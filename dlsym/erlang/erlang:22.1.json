{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/configure.in": "dnl Process this file with autoconf to produce a configure script. -*-m4-*-\n\ndnl %CopyrightBegin%\ndnl\ndnl Copyright Ericsson AB 1997-2019. All Rights Reserved.\ndnl\ndnl Licensed under the Apache License, Version 2.0 (the \"License\");\ndnl you may not use this file except in compliance with the License.\ndnl You may obtain a copy of the License at\ndnl\ndnl     http://www.apache.org/licenses/LICENSE-2.0\ndnl\ndnl Unless required by applicable law or agreed to in writing, software\ndnl distributed under the License is distributed on an \"AS IS\" BASIS,\ndnl WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\ndnl See the License for the specific language governing permissions and\ndnl limitations under the License.\ndnl\ndnl %CopyrightEnd%\n\ndnl The string \"FIXME convbreak\" means that there is a break of\ndnl autoconf convention that should be cleaned up.\n\nAC_INIT(vsn.mk)\nAC_PREREQ(2.59)\n\nLM_PRECIOUS_VARS\n\ndnl How to set srcdir absolute is taken from the GNU Emacs distribution\n#### Make srcdir absolute, if it isn't already.  It's important to\n#### avoid running the path through pwd unnecessary, since pwd can\n#### give you automounter prefixes, which can go away.\ncase \"${srcdir}\" in\n  /* ) ;;\n  . )\n    ## We may be able to use the $PWD environment variable to make this\n    ## absolute.  But sometimes PWD is inaccurate.\n    ## Make sure CDPATH doesn't affect cd (in case PWD is relative).\n    CDPATH=\n    if test \"${PWD}\" != \"\" && test \"`(cd ${PWD} ; sh -c pwd)`\" = \"`pwd`\"  ;\n    then\n      srcdir=\"$PWD\"\n    else\n      srcdir=\"`(cd ${srcdir}; pwd)`\"\n    fi\n  ;;\n  *  ) srcdir=\"`(cd ${srcdir}; pwd)`\" ;;\nesac\n\n## Now, make sure that ERL_TOP is set and is the same as srcdir\n##\nif test -z \"$ERL_TOP\" || test ! -d $ERL_TOP ; then\n  AC_MSG_ERROR(You need to set the environment variable ERL_TOP!)\nfi\nif test x\"${ERL_TOP}/erts\" != x\"$srcdir\"; then\n  AC_MSG_ERROR([You need to run configure with argument --srcdir=${ERL_TOP}/erts])\nfi\nerl_top=${ERL_TOP}\n\n# echo XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n# echo X\n# echo \"X srcdir  = $srcdir\"\n# echo \"X ERL_TOP = $ERL_TOP\"\n# echo X\n# echo XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nAC_CONFIG_AUX_DIRS($srcdir/autoconf)\n\ndnl ----------------------------------------------------------------------\ndnl Figure out what system we are running on.\ndnl ----------------------------------------------------------------------\n\n#\n# To configure for free source run ./configure --host=free_source\n#\ndnl\ndnl AC_CANONICAL_HOST does not like free_source as a host specification,\ndnl so we make a little special case.\ndnl\nif test \"X$host\" != \"Xfree_source\" -a \"X$host\" != \"Xwin32\"; then\n    AC_CANONICAL_HOST\nelse\n    host_os=$host\nfi\n\nif test \"$cross_compiling\" = \"yes\"; then\n    CROSS_COMPILING=yes\nelse\n    CROSS_COMPILING=no\nfi\nAC_SUBST(CROSS_COMPILING)\n\nERL_XCOMP_SYSROOT_INIT\n\nAC_ISC_POSIX\n\nAC_CONFIG_HEADER($host/config.h:config.h.in include/internal/$host/ethread_header_config.h:include/internal/ethread_header_config.h.in include/$host/erl_int_sizes_config.h:include/erl_int_sizes_config.h.in)\ndnl ----------------------------------------------------------------------\ndnl Optional features.\ndnl ----------------------------------------------------------------------\nENABLE_ALLOC_TYPE_VARS=\nAC_SUBST(ENABLE_ALLOC_TYPE_VARS)\n\nAC_ARG_ENABLE(bootstrap-only,\nAS_HELP_STRING([--enable-bootstrap-only],\n               [enable bootstrap only configuration]),\n[ if test \"X$enableval\" = \"Xyes\"; then\n\t# Disable stuff not necessary in a bootstrap only system in order\n\t# to speed up things by reducing the amount of stuff needing to be\n\t# built...\n\twith_termcap=no\n\twith_ssl=no\n\twith_ssl_zlib=no\n\tenable_hipe=no\n\tenable_sctp=no\n  fi\n])\n\nAC_ARG_ENABLE(dirty-schedulers-test,\nAS_HELP_STRING([--enable-dirty-schedulers-test], [enable dirty scheduler test (for debugging purposes)]),\n[ case \"$enableval\" in\n    yes)  enable_dirty_schedulers_test=yes ;;\n    *) enable_dirty_schedulers_test=no ;;\n  esac ], enable_dirty_schedulers_test=no)\n\nAC_ARG_ENABLE(smp-require-native-atomics,\n\t      AS_HELP_STRING([--disable-smp-require-native-atomics],\n                             [disable the SMP requirement of a native atomic implementation]),\n[ case \"$enableval\" in\n    no) smp_require_native_atomics=no ;;\n    *)  smp_require_native_atomics=yes ;;\n  esac ], smp_require_native_atomics=yes)\n\nAC_ARG_WITH(termcap,\nAS_HELP_STRING([--with-termcap], [use termcap (default)])\nAS_HELP_STRING([--without-termcap],\n               [do not use any termcap libraries (ncurses,curses,termcap,termlib)]),\n[],\n[with_termcap=yes])\n\nAC_ARG_ENABLE(lock-checking,\nAS_HELP_STRING([--enable-lock-checking], [enable lock checking]),\n[ case \"$enableval\" in\n    no) enable_lock_check=no ;;\n    *)  enable_lock_check=yes ;;\n  esac\n],\n  enable_lock_check=no)\n\nAC_ARG_ENABLE(lock-counter,\nAS_HELP_STRING([--enable-lock-counter], [enable lock counters]),\n[ case \"$enableval\" in\n    no) enable_lock_count=no ;;\n    *)  enable_lock_count=yes ;;\n  esac ], enable_lock_count=no)\n\nAC_ARG_ENABLE(kernel-poll,\nAS_HELP_STRING([--enable-kernel-poll], [enable kernel poll support])\nAS_HELP_STRING([--disable-kernel-poll], [disable kernel poll support]),\n[ case \"$enableval\" in\n    no) enable_kernel_poll=no ;;\n    *)  enable_kernel_poll=yes ;;\n  esac ], enable_kernel_poll=unknown)\n\n\nAC_ARG_ENABLE(sctp,\nAS_HELP_STRING([--enable-sctp], [enable sctp support (default)\nto on demand load the SCTP library in runtime if needed])\nAS_HELP_STRING([--enable-sctp=lib], [enable sctp support\nto link against the SCTP library])\nAS_HELP_STRING([--disable-sctp], [disable sctp support]),\n[ case \"x$enableval\" in\n      xno|xyes|xlib|x)\n          ;;\n      x*)\n          AC_MSG_ERROR(\"invalid value --enable-sctp=$enableval\")\n          ;;\n  esac ])\n\nAC_ARG_ENABLE(hipe,\nAS_HELP_STRING([--enable-hipe], [enable hipe support])\nAS_HELP_STRING([--disable-hipe], [disable hipe support]))\n\nAC_ARG_ENABLE(native-libs,\nAS_HELP_STRING([--enable-native-libs],\n               [compile Erlang libraries to native code]))\n\nAC_ARG_ENABLE(fp-exceptions,\nAS_HELP_STRING([--enable-fp-exceptions],\n               [use hardware floating point exceptions (default if hipe enabled)]),\n[ case \"$enableval\" in\n    no) enable_fp_exceptions=no ;;\n    *)  enable_fp_exceptions=yes ;;\n  esac\n],enable_fp_exceptions=auto)\n\nAC_ARG_ENABLE(m64-build,\nAS_HELP_STRING([--enable-m64-build],\n               [build 64bit binaries using the -m64 flag to (g)cc]),\n[ case \"$enableval\" in\n    no) enable_m64_build=no ;;\n    *)  enable_m64_build=yes ;;\n  esac\n],enable_m64_build=no)\n\nAC_ARG_ENABLE(m32-build,\nAS_HELP_STRING([--enable-m32-build],\n               [build 32bit binaries using the -m32 flag to (g)cc]),\n[ case \"$enableval\" in\n    no) enable_m32_build=no ;;\n    *)\tenable_m32_build=yes ;;\n  esac\n],enable_m32_build=no)\n\nAC_ARG_WITH(dynamic-trace,\nAS_HELP_STRING([--with-dynamic-trace={dtrace|lttng|systemtap}],\n\t       [specify use of dynamic trace framework, dtrace, lttng or systemtap])\nAS_HELP_STRING([--without-dynamic-trace], \n               [don't enable any dynamic tracing (default)]))\n\nif test X\"$with_dynamic_trace\" = X\"\"; then\n   with_dynamic_trace=no\nfi\n\ncase \"$with_dynamic_trace\" in\n     no) DYNAMIC_TRACE_FRAMEWORK=;;\n     lttng)\n            AC_DEFINE(USE_LTTNG,[1],\n                      [Define if you want to use lttng for dynamic tracing])\n            DYNAMIC_TRACE_FRAMEWORK=lttng;;\n     dtrace) \n\t    AC_DEFINE(USE_DTRACE,[1],\n\t\t[Define if you want to use dtrace for dynamic tracing])\n     \t     DYNAMIC_TRACE_FRAMEWORK=dtrace;;\n     systemtap) \n\t    AC_DEFINE(USE_SYSTEMTAP,[1],\n\t\t[Define if you want to use systemtap for dynamic tracing])\n\t    DYNAMIC_TRACE_FRAMEWORK=systemtap;;\n     *)\t\n     \t    AC_MSG_ERROR(Unknown dynamic tracing framework specified with --with-dynamic-trace!);;\nesac\n\nif test X\"$DYNAMIC_TRACE_FRAMEWORK\" != X\"\"; then\n   AC_DEFINE(USE_DYNAMIC_TRACE,[1],\n\t\t[Define if you want to use dynamic tracing])\nfi\n\nAC_ARG_ENABLE(vm-probes,\nAS_HELP_STRING([--enable-vm-probes],\n               [add dynamic trace probes to the Beam VM (only possible if --with-dynamic-trace is enabled, and then default)]),\n\t       [ case \"$enableval\" in\n    \t       \t no) use_vm_probes=no ;;\n    \t\t *)\n\t\t\tif  test X\"$DYNAMIC_TRACE_FRAMEWORK\" != X\"\"; then\n\t\t \t    use_vm_probes=yes ;\n\t\t\telse\n\t\t\t    AC_MSG_ERROR(Can not enable VM probes without any dynamic tracing framework!);\n\t\t\tfi;;  \n  \t\t esac ], if  test X\"$DYNAMIC_TRACE_FRAMEWORK\" != X\"\"; then\n\t\t \t    use_vm_probes=yes ;\n\t\t\telse\n\t\t\t    use_vm_probes=no\n\t\t\tfi)\n\nAC_SUBST(USE_VM_PROBES)\nif test X\"$DYNAMIC_TRACE_FRAMEWORK\" != X\"lttng\"; then\n    if test X\"$use_vm_probes\" = X\"yes\"; then\n        USE_VM_PROBES=yes\n        AC_DEFINE(USE_VM_PROBES,[1],\n                  [Define to enable VM dynamic trace probes])\n    fi\nfi\n\nAC_ARG_WITH(assumed-cache-line-size,\nAS_HELP_STRING([--with-assumed-cache-line-size=SIZE],\n               [specify assumed cache line size in bytes (valid values are powers of two between and including 16 and 8192; default is 64)]))\n\ndnl Require the assumed cache-line size to be a power of two between 16 and 8192\ncase \"$with_assumed_cache_line_size\" in\n     \"\"|no|yes)\n\twith_assumed_cache_line_size=64;;\n     16|32|64|128|256|512|1024|2048|4096|8192)\n\t;;\n     *)\n\tAC_MSG_ERROR([Invalid assumed cache-line size of $with_assumed_cache_line_size bytes])\n\t;;\nesac\n\nAC_DEFINE_UNQUOTED(ASSUMED_CACHE_LINE_SIZE,\n\t\t   $with_assumed_cache_line_size,\n\t\t   [Assumed cache-line size (in bytes)])\n\nAC_ARG_ENABLE(systemd,\nAS_HELP_STRING([--enable-systemd], [enable systemd support in epmd]),\n[],\n[enable_systemd=no])\n\nAC_ARG_ENABLE(saved-compile-time,\nAS_HELP_STRING([--disable-saved-compile-time], [disable saved compile time]),\n[ case \"$enableval\" in\n    no) save_compile_time=0 ;;\n    *)  save_compile_time=1 ;;\n  esac ], save_compile_time=1)\n\nAC_DEFINE_UNQUOTED(ERTS_SAVED_COMPILE_TIME, $save_compile_time, [Save compile time?])\n\nAC_ARG_WITH(microstate-accounting,\nAS_HELP_STRING([--with-microstate-accounting={yes|extra}],\n               [enable microstate account, possibly with extra detailed states])\nAS_HELP_STRING([--without-microstate-accounting],\n               [don't enable microstate accounting]),\n[],[with_microstate_accounting=yes])\n\ncase \"$with_microstate_accounting\" in\n    yes) AC_DEFINE(ERTS_ENABLE_MSACC,[1],\n\t\t[Define as 1 if you want to enable microstate accounting, 2 if you want extra states]) ;;\n    extra) AC_DEFINE(ERTS_ENABLE_MSACC,[2],\n\t\t[Define as 1 if you want to enable microstate accounting, 2 if you want extra states]) ;;\n    *) ;;\nesac\n\ndnl Magic test for clearcase.\nOTP_RELEASE=\nif test \"${ERLANG_COMMERCIAL_BUILD}\" != \"\"; then\n\tOTP_EXTRA_FLAGS=-DOTP_RELEASE\n\tOTP_RELEASE=yes\nelse\n\tOTP_EXTRA_FLAGS=\nfi\nAC_SUBST(OTP_RELEASE)\n\nAC_MSG_CHECKING([OTP release])\n[SYSTEM_VSN=`cat $ERL_TOP/OTP_VERSION | sed \"s|\\([0-9]*\\).*|\\1|\"`]\nAC_MSG_RESULT([$SYSTEM_VSN])\nAC_SUBST(SYSTEM_VSN)\n\nAC_MSG_CHECKING([OTP version])\n[OTP_VERSION=`cat $ERL_TOP/OTP_VERSION`]\nAC_MSG_RESULT([$OTP_VERSION])\nAC_SUBST(OTP_VERSION)\n\nif test X${enable_m64_build} = Xyes; then\n\tcase $CFLAGS in\n\t\t*-m64*)\n\t\t\t;;\n\t\t*)\n\t\t\tCFLAGS=\"-m64 $CFLAGS\"\n\t\t\t;;\n\tesac\nelse\n\tif test X${enable_m32_build} = Xyes;\n\tthen\n\t\tcase $CFLAGS in\n\t\t    *-m32*)\n\t\t\t    ;;\n\t\t    *)\n\t\t\t    CFLAGS=\"-m32 $CFLAGS\"\n\t\t\t    ;;\n\t\tesac ;\n\tfi\nfi\n\nAC_ARG_ENABLE(static-nifs,\nAS_HELP_STRING([--enable-static-nifs], [link nifs statically. If yes then all nifs in all Erlang/OTP applications will be statically linked into the main binary. It is also possible to give a list of nifs that should be linked statically. The list should be a comma separated and contain the absolute path to a .a archive for each nif that is to be statically linked. The name of the .a archive has to be the same as the name of the nif. Note that you have to link any external dependencies that the nifs have to the main binary, so for the crypto nif you want to pass LIBS=-lcrypto to configure.]),\n\t       STATIC_NIFS=\"$enableval\",\n\t       STATIC_NIFS=no)\nAC_SUBST(STATIC_NIFS)\n\nAC_ARG_ENABLE(static-drivers,\nAS_HELP_STRING([--enable-static-drivers], [comma separated list of linked-in drivers to link statically with the main binary. The list should contain the absolute path to a .a archive for each driver that is to be statically linked. The name of the .a archive has to be the same as the name of the driver.]),\n\t       STATIC_DRIVERS=\"$enableval\",\n\t       STATIC_DRIVERS=no)\nAC_SUBST(STATIC_DRIVERS)\n\nAC_ARG_WITH(ets-write-concurrency-locks,\nAS_HELP_STRING([--with-ets-write-concurrency-locks={8|16|32|64|128|256}],\n               [specify how many locks the write_concurrency option for ets should use.])\nAS_HELP_STRING([--without-ets-write-concurrency-locks],\n               [use the default number of write_concurrency locks (default)]))\n\nif test X\"$with_ets_write_concurrency_locks\" != X\"\"; then\n   AC_DEFINE_UNQUOTED(ERTS_DB_HASH_LOCK_CNT,$with_ets_write_concurrency_locks,\n\t\t      [Define to override the default number of write_concurrency locks])\nfi\n\nAC_ARG_WITH(spectre-mitigation,\n    AS_HELP_STRING([--with-spectre-mitigation={yes|incomplete}],\n                   [enable spectre mitigation, either fully or with mitigations\n                    disabled in a handful places like the interpreter])\n    AS_HELP_STRING([--without-spectre-mitigation],\n                   [build without spectre mitigation]),\n    [],[with_spectre_mitigation=no])\n\ncase \"$with_spectre_mitigation\" in\n    no) ;;\n    yes) ;;\n    incomplete) ;;\n    *) AC_MSG_ERROR([Invalid spectre mitigation setting]) ;;\nesac\n\ni_noretpoline_attr=\"\"\n\nif test X\"$with_spectre_mitigation\" != X\"no\"; then\n    CFLAGS=\"$CFLAGS -mindirect-branch=thunk\"\n\n    AC_MSG_CHECKING([for spectre mitigation])\n    AC_COMPILE_IFELSE(\n        [AC_LANG_PROGRAM([],[return 0;])],\n        [AC_MSG_RESULT([yes])],\n        [AC_MSG_ERROR([no])])\n\n    if test X\"$with_spectre_mitigation\" = X\"incomplete\"; then\n        # gcc and clang support this attribute if they're recent enough. Note\n        # that we must compile with -Werror to check for actual support as they\n        # warn rather than error out on unsupported attributes.\n\n        i_noretpoline_attr='__attribute__((__indirect_branch__(\"keep\")))'\n        i_preserve_cflags=\"$CFLAGS\"\n        CFLAGS=\"$CFLAGS -Werror\"\n\n        AC_MSG_CHECKING([whether spectre mitigation can be disabled on a per-function basis])\n        AC_COMPILE_IFELSE(\n            [AC_LANG_PROGRAM([$i_noretpoline_attr],[return 0;])],\n            [AC_MSG_RESULT([yes])],\n            [AC_MSG_ERROR([no])])\n\n        CFLAGS=\"$i_preserve_cflags\"\n    fi\nfi\n\nAC_DEFINE_UNQUOTED(ERTS_NO_RETPOLINE, $i_noretpoline_attr,\n                   [Per-function attribute for disabling retpoline. This is\n                    *only* defined when --with-spectre-mitigation=incomplete\n                    and has no effects otherwise])\n\ndnl ----------------------------------------------------------------------\ndnl Checks for programs.\ndnl ----------------------------------------------------------------------\n\nAC_PROG_CC\nAC_SUBST(GCC)\n\ndnl ---------------------------------------------------------------------\ndnl Special stuff regarding CFLAGS and details in the environment...\ndnl ---------------------------------------------------------------------\n\ndnl NOTE: CPPFLAGS will be included in CFLAGS at the end\ncase $host_os in\n    linux*) CPPFLAGS=\"$CPPFLAGS -D_GNU_SOURCE\";; \n    win32)\n\t# The ethread library requires _WIN32_WINNT of at least 0x0403.\n\t# -D_WIN32_WINNT=* from CPPFLAGS is saved in ETHR_DEFS.\n\tCPPFLAGS=\"$CPPFLAGS -D_WIN32_WINNT=0x0600 -DWINVER=0x0600\"\n\t;;\n    *)\n\t;;\nesac\n\n\nLM_WINDOWS_ENVIRONMENT\n\t\ndnl\ndnl Flags to the C compiler\ndnl\ndnl Make sure we find config.h\ndnl\n\nERTS_CONFIG_H_IDIR=\"-I${ERL_TOP}/erts/$host\"\nAC_SUBST(ERTS_CONFIG_H_IDIR)\n\nextra_flags=\"$ERTS_CONFIG_H_IDIR $OTP_EXTRA_FLAGS\"\nCFLAGS=\"$CFLAGS $extra_flags\"\nDEBUG_CFLAGS=\"-g $CPPFLAGS $extra_flags $DEBUG_CFLAGS\"\nDEBUG_FLAGS=-g\n\ndnl\ndnl Adjust DEBUG_CFLAGS to match CFLAGS in terms of -m\ndnl\n\ncase $CFLAGS in\n\t*-m64*)\n\t\tcase $DEBUG_CFLAGS in\n\t\t\t*-m64*)\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tDEBUG_CFLAGS=\"-m64 $DEBUG_CFLAGS\"\n\t\t\t\t;;\n\t\tesac\n\t\t;;\n\t*-m32*)\n\t\tcase $DEBUG_CFLAGS in\n\t\t\t*-m32*)\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tDEBUG_CFLAGS=\"-m32 $DEBUG_CFLAGS\"\n\t\t\t\t;;\n\t\tesac\n\t\t;;\n\t*)\n\t\t;;\nesac\n\nlfs_conf=ok\nlfs_source=none\nif test \"${LFS_CFLAGS+set}\" = \"set\" || \\\n   test \"${LFS_LDFLAGS+set}\" = \"set\" || \\\n   test \"${LFS_LIBS+set}\" = \"set\"; then\n    lfs_source=user\nelse\n   LM_CHECK_GETCONF\n   test \"$GETCONF\" = \"false\" || lfs_source=getconf\nfi\n\nif test \"$lfs_source\" = \"none\"; then\n    AC_MSG_WARN([Do not know how to check for large file support flags; no getconf is available])\nelse\n    for var in CFLAGS LDFLAGS LIBS; do\n\tAC_MSG_CHECKING([for large file support $var])\n\tif test $lfs_source = user; then\n\t    eval \"lfs_val=\\\"\\$LFS_$var\\\"\"\n\telse\n\t    eval \"lfs_var=LFS_$var\"\n\t    lfs_val=`$GETCONF $lfs_var 2>/dev/null` || lfs_conf=failed\n\t    if test $lfs_conf = failed; then\n\t\tAC_MSG_RESULT([failed])\n\t\tbreak\n\t    fi\n\t    eval \"$lfs_var=\\\"$lfs_val\\\"\"\n\tfi\n\ttest \"$lfs_val\" != \"\" || lfs_val=none\n\tAC_MSG_RESULT([$lfs_val])\n    done\n    if test $lfs_conf = failed; then\n\tAC_MSG_WARN([Check for large file support flags failed; $GETCONF failed])\n    else\n\tCFLAGS=\"$CFLAGS $LFS_CFLAGS\"\n\tDEBUG_CFLAGS=\"$DEBUG_CFLAGS $LFS_CFLAGS\"\n\tLDFLAGS=\"$LDFLAGS $LFS_LDFLAGS\"\n\tLIBS=\"$LIBS $LFS_LIBS\"\n    fi\nfi\n\nif test \"x$GCC\" = xyes; then\n  # Treat certain GCC warnings as errors\n  LM_TRY_ENABLE_CFLAG([-Werror=return-type], [WERRORFLAGS])\n  LM_TRY_ENABLE_CFLAG([-Werror=implicit], [WERRORFLAGS])\n  LM_TRY_ENABLE_CFLAG([-Werror=undef], [WERRORFLAGS])\n\n  # until the emulator can handle this, I suggest we turn it off!\n  #WFLAGS=\"-Wall -Wshadow -Wcast-qual -Wmissing-declarations\"\n  WFLAGS=\"-Wall -Wstrict-prototypes\"\n\n  case \"$host_cpu\" in\n    tile*)\n      # tile-gcc is a bit stricter with -Wmissing-prototypes than other gccs,\n      # and too strict for our taste.\n      ;;\n    *)\n      WFLAGS=\"$WFLAGS -Wmissing-prototypes\";;\n  esac\n\n  saved_CFLAGS=$CFLAGS\n  CFLAGS=\"$CFLAGS -Wdeclaration-after-statement\"\n  AC_TRY_COMPILE([],[;], warn_decl_after_st=true, warn_decl_after_st=false)\n  if test \"X$warn_decl_after_st\" = \"Xtrue\"; then\n    WFLAGS=\"$WFLAGS -Wdeclaration-after-statement\"\n  fi\n  CFLAGS=$saved_CFLAGS\nelse\n  WFLAGS=\"\"\n  WERRORFLAGS=\"\"\nfi\n\nAC_MSG_CHECKING([CFLAGS for -O switch])\ncase \"$CFLAGS\" in\n     *-O*) AC_MSG_RESULT([yes]) ;;\n     *)\n       AC_MSG_ERROR([\n  CFLAGS must contain a -O flag. If you need to edit the CFLAGS you probably\n  also want to add the default CFLAGS. The default CFLAGS are \"-O2 -g\".\n  If you want to build erts without any optimization, pass -O0 to CFLAGS.]) ;;\nesac\n\ndnl DEBUG_FLAGS is obsolete (I hope)\nAC_SUBST(DEBUG_FLAGS)\nAC_SUBST(DEBUG_CFLAGS)\nAC_SUBST(WFLAGS)\nAC_SUBST(WERRORFLAGS)\n\n## Check if we can do profile guided optimization of beam_emu\nLM_CHECK_ENABLE_CFLAG([-fprofile-generate -Werror],[PROFILE_GENERATE])\nLM_CHECK_ENABLE_CFLAG([-fprofile-use -Werror],[PROFILE_USE])\nLM_CHECK_ENABLE_CFLAG([-fprofile-use -fprofile-correction -Werror],[PROFILE_CORRECTION])\n\nif test \"X$PROFILE_CORRECTION\" = \"Xtrue\"; then\n   saved_CFLAGS=$CFLAGS\n   saved_LDFLAGS=$LDFLAGS\n   CFLAGS=\"-fprofile-generate $saved_CFLAGS\"\n   LDFLAGS=\"-fprofile-generate $saved_LDFLAGS\"\n   AC_MSG_CHECKING([whether $CC links with -fprofile-generate])\n   AC_LINK_IFELSE([AC_LANG_PROGRAM([],[return 0;])],\n        [AC_MSG_RESULT([yes])\n         PROFILE_GENERATE=true],\n        [AC_MSG_RESULT([no])\n         PROFILE_GENERATE=false])\n   CFLAGS=$saved_CFLAGS\n   LDFLAGS=$saved_LDFLAGS\nfi\n\n## Check if this is clang\nLM_CHECK_ENABLE_CFLAG([-fprofile-instr-generate -Werror],[PROFILE_INSTR_GENERATE])\nif test \"X$PROFILE_INSTR_GENERATE\" = \"Xtrue\"; then\n   # It was clang, now we also have to check if we have llvm-profdata and that\n   # we can link programs with -fprofile-instr-use\n   saved_CFLAGS=$CFLAGS;\n   CFLAGS=\"-fprofile-instr-generate -Werror $saved_CFLAGS\"\n   AC_RUN_IFELSE([AC_LANG_PROGRAM([],[])],\n     [AC_CHECK_PROGS([LLVM_PROFDATA], [llvm-profdata])\n      AC_CHECK_PROGS([XCRUN], [xcrun])\n      if test \"X$XCRUN\" != \"X\" -a \"X$LLVM_PROFDATA\" = \"X\"; then\n        AC_MSG_CHECKING([for $XCRUN llvm-profdata])\n        if $XCRUN llvm-profdata --help 2>& AS_MESSAGE_LOG_FD >& AS_MESSAGE_LOG_FD; then\n          LLVM_PROFDATA=\"$XCRUN llvm-profdata\"\n          AC_MSG_RESULT([yes])\n        else\n          AC_MSG_RESULT([no])\n        fi\n      fi\n      AC_SUBST(LLVM_PROFDATA)\n      if test \"X$LLVM_PROFDATA\" != \"X\"; then\n        CFLAGS=\"-fprofile-instr-use=default.profdata -Werror $saved_CFLAGS\";\n        $LLVM_PROFDATA merge -output=default.profdata *.profraw;\n        AC_MSG_CHECKING([whether $CC accepts -fprofile-instr-use=default.profdata -Werror])\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],[return 0;])],\n          [AC_MSG_RESULT([yes])\n           PROFILE_INSTR_USE=true],\n          [AC_MSG_RESULT([no])\n           PROFILE_INSTR_USE=false])\n        rm -f default.profdata\n      fi],\n     [],\n     [AC_MSG_NOTICE([Disabling PGO when cross-compiling])])\n   rm -f *.profraw\n   CFLAGS=$saved_CFLAGS;\nfi\n\nAC_ARG_ENABLE(pgo,\nAS_HELP_STRING([--enable-pgo],\n               [build erts using PGO (profile guided optimization)]),\n[ case \"$enableval\" in\n    no) enable_pgo=no ;;\n    *)\tenable_pgo=yes ;;\n  esac\n],enable_pgo=default)\n\nUSE_PGO=false\nAC_MSG_CHECKING([whether to do PGO of erts])\nif test $enable_pgo = no; then\n  AC_MSG_RESULT([no, disabled by user])\nelif test $CROSS_COMPILING = yes; then\n  if test $enable_pgo = yes; then\n    AC_MSG_ERROR(cannot use PGO when cross-compiling)\n  else\n    AC_MSG_RESULT([no, cross compiling])\n  fi\nelif test \"X$host\" = \"Xwin32\"; then\n  AC_MSG_RESULT([no, not supported in windows])\nelif test \"X$PROFILE_GENERATE\" = \"Xtrue\" -a \"X$PROFILE_USE\" = \"Xtrue\" -a \"X$PROFILE_CORRECTION\" = \"Xtrue\"; then\n  ## We need -fprofile-generate and -fprofile-correction support to use PGO with\n  ## gcc as multiple threads run within the executed object files\n  USE_PGO=true\n  PROFILE_COMPILER=gcc\n  AC_MSG_RESULT([yes, using -fprofile-generate -fprofile-correction])\nelif test \"X$PROFILE_INSTR_GENERATE\" = \"Xtrue\" -a \"X$PROFILE_INSTR_USE\" = \"Xtrue\"; then\n  USE_PGO=true\n  PROFILE_COMPILER=clang\n  AC_MSG_RESULT([yes, using -fprofile-instr-generate])\nelse\n  if test $enable_pgo = yes; then\n    AC_MSG_ERROR(cannot use PGO with this compiler)\n  else\n    AC_MSG_RESULT([no])\n  fi\nfi\n\nAC_SUBST(USE_PGO)\nAC_SUBST(PROFILE_COMPILER)\n\nAC_CHECK_SIZEOF(void *) # Needed for ARCH and smp checks below\nif test \"x$ac_cv_sizeof_void_p\" = x8; then\n  AC_SUBST(EXTERNAL_WORD_SIZE, 64)\nelse\n  AC_SUBST(EXTERNAL_WORD_SIZE, 32)\nfi\n\ndnl\ndnl Figure out operating system and cpu architecture\ndnl\n\nif test \"x$host_alias\" != \"x\"; then\n    chk_opsys_=$host_os\nelse\n    chk_opsys_=`uname -s`\n    if test \"x$chk_opsys_\" = \"xSunOS\"; then\n\tchk_opsys_=$chk_opsys_`uname -r`\n    fi\nfi\ncase $chk_opsys_ in\n    win32)\t\t\tOPSYS=win32;;\n    solaris2.*|SunOS5.*)\tOPSYS=sol2;;\n    linux*|Linux)\t\tOPSYS=linux;;\n    darwin|Darwin)\t\tOPSYS=darwin;;\n    freebsd|FreeBSD)\t\tOPSYS=freebsd;;\n    *)\t\t\t\tOPSYS=noopsys\nesac\n\nAC_SUBST(OPSYS)\n\nLM_HARDWARE_ARCH\n\ndnl Check consistency of os and darwin-switches\n\n\ndnl Take care of LDFLAGS on darwin, and disable common_test as it\ndnl has a build/configure system re rx-lib that is not compatible\ndnl First remove common_tests skip file.\n\ndnl Adjust LDFLAGS to allow 64bit linkage on DARWIN\ncase $ARCH-$OPSYS in\n\tamd64-darwin*)\n\t\tAC_MSG_NOTICE([Adjusting LDFLAGS to cope with 64bit Darwin])\n\t\tcase $LDFLAGS in\n\t\t\t*-m64*)\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tLDFLAGS=\"-m64 $LDFLAGS\"\n\t\t\t;;\n\t\tesac\n\t\t;;\n\t*-darwin*)\n\t\tcase $LDFLAGS in\n\t\t\t*-m32*)\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tLDFLAGS=\"-m32 $LDFLAGS\"\n\t\t\t\t;;\n\t\tesac\n\t\t;;\n\t*)\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tAC_MSG_NOTICE([Adjusting LDFLAGS to use -m64])\n\t\t\tcase $LDFLAGS in\n\t\t\t\t*-m64*)\n\t\t\t\t\t;;\n\t\t\t\t*)\n\t\t\t\t\tLDFLAGS=\"-m64 $LDFLAGS\"\n\t\t\t\t;;\n\t\t\tesac\n\t\tfi;\n\t\tif test X${enable_m32_build} = Xyes; then\n\t\t\tAC_MSG_NOTICE([Adjusting LDFLAGS to use -m32]) ;\n\t\t\tcase $LDFLAGS in\n\t\t\t\t*-m32*)\n\t\t\t\t\t;;\n\t\t\t\t*)\n\t\t\t\t\tLDFLAGS=\"-m32 $LDFLAGS\"\n\t\t\t\t;;\n\t\t\tesac ;\n\t\tfi\n\t\t;;\nesac\n\nAC_MSG_CHECKING(if VM has to be linked with Carbon framework)\ncase $ARCH-$OPSYS in\n\t*-darwin*)\n  \t\tLIBCARBON=\"-framework Carbon -framework Cocoa\"\n\t\tAC_MSG_RESULT([yes])\n\t\t;;\n\t*)\n\t\tLIBCARBON=\n\t\tAC_MSG_RESULT([no])\n\t\t;;\nesac\n\t\nAC_SUBST(LIBCARBON)\n\n_search_path=/bin:/usr/bin:/usr/local/bin:$PATH\n\nAC_PATH_PROG(MKDIR, mkdir, false, $_search_path)\nif test \"$ac_cv_path_MKDIR\" = false; then\n  AC_MSG_ERROR([No 'mkdir' command found])\nfi\n\nAC_PATH_PROG(CP, cp, false, $_search_path)\nif test \"$ac_cv_path_CP\" = false; then\n  AC_MSG_ERROR([No 'cp' command found])\nfi\n\n_search_path=\n\n\n# Remove old configuration information.\n# Next line should be before first output to CONN_INFO. So this is\n# just the right place.\nrm -f \"$ERL_TOP/erts/CONF_INFO\"\n\ndnl Check if we should/can build a sharing-preserving emulator\nAC_MSG_CHECKING(if we are building a sharing-preserving emulator)\nif test \"$enable_sharing_preserving\" = \"yes\"; then\n        AC_DEFINE(SHCOPY, [1],\n\t\t  [Define if building a sharing-preserving emulator])\n\tAC_MSG_RESULT([yes])\nelse\n\tAC_MSG_RESULT([no])\nfi\n\n\ndnl some tests below will call this if we haven't already - and autoconf\ndnl can't handle those tests being done conditionally at runtime\nAC_PROG_CPP\n\nAC_PROG_RANLIB\n\nAC_PROG_YACC\nLM_PROG_PERL5\nif test \"$ac_cv_path_PERL\" = false; then\n  AC_MSG_ERROR([Perl version 5 is required to build the emulator!])\nfi\nAC_PROG_LN_S\n\n\nAC_CHECK_TOOL([AR], [ar], [false])\nif test \"$ac_cv_prog_AR\" = false; then\n  AC_MSG_ERROR([No 'ar' command found in PATH])\nfi\n\n#\n# Get programs needed for building the documentation \n#\n\n## Delete previous failed configure results\nif test -f doc/CONF_INFO; then\n   rm -f doc/CONF_INFO\nfi\n\nAC_CHECK_PROGS(XSLTPROC, xsltproc)\nif test -z \"$XSLTPROC\"; then\n  echo \"xsltproc\" >> doc/CONF_INFO\n  AC_MSG_WARN([No 'xsltproc' command found: the documentation cannot be built])\nfi\n\nAC_CHECK_PROGS(FOP, fop)\nif test -z \"$FOP\"; then\n  FOP=\"$ERL_TOP/make/fakefop\"\n  echo \"fop\" >> doc/CONF_INFO\n  AC_MSG_WARN([No 'fop' command found: going to generate placeholder PDF files])\nfi\n\nAC_CHECK_PROGS(XMLLINT, xmllint)\nif test -z \"$XMLLINT\"; then\n  echo \"xmllint\" >> doc/CONF_INFO\n  AC_MSG_WARN([No 'xmllint' command found: can't run the xmllint target for the documentation])\nfi\n\ndnl\ndnl We can live with Solaris /usr/ucb/install\ndnl\ncase $host in\n  *-*-solaris*|free_source)\n    if test -x /usr/ucb/install; then\n      INSTALL=\"/usr/ucb/install -c\"\n    fi\n    ;;\n  *)\n    ;;\nesac\nAC_PROG_INSTALL\nLM_PROG_INSTALL_DIR\n\ncase $host_os in\n\tdarwin*)\n\t\tdnl Need to preserve modification time on archives;\n\t\tdnl otherwise, ranlib has to be run on archives\n\t\tdnl again after installation.\n\t\tINSTALL_DATA=\"$INSTALL_DATA -p\";;\n\t*)\n\t\t;;\nesac\n\ndnl\ndnl Fix for Tilera install permissions\ndnl\n\ncase $build in\n\t*tile*)\n\t\tINSTALL_PROGRAM=\"$INSTALL_PROGRAM -m755\"\n\t\tINSTALL_SCRIPT=\"$INSTALL_SCRIPT -m755\"\n\t\t;;\n\t*)\n\t\t;;\nesac\n\ndnl ----------------------------------------------------------------------\ndnl Misc. things (some of them should go away)\ndnl ----------------------------------------------------------------------\n\ndnl\ndnl An attempt to allow cross compiling. This is not the right way,\ndnl nor does it work currently. Some makefiles still needs these\ndnl variables, so we leave them in for now.\ndnl\nHCC='$(CC)'         AC_SUBST(HCC)\nHCFLAGS=\"\"          AC_SUBST(HCFLAGS)\nHCFLAGS=\"$HCFLAGS -I${ERL_TOP}/erts/$host\"\nvxworks_reclaim=\"\"  AC_SUBST(vxworks_reclaim)\n\ndnl We want to use $(CC) as linker for the emulator regardless of\ndnl what the user say. This might not be the right way to do it, but\ndnl for now that is the way we do it.\nUSER_LD=$LD\nUSER_LDFLAGS=\"$LDFLAGS\"\nLD='$(CC)'\ncase $host_os in\n     darwin*)\n\tsaved_LDFLAGS=\"$LDFLAGS\"\n\tLDFLAGS=\"$LDFLAGS -Wl,-no_weak_imports\"\n\tAC_TRY_LINK([],[],\n\t\t[\n\t\t\tLD_MAY_BE_WEAK=no\n\t\t],\n\t\t[\n\t\t\tLD_MAY_BE_WEAK=yes\n\t\t\tLDFLAGS=\"$saved_LDFLAGS\"\n\t\t]);;\n    *)\n\tLD_MAY_BE_WEAK=no;;\nesac\n\nAC_SUBST(LD)\n\ndnl Check for cygwin and object/exe files extension\ndnl AC_CYGWIN is deprecated\nAC_EXEEXT\nAC_OBJEXT\n\ndnl This is the os flavour, should be unix, ose, vxworks or win32\ncase $host in\n   win32)\n      ERLANG_OSTYPE=win32 ;;\n   *)\n      ERLANG_OSTYPE=unix ;;\nesac\n\nAC_SUBST(ERLANG_OSTYPE)\n\n# Check how to export functions from the emulator executable, needed\n# when dynamically loaded drivers are loaded (so that they can find\n# emulator functions).\n# OS'es with ELF executables using the GNU linker (Linux and recent *BSD,\n# in rare cases Solaris) typically need '-Wl,-export-dynamic' (i.e. pass\n# -export-dynamic to the linker - also known as -rdynamic and some other\n# variants); some sysVr4 system(s) instead need(s) '-Wl,-Bexport'.\n# AIX 4.x (perhaps only for x>=2) wants -Wl,-bexpall,-brtl and doesn't\n# reliably return an error for others, thus we separate it out.\n# Otherwise we assume that if the linker accepts the flag, it is needed.\nAC_MSG_CHECKING(for extra flags needed to export symbols)\nDEXPORT=\"\"\ncase $host_os in\n\taix4*)\n\t\tDEXPORT=-Wl,-bexpall,-brtl\n\t;;\n\tbsdi*)\n    \t\tDEXPORT=\"-rdynamic \" \n    \t;;\n\twin32)\n    \t\tDEXPORT=\"\" \n    \t;;\n\t*)\n\t\tsave_ldflags=\"$LDFLAGS\"\n\t\tLDFLAGS=-Wl,-export-dynamic\n\t\tAC_TRY_LINK(,,[DEXPORT=-Wl,-export-dynamic], [\n\t\t\tLDFLAGS=-Wl,-Bexport\n\t\t\tAC_TRY_LINK(,,[DEXPORT=-Wl,-Bexport],\n\t\t\t\tAC_MSG_RESULT(none))])\n\t\tLDFLAGS=\"$save_ldflags\"\n\t;;\nesac\nAC_SUBST(DEXPORT)\ncase \"x$DEXPORT\" in\n\t\"x\")\n\t\tAC_MSG_RESULT([none]);;\n\t*)\n\t\tAC_MSG_RESULT([$DEXPORT]);;\nesac\n\n# Check for Solaris/ultrasparc /dev/perfmon interface\n# (also needs gcc specific asm instructions)\ncase \"${host}:${GCC}\" in\n  sparc-*-solaris*:yes)\n    AC_DEFINE(HAVE_SOLARIS_SPARC_PERFMON,[1],\n\t[define if you have the Solaris/ultrasparc /dev/perfmon interface])\n    ;;\n  *)\n    ;;\nesac\n\n\ndnl ----------------------------------------------------------------------\ndnl Checks for libraries.\ndnl ----------------------------------------------------------------------\n\nAC_CHECK_LIB(m, sin)\nAC_CHECK_LIB(dl, dlopen)\nAC_CHECK_LIB(inet, main)\nAC_CHECK_LIB(util, openpty)\n\ndnl Try to find a thread library.\ndnl\ndnl ETHR_LIB_NAME, ETHR_LIBS, ETHR_X_LIBS, ETHR_THR_LIB_BASE and ETHR_DEFS\ndnl are set by ERL_FIND_ETHR_LIB\nERL_FIND_ETHR_LIB\n\nif test \"X$ETHR_LIB_NAME\" = \"X\"; then\n   AC_MSG_ERROR([cannot build emulator since no thread library was found])\nfi\n\nTYPES=opt\n\nDIRTY_SCHEDULER_TEST=$enable_dirty_schedulers_test\nAC_SUBST(DIRTY_SCHEDULER_TEST)\ntest $DIRTY_SCHEDULER_TEST != yes || {\n    test -f \"$ERL_TOP/erts/CONF_INFO\" || echo \"\" > \"$ERL_TOP/erts/CONF_INFO\"\n    cat >> $ERL_TOP/erts/CONF_INFO <<EOF\n\n                 WARNING:\n                   Dirty Scheduler Test has been enabled. This\n                   feature is for debugging purposes only.\n                   Poor performance as well as strange system\n                   characteristics is expected!\n\nEOF\n}\n\ntest \"X$smp_require_native_atomics\" = \"Xyes\" &&\n     AC_DEFINE(ETHR_SMP_REQUIRE_NATIVE_IMPLS, 1, [Define if you want to enable check for native ethread implementations])\n\ncase \"$ethr_have_native_atomics-$smp_require_native_atomics-$ethr_have_native_spinlock\" in\n  yes-*)\n\tif test \"$ethr_native_atomic_implementation\" = \"gcc_sync\"; then\n\t    test -f \"$ERL_TOP/erts/CONF_INFO\" ||\n\t\techo \"\" > \"$ERL_TOP/erts/CONF_INFO\"\n\t    cat >> $ERL_TOP/erts/CONF_INFO <<EOF\n\n                 WARNING:\n                   Only gcc's __sync_* builtins available for\n                   atomic memory access. This will cause lots\n                   of expensive and unnecessary memory barrier\n                   instructions to be issued which will make\n                   the performance of the runtime system\n                   suffer. You are *strongly* advised to\n                   upgrade to a gcc version that supports the\n                   __atomic_* builtins (at least gcc version\n                   4.7) or build with libatomic_ops. See the\n                   \"Atomic Memory Operations and the VM\"\n\t\t   chapter of \\$ERL_TOP/HOWTO/INSTALL.md for\n                   more information.\n\nEOF\n\tfi\n\t;;\n\n  no-yes-*)\n\tAC_MSG_ERROR([No native atomic implementation found. See the \\\"Atomic Memory Operations and the VM\\\" chapter of \\$ERL_TOP/HOWTO/INSTALL.md for more information.])\n\t;;\n\n  no-no-yes)\n\n\ttest -f \"$ERL_TOP/erts/CONF_INFO\" ||\n\t    echo \"\" > \"$ERL_TOP/erts/CONF_INFO\"\n\tcat >> $ERL_TOP/erts/CONF_INFO <<EOF\n\n                 No native atomic implementation available.\n                 Fallbacks implemented using spinlocks will be\n                 used. Note that the performance of the SMP\n                 runtime system will suffer immensely due to\n\t\t this.\n\nEOF\n\t;;\n\n  no-no-no)\n\ttest -f \"$ERL_TOP/erts/CONF_INFO\" ||\n\t    echo \"\" > \"$ERL_TOP/erts/CONF_INFO\"\n\tcat >> \"$ERL_TOP/erts/CONF_INFO\" <<EOF\n\n                 No native atomic implementation, nor no native\n                 spinlock implementation available. Fallbacks\n                 implemented using mutexes will be used. Note\n                 that the performance of the SMP runtime system\n                 will suffer immensely due to this.\n\nEOF\n\t;;\n\nesac\nAC_SUBST(TYPES)\n\nAC_CHECK_FUNCS([posix_fadvise closefrom])\nAC_CHECK_HEADERS([linux/falloc.h])\ndnl * Old glibcs have broken fallocate64(). Make sure not to use it.\nAC_CACHE_CHECK([whether fallocate() works],i_cv_fallocate_works,[\n    AC_TRY_LINK([\n        #include <stdio.h>\n        #include <stdlib.h>\n        #include <fcntl.h>\n        #include <unistd.h>\n\t#include <fcntl.h>\n\t#include <linux/falloc.h>\n\t],\n        [\t            \n\tint fd = creat(\"conftest.temp\", 0600);\n        fallocate(fd, FALLOC_FL_KEEP_SIZE,(off_t)  1024,(off_t)  1024);\n    \t], i_cv_fallocate_works=yes, i_cv_fallocate_works=no)\n])\nif test $i_cv_fallocate_works = yes; then\n   AC_DEFINE(HAVE_FALLOCATE, 1, Define if you have a working fallocate())\nfi\n\ndnl * Old glibcs have broken posix_fallocate(). Make sure not to use it.\ndnl * It may also be broken in AIX.\nAC_CACHE_CHECK([whether posix_fallocate() works],i_cv_posix_fallocate_works,[\n    AC_TRY_RUN([\n        #if !defined(__sun) && !defined(__sun__)\n        #define _XOPEN_SOURCE 600\n        #endif\n        #include <stdio.h>\n        #include <stdlib.h>\n        #include <fcntl.h>\n        #include <unistd.h>\n        #if defined(__GLIBC__) && (__GLIBC__ < 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ < 7))\n            possibly broken posix_fallocate\n        #endif\n        int main() {\n            int fd = creat(\"conftest.temp\", 0600);\n            int ret;\n            if (-1 == fd) {\n               perror(\"creat()\");\n               return 2;\n            }\n            ret = posix_fallocate(fd, 1024, 1024) < 0 ? 1 : 0;\n            unlink(\"conftest.temp\");\n            return ret;\n        }\n    ], [\n        i_cv_posix_fallocate_works=yes\n    ], [\n        i_cv_posix_fallocate_works=no\n    ], [\n        i_cv_posix_fallocate_works=no\n    ])\n])\nif test $i_cv_posix_fallocate_works = yes; then\n   AC_DEFINE(HAVE_POSIX_FALLOCATE,, Define if you have a working posix_fallocate())\nfi\n\n#\n# EMU_THR_LIB_NAME, EMU_THR_LIBS, EMU_THR_X_LIBS, and EMU_THR_DEFS is\n# used by the emulator, and can (but should not) be used by applications\n# that only require thread support when the emulator has thread support.\n# Other applications should use ETHR_LIB_NAME, ETHR_LIBS, ETHR_X_LIBS,\n# and ETHR_DEFS.\n#\n\nEMU_THR_LIB_NAME=\nEMU_THR_X_LIBS=\nEMU_THR_LIBS=\nEMU_THR_DEFS=\n\n# Threads enabled for emulator\nEMU_THR_LIB_NAME=$ETHR_LIB_NAME\nEMU_THR_X_LIBS=$ETHR_X_LIBS\nEMU_THR_LIBS=$ETHR_LIBS\nEMU_THR_DEFS=$ETHR_DEFS\nENABLE_ALLOC_TYPE_VARS=\"$ENABLE_ALLOC_TYPE_VARS threads\"\nAC_MSG_CHECKING(whether lock checking should be enabled)\nAC_MSG_RESULT($enable_lock_check)\nif test \"x$enable_lock_check\" != \"xno\"; then\n    EMU_THR_DEFS=\"$EMU_THR_DEFS -DERTS_ENABLE_LOCK_CHECK\"\nfi\n\nAC_MSG_CHECKING(whether lock counters should be enabled)\nAC_MSG_RESULT($enable_lock_count)\nif test \"x$enable_lock_count\" != \"xno\"; then\n    TYPES=\"$TYPES lcnt\"\nfi\n\ncase $host_os in\n    linux*)\n\tAC_MSG_CHECKING([whether dlopen() needs to be called before first call to dlerror()])\n\tif test \"x$ETHR_THR_LIB_BASE_TYPE\" != \"xposix_nptl\"; then\n\t    AC_DEFINE(ERTS_NEED_DLOPEN_BEFORE_DLERROR,[1],\n\t\t[Define if dlopen() needs to be called before first call to dlerror()])\n\t\tAC_MSG_RESULT(yes)\n\telse\n\t\tAC_MSG_RESULT(no)\n\tfi\n\t;;\n    *)\n\t;;\nesac\n\n# Remove -D_WIN32_WINNT*, -DWINVER* and -D_GNU_SOURCE from EMU_THR_DEFS\n# (defined in CFLAGS). Note that we want to keep these flags\n# in ETHR_DEFS, but not in EMU_THR_DEFS.\nnew_emu_thr_defs=\nfor thr_def in $EMU_THR_DEFS; do\n    case $thr_def in\n\t-D_GNU_SOURCE*|-D_WIN32_WINNT*|-DWINVER*)\n\t    ;;\n\t*)\n\t    new_emu_thr_defs=\"$new_emu_thr_defs $thr_def\"\n\t    ;;\n    esac\ndone\nEMU_THR_DEFS=$new_emu_thr_defs\n\nAC_SUBST(EMU_THR_LIB_NAME)\nAC_SUBST(EMU_THR_X_LIBS)\nAC_SUBST(EMU_THR_LIBS)\nAC_SUBST(EMU_THR_DEFS)\n\nif test \"x$enable_lock_check\" = \"xno\"; then\n    EMU_LOCK_CHECKING=no\nelse\n    EMU_LOCK_CHECKING=yes\nfi\n\nAC_SUBST(EMU_LOCK_CHECKING)\n\nERL_INTERNAL_LIBS\n\ndnl THR_LIBS and THR_DEFS are only used by odbc\nTHR_LIBS=$ETHR_X_LIBS\nTHR_DEFS=$ETHR_DEFS\n\nAC_SUBST(THR_LIBS)\nAC_SUBST(THR_DEFS)\n\ndnl ----------------------------------------------------------------------\ndnl Try to figure out where to get the termcap functions from.\ndnl We use tgetent(), tgetflag(), tgetnum(), tgetstr() and tputs()\ndnl ----------------------------------------------------------------------\n\nTERMCAP_LIB=\n\nif test \"x$with_termcap\" != \"xno\" &&\n   test \"X$host\" != \"Xwin32\"; then\n    # try these libs\n    termcap_libs=\"tinfo ncurses curses termcap termlib\"\n\n    for termcap_lib in $termcap_libs; do\n\tAC_CHECK_LIB($termcap_lib, tgetent, TERMCAP_LIB=\"-l$termcap_lib\")\n\tif test \"x$TERMCAP_LIB\" != \"x\"; then\n\t    break\n\tfi\n    done\n\n    if test \"x$TERMCAP_LIB\" = \"x\"; then\n\tAC_MSG_ERROR([No curses library functions found])\n    fi\nfi\n\nAC_SUBST(TERMCAP_LIB)\n\nif test \"x$TERMCAP_LIB\" != \"x\"; then\n\n\tAC_DEFINE(HAVE_TERMCAP, 1, [Define if termcap functions exists])\nfi\n\nif test \"X$host\" != \"Xwin32\"; then\n    AC_MSG_CHECKING(for wcwidth)\n    AC_TRY_LINK([#include <wchar.h>], [wcwidth(0);],\n                have_wcwidth=yes, have_wcwidth=no)\n    if test $have_wcwidth = yes; then\n        AC_MSG_RESULT([yes])\n        AC_DEFINE(HAVE_WCWIDTH, [1],\n                  [Define to 1 if you have a `wcwidth' function.])\n    fi\nfi\n\ndnl -------------\ndnl zlib\ndnl -------------\n\nAC_ARG_ENABLE(builtin-zlib,\n  AS_HELP_STRING([--enable-builtin-zlib],\n                 [force use of our own built-in zlib]),\n  [ case \"$enableval\" in\n      no) enable_builtin_zlib=no ;;\n      *)  enable_builtin_zlib=yes ;;\n    esac ], enable_builtin_zlib=no)\n\nZ_LIB=\n\nif test \"x$enable_builtin_zlib\" = \"xyes\"; then\n  AC_DEFINE(HAVE_ZLIB_INFLATEGETDICTIONARY, 1,\n            [Define if your zlib version defines inflateGetDictionary.])\n  AC_MSG_NOTICE([Using our own built-in zlib source])\nelse\nAC_MSG_CHECKING(for zlib 1.2.5 or higher)\nzlib_save_LIBS=$LIBS\nLIBS=\"-lz $LIBS\"\nAC_LINK_IFELSE(\n [AC_LANG_PROGRAM([[\n#include \"zlib.h\"\n]],[[\n#if ZLIB_VERNUM >= 0x1250\n  Bytef s[1];\n  s[0] = 0;\n  (void) adler32((uLong)0, s, 1);\n#else\n#error \"No zlib 1.2.5 or higher found\"\nerror\n#endif\n]])],\n[\n Z_LIB=\"-lz\"\n AC_DEFINE(HAVE_LIBZ, 1, [Define to 1 if you have the `z' library (-lz).])\n AC_MSG_RESULT(yes)\n],[\n AC_MSG_RESULT(no)\n])\n\nif test \"$Z_LIB\" != \"\"; then\n  AC_MSG_CHECKING(for zlib inflateGetDictionary presence)\n  AC_SEARCH_LIBS(inflateGetDictionary, [z],\n                 AC_DEFINE(HAVE_ZLIB_INFLATEGETDICTIONARY, 1,\n                           [Define if your zlib version defines inflateGetDictionary.]))\nfi\n\nLIBS=$zlib_save_LIBS\n\nfi\nAC_SUBST(Z_LIB)\n\n\ndnl -------------\ndnl esock\ndnl -------------\n\nAC_ARG_ENABLE(esock,\nAS_HELP_STRING([--enable-esock], [enable builtin experimental socket (as a nif) support (default)])\nAS_HELP_STRING([--disable-esock], [disable builtin experimental socket (as a nif) support]))\n\ndnl Default value\nUSE_ESOCK=yes\n\nif test \"x$enable_esock\" = \"xyes\"; then\n    USE_ESOCK=yes\nelse\n    if test \"x$enable_esock\" = \"xno\"; then\n        USE_ESOCK=no\n    fi\nfi\n\nif test \"x$USE_ESOCK\" = \"xyes\"; then\n    if test \"x$USE_ESOCK\" = \"xyes\"; then\n        AC_CHECK_FUNCS([localtime_r strftime])\n    fi\nfi\n\nAC_SUBST(USE_ESOCK)\n\n\ndnl\ndnl This test kindly borrowed from Tcl\ndnl\n#--------------------------------------------------------------------\n#\tCheck for the existence of the -lsocket and -lnsl libraries.\n#\tThe order here is important, so that they end up in the right\n#\torder in the command line generated by make.  Here are some\n#\tspecial considerations:\n#\t1. Use \"connect\" and \"accept\" to check for -lsocket, and\n#\t   \"gethostbyname\" to check for -lnsl.\n#\t2. Use each function name only once:  can't redo a check because\n#\t   autoconf caches the results of the last check and won't redo it.\n#\t3. Use -lnsl and -lsocket only if they supply procedures that\n#\t   aren't already present in the normal libraries.  This is because\n#\t   IRIX 5.2 has libraries, but they aren't needed and they're\n#\t   bogus:  they goof up name resolution if used.\n#\t4. On some SVR4 systems, can't use -lsocket without -lnsl too.\n#\t   To get around this problem, check for both libraries together\n#\t   if -lsocket doesn't work by itself.\n#--------------------------------------------------------------------\n\ntk_oldLibs=$LIBS\nerl_checkBoth=0\nSOCKET_LIBS=\"\"\nAC_CHECK_FUNC(connect, erl_checkSocket=0, erl_checkSocket=1)\nif test \"$erl_checkSocket\" = 1; then\n    AC_CHECK_LIB(socket, main, SOCKET_LIBS=\"-lsocket\", erl_checkBoth=1)\nfi\n\nif test \"$erl_checkBoth\" = 1; then\n    LIBS=\"$LIBS -lsocket -lnsl\"\n    AC_CHECK_FUNC(accept, SOCKET_LIBS=\"-lsocket -lnsl\")\nfi\n\nLIBS=\"$tk_oldLibs $SOCKET_LIBS\"\nAC_CHECK_FUNC(gethostbyname, , AC_CHECK_LIB(nsl, main, [SOCKET_LIBS=\"$SOCKET_LIBS -lnsl\"]))\nAC_CHECK_FUNC(gethostbyname_r,have_gethostbyname_r=yes)\n\nLIBS=\"$tk_oldLibs $SOCKET_LIBS\"\n\nAC_SUBST(SOCKET_LIBS)\n\ndnl\ndnl These gethostbyname thingies use old style AC_DEFINE for BC with ancient \ndnl autoconf...\ndnl \n\nif test \"$have_gethostbyname_r\" = yes; then\n\t# OK, so we have gethostbyname_r() - but do we know how to call it...?\n\t# (if not, HAVE_GETHOSTBYNAME_R will not be defined at all)\n\tcase $host_os in\n\t\tsolaris2*)\n\t\t\tAC_DEFINE(HAVE_GETHOSTBYNAME_R, GHBN_R_SOLARIS,\n\t\t\t\t[Define to flavour of gethostbyname_r])\n\t\t;;\n\t\taix4*)\n\t\t\t# AIX version also needs \"struct hostent_data\" defn\n\t\t\tAC_TRY_COMPILE([#include <netdb.h>],\n\t\t\t\t[struct hostent_data hd;],\n\t\t\t\tAC_DEFINE(HAVE_GETHOSTBYNAME_R, GHBN_R_AIX,\n\t\t\t\t    [Define to flavour of gethostbyname_r]))\n\t\t;;\n\t\t*)\n\t\t\tAC_EGREP_CPP(^yes$,[\n#include <stdio.h>\n#ifdef __GLIBC__\nyes\n#endif\n\t\t\t  ], AC_DEFINE(HAVE_GETHOSTBYNAME_R, GHBN_R_GLIBC,\n\t\t\t\t[Define to flavour of gethostbyname_r]))\n\t\t;;\n\tesac\nfi\n\nAC_MSG_CHECKING(for working posix_openpt implementation)\nAC_TRY_LINK([\n#define _XOPEN_SOURCE 600 \n#include <stdlib.h>\n#include <fcntl.h>\n],\n[\n    int mfd = posix_openpt(O_RDWR);\n    ptsname(mfd);\n    grantpt(mfd);\n    unlockpt(mfd);\n    return mfd;\n], working_posix_openpt=yes, working_posix_openpt=no)\n\nif test \"X$working_posix_openpt\" = \"Xyes\"; then\n    AC_DEFINE(HAVE_WORKING_POSIX_OPENPT, [1],\n\t      [Define if you have a working posix_openpt implementation])\n    AC_MSG_RESULT(yes)\nelse\n    AC_MSG_RESULT(no)\nfi\n\ndnl Check for usage of sockaddr_in in netdb.h\ndnl somewhat ugly check, I check for presence of the string and that \ndnl compilation works. If either fails I assume it's not needed.\ndnl Seems only to be needed on a patched version of solaris2.5.1, with\ndnl netdb.h  version  1.18.\nAC_MSG_CHECKING([if netdb.h requires netinet/in.h to be previously included])\nAC_EGREP_CPP(sockaddr_in, \n\t     [#include <netdb.h>],\n\t     AC_TRY_COMPILE([#include <netinet/in.h>\n\t\t\t     #include <netdb.h>], \n\t\t\t    [return 0;],\n\t\t\t    need_in_h=yes, \n                            need_in_h=no),\n             need_in_h=no)\n\nif test $need_in_h = yes; then\n\tAC_DEFINE(NETDB_H_NEEDS_IN_H,[1],\n\t\t[Define if netdb.h needs struct sockaddr_in ans in.h CAN be included before])\n\tAC_MSG_RESULT(yes)\nelse\n\tAC_MSG_RESULT(no)\nfi\n\ndnl Check for type socklen_t\ndnl\nAC_MSG_CHECKING([for socklen_t])\nAC_TRY_COMPILE( [#include <sys/socket.h>], \n\t\t[socklen_t test;],\n\t\thave_socklen_t=yes, \n                have_socklen_t=no),\n\nif test $have_socklen_t = yes; then\n\tAC_DEFINE(HAVE_SOCKLEN_T,[1],[Define if we have socklen_t])\n\tAC_MSG_RESULT(yes)\nelse\n\tAC_MSG_RESULT(no)\nfi\n\n\ndnl h_errno isn't always declared in netdb.h, and with some definitions\ndnl (e.g. function call for thread-safe) a simple 'extern int' may conflict\ndnl (we do assume that h_errno exists at all...)\nAC_CACHE_CHECK([for h_errno declaration in netdb.h],\n  ac_cv_decl_h_errno,\n[AC_TRY_COMPILE([#include <netdb.h>], [int err = h_errno;],\n  ac_cv_decl_h_errno=yes, ac_cv_decl_h_errno=no)])\nif test $ac_cv_decl_h_errno = yes; then\n  AC_DEFINE(H_ERRNO_DECLARED,[1],\n\t[define if h_errno is declared (in some way) in a system header file])\nfi\n\n\ndnl ----------------------------------------------------------------------\ndnl Checks for header files.\ndnl ----------------------------------------------------------------------\n\ndnl We sometimes need EMU_THR_DEFS in order to find certain headers.\nsaved_cppflags=$CPPFLAGS\nCPPFLAGS=\"$CPPFLAGS $EMU_THR_DEFS\"\n\nAC_HEADER_DIRENT\nAC_HEADER_STDC\nAC_HEADER_SYS_WAIT\nAC_HEADER_TIME\n\ndnl Interactive UX needs <net/errno.h> for socket related error codes.\ndnl Some Linuxes needs <sys/socketio.h> instead of <sys/sockio.h>\ndnl\nAC_CHECK_HEADERS(fcntl.h limits.h unistd.h syslog.h dlfcn.h ieeefp.h \\\n                 sys/types.h sys/stropts.h sys/sysctl.h \\\n                 sys/ioctl.h sys/time.h sys/uio.h sys/mman.h \\\n                 sys/socket.h sys/sockio.h sys/socketio.h \\\n                 net/errno.h malloc.h arpa/nameser.h libdlpi.h \\\n\t\t pty.h util.h libutil.h utmp.h langinfo.h poll.h sdkddkver.h)\n\nAC_CHECK_MEMBERS([struct ifreq.ifr_hwaddr], [], [],\n\t[#ifdef __WIN32__\n\t #else\n\t #ifdef VXWORKS\n\t #else\n\t #include <net/if.h>\n\t #endif\n\t #endif\n\t])\n\nAC_CHECK_MEMBERS([struct ifreq.ifr_enaddr], [], [],\n\t[#ifdef __WIN32__\n\t #else\n\t #ifdef VXWORKS\n\t #else\n\t #include <net/if.h>\n\t #endif\n\t #endif\n\t])\n\ndnl ----------------------------------------------------------------------\ndnl  Check the availability of systemd\ndnl ----------------------------------------------------------------------\nif test x\"$enable_systemd\" != x\"no\"; then\n\nsystemd_daemon_save_LIBS=$LIBS\nLIBS=\nAC_SEARCH_LIBS(sd_listen_fds,[systemd systemd-daemon],\n  [have_sd_listen_fds=yes],[have_sd_listen_fds=no],$systemd_daemon_save_LIBS)\nAC_SEARCH_LIBS(sd_notify,[systemd systemd-daemon],\n  [have_sd_notify=yes],[have_sd_notify=no],$systemd_daemon_save_LIBS)\nAC_CHECK_HEADERS(systemd/sd-daemon.h,\n  [have_systemd_sd_daemon_h=yes],[have_systemd_sd_daemon_h=no])\n\nif test x\"$have_sd_listen_fds\" = x\"yes\" && \\\n   test x\"$have_sd_notify\" = x\"yes\" && \\\n   test x\"$have_systemd_sd_daemon_h\" = x\"yes\"; then\n  AC_DEFINE([HAVE_SYSTEMD_DAEMON],[1],[Define if you have systemd daemon])\n  SYSTEMD_DAEMON_LIBS=$LIBS\nelif test x\"$enable_systemd\" = x\"yes\"; then\n  AC_MSG_FAILURE([--enable-systemd was given, but test for systemd failed])\nfi\nLIBS=$systemd_daemon_save_LIBS\nfi\nAC_SUBST(SYSTEMD_DAEMON_LIBS)\n\n\ndnl ----------------------------------------------------------------------\ndnl Check the availability for libdlpi\ndnl ----------------------------------------------------------------------\nAC_CHECK_LIB(dlpi, dlpi_open)\nif test x\"$ac_cv_lib_dlpi_dlpi_open\" = x\"no\"; then\n   unset -v ac_cv_lib_dlpi_dlpi_open\n   dnl Try again now with -L/lib (or ditto 64) as argument to linker since\n   dnl gcc makes /usr/ccs/bin/ld ignore the crle configured linker default paths\n   dnl typically causing dlpi not being found on Solaris et.al\n   save_ldflags=\"$LDFLAGS\"\n   try_dlpi_lib=/lib\n   if test x\"$ac_cv_sizeof_void_p\" = x\"8\"; then\n      if test -d /lib64; then\n\t try_dlpi_lib=/lib64\n      elif test -d /lib/64; then\n\t try_dlpi_lib=/lib/64\n      fi\n   fi\n   if test ! -f \"$try_dlpi_lib/libdlpi.so\" && \\\n      test -f \"$try_dlpi_lib/libdlpi.so.1\"\n   then\n      dnl It looks like there is a missing symlink\n      dnl - let's be helpful and notify the user\n      dnl NOTE this help is far from perfect e.g if there would be no\n      dnl *.so.1 but a *.so.1.123 or *.so.2 this will be no help\n      AC_MSG_ERROR(\n\t[Your OS installation is missing a symbolic link.\n\tMaybe it lacks some development package(s)...\n\tIt can anyhow be fixed with the following command:\n\t# ln -s libdlpi.so.1 $try_dlpi_lib/libdlpi.so\n\t])\n   fi\n   LDFLAGS=\"-L$try_dlpi_lib -R$try_dlpi_lib $LDFLAGS\"\n   unset -v try_dlpi_lib\n   AC_MSG_NOTICE([Extending the search to include /lib])\n   AC_CHECK_LIB(dlpi, dlpi_open)\n   if test x\"$ac_cv_lib_dlpi_dlpi_open\" = x\"no\"; then\n      LDFLAGS=\"$save_ldflags\"\n   fi\n   unset -v save_ldflags\nfi\n\nAC_CHECK_HEADER(sys/resource.h,\n\t[AC_DEFINE(HAVE_SYS_RESOURCE_H, 1,\n\t\t[Define to 1 if you have the <sys/resource.h> header file])\n\t AC_CHECK_DECLS([getrlimit, setrlimit, RLIMIT_STACK],\n\t\t[],[],\n\t\t[#include <sys/resource.h>])],\n\t[],[])\n\nAC_CHECK_FUNCS([getrusage])\n\ndnl Check if we have kernel poll support\nhave_kernel_poll=no\nAC_CHECK_HEADER(sys/event.h, have_kernel_poll=kqueue)\nAC_CHECK_HEADER(sys/epoll.h, have_kernel_poll=epoll)\nAC_CHECK_HEADER(sys/devpoll.h, have_kernel_poll=/dev/poll)\n\ndnl Check if we have timerfds to be used for high accuracy\ndnl epoll_wait timeouts\nAC_CHECK_HEADERS([sys/timerfd.h])\n\ndnl Check for kernel SCTP support\nAC_SUBST(LIBSCTP)\nif test \"x$enable_sctp\" != \"xno\" ; then\n    AC_CHECK_HEADER(netinet/sctp.h,\n        [LIBSCTP=libsctp.so.1\n\t AC_DEFINE(HAVE_SCTP_H, [1],\n            [Define to 1 if you have the <netinet/sctp.h> header file])],\n\t[],\n\t[#if HAVE_SYS_SOCKET_H\n\t #include <sys/socket.h>\n\t #endif\n\t])\nfi\n\nif test x\"$ac_cv_header_netinet_sctp_h\" = x\"yes\"; then\n    AS_IF([test \"x$enable_sctp\" = \"xlib\"],\n        AC_CHECK_LIB(sctp, sctp_bindx))\n    AC_CHECK_FUNCS([sctp_bindx sctp_peeloff sctp_getladdrs sctp_freeladdrs sctp_getpaddrs sctp_freepaddrs])\n    AC_CHECK_DECLS([SCTP_UNORDERED, SCTP_ADDR_OVER, SCTP_ABORT,\n                    SCTP_EOF, SCTP_SENDALL, SCTP_ADDR_CONFIRMED,\n\t\t    SCTP_DELAYED_ACK_TIME,\n\t\t    SCTP_EMPTY, SCTP_UNCONFIRMED,\n\t\t    SCTP_CLOSED, SCTPS_IDLE,\n\t\t    SCTP_BOUND, SCTPS_BOUND,\n\t\t    SCTP_LISTEN, SCTPS_LISTEN,\n\t\t    SCTP_COOKIE_WAIT, SCTPS_COOKIE_WAIT,\n\t\t    SCTP_COOKIE_ECHOED, SCTPS_COOKIE_ECHOED,\n\t\t    SCTP_ESTABLISHED, SCTPS_ESTABLISHED,\n\t\t    SCTP_SHUTDOWN_PENDING, SCTPS_SHUTDOWN_PENDING,\n\t\t    SCTP_SHUTDOWN_SENT, SCTPS_SHUTDOWN_SENT,\n\t\t    SCTP_SHUTDOWN_RECEIVED, SCTPS_SHUTDOWN_RECEIVED,\n\t\t    SCTP_SHUTDOWN_ACK_SENT, SCTPS_SHUTDOWN_ACK_SENT], [], [],\n        [#if HAVE_SYS_SOCKET_H\n         #include <sys/socket.h>\n         #endif\n         #include <netinet/sctp.h>\n        ])\n    AC_CHECK_MEMBERS([struct sctp_paddrparams.spp_pathmtu,\n                      struct sctp_paddrparams.spp_sackdelay,\n                      struct sctp_paddrparams.spp_flags,\n                      struct sctp_remote_error.sre_data,\n                      struct sctp_send_failed.ssf_data,\n                      struct sctp_event_subscribe.sctp_authentication_event,\n                      struct sctp_event_subscribe.sctp_sender_dry_event], [], [],\n        [#if HAVE_SYS_SOCKET_H\n         #include <sys/socket.h>\n         #endif\n         #include <netinet/sctp.h>\n        ])\nfi\n\ndnl Check for setns\nAC_CHECK_HEADERS(sched.h setns.h)\nAC_CHECK_FUNCS([setns])\n\nHAVE_VALGRIND=no\nAC_CHECK_HEADER(valgrind/valgrind.h, HAVE_VALGRIND=yes)\nAC_SUBST(HAVE_VALGRIND)\n\nLM_DECL_SO_BSDCOMPAT\nLM_DECL_INADDR_LOOPBACK\nLM_DECL_SYS_ERRLIST\n\nAC_CACHE_CHECK([if windows.h includes winsock2.h],\n\t\terts_cv_windows_h_includes_winsock2_h,\n\t\tAC_TRY_COMPILE([#include <windows.h>\n\t\t\t\t],\n\t\t\t       [#ifndef _WINSOCK2API_\n\t\t\t\t#error winsock2.h not included\n\t\t\t\t#endif\n\t\t\t\tint i = 1;\n\t\t\t\t],\n\t\t\t       erts_cv_windows_h_includes_winsock2_h=yes,\n\t\t\t       erts_cv_windows_h_includes_winsock2_h=no))\nif test $erts_cv_windows_h_includes_winsock2_h = yes; then\n\tAC_DEFINE(WINDOWS_H_INCLUDES_WINSOCK2_H, 1, \\\n[Define if windows.h includes winsock2.h])\nfi\n\ndnl restore CPPFLAGS\nCPPFLAGS=$saved_cppflags\n\ndnl ----------------------------------------------------------------------\ndnl Checks for typedefs, structures, and compiler characteristics.\ndnl ----------------------------------------------------------------------\n\nAC_C_CONST\nAC_TYPE_SIGNAL\nAC_TYPE_OFF_T\nAC_TYPE_PID_T\nAC_TYPE_SIZE_T\n\nAC_STRUCT_TM\nLM_STRUCT_SOCKADDR_SA_LEN\nLM_STRUCT_EXCEPTION\n\nAC_CHECK_SIZEOF(char, 1)\nAC_CHECK_SIZEOF(short)\nAC_CHECK_SIZEOF(int)\nAC_CHECK_SIZEOF(long)\nAC_CHECK_SIZEOF(void *)\nAC_CHECK_SIZEOF(long long)\nAC_CHECK_SIZEOF(size_t)\nAC_CHECK_SIZEOF(off_t)\nAC_CHECK_SIZEOF(time_t)\n\nBITS64=\n\nif test $ac_cv_sizeof_void_p = 8; then\n  BITS64=yes\nfi\nAC_SUBST(BITS64)\n\nAC_MSG_CHECKING([for C compiler 'restrict' support])\nrestrict_keyword=\"\"\nfor x in restrict __restrict; do\n    AC_TRY_COMPILE([int * $x foo(int * $x arg);\n\t\t    int * $x foo(int * $x arg)\n\t\t        { int * $x var=arg; return var;}\n\t\t   ],[],\n\t\t   [restrict_keyword=$x],[])\n    if test \"x$restrict_keyword\" != \"x\"; then\n\tbreak\n    fi\ndone\nAC_DEFINE_UNQUOTED(ERTS_RESTRICT,[$restrict_keyword],[Type qualifier restrict])\nif test \"x$restrict_keyword\" != \"x\"; then\n   AC_MSG_RESULT(yes)\nelse\n   AC_MSG_RESULT(no)\nfi\n\nif test \"x$ac_compiler_gnu\" = \"xyes\"; then\nAC_MSG_CHECKING([if we should add -fno-tree-copyrename to CFLAGS for computed gotos to work properly])\nAC_TRY_COMPILE([],[\n\t\t#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n\t\t\t;\n\t\t\t#else\n\t\t\t#error old and ok\n\t\t\t#endif\n\t\t\t],\n\t\t\tno_tree_copyrename=yes,\n\t\t\tno_tree_copyrename=no)\n\nif test \"x$no_tree_copyrename\" = \"xyes\"; then\n\tCFLAGS=\"$CFLAGS -fno-tree-copyrename\"\n\tAC_MSG_RESULT(yes, adjusting CFLAGS)\nelse\n\tAC_MSG_RESULT(no)\nfi\n\nAC_MSG_CHECKING([for broken gcc-4.3.0 compiler])\nAC_TRY_RUN([\n/* pr36339.c */\nextern void abort (void);\n\ntypedef unsigned long my_uintptr_t;\n\nint check_a(my_uintptr_t tagged_ptr);\n\nint __attribute__((noinline)) try_a(my_uintptr_t x)\n{\n  my_uintptr_t heap[2];\n  my_uintptr_t *hp = heap;\n\n  hp[0] = x;\n  hp[1] = 0;\n  return check_a((my_uintptr_t)(void*)((char*)hp + 1));\n}\n\nint __attribute__((noinline)) check_a(my_uintptr_t tagged_ptr)\n{\n  my_uintptr_t *hp = (my_uintptr_t*)(void*)((char*)tagged_ptr - 1);\n\n  if (hp[0] == 42 && hp[1] == 0)\n    return 0;\n  return -1;\n}\n\nint main(void)\n{\n  if (try_a(42) < 0)\n    abort ();\n  return 0;\n}\n], gcc_4_3_0_bug=no, gcc_4_3_0_bug=yes, gcc_4_3_0_bug=cross)\n\ncase $gcc_4_3_0_bug in\n\tyes|no)\n\t\tgcc_4_3_0_bug_result=$gcc_4_3_0_bug;;\n\tcross)\n\t\tgcc_dumped_vsn=`$CC -dumpversion 2>/dev/null`\n\t\tcase gcc-$gcc_dumped_vsn in\n\t\t\tgcc-4.3.0) gcc_4_3_0_bug=yes;;\n\t\t\t*) gcc_4_3_0_bug=no;;\n\t\tesac\n\t\tgcc_4_3_0_bug_result=\"$gcc_4_3_0_bug; could not run test since cross compiling, checked version number ($gcc_dumped_vsn) instead\";;\nesac\n\nAC_MSG_RESULT([$gcc_4_3_0_bug_result])\nif test $gcc_4_3_0_bug = yes; then\n\tAC_MSG_ERROR([This gcc miscompiles the Erlang runtime system; please use a different version])\t\nfi\n\nfi\n\ncase X$erl_xcomp_bigendian in\n    X) ;;\n    Xyes|Xno) ac_cv_c_bigendian=$erl_xcomp_bigendian;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_bigendian value: $erl_xcomp_bigendian]);;\nesac\n\nAC_C_BIGENDIAN(\n\t[\n\t AC_DEFINE([WORDS_BIGENDIAN], [1], [Define if big-endian])\n\t AC_DEFINE([ERTS_ENDIANNESS], [1], [Define > 0 if big-endian < 0 if little-endian, or 0 if unknown])\n\t],\n\t[\n\t AC_DEFINE([ERTS_ENDIANNESS], [-1], [Define > 0 if big-endian < 0 if little-endian, or 0 if unknown])\n\t],\n\t[\n\t  case \"$erl_xcomp_bigendian\" in\n\t    yes)\n\t     AC_DEFINE([ERTS_ENDIANNESS], [1], [Define > 0 if big-endian < 0 if little-endian, or 0 if unknown]);;\n\t    no)\n\t     AC_DEFINE([ERTS_ENDIANNESS], [-1], [Define > 0 if big-endian < 0 if little-endian, or 0 if unknown]);;\n\t    *)\n\t     AC_DEFINE([ERTS_ENDIANNESS], [0], [Define > 0 if big-endian < 0 if little-endian, or 0 if unknown]);;\n\t  esac\n\t])\t\n\nAC_C_DOUBLE_MIDDLE_ENDIAN\n\ndnl fdatasync syscall (Unix only)\nAC_CHECK_FUNCS([fdatasync])\n\ndnl Find which C libraries are required to use fdatasync\ndnl TODO: Remove check once SunOS >= 5.11 is required by erts.\ndnl       fdatasync requires linking against -lrt on SunOS <= 5.10.\ndnl       OpenSolaris 2009.06 is SunOS 5.11 and does not require -lrt.\nAC_SEARCH_LIBS(fdatasync, [rt])\n\n\ndnl sendfile syscall\ncase $host_os in\n    linux*|freebsd*|dragonfly*|darwin*)\n\t\tAC_CHECK_FUNCS([sendfile])\n\t\t;;\n    solaris*)\n\t\tAC_SEARCH_LIBS(sendfilev, sendfile,\n\t\t\tAC_DEFINE([HAVE_SENDFILEV],[1],\n\t\t           [Define to 1 if you have the `sendfilev' function.]))\n\t\t;;\n    win32)\n\t\tLIBS=\"$LIBS -lmswsock\"\n\t\t;;\n    *)\n\t\t;;\nesac\n\ndnl ----------------------------------------------------------------------\ndnl Checks for library functions.\ndnl ----------------------------------------------------------------------\n\ndnl We may need the thread library and thread flags in order to find right stuff\nsaved_cppflags=$CPPFLAGS\nCPPFLAGS=\"$CPPFLAGS $EMU_THR_DEFS\"\nsaved_libs=$LIBS\nLIBS=\"$LIBS $EMU_THR_X_LIBS\"\n\ndnl Check if we have these, in which case we'll try to build\ndnl inet_gethost with ipv6 support.\nAC_CHECK_HEADERS(windows.h)\nAC_CHECK_HEADERS(winsock2.h)\nAC_CHECK_HEADERS(ws2tcpip.h,[],[],[\n#ifdef HAVE_WINSOCK2_H\n#include <winsock2.h>\n#endif\n#ifdef HAVE_WINDOWS_H\n#include <windows.h>\n#endif\n])\ndnl AC_CHECK_FUNC(getaddrinfo, have_getaddrinfo=yes, have_getaddrinfo=no)\nAC_MSG_CHECKING(for getaddrinfo)\nAC_TRY_LINK([\n#include <stdlib.h>\n#include <string.h>\n#ifdef HAVE_WINSOCK2_H\n#include <winsock2.h>\n#endif\n#ifdef HAVE_WINDOWS_H\n#include <windows.h>\n#endif\n#ifdef HAVE_WS2TCPIP_H\n#include <ws2tcpip.h>\n#endif\n#ifndef __WIN32__\n#include <sys/socket.h>\n#include <netdb.h>\n#endif\n], \n[\ngetaddrinfo(\"\",\"\",NULL,NULL);\n],have_getaddrinfo=yes, have_getaddrinfo=no)\nif test $have_getaddrinfo = yes; then\n        AC_MSG_RESULT([yes])\n        AC_MSG_CHECKING([whether getaddrinfo accepts enough flags])\n        AC_TRY_LINK([\n#include <stdlib.h>\n#include <string.h>\n#ifdef HAVE_WINSOCK2_H\n#include <winsock2.h>\n#endif\n#ifdef HAVE_WINDOWS_H\n#include <windows.h>\n#endif\n#ifdef HAVE_WS2TCPIP_H\n#include <ws2tcpip.h>\n#endif\n#ifndef __WIN32__\n#include <sys/socket.h>\n#include <netdb.h>\n#endif\n],\n[\n    struct addrinfo hints, *ai;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_flags = AI_CANONNAME;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_family = AF_INET6;\n    if (getaddrinfo(\"::\", NULL, &hints, &ai) == 0) {\n\tfreeaddrinfo(ai);\n\texit(0);\n    } else {\n\texit(1);\n    }\n],, have_getaddrinfo=no)\n\tAC_MSG_RESULT($have_getaddrinfo)\n\tcase $have_getaddrinfo in\n\t    yes)\n\t\tAC_DEFINE(HAVE_GETADDRINFO, [1], \n\t\t          [Define to 1 if you have a good `getaddrinfo' function.]);;\n\t    *) ;;\n\tesac\nelse\n    AC_MSG_RESULT([no])\nfi\nAC_MSG_CHECKING(for getnameinfo)\nAC_TRY_LINK([\n#include <stdlib.h>\n#include <string.h>\n#ifdef HAVE_WINSOCK2_H\n#include <winsock2.h>\n#endif\n#ifdef HAVE_WINDOWS_H\n#include <windows.h>\n#endif\n#ifdef HAVE_WS2TCPIP_H\n#include <ws2tcpip.h>\n#endif\n#ifndef __WIN32__\n#include <sys/socket.h>\n#include <netdb.h>\n#endif\n], \n[\ngetnameinfo(NULL,0,NULL,0,NULL,0,0);\n],have_getnameinfo=yes, have_getnameinfo=no)\nif test $have_getnameinfo = yes; then\n        AC_MSG_RESULT([yes])\n\tAC_DEFINE(HAVE_GETNAMEINFO, [1], \n\t\t  [Define to 1 if you have a good `getnameinfo' function.])\nelse\n\tAC_MSG_RESULT([no])\t  \nfi\n\n\nAC_CHECK_FUNCS([getipnodebyname getipnodebyaddr gethostbyname2])\n\nAC_CHECK_FUNCS([ieee_handler fpsetmask finite isnan isinf res_gethostbyname dlopen \\\n\t\tpread pwrite memmove strerror strerror_r strncasecmp \\\n\t\tgethrtime localtime_r gmtime_r inet_pton mprotect \\\n\t\tmmap mremap memcpy mallopt sbrk _sbrk __sbrk brk _brk __brk \\\n\t\tflockfile fstat strlcpy strlcat setsid posix2time time2posix \\\n\t\tsetlocale nl_langinfo poll mlockall ppoll])\n\nAC_MSG_CHECKING([for isfinite])\nAC_TRY_LINK([#include <math.h>],\n            [isfinite(0);], have_isfinite=yes, have_isfinite=no),\n\nif test $have_isfinite = yes; then\n    AC_DEFINE(HAVE_ISFINITE,[1],\n              [Define to 1 if you have the `isfinite' function.])\n    AC_MSG_RESULT(yes)\nelse\n    AC_MSG_RESULT(no)\nfi\n\ncase X$erl_xcomp_posix_memalign in\n     Xno) ;;\n     Xyes) have_posix_memalign=yes ;;\n     *)\n\tAC_CHECK_FUNC(\n\t\t[posix_memalign],\n                [if test \"$cross_compiling\" != yes; then\nAC_TRY_RUN([\n#include <stdlib.h>\nint main(void) {\n    void *ptr = NULL;\n    int error;\n    size_t alignment = 0x40000, size = 0x20028;\n    if ((error = posix_memalign(&ptr, alignment, size)) != 0 || ptr == NULL)\n      return error;\n    return 0;\n}\n],have_posix_memalign=yes\n)\n\t\t else\n\t\t\thave_posix_memalign=yes\n\t\t fi]);;\nesac\n\nif test \"$have_posix_memalign\" = \"yes\"; then\n   AC_DEFINE(HAVE_POSIX_MEMALIGN,[1],\n\t     [Define to 1 if you have the `posix_memalign' function.])\nfi\n\n\ndnl writev on OS X snow leopard is broken for files > 4GB\ncase $host_os in\n        darwin10.8.0)\n\t    AC_MSG_CHECKING([for writev])\n\t    AC_MSG_RESULT(no, not stable on OS X Snow Leopard) ;;\n        *)\n\t    AC_CHECK_FUNCS([writev]) ;;\nesac\n\nAC_CHECK_DECLS([posix2time, time2posix],,,[#include <time.h>])\n\nAC_FUNC_VPRINTF\n\ndnl The AC_DEFINEs are necessary for autoheader to work. :-(\ndnl for gzio\nLM_CHECK_FUNC_DECL(fread, [extern int fread();],,\n                   AC_DEFINE(HAVE_CONFLICTING_FREAD_DECLARATION,[1],[Define if you have a decl of fread that conflicts with int fread]))\n\ndnl Checking with TRY_LINK since putc_unlocked might be (probably is) a macro\nAC_CACHE_CHECK([for putc_unlocked],\n\terts_cv_putc_unlocked,\n\tAC_TRY_LINK([#include <stdio.h>],\n\t\t[int res = putc_unlocked('x',stdout);],\n\t\terts_cv_putc_unlocked=yes,\n             \terts_cv_putc_unlocked=no))\nif test $erts_cv_putc_unlocked = yes; then\n\tAC_DEFINE(HAVE_PUTC_UNLOCKED, 1, [Define if you have putc_unlocked])\nfi\n\ndnl Checking with TRY_LINK since fwrite_unlocked might be a macro\nAC_CACHE_CHECK([for fwrite_unlocked],\n\terts_cv_fwrite_unlocked,\n\tAC_TRY_LINK([#include <stdio.h>],\n\t\t[size_t res = fwrite_unlocked(NULL,sizeof(char),0,stdout);],\n\t\terts_cv_fwrite_unlocked=yes,\n             \terts_cv_fwrite_unlocked=no))\nif test $erts_cv_fwrite_unlocked = yes; then\n\tAC_DEFINE(HAVE_FWRITE_UNLOCKED, 1, [Define if you have fwrite_unlocked])\nfi\n\ndnl Need by run_erl.\nAC_CHECK_FUNCS([openpty])\n\nAC_CHECK_HEADERS(net/if_dl.h ifaddrs.h netpacket/packet.h sys/un.h)\nAC_CHECK_FUNCS([getifaddrs])\n\ndnl Checks for variables in6addr_any and in6addr_loopback,\ndnl\ndnl They normally declared by netinet/in.h, according to POSIX,\ndnl but not on Windows 7 (Windows SDK 7.1).  I would have liked\ndnl to just write AC_CHECK_DECL([in6addr_any], ...) but if doing so,\ndnl the configure check fails erroneously on Linux with the error\ndnl \"cannot convert to a pointer type\", on a line looking like\ndnl \"char *p = (char *) in6addr_any;\", so work around that\ndnl with some more code. \nAC_CACHE_CHECK(\n    [whether in6addr_any is declared],\n    [erts_cv_have_in6addr_any],\n    [AC_LINK_IFELSE(\n\t[AC_LANG_PROGRAM(\n\t    [[\n\t\t#include <sys/types.h>\n\t\t#include <sys/socket.h>\n\t\t#include <netinet/in.h>\n\t    ]],\n\t    [[printf(\"%d\", in6addr_any.s6_addr[16]);]]\n\t)],\n\t[erts_cv_have_in6addr_any=yes],\n\t[erts_cv_have_in6addr_any=no]\n    )]\n)\n\ncase \"$erts_cv_have_in6addr_any\" in\n yes)\n   AC_DEFINE([HAVE_IN6ADDR_ANY], [1],\n             [Define to 1 if you have the variable in6addr_any declared.])\nesac\n\nAC_CACHE_CHECK(\n    [whether in6addr_loopback is declared],\n    [erts_cv_have_in6addr_loopback],\n    [AC_LINK_IFELSE(\n\t[AC_LANG_PROGRAM(\n\t    [[\n\t\t#include <sys/types.h>\n\t\t#include <sys/socket.h>\n\t\t#include <netinet/in.h>\n\t    ]],\n\t    [[printf(\"%d\", in6addr_loopback.s6_addr[16]);]]\n\t)],\n\t[erts_cv_have_in6addr_loopback=yes],\n\t[erts_cv_have_in6addr_loopback=no]\n    )]\n)\n\ncase \"$erts_cv_have_in6addr_loopback\" in\n yes)\n   AC_DEFINE([HAVE_IN6ADDR_LOOPBACK], [1],\n             [Define to 1 if you have the variable in6addr_loopback declared.])\nesac\n\nAC_CHECK_DECLS([IN6ADDR_ANY_INIT, IN6ADDR_LOOPBACK_INIT, IPV6_V6ONLY], [], [],\n\t       [\n\t\t#include <sys/types.h>\n\t\t#include <sys/socket.h>\n\t\t#include <netinet/in.h>\n\t       ])\n\ndnl ----------------------------------------------------------------------\ndnl Checks for features/quirks in the system that affects Erlang.\ndnl ----------------------------------------------------------------------\n\nAC_MSG_CHECKING([for sched_getaffinity/sched_setaffinity])\nAC_TRY_LINK([#include <sched.h>],\n[\n#ifndef CPU_SETSIZE\n#error no CPU_SETSIZE\n#endif\n\tint res;\n\tcpu_set_t cpuset;\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(1, &cpuset);\n\tres = sched_setaffinity(0, sizeof(cpu_set_t), &cpuset);\n\tres = sched_getaffinity(0, sizeof(cpu_set_t), &cpuset);\n\tres = CPU_ISSET(1, &cpuset);\n\tCPU_CLR(1, &cpuset);\n],\n\t\tsched_xetaffinity=yes,\n\t\tsched_xetaffinity=no)\nAC_MSG_RESULT([$sched_xetaffinity])\nif test $sched_xetaffinity = yes; then\n\tAC_DEFINE(HAVE_SCHED_xETAFFINITY, 1, [Define if you have sched_getaffinity/sched_setaffinity])\nfi\n\n\nAC_MSG_CHECKING([for pset functionality])\nAC_TRY_LINK([#include <sys/pset.h>],\n[\n\tint res;\n\tpsetid_t id = PS_MYID;\n\tint type = PS_PRIVATE;\n\tuint_t numcpus = 1024;\n\tprocessorid_t cpulist[1024];\n\n\tres = pset_info(id, &type, &numcpus, &cpulist[0]);\n],\n\t\tpset_functionality=yes,\n\t\tpset_functionality=no)\nAC_MSG_RESULT([$pset_functionality])\nif test $pset_functionality = yes; then\n\tAC_DEFINE(HAVE_PSET, 1, [Define if you have pset functionality])\nfi\n\nAC_MSG_CHECKING([for processor_bind functionality])\nAC_TRY_LINK([\n#include <sys/types.h>\n#include <sys/processor.h>\n#include <sys/procset.h>\n],\n[\n\tint res = processor_bind(P_LWPID, P_MYID, PBIND_NONE, NULL);\n],\n\t\tprocessor_bind_functionality=yes,\n\t\tprocessor_bind_functionality=no)\nAC_MSG_RESULT([$processor_bind_functionality])\nif test $processor_bind_functionality = yes; then\n\tAC_DEFINE(HAVE_PROCESSOR_BIND, 1, [Define if you have processor_bind functionality])\nfi\n\nAC_MSG_CHECKING([for cpuset_getaffinity/cpuset_setaffinity])\nAC_TRY_LINK([\n#include <sys/param.h>\n#include <sys/cpuset.h>\n],\n[\n\tint res;\n\tcpuset_t cpuset;\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(1, &cpuset);\n\tres = cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1, sizeof(cpuset_t), &cpuset);\n\tres = cpuset_getaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1, sizeof(cpuset_t), &cpuset);\n\tres = CPU_ISSET(1, &cpuset);\n\tCPU_CLR(1, &cpuset);\n],\n\t\tcpuset_xetaffinity=yes,\n\t\tcpuset_xetaffinity=no)\nAC_MSG_RESULT([$cpuset_xetaffinity])\nif test $cpuset_xetaffinity = yes; then\n\tAC_DEFINE(HAVE_CPUSET_xETAFFINITY, 1, [Define if you have cpuset_getaffinity/cpuset_setaffinity])\nfi\n\nAC_CACHE_CHECK([for 'end' symbol],\n\t\terts_cv_have_end_symbol,\n\t\t[AC_TRY_LINK([],\n\t\t\t[extern char end; {char *x = &end; *x= 0;}],\n\t\t\terts_cv_have_end_symbol=yes,\n\t\t\terts_cv_have_end_symbol=no)])\nif test $erts_cv_have_end_symbol = yes; then\n\tAC_DEFINE(HAVE_END_SYMBOL, 1, [Define if you have the 'end' symbol])\nfi\n\nAC_CACHE_CHECK([for '_end' symbol],\n\t\terts_cv_have__end_symbol,\n\t\t[AC_TRY_LINK([],\n\t\t\t[extern char _end; {char *x = &_end; *x= 0;}],\n\t\t\terts_cv_have__end_symbol=yes,\n\t\t\terts_cv_have__end_symbol=no)])\nif test $erts_cv_have__end_symbol = yes; then\n\tAC_DEFINE(HAVE__END_SYMBOL, 1, [Define if you have the '_end' symbol])\nfi\n\nAC_CACHE_CHECK([if __after_morecore_hook can track malloc()s core memory use],\n\t\terts_cv___after_morecore_hook_can_track_malloc,\n\t\t[AC_TRY_RUN([\n#include <stdlib.h>\n#ifdef HAVE_MALLOC_H\n#  include <malloc.h>\n#endif\n#if defined(HAVE_END_SYMBOL)\nextern char end;\n#elif defined(HAVE__END_SYMBOL)\nextern char _end;\n#endif\n\n#ifdef ETHR_PTHREADS\n#  ifdef ETHR_HAVE_PTHREAD_H\n#    include <pthread.h>\n#  else\n#    ifdef ETHR_HAVE_MIT_PTHREAD_H\n#      include <pthread/mit/pthread.h>\n#    endif\n#  endif\n#  define N_THR 5\n#else\n#  define N_THR 1\n#endif\n\nstatic char *heap_start = NULL;\nstatic char *heap_end = NULL;\n\nvoid update_heap_size(void)\n{\n    heap_end = (char *) sbrk(0);\n}\n\nvoid init_hook(void)\n{\n#if defined(HAVE_END_SYMBOL)\n    heap_start = &end;\n#elif defined(HAVE__END_SYMBOL)\n    heap_start = &_end;\n#else\n    heap_start = sbrk(0);\n#endif\n    __after_morecore_hook = update_heap_size;\n}\n\nvoid (*__malloc_initialize_hook) (void) = init_hook;\n\nstatic int\ncheck_malloc(int size)\n{\n    char *p = (char *) malloc(size);\n    if (!heap_start || !heap_end) return 0;\n    if (!p) return 0;\n    if (p < heap_start || heap_end <= p) return 0;\n    if (p + size < heap_start || heap_end < p + size) return 0;\n    return 1;\n}\n\n#ifdef ETHR_PTHREADS\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif\n\nstatic void *\ndo_tests(void *vresp)\n{\n    int i, ok = 0;\n#ifdef ETHR_PTHREADS\n    if (pthread_mutex_lock(&mutex) != 0)\n\treturn NULL;\n#endif\n\n    for (i = 0; i < 10; i++)\n\tif (!check_malloc(1000))\n\t    goto failed;\n    for (i = 0; i < 100; i++)\n\tif (!check_malloc(1))\n\t    goto failed;\n    if (!check_malloc(1024*1024+1))\n\tgoto failed;\n    if (!check_malloc(10*1024*1024+1))\n\tgoto failed;\n    ok = 1;\n\n failed:\n#ifdef ETHR_PTHREADS\n    if (pthread_mutex_unlock(&mutex) != 0)\n\treturn NULL;\n#endif\n    if (ok)\n\t*((int *) vresp) = 0;\n    return NULL;\n}\n\n\nint main(void)\n{\n    int res[N_THR], i;\n#ifdef ETHR_PTHREADS\n    pthread_t tid[N_THR];\n#endif\n\n#if defined(HAVE_MALLOPT) && defined(M_MMAP_MAX)\n    (void) mallopt(M_MMAP_MAX, 0);\n#endif\n\n    for (i = 0; i < N_THR; i++)\n\tres[i] = 1;\n#ifdef ETHR_PTHREADS\n    for (i = 1; i < N_THR; i++)\n\tif (pthread_create(&tid[i], NULL, do_tests, &res[i]) != 0)\n\t    return 1;\n#endif\n    (void) do_tests(&res[0]);\n#ifdef ETHR_PTHREADS\n    for (i = 1; i < N_THR; i++)\n\tif (pthread_join(tid[i], NULL) != 0)\n\t    return 1;\n#endif\n    for (i = 0; i < N_THR; i++)\n\tif (res[i])\n\t    return 1;\n    return 0;\n}\n\t],\n\terts_cv___after_morecore_hook_can_track_malloc=yes,\n\terts_cv___after_morecore_hook_can_track_malloc=no,\n\t[\n\tcase X$erl_xcomp_after_morecore_hook in\n\t    X) erts_cv___after_morecore_hook_can_track_malloc=cross;;\n\t    Xyes|Xno) erts_cv___after_morecore_hook_can_track_malloc=$erl_xcomp_after_morecore_hook;;\n\t    *) AC_MSG_ERROR([Bad erl_xcomp_after_morecore_hook value: $erl_xcomp_after_morecore_hook]);;\n\tesac\n\t]\n\t)])\n\ncase $erts_cv___after_morecore_hook_can_track_malloc in\n\tyes) AC_DEFINE(ERTS___AFTER_MORECORE_HOOK_CAN_TRACK_MALLOC, 1, \\\n[Define if __after_morecore_hook can track malloc()s core memory use.]);;\n\tcross) AC_MSG_WARN([result no guessed because of cross compilation]);;\n\t*) ;;\nesac\n\nif test \"x$ac_cv_func_sbrk\" = \"xyes\"; then\n    AC_CACHE_CHECK([types of sbrk()s return value and argument],\n\t\t    erts_cv_sbrk_ret_arg_types,\n\t\t    [\n\n\terts_cv_sbrk_ret_arg_types=unknown\n\tret_types=\"void *,char *\"\n\targ_types=\"intptr_t,ptrdiff_t,int,long\"\n\tsave_ifs=\"$IFS\"; IFS=\",\"\n\tfor rtype in $ret_types; do\n\t    for atype in $arg_types; do\n\t\tIFS=$save_ifs\n\t\tAC_TRY_LINK([#include <sys/types.h>\n\t\t\t\t#include <unistd.h>],\n\t\t\t\t[$rtype sbrk($atype incr);],\n\t\t\t\t[erts_cv_sbrk_ret_arg_types=\"$rtype,$atype\"])\n\t\tIFS=\",\"\n\t\tif test \"$erts_cv_sbrk_ret_arg_types\" != \"unknown\"; then\n\t\t    break 2\n\t\tfi\n\t    done\n\tdone\n\tIFS=$save_ifs])\n    \n    if test \"$erts_cv_sbrk_ret_arg_types\" != \"unknown\"; then\n\tsave_ifs=\"$IFS\"; IFS=\",\"\n\tread ret_type arg_type <<EOF\n$erts_cv_sbrk_ret_arg_types\nEOF\n\tIFS=$save_ifs\n\tAC_DEFINE_UNQUOTED(SBRK_RET_TYPE, $ret_type, \\\n[Define the sbrk() return type.])\n\tAC_DEFINE_UNQUOTED(SBRK_ARG_TYPE, $arg_type, \\\n[Define the sbrk() argument type.])\n    fi\nfi\n\nif test $ac_cv_func_brk = yes; then\n    AC_CACHE_CHECK([types of brk()s return value and argument],\n\t\t    erts_cv_brk_ret_arg_types,\n\t\t    [\n\n\terts_cv_brk_ret_arg_types=unknown\n\tret_types=\"int,long,char *,void *\"\n\targ_types=\"void *,const void *,char *,const char *\"\n\tsave_ifs=\"$IFS\"; IFS=\",\"\n\tfor rtype in $ret_types; do\n\t    for atype in $arg_types; do\n\t\tIFS=$save_ifs\n\t\tAC_TRY_LINK([#include <sys/types.h>\n\t\t\t\t#include <unistd.h>],\n\t\t\t\t[$rtype brk($atype endds);],\n\t\t\t\t[erts_cv_brk_ret_arg_types=\"$rtype,$atype\"])\n\t\tIFS=\",\"\n\t\tif test \"$erts_cv_brk_ret_arg_types\" != \"unknown\"; then\n\t\t    break 2\n\t\tfi\n\t    done\n\tdone\n\tIFS=$save_ifs])\n    \n    if test \"$erts_cv_brk_ret_arg_types\" != \"unknown\"; then\n\tsave_ifs=\"$IFS\"; IFS=\",\"\n\tread ret_type arg_type <<EOF\n$erts_cv_brk_ret_arg_types\nEOF\n\tIFS=$save_ifs\n\tAC_DEFINE_UNQUOTED(BRK_RET_TYPE, $ret_type, \\\n[Define the brk() return type.])\n\tAC_DEFINE_UNQUOTED(BRK_ARG_TYPE, $arg_type, \\\n[Define the brk() argument type.])\n    fi\n\nfi\n\nif test $ac_cv_func_sbrk = yes; then\n\n    AC_CACHE_CHECK([if sbrk()/brk() wrappers can track malloc()s core memory use],\n\t\t    erts_cv_brk_wrappers_can_track_malloc,\n\t\t    [AC_TRY_RUN([\n#include <stdlib.h>\n#include <sys/types.h>\n#include <unistd.h>\n#ifdef HAVE_DLFCN_H\n#  include <dlfcn.h>\n#endif\n\n/*\n * Our implementation requires that we have sbrk(), and 'end' or '_end'.\n */\n\n#if !defined(HAVE_SBRK)\n#  error no sbrk()\n#endif\n#if defined(HAVE_END_SYMBOL)\nextern char end;\n#elif defined(HAVE__END_SYMBOL)\nextern char _end;\n#else\n#  error no 'end' nor '_end'\n#endif\n\n#ifdef ETHR_PTHREADS\n#  ifdef ETHR_HAVE_PTHREAD_H\n#    include <pthread.h>\n#  else\n#    ifdef ETHR_HAVE_MIT_PTHREAD_H\n#      include <pthread/mit/pthread.h>\n#    endif\n#  endif\n#  define N_THR 5\n#else\n#  define N_THR 1\n#endif\n\n#define SBRK_IMPL(RET_TYPE, SBRK, ARG_TYPE)\t\t\t\t\\\nRET_TYPE SBRK (ARG_TYPE);\t\t\t\t\t\t\\\nstatic RET_TYPE (*real_ ## SBRK)(ARG_TYPE) = NULL;\t\t\t\\\nRET_TYPE\t\t\t\t\t\t\t\t\\\nSBRK (ARG_TYPE arg)\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n    RET_TYPE res;\t\t\t\t\t\t\t\\\n    if (!real_ ## SBRK) real_ ## SBRK = dlsym(RTLD_NEXT, #SBRK);\t\\\n    res = (*real_ ## SBRK)(arg);\t\t\t\t\t\\\n    if (res != (RET_TYPE) -1) heap_end = (char *) (*real_ ## SBRK)(0);\t\\\n    return res;\t\t\t\t\t\t\t\t\\\n}\n\n#define BRK_IMPL(RET_TYPE, BRK, ARG_TYPE)\t\t\t\t\\\nRET_TYPE BRK (ARG_TYPE);\t\t\t\t\t\t\\\nstatic RET_TYPE (*real_ ## BRK)(ARG_TYPE) = NULL;\t\t\t\\\nRET_TYPE\t\t\t\t\t\t\t\t\\\nBRK (ARG_TYPE arg)\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n    RET_TYPE res;\t\t\t\t\t\t\t\\\n    if (!real_ ## BRK) real_ ## BRK = dlsym(RTLD_NEXT, #BRK);\t\t\\\n    res = (*real_ ## BRK)(arg);\t\t\t\t\t\t\\\n    if (res != (RET_TYPE) -1) heap_end = (char *) arg;\t\t\t\\\n    return res;\t\t\t\t\t\t\t\t\\\n}\n\nstatic char *heap_start = NULL;\nstatic char *heap_end = NULL;\n\nSBRK_IMPL(SBRK_RET_TYPE, sbrk, SBRK_ARG_TYPE)\n#ifdef HAVE_BRK\n   BRK_IMPL(BRK_RET_TYPE, brk, BRK_ARG_TYPE)\n#endif\n\n#ifdef HAVE__SBRK\n   SBRK_IMPL(SBRK_RET_TYPE, _sbrk, SBRK_ARG_TYPE)\n#endif\n#ifdef HAVE__BRK\n   BRK_IMPL(BRK_RET_TYPE, _brk, BRK_ARG_TYPE)\n#endif\n\n#ifdef HAVE___SBRK\n   SBRK_IMPL(SBRK_RET_TYPE, __sbrk, SBRK_ARG_TYPE)\n#endif\n#ifdef HAVE___BRK\n   BRK_IMPL(BRK_RET_TYPE, __brk, BRK_ARG_TYPE)\n#endif\n\nstatic int\ncheck_malloc(int size)\n{\n    char *p = (char *) malloc(size);\n    if (!heap_start || !heap_end) return 0;\n    if (!p) return 0;\n    if (p < heap_start || heap_end <= p) return 0;\n    if (p + size < heap_start || heap_end < p + size) return 0;\n    return 1;\n}\n\n#ifdef ETHR_PTHREADS\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif\n\nstatic void *\ndo_tests(void *vresp)\n{\n    int i, ok = 0;\n#ifdef ETHR_PTHREADS\n    if (pthread_mutex_lock(&mutex) != 0)\n\treturn NULL;\n#endif\n\n    for (i = 0; i < 10; i++)\n\tif (!check_malloc(1000))\n\t    goto failed;\n    for (i = 0; i < 100; i++)\n\tif (!check_malloc(1))\n\t    goto failed;\n    if (!check_malloc(1024*1024+1))\n\tgoto failed;\n    if (!check_malloc(10*1024*1024+1))\n\tgoto failed;\n    ok = 1;\n\n failed:\n#ifdef ETHR_PTHREADS\n    if (pthread_mutex_unlock(&mutex) != 0)\n\treturn NULL;\n#endif\n    if (ok)\n\t*((int *) vresp) = 0;\n    return NULL;\n}\n\n\nint main(void)\n{\n    int res[N_THR], i;\n#ifdef ETHR_PTHREADS\n    pthread_t tid[N_THR];\n#endif\n#if defined(HAVE_END_SYMBOL)\n    heap_start = &end;\n#elif defined(HAVE__END_SYMBOL)\n    heap_start = &_end;\n#endif\n\n#if defined(HAVE_MALLOPT) && defined(M_MMAP_MAX)\n    (void) mallopt(M_MMAP_MAX, 0);\n#endif\n\n    for (i = 0; i < N_THR; i++)\n\tres[i] = 1;\n#ifdef ETHR_PTHREADS\n    for (i = 1; i < N_THR; i++)\n\tif (pthread_create(&tid[i], NULL, do_tests, &res[i]) != 0)\n\t    return 1;\n#endif\n    (void) do_tests(&res[0]);\n#ifdef ETHR_PTHREADS\n    for (i = 1; i < N_THR; i++)\n\tif (pthread_join(tid[i], NULL) != 0)\n\t    return 1;\n#endif\n    for (i = 0; i < N_THR; i++)\n\tif (res[i])\n\t    return 1;\n    return 0;\n}\n\t],\n\t    erts_cv_brk_wrappers_can_track_malloc=yes,\n\t    erts_cv_brk_wrappers_can_track_malloc=no,\n\t    [\n\t    case X$erl_xcomp_dlsym_brk_wrappers in\n\t\tX) erts_cv_brk_wrappers_can_track_malloc=cross;;\n\t\tXyes|Xno) erts_cv_brk_wrappers_can_track_malloc=$erl_xcomp_dlsym_brk_wrappers;;\n\t\t*) AC_MSG_ERROR([Bad erl_xcomp_dlsym_brk_wrappers value: $erl_xcomp_dlsym_brk_wrappers]);;\n\t    esac\n\t    ])])\n\tcase $erts_cv_brk_wrappers_can_track_malloc in\n\t    yes)\n\t\tAC_DEFINE(ERTS_BRK_WRAPPERS_CAN_TRACK_MALLOC, 1, \\\n[Define if sbrk()/brk() wrappers can track malloc()s core memory use]);;\n\t    cross)\n\t\tAC_MSG_WARN([result no guessed because of cross compilation]);;\n\t    *) ;;\n\tesac\nfi\n\ndnl Restore LIBS\nLIBS=$saved_libs\ndnl restore CPPFLAGS\nCPPFLAGS=$saved_cppflags\n\ncase $ARCH in\n     x86|amd64)\n\tAC_DEFINE(ERTS_STRUCTURE_ALIGNED_ALLOC, 1, [Define if structure alignment is enough for allocators. If not defined, 64-bit alignment will be forced.]);;\n     *)\n\t;;\nesac\n\nLM_SYS_IPV6\nLM_SYS_MULTICAST\nERL_TIME_CORRECTION\nAC_CHECK_PROG(M4, m4, m4)\n\n\nif test X${enable_hipe} != Xno; then\n        dnl HiPE cannot run without mprotect()\n        if test X$ac_cv_func_mprotect != Xyes; then\n            if test X${enable_hipe} = Xyes; then\n\t        AC_MSG_ERROR([HiPE needs mprotect() on $ARCH])\n            else\n\t        enable_hipe=no\n\t        AC_MSG_WARN([HiPE disabled due to lack of mprotect()])\n            fi\n        fi\n        AC_MSG_CHECKING([for safe signal delivery])\n        AC_TRY_COMPILE([#include <signal.h>],\n          [#if defined(__APPLE__) && defined(__MACH__) && !defined(__DARWIN__)\n           #define __DARWIN__ 1\n           #endif\n\n           #if !(defined(__GLIBC__) || defined(__DARWIN__) || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__sun__))\n          /*\n           * Unknown libc -- assume musl, which does not allow safe signals\n           */\n           #error \"HiPE does not work without a libc that can guarantee that sigaltstack works\"\n           #endif\t/* !(__GLIBC__ || __DARWIN__ || __NetBSD__ || __FreeBSD__ || __sun__) */],\n        [AC_MSG_RESULT([yes])],\n        [enable_hipe=no\n         AC_MSG_RESULT([no, musl probably used. Need glibc to work properly])\n         AC_MSG_WARN([HiPE disabled due to lack of safe signal delivery])])\nfi\n\ndnl check to auto-enable hipe here...\nif test \"$cross_compiling\" != \"yes\" && test X${enable_hipe} != Xno; then\n  if test -z \"$M4\"; then\n\tenable_hipe=no\n   \tAC_MSG_NOTICE([HiPE disabled as no valid m4 is found in PATH])\n  else\n  \tcase \"$ARCH-$OPSYS\" in\n\t    x86-linux|amd64-linux|x86-darwin*|amd64-darwin*|ppc-linux|ppc64-linux|ppc-darwin|arm-linux|amd64-freebsd|x86-freebsd|x86-sol2|amd64-sol2|ultrasparc-linux)\n      \t\tenable_hipe=yes\n      \t\t;;\t\n  \tesac\n  fi\nfi\n\nif test X${enable_hipe} = Xyes; then\n   case $OPSYS in\n\tlinux)\n\t\tppcBEAMLDFLAGS=\"-Wl,-m,elf32ppc\"\n\t\tppc64BEAMLDFLAGS=\"-Wl,-m,elf64ppc,-T,hipe/elf64ppc.x\"\n\t\t;;\n\tdarwin)\n\t\tamd64BEAMLDFLAGS=\"-pagezero_size 0x10000000\"\n\t\t;;\n   esac\n   archVarName=\"${ARCH}BEAMLDFLAGS\"\n   eval HIPEBEAMLDFLAGS=\\$$archVarName\nfi\nAC_SUBST(HIPEBEAMLDFLAGS)\n\ndnl Permanently disable floating point exceptions.\ndnl On x86/amd64, floating points exceptions have\ndnl unresolved stability issues.\nAC_MSG_CHECKING([for unreliable floating point exceptions])\nFPE=unreliable\nAC_SUBST(FPE)\nAC_MSG_RESULT([unreliable])\nAC_DEFINE(NO_FPE_SIGNALS,[],[Define if floating points exceptions are non-existing/not reliable])\n\ndnl\ndnl Some operating systems allow you to redefine FD_SETSIZE to be able\ndnl to select on more than the default number of file descriptors.\ndnl We first discovered this in BSD/OS where the default is ridiculously\ndnl low (256). But since we use a lot of file descriptors we found the\ndnl need to go over the limit in other os's as well. Since FD_SETSIZE \ndnl must be defined before pulling in sys/types.h the actual number\ndnl of file descriptors is set in acconfig.h and will thus be in config.h\ndnl which *always* should be included first.\ndnl\n\nAC_MSG_CHECKING([whether to redefine FD_SETSIZE])\ncase $host_os in\n  bsdi*)\n\tAC_DEFINE(REDEFINE_FD_SETSIZE,[],[Define if you wish to redefine FD_SETSIZE to be able to select on more fd])\n\tAC_MSG_RESULT(yes)\n\t;;\n  *)\n\tAC_MSG_RESULT(no)\n\t;;\nesac\n\n\n\ndnl ----------------------------------------------------------------------\ndnl Tests related to configurable options given on command line\ndnl (using the --disable, --enable and --with switches).\ndnl ----------------------------------------------------------------------\n\n#\n# Check if we should enable HiPE.\n#\n\nHIPE_ENABLED=\nHIPE_HELPERS=\n\ndnl if not disabled, autoenable HiPE on known supported platforms\ndnl done up where floating point is checked, need to descide there already...\n\nif test X${enable_hipe} = Xyes; then\n  if test X$ac_cv_sizeof_void_p != X4 -a X$ARCH != Xamd64 -a X$ARCH != Xppc64; then\n\tAC_MSG_WARN([HiPE is not supported in 64-bit builds])\n  else\n     HIPE_ENABLED=yes\n     AC_DEFINE(HIPE,[1],[Define to enable HiPE])\n     HIPE_HELPERS=\"xmerl syntax_tools edoc\"\n     ENABLE_ALLOC_TYPE_VARS=\"$ENABLE_ALLOC_TYPE_VARS hipe\"\n     AC_MSG_NOTICE([Enable exec_alloc for hipe code allocation])\n     ENABLE_ALLOC_TYPE_VARS=\"$ENABLE_ALLOC_TYPE_VARS exec_alloc\"\n  fi\nfi\nAC_SUBST(HIPE_HELPERS)\nAC_SUBST(HIPE_ENABLED)\n\n#\n# Check if Erlang libraries should be compiled to native code.\n#\nNATIVE_LIBS_ENABLED=\nif test X${enable_native_libs} = Xyes -a X${HIPE_ENABLED} = Xyes; then\n  NATIVE_LIBS_ENABLED=yes\n  cat >> $ERL_TOP/erts/CONF_INFO <<EOF\n\n                 WARNING: In OTP 22, HiPE (the native code compiler) is\n\t\t not fully functional. The reasons for this are:\n\n\t\t 1. There are new BEAM instructions for binary\n\t\t matching that the HiPE native code compiler does not\n\t\t support. \n\n\t\t 2. The new optimizations in the Erlang compiler create\n\t\t new combination of instructions that HiPE currently\n\t\t does not handle correctly.\n\n\t\t If erlc is invoked like so:\n\n\t\t     erlc +native some_file.erl\n\n                 or like so:\n\n                     erlc +native some_file.beam\n\n\t\t and if any of the new binary matching instructions\n\t\t are used, the compiler will issue a warning and\n\t\t produce a BEAM file without native code.\n\nEOF\nfi\nAC_SUBST(NATIVE_LIBS_ENABLED)\n\n#\n# Check for working poll().\n#\nAC_MSG_CHECKING([for working poll()])\nif test \"x$ac_cv_header_poll_h\" != \"xyes\" -o \"x$ac_cv_func_poll\" != \"xyes\"; then\n\npoll_works=no\n\nelse\n\nAC_TRY_RUN([\n#include <poll.h>\nmain()\n{\n#ifdef _POLL_EMUL_H_\n  exit(1); /* Implemented using select() -- fail */\n#else\n  struct pollfd fds[1];\n  int fd;\n  fd = open(\"/dev/null\", 1);\n  fds[0].fd = fd;\n  fds[0].events = POLLIN;\n  fds[0].revents = 0;\n  if (poll(fds, 1, 0) < 0 || (fds[0].revents & POLLNVAL) != 0) {\n    exit(1);  /* Does not work for devices -- fail */\n  }\n  exit(0);\n#endif\n}\n],\npoll_works=yes,\npoll_works=no,\n[\ncase X$erl_xcomp_poll in\n    X) poll_works=cross;;\n    Xyes|Xno) poll_works=$erl_xcomp_poll;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_poll value: $erl_xcomp_poll]);;\nesac\n])\n\nfi\n\ncase $poll_works-$host_os in\n    no-*|cross-darwin*)\n\t#\n\t# The USE_SELECT define is used by the ssl application (should not\n\t# be used by erts).\n\t#\n\tAC_DEFINE(USE_SELECT, 1, [Define if select() should be used instead of poll()])\n\tif test $poll_works = cross; then\n\t    AC_MSG_RESULT(cross)\n\t    AC_MSG_WARN([result no guessed based on OS ($host_os) because of cross compilation])\n\telse\n\t    AC_MSG_RESULT([no; non-existing, broken, or based on select()])\n        fi\n\tpoll_works=no;;\n    yes-*|cross-*)\n\tAC_DEFINE(ERTS_USE_POLL, 1, [Define if poll() should be used instead of select()])\n\tif test $poll_works = cross; then\n\t    AC_MSG_RESULT(cross)\n\t    AC_MSG_WARN([result yes guessed based on OS ($host_os) because of cross compilation])\n\telse\n\t    AC_MSG_RESULT(yes)\n        fi\n\tpoll_works=yes;;\nesac\n\n#\n# If kqueue() found\n#\nif test $have_kernel_poll = kqueue; then\n## Some OS X kernel version seems to have bugs in them with regards to kqueue\n## Disable kernel poll on those versions\n   AC_MSG_CHECKING([whether host os has known kqueue bugs])\n   case $host_os in\n     # Any OS X version < 16 has known problems with using kqueue\n     # so we don't use it there. See erl_poll.c for details.\n     darwin[[0-9]].*|darwin1[[0-5]].*)\n        AC_MSG_RESULT([yes, disabling kernel poll])\n        have_kernel_poll=no\n        ;;\n     *)\n        AC_MSG_RESULT([no])\n        ;;\n   esac\nfi\n#\n# If epoll() found, check that it is level triggered.\n#\nif test $have_kernel_poll = epoll; then\n\tAC_MSG_CHECKING([whether epoll is level triggered])\n\tAC_TRY_LINK([#include <sys/epoll.h>],[\n\t\t\t#ifdef EPOLLET\n\t\t\t/* Edge triggered option exist, assume level triggered\n\t\t\t   is default */\n\t\t\t;\n\t\t\t#else\n\t\t\t/* No edge triggered option exist; assume edge\n\t\t\t   triggered only */\n\t\t\t#error No EPOLLET\n\t\t\t#endif\n\t\t\t],\n\t\t\tlevel_triggered_epoll=yes,\n\t\t\t[level_triggered_epoll=no\n\t\t\t have_kernel_poll=no])\n\tAC_MSG_RESULT([$level_triggered_epoll])\nfi\n#\n# Check if we should enable kernel poll support\n#\nAC_MSG_CHECKING(whether kernel poll support should be enabled)\nERTS_ENABLE_KERNEL_POLL=no\nERTS_BUILD_FALLBACK_POLL=no\ncase $enable_kernel_poll-$have_kernel_poll in\n    no-*)\n\tAC_MSG_RESULT(no; disabled by user);;\n    yes-no)\n\tAC_MSG_ERROR(no; kernel poll support requested but not found);;\n    *-no)\n\tAC_MSG_RESULT(no);;\n    *)\n\tcase $have_kernel_poll in\n\t    epoll)\n\t\tAC_DEFINE(HAVE_SYS_EPOLL_H, 1, [Define if you have the <sys/epoll.h> header file.])\n                ERTS_BUILD_FALLBACK_POLL=yes\n                ;;\n\t    /dev/poll)\n\t\tAC_DEFINE(HAVE_SYS_DEVPOLL_H, 1, [Define if you have <sys/devpoll.h> header file.])\n                ;;\n\t    kqueue)\n\t\tAC_DEFINE(HAVE_SYS_EVENT_H, 1, [Define if you have <sys/event.h> header file.])\n                ERTS_BUILD_FALLBACK_POLL=yes\n                ;;\n\t    *)\n\t\tAC_MSG_ERROR(configure.in need to be updated);;\n\tesac\n\tERTS_ENABLE_KERNEL_POLL=yes\n\tAC_DEFINE(ERTS_ENABLE_KERNEL_POLL, 1, [Define if you have kernel poll and want to use it])\n\tAC_MSG_RESULT([yes; $have_kernel_poll]);;\nesac\nAC_SUBST(ERTS_BUILD_FALLBACK_POLL)\n\nAC_MSG_CHECKING([whether putenv() stores a copy of the key-value pair])\nAC_TRY_RUN([\n#include <stdlib.h>\nint main(void) {\n    int i;\n    char *env;\n    char buf[10];\n    for (i = 0; i < 7; i++)\n\tbuf[i] = 'X';\n    buf[i] = '\\0';\n    buf[3] = '=';\n    if (putenv(buf) != 0)\n\treturn 1;\n    for (i = 4; i < 7; i++)\n\tbuf[i] = 'Y';\n    env = getenv(\"XXX\");\n    if (!env)\n\treturn 2;\n    for (i = 0; i < 3; i++)\n\tif (env[i] != 'X')\n\t    return 3;\n    for (i = 0; i < 3; i++)\n\tbuf[i] = 'Y';\n    env = getenv(\"XXX\");\n    if (!env)\n\treturn 4;\n    for (i = 0; i < 3; i++)\n\tif (env[i] != 'X')\n\t    return 5;\n    return 0;\n}\n],\ncopying_putenv=yes,\ncopying_putenv=no,\n[\ncase X$erl_xcomp_putenv_copy in\n    X) copying_putenv=cross;;\n    Xyes|Xno) copying_putenv=$erl_xcomp_putenv_copy;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_putenv_copy value: $erl_xcomp_putenv_copy]);;\nesac\n])\n\nAC_MSG_RESULT($copying_putenv)\ncase $copying_putenv in\n    yes)\n\tAC_DEFINE(HAVE_COPYING_PUTENV,[1],\\\n[Define if you have a putenv() that stores a copy of the key-value pair]);;\n    cross)\n\tAC_MSG_WARN([result no guessed because of cross compilation]);;\n    *) ;;\nesac\n\ndnl ----------------------------------------------------------------------\ndnl Stuff that should be moved into their respective application\ndnl ----------------------------------------------------------------------\n\ndnl\ndnl We should look for a compiler that handles jump tables, for beam_emu \ndnl to be optimized\ndnl\n\nLM_FIND_EMU_CC\n\ndnl\ndnl Test whether code pointers are always short (32 bits).\ndnl\n\nAC_MSG_CHECKING([whether the code model is small])\nsaved_LDFLAGS=\"$LDFLAGS\"\nLDFLAGS=\"$LDFLAGS $HIPEBEAMLDFLAGS\"\nAC_TRY_RUN([\n   #include <stdlib.h>\n   int main() {\n    if ((unsigned long long)&main < (1ull << 32)) {\n       exit(0);\n    }\n    exit(1);\n   }\n],\nerl_code_model_small=yes,\nerl_code_model_small=no,\n[case X$erl_xcomp_code_model_small in\n      X) erl_code_model_small=no;;\n      Xyes|Xno) erl_code_model_small=$erl_xcomp_code_model_small;;\n      *) AC_MSG_ERROR([Bad erl_xcomp_code_model_small value: $erl_xcomp_code_model_small]);;\n esac])\nAC_MSG_RESULT([$erl_code_model_small])\nLDFLAGS=\"$saved_LDFLAGS\"\ncase $erl_code_model_small in\n     yes)\n        AC_DEFINE(CODE_MODEL_SMALL,[1],\n\t[Define if the code model is small (code fits below 2Gb)])\n\tCODE_MODEL=small\n\t;;\n     no)\n\tCODE_MODEL=unknown\n        ;;\nesac\nAC_SUBST(CODE_MODEL)\n\ndnl\ndnl DTrace & LTTNG\ndnl\ncase $DYNAMIC_TRACE_FRAMEWORK in\n     dtrace|systemtap)\n        AC_CHECK_TOOL(DTRACE, dtrace, none)\n        test \"$DTRACE\" = \"none\" && AC_MSG_ERROR([No dtrace utility found.]);\n        enable_lttng_test=no\n\tenable_dtrace_test=yes;;\n     lttng)\n        enable_lttng_test=yes\n        enable_dtrace_test=no;;\n     *)\n        enable_lttng_test=no\n        enable_dtrace_test=no;;\nesac        \n\t\t     \nAC_SUBST(DTRACE)\n\nAC_SUBST(DTRACE_CPP)\nAC_SUBST(DTRACE_ENABLED)\nAC_SUBST(DTRACE_ENABLED_2STEP)\nDTRACE_CPP=-C\nDTRACE_ENABLED=\nDTRACE_ENABLED_2STEP=\nDTRACE_2STEP_TEST=./dtrace-test.o\nDTRACE_BITS_FLAG=\ncase $OPSYS in\n    freebsd)\n\tif test \"$BITS64\" = \"yes\" ; then\n\t\tDTRACE_BITS_FLAG=-64\n\telse\n\t\tDTRACE_BITS_FLAG=-32\n\tfi\n    ;;\n    *)\n\t: # Nothing to do\n    ;;\nesac\nif test \"$enable_dtrace_test\" = \"yes\" ; then\n        if test \"$DTRACE\" = \"dtrace\" ; then\n                AC_CHECK_HEADERS(sys/sdt.h)\n\t\tAC_MSG_CHECKING([for 1-stage DTrace precompilation])\n                # The OS X version of dtrace prints a spurious line here.\n                if ! dtrace -h $DTRACE_CPP -Iemulator/beam -o ./foo-dtrace.h -s emulator/beam/erlang_dtrace.d; then\n                        AC_MSG_ERROR([Could not precompile erlang_dtrace.d: dtrace -h failed])\n                fi\n\t\tAC_MSG_RESULT([yes])\n\n\t\tAC_MSG_CHECKING([for 2-stage DTrace precompilation])\n                AC_TRY_COMPILE([ #include \"foo-dtrace.h\" ],\n                    [ERLANG_DIST_PORT_BUSY_ENABLED();],\n\t\t    [rm -f $DTRACE_2STEP_TEST\n\t\t     dtrace -G $DTRACE_CPP $DTRACE_BITS_FLAG -Iemulator/beam -o $DTRACE_2STEP_TEST -s emulator/beam/erlang_dtrace.d conftest.$OBJEXT 2>&AS_MESSAGE_LOG_FD\n                     if test -f $DTRACE_2STEP_TEST; then\n\t\t\trm -f $DTRACE_2STEP_TEST\n                        DTRACE_ENABLED_2STEP=yes\n\t\t     fi],\n                    [])\n\t\trm -f foo-dtrace.h\n\t\tAS_IF([test \"x$DTRACE_ENABLED_2STEP\" = \"xyes\"],\n\t\t      [AC_MSG_RESULT([yes])],\n                      [AC_MSG_RESULT([no])])\n\n                DTRACE_ENABLED=yes\n                case $OPSYS in\n                    linux)\n                        : # No extra libs to add to LIBS\n                    ;;\n                    freebsd)\n                        LIBS=\"$LIBS -lelf\"\n                    ;;\n                    *)\n                        LIBS=\"$LIBS -ldtrace\"\n                    ;;\n                esac\n        else\n                AC_MSG_ERROR([Dtrace preprocessing test failed.])\n        fi\nfi\n\nif test \"$enable_lttng_test\" = \"yes\" ; then\n    AC_CHECK_HEADERS(lttng/tracepoint.h)\n    AC_CHECK_HEADERS(lttng/tracepoint-event.h)\n    dnl The macro tracepoint_enabled is not present in older lttng versions\n    dnl checking for tracepoint_enabled\n    AC_MSG_CHECKING([for tracepoint_enabled in lttng/tracepoint.h])\n    AC_COMPILE_IFELSE(\n        [AC_LANG_PROGRAM(\n            [#include <lttng/tracepoint.h>\n             #define TRACEPOINT_PROVIDER org_erlang_otp\n             TRACEPOINT_EVENT(\n                 org_erlang_otp,\n                 dummy,\n                 TP_ARGS(int, my_int),\n                 TP_FIELDS(ctf_integer(int, my_int, my_int)))\n             #define TRACEPOINT_CREATE_PROBES\n             #define TRACEPOINT_DEFINE],\n            [if(tracepoint_enabled(org_erlang_otp,dummy)) do {} while(0)])],\n        [AC_MSG_RESULT([yes])],\n        [AC_MSG_ERROR([no (available in lttng-ust v2.7)])])\n    if test \"x$ac_cv_header_lttng_tracepoint_h\" = \"xyes\" \\\n        -a \"x$ac_cv_header_lttng_tracepoint_event_h\" = \"xyes\"; then\n        # No straight forward way to test for liblttng-ust when no public symbol exists,\n        # just add the lib.\n        LIBS=\"$LIBS -llttng-ust -ldl\"\n    else\n        AC_MSG_ERROR([No LTTng support found.])\n    fi\nfi\n\n\n#--------------------------------------------------------------------\n# Os mon stuff.\n#--------------------------------------------------------------------\nAC_SUBST(os_mon_programs)\nAC_SUBST(CPU_SUP_LIBS)\n\nAC_CHECK_LIB(kstat, kstat_open, [ \n\tuse_cpu_sup=yes\n\tCPU_SUP_LIBS=\"$CPU_SUP_LIBS -lkstat\"\n\t])\n\nAC_CHECK_LIB(kvm, kvm_open, [\n\tuse_cpu_sup=yes\n\tCPU_SUP_LIBS=\"$CPU_SUP_LIBS -lkvm\"\n\t])\n\ncase $host_os in\n\tsolaris2*)\n\t\tos_mon_programs=\"$os_mon_programs ferrule mod_syslog\" ;;\n\tdarwin*)\n\t\tuse_cpu_sup=yes ;;\n\topenbsd*)\n\t\tuse_cpu_sup=yes ;;\n\tlinux*)\n\t\tuse_cpu_sup=yes ;;\n\tfreebsd*)\n\t\tuse_cpu_sup=yes ;;\nesac\n\nif test \"$use_cpu_sup\" = \"yes\"; then\n    os_mon_programs=\"$os_mon_programs cpu_sup\"\nfi\n\nAC_ARG_WITH(javac,\nAS_HELP_STRING([--with-javac=JAVAC], [specify Java compiler to use])\nAS_HELP_STRING([--with-javac], [use a Java compiler if found (default)])\nAS_HELP_STRING([--without-javac], [don't use any Java compiler]))\n\ndnl\ndnl Then there are a number of apps which needs a java compiler...\ndnl\nneed_java=\"jinterface\"\n\nif test -d $ERL_TOP/lib/ic; then\n   need_java=\"$need_java ic/java_src\"\nfi\n\n# Remove all SKIP files from previous runs\nfor a in $need_java ; do\n  rm -f $ERL_TOP/lib/$a/SKIP\ndone\n\nif test \"X$with_javac\" = \"Xno\"; then\n  for a in $need_java ; do\n\techo \"Java compiler disabled by user\" > $ERL_TOP/lib/$a/SKIP\n  done\n\nelse # begin - try to find javac\n\nif test \"X$with_javac\" != \"Xyes\" -a \"X$with_javac\" != \"X\"; then\n    check_javac=$with_javac\nelse\n  check_javac=\"javac.sh javac guavac gcj jikes bock\"\nfi\n\nAC_CHECK_PROGS(JAVAC, $check_javac)\nif test -n \"$JAVAC\"; then\n  dnl Make sure it's at least JDK 1.6\n  AC_CACHE_CHECK(for JDK version 1.6, \n     ac_cv_prog_javac_ver_1_6,\n     [ERL_TRY_LINK_JAVA([], [for (String i : args);],\n        ac_cv_prog_javac_ver_1_6=yes, ac_cv_prog_javac_ver_1_6=no)])\n  if test $ac_cv_prog_javac_ver_1_6 = no; then\n    unset -v JAVAC\n  fi\nfi\nif test -z \"$JAVAC\"; then\n\n  if test \"X$with_javac\" != \"X\"; then\n  \tAC_MSG_ERROR([No java compiler found in PATH (checked for $check_javac)])\n  fi\n\n  AC_MSG_WARN([Could not find any usable java compiler, will skip: jinterface])\n\n  for a in $need_java ; do\n\techo \"No Java compiler found\" > $ERL_TOP/lib/$a/SKIP\n  done\nfi\n\nfi # end - try to find javac\n\ndnl\ndnl Orber has a c++ example, this isn't the right way to check for\ndnl it, but....\ndnl\nAC_SUBST(CXXFLAGS)\ndnl this deliberately does not believe that 'gcc' is a C++ compiler\nAC_CHECK_TOOLS(CXX, [$CCC c++ g++ CC cxx cc++ cl], false)\n\n# Remove SKIP file from previous run\nrm -f $ERL_TOP/lib/orber/SKIP\n\nif test \"$CXX\" = false; then\n  echo \"No C++ compiler found\" > $ERL_TOP/lib/orber/SKIP\nfi\n\ndnl ----------------------------------------------------------------------\ndnl Include CPPFLAGS in CFLAGS\ndnl ----------------------------------------------------------------------\nCFLAGS=\"$CFLAGS $CPPFLAGS\"\n\n#\n# Currently if we compile for 64 bits we want to compile\n# some external port programs using 32 bits\n#\n\n# If not defined we trust the C compiler in $CC to do 32 bits\nif test -z \"$CC32\"; then\n  CC32=\"$CC\"\nfi\n\nif test -z \"$CFLAGS32\"; then\n  if test $ac_cv_sizeof_void_p != 4; then\n    # We are compiling default 64 bits and use -m32 for 32 bit compilations\n    CFLAGS32=\"$CFLAGS -m32\"\n  else\n    CFLAGS32=\"$CFLAGS\"\n  fi\nfi\n\nAC_SUBST(CC32)\nAC_SUBST(CFLAGS32)\n\ndnl\ndnl ERTS_EMU_CMDLINE_FLAGS will force modification of config.h when\ndnl the emulator command line flags are modified by configure, which\ndnl in turn will make 'make' detect that files depending on config.h\ndnl needs to be rebuilt.\ndnl\n\nAC_DEFINE_UNQUOTED(ERTS_EMU_CMDLINE_FLAGS,\n\"$STATIC_CFLAGS $CFLAGS $DEBUG_CFLAGS $EMU_THR_DEFS $DEFS $WERRORFLAGS $WFLAGS\",\n[The only reason ERTS_EMU_CMDLINE_FLAGS exists is to force modification of config.h when the emulator command line flags are modified by configure])\n\nAC_SUBST(STATIC_CFLAGS)\n\ndnl ----------------------------------------------------------------------\ndnl Directories needed for the build\ndnl ----------------------------------------------------------------------\n\nerts=${erl_top}/erts\n\nerts_dirs=\"\t\t\t\t\t\t\t\t\n  $erts/obj $erts/obj.debug\n\t\t\t\t\t\t\t\t\t\n  $erts/obj/$host\n  $erts/obj.debug/$host\n\n\"\nfor d in ${erl_top}/bin ${erl_top}/bin/$host $erts_dirs ;\ndo\n  if test ! -d $d; then\n    mkdir -p 1>/dev/null 2>&1 $d\n  fi\ndone\n\ndnl ---------------------------------------------------------------------\ndnl Autoheader macro for adding code at top and bottom of config.h.in\ndnl ---------------------------------------------------------------------\nAH_TOP([\n#define GHBN_R_SOLARIS  2\n#define GHBN_R_AIX      3\n#define GHBN_R_GLIBC    4\n])\n\nAH_BOTTOM([\n/* Redefine in6_addr. XXX this should be moved to the files where it's used? */\n#ifdef HAVE_IN_ADDR6_STRUCT\n#define in6_addr in_addr6\n#endif\n\n/* Define a reasonable default for INADDR_LOOPBACK */\n/* XXX this should be moved to the files where it's used? */\n#ifdef HAVE_NO_INADDR_LOOPBACK\n#define INADDR_LOOPBACK (u_long)0x7F000001\n#endif\n\n#ifdef REDEFINE_FD_SETSIZE\n#define FD_SETSIZE 1024\n#endif\n \n#ifdef HAVE_GETHRVTIME_PROCFS_IOCTL\n#define HAVE_GETHRVTIME\n#endif\n\n#if !defined(HAVE_ISFINITE) && !defined(HAVE_FINITE)\n# if defined(HAVE_ISINF) && defined(HAVE_ISNAN)\n#  define USE_ISINF_ISNAN\n# endif\n#endif\n\n#if defined(DEBUG) && !defined(ERTS_ENABLE_LOCK_CHECK)\n#define ERTS_ENABLE_LOCK_CHECK 1\n#endif\n])\n\nif test \"x$GCC\" = xyes; then\n  CFLAGS=\"$WERRORFLAGS $CFLAGS\"\nfi\n\ndnl ----------------------------------------------------------------------\ndnl Enable -fsanitize= flags.\ndnl ----------------------------------------------------------------------\n\nm4_define(DEFAULT_SANITIZERS, [address,undefined])\nAC_ARG_ENABLE(\n    sanitizers,\n    AS_HELP_STRING(\n        [--enable-sanitizers@<:@=comma-separated list of sanitizers@:>@],\n\t    [Default=DEFAULT_SANITIZERS]),\n[\ncase \"$enableval\" in\n    no) sanitizers= ;;\n    yes) sanitizers=\"-fsanitize=DEFAULT_SANITIZERS\" ;;\n    *) sanitizers=\"-fsanitize=$enableval\" ;;\nesac\nCFLAGS=\"$CFLAGS $sanitizers\"\nLDFLAGS=\"$LDFLAGS $sanitizers\"\n])\n\ndnl ----------------------------------------------------------------------\ndnl Check for log2\ndnl ----------------------------------------------------------------------\nAC_CHECK_FUNCS([log2])\n\ndnl ----------------------------------------------------------------------\ndnl Output the result.\ndnl ----------------------------------------------------------------------\n\ndnl  Note that the output files are relative to $srcdir\nAC_CONFIG_FILES([\n  emulator/$host/Makefile:emulator/Makefile.in\n  epmd/src/$host/Makefile:epmd/src/Makefile.in\n  etc/common/$host/Makefile:etc/common/Makefile.in\n  include/internal/$host/ethread.mk:include/internal/ethread.mk.in\n  include/internal/$host/erts_internal.mk:include/internal/erts_internal.mk.in\n  lib_src/$host/Makefile:lib_src/Makefile.in\n  ../make/$host/otp.mk:../make/otp.mk.in\n])\n\nAC_CONFIG_FILES([../make/make_emakefile:../make/make_emakefile.in],\n                [chmod +x ../make/make_emakefile])\n\ndnl\ndnl The ones below should be moved to their respective lib\ndnl\nAC_CONFIG_FILES([\n  ../lib/os_mon/c_src/$host/Makefile:../lib/os_mon/c_src/Makefile.in\n  ../lib/runtime_tools/c_src/$host/Makefile:../lib/runtime_tools/c_src/Makefile.in\n  ../lib/tools/c_src/$host/Makefile:../lib/tools/c_src/Makefile.in\n  ])\n\nAC_CONFIG_FILES([../make/install_dir_data.sh:../make/install_dir_data.sh.in], [chmod +x ../make/install_dir_data.sh])\n\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/aclocal.m4": "dnl\ndnl %CopyrightBegin%\ndnl\ndnl Copyright Ericsson AB 1998-2018. All Rights Reserved.\ndnl\ndnl Licensed under the Apache License, Version 2.0 (the \"License\");\ndnl you may not use this file except in compliance with the License.\ndnl You may obtain a copy of the License at\ndnl\ndnl     http://www.apache.org/licenses/LICENSE-2.0\ndnl\ndnl Unless required by applicable law or agreed to in writing, software\ndnl distributed under the License is distributed on an \"AS IS\" BASIS,\ndnl WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\ndnl See the License for the specific language governing permissions and\ndnl limitations under the License.\ndnl\ndnl %CopyrightEnd%\ndnl\n\ndnl\ndnl aclocal.m4\ndnl\ndnl Local macros used in configure.in. The Local Macros which\ndnl could/should be part of autoconf are prefixed LM_, macros specific\ndnl to the Erlang system are prefixed ERL_.\ndnl\n\nAC_DEFUN(LM_PRECIOUS_VARS,\n[\n\ndnl ERL_TOP\nAC_ARG_VAR(ERL_TOP, [Erlang/OTP top source directory])\n\ndnl Tools\nAC_ARG_VAR(CC, [C compiler])\nAC_ARG_VAR(CFLAGS, [C compiler flags])\nAC_ARG_VAR(STATIC_CFLAGS, [C compiler static flags])\nAC_ARG_VAR(CFLAG_RUNTIME_LIBRARY_PATH, [runtime library path linker flag passed via C compiler])\nAC_ARG_VAR(CPP, [C/C++ preprocessor])\nAC_ARG_VAR(CPPFLAGS, [C/C++ preprocessor flags])\nAC_ARG_VAR(CXX, [C++ compiler])\nAC_ARG_VAR(CXXFLAGS, [C++ compiler flags])\nAC_ARG_VAR(LD, [linker (is often overridden by configure)])\nAC_ARG_VAR(LDFLAGS, [linker flags (can be risky to set since LD may be overriden by configure)])\nAC_ARG_VAR(LIBS, [libraries])\nAC_ARG_VAR(DED_LD, [linker for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(DED_LDFLAGS, [linker flags for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(DED_LD_FLAG_RUNTIME_LIBRARY_PATH, [runtime library path linker flag for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(LFS_CFLAGS, [large file support C compiler flags (set all LFS_* variables or none)])\nAC_ARG_VAR(LFS_LDFLAGS, [large file support linker flags (set all LFS_* variables or none)])\nAC_ARG_VAR(LFS_LIBS, [large file support libraries (set all LFS_* variables or none)])\nAC_ARG_VAR(RANLIB, [ranlib])\nAC_ARG_VAR(AR, [ar])\nAC_ARG_VAR(GETCONF, [getconf])\n\ndnl Cross system root\nAC_ARG_VAR(erl_xcomp_sysroot, [Absolute cross system root path (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_isysroot, [Absolute cross system root include path (only used when cross compiling)])\n\ndnl Cross compilation variables\nAC_ARG_VAR(erl_xcomp_bigendian, [big endian system: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_double_middle_endian, [double-middle-endian system: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_nptl, [have Native POSIX Thread Library: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_usable_sigusrx, [SIGUSR1 and SIGUSR2 can be used: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_usable_sigaltstack, [have working sigaltstack(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_poll, [have working poll(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_kqueue, [have working kqueue(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_putenv_copy, [putenv() stores key-value copy: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_reliable_fpe, [have reliable floating point exceptions: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_getaddrinfo, [have working getaddrinfo() for both IPv4 and IPv6: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_gethrvtime_procfs_ioctl, [have working gethrvtime() which can be used with procfs ioctl(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_clock_gettime_cpu_time, [clock_gettime() can be used for retrieving process CPU time: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_after_morecore_hook, [__after_morecore_hook can track malloc()s core memory usage: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_dlsym_brk_wrappers, [dlsym(RTLD_NEXT, _) brk wrappers can track malloc()s core memory usage: yes|no (only used when cross compiling)])\n\n])\n\nAC_DEFUN(ERL_XCOMP_SYSROOT_INIT,\n[\nerl_xcomp_without_sysroot=no\nif test \"$cross_compiling\" = \"yes\"; then\n    test \"$erl_xcomp_sysroot\" != \"\" || erl_xcomp_without_sysroot=yes\n    test \"$erl_xcomp_isysroot\" != \"\" || erl_xcomp_isysroot=\"$erl_xcomp_sysroot\"\nelse\n    erl_xcomp_sysroot=\n    erl_xcomp_isysroot=\nfi\n])\n\nAC_DEFUN(LM_CHECK_GETCONF,\n[\nif test \"$cross_compiling\" != \"yes\"; then\n    AC_CHECK_PROG([GETCONF], [getconf], [getconf], [false])\nelse\n    dnl First check if we got a `<HOST>-getconf' in $PATH\n    host_getconf=\"$host_alias-getconf\"\n    AC_CHECK_PROG([GETCONF], [$host_getconf], [$host_getconf], [false])\n    if test \"$GETCONF\" = \"false\" && test \"$erl_xcomp_sysroot\" != \"\"; then\n\tdnl We should perhaps give up if we have'nt found it by now, but at\n\tdnl least in one Tilera MDE `getconf' under sysroot is a bourne\n\tdnl shell script which we can use. We try to find `<HOST>-getconf'\n    \tdnl or `getconf' under sysconf, but only under sysconf since\n\tdnl `getconf' in $PATH is almost guaranteed to be for the build\n\tdnl machine.\n\tGETCONF=\n\tprfx=\"$erl_xcomp_sysroot\"\n        AC_PATH_TOOL([GETCONF], [getconf], [false],\n\t             [\"$prfx/usr/bin:$prfx/bin:$prfx/usr/local/bin\"])\n    fi\nfi\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_WINDOWS_ENVIRONMENT\ndnl\ndnl\ndnl Tries to determine thw windows build environment, i.e. \ndnl MIXED_CYGWIN_VC or MIXED_MSYS_VC \ndnl\n\nAC_DEFUN(LM_WINDOWS_ENVIRONMENT,\n[\n\nif test \"X$windows_environment_\" != \"Xchecked\"; then\nwindows_environment_=checked\nMIXED_CYGWIN=no\nMIXED_MSYS=no\n\nAC_MSG_CHECKING(for mixed cygwin or msys and native VC++ environment)\nif test \"X$host\" = \"Xwin32\" -a \"x$GCC\" != \"xyes\"; then\n\tif test -x /usr/bin/msys-?.0.dll; then\n\t        CFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_MSYS=yes\n\t\tAC_MSG_RESULT([MSYS and VC])\n\t\tMIXED_MSYS_VC=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_MSYS_VC\"\n\telif test -x /usr/bin/cygpath; then\n\t\tCFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_CYGWIN=yes\n\t\tAC_MSG_RESULT([Cygwin and VC])\n\t\tMIXED_CYGWIN_VC=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_CYGWIN_VC\"\n\telse\t\t    \n\t\tAC_MSG_RESULT([undeterminable])\n\t\tAC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)\n\tfi\nelse\n\tAC_MSG_RESULT([no])\n\tMIXED_CYGWIN_VC=no\n\tMIXED_MSYS_VC=no\nfi\nAC_SUBST(MIXED_CYGWIN_VC)\nAC_SUBST(MIXED_MSYS_VC)\n\nMIXED_VC=no\nif test \"x$MIXED_MSYS_VC\" = \"xyes\" -o  \"x$MIXED_CYGWIN_VC\" = \"xyes\" ; then\n   MIXED_VC=yes\nfi\n\nAC_SUBST(MIXED_VC)\n\nif test \"x$MIXED_MSYS\" != \"xyes\"; then\n   AC_MSG_CHECKING(for mixed cygwin and native MinGW environment)\n   if test \"X$host\" = \"Xwin32\" -a \"x$GCC\" = x\"yes\"; then\n\tif test -x /usr/bin/cygpath; then\n\t\tCFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_CYGWIN=yes\n\t\tAC_MSG_RESULT([yes])\n\t\tMIXED_CYGWIN_MINGW=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_CYGWIN_MINGW\"\n\telse\n\t\tAC_MSG_RESULT([undeterminable])\n\t\tAC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)\n\tfi\n    else\n\tAC_MSG_RESULT([no])\n\tMIXED_CYGWIN_MINGW=no\n    fi\nelse\n\tMIXED_CYGWIN_MINGW=no\nfi\t\nAC_SUBST(MIXED_CYGWIN_MINGW)\n\nAC_MSG_CHECKING(if we mix cygwin with any native compiler)\nif test \"X$MIXED_CYGWIN\" = \"Xyes\"; then\n\tAC_MSG_RESULT([yes])\t\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nAC_SUBST(MIXED_CYGWIN)\n\t\nAC_MSG_CHECKING(if we mix msys with another native compiler)\nif test \"X$MIXED_MSYS\" = \"Xyes\" ; then\n\tAC_MSG_RESULT([yes])\t\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nAC_SUBST(MIXED_MSYS)\n\nfi\n])\t\t\n\t\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_FIND_EMU_CC\ndnl\ndnl\ndnl Tries fairly hard to find a C compiler that can handle jump tables.\ndnl Defines the @EMU_CC@ variable for the makefiles and \ndnl inserts NO_JUMP_TABLE in the header if one cannot be found...\ndnl\n\nAC_DEFUN(LM_FIND_EMU_CC,\n\t[AC_CACHE_CHECK(for a compiler that handles jumptables,\n\t\t\tac_cv_prog_emu_cc,\n\t\t\t[\nAC_TRY_COMPILE([],[\n#if defined(__clang_major__) && __clang_major__ >= 3\n    /* clang 3.x or later is fine */\n#elif defined(__llvm__)\n#error \"this version of llvm is unable to correctly compile beam_emu.c\"\n#endif\n    __label__ lbl1;\n    __label__ lbl2;\n    int x = magic();\n    static void *jtab[2];\n\n    jtab[0] = &&lbl1;\n    jtab[1] = &&lbl2;\n    goto *jtab[x];\nlbl1:\n    return 1;\nlbl2:\n    return 2;\n],ac_cv_prog_emu_cc=\"$CC\",ac_cv_prog_emu_cc=no)\n\nif test \"$ac_cv_prog_emu_cc\" = no; then\n\tfor ac_progname in emu_cc.sh gcc-4.2 gcc; do\n  \t\tIFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\":\"\n  \t\tac_dummy=\"$PATH\"\n  \t\tfor ac_dir in $ac_dummy; do\n    \t\t\ttest -z \"$ac_dir\" && ac_dir=.\n    \t\t\tif test -f \"$ac_dir/$ac_progname\"; then\n      \t\t\t\tac_cv_prog_emu_cc=\"$ac_dir/$ac_progname\"\n      \t\t\t\tbreak\n    \t\t\tfi\n  \t\tdone\n  \t\tIFS=\"$ac_save_ifs\"\n\t\tif test \"$ac_cv_prog_emu_cc\" != no; then\n\t\t\tbreak\n\t\tfi\n\tdone\nfi\n\nif test \"$ac_cv_prog_emu_cc\" != no; then\n\tsave_CC=\"$CC\"\n\tsave_CFLAGS=$CFLAGS\n\tsave_CPPFLAGS=$CPPFLAGS\n\tCC=\"$ac_cv_prog_emu_cc\"\n\tCFLAGS=\"\"\n\tCPPFLAGS=\"\"\n\tAC_TRY_COMPILE([],[\n#if defined(__clang_major__) && __clang_major__ >= 3\n    /* clang 3.x or later is fine */\n#elif defined(__llvm__)\n#error \"this version of llvm is unable to correctly compile beam_emu.c\"\n#endif\n    \t__label__ lbl1;\n    \t__label__ lbl2;\n    \tint x = magic();\n    \tstatic void *jtab[2];\n\n    \tjtab[0] = &&lbl1;\n    \tjtab[1] = &&lbl2;\n    \tgoto *jtab[x];\n\tlbl1:\n    \treturn 1;\n\tlbl2:\n    \treturn 2;\n\t],ac_cv_prog_emu_cc=\"$CC\",ac_cv_prog_emu_cc=no)\n\tCC=$save_CC\n\tCFLAGS=$save_CFLAGS\n\tCPPFLAGS=$save_CPPFLAGS\nfi\n])\nif test \"$ac_cv_prog_emu_cc\" = no; then\n\tAC_DEFINE(NO_JUMP_TABLE,[],[Defined if no found C compiler can handle jump tables])\n\tEMU_CC=\"$CC\"\nelse\n\tEMU_CC=\"$ac_cv_prog_emu_cc\"\nfi\nAC_SUBST(EMU_CC)\n])\t\t\n\t\t\t\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_PROG_INSTALL_DIR\ndnl\ndnl This macro may be used by any OTP application.\ndnl\ndnl Figure out how to create directories with parents.\ndnl (In my opinion INSTALL_DIR is a bad name, MKSUBDIRS or something is better)\ndnl\ndnl We prefer 'install -d', but use 'mkdir -p' if it exists.\ndnl If none of these methods works, we give up.\ndnl\n\n\nAC_DEFUN(LM_PROG_INSTALL_DIR,\n[AC_CACHE_CHECK(how to create a directory including parents,\nac_cv_prog_mkdir_p,\n[\ntemp_name_base=config.$$\ntemp_name=$temp_name_base/x/y/z\n$INSTALL -d $temp_name >/dev/null 2>&1\nac_cv_prog_mkdir_p=none\nif test -d $temp_name; then\n        ac_cv_prog_mkdir_p=\"$INSTALL -d\"\nelse\n        mkdir -p $temp_name >/dev/null 2>&1\n        if test -d $temp_name; then\n                ac_cv_prog_mkdir_p=\"mkdir -p\"\n        fi\nfi\nrm -fr $temp_name_base           \n])\n\ncase \"${ac_cv_prog_mkdir_p}\" in\n  none) AC_MSG_ERROR(don't know how create directories with parents) ;;\n  *)    INSTALL_DIR=\"$ac_cv_prog_mkdir_p\" AC_SUBST(INSTALL_DIR)     ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_PROG_PERL5\ndnl\ndnl Try to find perl version 5. If found set PERL to the absolute path\ndnl of the program, if not found set PERL to false.\ndnl\ndnl On some systems /usr/bin/perl is perl 4 and e.g.\ndnl /usr/local/bin/perl is perl 5. We try to handle this case by\ndnl putting a couple of \ndnl Tries to handle the case that there are two programs called perl\ndnl in the path and one of them is perl 5 and the other isn't. \ndnl\nAC_DEFUN(LM_PROG_PERL5,\n[AC_PATH_PROGS(PERL, perl5 perl, false,\n   /usr/local/bin:/opt/local/bin:/usr/local/gnu/bin:${PATH})\nchangequote(, )dnl\ndnl[ That bracket is needed to balance the right bracket below\nif test \"$PERL\" = \"false\" || $PERL -e 'exit ($] >= 5)'; then\nchangequote([, ])dnl\n  ac_cv_path_PERL=false\n  PERL=false\ndnl  AC_MSG_WARN(perl version 5 not found)\nfi\n])dnl\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_SO_BSDCOMPAT\ndnl\ndnl Check if the system has the SO_BSDCOMPAT flag on sockets (linux) \ndnl\nAC_DEFUN(LM_DECL_SO_BSDCOMPAT,\n[AC_CACHE_CHECK([for SO_BSDCOMPAT declaration], ac_cv_decl_so_bsdcompat,\nAC_TRY_COMPILE([#include <sys/socket.h>], [int i = SO_BSDCOMPAT;],\n               ac_cv_decl_so_bsdcompat=yes,\n               ac_cv_decl_so_bsdcompat=no))\n\ncase \"${ac_cv_decl_so_bsdcompat}\" in\n  \"yes\" ) AC_DEFINE(HAVE_SO_BSDCOMPAT,[],\n\t\t[Define if you have SO_BSDCOMPAT flag on sockets]) ;;\n  * ) ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_INADDR_LOOPBACK\ndnl\ndnl Try to find declaration of INADDR_LOOPBACK, if nowhere provide a default\ndnl\n\nAC_DEFUN(LM_DECL_INADDR_LOOPBACK,\n[AC_CACHE_CHECK([for INADDR_LOOPBACK in netinet/in.h],\n ac_cv_decl_inaddr_loopback,\n[AC_TRY_COMPILE([#include <sys/types.h>\n#include <netinet/in.h>], [int i = INADDR_LOOPBACK;],\nac_cv_decl_inaddr_loopback=yes, ac_cv_decl_inaddr_loopback=no)\n])\n\nif test ${ac_cv_decl_inaddr_loopback} = no; then\n  AC_CACHE_CHECK([for INADDR_LOOPBACK in rpc/types.h],\n                   ac_cv_decl_inaddr_loopback_rpc,\n                   AC_TRY_COMPILE([#include <rpc/types.h>],\n                                   [int i = INADDR_LOOPBACK;],\n                                   ac_cv_decl_inaddr_loopback_rpc=yes,\n                                   ac_cv_decl_inaddr_loopback_rpc=no))\n\n   case \"${ac_cv_decl_inaddr_loopback_rpc}\" in\n     \"yes\" )\n        AC_DEFINE(DEF_INADDR_LOOPBACK_IN_RPC_TYPES_H,[],\n\t\t[Define if you need to include rpc/types.h to get INADDR_LOOPBACK defined]) ;;\n      * )\n  \tAC_CACHE_CHECK([for INADDR_LOOPBACK in winsock2.h],\n                   ac_cv_decl_inaddr_loopback_winsock2,\n                   AC_TRY_COMPILE([#define WIN32_LEAN_AND_MEAN\n\t\t\t\t   #include <winsock2.h>],\n                                   [int i = INADDR_LOOPBACK;],\n                                   ac_cv_decl_inaddr_loopback_winsock2=yes,\n                                   ac_cv_decl_inaddr_loopback_winsock2=no))\n\tcase \"${ac_cv_decl_inaddr_loopback_winsock2}\" in\n     \t\t\"yes\" )\n\t\t\tAC_DEFINE(DEF_INADDR_LOOPBACK_IN_WINSOCK2_H,[],\n\t\t\t\t[Define if you need to include winsock2.h to get INADDR_LOOPBACK defined]) ;;\n\t\t* )\n\t\t\t# couldn't find it anywhere\n        \t\tAC_DEFINE(HAVE_NO_INADDR_LOOPBACK,[],\n\t\t\t\t[Define if you don't have a definition of INADDR_LOOPBACK]) ;;\n\tesac;;\n   esac\nfi\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_STRUCT_SOCKADDR_SA_LEN\ndnl\ndnl Check if the sockaddr structure has the field sa_len\ndnl\n\nAC_DEFUN(LM_STRUCT_SOCKADDR_SA_LEN,\n[AC_CACHE_CHECK([whether struct sockaddr has sa_len field],\n                ac_cv_struct_sockaddr_sa_len,\nAC_TRY_COMPILE([#include <sys/types.h>\n#include <sys/socket.h>], [struct sockaddr s; s.sa_len = 10;],\n  ac_cv_struct_sockaddr_sa_len=yes, ac_cv_struct_sockaddr_sa_len=no))\n\ndnl FIXME convbreak\ncase ${ac_cv_struct_sockaddr_sa_len} in\n  \"no\" ) AC_DEFINE(NO_SA_LEN,[1],[Define if you dont have salen]) ;;\n  *) ;;\nesac\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_STRUCT_EXCEPTION\ndnl\ndnl Check to see whether the system supports the matherr function\ndnl and its associated type \"struct exception\".\ndnl\n\nAC_DEFUN(LM_STRUCT_EXCEPTION,\n[AC_CACHE_CHECK([for struct exception (and matherr function)],\n ac_cv_struct_exception,\nAC_TRY_COMPILE([#include <math.h>],\n  [struct exception x; x.type = DOMAIN; x.type = SING;],\n  ac_cv_struct_exception=yes, ac_cv_struct_exception=no))\n\ncase \"${ac_cv_struct_exception}\" in\n  \"yes\" ) AC_DEFINE(USE_MATHERR,[1],[Define if you have matherr() function and struct exception type]) ;;\n  *  ) ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_SYS_IPV6\ndnl\ndnl Check for ipv6 support and what the in6_addr structure is called.\ndnl (early linux used in_addr6 insted of in6_addr)\ndnl\n\nAC_DEFUN(LM_SYS_IPV6,\n[AC_MSG_CHECKING(for IP version 6 support)\nAC_CACHE_VAL(ac_cv_sys_ipv6_support,\n[ok_so_far=yes\n AC_TRY_COMPILE([#include <sys/types.h>\n#ifdef __WIN32__\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <netinet/in.h>\n#endif],\n   [struct in6_addr a6; struct sockaddr_in6 s6;], ok_so_far=yes, ok_so_far=no)\n\nif test $ok_so_far = yes; then\n  ac_cv_sys_ipv6_support=yes\nelse\n  AC_TRY_COMPILE([#include <sys/types.h>\n#ifdef __WIN32__\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <netinet/in.h>\n#endif],\n    [struct in_addr6 a6; struct sockaddr_in6 s6;],\n    ac_cv_sys_ipv6_support=in_addr6, ac_cv_sys_ipv6_support=no)\nfi\n])dnl\n\ndnl\ndnl Have to use old style AC_DEFINE due to BC with old autoconf.\ndnl\n\ncase ${ac_cv_sys_ipv6_support} in\n  yes)\n    AC_MSG_RESULT(yes)\n    AC_DEFINE(HAVE_IN6,[1],[Define if ipv6 is present])\n    ;;\n  in_addr6)\n    AC_MSG_RESULT([yes (but I am redefining in_addr6 to in6_addr)])\n    AC_DEFINE(HAVE_IN6,[1],[Define if ipv6 is present])\n    AC_DEFINE(HAVE_IN_ADDR6_STRUCT,[],[Early linux used in_addr6 instead of in6_addr, define if you have this])\n    ;;\n  *)\n    AC_MSG_RESULT(no)\n    ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_SYS_MULTICAST\ndnl\ndnl Check for multicast support. Only checks for multicast options in\ndnl setsockopt(), no check is performed that multicasting actually works.\ndnl If options are found defines HAVE_MULTICAST_SUPPORT\ndnl\n\nAC_DEFUN(LM_SYS_MULTICAST,\n[AC_CACHE_CHECK([for multicast support], ac_cv_sys_multicast_support,\n[AC_EGREP_CPP(^yes$,\n[#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#if defined(IP_MULTICAST_TTL) && defined(IP_MULTICAST_LOOP) && defined(IP_MULTICAST_IF) && defined(IP_ADD_MEMBERSHIP) && defined(IP_DROP_MEMBERSHIP)\nyes\n#endif\n], ac_cv_sys_multicast_support=yes, ac_cv_sys_multicast_support=no)])\nif test $ac_cv_sys_multicast_support = yes; then\n  AC_DEFINE(HAVE_MULTICAST_SUPPORT,[1],\n\t[Define if setsockopt() accepts multicast options])\nfi\n])dnl\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_SYS_ERRLIST\ndnl\ndnl Define SYS_ERRLIST_DECLARED if the variable sys_errlist is declared\ndnl in a system header file, stdio.h or errno.h.\ndnl\n\nAC_DEFUN(LM_DECL_SYS_ERRLIST,\n[AC_CACHE_CHECK([for sys_errlist declaration in stdio.h or errno.h],\n  ac_cv_decl_sys_errlist,\n[AC_TRY_COMPILE([#include <stdio.h>\n#include <errno.h>], [char *msg = *(sys_errlist + 1);],\n  ac_cv_decl_sys_errlist=yes, ac_cv_decl_sys_errlist=no)])\nif test $ac_cv_decl_sys_errlist = yes; then\n  AC_DEFINE(SYS_ERRLIST_DECLARED,[],\n\t[define if the variable sys_errlist is declared in a system header file])\nfi\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_CHECK_FUNC_DECL( funname, declaration [, extra includes \ndnl                     [, action-if-found [, action-if-not-found]]] )\ndnl\ndnl Checks if the declaration \"declaration\" of \"funname\" conflicts\ndnl with the header files idea of how the function should be\ndnl declared. It is useful on systems which lack prototypes and you\ndnl need to provide your own (e.g. when you want to take the address\ndnl of a function). The 4'th argument is expanded if conflicting, \ndnl the 5'th argument otherwise\ndnl\ndnl\n\nAC_DEFUN(LM_CHECK_FUNC_DECL,\n[AC_MSG_CHECKING([for conflicting declaration of $1])\nAC_CACHE_VAL(ac_cv_func_decl_$1,\n[AC_TRY_COMPILE([#include <stdio.h>\n$3],[$2\nchar *c = (char *)$1;\n], eval \"ac_cv_func_decl_$1=no\", eval \"ac_cv_func_decl_$1=yes\")])\nif eval \"test \\\"`echo '$ac_cv_func_decl_'$1`\\\" = yes\"; then\n  AC_MSG_RESULT(yes)\n  ifelse([$4], , :, [$4])\nelse\n  AC_MSG_RESULT(no)\nifelse([$5], , , [$5\n])dnl\nfi\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl AC_DOUBLE_MIDDLE_ENDIAN\ndnl\ndnl Checks whether doubles are represented in \"middle-endian\" format.\ndnl Sets ac_cv_double_middle_endian={no,yes,unknown} accordingly,\ndnl as well as DOUBLE_MIDDLE_ENDIAN.\ndnl\ndnl\n\nAC_DEFUN([AC_C_DOUBLE_MIDDLE_ENDIAN],\n[AC_CACHE_CHECK(whether double word ordering is middle-endian, ac_cv_c_double_middle_endian,\n[# It does not; compile a test program.\nAC_RUN_IFELSE(\n[AC_LANG_SOURCE([[#include <stdlib.h>\n\nint\nmain(void)\n{\n  int i = 0;\n  int zero = 0;\n  int bigendian;\n  int zero_index = 0;\n\n  union\n  {\n    long int l;\n    char c[sizeof (long int)];\n  } u;\n\n  /* we'll use the one with 32-bit words */\n  union\n  {\n    double d;\n    unsigned int c[2];\n  } vint;\n\n  union\n  {\n    double d;\n    unsigned long c[2];\n  } vlong;\n\n  union\n  {\n    double d;\n    unsigned short c[2];\n  } vshort;\n\n\n  /* Are we little or big endian?  From Harbison&Steele.  */\n  u.l = 1;\n  bigendian = (u.c[sizeof (long int) - 1] == 1);\n\n  zero_index = bigendian ? 1 : 0;\n\n  vint.d = 1.0;\n  vlong.d = 1.0;\n  vshort.d = 1.0;\n\n  if (sizeof(unsigned int) == 4)\n    {\n      if (vint.c[zero_index] != 0)\n\tzero = 1;\n    }\n  else if (sizeof(unsigned long) == 4)\n    {\n      if (vlong.c[zero_index] != 0)\n\tzero = 1;\n    }\n  else if (sizeof(unsigned short) == 4)\n    {\n      if (vshort.c[zero_index] != 0)\n\tzero = 1;\n    }\n\n  exit (zero);\n}\n]])],\n\t      [ac_cv_c_double_middle_endian=no],\n\t      [ac_cv_c_double_middle_endian=yes],\n\t      [ac_cv_c_double_middle=unknown])])\ncase $ac_cv_c_double_middle_endian in\n  yes)\n    m4_default([$1],\n      [AC_DEFINE([DOUBLE_MIDDLE_ENDIAN], 1,\n\t[Define to 1 if your processor stores the words in a double in\n\t middle-endian format (like some ARMs).])]) ;;\n  no)\n    $2 ;;\n  *)\n    m4_default([$3],\n      [AC_MSG_WARN([unknown double endianness\npresetting ac_cv_c_double_middle_endian=no (or yes) will help])]) ;;\nesac\n])# AC_C_DOUBLE_MIDDLE_ENDIAN\n\n\nAC_DEFUN(ERL_MONOTONIC_CLOCK,\n[\n  if test \"$3\" = \"yes\"; then\n     default_resolution_clock_gettime_monotonic=\"CLOCK_HIGHRES CLOCK_BOOTTIME CLOCK_MONOTONIC\"\n     low_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_COARSE CLOCK_MONOTONIC_FAST\"\n     high_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_PRECISE\"\n  else\n     default_resolution_clock_gettime_monotonic=\"CLOCK_HIGHRES CLOCK_UPTIME CLOCK_MONOTONIC\"\n     low_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_COARSE CLOCK_UPTIME_FAST\"\n     high_resolution_clock_gettime_monotonic=\"CLOCK_UPTIME_PRECISE\"\n  fi\n\n  case \"$1\" in\n    high_resolution)\n\tcheck_msg=\"high resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$high_resolution_clock_gettime_monotonic\"\n\t;;\n    low_resolution)\n\tcheck_msg=\"low resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$low_resolution_clock_gettime_monotonic\"\n\t;;\n    custom_resolution)\n\tcheck_msg=\"custom resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$2\"\n\t;;\n    *)\n\tcheck_msg=\"custom \"\n\tprefer_resolution_clock_gettime_monotonic=\"$2\"\n\t;;\n  esac\n\n  clock_gettime_lib=\"\"\n  AC_CHECK_LIB(rt, clock_gettime, [clock_gettime_lib=\"-lrt\"])\n\n  save_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $clock_gettime_lib\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     trust_test=\"#error May not be there due to weak linking\"\n  else\n     trust_test=\"\"\n  fi\n\n  AC_CACHE_CHECK([for clock_gettime(CLOCK_MONOTONIC_RAW, _)], erl_cv_clock_gettime_monotonic_raw,\n  [\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime(CLOCK_MONOTONIC_RAW, &ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_monotonic_raw=yes,\n\t\t      erl_cv_clock_gettime_monotonic_raw=no)\n  ])\n\n  AC_CACHE_CHECK([for clock_gettime() with ${check_msg}monotonic clock type], erl_cv_clock_gettime_monotonic_$1,\n  [\n     for clock_type in $prefer_resolution_clock_gettime_monotonic $default_resolution_clock_gettime_monotonic $high_resolution_clock_gettime_monotonic $low_resolution_clock_gettime_monotonic; do\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime($clock_type,&ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_monotonic_$1=$clock_type,\n\t\t      erl_cv_clock_gettime_monotonic_$1=no)\n       test $erl_cv_clock_gettime_monotonic_$1 = no || break\n     done\n  ])\n\n  LIBS=\"$save_LIBS\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     check_for_clock_getres=\n  else\n     check_for_clock_getres=clock_getres\n  fi\n\n  AC_CHECK_FUNCS([$check_for_clock_getres clock_get_attributes gethrtime])\n  \n  AC_CACHE_CHECK([for mach clock_get_time() with monotonic clock type], erl_cv_mach_clock_get_time_monotonic,\n  [\n     AC_TRY_COMPILE([\n#include <mach/clock.h>\n#include <mach/mach.h>\n\t\t\t],\n\t \t\t[\n    kern_return_t res;\n    clock_serv_t clk_srv;\n    mach_timespec_t time_spec;\n\n    host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &clk_srv);\n    res = clock_get_time(clk_srv, &time_spec);\n    mach_port_deallocate(mach_task_self(), clk_srv);\n    \t\t\t],\n    \t\t\terl_cv_mach_clock_get_time_monotonic=yes,\n\t\t\terl_cv_mach_clock_get_time_monotonic=no)\n  ])\n  \n  erl_corrected_monotonic_clock=no\n  case $erl_cv_clock_gettime_monotonic_$1-$ac_cv_func_gethrtime-$erl_cv_mach_clock_get_time_monotonic-$host_os in\n    *-*-*-win32)\n      erl_monotonic_clock_func=WindowsAPI\n      ;;\n    CLOCK_*-*-*-linux*)\n      case $erl_cv_clock_gettime_monotonic_$1-$erl_cv_clock_gettime_monotonic_raw in\n        CLOCK_BOOTTIME-yes|CLOCK_MONOTONIC-yes)\n\t  erl_corrected_monotonic_clock=yes\n\t  ;;\n\t*)\n\t  # We don't trust CLOCK_MONOTONIC to be NTP\n\t  # adjusted on linux systems that do not have\n\t  # CLOCK_MONOTONIC_RAW (although it seems to\n\t  # be...)\n\t  ;;\n      esac\n      erl_monotonic_clock_func=clock_gettime\n      ;;\n    no-no-no-linux*)\n      erl_monotonic_clock_func=times\n      ;;\n    CLOCK_*-*-*-*)\n      erl_monotonic_clock_func=clock_gettime\n      ;;\n    no-yes-*-*)\n      erl_monotonic_clock_func=gethrtime\n      ;;\n    no-no-yes-*)\n      erl_monotonic_clock_func=mach_clock_get_time\n      ;;\n    no-no-no-*)\n      erl_monotonic_clock_func=none\n      ;;\n  esac\n\n  erl_monotonic_clock_low_resolution=no\n  erl_monotonic_clock_lib=\n  erl_monotonic_clock_id=\n  case $erl_monotonic_clock_func in\n    clock_gettime)\n      erl_monotonic_clock_id=$erl_cv_clock_gettime_monotonic_$1\n      for low_res_id in $low_resolution_clock_gettime_monotonic; do\n      \t  if test $erl_monotonic_clock_id = $low_res_id; then\n\t    erl_monotonic_clock_low_resolution=yes\n\t    break\n\t  fi\n      done\n      erl_monotonic_clock_lib=$clock_gettime_lib\n      ;;\n    mach_clock_get_time)\n      erl_monotonic_clock_id=SYSTEM_CLOCK\n      ;;\n    times)\n      erl_monotonic_clock_low_resolution=yes\n      ;;\n    *)\n      ;;\n  esac\n \n])\n\nAC_DEFUN(ERL_WALL_CLOCK,\n[\n  default_resolution_clock_gettime_wall=\"CLOCK_REALTIME\"\n  low_resolution_clock_gettime_wall=\"CLOCK_REALTIME_COARSE CLOCK_REALTIME_FAST\"\n  high_resolution_clock_gettime_wall=\"CLOCK_REALTIME_PRECISE\"\n\n  case \"$1\" in\n    high_resolution)\n\tcheck_msg=\"high resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$high_resolution_clock_gettime_wall\"\n\t;;\n    low_resolution)\n\tcheck_msg=\"low resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$low_resolution_clock_gettime_wall\"\n\t;;\n    custom_resolution)\n\tcheck_msg=\"custom resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$2\"\n\t;;\n    *)\n\tcheck_msg=\"\"\n\tprefer_resolution_clock_gettime_wall=\n\t;;\n  esac\n\n  clock_gettime_lib=\"\"\n  AC_CHECK_LIB(rt, clock_gettime, [clock_gettime_lib=\"-lrt\"])\n\n  save_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $clock_gettime_lib\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     trust_test=\"#error May not be there due to weak linking\"\n  else\n     trust_test=\"\"\n  fi\n\n  AC_CACHE_CHECK([for clock_gettime() with ${check_msg}wall clock type], erl_cv_clock_gettime_wall_$1,\n  [\n     for clock_type in $prefer_resolution_clock_gettime_wall $default_resolution_clock_gettime_wall $high_resolution_clock_gettime_wall $low_resolution_clock_gettime_wall; do\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime($clock_type,&ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_wall_$1=$clock_type,\n\t\t      erl_cv_clock_gettime_wall_$1=no)\n       test $erl_cv_clock_gettime_wall_$1 = no || break\n     done\n  ])\n\n  LIBS=\"$save_LIBS\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     check_for_clock_getres=\n  else\n     check_for_clock_getres=clock_getres\n  fi\n\n  AC_CHECK_FUNCS([$check_for_clock_getres clock_get_attributes gettimeofday])\n  \n  AC_CACHE_CHECK([for mach clock_get_time() with wall clock type], erl_cv_mach_clock_get_time_wall,\n  [\n     AC_TRY_COMPILE([\n#include <mach/clock.h>\n#include <mach/mach.h>\n\t\t\t],\n\t \t\t[\n    kern_return_t res;\n    clock_serv_t clk_srv;\n    mach_timespec_t time_spec;\n\n    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &clk_srv);\n    res = clock_get_time(clk_srv, &time_spec);\n    mach_port_deallocate(mach_task_self(), clk_srv);\n    \t\t\t],\n    \t\t\terl_cv_mach_clock_get_time_wall=yes,\n\t\t\terl_cv_mach_clock_get_time_wall=no)\n  ])\n\n  erl_wall_clock_lib=\n  erl_wall_clock_low_resolution=no\n  erl_wall_clock_id=\n  case $1-$erl_cv_clock_gettime_wall_$1-$erl_cv_mach_clock_get_time_wall-$ac_cv_func_gettimeofday-$host_os in\n    *-*-*-*-win32)\n      erl_wall_clock_func=WindowsAPI\n      erl_wall_clock_low_resolution=yes\n      ;;\n    high_resolution-no-yes-*-*)\n      erl_wall_clock_func=mach_clock_get_time\n      erl_wall_clock_id=CALENDAR_CLOCK\n      ;;\n    *-CLOCK_*-*-*-*)\n      erl_wall_clock_func=clock_gettime\n      erl_wall_clock_lib=$clock_gettime_lib\n      erl_wall_clock_id=$erl_cv_clock_gettime_wall_$1\n      for low_res_id in $low_resolution_clock_gettime_wall; do\n      \t  if test $erl_wall_clock_id = $low_res_id; then\n\t    erl_wall_clock_low_resolution=yes\n\t    break\n\t  fi\n      done\n      ;;\n    *-no-*-yes-*)\n      erl_wall_clock_func=gettimeofday\n      ;;\n    *)\n      erl_wall_clock_func=none\n      ;;\n  esac\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_CHECK_THR_LIB\ndnl\ndnl This macro may be used by any OTP application.\ndnl\ndnl LM_CHECK_THR_LIB sets THR_LIBS, THR_DEFS, and THR_LIB_NAME. It also\ndnl checks for some pthread headers which will appear in DEFS or config.h.\ndnl\n\nAC_DEFUN(LM_CHECK_THR_LIB,\n[\n\nNEED_NPTL_PTHREAD_H=no\n\ndnl win32?\nAC_MSG_CHECKING([for native win32 threads])\nif test \"X$host_os\" = \"Xwin32\"; then\n    AC_MSG_RESULT(yes)\n    THR_DEFS=\"-DWIN32_THREADS\"\n    THR_LIBS=\n    THR_LIB_NAME=win32_threads\n    THR_LIB_TYPE=win32_threads\nelse\n    AC_MSG_RESULT(no)\n    THR_DEFS=\n    THR_LIBS=\n    THR_LIB_NAME=\n    THR_LIB_TYPE=posix_unknown\n\ndnl Try to find POSIX threads\n\ndnl The usual pthread lib...\n    AC_CHECK_LIB(pthread, pthread_create, THR_LIBS=\"-lpthread\")\n\ndnl Very old versions of FreeBSD have pthreads in special c library, c_r...\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_CHECK_LIB(c_r, pthread_create, THR_LIBS=\"-lc_r\")\n    fi\n\ndnl QNX has pthreads in standard C library\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_CHECK_FUNC(pthread_create, THR_LIBS=\"none_needed\")\n    fi\n\ndnl On ofs1 the '-pthread' switch should be used\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_MSG_CHECKING([if the '-pthread' switch can be used])\n\tsaved_cflags=$CFLAGS\n\tCFLAGS=\"$CFLAGS -pthread\"\n\tAC_TRY_LINK([#include <pthread.h>],\n\t\t    pthread_create((void*)0,(void*)0,(void*)0,(void*)0);,\n\t\t    [THR_DEFS=\"-pthread\"\n\t\t     THR_LIBS=\"-pthread\"])\n\tCFLAGS=$saved_cflags\n\tif test \"x$THR_LIBS\" != \"x\"; then\n\t    AC_MSG_RESULT(yes)\n\telse\n\t    AC_MSG_RESULT(no)\n\tfi\n    fi\n\n    if test \"x$THR_LIBS\" != \"x\"; then\n\tTHR_DEFS=\"$THR_DEFS -D_THREAD_SAFE -D_REENTRANT -DPOSIX_THREADS\"\n\tTHR_LIB_NAME=pthread\n\tif test \"x$THR_LIBS\" = \"xnone_needed\"; then\n\t    THR_LIBS=\n\tfi\n\tcase $host_os in\n\t    solaris*)\n\t\tTHR_DEFS=\"$THR_DEFS -D_POSIX_PTHREAD_SEMANTICS\" ;;\n\t    linux*)\n\t\tTHR_DEFS=\"$THR_DEFS -D_POSIX_THREAD_SAFE_FUNCTIONS\"\n\n\t\tLM_CHECK_GETCONF\n\t\tAC_MSG_CHECKING(for Native POSIX Thread Library)\n\t\tlibpthr_vsn=`$GETCONF GNU_LIBPTHREAD_VERSION 2>/dev/null`\n\t\tif test $? -eq 0; then\n\t\t    case \"$libpthr_vsn\" in\n\t\t\t*nptl*|*NPTL*) nptl=yes;;\n\t\t\t*) nptl=no;;\n\t\t    esac\n\t\telif test \"$cross_compiling\" = \"yes\"; then\n\t\t    case \"$erl_xcomp_linux_nptl\" in\n\t\t\t\"\") nptl=cross;;\n\t\t\tyes|no) nptl=$erl_xcomp_linux_nptl;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_nptl value: $erl_xcomp_linux_nptl]);;\n\t\t    esac\n\t\telse\n\t\t    nptl=no\n\t\tfi\n\t\tAC_MSG_RESULT($nptl)\n\t\tif test $nptl = cross; then\n\t\t    nptl=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $nptl = yes; then\n\t\t    THR_LIB_TYPE=posix_nptl\n\t\t    need_nptl_incldir=no\n\t\t    AC_CHECK_HEADER(nptl/pthread.h,\n\t\t\t\t    [need_nptl_incldir=yes\n\t\t\t\t     NEED_NPTL_PTHREAD_H=yes])\n\t\t    if test $need_nptl_incldir = yes; then\n\t\t\t# Ahh...\n\t\t\tnptl_path=\"$C_INCLUDE_PATH:$CPATH\"\n\t\t\tif test X$cross_compiling != Xyes; then\n\t\t\t    nptl_path=\"$nptl_path:/usr/local/include:/usr/include\"\n\t\t\telse\n\t\t\t    IROOT=\"$erl_xcomp_isysroot\"\n\t\t\t    test \"$IROOT\" != \"\" || IROOT=\"$erl_xcomp_sysroot\"\n\t\t\t    test \"$IROOT\" != \"\" || AC_MSG_ERROR([Don't know where to search for includes! Please set erl_xcomp_isysroot])\n\t\t\t    nptl_path=\"$nptl_path:$IROOT/usr/local/include:$IROOT/usr/include\"\n\t\t\tfi\n\t\t\tnptl_ws_path=\n\t\t\tsave_ifs=\"$IFS\"; IFS=\":\"\n\t\t\tfor dir in $nptl_path; do\n\t\t\t    if test \"x$dir\" != \"x\"; then\n\t\t\t\tnptl_ws_path=\"$nptl_ws_path $dir\"\n\t\t\t    fi\n\t\t\tdone\n\t\t\tIFS=$save_ifs\n\t\t\tnptl_incldir=\n\t\t\tfor dir in $nptl_ws_path; do\n\t\t            AC_CHECK_HEADER($dir/nptl/pthread.h,\n\t\t\t\t\t    nptl_incldir=$dir/nptl)\n\t\t\t    if test \"x$nptl_incldir\" != \"x\"; then\n\t\t\t\tTHR_DEFS=\"$THR_DEFS -isystem $nptl_incldir\"\n\t\t\t\tbreak\n\t\t\t    fi\n\t\t\tdone\n\t\t\tif test \"x$nptl_incldir\" = \"x\"; then\n\t\t\t    AC_MSG_ERROR(Failed to locate nptl system include directory)\n\t\t\tfi\n\t\t    fi\n\t\tfi\n\t\t;;\n\t    *) ;;\n\tesac\n\n\tdnl We sometimes need THR_DEFS in order to find certain headers\n\tdnl (at least for pthread.h on osf1).\n\tsaved_cppflags=$CPPFLAGS\n\tCPPFLAGS=\"$CPPFLAGS $THR_DEFS\"\n\n\tdnl\n\tdnl Check for headers\n\tdnl\n\n\tAC_CHECK_HEADER(pthread.h,\n\t\t\tAC_DEFINE(HAVE_PTHREAD_H, 1, \\\n[Define if you have the <pthread.h> header file.]))\n\n\tdnl Some Linuxes have <pthread/mit/pthread.h> instead of <pthread.h>\n\tAC_CHECK_HEADER(pthread/mit/pthread.h, \\\n\t\t\tAC_DEFINE(HAVE_MIT_PTHREAD_H, 1, \\\n[Define if the pthread.h header file is in pthread/mit directory.]))\n\n\tdnl restore CPPFLAGS\n\tCPPFLAGS=$saved_cppflags\n\n    fi\nfi\n\n])\n\nAC_DEFUN(ERL_INTERNAL_LIBS,\n[\n\nERTS_INTERNAL_X_LIBS=\n\nAC_CHECK_LIB(kstat, kstat_open,\n[AC_DEFINE(HAVE_KSTAT, 1, [Define if you have kstat])\nERTS_INTERNAL_X_LIBS=\"$ERTS_INTERNAL_X_LIBS -lkstat\"])\n\nAC_SUBST(ERTS_INTERNAL_X_LIBS)\n\n])\n\nAC_DEFUN(ETHR_CHK_GCC_ATOMIC_OP__,\n[\n    # $1 - atomic_op\n\n    for atomic_bit_size in 32 64 128; do\n\tcase $atomic_bit_size in\n\t    32) gcc_atomic_type=\"$gcc_atomic_type32\";;\n\t    64) gcc_atomic_type=\"$gcc_atomic_type64\";;\n\t    128) gcc_atomic_type=\"$gcc_atomic_type128\";;\n\tesac\n\tgcc_atomic_lockfree=\"int x[[(2*__atomic_always_lock_free(sizeof($gcc_atomic_type), 0))-1]]\"\n\tcase $1 in\n\t    __sync_add_and_fetch | __sync_fetch_and_and | __sync_fetch_and_or)\n\t\tatomic_call=\"volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0);\"\n\t\t;;\n\t    __sync_val_compare_and_swap)\n\t\tatomic_call=\"volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0, ($gcc_atomic_type) 0);\"\n\t\t;;\n\t    __atomic_store_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELAXED); $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELEASE);\"\n\t\t;;\n\t    __atomic_load_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, __ATOMIC_RELAXED); res = $1(&var, __ATOMIC_ACQUIRE);\"\n\t\t;;\n\t    __atomic_add_fetch| __atomic_fetch_and | __atomic_fetch_or)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELAXED); res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_ACQUIRE); res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELEASE);\"\n\t\t;;\n\t    __atomic_compare_exchange_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type val; int res = $1(&var, &val, ($gcc_atomic_type) 0, 0, __ATOMIC_RELAXED, __ATOMIC_RELAXED); res = $1(&var, &val, ($gcc_atomic_type) 0, 0, __ATOMIC_ACQUIRE, __ATOMIC_ACQUIRE);\"\n\t\t;;\n\t    *)\n\t\tAC_MSG_ERROR([Internal error: missing implementation for $1])\n\t\t;;\n\tesac\n\teval atomic${atomic_bit_size}_call=\\\"$atomic_call\\\"\n    done\n    \n    AC_CACHE_CHECK([for 32-bit $1()], ethr_cv_32bit_$1,\n\t\t   [\n\t\t       ethr_cv_32bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic32_call], [ethr_cv_32bit_$1=yes])\n\t\t   ])\n    AC_CACHE_CHECK([for 64-bit $1()], ethr_cv_64bit_$1,\n\t\t   [\n\t\t       ethr_cv_64bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic64_call], [ethr_cv_64bit_$1=yes])\n\t\t   ])\n    AC_CACHE_CHECK([for 128-bit $1()], ethr_cv_128bit_$1,\n\t\t   [\n\t\t       ethr_cv_128bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic128_call], [ethr_cv_128bit_$1=yes])\n\t\t   ])\n\n\tcase $ethr_cv_128bit_$1-$ethr_cv_64bit_$1-$ethr_cv_32bit_$1 in\n\t    no-no-no)\n\t\thave_atomic_ops=0;;\n\t    no-no-yes)\n\t\thave_atomic_ops=4;;\n\t    no-yes-no)\n\t\thave_atomic_ops=8;;\n\t    no-yes-yes)\n\t\thave_atomic_ops=12;;\n\t    yes-no-no)\n\t\thave_atomic_ops=16;;\n\t    yes-no-yes)\n\t\thave_atomic_ops=20;;\n\t    yes-yes-no)\n\t\thave_atomic_ops=24;;\n\t    yes-yes-yes)\n\t\thave_atomic_ops=28;;\n\tesac\n\tAC_DEFINE_UNQUOTED([ETHR_HAVE_$1], [$have_atomic_ops], [Define as a bitmask corresponding to the word sizes that $1() can handle on your system])\n])\n\nAC_DEFUN(ETHR_CHK_IF_NOOP,\n[\n   ethr_test_filename=\"chk_if_$1$3_noop_config1test.$$\"\n   cat > \"${ethr_test_filename}.c\" <<EOF\nint\nmy_test(void)\n{\n    $1$2;\n    return 0;\n}\nEOF\n   $CC -O3 $ETHR_DEFS -c \"${ethr_test_filename}.c\" -o \"${ethr_test_filename}1.o\"\n   cat > \"${ethr_test_filename}.c\" <<EOF\nint\nmy_test(void)\n{\n    ;\n    return 0;\n}\nEOF\n   $CC -O3 $ETHR_DEFS -c \"${ethr_test_filename}.c\" -o \"${ethr_test_filename}2.o\"\n   if diff \"${ethr_test_filename}1.o\" \"${ethr_test_filename}2.o\" >/dev/null 2>&1; then\n      ethr_$1$3_noop=yes\n   else\n      ethr_$1$3_noop=no\n   fi\n   rm -f \"${ethr_test_filename}.c\" \"${ethr_test_filename}1.o\"  \"${ethr_test_filename}2.o\" \n])\n\nAC_DEFUN(ETHR_CHK_GCC_ATOMIC_OPS,\n[\n    AC_CHECK_SIZEOF(short)\n    AC_CHECK_SIZEOF(int)\n    AC_CHECK_SIZEOF(long)\n    AC_CHECK_SIZEOF(long long)\n    AC_CHECK_SIZEOF(__int128_t)\n\n    if test \"$ac_cv_sizeof_short\" = \"4\"; then\n\tgcc_atomic_type32=\"short\"\n    elif test \"$ac_cv_sizeof_int\" = \"4\"; then\n\tgcc_atomic_type32=\"int\"\n    elif test \"$ac_cv_sizeof_long\" = \"4\"; then\n\tgcc_atomic_type32=\"long\"\n    else\n\tAC_MSG_ERROR([No 32-bit type found])\n    fi\n\n    if test \"$ac_cv_sizeof_int\" = \"8\"; then\n\tgcc_atomic_type64=\"int\"\n    elif test \"$ac_cv_sizeof_long\" = \"8\"; then\n\tgcc_atomic_type64=\"long\"\n    elif test \"$ac_cv_sizeof_long_long\" = \"8\"; then\n\tgcc_atomic_type64=\"long long\"\n    else\n\tAC_MSG_ERROR([No 64-bit type found])\n    fi\n\n    if test \"$ac_cv_sizeof___int128_t\" = \"16\"; then\n\tgcc_atomic_type128=\"__int128_t\"\n    else\n\tgcc_atomic_type128=\"#error \"\t\n    fi\n    AC_CACHE_CHECK([for a working __sync_synchronize()], ethr_cv___sync_synchronize,\n\t\t   [\n\t\t       ethr_cv___sync_synchronize=no\n\t\t       AC_TRY_LINK([],\n\t\t\t\t   [ __sync_synchronize(); ],\n\t\t\t\t   [ethr_cv___sync_synchronize=yes])\n\t\t       if test $ethr_cv___sync_synchronize = yes; then\n\t\t\t   #\n\t\t\t   # Old gcc versions on at least x86 have a buggy\n\t\t\t   # __sync_synchronize() which does not emit a\n\t\t\t   # memory barrier. We try to detect this by\n\t\t\t   # compiling to assembly with and without\n\t\t\t   # __sync_synchronize() and compare the results.\n\t\t\t   #\n\t\t\t   ETHR_CHK_IF_NOOP(__sync_synchronize, [()], [])\n\t\t\t   if test $ethr___sync_synchronize_noop = yes; then\n\t\t\t      # Got a buggy implementation of\n\t\t\t      # __sync_synchronize...\n\t\t\t      ethr_cv___sync_synchronize=\"no; buggy implementation\"\n\t\t\t   fi\n\t\t       fi\n\t\t   ])\n\n    if test \"$ethr_cv___sync_synchronize\" = \"yes\"; then\n\thave_sync_synchronize_value=\"~0\"\n    else\n\thave_sync_synchronize_value=\"0\"\n    fi\n    AC_DEFINE_UNQUOTED([ETHR_HAVE___sync_synchronize], [$have_sync_synchronize_value], [Define as a bitmask corresponding to the word sizes that __sync_synchronize() can handle on your system])\n\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_add_and_fetch)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_fetch_and_and)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_fetch_and_or)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_val_compare_and_swap)\n\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_store_n)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_load_n)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_add_fetch)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_fetch_and)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_fetch_or)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_compare_exchange_n)\n\n    ethr_have_gcc_native_atomics=no\n    ethr_arm_dbm_instr_val=0\n    case \"$GCC-$host_cpu\" in\n\tyes-arm*)\n\t    AC_CACHE_CHECK([for ARM DMB instruction], ethr_cv_arm_dbm_instr,\n\t\t\t   [\n\t\t\t\tethr_cv_arm_dbm_instr=no\n\t\t\t\tAC_TRY_LINK([],\n\t\t\t\t\t    [\n\t\t\t\t\t\t__asm__ __volatile__(\"dmb sy\" : : : \"memory\");\n\t\t\t\t\t\t__asm__ __volatile__(\"dmb st\" : : : \"memory\");\n\t\t\t\t\t    ],\n\t\t\t\t\t    [ethr_cv_arm_dbm_instr=yes])\n\t\t\t   ])\n\t    if test $ethr_cv_arm_dbm_instr = yes; then\n\t\tethr_arm_dbm_instr_val=1\n\t\ttest $ethr_cv_64bit___atomic_compare_exchange_n = yes &&\n\t\t    ethr_have_gcc_native_atomics=yes\n\t    fi;;\n\t*)\n\t    ;;\n    esac\n    AC_DEFINE_UNQUOTED([ETHR_HAVE_GCC_ASM_ARM_DMB_INSTRUCTION], [$ethr_arm_dbm_instr_val], [Define as a boolean indicating whether you have a gcc compatible compiler capable of generating the ARM DMB instruction, and are compiling for an ARM processor with ARM DMB instruction support, or not])\n    test $ethr_cv_32bit___sync_val_compare_and_swap = yes &&\n    \tethr_have_gcc_native_atomics=yes\n    test $ethr_cv_64bit___sync_val_compare_and_swap = yes &&\n    \tethr_have_gcc_native_atomics=yes\n    if test \"$ethr_cv___sync_synchronize\" = \"yes\"; then\n    \ttest $ethr_cv_64bit___atomic_compare_exchange_n = yes &&\n    \t    ethr_have_gcc_native_atomics=yes\n    \ttest $ethr_cv_32bit___atomic_compare_exchange_n = yes &&\n    \t    ethr_have_gcc_native_atomics=yes\n    fi\n    ethr_have_gcc_atomic_builtins=0\n    if test $ethr_have_gcc_native_atomics = yes; then\n       ethr_native_atomic_implementation=gcc_sync\n       test $ethr_cv_32bit___atomic_compare_exchange_n = yes && ethr_have_gcc_atomic_builtins=1\n       test $ethr_cv_64bit___atomic_compare_exchange_n = yes && ethr_have_gcc_atomic_builtins=1\n       test $ethr_have_gcc_atomic_builtins = 1 && ethr_native_atomic_implementation=gcc_atomic_sync\n    fi\n    AC_DEFINE_UNQUOTED([ETHR_HAVE_GCC___ATOMIC_BUILTINS], [$ethr_have_gcc_atomic_builtins], [Define as a boolean indicating whether you have a gcc __atomic builtins or not])\n    test $ethr_have_gcc_native_atomics = yes && ethr_have_native_atomics=yes\n])\n\nAC_DEFUN(ETHR_CHK_INTERLOCKED,\n[\n    ilckd=\"$1\"\n    AC_MSG_CHECKING([for ${ilckd}()])\n    case \"$2\" in\n\t\"1\") ilckd_call=\"${ilckd}(var);\";;\n\t\"2\") ilckd_call=\"${ilckd}(var, ($3) 0);\";;\n\t\"3\") ilckd_call=\"${ilckd}(var, ($3) 0, ($3) 0);\";;\n\t\"4\") ilckd_call=\"${ilckd}(var, ($3) 0, ($3) 0, arr);\";;\n    esac\n    have_interlocked_op=no\n    AC_TRY_LINK(\n\t[\n\t#define WIN32_LEAN_AND_MEAN\n\t#include <windows.h>\n\t#include <intrin.h>\n\t],\n\t[\n\t    volatile $3 *var;\n\t    volatile $3 arr[2];\n\n\t    $ilckd_call\n\t    return 0;\n\t],\n\t[have_interlocked_op=yes])\n    test $have_interlocked_op = yes && $4\n    AC_MSG_RESULT([$have_interlocked_op])\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl ERL_FIND_ETHR_LIB\ndnl\ndnl NOTE! This macro may be changed at any time! Should *only* be used by\ndnl       ERTS!\ndnl\ndnl Find a thread library to use. Sets ETHR_LIBS to libraries to link\ndnl with, ETHR_X_LIBS to extra libraries to link with (same as ETHR_LIBS\ndnl except that the ethread lib itself is not included), ETHR_DEFS to\ndnl defines to compile with, ETHR_THR_LIB_BASE to the name of the\ndnl thread library which the ethread library is based on, and ETHR_LIB_NAME\ndnl to the name of the library where the ethread implementation is located.\ndnl  ERL_FIND_ETHR_LIB currently searches for 'pthreads', and\ndnl 'win32_threads'. If no thread library was found ETHR_LIBS, ETHR_X_LIBS,\ndnl ETHR_DEFS, ETHR_THR_LIB_BASE, and ETHR_LIB_NAME are all set to the\ndnl empty string.\ndnl\n\nAC_DEFUN(ERL_FIND_ETHR_LIB,\n[\n\nAC_ARG_ENABLE(native-ethr-impls,\n\t      AS_HELP_STRING([--disable-native-ethr-impls],\n                             [disable native ethread implementations]),\n[ case \"$enableval\" in\n    no) disable_native_ethr_impls=yes ;;\n    *)  disable_native_ethr_impls=no ;;\n  esac ], disable_native_ethr_impls=no)\n\ntest \"X$disable_native_ethr_impls\" = \"Xyes\" &&\n  AC_DEFINE(ETHR_DISABLE_NATIVE_IMPLS, 1, [Define if you want to disable native ethread implementations])\n\nAC_ARG_ENABLE(x86-out-of-order,\n\t      AS_HELP_STRING([--enable-x86-out-of-order],\n                             [enable x86/x84_64 out of order support (default disabled)]))\n\nAC_ARG_ENABLE(prefer-gcc-native-ethr-impls,\n\t      AS_HELP_STRING([--enable-prefer-gcc-native-ethr-impls],\n\t\t\t     [prefer gcc native ethread implementations]),\n[ case \"$enableval\" in\n    yes) enable_prefer_gcc_native_ethr_impls=yes ;;\n    *)  enable_prefer_gcc_native_ethr_impls=no ;;\n  esac ], enable_prefer_gcc_native_ethr_impls=no)\n\ntest $enable_prefer_gcc_native_ethr_impls = yes &&\n  AC_DEFINE(ETHR_PREFER_GCC_NATIVE_IMPLS, 1, [Define if you prefer gcc native ethread implementations])\n\nAC_ARG_ENABLE(trust-gcc-atomic-builtins-memory-barriers,\n\t      AS_HELP_STRING([--enable-trust-gcc-atomic-builtins-memory-barriers],\n\t\t\t     [trust gcc atomic builtins memory barriers]),\n[ case \"$enableval\" in\n    yes) trust_gcc_atomic_builtins_mbs=1 ;;\n    *) trust_gcc_atomic_builtins_mbs=0 ;;\n  esac ], trust_gcc_atomic_builtins_mbs=0)\n\nAC_DEFINE_UNQUOTED(ETHR_TRUST_GCC_ATOMIC_BUILTINS_MEMORY_BARRIERS, [$trust_gcc_atomic_builtins_mbs], [Define as a boolean indicating whether you trust gcc's __atomic_* builtins memory barrier implementations, or not])\n\nAC_ARG_WITH(libatomic_ops,\n\t    AS_HELP_STRING([--with-libatomic_ops=PATH],\n\t\t\t   [specify and prefer usage of libatomic_ops in the ethread library]))\n\nAC_ARG_WITH(with_sparc_memory_order,\n\t    AS_HELP_STRING([--with-sparc-memory-order=TSO|PSO|RMO],\n\t\t\t   [specify sparc memory order (defaults to RMO)]))\n\nLM_CHECK_THR_LIB\nERL_INTERNAL_LIBS\n\nERL_MONOTONIC_CLOCK(try_find_pthread_compatible, CLOCK_HIGHRES CLOCK_MONOTONIC, no)\n\ncase $erl_monotonic_clock_func in\n  clock_gettime)\n    AC_DEFINE(ETHR_HAVE_CLOCK_GETTIME_MONOTONIC, [1], [Define if you have a clock_gettime() with a monotonic clock])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(ETHR_HAVE_MACH_CLOCK_GET_TIME, [1], [Define if you have a mach clock_get_time() with a monotonic clock])\n    ;;\n  gethrtime)\n    AC_DEFINE(ETHR_HAVE_GETHRTIME, [1], [Define if you have a monotonic gethrtime()])\n    ;;\n  *)\n    ;;\nesac\n\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(ETHR_MONOTONIC_CLOCK_ID, [$erl_monotonic_clock_id], [Define to the monotonic clock id to use])\nfi\n\nethr_native_atomic_implementation=none\nethr_have_native_atomics=no\nethr_have_native_spinlock=no\nETHR_THR_LIB_BASE=\"$THR_LIB_NAME\"\nETHR_THR_LIB_BASE_TYPE=\"$THR_LIB_TYPE\"\nETHR_DEFS=\"$THR_DEFS\"\nETHR_X_LIBS=\"$THR_LIBS $ERTS_INTERNAL_X_LIBS $erl_monotonic_clock_lib\"\nETHR_LIBS=\nETHR_LIB_NAME=\n\nethr_modified_default_stack_size=\n\nAC_ARG_WITH(threadnames,\nAS_HELP_STRING([--with-threadnames], [use pthread_setname to set the thread names (default)])\nAS_HELP_STRING([--without-threadnames],\n               [do not set any thread names]),\n[],\n[with_threadnames=yes])\n\ndnl Name of lib where ethread implementation is located\nethr_lib_name=ethread\n\ncase \"$THR_LIB_NAME\" in\n\n    win32_threads)\n\tETHR_THR_LIB_BASE_DIR=win\n\t# * _WIN32_WINNT >= 0x0400 is needed for\n\t#   TryEnterCriticalSection\n\t# * _WIN32_WINNT >= 0x0403 is needed for\n\t#   InitializeCriticalSectionAndSpinCount\n\t# The ethread lib will refuse to build if _WIN32_WINNT < 0x0403.\n\t#\n\t# -D_WIN32_WINNT should have been defined in $CPPFLAGS; fetch it\n\t# and save it in ETHR_DEFS.\n\tfound_win32_winnt=no\n\tfor cppflag in $CPPFLAGS; do\n\t    case $cppflag in\n\t\t-DWINVER*)\n\t\t    ETHR_DEFS=\"$ETHR_DEFS $cppflag\"\n\t\t    ;;\n\t\t-D_WIN32_WINNT*)\n\t\t    ETHR_DEFS=\"$ETHR_DEFS $cppflag\"\n\t\t    found_win32_winnt=yes\n\t\t    ;;\n\t\t*)\n\t\t    ;;\n\t    esac\n        done\n        if test $found_win32_winnt = no; then\n\t    AC_MSG_ERROR([-D_WIN32_WINNT missing in CPPFLAGS])\n        fi\n\n\tAC_DEFINE(ETHR_WIN32_THREADS, 1, [Define if you have win32 threads])\n\n\tif test \"X$disable_native_ethr_impls\" = \"Xyes\"; then\n\t    have_interlocked_op=no\n\t    ethr_have_native_atomics=no\n\telse\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT, 1, [Define if you have _InterlockedDecrement()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement_rel], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT_REL, 1, [Define if you have _InterlockedDecrement_rel()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT, 1, [Define if you have _InterlockedIncrement()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement_acq], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT_ACQ, 1, [Define if you have _InterlockedIncrement_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD, 1, [Define if you have _InterlockedExchangeAdd()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd_acq], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD_ACQ, 1, [Define if you have _InterlockedExchangeAdd_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedAnd], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDAND, 1, [Define if you have _InterlockedAnd()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedOr], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDOR, 1, [Define if you have _InterlockedOr()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchange], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGE, 1, [Define if you have _InterlockedExchange()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE, 1, [Define if you have _InterlockedCompareExchange()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange_acq], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE_ACQ, 1, [Define if you have _InterlockedCompareExchange_acq()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange_rel], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE_REL, 1, [Define if you have _InterlockedCompareExchange_rel()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement64], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT64, 1, [Define if you have _InterlockedDecrement64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement64_rel], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT64_REL, 1, [Define if you have _InterlockedDecrement64_rel()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement64], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT64, 1, [Define if you have _InterlockedIncrement64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement64_acq], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT64_ACQ, 1, [Define if you have _InterlockedIncrement64_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD64, 1, [Define if you have _InterlockedExchangeAdd64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd64_acq], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD64_ACQ, 1, [Define if you have _InterlockedExchangeAdd64_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedAnd64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDAND64, 1, [Define if you have _InterlockedAnd64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedOr64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDOR64, 1, [Define if you have _InterlockedOr64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchange64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGE64, 1, [Define if you have _InterlockedExchange64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64, 1, [Define if you have _InterlockedCompareExchange64()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64_acq], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64_ACQ, 1, [Define if you have _InterlockedCompareExchange64_acq()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64_rel], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64_REL, 1, [Define if you have _InterlockedCompareExchange64_rel()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange128], [4], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE128, 1, [Define if you have _InterlockedCompareExchange128()]))\n\tfi\n\tif test \"$ethr_have_native_atomics\" = \"yes\"; then\n\t   ethr_native_atomic_implementation=windows\n\t   ethr_have_native_spinlock=yes\n\tfi\n\t;;\n\n    pthread)\n\tETHR_THR_LIB_BASE_DIR=pthread\n\tAC_DEFINE(ETHR_PTHREADS, 1, [Define if you have pthreads])\n\tcase $host_os in\n\t    openbsd*)\n\t\t# The default stack size is insufficient for our needs\n\t\t# on OpenBSD. We increase it to 256 kilo words.\n\t\tethr_modified_default_stack_size=256;;\n\t    linux*)\n\t\tETHR_DEFS=\"$ETHR_DEFS -D_GNU_SOURCE\"\n\n\t\tif test\tX$cross_compiling = Xyes; then\n\t\t    case X$erl_xcomp_linux_usable_sigusrx in\n\t\t\tX) usable_sigusrx=cross;;\n\t\t\tXyes|Xno) usable_sigusrx=$erl_xcomp_linux_usable_sigusrx;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_usable_sigusrx value: $erl_xcomp_linux_usable_sigusrx]);;\n\t\t    esac\n\t\t    case X$erl_xcomp_linux_usable_sigaltstack in\n\t\t\tX) usable_sigaltstack=cross;;\n\t\t\tXyes|Xno) usable_sigaltstack=$erl_xcomp_linux_usable_sigaltstack;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_usable_sigaltstack value: $erl_xcomp_linux_usable_sigaltstack]);;\n\t\t    esac\n\t\telse\n\t\t    # FIXME: Test for actual problems instead of kernel versions\n\t\t    linux_kernel_vsn_=`uname -r`\n\t\t    case $linux_kernel_vsn_ in\n\t\t\t[[0-1]].*|2.[[0-1]]|2.[[0-1]].*)\n\t\t\t    usable_sigusrx=no\n\t\t\t    usable_sigaltstack=no;;\n\t\t\t2.[[2-3]]|2.[[2-3]].*)\n\t\t\t    usable_sigusrx=yes\n\t\t\t    usable_sigaltstack=no;;\n\t\t    \t*)\n\t\t\t    usable_sigusrx=yes\n\t\t\t    usable_sigaltstack=yes;;\n\t\t    esac\n\t\tfi\n\n\t\tAC_MSG_CHECKING(if SIGUSR1 and SIGUSR2 can be used)\n\t\tAC_MSG_RESULT($usable_sigusrx)\n\t\tif test $usable_sigusrx = cross; then\n\t\t    usable_sigusrx=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $usable_sigusrx = no; then\n\t\t    ETHR_DEFS=\"$ETHR_DEFS -DETHR_UNUSABLE_SIGUSRX\"\n\t\tfi\n\n\t\tAC_MSG_CHECKING(if sigaltstack can be used)\n\t\tAC_MSG_RESULT($usable_sigaltstack)\n\t\tif test $usable_sigaltstack = cross; then\n\t\t    usable_sigaltstack=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $usable_sigaltstack = no; then\n\t\t    ETHR_DEFS=\"$ETHR_DEFS -DETHR_UNUSABLE_SIGALTSTACK\"\n\t\tfi\n\t\t;;\n\t    *) ;;\n\tesac\n\n\tdnl We sometimes need ETHR_DEFS in order to find certain headers\n\tdnl (at least for pthread.h on osf1).\n\tsaved_cppflags=\"$CPPFLAGS\"\n\tCPPFLAGS=\"$CPPFLAGS $ETHR_DEFS\"\n\n\tdnl We need the thread library in order to find some functions\n\tsaved_libs=\"$LIBS\"\n\tLIBS=\"$LIBS $ETHR_X_LIBS\"\n\n\tdnl\n\tdnl Check for headers\n\tdnl\n\tAC_CHECK_HEADER(pthread.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_H, 1, \\\n[Define if you have the <pthread.h> header file.]))\n\n\tdnl Some Linuxes have <pthread/mit/pthread.h> instead of <pthread.h>\n\tAC_CHECK_HEADER(pthread/mit/pthread.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_MIT_PTHREAD_H, 1, \\\n[Define if the pthread.h header file is in pthread/mit directory.]))\n\n\tif test $NEED_NPTL_PTHREAD_H = yes; then\n\t    AC_DEFINE(ETHR_NEED_NPTL_PTHREAD_H, 1, \\\n[Define if you need the <nptl/pthread.h> header file.])\n\tfi\n\n\tAC_CHECK_HEADER(sched.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_SCHED_H, 1, \\\n[Define if you have the <sched.h> header file.]))\n\n\tAC_CHECK_HEADER(sys/time.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_SYS_TIME_H, 1, \\\n[Define if you have the <sys/time.h> header file.]))\n\n\tAC_TRY_COMPILE([#include <time.h>\n\t\t\t#include <sys/time.h>], \n\t\t\t[struct timeval *tv; return 0;],\n\t\t\tAC_DEFINE(ETHR_TIME_WITH_SYS_TIME, 1, \\\n[Define if you can safely include both <sys/time.h> and <time.h>.]))\n\n\tAC_MSG_CHECKING([for usable PTHREAD_STACK_MIN])\n\tpthread_stack_min=no\n\tAC_TRY_COMPILE([\n#include <limits.h>\n#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n#include <nptl/pthread.h>\n#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n#include <pthread/mit/pthread.h>\n#elif defined(ETHR_HAVE_PTHREAD_H)\n#include <pthread.h>\n#endif\n\t\t\t], \n\t\t\t[return PTHREAD_STACK_MIN;],\n\t\t\t[pthread_stack_min=yes])\n\n\tAC_MSG_RESULT([$pthread_stack_min])\n\ttest $pthread_stack_min != yes || {\n\t     AC_DEFINE(ETHR_HAVE_USABLE_PTHREAD_STACK_MIN, 1, [Define if you can use PTHREAD_STACK_MIN])\n\t}\n\n\tdnl\n\tdnl Check for functions\n\tdnl\n\tAC_CHECK_FUNC(pthread_spin_lock, \\\n\t\t\t[ethr_have_native_spinlock=yes \\\n\t\t\t AC_DEFINE(ETHR_HAVE_PTHREAD_SPIN_LOCK, 1, \\\n[Define if you have the pthread_spin_lock function.])])\n\n\thave_sched_yield=no\n\thave_librt_sched_yield=no\n\tAC_CHECK_FUNC(sched_yield, [have_sched_yield=yes])\n\tif test $have_sched_yield = no; then\n\t    AC_CHECK_LIB(rt, sched_yield,\n\t\t\t [have_librt_sched_yield=yes\n\t\t\t  ETHR_X_LIBS=\"$ETHR_X_LIBS -lrt\"])\n\tfi\n\tif test $have_sched_yield = yes || test $have_librt_sched_yield = yes; then\n\t    AC_DEFINE(ETHR_HAVE_SCHED_YIELD, 1, [Define if you have the sched_yield() function.])\n\t    AC_MSG_CHECKING([whether sched_yield() returns an int])\n\t    sched_yield_ret_int=no\n\t    AC_TRY_LINK([\n\t\t\t\t#ifdef ETHR_HAVE_SCHED_H\n\t\t\t\t#include <sched.h>\n\t\t\t\t#endif\n\t\t\t   ],\n\t\t\t   [int sched_yield();],\n\t\t\t   [sched_yield_ret_int=yes])\n\t    AC_MSG_RESULT([$sched_yield_ret_int])\n\t    if test $sched_yield_ret_int = yes; then\n\t\tAC_DEFINE(ETHR_SCHED_YIELD_RET_INT, 1, [Define if sched_yield() returns an int.])\n\t    fi\n\tfi\n\n\thave_pthread_yield=no\n\tAC_CHECK_FUNC(pthread_yield, [have_pthread_yield=yes])\n\tif test $have_pthread_yield = yes; then\n\t    AC_DEFINE(ETHR_HAVE_PTHREAD_YIELD, 1, [Define if you have the pthread_yield() function.])\n\t    AC_MSG_CHECKING([whether pthread_yield() returns an int])\n\t    pthread_yield_ret_int=no\n\t    AC_TRY_LINK([\n\t\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t\t#include <nptl/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t\t#include <pthread/mit/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t\t#include <pthread.h>\n\t\t\t\t#endif\n\t\t\t   ],\n\t\t\t   [int pthread_yield();],\n\t\t\t   [pthread_yield_ret_int=yes])\n\t    AC_MSG_RESULT([$pthread_yield_ret_int])\n\t    if test $pthread_yield_ret_int = yes; then\n\t\tAC_DEFINE(ETHR_PTHREAD_YIELD_RET_INT, 1, [Define if pthread_yield() returns an int.])\n\t    fi\n\tfi\n\n\thave_pthread_rwlock_init=no\n\tAC_CHECK_FUNC(pthread_rwlock_init, [have_pthread_rwlock_init=yes])\n\tif test $have_pthread_rwlock_init = yes; then\n\n\t    ethr_have_pthread_rwlockattr_setkind_np=no\n\t    AC_CHECK_FUNC(pthread_rwlockattr_setkind_np,\n\t\t\t  [ethr_have_pthread_rwlockattr_setkind_np=yes])\n\n\t    if test $ethr_have_pthread_rwlockattr_setkind_np = yes; then\n\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_RWLOCKATTR_SETKIND_NP, 1, \\\n[Define if you have the pthread_rwlockattr_setkind_np() function.])\n\n\t\tAC_MSG_CHECKING([for PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP])\n\t\tethr_pthread_rwlock_writer_nonrecursive_initializer_np=no\n\t\tAC_TRY_LINK([\n\t\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t\t#include <nptl/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t\t#include <pthread/mit/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t\t#include <pthread.h>\n\t\t\t\t#endif\n\t\t\t    ],\n\t\t\t    [\n\t\t\t\tpthread_rwlockattr_t *attr;\n\t\t\t\treturn pthread_rwlockattr_setkind_np(attr,\n\t\t\t\t    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n\t\t\t    ],\n\t\t\t    [ethr_pthread_rwlock_writer_nonrecursive_initializer_np=yes])\n\t\tAC_MSG_RESULT([$ethr_pthread_rwlock_writer_nonrecursive_initializer_np])\n\t\tif test $ethr_pthread_rwlock_writer_nonrecursive_initializer_np = yes; then\n\t\t    AC_DEFINE(ETHR_HAVE_PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, 1, \\\n[Define if you have the PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP rwlock attribute.])\n\t\tfi\n\t    fi\n\tfi\n\n\tif test \"$force_pthread_rwlocks\" = \"yes\"; then\n\n\t    AC_DEFINE(ETHR_FORCE_PTHREAD_RWLOCK, 1, \\\n[Define if you want to force usage of pthread rwlocks])\n\n\t    if test $have_pthread_rwlock_init = yes; then\n\t\tAC_MSG_WARN([Forced usage of pthread rwlocks. Note that this implementation may suffer from starvation issues.])\n\t    else\n\t\tAC_MSG_ERROR([User forced usage of pthread rwlock, but no such implementation was found])\n\t    fi\n\tfi\n\n\tAC_CHECK_FUNC(pthread_attr_setguardsize, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_ATTR_SETGUARDSIZE, 1, \\\n[Define if you have the pthread_attr_setguardsize function.]))\n\n\tif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n\t  AC_MSG_CHECKING(whether pthread_cond_timedwait() can use the monotonic clock $erl_monotonic_clock_id for timeout)\n\t  pthread_cond_timedwait_monotonic=no\n\t  AC_TRY_LINK([\n\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t#  include <nptl/pthread.h>\n\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t#  include <pthread/mit/pthread.h>\n\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t#  include <pthread.h>\n\t\t\t#endif\n\t\t\t#ifdef ETHR_TIME_WITH_SYS_TIME\n\t\t\t#  include <time.h>\n\t\t\t#  include <sys/time.h>\n\t\t\t#else\n\t\t\t#  ifdef ETHR_HAVE_SYS_TIME_H\n\t\t\t#    include <sys/time.h>\n\t\t\t#  else\n\t\t\t#    include <time.h>\n\t\t\t#  endif\n\t\t\t#endif\n\t\t\t#if defined(ETHR_HAVE_MACH_CLOCK_GET_TIME)\n\t\t\t#  include <mach/clock.h>\n\t\t\t#  include <mach/mach.h>\n\t\t\t#endif\n\t\t\t], \n\t\t\t[\n\t\t\tint res;\n\t\t\tpthread_condattr_t attr;\n\t\t\tpthread_cond_t cond;\n\t\t\tstruct timespec cond_timeout;\n\t\t\tpthread_mutex_t mutex;\n\t\t\tres = pthread_condattr_init(&attr);\n\t\t\tres = pthread_condattr_setclock(&attr, ETHR_MONOTONIC_CLOCK_ID);\n\t\t\tres = pthread_cond_init(&cond, &attr);\n\t\t\tres = pthread_cond_timedwait(&cond, &mutex, &cond_timeout);\n\t\t\t],\n\t\t\t[pthread_cond_timedwait_monotonic=yes])\n\t  AC_MSG_RESULT([$pthread_cond_timedwait_monotonic])\n\t  if test $pthread_cond_timedwait_monotonic = yes; then\n\t    AC_DEFINE(ETHR_HAVE_PTHREAD_COND_TIMEDWAIT_MONOTONIC, [1], [Define if pthread_cond_timedwait() can be used with a monotonic clock])\n\t  fi\n\tfi\n\n\tlinux_futex=no\n\tAC_MSG_CHECKING([for Linux futexes])\n\tAC_TRY_LINK([\n\t\t\t#include <sys/syscall.h>\n\t\t\t#include <unistd.h>\n\t\t\t#include <linux/futex.h>\n\t\t\t#include <sys/time.h>\n\t\t    ],\n\t\t    [\n\t\t\tint i = 1;\n\t\t\tsyscall(__NR_futex, (void *) &i, FUTEX_WAKE, 1,\n\t\t\t\t(void*)0,(void*)0, 0);\n\t\t\tsyscall(__NR_futex, (void *) &i, FUTEX_WAIT, 0,\n\t\t\t\t(void*)0,(void*)0, 0);\n\t\t\treturn 0;\n\t\t    ],\n\t\t    linux_futex=yes)\n\tAC_MSG_RESULT([$linux_futex])\n\ttest $linux_futex = yes && AC_DEFINE(ETHR_HAVE_LINUX_FUTEX, 1, [Define if you have a linux futex implementation.])\n\n\tpthread_setname=no\n\tAC_MSG_CHECKING([for pthread_setname_np])\n\told_CFLAGS=$CFLAGS\n\tCFLAGS=\"$CFLAGS -Werror\"\n\tAC_TRY_LINK([#define __USE_GNU\n                     #include <pthread.h>],\n                    [pthread_setname_np(pthread_self(), \"name\");],\n                    pthread_setname=linux)\n\tAC_TRY_LINK([#define __USE_GNU\n                     #include <pthread.h>],\n                    [pthread_set_name_np(pthread_self(), \"name\");],\n                    pthread_setname=bsd)\n\tAC_TRY_LINK([#define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [pthread_setname_np(\"name\");],\n                    pthread_setname=darwin)\n        AC_MSG_RESULT([$pthread_setname])\n        case $with_threadnames-$pthread_setname in\n             yes-linux) AC_DEFINE(ETHR_HAVE_PTHREAD_SETNAME_NP_2, 1,\n                          [Define if you have linux style pthread_setname_np]);;\n             yes-bsd) AC_DEFINE(ETHR_HAVE_PTHREAD_SET_NAME_NP_2, 1,\n                          [Define if you have bsd style pthread_set_name_np]);;\n             yes-darwin) AC_DEFINE(ETHR_HAVE_PTHREAD_SETNAME_NP_1, 1,\n                          [Define if you have darwin style pthread_setname_np]);;\n             *) ;;\n\tesac\n\n\tpthread_getname=no\n\tAC_MSG_CHECKING([for pthread_getname_np])\n\tAC_TRY_LINK([#define __USE_GNU\n                     #define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [char buff[256]; pthread_getname_np(pthread_self(), buff, 256);],\n                    pthread_getname=linux)\n\tAC_TRY_LINK([#define __USE_GNU\n                     #define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [char buff[256]; pthread_getname_np(pthread_self(), buff);],\n                    pthread_getname=ibm)\n        AC_MSG_RESULT([$pthread_getname])\n        case $pthread_getname in\n             linux) AC_DEFINE(ETHR_HAVE_PTHREAD_GETNAME_NP_3, 1,\n                          [Define if you have linux style pthread_getname_np]);;\n             ibm) AC_DEFINE(ETHR_HAVE_PTHREAD_GETNAME_NP_2, 1,\n                          [Define if you have ibm style pthread_getname_np]);;\n             *) ;;\n\tesac\n\tCFLAGS=$old_CFLAGS\n\n\tif test \"X$disable_native_ethr_impls\" = \"Xyes\"; then\n\t    ethr_have_native_atomics=no\n\telse\n\n\t    ETHR_CHK_GCC_ATOMIC_OPS([])\n\n\t    AC_MSG_CHECKING([for a usable libatomic_ops implementation])\n\t    case \"x$with_libatomic_ops\" in\n\t        xno | xyes | x)\n\t    \t    libatomic_ops_include=\n\t    \t    ;;\n\t        *)\n\t    \t    if test -d \"${with_libatomic_ops}/include\"; then\n\t    \t        libatomic_ops_include=\"-I$with_libatomic_ops/include\"\n\t    \t        CPPFLAGS=\"$CPPFLAGS $libatomic_ops_include\"\n\t    \t    else\n\t    \t        AC_MSG_ERROR([libatomic_ops include directory $with_libatomic_ops/include not found])\n\t    \t    fi;;\n\t    esac\n\t    ethr_have_libatomic_ops=no\n\t    AC_TRY_LINK([#include \"atomic_ops.h\"],\n\t    \t        [\n\t    \t    \t    volatile AO_t x;\n\t    \t    \t    AO_t y;\n\t    \t    \t    int z;\n\n\t    \t    \t    AO_nop_full();\n#if defined(AO_HAVE_store)\n\t    \t    \t    AO_store(&x, (AO_t) 0);\n#elif defined(AO_HAVE_store_release)\n\t    \t    \t    AO_store_release(&x, (AO_t) 0);\n#else\n#error No store\n#endif\n#if defined(AO_HAVE_load)\n\t    \t    \t    z = AO_load(&x);\n#elif defined(AO_HAVE_load_acquire)\n\t    \t    \t    z = AO_load_acquire(&x);\n#else\n#error No load\n#endif\n#if defined(AO_HAVE_compare_and_swap_full)\n\t    \t    \t    z = AO_compare_and_swap_full(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap_release)\n\t    \t    \t    z = AO_compare_and_swap_release(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap_acquire)\n\t    \t    \t    z = AO_compare_and_swap_acquire(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap)\n\t    \t    \t    z = AO_compare_and_swap(&x, (AO_t) 0, (AO_t) 1);\n#else\n#error No compare_and_swap\n#endif\n\t    \t        ],\n\t    \t        [ethr_have_native_atomics=yes\n\t\t\t ethr_native_atomic_implementation=libatomic_ops\n\t    \t         ethr_have_libatomic_ops=yes])\n\t    AC_MSG_RESULT([$ethr_have_libatomic_ops])\n\t    if test $ethr_have_libatomic_ops = yes; then\n\t        AC_CHECK_SIZEOF(AO_t, ,\n\t    \t    \t        [\n\t    \t    \t    \t    #include <stdio.h>\n\t    \t    \t    \t    #include \"atomic_ops.h\"\n\t    \t    \t        ])\n\t        AC_DEFINE_UNQUOTED(ETHR_SIZEOF_AO_T, $ac_cv_sizeof_AO_t, [Define to the size of AO_t if libatomic_ops is used])\n\n\t        AC_DEFINE(ETHR_HAVE_LIBATOMIC_OPS, 1, [Define if you have libatomic_ops atomic operations])\n\t        if test \"x$with_libatomic_ops\" != \"xno\" && test \"x$with_libatomic_ops\" != \"x\"; then\n\t    \t    AC_DEFINE(ETHR_PREFER_LIBATOMIC_OPS_NATIVE_IMPLS, 1, [Define if you prefer libatomic_ops native ethread implementations])\n\t        fi\n\t        ETHR_DEFS=\"$ETHR_DEFS $libatomic_ops_include\"\n\t    elif test \"x$with_libatomic_ops\" != \"xno\" && test \"x$with_libatomic_ops\" != \"x\"; then\n\t        AC_MSG_ERROR([No usable libatomic_ops implementation found])\n\t    fi\n\n\t    case \"$host_cpu\" in\n\t      sparc | sun4u | sparc64 | sun4v)\n\t    \t    case \"$with_sparc_memory_order\" in\n\t    \t        \"TSO\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_TSO, 1, [Define if only run in Sparc TSO mode]);;\n\t    \t        \"PSO\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_PSO, 1, [Define if only run in Sparc PSO, or TSO mode]);;\n\t    \t        \"RMO\"|\"\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_RMO, 1, [Define if run in Sparc RMO, PSO, or TSO mode]);;\n\t    \t        *)\n\t    \t    \t    AC_MSG_ERROR([Unsupported Sparc memory order: $with_sparc_memory_order]);;\n\t    \t    esac\n\t\t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;; \n\t      i86pc | i*86 | x86_64 | amd64)\n\t    \t    if test \"$enable_x86_out_of_order\" = \"yes\"; then\n\t    \t    \t    AC_DEFINE(ETHR_X86_OUT_OF_ORDER, 1, [Define if x86/x86_64 out of order instructions should be synchronized])\n\t    \t    fi\n\t\t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      macppc | ppc | powerpc | \"Power Macintosh\")\n\t      \t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      tile)\n\t            ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      *)\n\t    \t    ;;\n\t    esac\n\n\tfi\n\n\ttest ethr_have_native_atomics = \"yes\" && ethr_have_native_spinlock=yes\n\n\tdnl Restore LIBS\n\tLIBS=$saved_libs\n\tdnl restore CPPFLAGS\n\tCPPFLAGS=$saved_cppflags\n\n\t;;\n    *)\n\t;;\nesac\n\nAC_MSG_CHECKING([whether default stack size should be modified])\nif test \"x$ethr_modified_default_stack_size\" != \"x\"; then\n\tAC_DEFINE_UNQUOTED(ETHR_MODIFIED_DEFAULT_STACK_SIZE, $ethr_modified_default_stack_size, [Define if you want to modify the default stack size])\n\tAC_MSG_RESULT([yes; to $ethr_modified_default_stack_size kilo words])\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nif test \"x$ETHR_THR_LIB_BASE\" != \"x\"; then\n\tETHR_DEFS=\"-DUSE_THREADS $ETHR_DEFS\"\n\tETHR_LIBS=\"-l$ethr_lib_name -lerts_internal_r $ETHR_X_LIBS\"\n\tETHR_LIB_NAME=$ethr_lib_name\nfi\n\nAC_CHECK_SIZEOF(void *)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_PTR, $ac_cv_sizeof_void_p, [Define to the size of pointers])\n\nAC_CHECK_SIZEOF(int)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_INT, $ac_cv_sizeof_int, [Define to the size of int])\nAC_CHECK_SIZEOF(long)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_LONG, $ac_cv_sizeof_long, [Define to the size of long])\nAC_CHECK_SIZEOF(long long)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_LONG_LONG, $ac_cv_sizeof_long_long, [Define to the size of long long])\nAC_CHECK_SIZEOF(__int64)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF___INT64, $ac_cv_sizeof___int64, [Define to the size of __int64])\nAC_CHECK_SIZEOF(__int128_t)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF___INT128_T, $ac_cv_sizeof___int128_t, [Define to the size of __int128_t])\n\n\ncase X$erl_xcomp_bigendian in\n    X) ;;\n    Xyes|Xno) ac_cv_c_bigendian=$erl_xcomp_bigendian;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_bigendian value: $erl_xcomp_bigendian]);;\nesac\n\nAC_C_BIGENDIAN\n\nif test \"$ac_cv_c_bigendian\" = \"yes\"; then\n    AC_DEFINE(ETHR_BIGENDIAN, 1, [Define if bigendian])\nfi\n\ncase X$erl_xcomp_double_middle_endian in\n    X) ;;\n    Xyes|Xno|Xunknown) ac_cv_c_double_middle_endian=$erl_xcomp_double_middle_endian;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_double_middle_endian value: $erl_xcomp_double_middle_endian]);;\nesac\n\nAC_C_DOUBLE_MIDDLE_ENDIAN\n\nETHR_X86_SSE2_ASM=no\ncase \"$GCC-$ac_cv_sizeof_void_p-$host_cpu\" in\n  yes-4-i86pc | yes-4-i*86 | yes-4-x86_64 | yes-4-amd64)\n    AC_MSG_CHECKING([for gcc sse2 asm support])\n    save_CFLAGS=\"$CFLAGS\"\n    CFLAGS=\"$CFLAGS -msse2\"\n    gcc_sse2_asm=no\n    AC_TRY_COMPILE([],\n\t[\n\t\tlong long x, *y;\n\t\t__asm__ __volatile__(\"movq %1, %0\\n\\t\" : \"=x\"(x) : \"m\"(*y) : \"memory\");\n\t],\n\t[gcc_sse2_asm=yes])\n    CFLAGS=\"$save_CFLAGS\"\n    AC_MSG_RESULT([$gcc_sse2_asm])\n    if test \"$gcc_sse2_asm\" = \"yes\"; then\n      AC_DEFINE(ETHR_GCC_HAVE_SSE2_ASM_SUPPORT, 1, [Define if you use a gcc that supports -msse2 and understand sse2 specific asm statements])\n      ETHR_X86_SSE2_ASM=yes\n    fi\n    ;;\n  *)\n    ;;\nesac\n\ncase \"$GCC-$host_cpu\" in\n  yes-i86pc | yes-i*86 | yes-x86_64 | yes-amd64)\n\n    if test $ac_cv_sizeof_void_p = 4; then\n       dw_cmpxchg=\"cmpxchg8b\"\n    else\n       dw_cmpxchg=\"cmpxchg16b\"\n    fi\n\n    gcc_dw_cmpxchg_asm=no\n    gcc_pic_dw_cmpxchg_asm=no\n    gcc_cflags_pic=no\n    gcc_cmpxchg8b_pic_no_clobber_ebx=no\n    gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage=no\n\n    save_CFLAGS=\"$CFLAGS\"\n\n    # Check if it works out of the box using passed CFLAGS\n    # and with -fPIC added to CFLAGS if the passed CFLAGS\n    # doesn't trigger position independent code\n    pic_cmpxchg=unknown\n    while true; do\n\n        case $pic_cmpxchg in\n\t  yes) pic_text=\"pic \";;\n\t  *) pic_text=\"\";;\n\tesac\n\n\tAC_MSG_CHECKING([for gcc $pic_text$dw_cmpxchg plain asm support])    \n\n\tplain_cmpxchg=no\n    \tAC_TRY_COMPILE([],\n\t[\n    char xchgd;\n    long new[2], xchg[2], *p;\t\t  \n    __asm__ __volatile__(\n#if ETHR_SIZEOF_PTR == 4\n\t\"lock; cmpxchg8b %0\\n\\t\"\n#else\n\t\"lock; cmpxchg16b %0\\n\\t\"\n#endif\n\t\"setz %3\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=q\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"c\"(new[1]), \"b\"(new[0])\n\t: \"cc\", \"memory\");\n\t],\n\t[plain_cmpxchg=yes])\n\n\tAC_MSG_RESULT([$plain_cmpxchg])\n\n\tif test $pic_cmpxchg = yes; then\n\t   gcc_pic_dw_cmpxchg_asm=$plain_cmpxchg\n\t   break\n\tfi\n\n\tgcc_dw_cmpxchg_asm=$plain_cmpxchg\n\n    \t# If not already compiling to position independent\n\t# code add -fPIC to CFLAGS and do it again. This\n\t# since we want also want to know how to compile\n\t# to position independent code since this might\n\t# cause problems with the use of the EBX register\n\t# as input to the asm on 32-bit x86 and old gcc\n\t# compilers (gcc vsn < 5).\n\n    \tAC_TRY_COMPILE([],\n\t[\n#if !defined(__PIC__) || !__PIC__\n#  error no pic\n#endif\n\t],\n\t[pic_cmpxchg=yes\n\t gcc_cflags_pic=yes],\n\t[pic_cmpxchg=no])\n\n\tif test $pic_cmpxchg = yes; then\n\t   gcc_pic_dw_cmpxchg_asm=$gcc_dw_cmpxchg_asm\n\t   break\n\tfi\n\n\tCFLAGS=\"$save_CFLAGS -fPIC\"\n\tpic_cmpxchg=yes\n\n    done\n\n    if test $gcc_pic_dw_cmpxchg_asm = no && test $ac_cv_sizeof_void_p = 4; then\n\n      AC_MSG_CHECKING([for gcc pic cmpxchg8b asm support with EBX workaround])\n\n      # Check if we can work around it by managing the ebx\n      # register explicitly in the asm...\n\n      AC_TRY_COMPILE([],\n\t[\n    char xchgd;\n    long new[2], xchg[2], *p;\t\t  \n    __asm__ __volatile__(\n\t\"pushl %%ebx\\n\\t\"\n\t\"movl %8, %%ebx\\n\\t\"\n\t\"lock; cmpxchg8b %0\\n\\t\"\n\t\"setz %3\\n\\t\"\n\t\"popl %%ebx\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=q\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"c\"(new[1]), \"r\"(new[0])\n\t: \"cc\", \"memory\");\n\t],\n\t[gcc_pic_dw_cmpxchg_asm=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx=yes])     \n\n      AC_MSG_RESULT([$gcc_pic_dw_cmpxchg_asm])\n\n      if test $gcc_pic_dw_cmpxchg_asm = no; then\n\n      \tAC_MSG_CHECKING([for gcc pic cmpxchg8b asm support with EBX and register shortage workarounds])\n        # If no optimization is enabled we sometimes get a\n\t# register shortage. Check if we can work around\n\t# this...\n\n      \tAC_TRY_COMPILE([],\n\t  [\n      char xchgd;\n      long new[2], xchg[2], *p;\n      __asm__ __volatile__(\n\t\"pushl %%ebx\\n\\t\"\n\t\"movl (%7), %%ebx\\n\\t\"\n\t\"movl 4(%7), %%ecx\\n\\t\"\n\t\"lock; cmpxchg8b %0\\n\\t\"\n\t\"setz %3\\n\\t\"\n\t\"popl %%ebx\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=c\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"r\"(new)\n\t: \"cc\", \"memory\");\n\n\t],\n\t[gcc_pic_dw_cmpxchg_asm=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage=yes])\n\n        AC_MSG_RESULT([$gcc_pic_dw_cmpxchg_asm])\n      fi\n\n      if test $gcc_cflags_pic = yes; then\n        gcc_dw_cmpxchg_asm=$gcc_pic_dw_cmpxchg_asm\n      fi\n \n   fi\n\n    CFLAGS=\"$save_CFLAGS\"\n\n    if test \"$gcc_cmpxchg8b_pic_no_clobber_ebx\" = \"yes\"; then\n      AC_DEFINE(ETHR_CMPXCHG8B_PIC_NO_CLOBBER_EBX, 1, [Define if gcc wont let you clobber ebx with cmpxchg8b and position independent code])\n    fi\n    if test \"$gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage\" = \"yes\"; then\n      AC_DEFINE(ETHR_CMPXCHG8B_REGISTER_SHORTAGE, 1, [Define if you get a register shortage with cmpxchg8b and position independent code])\n    fi\n    if test \"$gcc_dw_cmpxchg_asm\" = \"yes\"; then\n      AC_DEFINE(ETHR_GCC_HAVE_DW_CMPXCHG_ASM_SUPPORT, 1, [Define if you use a gcc that supports the double word cmpxchg instruction])\n    fi;;\n  *)\n    ;;\nesac\n\nAC_DEFINE(ETHR_HAVE_ETHREAD_DEFINES, 1, \\\n[Define if you have all ethread defines])\n\nAC_SUBST(ETHR_X_LIBS)\nAC_SUBST(ETHR_LIBS)\nAC_SUBST(ETHR_LIB_NAME)\nAC_SUBST(ETHR_DEFS)\nAC_SUBST(ETHR_THR_LIB_BASE)\nAC_SUBST(ETHR_THR_LIB_BASE_DIR)\nAC_SUBST(ETHR_X86_SSE2_ASM)\n\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl ERL_TIME_CORRECTION\ndnl\ndnl Check for primitives that can be used for implementing\ndnl erts_os_monotonic_time() and erts_os_system_time()\ndnl\n\nAC_DEFUN(ERL_TIME_CORRECTION,\n[\n\nAC_ARG_WITH(clock-resolution,\nAS_HELP_STRING([--with-clock-resolution=high|low|default],\n               [specify wanted clock resolution]))\n\nAC_ARG_WITH(clock-gettime-realtime-id,\nAS_HELP_STRING([--with-clock-gettime-realtime-id=CLOCKID],\n               [specify clock id to use with clock_gettime() for realtime time)]))\n\nAC_ARG_WITH(clock-gettime-monotonic-id,\nAS_HELP_STRING([--with-clock-gettime-monotonic-id=CLOCKID],\n               [specify clock id to use with clock_gettime() for monotonic time)]))\n\nAC_ARG_ENABLE(prefer-elapsed-monotonic-time-during-suspend,\nAS_HELP_STRING([--enable-prefer-elapsed-monotonic-time-during-suspend],\n               [Prefer an OS monotonic time source with elapsed time during suspend])\nAS_HELP_STRING([--disable-prefer-elapsed-monotonic-time-during-suspend],\n               [Do not prefer an OS monotonic time source with elapsed time during suspend]),\n[ case \"$enableval\" in\n    yes) prefer_elapsed_monotonic_time_during_suspend=yes ;;\n    *)  prefer_elapsed_monotonic_time_during_suspend=no ;;\n  esac ], prefer_elapsed_monotonic_time_during_suspend=no)\n\nAC_ARG_ENABLE(gettimeofday-as-os-system-time,\n\t      AS_HELP_STRING([--enable-gettimeofday-as-os-system-time],\n                             [Force usage of gettimeofday() for OS system time]),\n[ case \"$enableval\" in\n    yes) force_gettimeofday_os_system_time=yes ;;\n    *)  force_gettimeofday_os_system_time=no ;;\n  esac ], force_gettimeofday_os_system_time=no)\n\ncase \"$with_clock_resolution\" in\n   \"\"|no|yes)\n     with_clock_resolution=default;;\n   high|low|default)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid wanted clock resolution: $with_clock_resolution])\n     ;;\nesac\n\nif test \"$force_gettimeofday_os_system_time\" = \"yes\"; then\n\n  AC_CHECK_FUNCS([gettimeofday])\n  if test \"$ac_cv_func_gettimeofday\" = \"yes\"; then\n    AC_DEFINE(OS_SYSTEM_TIME_GETTIMEOFDAY,  [1], [Define if you want to implement erts_os_system_time() using gettimeofday()])\n  else\n    AC_MSG_ERROR([No gettimeofday() available])\n  fi\n\nelse # $force_gettimeofday_os_system_time != yes\n\ncase \"$with_clock_gettime_realtime_id\" in\n   \"\"|no)\n     with_clock_gettime_realtime_id=no\n     ;;\n   CLOCK_*CPUTIME*)\n     AC_MSG_ERROR([Invalid clock_gettime() realtime clock id: Refusing to use the cputime clock id $with_clock_gettime_realtime_id as realtime clock id])\n     ;;\n   CLOCK_MONOTONIC*|CLOCK_BOOTTIME*|CLOCK_UPTIME*|CLOCK_HIGHRES*)\n     AC_MSG_ERROR([Invalid clock_gettime() realtime clock id: Refusing to use the monotonic clock id $with_clock_gettime_realtime_id as realtime clock id])\n     ;;\n   CLOCK_*)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid clock_gettime() clock id: $with_clock_gettime_realtime_id])\n     ;;\nesac\n\ncase \"$with_clock_resolution-$with_clock_gettime_realtime_id\" in\n  high-no)\n\tERL_WALL_CLOCK(high_resolution);;\n  low-no)\n\tERL_WALL_CLOCK(low_resolution);;\n  default-no)\n\tERL_WALL_CLOCK(default_resolution);;\n  *)\n\tERL_WALL_CLOCK(custom_resolution, $with_clock_gettime_realtime_id);;\nesac\n\ncase \"$erl_wall_clock_func-$erl_wall_clock_id-$with_clock_gettime_realtime_id\" in\n  *-*-no)\n    ;;\n  clock_gettime-$with_clock_gettime_realtime_id-$with_clock_gettime_realtime_id)\n    ;;\n  *)\n    AC_MSG_ERROR([$with_clock_gettime_realtime_id as clock id to clock_gettime() doesn't compile])\n    ;;\nesac\n\ncase $erl_wall_clock_func in\n  none)\n    AC_MSG_ERROR([No wall clock source found])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(OS_SYSTEM_TIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_system_time() using mach clock_get_time()])\n    ;;\n  clock_gettime)\n    AC_DEFINE(OS_SYSTEM_TIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_system_time() using clock_gettime()])\n    ;;\n  gettimeofday)\n    AC_DEFINE(OS_SYSTEM_TIME_GETTIMEOFDAY,  [1], [Define if you want to implement erts_os_system_time() using gettimeofday()])\n    ;;\n  *)\n    ;;\nesac\n\nif test \"x$erl_wall_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(WALL_CLOCK_ID_STR, [\"$erl_wall_clock_id\"], [Define as a string of wall clock id to use])\n    AC_DEFINE_UNQUOTED(WALL_CLOCK_ID, [$erl_wall_clock_id], [Define to wall clock id to use])\nfi\n\nfi # $force_gettimeofday_os_system_time != yes\n\ncase \"$with_clock_gettime_monotonic_id\" in\n   \"\"|no)\n     with_clock_gettime_monotonic_id=no\n     ;;\n   CLOCK_*CPUTIME*)\n     AC_MSG_ERROR([Invalid clock_gettime() monotonic clock id: Refusing to use the cputime clock id $with_clock_gettime_monotonic_id as monotonic clock id])\n     ;;\n   CLOCK_REALTIME*|CLOCK_TAI*)\n     AC_MSG_ERROR([Invalid clock_gettime() monotonic clock id: Refusing to use the realtime clock id $with_clock_gettime_monotonic_id as monotonic clock id])\n     ;;\n   CLOCK_*)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid clock_gettime() clock id: $with_clock_gettime_monotonic_id])\n     ;;\nesac\n\ncase \"$with_clock_resolution-$with_clock_gettime_monotonic_id\" in\n  high-no)\n\tERL_MONOTONIC_CLOCK(high_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  low-no)\n\tERL_MONOTONIC_CLOCK(low_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  default-no)\n\tERL_MONOTONIC_CLOCK(default_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  *)\n\tERL_MONOTONIC_CLOCK(custom_resolution, $with_clock_gettime_monotonic_id, $prefer_elapsed_monotonic_time_during_suspend);;\nesac\n\ncase \"$erl_monotonic_clock_func-$erl_monotonic_clock_id-$with_clock_gettime_monotonic_id\" in\n  *-*-no)\n    ;;\n  clock_gettime-$with_clock_gettime_monotonic_id-$with_clock_gettime_monotonic_id)\n    ;;\n  *)\n    AC_MSG_ERROR([$with_clock_gettime_monotonic_id as clock id to clock_gettime() doesn't compile])\n    ;;\nesac\n\ncase $erl_monotonic_clock_func in\n  times)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_TIMES, [1], [Define if you want to implement erts_os_monotonic_time() using times()])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_monotonic_time() using mach clock_get_time()])\n    ;;\n  clock_gettime)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_monotonic_time() using clock_gettime()])\n    ;;\n  gethrtime)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_GETHRTIME,  [1], [Define if you want to implement erts_os_monotonic_time() using gethrtime()])\n    ;;\n  *)\n    ;;\nesac\n\nif test $erl_corrected_monotonic_clock = yes; then\n  AC_DEFINE(ERTS_HAVE_CORRECTED_OS_MONOTONIC_TIME, [1], [Define if OS monotonic clock is corrected])\nfi\n\nif test $erl_monotonic_clock_low_resolution = yes; then\n  AC_DEFINE(ERTS_HAVE_LOW_RESOLUTION_OS_MONOTONIC_LOW, [1], [Define if you have a low resolution OS monotonic clock])\nfi\n\nxrtlib=\nif test \"$erl_monotonic_clock_lib\" != \"\"; then\n   xrtlib=\"$erl_monotonic_clock_lib\"\nfi\nif test \"$erl_wall_clock_lib\" != \"\"; then\n   xrtlib=\"$erl_wall_clock_lib\"\nfi\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(MONOTONIC_CLOCK_ID_STR, [\"$erl_monotonic_clock_id\"], [Define as a string of monotonic clock id to use])\n    AC_DEFINE_UNQUOTED(MONOTONIC_CLOCK_ID, [$erl_monotonic_clock_id], [Define to monotonic clock id to use])\nfi\n\nif test $erl_cv_clock_gettime_monotonic_raw = yes; then\n  AC_DEFINE(HAVE_CLOCK_GETTIME_MONOTONIC_RAW, [1], [Define if you have clock_gettime(CLOCK_MONOTONIC_RAW, _)])\nfi\n\nERL_MONOTONIC_CLOCK(high_resolution, undefined, no)\n\ncase $$erl_monotonic_clock_low_resolution-$erl_monotonic_clock_func in\n  no-mach_clock_get_time)\n    monotonic_hrtime=yes    \n    AC_DEFINE(SYS_HRTIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_hrtime() using mach clock_get_time()])\n    ;;\n  no-clock_gettime)\n    monotonic_hrtime=yes\n    AC_DEFINE(SYS_HRTIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_hrtime() using clock_gettime()])\n    ;;\n  no-gethrtime)\n    monotonic_hrtime=yes\n    AC_DEFINE(SYS_HRTIME_USING_GETHRTIME,  [1], [Define if you want to implement erts_os_hrtime() using gethrtime()])\n    ;;\n  *)\n    monotonic_hrtime=no\n    ;;\nesac\n\nif test $monotonic_hrtime = yes; then\n    AC_DEFINE(HAVE_MONOTONIC_ERTS_SYS_HRTIME, [1], [Define if you have a monotonic erts_os_hrtime() implementation])\nfi\n\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(HRTIME_CLOCK_ID_STR, [\"$erl_monotonic_clock_id\"], [Define as a string of monotonic clock id to use])\n    AC_DEFINE_UNQUOTED(HRTIME_CLOCK_ID, [$erl_monotonic_clock_id], [Define to monotonic clock id to use])\nfi\n\n\ndnl\ndnl Check if gethrvtime is working, and if to use procfs ioctl\ndnl or (yet to be written) write to the procfs ctl file.\ndnl\n\nAC_MSG_CHECKING([if gethrvtime works and how to use it])\nAC_TRY_RUN([\n/* gethrvtime procfs ioctl test */\n/* These need to be undef:ed to not break activation of\n * micro level process accounting on /proc/self \n */\n#ifdef _LARGEFILE_SOURCE\n#  undef _LARGEFILE_SOURCE\n#endif\n#ifdef _FILE_OFFSET_BITS\n#  undef _FILE_OFFSET_BITS\n#endif\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/signal.h>\n#include <sys/fault.h>\n#include <sys/syscall.h>\n#include <sys/procfs.h>\n#include <fcntl.h>\n\nint main() {\n    long msacct = PR_MSACCT;\n    int fd;\n    long long start, stop;\n    int i;\n    pid_t pid = getpid();\n    char proc_self[30] = \"/proc/\";\n\n    sprintf(proc_self+strlen(proc_self), \"%lu\", (unsigned long) pid);\n    if ( (fd = open(proc_self, O_WRONLY)) == -1)\n\texit(1);\n    if (ioctl(fd, PIOCSET, &msacct) < 0)\n\texit(2);\n    if (close(fd) < 0)\n\texit(3);\n    start = gethrvtime();\n    for (i = 0; i < 100; i++)\n\tstop = gethrvtime();\n    if (start == 0)\n\texit(4);\n    if (start == stop)\n\texit(5);\n    exit(0); return 0;\n}\n],\nerl_gethrvtime=procfs_ioctl,\nerl_gethrvtime=false,\n[\ncase X$erl_xcomp_gethrvtime_procfs_ioctl in\n    X)\n\terl_gethrvtime=cross;;\n    Xyes|Xno)\n\tif test $erl_xcomp_gethrvtime_procfs_ioctl = yes; then\n\t    erl_gethrvtime=procfs_ioctl\n\telse\n\t    erl_gethrvtime=false\n\tfi;;\n    *)\n\tAC_MSG_ERROR([Bad erl_xcomp_gethrvtime_procfs_ioctl value: $erl_xcomp_gethrvtime_procfs_ioctl]);;\nesac\n])\n\nLIBRT=$xrtlib\ncase $erl_gethrvtime in\n  procfs_ioctl)\n\tAC_DEFINE(HAVE_GETHRVTIME_PROCFS_IOCTL,[1],\n\t\t[define if gethrvtime() works and uses ioctl() to /proc/self])\n\tAC_MSG_RESULT(uses ioctl to procfs)\n\t;;\n  *)\n\tif test $erl_gethrvtime = cross; then\n\t    erl_gethrvtime=false\n\t    AC_MSG_RESULT(cross)\n\t    AC_MSG_WARN([result 'not working' guessed because of cross compilation])\n\telse\n\t    AC_MSG_RESULT(not working)\n\tfi\n\n\tdnl\n\tdnl Check if clock_gettime (linux) is working\n\tdnl\n\n\tAC_MSG_CHECKING([if clock_gettime can be used to get thread CPU time])\n\tsave_libs=$LIBS\n\tLIBS=\"-lrt\"\n\tAC_TRY_RUN([\n\t#include <stdlib.h>\n\t#include <unistd.h>\n\t#include <string.h>\n\t#include <stdio.h>\n\t#include <time.h>\n\tint main() {\n\t    long long start, stop;\n\t    int i;\n\t    struct timespec tp;\n\n\t    if (clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp) < 0)\n\t      exit(1);\n\t    start = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;\n\t    for (i = 0; i < 100; i++)\n\t      clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp);\n\t    stop = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;\n\t    if (start == 0)\n\t      exit(4);\n\t    if (start == stop)\n\t      exit(5);\n\t    exit(0); return 0;\n\t  }\n\t],\n\terl_clock_gettime_cpu_time=yes,\n\terl_clock_gettime_cpu_time=no,\n\t[\n\tcase X$erl_xcomp_clock_gettime_cpu_time in\n\t    X) erl_clock_gettime_cpu_time=cross;;\n\t    Xyes|Xno) erl_clock_gettime_cpu_time=$erl_xcomp_clock_gettime_cpu_time;;\n\t    *) AC_MSG_ERROR([Bad erl_xcomp_clock_gettime_cpu_time value: $erl_xcomp_clock_gettime_cpu_time]);;\n\tesac\n\t])\n\tLIBS=$save_libs\n\tAC_MSG_RESULT($erl_clock_gettime_cpu_time)\n\tcase $erl_clock_gettime_cpu_time in\n\t\tyes)\n\t\t\tAC_DEFINE(HAVE_CLOCK_GETTIME_CPU_TIME,[],\n\t\t\t\t  [define if clock_gettime() works for getting thread time])\n\t\t\tLIBRT=-lrt\n\t\t\t;;\n\t\tcross)\n\t\t\terl_clock_gettime_cpu_time=no\n\t\t\tAC_MSG_WARN([result no guessed because of cross compilation])\n\t\t\t;;\n\t\t*)\n\t\t\t;;\n\tesac\n\t;;\nesac\nAC_SUBST(LIBRT)\n])dnl\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_TRY_ENABLE_CFLAG\ndnl\ndnl\ndnl Tries a CFLAG and sees if it can be enabled without compiler errors\ndnl $1: textual cflag to add\ndnl $2: variable to store the modified CFLAG in\ndnl Usage example LM_TRY_ENABLE_CFLAG([-Werror=return-type], [CFLAGS])\ndnl\ndnl\nAC_DEFUN([LM_TRY_ENABLE_CFLAG], [\n    AC_MSG_CHECKING([if we can add $1 to $2 (via CFLAGS)])\n    saved_CFLAGS=$CFLAGS;\n    CFLAGS=\"$1 $$2\";\n    AC_TRY_COMPILE([],[return 0;],can_enable_flag=true,can_enable_flag=false)\n    CFLAGS=$saved_CFLAGS;\n    if test \"X$can_enable_flag\" = \"Xtrue\"; then\n        AC_MSG_RESULT([yes])\n        AS_VAR_SET($2, \"$1 $$2\")\n    else\n        AC_MSG_RESULT([no])\n    fi\n])\n\nAC_DEFUN([LM_CHECK_ENABLE_CFLAG], [\n    AC_MSG_CHECKING([whether $CC accepts $1...])\n    saved_CFLAGS=$CFLAGS;\n    CFLAGS=\"$1 $CFLAGS\";\n    AC_TRY_COMPILE([],[return 0;],can_enable_flag=true,can_enable_flag=false)\n    CFLAGS=$saved_CFLAGS;\n    if test \"X$can_enable_flag\" = \"Xtrue\"; then\n        AS_VAR_SET($2, true)\n        AC_MSG_RESULT([yes])\n    else\n        AS_VAR_SET($2, false)\n        AC_MSG_RESULT([no])\n    fi\n])\n\ndnl ERL_TRY_LINK_JAVA(CLASSES, FUNCTION-BODY\ndnl                   [ACTION_IF_FOUND [, ACTION-IF-NOT-FOUND]])\ndnl Freely inspired by AC_TRY_LINK. (Maybe better to create a \ndnl AC_LANG_JAVA instead...)\nAC_DEFUN(ERL_TRY_LINK_JAVA,\n[java_link='$JAVAC conftest.java 1>&AC_FD_CC'\nchangequote(, )dnl\ncat > conftest.java <<EOF\n$1\nclass conftest { public static void main(String[] args) {\n   $2\n   ; return; }}\nEOF\nchangequote([, ])dnl\nif AC_TRY_EVAL(java_link) && test -s conftest.class; then\n   ifelse([$3], , :, [rm -rf conftest*\n   $3])\nelse\n   echo \"configure: failed program was:\" 1>&AC_FD_CC\n   cat conftest.java 1>&AC_FD_CC\n   echo \"configure: PATH was $PATH\" 1>&AC_FD_CC\nifelse([$4], , , [  rm -rf conftest*\n  $4\n])dnl\nfi\nrm -f conftest*])\n#define UNSAFE_MASK  0xc0000000 /* Mask for bits that must be constant */\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_HARDWARE_ARCH\ndnl\ndnl Determine target hardware in ARCH\ndnl\nAC_DEFUN([LM_HARDWARE_ARCH], [\n    AC_MSG_CHECKING([target hardware architecture])\n    if test \"x$host_alias\" != \"x\" -a \"x$host_cpu\" != \"x\"; then\n        chk_arch_=$host_cpu\n    else\n        chk_arch_=`uname -m`\n    fi\n\n    case $chk_arch_ in\n    sun4u)\tARCH=ultrasparc;;\n    sparc64)\tARCH=sparc64;;\n    sun4v)\tARCH=ultrasparc;;\n    i86pc)\tARCH=x86;;\n    i386)\tARCH=x86;;\n    i486)\tARCH=x86;;\n    i586)\tARCH=x86;;\n    i686)\tARCH=x86;;\n    x86_64)\tARCH=amd64;;\n    amd64)\tARCH=amd64;;\n    macppc)\tARCH=ppc;;\n    powerpc)\tARCH=ppc;;\n    ppc)\tARCH=ppc;;\n    ppc64)\tARCH=ppc64;;\n    ppc64le)\tARCH=ppc64le;;\n    \"Power Macintosh\")\tARCH=ppc;;\n    armv5b)\tARCH=arm;;\n    armv5teb)\tARCH=arm;;\n    armv5tel)\tARCH=arm;;\n    armv5tejl)\tARCH=arm;;\n    armv6l)\tARCH=arm;;\n    armv6hl)\tARCH=arm;;\n    armv7l)\tARCH=arm;;\n    armv7hl)\tARCH=arm;;\n    tile)\tARCH=tile;;\n    e2k)        ARCH=e2k;;\n    *)\t \tARCH=noarch;;\n    esac\n    AC_MSG_RESULT($ARCH)\n\n    dnl\n    dnl Convert between x86 and amd64 based on the compiler's mode.\n    dnl Ditto between ultrasparc and sparc64.\n    dnl\n    AC_MSG_CHECKING(whether compilation mode forces ARCH adjustment)\n    case \"$ARCH-$ac_cv_sizeof_void_p\" in\n    x86-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=x86 to ARCH=amd64)\n\tARCH=amd64\n\t;;\n    amd64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=amd64 to ARCH=x86)\n\tARCH=x86\n\t;;\n    ultrasparc-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ultrasparc to ARCH=sparc64)\n\tARCH=sparc64\n\t;;\n    sparc64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=sparc64 to ARCH=ultrasparc)\n\tARCH=ultrasparc\n\t;;\n    ppc64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ppc64 to ARCH=ppc)\n\tARCH=ppc\n\t;;\n    ppc-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ppc to ARCH=ppc64)\n\tARCH=ppc64\n\t;;\n    arm-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=arm to ARCH=noarch)\n\tARCH=noarch\n\t;;\n    *)\n\tAC_MSG_RESULT(no: ARCH is $ARCH)\n\t;;\n    esac\n\n    AC_SUBST(ARCH)\n])\n\ndnl\ndnl--------------------------------------------------------------------\ndnl Dynamic Erlang Drivers\ndnl\ndnl Linking to produce dynamic Erlang drivers to be loaded by Erlang's\ndnl Dynamic Driver Loader and Linker (DDLL). Below the prefix DED is an\ndnl abbreviation for `Dynamic Erlang Driver'.\ndnl\ndnl For DED we need something quite sloppy, which allows undefined references \ndnl (notably driver functions) in the resulting shared library. \ndnl Example of Makefile rule (and settings of macros):\ndnl\ndnl LIBS = @LIBS@\ndnl LD = @DED_LD@\ndnl LDFLAGS = @DED_LDFLAGS@\ndnl soname = @ldsoname@\ndnl\ndnl my_drv.so:   my_drv.o my_utils.o\ndnl              $(LD) $(LDFLAGS) $(soname) $@ -o $@ $^ -lc $(LIBS)\ndnl\ndnl--------------------------------------------------------------------\ndnl\n\nAC_DEFUN(ERL_DED,\n\t[\n\nUSER_LD=$LD\nUSER_LDFLAGS=\"$LDFLAGS\"\n\nLM_CHECK_THR_LIB\n\nDED_CC=$CC\nDED_GCC=$GCC\n\nDED_CFLAGS=\nDED_OSTYPE=unix\ncase $host_os in\n     linux*)\n\tDED_CFLAGS=\"-D_GNU_SOURCE\" ;;\n     win32)\n\tDED_CFLAGS=\"-D_WIN32_WINNT=0x0600 -DWINVER=0x0600\"\n        DED_OSTYPE=win32 ;;\n     *)\n        ;;\nesac\n\n\nDED_WARN_FLAGS=\"-Wall -Wstrict-prototypes\"\ncase \"$host_cpu\" in\n  tile*)\n    # tile-gcc is a bit stricter with -Wmissing-prototypes than other gccs,\n    # and too strict for our taste.\n    ;;\n  *)\n    DED_WARN_FLAGS=\"$DED_WARN_FLAGS -Wmissing-prototypes\";;\nesac\n  \nLM_TRY_ENABLE_CFLAG([-Wdeclaration-after-statement], [DED_WARN_FLAGS])\n\nLM_TRY_ENABLE_CFLAG([-Werror=return-type], [DED_WERRORFLAGS])\nLM_TRY_ENABLE_CFLAG([-Werror=implicit], [DED_WERRORFLAGS])\nLM_TRY_ENABLE_CFLAG([-Werror=undef], [DED_WERRORFLAGS])\n\nDED_SYS_INCLUDE=\"-I${ERL_TOP}/erts/emulator/beam -I${ERL_TOP}/erts/include -I${ERL_TOP}/erts/include/$host -I${ERL_TOP}/erts/include/internal -I${ERL_TOP}/erts/include/internal/$host -I${ERL_TOP}/erts/emulator/sys/$DED_OSTYPE -I${ERL_TOP}/erts/emulator/sys/common\"\nDED_INCLUDE=$DED_SYS_INCLUDE\n\nif test \"$THR_DEFS\" = \"\"; then\n    DED_THR_DEFS=\"-D_THREAD_SAFE -D_REENTRANT\"\nelse\n    DED_THR_DEFS=\"$THR_DEFS\"\nfi\n# DED_EMU_THR_DEFS=$EMU_THR_DEFS\nDED_CFLAGS=\"$CFLAGS $CPPFLAGS $DED_CFLAGS\"\nif test \"x$GCC\" = xyes; then\n    DED_STATIC_CFLAGS=\"$DED_CFLAGS\"\n    DED_CFLAGS=\"$DED_CFLAGS -fPIC\"\nfi\n\nDED_EXT=so\ncase $host_os in\n    win32) DED_EXT=dll;;\n    darwin*)\n\tDED_CFLAGS=\"$DED_CFLAGS -fno-common\"\n\tDED_STATIC_CFLAGS=\"$DED_STATIC_CFLAGS -fno-common\";;\n    *)\n\t;;\nesac\n\nDED_STATIC_CFLAGS=\"$DED_STATIC_CFLAGS -DSTATIC_ERLANG_NIF -DSTATIC_ERLANG_DRIVER\"\n\nif test \"$CFLAG_RUNTIME_LIBRARY_PATH\" = \"\"; then\n\n  CFLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-R\"\n  case $host_os in\n    darwin*)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n    win32)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n    osf*)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-rpath,\"\n\t;;\n    *)\n\t;;\n  esac\n\nfi\n\n# If DED_LD is set in environment, we expect all DED_LD* variables\n# to be specified (cross compiling)\nif test \"x$DED_LD\" = \"x\"; then\n\nDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-R\"\ncase $host_os in\n\twin32)\n\t\tDED_LD=\"ld.sh\"\n\t\tDED_LDFLAGS=\"-dll\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n\tsolaris2*|sysv4*)\n\t\tDED_LDFLAGS=\"-G\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-64 $DED_LDFLAGS\"\n\t\tfi\n\t;;\n\taix4*)\n\t\tDED_LDFLAGS=\"-G -bnoentry -bexpall\"\n\t;;\n\tfreebsd2*)\n\t\t# Non-ELF GNU linker\n\t\tDED_LDFLAGS=\"-Bshareable\"\n\t;;\n\tdarwin*)\n\t\t# Mach-O linker: a shared lib and a loadable\n\t\t# object file is not the same thing.\n\t\tDED_LDFLAGS=\"-bundle -bundle_loader ${ERL_TOP}/bin/$host/beam.smp\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t  DED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\telse\n\t\t  if test X${enable_m32_build} = Xyes; then\n\t\t    DED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\t  else\n\t\t    AC_CHECK_SIZEOF(void *)\n\t\t    case \"$ac_cv_sizeof_void_p\" in\n\t\t      8)\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\";;\n\t\t      *)\n\t\t        ;;\n\t\t    esac\n\t\t  fi\n\t\tfi\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t;;\n\tlinux*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared -Wl,-Bsymbolic\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\tfi;\n\t\tif test X${enable_m32_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\tfi\n\t;;\t\n\tfreebsd*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\tfi;\n\t\tif test X${enable_m32_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\tfi\n\t;;\t\n\topenbsd*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared\"\n\t;;\n\tosf*)\n\t\t# NOTE! Whitespace after -rpath is important.\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-rpath \"\n\t\tDED_LDFLAGS=\"-shared -expect_unresolved '*'\"\n\t;;\n\t*)\n\t\t# assume GNU linker and ELF\n\t\tDED_LDFLAGS=\"-shared\"\n\t\t# GNU linker has no option for 64bit build, should not propagate -m64\n\t;;\nesac\n\nif test \"$DED_LD\" = \"\" && test \"$USER_LD\" != \"\"; then\n    DED_LD=\"$USER_LD\"\n    DED_LDFLAGS=\"$USER_LDFLAGS $DED_LDFLAGS\"\nfi\n\nDED_LIBS=$LIBS\n\nfi # \"x$DED_LD\" = \"x\"\n\nAC_CHECK_TOOL(DED_LD, ld, false)\ntest \"$DED_LD\" != \"false\" || AC_MSG_ERROR([No linker found])\n\nAC_MSG_CHECKING(for static compiler flags)\nDED_STATIC_CFLAGS=\"$DED_WERRORFLAGS $DED_WFLAGS $DED_THR_DEFS $DED_STATIC_CFLAGS\"\nAC_MSG_RESULT([$DED_STATIC_CFLAGS])\nAC_MSG_CHECKING(for basic compiler flags for loadable drivers)\nDED_BASIC_CFLAGS=$DED_CFLAGS\nAC_MSG_RESULT([$DED_CFLAGS])\nAC_MSG_CHECKING(for compiler flags for loadable drivers)\nDED_CFLAGS=\"$DED_WERRORFLAGS $DED_WARN_FLAGS $DED_THR_DEFS $DED_CFLAGS\"\nAC_MSG_RESULT([$DED_CFLAGS])\nAC_MSG_CHECKING(for linker for loadable drivers)\nAC_MSG_RESULT([$DED_LD])\nAC_MSG_CHECKING(for linker flags for loadable drivers)\nAC_MSG_RESULT([$DED_LDFLAGS])\nAC_MSG_CHECKING(for 'runtime library path' linker flag)\nif test \"x$DED_LD_FLAG_RUNTIME_LIBRARY_PATH\" != \"x\"; then\n\tAC_MSG_RESULT([$DED_LD_FLAG_RUNTIME_LIBRARY_PATH])\nelse\n\tAC_MSG_RESULT([not found])\nfi\n\nAC_SUBST(DED_CC)\nAC_SUBST(DED_GCC)\nAC_SUBST(DED_EXT)\nAC_SUBST(DED_SYS_INCLUDE)\nAC_SUBST(DED_INCLUDE)\nAC_SUBST(DED_BASIC_CFLAGS)\nAC_SUBST(DED_CFLAGS)\nAC_SUBST(DED_STATIC_CFLAGS)\nAC_SUBST(DED_WARN_FLAGS)\nAC_SUBST(DED_WERRORFLAGS)\nAC_SUBST(DED_LD)\nAC_SUBST(DED_LDFLAGS)\nAC_SUBST(DED_LD_FLAG_RUNTIME_LIBRARY_PATH)\nAC_SUBST(DED_LIBS)\nAC_SUBST(DED_THR_DEFS)\nAC_SUBST(DED_OSTYPE)\n\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/sys/common/erl_mtrace_sys_wrap.c": "/*\n * %CopyrightBegin%\n * \n * Copyright Ericsson AB 2004-2016. All Rights Reserved.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * \n * %CopyrightEnd%\n */\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n#include \"sys.h\"\n#include \"erl_mtrace.h\"\n\n#ifdef ERTS_CAN_TRACK_MALLOC\n#if defined(HAVE_END_SYMBOL)\nextern char end;\n#elif defined(HAVE__END_SYMBOL)\nextern char _end;\n#endif\n\nstatic int inited = 0;\nstatic int init(void);\n\nstatic volatile char *heap_start = NULL;\nstatic volatile char *heap_end = NULL;\n\n#if defined(ERTS___AFTER_MORECORE_HOOK_CAN_TRACK_MALLOC) /* ----------------- */\n\n#ifdef HAVE_MALLOC_H\n#  include <malloc.h>\n#endif\n\n#undef SBRK_0\n#define SBRK_0 sbrk(0)\n\nstatic void\ninit_hook(void)\n{\n    __after_morecore_hook = erts_mtrace_update_heap_size;\n    if (inited)\n\treturn;\n    heap_end = NULL;\n#if defined(HAVE_END_SYMBOL)\n    heap_start = &end;\n#elif defined(HAVE__END_SYMBOL)\n    heap_start = &_end;\n#else\n    heap_start = SBRK_0;\n    if (heap_start == (SBRK_RET_TYPE) -1) {\n\theap_start = NULL;\n\treturn;\n    }\n#endif\n    inited = 1;\n}\n\nstatic int\ninit(void)\n{\n    init_hook();\n    return inited;\n}\n\nvoid (*__malloc_initialize_hook)(void) = init_hook;\n\n#elif defined(ERTS_BRK_WRAPPERS_CAN_TRACK_MALLOC) /* ------------------------ */\n#ifdef HAVE_DLFCN_H\n#  include <dlfcn.h>\n#endif\n\n#undef SBRK_0\n#define SBRK_0 (*real_sbrk)(0)\n\n#ifndef HAVE_SBRK\n#  error no sbrk()\n#endif\n#if !defined(HAVE_END_SYMBOL) && !defined(HAVE__END_SYMBOL)\n#  error no 'end' nor '_end'\n#endif\n\nstatic void update_heap_size(char *new_end);\n\n#define SBRK_IMPL(RET_TYPE, FUNC, ARG_TYPE)\t\t\t\\\nRET_TYPE FUNC (ARG_TYPE);\t\t\t\t\t\\\nstatic RET_TYPE (*real_ ## FUNC)(ARG_TYPE) = NULL;\t\t\\\nRET_TYPE FUNC (ARG_TYPE arg)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n    RET_TYPE res;\t\t\t\t\t\t\\\n    if (!inited && !init())\t\t\t\t\t\\\n\treturn (RET_TYPE) -1;\t\t\t\t\t\\\n    res = (*real_ ## FUNC)(arg);\t\t\t\t\\\n    if (erts_mtrace_enabled && res != ((RET_TYPE) -1))\t\t\\\n\tupdate_heap_size((char *) (*real_ ## FUNC)(0));\t\t\\\n    return res;\t\t\t\t\t\t\t\\\n}\n\n#define BRK_IMPL(RET_TYPE, FUNC, ARG_TYPE)\t\t\t\\\nRET_TYPE FUNC (ARG_TYPE);\t\t\t\t\t\\\nstatic RET_TYPE (*real_ ## FUNC)(ARG_TYPE) = NULL;\t\t\\\nRET_TYPE FUNC (ARG_TYPE arg)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n    RET_TYPE res;\t\t\t\t\t\t\\\n    if (!inited && !init())\t\t\t\t\t\\\n\treturn (RET_TYPE) -1;\t\t\t\t\t\\\n    res = (*real_ ## FUNC)(arg);\t\t\t\t\\\n    if (erts_mtrace_enabled && res != ((RET_TYPE) -1))\t\t\\\n\tupdate_heap_size((char *) arg);\t\t\t\t\\\n    return res;\t\t\t\t\t\t\t\\\n}\n\nSBRK_IMPL(SBRK_RET_TYPE, sbrk, SBRK_ARG_TYPE)\n#ifdef HAVE_BRK\n   BRK_IMPL(BRK_RET_TYPE, brk, BRK_ARG_TYPE)\n#endif\n\n#ifdef HAVE__SBRK\n   SBRK_IMPL(SBRK_RET_TYPE, _sbrk, SBRK_ARG_TYPE)\n#endif\n#ifdef HAVE__BRK\n   BRK_IMPL(BRK_RET_TYPE, _brk, BRK_ARG_TYPE)\n#endif\n\n#ifdef HAVE___SBRK\n   SBRK_IMPL(SBRK_RET_TYPE, __sbrk, SBRK_ARG_TYPE)\n#endif\n#ifdef HAVE___BRK\n   BRK_IMPL(BRK_RET_TYPE, __brk, BRK_ARG_TYPE)\n#endif\n\nstatic int\ninit(void)\n{\n    if (inited)\n\treturn 1;\n\n#define INIT_XBRK_SYM(SYM)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n    if (!real_ ## SYM) {\t\t\t\\\n\treal_ ## SYM = dlsym(RTLD_NEXT, #SYM);\t\\\n\tif (!real_ ## SYM) {\t\t\t\\\n\t    errno = ENOMEM;\t\t\t\\\n\t    return 0;\t\t\t\t\\\n\t}\t\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n} while (0)\n\n    heap_end = NULL;\n#if defined(HAVE_END_SYMBOL)\n    heap_start = &end;\n#elif defined(HAVE__END_SYMBOL)\n    heap_start = &_end;\n#endif\n\n    INIT_XBRK_SYM(sbrk);\n#ifdef HAVE_BRK\n    INIT_XBRK_SYM(brk);\n#endif\n#ifdef HAVE__SBRK\n    INIT_XBRK_SYM(_sbrk);\n#endif\n#ifdef HAVE__BRK\n    INIT_XBRK_SYM(_brk);\n#endif\n#ifdef HAVE___SBRK\n    INIT_XBRK_SYM(__sbrk);\n#endif\n#ifdef HAVE___BRK\n    INIT_XBRK_SYM(__brk);\n#endif\n\n    return inited = 1;\n#undef INIT_XBRK_SYM\n}\n\n#endif /* #elif defined(ERTS_BRK_WRAPPERS_CAN_TRACK_MALLOC) */ /* ----------- */\n\nstatic void\nupdate_heap_size(char *new_end)\n{\n    volatile char *new_start, *old_start, *old_end;\n    Uint size;\n\n    if (new_end == ((char *) -1))\n\treturn;\n\n    new_start = (old_start = heap_start);\n    old_end = heap_end;\n    heap_end = new_end;\n    if (new_end < old_start || !old_start)\n\theap_start = (new_start = new_end);\n\n    size = (Uint) (new_end - new_start);\n\n    if (!old_end) {\n\tif (size)\n\t    erts_mtrace_crr_alloc((void *) new_start,\n\t\t\t\t  ERTS_ALC_A_SYSTEM,\n\t\t\t\t  ERTS_MTRACE_SEGMENT_ID,\n\t\t\t\t  size);\n\telse\n\t    heap_end = NULL;\n    }\n    else {\n\tif (old_end != new_end || old_start != new_start) {\n\n\t    if (size)\n\t\terts_mtrace_crr_realloc((void *) new_start,\n\t\t\t\t\tERTS_ALC_A_SYSTEM,\n\t\t\t\t\tERTS_MTRACE_SEGMENT_ID,\n\t\t\t\t\t(void *) old_start,\n\t\t\t\t\tsize);\n\t    else {\n\t\tif (old_start)\n\t\t    erts_mtrace_crr_free(ERTS_ALC_A_SYSTEM,\n\t\t\t\t\t ERTS_MTRACE_SEGMENT_ID,\n\t\t\t\t\t (void *) old_start);\n\t\theap_end = NULL;\n\t    }\n\t}\n    }\n}\n\n#endif /* #ifdef ERTS_CAN_TRACK_MALLOC */\n\nvoid\nerts_mtrace_update_heap_size(void)\n{\n#ifdef ERTS_CAN_TRACK_MALLOC\n    if (erts_mtrace_enabled && (inited || init()))\n\tupdate_heap_size((char *) SBRK_0);\n#endif\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/sys/unix/erl_unix_sys_ddll.c": "/*\n * %CopyrightBegin%\n * \n * Copyright Ericsson AB 2006-2016. All Rights Reserved.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * \n * %CopyrightEnd%\n */\n\n/* \n * Interface functions to the dynamic linker using dl* functions.\n * (As far as I know it works on SunOS 4, 5, Linux and FreeBSD. /Seb) \n */\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#include \"sys.h\"\n#include \"erl_vm.h\"\n#include \"global.h\"\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n\n/* some systems do not have RTLD_NOW defined, and require the \"mode\"\n * argument to dload() always be 1.\n */\n#ifndef RTLD_NOW\n#  define RTLD_NOW 1\n#endif\n\n#define MAX_NAME_LEN 255      /* XXX should we get the system path size? */\n#define EXT_LEN      3\n#define FILE_EXT     \".so\"    /* extension appended to the filename */\n\nstatic char **errcodes = NULL;\nstatic int num_errcodes = 0;\nstatic int num_errcodes_allocated = 0;\n\n#define my_strdup(WHAT) my_strdup_in(ERTS_ALC_T_DDLL_ERRCODES, WHAT);\n\nstatic char *my_strdup_in(ErtsAlcType_t type, char *what)\n{\n    char *res = erts_alloc(type, strlen(what) + 1);\n    strcpy(res, what);\n    return res;\n}\n\n\nstatic int find_errcode(char *string, ErtsSysDdllError* err) \n{\n    int i;\n\n    if (err != NULL) {\n\terts_sys_ddll_free_error(err); /* in case we ignored an earlier error */\n\terr->str = my_strdup_in(ERTS_ALC_T_DDLL_TMP_BUF, string);\n\treturn 0;\n    }\n    for(i=0;i<num_errcodes;++i) {\n\tif (!strcmp(string, errcodes[i])) {\n\t    return i;\n\t}\n    }\n    if (num_errcodes_allocated == num_errcodes) {\n\terrcodes = (num_errcodes_allocated == 0) \n\t    ? erts_alloc(ERTS_ALC_T_DDLL_ERRCODES, \n\t\t\t (num_errcodes_allocated = 10) * sizeof(char *)) \n\t    : erts_realloc(ERTS_ALC_T_DDLL_ERRCODES, errcodes,\n\t\t\t   (num_errcodes_allocated += 10) * sizeof(char *));\n    }\n    errcodes[num_errcodes++] = my_strdup(string);\n    return (num_errcodes - 1);\n}\n\nvoid erl_sys_ddll_init(void) {\n#if defined(HAVE_DLOPEN) && defined(ERTS_NEED_DLOPEN_BEFORE_DLERROR)\n    /*\n     * dlopen() needs to be called before we make the first call to\n     * dlerror(); otherwise, dlerror() might dump core. At least\n     * some versions of linuxthread suffer from this bug.\n     */\n    void *handle = dlopen(\"/nonexistinglib\", RTLD_NOW);\n    if (handle)\n\tdlclose(handle);\n#endif    \n    return;\n}\n\n/* \n * Open a shared object\n */\nint erts_sys_ddll_open(const char *full_name, void **handle, ErtsSysDdllError* err)\n{\n#if defined(HAVE_DLOPEN)\n    char* dlname; \n    int len = sys_strlen(full_name);\n    int ret;\n    \n    dlname = erts_alloc(ERTS_ALC_T_TMP, len + EXT_LEN + 1);\n    sys_strcpy(dlname, full_name);\n    sys_strcpy(dlname+len, FILE_EXT);\n    \n    ret = erts_sys_ddll_open_noext(dlname, handle, err);\n\n    erts_free(ERTS_ALC_T_TMP, (void *) dlname);\n    return ret;\n#else\n    return ERL_DE_ERROR_NO_DDLL_FUNCTIONALITY;\n#endif\n}\n\nint erts_sys_ddll_open_noext(char *dlname, void **handle, ErtsSysDdllError* err)\n{\n#if defined(HAVE_DLOPEN)   \n    int ret = ERL_DE_NO_ERROR;\n    char *str;\n    dlerror();\n    if ((*handle = dlopen(dlname, RTLD_NOW)) == NULL) {\n\tstr = dlerror();\n\n\tif (err == NULL) {\n\t    /*\n\t     * Remove prefix filename to avoid exploading number of\n\t     * error codes on extreme usage.\n\t     */\n\t    if (strstr(str,dlname) == str) {\n\t\tchar *save_str = str;\n\t\tstr += strlen(dlname);\n\t\twhile (*str == ':' || *str == ' ') {\n\t\t    ++str;\n\t\t}\n\t\tif (*str == '\\0') { /* Better with filename than nothing... */\n\t\t    str = save_str;\n\t\t}\n\t    }\n\t}\n\tret = ERL_DE_DYNAMIC_ERROR_OFFSET - find_errcode(str, err);\n    }\n    return ret;\n#else\n    return ERL_DE_ERROR_NO_DDLL_FUNCTIONALITY;\n#endif\n}\n\n/* \n * Find a symbol in the shared object\n */\nint erts_sys_ddll_sym2(void *handle, const char *func_name, void **function,\n\t\t       ErtsSysDdllError* err)\n{\n#if defined(HAVE_DLOPEN)\n    void *sym;\n    char *e;\n    int ret;\n    dlerror();\n    sym = dlsym(handle, func_name);\n    if ((e = dlerror()) != NULL) {\n\tret = ERL_DE_DYNAMIC_ERROR_OFFSET - find_errcode(e, err);\n    } else {\n\t*function = sym;\n\tret = ERL_DE_NO_ERROR;\n    }\n    return ret;\n#else\n    return ERL_DE_ERROR_NO_DDLL_FUNCTIONALITY;\n#endif\n}\n\n/* XXX:PaN These two will be changed with new driver interface! */\n\n/* \n * Load the driver init function, might appear under different names depending on object arch... \n */\n\nint erts_sys_ddll_load_driver_init(void *handle, void **function)\n{\n    void *fn;\n    int res;\n    if ((res = erts_sys_ddll_sym2(handle, \"driver_init\", &fn, NULL)) != ERL_DE_NO_ERROR) {\n\tres = erts_sys_ddll_sym2(handle, \"_driver_init\", &fn, NULL);\n    }\n    if (res == ERL_DE_NO_ERROR) {\n\t*function = fn;\n    }\n    return res;\n}\n\nint erts_sys_ddll_load_nif_init(void *handle, void **function, ErtsSysDdllError* err)\n{\n    void *fn;\n    int res;\n    if ((res = erts_sys_ddll_sym2(handle, \"nif_init\", &fn, err)) != ERL_DE_NO_ERROR) {\n\tres = erts_sys_ddll_sym2(handle, \"_nif_init\", &fn, err);\n    }\n    if (res == ERL_DE_NO_ERROR) {\n\t*function = fn;\n    }\n    return res;\n}\n\n/* \n * Call the driver_init function, whatever it's really called, simple on unix... \n*/\nvoid *erts_sys_ddll_call_init(void *function) {\n    void *(*initfn)(void) = function;\n    return (*initfn)();\n}\nvoid *erts_sys_ddll_call_nif_init(void *function) {\n    return erts_sys_ddll_call_init(function);\n}\n\n\n\n/* \n * Close a chared object\n */\nint erts_sys_ddll_close2(void *handle, ErtsSysDdllError* err)\n{\n#if defined(HAVE_DLOPEN)\n    int ret;\n    char *s;\n    dlerror();\n    if (dlclose(handle) == 0) {\n\tret = ERL_DE_NO_ERROR;\n    } else {\n\tif ((s = dlerror()) == NULL) {\n\t    find_errcode(\"unspecified error\", err);\n\t    ret = ERL_DE_ERROR_UNSPECIFIED;\n\t} else {\n\t    ret = ERL_DE_DYNAMIC_ERROR_OFFSET - find_errcode(s, err);\n\t}\n    }\n    return ret;\n#else\n    return ERL_DE_ERROR_NO_DDLL_FUNCTIONALITY;\n#endif\n}\n\n\n/*\n * Return string that describes the (current) error\n */\nchar *erts_sys_ddll_error(int code)\n{\n    int actual_code;\n\n    if (code > ERL_DE_DYNAMIC_ERROR_OFFSET) {\n\treturn \"Unspecified error\";\n    }\n    actual_code = -1*(code - ERL_DE_DYNAMIC_ERROR_OFFSET);\n#if defined(HAVE_DLOPEN)\n    {\n\tchar *msg;\n\n\tif (actual_code >= num_errcodes) {\n\t    msg = \"Unknown dlload error\";\n\t} else {\n\t    msg = errcodes[actual_code];\n\t}\n\treturn msg;\n    }\n#endif\n    return \"no error\";\n}\n\nvoid erts_sys_ddll_free_error(ErtsSysDdllError* err)\n{   \n    if (err->str != NULL) {\n\terts_free(ERTS_ALC_T_DDLL_TMP_BUF, err->str);\n    }\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/test/nif_SUITE_data/nif_api_2_4/erl_nif_api_funcs.h": "/*\n * %CopyrightBegin%\n *\n * Copyright Ericsson AB 2009-2017. All Rights Reserved.\n *\n * The contents of this file are subject to the Erlang Public License,\n * Version 1.1, (the \"License\"); you may not use this file except in\n * compliance with the License. You should have received a copy of the\n * Erlang Public License along with this software. If not, it can be\n * retrieved online at http://www.erlang.org/.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See\n * the License for the specific language governing rights and limitations\n * under the License.\n *\n * %CopyrightEnd%\n */\n\n#if !defined(ERL_NIF_API_FUNC_DECL) && !defined(ERL_NIF_API_FUNC_MACRO)\n#  error This file should not be included directly\n#endif\n\n/*\n** WARNING: add new ERL_NIF_API_FUNC_DECL entries at the bottom of the list\n** to keep compatibility on Windows!!!\n**\n** And don't forget to increase ERL_NIF_MINOR_VERSION in erl_nif.h\n** when adding functions to the API.\n*/\n#ifdef ERL_NIF_API_FUNC_DECL\nERL_NIF_API_FUNC_DECL(void*,enif_priv_data,(ErlNifEnv*));\nERL_NIF_API_FUNC_DECL(void*,enif_alloc,(size_t size));\nERL_NIF_API_FUNC_DECL(void,enif_free,(void* ptr));\nERL_NIF_API_FUNC_DECL(int,enif_is_atom,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_is_binary,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_is_ref,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_inspect_binary,(ErlNifEnv*, ERL_NIF_TERM bin_term, ErlNifBinary* bin));\nERL_NIF_API_FUNC_DECL(int,enif_alloc_binary,(size_t size, ErlNifBinary* bin));\nERL_NIF_API_FUNC_DECL(int,enif_realloc_binary,(ErlNifBinary* bin, size_t size));\nERL_NIF_API_FUNC_DECL(void,enif_release_binary,(ErlNifBinary* bin));\nERL_NIF_API_FUNC_DECL(int,enif_get_int,(ErlNifEnv*, ERL_NIF_TERM term, int* ip));\nERL_NIF_API_FUNC_DECL(int,enif_get_ulong,(ErlNifEnv*, ERL_NIF_TERM term, unsigned long* ip));\nERL_NIF_API_FUNC_DECL(int,enif_get_double,(ErlNifEnv*, ERL_NIF_TERM term, double* dp));\nERL_NIF_API_FUNC_DECL(int,enif_get_list_cell,(ErlNifEnv* env, ERL_NIF_TERM term, ERL_NIF_TERM* head, ERL_NIF_TERM* tail));\nERL_NIF_API_FUNC_DECL(int,enif_get_tuple,(ErlNifEnv* env, ERL_NIF_TERM tpl, int* arity, const ERL_NIF_TERM** array));\nERL_NIF_API_FUNC_DECL(int,enif_is_identical,(ERL_NIF_TERM lhs, ERL_NIF_TERM rhs));\nERL_NIF_API_FUNC_DECL(int,enif_compare,(ERL_NIF_TERM lhs, ERL_NIF_TERM rhs));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_binary,(ErlNifEnv* env, ErlNifBinary* bin));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_badarg,(ErlNifEnv* env));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_int,(ErlNifEnv* env, int i));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_ulong,(ErlNifEnv* env, unsigned long i));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_double,(ErlNifEnv* env, double d));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_atom,(ErlNifEnv* env, const char* name));\nERL_NIF_API_FUNC_DECL(int,enif_make_existing_atom,(ErlNifEnv* env, const char* name, ERL_NIF_TERM* atom, ErlNifCharEncoding));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_tuple,(ErlNifEnv* env, unsigned cnt, ...));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_list,(ErlNifEnv* env, unsigned cnt, ...));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_list_cell,(ErlNifEnv* env, ERL_NIF_TERM car, ERL_NIF_TERM cdr));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_string,(ErlNifEnv* env, const char* string, ErlNifCharEncoding));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_ref,(ErlNifEnv* env));\n\nERL_NIF_API_FUNC_DECL(ErlNifMutex*,enif_mutex_create,(char *name));\nERL_NIF_API_FUNC_DECL(void,enif_mutex_destroy,(ErlNifMutex *mtx));\nERL_NIF_API_FUNC_DECL(int,enif_mutex_trylock,(ErlNifMutex *mtx));\nERL_NIF_API_FUNC_DECL(void,enif_mutex_lock,(ErlNifMutex *mtx));\nERL_NIF_API_FUNC_DECL(void,enif_mutex_unlock,(ErlNifMutex *mtx));\nERL_NIF_API_FUNC_DECL(ErlNifCond*,enif_cond_create,(char *name));\nERL_NIF_API_FUNC_DECL(void,enif_cond_destroy,(ErlNifCond *cnd));\nERL_NIF_API_FUNC_DECL(void,enif_cond_signal,(ErlNifCond *cnd));\nERL_NIF_API_FUNC_DECL(void,enif_cond_broadcast,(ErlNifCond *cnd));\nERL_NIF_API_FUNC_DECL(void,enif_cond_wait,(ErlNifCond *cnd, ErlNifMutex *mtx));\nERL_NIF_API_FUNC_DECL(ErlNifRWLock*,enif_rwlock_create,(char *name));\nERL_NIF_API_FUNC_DECL(void,enif_rwlock_destroy,(ErlNifRWLock *rwlck));\nERL_NIF_API_FUNC_DECL(int,enif_rwlock_tryrlock,(ErlNifRWLock *rwlck));\nERL_NIF_API_FUNC_DECL(void,enif_rwlock_rlock,(ErlNifRWLock *rwlck));\nERL_NIF_API_FUNC_DECL(void,enif_rwlock_runlock,(ErlNifRWLock *rwlck));\nERL_NIF_API_FUNC_DECL(int,enif_rwlock_tryrwlock,(ErlNifRWLock *rwlck));\nERL_NIF_API_FUNC_DECL(void,enif_rwlock_rwlock,(ErlNifRWLock *rwlck));\nERL_NIF_API_FUNC_DECL(void,enif_rwlock_rwunlock,(ErlNifRWLock *rwlck));\nERL_NIF_API_FUNC_DECL(int,enif_tsd_key_create,(char *name, ErlNifTSDKey *key));\nERL_NIF_API_FUNC_DECL(void,enif_tsd_key_destroy,(ErlNifTSDKey key));\nERL_NIF_API_FUNC_DECL(void,enif_tsd_set,(ErlNifTSDKey key, void *data));\nERL_NIF_API_FUNC_DECL(void*,enif_tsd_get,(ErlNifTSDKey key));\nERL_NIF_API_FUNC_DECL(ErlNifThreadOpts*,enif_thread_opts_create,(char *name));\nERL_NIF_API_FUNC_DECL(void,enif_thread_opts_destroy,(ErlNifThreadOpts *opts));\nERL_NIF_API_FUNC_DECL(int,enif_thread_create,(char *name,ErlNifTid *tid,void * (*func)(void *),void *args,ErlNifThreadOpts *opts));\nERL_NIF_API_FUNC_DECL(ErlNifTid,enif_thread_self,(void));\nERL_NIF_API_FUNC_DECL(int,enif_equal_tids,(ErlNifTid tid1, ErlNifTid tid2));\nERL_NIF_API_FUNC_DECL(void,enif_thread_exit,(void *resp));\nERL_NIF_API_FUNC_DECL(int,enif_thread_join,(ErlNifTid, void **respp));\n\nERL_NIF_API_FUNC_DECL(void*,enif_realloc,(void* ptr, size_t size));\nERL_NIF_API_FUNC_DECL(void,enif_system_info,(ErlNifSysInfo *sip, size_t si_size));\nERL_NIF_API_FUNC_DECL(int,enif_fprintf,(void/* FILE* */ *filep, const char *format, ...));\nERL_NIF_API_FUNC_DECL(int,enif_inspect_iolist_as_binary,(ErlNifEnv*, ERL_NIF_TERM term, ErlNifBinary* bin));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_sub_binary,(ErlNifEnv*, ERL_NIF_TERM bin_term, size_t pos, size_t size));\nERL_NIF_API_FUNC_DECL(int,enif_get_string,(ErlNifEnv*, ERL_NIF_TERM list, char* buf, unsigned len, ErlNifCharEncoding));\nERL_NIF_API_FUNC_DECL(int,enif_get_atom,(ErlNifEnv*, ERL_NIF_TERM atom, char* buf, unsigned len, ErlNifCharEncoding));\nERL_NIF_API_FUNC_DECL(int,enif_is_fun,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_is_pid,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_is_port,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_get_uint,(ErlNifEnv*, ERL_NIF_TERM term, unsigned* ip));\nERL_NIF_API_FUNC_DECL(int,enif_get_long,(ErlNifEnv*, ERL_NIF_TERM term, long* ip));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_uint,(ErlNifEnv*, unsigned i));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_long,(ErlNifEnv*, long i));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_tuple_from_array,(ErlNifEnv*, const ERL_NIF_TERM arr[], unsigned cnt));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_list_from_array,(ErlNifEnv*, const ERL_NIF_TERM arr[], unsigned cnt));\nERL_NIF_API_FUNC_DECL(int,enif_is_empty_list,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(ErlNifResourceType*,enif_open_resource_type,(ErlNifEnv*, const char* module_str, const char* name_str, void (*dtor)(ErlNifEnv*,void *), ErlNifResourceFlags flags, ErlNifResourceFlags* tried));\nERL_NIF_API_FUNC_DECL(void*,enif_alloc_resource,(ErlNifResourceType* type, size_t size));\nERL_NIF_API_FUNC_DECL(void,enif_release_resource,(void* obj));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_resource,(ErlNifEnv*, void* obj));\nERL_NIF_API_FUNC_DECL(int,enif_get_resource,(ErlNifEnv*, ERL_NIF_TERM term, ErlNifResourceType* type, void** objp));\nERL_NIF_API_FUNC_DECL(size_t,enif_sizeof_resource,(void* obj));\nERL_NIF_API_FUNC_DECL(unsigned char*,enif_make_new_binary,(ErlNifEnv*,size_t size,ERL_NIF_TERM* termp));\nERL_NIF_API_FUNC_DECL(int,enif_is_list,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_is_tuple,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_get_atom_length,(ErlNifEnv*, ERL_NIF_TERM atom, unsigned* len, ErlNifCharEncoding));\nERL_NIF_API_FUNC_DECL(int,enif_get_list_length,(ErlNifEnv* env, ERL_NIF_TERM term, unsigned* len));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM, enif_make_atom_len,(ErlNifEnv* env, const char* name, size_t len));\nERL_NIF_API_FUNC_DECL(int, enif_make_existing_atom_len,(ErlNifEnv* env, const char* name, size_t len, ERL_NIF_TERM* atom, ErlNifCharEncoding));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_string_len,(ErlNifEnv* env, const char* string, size_t len, ErlNifCharEncoding));\nERL_NIF_API_FUNC_DECL(ErlNifEnv*,enif_alloc_env,(void));\nERL_NIF_API_FUNC_DECL(void,enif_free_env,(ErlNifEnv* env));\nERL_NIF_API_FUNC_DECL(void,enif_clear_env,(ErlNifEnv* env));\nERL_NIF_API_FUNC_DECL(int,enif_send,(ErlNifEnv* env, const ErlNifPid* to_pid, ErlNifEnv* msg_env, ERL_NIF_TERM msg));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_copy,(ErlNifEnv* dst_env, ERL_NIF_TERM src_term));\nERL_NIF_API_FUNC_DECL(ErlNifPid*,enif_self,(ErlNifEnv* caller_env, ErlNifPid* pid));\nERL_NIF_API_FUNC_DECL(int,enif_get_local_pid,(ErlNifEnv* env, ERL_NIF_TERM, ErlNifPid* pid));\nERL_NIF_API_FUNC_DECL(void,enif_keep_resource,(void* obj));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_resource_binary,(ErlNifEnv*,void* obj,const void* data, size_t size));\n#if SIZEOF_LONG != 8\nERL_NIF_API_FUNC_DECL(int,enif_get_int64,(ErlNifEnv*, ERL_NIF_TERM term, ErlNifSInt64* ip));\nERL_NIF_API_FUNC_DECL(int,enif_get_uint64,(ErlNifEnv*, ERL_NIF_TERM term, ErlNifUInt64* ip));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_int64,(ErlNifEnv*, ErlNifSInt64));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_uint64,(ErlNifEnv*, ErlNifUInt64));\n#endif\nERL_NIF_API_FUNC_DECL(int,enif_is_exception,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_make_reverse_list,(ErlNifEnv*, ERL_NIF_TERM term, ERL_NIF_TERM *list));\nERL_NIF_API_FUNC_DECL(int,enif_is_number,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(void*,enif_dlopen,(const char* lib, void (*err_handler)(void*,const char*), void* err_arg));\nERL_NIF_API_FUNC_DECL(void*,enif_dlsym,(void* handle, const char* symbol, void (*err_handler)(void*,const char*), void* err_arg));\nERL_NIF_API_FUNC_DECL(int,enif_consume_timeslice,(ErlNifEnv*, int percent));\n\n/*\n** Add new entries here to keep compatibility on Windows!!!\n*/\n#endif\n\n/*\n** Please keep the ERL_NIF_API_FUNC_MACRO list below in the same order\n** as the ERL_NIF_API_FUNC_DECL list above\n*/\n#ifdef ERL_NIF_API_FUNC_MACRO\n#  define enif_priv_data ERL_NIF_API_FUNC_MACRO(enif_priv_data)\n#  define enif_alloc ERL_NIF_API_FUNC_MACRO(enif_alloc)\n#  define enif_free ERL_NIF_API_FUNC_MACRO(enif_free)\n#  define enif_is_atom ERL_NIF_API_FUNC_MACRO(enif_is_atom)\n#  define enif_is_binary ERL_NIF_API_FUNC_MACRO(enif_is_binary)\n#  define enif_is_ref ERL_NIF_API_FUNC_MACRO(enif_is_ref)\n#  define enif_inspect_binary ERL_NIF_API_FUNC_MACRO(enif_inspect_binary)\n#  define enif_alloc_binary ERL_NIF_API_FUNC_MACRO(enif_alloc_binary)\n#  define enif_realloc_binary ERL_NIF_API_FUNC_MACRO(enif_realloc_binary)\n#  define enif_release_binary ERL_NIF_API_FUNC_MACRO(enif_release_binary)\n#  define enif_get_int ERL_NIF_API_FUNC_MACRO(enif_get_int)\n#  define enif_get_ulong ERL_NIF_API_FUNC_MACRO(enif_get_ulong)\n#  define enif_get_double ERL_NIF_API_FUNC_MACRO(enif_get_double)\n#  define enif_get_tuple ERL_NIF_API_FUNC_MACRO(enif_get_tuple)\n#  define enif_get_list_cell ERL_NIF_API_FUNC_MACRO(enif_get_list_cell)\n#  define enif_is_identical ERL_NIF_API_FUNC_MACRO(enif_is_identical)\n#  define enif_compare ERL_NIF_API_FUNC_MACRO(enif_compare)\n\n#  define enif_make_binary ERL_NIF_API_FUNC_MACRO(enif_make_binary)\n#  define enif_make_badarg ERL_NIF_API_FUNC_MACRO(enif_make_badarg)\n#  define enif_make_int ERL_NIF_API_FUNC_MACRO(enif_make_int)\n#  define enif_make_ulong ERL_NIF_API_FUNC_MACRO(enif_make_ulong)\n#  define enif_make_double ERL_NIF_API_FUNC_MACRO(enif_make_double)\n#  define enif_make_atom ERL_NIF_API_FUNC_MACRO(enif_make_atom)\n#  define enif_make_existing_atom ERL_NIF_API_FUNC_MACRO(enif_make_existing_atom)\n#  define enif_make_tuple ERL_NIF_API_FUNC_MACRO(enif_make_tuple)\n#  define enif_make_list ERL_NIF_API_FUNC_MACRO(enif_make_list)\n#  define enif_make_list_cell ERL_NIF_API_FUNC_MACRO(enif_make_list_cell)\n#  define enif_make_string ERL_NIF_API_FUNC_MACRO(enif_make_string)\n#  define enif_make_ref ERL_NIF_API_FUNC_MACRO(enif_make_ref)\n\n#  define enif_mutex_create ERL_NIF_API_FUNC_MACRO(enif_mutex_create) \n#  define enif_mutex_destroy ERL_NIF_API_FUNC_MACRO(enif_mutex_destroy) \n#  define enif_mutex_trylock ERL_NIF_API_FUNC_MACRO(enif_mutex_trylock) \n#  define enif_mutex_lock ERL_NIF_API_FUNC_MACRO(enif_mutex_lock) \n#  define enif_mutex_unlock ERL_NIF_API_FUNC_MACRO(enif_mutex_unlock) \n#  define enif_cond_create ERL_NIF_API_FUNC_MACRO(enif_cond_create) \n#  define enif_cond_destroy ERL_NIF_API_FUNC_MACRO(enif_cond_destroy) \n#  define enif_cond_signal ERL_NIF_API_FUNC_MACRO(enif_cond_signal) \n#  define enif_cond_broadcast ERL_NIF_API_FUNC_MACRO(enif_cond_broadcast) \n#  define enif_cond_wait ERL_NIF_API_FUNC_MACRO(enif_cond_wait) \n#  define enif_rwlock_create ERL_NIF_API_FUNC_MACRO(enif_rwlock_create) \n#  define enif_rwlock_destroy ERL_NIF_API_FUNC_MACRO(enif_rwlock_destroy) \n#  define enif_rwlock_tryrlock ERL_NIF_API_FUNC_MACRO(enif_rwlock_tryrlock) \n#  define enif_rwlock_rlock ERL_NIF_API_FUNC_MACRO(enif_rwlock_rlock) \n#  define enif_rwlock_runlock ERL_NIF_API_FUNC_MACRO(enif_rwlock_runlock) \n#  define enif_rwlock_tryrwlock ERL_NIF_API_FUNC_MACRO(enif_rwlock_tryrwlock) \n#  define enif_rwlock_rwlock ERL_NIF_API_FUNC_MACRO(enif_rwlock_rwlock) \n#  define enif_rwlock_rwunlock ERL_NIF_API_FUNC_MACRO(enif_rwlock_rwunlock) \n#  define enif_tsd_key_create ERL_NIF_API_FUNC_MACRO(enif_tsd_key_create) \n#  define enif_tsd_key_destroy ERL_NIF_API_FUNC_MACRO(enif_tsd_key_destroy) \n#  define enif_tsd_set ERL_NIF_API_FUNC_MACRO(enif_tsd_set) \n#  define enif_tsd_get ERL_NIF_API_FUNC_MACRO(enif_tsd_get) \n#  define enif_thread_opts_create ERL_NIF_API_FUNC_MACRO(enif_thread_opts_create) \n#  define enif_thread_opts_destroy ERL_NIF_API_FUNC_MACRO(enif_thread_opts_destroy) \n#  define enif_thread_create ERL_NIF_API_FUNC_MACRO(enif_thread_create) \n#  define enif_thread_self ERL_NIF_API_FUNC_MACRO(enif_thread_self) \n#  define enif_equal_tids ERL_NIF_API_FUNC_MACRO(enif_equal_tids) \n#  define enif_thread_exit ERL_NIF_API_FUNC_MACRO(enif_thread_exit) \n#  define enif_thread_join ERL_NIF_API_FUNC_MACRO(enif_thread_join) \n\n#  define enif_realloc ERL_NIF_API_FUNC_MACRO(enif_realloc) \n#  define enif_system_info ERL_NIF_API_FUNC_MACRO(enif_system_info) \n#  define enif_fprintf ERL_NIF_API_FUNC_MACRO(enif_fprintf) \n#  define enif_inspect_iolist_as_binary ERL_NIF_API_FUNC_MACRO(enif_inspect_iolist_as_binary)\n#  define enif_make_sub_binary ERL_NIF_API_FUNC_MACRO(enif_make_sub_binary)\n#  define enif_get_string ERL_NIF_API_FUNC_MACRO(enif_get_string)\n#  define enif_get_atom ERL_NIF_API_FUNC_MACRO(enif_get_atom)\n#  define enif_is_fun ERL_NIF_API_FUNC_MACRO(enif_is_fun)\n#  define enif_is_pid ERL_NIF_API_FUNC_MACRO(enif_is_pid)\n#  define enif_is_port ERL_NIF_API_FUNC_MACRO(enif_is_port)\n#  define enif_get_uint ERL_NIF_API_FUNC_MACRO(enif_get_uint)\n#  define enif_get_long ERL_NIF_API_FUNC_MACRO(enif_get_long)\n#  define enif_make_uint ERL_NIF_API_FUNC_MACRO(enif_make_uint)\n#  define enif_make_long ERL_NIF_API_FUNC_MACRO(enif_make_long)\n#  define enif_make_tuple_from_array ERL_NIF_API_FUNC_MACRO(enif_make_tuple_from_array)\n#  define enif_make_list_from_array ERL_NIF_API_FUNC_MACRO(enif_make_list_from_array)\n#  define enif_is_empty_list ERL_NIF_API_FUNC_MACRO(enif_is_empty_list)\n#  define enif_open_resource_type ERL_NIF_API_FUNC_MACRO(enif_open_resource_type)\n#  define enif_alloc_resource ERL_NIF_API_FUNC_MACRO(enif_alloc_resource)\n#  define enif_release_resource ERL_NIF_API_FUNC_MACRO(enif_release_resource)\n#  define enif_make_resource ERL_NIF_API_FUNC_MACRO(enif_make_resource)\n#  define enif_get_resource ERL_NIF_API_FUNC_MACRO(enif_get_resource)\n#  define enif_sizeof_resource ERL_NIF_API_FUNC_MACRO(enif_sizeof_resource)\n#  define enif_make_new_binary ERL_NIF_API_FUNC_MACRO(enif_make_new_binary)\n#  define enif_is_list ERL_NIF_API_FUNC_MACRO(enif_is_list)\n#  define enif_is_tuple ERL_NIF_API_FUNC_MACRO(enif_is_tuple)\n#  define enif_get_atom_length ERL_NIF_API_FUNC_MACRO(enif_get_atom_length)\n#  define enif_get_list_length ERL_NIF_API_FUNC_MACRO(enif_get_list_length)\n#  define enif_make_atom_len ERL_NIF_API_FUNC_MACRO(enif_make_atom_len)\n#  define enif_make_existing_atom_len ERL_NIF_API_FUNC_MACRO(enif_make_existing_atom_len)\n#  define enif_make_string_len ERL_NIF_API_FUNC_MACRO(enif_make_string_len)\n#  define enif_alloc_env ERL_NIF_API_FUNC_MACRO(enif_alloc_env)\n#  define enif_free_env ERL_NIF_API_FUNC_MACRO(enif_free_env)\n#  define enif_clear_env ERL_NIF_API_FUNC_MACRO(enif_clear_env)\n#  define enif_send ERL_NIF_API_FUNC_MACRO(enif_send)\n#  define enif_make_copy ERL_NIF_API_FUNC_MACRO(enif_make_copy)\n#  define enif_self ERL_NIF_API_FUNC_MACRO(enif_self)\n#  define enif_get_local_pid ERL_NIF_API_FUNC_MACRO(enif_get_local_pid)\n#  define enif_keep_resource ERL_NIF_API_FUNC_MACRO(enif_keep_resource)\n#  define enif_make_resource_binary ERL_NIF_API_FUNC_MACRO(enif_make_resource_binary)\n#if  SIZEOF_LONG != 8\n#  define enif_get_int64 ERL_NIF_API_FUNC_MACRO(enif_get_int64)\n#  define enif_get_uint64 ERL_NIF_API_FUNC_MACRO(enif_get_uint64)\n#  define enif_make_int64 ERL_NIF_API_FUNC_MACRO(enif_make_int64)\n#  define enif_make_uint64 ERL_NIF_API_FUNC_MACRO(enif_make_uint64)\n#endif\n\n#  define enif_is_exception ERL_NIF_API_FUNC_MACRO(enif_is_exception)\n#  define enif_make_reverse_list ERL_NIF_API_FUNC_MACRO(enif_make_reverse_list)\n#  define enif_is_number ERL_NIF_API_FUNC_MACRO(enif_is_number)\n#  define enif_dlopen ERL_NIF_API_FUNC_MACRO(enif_dlopen)\n#  define enif_dlsym ERL_NIF_API_FUNC_MACRO(enif_dlsym)\n#  define enif_consume_timeslice ERL_NIF_API_FUNC_MACRO(enif_consume_timeslice)\n\n/*\n** Add new entries here\n*/\n#endif\n\n\n#if defined(__GNUC__) && !(defined(__WIN32__) || defined(_WIN32) || defined(_WIN32_))\n\n/* Inline functions for compile time type checking of arguments to\n   variadic functions.\n*/\n\n#  define ERL_NIF_INLINE __inline__\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple1(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1)\n{\n    return enif_make_tuple(env, 1, e1);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple2(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2)\n{\n    return enif_make_tuple(env, 2, e1, e2);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple3(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2,\n\t\t\t\t\t\t    ERL_NIF_TERM e3)\n{\n    return enif_make_tuple(env, 3, e1, e2, e3);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple4(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2,\n\t\t\t\t\t\t    ERL_NIF_TERM e3,\n\t\t\t\t\t\t    ERL_NIF_TERM e4)\n{\n    return enif_make_tuple(env, 4, e1, e2, e3, e4);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple5(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2,\n\t\t\t\t\t\t    ERL_NIF_TERM e3,\n\t\t\t\t\t\t    ERL_NIF_TERM e4,\n\t\t\t\t\t\t    ERL_NIF_TERM e5)\n{\n    return enif_make_tuple(env, 5, e1, e2, e3, e4, e5);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple6(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2,\n\t\t\t\t\t\t    ERL_NIF_TERM e3,\n\t\t\t\t\t\t    ERL_NIF_TERM e4,\n\t\t\t\t\t\t    ERL_NIF_TERM e5,\n\t\t\t\t\t\t    ERL_NIF_TERM e6)\n{\n    return enif_make_tuple(env, 6, e1, e2, e3, e4, e5, e6);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple7(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2,\n\t\t\t\t\t\t    ERL_NIF_TERM e3,\n\t\t\t\t\t\t    ERL_NIF_TERM e4,\n\t\t\t\t\t\t    ERL_NIF_TERM e5,\n\t\t\t\t\t\t    ERL_NIF_TERM e6,\n\t\t\t\t\t\t    ERL_NIF_TERM e7)\n{\n    return enif_make_tuple(env, 7, e1, e2, e3, e4, e5, e6, e7);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple8(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2,\n\t\t\t\t\t\t    ERL_NIF_TERM e3,\n\t\t\t\t\t\t    ERL_NIF_TERM e4,\n\t\t\t\t\t\t    ERL_NIF_TERM e5,\n\t\t\t\t\t\t    ERL_NIF_TERM e6,\n\t\t\t\t\t\t    ERL_NIF_TERM e7,\n\t\t\t\t\t\t    ERL_NIF_TERM e8)\n{\n    return enif_make_tuple(env, 8, e1, e2, e3, e4, e5, e6, e7, e8);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple9(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2,\n\t\t\t\t\t\t    ERL_NIF_TERM e3,\n\t\t\t\t\t\t    ERL_NIF_TERM e4,\n\t\t\t\t\t\t    ERL_NIF_TERM e5,\n\t\t\t\t\t\t    ERL_NIF_TERM e6,\n\t\t\t\t\t\t    ERL_NIF_TERM e7,\n\t\t\t\t\t\t    ERL_NIF_TERM e8,\n\t\t\t\t\t\t    ERL_NIF_TERM e9)\n{\n    return enif_make_tuple(env, 9, e1, e2, e3, e4, e5, e6, e7, e8, e9);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list1(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1)\n{\n    return enif_make_list(env, 1, e1);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list2(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2)\n{\n    return enif_make_list(env, 2, e1, e2);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list3(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2,\n\t\t\t\t\t\t   ERL_NIF_TERM e3)\n{\n    return enif_make_list(env, 3, e1, e2, e3);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list4(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2,\n\t\t\t\t\t\t   ERL_NIF_TERM e3,\n\t\t\t\t\t\t   ERL_NIF_TERM e4)\n{\n    return enif_make_list(env, 4, e1, e2, e3, e4);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list5(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2,\n\t\t\t\t\t\t   ERL_NIF_TERM e3,\n\t\t\t\t\t\t   ERL_NIF_TERM e4,\n\t\t\t\t\t\t   ERL_NIF_TERM e5)\n{\n    return enif_make_list(env, 5, e1, e2, e3, e4, e5);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list6(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2,\n\t\t\t\t\t\t   ERL_NIF_TERM e3,\n\t\t\t\t\t\t   ERL_NIF_TERM e4,\n\t\t\t\t\t\t   ERL_NIF_TERM e5,\n\t\t\t\t\t\t   ERL_NIF_TERM e6)\n{\n    return enif_make_list(env, 6, e1, e2, e3, e4, e5, e6);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list7(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2,\n\t\t\t\t\t\t   ERL_NIF_TERM e3,\n\t\t\t\t\t\t   ERL_NIF_TERM e4,\n\t\t\t\t\t\t   ERL_NIF_TERM e5,\n\t\t\t\t\t\t   ERL_NIF_TERM e6,\n\t\t\t\t\t\t   ERL_NIF_TERM e7)\n{\n    return enif_make_list(env, 7, e1, e2, e3, e4, e5, e6, e7);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list8(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2,\n\t\t\t\t\t\t   ERL_NIF_TERM e3,\n\t\t\t\t\t\t   ERL_NIF_TERM e4,\n\t\t\t\t\t\t   ERL_NIF_TERM e5,\n\t\t\t\t\t\t   ERL_NIF_TERM e6,\n\t\t\t\t\t\t   ERL_NIF_TERM e7,\n\t\t\t\t\t\t   ERL_NIF_TERM e8)\n{\n    return enif_make_list(env, 8, e1, e2, e3, e4, e5, e6, e7, e8);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list9(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2,\n\t\t\t\t\t\t   ERL_NIF_TERM e3,\n\t\t\t\t\t\t   ERL_NIF_TERM e4,\n\t\t\t\t\t\t   ERL_NIF_TERM e5,\n\t\t\t\t\t\t   ERL_NIF_TERM e6,\n\t\t\t\t\t\t   ERL_NIF_TERM e7,\n\t\t\t\t\t\t   ERL_NIF_TERM e8,\n\t\t\t\t\t\t   ERL_NIF_TERM e9)\n{\n    return enif_make_list(env, 9, e1, e2, e3, e4, e5, e6, e7, e8, e9);\n}\n\n#  undef ERL_NIF_INLINE\n\n#else /* fallback with macros */\n\n#ifndef enif_make_list1\n#  define enif_make_list1(ENV,E1) enif_make_list(ENV,1,E1)\n#  define enif_make_list2(ENV,E1,E2) enif_make_list(ENV,2,E1,E2)\n#  define enif_make_list3(ENV,E1,E2,E3) enif_make_list(ENV,3,E1,E2,E3)\n#  define enif_make_list4(ENV,E1,E2,E3,E4) enif_make_list(ENV,4,E1,E2,E3,E4)\n#  define enif_make_list5(ENV,E1,E2,E3,E4,E5) enif_make_list(ENV,5,E1,E2,E3,E4,E5)\n#  define enif_make_list6(ENV,E1,E2,E3,E4,E5,E6) enif_make_list(ENV,6,E1,E2,E3,E4,E5,E6)\n#  define enif_make_list7(ENV,E1,E2,E3,E4,E5,E6,E7) enif_make_list(ENV,7,E1,E2,E3,E4,E5,E6,E7)\n#  define enif_make_list8(ENV,E1,E2,E3,E4,E5,E6,E7,E8) enif_make_list(ENV,8,E1,E2,E3,E4,E5,E6,E7,E8)\n#  define enif_make_list9(ENV,E1,E2,E3,E4,E5,E6,E7,E8,E9) enif_make_list(ENV,9,E1,E2,E3,E4,E5,E6,E7,E8,E9)\n#  define enif_make_tuple1(ENV,E1) enif_make_tuple(ENV,1,E1)\n#  define enif_make_tuple2(ENV,E1,E2) enif_make_tuple(ENV,2,E1,E2)\n#  define enif_make_tuple3(ENV,E1,E2,E3) enif_make_tuple(ENV,3,E1,E2,E3)\n#  define enif_make_tuple4(ENV,E1,E2,E3,E4) enif_make_tuple(ENV,4,E1,E2,E3,E4)\n#  define enif_make_tuple5(ENV,E1,E2,E3,E4,E5) enif_make_tuple(ENV,5,E1,E2,E3,E4,E5)\n#  define enif_make_tuple6(ENV,E1,E2,E3,E4,E5,E6) enif_make_tuple(ENV,6,E1,E2,E3,E4,E5,E6)\n#  define enif_make_tuple7(ENV,E1,E2,E3,E4,E5,E6,E7) enif_make_tuple(ENV,7,E1,E2,E3,E4,E5,E6,E7)\n#  define enif_make_tuple8(ENV,E1,E2,E3,E4,E5,E6,E7,E8) enif_make_tuple(ENV,8,E1,E2,E3,E4,E5,E6,E7,E8)\n#  define enif_make_tuple9(ENV,E1,E2,E3,E4,E5,E6,E7,E8,E9) enif_make_tuple(ENV,9,E1,E2,E3,E4,E5,E6,E7,E8,E9)\n#endif\n\n#endif /* __GNUC__ && !WIN32 */\n\n#ifndef enif_make_pid\n\n#  define enif_make_pid(ENV, PID) ((const ERL_NIF_TERM)((PID)->pid))\n\n#if SIZEOF_LONG == 8\n#  define enif_get_int64 enif_get_long\n#  define enif_get_uint64 enif_get_ulong\n#  define enif_make_int64 enif_make_long\n#  define enif_make_uint64 enif_make_ulong\n#endif\n\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/hipe/hipe_x86_signal.c": "/*\n * %CopyrightBegin%\n\n *\n * Copyright Ericsson AB 2001-2017. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * %CopyrightEnd%\n */\n/*\n * hipe_x86_signal.c\n *\n * Erlang code compiled to x86 native code uses the x86 %esp as its\n * stack pointer. This improves performance in several ways:\n * - It permits the use of the x86 call and ret instructions, which\n *   reduces code volume and improves branch prediction.\n * - It avoids stealing a gp register to act as a stack pointer.\n *\n * Unix signal handlers are by default delivered onto the current\n * stack, i.e. %esp. This is a problem since our native-code stacks\n * are small and may not have room for the Unix signal handler.\n *\n * There is a way to redirect signal handlers to an \"alternate\" signal\n * stack by using the SA_ONSTACK flag with the sigaction() library call.\n * Unfortunately, this has to be specified explicitly for each signal,\n * and it is difficult to enforce given the presence of libraries.\n *\n * Our solution is to override the C library's signal handler setup\n * procedure with our own which enforces the SA_ONSTACK flag.\n */\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"sys.h\"\n#include \"erl_alloc.h\"\n#include \"hipe_signal.h\"\n\n#if defined(__GLIBC__) && __GLIBC__ == 2 && (__GLIBC_MINOR__ >= 3)\n/*\n * __libc_sigaction() is the core routine.\n * Without libpthread, sigaction() and __sigaction() are both aliases\n * for __libc_sigaction().\n * libpthread redefines __sigaction() as a non-trivial wrapper around\n * __libc_sigaction(), and makes sigaction() an alias for __sigaction().\n * glibc has internal calls to both sigaction() and __sigaction().\n *\n * Overriding __libc_sigaction() would be ideal, but doing so breaks\n * libpthread (threads hang).\n *\n * Overriding __sigaction(), using dlsym RTLD_NEXT to find glibc's\n * version of __sigaction(), works with glibc-2.2.4 and 2.2.5.\n * Unfortunately, this solution doesn't work with earlier versions,\n * including glibc-2.2.2 and glibc-2.1.92 (2.2 despite its name):\n * 2.2.2 SIGSEGVs in dlsym RTLD_NEXT (known glibc bug), and 2.1.92\n * SIGSEGVs inexplicably in two test cases in the HiPE test suite.\n *\n * Instead we only override sigaction() and call __sigaction()\n * directly. This should work for HiPE/x86 as long as only the Posix\n * signal interface is used, i.e. there are no calls to simulated\n * old BSD or SysV interfaces.\n * glibc's internal calls to __sigaction() appear to be mostly safe.\n * hipe_signal_init() fixes some unsafe ones, e.g. the SIGPROF handler.\n */\n#ifndef __USE_GNU\n#define __USE_GNU\t\t/* to un-hide RTLD_NEXT */\n#endif\n#define NEXT_SIGACTION \"__sigaction\"\n#define LIBC_SIGACTION __sigaction\n#define OVERRIDE_SIGACTION\n#endif\t/* glibc >= 2.3 */\n\n/* Is there no standard identifier for Darwin/MacOSX ? */\n#if defined(__APPLE__) && defined(__MACH__) && !defined(__DARWIN__)\n#define __DARWIN__ 1\n#endif\n\n#if defined(__DARWIN__)\n/*\n * Assumes Mac OS X >= 10.3 (dlsym operations not available in 10.2 and\n * earlier).\n *\n * The code below assumes that is is part of the main image (earlier\n * in the load order than libSystem and certainly before any dylib\n * that might use sigaction) -- a standard RTLD_NEXT caveat.\n *\n * _sigaction lives in /usr/lib/libSystem.B.dylib and can be found\n * with the standard dlsym(RTLD_NEXT) call. The proviso on Mac OS X\n * being that the symbol for dlsym doesn't include a leading '_'.\n *\n * The other _sigaction, _sigaction_no_bind I don't understand the purpose\n * of and don't modify.\n */\n#define NEXT_SIGACTION \"sigaction\"\n#define LIBC_SIGACTION _sigaction\n#undef OVERRIDE_SIGACTION\n#define _NSIG NSIG\n#endif /* __DARWIN__ */\n\n#if defined(__sun__)\n/*\n * Assume Solaris/x86 2.8.\n * There is a number of sigaction() procedures in libc:\n * * sigaction(): weak reference to _sigaction().\n * * _sigaction(): apparently a simple wrapper around __sigaction().\n * * __sigaction(): apparently the procedure doing the actual system call.\n * * _libc_sigaction(): apparently some thread-related wrapper, which ends\n *   up calling __sigaction().\n * The threads library redefines sigaction() and _sigaction() to its\n * own wrapper, which checks for and restricts access to threads-related\n * signals. The wrapper appears to eventually call libc's __sigaction().\n *\n * We catch and override _sigaction() since overriding __sigaction()\n * causes fatal errors in some cases.\n *\n * When linked with thread support, there are calls to sigaction() before\n * our init routine has had a chance to find _sigaction()'s address.\n * This forces us to initialise at the first call.\n */\n#define NEXT_SIGACTION \"_sigaction\"\n#define LIBC_SIGACTION _sigaction\n#define OVERRIDE_SIGACTION\n#define _NSIG NSIG\n#endif /* __sun__ */\n\n#if defined(__FreeBSD__)\n/*\n * This is a copy of Darwin code for FreeBSD.\n * CAVEAT: detailed semantics are not verified yet.\n */\n#define NEXT_SIGACTION \"sigaction\"\n#define LIBC_SIGACTION _sigaction\n#undef OVERRIDE_SIGACTION\n#define _NSIG NSIG\n#endif /* __FreeBSD__ */\n\n#if defined(__NetBSD__)\n/*\n * Note: This is only stub code to allow the build to succeed.\n * Whether this actually provides the needed overrides for safe\n * signal delivery or not is unknown.\n */\n#undef NEXT_SIGACTION\n#undef OVERRIDE_SIGACTION\n#endif /* __NetBSD__ */\n\n#if !(defined(__GLIBC__) || defined(__DARWIN__) || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__sun__))\n/*\n * Unknown libc -- assume musl, which does not allow safe signals\n */\n#error \"HiPE does not work without a libc that can guarantee that sigaltstack works\"\n#endif\t/* !(__GLIBC__ || __DARWIN__ || __NetBSD__ || __FreeBSD__ || __sun__) */\n\n#if defined(NEXT_SIGACTION)\n/*\n * Initialize a function pointer to the libc core sigaction routine,\n * to be used by our wrappers.\n */\n#include <dlfcn.h>\nstatic int (*next_sigaction)(int, const struct sigaction*, struct sigaction*);\nstatic void do_init(void)\n{\n    next_sigaction = dlsym(RTLD_NEXT, NEXT_SIGACTION);\n    if (next_sigaction != 0)\n\treturn;\n    perror(\"dlsym\");\n    abort();\n}\n#define INIT()\tdo { if (!next_sigaction) do_init(); } while (0)\n#else\t/* !defined(NEXT_SIGACTION) */\n#define INIT()\tdo { } while (0)\n#endif\t/* !defined(NEXT_SIGACTION) */\n\n#if defined(NEXT_SIGACTION)\n/*\n * This is our wrapper for sigaction(). sigaction() can be called before\n * hipe_signal_init() has been executed, especially when threads support\n * has been linked with the executable. Therefore, we must initialise\n * next_sigaction() dynamically, the first time it's needed.\n */\nstatic int my_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)\n{\n    struct sigaction newact;\n\n    INIT();\n\n    if (act &&\n\tact->sa_handler != SIG_DFL &&\n\tact->sa_handler != SIG_IGN &&\n\t!(act->sa_flags & SA_ONSTACK)) {\n\tnewact = *act;\n\tnewact.sa_flags |= SA_ONSTACK;\n\tact = &newact;\n    }\n    return next_sigaction(signum, act, oldact);\n}\n#endif\n\n#if defined(LIBC_SIGACTION)\n/*\n * This overrides the C library's core sigaction() procedure, catching\n * all its internal calls.\n */\nextern int LIBC_SIGACTION(int, const struct sigaction*, struct sigaction*);\nint LIBC_SIGACTION(int signum, const struct sigaction *act, struct sigaction *oldact)\n{\n    return my_sigaction(signum, act, oldact);\n}\n#endif\n\n#if defined(OVERRIDE_SIGACTION)\n/*\n * This catches the application's own sigaction() calls.\n */\nint sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)\n{\n    return my_sigaction(signum, act, oldact);\n}\n#endif\n\n/*\n * Set alternate signal stack for the invoking thread.\n */\nstatic void hipe_sigaltstack(void *ss_sp)\n{\n    stack_t ss;\n\n    ss.ss_sp = ss_sp;\n    ss.ss_flags = 0;\n    ss.ss_size = SIGSTKSZ;\n    if (sigaltstack(&ss, NULL) < 0) {\n\tperror(\"sigaltstack\");\n\tabort();\n    }\n}\n\n/*\n * Set up alternate signal stack for an Erlang process scheduler thread.\n */\nvoid hipe_thread_signal_init(void)\n{\n    /* Stack don't really need to be cache aligned.\n       We use it to suppress false leak report from valgrind */\n    hipe_sigaltstack(erts_alloc_permanent_cache_aligned(ERTS_ALC_T_HIPE_LL, SIGSTKSZ));\n}\n\n/*\n * Set up alternate signal stack for the main thread,\n * unless this is a multithreaded runtime system.\n */\nstatic void hipe_sigaltstack_init(void)\n{\n}\n\n/*\n * 1. Set up alternate signal stack for the main thread.\n * 2. Add SA_ONSTACK to existing user-defined signal handlers.\n */\nvoid hipe_signal_init(void)\n{\n    struct sigaction sa;\n    int i;\n\n    INIT();\n\n    hipe_sigaltstack_init();\n\n    for (i = 1; i < _NSIG; ++i) {\n\tif (sigaction(i, NULL, &sa)) {\n\t    /* This will fail with EINVAL on Solaris if 'i' is one of the\n\t       thread library's private signals. We DO catch the initial\n\t       setup of these signals, so things MAY be OK anyway. */\n\t    continue;\n\t}\n\tif (sa.sa_handler == SIG_DFL ||\n\t    sa.sa_handler == SIG_IGN ||\n\t    (sa.sa_flags & SA_ONSTACK))\n\t    continue;\n\tsa.sa_flags |= SA_ONSTACK;\n\tif (sigaction(i, &sa, NULL)) {\n#ifdef SIGCANCEL\n\t    /* Solaris 9 x86 refuses to let us modify SIGCANCEL. */\n\t    if (i == SIGCANCEL)\n\t\tcontinue;\n#endif\n\t    perror(\"sigaction\");\n\t    abort();\n\t}\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/beam/erl_nif.c": "/*\n * %CopyrightBegin%\n *\n * Copyright Ericsson AB 2009-2018. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * %CopyrightEnd%\n */\n/* Erlang Native InterFace\n */\n\n/*\n * Environment contains a pointer to currently executing process.\n * In the dirty case this pointer do however not point to the\n * actual process structure of the executing process, but instead\n * a \"shadow process structure\". This in order to be able to handle\n * heap allocation without the need to acquire the main lock on\n * the process.\n *\n * The dirty process is allowed to allocate on the heap without\n * the main lock, i.e., incrementing htop, but is not allowed to\n * modify mbuf, offheap, etc without the main lock. The dirty\n * process moves mbuf list and offheap list of the shadow process\n * structure into the real structure when the dirty nif call\n * completes.\n */\n\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#include \"erl_nif.h\"\n\n#include \"sys.h\"\n#include \"global.h\"\n#include \"erl_binary.h\"\n#include \"bif.h\"\n#include \"error.h\"\n#include \"big.h\"\n#include \"erl_map.h\"\n#include \"beam_bp.h\"\n#include \"erl_thr_progress.h\"\n#include \"dtrace-wrapper.h\"\n#include \"erl_process.h\"\n#include \"erl_bif_unique.h\"\n#include \"erl_utils.h\"\n#include \"erl_io_queue.h\"\n#include \"erl_proc_sig_queue.h\"\n#undef ERTS_WANT_NFUNC_SCHED_INTERNALS__\n#define ERTS_WANT_NFUNC_SCHED_INTERNALS__\n#include \"erl_nfunc_sched.h\"\n#if defined(USE_DYNAMIC_TRACE) && (defined(USE_DTRACE) || defined(USE_SYSTEMTAP))\n#define HAVE_USE_DTRACE 1\n#endif\n\n#include <limits.h>\n#include <stddef.h> /* offsetof */\n\n/* Information about a loaded nif library.\n * Each successful call to erlang:load_nif will allocate an instance of\n * erl_module_nif. Two calls opening the same library will thus have the same\n * 'handle'.\n */\nstruct erl_module_nif {\n    void* priv_data;\n    void* handle;             /* \"dlopen\" */\n    struct enif_entry_t entry;\n    erts_refc_t rt_cnt;       /* number of resource types */\n    erts_refc_t rt_dtor_cnt;  /* number of resource types with destructors */\n    Module* mod;           /* Can be NULL if orphan with dtor-resources left */ \n\n    ErlNifFunc _funcs_copy_[1];  /* only used for old libs */\n};\n\ntypedef ERL_NIF_TERM (*NativeFunPtr)(ErlNifEnv*, int, const ERL_NIF_TERM[]);\n\n#ifdef DEBUG\n#  define READONLY_CHECK\n#  define ERTS_DBG_NIF_NOT_SCHED_MARKER ((void *) (UWord) 1)\n#endif\n#ifdef READONLY_CHECK\n#  define ADD_READONLY_CHECK(ENV,PTR,SIZE) add_readonly_check(ENV,PTR,SIZE)\nstatic void add_readonly_check(ErlNifEnv*, unsigned char* ptr, unsigned sz);\n#else\n#  define ADD_READONLY_CHECK(ENV,PTR,SIZE) ((void)0)\n#endif\n\n#ifdef ERTS_NIF_ASSERT_IN_ENV\n#  define ASSERT_IN_ENV(ENV, TERM, NR, TYPE) dbg_assert_in_env(ENV, TERM, NR, TYPE, __func__)\nstatic void dbg_assert_in_env(ErlNifEnv*, Eterm term, int nr, const char* type, const char* func);\n#  include \"erl_gc.h\"\n#else\n#  define ASSERT_IN_ENV(ENV, TERM, NR, TYPE)\n#endif\n\n#ifdef DEBUG\nstatic int is_offheap(const ErlOffHeap* off_heap);\n#endif\n\n#ifdef USE_VM_PROBES\nvoid dtrace_nifenv_str(ErlNifEnv *, char *);\n#endif\n\n#define MIN_HEAP_FRAG_SZ 200\nstatic Eterm* alloc_heap_heavy(ErlNifEnv* env, size_t need, Eterm* hp);\n\nstatic ERTS_INLINE int\nis_scheduler(void)\n{\n    ErtsSchedulerData *esdp = erts_get_scheduler_data();\n    if (!esdp)\n\treturn 0;\n    if (ERTS_SCHEDULER_IS_DIRTY(esdp))\n\treturn -1;\n    return 1;\n}\n\nstatic ERTS_INLINE void\nexecution_state(ErlNifEnv *env, Process **c_pp, int *schedp)\n{\n    if (schedp)\n\t*schedp = is_scheduler();\n    if (c_pp) {\n\tif (!env || env->proc->common.id == ERTS_INVALID_PID)\n\t    *c_pp = NULL;\n\telse {\n\t    Process *c_p = env->proc;\n\n\t    if (!(c_p->static_flags & ERTS_STC_FLG_SHADOW_PROC)) {\n\t\tERTS_LC_ASSERT(erts_proc_lc_my_proc_locks(c_p)\n\t\t\t\t   & ERTS_PROC_LOCK_MAIN);\n\t    }\n\t    else {\n\t\tc_p = env->proc->next;\n\t\tASSERT(is_scheduler() < 0);\n\t\tASSERT(c_p && env->proc->common.id == c_p->common.id);\n\t    }\n\n\t    *c_pp = c_p;\n\n\t    ASSERT(!(c_p->static_flags & ERTS_STC_FLG_SHADOW_PROC));\n\t}\n    }\n}\n\nstatic ERTS_INLINE Eterm* alloc_heap(ErlNifEnv* env, size_t need)\n{\n    Eterm* hp = env->hp;\n    env->hp += need;\n    if (env->hp <= env->hp_end) {\n\treturn hp;\n    }\n    return alloc_heap_heavy(env, need, hp);\n}\n\nstatic Eterm* alloc_heap_heavy(ErlNifEnv* env, size_t need, Eterm* hp)\n{\n    env->hp = hp;\n    if (env->heap_frag == NULL) {\n\tASSERT(HEAP_LIMIT(env->proc) == env->hp_end);\n        ASSERT(env->hp + need > env->hp_end);\n\tHEAP_TOP(env->proc) = env->hp;\n    }\n    else {\n\tUint usz = env->hp - env->heap_frag->mem;\n\tenv->proc->mbuf_sz += usz - env->heap_frag->used_size;\n\tenv->heap_frag->used_size = usz;\n\tASSERT(env->heap_frag->used_size <= env->heap_frag->alloc_size);\n    }\n    hp = erts_heap_alloc(env->proc, need, MIN_HEAP_FRAG_SZ);\n    env->heap_frag = MBUF(env->proc);\n    env->hp = hp + need;\n    env->hp_end = env->heap_frag->mem + env->heap_frag->alloc_size;\n\n    return hp;\n}\n\n#if SIZEOF_LONG != ERTS_SIZEOF_ETERM\nstatic ERTS_INLINE void ensure_heap(ErlNifEnv* env, size_t may_need)\n{\n    if (env->hp + may_need > env->hp_end) {\n\talloc_heap_heavy(env, may_need, env->hp);\n\tenv->hp -= may_need;\n    }\n}\n#endif\n\nvoid erts_pre_nif(ErlNifEnv* env, Process* p, struct erl_module_nif* mod_nif,\n                  Process* tracee)\n{\n    env->mod_nif = mod_nif;\n    env->proc = p;\n    env->hp = HEAP_TOP(p);\n    env->hp_end = HEAP_LIMIT(p);\n    env->heap_frag = NULL;\n    env->fpe_was_unmasked = erts_block_fpe();\n    env->tmp_obj_list = NULL;\n    env->exception_thrown = 0;\n    env->tracee = tracee;\n\n    ASSERT(p->common.id != ERTS_INVALID_PID);\n\n#ifdef ERTS_NIF_ASSERT_IN_ENV\n    env->dbg_disable_assert_in_env = 0;\n#endif\n#if defined(DEBUG) && defined(ERTS_DIRTY_SCHEDULERS)\n    {\n\tErtsSchedulerData *esdp = erts_get_scheduler_data();\n\tASSERT(esdp);\n\n\tif (!ERTS_SCHEDULER_IS_DIRTY(esdp)) {\n\t    erts_aint32_t state = erts_atomic32_read_nob(&p->state);\n\n\t    ASSERT(p->scheduler_data == esdp);\n\t    ASSERT((state & (ERTS_PSFLG_RUNNING\n\t\t\t     | ERTS_PSFLG_RUNNING_SYS))\n\t\t   && !(state & (ERTS_PSFLG_DIRTY_RUNNING\n\t\t\t\t | ERTS_PSFLG_DIRTY_RUNNING_SYS)));\n\t}\n    }\n#endif\n}\n\nstatic void full_cache_env(ErlNifEnv *env);\nstatic void cache_env(ErlNifEnv* env);\nstatic void full_flush_env(ErlNifEnv *env);\nstatic void flush_env(ErlNifEnv* env);\n\n/* Temporary object header, auto-deallocated when NIF returns or when\n * independent environment is cleared.\n *\n * The payload can be accessed with &tmp_obj_ptr[1] but keep in mind that its\n * first element must not require greater alignment than `next`. */\nstruct enif_tmp_obj_t {\n    struct enif_tmp_obj_t* next;\n    void (*dtor)(struct enif_tmp_obj_t*);\n    ErtsAlcType_t allocator;\n    /*char data[];*/\n};\n\nstatic ERTS_INLINE void free_tmp_objs(ErlNifEnv* env)\n{\n    while (env->tmp_obj_list != NULL) {\n\tstruct enif_tmp_obj_t* free_me = env->tmp_obj_list;\n\tenv->tmp_obj_list = free_me->next;\n\tfree_me->dtor(free_me);\n    }\n}\n\n/* Whether the given environment is bound to a process and will be cleaned up\n * when the NIF returns. It's safe to use temp_alloc for objects in\n * env->tmp_obj_list when this is true. */\nstatic ERTS_INLINE int is_proc_bound(ErlNifEnv *env)\n{\n    return env->mod_nif != NULL;\n}\n\n/* Allocates and attaches an object to the given environment, running its\n * destructor when the environment is cleared. To avoid temporary variables the\n * address of the allocated object is returned instead of the enif_tmp_obj_t.\n *\n * The destructor *must* call `erts_free(tmp_obj->allocator, tmp_obj)` to free\n * the object. If the destructor needs to refer to the allocated object its\n * address will be &tmp_obj[1]. */\nstatic ERTS_INLINE void *alloc_tmp_obj(ErlNifEnv *env, size_t size,\n                                       void (*dtor)(struct enif_tmp_obj_t*)) {\n    struct enif_tmp_obj_t *tmp_obj;\n    ErtsAlcType_t allocator;\n\n    allocator = is_proc_bound(env) ? ERTS_ALC_T_TMP : ERTS_ALC_T_NIF;\n\n    tmp_obj = erts_alloc(allocator, sizeof(struct enif_tmp_obj_t) + MAX(1, size));\n\n    tmp_obj->next = env->tmp_obj_list;\n    tmp_obj->allocator = allocator;\n    tmp_obj->dtor = dtor;\n\n    env->tmp_obj_list = tmp_obj;\n\n    return (void*)&tmp_obj[1];\n}\n\n/* Generic destructor for objects allocated through alloc_tmp_obj that don't\n * care about their payload. */\nstatic void tmp_alloc_dtor(struct enif_tmp_obj_t *tmp_obj)\n{\n    erts_free(tmp_obj->allocator, tmp_obj);\n}\n\nvoid erts_post_nif(ErlNifEnv* env)\n{\n    erts_unblock_fpe(env->fpe_was_unmasked);\n    full_flush_env(env);\n    free_tmp_objs(env);\n    env->exiting = ERTS_PROC_IS_EXITING(env->proc);\n}\n\n\n/*\n * Initialize a NifExport struct. Create it if needed and store it in the\n * proc. The direct_fp function is what will be invoked by op_call_nif, and\n * the indirect_fp function, if not NULL, is what the direct_fp function\n * will call. If the allocated NifExport isn't enough to hold all of argv,\n * allocate a larger one. Save 'current' and registers if first time this\n * call is scheduled.\n */\n\nstatic ERTS_INLINE ERL_NIF_TERM\nschedule(ErlNifEnv* env, NativeFunPtr direct_fp, NativeFunPtr indirect_fp,\n\t Eterm mod, Eterm func_name, int argc, const ERL_NIF_TERM argv[])\n{\n    NifExport *ep;\n    Process *c_p, *dirty_shadow_proc;\n\n    execution_state(env, &c_p, NULL);\n    if (c_p == env->proc)\n\tdirty_shadow_proc = NULL;\n    else\n\tdirty_shadow_proc = env->proc;\n\n    ERTS_LC_ASSERT(ERTS_PROC_LOCK_MAIN & erts_proc_lc_my_proc_locks(c_p));\n\n    ep = erts_nif_export_schedule(c_p, dirty_shadow_proc,\n\t\t\t\t  c_p->current,\n\t\t\t\t  c_p->cp,\n\t\t\t\t  BeamOpCodeAddr(op_call_nif),\n\t\t\t\t  direct_fp, indirect_fp,\n\t\t\t\t  mod, func_name,\n\t\t\t\t  argc, (const Eterm *) argv);\n    if (!ep->m) {\n\t/* First time this call is scheduled... */\n\terts_refc_inc(&env->mod_nif->rt_dtor_cnt, 1);\n\tep->m = env->mod_nif;\n    }\n    return (ERL_NIF_TERM) THE_NON_VALUE;\n}\n\n\nstatic ERL_NIF_TERM dirty_nif_finalizer(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);\nstatic ERL_NIF_TERM dirty_nif_exception(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);\n\nint\nerts_call_dirty_nif(ErtsSchedulerData *esdp, Process *c_p, BeamInstr *I, Eterm *reg)\n{\n    int exiting;\n    ERL_NIF_TERM *argv = (ERL_NIF_TERM *) reg;\n    NifExport *nep = ERTS_I_BEAM_OP_TO_NIF_EXPORT(I);\n    ErtsCodeMFA *codemfa = erts_code_to_codemfa(I);\n    NativeFunPtr dirty_nif = (NativeFunPtr) I[1];\n    ErlNifEnv env;\n    ERL_NIF_TERM result;\n#ifdef DEBUG\n    erts_aint32_t state = erts_atomic32_read_nob(&c_p->state);\n\n    ASSERT(nep == ERTS_PROC_GET_NIF_TRAP_EXPORT(c_p));\n\n    ASSERT(!c_p->scheduler_data);\n    ASSERT((state & ERTS_PSFLG_DIRTY_RUNNING)\n\t&& !(state & (ERTS_PSFLG_RUNNING|ERTS_PSFLG_RUNNING_SYS)));\n    ASSERT(esdp);\n\n    nep->func = ERTS_DBG_NIF_NOT_SCHED_MARKER;\n#endif\n\n    erts_pre_nif(&env, c_p, nep->m, NULL);\n\n    env.proc = erts_make_dirty_shadow_proc(esdp, c_p);\n\n    env.proc->freason = EXC_NULL;\n    env.proc->fvalue = NIL;\n    env.proc->ftrace = NIL;\n    env.proc->i = c_p->i;\n\n    ASSERT(ERTS_SCHEDULER_IS_DIRTY(erts_proc_sched_data(c_p)));\n\n    erts_atomic32_read_band_mb(&c_p->state, ~(ERTS_PSFLG_DIRTY_CPU_PROC\n\t\t\t\t\t\t   | ERTS_PSFLG_DIRTY_IO_PROC));\n\n    ASSERT(esdp->current_nif == NULL);\n    esdp->current_nif = &env;\n\n    erts_proc_unlock(c_p, ERTS_PROC_LOCK_MAIN);\n\n    result = (*dirty_nif)(&env, codemfa->arity, argv); /* Call dirty NIF */\n\n    erts_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);\n\n    ASSERT(esdp->current_nif == &env);\n    esdp->current_nif = NULL;\n\n    ASSERT(env.proc->static_flags & ERTS_STC_FLG_SHADOW_PROC);\n    ASSERT(env.proc->next == c_p);\n\n    exiting = ERTS_PROC_IS_EXITING(c_p);\n\n    if (!exiting) {\n\tif (env.exception_thrown) {\n\tschedule_exception:\n\t    schedule(&env, dirty_nif_exception, NULL,\n\t\t     am_erts_internal, am_dirty_nif_exception,\n\t\t     1, &env.proc->fvalue);\n\t}\n\telse if (is_value(result)) {\n\t    schedule(&env, dirty_nif_finalizer, NULL,\n\t\t     am_erts_internal, am_dirty_nif_finalizer,\n\t\t     1, &result);\n\t}\n\telse if (env.proc->freason != TRAP) { /* user returned garbage... */\n\t    ERTS_DECL_AM(badreturn);\n\t    (void) enif_raise_exception(&env, AM_badreturn);\n\t    goto schedule_exception;\n\t}\n\telse {\n\t    /* Rescheduled by dirty NIF call... */\n\t    ASSERT(nep->func != ERTS_DBG_NIF_NOT_SCHED_MARKER);\n\t}\n\tc_p->i = env.proc->i;\n\tc_p->arity = env.proc->arity;\n    }\n\n#ifdef DEBUG\n    if (nep->func == ERTS_DBG_NIF_NOT_SCHED_MARKER)\n\tnep->func = NULL;\n#endif\n\n    erts_unblock_fpe(env.fpe_was_unmasked);\n    full_flush_env(&env);\n    free_tmp_objs(&env);\n\n    return exiting;\n}\n\n\nstatic void full_flush_env(ErlNifEnv* env)\n{\n    flush_env(env);\n    if (env->proc->static_flags & ERTS_STC_FLG_SHADOW_PROC)\n\t/* Dirty nif call using shadow process struct */\n\terts_flush_dirty_shadow_proc(env->proc);\n}\n\nstatic void full_cache_env(ErlNifEnv* env)\n{    \n    if (env->proc->static_flags & ERTS_STC_FLG_SHADOW_PROC) {\n\terts_cache_dirty_shadow_proc(env->proc);\n        /*\n         * If shadow proc had heap fragments when flushed\n         * those have now been moved to the real proc.\n         * Ensure heap pointers do not point into a heap\n         * fragment on real proc...\n         */\n        ASSERT(!env->proc->mbuf);\n\tenv->hp_end = HEAP_LIMIT(env->proc);\n\tenv->hp = HEAP_TOP(env->proc);\n    }\n    cache_env(env);\n}\n\n/* Flush out our cached heap pointers to allow an ordinary HAlloc\n*/\nstatic void flush_env(ErlNifEnv* env)\n{\n    if (env->heap_frag == NULL) {\n\tASSERT(env->hp_end == HEAP_LIMIT(env->proc));\n\tASSERT(env->hp >= HEAP_TOP(env->proc));\n\tASSERT(env->hp <= HEAP_LIMIT(env->proc));\t\n\tHEAP_TOP(env->proc) = env->hp;\n    }\n    else {\n\tUint usz;\n\tASSERT(env->hp_end != HEAP_LIMIT(env->proc));\n\tASSERT(env->hp_end - env->hp <= env->heap_frag->alloc_size);\n\tusz = env->hp - env->heap_frag->mem;\n\tenv->proc->mbuf_sz += usz - env->heap_frag->used_size;\n\tenv->heap_frag->used_size = usz;\n\tASSERT(env->heap_frag->used_size <= env->heap_frag->alloc_size);\n    }\n}\n\n/* Restore cached heap pointers to allow alloc_heap again.\n*/\nstatic void cache_env(ErlNifEnv* env)\n{\n    env->heap_frag = MBUF(env->proc);\n    if (env->heap_frag == NULL) {\n\tASSERT(env->hp_end == HEAP_LIMIT(env->proc));\n\tASSERT(env->hp <= HEAP_TOP(env->proc));\n\tASSERT(env->hp <= HEAP_LIMIT(env->proc));\t\n\tenv->hp = HEAP_TOP(env->proc);\n    }\n    else {\n\tenv->hp = env->heap_frag->mem + env->heap_frag->used_size;\n\tenv->hp_end = env->heap_frag->mem + env->heap_frag->alloc_size;\n    }\n}\n\nvoid* enif_priv_data(ErlNifEnv* env)\n{\n    return env->mod_nif->priv_data;\n}\n\nvoid* enif_alloc(size_t size)\n{\n    return erts_alloc_fnf(ERTS_ALC_T_NIF, (Uint) size);\n}\n\nvoid* enif_realloc(void* ptr, size_t size)\n{\n    return erts_realloc_fnf(ERTS_ALC_T_NIF, ptr, size);\n}\n\nvoid enif_free(void* ptr)\n{\n    erts_free(ERTS_ALC_T_NIF, ptr);\n}\n\nstruct enif_msg_environment_t\n{\n    ErlNifEnv env;\n    Process phony_proc;\n};\n\nstatic ERTS_INLINE void\nsetup_nif_env(struct enif_msg_environment_t* msg_env,\n              struct erl_module_nif* mod,\n              Process* tracee)\n{\n    Eterm* phony_heap = (Eterm*) msg_env; /* dummy non-NULL ptr */\n\n    msg_env->env.hp = phony_heap;\n    msg_env->env.hp_end = phony_heap;\n    msg_env->env.heap_frag = NULL;\n    msg_env->env.mod_nif = mod;\n    msg_env->env.tmp_obj_list = NULL;\n    msg_env->env.proc = &msg_env->phony_proc;\n    msg_env->env.exception_thrown = 0;\n    sys_memset(&msg_env->phony_proc, 0, sizeof(Process));\n    HEAP_START(&msg_env->phony_proc) = phony_heap;\n    HEAP_TOP(&msg_env->phony_proc) = phony_heap;\n    HEAP_LIMIT(&msg_env->phony_proc) = phony_heap;\n    HEAP_END(&msg_env->phony_proc) = phony_heap;\n    MBUF(&msg_env->phony_proc) = NULL;\n    msg_env->phony_proc.common.id = ERTS_INVALID_PID;\n    msg_env->env.tracee = tracee;\n\n#ifdef FORCE_HEAP_FRAGS\n    msg_env->phony_proc.space_verified = 0;\n    msg_env->phony_proc.space_verified_from = NULL;\n#endif\n#ifdef ERTS_NIF_ASSERT_IN_ENV\n    msg_env->env.dbg_disable_assert_in_env = 0;\n#endif\n}\n\nErlNifEnv* enif_alloc_env(void)\n{\n    struct enif_msg_environment_t* msg_env =\n\terts_alloc_fnf(ERTS_ALC_T_NIF, sizeof(struct enif_msg_environment_t));\n    setup_nif_env(msg_env, NULL, NULL);\n    return &msg_env->env;\n}\nvoid enif_free_env(ErlNifEnv* env)\n{\n    enif_clear_env(env);\n    erts_free(ERTS_ALC_T_NIF, env);\n}\n\nstatic ERTS_INLINE void pre_nif_noproc(struct enif_msg_environment_t* msg_env,\n                                       struct erl_module_nif* mod,\n                                       Process* tracee)\n{\n    setup_nif_env(msg_env, mod, tracee);\n    msg_env->env.fpe_was_unmasked = erts_block_fpe();\n}\n\nstatic ERTS_INLINE void post_nif_noproc(struct enif_msg_environment_t* msg_env)\n{\n    erts_unblock_fpe(msg_env->env.fpe_was_unmasked);\n    enif_clear_env(&msg_env->env);\n}\n\nstatic ERTS_INLINE void clear_offheap(ErlOffHeap* oh)\n{\n    oh->first = NULL;\n    oh->overhead = 0;\n}\n\nvoid enif_clear_env(ErlNifEnv* env)\n{\n    struct enif_msg_environment_t* menv = (struct enif_msg_environment_t*)env;\n    Process* p = &menv->phony_proc;\n    ASSERT(p == menv->env.proc);\n    ASSERT(p->common.id == ERTS_INVALID_PID);\n    ASSERT(MBUF(p) == menv->env.heap_frag);\n\n    free_tmp_objs(env);\n\n    if (MBUF(p) != NULL) {\n\terts_cleanup_offheap(&MSO(p));\n\tclear_offheap(&MSO(p));\n\tfree_message_buffer(MBUF(p));\n\tMBUF(p) = NULL;\n\tmenv->env.heap_frag = NULL;\n    }\n    ASSERT(HEAP_TOP(p) == HEAP_END(p));\n    menv->env.hp = menv->env.hp_end = HEAP_TOP(p);\n    \n    ASSERT(!is_offheap(&MSO(p)));\n}\n\n#ifdef DEBUG\nstatic int enif_send_delay = 0;\n#define ERTS_FORCE_ENIF_SEND_DELAY() (enif_send_delay++ % 32 == 0)\n#else\n#ifdef ERTS_PROC_LOCK_OWN_IMPL\n#define ERTS_FORCE_ENIF_SEND_DELAY() 0\n#else\n/*\n * We always schedule messages if we do not use our own\n * process lock implementation, as if we try to do a trylock on\n * a lock that might already be locked by the same thread.\n * And what happens then with different mutex implementations\n * is not always guaranteed.\n */\n#define ERTS_FORCE_ENIF_SEND_DELAY() 1\n#endif\n#endif\n\nint erts_flush_trace_messages(Process *c_p, ErtsProcLocks c_p_locks)\n{\n    ErlTraceMessageQueue *msgq, **last_msgq;\n    int reds = 0;\n\n    /* Only one thread at a time is allowed to flush trace messages,\n       so we require the main lock to be held when doing the flush */\n    ERTS_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);\n\n    erts_proc_lock(c_p, ERTS_PROC_LOCK_TRACE);\n\n    msgq = c_p->trace_msg_q;\n\n    if (!msgq)\n        goto error;\n\n    do {\n        Process* rp;\n        ErtsProcLocks rp_locks;\n        ErtsMessage *first, **last;\n        Uint len;\n\n        first = msgq->first;\n        last = msgq->last;\n        len = msgq->len;\n        msgq->first = NULL;\n        msgq->last = &msgq->first;\n        msgq->len = 0;\n        erts_proc_unlock(c_p, ERTS_PROC_LOCK_TRACE);\n\n        ASSERT(len != 0);\n\n        rp = erts_proc_lookup(msgq->receiver);\n        if (rp) {\n            rp_locks = 0;\n            if (rp->common.id == c_p->common.id)\n                rp_locks = c_p_locks;\n            erts_queue_proc_messages(c_p, rp, rp_locks, first, last, len);\n            if (rp->common.id == c_p->common.id)\n                rp_locks &= ~c_p_locks;\n            if (rp_locks)\n                erts_proc_unlock(rp, rp_locks);\n            reds += len;\n        } else {\n            erts_cleanup_messages(first);\n        }\n        reds += 1;\n        erts_proc_lock(c_p, ERTS_PROC_LOCK_TRACE);\n        msgq = msgq->next;\n    } while (msgq);\n\n    last_msgq = &c_p->trace_msg_q;\n\n    while (*last_msgq) {\n        msgq = *last_msgq;\n        if (msgq->len == 0) {\n            *last_msgq = msgq->next;\n            erts_free(ERTS_ALC_T_TRACE_MSG_QUEUE, msgq);\n        } else {\n            last_msgq = &msgq->next;\n        }\n    }\n\nerror:\n    erts_proc_unlock(c_p, ERTS_PROC_LOCK_TRACE);\n\n    return reds;\n}\n\n/** @brief Create a message with the content of process independent \\c msg_env.\n *  Invalidates \\c msg_env.\n */\nErtsMessage* erts_create_message_from_nif_env(ErlNifEnv* msg_env)\n{\n    struct enif_msg_environment_t* menv = (struct enif_msg_environment_t*)msg_env;\n    ErtsMessage* mp;\n\n    flush_env(msg_env);\n    mp = erts_alloc_message(0, NULL);\n    mp->data.heap_frag = menv->env.heap_frag;\n    ASSERT(mp->data.heap_frag == MBUF(&menv->phony_proc));\n    if (mp->data.heap_frag != NULL) {\n        /* Move all offheap's from phony proc to the first fragment.\n           Quick and dirty... */\n        ASSERT(!is_offheap(&mp->data.heap_frag->off_heap));\n        mp->data.heap_frag->off_heap = MSO(&menv->phony_proc);\n        clear_offheap(&MSO(&menv->phony_proc));\n        menv->env.heap_frag = NULL;\n        MBUF(&menv->phony_proc) = NULL;\n    }\n    return mp;\n}\n\nstatic ERTS_INLINE ERL_NIF_TERM make_copy(ErlNifEnv* dst_env,\n                                          ERL_NIF_TERM src_term,\n                                          Uint *cpy_szp)\n{\n    Uint sz;\n    Eterm* hp;\n    /*\n     * No preserved sharing allowed as long as literals are also preserved.\n     * Process independent environment can not be reached by purge.\n     */\n    sz = size_object(src_term);\n    if (cpy_szp)\n        *cpy_szp += sz;\n    hp = alloc_heap(dst_env, sz);\n    return copy_struct(src_term, sz, &hp, &MSO(dst_env->proc));\n}\n\nint enif_send(ErlNifEnv* env, const ErlNifPid* to_pid,\n\t      ErlNifEnv* msg_env, ERL_NIF_TERM msg)\n{\n    struct enif_msg_environment_t* menv = (struct enif_msg_environment_t*)msg_env;\n    ErtsProcLocks rp_locks = 0;\n    ErtsProcLocks lc_locks = 0;\n    Process* rp;\n    Process* c_p;\n    ErtsMessage *mp;\n    Eterm from;\n    Eterm receiver = to_pid->pid;\n    int scheduler;\n    Uint copy_sz = 0;\n\n    execution_state(env, &c_p, &scheduler);\n\n\n    if (scheduler > 0) { /* Normal scheduler */\n\trp = erts_proc_lookup(receiver);\n\tif (!rp)\n\t    return 0;\n    }\n    else {\n\tif (c_p) {\n\t    ASSERT(scheduler < 0); /* Dirty scheduler */\n\t    if (ERTS_PROC_IS_EXITING(c_p))\n\t\treturn 0;\n\n\t    if (env->proc->static_flags & ERTS_STC_FLG_SHADOW_PROC) {\n\t\terts_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);\n\t    }\n\t}\n\n\trp = erts_pid2proc_opt(c_p, ERTS_PROC_LOCK_MAIN,\n\t\t\t       receiver, rp_locks,\n\t\t\t       ERTS_P2P_FLG_INC_REFC);\n\tif (!rp) {\n\t    if (c_p && (env->proc->static_flags & ERTS_STC_FLG_SHADOW_PROC))\n\t\terts_proc_unlock(c_p, ERTS_PROC_LOCK_MAIN);\n\t    return 0;\n\t}\n    }\n\n    if (c_p == rp)\n\trp_locks = ERTS_PROC_LOCK_MAIN;\n\n    if (menv) {\n        Eterm token = c_p ? SEQ_TRACE_TOKEN(c_p) : am_undefined;\n        if (token != NIL && token != am_undefined) {\n            /* This code is copied from erts_send_message */\n            Eterm stoken = SEQ_TRACE_TOKEN(c_p);\n#ifdef USE_VM_PROBES\n            DTRACE_CHARBUF(sender_name, 64);\n            DTRACE_CHARBUF(receiver_name, 64);\n            Sint tok_label = 0;\n            Sint tok_lastcnt = 0;\n            Sint tok_serial = 0;\n            Eterm utag = NIL;\n            *sender_name = *receiver_name = '\\0';\n            if (DTRACE_ENABLED(message_send)) {\n                erts_snprintf(sender_name, sizeof(DTRACE_CHARBUF_NAME(sender_name)),\n                              \"%T\", c_p->common.id);\n                erts_snprintf(receiver_name, sizeof(DTRACE_CHARBUF_NAME(receiver_name)),\n                              \"%T\", rp->common.id);\n            }\n#endif\n            if (have_seqtrace(stoken)) {\n                seq_trace_update_send(c_p);\n                seq_trace_output(stoken, msg, SEQ_TRACE_SEND,\n                                 rp->common.id, c_p);\n            }\n#ifdef USE_VM_PROBES\n            if (!(DT_UTAG_FLAGS(c_p) & DT_UTAG_SPREADING)) {\n                stoken = NIL;\n            }\n#endif\n            token = make_copy(msg_env, stoken, &copy_sz);\n\n#ifdef USE_VM_PROBES\n            if (DT_UTAG_FLAGS(c_p) & DT_UTAG_SPREADING) {\n                if (is_immed(DT_UTAG(c_p)))\n                    utag = DT_UTAG(c_p);\n                else\n                    utag = make_copy(msg_env, DT_UTAG(c_p), &copy_sz);\n            }\n            if (DTRACE_ENABLED(message_send)) {\n                if (have_seqtrace(stoken)) {\n                    tok_label = SEQ_TRACE_T_DTRACE_LABEL(stoken);\n                    tok_lastcnt = signed_val(SEQ_TRACE_T_LASTCNT(stoken));\n                    tok_serial = signed_val(SEQ_TRACE_T_SERIAL(stoken));\n                }\n                DTRACE6(message_send, sender_name, receiver_name,\n                        size_object(msg), tok_label, tok_lastcnt, tok_serial);\n            }\n#endif\n        }\n        mp = erts_create_message_from_nif_env(msg_env);\n        ERL_MESSAGE_TOKEN(mp) = token;\n    } else {\n        erts_literal_area_t litarea;\n\tErlOffHeap *ohp;\n        Eterm *hp;\n        Uint sz;\n        INITIALIZE_LITERAL_PURGE_AREA(litarea);\n        sz = size_object_litopt(msg, &litarea);\n        copy_sz += sz;\n\tif (c_p && !env->tracee) {\n\t    full_flush_env(env);\n\t    mp = erts_alloc_message_heap(rp, &rp_locks, sz, &hp, &ohp);\n\t    full_cache_env(env);\n\t}\n\telse {\n\t    erts_aint_t state = erts_atomic32_read_nob(&rp->state);\n\t    if (state & ERTS_PSFLG_OFF_HEAP_MSGQ) {\n\t\tmp = erts_alloc_message(sz, &hp);\n\t\tohp = sz == 0 ? NULL : &mp->hfrag.off_heap;\n\t    }\n\t    else {\n\t\tErlHeapFragment *bp = new_message_buffer(sz);\n\t\tmp = erts_alloc_message(0, NULL);\n\t\tmp->data.heap_frag = bp;\n\t\thp = bp->mem;\n\t\tohp = &bp->off_heap;\n\t    }\n\t}\n        ERL_MESSAGE_TOKEN(mp) = am_undefined;\n        msg = copy_struct_litopt(msg, sz, &hp, ohp, &litarea);\n    }\n\n    from = c_p ? c_p->common.id : am_undefined;\n\n    if (!env || !env->tracee) {\n\n        if (c_p && IS_TRACED_FL(c_p, F_TRACE_SEND)) {\n\t    full_flush_env(env);\n            trace_send(c_p, receiver, msg);\n\t    full_cache_env(env);\n\t}\n        if (c_p && scheduler > 0 && copy_sz > ERTS_MSG_COPY_WORDS_PER_REDUCTION) {\n            Uint reds = copy_sz / ERTS_MSG_COPY_WORDS_PER_REDUCTION;\n            if (reds > CONTEXT_REDS)\n                reds = CONTEXT_REDS;\n            BUMP_REDS(c_p, (int) reds);\n        }\n    }\n    else {\n        /* This clause is taken when the nif is called in the context\n           of a traced process. We do not know which locks we have\n           so we have to do a try lock and if that fails we enqueue\n           the message in a special trace message output queue of the\n           tracee */\n        ErlTraceMessageQueue *msgq;\n        Process *t_p = env->tracee;\n\n        erts_proc_lock(t_p, ERTS_PROC_LOCK_TRACE);\n\n        msgq = t_p->trace_msg_q;\n\n        while (msgq != NULL) {\n            if (msgq->receiver == receiver) {\n                break;\n            }\n            msgq = msgq->next;\n        }\n\n#ifdef ERTS_ENABLE_LOCK_CHECK\n        lc_locks = erts_proc_lc_my_proc_locks(rp);\n        rp_locks |= lc_locks;\n#endif\n        if (ERTS_FORCE_ENIF_SEND_DELAY() || msgq ||\n            rp_locks & ERTS_PROC_LOCK_MSGQ ||\n            erts_proc_trylock(rp, ERTS_PROC_LOCK_MSGQ) == EBUSY) {\n\n            ERL_MESSAGE_TERM(mp) = msg;\n            ERL_MESSAGE_FROM(mp) = from;\n            ERL_MESSAGE_TOKEN(mp) = am_undefined;\n\n            if (!msgq) {\n                msgq = erts_alloc(ERTS_ALC_T_TRACE_MSG_QUEUE,\n                                  sizeof(ErlTraceMessageQueue));\n                msgq->receiver = receiver;\n                msgq->first = mp;\n                msgq->last = &mp->next;\n                msgq->len = 1;\n\n                /* Insert in linked list */\n                msgq->next = t_p->trace_msg_q;\n                t_p->trace_msg_q = msgq;\n\n                erts_proc_unlock(t_p, ERTS_PROC_LOCK_TRACE);\n\n\t\terts_schedule_flush_trace_messages(t_p, 0);\n            } else {\n                msgq->len++;\n                *msgq->last = mp;\n                msgq->last = &mp->next;\n                erts_proc_unlock(t_p, ERTS_PROC_LOCK_TRACE);\n            }\n            goto done;\n        } else {\n            erts_proc_unlock(t_p, ERTS_PROC_LOCK_TRACE);\n            rp_locks &= ~ERTS_PROC_LOCK_TRACE;\n            rp_locks |= ERTS_PROC_LOCK_MSGQ;\n        }\n    }\n\n    if (c_p)\n        erts_queue_proc_message(c_p, rp, rp_locks, mp, msg);\n    else\n        erts_queue_message(rp, rp_locks, mp, msg, from);\n\ndone:\n\n    if (c_p == rp)\n\trp_locks &= ~ERTS_PROC_LOCK_MAIN;\n    if (rp_locks & ~lc_locks)\n\terts_proc_unlock(rp, rp_locks & ~lc_locks);\n    if (c_p && (env->proc->static_flags & ERTS_STC_FLG_SHADOW_PROC))\n\terts_proc_unlock(c_p, ERTS_PROC_LOCK_MAIN);\n    if (scheduler <= 0)\n\terts_proc_dec_refc(rp);\n\n    return 1;\n}\n\nint\nenif_port_command(ErlNifEnv *env, const ErlNifPort* to_port,\n                  ErlNifEnv *msg_env, ERL_NIF_TERM msg)\n{\n    int iflags = (erts_port_synchronous_ops\n\t\t  ? ERTS_PORT_SFLGS_INVALID_DRIVER_LOOKUP\n\t\t  : ERTS_PORT_SFLGS_INVALID_LOOKUP);\n    int scheduler;\n    Process *c_p;\n    Port *prt;\n    int res;\n\n    if (!env)\n\terts_exit(ERTS_ABORT_EXIT, \"enif_port_command: env == NULL\");\n\n    execution_state(env, &c_p, &scheduler);\n\n    if (!c_p)\n\tc_p = env->proc;\n\n    if (scheduler > 0)\n\tprt = erts_port_lookup(to_port->port_id, iflags);\n    else {\n\tif (ERTS_PROC_IS_EXITING(c_p))\n\t    return 0;\n\tprt = erts_thr_port_lookup(to_port->port_id, iflags);\n    }\n\n    if (!prt)\n\tres = 0;\n    else\n        res = erts_port_output_async(prt, c_p->common.id, msg);\n\n    if (scheduler <= 0)\n\terts_port_dec_refc(prt);\n\n    return res;\n}\n\n/*\n *  env must be the caller's environment in a scheduler or NULL in a\n *      non-scheduler thread.\n *  name must be an atom - anything else will just waste time.\n */\nstatic Eterm call_whereis(ErlNifEnv *env, Eterm name)\n{\n    Process *c_p;\n    Eterm res;\n    int scheduler;\n\n    execution_state(env, &c_p, &scheduler);\n    ASSERT(scheduler || !c_p);\n\n    if (scheduler < 0) {\n        /* dirty scheduler */\n        if (ERTS_PROC_IS_EXITING(c_p))\n            return 0;\n\n        if (env->proc->static_flags & ERTS_STC_FLG_SHADOW_PROC)\n            c_p = NULL; /* as we don't have main lock */\n    }\n\n\n    if (c_p) {\n         /* main lock may be released below and c_p->htop updated by others */\n        flush_env(env);\n    }\n    res = erts_whereis_name_to_id(c_p, name);\n    if (c_p)\n        cache_env(env);\n\n    return res;\n}\n\nint enif_whereis_pid(ErlNifEnv *env, ERL_NIF_TERM name, ErlNifPid *pid)\n{\n    Eterm res;\n\n    if (is_not_atom(name))\n        return 0;\n\n    res = call_whereis(env, name);\n    /* enif_get_local_ functions check the type */\n    return enif_get_local_pid(env, res, pid);\n}\n\nint enif_whereis_port(ErlNifEnv *env, ERL_NIF_TERM name, ErlNifPort *port)\n{\n    Eterm res;\n\n    if (is_not_atom(name))\n        return 0;\n\n    res = call_whereis(env, name);\n    /* enif_get_local_ functions check the type */\n    return enif_get_local_port(env, res, port);\n}\n\nERL_NIF_TERM enif_make_copy(ErlNifEnv* dst_env, ERL_NIF_TERM src_term)\n{\n    return make_copy(dst_env, src_term, NULL);\n}\n\n#ifdef DEBUG\nstatic int is_offheap(const ErlOffHeap* oh)\n{\n    return oh->first != NULL;\n}\n#endif\n\nErlNifPid* enif_self(ErlNifEnv* caller_env, ErlNifPid* pid)\n{\n    if (caller_env->proc->common.id == ERTS_INVALID_PID)\n        return NULL;\n    pid->pid = caller_env->proc->common.id;\n    return pid;\n}\n\nint enif_get_local_pid(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifPid* pid)\n{\n    if (is_internal_pid(term)) {\n        pid->pid=term;\n        return 1;\n    }\n    return 0;\n}\n\nvoid enif_set_pid_undefined(ErlNifPid* pid)\n{\n    pid->pid = am_undefined;\n}\n\nint enif_is_pid_undefined(const ErlNifPid* pid)\n{\n    ASSERT(pid->pid == am_undefined || is_internal_pid(pid->pid));\n    return pid->pid == am_undefined;\n}\n\nint enif_get_local_port(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifPort* port)\n{\n    if (is_internal_port(term)) {\n        port->port_id=term;\n        return 1;\n    }\n    return 0;\n}\n\nint enif_is_atom(ErlNifEnv* env, ERL_NIF_TERM term)\n{\n    return is_atom(term);\n}\n\nint enif_is_binary(ErlNifEnv* env, ERL_NIF_TERM term)\n{\n    return is_binary(term) && (binary_bitsize(term) % 8 == 0);\n}\n\nint enif_is_empty_list(ErlNifEnv* env, ERL_NIF_TERM term)\n{\n    return is_nil(term);\n}\n\nint enif_is_fun(ErlNifEnv* env, ERL_NIF_TERM term)\n{\n    return is_fun(term);\n}\n\nint enif_is_pid(ErlNifEnv* env, ERL_NIF_TERM term)\n{\n    return is_pid(term);\n}\n\nint enif_is_port(ErlNifEnv* env, ERL_NIF_TERM term)\n{\n    return is_port(term);\n}\n\nint enif_is_ref(ErlNifEnv* env, ERL_NIF_TERM term)\n{\n    return is_ref(term);\n}\n\nint enif_is_tuple(ErlNifEnv* env, ERL_NIF_TERM term)\n{\n    return is_tuple(term);\n}\n\nint enif_is_list(ErlNifEnv* env, ERL_NIF_TERM term)\n{\n    return is_list(term) || is_nil(term);\n}\n\nint enif_is_exception(ErlNifEnv* env, ERL_NIF_TERM term)\n{\n    return env->exception_thrown && term == THE_NON_VALUE;\n}\n\nint enif_is_number(ErlNifEnv* env, ERL_NIF_TERM term)\n{\n    return is_number(term);\n}\n\nErlNifTermType enif_term_type(ErlNifEnv* env, ERL_NIF_TERM term) {\n    (void)env;\n\n    switch (tag_val_def(term)) {\n    case ATOM_DEF:\n        return ERL_NIF_TERM_TYPE_ATOM;\n    case BINARY_DEF:\n        return ERL_NIF_TERM_TYPE_BITSTRING;\n    case FLOAT_DEF:\n        return ERL_NIF_TERM_TYPE_FLOAT;\n    case EXPORT_DEF:\n    case FUN_DEF:\n        return ERL_NIF_TERM_TYPE_FUN;\n    case BIG_DEF:\n    case SMALL_DEF:\n        return ERL_NIF_TERM_TYPE_INTEGER;\n    case LIST_DEF:\n    case NIL_DEF:\n        return ERL_NIF_TERM_TYPE_LIST;\n    case MAP_DEF:\n        return ERL_NIF_TERM_TYPE_MAP;\n    case EXTERNAL_PID_DEF:\n    case PID_DEF:\n        return ERL_NIF_TERM_TYPE_PID;\n    case EXTERNAL_PORT_DEF:\n    case PORT_DEF:\n        return ERL_NIF_TERM_TYPE_PORT;\n    case EXTERNAL_REF_DEF:\n    case REF_DEF:\n        return ERL_NIF_TERM_TYPE_REFERENCE;\n    case TUPLE_DEF:\n        return ERL_NIF_TERM_TYPE_TUPLE;\n    default:\n        /* tag_val_def() aborts on its own when passed complete garbage, but\n         * it's possible that the user has given us garbage that just happens\n         * to match something that tag_val_def() accepts but we don't, like\n         * binary match contexts. */\n        ERTS_INTERNAL_ERROR(\"Invalid term passed to enif_term_type\");\n    }\n}\n\nstatic void aligned_binary_dtor(struct enif_tmp_obj_t* obj)\n{\n    erts_free_aligned_binary_bytes_extra((byte*)obj, obj->allocator);\n}\n\nint enif_inspect_binary(ErlNifEnv* env, Eterm bin_term, ErlNifBinary* bin)\n{\n    ErtsAlcType_t allocator = is_proc_bound(env) ? ERTS_ALC_T_TMP : ERTS_ALC_T_NIF;\n    union {\n\tstruct enif_tmp_obj_t* tmp;\n\tbyte* raw_ptr;\n    }u;\n\n    if (is_binary(bin_term)) {\n        ProcBin *pb = (ProcBin*) binary_val(bin_term);\n        if (pb->thing_word == HEADER_SUB_BIN) {\n            ErlSubBin* sb = (ErlSubBin*) pb;\n            pb = (ProcBin*) binary_val(sb->orig);\n        }\n        if (pb->thing_word == HEADER_PROC_BIN && pb->flags)\n            erts_emasculate_writable_binary(pb);\n    }\n    u.tmp = NULL;\n    bin->data = erts_get_aligned_binary_bytes_extra(bin_term, &u.raw_ptr, allocator,\n\t\t\t\t\t\t    sizeof(struct enif_tmp_obj_t));\n    if (bin->data == NULL) {\n\treturn 0;\n    }\n    if (u.tmp != NULL) {\n\tu.tmp->allocator = allocator;\n\tu.tmp->next = env->tmp_obj_list;\n\tu.tmp->dtor = &aligned_binary_dtor;\n\tenv->tmp_obj_list = u.tmp;\n    }\n    bin->size = binary_size(bin_term);\n    bin->ref_bin = NULL;\n    ADD_READONLY_CHECK(env, bin->data, bin->size);\n    return 1;\n}\n\nint enif_inspect_iolist_as_binary(ErlNifEnv* env, Eterm term, ErlNifBinary* bin)\n{\n    ErlDrvSizeT sz;\n    if (is_binary(term)) {\n\treturn enif_inspect_binary(env,term,bin);\n    }\n    if (is_nil(term)) {\n\tbin->data = (unsigned char*) &bin->data; /* dummy non-NULL */\n\tbin->size = 0;\n\tbin->ref_bin = NULL;\n\treturn 1;\n    }\n    if (erts_iolist_size(term, &sz)) {\n\treturn 0;\n    }\n\n    bin->data = alloc_tmp_obj(env, sz, &tmp_alloc_dtor);\n    bin->size = sz;\n    bin->ref_bin = NULL;\n    erts_iolist_to_buf(term, (char*) bin->data, sz);\n    ADD_READONLY_CHECK(env, bin->data, bin->size); \n    return 1;\n}\n\nint enif_alloc_binary(size_t size, ErlNifBinary* bin)\n{\n    Binary* refbin;\n\n    refbin = erts_bin_drv_alloc_fnf(size); /* BUGBUG: alloc type? */\n    if (refbin == NULL) {\n\treturn 0; /* The NIF must take action */\n    }\n\n    bin->size = size;\n    bin->data = (unsigned char*) refbin->orig_bytes;\n    bin->ref_bin = refbin;\n    return 1;\n}\n\nint enif_realloc_binary(ErlNifBinary* bin, size_t size)\n{\n    if (bin->ref_bin != NULL) {\n\tBinary* oldbin;\n\tBinary* newbin;\n    \n\toldbin = (Binary*) bin->ref_bin; \n\tnewbin = (Binary *) erts_bin_realloc_fnf(oldbin, size);\n\tif (!newbin) {\n\t    return 0;\n\t}    \n\tbin->ref_bin = newbin;\n\tbin->data = (unsigned char*) newbin->orig_bytes;\n\tbin->size = size;\n    }\n    else {\n\tunsigned char* old_data = bin->data;\n\tsize_t cpy_sz = (size < bin->size ? size : bin->size);  \n\tenif_alloc_binary(size, bin);\n\tsys_memcpy(bin->data, old_data, cpy_sz); \n    }\n    return 1;\n}\n\n\nvoid enif_release_binary(ErlNifBinary* bin)\n{\n    if (bin->ref_bin != NULL) {\n\tBinary* refbin = bin->ref_bin;\n        erts_bin_release(refbin);\n    }\n#ifdef DEBUG\n    bin->data = NULL;\n    bin->ref_bin = NULL;\n#endif\n}\n\nunsigned char* enif_make_new_binary(ErlNifEnv* env, size_t size,\n\t\t\t\t    ERL_NIF_TERM* termp)\n{\n    flush_env(env);\n    *termp = new_binary(env->proc, NULL, size);\n    cache_env(env);\n    return binary_bytes(*termp);\n}\n\nint enif_term_to_binary(ErlNifEnv *dst_env, ERL_NIF_TERM term,\n                        ErlNifBinary *bin)\n{\n    Uint size;\n    byte *bp;\n    Binary* refbin;\n\n    switch (erts_encode_ext_size(term, &size)) {\n    case ERTS_EXT_SZ_SYSTEM_LIMIT:\n        return 0; /* system limit */\n    case ERTS_EXT_SZ_YIELD:\n        ERTS_INTERNAL_ERROR(\"Unexpected yield\");\n    case ERTS_EXT_SZ_OK:\n        break;\n    }\n    if (!enif_alloc_binary(size, bin))\n        return 0;\n\n    refbin = bin->ref_bin;\n\n    bp = bin->data;\n\n    erts_encode_ext(term, &bp);\n\n    bin->size = bp - bin->data;\n    refbin->orig_size = bin->size;\n\n    ASSERT(bin->data + bin->size == bp);\n\n    return 1;\n}\n\nsize_t enif_binary_to_term(ErlNifEnv *dst_env,\n                           const unsigned char* data,\n                           size_t data_sz,\n                           ERL_NIF_TERM *term,\n                           ErlNifBinaryToTerm opts)\n{\n    Sint size;\n    ErtsHeapFactory factory;\n    byte *bp = (byte*) data;\n    Uint32 flags = 0;\n\n    switch ((Uint32)opts) {\n    case 0: break;\n    case ERL_NIF_BIN2TERM_SAFE: flags = ERTS_DIST_EXT_BTT_SAFE; break;\n    default: return 0;\n    }\n    if ((size = erts_decode_ext_size(bp, data_sz)) < 0)\n        return 0;\n\n    if (size > 0) {\n        flush_env(dst_env);\n        erts_factory_proc_prealloc_init(&factory, dst_env->proc, size);\n    } else {\n        erts_factory_dummy_init(&factory);\n    }\n\n    *term = erts_decode_ext(&factory, &bp, flags);\n\n    if (is_non_value(*term)) {\n        return 0;\n    }\n    if (size > 0) {\n        erts_factory_close(&factory);\n        cache_env(dst_env);\n    }\n\n    ASSERT(bp > data);\n    return bp - data;\n}\n\nint enif_is_identical(Eterm lhs, Eterm rhs)\n{\n    return EQ(lhs,rhs);\n}\n\nint enif_compare(Eterm lhs, Eterm rhs)\n{\n    Sint result = CMP(lhs,rhs);\n\n    if (result < 0) {\n        return -1;\n    } else if (result > 0) {\n        return 1;\n    }\n\n    return result;\n}\n\nErlNifUInt64 enif_hash(ErlNifHash type, Eterm term, ErlNifUInt64 salt)\n{\n    switch (type) {\n        case ERL_NIF_INTERNAL_HASH:\n            return make_internal_hash(term, (Uint32) salt);\n        case ERL_NIF_PHASH2:\n            /* It appears that make_hash2 doesn't always react to seasoning\n             * as well as it should. Therefore, let's make it ignore the salt\n             * value and declare salted uses of phash2 as unsupported.\n             */\n            return make_hash2(term) & ((1 << 27) - 1);\n        default:\n            return 0;\n    }\n}\n\nint enif_get_tuple(ErlNifEnv* env, Eterm tpl, int* arity, const Eterm** array)\n{\n    Eterm* ptr;\n    if (is_not_tuple(tpl)) {\n\treturn 0;\n    }\n    ptr = tuple_val(tpl);\n    *arity = arityval(*ptr);\n    *array = ptr+1;\n    return 1;\n}\n\nint enif_get_string(ErlNifEnv *env, ERL_NIF_TERM list, char* buf, unsigned len,\n\t\t    ErlNifCharEncoding encoding)\n{\n    Eterm* listptr;\n    int n = 0;\n\n    ASSERT(encoding == ERL_NIF_LATIN1);\n    if (len < 1) {\n\treturn 0;\n    }\n    while (is_not_nil(list)) { \t    \n\tif (is_not_list(list)) {\n\t    buf[n] = '\\0';\n\t    return 0;\n\t}\n\tlistptr = list_val(list);\n    \n\tif (!is_byte(*listptr)) {\n\t    buf[n] = '\\0';\n\t    return 0;\n\t}\n\tbuf[n++] = unsigned_val(*listptr);\n\tif (n >= len) {\n\t    buf[n-1] = '\\0'; /* truncate */\n\t    return -len;\n\t}\n\tlist = CDR(listptr);\n    }\n    buf[n] = '\\0';\n    return n + 1;\n}\n\nEterm enif_make_binary(ErlNifEnv* env, ErlNifBinary* bin)\n{\n    Eterm bin_term;\n\n    if (bin->ref_bin != NULL) {\n        Binary* binary = bin->ref_bin;\n\n        /* If the binary is smaller than the heap binary limit we'll return a\n         * heap binary to reduce the number of small refc binaries in the\n         * system. We can't simply release the refc binary right away however;\n         * the documentation states that the binary should be considered\n         * read-only from this point on, which implies that it should still be\n         * readable.\n         *\n         * We could keep it alive until we return by adding it to the temporary\n         * object list, but that requires an off-heap allocation which is\n         * potentially quite slow, so we create a dummy ProcBin instead and\n         * rely on the next minor GC to get rid of it. */\n        if (bin->size <= ERL_ONHEAP_BIN_LIMIT) {\n            ErlHeapBin* hb;\n\n            hb = (ErlHeapBin*)alloc_heap(env, heap_bin_size(bin->size));\n            hb->thing_word = header_heap_bin(bin->size);\n            hb->size = bin->size;\n\n            sys_memcpy(hb->data, bin->data, bin->size);\n\n            erts_build_proc_bin(&MSO(env->proc),\n                                alloc_heap(env, PROC_BIN_SIZE),\n                                binary);\n\n            bin_term = make_binary(hb);\n        } else {\n            bin_term = erts_build_proc_bin(&MSO(env->proc),\n                                           alloc_heap(env, PROC_BIN_SIZE),\n                                           binary);\n        }\n\n        /* Our (possibly shared) ownership has been transferred to the term. */\n        bin->ref_bin = NULL;\n    } else {\n        flush_env(env);\n        bin_term = new_binary(env->proc, bin->data, bin->size);\n        cache_env(env);\n    }\n\n    return bin_term;\n}\n\nEterm enif_make_sub_binary(ErlNifEnv* env, ERL_NIF_TERM bin_term,\n\t\t\t   size_t pos, size_t size)\n{\n    ErlSubBin* sb;\n    Eterm orig;\n    Uint offset, bit_offset, bit_size; \n#ifdef DEBUG\n    size_t src_size;\n\n    ASSERT(is_binary(bin_term));\n    src_size = binary_size(bin_term);\n    ASSERT(pos <= src_size);\n    ASSERT(size <= src_size);\n    ASSERT(pos + size <= src_size);   \n#endif\n    sb = (ErlSubBin*) alloc_heap(env, ERL_SUB_BIN_SIZE);\n    ERTS_GET_REAL_BIN(bin_term, orig, offset, bit_offset, bit_size);\n    sb->thing_word = HEADER_SUB_BIN;\n    sb->size = size;\n    sb->offs = offset + pos;\n    sb->orig = orig;\n    sb->bitoffs = bit_offset;\n    sb->bitsize = 0;\n    sb->is_writable = 0;\n    return make_binary(sb);\n}\n\n\nEterm enif_make_badarg(ErlNifEnv* env)\n{\n    return enif_raise_exception(env, am_badarg);\n}\n\nEterm enif_raise_exception(ErlNifEnv* env, ERL_NIF_TERM reason)\n{\n    env->exception_thrown = 1;\n    env->proc->fvalue = reason;\n    BIF_ERROR(env->proc, EXC_ERROR);\n}\n\nint enif_has_pending_exception(ErlNifEnv* env, ERL_NIF_TERM* reason)\n{\n    if (env->exception_thrown && reason != NULL)\n\t*reason = env->proc->fvalue;\n    return env->exception_thrown;\n}\n\nint enif_get_atom(ErlNifEnv* env, Eterm atom, char* buf, unsigned len,\n\t\t  ErlNifCharEncoding encoding)\n{\n    Atom* ap;\n    ASSERT(encoding == ERL_NIF_LATIN1);\n    if (is_not_atom(atom) || len==0) {\n\treturn 0;\n    }\n    ap = atom_tab(atom_val(atom));\n\n    if (ap->latin1_chars < 0 || ap->latin1_chars >= len) {\n\treturn 0;\n    }\n    if (ap->latin1_chars == ap->len) {\n\tsys_memcpy(buf, ap->name, ap->len);\n    }\n    else {\n\tint dlen = erts_utf8_to_latin1((byte*)buf, ap->name, ap->len);\n\tASSERT(dlen == ap->latin1_chars); (void)dlen;\n    }\n    buf[ap->latin1_chars] = '\\0';\n    return ap->latin1_chars + 1;\n}\n\nint enif_get_int(ErlNifEnv* env, Eterm term, int* ip)\n{\n#if SIZEOF_INT ==  ERTS_SIZEOF_ETERM\n    return term_to_Sint(term, (Sint*)ip);\n#elif (SIZEOF_LONG ==  ERTS_SIZEOF_ETERM) || \\\n  (SIZEOF_LONG_LONG ==  ERTS_SIZEOF_ETERM)\n    Sint i;\n    if (!term_to_Sint(term, &i) || i < INT_MIN || i > INT_MAX) {\n\treturn 0;\n    }\n    *ip = (int) i;\n    return 1;\n#else\n#  error Unknown word size \n#endif     \n}\n\nint enif_get_uint(ErlNifEnv* env, Eterm term, unsigned* ip)\n{\n#if SIZEOF_INT == ERTS_SIZEOF_ETERM\n    return term_to_Uint(term, (Uint*)ip);\n#elif (SIZEOF_LONG == ERTS_SIZEOF_ETERM) || \\\n  (SIZEOF_LONG_LONG ==  ERTS_SIZEOF_ETERM)\n    Uint i;\n    if (!term_to_Uint(term, &i) || i > UINT_MAX) {\n\treturn 0;\n    }\n    *ip = (unsigned) i;\n    return 1;\n#endif     \n}\n\nint enif_get_long(ErlNifEnv* env, Eterm term, long* ip)\n{\n#if SIZEOF_LONG == ERTS_SIZEOF_ETERM\n    return term_to_Sint(term, ip);\n#elif SIZEOF_LONG == 8\n    return term_to_Sint64(term, ip);\n#elif SIZEOF_LONG == SIZEOF_INT\n    int tmp,ret;\n    ret = enif_get_int(env,term,&tmp);\n    if (ret) {\n      *ip = (long) tmp;\n    }\n    return ret;\n#else\n#  error Unknown long word size \n#endif     \n}\n\nint enif_get_ulong(ErlNifEnv* env, Eterm term, unsigned long* ip)\n{\n#if SIZEOF_LONG == ERTS_SIZEOF_ETERM\n    return term_to_Uint(term, ip);\n#elif SIZEOF_LONG == 8\n    return term_to_Uint64(term, ip);\n#elif SIZEOF_LONG == SIZEOF_INT\n    int ret;\n    unsigned int tmp;\n    ret = enif_get_uint(env,term,&tmp);\n    if (ret) {\n      *ip = (unsigned long) tmp;\n    }\n    return ret;\n#else\n#  error Unknown long word size \n#endif     \n}\n\n#if HAVE_INT64 && SIZEOF_LONG != 8\nint enif_get_int64(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifSInt64* ip)\n{\n    return term_to_Sint64(term, ip);\n}\n\nint enif_get_uint64(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifUInt64* ip)\n{\n    return term_to_Uint64(term, ip);\n}\n#endif /* HAVE_INT64 && SIZEOF_LONG != 8 */\n\nint enif_get_double(ErlNifEnv* env, ERL_NIF_TERM term, double* dp)\n{\n    FloatDef f;\n    if (is_not_float(term)) {\n\treturn 0;\n    }\n    GET_DOUBLE(term, f);\n    *dp = f.fd;\n    return 1;\n}\n\nint enif_get_atom_length(ErlNifEnv* env, Eterm atom, unsigned* len,\n\t\t\t ErlNifCharEncoding enc)\n{\n    Atom* ap;\n    ASSERT(enc == ERL_NIF_LATIN1);\n    if (is_not_atom(atom)) return 0;\n    ap = atom_tab(atom_val(atom));\n    if (ap->latin1_chars < 0) {\n\treturn 0;\n    }\n    *len = ap->latin1_chars;\n    return 1;\n}\n\nint enif_get_list_cell(ErlNifEnv* env, Eterm term, Eterm* head, Eterm* tail)\n{\n    Eterm* val;\n    if (is_not_list(term)) return 0;\n    val = list_val(term);\n    *head = CAR(val);\n    *tail = CDR(val);\n    return 1;\n}\n\nint enif_get_list_length(ErlNifEnv* env, Eterm term, unsigned* len)\n{\n    Sint i;\n    Uint u;\n\n    if ((i = erts_list_length(term)) < 0) return 0;\n    u = (Uint)i;\n    if ((unsigned)u != u) return 0;\n    *len = u;\n    return 1;\n}\n\nERL_NIF_TERM enif_make_int(ErlNifEnv* env, int i)\n{\n#if SIZEOF_INT == ERTS_SIZEOF_ETERM\n    return IS_SSMALL(i) ? make_small(i) : small_to_big(i,alloc_heap(env,2));\n#elif (SIZEOF_LONG == ERTS_SIZEOF_ETERM) || \\\n  (SIZEOF_LONG_LONG == ERTS_SIZEOF_ETERM)\n    return make_small(i);\n#endif\n}\n\nERL_NIF_TERM enif_make_uint(ErlNifEnv* env, unsigned i)\n{\n#if SIZEOF_INT == ERTS_SIZEOF_ETERM\n    return IS_USMALL(0,i) ? make_small(i) : uint_to_big(i,alloc_heap(env,2));\n#elif (SIZEOF_LONG ==  ERTS_SIZEOF_ETERM) || \\\n  (SIZEOF_LONG_LONG ==  ERTS_SIZEOF_ETERM)\n    return make_small(i);\n#endif\n}\n\nERL_NIF_TERM enif_make_long(ErlNifEnv* env, long i)\n{\n    if (IS_SSMALL(i)) {\n\treturn make_small(i);\n    }\n#if SIZEOF_LONG == ERTS_SIZEOF_ETERM\n    return small_to_big(i, alloc_heap(env,2));\n#elif SIZEOF_LONG_LONG ==  ERTS_SIZEOF_ETERM\n    return make_small(i);\n#elif SIZEOF_LONG == 8\n    ensure_heap(env,3);\n    return erts_sint64_to_big(i, &env->hp);\n#endif\n}\n\nERL_NIF_TERM enif_make_ulong(ErlNifEnv* env, unsigned long i)\n{\n    if (IS_USMALL(0,i)) {\n\treturn make_small(i);\n    }\n#if SIZEOF_LONG == ERTS_SIZEOF_ETERM\n    return uint_to_big(i,alloc_heap(env,2));\n#elif SIZEOF_LONG_LONG ==  ERTS_SIZEOF_ETERM\n    return make_small(i);\n#elif SIZEOF_LONG == 8\n    ensure_heap(env,3);\n    return erts_uint64_to_big(i, &env->hp);    \n#endif\n}\n\n#if HAVE_INT64 && SIZEOF_LONG != 8\nERL_NIF_TERM enif_make_int64(ErlNifEnv* env, ErlNifSInt64 i)\n{\n    Uint* hp;\n    Uint need = 0;\n    erts_bld_sint64(NULL, &need, i);\n    hp = alloc_heap(env, need);\n    return erts_bld_sint64(&hp, NULL, i);\n}\n\nERL_NIF_TERM enif_make_uint64(ErlNifEnv* env, ErlNifUInt64 i)\n{\n    Uint* hp;\n    Uint need = 0;\n    erts_bld_uint64(NULL, &need, i);\n    hp = alloc_heap(env, need);\n    return erts_bld_uint64(&hp, NULL, i);\n}\n#endif /* HAVE_INT64 && SIZEOF_LONG != 8 */\n\nERL_NIF_TERM enif_make_double(ErlNifEnv* env, double d)\n{\n    Eterm* hp;\n    FloatDef f;\n\n    if (!erts_isfinite(d))\n        return enif_make_badarg(env);\n    hp = alloc_heap(env,FLOAT_SIZE_OBJECT);\n    f.fd = d;\n    PUT_DOUBLE(f, hp);\n    return make_float(hp);\n}\n\nERL_NIF_TERM enif_make_atom(ErlNifEnv* env, const char* name)\n{\n    return enif_make_atom_len(env, name, sys_strlen(name));\n}\n\nERL_NIF_TERM enif_make_atom_len(ErlNifEnv* env, const char* name, size_t len)\n{\n    if (len > MAX_ATOM_CHARACTERS)\n        return enif_make_badarg(env);\n    return erts_atom_put((byte*)name, len, ERTS_ATOM_ENC_LATIN1, 1);\n}\n\nint enif_make_existing_atom(ErlNifEnv* env, const char* name, ERL_NIF_TERM* atom,\n\t\t\t    ErlNifCharEncoding enc)\n{\n    return enif_make_existing_atom_len(env, name, sys_strlen(name), atom, enc);\n}\n\nint enif_make_existing_atom_len(ErlNifEnv* env, const char* name, size_t len,\n\t\t\t\tERL_NIF_TERM* atom, ErlNifCharEncoding encoding)\n{\n    ASSERT(encoding == ERL_NIF_LATIN1);\n    if (len > MAX_ATOM_CHARACTERS)\n        return 0;\n    return erts_atom_get(name, len, atom, ERTS_ATOM_ENC_LATIN1);\n}\n\nERL_NIF_TERM enif_make_tuple(ErlNifEnv* env, unsigned cnt, ...)\n{\n#ifdef ERTS_NIF_ASSERT_IN_ENV\n    int nr = 0;\n#endif\n    Eterm* hp = alloc_heap(env,cnt+1);\n    Eterm ret = make_tuple(hp);\n    va_list ap;\n\n    *hp++ = make_arityval(cnt);\n    va_start(ap,cnt);\n    while (cnt--) {\n        Eterm elem = va_arg(ap,Eterm);\n        ASSERT_IN_ENV(env, elem, ++nr, \"tuple\");\n\t*hp++ = elem;\n    }\n    va_end(ap);\n    return ret;\n}\n\nERL_NIF_TERM enif_make_tuple_from_array(ErlNifEnv* env, const ERL_NIF_TERM arr[], unsigned cnt)\n{\n#ifdef ERTS_NIF_ASSERT_IN_ENV\n    int nr = 0;\n#endif\n    Eterm* hp = alloc_heap(env,cnt+1);\n    Eterm ret = make_tuple(hp);\n    const Eterm* src = arr;\n\n    *hp++ = make_arityval(cnt);\n    while (cnt--) {\n        ASSERT_IN_ENV(env, *src, ++nr, \"tuple\");\n\t*hp++ = *src++;\t   \n    }\n    return ret;\n}\n\nERL_NIF_TERM enif_make_list_cell(ErlNifEnv* env, Eterm car, Eterm cdr)\n{\n    Eterm* hp = alloc_heap(env,2);\n    Eterm ret = make_list(hp);\n\n    ASSERT_IN_ENV(env, car, 0, \"head of list cell\");\n    ASSERT_IN_ENV(env, cdr, 0, \"tail of list cell\");\n    CAR(hp) = car;\n    CDR(hp) = cdr;\n    return ret;\n}\n\nERL_NIF_TERM enif_make_list(ErlNifEnv* env, unsigned cnt, ...)\n{\n    if (cnt == 0) {\n\treturn NIL;\n    }\n    else {\n#ifdef ERTS_NIF_ASSERT_IN_ENV\n        int nr = 0;\n#endif\n\tEterm* hp = alloc_heap(env,cnt*2);\n\tEterm ret = make_list(hp);\n\tEterm* last = &ret;\n\tva_list ap;\n\n\tva_start(ap,cnt);\n\twhile (cnt--) {\n            Eterm term = va_arg(ap,Eterm);\n\t    *last = make_list(hp);\n            ASSERT_IN_ENV(env, term, ++nr, \"list\");\n\t    *hp = term;\n\t    last = ++hp;\n\t    ++hp;\n\t}\n\tva_end(ap);\n\t*last = NIL;\n\treturn ret;\n    }\n}\n\nERL_NIF_TERM enif_make_list_from_array(ErlNifEnv* env, const ERL_NIF_TERM arr[], unsigned cnt)\n{\n#ifdef ERTS_NIF_ASSERT_IN_ENV\n    int nr = 0;\n#endif\n    Eterm* hp = alloc_heap(env,cnt*2);\n    Eterm ret = make_list(hp);\n    Eterm* last = &ret;\n    const Eterm* src = arr;\n\n    while (cnt--) {\n        Eterm term = *src++;\n\t*last = make_list(hp);\n        ASSERT_IN_ENV(env, term, ++nr, \"list\");\n\t*hp = term;\n\tlast = ++hp;\n\t++hp;\n    }\n    *last = NIL;\n    return ret;\n}\n\nERL_NIF_TERM enif_make_string(ErlNifEnv* env, const char* string,\n\t\t\t      ErlNifCharEncoding encoding)\n{\n    return enif_make_string_len(env, string, sys_strlen(string), encoding);\n}\n\nERL_NIF_TERM enif_make_string_len(ErlNifEnv* env, const char* string,\n\t\t\t\t  size_t len, ErlNifCharEncoding encoding)\n{\n    Eterm* hp = alloc_heap(env,len*2);\n    ASSERT(encoding == ERL_NIF_LATIN1);\n    return erts_bld_string_n(&hp,NULL,string,len);\n}\n\nERL_NIF_TERM enif_make_ref(ErlNifEnv* env)\n{\n    Eterm* hp = alloc_heap(env, ERTS_REF_THING_SIZE);\n    return erts_make_ref_in_buffer(hp);\n}\n\nvoid enif_system_info(ErlNifSysInfo *sip, size_t si_size)\n{\n    driver_system_info(sip, si_size);\n}\n\nint enif_make_reverse_list(ErlNifEnv* env, ERL_NIF_TERM term, ERL_NIF_TERM *list)\n{\n    Eterm *listptr, ret, *hp;\n\n    ret = NIL;\n\n    while (is_not_nil(term)) {\n\tif (is_not_list(term)) {\n\t    return 0;\n\t}\n\thp = alloc_heap(env, 2);\n\tlistptr = list_val(term);\n\tret = CONS(hp, CAR(listptr), ret);\n\tterm = CDR(listptr);\n    }\n    *list = ret;\n    return 1;\n}\n\nint enif_is_current_process_alive(ErlNifEnv* env)\n{\n    Process *c_p;\n    int scheduler;\n\n    execution_state(env, &c_p, &scheduler);\n\n    if (!c_p)\n\terts_exit(ERTS_ABORT_EXIT,\n\t\t  \"enif_is_current_process_alive: \"\n                  \"Invalid environment\");\n\n    if (!scheduler)\n\terts_exit(ERTS_ABORT_EXIT, \"enif_is_current_process_alive: \"\n\t\t  \"called from non-scheduler thread\");\n\n    return !ERTS_PROC_IS_EXITING(c_p);\n}\n\nint enif_is_process_alive(ErlNifEnv* env, ErlNifPid *proc)\n{\n    int scheduler;\n\n    execution_state(env, NULL, &scheduler);\n\n    if (scheduler > 0)\n\treturn !!erts_proc_lookup(proc->pid);\n    else {\n\tProcess* rp = erts_pid2proc_opt(NULL, 0, proc->pid, 0,\n\t\t\t\t\tERTS_P2P_FLG_INC_REFC);\n\tif (rp)\n\t    erts_proc_dec_refc(rp);\n\treturn !!rp;\n    }\n}\n\nint enif_is_port_alive(ErlNifEnv *env, ErlNifPort *port)\n{\n    int scheduler;\n    Uint32 iflags = (erts_port_synchronous_ops\n\t\t     ? ERTS_PORT_SFLGS_INVALID_DRIVER_LOOKUP\n\t\t     : ERTS_PORT_SFLGS_INVALID_LOOKUP);\n\n    execution_state(env, NULL, &scheduler);\n\n    if (scheduler > 0)\n\treturn !!erts_port_lookup(port->port_id, iflags);\n    else {\n\tPort *prt = erts_thr_port_lookup(port->port_id, iflags);\n\tif (prt)\n\t    erts_port_dec_refc(prt);\n\treturn !!prt;\n    }\n}\n\nERL_NIF_TERM\nenif_now_time(ErlNifEnv *env)\n{\n    Uint mega, sec, micro;\n    Eterm *hp;\n    get_now(&mega, &sec, &micro);\n    hp = alloc_heap(env, 4);\n    return TUPLE3(hp, make_small(mega), make_small(sec), make_small(micro));\n}\n\nERL_NIF_TERM\nenif_cpu_time(ErlNifEnv *env)\n{\n#ifdef HAVE_ERTS_NOW_CPU\n    Uint mega, sec, micro;\n    Eterm *hp;\n    erts_get_now_cpu(&mega, &sec, &micro);\n    hp = alloc_heap(env, 4);\n    return TUPLE3(hp, make_small(mega), make_small(sec), make_small(micro));\n#else\n    return enif_make_badarg(env);\n#endif\n}\n\nERL_NIF_TERM\nenif_make_unique_integer(ErlNifEnv *env, ErlNifUniqueInteger properties)\n{\n    int monotonic = properties & ERL_NIF_UNIQUE_MONOTONIC;\n    int positive = properties & ERL_NIF_UNIQUE_POSITIVE;\n    Eterm *hp;\n    Uint hsz;\n\n    if (monotonic) {\n        Sint64 raw_unique = erts_raw_get_unique_monotonic_integer();\n        hsz = erts_raw_unique_monotonic_integer_heap_size(raw_unique, positive);\n        hp = alloc_heap(env, hsz);\n        return erts_raw_make_unique_monotonic_integer_value(&hp, raw_unique, positive);\n    } else {\n        Uint64 raw_unique[ERTS_UNIQUE_INT_RAW_VALUES];\n        erts_raw_get_unique_integer(raw_unique);\n        hsz = erts_raw_unique_integer_heap_size(raw_unique, positive);\n        hp = alloc_heap(env, hsz);\n        return erts_raw_make_unique_integer(&hp, raw_unique, positive);\n    }\n}\n\nErlNifMutex* enif_mutex_create(char *name) { return erl_drv_mutex_create(name); }\nvoid enif_mutex_destroy(ErlNifMutex *mtx) {  erl_drv_mutex_destroy(mtx); }\nint enif_mutex_trylock(ErlNifMutex *mtx) { return erl_drv_mutex_trylock(mtx); }\nvoid enif_mutex_lock(ErlNifMutex *mtx) { erl_drv_mutex_lock(mtx); }\nvoid enif_mutex_unlock(ErlNifMutex *mtx) { erl_drv_mutex_unlock(mtx); }\nErlNifCond* enif_cond_create(char *name) { return erl_drv_cond_create(name); }\nvoid enif_cond_destroy(ErlNifCond *cnd) { erl_drv_cond_destroy(cnd); }\nvoid enif_cond_signal(ErlNifCond *cnd) { erl_drv_cond_signal(cnd); }\nvoid enif_cond_broadcast(ErlNifCond *cnd) { erl_drv_cond_broadcast(cnd); }\nvoid enif_cond_wait(ErlNifCond *cnd, ErlNifMutex *mtx) { erl_drv_cond_wait(cnd,mtx); }\nErlNifRWLock* enif_rwlock_create(char *name) { return erl_drv_rwlock_create(name); }\nvoid enif_rwlock_destroy(ErlNifRWLock *rwlck) { erl_drv_rwlock_destroy(rwlck); }\nint enif_rwlock_tryrlock(ErlNifRWLock *rwlck) { return erl_drv_rwlock_tryrlock(rwlck); }\nvoid enif_rwlock_rlock(ErlNifRWLock *rwlck) { erl_drv_rwlock_rlock(rwlck); }\nvoid enif_rwlock_runlock(ErlNifRWLock *rwlck) { erl_drv_rwlock_runlock(rwlck); }\nint enif_rwlock_tryrwlock(ErlNifRWLock *rwlck) { return erl_drv_rwlock_tryrwlock(rwlck); }\nvoid enif_rwlock_rwlock(ErlNifRWLock *rwlck) { erl_drv_rwlock_rwlock(rwlck); }\nvoid enif_rwlock_rwunlock(ErlNifRWLock *rwlck) { erl_drv_rwlock_rwunlock(rwlck); }\nint enif_tsd_key_create(char *name, ErlNifTSDKey *key) { return erl_drv_tsd_key_create(name,key); }\nvoid enif_tsd_key_destroy(ErlNifTSDKey key) { erl_drv_tsd_key_destroy(key); }\nvoid enif_tsd_set(ErlNifTSDKey key, void *data) { erl_drv_tsd_set(key,data); }\nvoid* enif_tsd_get(ErlNifTSDKey key) { return erl_drv_tsd_get(key); }\nErlNifThreadOpts* enif_thread_opts_create(char *name) { return (ErlNifThreadOpts*) erl_drv_thread_opts_create(name); }\nvoid enif_thread_opts_destroy(ErlNifThreadOpts *opts) { erl_drv_thread_opts_destroy((ErlDrvThreadOpts*)opts); }\nint enif_thread_create(char *name, ErlNifTid *tid, void* (*func)(void *),\n\t\t       void *args, ErlNifThreadOpts *opts) {\n    return erl_drv_thread_create(name,tid,func,args,(ErlDrvThreadOpts*)opts);\n}\nErlNifTid enif_thread_self(void) { return erl_drv_thread_self(); }\nint enif_equal_tids(ErlNifTid tid1, ErlNifTid tid2) { return erl_drv_equal_tids(tid1,tid2); }\nvoid enif_thread_exit(void *resp) { erl_drv_thread_exit(resp); }\nint enif_thread_join(ErlNifTid tid, void **respp) { return erl_drv_thread_join(tid,respp); }\n\nchar* enif_mutex_name(ErlNifMutex *mtx) {return erl_drv_mutex_name(mtx); }\nchar* enif_cond_name(ErlNifCond *cnd) { return erl_drv_cond_name(cnd); }\nchar* enif_rwlock_name(ErlNifRWLock* rwlck) { return erl_drv_rwlock_name(rwlck); }\nchar* enif_thread_name(ErlNifTid tid) { return erl_drv_thread_name(tid); }\n\nint enif_getenv(const char *key, char *value, size_t *value_size) { return erl_drv_getenv(key, value, value_size); }\n\nErlNifTime enif_monotonic_time(ErlNifTimeUnit time_unit)\n{\n    return (ErlNifTime) erts_napi_monotonic_time((int) time_unit);\n}\n\nErlNifTime enif_time_offset(ErlNifTimeUnit time_unit)\n{\n    return (ErlNifTime) erts_napi_time_offset((int) time_unit);\n}\n\nErlNifTime\nenif_convert_time_unit(ErlNifTime val,\n\t\t       ErlNifTimeUnit from,\n\t\t       ErlNifTimeUnit to)\n{\n    return (ErlNifTime) erts_napi_convert_time_unit((ErtsMonotonicTime) val,\n\t\t\t\t\t\t    (int) from,\n\t\t\t\t\t\t    (int) to);\n}\n\nint enif_fprintf(FILE* filep, const char* format, ...)\n{ \n    int ret;\n    va_list arglist;\n    va_start(arglist, format);\n    ret = erts_vfprintf(filep, format, arglist);\n    va_end(arglist);\n    return ret;\n}    \n\nint enif_vfprintf(FILE* filep, const char *format, va_list ap)\n{\n    return erts_vfprintf(filep, format, ap);\n}\n\nint enif_snprintf(char *buffer, size_t size, const char* format, ...) \n{ \n    int ret;\n    va_list arglist;\n    va_start(arglist, format);\n    ret = erts_vsnprintf(buffer, size, format, arglist);\n    va_end(arglist);\n    return ret;\n}\n\nint enif_vsnprintf(char* buffer, size_t size, const char *format, va_list ap)\n{\n    return erts_vsnprintf(buffer, size, format, ap);\n}\n\n\n/***********************************************************\n **       Memory managed (GC'ed) \"resource\" objects       **\n ***********************************************************/\n\n/* dummy node in circular list */\nstruct enif_resource_type_t resource_type_list; \n\nstatic ErlNifResourceType* find_resource_type(Eterm module, Eterm name)\n{\n    ErlNifResourceType* type;\n    for (type = resource_type_list.next;\n\t type != &resource_type_list;\n\t type = type->next) {\n\n\tif (type->module == module && type->name == name) {\n\t    return type;\n\t}\n    }\n    return NULL;\n}\n\n#define in_area(ptr,start,nbytes) \\\n    ((UWord)((char*)(ptr) - (char*)(start)) < (nbytes))\n\n\nstatic void close_lib(struct erl_module_nif* lib)\n{\n    ASSERT(lib != NULL);\n    ASSERT(lib->handle != NULL);\n    ASSERT(erts_refc_read(&lib->rt_dtor_cnt,0) == 0);\n\n    if (lib->entry.unload != NULL) {\n\tstruct enif_msg_environment_t msg_env;\n        pre_nif_noproc(&msg_env, lib, NULL);\n\tlib->entry.unload(&msg_env.env, lib->priv_data);\n        post_nif_noproc(&msg_env);\n    }\n    if (!erts_is_static_nif(lib->handle))\n      erts_sys_ddll_close(lib->handle);\n    lib->handle = NULL;\n}\n\nstatic void steal_resource_type(ErlNifResourceType* type)\n{\n    struct erl_module_nif* lib = type->owner;\n\n    if (type->dtor != NULL\n\t&& erts_refc_dectest(&lib->rt_dtor_cnt, 0) == 0\n\t&& lib->mod == NULL) {\n\t/* last type with destructor gone, close orphan lib */\n\n\tclose_lib(lib);\n    }\n    if (erts_refc_dectest(&lib->rt_cnt, 0) == 0\n\t&& lib->mod == NULL) {\n\terts_free(ERTS_ALC_T_NIF, lib);\n    }\n}\n\n/* The opened_rt_list is used by enif_open_resource_type()\n * in order to rollback \"creates\" and \"take-overs\" in case the load fails.\n */\nstruct opened_resource_type\n{\n    struct opened_resource_type* next;\n\n    ErlNifResourceFlags op;\n    ErlNifResourceType* type;\n    ErlNifResourceTypeInit new_callbacks;\n};\nstatic struct opened_resource_type* opened_rt_list = NULL;\n\nstatic\nErlNifResourceType* open_resource_type(ErlNifEnv* env,\n                                       const char* name_str,\n                                       const ErlNifResourceTypeInit* init,\n                                       ErlNifResourceFlags flags,\n                                       ErlNifResourceFlags* tried,\n                                       size_t sizeof_init)\n{\n    ErlNifResourceType* type = NULL;\n    ErlNifResourceFlags op = flags;\n    Eterm module_am, name_am;\n\n    ASSERT(erts_thr_progress_is_blocking());\n    module_am = make_atom(env->mod_nif->mod->module);\n    name_am = enif_make_atom(env, name_str);\n\n    type = find_resource_type(module_am, name_am);\n    if (type == NULL) {\n\tif (flags & ERL_NIF_RT_CREATE) {\n\t    type = erts_alloc(ERTS_ALC_T_NIF,\n\t\t\t      sizeof(struct enif_resource_type_t));\n\t    type->module = module_am;\n\t    type->name = name_am;\n\t    erts_refc_init(&type->refc, 1);\n\t    op = ERL_NIF_RT_CREATE;\n\t#ifdef DEBUG\n\t    type->dtor = (void*)1;\n\t    type->owner = (void*)2;\n\t    type->prev = (void*)3;\n\t    type->next = (void*)4;\n\t#endif\n\t}\n    }\n    else {\n\tif (flags & ERL_NIF_RT_TAKEOVER) {\n\t    op = ERL_NIF_RT_TAKEOVER;\n\t}\n\telse {\n\t    type = NULL;\n\t}\n    }\n    if (type != NULL) {\n\tstruct opened_resource_type* ort = erts_alloc(ERTS_ALC_T_TMP,\n\t\t\t\t\t\tsizeof(struct opened_resource_type));\n\tort->op = op;\n\tort->type = type;\n        sys_memzero(&ort->new_callbacks, sizeof(ErlNifResourceTypeInit));\n        ASSERT(sizeof_init > 0 && sizeof_init <= sizeof(ErlNifResourceTypeInit));\n        sys_memcpy(&ort->new_callbacks, init, sizeof_init);\n\tort->next = opened_rt_list;\n\topened_rt_list = ort;\n    }\n    if (tried != NULL) {\n\t*tried = op;\n    }\n    return type;\n}\n\nErlNifResourceType*\nenif_open_resource_type(ErlNifEnv* env,\n                        const char* module_str,\n                        const char* name_str,\n\t\t\tErlNifResourceDtor* dtor,\n\t\t\tErlNifResourceFlags flags,\n\t\t\tErlNifResourceFlags* tried)\n{\n    ErlNifResourceTypeInit init =  {dtor, NULL};\n    ASSERT(module_str == NULL); /* for now... */\n    return open_resource_type(env, name_str, &init, flags, tried,\n                              sizeof(init));\n}\n\nErlNifResourceType*\nenif_open_resource_type_x(ErlNifEnv* env,\n                          const char* name_str,\n                          const ErlNifResourceTypeInit* init,\n                          ErlNifResourceFlags flags,\n                          ErlNifResourceFlags* tried)\n{\n    return open_resource_type(env, name_str, init, flags, tried,\n                              env->mod_nif->entry.sizeof_ErlNifResourceTypeInit);\n}\n\nstatic void commit_opened_resource_types(struct erl_module_nif* lib)\n{\n    while (opened_rt_list) {\n\tstruct opened_resource_type* ort = opened_rt_list;\n\n\tErlNifResourceType* type = ort->type;\n\n\tif (ort->op == ERL_NIF_RT_CREATE) {\n\t    type->prev = &resource_type_list;\n\t    type->next = resource_type_list.next;\n\t    type->next->prev = type;\n\t    type->prev->next = type;\n\t}\n\telse { /* ERL_NIF_RT_TAKEOVER */\n\t    steal_resource_type(type);\n\t}\n\n\ttype->owner = lib;\n\ttype->dtor = ort->new_callbacks.dtor;\n        type->stop = ort->new_callbacks.stop;\n        type->down = ort->new_callbacks.down;\n\n\tif (type->dtor != NULL) {\n\t    erts_refc_inc(&lib->rt_dtor_cnt, 1);\n\t}\n\terts_refc_inc(&lib->rt_cnt, 1);\n\n\topened_rt_list = ort->next;\n\terts_free(ERTS_ALC_T_TMP, ort);\n    }\n}\n\nstatic void rollback_opened_resource_types(void)\n{\n    while (opened_rt_list) {\n\tstruct opened_resource_type* ort = opened_rt_list;\n\n\tif (ort->op == ERL_NIF_RT_CREATE) {\n\t    erts_free(ERTS_ALC_T_NIF, ort->type);\n\t}\n\n\topened_rt_list = ort->next;\n\terts_free(ERTS_ALC_T_TMP, ort);\n    }\n}\n\n#ifdef ARCH_64\n#  define ERTS_RESOURCE_DYING_FLAG (((Uint) 1) << 63)\n#else\n#  define ERTS_RESOURCE_DYING_FLAG (((Uint) 1) << 31)\n#endif\n#define ERTS_RESOURCE_REFC_MASK (~ERTS_RESOURCE_DYING_FLAG)\n\nstatic ERTS_INLINE void\nrmon_set_dying(ErtsResourceMonitors *rms)\n{\n    rms->refc |= ERTS_RESOURCE_DYING_FLAG;\n}\n\nstatic ERTS_INLINE int\nrmon_is_dying(ErtsResourceMonitors *rms)\n{\n    return !!(rms->refc & ERTS_RESOURCE_DYING_FLAG);\n}\n\nstatic ERTS_INLINE void\nrmon_refc_inc(ErtsResourceMonitors *rms)\n{\n    rms->refc++;\n}\n\nstatic ERTS_INLINE Uint\nrmon_refc_dec_read(ErtsResourceMonitors *rms)\n{\n    Uint res;\n    ASSERT((rms->refc & ERTS_RESOURCE_REFC_MASK) != 0);\n    res = --rms->refc;\n    return res & ERTS_RESOURCE_REFC_MASK;\n}\n\nstatic ERTS_INLINE void\nrmon_refc_dec(ErtsResourceMonitors *rms)\n{\n    ASSERT((rms->refc & ERTS_RESOURCE_REFC_MASK) != 0);\n    --rms->refc;\n}\n\nstatic ERTS_INLINE Uint\nrmon_refc_read(ErtsResourceMonitors *rms)\n{\n    return rms->refc & ERTS_RESOURCE_REFC_MASK;\n}\n\nstatic int dtor_demonitor(ErtsMonitor* mon, void* context, Sint reds)\n{\n    ASSERT(erts_monitor_is_origin(mon));\n    ASSERT(is_internal_pid(mon->other.item));\n\n    erts_proc_sig_send_demonitor(mon);\n    return 1;\n}\n\n#ifdef DEBUG\nint erts_dbg_is_resource_dying(ErtsResource* resource)\n{\n    return resource->monitors && rmon_is_dying(resource->monitors);\n}\n#endif\n\n#define NIF_RESOURCE_DTOR &nif_resource_dtor_prologue\n\nstatic void run_resource_dtor(void* vbin);\n \nstatic int nif_resource_dtor_prologue(Binary* bin)\n{\n    /*\n     * Schedule user resource destructor as aux work to get a context\n     * where we know what locks we have for example.\n     */\n    Uint sched_id = erts_get_scheduler_id();\n    if (!sched_id)\n        sched_id = 1;\n    erts_schedule_misc_aux_work(sched_id, run_resource_dtor, bin);\n    return 0; /* don't free */\n}\n \nstatic void run_resource_dtor(void* vbin)\n{\n    Binary* bin = (Binary*) vbin;\n    ErtsResource* resource = (ErtsResource*) ERTS_MAGIC_BIN_UNALIGNED_DATA(bin);\n    ErlNifResourceType* type = resource->type;\n    ASSERT(ERTS_MAGIC_BIN_DESTRUCTOR(bin) == NIF_RESOURCE_DTOR);\n\n    if (resource->monitors) {\n        ErtsResourceMonitors* rm = resource->monitors;\n        int kill;\n        ErtsMonitor *root;\n        Uint refc;\n\n        ASSERT(type->down);\n        erts_mtx_lock(&rm->lock);\n        ASSERT(erts_refc_read(&bin->intern.refc, 0) == 0);\n        kill = !rmon_is_dying(rm);\n        if (kill) {\n            rmon_set_dying(rm);\n            root = rm->root;\n            rm->root = NULL;\n        }\n        refc = rmon_refc_read(rm);\n        erts_mtx_unlock(&rm->lock);\n\n        if (kill)\n            erts_monitor_tree_foreach_delete(&root,\n                                             dtor_demonitor,\n                                             NULL);\n\n        /*\n         * If resource->monitors->refc != 0 there are\n         * outstanding references to the resource from\n         * monitors that has not been removed yet.\n         * nif_resource_dtor_prologue() will be called again when this\n         * reference count reach zero.\n         */\n        if (refc != 0)\n            return; /* we'll be back... */\n        erts_mtx_destroy(&rm->lock);\n    }\n\n    if (type->dtor != NULL) {\n        struct enif_msg_environment_t msg_env;\n        pre_nif_noproc(&msg_env, type->owner, NULL);\n\ttype->dtor(&msg_env.env, resource->data);\n        post_nif_noproc(&msg_env);\n    }\n    if (erts_refc_dectest(&type->refc, 0) == 0) {\n\tASSERT(type->next == NULL);\n\tASSERT(type->owner != NULL);\n\tASSERT(type->owner->mod == NULL);\n\tsteal_resource_type(type);\n\terts_free(ERTS_ALC_T_NIF, type);\n    }\n    erts_magic_binary_free((Binary*)vbin);\n}\n\nvoid erts_resource_stop(ErtsResource* resource, ErlNifEvent e,\n                        int is_direct_call)\n{\n    struct enif_msg_environment_t msg_env;\n    ASSERT(resource->type->stop);\n    pre_nif_noproc(&msg_env, resource->type->owner, NULL);\n    resource->type->stop(&msg_env.env, resource->data, e, is_direct_call);\n    post_nif_noproc(&msg_env);\n}\n\nvoid erts_nif_demonitored(ErtsResource* resource)\n{\n    ErtsResourceMonitors* rmp = resource->monitors;\n    ErtsBinary* bin = ERTS_MAGIC_BIN_FROM_UNALIGNED_DATA(resource);\n    int free_me;\n\n    ASSERT(rmp);\n    ASSERT(resource->type->down);\n\n    erts_mtx_lock(&rmp->lock);\n    free_me = ((rmon_refc_dec_read(rmp) == 0) & !!rmon_is_dying(rmp));\n    erts_mtx_unlock(&rmp->lock);\n\n    if (free_me)\n        erts_bin_free(&bin->binary);\n}\n\nvoid erts_fire_nif_monitor(ErtsMonitor *tmon)\n{\n    ErtsResource* resource;\n    ErtsMonitorData *mdp;\n    ErtsMonitor *omon;\n    ErtsBinary* bin;\n    struct enif_msg_environment_t msg_env;\n    ErlNifPid nif_pid;\n    ErlNifMonitor nif_monitor;\n    ErtsResourceMonitors* rmp;\n    Uint mrefc, brefc;\n    int active, is_dying;\n\n    ASSERT(tmon->type == ERTS_MON_TYPE_RESOURCE);\n    ASSERT(erts_monitor_is_target(tmon));\n\n    resource = tmon->other.ptr;\n    bin = ERTS_MAGIC_BIN_FROM_UNALIGNED_DATA(resource);\n    rmp = resource->monitors;\n\n    mdp = erts_monitor_to_data(tmon);\n    omon = &mdp->origin;\n\n    ASSERT(rmp);\n    ASSERT(resource->type->down);\n\n    erts_mtx_lock(&rmp->lock);\n\n    mrefc = rmon_refc_dec_read(rmp);\n    is_dying = rmon_is_dying(rmp);\n    active = !is_dying && erts_monitor_is_in_table(omon);\n\n    if (active) {\n        erts_monitor_tree_delete(&rmp->root, omon);\n        brefc = (Uint) erts_refc_inc_unless(&bin->binary.intern.refc, 0, 0);\n    }\n\n    erts_mtx_unlock(&rmp->lock);\n\n    if (!active) {\n        ASSERT(!is_dying || erts_refc_read(&bin->binary.intern.refc, 0) == 0);\n        if (is_dying && mrefc == 0)\n            erts_bin_free(&bin->binary);\n        erts_monitor_release(tmon);\n    }\n    else {\n        if (brefc > 0) {\n            ASSERT(is_internal_pid(omon->other.item));\n            erts_ref_to_driver_monitor(mdp->ref, &nif_monitor);\n            nif_pid.pid = omon->other.item;\n            pre_nif_noproc(&msg_env, resource->type->owner, NULL);\n            resource->type->down(&msg_env.env, resource->data, &nif_pid, &nif_monitor);\n            post_nif_noproc(&msg_env);\n\n            erts_bin_release(&bin->binary);\n        }\n\n        erts_monitor_release_both(mdp);\n    }\n}\n\nvoid* enif_alloc_resource(ErlNifResourceType* type, size_t data_sz)\n{\n    size_t magic_sz = offsetof(ErtsResource,data);\n    Binary* bin;\n    ErtsResource* resource;\n    size_t monitors_offs;\n\n    if (type->down) {\n        /* Put ErtsResourceMonitors after user data and properly aligned */\n        monitors_offs = ((data_sz + ERTS_ALLOC_ALIGN_BYTES - 1)\n                         & ~((size_t)ERTS_ALLOC_ALIGN_BYTES - 1));\n        magic_sz += monitors_offs + sizeof(ErtsResourceMonitors);\n    }\n    else {\n        ERTS_UNDEF(monitors_offs, 0);\n        magic_sz += data_sz;\n    }\n    bin = erts_create_magic_binary_x(magic_sz, NIF_RESOURCE_DTOR,\n                                     ERTS_ALC_T_BINARY,\n                                     1); /* unaligned */\n    resource = ERTS_MAGIC_BIN_UNALIGNED_DATA(bin);\n\n    ASSERT(type->owner && type->next && type->prev); /* not allowed in load/upgrade */\n    resource->type = type;\n    erts_refc_inc(&bin->intern.refc, 1);\n#ifdef DEBUG\n    erts_refc_init(&resource->nif_refc, 1);\n#endif\n    erts_refc_inc(&resource->type->refc, 2);\n    if (type->down) {\n        resource->monitors = (ErtsResourceMonitors*) (resource->data + monitors_offs);\n        erts_mtx_init(&resource->monitors->lock, \"resource_monitors\", NIL,\n            ERTS_LOCK_FLAGS_CATEGORY_GENERIC);\n        resource->monitors->root = NULL;\n        resource->monitors->refc = 0;\n        resource->monitors->user_data_sz = data_sz;\n    }\n    else {\n        resource->monitors = NULL;\n    }\n    return resource->data;\n}\n\nvoid enif_release_resource(void* obj)\n{\n    ErtsResource* resource = DATA_TO_RESOURCE(obj);\n    ErtsBinary* bin = ERTS_MAGIC_BIN_FROM_UNALIGNED_DATA(resource);\n\n    ASSERT(ERTS_MAGIC_BIN_DESTRUCTOR(bin) == NIF_RESOURCE_DTOR);\n    ASSERT(erts_refc_read(&bin->binary.intern.refc, 0) != 0);\n#ifdef DEBUG\n    erts_refc_dec(&resource->nif_refc, 0);\n#endif\n    erts_bin_release(&bin->binary);\n}\n\nvoid enif_keep_resource(void* obj)\n{\n    ErtsResource* resource = DATA_TO_RESOURCE(obj);\n    ErtsBinary* bin = ERTS_MAGIC_BIN_FROM_UNALIGNED_DATA(resource);\n\n    ASSERT(ERTS_MAGIC_BIN_DESTRUCTOR(bin) == NIF_RESOURCE_DTOR);\n    ASSERT(erts_refc_read(&bin->binary.intern.refc, 0) != 0);\n#ifdef DEBUG\n    erts_refc_inc(&resource->nif_refc, 1);\n#endif\n    erts_refc_inc(&bin->binary.intern.refc, 2);\n}\n\nEterm erts_bld_resource_ref(Eterm** hpp, ErlOffHeap* oh, ErtsResource* resource)\n{\n    ErtsBinary* bin = ERTS_MAGIC_BIN_FROM_UNALIGNED_DATA(resource);\n    ASSERT(erts_refc_read(&bin->binary.intern.refc, 0) != 0);\n    return erts_mk_magic_ref(hpp, oh, &bin->binary);\n}\n\nERL_NIF_TERM enif_make_resource(ErlNifEnv* env, void* obj)\n{\n    ErtsResource* resource = DATA_TO_RESOURCE(obj);\n    ErtsBinary* bin = ERTS_MAGIC_BIN_FROM_UNALIGNED_DATA(resource);\n    Eterm* hp = alloc_heap(env, ERTS_MAGIC_REF_THING_SIZE);\n    ASSERT(erts_refc_read(&bin->binary.intern.refc, 0) != 0);\n    return erts_mk_magic_ref(&hp, &MSO(env->proc), &bin->binary);\n}\n\nERL_NIF_TERM enif_make_resource_binary(ErlNifEnv* env, void* obj,\n\t\t\t\t       const void* data, size_t size)\n{\n    ErtsResource* resource = DATA_TO_RESOURCE(obj);\n    ErtsBinary* bin = ERTS_MAGIC_BIN_FROM_UNALIGNED_DATA(resource);\n    ErlOffHeap *ohp = &MSO(env->proc);\n    Eterm* hp = alloc_heap(env,PROC_BIN_SIZE);\n    ProcBin* pb = (ProcBin *) hp;\n\n    pb->thing_word = HEADER_PROC_BIN;\n    pb->size = size;\n    pb->next = ohp->first;\n    ohp->first = (struct erl_off_heap_header*) pb;\n    pb->val = &bin->binary;\n    pb->bytes = (byte*) data;\n    pb->flags = 0;\n\n    OH_OVERHEAD(ohp, size / sizeof(Eterm));\n    erts_refc_inc(&bin->binary.intern.refc, 1);\n\n    return make_binary(hp);\n}\n\nint enif_get_resource(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifResourceType* type,\n\t\t      void** objp)\n{\n    Binary* mbin;\n    ErtsResource* resource;\n    if (is_internal_magic_ref(term))\n\tmbin = erts_magic_ref2bin(term);\n    else {\n        Eterm *hp;\n        if (!is_binary(term))\n            return 0;\n        hp = binary_val(term);\n        if (thing_subtag(*hp) != REFC_BINARY_SUBTAG)\n            return 0;\n        /*\n        if (((ProcBin *) hp)->size != 0) {\t\n            return 0; / * Or should we allow \"resource binaries\" as handles? * /\n        }\n        */\n        mbin = ((ProcBin *) hp)->val;\n        if (!(mbin->intern.flags & BIN_FLAG_MAGIC))\n            return 0;\n    }\n    resource = (ErtsResource*) ERTS_MAGIC_BIN_UNALIGNED_DATA(mbin);\n    if (ERTS_MAGIC_BIN_DESTRUCTOR(mbin) != NIF_RESOURCE_DTOR\n\t|| resource->type != type) {\t\n\treturn 0;\n    }\n    *objp = resource->data;\n    return 1;\n}\n\nsize_t enif_sizeof_resource(void* obj)\n{\n    ErtsResource* resource = DATA_TO_RESOURCE(obj);\n    if (resource->monitors) {\n        return resource->monitors->user_data_sz;\n    }\n    else {\n        Binary* bin = &ERTS_MAGIC_BIN_FROM_UNALIGNED_DATA(resource)->binary;\n        return ERTS_MAGIC_BIN_UNALIGNED_DATA_SIZE(bin) - offsetof(ErtsResource,data);\n    }\n}\n\n\nvoid* enif_dlopen(const char* lib,\n\t\t  void (*err_handler)(void*,const char*), void* err_arg)\n{\n    ErtsSysDdllError errdesc = ERTS_SYS_DDLL_ERROR_INIT;\n    void* handle;\n    void* init_func;\n    if (erts_sys_ddll_open(lib, &handle, &errdesc) == ERL_DE_NO_ERROR) {\n\tif (erts_sys_ddll_load_nif_init(handle, &init_func, &errdesc) == ERL_DE_NO_ERROR) {\n\t    erts_sys_ddll_call_nif_init(init_func);\n\t}\n    }\n    else {\n\tif (err_handler != NULL) {\n\t    (*err_handler)(err_arg, errdesc.str);\n\t}\n\thandle = NULL;\n    }\n    erts_sys_ddll_free_error(&errdesc);\n    return handle;\n}\n\nvoid* enif_dlsym(void* handle, const char* symbol,\n\t\t void (*err_handler)(void*,const char*), void* err_arg)\n{\n    ErtsSysDdllError errdesc = ERTS_SYS_DDLL_ERROR_INIT;\n    void* ret;\n    if (erts_sys_ddll_sym2(handle, symbol, &ret, &errdesc) != ERL_DE_NO_ERROR) {\n\tif (err_handler != NULL) {\n\t    (*err_handler)(err_arg, errdesc.str);\n\t}\n\terts_sys_ddll_free_error(&errdesc);\n\treturn NULL;\n    }\n    return ret;\n}\n\nint enif_consume_timeslice(ErlNifEnv* env, int percent)\n{\n    Process *proc;\n    Sint reds;\n    int sched;\n\n    execution_state(env, &proc, &sched);\n\n    if (sched < 0)\n        return 0; /* no-op on dirty scheduler */\n\n    ASSERT(is_proc_bound(env) && percent >= 1 && percent <= 100);\n    if (percent < 1) percent = 1;\n    else if (percent > 100) percent = 100;\n\n    reds = ((CONTEXT_REDS+99) / 100) * percent;\n    ASSERT(reds > 0 && reds <= CONTEXT_REDS);\n    BUMP_REDS(proc, reds);\n    return ERTS_BIF_REDS_LEFT(proc) == 0;\n}\n\nstatic ERTS_INLINE void\nnif_export_cleanup_nif_mod(NifExport *ep)\n{\n    if (erts_refc_dectest(&ep->m->rt_dtor_cnt, 0) == 0 && ep->m->mod == NULL)\n\tclose_lib(ep->m);\n    ep->m = NULL;\n}\n\nvoid\nerts_nif_export_cleanup_nif_mod(NifExport *ep)\n{\n    nif_export_cleanup_nif_mod(ep);\n}\n\nstatic ERTS_INLINE void\nnif_export_restore(Process *c_p, NifExport *ep, Eterm res)\n{\n    erts_nif_export_restore(c_p, ep, res);\n    ASSERT(ep->m);\n    nif_export_cleanup_nif_mod(ep);\n}\n\n\n\n/*\n * Finalize a dirty NIF call. This function is scheduled to cause the VM to\n * switch the process off a dirty scheduler thread and back onto a regular\n * scheduler thread, and then return the result from the dirty NIF. It also\n * restores the original NIF MFA when necessary based on the value of\n * ep->func set by execute_dirty_nif via init_nif_sched_data -- non-NULL\n * means restore, NULL means do not restore.\n */\nstatic ERL_NIF_TERM\ndirty_nif_finalizer(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])\n{\n    Process* proc;\n    NifExport* ep;\n\n    execution_state(env, &proc, NULL);\n\n    ASSERT(argc == 1);\n    ASSERT(!ERTS_SCHEDULER_IS_DIRTY(erts_proc_sched_data(proc)));\n    ep = (NifExport*) ERTS_PROC_GET_NIF_TRAP_EXPORT(proc);\n    ASSERT(ep);\n    nif_export_restore(proc, ep, argv[0]);\n    return argv[0];\n}\n\n/* Finalize a dirty NIF call that raised an exception.  Otherwise same as\n * the dirty_nif_finalizer() function.\n */\nstatic ERL_NIF_TERM\ndirty_nif_exception(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])\n{\n    ERL_NIF_TERM ret;\n    Process* proc;\n    NifExport* ep;\n    Eterm exception;\n\n    execution_state(env, &proc, NULL);\n\n    ASSERT(argc == 1);\n    ASSERT(!ERTS_SCHEDULER_IS_DIRTY(erts_proc_sched_data(proc)));\n    ep = (NifExport*) ERTS_PROC_GET_NIF_TRAP_EXPORT(proc);\n    ASSERT(ep);\n    exception = argv[0]; /* argv overwritten by restore below... */\n    nif_export_cleanup_nif_mod(ep);\n    ret = enif_raise_exception(env, exception);\n\n    /* Restore orig info for error and clear nif export in handle_error() */\n    proc->freason |= EXF_RESTORE_NIF;\n    return ret;\n}\n\n/*\n * Dirty NIF scheduling wrapper function. Schedule a dirty NIF to execute.\n * The dirty scheduler thread type (CPU or I/O) is indicated in flags\n * parameter.\n */\nstatic ERTS_INLINE ERL_NIF_TERM\nschedule_dirty_nif(ErlNifEnv* env, int flags, NativeFunPtr fp,\n\t\t   Eterm func_name, int argc, const ERL_NIF_TERM argv[])\n{\n    Process* proc;\n\n    ASSERT(is_atom(func_name));\n    ASSERT(fp);\n\n    ASSERT(flags==ERL_NIF_DIRTY_JOB_IO_BOUND || flags==ERL_NIF_DIRTY_JOB_CPU_BOUND);\n\n    execution_state(env, &proc, NULL);\n\n    (void) erts_atomic32_read_bset_nob(&proc->state,\n\t\t\t\t\t   (ERTS_PSFLG_DIRTY_CPU_PROC\n\t\t\t\t\t    | ERTS_PSFLG_DIRTY_IO_PROC),\n\t\t\t\t\t   (flags == ERL_NIF_DIRTY_JOB_CPU_BOUND\n\t\t\t\t\t    ? ERTS_PSFLG_DIRTY_CPU_PROC\n\t\t\t\t\t    : ERTS_PSFLG_DIRTY_IO_PROC));\n\n    return schedule(env, fp, NULL, proc->current->module, func_name, argc, argv);\n}\n\nstatic ERTS_INLINE ERL_NIF_TERM\nstatic_schedule_dirty_nif(ErlNifEnv* env, erts_aint32_t dirty_psflg,\n\t\t\t     int argc, const ERL_NIF_TERM argv[])\n{\n    Process *proc;\n    NifExport *ep;\n    Eterm mod, func;\n    NativeFunPtr fp;\n\n    execution_state(env, &proc, NULL);\n\n    /*\n     * Called in order to schedule statically determined\n     * dirty NIF calls...\n     *\n     * Note that 'current' does not point into a NifExport\n     * structure; only a structure with similar\n     * parts (located in code).\n     */\n\n    ep = ErtsContainerStruct(proc->current, NifExport, exp.info.mfa);\n    mod = proc->current->module;\n    func = proc->current->function;\n    fp = (NativeFunPtr) ep->func;\n\n    ASSERT(is_atom(mod) && is_atom(func));\n    ASSERT(fp);\n\n    (void) erts_atomic32_read_bset_nob(&proc->state,\n\t\t\t\t\t   (ERTS_PSFLG_DIRTY_CPU_PROC\n\t\t\t\t\t    | ERTS_PSFLG_DIRTY_IO_PROC),\n\t\t\t\t\t   dirty_psflg);\n\n    return schedule(env, fp, NULL, mod, func, argc, argv);\n}\n\nstatic ERL_NIF_TERM\nstatic_schedule_dirty_io_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])\n{\n    return static_schedule_dirty_nif(env, ERTS_PSFLG_DIRTY_IO_PROC, argc, argv);\n}\n\nstatic ERL_NIF_TERM\nstatic_schedule_dirty_cpu_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])\n{\n    return static_schedule_dirty_nif(env, ERTS_PSFLG_DIRTY_CPU_PROC, argc, argv);\n}\n\n\n/*\n * NIF execution wrapper used by enif_schedule_nif() for regular NIFs. It\n * calls the actual NIF, restores original NIF MFA if necessary, and\n * then returns the NIF result.\n */\nstatic ERL_NIF_TERM\nexecute_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])\n{\n    Process* proc;\n    NativeFunPtr fp;\n    NifExport* ep;\n    ERL_NIF_TERM result;\n\n    execution_state(env, &proc, NULL);\n\n    ep = ErtsContainerStruct(proc->current, NifExport, exp.info.mfa);\n    fp = ep->func;\n    ASSERT(ep);\n    ASSERT(!env->exception_thrown);\n\n    fp = (NativeFunPtr) ep->func;\n\n#ifdef DEBUG\n    ep->func = ERTS_DBG_NIF_NOT_SCHED_MARKER;\n#endif\n\n    result = (*fp)(env, argc, argv);\n\n    ASSERT(ep == ERTS_PROC_GET_NIF_TRAP_EXPORT(proc));\n\n    if (is_value(result) || proc->freason != TRAP) {\n\t/* Done (not rescheduled)... */\n\tASSERT(ep->func == ERTS_DBG_NIF_NOT_SCHED_MARKER);\n\tif (!env->exception_thrown)\n\t    nif_export_restore(proc, ep, result);\n\telse {\n\t    nif_export_cleanup_nif_mod(ep);\n\t    /*\n\t     * Restore orig info for error and clear nif\n\t     * export in handle_error()\n\t     */\n\t    proc->freason |= EXF_RESTORE_NIF;\n\t}\n    }\n\n#ifdef DEBUG\n    if (ep->func == ERTS_DBG_NIF_NOT_SCHED_MARKER)\n\tep->func = NULL;\n#endif\n\n    return result;\n}\n\nERL_NIF_TERM\nenif_schedule_nif(ErlNifEnv* env, const char* fun_name, int flags,\n\t\t  ERL_NIF_TERM (*fp)(ErlNifEnv*, int, const ERL_NIF_TERM[]),\n\t\t  int argc, const ERL_NIF_TERM argv[])\n{\n    Process* proc;\n    ERL_NIF_TERM fun_name_atom, result;\n    int scheduler;\n\n    if (argc > MAX_ARG)\n\treturn enif_make_badarg(env);\n    fun_name_atom = enif_make_atom(env, fun_name);\n    if (enif_is_exception(env, fun_name_atom))\n\treturn fun_name_atom;\n\n    execution_state(env, &proc, &scheduler);\n    if (scheduler <= 0) {\n\tif (scheduler == 0)\n\t    enif_make_badarg(env);\n\terts_proc_lock(proc, ERTS_PROC_LOCK_MAIN);\n    }\n\n    if (flags == 0)\n\tresult = schedule(env, execute_nif, fp, proc->current->module,\n\t\t\t  fun_name_atom, argc, argv);\n    else if (!(flags & ~(ERL_NIF_DIRTY_JOB_IO_BOUND|ERL_NIF_DIRTY_JOB_CPU_BOUND))) {\n\tresult = schedule_dirty_nif(env, flags, fp, fun_name_atom, argc, argv);\n    }\n    else\n\tresult = enif_make_badarg(env);\n\n    if (scheduler < 0)\n\terts_proc_unlock(proc, ERTS_PROC_LOCK_MAIN);\n\n    return result;\n}\n\nint\nenif_thread_type(void)\n{\n    ErtsSchedulerData *esdp = erts_get_scheduler_data();\n\n    if (!esdp)\n\treturn ERL_NIF_THR_UNDEFINED;\n\n    switch (esdp->type) {\n    case ERTS_SCHED_NORMAL:\n\treturn ERL_NIF_THR_NORMAL_SCHEDULER;\n    case ERTS_SCHED_DIRTY_CPU:\n\treturn ERL_NIF_THR_DIRTY_CPU_SCHEDULER;\n    case ERTS_SCHED_DIRTY_IO:\n        return ERL_NIF_THR_DIRTY_IO_SCHEDULER;\n    default:\n        ERTS_INTERNAL_ERROR(\"Invalid scheduler type\");\n\treturn -1;\n    }\n}\n\n/* Maps */\n\nint enif_is_map(ErlNifEnv* env, ERL_NIF_TERM term)\n{\n    return is_map(term);\n}\n\nint enif_get_map_size(ErlNifEnv* env, ERL_NIF_TERM term, size_t *size)\n{\n    if (is_flatmap(term)) {\n\tflatmap_t *mp;\n\tmp    = (flatmap_t*)flatmap_val(term);\n\t*size = flatmap_get_size(mp);\n\treturn 1;\n    }\n    else if (is_hashmap(term)) {\n        *size = hashmap_size(term);\n        return 1;\n    }\n    return 0;\n}\n\nERL_NIF_TERM enif_make_new_map(ErlNifEnv* env)\n{\n    Eterm* hp = alloc_heap(env,MAP_HEADER_FLATMAP_SZ+1);\n    Eterm tup;\n    flatmap_t *mp;\n\n    tup   = make_tuple(hp);\n    *hp++ = make_arityval(0);\n    mp    = (flatmap_t*)hp;\n    mp->thing_word = MAP_HEADER_FLATMAP;\n    mp->size = 0;\n    mp->keys = tup;\n\n    return make_flatmap(mp);\n}\n\nint enif_make_map_from_arrays(ErlNifEnv *env,\n                              ERL_NIF_TERM keys[],\n                              ERL_NIF_TERM values[],\n                              size_t cnt,\n                              ERL_NIF_TERM *map_out)\n{\n    ErtsHeapFactory factory;\n    int succeeded;\n\n#ifdef ERTS_NIF_ASSERT_IN_ENV\n    size_t index = 0;\n\n    while (index < cnt) {\n        ASSERT_IN_ENV(env, keys[index], index, \"key\");\n        ASSERT_IN_ENV(env, values[index], index, \"value\");\n        index++;\n    }\n#endif\n\n    flush_env(env);\n\n    erts_factory_proc_prealloc_init(&factory, env->proc,\n        cnt * 2 + MAP_HEADER_FLATMAP_SZ + 1);\n\n    (*map_out) = erts_map_from_ks_and_vs(&factory, keys, values, cnt);\n    succeeded = (*map_out) != THE_NON_VALUE;\n\n    if (!succeeded) {\n        erts_factory_undo(&factory);\n    }\n\n    erts_factory_close(&factory);\n\n    cache_env(env);\n\n    return succeeded;\n}\n\nint enif_make_map_put(ErlNifEnv* env,\n\t              Eterm map_in,\n\t\t      Eterm key,\n\t\t      Eterm value,\n\t\t      Eterm *map_out)\n{\n    if (!is_map(map_in)) {\n\treturn 0;\n    }\n    ASSERT_IN_ENV(env, map_in, 0, \"old map\");\n    ASSERT_IN_ENV(env, key, 0, \"key\");\n    ASSERT_IN_ENV(env, value, 0, \"value\");\n\n    flush_env(env);\n    *map_out = erts_maps_put(env->proc, key, value, map_in);\n    cache_env(env);\n    return 1;\n}\n\nint enif_get_map_value(ErlNifEnv* env,\n\t               Eterm map,\n\t\t       Eterm key,\n\t\t       Eterm *value)\n{\n    const Eterm *ret;\n    if (!is_map(map)) {\n\treturn 0;\n    }\n    ret = erts_maps_get(key, map);\n    if (ret) {\n        *value = *ret;\n        return 1;\n    }\n    return 0;\n}\n\nint enif_make_map_update(ErlNifEnv* env,\n\t                 Eterm map_in,\n\t\t\t Eterm key,\n\t\t\t Eterm value,\n\t\t\t Eterm *map_out)\n{\n    int res;\n    if (!is_map(map_in)) {\n\treturn 0;\n    }\n\n    ASSERT_IN_ENV(env, map_in, 0, \"old map\");\n    ASSERT_IN_ENV(env, key, 0, \"key\");\n    ASSERT_IN_ENV(env, value, 0, \"value\");\n\n    flush_env(env);\n    res = erts_maps_update(env->proc, key, value, map_in, map_out);\n    cache_env(env);\n    return res;\n}\n\nint enif_make_map_remove(ErlNifEnv* env,\n\t                 Eterm map_in,\n\t\t\t Eterm key,\n\t\t\t Eterm *map_out)\n{\n    if (!is_map(map_in)) {\n\treturn 0;\n    }\n    flush_env(env);\n    (void) erts_maps_take(env->proc, key, map_in, map_out, NULL);\n    cache_env(env);\n    return 1;\n}\n\nint enif_map_iterator_create(ErlNifEnv *env,\n\t                     Eterm map,\n\t\t\t     ErlNifMapIterator *iter,\n\t\t\t     ErlNifMapIteratorEntry entry)\n{\n    if (is_flatmap(map)) {\n\tflatmap_t *mp = (flatmap_t*)flatmap_val(map);\n\tsize_t offset;\n\n\tswitch (entry) {\n\t    case ERL_NIF_MAP_ITERATOR_FIRST: offset = 0; break;\n\t    case ERL_NIF_MAP_ITERATOR_LAST: offset = flatmap_get_size(mp) - 1; break;\n\t    default: goto error;\n\t}\n\n\t/* empty maps are ok but will leave the iterator\n\t * in bad shape.\n\t */\n\n\titer->map     = map;\n\titer->u.flat.ks = ((Eterm *)flatmap_get_keys(mp)) + offset;\n\titer->u.flat.vs = ((Eterm *)flatmap_get_values(mp)) + offset;\n\titer->size    = flatmap_get_size(mp);\n\titer->idx     = offset + 1;\n\n\treturn 1;\n    }\n    else if (is_hashmap(map)) {\n        iter->map = map;\n        iter->size = hashmap_size(map);\n        iter->u.hash.wstack = erts_alloc(ERTS_ALC_T_NIF, sizeof(ErtsDynamicWStack));\n        WSTACK_INIT(iter->u.hash.wstack, ERTS_ALC_T_NIF);\n\n        switch (entry) {\n\t    case ERL_NIF_MAP_ITERATOR_FIRST:\n                iter->idx = 1;\n                hashmap_iterator_init(&iter->u.hash.wstack->ws, map, 0);\n                iter->u.hash.kv = hashmap_iterator_next(&iter->u.hash.wstack->ws);\n                break;\n\t    case ERL_NIF_MAP_ITERATOR_LAST:\n                iter->idx = hashmap_size(map);\n                hashmap_iterator_init(&iter->u.hash.wstack->ws, map, 1);\n                iter->u.hash.kv = hashmap_iterator_prev(&iter->u.hash.wstack->ws);\n                break;\n\t    default:\n                goto error;\n\t}\n        ASSERT(!!iter->u.hash.kv == (iter->idx >= 1 &&\n                                     iter->idx <= iter->size));\n        return 1;\n    }\nerror:\n#ifdef DEBUG\n    iter->map = THE_NON_VALUE;\n#endif\n    return 0;\n}\n\nvoid enif_map_iterator_destroy(ErlNifEnv *env, ErlNifMapIterator *iter)\n{\n    if (is_hashmap(iter->map)) {\n        WSTACK_DESTROY(iter->u.hash.wstack->ws);\n        erts_free(ERTS_ALC_T_NIF, iter->u.hash.wstack);\n    }\n    else\n        ASSERT(is_flatmap(iter->map));\n\n#ifdef DEBUG\n    iter->map = THE_NON_VALUE;\n#endif\n}\n\nint enif_map_iterator_is_tail(ErlNifEnv *env, ErlNifMapIterator *iter)\n{\n    ASSERT(iter);\n    if (is_flatmap(iter->map)) {\n        ASSERT(iter->idx >= 0);\n        ASSERT(iter->idx <= flatmap_get_size(flatmap_val(iter->map)) + 1);\n        return (iter->size == 0 || iter->idx > iter->size);\n    }\n    else {\n        ASSERT(is_hashmap(iter->map));\n        return iter->idx > iter->size;\n    }\n}\n\nint enif_map_iterator_is_head(ErlNifEnv *env, ErlNifMapIterator *iter)\n{\n    ASSERT(iter);\n    if (is_flatmap(iter->map)) {\n        ASSERT(iter->idx >= 0);\n        ASSERT(iter->idx <= flatmap_get_size(flatmap_val(iter->map)) + 1);\n        return (iter->size == 0 || iter->idx == 0);\n    }\n    else {\n        ASSERT(is_hashmap(iter->map));\n        return iter->idx == 0;\n    }\n}\n\n\nint enif_map_iterator_next(ErlNifEnv *env, ErlNifMapIterator *iter)\n{\n    ASSERT(iter);\n    if (is_flatmap(iter->map)) {\n        if (iter->idx <= iter->size) {\n            iter->idx++;\n            iter->u.flat.ks++;\n            iter->u.flat.vs++;\n        }\n        return (iter->idx <= iter->size);\n    }\n    else {\n        ASSERT(is_hashmap(iter->map));\n\n        if (iter->idx <= hashmap_size(iter->map)) {\n            if (iter->idx < 1) {\n                hashmap_iterator_init(&iter->u.hash.wstack->ws, iter->map, 0);\n            }\n            iter->u.hash.kv = hashmap_iterator_next(&iter->u.hash.wstack->ws);\n            iter->idx++;\n            ASSERT(!!iter->u.hash.kv == (iter->idx <= iter->size));\n        }\n        return iter->idx <= iter->size;\n    }\n}\n\nint enif_map_iterator_prev(ErlNifEnv *env, ErlNifMapIterator *iter)\n{\n    ASSERT(iter);\n    if (is_flatmap(iter->map)) {\n        if (iter->idx > 0) {\n            iter->idx--;\n            iter->u.flat.ks--;\n            iter->u.flat.vs--;\n        }\n        return iter->idx > 0;\n    }\n    else {\n        ASSERT(is_hashmap(iter->map));\n\n        if (iter->idx > 0) {\n            if (iter->idx > iter->size) {\n                hashmap_iterator_init(&iter->u.hash.wstack->ws, iter->map, 1);\n            }\n            iter->u.hash.kv = hashmap_iterator_prev(&iter->u.hash.wstack->ws);\n            iter->idx--;\n            ASSERT(!!iter->u.hash.kv == (iter->idx > 0));\n        }\n        return iter->idx > 0;\n    }\n}\n\nint enif_map_iterator_get_pair(ErlNifEnv *env,\n\t\t\t       ErlNifMapIterator *iter,\n\t\t\t       Eterm *key,\n\t\t\t       Eterm *value)\n{\n    ASSERT(iter);\n    if (is_flatmap(iter->map)) {\n        if (iter->idx > 0 && iter->idx <= iter->size) {\n            ASSERT(iter->u.flat.ks >= flatmap_get_keys(flatmap_val(iter->map)) &&\n                   iter->u.flat.ks  < (flatmap_get_keys(flatmap_val(iter->map)) + flatmap_get_size(flatmap_val(iter->map))));\n            ASSERT(iter->u.flat.vs >= flatmap_get_values(flatmap_val(iter->map)) &&\n                   iter->u.flat.vs  < (flatmap_get_values(flatmap_val(iter->map)) + flatmap_get_size(flatmap_val(iter->map))));\n            *key   = *(iter->u.flat.ks);\n            *value = *(iter->u.flat.vs);\n            return 1;\n        }\n    }\n    else {\n        ASSERT(is_hashmap(iter->map));\n        if (iter->idx > 0 && iter->idx <= iter->size) {\n            *key   = CAR(iter->u.hash.kv);\n            *value = CDR(iter->u.hash.kv);\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint enif_monitor_process(ErlNifEnv* env, void* obj, const ErlNifPid* target_pid,\n                         ErlNifMonitor* monitor)\n{\n    ErtsResource* rsrc = DATA_TO_RESOURCE(obj);\n    Eterm tmp[ERTS_REF_THING_SIZE];\n    Eterm ref;\n    ErtsResourceMonitors *rm;\n    ErtsMonitorData *mdp;\n\n    ASSERT(ERTS_MAGIC_BIN_FROM_UNALIGNED_DATA(rsrc)->magic_binary.destructor\n           == NIF_RESOURCE_DTOR);\n    ASSERT(erts_refc_read(&ERTS_MAGIC_BIN_FROM_UNALIGNED_DATA(rsrc)->binary.intern.refc, 0) != 0);\n    ASSERT(!rsrc->monitors == !rsrc->type->down);\n\n    rm = rsrc->monitors;\n    if (!rm) {\n        ASSERT(!rsrc->type->down);\n        return -1;\n    }\n    ASSERT(rsrc->type->down);\n\n    if (target_pid->pid == am_undefined)\n        return 1;\n\n    ref = erts_make_ref_in_buffer(tmp);\n\n    mdp = erts_monitor_create(ERTS_MON_TYPE_RESOURCE, ref,\n                              (Eterm) rsrc, target_pid->pid, NIL);\n    erts_mtx_lock(&rm->lock);\n    ASSERT(!rmon_is_dying(rm));\n    erts_monitor_tree_insert(&rm->root, &mdp->origin);\n    rmon_refc_inc(rm);\n    erts_mtx_unlock(&rm->lock);\n\n    if (!erts_proc_sig_send_monitor(&mdp->target, target_pid->pid)) {\n        /* Failed to send monitor signal; cleanup... */\n#ifdef DEBUG\n        ErtsBinary* bin = ERTS_MAGIC_BIN_FROM_UNALIGNED_DATA(rsrc);\n#endif\n\n        erts_mtx_lock(&rm->lock);\n        ASSERT(!rmon_is_dying(rm));\n        erts_monitor_tree_delete(&rm->root, &mdp->origin);\n        rmon_refc_dec(rm);\n        ASSERT(erts_refc_read(&bin->binary.intern.refc, 1) != 0);\n        erts_mtx_unlock(&rm->lock);\n        erts_monitor_release_both(mdp);\n\n        return 1;\n    }\n\n    if (monitor)\n        erts_ref_to_driver_monitor(ref,monitor);\n\n    return 0;\n}\n\nERL_NIF_TERM enif_make_monitor_term(ErlNifEnv* env, const ErlNifMonitor* monitor)\n{\n    Eterm* hp = alloc_heap(env, ERTS_REF_THING_SIZE);\n    return erts_driver_monitor_to_ref(hp, monitor);\n}\n\nint enif_demonitor_process(ErlNifEnv* env, void* obj, const ErlNifMonitor* monitor)\n{\n    ErtsResource* rsrc = DATA_TO_RESOURCE(obj);\n#ifdef DEBUG\n    ErtsBinary* bin = ERTS_MAGIC_BIN_FROM_UNALIGNED_DATA(rsrc);\n#endif\n    ErtsResourceMonitors *rm;\n    ErtsMonitor *mon;\n    Eterm ref_heap[ERTS_REF_THING_SIZE];\n    Eterm ref;\n\n    ASSERT(bin->magic_binary.destructor == NIF_RESOURCE_DTOR);\n    ASSERT(erts_refc_read(&bin->binary.intern.refc, 0) != 0);\n\n    ref = erts_driver_monitor_to_ref(ref_heap, monitor);\n\n    rm = rsrc->monitors;\n    erts_mtx_lock(&rm->lock);\n    ASSERT(!rmon_is_dying(rm));\n    mon = erts_monitor_tree_lookup(rm->root, ref);\n    if (mon)\n        erts_monitor_tree_delete(&rm->root, mon);\n    erts_mtx_unlock(&rm->lock);\n\n    if (!mon)\n        return 1;\n\n    ASSERT(erts_monitor_is_origin(mon));\n    ASSERT(is_internal_pid(mon->other.item));\n\n    erts_proc_sig_send_demonitor(mon);\n\n    return 0;\n}\n\nint enif_compare_monitors(const ErlNifMonitor *monitor1,\n                          const ErlNifMonitor *monitor2)\n{\n    return sys_memcmp((void *) monitor1, (void *) monitor2,\n                      ERTS_REF_THING_SIZE*sizeof(Eterm));\n}\n\nErlNifIOQueue *enif_ioq_create(ErlNifIOQueueOpts opts)\n{\n    ErlNifIOQueue *q;\n\n    if (opts != ERL_NIF_IOQ_NORMAL)\n        return NULL;\n\n    q = enif_alloc(sizeof(ErlNifIOQueue));\n    if (!q) return NULL;\n    erts_ioq_init(q, ERTS_ALC_T_NIF, 0);\n\n    return q;\n}\n\nvoid enif_ioq_destroy(ErlNifIOQueue *q)\n{\n    erts_ioq_clear(q);\n    enif_free(q);\n}\n\n/* If the iovec was preallocated (Stack or otherwise) it needs to be marked as\n * such to perform a proper free. */\n#define ERL_NIF_IOVEC_FLAGS_PREALLOC (1 << 0)\n\nvoid enif_free_iovec(ErlNifIOVec *iov)\n{\n    int i;\n    /* Decrement the refc of all the binaries */\n    for (i = 0; i < iov->iovcnt; i++) {\n        Binary *bptr = ((Binary**)iov->ref_bins)[i];\n        /* bptr can be null if enq_binary was used */\n        if (bptr && erts_refc_dectest(&bptr->intern.refc, 0) == 0) {\n            erts_bin_free(bptr);\n        }\n    }\n\n    if (!(iov->flags & ERL_NIF_IOVEC_FLAGS_PREALLOC)) {\n        enif_free(iov);\n    }\n}\n\ntypedef struct {\n    UWord sublist_length;\n    Eterm sublist_start;\n    Eterm sublist_end;\n\n    UWord referenced_size;\n    UWord copied_size;\n\n    UWord iovec_len;\n} iovec_slice_t;\n\nstatic int examine_iovec_term(Eterm list, UWord max_length, iovec_slice_t *result) {\n    Eterm lookahead;\n\n    result->sublist_start = list;\n    result->sublist_length = 0;\n    result->referenced_size = 0;\n    result->copied_size = 0;\n    result->iovec_len = 0;\n\n    lookahead = result->sublist_start;\n\n    while (is_list(lookahead)) {\n        UWord byte_size;\n        Eterm binary;\n        Eterm *cell;\n\n        cell = list_val(lookahead);\n        binary = CAR(cell);\n\n        if (!is_binary(binary)) {\n            return 0;\n        }\n\n        byte_size = binary_size(binary);\n\n        if (byte_size > 0) {\n            int bit_offset, bit_size;\n            Eterm parent_binary;\n            UWord byte_offset;\n\n            int requires_copying;\n\n            ERTS_GET_REAL_BIN(binary, parent_binary, byte_offset,\n                bit_offset, bit_size);\n\n            (void)byte_offset;\n\n            if (bit_size != 0) {\n                return 0;\n            }\n\n            /* If we're unaligned or an on-heap binary we'll need to copy\n             * ourselves over to a temporary buffer. */\n            requires_copying = (bit_offset != 0) ||\n                thing_subtag(*binary_val(parent_binary)) == HEAP_BINARY_SUBTAG;\n\n            if (requires_copying) {\n                result->copied_size += byte_size;\n            } else {\n                result->referenced_size += byte_size;\n            }\n\n            result->iovec_len += 1 + byte_size / MAX_SYSIOVEC_IOVLEN;\n        }\n\n        result->sublist_length += 1;\n        lookahead = CDR(cell);\n\n        if (result->sublist_length >= max_length) {\n            break;\n        }\n    }\n\n    if (!is_nil(lookahead) && !is_list(lookahead)) {\n        return 0;\n    }\n\n    result->sublist_end = lookahead;\n\n    return 1;\n}\n\nstatic void marshal_iovec_binary(Eterm binary, ErlNifBinary *copy_buffer,\n        UWord *copy_offset, ErlNifBinary *result) {\n\n    Eterm *parent_header;\n    Eterm parent_binary;\n\n    int bit_offset, bit_size;\n    Uint byte_offset;\n\n    ASSERT(is_binary(binary));\n\n    ERTS_GET_REAL_BIN(binary, parent_binary, byte_offset, bit_offset, bit_size);\n\n    ASSERT(bit_size == 0);\n\n    parent_header = binary_val(parent_binary);\n\n    result->size = binary_size(binary);\n\n    if (thing_subtag(*parent_header) == REFC_BINARY_SUBTAG) {\n        ProcBin *pb = (ProcBin*)parent_header;\n\n        if (pb->flags & (PB_IS_WRITABLE | PB_ACTIVE_WRITER)) {\n            erts_emasculate_writable_binary(pb);\n        }\n\n        ASSERT(pb->val != NULL);\n        ASSERT(byte_offset < pb->size);\n        ASSERT(&pb->bytes[byte_offset] >= (byte*)(pb->val)->orig_bytes);\n\n        result->data = (unsigned char*)&pb->bytes[byte_offset];\n        result->ref_bin = (void*)pb->val;\n    } else {\n        ErlHeapBin *hb = (ErlHeapBin*)parent_header;\n\n        ASSERT(thing_subtag(*parent_header) == HEAP_BINARY_SUBTAG);\n\n        result->data = &((unsigned char*)&hb->data)[byte_offset];\n        result->ref_bin = NULL;\n    }\n\n    /* If this isn't an *aligned* refc binary, copy its contents to the buffer\n     * and reference that instead. */\n\n    if (result->ref_bin == NULL || bit_offset != 0) {\n        ASSERT(copy_buffer->ref_bin != NULL && copy_buffer->data != NULL);\n        ASSERT(result->size <= (copy_buffer->size - *copy_offset));\n\n        if (bit_offset == 0) {\n            sys_memcpy(&copy_buffer->data[*copy_offset],\n                result->data, result->size);\n        } else {\n            erts_copy_bits(result->data, bit_offset, 1,\n                (byte*)&copy_buffer->data[*copy_offset], 0, 1,\n                result->size * 8);\n        }\n\n        result->data = &copy_buffer->data[*copy_offset];\n        result->ref_bin = copy_buffer->ref_bin;\n\n        *copy_offset += result->size;\n    }\n}\n\nstatic int fill_iovec_with_slice(ErlNifEnv *env,\n                                 iovec_slice_t *slice,\n                                 ErlNifIOVec *iovec) {\n    ErlNifBinary copy_buffer = {0};\n    UWord copy_offset, iovec_idx;\n    Eterm sublist_iterator;\n\n    /* Set up a common refc binary for all on-heap and unaligned binaries. */\n    if (slice->copied_size > 0) {\n        if (!enif_alloc_binary(slice->copied_size, &copy_buffer)) {\n            return 0;\n        }\n\n        ASSERT(copy_buffer.ref_bin != NULL);\n    }\n\n    sublist_iterator = slice->sublist_start;\n    copy_offset = 0;\n    iovec_idx = 0;\n\n    while (sublist_iterator != slice->sublist_end) {\n        ErlNifBinary raw_data;\n        Eterm *cell;\n\n        cell = list_val(sublist_iterator);\n        marshal_iovec_binary(CAR(cell), &copy_buffer, &copy_offset, &raw_data);\n\n        while (raw_data.size > 0) {\n            UWord chunk_len = MIN(raw_data.size, MAX_SYSIOVEC_IOVLEN);\n\n            ASSERT(iovec_idx < iovec->iovcnt);\n            ASSERT(raw_data.ref_bin != NULL);\n\n            iovec->iov[iovec_idx].iov_base = raw_data.data;\n            iovec->iov[iovec_idx].iov_len = chunk_len;\n\n            iovec->ref_bins[iovec_idx] = raw_data.ref_bin;\n\n            raw_data.data += chunk_len;\n            raw_data.size -= chunk_len;\n\n            iovec_idx += 1;\n        }\n\n        sublist_iterator = CDR(cell);\n    }\n\n    ASSERT(iovec_idx == iovec->iovcnt);\n\n    if (env == NULL) {\n        int i;\n        for (i = 0; i < iovec->iovcnt; i++) {\n            Binary *refc_binary = (Binary*)(iovec->ref_bins[i]);\n            erts_refc_inc(&refc_binary->intern.refc, 1);\n        }\n\n        if (slice->copied_size > 0) {\n            /* Transfer ownership to the iovec; we've taken references to it in\n             * the above loop. */\n            enif_release_binary(&copy_buffer);\n        }\n    } else {\n        if (slice->copied_size > 0) {\n            /* Attach the binary to our environment and let the next minor GC\n             * get rid of it. This is slightly faster than using the tmp object\n             * list since it avoids off-heap allocations. */\n            erts_build_proc_bin(&MSO(env->proc),\n                alloc_heap(env, PROC_BIN_SIZE), copy_buffer.ref_bin);\n        }\n    }\n\n    return 1;\n}\n\nstatic int create_iovec_from_slice(ErlNifEnv *env,\n                                   iovec_slice_t *slice,\n                                   ErlNifIOVec **result) {\n    ErlNifIOVec *iovec = *result;\n\n    if (iovec && slice->iovec_len < ERL_NIF_IOVEC_SIZE) {\n        iovec->iov = iovec->small_iov;\n        iovec->ref_bins = iovec->small_ref_bin;\n        iovec->flags = ERL_NIF_IOVEC_FLAGS_PREALLOC;\n    } else {\n        UWord iov_offset, binv_offset, alloc_size;\n        char *alloc_base;\n\n        iov_offset = ERTS_ALC_DATA_ALIGN_SIZE(sizeof(ErlNifIOVec));\n        binv_offset = iov_offset;\n        binv_offset += ERTS_ALC_DATA_ALIGN_SIZE(slice->iovec_len * sizeof(SysIOVec));\n        alloc_size = binv_offset;\n        alloc_size += slice->iovec_len * sizeof(Binary*);\n\n        /* When the user passes an environment, we attach the iovec to it so\n         * the user won't have to bother managing it (similar to\n         * enif_inspect_binary). It'll disappear once the environment is\n         * cleaned up. */\n        if (env != NULL) {\n            alloc_base = alloc_tmp_obj(env, alloc_size, &tmp_alloc_dtor);\n        } else {\n            alloc_base = erts_alloc(ERTS_ALC_T_NIF, alloc_size);\n        }\n\n        iovec = (ErlNifIOVec*)alloc_base;\n        iovec->iov = (SysIOVec*)(alloc_base + iov_offset);\n        iovec->ref_bins = (void**)(alloc_base + binv_offset);\n        iovec->flags = 0;\n    }\n\n    iovec->size = slice->referenced_size + slice->copied_size;\n    iovec->iovcnt = slice->iovec_len;\n\n    if(!fill_iovec_with_slice(env, slice, iovec)) {\n        if (env == NULL && !(iovec->flags & ERL_NIF_IOVEC_FLAGS_PREALLOC)) {\n            erts_free(ERTS_ALC_T_NIF, iovec);\n        }\n\n        return 0;\n    }\n\n    *result = iovec;\n\n    return 1;\n}\n\nint enif_inspect_iovec(ErlNifEnv *env, size_t max_elements,\n                       ERL_NIF_TERM list, ERL_NIF_TERM *tail,\n                       ErlNifIOVec **iov) {\n    iovec_slice_t slice;\n\n    if(!examine_iovec_term(list, max_elements, &slice)) {\n        return 0;\n    } else if(!create_iovec_from_slice(env, &slice, iov)) {\n        return 0;\n    }\n\n    (*tail) = slice.sublist_end;\n\n    return 1;\n}\n\n/* */\nint enif_ioq_enqv(ErlNifIOQueue *q, ErlNifIOVec *iov, size_t skip)\n{\n    if(skip <= iov->size) {\n        return !erts_ioq_enqv(q, (ErtsIOVec*)iov, skip);\n    }\n\n    return 0;\n}\n\nint enif_ioq_enq_binary(ErlNifIOQueue *q, ErlNifBinary *bin, size_t skip)\n{\n    ErlNifIOVec vec = {1, bin->size, NULL, NULL, ERL_NIF_IOVEC_FLAGS_PREALLOC };\n    Binary *ref_bin = (Binary*)bin->ref_bin;\n    int res;\n    vec.iov = vec.small_iov;\n    vec.ref_bins = vec.small_ref_bin;\n    vec.iov[0].iov_base = bin->data;\n    vec.iov[0].iov_len = bin->size;\n    ((Binary**)(vec.ref_bins))[0] = ref_bin;\n\n    res = enif_ioq_enqv(q, &vec, skip);\n    enif_release_binary(bin);\n    return res;\n}\n\nsize_t enif_ioq_size(ErlNifIOQueue *q)\n{\n    return erts_ioq_size(q);\n}\n\nint enif_ioq_deq(ErlNifIOQueue *q, size_t elems, size_t *size)\n{\n    if (erts_ioq_deq(q, elems) == -1)\n        return 0;\n    if (size)\n        *size = erts_ioq_size(q);\n    return 1;\n}\n\nint enif_ioq_peek_head(ErlNifEnv *env, ErlNifIOQueue *q, size_t *size, ERL_NIF_TERM *bin_term) {\n    SysIOVec *iov_entry;\n    Binary *ref_bin;\n\n    if (q->size == 0) {\n        return 0;\n    }\n\n    ASSERT(q->b_head != q->b_tail && q->v_head != q->v_tail);\n\n    ref_bin = &q->b_head[0]->nif;\n    iov_entry = &q->v_head[0];\n\n    if (size != NULL) {\n        *size = iov_entry->iov_len;\n    }\n\n    if (iov_entry->iov_len > ERL_ONHEAP_BIN_LIMIT) {\n        ProcBin *pb = (ProcBin*)alloc_heap(env, PROC_BIN_SIZE);\n\n        pb->thing_word = HEADER_PROC_BIN;\n        pb->next = MSO(env->proc).first;\n        pb->val = ref_bin;\n        pb->flags = 0;\n\n        ASSERT((byte*)iov_entry->iov_base >= (byte*)ref_bin->orig_bytes);\n        ASSERT(iov_entry->iov_len <= ref_bin->orig_size);\n\n        pb->bytes = (byte*)iov_entry->iov_base;\n        pb->size = iov_entry->iov_len;\n\n        MSO(env->proc).first = (struct erl_off_heap_header*) pb;\n        OH_OVERHEAD(&(MSO(env->proc)), pb->size / sizeof(Eterm));\n\n        erts_refc_inc(&ref_bin->intern.refc, 2);\n        *bin_term = make_binary(pb);\n    } else {\n        ErlHeapBin* hb = (ErlHeapBin*)alloc_heap(env, heap_bin_size(iov_entry->iov_len));\n\n        hb->thing_word = header_heap_bin(iov_entry->iov_len);\n        hb->size = iov_entry->iov_len;\n\n        sys_memcpy(hb->data, iov_entry->iov_base, iov_entry->iov_len);\n        *bin_term = make_binary(hb);\n    }\n\n    return 1;\n}\n\nSysIOVec *enif_ioq_peek(ErlNifIOQueue *q, int *iovlen)\n{\n    return erts_ioq_peekq(q, iovlen);\n}\n\n/***************************************************************************\n **                              load_nif/2                               **\n ***************************************************************************/\n\n\nstatic ErtsCodeInfo** get_func_pp(BeamCodeHeader* mod_code, Eterm f_atom, unsigned arity)\n{\n    int n = (int) mod_code->num_functions;\n    int j;\n    for (j = 0; j < n; ++j) {\n\tErtsCodeInfo* ci = mod_code->functions[j];\n\tASSERT(BeamIsOpCode(ci->op, op_i_func_info_IaaI));\n\tif (f_atom == ci->mfa.function\n\t    && arity == ci->mfa.arity) {\n\t    return mod_code->functions+j;\n\t}\n    }\n    return NULL;\n}\n\nstatic Eterm mkatom(const char *str)\n{\n    return am_atom_put(str, sys_strlen(str));\n}\n\nstruct tainted_module_t\n{\n    struct tainted_module_t* next;\n    Eterm module_atom;\n};\n\nerts_atomic_t first_taint; /* struct tainted_module_t* */\n\nvoid erts_add_taint(Eterm mod_atom)\n{\n#ifdef ERTS_ENABLE_LOCK_CHECK\n    extern erts_rwmtx_t erts_driver_list_lock; /* Mutex for driver list */\n#endif\n    struct tainted_module_t *first, *t;\n\n    ERTS_LC_ASSERT(erts_lc_rwmtx_is_rwlocked(&erts_driver_list_lock)\n                   || erts_thr_progress_is_blocking());\n\n    first = (struct tainted_module_t*) erts_atomic_read_nob(&first_taint);\n    for (t=first ; t; t=t->next) {\n\tif (t->module_atom == mod_atom) {\n\t    return;\n\t}\n    }\n    t = erts_alloc_fnf(ERTS_ALC_T_TAINT, sizeof(*t));\n    if (t != NULL) {\n\tt->module_atom = mod_atom;\n\tt->next = first;\n        erts_atomic_set_nob(&first_taint, (erts_aint_t)t);\n    }\n}\n\nEterm erts_nif_taints(Process* p)\n{\n    struct tainted_module_t *first, *t;\n    unsigned cnt = 0;\n    Eterm list = NIL;\n    Eterm* hp;\n\n    first = (struct tainted_module_t*) erts_atomic_read_nob(&first_taint);\n    for (t=first ; t!=NULL; t=t->next) {\n\tcnt++;\n    }\n    hp = HAlloc(p,cnt*2);\n    for (t=first ; t!=NULL; t=t->next) {\n\tlist = CONS(hp, t->module_atom, list);\n\thp += 2;\n    }\n    return list;\n}\n\nvoid erts_print_nif_taints(fmtfn_t to, void* to_arg)\n{\n    struct tainted_module_t *t;\n    const char* delim = \"\";\n\n    t = (struct tainted_module_t*) erts_atomic_read_nob(&first_taint);\n    for ( ; t; t = t->next) {\n\tconst Atom* atom = atom_tab(atom_val(t->module_atom));\n\terts_cbprintf(to,to_arg,\"%s%.*s\", delim, atom->len, atom->name);\n\tdelim = \",\";\n    }\n    erts_cbprintf(to,to_arg,\"\\n\");\n}\n\n\nstatic Eterm load_nif_error(Process* p, const char* atom, const char* format, ...)\n{\n    erts_dsprintf_buf_t* dsbufp = erts_create_tmp_dsbuf(0);\n    Eterm ret;\n    Eterm* hp;\n    Eterm** hpp = NULL;\n    Uint sz = 0;\n    Uint* szp = &sz;\n    va_list arglist;   \n\n    va_start(arglist, format);\n    erts_vdsprintf(dsbufp, format, arglist);\n    va_end(arglist);\n    \n    for (;;) {\n\tEterm txt = erts_bld_string_n(hpp, &sz, dsbufp->str, dsbufp->str_len);\n\tret = erts_bld_tuple(hpp, szp, 2, am_error,\n\t\t\t     erts_bld_tuple(hpp, szp, 2, mkatom(atom), txt));\n\tif (hpp != NULL) {\n\t    break;\n\t}\n\thp = HAlloc(p,sz);\n\thpp = &hp;\n\tszp = NULL;\n    }\n    erts_destroy_tmp_dsbuf(dsbufp);\n    return ret;\n}\n\n#define AT_LEAST_VERSION(E,MAJ,MIN) \\\n    (((E)->major * 0x100 + (E)->minor) >= ((MAJ) * 0x100 + (MIN)))\n\n/*\n * Allocate erl_module_nif and make a _modern_ copy of the lib entry.\n */\nstatic struct erl_module_nif* create_lib(const ErlNifEntry* src)\n{\n    struct erl_module_nif* lib;\n    ErlNifEntry* dst;\n    Uint bytes = offsetof(struct erl_module_nif, _funcs_copy_);\n\n    if (!AT_LEAST_VERSION(src, 2, 7))\n        bytes += src->num_of_funcs * sizeof(ErlNifFunc);\n\n    lib = erts_alloc(ERTS_ALC_T_NIF, bytes);\n    dst = &lib->entry;\n\n    sys_memcpy(dst, src, offsetof(ErlNifEntry, vm_variant));\n\n    if (AT_LEAST_VERSION(src, 2, 1)) {\n        dst->vm_variant = src->vm_variant;\n    } else {\n        dst->vm_variant = \"beam.vanilla\";\n    }\n    if (AT_LEAST_VERSION(src, 2, 7)) {\n        dst->options = src->options;\n    } else {\n        /*\n         * Make a modern copy of the ErlNifFunc array\n         */\n        struct ErlNifFunc_V1 {\n            const char* name;\n            unsigned arity;\n            ERL_NIF_TERM (*fptr)(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);\n        }*src_funcs = (struct ErlNifFunc_V1*) src->funcs;\n        int i;\n        for (i = 0; i < src->num_of_funcs; ++i) {\n            sys_memcpy(&lib->_funcs_copy_[i], &src_funcs[i], sizeof(*src_funcs));\n            lib->_funcs_copy_[i].flags = 0;\n        }\n        dst->funcs = lib->_funcs_copy_;\n        dst->options = 0;\n    }\n    if (AT_LEAST_VERSION(src, 2, 12)) {\n        dst->sizeof_ErlNifResourceTypeInit = src->sizeof_ErlNifResourceTypeInit;\n    } else {\n        dst->sizeof_ErlNifResourceTypeInit = 0;\n    }\n    if (AT_LEAST_VERSION(src, 2, 14)) {\n        dst->min_erts = src->min_erts;\n    } else {\n        dst->min_erts = \"erts-?\";\n    }\n    return lib;\n};\n\n\nBIF_RETTYPE load_nif_2(BIF_ALIST_2)\n{\n    static const char bad_lib[] = \"bad_lib\";\n    static const char upgrade[] = \"upgrade\";\n    char* lib_name = NULL;\n    void* handle = NULL;\n    void* init_func = NULL;\n    ErlNifEntry* entry = NULL;\n    ErlNifEnv env;\n    int i, err, encoding;\n    Module* module_p;\n    Eterm mod_atom;\n    const Atom* mod_atomp;\n    Eterm f_atom;\n    ErtsCodeMFA* caller;\n    ErtsSysDdllError errdesc = ERTS_SYS_DDLL_ERROR_INIT;\n    Eterm ret = am_ok;\n    int veto;\n    int taint = 1;\n    struct erl_module_nif* lib = NULL;\n    struct erl_module_instance* this_mi;\n    struct erl_module_instance* prev_mi;\n\n    if (BIF_P->flags & F_HIPE_MODE) {\n\tret = load_nif_error(BIF_P, \"notsup\", \"Calling load_nif from HiPE compiled \"\n\t\t\t     \"modules not supported\");\n\tBIF_RET(ret);\n    }\n\n    encoding = erts_get_native_filename_encoding();\n    if (encoding == ERL_FILENAME_WIN_WCHAR) {\n        /* Do not convert the lib name to utf-16le yet, do that in win32 specific code */\n        /* since lib_name is used in error messages */\n        encoding = ERL_FILENAME_UTF8;\n    }\n    lib_name = erts_convert_filename_to_encoding(BIF_ARG_1, NULL, 0,\n                                                 ERTS_ALC_T_TMP, 1, 0, encoding,\n\t\t\t\t\t\t NULL, 0);\n    if (!lib_name) {\n\tBIF_ERROR(BIF_P, BADARG);\n    }\n\n    if (!erts_try_seize_code_write_permission(BIF_P)) {\n\terts_free(ERTS_ALC_T_TMP, lib_name);\n\tERTS_BIF_YIELD2(bif_export[BIF_load_nif_2],\n\t\t\tBIF_P, BIF_ARG_1, BIF_ARG_2);\n    }\n\n    /* Block system (is this the right place to do it?) */\n    erts_proc_unlock(BIF_P, ERTS_PROC_LOCK_MAIN);\n    erts_thr_progress_block();\n\n    /* Find calling module */\n    ASSERT(BIF_P->current != NULL);\n    ASSERT(BIF_P->current->module == am_erlang\n\t   && BIF_P->current->function == am_load_nif \n\t   && BIF_P->current->arity == 2);\n    caller = find_function_from_pc(BIF_P->cp);\n    ASSERT(caller != NULL);\n    mod_atom = caller->module;\n    ASSERT(is_atom(mod_atom));\n    module_p = erts_get_module(mod_atom, erts_active_code_ix());\n    ASSERT(module_p != NULL);\n\n    mod_atomp = atom_tab(atom_val(mod_atom));\n    {\n        ErtsStaticNifEntry* sne;\n        sne = erts_static_nif_get_nif_init((char*)mod_atomp->name, mod_atomp->len);\n        if (sne != NULL) {\n            init_func = sne->nif_init;\n            handle = init_func;\n            taint = sne->taint;\n        }\n    }\n    this_mi = &module_p->curr;\n    prev_mi = &module_p->old;\n    if (in_area(caller, module_p->old.code_hdr, module_p->old.code_length)) {\n\tret = load_nif_error(BIF_P, \"old_code\", \"Calling load_nif from old \"\n\t\t\t     \"module '%T' not allowed\", mod_atom);\n\tgoto error;\n    } else if (module_p->on_load) {\n\tASSERT(module_p->on_load->code_hdr->on_load_function_ptr);\n\tif (module_p->curr.code_hdr) {\n\t    prev_mi = &module_p->curr;\n\t} else {\n\t    prev_mi = &module_p->old;\n\t}\n\tthis_mi = module_p->on_load;\n    }\n\n    if (this_mi->nif != NULL) {\n        ret = load_nif_error(BIF_P,\"reload\",\"NIF library already loaded\"\n                             \" (reload disallowed since OTP 20).\");\n    }\n    else if (init_func == NULL &&\n             (err=erts_sys_ddll_open(lib_name, &handle, &errdesc)) != ERL_DE_NO_ERROR) {\n\tconst char slogan[] = \"Failed to load NIF library\";\n\tif (strstr(errdesc.str, lib_name) != NULL) {\n\t    ret = load_nif_error(BIF_P, \"load_failed\", \"%s: '%s'\", slogan, errdesc.str);\n\t}\n\telse {\n\t    ret = load_nif_error(BIF_P, \"load_failed\", \"%s %s: '%s'\", slogan, lib_name, errdesc.str);\n\t}\n    }\n    else if (init_func == NULL &&\n\t     erts_sys_ddll_load_nif_init(handle, &init_func, &errdesc) != ERL_DE_NO_ERROR) {\n\tret  = load_nif_error(BIF_P, bad_lib, \"Failed to find library init\"\n\t\t\t      \" function: '%s'\", errdesc.str);\n\t\n    }\n    else if ((taint ? erts_add_taint(mod_atom) : 0,\n\t      (entry = erts_sys_ddll_call_nif_init(init_func)) == NULL)) {\n\tret = load_nif_error(BIF_P, bad_lib, \"Library init-call unsuccessful\");\n    }\n    else if (entry->major > ERL_NIF_MAJOR_VERSION\n             || (entry->major == ERL_NIF_MAJOR_VERSION\n                 && entry->minor > ERL_NIF_MINOR_VERSION)) {\n        char* fmt = \"That '%T' NIF library needs %s or newer. Either try to\"\n            \" recompile the NIF lib or use a newer erts runtime.\";\n        ret = load_nif_error(BIF_P, bad_lib, fmt, mod_atom, entry->min_erts);\n    }\n    else if (entry->major < ERL_NIF_MIN_REQUIRED_MAJOR_VERSION_ON_LOAD\n\t     || (entry->major==2 && entry->minor == 5)) { /* experimental maps */\n\t\n        char* fmt = \"That old NIF library (%d.%d) is not compatible with this \"\n            \"erts runtime (%d.%d). Try recompile the NIF lib.\";\n        ret = load_nif_error(BIF_P, bad_lib, fmt, entry->major, entry->minor,\n                             ERL_NIF_MAJOR_VERSION, ERL_NIF_MINOR_VERSION);\n    }   \n    else if (AT_LEAST_VERSION(entry, 2, 1)\n\t     && sys_strcmp(entry->vm_variant, ERL_NIF_VM_VARIANT) != 0) {\n\tret = load_nif_error(BIF_P, bad_lib, \"Library (%s) not compiled for \"\n\t\t\t     \"this vm variant (%s).\",\n\t\t\t     entry->vm_variant, ERL_NIF_VM_VARIANT);\n    }\n    else if (!erts_is_atom_str((char*)entry->name, mod_atom, 1)) {\n\tret = load_nif_error(BIF_P, bad_lib, \"Library module name '%s' does not\"\n\t\t\t     \" match calling module '%T'\", entry->name, mod_atom);\n    }\n    else {\n        lib = create_lib(entry);\n        entry = &lib->entry; /* Use a guaranteed modern lib entry from now on */\n\n        lib->handle = handle;\n        erts_refc_init(&lib->rt_cnt, 0);\n        erts_refc_init(&lib->rt_dtor_cnt, 0);\n        ASSERT(opened_rt_list == NULL);\n        lib->mod = module_p;\n\n        for (i=0; i < entry->num_of_funcs && ret==am_ok; i++) {\n\t    ErtsCodeInfo** ci_pp;\n            ErlNifFunc* f = &entry->funcs[i];\n\n\t    if (!erts_atom_get(f->name, sys_strlen(f->name), &f_atom, ERTS_ATOM_ENC_LATIN1)\n\t\t|| (ci_pp = get_func_pp(this_mi->code_hdr, f_atom, f->arity))==NULL) {\n\t\tret = load_nif_error(BIF_P,bad_lib,\"Function not found %T:%s/%u\",\n\t\t\t\t     mod_atom, f->name, f->arity);\n\t    }\n\t    else if (f->flags) {\n\t\t/*\n\t\t * If the flags field is non-zero and this emulator was\n\t\t * built with dirty scheduler support, check that the flags\n\t\t * value is legal. But if this emulator was built without\n\t\t * dirty scheduler support, treat a non-zero flags field as\n\t\t * a load error.\n\t\t */\n\t\tif (f->flags != ERL_NIF_DIRTY_JOB_IO_BOUND && f->flags != ERL_NIF_DIRTY_JOB_CPU_BOUND)\n\t\t    ret = load_nif_error(BIF_P, bad_lib, \"Illegal flags field value %d for NIF %T:%s/%u\",\n\t\t\t\t\t f->flags, mod_atom, f->name, f->arity);\n\t    }\n\t    else if (erts_codeinfo_to_code(ci_pp[1]) - erts_codeinfo_to_code(ci_pp[0])\n                     < BEAM_NIF_MIN_FUNC_SZ)\n\t    {\n\t\tret = load_nif_error(BIF_P,bad_lib,\"No explicit call to load_nif\"\n\t\t\t\t     \" in module (%T:%s/%u too small)\",\n\t\t\t\t     mod_atom, f->name, f->arity);\n\t    }\n\t    /*erts_fprintf(stderr, \"Found NIF %T:%s/%u\\r\\n\",\n\t      mod_atom, f->name, f->arity);*/\n\t}\n    }\n\n    if (ret != am_ok) {\n\tgoto error;\n    }\n\n    /* Call load or upgrade:\n     */\n\n    env.mod_nif = lib;\n\n    lib->priv_data = NULL;\n    if (prev_mi->nif != NULL) { /**************** Upgrade ***************/\n        void* prev_old_data = prev_mi->nif->priv_data;\n        if (entry->upgrade == NULL) {\n            ret = load_nif_error(BIF_P, upgrade, \"Upgrade not supported by this NIF library.\");\n            goto error;\n        }\n        erts_pre_nif(&env, BIF_P, lib, NULL);\n        veto = entry->upgrade(&env, &lib->priv_data, &prev_mi->nif->priv_data, BIF_ARG_2);\n        erts_post_nif(&env);\n        if (veto) {\n            prev_mi->nif->priv_data = prev_old_data;\n            ret = load_nif_error(BIF_P, upgrade, \"Library upgrade-call unsuccessful (%d).\", veto);\n        }\n    }\n    else if (entry->load != NULL) { /********* Initial load ***********/\n        erts_pre_nif(&env, BIF_P, lib, NULL);\n        veto = entry->load(&env, &lib->priv_data, BIF_ARG_2);\n        erts_post_nif(&env);\n        if (veto) {\n            ret = load_nif_error(BIF_P, \"load\", \"Library load-call unsuccessful (%d).\", veto);\n        }\n    }\n    if (ret == am_ok) {\n        commit_opened_resource_types(lib);\n\n\t/*\n\t** Everything ok, patch the beam code with op_call_nif\n\t*/\n\n\tthis_mi->nif = lib;\n\tfor (i=0; i < entry->num_of_funcs; i++)\n\t{\n            ErlNifFunc* f = &entry->funcs[i];\n\t    ErtsCodeInfo* ci;\n            BeamInstr *code_ptr;\n\n\t    erts_atom_get(f->name, sys_strlen(f->name), &f_atom, ERTS_ATOM_ENC_LATIN1);\n\t    ci = *get_func_pp(this_mi->code_hdr, f_atom, f->arity);\n            code_ptr = erts_codeinfo_to_code(ci);\n\n\t    if (ci->u.gen_bp == NULL) {\n\t\tcode_ptr[0] = BeamOpCodeAddr(op_call_nif);\n\t    }\n\t    else { /* Function traced, patch the original instruction word */\n\t\tGenericBp* g = ci->u.gen_bp;\n\t\tASSERT(BeamIsOpCode(code_ptr[0], op_i_generic_breakpoint));\n\t\tg->orig_instr = BeamOpCodeAddr(op_call_nif);\n\t    }\n\t    if (f->flags) {\n\t\tcode_ptr[3] = (BeamInstr) f->fptr;\n\t\tcode_ptr[1] = (f->flags == ERL_NIF_DIRTY_JOB_IO_BOUND) ?\n\t\t    (BeamInstr) static_schedule_dirty_io_nif :\n\t\t    (BeamInstr) static_schedule_dirty_cpu_nif;\n\t    }\n\t    else\n\t\tcode_ptr[1] = (BeamInstr) f->fptr;\n\t    code_ptr[2] = (BeamInstr) lib;\n\t}\n    }\n    else {\n    error:\n\trollback_opened_resource_types();\n\tASSERT(ret != am_ok);\n        if (lib != NULL) {\n\t    erts_free(ERTS_ALC_T_NIF, lib);\n\t}\n\tif (handle != NULL && !erts_is_static_nif(handle)) {\n\t    erts_sys_ddll_close(handle);\n\t}\n\terts_sys_ddll_free_error(&errdesc);\n    }\n\n    erts_thr_progress_unblock();\n    erts_proc_lock(BIF_P, ERTS_PROC_LOCK_MAIN);\n    erts_release_code_write_permission();\n    erts_free(ERTS_ALC_T_TMP, lib_name);\n\n    BIF_RET(ret);\n}\n\n\nvoid\nerts_unload_nif(struct erl_module_nif* lib)\n{\n    ErlNifResourceType* rt;\n    ErlNifResourceType* next;\n    ASSERT(erts_thr_progress_is_blocking());\n    ASSERT(lib != NULL);\n    ASSERT(lib->mod != NULL);\n\n    erts_tracer_nif_clear();\n\n    for (rt = resource_type_list.next;\n\t rt != &resource_type_list;\n\t rt = next) {\n\n\tnext = rt->next;\n\tif (rt->owner == lib) {\n\t    rt->next->prev = rt->prev;\n\t    rt->prev->next = rt->next;\n\t    rt->next = NULL;\n\t    rt->prev = NULL;\n\t    if (erts_refc_dectest(&rt->refc, 0) == 0) {\n\t\tif (rt->dtor != NULL) {\n\t\t    erts_refc_dec(&lib->rt_dtor_cnt, 0);\n\t\t}\n\t\terts_refc_dec(&lib->rt_cnt, 0);\n\t\terts_free(ERTS_ALC_T_NIF, rt);\n\t    }\n\t}\n    }\n    if (erts_refc_read(&lib->rt_dtor_cnt, 0) == 0) {\n\tclose_lib(lib);\n\tif (erts_refc_read(&lib->rt_cnt, 0) == 0) {\n\t    erts_free(ERTS_ALC_T_NIF, lib);\n\t    return;\n\t}\n    }\n    else {\n\tASSERT(erts_refc_read(&lib->rt_cnt, 1) > 0);\n    }\n    lib->mod = NULL;   /* orphan lib */\n}\t\n\nvoid erl_nif_init()\n{\n    ERTS_CT_ASSERT((offsetof(ErtsResource,data) % 8)\n                   == ERTS_MAGIC_BIN_BYTES_TO_ALIGN);\n\n    resource_type_list.next = &resource_type_list;\n    resource_type_list.prev = &resource_type_list;\n    resource_type_list.dtor = NULL;\n    resource_type_list.owner = NULL;\n    resource_type_list.module = THE_NON_VALUE;\n    resource_type_list.name = THE_NON_VALUE;\n\n}\n\nint erts_nif_get_funcs(struct erl_module_nif* mod,\n                       ErlNifFunc **funcs)\n{\n    *funcs = mod->entry.funcs;\n    return mod->entry.num_of_funcs;\n}\n\nModule *erts_nif_get_module(struct erl_module_nif *nif_mod) {\n    return nif_mod->mod;\n}\n\nEterm erts_nif_call_function(Process *p, Process *tracee,\n                             struct erl_module_nif* mod,\n                             ErlNifFunc *fun, int argc, Eterm *argv)\n{\n    Eterm nif_result;\n#ifdef DEBUG\n    /* Verify that function is part of this module */\n    int i;\n    for (i = 0; i < mod->entry.num_of_funcs; i++)\n        if (fun == &(mod->entry.funcs[i]))\n            break;\n    ASSERT(i < mod->entry.num_of_funcs);\n    if (p)\n        ERTS_LC_ASSERT(erts_proc_lc_my_proc_locks(p) & ERTS_PROC_LOCK_MAIN\n                           || erts_thr_progress_is_blocking());\n#endif\n    if (p) {\n        /* This is almost a normal nif call like in beam_emu,\n           except that any heap consumed by the nif will be\n           released without checking if anything in it is live.\n           This is because we cannot do a GC here as we don't know\n           the number of live registers that have to be preserved.\n           This means that any heap part of the returned term may\n           not be used outside this function. */\n        struct enif_environment_t env;\n        ErlHeapFragment *orig_hf = MBUF(p);\n        ErlOffHeap orig_oh = MSO(p);\n        Eterm *orig_htop = HEAP_TOP(p);\n        ASSERT(is_internal_pid(p->common.id));\n        MBUF(p) = NULL;\n        clear_offheap(&MSO(p));\n\n        erts_pre_nif(&env, p, mod, tracee);\n#ifdef ERTS_NIF_ASSERT_IN_ENV\n        env.dbg_disable_assert_in_env = 1;\n#endif\n        nif_result = (*fun->fptr)(&env, argc, argv);\n        if (env.exception_thrown)\n            nif_result = THE_NON_VALUE;\n        erts_post_nif(&env);\n\n        /* Free any offheap and heap fragments created in nif */\n        if (MSO(p).first) {\n            erts_cleanup_offheap(&MSO(p));\n            clear_offheap(&MSO(p));\n        }\n        if (MBUF(p))\n            free_message_buffer(MBUF(p));\n\n        /* restore original heap fragment list */\n        MBUF(p) = orig_hf;\n        MSO(p) = orig_oh;\n        HEAP_TOP(p) = orig_htop;\n    } else {\n        /* Nif call was done without a process context,\n           so we create a phony one. */\n        struct enif_msg_environment_t msg_env;\n        pre_nif_noproc(&msg_env, mod, tracee);\n#ifdef ERTS_NIF_ASSERT_IN_ENV\n        msg_env.env.dbg_disable_assert_in_env = 1;\n#endif\n        nif_result = (*fun->fptr)(&msg_env.env, argc, argv);\n        if (msg_env.env.exception_thrown)\n            nif_result = THE_NON_VALUE;\n        post_nif_noproc(&msg_env);\n    }\n\n    return nif_result;\n}\n\n#ifdef USE_VM_PROBES\nvoid dtrace_nifenv_str(ErlNifEnv *env, char *process_buf)\n{\n    dtrace_pid_str(env->proc->common.id, process_buf);\n}\n#endif\n\n#ifdef READONLY_CHECK\n/* Use checksums to assert that NIFs do not write into inspected binaries\n*/\nstatic void readonly_check_dtor(struct enif_tmp_obj_t*);\nstatic unsigned calc_checksum(unsigned char* ptr, unsigned size);\n\nstruct readonly_check_t\n{\n    unsigned char* ptr;\n    unsigned size;\n    unsigned checksum;\n};\nstatic void add_readonly_check(ErlNifEnv* env, unsigned char* ptr, unsigned sz)\n{\n    struct readonly_check_t* obj;\n\n    obj = alloc_tmp_obj(env, sizeof(struct readonly_check_t),\n        &readonly_check_dtor);\n\n    obj->ptr = ptr;\n    obj->size = sz;\n    obj->checksum = calc_checksum(ptr, sz);\n}\nstatic void readonly_check_dtor(struct enif_tmp_obj_t* tmp_obj)\n{\n    struct readonly_check_t* ro_check = (struct readonly_check_t*)&tmp_obj[1];\n    unsigned chksum = calc_checksum(ro_check->ptr, ro_check->size);\n    if (chksum != ro_check->checksum) { \n\tfprintf(stderr, \"\\r\\nReadonly data written by NIF, checksums differ\"\n\t\t\" %x != %x\\r\\nABORTING\\r\\n\", chksum, ro_check->checksum);\n\tabort();\n    }\n    erts_free(tmp_obj->allocator, tmp_obj);\n}\nstatic unsigned calc_checksum(unsigned char* ptr, unsigned size)\n{\n    unsigned i, sum = 0;\n    for (i=0; i<size; i++) {\n\tsum ^= ptr[i] << ((i % 4)*8);\n    }\n    return sum;\n}\n\n#endif /* READONLY_CHECK */\n\n#ifdef ERTS_NIF_ASSERT_IN_ENV\nstatic void dbg_assert_in_env(ErlNifEnv* env, Eterm term,\n                              int nr, const char* type, const char* func)\n{\n    Uint saved_used_size;\n    Eterm* real_htop;\n\n    if (is_immed(term)\n        || (is_non_value(term) && env->exception_thrown)\n        || erts_is_literal(term, ptr_val(term)))\n        return;\n\n    if (env->dbg_disable_assert_in_env) {\n        /*\n         * Trace nifs may cheat as built terms are discarded after return.\n         * ToDo: Check if 'term' is part of argv[].\n         */\n        return;\n    }\n\n    if (env->heap_frag) {\n        ASSERT(env->heap_frag == MBUF(env->proc));\n        ASSERT(env->hp >= env->heap_frag->mem);\n        ASSERT(env->hp <= env->heap_frag->mem + env->heap_frag->alloc_size);\n        saved_used_size = env->heap_frag->used_size;\n        env->heap_frag->used_size = env->hp - env->heap_frag->mem;\n        real_htop = NULL;\n    }\n    else {\n        real_htop = env->hp;\n    }\n    if (!erts_dbg_within_proc(ptr_val(term), env->proc, real_htop)) {\n        fprintf(stderr, \"\\r\\nFAILED ASSERTION in %s:\\r\\n\", func);\n        if (nr) {\n            fprintf(stderr, \"Term #%d of the %s is not from same ErlNifEnv.\",\n                    nr, type);\n        }\n        else {\n            fprintf(stderr, \"The %s is not from the same ErlNifEnv.\", type);\n        }\n        fprintf(stderr, \"\\r\\nABORTING\\r\\n\");\n        abort();\n    }\n    if (env->heap_frag) {\n        env->heap_frag->used_size = saved_used_size;\n    }\n}\n#endif\n\n#ifdef HAVE_USE_DTRACE\n\n#define MESSAGE_BUFSIZ 1024\n\nstatic void get_string_maybe(ErlNifEnv *env, const ERL_NIF_TERM term,\n\t\t      char **ptr, char *buf, int bufsiz)\n{\n    ErlNifBinary str_bin;\n\n    if (!enif_inspect_iolist_as_binary(env, term, &str_bin) ||\n        str_bin.size > bufsiz) {\n        *ptr = NULL;\n    } else {\n        sys_memcpy(buf, (char *) str_bin.data, str_bin.size);\n        buf[str_bin.size] = '\\0';\n        *ptr = buf;\n    }\n}\n\nERL_NIF_TERM erl_nif_user_trace_s1(ErlNifEnv* env, int argc,\n                                   const ERL_NIF_TERM argv[])\n{\n    ErlNifBinary message_bin;\n    DTRACE_CHARBUF(messagebuf, MESSAGE_BUFSIZ + 1);\n\n    if (DTRACE_ENABLED(user_trace_s1)) {\n\tif (!enif_inspect_iolist_as_binary(env, argv[0], &message_bin) ||\n\t    message_bin.size > MESSAGE_BUFSIZ) {\n\t    return am_badarg;\n\t}\n\tsys_memcpy(messagebuf, (char *) message_bin.data, message_bin.size);\n        messagebuf[message_bin.size] = '\\0';\n\tDTRACE1(user_trace_s1, messagebuf);\n\treturn am_true;\n    } else {\n\treturn am_false;\n    }\n}\n\nERL_NIF_TERM erl_nif_user_trace_i4s4(ErlNifEnv* env, int argc,\n                                     const ERL_NIF_TERM argv[])\n{\n    DTRACE_CHARBUF(procbuf, 32 + 1);\n    DTRACE_CHARBUF(user_tagbuf, MESSAGE_BUFSIZ + 1);\n    char *utbuf = NULL;\n    ErlNifSInt64 i1, i2, i3, i4;\n    DTRACE_CHARBUF(messagebuf1, MESSAGE_BUFSIZ + 1);\n    DTRACE_CHARBUF(messagebuf2, MESSAGE_BUFSIZ + 1);\n    DTRACE_CHARBUF(messagebuf3, MESSAGE_BUFSIZ + 1);\n    DTRACE_CHARBUF(messagebuf4, MESSAGE_BUFSIZ + 1);\n    char *mbuf1 = NULL, *mbuf2 = NULL, *mbuf3 = NULL, *mbuf4 = NULL;\n    \n    if (DTRACE_ENABLED(user_trace_i4s4)) {\n\tdtrace_nifenv_str(env, procbuf);\n        get_string_maybe(env, argv[0], &utbuf, user_tagbuf, MESSAGE_BUFSIZ);\n        if (! enif_get_int64(env, argv[1], &i1))\n            i1 = 0;\n        if (! enif_get_int64(env, argv[2], &i2))\n            i2 = 0;\n        if (! enif_get_int64(env, argv[3], &i3))\n            i3 = 0;\n        if (! enif_get_int64(env, argv[4], &i4))\n            i4 = 0;\n        get_string_maybe(env, argv[5], &mbuf1, messagebuf1, MESSAGE_BUFSIZ);\n        get_string_maybe(env, argv[6], &mbuf2, messagebuf2, MESSAGE_BUFSIZ);\n        get_string_maybe(env, argv[7], &mbuf3, messagebuf3, MESSAGE_BUFSIZ);\n        get_string_maybe(env, argv[8], &mbuf4, messagebuf4, MESSAGE_BUFSIZ);\n\tDTRACE10(user_trace_i4s4, procbuf, utbuf,\n\t\t i1, i2, i3, i4, mbuf1, mbuf2, mbuf3, mbuf4);\n\treturn am_true;\n    } else {\n\treturn am_false;\n    }\n}\n\n#define DTRACE10_LABEL(name, label, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) \\\n    erlang_##name##label((a0), (a1), (a2), (a3), (a4), (a5), (a6), (a7), (a8), (a9))\n#define N_STATEMENT(the_label) \\\n   case the_label: \\\n      if (DTRACE_ENABLED(user_trace_n##the_label)) { \\\n          dtrace_nifenv_str(env, procbuf); \\\n          get_string_maybe(env, argv[1], &utbuf, user_tagbuf, MESSAGE_BUFSIZ); \\\n          if (! enif_get_int64(env, argv[2], &i1)) \\\n              i1 = 0; \\\n          if (! enif_get_int64(env, argv[3], &i2)) \\\n              i2 = 0; \\\n          if (! enif_get_int64(env, argv[4], &i3)) \\\n              i3 = 0; \\\n          if (! enif_get_int64(env, argv[5], &i4)) \\\n              i4 = 0; \\\n          get_string_maybe(env, argv[6], &mbuf1, messagebuf1, MESSAGE_BUFSIZ); \\\n          get_string_maybe(env, argv[7], &mbuf2, messagebuf2, MESSAGE_BUFSIZ); \\\n          get_string_maybe(env, argv[8], &mbuf3, messagebuf3, MESSAGE_BUFSIZ); \\\n          get_string_maybe(env, argv[9], &mbuf4, messagebuf4, MESSAGE_BUFSIZ); \\\n          DTRACE10_LABEL(user_trace_n, the_label, procbuf, utbuf,    \\\n                         i1, i2, i3, i4, mbuf1, mbuf2, mbuf3, mbuf4); \\\n          return am_true; \\\n      } else { \\\n          return am_false; \\\n      } \\\n      break\n\nERL_NIF_TERM erl_nif_user_trace_n(ErlNifEnv* env, int argc,\n\t\t\t\t  const ERL_NIF_TERM argv[])\n{\n    DTRACE_CHARBUF(procbuf, 32 + 1);\n    DTRACE_CHARBUF(user_tagbuf, MESSAGE_BUFSIZ + 1);\n    char *utbuf = NULL;\n    ErlNifSInt64 i1, i2, i3, i4;\n    DTRACE_CHARBUF(messagebuf1, MESSAGE_BUFSIZ + 1);\n    DTRACE_CHARBUF(messagebuf2, MESSAGE_BUFSIZ + 1);\n    DTRACE_CHARBUF(messagebuf3, MESSAGE_BUFSIZ + 1);\n    DTRACE_CHARBUF(messagebuf4, MESSAGE_BUFSIZ + 1);\n    char *mbuf1 = NULL, *mbuf2 = NULL, *mbuf3 = NULL, *mbuf4 = NULL;\n    ErlNifSInt64 label = 0;\n\n    if (! enif_get_int64(env, argv[0], &label) || label < 0 || label > 1023) {\n\treturn am_badarg;\n    }\n    switch (label) {\n        N_STATEMENT(0);\n        N_STATEMENT(1);\n        N_STATEMENT(2);\n        N_STATEMENT(3);\n        N_STATEMENT(4);\n        N_STATEMENT(5);\n        N_STATEMENT(6);\n        N_STATEMENT(7);\n        N_STATEMENT(8);\n        N_STATEMENT(9);\n        N_STATEMENT(10);\n        N_STATEMENT(11);\n        N_STATEMENT(12);\n        N_STATEMENT(13);\n        N_STATEMENT(14);\n        N_STATEMENT(15);\n        N_STATEMENT(16);\n        N_STATEMENT(17);\n        N_STATEMENT(18);\n        N_STATEMENT(19);\n        N_STATEMENT(20);\n        N_STATEMENT(21);\n        N_STATEMENT(22);\n        N_STATEMENT(23);\n        N_STATEMENT(24);\n        N_STATEMENT(25);\n        N_STATEMENT(26);\n        N_STATEMENT(27);\n        N_STATEMENT(28);\n        N_STATEMENT(29);\n        N_STATEMENT(30);\n        N_STATEMENT(31);\n        N_STATEMENT(32);\n        N_STATEMENT(33);\n        N_STATEMENT(34);\n        N_STATEMENT(35);\n        N_STATEMENT(36);\n        N_STATEMENT(37);\n        N_STATEMENT(38);\n        N_STATEMENT(39);\n        N_STATEMENT(40);\n        N_STATEMENT(41);\n        N_STATEMENT(42);\n        N_STATEMENT(43);\n        N_STATEMENT(44);\n        N_STATEMENT(45);\n        N_STATEMENT(46);\n        N_STATEMENT(47);\n        N_STATEMENT(48);\n        N_STATEMENT(49);\n        N_STATEMENT(50);\n        N_STATEMENT(51);\n        N_STATEMENT(52);\n        N_STATEMENT(53);\n        N_STATEMENT(54);\n        N_STATEMENT(55);\n        N_STATEMENT(56);\n        N_STATEMENT(57);\n        N_STATEMENT(58);\n        N_STATEMENT(59);\n        N_STATEMENT(60);\n        N_STATEMENT(61);\n        N_STATEMENT(62);\n        N_STATEMENT(63);\n        N_STATEMENT(64);\n        N_STATEMENT(65);\n        N_STATEMENT(66);\n        N_STATEMENT(67);\n        N_STATEMENT(68);\n        N_STATEMENT(69);\n        N_STATEMENT(70);\n        N_STATEMENT(71);\n        N_STATEMENT(72);\n        N_STATEMENT(73);\n        N_STATEMENT(74);\n        N_STATEMENT(75);\n        N_STATEMENT(76);\n        N_STATEMENT(77);\n        N_STATEMENT(78);\n        N_STATEMENT(79);\n        N_STATEMENT(80);\n        N_STATEMENT(81);\n        N_STATEMENT(82);\n        N_STATEMENT(83);\n        N_STATEMENT(84);\n        N_STATEMENT(85);\n        N_STATEMENT(86);\n        N_STATEMENT(87);\n        N_STATEMENT(88);\n        N_STATEMENT(89);\n        N_STATEMENT(90);\n        N_STATEMENT(91);\n        N_STATEMENT(92);\n        N_STATEMENT(93);\n        N_STATEMENT(94);\n        N_STATEMENT(95);\n        N_STATEMENT(96);\n        N_STATEMENT(97);\n        N_STATEMENT(98);\n        N_STATEMENT(99);\n        N_STATEMENT(100);\n        N_STATEMENT(101);\n        N_STATEMENT(102);\n        N_STATEMENT(103);\n        N_STATEMENT(104);\n        N_STATEMENT(105);\n        N_STATEMENT(106);\n        N_STATEMENT(107);\n        N_STATEMENT(108);\n        N_STATEMENT(109);\n        N_STATEMENT(110);\n        N_STATEMENT(111);\n        N_STATEMENT(112);\n        N_STATEMENT(113);\n        N_STATEMENT(114);\n        N_STATEMENT(115);\n        N_STATEMENT(116);\n        N_STATEMENT(117);\n        N_STATEMENT(118);\n        N_STATEMENT(119);\n        N_STATEMENT(120);\n        N_STATEMENT(121);\n        N_STATEMENT(122);\n        N_STATEMENT(123);\n        N_STATEMENT(124);\n        N_STATEMENT(125);\n        N_STATEMENT(126);\n        N_STATEMENT(127);\n        N_STATEMENT(128);\n        N_STATEMENT(129);\n        N_STATEMENT(130);\n        N_STATEMENT(131);\n        N_STATEMENT(132);\n        N_STATEMENT(133);\n        N_STATEMENT(134);\n        N_STATEMENT(135);\n        N_STATEMENT(136);\n        N_STATEMENT(137);\n        N_STATEMENT(138);\n        N_STATEMENT(139);\n        N_STATEMENT(140);\n        N_STATEMENT(141);\n        N_STATEMENT(142);\n        N_STATEMENT(143);\n        N_STATEMENT(144);\n        N_STATEMENT(145);\n        N_STATEMENT(146);\n        N_STATEMENT(147);\n        N_STATEMENT(148);\n        N_STATEMENT(149);\n        N_STATEMENT(150);\n        N_STATEMENT(151);\n        N_STATEMENT(152);\n        N_STATEMENT(153);\n        N_STATEMENT(154);\n        N_STATEMENT(155);\n        N_STATEMENT(156);\n        N_STATEMENT(157);\n        N_STATEMENT(158);\n        N_STATEMENT(159);\n        N_STATEMENT(160);\n        N_STATEMENT(161);\n        N_STATEMENT(162);\n        N_STATEMENT(163);\n        N_STATEMENT(164);\n        N_STATEMENT(165);\n        N_STATEMENT(166);\n        N_STATEMENT(167);\n        N_STATEMENT(168);\n        N_STATEMENT(169);\n        N_STATEMENT(170);\n        N_STATEMENT(171);\n        N_STATEMENT(172);\n        N_STATEMENT(173);\n        N_STATEMENT(174);\n        N_STATEMENT(175);\n        N_STATEMENT(176);\n        N_STATEMENT(177);\n        N_STATEMENT(178);\n        N_STATEMENT(179);\n        N_STATEMENT(180);\n        N_STATEMENT(181);\n        N_STATEMENT(182);\n        N_STATEMENT(183);\n        N_STATEMENT(184);\n        N_STATEMENT(185);\n        N_STATEMENT(186);\n        N_STATEMENT(187);\n        N_STATEMENT(188);\n        N_STATEMENT(189);\n        N_STATEMENT(190);\n        N_STATEMENT(191);\n        N_STATEMENT(192);\n        N_STATEMENT(193);\n        N_STATEMENT(194);\n        N_STATEMENT(195);\n        N_STATEMENT(196);\n        N_STATEMENT(197);\n        N_STATEMENT(198);\n        N_STATEMENT(199);\n        N_STATEMENT(200);\n        N_STATEMENT(201);\n        N_STATEMENT(202);\n        N_STATEMENT(203);\n        N_STATEMENT(204);\n        N_STATEMENT(205);\n        N_STATEMENT(206);\n        N_STATEMENT(207);\n        N_STATEMENT(208);\n        N_STATEMENT(209);\n        N_STATEMENT(210);\n        N_STATEMENT(211);\n        N_STATEMENT(212);\n        N_STATEMENT(213);\n        N_STATEMENT(214);\n        N_STATEMENT(215);\n        N_STATEMENT(216);\n        N_STATEMENT(217);\n        N_STATEMENT(218);\n        N_STATEMENT(219);\n        N_STATEMENT(220);\n        N_STATEMENT(221);\n        N_STATEMENT(222);\n        N_STATEMENT(223);\n        N_STATEMENT(224);\n        N_STATEMENT(225);\n        N_STATEMENT(226);\n        N_STATEMENT(227);\n        N_STATEMENT(228);\n        N_STATEMENT(229);\n        N_STATEMENT(230);\n        N_STATEMENT(231);\n        N_STATEMENT(232);\n        N_STATEMENT(233);\n        N_STATEMENT(234);\n        N_STATEMENT(235);\n        N_STATEMENT(236);\n        N_STATEMENT(237);\n        N_STATEMENT(238);\n        N_STATEMENT(239);\n        N_STATEMENT(240);\n        N_STATEMENT(241);\n        N_STATEMENT(242);\n        N_STATEMENT(243);\n        N_STATEMENT(244);\n        N_STATEMENT(245);\n        N_STATEMENT(246);\n        N_STATEMENT(247);\n        N_STATEMENT(248);\n        N_STATEMENT(249);\n        N_STATEMENT(250);\n        N_STATEMENT(251);\n        N_STATEMENT(252);\n        N_STATEMENT(253);\n        N_STATEMENT(254);\n        N_STATEMENT(255);\n        N_STATEMENT(256);\n        N_STATEMENT(257);\n        N_STATEMENT(258);\n        N_STATEMENT(259);\n        N_STATEMENT(260);\n        N_STATEMENT(261);\n        N_STATEMENT(262);\n        N_STATEMENT(263);\n        N_STATEMENT(264);\n        N_STATEMENT(265);\n        N_STATEMENT(266);\n        N_STATEMENT(267);\n        N_STATEMENT(268);\n        N_STATEMENT(269);\n        N_STATEMENT(270);\n        N_STATEMENT(271);\n        N_STATEMENT(272);\n        N_STATEMENT(273);\n        N_STATEMENT(274);\n        N_STATEMENT(275);\n        N_STATEMENT(276);\n        N_STATEMENT(277);\n        N_STATEMENT(278);\n        N_STATEMENT(279);\n        N_STATEMENT(280);\n        N_STATEMENT(281);\n        N_STATEMENT(282);\n        N_STATEMENT(283);\n        N_STATEMENT(284);\n        N_STATEMENT(285);\n        N_STATEMENT(286);\n        N_STATEMENT(287);\n        N_STATEMENT(288);\n        N_STATEMENT(289);\n        N_STATEMENT(290);\n        N_STATEMENT(291);\n        N_STATEMENT(292);\n        N_STATEMENT(293);\n        N_STATEMENT(294);\n        N_STATEMENT(295);\n        N_STATEMENT(296);\n        N_STATEMENT(297);\n        N_STATEMENT(298);\n        N_STATEMENT(299);\n        N_STATEMENT(300);\n        N_STATEMENT(301);\n        N_STATEMENT(302);\n        N_STATEMENT(303);\n        N_STATEMENT(304);\n        N_STATEMENT(305);\n        N_STATEMENT(306);\n        N_STATEMENT(307);\n        N_STATEMENT(308);\n        N_STATEMENT(309);\n        N_STATEMENT(310);\n        N_STATEMENT(311);\n        N_STATEMENT(312);\n        N_STATEMENT(313);\n        N_STATEMENT(314);\n        N_STATEMENT(315);\n        N_STATEMENT(316);\n        N_STATEMENT(317);\n        N_STATEMENT(318);\n        N_STATEMENT(319);\n        N_STATEMENT(320);\n        N_STATEMENT(321);\n        N_STATEMENT(322);\n        N_STATEMENT(323);\n        N_STATEMENT(324);\n        N_STATEMENT(325);\n        N_STATEMENT(326);\n        N_STATEMENT(327);\n        N_STATEMENT(328);\n        N_STATEMENT(329);\n        N_STATEMENT(330);\n        N_STATEMENT(331);\n        N_STATEMENT(332);\n        N_STATEMENT(333);\n        N_STATEMENT(334);\n        N_STATEMENT(335);\n        N_STATEMENT(336);\n        N_STATEMENT(337);\n        N_STATEMENT(338);\n        N_STATEMENT(339);\n        N_STATEMENT(340);\n        N_STATEMENT(341);\n        N_STATEMENT(342);\n        N_STATEMENT(343);\n        N_STATEMENT(344);\n        N_STATEMENT(345);\n        N_STATEMENT(346);\n        N_STATEMENT(347);\n        N_STATEMENT(348);\n        N_STATEMENT(349);\n        N_STATEMENT(350);\n        N_STATEMENT(351);\n        N_STATEMENT(352);\n        N_STATEMENT(353);\n        N_STATEMENT(354);\n        N_STATEMENT(355);\n        N_STATEMENT(356);\n        N_STATEMENT(357);\n        N_STATEMENT(358);\n        N_STATEMENT(359);\n        N_STATEMENT(360);\n        N_STATEMENT(361);\n        N_STATEMENT(362);\n        N_STATEMENT(363);\n        N_STATEMENT(364);\n        N_STATEMENT(365);\n        N_STATEMENT(366);\n        N_STATEMENT(367);\n        N_STATEMENT(368);\n        N_STATEMENT(369);\n        N_STATEMENT(370);\n        N_STATEMENT(371);\n        N_STATEMENT(372);\n        N_STATEMENT(373);\n        N_STATEMENT(374);\n        N_STATEMENT(375);\n        N_STATEMENT(376);\n        N_STATEMENT(377);\n        N_STATEMENT(378);\n        N_STATEMENT(379);\n        N_STATEMENT(380);\n        N_STATEMENT(381);\n        N_STATEMENT(382);\n        N_STATEMENT(383);\n        N_STATEMENT(384);\n        N_STATEMENT(385);\n        N_STATEMENT(386);\n        N_STATEMENT(387);\n        N_STATEMENT(388);\n        N_STATEMENT(389);\n        N_STATEMENT(390);\n        N_STATEMENT(391);\n        N_STATEMENT(392);\n        N_STATEMENT(393);\n        N_STATEMENT(394);\n        N_STATEMENT(395);\n        N_STATEMENT(396);\n        N_STATEMENT(397);\n        N_STATEMENT(398);\n        N_STATEMENT(399);\n        N_STATEMENT(400);\n        N_STATEMENT(401);\n        N_STATEMENT(402);\n        N_STATEMENT(403);\n        N_STATEMENT(404);\n        N_STATEMENT(405);\n        N_STATEMENT(406);\n        N_STATEMENT(407);\n        N_STATEMENT(408);\n        N_STATEMENT(409);\n        N_STATEMENT(410);\n        N_STATEMENT(411);\n        N_STATEMENT(412);\n        N_STATEMENT(413);\n        N_STATEMENT(414);\n        N_STATEMENT(415);\n        N_STATEMENT(416);\n        N_STATEMENT(417);\n        N_STATEMENT(418);\n        N_STATEMENT(419);\n        N_STATEMENT(420);\n        N_STATEMENT(421);\n        N_STATEMENT(422);\n        N_STATEMENT(423);\n        N_STATEMENT(424);\n        N_STATEMENT(425);\n        N_STATEMENT(426);\n        N_STATEMENT(427);\n        N_STATEMENT(428);\n        N_STATEMENT(429);\n        N_STATEMENT(430);\n        N_STATEMENT(431);\n        N_STATEMENT(432);\n        N_STATEMENT(433);\n        N_STATEMENT(434);\n        N_STATEMENT(435);\n        N_STATEMENT(436);\n        N_STATEMENT(437);\n        N_STATEMENT(438);\n        N_STATEMENT(439);\n        N_STATEMENT(440);\n        N_STATEMENT(441);\n        N_STATEMENT(442);\n        N_STATEMENT(443);\n        N_STATEMENT(444);\n        N_STATEMENT(445);\n        N_STATEMENT(446);\n        N_STATEMENT(447);\n        N_STATEMENT(448);\n        N_STATEMENT(449);\n        N_STATEMENT(450);\n        N_STATEMENT(451);\n        N_STATEMENT(452);\n        N_STATEMENT(453);\n        N_STATEMENT(454);\n        N_STATEMENT(455);\n        N_STATEMENT(456);\n        N_STATEMENT(457);\n        N_STATEMENT(458);\n        N_STATEMENT(459);\n        N_STATEMENT(460);\n        N_STATEMENT(461);\n        N_STATEMENT(462);\n        N_STATEMENT(463);\n        N_STATEMENT(464);\n        N_STATEMENT(465);\n        N_STATEMENT(466);\n        N_STATEMENT(467);\n        N_STATEMENT(468);\n        N_STATEMENT(469);\n        N_STATEMENT(470);\n        N_STATEMENT(471);\n        N_STATEMENT(472);\n        N_STATEMENT(473);\n        N_STATEMENT(474);\n        N_STATEMENT(475);\n        N_STATEMENT(476);\n        N_STATEMENT(477);\n        N_STATEMENT(478);\n        N_STATEMENT(479);\n        N_STATEMENT(480);\n        N_STATEMENT(481);\n        N_STATEMENT(482);\n        N_STATEMENT(483);\n        N_STATEMENT(484);\n        N_STATEMENT(485);\n        N_STATEMENT(486);\n        N_STATEMENT(487);\n        N_STATEMENT(488);\n        N_STATEMENT(489);\n        N_STATEMENT(490);\n        N_STATEMENT(491);\n        N_STATEMENT(492);\n        N_STATEMENT(493);\n        N_STATEMENT(494);\n        N_STATEMENT(495);\n        N_STATEMENT(496);\n        N_STATEMENT(497);\n        N_STATEMENT(498);\n        N_STATEMENT(499);\n        N_STATEMENT(500);\n        N_STATEMENT(501);\n        N_STATEMENT(502);\n        N_STATEMENT(503);\n        N_STATEMENT(504);\n        N_STATEMENT(505);\n        N_STATEMENT(506);\n        N_STATEMENT(507);\n        N_STATEMENT(508);\n        N_STATEMENT(509);\n        N_STATEMENT(510);\n        N_STATEMENT(511);\n        N_STATEMENT(512);\n        N_STATEMENT(513);\n        N_STATEMENT(514);\n        N_STATEMENT(515);\n        N_STATEMENT(516);\n        N_STATEMENT(517);\n        N_STATEMENT(518);\n        N_STATEMENT(519);\n        N_STATEMENT(520);\n        N_STATEMENT(521);\n        N_STATEMENT(522);\n        N_STATEMENT(523);\n        N_STATEMENT(524);\n        N_STATEMENT(525);\n        N_STATEMENT(526);\n        N_STATEMENT(527);\n        N_STATEMENT(528);\n        N_STATEMENT(529);\n        N_STATEMENT(530);\n        N_STATEMENT(531);\n        N_STATEMENT(532);\n        N_STATEMENT(533);\n        N_STATEMENT(534);\n        N_STATEMENT(535);\n        N_STATEMENT(536);\n        N_STATEMENT(537);\n        N_STATEMENT(538);\n        N_STATEMENT(539);\n        N_STATEMENT(540);\n        N_STATEMENT(541);\n        N_STATEMENT(542);\n        N_STATEMENT(543);\n        N_STATEMENT(544);\n        N_STATEMENT(545);\n        N_STATEMENT(546);\n        N_STATEMENT(547);\n        N_STATEMENT(548);\n        N_STATEMENT(549);\n        N_STATEMENT(550);\n        N_STATEMENT(551);\n        N_STATEMENT(552);\n        N_STATEMENT(553);\n        N_STATEMENT(554);\n        N_STATEMENT(555);\n        N_STATEMENT(556);\n        N_STATEMENT(557);\n        N_STATEMENT(558);\n        N_STATEMENT(559);\n        N_STATEMENT(560);\n        N_STATEMENT(561);\n        N_STATEMENT(562);\n        N_STATEMENT(563);\n        N_STATEMENT(564);\n        N_STATEMENT(565);\n        N_STATEMENT(566);\n        N_STATEMENT(567);\n        N_STATEMENT(568);\n        N_STATEMENT(569);\n        N_STATEMENT(570);\n        N_STATEMENT(571);\n        N_STATEMENT(572);\n        N_STATEMENT(573);\n        N_STATEMENT(574);\n        N_STATEMENT(575);\n        N_STATEMENT(576);\n        N_STATEMENT(577);\n        N_STATEMENT(578);\n        N_STATEMENT(579);\n        N_STATEMENT(580);\n        N_STATEMENT(581);\n        N_STATEMENT(582);\n        N_STATEMENT(583);\n        N_STATEMENT(584);\n        N_STATEMENT(585);\n        N_STATEMENT(586);\n        N_STATEMENT(587);\n        N_STATEMENT(588);\n        N_STATEMENT(589);\n        N_STATEMENT(590);\n        N_STATEMENT(591);\n        N_STATEMENT(592);\n        N_STATEMENT(593);\n        N_STATEMENT(594);\n        N_STATEMENT(595);\n        N_STATEMENT(596);\n        N_STATEMENT(597);\n        N_STATEMENT(598);\n        N_STATEMENT(599);\n        N_STATEMENT(600);\n        N_STATEMENT(601);\n        N_STATEMENT(602);\n        N_STATEMENT(603);\n        N_STATEMENT(604);\n        N_STATEMENT(605);\n        N_STATEMENT(606);\n        N_STATEMENT(607);\n        N_STATEMENT(608);\n        N_STATEMENT(609);\n        N_STATEMENT(610);\n        N_STATEMENT(611);\n        N_STATEMENT(612);\n        N_STATEMENT(613);\n        N_STATEMENT(614);\n        N_STATEMENT(615);\n        N_STATEMENT(616);\n        N_STATEMENT(617);\n        N_STATEMENT(618);\n        N_STATEMENT(619);\n        N_STATEMENT(620);\n        N_STATEMENT(621);\n        N_STATEMENT(622);\n        N_STATEMENT(623);\n        N_STATEMENT(624);\n        N_STATEMENT(625);\n        N_STATEMENT(626);\n        N_STATEMENT(627);\n        N_STATEMENT(628);\n        N_STATEMENT(629);\n        N_STATEMENT(630);\n        N_STATEMENT(631);\n        N_STATEMENT(632);\n        N_STATEMENT(633);\n        N_STATEMENT(634);\n        N_STATEMENT(635);\n        N_STATEMENT(636);\n        N_STATEMENT(637);\n        N_STATEMENT(638);\n        N_STATEMENT(639);\n        N_STATEMENT(640);\n        N_STATEMENT(641);\n        N_STATEMENT(642);\n        N_STATEMENT(643);\n        N_STATEMENT(644);\n        N_STATEMENT(645);\n        N_STATEMENT(646);\n        N_STATEMENT(647);\n        N_STATEMENT(648);\n        N_STATEMENT(649);\n        N_STATEMENT(650);\n        N_STATEMENT(651);\n        N_STATEMENT(652);\n        N_STATEMENT(653);\n        N_STATEMENT(654);\n        N_STATEMENT(655);\n        N_STATEMENT(656);\n        N_STATEMENT(657);\n        N_STATEMENT(658);\n        N_STATEMENT(659);\n        N_STATEMENT(660);\n        N_STATEMENT(661);\n        N_STATEMENT(662);\n        N_STATEMENT(663);\n        N_STATEMENT(664);\n        N_STATEMENT(665);\n        N_STATEMENT(666);\n        N_STATEMENT(667);\n        N_STATEMENT(668);\n        N_STATEMENT(669);\n        N_STATEMENT(670);\n        N_STATEMENT(671);\n        N_STATEMENT(672);\n        N_STATEMENT(673);\n        N_STATEMENT(674);\n        N_STATEMENT(675);\n        N_STATEMENT(676);\n        N_STATEMENT(677);\n        N_STATEMENT(678);\n        N_STATEMENT(679);\n        N_STATEMENT(680);\n        N_STATEMENT(681);\n        N_STATEMENT(682);\n        N_STATEMENT(683);\n        N_STATEMENT(684);\n        N_STATEMENT(685);\n        N_STATEMENT(686);\n        N_STATEMENT(687);\n        N_STATEMENT(688);\n        N_STATEMENT(689);\n        N_STATEMENT(690);\n        N_STATEMENT(691);\n        N_STATEMENT(692);\n        N_STATEMENT(693);\n        N_STATEMENT(694);\n        N_STATEMENT(695);\n        N_STATEMENT(696);\n        N_STATEMENT(697);\n        N_STATEMENT(698);\n        N_STATEMENT(699);\n        N_STATEMENT(700);\n        N_STATEMENT(701);\n        N_STATEMENT(702);\n        N_STATEMENT(703);\n        N_STATEMENT(704);\n        N_STATEMENT(705);\n        N_STATEMENT(706);\n        N_STATEMENT(707);\n        N_STATEMENT(708);\n        N_STATEMENT(709);\n        N_STATEMENT(710);\n        N_STATEMENT(711);\n        N_STATEMENT(712);\n        N_STATEMENT(713);\n        N_STATEMENT(714);\n        N_STATEMENT(715);\n        N_STATEMENT(716);\n        N_STATEMENT(717);\n        N_STATEMENT(718);\n        N_STATEMENT(719);\n        N_STATEMENT(720);\n        N_STATEMENT(721);\n        N_STATEMENT(722);\n        N_STATEMENT(723);\n        N_STATEMENT(724);\n        N_STATEMENT(725);\n        N_STATEMENT(726);\n        N_STATEMENT(727);\n        N_STATEMENT(728);\n        N_STATEMENT(729);\n        N_STATEMENT(730);\n        N_STATEMENT(731);\n        N_STATEMENT(732);\n        N_STATEMENT(733);\n        N_STATEMENT(734);\n        N_STATEMENT(735);\n        N_STATEMENT(736);\n        N_STATEMENT(737);\n        N_STATEMENT(738);\n        N_STATEMENT(739);\n        N_STATEMENT(740);\n        N_STATEMENT(741);\n        N_STATEMENT(742);\n        N_STATEMENT(743);\n        N_STATEMENT(744);\n        N_STATEMENT(745);\n        N_STATEMENT(746);\n        N_STATEMENT(747);\n        N_STATEMENT(748);\n        N_STATEMENT(749);\n        N_STATEMENT(750);\n        N_STATEMENT(751);\n        N_STATEMENT(752);\n        N_STATEMENT(753);\n        N_STATEMENT(754);\n        N_STATEMENT(755);\n        N_STATEMENT(756);\n        N_STATEMENT(757);\n        N_STATEMENT(758);\n        N_STATEMENT(759);\n        N_STATEMENT(760);\n        N_STATEMENT(761);\n        N_STATEMENT(762);\n        N_STATEMENT(763);\n        N_STATEMENT(764);\n        N_STATEMENT(765);\n        N_STATEMENT(766);\n        N_STATEMENT(767);\n        N_STATEMENT(768);\n        N_STATEMENT(769);\n        N_STATEMENT(770);\n        N_STATEMENT(771);\n        N_STATEMENT(772);\n        N_STATEMENT(773);\n        N_STATEMENT(774);\n        N_STATEMENT(775);\n        N_STATEMENT(776);\n        N_STATEMENT(777);\n        N_STATEMENT(778);\n        N_STATEMENT(779);\n        N_STATEMENT(780);\n        N_STATEMENT(781);\n        N_STATEMENT(782);\n        N_STATEMENT(783);\n        N_STATEMENT(784);\n        N_STATEMENT(785);\n        N_STATEMENT(786);\n        N_STATEMENT(787);\n        N_STATEMENT(788);\n        N_STATEMENT(789);\n        N_STATEMENT(790);\n        N_STATEMENT(791);\n        N_STATEMENT(792);\n        N_STATEMENT(793);\n        N_STATEMENT(794);\n        N_STATEMENT(795);\n        N_STATEMENT(796);\n        N_STATEMENT(797);\n        N_STATEMENT(798);\n        N_STATEMENT(799);\n        N_STATEMENT(800);\n        N_STATEMENT(801);\n        N_STATEMENT(802);\n        N_STATEMENT(803);\n        N_STATEMENT(804);\n        N_STATEMENT(805);\n        N_STATEMENT(806);\n        N_STATEMENT(807);\n        N_STATEMENT(808);\n        N_STATEMENT(809);\n        N_STATEMENT(810);\n        N_STATEMENT(811);\n        N_STATEMENT(812);\n        N_STATEMENT(813);\n        N_STATEMENT(814);\n        N_STATEMENT(815);\n        N_STATEMENT(816);\n        N_STATEMENT(817);\n        N_STATEMENT(818);\n        N_STATEMENT(819);\n        N_STATEMENT(820);\n        N_STATEMENT(821);\n        N_STATEMENT(822);\n        N_STATEMENT(823);\n        N_STATEMENT(824);\n        N_STATEMENT(825);\n        N_STATEMENT(826);\n        N_STATEMENT(827);\n        N_STATEMENT(828);\n        N_STATEMENT(829);\n        N_STATEMENT(830);\n        N_STATEMENT(831);\n        N_STATEMENT(832);\n        N_STATEMENT(833);\n        N_STATEMENT(834);\n        N_STATEMENT(835);\n        N_STATEMENT(836);\n        N_STATEMENT(837);\n        N_STATEMENT(838);\n        N_STATEMENT(839);\n        N_STATEMENT(840);\n        N_STATEMENT(841);\n        N_STATEMENT(842);\n        N_STATEMENT(843);\n        N_STATEMENT(844);\n        N_STATEMENT(845);\n        N_STATEMENT(846);\n        N_STATEMENT(847);\n        N_STATEMENT(848);\n        N_STATEMENT(849);\n        N_STATEMENT(850);\n        N_STATEMENT(851);\n        N_STATEMENT(852);\n        N_STATEMENT(853);\n        N_STATEMENT(854);\n        N_STATEMENT(855);\n        N_STATEMENT(856);\n        N_STATEMENT(857);\n        N_STATEMENT(858);\n        N_STATEMENT(859);\n        N_STATEMENT(860);\n        N_STATEMENT(861);\n        N_STATEMENT(862);\n        N_STATEMENT(863);\n        N_STATEMENT(864);\n        N_STATEMENT(865);\n        N_STATEMENT(866);\n        N_STATEMENT(867);\n        N_STATEMENT(868);\n        N_STATEMENT(869);\n        N_STATEMENT(870);\n        N_STATEMENT(871);\n        N_STATEMENT(872);\n        N_STATEMENT(873);\n        N_STATEMENT(874);\n        N_STATEMENT(875);\n        N_STATEMENT(876);\n        N_STATEMENT(877);\n        N_STATEMENT(878);\n        N_STATEMENT(879);\n        N_STATEMENT(880);\n        N_STATEMENT(881);\n        N_STATEMENT(882);\n        N_STATEMENT(883);\n        N_STATEMENT(884);\n        N_STATEMENT(885);\n        N_STATEMENT(886);\n        N_STATEMENT(887);\n        N_STATEMENT(888);\n        N_STATEMENT(889);\n        N_STATEMENT(890);\n        N_STATEMENT(891);\n        N_STATEMENT(892);\n        N_STATEMENT(893);\n        N_STATEMENT(894);\n        N_STATEMENT(895);\n        N_STATEMENT(896);\n        N_STATEMENT(897);\n        N_STATEMENT(898);\n        N_STATEMENT(899);\n        N_STATEMENT(900);\n        N_STATEMENT(901);\n        N_STATEMENT(902);\n        N_STATEMENT(903);\n        N_STATEMENT(904);\n        N_STATEMENT(905);\n        N_STATEMENT(906);\n        N_STATEMENT(907);\n        N_STATEMENT(908);\n        N_STATEMENT(909);\n        N_STATEMENT(910);\n        N_STATEMENT(911);\n        N_STATEMENT(912);\n        N_STATEMENT(913);\n        N_STATEMENT(914);\n        N_STATEMENT(915);\n        N_STATEMENT(916);\n        N_STATEMENT(917);\n        N_STATEMENT(918);\n        N_STATEMENT(919);\n        N_STATEMENT(920);\n        N_STATEMENT(921);\n        N_STATEMENT(922);\n        N_STATEMENT(923);\n        N_STATEMENT(924);\n        N_STATEMENT(925);\n        N_STATEMENT(926);\n        N_STATEMENT(927);\n        N_STATEMENT(928);\n        N_STATEMENT(929);\n        N_STATEMENT(930);\n        N_STATEMENT(931);\n        N_STATEMENT(932);\n        N_STATEMENT(933);\n        N_STATEMENT(934);\n        N_STATEMENT(935);\n        N_STATEMENT(936);\n        N_STATEMENT(937);\n        N_STATEMENT(938);\n        N_STATEMENT(939);\n        N_STATEMENT(940);\n        N_STATEMENT(941);\n        N_STATEMENT(942);\n        N_STATEMENT(943);\n        N_STATEMENT(944);\n        N_STATEMENT(945);\n        N_STATEMENT(946);\n        N_STATEMENT(947);\n        N_STATEMENT(948);\n        N_STATEMENT(949);\n        N_STATEMENT(950);\n    }\n    return am_error;          /* NOTREACHED, shut up the compiler */\n}\n\n#endif /* HAVE_USE_DTRACE */\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/beam/erl_nif_api_funcs.h": "/*\n * %CopyrightBegin%\n *\n * Copyright Ericsson AB 2009-2018. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * %CopyrightEnd%\n */\n\n#if !defined(ERL_NIF_API_FUNC_DECL) && !defined(ERL_NIF_API_FUNC_MACRO)\n#  error This file should not be included directly\n#endif\n\n/*\n** WARNING: Add new ERL_NIF_API_FUNC_DECL entries at the bottom of the list\n** to keep compatibility on Windows!!!\n**\n** And don't forget to increase ERL_NIF_MINOR_VERSION in erl_nif.h\n** when adding functions to the API.\n*/\n#ifdef ERL_NIF_API_FUNC_DECL\nERL_NIF_API_FUNC_DECL(void*,enif_priv_data,(ErlNifEnv*));\nERL_NIF_API_FUNC_DECL(void*,enif_alloc,(size_t size));\nERL_NIF_API_FUNC_DECL(void,enif_free,(void* ptr));\nERL_NIF_API_FUNC_DECL(int,enif_is_atom,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_is_binary,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_is_ref,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_inspect_binary,(ErlNifEnv*, ERL_NIF_TERM bin_term, ErlNifBinary* bin));\nERL_NIF_API_FUNC_DECL(int,enif_alloc_binary,(size_t size, ErlNifBinary* bin));\nERL_NIF_API_FUNC_DECL(int,enif_realloc_binary,(ErlNifBinary* bin, size_t size));\nERL_NIF_API_FUNC_DECL(void,enif_release_binary,(ErlNifBinary* bin));\nERL_NIF_API_FUNC_DECL(int,enif_get_int,(ErlNifEnv*, ERL_NIF_TERM term, int* ip));\nERL_NIF_API_FUNC_DECL(int,enif_get_ulong,(ErlNifEnv*, ERL_NIF_TERM term, unsigned long* ip));\nERL_NIF_API_FUNC_DECL(int,enif_get_double,(ErlNifEnv*, ERL_NIF_TERM term, double* dp));\nERL_NIF_API_FUNC_DECL(int,enif_get_list_cell,(ErlNifEnv* env, ERL_NIF_TERM term, ERL_NIF_TERM* head, ERL_NIF_TERM* tail));\nERL_NIF_API_FUNC_DECL(int,enif_get_tuple,(ErlNifEnv* env, ERL_NIF_TERM tpl, int* arity, const ERL_NIF_TERM** array));\nERL_NIF_API_FUNC_DECL(int,enif_is_identical,(ERL_NIF_TERM lhs, ERL_NIF_TERM rhs));\nERL_NIF_API_FUNC_DECL(int,enif_compare,(ERL_NIF_TERM lhs, ERL_NIF_TERM rhs));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_binary,(ErlNifEnv* env, ErlNifBinary* bin));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_badarg,(ErlNifEnv* env));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_int,(ErlNifEnv* env, int i));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_ulong,(ErlNifEnv* env, unsigned long i));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_double,(ErlNifEnv* env, double d));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_atom,(ErlNifEnv* env, const char* name));\nERL_NIF_API_FUNC_DECL(int,enif_make_existing_atom,(ErlNifEnv* env, const char* name, ERL_NIF_TERM* atom, ErlNifCharEncoding));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_tuple,(ErlNifEnv* env, unsigned cnt, ...));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_list,(ErlNifEnv* env, unsigned cnt, ...));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_list_cell,(ErlNifEnv* env, ERL_NIF_TERM car, ERL_NIF_TERM cdr));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_string,(ErlNifEnv* env, const char* string, ErlNifCharEncoding));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_ref,(ErlNifEnv* env));\n\nERL_NIF_API_FUNC_DECL(ErlNifMutex*,enif_mutex_create,(char *name));\nERL_NIF_API_FUNC_DECL(void,enif_mutex_destroy,(ErlNifMutex *mtx));\nERL_NIF_API_FUNC_DECL(int,enif_mutex_trylock,(ErlNifMutex *mtx));\nERL_NIF_API_FUNC_DECL(void,enif_mutex_lock,(ErlNifMutex *mtx));\nERL_NIF_API_FUNC_DECL(void,enif_mutex_unlock,(ErlNifMutex *mtx));\nERL_NIF_API_FUNC_DECL(ErlNifCond*,enif_cond_create,(char *name));\nERL_NIF_API_FUNC_DECL(void,enif_cond_destroy,(ErlNifCond *cnd));\nERL_NIF_API_FUNC_DECL(void,enif_cond_signal,(ErlNifCond *cnd));\nERL_NIF_API_FUNC_DECL(void,enif_cond_broadcast,(ErlNifCond *cnd));\nERL_NIF_API_FUNC_DECL(void,enif_cond_wait,(ErlNifCond *cnd, ErlNifMutex *mtx));\nERL_NIF_API_FUNC_DECL(ErlNifRWLock*,enif_rwlock_create,(char *name));\nERL_NIF_API_FUNC_DECL(void,enif_rwlock_destroy,(ErlNifRWLock *rwlck));\nERL_NIF_API_FUNC_DECL(int,enif_rwlock_tryrlock,(ErlNifRWLock *rwlck));\nERL_NIF_API_FUNC_DECL(void,enif_rwlock_rlock,(ErlNifRWLock *rwlck));\nERL_NIF_API_FUNC_DECL(void,enif_rwlock_runlock,(ErlNifRWLock *rwlck));\nERL_NIF_API_FUNC_DECL(int,enif_rwlock_tryrwlock,(ErlNifRWLock *rwlck));\nERL_NIF_API_FUNC_DECL(void,enif_rwlock_rwlock,(ErlNifRWLock *rwlck));\nERL_NIF_API_FUNC_DECL(void,enif_rwlock_rwunlock,(ErlNifRWLock *rwlck));\nERL_NIF_API_FUNC_DECL(int,enif_tsd_key_create,(char *name, ErlNifTSDKey *key));\nERL_NIF_API_FUNC_DECL(void,enif_tsd_key_destroy,(ErlNifTSDKey key));\nERL_NIF_API_FUNC_DECL(void,enif_tsd_set,(ErlNifTSDKey key, void *data));\nERL_NIF_API_FUNC_DECL(void*,enif_tsd_get,(ErlNifTSDKey key));\nERL_NIF_API_FUNC_DECL(ErlNifThreadOpts*,enif_thread_opts_create,(char *name));\nERL_NIF_API_FUNC_DECL(void,enif_thread_opts_destroy,(ErlNifThreadOpts *opts));\nERL_NIF_API_FUNC_DECL(int,enif_thread_create,(char *name,ErlNifTid *tid,void * (*func)(void *),void *args,ErlNifThreadOpts *opts));\nERL_NIF_API_FUNC_DECL(ErlNifTid,enif_thread_self,(void));\nERL_NIF_API_FUNC_DECL(int,enif_equal_tids,(ErlNifTid tid1, ErlNifTid tid2));\nERL_NIF_API_FUNC_DECL(void,enif_thread_exit,(void *resp));\nERL_NIF_API_FUNC_DECL(int,enif_thread_join,(ErlNifTid, void **respp));\n\nERL_NIF_API_FUNC_DECL(void*,enif_realloc,(void* ptr, size_t size));\nERL_NIF_API_FUNC_DECL(void,enif_system_info,(ErlNifSysInfo *sip, size_t si_size));\nERL_NIF_API_FUNC_DECL(int,enif_fprintf,(FILE* filep, const char *format, ...));\nERL_NIF_API_FUNC_DECL(int,enif_inspect_iolist_as_binary,(ErlNifEnv*, ERL_NIF_TERM term, ErlNifBinary* bin));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_sub_binary,(ErlNifEnv*, ERL_NIF_TERM bin_term, size_t pos, size_t size));\nERL_NIF_API_FUNC_DECL(int,enif_get_string,(ErlNifEnv*, ERL_NIF_TERM list, char* buf, unsigned len, ErlNifCharEncoding));\nERL_NIF_API_FUNC_DECL(int,enif_get_atom,(ErlNifEnv*, ERL_NIF_TERM atom, char* buf, unsigned len, ErlNifCharEncoding));\nERL_NIF_API_FUNC_DECL(int,enif_is_fun,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_is_pid,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_is_port,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_get_uint,(ErlNifEnv*, ERL_NIF_TERM term, unsigned* ip));\nERL_NIF_API_FUNC_DECL(int,enif_get_long,(ErlNifEnv*, ERL_NIF_TERM term, long* ip));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_uint,(ErlNifEnv*, unsigned i));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_long,(ErlNifEnv*, long i));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_tuple_from_array,(ErlNifEnv*, const ERL_NIF_TERM arr[], unsigned cnt));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_list_from_array,(ErlNifEnv*, const ERL_NIF_TERM arr[], unsigned cnt));\nERL_NIF_API_FUNC_DECL(int,enif_is_empty_list,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(ErlNifResourceType*,enif_open_resource_type,(ErlNifEnv*, const char* module_str, const char* name_str, void (*dtor)(ErlNifEnv*,void *), ErlNifResourceFlags flags, ErlNifResourceFlags* tried));\nERL_NIF_API_FUNC_DECL(void*,enif_alloc_resource,(ErlNifResourceType* type, size_t size));\nERL_NIF_API_FUNC_DECL(void,enif_release_resource,(void* obj));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_resource,(ErlNifEnv*, void* obj));\nERL_NIF_API_FUNC_DECL(int,enif_get_resource,(ErlNifEnv*, ERL_NIF_TERM term, ErlNifResourceType* type, void** objp));\nERL_NIF_API_FUNC_DECL(size_t,enif_sizeof_resource,(void* obj));\nERL_NIF_API_FUNC_DECL(unsigned char*,enif_make_new_binary,(ErlNifEnv*,size_t size,ERL_NIF_TERM* termp));\nERL_NIF_API_FUNC_DECL(int,enif_is_list,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_is_tuple,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_get_atom_length,(ErlNifEnv*, ERL_NIF_TERM atom, unsigned* len, ErlNifCharEncoding));\nERL_NIF_API_FUNC_DECL(int,enif_get_list_length,(ErlNifEnv* env, ERL_NIF_TERM term, unsigned* len));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM, enif_make_atom_len,(ErlNifEnv* env, const char* name, size_t len));\nERL_NIF_API_FUNC_DECL(int, enif_make_existing_atom_len,(ErlNifEnv* env, const char* name, size_t len, ERL_NIF_TERM* atom, ErlNifCharEncoding));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_string_len,(ErlNifEnv* env, const char* string, size_t len, ErlNifCharEncoding));\nERL_NIF_API_FUNC_DECL(ErlNifEnv*,enif_alloc_env,(void));\nERL_NIF_API_FUNC_DECL(void,enif_free_env,(ErlNifEnv* env));\nERL_NIF_API_FUNC_DECL(void,enif_clear_env,(ErlNifEnv* env));\nERL_NIF_API_FUNC_DECL(int,enif_send,(ErlNifEnv* env, const ErlNifPid* to_pid, ErlNifEnv* msg_env, ERL_NIF_TERM msg));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_copy,(ErlNifEnv* dst_env, ERL_NIF_TERM src_term));\nERL_NIF_API_FUNC_DECL(ErlNifPid*,enif_self,(ErlNifEnv* caller_env, ErlNifPid* pid));\nERL_NIF_API_FUNC_DECL(int,enif_get_local_pid,(ErlNifEnv* env, ERL_NIF_TERM, ErlNifPid* pid));\nERL_NIF_API_FUNC_DECL(void,enif_keep_resource,(void* obj));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_resource_binary,(ErlNifEnv*,void* obj,const void* data, size_t size));\n#if SIZEOF_LONG != 8\nERL_NIF_API_FUNC_DECL(int,enif_get_int64,(ErlNifEnv*, ERL_NIF_TERM term, ErlNifSInt64* ip));\nERL_NIF_API_FUNC_DECL(int,enif_get_uint64,(ErlNifEnv*, ERL_NIF_TERM term, ErlNifUInt64* ip));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_int64,(ErlNifEnv*, ErlNifSInt64));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_uint64,(ErlNifEnv*, ErlNifUInt64));\n#endif\nERL_NIF_API_FUNC_DECL(int,enif_is_exception,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int,enif_make_reverse_list,(ErlNifEnv*, ERL_NIF_TERM term, ERL_NIF_TERM *list));\nERL_NIF_API_FUNC_DECL(int,enif_is_number,(ErlNifEnv*, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(void*,enif_dlopen,(const char* lib, void (*err_handler)(void*,const char*), void* err_arg));\nERL_NIF_API_FUNC_DECL(void*,enif_dlsym,(void* handle, const char* symbol, void (*err_handler)(void*,const char*), void* err_arg));\nERL_NIF_API_FUNC_DECL(int,enif_consume_timeslice,(ErlNifEnv*, int percent));\nERL_NIF_API_FUNC_DECL(int, enif_is_map, (ErlNifEnv* env, ERL_NIF_TERM term));\nERL_NIF_API_FUNC_DECL(int, enif_get_map_size, (ErlNifEnv* env, ERL_NIF_TERM term, size_t *size));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM, enif_make_new_map, (ErlNifEnv* env));\nERL_NIF_API_FUNC_DECL(int, enif_make_map_put, (ErlNifEnv* env, ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM value, ERL_NIF_TERM* map_out));\nERL_NIF_API_FUNC_DECL(int, enif_get_map_value, (ErlNifEnv* env, ERL_NIF_TERM map, ERL_NIF_TERM key, ERL_NIF_TERM* value));\nERL_NIF_API_FUNC_DECL(int, enif_make_map_update, (ErlNifEnv* env, ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM value, ERL_NIF_TERM* map_out));\nERL_NIF_API_FUNC_DECL(int, enif_make_map_remove, (ErlNifEnv* env, ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM* map_out));\nERL_NIF_API_FUNC_DECL(int, enif_map_iterator_create, (ErlNifEnv *env, ERL_NIF_TERM map, ErlNifMapIterator *iter, ErlNifMapIteratorEntry entry));\nERL_NIF_API_FUNC_DECL(void, enif_map_iterator_destroy, (ErlNifEnv *env, ErlNifMapIterator *iter));\nERL_NIF_API_FUNC_DECL(int, enif_map_iterator_is_head, (ErlNifEnv *env, ErlNifMapIterator *iter));\nERL_NIF_API_FUNC_DECL(int, enif_map_iterator_is_tail, (ErlNifEnv *env, ErlNifMapIterator *iter));\nERL_NIF_API_FUNC_DECL(int, enif_map_iterator_next, (ErlNifEnv *env, ErlNifMapIterator *iter));\nERL_NIF_API_FUNC_DECL(int, enif_map_iterator_prev, (ErlNifEnv *env, ErlNifMapIterator *iter));\nERL_NIF_API_FUNC_DECL(int, enif_map_iterator_get_pair, (ErlNifEnv *env, ErlNifMapIterator *iter, ERL_NIF_TERM *key, ERL_NIF_TERM *value));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_schedule_nif,(ErlNifEnv*,const char*,int,ERL_NIF_TERM (*)(ErlNifEnv*,int,const ERL_NIF_TERM[]),int,const ERL_NIF_TERM[]));\nERL_NIF_API_FUNC_DECL(int, enif_has_pending_exception, (ErlNifEnv *env, ERL_NIF_TERM* reason));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM, enif_raise_exception, (ErlNifEnv *env, ERL_NIF_TERM reason));\nERL_NIF_API_FUNC_DECL(int,enif_getenv,(const char* key, char* value, size_t* value_size));\nERL_NIF_API_FUNC_DECL(ErlNifTime, enif_monotonic_time, (ErlNifTimeUnit));\nERL_NIF_API_FUNC_DECL(ErlNifTime, enif_time_offset, (ErlNifTimeUnit));\nERL_NIF_API_FUNC_DECL(ErlNifTime, enif_convert_time_unit, (ErlNifTime, ErlNifTimeUnit, ErlNifTimeUnit));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM, enif_now_time, (ErlNifEnv *env));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM, enif_cpu_time, (ErlNifEnv *env));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM, enif_make_unique_integer, (ErlNifEnv *env, ErlNifUniqueInteger properties));\nERL_NIF_API_FUNC_DECL(int, enif_is_current_process_alive, (ErlNifEnv *env));\nERL_NIF_API_FUNC_DECL(int, enif_is_process_alive, (ErlNifEnv *env, ErlNifPid *pid));\nERL_NIF_API_FUNC_DECL(int, enif_is_port_alive, (ErlNifEnv *env, ErlNifPort *port_id));\nERL_NIF_API_FUNC_DECL(int, enif_get_local_port, (ErlNifEnv* env, ERL_NIF_TERM, ErlNifPort* port_id));\nERL_NIF_API_FUNC_DECL(int, enif_term_to_binary, (ErlNifEnv *env, ERL_NIF_TERM term, ErlNifBinary *bin));\nERL_NIF_API_FUNC_DECL(size_t, enif_binary_to_term, (ErlNifEnv *env, const unsigned char* data, size_t sz, ERL_NIF_TERM *term, unsigned int opts));\nERL_NIF_API_FUNC_DECL(int, enif_port_command, (ErlNifEnv *env, const ErlNifPort* to_port, ErlNifEnv *msg_env, ERL_NIF_TERM msg));\nERL_NIF_API_FUNC_DECL(int,enif_thread_type,(void));\nERL_NIF_API_FUNC_DECL(int,enif_snprintf,(char * buffer, size_t size, const char *format, ...));\nERL_NIF_API_FUNC_DECL(int,enif_select,(ErlNifEnv* env, ErlNifEvent e, enum ErlNifSelectFlags flags, void* obj, const ErlNifPid* pid, ERL_NIF_TERM ref));\nERL_NIF_API_FUNC_DECL(ErlNifResourceType*,enif_open_resource_type_x,(ErlNifEnv*, const char* name_str, const ErlNifResourceTypeInit*, ErlNifResourceFlags flags, ErlNifResourceFlags* tried));\nERL_NIF_API_FUNC_DECL(int, enif_monitor_process,(ErlNifEnv*,void* obj,const ErlNifPid*,ErlNifMonitor *monitor));\nERL_NIF_API_FUNC_DECL(int, enif_demonitor_process,(ErlNifEnv*,void* obj,const ErlNifMonitor *monitor));\nERL_NIF_API_FUNC_DECL(int, enif_compare_monitors,(const ErlNifMonitor*,const ErlNifMonitor*));\nERL_NIF_API_FUNC_DECL(ErlNifUInt64,enif_hash,(ErlNifHash type, ERL_NIF_TERM term, ErlNifUInt64 salt));\nERL_NIF_API_FUNC_DECL(int, enif_whereis_pid, (ErlNifEnv *env, ERL_NIF_TERM name, ErlNifPid *pid));\nERL_NIF_API_FUNC_DECL(int, enif_whereis_port, (ErlNifEnv *env, ERL_NIF_TERM name, ErlNifPort *port));\n\nERL_NIF_API_FUNC_DECL(ErlNifIOQueue *,enif_ioq_create,(ErlNifIOQueueOpts opts));\nERL_NIF_API_FUNC_DECL(void,enif_ioq_destroy,(ErlNifIOQueue *q));\n\nERL_NIF_API_FUNC_DECL(int,enif_ioq_enq_binary,(ErlNifIOQueue *q, ErlNifBinary *bin, size_t skip));\nERL_NIF_API_FUNC_DECL(int,enif_ioq_enqv,(ErlNifIOQueue *q, ErlNifIOVec *iov, size_t skip));\n\nERL_NIF_API_FUNC_DECL(size_t,enif_ioq_size,(ErlNifIOQueue *q));\nERL_NIF_API_FUNC_DECL(int,enif_ioq_deq,(ErlNifIOQueue *q, size_t count, size_t *size));\n\nERL_NIF_API_FUNC_DECL(SysIOVec*,enif_ioq_peek,(ErlNifIOQueue *q, int *iovlen));\n\nERL_NIF_API_FUNC_DECL(int,enif_inspect_iovec,(ErlNifEnv *env, size_t max_length, ERL_NIF_TERM iovec_term, ERL_NIF_TERM *tail, ErlNifIOVec **iovec));\nERL_NIF_API_FUNC_DECL(void,enif_free_iovec,(ErlNifIOVec *iov));\n\nERL_NIF_API_FUNC_DECL(int,enif_ioq_peek_head,(ErlNifEnv *env, ErlNifIOQueue *q, size_t *size, ERL_NIF_TERM *head));\n\nERL_NIF_API_FUNC_DECL(char*,enif_mutex_name,(ErlNifMutex*));\nERL_NIF_API_FUNC_DECL(char*,enif_cond_name,(ErlNifCond*));\nERL_NIF_API_FUNC_DECL(char*,enif_rwlock_name,(ErlNifRWLock*));\nERL_NIF_API_FUNC_DECL(char*,enif_thread_name,(ErlNifTid));\n\nERL_NIF_API_FUNC_DECL(int,enif_vfprintf,(FILE*, const char *fmt, va_list));\nERL_NIF_API_FUNC_DECL(int,enif_vsnprintf,(char*, size_t, const char *fmt, va_list));\n\nERL_NIF_API_FUNC_DECL(int,enif_make_map_from_arrays,(ErlNifEnv *env, ERL_NIF_TERM keys[], ERL_NIF_TERM values[], size_t cnt, ERL_NIF_TERM *map_out));\n\nERL_NIF_API_FUNC_DECL(int,enif_select_x,(ErlNifEnv* env, ErlNifEvent e, enum ErlNifSelectFlags flags, void* obj, const ErlNifPid* pid, ERL_NIF_TERM msg, ErlNifEnv* msg_env));\nERL_NIF_API_FUNC_DECL(ERL_NIF_TERM,enif_make_monitor_term,(ErlNifEnv* env, const ErlNifMonitor*));\nERL_NIF_API_FUNC_DECL(void,enif_set_pid_undefined,(ErlNifPid* pid));\nERL_NIF_API_FUNC_DECL(int,enif_is_pid_undefined,(const ErlNifPid* pid));\n\nERL_NIF_API_FUNC_DECL(ErlNifTermType,enif_term_type,(ErlNifEnv* env, ERL_NIF_TERM term));\n\n/*\n** ADD NEW ENTRIES HERE (before this comment) !!!\n*/\n#endif /* ERL_NIF_API_FUNC_DECL */\n\n/*\n** Please keep the ERL_NIF_API_FUNC_MACRO list below in the same order\n** as the ERL_NIF_API_FUNC_DECL list above\n*/\n#ifdef ERL_NIF_API_FUNC_MACRO\n#  define enif_priv_data ERL_NIF_API_FUNC_MACRO(enif_priv_data)\n#  define enif_alloc ERL_NIF_API_FUNC_MACRO(enif_alloc)\n#  define enif_free ERL_NIF_API_FUNC_MACRO(enif_free)\n#  define enif_is_atom ERL_NIF_API_FUNC_MACRO(enif_is_atom)\n#  define enif_is_binary ERL_NIF_API_FUNC_MACRO(enif_is_binary)\n#  define enif_is_ref ERL_NIF_API_FUNC_MACRO(enif_is_ref)\n#  define enif_inspect_binary ERL_NIF_API_FUNC_MACRO(enif_inspect_binary)\n#  define enif_alloc_binary ERL_NIF_API_FUNC_MACRO(enif_alloc_binary)\n#  define enif_realloc_binary ERL_NIF_API_FUNC_MACRO(enif_realloc_binary)\n#  define enif_release_binary ERL_NIF_API_FUNC_MACRO(enif_release_binary)\n#  define enif_get_int ERL_NIF_API_FUNC_MACRO(enif_get_int)\n#  define enif_get_ulong ERL_NIF_API_FUNC_MACRO(enif_get_ulong)\n#  define enif_get_double ERL_NIF_API_FUNC_MACRO(enif_get_double)\n#  define enif_get_tuple ERL_NIF_API_FUNC_MACRO(enif_get_tuple)\n#  define enif_get_list_cell ERL_NIF_API_FUNC_MACRO(enif_get_list_cell)\n#  define enif_is_identical ERL_NIF_API_FUNC_MACRO(enif_is_identical)\n#  define enif_compare ERL_NIF_API_FUNC_MACRO(enif_compare)\n\n#  define enif_make_binary ERL_NIF_API_FUNC_MACRO(enif_make_binary)\n#  define enif_make_badarg ERL_NIF_API_FUNC_MACRO(enif_make_badarg)\n#  define enif_make_int ERL_NIF_API_FUNC_MACRO(enif_make_int)\n#  define enif_make_ulong ERL_NIF_API_FUNC_MACRO(enif_make_ulong)\n#  define enif_make_double ERL_NIF_API_FUNC_MACRO(enif_make_double)\n#  define enif_make_atom ERL_NIF_API_FUNC_MACRO(enif_make_atom)\n#  define enif_make_existing_atom ERL_NIF_API_FUNC_MACRO(enif_make_existing_atom)\n#  define enif_make_tuple ERL_NIF_API_FUNC_MACRO(enif_make_tuple)\n#  define enif_make_list ERL_NIF_API_FUNC_MACRO(enif_make_list)\n#  define enif_make_list_cell ERL_NIF_API_FUNC_MACRO(enif_make_list_cell)\n#  define enif_make_string ERL_NIF_API_FUNC_MACRO(enif_make_string)\n#  define enif_make_ref ERL_NIF_API_FUNC_MACRO(enif_make_ref)\n\n#  define enif_mutex_create ERL_NIF_API_FUNC_MACRO(enif_mutex_create) \n#  define enif_mutex_destroy ERL_NIF_API_FUNC_MACRO(enif_mutex_destroy) \n#  define enif_mutex_trylock ERL_NIF_API_FUNC_MACRO(enif_mutex_trylock) \n#  define enif_mutex_lock ERL_NIF_API_FUNC_MACRO(enif_mutex_lock) \n#  define enif_mutex_unlock ERL_NIF_API_FUNC_MACRO(enif_mutex_unlock) \n#  define enif_cond_create ERL_NIF_API_FUNC_MACRO(enif_cond_create) \n#  define enif_cond_destroy ERL_NIF_API_FUNC_MACRO(enif_cond_destroy) \n#  define enif_cond_signal ERL_NIF_API_FUNC_MACRO(enif_cond_signal) \n#  define enif_cond_broadcast ERL_NIF_API_FUNC_MACRO(enif_cond_broadcast) \n#  define enif_cond_wait ERL_NIF_API_FUNC_MACRO(enif_cond_wait) \n#  define enif_rwlock_create ERL_NIF_API_FUNC_MACRO(enif_rwlock_create) \n#  define enif_rwlock_destroy ERL_NIF_API_FUNC_MACRO(enif_rwlock_destroy) \n#  define enif_rwlock_tryrlock ERL_NIF_API_FUNC_MACRO(enif_rwlock_tryrlock) \n#  define enif_rwlock_rlock ERL_NIF_API_FUNC_MACRO(enif_rwlock_rlock) \n#  define enif_rwlock_runlock ERL_NIF_API_FUNC_MACRO(enif_rwlock_runlock) \n#  define enif_rwlock_tryrwlock ERL_NIF_API_FUNC_MACRO(enif_rwlock_tryrwlock) \n#  define enif_rwlock_rwlock ERL_NIF_API_FUNC_MACRO(enif_rwlock_rwlock) \n#  define enif_rwlock_rwunlock ERL_NIF_API_FUNC_MACRO(enif_rwlock_rwunlock) \n#  define enif_tsd_key_create ERL_NIF_API_FUNC_MACRO(enif_tsd_key_create) \n#  define enif_tsd_key_destroy ERL_NIF_API_FUNC_MACRO(enif_tsd_key_destroy) \n#  define enif_tsd_set ERL_NIF_API_FUNC_MACRO(enif_tsd_set) \n#  define enif_tsd_get ERL_NIF_API_FUNC_MACRO(enif_tsd_get) \n#  define enif_thread_opts_create ERL_NIF_API_FUNC_MACRO(enif_thread_opts_create) \n#  define enif_thread_opts_destroy ERL_NIF_API_FUNC_MACRO(enif_thread_opts_destroy) \n#  define enif_thread_create ERL_NIF_API_FUNC_MACRO(enif_thread_create) \n#  define enif_thread_self ERL_NIF_API_FUNC_MACRO(enif_thread_self) \n#  define enif_equal_tids ERL_NIF_API_FUNC_MACRO(enif_equal_tids) \n#  define enif_thread_exit ERL_NIF_API_FUNC_MACRO(enif_thread_exit) \n#  define enif_thread_join ERL_NIF_API_FUNC_MACRO(enif_thread_join) \n\n#  define enif_realloc ERL_NIF_API_FUNC_MACRO(enif_realloc) \n#  define enif_system_info ERL_NIF_API_FUNC_MACRO(enif_system_info) \n#  define enif_fprintf ERL_NIF_API_FUNC_MACRO(enif_fprintf) \n#  define enif_inspect_iolist_as_binary ERL_NIF_API_FUNC_MACRO(enif_inspect_iolist_as_binary)\n#  define enif_make_sub_binary ERL_NIF_API_FUNC_MACRO(enif_make_sub_binary)\n#  define enif_get_string ERL_NIF_API_FUNC_MACRO(enif_get_string)\n#  define enif_get_atom ERL_NIF_API_FUNC_MACRO(enif_get_atom)\n#  define enif_is_fun ERL_NIF_API_FUNC_MACRO(enif_is_fun)\n#  define enif_is_pid ERL_NIF_API_FUNC_MACRO(enif_is_pid)\n#  define enif_is_port ERL_NIF_API_FUNC_MACRO(enif_is_port)\n#  define enif_get_uint ERL_NIF_API_FUNC_MACRO(enif_get_uint)\n#  define enif_get_long ERL_NIF_API_FUNC_MACRO(enif_get_long)\n#  define enif_make_uint ERL_NIF_API_FUNC_MACRO(enif_make_uint)\n#  define enif_make_long ERL_NIF_API_FUNC_MACRO(enif_make_long)\n#  define enif_make_tuple_from_array ERL_NIF_API_FUNC_MACRO(enif_make_tuple_from_array)\n#  define enif_make_list_from_array ERL_NIF_API_FUNC_MACRO(enif_make_list_from_array)\n#  define enif_is_empty_list ERL_NIF_API_FUNC_MACRO(enif_is_empty_list)\n#  define enif_open_resource_type ERL_NIF_API_FUNC_MACRO(enif_open_resource_type)\n#  define enif_alloc_resource ERL_NIF_API_FUNC_MACRO(enif_alloc_resource)\n#  define enif_release_resource ERL_NIF_API_FUNC_MACRO(enif_release_resource)\n#  define enif_make_resource ERL_NIF_API_FUNC_MACRO(enif_make_resource)\n#  define enif_get_resource ERL_NIF_API_FUNC_MACRO(enif_get_resource)\n#  define enif_sizeof_resource ERL_NIF_API_FUNC_MACRO(enif_sizeof_resource)\n#  define enif_make_new_binary ERL_NIF_API_FUNC_MACRO(enif_make_new_binary)\n#  define enif_is_list ERL_NIF_API_FUNC_MACRO(enif_is_list)\n#  define enif_is_tuple ERL_NIF_API_FUNC_MACRO(enif_is_tuple)\n#  define enif_get_atom_length ERL_NIF_API_FUNC_MACRO(enif_get_atom_length)\n#  define enif_get_list_length ERL_NIF_API_FUNC_MACRO(enif_get_list_length)\n#  define enif_make_atom_len ERL_NIF_API_FUNC_MACRO(enif_make_atom_len)\n#  define enif_make_existing_atom_len ERL_NIF_API_FUNC_MACRO(enif_make_existing_atom_len)\n#  define enif_make_string_len ERL_NIF_API_FUNC_MACRO(enif_make_string_len)\n#  define enif_alloc_env ERL_NIF_API_FUNC_MACRO(enif_alloc_env)\n#  define enif_free_env ERL_NIF_API_FUNC_MACRO(enif_free_env)\n#  define enif_clear_env ERL_NIF_API_FUNC_MACRO(enif_clear_env)\n#  define enif_send ERL_NIF_API_FUNC_MACRO(enif_send)\n#  define enif_make_copy ERL_NIF_API_FUNC_MACRO(enif_make_copy)\n#  define enif_self ERL_NIF_API_FUNC_MACRO(enif_self)\n#  define enif_get_local_pid ERL_NIF_API_FUNC_MACRO(enif_get_local_pid)\n#  define enif_keep_resource ERL_NIF_API_FUNC_MACRO(enif_keep_resource)\n#  define enif_make_resource_binary ERL_NIF_API_FUNC_MACRO(enif_make_resource_binary)\n#if  SIZEOF_LONG != 8\n#  define enif_get_int64 ERL_NIF_API_FUNC_MACRO(enif_get_int64)\n#  define enif_get_uint64 ERL_NIF_API_FUNC_MACRO(enif_get_uint64)\n#  define enif_make_int64 ERL_NIF_API_FUNC_MACRO(enif_make_int64)\n#  define enif_make_uint64 ERL_NIF_API_FUNC_MACRO(enif_make_uint64)\n#endif\n#  define enif_is_exception ERL_NIF_API_FUNC_MACRO(enif_is_exception)\n#  define enif_make_reverse_list ERL_NIF_API_FUNC_MACRO(enif_make_reverse_list)\n#  define enif_is_number ERL_NIF_API_FUNC_MACRO(enif_is_number)\n#  define enif_dlopen ERL_NIF_API_FUNC_MACRO(enif_dlopen)\n#  define enif_dlsym ERL_NIF_API_FUNC_MACRO(enif_dlsym)\n#  define enif_consume_timeslice ERL_NIF_API_FUNC_MACRO(enif_consume_timeslice)\n#  define enif_is_map ERL_NIF_API_FUNC_MACRO(enif_is_map)\n#  define enif_get_map_size ERL_NIF_API_FUNC_MACRO(enif_get_map_size)\n#  define enif_make_new_map ERL_NIF_API_FUNC_MACRO(enif_make_new_map)\n#  define enif_make_map_put ERL_NIF_API_FUNC_MACRO(enif_make_map_put)\n#  define enif_get_map_value ERL_NIF_API_FUNC_MACRO(enif_get_map_value)\n#  define enif_make_map_update ERL_NIF_API_FUNC_MACRO(enif_make_map_update)\n#  define enif_make_map_remove ERL_NIF_API_FUNC_MACRO(enif_make_map_remove)\n#  define enif_map_iterator_create ERL_NIF_API_FUNC_MACRO(enif_map_iterator_create)\n#  define enif_map_iterator_destroy ERL_NIF_API_FUNC_MACRO(enif_map_iterator_destroy)\n#  define enif_map_iterator_is_head ERL_NIF_API_FUNC_MACRO(enif_map_iterator_is_head)\n#  define enif_map_iterator_is_tail ERL_NIF_API_FUNC_MACRO(enif_map_iterator_is_tail)\n#  define enif_map_iterator_next ERL_NIF_API_FUNC_MACRO(enif_map_iterator_next)\n#  define enif_map_iterator_prev ERL_NIF_API_FUNC_MACRO(enif_map_iterator_prev)\n#  define enif_map_iterator_get_pair ERL_NIF_API_FUNC_MACRO(enif_map_iterator_get_pair)\n#  define enif_schedule_nif ERL_NIF_API_FUNC_MACRO(enif_schedule_nif)\n#  define enif_has_pending_exception ERL_NIF_API_FUNC_MACRO(enif_has_pending_exception)\n#  define enif_raise_exception ERL_NIF_API_FUNC_MACRO(enif_raise_exception)\n#  define enif_getenv ERL_NIF_API_FUNC_MACRO(enif_getenv)\n#  define enif_monotonic_time ERL_NIF_API_FUNC_MACRO(enif_monotonic_time)\n#  define enif_time_offset ERL_NIF_API_FUNC_MACRO(enif_time_offset)\n#  define enif_convert_time_unit ERL_NIF_API_FUNC_MACRO(enif_convert_time_unit)\n#  define enif_now_time ERL_NIF_API_FUNC_MACRO(enif_now_time)\n#  define enif_cpu_time ERL_NIF_API_FUNC_MACRO(enif_cpu_time)\n#  define enif_make_unique_integer ERL_NIF_API_FUNC_MACRO(enif_make_unique_integer)\n#  define enif_is_current_process_alive ERL_NIF_API_FUNC_MACRO(enif_is_current_process_alive)\n#  define enif_is_process_alive ERL_NIF_API_FUNC_MACRO(enif_is_process_alive)\n#  define enif_is_port_alive ERL_NIF_API_FUNC_MACRO(enif_is_port_alive)\n#  define enif_get_local_port ERL_NIF_API_FUNC_MACRO(enif_get_local_port)\n#  define enif_term_to_binary ERL_NIF_API_FUNC_MACRO(enif_term_to_binary)\n#  define enif_binary_to_term ERL_NIF_API_FUNC_MACRO(enif_binary_to_term)\n#  define enif_port_command ERL_NIF_API_FUNC_MACRO(enif_port_command)\n#  define enif_thread_type ERL_NIF_API_FUNC_MACRO(enif_thread_type)\n#  define enif_snprintf ERL_NIF_API_FUNC_MACRO(enif_snprintf)\n#  define enif_select ERL_NIF_API_FUNC_MACRO(enif_select)\n#  define enif_open_resource_type_x ERL_NIF_API_FUNC_MACRO(enif_open_resource_type_x)\n#  define enif_monitor_process ERL_NIF_API_FUNC_MACRO(enif_monitor_process)\n#  define enif_demonitor_process ERL_NIF_API_FUNC_MACRO(enif_demonitor_process)\n#  define enif_compare_monitors ERL_NIF_API_FUNC_MACRO(enif_compare_monitors)\n#  define enif_hash ERL_NIF_API_FUNC_MACRO(enif_hash)\n#  define enif_whereis_pid ERL_NIF_API_FUNC_MACRO(enif_whereis_pid)\n#  define enif_whereis_port ERL_NIF_API_FUNC_MACRO(enif_whereis_port)\n#  define enif_ioq_create ERL_NIF_API_FUNC_MACRO(enif_ioq_create)\n#  define enif_ioq_destroy ERL_NIF_API_FUNC_MACRO(enif_ioq_destroy)\n#  define enif_ioq_enq ERL_NIF_API_FUNC_MACRO(enif_ioq_enq)\n#  define enif_ioq_enq_binary ERL_NIF_API_FUNC_MACRO(enif_ioq_enq_binary)\n#  define enif_ioq_enqv ERL_NIF_API_FUNC_MACRO(enif_ioq_enqv)\n#  define enif_ioq_size ERL_NIF_API_FUNC_MACRO(enif_ioq_size)\n#  define enif_ioq_deq ERL_NIF_API_FUNC_MACRO(enif_ioq_deq)\n#  define enif_ioq_peek ERL_NIF_API_FUNC_MACRO(enif_ioq_peek)\n#  define enif_inspect_iovec ERL_NIF_API_FUNC_MACRO(enif_inspect_iovec)\n#  define enif_free_iovec ERL_NIF_API_FUNC_MACRO(enif_free_iovec)\n#  define enif_ioq_peek_head ERL_NIF_API_FUNC_MACRO(enif_ioq_peek_head)\n#  define enif_mutex_name ERL_NIF_API_FUNC_MACRO(enif_mutex_name)\n#  define enif_cond_name ERL_NIF_API_FUNC_MACRO(enif_cond_name)\n#  define enif_rwlock_name ERL_NIF_API_FUNC_MACRO(enif_rwlock_name)\n#  define enif_thread_name ERL_NIF_API_FUNC_MACRO(enif_thread_name)\n#  define enif_vfprintf ERL_NIF_API_FUNC_MACRO(enif_vfprintf)\n#  define enif_vsnprintf ERL_NIF_API_FUNC_MACRO(enif_vsnprintf)\n#  define enif_make_map_from_arrays ERL_NIF_API_FUNC_MACRO(enif_make_map_from_arrays)\n#  define enif_select_x ERL_NIF_API_FUNC_MACRO(enif_select_x)\n#  define enif_make_monitor_term ERL_NIF_API_FUNC_MACRO(enif_make_monitor_term)\n#  define enif_set_pid_undefined ERL_NIF_API_FUNC_MACRO(enif_set_pid_undefined)\n#  define enif_is_pid_undefined ERL_NIF_API_FUNC_MACRO(enif_is_pid_undefined)\n#  define enif_term_type ERL_NIF_API_FUNC_MACRO(enif_term_type)\n\n/*\n** ADD NEW ENTRIES HERE (before this comment)\n*/\n\n/*\n * Conditional EXPERIMENTAL stuff always last\n * Must be moved up and made unconditional to support binary backward\n * compatibility on Windows.\n */\n#endif  /* ERL_NIF_API_FUNC_MACRO */\n\n\n#if defined(__GNUC__) && !(defined(__WIN32__) || defined(_WIN32) || defined(_WIN32_))\n\n/* Inline functions for compile time type checking of arguments to\n   variadic functions.\n*/\n\n#  define ERL_NIF_INLINE __inline__\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple1(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1)\n{\n    return enif_make_tuple(env, 1, e1);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple2(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2)\n{\n    return enif_make_tuple(env, 2, e1, e2);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple3(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2,\n\t\t\t\t\t\t    ERL_NIF_TERM e3)\n{\n    return enif_make_tuple(env, 3, e1, e2, e3);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple4(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2,\n\t\t\t\t\t\t    ERL_NIF_TERM e3,\n\t\t\t\t\t\t    ERL_NIF_TERM e4)\n{\n    return enif_make_tuple(env, 4, e1, e2, e3, e4);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple5(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2,\n\t\t\t\t\t\t    ERL_NIF_TERM e3,\n\t\t\t\t\t\t    ERL_NIF_TERM e4,\n\t\t\t\t\t\t    ERL_NIF_TERM e5)\n{\n    return enif_make_tuple(env, 5, e1, e2, e3, e4, e5);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple6(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2,\n\t\t\t\t\t\t    ERL_NIF_TERM e3,\n\t\t\t\t\t\t    ERL_NIF_TERM e4,\n\t\t\t\t\t\t    ERL_NIF_TERM e5,\n\t\t\t\t\t\t    ERL_NIF_TERM e6)\n{\n    return enif_make_tuple(env, 6, e1, e2, e3, e4, e5, e6);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple7(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2,\n\t\t\t\t\t\t    ERL_NIF_TERM e3,\n\t\t\t\t\t\t    ERL_NIF_TERM e4,\n\t\t\t\t\t\t    ERL_NIF_TERM e5,\n\t\t\t\t\t\t    ERL_NIF_TERM e6,\n\t\t\t\t\t\t    ERL_NIF_TERM e7)\n{\n    return enif_make_tuple(env, 7, e1, e2, e3, e4, e5, e6, e7);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple8(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2,\n\t\t\t\t\t\t    ERL_NIF_TERM e3,\n\t\t\t\t\t\t    ERL_NIF_TERM e4,\n\t\t\t\t\t\t    ERL_NIF_TERM e5,\n\t\t\t\t\t\t    ERL_NIF_TERM e6,\n\t\t\t\t\t\t    ERL_NIF_TERM e7,\n\t\t\t\t\t\t    ERL_NIF_TERM e8)\n{\n    return enif_make_tuple(env, 8, e1, e2, e3, e4, e5, e6, e7, e8);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_tuple9(ErlNifEnv* env,\n\t\t\t\t\t\t    ERL_NIF_TERM e1,\n\t\t\t\t\t\t    ERL_NIF_TERM e2,\n\t\t\t\t\t\t    ERL_NIF_TERM e3,\n\t\t\t\t\t\t    ERL_NIF_TERM e4,\n\t\t\t\t\t\t    ERL_NIF_TERM e5,\n\t\t\t\t\t\t    ERL_NIF_TERM e6,\n\t\t\t\t\t\t    ERL_NIF_TERM e7,\n\t\t\t\t\t\t    ERL_NIF_TERM e8,\n\t\t\t\t\t\t    ERL_NIF_TERM e9)\n{\n    return enif_make_tuple(env, 9, e1, e2, e3, e4, e5, e6, e7, e8, e9);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list1(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1)\n{\n    return enif_make_list(env, 1, e1);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list2(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2)\n{\n    return enif_make_list(env, 2, e1, e2);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list3(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2,\n\t\t\t\t\t\t   ERL_NIF_TERM e3)\n{\n    return enif_make_list(env, 3, e1, e2, e3);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list4(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2,\n\t\t\t\t\t\t   ERL_NIF_TERM e3,\n\t\t\t\t\t\t   ERL_NIF_TERM e4)\n{\n    return enif_make_list(env, 4, e1, e2, e3, e4);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list5(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2,\n\t\t\t\t\t\t   ERL_NIF_TERM e3,\n\t\t\t\t\t\t   ERL_NIF_TERM e4,\n\t\t\t\t\t\t   ERL_NIF_TERM e5)\n{\n    return enif_make_list(env, 5, e1, e2, e3, e4, e5);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list6(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2,\n\t\t\t\t\t\t   ERL_NIF_TERM e3,\n\t\t\t\t\t\t   ERL_NIF_TERM e4,\n\t\t\t\t\t\t   ERL_NIF_TERM e5,\n\t\t\t\t\t\t   ERL_NIF_TERM e6)\n{\n    return enif_make_list(env, 6, e1, e2, e3, e4, e5, e6);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list7(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2,\n\t\t\t\t\t\t   ERL_NIF_TERM e3,\n\t\t\t\t\t\t   ERL_NIF_TERM e4,\n\t\t\t\t\t\t   ERL_NIF_TERM e5,\n\t\t\t\t\t\t   ERL_NIF_TERM e6,\n\t\t\t\t\t\t   ERL_NIF_TERM e7)\n{\n    return enif_make_list(env, 7, e1, e2, e3, e4, e5, e6, e7);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list8(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2,\n\t\t\t\t\t\t   ERL_NIF_TERM e3,\n\t\t\t\t\t\t   ERL_NIF_TERM e4,\n\t\t\t\t\t\t   ERL_NIF_TERM e5,\n\t\t\t\t\t\t   ERL_NIF_TERM e6,\n\t\t\t\t\t\t   ERL_NIF_TERM e7,\n\t\t\t\t\t\t   ERL_NIF_TERM e8)\n{\n    return enif_make_list(env, 8, e1, e2, e3, e4, e5, e6, e7, e8);\n}\n\nstatic ERL_NIF_INLINE ERL_NIF_TERM enif_make_list9(ErlNifEnv* env,\n\t\t\t\t\t\t   ERL_NIF_TERM e1,\n\t\t\t\t\t\t   ERL_NIF_TERM e2,\n\t\t\t\t\t\t   ERL_NIF_TERM e3,\n\t\t\t\t\t\t   ERL_NIF_TERM e4,\n\t\t\t\t\t\t   ERL_NIF_TERM e5,\n\t\t\t\t\t\t   ERL_NIF_TERM e6,\n\t\t\t\t\t\t   ERL_NIF_TERM e7,\n\t\t\t\t\t\t   ERL_NIF_TERM e8,\n\t\t\t\t\t\t   ERL_NIF_TERM e9)\n{\n    return enif_make_list(env, 9, e1, e2, e3, e4, e5, e6, e7, e8, e9);\n}\n\n#  undef ERL_NIF_INLINE\n\n#else /* fallback with macros */\n\n#ifndef enif_make_list1\n#  define enif_make_list1(ENV,E1) enif_make_list(ENV,1,E1)\n#  define enif_make_list2(ENV,E1,E2) enif_make_list(ENV,2,E1,E2)\n#  define enif_make_list3(ENV,E1,E2,E3) enif_make_list(ENV,3,E1,E2,E3)\n#  define enif_make_list4(ENV,E1,E2,E3,E4) enif_make_list(ENV,4,E1,E2,E3,E4)\n#  define enif_make_list5(ENV,E1,E2,E3,E4,E5) enif_make_list(ENV,5,E1,E2,E3,E4,E5)\n#  define enif_make_list6(ENV,E1,E2,E3,E4,E5,E6) enif_make_list(ENV,6,E1,E2,E3,E4,E5,E6)\n#  define enif_make_list7(ENV,E1,E2,E3,E4,E5,E6,E7) enif_make_list(ENV,7,E1,E2,E3,E4,E5,E6,E7)\n#  define enif_make_list8(ENV,E1,E2,E3,E4,E5,E6,E7,E8) enif_make_list(ENV,8,E1,E2,E3,E4,E5,E6,E7,E8)\n#  define enif_make_list9(ENV,E1,E2,E3,E4,E5,E6,E7,E8,E9) enif_make_list(ENV,9,E1,E2,E3,E4,E5,E6,E7,E8,E9)\n#  define enif_make_tuple1(ENV,E1) enif_make_tuple(ENV,1,E1)\n#  define enif_make_tuple2(ENV,E1,E2) enif_make_tuple(ENV,2,E1,E2)\n#  define enif_make_tuple3(ENV,E1,E2,E3) enif_make_tuple(ENV,3,E1,E2,E3)\n#  define enif_make_tuple4(ENV,E1,E2,E3,E4) enif_make_tuple(ENV,4,E1,E2,E3,E4)\n#  define enif_make_tuple5(ENV,E1,E2,E3,E4,E5) enif_make_tuple(ENV,5,E1,E2,E3,E4,E5)\n#  define enif_make_tuple6(ENV,E1,E2,E3,E4,E5,E6) enif_make_tuple(ENV,6,E1,E2,E3,E4,E5,E6)\n#  define enif_make_tuple7(ENV,E1,E2,E3,E4,E5,E6,E7) enif_make_tuple(ENV,7,E1,E2,E3,E4,E5,E6,E7)\n#  define enif_make_tuple8(ENV,E1,E2,E3,E4,E5,E6,E7,E8) enif_make_tuple(ENV,8,E1,E2,E3,E4,E5,E6,E7,E8)\n#  define enif_make_tuple9(ENV,E1,E2,E3,E4,E5,E6,E7,E8,E9) enif_make_tuple(ENV,9,E1,E2,E3,E4,E5,E6,E7,E8,E9)\n#endif\n\n#endif /* __GNUC__ && !WIN32 */\n\n#ifndef enif_make_pid\n\n#  define enif_make_pid(ENV, PID) ((void)(ENV),(const ERL_NIF_TERM)((PID)->pid))\n#  define enif_compare_pids(A, B) (enif_compare((A)->pid,(B)->pid))\n#  define enif_select_read(ENV, E, OBJ, PID, MSG, MSG_ENV) \\\n    enif_select_x(ENV, E, ERL_NIF_SELECT_READ | ERL_NIF_SELECT_CUSTOM_MSG, \\\n                  OBJ, PID, MSG, MSG_ENV)\n#  define enif_select_write(ENV, E, OBJ, PID, MSG, MSG_ENV) \\\n    enif_select_x(ENV, E, ERL_NIF_SELECT_WRITE | ERL_NIF_SELECT_CUSTOM_MSG, \\\n                  OBJ, PID, MSG, MSG_ENV)\n\n#if SIZEOF_LONG == 8\n#  define enif_get_int64 enif_get_long\n#  define enif_get_uint64 enif_get_ulong\n#  define enif_make_int64 enif_make_long\n#  define enif_make_uint64 enif_make_ulong\n#endif\n\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/aclocal.m4": "dnl\ndnl %CopyrightBegin%\ndnl\ndnl Copyright Ericsson AB 1998-2018. All Rights Reserved.\ndnl\ndnl Licensed under the Apache License, Version 2.0 (the \"License\");\ndnl you may not use this file except in compliance with the License.\ndnl You may obtain a copy of the License at\ndnl\ndnl     http://www.apache.org/licenses/LICENSE-2.0\ndnl\ndnl Unless required by applicable law or agreed to in writing, software\ndnl distributed under the License is distributed on an \"AS IS\" BASIS,\ndnl WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\ndnl See the License for the specific language governing permissions and\ndnl limitations under the License.\ndnl\ndnl %CopyrightEnd%\ndnl\n\ndnl\ndnl aclocal.m4\ndnl\ndnl Local macros used in configure.in. The Local Macros which\ndnl could/should be part of autoconf are prefixed LM_, macros specific\ndnl to the Erlang system are prefixed ERL_.\ndnl\n\nAC_DEFUN(LM_PRECIOUS_VARS,\n[\n\ndnl ERL_TOP\nAC_ARG_VAR(ERL_TOP, [Erlang/OTP top source directory])\n\ndnl Tools\nAC_ARG_VAR(CC, [C compiler])\nAC_ARG_VAR(CFLAGS, [C compiler flags])\nAC_ARG_VAR(STATIC_CFLAGS, [C compiler static flags])\nAC_ARG_VAR(CFLAG_RUNTIME_LIBRARY_PATH, [runtime library path linker flag passed via C compiler])\nAC_ARG_VAR(CPP, [C/C++ preprocessor])\nAC_ARG_VAR(CPPFLAGS, [C/C++ preprocessor flags])\nAC_ARG_VAR(CXX, [C++ compiler])\nAC_ARG_VAR(CXXFLAGS, [C++ compiler flags])\nAC_ARG_VAR(LD, [linker (is often overridden by configure)])\nAC_ARG_VAR(LDFLAGS, [linker flags (can be risky to set since LD may be overriden by configure)])\nAC_ARG_VAR(LIBS, [libraries])\nAC_ARG_VAR(DED_LD, [linker for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(DED_LDFLAGS, [linker flags for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(DED_LD_FLAG_RUNTIME_LIBRARY_PATH, [runtime library path linker flag for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(LFS_CFLAGS, [large file support C compiler flags (set all LFS_* variables or none)])\nAC_ARG_VAR(LFS_LDFLAGS, [large file support linker flags (set all LFS_* variables or none)])\nAC_ARG_VAR(LFS_LIBS, [large file support libraries (set all LFS_* variables or none)])\nAC_ARG_VAR(RANLIB, [ranlib])\nAC_ARG_VAR(AR, [ar])\nAC_ARG_VAR(GETCONF, [getconf])\n\ndnl Cross system root\nAC_ARG_VAR(erl_xcomp_sysroot, [Absolute cross system root path (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_isysroot, [Absolute cross system root include path (only used when cross compiling)])\n\ndnl Cross compilation variables\nAC_ARG_VAR(erl_xcomp_bigendian, [big endian system: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_double_middle_endian, [double-middle-endian system: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_nptl, [have Native POSIX Thread Library: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_usable_sigusrx, [SIGUSR1 and SIGUSR2 can be used: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_usable_sigaltstack, [have working sigaltstack(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_poll, [have working poll(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_kqueue, [have working kqueue(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_putenv_copy, [putenv() stores key-value copy: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_reliable_fpe, [have reliable floating point exceptions: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_getaddrinfo, [have working getaddrinfo() for both IPv4 and IPv6: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_gethrvtime_procfs_ioctl, [have working gethrvtime() which can be used with procfs ioctl(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_clock_gettime_cpu_time, [clock_gettime() can be used for retrieving process CPU time: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_after_morecore_hook, [__after_morecore_hook can track malloc()s core memory usage: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_dlsym_brk_wrappers, [dlsym(RTLD_NEXT, _) brk wrappers can track malloc()s core memory usage: yes|no (only used when cross compiling)])\n\n])\n\nAC_DEFUN(ERL_XCOMP_SYSROOT_INIT,\n[\nerl_xcomp_without_sysroot=no\nif test \"$cross_compiling\" = \"yes\"; then\n    test \"$erl_xcomp_sysroot\" != \"\" || erl_xcomp_without_sysroot=yes\n    test \"$erl_xcomp_isysroot\" != \"\" || erl_xcomp_isysroot=\"$erl_xcomp_sysroot\"\nelse\n    erl_xcomp_sysroot=\n    erl_xcomp_isysroot=\nfi\n])\n\nAC_DEFUN(LM_CHECK_GETCONF,\n[\nif test \"$cross_compiling\" != \"yes\"; then\n    AC_CHECK_PROG([GETCONF], [getconf], [getconf], [false])\nelse\n    dnl First check if we got a `<HOST>-getconf' in $PATH\n    host_getconf=\"$host_alias-getconf\"\n    AC_CHECK_PROG([GETCONF], [$host_getconf], [$host_getconf], [false])\n    if test \"$GETCONF\" = \"false\" && test \"$erl_xcomp_sysroot\" != \"\"; then\n\tdnl We should perhaps give up if we have'nt found it by now, but at\n\tdnl least in one Tilera MDE `getconf' under sysroot is a bourne\n\tdnl shell script which we can use. We try to find `<HOST>-getconf'\n    \tdnl or `getconf' under sysconf, but only under sysconf since\n\tdnl `getconf' in $PATH is almost guaranteed to be for the build\n\tdnl machine.\n\tGETCONF=\n\tprfx=\"$erl_xcomp_sysroot\"\n        AC_PATH_TOOL([GETCONF], [getconf], [false],\n\t             [\"$prfx/usr/bin:$prfx/bin:$prfx/usr/local/bin\"])\n    fi\nfi\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_WINDOWS_ENVIRONMENT\ndnl\ndnl\ndnl Tries to determine thw windows build environment, i.e. \ndnl MIXED_CYGWIN_VC or MIXED_MSYS_VC \ndnl\n\nAC_DEFUN(LM_WINDOWS_ENVIRONMENT,\n[\n\nif test \"X$windows_environment_\" != \"Xchecked\"; then\nwindows_environment_=checked\nMIXED_CYGWIN=no\nMIXED_MSYS=no\n\nAC_MSG_CHECKING(for mixed cygwin or msys and native VC++ environment)\nif test \"X$host\" = \"Xwin32\" -a \"x$GCC\" != \"xyes\"; then\n\tif test -x /usr/bin/msys-?.0.dll; then\n\t        CFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_MSYS=yes\n\t\tAC_MSG_RESULT([MSYS and VC])\n\t\tMIXED_MSYS_VC=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_MSYS_VC\"\n\telif test -x /usr/bin/cygpath; then\n\t\tCFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_CYGWIN=yes\n\t\tAC_MSG_RESULT([Cygwin and VC])\n\t\tMIXED_CYGWIN_VC=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_CYGWIN_VC\"\n\telse\t\t    \n\t\tAC_MSG_RESULT([undeterminable])\n\t\tAC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)\n\tfi\nelse\n\tAC_MSG_RESULT([no])\n\tMIXED_CYGWIN_VC=no\n\tMIXED_MSYS_VC=no\nfi\nAC_SUBST(MIXED_CYGWIN_VC)\nAC_SUBST(MIXED_MSYS_VC)\n\nMIXED_VC=no\nif test \"x$MIXED_MSYS_VC\" = \"xyes\" -o  \"x$MIXED_CYGWIN_VC\" = \"xyes\" ; then\n   MIXED_VC=yes\nfi\n\nAC_SUBST(MIXED_VC)\n\nif test \"x$MIXED_MSYS\" != \"xyes\"; then\n   AC_MSG_CHECKING(for mixed cygwin and native MinGW environment)\n   if test \"X$host\" = \"Xwin32\" -a \"x$GCC\" = x\"yes\"; then\n\tif test -x /usr/bin/cygpath; then\n\t\tCFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_CYGWIN=yes\n\t\tAC_MSG_RESULT([yes])\n\t\tMIXED_CYGWIN_MINGW=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_CYGWIN_MINGW\"\n\telse\n\t\tAC_MSG_RESULT([undeterminable])\n\t\tAC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)\n\tfi\n    else\n\tAC_MSG_RESULT([no])\n\tMIXED_CYGWIN_MINGW=no\n    fi\nelse\n\tMIXED_CYGWIN_MINGW=no\nfi\t\nAC_SUBST(MIXED_CYGWIN_MINGW)\n\nAC_MSG_CHECKING(if we mix cygwin with any native compiler)\nif test \"X$MIXED_CYGWIN\" = \"Xyes\"; then\n\tAC_MSG_RESULT([yes])\t\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nAC_SUBST(MIXED_CYGWIN)\n\t\nAC_MSG_CHECKING(if we mix msys with another native compiler)\nif test \"X$MIXED_MSYS\" = \"Xyes\" ; then\n\tAC_MSG_RESULT([yes])\t\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nAC_SUBST(MIXED_MSYS)\n\nfi\n])\t\t\n\t\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_FIND_EMU_CC\ndnl\ndnl\ndnl Tries fairly hard to find a C compiler that can handle jump tables.\ndnl Defines the @EMU_CC@ variable for the makefiles and \ndnl inserts NO_JUMP_TABLE in the header if one cannot be found...\ndnl\n\nAC_DEFUN(LM_FIND_EMU_CC,\n\t[AC_CACHE_CHECK(for a compiler that handles jumptables,\n\t\t\tac_cv_prog_emu_cc,\n\t\t\t[\nAC_TRY_COMPILE([],[\n#if defined(__clang_major__) && __clang_major__ >= 3\n    /* clang 3.x or later is fine */\n#elif defined(__llvm__)\n#error \"this version of llvm is unable to correctly compile beam_emu.c\"\n#endif\n    __label__ lbl1;\n    __label__ lbl2;\n    int x = magic();\n    static void *jtab[2];\n\n    jtab[0] = &&lbl1;\n    jtab[1] = &&lbl2;\n    goto *jtab[x];\nlbl1:\n    return 1;\nlbl2:\n    return 2;\n],ac_cv_prog_emu_cc=\"$CC\",ac_cv_prog_emu_cc=no)\n\nif test \"$ac_cv_prog_emu_cc\" = no; then\n\tfor ac_progname in emu_cc.sh gcc-4.2 gcc; do\n  \t\tIFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\":\"\n  \t\tac_dummy=\"$PATH\"\n  \t\tfor ac_dir in $ac_dummy; do\n    \t\t\ttest -z \"$ac_dir\" && ac_dir=.\n    \t\t\tif test -f \"$ac_dir/$ac_progname\"; then\n      \t\t\t\tac_cv_prog_emu_cc=\"$ac_dir/$ac_progname\"\n      \t\t\t\tbreak\n    \t\t\tfi\n  \t\tdone\n  \t\tIFS=\"$ac_save_ifs\"\n\t\tif test \"$ac_cv_prog_emu_cc\" != no; then\n\t\t\tbreak\n\t\tfi\n\tdone\nfi\n\nif test \"$ac_cv_prog_emu_cc\" != no; then\n\tsave_CC=\"$CC\"\n\tsave_CFLAGS=$CFLAGS\n\tsave_CPPFLAGS=$CPPFLAGS\n\tCC=\"$ac_cv_prog_emu_cc\"\n\tCFLAGS=\"\"\n\tCPPFLAGS=\"\"\n\tAC_TRY_COMPILE([],[\n#if defined(__clang_major__) && __clang_major__ >= 3\n    /* clang 3.x or later is fine */\n#elif defined(__llvm__)\n#error \"this version of llvm is unable to correctly compile beam_emu.c\"\n#endif\n    \t__label__ lbl1;\n    \t__label__ lbl2;\n    \tint x = magic();\n    \tstatic void *jtab[2];\n\n    \tjtab[0] = &&lbl1;\n    \tjtab[1] = &&lbl2;\n    \tgoto *jtab[x];\n\tlbl1:\n    \treturn 1;\n\tlbl2:\n    \treturn 2;\n\t],ac_cv_prog_emu_cc=\"$CC\",ac_cv_prog_emu_cc=no)\n\tCC=$save_CC\n\tCFLAGS=$save_CFLAGS\n\tCPPFLAGS=$save_CPPFLAGS\nfi\n])\nif test \"$ac_cv_prog_emu_cc\" = no; then\n\tAC_DEFINE(NO_JUMP_TABLE,[],[Defined if no found C compiler can handle jump tables])\n\tEMU_CC=\"$CC\"\nelse\n\tEMU_CC=\"$ac_cv_prog_emu_cc\"\nfi\nAC_SUBST(EMU_CC)\n])\t\t\n\t\t\t\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_PROG_INSTALL_DIR\ndnl\ndnl This macro may be used by any OTP application.\ndnl\ndnl Figure out how to create directories with parents.\ndnl (In my opinion INSTALL_DIR is a bad name, MKSUBDIRS or something is better)\ndnl\ndnl We prefer 'install -d', but use 'mkdir -p' if it exists.\ndnl If none of these methods works, we give up.\ndnl\n\n\nAC_DEFUN(LM_PROG_INSTALL_DIR,\n[AC_CACHE_CHECK(how to create a directory including parents,\nac_cv_prog_mkdir_p,\n[\ntemp_name_base=config.$$\ntemp_name=$temp_name_base/x/y/z\n$INSTALL -d $temp_name >/dev/null 2>&1\nac_cv_prog_mkdir_p=none\nif test -d $temp_name; then\n        ac_cv_prog_mkdir_p=\"$INSTALL -d\"\nelse\n        mkdir -p $temp_name >/dev/null 2>&1\n        if test -d $temp_name; then\n                ac_cv_prog_mkdir_p=\"mkdir -p\"\n        fi\nfi\nrm -fr $temp_name_base           \n])\n\ncase \"${ac_cv_prog_mkdir_p}\" in\n  none) AC_MSG_ERROR(don't know how create directories with parents) ;;\n  *)    INSTALL_DIR=\"$ac_cv_prog_mkdir_p\" AC_SUBST(INSTALL_DIR)     ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_PROG_PERL5\ndnl\ndnl Try to find perl version 5. If found set PERL to the absolute path\ndnl of the program, if not found set PERL to false.\ndnl\ndnl On some systems /usr/bin/perl is perl 4 and e.g.\ndnl /usr/local/bin/perl is perl 5. We try to handle this case by\ndnl putting a couple of \ndnl Tries to handle the case that there are two programs called perl\ndnl in the path and one of them is perl 5 and the other isn't. \ndnl\nAC_DEFUN(LM_PROG_PERL5,\n[AC_PATH_PROGS(PERL, perl5 perl, false,\n   /usr/local/bin:/opt/local/bin:/usr/local/gnu/bin:${PATH})\nchangequote(, )dnl\ndnl[ That bracket is needed to balance the right bracket below\nif test \"$PERL\" = \"false\" || $PERL -e 'exit ($] >= 5)'; then\nchangequote([, ])dnl\n  ac_cv_path_PERL=false\n  PERL=false\ndnl  AC_MSG_WARN(perl version 5 not found)\nfi\n])dnl\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_SO_BSDCOMPAT\ndnl\ndnl Check if the system has the SO_BSDCOMPAT flag on sockets (linux) \ndnl\nAC_DEFUN(LM_DECL_SO_BSDCOMPAT,\n[AC_CACHE_CHECK([for SO_BSDCOMPAT declaration], ac_cv_decl_so_bsdcompat,\nAC_TRY_COMPILE([#include <sys/socket.h>], [int i = SO_BSDCOMPAT;],\n               ac_cv_decl_so_bsdcompat=yes,\n               ac_cv_decl_so_bsdcompat=no))\n\ncase \"${ac_cv_decl_so_bsdcompat}\" in\n  \"yes\" ) AC_DEFINE(HAVE_SO_BSDCOMPAT,[],\n\t\t[Define if you have SO_BSDCOMPAT flag on sockets]) ;;\n  * ) ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_INADDR_LOOPBACK\ndnl\ndnl Try to find declaration of INADDR_LOOPBACK, if nowhere provide a default\ndnl\n\nAC_DEFUN(LM_DECL_INADDR_LOOPBACK,\n[AC_CACHE_CHECK([for INADDR_LOOPBACK in netinet/in.h],\n ac_cv_decl_inaddr_loopback,\n[AC_TRY_COMPILE([#include <sys/types.h>\n#include <netinet/in.h>], [int i = INADDR_LOOPBACK;],\nac_cv_decl_inaddr_loopback=yes, ac_cv_decl_inaddr_loopback=no)\n])\n\nif test ${ac_cv_decl_inaddr_loopback} = no; then\n  AC_CACHE_CHECK([for INADDR_LOOPBACK in rpc/types.h],\n                   ac_cv_decl_inaddr_loopback_rpc,\n                   AC_TRY_COMPILE([#include <rpc/types.h>],\n                                   [int i = INADDR_LOOPBACK;],\n                                   ac_cv_decl_inaddr_loopback_rpc=yes,\n                                   ac_cv_decl_inaddr_loopback_rpc=no))\n\n   case \"${ac_cv_decl_inaddr_loopback_rpc}\" in\n     \"yes\" )\n        AC_DEFINE(DEF_INADDR_LOOPBACK_IN_RPC_TYPES_H,[],\n\t\t[Define if you need to include rpc/types.h to get INADDR_LOOPBACK defined]) ;;\n      * )\n  \tAC_CACHE_CHECK([for INADDR_LOOPBACK in winsock2.h],\n                   ac_cv_decl_inaddr_loopback_winsock2,\n                   AC_TRY_COMPILE([#define WIN32_LEAN_AND_MEAN\n\t\t\t\t   #include <winsock2.h>],\n                                   [int i = INADDR_LOOPBACK;],\n                                   ac_cv_decl_inaddr_loopback_winsock2=yes,\n                                   ac_cv_decl_inaddr_loopback_winsock2=no))\n\tcase \"${ac_cv_decl_inaddr_loopback_winsock2}\" in\n     \t\t\"yes\" )\n\t\t\tAC_DEFINE(DEF_INADDR_LOOPBACK_IN_WINSOCK2_H,[],\n\t\t\t\t[Define if you need to include winsock2.h to get INADDR_LOOPBACK defined]) ;;\n\t\t* )\n\t\t\t# couldn't find it anywhere\n        \t\tAC_DEFINE(HAVE_NO_INADDR_LOOPBACK,[],\n\t\t\t\t[Define if you don't have a definition of INADDR_LOOPBACK]) ;;\n\tesac;;\n   esac\nfi\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_STRUCT_SOCKADDR_SA_LEN\ndnl\ndnl Check if the sockaddr structure has the field sa_len\ndnl\n\nAC_DEFUN(LM_STRUCT_SOCKADDR_SA_LEN,\n[AC_CACHE_CHECK([whether struct sockaddr has sa_len field],\n                ac_cv_struct_sockaddr_sa_len,\nAC_TRY_COMPILE([#include <sys/types.h>\n#include <sys/socket.h>], [struct sockaddr s; s.sa_len = 10;],\n  ac_cv_struct_sockaddr_sa_len=yes, ac_cv_struct_sockaddr_sa_len=no))\n\ndnl FIXME convbreak\ncase ${ac_cv_struct_sockaddr_sa_len} in\n  \"no\" ) AC_DEFINE(NO_SA_LEN,[1],[Define if you dont have salen]) ;;\n  *) ;;\nesac\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_STRUCT_EXCEPTION\ndnl\ndnl Check to see whether the system supports the matherr function\ndnl and its associated type \"struct exception\".\ndnl\n\nAC_DEFUN(LM_STRUCT_EXCEPTION,\n[AC_CACHE_CHECK([for struct exception (and matherr function)],\n ac_cv_struct_exception,\nAC_TRY_COMPILE([#include <math.h>],\n  [struct exception x; x.type = DOMAIN; x.type = SING;],\n  ac_cv_struct_exception=yes, ac_cv_struct_exception=no))\n\ncase \"${ac_cv_struct_exception}\" in\n  \"yes\" ) AC_DEFINE(USE_MATHERR,[1],[Define if you have matherr() function and struct exception type]) ;;\n  *  ) ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_SYS_IPV6\ndnl\ndnl Check for ipv6 support and what the in6_addr structure is called.\ndnl (early linux used in_addr6 insted of in6_addr)\ndnl\n\nAC_DEFUN(LM_SYS_IPV6,\n[AC_MSG_CHECKING(for IP version 6 support)\nAC_CACHE_VAL(ac_cv_sys_ipv6_support,\n[ok_so_far=yes\n AC_TRY_COMPILE([#include <sys/types.h>\n#ifdef __WIN32__\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <netinet/in.h>\n#endif],\n   [struct in6_addr a6; struct sockaddr_in6 s6;], ok_so_far=yes, ok_so_far=no)\n\nif test $ok_so_far = yes; then\n  ac_cv_sys_ipv6_support=yes\nelse\n  AC_TRY_COMPILE([#include <sys/types.h>\n#ifdef __WIN32__\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <netinet/in.h>\n#endif],\n    [struct in_addr6 a6; struct sockaddr_in6 s6;],\n    ac_cv_sys_ipv6_support=in_addr6, ac_cv_sys_ipv6_support=no)\nfi\n])dnl\n\ndnl\ndnl Have to use old style AC_DEFINE due to BC with old autoconf.\ndnl\n\ncase ${ac_cv_sys_ipv6_support} in\n  yes)\n    AC_MSG_RESULT(yes)\n    AC_DEFINE(HAVE_IN6,[1],[Define if ipv6 is present])\n    ;;\n  in_addr6)\n    AC_MSG_RESULT([yes (but I am redefining in_addr6 to in6_addr)])\n    AC_DEFINE(HAVE_IN6,[1],[Define if ipv6 is present])\n    AC_DEFINE(HAVE_IN_ADDR6_STRUCT,[],[Early linux used in_addr6 instead of in6_addr, define if you have this])\n    ;;\n  *)\n    AC_MSG_RESULT(no)\n    ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_SYS_MULTICAST\ndnl\ndnl Check for multicast support. Only checks for multicast options in\ndnl setsockopt(), no check is performed that multicasting actually works.\ndnl If options are found defines HAVE_MULTICAST_SUPPORT\ndnl\n\nAC_DEFUN(LM_SYS_MULTICAST,\n[AC_CACHE_CHECK([for multicast support], ac_cv_sys_multicast_support,\n[AC_EGREP_CPP(^yes$,\n[#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#if defined(IP_MULTICAST_TTL) && defined(IP_MULTICAST_LOOP) && defined(IP_MULTICAST_IF) && defined(IP_ADD_MEMBERSHIP) && defined(IP_DROP_MEMBERSHIP)\nyes\n#endif\n], ac_cv_sys_multicast_support=yes, ac_cv_sys_multicast_support=no)])\nif test $ac_cv_sys_multicast_support = yes; then\n  AC_DEFINE(HAVE_MULTICAST_SUPPORT,[1],\n\t[Define if setsockopt() accepts multicast options])\nfi\n])dnl\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_SYS_ERRLIST\ndnl\ndnl Define SYS_ERRLIST_DECLARED if the variable sys_errlist is declared\ndnl in a system header file, stdio.h or errno.h.\ndnl\n\nAC_DEFUN(LM_DECL_SYS_ERRLIST,\n[AC_CACHE_CHECK([for sys_errlist declaration in stdio.h or errno.h],\n  ac_cv_decl_sys_errlist,\n[AC_TRY_COMPILE([#include <stdio.h>\n#include <errno.h>], [char *msg = *(sys_errlist + 1);],\n  ac_cv_decl_sys_errlist=yes, ac_cv_decl_sys_errlist=no)])\nif test $ac_cv_decl_sys_errlist = yes; then\n  AC_DEFINE(SYS_ERRLIST_DECLARED,[],\n\t[define if the variable sys_errlist is declared in a system header file])\nfi\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_CHECK_FUNC_DECL( funname, declaration [, extra includes \ndnl                     [, action-if-found [, action-if-not-found]]] )\ndnl\ndnl Checks if the declaration \"declaration\" of \"funname\" conflicts\ndnl with the header files idea of how the function should be\ndnl declared. It is useful on systems which lack prototypes and you\ndnl need to provide your own (e.g. when you want to take the address\ndnl of a function). The 4'th argument is expanded if conflicting, \ndnl the 5'th argument otherwise\ndnl\ndnl\n\nAC_DEFUN(LM_CHECK_FUNC_DECL,\n[AC_MSG_CHECKING([for conflicting declaration of $1])\nAC_CACHE_VAL(ac_cv_func_decl_$1,\n[AC_TRY_COMPILE([#include <stdio.h>\n$3],[$2\nchar *c = (char *)$1;\n], eval \"ac_cv_func_decl_$1=no\", eval \"ac_cv_func_decl_$1=yes\")])\nif eval \"test \\\"`echo '$ac_cv_func_decl_'$1`\\\" = yes\"; then\n  AC_MSG_RESULT(yes)\n  ifelse([$4], , :, [$4])\nelse\n  AC_MSG_RESULT(no)\nifelse([$5], , , [$5\n])dnl\nfi\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl AC_DOUBLE_MIDDLE_ENDIAN\ndnl\ndnl Checks whether doubles are represented in \"middle-endian\" format.\ndnl Sets ac_cv_double_middle_endian={no,yes,unknown} accordingly,\ndnl as well as DOUBLE_MIDDLE_ENDIAN.\ndnl\ndnl\n\nAC_DEFUN([AC_C_DOUBLE_MIDDLE_ENDIAN],\n[AC_CACHE_CHECK(whether double word ordering is middle-endian, ac_cv_c_double_middle_endian,\n[# It does not; compile a test program.\nAC_RUN_IFELSE(\n[AC_LANG_SOURCE([[#include <stdlib.h>\n\nint\nmain(void)\n{\n  int i = 0;\n  int zero = 0;\n  int bigendian;\n  int zero_index = 0;\n\n  union\n  {\n    long int l;\n    char c[sizeof (long int)];\n  } u;\n\n  /* we'll use the one with 32-bit words */\n  union\n  {\n    double d;\n    unsigned int c[2];\n  } vint;\n\n  union\n  {\n    double d;\n    unsigned long c[2];\n  } vlong;\n\n  union\n  {\n    double d;\n    unsigned short c[2];\n  } vshort;\n\n\n  /* Are we little or big endian?  From Harbison&Steele.  */\n  u.l = 1;\n  bigendian = (u.c[sizeof (long int) - 1] == 1);\n\n  zero_index = bigendian ? 1 : 0;\n\n  vint.d = 1.0;\n  vlong.d = 1.0;\n  vshort.d = 1.0;\n\n  if (sizeof(unsigned int) == 4)\n    {\n      if (vint.c[zero_index] != 0)\n\tzero = 1;\n    }\n  else if (sizeof(unsigned long) == 4)\n    {\n      if (vlong.c[zero_index] != 0)\n\tzero = 1;\n    }\n  else if (sizeof(unsigned short) == 4)\n    {\n      if (vshort.c[zero_index] != 0)\n\tzero = 1;\n    }\n\n  exit (zero);\n}\n]])],\n\t      [ac_cv_c_double_middle_endian=no],\n\t      [ac_cv_c_double_middle_endian=yes],\n\t      [ac_cv_c_double_middle=unknown])])\ncase $ac_cv_c_double_middle_endian in\n  yes)\n    m4_default([$1],\n      [AC_DEFINE([DOUBLE_MIDDLE_ENDIAN], 1,\n\t[Define to 1 if your processor stores the words in a double in\n\t middle-endian format (like some ARMs).])]) ;;\n  no)\n    $2 ;;\n  *)\n    m4_default([$3],\n      [AC_MSG_WARN([unknown double endianness\npresetting ac_cv_c_double_middle_endian=no (or yes) will help])]) ;;\nesac\n])# AC_C_DOUBLE_MIDDLE_ENDIAN\n\n\nAC_DEFUN(ERL_MONOTONIC_CLOCK,\n[\n  if test \"$3\" = \"yes\"; then\n     default_resolution_clock_gettime_monotonic=\"CLOCK_HIGHRES CLOCK_BOOTTIME CLOCK_MONOTONIC\"\n     low_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_COARSE CLOCK_MONOTONIC_FAST\"\n     high_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_PRECISE\"\n  else\n     default_resolution_clock_gettime_monotonic=\"CLOCK_HIGHRES CLOCK_UPTIME CLOCK_MONOTONIC\"\n     low_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_COARSE CLOCK_UPTIME_FAST\"\n     high_resolution_clock_gettime_monotonic=\"CLOCK_UPTIME_PRECISE\"\n  fi\n\n  case \"$1\" in\n    high_resolution)\n\tcheck_msg=\"high resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$high_resolution_clock_gettime_monotonic\"\n\t;;\n    low_resolution)\n\tcheck_msg=\"low resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$low_resolution_clock_gettime_monotonic\"\n\t;;\n    custom_resolution)\n\tcheck_msg=\"custom resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$2\"\n\t;;\n    *)\n\tcheck_msg=\"custom \"\n\tprefer_resolution_clock_gettime_monotonic=\"$2\"\n\t;;\n  esac\n\n  clock_gettime_lib=\"\"\n  AC_CHECK_LIB(rt, clock_gettime, [clock_gettime_lib=\"-lrt\"])\n\n  save_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $clock_gettime_lib\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     trust_test=\"#error May not be there due to weak linking\"\n  else\n     trust_test=\"\"\n  fi\n\n  AC_CACHE_CHECK([for clock_gettime(CLOCK_MONOTONIC_RAW, _)], erl_cv_clock_gettime_monotonic_raw,\n  [\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime(CLOCK_MONOTONIC_RAW, &ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_monotonic_raw=yes,\n\t\t      erl_cv_clock_gettime_monotonic_raw=no)\n  ])\n\n  AC_CACHE_CHECK([for clock_gettime() with ${check_msg}monotonic clock type], erl_cv_clock_gettime_monotonic_$1,\n  [\n     for clock_type in $prefer_resolution_clock_gettime_monotonic $default_resolution_clock_gettime_monotonic $high_resolution_clock_gettime_monotonic $low_resolution_clock_gettime_monotonic; do\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime($clock_type,&ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_monotonic_$1=$clock_type,\n\t\t      erl_cv_clock_gettime_monotonic_$1=no)\n       test $erl_cv_clock_gettime_monotonic_$1 = no || break\n     done\n  ])\n\n  LIBS=\"$save_LIBS\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     check_for_clock_getres=\n  else\n     check_for_clock_getres=clock_getres\n  fi\n\n  AC_CHECK_FUNCS([$check_for_clock_getres clock_get_attributes gethrtime])\n  \n  AC_CACHE_CHECK([for mach clock_get_time() with monotonic clock type], erl_cv_mach_clock_get_time_monotonic,\n  [\n     AC_TRY_COMPILE([\n#include <mach/clock.h>\n#include <mach/mach.h>\n\t\t\t],\n\t \t\t[\n    kern_return_t res;\n    clock_serv_t clk_srv;\n    mach_timespec_t time_spec;\n\n    host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &clk_srv);\n    res = clock_get_time(clk_srv, &time_spec);\n    mach_port_deallocate(mach_task_self(), clk_srv);\n    \t\t\t],\n    \t\t\terl_cv_mach_clock_get_time_monotonic=yes,\n\t\t\terl_cv_mach_clock_get_time_monotonic=no)\n  ])\n  \n  erl_corrected_monotonic_clock=no\n  case $erl_cv_clock_gettime_monotonic_$1-$ac_cv_func_gethrtime-$erl_cv_mach_clock_get_time_monotonic-$host_os in\n    *-*-*-win32)\n      erl_monotonic_clock_func=WindowsAPI\n      ;;\n    CLOCK_*-*-*-linux*)\n      case $erl_cv_clock_gettime_monotonic_$1-$erl_cv_clock_gettime_monotonic_raw in\n        CLOCK_BOOTTIME-yes|CLOCK_MONOTONIC-yes)\n\t  erl_corrected_monotonic_clock=yes\n\t  ;;\n\t*)\n\t  # We don't trust CLOCK_MONOTONIC to be NTP\n\t  # adjusted on linux systems that do not have\n\t  # CLOCK_MONOTONIC_RAW (although it seems to\n\t  # be...)\n\t  ;;\n      esac\n      erl_monotonic_clock_func=clock_gettime\n      ;;\n    no-no-no-linux*)\n      erl_monotonic_clock_func=times\n      ;;\n    CLOCK_*-*-*-*)\n      erl_monotonic_clock_func=clock_gettime\n      ;;\n    no-yes-*-*)\n      erl_monotonic_clock_func=gethrtime\n      ;;\n    no-no-yes-*)\n      erl_monotonic_clock_func=mach_clock_get_time\n      ;;\n    no-no-no-*)\n      erl_monotonic_clock_func=none\n      ;;\n  esac\n\n  erl_monotonic_clock_low_resolution=no\n  erl_monotonic_clock_lib=\n  erl_monotonic_clock_id=\n  case $erl_monotonic_clock_func in\n    clock_gettime)\n      erl_monotonic_clock_id=$erl_cv_clock_gettime_monotonic_$1\n      for low_res_id in $low_resolution_clock_gettime_monotonic; do\n      \t  if test $erl_monotonic_clock_id = $low_res_id; then\n\t    erl_monotonic_clock_low_resolution=yes\n\t    break\n\t  fi\n      done\n      erl_monotonic_clock_lib=$clock_gettime_lib\n      ;;\n    mach_clock_get_time)\n      erl_monotonic_clock_id=SYSTEM_CLOCK\n      ;;\n    times)\n      erl_monotonic_clock_low_resolution=yes\n      ;;\n    *)\n      ;;\n  esac\n \n])\n\nAC_DEFUN(ERL_WALL_CLOCK,\n[\n  default_resolution_clock_gettime_wall=\"CLOCK_REALTIME\"\n  low_resolution_clock_gettime_wall=\"CLOCK_REALTIME_COARSE CLOCK_REALTIME_FAST\"\n  high_resolution_clock_gettime_wall=\"CLOCK_REALTIME_PRECISE\"\n\n  case \"$1\" in\n    high_resolution)\n\tcheck_msg=\"high resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$high_resolution_clock_gettime_wall\"\n\t;;\n    low_resolution)\n\tcheck_msg=\"low resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$low_resolution_clock_gettime_wall\"\n\t;;\n    custom_resolution)\n\tcheck_msg=\"custom resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$2\"\n\t;;\n    *)\n\tcheck_msg=\"\"\n\tprefer_resolution_clock_gettime_wall=\n\t;;\n  esac\n\n  clock_gettime_lib=\"\"\n  AC_CHECK_LIB(rt, clock_gettime, [clock_gettime_lib=\"-lrt\"])\n\n  save_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $clock_gettime_lib\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     trust_test=\"#error May not be there due to weak linking\"\n  else\n     trust_test=\"\"\n  fi\n\n  AC_CACHE_CHECK([for clock_gettime() with ${check_msg}wall clock type], erl_cv_clock_gettime_wall_$1,\n  [\n     for clock_type in $prefer_resolution_clock_gettime_wall $default_resolution_clock_gettime_wall $high_resolution_clock_gettime_wall $low_resolution_clock_gettime_wall; do\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime($clock_type,&ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_wall_$1=$clock_type,\n\t\t      erl_cv_clock_gettime_wall_$1=no)\n       test $erl_cv_clock_gettime_wall_$1 = no || break\n     done\n  ])\n\n  LIBS=\"$save_LIBS\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     check_for_clock_getres=\n  else\n     check_for_clock_getres=clock_getres\n  fi\n\n  AC_CHECK_FUNCS([$check_for_clock_getres clock_get_attributes gettimeofday])\n  \n  AC_CACHE_CHECK([for mach clock_get_time() with wall clock type], erl_cv_mach_clock_get_time_wall,\n  [\n     AC_TRY_COMPILE([\n#include <mach/clock.h>\n#include <mach/mach.h>\n\t\t\t],\n\t \t\t[\n    kern_return_t res;\n    clock_serv_t clk_srv;\n    mach_timespec_t time_spec;\n\n    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &clk_srv);\n    res = clock_get_time(clk_srv, &time_spec);\n    mach_port_deallocate(mach_task_self(), clk_srv);\n    \t\t\t],\n    \t\t\terl_cv_mach_clock_get_time_wall=yes,\n\t\t\terl_cv_mach_clock_get_time_wall=no)\n  ])\n\n  erl_wall_clock_lib=\n  erl_wall_clock_low_resolution=no\n  erl_wall_clock_id=\n  case $1-$erl_cv_clock_gettime_wall_$1-$erl_cv_mach_clock_get_time_wall-$ac_cv_func_gettimeofday-$host_os in\n    *-*-*-*-win32)\n      erl_wall_clock_func=WindowsAPI\n      erl_wall_clock_low_resolution=yes\n      ;;\n    high_resolution-no-yes-*-*)\n      erl_wall_clock_func=mach_clock_get_time\n      erl_wall_clock_id=CALENDAR_CLOCK\n      ;;\n    *-CLOCK_*-*-*-*)\n      erl_wall_clock_func=clock_gettime\n      erl_wall_clock_lib=$clock_gettime_lib\n      erl_wall_clock_id=$erl_cv_clock_gettime_wall_$1\n      for low_res_id in $low_resolution_clock_gettime_wall; do\n      \t  if test $erl_wall_clock_id = $low_res_id; then\n\t    erl_wall_clock_low_resolution=yes\n\t    break\n\t  fi\n      done\n      ;;\n    *-no-*-yes-*)\n      erl_wall_clock_func=gettimeofday\n      ;;\n    *)\n      erl_wall_clock_func=none\n      ;;\n  esac\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_CHECK_THR_LIB\ndnl\ndnl This macro may be used by any OTP application.\ndnl\ndnl LM_CHECK_THR_LIB sets THR_LIBS, THR_DEFS, and THR_LIB_NAME. It also\ndnl checks for some pthread headers which will appear in DEFS or config.h.\ndnl\n\nAC_DEFUN(LM_CHECK_THR_LIB,\n[\n\nNEED_NPTL_PTHREAD_H=no\n\ndnl win32?\nAC_MSG_CHECKING([for native win32 threads])\nif test \"X$host_os\" = \"Xwin32\"; then\n    AC_MSG_RESULT(yes)\n    THR_DEFS=\"-DWIN32_THREADS\"\n    THR_LIBS=\n    THR_LIB_NAME=win32_threads\n    THR_LIB_TYPE=win32_threads\nelse\n    AC_MSG_RESULT(no)\n    THR_DEFS=\n    THR_LIBS=\n    THR_LIB_NAME=\n    THR_LIB_TYPE=posix_unknown\n\ndnl Try to find POSIX threads\n\ndnl The usual pthread lib...\n    AC_CHECK_LIB(pthread, pthread_create, THR_LIBS=\"-lpthread\")\n\ndnl Very old versions of FreeBSD have pthreads in special c library, c_r...\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_CHECK_LIB(c_r, pthread_create, THR_LIBS=\"-lc_r\")\n    fi\n\ndnl QNX has pthreads in standard C library\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_CHECK_FUNC(pthread_create, THR_LIBS=\"none_needed\")\n    fi\n\ndnl On ofs1 the '-pthread' switch should be used\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_MSG_CHECKING([if the '-pthread' switch can be used])\n\tsaved_cflags=$CFLAGS\n\tCFLAGS=\"$CFLAGS -pthread\"\n\tAC_TRY_LINK([#include <pthread.h>],\n\t\t    pthread_create((void*)0,(void*)0,(void*)0,(void*)0);,\n\t\t    [THR_DEFS=\"-pthread\"\n\t\t     THR_LIBS=\"-pthread\"])\n\tCFLAGS=$saved_cflags\n\tif test \"x$THR_LIBS\" != \"x\"; then\n\t    AC_MSG_RESULT(yes)\n\telse\n\t    AC_MSG_RESULT(no)\n\tfi\n    fi\n\n    if test \"x$THR_LIBS\" != \"x\"; then\n\tTHR_DEFS=\"$THR_DEFS -D_THREAD_SAFE -D_REENTRANT -DPOSIX_THREADS\"\n\tTHR_LIB_NAME=pthread\n\tif test \"x$THR_LIBS\" = \"xnone_needed\"; then\n\t    THR_LIBS=\n\tfi\n\tcase $host_os in\n\t    solaris*)\n\t\tTHR_DEFS=\"$THR_DEFS -D_POSIX_PTHREAD_SEMANTICS\" ;;\n\t    linux*)\n\t\tTHR_DEFS=\"$THR_DEFS -D_POSIX_THREAD_SAFE_FUNCTIONS\"\n\n\t\tLM_CHECK_GETCONF\n\t\tAC_MSG_CHECKING(for Native POSIX Thread Library)\n\t\tlibpthr_vsn=`$GETCONF GNU_LIBPTHREAD_VERSION 2>/dev/null`\n\t\tif test $? -eq 0; then\n\t\t    case \"$libpthr_vsn\" in\n\t\t\t*nptl*|*NPTL*) nptl=yes;;\n\t\t\t*) nptl=no;;\n\t\t    esac\n\t\telif test \"$cross_compiling\" = \"yes\"; then\n\t\t    case \"$erl_xcomp_linux_nptl\" in\n\t\t\t\"\") nptl=cross;;\n\t\t\tyes|no) nptl=$erl_xcomp_linux_nptl;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_nptl value: $erl_xcomp_linux_nptl]);;\n\t\t    esac\n\t\telse\n\t\t    nptl=no\n\t\tfi\n\t\tAC_MSG_RESULT($nptl)\n\t\tif test $nptl = cross; then\n\t\t    nptl=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $nptl = yes; then\n\t\t    THR_LIB_TYPE=posix_nptl\n\t\t    need_nptl_incldir=no\n\t\t    AC_CHECK_HEADER(nptl/pthread.h,\n\t\t\t\t    [need_nptl_incldir=yes\n\t\t\t\t     NEED_NPTL_PTHREAD_H=yes])\n\t\t    if test $need_nptl_incldir = yes; then\n\t\t\t# Ahh...\n\t\t\tnptl_path=\"$C_INCLUDE_PATH:$CPATH\"\n\t\t\tif test X$cross_compiling != Xyes; then\n\t\t\t    nptl_path=\"$nptl_path:/usr/local/include:/usr/include\"\n\t\t\telse\n\t\t\t    IROOT=\"$erl_xcomp_isysroot\"\n\t\t\t    test \"$IROOT\" != \"\" || IROOT=\"$erl_xcomp_sysroot\"\n\t\t\t    test \"$IROOT\" != \"\" || AC_MSG_ERROR([Don't know where to search for includes! Please set erl_xcomp_isysroot])\n\t\t\t    nptl_path=\"$nptl_path:$IROOT/usr/local/include:$IROOT/usr/include\"\n\t\t\tfi\n\t\t\tnptl_ws_path=\n\t\t\tsave_ifs=\"$IFS\"; IFS=\":\"\n\t\t\tfor dir in $nptl_path; do\n\t\t\t    if test \"x$dir\" != \"x\"; then\n\t\t\t\tnptl_ws_path=\"$nptl_ws_path $dir\"\n\t\t\t    fi\n\t\t\tdone\n\t\t\tIFS=$save_ifs\n\t\t\tnptl_incldir=\n\t\t\tfor dir in $nptl_ws_path; do\n\t\t            AC_CHECK_HEADER($dir/nptl/pthread.h,\n\t\t\t\t\t    nptl_incldir=$dir/nptl)\n\t\t\t    if test \"x$nptl_incldir\" != \"x\"; then\n\t\t\t\tTHR_DEFS=\"$THR_DEFS -isystem $nptl_incldir\"\n\t\t\t\tbreak\n\t\t\t    fi\n\t\t\tdone\n\t\t\tif test \"x$nptl_incldir\" = \"x\"; then\n\t\t\t    AC_MSG_ERROR(Failed to locate nptl system include directory)\n\t\t\tfi\n\t\t    fi\n\t\tfi\n\t\t;;\n\t    *) ;;\n\tesac\n\n\tdnl We sometimes need THR_DEFS in order to find certain headers\n\tdnl (at least for pthread.h on osf1).\n\tsaved_cppflags=$CPPFLAGS\n\tCPPFLAGS=\"$CPPFLAGS $THR_DEFS\"\n\n\tdnl\n\tdnl Check for headers\n\tdnl\n\n\tAC_CHECK_HEADER(pthread.h,\n\t\t\tAC_DEFINE(HAVE_PTHREAD_H, 1, \\\n[Define if you have the <pthread.h> header file.]))\n\n\tdnl Some Linuxes have <pthread/mit/pthread.h> instead of <pthread.h>\n\tAC_CHECK_HEADER(pthread/mit/pthread.h, \\\n\t\t\tAC_DEFINE(HAVE_MIT_PTHREAD_H, 1, \\\n[Define if the pthread.h header file is in pthread/mit directory.]))\n\n\tdnl restore CPPFLAGS\n\tCPPFLAGS=$saved_cppflags\n\n    fi\nfi\n\n])\n\nAC_DEFUN(ERL_INTERNAL_LIBS,\n[\n\nERTS_INTERNAL_X_LIBS=\n\nAC_CHECK_LIB(kstat, kstat_open,\n[AC_DEFINE(HAVE_KSTAT, 1, [Define if you have kstat])\nERTS_INTERNAL_X_LIBS=\"$ERTS_INTERNAL_X_LIBS -lkstat\"])\n\nAC_SUBST(ERTS_INTERNAL_X_LIBS)\n\n])\n\nAC_DEFUN(ETHR_CHK_GCC_ATOMIC_OP__,\n[\n    # $1 - atomic_op\n\n    for atomic_bit_size in 32 64 128; do\n\tcase $atomic_bit_size in\n\t    32) gcc_atomic_type=\"$gcc_atomic_type32\";;\n\t    64) gcc_atomic_type=\"$gcc_atomic_type64\";;\n\t    128) gcc_atomic_type=\"$gcc_atomic_type128\";;\n\tesac\n\tgcc_atomic_lockfree=\"int x[[(2*__atomic_always_lock_free(sizeof($gcc_atomic_type), 0))-1]]\"\n\tcase $1 in\n\t    __sync_add_and_fetch | __sync_fetch_and_and | __sync_fetch_and_or)\n\t\tatomic_call=\"volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0);\"\n\t\t;;\n\t    __sync_val_compare_and_swap)\n\t\tatomic_call=\"volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0, ($gcc_atomic_type) 0);\"\n\t\t;;\n\t    __atomic_store_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELAXED); $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELEASE);\"\n\t\t;;\n\t    __atomic_load_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, __ATOMIC_RELAXED); res = $1(&var, __ATOMIC_ACQUIRE);\"\n\t\t;;\n\t    __atomic_add_fetch| __atomic_fetch_and | __atomic_fetch_or)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELAXED); res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_ACQUIRE); res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELEASE);\"\n\t\t;;\n\t    __atomic_compare_exchange_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type val; int res = $1(&var, &val, ($gcc_atomic_type) 0, 0, __ATOMIC_RELAXED, __ATOMIC_RELAXED); res = $1(&var, &val, ($gcc_atomic_type) 0, 0, __ATOMIC_ACQUIRE, __ATOMIC_ACQUIRE);\"\n\t\t;;\n\t    *)\n\t\tAC_MSG_ERROR([Internal error: missing implementation for $1])\n\t\t;;\n\tesac\n\teval atomic${atomic_bit_size}_call=\\\"$atomic_call\\\"\n    done\n    \n    AC_CACHE_CHECK([for 32-bit $1()], ethr_cv_32bit_$1,\n\t\t   [\n\t\t       ethr_cv_32bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic32_call], [ethr_cv_32bit_$1=yes])\n\t\t   ])\n    AC_CACHE_CHECK([for 64-bit $1()], ethr_cv_64bit_$1,\n\t\t   [\n\t\t       ethr_cv_64bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic64_call], [ethr_cv_64bit_$1=yes])\n\t\t   ])\n    AC_CACHE_CHECK([for 128-bit $1()], ethr_cv_128bit_$1,\n\t\t   [\n\t\t       ethr_cv_128bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic128_call], [ethr_cv_128bit_$1=yes])\n\t\t   ])\n\n\tcase $ethr_cv_128bit_$1-$ethr_cv_64bit_$1-$ethr_cv_32bit_$1 in\n\t    no-no-no)\n\t\thave_atomic_ops=0;;\n\t    no-no-yes)\n\t\thave_atomic_ops=4;;\n\t    no-yes-no)\n\t\thave_atomic_ops=8;;\n\t    no-yes-yes)\n\t\thave_atomic_ops=12;;\n\t    yes-no-no)\n\t\thave_atomic_ops=16;;\n\t    yes-no-yes)\n\t\thave_atomic_ops=20;;\n\t    yes-yes-no)\n\t\thave_atomic_ops=24;;\n\t    yes-yes-yes)\n\t\thave_atomic_ops=28;;\n\tesac\n\tAC_DEFINE_UNQUOTED([ETHR_HAVE_$1], [$have_atomic_ops], [Define as a bitmask corresponding to the word sizes that $1() can handle on your system])\n])\n\nAC_DEFUN(ETHR_CHK_IF_NOOP,\n[\n   ethr_test_filename=\"chk_if_$1$3_noop_config1test.$$\"\n   cat > \"${ethr_test_filename}.c\" <<EOF\nint\nmy_test(void)\n{\n    $1$2;\n    return 0;\n}\nEOF\n   $CC -O3 $ETHR_DEFS -c \"${ethr_test_filename}.c\" -o \"${ethr_test_filename}1.o\"\n   cat > \"${ethr_test_filename}.c\" <<EOF\nint\nmy_test(void)\n{\n    ;\n    return 0;\n}\nEOF\n   $CC -O3 $ETHR_DEFS -c \"${ethr_test_filename}.c\" -o \"${ethr_test_filename}2.o\"\n   if diff \"${ethr_test_filename}1.o\" \"${ethr_test_filename}2.o\" >/dev/null 2>&1; then\n      ethr_$1$3_noop=yes\n   else\n      ethr_$1$3_noop=no\n   fi\n   rm -f \"${ethr_test_filename}.c\" \"${ethr_test_filename}1.o\"  \"${ethr_test_filename}2.o\" \n])\n\nAC_DEFUN(ETHR_CHK_GCC_ATOMIC_OPS,\n[\n    AC_CHECK_SIZEOF(short)\n    AC_CHECK_SIZEOF(int)\n    AC_CHECK_SIZEOF(long)\n    AC_CHECK_SIZEOF(long long)\n    AC_CHECK_SIZEOF(__int128_t)\n\n    if test \"$ac_cv_sizeof_short\" = \"4\"; then\n\tgcc_atomic_type32=\"short\"\n    elif test \"$ac_cv_sizeof_int\" = \"4\"; then\n\tgcc_atomic_type32=\"int\"\n    elif test \"$ac_cv_sizeof_long\" = \"4\"; then\n\tgcc_atomic_type32=\"long\"\n    else\n\tAC_MSG_ERROR([No 32-bit type found])\n    fi\n\n    if test \"$ac_cv_sizeof_int\" = \"8\"; then\n\tgcc_atomic_type64=\"int\"\n    elif test \"$ac_cv_sizeof_long\" = \"8\"; then\n\tgcc_atomic_type64=\"long\"\n    elif test \"$ac_cv_sizeof_long_long\" = \"8\"; then\n\tgcc_atomic_type64=\"long long\"\n    else\n\tAC_MSG_ERROR([No 64-bit type found])\n    fi\n\n    if test \"$ac_cv_sizeof___int128_t\" = \"16\"; then\n\tgcc_atomic_type128=\"__int128_t\"\n    else\n\tgcc_atomic_type128=\"#error \"\t\n    fi\n    AC_CACHE_CHECK([for a working __sync_synchronize()], ethr_cv___sync_synchronize,\n\t\t   [\n\t\t       ethr_cv___sync_synchronize=no\n\t\t       AC_TRY_LINK([],\n\t\t\t\t   [ __sync_synchronize(); ],\n\t\t\t\t   [ethr_cv___sync_synchronize=yes])\n\t\t       if test $ethr_cv___sync_synchronize = yes; then\n\t\t\t   #\n\t\t\t   # Old gcc versions on at least x86 have a buggy\n\t\t\t   # __sync_synchronize() which does not emit a\n\t\t\t   # memory barrier. We try to detect this by\n\t\t\t   # compiling to assembly with and without\n\t\t\t   # __sync_synchronize() and compare the results.\n\t\t\t   #\n\t\t\t   ETHR_CHK_IF_NOOP(__sync_synchronize, [()], [])\n\t\t\t   if test $ethr___sync_synchronize_noop = yes; then\n\t\t\t      # Got a buggy implementation of\n\t\t\t      # __sync_synchronize...\n\t\t\t      ethr_cv___sync_synchronize=\"no; buggy implementation\"\n\t\t\t   fi\n\t\t       fi\n\t\t   ])\n\n    if test \"$ethr_cv___sync_synchronize\" = \"yes\"; then\n\thave_sync_synchronize_value=\"~0\"\n    else\n\thave_sync_synchronize_value=\"0\"\n    fi\n    AC_DEFINE_UNQUOTED([ETHR_HAVE___sync_synchronize], [$have_sync_synchronize_value], [Define as a bitmask corresponding to the word sizes that __sync_synchronize() can handle on your system])\n\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_add_and_fetch)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_fetch_and_and)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_fetch_and_or)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_val_compare_and_swap)\n\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_store_n)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_load_n)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_add_fetch)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_fetch_and)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_fetch_or)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_compare_exchange_n)\n\n    ethr_have_gcc_native_atomics=no\n    ethr_arm_dbm_instr_val=0\n    case \"$GCC-$host_cpu\" in\n\tyes-arm*)\n\t    AC_CACHE_CHECK([for ARM DMB instruction], ethr_cv_arm_dbm_instr,\n\t\t\t   [\n\t\t\t\tethr_cv_arm_dbm_instr=no\n\t\t\t\tAC_TRY_LINK([],\n\t\t\t\t\t    [\n\t\t\t\t\t\t__asm__ __volatile__(\"dmb sy\" : : : \"memory\");\n\t\t\t\t\t\t__asm__ __volatile__(\"dmb st\" : : : \"memory\");\n\t\t\t\t\t    ],\n\t\t\t\t\t    [ethr_cv_arm_dbm_instr=yes])\n\t\t\t   ])\n\t    if test $ethr_cv_arm_dbm_instr = yes; then\n\t\tethr_arm_dbm_instr_val=1\n\t\ttest $ethr_cv_64bit___atomic_compare_exchange_n = yes &&\n\t\t    ethr_have_gcc_native_atomics=yes\n\t    fi;;\n\t*)\n\t    ;;\n    esac\n    AC_DEFINE_UNQUOTED([ETHR_HAVE_GCC_ASM_ARM_DMB_INSTRUCTION], [$ethr_arm_dbm_instr_val], [Define as a boolean indicating whether you have a gcc compatible compiler capable of generating the ARM DMB instruction, and are compiling for an ARM processor with ARM DMB instruction support, or not])\n    test $ethr_cv_32bit___sync_val_compare_and_swap = yes &&\n    \tethr_have_gcc_native_atomics=yes\n    test $ethr_cv_64bit___sync_val_compare_and_swap = yes &&\n    \tethr_have_gcc_native_atomics=yes\n    if test \"$ethr_cv___sync_synchronize\" = \"yes\"; then\n    \ttest $ethr_cv_64bit___atomic_compare_exchange_n = yes &&\n    \t    ethr_have_gcc_native_atomics=yes\n    \ttest $ethr_cv_32bit___atomic_compare_exchange_n = yes &&\n    \t    ethr_have_gcc_native_atomics=yes\n    fi\n    ethr_have_gcc_atomic_builtins=0\n    if test $ethr_have_gcc_native_atomics = yes; then\n       ethr_native_atomic_implementation=gcc_sync\n       test $ethr_cv_32bit___atomic_compare_exchange_n = yes && ethr_have_gcc_atomic_builtins=1\n       test $ethr_cv_64bit___atomic_compare_exchange_n = yes && ethr_have_gcc_atomic_builtins=1\n       test $ethr_have_gcc_atomic_builtins = 1 && ethr_native_atomic_implementation=gcc_atomic_sync\n    fi\n    AC_DEFINE_UNQUOTED([ETHR_HAVE_GCC___ATOMIC_BUILTINS], [$ethr_have_gcc_atomic_builtins], [Define as a boolean indicating whether you have a gcc __atomic builtins or not])\n    test $ethr_have_gcc_native_atomics = yes && ethr_have_native_atomics=yes\n])\n\nAC_DEFUN(ETHR_CHK_INTERLOCKED,\n[\n    ilckd=\"$1\"\n    AC_MSG_CHECKING([for ${ilckd}()])\n    case \"$2\" in\n\t\"1\") ilckd_call=\"${ilckd}(var);\";;\n\t\"2\") ilckd_call=\"${ilckd}(var, ($3) 0);\";;\n\t\"3\") ilckd_call=\"${ilckd}(var, ($3) 0, ($3) 0);\";;\n\t\"4\") ilckd_call=\"${ilckd}(var, ($3) 0, ($3) 0, arr);\";;\n    esac\n    have_interlocked_op=no\n    AC_TRY_LINK(\n\t[\n\t#define WIN32_LEAN_AND_MEAN\n\t#include <windows.h>\n\t#include <intrin.h>\n\t],\n\t[\n\t    volatile $3 *var;\n\t    volatile $3 arr[2];\n\n\t    $ilckd_call\n\t    return 0;\n\t],\n\t[have_interlocked_op=yes])\n    test $have_interlocked_op = yes && $4\n    AC_MSG_RESULT([$have_interlocked_op])\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl ERL_FIND_ETHR_LIB\ndnl\ndnl NOTE! This macro may be changed at any time! Should *only* be used by\ndnl       ERTS!\ndnl\ndnl Find a thread library to use. Sets ETHR_LIBS to libraries to link\ndnl with, ETHR_X_LIBS to extra libraries to link with (same as ETHR_LIBS\ndnl except that the ethread lib itself is not included), ETHR_DEFS to\ndnl defines to compile with, ETHR_THR_LIB_BASE to the name of the\ndnl thread library which the ethread library is based on, and ETHR_LIB_NAME\ndnl to the name of the library where the ethread implementation is located.\ndnl  ERL_FIND_ETHR_LIB currently searches for 'pthreads', and\ndnl 'win32_threads'. If no thread library was found ETHR_LIBS, ETHR_X_LIBS,\ndnl ETHR_DEFS, ETHR_THR_LIB_BASE, and ETHR_LIB_NAME are all set to the\ndnl empty string.\ndnl\n\nAC_DEFUN(ERL_FIND_ETHR_LIB,\n[\n\nAC_ARG_ENABLE(native-ethr-impls,\n\t      AS_HELP_STRING([--disable-native-ethr-impls],\n                             [disable native ethread implementations]),\n[ case \"$enableval\" in\n    no) disable_native_ethr_impls=yes ;;\n    *)  disable_native_ethr_impls=no ;;\n  esac ], disable_native_ethr_impls=no)\n\ntest \"X$disable_native_ethr_impls\" = \"Xyes\" &&\n  AC_DEFINE(ETHR_DISABLE_NATIVE_IMPLS, 1, [Define if you want to disable native ethread implementations])\n\nAC_ARG_ENABLE(x86-out-of-order,\n\t      AS_HELP_STRING([--enable-x86-out-of-order],\n                             [enable x86/x84_64 out of order support (default disabled)]))\n\nAC_ARG_ENABLE(prefer-gcc-native-ethr-impls,\n\t      AS_HELP_STRING([--enable-prefer-gcc-native-ethr-impls],\n\t\t\t     [prefer gcc native ethread implementations]),\n[ case \"$enableval\" in\n    yes) enable_prefer_gcc_native_ethr_impls=yes ;;\n    *)  enable_prefer_gcc_native_ethr_impls=no ;;\n  esac ], enable_prefer_gcc_native_ethr_impls=no)\n\ntest $enable_prefer_gcc_native_ethr_impls = yes &&\n  AC_DEFINE(ETHR_PREFER_GCC_NATIVE_IMPLS, 1, [Define if you prefer gcc native ethread implementations])\n\nAC_ARG_ENABLE(trust-gcc-atomic-builtins-memory-barriers,\n\t      AS_HELP_STRING([--enable-trust-gcc-atomic-builtins-memory-barriers],\n\t\t\t     [trust gcc atomic builtins memory barriers]),\n[ case \"$enableval\" in\n    yes) trust_gcc_atomic_builtins_mbs=1 ;;\n    *) trust_gcc_atomic_builtins_mbs=0 ;;\n  esac ], trust_gcc_atomic_builtins_mbs=0)\n\nAC_DEFINE_UNQUOTED(ETHR_TRUST_GCC_ATOMIC_BUILTINS_MEMORY_BARRIERS, [$trust_gcc_atomic_builtins_mbs], [Define as a boolean indicating whether you trust gcc's __atomic_* builtins memory barrier implementations, or not])\n\nAC_ARG_WITH(libatomic_ops,\n\t    AS_HELP_STRING([--with-libatomic_ops=PATH],\n\t\t\t   [specify and prefer usage of libatomic_ops in the ethread library]))\n\nAC_ARG_WITH(with_sparc_memory_order,\n\t    AS_HELP_STRING([--with-sparc-memory-order=TSO|PSO|RMO],\n\t\t\t   [specify sparc memory order (defaults to RMO)]))\n\nLM_CHECK_THR_LIB\nERL_INTERNAL_LIBS\n\nERL_MONOTONIC_CLOCK(try_find_pthread_compatible, CLOCK_HIGHRES CLOCK_MONOTONIC, no)\n\ncase $erl_monotonic_clock_func in\n  clock_gettime)\n    AC_DEFINE(ETHR_HAVE_CLOCK_GETTIME_MONOTONIC, [1], [Define if you have a clock_gettime() with a monotonic clock])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(ETHR_HAVE_MACH_CLOCK_GET_TIME, [1], [Define if you have a mach clock_get_time() with a monotonic clock])\n    ;;\n  gethrtime)\n    AC_DEFINE(ETHR_HAVE_GETHRTIME, [1], [Define if you have a monotonic gethrtime()])\n    ;;\n  *)\n    ;;\nesac\n\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(ETHR_MONOTONIC_CLOCK_ID, [$erl_monotonic_clock_id], [Define to the monotonic clock id to use])\nfi\n\nethr_native_atomic_implementation=none\nethr_have_native_atomics=no\nethr_have_native_spinlock=no\nETHR_THR_LIB_BASE=\"$THR_LIB_NAME\"\nETHR_THR_LIB_BASE_TYPE=\"$THR_LIB_TYPE\"\nETHR_DEFS=\"$THR_DEFS\"\nETHR_X_LIBS=\"$THR_LIBS $ERTS_INTERNAL_X_LIBS $erl_monotonic_clock_lib\"\nETHR_LIBS=\nETHR_LIB_NAME=\n\nethr_modified_default_stack_size=\n\nAC_ARG_WITH(threadnames,\nAS_HELP_STRING([--with-threadnames], [use pthread_setname to set the thread names (default)])\nAS_HELP_STRING([--without-threadnames],\n               [do not set any thread names]),\n[],\n[with_threadnames=yes])\n\ndnl Name of lib where ethread implementation is located\nethr_lib_name=ethread\n\ncase \"$THR_LIB_NAME\" in\n\n    win32_threads)\n\tETHR_THR_LIB_BASE_DIR=win\n\t# * _WIN32_WINNT >= 0x0400 is needed for\n\t#   TryEnterCriticalSection\n\t# * _WIN32_WINNT >= 0x0403 is needed for\n\t#   InitializeCriticalSectionAndSpinCount\n\t# The ethread lib will refuse to build if _WIN32_WINNT < 0x0403.\n\t#\n\t# -D_WIN32_WINNT should have been defined in $CPPFLAGS; fetch it\n\t# and save it in ETHR_DEFS.\n\tfound_win32_winnt=no\n\tfor cppflag in $CPPFLAGS; do\n\t    case $cppflag in\n\t\t-DWINVER*)\n\t\t    ETHR_DEFS=\"$ETHR_DEFS $cppflag\"\n\t\t    ;;\n\t\t-D_WIN32_WINNT*)\n\t\t    ETHR_DEFS=\"$ETHR_DEFS $cppflag\"\n\t\t    found_win32_winnt=yes\n\t\t    ;;\n\t\t*)\n\t\t    ;;\n\t    esac\n        done\n        if test $found_win32_winnt = no; then\n\t    AC_MSG_ERROR([-D_WIN32_WINNT missing in CPPFLAGS])\n        fi\n\n\tAC_DEFINE(ETHR_WIN32_THREADS, 1, [Define if you have win32 threads])\n\n\tif test \"X$disable_native_ethr_impls\" = \"Xyes\"; then\n\t    have_interlocked_op=no\n\t    ethr_have_native_atomics=no\n\telse\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT, 1, [Define if you have _InterlockedDecrement()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement_rel], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT_REL, 1, [Define if you have _InterlockedDecrement_rel()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT, 1, [Define if you have _InterlockedIncrement()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement_acq], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT_ACQ, 1, [Define if you have _InterlockedIncrement_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD, 1, [Define if you have _InterlockedExchangeAdd()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd_acq], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD_ACQ, 1, [Define if you have _InterlockedExchangeAdd_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedAnd], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDAND, 1, [Define if you have _InterlockedAnd()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedOr], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDOR, 1, [Define if you have _InterlockedOr()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchange], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGE, 1, [Define if you have _InterlockedExchange()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE, 1, [Define if you have _InterlockedCompareExchange()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange_acq], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE_ACQ, 1, [Define if you have _InterlockedCompareExchange_acq()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange_rel], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE_REL, 1, [Define if you have _InterlockedCompareExchange_rel()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement64], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT64, 1, [Define if you have _InterlockedDecrement64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement64_rel], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT64_REL, 1, [Define if you have _InterlockedDecrement64_rel()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement64], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT64, 1, [Define if you have _InterlockedIncrement64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement64_acq], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT64_ACQ, 1, [Define if you have _InterlockedIncrement64_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD64, 1, [Define if you have _InterlockedExchangeAdd64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd64_acq], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD64_ACQ, 1, [Define if you have _InterlockedExchangeAdd64_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedAnd64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDAND64, 1, [Define if you have _InterlockedAnd64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedOr64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDOR64, 1, [Define if you have _InterlockedOr64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchange64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGE64, 1, [Define if you have _InterlockedExchange64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64, 1, [Define if you have _InterlockedCompareExchange64()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64_acq], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64_ACQ, 1, [Define if you have _InterlockedCompareExchange64_acq()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64_rel], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64_REL, 1, [Define if you have _InterlockedCompareExchange64_rel()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange128], [4], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE128, 1, [Define if you have _InterlockedCompareExchange128()]))\n\tfi\n\tif test \"$ethr_have_native_atomics\" = \"yes\"; then\n\t   ethr_native_atomic_implementation=windows\n\t   ethr_have_native_spinlock=yes\n\tfi\n\t;;\n\n    pthread)\n\tETHR_THR_LIB_BASE_DIR=pthread\n\tAC_DEFINE(ETHR_PTHREADS, 1, [Define if you have pthreads])\n\tcase $host_os in\n\t    openbsd*)\n\t\t# The default stack size is insufficient for our needs\n\t\t# on OpenBSD. We increase it to 256 kilo words.\n\t\tethr_modified_default_stack_size=256;;\n\t    linux*)\n\t\tETHR_DEFS=\"$ETHR_DEFS -D_GNU_SOURCE\"\n\n\t\tif test\tX$cross_compiling = Xyes; then\n\t\t    case X$erl_xcomp_linux_usable_sigusrx in\n\t\t\tX) usable_sigusrx=cross;;\n\t\t\tXyes|Xno) usable_sigusrx=$erl_xcomp_linux_usable_sigusrx;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_usable_sigusrx value: $erl_xcomp_linux_usable_sigusrx]);;\n\t\t    esac\n\t\t    case X$erl_xcomp_linux_usable_sigaltstack in\n\t\t\tX) usable_sigaltstack=cross;;\n\t\t\tXyes|Xno) usable_sigaltstack=$erl_xcomp_linux_usable_sigaltstack;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_usable_sigaltstack value: $erl_xcomp_linux_usable_sigaltstack]);;\n\t\t    esac\n\t\telse\n\t\t    # FIXME: Test for actual problems instead of kernel versions\n\t\t    linux_kernel_vsn_=`uname -r`\n\t\t    case $linux_kernel_vsn_ in\n\t\t\t[[0-1]].*|2.[[0-1]]|2.[[0-1]].*)\n\t\t\t    usable_sigusrx=no\n\t\t\t    usable_sigaltstack=no;;\n\t\t\t2.[[2-3]]|2.[[2-3]].*)\n\t\t\t    usable_sigusrx=yes\n\t\t\t    usable_sigaltstack=no;;\n\t\t    \t*)\n\t\t\t    usable_sigusrx=yes\n\t\t\t    usable_sigaltstack=yes;;\n\t\t    esac\n\t\tfi\n\n\t\tAC_MSG_CHECKING(if SIGUSR1 and SIGUSR2 can be used)\n\t\tAC_MSG_RESULT($usable_sigusrx)\n\t\tif test $usable_sigusrx = cross; then\n\t\t    usable_sigusrx=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $usable_sigusrx = no; then\n\t\t    ETHR_DEFS=\"$ETHR_DEFS -DETHR_UNUSABLE_SIGUSRX\"\n\t\tfi\n\n\t\tAC_MSG_CHECKING(if sigaltstack can be used)\n\t\tAC_MSG_RESULT($usable_sigaltstack)\n\t\tif test $usable_sigaltstack = cross; then\n\t\t    usable_sigaltstack=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $usable_sigaltstack = no; then\n\t\t    ETHR_DEFS=\"$ETHR_DEFS -DETHR_UNUSABLE_SIGALTSTACK\"\n\t\tfi\n\t\t;;\n\t    *) ;;\n\tesac\n\n\tdnl We sometimes need ETHR_DEFS in order to find certain headers\n\tdnl (at least for pthread.h on osf1).\n\tsaved_cppflags=\"$CPPFLAGS\"\n\tCPPFLAGS=\"$CPPFLAGS $ETHR_DEFS\"\n\n\tdnl We need the thread library in order to find some functions\n\tsaved_libs=\"$LIBS\"\n\tLIBS=\"$LIBS $ETHR_X_LIBS\"\n\n\tdnl\n\tdnl Check for headers\n\tdnl\n\tAC_CHECK_HEADER(pthread.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_H, 1, \\\n[Define if you have the <pthread.h> header file.]))\n\n\tdnl Some Linuxes have <pthread/mit/pthread.h> instead of <pthread.h>\n\tAC_CHECK_HEADER(pthread/mit/pthread.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_MIT_PTHREAD_H, 1, \\\n[Define if the pthread.h header file is in pthread/mit directory.]))\n\n\tif test $NEED_NPTL_PTHREAD_H = yes; then\n\t    AC_DEFINE(ETHR_NEED_NPTL_PTHREAD_H, 1, \\\n[Define if you need the <nptl/pthread.h> header file.])\n\tfi\n\n\tAC_CHECK_HEADER(sched.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_SCHED_H, 1, \\\n[Define if you have the <sched.h> header file.]))\n\n\tAC_CHECK_HEADER(sys/time.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_SYS_TIME_H, 1, \\\n[Define if you have the <sys/time.h> header file.]))\n\n\tAC_TRY_COMPILE([#include <time.h>\n\t\t\t#include <sys/time.h>], \n\t\t\t[struct timeval *tv; return 0;],\n\t\t\tAC_DEFINE(ETHR_TIME_WITH_SYS_TIME, 1, \\\n[Define if you can safely include both <sys/time.h> and <time.h>.]))\n\n\tAC_MSG_CHECKING([for usable PTHREAD_STACK_MIN])\n\tpthread_stack_min=no\n\tAC_TRY_COMPILE([\n#include <limits.h>\n#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n#include <nptl/pthread.h>\n#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n#include <pthread/mit/pthread.h>\n#elif defined(ETHR_HAVE_PTHREAD_H)\n#include <pthread.h>\n#endif\n\t\t\t], \n\t\t\t[return PTHREAD_STACK_MIN;],\n\t\t\t[pthread_stack_min=yes])\n\n\tAC_MSG_RESULT([$pthread_stack_min])\n\ttest $pthread_stack_min != yes || {\n\t     AC_DEFINE(ETHR_HAVE_USABLE_PTHREAD_STACK_MIN, 1, [Define if you can use PTHREAD_STACK_MIN])\n\t}\n\n\tdnl\n\tdnl Check for functions\n\tdnl\n\tAC_CHECK_FUNC(pthread_spin_lock, \\\n\t\t\t[ethr_have_native_spinlock=yes \\\n\t\t\t AC_DEFINE(ETHR_HAVE_PTHREAD_SPIN_LOCK, 1, \\\n[Define if you have the pthread_spin_lock function.])])\n\n\thave_sched_yield=no\n\thave_librt_sched_yield=no\n\tAC_CHECK_FUNC(sched_yield, [have_sched_yield=yes])\n\tif test $have_sched_yield = no; then\n\t    AC_CHECK_LIB(rt, sched_yield,\n\t\t\t [have_librt_sched_yield=yes\n\t\t\t  ETHR_X_LIBS=\"$ETHR_X_LIBS -lrt\"])\n\tfi\n\tif test $have_sched_yield = yes || test $have_librt_sched_yield = yes; then\n\t    AC_DEFINE(ETHR_HAVE_SCHED_YIELD, 1, [Define if you have the sched_yield() function.])\n\t    AC_MSG_CHECKING([whether sched_yield() returns an int])\n\t    sched_yield_ret_int=no\n\t    AC_TRY_LINK([\n\t\t\t\t#ifdef ETHR_HAVE_SCHED_H\n\t\t\t\t#include <sched.h>\n\t\t\t\t#endif\n\t\t\t   ],\n\t\t\t   [int sched_yield();],\n\t\t\t   [sched_yield_ret_int=yes])\n\t    AC_MSG_RESULT([$sched_yield_ret_int])\n\t    if test $sched_yield_ret_int = yes; then\n\t\tAC_DEFINE(ETHR_SCHED_YIELD_RET_INT, 1, [Define if sched_yield() returns an int.])\n\t    fi\n\tfi\n\n\thave_pthread_yield=no\n\tAC_CHECK_FUNC(pthread_yield, [have_pthread_yield=yes])\n\tif test $have_pthread_yield = yes; then\n\t    AC_DEFINE(ETHR_HAVE_PTHREAD_YIELD, 1, [Define if you have the pthread_yield() function.])\n\t    AC_MSG_CHECKING([whether pthread_yield() returns an int])\n\t    pthread_yield_ret_int=no\n\t    AC_TRY_LINK([\n\t\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t\t#include <nptl/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t\t#include <pthread/mit/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t\t#include <pthread.h>\n\t\t\t\t#endif\n\t\t\t   ],\n\t\t\t   [int pthread_yield();],\n\t\t\t   [pthread_yield_ret_int=yes])\n\t    AC_MSG_RESULT([$pthread_yield_ret_int])\n\t    if test $pthread_yield_ret_int = yes; then\n\t\tAC_DEFINE(ETHR_PTHREAD_YIELD_RET_INT, 1, [Define if pthread_yield() returns an int.])\n\t    fi\n\tfi\n\n\thave_pthread_rwlock_init=no\n\tAC_CHECK_FUNC(pthread_rwlock_init, [have_pthread_rwlock_init=yes])\n\tif test $have_pthread_rwlock_init = yes; then\n\n\t    ethr_have_pthread_rwlockattr_setkind_np=no\n\t    AC_CHECK_FUNC(pthread_rwlockattr_setkind_np,\n\t\t\t  [ethr_have_pthread_rwlockattr_setkind_np=yes])\n\n\t    if test $ethr_have_pthread_rwlockattr_setkind_np = yes; then\n\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_RWLOCKATTR_SETKIND_NP, 1, \\\n[Define if you have the pthread_rwlockattr_setkind_np() function.])\n\n\t\tAC_MSG_CHECKING([for PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP])\n\t\tethr_pthread_rwlock_writer_nonrecursive_initializer_np=no\n\t\tAC_TRY_LINK([\n\t\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t\t#include <nptl/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t\t#include <pthread/mit/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t\t#include <pthread.h>\n\t\t\t\t#endif\n\t\t\t    ],\n\t\t\t    [\n\t\t\t\tpthread_rwlockattr_t *attr;\n\t\t\t\treturn pthread_rwlockattr_setkind_np(attr,\n\t\t\t\t    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n\t\t\t    ],\n\t\t\t    [ethr_pthread_rwlock_writer_nonrecursive_initializer_np=yes])\n\t\tAC_MSG_RESULT([$ethr_pthread_rwlock_writer_nonrecursive_initializer_np])\n\t\tif test $ethr_pthread_rwlock_writer_nonrecursive_initializer_np = yes; then\n\t\t    AC_DEFINE(ETHR_HAVE_PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, 1, \\\n[Define if you have the PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP rwlock attribute.])\n\t\tfi\n\t    fi\n\tfi\n\n\tif test \"$force_pthread_rwlocks\" = \"yes\"; then\n\n\t    AC_DEFINE(ETHR_FORCE_PTHREAD_RWLOCK, 1, \\\n[Define if you want to force usage of pthread rwlocks])\n\n\t    if test $have_pthread_rwlock_init = yes; then\n\t\tAC_MSG_WARN([Forced usage of pthread rwlocks. Note that this implementation may suffer from starvation issues.])\n\t    else\n\t\tAC_MSG_ERROR([User forced usage of pthread rwlock, but no such implementation was found])\n\t    fi\n\tfi\n\n\tAC_CHECK_FUNC(pthread_attr_setguardsize, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_ATTR_SETGUARDSIZE, 1, \\\n[Define if you have the pthread_attr_setguardsize function.]))\n\n\tif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n\t  AC_MSG_CHECKING(whether pthread_cond_timedwait() can use the monotonic clock $erl_monotonic_clock_id for timeout)\n\t  pthread_cond_timedwait_monotonic=no\n\t  AC_TRY_LINK([\n\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t#  include <nptl/pthread.h>\n\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t#  include <pthread/mit/pthread.h>\n\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t#  include <pthread.h>\n\t\t\t#endif\n\t\t\t#ifdef ETHR_TIME_WITH_SYS_TIME\n\t\t\t#  include <time.h>\n\t\t\t#  include <sys/time.h>\n\t\t\t#else\n\t\t\t#  ifdef ETHR_HAVE_SYS_TIME_H\n\t\t\t#    include <sys/time.h>\n\t\t\t#  else\n\t\t\t#    include <time.h>\n\t\t\t#  endif\n\t\t\t#endif\n\t\t\t#if defined(ETHR_HAVE_MACH_CLOCK_GET_TIME)\n\t\t\t#  include <mach/clock.h>\n\t\t\t#  include <mach/mach.h>\n\t\t\t#endif\n\t\t\t], \n\t\t\t[\n\t\t\tint res;\n\t\t\tpthread_condattr_t attr;\n\t\t\tpthread_cond_t cond;\n\t\t\tstruct timespec cond_timeout;\n\t\t\tpthread_mutex_t mutex;\n\t\t\tres = pthread_condattr_init(&attr);\n\t\t\tres = pthread_condattr_setclock(&attr, ETHR_MONOTONIC_CLOCK_ID);\n\t\t\tres = pthread_cond_init(&cond, &attr);\n\t\t\tres = pthread_cond_timedwait(&cond, &mutex, &cond_timeout);\n\t\t\t],\n\t\t\t[pthread_cond_timedwait_monotonic=yes])\n\t  AC_MSG_RESULT([$pthread_cond_timedwait_monotonic])\n\t  if test $pthread_cond_timedwait_monotonic = yes; then\n\t    AC_DEFINE(ETHR_HAVE_PTHREAD_COND_TIMEDWAIT_MONOTONIC, [1], [Define if pthread_cond_timedwait() can be used with a monotonic clock])\n\t  fi\n\tfi\n\n\tlinux_futex=no\n\tAC_MSG_CHECKING([for Linux futexes])\n\tAC_TRY_LINK([\n\t\t\t#include <sys/syscall.h>\n\t\t\t#include <unistd.h>\n\t\t\t#include <linux/futex.h>\n\t\t\t#include <sys/time.h>\n\t\t    ],\n\t\t    [\n\t\t\tint i = 1;\n\t\t\tsyscall(__NR_futex, (void *) &i, FUTEX_WAKE, 1,\n\t\t\t\t(void*)0,(void*)0, 0);\n\t\t\tsyscall(__NR_futex, (void *) &i, FUTEX_WAIT, 0,\n\t\t\t\t(void*)0,(void*)0, 0);\n\t\t\treturn 0;\n\t\t    ],\n\t\t    linux_futex=yes)\n\tAC_MSG_RESULT([$linux_futex])\n\ttest $linux_futex = yes && AC_DEFINE(ETHR_HAVE_LINUX_FUTEX, 1, [Define if you have a linux futex implementation.])\n\n\tpthread_setname=no\n\tAC_MSG_CHECKING([for pthread_setname_np])\n\told_CFLAGS=$CFLAGS\n\tCFLAGS=\"$CFLAGS -Werror\"\n\tAC_TRY_LINK([#define __USE_GNU\n                     #include <pthread.h>],\n                    [pthread_setname_np(pthread_self(), \"name\");],\n                    pthread_setname=linux)\n\tAC_TRY_LINK([#define __USE_GNU\n                     #include <pthread.h>],\n                    [pthread_set_name_np(pthread_self(), \"name\");],\n                    pthread_setname=bsd)\n\tAC_TRY_LINK([#define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [pthread_setname_np(\"name\");],\n                    pthread_setname=darwin)\n        AC_MSG_RESULT([$pthread_setname])\n        case $with_threadnames-$pthread_setname in\n             yes-linux) AC_DEFINE(ETHR_HAVE_PTHREAD_SETNAME_NP_2, 1,\n                          [Define if you have linux style pthread_setname_np]);;\n             yes-bsd) AC_DEFINE(ETHR_HAVE_PTHREAD_SET_NAME_NP_2, 1,\n                          [Define if you have bsd style pthread_set_name_np]);;\n             yes-darwin) AC_DEFINE(ETHR_HAVE_PTHREAD_SETNAME_NP_1, 1,\n                          [Define if you have darwin style pthread_setname_np]);;\n             *) ;;\n\tesac\n\n\tpthread_getname=no\n\tAC_MSG_CHECKING([for pthread_getname_np])\n\tAC_TRY_LINK([#define __USE_GNU\n                     #define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [char buff[256]; pthread_getname_np(pthread_self(), buff, 256);],\n                    pthread_getname=linux)\n\tAC_TRY_LINK([#define __USE_GNU\n                     #define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [char buff[256]; pthread_getname_np(pthread_self(), buff);],\n                    pthread_getname=ibm)\n        AC_MSG_RESULT([$pthread_getname])\n        case $pthread_getname in\n             linux) AC_DEFINE(ETHR_HAVE_PTHREAD_GETNAME_NP_3, 1,\n                          [Define if you have linux style pthread_getname_np]);;\n             ibm) AC_DEFINE(ETHR_HAVE_PTHREAD_GETNAME_NP_2, 1,\n                          [Define if you have ibm style pthread_getname_np]);;\n             *) ;;\n\tesac\n\tCFLAGS=$old_CFLAGS\n\n\tif test \"X$disable_native_ethr_impls\" = \"Xyes\"; then\n\t    ethr_have_native_atomics=no\n\telse\n\n\t    ETHR_CHK_GCC_ATOMIC_OPS([])\n\n\t    AC_MSG_CHECKING([for a usable libatomic_ops implementation])\n\t    case \"x$with_libatomic_ops\" in\n\t        xno | xyes | x)\n\t    \t    libatomic_ops_include=\n\t    \t    ;;\n\t        *)\n\t    \t    if test -d \"${with_libatomic_ops}/include\"; then\n\t    \t        libatomic_ops_include=\"-I$with_libatomic_ops/include\"\n\t    \t        CPPFLAGS=\"$CPPFLAGS $libatomic_ops_include\"\n\t    \t    else\n\t    \t        AC_MSG_ERROR([libatomic_ops include directory $with_libatomic_ops/include not found])\n\t    \t    fi;;\n\t    esac\n\t    ethr_have_libatomic_ops=no\n\t    AC_TRY_LINK([#include \"atomic_ops.h\"],\n\t    \t        [\n\t    \t    \t    volatile AO_t x;\n\t    \t    \t    AO_t y;\n\t    \t    \t    int z;\n\n\t    \t    \t    AO_nop_full();\n#if defined(AO_HAVE_store)\n\t    \t    \t    AO_store(&x, (AO_t) 0);\n#elif defined(AO_HAVE_store_release)\n\t    \t    \t    AO_store_release(&x, (AO_t) 0);\n#else\n#error No store\n#endif\n#if defined(AO_HAVE_load)\n\t    \t    \t    z = AO_load(&x);\n#elif defined(AO_HAVE_load_acquire)\n\t    \t    \t    z = AO_load_acquire(&x);\n#else\n#error No load\n#endif\n#if defined(AO_HAVE_compare_and_swap_full)\n\t    \t    \t    z = AO_compare_and_swap_full(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap_release)\n\t    \t    \t    z = AO_compare_and_swap_release(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap_acquire)\n\t    \t    \t    z = AO_compare_and_swap_acquire(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap)\n\t    \t    \t    z = AO_compare_and_swap(&x, (AO_t) 0, (AO_t) 1);\n#else\n#error No compare_and_swap\n#endif\n\t    \t        ],\n\t    \t        [ethr_have_native_atomics=yes\n\t\t\t ethr_native_atomic_implementation=libatomic_ops\n\t    \t         ethr_have_libatomic_ops=yes])\n\t    AC_MSG_RESULT([$ethr_have_libatomic_ops])\n\t    if test $ethr_have_libatomic_ops = yes; then\n\t        AC_CHECK_SIZEOF(AO_t, ,\n\t    \t    \t        [\n\t    \t    \t    \t    #include <stdio.h>\n\t    \t    \t    \t    #include \"atomic_ops.h\"\n\t    \t    \t        ])\n\t        AC_DEFINE_UNQUOTED(ETHR_SIZEOF_AO_T, $ac_cv_sizeof_AO_t, [Define to the size of AO_t if libatomic_ops is used])\n\n\t        AC_DEFINE(ETHR_HAVE_LIBATOMIC_OPS, 1, [Define if you have libatomic_ops atomic operations])\n\t        if test \"x$with_libatomic_ops\" != \"xno\" && test \"x$with_libatomic_ops\" != \"x\"; then\n\t    \t    AC_DEFINE(ETHR_PREFER_LIBATOMIC_OPS_NATIVE_IMPLS, 1, [Define if you prefer libatomic_ops native ethread implementations])\n\t        fi\n\t        ETHR_DEFS=\"$ETHR_DEFS $libatomic_ops_include\"\n\t    elif test \"x$with_libatomic_ops\" != \"xno\" && test \"x$with_libatomic_ops\" != \"x\"; then\n\t        AC_MSG_ERROR([No usable libatomic_ops implementation found])\n\t    fi\n\n\t    case \"$host_cpu\" in\n\t      sparc | sun4u | sparc64 | sun4v)\n\t    \t    case \"$with_sparc_memory_order\" in\n\t    \t        \"TSO\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_TSO, 1, [Define if only run in Sparc TSO mode]);;\n\t    \t        \"PSO\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_PSO, 1, [Define if only run in Sparc PSO, or TSO mode]);;\n\t    \t        \"RMO\"|\"\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_RMO, 1, [Define if run in Sparc RMO, PSO, or TSO mode]);;\n\t    \t        *)\n\t    \t    \t    AC_MSG_ERROR([Unsupported Sparc memory order: $with_sparc_memory_order]);;\n\t    \t    esac\n\t\t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;; \n\t      i86pc | i*86 | x86_64 | amd64)\n\t    \t    if test \"$enable_x86_out_of_order\" = \"yes\"; then\n\t    \t    \t    AC_DEFINE(ETHR_X86_OUT_OF_ORDER, 1, [Define if x86/x86_64 out of order instructions should be synchronized])\n\t    \t    fi\n\t\t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      macppc | ppc | powerpc | \"Power Macintosh\")\n\t      \t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      tile)\n\t            ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      *)\n\t    \t    ;;\n\t    esac\n\n\tfi\n\n\ttest ethr_have_native_atomics = \"yes\" && ethr_have_native_spinlock=yes\n\n\tdnl Restore LIBS\n\tLIBS=$saved_libs\n\tdnl restore CPPFLAGS\n\tCPPFLAGS=$saved_cppflags\n\n\t;;\n    *)\n\t;;\nesac\n\nAC_MSG_CHECKING([whether default stack size should be modified])\nif test \"x$ethr_modified_default_stack_size\" != \"x\"; then\n\tAC_DEFINE_UNQUOTED(ETHR_MODIFIED_DEFAULT_STACK_SIZE, $ethr_modified_default_stack_size, [Define if you want to modify the default stack size])\n\tAC_MSG_RESULT([yes; to $ethr_modified_default_stack_size kilo words])\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nif test \"x$ETHR_THR_LIB_BASE\" != \"x\"; then\n\tETHR_DEFS=\"-DUSE_THREADS $ETHR_DEFS\"\n\tETHR_LIBS=\"-l$ethr_lib_name -lerts_internal_r $ETHR_X_LIBS\"\n\tETHR_LIB_NAME=$ethr_lib_name\nfi\n\nAC_CHECK_SIZEOF(void *)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_PTR, $ac_cv_sizeof_void_p, [Define to the size of pointers])\n\nAC_CHECK_SIZEOF(int)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_INT, $ac_cv_sizeof_int, [Define to the size of int])\nAC_CHECK_SIZEOF(long)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_LONG, $ac_cv_sizeof_long, [Define to the size of long])\nAC_CHECK_SIZEOF(long long)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_LONG_LONG, $ac_cv_sizeof_long_long, [Define to the size of long long])\nAC_CHECK_SIZEOF(__int64)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF___INT64, $ac_cv_sizeof___int64, [Define to the size of __int64])\nAC_CHECK_SIZEOF(__int128_t)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF___INT128_T, $ac_cv_sizeof___int128_t, [Define to the size of __int128_t])\n\n\ncase X$erl_xcomp_bigendian in\n    X) ;;\n    Xyes|Xno) ac_cv_c_bigendian=$erl_xcomp_bigendian;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_bigendian value: $erl_xcomp_bigendian]);;\nesac\n\nAC_C_BIGENDIAN\n\nif test \"$ac_cv_c_bigendian\" = \"yes\"; then\n    AC_DEFINE(ETHR_BIGENDIAN, 1, [Define if bigendian])\nfi\n\ncase X$erl_xcomp_double_middle_endian in\n    X) ;;\n    Xyes|Xno|Xunknown) ac_cv_c_double_middle_endian=$erl_xcomp_double_middle_endian;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_double_middle_endian value: $erl_xcomp_double_middle_endian]);;\nesac\n\nAC_C_DOUBLE_MIDDLE_ENDIAN\n\nETHR_X86_SSE2_ASM=no\ncase \"$GCC-$ac_cv_sizeof_void_p-$host_cpu\" in\n  yes-4-i86pc | yes-4-i*86 | yes-4-x86_64 | yes-4-amd64)\n    AC_MSG_CHECKING([for gcc sse2 asm support])\n    save_CFLAGS=\"$CFLAGS\"\n    CFLAGS=\"$CFLAGS -msse2\"\n    gcc_sse2_asm=no\n    AC_TRY_COMPILE([],\n\t[\n\t\tlong long x, *y;\n\t\t__asm__ __volatile__(\"movq %1, %0\\n\\t\" : \"=x\"(x) : \"m\"(*y) : \"memory\");\n\t],\n\t[gcc_sse2_asm=yes])\n    CFLAGS=\"$save_CFLAGS\"\n    AC_MSG_RESULT([$gcc_sse2_asm])\n    if test \"$gcc_sse2_asm\" = \"yes\"; then\n      AC_DEFINE(ETHR_GCC_HAVE_SSE2_ASM_SUPPORT, 1, [Define if you use a gcc that supports -msse2 and understand sse2 specific asm statements])\n      ETHR_X86_SSE2_ASM=yes\n    fi\n    ;;\n  *)\n    ;;\nesac\n\ncase \"$GCC-$host_cpu\" in\n  yes-i86pc | yes-i*86 | yes-x86_64 | yes-amd64)\n\n    if test $ac_cv_sizeof_void_p = 4; then\n       dw_cmpxchg=\"cmpxchg8b\"\n    else\n       dw_cmpxchg=\"cmpxchg16b\"\n    fi\n\n    gcc_dw_cmpxchg_asm=no\n    gcc_pic_dw_cmpxchg_asm=no\n    gcc_cflags_pic=no\n    gcc_cmpxchg8b_pic_no_clobber_ebx=no\n    gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage=no\n\n    save_CFLAGS=\"$CFLAGS\"\n\n    # Check if it works out of the box using passed CFLAGS\n    # and with -fPIC added to CFLAGS if the passed CFLAGS\n    # doesn't trigger position independent code\n    pic_cmpxchg=unknown\n    while true; do\n\n        case $pic_cmpxchg in\n\t  yes) pic_text=\"pic \";;\n\t  *) pic_text=\"\";;\n\tesac\n\n\tAC_MSG_CHECKING([for gcc $pic_text$dw_cmpxchg plain asm support])    \n\n\tplain_cmpxchg=no\n    \tAC_TRY_COMPILE([],\n\t[\n    char xchgd;\n    long new[2], xchg[2], *p;\t\t  \n    __asm__ __volatile__(\n#if ETHR_SIZEOF_PTR == 4\n\t\"lock; cmpxchg8b %0\\n\\t\"\n#else\n\t\"lock; cmpxchg16b %0\\n\\t\"\n#endif\n\t\"setz %3\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=q\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"c\"(new[1]), \"b\"(new[0])\n\t: \"cc\", \"memory\");\n\t],\n\t[plain_cmpxchg=yes])\n\n\tAC_MSG_RESULT([$plain_cmpxchg])\n\n\tif test $pic_cmpxchg = yes; then\n\t   gcc_pic_dw_cmpxchg_asm=$plain_cmpxchg\n\t   break\n\tfi\n\n\tgcc_dw_cmpxchg_asm=$plain_cmpxchg\n\n    \t# If not already compiling to position independent\n\t# code add -fPIC to CFLAGS and do it again. This\n\t# since we want also want to know how to compile\n\t# to position independent code since this might\n\t# cause problems with the use of the EBX register\n\t# as input to the asm on 32-bit x86 and old gcc\n\t# compilers (gcc vsn < 5).\n\n    \tAC_TRY_COMPILE([],\n\t[\n#if !defined(__PIC__) || !__PIC__\n#  error no pic\n#endif\n\t],\n\t[pic_cmpxchg=yes\n\t gcc_cflags_pic=yes],\n\t[pic_cmpxchg=no])\n\n\tif test $pic_cmpxchg = yes; then\n\t   gcc_pic_dw_cmpxchg_asm=$gcc_dw_cmpxchg_asm\n\t   break\n\tfi\n\n\tCFLAGS=\"$save_CFLAGS -fPIC\"\n\tpic_cmpxchg=yes\n\n    done\n\n    if test $gcc_pic_dw_cmpxchg_asm = no && test $ac_cv_sizeof_void_p = 4; then\n\n      AC_MSG_CHECKING([for gcc pic cmpxchg8b asm support with EBX workaround])\n\n      # Check if we can work around it by managing the ebx\n      # register explicitly in the asm...\n\n      AC_TRY_COMPILE([],\n\t[\n    char xchgd;\n    long new[2], xchg[2], *p;\t\t  \n    __asm__ __volatile__(\n\t\"pushl %%ebx\\n\\t\"\n\t\"movl %8, %%ebx\\n\\t\"\n\t\"lock; cmpxchg8b %0\\n\\t\"\n\t\"setz %3\\n\\t\"\n\t\"popl %%ebx\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=q\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"c\"(new[1]), \"r\"(new[0])\n\t: \"cc\", \"memory\");\n\t],\n\t[gcc_pic_dw_cmpxchg_asm=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx=yes])     \n\n      AC_MSG_RESULT([$gcc_pic_dw_cmpxchg_asm])\n\n      if test $gcc_pic_dw_cmpxchg_asm = no; then\n\n      \tAC_MSG_CHECKING([for gcc pic cmpxchg8b asm support with EBX and register shortage workarounds])\n        # If no optimization is enabled we sometimes get a\n\t# register shortage. Check if we can work around\n\t# this...\n\n      \tAC_TRY_COMPILE([],\n\t  [\n      char xchgd;\n      long new[2], xchg[2], *p;\n      __asm__ __volatile__(\n\t\"pushl %%ebx\\n\\t\"\n\t\"movl (%7), %%ebx\\n\\t\"\n\t\"movl 4(%7), %%ecx\\n\\t\"\n\t\"lock; cmpxchg8b %0\\n\\t\"\n\t\"setz %3\\n\\t\"\n\t\"popl %%ebx\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=c\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"r\"(new)\n\t: \"cc\", \"memory\");\n\n\t],\n\t[gcc_pic_dw_cmpxchg_asm=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage=yes])\n\n        AC_MSG_RESULT([$gcc_pic_dw_cmpxchg_asm])\n      fi\n\n      if test $gcc_cflags_pic = yes; then\n        gcc_dw_cmpxchg_asm=$gcc_pic_dw_cmpxchg_asm\n      fi\n \n   fi\n\n    CFLAGS=\"$save_CFLAGS\"\n\n    if test \"$gcc_cmpxchg8b_pic_no_clobber_ebx\" = \"yes\"; then\n      AC_DEFINE(ETHR_CMPXCHG8B_PIC_NO_CLOBBER_EBX, 1, [Define if gcc wont let you clobber ebx with cmpxchg8b and position independent code])\n    fi\n    if test \"$gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage\" = \"yes\"; then\n      AC_DEFINE(ETHR_CMPXCHG8B_REGISTER_SHORTAGE, 1, [Define if you get a register shortage with cmpxchg8b and position independent code])\n    fi\n    if test \"$gcc_dw_cmpxchg_asm\" = \"yes\"; then\n      AC_DEFINE(ETHR_GCC_HAVE_DW_CMPXCHG_ASM_SUPPORT, 1, [Define if you use a gcc that supports the double word cmpxchg instruction])\n    fi;;\n  *)\n    ;;\nesac\n\nAC_DEFINE(ETHR_HAVE_ETHREAD_DEFINES, 1, \\\n[Define if you have all ethread defines])\n\nAC_SUBST(ETHR_X_LIBS)\nAC_SUBST(ETHR_LIBS)\nAC_SUBST(ETHR_LIB_NAME)\nAC_SUBST(ETHR_DEFS)\nAC_SUBST(ETHR_THR_LIB_BASE)\nAC_SUBST(ETHR_THR_LIB_BASE_DIR)\nAC_SUBST(ETHR_X86_SSE2_ASM)\n\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl ERL_TIME_CORRECTION\ndnl\ndnl Check for primitives that can be used for implementing\ndnl erts_os_monotonic_time() and erts_os_system_time()\ndnl\n\nAC_DEFUN(ERL_TIME_CORRECTION,\n[\n\nAC_ARG_WITH(clock-resolution,\nAS_HELP_STRING([--with-clock-resolution=high|low|default],\n               [specify wanted clock resolution]))\n\nAC_ARG_WITH(clock-gettime-realtime-id,\nAS_HELP_STRING([--with-clock-gettime-realtime-id=CLOCKID],\n               [specify clock id to use with clock_gettime() for realtime time)]))\n\nAC_ARG_WITH(clock-gettime-monotonic-id,\nAS_HELP_STRING([--with-clock-gettime-monotonic-id=CLOCKID],\n               [specify clock id to use with clock_gettime() for monotonic time)]))\n\nAC_ARG_ENABLE(prefer-elapsed-monotonic-time-during-suspend,\nAS_HELP_STRING([--enable-prefer-elapsed-monotonic-time-during-suspend],\n               [Prefer an OS monotonic time source with elapsed time during suspend])\nAS_HELP_STRING([--disable-prefer-elapsed-monotonic-time-during-suspend],\n               [Do not prefer an OS monotonic time source with elapsed time during suspend]),\n[ case \"$enableval\" in\n    yes) prefer_elapsed_monotonic_time_during_suspend=yes ;;\n    *)  prefer_elapsed_monotonic_time_during_suspend=no ;;\n  esac ], prefer_elapsed_monotonic_time_during_suspend=no)\n\nAC_ARG_ENABLE(gettimeofday-as-os-system-time,\n\t      AS_HELP_STRING([--enable-gettimeofday-as-os-system-time],\n                             [Force usage of gettimeofday() for OS system time]),\n[ case \"$enableval\" in\n    yes) force_gettimeofday_os_system_time=yes ;;\n    *)  force_gettimeofday_os_system_time=no ;;\n  esac ], force_gettimeofday_os_system_time=no)\n\ncase \"$with_clock_resolution\" in\n   \"\"|no|yes)\n     with_clock_resolution=default;;\n   high|low|default)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid wanted clock resolution: $with_clock_resolution])\n     ;;\nesac\n\nif test \"$force_gettimeofday_os_system_time\" = \"yes\"; then\n\n  AC_CHECK_FUNCS([gettimeofday])\n  if test \"$ac_cv_func_gettimeofday\" = \"yes\"; then\n    AC_DEFINE(OS_SYSTEM_TIME_GETTIMEOFDAY,  [1], [Define if you want to implement erts_os_system_time() using gettimeofday()])\n  else\n    AC_MSG_ERROR([No gettimeofday() available])\n  fi\n\nelse # $force_gettimeofday_os_system_time != yes\n\ncase \"$with_clock_gettime_realtime_id\" in\n   \"\"|no)\n     with_clock_gettime_realtime_id=no\n     ;;\n   CLOCK_*CPUTIME*)\n     AC_MSG_ERROR([Invalid clock_gettime() realtime clock id: Refusing to use the cputime clock id $with_clock_gettime_realtime_id as realtime clock id])\n     ;;\n   CLOCK_MONOTONIC*|CLOCK_BOOTTIME*|CLOCK_UPTIME*|CLOCK_HIGHRES*)\n     AC_MSG_ERROR([Invalid clock_gettime() realtime clock id: Refusing to use the monotonic clock id $with_clock_gettime_realtime_id as realtime clock id])\n     ;;\n   CLOCK_*)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid clock_gettime() clock id: $with_clock_gettime_realtime_id])\n     ;;\nesac\n\ncase \"$with_clock_resolution-$with_clock_gettime_realtime_id\" in\n  high-no)\n\tERL_WALL_CLOCK(high_resolution);;\n  low-no)\n\tERL_WALL_CLOCK(low_resolution);;\n  default-no)\n\tERL_WALL_CLOCK(default_resolution);;\n  *)\n\tERL_WALL_CLOCK(custom_resolution, $with_clock_gettime_realtime_id);;\nesac\n\ncase \"$erl_wall_clock_func-$erl_wall_clock_id-$with_clock_gettime_realtime_id\" in\n  *-*-no)\n    ;;\n  clock_gettime-$with_clock_gettime_realtime_id-$with_clock_gettime_realtime_id)\n    ;;\n  *)\n    AC_MSG_ERROR([$with_clock_gettime_realtime_id as clock id to clock_gettime() doesn't compile])\n    ;;\nesac\n\ncase $erl_wall_clock_func in\n  none)\n    AC_MSG_ERROR([No wall clock source found])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(OS_SYSTEM_TIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_system_time() using mach clock_get_time()])\n    ;;\n  clock_gettime)\n    AC_DEFINE(OS_SYSTEM_TIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_system_time() using clock_gettime()])\n    ;;\n  gettimeofday)\n    AC_DEFINE(OS_SYSTEM_TIME_GETTIMEOFDAY,  [1], [Define if you want to implement erts_os_system_time() using gettimeofday()])\n    ;;\n  *)\n    ;;\nesac\n\nif test \"x$erl_wall_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(WALL_CLOCK_ID_STR, [\"$erl_wall_clock_id\"], [Define as a string of wall clock id to use])\n    AC_DEFINE_UNQUOTED(WALL_CLOCK_ID, [$erl_wall_clock_id], [Define to wall clock id to use])\nfi\n\nfi # $force_gettimeofday_os_system_time != yes\n\ncase \"$with_clock_gettime_monotonic_id\" in\n   \"\"|no)\n     with_clock_gettime_monotonic_id=no\n     ;;\n   CLOCK_*CPUTIME*)\n     AC_MSG_ERROR([Invalid clock_gettime() monotonic clock id: Refusing to use the cputime clock id $with_clock_gettime_monotonic_id as monotonic clock id])\n     ;;\n   CLOCK_REALTIME*|CLOCK_TAI*)\n     AC_MSG_ERROR([Invalid clock_gettime() monotonic clock id: Refusing to use the realtime clock id $with_clock_gettime_monotonic_id as monotonic clock id])\n     ;;\n   CLOCK_*)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid clock_gettime() clock id: $with_clock_gettime_monotonic_id])\n     ;;\nesac\n\ncase \"$with_clock_resolution-$with_clock_gettime_monotonic_id\" in\n  high-no)\n\tERL_MONOTONIC_CLOCK(high_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  low-no)\n\tERL_MONOTONIC_CLOCK(low_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  default-no)\n\tERL_MONOTONIC_CLOCK(default_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  *)\n\tERL_MONOTONIC_CLOCK(custom_resolution, $with_clock_gettime_monotonic_id, $prefer_elapsed_monotonic_time_during_suspend);;\nesac\n\ncase \"$erl_monotonic_clock_func-$erl_monotonic_clock_id-$with_clock_gettime_monotonic_id\" in\n  *-*-no)\n    ;;\n  clock_gettime-$with_clock_gettime_monotonic_id-$with_clock_gettime_monotonic_id)\n    ;;\n  *)\n    AC_MSG_ERROR([$with_clock_gettime_monotonic_id as clock id to clock_gettime() doesn't compile])\n    ;;\nesac\n\ncase $erl_monotonic_clock_func in\n  times)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_TIMES, [1], [Define if you want to implement erts_os_monotonic_time() using times()])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_monotonic_time() using mach clock_get_time()])\n    ;;\n  clock_gettime)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_monotonic_time() using clock_gettime()])\n    ;;\n  gethrtime)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_GETHRTIME,  [1], [Define if you want to implement erts_os_monotonic_time() using gethrtime()])\n    ;;\n  *)\n    ;;\nesac\n\nif test $erl_corrected_monotonic_clock = yes; then\n  AC_DEFINE(ERTS_HAVE_CORRECTED_OS_MONOTONIC_TIME, [1], [Define if OS monotonic clock is corrected])\nfi\n\nif test $erl_monotonic_clock_low_resolution = yes; then\n  AC_DEFINE(ERTS_HAVE_LOW_RESOLUTION_OS_MONOTONIC_LOW, [1], [Define if you have a low resolution OS monotonic clock])\nfi\n\nxrtlib=\nif test \"$erl_monotonic_clock_lib\" != \"\"; then\n   xrtlib=\"$erl_monotonic_clock_lib\"\nfi\nif test \"$erl_wall_clock_lib\" != \"\"; then\n   xrtlib=\"$erl_wall_clock_lib\"\nfi\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(MONOTONIC_CLOCK_ID_STR, [\"$erl_monotonic_clock_id\"], [Define as a string of monotonic clock id to use])\n    AC_DEFINE_UNQUOTED(MONOTONIC_CLOCK_ID, [$erl_monotonic_clock_id], [Define to monotonic clock id to use])\nfi\n\nif test $erl_cv_clock_gettime_monotonic_raw = yes; then\n  AC_DEFINE(HAVE_CLOCK_GETTIME_MONOTONIC_RAW, [1], [Define if you have clock_gettime(CLOCK_MONOTONIC_RAW, _)])\nfi\n\nERL_MONOTONIC_CLOCK(high_resolution, undefined, no)\n\ncase $$erl_monotonic_clock_low_resolution-$erl_monotonic_clock_func in\n  no-mach_clock_get_time)\n    monotonic_hrtime=yes    \n    AC_DEFINE(SYS_HRTIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_hrtime() using mach clock_get_time()])\n    ;;\n  no-clock_gettime)\n    monotonic_hrtime=yes\n    AC_DEFINE(SYS_HRTIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_hrtime() using clock_gettime()])\n    ;;\n  no-gethrtime)\n    monotonic_hrtime=yes\n    AC_DEFINE(SYS_HRTIME_USING_GETHRTIME,  [1], [Define if you want to implement erts_os_hrtime() using gethrtime()])\n    ;;\n  *)\n    monotonic_hrtime=no\n    ;;\nesac\n\nif test $monotonic_hrtime = yes; then\n    AC_DEFINE(HAVE_MONOTONIC_ERTS_SYS_HRTIME, [1], [Define if you have a monotonic erts_os_hrtime() implementation])\nfi\n\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(HRTIME_CLOCK_ID_STR, [\"$erl_monotonic_clock_id\"], [Define as a string of monotonic clock id to use])\n    AC_DEFINE_UNQUOTED(HRTIME_CLOCK_ID, [$erl_monotonic_clock_id], [Define to monotonic clock id to use])\nfi\n\n\ndnl\ndnl Check if gethrvtime is working, and if to use procfs ioctl\ndnl or (yet to be written) write to the procfs ctl file.\ndnl\n\nAC_MSG_CHECKING([if gethrvtime works and how to use it])\nAC_TRY_RUN([\n/* gethrvtime procfs ioctl test */\n/* These need to be undef:ed to not break activation of\n * micro level process accounting on /proc/self \n */\n#ifdef _LARGEFILE_SOURCE\n#  undef _LARGEFILE_SOURCE\n#endif\n#ifdef _FILE_OFFSET_BITS\n#  undef _FILE_OFFSET_BITS\n#endif\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/signal.h>\n#include <sys/fault.h>\n#include <sys/syscall.h>\n#include <sys/procfs.h>\n#include <fcntl.h>\n\nint main() {\n    long msacct = PR_MSACCT;\n    int fd;\n    long long start, stop;\n    int i;\n    pid_t pid = getpid();\n    char proc_self[30] = \"/proc/\";\n\n    sprintf(proc_self+strlen(proc_self), \"%lu\", (unsigned long) pid);\n    if ( (fd = open(proc_self, O_WRONLY)) == -1)\n\texit(1);\n    if (ioctl(fd, PIOCSET, &msacct) < 0)\n\texit(2);\n    if (close(fd) < 0)\n\texit(3);\n    start = gethrvtime();\n    for (i = 0; i < 100; i++)\n\tstop = gethrvtime();\n    if (start == 0)\n\texit(4);\n    if (start == stop)\n\texit(5);\n    exit(0); return 0;\n}\n],\nerl_gethrvtime=procfs_ioctl,\nerl_gethrvtime=false,\n[\ncase X$erl_xcomp_gethrvtime_procfs_ioctl in\n    X)\n\terl_gethrvtime=cross;;\n    Xyes|Xno)\n\tif test $erl_xcomp_gethrvtime_procfs_ioctl = yes; then\n\t    erl_gethrvtime=procfs_ioctl\n\telse\n\t    erl_gethrvtime=false\n\tfi;;\n    *)\n\tAC_MSG_ERROR([Bad erl_xcomp_gethrvtime_procfs_ioctl value: $erl_xcomp_gethrvtime_procfs_ioctl]);;\nesac\n])\n\nLIBRT=$xrtlib\ncase $erl_gethrvtime in\n  procfs_ioctl)\n\tAC_DEFINE(HAVE_GETHRVTIME_PROCFS_IOCTL,[1],\n\t\t[define if gethrvtime() works and uses ioctl() to /proc/self])\n\tAC_MSG_RESULT(uses ioctl to procfs)\n\t;;\n  *)\n\tif test $erl_gethrvtime = cross; then\n\t    erl_gethrvtime=false\n\t    AC_MSG_RESULT(cross)\n\t    AC_MSG_WARN([result 'not working' guessed because of cross compilation])\n\telse\n\t    AC_MSG_RESULT(not working)\n\tfi\n\n\tdnl\n\tdnl Check if clock_gettime (linux) is working\n\tdnl\n\n\tAC_MSG_CHECKING([if clock_gettime can be used to get thread CPU time])\n\tsave_libs=$LIBS\n\tLIBS=\"-lrt\"\n\tAC_TRY_RUN([\n\t#include <stdlib.h>\n\t#include <unistd.h>\n\t#include <string.h>\n\t#include <stdio.h>\n\t#include <time.h>\n\tint main() {\n\t    long long start, stop;\n\t    int i;\n\t    struct timespec tp;\n\n\t    if (clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp) < 0)\n\t      exit(1);\n\t    start = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;\n\t    for (i = 0; i < 100; i++)\n\t      clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp);\n\t    stop = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;\n\t    if (start == 0)\n\t      exit(4);\n\t    if (start == stop)\n\t      exit(5);\n\t    exit(0); return 0;\n\t  }\n\t],\n\terl_clock_gettime_cpu_time=yes,\n\terl_clock_gettime_cpu_time=no,\n\t[\n\tcase X$erl_xcomp_clock_gettime_cpu_time in\n\t    X) erl_clock_gettime_cpu_time=cross;;\n\t    Xyes|Xno) erl_clock_gettime_cpu_time=$erl_xcomp_clock_gettime_cpu_time;;\n\t    *) AC_MSG_ERROR([Bad erl_xcomp_clock_gettime_cpu_time value: $erl_xcomp_clock_gettime_cpu_time]);;\n\tesac\n\t])\n\tLIBS=$save_libs\n\tAC_MSG_RESULT($erl_clock_gettime_cpu_time)\n\tcase $erl_clock_gettime_cpu_time in\n\t\tyes)\n\t\t\tAC_DEFINE(HAVE_CLOCK_GETTIME_CPU_TIME,[],\n\t\t\t\t  [define if clock_gettime() works for getting thread time])\n\t\t\tLIBRT=-lrt\n\t\t\t;;\n\t\tcross)\n\t\t\terl_clock_gettime_cpu_time=no\n\t\t\tAC_MSG_WARN([result no guessed because of cross compilation])\n\t\t\t;;\n\t\t*)\n\t\t\t;;\n\tesac\n\t;;\nesac\nAC_SUBST(LIBRT)\n])dnl\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_TRY_ENABLE_CFLAG\ndnl\ndnl\ndnl Tries a CFLAG and sees if it can be enabled without compiler errors\ndnl $1: textual cflag to add\ndnl $2: variable to store the modified CFLAG in\ndnl Usage example LM_TRY_ENABLE_CFLAG([-Werror=return-type], [CFLAGS])\ndnl\ndnl\nAC_DEFUN([LM_TRY_ENABLE_CFLAG], [\n    AC_MSG_CHECKING([if we can add $1 to $2 (via CFLAGS)])\n    saved_CFLAGS=$CFLAGS;\n    CFLAGS=\"$1 $$2\";\n    AC_TRY_COMPILE([],[return 0;],can_enable_flag=true,can_enable_flag=false)\n    CFLAGS=$saved_CFLAGS;\n    if test \"X$can_enable_flag\" = \"Xtrue\"; then\n        AC_MSG_RESULT([yes])\n        AS_VAR_SET($2, \"$1 $$2\")\n    else\n        AC_MSG_RESULT([no])\n    fi\n])\n\nAC_DEFUN([LM_CHECK_ENABLE_CFLAG], [\n    AC_MSG_CHECKING([whether $CC accepts $1...])\n    saved_CFLAGS=$CFLAGS;\n    CFLAGS=\"$1 $CFLAGS\";\n    AC_TRY_COMPILE([],[return 0;],can_enable_flag=true,can_enable_flag=false)\n    CFLAGS=$saved_CFLAGS;\n    if test \"X$can_enable_flag\" = \"Xtrue\"; then\n        AS_VAR_SET($2, true)\n        AC_MSG_RESULT([yes])\n    else\n        AS_VAR_SET($2, false)\n        AC_MSG_RESULT([no])\n    fi\n])\n\ndnl ERL_TRY_LINK_JAVA(CLASSES, FUNCTION-BODY\ndnl                   [ACTION_IF_FOUND [, ACTION-IF-NOT-FOUND]])\ndnl Freely inspired by AC_TRY_LINK. (Maybe better to create a \ndnl AC_LANG_JAVA instead...)\nAC_DEFUN(ERL_TRY_LINK_JAVA,\n[java_link='$JAVAC conftest.java 1>&AC_FD_CC'\nchangequote(, )dnl\ncat > conftest.java <<EOF\n$1\nclass conftest { public static void main(String[] args) {\n   $2\n   ; return; }}\nEOF\nchangequote([, ])dnl\nif AC_TRY_EVAL(java_link) && test -s conftest.class; then\n   ifelse([$3], , :, [rm -rf conftest*\n   $3])\nelse\n   echo \"configure: failed program was:\" 1>&AC_FD_CC\n   cat conftest.java 1>&AC_FD_CC\n   echo \"configure: PATH was $PATH\" 1>&AC_FD_CC\nifelse([$4], , , [  rm -rf conftest*\n  $4\n])dnl\nfi\nrm -f conftest*])\n#define UNSAFE_MASK  0xc0000000 /* Mask for bits that must be constant */\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_HARDWARE_ARCH\ndnl\ndnl Determine target hardware in ARCH\ndnl\nAC_DEFUN([LM_HARDWARE_ARCH], [\n    AC_MSG_CHECKING([target hardware architecture])\n    if test \"x$host_alias\" != \"x\" -a \"x$host_cpu\" != \"x\"; then\n        chk_arch_=$host_cpu\n    else\n        chk_arch_=`uname -m`\n    fi\n\n    case $chk_arch_ in\n    sun4u)\tARCH=ultrasparc;;\n    sparc64)\tARCH=sparc64;;\n    sun4v)\tARCH=ultrasparc;;\n    i86pc)\tARCH=x86;;\n    i386)\tARCH=x86;;\n    i486)\tARCH=x86;;\n    i586)\tARCH=x86;;\n    i686)\tARCH=x86;;\n    x86_64)\tARCH=amd64;;\n    amd64)\tARCH=amd64;;\n    macppc)\tARCH=ppc;;\n    powerpc)\tARCH=ppc;;\n    ppc)\tARCH=ppc;;\n    ppc64)\tARCH=ppc64;;\n    ppc64le)\tARCH=ppc64le;;\n    \"Power Macintosh\")\tARCH=ppc;;\n    armv5b)\tARCH=arm;;\n    armv5teb)\tARCH=arm;;\n    armv5tel)\tARCH=arm;;\n    armv5tejl)\tARCH=arm;;\n    armv6l)\tARCH=arm;;\n    armv6hl)\tARCH=arm;;\n    armv7l)\tARCH=arm;;\n    armv7hl)\tARCH=arm;;\n    tile)\tARCH=tile;;\n    e2k)        ARCH=e2k;;\n    *)\t \tARCH=noarch;;\n    esac\n    AC_MSG_RESULT($ARCH)\n\n    dnl\n    dnl Convert between x86 and amd64 based on the compiler's mode.\n    dnl Ditto between ultrasparc and sparc64.\n    dnl\n    AC_MSG_CHECKING(whether compilation mode forces ARCH adjustment)\n    case \"$ARCH-$ac_cv_sizeof_void_p\" in\n    x86-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=x86 to ARCH=amd64)\n\tARCH=amd64\n\t;;\n    amd64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=amd64 to ARCH=x86)\n\tARCH=x86\n\t;;\n    ultrasparc-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ultrasparc to ARCH=sparc64)\n\tARCH=sparc64\n\t;;\n    sparc64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=sparc64 to ARCH=ultrasparc)\n\tARCH=ultrasparc\n\t;;\n    ppc64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ppc64 to ARCH=ppc)\n\tARCH=ppc\n\t;;\n    ppc-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ppc to ARCH=ppc64)\n\tARCH=ppc64\n\t;;\n    arm-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=arm to ARCH=noarch)\n\tARCH=noarch\n\t;;\n    *)\n\tAC_MSG_RESULT(no: ARCH is $ARCH)\n\t;;\n    esac\n\n    AC_SUBST(ARCH)\n])\n\ndnl\ndnl--------------------------------------------------------------------\ndnl Dynamic Erlang Drivers\ndnl\ndnl Linking to produce dynamic Erlang drivers to be loaded by Erlang's\ndnl Dynamic Driver Loader and Linker (DDLL). Below the prefix DED is an\ndnl abbreviation for `Dynamic Erlang Driver'.\ndnl\ndnl For DED we need something quite sloppy, which allows undefined references \ndnl (notably driver functions) in the resulting shared library. \ndnl Example of Makefile rule (and settings of macros):\ndnl\ndnl LIBS = @LIBS@\ndnl LD = @DED_LD@\ndnl LDFLAGS = @DED_LDFLAGS@\ndnl soname = @ldsoname@\ndnl\ndnl my_drv.so:   my_drv.o my_utils.o\ndnl              $(LD) $(LDFLAGS) $(soname) $@ -o $@ $^ -lc $(LIBS)\ndnl\ndnl--------------------------------------------------------------------\ndnl\n\nAC_DEFUN(ERL_DED,\n\t[\n\nUSER_LD=$LD\nUSER_LDFLAGS=\"$LDFLAGS\"\n\nLM_CHECK_THR_LIB\n\nDED_CC=$CC\nDED_GCC=$GCC\n\nDED_CFLAGS=\nDED_OSTYPE=unix\ncase $host_os in\n     linux*)\n\tDED_CFLAGS=\"-D_GNU_SOURCE\" ;;\n     win32)\n\tDED_CFLAGS=\"-D_WIN32_WINNT=0x0600 -DWINVER=0x0600\"\n        DED_OSTYPE=win32 ;;\n     *)\n        ;;\nesac\n\n\nDED_WARN_FLAGS=\"-Wall -Wstrict-prototypes\"\ncase \"$host_cpu\" in\n  tile*)\n    # tile-gcc is a bit stricter with -Wmissing-prototypes than other gccs,\n    # and too strict for our taste.\n    ;;\n  *)\n    DED_WARN_FLAGS=\"$DED_WARN_FLAGS -Wmissing-prototypes\";;\nesac\n  \nLM_TRY_ENABLE_CFLAG([-Wdeclaration-after-statement], [DED_WARN_FLAGS])\n\nLM_TRY_ENABLE_CFLAG([-Werror=return-type], [DED_WERRORFLAGS])\nLM_TRY_ENABLE_CFLAG([-Werror=implicit], [DED_WERRORFLAGS])\nLM_TRY_ENABLE_CFLAG([-Werror=undef], [DED_WERRORFLAGS])\n\nDED_SYS_INCLUDE=\"-I${ERL_TOP}/erts/emulator/beam -I${ERL_TOP}/erts/include -I${ERL_TOP}/erts/include/$host -I${ERL_TOP}/erts/include/internal -I${ERL_TOP}/erts/include/internal/$host -I${ERL_TOP}/erts/emulator/sys/$DED_OSTYPE -I${ERL_TOP}/erts/emulator/sys/common\"\nDED_INCLUDE=$DED_SYS_INCLUDE\n\nif test \"$THR_DEFS\" = \"\"; then\n    DED_THR_DEFS=\"-D_THREAD_SAFE -D_REENTRANT\"\nelse\n    DED_THR_DEFS=\"$THR_DEFS\"\nfi\n# DED_EMU_THR_DEFS=$EMU_THR_DEFS\nDED_CFLAGS=\"$CFLAGS $CPPFLAGS $DED_CFLAGS\"\nif test \"x$GCC\" = xyes; then\n    DED_STATIC_CFLAGS=\"$DED_CFLAGS\"\n    DED_CFLAGS=\"$DED_CFLAGS -fPIC\"\nfi\n\nDED_EXT=so\ncase $host_os in\n    win32) DED_EXT=dll;;\n    darwin*)\n\tDED_CFLAGS=\"$DED_CFLAGS -fno-common\"\n\tDED_STATIC_CFLAGS=\"$DED_STATIC_CFLAGS -fno-common\";;\n    *)\n\t;;\nesac\n\nDED_STATIC_CFLAGS=\"$DED_STATIC_CFLAGS -DSTATIC_ERLANG_NIF -DSTATIC_ERLANG_DRIVER\"\n\nif test \"$CFLAG_RUNTIME_LIBRARY_PATH\" = \"\"; then\n\n  CFLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-R\"\n  case $host_os in\n    darwin*)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n    win32)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n    osf*)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-rpath,\"\n\t;;\n    *)\n\t;;\n  esac\n\nfi\n\n# If DED_LD is set in environment, we expect all DED_LD* variables\n# to be specified (cross compiling)\nif test \"x$DED_LD\" = \"x\"; then\n\nDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-R\"\ncase $host_os in\n\twin32)\n\t\tDED_LD=\"ld.sh\"\n\t\tDED_LDFLAGS=\"-dll\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n\tsolaris2*|sysv4*)\n\t\tDED_LDFLAGS=\"-G\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-64 $DED_LDFLAGS\"\n\t\tfi\n\t;;\n\taix4*)\n\t\tDED_LDFLAGS=\"-G -bnoentry -bexpall\"\n\t;;\n\tfreebsd2*)\n\t\t# Non-ELF GNU linker\n\t\tDED_LDFLAGS=\"-Bshareable\"\n\t;;\n\tdarwin*)\n\t\t# Mach-O linker: a shared lib and a loadable\n\t\t# object file is not the same thing.\n\t\tDED_LDFLAGS=\"-bundle -bundle_loader ${ERL_TOP}/bin/$host/beam.smp\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t  DED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\telse\n\t\t  if test X${enable_m32_build} = Xyes; then\n\t\t    DED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\t  else\n\t\t    AC_CHECK_SIZEOF(void *)\n\t\t    case \"$ac_cv_sizeof_void_p\" in\n\t\t      8)\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\";;\n\t\t      *)\n\t\t        ;;\n\t\t    esac\n\t\t  fi\n\t\tfi\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t;;\n\tlinux*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared -Wl,-Bsymbolic\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\tfi;\n\t\tif test X${enable_m32_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\tfi\n\t;;\t\n\tfreebsd*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\tfi;\n\t\tif test X${enable_m32_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\tfi\n\t;;\t\n\topenbsd*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared\"\n\t;;\n\tosf*)\n\t\t# NOTE! Whitespace after -rpath is important.\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-rpath \"\n\t\tDED_LDFLAGS=\"-shared -expect_unresolved '*'\"\n\t;;\n\t*)\n\t\t# assume GNU linker and ELF\n\t\tDED_LDFLAGS=\"-shared\"\n\t\t# GNU linker has no option for 64bit build, should not propagate -m64\n\t;;\nesac\n\nif test \"$DED_LD\" = \"\" && test \"$USER_LD\" != \"\"; then\n    DED_LD=\"$USER_LD\"\n    DED_LDFLAGS=\"$USER_LDFLAGS $DED_LDFLAGS\"\nfi\n\nDED_LIBS=$LIBS\n\nfi # \"x$DED_LD\" = \"x\"\n\nAC_CHECK_TOOL(DED_LD, ld, false)\ntest \"$DED_LD\" != \"false\" || AC_MSG_ERROR([No linker found])\n\nAC_MSG_CHECKING(for static compiler flags)\nDED_STATIC_CFLAGS=\"$DED_WERRORFLAGS $DED_WFLAGS $DED_THR_DEFS $DED_STATIC_CFLAGS\"\nAC_MSG_RESULT([$DED_STATIC_CFLAGS])\nAC_MSG_CHECKING(for basic compiler flags for loadable drivers)\nDED_BASIC_CFLAGS=$DED_CFLAGS\nAC_MSG_RESULT([$DED_CFLAGS])\nAC_MSG_CHECKING(for compiler flags for loadable drivers)\nDED_CFLAGS=\"$DED_WERRORFLAGS $DED_WARN_FLAGS $DED_THR_DEFS $DED_CFLAGS\"\nAC_MSG_RESULT([$DED_CFLAGS])\nAC_MSG_CHECKING(for linker for loadable drivers)\nAC_MSG_RESULT([$DED_LD])\nAC_MSG_CHECKING(for linker flags for loadable drivers)\nAC_MSG_RESULT([$DED_LDFLAGS])\nAC_MSG_CHECKING(for 'runtime library path' linker flag)\nif test \"x$DED_LD_FLAG_RUNTIME_LIBRARY_PATH\" != \"x\"; then\n\tAC_MSG_RESULT([$DED_LD_FLAG_RUNTIME_LIBRARY_PATH])\nelse\n\tAC_MSG_RESULT([not found])\nfi\n\nAC_SUBST(DED_CC)\nAC_SUBST(DED_GCC)\nAC_SUBST(DED_EXT)\nAC_SUBST(DED_SYS_INCLUDE)\nAC_SUBST(DED_INCLUDE)\nAC_SUBST(DED_BASIC_CFLAGS)\nAC_SUBST(DED_CFLAGS)\nAC_SUBST(DED_STATIC_CFLAGS)\nAC_SUBST(DED_WARN_FLAGS)\nAC_SUBST(DED_WERRORFLAGS)\nAC_SUBST(DED_LD)\nAC_SUBST(DED_LDFLAGS)\nAC_SUBST(DED_LD_FLAG_RUNTIME_LIBRARY_PATH)\nAC_SUBST(DED_LIBS)\nAC_SUBST(DED_THR_DEFS)\nAC_SUBST(DED_OSTYPE)\n\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/c_src/wxe_gl.cpp": "/*\n * %CopyrightBegin%\n *\n * Copyright Ericsson AB 2008-2016. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * %CopyrightEnd%\n */\n\n#include <stdio.h>\n#include <string.h>\n#ifndef _WIN32\n#include <dlfcn.h>\n#else\n#include <windows.h>\n#endif\n#include \"wxe_impl.h\"\n#include \"wxe_return.h\"\n#include \"wxe_gl.h\"\n\n/* ****************************************************************************\n * Opengl context management *\n * ****************************************************************************/\n\nint erl_gl_initiated = FALSE;\nErlDrvTermData gl_active = 0;\nwxeGLC glc;\n\ntypedef void (*WXE_GL_DISPATCH) (int, char *, ErlDrvPort, ErlDrvTermData, char **, int *);\nWXE_GL_DISPATCH wxe_gl_dispatch;\n\n#ifdef _WIN32\n#define RTLD_LAZY 0\ntypedef HMODULE DL_LIB_P;\nvoid * dlsym(HMODULE Lib, const char *func) {\n  void * funcp;\n  if((funcp = (void *) GetProcAddress(Lib, func)))\n    return funcp;\n  else\n    return (void *) wglGetProcAddress(func);\n}\n\nHMODULE dlopen(const char *path, int unused) {\n  WCHAR * DLL;\n  int len = MultiByteToWideChar(CP_ACP, 0, path, -1, NULL, 0);\n  DLL = (WCHAR *) malloc(len * sizeof(WCHAR));\n  MultiByteToWideChar(CP_ACP, 0, path, -1, DLL, len);\n  HMODULE lib = LoadLibrary(DLL);\n  free(DLL);\n  return lib;\n}\n\nvoid dlclose(HMODULE Lib) {\n  FreeLibrary(Lib);\n}\n#else\ntypedef void * DL_LIB_P;\n#endif\n\nvoid wxe_initOpenGL(wxeReturn *rt, char *bp) {\n  DL_LIB_P LIBhandle;\n  int (*init_opengl)(void *);\n#ifdef _WIN32\n  void * erlCallbacks = &WinDynDriverCallbacks;\n#else \n  void * erlCallbacks = NULL;\n#endif\n  \n  if(erl_gl_initiated == FALSE) {\n    if((LIBhandle = dlopen(bp, RTLD_LAZY))) {\n      *(void **) (&init_opengl) = dlsym(LIBhandle, \"egl_init_opengl\");\n      wxe_gl_dispatch = (WXE_GL_DISPATCH) dlsym(LIBhandle, \"egl_dispatch\");\n      if(init_opengl && wxe_gl_dispatch) {\n\t(*init_opengl)(erlCallbacks);\n\trt->addAtom((char *) \"ok\");\n\trt->add(wxString::FromAscii(\"initiated\"));\n\trt->addTupleCount(2);\n\terl_gl_initiated = TRUE;\n      } else {\n\twxString msg;\n\tmsg.Printf(wxT(\"In library: \"));\n\tmsg += wxString::FromAscii(bp);\n\tmsg += wxT(\" functions: \");\n\tif(!init_opengl) \n\t  msg += wxT(\"egl_init_opengl \");\n\tif(!wxe_gl_dispatch) \n\t  msg += wxT(\"egl_dispatch \");\n\trt->addAtom((char *) \"error\");\n\trt->add(msg);\n\trt->addTupleCount(2);\n      }\n    } else {\n      wxString msg;\n      msg.Printf(wxT(\"Could not load dll: \"));\n      msg += wxString::FromAscii(bp);\n      rt->addAtom((char *) \"error\");\n      rt->add(msg);\n      rt->addTupleCount(2);\n    }\n  } else {\n    rt->addAtom((char *) \"ok\");\n    rt->add(wxString::FromAscii(\"already initilized\"));\n    rt->addTupleCount(2);\n  }\n  rt->send();\n}\n\nvoid setActiveGL(ErlDrvTermData caller, wxGLCanvas *canvas)\n{\n  gl_active = caller;\n  glc[caller] = canvas;\n}\n\nvoid deleteActiveGL(wxGLCanvas *canvas)\n{\n  gl_active = 0;\n  wxeGLC::iterator it;\n  for(it = glc.begin(); it != glc.end(); ++it) {\n    if(it->second == canvas) { \n      it->second = (wxGLCanvas *) 0;\n    }\n  }\n}\n\nvoid gl_dispatch(int op, char *bp,ErlDrvTermData caller,WXEBinRef *bins){\n  if(caller != gl_active) {\n    wxGLCanvas * current = glc[caller];\n    if(current) {\n      if(current != glc[gl_active]) {\n\tcurrent->SetCurrent();\n      }\n      gl_active = caller;\n    } else {\n      ErlDrvTermData rt[] = // Error msg\n\t{ERL_DRV_ATOM, driver_mk_atom((char *) \"_egl_error_\"),\n\t ERL_DRV_INT,  (ErlDrvTermData) op,\n\t ERL_DRV_ATOM, driver_mk_atom((char *) \"no_gl_context\"),\n\t ERL_DRV_TUPLE,3};\n      erl_drv_send_term(WXE_DRV_PORT,caller,rt,8);\n      return ;\n    }\n  };\n  char * bs[3];\n  int bs_sz[3];\n  for(int i=0; i<3; i++) {\n    if(bins[i].from) {\n      bs[i] = bins[i].base;\n      bs_sz[i] = bins[i].size;\n    }\n    else\n      break;\n  }\n  wxe_gl_dispatch(op, bp, WXE_DRV_PORT_HANDLE, caller, bs, bs_sz);\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/c_src/egl_impl.cpp": "/*\n * %CopyrightBegin%\n *\n * Copyright Ericsson AB 2011-2016. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * %CopyrightEnd%\n */\n\n#include <stdio.h>\n#include <string.h>\n\n#ifdef _WIN32\n#include <windows.h>\n#endif\n\n#include \"egl_impl.h\"\n\n#define WX_DEF_EXTS\n#include \"gen/gl_fdefs.h\"\n#include \"gen/gl_finit.h\"\n#include \"gen/glu_finit.h\"\n\nvoid init_tess();\nvoid exit_tess();\nint load_gl_functions();\n\n/* ****************************************************************************\n * OPENGL INITIALIZATION\n *****************************************************************************/\n\nint egl_initiated = 0;\n\n#ifdef _WIN32\n#define RTLD_LAZY 0\n#define OPENGL_LIB L\"opengl32.dll\"\n#define OPENGLU_LIB L\"glu32.dll\"\ntypedef HMODULE DL_LIB_P;\ntypedef WCHAR DL_CHAR;\nvoid * dlsym(HMODULE Lib, const char *func) {\n  void * funcp;\n  if((funcp = (void *) GetProcAddress(Lib, func)))\n    return funcp;\n  else\n    return (void *) wglGetProcAddress(func);\n}\n\nHMODULE dlopen(const WCHAR *DLL, int unused) {\n  return LoadLibrary(DLL);\n}\n\nvoid dlclose(HMODULE Lib) {\n  FreeLibrary(Lib);\n}\n\n#else\ntypedef void * DL_LIB_P;\ntypedef char DL_CHAR;\n# ifdef _MACOSX\n#  define OPENGL_LIB \"/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib\"\n#  define OPENGLU_LIB \"/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGLU.dylib\"\n# else\n#  define OPENGL_LIB \"libGL.so.1\"\n#  define OPENGLU_LIB \"libGLU.so.1\"\n# endif\n#endif\nextern \"C\" {\nDRIVER_INIT(EGL_DRIVER) {\n  return NULL;\n}\n}\n\nint egl_init_opengl(void *erlCallbacks)\n{\n#ifdef _WIN32\n  driver_init((TWinDynDriverCallbacks *) erlCallbacks);\n#endif\n  if(egl_initiated == 0) {\n    if(load_gl_functions()) {\n      init_tess();\n      egl_initiated = 1;\n    }\n  }\n  return 1;\n}\n\nint load_gl_functions() {\n  DL_CHAR * DLName = (DL_CHAR *) OPENGL_LIB;\n  DL_LIB_P LIBhandle = dlopen(DLName, RTLD_LAZY);\n  //fprintf(stderr, \"Loading GL: %s\\r\\n\", (const char*)DLName);\n  void * func = NULL;\n  int i;\n\n  if(LIBhandle) {\n    for(i=0; gl_fns[i].name != NULL; i++) {\n      if((func = dlsym(LIBhandle, gl_fns[i].name))) {\n\t* (void **) (gl_fns[i].func) = func;\n\t// fprintf(stderr, \"GL LOADED %s \\r\\n\", gl_fns[i].name);\n      } else {\n\tif(gl_fns[i].alt != NULL) {\n\t  if((func = dlsym(LIBhandle, gl_fns[i].alt))) {\n\t    * (void **) (gl_fns[i].func) = func;\n\t    // fprintf(stderr, \"GL LOADED %s \\r\\n\", gl_fns[i].alt);\n\t  } else {\n\t    * (void **) (gl_fns[i].func) = (void *) &gl_error;\n\t    // fprintf(stderr, \"GL Skipped %s and %s \\r\\n\", gl_fns[i].name, gl_fns[i].alt);\n\t  };\n\t} else {\n\t  * (void **) (gl_fns[i].func) = (void *) &gl_error;\n\t  // fprintf(stderr, \"GL Skipped %s \\r\\n\", gl_fns[i].name);\n\t}\n      }\n    }\n    // dlclose(LIBhandle);\n    // fprintf(stderr, \"OPENGL library is loaded\\r\\n\");\n  } else {\n    fprintf(stderr, \"Could NOT load OpenGL library: %s\\r\\n\", DLName);\n  };\n\n  DLName = (DL_CHAR *) OPENGLU_LIB;\n  LIBhandle = dlopen(DLName, RTLD_LAZY);\n  // fprintf(stderr, \"Loading GLU: %s\\r\\n\", (const char*)DLName);\n  func = NULL;\n\n  if(LIBhandle) {\n    for(i=0; glu_fns[i].name != NULL; i++) {\n      if((func = dlsym(LIBhandle, glu_fns[i].name))) {\n\t* (void **) (glu_fns[i].func) = func;\n      } else {\n\tif(glu_fns[i].alt != NULL) {\n\t  if((func = dlsym(LIBhandle, glu_fns[i].alt))) {\n\t    * (void **) (glu_fns[i].func) = func;\n\t  } else {\n\t    * (void **) (glu_fns[i].func) = (void *) &gl_error;\n\t    // fprintf(stderr, \"GLU Skipped %s\\r\\n\", glu_fns[i].alt);\n\t  };\n\t} else {\n\t  * (void **) (glu_fns[i].func) = (void *) &gl_error;\n\t  // fprintf(stderr, \"GLU Skipped %s\\r\\n\", glu_fns[i].name);\n\t}\n      }\n    }\n    // dlclose(LIBhandle);\n    // fprintf(stderr, \"GLU library is loaded\\r\\n\");\n  } else {\n    fprintf(stderr, \"Could NOT load OpenGL GLU library: %s\\r\\n\", DLName);\n  };\n\n  return 1;\n}\n\nvoid gl_error() {\n  // fprintf(stderr, \"OpenGL Extension not available \\r\\n\");\n  throw \"undef_extension\";\n}\n\n/* *******************************************************************************\n * GLU Tesselation special\n * ******************************************************************************/\n\nstatic GLUtesselator* tess;\n\ntypedef struct {\n  GLdouble * tess_coords;\n  int alloc_n;\n  int alloc_max;\n\n  int * tess_index_list;\n  int index_n;\n  int index_max;\n\n  int error;\n} egl_tess_data;\n\n#define NEED_MORE_ALLOC 1\n#define NEED_MORE_INDEX 2\n\nstatic egl_tess_data egl_tess;\n\nvoid CALLBACK\negl_ogla_vertex(GLdouble* coords)\n{\n  /* fprintf(stderr, \"%d\\r\\n\", (int) (coords - tess_coords) / 3); */\n  if(egl_tess.index_n < egl_tess.index_max) {\n    egl_tess.tess_index_list[egl_tess.index_n] = (int) (coords - egl_tess.tess_coords) / 3;\n    egl_tess.index_n++;\n  }\n  else\n    egl_tess.error = NEED_MORE_INDEX;\n}\n\nvoid CALLBACK\negl_ogla_combine(GLdouble coords[3],\n\t\t void* vertex_data[4],\n\t\t GLfloat w[4],\n\t\t void **dataOut)\n{\n  GLdouble* vertex = &egl_tess.tess_coords[egl_tess.alloc_n];\n  if(egl_tess.alloc_n < egl_tess.alloc_max) {\n    egl_tess.alloc_n += 3;\n    vertex[0] = coords[0];\n    vertex[1] = coords[1];\n    vertex[2] = coords[2];\n    *dataOut = vertex;\n\n#if 0\n    fprintf(stderr, \"combine: \");\n    int i;\n    for (i = 0; i < 4; i++) {\n      if (w[i] > 0.0) {\n\tfprintf(stderr, \"%d(%g) \", (int) vertex_data[i], w[i]);\n      }\n    }\n    fprintf(stderr, \"\\r\\n\");\n    fprintf(stderr, \"%g %g %g\\r\\n\", vertex[0], vertex[1], vertex[2]);\n#endif\n\n  } else {\n    egl_tess.error = NEED_MORE_ALLOC;\n    *dataOut = NULL;\n  }\n}\n\nvoid CALLBACK\negl_ogla_edge_flag(GLboolean flag)\n{\n}\n\nvoid CALLBACK\negl_ogla_error(GLenum errorCode)\n{\n  // const GLubyte *err;\n  // err = gluErrorString(errorCode);\n  // fprintf(stderr, \"Tesselation error: %d: %s\\r\\n\", (int) errorCode, err);\n}\n\nvoid init_tess()\n{\n  tess = gluNewTess();\n\n  gluTessCallback(tess, GLU_TESS_VERTEX,     (GLUfuncptr) egl_ogla_vertex);\n  gluTessCallback(tess, GLU_TESS_EDGE_FLAG,  (GLUfuncptr) egl_ogla_edge_flag);\n  gluTessCallback(tess, GLU_TESS_COMBINE,    (GLUfuncptr) egl_ogla_combine);\n  gluTessCallback(tess, GLU_TESS_ERROR,      (GLUfuncptr) egl_ogla_error);\n\n}\n\nvoid exit_tess()\n{\n  gluDeleteTess(tess);\n}\n\nint erl_tess_impl(char* buff, ErlDrvPort port, ErlDrvTermData caller)\n{\n  ErlDrvBinary* bin;\n  int i;\n  int num_vertices;\n  GLdouble *n;\n  int AP;\n  int a_max = 2;\n  int i_max = 6;\n  num_vertices = * (int *) buff; buff += 8; /* Align */\n  n = (double *) buff; buff += 8*3;\n\n  egl_tess.alloc_max = a_max*num_vertices*3;\n  bin = driver_alloc_binary(egl_tess.alloc_max*sizeof(GLdouble));\n  egl_tess.error = 0;\n  egl_tess.tess_coords = (double *) bin->orig_bytes;\n  memcpy(egl_tess.tess_coords,buff,num_vertices*3*sizeof(GLdouble));\n  egl_tess.index_max = i_max*3*num_vertices;\n  egl_tess.tess_index_list = (int *) driver_alloc(sizeof(int) * egl_tess.index_max);\n\n  egl_tess.tess_coords = (double *) bin->orig_bytes;\n  egl_tess.index_n = 0;\n  egl_tess.alloc_n = num_vertices*3;\n\n  gluTessNormal(tess, n[0], n[1], n[2]);\n  gluTessBeginPolygon(tess, 0);\n  gluTessBeginContour(tess);\n  for (i = 0; i < num_vertices; i++) {\n    gluTessVertex(tess, egl_tess.tess_coords+3*i, egl_tess.tess_coords+3*i);\n  }\n  gluTessEndContour(tess);\n  gluTessEndPolygon(tess);\n\n  AP = 0; ErlDrvTermData *rt;\n  rt = (ErlDrvTermData *) driver_alloc(sizeof(ErlDrvTermData) * (13+egl_tess.index_n*2));\n  rt[AP++]=ERL_DRV_ATOM; rt[AP++]=driver_mk_atom((char *) \"_egl_result_\");\n\n  for(i=0; i < egl_tess.index_n; i++) {\n    rt[AP++] = ERL_DRV_INT; rt[AP++] = (int) egl_tess.tess_index_list[i];\n  };\n  rt[AP++] = ERL_DRV_NIL; rt[AP++] = ERL_DRV_LIST; rt[AP++] = egl_tess.index_n+1;\n\n  rt[AP++] = ERL_DRV_BINARY; rt[AP++] = (ErlDrvTermData) bin;\n  rt[AP++] = egl_tess.alloc_n*sizeof(GLdouble); rt[AP++] = 0;\n\n  rt[AP++] = ERL_DRV_TUPLE; rt[AP++] = 2; // Return tuple {list, Bin}\n  rt[AP++] = ERL_DRV_TUPLE; rt[AP++] = 2; // Result tuple\n\n  driver_send_term(port,caller,rt,AP);\n  /* fprintf(stderr, \"List %d: %d %d %d \\r\\n\",  */\n  /* \t  res, */\n  /* \t  n_pos,  */\n  /* \t  (tess_alloc_vertex-new_vertices)*sizeof(GLdouble),  */\n  /* \t  num_vertices*6*sizeof(GLdouble)); */\n  driver_free_binary(bin);\n  driver_free(egl_tess.tess_index_list);\n  driver_free(rt);\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/crypto/aclocal.m4": "dnl\ndnl %CopyrightBegin%\ndnl\ndnl Copyright Ericsson AB 1998-2018. All Rights Reserved.\ndnl\ndnl Licensed under the Apache License, Version 2.0 (the \"License\");\ndnl you may not use this file except in compliance with the License.\ndnl You may obtain a copy of the License at\ndnl\ndnl     http://www.apache.org/licenses/LICENSE-2.0\ndnl\ndnl Unless required by applicable law or agreed to in writing, software\ndnl distributed under the License is distributed on an \"AS IS\" BASIS,\ndnl WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\ndnl See the License for the specific language governing permissions and\ndnl limitations under the License.\ndnl\ndnl %CopyrightEnd%\ndnl\n\ndnl\ndnl aclocal.m4\ndnl\ndnl Local macros used in configure.in. The Local Macros which\ndnl could/should be part of autoconf are prefixed LM_, macros specific\ndnl to the Erlang system are prefixed ERL_.\ndnl\n\nAC_DEFUN(LM_PRECIOUS_VARS,\n[\n\ndnl ERL_TOP\nAC_ARG_VAR(ERL_TOP, [Erlang/OTP top source directory])\n\ndnl Tools\nAC_ARG_VAR(CC, [C compiler])\nAC_ARG_VAR(CFLAGS, [C compiler flags])\nAC_ARG_VAR(STATIC_CFLAGS, [C compiler static flags])\nAC_ARG_VAR(CFLAG_RUNTIME_LIBRARY_PATH, [runtime library path linker flag passed via C compiler])\nAC_ARG_VAR(CPP, [C/C++ preprocessor])\nAC_ARG_VAR(CPPFLAGS, [C/C++ preprocessor flags])\nAC_ARG_VAR(CXX, [C++ compiler])\nAC_ARG_VAR(CXXFLAGS, [C++ compiler flags])\nAC_ARG_VAR(LD, [linker (is often overridden by configure)])\nAC_ARG_VAR(LDFLAGS, [linker flags (can be risky to set since LD may be overriden by configure)])\nAC_ARG_VAR(LIBS, [libraries])\nAC_ARG_VAR(DED_LD, [linker for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(DED_LDFLAGS, [linker flags for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(DED_LD_FLAG_RUNTIME_LIBRARY_PATH, [runtime library path linker flag for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(LFS_CFLAGS, [large file support C compiler flags (set all LFS_* variables or none)])\nAC_ARG_VAR(LFS_LDFLAGS, [large file support linker flags (set all LFS_* variables or none)])\nAC_ARG_VAR(LFS_LIBS, [large file support libraries (set all LFS_* variables or none)])\nAC_ARG_VAR(RANLIB, [ranlib])\nAC_ARG_VAR(AR, [ar])\nAC_ARG_VAR(GETCONF, [getconf])\n\ndnl Cross system root\nAC_ARG_VAR(erl_xcomp_sysroot, [Absolute cross system root path (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_isysroot, [Absolute cross system root include path (only used when cross compiling)])\n\ndnl Cross compilation variables\nAC_ARG_VAR(erl_xcomp_bigendian, [big endian system: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_double_middle_endian, [double-middle-endian system: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_nptl, [have Native POSIX Thread Library: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_usable_sigusrx, [SIGUSR1 and SIGUSR2 can be used: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_usable_sigaltstack, [have working sigaltstack(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_poll, [have working poll(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_kqueue, [have working kqueue(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_putenv_copy, [putenv() stores key-value copy: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_reliable_fpe, [have reliable floating point exceptions: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_getaddrinfo, [have working getaddrinfo() for both IPv4 and IPv6: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_gethrvtime_procfs_ioctl, [have working gethrvtime() which can be used with procfs ioctl(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_clock_gettime_cpu_time, [clock_gettime() can be used for retrieving process CPU time: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_after_morecore_hook, [__after_morecore_hook can track malloc()s core memory usage: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_dlsym_brk_wrappers, [dlsym(RTLD_NEXT, _) brk wrappers can track malloc()s core memory usage: yes|no (only used when cross compiling)])\n\n])\n\nAC_DEFUN(ERL_XCOMP_SYSROOT_INIT,\n[\nerl_xcomp_without_sysroot=no\nif test \"$cross_compiling\" = \"yes\"; then\n    test \"$erl_xcomp_sysroot\" != \"\" || erl_xcomp_without_sysroot=yes\n    test \"$erl_xcomp_isysroot\" != \"\" || erl_xcomp_isysroot=\"$erl_xcomp_sysroot\"\nelse\n    erl_xcomp_sysroot=\n    erl_xcomp_isysroot=\nfi\n])\n\nAC_DEFUN(LM_CHECK_GETCONF,\n[\nif test \"$cross_compiling\" != \"yes\"; then\n    AC_CHECK_PROG([GETCONF], [getconf], [getconf], [false])\nelse\n    dnl First check if we got a `<HOST>-getconf' in $PATH\n    host_getconf=\"$host_alias-getconf\"\n    AC_CHECK_PROG([GETCONF], [$host_getconf], [$host_getconf], [false])\n    if test \"$GETCONF\" = \"false\" && test \"$erl_xcomp_sysroot\" != \"\"; then\n\tdnl We should perhaps give up if we have'nt found it by now, but at\n\tdnl least in one Tilera MDE `getconf' under sysroot is a bourne\n\tdnl shell script which we can use. We try to find `<HOST>-getconf'\n    \tdnl or `getconf' under sysconf, but only under sysconf since\n\tdnl `getconf' in $PATH is almost guaranteed to be for the build\n\tdnl machine.\n\tGETCONF=\n\tprfx=\"$erl_xcomp_sysroot\"\n        AC_PATH_TOOL([GETCONF], [getconf], [false],\n\t             [\"$prfx/usr/bin:$prfx/bin:$prfx/usr/local/bin\"])\n    fi\nfi\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_WINDOWS_ENVIRONMENT\ndnl\ndnl\ndnl Tries to determine thw windows build environment, i.e. \ndnl MIXED_CYGWIN_VC or MIXED_MSYS_VC \ndnl\n\nAC_DEFUN(LM_WINDOWS_ENVIRONMENT,\n[\n\nif test \"X$windows_environment_\" != \"Xchecked\"; then\nwindows_environment_=checked\nMIXED_CYGWIN=no\nMIXED_MSYS=no\n\nAC_MSG_CHECKING(for mixed cygwin or msys and native VC++ environment)\nif test \"X$host\" = \"Xwin32\" -a \"x$GCC\" != \"xyes\"; then\n\tif test -x /usr/bin/msys-?.0.dll; then\n\t        CFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_MSYS=yes\n\t\tAC_MSG_RESULT([MSYS and VC])\n\t\tMIXED_MSYS_VC=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_MSYS_VC\"\n\telif test -x /usr/bin/cygpath; then\n\t\tCFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_CYGWIN=yes\n\t\tAC_MSG_RESULT([Cygwin and VC])\n\t\tMIXED_CYGWIN_VC=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_CYGWIN_VC\"\n\telse\t\t    \n\t\tAC_MSG_RESULT([undeterminable])\n\t\tAC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)\n\tfi\nelse\n\tAC_MSG_RESULT([no])\n\tMIXED_CYGWIN_VC=no\n\tMIXED_MSYS_VC=no\nfi\nAC_SUBST(MIXED_CYGWIN_VC)\nAC_SUBST(MIXED_MSYS_VC)\n\nMIXED_VC=no\nif test \"x$MIXED_MSYS_VC\" = \"xyes\" -o  \"x$MIXED_CYGWIN_VC\" = \"xyes\" ; then\n   MIXED_VC=yes\nfi\n\nAC_SUBST(MIXED_VC)\n\nif test \"x$MIXED_MSYS\" != \"xyes\"; then\n   AC_MSG_CHECKING(for mixed cygwin and native MinGW environment)\n   if test \"X$host\" = \"Xwin32\" -a \"x$GCC\" = x\"yes\"; then\n\tif test -x /usr/bin/cygpath; then\n\t\tCFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_CYGWIN=yes\n\t\tAC_MSG_RESULT([yes])\n\t\tMIXED_CYGWIN_MINGW=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_CYGWIN_MINGW\"\n\telse\n\t\tAC_MSG_RESULT([undeterminable])\n\t\tAC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)\n\tfi\n    else\n\tAC_MSG_RESULT([no])\n\tMIXED_CYGWIN_MINGW=no\n    fi\nelse\n\tMIXED_CYGWIN_MINGW=no\nfi\t\nAC_SUBST(MIXED_CYGWIN_MINGW)\n\nAC_MSG_CHECKING(if we mix cygwin with any native compiler)\nif test \"X$MIXED_CYGWIN\" = \"Xyes\"; then\n\tAC_MSG_RESULT([yes])\t\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nAC_SUBST(MIXED_CYGWIN)\n\t\nAC_MSG_CHECKING(if we mix msys with another native compiler)\nif test \"X$MIXED_MSYS\" = \"Xyes\" ; then\n\tAC_MSG_RESULT([yes])\t\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nAC_SUBST(MIXED_MSYS)\n\nfi\n])\t\t\n\t\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_FIND_EMU_CC\ndnl\ndnl\ndnl Tries fairly hard to find a C compiler that can handle jump tables.\ndnl Defines the @EMU_CC@ variable for the makefiles and \ndnl inserts NO_JUMP_TABLE in the header if one cannot be found...\ndnl\n\nAC_DEFUN(LM_FIND_EMU_CC,\n\t[AC_CACHE_CHECK(for a compiler that handles jumptables,\n\t\t\tac_cv_prog_emu_cc,\n\t\t\t[\nAC_TRY_COMPILE([],[\n#if defined(__clang_major__) && __clang_major__ >= 3\n    /* clang 3.x or later is fine */\n#elif defined(__llvm__)\n#error \"this version of llvm is unable to correctly compile beam_emu.c\"\n#endif\n    __label__ lbl1;\n    __label__ lbl2;\n    int x = magic();\n    static void *jtab[2];\n\n    jtab[0] = &&lbl1;\n    jtab[1] = &&lbl2;\n    goto *jtab[x];\nlbl1:\n    return 1;\nlbl2:\n    return 2;\n],ac_cv_prog_emu_cc=\"$CC\",ac_cv_prog_emu_cc=no)\n\nif test \"$ac_cv_prog_emu_cc\" = no; then\n\tfor ac_progname in emu_cc.sh gcc-4.2 gcc; do\n  \t\tIFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\":\"\n  \t\tac_dummy=\"$PATH\"\n  \t\tfor ac_dir in $ac_dummy; do\n    \t\t\ttest -z \"$ac_dir\" && ac_dir=.\n    \t\t\tif test -f \"$ac_dir/$ac_progname\"; then\n      \t\t\t\tac_cv_prog_emu_cc=\"$ac_dir/$ac_progname\"\n      \t\t\t\tbreak\n    \t\t\tfi\n  \t\tdone\n  \t\tIFS=\"$ac_save_ifs\"\n\t\tif test \"$ac_cv_prog_emu_cc\" != no; then\n\t\t\tbreak\n\t\tfi\n\tdone\nfi\n\nif test \"$ac_cv_prog_emu_cc\" != no; then\n\tsave_CC=\"$CC\"\n\tsave_CFLAGS=$CFLAGS\n\tsave_CPPFLAGS=$CPPFLAGS\n\tCC=\"$ac_cv_prog_emu_cc\"\n\tCFLAGS=\"\"\n\tCPPFLAGS=\"\"\n\tAC_TRY_COMPILE([],[\n#if defined(__clang_major__) && __clang_major__ >= 3\n    /* clang 3.x or later is fine */\n#elif defined(__llvm__)\n#error \"this version of llvm is unable to correctly compile beam_emu.c\"\n#endif\n    \t__label__ lbl1;\n    \t__label__ lbl2;\n    \tint x = magic();\n    \tstatic void *jtab[2];\n\n    \tjtab[0] = &&lbl1;\n    \tjtab[1] = &&lbl2;\n    \tgoto *jtab[x];\n\tlbl1:\n    \treturn 1;\n\tlbl2:\n    \treturn 2;\n\t],ac_cv_prog_emu_cc=\"$CC\",ac_cv_prog_emu_cc=no)\n\tCC=$save_CC\n\tCFLAGS=$save_CFLAGS\n\tCPPFLAGS=$save_CPPFLAGS\nfi\n])\nif test \"$ac_cv_prog_emu_cc\" = no; then\n\tAC_DEFINE(NO_JUMP_TABLE,[],[Defined if no found C compiler can handle jump tables])\n\tEMU_CC=\"$CC\"\nelse\n\tEMU_CC=\"$ac_cv_prog_emu_cc\"\nfi\nAC_SUBST(EMU_CC)\n])\t\t\n\t\t\t\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_PROG_INSTALL_DIR\ndnl\ndnl This macro may be used by any OTP application.\ndnl\ndnl Figure out how to create directories with parents.\ndnl (In my opinion INSTALL_DIR is a bad name, MKSUBDIRS or something is better)\ndnl\ndnl We prefer 'install -d', but use 'mkdir -p' if it exists.\ndnl If none of these methods works, we give up.\ndnl\n\n\nAC_DEFUN(LM_PROG_INSTALL_DIR,\n[AC_CACHE_CHECK(how to create a directory including parents,\nac_cv_prog_mkdir_p,\n[\ntemp_name_base=config.$$\ntemp_name=$temp_name_base/x/y/z\n$INSTALL -d $temp_name >/dev/null 2>&1\nac_cv_prog_mkdir_p=none\nif test -d $temp_name; then\n        ac_cv_prog_mkdir_p=\"$INSTALL -d\"\nelse\n        mkdir -p $temp_name >/dev/null 2>&1\n        if test -d $temp_name; then\n                ac_cv_prog_mkdir_p=\"mkdir -p\"\n        fi\nfi\nrm -fr $temp_name_base           \n])\n\ncase \"${ac_cv_prog_mkdir_p}\" in\n  none) AC_MSG_ERROR(don't know how create directories with parents) ;;\n  *)    INSTALL_DIR=\"$ac_cv_prog_mkdir_p\" AC_SUBST(INSTALL_DIR)     ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_PROG_PERL5\ndnl\ndnl Try to find perl version 5. If found set PERL to the absolute path\ndnl of the program, if not found set PERL to false.\ndnl\ndnl On some systems /usr/bin/perl is perl 4 and e.g.\ndnl /usr/local/bin/perl is perl 5. We try to handle this case by\ndnl putting a couple of \ndnl Tries to handle the case that there are two programs called perl\ndnl in the path and one of them is perl 5 and the other isn't. \ndnl\nAC_DEFUN(LM_PROG_PERL5,\n[AC_PATH_PROGS(PERL, perl5 perl, false,\n   /usr/local/bin:/opt/local/bin:/usr/local/gnu/bin:${PATH})\nchangequote(, )dnl\ndnl[ That bracket is needed to balance the right bracket below\nif test \"$PERL\" = \"false\" || $PERL -e 'exit ($] >= 5)'; then\nchangequote([, ])dnl\n  ac_cv_path_PERL=false\n  PERL=false\ndnl  AC_MSG_WARN(perl version 5 not found)\nfi\n])dnl\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_SO_BSDCOMPAT\ndnl\ndnl Check if the system has the SO_BSDCOMPAT flag on sockets (linux) \ndnl\nAC_DEFUN(LM_DECL_SO_BSDCOMPAT,\n[AC_CACHE_CHECK([for SO_BSDCOMPAT declaration], ac_cv_decl_so_bsdcompat,\nAC_TRY_COMPILE([#include <sys/socket.h>], [int i = SO_BSDCOMPAT;],\n               ac_cv_decl_so_bsdcompat=yes,\n               ac_cv_decl_so_bsdcompat=no))\n\ncase \"${ac_cv_decl_so_bsdcompat}\" in\n  \"yes\" ) AC_DEFINE(HAVE_SO_BSDCOMPAT,[],\n\t\t[Define if you have SO_BSDCOMPAT flag on sockets]) ;;\n  * ) ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_INADDR_LOOPBACK\ndnl\ndnl Try to find declaration of INADDR_LOOPBACK, if nowhere provide a default\ndnl\n\nAC_DEFUN(LM_DECL_INADDR_LOOPBACK,\n[AC_CACHE_CHECK([for INADDR_LOOPBACK in netinet/in.h],\n ac_cv_decl_inaddr_loopback,\n[AC_TRY_COMPILE([#include <sys/types.h>\n#include <netinet/in.h>], [int i = INADDR_LOOPBACK;],\nac_cv_decl_inaddr_loopback=yes, ac_cv_decl_inaddr_loopback=no)\n])\n\nif test ${ac_cv_decl_inaddr_loopback} = no; then\n  AC_CACHE_CHECK([for INADDR_LOOPBACK in rpc/types.h],\n                   ac_cv_decl_inaddr_loopback_rpc,\n                   AC_TRY_COMPILE([#include <rpc/types.h>],\n                                   [int i = INADDR_LOOPBACK;],\n                                   ac_cv_decl_inaddr_loopback_rpc=yes,\n                                   ac_cv_decl_inaddr_loopback_rpc=no))\n\n   case \"${ac_cv_decl_inaddr_loopback_rpc}\" in\n     \"yes\" )\n        AC_DEFINE(DEF_INADDR_LOOPBACK_IN_RPC_TYPES_H,[],\n\t\t[Define if you need to include rpc/types.h to get INADDR_LOOPBACK defined]) ;;\n      * )\n  \tAC_CACHE_CHECK([for INADDR_LOOPBACK in winsock2.h],\n                   ac_cv_decl_inaddr_loopback_winsock2,\n                   AC_TRY_COMPILE([#define WIN32_LEAN_AND_MEAN\n\t\t\t\t   #include <winsock2.h>],\n                                   [int i = INADDR_LOOPBACK;],\n                                   ac_cv_decl_inaddr_loopback_winsock2=yes,\n                                   ac_cv_decl_inaddr_loopback_winsock2=no))\n\tcase \"${ac_cv_decl_inaddr_loopback_winsock2}\" in\n     \t\t\"yes\" )\n\t\t\tAC_DEFINE(DEF_INADDR_LOOPBACK_IN_WINSOCK2_H,[],\n\t\t\t\t[Define if you need to include winsock2.h to get INADDR_LOOPBACK defined]) ;;\n\t\t* )\n\t\t\t# couldn't find it anywhere\n        \t\tAC_DEFINE(HAVE_NO_INADDR_LOOPBACK,[],\n\t\t\t\t[Define if you don't have a definition of INADDR_LOOPBACK]) ;;\n\tesac;;\n   esac\nfi\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_STRUCT_SOCKADDR_SA_LEN\ndnl\ndnl Check if the sockaddr structure has the field sa_len\ndnl\n\nAC_DEFUN(LM_STRUCT_SOCKADDR_SA_LEN,\n[AC_CACHE_CHECK([whether struct sockaddr has sa_len field],\n                ac_cv_struct_sockaddr_sa_len,\nAC_TRY_COMPILE([#include <sys/types.h>\n#include <sys/socket.h>], [struct sockaddr s; s.sa_len = 10;],\n  ac_cv_struct_sockaddr_sa_len=yes, ac_cv_struct_sockaddr_sa_len=no))\n\ndnl FIXME convbreak\ncase ${ac_cv_struct_sockaddr_sa_len} in\n  \"no\" ) AC_DEFINE(NO_SA_LEN,[1],[Define if you dont have salen]) ;;\n  *) ;;\nesac\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_STRUCT_EXCEPTION\ndnl\ndnl Check to see whether the system supports the matherr function\ndnl and its associated type \"struct exception\".\ndnl\n\nAC_DEFUN(LM_STRUCT_EXCEPTION,\n[AC_CACHE_CHECK([for struct exception (and matherr function)],\n ac_cv_struct_exception,\nAC_TRY_COMPILE([#include <math.h>],\n  [struct exception x; x.type = DOMAIN; x.type = SING;],\n  ac_cv_struct_exception=yes, ac_cv_struct_exception=no))\n\ncase \"${ac_cv_struct_exception}\" in\n  \"yes\" ) AC_DEFINE(USE_MATHERR,[1],[Define if you have matherr() function and struct exception type]) ;;\n  *  ) ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_SYS_IPV6\ndnl\ndnl Check for ipv6 support and what the in6_addr structure is called.\ndnl (early linux used in_addr6 insted of in6_addr)\ndnl\n\nAC_DEFUN(LM_SYS_IPV6,\n[AC_MSG_CHECKING(for IP version 6 support)\nAC_CACHE_VAL(ac_cv_sys_ipv6_support,\n[ok_so_far=yes\n AC_TRY_COMPILE([#include <sys/types.h>\n#ifdef __WIN32__\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <netinet/in.h>\n#endif],\n   [struct in6_addr a6; struct sockaddr_in6 s6;], ok_so_far=yes, ok_so_far=no)\n\nif test $ok_so_far = yes; then\n  ac_cv_sys_ipv6_support=yes\nelse\n  AC_TRY_COMPILE([#include <sys/types.h>\n#ifdef __WIN32__\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <netinet/in.h>\n#endif],\n    [struct in_addr6 a6; struct sockaddr_in6 s6;],\n    ac_cv_sys_ipv6_support=in_addr6, ac_cv_sys_ipv6_support=no)\nfi\n])dnl\n\ndnl\ndnl Have to use old style AC_DEFINE due to BC with old autoconf.\ndnl\n\ncase ${ac_cv_sys_ipv6_support} in\n  yes)\n    AC_MSG_RESULT(yes)\n    AC_DEFINE(HAVE_IN6,[1],[Define if ipv6 is present])\n    ;;\n  in_addr6)\n    AC_MSG_RESULT([yes (but I am redefining in_addr6 to in6_addr)])\n    AC_DEFINE(HAVE_IN6,[1],[Define if ipv6 is present])\n    AC_DEFINE(HAVE_IN_ADDR6_STRUCT,[],[Early linux used in_addr6 instead of in6_addr, define if you have this])\n    ;;\n  *)\n    AC_MSG_RESULT(no)\n    ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_SYS_MULTICAST\ndnl\ndnl Check for multicast support. Only checks for multicast options in\ndnl setsockopt(), no check is performed that multicasting actually works.\ndnl If options are found defines HAVE_MULTICAST_SUPPORT\ndnl\n\nAC_DEFUN(LM_SYS_MULTICAST,\n[AC_CACHE_CHECK([for multicast support], ac_cv_sys_multicast_support,\n[AC_EGREP_CPP(^yes$,\n[#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#if defined(IP_MULTICAST_TTL) && defined(IP_MULTICAST_LOOP) && defined(IP_MULTICAST_IF) && defined(IP_ADD_MEMBERSHIP) && defined(IP_DROP_MEMBERSHIP)\nyes\n#endif\n], ac_cv_sys_multicast_support=yes, ac_cv_sys_multicast_support=no)])\nif test $ac_cv_sys_multicast_support = yes; then\n  AC_DEFINE(HAVE_MULTICAST_SUPPORT,[1],\n\t[Define if setsockopt() accepts multicast options])\nfi\n])dnl\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_SYS_ERRLIST\ndnl\ndnl Define SYS_ERRLIST_DECLARED if the variable sys_errlist is declared\ndnl in a system header file, stdio.h or errno.h.\ndnl\n\nAC_DEFUN(LM_DECL_SYS_ERRLIST,\n[AC_CACHE_CHECK([for sys_errlist declaration in stdio.h or errno.h],\n  ac_cv_decl_sys_errlist,\n[AC_TRY_COMPILE([#include <stdio.h>\n#include <errno.h>], [char *msg = *(sys_errlist + 1);],\n  ac_cv_decl_sys_errlist=yes, ac_cv_decl_sys_errlist=no)])\nif test $ac_cv_decl_sys_errlist = yes; then\n  AC_DEFINE(SYS_ERRLIST_DECLARED,[],\n\t[define if the variable sys_errlist is declared in a system header file])\nfi\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_CHECK_FUNC_DECL( funname, declaration [, extra includes \ndnl                     [, action-if-found [, action-if-not-found]]] )\ndnl\ndnl Checks if the declaration \"declaration\" of \"funname\" conflicts\ndnl with the header files idea of how the function should be\ndnl declared. It is useful on systems which lack prototypes and you\ndnl need to provide your own (e.g. when you want to take the address\ndnl of a function). The 4'th argument is expanded if conflicting, \ndnl the 5'th argument otherwise\ndnl\ndnl\n\nAC_DEFUN(LM_CHECK_FUNC_DECL,\n[AC_MSG_CHECKING([for conflicting declaration of $1])\nAC_CACHE_VAL(ac_cv_func_decl_$1,\n[AC_TRY_COMPILE([#include <stdio.h>\n$3],[$2\nchar *c = (char *)$1;\n], eval \"ac_cv_func_decl_$1=no\", eval \"ac_cv_func_decl_$1=yes\")])\nif eval \"test \\\"`echo '$ac_cv_func_decl_'$1`\\\" = yes\"; then\n  AC_MSG_RESULT(yes)\n  ifelse([$4], , :, [$4])\nelse\n  AC_MSG_RESULT(no)\nifelse([$5], , , [$5\n])dnl\nfi\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl AC_DOUBLE_MIDDLE_ENDIAN\ndnl\ndnl Checks whether doubles are represented in \"middle-endian\" format.\ndnl Sets ac_cv_double_middle_endian={no,yes,unknown} accordingly,\ndnl as well as DOUBLE_MIDDLE_ENDIAN.\ndnl\ndnl\n\nAC_DEFUN([AC_C_DOUBLE_MIDDLE_ENDIAN],\n[AC_CACHE_CHECK(whether double word ordering is middle-endian, ac_cv_c_double_middle_endian,\n[# It does not; compile a test program.\nAC_RUN_IFELSE(\n[AC_LANG_SOURCE([[#include <stdlib.h>\n\nint\nmain(void)\n{\n  int i = 0;\n  int zero = 0;\n  int bigendian;\n  int zero_index = 0;\n\n  union\n  {\n    long int l;\n    char c[sizeof (long int)];\n  } u;\n\n  /* we'll use the one with 32-bit words */\n  union\n  {\n    double d;\n    unsigned int c[2];\n  } vint;\n\n  union\n  {\n    double d;\n    unsigned long c[2];\n  } vlong;\n\n  union\n  {\n    double d;\n    unsigned short c[2];\n  } vshort;\n\n\n  /* Are we little or big endian?  From Harbison&Steele.  */\n  u.l = 1;\n  bigendian = (u.c[sizeof (long int) - 1] == 1);\n\n  zero_index = bigendian ? 1 : 0;\n\n  vint.d = 1.0;\n  vlong.d = 1.0;\n  vshort.d = 1.0;\n\n  if (sizeof(unsigned int) == 4)\n    {\n      if (vint.c[zero_index] != 0)\n\tzero = 1;\n    }\n  else if (sizeof(unsigned long) == 4)\n    {\n      if (vlong.c[zero_index] != 0)\n\tzero = 1;\n    }\n  else if (sizeof(unsigned short) == 4)\n    {\n      if (vshort.c[zero_index] != 0)\n\tzero = 1;\n    }\n\n  exit (zero);\n}\n]])],\n\t      [ac_cv_c_double_middle_endian=no],\n\t      [ac_cv_c_double_middle_endian=yes],\n\t      [ac_cv_c_double_middle=unknown])])\ncase $ac_cv_c_double_middle_endian in\n  yes)\n    m4_default([$1],\n      [AC_DEFINE([DOUBLE_MIDDLE_ENDIAN], 1,\n\t[Define to 1 if your processor stores the words in a double in\n\t middle-endian format (like some ARMs).])]) ;;\n  no)\n    $2 ;;\n  *)\n    m4_default([$3],\n      [AC_MSG_WARN([unknown double endianness\npresetting ac_cv_c_double_middle_endian=no (or yes) will help])]) ;;\nesac\n])# AC_C_DOUBLE_MIDDLE_ENDIAN\n\n\nAC_DEFUN(ERL_MONOTONIC_CLOCK,\n[\n  if test \"$3\" = \"yes\"; then\n     default_resolution_clock_gettime_monotonic=\"CLOCK_HIGHRES CLOCK_BOOTTIME CLOCK_MONOTONIC\"\n     low_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_COARSE CLOCK_MONOTONIC_FAST\"\n     high_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_PRECISE\"\n  else\n     default_resolution_clock_gettime_monotonic=\"CLOCK_HIGHRES CLOCK_UPTIME CLOCK_MONOTONIC\"\n     low_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_COARSE CLOCK_UPTIME_FAST\"\n     high_resolution_clock_gettime_monotonic=\"CLOCK_UPTIME_PRECISE\"\n  fi\n\n  case \"$1\" in\n    high_resolution)\n\tcheck_msg=\"high resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$high_resolution_clock_gettime_monotonic\"\n\t;;\n    low_resolution)\n\tcheck_msg=\"low resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$low_resolution_clock_gettime_monotonic\"\n\t;;\n    custom_resolution)\n\tcheck_msg=\"custom resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$2\"\n\t;;\n    *)\n\tcheck_msg=\"custom \"\n\tprefer_resolution_clock_gettime_monotonic=\"$2\"\n\t;;\n  esac\n\n  clock_gettime_lib=\"\"\n  AC_CHECK_LIB(rt, clock_gettime, [clock_gettime_lib=\"-lrt\"])\n\n  save_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $clock_gettime_lib\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     trust_test=\"#error May not be there due to weak linking\"\n  else\n     trust_test=\"\"\n  fi\n\n  AC_CACHE_CHECK([for clock_gettime(CLOCK_MONOTONIC_RAW, _)], erl_cv_clock_gettime_monotonic_raw,\n  [\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime(CLOCK_MONOTONIC_RAW, &ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_monotonic_raw=yes,\n\t\t      erl_cv_clock_gettime_monotonic_raw=no)\n  ])\n\n  AC_CACHE_CHECK([for clock_gettime() with ${check_msg}monotonic clock type], erl_cv_clock_gettime_monotonic_$1,\n  [\n     for clock_type in $prefer_resolution_clock_gettime_monotonic $default_resolution_clock_gettime_monotonic $high_resolution_clock_gettime_monotonic $low_resolution_clock_gettime_monotonic; do\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime($clock_type,&ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_monotonic_$1=$clock_type,\n\t\t      erl_cv_clock_gettime_monotonic_$1=no)\n       test $erl_cv_clock_gettime_monotonic_$1 = no || break\n     done\n  ])\n\n  LIBS=\"$save_LIBS\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     check_for_clock_getres=\n  else\n     check_for_clock_getres=clock_getres\n  fi\n\n  AC_CHECK_FUNCS([$check_for_clock_getres clock_get_attributes gethrtime])\n  \n  AC_CACHE_CHECK([for mach clock_get_time() with monotonic clock type], erl_cv_mach_clock_get_time_monotonic,\n  [\n     AC_TRY_COMPILE([\n#include <mach/clock.h>\n#include <mach/mach.h>\n\t\t\t],\n\t \t\t[\n    kern_return_t res;\n    clock_serv_t clk_srv;\n    mach_timespec_t time_spec;\n\n    host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &clk_srv);\n    res = clock_get_time(clk_srv, &time_spec);\n    mach_port_deallocate(mach_task_self(), clk_srv);\n    \t\t\t],\n    \t\t\terl_cv_mach_clock_get_time_monotonic=yes,\n\t\t\terl_cv_mach_clock_get_time_monotonic=no)\n  ])\n  \n  erl_corrected_monotonic_clock=no\n  case $erl_cv_clock_gettime_monotonic_$1-$ac_cv_func_gethrtime-$erl_cv_mach_clock_get_time_monotonic-$host_os in\n    *-*-*-win32)\n      erl_monotonic_clock_func=WindowsAPI\n      ;;\n    CLOCK_*-*-*-linux*)\n      case $erl_cv_clock_gettime_monotonic_$1-$erl_cv_clock_gettime_monotonic_raw in\n        CLOCK_BOOTTIME-yes|CLOCK_MONOTONIC-yes)\n\t  erl_corrected_monotonic_clock=yes\n\t  ;;\n\t*)\n\t  # We don't trust CLOCK_MONOTONIC to be NTP\n\t  # adjusted on linux systems that do not have\n\t  # CLOCK_MONOTONIC_RAW (although it seems to\n\t  # be...)\n\t  ;;\n      esac\n      erl_monotonic_clock_func=clock_gettime\n      ;;\n    no-no-no-linux*)\n      erl_monotonic_clock_func=times\n      ;;\n    CLOCK_*-*-*-*)\n      erl_monotonic_clock_func=clock_gettime\n      ;;\n    no-yes-*-*)\n      erl_monotonic_clock_func=gethrtime\n      ;;\n    no-no-yes-*)\n      erl_monotonic_clock_func=mach_clock_get_time\n      ;;\n    no-no-no-*)\n      erl_monotonic_clock_func=none\n      ;;\n  esac\n\n  erl_monotonic_clock_low_resolution=no\n  erl_monotonic_clock_lib=\n  erl_monotonic_clock_id=\n  case $erl_monotonic_clock_func in\n    clock_gettime)\n      erl_monotonic_clock_id=$erl_cv_clock_gettime_monotonic_$1\n      for low_res_id in $low_resolution_clock_gettime_monotonic; do\n      \t  if test $erl_monotonic_clock_id = $low_res_id; then\n\t    erl_monotonic_clock_low_resolution=yes\n\t    break\n\t  fi\n      done\n      erl_monotonic_clock_lib=$clock_gettime_lib\n      ;;\n    mach_clock_get_time)\n      erl_monotonic_clock_id=SYSTEM_CLOCK\n      ;;\n    times)\n      erl_monotonic_clock_low_resolution=yes\n      ;;\n    *)\n      ;;\n  esac\n \n])\n\nAC_DEFUN(ERL_WALL_CLOCK,\n[\n  default_resolution_clock_gettime_wall=\"CLOCK_REALTIME\"\n  low_resolution_clock_gettime_wall=\"CLOCK_REALTIME_COARSE CLOCK_REALTIME_FAST\"\n  high_resolution_clock_gettime_wall=\"CLOCK_REALTIME_PRECISE\"\n\n  case \"$1\" in\n    high_resolution)\n\tcheck_msg=\"high resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$high_resolution_clock_gettime_wall\"\n\t;;\n    low_resolution)\n\tcheck_msg=\"low resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$low_resolution_clock_gettime_wall\"\n\t;;\n    custom_resolution)\n\tcheck_msg=\"custom resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$2\"\n\t;;\n    *)\n\tcheck_msg=\"\"\n\tprefer_resolution_clock_gettime_wall=\n\t;;\n  esac\n\n  clock_gettime_lib=\"\"\n  AC_CHECK_LIB(rt, clock_gettime, [clock_gettime_lib=\"-lrt\"])\n\n  save_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $clock_gettime_lib\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     trust_test=\"#error May not be there due to weak linking\"\n  else\n     trust_test=\"\"\n  fi\n\n  AC_CACHE_CHECK([for clock_gettime() with ${check_msg}wall clock type], erl_cv_clock_gettime_wall_$1,\n  [\n     for clock_type in $prefer_resolution_clock_gettime_wall $default_resolution_clock_gettime_wall $high_resolution_clock_gettime_wall $low_resolution_clock_gettime_wall; do\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime($clock_type,&ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_wall_$1=$clock_type,\n\t\t      erl_cv_clock_gettime_wall_$1=no)\n       test $erl_cv_clock_gettime_wall_$1 = no || break\n     done\n  ])\n\n  LIBS=\"$save_LIBS\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     check_for_clock_getres=\n  else\n     check_for_clock_getres=clock_getres\n  fi\n\n  AC_CHECK_FUNCS([$check_for_clock_getres clock_get_attributes gettimeofday])\n  \n  AC_CACHE_CHECK([for mach clock_get_time() with wall clock type], erl_cv_mach_clock_get_time_wall,\n  [\n     AC_TRY_COMPILE([\n#include <mach/clock.h>\n#include <mach/mach.h>\n\t\t\t],\n\t \t\t[\n    kern_return_t res;\n    clock_serv_t clk_srv;\n    mach_timespec_t time_spec;\n\n    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &clk_srv);\n    res = clock_get_time(clk_srv, &time_spec);\n    mach_port_deallocate(mach_task_self(), clk_srv);\n    \t\t\t],\n    \t\t\terl_cv_mach_clock_get_time_wall=yes,\n\t\t\terl_cv_mach_clock_get_time_wall=no)\n  ])\n\n  erl_wall_clock_lib=\n  erl_wall_clock_low_resolution=no\n  erl_wall_clock_id=\n  case $1-$erl_cv_clock_gettime_wall_$1-$erl_cv_mach_clock_get_time_wall-$ac_cv_func_gettimeofday-$host_os in\n    *-*-*-*-win32)\n      erl_wall_clock_func=WindowsAPI\n      erl_wall_clock_low_resolution=yes\n      ;;\n    high_resolution-no-yes-*-*)\n      erl_wall_clock_func=mach_clock_get_time\n      erl_wall_clock_id=CALENDAR_CLOCK\n      ;;\n    *-CLOCK_*-*-*-*)\n      erl_wall_clock_func=clock_gettime\n      erl_wall_clock_lib=$clock_gettime_lib\n      erl_wall_clock_id=$erl_cv_clock_gettime_wall_$1\n      for low_res_id in $low_resolution_clock_gettime_wall; do\n      \t  if test $erl_wall_clock_id = $low_res_id; then\n\t    erl_wall_clock_low_resolution=yes\n\t    break\n\t  fi\n      done\n      ;;\n    *-no-*-yes-*)\n      erl_wall_clock_func=gettimeofday\n      ;;\n    *)\n      erl_wall_clock_func=none\n      ;;\n  esac\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_CHECK_THR_LIB\ndnl\ndnl This macro may be used by any OTP application.\ndnl\ndnl LM_CHECK_THR_LIB sets THR_LIBS, THR_DEFS, and THR_LIB_NAME. It also\ndnl checks for some pthread headers which will appear in DEFS or config.h.\ndnl\n\nAC_DEFUN(LM_CHECK_THR_LIB,\n[\n\nNEED_NPTL_PTHREAD_H=no\n\ndnl win32?\nAC_MSG_CHECKING([for native win32 threads])\nif test \"X$host_os\" = \"Xwin32\"; then\n    AC_MSG_RESULT(yes)\n    THR_DEFS=\"-DWIN32_THREADS\"\n    THR_LIBS=\n    THR_LIB_NAME=win32_threads\n    THR_LIB_TYPE=win32_threads\nelse\n    AC_MSG_RESULT(no)\n    THR_DEFS=\n    THR_LIBS=\n    THR_LIB_NAME=\n    THR_LIB_TYPE=posix_unknown\n\ndnl Try to find POSIX threads\n\ndnl The usual pthread lib...\n    AC_CHECK_LIB(pthread, pthread_create, THR_LIBS=\"-lpthread\")\n\ndnl Very old versions of FreeBSD have pthreads in special c library, c_r...\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_CHECK_LIB(c_r, pthread_create, THR_LIBS=\"-lc_r\")\n    fi\n\ndnl QNX has pthreads in standard C library\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_CHECK_FUNC(pthread_create, THR_LIBS=\"none_needed\")\n    fi\n\ndnl On ofs1 the '-pthread' switch should be used\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_MSG_CHECKING([if the '-pthread' switch can be used])\n\tsaved_cflags=$CFLAGS\n\tCFLAGS=\"$CFLAGS -pthread\"\n\tAC_TRY_LINK([#include <pthread.h>],\n\t\t    pthread_create((void*)0,(void*)0,(void*)0,(void*)0);,\n\t\t    [THR_DEFS=\"-pthread\"\n\t\t     THR_LIBS=\"-pthread\"])\n\tCFLAGS=$saved_cflags\n\tif test \"x$THR_LIBS\" != \"x\"; then\n\t    AC_MSG_RESULT(yes)\n\telse\n\t    AC_MSG_RESULT(no)\n\tfi\n    fi\n\n    if test \"x$THR_LIBS\" != \"x\"; then\n\tTHR_DEFS=\"$THR_DEFS -D_THREAD_SAFE -D_REENTRANT -DPOSIX_THREADS\"\n\tTHR_LIB_NAME=pthread\n\tif test \"x$THR_LIBS\" = \"xnone_needed\"; then\n\t    THR_LIBS=\n\tfi\n\tcase $host_os in\n\t    solaris*)\n\t\tTHR_DEFS=\"$THR_DEFS -D_POSIX_PTHREAD_SEMANTICS\" ;;\n\t    linux*)\n\t\tTHR_DEFS=\"$THR_DEFS -D_POSIX_THREAD_SAFE_FUNCTIONS\"\n\n\t\tLM_CHECK_GETCONF\n\t\tAC_MSG_CHECKING(for Native POSIX Thread Library)\n\t\tlibpthr_vsn=`$GETCONF GNU_LIBPTHREAD_VERSION 2>/dev/null`\n\t\tif test $? -eq 0; then\n\t\t    case \"$libpthr_vsn\" in\n\t\t\t*nptl*|*NPTL*) nptl=yes;;\n\t\t\t*) nptl=no;;\n\t\t    esac\n\t\telif test \"$cross_compiling\" = \"yes\"; then\n\t\t    case \"$erl_xcomp_linux_nptl\" in\n\t\t\t\"\") nptl=cross;;\n\t\t\tyes|no) nptl=$erl_xcomp_linux_nptl;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_nptl value: $erl_xcomp_linux_nptl]);;\n\t\t    esac\n\t\telse\n\t\t    nptl=no\n\t\tfi\n\t\tAC_MSG_RESULT($nptl)\n\t\tif test $nptl = cross; then\n\t\t    nptl=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $nptl = yes; then\n\t\t    THR_LIB_TYPE=posix_nptl\n\t\t    need_nptl_incldir=no\n\t\t    AC_CHECK_HEADER(nptl/pthread.h,\n\t\t\t\t    [need_nptl_incldir=yes\n\t\t\t\t     NEED_NPTL_PTHREAD_H=yes])\n\t\t    if test $need_nptl_incldir = yes; then\n\t\t\t# Ahh...\n\t\t\tnptl_path=\"$C_INCLUDE_PATH:$CPATH\"\n\t\t\tif test X$cross_compiling != Xyes; then\n\t\t\t    nptl_path=\"$nptl_path:/usr/local/include:/usr/include\"\n\t\t\telse\n\t\t\t    IROOT=\"$erl_xcomp_isysroot\"\n\t\t\t    test \"$IROOT\" != \"\" || IROOT=\"$erl_xcomp_sysroot\"\n\t\t\t    test \"$IROOT\" != \"\" || AC_MSG_ERROR([Don't know where to search for includes! Please set erl_xcomp_isysroot])\n\t\t\t    nptl_path=\"$nptl_path:$IROOT/usr/local/include:$IROOT/usr/include\"\n\t\t\tfi\n\t\t\tnptl_ws_path=\n\t\t\tsave_ifs=\"$IFS\"; IFS=\":\"\n\t\t\tfor dir in $nptl_path; do\n\t\t\t    if test \"x$dir\" != \"x\"; then\n\t\t\t\tnptl_ws_path=\"$nptl_ws_path $dir\"\n\t\t\t    fi\n\t\t\tdone\n\t\t\tIFS=$save_ifs\n\t\t\tnptl_incldir=\n\t\t\tfor dir in $nptl_ws_path; do\n\t\t            AC_CHECK_HEADER($dir/nptl/pthread.h,\n\t\t\t\t\t    nptl_incldir=$dir/nptl)\n\t\t\t    if test \"x$nptl_incldir\" != \"x\"; then\n\t\t\t\tTHR_DEFS=\"$THR_DEFS -isystem $nptl_incldir\"\n\t\t\t\tbreak\n\t\t\t    fi\n\t\t\tdone\n\t\t\tif test \"x$nptl_incldir\" = \"x\"; then\n\t\t\t    AC_MSG_ERROR(Failed to locate nptl system include directory)\n\t\t\tfi\n\t\t    fi\n\t\tfi\n\t\t;;\n\t    *) ;;\n\tesac\n\n\tdnl We sometimes need THR_DEFS in order to find certain headers\n\tdnl (at least for pthread.h on osf1).\n\tsaved_cppflags=$CPPFLAGS\n\tCPPFLAGS=\"$CPPFLAGS $THR_DEFS\"\n\n\tdnl\n\tdnl Check for headers\n\tdnl\n\n\tAC_CHECK_HEADER(pthread.h,\n\t\t\tAC_DEFINE(HAVE_PTHREAD_H, 1, \\\n[Define if you have the <pthread.h> header file.]))\n\n\tdnl Some Linuxes have <pthread/mit/pthread.h> instead of <pthread.h>\n\tAC_CHECK_HEADER(pthread/mit/pthread.h, \\\n\t\t\tAC_DEFINE(HAVE_MIT_PTHREAD_H, 1, \\\n[Define if the pthread.h header file is in pthread/mit directory.]))\n\n\tdnl restore CPPFLAGS\n\tCPPFLAGS=$saved_cppflags\n\n    fi\nfi\n\n])\n\nAC_DEFUN(ERL_INTERNAL_LIBS,\n[\n\nERTS_INTERNAL_X_LIBS=\n\nAC_CHECK_LIB(kstat, kstat_open,\n[AC_DEFINE(HAVE_KSTAT, 1, [Define if you have kstat])\nERTS_INTERNAL_X_LIBS=\"$ERTS_INTERNAL_X_LIBS -lkstat\"])\n\nAC_SUBST(ERTS_INTERNAL_X_LIBS)\n\n])\n\nAC_DEFUN(ETHR_CHK_GCC_ATOMIC_OP__,\n[\n    # $1 - atomic_op\n\n    for atomic_bit_size in 32 64 128; do\n\tcase $atomic_bit_size in\n\t    32) gcc_atomic_type=\"$gcc_atomic_type32\";;\n\t    64) gcc_atomic_type=\"$gcc_atomic_type64\";;\n\t    128) gcc_atomic_type=\"$gcc_atomic_type128\";;\n\tesac\n\tgcc_atomic_lockfree=\"int x[[(2*__atomic_always_lock_free(sizeof($gcc_atomic_type), 0))-1]]\"\n\tcase $1 in\n\t    __sync_add_and_fetch | __sync_fetch_and_and | __sync_fetch_and_or)\n\t\tatomic_call=\"volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0);\"\n\t\t;;\n\t    __sync_val_compare_and_swap)\n\t\tatomic_call=\"volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0, ($gcc_atomic_type) 0);\"\n\t\t;;\n\t    __atomic_store_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELAXED); $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELEASE);\"\n\t\t;;\n\t    __atomic_load_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, __ATOMIC_RELAXED); res = $1(&var, __ATOMIC_ACQUIRE);\"\n\t\t;;\n\t    __atomic_add_fetch| __atomic_fetch_and | __atomic_fetch_or)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELAXED); res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_ACQUIRE); res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELEASE);\"\n\t\t;;\n\t    __atomic_compare_exchange_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type val; int res = $1(&var, &val, ($gcc_atomic_type) 0, 0, __ATOMIC_RELAXED, __ATOMIC_RELAXED); res = $1(&var, &val, ($gcc_atomic_type) 0, 0, __ATOMIC_ACQUIRE, __ATOMIC_ACQUIRE);\"\n\t\t;;\n\t    *)\n\t\tAC_MSG_ERROR([Internal error: missing implementation for $1])\n\t\t;;\n\tesac\n\teval atomic${atomic_bit_size}_call=\\\"$atomic_call\\\"\n    done\n    \n    AC_CACHE_CHECK([for 32-bit $1()], ethr_cv_32bit_$1,\n\t\t   [\n\t\t       ethr_cv_32bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic32_call], [ethr_cv_32bit_$1=yes])\n\t\t   ])\n    AC_CACHE_CHECK([for 64-bit $1()], ethr_cv_64bit_$1,\n\t\t   [\n\t\t       ethr_cv_64bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic64_call], [ethr_cv_64bit_$1=yes])\n\t\t   ])\n    AC_CACHE_CHECK([for 128-bit $1()], ethr_cv_128bit_$1,\n\t\t   [\n\t\t       ethr_cv_128bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic128_call], [ethr_cv_128bit_$1=yes])\n\t\t   ])\n\n\tcase $ethr_cv_128bit_$1-$ethr_cv_64bit_$1-$ethr_cv_32bit_$1 in\n\t    no-no-no)\n\t\thave_atomic_ops=0;;\n\t    no-no-yes)\n\t\thave_atomic_ops=4;;\n\t    no-yes-no)\n\t\thave_atomic_ops=8;;\n\t    no-yes-yes)\n\t\thave_atomic_ops=12;;\n\t    yes-no-no)\n\t\thave_atomic_ops=16;;\n\t    yes-no-yes)\n\t\thave_atomic_ops=20;;\n\t    yes-yes-no)\n\t\thave_atomic_ops=24;;\n\t    yes-yes-yes)\n\t\thave_atomic_ops=28;;\n\tesac\n\tAC_DEFINE_UNQUOTED([ETHR_HAVE_$1], [$have_atomic_ops], [Define as a bitmask corresponding to the word sizes that $1() can handle on your system])\n])\n\nAC_DEFUN(ETHR_CHK_IF_NOOP,\n[\n   ethr_test_filename=\"chk_if_$1$3_noop_config1test.$$\"\n   cat > \"${ethr_test_filename}.c\" <<EOF\nint\nmy_test(void)\n{\n    $1$2;\n    return 0;\n}\nEOF\n   $CC -O3 $ETHR_DEFS -c \"${ethr_test_filename}.c\" -o \"${ethr_test_filename}1.o\"\n   cat > \"${ethr_test_filename}.c\" <<EOF\nint\nmy_test(void)\n{\n    ;\n    return 0;\n}\nEOF\n   $CC -O3 $ETHR_DEFS -c \"${ethr_test_filename}.c\" -o \"${ethr_test_filename}2.o\"\n   if diff \"${ethr_test_filename}1.o\" \"${ethr_test_filename}2.o\" >/dev/null 2>&1; then\n      ethr_$1$3_noop=yes\n   else\n      ethr_$1$3_noop=no\n   fi\n   rm -f \"${ethr_test_filename}.c\" \"${ethr_test_filename}1.o\"  \"${ethr_test_filename}2.o\" \n])\n\nAC_DEFUN(ETHR_CHK_GCC_ATOMIC_OPS,\n[\n    AC_CHECK_SIZEOF(short)\n    AC_CHECK_SIZEOF(int)\n    AC_CHECK_SIZEOF(long)\n    AC_CHECK_SIZEOF(long long)\n    AC_CHECK_SIZEOF(__int128_t)\n\n    if test \"$ac_cv_sizeof_short\" = \"4\"; then\n\tgcc_atomic_type32=\"short\"\n    elif test \"$ac_cv_sizeof_int\" = \"4\"; then\n\tgcc_atomic_type32=\"int\"\n    elif test \"$ac_cv_sizeof_long\" = \"4\"; then\n\tgcc_atomic_type32=\"long\"\n    else\n\tAC_MSG_ERROR([No 32-bit type found])\n    fi\n\n    if test \"$ac_cv_sizeof_int\" = \"8\"; then\n\tgcc_atomic_type64=\"int\"\n    elif test \"$ac_cv_sizeof_long\" = \"8\"; then\n\tgcc_atomic_type64=\"long\"\n    elif test \"$ac_cv_sizeof_long_long\" = \"8\"; then\n\tgcc_atomic_type64=\"long long\"\n    else\n\tAC_MSG_ERROR([No 64-bit type found])\n    fi\n\n    if test \"$ac_cv_sizeof___int128_t\" = \"16\"; then\n\tgcc_atomic_type128=\"__int128_t\"\n    else\n\tgcc_atomic_type128=\"#error \"\t\n    fi\n    AC_CACHE_CHECK([for a working __sync_synchronize()], ethr_cv___sync_synchronize,\n\t\t   [\n\t\t       ethr_cv___sync_synchronize=no\n\t\t       AC_TRY_LINK([],\n\t\t\t\t   [ __sync_synchronize(); ],\n\t\t\t\t   [ethr_cv___sync_synchronize=yes])\n\t\t       if test $ethr_cv___sync_synchronize = yes; then\n\t\t\t   #\n\t\t\t   # Old gcc versions on at least x86 have a buggy\n\t\t\t   # __sync_synchronize() which does not emit a\n\t\t\t   # memory barrier. We try to detect this by\n\t\t\t   # compiling to assembly with and without\n\t\t\t   # __sync_synchronize() and compare the results.\n\t\t\t   #\n\t\t\t   ETHR_CHK_IF_NOOP(__sync_synchronize, [()], [])\n\t\t\t   if test $ethr___sync_synchronize_noop = yes; then\n\t\t\t      # Got a buggy implementation of\n\t\t\t      # __sync_synchronize...\n\t\t\t      ethr_cv___sync_synchronize=\"no; buggy implementation\"\n\t\t\t   fi\n\t\t       fi\n\t\t   ])\n\n    if test \"$ethr_cv___sync_synchronize\" = \"yes\"; then\n\thave_sync_synchronize_value=\"~0\"\n    else\n\thave_sync_synchronize_value=\"0\"\n    fi\n    AC_DEFINE_UNQUOTED([ETHR_HAVE___sync_synchronize], [$have_sync_synchronize_value], [Define as a bitmask corresponding to the word sizes that __sync_synchronize() can handle on your system])\n\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_add_and_fetch)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_fetch_and_and)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_fetch_and_or)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_val_compare_and_swap)\n\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_store_n)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_load_n)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_add_fetch)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_fetch_and)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_fetch_or)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_compare_exchange_n)\n\n    ethr_have_gcc_native_atomics=no\n    ethr_arm_dbm_instr_val=0\n    case \"$GCC-$host_cpu\" in\n\tyes-arm*)\n\t    AC_CACHE_CHECK([for ARM DMB instruction], ethr_cv_arm_dbm_instr,\n\t\t\t   [\n\t\t\t\tethr_cv_arm_dbm_instr=no\n\t\t\t\tAC_TRY_LINK([],\n\t\t\t\t\t    [\n\t\t\t\t\t\t__asm__ __volatile__(\"dmb sy\" : : : \"memory\");\n\t\t\t\t\t\t__asm__ __volatile__(\"dmb st\" : : : \"memory\");\n\t\t\t\t\t    ],\n\t\t\t\t\t    [ethr_cv_arm_dbm_instr=yes])\n\t\t\t   ])\n\t    if test $ethr_cv_arm_dbm_instr = yes; then\n\t\tethr_arm_dbm_instr_val=1\n\t\ttest $ethr_cv_64bit___atomic_compare_exchange_n = yes &&\n\t\t    ethr_have_gcc_native_atomics=yes\n\t    fi;;\n\t*)\n\t    ;;\n    esac\n    AC_DEFINE_UNQUOTED([ETHR_HAVE_GCC_ASM_ARM_DMB_INSTRUCTION], [$ethr_arm_dbm_instr_val], [Define as a boolean indicating whether you have a gcc compatible compiler capable of generating the ARM DMB instruction, and are compiling for an ARM processor with ARM DMB instruction support, or not])\n    test $ethr_cv_32bit___sync_val_compare_and_swap = yes &&\n    \tethr_have_gcc_native_atomics=yes\n    test $ethr_cv_64bit___sync_val_compare_and_swap = yes &&\n    \tethr_have_gcc_native_atomics=yes\n    if test \"$ethr_cv___sync_synchronize\" = \"yes\"; then\n    \ttest $ethr_cv_64bit___atomic_compare_exchange_n = yes &&\n    \t    ethr_have_gcc_native_atomics=yes\n    \ttest $ethr_cv_32bit___atomic_compare_exchange_n = yes &&\n    \t    ethr_have_gcc_native_atomics=yes\n    fi\n    ethr_have_gcc_atomic_builtins=0\n    if test $ethr_have_gcc_native_atomics = yes; then\n       ethr_native_atomic_implementation=gcc_sync\n       test $ethr_cv_32bit___atomic_compare_exchange_n = yes && ethr_have_gcc_atomic_builtins=1\n       test $ethr_cv_64bit___atomic_compare_exchange_n = yes && ethr_have_gcc_atomic_builtins=1\n       test $ethr_have_gcc_atomic_builtins = 1 && ethr_native_atomic_implementation=gcc_atomic_sync\n    fi\n    AC_DEFINE_UNQUOTED([ETHR_HAVE_GCC___ATOMIC_BUILTINS], [$ethr_have_gcc_atomic_builtins], [Define as a boolean indicating whether you have a gcc __atomic builtins or not])\n    test $ethr_have_gcc_native_atomics = yes && ethr_have_native_atomics=yes\n])\n\nAC_DEFUN(ETHR_CHK_INTERLOCKED,\n[\n    ilckd=\"$1\"\n    AC_MSG_CHECKING([for ${ilckd}()])\n    case \"$2\" in\n\t\"1\") ilckd_call=\"${ilckd}(var);\";;\n\t\"2\") ilckd_call=\"${ilckd}(var, ($3) 0);\";;\n\t\"3\") ilckd_call=\"${ilckd}(var, ($3) 0, ($3) 0);\";;\n\t\"4\") ilckd_call=\"${ilckd}(var, ($3) 0, ($3) 0, arr);\";;\n    esac\n    have_interlocked_op=no\n    AC_TRY_LINK(\n\t[\n\t#define WIN32_LEAN_AND_MEAN\n\t#include <windows.h>\n\t#include <intrin.h>\n\t],\n\t[\n\t    volatile $3 *var;\n\t    volatile $3 arr[2];\n\n\t    $ilckd_call\n\t    return 0;\n\t],\n\t[have_interlocked_op=yes])\n    test $have_interlocked_op = yes && $4\n    AC_MSG_RESULT([$have_interlocked_op])\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl ERL_FIND_ETHR_LIB\ndnl\ndnl NOTE! This macro may be changed at any time! Should *only* be used by\ndnl       ERTS!\ndnl\ndnl Find a thread library to use. Sets ETHR_LIBS to libraries to link\ndnl with, ETHR_X_LIBS to extra libraries to link with (same as ETHR_LIBS\ndnl except that the ethread lib itself is not included), ETHR_DEFS to\ndnl defines to compile with, ETHR_THR_LIB_BASE to the name of the\ndnl thread library which the ethread library is based on, and ETHR_LIB_NAME\ndnl to the name of the library where the ethread implementation is located.\ndnl  ERL_FIND_ETHR_LIB currently searches for 'pthreads', and\ndnl 'win32_threads'. If no thread library was found ETHR_LIBS, ETHR_X_LIBS,\ndnl ETHR_DEFS, ETHR_THR_LIB_BASE, and ETHR_LIB_NAME are all set to the\ndnl empty string.\ndnl\n\nAC_DEFUN(ERL_FIND_ETHR_LIB,\n[\n\nAC_ARG_ENABLE(native-ethr-impls,\n\t      AS_HELP_STRING([--disable-native-ethr-impls],\n                             [disable native ethread implementations]),\n[ case \"$enableval\" in\n    no) disable_native_ethr_impls=yes ;;\n    *)  disable_native_ethr_impls=no ;;\n  esac ], disable_native_ethr_impls=no)\n\ntest \"X$disable_native_ethr_impls\" = \"Xyes\" &&\n  AC_DEFINE(ETHR_DISABLE_NATIVE_IMPLS, 1, [Define if you want to disable native ethread implementations])\n\nAC_ARG_ENABLE(x86-out-of-order,\n\t      AS_HELP_STRING([--enable-x86-out-of-order],\n                             [enable x86/x84_64 out of order support (default disabled)]))\n\nAC_ARG_ENABLE(prefer-gcc-native-ethr-impls,\n\t      AS_HELP_STRING([--enable-prefer-gcc-native-ethr-impls],\n\t\t\t     [prefer gcc native ethread implementations]),\n[ case \"$enableval\" in\n    yes) enable_prefer_gcc_native_ethr_impls=yes ;;\n    *)  enable_prefer_gcc_native_ethr_impls=no ;;\n  esac ], enable_prefer_gcc_native_ethr_impls=no)\n\ntest $enable_prefer_gcc_native_ethr_impls = yes &&\n  AC_DEFINE(ETHR_PREFER_GCC_NATIVE_IMPLS, 1, [Define if you prefer gcc native ethread implementations])\n\nAC_ARG_ENABLE(trust-gcc-atomic-builtins-memory-barriers,\n\t      AS_HELP_STRING([--enable-trust-gcc-atomic-builtins-memory-barriers],\n\t\t\t     [trust gcc atomic builtins memory barriers]),\n[ case \"$enableval\" in\n    yes) trust_gcc_atomic_builtins_mbs=1 ;;\n    *) trust_gcc_atomic_builtins_mbs=0 ;;\n  esac ], trust_gcc_atomic_builtins_mbs=0)\n\nAC_DEFINE_UNQUOTED(ETHR_TRUST_GCC_ATOMIC_BUILTINS_MEMORY_BARRIERS, [$trust_gcc_atomic_builtins_mbs], [Define as a boolean indicating whether you trust gcc's __atomic_* builtins memory barrier implementations, or not])\n\nAC_ARG_WITH(libatomic_ops,\n\t    AS_HELP_STRING([--with-libatomic_ops=PATH],\n\t\t\t   [specify and prefer usage of libatomic_ops in the ethread library]))\n\nAC_ARG_WITH(with_sparc_memory_order,\n\t    AS_HELP_STRING([--with-sparc-memory-order=TSO|PSO|RMO],\n\t\t\t   [specify sparc memory order (defaults to RMO)]))\n\nLM_CHECK_THR_LIB\nERL_INTERNAL_LIBS\n\nERL_MONOTONIC_CLOCK(try_find_pthread_compatible, CLOCK_HIGHRES CLOCK_MONOTONIC, no)\n\ncase $erl_monotonic_clock_func in\n  clock_gettime)\n    AC_DEFINE(ETHR_HAVE_CLOCK_GETTIME_MONOTONIC, [1], [Define if you have a clock_gettime() with a monotonic clock])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(ETHR_HAVE_MACH_CLOCK_GET_TIME, [1], [Define if you have a mach clock_get_time() with a monotonic clock])\n    ;;\n  gethrtime)\n    AC_DEFINE(ETHR_HAVE_GETHRTIME, [1], [Define if you have a monotonic gethrtime()])\n    ;;\n  *)\n    ;;\nesac\n\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(ETHR_MONOTONIC_CLOCK_ID, [$erl_monotonic_clock_id], [Define to the monotonic clock id to use])\nfi\n\nethr_native_atomic_implementation=none\nethr_have_native_atomics=no\nethr_have_native_spinlock=no\nETHR_THR_LIB_BASE=\"$THR_LIB_NAME\"\nETHR_THR_LIB_BASE_TYPE=\"$THR_LIB_TYPE\"\nETHR_DEFS=\"$THR_DEFS\"\nETHR_X_LIBS=\"$THR_LIBS $ERTS_INTERNAL_X_LIBS $erl_monotonic_clock_lib\"\nETHR_LIBS=\nETHR_LIB_NAME=\n\nethr_modified_default_stack_size=\n\nAC_ARG_WITH(threadnames,\nAS_HELP_STRING([--with-threadnames], [use pthread_setname to set the thread names (default)])\nAS_HELP_STRING([--without-threadnames],\n               [do not set any thread names]),\n[],\n[with_threadnames=yes])\n\ndnl Name of lib where ethread implementation is located\nethr_lib_name=ethread\n\ncase \"$THR_LIB_NAME\" in\n\n    win32_threads)\n\tETHR_THR_LIB_BASE_DIR=win\n\t# * _WIN32_WINNT >= 0x0400 is needed for\n\t#   TryEnterCriticalSection\n\t# * _WIN32_WINNT >= 0x0403 is needed for\n\t#   InitializeCriticalSectionAndSpinCount\n\t# The ethread lib will refuse to build if _WIN32_WINNT < 0x0403.\n\t#\n\t# -D_WIN32_WINNT should have been defined in $CPPFLAGS; fetch it\n\t# and save it in ETHR_DEFS.\n\tfound_win32_winnt=no\n\tfor cppflag in $CPPFLAGS; do\n\t    case $cppflag in\n\t\t-DWINVER*)\n\t\t    ETHR_DEFS=\"$ETHR_DEFS $cppflag\"\n\t\t    ;;\n\t\t-D_WIN32_WINNT*)\n\t\t    ETHR_DEFS=\"$ETHR_DEFS $cppflag\"\n\t\t    found_win32_winnt=yes\n\t\t    ;;\n\t\t*)\n\t\t    ;;\n\t    esac\n        done\n        if test $found_win32_winnt = no; then\n\t    AC_MSG_ERROR([-D_WIN32_WINNT missing in CPPFLAGS])\n        fi\n\n\tAC_DEFINE(ETHR_WIN32_THREADS, 1, [Define if you have win32 threads])\n\n\tif test \"X$disable_native_ethr_impls\" = \"Xyes\"; then\n\t    have_interlocked_op=no\n\t    ethr_have_native_atomics=no\n\telse\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT, 1, [Define if you have _InterlockedDecrement()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement_rel], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT_REL, 1, [Define if you have _InterlockedDecrement_rel()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT, 1, [Define if you have _InterlockedIncrement()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement_acq], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT_ACQ, 1, [Define if you have _InterlockedIncrement_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD, 1, [Define if you have _InterlockedExchangeAdd()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd_acq], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD_ACQ, 1, [Define if you have _InterlockedExchangeAdd_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedAnd], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDAND, 1, [Define if you have _InterlockedAnd()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedOr], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDOR, 1, [Define if you have _InterlockedOr()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchange], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGE, 1, [Define if you have _InterlockedExchange()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE, 1, [Define if you have _InterlockedCompareExchange()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange_acq], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE_ACQ, 1, [Define if you have _InterlockedCompareExchange_acq()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange_rel], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE_REL, 1, [Define if you have _InterlockedCompareExchange_rel()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement64], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT64, 1, [Define if you have _InterlockedDecrement64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement64_rel], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT64_REL, 1, [Define if you have _InterlockedDecrement64_rel()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement64], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT64, 1, [Define if you have _InterlockedIncrement64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement64_acq], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT64_ACQ, 1, [Define if you have _InterlockedIncrement64_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD64, 1, [Define if you have _InterlockedExchangeAdd64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd64_acq], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD64_ACQ, 1, [Define if you have _InterlockedExchangeAdd64_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedAnd64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDAND64, 1, [Define if you have _InterlockedAnd64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedOr64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDOR64, 1, [Define if you have _InterlockedOr64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchange64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGE64, 1, [Define if you have _InterlockedExchange64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64, 1, [Define if you have _InterlockedCompareExchange64()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64_acq], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64_ACQ, 1, [Define if you have _InterlockedCompareExchange64_acq()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64_rel], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64_REL, 1, [Define if you have _InterlockedCompareExchange64_rel()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange128], [4], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE128, 1, [Define if you have _InterlockedCompareExchange128()]))\n\tfi\n\tif test \"$ethr_have_native_atomics\" = \"yes\"; then\n\t   ethr_native_atomic_implementation=windows\n\t   ethr_have_native_spinlock=yes\n\tfi\n\t;;\n\n    pthread)\n\tETHR_THR_LIB_BASE_DIR=pthread\n\tAC_DEFINE(ETHR_PTHREADS, 1, [Define if you have pthreads])\n\tcase $host_os in\n\t    openbsd*)\n\t\t# The default stack size is insufficient for our needs\n\t\t# on OpenBSD. We increase it to 256 kilo words.\n\t\tethr_modified_default_stack_size=256;;\n\t    linux*)\n\t\tETHR_DEFS=\"$ETHR_DEFS -D_GNU_SOURCE\"\n\n\t\tif test\tX$cross_compiling = Xyes; then\n\t\t    case X$erl_xcomp_linux_usable_sigusrx in\n\t\t\tX) usable_sigusrx=cross;;\n\t\t\tXyes|Xno) usable_sigusrx=$erl_xcomp_linux_usable_sigusrx;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_usable_sigusrx value: $erl_xcomp_linux_usable_sigusrx]);;\n\t\t    esac\n\t\t    case X$erl_xcomp_linux_usable_sigaltstack in\n\t\t\tX) usable_sigaltstack=cross;;\n\t\t\tXyes|Xno) usable_sigaltstack=$erl_xcomp_linux_usable_sigaltstack;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_usable_sigaltstack value: $erl_xcomp_linux_usable_sigaltstack]);;\n\t\t    esac\n\t\telse\n\t\t    # FIXME: Test for actual problems instead of kernel versions\n\t\t    linux_kernel_vsn_=`uname -r`\n\t\t    case $linux_kernel_vsn_ in\n\t\t\t[[0-1]].*|2.[[0-1]]|2.[[0-1]].*)\n\t\t\t    usable_sigusrx=no\n\t\t\t    usable_sigaltstack=no;;\n\t\t\t2.[[2-3]]|2.[[2-3]].*)\n\t\t\t    usable_sigusrx=yes\n\t\t\t    usable_sigaltstack=no;;\n\t\t    \t*)\n\t\t\t    usable_sigusrx=yes\n\t\t\t    usable_sigaltstack=yes;;\n\t\t    esac\n\t\tfi\n\n\t\tAC_MSG_CHECKING(if SIGUSR1 and SIGUSR2 can be used)\n\t\tAC_MSG_RESULT($usable_sigusrx)\n\t\tif test $usable_sigusrx = cross; then\n\t\t    usable_sigusrx=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $usable_sigusrx = no; then\n\t\t    ETHR_DEFS=\"$ETHR_DEFS -DETHR_UNUSABLE_SIGUSRX\"\n\t\tfi\n\n\t\tAC_MSG_CHECKING(if sigaltstack can be used)\n\t\tAC_MSG_RESULT($usable_sigaltstack)\n\t\tif test $usable_sigaltstack = cross; then\n\t\t    usable_sigaltstack=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $usable_sigaltstack = no; then\n\t\t    ETHR_DEFS=\"$ETHR_DEFS -DETHR_UNUSABLE_SIGALTSTACK\"\n\t\tfi\n\t\t;;\n\t    *) ;;\n\tesac\n\n\tdnl We sometimes need ETHR_DEFS in order to find certain headers\n\tdnl (at least for pthread.h on osf1).\n\tsaved_cppflags=\"$CPPFLAGS\"\n\tCPPFLAGS=\"$CPPFLAGS $ETHR_DEFS\"\n\n\tdnl We need the thread library in order to find some functions\n\tsaved_libs=\"$LIBS\"\n\tLIBS=\"$LIBS $ETHR_X_LIBS\"\n\n\tdnl\n\tdnl Check for headers\n\tdnl\n\tAC_CHECK_HEADER(pthread.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_H, 1, \\\n[Define if you have the <pthread.h> header file.]))\n\n\tdnl Some Linuxes have <pthread/mit/pthread.h> instead of <pthread.h>\n\tAC_CHECK_HEADER(pthread/mit/pthread.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_MIT_PTHREAD_H, 1, \\\n[Define if the pthread.h header file is in pthread/mit directory.]))\n\n\tif test $NEED_NPTL_PTHREAD_H = yes; then\n\t    AC_DEFINE(ETHR_NEED_NPTL_PTHREAD_H, 1, \\\n[Define if you need the <nptl/pthread.h> header file.])\n\tfi\n\n\tAC_CHECK_HEADER(sched.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_SCHED_H, 1, \\\n[Define if you have the <sched.h> header file.]))\n\n\tAC_CHECK_HEADER(sys/time.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_SYS_TIME_H, 1, \\\n[Define if you have the <sys/time.h> header file.]))\n\n\tAC_TRY_COMPILE([#include <time.h>\n\t\t\t#include <sys/time.h>], \n\t\t\t[struct timeval *tv; return 0;],\n\t\t\tAC_DEFINE(ETHR_TIME_WITH_SYS_TIME, 1, \\\n[Define if you can safely include both <sys/time.h> and <time.h>.]))\n\n\tAC_MSG_CHECKING([for usable PTHREAD_STACK_MIN])\n\tpthread_stack_min=no\n\tAC_TRY_COMPILE([\n#include <limits.h>\n#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n#include <nptl/pthread.h>\n#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n#include <pthread/mit/pthread.h>\n#elif defined(ETHR_HAVE_PTHREAD_H)\n#include <pthread.h>\n#endif\n\t\t\t], \n\t\t\t[return PTHREAD_STACK_MIN;],\n\t\t\t[pthread_stack_min=yes])\n\n\tAC_MSG_RESULT([$pthread_stack_min])\n\ttest $pthread_stack_min != yes || {\n\t     AC_DEFINE(ETHR_HAVE_USABLE_PTHREAD_STACK_MIN, 1, [Define if you can use PTHREAD_STACK_MIN])\n\t}\n\n\tdnl\n\tdnl Check for functions\n\tdnl\n\tAC_CHECK_FUNC(pthread_spin_lock, \\\n\t\t\t[ethr_have_native_spinlock=yes \\\n\t\t\t AC_DEFINE(ETHR_HAVE_PTHREAD_SPIN_LOCK, 1, \\\n[Define if you have the pthread_spin_lock function.])])\n\n\thave_sched_yield=no\n\thave_librt_sched_yield=no\n\tAC_CHECK_FUNC(sched_yield, [have_sched_yield=yes])\n\tif test $have_sched_yield = no; then\n\t    AC_CHECK_LIB(rt, sched_yield,\n\t\t\t [have_librt_sched_yield=yes\n\t\t\t  ETHR_X_LIBS=\"$ETHR_X_LIBS -lrt\"])\n\tfi\n\tif test $have_sched_yield = yes || test $have_librt_sched_yield = yes; then\n\t    AC_DEFINE(ETHR_HAVE_SCHED_YIELD, 1, [Define if you have the sched_yield() function.])\n\t    AC_MSG_CHECKING([whether sched_yield() returns an int])\n\t    sched_yield_ret_int=no\n\t    AC_TRY_LINK([\n\t\t\t\t#ifdef ETHR_HAVE_SCHED_H\n\t\t\t\t#include <sched.h>\n\t\t\t\t#endif\n\t\t\t   ],\n\t\t\t   [int sched_yield();],\n\t\t\t   [sched_yield_ret_int=yes])\n\t    AC_MSG_RESULT([$sched_yield_ret_int])\n\t    if test $sched_yield_ret_int = yes; then\n\t\tAC_DEFINE(ETHR_SCHED_YIELD_RET_INT, 1, [Define if sched_yield() returns an int.])\n\t    fi\n\tfi\n\n\thave_pthread_yield=no\n\tAC_CHECK_FUNC(pthread_yield, [have_pthread_yield=yes])\n\tif test $have_pthread_yield = yes; then\n\t    AC_DEFINE(ETHR_HAVE_PTHREAD_YIELD, 1, [Define if you have the pthread_yield() function.])\n\t    AC_MSG_CHECKING([whether pthread_yield() returns an int])\n\t    pthread_yield_ret_int=no\n\t    AC_TRY_LINK([\n\t\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t\t#include <nptl/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t\t#include <pthread/mit/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t\t#include <pthread.h>\n\t\t\t\t#endif\n\t\t\t   ],\n\t\t\t   [int pthread_yield();],\n\t\t\t   [pthread_yield_ret_int=yes])\n\t    AC_MSG_RESULT([$pthread_yield_ret_int])\n\t    if test $pthread_yield_ret_int = yes; then\n\t\tAC_DEFINE(ETHR_PTHREAD_YIELD_RET_INT, 1, [Define if pthread_yield() returns an int.])\n\t    fi\n\tfi\n\n\thave_pthread_rwlock_init=no\n\tAC_CHECK_FUNC(pthread_rwlock_init, [have_pthread_rwlock_init=yes])\n\tif test $have_pthread_rwlock_init = yes; then\n\n\t    ethr_have_pthread_rwlockattr_setkind_np=no\n\t    AC_CHECK_FUNC(pthread_rwlockattr_setkind_np,\n\t\t\t  [ethr_have_pthread_rwlockattr_setkind_np=yes])\n\n\t    if test $ethr_have_pthread_rwlockattr_setkind_np = yes; then\n\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_RWLOCKATTR_SETKIND_NP, 1, \\\n[Define if you have the pthread_rwlockattr_setkind_np() function.])\n\n\t\tAC_MSG_CHECKING([for PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP])\n\t\tethr_pthread_rwlock_writer_nonrecursive_initializer_np=no\n\t\tAC_TRY_LINK([\n\t\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t\t#include <nptl/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t\t#include <pthread/mit/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t\t#include <pthread.h>\n\t\t\t\t#endif\n\t\t\t    ],\n\t\t\t    [\n\t\t\t\tpthread_rwlockattr_t *attr;\n\t\t\t\treturn pthread_rwlockattr_setkind_np(attr,\n\t\t\t\t    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n\t\t\t    ],\n\t\t\t    [ethr_pthread_rwlock_writer_nonrecursive_initializer_np=yes])\n\t\tAC_MSG_RESULT([$ethr_pthread_rwlock_writer_nonrecursive_initializer_np])\n\t\tif test $ethr_pthread_rwlock_writer_nonrecursive_initializer_np = yes; then\n\t\t    AC_DEFINE(ETHR_HAVE_PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, 1, \\\n[Define if you have the PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP rwlock attribute.])\n\t\tfi\n\t    fi\n\tfi\n\n\tif test \"$force_pthread_rwlocks\" = \"yes\"; then\n\n\t    AC_DEFINE(ETHR_FORCE_PTHREAD_RWLOCK, 1, \\\n[Define if you want to force usage of pthread rwlocks])\n\n\t    if test $have_pthread_rwlock_init = yes; then\n\t\tAC_MSG_WARN([Forced usage of pthread rwlocks. Note that this implementation may suffer from starvation issues.])\n\t    else\n\t\tAC_MSG_ERROR([User forced usage of pthread rwlock, but no such implementation was found])\n\t    fi\n\tfi\n\n\tAC_CHECK_FUNC(pthread_attr_setguardsize, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_ATTR_SETGUARDSIZE, 1, \\\n[Define if you have the pthread_attr_setguardsize function.]))\n\n\tif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n\t  AC_MSG_CHECKING(whether pthread_cond_timedwait() can use the monotonic clock $erl_monotonic_clock_id for timeout)\n\t  pthread_cond_timedwait_monotonic=no\n\t  AC_TRY_LINK([\n\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t#  include <nptl/pthread.h>\n\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t#  include <pthread/mit/pthread.h>\n\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t#  include <pthread.h>\n\t\t\t#endif\n\t\t\t#ifdef ETHR_TIME_WITH_SYS_TIME\n\t\t\t#  include <time.h>\n\t\t\t#  include <sys/time.h>\n\t\t\t#else\n\t\t\t#  ifdef ETHR_HAVE_SYS_TIME_H\n\t\t\t#    include <sys/time.h>\n\t\t\t#  else\n\t\t\t#    include <time.h>\n\t\t\t#  endif\n\t\t\t#endif\n\t\t\t#if defined(ETHR_HAVE_MACH_CLOCK_GET_TIME)\n\t\t\t#  include <mach/clock.h>\n\t\t\t#  include <mach/mach.h>\n\t\t\t#endif\n\t\t\t], \n\t\t\t[\n\t\t\tint res;\n\t\t\tpthread_condattr_t attr;\n\t\t\tpthread_cond_t cond;\n\t\t\tstruct timespec cond_timeout;\n\t\t\tpthread_mutex_t mutex;\n\t\t\tres = pthread_condattr_init(&attr);\n\t\t\tres = pthread_condattr_setclock(&attr, ETHR_MONOTONIC_CLOCK_ID);\n\t\t\tres = pthread_cond_init(&cond, &attr);\n\t\t\tres = pthread_cond_timedwait(&cond, &mutex, &cond_timeout);\n\t\t\t],\n\t\t\t[pthread_cond_timedwait_monotonic=yes])\n\t  AC_MSG_RESULT([$pthread_cond_timedwait_monotonic])\n\t  if test $pthread_cond_timedwait_monotonic = yes; then\n\t    AC_DEFINE(ETHR_HAVE_PTHREAD_COND_TIMEDWAIT_MONOTONIC, [1], [Define if pthread_cond_timedwait() can be used with a monotonic clock])\n\t  fi\n\tfi\n\n\tlinux_futex=no\n\tAC_MSG_CHECKING([for Linux futexes])\n\tAC_TRY_LINK([\n\t\t\t#include <sys/syscall.h>\n\t\t\t#include <unistd.h>\n\t\t\t#include <linux/futex.h>\n\t\t\t#include <sys/time.h>\n\t\t    ],\n\t\t    [\n\t\t\tint i = 1;\n\t\t\tsyscall(__NR_futex, (void *) &i, FUTEX_WAKE, 1,\n\t\t\t\t(void*)0,(void*)0, 0);\n\t\t\tsyscall(__NR_futex, (void *) &i, FUTEX_WAIT, 0,\n\t\t\t\t(void*)0,(void*)0, 0);\n\t\t\treturn 0;\n\t\t    ],\n\t\t    linux_futex=yes)\n\tAC_MSG_RESULT([$linux_futex])\n\ttest $linux_futex = yes && AC_DEFINE(ETHR_HAVE_LINUX_FUTEX, 1, [Define if you have a linux futex implementation.])\n\n\tpthread_setname=no\n\tAC_MSG_CHECKING([for pthread_setname_np])\n\told_CFLAGS=$CFLAGS\n\tCFLAGS=\"$CFLAGS -Werror\"\n\tAC_TRY_LINK([#define __USE_GNU\n                     #include <pthread.h>],\n                    [pthread_setname_np(pthread_self(), \"name\");],\n                    pthread_setname=linux)\n\tAC_TRY_LINK([#define __USE_GNU\n                     #include <pthread.h>],\n                    [pthread_set_name_np(pthread_self(), \"name\");],\n                    pthread_setname=bsd)\n\tAC_TRY_LINK([#define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [pthread_setname_np(\"name\");],\n                    pthread_setname=darwin)\n        AC_MSG_RESULT([$pthread_setname])\n        case $with_threadnames-$pthread_setname in\n             yes-linux) AC_DEFINE(ETHR_HAVE_PTHREAD_SETNAME_NP_2, 1,\n                          [Define if you have linux style pthread_setname_np]);;\n             yes-bsd) AC_DEFINE(ETHR_HAVE_PTHREAD_SET_NAME_NP_2, 1,\n                          [Define if you have bsd style pthread_set_name_np]);;\n             yes-darwin) AC_DEFINE(ETHR_HAVE_PTHREAD_SETNAME_NP_1, 1,\n                          [Define if you have darwin style pthread_setname_np]);;\n             *) ;;\n\tesac\n\n\tpthread_getname=no\n\tAC_MSG_CHECKING([for pthread_getname_np])\n\tAC_TRY_LINK([#define __USE_GNU\n                     #define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [char buff[256]; pthread_getname_np(pthread_self(), buff, 256);],\n                    pthread_getname=linux)\n\tAC_TRY_LINK([#define __USE_GNU\n                     #define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [char buff[256]; pthread_getname_np(pthread_self(), buff);],\n                    pthread_getname=ibm)\n        AC_MSG_RESULT([$pthread_getname])\n        case $pthread_getname in\n             linux) AC_DEFINE(ETHR_HAVE_PTHREAD_GETNAME_NP_3, 1,\n                          [Define if you have linux style pthread_getname_np]);;\n             ibm) AC_DEFINE(ETHR_HAVE_PTHREAD_GETNAME_NP_2, 1,\n                          [Define if you have ibm style pthread_getname_np]);;\n             *) ;;\n\tesac\n\tCFLAGS=$old_CFLAGS\n\n\tif test \"X$disable_native_ethr_impls\" = \"Xyes\"; then\n\t    ethr_have_native_atomics=no\n\telse\n\n\t    ETHR_CHK_GCC_ATOMIC_OPS([])\n\n\t    AC_MSG_CHECKING([for a usable libatomic_ops implementation])\n\t    case \"x$with_libatomic_ops\" in\n\t        xno | xyes | x)\n\t    \t    libatomic_ops_include=\n\t    \t    ;;\n\t        *)\n\t    \t    if test -d \"${with_libatomic_ops}/include\"; then\n\t    \t        libatomic_ops_include=\"-I$with_libatomic_ops/include\"\n\t    \t        CPPFLAGS=\"$CPPFLAGS $libatomic_ops_include\"\n\t    \t    else\n\t    \t        AC_MSG_ERROR([libatomic_ops include directory $with_libatomic_ops/include not found])\n\t    \t    fi;;\n\t    esac\n\t    ethr_have_libatomic_ops=no\n\t    AC_TRY_LINK([#include \"atomic_ops.h\"],\n\t    \t        [\n\t    \t    \t    volatile AO_t x;\n\t    \t    \t    AO_t y;\n\t    \t    \t    int z;\n\n\t    \t    \t    AO_nop_full();\n#if defined(AO_HAVE_store)\n\t    \t    \t    AO_store(&x, (AO_t) 0);\n#elif defined(AO_HAVE_store_release)\n\t    \t    \t    AO_store_release(&x, (AO_t) 0);\n#else\n#error No store\n#endif\n#if defined(AO_HAVE_load)\n\t    \t    \t    z = AO_load(&x);\n#elif defined(AO_HAVE_load_acquire)\n\t    \t    \t    z = AO_load_acquire(&x);\n#else\n#error No load\n#endif\n#if defined(AO_HAVE_compare_and_swap_full)\n\t    \t    \t    z = AO_compare_and_swap_full(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap_release)\n\t    \t    \t    z = AO_compare_and_swap_release(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap_acquire)\n\t    \t    \t    z = AO_compare_and_swap_acquire(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap)\n\t    \t    \t    z = AO_compare_and_swap(&x, (AO_t) 0, (AO_t) 1);\n#else\n#error No compare_and_swap\n#endif\n\t    \t        ],\n\t    \t        [ethr_have_native_atomics=yes\n\t\t\t ethr_native_atomic_implementation=libatomic_ops\n\t    \t         ethr_have_libatomic_ops=yes])\n\t    AC_MSG_RESULT([$ethr_have_libatomic_ops])\n\t    if test $ethr_have_libatomic_ops = yes; then\n\t        AC_CHECK_SIZEOF(AO_t, ,\n\t    \t    \t        [\n\t    \t    \t    \t    #include <stdio.h>\n\t    \t    \t    \t    #include \"atomic_ops.h\"\n\t    \t    \t        ])\n\t        AC_DEFINE_UNQUOTED(ETHR_SIZEOF_AO_T, $ac_cv_sizeof_AO_t, [Define to the size of AO_t if libatomic_ops is used])\n\n\t        AC_DEFINE(ETHR_HAVE_LIBATOMIC_OPS, 1, [Define if you have libatomic_ops atomic operations])\n\t        if test \"x$with_libatomic_ops\" != \"xno\" && test \"x$with_libatomic_ops\" != \"x\"; then\n\t    \t    AC_DEFINE(ETHR_PREFER_LIBATOMIC_OPS_NATIVE_IMPLS, 1, [Define if you prefer libatomic_ops native ethread implementations])\n\t        fi\n\t        ETHR_DEFS=\"$ETHR_DEFS $libatomic_ops_include\"\n\t    elif test \"x$with_libatomic_ops\" != \"xno\" && test \"x$with_libatomic_ops\" != \"x\"; then\n\t        AC_MSG_ERROR([No usable libatomic_ops implementation found])\n\t    fi\n\n\t    case \"$host_cpu\" in\n\t      sparc | sun4u | sparc64 | sun4v)\n\t    \t    case \"$with_sparc_memory_order\" in\n\t    \t        \"TSO\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_TSO, 1, [Define if only run in Sparc TSO mode]);;\n\t    \t        \"PSO\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_PSO, 1, [Define if only run in Sparc PSO, or TSO mode]);;\n\t    \t        \"RMO\"|\"\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_RMO, 1, [Define if run in Sparc RMO, PSO, or TSO mode]);;\n\t    \t        *)\n\t    \t    \t    AC_MSG_ERROR([Unsupported Sparc memory order: $with_sparc_memory_order]);;\n\t    \t    esac\n\t\t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;; \n\t      i86pc | i*86 | x86_64 | amd64)\n\t    \t    if test \"$enable_x86_out_of_order\" = \"yes\"; then\n\t    \t    \t    AC_DEFINE(ETHR_X86_OUT_OF_ORDER, 1, [Define if x86/x86_64 out of order instructions should be synchronized])\n\t    \t    fi\n\t\t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      macppc | ppc | powerpc | \"Power Macintosh\")\n\t      \t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      tile)\n\t            ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      *)\n\t    \t    ;;\n\t    esac\n\n\tfi\n\n\ttest ethr_have_native_atomics = \"yes\" && ethr_have_native_spinlock=yes\n\n\tdnl Restore LIBS\n\tLIBS=$saved_libs\n\tdnl restore CPPFLAGS\n\tCPPFLAGS=$saved_cppflags\n\n\t;;\n    *)\n\t;;\nesac\n\nAC_MSG_CHECKING([whether default stack size should be modified])\nif test \"x$ethr_modified_default_stack_size\" != \"x\"; then\n\tAC_DEFINE_UNQUOTED(ETHR_MODIFIED_DEFAULT_STACK_SIZE, $ethr_modified_default_stack_size, [Define if you want to modify the default stack size])\n\tAC_MSG_RESULT([yes; to $ethr_modified_default_stack_size kilo words])\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nif test \"x$ETHR_THR_LIB_BASE\" != \"x\"; then\n\tETHR_DEFS=\"-DUSE_THREADS $ETHR_DEFS\"\n\tETHR_LIBS=\"-l$ethr_lib_name -lerts_internal_r $ETHR_X_LIBS\"\n\tETHR_LIB_NAME=$ethr_lib_name\nfi\n\nAC_CHECK_SIZEOF(void *)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_PTR, $ac_cv_sizeof_void_p, [Define to the size of pointers])\n\nAC_CHECK_SIZEOF(int)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_INT, $ac_cv_sizeof_int, [Define to the size of int])\nAC_CHECK_SIZEOF(long)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_LONG, $ac_cv_sizeof_long, [Define to the size of long])\nAC_CHECK_SIZEOF(long long)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_LONG_LONG, $ac_cv_sizeof_long_long, [Define to the size of long long])\nAC_CHECK_SIZEOF(__int64)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF___INT64, $ac_cv_sizeof___int64, [Define to the size of __int64])\nAC_CHECK_SIZEOF(__int128_t)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF___INT128_T, $ac_cv_sizeof___int128_t, [Define to the size of __int128_t])\n\n\ncase X$erl_xcomp_bigendian in\n    X) ;;\n    Xyes|Xno) ac_cv_c_bigendian=$erl_xcomp_bigendian;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_bigendian value: $erl_xcomp_bigendian]);;\nesac\n\nAC_C_BIGENDIAN\n\nif test \"$ac_cv_c_bigendian\" = \"yes\"; then\n    AC_DEFINE(ETHR_BIGENDIAN, 1, [Define if bigendian])\nfi\n\ncase X$erl_xcomp_double_middle_endian in\n    X) ;;\n    Xyes|Xno|Xunknown) ac_cv_c_double_middle_endian=$erl_xcomp_double_middle_endian;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_double_middle_endian value: $erl_xcomp_double_middle_endian]);;\nesac\n\nAC_C_DOUBLE_MIDDLE_ENDIAN\n\nETHR_X86_SSE2_ASM=no\ncase \"$GCC-$ac_cv_sizeof_void_p-$host_cpu\" in\n  yes-4-i86pc | yes-4-i*86 | yes-4-x86_64 | yes-4-amd64)\n    AC_MSG_CHECKING([for gcc sse2 asm support])\n    save_CFLAGS=\"$CFLAGS\"\n    CFLAGS=\"$CFLAGS -msse2\"\n    gcc_sse2_asm=no\n    AC_TRY_COMPILE([],\n\t[\n\t\tlong long x, *y;\n\t\t__asm__ __volatile__(\"movq %1, %0\\n\\t\" : \"=x\"(x) : \"m\"(*y) : \"memory\");\n\t],\n\t[gcc_sse2_asm=yes])\n    CFLAGS=\"$save_CFLAGS\"\n    AC_MSG_RESULT([$gcc_sse2_asm])\n    if test \"$gcc_sse2_asm\" = \"yes\"; then\n      AC_DEFINE(ETHR_GCC_HAVE_SSE2_ASM_SUPPORT, 1, [Define if you use a gcc that supports -msse2 and understand sse2 specific asm statements])\n      ETHR_X86_SSE2_ASM=yes\n    fi\n    ;;\n  *)\n    ;;\nesac\n\ncase \"$GCC-$host_cpu\" in\n  yes-i86pc | yes-i*86 | yes-x86_64 | yes-amd64)\n\n    if test $ac_cv_sizeof_void_p = 4; then\n       dw_cmpxchg=\"cmpxchg8b\"\n    else\n       dw_cmpxchg=\"cmpxchg16b\"\n    fi\n\n    gcc_dw_cmpxchg_asm=no\n    gcc_pic_dw_cmpxchg_asm=no\n    gcc_cflags_pic=no\n    gcc_cmpxchg8b_pic_no_clobber_ebx=no\n    gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage=no\n\n    save_CFLAGS=\"$CFLAGS\"\n\n    # Check if it works out of the box using passed CFLAGS\n    # and with -fPIC added to CFLAGS if the passed CFLAGS\n    # doesn't trigger position independent code\n    pic_cmpxchg=unknown\n    while true; do\n\n        case $pic_cmpxchg in\n\t  yes) pic_text=\"pic \";;\n\t  *) pic_text=\"\";;\n\tesac\n\n\tAC_MSG_CHECKING([for gcc $pic_text$dw_cmpxchg plain asm support])    \n\n\tplain_cmpxchg=no\n    \tAC_TRY_COMPILE([],\n\t[\n    char xchgd;\n    long new[2], xchg[2], *p;\t\t  \n    __asm__ __volatile__(\n#if ETHR_SIZEOF_PTR == 4\n\t\"lock; cmpxchg8b %0\\n\\t\"\n#else\n\t\"lock; cmpxchg16b %0\\n\\t\"\n#endif\n\t\"setz %3\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=q\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"c\"(new[1]), \"b\"(new[0])\n\t: \"cc\", \"memory\");\n\t],\n\t[plain_cmpxchg=yes])\n\n\tAC_MSG_RESULT([$plain_cmpxchg])\n\n\tif test $pic_cmpxchg = yes; then\n\t   gcc_pic_dw_cmpxchg_asm=$plain_cmpxchg\n\t   break\n\tfi\n\n\tgcc_dw_cmpxchg_asm=$plain_cmpxchg\n\n    \t# If not already compiling to position independent\n\t# code add -fPIC to CFLAGS and do it again. This\n\t# since we want also want to know how to compile\n\t# to position independent code since this might\n\t# cause problems with the use of the EBX register\n\t# as input to the asm on 32-bit x86 and old gcc\n\t# compilers (gcc vsn < 5).\n\n    \tAC_TRY_COMPILE([],\n\t[\n#if !defined(__PIC__) || !__PIC__\n#  error no pic\n#endif\n\t],\n\t[pic_cmpxchg=yes\n\t gcc_cflags_pic=yes],\n\t[pic_cmpxchg=no])\n\n\tif test $pic_cmpxchg = yes; then\n\t   gcc_pic_dw_cmpxchg_asm=$gcc_dw_cmpxchg_asm\n\t   break\n\tfi\n\n\tCFLAGS=\"$save_CFLAGS -fPIC\"\n\tpic_cmpxchg=yes\n\n    done\n\n    if test $gcc_pic_dw_cmpxchg_asm = no && test $ac_cv_sizeof_void_p = 4; then\n\n      AC_MSG_CHECKING([for gcc pic cmpxchg8b asm support with EBX workaround])\n\n      # Check if we can work around it by managing the ebx\n      # register explicitly in the asm...\n\n      AC_TRY_COMPILE([],\n\t[\n    char xchgd;\n    long new[2], xchg[2], *p;\t\t  \n    __asm__ __volatile__(\n\t\"pushl %%ebx\\n\\t\"\n\t\"movl %8, %%ebx\\n\\t\"\n\t\"lock; cmpxchg8b %0\\n\\t\"\n\t\"setz %3\\n\\t\"\n\t\"popl %%ebx\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=q\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"c\"(new[1]), \"r\"(new[0])\n\t: \"cc\", \"memory\");\n\t],\n\t[gcc_pic_dw_cmpxchg_asm=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx=yes])     \n\n      AC_MSG_RESULT([$gcc_pic_dw_cmpxchg_asm])\n\n      if test $gcc_pic_dw_cmpxchg_asm = no; then\n\n      \tAC_MSG_CHECKING([for gcc pic cmpxchg8b asm support with EBX and register shortage workarounds])\n        # If no optimization is enabled we sometimes get a\n\t# register shortage. Check if we can work around\n\t# this...\n\n      \tAC_TRY_COMPILE([],\n\t  [\n      char xchgd;\n      long new[2], xchg[2], *p;\n      __asm__ __volatile__(\n\t\"pushl %%ebx\\n\\t\"\n\t\"movl (%7), %%ebx\\n\\t\"\n\t\"movl 4(%7), %%ecx\\n\\t\"\n\t\"lock; cmpxchg8b %0\\n\\t\"\n\t\"setz %3\\n\\t\"\n\t\"popl %%ebx\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=c\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"r\"(new)\n\t: \"cc\", \"memory\");\n\n\t],\n\t[gcc_pic_dw_cmpxchg_asm=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage=yes])\n\n        AC_MSG_RESULT([$gcc_pic_dw_cmpxchg_asm])\n      fi\n\n      if test $gcc_cflags_pic = yes; then\n        gcc_dw_cmpxchg_asm=$gcc_pic_dw_cmpxchg_asm\n      fi\n \n   fi\n\n    CFLAGS=\"$save_CFLAGS\"\n\n    if test \"$gcc_cmpxchg8b_pic_no_clobber_ebx\" = \"yes\"; then\n      AC_DEFINE(ETHR_CMPXCHG8B_PIC_NO_CLOBBER_EBX, 1, [Define if gcc wont let you clobber ebx with cmpxchg8b and position independent code])\n    fi\n    if test \"$gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage\" = \"yes\"; then\n      AC_DEFINE(ETHR_CMPXCHG8B_REGISTER_SHORTAGE, 1, [Define if you get a register shortage with cmpxchg8b and position independent code])\n    fi\n    if test \"$gcc_dw_cmpxchg_asm\" = \"yes\"; then\n      AC_DEFINE(ETHR_GCC_HAVE_DW_CMPXCHG_ASM_SUPPORT, 1, [Define if you use a gcc that supports the double word cmpxchg instruction])\n    fi;;\n  *)\n    ;;\nesac\n\nAC_DEFINE(ETHR_HAVE_ETHREAD_DEFINES, 1, \\\n[Define if you have all ethread defines])\n\nAC_SUBST(ETHR_X_LIBS)\nAC_SUBST(ETHR_LIBS)\nAC_SUBST(ETHR_LIB_NAME)\nAC_SUBST(ETHR_DEFS)\nAC_SUBST(ETHR_THR_LIB_BASE)\nAC_SUBST(ETHR_THR_LIB_BASE_DIR)\nAC_SUBST(ETHR_X86_SSE2_ASM)\n\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl ERL_TIME_CORRECTION\ndnl\ndnl Check for primitives that can be used for implementing\ndnl erts_os_monotonic_time() and erts_os_system_time()\ndnl\n\nAC_DEFUN(ERL_TIME_CORRECTION,\n[\n\nAC_ARG_WITH(clock-resolution,\nAS_HELP_STRING([--with-clock-resolution=high|low|default],\n               [specify wanted clock resolution]))\n\nAC_ARG_WITH(clock-gettime-realtime-id,\nAS_HELP_STRING([--with-clock-gettime-realtime-id=CLOCKID],\n               [specify clock id to use with clock_gettime() for realtime time)]))\n\nAC_ARG_WITH(clock-gettime-monotonic-id,\nAS_HELP_STRING([--with-clock-gettime-monotonic-id=CLOCKID],\n               [specify clock id to use with clock_gettime() for monotonic time)]))\n\nAC_ARG_ENABLE(prefer-elapsed-monotonic-time-during-suspend,\nAS_HELP_STRING([--enable-prefer-elapsed-monotonic-time-during-suspend],\n               [Prefer an OS monotonic time source with elapsed time during suspend])\nAS_HELP_STRING([--disable-prefer-elapsed-monotonic-time-during-suspend],\n               [Do not prefer an OS monotonic time source with elapsed time during suspend]),\n[ case \"$enableval\" in\n    yes) prefer_elapsed_monotonic_time_during_suspend=yes ;;\n    *)  prefer_elapsed_monotonic_time_during_suspend=no ;;\n  esac ], prefer_elapsed_monotonic_time_during_suspend=no)\n\nAC_ARG_ENABLE(gettimeofday-as-os-system-time,\n\t      AS_HELP_STRING([--enable-gettimeofday-as-os-system-time],\n                             [Force usage of gettimeofday() for OS system time]),\n[ case \"$enableval\" in\n    yes) force_gettimeofday_os_system_time=yes ;;\n    *)  force_gettimeofday_os_system_time=no ;;\n  esac ], force_gettimeofday_os_system_time=no)\n\ncase \"$with_clock_resolution\" in\n   \"\"|no|yes)\n     with_clock_resolution=default;;\n   high|low|default)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid wanted clock resolution: $with_clock_resolution])\n     ;;\nesac\n\nif test \"$force_gettimeofday_os_system_time\" = \"yes\"; then\n\n  AC_CHECK_FUNCS([gettimeofday])\n  if test \"$ac_cv_func_gettimeofday\" = \"yes\"; then\n    AC_DEFINE(OS_SYSTEM_TIME_GETTIMEOFDAY,  [1], [Define if you want to implement erts_os_system_time() using gettimeofday()])\n  else\n    AC_MSG_ERROR([No gettimeofday() available])\n  fi\n\nelse # $force_gettimeofday_os_system_time != yes\n\ncase \"$with_clock_gettime_realtime_id\" in\n   \"\"|no)\n     with_clock_gettime_realtime_id=no\n     ;;\n   CLOCK_*CPUTIME*)\n     AC_MSG_ERROR([Invalid clock_gettime() realtime clock id: Refusing to use the cputime clock id $with_clock_gettime_realtime_id as realtime clock id])\n     ;;\n   CLOCK_MONOTONIC*|CLOCK_BOOTTIME*|CLOCK_UPTIME*|CLOCK_HIGHRES*)\n     AC_MSG_ERROR([Invalid clock_gettime() realtime clock id: Refusing to use the monotonic clock id $with_clock_gettime_realtime_id as realtime clock id])\n     ;;\n   CLOCK_*)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid clock_gettime() clock id: $with_clock_gettime_realtime_id])\n     ;;\nesac\n\ncase \"$with_clock_resolution-$with_clock_gettime_realtime_id\" in\n  high-no)\n\tERL_WALL_CLOCK(high_resolution);;\n  low-no)\n\tERL_WALL_CLOCK(low_resolution);;\n  default-no)\n\tERL_WALL_CLOCK(default_resolution);;\n  *)\n\tERL_WALL_CLOCK(custom_resolution, $with_clock_gettime_realtime_id);;\nesac\n\ncase \"$erl_wall_clock_func-$erl_wall_clock_id-$with_clock_gettime_realtime_id\" in\n  *-*-no)\n    ;;\n  clock_gettime-$with_clock_gettime_realtime_id-$with_clock_gettime_realtime_id)\n    ;;\n  *)\n    AC_MSG_ERROR([$with_clock_gettime_realtime_id as clock id to clock_gettime() doesn't compile])\n    ;;\nesac\n\ncase $erl_wall_clock_func in\n  none)\n    AC_MSG_ERROR([No wall clock source found])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(OS_SYSTEM_TIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_system_time() using mach clock_get_time()])\n    ;;\n  clock_gettime)\n    AC_DEFINE(OS_SYSTEM_TIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_system_time() using clock_gettime()])\n    ;;\n  gettimeofday)\n    AC_DEFINE(OS_SYSTEM_TIME_GETTIMEOFDAY,  [1], [Define if you want to implement erts_os_system_time() using gettimeofday()])\n    ;;\n  *)\n    ;;\nesac\n\nif test \"x$erl_wall_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(WALL_CLOCK_ID_STR, [\"$erl_wall_clock_id\"], [Define as a string of wall clock id to use])\n    AC_DEFINE_UNQUOTED(WALL_CLOCK_ID, [$erl_wall_clock_id], [Define to wall clock id to use])\nfi\n\nfi # $force_gettimeofday_os_system_time != yes\n\ncase \"$with_clock_gettime_monotonic_id\" in\n   \"\"|no)\n     with_clock_gettime_monotonic_id=no\n     ;;\n   CLOCK_*CPUTIME*)\n     AC_MSG_ERROR([Invalid clock_gettime() monotonic clock id: Refusing to use the cputime clock id $with_clock_gettime_monotonic_id as monotonic clock id])\n     ;;\n   CLOCK_REALTIME*|CLOCK_TAI*)\n     AC_MSG_ERROR([Invalid clock_gettime() monotonic clock id: Refusing to use the realtime clock id $with_clock_gettime_monotonic_id as monotonic clock id])\n     ;;\n   CLOCK_*)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid clock_gettime() clock id: $with_clock_gettime_monotonic_id])\n     ;;\nesac\n\ncase \"$with_clock_resolution-$with_clock_gettime_monotonic_id\" in\n  high-no)\n\tERL_MONOTONIC_CLOCK(high_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  low-no)\n\tERL_MONOTONIC_CLOCK(low_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  default-no)\n\tERL_MONOTONIC_CLOCK(default_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  *)\n\tERL_MONOTONIC_CLOCK(custom_resolution, $with_clock_gettime_monotonic_id, $prefer_elapsed_monotonic_time_during_suspend);;\nesac\n\ncase \"$erl_monotonic_clock_func-$erl_monotonic_clock_id-$with_clock_gettime_monotonic_id\" in\n  *-*-no)\n    ;;\n  clock_gettime-$with_clock_gettime_monotonic_id-$with_clock_gettime_monotonic_id)\n    ;;\n  *)\n    AC_MSG_ERROR([$with_clock_gettime_monotonic_id as clock id to clock_gettime() doesn't compile])\n    ;;\nesac\n\ncase $erl_monotonic_clock_func in\n  times)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_TIMES, [1], [Define if you want to implement erts_os_monotonic_time() using times()])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_monotonic_time() using mach clock_get_time()])\n    ;;\n  clock_gettime)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_monotonic_time() using clock_gettime()])\n    ;;\n  gethrtime)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_GETHRTIME,  [1], [Define if you want to implement erts_os_monotonic_time() using gethrtime()])\n    ;;\n  *)\n    ;;\nesac\n\nif test $erl_corrected_monotonic_clock = yes; then\n  AC_DEFINE(ERTS_HAVE_CORRECTED_OS_MONOTONIC_TIME, [1], [Define if OS monotonic clock is corrected])\nfi\n\nif test $erl_monotonic_clock_low_resolution = yes; then\n  AC_DEFINE(ERTS_HAVE_LOW_RESOLUTION_OS_MONOTONIC_LOW, [1], [Define if you have a low resolution OS monotonic clock])\nfi\n\nxrtlib=\nif test \"$erl_monotonic_clock_lib\" != \"\"; then\n   xrtlib=\"$erl_monotonic_clock_lib\"\nfi\nif test \"$erl_wall_clock_lib\" != \"\"; then\n   xrtlib=\"$erl_wall_clock_lib\"\nfi\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(MONOTONIC_CLOCK_ID_STR, [\"$erl_monotonic_clock_id\"], [Define as a string of monotonic clock id to use])\n    AC_DEFINE_UNQUOTED(MONOTONIC_CLOCK_ID, [$erl_monotonic_clock_id], [Define to monotonic clock id to use])\nfi\n\nif test $erl_cv_clock_gettime_monotonic_raw = yes; then\n  AC_DEFINE(HAVE_CLOCK_GETTIME_MONOTONIC_RAW, [1], [Define if you have clock_gettime(CLOCK_MONOTONIC_RAW, _)])\nfi\n\nERL_MONOTONIC_CLOCK(high_resolution, undefined, no)\n\ncase $$erl_monotonic_clock_low_resolution-$erl_monotonic_clock_func in\n  no-mach_clock_get_time)\n    monotonic_hrtime=yes    \n    AC_DEFINE(SYS_HRTIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_hrtime() using mach clock_get_time()])\n    ;;\n  no-clock_gettime)\n    monotonic_hrtime=yes\n    AC_DEFINE(SYS_HRTIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_hrtime() using clock_gettime()])\n    ;;\n  no-gethrtime)\n    monotonic_hrtime=yes\n    AC_DEFINE(SYS_HRTIME_USING_GETHRTIME,  [1], [Define if you want to implement erts_os_hrtime() using gethrtime()])\n    ;;\n  *)\n    monotonic_hrtime=no\n    ;;\nesac\n\nif test $monotonic_hrtime = yes; then\n    AC_DEFINE(HAVE_MONOTONIC_ERTS_SYS_HRTIME, [1], [Define if you have a monotonic erts_os_hrtime() implementation])\nfi\n\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(HRTIME_CLOCK_ID_STR, [\"$erl_monotonic_clock_id\"], [Define as a string of monotonic clock id to use])\n    AC_DEFINE_UNQUOTED(HRTIME_CLOCK_ID, [$erl_monotonic_clock_id], [Define to monotonic clock id to use])\nfi\n\n\ndnl\ndnl Check if gethrvtime is working, and if to use procfs ioctl\ndnl or (yet to be written) write to the procfs ctl file.\ndnl\n\nAC_MSG_CHECKING([if gethrvtime works and how to use it])\nAC_TRY_RUN([\n/* gethrvtime procfs ioctl test */\n/* These need to be undef:ed to not break activation of\n * micro level process accounting on /proc/self \n */\n#ifdef _LARGEFILE_SOURCE\n#  undef _LARGEFILE_SOURCE\n#endif\n#ifdef _FILE_OFFSET_BITS\n#  undef _FILE_OFFSET_BITS\n#endif\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/signal.h>\n#include <sys/fault.h>\n#include <sys/syscall.h>\n#include <sys/procfs.h>\n#include <fcntl.h>\n\nint main() {\n    long msacct = PR_MSACCT;\n    int fd;\n    long long start, stop;\n    int i;\n    pid_t pid = getpid();\n    char proc_self[30] = \"/proc/\";\n\n    sprintf(proc_self+strlen(proc_self), \"%lu\", (unsigned long) pid);\n    if ( (fd = open(proc_self, O_WRONLY)) == -1)\n\texit(1);\n    if (ioctl(fd, PIOCSET, &msacct) < 0)\n\texit(2);\n    if (close(fd) < 0)\n\texit(3);\n    start = gethrvtime();\n    for (i = 0; i < 100; i++)\n\tstop = gethrvtime();\n    if (start == 0)\n\texit(4);\n    if (start == stop)\n\texit(5);\n    exit(0); return 0;\n}\n],\nerl_gethrvtime=procfs_ioctl,\nerl_gethrvtime=false,\n[\ncase X$erl_xcomp_gethrvtime_procfs_ioctl in\n    X)\n\terl_gethrvtime=cross;;\n    Xyes|Xno)\n\tif test $erl_xcomp_gethrvtime_procfs_ioctl = yes; then\n\t    erl_gethrvtime=procfs_ioctl\n\telse\n\t    erl_gethrvtime=false\n\tfi;;\n    *)\n\tAC_MSG_ERROR([Bad erl_xcomp_gethrvtime_procfs_ioctl value: $erl_xcomp_gethrvtime_procfs_ioctl]);;\nesac\n])\n\nLIBRT=$xrtlib\ncase $erl_gethrvtime in\n  procfs_ioctl)\n\tAC_DEFINE(HAVE_GETHRVTIME_PROCFS_IOCTL,[1],\n\t\t[define if gethrvtime() works and uses ioctl() to /proc/self])\n\tAC_MSG_RESULT(uses ioctl to procfs)\n\t;;\n  *)\n\tif test $erl_gethrvtime = cross; then\n\t    erl_gethrvtime=false\n\t    AC_MSG_RESULT(cross)\n\t    AC_MSG_WARN([result 'not working' guessed because of cross compilation])\n\telse\n\t    AC_MSG_RESULT(not working)\n\tfi\n\n\tdnl\n\tdnl Check if clock_gettime (linux) is working\n\tdnl\n\n\tAC_MSG_CHECKING([if clock_gettime can be used to get thread CPU time])\n\tsave_libs=$LIBS\n\tLIBS=\"-lrt\"\n\tAC_TRY_RUN([\n\t#include <stdlib.h>\n\t#include <unistd.h>\n\t#include <string.h>\n\t#include <stdio.h>\n\t#include <time.h>\n\tint main() {\n\t    long long start, stop;\n\t    int i;\n\t    struct timespec tp;\n\n\t    if (clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp) < 0)\n\t      exit(1);\n\t    start = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;\n\t    for (i = 0; i < 100; i++)\n\t      clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp);\n\t    stop = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;\n\t    if (start == 0)\n\t      exit(4);\n\t    if (start == stop)\n\t      exit(5);\n\t    exit(0); return 0;\n\t  }\n\t],\n\terl_clock_gettime_cpu_time=yes,\n\terl_clock_gettime_cpu_time=no,\n\t[\n\tcase X$erl_xcomp_clock_gettime_cpu_time in\n\t    X) erl_clock_gettime_cpu_time=cross;;\n\t    Xyes|Xno) erl_clock_gettime_cpu_time=$erl_xcomp_clock_gettime_cpu_time;;\n\t    *) AC_MSG_ERROR([Bad erl_xcomp_clock_gettime_cpu_time value: $erl_xcomp_clock_gettime_cpu_time]);;\n\tesac\n\t])\n\tLIBS=$save_libs\n\tAC_MSG_RESULT($erl_clock_gettime_cpu_time)\n\tcase $erl_clock_gettime_cpu_time in\n\t\tyes)\n\t\t\tAC_DEFINE(HAVE_CLOCK_GETTIME_CPU_TIME,[],\n\t\t\t\t  [define if clock_gettime() works for getting thread time])\n\t\t\tLIBRT=-lrt\n\t\t\t;;\n\t\tcross)\n\t\t\terl_clock_gettime_cpu_time=no\n\t\t\tAC_MSG_WARN([result no guessed because of cross compilation])\n\t\t\t;;\n\t\t*)\n\t\t\t;;\n\tesac\n\t;;\nesac\nAC_SUBST(LIBRT)\n])dnl\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_TRY_ENABLE_CFLAG\ndnl\ndnl\ndnl Tries a CFLAG and sees if it can be enabled without compiler errors\ndnl $1: textual cflag to add\ndnl $2: variable to store the modified CFLAG in\ndnl Usage example LM_TRY_ENABLE_CFLAG([-Werror=return-type], [CFLAGS])\ndnl\ndnl\nAC_DEFUN([LM_TRY_ENABLE_CFLAG], [\n    AC_MSG_CHECKING([if we can add $1 to $2 (via CFLAGS)])\n    saved_CFLAGS=$CFLAGS;\n    CFLAGS=\"$1 $$2\";\n    AC_TRY_COMPILE([],[return 0;],can_enable_flag=true,can_enable_flag=false)\n    CFLAGS=$saved_CFLAGS;\n    if test \"X$can_enable_flag\" = \"Xtrue\"; then\n        AC_MSG_RESULT([yes])\n        AS_VAR_SET($2, \"$1 $$2\")\n    else\n        AC_MSG_RESULT([no])\n    fi\n])\n\nAC_DEFUN([LM_CHECK_ENABLE_CFLAG], [\n    AC_MSG_CHECKING([whether $CC accepts $1...])\n    saved_CFLAGS=$CFLAGS;\n    CFLAGS=\"$1 $CFLAGS\";\n    AC_TRY_COMPILE([],[return 0;],can_enable_flag=true,can_enable_flag=false)\n    CFLAGS=$saved_CFLAGS;\n    if test \"X$can_enable_flag\" = \"Xtrue\"; then\n        AS_VAR_SET($2, true)\n        AC_MSG_RESULT([yes])\n    else\n        AS_VAR_SET($2, false)\n        AC_MSG_RESULT([no])\n    fi\n])\n\ndnl ERL_TRY_LINK_JAVA(CLASSES, FUNCTION-BODY\ndnl                   [ACTION_IF_FOUND [, ACTION-IF-NOT-FOUND]])\ndnl Freely inspired by AC_TRY_LINK. (Maybe better to create a \ndnl AC_LANG_JAVA instead...)\nAC_DEFUN(ERL_TRY_LINK_JAVA,\n[java_link='$JAVAC conftest.java 1>&AC_FD_CC'\nchangequote(, )dnl\ncat > conftest.java <<EOF\n$1\nclass conftest { public static void main(String[] args) {\n   $2\n   ; return; }}\nEOF\nchangequote([, ])dnl\nif AC_TRY_EVAL(java_link) && test -s conftest.class; then\n   ifelse([$3], , :, [rm -rf conftest*\n   $3])\nelse\n   echo \"configure: failed program was:\" 1>&AC_FD_CC\n   cat conftest.java 1>&AC_FD_CC\n   echo \"configure: PATH was $PATH\" 1>&AC_FD_CC\nifelse([$4], , , [  rm -rf conftest*\n  $4\n])dnl\nfi\nrm -f conftest*])\n#define UNSAFE_MASK  0xc0000000 /* Mask for bits that must be constant */\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_HARDWARE_ARCH\ndnl\ndnl Determine target hardware in ARCH\ndnl\nAC_DEFUN([LM_HARDWARE_ARCH], [\n    AC_MSG_CHECKING([target hardware architecture])\n    if test \"x$host_alias\" != \"x\" -a \"x$host_cpu\" != \"x\"; then\n        chk_arch_=$host_cpu\n    else\n        chk_arch_=`uname -m`\n    fi\n\n    case $chk_arch_ in\n    sun4u)\tARCH=ultrasparc;;\n    sparc64)\tARCH=sparc64;;\n    sun4v)\tARCH=ultrasparc;;\n    i86pc)\tARCH=x86;;\n    i386)\tARCH=x86;;\n    i486)\tARCH=x86;;\n    i586)\tARCH=x86;;\n    i686)\tARCH=x86;;\n    x86_64)\tARCH=amd64;;\n    amd64)\tARCH=amd64;;\n    macppc)\tARCH=ppc;;\n    powerpc)\tARCH=ppc;;\n    ppc)\tARCH=ppc;;\n    ppc64)\tARCH=ppc64;;\n    ppc64le)\tARCH=ppc64le;;\n    \"Power Macintosh\")\tARCH=ppc;;\n    armv5b)\tARCH=arm;;\n    armv5teb)\tARCH=arm;;\n    armv5tel)\tARCH=arm;;\n    armv5tejl)\tARCH=arm;;\n    armv6l)\tARCH=arm;;\n    armv6hl)\tARCH=arm;;\n    armv7l)\tARCH=arm;;\n    armv7hl)\tARCH=arm;;\n    tile)\tARCH=tile;;\n    e2k)        ARCH=e2k;;\n    *)\t \tARCH=noarch;;\n    esac\n    AC_MSG_RESULT($ARCH)\n\n    dnl\n    dnl Convert between x86 and amd64 based on the compiler's mode.\n    dnl Ditto between ultrasparc and sparc64.\n    dnl\n    AC_MSG_CHECKING(whether compilation mode forces ARCH adjustment)\n    case \"$ARCH-$ac_cv_sizeof_void_p\" in\n    x86-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=x86 to ARCH=amd64)\n\tARCH=amd64\n\t;;\n    amd64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=amd64 to ARCH=x86)\n\tARCH=x86\n\t;;\n    ultrasparc-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ultrasparc to ARCH=sparc64)\n\tARCH=sparc64\n\t;;\n    sparc64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=sparc64 to ARCH=ultrasparc)\n\tARCH=ultrasparc\n\t;;\n    ppc64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ppc64 to ARCH=ppc)\n\tARCH=ppc\n\t;;\n    ppc-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ppc to ARCH=ppc64)\n\tARCH=ppc64\n\t;;\n    arm-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=arm to ARCH=noarch)\n\tARCH=noarch\n\t;;\n    *)\n\tAC_MSG_RESULT(no: ARCH is $ARCH)\n\t;;\n    esac\n\n    AC_SUBST(ARCH)\n])\n\ndnl\ndnl--------------------------------------------------------------------\ndnl Dynamic Erlang Drivers\ndnl\ndnl Linking to produce dynamic Erlang drivers to be loaded by Erlang's\ndnl Dynamic Driver Loader and Linker (DDLL). Below the prefix DED is an\ndnl abbreviation for `Dynamic Erlang Driver'.\ndnl\ndnl For DED we need something quite sloppy, which allows undefined references \ndnl (notably driver functions) in the resulting shared library. \ndnl Example of Makefile rule (and settings of macros):\ndnl\ndnl LIBS = @LIBS@\ndnl LD = @DED_LD@\ndnl LDFLAGS = @DED_LDFLAGS@\ndnl soname = @ldsoname@\ndnl\ndnl my_drv.so:   my_drv.o my_utils.o\ndnl              $(LD) $(LDFLAGS) $(soname) $@ -o $@ $^ -lc $(LIBS)\ndnl\ndnl--------------------------------------------------------------------\ndnl\n\nAC_DEFUN(ERL_DED,\n\t[\n\nUSER_LD=$LD\nUSER_LDFLAGS=\"$LDFLAGS\"\n\nLM_CHECK_THR_LIB\n\nDED_CC=$CC\nDED_GCC=$GCC\n\nDED_CFLAGS=\nDED_OSTYPE=unix\ncase $host_os in\n     linux*)\n\tDED_CFLAGS=\"-D_GNU_SOURCE\" ;;\n     win32)\n\tDED_CFLAGS=\"-D_WIN32_WINNT=0x0600 -DWINVER=0x0600\"\n        DED_OSTYPE=win32 ;;\n     *)\n        ;;\nesac\n\n\nDED_WARN_FLAGS=\"-Wall -Wstrict-prototypes\"\ncase \"$host_cpu\" in\n  tile*)\n    # tile-gcc is a bit stricter with -Wmissing-prototypes than other gccs,\n    # and too strict for our taste.\n    ;;\n  *)\n    DED_WARN_FLAGS=\"$DED_WARN_FLAGS -Wmissing-prototypes\";;\nesac\n  \nLM_TRY_ENABLE_CFLAG([-Wdeclaration-after-statement], [DED_WARN_FLAGS])\n\nLM_TRY_ENABLE_CFLAG([-Werror=return-type], [DED_WERRORFLAGS])\nLM_TRY_ENABLE_CFLAG([-Werror=implicit], [DED_WERRORFLAGS])\nLM_TRY_ENABLE_CFLAG([-Werror=undef], [DED_WERRORFLAGS])\n\nDED_SYS_INCLUDE=\"-I${ERL_TOP}/erts/emulator/beam -I${ERL_TOP}/erts/include -I${ERL_TOP}/erts/include/$host -I${ERL_TOP}/erts/include/internal -I${ERL_TOP}/erts/include/internal/$host -I${ERL_TOP}/erts/emulator/sys/$DED_OSTYPE -I${ERL_TOP}/erts/emulator/sys/common\"\nDED_INCLUDE=$DED_SYS_INCLUDE\n\nif test \"$THR_DEFS\" = \"\"; then\n    DED_THR_DEFS=\"-D_THREAD_SAFE -D_REENTRANT\"\nelse\n    DED_THR_DEFS=\"$THR_DEFS\"\nfi\n# DED_EMU_THR_DEFS=$EMU_THR_DEFS\nDED_CFLAGS=\"$CFLAGS $CPPFLAGS $DED_CFLAGS\"\nif test \"x$GCC\" = xyes; then\n    DED_STATIC_CFLAGS=\"$DED_CFLAGS\"\n    DED_CFLAGS=\"$DED_CFLAGS -fPIC\"\nfi\n\nDED_EXT=so\ncase $host_os in\n    win32) DED_EXT=dll;;\n    darwin*)\n\tDED_CFLAGS=\"$DED_CFLAGS -fno-common\"\n\tDED_STATIC_CFLAGS=\"$DED_STATIC_CFLAGS -fno-common\";;\n    *)\n\t;;\nesac\n\nDED_STATIC_CFLAGS=\"$DED_STATIC_CFLAGS -DSTATIC_ERLANG_NIF -DSTATIC_ERLANG_DRIVER\"\n\nif test \"$CFLAG_RUNTIME_LIBRARY_PATH\" = \"\"; then\n\n  CFLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-R\"\n  case $host_os in\n    darwin*)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n    win32)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n    osf*)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-rpath,\"\n\t;;\n    *)\n\t;;\n  esac\n\nfi\n\n# If DED_LD is set in environment, we expect all DED_LD* variables\n# to be specified (cross compiling)\nif test \"x$DED_LD\" = \"x\"; then\n\nDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-R\"\ncase $host_os in\n\twin32)\n\t\tDED_LD=\"ld.sh\"\n\t\tDED_LDFLAGS=\"-dll\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n\tsolaris2*|sysv4*)\n\t\tDED_LDFLAGS=\"-G\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-64 $DED_LDFLAGS\"\n\t\tfi\n\t;;\n\taix4*)\n\t\tDED_LDFLAGS=\"-G -bnoentry -bexpall\"\n\t;;\n\tfreebsd2*)\n\t\t# Non-ELF GNU linker\n\t\tDED_LDFLAGS=\"-Bshareable\"\n\t;;\n\tdarwin*)\n\t\t# Mach-O linker: a shared lib and a loadable\n\t\t# object file is not the same thing.\n\t\tDED_LDFLAGS=\"-bundle -bundle_loader ${ERL_TOP}/bin/$host/beam.smp\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t  DED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\telse\n\t\t  if test X${enable_m32_build} = Xyes; then\n\t\t    DED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\t  else\n\t\t    AC_CHECK_SIZEOF(void *)\n\t\t    case \"$ac_cv_sizeof_void_p\" in\n\t\t      8)\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\";;\n\t\t      *)\n\t\t        ;;\n\t\t    esac\n\t\t  fi\n\t\tfi\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t;;\n\tlinux*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared -Wl,-Bsymbolic\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\tfi;\n\t\tif test X${enable_m32_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\tfi\n\t;;\t\n\tfreebsd*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\tfi;\n\t\tif test X${enable_m32_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\tfi\n\t;;\t\n\topenbsd*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared\"\n\t;;\n\tosf*)\n\t\t# NOTE! Whitespace after -rpath is important.\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-rpath \"\n\t\tDED_LDFLAGS=\"-shared -expect_unresolved '*'\"\n\t;;\n\t*)\n\t\t# assume GNU linker and ELF\n\t\tDED_LDFLAGS=\"-shared\"\n\t\t# GNU linker has no option for 64bit build, should not propagate -m64\n\t;;\nesac\n\nif test \"$DED_LD\" = \"\" && test \"$USER_LD\" != \"\"; then\n    DED_LD=\"$USER_LD\"\n    DED_LDFLAGS=\"$USER_LDFLAGS $DED_LDFLAGS\"\nfi\n\nDED_LIBS=$LIBS\n\nfi # \"x$DED_LD\" = \"x\"\n\nAC_CHECK_TOOL(DED_LD, ld, false)\ntest \"$DED_LD\" != \"false\" || AC_MSG_ERROR([No linker found])\n\nAC_MSG_CHECKING(for static compiler flags)\nDED_STATIC_CFLAGS=\"$DED_WERRORFLAGS $DED_WFLAGS $DED_THR_DEFS $DED_STATIC_CFLAGS\"\nAC_MSG_RESULT([$DED_STATIC_CFLAGS])\nAC_MSG_CHECKING(for basic compiler flags for loadable drivers)\nDED_BASIC_CFLAGS=$DED_CFLAGS\nAC_MSG_RESULT([$DED_CFLAGS])\nAC_MSG_CHECKING(for compiler flags for loadable drivers)\nDED_CFLAGS=\"$DED_WERRORFLAGS $DED_WARN_FLAGS $DED_THR_DEFS $DED_CFLAGS\"\nAC_MSG_RESULT([$DED_CFLAGS])\nAC_MSG_CHECKING(for linker for loadable drivers)\nAC_MSG_RESULT([$DED_LD])\nAC_MSG_CHECKING(for linker flags for loadable drivers)\nAC_MSG_RESULT([$DED_LDFLAGS])\nAC_MSG_CHECKING(for 'runtime library path' linker flag)\nif test \"x$DED_LD_FLAG_RUNTIME_LIBRARY_PATH\" != \"x\"; then\n\tAC_MSG_RESULT([$DED_LD_FLAG_RUNTIME_LIBRARY_PATH])\nelse\n\tAC_MSG_RESULT([not found])\nfi\n\nAC_SUBST(DED_CC)\nAC_SUBST(DED_GCC)\nAC_SUBST(DED_EXT)\nAC_SUBST(DED_SYS_INCLUDE)\nAC_SUBST(DED_INCLUDE)\nAC_SUBST(DED_BASIC_CFLAGS)\nAC_SUBST(DED_CFLAGS)\nAC_SUBST(DED_STATIC_CFLAGS)\nAC_SUBST(DED_WARN_FLAGS)\nAC_SUBST(DED_WERRORFLAGS)\nAC_SUBST(DED_LD)\nAC_SUBST(DED_LDFLAGS)\nAC_SUBST(DED_LD_FLAG_RUNTIME_LIBRARY_PATH)\nAC_SUBST(DED_LIBS)\nAC_SUBST(DED_THR_DEFS)\nAC_SUBST(DED_OSTYPE)\n\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/crypto/c_src/crypto_callback.c": "/* \n * %CopyrightBegin%\n *\n * Copyright Ericsson AB 2014-2016. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * %CopyrightEnd%\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <openssl/opensslconf.h>\n#include <stdint.h>\n\n#include <erl_nif.h>\n#include \"crypto_callback.h\"\n\n#ifdef DEBUG\n    #  define ASSERT(e) \\\n    ((void) ((e) ? 1 : (fprintf(stderr,\"Assert '%s' failed at %s:%d\\n\",\\\n\t\t\t\t#e, __FILE__, __LINE__), abort(), 0)))\n#else\n    #  define ASSERT(e) ((void) 1)\n#endif\n\n#ifdef __GNUC__\n    #  define INLINE __inline__\n#elif defined(__WIN32__)\n    #  define INLINE __forceinline\n#else\n    #  define INLINE\n#endif\n\n#ifdef __WIN32__\n#  define DLLEXPORT __declspec(dllexport)\n#elif defined(__GNUC__) && __GNUC__ >= 4\n#  define DLLEXPORT __attribute__ ((visibility(\"default\")))\n#elif defined (__SUNPRO_C) && (__SUNPRO_C >= 0x550)\n#  define DLLEXPORT __global\n#else\n#  define DLLEXPORT\n#endif\n\n/* to be dlsym'ed */\nDLLEXPORT struct crypto_callbacks* get_crypto_callbacks(int nlocks);\n\n\nstatic void nomem(size_t size, const char* op)\n{\n    fprintf(stderr, \"Out of memory abort. Crypto failed to %s %zu bytes.\\r\\n\",\n\t    op, size);\n    abort();\n}\n\nstatic void* crypto_alloc(size_t size CCB_FILE_LINE_ARGS)\n{\n    void *ret;\n\n    if ((ret = enif_alloc(size)) == NULL)\n        goto err;\n    return ret;\n\n err:\n    if (size)\n\tnomem(size, \"allocate\");\n    return NULL;\n}\nstatic void* crypto_realloc(void* ptr, size_t size CCB_FILE_LINE_ARGS)\n{\n    void* ret;\n\n    if ((ret = enif_realloc(ptr, size)) == NULL)\n        goto err;\n    return ret;\n\n err:\n    if (size)\n\tnomem(size, \"reallocate\");\n    return NULL;\n}\n\nstatic void crypto_free(void* ptr CCB_FILE_LINE_ARGS)\n{\n    if (ptr == NULL)\n        return;\n\n    enif_free(ptr);\n}\n\n\n#ifdef OPENSSL_THREADS /* vvvvvvvvvvvvvvv OPENSSL_THREADS vvvvvvvvvvvvvvvv */\n\nstatic ErlNifRWLock** lock_vec = NULL; /* Static locks used by openssl */\n\n#include <openssl/crypto.h>\n\nstatic INLINE void locking(int mode, ErlNifRWLock* lock)\n{\n    switch (mode) {\n    case CRYPTO_LOCK|CRYPTO_READ:\n\tenif_rwlock_rlock(lock);\n\tbreak;\n    case CRYPTO_LOCK|CRYPTO_WRITE:\n\tenif_rwlock_rwlock(lock);\n\tbreak;\n    case CRYPTO_UNLOCK|CRYPTO_READ:\n\tenif_rwlock_runlock(lock);\n\tbreak;\n    case CRYPTO_UNLOCK|CRYPTO_WRITE:\n\tenif_rwlock_rwunlock(lock);\n\tbreak;\n    default:\n\tASSERT(!\"Invalid lock mode\");\n    }\n}\n\nstatic void locking_function(int mode, int n, const char *file, int line)\n{\n    locking(mode, lock_vec[n]);\n}\n\nstatic unsigned long id_function(void)\n{\n    return (unsigned long) enif_thread_self();\n}\n\n/* Dynamic locking, not used by current openssl version (0.9.8)\n */\nstatic struct CRYPTO_dynlock_value* dyn_create_function(const char *file, int line)\n{\n    return (struct CRYPTO_dynlock_value*) enif_rwlock_create(\"crypto_dyn\");\n}\nstatic void dyn_lock_function(int mode, struct CRYPTO_dynlock_value* ptr,const char *file, int line)\n{\n    locking(mode, (ErlNifRWLock*)ptr);\n}\nstatic void dyn_destroy_function(struct CRYPTO_dynlock_value *ptr, const char *file, int line)\n{\n    enif_rwlock_destroy((ErlNifRWLock*)ptr);\n}\n\n#endif /* ^^^^^^^^^^^^^^^^^^^^^^ OPENSSL_THREADS ^^^^^^^^^^^^^^^^^^^^^^ */\n\nDLLEXPORT struct crypto_callbacks* get_crypto_callbacks(int nlocks)\n{\n    static int is_initialized = 0;\n    static struct crypto_callbacks the_struct = {\n\tsizeof(struct crypto_callbacks),\n\n\t&crypto_alloc,\n\t&crypto_realloc,\n\t&crypto_free,\n        \n#ifdef OPENSSL_THREADS\n\t&locking_function,\n\t&id_function,\n\t&dyn_create_function,\n\t&dyn_lock_function,\n\t&dyn_destroy_function\n#endif /* OPENSSL_THREADS */\n    };\n\n    if (!is_initialized) {\n#ifdef OPENSSL_THREADS\n\tif (nlocks > 0) {\n\t    int i;\n\n            if ((size_t)nlocks > SIZE_MAX / sizeof(*lock_vec))\n                goto err;\n            if ((lock_vec = enif_alloc((size_t)nlocks * sizeof(*lock_vec))) == NULL)\n                goto err;\n\n            memset(lock_vec, 0, (size_t)nlocks * sizeof(*lock_vec));\n\n\t    for (i=nlocks-1; i>=0; --i) {\n\t\tif ((lock_vec[i] = enif_rwlock_create(\"crypto_stat\")) == NULL)\n                    goto err;\n\t    }\n\t}\n#endif\n\tis_initialized = 1;\n    }\n    return &the_struct;\n\n err:\n    return NULL;\n}\n\n#ifdef HAVE_DYNAMIC_CRYPTO_LIB\n/* This is not really a NIF library, but we use ERL_NIF_INIT in order to\n * get access to the erl_nif API (on Windows).\n */\nstatic struct {\n    int dummy__;\n    ErlNifFunc funcv[0];\n} empty;\nERL_NIF_INIT(dummy, empty.funcv, NULL, NULL, NULL, NULL)\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/crypto/c_src/crypto.c": "/*\n * %CopyrightBegin%\n *\n * Copyright Ericsson AB 2010-2018. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * %CopyrightEnd%\n */\n\n/*\n * Purpose:  Dynamically loadable NIF library for cryptography.\n * Based on OpenSSL.\n */\n\n#include \"common.h\"\n\n#include \"aead.h\"\n#include \"aes.h\"\n#include \"algorithms.h\"\n#include \"api_ng.h\"\n#include \"bn.h\"\n#include \"cipher.h\"\n#include \"mac.h\"\n#include \"dh.h\"\n#include \"digest.h\"\n#include \"dss.h\"\n#include \"ec.h\"\n#include \"ecdh.h\"\n#include \"eddsa.h\"\n#include \"engine.h\"\n#include \"evp.h\"\n#include \"fips.h\"\n#include \"hash.h\"\n#include \"hmac.h\"\n#include \"info.h\"\n#include \"math.h\"\n#include \"pkey.h\"\n#include \"rand.h\"\n#include \"rsa.h\"\n#include \"srp.h\"\n\n/* NIF interface declarations */\nstatic int load(ErlNifEnv* env, void** priv_data, ERL_NIF_TERM load_info);\nstatic int upgrade(ErlNifEnv* env, void** priv_data, void** old_priv_data, ERL_NIF_TERM load_info);\nstatic void unload(ErlNifEnv* env, void* priv_data);\n\nstatic int library_refc = 0; /* number of users of this dynamic library */\nstatic int library_initialized = 0;\n\nstatic ErlNifFunc nif_funcs[] = {\n    {\"info_lib\", 0, info_lib, 0},\n    {\"info_fips\", 0, info_fips, 0},\n    {\"enable_fips_mode\", 1, enable_fips_mode, 0},\n    {\"hash_algorithms\", 0, hash_algorithms, 0},\n    {\"pubkey_algorithms\", 0, pubkey_algorithms, 0},\n    {\"cipher_algorithms\", 0, cipher_algorithms, 0},\n    {\"mac_algorithms\", 0, mac_algorithms, 0},\n    {\"curve_algorithms\", 0, curve_algorithms, 0},\n    {\"rsa_opts_algorithms\", 0, rsa_opts_algorithms, 0},\n    {\"hash_info\", 1, hash_info_nif, 0},\n    {\"hash_nif\", 2, hash_nif, 0},\n    {\"hash_init_nif\", 1, hash_init_nif, 0},\n    {\"hash_update_nif\", 2, hash_update_nif, 0},\n    {\"hash_final_nif\", 1, hash_final_nif, 0},\n    {\"mac_nif\", 4, mac_nif, 0},\n    {\"mac_init_nif\", 3, mac_init_nif, 0},\n    {\"mac_update_nif\", 2, mac_update_nif, 0},\n    {\"mac_final_nif\", 1, mac_final_nif, 0},\n    {\"cipher_info_nif\", 1, cipher_info_nif, 0},\n    {\"aes_ige_crypt_nif\", 4, aes_ige_crypt_nif, 0},\n    {\"ng_crypto_init_nif\", 4, ng_crypto_init_nif, 0},\n    {\"ng_crypto_update_nif\", 2, ng_crypto_update_nif, 0},\n    {\"ng_crypto_update_nif\", 3, ng_crypto_update_nif, 0},\n    {\"ng_crypto_one_time_nif\", 5, ng_crypto_one_time_nif, 0},\n    {\"strong_rand_bytes_nif\", 1, strong_rand_bytes_nif, 0},\n    {\"strong_rand_range_nif\", 1, strong_rand_range_nif, 0},\n    {\"rand_uniform_nif\", 2, rand_uniform_nif, 0},\n    {\"mod_exp_nif\", 4, mod_exp_nif, 0},\n    {\"do_exor\", 2, do_exor, 0},\n    {\"pkey_sign_nif\", 5, pkey_sign_nif, 0},\n    {\"pkey_verify_nif\", 6, pkey_verify_nif, 0},\n    {\"pkey_crypt_nif\", 6, pkey_crypt_nif, 0},\n    {\"rsa_generate_key_nif\", 2, rsa_generate_key_nif, 0},\n    {\"dh_generate_key_nif\", 4, dh_generate_key_nif, 0},\n    {\"dh_compute_key_nif\", 3, dh_compute_key_nif, 0},\n    {\"evp_compute_key_nif\", 3, evp_compute_key_nif, 0},\n    {\"evp_generate_key_nif\", 1, evp_generate_key_nif, 0},\n    {\"privkey_to_pubkey_nif\", 2, privkey_to_pubkey_nif, 0},\n    {\"srp_value_B_nif\", 5, srp_value_B_nif, 0},\n    {\"srp_user_secret_nif\", 7, srp_user_secret_nif, 0},\n    {\"srp_host_secret_nif\", 5, srp_host_secret_nif, 0},\n\n    {\"ec_key_generate\", 2, ec_key_generate, 0},\n    {\"ecdh_compute_key_nif\", 3, ecdh_compute_key_nif, 0},\n\n    {\"rand_seed_nif\", 1, rand_seed_nif, 0},\n\n    {\"aead_cipher\", 7, aead_cipher, 0},\n\n    {\"engine_by_id_nif\", 1, engine_by_id_nif, 0},\n    {\"engine_init_nif\", 1, engine_init_nif, 0},\n    {\"engine_finish_nif\", 1, engine_finish_nif, 0},\n    {\"engine_free_nif\", 1, engine_free_nif, 0},\n    {\"engine_load_dynamic_nif\", 0, engine_load_dynamic_nif, 0},\n    {\"engine_ctrl_cmd_strings_nif\", 3, engine_ctrl_cmd_strings_nif, 0},\n    {\"engine_register_nif\", 2, engine_register_nif, 0},\n    {\"engine_unregister_nif\", 2, engine_unregister_nif, 0},\n    {\"engine_add_nif\", 1, engine_add_nif, 0},\n    {\"engine_remove_nif\", 1, engine_remove_nif, 0},\n    {\"engine_get_first_nif\", 0, engine_get_first_nif, 0},\n    {\"engine_get_next_nif\", 1, engine_get_next_nif, 0},\n    {\"engine_get_id_nif\", 1, engine_get_id_nif, 0},\n    {\"engine_get_name_nif\", 1, engine_get_name_nif, 0},\n    {\"engine_get_all_methods_nif\", 0, engine_get_all_methods_nif, 0}\n};\n\nERL_NIF_INIT(crypto,nif_funcs,load,NULL,upgrade,unload)\n\n\nstatic int verify_lib_version(void)\n{\n    const unsigned long libv = SSLeay();\n    const unsigned long hdrv = OPENSSL_VERSION_NUMBER;\n\n#   define MAJOR_VER(V) ((unsigned long)(V) >> (7*4))\n\n    if (MAJOR_VER(libv) != MAJOR_VER(hdrv)) {\n\tPRINTF_ERR2(\"CRYPTO: INCOMPATIBLE SSL VERSION\"\n\t\t    \" lib=%lx header=%lx\\n\", libv, hdrv);\n\treturn 0;\n    }\n    return 1;\n}\n\nstatic int initialize(ErlNifEnv* env, ERL_NIF_TERM load_info)\n{\n#ifdef OPENSSL_THREADS\n    ErlNifSysInfo sys_info;\n#endif\n    get_crypto_callbacks_t* funcp;\n    struct crypto_callbacks* ccb;\n    int nlocks = 0;\n    int tpl_arity;\n    const ERL_NIF_TERM* tpl_array;\n    int vernum;\n    ErlNifBinary lib_bin;\n    char lib_buf[1000];\n#ifdef HAVE_DYNAMIC_CRYPTO_LIB\n    void *handle;\n#endif\n\n    if (!verify_lib_version())\n\treturn __LINE__;\n\n    /* load_info: {302, <<\"/full/path/of/this/library\">>,true|false} */\n    if (!enif_get_tuple(env, load_info, &tpl_arity, &tpl_array))\n        return __LINE__;\n    if (tpl_arity != 3)\n        return __LINE__;\n    if (!enif_get_int(env, tpl_array[0], &vernum))\n        return __LINE__;\n    if (vernum != 302)\n        return __LINE__;\n    if (!enif_inspect_binary(env, tpl_array[1], &lib_bin))\n        return __LINE__;\n\n#ifdef HAS_EVP_PKEY_CTX\n    if (!init_mac_ctx(env)) {\n\treturn __LINE__;\n    }\n#else\n    if (!init_hmac_ctx(env)) {\n\treturn __LINE__;\n    }\n#endif\n    if (!init_hash_ctx(env)) {\n        return __LINE__;\n    }\n    if (!init_cipher_ctx(env)) {\n        return __LINE__;\n    }\n    if (!init_engine_ctx(env)) {\n        return __LINE__;\n    }\n\n    if (library_initialized) {\n\t/* Repeated loading of this library (module upgrade).\n\t * Atoms and callbacks are already set, we are done.\n\t */\n\treturn 0;\n    }\n\n    if (!init_atoms(env, tpl_array[2], load_info)) {\n        return __LINE__;\n    }\n\n#ifdef HAVE_DYNAMIC_CRYPTO_LIB\n    if (!change_basename(&lib_bin, lib_buf, sizeof(lib_buf), crypto_callback_name))\n        return __LINE__;\n    if ((handle = enif_dlopen(lib_buf, &error_handler, NULL)) == NULL)\n        return __LINE__;\n    if ((funcp = (get_crypto_callbacks_t*) enif_dlsym(handle, \"get_crypto_callbacks\",\n                                                       &error_handler, NULL)) == NULL)\n        return __LINE__;\n#else /* !HAVE_DYNAMIC_CRYPTO_LIB */\n    funcp = &get_crypto_callbacks;\n#endif\n\n#ifdef OPENSSL_THREADS\n    enif_system_info(&sys_info, sizeof(sys_info));\n    if (sys_info.scheduler_threads > 1) {\n\tnlocks = CRYPTO_num_locks();\n    }\n    /* else no need for locks */\n#endif\n\n    ccb = (*funcp)(nlocks);\n\n    if (!ccb || ccb->sizeof_me != sizeof(*ccb)) {\n\tPRINTF_ERR0(\"Invalid 'crypto_callbacks'\");\n\treturn __LINE__;\n    }\n\n#ifdef HAS_CRYPTO_MEM_FUNCTIONS\n    if (!CRYPTO_set_mem_functions(ccb->crypto_alloc, ccb->crypto_realloc, ccb->crypto_free))\n        return __LINE__;\n#endif\n\n#ifdef OPENSSL_THREADS\n    if (nlocks > 0) {\n\tCRYPTO_set_locking_callback(ccb->locking_function);\n\tCRYPTO_set_id_callback(ccb->id_function);\n\tCRYPTO_set_dynlock_create_callback(ccb->dyn_create_function);\n\tCRYPTO_set_dynlock_lock_callback(ccb->dyn_lock_function);\n\tCRYPTO_set_dynlock_destroy_callback(ccb->dyn_destroy_function);\n    }\n#endif /* OPENSSL_THREADS */\n\n    init_digest_types(env);\n    init_mac_types(env);\n    init_cipher_types(env);\n    init_algorithms_types(env);\n\n    library_initialized = 1;\n    return 0;\n}\n\nstatic int load(ErlNifEnv* env, void** priv_data, ERL_NIF_TERM load_info)\n{\n    int errline = initialize(env, load_info);\n    if (errline) {\n\treturn errline;\n    }\n\n    *priv_data = NULL;\n    library_refc++;\n    return 0;\n}\n\nstatic int upgrade(ErlNifEnv* env, void** priv_data, void** old_priv_data,\n\t\t   ERL_NIF_TERM load_info)\n{\n    int errline;\n    if (*old_priv_data != NULL) {\n\treturn __LINE__; /* Don't know how to do that */\n    }\n    if (*priv_data != NULL) {\n\treturn __LINE__; /* Don't know how to do that */\n    }\n    errline = initialize(env, load_info);\n    if (errline) {\n\treturn errline;\n    }\n    library_refc++;\n    return 0;\n}\n\nstatic void unload(ErlNifEnv* env, void* priv_data)\n{\n    --library_refc;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/crypto/c_src/check_erlang.cocci": "// %CopyrightBegin%\n//\n// Copyright Doug Hogan 2019. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// %CopyrightEnd%\n\n// Coccinelle script to help verify Erlang calls.\n// http://coccinelle.lip6.fr\n// https://github.com/coccinelle/coccinelle\n//\n// These work with the Erlang code because it has a rigid coding pattern.\n// $ spatch.opt --all-includes -sp_file check_erlang.cocci -dir .\n\n// Make sure resources are cleaned up properly in all paths.\n// Need 'strict' so it's also checked in error handling paths.\n@enif_alloc_resource@\ntype T;\nidentifier CTX, L;\nidentifier virtual.enif_alloc_resource, virtual.enif_release_resource;\nposition p, pr;\n@@\n\n T *CTX = NULL;\n\n ...\n if ((CTX = enif_alloc_resource(...)@p) == NULL)\n   goto L;\n\n ... when strict, forall\n if (CTX)\n   enif_release_resource(CTX)@pr;\n\n\n// After calling enif_alloc_binary(), you must either release it with\n// enif_release_binary() or transfer ownership to Erlang via enif_make_binary().\n@enif_alloc_binary@\nexpression SZ;\nidentifier BIN, RET, ENV, X, L;\nidentifier TUPLE =~ \"^enif_make_tuple[0-9]+$\";\nidentifier virtual.enif_alloc_binary, virtual.enif_make_binary;\nidentifier virtual.enif_release_binary;\nposition pa, pm, pr;\n@@\n\n// This construct is used in engine.c\n(\n  if (!enif_alloc_binary(SZ, &BIN)@pa)\n      goto L;\n\n  ... when strict, forall\n  return\n(\n  enif_make_binary(ENV, &BIN)@pm\n|\n  TUPLE(..., enif_make_binary(ENV, &BIN)@pm)@pm\n);\n\n|\n// This is the typical way we allocate and use binaries.\n  int X = 0;\n\n  ...\n  if (!enif_alloc_binary(SZ, &BIN)@pa)\n    goto L;\n  X = 1;\n\n  ... when strict, forall\n(\n  RET = enif_make_binary(ENV, &BIN)@pm;\n  X = 0;\n|\n  if (X)\n    enif_release_binary(&BIN)@pr;\n|\n  return enif_make_binary(ENV, &BIN)@pm;\n)\n)\n\n// TODO: These don't have single checks that handle all cases.\n//\n// enif_consume_timeslice      returns 1 if exhausted or else 0\n// enif_has_pending_exception  returns true if exception pending\n\n@erlang_check_void@\nidentifier FUNCVOID =~ \"^(enif_mutex_destroy|enif_mutex_lock|enif_mutex_unlock|enif_rwlock_destroy|enif_rwlock_rlock|enif_rwlock_runlock|enif_rwlock_rwlock|enif_rwlock_rwunlock|enif_system_info)$\";\nposition p;\n@@\n\n  FUNCVOID(...)@p;\n\n\n@erlang_check_null@\nexpression X;\nidentifier L;\nidentifier FUNCNULL =~ \"^(enif_alloc|enif_alloc_resource|enif_dlopen|enif_dlsym|enif_make_new_binary|enif_mutex_create|enif_open_resource_type|enif_realloc|enif_rwlock_create)$\";\nposition p;\n@@\n\n(\n  if ((X = FUNCNULL(...)@p) == NULL)\n      goto L;\n|\n  X = FUNCNULL(...)@p;\n  if (X == NULL)\n      goto L;\n|\n  return FUNCNULL(...)@p;\n)\n\n\n@erlang_check_not@\nidentifier L;\nidentifier FUNCNOT =~ \"^(enif_alloc_binary|enif_get_int|enif_get_list_cell|enif_get_list_length|enif_get_long|enif_get_map_value|enif_get_resource|enif_get_tuple|enif_get_uint|enif_get_ulong|enif_inspect_binary|enif_inspect_iolist_as_binary|enif_is_atom|enif_is_binary|enif_is_current_process_alive|enif_is_empty_list|enif_is_list|enif_is_map|enif_is_tuple|enif_realloc_binary)$\";\nposition p;\n@@\n\n(\n  if (!FUNCNOT(...)@p)\n      goto L;\n|\n  return FUNCNOT(...)@p;\n)\n\n\n@erlang_check_null_free@\nexpression X;\nidentifier FUNCFREE =~ \"^(enif_free|enif_free_env|enif_free_iovec|enif_release_binary|enif_release_resource)$\";\nposition p;\n@@\n\n  if (\n(\n X\n|\n X != NULL\n)\n  )\n    FUNCFREE(X)@p;\n\n\n@erlang_check_new@\nexpression RET;\nidentifier FUNCNEW =~ \"^(enif_make_atom|enif_make_badarg|enif_make_binary|enif_make_int|enif_make_list|enif_make_list_from_array|enif_make_resource|enif_make_tuple|enif_raise_exception|enif_schedule_nif|enif_thread_self)$\";\nposition p;\n@@\n\n(\n  RET = FUNCNEW(...)@p;\n|\n  return FUNCNEW(...)@p;\n)\n\n\n// Flag any calls that aren't part of the above pattern.\n@enif_alloc_not_free@\n\nidentifier FUNCVOID =~ \"^(enif_mutex_destroy|enif_mutex_lock|enif_mutex_unlock|enif_rwlock_destroy|enif_rwlock_rlock|enif_rwlock_runlock|enif_rwlock_rwlock|enif_rwlock_rwunlock|enif_system_info)$\";\nposition pvoid != {erlang_check_void.p,enif_alloc_binary.pr};\n\nidentifier FUNCNULL =~ \"^(enif_alloc|enif_alloc_resource|enif_dlopen|enif_dlsym|enif_make_new_binary|enif_mutex_create|enif_open_resource_type|enif_realloc|enif_rwlock_create)$\";\nposition pnull != {erlang_check_null.p,enif_alloc_resource.p};\n\nidentifier FUNCNOT =~ \"^(enif_alloc_binary|enif_get_int|enif_get_list_cell|enif_get_list_length|enif_get_long|enif_get_map_value|enif_get_resource|enif_get_tuple|enif_get_uint|enif_get_ulong|enif_inspect_binary|enif_inspect_iolist_as_binary|enif_is_atom|enif_is_binary|enif_is_current_process_alive|enif_is_empty_list|enif_is_list|enif_is_map|enif_is_tuple|enif_realloc_binary)$\";\nposition pnot != {erlang_check_not.p,enif_alloc_binary.pa};\n\nidentifier FUNCNEW =~ \"^(enif_make_atom|enif_make_badarg|enif_make_binary|enif_make_int|enif_make_list|enif_make_list_from_array|enif_make_resource|enif_make_tuple|enif_raise_exception|enif_schedule_nif|enif_thread_self)$\";\nposition pnew != {erlang_check_new.p,enif_alloc_binary.pm};\n\nidentifier FUNCFREE =~ \"^(enif_free|enif_free_env|enif_free_iovec|enif_release_binary|enif_release_resource)$\";\nposition pfree != {enif_alloc_resource.pr,enif_alloc_binary.pr,erlang_check_null_free.p};\n\n@@\n\n(\n* FUNCVOID(...)@pvoid\n|\n* FUNCNULL(...)@pnull\n|\n* FUNCNOT(...)@pnot\n|\n* FUNCNEW(...)@pnew\n|\n* FUNCFREE(...)@pfree\n)\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/aclocal.m4": "dnl\ndnl %CopyrightBegin%\ndnl\ndnl Copyright Ericsson AB 1998-2018. All Rights Reserved.\ndnl\ndnl Licensed under the Apache License, Version 2.0 (the \"License\");\ndnl you may not use this file except in compliance with the License.\ndnl You may obtain a copy of the License at\ndnl\ndnl     http://www.apache.org/licenses/LICENSE-2.0\ndnl\ndnl Unless required by applicable law or agreed to in writing, software\ndnl distributed under the License is distributed on an \"AS IS\" BASIS,\ndnl WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\ndnl See the License for the specific language governing permissions and\ndnl limitations under the License.\ndnl\ndnl %CopyrightEnd%\ndnl\n\ndnl\ndnl aclocal.m4\ndnl\ndnl Local macros used in configure.in. The Local Macros which\ndnl could/should be part of autoconf are prefixed LM_, macros specific\ndnl to the Erlang system are prefixed ERL_.\ndnl\n\nAC_DEFUN(LM_PRECIOUS_VARS,\n[\n\ndnl ERL_TOP\nAC_ARG_VAR(ERL_TOP, [Erlang/OTP top source directory])\n\ndnl Tools\nAC_ARG_VAR(CC, [C compiler])\nAC_ARG_VAR(CFLAGS, [C compiler flags])\nAC_ARG_VAR(STATIC_CFLAGS, [C compiler static flags])\nAC_ARG_VAR(CFLAG_RUNTIME_LIBRARY_PATH, [runtime library path linker flag passed via C compiler])\nAC_ARG_VAR(CPP, [C/C++ preprocessor])\nAC_ARG_VAR(CPPFLAGS, [C/C++ preprocessor flags])\nAC_ARG_VAR(CXX, [C++ compiler])\nAC_ARG_VAR(CXXFLAGS, [C++ compiler flags])\nAC_ARG_VAR(LD, [linker (is often overridden by configure)])\nAC_ARG_VAR(LDFLAGS, [linker flags (can be risky to set since LD may be overriden by configure)])\nAC_ARG_VAR(LIBS, [libraries])\nAC_ARG_VAR(DED_LD, [linker for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(DED_LDFLAGS, [linker flags for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(DED_LD_FLAG_RUNTIME_LIBRARY_PATH, [runtime library path linker flag for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(LFS_CFLAGS, [large file support C compiler flags (set all LFS_* variables or none)])\nAC_ARG_VAR(LFS_LDFLAGS, [large file support linker flags (set all LFS_* variables or none)])\nAC_ARG_VAR(LFS_LIBS, [large file support libraries (set all LFS_* variables or none)])\nAC_ARG_VAR(RANLIB, [ranlib])\nAC_ARG_VAR(AR, [ar])\nAC_ARG_VAR(GETCONF, [getconf])\n\ndnl Cross system root\nAC_ARG_VAR(erl_xcomp_sysroot, [Absolute cross system root path (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_isysroot, [Absolute cross system root include path (only used when cross compiling)])\n\ndnl Cross compilation variables\nAC_ARG_VAR(erl_xcomp_bigendian, [big endian system: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_double_middle_endian, [double-middle-endian system: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_nptl, [have Native POSIX Thread Library: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_usable_sigusrx, [SIGUSR1 and SIGUSR2 can be used: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_usable_sigaltstack, [have working sigaltstack(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_poll, [have working poll(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_kqueue, [have working kqueue(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_putenv_copy, [putenv() stores key-value copy: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_reliable_fpe, [have reliable floating point exceptions: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_getaddrinfo, [have working getaddrinfo() for both IPv4 and IPv6: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_gethrvtime_procfs_ioctl, [have working gethrvtime() which can be used with procfs ioctl(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_clock_gettime_cpu_time, [clock_gettime() can be used for retrieving process CPU time: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_after_morecore_hook, [__after_morecore_hook can track malloc()s core memory usage: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_dlsym_brk_wrappers, [dlsym(RTLD_NEXT, _) brk wrappers can track malloc()s core memory usage: yes|no (only used when cross compiling)])\n\n])\n\nAC_DEFUN(ERL_XCOMP_SYSROOT_INIT,\n[\nerl_xcomp_without_sysroot=no\nif test \"$cross_compiling\" = \"yes\"; then\n    test \"$erl_xcomp_sysroot\" != \"\" || erl_xcomp_without_sysroot=yes\n    test \"$erl_xcomp_isysroot\" != \"\" || erl_xcomp_isysroot=\"$erl_xcomp_sysroot\"\nelse\n    erl_xcomp_sysroot=\n    erl_xcomp_isysroot=\nfi\n])\n\nAC_DEFUN(LM_CHECK_GETCONF,\n[\nif test \"$cross_compiling\" != \"yes\"; then\n    AC_CHECK_PROG([GETCONF], [getconf], [getconf], [false])\nelse\n    dnl First check if we got a `<HOST>-getconf' in $PATH\n    host_getconf=\"$host_alias-getconf\"\n    AC_CHECK_PROG([GETCONF], [$host_getconf], [$host_getconf], [false])\n    if test \"$GETCONF\" = \"false\" && test \"$erl_xcomp_sysroot\" != \"\"; then\n\tdnl We should perhaps give up if we have'nt found it by now, but at\n\tdnl least in one Tilera MDE `getconf' under sysroot is a bourne\n\tdnl shell script which we can use. We try to find `<HOST>-getconf'\n    \tdnl or `getconf' under sysconf, but only under sysconf since\n\tdnl `getconf' in $PATH is almost guaranteed to be for the build\n\tdnl machine.\n\tGETCONF=\n\tprfx=\"$erl_xcomp_sysroot\"\n        AC_PATH_TOOL([GETCONF], [getconf], [false],\n\t             [\"$prfx/usr/bin:$prfx/bin:$prfx/usr/local/bin\"])\n    fi\nfi\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_WINDOWS_ENVIRONMENT\ndnl\ndnl\ndnl Tries to determine thw windows build environment, i.e. \ndnl MIXED_CYGWIN_VC or MIXED_MSYS_VC \ndnl\n\nAC_DEFUN(LM_WINDOWS_ENVIRONMENT,\n[\n\nif test \"X$windows_environment_\" != \"Xchecked\"; then\nwindows_environment_=checked\nMIXED_CYGWIN=no\nMIXED_MSYS=no\n\nAC_MSG_CHECKING(for mixed cygwin or msys and native VC++ environment)\nif test \"X$host\" = \"Xwin32\" -a \"x$GCC\" != \"xyes\"; then\n\tif test -x /usr/bin/msys-?.0.dll; then\n\t        CFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_MSYS=yes\n\t\tAC_MSG_RESULT([MSYS and VC])\n\t\tMIXED_MSYS_VC=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_MSYS_VC\"\n\telif test -x /usr/bin/cygpath; then\n\t\tCFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_CYGWIN=yes\n\t\tAC_MSG_RESULT([Cygwin and VC])\n\t\tMIXED_CYGWIN_VC=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_CYGWIN_VC\"\n\telse\t\t    \n\t\tAC_MSG_RESULT([undeterminable])\n\t\tAC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)\n\tfi\nelse\n\tAC_MSG_RESULT([no])\n\tMIXED_CYGWIN_VC=no\n\tMIXED_MSYS_VC=no\nfi\nAC_SUBST(MIXED_CYGWIN_VC)\nAC_SUBST(MIXED_MSYS_VC)\n\nMIXED_VC=no\nif test \"x$MIXED_MSYS_VC\" = \"xyes\" -o  \"x$MIXED_CYGWIN_VC\" = \"xyes\" ; then\n   MIXED_VC=yes\nfi\n\nAC_SUBST(MIXED_VC)\n\nif test \"x$MIXED_MSYS\" != \"xyes\"; then\n   AC_MSG_CHECKING(for mixed cygwin and native MinGW environment)\n   if test \"X$host\" = \"Xwin32\" -a \"x$GCC\" = x\"yes\"; then\n\tif test -x /usr/bin/cygpath; then\n\t\tCFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_CYGWIN=yes\n\t\tAC_MSG_RESULT([yes])\n\t\tMIXED_CYGWIN_MINGW=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_CYGWIN_MINGW\"\n\telse\n\t\tAC_MSG_RESULT([undeterminable])\n\t\tAC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)\n\tfi\n    else\n\tAC_MSG_RESULT([no])\n\tMIXED_CYGWIN_MINGW=no\n    fi\nelse\n\tMIXED_CYGWIN_MINGW=no\nfi\t\nAC_SUBST(MIXED_CYGWIN_MINGW)\n\nAC_MSG_CHECKING(if we mix cygwin with any native compiler)\nif test \"X$MIXED_CYGWIN\" = \"Xyes\"; then\n\tAC_MSG_RESULT([yes])\t\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nAC_SUBST(MIXED_CYGWIN)\n\t\nAC_MSG_CHECKING(if we mix msys with another native compiler)\nif test \"X$MIXED_MSYS\" = \"Xyes\" ; then\n\tAC_MSG_RESULT([yes])\t\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nAC_SUBST(MIXED_MSYS)\n\nfi\n])\t\t\n\t\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_FIND_EMU_CC\ndnl\ndnl\ndnl Tries fairly hard to find a C compiler that can handle jump tables.\ndnl Defines the @EMU_CC@ variable for the makefiles and \ndnl inserts NO_JUMP_TABLE in the header if one cannot be found...\ndnl\n\nAC_DEFUN(LM_FIND_EMU_CC,\n\t[AC_CACHE_CHECK(for a compiler that handles jumptables,\n\t\t\tac_cv_prog_emu_cc,\n\t\t\t[\nAC_TRY_COMPILE([],[\n#if defined(__clang_major__) && __clang_major__ >= 3\n    /* clang 3.x or later is fine */\n#elif defined(__llvm__)\n#error \"this version of llvm is unable to correctly compile beam_emu.c\"\n#endif\n    __label__ lbl1;\n    __label__ lbl2;\n    int x = magic();\n    static void *jtab[2];\n\n    jtab[0] = &&lbl1;\n    jtab[1] = &&lbl2;\n    goto *jtab[x];\nlbl1:\n    return 1;\nlbl2:\n    return 2;\n],ac_cv_prog_emu_cc=\"$CC\",ac_cv_prog_emu_cc=no)\n\nif test \"$ac_cv_prog_emu_cc\" = no; then\n\tfor ac_progname in emu_cc.sh gcc-4.2 gcc; do\n  \t\tIFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\":\"\n  \t\tac_dummy=\"$PATH\"\n  \t\tfor ac_dir in $ac_dummy; do\n    \t\t\ttest -z \"$ac_dir\" && ac_dir=.\n    \t\t\tif test -f \"$ac_dir/$ac_progname\"; then\n      \t\t\t\tac_cv_prog_emu_cc=\"$ac_dir/$ac_progname\"\n      \t\t\t\tbreak\n    \t\t\tfi\n  \t\tdone\n  \t\tIFS=\"$ac_save_ifs\"\n\t\tif test \"$ac_cv_prog_emu_cc\" != no; then\n\t\t\tbreak\n\t\tfi\n\tdone\nfi\n\nif test \"$ac_cv_prog_emu_cc\" != no; then\n\tsave_CC=\"$CC\"\n\tsave_CFLAGS=$CFLAGS\n\tsave_CPPFLAGS=$CPPFLAGS\n\tCC=\"$ac_cv_prog_emu_cc\"\n\tCFLAGS=\"\"\n\tCPPFLAGS=\"\"\n\tAC_TRY_COMPILE([],[\n#if defined(__clang_major__) && __clang_major__ >= 3\n    /* clang 3.x or later is fine */\n#elif defined(__llvm__)\n#error \"this version of llvm is unable to correctly compile beam_emu.c\"\n#endif\n    \t__label__ lbl1;\n    \t__label__ lbl2;\n    \tint x = magic();\n    \tstatic void *jtab[2];\n\n    \tjtab[0] = &&lbl1;\n    \tjtab[1] = &&lbl2;\n    \tgoto *jtab[x];\n\tlbl1:\n    \treturn 1;\n\tlbl2:\n    \treturn 2;\n\t],ac_cv_prog_emu_cc=\"$CC\",ac_cv_prog_emu_cc=no)\n\tCC=$save_CC\n\tCFLAGS=$save_CFLAGS\n\tCPPFLAGS=$save_CPPFLAGS\nfi\n])\nif test \"$ac_cv_prog_emu_cc\" = no; then\n\tAC_DEFINE(NO_JUMP_TABLE,[],[Defined if no found C compiler can handle jump tables])\n\tEMU_CC=\"$CC\"\nelse\n\tEMU_CC=\"$ac_cv_prog_emu_cc\"\nfi\nAC_SUBST(EMU_CC)\n])\t\t\n\t\t\t\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_PROG_INSTALL_DIR\ndnl\ndnl This macro may be used by any OTP application.\ndnl\ndnl Figure out how to create directories with parents.\ndnl (In my opinion INSTALL_DIR is a bad name, MKSUBDIRS or something is better)\ndnl\ndnl We prefer 'install -d', but use 'mkdir -p' if it exists.\ndnl If none of these methods works, we give up.\ndnl\n\n\nAC_DEFUN(LM_PROG_INSTALL_DIR,\n[AC_CACHE_CHECK(how to create a directory including parents,\nac_cv_prog_mkdir_p,\n[\ntemp_name_base=config.$$\ntemp_name=$temp_name_base/x/y/z\n$INSTALL -d $temp_name >/dev/null 2>&1\nac_cv_prog_mkdir_p=none\nif test -d $temp_name; then\n        ac_cv_prog_mkdir_p=\"$INSTALL -d\"\nelse\n        mkdir -p $temp_name >/dev/null 2>&1\n        if test -d $temp_name; then\n                ac_cv_prog_mkdir_p=\"mkdir -p\"\n        fi\nfi\nrm -fr $temp_name_base           \n])\n\ncase \"${ac_cv_prog_mkdir_p}\" in\n  none) AC_MSG_ERROR(don't know how create directories with parents) ;;\n  *)    INSTALL_DIR=\"$ac_cv_prog_mkdir_p\" AC_SUBST(INSTALL_DIR)     ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_PROG_PERL5\ndnl\ndnl Try to find perl version 5. If found set PERL to the absolute path\ndnl of the program, if not found set PERL to false.\ndnl\ndnl On some systems /usr/bin/perl is perl 4 and e.g.\ndnl /usr/local/bin/perl is perl 5. We try to handle this case by\ndnl putting a couple of \ndnl Tries to handle the case that there are two programs called perl\ndnl in the path and one of them is perl 5 and the other isn't. \ndnl\nAC_DEFUN(LM_PROG_PERL5,\n[AC_PATH_PROGS(PERL, perl5 perl, false,\n   /usr/local/bin:/opt/local/bin:/usr/local/gnu/bin:${PATH})\nchangequote(, )dnl\ndnl[ That bracket is needed to balance the right bracket below\nif test \"$PERL\" = \"false\" || $PERL -e 'exit ($] >= 5)'; then\nchangequote([, ])dnl\n  ac_cv_path_PERL=false\n  PERL=false\ndnl  AC_MSG_WARN(perl version 5 not found)\nfi\n])dnl\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_SO_BSDCOMPAT\ndnl\ndnl Check if the system has the SO_BSDCOMPAT flag on sockets (linux) \ndnl\nAC_DEFUN(LM_DECL_SO_BSDCOMPAT,\n[AC_CACHE_CHECK([for SO_BSDCOMPAT declaration], ac_cv_decl_so_bsdcompat,\nAC_TRY_COMPILE([#include <sys/socket.h>], [int i = SO_BSDCOMPAT;],\n               ac_cv_decl_so_bsdcompat=yes,\n               ac_cv_decl_so_bsdcompat=no))\n\ncase \"${ac_cv_decl_so_bsdcompat}\" in\n  \"yes\" ) AC_DEFINE(HAVE_SO_BSDCOMPAT,[],\n\t\t[Define if you have SO_BSDCOMPAT flag on sockets]) ;;\n  * ) ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_INADDR_LOOPBACK\ndnl\ndnl Try to find declaration of INADDR_LOOPBACK, if nowhere provide a default\ndnl\n\nAC_DEFUN(LM_DECL_INADDR_LOOPBACK,\n[AC_CACHE_CHECK([for INADDR_LOOPBACK in netinet/in.h],\n ac_cv_decl_inaddr_loopback,\n[AC_TRY_COMPILE([#include <sys/types.h>\n#include <netinet/in.h>], [int i = INADDR_LOOPBACK;],\nac_cv_decl_inaddr_loopback=yes, ac_cv_decl_inaddr_loopback=no)\n])\n\nif test ${ac_cv_decl_inaddr_loopback} = no; then\n  AC_CACHE_CHECK([for INADDR_LOOPBACK in rpc/types.h],\n                   ac_cv_decl_inaddr_loopback_rpc,\n                   AC_TRY_COMPILE([#include <rpc/types.h>],\n                                   [int i = INADDR_LOOPBACK;],\n                                   ac_cv_decl_inaddr_loopback_rpc=yes,\n                                   ac_cv_decl_inaddr_loopback_rpc=no))\n\n   case \"${ac_cv_decl_inaddr_loopback_rpc}\" in\n     \"yes\" )\n        AC_DEFINE(DEF_INADDR_LOOPBACK_IN_RPC_TYPES_H,[],\n\t\t[Define if you need to include rpc/types.h to get INADDR_LOOPBACK defined]) ;;\n      * )\n  \tAC_CACHE_CHECK([for INADDR_LOOPBACK in winsock2.h],\n                   ac_cv_decl_inaddr_loopback_winsock2,\n                   AC_TRY_COMPILE([#define WIN32_LEAN_AND_MEAN\n\t\t\t\t   #include <winsock2.h>],\n                                   [int i = INADDR_LOOPBACK;],\n                                   ac_cv_decl_inaddr_loopback_winsock2=yes,\n                                   ac_cv_decl_inaddr_loopback_winsock2=no))\n\tcase \"${ac_cv_decl_inaddr_loopback_winsock2}\" in\n     \t\t\"yes\" )\n\t\t\tAC_DEFINE(DEF_INADDR_LOOPBACK_IN_WINSOCK2_H,[],\n\t\t\t\t[Define if you need to include winsock2.h to get INADDR_LOOPBACK defined]) ;;\n\t\t* )\n\t\t\t# couldn't find it anywhere\n        \t\tAC_DEFINE(HAVE_NO_INADDR_LOOPBACK,[],\n\t\t\t\t[Define if you don't have a definition of INADDR_LOOPBACK]) ;;\n\tesac;;\n   esac\nfi\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_STRUCT_SOCKADDR_SA_LEN\ndnl\ndnl Check if the sockaddr structure has the field sa_len\ndnl\n\nAC_DEFUN(LM_STRUCT_SOCKADDR_SA_LEN,\n[AC_CACHE_CHECK([whether struct sockaddr has sa_len field],\n                ac_cv_struct_sockaddr_sa_len,\nAC_TRY_COMPILE([#include <sys/types.h>\n#include <sys/socket.h>], [struct sockaddr s; s.sa_len = 10;],\n  ac_cv_struct_sockaddr_sa_len=yes, ac_cv_struct_sockaddr_sa_len=no))\n\ndnl FIXME convbreak\ncase ${ac_cv_struct_sockaddr_sa_len} in\n  \"no\" ) AC_DEFINE(NO_SA_LEN,[1],[Define if you dont have salen]) ;;\n  *) ;;\nesac\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_STRUCT_EXCEPTION\ndnl\ndnl Check to see whether the system supports the matherr function\ndnl and its associated type \"struct exception\".\ndnl\n\nAC_DEFUN(LM_STRUCT_EXCEPTION,\n[AC_CACHE_CHECK([for struct exception (and matherr function)],\n ac_cv_struct_exception,\nAC_TRY_COMPILE([#include <math.h>],\n  [struct exception x; x.type = DOMAIN; x.type = SING;],\n  ac_cv_struct_exception=yes, ac_cv_struct_exception=no))\n\ncase \"${ac_cv_struct_exception}\" in\n  \"yes\" ) AC_DEFINE(USE_MATHERR,[1],[Define if you have matherr() function and struct exception type]) ;;\n  *  ) ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_SYS_IPV6\ndnl\ndnl Check for ipv6 support and what the in6_addr structure is called.\ndnl (early linux used in_addr6 insted of in6_addr)\ndnl\n\nAC_DEFUN(LM_SYS_IPV6,\n[AC_MSG_CHECKING(for IP version 6 support)\nAC_CACHE_VAL(ac_cv_sys_ipv6_support,\n[ok_so_far=yes\n AC_TRY_COMPILE([#include <sys/types.h>\n#ifdef __WIN32__\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <netinet/in.h>\n#endif],\n   [struct in6_addr a6; struct sockaddr_in6 s6;], ok_so_far=yes, ok_so_far=no)\n\nif test $ok_so_far = yes; then\n  ac_cv_sys_ipv6_support=yes\nelse\n  AC_TRY_COMPILE([#include <sys/types.h>\n#ifdef __WIN32__\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <netinet/in.h>\n#endif],\n    [struct in_addr6 a6; struct sockaddr_in6 s6;],\n    ac_cv_sys_ipv6_support=in_addr6, ac_cv_sys_ipv6_support=no)\nfi\n])dnl\n\ndnl\ndnl Have to use old style AC_DEFINE due to BC with old autoconf.\ndnl\n\ncase ${ac_cv_sys_ipv6_support} in\n  yes)\n    AC_MSG_RESULT(yes)\n    AC_DEFINE(HAVE_IN6,[1],[Define if ipv6 is present])\n    ;;\n  in_addr6)\n    AC_MSG_RESULT([yes (but I am redefining in_addr6 to in6_addr)])\n    AC_DEFINE(HAVE_IN6,[1],[Define if ipv6 is present])\n    AC_DEFINE(HAVE_IN_ADDR6_STRUCT,[],[Early linux used in_addr6 instead of in6_addr, define if you have this])\n    ;;\n  *)\n    AC_MSG_RESULT(no)\n    ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_SYS_MULTICAST\ndnl\ndnl Check for multicast support. Only checks for multicast options in\ndnl setsockopt(), no check is performed that multicasting actually works.\ndnl If options are found defines HAVE_MULTICAST_SUPPORT\ndnl\n\nAC_DEFUN(LM_SYS_MULTICAST,\n[AC_CACHE_CHECK([for multicast support], ac_cv_sys_multicast_support,\n[AC_EGREP_CPP(^yes$,\n[#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#if defined(IP_MULTICAST_TTL) && defined(IP_MULTICAST_LOOP) && defined(IP_MULTICAST_IF) && defined(IP_ADD_MEMBERSHIP) && defined(IP_DROP_MEMBERSHIP)\nyes\n#endif\n], ac_cv_sys_multicast_support=yes, ac_cv_sys_multicast_support=no)])\nif test $ac_cv_sys_multicast_support = yes; then\n  AC_DEFINE(HAVE_MULTICAST_SUPPORT,[1],\n\t[Define if setsockopt() accepts multicast options])\nfi\n])dnl\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_SYS_ERRLIST\ndnl\ndnl Define SYS_ERRLIST_DECLARED if the variable sys_errlist is declared\ndnl in a system header file, stdio.h or errno.h.\ndnl\n\nAC_DEFUN(LM_DECL_SYS_ERRLIST,\n[AC_CACHE_CHECK([for sys_errlist declaration in stdio.h or errno.h],\n  ac_cv_decl_sys_errlist,\n[AC_TRY_COMPILE([#include <stdio.h>\n#include <errno.h>], [char *msg = *(sys_errlist + 1);],\n  ac_cv_decl_sys_errlist=yes, ac_cv_decl_sys_errlist=no)])\nif test $ac_cv_decl_sys_errlist = yes; then\n  AC_DEFINE(SYS_ERRLIST_DECLARED,[],\n\t[define if the variable sys_errlist is declared in a system header file])\nfi\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_CHECK_FUNC_DECL( funname, declaration [, extra includes \ndnl                     [, action-if-found [, action-if-not-found]]] )\ndnl\ndnl Checks if the declaration \"declaration\" of \"funname\" conflicts\ndnl with the header files idea of how the function should be\ndnl declared. It is useful on systems which lack prototypes and you\ndnl need to provide your own (e.g. when you want to take the address\ndnl of a function). The 4'th argument is expanded if conflicting, \ndnl the 5'th argument otherwise\ndnl\ndnl\n\nAC_DEFUN(LM_CHECK_FUNC_DECL,\n[AC_MSG_CHECKING([for conflicting declaration of $1])\nAC_CACHE_VAL(ac_cv_func_decl_$1,\n[AC_TRY_COMPILE([#include <stdio.h>\n$3],[$2\nchar *c = (char *)$1;\n], eval \"ac_cv_func_decl_$1=no\", eval \"ac_cv_func_decl_$1=yes\")])\nif eval \"test \\\"`echo '$ac_cv_func_decl_'$1`\\\" = yes\"; then\n  AC_MSG_RESULT(yes)\n  ifelse([$4], , :, [$4])\nelse\n  AC_MSG_RESULT(no)\nifelse([$5], , , [$5\n])dnl\nfi\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl AC_DOUBLE_MIDDLE_ENDIAN\ndnl\ndnl Checks whether doubles are represented in \"middle-endian\" format.\ndnl Sets ac_cv_double_middle_endian={no,yes,unknown} accordingly,\ndnl as well as DOUBLE_MIDDLE_ENDIAN.\ndnl\ndnl\n\nAC_DEFUN([AC_C_DOUBLE_MIDDLE_ENDIAN],\n[AC_CACHE_CHECK(whether double word ordering is middle-endian, ac_cv_c_double_middle_endian,\n[# It does not; compile a test program.\nAC_RUN_IFELSE(\n[AC_LANG_SOURCE([[#include <stdlib.h>\n\nint\nmain(void)\n{\n  int i = 0;\n  int zero = 0;\n  int bigendian;\n  int zero_index = 0;\n\n  union\n  {\n    long int l;\n    char c[sizeof (long int)];\n  } u;\n\n  /* we'll use the one with 32-bit words */\n  union\n  {\n    double d;\n    unsigned int c[2];\n  } vint;\n\n  union\n  {\n    double d;\n    unsigned long c[2];\n  } vlong;\n\n  union\n  {\n    double d;\n    unsigned short c[2];\n  } vshort;\n\n\n  /* Are we little or big endian?  From Harbison&Steele.  */\n  u.l = 1;\n  bigendian = (u.c[sizeof (long int) - 1] == 1);\n\n  zero_index = bigendian ? 1 : 0;\n\n  vint.d = 1.0;\n  vlong.d = 1.0;\n  vshort.d = 1.0;\n\n  if (sizeof(unsigned int) == 4)\n    {\n      if (vint.c[zero_index] != 0)\n\tzero = 1;\n    }\n  else if (sizeof(unsigned long) == 4)\n    {\n      if (vlong.c[zero_index] != 0)\n\tzero = 1;\n    }\n  else if (sizeof(unsigned short) == 4)\n    {\n      if (vshort.c[zero_index] != 0)\n\tzero = 1;\n    }\n\n  exit (zero);\n}\n]])],\n\t      [ac_cv_c_double_middle_endian=no],\n\t      [ac_cv_c_double_middle_endian=yes],\n\t      [ac_cv_c_double_middle=unknown])])\ncase $ac_cv_c_double_middle_endian in\n  yes)\n    m4_default([$1],\n      [AC_DEFINE([DOUBLE_MIDDLE_ENDIAN], 1,\n\t[Define to 1 if your processor stores the words in a double in\n\t middle-endian format (like some ARMs).])]) ;;\n  no)\n    $2 ;;\n  *)\n    m4_default([$3],\n      [AC_MSG_WARN([unknown double endianness\npresetting ac_cv_c_double_middle_endian=no (or yes) will help])]) ;;\nesac\n])# AC_C_DOUBLE_MIDDLE_ENDIAN\n\n\nAC_DEFUN(ERL_MONOTONIC_CLOCK,\n[\n  if test \"$3\" = \"yes\"; then\n     default_resolution_clock_gettime_monotonic=\"CLOCK_HIGHRES CLOCK_BOOTTIME CLOCK_MONOTONIC\"\n     low_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_COARSE CLOCK_MONOTONIC_FAST\"\n     high_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_PRECISE\"\n  else\n     default_resolution_clock_gettime_monotonic=\"CLOCK_HIGHRES CLOCK_UPTIME CLOCK_MONOTONIC\"\n     low_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_COARSE CLOCK_UPTIME_FAST\"\n     high_resolution_clock_gettime_monotonic=\"CLOCK_UPTIME_PRECISE\"\n  fi\n\n  case \"$1\" in\n    high_resolution)\n\tcheck_msg=\"high resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$high_resolution_clock_gettime_monotonic\"\n\t;;\n    low_resolution)\n\tcheck_msg=\"low resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$low_resolution_clock_gettime_monotonic\"\n\t;;\n    custom_resolution)\n\tcheck_msg=\"custom resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$2\"\n\t;;\n    *)\n\tcheck_msg=\"custom \"\n\tprefer_resolution_clock_gettime_monotonic=\"$2\"\n\t;;\n  esac\n\n  clock_gettime_lib=\"\"\n  AC_CHECK_LIB(rt, clock_gettime, [clock_gettime_lib=\"-lrt\"])\n\n  save_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $clock_gettime_lib\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     trust_test=\"#error May not be there due to weak linking\"\n  else\n     trust_test=\"\"\n  fi\n\n  AC_CACHE_CHECK([for clock_gettime(CLOCK_MONOTONIC_RAW, _)], erl_cv_clock_gettime_monotonic_raw,\n  [\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime(CLOCK_MONOTONIC_RAW, &ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_monotonic_raw=yes,\n\t\t      erl_cv_clock_gettime_monotonic_raw=no)\n  ])\n\n  AC_CACHE_CHECK([for clock_gettime() with ${check_msg}monotonic clock type], erl_cv_clock_gettime_monotonic_$1,\n  [\n     for clock_type in $prefer_resolution_clock_gettime_monotonic $default_resolution_clock_gettime_monotonic $high_resolution_clock_gettime_monotonic $low_resolution_clock_gettime_monotonic; do\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime($clock_type,&ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_monotonic_$1=$clock_type,\n\t\t      erl_cv_clock_gettime_monotonic_$1=no)\n       test $erl_cv_clock_gettime_monotonic_$1 = no || break\n     done\n  ])\n\n  LIBS=\"$save_LIBS\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     check_for_clock_getres=\n  else\n     check_for_clock_getres=clock_getres\n  fi\n\n  AC_CHECK_FUNCS([$check_for_clock_getres clock_get_attributes gethrtime])\n  \n  AC_CACHE_CHECK([for mach clock_get_time() with monotonic clock type], erl_cv_mach_clock_get_time_monotonic,\n  [\n     AC_TRY_COMPILE([\n#include <mach/clock.h>\n#include <mach/mach.h>\n\t\t\t],\n\t \t\t[\n    kern_return_t res;\n    clock_serv_t clk_srv;\n    mach_timespec_t time_spec;\n\n    host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &clk_srv);\n    res = clock_get_time(clk_srv, &time_spec);\n    mach_port_deallocate(mach_task_self(), clk_srv);\n    \t\t\t],\n    \t\t\terl_cv_mach_clock_get_time_monotonic=yes,\n\t\t\terl_cv_mach_clock_get_time_monotonic=no)\n  ])\n  \n  erl_corrected_monotonic_clock=no\n  case $erl_cv_clock_gettime_monotonic_$1-$ac_cv_func_gethrtime-$erl_cv_mach_clock_get_time_monotonic-$host_os in\n    *-*-*-win32)\n      erl_monotonic_clock_func=WindowsAPI\n      ;;\n    CLOCK_*-*-*-linux*)\n      case $erl_cv_clock_gettime_monotonic_$1-$erl_cv_clock_gettime_monotonic_raw in\n        CLOCK_BOOTTIME-yes|CLOCK_MONOTONIC-yes)\n\t  erl_corrected_monotonic_clock=yes\n\t  ;;\n\t*)\n\t  # We don't trust CLOCK_MONOTONIC to be NTP\n\t  # adjusted on linux systems that do not have\n\t  # CLOCK_MONOTONIC_RAW (although it seems to\n\t  # be...)\n\t  ;;\n      esac\n      erl_monotonic_clock_func=clock_gettime\n      ;;\n    no-no-no-linux*)\n      erl_monotonic_clock_func=times\n      ;;\n    CLOCK_*-*-*-*)\n      erl_monotonic_clock_func=clock_gettime\n      ;;\n    no-yes-*-*)\n      erl_monotonic_clock_func=gethrtime\n      ;;\n    no-no-yes-*)\n      erl_monotonic_clock_func=mach_clock_get_time\n      ;;\n    no-no-no-*)\n      erl_monotonic_clock_func=none\n      ;;\n  esac\n\n  erl_monotonic_clock_low_resolution=no\n  erl_monotonic_clock_lib=\n  erl_monotonic_clock_id=\n  case $erl_monotonic_clock_func in\n    clock_gettime)\n      erl_monotonic_clock_id=$erl_cv_clock_gettime_monotonic_$1\n      for low_res_id in $low_resolution_clock_gettime_monotonic; do\n      \t  if test $erl_monotonic_clock_id = $low_res_id; then\n\t    erl_monotonic_clock_low_resolution=yes\n\t    break\n\t  fi\n      done\n      erl_monotonic_clock_lib=$clock_gettime_lib\n      ;;\n    mach_clock_get_time)\n      erl_monotonic_clock_id=SYSTEM_CLOCK\n      ;;\n    times)\n      erl_monotonic_clock_low_resolution=yes\n      ;;\n    *)\n      ;;\n  esac\n \n])\n\nAC_DEFUN(ERL_WALL_CLOCK,\n[\n  default_resolution_clock_gettime_wall=\"CLOCK_REALTIME\"\n  low_resolution_clock_gettime_wall=\"CLOCK_REALTIME_COARSE CLOCK_REALTIME_FAST\"\n  high_resolution_clock_gettime_wall=\"CLOCK_REALTIME_PRECISE\"\n\n  case \"$1\" in\n    high_resolution)\n\tcheck_msg=\"high resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$high_resolution_clock_gettime_wall\"\n\t;;\n    low_resolution)\n\tcheck_msg=\"low resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$low_resolution_clock_gettime_wall\"\n\t;;\n    custom_resolution)\n\tcheck_msg=\"custom resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$2\"\n\t;;\n    *)\n\tcheck_msg=\"\"\n\tprefer_resolution_clock_gettime_wall=\n\t;;\n  esac\n\n  clock_gettime_lib=\"\"\n  AC_CHECK_LIB(rt, clock_gettime, [clock_gettime_lib=\"-lrt\"])\n\n  save_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $clock_gettime_lib\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     trust_test=\"#error May not be there due to weak linking\"\n  else\n     trust_test=\"\"\n  fi\n\n  AC_CACHE_CHECK([for clock_gettime() with ${check_msg}wall clock type], erl_cv_clock_gettime_wall_$1,\n  [\n     for clock_type in $prefer_resolution_clock_gettime_wall $default_resolution_clock_gettime_wall $high_resolution_clock_gettime_wall $low_resolution_clock_gettime_wall; do\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime($clock_type,&ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_wall_$1=$clock_type,\n\t\t      erl_cv_clock_gettime_wall_$1=no)\n       test $erl_cv_clock_gettime_wall_$1 = no || break\n     done\n  ])\n\n  LIBS=\"$save_LIBS\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     check_for_clock_getres=\n  else\n     check_for_clock_getres=clock_getres\n  fi\n\n  AC_CHECK_FUNCS([$check_for_clock_getres clock_get_attributes gettimeofday])\n  \n  AC_CACHE_CHECK([for mach clock_get_time() with wall clock type], erl_cv_mach_clock_get_time_wall,\n  [\n     AC_TRY_COMPILE([\n#include <mach/clock.h>\n#include <mach/mach.h>\n\t\t\t],\n\t \t\t[\n    kern_return_t res;\n    clock_serv_t clk_srv;\n    mach_timespec_t time_spec;\n\n    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &clk_srv);\n    res = clock_get_time(clk_srv, &time_spec);\n    mach_port_deallocate(mach_task_self(), clk_srv);\n    \t\t\t],\n    \t\t\terl_cv_mach_clock_get_time_wall=yes,\n\t\t\terl_cv_mach_clock_get_time_wall=no)\n  ])\n\n  erl_wall_clock_lib=\n  erl_wall_clock_low_resolution=no\n  erl_wall_clock_id=\n  case $1-$erl_cv_clock_gettime_wall_$1-$erl_cv_mach_clock_get_time_wall-$ac_cv_func_gettimeofday-$host_os in\n    *-*-*-*-win32)\n      erl_wall_clock_func=WindowsAPI\n      erl_wall_clock_low_resolution=yes\n      ;;\n    high_resolution-no-yes-*-*)\n      erl_wall_clock_func=mach_clock_get_time\n      erl_wall_clock_id=CALENDAR_CLOCK\n      ;;\n    *-CLOCK_*-*-*-*)\n      erl_wall_clock_func=clock_gettime\n      erl_wall_clock_lib=$clock_gettime_lib\n      erl_wall_clock_id=$erl_cv_clock_gettime_wall_$1\n      for low_res_id in $low_resolution_clock_gettime_wall; do\n      \t  if test $erl_wall_clock_id = $low_res_id; then\n\t    erl_wall_clock_low_resolution=yes\n\t    break\n\t  fi\n      done\n      ;;\n    *-no-*-yes-*)\n      erl_wall_clock_func=gettimeofday\n      ;;\n    *)\n      erl_wall_clock_func=none\n      ;;\n  esac\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_CHECK_THR_LIB\ndnl\ndnl This macro may be used by any OTP application.\ndnl\ndnl LM_CHECK_THR_LIB sets THR_LIBS, THR_DEFS, and THR_LIB_NAME. It also\ndnl checks for some pthread headers which will appear in DEFS or config.h.\ndnl\n\nAC_DEFUN(LM_CHECK_THR_LIB,\n[\n\nNEED_NPTL_PTHREAD_H=no\n\ndnl win32?\nAC_MSG_CHECKING([for native win32 threads])\nif test \"X$host_os\" = \"Xwin32\"; then\n    AC_MSG_RESULT(yes)\n    THR_DEFS=\"-DWIN32_THREADS\"\n    THR_LIBS=\n    THR_LIB_NAME=win32_threads\n    THR_LIB_TYPE=win32_threads\nelse\n    AC_MSG_RESULT(no)\n    THR_DEFS=\n    THR_LIBS=\n    THR_LIB_NAME=\n    THR_LIB_TYPE=posix_unknown\n\ndnl Try to find POSIX threads\n\ndnl The usual pthread lib...\n    AC_CHECK_LIB(pthread, pthread_create, THR_LIBS=\"-lpthread\")\n\ndnl Very old versions of FreeBSD have pthreads in special c library, c_r...\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_CHECK_LIB(c_r, pthread_create, THR_LIBS=\"-lc_r\")\n    fi\n\ndnl QNX has pthreads in standard C library\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_CHECK_FUNC(pthread_create, THR_LIBS=\"none_needed\")\n    fi\n\ndnl On ofs1 the '-pthread' switch should be used\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_MSG_CHECKING([if the '-pthread' switch can be used])\n\tsaved_cflags=$CFLAGS\n\tCFLAGS=\"$CFLAGS -pthread\"\n\tAC_TRY_LINK([#include <pthread.h>],\n\t\t    pthread_create((void*)0,(void*)0,(void*)0,(void*)0);,\n\t\t    [THR_DEFS=\"-pthread\"\n\t\t     THR_LIBS=\"-pthread\"])\n\tCFLAGS=$saved_cflags\n\tif test \"x$THR_LIBS\" != \"x\"; then\n\t    AC_MSG_RESULT(yes)\n\telse\n\t    AC_MSG_RESULT(no)\n\tfi\n    fi\n\n    if test \"x$THR_LIBS\" != \"x\"; then\n\tTHR_DEFS=\"$THR_DEFS -D_THREAD_SAFE -D_REENTRANT -DPOSIX_THREADS\"\n\tTHR_LIB_NAME=pthread\n\tif test \"x$THR_LIBS\" = \"xnone_needed\"; then\n\t    THR_LIBS=\n\tfi\n\tcase $host_os in\n\t    solaris*)\n\t\tTHR_DEFS=\"$THR_DEFS -D_POSIX_PTHREAD_SEMANTICS\" ;;\n\t    linux*)\n\t\tTHR_DEFS=\"$THR_DEFS -D_POSIX_THREAD_SAFE_FUNCTIONS\"\n\n\t\tLM_CHECK_GETCONF\n\t\tAC_MSG_CHECKING(for Native POSIX Thread Library)\n\t\tlibpthr_vsn=`$GETCONF GNU_LIBPTHREAD_VERSION 2>/dev/null`\n\t\tif test $? -eq 0; then\n\t\t    case \"$libpthr_vsn\" in\n\t\t\t*nptl*|*NPTL*) nptl=yes;;\n\t\t\t*) nptl=no;;\n\t\t    esac\n\t\telif test \"$cross_compiling\" = \"yes\"; then\n\t\t    case \"$erl_xcomp_linux_nptl\" in\n\t\t\t\"\") nptl=cross;;\n\t\t\tyes|no) nptl=$erl_xcomp_linux_nptl;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_nptl value: $erl_xcomp_linux_nptl]);;\n\t\t    esac\n\t\telse\n\t\t    nptl=no\n\t\tfi\n\t\tAC_MSG_RESULT($nptl)\n\t\tif test $nptl = cross; then\n\t\t    nptl=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $nptl = yes; then\n\t\t    THR_LIB_TYPE=posix_nptl\n\t\t    need_nptl_incldir=no\n\t\t    AC_CHECK_HEADER(nptl/pthread.h,\n\t\t\t\t    [need_nptl_incldir=yes\n\t\t\t\t     NEED_NPTL_PTHREAD_H=yes])\n\t\t    if test $need_nptl_incldir = yes; then\n\t\t\t# Ahh...\n\t\t\tnptl_path=\"$C_INCLUDE_PATH:$CPATH\"\n\t\t\tif test X$cross_compiling != Xyes; then\n\t\t\t    nptl_path=\"$nptl_path:/usr/local/include:/usr/include\"\n\t\t\telse\n\t\t\t    IROOT=\"$erl_xcomp_isysroot\"\n\t\t\t    test \"$IROOT\" != \"\" || IROOT=\"$erl_xcomp_sysroot\"\n\t\t\t    test \"$IROOT\" != \"\" || AC_MSG_ERROR([Don't know where to search for includes! Please set erl_xcomp_isysroot])\n\t\t\t    nptl_path=\"$nptl_path:$IROOT/usr/local/include:$IROOT/usr/include\"\n\t\t\tfi\n\t\t\tnptl_ws_path=\n\t\t\tsave_ifs=\"$IFS\"; IFS=\":\"\n\t\t\tfor dir in $nptl_path; do\n\t\t\t    if test \"x$dir\" != \"x\"; then\n\t\t\t\tnptl_ws_path=\"$nptl_ws_path $dir\"\n\t\t\t    fi\n\t\t\tdone\n\t\t\tIFS=$save_ifs\n\t\t\tnptl_incldir=\n\t\t\tfor dir in $nptl_ws_path; do\n\t\t            AC_CHECK_HEADER($dir/nptl/pthread.h,\n\t\t\t\t\t    nptl_incldir=$dir/nptl)\n\t\t\t    if test \"x$nptl_incldir\" != \"x\"; then\n\t\t\t\tTHR_DEFS=\"$THR_DEFS -isystem $nptl_incldir\"\n\t\t\t\tbreak\n\t\t\t    fi\n\t\t\tdone\n\t\t\tif test \"x$nptl_incldir\" = \"x\"; then\n\t\t\t    AC_MSG_ERROR(Failed to locate nptl system include directory)\n\t\t\tfi\n\t\t    fi\n\t\tfi\n\t\t;;\n\t    *) ;;\n\tesac\n\n\tdnl We sometimes need THR_DEFS in order to find certain headers\n\tdnl (at least for pthread.h on osf1).\n\tsaved_cppflags=$CPPFLAGS\n\tCPPFLAGS=\"$CPPFLAGS $THR_DEFS\"\n\n\tdnl\n\tdnl Check for headers\n\tdnl\n\n\tAC_CHECK_HEADER(pthread.h,\n\t\t\tAC_DEFINE(HAVE_PTHREAD_H, 1, \\\n[Define if you have the <pthread.h> header file.]))\n\n\tdnl Some Linuxes have <pthread/mit/pthread.h> instead of <pthread.h>\n\tAC_CHECK_HEADER(pthread/mit/pthread.h, \\\n\t\t\tAC_DEFINE(HAVE_MIT_PTHREAD_H, 1, \\\n[Define if the pthread.h header file is in pthread/mit directory.]))\n\n\tdnl restore CPPFLAGS\n\tCPPFLAGS=$saved_cppflags\n\n    fi\nfi\n\n])\n\nAC_DEFUN(ERL_INTERNAL_LIBS,\n[\n\nERTS_INTERNAL_X_LIBS=\n\nAC_CHECK_LIB(kstat, kstat_open,\n[AC_DEFINE(HAVE_KSTAT, 1, [Define if you have kstat])\nERTS_INTERNAL_X_LIBS=\"$ERTS_INTERNAL_X_LIBS -lkstat\"])\n\nAC_SUBST(ERTS_INTERNAL_X_LIBS)\n\n])\n\nAC_DEFUN(ETHR_CHK_GCC_ATOMIC_OP__,\n[\n    # $1 - atomic_op\n\n    for atomic_bit_size in 32 64 128; do\n\tcase $atomic_bit_size in\n\t    32) gcc_atomic_type=\"$gcc_atomic_type32\";;\n\t    64) gcc_atomic_type=\"$gcc_atomic_type64\";;\n\t    128) gcc_atomic_type=\"$gcc_atomic_type128\";;\n\tesac\n\tgcc_atomic_lockfree=\"int x[[(2*__atomic_always_lock_free(sizeof($gcc_atomic_type), 0))-1]]\"\n\tcase $1 in\n\t    __sync_add_and_fetch | __sync_fetch_and_and | __sync_fetch_and_or)\n\t\tatomic_call=\"volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0);\"\n\t\t;;\n\t    __sync_val_compare_and_swap)\n\t\tatomic_call=\"volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0, ($gcc_atomic_type) 0);\"\n\t\t;;\n\t    __atomic_store_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELAXED); $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELEASE);\"\n\t\t;;\n\t    __atomic_load_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, __ATOMIC_RELAXED); res = $1(&var, __ATOMIC_ACQUIRE);\"\n\t\t;;\n\t    __atomic_add_fetch| __atomic_fetch_and | __atomic_fetch_or)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELAXED); res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_ACQUIRE); res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELEASE);\"\n\t\t;;\n\t    __atomic_compare_exchange_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type val; int res = $1(&var, &val, ($gcc_atomic_type) 0, 0, __ATOMIC_RELAXED, __ATOMIC_RELAXED); res = $1(&var, &val, ($gcc_atomic_type) 0, 0, __ATOMIC_ACQUIRE, __ATOMIC_ACQUIRE);\"\n\t\t;;\n\t    *)\n\t\tAC_MSG_ERROR([Internal error: missing implementation for $1])\n\t\t;;\n\tesac\n\teval atomic${atomic_bit_size}_call=\\\"$atomic_call\\\"\n    done\n    \n    AC_CACHE_CHECK([for 32-bit $1()], ethr_cv_32bit_$1,\n\t\t   [\n\t\t       ethr_cv_32bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic32_call], [ethr_cv_32bit_$1=yes])\n\t\t   ])\n    AC_CACHE_CHECK([for 64-bit $1()], ethr_cv_64bit_$1,\n\t\t   [\n\t\t       ethr_cv_64bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic64_call], [ethr_cv_64bit_$1=yes])\n\t\t   ])\n    AC_CACHE_CHECK([for 128-bit $1()], ethr_cv_128bit_$1,\n\t\t   [\n\t\t       ethr_cv_128bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic128_call], [ethr_cv_128bit_$1=yes])\n\t\t   ])\n\n\tcase $ethr_cv_128bit_$1-$ethr_cv_64bit_$1-$ethr_cv_32bit_$1 in\n\t    no-no-no)\n\t\thave_atomic_ops=0;;\n\t    no-no-yes)\n\t\thave_atomic_ops=4;;\n\t    no-yes-no)\n\t\thave_atomic_ops=8;;\n\t    no-yes-yes)\n\t\thave_atomic_ops=12;;\n\t    yes-no-no)\n\t\thave_atomic_ops=16;;\n\t    yes-no-yes)\n\t\thave_atomic_ops=20;;\n\t    yes-yes-no)\n\t\thave_atomic_ops=24;;\n\t    yes-yes-yes)\n\t\thave_atomic_ops=28;;\n\tesac\n\tAC_DEFINE_UNQUOTED([ETHR_HAVE_$1], [$have_atomic_ops], [Define as a bitmask corresponding to the word sizes that $1() can handle on your system])\n])\n\nAC_DEFUN(ETHR_CHK_IF_NOOP,\n[\n   ethr_test_filename=\"chk_if_$1$3_noop_config1test.$$\"\n   cat > \"${ethr_test_filename}.c\" <<EOF\nint\nmy_test(void)\n{\n    $1$2;\n    return 0;\n}\nEOF\n   $CC -O3 $ETHR_DEFS -c \"${ethr_test_filename}.c\" -o \"${ethr_test_filename}1.o\"\n   cat > \"${ethr_test_filename}.c\" <<EOF\nint\nmy_test(void)\n{\n    ;\n    return 0;\n}\nEOF\n   $CC -O3 $ETHR_DEFS -c \"${ethr_test_filename}.c\" -o \"${ethr_test_filename}2.o\"\n   if diff \"${ethr_test_filename}1.o\" \"${ethr_test_filename}2.o\" >/dev/null 2>&1; then\n      ethr_$1$3_noop=yes\n   else\n      ethr_$1$3_noop=no\n   fi\n   rm -f \"${ethr_test_filename}.c\" \"${ethr_test_filename}1.o\"  \"${ethr_test_filename}2.o\" \n])\n\nAC_DEFUN(ETHR_CHK_GCC_ATOMIC_OPS,\n[\n    AC_CHECK_SIZEOF(short)\n    AC_CHECK_SIZEOF(int)\n    AC_CHECK_SIZEOF(long)\n    AC_CHECK_SIZEOF(long long)\n    AC_CHECK_SIZEOF(__int128_t)\n\n    if test \"$ac_cv_sizeof_short\" = \"4\"; then\n\tgcc_atomic_type32=\"short\"\n    elif test \"$ac_cv_sizeof_int\" = \"4\"; then\n\tgcc_atomic_type32=\"int\"\n    elif test \"$ac_cv_sizeof_long\" = \"4\"; then\n\tgcc_atomic_type32=\"long\"\n    else\n\tAC_MSG_ERROR([No 32-bit type found])\n    fi\n\n    if test \"$ac_cv_sizeof_int\" = \"8\"; then\n\tgcc_atomic_type64=\"int\"\n    elif test \"$ac_cv_sizeof_long\" = \"8\"; then\n\tgcc_atomic_type64=\"long\"\n    elif test \"$ac_cv_sizeof_long_long\" = \"8\"; then\n\tgcc_atomic_type64=\"long long\"\n    else\n\tAC_MSG_ERROR([No 64-bit type found])\n    fi\n\n    if test \"$ac_cv_sizeof___int128_t\" = \"16\"; then\n\tgcc_atomic_type128=\"__int128_t\"\n    else\n\tgcc_atomic_type128=\"#error \"\t\n    fi\n    AC_CACHE_CHECK([for a working __sync_synchronize()], ethr_cv___sync_synchronize,\n\t\t   [\n\t\t       ethr_cv___sync_synchronize=no\n\t\t       AC_TRY_LINK([],\n\t\t\t\t   [ __sync_synchronize(); ],\n\t\t\t\t   [ethr_cv___sync_synchronize=yes])\n\t\t       if test $ethr_cv___sync_synchronize = yes; then\n\t\t\t   #\n\t\t\t   # Old gcc versions on at least x86 have a buggy\n\t\t\t   # __sync_synchronize() which does not emit a\n\t\t\t   # memory barrier. We try to detect this by\n\t\t\t   # compiling to assembly with and without\n\t\t\t   # __sync_synchronize() and compare the results.\n\t\t\t   #\n\t\t\t   ETHR_CHK_IF_NOOP(__sync_synchronize, [()], [])\n\t\t\t   if test $ethr___sync_synchronize_noop = yes; then\n\t\t\t      # Got a buggy implementation of\n\t\t\t      # __sync_synchronize...\n\t\t\t      ethr_cv___sync_synchronize=\"no; buggy implementation\"\n\t\t\t   fi\n\t\t       fi\n\t\t   ])\n\n    if test \"$ethr_cv___sync_synchronize\" = \"yes\"; then\n\thave_sync_synchronize_value=\"~0\"\n    else\n\thave_sync_synchronize_value=\"0\"\n    fi\n    AC_DEFINE_UNQUOTED([ETHR_HAVE___sync_synchronize], [$have_sync_synchronize_value], [Define as a bitmask corresponding to the word sizes that __sync_synchronize() can handle on your system])\n\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_add_and_fetch)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_fetch_and_and)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_fetch_and_or)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_val_compare_and_swap)\n\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_store_n)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_load_n)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_add_fetch)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_fetch_and)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_fetch_or)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_compare_exchange_n)\n\n    ethr_have_gcc_native_atomics=no\n    ethr_arm_dbm_instr_val=0\n    case \"$GCC-$host_cpu\" in\n\tyes-arm*)\n\t    AC_CACHE_CHECK([for ARM DMB instruction], ethr_cv_arm_dbm_instr,\n\t\t\t   [\n\t\t\t\tethr_cv_arm_dbm_instr=no\n\t\t\t\tAC_TRY_LINK([],\n\t\t\t\t\t    [\n\t\t\t\t\t\t__asm__ __volatile__(\"dmb sy\" : : : \"memory\");\n\t\t\t\t\t\t__asm__ __volatile__(\"dmb st\" : : : \"memory\");\n\t\t\t\t\t    ],\n\t\t\t\t\t    [ethr_cv_arm_dbm_instr=yes])\n\t\t\t   ])\n\t    if test $ethr_cv_arm_dbm_instr = yes; then\n\t\tethr_arm_dbm_instr_val=1\n\t\ttest $ethr_cv_64bit___atomic_compare_exchange_n = yes &&\n\t\t    ethr_have_gcc_native_atomics=yes\n\t    fi;;\n\t*)\n\t    ;;\n    esac\n    AC_DEFINE_UNQUOTED([ETHR_HAVE_GCC_ASM_ARM_DMB_INSTRUCTION], [$ethr_arm_dbm_instr_val], [Define as a boolean indicating whether you have a gcc compatible compiler capable of generating the ARM DMB instruction, and are compiling for an ARM processor with ARM DMB instruction support, or not])\n    test $ethr_cv_32bit___sync_val_compare_and_swap = yes &&\n    \tethr_have_gcc_native_atomics=yes\n    test $ethr_cv_64bit___sync_val_compare_and_swap = yes &&\n    \tethr_have_gcc_native_atomics=yes\n    if test \"$ethr_cv___sync_synchronize\" = \"yes\"; then\n    \ttest $ethr_cv_64bit___atomic_compare_exchange_n = yes &&\n    \t    ethr_have_gcc_native_atomics=yes\n    \ttest $ethr_cv_32bit___atomic_compare_exchange_n = yes &&\n    \t    ethr_have_gcc_native_atomics=yes\n    fi\n    ethr_have_gcc_atomic_builtins=0\n    if test $ethr_have_gcc_native_atomics = yes; then\n       ethr_native_atomic_implementation=gcc_sync\n       test $ethr_cv_32bit___atomic_compare_exchange_n = yes && ethr_have_gcc_atomic_builtins=1\n       test $ethr_cv_64bit___atomic_compare_exchange_n = yes && ethr_have_gcc_atomic_builtins=1\n       test $ethr_have_gcc_atomic_builtins = 1 && ethr_native_atomic_implementation=gcc_atomic_sync\n    fi\n    AC_DEFINE_UNQUOTED([ETHR_HAVE_GCC___ATOMIC_BUILTINS], [$ethr_have_gcc_atomic_builtins], [Define as a boolean indicating whether you have a gcc __atomic builtins or not])\n    test $ethr_have_gcc_native_atomics = yes && ethr_have_native_atomics=yes\n])\n\nAC_DEFUN(ETHR_CHK_INTERLOCKED,\n[\n    ilckd=\"$1\"\n    AC_MSG_CHECKING([for ${ilckd}()])\n    case \"$2\" in\n\t\"1\") ilckd_call=\"${ilckd}(var);\";;\n\t\"2\") ilckd_call=\"${ilckd}(var, ($3) 0);\";;\n\t\"3\") ilckd_call=\"${ilckd}(var, ($3) 0, ($3) 0);\";;\n\t\"4\") ilckd_call=\"${ilckd}(var, ($3) 0, ($3) 0, arr);\";;\n    esac\n    have_interlocked_op=no\n    AC_TRY_LINK(\n\t[\n\t#define WIN32_LEAN_AND_MEAN\n\t#include <windows.h>\n\t#include <intrin.h>\n\t],\n\t[\n\t    volatile $3 *var;\n\t    volatile $3 arr[2];\n\n\t    $ilckd_call\n\t    return 0;\n\t],\n\t[have_interlocked_op=yes])\n    test $have_interlocked_op = yes && $4\n    AC_MSG_RESULT([$have_interlocked_op])\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl ERL_FIND_ETHR_LIB\ndnl\ndnl NOTE! This macro may be changed at any time! Should *only* be used by\ndnl       ERTS!\ndnl\ndnl Find a thread library to use. Sets ETHR_LIBS to libraries to link\ndnl with, ETHR_X_LIBS to extra libraries to link with (same as ETHR_LIBS\ndnl except that the ethread lib itself is not included), ETHR_DEFS to\ndnl defines to compile with, ETHR_THR_LIB_BASE to the name of the\ndnl thread library which the ethread library is based on, and ETHR_LIB_NAME\ndnl to the name of the library where the ethread implementation is located.\ndnl  ERL_FIND_ETHR_LIB currently searches for 'pthreads', and\ndnl 'win32_threads'. If no thread library was found ETHR_LIBS, ETHR_X_LIBS,\ndnl ETHR_DEFS, ETHR_THR_LIB_BASE, and ETHR_LIB_NAME are all set to the\ndnl empty string.\ndnl\n\nAC_DEFUN(ERL_FIND_ETHR_LIB,\n[\n\nAC_ARG_ENABLE(native-ethr-impls,\n\t      AS_HELP_STRING([--disable-native-ethr-impls],\n                             [disable native ethread implementations]),\n[ case \"$enableval\" in\n    no) disable_native_ethr_impls=yes ;;\n    *)  disable_native_ethr_impls=no ;;\n  esac ], disable_native_ethr_impls=no)\n\ntest \"X$disable_native_ethr_impls\" = \"Xyes\" &&\n  AC_DEFINE(ETHR_DISABLE_NATIVE_IMPLS, 1, [Define if you want to disable native ethread implementations])\n\nAC_ARG_ENABLE(x86-out-of-order,\n\t      AS_HELP_STRING([--enable-x86-out-of-order],\n                             [enable x86/x84_64 out of order support (default disabled)]))\n\nAC_ARG_ENABLE(prefer-gcc-native-ethr-impls,\n\t      AS_HELP_STRING([--enable-prefer-gcc-native-ethr-impls],\n\t\t\t     [prefer gcc native ethread implementations]),\n[ case \"$enableval\" in\n    yes) enable_prefer_gcc_native_ethr_impls=yes ;;\n    *)  enable_prefer_gcc_native_ethr_impls=no ;;\n  esac ], enable_prefer_gcc_native_ethr_impls=no)\n\ntest $enable_prefer_gcc_native_ethr_impls = yes &&\n  AC_DEFINE(ETHR_PREFER_GCC_NATIVE_IMPLS, 1, [Define if you prefer gcc native ethread implementations])\n\nAC_ARG_ENABLE(trust-gcc-atomic-builtins-memory-barriers,\n\t      AS_HELP_STRING([--enable-trust-gcc-atomic-builtins-memory-barriers],\n\t\t\t     [trust gcc atomic builtins memory barriers]),\n[ case \"$enableval\" in\n    yes) trust_gcc_atomic_builtins_mbs=1 ;;\n    *) trust_gcc_atomic_builtins_mbs=0 ;;\n  esac ], trust_gcc_atomic_builtins_mbs=0)\n\nAC_DEFINE_UNQUOTED(ETHR_TRUST_GCC_ATOMIC_BUILTINS_MEMORY_BARRIERS, [$trust_gcc_atomic_builtins_mbs], [Define as a boolean indicating whether you trust gcc's __atomic_* builtins memory barrier implementations, or not])\n\nAC_ARG_WITH(libatomic_ops,\n\t    AS_HELP_STRING([--with-libatomic_ops=PATH],\n\t\t\t   [specify and prefer usage of libatomic_ops in the ethread library]))\n\nAC_ARG_WITH(with_sparc_memory_order,\n\t    AS_HELP_STRING([--with-sparc-memory-order=TSO|PSO|RMO],\n\t\t\t   [specify sparc memory order (defaults to RMO)]))\n\nLM_CHECK_THR_LIB\nERL_INTERNAL_LIBS\n\nERL_MONOTONIC_CLOCK(try_find_pthread_compatible, CLOCK_HIGHRES CLOCK_MONOTONIC, no)\n\ncase $erl_monotonic_clock_func in\n  clock_gettime)\n    AC_DEFINE(ETHR_HAVE_CLOCK_GETTIME_MONOTONIC, [1], [Define if you have a clock_gettime() with a monotonic clock])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(ETHR_HAVE_MACH_CLOCK_GET_TIME, [1], [Define if you have a mach clock_get_time() with a monotonic clock])\n    ;;\n  gethrtime)\n    AC_DEFINE(ETHR_HAVE_GETHRTIME, [1], [Define if you have a monotonic gethrtime()])\n    ;;\n  *)\n    ;;\nesac\n\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(ETHR_MONOTONIC_CLOCK_ID, [$erl_monotonic_clock_id], [Define to the monotonic clock id to use])\nfi\n\nethr_native_atomic_implementation=none\nethr_have_native_atomics=no\nethr_have_native_spinlock=no\nETHR_THR_LIB_BASE=\"$THR_LIB_NAME\"\nETHR_THR_LIB_BASE_TYPE=\"$THR_LIB_TYPE\"\nETHR_DEFS=\"$THR_DEFS\"\nETHR_X_LIBS=\"$THR_LIBS $ERTS_INTERNAL_X_LIBS $erl_monotonic_clock_lib\"\nETHR_LIBS=\nETHR_LIB_NAME=\n\nethr_modified_default_stack_size=\n\nAC_ARG_WITH(threadnames,\nAS_HELP_STRING([--with-threadnames], [use pthread_setname to set the thread names (default)])\nAS_HELP_STRING([--without-threadnames],\n               [do not set any thread names]),\n[],\n[with_threadnames=yes])\n\ndnl Name of lib where ethread implementation is located\nethr_lib_name=ethread\n\ncase \"$THR_LIB_NAME\" in\n\n    win32_threads)\n\tETHR_THR_LIB_BASE_DIR=win\n\t# * _WIN32_WINNT >= 0x0400 is needed for\n\t#   TryEnterCriticalSection\n\t# * _WIN32_WINNT >= 0x0403 is needed for\n\t#   InitializeCriticalSectionAndSpinCount\n\t# The ethread lib will refuse to build if _WIN32_WINNT < 0x0403.\n\t#\n\t# -D_WIN32_WINNT should have been defined in $CPPFLAGS; fetch it\n\t# and save it in ETHR_DEFS.\n\tfound_win32_winnt=no\n\tfor cppflag in $CPPFLAGS; do\n\t    case $cppflag in\n\t\t-DWINVER*)\n\t\t    ETHR_DEFS=\"$ETHR_DEFS $cppflag\"\n\t\t    ;;\n\t\t-D_WIN32_WINNT*)\n\t\t    ETHR_DEFS=\"$ETHR_DEFS $cppflag\"\n\t\t    found_win32_winnt=yes\n\t\t    ;;\n\t\t*)\n\t\t    ;;\n\t    esac\n        done\n        if test $found_win32_winnt = no; then\n\t    AC_MSG_ERROR([-D_WIN32_WINNT missing in CPPFLAGS])\n        fi\n\n\tAC_DEFINE(ETHR_WIN32_THREADS, 1, [Define if you have win32 threads])\n\n\tif test \"X$disable_native_ethr_impls\" = \"Xyes\"; then\n\t    have_interlocked_op=no\n\t    ethr_have_native_atomics=no\n\telse\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT, 1, [Define if you have _InterlockedDecrement()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement_rel], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT_REL, 1, [Define if you have _InterlockedDecrement_rel()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT, 1, [Define if you have _InterlockedIncrement()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement_acq], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT_ACQ, 1, [Define if you have _InterlockedIncrement_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD, 1, [Define if you have _InterlockedExchangeAdd()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd_acq], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD_ACQ, 1, [Define if you have _InterlockedExchangeAdd_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedAnd], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDAND, 1, [Define if you have _InterlockedAnd()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedOr], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDOR, 1, [Define if you have _InterlockedOr()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchange], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGE, 1, [Define if you have _InterlockedExchange()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE, 1, [Define if you have _InterlockedCompareExchange()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange_acq], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE_ACQ, 1, [Define if you have _InterlockedCompareExchange_acq()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange_rel], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE_REL, 1, [Define if you have _InterlockedCompareExchange_rel()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement64], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT64, 1, [Define if you have _InterlockedDecrement64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement64_rel], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT64_REL, 1, [Define if you have _InterlockedDecrement64_rel()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement64], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT64, 1, [Define if you have _InterlockedIncrement64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement64_acq], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT64_ACQ, 1, [Define if you have _InterlockedIncrement64_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD64, 1, [Define if you have _InterlockedExchangeAdd64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd64_acq], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD64_ACQ, 1, [Define if you have _InterlockedExchangeAdd64_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedAnd64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDAND64, 1, [Define if you have _InterlockedAnd64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedOr64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDOR64, 1, [Define if you have _InterlockedOr64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchange64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGE64, 1, [Define if you have _InterlockedExchange64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64, 1, [Define if you have _InterlockedCompareExchange64()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64_acq], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64_ACQ, 1, [Define if you have _InterlockedCompareExchange64_acq()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64_rel], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64_REL, 1, [Define if you have _InterlockedCompareExchange64_rel()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange128], [4], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE128, 1, [Define if you have _InterlockedCompareExchange128()]))\n\tfi\n\tif test \"$ethr_have_native_atomics\" = \"yes\"; then\n\t   ethr_native_atomic_implementation=windows\n\t   ethr_have_native_spinlock=yes\n\tfi\n\t;;\n\n    pthread)\n\tETHR_THR_LIB_BASE_DIR=pthread\n\tAC_DEFINE(ETHR_PTHREADS, 1, [Define if you have pthreads])\n\tcase $host_os in\n\t    openbsd*)\n\t\t# The default stack size is insufficient for our needs\n\t\t# on OpenBSD. We increase it to 256 kilo words.\n\t\tethr_modified_default_stack_size=256;;\n\t    linux*)\n\t\tETHR_DEFS=\"$ETHR_DEFS -D_GNU_SOURCE\"\n\n\t\tif test\tX$cross_compiling = Xyes; then\n\t\t    case X$erl_xcomp_linux_usable_sigusrx in\n\t\t\tX) usable_sigusrx=cross;;\n\t\t\tXyes|Xno) usable_sigusrx=$erl_xcomp_linux_usable_sigusrx;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_usable_sigusrx value: $erl_xcomp_linux_usable_sigusrx]);;\n\t\t    esac\n\t\t    case X$erl_xcomp_linux_usable_sigaltstack in\n\t\t\tX) usable_sigaltstack=cross;;\n\t\t\tXyes|Xno) usable_sigaltstack=$erl_xcomp_linux_usable_sigaltstack;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_usable_sigaltstack value: $erl_xcomp_linux_usable_sigaltstack]);;\n\t\t    esac\n\t\telse\n\t\t    # FIXME: Test for actual problems instead of kernel versions\n\t\t    linux_kernel_vsn_=`uname -r`\n\t\t    case $linux_kernel_vsn_ in\n\t\t\t[[0-1]].*|2.[[0-1]]|2.[[0-1]].*)\n\t\t\t    usable_sigusrx=no\n\t\t\t    usable_sigaltstack=no;;\n\t\t\t2.[[2-3]]|2.[[2-3]].*)\n\t\t\t    usable_sigusrx=yes\n\t\t\t    usable_sigaltstack=no;;\n\t\t    \t*)\n\t\t\t    usable_sigusrx=yes\n\t\t\t    usable_sigaltstack=yes;;\n\t\t    esac\n\t\tfi\n\n\t\tAC_MSG_CHECKING(if SIGUSR1 and SIGUSR2 can be used)\n\t\tAC_MSG_RESULT($usable_sigusrx)\n\t\tif test $usable_sigusrx = cross; then\n\t\t    usable_sigusrx=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $usable_sigusrx = no; then\n\t\t    ETHR_DEFS=\"$ETHR_DEFS -DETHR_UNUSABLE_SIGUSRX\"\n\t\tfi\n\n\t\tAC_MSG_CHECKING(if sigaltstack can be used)\n\t\tAC_MSG_RESULT($usable_sigaltstack)\n\t\tif test $usable_sigaltstack = cross; then\n\t\t    usable_sigaltstack=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $usable_sigaltstack = no; then\n\t\t    ETHR_DEFS=\"$ETHR_DEFS -DETHR_UNUSABLE_SIGALTSTACK\"\n\t\tfi\n\t\t;;\n\t    *) ;;\n\tesac\n\n\tdnl We sometimes need ETHR_DEFS in order to find certain headers\n\tdnl (at least for pthread.h on osf1).\n\tsaved_cppflags=\"$CPPFLAGS\"\n\tCPPFLAGS=\"$CPPFLAGS $ETHR_DEFS\"\n\n\tdnl We need the thread library in order to find some functions\n\tsaved_libs=\"$LIBS\"\n\tLIBS=\"$LIBS $ETHR_X_LIBS\"\n\n\tdnl\n\tdnl Check for headers\n\tdnl\n\tAC_CHECK_HEADER(pthread.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_H, 1, \\\n[Define if you have the <pthread.h> header file.]))\n\n\tdnl Some Linuxes have <pthread/mit/pthread.h> instead of <pthread.h>\n\tAC_CHECK_HEADER(pthread/mit/pthread.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_MIT_PTHREAD_H, 1, \\\n[Define if the pthread.h header file is in pthread/mit directory.]))\n\n\tif test $NEED_NPTL_PTHREAD_H = yes; then\n\t    AC_DEFINE(ETHR_NEED_NPTL_PTHREAD_H, 1, \\\n[Define if you need the <nptl/pthread.h> header file.])\n\tfi\n\n\tAC_CHECK_HEADER(sched.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_SCHED_H, 1, \\\n[Define if you have the <sched.h> header file.]))\n\n\tAC_CHECK_HEADER(sys/time.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_SYS_TIME_H, 1, \\\n[Define if you have the <sys/time.h> header file.]))\n\n\tAC_TRY_COMPILE([#include <time.h>\n\t\t\t#include <sys/time.h>], \n\t\t\t[struct timeval *tv; return 0;],\n\t\t\tAC_DEFINE(ETHR_TIME_WITH_SYS_TIME, 1, \\\n[Define if you can safely include both <sys/time.h> and <time.h>.]))\n\n\tAC_MSG_CHECKING([for usable PTHREAD_STACK_MIN])\n\tpthread_stack_min=no\n\tAC_TRY_COMPILE([\n#include <limits.h>\n#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n#include <nptl/pthread.h>\n#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n#include <pthread/mit/pthread.h>\n#elif defined(ETHR_HAVE_PTHREAD_H)\n#include <pthread.h>\n#endif\n\t\t\t], \n\t\t\t[return PTHREAD_STACK_MIN;],\n\t\t\t[pthread_stack_min=yes])\n\n\tAC_MSG_RESULT([$pthread_stack_min])\n\ttest $pthread_stack_min != yes || {\n\t     AC_DEFINE(ETHR_HAVE_USABLE_PTHREAD_STACK_MIN, 1, [Define if you can use PTHREAD_STACK_MIN])\n\t}\n\n\tdnl\n\tdnl Check for functions\n\tdnl\n\tAC_CHECK_FUNC(pthread_spin_lock, \\\n\t\t\t[ethr_have_native_spinlock=yes \\\n\t\t\t AC_DEFINE(ETHR_HAVE_PTHREAD_SPIN_LOCK, 1, \\\n[Define if you have the pthread_spin_lock function.])])\n\n\thave_sched_yield=no\n\thave_librt_sched_yield=no\n\tAC_CHECK_FUNC(sched_yield, [have_sched_yield=yes])\n\tif test $have_sched_yield = no; then\n\t    AC_CHECK_LIB(rt, sched_yield,\n\t\t\t [have_librt_sched_yield=yes\n\t\t\t  ETHR_X_LIBS=\"$ETHR_X_LIBS -lrt\"])\n\tfi\n\tif test $have_sched_yield = yes || test $have_librt_sched_yield = yes; then\n\t    AC_DEFINE(ETHR_HAVE_SCHED_YIELD, 1, [Define if you have the sched_yield() function.])\n\t    AC_MSG_CHECKING([whether sched_yield() returns an int])\n\t    sched_yield_ret_int=no\n\t    AC_TRY_LINK([\n\t\t\t\t#ifdef ETHR_HAVE_SCHED_H\n\t\t\t\t#include <sched.h>\n\t\t\t\t#endif\n\t\t\t   ],\n\t\t\t   [int sched_yield();],\n\t\t\t   [sched_yield_ret_int=yes])\n\t    AC_MSG_RESULT([$sched_yield_ret_int])\n\t    if test $sched_yield_ret_int = yes; then\n\t\tAC_DEFINE(ETHR_SCHED_YIELD_RET_INT, 1, [Define if sched_yield() returns an int.])\n\t    fi\n\tfi\n\n\thave_pthread_yield=no\n\tAC_CHECK_FUNC(pthread_yield, [have_pthread_yield=yes])\n\tif test $have_pthread_yield = yes; then\n\t    AC_DEFINE(ETHR_HAVE_PTHREAD_YIELD, 1, [Define if you have the pthread_yield() function.])\n\t    AC_MSG_CHECKING([whether pthread_yield() returns an int])\n\t    pthread_yield_ret_int=no\n\t    AC_TRY_LINK([\n\t\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t\t#include <nptl/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t\t#include <pthread/mit/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t\t#include <pthread.h>\n\t\t\t\t#endif\n\t\t\t   ],\n\t\t\t   [int pthread_yield();],\n\t\t\t   [pthread_yield_ret_int=yes])\n\t    AC_MSG_RESULT([$pthread_yield_ret_int])\n\t    if test $pthread_yield_ret_int = yes; then\n\t\tAC_DEFINE(ETHR_PTHREAD_YIELD_RET_INT, 1, [Define if pthread_yield() returns an int.])\n\t    fi\n\tfi\n\n\thave_pthread_rwlock_init=no\n\tAC_CHECK_FUNC(pthread_rwlock_init, [have_pthread_rwlock_init=yes])\n\tif test $have_pthread_rwlock_init = yes; then\n\n\t    ethr_have_pthread_rwlockattr_setkind_np=no\n\t    AC_CHECK_FUNC(pthread_rwlockattr_setkind_np,\n\t\t\t  [ethr_have_pthread_rwlockattr_setkind_np=yes])\n\n\t    if test $ethr_have_pthread_rwlockattr_setkind_np = yes; then\n\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_RWLOCKATTR_SETKIND_NP, 1, \\\n[Define if you have the pthread_rwlockattr_setkind_np() function.])\n\n\t\tAC_MSG_CHECKING([for PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP])\n\t\tethr_pthread_rwlock_writer_nonrecursive_initializer_np=no\n\t\tAC_TRY_LINK([\n\t\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t\t#include <nptl/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t\t#include <pthread/mit/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t\t#include <pthread.h>\n\t\t\t\t#endif\n\t\t\t    ],\n\t\t\t    [\n\t\t\t\tpthread_rwlockattr_t *attr;\n\t\t\t\treturn pthread_rwlockattr_setkind_np(attr,\n\t\t\t\t    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n\t\t\t    ],\n\t\t\t    [ethr_pthread_rwlock_writer_nonrecursive_initializer_np=yes])\n\t\tAC_MSG_RESULT([$ethr_pthread_rwlock_writer_nonrecursive_initializer_np])\n\t\tif test $ethr_pthread_rwlock_writer_nonrecursive_initializer_np = yes; then\n\t\t    AC_DEFINE(ETHR_HAVE_PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, 1, \\\n[Define if you have the PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP rwlock attribute.])\n\t\tfi\n\t    fi\n\tfi\n\n\tif test \"$force_pthread_rwlocks\" = \"yes\"; then\n\n\t    AC_DEFINE(ETHR_FORCE_PTHREAD_RWLOCK, 1, \\\n[Define if you want to force usage of pthread rwlocks])\n\n\t    if test $have_pthread_rwlock_init = yes; then\n\t\tAC_MSG_WARN([Forced usage of pthread rwlocks. Note that this implementation may suffer from starvation issues.])\n\t    else\n\t\tAC_MSG_ERROR([User forced usage of pthread rwlock, but no such implementation was found])\n\t    fi\n\tfi\n\n\tAC_CHECK_FUNC(pthread_attr_setguardsize, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_ATTR_SETGUARDSIZE, 1, \\\n[Define if you have the pthread_attr_setguardsize function.]))\n\n\tif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n\t  AC_MSG_CHECKING(whether pthread_cond_timedwait() can use the monotonic clock $erl_monotonic_clock_id for timeout)\n\t  pthread_cond_timedwait_monotonic=no\n\t  AC_TRY_LINK([\n\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t#  include <nptl/pthread.h>\n\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t#  include <pthread/mit/pthread.h>\n\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t#  include <pthread.h>\n\t\t\t#endif\n\t\t\t#ifdef ETHR_TIME_WITH_SYS_TIME\n\t\t\t#  include <time.h>\n\t\t\t#  include <sys/time.h>\n\t\t\t#else\n\t\t\t#  ifdef ETHR_HAVE_SYS_TIME_H\n\t\t\t#    include <sys/time.h>\n\t\t\t#  else\n\t\t\t#    include <time.h>\n\t\t\t#  endif\n\t\t\t#endif\n\t\t\t#if defined(ETHR_HAVE_MACH_CLOCK_GET_TIME)\n\t\t\t#  include <mach/clock.h>\n\t\t\t#  include <mach/mach.h>\n\t\t\t#endif\n\t\t\t], \n\t\t\t[\n\t\t\tint res;\n\t\t\tpthread_condattr_t attr;\n\t\t\tpthread_cond_t cond;\n\t\t\tstruct timespec cond_timeout;\n\t\t\tpthread_mutex_t mutex;\n\t\t\tres = pthread_condattr_init(&attr);\n\t\t\tres = pthread_condattr_setclock(&attr, ETHR_MONOTONIC_CLOCK_ID);\n\t\t\tres = pthread_cond_init(&cond, &attr);\n\t\t\tres = pthread_cond_timedwait(&cond, &mutex, &cond_timeout);\n\t\t\t],\n\t\t\t[pthread_cond_timedwait_monotonic=yes])\n\t  AC_MSG_RESULT([$pthread_cond_timedwait_monotonic])\n\t  if test $pthread_cond_timedwait_monotonic = yes; then\n\t    AC_DEFINE(ETHR_HAVE_PTHREAD_COND_TIMEDWAIT_MONOTONIC, [1], [Define if pthread_cond_timedwait() can be used with a monotonic clock])\n\t  fi\n\tfi\n\n\tlinux_futex=no\n\tAC_MSG_CHECKING([for Linux futexes])\n\tAC_TRY_LINK([\n\t\t\t#include <sys/syscall.h>\n\t\t\t#include <unistd.h>\n\t\t\t#include <linux/futex.h>\n\t\t\t#include <sys/time.h>\n\t\t    ],\n\t\t    [\n\t\t\tint i = 1;\n\t\t\tsyscall(__NR_futex, (void *) &i, FUTEX_WAKE, 1,\n\t\t\t\t(void*)0,(void*)0, 0);\n\t\t\tsyscall(__NR_futex, (void *) &i, FUTEX_WAIT, 0,\n\t\t\t\t(void*)0,(void*)0, 0);\n\t\t\treturn 0;\n\t\t    ],\n\t\t    linux_futex=yes)\n\tAC_MSG_RESULT([$linux_futex])\n\ttest $linux_futex = yes && AC_DEFINE(ETHR_HAVE_LINUX_FUTEX, 1, [Define if you have a linux futex implementation.])\n\n\tpthread_setname=no\n\tAC_MSG_CHECKING([for pthread_setname_np])\n\told_CFLAGS=$CFLAGS\n\tCFLAGS=\"$CFLAGS -Werror\"\n\tAC_TRY_LINK([#define __USE_GNU\n                     #include <pthread.h>],\n                    [pthread_setname_np(pthread_self(), \"name\");],\n                    pthread_setname=linux)\n\tAC_TRY_LINK([#define __USE_GNU\n                     #include <pthread.h>],\n                    [pthread_set_name_np(pthread_self(), \"name\");],\n                    pthread_setname=bsd)\n\tAC_TRY_LINK([#define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [pthread_setname_np(\"name\");],\n                    pthread_setname=darwin)\n        AC_MSG_RESULT([$pthread_setname])\n        case $with_threadnames-$pthread_setname in\n             yes-linux) AC_DEFINE(ETHR_HAVE_PTHREAD_SETNAME_NP_2, 1,\n                          [Define if you have linux style pthread_setname_np]);;\n             yes-bsd) AC_DEFINE(ETHR_HAVE_PTHREAD_SET_NAME_NP_2, 1,\n                          [Define if you have bsd style pthread_set_name_np]);;\n             yes-darwin) AC_DEFINE(ETHR_HAVE_PTHREAD_SETNAME_NP_1, 1,\n                          [Define if you have darwin style pthread_setname_np]);;\n             *) ;;\n\tesac\n\n\tpthread_getname=no\n\tAC_MSG_CHECKING([for pthread_getname_np])\n\tAC_TRY_LINK([#define __USE_GNU\n                     #define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [char buff[256]; pthread_getname_np(pthread_self(), buff, 256);],\n                    pthread_getname=linux)\n\tAC_TRY_LINK([#define __USE_GNU\n                     #define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [char buff[256]; pthread_getname_np(pthread_self(), buff);],\n                    pthread_getname=ibm)\n        AC_MSG_RESULT([$pthread_getname])\n        case $pthread_getname in\n             linux) AC_DEFINE(ETHR_HAVE_PTHREAD_GETNAME_NP_3, 1,\n                          [Define if you have linux style pthread_getname_np]);;\n             ibm) AC_DEFINE(ETHR_HAVE_PTHREAD_GETNAME_NP_2, 1,\n                          [Define if you have ibm style pthread_getname_np]);;\n             *) ;;\n\tesac\n\tCFLAGS=$old_CFLAGS\n\n\tif test \"X$disable_native_ethr_impls\" = \"Xyes\"; then\n\t    ethr_have_native_atomics=no\n\telse\n\n\t    ETHR_CHK_GCC_ATOMIC_OPS([])\n\n\t    AC_MSG_CHECKING([for a usable libatomic_ops implementation])\n\t    case \"x$with_libatomic_ops\" in\n\t        xno | xyes | x)\n\t    \t    libatomic_ops_include=\n\t    \t    ;;\n\t        *)\n\t    \t    if test -d \"${with_libatomic_ops}/include\"; then\n\t    \t        libatomic_ops_include=\"-I$with_libatomic_ops/include\"\n\t    \t        CPPFLAGS=\"$CPPFLAGS $libatomic_ops_include\"\n\t    \t    else\n\t    \t        AC_MSG_ERROR([libatomic_ops include directory $with_libatomic_ops/include not found])\n\t    \t    fi;;\n\t    esac\n\t    ethr_have_libatomic_ops=no\n\t    AC_TRY_LINK([#include \"atomic_ops.h\"],\n\t    \t        [\n\t    \t    \t    volatile AO_t x;\n\t    \t    \t    AO_t y;\n\t    \t    \t    int z;\n\n\t    \t    \t    AO_nop_full();\n#if defined(AO_HAVE_store)\n\t    \t    \t    AO_store(&x, (AO_t) 0);\n#elif defined(AO_HAVE_store_release)\n\t    \t    \t    AO_store_release(&x, (AO_t) 0);\n#else\n#error No store\n#endif\n#if defined(AO_HAVE_load)\n\t    \t    \t    z = AO_load(&x);\n#elif defined(AO_HAVE_load_acquire)\n\t    \t    \t    z = AO_load_acquire(&x);\n#else\n#error No load\n#endif\n#if defined(AO_HAVE_compare_and_swap_full)\n\t    \t    \t    z = AO_compare_and_swap_full(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap_release)\n\t    \t    \t    z = AO_compare_and_swap_release(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap_acquire)\n\t    \t    \t    z = AO_compare_and_swap_acquire(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap)\n\t    \t    \t    z = AO_compare_and_swap(&x, (AO_t) 0, (AO_t) 1);\n#else\n#error No compare_and_swap\n#endif\n\t    \t        ],\n\t    \t        [ethr_have_native_atomics=yes\n\t\t\t ethr_native_atomic_implementation=libatomic_ops\n\t    \t         ethr_have_libatomic_ops=yes])\n\t    AC_MSG_RESULT([$ethr_have_libatomic_ops])\n\t    if test $ethr_have_libatomic_ops = yes; then\n\t        AC_CHECK_SIZEOF(AO_t, ,\n\t    \t    \t        [\n\t    \t    \t    \t    #include <stdio.h>\n\t    \t    \t    \t    #include \"atomic_ops.h\"\n\t    \t    \t        ])\n\t        AC_DEFINE_UNQUOTED(ETHR_SIZEOF_AO_T, $ac_cv_sizeof_AO_t, [Define to the size of AO_t if libatomic_ops is used])\n\n\t        AC_DEFINE(ETHR_HAVE_LIBATOMIC_OPS, 1, [Define if you have libatomic_ops atomic operations])\n\t        if test \"x$with_libatomic_ops\" != \"xno\" && test \"x$with_libatomic_ops\" != \"x\"; then\n\t    \t    AC_DEFINE(ETHR_PREFER_LIBATOMIC_OPS_NATIVE_IMPLS, 1, [Define if you prefer libatomic_ops native ethread implementations])\n\t        fi\n\t        ETHR_DEFS=\"$ETHR_DEFS $libatomic_ops_include\"\n\t    elif test \"x$with_libatomic_ops\" != \"xno\" && test \"x$with_libatomic_ops\" != \"x\"; then\n\t        AC_MSG_ERROR([No usable libatomic_ops implementation found])\n\t    fi\n\n\t    case \"$host_cpu\" in\n\t      sparc | sun4u | sparc64 | sun4v)\n\t    \t    case \"$with_sparc_memory_order\" in\n\t    \t        \"TSO\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_TSO, 1, [Define if only run in Sparc TSO mode]);;\n\t    \t        \"PSO\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_PSO, 1, [Define if only run in Sparc PSO, or TSO mode]);;\n\t    \t        \"RMO\"|\"\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_RMO, 1, [Define if run in Sparc RMO, PSO, or TSO mode]);;\n\t    \t        *)\n\t    \t    \t    AC_MSG_ERROR([Unsupported Sparc memory order: $with_sparc_memory_order]);;\n\t    \t    esac\n\t\t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;; \n\t      i86pc | i*86 | x86_64 | amd64)\n\t    \t    if test \"$enable_x86_out_of_order\" = \"yes\"; then\n\t    \t    \t    AC_DEFINE(ETHR_X86_OUT_OF_ORDER, 1, [Define if x86/x86_64 out of order instructions should be synchronized])\n\t    \t    fi\n\t\t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      macppc | ppc | powerpc | \"Power Macintosh\")\n\t      \t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      tile)\n\t            ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      *)\n\t    \t    ;;\n\t    esac\n\n\tfi\n\n\ttest ethr_have_native_atomics = \"yes\" && ethr_have_native_spinlock=yes\n\n\tdnl Restore LIBS\n\tLIBS=$saved_libs\n\tdnl restore CPPFLAGS\n\tCPPFLAGS=$saved_cppflags\n\n\t;;\n    *)\n\t;;\nesac\n\nAC_MSG_CHECKING([whether default stack size should be modified])\nif test \"x$ethr_modified_default_stack_size\" != \"x\"; then\n\tAC_DEFINE_UNQUOTED(ETHR_MODIFIED_DEFAULT_STACK_SIZE, $ethr_modified_default_stack_size, [Define if you want to modify the default stack size])\n\tAC_MSG_RESULT([yes; to $ethr_modified_default_stack_size kilo words])\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nif test \"x$ETHR_THR_LIB_BASE\" != \"x\"; then\n\tETHR_DEFS=\"-DUSE_THREADS $ETHR_DEFS\"\n\tETHR_LIBS=\"-l$ethr_lib_name -lerts_internal_r $ETHR_X_LIBS\"\n\tETHR_LIB_NAME=$ethr_lib_name\nfi\n\nAC_CHECK_SIZEOF(void *)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_PTR, $ac_cv_sizeof_void_p, [Define to the size of pointers])\n\nAC_CHECK_SIZEOF(int)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_INT, $ac_cv_sizeof_int, [Define to the size of int])\nAC_CHECK_SIZEOF(long)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_LONG, $ac_cv_sizeof_long, [Define to the size of long])\nAC_CHECK_SIZEOF(long long)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_LONG_LONG, $ac_cv_sizeof_long_long, [Define to the size of long long])\nAC_CHECK_SIZEOF(__int64)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF___INT64, $ac_cv_sizeof___int64, [Define to the size of __int64])\nAC_CHECK_SIZEOF(__int128_t)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF___INT128_T, $ac_cv_sizeof___int128_t, [Define to the size of __int128_t])\n\n\ncase X$erl_xcomp_bigendian in\n    X) ;;\n    Xyes|Xno) ac_cv_c_bigendian=$erl_xcomp_bigendian;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_bigendian value: $erl_xcomp_bigendian]);;\nesac\n\nAC_C_BIGENDIAN\n\nif test \"$ac_cv_c_bigendian\" = \"yes\"; then\n    AC_DEFINE(ETHR_BIGENDIAN, 1, [Define if bigendian])\nfi\n\ncase X$erl_xcomp_double_middle_endian in\n    X) ;;\n    Xyes|Xno|Xunknown) ac_cv_c_double_middle_endian=$erl_xcomp_double_middle_endian;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_double_middle_endian value: $erl_xcomp_double_middle_endian]);;\nesac\n\nAC_C_DOUBLE_MIDDLE_ENDIAN\n\nETHR_X86_SSE2_ASM=no\ncase \"$GCC-$ac_cv_sizeof_void_p-$host_cpu\" in\n  yes-4-i86pc | yes-4-i*86 | yes-4-x86_64 | yes-4-amd64)\n    AC_MSG_CHECKING([for gcc sse2 asm support])\n    save_CFLAGS=\"$CFLAGS\"\n    CFLAGS=\"$CFLAGS -msse2\"\n    gcc_sse2_asm=no\n    AC_TRY_COMPILE([],\n\t[\n\t\tlong long x, *y;\n\t\t__asm__ __volatile__(\"movq %1, %0\\n\\t\" : \"=x\"(x) : \"m\"(*y) : \"memory\");\n\t],\n\t[gcc_sse2_asm=yes])\n    CFLAGS=\"$save_CFLAGS\"\n    AC_MSG_RESULT([$gcc_sse2_asm])\n    if test \"$gcc_sse2_asm\" = \"yes\"; then\n      AC_DEFINE(ETHR_GCC_HAVE_SSE2_ASM_SUPPORT, 1, [Define if you use a gcc that supports -msse2 and understand sse2 specific asm statements])\n      ETHR_X86_SSE2_ASM=yes\n    fi\n    ;;\n  *)\n    ;;\nesac\n\ncase \"$GCC-$host_cpu\" in\n  yes-i86pc | yes-i*86 | yes-x86_64 | yes-amd64)\n\n    if test $ac_cv_sizeof_void_p = 4; then\n       dw_cmpxchg=\"cmpxchg8b\"\n    else\n       dw_cmpxchg=\"cmpxchg16b\"\n    fi\n\n    gcc_dw_cmpxchg_asm=no\n    gcc_pic_dw_cmpxchg_asm=no\n    gcc_cflags_pic=no\n    gcc_cmpxchg8b_pic_no_clobber_ebx=no\n    gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage=no\n\n    save_CFLAGS=\"$CFLAGS\"\n\n    # Check if it works out of the box using passed CFLAGS\n    # and with -fPIC added to CFLAGS if the passed CFLAGS\n    # doesn't trigger position independent code\n    pic_cmpxchg=unknown\n    while true; do\n\n        case $pic_cmpxchg in\n\t  yes) pic_text=\"pic \";;\n\t  *) pic_text=\"\";;\n\tesac\n\n\tAC_MSG_CHECKING([for gcc $pic_text$dw_cmpxchg plain asm support])    \n\n\tplain_cmpxchg=no\n    \tAC_TRY_COMPILE([],\n\t[\n    char xchgd;\n    long new[2], xchg[2], *p;\t\t  \n    __asm__ __volatile__(\n#if ETHR_SIZEOF_PTR == 4\n\t\"lock; cmpxchg8b %0\\n\\t\"\n#else\n\t\"lock; cmpxchg16b %0\\n\\t\"\n#endif\n\t\"setz %3\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=q\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"c\"(new[1]), \"b\"(new[0])\n\t: \"cc\", \"memory\");\n\t],\n\t[plain_cmpxchg=yes])\n\n\tAC_MSG_RESULT([$plain_cmpxchg])\n\n\tif test $pic_cmpxchg = yes; then\n\t   gcc_pic_dw_cmpxchg_asm=$plain_cmpxchg\n\t   break\n\tfi\n\n\tgcc_dw_cmpxchg_asm=$plain_cmpxchg\n\n    \t# If not already compiling to position independent\n\t# code add -fPIC to CFLAGS and do it again. This\n\t# since we want also want to know how to compile\n\t# to position independent code since this might\n\t# cause problems with the use of the EBX register\n\t# as input to the asm on 32-bit x86 and old gcc\n\t# compilers (gcc vsn < 5).\n\n    \tAC_TRY_COMPILE([],\n\t[\n#if !defined(__PIC__) || !__PIC__\n#  error no pic\n#endif\n\t],\n\t[pic_cmpxchg=yes\n\t gcc_cflags_pic=yes],\n\t[pic_cmpxchg=no])\n\n\tif test $pic_cmpxchg = yes; then\n\t   gcc_pic_dw_cmpxchg_asm=$gcc_dw_cmpxchg_asm\n\t   break\n\tfi\n\n\tCFLAGS=\"$save_CFLAGS -fPIC\"\n\tpic_cmpxchg=yes\n\n    done\n\n    if test $gcc_pic_dw_cmpxchg_asm = no && test $ac_cv_sizeof_void_p = 4; then\n\n      AC_MSG_CHECKING([for gcc pic cmpxchg8b asm support with EBX workaround])\n\n      # Check if we can work around it by managing the ebx\n      # register explicitly in the asm...\n\n      AC_TRY_COMPILE([],\n\t[\n    char xchgd;\n    long new[2], xchg[2], *p;\t\t  \n    __asm__ __volatile__(\n\t\"pushl %%ebx\\n\\t\"\n\t\"movl %8, %%ebx\\n\\t\"\n\t\"lock; cmpxchg8b %0\\n\\t\"\n\t\"setz %3\\n\\t\"\n\t\"popl %%ebx\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=q\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"c\"(new[1]), \"r\"(new[0])\n\t: \"cc\", \"memory\");\n\t],\n\t[gcc_pic_dw_cmpxchg_asm=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx=yes])     \n\n      AC_MSG_RESULT([$gcc_pic_dw_cmpxchg_asm])\n\n      if test $gcc_pic_dw_cmpxchg_asm = no; then\n\n      \tAC_MSG_CHECKING([for gcc pic cmpxchg8b asm support with EBX and register shortage workarounds])\n        # If no optimization is enabled we sometimes get a\n\t# register shortage. Check if we can work around\n\t# this...\n\n      \tAC_TRY_COMPILE([],\n\t  [\n      char xchgd;\n      long new[2], xchg[2], *p;\n      __asm__ __volatile__(\n\t\"pushl %%ebx\\n\\t\"\n\t\"movl (%7), %%ebx\\n\\t\"\n\t\"movl 4(%7), %%ecx\\n\\t\"\n\t\"lock; cmpxchg8b %0\\n\\t\"\n\t\"setz %3\\n\\t\"\n\t\"popl %%ebx\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=c\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"r\"(new)\n\t: \"cc\", \"memory\");\n\n\t],\n\t[gcc_pic_dw_cmpxchg_asm=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage=yes])\n\n        AC_MSG_RESULT([$gcc_pic_dw_cmpxchg_asm])\n      fi\n\n      if test $gcc_cflags_pic = yes; then\n        gcc_dw_cmpxchg_asm=$gcc_pic_dw_cmpxchg_asm\n      fi\n \n   fi\n\n    CFLAGS=\"$save_CFLAGS\"\n\n    if test \"$gcc_cmpxchg8b_pic_no_clobber_ebx\" = \"yes\"; then\n      AC_DEFINE(ETHR_CMPXCHG8B_PIC_NO_CLOBBER_EBX, 1, [Define if gcc wont let you clobber ebx with cmpxchg8b and position independent code])\n    fi\n    if test \"$gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage\" = \"yes\"; then\n      AC_DEFINE(ETHR_CMPXCHG8B_REGISTER_SHORTAGE, 1, [Define if you get a register shortage with cmpxchg8b and position independent code])\n    fi\n    if test \"$gcc_dw_cmpxchg_asm\" = \"yes\"; then\n      AC_DEFINE(ETHR_GCC_HAVE_DW_CMPXCHG_ASM_SUPPORT, 1, [Define if you use a gcc that supports the double word cmpxchg instruction])\n    fi;;\n  *)\n    ;;\nesac\n\nAC_DEFINE(ETHR_HAVE_ETHREAD_DEFINES, 1, \\\n[Define if you have all ethread defines])\n\nAC_SUBST(ETHR_X_LIBS)\nAC_SUBST(ETHR_LIBS)\nAC_SUBST(ETHR_LIB_NAME)\nAC_SUBST(ETHR_DEFS)\nAC_SUBST(ETHR_THR_LIB_BASE)\nAC_SUBST(ETHR_THR_LIB_BASE_DIR)\nAC_SUBST(ETHR_X86_SSE2_ASM)\n\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl ERL_TIME_CORRECTION\ndnl\ndnl Check for primitives that can be used for implementing\ndnl erts_os_monotonic_time() and erts_os_system_time()\ndnl\n\nAC_DEFUN(ERL_TIME_CORRECTION,\n[\n\nAC_ARG_WITH(clock-resolution,\nAS_HELP_STRING([--with-clock-resolution=high|low|default],\n               [specify wanted clock resolution]))\n\nAC_ARG_WITH(clock-gettime-realtime-id,\nAS_HELP_STRING([--with-clock-gettime-realtime-id=CLOCKID],\n               [specify clock id to use with clock_gettime() for realtime time)]))\n\nAC_ARG_WITH(clock-gettime-monotonic-id,\nAS_HELP_STRING([--with-clock-gettime-monotonic-id=CLOCKID],\n               [specify clock id to use with clock_gettime() for monotonic time)]))\n\nAC_ARG_ENABLE(prefer-elapsed-monotonic-time-during-suspend,\nAS_HELP_STRING([--enable-prefer-elapsed-monotonic-time-during-suspend],\n               [Prefer an OS monotonic time source with elapsed time during suspend])\nAS_HELP_STRING([--disable-prefer-elapsed-monotonic-time-during-suspend],\n               [Do not prefer an OS monotonic time source with elapsed time during suspend]),\n[ case \"$enableval\" in\n    yes) prefer_elapsed_monotonic_time_during_suspend=yes ;;\n    *)  prefer_elapsed_monotonic_time_during_suspend=no ;;\n  esac ], prefer_elapsed_monotonic_time_during_suspend=no)\n\nAC_ARG_ENABLE(gettimeofday-as-os-system-time,\n\t      AS_HELP_STRING([--enable-gettimeofday-as-os-system-time],\n                             [Force usage of gettimeofday() for OS system time]),\n[ case \"$enableval\" in\n    yes) force_gettimeofday_os_system_time=yes ;;\n    *)  force_gettimeofday_os_system_time=no ;;\n  esac ], force_gettimeofday_os_system_time=no)\n\ncase \"$with_clock_resolution\" in\n   \"\"|no|yes)\n     with_clock_resolution=default;;\n   high|low|default)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid wanted clock resolution: $with_clock_resolution])\n     ;;\nesac\n\nif test \"$force_gettimeofday_os_system_time\" = \"yes\"; then\n\n  AC_CHECK_FUNCS([gettimeofday])\n  if test \"$ac_cv_func_gettimeofday\" = \"yes\"; then\n    AC_DEFINE(OS_SYSTEM_TIME_GETTIMEOFDAY,  [1], [Define if you want to implement erts_os_system_time() using gettimeofday()])\n  else\n    AC_MSG_ERROR([No gettimeofday() available])\n  fi\n\nelse # $force_gettimeofday_os_system_time != yes\n\ncase \"$with_clock_gettime_realtime_id\" in\n   \"\"|no)\n     with_clock_gettime_realtime_id=no\n     ;;\n   CLOCK_*CPUTIME*)\n     AC_MSG_ERROR([Invalid clock_gettime() realtime clock id: Refusing to use the cputime clock id $with_clock_gettime_realtime_id as realtime clock id])\n     ;;\n   CLOCK_MONOTONIC*|CLOCK_BOOTTIME*|CLOCK_UPTIME*|CLOCK_HIGHRES*)\n     AC_MSG_ERROR([Invalid clock_gettime() realtime clock id: Refusing to use the monotonic clock id $with_clock_gettime_realtime_id as realtime clock id])\n     ;;\n   CLOCK_*)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid clock_gettime() clock id: $with_clock_gettime_realtime_id])\n     ;;\nesac\n\ncase \"$with_clock_resolution-$with_clock_gettime_realtime_id\" in\n  high-no)\n\tERL_WALL_CLOCK(high_resolution);;\n  low-no)\n\tERL_WALL_CLOCK(low_resolution);;\n  default-no)\n\tERL_WALL_CLOCK(default_resolution);;\n  *)\n\tERL_WALL_CLOCK(custom_resolution, $with_clock_gettime_realtime_id);;\nesac\n\ncase \"$erl_wall_clock_func-$erl_wall_clock_id-$with_clock_gettime_realtime_id\" in\n  *-*-no)\n    ;;\n  clock_gettime-$with_clock_gettime_realtime_id-$with_clock_gettime_realtime_id)\n    ;;\n  *)\n    AC_MSG_ERROR([$with_clock_gettime_realtime_id as clock id to clock_gettime() doesn't compile])\n    ;;\nesac\n\ncase $erl_wall_clock_func in\n  none)\n    AC_MSG_ERROR([No wall clock source found])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(OS_SYSTEM_TIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_system_time() using mach clock_get_time()])\n    ;;\n  clock_gettime)\n    AC_DEFINE(OS_SYSTEM_TIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_system_time() using clock_gettime()])\n    ;;\n  gettimeofday)\n    AC_DEFINE(OS_SYSTEM_TIME_GETTIMEOFDAY,  [1], [Define if you want to implement erts_os_system_time() using gettimeofday()])\n    ;;\n  *)\n    ;;\nesac\n\nif test \"x$erl_wall_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(WALL_CLOCK_ID_STR, [\"$erl_wall_clock_id\"], [Define as a string of wall clock id to use])\n    AC_DEFINE_UNQUOTED(WALL_CLOCK_ID, [$erl_wall_clock_id], [Define to wall clock id to use])\nfi\n\nfi # $force_gettimeofday_os_system_time != yes\n\ncase \"$with_clock_gettime_monotonic_id\" in\n   \"\"|no)\n     with_clock_gettime_monotonic_id=no\n     ;;\n   CLOCK_*CPUTIME*)\n     AC_MSG_ERROR([Invalid clock_gettime() monotonic clock id: Refusing to use the cputime clock id $with_clock_gettime_monotonic_id as monotonic clock id])\n     ;;\n   CLOCK_REALTIME*|CLOCK_TAI*)\n     AC_MSG_ERROR([Invalid clock_gettime() monotonic clock id: Refusing to use the realtime clock id $with_clock_gettime_monotonic_id as monotonic clock id])\n     ;;\n   CLOCK_*)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid clock_gettime() clock id: $with_clock_gettime_monotonic_id])\n     ;;\nesac\n\ncase \"$with_clock_resolution-$with_clock_gettime_monotonic_id\" in\n  high-no)\n\tERL_MONOTONIC_CLOCK(high_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  low-no)\n\tERL_MONOTONIC_CLOCK(low_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  default-no)\n\tERL_MONOTONIC_CLOCK(default_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  *)\n\tERL_MONOTONIC_CLOCK(custom_resolution, $with_clock_gettime_monotonic_id, $prefer_elapsed_monotonic_time_during_suspend);;\nesac\n\ncase \"$erl_monotonic_clock_func-$erl_monotonic_clock_id-$with_clock_gettime_monotonic_id\" in\n  *-*-no)\n    ;;\n  clock_gettime-$with_clock_gettime_monotonic_id-$with_clock_gettime_monotonic_id)\n    ;;\n  *)\n    AC_MSG_ERROR([$with_clock_gettime_monotonic_id as clock id to clock_gettime() doesn't compile])\n    ;;\nesac\n\ncase $erl_monotonic_clock_func in\n  times)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_TIMES, [1], [Define if you want to implement erts_os_monotonic_time() using times()])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_monotonic_time() using mach clock_get_time()])\n    ;;\n  clock_gettime)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_monotonic_time() using clock_gettime()])\n    ;;\n  gethrtime)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_GETHRTIME,  [1], [Define if you want to implement erts_os_monotonic_time() using gethrtime()])\n    ;;\n  *)\n    ;;\nesac\n\nif test $erl_corrected_monotonic_clock = yes; then\n  AC_DEFINE(ERTS_HAVE_CORRECTED_OS_MONOTONIC_TIME, [1], [Define if OS monotonic clock is corrected])\nfi\n\nif test $erl_monotonic_clock_low_resolution = yes; then\n  AC_DEFINE(ERTS_HAVE_LOW_RESOLUTION_OS_MONOTONIC_LOW, [1], [Define if you have a low resolution OS monotonic clock])\nfi\n\nxrtlib=\nif test \"$erl_monotonic_clock_lib\" != \"\"; then\n   xrtlib=\"$erl_monotonic_clock_lib\"\nfi\nif test \"$erl_wall_clock_lib\" != \"\"; then\n   xrtlib=\"$erl_wall_clock_lib\"\nfi\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(MONOTONIC_CLOCK_ID_STR, [\"$erl_monotonic_clock_id\"], [Define as a string of monotonic clock id to use])\n    AC_DEFINE_UNQUOTED(MONOTONIC_CLOCK_ID, [$erl_monotonic_clock_id], [Define to monotonic clock id to use])\nfi\n\nif test $erl_cv_clock_gettime_monotonic_raw = yes; then\n  AC_DEFINE(HAVE_CLOCK_GETTIME_MONOTONIC_RAW, [1], [Define if you have clock_gettime(CLOCK_MONOTONIC_RAW, _)])\nfi\n\nERL_MONOTONIC_CLOCK(high_resolution, undefined, no)\n\ncase $$erl_monotonic_clock_low_resolution-$erl_monotonic_clock_func in\n  no-mach_clock_get_time)\n    monotonic_hrtime=yes    \n    AC_DEFINE(SYS_HRTIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_hrtime() using mach clock_get_time()])\n    ;;\n  no-clock_gettime)\n    monotonic_hrtime=yes\n    AC_DEFINE(SYS_HRTIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_hrtime() using clock_gettime()])\n    ;;\n  no-gethrtime)\n    monotonic_hrtime=yes\n    AC_DEFINE(SYS_HRTIME_USING_GETHRTIME,  [1], [Define if you want to implement erts_os_hrtime() using gethrtime()])\n    ;;\n  *)\n    monotonic_hrtime=no\n    ;;\nesac\n\nif test $monotonic_hrtime = yes; then\n    AC_DEFINE(HAVE_MONOTONIC_ERTS_SYS_HRTIME, [1], [Define if you have a monotonic erts_os_hrtime() implementation])\nfi\n\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(HRTIME_CLOCK_ID_STR, [\"$erl_monotonic_clock_id\"], [Define as a string of monotonic clock id to use])\n    AC_DEFINE_UNQUOTED(HRTIME_CLOCK_ID, [$erl_monotonic_clock_id], [Define to monotonic clock id to use])\nfi\n\n\ndnl\ndnl Check if gethrvtime is working, and if to use procfs ioctl\ndnl or (yet to be written) write to the procfs ctl file.\ndnl\n\nAC_MSG_CHECKING([if gethrvtime works and how to use it])\nAC_TRY_RUN([\n/* gethrvtime procfs ioctl test */\n/* These need to be undef:ed to not break activation of\n * micro level process accounting on /proc/self \n */\n#ifdef _LARGEFILE_SOURCE\n#  undef _LARGEFILE_SOURCE\n#endif\n#ifdef _FILE_OFFSET_BITS\n#  undef _FILE_OFFSET_BITS\n#endif\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/signal.h>\n#include <sys/fault.h>\n#include <sys/syscall.h>\n#include <sys/procfs.h>\n#include <fcntl.h>\n\nint main() {\n    long msacct = PR_MSACCT;\n    int fd;\n    long long start, stop;\n    int i;\n    pid_t pid = getpid();\n    char proc_self[30] = \"/proc/\";\n\n    sprintf(proc_self+strlen(proc_self), \"%lu\", (unsigned long) pid);\n    if ( (fd = open(proc_self, O_WRONLY)) == -1)\n\texit(1);\n    if (ioctl(fd, PIOCSET, &msacct) < 0)\n\texit(2);\n    if (close(fd) < 0)\n\texit(3);\n    start = gethrvtime();\n    for (i = 0; i < 100; i++)\n\tstop = gethrvtime();\n    if (start == 0)\n\texit(4);\n    if (start == stop)\n\texit(5);\n    exit(0); return 0;\n}\n],\nerl_gethrvtime=procfs_ioctl,\nerl_gethrvtime=false,\n[\ncase X$erl_xcomp_gethrvtime_procfs_ioctl in\n    X)\n\terl_gethrvtime=cross;;\n    Xyes|Xno)\n\tif test $erl_xcomp_gethrvtime_procfs_ioctl = yes; then\n\t    erl_gethrvtime=procfs_ioctl\n\telse\n\t    erl_gethrvtime=false\n\tfi;;\n    *)\n\tAC_MSG_ERROR([Bad erl_xcomp_gethrvtime_procfs_ioctl value: $erl_xcomp_gethrvtime_procfs_ioctl]);;\nesac\n])\n\nLIBRT=$xrtlib\ncase $erl_gethrvtime in\n  procfs_ioctl)\n\tAC_DEFINE(HAVE_GETHRVTIME_PROCFS_IOCTL,[1],\n\t\t[define if gethrvtime() works and uses ioctl() to /proc/self])\n\tAC_MSG_RESULT(uses ioctl to procfs)\n\t;;\n  *)\n\tif test $erl_gethrvtime = cross; then\n\t    erl_gethrvtime=false\n\t    AC_MSG_RESULT(cross)\n\t    AC_MSG_WARN([result 'not working' guessed because of cross compilation])\n\telse\n\t    AC_MSG_RESULT(not working)\n\tfi\n\n\tdnl\n\tdnl Check if clock_gettime (linux) is working\n\tdnl\n\n\tAC_MSG_CHECKING([if clock_gettime can be used to get thread CPU time])\n\tsave_libs=$LIBS\n\tLIBS=\"-lrt\"\n\tAC_TRY_RUN([\n\t#include <stdlib.h>\n\t#include <unistd.h>\n\t#include <string.h>\n\t#include <stdio.h>\n\t#include <time.h>\n\tint main() {\n\t    long long start, stop;\n\t    int i;\n\t    struct timespec tp;\n\n\t    if (clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp) < 0)\n\t      exit(1);\n\t    start = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;\n\t    for (i = 0; i < 100; i++)\n\t      clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp);\n\t    stop = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;\n\t    if (start == 0)\n\t      exit(4);\n\t    if (start == stop)\n\t      exit(5);\n\t    exit(0); return 0;\n\t  }\n\t],\n\terl_clock_gettime_cpu_time=yes,\n\terl_clock_gettime_cpu_time=no,\n\t[\n\tcase X$erl_xcomp_clock_gettime_cpu_time in\n\t    X) erl_clock_gettime_cpu_time=cross;;\n\t    Xyes|Xno) erl_clock_gettime_cpu_time=$erl_xcomp_clock_gettime_cpu_time;;\n\t    *) AC_MSG_ERROR([Bad erl_xcomp_clock_gettime_cpu_time value: $erl_xcomp_clock_gettime_cpu_time]);;\n\tesac\n\t])\n\tLIBS=$save_libs\n\tAC_MSG_RESULT($erl_clock_gettime_cpu_time)\n\tcase $erl_clock_gettime_cpu_time in\n\t\tyes)\n\t\t\tAC_DEFINE(HAVE_CLOCK_GETTIME_CPU_TIME,[],\n\t\t\t\t  [define if clock_gettime() works for getting thread time])\n\t\t\tLIBRT=-lrt\n\t\t\t;;\n\t\tcross)\n\t\t\terl_clock_gettime_cpu_time=no\n\t\t\tAC_MSG_WARN([result no guessed because of cross compilation])\n\t\t\t;;\n\t\t*)\n\t\t\t;;\n\tesac\n\t;;\nesac\nAC_SUBST(LIBRT)\n])dnl\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_TRY_ENABLE_CFLAG\ndnl\ndnl\ndnl Tries a CFLAG and sees if it can be enabled without compiler errors\ndnl $1: textual cflag to add\ndnl $2: variable to store the modified CFLAG in\ndnl Usage example LM_TRY_ENABLE_CFLAG([-Werror=return-type], [CFLAGS])\ndnl\ndnl\nAC_DEFUN([LM_TRY_ENABLE_CFLAG], [\n    AC_MSG_CHECKING([if we can add $1 to $2 (via CFLAGS)])\n    saved_CFLAGS=$CFLAGS;\n    CFLAGS=\"$1 $$2\";\n    AC_TRY_COMPILE([],[return 0;],can_enable_flag=true,can_enable_flag=false)\n    CFLAGS=$saved_CFLAGS;\n    if test \"X$can_enable_flag\" = \"Xtrue\"; then\n        AC_MSG_RESULT([yes])\n        AS_VAR_SET($2, \"$1 $$2\")\n    else\n        AC_MSG_RESULT([no])\n    fi\n])\n\nAC_DEFUN([LM_CHECK_ENABLE_CFLAG], [\n    AC_MSG_CHECKING([whether $CC accepts $1...])\n    saved_CFLAGS=$CFLAGS;\n    CFLAGS=\"$1 $CFLAGS\";\n    AC_TRY_COMPILE([],[return 0;],can_enable_flag=true,can_enable_flag=false)\n    CFLAGS=$saved_CFLAGS;\n    if test \"X$can_enable_flag\" = \"Xtrue\"; then\n        AS_VAR_SET($2, true)\n        AC_MSG_RESULT([yes])\n    else\n        AS_VAR_SET($2, false)\n        AC_MSG_RESULT([no])\n    fi\n])\n\ndnl ERL_TRY_LINK_JAVA(CLASSES, FUNCTION-BODY\ndnl                   [ACTION_IF_FOUND [, ACTION-IF-NOT-FOUND]])\ndnl Freely inspired by AC_TRY_LINK. (Maybe better to create a \ndnl AC_LANG_JAVA instead...)\nAC_DEFUN(ERL_TRY_LINK_JAVA,\n[java_link='$JAVAC conftest.java 1>&AC_FD_CC'\nchangequote(, )dnl\ncat > conftest.java <<EOF\n$1\nclass conftest { public static void main(String[] args) {\n   $2\n   ; return; }}\nEOF\nchangequote([, ])dnl\nif AC_TRY_EVAL(java_link) && test -s conftest.class; then\n   ifelse([$3], , :, [rm -rf conftest*\n   $3])\nelse\n   echo \"configure: failed program was:\" 1>&AC_FD_CC\n   cat conftest.java 1>&AC_FD_CC\n   echo \"configure: PATH was $PATH\" 1>&AC_FD_CC\nifelse([$4], , , [  rm -rf conftest*\n  $4\n])dnl\nfi\nrm -f conftest*])\n#define UNSAFE_MASK  0xc0000000 /* Mask for bits that must be constant */\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_HARDWARE_ARCH\ndnl\ndnl Determine target hardware in ARCH\ndnl\nAC_DEFUN([LM_HARDWARE_ARCH], [\n    AC_MSG_CHECKING([target hardware architecture])\n    if test \"x$host_alias\" != \"x\" -a \"x$host_cpu\" != \"x\"; then\n        chk_arch_=$host_cpu\n    else\n        chk_arch_=`uname -m`\n    fi\n\n    case $chk_arch_ in\n    sun4u)\tARCH=ultrasparc;;\n    sparc64)\tARCH=sparc64;;\n    sun4v)\tARCH=ultrasparc;;\n    i86pc)\tARCH=x86;;\n    i386)\tARCH=x86;;\n    i486)\tARCH=x86;;\n    i586)\tARCH=x86;;\n    i686)\tARCH=x86;;\n    x86_64)\tARCH=amd64;;\n    amd64)\tARCH=amd64;;\n    macppc)\tARCH=ppc;;\n    powerpc)\tARCH=ppc;;\n    ppc)\tARCH=ppc;;\n    ppc64)\tARCH=ppc64;;\n    ppc64le)\tARCH=ppc64le;;\n    \"Power Macintosh\")\tARCH=ppc;;\n    armv5b)\tARCH=arm;;\n    armv5teb)\tARCH=arm;;\n    armv5tel)\tARCH=arm;;\n    armv5tejl)\tARCH=arm;;\n    armv6l)\tARCH=arm;;\n    armv6hl)\tARCH=arm;;\n    armv7l)\tARCH=arm;;\n    armv7hl)\tARCH=arm;;\n    tile)\tARCH=tile;;\n    e2k)        ARCH=e2k;;\n    *)\t \tARCH=noarch;;\n    esac\n    AC_MSG_RESULT($ARCH)\n\n    dnl\n    dnl Convert between x86 and amd64 based on the compiler's mode.\n    dnl Ditto between ultrasparc and sparc64.\n    dnl\n    AC_MSG_CHECKING(whether compilation mode forces ARCH adjustment)\n    case \"$ARCH-$ac_cv_sizeof_void_p\" in\n    x86-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=x86 to ARCH=amd64)\n\tARCH=amd64\n\t;;\n    amd64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=amd64 to ARCH=x86)\n\tARCH=x86\n\t;;\n    ultrasparc-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ultrasparc to ARCH=sparc64)\n\tARCH=sparc64\n\t;;\n    sparc64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=sparc64 to ARCH=ultrasparc)\n\tARCH=ultrasparc\n\t;;\n    ppc64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ppc64 to ARCH=ppc)\n\tARCH=ppc\n\t;;\n    ppc-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ppc to ARCH=ppc64)\n\tARCH=ppc64\n\t;;\n    arm-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=arm to ARCH=noarch)\n\tARCH=noarch\n\t;;\n    *)\n\tAC_MSG_RESULT(no: ARCH is $ARCH)\n\t;;\n    esac\n\n    AC_SUBST(ARCH)\n])\n\ndnl\ndnl--------------------------------------------------------------------\ndnl Dynamic Erlang Drivers\ndnl\ndnl Linking to produce dynamic Erlang drivers to be loaded by Erlang's\ndnl Dynamic Driver Loader and Linker (DDLL). Below the prefix DED is an\ndnl abbreviation for `Dynamic Erlang Driver'.\ndnl\ndnl For DED we need something quite sloppy, which allows undefined references \ndnl (notably driver functions) in the resulting shared library. \ndnl Example of Makefile rule (and settings of macros):\ndnl\ndnl LIBS = @LIBS@\ndnl LD = @DED_LD@\ndnl LDFLAGS = @DED_LDFLAGS@\ndnl soname = @ldsoname@\ndnl\ndnl my_drv.so:   my_drv.o my_utils.o\ndnl              $(LD) $(LDFLAGS) $(soname) $@ -o $@ $^ -lc $(LIBS)\ndnl\ndnl--------------------------------------------------------------------\ndnl\n\nAC_DEFUN(ERL_DED,\n\t[\n\nUSER_LD=$LD\nUSER_LDFLAGS=\"$LDFLAGS\"\n\nLM_CHECK_THR_LIB\n\nDED_CC=$CC\nDED_GCC=$GCC\n\nDED_CFLAGS=\nDED_OSTYPE=unix\ncase $host_os in\n     linux*)\n\tDED_CFLAGS=\"-D_GNU_SOURCE\" ;;\n     win32)\n\tDED_CFLAGS=\"-D_WIN32_WINNT=0x0600 -DWINVER=0x0600\"\n        DED_OSTYPE=win32 ;;\n     *)\n        ;;\nesac\n\n\nDED_WARN_FLAGS=\"-Wall -Wstrict-prototypes\"\ncase \"$host_cpu\" in\n  tile*)\n    # tile-gcc is a bit stricter with -Wmissing-prototypes than other gccs,\n    # and too strict for our taste.\n    ;;\n  *)\n    DED_WARN_FLAGS=\"$DED_WARN_FLAGS -Wmissing-prototypes\";;\nesac\n  \nLM_TRY_ENABLE_CFLAG([-Wdeclaration-after-statement], [DED_WARN_FLAGS])\n\nLM_TRY_ENABLE_CFLAG([-Werror=return-type], [DED_WERRORFLAGS])\nLM_TRY_ENABLE_CFLAG([-Werror=implicit], [DED_WERRORFLAGS])\nLM_TRY_ENABLE_CFLAG([-Werror=undef], [DED_WERRORFLAGS])\n\nDED_SYS_INCLUDE=\"-I${ERL_TOP}/erts/emulator/beam -I${ERL_TOP}/erts/include -I${ERL_TOP}/erts/include/$host -I${ERL_TOP}/erts/include/internal -I${ERL_TOP}/erts/include/internal/$host -I${ERL_TOP}/erts/emulator/sys/$DED_OSTYPE -I${ERL_TOP}/erts/emulator/sys/common\"\nDED_INCLUDE=$DED_SYS_INCLUDE\n\nif test \"$THR_DEFS\" = \"\"; then\n    DED_THR_DEFS=\"-D_THREAD_SAFE -D_REENTRANT\"\nelse\n    DED_THR_DEFS=\"$THR_DEFS\"\nfi\n# DED_EMU_THR_DEFS=$EMU_THR_DEFS\nDED_CFLAGS=\"$CFLAGS $CPPFLAGS $DED_CFLAGS\"\nif test \"x$GCC\" = xyes; then\n    DED_STATIC_CFLAGS=\"$DED_CFLAGS\"\n    DED_CFLAGS=\"$DED_CFLAGS -fPIC\"\nfi\n\nDED_EXT=so\ncase $host_os in\n    win32) DED_EXT=dll;;\n    darwin*)\n\tDED_CFLAGS=\"$DED_CFLAGS -fno-common\"\n\tDED_STATIC_CFLAGS=\"$DED_STATIC_CFLAGS -fno-common\";;\n    *)\n\t;;\nesac\n\nDED_STATIC_CFLAGS=\"$DED_STATIC_CFLAGS -DSTATIC_ERLANG_NIF -DSTATIC_ERLANG_DRIVER\"\n\nif test \"$CFLAG_RUNTIME_LIBRARY_PATH\" = \"\"; then\n\n  CFLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-R\"\n  case $host_os in\n    darwin*)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n    win32)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n    osf*)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-rpath,\"\n\t;;\n    *)\n\t;;\n  esac\n\nfi\n\n# If DED_LD is set in environment, we expect all DED_LD* variables\n# to be specified (cross compiling)\nif test \"x$DED_LD\" = \"x\"; then\n\nDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-R\"\ncase $host_os in\n\twin32)\n\t\tDED_LD=\"ld.sh\"\n\t\tDED_LDFLAGS=\"-dll\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n\tsolaris2*|sysv4*)\n\t\tDED_LDFLAGS=\"-G\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-64 $DED_LDFLAGS\"\n\t\tfi\n\t;;\n\taix4*)\n\t\tDED_LDFLAGS=\"-G -bnoentry -bexpall\"\n\t;;\n\tfreebsd2*)\n\t\t# Non-ELF GNU linker\n\t\tDED_LDFLAGS=\"-Bshareable\"\n\t;;\n\tdarwin*)\n\t\t# Mach-O linker: a shared lib and a loadable\n\t\t# object file is not the same thing.\n\t\tDED_LDFLAGS=\"-bundle -bundle_loader ${ERL_TOP}/bin/$host/beam.smp\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t  DED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\telse\n\t\t  if test X${enable_m32_build} = Xyes; then\n\t\t    DED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\t  else\n\t\t    AC_CHECK_SIZEOF(void *)\n\t\t    case \"$ac_cv_sizeof_void_p\" in\n\t\t      8)\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\";;\n\t\t      *)\n\t\t        ;;\n\t\t    esac\n\t\t  fi\n\t\tfi\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t;;\n\tlinux*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared -Wl,-Bsymbolic\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\tfi;\n\t\tif test X${enable_m32_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\tfi\n\t;;\t\n\tfreebsd*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\tfi;\n\t\tif test X${enable_m32_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\tfi\n\t;;\t\n\topenbsd*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared\"\n\t;;\n\tosf*)\n\t\t# NOTE! Whitespace after -rpath is important.\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-rpath \"\n\t\tDED_LDFLAGS=\"-shared -expect_unresolved '*'\"\n\t;;\n\t*)\n\t\t# assume GNU linker and ELF\n\t\tDED_LDFLAGS=\"-shared\"\n\t\t# GNU linker has no option for 64bit build, should not propagate -m64\n\t;;\nesac\n\nif test \"$DED_LD\" = \"\" && test \"$USER_LD\" != \"\"; then\n    DED_LD=\"$USER_LD\"\n    DED_LDFLAGS=\"$USER_LDFLAGS $DED_LDFLAGS\"\nfi\n\nDED_LIBS=$LIBS\n\nfi # \"x$DED_LD\" = \"x\"\n\nAC_CHECK_TOOL(DED_LD, ld, false)\ntest \"$DED_LD\" != \"false\" || AC_MSG_ERROR([No linker found])\n\nAC_MSG_CHECKING(for static compiler flags)\nDED_STATIC_CFLAGS=\"$DED_WERRORFLAGS $DED_WFLAGS $DED_THR_DEFS $DED_STATIC_CFLAGS\"\nAC_MSG_RESULT([$DED_STATIC_CFLAGS])\nAC_MSG_CHECKING(for basic compiler flags for loadable drivers)\nDED_BASIC_CFLAGS=$DED_CFLAGS\nAC_MSG_RESULT([$DED_CFLAGS])\nAC_MSG_CHECKING(for compiler flags for loadable drivers)\nDED_CFLAGS=\"$DED_WERRORFLAGS $DED_WARN_FLAGS $DED_THR_DEFS $DED_CFLAGS\"\nAC_MSG_RESULT([$DED_CFLAGS])\nAC_MSG_CHECKING(for linker for loadable drivers)\nAC_MSG_RESULT([$DED_LD])\nAC_MSG_CHECKING(for linker flags for loadable drivers)\nAC_MSG_RESULT([$DED_LDFLAGS])\nAC_MSG_CHECKING(for 'runtime library path' linker flag)\nif test \"x$DED_LD_FLAG_RUNTIME_LIBRARY_PATH\" != \"x\"; then\n\tAC_MSG_RESULT([$DED_LD_FLAG_RUNTIME_LIBRARY_PATH])\nelse\n\tAC_MSG_RESULT([not found])\nfi\n\nAC_SUBST(DED_CC)\nAC_SUBST(DED_GCC)\nAC_SUBST(DED_EXT)\nAC_SUBST(DED_SYS_INCLUDE)\nAC_SUBST(DED_INCLUDE)\nAC_SUBST(DED_BASIC_CFLAGS)\nAC_SUBST(DED_CFLAGS)\nAC_SUBST(DED_STATIC_CFLAGS)\nAC_SUBST(DED_WARN_FLAGS)\nAC_SUBST(DED_WERRORFLAGS)\nAC_SUBST(DED_LD)\nAC_SUBST(DED_LDFLAGS)\nAC_SUBST(DED_LD_FLAG_RUNTIME_LIBRARY_PATH)\nAC_SUBST(DED_LIBS)\nAC_SUBST(DED_THR_DEFS)\nAC_SUBST(DED_OSTYPE)\n\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/odbc/aclocal.m4": "dnl\ndnl %CopyrightBegin%\ndnl\ndnl Copyright Ericsson AB 1998-2018. All Rights Reserved.\ndnl\ndnl Licensed under the Apache License, Version 2.0 (the \"License\");\ndnl you may not use this file except in compliance with the License.\ndnl You may obtain a copy of the License at\ndnl\ndnl     http://www.apache.org/licenses/LICENSE-2.0\ndnl\ndnl Unless required by applicable law or agreed to in writing, software\ndnl distributed under the License is distributed on an \"AS IS\" BASIS,\ndnl WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\ndnl See the License for the specific language governing permissions and\ndnl limitations under the License.\ndnl\ndnl %CopyrightEnd%\ndnl\n\ndnl\ndnl aclocal.m4\ndnl\ndnl Local macros used in configure.in. The Local Macros which\ndnl could/should be part of autoconf are prefixed LM_, macros specific\ndnl to the Erlang system are prefixed ERL_.\ndnl\n\nAC_DEFUN(LM_PRECIOUS_VARS,\n[\n\ndnl ERL_TOP\nAC_ARG_VAR(ERL_TOP, [Erlang/OTP top source directory])\n\ndnl Tools\nAC_ARG_VAR(CC, [C compiler])\nAC_ARG_VAR(CFLAGS, [C compiler flags])\nAC_ARG_VAR(STATIC_CFLAGS, [C compiler static flags])\nAC_ARG_VAR(CFLAG_RUNTIME_LIBRARY_PATH, [runtime library path linker flag passed via C compiler])\nAC_ARG_VAR(CPP, [C/C++ preprocessor])\nAC_ARG_VAR(CPPFLAGS, [C/C++ preprocessor flags])\nAC_ARG_VAR(CXX, [C++ compiler])\nAC_ARG_VAR(CXXFLAGS, [C++ compiler flags])\nAC_ARG_VAR(LD, [linker (is often overridden by configure)])\nAC_ARG_VAR(LDFLAGS, [linker flags (can be risky to set since LD may be overriden by configure)])\nAC_ARG_VAR(LIBS, [libraries])\nAC_ARG_VAR(DED_LD, [linker for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(DED_LDFLAGS, [linker flags for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(DED_LD_FLAG_RUNTIME_LIBRARY_PATH, [runtime library path linker flag for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(LFS_CFLAGS, [large file support C compiler flags (set all LFS_* variables or none)])\nAC_ARG_VAR(LFS_LDFLAGS, [large file support linker flags (set all LFS_* variables or none)])\nAC_ARG_VAR(LFS_LIBS, [large file support libraries (set all LFS_* variables or none)])\nAC_ARG_VAR(RANLIB, [ranlib])\nAC_ARG_VAR(AR, [ar])\nAC_ARG_VAR(GETCONF, [getconf])\n\ndnl Cross system root\nAC_ARG_VAR(erl_xcomp_sysroot, [Absolute cross system root path (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_isysroot, [Absolute cross system root include path (only used when cross compiling)])\n\ndnl Cross compilation variables\nAC_ARG_VAR(erl_xcomp_bigendian, [big endian system: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_double_middle_endian, [double-middle-endian system: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_nptl, [have Native POSIX Thread Library: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_usable_sigusrx, [SIGUSR1 and SIGUSR2 can be used: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_usable_sigaltstack, [have working sigaltstack(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_poll, [have working poll(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_kqueue, [have working kqueue(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_putenv_copy, [putenv() stores key-value copy: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_reliable_fpe, [have reliable floating point exceptions: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_getaddrinfo, [have working getaddrinfo() for both IPv4 and IPv6: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_gethrvtime_procfs_ioctl, [have working gethrvtime() which can be used with procfs ioctl(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_clock_gettime_cpu_time, [clock_gettime() can be used for retrieving process CPU time: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_after_morecore_hook, [__after_morecore_hook can track malloc()s core memory usage: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_dlsym_brk_wrappers, [dlsym(RTLD_NEXT, _) brk wrappers can track malloc()s core memory usage: yes|no (only used when cross compiling)])\n\n])\n\nAC_DEFUN(ERL_XCOMP_SYSROOT_INIT,\n[\nerl_xcomp_without_sysroot=no\nif test \"$cross_compiling\" = \"yes\"; then\n    test \"$erl_xcomp_sysroot\" != \"\" || erl_xcomp_without_sysroot=yes\n    test \"$erl_xcomp_isysroot\" != \"\" || erl_xcomp_isysroot=\"$erl_xcomp_sysroot\"\nelse\n    erl_xcomp_sysroot=\n    erl_xcomp_isysroot=\nfi\n])\n\nAC_DEFUN(LM_CHECK_GETCONF,\n[\nif test \"$cross_compiling\" != \"yes\"; then\n    AC_CHECK_PROG([GETCONF], [getconf], [getconf], [false])\nelse\n    dnl First check if we got a `<HOST>-getconf' in $PATH\n    host_getconf=\"$host_alias-getconf\"\n    AC_CHECK_PROG([GETCONF], [$host_getconf], [$host_getconf], [false])\n    if test \"$GETCONF\" = \"false\" && test \"$erl_xcomp_sysroot\" != \"\"; then\n\tdnl We should perhaps give up if we have'nt found it by now, but at\n\tdnl least in one Tilera MDE `getconf' under sysroot is a bourne\n\tdnl shell script which we can use. We try to find `<HOST>-getconf'\n    \tdnl or `getconf' under sysconf, but only under sysconf since\n\tdnl `getconf' in $PATH is almost guaranteed to be for the build\n\tdnl machine.\n\tGETCONF=\n\tprfx=\"$erl_xcomp_sysroot\"\n        AC_PATH_TOOL([GETCONF], [getconf], [false],\n\t             [\"$prfx/usr/bin:$prfx/bin:$prfx/usr/local/bin\"])\n    fi\nfi\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_WINDOWS_ENVIRONMENT\ndnl\ndnl\ndnl Tries to determine thw windows build environment, i.e. \ndnl MIXED_CYGWIN_VC or MIXED_MSYS_VC \ndnl\n\nAC_DEFUN(LM_WINDOWS_ENVIRONMENT,\n[\n\nif test \"X$windows_environment_\" != \"Xchecked\"; then\nwindows_environment_=checked\nMIXED_CYGWIN=no\nMIXED_MSYS=no\n\nAC_MSG_CHECKING(for mixed cygwin or msys and native VC++ environment)\nif test \"X$host\" = \"Xwin32\" -a \"x$GCC\" != \"xyes\"; then\n\tif test -x /usr/bin/msys-?.0.dll; then\n\t        CFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_MSYS=yes\n\t\tAC_MSG_RESULT([MSYS and VC])\n\t\tMIXED_MSYS_VC=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_MSYS_VC\"\n\telif test -x /usr/bin/cygpath; then\n\t\tCFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_CYGWIN=yes\n\t\tAC_MSG_RESULT([Cygwin and VC])\n\t\tMIXED_CYGWIN_VC=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_CYGWIN_VC\"\n\telse\t\t    \n\t\tAC_MSG_RESULT([undeterminable])\n\t\tAC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)\n\tfi\nelse\n\tAC_MSG_RESULT([no])\n\tMIXED_CYGWIN_VC=no\n\tMIXED_MSYS_VC=no\nfi\nAC_SUBST(MIXED_CYGWIN_VC)\nAC_SUBST(MIXED_MSYS_VC)\n\nMIXED_VC=no\nif test \"x$MIXED_MSYS_VC\" = \"xyes\" -o  \"x$MIXED_CYGWIN_VC\" = \"xyes\" ; then\n   MIXED_VC=yes\nfi\n\nAC_SUBST(MIXED_VC)\n\nif test \"x$MIXED_MSYS\" != \"xyes\"; then\n   AC_MSG_CHECKING(for mixed cygwin and native MinGW environment)\n   if test \"X$host\" = \"Xwin32\" -a \"x$GCC\" = x\"yes\"; then\n\tif test -x /usr/bin/cygpath; then\n\t\tCFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_CYGWIN=yes\n\t\tAC_MSG_RESULT([yes])\n\t\tMIXED_CYGWIN_MINGW=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_CYGWIN_MINGW\"\n\telse\n\t\tAC_MSG_RESULT([undeterminable])\n\t\tAC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)\n\tfi\n    else\n\tAC_MSG_RESULT([no])\n\tMIXED_CYGWIN_MINGW=no\n    fi\nelse\n\tMIXED_CYGWIN_MINGW=no\nfi\t\nAC_SUBST(MIXED_CYGWIN_MINGW)\n\nAC_MSG_CHECKING(if we mix cygwin with any native compiler)\nif test \"X$MIXED_CYGWIN\" = \"Xyes\"; then\n\tAC_MSG_RESULT([yes])\t\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nAC_SUBST(MIXED_CYGWIN)\n\t\nAC_MSG_CHECKING(if we mix msys with another native compiler)\nif test \"X$MIXED_MSYS\" = \"Xyes\" ; then\n\tAC_MSG_RESULT([yes])\t\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nAC_SUBST(MIXED_MSYS)\n\nfi\n])\t\t\n\t\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_FIND_EMU_CC\ndnl\ndnl\ndnl Tries fairly hard to find a C compiler that can handle jump tables.\ndnl Defines the @EMU_CC@ variable for the makefiles and \ndnl inserts NO_JUMP_TABLE in the header if one cannot be found...\ndnl\n\nAC_DEFUN(LM_FIND_EMU_CC,\n\t[AC_CACHE_CHECK(for a compiler that handles jumptables,\n\t\t\tac_cv_prog_emu_cc,\n\t\t\t[\nAC_TRY_COMPILE([],[\n#if defined(__clang_major__) && __clang_major__ >= 3\n    /* clang 3.x or later is fine */\n#elif defined(__llvm__)\n#error \"this version of llvm is unable to correctly compile beam_emu.c\"\n#endif\n    __label__ lbl1;\n    __label__ lbl2;\n    int x = magic();\n    static void *jtab[2];\n\n    jtab[0] = &&lbl1;\n    jtab[1] = &&lbl2;\n    goto *jtab[x];\nlbl1:\n    return 1;\nlbl2:\n    return 2;\n],ac_cv_prog_emu_cc=\"$CC\",ac_cv_prog_emu_cc=no)\n\nif test \"$ac_cv_prog_emu_cc\" = no; then\n\tfor ac_progname in emu_cc.sh gcc-4.2 gcc; do\n  \t\tIFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\":\"\n  \t\tac_dummy=\"$PATH\"\n  \t\tfor ac_dir in $ac_dummy; do\n    \t\t\ttest -z \"$ac_dir\" && ac_dir=.\n    \t\t\tif test -f \"$ac_dir/$ac_progname\"; then\n      \t\t\t\tac_cv_prog_emu_cc=\"$ac_dir/$ac_progname\"\n      \t\t\t\tbreak\n    \t\t\tfi\n  \t\tdone\n  \t\tIFS=\"$ac_save_ifs\"\n\t\tif test \"$ac_cv_prog_emu_cc\" != no; then\n\t\t\tbreak\n\t\tfi\n\tdone\nfi\n\nif test \"$ac_cv_prog_emu_cc\" != no; then\n\tsave_CC=\"$CC\"\n\tsave_CFLAGS=$CFLAGS\n\tsave_CPPFLAGS=$CPPFLAGS\n\tCC=\"$ac_cv_prog_emu_cc\"\n\tCFLAGS=\"\"\n\tCPPFLAGS=\"\"\n\tAC_TRY_COMPILE([],[\n#if defined(__clang_major__) && __clang_major__ >= 3\n    /* clang 3.x or later is fine */\n#elif defined(__llvm__)\n#error \"this version of llvm is unable to correctly compile beam_emu.c\"\n#endif\n    \t__label__ lbl1;\n    \t__label__ lbl2;\n    \tint x = magic();\n    \tstatic void *jtab[2];\n\n    \tjtab[0] = &&lbl1;\n    \tjtab[1] = &&lbl2;\n    \tgoto *jtab[x];\n\tlbl1:\n    \treturn 1;\n\tlbl2:\n    \treturn 2;\n\t],ac_cv_prog_emu_cc=\"$CC\",ac_cv_prog_emu_cc=no)\n\tCC=$save_CC\n\tCFLAGS=$save_CFLAGS\n\tCPPFLAGS=$save_CPPFLAGS\nfi\n])\nif test \"$ac_cv_prog_emu_cc\" = no; then\n\tAC_DEFINE(NO_JUMP_TABLE,[],[Defined if no found C compiler can handle jump tables])\n\tEMU_CC=\"$CC\"\nelse\n\tEMU_CC=\"$ac_cv_prog_emu_cc\"\nfi\nAC_SUBST(EMU_CC)\n])\t\t\n\t\t\t\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_PROG_INSTALL_DIR\ndnl\ndnl This macro may be used by any OTP application.\ndnl\ndnl Figure out how to create directories with parents.\ndnl (In my opinion INSTALL_DIR is a bad name, MKSUBDIRS or something is better)\ndnl\ndnl We prefer 'install -d', but use 'mkdir -p' if it exists.\ndnl If none of these methods works, we give up.\ndnl\n\n\nAC_DEFUN(LM_PROG_INSTALL_DIR,\n[AC_CACHE_CHECK(how to create a directory including parents,\nac_cv_prog_mkdir_p,\n[\ntemp_name_base=config.$$\ntemp_name=$temp_name_base/x/y/z\n$INSTALL -d $temp_name >/dev/null 2>&1\nac_cv_prog_mkdir_p=none\nif test -d $temp_name; then\n        ac_cv_prog_mkdir_p=\"$INSTALL -d\"\nelse\n        mkdir -p $temp_name >/dev/null 2>&1\n        if test -d $temp_name; then\n                ac_cv_prog_mkdir_p=\"mkdir -p\"\n        fi\nfi\nrm -fr $temp_name_base           \n])\n\ncase \"${ac_cv_prog_mkdir_p}\" in\n  none) AC_MSG_ERROR(don't know how create directories with parents) ;;\n  *)    INSTALL_DIR=\"$ac_cv_prog_mkdir_p\" AC_SUBST(INSTALL_DIR)     ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_PROG_PERL5\ndnl\ndnl Try to find perl version 5. If found set PERL to the absolute path\ndnl of the program, if not found set PERL to false.\ndnl\ndnl On some systems /usr/bin/perl is perl 4 and e.g.\ndnl /usr/local/bin/perl is perl 5. We try to handle this case by\ndnl putting a couple of \ndnl Tries to handle the case that there are two programs called perl\ndnl in the path and one of them is perl 5 and the other isn't. \ndnl\nAC_DEFUN(LM_PROG_PERL5,\n[AC_PATH_PROGS(PERL, perl5 perl, false,\n   /usr/local/bin:/opt/local/bin:/usr/local/gnu/bin:${PATH})\nchangequote(, )dnl\ndnl[ That bracket is needed to balance the right bracket below\nif test \"$PERL\" = \"false\" || $PERL -e 'exit ($] >= 5)'; then\nchangequote([, ])dnl\n  ac_cv_path_PERL=false\n  PERL=false\ndnl  AC_MSG_WARN(perl version 5 not found)\nfi\n])dnl\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_SO_BSDCOMPAT\ndnl\ndnl Check if the system has the SO_BSDCOMPAT flag on sockets (linux) \ndnl\nAC_DEFUN(LM_DECL_SO_BSDCOMPAT,\n[AC_CACHE_CHECK([for SO_BSDCOMPAT declaration], ac_cv_decl_so_bsdcompat,\nAC_TRY_COMPILE([#include <sys/socket.h>], [int i = SO_BSDCOMPAT;],\n               ac_cv_decl_so_bsdcompat=yes,\n               ac_cv_decl_so_bsdcompat=no))\n\ncase \"${ac_cv_decl_so_bsdcompat}\" in\n  \"yes\" ) AC_DEFINE(HAVE_SO_BSDCOMPAT,[],\n\t\t[Define if you have SO_BSDCOMPAT flag on sockets]) ;;\n  * ) ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_INADDR_LOOPBACK\ndnl\ndnl Try to find declaration of INADDR_LOOPBACK, if nowhere provide a default\ndnl\n\nAC_DEFUN(LM_DECL_INADDR_LOOPBACK,\n[AC_CACHE_CHECK([for INADDR_LOOPBACK in netinet/in.h],\n ac_cv_decl_inaddr_loopback,\n[AC_TRY_COMPILE([#include <sys/types.h>\n#include <netinet/in.h>], [int i = INADDR_LOOPBACK;],\nac_cv_decl_inaddr_loopback=yes, ac_cv_decl_inaddr_loopback=no)\n])\n\nif test ${ac_cv_decl_inaddr_loopback} = no; then\n  AC_CACHE_CHECK([for INADDR_LOOPBACK in rpc/types.h],\n                   ac_cv_decl_inaddr_loopback_rpc,\n                   AC_TRY_COMPILE([#include <rpc/types.h>],\n                                   [int i = INADDR_LOOPBACK;],\n                                   ac_cv_decl_inaddr_loopback_rpc=yes,\n                                   ac_cv_decl_inaddr_loopback_rpc=no))\n\n   case \"${ac_cv_decl_inaddr_loopback_rpc}\" in\n     \"yes\" )\n        AC_DEFINE(DEF_INADDR_LOOPBACK_IN_RPC_TYPES_H,[],\n\t\t[Define if you need to include rpc/types.h to get INADDR_LOOPBACK defined]) ;;\n      * )\n  \tAC_CACHE_CHECK([for INADDR_LOOPBACK in winsock2.h],\n                   ac_cv_decl_inaddr_loopback_winsock2,\n                   AC_TRY_COMPILE([#define WIN32_LEAN_AND_MEAN\n\t\t\t\t   #include <winsock2.h>],\n                                   [int i = INADDR_LOOPBACK;],\n                                   ac_cv_decl_inaddr_loopback_winsock2=yes,\n                                   ac_cv_decl_inaddr_loopback_winsock2=no))\n\tcase \"${ac_cv_decl_inaddr_loopback_winsock2}\" in\n     \t\t\"yes\" )\n\t\t\tAC_DEFINE(DEF_INADDR_LOOPBACK_IN_WINSOCK2_H,[],\n\t\t\t\t[Define if you need to include winsock2.h to get INADDR_LOOPBACK defined]) ;;\n\t\t* )\n\t\t\t# couldn't find it anywhere\n        \t\tAC_DEFINE(HAVE_NO_INADDR_LOOPBACK,[],\n\t\t\t\t[Define if you don't have a definition of INADDR_LOOPBACK]) ;;\n\tesac;;\n   esac\nfi\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_STRUCT_SOCKADDR_SA_LEN\ndnl\ndnl Check if the sockaddr structure has the field sa_len\ndnl\n\nAC_DEFUN(LM_STRUCT_SOCKADDR_SA_LEN,\n[AC_CACHE_CHECK([whether struct sockaddr has sa_len field],\n                ac_cv_struct_sockaddr_sa_len,\nAC_TRY_COMPILE([#include <sys/types.h>\n#include <sys/socket.h>], [struct sockaddr s; s.sa_len = 10;],\n  ac_cv_struct_sockaddr_sa_len=yes, ac_cv_struct_sockaddr_sa_len=no))\n\ndnl FIXME convbreak\ncase ${ac_cv_struct_sockaddr_sa_len} in\n  \"no\" ) AC_DEFINE(NO_SA_LEN,[1],[Define if you dont have salen]) ;;\n  *) ;;\nesac\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_STRUCT_EXCEPTION\ndnl\ndnl Check to see whether the system supports the matherr function\ndnl and its associated type \"struct exception\".\ndnl\n\nAC_DEFUN(LM_STRUCT_EXCEPTION,\n[AC_CACHE_CHECK([for struct exception (and matherr function)],\n ac_cv_struct_exception,\nAC_TRY_COMPILE([#include <math.h>],\n  [struct exception x; x.type = DOMAIN; x.type = SING;],\n  ac_cv_struct_exception=yes, ac_cv_struct_exception=no))\n\ncase \"${ac_cv_struct_exception}\" in\n  \"yes\" ) AC_DEFINE(USE_MATHERR,[1],[Define if you have matherr() function and struct exception type]) ;;\n  *  ) ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_SYS_IPV6\ndnl\ndnl Check for ipv6 support and what the in6_addr structure is called.\ndnl (early linux used in_addr6 insted of in6_addr)\ndnl\n\nAC_DEFUN(LM_SYS_IPV6,\n[AC_MSG_CHECKING(for IP version 6 support)\nAC_CACHE_VAL(ac_cv_sys_ipv6_support,\n[ok_so_far=yes\n AC_TRY_COMPILE([#include <sys/types.h>\n#ifdef __WIN32__\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <netinet/in.h>\n#endif],\n   [struct in6_addr a6; struct sockaddr_in6 s6;], ok_so_far=yes, ok_so_far=no)\n\nif test $ok_so_far = yes; then\n  ac_cv_sys_ipv6_support=yes\nelse\n  AC_TRY_COMPILE([#include <sys/types.h>\n#ifdef __WIN32__\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <netinet/in.h>\n#endif],\n    [struct in_addr6 a6; struct sockaddr_in6 s6;],\n    ac_cv_sys_ipv6_support=in_addr6, ac_cv_sys_ipv6_support=no)\nfi\n])dnl\n\ndnl\ndnl Have to use old style AC_DEFINE due to BC with old autoconf.\ndnl\n\ncase ${ac_cv_sys_ipv6_support} in\n  yes)\n    AC_MSG_RESULT(yes)\n    AC_DEFINE(HAVE_IN6,[1],[Define if ipv6 is present])\n    ;;\n  in_addr6)\n    AC_MSG_RESULT([yes (but I am redefining in_addr6 to in6_addr)])\n    AC_DEFINE(HAVE_IN6,[1],[Define if ipv6 is present])\n    AC_DEFINE(HAVE_IN_ADDR6_STRUCT,[],[Early linux used in_addr6 instead of in6_addr, define if you have this])\n    ;;\n  *)\n    AC_MSG_RESULT(no)\n    ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_SYS_MULTICAST\ndnl\ndnl Check for multicast support. Only checks for multicast options in\ndnl setsockopt(), no check is performed that multicasting actually works.\ndnl If options are found defines HAVE_MULTICAST_SUPPORT\ndnl\n\nAC_DEFUN(LM_SYS_MULTICAST,\n[AC_CACHE_CHECK([for multicast support], ac_cv_sys_multicast_support,\n[AC_EGREP_CPP(^yes$,\n[#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#if defined(IP_MULTICAST_TTL) && defined(IP_MULTICAST_LOOP) && defined(IP_MULTICAST_IF) && defined(IP_ADD_MEMBERSHIP) && defined(IP_DROP_MEMBERSHIP)\nyes\n#endif\n], ac_cv_sys_multicast_support=yes, ac_cv_sys_multicast_support=no)])\nif test $ac_cv_sys_multicast_support = yes; then\n  AC_DEFINE(HAVE_MULTICAST_SUPPORT,[1],\n\t[Define if setsockopt() accepts multicast options])\nfi\n])dnl\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_SYS_ERRLIST\ndnl\ndnl Define SYS_ERRLIST_DECLARED if the variable sys_errlist is declared\ndnl in a system header file, stdio.h or errno.h.\ndnl\n\nAC_DEFUN(LM_DECL_SYS_ERRLIST,\n[AC_CACHE_CHECK([for sys_errlist declaration in stdio.h or errno.h],\n  ac_cv_decl_sys_errlist,\n[AC_TRY_COMPILE([#include <stdio.h>\n#include <errno.h>], [char *msg = *(sys_errlist + 1);],\n  ac_cv_decl_sys_errlist=yes, ac_cv_decl_sys_errlist=no)])\nif test $ac_cv_decl_sys_errlist = yes; then\n  AC_DEFINE(SYS_ERRLIST_DECLARED,[],\n\t[define if the variable sys_errlist is declared in a system header file])\nfi\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_CHECK_FUNC_DECL( funname, declaration [, extra includes \ndnl                     [, action-if-found [, action-if-not-found]]] )\ndnl\ndnl Checks if the declaration \"declaration\" of \"funname\" conflicts\ndnl with the header files idea of how the function should be\ndnl declared. It is useful on systems which lack prototypes and you\ndnl need to provide your own (e.g. when you want to take the address\ndnl of a function). The 4'th argument is expanded if conflicting, \ndnl the 5'th argument otherwise\ndnl\ndnl\n\nAC_DEFUN(LM_CHECK_FUNC_DECL,\n[AC_MSG_CHECKING([for conflicting declaration of $1])\nAC_CACHE_VAL(ac_cv_func_decl_$1,\n[AC_TRY_COMPILE([#include <stdio.h>\n$3],[$2\nchar *c = (char *)$1;\n], eval \"ac_cv_func_decl_$1=no\", eval \"ac_cv_func_decl_$1=yes\")])\nif eval \"test \\\"`echo '$ac_cv_func_decl_'$1`\\\" = yes\"; then\n  AC_MSG_RESULT(yes)\n  ifelse([$4], , :, [$4])\nelse\n  AC_MSG_RESULT(no)\nifelse([$5], , , [$5\n])dnl\nfi\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl AC_DOUBLE_MIDDLE_ENDIAN\ndnl\ndnl Checks whether doubles are represented in \"middle-endian\" format.\ndnl Sets ac_cv_double_middle_endian={no,yes,unknown} accordingly,\ndnl as well as DOUBLE_MIDDLE_ENDIAN.\ndnl\ndnl\n\nAC_DEFUN([AC_C_DOUBLE_MIDDLE_ENDIAN],\n[AC_CACHE_CHECK(whether double word ordering is middle-endian, ac_cv_c_double_middle_endian,\n[# It does not; compile a test program.\nAC_RUN_IFELSE(\n[AC_LANG_SOURCE([[#include <stdlib.h>\n\nint\nmain(void)\n{\n  int i = 0;\n  int zero = 0;\n  int bigendian;\n  int zero_index = 0;\n\n  union\n  {\n    long int l;\n    char c[sizeof (long int)];\n  } u;\n\n  /* we'll use the one with 32-bit words */\n  union\n  {\n    double d;\n    unsigned int c[2];\n  } vint;\n\n  union\n  {\n    double d;\n    unsigned long c[2];\n  } vlong;\n\n  union\n  {\n    double d;\n    unsigned short c[2];\n  } vshort;\n\n\n  /* Are we little or big endian?  From Harbison&Steele.  */\n  u.l = 1;\n  bigendian = (u.c[sizeof (long int) - 1] == 1);\n\n  zero_index = bigendian ? 1 : 0;\n\n  vint.d = 1.0;\n  vlong.d = 1.0;\n  vshort.d = 1.0;\n\n  if (sizeof(unsigned int) == 4)\n    {\n      if (vint.c[zero_index] != 0)\n\tzero = 1;\n    }\n  else if (sizeof(unsigned long) == 4)\n    {\n      if (vlong.c[zero_index] != 0)\n\tzero = 1;\n    }\n  else if (sizeof(unsigned short) == 4)\n    {\n      if (vshort.c[zero_index] != 0)\n\tzero = 1;\n    }\n\n  exit (zero);\n}\n]])],\n\t      [ac_cv_c_double_middle_endian=no],\n\t      [ac_cv_c_double_middle_endian=yes],\n\t      [ac_cv_c_double_middle=unknown])])\ncase $ac_cv_c_double_middle_endian in\n  yes)\n    m4_default([$1],\n      [AC_DEFINE([DOUBLE_MIDDLE_ENDIAN], 1,\n\t[Define to 1 if your processor stores the words in a double in\n\t middle-endian format (like some ARMs).])]) ;;\n  no)\n    $2 ;;\n  *)\n    m4_default([$3],\n      [AC_MSG_WARN([unknown double endianness\npresetting ac_cv_c_double_middle_endian=no (or yes) will help])]) ;;\nesac\n])# AC_C_DOUBLE_MIDDLE_ENDIAN\n\n\nAC_DEFUN(ERL_MONOTONIC_CLOCK,\n[\n  if test \"$3\" = \"yes\"; then\n     default_resolution_clock_gettime_monotonic=\"CLOCK_HIGHRES CLOCK_BOOTTIME CLOCK_MONOTONIC\"\n     low_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_COARSE CLOCK_MONOTONIC_FAST\"\n     high_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_PRECISE\"\n  else\n     default_resolution_clock_gettime_monotonic=\"CLOCK_HIGHRES CLOCK_UPTIME CLOCK_MONOTONIC\"\n     low_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_COARSE CLOCK_UPTIME_FAST\"\n     high_resolution_clock_gettime_monotonic=\"CLOCK_UPTIME_PRECISE\"\n  fi\n\n  case \"$1\" in\n    high_resolution)\n\tcheck_msg=\"high resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$high_resolution_clock_gettime_monotonic\"\n\t;;\n    low_resolution)\n\tcheck_msg=\"low resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$low_resolution_clock_gettime_monotonic\"\n\t;;\n    custom_resolution)\n\tcheck_msg=\"custom resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$2\"\n\t;;\n    *)\n\tcheck_msg=\"custom \"\n\tprefer_resolution_clock_gettime_monotonic=\"$2\"\n\t;;\n  esac\n\n  clock_gettime_lib=\"\"\n  AC_CHECK_LIB(rt, clock_gettime, [clock_gettime_lib=\"-lrt\"])\n\n  save_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $clock_gettime_lib\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     trust_test=\"#error May not be there due to weak linking\"\n  else\n     trust_test=\"\"\n  fi\n\n  AC_CACHE_CHECK([for clock_gettime(CLOCK_MONOTONIC_RAW, _)], erl_cv_clock_gettime_monotonic_raw,\n  [\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime(CLOCK_MONOTONIC_RAW, &ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_monotonic_raw=yes,\n\t\t      erl_cv_clock_gettime_monotonic_raw=no)\n  ])\n\n  AC_CACHE_CHECK([for clock_gettime() with ${check_msg}monotonic clock type], erl_cv_clock_gettime_monotonic_$1,\n  [\n     for clock_type in $prefer_resolution_clock_gettime_monotonic $default_resolution_clock_gettime_monotonic $high_resolution_clock_gettime_monotonic $low_resolution_clock_gettime_monotonic; do\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime($clock_type,&ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_monotonic_$1=$clock_type,\n\t\t      erl_cv_clock_gettime_monotonic_$1=no)\n       test $erl_cv_clock_gettime_monotonic_$1 = no || break\n     done\n  ])\n\n  LIBS=\"$save_LIBS\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     check_for_clock_getres=\n  else\n     check_for_clock_getres=clock_getres\n  fi\n\n  AC_CHECK_FUNCS([$check_for_clock_getres clock_get_attributes gethrtime])\n  \n  AC_CACHE_CHECK([for mach clock_get_time() with monotonic clock type], erl_cv_mach_clock_get_time_monotonic,\n  [\n     AC_TRY_COMPILE([\n#include <mach/clock.h>\n#include <mach/mach.h>\n\t\t\t],\n\t \t\t[\n    kern_return_t res;\n    clock_serv_t clk_srv;\n    mach_timespec_t time_spec;\n\n    host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &clk_srv);\n    res = clock_get_time(clk_srv, &time_spec);\n    mach_port_deallocate(mach_task_self(), clk_srv);\n    \t\t\t],\n    \t\t\terl_cv_mach_clock_get_time_monotonic=yes,\n\t\t\terl_cv_mach_clock_get_time_monotonic=no)\n  ])\n  \n  erl_corrected_monotonic_clock=no\n  case $erl_cv_clock_gettime_monotonic_$1-$ac_cv_func_gethrtime-$erl_cv_mach_clock_get_time_monotonic-$host_os in\n    *-*-*-win32)\n      erl_monotonic_clock_func=WindowsAPI\n      ;;\n    CLOCK_*-*-*-linux*)\n      case $erl_cv_clock_gettime_monotonic_$1-$erl_cv_clock_gettime_monotonic_raw in\n        CLOCK_BOOTTIME-yes|CLOCK_MONOTONIC-yes)\n\t  erl_corrected_monotonic_clock=yes\n\t  ;;\n\t*)\n\t  # We don't trust CLOCK_MONOTONIC to be NTP\n\t  # adjusted on linux systems that do not have\n\t  # CLOCK_MONOTONIC_RAW (although it seems to\n\t  # be...)\n\t  ;;\n      esac\n      erl_monotonic_clock_func=clock_gettime\n      ;;\n    no-no-no-linux*)\n      erl_monotonic_clock_func=times\n      ;;\n    CLOCK_*-*-*-*)\n      erl_monotonic_clock_func=clock_gettime\n      ;;\n    no-yes-*-*)\n      erl_monotonic_clock_func=gethrtime\n      ;;\n    no-no-yes-*)\n      erl_monotonic_clock_func=mach_clock_get_time\n      ;;\n    no-no-no-*)\n      erl_monotonic_clock_func=none\n      ;;\n  esac\n\n  erl_monotonic_clock_low_resolution=no\n  erl_monotonic_clock_lib=\n  erl_monotonic_clock_id=\n  case $erl_monotonic_clock_func in\n    clock_gettime)\n      erl_monotonic_clock_id=$erl_cv_clock_gettime_monotonic_$1\n      for low_res_id in $low_resolution_clock_gettime_monotonic; do\n      \t  if test $erl_monotonic_clock_id = $low_res_id; then\n\t    erl_monotonic_clock_low_resolution=yes\n\t    break\n\t  fi\n      done\n      erl_monotonic_clock_lib=$clock_gettime_lib\n      ;;\n    mach_clock_get_time)\n      erl_monotonic_clock_id=SYSTEM_CLOCK\n      ;;\n    times)\n      erl_monotonic_clock_low_resolution=yes\n      ;;\n    *)\n      ;;\n  esac\n \n])\n\nAC_DEFUN(ERL_WALL_CLOCK,\n[\n  default_resolution_clock_gettime_wall=\"CLOCK_REALTIME\"\n  low_resolution_clock_gettime_wall=\"CLOCK_REALTIME_COARSE CLOCK_REALTIME_FAST\"\n  high_resolution_clock_gettime_wall=\"CLOCK_REALTIME_PRECISE\"\n\n  case \"$1\" in\n    high_resolution)\n\tcheck_msg=\"high resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$high_resolution_clock_gettime_wall\"\n\t;;\n    low_resolution)\n\tcheck_msg=\"low resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$low_resolution_clock_gettime_wall\"\n\t;;\n    custom_resolution)\n\tcheck_msg=\"custom resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$2\"\n\t;;\n    *)\n\tcheck_msg=\"\"\n\tprefer_resolution_clock_gettime_wall=\n\t;;\n  esac\n\n  clock_gettime_lib=\"\"\n  AC_CHECK_LIB(rt, clock_gettime, [clock_gettime_lib=\"-lrt\"])\n\n  save_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $clock_gettime_lib\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     trust_test=\"#error May not be there due to weak linking\"\n  else\n     trust_test=\"\"\n  fi\n\n  AC_CACHE_CHECK([for clock_gettime() with ${check_msg}wall clock type], erl_cv_clock_gettime_wall_$1,\n  [\n     for clock_type in $prefer_resolution_clock_gettime_wall $default_resolution_clock_gettime_wall $high_resolution_clock_gettime_wall $low_resolution_clock_gettime_wall; do\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime($clock_type,&ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_wall_$1=$clock_type,\n\t\t      erl_cv_clock_gettime_wall_$1=no)\n       test $erl_cv_clock_gettime_wall_$1 = no || break\n     done\n  ])\n\n  LIBS=\"$save_LIBS\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     check_for_clock_getres=\n  else\n     check_for_clock_getres=clock_getres\n  fi\n\n  AC_CHECK_FUNCS([$check_for_clock_getres clock_get_attributes gettimeofday])\n  \n  AC_CACHE_CHECK([for mach clock_get_time() with wall clock type], erl_cv_mach_clock_get_time_wall,\n  [\n     AC_TRY_COMPILE([\n#include <mach/clock.h>\n#include <mach/mach.h>\n\t\t\t],\n\t \t\t[\n    kern_return_t res;\n    clock_serv_t clk_srv;\n    mach_timespec_t time_spec;\n\n    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &clk_srv);\n    res = clock_get_time(clk_srv, &time_spec);\n    mach_port_deallocate(mach_task_self(), clk_srv);\n    \t\t\t],\n    \t\t\terl_cv_mach_clock_get_time_wall=yes,\n\t\t\terl_cv_mach_clock_get_time_wall=no)\n  ])\n\n  erl_wall_clock_lib=\n  erl_wall_clock_low_resolution=no\n  erl_wall_clock_id=\n  case $1-$erl_cv_clock_gettime_wall_$1-$erl_cv_mach_clock_get_time_wall-$ac_cv_func_gettimeofday-$host_os in\n    *-*-*-*-win32)\n      erl_wall_clock_func=WindowsAPI\n      erl_wall_clock_low_resolution=yes\n      ;;\n    high_resolution-no-yes-*-*)\n      erl_wall_clock_func=mach_clock_get_time\n      erl_wall_clock_id=CALENDAR_CLOCK\n      ;;\n    *-CLOCK_*-*-*-*)\n      erl_wall_clock_func=clock_gettime\n      erl_wall_clock_lib=$clock_gettime_lib\n      erl_wall_clock_id=$erl_cv_clock_gettime_wall_$1\n      for low_res_id in $low_resolution_clock_gettime_wall; do\n      \t  if test $erl_wall_clock_id = $low_res_id; then\n\t    erl_wall_clock_low_resolution=yes\n\t    break\n\t  fi\n      done\n      ;;\n    *-no-*-yes-*)\n      erl_wall_clock_func=gettimeofday\n      ;;\n    *)\n      erl_wall_clock_func=none\n      ;;\n  esac\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_CHECK_THR_LIB\ndnl\ndnl This macro may be used by any OTP application.\ndnl\ndnl LM_CHECK_THR_LIB sets THR_LIBS, THR_DEFS, and THR_LIB_NAME. It also\ndnl checks for some pthread headers which will appear in DEFS or config.h.\ndnl\n\nAC_DEFUN(LM_CHECK_THR_LIB,\n[\n\nNEED_NPTL_PTHREAD_H=no\n\ndnl win32?\nAC_MSG_CHECKING([for native win32 threads])\nif test \"X$host_os\" = \"Xwin32\"; then\n    AC_MSG_RESULT(yes)\n    THR_DEFS=\"-DWIN32_THREADS\"\n    THR_LIBS=\n    THR_LIB_NAME=win32_threads\n    THR_LIB_TYPE=win32_threads\nelse\n    AC_MSG_RESULT(no)\n    THR_DEFS=\n    THR_LIBS=\n    THR_LIB_NAME=\n    THR_LIB_TYPE=posix_unknown\n\ndnl Try to find POSIX threads\n\ndnl The usual pthread lib...\n    AC_CHECK_LIB(pthread, pthread_create, THR_LIBS=\"-lpthread\")\n\ndnl Very old versions of FreeBSD have pthreads in special c library, c_r...\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_CHECK_LIB(c_r, pthread_create, THR_LIBS=\"-lc_r\")\n    fi\n\ndnl QNX has pthreads in standard C library\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_CHECK_FUNC(pthread_create, THR_LIBS=\"none_needed\")\n    fi\n\ndnl On ofs1 the '-pthread' switch should be used\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_MSG_CHECKING([if the '-pthread' switch can be used])\n\tsaved_cflags=$CFLAGS\n\tCFLAGS=\"$CFLAGS -pthread\"\n\tAC_TRY_LINK([#include <pthread.h>],\n\t\t    pthread_create((void*)0,(void*)0,(void*)0,(void*)0);,\n\t\t    [THR_DEFS=\"-pthread\"\n\t\t     THR_LIBS=\"-pthread\"])\n\tCFLAGS=$saved_cflags\n\tif test \"x$THR_LIBS\" != \"x\"; then\n\t    AC_MSG_RESULT(yes)\n\telse\n\t    AC_MSG_RESULT(no)\n\tfi\n    fi\n\n    if test \"x$THR_LIBS\" != \"x\"; then\n\tTHR_DEFS=\"$THR_DEFS -D_THREAD_SAFE -D_REENTRANT -DPOSIX_THREADS\"\n\tTHR_LIB_NAME=pthread\n\tif test \"x$THR_LIBS\" = \"xnone_needed\"; then\n\t    THR_LIBS=\n\tfi\n\tcase $host_os in\n\t    solaris*)\n\t\tTHR_DEFS=\"$THR_DEFS -D_POSIX_PTHREAD_SEMANTICS\" ;;\n\t    linux*)\n\t\tTHR_DEFS=\"$THR_DEFS -D_POSIX_THREAD_SAFE_FUNCTIONS\"\n\n\t\tLM_CHECK_GETCONF\n\t\tAC_MSG_CHECKING(for Native POSIX Thread Library)\n\t\tlibpthr_vsn=`$GETCONF GNU_LIBPTHREAD_VERSION 2>/dev/null`\n\t\tif test $? -eq 0; then\n\t\t    case \"$libpthr_vsn\" in\n\t\t\t*nptl*|*NPTL*) nptl=yes;;\n\t\t\t*) nptl=no;;\n\t\t    esac\n\t\telif test \"$cross_compiling\" = \"yes\"; then\n\t\t    case \"$erl_xcomp_linux_nptl\" in\n\t\t\t\"\") nptl=cross;;\n\t\t\tyes|no) nptl=$erl_xcomp_linux_nptl;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_nptl value: $erl_xcomp_linux_nptl]);;\n\t\t    esac\n\t\telse\n\t\t    nptl=no\n\t\tfi\n\t\tAC_MSG_RESULT($nptl)\n\t\tif test $nptl = cross; then\n\t\t    nptl=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $nptl = yes; then\n\t\t    THR_LIB_TYPE=posix_nptl\n\t\t    need_nptl_incldir=no\n\t\t    AC_CHECK_HEADER(nptl/pthread.h,\n\t\t\t\t    [need_nptl_incldir=yes\n\t\t\t\t     NEED_NPTL_PTHREAD_H=yes])\n\t\t    if test $need_nptl_incldir = yes; then\n\t\t\t# Ahh...\n\t\t\tnptl_path=\"$C_INCLUDE_PATH:$CPATH\"\n\t\t\tif test X$cross_compiling != Xyes; then\n\t\t\t    nptl_path=\"$nptl_path:/usr/local/include:/usr/include\"\n\t\t\telse\n\t\t\t    IROOT=\"$erl_xcomp_isysroot\"\n\t\t\t    test \"$IROOT\" != \"\" || IROOT=\"$erl_xcomp_sysroot\"\n\t\t\t    test \"$IROOT\" != \"\" || AC_MSG_ERROR([Don't know where to search for includes! Please set erl_xcomp_isysroot])\n\t\t\t    nptl_path=\"$nptl_path:$IROOT/usr/local/include:$IROOT/usr/include\"\n\t\t\tfi\n\t\t\tnptl_ws_path=\n\t\t\tsave_ifs=\"$IFS\"; IFS=\":\"\n\t\t\tfor dir in $nptl_path; do\n\t\t\t    if test \"x$dir\" != \"x\"; then\n\t\t\t\tnptl_ws_path=\"$nptl_ws_path $dir\"\n\t\t\t    fi\n\t\t\tdone\n\t\t\tIFS=$save_ifs\n\t\t\tnptl_incldir=\n\t\t\tfor dir in $nptl_ws_path; do\n\t\t            AC_CHECK_HEADER($dir/nptl/pthread.h,\n\t\t\t\t\t    nptl_incldir=$dir/nptl)\n\t\t\t    if test \"x$nptl_incldir\" != \"x\"; then\n\t\t\t\tTHR_DEFS=\"$THR_DEFS -isystem $nptl_incldir\"\n\t\t\t\tbreak\n\t\t\t    fi\n\t\t\tdone\n\t\t\tif test \"x$nptl_incldir\" = \"x\"; then\n\t\t\t    AC_MSG_ERROR(Failed to locate nptl system include directory)\n\t\t\tfi\n\t\t    fi\n\t\tfi\n\t\t;;\n\t    *) ;;\n\tesac\n\n\tdnl We sometimes need THR_DEFS in order to find certain headers\n\tdnl (at least for pthread.h on osf1).\n\tsaved_cppflags=$CPPFLAGS\n\tCPPFLAGS=\"$CPPFLAGS $THR_DEFS\"\n\n\tdnl\n\tdnl Check for headers\n\tdnl\n\n\tAC_CHECK_HEADER(pthread.h,\n\t\t\tAC_DEFINE(HAVE_PTHREAD_H, 1, \\\n[Define if you have the <pthread.h> header file.]))\n\n\tdnl Some Linuxes have <pthread/mit/pthread.h> instead of <pthread.h>\n\tAC_CHECK_HEADER(pthread/mit/pthread.h, \\\n\t\t\tAC_DEFINE(HAVE_MIT_PTHREAD_H, 1, \\\n[Define if the pthread.h header file is in pthread/mit directory.]))\n\n\tdnl restore CPPFLAGS\n\tCPPFLAGS=$saved_cppflags\n\n    fi\nfi\n\n])\n\nAC_DEFUN(ERL_INTERNAL_LIBS,\n[\n\nERTS_INTERNAL_X_LIBS=\n\nAC_CHECK_LIB(kstat, kstat_open,\n[AC_DEFINE(HAVE_KSTAT, 1, [Define if you have kstat])\nERTS_INTERNAL_X_LIBS=\"$ERTS_INTERNAL_X_LIBS -lkstat\"])\n\nAC_SUBST(ERTS_INTERNAL_X_LIBS)\n\n])\n\nAC_DEFUN(ETHR_CHK_GCC_ATOMIC_OP__,\n[\n    # $1 - atomic_op\n\n    for atomic_bit_size in 32 64 128; do\n\tcase $atomic_bit_size in\n\t    32) gcc_atomic_type=\"$gcc_atomic_type32\";;\n\t    64) gcc_atomic_type=\"$gcc_atomic_type64\";;\n\t    128) gcc_atomic_type=\"$gcc_atomic_type128\";;\n\tesac\n\tgcc_atomic_lockfree=\"int x[[(2*__atomic_always_lock_free(sizeof($gcc_atomic_type), 0))-1]]\"\n\tcase $1 in\n\t    __sync_add_and_fetch | __sync_fetch_and_and | __sync_fetch_and_or)\n\t\tatomic_call=\"volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0);\"\n\t\t;;\n\t    __sync_val_compare_and_swap)\n\t\tatomic_call=\"volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0, ($gcc_atomic_type) 0);\"\n\t\t;;\n\t    __atomic_store_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELAXED); $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELEASE);\"\n\t\t;;\n\t    __atomic_load_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, __ATOMIC_RELAXED); res = $1(&var, __ATOMIC_ACQUIRE);\"\n\t\t;;\n\t    __atomic_add_fetch| __atomic_fetch_and | __atomic_fetch_or)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELAXED); res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_ACQUIRE); res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELEASE);\"\n\t\t;;\n\t    __atomic_compare_exchange_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type val; int res = $1(&var, &val, ($gcc_atomic_type) 0, 0, __ATOMIC_RELAXED, __ATOMIC_RELAXED); res = $1(&var, &val, ($gcc_atomic_type) 0, 0, __ATOMIC_ACQUIRE, __ATOMIC_ACQUIRE);\"\n\t\t;;\n\t    *)\n\t\tAC_MSG_ERROR([Internal error: missing implementation for $1])\n\t\t;;\n\tesac\n\teval atomic${atomic_bit_size}_call=\\\"$atomic_call\\\"\n    done\n    \n    AC_CACHE_CHECK([for 32-bit $1()], ethr_cv_32bit_$1,\n\t\t   [\n\t\t       ethr_cv_32bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic32_call], [ethr_cv_32bit_$1=yes])\n\t\t   ])\n    AC_CACHE_CHECK([for 64-bit $1()], ethr_cv_64bit_$1,\n\t\t   [\n\t\t       ethr_cv_64bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic64_call], [ethr_cv_64bit_$1=yes])\n\t\t   ])\n    AC_CACHE_CHECK([for 128-bit $1()], ethr_cv_128bit_$1,\n\t\t   [\n\t\t       ethr_cv_128bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic128_call], [ethr_cv_128bit_$1=yes])\n\t\t   ])\n\n\tcase $ethr_cv_128bit_$1-$ethr_cv_64bit_$1-$ethr_cv_32bit_$1 in\n\t    no-no-no)\n\t\thave_atomic_ops=0;;\n\t    no-no-yes)\n\t\thave_atomic_ops=4;;\n\t    no-yes-no)\n\t\thave_atomic_ops=8;;\n\t    no-yes-yes)\n\t\thave_atomic_ops=12;;\n\t    yes-no-no)\n\t\thave_atomic_ops=16;;\n\t    yes-no-yes)\n\t\thave_atomic_ops=20;;\n\t    yes-yes-no)\n\t\thave_atomic_ops=24;;\n\t    yes-yes-yes)\n\t\thave_atomic_ops=28;;\n\tesac\n\tAC_DEFINE_UNQUOTED([ETHR_HAVE_$1], [$have_atomic_ops], [Define as a bitmask corresponding to the word sizes that $1() can handle on your system])\n])\n\nAC_DEFUN(ETHR_CHK_IF_NOOP,\n[\n   ethr_test_filename=\"chk_if_$1$3_noop_config1test.$$\"\n   cat > \"${ethr_test_filename}.c\" <<EOF\nint\nmy_test(void)\n{\n    $1$2;\n    return 0;\n}\nEOF\n   $CC -O3 $ETHR_DEFS -c \"${ethr_test_filename}.c\" -o \"${ethr_test_filename}1.o\"\n   cat > \"${ethr_test_filename}.c\" <<EOF\nint\nmy_test(void)\n{\n    ;\n    return 0;\n}\nEOF\n   $CC -O3 $ETHR_DEFS -c \"${ethr_test_filename}.c\" -o \"${ethr_test_filename}2.o\"\n   if diff \"${ethr_test_filename}1.o\" \"${ethr_test_filename}2.o\" >/dev/null 2>&1; then\n      ethr_$1$3_noop=yes\n   else\n      ethr_$1$3_noop=no\n   fi\n   rm -f \"${ethr_test_filename}.c\" \"${ethr_test_filename}1.o\"  \"${ethr_test_filename}2.o\" \n])\n\nAC_DEFUN(ETHR_CHK_GCC_ATOMIC_OPS,\n[\n    AC_CHECK_SIZEOF(short)\n    AC_CHECK_SIZEOF(int)\n    AC_CHECK_SIZEOF(long)\n    AC_CHECK_SIZEOF(long long)\n    AC_CHECK_SIZEOF(__int128_t)\n\n    if test \"$ac_cv_sizeof_short\" = \"4\"; then\n\tgcc_atomic_type32=\"short\"\n    elif test \"$ac_cv_sizeof_int\" = \"4\"; then\n\tgcc_atomic_type32=\"int\"\n    elif test \"$ac_cv_sizeof_long\" = \"4\"; then\n\tgcc_atomic_type32=\"long\"\n    else\n\tAC_MSG_ERROR([No 32-bit type found])\n    fi\n\n    if test \"$ac_cv_sizeof_int\" = \"8\"; then\n\tgcc_atomic_type64=\"int\"\n    elif test \"$ac_cv_sizeof_long\" = \"8\"; then\n\tgcc_atomic_type64=\"long\"\n    elif test \"$ac_cv_sizeof_long_long\" = \"8\"; then\n\tgcc_atomic_type64=\"long long\"\n    else\n\tAC_MSG_ERROR([No 64-bit type found])\n    fi\n\n    if test \"$ac_cv_sizeof___int128_t\" = \"16\"; then\n\tgcc_atomic_type128=\"__int128_t\"\n    else\n\tgcc_atomic_type128=\"#error \"\t\n    fi\n    AC_CACHE_CHECK([for a working __sync_synchronize()], ethr_cv___sync_synchronize,\n\t\t   [\n\t\t       ethr_cv___sync_synchronize=no\n\t\t       AC_TRY_LINK([],\n\t\t\t\t   [ __sync_synchronize(); ],\n\t\t\t\t   [ethr_cv___sync_synchronize=yes])\n\t\t       if test $ethr_cv___sync_synchronize = yes; then\n\t\t\t   #\n\t\t\t   # Old gcc versions on at least x86 have a buggy\n\t\t\t   # __sync_synchronize() which does not emit a\n\t\t\t   # memory barrier. We try to detect this by\n\t\t\t   # compiling to assembly with and without\n\t\t\t   # __sync_synchronize() and compare the results.\n\t\t\t   #\n\t\t\t   ETHR_CHK_IF_NOOP(__sync_synchronize, [()], [])\n\t\t\t   if test $ethr___sync_synchronize_noop = yes; then\n\t\t\t      # Got a buggy implementation of\n\t\t\t      # __sync_synchronize...\n\t\t\t      ethr_cv___sync_synchronize=\"no; buggy implementation\"\n\t\t\t   fi\n\t\t       fi\n\t\t   ])\n\n    if test \"$ethr_cv___sync_synchronize\" = \"yes\"; then\n\thave_sync_synchronize_value=\"~0\"\n    else\n\thave_sync_synchronize_value=\"0\"\n    fi\n    AC_DEFINE_UNQUOTED([ETHR_HAVE___sync_synchronize], [$have_sync_synchronize_value], [Define as a bitmask corresponding to the word sizes that __sync_synchronize() can handle on your system])\n\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_add_and_fetch)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_fetch_and_and)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_fetch_and_or)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_val_compare_and_swap)\n\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_store_n)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_load_n)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_add_fetch)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_fetch_and)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_fetch_or)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_compare_exchange_n)\n\n    ethr_have_gcc_native_atomics=no\n    ethr_arm_dbm_instr_val=0\n    case \"$GCC-$host_cpu\" in\n\tyes-arm*)\n\t    AC_CACHE_CHECK([for ARM DMB instruction], ethr_cv_arm_dbm_instr,\n\t\t\t   [\n\t\t\t\tethr_cv_arm_dbm_instr=no\n\t\t\t\tAC_TRY_LINK([],\n\t\t\t\t\t    [\n\t\t\t\t\t\t__asm__ __volatile__(\"dmb sy\" : : : \"memory\");\n\t\t\t\t\t\t__asm__ __volatile__(\"dmb st\" : : : \"memory\");\n\t\t\t\t\t    ],\n\t\t\t\t\t    [ethr_cv_arm_dbm_instr=yes])\n\t\t\t   ])\n\t    if test $ethr_cv_arm_dbm_instr = yes; then\n\t\tethr_arm_dbm_instr_val=1\n\t\ttest $ethr_cv_64bit___atomic_compare_exchange_n = yes &&\n\t\t    ethr_have_gcc_native_atomics=yes\n\t    fi;;\n\t*)\n\t    ;;\n    esac\n    AC_DEFINE_UNQUOTED([ETHR_HAVE_GCC_ASM_ARM_DMB_INSTRUCTION], [$ethr_arm_dbm_instr_val], [Define as a boolean indicating whether you have a gcc compatible compiler capable of generating the ARM DMB instruction, and are compiling for an ARM processor with ARM DMB instruction support, or not])\n    test $ethr_cv_32bit___sync_val_compare_and_swap = yes &&\n    \tethr_have_gcc_native_atomics=yes\n    test $ethr_cv_64bit___sync_val_compare_and_swap = yes &&\n    \tethr_have_gcc_native_atomics=yes\n    if test \"$ethr_cv___sync_synchronize\" = \"yes\"; then\n    \ttest $ethr_cv_64bit___atomic_compare_exchange_n = yes &&\n    \t    ethr_have_gcc_native_atomics=yes\n    \ttest $ethr_cv_32bit___atomic_compare_exchange_n = yes &&\n    \t    ethr_have_gcc_native_atomics=yes\n    fi\n    ethr_have_gcc_atomic_builtins=0\n    if test $ethr_have_gcc_native_atomics = yes; then\n       ethr_native_atomic_implementation=gcc_sync\n       test $ethr_cv_32bit___atomic_compare_exchange_n = yes && ethr_have_gcc_atomic_builtins=1\n       test $ethr_cv_64bit___atomic_compare_exchange_n = yes && ethr_have_gcc_atomic_builtins=1\n       test $ethr_have_gcc_atomic_builtins = 1 && ethr_native_atomic_implementation=gcc_atomic_sync\n    fi\n    AC_DEFINE_UNQUOTED([ETHR_HAVE_GCC___ATOMIC_BUILTINS], [$ethr_have_gcc_atomic_builtins], [Define as a boolean indicating whether you have a gcc __atomic builtins or not])\n    test $ethr_have_gcc_native_atomics = yes && ethr_have_native_atomics=yes\n])\n\nAC_DEFUN(ETHR_CHK_INTERLOCKED,\n[\n    ilckd=\"$1\"\n    AC_MSG_CHECKING([for ${ilckd}()])\n    case \"$2\" in\n\t\"1\") ilckd_call=\"${ilckd}(var);\";;\n\t\"2\") ilckd_call=\"${ilckd}(var, ($3) 0);\";;\n\t\"3\") ilckd_call=\"${ilckd}(var, ($3) 0, ($3) 0);\";;\n\t\"4\") ilckd_call=\"${ilckd}(var, ($3) 0, ($3) 0, arr);\";;\n    esac\n    have_interlocked_op=no\n    AC_TRY_LINK(\n\t[\n\t#define WIN32_LEAN_AND_MEAN\n\t#include <windows.h>\n\t#include <intrin.h>\n\t],\n\t[\n\t    volatile $3 *var;\n\t    volatile $3 arr[2];\n\n\t    $ilckd_call\n\t    return 0;\n\t],\n\t[have_interlocked_op=yes])\n    test $have_interlocked_op = yes && $4\n    AC_MSG_RESULT([$have_interlocked_op])\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl ERL_FIND_ETHR_LIB\ndnl\ndnl NOTE! This macro may be changed at any time! Should *only* be used by\ndnl       ERTS!\ndnl\ndnl Find a thread library to use. Sets ETHR_LIBS to libraries to link\ndnl with, ETHR_X_LIBS to extra libraries to link with (same as ETHR_LIBS\ndnl except that the ethread lib itself is not included), ETHR_DEFS to\ndnl defines to compile with, ETHR_THR_LIB_BASE to the name of the\ndnl thread library which the ethread library is based on, and ETHR_LIB_NAME\ndnl to the name of the library where the ethread implementation is located.\ndnl  ERL_FIND_ETHR_LIB currently searches for 'pthreads', and\ndnl 'win32_threads'. If no thread library was found ETHR_LIBS, ETHR_X_LIBS,\ndnl ETHR_DEFS, ETHR_THR_LIB_BASE, and ETHR_LIB_NAME are all set to the\ndnl empty string.\ndnl\n\nAC_DEFUN(ERL_FIND_ETHR_LIB,\n[\n\nAC_ARG_ENABLE(native-ethr-impls,\n\t      AS_HELP_STRING([--disable-native-ethr-impls],\n                             [disable native ethread implementations]),\n[ case \"$enableval\" in\n    no) disable_native_ethr_impls=yes ;;\n    *)  disable_native_ethr_impls=no ;;\n  esac ], disable_native_ethr_impls=no)\n\ntest \"X$disable_native_ethr_impls\" = \"Xyes\" &&\n  AC_DEFINE(ETHR_DISABLE_NATIVE_IMPLS, 1, [Define if you want to disable native ethread implementations])\n\nAC_ARG_ENABLE(x86-out-of-order,\n\t      AS_HELP_STRING([--enable-x86-out-of-order],\n                             [enable x86/x84_64 out of order support (default disabled)]))\n\nAC_ARG_ENABLE(prefer-gcc-native-ethr-impls,\n\t      AS_HELP_STRING([--enable-prefer-gcc-native-ethr-impls],\n\t\t\t     [prefer gcc native ethread implementations]),\n[ case \"$enableval\" in\n    yes) enable_prefer_gcc_native_ethr_impls=yes ;;\n    *)  enable_prefer_gcc_native_ethr_impls=no ;;\n  esac ], enable_prefer_gcc_native_ethr_impls=no)\n\ntest $enable_prefer_gcc_native_ethr_impls = yes &&\n  AC_DEFINE(ETHR_PREFER_GCC_NATIVE_IMPLS, 1, [Define if you prefer gcc native ethread implementations])\n\nAC_ARG_ENABLE(trust-gcc-atomic-builtins-memory-barriers,\n\t      AS_HELP_STRING([--enable-trust-gcc-atomic-builtins-memory-barriers],\n\t\t\t     [trust gcc atomic builtins memory barriers]),\n[ case \"$enableval\" in\n    yes) trust_gcc_atomic_builtins_mbs=1 ;;\n    *) trust_gcc_atomic_builtins_mbs=0 ;;\n  esac ], trust_gcc_atomic_builtins_mbs=0)\n\nAC_DEFINE_UNQUOTED(ETHR_TRUST_GCC_ATOMIC_BUILTINS_MEMORY_BARRIERS, [$trust_gcc_atomic_builtins_mbs], [Define as a boolean indicating whether you trust gcc's __atomic_* builtins memory barrier implementations, or not])\n\nAC_ARG_WITH(libatomic_ops,\n\t    AS_HELP_STRING([--with-libatomic_ops=PATH],\n\t\t\t   [specify and prefer usage of libatomic_ops in the ethread library]))\n\nAC_ARG_WITH(with_sparc_memory_order,\n\t    AS_HELP_STRING([--with-sparc-memory-order=TSO|PSO|RMO],\n\t\t\t   [specify sparc memory order (defaults to RMO)]))\n\nLM_CHECK_THR_LIB\nERL_INTERNAL_LIBS\n\nERL_MONOTONIC_CLOCK(try_find_pthread_compatible, CLOCK_HIGHRES CLOCK_MONOTONIC, no)\n\ncase $erl_monotonic_clock_func in\n  clock_gettime)\n    AC_DEFINE(ETHR_HAVE_CLOCK_GETTIME_MONOTONIC, [1], [Define if you have a clock_gettime() with a monotonic clock])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(ETHR_HAVE_MACH_CLOCK_GET_TIME, [1], [Define if you have a mach clock_get_time() with a monotonic clock])\n    ;;\n  gethrtime)\n    AC_DEFINE(ETHR_HAVE_GETHRTIME, [1], [Define if you have a monotonic gethrtime()])\n    ;;\n  *)\n    ;;\nesac\n\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(ETHR_MONOTONIC_CLOCK_ID, [$erl_monotonic_clock_id], [Define to the monotonic clock id to use])\nfi\n\nethr_native_atomic_implementation=none\nethr_have_native_atomics=no\nethr_have_native_spinlock=no\nETHR_THR_LIB_BASE=\"$THR_LIB_NAME\"\nETHR_THR_LIB_BASE_TYPE=\"$THR_LIB_TYPE\"\nETHR_DEFS=\"$THR_DEFS\"\nETHR_X_LIBS=\"$THR_LIBS $ERTS_INTERNAL_X_LIBS $erl_monotonic_clock_lib\"\nETHR_LIBS=\nETHR_LIB_NAME=\n\nethr_modified_default_stack_size=\n\nAC_ARG_WITH(threadnames,\nAS_HELP_STRING([--with-threadnames], [use pthread_setname to set the thread names (default)])\nAS_HELP_STRING([--without-threadnames],\n               [do not set any thread names]),\n[],\n[with_threadnames=yes])\n\ndnl Name of lib where ethread implementation is located\nethr_lib_name=ethread\n\ncase \"$THR_LIB_NAME\" in\n\n    win32_threads)\n\tETHR_THR_LIB_BASE_DIR=win\n\t# * _WIN32_WINNT >= 0x0400 is needed for\n\t#   TryEnterCriticalSection\n\t# * _WIN32_WINNT >= 0x0403 is needed for\n\t#   InitializeCriticalSectionAndSpinCount\n\t# The ethread lib will refuse to build if _WIN32_WINNT < 0x0403.\n\t#\n\t# -D_WIN32_WINNT should have been defined in $CPPFLAGS; fetch it\n\t# and save it in ETHR_DEFS.\n\tfound_win32_winnt=no\n\tfor cppflag in $CPPFLAGS; do\n\t    case $cppflag in\n\t\t-DWINVER*)\n\t\t    ETHR_DEFS=\"$ETHR_DEFS $cppflag\"\n\t\t    ;;\n\t\t-D_WIN32_WINNT*)\n\t\t    ETHR_DEFS=\"$ETHR_DEFS $cppflag\"\n\t\t    found_win32_winnt=yes\n\t\t    ;;\n\t\t*)\n\t\t    ;;\n\t    esac\n        done\n        if test $found_win32_winnt = no; then\n\t    AC_MSG_ERROR([-D_WIN32_WINNT missing in CPPFLAGS])\n        fi\n\n\tAC_DEFINE(ETHR_WIN32_THREADS, 1, [Define if you have win32 threads])\n\n\tif test \"X$disable_native_ethr_impls\" = \"Xyes\"; then\n\t    have_interlocked_op=no\n\t    ethr_have_native_atomics=no\n\telse\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT, 1, [Define if you have _InterlockedDecrement()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement_rel], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT_REL, 1, [Define if you have _InterlockedDecrement_rel()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT, 1, [Define if you have _InterlockedIncrement()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement_acq], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT_ACQ, 1, [Define if you have _InterlockedIncrement_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD, 1, [Define if you have _InterlockedExchangeAdd()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd_acq], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD_ACQ, 1, [Define if you have _InterlockedExchangeAdd_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedAnd], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDAND, 1, [Define if you have _InterlockedAnd()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedOr], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDOR, 1, [Define if you have _InterlockedOr()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchange], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGE, 1, [Define if you have _InterlockedExchange()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE, 1, [Define if you have _InterlockedCompareExchange()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange_acq], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE_ACQ, 1, [Define if you have _InterlockedCompareExchange_acq()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange_rel], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE_REL, 1, [Define if you have _InterlockedCompareExchange_rel()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement64], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT64, 1, [Define if you have _InterlockedDecrement64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement64_rel], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT64_REL, 1, [Define if you have _InterlockedDecrement64_rel()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement64], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT64, 1, [Define if you have _InterlockedIncrement64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement64_acq], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT64_ACQ, 1, [Define if you have _InterlockedIncrement64_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD64, 1, [Define if you have _InterlockedExchangeAdd64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd64_acq], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD64_ACQ, 1, [Define if you have _InterlockedExchangeAdd64_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedAnd64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDAND64, 1, [Define if you have _InterlockedAnd64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedOr64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDOR64, 1, [Define if you have _InterlockedOr64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchange64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGE64, 1, [Define if you have _InterlockedExchange64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64, 1, [Define if you have _InterlockedCompareExchange64()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64_acq], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64_ACQ, 1, [Define if you have _InterlockedCompareExchange64_acq()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64_rel], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64_REL, 1, [Define if you have _InterlockedCompareExchange64_rel()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange128], [4], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE128, 1, [Define if you have _InterlockedCompareExchange128()]))\n\tfi\n\tif test \"$ethr_have_native_atomics\" = \"yes\"; then\n\t   ethr_native_atomic_implementation=windows\n\t   ethr_have_native_spinlock=yes\n\tfi\n\t;;\n\n    pthread)\n\tETHR_THR_LIB_BASE_DIR=pthread\n\tAC_DEFINE(ETHR_PTHREADS, 1, [Define if you have pthreads])\n\tcase $host_os in\n\t    openbsd*)\n\t\t# The default stack size is insufficient for our needs\n\t\t# on OpenBSD. We increase it to 256 kilo words.\n\t\tethr_modified_default_stack_size=256;;\n\t    linux*)\n\t\tETHR_DEFS=\"$ETHR_DEFS -D_GNU_SOURCE\"\n\n\t\tif test\tX$cross_compiling = Xyes; then\n\t\t    case X$erl_xcomp_linux_usable_sigusrx in\n\t\t\tX) usable_sigusrx=cross;;\n\t\t\tXyes|Xno) usable_sigusrx=$erl_xcomp_linux_usable_sigusrx;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_usable_sigusrx value: $erl_xcomp_linux_usable_sigusrx]);;\n\t\t    esac\n\t\t    case X$erl_xcomp_linux_usable_sigaltstack in\n\t\t\tX) usable_sigaltstack=cross;;\n\t\t\tXyes|Xno) usable_sigaltstack=$erl_xcomp_linux_usable_sigaltstack;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_usable_sigaltstack value: $erl_xcomp_linux_usable_sigaltstack]);;\n\t\t    esac\n\t\telse\n\t\t    # FIXME: Test for actual problems instead of kernel versions\n\t\t    linux_kernel_vsn_=`uname -r`\n\t\t    case $linux_kernel_vsn_ in\n\t\t\t[[0-1]].*|2.[[0-1]]|2.[[0-1]].*)\n\t\t\t    usable_sigusrx=no\n\t\t\t    usable_sigaltstack=no;;\n\t\t\t2.[[2-3]]|2.[[2-3]].*)\n\t\t\t    usable_sigusrx=yes\n\t\t\t    usable_sigaltstack=no;;\n\t\t    \t*)\n\t\t\t    usable_sigusrx=yes\n\t\t\t    usable_sigaltstack=yes;;\n\t\t    esac\n\t\tfi\n\n\t\tAC_MSG_CHECKING(if SIGUSR1 and SIGUSR2 can be used)\n\t\tAC_MSG_RESULT($usable_sigusrx)\n\t\tif test $usable_sigusrx = cross; then\n\t\t    usable_sigusrx=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $usable_sigusrx = no; then\n\t\t    ETHR_DEFS=\"$ETHR_DEFS -DETHR_UNUSABLE_SIGUSRX\"\n\t\tfi\n\n\t\tAC_MSG_CHECKING(if sigaltstack can be used)\n\t\tAC_MSG_RESULT($usable_sigaltstack)\n\t\tif test $usable_sigaltstack = cross; then\n\t\t    usable_sigaltstack=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $usable_sigaltstack = no; then\n\t\t    ETHR_DEFS=\"$ETHR_DEFS -DETHR_UNUSABLE_SIGALTSTACK\"\n\t\tfi\n\t\t;;\n\t    *) ;;\n\tesac\n\n\tdnl We sometimes need ETHR_DEFS in order to find certain headers\n\tdnl (at least for pthread.h on osf1).\n\tsaved_cppflags=\"$CPPFLAGS\"\n\tCPPFLAGS=\"$CPPFLAGS $ETHR_DEFS\"\n\n\tdnl We need the thread library in order to find some functions\n\tsaved_libs=\"$LIBS\"\n\tLIBS=\"$LIBS $ETHR_X_LIBS\"\n\n\tdnl\n\tdnl Check for headers\n\tdnl\n\tAC_CHECK_HEADER(pthread.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_H, 1, \\\n[Define if you have the <pthread.h> header file.]))\n\n\tdnl Some Linuxes have <pthread/mit/pthread.h> instead of <pthread.h>\n\tAC_CHECK_HEADER(pthread/mit/pthread.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_MIT_PTHREAD_H, 1, \\\n[Define if the pthread.h header file is in pthread/mit directory.]))\n\n\tif test $NEED_NPTL_PTHREAD_H = yes; then\n\t    AC_DEFINE(ETHR_NEED_NPTL_PTHREAD_H, 1, \\\n[Define if you need the <nptl/pthread.h> header file.])\n\tfi\n\n\tAC_CHECK_HEADER(sched.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_SCHED_H, 1, \\\n[Define if you have the <sched.h> header file.]))\n\n\tAC_CHECK_HEADER(sys/time.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_SYS_TIME_H, 1, \\\n[Define if you have the <sys/time.h> header file.]))\n\n\tAC_TRY_COMPILE([#include <time.h>\n\t\t\t#include <sys/time.h>], \n\t\t\t[struct timeval *tv; return 0;],\n\t\t\tAC_DEFINE(ETHR_TIME_WITH_SYS_TIME, 1, \\\n[Define if you can safely include both <sys/time.h> and <time.h>.]))\n\n\tAC_MSG_CHECKING([for usable PTHREAD_STACK_MIN])\n\tpthread_stack_min=no\n\tAC_TRY_COMPILE([\n#include <limits.h>\n#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n#include <nptl/pthread.h>\n#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n#include <pthread/mit/pthread.h>\n#elif defined(ETHR_HAVE_PTHREAD_H)\n#include <pthread.h>\n#endif\n\t\t\t], \n\t\t\t[return PTHREAD_STACK_MIN;],\n\t\t\t[pthread_stack_min=yes])\n\n\tAC_MSG_RESULT([$pthread_stack_min])\n\ttest $pthread_stack_min != yes || {\n\t     AC_DEFINE(ETHR_HAVE_USABLE_PTHREAD_STACK_MIN, 1, [Define if you can use PTHREAD_STACK_MIN])\n\t}\n\n\tdnl\n\tdnl Check for functions\n\tdnl\n\tAC_CHECK_FUNC(pthread_spin_lock, \\\n\t\t\t[ethr_have_native_spinlock=yes \\\n\t\t\t AC_DEFINE(ETHR_HAVE_PTHREAD_SPIN_LOCK, 1, \\\n[Define if you have the pthread_spin_lock function.])])\n\n\thave_sched_yield=no\n\thave_librt_sched_yield=no\n\tAC_CHECK_FUNC(sched_yield, [have_sched_yield=yes])\n\tif test $have_sched_yield = no; then\n\t    AC_CHECK_LIB(rt, sched_yield,\n\t\t\t [have_librt_sched_yield=yes\n\t\t\t  ETHR_X_LIBS=\"$ETHR_X_LIBS -lrt\"])\n\tfi\n\tif test $have_sched_yield = yes || test $have_librt_sched_yield = yes; then\n\t    AC_DEFINE(ETHR_HAVE_SCHED_YIELD, 1, [Define if you have the sched_yield() function.])\n\t    AC_MSG_CHECKING([whether sched_yield() returns an int])\n\t    sched_yield_ret_int=no\n\t    AC_TRY_LINK([\n\t\t\t\t#ifdef ETHR_HAVE_SCHED_H\n\t\t\t\t#include <sched.h>\n\t\t\t\t#endif\n\t\t\t   ],\n\t\t\t   [int sched_yield();],\n\t\t\t   [sched_yield_ret_int=yes])\n\t    AC_MSG_RESULT([$sched_yield_ret_int])\n\t    if test $sched_yield_ret_int = yes; then\n\t\tAC_DEFINE(ETHR_SCHED_YIELD_RET_INT, 1, [Define if sched_yield() returns an int.])\n\t    fi\n\tfi\n\n\thave_pthread_yield=no\n\tAC_CHECK_FUNC(pthread_yield, [have_pthread_yield=yes])\n\tif test $have_pthread_yield = yes; then\n\t    AC_DEFINE(ETHR_HAVE_PTHREAD_YIELD, 1, [Define if you have the pthread_yield() function.])\n\t    AC_MSG_CHECKING([whether pthread_yield() returns an int])\n\t    pthread_yield_ret_int=no\n\t    AC_TRY_LINK([\n\t\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t\t#include <nptl/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t\t#include <pthread/mit/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t\t#include <pthread.h>\n\t\t\t\t#endif\n\t\t\t   ],\n\t\t\t   [int pthread_yield();],\n\t\t\t   [pthread_yield_ret_int=yes])\n\t    AC_MSG_RESULT([$pthread_yield_ret_int])\n\t    if test $pthread_yield_ret_int = yes; then\n\t\tAC_DEFINE(ETHR_PTHREAD_YIELD_RET_INT, 1, [Define if pthread_yield() returns an int.])\n\t    fi\n\tfi\n\n\thave_pthread_rwlock_init=no\n\tAC_CHECK_FUNC(pthread_rwlock_init, [have_pthread_rwlock_init=yes])\n\tif test $have_pthread_rwlock_init = yes; then\n\n\t    ethr_have_pthread_rwlockattr_setkind_np=no\n\t    AC_CHECK_FUNC(pthread_rwlockattr_setkind_np,\n\t\t\t  [ethr_have_pthread_rwlockattr_setkind_np=yes])\n\n\t    if test $ethr_have_pthread_rwlockattr_setkind_np = yes; then\n\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_RWLOCKATTR_SETKIND_NP, 1, \\\n[Define if you have the pthread_rwlockattr_setkind_np() function.])\n\n\t\tAC_MSG_CHECKING([for PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP])\n\t\tethr_pthread_rwlock_writer_nonrecursive_initializer_np=no\n\t\tAC_TRY_LINK([\n\t\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t\t#include <nptl/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t\t#include <pthread/mit/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t\t#include <pthread.h>\n\t\t\t\t#endif\n\t\t\t    ],\n\t\t\t    [\n\t\t\t\tpthread_rwlockattr_t *attr;\n\t\t\t\treturn pthread_rwlockattr_setkind_np(attr,\n\t\t\t\t    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n\t\t\t    ],\n\t\t\t    [ethr_pthread_rwlock_writer_nonrecursive_initializer_np=yes])\n\t\tAC_MSG_RESULT([$ethr_pthread_rwlock_writer_nonrecursive_initializer_np])\n\t\tif test $ethr_pthread_rwlock_writer_nonrecursive_initializer_np = yes; then\n\t\t    AC_DEFINE(ETHR_HAVE_PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, 1, \\\n[Define if you have the PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP rwlock attribute.])\n\t\tfi\n\t    fi\n\tfi\n\n\tif test \"$force_pthread_rwlocks\" = \"yes\"; then\n\n\t    AC_DEFINE(ETHR_FORCE_PTHREAD_RWLOCK, 1, \\\n[Define if you want to force usage of pthread rwlocks])\n\n\t    if test $have_pthread_rwlock_init = yes; then\n\t\tAC_MSG_WARN([Forced usage of pthread rwlocks. Note that this implementation may suffer from starvation issues.])\n\t    else\n\t\tAC_MSG_ERROR([User forced usage of pthread rwlock, but no such implementation was found])\n\t    fi\n\tfi\n\n\tAC_CHECK_FUNC(pthread_attr_setguardsize, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_ATTR_SETGUARDSIZE, 1, \\\n[Define if you have the pthread_attr_setguardsize function.]))\n\n\tif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n\t  AC_MSG_CHECKING(whether pthread_cond_timedwait() can use the monotonic clock $erl_monotonic_clock_id for timeout)\n\t  pthread_cond_timedwait_monotonic=no\n\t  AC_TRY_LINK([\n\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t#  include <nptl/pthread.h>\n\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t#  include <pthread/mit/pthread.h>\n\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t#  include <pthread.h>\n\t\t\t#endif\n\t\t\t#ifdef ETHR_TIME_WITH_SYS_TIME\n\t\t\t#  include <time.h>\n\t\t\t#  include <sys/time.h>\n\t\t\t#else\n\t\t\t#  ifdef ETHR_HAVE_SYS_TIME_H\n\t\t\t#    include <sys/time.h>\n\t\t\t#  else\n\t\t\t#    include <time.h>\n\t\t\t#  endif\n\t\t\t#endif\n\t\t\t#if defined(ETHR_HAVE_MACH_CLOCK_GET_TIME)\n\t\t\t#  include <mach/clock.h>\n\t\t\t#  include <mach/mach.h>\n\t\t\t#endif\n\t\t\t], \n\t\t\t[\n\t\t\tint res;\n\t\t\tpthread_condattr_t attr;\n\t\t\tpthread_cond_t cond;\n\t\t\tstruct timespec cond_timeout;\n\t\t\tpthread_mutex_t mutex;\n\t\t\tres = pthread_condattr_init(&attr);\n\t\t\tres = pthread_condattr_setclock(&attr, ETHR_MONOTONIC_CLOCK_ID);\n\t\t\tres = pthread_cond_init(&cond, &attr);\n\t\t\tres = pthread_cond_timedwait(&cond, &mutex, &cond_timeout);\n\t\t\t],\n\t\t\t[pthread_cond_timedwait_monotonic=yes])\n\t  AC_MSG_RESULT([$pthread_cond_timedwait_monotonic])\n\t  if test $pthread_cond_timedwait_monotonic = yes; then\n\t    AC_DEFINE(ETHR_HAVE_PTHREAD_COND_TIMEDWAIT_MONOTONIC, [1], [Define if pthread_cond_timedwait() can be used with a monotonic clock])\n\t  fi\n\tfi\n\n\tlinux_futex=no\n\tAC_MSG_CHECKING([for Linux futexes])\n\tAC_TRY_LINK([\n\t\t\t#include <sys/syscall.h>\n\t\t\t#include <unistd.h>\n\t\t\t#include <linux/futex.h>\n\t\t\t#include <sys/time.h>\n\t\t    ],\n\t\t    [\n\t\t\tint i = 1;\n\t\t\tsyscall(__NR_futex, (void *) &i, FUTEX_WAKE, 1,\n\t\t\t\t(void*)0,(void*)0, 0);\n\t\t\tsyscall(__NR_futex, (void *) &i, FUTEX_WAIT, 0,\n\t\t\t\t(void*)0,(void*)0, 0);\n\t\t\treturn 0;\n\t\t    ],\n\t\t    linux_futex=yes)\n\tAC_MSG_RESULT([$linux_futex])\n\ttest $linux_futex = yes && AC_DEFINE(ETHR_HAVE_LINUX_FUTEX, 1, [Define if you have a linux futex implementation.])\n\n\tpthread_setname=no\n\tAC_MSG_CHECKING([for pthread_setname_np])\n\told_CFLAGS=$CFLAGS\n\tCFLAGS=\"$CFLAGS -Werror\"\n\tAC_TRY_LINK([#define __USE_GNU\n                     #include <pthread.h>],\n                    [pthread_setname_np(pthread_self(), \"name\");],\n                    pthread_setname=linux)\n\tAC_TRY_LINK([#define __USE_GNU\n                     #include <pthread.h>],\n                    [pthread_set_name_np(pthread_self(), \"name\");],\n                    pthread_setname=bsd)\n\tAC_TRY_LINK([#define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [pthread_setname_np(\"name\");],\n                    pthread_setname=darwin)\n        AC_MSG_RESULT([$pthread_setname])\n        case $with_threadnames-$pthread_setname in\n             yes-linux) AC_DEFINE(ETHR_HAVE_PTHREAD_SETNAME_NP_2, 1,\n                          [Define if you have linux style pthread_setname_np]);;\n             yes-bsd) AC_DEFINE(ETHR_HAVE_PTHREAD_SET_NAME_NP_2, 1,\n                          [Define if you have bsd style pthread_set_name_np]);;\n             yes-darwin) AC_DEFINE(ETHR_HAVE_PTHREAD_SETNAME_NP_1, 1,\n                          [Define if you have darwin style pthread_setname_np]);;\n             *) ;;\n\tesac\n\n\tpthread_getname=no\n\tAC_MSG_CHECKING([for pthread_getname_np])\n\tAC_TRY_LINK([#define __USE_GNU\n                     #define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [char buff[256]; pthread_getname_np(pthread_self(), buff, 256);],\n                    pthread_getname=linux)\n\tAC_TRY_LINK([#define __USE_GNU\n                     #define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [char buff[256]; pthread_getname_np(pthread_self(), buff);],\n                    pthread_getname=ibm)\n        AC_MSG_RESULT([$pthread_getname])\n        case $pthread_getname in\n             linux) AC_DEFINE(ETHR_HAVE_PTHREAD_GETNAME_NP_3, 1,\n                          [Define if you have linux style pthread_getname_np]);;\n             ibm) AC_DEFINE(ETHR_HAVE_PTHREAD_GETNAME_NP_2, 1,\n                          [Define if you have ibm style pthread_getname_np]);;\n             *) ;;\n\tesac\n\tCFLAGS=$old_CFLAGS\n\n\tif test \"X$disable_native_ethr_impls\" = \"Xyes\"; then\n\t    ethr_have_native_atomics=no\n\telse\n\n\t    ETHR_CHK_GCC_ATOMIC_OPS([])\n\n\t    AC_MSG_CHECKING([for a usable libatomic_ops implementation])\n\t    case \"x$with_libatomic_ops\" in\n\t        xno | xyes | x)\n\t    \t    libatomic_ops_include=\n\t    \t    ;;\n\t        *)\n\t    \t    if test -d \"${with_libatomic_ops}/include\"; then\n\t    \t        libatomic_ops_include=\"-I$with_libatomic_ops/include\"\n\t    \t        CPPFLAGS=\"$CPPFLAGS $libatomic_ops_include\"\n\t    \t    else\n\t    \t        AC_MSG_ERROR([libatomic_ops include directory $with_libatomic_ops/include not found])\n\t    \t    fi;;\n\t    esac\n\t    ethr_have_libatomic_ops=no\n\t    AC_TRY_LINK([#include \"atomic_ops.h\"],\n\t    \t        [\n\t    \t    \t    volatile AO_t x;\n\t    \t    \t    AO_t y;\n\t    \t    \t    int z;\n\n\t    \t    \t    AO_nop_full();\n#if defined(AO_HAVE_store)\n\t    \t    \t    AO_store(&x, (AO_t) 0);\n#elif defined(AO_HAVE_store_release)\n\t    \t    \t    AO_store_release(&x, (AO_t) 0);\n#else\n#error No store\n#endif\n#if defined(AO_HAVE_load)\n\t    \t    \t    z = AO_load(&x);\n#elif defined(AO_HAVE_load_acquire)\n\t    \t    \t    z = AO_load_acquire(&x);\n#else\n#error No load\n#endif\n#if defined(AO_HAVE_compare_and_swap_full)\n\t    \t    \t    z = AO_compare_and_swap_full(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap_release)\n\t    \t    \t    z = AO_compare_and_swap_release(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap_acquire)\n\t    \t    \t    z = AO_compare_and_swap_acquire(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap)\n\t    \t    \t    z = AO_compare_and_swap(&x, (AO_t) 0, (AO_t) 1);\n#else\n#error No compare_and_swap\n#endif\n\t    \t        ],\n\t    \t        [ethr_have_native_atomics=yes\n\t\t\t ethr_native_atomic_implementation=libatomic_ops\n\t    \t         ethr_have_libatomic_ops=yes])\n\t    AC_MSG_RESULT([$ethr_have_libatomic_ops])\n\t    if test $ethr_have_libatomic_ops = yes; then\n\t        AC_CHECK_SIZEOF(AO_t, ,\n\t    \t    \t        [\n\t    \t    \t    \t    #include <stdio.h>\n\t    \t    \t    \t    #include \"atomic_ops.h\"\n\t    \t    \t        ])\n\t        AC_DEFINE_UNQUOTED(ETHR_SIZEOF_AO_T, $ac_cv_sizeof_AO_t, [Define to the size of AO_t if libatomic_ops is used])\n\n\t        AC_DEFINE(ETHR_HAVE_LIBATOMIC_OPS, 1, [Define if you have libatomic_ops atomic operations])\n\t        if test \"x$with_libatomic_ops\" != \"xno\" && test \"x$with_libatomic_ops\" != \"x\"; then\n\t    \t    AC_DEFINE(ETHR_PREFER_LIBATOMIC_OPS_NATIVE_IMPLS, 1, [Define if you prefer libatomic_ops native ethread implementations])\n\t        fi\n\t        ETHR_DEFS=\"$ETHR_DEFS $libatomic_ops_include\"\n\t    elif test \"x$with_libatomic_ops\" != \"xno\" && test \"x$with_libatomic_ops\" != \"x\"; then\n\t        AC_MSG_ERROR([No usable libatomic_ops implementation found])\n\t    fi\n\n\t    case \"$host_cpu\" in\n\t      sparc | sun4u | sparc64 | sun4v)\n\t    \t    case \"$with_sparc_memory_order\" in\n\t    \t        \"TSO\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_TSO, 1, [Define if only run in Sparc TSO mode]);;\n\t    \t        \"PSO\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_PSO, 1, [Define if only run in Sparc PSO, or TSO mode]);;\n\t    \t        \"RMO\"|\"\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_RMO, 1, [Define if run in Sparc RMO, PSO, or TSO mode]);;\n\t    \t        *)\n\t    \t    \t    AC_MSG_ERROR([Unsupported Sparc memory order: $with_sparc_memory_order]);;\n\t    \t    esac\n\t\t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;; \n\t      i86pc | i*86 | x86_64 | amd64)\n\t    \t    if test \"$enable_x86_out_of_order\" = \"yes\"; then\n\t    \t    \t    AC_DEFINE(ETHR_X86_OUT_OF_ORDER, 1, [Define if x86/x86_64 out of order instructions should be synchronized])\n\t    \t    fi\n\t\t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      macppc | ppc | powerpc | \"Power Macintosh\")\n\t      \t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      tile)\n\t            ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      *)\n\t    \t    ;;\n\t    esac\n\n\tfi\n\n\ttest ethr_have_native_atomics = \"yes\" && ethr_have_native_spinlock=yes\n\n\tdnl Restore LIBS\n\tLIBS=$saved_libs\n\tdnl restore CPPFLAGS\n\tCPPFLAGS=$saved_cppflags\n\n\t;;\n    *)\n\t;;\nesac\n\nAC_MSG_CHECKING([whether default stack size should be modified])\nif test \"x$ethr_modified_default_stack_size\" != \"x\"; then\n\tAC_DEFINE_UNQUOTED(ETHR_MODIFIED_DEFAULT_STACK_SIZE, $ethr_modified_default_stack_size, [Define if you want to modify the default stack size])\n\tAC_MSG_RESULT([yes; to $ethr_modified_default_stack_size kilo words])\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nif test \"x$ETHR_THR_LIB_BASE\" != \"x\"; then\n\tETHR_DEFS=\"-DUSE_THREADS $ETHR_DEFS\"\n\tETHR_LIBS=\"-l$ethr_lib_name -lerts_internal_r $ETHR_X_LIBS\"\n\tETHR_LIB_NAME=$ethr_lib_name\nfi\n\nAC_CHECK_SIZEOF(void *)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_PTR, $ac_cv_sizeof_void_p, [Define to the size of pointers])\n\nAC_CHECK_SIZEOF(int)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_INT, $ac_cv_sizeof_int, [Define to the size of int])\nAC_CHECK_SIZEOF(long)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_LONG, $ac_cv_sizeof_long, [Define to the size of long])\nAC_CHECK_SIZEOF(long long)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_LONG_LONG, $ac_cv_sizeof_long_long, [Define to the size of long long])\nAC_CHECK_SIZEOF(__int64)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF___INT64, $ac_cv_sizeof___int64, [Define to the size of __int64])\nAC_CHECK_SIZEOF(__int128_t)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF___INT128_T, $ac_cv_sizeof___int128_t, [Define to the size of __int128_t])\n\n\ncase X$erl_xcomp_bigendian in\n    X) ;;\n    Xyes|Xno) ac_cv_c_bigendian=$erl_xcomp_bigendian;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_bigendian value: $erl_xcomp_bigendian]);;\nesac\n\nAC_C_BIGENDIAN\n\nif test \"$ac_cv_c_bigendian\" = \"yes\"; then\n    AC_DEFINE(ETHR_BIGENDIAN, 1, [Define if bigendian])\nfi\n\ncase X$erl_xcomp_double_middle_endian in\n    X) ;;\n    Xyes|Xno|Xunknown) ac_cv_c_double_middle_endian=$erl_xcomp_double_middle_endian;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_double_middle_endian value: $erl_xcomp_double_middle_endian]);;\nesac\n\nAC_C_DOUBLE_MIDDLE_ENDIAN\n\nETHR_X86_SSE2_ASM=no\ncase \"$GCC-$ac_cv_sizeof_void_p-$host_cpu\" in\n  yes-4-i86pc | yes-4-i*86 | yes-4-x86_64 | yes-4-amd64)\n    AC_MSG_CHECKING([for gcc sse2 asm support])\n    save_CFLAGS=\"$CFLAGS\"\n    CFLAGS=\"$CFLAGS -msse2\"\n    gcc_sse2_asm=no\n    AC_TRY_COMPILE([],\n\t[\n\t\tlong long x, *y;\n\t\t__asm__ __volatile__(\"movq %1, %0\\n\\t\" : \"=x\"(x) : \"m\"(*y) : \"memory\");\n\t],\n\t[gcc_sse2_asm=yes])\n    CFLAGS=\"$save_CFLAGS\"\n    AC_MSG_RESULT([$gcc_sse2_asm])\n    if test \"$gcc_sse2_asm\" = \"yes\"; then\n      AC_DEFINE(ETHR_GCC_HAVE_SSE2_ASM_SUPPORT, 1, [Define if you use a gcc that supports -msse2 and understand sse2 specific asm statements])\n      ETHR_X86_SSE2_ASM=yes\n    fi\n    ;;\n  *)\n    ;;\nesac\n\ncase \"$GCC-$host_cpu\" in\n  yes-i86pc | yes-i*86 | yes-x86_64 | yes-amd64)\n\n    if test $ac_cv_sizeof_void_p = 4; then\n       dw_cmpxchg=\"cmpxchg8b\"\n    else\n       dw_cmpxchg=\"cmpxchg16b\"\n    fi\n\n    gcc_dw_cmpxchg_asm=no\n    gcc_pic_dw_cmpxchg_asm=no\n    gcc_cflags_pic=no\n    gcc_cmpxchg8b_pic_no_clobber_ebx=no\n    gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage=no\n\n    save_CFLAGS=\"$CFLAGS\"\n\n    # Check if it works out of the box using passed CFLAGS\n    # and with -fPIC added to CFLAGS if the passed CFLAGS\n    # doesn't trigger position independent code\n    pic_cmpxchg=unknown\n    while true; do\n\n        case $pic_cmpxchg in\n\t  yes) pic_text=\"pic \";;\n\t  *) pic_text=\"\";;\n\tesac\n\n\tAC_MSG_CHECKING([for gcc $pic_text$dw_cmpxchg plain asm support])    \n\n\tplain_cmpxchg=no\n    \tAC_TRY_COMPILE([],\n\t[\n    char xchgd;\n    long new[2], xchg[2], *p;\t\t  \n    __asm__ __volatile__(\n#if ETHR_SIZEOF_PTR == 4\n\t\"lock; cmpxchg8b %0\\n\\t\"\n#else\n\t\"lock; cmpxchg16b %0\\n\\t\"\n#endif\n\t\"setz %3\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=q\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"c\"(new[1]), \"b\"(new[0])\n\t: \"cc\", \"memory\");\n\t],\n\t[plain_cmpxchg=yes])\n\n\tAC_MSG_RESULT([$plain_cmpxchg])\n\n\tif test $pic_cmpxchg = yes; then\n\t   gcc_pic_dw_cmpxchg_asm=$plain_cmpxchg\n\t   break\n\tfi\n\n\tgcc_dw_cmpxchg_asm=$plain_cmpxchg\n\n    \t# If not already compiling to position independent\n\t# code add -fPIC to CFLAGS and do it again. This\n\t# since we want also want to know how to compile\n\t# to position independent code since this might\n\t# cause problems with the use of the EBX register\n\t# as input to the asm on 32-bit x86 and old gcc\n\t# compilers (gcc vsn < 5).\n\n    \tAC_TRY_COMPILE([],\n\t[\n#if !defined(__PIC__) || !__PIC__\n#  error no pic\n#endif\n\t],\n\t[pic_cmpxchg=yes\n\t gcc_cflags_pic=yes],\n\t[pic_cmpxchg=no])\n\n\tif test $pic_cmpxchg = yes; then\n\t   gcc_pic_dw_cmpxchg_asm=$gcc_dw_cmpxchg_asm\n\t   break\n\tfi\n\n\tCFLAGS=\"$save_CFLAGS -fPIC\"\n\tpic_cmpxchg=yes\n\n    done\n\n    if test $gcc_pic_dw_cmpxchg_asm = no && test $ac_cv_sizeof_void_p = 4; then\n\n      AC_MSG_CHECKING([for gcc pic cmpxchg8b asm support with EBX workaround])\n\n      # Check if we can work around it by managing the ebx\n      # register explicitly in the asm...\n\n      AC_TRY_COMPILE([],\n\t[\n    char xchgd;\n    long new[2], xchg[2], *p;\t\t  \n    __asm__ __volatile__(\n\t\"pushl %%ebx\\n\\t\"\n\t\"movl %8, %%ebx\\n\\t\"\n\t\"lock; cmpxchg8b %0\\n\\t\"\n\t\"setz %3\\n\\t\"\n\t\"popl %%ebx\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=q\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"c\"(new[1]), \"r\"(new[0])\n\t: \"cc\", \"memory\");\n\t],\n\t[gcc_pic_dw_cmpxchg_asm=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx=yes])     \n\n      AC_MSG_RESULT([$gcc_pic_dw_cmpxchg_asm])\n\n      if test $gcc_pic_dw_cmpxchg_asm = no; then\n\n      \tAC_MSG_CHECKING([for gcc pic cmpxchg8b asm support with EBX and register shortage workarounds])\n        # If no optimization is enabled we sometimes get a\n\t# register shortage. Check if we can work around\n\t# this...\n\n      \tAC_TRY_COMPILE([],\n\t  [\n      char xchgd;\n      long new[2], xchg[2], *p;\n      __asm__ __volatile__(\n\t\"pushl %%ebx\\n\\t\"\n\t\"movl (%7), %%ebx\\n\\t\"\n\t\"movl 4(%7), %%ecx\\n\\t\"\n\t\"lock; cmpxchg8b %0\\n\\t\"\n\t\"setz %3\\n\\t\"\n\t\"popl %%ebx\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=c\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"r\"(new)\n\t: \"cc\", \"memory\");\n\n\t],\n\t[gcc_pic_dw_cmpxchg_asm=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage=yes])\n\n        AC_MSG_RESULT([$gcc_pic_dw_cmpxchg_asm])\n      fi\n\n      if test $gcc_cflags_pic = yes; then\n        gcc_dw_cmpxchg_asm=$gcc_pic_dw_cmpxchg_asm\n      fi\n \n   fi\n\n    CFLAGS=\"$save_CFLAGS\"\n\n    if test \"$gcc_cmpxchg8b_pic_no_clobber_ebx\" = \"yes\"; then\n      AC_DEFINE(ETHR_CMPXCHG8B_PIC_NO_CLOBBER_EBX, 1, [Define if gcc wont let you clobber ebx with cmpxchg8b and position independent code])\n    fi\n    if test \"$gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage\" = \"yes\"; then\n      AC_DEFINE(ETHR_CMPXCHG8B_REGISTER_SHORTAGE, 1, [Define if you get a register shortage with cmpxchg8b and position independent code])\n    fi\n    if test \"$gcc_dw_cmpxchg_asm\" = \"yes\"; then\n      AC_DEFINE(ETHR_GCC_HAVE_DW_CMPXCHG_ASM_SUPPORT, 1, [Define if you use a gcc that supports the double word cmpxchg instruction])\n    fi;;\n  *)\n    ;;\nesac\n\nAC_DEFINE(ETHR_HAVE_ETHREAD_DEFINES, 1, \\\n[Define if you have all ethread defines])\n\nAC_SUBST(ETHR_X_LIBS)\nAC_SUBST(ETHR_LIBS)\nAC_SUBST(ETHR_LIB_NAME)\nAC_SUBST(ETHR_DEFS)\nAC_SUBST(ETHR_THR_LIB_BASE)\nAC_SUBST(ETHR_THR_LIB_BASE_DIR)\nAC_SUBST(ETHR_X86_SSE2_ASM)\n\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl ERL_TIME_CORRECTION\ndnl\ndnl Check for primitives that can be used for implementing\ndnl erts_os_monotonic_time() and erts_os_system_time()\ndnl\n\nAC_DEFUN(ERL_TIME_CORRECTION,\n[\n\nAC_ARG_WITH(clock-resolution,\nAS_HELP_STRING([--with-clock-resolution=high|low|default],\n               [specify wanted clock resolution]))\n\nAC_ARG_WITH(clock-gettime-realtime-id,\nAS_HELP_STRING([--with-clock-gettime-realtime-id=CLOCKID],\n               [specify clock id to use with clock_gettime() for realtime time)]))\n\nAC_ARG_WITH(clock-gettime-monotonic-id,\nAS_HELP_STRING([--with-clock-gettime-monotonic-id=CLOCKID],\n               [specify clock id to use with clock_gettime() for monotonic time)]))\n\nAC_ARG_ENABLE(prefer-elapsed-monotonic-time-during-suspend,\nAS_HELP_STRING([--enable-prefer-elapsed-monotonic-time-during-suspend],\n               [Prefer an OS monotonic time source with elapsed time during suspend])\nAS_HELP_STRING([--disable-prefer-elapsed-monotonic-time-during-suspend],\n               [Do not prefer an OS monotonic time source with elapsed time during suspend]),\n[ case \"$enableval\" in\n    yes) prefer_elapsed_monotonic_time_during_suspend=yes ;;\n    *)  prefer_elapsed_monotonic_time_during_suspend=no ;;\n  esac ], prefer_elapsed_monotonic_time_during_suspend=no)\n\nAC_ARG_ENABLE(gettimeofday-as-os-system-time,\n\t      AS_HELP_STRING([--enable-gettimeofday-as-os-system-time],\n                             [Force usage of gettimeofday() for OS system time]),\n[ case \"$enableval\" in\n    yes) force_gettimeofday_os_system_time=yes ;;\n    *)  force_gettimeofday_os_system_time=no ;;\n  esac ], force_gettimeofday_os_system_time=no)\n\ncase \"$with_clock_resolution\" in\n   \"\"|no|yes)\n     with_clock_resolution=default;;\n   high|low|default)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid wanted clock resolution: $with_clock_resolution])\n     ;;\nesac\n\nif test \"$force_gettimeofday_os_system_time\" = \"yes\"; then\n\n  AC_CHECK_FUNCS([gettimeofday])\n  if test \"$ac_cv_func_gettimeofday\" = \"yes\"; then\n    AC_DEFINE(OS_SYSTEM_TIME_GETTIMEOFDAY,  [1], [Define if you want to implement erts_os_system_time() using gettimeofday()])\n  else\n    AC_MSG_ERROR([No gettimeofday() available])\n  fi\n\nelse # $force_gettimeofday_os_system_time != yes\n\ncase \"$with_clock_gettime_realtime_id\" in\n   \"\"|no)\n     with_clock_gettime_realtime_id=no\n     ;;\n   CLOCK_*CPUTIME*)\n     AC_MSG_ERROR([Invalid clock_gettime() realtime clock id: Refusing to use the cputime clock id $with_clock_gettime_realtime_id as realtime clock id])\n     ;;\n   CLOCK_MONOTONIC*|CLOCK_BOOTTIME*|CLOCK_UPTIME*|CLOCK_HIGHRES*)\n     AC_MSG_ERROR([Invalid clock_gettime() realtime clock id: Refusing to use the monotonic clock id $with_clock_gettime_realtime_id as realtime clock id])\n     ;;\n   CLOCK_*)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid clock_gettime() clock id: $with_clock_gettime_realtime_id])\n     ;;\nesac\n\ncase \"$with_clock_resolution-$with_clock_gettime_realtime_id\" in\n  high-no)\n\tERL_WALL_CLOCK(high_resolution);;\n  low-no)\n\tERL_WALL_CLOCK(low_resolution);;\n  default-no)\n\tERL_WALL_CLOCK(default_resolution);;\n  *)\n\tERL_WALL_CLOCK(custom_resolution, $with_clock_gettime_realtime_id);;\nesac\n\ncase \"$erl_wall_clock_func-$erl_wall_clock_id-$with_clock_gettime_realtime_id\" in\n  *-*-no)\n    ;;\n  clock_gettime-$with_clock_gettime_realtime_id-$with_clock_gettime_realtime_id)\n    ;;\n  *)\n    AC_MSG_ERROR([$with_clock_gettime_realtime_id as clock id to clock_gettime() doesn't compile])\n    ;;\nesac\n\ncase $erl_wall_clock_func in\n  none)\n    AC_MSG_ERROR([No wall clock source found])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(OS_SYSTEM_TIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_system_time() using mach clock_get_time()])\n    ;;\n  clock_gettime)\n    AC_DEFINE(OS_SYSTEM_TIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_system_time() using clock_gettime()])\n    ;;\n  gettimeofday)\n    AC_DEFINE(OS_SYSTEM_TIME_GETTIMEOFDAY,  [1], [Define if you want to implement erts_os_system_time() using gettimeofday()])\n    ;;\n  *)\n    ;;\nesac\n\nif test \"x$erl_wall_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(WALL_CLOCK_ID_STR, [\"$erl_wall_clock_id\"], [Define as a string of wall clock id to use])\n    AC_DEFINE_UNQUOTED(WALL_CLOCK_ID, [$erl_wall_clock_id], [Define to wall clock id to use])\nfi\n\nfi # $force_gettimeofday_os_system_time != yes\n\ncase \"$with_clock_gettime_monotonic_id\" in\n   \"\"|no)\n     with_clock_gettime_monotonic_id=no\n     ;;\n   CLOCK_*CPUTIME*)\n     AC_MSG_ERROR([Invalid clock_gettime() monotonic clock id: Refusing to use the cputime clock id $with_clock_gettime_monotonic_id as monotonic clock id])\n     ;;\n   CLOCK_REALTIME*|CLOCK_TAI*)\n     AC_MSG_ERROR([Invalid clock_gettime() monotonic clock id: Refusing to use the realtime clock id $with_clock_gettime_monotonic_id as monotonic clock id])\n     ;;\n   CLOCK_*)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid clock_gettime() clock id: $with_clock_gettime_monotonic_id])\n     ;;\nesac\n\ncase \"$with_clock_resolution-$with_clock_gettime_monotonic_id\" in\n  high-no)\n\tERL_MONOTONIC_CLOCK(high_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  low-no)\n\tERL_MONOTONIC_CLOCK(low_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  default-no)\n\tERL_MONOTONIC_CLOCK(default_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  *)\n\tERL_MONOTONIC_CLOCK(custom_resolution, $with_clock_gettime_monotonic_id, $prefer_elapsed_monotonic_time_during_suspend);;\nesac\n\ncase \"$erl_monotonic_clock_func-$erl_monotonic_clock_id-$with_clock_gettime_monotonic_id\" in\n  *-*-no)\n    ;;\n  clock_gettime-$with_clock_gettime_monotonic_id-$with_clock_gettime_monotonic_id)\n    ;;\n  *)\n    AC_MSG_ERROR([$with_clock_gettime_monotonic_id as clock id to clock_gettime() doesn't compile])\n    ;;\nesac\n\ncase $erl_monotonic_clock_func in\n  times)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_TIMES, [1], [Define if you want to implement erts_os_monotonic_time() using times()])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_monotonic_time() using mach clock_get_time()])\n    ;;\n  clock_gettime)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_monotonic_time() using clock_gettime()])\n    ;;\n  gethrtime)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_GETHRTIME,  [1], [Define if you want to implement erts_os_monotonic_time() using gethrtime()])\n    ;;\n  *)\n    ;;\nesac\n\nif test $erl_corrected_monotonic_clock = yes; then\n  AC_DEFINE(ERTS_HAVE_CORRECTED_OS_MONOTONIC_TIME, [1], [Define if OS monotonic clock is corrected])\nfi\n\nif test $erl_monotonic_clock_low_resolution = yes; then\n  AC_DEFINE(ERTS_HAVE_LOW_RESOLUTION_OS_MONOTONIC_LOW, [1], [Define if you have a low resolution OS monotonic clock])\nfi\n\nxrtlib=\nif test \"$erl_monotonic_clock_lib\" != \"\"; then\n   xrtlib=\"$erl_monotonic_clock_lib\"\nfi\nif test \"$erl_wall_clock_lib\" != \"\"; then\n   xrtlib=\"$erl_wall_clock_lib\"\nfi\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(MONOTONIC_CLOCK_ID_STR, [\"$erl_monotonic_clock_id\"], [Define as a string of monotonic clock id to use])\n    AC_DEFINE_UNQUOTED(MONOTONIC_CLOCK_ID, [$erl_monotonic_clock_id], [Define to monotonic clock id to use])\nfi\n\nif test $erl_cv_clock_gettime_monotonic_raw = yes; then\n  AC_DEFINE(HAVE_CLOCK_GETTIME_MONOTONIC_RAW, [1], [Define if you have clock_gettime(CLOCK_MONOTONIC_RAW, _)])\nfi\n\nERL_MONOTONIC_CLOCK(high_resolution, undefined, no)\n\ncase $$erl_monotonic_clock_low_resolution-$erl_monotonic_clock_func in\n  no-mach_clock_get_time)\n    monotonic_hrtime=yes    \n    AC_DEFINE(SYS_HRTIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_hrtime() using mach clock_get_time()])\n    ;;\n  no-clock_gettime)\n    monotonic_hrtime=yes\n    AC_DEFINE(SYS_HRTIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_hrtime() using clock_gettime()])\n    ;;\n  no-gethrtime)\n    monotonic_hrtime=yes\n    AC_DEFINE(SYS_HRTIME_USING_GETHRTIME,  [1], [Define if you want to implement erts_os_hrtime() using gethrtime()])\n    ;;\n  *)\n    monotonic_hrtime=no\n    ;;\nesac\n\nif test $monotonic_hrtime = yes; then\n    AC_DEFINE(HAVE_MONOTONIC_ERTS_SYS_HRTIME, [1], [Define if you have a monotonic erts_os_hrtime() implementation])\nfi\n\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(HRTIME_CLOCK_ID_STR, [\"$erl_monotonic_clock_id\"], [Define as a string of monotonic clock id to use])\n    AC_DEFINE_UNQUOTED(HRTIME_CLOCK_ID, [$erl_monotonic_clock_id], [Define to monotonic clock id to use])\nfi\n\n\ndnl\ndnl Check if gethrvtime is working, and if to use procfs ioctl\ndnl or (yet to be written) write to the procfs ctl file.\ndnl\n\nAC_MSG_CHECKING([if gethrvtime works and how to use it])\nAC_TRY_RUN([\n/* gethrvtime procfs ioctl test */\n/* These need to be undef:ed to not break activation of\n * micro level process accounting on /proc/self \n */\n#ifdef _LARGEFILE_SOURCE\n#  undef _LARGEFILE_SOURCE\n#endif\n#ifdef _FILE_OFFSET_BITS\n#  undef _FILE_OFFSET_BITS\n#endif\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/signal.h>\n#include <sys/fault.h>\n#include <sys/syscall.h>\n#include <sys/procfs.h>\n#include <fcntl.h>\n\nint main() {\n    long msacct = PR_MSACCT;\n    int fd;\n    long long start, stop;\n    int i;\n    pid_t pid = getpid();\n    char proc_self[30] = \"/proc/\";\n\n    sprintf(proc_self+strlen(proc_self), \"%lu\", (unsigned long) pid);\n    if ( (fd = open(proc_self, O_WRONLY)) == -1)\n\texit(1);\n    if (ioctl(fd, PIOCSET, &msacct) < 0)\n\texit(2);\n    if (close(fd) < 0)\n\texit(3);\n    start = gethrvtime();\n    for (i = 0; i < 100; i++)\n\tstop = gethrvtime();\n    if (start == 0)\n\texit(4);\n    if (start == stop)\n\texit(5);\n    exit(0); return 0;\n}\n],\nerl_gethrvtime=procfs_ioctl,\nerl_gethrvtime=false,\n[\ncase X$erl_xcomp_gethrvtime_procfs_ioctl in\n    X)\n\terl_gethrvtime=cross;;\n    Xyes|Xno)\n\tif test $erl_xcomp_gethrvtime_procfs_ioctl = yes; then\n\t    erl_gethrvtime=procfs_ioctl\n\telse\n\t    erl_gethrvtime=false\n\tfi;;\n    *)\n\tAC_MSG_ERROR([Bad erl_xcomp_gethrvtime_procfs_ioctl value: $erl_xcomp_gethrvtime_procfs_ioctl]);;\nesac\n])\n\nLIBRT=$xrtlib\ncase $erl_gethrvtime in\n  procfs_ioctl)\n\tAC_DEFINE(HAVE_GETHRVTIME_PROCFS_IOCTL,[1],\n\t\t[define if gethrvtime() works and uses ioctl() to /proc/self])\n\tAC_MSG_RESULT(uses ioctl to procfs)\n\t;;\n  *)\n\tif test $erl_gethrvtime = cross; then\n\t    erl_gethrvtime=false\n\t    AC_MSG_RESULT(cross)\n\t    AC_MSG_WARN([result 'not working' guessed because of cross compilation])\n\telse\n\t    AC_MSG_RESULT(not working)\n\tfi\n\n\tdnl\n\tdnl Check if clock_gettime (linux) is working\n\tdnl\n\n\tAC_MSG_CHECKING([if clock_gettime can be used to get thread CPU time])\n\tsave_libs=$LIBS\n\tLIBS=\"-lrt\"\n\tAC_TRY_RUN([\n\t#include <stdlib.h>\n\t#include <unistd.h>\n\t#include <string.h>\n\t#include <stdio.h>\n\t#include <time.h>\n\tint main() {\n\t    long long start, stop;\n\t    int i;\n\t    struct timespec tp;\n\n\t    if (clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp) < 0)\n\t      exit(1);\n\t    start = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;\n\t    for (i = 0; i < 100; i++)\n\t      clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp);\n\t    stop = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;\n\t    if (start == 0)\n\t      exit(4);\n\t    if (start == stop)\n\t      exit(5);\n\t    exit(0); return 0;\n\t  }\n\t],\n\terl_clock_gettime_cpu_time=yes,\n\terl_clock_gettime_cpu_time=no,\n\t[\n\tcase X$erl_xcomp_clock_gettime_cpu_time in\n\t    X) erl_clock_gettime_cpu_time=cross;;\n\t    Xyes|Xno) erl_clock_gettime_cpu_time=$erl_xcomp_clock_gettime_cpu_time;;\n\t    *) AC_MSG_ERROR([Bad erl_xcomp_clock_gettime_cpu_time value: $erl_xcomp_clock_gettime_cpu_time]);;\n\tesac\n\t])\n\tLIBS=$save_libs\n\tAC_MSG_RESULT($erl_clock_gettime_cpu_time)\n\tcase $erl_clock_gettime_cpu_time in\n\t\tyes)\n\t\t\tAC_DEFINE(HAVE_CLOCK_GETTIME_CPU_TIME,[],\n\t\t\t\t  [define if clock_gettime() works for getting thread time])\n\t\t\tLIBRT=-lrt\n\t\t\t;;\n\t\tcross)\n\t\t\terl_clock_gettime_cpu_time=no\n\t\t\tAC_MSG_WARN([result no guessed because of cross compilation])\n\t\t\t;;\n\t\t*)\n\t\t\t;;\n\tesac\n\t;;\nesac\nAC_SUBST(LIBRT)\n])dnl\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_TRY_ENABLE_CFLAG\ndnl\ndnl\ndnl Tries a CFLAG and sees if it can be enabled without compiler errors\ndnl $1: textual cflag to add\ndnl $2: variable to store the modified CFLAG in\ndnl Usage example LM_TRY_ENABLE_CFLAG([-Werror=return-type], [CFLAGS])\ndnl\ndnl\nAC_DEFUN([LM_TRY_ENABLE_CFLAG], [\n    AC_MSG_CHECKING([if we can add $1 to $2 (via CFLAGS)])\n    saved_CFLAGS=$CFLAGS;\n    CFLAGS=\"$1 $$2\";\n    AC_TRY_COMPILE([],[return 0;],can_enable_flag=true,can_enable_flag=false)\n    CFLAGS=$saved_CFLAGS;\n    if test \"X$can_enable_flag\" = \"Xtrue\"; then\n        AC_MSG_RESULT([yes])\n        AS_VAR_SET($2, \"$1 $$2\")\n    else\n        AC_MSG_RESULT([no])\n    fi\n])\n\nAC_DEFUN([LM_CHECK_ENABLE_CFLAG], [\n    AC_MSG_CHECKING([whether $CC accepts $1...])\n    saved_CFLAGS=$CFLAGS;\n    CFLAGS=\"$1 $CFLAGS\";\n    AC_TRY_COMPILE([],[return 0;],can_enable_flag=true,can_enable_flag=false)\n    CFLAGS=$saved_CFLAGS;\n    if test \"X$can_enable_flag\" = \"Xtrue\"; then\n        AS_VAR_SET($2, true)\n        AC_MSG_RESULT([yes])\n    else\n        AS_VAR_SET($2, false)\n        AC_MSG_RESULT([no])\n    fi\n])\n\ndnl ERL_TRY_LINK_JAVA(CLASSES, FUNCTION-BODY\ndnl                   [ACTION_IF_FOUND [, ACTION-IF-NOT-FOUND]])\ndnl Freely inspired by AC_TRY_LINK. (Maybe better to create a \ndnl AC_LANG_JAVA instead...)\nAC_DEFUN(ERL_TRY_LINK_JAVA,\n[java_link='$JAVAC conftest.java 1>&AC_FD_CC'\nchangequote(, )dnl\ncat > conftest.java <<EOF\n$1\nclass conftest { public static void main(String[] args) {\n   $2\n   ; return; }}\nEOF\nchangequote([, ])dnl\nif AC_TRY_EVAL(java_link) && test -s conftest.class; then\n   ifelse([$3], , :, [rm -rf conftest*\n   $3])\nelse\n   echo \"configure: failed program was:\" 1>&AC_FD_CC\n   cat conftest.java 1>&AC_FD_CC\n   echo \"configure: PATH was $PATH\" 1>&AC_FD_CC\nifelse([$4], , , [  rm -rf conftest*\n  $4\n])dnl\nfi\nrm -f conftest*])\n#define UNSAFE_MASK  0xc0000000 /* Mask for bits that must be constant */\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_HARDWARE_ARCH\ndnl\ndnl Determine target hardware in ARCH\ndnl\nAC_DEFUN([LM_HARDWARE_ARCH], [\n    AC_MSG_CHECKING([target hardware architecture])\n    if test \"x$host_alias\" != \"x\" -a \"x$host_cpu\" != \"x\"; then\n        chk_arch_=$host_cpu\n    else\n        chk_arch_=`uname -m`\n    fi\n\n    case $chk_arch_ in\n    sun4u)\tARCH=ultrasparc;;\n    sparc64)\tARCH=sparc64;;\n    sun4v)\tARCH=ultrasparc;;\n    i86pc)\tARCH=x86;;\n    i386)\tARCH=x86;;\n    i486)\tARCH=x86;;\n    i586)\tARCH=x86;;\n    i686)\tARCH=x86;;\n    x86_64)\tARCH=amd64;;\n    amd64)\tARCH=amd64;;\n    macppc)\tARCH=ppc;;\n    powerpc)\tARCH=ppc;;\n    ppc)\tARCH=ppc;;\n    ppc64)\tARCH=ppc64;;\n    ppc64le)\tARCH=ppc64le;;\n    \"Power Macintosh\")\tARCH=ppc;;\n    armv5b)\tARCH=arm;;\n    armv5teb)\tARCH=arm;;\n    armv5tel)\tARCH=arm;;\n    armv5tejl)\tARCH=arm;;\n    armv6l)\tARCH=arm;;\n    armv6hl)\tARCH=arm;;\n    armv7l)\tARCH=arm;;\n    armv7hl)\tARCH=arm;;\n    tile)\tARCH=tile;;\n    e2k)        ARCH=e2k;;\n    *)\t \tARCH=noarch;;\n    esac\n    AC_MSG_RESULT($ARCH)\n\n    dnl\n    dnl Convert between x86 and amd64 based on the compiler's mode.\n    dnl Ditto between ultrasparc and sparc64.\n    dnl\n    AC_MSG_CHECKING(whether compilation mode forces ARCH adjustment)\n    case \"$ARCH-$ac_cv_sizeof_void_p\" in\n    x86-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=x86 to ARCH=amd64)\n\tARCH=amd64\n\t;;\n    amd64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=amd64 to ARCH=x86)\n\tARCH=x86\n\t;;\n    ultrasparc-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ultrasparc to ARCH=sparc64)\n\tARCH=sparc64\n\t;;\n    sparc64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=sparc64 to ARCH=ultrasparc)\n\tARCH=ultrasparc\n\t;;\n    ppc64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ppc64 to ARCH=ppc)\n\tARCH=ppc\n\t;;\n    ppc-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ppc to ARCH=ppc64)\n\tARCH=ppc64\n\t;;\n    arm-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=arm to ARCH=noarch)\n\tARCH=noarch\n\t;;\n    *)\n\tAC_MSG_RESULT(no: ARCH is $ARCH)\n\t;;\n    esac\n\n    AC_SUBST(ARCH)\n])\n\ndnl\ndnl--------------------------------------------------------------------\ndnl Dynamic Erlang Drivers\ndnl\ndnl Linking to produce dynamic Erlang drivers to be loaded by Erlang's\ndnl Dynamic Driver Loader and Linker (DDLL). Below the prefix DED is an\ndnl abbreviation for `Dynamic Erlang Driver'.\ndnl\ndnl For DED we need something quite sloppy, which allows undefined references \ndnl (notably driver functions) in the resulting shared library. \ndnl Example of Makefile rule (and settings of macros):\ndnl\ndnl LIBS = @LIBS@\ndnl LD = @DED_LD@\ndnl LDFLAGS = @DED_LDFLAGS@\ndnl soname = @ldsoname@\ndnl\ndnl my_drv.so:   my_drv.o my_utils.o\ndnl              $(LD) $(LDFLAGS) $(soname) $@ -o $@ $^ -lc $(LIBS)\ndnl\ndnl--------------------------------------------------------------------\ndnl\n\nAC_DEFUN(ERL_DED,\n\t[\n\nUSER_LD=$LD\nUSER_LDFLAGS=\"$LDFLAGS\"\n\nLM_CHECK_THR_LIB\n\nDED_CC=$CC\nDED_GCC=$GCC\n\nDED_CFLAGS=\nDED_OSTYPE=unix\ncase $host_os in\n     linux*)\n\tDED_CFLAGS=\"-D_GNU_SOURCE\" ;;\n     win32)\n\tDED_CFLAGS=\"-D_WIN32_WINNT=0x0600 -DWINVER=0x0600\"\n        DED_OSTYPE=win32 ;;\n     *)\n        ;;\nesac\n\n\nDED_WARN_FLAGS=\"-Wall -Wstrict-prototypes\"\ncase \"$host_cpu\" in\n  tile*)\n    # tile-gcc is a bit stricter with -Wmissing-prototypes than other gccs,\n    # and too strict for our taste.\n    ;;\n  *)\n    DED_WARN_FLAGS=\"$DED_WARN_FLAGS -Wmissing-prototypes\";;\nesac\n  \nLM_TRY_ENABLE_CFLAG([-Wdeclaration-after-statement], [DED_WARN_FLAGS])\n\nLM_TRY_ENABLE_CFLAG([-Werror=return-type], [DED_WERRORFLAGS])\nLM_TRY_ENABLE_CFLAG([-Werror=implicit], [DED_WERRORFLAGS])\nLM_TRY_ENABLE_CFLAG([-Werror=undef], [DED_WERRORFLAGS])\n\nDED_SYS_INCLUDE=\"-I${ERL_TOP}/erts/emulator/beam -I${ERL_TOP}/erts/include -I${ERL_TOP}/erts/include/$host -I${ERL_TOP}/erts/include/internal -I${ERL_TOP}/erts/include/internal/$host -I${ERL_TOP}/erts/emulator/sys/$DED_OSTYPE -I${ERL_TOP}/erts/emulator/sys/common\"\nDED_INCLUDE=$DED_SYS_INCLUDE\n\nif test \"$THR_DEFS\" = \"\"; then\n    DED_THR_DEFS=\"-D_THREAD_SAFE -D_REENTRANT\"\nelse\n    DED_THR_DEFS=\"$THR_DEFS\"\nfi\n# DED_EMU_THR_DEFS=$EMU_THR_DEFS\nDED_CFLAGS=\"$CFLAGS $CPPFLAGS $DED_CFLAGS\"\nif test \"x$GCC\" = xyes; then\n    DED_STATIC_CFLAGS=\"$DED_CFLAGS\"\n    DED_CFLAGS=\"$DED_CFLAGS -fPIC\"\nfi\n\nDED_EXT=so\ncase $host_os in\n    win32) DED_EXT=dll;;\n    darwin*)\n\tDED_CFLAGS=\"$DED_CFLAGS -fno-common\"\n\tDED_STATIC_CFLAGS=\"$DED_STATIC_CFLAGS -fno-common\";;\n    *)\n\t;;\nesac\n\nDED_STATIC_CFLAGS=\"$DED_STATIC_CFLAGS -DSTATIC_ERLANG_NIF -DSTATIC_ERLANG_DRIVER\"\n\nif test \"$CFLAG_RUNTIME_LIBRARY_PATH\" = \"\"; then\n\n  CFLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-R\"\n  case $host_os in\n    darwin*)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n    win32)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n    osf*)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-rpath,\"\n\t;;\n    *)\n\t;;\n  esac\n\nfi\n\n# If DED_LD is set in environment, we expect all DED_LD* variables\n# to be specified (cross compiling)\nif test \"x$DED_LD\" = \"x\"; then\n\nDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-R\"\ncase $host_os in\n\twin32)\n\t\tDED_LD=\"ld.sh\"\n\t\tDED_LDFLAGS=\"-dll\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n\tsolaris2*|sysv4*)\n\t\tDED_LDFLAGS=\"-G\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-64 $DED_LDFLAGS\"\n\t\tfi\n\t;;\n\taix4*)\n\t\tDED_LDFLAGS=\"-G -bnoentry -bexpall\"\n\t;;\n\tfreebsd2*)\n\t\t# Non-ELF GNU linker\n\t\tDED_LDFLAGS=\"-Bshareable\"\n\t;;\n\tdarwin*)\n\t\t# Mach-O linker: a shared lib and a loadable\n\t\t# object file is not the same thing.\n\t\tDED_LDFLAGS=\"-bundle -bundle_loader ${ERL_TOP}/bin/$host/beam.smp\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t  DED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\telse\n\t\t  if test X${enable_m32_build} = Xyes; then\n\t\t    DED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\t  else\n\t\t    AC_CHECK_SIZEOF(void *)\n\t\t    case \"$ac_cv_sizeof_void_p\" in\n\t\t      8)\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\";;\n\t\t      *)\n\t\t        ;;\n\t\t    esac\n\t\t  fi\n\t\tfi\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t;;\n\tlinux*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared -Wl,-Bsymbolic\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\tfi;\n\t\tif test X${enable_m32_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\tfi\n\t;;\t\n\tfreebsd*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\tfi;\n\t\tif test X${enable_m32_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\tfi\n\t;;\t\n\topenbsd*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared\"\n\t;;\n\tosf*)\n\t\t# NOTE! Whitespace after -rpath is important.\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-rpath \"\n\t\tDED_LDFLAGS=\"-shared -expect_unresolved '*'\"\n\t;;\n\t*)\n\t\t# assume GNU linker and ELF\n\t\tDED_LDFLAGS=\"-shared\"\n\t\t# GNU linker has no option for 64bit build, should not propagate -m64\n\t;;\nesac\n\nif test \"$DED_LD\" = \"\" && test \"$USER_LD\" != \"\"; then\n    DED_LD=\"$USER_LD\"\n    DED_LDFLAGS=\"$USER_LDFLAGS $DED_LDFLAGS\"\nfi\n\nDED_LIBS=$LIBS\n\nfi # \"x$DED_LD\" = \"x\"\n\nAC_CHECK_TOOL(DED_LD, ld, false)\ntest \"$DED_LD\" != \"false\" || AC_MSG_ERROR([No linker found])\n\nAC_MSG_CHECKING(for static compiler flags)\nDED_STATIC_CFLAGS=\"$DED_WERRORFLAGS $DED_WFLAGS $DED_THR_DEFS $DED_STATIC_CFLAGS\"\nAC_MSG_RESULT([$DED_STATIC_CFLAGS])\nAC_MSG_CHECKING(for basic compiler flags for loadable drivers)\nDED_BASIC_CFLAGS=$DED_CFLAGS\nAC_MSG_RESULT([$DED_CFLAGS])\nAC_MSG_CHECKING(for compiler flags for loadable drivers)\nDED_CFLAGS=\"$DED_WERRORFLAGS $DED_WARN_FLAGS $DED_THR_DEFS $DED_CFLAGS\"\nAC_MSG_RESULT([$DED_CFLAGS])\nAC_MSG_CHECKING(for linker for loadable drivers)\nAC_MSG_RESULT([$DED_LD])\nAC_MSG_CHECKING(for linker flags for loadable drivers)\nAC_MSG_RESULT([$DED_LDFLAGS])\nAC_MSG_CHECKING(for 'runtime library path' linker flag)\nif test \"x$DED_LD_FLAG_RUNTIME_LIBRARY_PATH\" != \"x\"; then\n\tAC_MSG_RESULT([$DED_LD_FLAG_RUNTIME_LIBRARY_PATH])\nelse\n\tAC_MSG_RESULT([not found])\nfi\n\nAC_SUBST(DED_CC)\nAC_SUBST(DED_GCC)\nAC_SUBST(DED_EXT)\nAC_SUBST(DED_SYS_INCLUDE)\nAC_SUBST(DED_INCLUDE)\nAC_SUBST(DED_BASIC_CFLAGS)\nAC_SUBST(DED_CFLAGS)\nAC_SUBST(DED_STATIC_CFLAGS)\nAC_SUBST(DED_WARN_FLAGS)\nAC_SUBST(DED_WERRORFLAGS)\nAC_SUBST(DED_LD)\nAC_SUBST(DED_LDFLAGS)\nAC_SUBST(DED_LD_FLAG_RUNTIME_LIBRARY_PATH)\nAC_SUBST(DED_LIBS)\nAC_SUBST(DED_THR_DEFS)\nAC_SUBST(DED_OSTYPE)\n\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_interface/aclocal.m4": "dnl\ndnl %CopyrightBegin%\ndnl\ndnl Copyright Ericsson AB 1998-2018. All Rights Reserved.\ndnl\ndnl Licensed under the Apache License, Version 2.0 (the \"License\");\ndnl you may not use this file except in compliance with the License.\ndnl You may obtain a copy of the License at\ndnl\ndnl     http://www.apache.org/licenses/LICENSE-2.0\ndnl\ndnl Unless required by applicable law or agreed to in writing, software\ndnl distributed under the License is distributed on an \"AS IS\" BASIS,\ndnl WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\ndnl See the License for the specific language governing permissions and\ndnl limitations under the License.\ndnl\ndnl %CopyrightEnd%\ndnl\n\ndnl\ndnl aclocal.m4\ndnl\ndnl Local macros used in configure.in. The Local Macros which\ndnl could/should be part of autoconf are prefixed LM_, macros specific\ndnl to the Erlang system are prefixed ERL_.\ndnl\n\nAC_DEFUN(LM_PRECIOUS_VARS,\n[\n\ndnl ERL_TOP\nAC_ARG_VAR(ERL_TOP, [Erlang/OTP top source directory])\n\ndnl Tools\nAC_ARG_VAR(CC, [C compiler])\nAC_ARG_VAR(CFLAGS, [C compiler flags])\nAC_ARG_VAR(STATIC_CFLAGS, [C compiler static flags])\nAC_ARG_VAR(CFLAG_RUNTIME_LIBRARY_PATH, [runtime library path linker flag passed via C compiler])\nAC_ARG_VAR(CPP, [C/C++ preprocessor])\nAC_ARG_VAR(CPPFLAGS, [C/C++ preprocessor flags])\nAC_ARG_VAR(CXX, [C++ compiler])\nAC_ARG_VAR(CXXFLAGS, [C++ compiler flags])\nAC_ARG_VAR(LD, [linker (is often overridden by configure)])\nAC_ARG_VAR(LDFLAGS, [linker flags (can be risky to set since LD may be overriden by configure)])\nAC_ARG_VAR(LIBS, [libraries])\nAC_ARG_VAR(DED_LD, [linker for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(DED_LDFLAGS, [linker flags for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(DED_LD_FLAG_RUNTIME_LIBRARY_PATH, [runtime library path linker flag for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(LFS_CFLAGS, [large file support C compiler flags (set all LFS_* variables or none)])\nAC_ARG_VAR(LFS_LDFLAGS, [large file support linker flags (set all LFS_* variables or none)])\nAC_ARG_VAR(LFS_LIBS, [large file support libraries (set all LFS_* variables or none)])\nAC_ARG_VAR(RANLIB, [ranlib])\nAC_ARG_VAR(AR, [ar])\nAC_ARG_VAR(GETCONF, [getconf])\n\ndnl Cross system root\nAC_ARG_VAR(erl_xcomp_sysroot, [Absolute cross system root path (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_isysroot, [Absolute cross system root include path (only used when cross compiling)])\n\ndnl Cross compilation variables\nAC_ARG_VAR(erl_xcomp_bigendian, [big endian system: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_double_middle_endian, [double-middle-endian system: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_nptl, [have Native POSIX Thread Library: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_usable_sigusrx, [SIGUSR1 and SIGUSR2 can be used: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_usable_sigaltstack, [have working sigaltstack(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_poll, [have working poll(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_kqueue, [have working kqueue(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_putenv_copy, [putenv() stores key-value copy: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_reliable_fpe, [have reliable floating point exceptions: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_getaddrinfo, [have working getaddrinfo() for both IPv4 and IPv6: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_gethrvtime_procfs_ioctl, [have working gethrvtime() which can be used with procfs ioctl(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_clock_gettime_cpu_time, [clock_gettime() can be used for retrieving process CPU time: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_after_morecore_hook, [__after_morecore_hook can track malloc()s core memory usage: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_dlsym_brk_wrappers, [dlsym(RTLD_NEXT, _) brk wrappers can track malloc()s core memory usage: yes|no (only used when cross compiling)])\n\n])\n\nAC_DEFUN(ERL_XCOMP_SYSROOT_INIT,\n[\nerl_xcomp_without_sysroot=no\nif test \"$cross_compiling\" = \"yes\"; then\n    test \"$erl_xcomp_sysroot\" != \"\" || erl_xcomp_without_sysroot=yes\n    test \"$erl_xcomp_isysroot\" != \"\" || erl_xcomp_isysroot=\"$erl_xcomp_sysroot\"\nelse\n    erl_xcomp_sysroot=\n    erl_xcomp_isysroot=\nfi\n])\n\nAC_DEFUN(LM_CHECK_GETCONF,\n[\nif test \"$cross_compiling\" != \"yes\"; then\n    AC_CHECK_PROG([GETCONF], [getconf], [getconf], [false])\nelse\n    dnl First check if we got a `<HOST>-getconf' in $PATH\n    host_getconf=\"$host_alias-getconf\"\n    AC_CHECK_PROG([GETCONF], [$host_getconf], [$host_getconf], [false])\n    if test \"$GETCONF\" = \"false\" && test \"$erl_xcomp_sysroot\" != \"\"; then\n\tdnl We should perhaps give up if we have'nt found it by now, but at\n\tdnl least in one Tilera MDE `getconf' under sysroot is a bourne\n\tdnl shell script which we can use. We try to find `<HOST>-getconf'\n    \tdnl or `getconf' under sysconf, but only under sysconf since\n\tdnl `getconf' in $PATH is almost guaranteed to be for the build\n\tdnl machine.\n\tGETCONF=\n\tprfx=\"$erl_xcomp_sysroot\"\n        AC_PATH_TOOL([GETCONF], [getconf], [false],\n\t             [\"$prfx/usr/bin:$prfx/bin:$prfx/usr/local/bin\"])\n    fi\nfi\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_WINDOWS_ENVIRONMENT\ndnl\ndnl\ndnl Tries to determine thw windows build environment, i.e. \ndnl MIXED_CYGWIN_VC or MIXED_MSYS_VC \ndnl\n\nAC_DEFUN(LM_WINDOWS_ENVIRONMENT,\n[\n\nif test \"X$windows_environment_\" != \"Xchecked\"; then\nwindows_environment_=checked\nMIXED_CYGWIN=no\nMIXED_MSYS=no\n\nAC_MSG_CHECKING(for mixed cygwin or msys and native VC++ environment)\nif test \"X$host\" = \"Xwin32\" -a \"x$GCC\" != \"xyes\"; then\n\tif test -x /usr/bin/msys-?.0.dll; then\n\t        CFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_MSYS=yes\n\t\tAC_MSG_RESULT([MSYS and VC])\n\t\tMIXED_MSYS_VC=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_MSYS_VC\"\n\telif test -x /usr/bin/cygpath; then\n\t\tCFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_CYGWIN=yes\n\t\tAC_MSG_RESULT([Cygwin and VC])\n\t\tMIXED_CYGWIN_VC=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_CYGWIN_VC\"\n\telse\t\t    \n\t\tAC_MSG_RESULT([undeterminable])\n\t\tAC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)\n\tfi\nelse\n\tAC_MSG_RESULT([no])\n\tMIXED_CYGWIN_VC=no\n\tMIXED_MSYS_VC=no\nfi\nAC_SUBST(MIXED_CYGWIN_VC)\nAC_SUBST(MIXED_MSYS_VC)\n\nMIXED_VC=no\nif test \"x$MIXED_MSYS_VC\" = \"xyes\" -o  \"x$MIXED_CYGWIN_VC\" = \"xyes\" ; then\n   MIXED_VC=yes\nfi\n\nAC_SUBST(MIXED_VC)\n\nif test \"x$MIXED_MSYS\" != \"xyes\"; then\n   AC_MSG_CHECKING(for mixed cygwin and native MinGW environment)\n   if test \"X$host\" = \"Xwin32\" -a \"x$GCC\" = x\"yes\"; then\n\tif test -x /usr/bin/cygpath; then\n\t\tCFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_CYGWIN=yes\n\t\tAC_MSG_RESULT([yes])\n\t\tMIXED_CYGWIN_MINGW=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_CYGWIN_MINGW\"\n\telse\n\t\tAC_MSG_RESULT([undeterminable])\n\t\tAC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)\n\tfi\n    else\n\tAC_MSG_RESULT([no])\n\tMIXED_CYGWIN_MINGW=no\n    fi\nelse\n\tMIXED_CYGWIN_MINGW=no\nfi\t\nAC_SUBST(MIXED_CYGWIN_MINGW)\n\nAC_MSG_CHECKING(if we mix cygwin with any native compiler)\nif test \"X$MIXED_CYGWIN\" = \"Xyes\"; then\n\tAC_MSG_RESULT([yes])\t\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nAC_SUBST(MIXED_CYGWIN)\n\t\nAC_MSG_CHECKING(if we mix msys with another native compiler)\nif test \"X$MIXED_MSYS\" = \"Xyes\" ; then\n\tAC_MSG_RESULT([yes])\t\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nAC_SUBST(MIXED_MSYS)\n\nfi\n])\t\t\n\t\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_FIND_EMU_CC\ndnl\ndnl\ndnl Tries fairly hard to find a C compiler that can handle jump tables.\ndnl Defines the @EMU_CC@ variable for the makefiles and \ndnl inserts NO_JUMP_TABLE in the header if one cannot be found...\ndnl\n\nAC_DEFUN(LM_FIND_EMU_CC,\n\t[AC_CACHE_CHECK(for a compiler that handles jumptables,\n\t\t\tac_cv_prog_emu_cc,\n\t\t\t[\nAC_TRY_COMPILE([],[\n#if defined(__clang_major__) && __clang_major__ >= 3\n    /* clang 3.x or later is fine */\n#elif defined(__llvm__)\n#error \"this version of llvm is unable to correctly compile beam_emu.c\"\n#endif\n    __label__ lbl1;\n    __label__ lbl2;\n    int x = magic();\n    static void *jtab[2];\n\n    jtab[0] = &&lbl1;\n    jtab[1] = &&lbl2;\n    goto *jtab[x];\nlbl1:\n    return 1;\nlbl2:\n    return 2;\n],ac_cv_prog_emu_cc=\"$CC\",ac_cv_prog_emu_cc=no)\n\nif test \"$ac_cv_prog_emu_cc\" = no; then\n\tfor ac_progname in emu_cc.sh gcc-4.2 gcc; do\n  \t\tIFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\":\"\n  \t\tac_dummy=\"$PATH\"\n  \t\tfor ac_dir in $ac_dummy; do\n    \t\t\ttest -z \"$ac_dir\" && ac_dir=.\n    \t\t\tif test -f \"$ac_dir/$ac_progname\"; then\n      \t\t\t\tac_cv_prog_emu_cc=\"$ac_dir/$ac_progname\"\n      \t\t\t\tbreak\n    \t\t\tfi\n  \t\tdone\n  \t\tIFS=\"$ac_save_ifs\"\n\t\tif test \"$ac_cv_prog_emu_cc\" != no; then\n\t\t\tbreak\n\t\tfi\n\tdone\nfi\n\nif test \"$ac_cv_prog_emu_cc\" != no; then\n\tsave_CC=\"$CC\"\n\tsave_CFLAGS=$CFLAGS\n\tsave_CPPFLAGS=$CPPFLAGS\n\tCC=\"$ac_cv_prog_emu_cc\"\n\tCFLAGS=\"\"\n\tCPPFLAGS=\"\"\n\tAC_TRY_COMPILE([],[\n#if defined(__clang_major__) && __clang_major__ >= 3\n    /* clang 3.x or later is fine */\n#elif defined(__llvm__)\n#error \"this version of llvm is unable to correctly compile beam_emu.c\"\n#endif\n    \t__label__ lbl1;\n    \t__label__ lbl2;\n    \tint x = magic();\n    \tstatic void *jtab[2];\n\n    \tjtab[0] = &&lbl1;\n    \tjtab[1] = &&lbl2;\n    \tgoto *jtab[x];\n\tlbl1:\n    \treturn 1;\n\tlbl2:\n    \treturn 2;\n\t],ac_cv_prog_emu_cc=\"$CC\",ac_cv_prog_emu_cc=no)\n\tCC=$save_CC\n\tCFLAGS=$save_CFLAGS\n\tCPPFLAGS=$save_CPPFLAGS\nfi\n])\nif test \"$ac_cv_prog_emu_cc\" = no; then\n\tAC_DEFINE(NO_JUMP_TABLE,[],[Defined if no found C compiler can handle jump tables])\n\tEMU_CC=\"$CC\"\nelse\n\tEMU_CC=\"$ac_cv_prog_emu_cc\"\nfi\nAC_SUBST(EMU_CC)\n])\t\t\n\t\t\t\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_PROG_INSTALL_DIR\ndnl\ndnl This macro may be used by any OTP application.\ndnl\ndnl Figure out how to create directories with parents.\ndnl (In my opinion INSTALL_DIR is a bad name, MKSUBDIRS or something is better)\ndnl\ndnl We prefer 'install -d', but use 'mkdir -p' if it exists.\ndnl If none of these methods works, we give up.\ndnl\n\n\nAC_DEFUN(LM_PROG_INSTALL_DIR,\n[AC_CACHE_CHECK(how to create a directory including parents,\nac_cv_prog_mkdir_p,\n[\ntemp_name_base=config.$$\ntemp_name=$temp_name_base/x/y/z\n$INSTALL -d $temp_name >/dev/null 2>&1\nac_cv_prog_mkdir_p=none\nif test -d $temp_name; then\n        ac_cv_prog_mkdir_p=\"$INSTALL -d\"\nelse\n        mkdir -p $temp_name >/dev/null 2>&1\n        if test -d $temp_name; then\n                ac_cv_prog_mkdir_p=\"mkdir -p\"\n        fi\nfi\nrm -fr $temp_name_base           \n])\n\ncase \"${ac_cv_prog_mkdir_p}\" in\n  none) AC_MSG_ERROR(don't know how create directories with parents) ;;\n  *)    INSTALL_DIR=\"$ac_cv_prog_mkdir_p\" AC_SUBST(INSTALL_DIR)     ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_PROG_PERL5\ndnl\ndnl Try to find perl version 5. If found set PERL to the absolute path\ndnl of the program, if not found set PERL to false.\ndnl\ndnl On some systems /usr/bin/perl is perl 4 and e.g.\ndnl /usr/local/bin/perl is perl 5. We try to handle this case by\ndnl putting a couple of \ndnl Tries to handle the case that there are two programs called perl\ndnl in the path and one of them is perl 5 and the other isn't. \ndnl\nAC_DEFUN(LM_PROG_PERL5,\n[AC_PATH_PROGS(PERL, perl5 perl, false,\n   /usr/local/bin:/opt/local/bin:/usr/local/gnu/bin:${PATH})\nchangequote(, )dnl\ndnl[ That bracket is needed to balance the right bracket below\nif test \"$PERL\" = \"false\" || $PERL -e 'exit ($] >= 5)'; then\nchangequote([, ])dnl\n  ac_cv_path_PERL=false\n  PERL=false\ndnl  AC_MSG_WARN(perl version 5 not found)\nfi\n])dnl\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_SO_BSDCOMPAT\ndnl\ndnl Check if the system has the SO_BSDCOMPAT flag on sockets (linux) \ndnl\nAC_DEFUN(LM_DECL_SO_BSDCOMPAT,\n[AC_CACHE_CHECK([for SO_BSDCOMPAT declaration], ac_cv_decl_so_bsdcompat,\nAC_TRY_COMPILE([#include <sys/socket.h>], [int i = SO_BSDCOMPAT;],\n               ac_cv_decl_so_bsdcompat=yes,\n               ac_cv_decl_so_bsdcompat=no))\n\ncase \"${ac_cv_decl_so_bsdcompat}\" in\n  \"yes\" ) AC_DEFINE(HAVE_SO_BSDCOMPAT,[],\n\t\t[Define if you have SO_BSDCOMPAT flag on sockets]) ;;\n  * ) ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_INADDR_LOOPBACK\ndnl\ndnl Try to find declaration of INADDR_LOOPBACK, if nowhere provide a default\ndnl\n\nAC_DEFUN(LM_DECL_INADDR_LOOPBACK,\n[AC_CACHE_CHECK([for INADDR_LOOPBACK in netinet/in.h],\n ac_cv_decl_inaddr_loopback,\n[AC_TRY_COMPILE([#include <sys/types.h>\n#include <netinet/in.h>], [int i = INADDR_LOOPBACK;],\nac_cv_decl_inaddr_loopback=yes, ac_cv_decl_inaddr_loopback=no)\n])\n\nif test ${ac_cv_decl_inaddr_loopback} = no; then\n  AC_CACHE_CHECK([for INADDR_LOOPBACK in rpc/types.h],\n                   ac_cv_decl_inaddr_loopback_rpc,\n                   AC_TRY_COMPILE([#include <rpc/types.h>],\n                                   [int i = INADDR_LOOPBACK;],\n                                   ac_cv_decl_inaddr_loopback_rpc=yes,\n                                   ac_cv_decl_inaddr_loopback_rpc=no))\n\n   case \"${ac_cv_decl_inaddr_loopback_rpc}\" in\n     \"yes\" )\n        AC_DEFINE(DEF_INADDR_LOOPBACK_IN_RPC_TYPES_H,[],\n\t\t[Define if you need to include rpc/types.h to get INADDR_LOOPBACK defined]) ;;\n      * )\n  \tAC_CACHE_CHECK([for INADDR_LOOPBACK in winsock2.h],\n                   ac_cv_decl_inaddr_loopback_winsock2,\n                   AC_TRY_COMPILE([#define WIN32_LEAN_AND_MEAN\n\t\t\t\t   #include <winsock2.h>],\n                                   [int i = INADDR_LOOPBACK;],\n                                   ac_cv_decl_inaddr_loopback_winsock2=yes,\n                                   ac_cv_decl_inaddr_loopback_winsock2=no))\n\tcase \"${ac_cv_decl_inaddr_loopback_winsock2}\" in\n     \t\t\"yes\" )\n\t\t\tAC_DEFINE(DEF_INADDR_LOOPBACK_IN_WINSOCK2_H,[],\n\t\t\t\t[Define if you need to include winsock2.h to get INADDR_LOOPBACK defined]) ;;\n\t\t* )\n\t\t\t# couldn't find it anywhere\n        \t\tAC_DEFINE(HAVE_NO_INADDR_LOOPBACK,[],\n\t\t\t\t[Define if you don't have a definition of INADDR_LOOPBACK]) ;;\n\tesac;;\n   esac\nfi\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_STRUCT_SOCKADDR_SA_LEN\ndnl\ndnl Check if the sockaddr structure has the field sa_len\ndnl\n\nAC_DEFUN(LM_STRUCT_SOCKADDR_SA_LEN,\n[AC_CACHE_CHECK([whether struct sockaddr has sa_len field],\n                ac_cv_struct_sockaddr_sa_len,\nAC_TRY_COMPILE([#include <sys/types.h>\n#include <sys/socket.h>], [struct sockaddr s; s.sa_len = 10;],\n  ac_cv_struct_sockaddr_sa_len=yes, ac_cv_struct_sockaddr_sa_len=no))\n\ndnl FIXME convbreak\ncase ${ac_cv_struct_sockaddr_sa_len} in\n  \"no\" ) AC_DEFINE(NO_SA_LEN,[1],[Define if you dont have salen]) ;;\n  *) ;;\nesac\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_STRUCT_EXCEPTION\ndnl\ndnl Check to see whether the system supports the matherr function\ndnl and its associated type \"struct exception\".\ndnl\n\nAC_DEFUN(LM_STRUCT_EXCEPTION,\n[AC_CACHE_CHECK([for struct exception (and matherr function)],\n ac_cv_struct_exception,\nAC_TRY_COMPILE([#include <math.h>],\n  [struct exception x; x.type = DOMAIN; x.type = SING;],\n  ac_cv_struct_exception=yes, ac_cv_struct_exception=no))\n\ncase \"${ac_cv_struct_exception}\" in\n  \"yes\" ) AC_DEFINE(USE_MATHERR,[1],[Define if you have matherr() function and struct exception type]) ;;\n  *  ) ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_SYS_IPV6\ndnl\ndnl Check for ipv6 support and what the in6_addr structure is called.\ndnl (early linux used in_addr6 insted of in6_addr)\ndnl\n\nAC_DEFUN(LM_SYS_IPV6,\n[AC_MSG_CHECKING(for IP version 6 support)\nAC_CACHE_VAL(ac_cv_sys_ipv6_support,\n[ok_so_far=yes\n AC_TRY_COMPILE([#include <sys/types.h>\n#ifdef __WIN32__\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <netinet/in.h>\n#endif],\n   [struct in6_addr a6; struct sockaddr_in6 s6;], ok_so_far=yes, ok_so_far=no)\n\nif test $ok_so_far = yes; then\n  ac_cv_sys_ipv6_support=yes\nelse\n  AC_TRY_COMPILE([#include <sys/types.h>\n#ifdef __WIN32__\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <netinet/in.h>\n#endif],\n    [struct in_addr6 a6; struct sockaddr_in6 s6;],\n    ac_cv_sys_ipv6_support=in_addr6, ac_cv_sys_ipv6_support=no)\nfi\n])dnl\n\ndnl\ndnl Have to use old style AC_DEFINE due to BC with old autoconf.\ndnl\n\ncase ${ac_cv_sys_ipv6_support} in\n  yes)\n    AC_MSG_RESULT(yes)\n    AC_DEFINE(HAVE_IN6,[1],[Define if ipv6 is present])\n    ;;\n  in_addr6)\n    AC_MSG_RESULT([yes (but I am redefining in_addr6 to in6_addr)])\n    AC_DEFINE(HAVE_IN6,[1],[Define if ipv6 is present])\n    AC_DEFINE(HAVE_IN_ADDR6_STRUCT,[],[Early linux used in_addr6 instead of in6_addr, define if you have this])\n    ;;\n  *)\n    AC_MSG_RESULT(no)\n    ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_SYS_MULTICAST\ndnl\ndnl Check for multicast support. Only checks for multicast options in\ndnl setsockopt(), no check is performed that multicasting actually works.\ndnl If options are found defines HAVE_MULTICAST_SUPPORT\ndnl\n\nAC_DEFUN(LM_SYS_MULTICAST,\n[AC_CACHE_CHECK([for multicast support], ac_cv_sys_multicast_support,\n[AC_EGREP_CPP(^yes$,\n[#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#if defined(IP_MULTICAST_TTL) && defined(IP_MULTICAST_LOOP) && defined(IP_MULTICAST_IF) && defined(IP_ADD_MEMBERSHIP) && defined(IP_DROP_MEMBERSHIP)\nyes\n#endif\n], ac_cv_sys_multicast_support=yes, ac_cv_sys_multicast_support=no)])\nif test $ac_cv_sys_multicast_support = yes; then\n  AC_DEFINE(HAVE_MULTICAST_SUPPORT,[1],\n\t[Define if setsockopt() accepts multicast options])\nfi\n])dnl\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_SYS_ERRLIST\ndnl\ndnl Define SYS_ERRLIST_DECLARED if the variable sys_errlist is declared\ndnl in a system header file, stdio.h or errno.h.\ndnl\n\nAC_DEFUN(LM_DECL_SYS_ERRLIST,\n[AC_CACHE_CHECK([for sys_errlist declaration in stdio.h or errno.h],\n  ac_cv_decl_sys_errlist,\n[AC_TRY_COMPILE([#include <stdio.h>\n#include <errno.h>], [char *msg = *(sys_errlist + 1);],\n  ac_cv_decl_sys_errlist=yes, ac_cv_decl_sys_errlist=no)])\nif test $ac_cv_decl_sys_errlist = yes; then\n  AC_DEFINE(SYS_ERRLIST_DECLARED,[],\n\t[define if the variable sys_errlist is declared in a system header file])\nfi\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_CHECK_FUNC_DECL( funname, declaration [, extra includes \ndnl                     [, action-if-found [, action-if-not-found]]] )\ndnl\ndnl Checks if the declaration \"declaration\" of \"funname\" conflicts\ndnl with the header files idea of how the function should be\ndnl declared. It is useful on systems which lack prototypes and you\ndnl need to provide your own (e.g. when you want to take the address\ndnl of a function). The 4'th argument is expanded if conflicting, \ndnl the 5'th argument otherwise\ndnl\ndnl\n\nAC_DEFUN(LM_CHECK_FUNC_DECL,\n[AC_MSG_CHECKING([for conflicting declaration of $1])\nAC_CACHE_VAL(ac_cv_func_decl_$1,\n[AC_TRY_COMPILE([#include <stdio.h>\n$3],[$2\nchar *c = (char *)$1;\n], eval \"ac_cv_func_decl_$1=no\", eval \"ac_cv_func_decl_$1=yes\")])\nif eval \"test \\\"`echo '$ac_cv_func_decl_'$1`\\\" = yes\"; then\n  AC_MSG_RESULT(yes)\n  ifelse([$4], , :, [$4])\nelse\n  AC_MSG_RESULT(no)\nifelse([$5], , , [$5\n])dnl\nfi\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl AC_DOUBLE_MIDDLE_ENDIAN\ndnl\ndnl Checks whether doubles are represented in \"middle-endian\" format.\ndnl Sets ac_cv_double_middle_endian={no,yes,unknown} accordingly,\ndnl as well as DOUBLE_MIDDLE_ENDIAN.\ndnl\ndnl\n\nAC_DEFUN([AC_C_DOUBLE_MIDDLE_ENDIAN],\n[AC_CACHE_CHECK(whether double word ordering is middle-endian, ac_cv_c_double_middle_endian,\n[# It does not; compile a test program.\nAC_RUN_IFELSE(\n[AC_LANG_SOURCE([[#include <stdlib.h>\n\nint\nmain(void)\n{\n  int i = 0;\n  int zero = 0;\n  int bigendian;\n  int zero_index = 0;\n\n  union\n  {\n    long int l;\n    char c[sizeof (long int)];\n  } u;\n\n  /* we'll use the one with 32-bit words */\n  union\n  {\n    double d;\n    unsigned int c[2];\n  } vint;\n\n  union\n  {\n    double d;\n    unsigned long c[2];\n  } vlong;\n\n  union\n  {\n    double d;\n    unsigned short c[2];\n  } vshort;\n\n\n  /* Are we little or big endian?  From Harbison&Steele.  */\n  u.l = 1;\n  bigendian = (u.c[sizeof (long int) - 1] == 1);\n\n  zero_index = bigendian ? 1 : 0;\n\n  vint.d = 1.0;\n  vlong.d = 1.0;\n  vshort.d = 1.0;\n\n  if (sizeof(unsigned int) == 4)\n    {\n      if (vint.c[zero_index] != 0)\n\tzero = 1;\n    }\n  else if (sizeof(unsigned long) == 4)\n    {\n      if (vlong.c[zero_index] != 0)\n\tzero = 1;\n    }\n  else if (sizeof(unsigned short) == 4)\n    {\n      if (vshort.c[zero_index] != 0)\n\tzero = 1;\n    }\n\n  exit (zero);\n}\n]])],\n\t      [ac_cv_c_double_middle_endian=no],\n\t      [ac_cv_c_double_middle_endian=yes],\n\t      [ac_cv_c_double_middle=unknown])])\ncase $ac_cv_c_double_middle_endian in\n  yes)\n    m4_default([$1],\n      [AC_DEFINE([DOUBLE_MIDDLE_ENDIAN], 1,\n\t[Define to 1 if your processor stores the words in a double in\n\t middle-endian format (like some ARMs).])]) ;;\n  no)\n    $2 ;;\n  *)\n    m4_default([$3],\n      [AC_MSG_WARN([unknown double endianness\npresetting ac_cv_c_double_middle_endian=no (or yes) will help])]) ;;\nesac\n])# AC_C_DOUBLE_MIDDLE_ENDIAN\n\n\nAC_DEFUN(ERL_MONOTONIC_CLOCK,\n[\n  if test \"$3\" = \"yes\"; then\n     default_resolution_clock_gettime_monotonic=\"CLOCK_HIGHRES CLOCK_BOOTTIME CLOCK_MONOTONIC\"\n     low_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_COARSE CLOCK_MONOTONIC_FAST\"\n     high_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_PRECISE\"\n  else\n     default_resolution_clock_gettime_monotonic=\"CLOCK_HIGHRES CLOCK_UPTIME CLOCK_MONOTONIC\"\n     low_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_COARSE CLOCK_UPTIME_FAST\"\n     high_resolution_clock_gettime_monotonic=\"CLOCK_UPTIME_PRECISE\"\n  fi\n\n  case \"$1\" in\n    high_resolution)\n\tcheck_msg=\"high resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$high_resolution_clock_gettime_monotonic\"\n\t;;\n    low_resolution)\n\tcheck_msg=\"low resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$low_resolution_clock_gettime_monotonic\"\n\t;;\n    custom_resolution)\n\tcheck_msg=\"custom resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$2\"\n\t;;\n    *)\n\tcheck_msg=\"custom \"\n\tprefer_resolution_clock_gettime_monotonic=\"$2\"\n\t;;\n  esac\n\n  clock_gettime_lib=\"\"\n  AC_CHECK_LIB(rt, clock_gettime, [clock_gettime_lib=\"-lrt\"])\n\n  save_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $clock_gettime_lib\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     trust_test=\"#error May not be there due to weak linking\"\n  else\n     trust_test=\"\"\n  fi\n\n  AC_CACHE_CHECK([for clock_gettime(CLOCK_MONOTONIC_RAW, _)], erl_cv_clock_gettime_monotonic_raw,\n  [\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime(CLOCK_MONOTONIC_RAW, &ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_monotonic_raw=yes,\n\t\t      erl_cv_clock_gettime_monotonic_raw=no)\n  ])\n\n  AC_CACHE_CHECK([for clock_gettime() with ${check_msg}monotonic clock type], erl_cv_clock_gettime_monotonic_$1,\n  [\n     for clock_type in $prefer_resolution_clock_gettime_monotonic $default_resolution_clock_gettime_monotonic $high_resolution_clock_gettime_monotonic $low_resolution_clock_gettime_monotonic; do\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime($clock_type,&ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_monotonic_$1=$clock_type,\n\t\t      erl_cv_clock_gettime_monotonic_$1=no)\n       test $erl_cv_clock_gettime_monotonic_$1 = no || break\n     done\n  ])\n\n  LIBS=\"$save_LIBS\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     check_for_clock_getres=\n  else\n     check_for_clock_getres=clock_getres\n  fi\n\n  AC_CHECK_FUNCS([$check_for_clock_getres clock_get_attributes gethrtime])\n  \n  AC_CACHE_CHECK([for mach clock_get_time() with monotonic clock type], erl_cv_mach_clock_get_time_monotonic,\n  [\n     AC_TRY_COMPILE([\n#include <mach/clock.h>\n#include <mach/mach.h>\n\t\t\t],\n\t \t\t[\n    kern_return_t res;\n    clock_serv_t clk_srv;\n    mach_timespec_t time_spec;\n\n    host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &clk_srv);\n    res = clock_get_time(clk_srv, &time_spec);\n    mach_port_deallocate(mach_task_self(), clk_srv);\n    \t\t\t],\n    \t\t\terl_cv_mach_clock_get_time_monotonic=yes,\n\t\t\terl_cv_mach_clock_get_time_monotonic=no)\n  ])\n  \n  erl_corrected_monotonic_clock=no\n  case $erl_cv_clock_gettime_monotonic_$1-$ac_cv_func_gethrtime-$erl_cv_mach_clock_get_time_monotonic-$host_os in\n    *-*-*-win32)\n      erl_monotonic_clock_func=WindowsAPI\n      ;;\n    CLOCK_*-*-*-linux*)\n      case $erl_cv_clock_gettime_monotonic_$1-$erl_cv_clock_gettime_monotonic_raw in\n        CLOCK_BOOTTIME-yes|CLOCK_MONOTONIC-yes)\n\t  erl_corrected_monotonic_clock=yes\n\t  ;;\n\t*)\n\t  # We don't trust CLOCK_MONOTONIC to be NTP\n\t  # adjusted on linux systems that do not have\n\t  # CLOCK_MONOTONIC_RAW (although it seems to\n\t  # be...)\n\t  ;;\n      esac\n      erl_monotonic_clock_func=clock_gettime\n      ;;\n    no-no-no-linux*)\n      erl_monotonic_clock_func=times\n      ;;\n    CLOCK_*-*-*-*)\n      erl_monotonic_clock_func=clock_gettime\n      ;;\n    no-yes-*-*)\n      erl_monotonic_clock_func=gethrtime\n      ;;\n    no-no-yes-*)\n      erl_monotonic_clock_func=mach_clock_get_time\n      ;;\n    no-no-no-*)\n      erl_monotonic_clock_func=none\n      ;;\n  esac\n\n  erl_monotonic_clock_low_resolution=no\n  erl_monotonic_clock_lib=\n  erl_monotonic_clock_id=\n  case $erl_monotonic_clock_func in\n    clock_gettime)\n      erl_monotonic_clock_id=$erl_cv_clock_gettime_monotonic_$1\n      for low_res_id in $low_resolution_clock_gettime_monotonic; do\n      \t  if test $erl_monotonic_clock_id = $low_res_id; then\n\t    erl_monotonic_clock_low_resolution=yes\n\t    break\n\t  fi\n      done\n      erl_monotonic_clock_lib=$clock_gettime_lib\n      ;;\n    mach_clock_get_time)\n      erl_monotonic_clock_id=SYSTEM_CLOCK\n      ;;\n    times)\n      erl_monotonic_clock_low_resolution=yes\n      ;;\n    *)\n      ;;\n  esac\n \n])\n\nAC_DEFUN(ERL_WALL_CLOCK,\n[\n  default_resolution_clock_gettime_wall=\"CLOCK_REALTIME\"\n  low_resolution_clock_gettime_wall=\"CLOCK_REALTIME_COARSE CLOCK_REALTIME_FAST\"\n  high_resolution_clock_gettime_wall=\"CLOCK_REALTIME_PRECISE\"\n\n  case \"$1\" in\n    high_resolution)\n\tcheck_msg=\"high resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$high_resolution_clock_gettime_wall\"\n\t;;\n    low_resolution)\n\tcheck_msg=\"low resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$low_resolution_clock_gettime_wall\"\n\t;;\n    custom_resolution)\n\tcheck_msg=\"custom resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$2\"\n\t;;\n    *)\n\tcheck_msg=\"\"\n\tprefer_resolution_clock_gettime_wall=\n\t;;\n  esac\n\n  clock_gettime_lib=\"\"\n  AC_CHECK_LIB(rt, clock_gettime, [clock_gettime_lib=\"-lrt\"])\n\n  save_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $clock_gettime_lib\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     trust_test=\"#error May not be there due to weak linking\"\n  else\n     trust_test=\"\"\n  fi\n\n  AC_CACHE_CHECK([for clock_gettime() with ${check_msg}wall clock type], erl_cv_clock_gettime_wall_$1,\n  [\n     for clock_type in $prefer_resolution_clock_gettime_wall $default_resolution_clock_gettime_wall $high_resolution_clock_gettime_wall $low_resolution_clock_gettime_wall; do\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime($clock_type,&ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_wall_$1=$clock_type,\n\t\t      erl_cv_clock_gettime_wall_$1=no)\n       test $erl_cv_clock_gettime_wall_$1 = no || break\n     done\n  ])\n\n  LIBS=\"$save_LIBS\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     check_for_clock_getres=\n  else\n     check_for_clock_getres=clock_getres\n  fi\n\n  AC_CHECK_FUNCS([$check_for_clock_getres clock_get_attributes gettimeofday])\n  \n  AC_CACHE_CHECK([for mach clock_get_time() with wall clock type], erl_cv_mach_clock_get_time_wall,\n  [\n     AC_TRY_COMPILE([\n#include <mach/clock.h>\n#include <mach/mach.h>\n\t\t\t],\n\t \t\t[\n    kern_return_t res;\n    clock_serv_t clk_srv;\n    mach_timespec_t time_spec;\n\n    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &clk_srv);\n    res = clock_get_time(clk_srv, &time_spec);\n    mach_port_deallocate(mach_task_self(), clk_srv);\n    \t\t\t],\n    \t\t\terl_cv_mach_clock_get_time_wall=yes,\n\t\t\terl_cv_mach_clock_get_time_wall=no)\n  ])\n\n  erl_wall_clock_lib=\n  erl_wall_clock_low_resolution=no\n  erl_wall_clock_id=\n  case $1-$erl_cv_clock_gettime_wall_$1-$erl_cv_mach_clock_get_time_wall-$ac_cv_func_gettimeofday-$host_os in\n    *-*-*-*-win32)\n      erl_wall_clock_func=WindowsAPI\n      erl_wall_clock_low_resolution=yes\n      ;;\n    high_resolution-no-yes-*-*)\n      erl_wall_clock_func=mach_clock_get_time\n      erl_wall_clock_id=CALENDAR_CLOCK\n      ;;\n    *-CLOCK_*-*-*-*)\n      erl_wall_clock_func=clock_gettime\n      erl_wall_clock_lib=$clock_gettime_lib\n      erl_wall_clock_id=$erl_cv_clock_gettime_wall_$1\n      for low_res_id in $low_resolution_clock_gettime_wall; do\n      \t  if test $erl_wall_clock_id = $low_res_id; then\n\t    erl_wall_clock_low_resolution=yes\n\t    break\n\t  fi\n      done\n      ;;\n    *-no-*-yes-*)\n      erl_wall_clock_func=gettimeofday\n      ;;\n    *)\n      erl_wall_clock_func=none\n      ;;\n  esac\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_CHECK_THR_LIB\ndnl\ndnl This macro may be used by any OTP application.\ndnl\ndnl LM_CHECK_THR_LIB sets THR_LIBS, THR_DEFS, and THR_LIB_NAME. It also\ndnl checks for some pthread headers which will appear in DEFS or config.h.\ndnl\n\nAC_DEFUN(LM_CHECK_THR_LIB,\n[\n\nNEED_NPTL_PTHREAD_H=no\n\ndnl win32?\nAC_MSG_CHECKING([for native win32 threads])\nif test \"X$host_os\" = \"Xwin32\"; then\n    AC_MSG_RESULT(yes)\n    THR_DEFS=\"-DWIN32_THREADS\"\n    THR_LIBS=\n    THR_LIB_NAME=win32_threads\n    THR_LIB_TYPE=win32_threads\nelse\n    AC_MSG_RESULT(no)\n    THR_DEFS=\n    THR_LIBS=\n    THR_LIB_NAME=\n    THR_LIB_TYPE=posix_unknown\n\ndnl Try to find POSIX threads\n\ndnl The usual pthread lib...\n    AC_CHECK_LIB(pthread, pthread_create, THR_LIBS=\"-lpthread\")\n\ndnl Very old versions of FreeBSD have pthreads in special c library, c_r...\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_CHECK_LIB(c_r, pthread_create, THR_LIBS=\"-lc_r\")\n    fi\n\ndnl QNX has pthreads in standard C library\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_CHECK_FUNC(pthread_create, THR_LIBS=\"none_needed\")\n    fi\n\ndnl On ofs1 the '-pthread' switch should be used\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_MSG_CHECKING([if the '-pthread' switch can be used])\n\tsaved_cflags=$CFLAGS\n\tCFLAGS=\"$CFLAGS -pthread\"\n\tAC_TRY_LINK([#include <pthread.h>],\n\t\t    pthread_create((void*)0,(void*)0,(void*)0,(void*)0);,\n\t\t    [THR_DEFS=\"-pthread\"\n\t\t     THR_LIBS=\"-pthread\"])\n\tCFLAGS=$saved_cflags\n\tif test \"x$THR_LIBS\" != \"x\"; then\n\t    AC_MSG_RESULT(yes)\n\telse\n\t    AC_MSG_RESULT(no)\n\tfi\n    fi\n\n    if test \"x$THR_LIBS\" != \"x\"; then\n\tTHR_DEFS=\"$THR_DEFS -D_THREAD_SAFE -D_REENTRANT -DPOSIX_THREADS\"\n\tTHR_LIB_NAME=pthread\n\tif test \"x$THR_LIBS\" = \"xnone_needed\"; then\n\t    THR_LIBS=\n\tfi\n\tcase $host_os in\n\t    solaris*)\n\t\tTHR_DEFS=\"$THR_DEFS -D_POSIX_PTHREAD_SEMANTICS\" ;;\n\t    linux*)\n\t\tTHR_DEFS=\"$THR_DEFS -D_POSIX_THREAD_SAFE_FUNCTIONS\"\n\n\t\tLM_CHECK_GETCONF\n\t\tAC_MSG_CHECKING(for Native POSIX Thread Library)\n\t\tlibpthr_vsn=`$GETCONF GNU_LIBPTHREAD_VERSION 2>/dev/null`\n\t\tif test $? -eq 0; then\n\t\t    case \"$libpthr_vsn\" in\n\t\t\t*nptl*|*NPTL*) nptl=yes;;\n\t\t\t*) nptl=no;;\n\t\t    esac\n\t\telif test \"$cross_compiling\" = \"yes\"; then\n\t\t    case \"$erl_xcomp_linux_nptl\" in\n\t\t\t\"\") nptl=cross;;\n\t\t\tyes|no) nptl=$erl_xcomp_linux_nptl;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_nptl value: $erl_xcomp_linux_nptl]);;\n\t\t    esac\n\t\telse\n\t\t    nptl=no\n\t\tfi\n\t\tAC_MSG_RESULT($nptl)\n\t\tif test $nptl = cross; then\n\t\t    nptl=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $nptl = yes; then\n\t\t    THR_LIB_TYPE=posix_nptl\n\t\t    need_nptl_incldir=no\n\t\t    AC_CHECK_HEADER(nptl/pthread.h,\n\t\t\t\t    [need_nptl_incldir=yes\n\t\t\t\t     NEED_NPTL_PTHREAD_H=yes])\n\t\t    if test $need_nptl_incldir = yes; then\n\t\t\t# Ahh...\n\t\t\tnptl_path=\"$C_INCLUDE_PATH:$CPATH\"\n\t\t\tif test X$cross_compiling != Xyes; then\n\t\t\t    nptl_path=\"$nptl_path:/usr/local/include:/usr/include\"\n\t\t\telse\n\t\t\t    IROOT=\"$erl_xcomp_isysroot\"\n\t\t\t    test \"$IROOT\" != \"\" || IROOT=\"$erl_xcomp_sysroot\"\n\t\t\t    test \"$IROOT\" != \"\" || AC_MSG_ERROR([Don't know where to search for includes! Please set erl_xcomp_isysroot])\n\t\t\t    nptl_path=\"$nptl_path:$IROOT/usr/local/include:$IROOT/usr/include\"\n\t\t\tfi\n\t\t\tnptl_ws_path=\n\t\t\tsave_ifs=\"$IFS\"; IFS=\":\"\n\t\t\tfor dir in $nptl_path; do\n\t\t\t    if test \"x$dir\" != \"x\"; then\n\t\t\t\tnptl_ws_path=\"$nptl_ws_path $dir\"\n\t\t\t    fi\n\t\t\tdone\n\t\t\tIFS=$save_ifs\n\t\t\tnptl_incldir=\n\t\t\tfor dir in $nptl_ws_path; do\n\t\t            AC_CHECK_HEADER($dir/nptl/pthread.h,\n\t\t\t\t\t    nptl_incldir=$dir/nptl)\n\t\t\t    if test \"x$nptl_incldir\" != \"x\"; then\n\t\t\t\tTHR_DEFS=\"$THR_DEFS -isystem $nptl_incldir\"\n\t\t\t\tbreak\n\t\t\t    fi\n\t\t\tdone\n\t\t\tif test \"x$nptl_incldir\" = \"x\"; then\n\t\t\t    AC_MSG_ERROR(Failed to locate nptl system include directory)\n\t\t\tfi\n\t\t    fi\n\t\tfi\n\t\t;;\n\t    *) ;;\n\tesac\n\n\tdnl We sometimes need THR_DEFS in order to find certain headers\n\tdnl (at least for pthread.h on osf1).\n\tsaved_cppflags=$CPPFLAGS\n\tCPPFLAGS=\"$CPPFLAGS $THR_DEFS\"\n\n\tdnl\n\tdnl Check for headers\n\tdnl\n\n\tAC_CHECK_HEADER(pthread.h,\n\t\t\tAC_DEFINE(HAVE_PTHREAD_H, 1, \\\n[Define if you have the <pthread.h> header file.]))\n\n\tdnl Some Linuxes have <pthread/mit/pthread.h> instead of <pthread.h>\n\tAC_CHECK_HEADER(pthread/mit/pthread.h, \\\n\t\t\tAC_DEFINE(HAVE_MIT_PTHREAD_H, 1, \\\n[Define if the pthread.h header file is in pthread/mit directory.]))\n\n\tdnl restore CPPFLAGS\n\tCPPFLAGS=$saved_cppflags\n\n    fi\nfi\n\n])\n\nAC_DEFUN(ERL_INTERNAL_LIBS,\n[\n\nERTS_INTERNAL_X_LIBS=\n\nAC_CHECK_LIB(kstat, kstat_open,\n[AC_DEFINE(HAVE_KSTAT, 1, [Define if you have kstat])\nERTS_INTERNAL_X_LIBS=\"$ERTS_INTERNAL_X_LIBS -lkstat\"])\n\nAC_SUBST(ERTS_INTERNAL_X_LIBS)\n\n])\n\nAC_DEFUN(ETHR_CHK_GCC_ATOMIC_OP__,\n[\n    # $1 - atomic_op\n\n    for atomic_bit_size in 32 64 128; do\n\tcase $atomic_bit_size in\n\t    32) gcc_atomic_type=\"$gcc_atomic_type32\";;\n\t    64) gcc_atomic_type=\"$gcc_atomic_type64\";;\n\t    128) gcc_atomic_type=\"$gcc_atomic_type128\";;\n\tesac\n\tgcc_atomic_lockfree=\"int x[[(2*__atomic_always_lock_free(sizeof($gcc_atomic_type), 0))-1]]\"\n\tcase $1 in\n\t    __sync_add_and_fetch | __sync_fetch_and_and | __sync_fetch_and_or)\n\t\tatomic_call=\"volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0);\"\n\t\t;;\n\t    __sync_val_compare_and_swap)\n\t\tatomic_call=\"volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0, ($gcc_atomic_type) 0);\"\n\t\t;;\n\t    __atomic_store_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELAXED); $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELEASE);\"\n\t\t;;\n\t    __atomic_load_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, __ATOMIC_RELAXED); res = $1(&var, __ATOMIC_ACQUIRE);\"\n\t\t;;\n\t    __atomic_add_fetch| __atomic_fetch_and | __atomic_fetch_or)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELAXED); res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_ACQUIRE); res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELEASE);\"\n\t\t;;\n\t    __atomic_compare_exchange_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type val; int res = $1(&var, &val, ($gcc_atomic_type) 0, 0, __ATOMIC_RELAXED, __ATOMIC_RELAXED); res = $1(&var, &val, ($gcc_atomic_type) 0, 0, __ATOMIC_ACQUIRE, __ATOMIC_ACQUIRE);\"\n\t\t;;\n\t    *)\n\t\tAC_MSG_ERROR([Internal error: missing implementation for $1])\n\t\t;;\n\tesac\n\teval atomic${atomic_bit_size}_call=\\\"$atomic_call\\\"\n    done\n    \n    AC_CACHE_CHECK([for 32-bit $1()], ethr_cv_32bit_$1,\n\t\t   [\n\t\t       ethr_cv_32bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic32_call], [ethr_cv_32bit_$1=yes])\n\t\t   ])\n    AC_CACHE_CHECK([for 64-bit $1()], ethr_cv_64bit_$1,\n\t\t   [\n\t\t       ethr_cv_64bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic64_call], [ethr_cv_64bit_$1=yes])\n\t\t   ])\n    AC_CACHE_CHECK([for 128-bit $1()], ethr_cv_128bit_$1,\n\t\t   [\n\t\t       ethr_cv_128bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic128_call], [ethr_cv_128bit_$1=yes])\n\t\t   ])\n\n\tcase $ethr_cv_128bit_$1-$ethr_cv_64bit_$1-$ethr_cv_32bit_$1 in\n\t    no-no-no)\n\t\thave_atomic_ops=0;;\n\t    no-no-yes)\n\t\thave_atomic_ops=4;;\n\t    no-yes-no)\n\t\thave_atomic_ops=8;;\n\t    no-yes-yes)\n\t\thave_atomic_ops=12;;\n\t    yes-no-no)\n\t\thave_atomic_ops=16;;\n\t    yes-no-yes)\n\t\thave_atomic_ops=20;;\n\t    yes-yes-no)\n\t\thave_atomic_ops=24;;\n\t    yes-yes-yes)\n\t\thave_atomic_ops=28;;\n\tesac\n\tAC_DEFINE_UNQUOTED([ETHR_HAVE_$1], [$have_atomic_ops], [Define as a bitmask corresponding to the word sizes that $1() can handle on your system])\n])\n\nAC_DEFUN(ETHR_CHK_IF_NOOP,\n[\n   ethr_test_filename=\"chk_if_$1$3_noop_config1test.$$\"\n   cat > \"${ethr_test_filename}.c\" <<EOF\nint\nmy_test(void)\n{\n    $1$2;\n    return 0;\n}\nEOF\n   $CC -O3 $ETHR_DEFS -c \"${ethr_test_filename}.c\" -o \"${ethr_test_filename}1.o\"\n   cat > \"${ethr_test_filename}.c\" <<EOF\nint\nmy_test(void)\n{\n    ;\n    return 0;\n}\nEOF\n   $CC -O3 $ETHR_DEFS -c \"${ethr_test_filename}.c\" -o \"${ethr_test_filename}2.o\"\n   if diff \"${ethr_test_filename}1.o\" \"${ethr_test_filename}2.o\" >/dev/null 2>&1; then\n      ethr_$1$3_noop=yes\n   else\n      ethr_$1$3_noop=no\n   fi\n   rm -f \"${ethr_test_filename}.c\" \"${ethr_test_filename}1.o\"  \"${ethr_test_filename}2.o\" \n])\n\nAC_DEFUN(ETHR_CHK_GCC_ATOMIC_OPS,\n[\n    AC_CHECK_SIZEOF(short)\n    AC_CHECK_SIZEOF(int)\n    AC_CHECK_SIZEOF(long)\n    AC_CHECK_SIZEOF(long long)\n    AC_CHECK_SIZEOF(__int128_t)\n\n    if test \"$ac_cv_sizeof_short\" = \"4\"; then\n\tgcc_atomic_type32=\"short\"\n    elif test \"$ac_cv_sizeof_int\" = \"4\"; then\n\tgcc_atomic_type32=\"int\"\n    elif test \"$ac_cv_sizeof_long\" = \"4\"; then\n\tgcc_atomic_type32=\"long\"\n    else\n\tAC_MSG_ERROR([No 32-bit type found])\n    fi\n\n    if test \"$ac_cv_sizeof_int\" = \"8\"; then\n\tgcc_atomic_type64=\"int\"\n    elif test \"$ac_cv_sizeof_long\" = \"8\"; then\n\tgcc_atomic_type64=\"long\"\n    elif test \"$ac_cv_sizeof_long_long\" = \"8\"; then\n\tgcc_atomic_type64=\"long long\"\n    else\n\tAC_MSG_ERROR([No 64-bit type found])\n    fi\n\n    if test \"$ac_cv_sizeof___int128_t\" = \"16\"; then\n\tgcc_atomic_type128=\"__int128_t\"\n    else\n\tgcc_atomic_type128=\"#error \"\t\n    fi\n    AC_CACHE_CHECK([for a working __sync_synchronize()], ethr_cv___sync_synchronize,\n\t\t   [\n\t\t       ethr_cv___sync_synchronize=no\n\t\t       AC_TRY_LINK([],\n\t\t\t\t   [ __sync_synchronize(); ],\n\t\t\t\t   [ethr_cv___sync_synchronize=yes])\n\t\t       if test $ethr_cv___sync_synchronize = yes; then\n\t\t\t   #\n\t\t\t   # Old gcc versions on at least x86 have a buggy\n\t\t\t   # __sync_synchronize() which does not emit a\n\t\t\t   # memory barrier. We try to detect this by\n\t\t\t   # compiling to assembly with and without\n\t\t\t   # __sync_synchronize() and compare the results.\n\t\t\t   #\n\t\t\t   ETHR_CHK_IF_NOOP(__sync_synchronize, [()], [])\n\t\t\t   if test $ethr___sync_synchronize_noop = yes; then\n\t\t\t      # Got a buggy implementation of\n\t\t\t      # __sync_synchronize...\n\t\t\t      ethr_cv___sync_synchronize=\"no; buggy implementation\"\n\t\t\t   fi\n\t\t       fi\n\t\t   ])\n\n    if test \"$ethr_cv___sync_synchronize\" = \"yes\"; then\n\thave_sync_synchronize_value=\"~0\"\n    else\n\thave_sync_synchronize_value=\"0\"\n    fi\n    AC_DEFINE_UNQUOTED([ETHR_HAVE___sync_synchronize], [$have_sync_synchronize_value], [Define as a bitmask corresponding to the word sizes that __sync_synchronize() can handle on your system])\n\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_add_and_fetch)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_fetch_and_and)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_fetch_and_or)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_val_compare_and_swap)\n\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_store_n)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_load_n)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_add_fetch)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_fetch_and)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_fetch_or)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_compare_exchange_n)\n\n    ethr_have_gcc_native_atomics=no\n    ethr_arm_dbm_instr_val=0\n    case \"$GCC-$host_cpu\" in\n\tyes-arm*)\n\t    AC_CACHE_CHECK([for ARM DMB instruction], ethr_cv_arm_dbm_instr,\n\t\t\t   [\n\t\t\t\tethr_cv_arm_dbm_instr=no\n\t\t\t\tAC_TRY_LINK([],\n\t\t\t\t\t    [\n\t\t\t\t\t\t__asm__ __volatile__(\"dmb sy\" : : : \"memory\");\n\t\t\t\t\t\t__asm__ __volatile__(\"dmb st\" : : : \"memory\");\n\t\t\t\t\t    ],\n\t\t\t\t\t    [ethr_cv_arm_dbm_instr=yes])\n\t\t\t   ])\n\t    if test $ethr_cv_arm_dbm_instr = yes; then\n\t\tethr_arm_dbm_instr_val=1\n\t\ttest $ethr_cv_64bit___atomic_compare_exchange_n = yes &&\n\t\t    ethr_have_gcc_native_atomics=yes\n\t    fi;;\n\t*)\n\t    ;;\n    esac\n    AC_DEFINE_UNQUOTED([ETHR_HAVE_GCC_ASM_ARM_DMB_INSTRUCTION], [$ethr_arm_dbm_instr_val], [Define as a boolean indicating whether you have a gcc compatible compiler capable of generating the ARM DMB instruction, and are compiling for an ARM processor with ARM DMB instruction support, or not])\n    test $ethr_cv_32bit___sync_val_compare_and_swap = yes &&\n    \tethr_have_gcc_native_atomics=yes\n    test $ethr_cv_64bit___sync_val_compare_and_swap = yes &&\n    \tethr_have_gcc_native_atomics=yes\n    if test \"$ethr_cv___sync_synchronize\" = \"yes\"; then\n    \ttest $ethr_cv_64bit___atomic_compare_exchange_n = yes &&\n    \t    ethr_have_gcc_native_atomics=yes\n    \ttest $ethr_cv_32bit___atomic_compare_exchange_n = yes &&\n    \t    ethr_have_gcc_native_atomics=yes\n    fi\n    ethr_have_gcc_atomic_builtins=0\n    if test $ethr_have_gcc_native_atomics = yes; then\n       ethr_native_atomic_implementation=gcc_sync\n       test $ethr_cv_32bit___atomic_compare_exchange_n = yes && ethr_have_gcc_atomic_builtins=1\n       test $ethr_cv_64bit___atomic_compare_exchange_n = yes && ethr_have_gcc_atomic_builtins=1\n       test $ethr_have_gcc_atomic_builtins = 1 && ethr_native_atomic_implementation=gcc_atomic_sync\n    fi\n    AC_DEFINE_UNQUOTED([ETHR_HAVE_GCC___ATOMIC_BUILTINS], [$ethr_have_gcc_atomic_builtins], [Define as a boolean indicating whether you have a gcc __atomic builtins or not])\n    test $ethr_have_gcc_native_atomics = yes && ethr_have_native_atomics=yes\n])\n\nAC_DEFUN(ETHR_CHK_INTERLOCKED,\n[\n    ilckd=\"$1\"\n    AC_MSG_CHECKING([for ${ilckd}()])\n    case \"$2\" in\n\t\"1\") ilckd_call=\"${ilckd}(var);\";;\n\t\"2\") ilckd_call=\"${ilckd}(var, ($3) 0);\";;\n\t\"3\") ilckd_call=\"${ilckd}(var, ($3) 0, ($3) 0);\";;\n\t\"4\") ilckd_call=\"${ilckd}(var, ($3) 0, ($3) 0, arr);\";;\n    esac\n    have_interlocked_op=no\n    AC_TRY_LINK(\n\t[\n\t#define WIN32_LEAN_AND_MEAN\n\t#include <windows.h>\n\t#include <intrin.h>\n\t],\n\t[\n\t    volatile $3 *var;\n\t    volatile $3 arr[2];\n\n\t    $ilckd_call\n\t    return 0;\n\t],\n\t[have_interlocked_op=yes])\n    test $have_interlocked_op = yes && $4\n    AC_MSG_RESULT([$have_interlocked_op])\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl ERL_FIND_ETHR_LIB\ndnl\ndnl NOTE! This macro may be changed at any time! Should *only* be used by\ndnl       ERTS!\ndnl\ndnl Find a thread library to use. Sets ETHR_LIBS to libraries to link\ndnl with, ETHR_X_LIBS to extra libraries to link with (same as ETHR_LIBS\ndnl except that the ethread lib itself is not included), ETHR_DEFS to\ndnl defines to compile with, ETHR_THR_LIB_BASE to the name of the\ndnl thread library which the ethread library is based on, and ETHR_LIB_NAME\ndnl to the name of the library where the ethread implementation is located.\ndnl  ERL_FIND_ETHR_LIB currently searches for 'pthreads', and\ndnl 'win32_threads'. If no thread library was found ETHR_LIBS, ETHR_X_LIBS,\ndnl ETHR_DEFS, ETHR_THR_LIB_BASE, and ETHR_LIB_NAME are all set to the\ndnl empty string.\ndnl\n\nAC_DEFUN(ERL_FIND_ETHR_LIB,\n[\n\nAC_ARG_ENABLE(native-ethr-impls,\n\t      AS_HELP_STRING([--disable-native-ethr-impls],\n                             [disable native ethread implementations]),\n[ case \"$enableval\" in\n    no) disable_native_ethr_impls=yes ;;\n    *)  disable_native_ethr_impls=no ;;\n  esac ], disable_native_ethr_impls=no)\n\ntest \"X$disable_native_ethr_impls\" = \"Xyes\" &&\n  AC_DEFINE(ETHR_DISABLE_NATIVE_IMPLS, 1, [Define if you want to disable native ethread implementations])\n\nAC_ARG_ENABLE(x86-out-of-order,\n\t      AS_HELP_STRING([--enable-x86-out-of-order],\n                             [enable x86/x84_64 out of order support (default disabled)]))\n\nAC_ARG_ENABLE(prefer-gcc-native-ethr-impls,\n\t      AS_HELP_STRING([--enable-prefer-gcc-native-ethr-impls],\n\t\t\t     [prefer gcc native ethread implementations]),\n[ case \"$enableval\" in\n    yes) enable_prefer_gcc_native_ethr_impls=yes ;;\n    *)  enable_prefer_gcc_native_ethr_impls=no ;;\n  esac ], enable_prefer_gcc_native_ethr_impls=no)\n\ntest $enable_prefer_gcc_native_ethr_impls = yes &&\n  AC_DEFINE(ETHR_PREFER_GCC_NATIVE_IMPLS, 1, [Define if you prefer gcc native ethread implementations])\n\nAC_ARG_ENABLE(trust-gcc-atomic-builtins-memory-barriers,\n\t      AS_HELP_STRING([--enable-trust-gcc-atomic-builtins-memory-barriers],\n\t\t\t     [trust gcc atomic builtins memory barriers]),\n[ case \"$enableval\" in\n    yes) trust_gcc_atomic_builtins_mbs=1 ;;\n    *) trust_gcc_atomic_builtins_mbs=0 ;;\n  esac ], trust_gcc_atomic_builtins_mbs=0)\n\nAC_DEFINE_UNQUOTED(ETHR_TRUST_GCC_ATOMIC_BUILTINS_MEMORY_BARRIERS, [$trust_gcc_atomic_builtins_mbs], [Define as a boolean indicating whether you trust gcc's __atomic_* builtins memory barrier implementations, or not])\n\nAC_ARG_WITH(libatomic_ops,\n\t    AS_HELP_STRING([--with-libatomic_ops=PATH],\n\t\t\t   [specify and prefer usage of libatomic_ops in the ethread library]))\n\nAC_ARG_WITH(with_sparc_memory_order,\n\t    AS_HELP_STRING([--with-sparc-memory-order=TSO|PSO|RMO],\n\t\t\t   [specify sparc memory order (defaults to RMO)]))\n\nLM_CHECK_THR_LIB\nERL_INTERNAL_LIBS\n\nERL_MONOTONIC_CLOCK(try_find_pthread_compatible, CLOCK_HIGHRES CLOCK_MONOTONIC, no)\n\ncase $erl_monotonic_clock_func in\n  clock_gettime)\n    AC_DEFINE(ETHR_HAVE_CLOCK_GETTIME_MONOTONIC, [1], [Define if you have a clock_gettime() with a monotonic clock])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(ETHR_HAVE_MACH_CLOCK_GET_TIME, [1], [Define if you have a mach clock_get_time() with a monotonic clock])\n    ;;\n  gethrtime)\n    AC_DEFINE(ETHR_HAVE_GETHRTIME, [1], [Define if you have a monotonic gethrtime()])\n    ;;\n  *)\n    ;;\nesac\n\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(ETHR_MONOTONIC_CLOCK_ID, [$erl_monotonic_clock_id], [Define to the monotonic clock id to use])\nfi\n\nethr_native_atomic_implementation=none\nethr_have_native_atomics=no\nethr_have_native_spinlock=no\nETHR_THR_LIB_BASE=\"$THR_LIB_NAME\"\nETHR_THR_LIB_BASE_TYPE=\"$THR_LIB_TYPE\"\nETHR_DEFS=\"$THR_DEFS\"\nETHR_X_LIBS=\"$THR_LIBS $ERTS_INTERNAL_X_LIBS $erl_monotonic_clock_lib\"\nETHR_LIBS=\nETHR_LIB_NAME=\n\nethr_modified_default_stack_size=\n\nAC_ARG_WITH(threadnames,\nAS_HELP_STRING([--with-threadnames], [use pthread_setname to set the thread names (default)])\nAS_HELP_STRING([--without-threadnames],\n               [do not set any thread names]),\n[],\n[with_threadnames=yes])\n\ndnl Name of lib where ethread implementation is located\nethr_lib_name=ethread\n\ncase \"$THR_LIB_NAME\" in\n\n    win32_threads)\n\tETHR_THR_LIB_BASE_DIR=win\n\t# * _WIN32_WINNT >= 0x0400 is needed for\n\t#   TryEnterCriticalSection\n\t# * _WIN32_WINNT >= 0x0403 is needed for\n\t#   InitializeCriticalSectionAndSpinCount\n\t# The ethread lib will refuse to build if _WIN32_WINNT < 0x0403.\n\t#\n\t# -D_WIN32_WINNT should have been defined in $CPPFLAGS; fetch it\n\t# and save it in ETHR_DEFS.\n\tfound_win32_winnt=no\n\tfor cppflag in $CPPFLAGS; do\n\t    case $cppflag in\n\t\t-DWINVER*)\n\t\t    ETHR_DEFS=\"$ETHR_DEFS $cppflag\"\n\t\t    ;;\n\t\t-D_WIN32_WINNT*)\n\t\t    ETHR_DEFS=\"$ETHR_DEFS $cppflag\"\n\t\t    found_win32_winnt=yes\n\t\t    ;;\n\t\t*)\n\t\t    ;;\n\t    esac\n        done\n        if test $found_win32_winnt = no; then\n\t    AC_MSG_ERROR([-D_WIN32_WINNT missing in CPPFLAGS])\n        fi\n\n\tAC_DEFINE(ETHR_WIN32_THREADS, 1, [Define if you have win32 threads])\n\n\tif test \"X$disable_native_ethr_impls\" = \"Xyes\"; then\n\t    have_interlocked_op=no\n\t    ethr_have_native_atomics=no\n\telse\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT, 1, [Define if you have _InterlockedDecrement()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement_rel], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT_REL, 1, [Define if you have _InterlockedDecrement_rel()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT, 1, [Define if you have _InterlockedIncrement()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement_acq], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT_ACQ, 1, [Define if you have _InterlockedIncrement_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD, 1, [Define if you have _InterlockedExchangeAdd()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd_acq], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD_ACQ, 1, [Define if you have _InterlockedExchangeAdd_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedAnd], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDAND, 1, [Define if you have _InterlockedAnd()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedOr], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDOR, 1, [Define if you have _InterlockedOr()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchange], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGE, 1, [Define if you have _InterlockedExchange()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE, 1, [Define if you have _InterlockedCompareExchange()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange_acq], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE_ACQ, 1, [Define if you have _InterlockedCompareExchange_acq()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange_rel], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE_REL, 1, [Define if you have _InterlockedCompareExchange_rel()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement64], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT64, 1, [Define if you have _InterlockedDecrement64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement64_rel], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT64_REL, 1, [Define if you have _InterlockedDecrement64_rel()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement64], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT64, 1, [Define if you have _InterlockedIncrement64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement64_acq], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT64_ACQ, 1, [Define if you have _InterlockedIncrement64_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD64, 1, [Define if you have _InterlockedExchangeAdd64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd64_acq], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD64_ACQ, 1, [Define if you have _InterlockedExchangeAdd64_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedAnd64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDAND64, 1, [Define if you have _InterlockedAnd64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedOr64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDOR64, 1, [Define if you have _InterlockedOr64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchange64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGE64, 1, [Define if you have _InterlockedExchange64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64, 1, [Define if you have _InterlockedCompareExchange64()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64_acq], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64_ACQ, 1, [Define if you have _InterlockedCompareExchange64_acq()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64_rel], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64_REL, 1, [Define if you have _InterlockedCompareExchange64_rel()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange128], [4], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE128, 1, [Define if you have _InterlockedCompareExchange128()]))\n\tfi\n\tif test \"$ethr_have_native_atomics\" = \"yes\"; then\n\t   ethr_native_atomic_implementation=windows\n\t   ethr_have_native_spinlock=yes\n\tfi\n\t;;\n\n    pthread)\n\tETHR_THR_LIB_BASE_DIR=pthread\n\tAC_DEFINE(ETHR_PTHREADS, 1, [Define if you have pthreads])\n\tcase $host_os in\n\t    openbsd*)\n\t\t# The default stack size is insufficient for our needs\n\t\t# on OpenBSD. We increase it to 256 kilo words.\n\t\tethr_modified_default_stack_size=256;;\n\t    linux*)\n\t\tETHR_DEFS=\"$ETHR_DEFS -D_GNU_SOURCE\"\n\n\t\tif test\tX$cross_compiling = Xyes; then\n\t\t    case X$erl_xcomp_linux_usable_sigusrx in\n\t\t\tX) usable_sigusrx=cross;;\n\t\t\tXyes|Xno) usable_sigusrx=$erl_xcomp_linux_usable_sigusrx;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_usable_sigusrx value: $erl_xcomp_linux_usable_sigusrx]);;\n\t\t    esac\n\t\t    case X$erl_xcomp_linux_usable_sigaltstack in\n\t\t\tX) usable_sigaltstack=cross;;\n\t\t\tXyes|Xno) usable_sigaltstack=$erl_xcomp_linux_usable_sigaltstack;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_usable_sigaltstack value: $erl_xcomp_linux_usable_sigaltstack]);;\n\t\t    esac\n\t\telse\n\t\t    # FIXME: Test for actual problems instead of kernel versions\n\t\t    linux_kernel_vsn_=`uname -r`\n\t\t    case $linux_kernel_vsn_ in\n\t\t\t[[0-1]].*|2.[[0-1]]|2.[[0-1]].*)\n\t\t\t    usable_sigusrx=no\n\t\t\t    usable_sigaltstack=no;;\n\t\t\t2.[[2-3]]|2.[[2-3]].*)\n\t\t\t    usable_sigusrx=yes\n\t\t\t    usable_sigaltstack=no;;\n\t\t    \t*)\n\t\t\t    usable_sigusrx=yes\n\t\t\t    usable_sigaltstack=yes;;\n\t\t    esac\n\t\tfi\n\n\t\tAC_MSG_CHECKING(if SIGUSR1 and SIGUSR2 can be used)\n\t\tAC_MSG_RESULT($usable_sigusrx)\n\t\tif test $usable_sigusrx = cross; then\n\t\t    usable_sigusrx=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $usable_sigusrx = no; then\n\t\t    ETHR_DEFS=\"$ETHR_DEFS -DETHR_UNUSABLE_SIGUSRX\"\n\t\tfi\n\n\t\tAC_MSG_CHECKING(if sigaltstack can be used)\n\t\tAC_MSG_RESULT($usable_sigaltstack)\n\t\tif test $usable_sigaltstack = cross; then\n\t\t    usable_sigaltstack=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $usable_sigaltstack = no; then\n\t\t    ETHR_DEFS=\"$ETHR_DEFS -DETHR_UNUSABLE_SIGALTSTACK\"\n\t\tfi\n\t\t;;\n\t    *) ;;\n\tesac\n\n\tdnl We sometimes need ETHR_DEFS in order to find certain headers\n\tdnl (at least for pthread.h on osf1).\n\tsaved_cppflags=\"$CPPFLAGS\"\n\tCPPFLAGS=\"$CPPFLAGS $ETHR_DEFS\"\n\n\tdnl We need the thread library in order to find some functions\n\tsaved_libs=\"$LIBS\"\n\tLIBS=\"$LIBS $ETHR_X_LIBS\"\n\n\tdnl\n\tdnl Check for headers\n\tdnl\n\tAC_CHECK_HEADER(pthread.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_H, 1, \\\n[Define if you have the <pthread.h> header file.]))\n\n\tdnl Some Linuxes have <pthread/mit/pthread.h> instead of <pthread.h>\n\tAC_CHECK_HEADER(pthread/mit/pthread.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_MIT_PTHREAD_H, 1, \\\n[Define if the pthread.h header file is in pthread/mit directory.]))\n\n\tif test $NEED_NPTL_PTHREAD_H = yes; then\n\t    AC_DEFINE(ETHR_NEED_NPTL_PTHREAD_H, 1, \\\n[Define if you need the <nptl/pthread.h> header file.])\n\tfi\n\n\tAC_CHECK_HEADER(sched.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_SCHED_H, 1, \\\n[Define if you have the <sched.h> header file.]))\n\n\tAC_CHECK_HEADER(sys/time.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_SYS_TIME_H, 1, \\\n[Define if you have the <sys/time.h> header file.]))\n\n\tAC_TRY_COMPILE([#include <time.h>\n\t\t\t#include <sys/time.h>], \n\t\t\t[struct timeval *tv; return 0;],\n\t\t\tAC_DEFINE(ETHR_TIME_WITH_SYS_TIME, 1, \\\n[Define if you can safely include both <sys/time.h> and <time.h>.]))\n\n\tAC_MSG_CHECKING([for usable PTHREAD_STACK_MIN])\n\tpthread_stack_min=no\n\tAC_TRY_COMPILE([\n#include <limits.h>\n#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n#include <nptl/pthread.h>\n#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n#include <pthread/mit/pthread.h>\n#elif defined(ETHR_HAVE_PTHREAD_H)\n#include <pthread.h>\n#endif\n\t\t\t], \n\t\t\t[return PTHREAD_STACK_MIN;],\n\t\t\t[pthread_stack_min=yes])\n\n\tAC_MSG_RESULT([$pthread_stack_min])\n\ttest $pthread_stack_min != yes || {\n\t     AC_DEFINE(ETHR_HAVE_USABLE_PTHREAD_STACK_MIN, 1, [Define if you can use PTHREAD_STACK_MIN])\n\t}\n\n\tdnl\n\tdnl Check for functions\n\tdnl\n\tAC_CHECK_FUNC(pthread_spin_lock, \\\n\t\t\t[ethr_have_native_spinlock=yes \\\n\t\t\t AC_DEFINE(ETHR_HAVE_PTHREAD_SPIN_LOCK, 1, \\\n[Define if you have the pthread_spin_lock function.])])\n\n\thave_sched_yield=no\n\thave_librt_sched_yield=no\n\tAC_CHECK_FUNC(sched_yield, [have_sched_yield=yes])\n\tif test $have_sched_yield = no; then\n\t    AC_CHECK_LIB(rt, sched_yield,\n\t\t\t [have_librt_sched_yield=yes\n\t\t\t  ETHR_X_LIBS=\"$ETHR_X_LIBS -lrt\"])\n\tfi\n\tif test $have_sched_yield = yes || test $have_librt_sched_yield = yes; then\n\t    AC_DEFINE(ETHR_HAVE_SCHED_YIELD, 1, [Define if you have the sched_yield() function.])\n\t    AC_MSG_CHECKING([whether sched_yield() returns an int])\n\t    sched_yield_ret_int=no\n\t    AC_TRY_LINK([\n\t\t\t\t#ifdef ETHR_HAVE_SCHED_H\n\t\t\t\t#include <sched.h>\n\t\t\t\t#endif\n\t\t\t   ],\n\t\t\t   [int sched_yield();],\n\t\t\t   [sched_yield_ret_int=yes])\n\t    AC_MSG_RESULT([$sched_yield_ret_int])\n\t    if test $sched_yield_ret_int = yes; then\n\t\tAC_DEFINE(ETHR_SCHED_YIELD_RET_INT, 1, [Define if sched_yield() returns an int.])\n\t    fi\n\tfi\n\n\thave_pthread_yield=no\n\tAC_CHECK_FUNC(pthread_yield, [have_pthread_yield=yes])\n\tif test $have_pthread_yield = yes; then\n\t    AC_DEFINE(ETHR_HAVE_PTHREAD_YIELD, 1, [Define if you have the pthread_yield() function.])\n\t    AC_MSG_CHECKING([whether pthread_yield() returns an int])\n\t    pthread_yield_ret_int=no\n\t    AC_TRY_LINK([\n\t\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t\t#include <nptl/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t\t#include <pthread/mit/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t\t#include <pthread.h>\n\t\t\t\t#endif\n\t\t\t   ],\n\t\t\t   [int pthread_yield();],\n\t\t\t   [pthread_yield_ret_int=yes])\n\t    AC_MSG_RESULT([$pthread_yield_ret_int])\n\t    if test $pthread_yield_ret_int = yes; then\n\t\tAC_DEFINE(ETHR_PTHREAD_YIELD_RET_INT, 1, [Define if pthread_yield() returns an int.])\n\t    fi\n\tfi\n\n\thave_pthread_rwlock_init=no\n\tAC_CHECK_FUNC(pthread_rwlock_init, [have_pthread_rwlock_init=yes])\n\tif test $have_pthread_rwlock_init = yes; then\n\n\t    ethr_have_pthread_rwlockattr_setkind_np=no\n\t    AC_CHECK_FUNC(pthread_rwlockattr_setkind_np,\n\t\t\t  [ethr_have_pthread_rwlockattr_setkind_np=yes])\n\n\t    if test $ethr_have_pthread_rwlockattr_setkind_np = yes; then\n\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_RWLOCKATTR_SETKIND_NP, 1, \\\n[Define if you have the pthread_rwlockattr_setkind_np() function.])\n\n\t\tAC_MSG_CHECKING([for PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP])\n\t\tethr_pthread_rwlock_writer_nonrecursive_initializer_np=no\n\t\tAC_TRY_LINK([\n\t\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t\t#include <nptl/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t\t#include <pthread/mit/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t\t#include <pthread.h>\n\t\t\t\t#endif\n\t\t\t    ],\n\t\t\t    [\n\t\t\t\tpthread_rwlockattr_t *attr;\n\t\t\t\treturn pthread_rwlockattr_setkind_np(attr,\n\t\t\t\t    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n\t\t\t    ],\n\t\t\t    [ethr_pthread_rwlock_writer_nonrecursive_initializer_np=yes])\n\t\tAC_MSG_RESULT([$ethr_pthread_rwlock_writer_nonrecursive_initializer_np])\n\t\tif test $ethr_pthread_rwlock_writer_nonrecursive_initializer_np = yes; then\n\t\t    AC_DEFINE(ETHR_HAVE_PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, 1, \\\n[Define if you have the PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP rwlock attribute.])\n\t\tfi\n\t    fi\n\tfi\n\n\tif test \"$force_pthread_rwlocks\" = \"yes\"; then\n\n\t    AC_DEFINE(ETHR_FORCE_PTHREAD_RWLOCK, 1, \\\n[Define if you want to force usage of pthread rwlocks])\n\n\t    if test $have_pthread_rwlock_init = yes; then\n\t\tAC_MSG_WARN([Forced usage of pthread rwlocks. Note that this implementation may suffer from starvation issues.])\n\t    else\n\t\tAC_MSG_ERROR([User forced usage of pthread rwlock, but no such implementation was found])\n\t    fi\n\tfi\n\n\tAC_CHECK_FUNC(pthread_attr_setguardsize, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_ATTR_SETGUARDSIZE, 1, \\\n[Define if you have the pthread_attr_setguardsize function.]))\n\n\tif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n\t  AC_MSG_CHECKING(whether pthread_cond_timedwait() can use the monotonic clock $erl_monotonic_clock_id for timeout)\n\t  pthread_cond_timedwait_monotonic=no\n\t  AC_TRY_LINK([\n\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t#  include <nptl/pthread.h>\n\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t#  include <pthread/mit/pthread.h>\n\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t#  include <pthread.h>\n\t\t\t#endif\n\t\t\t#ifdef ETHR_TIME_WITH_SYS_TIME\n\t\t\t#  include <time.h>\n\t\t\t#  include <sys/time.h>\n\t\t\t#else\n\t\t\t#  ifdef ETHR_HAVE_SYS_TIME_H\n\t\t\t#    include <sys/time.h>\n\t\t\t#  else\n\t\t\t#    include <time.h>\n\t\t\t#  endif\n\t\t\t#endif\n\t\t\t#if defined(ETHR_HAVE_MACH_CLOCK_GET_TIME)\n\t\t\t#  include <mach/clock.h>\n\t\t\t#  include <mach/mach.h>\n\t\t\t#endif\n\t\t\t], \n\t\t\t[\n\t\t\tint res;\n\t\t\tpthread_condattr_t attr;\n\t\t\tpthread_cond_t cond;\n\t\t\tstruct timespec cond_timeout;\n\t\t\tpthread_mutex_t mutex;\n\t\t\tres = pthread_condattr_init(&attr);\n\t\t\tres = pthread_condattr_setclock(&attr, ETHR_MONOTONIC_CLOCK_ID);\n\t\t\tres = pthread_cond_init(&cond, &attr);\n\t\t\tres = pthread_cond_timedwait(&cond, &mutex, &cond_timeout);\n\t\t\t],\n\t\t\t[pthread_cond_timedwait_monotonic=yes])\n\t  AC_MSG_RESULT([$pthread_cond_timedwait_monotonic])\n\t  if test $pthread_cond_timedwait_monotonic = yes; then\n\t    AC_DEFINE(ETHR_HAVE_PTHREAD_COND_TIMEDWAIT_MONOTONIC, [1], [Define if pthread_cond_timedwait() can be used with a monotonic clock])\n\t  fi\n\tfi\n\n\tlinux_futex=no\n\tAC_MSG_CHECKING([for Linux futexes])\n\tAC_TRY_LINK([\n\t\t\t#include <sys/syscall.h>\n\t\t\t#include <unistd.h>\n\t\t\t#include <linux/futex.h>\n\t\t\t#include <sys/time.h>\n\t\t    ],\n\t\t    [\n\t\t\tint i = 1;\n\t\t\tsyscall(__NR_futex, (void *) &i, FUTEX_WAKE, 1,\n\t\t\t\t(void*)0,(void*)0, 0);\n\t\t\tsyscall(__NR_futex, (void *) &i, FUTEX_WAIT, 0,\n\t\t\t\t(void*)0,(void*)0, 0);\n\t\t\treturn 0;\n\t\t    ],\n\t\t    linux_futex=yes)\n\tAC_MSG_RESULT([$linux_futex])\n\ttest $linux_futex = yes && AC_DEFINE(ETHR_HAVE_LINUX_FUTEX, 1, [Define if you have a linux futex implementation.])\n\n\tpthread_setname=no\n\tAC_MSG_CHECKING([for pthread_setname_np])\n\told_CFLAGS=$CFLAGS\n\tCFLAGS=\"$CFLAGS -Werror\"\n\tAC_TRY_LINK([#define __USE_GNU\n                     #include <pthread.h>],\n                    [pthread_setname_np(pthread_self(), \"name\");],\n                    pthread_setname=linux)\n\tAC_TRY_LINK([#define __USE_GNU\n                     #include <pthread.h>],\n                    [pthread_set_name_np(pthread_self(), \"name\");],\n                    pthread_setname=bsd)\n\tAC_TRY_LINK([#define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [pthread_setname_np(\"name\");],\n                    pthread_setname=darwin)\n        AC_MSG_RESULT([$pthread_setname])\n        case $with_threadnames-$pthread_setname in\n             yes-linux) AC_DEFINE(ETHR_HAVE_PTHREAD_SETNAME_NP_2, 1,\n                          [Define if you have linux style pthread_setname_np]);;\n             yes-bsd) AC_DEFINE(ETHR_HAVE_PTHREAD_SET_NAME_NP_2, 1,\n                          [Define if you have bsd style pthread_set_name_np]);;\n             yes-darwin) AC_DEFINE(ETHR_HAVE_PTHREAD_SETNAME_NP_1, 1,\n                          [Define if you have darwin style pthread_setname_np]);;\n             *) ;;\n\tesac\n\n\tpthread_getname=no\n\tAC_MSG_CHECKING([for pthread_getname_np])\n\tAC_TRY_LINK([#define __USE_GNU\n                     #define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [char buff[256]; pthread_getname_np(pthread_self(), buff, 256);],\n                    pthread_getname=linux)\n\tAC_TRY_LINK([#define __USE_GNU\n                     #define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [char buff[256]; pthread_getname_np(pthread_self(), buff);],\n                    pthread_getname=ibm)\n        AC_MSG_RESULT([$pthread_getname])\n        case $pthread_getname in\n             linux) AC_DEFINE(ETHR_HAVE_PTHREAD_GETNAME_NP_3, 1,\n                          [Define if you have linux style pthread_getname_np]);;\n             ibm) AC_DEFINE(ETHR_HAVE_PTHREAD_GETNAME_NP_2, 1,\n                          [Define if you have ibm style pthread_getname_np]);;\n             *) ;;\n\tesac\n\tCFLAGS=$old_CFLAGS\n\n\tif test \"X$disable_native_ethr_impls\" = \"Xyes\"; then\n\t    ethr_have_native_atomics=no\n\telse\n\n\t    ETHR_CHK_GCC_ATOMIC_OPS([])\n\n\t    AC_MSG_CHECKING([for a usable libatomic_ops implementation])\n\t    case \"x$with_libatomic_ops\" in\n\t        xno | xyes | x)\n\t    \t    libatomic_ops_include=\n\t    \t    ;;\n\t        *)\n\t    \t    if test -d \"${with_libatomic_ops}/include\"; then\n\t    \t        libatomic_ops_include=\"-I$with_libatomic_ops/include\"\n\t    \t        CPPFLAGS=\"$CPPFLAGS $libatomic_ops_include\"\n\t    \t    else\n\t    \t        AC_MSG_ERROR([libatomic_ops include directory $with_libatomic_ops/include not found])\n\t    \t    fi;;\n\t    esac\n\t    ethr_have_libatomic_ops=no\n\t    AC_TRY_LINK([#include \"atomic_ops.h\"],\n\t    \t        [\n\t    \t    \t    volatile AO_t x;\n\t    \t    \t    AO_t y;\n\t    \t    \t    int z;\n\n\t    \t    \t    AO_nop_full();\n#if defined(AO_HAVE_store)\n\t    \t    \t    AO_store(&x, (AO_t) 0);\n#elif defined(AO_HAVE_store_release)\n\t    \t    \t    AO_store_release(&x, (AO_t) 0);\n#else\n#error No store\n#endif\n#if defined(AO_HAVE_load)\n\t    \t    \t    z = AO_load(&x);\n#elif defined(AO_HAVE_load_acquire)\n\t    \t    \t    z = AO_load_acquire(&x);\n#else\n#error No load\n#endif\n#if defined(AO_HAVE_compare_and_swap_full)\n\t    \t    \t    z = AO_compare_and_swap_full(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap_release)\n\t    \t    \t    z = AO_compare_and_swap_release(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap_acquire)\n\t    \t    \t    z = AO_compare_and_swap_acquire(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap)\n\t    \t    \t    z = AO_compare_and_swap(&x, (AO_t) 0, (AO_t) 1);\n#else\n#error No compare_and_swap\n#endif\n\t    \t        ],\n\t    \t        [ethr_have_native_atomics=yes\n\t\t\t ethr_native_atomic_implementation=libatomic_ops\n\t    \t         ethr_have_libatomic_ops=yes])\n\t    AC_MSG_RESULT([$ethr_have_libatomic_ops])\n\t    if test $ethr_have_libatomic_ops = yes; then\n\t        AC_CHECK_SIZEOF(AO_t, ,\n\t    \t    \t        [\n\t    \t    \t    \t    #include <stdio.h>\n\t    \t    \t    \t    #include \"atomic_ops.h\"\n\t    \t    \t        ])\n\t        AC_DEFINE_UNQUOTED(ETHR_SIZEOF_AO_T, $ac_cv_sizeof_AO_t, [Define to the size of AO_t if libatomic_ops is used])\n\n\t        AC_DEFINE(ETHR_HAVE_LIBATOMIC_OPS, 1, [Define if you have libatomic_ops atomic operations])\n\t        if test \"x$with_libatomic_ops\" != \"xno\" && test \"x$with_libatomic_ops\" != \"x\"; then\n\t    \t    AC_DEFINE(ETHR_PREFER_LIBATOMIC_OPS_NATIVE_IMPLS, 1, [Define if you prefer libatomic_ops native ethread implementations])\n\t        fi\n\t        ETHR_DEFS=\"$ETHR_DEFS $libatomic_ops_include\"\n\t    elif test \"x$with_libatomic_ops\" != \"xno\" && test \"x$with_libatomic_ops\" != \"x\"; then\n\t        AC_MSG_ERROR([No usable libatomic_ops implementation found])\n\t    fi\n\n\t    case \"$host_cpu\" in\n\t      sparc | sun4u | sparc64 | sun4v)\n\t    \t    case \"$with_sparc_memory_order\" in\n\t    \t        \"TSO\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_TSO, 1, [Define if only run in Sparc TSO mode]);;\n\t    \t        \"PSO\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_PSO, 1, [Define if only run in Sparc PSO, or TSO mode]);;\n\t    \t        \"RMO\"|\"\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_RMO, 1, [Define if run in Sparc RMO, PSO, or TSO mode]);;\n\t    \t        *)\n\t    \t    \t    AC_MSG_ERROR([Unsupported Sparc memory order: $with_sparc_memory_order]);;\n\t    \t    esac\n\t\t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;; \n\t      i86pc | i*86 | x86_64 | amd64)\n\t    \t    if test \"$enable_x86_out_of_order\" = \"yes\"; then\n\t    \t    \t    AC_DEFINE(ETHR_X86_OUT_OF_ORDER, 1, [Define if x86/x86_64 out of order instructions should be synchronized])\n\t    \t    fi\n\t\t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      macppc | ppc | powerpc | \"Power Macintosh\")\n\t      \t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      tile)\n\t            ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      *)\n\t    \t    ;;\n\t    esac\n\n\tfi\n\n\ttest ethr_have_native_atomics = \"yes\" && ethr_have_native_spinlock=yes\n\n\tdnl Restore LIBS\n\tLIBS=$saved_libs\n\tdnl restore CPPFLAGS\n\tCPPFLAGS=$saved_cppflags\n\n\t;;\n    *)\n\t;;\nesac\n\nAC_MSG_CHECKING([whether default stack size should be modified])\nif test \"x$ethr_modified_default_stack_size\" != \"x\"; then\n\tAC_DEFINE_UNQUOTED(ETHR_MODIFIED_DEFAULT_STACK_SIZE, $ethr_modified_default_stack_size, [Define if you want to modify the default stack size])\n\tAC_MSG_RESULT([yes; to $ethr_modified_default_stack_size kilo words])\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nif test \"x$ETHR_THR_LIB_BASE\" != \"x\"; then\n\tETHR_DEFS=\"-DUSE_THREADS $ETHR_DEFS\"\n\tETHR_LIBS=\"-l$ethr_lib_name -lerts_internal_r $ETHR_X_LIBS\"\n\tETHR_LIB_NAME=$ethr_lib_name\nfi\n\nAC_CHECK_SIZEOF(void *)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_PTR, $ac_cv_sizeof_void_p, [Define to the size of pointers])\n\nAC_CHECK_SIZEOF(int)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_INT, $ac_cv_sizeof_int, [Define to the size of int])\nAC_CHECK_SIZEOF(long)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_LONG, $ac_cv_sizeof_long, [Define to the size of long])\nAC_CHECK_SIZEOF(long long)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_LONG_LONG, $ac_cv_sizeof_long_long, [Define to the size of long long])\nAC_CHECK_SIZEOF(__int64)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF___INT64, $ac_cv_sizeof___int64, [Define to the size of __int64])\nAC_CHECK_SIZEOF(__int128_t)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF___INT128_T, $ac_cv_sizeof___int128_t, [Define to the size of __int128_t])\n\n\ncase X$erl_xcomp_bigendian in\n    X) ;;\n    Xyes|Xno) ac_cv_c_bigendian=$erl_xcomp_bigendian;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_bigendian value: $erl_xcomp_bigendian]);;\nesac\n\nAC_C_BIGENDIAN\n\nif test \"$ac_cv_c_bigendian\" = \"yes\"; then\n    AC_DEFINE(ETHR_BIGENDIAN, 1, [Define if bigendian])\nfi\n\ncase X$erl_xcomp_double_middle_endian in\n    X) ;;\n    Xyes|Xno|Xunknown) ac_cv_c_double_middle_endian=$erl_xcomp_double_middle_endian;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_double_middle_endian value: $erl_xcomp_double_middle_endian]);;\nesac\n\nAC_C_DOUBLE_MIDDLE_ENDIAN\n\nETHR_X86_SSE2_ASM=no\ncase \"$GCC-$ac_cv_sizeof_void_p-$host_cpu\" in\n  yes-4-i86pc | yes-4-i*86 | yes-4-x86_64 | yes-4-amd64)\n    AC_MSG_CHECKING([for gcc sse2 asm support])\n    save_CFLAGS=\"$CFLAGS\"\n    CFLAGS=\"$CFLAGS -msse2\"\n    gcc_sse2_asm=no\n    AC_TRY_COMPILE([],\n\t[\n\t\tlong long x, *y;\n\t\t__asm__ __volatile__(\"movq %1, %0\\n\\t\" : \"=x\"(x) : \"m\"(*y) : \"memory\");\n\t],\n\t[gcc_sse2_asm=yes])\n    CFLAGS=\"$save_CFLAGS\"\n    AC_MSG_RESULT([$gcc_sse2_asm])\n    if test \"$gcc_sse2_asm\" = \"yes\"; then\n      AC_DEFINE(ETHR_GCC_HAVE_SSE2_ASM_SUPPORT, 1, [Define if you use a gcc that supports -msse2 and understand sse2 specific asm statements])\n      ETHR_X86_SSE2_ASM=yes\n    fi\n    ;;\n  *)\n    ;;\nesac\n\ncase \"$GCC-$host_cpu\" in\n  yes-i86pc | yes-i*86 | yes-x86_64 | yes-amd64)\n\n    if test $ac_cv_sizeof_void_p = 4; then\n       dw_cmpxchg=\"cmpxchg8b\"\n    else\n       dw_cmpxchg=\"cmpxchg16b\"\n    fi\n\n    gcc_dw_cmpxchg_asm=no\n    gcc_pic_dw_cmpxchg_asm=no\n    gcc_cflags_pic=no\n    gcc_cmpxchg8b_pic_no_clobber_ebx=no\n    gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage=no\n\n    save_CFLAGS=\"$CFLAGS\"\n\n    # Check if it works out of the box using passed CFLAGS\n    # and with -fPIC added to CFLAGS if the passed CFLAGS\n    # doesn't trigger position independent code\n    pic_cmpxchg=unknown\n    while true; do\n\n        case $pic_cmpxchg in\n\t  yes) pic_text=\"pic \";;\n\t  *) pic_text=\"\";;\n\tesac\n\n\tAC_MSG_CHECKING([for gcc $pic_text$dw_cmpxchg plain asm support])    \n\n\tplain_cmpxchg=no\n    \tAC_TRY_COMPILE([],\n\t[\n    char xchgd;\n    long new[2], xchg[2], *p;\t\t  \n    __asm__ __volatile__(\n#if ETHR_SIZEOF_PTR == 4\n\t\"lock; cmpxchg8b %0\\n\\t\"\n#else\n\t\"lock; cmpxchg16b %0\\n\\t\"\n#endif\n\t\"setz %3\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=q\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"c\"(new[1]), \"b\"(new[0])\n\t: \"cc\", \"memory\");\n\t],\n\t[plain_cmpxchg=yes])\n\n\tAC_MSG_RESULT([$plain_cmpxchg])\n\n\tif test $pic_cmpxchg = yes; then\n\t   gcc_pic_dw_cmpxchg_asm=$plain_cmpxchg\n\t   break\n\tfi\n\n\tgcc_dw_cmpxchg_asm=$plain_cmpxchg\n\n    \t# If not already compiling to position independent\n\t# code add -fPIC to CFLAGS and do it again. This\n\t# since we want also want to know how to compile\n\t# to position independent code since this might\n\t# cause problems with the use of the EBX register\n\t# as input to the asm on 32-bit x86 and old gcc\n\t# compilers (gcc vsn < 5).\n\n    \tAC_TRY_COMPILE([],\n\t[\n#if !defined(__PIC__) || !__PIC__\n#  error no pic\n#endif\n\t],\n\t[pic_cmpxchg=yes\n\t gcc_cflags_pic=yes],\n\t[pic_cmpxchg=no])\n\n\tif test $pic_cmpxchg = yes; then\n\t   gcc_pic_dw_cmpxchg_asm=$gcc_dw_cmpxchg_asm\n\t   break\n\tfi\n\n\tCFLAGS=\"$save_CFLAGS -fPIC\"\n\tpic_cmpxchg=yes\n\n    done\n\n    if test $gcc_pic_dw_cmpxchg_asm = no && test $ac_cv_sizeof_void_p = 4; then\n\n      AC_MSG_CHECKING([for gcc pic cmpxchg8b asm support with EBX workaround])\n\n      # Check if we can work around it by managing the ebx\n      # register explicitly in the asm...\n\n      AC_TRY_COMPILE([],\n\t[\n    char xchgd;\n    long new[2], xchg[2], *p;\t\t  \n    __asm__ __volatile__(\n\t\"pushl %%ebx\\n\\t\"\n\t\"movl %8, %%ebx\\n\\t\"\n\t\"lock; cmpxchg8b %0\\n\\t\"\n\t\"setz %3\\n\\t\"\n\t\"popl %%ebx\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=q\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"c\"(new[1]), \"r\"(new[0])\n\t: \"cc\", \"memory\");\n\t],\n\t[gcc_pic_dw_cmpxchg_asm=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx=yes])     \n\n      AC_MSG_RESULT([$gcc_pic_dw_cmpxchg_asm])\n\n      if test $gcc_pic_dw_cmpxchg_asm = no; then\n\n      \tAC_MSG_CHECKING([for gcc pic cmpxchg8b asm support with EBX and register shortage workarounds])\n        # If no optimization is enabled we sometimes get a\n\t# register shortage. Check if we can work around\n\t# this...\n\n      \tAC_TRY_COMPILE([],\n\t  [\n      char xchgd;\n      long new[2], xchg[2], *p;\n      __asm__ __volatile__(\n\t\"pushl %%ebx\\n\\t\"\n\t\"movl (%7), %%ebx\\n\\t\"\n\t\"movl 4(%7), %%ecx\\n\\t\"\n\t\"lock; cmpxchg8b %0\\n\\t\"\n\t\"setz %3\\n\\t\"\n\t\"popl %%ebx\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=c\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"r\"(new)\n\t: \"cc\", \"memory\");\n\n\t],\n\t[gcc_pic_dw_cmpxchg_asm=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage=yes])\n\n        AC_MSG_RESULT([$gcc_pic_dw_cmpxchg_asm])\n      fi\n\n      if test $gcc_cflags_pic = yes; then\n        gcc_dw_cmpxchg_asm=$gcc_pic_dw_cmpxchg_asm\n      fi\n \n   fi\n\n    CFLAGS=\"$save_CFLAGS\"\n\n    if test \"$gcc_cmpxchg8b_pic_no_clobber_ebx\" = \"yes\"; then\n      AC_DEFINE(ETHR_CMPXCHG8B_PIC_NO_CLOBBER_EBX, 1, [Define if gcc wont let you clobber ebx with cmpxchg8b and position independent code])\n    fi\n    if test \"$gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage\" = \"yes\"; then\n      AC_DEFINE(ETHR_CMPXCHG8B_REGISTER_SHORTAGE, 1, [Define if you get a register shortage with cmpxchg8b and position independent code])\n    fi\n    if test \"$gcc_dw_cmpxchg_asm\" = \"yes\"; then\n      AC_DEFINE(ETHR_GCC_HAVE_DW_CMPXCHG_ASM_SUPPORT, 1, [Define if you use a gcc that supports the double word cmpxchg instruction])\n    fi;;\n  *)\n    ;;\nesac\n\nAC_DEFINE(ETHR_HAVE_ETHREAD_DEFINES, 1, \\\n[Define if you have all ethread defines])\n\nAC_SUBST(ETHR_X_LIBS)\nAC_SUBST(ETHR_LIBS)\nAC_SUBST(ETHR_LIB_NAME)\nAC_SUBST(ETHR_DEFS)\nAC_SUBST(ETHR_THR_LIB_BASE)\nAC_SUBST(ETHR_THR_LIB_BASE_DIR)\nAC_SUBST(ETHR_X86_SSE2_ASM)\n\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl ERL_TIME_CORRECTION\ndnl\ndnl Check for primitives that can be used for implementing\ndnl erts_os_monotonic_time() and erts_os_system_time()\ndnl\n\nAC_DEFUN(ERL_TIME_CORRECTION,\n[\n\nAC_ARG_WITH(clock-resolution,\nAS_HELP_STRING([--with-clock-resolution=high|low|default],\n               [specify wanted clock resolution]))\n\nAC_ARG_WITH(clock-gettime-realtime-id,\nAS_HELP_STRING([--with-clock-gettime-realtime-id=CLOCKID],\n               [specify clock id to use with clock_gettime() for realtime time)]))\n\nAC_ARG_WITH(clock-gettime-monotonic-id,\nAS_HELP_STRING([--with-clock-gettime-monotonic-id=CLOCKID],\n               [specify clock id to use with clock_gettime() for monotonic time)]))\n\nAC_ARG_ENABLE(prefer-elapsed-monotonic-time-during-suspend,\nAS_HELP_STRING([--enable-prefer-elapsed-monotonic-time-during-suspend],\n               [Prefer an OS monotonic time source with elapsed time during suspend])\nAS_HELP_STRING([--disable-prefer-elapsed-monotonic-time-during-suspend],\n               [Do not prefer an OS monotonic time source with elapsed time during suspend]),\n[ case \"$enableval\" in\n    yes) prefer_elapsed_monotonic_time_during_suspend=yes ;;\n    *)  prefer_elapsed_monotonic_time_during_suspend=no ;;\n  esac ], prefer_elapsed_monotonic_time_during_suspend=no)\n\nAC_ARG_ENABLE(gettimeofday-as-os-system-time,\n\t      AS_HELP_STRING([--enable-gettimeofday-as-os-system-time],\n                             [Force usage of gettimeofday() for OS system time]),\n[ case \"$enableval\" in\n    yes) force_gettimeofday_os_system_time=yes ;;\n    *)  force_gettimeofday_os_system_time=no ;;\n  esac ], force_gettimeofday_os_system_time=no)\n\ncase \"$with_clock_resolution\" in\n   \"\"|no|yes)\n     with_clock_resolution=default;;\n   high|low|default)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid wanted clock resolution: $with_clock_resolution])\n     ;;\nesac\n\nif test \"$force_gettimeofday_os_system_time\" = \"yes\"; then\n\n  AC_CHECK_FUNCS([gettimeofday])\n  if test \"$ac_cv_func_gettimeofday\" = \"yes\"; then\n    AC_DEFINE(OS_SYSTEM_TIME_GETTIMEOFDAY,  [1], [Define if you want to implement erts_os_system_time() using gettimeofday()])\n  else\n    AC_MSG_ERROR([No gettimeofday() available])\n  fi\n\nelse # $force_gettimeofday_os_system_time != yes\n\ncase \"$with_clock_gettime_realtime_id\" in\n   \"\"|no)\n     with_clock_gettime_realtime_id=no\n     ;;\n   CLOCK_*CPUTIME*)\n     AC_MSG_ERROR([Invalid clock_gettime() realtime clock id: Refusing to use the cputime clock id $with_clock_gettime_realtime_id as realtime clock id])\n     ;;\n   CLOCK_MONOTONIC*|CLOCK_BOOTTIME*|CLOCK_UPTIME*|CLOCK_HIGHRES*)\n     AC_MSG_ERROR([Invalid clock_gettime() realtime clock id: Refusing to use the monotonic clock id $with_clock_gettime_realtime_id as realtime clock id])\n     ;;\n   CLOCK_*)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid clock_gettime() clock id: $with_clock_gettime_realtime_id])\n     ;;\nesac\n\ncase \"$with_clock_resolution-$with_clock_gettime_realtime_id\" in\n  high-no)\n\tERL_WALL_CLOCK(high_resolution);;\n  low-no)\n\tERL_WALL_CLOCK(low_resolution);;\n  default-no)\n\tERL_WALL_CLOCK(default_resolution);;\n  *)\n\tERL_WALL_CLOCK(custom_resolution, $with_clock_gettime_realtime_id);;\nesac\n\ncase \"$erl_wall_clock_func-$erl_wall_clock_id-$with_clock_gettime_realtime_id\" in\n  *-*-no)\n    ;;\n  clock_gettime-$with_clock_gettime_realtime_id-$with_clock_gettime_realtime_id)\n    ;;\n  *)\n    AC_MSG_ERROR([$with_clock_gettime_realtime_id as clock id to clock_gettime() doesn't compile])\n    ;;\nesac\n\ncase $erl_wall_clock_func in\n  none)\n    AC_MSG_ERROR([No wall clock source found])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(OS_SYSTEM_TIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_system_time() using mach clock_get_time()])\n    ;;\n  clock_gettime)\n    AC_DEFINE(OS_SYSTEM_TIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_system_time() using clock_gettime()])\n    ;;\n  gettimeofday)\n    AC_DEFINE(OS_SYSTEM_TIME_GETTIMEOFDAY,  [1], [Define if you want to implement erts_os_system_time() using gettimeofday()])\n    ;;\n  *)\n    ;;\nesac\n\nif test \"x$erl_wall_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(WALL_CLOCK_ID_STR, [\"$erl_wall_clock_id\"], [Define as a string of wall clock id to use])\n    AC_DEFINE_UNQUOTED(WALL_CLOCK_ID, [$erl_wall_clock_id], [Define to wall clock id to use])\nfi\n\nfi # $force_gettimeofday_os_system_time != yes\n\ncase \"$with_clock_gettime_monotonic_id\" in\n   \"\"|no)\n     with_clock_gettime_monotonic_id=no\n     ;;\n   CLOCK_*CPUTIME*)\n     AC_MSG_ERROR([Invalid clock_gettime() monotonic clock id: Refusing to use the cputime clock id $with_clock_gettime_monotonic_id as monotonic clock id])\n     ;;\n   CLOCK_REALTIME*|CLOCK_TAI*)\n     AC_MSG_ERROR([Invalid clock_gettime() monotonic clock id: Refusing to use the realtime clock id $with_clock_gettime_monotonic_id as monotonic clock id])\n     ;;\n   CLOCK_*)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid clock_gettime() clock id: $with_clock_gettime_monotonic_id])\n     ;;\nesac\n\ncase \"$with_clock_resolution-$with_clock_gettime_monotonic_id\" in\n  high-no)\n\tERL_MONOTONIC_CLOCK(high_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  low-no)\n\tERL_MONOTONIC_CLOCK(low_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  default-no)\n\tERL_MONOTONIC_CLOCK(default_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  *)\n\tERL_MONOTONIC_CLOCK(custom_resolution, $with_clock_gettime_monotonic_id, $prefer_elapsed_monotonic_time_during_suspend);;\nesac\n\ncase \"$erl_monotonic_clock_func-$erl_monotonic_clock_id-$with_clock_gettime_monotonic_id\" in\n  *-*-no)\n    ;;\n  clock_gettime-$with_clock_gettime_monotonic_id-$with_clock_gettime_monotonic_id)\n    ;;\n  *)\n    AC_MSG_ERROR([$with_clock_gettime_monotonic_id as clock id to clock_gettime() doesn't compile])\n    ;;\nesac\n\ncase $erl_monotonic_clock_func in\n  times)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_TIMES, [1], [Define if you want to implement erts_os_monotonic_time() using times()])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_monotonic_time() using mach clock_get_time()])\n    ;;\n  clock_gettime)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_monotonic_time() using clock_gettime()])\n    ;;\n  gethrtime)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_GETHRTIME,  [1], [Define if you want to implement erts_os_monotonic_time() using gethrtime()])\n    ;;\n  *)\n    ;;\nesac\n\nif test $erl_corrected_monotonic_clock = yes; then\n  AC_DEFINE(ERTS_HAVE_CORRECTED_OS_MONOTONIC_TIME, [1], [Define if OS monotonic clock is corrected])\nfi\n\nif test $erl_monotonic_clock_low_resolution = yes; then\n  AC_DEFINE(ERTS_HAVE_LOW_RESOLUTION_OS_MONOTONIC_LOW, [1], [Define if you have a low resolution OS monotonic clock])\nfi\n\nxrtlib=\nif test \"$erl_monotonic_clock_lib\" != \"\"; then\n   xrtlib=\"$erl_monotonic_clock_lib\"\nfi\nif test \"$erl_wall_clock_lib\" != \"\"; then\n   xrtlib=\"$erl_wall_clock_lib\"\nfi\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(MONOTONIC_CLOCK_ID_STR, [\"$erl_monotonic_clock_id\"], [Define as a string of monotonic clock id to use])\n    AC_DEFINE_UNQUOTED(MONOTONIC_CLOCK_ID, [$erl_monotonic_clock_id], [Define to monotonic clock id to use])\nfi\n\nif test $erl_cv_clock_gettime_monotonic_raw = yes; then\n  AC_DEFINE(HAVE_CLOCK_GETTIME_MONOTONIC_RAW, [1], [Define if you have clock_gettime(CLOCK_MONOTONIC_RAW, _)])\nfi\n\nERL_MONOTONIC_CLOCK(high_resolution, undefined, no)\n\ncase $$erl_monotonic_clock_low_resolution-$erl_monotonic_clock_func in\n  no-mach_clock_get_time)\n    monotonic_hrtime=yes    \n    AC_DEFINE(SYS_HRTIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_hrtime() using mach clock_get_time()])\n    ;;\n  no-clock_gettime)\n    monotonic_hrtime=yes\n    AC_DEFINE(SYS_HRTIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_hrtime() using clock_gettime()])\n    ;;\n  no-gethrtime)\n    monotonic_hrtime=yes\n    AC_DEFINE(SYS_HRTIME_USING_GETHRTIME,  [1], [Define if you want to implement erts_os_hrtime() using gethrtime()])\n    ;;\n  *)\n    monotonic_hrtime=no\n    ;;\nesac\n\nif test $monotonic_hrtime = yes; then\n    AC_DEFINE(HAVE_MONOTONIC_ERTS_SYS_HRTIME, [1], [Define if you have a monotonic erts_os_hrtime() implementation])\nfi\n\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(HRTIME_CLOCK_ID_STR, [\"$erl_monotonic_clock_id\"], [Define as a string of monotonic clock id to use])\n    AC_DEFINE_UNQUOTED(HRTIME_CLOCK_ID, [$erl_monotonic_clock_id], [Define to monotonic clock id to use])\nfi\n\n\ndnl\ndnl Check if gethrvtime is working, and if to use procfs ioctl\ndnl or (yet to be written) write to the procfs ctl file.\ndnl\n\nAC_MSG_CHECKING([if gethrvtime works and how to use it])\nAC_TRY_RUN([\n/* gethrvtime procfs ioctl test */\n/* These need to be undef:ed to not break activation of\n * micro level process accounting on /proc/self \n */\n#ifdef _LARGEFILE_SOURCE\n#  undef _LARGEFILE_SOURCE\n#endif\n#ifdef _FILE_OFFSET_BITS\n#  undef _FILE_OFFSET_BITS\n#endif\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/signal.h>\n#include <sys/fault.h>\n#include <sys/syscall.h>\n#include <sys/procfs.h>\n#include <fcntl.h>\n\nint main() {\n    long msacct = PR_MSACCT;\n    int fd;\n    long long start, stop;\n    int i;\n    pid_t pid = getpid();\n    char proc_self[30] = \"/proc/\";\n\n    sprintf(proc_self+strlen(proc_self), \"%lu\", (unsigned long) pid);\n    if ( (fd = open(proc_self, O_WRONLY)) == -1)\n\texit(1);\n    if (ioctl(fd, PIOCSET, &msacct) < 0)\n\texit(2);\n    if (close(fd) < 0)\n\texit(3);\n    start = gethrvtime();\n    for (i = 0; i < 100; i++)\n\tstop = gethrvtime();\n    if (start == 0)\n\texit(4);\n    if (start == stop)\n\texit(5);\n    exit(0); return 0;\n}\n],\nerl_gethrvtime=procfs_ioctl,\nerl_gethrvtime=false,\n[\ncase X$erl_xcomp_gethrvtime_procfs_ioctl in\n    X)\n\terl_gethrvtime=cross;;\n    Xyes|Xno)\n\tif test $erl_xcomp_gethrvtime_procfs_ioctl = yes; then\n\t    erl_gethrvtime=procfs_ioctl\n\telse\n\t    erl_gethrvtime=false\n\tfi;;\n    *)\n\tAC_MSG_ERROR([Bad erl_xcomp_gethrvtime_procfs_ioctl value: $erl_xcomp_gethrvtime_procfs_ioctl]);;\nesac\n])\n\nLIBRT=$xrtlib\ncase $erl_gethrvtime in\n  procfs_ioctl)\n\tAC_DEFINE(HAVE_GETHRVTIME_PROCFS_IOCTL,[1],\n\t\t[define if gethrvtime() works and uses ioctl() to /proc/self])\n\tAC_MSG_RESULT(uses ioctl to procfs)\n\t;;\n  *)\n\tif test $erl_gethrvtime = cross; then\n\t    erl_gethrvtime=false\n\t    AC_MSG_RESULT(cross)\n\t    AC_MSG_WARN([result 'not working' guessed because of cross compilation])\n\telse\n\t    AC_MSG_RESULT(not working)\n\tfi\n\n\tdnl\n\tdnl Check if clock_gettime (linux) is working\n\tdnl\n\n\tAC_MSG_CHECKING([if clock_gettime can be used to get thread CPU time])\n\tsave_libs=$LIBS\n\tLIBS=\"-lrt\"\n\tAC_TRY_RUN([\n\t#include <stdlib.h>\n\t#include <unistd.h>\n\t#include <string.h>\n\t#include <stdio.h>\n\t#include <time.h>\n\tint main() {\n\t    long long start, stop;\n\t    int i;\n\t    struct timespec tp;\n\n\t    if (clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp) < 0)\n\t      exit(1);\n\t    start = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;\n\t    for (i = 0; i < 100; i++)\n\t      clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp);\n\t    stop = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;\n\t    if (start == 0)\n\t      exit(4);\n\t    if (start == stop)\n\t      exit(5);\n\t    exit(0); return 0;\n\t  }\n\t],\n\terl_clock_gettime_cpu_time=yes,\n\terl_clock_gettime_cpu_time=no,\n\t[\n\tcase X$erl_xcomp_clock_gettime_cpu_time in\n\t    X) erl_clock_gettime_cpu_time=cross;;\n\t    Xyes|Xno) erl_clock_gettime_cpu_time=$erl_xcomp_clock_gettime_cpu_time;;\n\t    *) AC_MSG_ERROR([Bad erl_xcomp_clock_gettime_cpu_time value: $erl_xcomp_clock_gettime_cpu_time]);;\n\tesac\n\t])\n\tLIBS=$save_libs\n\tAC_MSG_RESULT($erl_clock_gettime_cpu_time)\n\tcase $erl_clock_gettime_cpu_time in\n\t\tyes)\n\t\t\tAC_DEFINE(HAVE_CLOCK_GETTIME_CPU_TIME,[],\n\t\t\t\t  [define if clock_gettime() works for getting thread time])\n\t\t\tLIBRT=-lrt\n\t\t\t;;\n\t\tcross)\n\t\t\terl_clock_gettime_cpu_time=no\n\t\t\tAC_MSG_WARN([result no guessed because of cross compilation])\n\t\t\t;;\n\t\t*)\n\t\t\t;;\n\tesac\n\t;;\nesac\nAC_SUBST(LIBRT)\n])dnl\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_TRY_ENABLE_CFLAG\ndnl\ndnl\ndnl Tries a CFLAG and sees if it can be enabled without compiler errors\ndnl $1: textual cflag to add\ndnl $2: variable to store the modified CFLAG in\ndnl Usage example LM_TRY_ENABLE_CFLAG([-Werror=return-type], [CFLAGS])\ndnl\ndnl\nAC_DEFUN([LM_TRY_ENABLE_CFLAG], [\n    AC_MSG_CHECKING([if we can add $1 to $2 (via CFLAGS)])\n    saved_CFLAGS=$CFLAGS;\n    CFLAGS=\"$1 $$2\";\n    AC_TRY_COMPILE([],[return 0;],can_enable_flag=true,can_enable_flag=false)\n    CFLAGS=$saved_CFLAGS;\n    if test \"X$can_enable_flag\" = \"Xtrue\"; then\n        AC_MSG_RESULT([yes])\n        AS_VAR_SET($2, \"$1 $$2\")\n    else\n        AC_MSG_RESULT([no])\n    fi\n])\n\nAC_DEFUN([LM_CHECK_ENABLE_CFLAG], [\n    AC_MSG_CHECKING([whether $CC accepts $1...])\n    saved_CFLAGS=$CFLAGS;\n    CFLAGS=\"$1 $CFLAGS\";\n    AC_TRY_COMPILE([],[return 0;],can_enable_flag=true,can_enable_flag=false)\n    CFLAGS=$saved_CFLAGS;\n    if test \"X$can_enable_flag\" = \"Xtrue\"; then\n        AS_VAR_SET($2, true)\n        AC_MSG_RESULT([yes])\n    else\n        AS_VAR_SET($2, false)\n        AC_MSG_RESULT([no])\n    fi\n])\n\ndnl ERL_TRY_LINK_JAVA(CLASSES, FUNCTION-BODY\ndnl                   [ACTION_IF_FOUND [, ACTION-IF-NOT-FOUND]])\ndnl Freely inspired by AC_TRY_LINK. (Maybe better to create a \ndnl AC_LANG_JAVA instead...)\nAC_DEFUN(ERL_TRY_LINK_JAVA,\n[java_link='$JAVAC conftest.java 1>&AC_FD_CC'\nchangequote(, )dnl\ncat > conftest.java <<EOF\n$1\nclass conftest { public static void main(String[] args) {\n   $2\n   ; return; }}\nEOF\nchangequote([, ])dnl\nif AC_TRY_EVAL(java_link) && test -s conftest.class; then\n   ifelse([$3], , :, [rm -rf conftest*\n   $3])\nelse\n   echo \"configure: failed program was:\" 1>&AC_FD_CC\n   cat conftest.java 1>&AC_FD_CC\n   echo \"configure: PATH was $PATH\" 1>&AC_FD_CC\nifelse([$4], , , [  rm -rf conftest*\n  $4\n])dnl\nfi\nrm -f conftest*])\n#define UNSAFE_MASK  0xc0000000 /* Mask for bits that must be constant */\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_HARDWARE_ARCH\ndnl\ndnl Determine target hardware in ARCH\ndnl\nAC_DEFUN([LM_HARDWARE_ARCH], [\n    AC_MSG_CHECKING([target hardware architecture])\n    if test \"x$host_alias\" != \"x\" -a \"x$host_cpu\" != \"x\"; then\n        chk_arch_=$host_cpu\n    else\n        chk_arch_=`uname -m`\n    fi\n\n    case $chk_arch_ in\n    sun4u)\tARCH=ultrasparc;;\n    sparc64)\tARCH=sparc64;;\n    sun4v)\tARCH=ultrasparc;;\n    i86pc)\tARCH=x86;;\n    i386)\tARCH=x86;;\n    i486)\tARCH=x86;;\n    i586)\tARCH=x86;;\n    i686)\tARCH=x86;;\n    x86_64)\tARCH=amd64;;\n    amd64)\tARCH=amd64;;\n    macppc)\tARCH=ppc;;\n    powerpc)\tARCH=ppc;;\n    ppc)\tARCH=ppc;;\n    ppc64)\tARCH=ppc64;;\n    ppc64le)\tARCH=ppc64le;;\n    \"Power Macintosh\")\tARCH=ppc;;\n    armv5b)\tARCH=arm;;\n    armv5teb)\tARCH=arm;;\n    armv5tel)\tARCH=arm;;\n    armv5tejl)\tARCH=arm;;\n    armv6l)\tARCH=arm;;\n    armv6hl)\tARCH=arm;;\n    armv7l)\tARCH=arm;;\n    armv7hl)\tARCH=arm;;\n    tile)\tARCH=tile;;\n    e2k)        ARCH=e2k;;\n    *)\t \tARCH=noarch;;\n    esac\n    AC_MSG_RESULT($ARCH)\n\n    dnl\n    dnl Convert between x86 and amd64 based on the compiler's mode.\n    dnl Ditto between ultrasparc and sparc64.\n    dnl\n    AC_MSG_CHECKING(whether compilation mode forces ARCH adjustment)\n    case \"$ARCH-$ac_cv_sizeof_void_p\" in\n    x86-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=x86 to ARCH=amd64)\n\tARCH=amd64\n\t;;\n    amd64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=amd64 to ARCH=x86)\n\tARCH=x86\n\t;;\n    ultrasparc-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ultrasparc to ARCH=sparc64)\n\tARCH=sparc64\n\t;;\n    sparc64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=sparc64 to ARCH=ultrasparc)\n\tARCH=ultrasparc\n\t;;\n    ppc64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ppc64 to ARCH=ppc)\n\tARCH=ppc\n\t;;\n    ppc-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ppc to ARCH=ppc64)\n\tARCH=ppc64\n\t;;\n    arm-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=arm to ARCH=noarch)\n\tARCH=noarch\n\t;;\n    *)\n\tAC_MSG_RESULT(no: ARCH is $ARCH)\n\t;;\n    esac\n\n    AC_SUBST(ARCH)\n])\n\ndnl\ndnl--------------------------------------------------------------------\ndnl Dynamic Erlang Drivers\ndnl\ndnl Linking to produce dynamic Erlang drivers to be loaded by Erlang's\ndnl Dynamic Driver Loader and Linker (DDLL). Below the prefix DED is an\ndnl abbreviation for `Dynamic Erlang Driver'.\ndnl\ndnl For DED we need something quite sloppy, which allows undefined references \ndnl (notably driver functions) in the resulting shared library. \ndnl Example of Makefile rule (and settings of macros):\ndnl\ndnl LIBS = @LIBS@\ndnl LD = @DED_LD@\ndnl LDFLAGS = @DED_LDFLAGS@\ndnl soname = @ldsoname@\ndnl\ndnl my_drv.so:   my_drv.o my_utils.o\ndnl              $(LD) $(LDFLAGS) $(soname) $@ -o $@ $^ -lc $(LIBS)\ndnl\ndnl--------------------------------------------------------------------\ndnl\n\nAC_DEFUN(ERL_DED,\n\t[\n\nUSER_LD=$LD\nUSER_LDFLAGS=\"$LDFLAGS\"\n\nLM_CHECK_THR_LIB\n\nDED_CC=$CC\nDED_GCC=$GCC\n\nDED_CFLAGS=\nDED_OSTYPE=unix\ncase $host_os in\n     linux*)\n\tDED_CFLAGS=\"-D_GNU_SOURCE\" ;;\n     win32)\n\tDED_CFLAGS=\"-D_WIN32_WINNT=0x0600 -DWINVER=0x0600\"\n        DED_OSTYPE=win32 ;;\n     *)\n        ;;\nesac\n\n\nDED_WARN_FLAGS=\"-Wall -Wstrict-prototypes\"\ncase \"$host_cpu\" in\n  tile*)\n    # tile-gcc is a bit stricter with -Wmissing-prototypes than other gccs,\n    # and too strict for our taste.\n    ;;\n  *)\n    DED_WARN_FLAGS=\"$DED_WARN_FLAGS -Wmissing-prototypes\";;\nesac\n  \nLM_TRY_ENABLE_CFLAG([-Wdeclaration-after-statement], [DED_WARN_FLAGS])\n\nLM_TRY_ENABLE_CFLAG([-Werror=return-type], [DED_WERRORFLAGS])\nLM_TRY_ENABLE_CFLAG([-Werror=implicit], [DED_WERRORFLAGS])\nLM_TRY_ENABLE_CFLAG([-Werror=undef], [DED_WERRORFLAGS])\n\nDED_SYS_INCLUDE=\"-I${ERL_TOP}/erts/emulator/beam -I${ERL_TOP}/erts/include -I${ERL_TOP}/erts/include/$host -I${ERL_TOP}/erts/include/internal -I${ERL_TOP}/erts/include/internal/$host -I${ERL_TOP}/erts/emulator/sys/$DED_OSTYPE -I${ERL_TOP}/erts/emulator/sys/common\"\nDED_INCLUDE=$DED_SYS_INCLUDE\n\nif test \"$THR_DEFS\" = \"\"; then\n    DED_THR_DEFS=\"-D_THREAD_SAFE -D_REENTRANT\"\nelse\n    DED_THR_DEFS=\"$THR_DEFS\"\nfi\n# DED_EMU_THR_DEFS=$EMU_THR_DEFS\nDED_CFLAGS=\"$CFLAGS $CPPFLAGS $DED_CFLAGS\"\nif test \"x$GCC\" = xyes; then\n    DED_STATIC_CFLAGS=\"$DED_CFLAGS\"\n    DED_CFLAGS=\"$DED_CFLAGS -fPIC\"\nfi\n\nDED_EXT=so\ncase $host_os in\n    win32) DED_EXT=dll;;\n    darwin*)\n\tDED_CFLAGS=\"$DED_CFLAGS -fno-common\"\n\tDED_STATIC_CFLAGS=\"$DED_STATIC_CFLAGS -fno-common\";;\n    *)\n\t;;\nesac\n\nDED_STATIC_CFLAGS=\"$DED_STATIC_CFLAGS -DSTATIC_ERLANG_NIF -DSTATIC_ERLANG_DRIVER\"\n\nif test \"$CFLAG_RUNTIME_LIBRARY_PATH\" = \"\"; then\n\n  CFLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-R\"\n  case $host_os in\n    darwin*)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n    win32)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n    osf*)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-rpath,\"\n\t;;\n    *)\n\t;;\n  esac\n\nfi\n\n# If DED_LD is set in environment, we expect all DED_LD* variables\n# to be specified (cross compiling)\nif test \"x$DED_LD\" = \"x\"; then\n\nDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-R\"\ncase $host_os in\n\twin32)\n\t\tDED_LD=\"ld.sh\"\n\t\tDED_LDFLAGS=\"-dll\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n\tsolaris2*|sysv4*)\n\t\tDED_LDFLAGS=\"-G\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-64 $DED_LDFLAGS\"\n\t\tfi\n\t;;\n\taix4*)\n\t\tDED_LDFLAGS=\"-G -bnoentry -bexpall\"\n\t;;\n\tfreebsd2*)\n\t\t# Non-ELF GNU linker\n\t\tDED_LDFLAGS=\"-Bshareable\"\n\t;;\n\tdarwin*)\n\t\t# Mach-O linker: a shared lib and a loadable\n\t\t# object file is not the same thing.\n\t\tDED_LDFLAGS=\"-bundle -bundle_loader ${ERL_TOP}/bin/$host/beam.smp\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t  DED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\telse\n\t\t  if test X${enable_m32_build} = Xyes; then\n\t\t    DED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\t  else\n\t\t    AC_CHECK_SIZEOF(void *)\n\t\t    case \"$ac_cv_sizeof_void_p\" in\n\t\t      8)\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\";;\n\t\t      *)\n\t\t        ;;\n\t\t    esac\n\t\t  fi\n\t\tfi\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t;;\n\tlinux*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared -Wl,-Bsymbolic\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\tfi;\n\t\tif test X${enable_m32_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\tfi\n\t;;\t\n\tfreebsd*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\tfi;\n\t\tif test X${enable_m32_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\tfi\n\t;;\t\n\topenbsd*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared\"\n\t;;\n\tosf*)\n\t\t# NOTE! Whitespace after -rpath is important.\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-rpath \"\n\t\tDED_LDFLAGS=\"-shared -expect_unresolved '*'\"\n\t;;\n\t*)\n\t\t# assume GNU linker and ELF\n\t\tDED_LDFLAGS=\"-shared\"\n\t\t# GNU linker has no option for 64bit build, should not propagate -m64\n\t;;\nesac\n\nif test \"$DED_LD\" = \"\" && test \"$USER_LD\" != \"\"; then\n    DED_LD=\"$USER_LD\"\n    DED_LDFLAGS=\"$USER_LDFLAGS $DED_LDFLAGS\"\nfi\n\nDED_LIBS=$LIBS\n\nfi # \"x$DED_LD\" = \"x\"\n\nAC_CHECK_TOOL(DED_LD, ld, false)\ntest \"$DED_LD\" != \"false\" || AC_MSG_ERROR([No linker found])\n\nAC_MSG_CHECKING(for static compiler flags)\nDED_STATIC_CFLAGS=\"$DED_WERRORFLAGS $DED_WFLAGS $DED_THR_DEFS $DED_STATIC_CFLAGS\"\nAC_MSG_RESULT([$DED_STATIC_CFLAGS])\nAC_MSG_CHECKING(for basic compiler flags for loadable drivers)\nDED_BASIC_CFLAGS=$DED_CFLAGS\nAC_MSG_RESULT([$DED_CFLAGS])\nAC_MSG_CHECKING(for compiler flags for loadable drivers)\nDED_CFLAGS=\"$DED_WERRORFLAGS $DED_WARN_FLAGS $DED_THR_DEFS $DED_CFLAGS\"\nAC_MSG_RESULT([$DED_CFLAGS])\nAC_MSG_CHECKING(for linker for loadable drivers)\nAC_MSG_RESULT([$DED_LD])\nAC_MSG_CHECKING(for linker flags for loadable drivers)\nAC_MSG_RESULT([$DED_LDFLAGS])\nAC_MSG_CHECKING(for 'runtime library path' linker flag)\nif test \"x$DED_LD_FLAG_RUNTIME_LIBRARY_PATH\" != \"x\"; then\n\tAC_MSG_RESULT([$DED_LD_FLAG_RUNTIME_LIBRARY_PATH])\nelse\n\tAC_MSG_RESULT([not found])\nfi\n\nAC_SUBST(DED_CC)\nAC_SUBST(DED_GCC)\nAC_SUBST(DED_EXT)\nAC_SUBST(DED_SYS_INCLUDE)\nAC_SUBST(DED_INCLUDE)\nAC_SUBST(DED_BASIC_CFLAGS)\nAC_SUBST(DED_CFLAGS)\nAC_SUBST(DED_STATIC_CFLAGS)\nAC_SUBST(DED_WARN_FLAGS)\nAC_SUBST(DED_WERRORFLAGS)\nAC_SUBST(DED_LD)\nAC_SUBST(DED_LDFLAGS)\nAC_SUBST(DED_LD_FLAG_RUNTIME_LIBRARY_PATH)\nAC_SUBST(DED_LIBS)\nAC_SUBST(DED_THR_DEFS)\nAC_SUBST(DED_OSTYPE)\n\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/make/aclocal.m4": "dnl\ndnl %CopyrightBegin%\ndnl\ndnl Copyright Ericsson AB 1998-2018. All Rights Reserved.\ndnl\ndnl Licensed under the Apache License, Version 2.0 (the \"License\");\ndnl you may not use this file except in compliance with the License.\ndnl You may obtain a copy of the License at\ndnl\ndnl     http://www.apache.org/licenses/LICENSE-2.0\ndnl\ndnl Unless required by applicable law or agreed to in writing, software\ndnl distributed under the License is distributed on an \"AS IS\" BASIS,\ndnl WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\ndnl See the License for the specific language governing permissions and\ndnl limitations under the License.\ndnl\ndnl %CopyrightEnd%\ndnl\n\ndnl\ndnl aclocal.m4\ndnl\ndnl Local macros used in configure.in. The Local Macros which\ndnl could/should be part of autoconf are prefixed LM_, macros specific\ndnl to the Erlang system are prefixed ERL_.\ndnl\n\nAC_DEFUN(LM_PRECIOUS_VARS,\n[\n\ndnl ERL_TOP\nAC_ARG_VAR(ERL_TOP, [Erlang/OTP top source directory])\n\ndnl Tools\nAC_ARG_VAR(CC, [C compiler])\nAC_ARG_VAR(CFLAGS, [C compiler flags])\nAC_ARG_VAR(STATIC_CFLAGS, [C compiler static flags])\nAC_ARG_VAR(CFLAG_RUNTIME_LIBRARY_PATH, [runtime library path linker flag passed via C compiler])\nAC_ARG_VAR(CPP, [C/C++ preprocessor])\nAC_ARG_VAR(CPPFLAGS, [C/C++ preprocessor flags])\nAC_ARG_VAR(CXX, [C++ compiler])\nAC_ARG_VAR(CXXFLAGS, [C++ compiler flags])\nAC_ARG_VAR(LD, [linker (is often overridden by configure)])\nAC_ARG_VAR(LDFLAGS, [linker flags (can be risky to set since LD may be overriden by configure)])\nAC_ARG_VAR(LIBS, [libraries])\nAC_ARG_VAR(DED_LD, [linker for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(DED_LDFLAGS, [linker flags for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(DED_LD_FLAG_RUNTIME_LIBRARY_PATH, [runtime library path linker flag for Dynamic Erlang Drivers (set all DED_LD* variables or none)])\nAC_ARG_VAR(LFS_CFLAGS, [large file support C compiler flags (set all LFS_* variables or none)])\nAC_ARG_VAR(LFS_LDFLAGS, [large file support linker flags (set all LFS_* variables or none)])\nAC_ARG_VAR(LFS_LIBS, [large file support libraries (set all LFS_* variables or none)])\nAC_ARG_VAR(RANLIB, [ranlib])\nAC_ARG_VAR(AR, [ar])\nAC_ARG_VAR(GETCONF, [getconf])\n\ndnl Cross system root\nAC_ARG_VAR(erl_xcomp_sysroot, [Absolute cross system root path (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_isysroot, [Absolute cross system root include path (only used when cross compiling)])\n\ndnl Cross compilation variables\nAC_ARG_VAR(erl_xcomp_bigendian, [big endian system: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_double_middle_endian, [double-middle-endian system: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_nptl, [have Native POSIX Thread Library: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_usable_sigusrx, [SIGUSR1 and SIGUSR2 can be used: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_linux_usable_sigaltstack, [have working sigaltstack(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_poll, [have working poll(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_kqueue, [have working kqueue(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_putenv_copy, [putenv() stores key-value copy: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_reliable_fpe, [have reliable floating point exceptions: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_getaddrinfo, [have working getaddrinfo() for both IPv4 and IPv6: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_gethrvtime_procfs_ioctl, [have working gethrvtime() which can be used with procfs ioctl(): yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_clock_gettime_cpu_time, [clock_gettime() can be used for retrieving process CPU time: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_after_morecore_hook, [__after_morecore_hook can track malloc()s core memory usage: yes|no (only used when cross compiling)])\nAC_ARG_VAR(erl_xcomp_dlsym_brk_wrappers, [dlsym(RTLD_NEXT, _) brk wrappers can track malloc()s core memory usage: yes|no (only used when cross compiling)])\n\n])\n\nAC_DEFUN(ERL_XCOMP_SYSROOT_INIT,\n[\nerl_xcomp_without_sysroot=no\nif test \"$cross_compiling\" = \"yes\"; then\n    test \"$erl_xcomp_sysroot\" != \"\" || erl_xcomp_without_sysroot=yes\n    test \"$erl_xcomp_isysroot\" != \"\" || erl_xcomp_isysroot=\"$erl_xcomp_sysroot\"\nelse\n    erl_xcomp_sysroot=\n    erl_xcomp_isysroot=\nfi\n])\n\nAC_DEFUN(LM_CHECK_GETCONF,\n[\nif test \"$cross_compiling\" != \"yes\"; then\n    AC_CHECK_PROG([GETCONF], [getconf], [getconf], [false])\nelse\n    dnl First check if we got a `<HOST>-getconf' in $PATH\n    host_getconf=\"$host_alias-getconf\"\n    AC_CHECK_PROG([GETCONF], [$host_getconf], [$host_getconf], [false])\n    if test \"$GETCONF\" = \"false\" && test \"$erl_xcomp_sysroot\" != \"\"; then\n\tdnl We should perhaps give up if we have'nt found it by now, but at\n\tdnl least in one Tilera MDE `getconf' under sysroot is a bourne\n\tdnl shell script which we can use. We try to find `<HOST>-getconf'\n    \tdnl or `getconf' under sysconf, but only under sysconf since\n\tdnl `getconf' in $PATH is almost guaranteed to be for the build\n\tdnl machine.\n\tGETCONF=\n\tprfx=\"$erl_xcomp_sysroot\"\n        AC_PATH_TOOL([GETCONF], [getconf], [false],\n\t             [\"$prfx/usr/bin:$prfx/bin:$prfx/usr/local/bin\"])\n    fi\nfi\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_WINDOWS_ENVIRONMENT\ndnl\ndnl\ndnl Tries to determine thw windows build environment, i.e. \ndnl MIXED_CYGWIN_VC or MIXED_MSYS_VC \ndnl\n\nAC_DEFUN(LM_WINDOWS_ENVIRONMENT,\n[\n\nif test \"X$windows_environment_\" != \"Xchecked\"; then\nwindows_environment_=checked\nMIXED_CYGWIN=no\nMIXED_MSYS=no\n\nAC_MSG_CHECKING(for mixed cygwin or msys and native VC++ environment)\nif test \"X$host\" = \"Xwin32\" -a \"x$GCC\" != \"xyes\"; then\n\tif test -x /usr/bin/msys-?.0.dll; then\n\t        CFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_MSYS=yes\n\t\tAC_MSG_RESULT([MSYS and VC])\n\t\tMIXED_MSYS_VC=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_MSYS_VC\"\n\telif test -x /usr/bin/cygpath; then\n\t\tCFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_CYGWIN=yes\n\t\tAC_MSG_RESULT([Cygwin and VC])\n\t\tMIXED_CYGWIN_VC=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_CYGWIN_VC\"\n\telse\t\t    \n\t\tAC_MSG_RESULT([undeterminable])\n\t\tAC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)\n\tfi\nelse\n\tAC_MSG_RESULT([no])\n\tMIXED_CYGWIN_VC=no\n\tMIXED_MSYS_VC=no\nfi\nAC_SUBST(MIXED_CYGWIN_VC)\nAC_SUBST(MIXED_MSYS_VC)\n\nMIXED_VC=no\nif test \"x$MIXED_MSYS_VC\" = \"xyes\" -o  \"x$MIXED_CYGWIN_VC\" = \"xyes\" ; then\n   MIXED_VC=yes\nfi\n\nAC_SUBST(MIXED_VC)\n\nif test \"x$MIXED_MSYS\" != \"xyes\"; then\n   AC_MSG_CHECKING(for mixed cygwin and native MinGW environment)\n   if test \"X$host\" = \"Xwin32\" -a \"x$GCC\" = x\"yes\"; then\n\tif test -x /usr/bin/cygpath; then\n\t\tCFLAGS=\"$CFLAGS -O2\"\n\t\tMIXED_CYGWIN=yes\n\t\tAC_MSG_RESULT([yes])\n\t\tMIXED_CYGWIN_MINGW=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DERTS_MIXED_CYGWIN_MINGW\"\n\telse\n\t\tAC_MSG_RESULT([undeterminable])\n\t\tAC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)\n\tfi\n    else\n\tAC_MSG_RESULT([no])\n\tMIXED_CYGWIN_MINGW=no\n    fi\nelse\n\tMIXED_CYGWIN_MINGW=no\nfi\t\nAC_SUBST(MIXED_CYGWIN_MINGW)\n\nAC_MSG_CHECKING(if we mix cygwin with any native compiler)\nif test \"X$MIXED_CYGWIN\" = \"Xyes\"; then\n\tAC_MSG_RESULT([yes])\t\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nAC_SUBST(MIXED_CYGWIN)\n\t\nAC_MSG_CHECKING(if we mix msys with another native compiler)\nif test \"X$MIXED_MSYS\" = \"Xyes\" ; then\n\tAC_MSG_RESULT([yes])\t\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nAC_SUBST(MIXED_MSYS)\n\nfi\n])\t\t\n\t\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_FIND_EMU_CC\ndnl\ndnl\ndnl Tries fairly hard to find a C compiler that can handle jump tables.\ndnl Defines the @EMU_CC@ variable for the makefiles and \ndnl inserts NO_JUMP_TABLE in the header if one cannot be found...\ndnl\n\nAC_DEFUN(LM_FIND_EMU_CC,\n\t[AC_CACHE_CHECK(for a compiler that handles jumptables,\n\t\t\tac_cv_prog_emu_cc,\n\t\t\t[\nAC_TRY_COMPILE([],[\n#if defined(__clang_major__) && __clang_major__ >= 3\n    /* clang 3.x or later is fine */\n#elif defined(__llvm__)\n#error \"this version of llvm is unable to correctly compile beam_emu.c\"\n#endif\n    __label__ lbl1;\n    __label__ lbl2;\n    int x = magic();\n    static void *jtab[2];\n\n    jtab[0] = &&lbl1;\n    jtab[1] = &&lbl2;\n    goto *jtab[x];\nlbl1:\n    return 1;\nlbl2:\n    return 2;\n],ac_cv_prog_emu_cc=\"$CC\",ac_cv_prog_emu_cc=no)\n\nif test \"$ac_cv_prog_emu_cc\" = no; then\n\tfor ac_progname in emu_cc.sh gcc-4.2 gcc; do\n  \t\tIFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\":\"\n  \t\tac_dummy=\"$PATH\"\n  \t\tfor ac_dir in $ac_dummy; do\n    \t\t\ttest -z \"$ac_dir\" && ac_dir=.\n    \t\t\tif test -f \"$ac_dir/$ac_progname\"; then\n      \t\t\t\tac_cv_prog_emu_cc=\"$ac_dir/$ac_progname\"\n      \t\t\t\tbreak\n    \t\t\tfi\n  \t\tdone\n  \t\tIFS=\"$ac_save_ifs\"\n\t\tif test \"$ac_cv_prog_emu_cc\" != no; then\n\t\t\tbreak\n\t\tfi\n\tdone\nfi\n\nif test \"$ac_cv_prog_emu_cc\" != no; then\n\tsave_CC=\"$CC\"\n\tsave_CFLAGS=$CFLAGS\n\tsave_CPPFLAGS=$CPPFLAGS\n\tCC=\"$ac_cv_prog_emu_cc\"\n\tCFLAGS=\"\"\n\tCPPFLAGS=\"\"\n\tAC_TRY_COMPILE([],[\n#if defined(__clang_major__) && __clang_major__ >= 3\n    /* clang 3.x or later is fine */\n#elif defined(__llvm__)\n#error \"this version of llvm is unable to correctly compile beam_emu.c\"\n#endif\n    \t__label__ lbl1;\n    \t__label__ lbl2;\n    \tint x = magic();\n    \tstatic void *jtab[2];\n\n    \tjtab[0] = &&lbl1;\n    \tjtab[1] = &&lbl2;\n    \tgoto *jtab[x];\n\tlbl1:\n    \treturn 1;\n\tlbl2:\n    \treturn 2;\n\t],ac_cv_prog_emu_cc=\"$CC\",ac_cv_prog_emu_cc=no)\n\tCC=$save_CC\n\tCFLAGS=$save_CFLAGS\n\tCPPFLAGS=$save_CPPFLAGS\nfi\n])\nif test \"$ac_cv_prog_emu_cc\" = no; then\n\tAC_DEFINE(NO_JUMP_TABLE,[],[Defined if no found C compiler can handle jump tables])\n\tEMU_CC=\"$CC\"\nelse\n\tEMU_CC=\"$ac_cv_prog_emu_cc\"\nfi\nAC_SUBST(EMU_CC)\n])\t\t\n\t\t\t\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_PROG_INSTALL_DIR\ndnl\ndnl This macro may be used by any OTP application.\ndnl\ndnl Figure out how to create directories with parents.\ndnl (In my opinion INSTALL_DIR is a bad name, MKSUBDIRS or something is better)\ndnl\ndnl We prefer 'install -d', but use 'mkdir -p' if it exists.\ndnl If none of these methods works, we give up.\ndnl\n\n\nAC_DEFUN(LM_PROG_INSTALL_DIR,\n[AC_CACHE_CHECK(how to create a directory including parents,\nac_cv_prog_mkdir_p,\n[\ntemp_name_base=config.$$\ntemp_name=$temp_name_base/x/y/z\n$INSTALL -d $temp_name >/dev/null 2>&1\nac_cv_prog_mkdir_p=none\nif test -d $temp_name; then\n        ac_cv_prog_mkdir_p=\"$INSTALL -d\"\nelse\n        mkdir -p $temp_name >/dev/null 2>&1\n        if test -d $temp_name; then\n                ac_cv_prog_mkdir_p=\"mkdir -p\"\n        fi\nfi\nrm -fr $temp_name_base           \n])\n\ncase \"${ac_cv_prog_mkdir_p}\" in\n  none) AC_MSG_ERROR(don't know how create directories with parents) ;;\n  *)    INSTALL_DIR=\"$ac_cv_prog_mkdir_p\" AC_SUBST(INSTALL_DIR)     ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_PROG_PERL5\ndnl\ndnl Try to find perl version 5. If found set PERL to the absolute path\ndnl of the program, if not found set PERL to false.\ndnl\ndnl On some systems /usr/bin/perl is perl 4 and e.g.\ndnl /usr/local/bin/perl is perl 5. We try to handle this case by\ndnl putting a couple of \ndnl Tries to handle the case that there are two programs called perl\ndnl in the path and one of them is perl 5 and the other isn't. \ndnl\nAC_DEFUN(LM_PROG_PERL5,\n[AC_PATH_PROGS(PERL, perl5 perl, false,\n   /usr/local/bin:/opt/local/bin:/usr/local/gnu/bin:${PATH})\nchangequote(, )dnl\ndnl[ That bracket is needed to balance the right bracket below\nif test \"$PERL\" = \"false\" || $PERL -e 'exit ($] >= 5)'; then\nchangequote([, ])dnl\n  ac_cv_path_PERL=false\n  PERL=false\ndnl  AC_MSG_WARN(perl version 5 not found)\nfi\n])dnl\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_SO_BSDCOMPAT\ndnl\ndnl Check if the system has the SO_BSDCOMPAT flag on sockets (linux) \ndnl\nAC_DEFUN(LM_DECL_SO_BSDCOMPAT,\n[AC_CACHE_CHECK([for SO_BSDCOMPAT declaration], ac_cv_decl_so_bsdcompat,\nAC_TRY_COMPILE([#include <sys/socket.h>], [int i = SO_BSDCOMPAT;],\n               ac_cv_decl_so_bsdcompat=yes,\n               ac_cv_decl_so_bsdcompat=no))\n\ncase \"${ac_cv_decl_so_bsdcompat}\" in\n  \"yes\" ) AC_DEFINE(HAVE_SO_BSDCOMPAT,[],\n\t\t[Define if you have SO_BSDCOMPAT flag on sockets]) ;;\n  * ) ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_INADDR_LOOPBACK\ndnl\ndnl Try to find declaration of INADDR_LOOPBACK, if nowhere provide a default\ndnl\n\nAC_DEFUN(LM_DECL_INADDR_LOOPBACK,\n[AC_CACHE_CHECK([for INADDR_LOOPBACK in netinet/in.h],\n ac_cv_decl_inaddr_loopback,\n[AC_TRY_COMPILE([#include <sys/types.h>\n#include <netinet/in.h>], [int i = INADDR_LOOPBACK;],\nac_cv_decl_inaddr_loopback=yes, ac_cv_decl_inaddr_loopback=no)\n])\n\nif test ${ac_cv_decl_inaddr_loopback} = no; then\n  AC_CACHE_CHECK([for INADDR_LOOPBACK in rpc/types.h],\n                   ac_cv_decl_inaddr_loopback_rpc,\n                   AC_TRY_COMPILE([#include <rpc/types.h>],\n                                   [int i = INADDR_LOOPBACK;],\n                                   ac_cv_decl_inaddr_loopback_rpc=yes,\n                                   ac_cv_decl_inaddr_loopback_rpc=no))\n\n   case \"${ac_cv_decl_inaddr_loopback_rpc}\" in\n     \"yes\" )\n        AC_DEFINE(DEF_INADDR_LOOPBACK_IN_RPC_TYPES_H,[],\n\t\t[Define if you need to include rpc/types.h to get INADDR_LOOPBACK defined]) ;;\n      * )\n  \tAC_CACHE_CHECK([for INADDR_LOOPBACK in winsock2.h],\n                   ac_cv_decl_inaddr_loopback_winsock2,\n                   AC_TRY_COMPILE([#define WIN32_LEAN_AND_MEAN\n\t\t\t\t   #include <winsock2.h>],\n                                   [int i = INADDR_LOOPBACK;],\n                                   ac_cv_decl_inaddr_loopback_winsock2=yes,\n                                   ac_cv_decl_inaddr_loopback_winsock2=no))\n\tcase \"${ac_cv_decl_inaddr_loopback_winsock2}\" in\n     \t\t\"yes\" )\n\t\t\tAC_DEFINE(DEF_INADDR_LOOPBACK_IN_WINSOCK2_H,[],\n\t\t\t\t[Define if you need to include winsock2.h to get INADDR_LOOPBACK defined]) ;;\n\t\t* )\n\t\t\t# couldn't find it anywhere\n        \t\tAC_DEFINE(HAVE_NO_INADDR_LOOPBACK,[],\n\t\t\t\t[Define if you don't have a definition of INADDR_LOOPBACK]) ;;\n\tesac;;\n   esac\nfi\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_STRUCT_SOCKADDR_SA_LEN\ndnl\ndnl Check if the sockaddr structure has the field sa_len\ndnl\n\nAC_DEFUN(LM_STRUCT_SOCKADDR_SA_LEN,\n[AC_CACHE_CHECK([whether struct sockaddr has sa_len field],\n                ac_cv_struct_sockaddr_sa_len,\nAC_TRY_COMPILE([#include <sys/types.h>\n#include <sys/socket.h>], [struct sockaddr s; s.sa_len = 10;],\n  ac_cv_struct_sockaddr_sa_len=yes, ac_cv_struct_sockaddr_sa_len=no))\n\ndnl FIXME convbreak\ncase ${ac_cv_struct_sockaddr_sa_len} in\n  \"no\" ) AC_DEFINE(NO_SA_LEN,[1],[Define if you dont have salen]) ;;\n  *) ;;\nesac\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_STRUCT_EXCEPTION\ndnl\ndnl Check to see whether the system supports the matherr function\ndnl and its associated type \"struct exception\".\ndnl\n\nAC_DEFUN(LM_STRUCT_EXCEPTION,\n[AC_CACHE_CHECK([for struct exception (and matherr function)],\n ac_cv_struct_exception,\nAC_TRY_COMPILE([#include <math.h>],\n  [struct exception x; x.type = DOMAIN; x.type = SING;],\n  ac_cv_struct_exception=yes, ac_cv_struct_exception=no))\n\ncase \"${ac_cv_struct_exception}\" in\n  \"yes\" ) AC_DEFINE(USE_MATHERR,[1],[Define if you have matherr() function and struct exception type]) ;;\n  *  ) ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_SYS_IPV6\ndnl\ndnl Check for ipv6 support and what the in6_addr structure is called.\ndnl (early linux used in_addr6 insted of in6_addr)\ndnl\n\nAC_DEFUN(LM_SYS_IPV6,\n[AC_MSG_CHECKING(for IP version 6 support)\nAC_CACHE_VAL(ac_cv_sys_ipv6_support,\n[ok_so_far=yes\n AC_TRY_COMPILE([#include <sys/types.h>\n#ifdef __WIN32__\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <netinet/in.h>\n#endif],\n   [struct in6_addr a6; struct sockaddr_in6 s6;], ok_so_far=yes, ok_so_far=no)\n\nif test $ok_so_far = yes; then\n  ac_cv_sys_ipv6_support=yes\nelse\n  AC_TRY_COMPILE([#include <sys/types.h>\n#ifdef __WIN32__\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <netinet/in.h>\n#endif],\n    [struct in_addr6 a6; struct sockaddr_in6 s6;],\n    ac_cv_sys_ipv6_support=in_addr6, ac_cv_sys_ipv6_support=no)\nfi\n])dnl\n\ndnl\ndnl Have to use old style AC_DEFINE due to BC with old autoconf.\ndnl\n\ncase ${ac_cv_sys_ipv6_support} in\n  yes)\n    AC_MSG_RESULT(yes)\n    AC_DEFINE(HAVE_IN6,[1],[Define if ipv6 is present])\n    ;;\n  in_addr6)\n    AC_MSG_RESULT([yes (but I am redefining in_addr6 to in6_addr)])\n    AC_DEFINE(HAVE_IN6,[1],[Define if ipv6 is present])\n    AC_DEFINE(HAVE_IN_ADDR6_STRUCT,[],[Early linux used in_addr6 instead of in6_addr, define if you have this])\n    ;;\n  *)\n    AC_MSG_RESULT(no)\n    ;;\nesac\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_SYS_MULTICAST\ndnl\ndnl Check for multicast support. Only checks for multicast options in\ndnl setsockopt(), no check is performed that multicasting actually works.\ndnl If options are found defines HAVE_MULTICAST_SUPPORT\ndnl\n\nAC_DEFUN(LM_SYS_MULTICAST,\n[AC_CACHE_CHECK([for multicast support], ac_cv_sys_multicast_support,\n[AC_EGREP_CPP(^yes$,\n[#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#if defined(IP_MULTICAST_TTL) && defined(IP_MULTICAST_LOOP) && defined(IP_MULTICAST_IF) && defined(IP_ADD_MEMBERSHIP) && defined(IP_DROP_MEMBERSHIP)\nyes\n#endif\n], ac_cv_sys_multicast_support=yes, ac_cv_sys_multicast_support=no)])\nif test $ac_cv_sys_multicast_support = yes; then\n  AC_DEFINE(HAVE_MULTICAST_SUPPORT,[1],\n\t[Define if setsockopt() accepts multicast options])\nfi\n])dnl\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_DECL_SYS_ERRLIST\ndnl\ndnl Define SYS_ERRLIST_DECLARED if the variable sys_errlist is declared\ndnl in a system header file, stdio.h or errno.h.\ndnl\n\nAC_DEFUN(LM_DECL_SYS_ERRLIST,\n[AC_CACHE_CHECK([for sys_errlist declaration in stdio.h or errno.h],\n  ac_cv_decl_sys_errlist,\n[AC_TRY_COMPILE([#include <stdio.h>\n#include <errno.h>], [char *msg = *(sys_errlist + 1);],\n  ac_cv_decl_sys_errlist=yes, ac_cv_decl_sys_errlist=no)])\nif test $ac_cv_decl_sys_errlist = yes; then\n  AC_DEFINE(SYS_ERRLIST_DECLARED,[],\n\t[define if the variable sys_errlist is declared in a system header file])\nfi\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_CHECK_FUNC_DECL( funname, declaration [, extra includes \ndnl                     [, action-if-found [, action-if-not-found]]] )\ndnl\ndnl Checks if the declaration \"declaration\" of \"funname\" conflicts\ndnl with the header files idea of how the function should be\ndnl declared. It is useful on systems which lack prototypes and you\ndnl need to provide your own (e.g. when you want to take the address\ndnl of a function). The 4'th argument is expanded if conflicting, \ndnl the 5'th argument otherwise\ndnl\ndnl\n\nAC_DEFUN(LM_CHECK_FUNC_DECL,\n[AC_MSG_CHECKING([for conflicting declaration of $1])\nAC_CACHE_VAL(ac_cv_func_decl_$1,\n[AC_TRY_COMPILE([#include <stdio.h>\n$3],[$2\nchar *c = (char *)$1;\n], eval \"ac_cv_func_decl_$1=no\", eval \"ac_cv_func_decl_$1=yes\")])\nif eval \"test \\\"`echo '$ac_cv_func_decl_'$1`\\\" = yes\"; then\n  AC_MSG_RESULT(yes)\n  ifelse([$4], , :, [$4])\nelse\n  AC_MSG_RESULT(no)\nifelse([$5], , , [$5\n])dnl\nfi\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl AC_DOUBLE_MIDDLE_ENDIAN\ndnl\ndnl Checks whether doubles are represented in \"middle-endian\" format.\ndnl Sets ac_cv_double_middle_endian={no,yes,unknown} accordingly,\ndnl as well as DOUBLE_MIDDLE_ENDIAN.\ndnl\ndnl\n\nAC_DEFUN([AC_C_DOUBLE_MIDDLE_ENDIAN],\n[AC_CACHE_CHECK(whether double word ordering is middle-endian, ac_cv_c_double_middle_endian,\n[# It does not; compile a test program.\nAC_RUN_IFELSE(\n[AC_LANG_SOURCE([[#include <stdlib.h>\n\nint\nmain(void)\n{\n  int i = 0;\n  int zero = 0;\n  int bigendian;\n  int zero_index = 0;\n\n  union\n  {\n    long int l;\n    char c[sizeof (long int)];\n  } u;\n\n  /* we'll use the one with 32-bit words */\n  union\n  {\n    double d;\n    unsigned int c[2];\n  } vint;\n\n  union\n  {\n    double d;\n    unsigned long c[2];\n  } vlong;\n\n  union\n  {\n    double d;\n    unsigned short c[2];\n  } vshort;\n\n\n  /* Are we little or big endian?  From Harbison&Steele.  */\n  u.l = 1;\n  bigendian = (u.c[sizeof (long int) - 1] == 1);\n\n  zero_index = bigendian ? 1 : 0;\n\n  vint.d = 1.0;\n  vlong.d = 1.0;\n  vshort.d = 1.0;\n\n  if (sizeof(unsigned int) == 4)\n    {\n      if (vint.c[zero_index] != 0)\n\tzero = 1;\n    }\n  else if (sizeof(unsigned long) == 4)\n    {\n      if (vlong.c[zero_index] != 0)\n\tzero = 1;\n    }\n  else if (sizeof(unsigned short) == 4)\n    {\n      if (vshort.c[zero_index] != 0)\n\tzero = 1;\n    }\n\n  exit (zero);\n}\n]])],\n\t      [ac_cv_c_double_middle_endian=no],\n\t      [ac_cv_c_double_middle_endian=yes],\n\t      [ac_cv_c_double_middle=unknown])])\ncase $ac_cv_c_double_middle_endian in\n  yes)\n    m4_default([$1],\n      [AC_DEFINE([DOUBLE_MIDDLE_ENDIAN], 1,\n\t[Define to 1 if your processor stores the words in a double in\n\t middle-endian format (like some ARMs).])]) ;;\n  no)\n    $2 ;;\n  *)\n    m4_default([$3],\n      [AC_MSG_WARN([unknown double endianness\npresetting ac_cv_c_double_middle_endian=no (or yes) will help])]) ;;\nesac\n])# AC_C_DOUBLE_MIDDLE_ENDIAN\n\n\nAC_DEFUN(ERL_MONOTONIC_CLOCK,\n[\n  if test \"$3\" = \"yes\"; then\n     default_resolution_clock_gettime_monotonic=\"CLOCK_HIGHRES CLOCK_BOOTTIME CLOCK_MONOTONIC\"\n     low_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_COARSE CLOCK_MONOTONIC_FAST\"\n     high_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_PRECISE\"\n  else\n     default_resolution_clock_gettime_monotonic=\"CLOCK_HIGHRES CLOCK_UPTIME CLOCK_MONOTONIC\"\n     low_resolution_clock_gettime_monotonic=\"CLOCK_MONOTONIC_COARSE CLOCK_UPTIME_FAST\"\n     high_resolution_clock_gettime_monotonic=\"CLOCK_UPTIME_PRECISE\"\n  fi\n\n  case \"$1\" in\n    high_resolution)\n\tcheck_msg=\"high resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$high_resolution_clock_gettime_monotonic\"\n\t;;\n    low_resolution)\n\tcheck_msg=\"low resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$low_resolution_clock_gettime_monotonic\"\n\t;;\n    custom_resolution)\n\tcheck_msg=\"custom resolution \"\n\tprefer_resolution_clock_gettime_monotonic=\"$2\"\n\t;;\n    *)\n\tcheck_msg=\"custom \"\n\tprefer_resolution_clock_gettime_monotonic=\"$2\"\n\t;;\n  esac\n\n  clock_gettime_lib=\"\"\n  AC_CHECK_LIB(rt, clock_gettime, [clock_gettime_lib=\"-lrt\"])\n\n  save_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $clock_gettime_lib\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     trust_test=\"#error May not be there due to weak linking\"\n  else\n     trust_test=\"\"\n  fi\n\n  AC_CACHE_CHECK([for clock_gettime(CLOCK_MONOTONIC_RAW, _)], erl_cv_clock_gettime_monotonic_raw,\n  [\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime(CLOCK_MONOTONIC_RAW, &ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_monotonic_raw=yes,\n\t\t      erl_cv_clock_gettime_monotonic_raw=no)\n  ])\n\n  AC_CACHE_CHECK([for clock_gettime() with ${check_msg}monotonic clock type], erl_cv_clock_gettime_monotonic_$1,\n  [\n     for clock_type in $prefer_resolution_clock_gettime_monotonic $default_resolution_clock_gettime_monotonic $high_resolution_clock_gettime_monotonic $low_resolution_clock_gettime_monotonic; do\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime($clock_type,&ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_monotonic_$1=$clock_type,\n\t\t      erl_cv_clock_gettime_monotonic_$1=no)\n       test $erl_cv_clock_gettime_monotonic_$1 = no || break\n     done\n  ])\n\n  LIBS=\"$save_LIBS\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     check_for_clock_getres=\n  else\n     check_for_clock_getres=clock_getres\n  fi\n\n  AC_CHECK_FUNCS([$check_for_clock_getres clock_get_attributes gethrtime])\n  \n  AC_CACHE_CHECK([for mach clock_get_time() with monotonic clock type], erl_cv_mach_clock_get_time_monotonic,\n  [\n     AC_TRY_COMPILE([\n#include <mach/clock.h>\n#include <mach/mach.h>\n\t\t\t],\n\t \t\t[\n    kern_return_t res;\n    clock_serv_t clk_srv;\n    mach_timespec_t time_spec;\n\n    host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &clk_srv);\n    res = clock_get_time(clk_srv, &time_spec);\n    mach_port_deallocate(mach_task_self(), clk_srv);\n    \t\t\t],\n    \t\t\terl_cv_mach_clock_get_time_monotonic=yes,\n\t\t\terl_cv_mach_clock_get_time_monotonic=no)\n  ])\n  \n  erl_corrected_monotonic_clock=no\n  case $erl_cv_clock_gettime_monotonic_$1-$ac_cv_func_gethrtime-$erl_cv_mach_clock_get_time_monotonic-$host_os in\n    *-*-*-win32)\n      erl_monotonic_clock_func=WindowsAPI\n      ;;\n    CLOCK_*-*-*-linux*)\n      case $erl_cv_clock_gettime_monotonic_$1-$erl_cv_clock_gettime_monotonic_raw in\n        CLOCK_BOOTTIME-yes|CLOCK_MONOTONIC-yes)\n\t  erl_corrected_monotonic_clock=yes\n\t  ;;\n\t*)\n\t  # We don't trust CLOCK_MONOTONIC to be NTP\n\t  # adjusted on linux systems that do not have\n\t  # CLOCK_MONOTONIC_RAW (although it seems to\n\t  # be...)\n\t  ;;\n      esac\n      erl_monotonic_clock_func=clock_gettime\n      ;;\n    no-no-no-linux*)\n      erl_monotonic_clock_func=times\n      ;;\n    CLOCK_*-*-*-*)\n      erl_monotonic_clock_func=clock_gettime\n      ;;\n    no-yes-*-*)\n      erl_monotonic_clock_func=gethrtime\n      ;;\n    no-no-yes-*)\n      erl_monotonic_clock_func=mach_clock_get_time\n      ;;\n    no-no-no-*)\n      erl_monotonic_clock_func=none\n      ;;\n  esac\n\n  erl_monotonic_clock_low_resolution=no\n  erl_monotonic_clock_lib=\n  erl_monotonic_clock_id=\n  case $erl_monotonic_clock_func in\n    clock_gettime)\n      erl_monotonic_clock_id=$erl_cv_clock_gettime_monotonic_$1\n      for low_res_id in $low_resolution_clock_gettime_monotonic; do\n      \t  if test $erl_monotonic_clock_id = $low_res_id; then\n\t    erl_monotonic_clock_low_resolution=yes\n\t    break\n\t  fi\n      done\n      erl_monotonic_clock_lib=$clock_gettime_lib\n      ;;\n    mach_clock_get_time)\n      erl_monotonic_clock_id=SYSTEM_CLOCK\n      ;;\n    times)\n      erl_monotonic_clock_low_resolution=yes\n      ;;\n    *)\n      ;;\n  esac\n \n])\n\nAC_DEFUN(ERL_WALL_CLOCK,\n[\n  default_resolution_clock_gettime_wall=\"CLOCK_REALTIME\"\n  low_resolution_clock_gettime_wall=\"CLOCK_REALTIME_COARSE CLOCK_REALTIME_FAST\"\n  high_resolution_clock_gettime_wall=\"CLOCK_REALTIME_PRECISE\"\n\n  case \"$1\" in\n    high_resolution)\n\tcheck_msg=\"high resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$high_resolution_clock_gettime_wall\"\n\t;;\n    low_resolution)\n\tcheck_msg=\"low resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$low_resolution_clock_gettime_wall\"\n\t;;\n    custom_resolution)\n\tcheck_msg=\"custom resolution \"\n\tprefer_resolution_clock_gettime_wall=\"$2\"\n\t;;\n    *)\n\tcheck_msg=\"\"\n\tprefer_resolution_clock_gettime_wall=\n\t;;\n  esac\n\n  clock_gettime_lib=\"\"\n  AC_CHECK_LIB(rt, clock_gettime, [clock_gettime_lib=\"-lrt\"])\n\n  save_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $clock_gettime_lib\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     trust_test=\"#error May not be there due to weak linking\"\n  else\n     trust_test=\"\"\n  fi\n\n  AC_CACHE_CHECK([for clock_gettime() with ${check_msg}wall clock type], erl_cv_clock_gettime_wall_$1,\n  [\n     for clock_type in $prefer_resolution_clock_gettime_wall $default_resolution_clock_gettime_wall $high_resolution_clock_gettime_wall $low_resolution_clock_gettime_wall; do\n       AC_TRY_LINK([\n#include <time.h>\n$trust_test\n\t\t      ],\n\t\t      [\n    struct timespec ts;\n    long long result;\n    clock_gettime($clock_type,&ts);\n    result = ((long long) ts.tv_sec) * 1000000000LL + \n    ((long long) ts.tv_nsec);\n\t\t      ],\n\t\t      erl_cv_clock_gettime_wall_$1=$clock_type,\n\t\t      erl_cv_clock_gettime_wall_$1=no)\n       test $erl_cv_clock_gettime_wall_$1 = no || break\n     done\n  ])\n\n  LIBS=\"$save_LIBS\"\n\n  if test \"$LD_MAY_BE_WEAK\" != \"no\"; then\n     check_for_clock_getres=\n  else\n     check_for_clock_getres=clock_getres\n  fi\n\n  AC_CHECK_FUNCS([$check_for_clock_getres clock_get_attributes gettimeofday])\n  \n  AC_CACHE_CHECK([for mach clock_get_time() with wall clock type], erl_cv_mach_clock_get_time_wall,\n  [\n     AC_TRY_COMPILE([\n#include <mach/clock.h>\n#include <mach/mach.h>\n\t\t\t],\n\t \t\t[\n    kern_return_t res;\n    clock_serv_t clk_srv;\n    mach_timespec_t time_spec;\n\n    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &clk_srv);\n    res = clock_get_time(clk_srv, &time_spec);\n    mach_port_deallocate(mach_task_self(), clk_srv);\n    \t\t\t],\n    \t\t\terl_cv_mach_clock_get_time_wall=yes,\n\t\t\terl_cv_mach_clock_get_time_wall=no)\n  ])\n\n  erl_wall_clock_lib=\n  erl_wall_clock_low_resolution=no\n  erl_wall_clock_id=\n  case $1-$erl_cv_clock_gettime_wall_$1-$erl_cv_mach_clock_get_time_wall-$ac_cv_func_gettimeofday-$host_os in\n    *-*-*-*-win32)\n      erl_wall_clock_func=WindowsAPI\n      erl_wall_clock_low_resolution=yes\n      ;;\n    high_resolution-no-yes-*-*)\n      erl_wall_clock_func=mach_clock_get_time\n      erl_wall_clock_id=CALENDAR_CLOCK\n      ;;\n    *-CLOCK_*-*-*-*)\n      erl_wall_clock_func=clock_gettime\n      erl_wall_clock_lib=$clock_gettime_lib\n      erl_wall_clock_id=$erl_cv_clock_gettime_wall_$1\n      for low_res_id in $low_resolution_clock_gettime_wall; do\n      \t  if test $erl_wall_clock_id = $low_res_id; then\n\t    erl_wall_clock_low_resolution=yes\n\t    break\n\t  fi\n      done\n      ;;\n    *-no-*-yes-*)\n      erl_wall_clock_func=gettimeofday\n      ;;\n    *)\n      erl_wall_clock_func=none\n      ;;\n  esac\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_CHECK_THR_LIB\ndnl\ndnl This macro may be used by any OTP application.\ndnl\ndnl LM_CHECK_THR_LIB sets THR_LIBS, THR_DEFS, and THR_LIB_NAME. It also\ndnl checks for some pthread headers which will appear in DEFS or config.h.\ndnl\n\nAC_DEFUN(LM_CHECK_THR_LIB,\n[\n\nNEED_NPTL_PTHREAD_H=no\n\ndnl win32?\nAC_MSG_CHECKING([for native win32 threads])\nif test \"X$host_os\" = \"Xwin32\"; then\n    AC_MSG_RESULT(yes)\n    THR_DEFS=\"-DWIN32_THREADS\"\n    THR_LIBS=\n    THR_LIB_NAME=win32_threads\n    THR_LIB_TYPE=win32_threads\nelse\n    AC_MSG_RESULT(no)\n    THR_DEFS=\n    THR_LIBS=\n    THR_LIB_NAME=\n    THR_LIB_TYPE=posix_unknown\n\ndnl Try to find POSIX threads\n\ndnl The usual pthread lib...\n    AC_CHECK_LIB(pthread, pthread_create, THR_LIBS=\"-lpthread\")\n\ndnl Very old versions of FreeBSD have pthreads in special c library, c_r...\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_CHECK_LIB(c_r, pthread_create, THR_LIBS=\"-lc_r\")\n    fi\n\ndnl QNX has pthreads in standard C library\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_CHECK_FUNC(pthread_create, THR_LIBS=\"none_needed\")\n    fi\n\ndnl On ofs1 the '-pthread' switch should be used\n    if test \"x$THR_LIBS\" = \"x\"; then\n\tAC_MSG_CHECKING([if the '-pthread' switch can be used])\n\tsaved_cflags=$CFLAGS\n\tCFLAGS=\"$CFLAGS -pthread\"\n\tAC_TRY_LINK([#include <pthread.h>],\n\t\t    pthread_create((void*)0,(void*)0,(void*)0,(void*)0);,\n\t\t    [THR_DEFS=\"-pthread\"\n\t\t     THR_LIBS=\"-pthread\"])\n\tCFLAGS=$saved_cflags\n\tif test \"x$THR_LIBS\" != \"x\"; then\n\t    AC_MSG_RESULT(yes)\n\telse\n\t    AC_MSG_RESULT(no)\n\tfi\n    fi\n\n    if test \"x$THR_LIBS\" != \"x\"; then\n\tTHR_DEFS=\"$THR_DEFS -D_THREAD_SAFE -D_REENTRANT -DPOSIX_THREADS\"\n\tTHR_LIB_NAME=pthread\n\tif test \"x$THR_LIBS\" = \"xnone_needed\"; then\n\t    THR_LIBS=\n\tfi\n\tcase $host_os in\n\t    solaris*)\n\t\tTHR_DEFS=\"$THR_DEFS -D_POSIX_PTHREAD_SEMANTICS\" ;;\n\t    linux*)\n\t\tTHR_DEFS=\"$THR_DEFS -D_POSIX_THREAD_SAFE_FUNCTIONS\"\n\n\t\tLM_CHECK_GETCONF\n\t\tAC_MSG_CHECKING(for Native POSIX Thread Library)\n\t\tlibpthr_vsn=`$GETCONF GNU_LIBPTHREAD_VERSION 2>/dev/null`\n\t\tif test $? -eq 0; then\n\t\t    case \"$libpthr_vsn\" in\n\t\t\t*nptl*|*NPTL*) nptl=yes;;\n\t\t\t*) nptl=no;;\n\t\t    esac\n\t\telif test \"$cross_compiling\" = \"yes\"; then\n\t\t    case \"$erl_xcomp_linux_nptl\" in\n\t\t\t\"\") nptl=cross;;\n\t\t\tyes|no) nptl=$erl_xcomp_linux_nptl;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_nptl value: $erl_xcomp_linux_nptl]);;\n\t\t    esac\n\t\telse\n\t\t    nptl=no\n\t\tfi\n\t\tAC_MSG_RESULT($nptl)\n\t\tif test $nptl = cross; then\n\t\t    nptl=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $nptl = yes; then\n\t\t    THR_LIB_TYPE=posix_nptl\n\t\t    need_nptl_incldir=no\n\t\t    AC_CHECK_HEADER(nptl/pthread.h,\n\t\t\t\t    [need_nptl_incldir=yes\n\t\t\t\t     NEED_NPTL_PTHREAD_H=yes])\n\t\t    if test $need_nptl_incldir = yes; then\n\t\t\t# Ahh...\n\t\t\tnptl_path=\"$C_INCLUDE_PATH:$CPATH\"\n\t\t\tif test X$cross_compiling != Xyes; then\n\t\t\t    nptl_path=\"$nptl_path:/usr/local/include:/usr/include\"\n\t\t\telse\n\t\t\t    IROOT=\"$erl_xcomp_isysroot\"\n\t\t\t    test \"$IROOT\" != \"\" || IROOT=\"$erl_xcomp_sysroot\"\n\t\t\t    test \"$IROOT\" != \"\" || AC_MSG_ERROR([Don't know where to search for includes! Please set erl_xcomp_isysroot])\n\t\t\t    nptl_path=\"$nptl_path:$IROOT/usr/local/include:$IROOT/usr/include\"\n\t\t\tfi\n\t\t\tnptl_ws_path=\n\t\t\tsave_ifs=\"$IFS\"; IFS=\":\"\n\t\t\tfor dir in $nptl_path; do\n\t\t\t    if test \"x$dir\" != \"x\"; then\n\t\t\t\tnptl_ws_path=\"$nptl_ws_path $dir\"\n\t\t\t    fi\n\t\t\tdone\n\t\t\tIFS=$save_ifs\n\t\t\tnptl_incldir=\n\t\t\tfor dir in $nptl_ws_path; do\n\t\t            AC_CHECK_HEADER($dir/nptl/pthread.h,\n\t\t\t\t\t    nptl_incldir=$dir/nptl)\n\t\t\t    if test \"x$nptl_incldir\" != \"x\"; then\n\t\t\t\tTHR_DEFS=\"$THR_DEFS -isystem $nptl_incldir\"\n\t\t\t\tbreak\n\t\t\t    fi\n\t\t\tdone\n\t\t\tif test \"x$nptl_incldir\" = \"x\"; then\n\t\t\t    AC_MSG_ERROR(Failed to locate nptl system include directory)\n\t\t\tfi\n\t\t    fi\n\t\tfi\n\t\t;;\n\t    *) ;;\n\tesac\n\n\tdnl We sometimes need THR_DEFS in order to find certain headers\n\tdnl (at least for pthread.h on osf1).\n\tsaved_cppflags=$CPPFLAGS\n\tCPPFLAGS=\"$CPPFLAGS $THR_DEFS\"\n\n\tdnl\n\tdnl Check for headers\n\tdnl\n\n\tAC_CHECK_HEADER(pthread.h,\n\t\t\tAC_DEFINE(HAVE_PTHREAD_H, 1, \\\n[Define if you have the <pthread.h> header file.]))\n\n\tdnl Some Linuxes have <pthread/mit/pthread.h> instead of <pthread.h>\n\tAC_CHECK_HEADER(pthread/mit/pthread.h, \\\n\t\t\tAC_DEFINE(HAVE_MIT_PTHREAD_H, 1, \\\n[Define if the pthread.h header file is in pthread/mit directory.]))\n\n\tdnl restore CPPFLAGS\n\tCPPFLAGS=$saved_cppflags\n\n    fi\nfi\n\n])\n\nAC_DEFUN(ERL_INTERNAL_LIBS,\n[\n\nERTS_INTERNAL_X_LIBS=\n\nAC_CHECK_LIB(kstat, kstat_open,\n[AC_DEFINE(HAVE_KSTAT, 1, [Define if you have kstat])\nERTS_INTERNAL_X_LIBS=\"$ERTS_INTERNAL_X_LIBS -lkstat\"])\n\nAC_SUBST(ERTS_INTERNAL_X_LIBS)\n\n])\n\nAC_DEFUN(ETHR_CHK_GCC_ATOMIC_OP__,\n[\n    # $1 - atomic_op\n\n    for atomic_bit_size in 32 64 128; do\n\tcase $atomic_bit_size in\n\t    32) gcc_atomic_type=\"$gcc_atomic_type32\";;\n\t    64) gcc_atomic_type=\"$gcc_atomic_type64\";;\n\t    128) gcc_atomic_type=\"$gcc_atomic_type128\";;\n\tesac\n\tgcc_atomic_lockfree=\"int x[[(2*__atomic_always_lock_free(sizeof($gcc_atomic_type), 0))-1]]\"\n\tcase $1 in\n\t    __sync_add_and_fetch | __sync_fetch_and_and | __sync_fetch_and_or)\n\t\tatomic_call=\"volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0);\"\n\t\t;;\n\t    __sync_val_compare_and_swap)\n\t\tatomic_call=\"volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0, ($gcc_atomic_type) 0);\"\n\t\t;;\n\t    __atomic_store_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELAXED); $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELEASE);\"\n\t\t;;\n\t    __atomic_load_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, __ATOMIC_RELAXED); res = $1(&var, __ATOMIC_ACQUIRE);\"\n\t\t;;\n\t    __atomic_add_fetch| __atomic_fetch_and | __atomic_fetch_or)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELAXED); res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_ACQUIRE); res = $1(&var, ($gcc_atomic_type) 0, __ATOMIC_RELEASE);\"\n\t\t;;\n\t    __atomic_compare_exchange_n)\n\t\tatomic_call=\"$gcc_atomic_lockfree; volatile $gcc_atomic_type var; $gcc_atomic_type val; int res = $1(&var, &val, ($gcc_atomic_type) 0, 0, __ATOMIC_RELAXED, __ATOMIC_RELAXED); res = $1(&var, &val, ($gcc_atomic_type) 0, 0, __ATOMIC_ACQUIRE, __ATOMIC_ACQUIRE);\"\n\t\t;;\n\t    *)\n\t\tAC_MSG_ERROR([Internal error: missing implementation for $1])\n\t\t;;\n\tesac\n\teval atomic${atomic_bit_size}_call=\\\"$atomic_call\\\"\n    done\n    \n    AC_CACHE_CHECK([for 32-bit $1()], ethr_cv_32bit_$1,\n\t\t   [\n\t\t       ethr_cv_32bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic32_call], [ethr_cv_32bit_$1=yes])\n\t\t   ])\n    AC_CACHE_CHECK([for 64-bit $1()], ethr_cv_64bit_$1,\n\t\t   [\n\t\t       ethr_cv_64bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic64_call], [ethr_cv_64bit_$1=yes])\n\t\t   ])\n    AC_CACHE_CHECK([for 128-bit $1()], ethr_cv_128bit_$1,\n\t\t   [\n\t\t       ethr_cv_128bit_$1=no\n\t\t       AC_TRY_LINK([], [$atomic128_call], [ethr_cv_128bit_$1=yes])\n\t\t   ])\n\n\tcase $ethr_cv_128bit_$1-$ethr_cv_64bit_$1-$ethr_cv_32bit_$1 in\n\t    no-no-no)\n\t\thave_atomic_ops=0;;\n\t    no-no-yes)\n\t\thave_atomic_ops=4;;\n\t    no-yes-no)\n\t\thave_atomic_ops=8;;\n\t    no-yes-yes)\n\t\thave_atomic_ops=12;;\n\t    yes-no-no)\n\t\thave_atomic_ops=16;;\n\t    yes-no-yes)\n\t\thave_atomic_ops=20;;\n\t    yes-yes-no)\n\t\thave_atomic_ops=24;;\n\t    yes-yes-yes)\n\t\thave_atomic_ops=28;;\n\tesac\n\tAC_DEFINE_UNQUOTED([ETHR_HAVE_$1], [$have_atomic_ops], [Define as a bitmask corresponding to the word sizes that $1() can handle on your system])\n])\n\nAC_DEFUN(ETHR_CHK_IF_NOOP,\n[\n   ethr_test_filename=\"chk_if_$1$3_noop_config1test.$$\"\n   cat > \"${ethr_test_filename}.c\" <<EOF\nint\nmy_test(void)\n{\n    $1$2;\n    return 0;\n}\nEOF\n   $CC -O3 $ETHR_DEFS -c \"${ethr_test_filename}.c\" -o \"${ethr_test_filename}1.o\"\n   cat > \"${ethr_test_filename}.c\" <<EOF\nint\nmy_test(void)\n{\n    ;\n    return 0;\n}\nEOF\n   $CC -O3 $ETHR_DEFS -c \"${ethr_test_filename}.c\" -o \"${ethr_test_filename}2.o\"\n   if diff \"${ethr_test_filename}1.o\" \"${ethr_test_filename}2.o\" >/dev/null 2>&1; then\n      ethr_$1$3_noop=yes\n   else\n      ethr_$1$3_noop=no\n   fi\n   rm -f \"${ethr_test_filename}.c\" \"${ethr_test_filename}1.o\"  \"${ethr_test_filename}2.o\" \n])\n\nAC_DEFUN(ETHR_CHK_GCC_ATOMIC_OPS,\n[\n    AC_CHECK_SIZEOF(short)\n    AC_CHECK_SIZEOF(int)\n    AC_CHECK_SIZEOF(long)\n    AC_CHECK_SIZEOF(long long)\n    AC_CHECK_SIZEOF(__int128_t)\n\n    if test \"$ac_cv_sizeof_short\" = \"4\"; then\n\tgcc_atomic_type32=\"short\"\n    elif test \"$ac_cv_sizeof_int\" = \"4\"; then\n\tgcc_atomic_type32=\"int\"\n    elif test \"$ac_cv_sizeof_long\" = \"4\"; then\n\tgcc_atomic_type32=\"long\"\n    else\n\tAC_MSG_ERROR([No 32-bit type found])\n    fi\n\n    if test \"$ac_cv_sizeof_int\" = \"8\"; then\n\tgcc_atomic_type64=\"int\"\n    elif test \"$ac_cv_sizeof_long\" = \"8\"; then\n\tgcc_atomic_type64=\"long\"\n    elif test \"$ac_cv_sizeof_long_long\" = \"8\"; then\n\tgcc_atomic_type64=\"long long\"\n    else\n\tAC_MSG_ERROR([No 64-bit type found])\n    fi\n\n    if test \"$ac_cv_sizeof___int128_t\" = \"16\"; then\n\tgcc_atomic_type128=\"__int128_t\"\n    else\n\tgcc_atomic_type128=\"#error \"\t\n    fi\n    AC_CACHE_CHECK([for a working __sync_synchronize()], ethr_cv___sync_synchronize,\n\t\t   [\n\t\t       ethr_cv___sync_synchronize=no\n\t\t       AC_TRY_LINK([],\n\t\t\t\t   [ __sync_synchronize(); ],\n\t\t\t\t   [ethr_cv___sync_synchronize=yes])\n\t\t       if test $ethr_cv___sync_synchronize = yes; then\n\t\t\t   #\n\t\t\t   # Old gcc versions on at least x86 have a buggy\n\t\t\t   # __sync_synchronize() which does not emit a\n\t\t\t   # memory barrier. We try to detect this by\n\t\t\t   # compiling to assembly with and without\n\t\t\t   # __sync_synchronize() and compare the results.\n\t\t\t   #\n\t\t\t   ETHR_CHK_IF_NOOP(__sync_synchronize, [()], [])\n\t\t\t   if test $ethr___sync_synchronize_noop = yes; then\n\t\t\t      # Got a buggy implementation of\n\t\t\t      # __sync_synchronize...\n\t\t\t      ethr_cv___sync_synchronize=\"no; buggy implementation\"\n\t\t\t   fi\n\t\t       fi\n\t\t   ])\n\n    if test \"$ethr_cv___sync_synchronize\" = \"yes\"; then\n\thave_sync_synchronize_value=\"~0\"\n    else\n\thave_sync_synchronize_value=\"0\"\n    fi\n    AC_DEFINE_UNQUOTED([ETHR_HAVE___sync_synchronize], [$have_sync_synchronize_value], [Define as a bitmask corresponding to the word sizes that __sync_synchronize() can handle on your system])\n\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_add_and_fetch)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_fetch_and_and)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_fetch_and_or)\n    ETHR_CHK_GCC_ATOMIC_OP__(__sync_val_compare_and_swap)\n\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_store_n)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_load_n)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_add_fetch)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_fetch_and)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_fetch_or)\n    ETHR_CHK_GCC_ATOMIC_OP__(__atomic_compare_exchange_n)\n\n    ethr_have_gcc_native_atomics=no\n    ethr_arm_dbm_instr_val=0\n    case \"$GCC-$host_cpu\" in\n\tyes-arm*)\n\t    AC_CACHE_CHECK([for ARM DMB instruction], ethr_cv_arm_dbm_instr,\n\t\t\t   [\n\t\t\t\tethr_cv_arm_dbm_instr=no\n\t\t\t\tAC_TRY_LINK([],\n\t\t\t\t\t    [\n\t\t\t\t\t\t__asm__ __volatile__(\"dmb sy\" : : : \"memory\");\n\t\t\t\t\t\t__asm__ __volatile__(\"dmb st\" : : : \"memory\");\n\t\t\t\t\t    ],\n\t\t\t\t\t    [ethr_cv_arm_dbm_instr=yes])\n\t\t\t   ])\n\t    if test $ethr_cv_arm_dbm_instr = yes; then\n\t\tethr_arm_dbm_instr_val=1\n\t\ttest $ethr_cv_64bit___atomic_compare_exchange_n = yes &&\n\t\t    ethr_have_gcc_native_atomics=yes\n\t    fi;;\n\t*)\n\t    ;;\n    esac\n    AC_DEFINE_UNQUOTED([ETHR_HAVE_GCC_ASM_ARM_DMB_INSTRUCTION], [$ethr_arm_dbm_instr_val], [Define as a boolean indicating whether you have a gcc compatible compiler capable of generating the ARM DMB instruction, and are compiling for an ARM processor with ARM DMB instruction support, or not])\n    test $ethr_cv_32bit___sync_val_compare_and_swap = yes &&\n    \tethr_have_gcc_native_atomics=yes\n    test $ethr_cv_64bit___sync_val_compare_and_swap = yes &&\n    \tethr_have_gcc_native_atomics=yes\n    if test \"$ethr_cv___sync_synchronize\" = \"yes\"; then\n    \ttest $ethr_cv_64bit___atomic_compare_exchange_n = yes &&\n    \t    ethr_have_gcc_native_atomics=yes\n    \ttest $ethr_cv_32bit___atomic_compare_exchange_n = yes &&\n    \t    ethr_have_gcc_native_atomics=yes\n    fi\n    ethr_have_gcc_atomic_builtins=0\n    if test $ethr_have_gcc_native_atomics = yes; then\n       ethr_native_atomic_implementation=gcc_sync\n       test $ethr_cv_32bit___atomic_compare_exchange_n = yes && ethr_have_gcc_atomic_builtins=1\n       test $ethr_cv_64bit___atomic_compare_exchange_n = yes && ethr_have_gcc_atomic_builtins=1\n       test $ethr_have_gcc_atomic_builtins = 1 && ethr_native_atomic_implementation=gcc_atomic_sync\n    fi\n    AC_DEFINE_UNQUOTED([ETHR_HAVE_GCC___ATOMIC_BUILTINS], [$ethr_have_gcc_atomic_builtins], [Define as a boolean indicating whether you have a gcc __atomic builtins or not])\n    test $ethr_have_gcc_native_atomics = yes && ethr_have_native_atomics=yes\n])\n\nAC_DEFUN(ETHR_CHK_INTERLOCKED,\n[\n    ilckd=\"$1\"\n    AC_MSG_CHECKING([for ${ilckd}()])\n    case \"$2\" in\n\t\"1\") ilckd_call=\"${ilckd}(var);\";;\n\t\"2\") ilckd_call=\"${ilckd}(var, ($3) 0);\";;\n\t\"3\") ilckd_call=\"${ilckd}(var, ($3) 0, ($3) 0);\";;\n\t\"4\") ilckd_call=\"${ilckd}(var, ($3) 0, ($3) 0, arr);\";;\n    esac\n    have_interlocked_op=no\n    AC_TRY_LINK(\n\t[\n\t#define WIN32_LEAN_AND_MEAN\n\t#include <windows.h>\n\t#include <intrin.h>\n\t],\n\t[\n\t    volatile $3 *var;\n\t    volatile $3 arr[2];\n\n\t    $ilckd_call\n\t    return 0;\n\t],\n\t[have_interlocked_op=yes])\n    test $have_interlocked_op = yes && $4\n    AC_MSG_RESULT([$have_interlocked_op])\n])\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl ERL_FIND_ETHR_LIB\ndnl\ndnl NOTE! This macro may be changed at any time! Should *only* be used by\ndnl       ERTS!\ndnl\ndnl Find a thread library to use. Sets ETHR_LIBS to libraries to link\ndnl with, ETHR_X_LIBS to extra libraries to link with (same as ETHR_LIBS\ndnl except that the ethread lib itself is not included), ETHR_DEFS to\ndnl defines to compile with, ETHR_THR_LIB_BASE to the name of the\ndnl thread library which the ethread library is based on, and ETHR_LIB_NAME\ndnl to the name of the library where the ethread implementation is located.\ndnl  ERL_FIND_ETHR_LIB currently searches for 'pthreads', and\ndnl 'win32_threads'. If no thread library was found ETHR_LIBS, ETHR_X_LIBS,\ndnl ETHR_DEFS, ETHR_THR_LIB_BASE, and ETHR_LIB_NAME are all set to the\ndnl empty string.\ndnl\n\nAC_DEFUN(ERL_FIND_ETHR_LIB,\n[\n\nAC_ARG_ENABLE(native-ethr-impls,\n\t      AS_HELP_STRING([--disable-native-ethr-impls],\n                             [disable native ethread implementations]),\n[ case \"$enableval\" in\n    no) disable_native_ethr_impls=yes ;;\n    *)  disable_native_ethr_impls=no ;;\n  esac ], disable_native_ethr_impls=no)\n\ntest \"X$disable_native_ethr_impls\" = \"Xyes\" &&\n  AC_DEFINE(ETHR_DISABLE_NATIVE_IMPLS, 1, [Define if you want to disable native ethread implementations])\n\nAC_ARG_ENABLE(x86-out-of-order,\n\t      AS_HELP_STRING([--enable-x86-out-of-order],\n                             [enable x86/x84_64 out of order support (default disabled)]))\n\nAC_ARG_ENABLE(prefer-gcc-native-ethr-impls,\n\t      AS_HELP_STRING([--enable-prefer-gcc-native-ethr-impls],\n\t\t\t     [prefer gcc native ethread implementations]),\n[ case \"$enableval\" in\n    yes) enable_prefer_gcc_native_ethr_impls=yes ;;\n    *)  enable_prefer_gcc_native_ethr_impls=no ;;\n  esac ], enable_prefer_gcc_native_ethr_impls=no)\n\ntest $enable_prefer_gcc_native_ethr_impls = yes &&\n  AC_DEFINE(ETHR_PREFER_GCC_NATIVE_IMPLS, 1, [Define if you prefer gcc native ethread implementations])\n\nAC_ARG_ENABLE(trust-gcc-atomic-builtins-memory-barriers,\n\t      AS_HELP_STRING([--enable-trust-gcc-atomic-builtins-memory-barriers],\n\t\t\t     [trust gcc atomic builtins memory barriers]),\n[ case \"$enableval\" in\n    yes) trust_gcc_atomic_builtins_mbs=1 ;;\n    *) trust_gcc_atomic_builtins_mbs=0 ;;\n  esac ], trust_gcc_atomic_builtins_mbs=0)\n\nAC_DEFINE_UNQUOTED(ETHR_TRUST_GCC_ATOMIC_BUILTINS_MEMORY_BARRIERS, [$trust_gcc_atomic_builtins_mbs], [Define as a boolean indicating whether you trust gcc's __atomic_* builtins memory barrier implementations, or not])\n\nAC_ARG_WITH(libatomic_ops,\n\t    AS_HELP_STRING([--with-libatomic_ops=PATH],\n\t\t\t   [specify and prefer usage of libatomic_ops in the ethread library]))\n\nAC_ARG_WITH(with_sparc_memory_order,\n\t    AS_HELP_STRING([--with-sparc-memory-order=TSO|PSO|RMO],\n\t\t\t   [specify sparc memory order (defaults to RMO)]))\n\nLM_CHECK_THR_LIB\nERL_INTERNAL_LIBS\n\nERL_MONOTONIC_CLOCK(try_find_pthread_compatible, CLOCK_HIGHRES CLOCK_MONOTONIC, no)\n\ncase $erl_monotonic_clock_func in\n  clock_gettime)\n    AC_DEFINE(ETHR_HAVE_CLOCK_GETTIME_MONOTONIC, [1], [Define if you have a clock_gettime() with a monotonic clock])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(ETHR_HAVE_MACH_CLOCK_GET_TIME, [1], [Define if you have a mach clock_get_time() with a monotonic clock])\n    ;;\n  gethrtime)\n    AC_DEFINE(ETHR_HAVE_GETHRTIME, [1], [Define if you have a monotonic gethrtime()])\n    ;;\n  *)\n    ;;\nesac\n\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(ETHR_MONOTONIC_CLOCK_ID, [$erl_monotonic_clock_id], [Define to the monotonic clock id to use])\nfi\n\nethr_native_atomic_implementation=none\nethr_have_native_atomics=no\nethr_have_native_spinlock=no\nETHR_THR_LIB_BASE=\"$THR_LIB_NAME\"\nETHR_THR_LIB_BASE_TYPE=\"$THR_LIB_TYPE\"\nETHR_DEFS=\"$THR_DEFS\"\nETHR_X_LIBS=\"$THR_LIBS $ERTS_INTERNAL_X_LIBS $erl_monotonic_clock_lib\"\nETHR_LIBS=\nETHR_LIB_NAME=\n\nethr_modified_default_stack_size=\n\nAC_ARG_WITH(threadnames,\nAS_HELP_STRING([--with-threadnames], [use pthread_setname to set the thread names (default)])\nAS_HELP_STRING([--without-threadnames],\n               [do not set any thread names]),\n[],\n[with_threadnames=yes])\n\ndnl Name of lib where ethread implementation is located\nethr_lib_name=ethread\n\ncase \"$THR_LIB_NAME\" in\n\n    win32_threads)\n\tETHR_THR_LIB_BASE_DIR=win\n\t# * _WIN32_WINNT >= 0x0400 is needed for\n\t#   TryEnterCriticalSection\n\t# * _WIN32_WINNT >= 0x0403 is needed for\n\t#   InitializeCriticalSectionAndSpinCount\n\t# The ethread lib will refuse to build if _WIN32_WINNT < 0x0403.\n\t#\n\t# -D_WIN32_WINNT should have been defined in $CPPFLAGS; fetch it\n\t# and save it in ETHR_DEFS.\n\tfound_win32_winnt=no\n\tfor cppflag in $CPPFLAGS; do\n\t    case $cppflag in\n\t\t-DWINVER*)\n\t\t    ETHR_DEFS=\"$ETHR_DEFS $cppflag\"\n\t\t    ;;\n\t\t-D_WIN32_WINNT*)\n\t\t    ETHR_DEFS=\"$ETHR_DEFS $cppflag\"\n\t\t    found_win32_winnt=yes\n\t\t    ;;\n\t\t*)\n\t\t    ;;\n\t    esac\n        done\n        if test $found_win32_winnt = no; then\n\t    AC_MSG_ERROR([-D_WIN32_WINNT missing in CPPFLAGS])\n        fi\n\n\tAC_DEFINE(ETHR_WIN32_THREADS, 1, [Define if you have win32 threads])\n\n\tif test \"X$disable_native_ethr_impls\" = \"Xyes\"; then\n\t    have_interlocked_op=no\n\t    ethr_have_native_atomics=no\n\telse\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT, 1, [Define if you have _InterlockedDecrement()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement_rel], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT_REL, 1, [Define if you have _InterlockedDecrement_rel()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT, 1, [Define if you have _InterlockedIncrement()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement_acq], [1], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT_ACQ, 1, [Define if you have _InterlockedIncrement_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD, 1, [Define if you have _InterlockedExchangeAdd()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd_acq], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD_ACQ, 1, [Define if you have _InterlockedExchangeAdd_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedAnd], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDAND, 1, [Define if you have _InterlockedAnd()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedOr], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDOR, 1, [Define if you have _InterlockedOr()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchange], [2], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGE, 1, [Define if you have _InterlockedExchange()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE, 1, [Define if you have _InterlockedCompareExchange()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange_acq], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE_ACQ, 1, [Define if you have _InterlockedCompareExchange_acq()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange_rel], [3], [long], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE_REL, 1, [Define if you have _InterlockedCompareExchange_rel()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement64], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT64, 1, [Define if you have _InterlockedDecrement64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedDecrement64_rel], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDDECREMENT64_REL, 1, [Define if you have _InterlockedDecrement64_rel()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement64], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT64, 1, [Define if you have _InterlockedIncrement64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedIncrement64_acq], [1], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDINCREMENT64_ACQ, 1, [Define if you have _InterlockedIncrement64_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD64, 1, [Define if you have _InterlockedExchangeAdd64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchangeAdd64_acq], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGEADD64_ACQ, 1, [Define if you have _InterlockedExchangeAdd64_acq()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedAnd64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDAND64, 1, [Define if you have _InterlockedAnd64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedOr64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDOR64, 1, [Define if you have _InterlockedOr64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedExchange64], [2], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDEXCHANGE64, 1, [Define if you have _InterlockedExchange64()]))\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64, 1, [Define if you have _InterlockedCompareExchange64()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64_acq], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64_ACQ, 1, [Define if you have _InterlockedCompareExchange64_acq()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange64_rel], [3], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE64_REL, 1, [Define if you have _InterlockedCompareExchange64_rel()]))\n\t    test \"$have_interlocked_op\" = \"yes\" && ethr_have_native_atomics=yes\n\n\t    ETHR_CHK_INTERLOCKED([_InterlockedCompareExchange128], [4], [__int64], AC_DEFINE_UNQUOTED(ETHR_HAVE__INTERLOCKEDCOMPAREEXCHANGE128, 1, [Define if you have _InterlockedCompareExchange128()]))\n\tfi\n\tif test \"$ethr_have_native_atomics\" = \"yes\"; then\n\t   ethr_native_atomic_implementation=windows\n\t   ethr_have_native_spinlock=yes\n\tfi\n\t;;\n\n    pthread)\n\tETHR_THR_LIB_BASE_DIR=pthread\n\tAC_DEFINE(ETHR_PTHREADS, 1, [Define if you have pthreads])\n\tcase $host_os in\n\t    openbsd*)\n\t\t# The default stack size is insufficient for our needs\n\t\t# on OpenBSD. We increase it to 256 kilo words.\n\t\tethr_modified_default_stack_size=256;;\n\t    linux*)\n\t\tETHR_DEFS=\"$ETHR_DEFS -D_GNU_SOURCE\"\n\n\t\tif test\tX$cross_compiling = Xyes; then\n\t\t    case X$erl_xcomp_linux_usable_sigusrx in\n\t\t\tX) usable_sigusrx=cross;;\n\t\t\tXyes|Xno) usable_sigusrx=$erl_xcomp_linux_usable_sigusrx;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_usable_sigusrx value: $erl_xcomp_linux_usable_sigusrx]);;\n\t\t    esac\n\t\t    case X$erl_xcomp_linux_usable_sigaltstack in\n\t\t\tX) usable_sigaltstack=cross;;\n\t\t\tXyes|Xno) usable_sigaltstack=$erl_xcomp_linux_usable_sigaltstack;;\n\t\t\t*) AC_MSG_ERROR([Bad erl_xcomp_linux_usable_sigaltstack value: $erl_xcomp_linux_usable_sigaltstack]);;\n\t\t    esac\n\t\telse\n\t\t    # FIXME: Test for actual problems instead of kernel versions\n\t\t    linux_kernel_vsn_=`uname -r`\n\t\t    case $linux_kernel_vsn_ in\n\t\t\t[[0-1]].*|2.[[0-1]]|2.[[0-1]].*)\n\t\t\t    usable_sigusrx=no\n\t\t\t    usable_sigaltstack=no;;\n\t\t\t2.[[2-3]]|2.[[2-3]].*)\n\t\t\t    usable_sigusrx=yes\n\t\t\t    usable_sigaltstack=no;;\n\t\t    \t*)\n\t\t\t    usable_sigusrx=yes\n\t\t\t    usable_sigaltstack=yes;;\n\t\t    esac\n\t\tfi\n\n\t\tAC_MSG_CHECKING(if SIGUSR1 and SIGUSR2 can be used)\n\t\tAC_MSG_RESULT($usable_sigusrx)\n\t\tif test $usable_sigusrx = cross; then\n\t\t    usable_sigusrx=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $usable_sigusrx = no; then\n\t\t    ETHR_DEFS=\"$ETHR_DEFS -DETHR_UNUSABLE_SIGUSRX\"\n\t\tfi\n\n\t\tAC_MSG_CHECKING(if sigaltstack can be used)\n\t\tAC_MSG_RESULT($usable_sigaltstack)\n\t\tif test $usable_sigaltstack = cross; then\n\t\t    usable_sigaltstack=yes\n\t\t    AC_MSG_WARN([result yes guessed because of cross compilation])\n\t\tfi\n\t\tif test $usable_sigaltstack = no; then\n\t\t    ETHR_DEFS=\"$ETHR_DEFS -DETHR_UNUSABLE_SIGALTSTACK\"\n\t\tfi\n\t\t;;\n\t    *) ;;\n\tesac\n\n\tdnl We sometimes need ETHR_DEFS in order to find certain headers\n\tdnl (at least for pthread.h on osf1).\n\tsaved_cppflags=\"$CPPFLAGS\"\n\tCPPFLAGS=\"$CPPFLAGS $ETHR_DEFS\"\n\n\tdnl We need the thread library in order to find some functions\n\tsaved_libs=\"$LIBS\"\n\tLIBS=\"$LIBS $ETHR_X_LIBS\"\n\n\tdnl\n\tdnl Check for headers\n\tdnl\n\tAC_CHECK_HEADER(pthread.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_H, 1, \\\n[Define if you have the <pthread.h> header file.]))\n\n\tdnl Some Linuxes have <pthread/mit/pthread.h> instead of <pthread.h>\n\tAC_CHECK_HEADER(pthread/mit/pthread.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_MIT_PTHREAD_H, 1, \\\n[Define if the pthread.h header file is in pthread/mit directory.]))\n\n\tif test $NEED_NPTL_PTHREAD_H = yes; then\n\t    AC_DEFINE(ETHR_NEED_NPTL_PTHREAD_H, 1, \\\n[Define if you need the <nptl/pthread.h> header file.])\n\tfi\n\n\tAC_CHECK_HEADER(sched.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_SCHED_H, 1, \\\n[Define if you have the <sched.h> header file.]))\n\n\tAC_CHECK_HEADER(sys/time.h, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_SYS_TIME_H, 1, \\\n[Define if you have the <sys/time.h> header file.]))\n\n\tAC_TRY_COMPILE([#include <time.h>\n\t\t\t#include <sys/time.h>], \n\t\t\t[struct timeval *tv; return 0;],\n\t\t\tAC_DEFINE(ETHR_TIME_WITH_SYS_TIME, 1, \\\n[Define if you can safely include both <sys/time.h> and <time.h>.]))\n\n\tAC_MSG_CHECKING([for usable PTHREAD_STACK_MIN])\n\tpthread_stack_min=no\n\tAC_TRY_COMPILE([\n#include <limits.h>\n#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n#include <nptl/pthread.h>\n#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n#include <pthread/mit/pthread.h>\n#elif defined(ETHR_HAVE_PTHREAD_H)\n#include <pthread.h>\n#endif\n\t\t\t], \n\t\t\t[return PTHREAD_STACK_MIN;],\n\t\t\t[pthread_stack_min=yes])\n\n\tAC_MSG_RESULT([$pthread_stack_min])\n\ttest $pthread_stack_min != yes || {\n\t     AC_DEFINE(ETHR_HAVE_USABLE_PTHREAD_STACK_MIN, 1, [Define if you can use PTHREAD_STACK_MIN])\n\t}\n\n\tdnl\n\tdnl Check for functions\n\tdnl\n\tAC_CHECK_FUNC(pthread_spin_lock, \\\n\t\t\t[ethr_have_native_spinlock=yes \\\n\t\t\t AC_DEFINE(ETHR_HAVE_PTHREAD_SPIN_LOCK, 1, \\\n[Define if you have the pthread_spin_lock function.])])\n\n\thave_sched_yield=no\n\thave_librt_sched_yield=no\n\tAC_CHECK_FUNC(sched_yield, [have_sched_yield=yes])\n\tif test $have_sched_yield = no; then\n\t    AC_CHECK_LIB(rt, sched_yield,\n\t\t\t [have_librt_sched_yield=yes\n\t\t\t  ETHR_X_LIBS=\"$ETHR_X_LIBS -lrt\"])\n\tfi\n\tif test $have_sched_yield = yes || test $have_librt_sched_yield = yes; then\n\t    AC_DEFINE(ETHR_HAVE_SCHED_YIELD, 1, [Define if you have the sched_yield() function.])\n\t    AC_MSG_CHECKING([whether sched_yield() returns an int])\n\t    sched_yield_ret_int=no\n\t    AC_TRY_LINK([\n\t\t\t\t#ifdef ETHR_HAVE_SCHED_H\n\t\t\t\t#include <sched.h>\n\t\t\t\t#endif\n\t\t\t   ],\n\t\t\t   [int sched_yield();],\n\t\t\t   [sched_yield_ret_int=yes])\n\t    AC_MSG_RESULT([$sched_yield_ret_int])\n\t    if test $sched_yield_ret_int = yes; then\n\t\tAC_DEFINE(ETHR_SCHED_YIELD_RET_INT, 1, [Define if sched_yield() returns an int.])\n\t    fi\n\tfi\n\n\thave_pthread_yield=no\n\tAC_CHECK_FUNC(pthread_yield, [have_pthread_yield=yes])\n\tif test $have_pthread_yield = yes; then\n\t    AC_DEFINE(ETHR_HAVE_PTHREAD_YIELD, 1, [Define if you have the pthread_yield() function.])\n\t    AC_MSG_CHECKING([whether pthread_yield() returns an int])\n\t    pthread_yield_ret_int=no\n\t    AC_TRY_LINK([\n\t\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t\t#include <nptl/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t\t#include <pthread/mit/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t\t#include <pthread.h>\n\t\t\t\t#endif\n\t\t\t   ],\n\t\t\t   [int pthread_yield();],\n\t\t\t   [pthread_yield_ret_int=yes])\n\t    AC_MSG_RESULT([$pthread_yield_ret_int])\n\t    if test $pthread_yield_ret_int = yes; then\n\t\tAC_DEFINE(ETHR_PTHREAD_YIELD_RET_INT, 1, [Define if pthread_yield() returns an int.])\n\t    fi\n\tfi\n\n\thave_pthread_rwlock_init=no\n\tAC_CHECK_FUNC(pthread_rwlock_init, [have_pthread_rwlock_init=yes])\n\tif test $have_pthread_rwlock_init = yes; then\n\n\t    ethr_have_pthread_rwlockattr_setkind_np=no\n\t    AC_CHECK_FUNC(pthread_rwlockattr_setkind_np,\n\t\t\t  [ethr_have_pthread_rwlockattr_setkind_np=yes])\n\n\t    if test $ethr_have_pthread_rwlockattr_setkind_np = yes; then\n\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_RWLOCKATTR_SETKIND_NP, 1, \\\n[Define if you have the pthread_rwlockattr_setkind_np() function.])\n\n\t\tAC_MSG_CHECKING([for PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP])\n\t\tethr_pthread_rwlock_writer_nonrecursive_initializer_np=no\n\t\tAC_TRY_LINK([\n\t\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t\t#include <nptl/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t\t#include <pthread/mit/pthread.h>\n\t\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t\t#include <pthread.h>\n\t\t\t\t#endif\n\t\t\t    ],\n\t\t\t    [\n\t\t\t\tpthread_rwlockattr_t *attr;\n\t\t\t\treturn pthread_rwlockattr_setkind_np(attr,\n\t\t\t\t    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n\t\t\t    ],\n\t\t\t    [ethr_pthread_rwlock_writer_nonrecursive_initializer_np=yes])\n\t\tAC_MSG_RESULT([$ethr_pthread_rwlock_writer_nonrecursive_initializer_np])\n\t\tif test $ethr_pthread_rwlock_writer_nonrecursive_initializer_np = yes; then\n\t\t    AC_DEFINE(ETHR_HAVE_PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, 1, \\\n[Define if you have the PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP rwlock attribute.])\n\t\tfi\n\t    fi\n\tfi\n\n\tif test \"$force_pthread_rwlocks\" = \"yes\"; then\n\n\t    AC_DEFINE(ETHR_FORCE_PTHREAD_RWLOCK, 1, \\\n[Define if you want to force usage of pthread rwlocks])\n\n\t    if test $have_pthread_rwlock_init = yes; then\n\t\tAC_MSG_WARN([Forced usage of pthread rwlocks. Note that this implementation may suffer from starvation issues.])\n\t    else\n\t\tAC_MSG_ERROR([User forced usage of pthread rwlock, but no such implementation was found])\n\t    fi\n\tfi\n\n\tAC_CHECK_FUNC(pthread_attr_setguardsize, \\\n\t\t\tAC_DEFINE(ETHR_HAVE_PTHREAD_ATTR_SETGUARDSIZE, 1, \\\n[Define if you have the pthread_attr_setguardsize function.]))\n\n\tif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n\t  AC_MSG_CHECKING(whether pthread_cond_timedwait() can use the monotonic clock $erl_monotonic_clock_id for timeout)\n\t  pthread_cond_timedwait_monotonic=no\n\t  AC_TRY_LINK([\n\t\t\t#if defined(ETHR_NEED_NPTL_PTHREAD_H)\n\t\t\t#  include <nptl/pthread.h>\n\t\t\t#elif defined(ETHR_HAVE_MIT_PTHREAD_H)\n\t\t\t#  include <pthread/mit/pthread.h>\n\t\t\t#elif defined(ETHR_HAVE_PTHREAD_H)\n\t\t\t#  include <pthread.h>\n\t\t\t#endif\n\t\t\t#ifdef ETHR_TIME_WITH_SYS_TIME\n\t\t\t#  include <time.h>\n\t\t\t#  include <sys/time.h>\n\t\t\t#else\n\t\t\t#  ifdef ETHR_HAVE_SYS_TIME_H\n\t\t\t#    include <sys/time.h>\n\t\t\t#  else\n\t\t\t#    include <time.h>\n\t\t\t#  endif\n\t\t\t#endif\n\t\t\t#if defined(ETHR_HAVE_MACH_CLOCK_GET_TIME)\n\t\t\t#  include <mach/clock.h>\n\t\t\t#  include <mach/mach.h>\n\t\t\t#endif\n\t\t\t], \n\t\t\t[\n\t\t\tint res;\n\t\t\tpthread_condattr_t attr;\n\t\t\tpthread_cond_t cond;\n\t\t\tstruct timespec cond_timeout;\n\t\t\tpthread_mutex_t mutex;\n\t\t\tres = pthread_condattr_init(&attr);\n\t\t\tres = pthread_condattr_setclock(&attr, ETHR_MONOTONIC_CLOCK_ID);\n\t\t\tres = pthread_cond_init(&cond, &attr);\n\t\t\tres = pthread_cond_timedwait(&cond, &mutex, &cond_timeout);\n\t\t\t],\n\t\t\t[pthread_cond_timedwait_monotonic=yes])\n\t  AC_MSG_RESULT([$pthread_cond_timedwait_monotonic])\n\t  if test $pthread_cond_timedwait_monotonic = yes; then\n\t    AC_DEFINE(ETHR_HAVE_PTHREAD_COND_TIMEDWAIT_MONOTONIC, [1], [Define if pthread_cond_timedwait() can be used with a monotonic clock])\n\t  fi\n\tfi\n\n\tlinux_futex=no\n\tAC_MSG_CHECKING([for Linux futexes])\n\tAC_TRY_LINK([\n\t\t\t#include <sys/syscall.h>\n\t\t\t#include <unistd.h>\n\t\t\t#include <linux/futex.h>\n\t\t\t#include <sys/time.h>\n\t\t    ],\n\t\t    [\n\t\t\tint i = 1;\n\t\t\tsyscall(__NR_futex, (void *) &i, FUTEX_WAKE, 1,\n\t\t\t\t(void*)0,(void*)0, 0);\n\t\t\tsyscall(__NR_futex, (void *) &i, FUTEX_WAIT, 0,\n\t\t\t\t(void*)0,(void*)0, 0);\n\t\t\treturn 0;\n\t\t    ],\n\t\t    linux_futex=yes)\n\tAC_MSG_RESULT([$linux_futex])\n\ttest $linux_futex = yes && AC_DEFINE(ETHR_HAVE_LINUX_FUTEX, 1, [Define if you have a linux futex implementation.])\n\n\tpthread_setname=no\n\tAC_MSG_CHECKING([for pthread_setname_np])\n\told_CFLAGS=$CFLAGS\n\tCFLAGS=\"$CFLAGS -Werror\"\n\tAC_TRY_LINK([#define __USE_GNU\n                     #include <pthread.h>],\n                    [pthread_setname_np(pthread_self(), \"name\");],\n                    pthread_setname=linux)\n\tAC_TRY_LINK([#define __USE_GNU\n                     #include <pthread.h>],\n                    [pthread_set_name_np(pthread_self(), \"name\");],\n                    pthread_setname=bsd)\n\tAC_TRY_LINK([#define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [pthread_setname_np(\"name\");],\n                    pthread_setname=darwin)\n        AC_MSG_RESULT([$pthread_setname])\n        case $with_threadnames-$pthread_setname in\n             yes-linux) AC_DEFINE(ETHR_HAVE_PTHREAD_SETNAME_NP_2, 1,\n                          [Define if you have linux style pthread_setname_np]);;\n             yes-bsd) AC_DEFINE(ETHR_HAVE_PTHREAD_SET_NAME_NP_2, 1,\n                          [Define if you have bsd style pthread_set_name_np]);;\n             yes-darwin) AC_DEFINE(ETHR_HAVE_PTHREAD_SETNAME_NP_1, 1,\n                          [Define if you have darwin style pthread_setname_np]);;\n             *) ;;\n\tesac\n\n\tpthread_getname=no\n\tAC_MSG_CHECKING([for pthread_getname_np])\n\tAC_TRY_LINK([#define __USE_GNU\n                     #define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [char buff[256]; pthread_getname_np(pthread_self(), buff, 256);],\n                    pthread_getname=linux)\n\tAC_TRY_LINK([#define __USE_GNU\n                     #define _DARWIN_C_SOURCE\n                     #include <pthread.h>],\n                    [char buff[256]; pthread_getname_np(pthread_self(), buff);],\n                    pthread_getname=ibm)\n        AC_MSG_RESULT([$pthread_getname])\n        case $pthread_getname in\n             linux) AC_DEFINE(ETHR_HAVE_PTHREAD_GETNAME_NP_3, 1,\n                          [Define if you have linux style pthread_getname_np]);;\n             ibm) AC_DEFINE(ETHR_HAVE_PTHREAD_GETNAME_NP_2, 1,\n                          [Define if you have ibm style pthread_getname_np]);;\n             *) ;;\n\tesac\n\tCFLAGS=$old_CFLAGS\n\n\tif test \"X$disable_native_ethr_impls\" = \"Xyes\"; then\n\t    ethr_have_native_atomics=no\n\telse\n\n\t    ETHR_CHK_GCC_ATOMIC_OPS([])\n\n\t    AC_MSG_CHECKING([for a usable libatomic_ops implementation])\n\t    case \"x$with_libatomic_ops\" in\n\t        xno | xyes | x)\n\t    \t    libatomic_ops_include=\n\t    \t    ;;\n\t        *)\n\t    \t    if test -d \"${with_libatomic_ops}/include\"; then\n\t    \t        libatomic_ops_include=\"-I$with_libatomic_ops/include\"\n\t    \t        CPPFLAGS=\"$CPPFLAGS $libatomic_ops_include\"\n\t    \t    else\n\t    \t        AC_MSG_ERROR([libatomic_ops include directory $with_libatomic_ops/include not found])\n\t    \t    fi;;\n\t    esac\n\t    ethr_have_libatomic_ops=no\n\t    AC_TRY_LINK([#include \"atomic_ops.h\"],\n\t    \t        [\n\t    \t    \t    volatile AO_t x;\n\t    \t    \t    AO_t y;\n\t    \t    \t    int z;\n\n\t    \t    \t    AO_nop_full();\n#if defined(AO_HAVE_store)\n\t    \t    \t    AO_store(&x, (AO_t) 0);\n#elif defined(AO_HAVE_store_release)\n\t    \t    \t    AO_store_release(&x, (AO_t) 0);\n#else\n#error No store\n#endif\n#if defined(AO_HAVE_load)\n\t    \t    \t    z = AO_load(&x);\n#elif defined(AO_HAVE_load_acquire)\n\t    \t    \t    z = AO_load_acquire(&x);\n#else\n#error No load\n#endif\n#if defined(AO_HAVE_compare_and_swap_full)\n\t    \t    \t    z = AO_compare_and_swap_full(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap_release)\n\t    \t    \t    z = AO_compare_and_swap_release(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap_acquire)\n\t    \t    \t    z = AO_compare_and_swap_acquire(&x, (AO_t) 0, (AO_t) 1);\n#elif defined(AO_HAVE_compare_and_swap)\n\t    \t    \t    z = AO_compare_and_swap(&x, (AO_t) 0, (AO_t) 1);\n#else\n#error No compare_and_swap\n#endif\n\t    \t        ],\n\t    \t        [ethr_have_native_atomics=yes\n\t\t\t ethr_native_atomic_implementation=libatomic_ops\n\t    \t         ethr_have_libatomic_ops=yes])\n\t    AC_MSG_RESULT([$ethr_have_libatomic_ops])\n\t    if test $ethr_have_libatomic_ops = yes; then\n\t        AC_CHECK_SIZEOF(AO_t, ,\n\t    \t    \t        [\n\t    \t    \t    \t    #include <stdio.h>\n\t    \t    \t    \t    #include \"atomic_ops.h\"\n\t    \t    \t        ])\n\t        AC_DEFINE_UNQUOTED(ETHR_SIZEOF_AO_T, $ac_cv_sizeof_AO_t, [Define to the size of AO_t if libatomic_ops is used])\n\n\t        AC_DEFINE(ETHR_HAVE_LIBATOMIC_OPS, 1, [Define if you have libatomic_ops atomic operations])\n\t        if test \"x$with_libatomic_ops\" != \"xno\" && test \"x$with_libatomic_ops\" != \"x\"; then\n\t    \t    AC_DEFINE(ETHR_PREFER_LIBATOMIC_OPS_NATIVE_IMPLS, 1, [Define if you prefer libatomic_ops native ethread implementations])\n\t        fi\n\t        ETHR_DEFS=\"$ETHR_DEFS $libatomic_ops_include\"\n\t    elif test \"x$with_libatomic_ops\" != \"xno\" && test \"x$with_libatomic_ops\" != \"x\"; then\n\t        AC_MSG_ERROR([No usable libatomic_ops implementation found])\n\t    fi\n\n\t    case \"$host_cpu\" in\n\t      sparc | sun4u | sparc64 | sun4v)\n\t    \t    case \"$with_sparc_memory_order\" in\n\t    \t        \"TSO\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_TSO, 1, [Define if only run in Sparc TSO mode]);;\n\t    \t        \"PSO\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_PSO, 1, [Define if only run in Sparc PSO, or TSO mode]);;\n\t    \t        \"RMO\"|\"\")\n\t    \t    \t    AC_DEFINE(ETHR_SPARC_RMO, 1, [Define if run in Sparc RMO, PSO, or TSO mode]);;\n\t    \t        *)\n\t    \t    \t    AC_MSG_ERROR([Unsupported Sparc memory order: $with_sparc_memory_order]);;\n\t    \t    esac\n\t\t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;; \n\t      i86pc | i*86 | x86_64 | amd64)\n\t    \t    if test \"$enable_x86_out_of_order\" = \"yes\"; then\n\t    \t    \t    AC_DEFINE(ETHR_X86_OUT_OF_ORDER, 1, [Define if x86/x86_64 out of order instructions should be synchronized])\n\t    \t    fi\n\t\t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      macppc | ppc | powerpc | \"Power Macintosh\")\n\t      \t    ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      tile)\n\t            ethr_native_atomic_implementation=ethread\n\t    \t    ethr_have_native_atomics=yes;;\n\t      *)\n\t    \t    ;;\n\t    esac\n\n\tfi\n\n\ttest ethr_have_native_atomics = \"yes\" && ethr_have_native_spinlock=yes\n\n\tdnl Restore LIBS\n\tLIBS=$saved_libs\n\tdnl restore CPPFLAGS\n\tCPPFLAGS=$saved_cppflags\n\n\t;;\n    *)\n\t;;\nesac\n\nAC_MSG_CHECKING([whether default stack size should be modified])\nif test \"x$ethr_modified_default_stack_size\" != \"x\"; then\n\tAC_DEFINE_UNQUOTED(ETHR_MODIFIED_DEFAULT_STACK_SIZE, $ethr_modified_default_stack_size, [Define if you want to modify the default stack size])\n\tAC_MSG_RESULT([yes; to $ethr_modified_default_stack_size kilo words])\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nif test \"x$ETHR_THR_LIB_BASE\" != \"x\"; then\n\tETHR_DEFS=\"-DUSE_THREADS $ETHR_DEFS\"\n\tETHR_LIBS=\"-l$ethr_lib_name -lerts_internal_r $ETHR_X_LIBS\"\n\tETHR_LIB_NAME=$ethr_lib_name\nfi\n\nAC_CHECK_SIZEOF(void *)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_PTR, $ac_cv_sizeof_void_p, [Define to the size of pointers])\n\nAC_CHECK_SIZEOF(int)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_INT, $ac_cv_sizeof_int, [Define to the size of int])\nAC_CHECK_SIZEOF(long)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_LONG, $ac_cv_sizeof_long, [Define to the size of long])\nAC_CHECK_SIZEOF(long long)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF_LONG_LONG, $ac_cv_sizeof_long_long, [Define to the size of long long])\nAC_CHECK_SIZEOF(__int64)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF___INT64, $ac_cv_sizeof___int64, [Define to the size of __int64])\nAC_CHECK_SIZEOF(__int128_t)\nAC_DEFINE_UNQUOTED(ETHR_SIZEOF___INT128_T, $ac_cv_sizeof___int128_t, [Define to the size of __int128_t])\n\n\ncase X$erl_xcomp_bigendian in\n    X) ;;\n    Xyes|Xno) ac_cv_c_bigendian=$erl_xcomp_bigendian;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_bigendian value: $erl_xcomp_bigendian]);;\nesac\n\nAC_C_BIGENDIAN\n\nif test \"$ac_cv_c_bigendian\" = \"yes\"; then\n    AC_DEFINE(ETHR_BIGENDIAN, 1, [Define if bigendian])\nfi\n\ncase X$erl_xcomp_double_middle_endian in\n    X) ;;\n    Xyes|Xno|Xunknown) ac_cv_c_double_middle_endian=$erl_xcomp_double_middle_endian;;\n    *) AC_MSG_ERROR([Bad erl_xcomp_double_middle_endian value: $erl_xcomp_double_middle_endian]);;\nesac\n\nAC_C_DOUBLE_MIDDLE_ENDIAN\n\nETHR_X86_SSE2_ASM=no\ncase \"$GCC-$ac_cv_sizeof_void_p-$host_cpu\" in\n  yes-4-i86pc | yes-4-i*86 | yes-4-x86_64 | yes-4-amd64)\n    AC_MSG_CHECKING([for gcc sse2 asm support])\n    save_CFLAGS=\"$CFLAGS\"\n    CFLAGS=\"$CFLAGS -msse2\"\n    gcc_sse2_asm=no\n    AC_TRY_COMPILE([],\n\t[\n\t\tlong long x, *y;\n\t\t__asm__ __volatile__(\"movq %1, %0\\n\\t\" : \"=x\"(x) : \"m\"(*y) : \"memory\");\n\t],\n\t[gcc_sse2_asm=yes])\n    CFLAGS=\"$save_CFLAGS\"\n    AC_MSG_RESULT([$gcc_sse2_asm])\n    if test \"$gcc_sse2_asm\" = \"yes\"; then\n      AC_DEFINE(ETHR_GCC_HAVE_SSE2_ASM_SUPPORT, 1, [Define if you use a gcc that supports -msse2 and understand sse2 specific asm statements])\n      ETHR_X86_SSE2_ASM=yes\n    fi\n    ;;\n  *)\n    ;;\nesac\n\ncase \"$GCC-$host_cpu\" in\n  yes-i86pc | yes-i*86 | yes-x86_64 | yes-amd64)\n\n    if test $ac_cv_sizeof_void_p = 4; then\n       dw_cmpxchg=\"cmpxchg8b\"\n    else\n       dw_cmpxchg=\"cmpxchg16b\"\n    fi\n\n    gcc_dw_cmpxchg_asm=no\n    gcc_pic_dw_cmpxchg_asm=no\n    gcc_cflags_pic=no\n    gcc_cmpxchg8b_pic_no_clobber_ebx=no\n    gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage=no\n\n    save_CFLAGS=\"$CFLAGS\"\n\n    # Check if it works out of the box using passed CFLAGS\n    # and with -fPIC added to CFLAGS if the passed CFLAGS\n    # doesn't trigger position independent code\n    pic_cmpxchg=unknown\n    while true; do\n\n        case $pic_cmpxchg in\n\t  yes) pic_text=\"pic \";;\n\t  *) pic_text=\"\";;\n\tesac\n\n\tAC_MSG_CHECKING([for gcc $pic_text$dw_cmpxchg plain asm support])    \n\n\tplain_cmpxchg=no\n    \tAC_TRY_COMPILE([],\n\t[\n    char xchgd;\n    long new[2], xchg[2], *p;\t\t  \n    __asm__ __volatile__(\n#if ETHR_SIZEOF_PTR == 4\n\t\"lock; cmpxchg8b %0\\n\\t\"\n#else\n\t\"lock; cmpxchg16b %0\\n\\t\"\n#endif\n\t\"setz %3\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=q\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"c\"(new[1]), \"b\"(new[0])\n\t: \"cc\", \"memory\");\n\t],\n\t[plain_cmpxchg=yes])\n\n\tAC_MSG_RESULT([$plain_cmpxchg])\n\n\tif test $pic_cmpxchg = yes; then\n\t   gcc_pic_dw_cmpxchg_asm=$plain_cmpxchg\n\t   break\n\tfi\n\n\tgcc_dw_cmpxchg_asm=$plain_cmpxchg\n\n    \t# If not already compiling to position independent\n\t# code add -fPIC to CFLAGS and do it again. This\n\t# since we want also want to know how to compile\n\t# to position independent code since this might\n\t# cause problems with the use of the EBX register\n\t# as input to the asm on 32-bit x86 and old gcc\n\t# compilers (gcc vsn < 5).\n\n    \tAC_TRY_COMPILE([],\n\t[\n#if !defined(__PIC__) || !__PIC__\n#  error no pic\n#endif\n\t],\n\t[pic_cmpxchg=yes\n\t gcc_cflags_pic=yes],\n\t[pic_cmpxchg=no])\n\n\tif test $pic_cmpxchg = yes; then\n\t   gcc_pic_dw_cmpxchg_asm=$gcc_dw_cmpxchg_asm\n\t   break\n\tfi\n\n\tCFLAGS=\"$save_CFLAGS -fPIC\"\n\tpic_cmpxchg=yes\n\n    done\n\n    if test $gcc_pic_dw_cmpxchg_asm = no && test $ac_cv_sizeof_void_p = 4; then\n\n      AC_MSG_CHECKING([for gcc pic cmpxchg8b asm support with EBX workaround])\n\n      # Check if we can work around it by managing the ebx\n      # register explicitly in the asm...\n\n      AC_TRY_COMPILE([],\n\t[\n    char xchgd;\n    long new[2], xchg[2], *p;\t\t  \n    __asm__ __volatile__(\n\t\"pushl %%ebx\\n\\t\"\n\t\"movl %8, %%ebx\\n\\t\"\n\t\"lock; cmpxchg8b %0\\n\\t\"\n\t\"setz %3\\n\\t\"\n\t\"popl %%ebx\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=q\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"c\"(new[1]), \"r\"(new[0])\n\t: \"cc\", \"memory\");\n\t],\n\t[gcc_pic_dw_cmpxchg_asm=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx=yes])     \n\n      AC_MSG_RESULT([$gcc_pic_dw_cmpxchg_asm])\n\n      if test $gcc_pic_dw_cmpxchg_asm = no; then\n\n      \tAC_MSG_CHECKING([for gcc pic cmpxchg8b asm support with EBX and register shortage workarounds])\n        # If no optimization is enabled we sometimes get a\n\t# register shortage. Check if we can work around\n\t# this...\n\n      \tAC_TRY_COMPILE([],\n\t  [\n      char xchgd;\n      long new[2], xchg[2], *p;\n      __asm__ __volatile__(\n\t\"pushl %%ebx\\n\\t\"\n\t\"movl (%7), %%ebx\\n\\t\"\n\t\"movl 4(%7), %%ecx\\n\\t\"\n\t\"lock; cmpxchg8b %0\\n\\t\"\n\t\"setz %3\\n\\t\"\n\t\"popl %%ebx\\n\\t\"\n\t: \"=m\"(*p), \"=d\"(xchg[1]), \"=a\"(xchg[0]), \"=c\"(xchgd)\n\t: \"m\"(*p), \"1\"(xchg[1]), \"2\"(xchg[0]), \"r\"(new)\n\t: \"cc\", \"memory\");\n\n\t],\n\t[gcc_pic_dw_cmpxchg_asm=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx=yes\n\t gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage=yes])\n\n        AC_MSG_RESULT([$gcc_pic_dw_cmpxchg_asm])\n      fi\n\n      if test $gcc_cflags_pic = yes; then\n        gcc_dw_cmpxchg_asm=$gcc_pic_dw_cmpxchg_asm\n      fi\n \n   fi\n\n    CFLAGS=\"$save_CFLAGS\"\n\n    if test \"$gcc_cmpxchg8b_pic_no_clobber_ebx\" = \"yes\"; then\n      AC_DEFINE(ETHR_CMPXCHG8B_PIC_NO_CLOBBER_EBX, 1, [Define if gcc wont let you clobber ebx with cmpxchg8b and position independent code])\n    fi\n    if test \"$gcc_cmpxchg8b_pic_no_clobber_ebx_register_shortage\" = \"yes\"; then\n      AC_DEFINE(ETHR_CMPXCHG8B_REGISTER_SHORTAGE, 1, [Define if you get a register shortage with cmpxchg8b and position independent code])\n    fi\n    if test \"$gcc_dw_cmpxchg_asm\" = \"yes\"; then\n      AC_DEFINE(ETHR_GCC_HAVE_DW_CMPXCHG_ASM_SUPPORT, 1, [Define if you use a gcc that supports the double word cmpxchg instruction])\n    fi;;\n  *)\n    ;;\nesac\n\nAC_DEFINE(ETHR_HAVE_ETHREAD_DEFINES, 1, \\\n[Define if you have all ethread defines])\n\nAC_SUBST(ETHR_X_LIBS)\nAC_SUBST(ETHR_LIBS)\nAC_SUBST(ETHR_LIB_NAME)\nAC_SUBST(ETHR_DEFS)\nAC_SUBST(ETHR_THR_LIB_BASE)\nAC_SUBST(ETHR_THR_LIB_BASE_DIR)\nAC_SUBST(ETHR_X86_SSE2_ASM)\n\n])\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl ERL_TIME_CORRECTION\ndnl\ndnl Check for primitives that can be used for implementing\ndnl erts_os_monotonic_time() and erts_os_system_time()\ndnl\n\nAC_DEFUN(ERL_TIME_CORRECTION,\n[\n\nAC_ARG_WITH(clock-resolution,\nAS_HELP_STRING([--with-clock-resolution=high|low|default],\n               [specify wanted clock resolution]))\n\nAC_ARG_WITH(clock-gettime-realtime-id,\nAS_HELP_STRING([--with-clock-gettime-realtime-id=CLOCKID],\n               [specify clock id to use with clock_gettime() for realtime time)]))\n\nAC_ARG_WITH(clock-gettime-monotonic-id,\nAS_HELP_STRING([--with-clock-gettime-monotonic-id=CLOCKID],\n               [specify clock id to use with clock_gettime() for monotonic time)]))\n\nAC_ARG_ENABLE(prefer-elapsed-monotonic-time-during-suspend,\nAS_HELP_STRING([--enable-prefer-elapsed-monotonic-time-during-suspend],\n               [Prefer an OS monotonic time source with elapsed time during suspend])\nAS_HELP_STRING([--disable-prefer-elapsed-monotonic-time-during-suspend],\n               [Do not prefer an OS monotonic time source with elapsed time during suspend]),\n[ case \"$enableval\" in\n    yes) prefer_elapsed_monotonic_time_during_suspend=yes ;;\n    *)  prefer_elapsed_monotonic_time_during_suspend=no ;;\n  esac ], prefer_elapsed_monotonic_time_during_suspend=no)\n\nAC_ARG_ENABLE(gettimeofday-as-os-system-time,\n\t      AS_HELP_STRING([--enable-gettimeofday-as-os-system-time],\n                             [Force usage of gettimeofday() for OS system time]),\n[ case \"$enableval\" in\n    yes) force_gettimeofday_os_system_time=yes ;;\n    *)  force_gettimeofday_os_system_time=no ;;\n  esac ], force_gettimeofday_os_system_time=no)\n\ncase \"$with_clock_resolution\" in\n   \"\"|no|yes)\n     with_clock_resolution=default;;\n   high|low|default)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid wanted clock resolution: $with_clock_resolution])\n     ;;\nesac\n\nif test \"$force_gettimeofday_os_system_time\" = \"yes\"; then\n\n  AC_CHECK_FUNCS([gettimeofday])\n  if test \"$ac_cv_func_gettimeofday\" = \"yes\"; then\n    AC_DEFINE(OS_SYSTEM_TIME_GETTIMEOFDAY,  [1], [Define if you want to implement erts_os_system_time() using gettimeofday()])\n  else\n    AC_MSG_ERROR([No gettimeofday() available])\n  fi\n\nelse # $force_gettimeofday_os_system_time != yes\n\ncase \"$with_clock_gettime_realtime_id\" in\n   \"\"|no)\n     with_clock_gettime_realtime_id=no\n     ;;\n   CLOCK_*CPUTIME*)\n     AC_MSG_ERROR([Invalid clock_gettime() realtime clock id: Refusing to use the cputime clock id $with_clock_gettime_realtime_id as realtime clock id])\n     ;;\n   CLOCK_MONOTONIC*|CLOCK_BOOTTIME*|CLOCK_UPTIME*|CLOCK_HIGHRES*)\n     AC_MSG_ERROR([Invalid clock_gettime() realtime clock id: Refusing to use the monotonic clock id $with_clock_gettime_realtime_id as realtime clock id])\n     ;;\n   CLOCK_*)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid clock_gettime() clock id: $with_clock_gettime_realtime_id])\n     ;;\nesac\n\ncase \"$with_clock_resolution-$with_clock_gettime_realtime_id\" in\n  high-no)\n\tERL_WALL_CLOCK(high_resolution);;\n  low-no)\n\tERL_WALL_CLOCK(low_resolution);;\n  default-no)\n\tERL_WALL_CLOCK(default_resolution);;\n  *)\n\tERL_WALL_CLOCK(custom_resolution, $with_clock_gettime_realtime_id);;\nesac\n\ncase \"$erl_wall_clock_func-$erl_wall_clock_id-$with_clock_gettime_realtime_id\" in\n  *-*-no)\n    ;;\n  clock_gettime-$with_clock_gettime_realtime_id-$with_clock_gettime_realtime_id)\n    ;;\n  *)\n    AC_MSG_ERROR([$with_clock_gettime_realtime_id as clock id to clock_gettime() doesn't compile])\n    ;;\nesac\n\ncase $erl_wall_clock_func in\n  none)\n    AC_MSG_ERROR([No wall clock source found])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(OS_SYSTEM_TIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_system_time() using mach clock_get_time()])\n    ;;\n  clock_gettime)\n    AC_DEFINE(OS_SYSTEM_TIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_system_time() using clock_gettime()])\n    ;;\n  gettimeofday)\n    AC_DEFINE(OS_SYSTEM_TIME_GETTIMEOFDAY,  [1], [Define if you want to implement erts_os_system_time() using gettimeofday()])\n    ;;\n  *)\n    ;;\nesac\n\nif test \"x$erl_wall_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(WALL_CLOCK_ID_STR, [\"$erl_wall_clock_id\"], [Define as a string of wall clock id to use])\n    AC_DEFINE_UNQUOTED(WALL_CLOCK_ID, [$erl_wall_clock_id], [Define to wall clock id to use])\nfi\n\nfi # $force_gettimeofday_os_system_time != yes\n\ncase \"$with_clock_gettime_monotonic_id\" in\n   \"\"|no)\n     with_clock_gettime_monotonic_id=no\n     ;;\n   CLOCK_*CPUTIME*)\n     AC_MSG_ERROR([Invalid clock_gettime() monotonic clock id: Refusing to use the cputime clock id $with_clock_gettime_monotonic_id as monotonic clock id])\n     ;;\n   CLOCK_REALTIME*|CLOCK_TAI*)\n     AC_MSG_ERROR([Invalid clock_gettime() monotonic clock id: Refusing to use the realtime clock id $with_clock_gettime_monotonic_id as monotonic clock id])\n     ;;\n   CLOCK_*)\n     ;;\n   *)\n     AC_MSG_ERROR([Invalid clock_gettime() clock id: $with_clock_gettime_monotonic_id])\n     ;;\nesac\n\ncase \"$with_clock_resolution-$with_clock_gettime_monotonic_id\" in\n  high-no)\n\tERL_MONOTONIC_CLOCK(high_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  low-no)\n\tERL_MONOTONIC_CLOCK(low_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  default-no)\n\tERL_MONOTONIC_CLOCK(default_resolution, undefined, $prefer_elapsed_monotonic_time_during_suspend);;\n  *)\n\tERL_MONOTONIC_CLOCK(custom_resolution, $with_clock_gettime_monotonic_id, $prefer_elapsed_monotonic_time_during_suspend);;\nesac\n\ncase \"$erl_monotonic_clock_func-$erl_monotonic_clock_id-$with_clock_gettime_monotonic_id\" in\n  *-*-no)\n    ;;\n  clock_gettime-$with_clock_gettime_monotonic_id-$with_clock_gettime_monotonic_id)\n    ;;\n  *)\n    AC_MSG_ERROR([$with_clock_gettime_monotonic_id as clock id to clock_gettime() doesn't compile])\n    ;;\nesac\n\ncase $erl_monotonic_clock_func in\n  times)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_TIMES, [1], [Define if you want to implement erts_os_monotonic_time() using times()])\n    ;;\n  mach_clock_get_time)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_monotonic_time() using mach clock_get_time()])\n    ;;\n  clock_gettime)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_monotonic_time() using clock_gettime()])\n    ;;\n  gethrtime)\n    AC_DEFINE(OS_MONOTONIC_TIME_USING_GETHRTIME,  [1], [Define if you want to implement erts_os_monotonic_time() using gethrtime()])\n    ;;\n  *)\n    ;;\nesac\n\nif test $erl_corrected_monotonic_clock = yes; then\n  AC_DEFINE(ERTS_HAVE_CORRECTED_OS_MONOTONIC_TIME, [1], [Define if OS monotonic clock is corrected])\nfi\n\nif test $erl_monotonic_clock_low_resolution = yes; then\n  AC_DEFINE(ERTS_HAVE_LOW_RESOLUTION_OS_MONOTONIC_LOW, [1], [Define if you have a low resolution OS monotonic clock])\nfi\n\nxrtlib=\nif test \"$erl_monotonic_clock_lib\" != \"\"; then\n   xrtlib=\"$erl_monotonic_clock_lib\"\nfi\nif test \"$erl_wall_clock_lib\" != \"\"; then\n   xrtlib=\"$erl_wall_clock_lib\"\nfi\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(MONOTONIC_CLOCK_ID_STR, [\"$erl_monotonic_clock_id\"], [Define as a string of monotonic clock id to use])\n    AC_DEFINE_UNQUOTED(MONOTONIC_CLOCK_ID, [$erl_monotonic_clock_id], [Define to monotonic clock id to use])\nfi\n\nif test $erl_cv_clock_gettime_monotonic_raw = yes; then\n  AC_DEFINE(HAVE_CLOCK_GETTIME_MONOTONIC_RAW, [1], [Define if you have clock_gettime(CLOCK_MONOTONIC_RAW, _)])\nfi\n\nERL_MONOTONIC_CLOCK(high_resolution, undefined, no)\n\ncase $$erl_monotonic_clock_low_resolution-$erl_monotonic_clock_func in\n  no-mach_clock_get_time)\n    monotonic_hrtime=yes    \n    AC_DEFINE(SYS_HRTIME_USING_MACH_CLOCK_GET_TIME, [1], [Define if you want to implement erts_os_hrtime() using mach clock_get_time()])\n    ;;\n  no-clock_gettime)\n    monotonic_hrtime=yes\n    AC_DEFINE(SYS_HRTIME_USING_CLOCK_GETTIME, [1], [Define if you want to implement erts_os_hrtime() using clock_gettime()])\n    ;;\n  no-gethrtime)\n    monotonic_hrtime=yes\n    AC_DEFINE(SYS_HRTIME_USING_GETHRTIME,  [1], [Define if you want to implement erts_os_hrtime() using gethrtime()])\n    ;;\n  *)\n    monotonic_hrtime=no\n    ;;\nesac\n\nif test $monotonic_hrtime = yes; then\n    AC_DEFINE(HAVE_MONOTONIC_ERTS_SYS_HRTIME, [1], [Define if you have a monotonic erts_os_hrtime() implementation])\nfi\n\nif test \"x$erl_monotonic_clock_id\" != \"x\"; then\n    AC_DEFINE_UNQUOTED(HRTIME_CLOCK_ID_STR, [\"$erl_monotonic_clock_id\"], [Define as a string of monotonic clock id to use])\n    AC_DEFINE_UNQUOTED(HRTIME_CLOCK_ID, [$erl_monotonic_clock_id], [Define to monotonic clock id to use])\nfi\n\n\ndnl\ndnl Check if gethrvtime is working, and if to use procfs ioctl\ndnl or (yet to be written) write to the procfs ctl file.\ndnl\n\nAC_MSG_CHECKING([if gethrvtime works and how to use it])\nAC_TRY_RUN([\n/* gethrvtime procfs ioctl test */\n/* These need to be undef:ed to not break activation of\n * micro level process accounting on /proc/self \n */\n#ifdef _LARGEFILE_SOURCE\n#  undef _LARGEFILE_SOURCE\n#endif\n#ifdef _FILE_OFFSET_BITS\n#  undef _FILE_OFFSET_BITS\n#endif\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/signal.h>\n#include <sys/fault.h>\n#include <sys/syscall.h>\n#include <sys/procfs.h>\n#include <fcntl.h>\n\nint main() {\n    long msacct = PR_MSACCT;\n    int fd;\n    long long start, stop;\n    int i;\n    pid_t pid = getpid();\n    char proc_self[30] = \"/proc/\";\n\n    sprintf(proc_self+strlen(proc_self), \"%lu\", (unsigned long) pid);\n    if ( (fd = open(proc_self, O_WRONLY)) == -1)\n\texit(1);\n    if (ioctl(fd, PIOCSET, &msacct) < 0)\n\texit(2);\n    if (close(fd) < 0)\n\texit(3);\n    start = gethrvtime();\n    for (i = 0; i < 100; i++)\n\tstop = gethrvtime();\n    if (start == 0)\n\texit(4);\n    if (start == stop)\n\texit(5);\n    exit(0); return 0;\n}\n],\nerl_gethrvtime=procfs_ioctl,\nerl_gethrvtime=false,\n[\ncase X$erl_xcomp_gethrvtime_procfs_ioctl in\n    X)\n\terl_gethrvtime=cross;;\n    Xyes|Xno)\n\tif test $erl_xcomp_gethrvtime_procfs_ioctl = yes; then\n\t    erl_gethrvtime=procfs_ioctl\n\telse\n\t    erl_gethrvtime=false\n\tfi;;\n    *)\n\tAC_MSG_ERROR([Bad erl_xcomp_gethrvtime_procfs_ioctl value: $erl_xcomp_gethrvtime_procfs_ioctl]);;\nesac\n])\n\nLIBRT=$xrtlib\ncase $erl_gethrvtime in\n  procfs_ioctl)\n\tAC_DEFINE(HAVE_GETHRVTIME_PROCFS_IOCTL,[1],\n\t\t[define if gethrvtime() works and uses ioctl() to /proc/self])\n\tAC_MSG_RESULT(uses ioctl to procfs)\n\t;;\n  *)\n\tif test $erl_gethrvtime = cross; then\n\t    erl_gethrvtime=false\n\t    AC_MSG_RESULT(cross)\n\t    AC_MSG_WARN([result 'not working' guessed because of cross compilation])\n\telse\n\t    AC_MSG_RESULT(not working)\n\tfi\n\n\tdnl\n\tdnl Check if clock_gettime (linux) is working\n\tdnl\n\n\tAC_MSG_CHECKING([if clock_gettime can be used to get thread CPU time])\n\tsave_libs=$LIBS\n\tLIBS=\"-lrt\"\n\tAC_TRY_RUN([\n\t#include <stdlib.h>\n\t#include <unistd.h>\n\t#include <string.h>\n\t#include <stdio.h>\n\t#include <time.h>\n\tint main() {\n\t    long long start, stop;\n\t    int i;\n\t    struct timespec tp;\n\n\t    if (clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp) < 0)\n\t      exit(1);\n\t    start = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;\n\t    for (i = 0; i < 100; i++)\n\t      clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp);\n\t    stop = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;\n\t    if (start == 0)\n\t      exit(4);\n\t    if (start == stop)\n\t      exit(5);\n\t    exit(0); return 0;\n\t  }\n\t],\n\terl_clock_gettime_cpu_time=yes,\n\terl_clock_gettime_cpu_time=no,\n\t[\n\tcase X$erl_xcomp_clock_gettime_cpu_time in\n\t    X) erl_clock_gettime_cpu_time=cross;;\n\t    Xyes|Xno) erl_clock_gettime_cpu_time=$erl_xcomp_clock_gettime_cpu_time;;\n\t    *) AC_MSG_ERROR([Bad erl_xcomp_clock_gettime_cpu_time value: $erl_xcomp_clock_gettime_cpu_time]);;\n\tesac\n\t])\n\tLIBS=$save_libs\n\tAC_MSG_RESULT($erl_clock_gettime_cpu_time)\n\tcase $erl_clock_gettime_cpu_time in\n\t\tyes)\n\t\t\tAC_DEFINE(HAVE_CLOCK_GETTIME_CPU_TIME,[],\n\t\t\t\t  [define if clock_gettime() works for getting thread time])\n\t\t\tLIBRT=-lrt\n\t\t\t;;\n\t\tcross)\n\t\t\terl_clock_gettime_cpu_time=no\n\t\t\tAC_MSG_WARN([result no guessed because of cross compilation])\n\t\t\t;;\n\t\t*)\n\t\t\t;;\n\tesac\n\t;;\nesac\nAC_SUBST(LIBRT)\n])dnl\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_TRY_ENABLE_CFLAG\ndnl\ndnl\ndnl Tries a CFLAG and sees if it can be enabled without compiler errors\ndnl $1: textual cflag to add\ndnl $2: variable to store the modified CFLAG in\ndnl Usage example LM_TRY_ENABLE_CFLAG([-Werror=return-type], [CFLAGS])\ndnl\ndnl\nAC_DEFUN([LM_TRY_ENABLE_CFLAG], [\n    AC_MSG_CHECKING([if we can add $1 to $2 (via CFLAGS)])\n    saved_CFLAGS=$CFLAGS;\n    CFLAGS=\"$1 $$2\";\n    AC_TRY_COMPILE([],[return 0;],can_enable_flag=true,can_enable_flag=false)\n    CFLAGS=$saved_CFLAGS;\n    if test \"X$can_enable_flag\" = \"Xtrue\"; then\n        AC_MSG_RESULT([yes])\n        AS_VAR_SET($2, \"$1 $$2\")\n    else\n        AC_MSG_RESULT([no])\n    fi\n])\n\nAC_DEFUN([LM_CHECK_ENABLE_CFLAG], [\n    AC_MSG_CHECKING([whether $CC accepts $1...])\n    saved_CFLAGS=$CFLAGS;\n    CFLAGS=\"$1 $CFLAGS\";\n    AC_TRY_COMPILE([],[return 0;],can_enable_flag=true,can_enable_flag=false)\n    CFLAGS=$saved_CFLAGS;\n    if test \"X$can_enable_flag\" = \"Xtrue\"; then\n        AS_VAR_SET($2, true)\n        AC_MSG_RESULT([yes])\n    else\n        AS_VAR_SET($2, false)\n        AC_MSG_RESULT([no])\n    fi\n])\n\ndnl ERL_TRY_LINK_JAVA(CLASSES, FUNCTION-BODY\ndnl                   [ACTION_IF_FOUND [, ACTION-IF-NOT-FOUND]])\ndnl Freely inspired by AC_TRY_LINK. (Maybe better to create a \ndnl AC_LANG_JAVA instead...)\nAC_DEFUN(ERL_TRY_LINK_JAVA,\n[java_link='$JAVAC conftest.java 1>&AC_FD_CC'\nchangequote(, )dnl\ncat > conftest.java <<EOF\n$1\nclass conftest { public static void main(String[] args) {\n   $2\n   ; return; }}\nEOF\nchangequote([, ])dnl\nif AC_TRY_EVAL(java_link) && test -s conftest.class; then\n   ifelse([$3], , :, [rm -rf conftest*\n   $3])\nelse\n   echo \"configure: failed program was:\" 1>&AC_FD_CC\n   cat conftest.java 1>&AC_FD_CC\n   echo \"configure: PATH was $PATH\" 1>&AC_FD_CC\nifelse([$4], , , [  rm -rf conftest*\n  $4\n])dnl\nfi\nrm -f conftest*])\n#define UNSAFE_MASK  0xc0000000 /* Mask for bits that must be constant */\n\n\ndnl ----------------------------------------------------------------------\ndnl\ndnl LM_HARDWARE_ARCH\ndnl\ndnl Determine target hardware in ARCH\ndnl\nAC_DEFUN([LM_HARDWARE_ARCH], [\n    AC_MSG_CHECKING([target hardware architecture])\n    if test \"x$host_alias\" != \"x\" -a \"x$host_cpu\" != \"x\"; then\n        chk_arch_=$host_cpu\n    else\n        chk_arch_=`uname -m`\n    fi\n\n    case $chk_arch_ in\n    sun4u)\tARCH=ultrasparc;;\n    sparc64)\tARCH=sparc64;;\n    sun4v)\tARCH=ultrasparc;;\n    i86pc)\tARCH=x86;;\n    i386)\tARCH=x86;;\n    i486)\tARCH=x86;;\n    i586)\tARCH=x86;;\n    i686)\tARCH=x86;;\n    x86_64)\tARCH=amd64;;\n    amd64)\tARCH=amd64;;\n    macppc)\tARCH=ppc;;\n    powerpc)\tARCH=ppc;;\n    ppc)\tARCH=ppc;;\n    ppc64)\tARCH=ppc64;;\n    ppc64le)\tARCH=ppc64le;;\n    \"Power Macintosh\")\tARCH=ppc;;\n    armv5b)\tARCH=arm;;\n    armv5teb)\tARCH=arm;;\n    armv5tel)\tARCH=arm;;\n    armv5tejl)\tARCH=arm;;\n    armv6l)\tARCH=arm;;\n    armv6hl)\tARCH=arm;;\n    armv7l)\tARCH=arm;;\n    armv7hl)\tARCH=arm;;\n    tile)\tARCH=tile;;\n    e2k)        ARCH=e2k;;\n    *)\t \tARCH=noarch;;\n    esac\n    AC_MSG_RESULT($ARCH)\n\n    dnl\n    dnl Convert between x86 and amd64 based on the compiler's mode.\n    dnl Ditto between ultrasparc and sparc64.\n    dnl\n    AC_MSG_CHECKING(whether compilation mode forces ARCH adjustment)\n    case \"$ARCH-$ac_cv_sizeof_void_p\" in\n    x86-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=x86 to ARCH=amd64)\n\tARCH=amd64\n\t;;\n    amd64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=amd64 to ARCH=x86)\n\tARCH=x86\n\t;;\n    ultrasparc-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ultrasparc to ARCH=sparc64)\n\tARCH=sparc64\n\t;;\n    sparc64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=sparc64 to ARCH=ultrasparc)\n\tARCH=ultrasparc\n\t;;\n    ppc64-4)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ppc64 to ARCH=ppc)\n\tARCH=ppc\n\t;;\n    ppc-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=ppc to ARCH=ppc64)\n\tARCH=ppc64\n\t;;\n    arm-8)\n\tAC_MSG_RESULT(yes: adjusting ARCH=arm to ARCH=noarch)\n\tARCH=noarch\n\t;;\n    *)\n\tAC_MSG_RESULT(no: ARCH is $ARCH)\n\t;;\n    esac\n\n    AC_SUBST(ARCH)\n])\n\ndnl\ndnl--------------------------------------------------------------------\ndnl Dynamic Erlang Drivers\ndnl\ndnl Linking to produce dynamic Erlang drivers to be loaded by Erlang's\ndnl Dynamic Driver Loader and Linker (DDLL). Below the prefix DED is an\ndnl abbreviation for `Dynamic Erlang Driver'.\ndnl\ndnl For DED we need something quite sloppy, which allows undefined references \ndnl (notably driver functions) in the resulting shared library. \ndnl Example of Makefile rule (and settings of macros):\ndnl\ndnl LIBS = @LIBS@\ndnl LD = @DED_LD@\ndnl LDFLAGS = @DED_LDFLAGS@\ndnl soname = @ldsoname@\ndnl\ndnl my_drv.so:   my_drv.o my_utils.o\ndnl              $(LD) $(LDFLAGS) $(soname) $@ -o $@ $^ -lc $(LIBS)\ndnl\ndnl--------------------------------------------------------------------\ndnl\n\nAC_DEFUN(ERL_DED,\n\t[\n\nUSER_LD=$LD\nUSER_LDFLAGS=\"$LDFLAGS\"\n\nLM_CHECK_THR_LIB\n\nDED_CC=$CC\nDED_GCC=$GCC\n\nDED_CFLAGS=\nDED_OSTYPE=unix\ncase $host_os in\n     linux*)\n\tDED_CFLAGS=\"-D_GNU_SOURCE\" ;;\n     win32)\n\tDED_CFLAGS=\"-D_WIN32_WINNT=0x0600 -DWINVER=0x0600\"\n        DED_OSTYPE=win32 ;;\n     *)\n        ;;\nesac\n\n\nDED_WARN_FLAGS=\"-Wall -Wstrict-prototypes\"\ncase \"$host_cpu\" in\n  tile*)\n    # tile-gcc is a bit stricter with -Wmissing-prototypes than other gccs,\n    # and too strict for our taste.\n    ;;\n  *)\n    DED_WARN_FLAGS=\"$DED_WARN_FLAGS -Wmissing-prototypes\";;\nesac\n  \nLM_TRY_ENABLE_CFLAG([-Wdeclaration-after-statement], [DED_WARN_FLAGS])\n\nLM_TRY_ENABLE_CFLAG([-Werror=return-type], [DED_WERRORFLAGS])\nLM_TRY_ENABLE_CFLAG([-Werror=implicit], [DED_WERRORFLAGS])\nLM_TRY_ENABLE_CFLAG([-Werror=undef], [DED_WERRORFLAGS])\n\nDED_SYS_INCLUDE=\"-I${ERL_TOP}/erts/emulator/beam -I${ERL_TOP}/erts/include -I${ERL_TOP}/erts/include/$host -I${ERL_TOP}/erts/include/internal -I${ERL_TOP}/erts/include/internal/$host -I${ERL_TOP}/erts/emulator/sys/$DED_OSTYPE -I${ERL_TOP}/erts/emulator/sys/common\"\nDED_INCLUDE=$DED_SYS_INCLUDE\n\nif test \"$THR_DEFS\" = \"\"; then\n    DED_THR_DEFS=\"-D_THREAD_SAFE -D_REENTRANT\"\nelse\n    DED_THR_DEFS=\"$THR_DEFS\"\nfi\n# DED_EMU_THR_DEFS=$EMU_THR_DEFS\nDED_CFLAGS=\"$CFLAGS $CPPFLAGS $DED_CFLAGS\"\nif test \"x$GCC\" = xyes; then\n    DED_STATIC_CFLAGS=\"$DED_CFLAGS\"\n    DED_CFLAGS=\"$DED_CFLAGS -fPIC\"\nfi\n\nDED_EXT=so\ncase $host_os in\n    win32) DED_EXT=dll;;\n    darwin*)\n\tDED_CFLAGS=\"$DED_CFLAGS -fno-common\"\n\tDED_STATIC_CFLAGS=\"$DED_STATIC_CFLAGS -fno-common\";;\n    *)\n\t;;\nesac\n\nDED_STATIC_CFLAGS=\"$DED_STATIC_CFLAGS -DSTATIC_ERLANG_NIF -DSTATIC_ERLANG_DRIVER\"\n\nif test \"$CFLAG_RUNTIME_LIBRARY_PATH\" = \"\"; then\n\n  CFLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-R\"\n  case $host_os in\n    darwin*)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n    win32)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n    osf*)\n\tCFLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-rpath,\"\n\t;;\n    *)\n\t;;\n  esac\n\nfi\n\n# If DED_LD is set in environment, we expect all DED_LD* variables\n# to be specified (cross compiling)\nif test \"x$DED_LD\" = \"x\"; then\n\nDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-R\"\ncase $host_os in\n\twin32)\n\t\tDED_LD=\"ld.sh\"\n\t\tDED_LDFLAGS=\"-dll\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\t;;\n\tsolaris2*|sysv4*)\n\t\tDED_LDFLAGS=\"-G\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-64 $DED_LDFLAGS\"\n\t\tfi\n\t;;\n\taix4*)\n\t\tDED_LDFLAGS=\"-G -bnoentry -bexpall\"\n\t;;\n\tfreebsd2*)\n\t\t# Non-ELF GNU linker\n\t\tDED_LDFLAGS=\"-Bshareable\"\n\t;;\n\tdarwin*)\n\t\t# Mach-O linker: a shared lib and a loadable\n\t\t# object file is not the same thing.\n\t\tDED_LDFLAGS=\"-bundle -bundle_loader ${ERL_TOP}/bin/$host/beam.smp\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t  DED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\telse\n\t\t  if test X${enable_m32_build} = Xyes; then\n\t\t    DED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\t  else\n\t\t    AC_CHECK_SIZEOF(void *)\n\t\t    case \"$ac_cv_sizeof_void_p\" in\n\t\t      8)\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\";;\n\t\t      *)\n\t\t        ;;\n\t\t    esac\n\t\t  fi\n\t\tfi\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t;;\n\tlinux*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared -Wl,-Bsymbolic\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\tfi;\n\t\tif test X${enable_m32_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\tfi\n\t;;\t\n\tfreebsd*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared\"\n\t\tif test X${enable_m64_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m64 $DED_LDFLAGS\"\n\t\tfi;\n\t\tif test X${enable_m32_build} = Xyes; then\n\t\t\tDED_LDFLAGS=\"-m32 $DED_LDFLAGS\"\n\t\tfi\n\t;;\t\n\topenbsd*)\n\t\tDED_LD=\"$CC\"\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"$CFLAG_RUNTIME_LIBRARY_PATH\"\n\t\tDED_LDFLAGS=\"-shared\"\n\t;;\n\tosf*)\n\t\t# NOTE! Whitespace after -rpath is important.\n\t\tDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-rpath \"\n\t\tDED_LDFLAGS=\"-shared -expect_unresolved '*'\"\n\t;;\n\t*)\n\t\t# assume GNU linker and ELF\n\t\tDED_LDFLAGS=\"-shared\"\n\t\t# GNU linker has no option for 64bit build, should not propagate -m64\n\t;;\nesac\n\nif test \"$DED_LD\" = \"\" && test \"$USER_LD\" != \"\"; then\n    DED_LD=\"$USER_LD\"\n    DED_LDFLAGS=\"$USER_LDFLAGS $DED_LDFLAGS\"\nfi\n\nDED_LIBS=$LIBS\n\nfi # \"x$DED_LD\" = \"x\"\n\nAC_CHECK_TOOL(DED_LD, ld, false)\ntest \"$DED_LD\" != \"false\" || AC_MSG_ERROR([No linker found])\n\nAC_MSG_CHECKING(for static compiler flags)\nDED_STATIC_CFLAGS=\"$DED_WERRORFLAGS $DED_WFLAGS $DED_THR_DEFS $DED_STATIC_CFLAGS\"\nAC_MSG_RESULT([$DED_STATIC_CFLAGS])\nAC_MSG_CHECKING(for basic compiler flags for loadable drivers)\nDED_BASIC_CFLAGS=$DED_CFLAGS\nAC_MSG_RESULT([$DED_CFLAGS])\nAC_MSG_CHECKING(for compiler flags for loadable drivers)\nDED_CFLAGS=\"$DED_WERRORFLAGS $DED_WARN_FLAGS $DED_THR_DEFS $DED_CFLAGS\"\nAC_MSG_RESULT([$DED_CFLAGS])\nAC_MSG_CHECKING(for linker for loadable drivers)\nAC_MSG_RESULT([$DED_LD])\nAC_MSG_CHECKING(for linker flags for loadable drivers)\nAC_MSG_RESULT([$DED_LDFLAGS])\nAC_MSG_CHECKING(for 'runtime library path' linker flag)\nif test \"x$DED_LD_FLAG_RUNTIME_LIBRARY_PATH\" != \"x\"; then\n\tAC_MSG_RESULT([$DED_LD_FLAG_RUNTIME_LIBRARY_PATH])\nelse\n\tAC_MSG_RESULT([not found])\nfi\n\nAC_SUBST(DED_CC)\nAC_SUBST(DED_GCC)\nAC_SUBST(DED_EXT)\nAC_SUBST(DED_SYS_INCLUDE)\nAC_SUBST(DED_INCLUDE)\nAC_SUBST(DED_BASIC_CFLAGS)\nAC_SUBST(DED_CFLAGS)\nAC_SUBST(DED_STATIC_CFLAGS)\nAC_SUBST(DED_WARN_FLAGS)\nAC_SUBST(DED_WERRORFLAGS)\nAC_SUBST(DED_LD)\nAC_SUBST(DED_LDFLAGS)\nAC_SUBST(DED_LD_FLAG_RUNTIME_LIBRARY_PATH)\nAC_SUBST(DED_LIBS)\nAC_SUBST(DED_THR_DEFS)\nAC_SUBST(DED_OSTYPE)\n\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/HOWTO/INSTALL-CROSS.md": "Cross Compiling Erlang/OTP\n==========================\n\nIntroduction\n------------\n\nThis document describes how to cross compile Erlang/OTP-%OTP-REL%. \nYou are advised to read the whole document before attempting to cross\ncompile Erlang/OTP. However, before reading this document, you should read\nthe [$ERL_TOP/HOWTO/INSTALL.md][] document which describes building and installing\nErlang/OTP in general. `$ERL_TOP` is the top directory in the source tree.\n\n### otp\\_build Versus configure/make ###\n\nBuilding Erlang/OTP can be done either by using the `$ERL_TOP/otp_build`\nscript, or by invoking `$ERL_TOP/configure` and `make` directly. Building using\n`otp_build` is easier since it involves fewer steps, but the `otp_build` build\nprocedure is not as flexible as the `configure`/`make` build procedure. Note\nthat `otp_build configure` will produce a default configuration that differs\nfrom what `configure` will produce by default. For example, currently\n`--disable-dynamic-ssl-lib` is added to the `configure` command line arguments\nunless `--enable-dynamic-ssl-lib` has been explicitly passed. The binary\nreleases that we deliver are built using `otp_build`.  The defaults used by\n`otp_build configure` may change at any time without prior notice.\n\n### Cross Configuration ###\n\nThe `$ERL_TOP/xcomp/erl-xcomp.conf.template` file contains all available cross\nconfiguration variables and can be used as a template when creating a cross\ncompilation configuration. All [cross configuration variables][] are also\nlisted at the end of this document. For examples of working cross\nconfigurations see the `$ERL_TOP/xcomp/erl-xcomp-TileraMDE2.0-tilepro.conf`\nfile and the `$ERL_TOP/xcomp/erl-xcomp-x86_64-saf-linux-gnu.conf` file. If the\ndefault behavior of a variable is satisfactory, the variable does not need to\nbe set. However, the `configure` script will issue a warning when a default\nvalue is used. When a variable has been set, no warning will be issued.\n\nA cross configuration file can be passed to `otp_build configure` using the\n`--xcomp-conf` command line argument. Note that `configure` does not accept\nthis command line argument. When using the `configure` script directly, pass\nthe configuration variables as arguments to `configure` using a\n`<VARIABLE>=<VALUE>` syntax. Variables can also be passed as environment\nvariables to `configure`. However, if you pass the configuration in the\nenvironment, make sure to unset all of these environment variables before\ninvoking `make`; otherwise, the environment variables might set make variables\nin some applications, or parts of some applications, and you may end up with\nan erroneously configured build. \n\n### What can be Cross Compiled? ###\n\nAll Erlang/OTP applications except the `wx` application can be cross compiled.\nThe build of the `wx` driver will currently be automatically disabled when\ncross compiling.\n\n### Compatibility ###\n\nThe build system, including cross compilation configuration variables used,\nmay be subject to non backward compatible changes without prior notice.\nCurrent cross build system has been tested when cross compiling some Linux/GNU\nsystems, but has only been partly tested for more esoteric platforms. The\nVxWorks example file is highly dependent on our environment and is here more\nor less only for internal use.\n\n### Patches ###\n\nPlease submit any patches for cross compiling in a way consistent with this\nsystem. All input is welcome as we have a very limited set of cross compiling\nenvironments to test with. If a new configuration variable is needed, add it\nto `$ERL_TOP/xcomp/erl-xcomp.conf.template`, and use it in `configure.in`.\nOther files that might need to be updated are:\n\n- `$ERL_TOP/xcomp/erl-xcomp-vars.sh`\n- `$ERL_TOP/erl-build-tool-vars.sh`\n- `$ERL_TOP/erts/aclocal.m4`\n- `$ERL_TOP/xcomp/README.md`\n- `$ERL_TOP/xcomp/erl-xcomp-*.conf`\n\nNote that this might be an incomplete list of files that need to be updated.\n\nGeneral information on how to submit patches can be found at:\n  <http://wiki.github.com/erlang/otp/submitting-patches>\n\nBuild and Install Procedure\n---------------------------\n\nIf you are building in Git, you want to read the [Building in Git][] section\nof [$ERL_TOP/HOWTO/INSTALL.md][] before proceeding.\n\nWe will first go through the `configure`/`make` build procedure which people\nprobably are most familiar with.\n\n### Building With configure/make Directly ###\n\n  (1)\n\nChange directory into the top directory of the Erlang/OTP source tree.\n\n    $ cd $ERL_TOP\n\nIn order to compile Erlang code, a small Erlang bootstrap system has to be\nbuilt, or an Erlang/OTP system of the same release as the one being built\nhas to be provided in the `$PATH`. The Erlang/OTP for the target system will\nbe built using this Erlang system, together with the cross compilation tools\nprovided.\n\nIf you want to build using a compatible Erlang/OTP system in the `$PATH`,\njump to (3).\n\n#### Building a Bootstrap System ####\n\n  (2)\n\n    $ ./configure --enable-bootstrap-only\n    $ make\n\nThe `--enable-bootstrap-only` argument to `configure` isn't strictly necessary,\nbut will speed things up. It will only run `configure` in applications\nnecessary for the bootstrap, and will disable a lot of things not needed by\nthe bootstrap system. If you run `configure` without `--enable-boostrap-only`\nyou also have to run make as `make bootstrap`; otherwise, the whole system will\nbe built.\n\n#### Cross Building the System ####\n\n  (3)\n\n    $ ./configure --host=<HOST> --build=<BUILD> [Other Config Args]\n    $ make\n\n`<HOST>` is the host/target system that you build for. It does not have to be\na full `CPU-VENDOR-OS` triplet, but can be. The full `CPU-VENDOR-OS` triplet\nwill be created by executing `$ERL_TOP/erts/autoconf/config.sub <HOST>`. If\n`config.sub` fails, you need to be more specific.\n\n`<BUILD>` should equal the `CPU-VENDOR-OS` triplet of the system that you\nbuild on. If you execute `$ERL_TOP/erts/autoconf/config.guess`, it will in\nmost cases print the triplet you want to use for this.\n\nPass the cross compilation variables as command line arguments to `configure`\nusing a `<VARIABLE>=<VALUE>` syntax.\n\n> *NOTE*: You can *not* pass a configuration file using the `--xcomp-conf`\n> argument when you invoke `configure` directly. The `--xcomp-conf` argument\n> can only be passed to `otp_build configure`.\n\n`make` will verify that the Erlang/OTP system used when building is of the\nsame release as the system being built, and will fail if this is not the case.\nIt is possible, however not recommended, to force the cross compilation even\nthough the wrong Erlang/OTP system is used. This by invoking `make` like this:\n`make ERL_XCOMP_FORCE_DIFFERENT_OTP=yes`.\n\n> *WARNING*: Invoking `make ERL_XCOMP_FORCE_DIFFERENT_OTP=yes` might fail,\n> silently produce suboptimal code, or silently produce erroneous code.\n\n#### Installing ####\n\nYou can either install using the installation paths determined by `configure`\n(4), or install manually using (5).\n\n##### Installing Using Paths Determined by configure #####\n\n  (4)\n\n    $ make install DESTDIR=<TEMPORARY_PREFIX>\n\n`make install` will install at a location specified when doing `configure`.\n`configure` arguments specifying where the installation should reside are for\nexample: `--prefix`, `--exec-prefix`, `--libdir`, `--bindir`, etc. By default\nit will install under `/usr/local`. You typically do not want to install your\ncross build under `/usr/local` on your build machine. Using [DESTDIR][]\nwill cause the installation paths to be prefixed by `$DESTDIR`. This makes it\npossible to install and package the installation on the build machine without\nhaving to place the installation in the same directory on the build machine as\nit should be executed from on the target machine.\n\nWhen `make install` has finished, change directory into `$DESTDIR`, package\nthe system, move it to the target machine, and unpack it. Note that the\ninstallation will only be working on the target machine at the location\ndetermined by `configure`.\n\n##### Installing Manually #####\n\n  (5)\n\n    $ make release RELEASE_ROOT=<RELEASE_DIR>\n\n`make release` will copy what you have built for the target machine to\n`<RELEASE_DIR>`. The `Install` script will not be run. The content of\n`<RELEASE_DIR>` is what by default ends up in `/usr/local/lib/erlang`.\n\nThe `Install` script used when installing Erlang/OTP requires common Unix\ntools such as `sed` to be present in your `$PATH`. If your target system\ndoes not have such tools, you need to run the `Install` script on your\nbuild machine before packaging Erlang/OTP. The `Install` script should\ncurrently be invoked as follows in the directory where it resides\n(the top directory):\n\n    $ ./Install [-cross] [-minimal|-sasl] <ERL_ROOT>\n\nwhere:\n\n*   `-minimal` Creates an installation that starts up a minimal amount\n    of applications, i.e., only `kernel` and `stdlib` are started. The\n    minimal system is normally enough, and is what `make install` uses.\n*   `-sasl` Creates an installation that also starts up the `sasl`\n    application.\n*   `-cross` For cross compilation. Informs the install script that it\n    is run on the build machine.\n*   `<ERL_ROOT>` - The absolute path to the Erlang installation to use\n    at run time. This is often the same as the current working directory,\n    but does not have to be. It can follow any other path through the file\n    system to the same directory.\n\nIf neither `-minimal`, nor `-sasl` is passed as argument you will be\nprompted.\n\nYou can now either do:\n\n  (6)\n\n*   Decide where the installation should be located on the target machine,\n    run the `Install` script on the build machine, and package the installed\n    installation. The installation just need to be unpacked at the right\n    location on the target machine:\n\n        $ cd <RELEASE_DIR>\n        $ ./Install -cross [-minimal|-sasl] <ABSOLUTE_INSTALL_DIR_ON_TARGET>\n\nor:\n\n  (7)\n\n*   Package the installation in `<RELEASE_DIR>`, place it wherever you want\n    on your target machine, and run the `Install` script on your target\n    machine:\n\n        $ cd <ABSOLUTE_INSTALL_DIR_ON_TARGET>\n        $ ./Install [-minimal|-sasl] <ABSOLUTE_INSTALL_DIR_ON_TARGET>\n\n### Building With the otp\\_build Script ###\n\n  (8)\n\n    $ cd $ERL_TOP\n\n  (9)\n\n    $ ./otp_build configure --xcomp-conf=<FILE> [Other Config Args]\n\nalternatively:\n\n    $ ./otp_build configure --host=<HOST> --build=<BUILD> [Other Config Args]\n\nIf you have your cross compilation configuration in a file, pass it using the\n`--xcomp-conf=<FILE>` command line argument. If not, pass `--host=<HOST>`,\n`--build=<BUILD>`, and the configuration variables using a `<VARIABLE>=<VALUE>`\nsyntax on the command line  (same as in (3)). Note that `<HOST>` and `<BUILD>`\nhave to be passed one way or the other; either by using `erl_xcomp_host=<HOST>`\nand `erl_xcomp_build=<BUILD>` in the configuration file, or by using the\n`--host=<HOST>`, and `--build=<BUILD>` command line arguments.\n\n`otp_build configure` will configure both for the boostrap system on the\nbuild machine and the cross host system.\n\n  (10)\n\n    $ ./otp_build boot -a\n\n`otp_build boot -a` will first build a bootstrap system for the build machine\nand then do the cross build of the system.\n\n  (11)\n\n    $ ./otp_build release -a <RELEASE_DIR>\n\n`otp_build release -a` will do the same as (5), and you will after this have\nto do a manual install either by doing (6), or (7).\n\nBuilding and Installing the Documentation\n-----------------------------------------\n\nAfter the system has been cross built you can build and install the\ndocumentation the same way as after a native build of the system. See the\n[How to Build the Documentation][] section in the [$ERL_TOP/HOWTO/INSTALL.md][]\ndocument for information on how to build the documentation.\n\nTesting the cross compiled system\n---------------------------------\n\nSome of the tests that come with erlang use native code to test. This means\nthat when cross compiling erlang you also have to cross compile test suites\nin order to run tests on the target host. To do this you first have to release\nthe tests as usual.\n\n    $ make release_tests\n\nor\n\n    $ ./otp_build tests\n\nThe tests will be released into `$ERL_TOP/release/tests`. After releasing the\ntests you have to install the tests on the build machine. You supply the same\nxcomp file as to `./otp_build` in (9).\n\n    $ cd $ERL_TOP/release/tests/test_server/\n    $ $ERL_TOP/bootstrap/bin/erl -eval 'ts:install([{xcomp,\"<FILE>\"}])' -s ts compile_testcases -s init stop\n\nYou should get a lot of printouts as the testcases are compiled. Once done you\nshould copy the entire `$ERL_TOP/release/tests` folder to the cross host system.\n\nThen go to the cross host system and setup the erlang installed in (4) or (5)\nto be in your `$PATH`. Then go to what previously was\n`$ERL_TOP/release/tests/test_server` and issue the following command.\n\n    $ erl -s ts install -s ts run all_tests -s init stop\n\nThe configure should be skipped and all tests should hopefully pass. For more\ndetails about how to use ts run `erl -s ts help -s init stop`\n\nCurrently Used Configuration Variables\n--------------------------------------\n\nNote that you cannot define arbitrary variables in a cross compilation\nconfiguration file. Only the ones listed below will be guaranteed to be\nvisible throughout the whole execution of all `configure` scripts. Other\nvariables needs to be defined as arguments to `configure` or exported in\nthe environment.\n\n### Variables for otp\\_build Only ###\n\nVariables in this section are only used, when configuring Erlang/OTP for\ncross compilation using `$ERL_TOP/otp_build configure`.\n\n> *NOTE*: These variables currently have *no* effect if you configure using\n> the `configure` script directly.\n\n*   `erl_xcomp_build` - The build system used. This value will be passed as\n    `--build=$erl_xcomp_build` argument to the `configure` script. It does\n    not have to be a full `CPU-VENDOR-OS` triplet, but can be. The full\n    `CPU-VENDOR-OS` triplet will be created by\n    `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_build`. If set to `guess`,\n    the build system will be guessed using\n    `$ERL_TOP/erts/autoconf/config.guess`.\n\n*   `erl_xcomp_host` - Cross host/target system to build for. This value will\n    be passed as `--host=$erl_xcomp_host` argument to the `configure` script.\n    It does not have to be a full `CPU-VENDOR-OS` triplet, but can be. The\n    full `CPU-VENDOR-OS` triplet will be created by\n    `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_host`.\n\n*   `erl_xcomp_configure_flags` - Extra configure flags to pass to the\n    `configure` script.\n\n### Cross Compiler and Other Tools ###\n\nIf the cross compilation tools are prefixed by `<HOST>-` you probably do\nnot need to set these variables (where `<HOST>` is what has been passed as\n`--host=<HOST>` argument to `configure`).\n\nAll variables in this section can also be used when native compiling.\n\n*   `CC` - C compiler.\n\n*   `CFLAGS` - C compiler flags.\n\n*   `STATIC_CFLAGS` - Static C compiler flags.\n\n*   `CFLAG_RUNTIME_LIBRARY_PATH` - This flag should set runtime library\n    search path for the shared libraries. Note that this actually is a\n    linker flag, but it needs to be passed via the compiler.\n\n*   `CPP` - C pre-processor.\n\n*   `CPPFLAGS` - C pre-processor flags.\n\n*   `CXX` - C++ compiler.\n\n*   `CXXFLAGS` - C++ compiler flags.\n\n*   `LD` - Linker.\n\n*   `LDFLAGS` - Linker flags.\n\n*   `LIBS` - Libraries.\n\n#### Dynamic Erlang Driver Linking ####\n\n> *NOTE*: Either set all or none of the `DED_LD*` variables.\n\n*   `DED_LD` - Linker for Dynamically loaded Erlang Drivers.\n\n*   `DED_LDFLAGS` - Linker flags to use with `DED_LD`.\n\n*   `DED_LD_FLAG_RUNTIME_LIBRARY_PATH` - This flag should set runtime library\n    search path for shared libraries when linking with `DED_LD`.\n\n#### Large File Support ####\n\n> *NOTE*: Either set all or none of the `LFS_*` variables.\n\n*   `LFS_CFLAGS` - Large file support C compiler flags.\n\n*   `LFS_LDFLAGS` - Large file support linker flags.\n\n*   `LFS_LIBS` - Large file support libraries.\n\n#### Other Tools ####\n\n*   `RANLIB` - `ranlib` archive index tool.\n\n*   `AR` - `ar` archiving tool.\n\n*   `GETCONF` - `getconf` system configuration inspection tool. `getconf` is\n    currently used for finding out large file support flags to use, and\n    on Linux systems for finding out if we have an NPTL thread library or\n    not.\n\n### Cross System Root Locations ###\n\n*   `erl_xcomp_sysroot` - The absolute path to the system root of the cross\n    compilation environment. Currently, the `crypto`, `odbc`, `ssh` and\n    `ssl` applications need the system root. These applications will be\n    skipped if the system root has not been set. The system root might be\n    needed for other things too. If this is the case and the system root\n    has not been set, `configure` will fail and request you to set it.\n\n*   `erl_xcomp_isysroot` - The absolute path to the system root for includes\n    of the cross compilation environment. If not set, this value defaults\n    to `$erl_xcomp_sysroot`, i.e., only set this value if the include system\n    root path is not the same as the system root path.\n\n### Optional Feature, and Bug Tests ###\n\nThese tests cannot (always) be done automatically when cross compiling. You\nusually do not need to set these variables.\n\n> *WARNING*: Setting these variables wrong may cause hard to detect\n> runtime errors. If you need to change these values, *really* make sure\n> that the values are correct.\n\n> *NOTE*: Some of these values will override results of tests performed\n> by `configure`, and some will not be used until `configure` is sure that\n> it cannot figure the result out.\n\nThe `configure` script will issue a warning when a default value is used.\nWhen a variable has been set, no warning will be issued.\n\n*   `erl_xcomp_after_morecore_hook` - `yes|no`. Defaults to `no`. If `yes`,\n    the target system must have a working `__after_morecore_hook` that can be\n    used for tracking used `malloc()` implementations core memory usage.\n    This is currently only used by unsupported features.\n\n*   `erl_xcomp_bigendian` - `yes|no`. No default. If `yes`, the target system\n    must be big endian. If `no`, little endian. This can often be\n    automatically detected, but not always. If not automatically detected,\n    `configure` will fail unless this variable is set. Since no default\n    value is used, `configure` will try to figure this out automatically.\n\t\n*   `erl_xcomp_double_middle` - `yes|no`. Defaults to `no`. \n\tIf `yes`, the target system must have doubles in \"middle-endian\" format. If\n    `no`, it has \"regular\" endianness. \t\n\n*   `erl_xcomp_clock_gettime_cpu_time` - `yes|no`. Defaults to `no`. If `yes`,\n    the target system must have a working `clock_gettime()` implementation\n    that can be used for retrieving process CPU time.\n\n*   `erl_xcomp_getaddrinfo` - `yes|no`. Defaults to `no`. If `yes`, the target\n    system must have a working `getaddrinfo()` implementation that can\n    handle both IPv4 and IPv6.\n\n*   `erl_xcomp_gethrvtime_procfs_ioctl` - `yes|no`. Defaults to `no`. If `yes`,\n    the target system must have a working `gethrvtime()` implementation and\n    is used with procfs `ioctl()`.\n\n*   `erl_xcomp_dlsym_brk_wrappers` - `yes|no`. Defaults to `no`. If `yes`, the\n    target system must have a working `dlsym(RTLD_NEXT, <S>)` implementation\n    that can be used on `brk` and `sbrk` symbols used by the `malloc()`\n    implementation in use, and by this track the `malloc()` implementations\n    core memory usage. This is currently only used by unsupported features.\n\n*   `erl_xcomp_kqueue` - `yes|no`. Defaults to `no`. If `yes`, the target\n    system must have a working `kqueue()` implementation that returns a file\n    descriptor which can be used by `poll()` and/or `select()`. If `no` and\n    the target system has not got `epoll()` or `/dev/poll`, the kernel-poll\n    feature will be disabled.\n\n*   `erl_xcomp_linux_clock_gettime_correction` - `yes|no`. Defaults to `yes` on\n    Linux; otherwise, `no`. If `yes`, `clock_gettime(CLOCK_MONOTONIC, _)` on\n    the target system must work. This variable is recommended to be set to\n    `no` on Linux systems with kernel versions less than 2.6.\n\n*   `erl_xcomp_linux_nptl` - `yes|no`. Defaults to `yes` on Linux; otherwise,\n    `no`. If `yes`, the target system must have NPTL (Native POSIX Thread\n    Library). Older Linux systems have LinuxThreads instead of NPTL (Linux\n    kernel versions typically less than 2.6).\n\n*   `erl_xcomp_linux_usable_sigaltstack` - `yes|no`. Defaults to `yes` on Linux;\n    otherwise, `no`. If `yes`, `sigaltstack()` must be usable on the target\n    system. `sigaltstack()` on Linux kernel versions less than 2.4 are\n    broken.\n\n*   `erl_xcomp_linux_usable_sigusrx` - `yes|no`. Defaults to `yes`. If `yes`,\n    the `SIGUSR1` and `SIGUSR2` signals must be usable by the ERTS. Old\n    LinuxThreads thread libraries (Linux kernel versions typically less than\n    2.2) used these signals and made them unusable by the ERTS.\n\n*   `erl_xcomp_poll` - `yes|no`. Defaults to `no` on Darwin/MacOSX; otherwise,\n    `yes`. If `yes`, the target system must have a working `poll()`\n    implementation that also can handle devices. If `no`, `select()` will be\n    used instead of `poll()`.\n\n*   `erl_xcomp_putenv_copy` - `yes|no`. Defaults to `no`. If `yes`, the target\n    system must have a `putenv()` implementation that stores a copy of the\n    key/value pair.\n\n*   `erl_xcomp_reliable_fpe` - `yes|no`. Defaults to `no`. If `yes`, the target\n    system must have reliable floating point exceptions.\n\n*   `erl_xcomp_posix_memalign` - `yes|no`. Defaults to `yes` if `posix_memalign`\n    system call exists; otherwise `no`. If `yes`, the target system must have a\n    `posix_memalign` implementation that accepts larger than page size\n    alignment.\n\n*   `erl_xcomp_code_model_small` - `yes|no`. Default to `no`. If `yes`, the target\n    system must place the beam.smp executable in the lower 2 GB of memory. That is it\n    should not use position independent executable.\n\n\n   [$ERL_TOP/HOWTO/INSTALL.md]: INSTALL.md\n   [Building in Git]: INSTALL.md#How-to-Build-and-Install-ErlangOTP\n   [How to Build the Documentation]: INSTALL.md#How-to-Build-and-Install-ErlangOTP_How-to-Build-the-Documentation\n   [cross configuration variables]: #Currently-Used-Configuration-Variables\n   [DESTDIR]: http://www.gnu.org/prep/standards/html_node/DESTDIR.html\n   [?TOC]: true\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/xcomp/erl-xcomp-avr32-atmel-linux-gnu.conf": "## -*-shell-script-*-\n##\n## %CopyrightBegin%\n##\n## Copyright Ericsson AB 2010-2012. All Rights Reserved.\n##\n## Licensed under the Apache License, Version 2.0 (the \"License\");\n## you may not use this file except in compliance with the License.\n## You may obtain a copy of the License at\n##\n##     http://www.apache.org/licenses/LICENSE-2.0\n##\n## Unless required by applicable law or agreed to in writing, software\n## distributed under the License is distributed on an \"AS IS\" BASIS,\n## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n## See the License for the specific language governing permissions and\n## limitations under the License.\n##\n## %CopyrightEnd%\n##\n## File: erl-xcomp-avr32-atmel-linux-gnu.conf\n## Author: Winston Smith <smith.winston.101@gmail.com>\n##\n## -----------------------------------------------------------------------------\n## When cross compiling Erlang/OTP using `otp_build', copy this file and set\n## the variables needed below. Then pass the path to the copy of this file as\n## an argument to `otp_build' in the configure stage:\n##   `otp_build configure --xcomp-conf=<FILE>'\n## -----------------------------------------------------------------------------\n\n## Note that you cannot define arbitrary variables in a cross compilation\n## configuration file. Only the ones listed below will be guaranteed to be\n## visible throughout the whole execution of all `configure' scripts. Other\n## variables needs to be defined as arguments to `configure' or exported in\n## the environment.\n\n## -- Variables for `otp_build' Only -------------------------------------------\n\n## Variables in this section are only used, when configuring Erlang/OTP for\n## cross compilation using `$ERL_TOP/otp_build configure'.\n\n## *NOTE*! These variables currently have *no* effect if you configure using\n## the `configure' script directly.\n\n# * `erl_xcomp_build' - The build system used. This value will be passed as\n#   `--build=$erl_xcomp_build' argument to the `configure' script. It does\n#   not have to be a full `CPU-VENDOR-OS' triplet, but can be. The full\n#   `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_build'. If set to `guess',\n#   the build system will be guessed using\n#   `$ERL_TOP/erts/autoconf/config.guess'.\nerl_xcomp_build=guess\n\n# * `erl_xcomp_host' - Cross host/target system to build for. This value will\n#   be passed as `--host=$erl_xcomp_host' argument to the `configure' script.\n#   It does not have to be a full `CPU-VENDOR-OS' triplet, but can be. The\n#   full `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_host'.\nerl_xcomp_host=avr32-atmel-linux-gnu\n\n# * `erl_xcomp_configure_flags' - Extra configure flags to pass to the\n#   `configure' script.\nerl_xcomp_configure_flags=\"--disable-hipe --disable-threads --disable-smp\"\n\n## -- Cross Compiler and Other Tools -------------------------------------------\n\n## If the cross compilation tools are prefixed by `<HOST>-' you probably do\n## not need to set these variables (where `<HOST>' is what has been passed as\n## `--host=<HOST>' argument to `configure').\n\n## All variables in this section can also be used when native compiling.\n\n# * `CC' - C compiler.\nCC=avr32-linux-gcc\n\n# * `CFLAGS' - C compiler flags.\nCFLAGS=\"-O -Dfinite=__finite\"\n\n# * `STATIC_CFLAGS' - Static C compiler flags.\n#STATIC_CFLAGS=\n\n# * `CFLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for the shared libraries. Note that this actually is a\n#   linker flag, but it needs to be passed via the compiler.\n#CFLAG_RUNTIME_LIBRARY_PATH=\n\n# * `CPP' - C pre-processor.\n#CPP=\n\n# * `CPPFLAGS' - C pre-processor flags.\n#CPPFLAGS=\n\n# * `CXX' - C++ compiler.\nCXX=avr32-linux-g++\n\n# * `CXXFLAGS' - C++ compiler flags.\n#CXXFLAGS=\n\n# * `LD' - Linker.\nLD=avr32-linux-ld\n\n# * `LDFLAGS' - Linker flags.\n#LDFLAGS=\n\n# * `LIBS' - Libraries.\n#LIBS=\n\n## -- *D*ynamic *E*rlang *D*river Linking --\n\n## *NOTE*! Either set all or none of the `DED_LD*' variables.\n\n# * `DED_LD' - Linker for Dynamically loaded Erlang Drivers.\n#DED_LD=\n\n# * `DED_LDFLAGS' - Linker flags to use with `DED_LD'.\n#DED_LDFLAGS=\n\n# * `DED_LD_FLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for shared libraries when linking with `DED_LD'.\n#DED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\n## -- Large File Support --\n\n## *NOTE*! Either set all or none of the `LFS_*' variables.\n\n# * `LFS_CFLAGS' - Large file support C compiler flags.\n#LFS_CFLAGS=\n\n# * `LFS_LDFLAGS' - Large file support linker flags.\n#LFS_LDFLAGS=\n\n# * `LFS_LIBS' - Large file support libraries.\n#LFS_LIBS=\n\n## -- Other Tools --\n\n# * `RANLIB' - `ranlib' archive index tool.\nRANLIB=avr32-linux-ranlib\n\n# * `AR' - `ar' archiving tool.\nAR=avr32-linux-ar\n\n# * `GETCONF' - `getconf' system configuration inspection tool. `getconf' is\n#   currently used for finding out large file support flags to use, and\n#   on Linux systems for finding out if we have an NPTL thread library or\n#   not.\n#GETCONF=\n\n## -- Cross System Root Locations ----------------------------------------------\n\n# * `erl_xcomp_sysroot' - The absolute path to the system root of the cross\n#   compilation environment. Currently, the `crypto', `odbc', `ssh' and\n#   `ssl' applications need the system root. These applications will be\n#   skipped if the system root has not been set. The system root might be\n#   needed for other things too. If this is the case and the system root\n#   has not been set, `configure' will fail and request you to set it.\n#\n#   NOTE: For AVR32, this should be set to the build_avr32/staging_dir\n#         subdirectory within the buildroot tree.\nerl_xcomp_sysroot=\"$ATMEL_SYSROOT_AVR32\"\n\n# * `erl_xcomp_isysroot' - The absolute path to the system root for includes\n#   of the cross compilation environment. If not set, this value defaults\n#   to `$erl_xcomp_sysroot', i.e., only set this value if the include system\n#   root path is not the same as the system root path.\n#erl_xcomp_isysroot=\n\n## -- Optional Feature, and Bug Tests ------------------------------------------\n\n## These tests cannot (always) be done automatically when cross compiling. You\n## usually do not need to set these variables. Only set these if you really\n## know what you are doing.\n\n## Note that some of these values will override results of tests performed\n## by `configure', and some will not be used until `configure' is sure that\n## it cannot figure the result out.\n\n## The `configure' script will issue a warning when a default value is used.\n## When a variable has been set, no warning will be issued.\n\n# * `erl_xcomp_after_morecore_hook' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `__after_morecore_hook' that can be\n#   used for tracking used `malloc()' implementations core memory usage.\n#   This is currently only used by unsupported features.\n#erl_xcomp_after_morecore_hook=\n\n# * `erl_xcomp_bigendian' - `yes|no'. No default. If `yes', the target system\n#   must be big endian. If `no', little endian. This can often be\n#   automatically detected, but not always. If not automatically detected,\n#   `configure' will fail unless this variable is set. Since no default\n#   value is used, `configure' will try to figure this out automatically.\n#erl_xcomp_bigendian=\n\n# * `erl_xcomp_double_middle_endian` - `yes|no`. No default. If `yes`, the\n#   target system must have doubles in \"middle-endian\" format. If\n#   `no`, it has \"regular\" endianness. This can often be automatically\n#   detected, but not always. If not automatically detected,\n#   `configure` will fail unless this variable is set. Since no\n#   default value is used, `configure` will try to figure this out\n#   automatically.\n#erl_xcomp_double_middle_endian\n\n# * `erl_xcomp_clock_gettime_cpu_time' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `clock_gettime()' implementation\n#   that can be used for retrieving process CPU time.\nerl_xcomp_clock_gettime_cpu_time=yes\n\n# * `erl_xcomp_getaddrinfo' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `getaddrinfo()' implementation that can\n#   handle both IPv4 and IPv6.\nerl_xcomp_getaddrinfo=yes\n\n# * `erl_xcomp_gethrvtime_procfs_ioctl' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `gethrvtime()' implementation and\n#   is used with procfs `ioctl()'.\n#erl_xcomp_gethrvtime_procfs_ioctl=\n\n# * `erl_xcomp_dlsym_brk_wrappers' - `yes|no'. Defaults to `no'. If `yes', the\n#   target system must have a working `dlsym(RTLD_NEXT, <S>)' implementation\n#   that can be used on `brk' and `sbrk' symbols used by the `malloc()'\n#   implementation in use, and by this track the `malloc()' implementations\n#   core memory usage. This is currently only used by unsupported features.\nerl_xcomp_dlsym_brk_wrappers=yes\n\n# * `erl_xcomp_kqueue' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `kqueue()' implementation that returns a file\n#   descriptor which can be used by `poll()' and/or `select()'. If `no' and\n#   the target system has not got `epoll()' or `/dev/poll', the kernel-poll\n#   feature will be disabled.\n#erl_xcomp_kqueue=\n\n# * `erl_xcomp_linux_clock_gettime_correction' - `yes|no'. Defaults to `yes' on\n#   Linux; otherwise, `no'. If `yes', `clock_gettime(CLOCK_MONOTONIC, _)' on\n#   the target system must work. This variable is recommended to be set to\n#   `no' on Linux systems with kernel versions less than 2.6.\n#erl_xcomp_linux_clock_gettime_correction=\n\n# * `erl_xcomp_linux_nptl' - `yes|no'. Defaults to `yes' on Linux; otherwise,\n#   `no'. If `yes', the target system must have NPTL (Native POSIX Thread\n#   Library). Older Linux systems have LinuxThreads instead of NPTL (Linux\n#   kernel versions typically less than 2.6).\n#erl_xcomp_linux_nptl=\n\n# * `erl_xcomp_linux_usable_sigaltstack' - `yes|no'. Defaults to `yes' on Linux;\n#   otherwise, `no'. If `yes', `sigaltstack()' must be usable on the target\n#   system. `sigaltstack()' on Linux kernel versions less than 2.4 are\n#   broken.\n#erl_xcomp_linux_usable_sigaltstack=\n\n# * `erl_xcomp_linux_usable_sigusrx' - `yes|no'. Defaults to `yes'. If `yes',\n#   the `SIGUSR1' and `SIGUSR2' signals must be usable by the ERTS. Old\n#   LinuxThreads thread libraries (Linux kernel versions typically less than\n#   2.2) used these signals and made them unusable by the ERTS.\n#erl_xcomp_linux_usable_sigusrx=\n\n# * `erl_xcomp_poll' - `yes|no'. Defaults to `no' on Darwin/MacOSX; otherwise,\n#   `yes'. If `yes', the target system must have a working `poll()'\n#   implementation that also can handle devices. If `no', `select()' will be\n#   used instead of `poll()'.\n#erl_xcomp_poll=\n\n# * `erl_xcomp_putenv_copy' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a `putenv()' implementation that stores a copy of the\n#   key/value pair.\n#erl_xcomp_putenv_copy=\n\n# * `erl_xcomp_reliable_fpe' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have reliable floating point exceptions.\n#erl_xcomp_reliable_fpe=\n\n## -----------------------------------------------------------------------------\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/xcomp/erl-xcomp-arm-android.conf": "## -*-shell-script-*-\n##\n## %CopyrightBegin%\n##\n## Copyright Ericsson AB 2009-2010. All Rights Reserved.\n##\n## Licensed under the Apache License, Version 2.0 (the \"License\");\n## you may not use this file except in compliance with the License.\n## You may obtain a copy of the License at\n##\n##     http://www.apache.org/licenses/LICENSE-2.0\n##\n## Unless required by applicable law or agreed to in writing, software\n## distributed under the License is distributed on an \"AS IS\" BASIS,\n## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n## See the License for the specific language governing permissions and\n## limitations under the License.\n##\n## %CopyrightEnd%\n##\n## File: erl-xcomp.conf.template\n## Author:\n##\n## -----------------------------------------------------------------------------\n## When cross compiling Erlang/OTP using `otp_build', copy this file and set\n## the variables needed below. Then pass the path to the copy of this file as\n## an argument to `otp_build' in the configure stage:\n##   `otp_build configure --xcomp-conf=<FILE>'\n## -----------------------------------------------------------------------------\n\n## Note that you cannot define arbitrary variables in a cross compilation\n## configuration file. Only the ones listed below will be guaranteed to be\n## visible throughout the whole execution of all `configure' scripts. Other\n## variables needs to be defined as arguments to `configure' or exported in\n## the environment.\n\n## -- Variables for `otp_build' Only -------------------------------------------\n\n## Variables in this section are only used, when configuring Erlang/OTP for\n## cross compilation using `$ERL_TOP/otp_build configure'.\n\n## *NOTE*! These variables currently have *no* effect if you configure using\n## the `configure' script directly.\n\n# * `erl_xcomp_build' - The build system used. This value will be passed as\n#   `--build=$erl_xcomp_build' argument to the `configure' script. It does\n#   not have to be a full `CPU-VENDOR-OS' triplet, but can be. The full\n#   `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_build'. If set to `guess',\n#   the build system will be guessed using\n#   `$ERL_TOP/erts/autoconf/config.guess'.\nerl_xcomp_build=guess\n\n# * `erl_xcomp_host' - Cross host/target system to build for. This value will\n#   be passed as `--host=$erl_xcomp_host' argument to the `configure' script.\n#   It does not have to be a full `CPU-VENDOR-OS' triplet, but can be. The\n#   full `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_host'.\nerl_xcomp_host=arm-linux-androideabi\n\n# * `erl_xcomp_configure_flags' - Extra configure flags to pass to the\n#   `configure' script.\nerl_xcomp_configure_flags=\"--disable-hipe --without-termcap\"\n\n\n## -- Cross Compiler and Other Tools -------------------------------------------\n\n##\n##\nNDK_SYSROOT=$NDK_ROOT/platforms/$NDK_PLAT/arch-arm\n\n## If the cross compilation tools are prefixed by `<HOST>-' you probably do\n## not need to set these variables (where `<HOST>' is what has been passed as\n## `--host=<HOST>' argument to `configure').\n\n## All variables in this section can also be used when native compiling.\n\n# * `CC' - C compiler.\nCC=\"arm-linux-androideabi-gcc --sysroot=$NDK_SYSROOT\"\n\n# * `CFLAGS' - C compiler flags.\nCFLAGS=\"-static -march=armv7-a -msoft-float -mthumb\"\n\n# * `STATIC_CFLAGS' - Static C compiler flags.\n#STATIC_CFLAGS=\n\n# * `CFLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for the shared libraries. Note that this actually is a\n#   linker flag, but it needs to be passed via the compiler.\n#CFLAG_RUNTIME_LIBRARY_PATH=\n\n# * `CPP' - C pre-processor.\nCPP=\"arm-linux-androideabi-cpp --sysroot=$NDK_SYSROOT\"\n\n# * `CPPFLAGS' - C pre-processor flags.\nCPPFLAGS=\"-static -march=armv7-a -msoft-float -mthumb\"\n\n# * `CXX' - C++ compiler.\nCXX=\"arm-linux-androideabi-c++ --sysroot=$NDK_SYSROOT\"\n\n# * `CXXFLAGS' - C++ compiler flags.\nCXXFLAGS=\"-static -march=armv7-a -msoft-float -mthumb\"\n\n# * `LD' - Linker.\n#LD=\n\n# * `LDFLAGS' - Linker flags.\nLDFLAGS=\"-static -march=armv7-a -msoft-float -mthumb\"\n\n# * `LIBS' - Libraries.\n#LIBS=\n\n## -- *D*ynamic *E*rlang *D*river Linking --\n\n## *NOTE*! Either set all or none of the `DED_LD*' variables.\n\n# * `DED_LD' - Linker for Dynamically loaded Erlang Drivers.\n#DED_LD=\n\n# * `DED_LDFLAGS' - Linker flags to use with `DED_LD'.\n#DED_LDFLAGS=\n\n# * `DED_LD_FLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for shared libraries when linking with `DED_LD'.\n#DED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\n## -- Large File Support --\n\n## *NOTE*! Either set all or none of the `LFS_*' variables.\n\n# * `LFS_CFLAGS' - Large file support C compiler flags.\n#LFS_CFLAGS=\n\n# * `LFS_LDFLAGS' - Large file support linker flags.\n#LFS_LDFLAGS=\n\n# * `LFS_LIBS' - Large file support libraries.\n#LFS_LIBS=\n\n## -- Other Tools --\n\n# * `RANLIB' - `ranlib' archive index tool.\n#RANLIB=\n\n# * `AR' - `ar' archiving tool.\n#AR=\n\n# * `GETCONF' - `getconf' system configuration inspection tool. `getconf' is\n#   currently used for finding out large file support flags to use, and\n#   on Linux systems for finding out if we have an NPTL thread library or\n#   not.\n#GETCONF=\n\n## -- Cross System Root Locations ----------------------------------------------\n\n# * `erl_xcomp_sysroot' - The absolute path to the system root of the cross\n#   compilation environment. Currently, the `crypto', `odbc', `ssh' and\n#   `ssl' applications need the system root. These applications will be\n#   skipped if the system root has not been set. The system root might be\n#   needed for other things too. If this is the case and the system root\n#   has not been set, `configure' will fail and request you to set it.\nerl_xcomp_sysroot=\"$NDK_SYSROOT\"\n\n\n# * `erl_xcomp_isysroot' - The absolute path to the system root for includes\n#   of the cross compilation environment. If not set, this value defaults\n#   to `$erl_xcomp_sysroot', i.e., only set this value if the include system\n#   root path is not the same as the system root path.\n#erl_xcomp_isysroot=\n\n## -- Optional Feature, and Bug Tests ------------------------------------------\n\n## These tests cannot (always) be done automatically when cross compiling. You\n## usually do not need to set these variables. Only set these if you really\n## know what you are doing.\n\n## Note that some of these values will override results of tests performed\n## by `configure', and some will not be used until `configure' is sure that\n## it cannot figure the result out.\n\n## The `configure' script will issue a warning when a default value is used.\n## When a variable has been set, no warning will be issued.\n\n# * `erl_xcomp_after_morecore_hook' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `__after_morecore_hook' that can be\n#   used for tracking used `malloc()' implementations core memory usage.\n#   This is currently only used by unsupported features.\n#erl_xcomp_after_morecore_hook=\n\n# * `erl_xcomp_bigendian' - `yes|no'. No default. If `yes', the target system\n#   must be big endian. If `no', little endian. This can often be\n#   automatically detected, but not always. If not automatically detected,\n#   `configure' will fail unless this variable is set. Since no default\n#   value is used, `configure' will try to figure this out automatically.\n#erl_xcomp_bigendian=\n\n# * `erl_xcomp_clock_gettime_cpu_time' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `clock_gettime()' implementation\n#   that can be used for retrieving process CPU time.\n#erl_xcomp_clock_gettime_cpu_time=\n\n# * `erl_xcomp_getaddrinfo' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `getaddrinfo()' implementation that can\n#   handle both IPv4 and IPv6.\n#erl_xcomp_getaddrinfo=\n\n# * `erl_xcomp_gethrvtime_procfs_ioctl' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `gethrvtime()' implementation and\n#   is used with procfs `ioctl()'.\n#erl_xcomp_gethrvtime_procfs_ioctl=\n\n# * `erl_xcomp_dlsym_brk_wrappers' - `yes|no'. Defaults to `no'. If `yes', the\n#   target system must have a working `dlsym(RTLD_NEXT, <S>)' implementation\n#   that can be used on `brk' and `sbrk' symbols used by the `malloc()'\n#   implementation in use, and by this track the `malloc()' implementations\n#   core memory usage. This is currently only used by unsupported features.\n#erl_xcomp_dlsym_brk_wrappers=\n\n# * `erl_xcomp_kqueue' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `kqueue()' implementation that returns a file\n#   descriptor which can be used by `poll()' and/or `select()'. If `no' and\n#   the target system has not got `epoll()' or `/dev/poll', the kernel-poll\n#   feature will be disabled.\n#erl_xcomp_kqueue=\n\n# * `erl_xcomp_linux_clock_gettime_correction' - `yes|no'. Defaults to `yes' on\n#   Linux; otherwise, `no'. If `yes', `clock_gettime(CLOCK_MONOTONIC, _)' on\n#   the target system must work. This variable is recommended to be set to\n#   `no' on Linux systems with kernel versions less than 2.6.\n#erl_xcomp_linux_clock_gettime_correction=\n\n# * `erl_xcomp_linux_nptl' - `yes|no'. Defaults to `yes' on Linux; otherwise,\n#   `no'. If `yes', the target system must have NPTL (Native POSIX Thread\n#   Library). Older Linux systems have LinuxThreads instead of NPTL (Linux\n#   kernel versions typically less than 2.6).\n#erl_xcomp_linux_nptl=\n\n# * `erl_xcomp_linux_usable_sigaltstack' - `yes|no'. Defaults to `yes' on Linux;\n#   otherwise, `no'. If `yes', `sigaltstack()' must be usable on the target\n#   system. `sigaltstack()' on Linux kernel versions less than 2.4 are\n#   broken.\n#erl_xcomp_linux_usable_sigaltstack=\n\n# * `erl_xcomp_linux_usable_sigusrx' - `yes|no'. Defaults to `yes'. If `yes',\n#   the `SIGUSR1' and `SIGUSR2' signals must be usable by the ERTS. Old\n#   LinuxThreads thread libraries (Linux kernel versions typically less than\n#   2.2) used these signals and made them unusable by the ERTS.\n#erl_xcomp_linux_usable_sigusrx=\n\n# * `erl_xcomp_poll' - `yes|no'. Defaults to `no' on Darwin/MacOSX; otherwise,\n#   `yes'. If `yes', the target system must have a working `poll()'\n#   implementation that also can handle devices. If `no', `select()' will be\n#   used instead of `poll()'.\n#erl_xcomp_poll=\n\n# * `erl_xcomp_putenv_copy' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a `putenv()' implementation that stores a copy of the\n#   key/value pair.\n#erl_xcomp_putenv_copy=\n\n# * `erl_xcomp_reliable_fpe' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have reliable floating point exceptions.\n#erl_xcomp_reliable_fpe=\n\n## -----------------------------------------------------------------------------\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/xcomp/erl-xcomp-mips-linux.conf": "## -*-shell-script-*-\n##\n## %CopyrightBegin%\n##\n## Copyright Ericsson AB 2010-2012. All Rights Reserved.\n##\n## Licensed under the Apache License, Version 2.0 (the \"License\");\n## you may not use this file except in compliance with the License.\n## You may obtain a copy of the License at\n##\n##     http://www.apache.org/licenses/LICENSE-2.0\n##\n## Unless required by applicable law or agreed to in writing, software\n## distributed under the License is distributed on an \"AS IS\" BASIS,\n## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n## See the License for the specific language governing permissions and\n## limitations under the License.\n##\n## %CopyrightEnd%\n##\n## File: erl-xcomp-mips-linux.conf\n## Author: Matthias Lang\n##\n## -----------------------------------------------------------------------------\n## When cross compiling Erlang/OTP using `otp_build', copy this file and set\n## the variables needed below. Then pass the path to the copy of this file as\n## an argument to `otp_build' in the configure stage:\n##   `otp_build configure --xcomp-conf=<FILE>'\n## -----------------------------------------------------------------------------\n\n## Note that you cannot define arbitrary variables in a cross compilation\n## configuration file. Only the ones listed below will be guaranteed to be\n## visible throughout the whole execution of all `configure' scripts. Other\n## variables needs to be defined as arguments to `configure' or exported in\n## the environment.\n\n## -- Variables for `otp_build' Only -------------------------------------------\n\n## Variables in this section are only used, when configuring Erlang/OTP for\n## cross compilation using `$ERL_TOP/otp_build configure'.\n\n## *NOTE*! These variables currently have *no* effect if you configure using\n## the `configure' script directly.\n\n# * `erl_xcomp_build' - The build system used. This value will be passed as\n#   `--build=$erl_xcomp_build' argument to the `configure' script. It does\n#   not have to be a full `CPU-VENDOR-OS' triplet, but can be. The full\n#   `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_build'. If set to `guess',\n#   the build system will be guessed using\n#   `$ERL_TOP/erts/autoconf/config.guess'.\nerl_xcomp_build=guess\n\n# * `erl_xcomp_host' - Cross host/target system to build for. This value will\n#   be passed as `--host=$erl_xcomp_host' argument to the `configure' script.\n#   It does not have to be a full `CPU-VENDOR-OS' triplet, but can be. The\n#   full `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_host'.\nerl_xcomp_host=mips-linux\n\n# * `erl_xcomp_configure_flags' - Extra configure flags to pass to the\n#   `configure' script.\n#erl_xcomp_configure_flags=\n\n## -- Cross Compiler and Other Tools -------------------------------------------\n\n## If the cross compilation tools are prefixed by `<HOST>-' you probably do\n## not need to set these variables (where `<HOST>' is what has been passed as\n## `--host=<HOST>' argument to `configure').\n\n## All variables in this section can also be used when native compiling.\n\n# * `CC' - C compiler.\n#CC=\n\n# * `CFLAGS' - C compiler flags.\nCFLAGS=-Os\n\n# * `STATIC_CFLAGS' - Static C compiler flags.\n#STATIC_CFLAGS=\n\n# * `CFLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for the shared libraries. Note that this actually is a\n#   linker flag, but it needs to be passed via the compiler.\n#CFLAG_RUNTIME_LIBRARY_PATH=\n\n# * `CPP' - C pre-processor.\n#CPP=\n\n# * `CPPFLAGS' - C pre-processor flags.\n#CPPFLAGS=\n\n# * `CXX' - C++ compiler.\n#CXX=\n\n# * `CXXFLAGS' - C++ compiler flags.\n#CXXFLAGS=\n\n# * `LD' - Linker.\n#LD=\n\n# * `LDFLAGS' - Linker flags.\n#LDFLAGS=\n\n# * `LIBS' - Libraries.\n#LIBS=\n\n## -- *D*ynamic *E*rlang *D*river Linking --\n\n## *NOTE*! Either set all or none of the `DED_LD*' variables.\n\n# * `DED_LD' - Linker for Dynamically loaded Erlang Drivers.\n#DED_LD=\n\n# * `DED_LDFLAGS' - Linker flags to use with `DED_LD'.\n#DED_LDFLAGS=\n\n# * `DED_LD_FLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for shared libraries when linking with `DED_LD'.\n#DED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\n## -- Large File Support --\n\n## *NOTE*! Either set all or none of the `LFS_*' variables.\n\n# * `LFS_CFLAGS' - Large file support C compiler flags.\n#LFS_CFLAGS=\n\n# * `LFS_LDFLAGS' - Large file support linker flags.\n#LFS_LDFLAGS=\n\n# * `LFS_LIBS' - Large file support libraries.\n#LFS_LIBS=\n\n## -- Other Tools --\n\n# * `RANLIB' - `ranlib' archive index tool.\n#RANLIB=\n\n# * `AR' - `ar' archiving tool.\n#AR=\n\n# * `GETCONF' - `getconf' system configuration inspection tool. `getconf' is\n#   currently used for finding out large file support flags to use, and\n#   on Linux systems for finding out if we have an NPTL thread library or\n#   not.\n#GETCONF=\n\n## -- Cross System Root Locations ----------------------------------------------\n\n# * `erl_xcomp_sysroot' - The absolute path to the system root of the cross\n#   compilation environment. Currently, the `crypto', `odbc', `ssh' and\n#   `ssl' applications need the system root. These applications will be\n#   skipped if the system root has not been set. The system root might be\n#   needed for other things too. If this is the case and the system root\n#   has not been set, `configure' will fail and request you to set it.\n#erl_xcomp_sysroot=\n\n# * `erl_xcomp_isysroot' - The absolute path to the system root for includes\n#   of the cross compilation environment. If not set, this value defaults\n#   to `$erl_xcomp_sysroot', i.e., only set this value if the include system\n#   root path is not the same as the system root path.\n#erl_xcomp_isysroot=\n\n## -- Optional Feature, and Bug Tests ------------------------------------------\n\n## These tests cannot (always) be done automatically when cross compiling. You\n## usually do not need to set these variables. Only set these if you really\n## know what you are doing.\n\n## Note that some of these values will override results of tests performed\n## by `configure', and some will not be used until `configure' is sure that\n## it cannot figure the result out.\n\n## The `configure' script will issue a warning when a default value is used.\n## When a variable has been set, no warning will be issued.\n\n# * `erl_xcomp_after_morecore_hook' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `__after_morecore_hook' that can be\n#   used for tracking used `malloc()' implementations core memory usage.\n#   This is currently only used by unsupported features.\n#erl_xcomp_after_morecore_hook=\n\n# * `erl_xcomp_bigendian' - `yes|no'. No default. If `yes', the target system\n#   must be big endian. If `no', little endian. This can often be\n#   automatically detected, but not always. If not automatically detected,\n#   `configure' will fail unless this variable is set. Since no default\n#   value is used, `configure' will try to figure this out automatically.\n#erl_xcomp_bigendian=\n\n# * `erl_xcomp_double_middle_endian` - `yes|no`. No default. If `yes`, the\n#   target system must have doubles in \"middle-endian\" format. If\n#   `no`, it has \"regular\" endianness. This can often be automatically\n#   detected, but not always. If not automatically detected,\n#   `configure` will fail unless this variable is set. Since no\n#   default value is used, `configure` will try to figure this out\n#   automatically.\n#erl_xcomp_double_middle_endian\n\n# * `erl_xcomp_clock_gettime_cpu_time' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `clock_gettime()' implementation\n#   that can be used for retrieving process CPU time.\n#erl_xcomp_clock_gettime_cpu_time=\n\n# * `erl_xcomp_getaddrinfo' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `getaddrinfo()' implementation that can\n#   handle both IPv4 and IPv6.\n#erl_xcomp_getaddrinfo=\n\n# * `erl_xcomp_gethrvtime_procfs_ioctl' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `gethrvtime()' implementation and\n#   is used with procfs `ioctl()'.\n#erl_xcomp_gethrvtime_procfs_ioctl=\n\n# * `erl_xcomp_dlsym_brk_wrappers' - `yes|no'. Defaults to `no'. If `yes', the\n#   target system must have a working `dlsym(RTLD_NEXT, <S>)' implementation\n#   that can be used on `brk' and `sbrk' symbols used by the `malloc()'\n#   implementation in use, and by this track the `malloc()' implementations\n#   core memory usage. This is currently only used by unsupported features.\n#erl_xcomp_dlsym_brk_wrappers=\n\n# * `erl_xcomp_kqueue' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `kqueue()' implementation that returns a file\n#   descriptor which can be used by `poll()' and/or `select()'. If `no' and\n#   the target system has not got `epoll()' or `/dev/poll', the kernel-poll\n#   feature will be disabled.\n#erl_xcomp_kqueue=\n\n# * `erl_xcomp_linux_clock_gettime_correction' - `yes|no'. Defaults to `yes' on\n#   Linux; otherwise, `no'. If `yes', `clock_gettime(CLOCK_MONOTONIC, _)' on\n#   the target system must work. This variable is recommended to be set to\n#   `no' on Linux systems with kernel versions less than 2.6.\n#erl_xcomp_linux_clock_gettime_correction=\n\n# * `erl_xcomp_linux_nptl' - `yes|no'. Defaults to `yes' on Linux; otherwise,\n#   `no'. If `yes', the target system must have NPTL (Native POSIX Thread\n#   Library). Older Linux systems have LinuxThreads instead of NPTL (Linux\n#   kernel versions typically less than 2.6).\n#erl_xcomp_linux_nptl=\n\n# * `erl_xcomp_linux_usable_sigaltstack' - `yes|no'. Defaults to `yes' on Linux;\n#   otherwise, `no'. If `yes', `sigaltstack()' must be usable on the target\n#   system. `sigaltstack()' on Linux kernel versions less than 2.4 are\n#   broken.\n#erl_xcomp_linux_usable_sigaltstack=\n\n# * `erl_xcomp_linux_usable_sigusrx' - `yes|no'. Defaults to `yes'. If `yes',\n#   the `SIGUSR1' and `SIGUSR2' signals must be usable by the ERTS. Old\n#   LinuxThreads thread libraries (Linux kernel versions typically less than\n#   2.2) used these signals and made them unusable by the ERTS.\n#erl_xcomp_linux_usable_sigusrx=\n\n# * `erl_xcomp_poll' - `yes|no'. Defaults to `no' on Darwin/MacOSX; otherwise,\n#   `yes'. If `yes', the target system must have a working `poll()'\n#   implementation that also can handle devices. If `no', `select()' will be\n#   used instead of `poll()'.\n#erl_xcomp_poll=\n\n# * `erl_xcomp_putenv_copy' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a `putenv()' implementation that stores a copy of the\n#   key/value pair.\n#erl_xcomp_putenv_copy=\n\n# * `erl_xcomp_reliable_fpe' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have reliable floating point exceptions.\n#erl_xcomp_reliable_fpe=\n\n## -----------------------------------------------------------------------------\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/xcomp/erl-xcomp-arm-linux.conf": "## -*-shell-script-*-\n##\n## %CopyrightBegin%\n##\n## Copyright Ericsson AB 2009-2010. All Rights Reserved.\n##\n## Licensed under the Apache License, Version 2.0 (the \"License\");\n## you may not use this file except in compliance with the License.\n## You may obtain a copy of the License at\n##\n##     http://www.apache.org/licenses/LICENSE-2.0\n##\n## Unless required by applicable law or agreed to in writing, software\n## distributed under the License is distributed on an \"AS IS\" BASIS,\n## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n## See the License for the specific language governing permissions and\n## limitations under the License.\n##\n## %CopyrightEnd%\n##\n## File: erl-xcomp.conf.template\n## Author:\n##\n## -----------------------------------------------------------------------------\n## When cross compiling Erlang/OTP using `otp_build', copy this file and set\n## the variables needed below. Then pass the path to the copy of this file as\n## an argument to `otp_build' in the configure stage:\n##   `otp_build configure --xcomp-conf=<FILE>'\n## -----------------------------------------------------------------------------\n\n## Note that you cannot define arbitrary variables in a cross compilation\n## configuration file. Only the ones listed below will be guaranteed to be\n## visible throughout the whole execution of all `configure' scripts. Other\n## variables needs to be defined as arguments to `configure' or exported in\n## the environment.\n\n## -- Variables for `otp_build' Only -------------------------------------------\n\n## Variables in this section are only used, when configuring Erlang/OTP for\n## cross compilation using `$ERL_TOP/otp_build configure'.\n\n## *NOTE*! These variables currently have *no* effect if you configure using\n## the `configure' script directly.\n\n# * `erl_xcomp_build' - The build system used. This value will be passed as\n#   `--build=$erl_xcomp_build' argument to the `configure' script. It does\n#   not have to be a full `CPU-VENDOR-OS' triplet, but can be. The full\n#   `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_build'. If set to `guess',\n#   the build system will be guessed using\n#   `$ERL_TOP/erts/autoconf/config.guess'.\nerl_xcomp_build=guess\n\n# * `erl_xcomp_host' - Cross host/target system to build for. This value will\n#   be passed as `--host=$erl_xcomp_host' argument to the `configure' script.\n#   It does not have to be a full `CPU-VENDOR-OS' triplet, but can be. The\n#   full `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_host'.\nerl_xcomp_host=arm-wrs-linux-gnueabi\n\n# * `erl_xcomp_configure_flags' - Extra configure flags to pass to the\n#   `configure' script.\nerl_xcomp_configure_flags=\"--disable-hipe\"\n\n\n## -- Cross Compiler and Other Tools -------------------------------------------\n\n## If the cross compilation tools are prefixed by `<HOST>-' you probably do\n## not need to set these variables (where `<HOST>' is what has been passed as\n## `--host=<HOST>' argument to `configure').\n\n## All variables in this section can also be used when native compiling.\n\n# * `CC' - C compiler.\nCC=\"arm-wrs-linux-gnueabi-gcc --sysroot=$ARM_SYSROOT\"\n\n# * `CFLAGS' - C compiler flags.\nCFLAGS=\"-O2 -DSMALL_MEMORY --sysroot=$ARM_SYSROOT -Wall -g\"\n\n# * `STATIC_CFLAGS' - Static C compiler flags.\n#STATIC_CFLAGS=\n\n# * `CFLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for the shared libraries. Note that this actually is a\n#   linker flag, but it needs to be passed via the compiler.\n#CFLAG_RUNTIME_LIBRARY_PATH=\n\n# * `CPP' - C pre-processor.\nCPP=\"arm-wrs-linux-gnueabi-cpp --sysroot=$ARM_SYSROOT\"\n\n# * `CPPFLAGS' - C pre-processor flags.\nCPPFLAGS=\"--sysroot=$ARM_SYSROOT\"\n\n# * `CXX' - C++ compiler.\nCXX=\"arm-wrs-linux-gnueabi-c++ --sysroot=$ARM_SYSROOT\"\n\n# * `CXXFLAGS' - C++ compiler flags.\nCXXFLAGS=\"--sysroot=$ARM_SYSROOT\"\n\n# * `LD' - Linker.\nLD=\"arm-wrs-linux-gnueabi-gcc\"\n\n# * `LDFLAGS' - Linker flags.\nLDFLAGS=\"--sysroot=$ARM_SYSROOT\"\n\n# * `LIBS' - Libraries.\n#LIBS=\n\n## -- *D*ynamic *E*rlang *D*river Linking --\n\n## *NOTE*! Either set all or none of the `DED_LD*' variables.\n\n# * `DED_LD' - Linker for Dynamically loaded Erlang Drivers.\nDED_LD=\"arm-wrs-linux-gnueabi-gcc\"\n\n# * `DED_LDFLAGS' - Linker flags to use with `DED_LD'.\nDED_LDFLAGS=\"--sysroot=$ARM_SYSROOT -shared -Wl,-Bsymbolic\"\n\n# * `DED_LD_FLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for shared libraries when linking with `DED_LD'.\nDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-R\"\n\n## -- Large File Support --\n\n## *NOTE*! Either set all or none of the `LFS_*' variables.\n\n# * `LFS_CFLAGS' - Large file support C compiler flags.\n#LFS_CFLAGS=\n\n# * `LFS_LDFLAGS' - Large file support linker flags.\n#LFS_LDFLAGS=\n\n# * `LFS_LIBS' - Large file support libraries.\n#LFS_LIBS=\n\n## -- Other Tools --\n\n# * `RANLIB' - `ranlib' archive index tool.\n#RANLIB=\n\n# * `AR' - `ar' archiving tool.\n#AR=\n\n# * `GETCONF' - `getconf' system configuration inspection tool. `getconf' is\n#   currently used for finding out large file support flags to use, and\n#   on Linux systems for finding out if we have an NPTL thread library or\n#   not.\n#GETCONF=\n\n## -- Cross System Root Locations ----------------------------------------------\n\n# * `erl_xcomp_sysroot' - The absolute path to the system root of the cross\n#   compilation environment. Currently, the `crypto', `odbc', `ssh' and\n#   `ssl' applications need the system root. These applications will be\n#   skipped if the system root has not been set. The system root might be\n#   needed for other things too. If this is the case and the system root\n#   has not been set, `configure' will fail and request you to set it.\nerl_xcomp_sysroot=\"$ARM_SYSROOT\"\n\n\n# * `erl_xcomp_isysroot' - The absolute path to the system root for includes\n#   of the cross compilation environment. If not set, this value defaults\n#   to `$erl_xcomp_sysroot', i.e., only set this value if the include system\n#   root path is not the same as the system root path.\n#erl_xcomp_isysroot=\n\n## -- Optional Feature, and Bug Tests ------------------------------------------\n\n## These tests cannot (always) be done automatically when cross compiling. You\n## usually do not need to set these variables. Only set these if you really\n## know what you are doing.\n\n## Note that some of these values will override results of tests performed\n## by `configure', and some will not be used until `configure' is sure that\n## it cannot figure the result out.\n\n## The `configure' script will issue a warning when a default value is used.\n## When a variable has been set, no warning will be issued.\n\n# * `erl_xcomp_after_morecore_hook' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `__after_morecore_hook' that can be\n#   used for tracking used `malloc()' implementations core memory usage.\n#   This is currently only used by unsupported features.\n#erl_xcomp_after_morecore_hook=\n\n# * `erl_xcomp_bigendian' - `yes|no'. No default. If `yes', the target system\n#   must be big endian. If `no', little endian. This can often be\n#   automatically detected, but not always. If not automatically detected,\n#   `configure' will fail unless this variable is set. Since no default\n#   value is used, `configure' will try to figure this out automatically.\n#erl_xcomp_bigendian=\n\n# * `erl_xcomp_clock_gettime_cpu_time' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `clock_gettime()' implementation\n#   that can be used for retrieving process CPU time.\n#erl_xcomp_clock_gettime_cpu_time=\n\n# * `erl_xcomp_getaddrinfo' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `getaddrinfo()' implementation that can\n#   handle both IPv4 and IPv6.\n#erl_xcomp_getaddrinfo=\n\n# * `erl_xcomp_gethrvtime_procfs_ioctl' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `gethrvtime()' implementation and\n#   is used with procfs `ioctl()'.\n#erl_xcomp_gethrvtime_procfs_ioctl=\n\n# * `erl_xcomp_dlsym_brk_wrappers' - `yes|no'. Defaults to `no'. If `yes', the\n#   target system must have a working `dlsym(RTLD_NEXT, <S>)' implementation\n#   that can be used on `brk' and `sbrk' symbols used by the `malloc()'\n#   implementation in use, and by this track the `malloc()' implementations\n#   core memory usage. This is currently only used by unsupported features.\n#erl_xcomp_dlsym_brk_wrappers=\n\n# * `erl_xcomp_kqueue' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `kqueue()' implementation that returns a file\n#   descriptor which can be used by `poll()' and/or `select()'. If `no' and\n#   the target system has not got `epoll()' or `/dev/poll', the kernel-poll\n#   feature will be disabled.\n#erl_xcomp_kqueue=\n\n# * `erl_xcomp_linux_clock_gettime_correction' - `yes|no'. Defaults to `yes' on\n#   Linux; otherwise, `no'. If `yes', `clock_gettime(CLOCK_MONOTONIC, _)' on\n#   the target system must work. This variable is recommended to be set to\n#   `no' on Linux systems with kernel versions less than 2.6.\n#erl_xcomp_linux_clock_gettime_correction=\n\n# * `erl_xcomp_linux_nptl' - `yes|no'. Defaults to `yes' on Linux; otherwise,\n#   `no'. If `yes', the target system must have NPTL (Native POSIX Thread\n#   Library). Older Linux systems have LinuxThreads instead of NPTL (Linux\n#   kernel versions typically less than 2.6).\n#erl_xcomp_linux_nptl=\n\n# * `erl_xcomp_linux_usable_sigaltstack' - `yes|no'. Defaults to `yes' on Linux;\n#   otherwise, `no'. If `yes', `sigaltstack()' must be usable on the target\n#   system. `sigaltstack()' on Linux kernel versions less than 2.4 are\n#   broken.\n#erl_xcomp_linux_usable_sigaltstack=\n\n# * `erl_xcomp_linux_usable_sigusrx' - `yes|no'. Defaults to `yes'. If `yes',\n#   the `SIGUSR1' and `SIGUSR2' signals must be usable by the ERTS. Old\n#   LinuxThreads thread libraries (Linux kernel versions typically less than\n#   2.2) used these signals and made them unusable by the ERTS.\n#erl_xcomp_linux_usable_sigusrx=\n\n# * `erl_xcomp_poll' - `yes|no'. Defaults to `no' on Darwin/MacOSX; otherwise,\n#   `yes'. If `yes', the target system must have a working `poll()'\n#   implementation that also can handle devices. If `no', `select()' will be\n#   used instead of `poll()'.\n#erl_xcomp_poll=\n\n# * `erl_xcomp_putenv_copy' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a `putenv()' implementation that stores a copy of the\n#   key/value pair.\n#erl_xcomp_putenv_copy=\n\n# * `erl_xcomp_reliable_fpe' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have reliable floating point exceptions.\n#erl_xcomp_reliable_fpe=\n\n## -----------------------------------------------------------------------------\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/xcomp/erl-xcomp-powerpc-dso-linux-gnu.conf": "## -*-shell-script-*-\n##\n## %CopyrightBegin%\n##\n## Copyright Ericsson AB 2009-2012. All Rights Reserved.\n##\n## Licensed under the Apache License, Version 2.0 (the \"License\");\n## you may not use this file except in compliance with the License.\n## You may obtain a copy of the License at\n##\n##     http://www.apache.org/licenses/LICENSE-2.0\n##\n## Unless required by applicable law or agreed to in writing, software\n## distributed under the License is distributed on an \"AS IS\" BASIS,\n## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n## See the License for the specific language governing permissions and\n## limitations under the License.\n##\n## %CopyrightEnd%\n##\n## File: erl-xcomp.conf.template\n## Author: Rickard Green\n##\n## -----------------------------------------------------------------------------\n## When cross compiling Erlang/OTP using `otp_build', copy this file and set\n## the variables needed below. Then pass the path to the copy of this file as\n## an argument to `otp_build' in the configure stage:\n##   `otp_build configure --xcomp-conf=<FILE>'\n## -----------------------------------------------------------------------------\n\n## Note that you cannot define arbitrary variables in a cross compilation\n## configuration file. Only the ones listed below will be guaranteed to be\n## visible throughout the whole execution of all `configure' scripts. Other\n## variables needs to be defined as arguments to `configure' or exported in\n## the environment.\n\n## -- Variables for `otp_build' Only -------------------------------------------\n\n## Variables in this section are only used, when configuring Erlang/OTP for\n## cross compilation using `$ERL_TOP/otp_build configure'.\n\n## *NOTE*! These variables currently have *no* effect if you configure using\n## the `configure' script directly.\n\n# * `erl_xcomp_build' - The build system used. This value will be passed as\n#   `--build=$erl_xcomp_build' argument to the `configure' script. It does\n#   not have to be a full `CPU-VENDOR-OS' triplet, but can be. The full\n#   `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_build'. If set to `guess',\n#   the build system will be guessed using\n#   `$ERL_TOP/erts/autoconf/config.guess'.\nerl_xcomp_build=guess\n\n# * `erl_xcomp_host' - Cross host/target system to build for. This value will\n#   be passed as `--host=$erl_xcomp_host' argument to the `configure' script.\n#   It does not have to be a full `CPU-VENDOR-OS' triplet, but can be. The\n#   full `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_host'.\nerl_xcomp_host=powerpc-wrs-linux-gnu\n\n# * `erl_xcomp_configure_flags' - Extra configure flags to pass to the\n#   `configure' script.\nerl_xcomp_configure_flags=\"--without-termcap\"\n\n## -- Cross Compiler and Other Tools -------------------------------------------\n\n## If the cross compilation tools are prefixed by `<HOST>-' you probably do\n## not need to set these variables (where `<HOST>' is what has been passed as\n## `--host=<HOST>' argument to `configure').\n\n## All variables in this section can also be used when native compiling.\n\n# * `CC' - C compiler.\nCC=powerpc-wrs-linux-gnu-gcc\n\n# * `CFLAGS' - C compiler flags.\nCFLAGS=\"-O2 --sysroot=/ldisk/cross/gcc-toolchain/sysroot -Wall -g\"\n\n# * `STATIC_CFLAGS' - Static C compiler flags.\n#STATIC_CFLAGS=\n\n# * `CFLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for the shared libraries. Note that this actually is a\n#   linker flag, but it needs to be passed via the compiler.\n#CFLAG_RUNTIME_LIBRARY_PATH=\n\n# * `CPP' - C pre-processor.\nCPP=\"powerpc-wrs-linux-gnu-cpp \"\n\n# * `CPPFLAGS' - C pre-processor flags.\nCPPFLAGS=\"--sysroot=/ldisk/cross/gcc-toolchain/sysroot\"\n\n# * `CXX' - C++ compiler.\nCXX=\"powerpc-wrs-linux-gnu-g++\"\n\n# * `CXXFLAGS' - C++ compiler flags.\nCXXFLAGS=\"--sysroot=/ldisk/cross/gcc-toolchain/sysroot\"\n\n# * `LD' - Linker.\nLD=\"powerpc-wrs-linux-gnu-gcc\"\n\n# * `LDFLAGS' - Linker flags.\nLDFLAGS=\"--sysroot=/ldisk/cross/gcc-toolchain/sysroot\"\n\n# * `LIBS' - Libraries.\n#LIBS=\n\n## -- *D*ynamic *E*rlang *D*river Linking --\n\n## *NOTE*! Either set all or none of the `DED_LD*' variables.\n\n# * `DED_LD' - Linker for Dynamically loaded Erlang Drivers.\nDED_LD=\"powerpc-wrs-linux-gnu-gcc\"\n\n# * `DED_LDFLAGS' - Linker flags to use with `DED_LD'.\nDED_LDFLAGS=\"--sysroot=/ldisk/cross/gcc-toolchain/sysroot -shared -Wl,-Bsymbolic\"\n\n# * `DED_LD_FLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for shared libraries when linking with `DED_LD'.\nDED_LD_FLAG_RUNTIME_LIBRARY_PATH=\"-Wl,-R\"\n\n## -- Large File Support --\n\n## *NOTE*! Either set all or none of the `LFS_*' variables.\n\n# * `LFS_CFLAGS' - Large file support C compiler flags.\n#LFS_CFLAGS=\n\n# * `LFS_LDFLAGS' - Large file support linker flags.\n#LFS_LDFLAGS=\n\n# * `LFS_LIBS' - Large file support libraries.\n#LFS_LIBS=\n\n## -- Other Tools --\n\n# * `RANLIB' - `ranlib' archive index tool.\nRANLIB=powerpc-wrs-linux-gnu-ranlib\n\n# * `AR' - `ar' archiving tool.\nAR=powerpc-wrs-linux-gnu-ar\n\n# * `GETCONF' - `getconf' system configuration inspection tool. `getconf' is\n#   currently used for finding out large file support flags to use, and\n#   on Linux systems for finding out if we have an NPTL thread library or\n#   not.\n#GETCONF=\n\n## -- Cross System Root Locations ----------------------------------------------\n\n# * `erl_xcomp_sysroot' - The absolute path to the system root of the cross\n#   compilation environment. Currently, the `crypto', `odbc', `ssh' and\n#   `ssl' applications need the system root. These applications will be\n#   skipped if the system root has not been set. The system root might be\n#   needed for other things too. If this is the case and the system root\n#   has not been set, `configure' will fail and request you to set it.\nerl_xcomp_sysroot=\"$DSO_SYSROOT_POWERPC\"\n\n# * `erl_xcomp_isysroot' - The absolute path to the system root for includes\n#   of the cross compilation environment. If not set, this value defaults\n#   to `$erl_xcomp_sysroot', i.e., only set this value if the include system\n#   root path is not the same as the system root path.\n#erl_xcomp_isysroot=\n\n## -- Optional Feature, and Bug Tests ------------------------------------------\n\n## These tests cannot (always) be done automatically when cross compiling. You\n## usually do not need to set these variables. Only set these if you really\n## know what you are doing.\n\n## Note that some of these values will override results of tests performed\n## by `configure', and some will not be used until `configure' is sure that\n## it cannot figure the result out.\n\n## The `configure' script will issue a warning when a default value is used.\n## When a variable has been set, no warning will be issued.\n\n# * `erl_xcomp_after_morecore_hook' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `__after_morecore_hook' that can be\n#   used for tracking used `malloc()' implementations core memory usage.\n#   This is currently only used by unsupported features.\n#erl_xcomp_after_morecore_hook=\n\n# * `erl_xcomp_bigendian' - `yes|no'. No default. If `yes', the target system\n#   must be big endian. If `no', little endian. This can often be\n#   automatically detected, but not always. If not automatically detected,\n#   `configure' will fail unless this variable is set. Since no default\n#   value is used, `configure' will try to figure this out automatically.\n#erl_xcomp_bigendian=\n\n# * `erl_xcomp_clock_gettime_cpu_time' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `clock_gettime()' implementation\n#   that can be used for retrieving process CPU time.\n#erl_xcomp_clock_gettime_cpu_time=\n\n# * `erl_xcomp_getaddrinfo' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `getaddrinfo()' implementation that can\n#   handle both IPv4 and IPv6.\nerl_xcomp_getaddrinfo=yes\n\n# * `erl_xcomp_gethrvtime_procfs_ioctl' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `gethrvtime()' implementation and\n#   is used with procfs `ioctl()'.\n#erl_xcomp_gethrvtime_procfs_ioctl=\n\n# * `erl_xcomp_dlsym_brk_wrappers' - `yes|no'. Defaults to `no'. If `yes', the\n#   target system must have a working `dlsym(RTLD_NEXT, <S>)' implementation\n#   that can be used on `brk' and `sbrk' symbols used by the `malloc()'\n#   implementation in use, and by this track the `malloc()' implementations\n#   core memory usage. This is currently only used by unsupported features.\n#erl_xcomp_dlsym_brk_wrappers=\n\n# * `erl_xcomp_kqueue' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `kqueue()' implementation that returns a file\n#   descriptor which can be used by `poll()' and/or `select()'. If `no' and\n#   the target system has not got `epoll()' or `/dev/poll', the kernel-poll\n#   feature will be disabled.\n#erl_xcomp_kqueue=\n\n# * `erl_xcomp_linux_clock_gettime_correction' - `yes|no'. Defaults to `yes' on\n#   Linux; otherwise, `no'. If `yes', `clock_gettime(CLOCK_MONOTONIC, _)' on\n#   the target system must work. This variable is recommended to be set to\n#   `no' on Linux systems with kernel versions less than 2.6.\n#erl_xcomp_linux_clock_gettime_correction=\n\n# * `erl_xcomp_linux_nptl' - `yes|no'. Defaults to `yes' on Linux; otherwise,\n#   `no'. If `yes', the target system must have NPTL (Native POSIX Thread\n#   Library). Older Linux systems have LinuxThreads instead of NPTL (Linux\n#   kernel versions typically less than 2.6).\n#erl_xcomp_linux_nptl=\n\n# * `erl_xcomp_linux_usable_sigaltstack' - `yes|no'. Defaults to `yes' on Linux;\n#   otherwise, `no'. If `yes', `sigaltstack()' must be usable on the target\n#   system. `sigaltstack()' on Linux kernel versions less than 2.4 are\n#   broken.\n#erl_xcomp_linux_usable_sigaltstack=\n\n# * `erl_xcomp_linux_usable_sigusrx' - `yes|no'. Defaults to `yes'. If `yes',\n#   the `SIGUSR1' and `SIGUSR2' signals must be usable by the ERTS. Old\n#   LinuxThreads thread libraries (Linux kernel versions typically less than\n#   2.2) used these signals and made them unusable by the ERTS.\n#erl_xcomp_linux_usable_sigusrx=\n\n# * `erl_xcomp_poll' - `yes|no'. Defaults to `no' on Darwin/MacOSX; otherwise,\n#   `yes'. If `yes', the target system must have a working `poll()'\n#   implementation that also can handle devices. If `no', `select()' will be\n#   used instead of `poll()'.\n#erl_xcomp_poll=\n\n# * `erl_xcomp_putenv_copy' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a `putenv()' implementation that stores a copy of the\n#   key/value pair.\n#erl_xcomp_putenv_copy=\n\n# * `erl_xcomp_reliable_fpe' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have reliable floating point exceptions.\n#erl_xcomp_reliable_fpe=\n\n## -----------------------------------------------------------------------------\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/xcomp/erl-xcomp-armv8-rpi3-linux-gnueabihf.conf": "## -*-shell-script-*-\n##\n## %CopyrightBegin%\n##\n## Copyright Ericsson AB 2009-2018. All Rights Reserved.\n##\n## Licensed under the Apache License, Version 2.0 (the \"License\");\n## you may not use this file except in compliance with the License.\n## You may obtain a copy of the License at\n##\n##     http://www.apache.org/licenses/LICENSE-2.0\n##\n## Unless required by applicable law or agreed to in writing, software\n## distributed under the License is distributed on an \"AS IS\" BASIS,\n## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n## See the License for the specific language governing permissions and\n## limitations under the License.\n##\n## %CopyrightEnd%\n##\n## File: erl-xcomp-armv8-rpi3-linux-gnueabihf.conf\n## Author: P\u00e9ter Dimitrov\n## Tested: macOS High Sierra 10.13.2 /\n##         Raspberry Pi 3 Model B Rev 1.2\n##\n## -----------------------------------------------------------------------------\n## When cross compiling Erlang/OTP using `otp_build', copy this file and set\n## the variables needed below. Then pass the path to the copy of this file as\n## an argument to `otp_build' in the configure stage:\n##   `otp_build configure --xcomp-conf=<FILE>'\n## -----------------------------------------------------------------------------\n\n## Note that you cannot define arbitrary variables in a cross compilation\n## configuration file. Only the ones listed below will be guaranteed to be\n## visible throughout the whole execution of all `configure' scripts. Other\n## variables needs to be defined as arguments to `configure' or exported in\n## the environment.\n\n## -- Variables for `otp_build' Only -------------------------------------------\n\n## Variables in this section are only used, when configuring Erlang/OTP for\n## cross compilation using `$ERL_TOP/otp_build configure'.\n\n## *NOTE*! These variables currently have *no* effect if you configure using\n## the `configure' script directly.\n\n# * `erl_xcomp_build' - The build system used. This value will be passed as\n#   `--build=$erl_xcomp_build' argument to the `configure' script. It does\n#   not have to be a full `CPU-VENDOR-OS' triplet, but can be. The full\n#   `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_build'. If set to `guess',\n#   the build system will be guessed using\n#   `$ERL_TOP/erts/autoconf/config.guess'.\nerl_xcomp_build=guess\n\n# * `erl_xcomp_host' - Cross host/target system to build for. This value will\n#   be passed as `--host=$erl_xcomp_host' argument to the `configure' script.\n#   It does not have to be a full `CPU-VENDOR-OS' triplet, but can be. The\n#   full `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_host'.\nerl_xcomp_host=armv8-rpi3-linux-gnueabihf\n\n# * `erl_xcomp_configure_flags' - Extra configure flags to pass to the\n#   `configure' script.\n#erl_xcomp_configure_flags=\n\n## -- Cross Compiler and Other Tools -------------------------------------------\n\n## If the cross compilation tools are prefixed by `<HOST>-' you probably do\n## not need to set these variables (where `<HOST>' is what has been passed as\n## `--host=<HOST>' argument to `configure').\n\n## All variables in this section can also be used when native compiling.\n\n# * `CC' - C compiler.\nCC=armv8-rpi3-linux-gnueabihf-gcc\n\n# * `CFLAGS' - C compiler flags.\n#CFLAGS=\n\n# * `STATIC_CFLAGS' - Static C compiler flags.\n#STATIC_CFLAGS=\n\n# * `CFLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for the shared libraries. Note that this actually is a\n#   linker flag, but it needs to be passed via the compiler.\n#CFLAG_RUNTIME_LIBRARY_PATH=\n\n# * `CPP' - C pre-processor.\nCPP=armv8-rpi3-linux-gnueabihf-cpp\n\n# * `CPPFLAGS' - C pre-processor flags.\n#CPPFLAGS=\n\n# * `CXX' - C++ compiler.\nCXX=armv8-rpi3-linux-gnueabihf-g++\n\n# * `CXXFLAGS' - C++ compiler flags.\n#CXXFLAGS=\n\n# * `LD' - Linker.\nLD=armv8-rpi3-linux-gnueabihf-ld\n\n# * `LDFLAGS' - Linker flags.\nLDFLAGS=\"-L$RPI_SYSROOT/lib\"\n\n# * `LIBS' - Libraries.\n#LIBS=\n\n## -- *D*ynamic *E*rlang *D*river Linking --\n\n## *NOTE*! Either set all or none of the `DED_LD*' variables.\n\n# * `DED_LD' - Linker for Dynamically loaded Erlang Drivers.\n#DED_LD=\n\n# * `DED_LDFLAGS' - Linker flags to use with `DED_LD'.\n#DED_LDFLAGS=\n\n# * `DED_LD_FLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for shared libraries when linking with `DED_LD'.\n#DED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\n## -- Large File Support --\n\n## *NOTE*! Either set all or none of the `LFS_*' variables.\n\n# * `LFS_CFLAGS' - Large file support C compiler flags.\n#LFS_CFLAGS=\n\n# * `LFS_LDFLAGS' - Large file support linker flags.\n#LFS_LDFLAGS=\n\n# * `LFS_LIBS' - Large file support libraries.\n#LFS_LIBS=\n\n## -- Other Tools --\n\n# * `RANLIB' - `ranlib' archive index tool.\nRANLIB=armv8-rpi3-linux-gnueabihf-ranlib\n\n# * `AR' - `ar' archiving tool.\nAR=armv8-rpi3-linux-gnueabihf-ar\n\n# * `GETCONF' - `getconf' system configuration inspection tool. `getconf' is\n#   currently used for finding out large file support flags to use, and\n#   on Linux systems for finding out if we have an NPTL thread library or\n#   not.\n#GETCONF=\n\n## -- Cross System Root Locations ----------------------------------------------\n\n# * `erl_xcomp_sysroot' - The absolute path to the system root of the cross\n#   compilation environment. Currently, the `crypto', `odbc', `ssh' and\n#   `ssl' applications need the system root. These applications will be\n#   skipped if the system root has not been set. The system root might be\n#   needed for other things too. If this is the case and the system root\n#   has not been set, `configure' will fail and request you to set it.\nerl_xcomp_sysroot=\"$RPI_SYSROOT\"\n\n# * `erl_xcomp_isysroot' - The absolute path to the system root for includes\n#   of the cross compilation environment. If not set, this value defaults\n#   to `$erl_xcomp_sysroot', i.e., only set this value if the include system\n#   root path is not the same as the system root path.\n#erl_xcomp_isysroot=\n\n## -- Optional Feature, and Bug Tests ------------------------------------------\n\n## These tests cannot (always) be done automatically when cross compiling. You\n## usually do not need to set these variables. Only set these if you really\n## know what you are doing.\n\n## Note that some of these values will override results of tests performed\n## by `configure', and some will not be used until `configure' is sure that\n## it cannot figure the result out.\n\n## The `configure' script will issue a warning when a default value is used.\n## When a variable has been set, no warning will be issued.\n\n# * `erl_xcomp_after_morecore_hook' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `__after_morecore_hook' that can be\n#   used for tracking used `malloc()' implementations core memory usage.\n#   This is currently only used by unsupported features.\n#erl_xcomp_after_morecore_hook=\n\n# * `erl_xcomp_bigendian' - `yes|no'. No default. If `yes', the target system\n#   must be big endian. If `no', little endian. This can often be\n#   automatically detected, but not always. If not automatically detected,\n#   `configure' will fail unless this variable is set. Since no default\n#   value is used, `configure' will try to figure this out automatically.\n#erl_xcomp_bigendian=\n\n# * `erl_xcomp_double_middle` - `yes|no`. No default. If `yes`, the\n#   target system must have doubles in \"middle-endian\" format. If\n#   `no`, it has \"regular\" endianness. This can often be automatically\n#   detected, but not always. If not automatically detected,\n#   `configure` will fail unless this variable is set. Since no\n#   default value is used, `configure` will try to figure this out\n#   automatically.\n#erl_xcomp_double_middle_endian\n\n# * `erl_xcomp_clock_gettime_cpu_time' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `clock_gettime()' implementation\n#   that can be used for retrieving process CPU time.\n#erl_xcomp_clock_gettime_cpu_time=\n\n# * `erl_xcomp_getaddrinfo' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `getaddrinfo()' implementation that can\n#   handle both IPv4 and IPv6.\n#erl_xcomp_getaddrinfo=\n\n# * `erl_xcomp_gethrvtime_procfs_ioctl' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `gethrvtime()' implementation and\n#   is used with procfs `ioctl()'.\n#erl_xcomp_gethrvtime_procfs_ioctl=\n\n# * `erl_xcomp_dlsym_brk_wrappers' - `yes|no'. Defaults to `no'. If `yes', the\n#   target system must have a working `dlsym(RTLD_NEXT, <S>)' implementation\n#   that can be used on `brk' and `sbrk' symbols used by the `malloc()'\n#   implementation in use, and by this track the `malloc()' implementations\n#   core memory usage. This is currently only used by unsupported features.\n#erl_xcomp_dlsym_brk_wrappers=\n\n# * `erl_xcomp_kqueue' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `kqueue()' implementation that returns a file\n#   descriptor which can be used by `poll()' and/or `select()'. If `no' and\n#   the target system has not got `epoll()' or `/dev/poll', the kernel-poll\n#   feature will be disabled.\n#erl_xcomp_kqueue=\n\n# * `erl_xcomp_linux_clock_gettime_correction' - `yes|no'. Defaults to `yes' on\n#   Linux; otherwise, `no'. If `yes', `clock_gettime(CLOCK_MONOTONIC, _)' on\n#   the target system must work. This variable is recommended to be set to\n#   `no' on Linux systems with kernel versions less than 2.6.\n#erl_xcomp_linux_clock_gettime_correction=\n\n# * `erl_xcomp_linux_nptl' - `yes|no'. Defaults to `yes' on Linux; otherwise,\n#   `no'. If `yes', the target system must have NPTL (Native POSIX Thread\n#   Library). Older Linux systems have LinuxThreads instead of NPTL (Linux\n#   kernel versions typically less than 2.6).\n#erl_xcomp_linux_nptl=\n\n# * `erl_xcomp_linux_usable_sigaltstack' - `yes|no'. Defaults to `yes' on Linux;\n#   otherwise, `no'. If `yes', `sigaltstack()' must be usable on the target\n#   system. `sigaltstack()' on Linux kernel versions less than 2.4 are\n#   broken.\n#erl_xcomp_linux_usable_sigaltstack=\n\n# * `erl_xcomp_linux_usable_sigusrx' - `yes|no'. Defaults to `yes'. If `yes',\n#   the `SIGUSR1' and `SIGUSR2' signals must be usable by the ERTS. Old\n#   LinuxThreads thread libraries (Linux kernel versions typically less than\n#   2.2) used these signals and made them unusable by the ERTS.\n#erl_xcomp_linux_usable_sigusrx=\n\n# * `erl_xcomp_poll' - `yes|no'. Defaults to `no' on Darwin/MacOSX; otherwise,\n#   `yes'. If `yes', the target system must have a working `poll()'\n#   implementation that also can handle devices. If `no', `select()' will be\n#   used instead of `poll()'.\n#erl_xcomp_poll=\n\n# * `erl_xcomp_putenv_copy' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a `putenv()' implementation that stores a copy of the\n#   key/value pair.\n#erl_xcomp_putenv_copy=\n\n# * `erl_xcomp_reliable_fpe' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have reliable floating point exceptions.\n#erl_xcomp_reliable_fpe=\n\n# * `erl_xcomp_posix_memalign' - `yes|no'. Defaults to `yes' if `posix_memalign'\n#   system call exists; otherwise `no'. If `yes', the target system must have a\n#   `posix_memalign' implementation that accepts larger than page size\n#   alignment.\n#erl_xcomp_posix_memalign=\n\n## -----------------------------------------------------------------------------\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/xcomp/erl-xcomp-vars.sh": "#\n# %CopyrightBegin%\n#\n# Copyright Ericsson AB 2010-2012. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# %CopyrightEnd%\n#\n\n#\n# erl_xcomp_vars - Cross configuration variables currently reqognized by\n#                  `configure' scripts in OTP.\n#\n# NOTE:\n#    When updating, also update $ERL_TOP/xcomp/{README,erl-xcomp.conf.template},\n#    and precious variables in $ERL_TOP/erts/aclocal.m4.\n#\n\nerl_xcomp_vars=\"erl_xcomp_sysroot erl_xcomp_isysroot erl_xcomp_bigendian erl_xcomp_double_middle_endian erl_xcomp_linux_clock_gettime_correction erl_xcomp_linux_nptl erl_xcomp_linux_usable_sigusrx erl_xcomp_linux_usable_sigaltstack erl_xcomp_poll erl_xcomp_kqueue erl_xcomp_putenv_copy erl_xcomp_reliable_fpe erl_xcomp_getaddrinfo erl_xcomp_gethrvtime_procfs_ioctl erl_xcomp_clock_gettime_cpu_time erl_xcomp_after_morecore_hook erl_xcomp_dlsym_brk_wrappers erl_xcomp_posix_memalign erl_xcomp_code_model_small\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/xcomp/erl-xcomp-x86_64-saf-linux-gnu.conf": "## -*-shell-script-*-\n##\n## %CopyrightBegin%\n##\n## Copyright Ericsson AB 2010-2012. All Rights Reserved.\n##\n## Licensed under the Apache License, Version 2.0 (the \"License\");\n## you may not use this file except in compliance with the License.\n## You may obtain a copy of the License at\n##\n##     http://www.apache.org/licenses/LICENSE-2.0\n##\n## Unless required by applicable law or agreed to in writing, software\n## distributed under the License is distributed on an \"AS IS\" BASIS,\n## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n## See the License for the specific language governing permissions and\n## limitations under the License.\n##\n## %CopyrightEnd%\n##\n## File: erl-xcomp-x86_64-saf-linux-gnu.conf\n## Author: Rickard Green\n##\n## -----------------------------------------------------------------------------\n## When cross compiling Erlang/OTP using `otp_build', copy this file and set\n## the variables needed below. Then pass the path to the copy of this file as\n## an argument to `otp_build' in the configure stage:\n##   `otp_build configure --xcomp-conf=<FILE>'\n## -----------------------------------------------------------------------------\n\n## Note that you cannot define arbitrary variables in a cross compilation\n## configuration file. Only the ones listed below will be guaranteed to be\n## visible throughout the whole execution of all `configure' scripts. Other\n## variables needs to be defined as arguments to `configure' or exported in\n## the environment.\n\n## -- Variables for `otp_build' Only -------------------------------------------\n\n## Variables in this section are only used, when configuring Erlang/OTP for\n## cross compilation using `$ERL_TOP/otp_build configure'.\n\n## *NOTE*! These variables currently have *no* effect if you configure using\n## the `configure' script directly.\n\n# * `erl_xcomp_build' - The build system used. This value will be passed as\n#   `--build=$erl_xcomp_build' argument to the `configure' script. It does\n#   not have to be a full `CPU-VENDOR-OS' triplet, but can be. The full\n#   `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_build'. If set to `guess',\n#   the build system will be guessed using\n#   `$ERL_TOP/erts/autoconf/config.guess'.\nerl_xcomp_build=guess\n\n# * `erl_xcomp_host' - Cross host/target system to build for. This value will\n#   be passed as `--host=$erl_xcomp_host' argument to the `configure' script.\n#   It does not have to be a full `CPU-VENDOR-OS' triplet, but can be. The\n#   full `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_host'.\nerl_xcomp_host=x86_64-saf-linux-gnu\n\n# * `erl_xcomp_configure_flags' - Extra configure flags to pass to the\n#   `configure' script.\n#erl_xcomp_configure_flags=\n\n## -- Cross Compiler and Other Tools -------------------------------------------\n\n## If the cross compilation tools are prefixed by `<HOST>-' you probably do\n## not need to set these variables (where `<HOST>' is what has been passed as\n## `--host=<HOST>' argument to `configure').\n\n## All variables in this section can also be used when native compiling.\n\n# * `CC' - C compiler.\nCC=x86_64-saf-gcc\n\n# * `CFLAGS' - C compiler flags.\n#CFLAGS=\n\n# * `STATIC_CFLAGS' - Static C compiler flags.\n#STATIC_CFLAGS=\n\n# * `CFLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for the shared libraries. Note that this actually is a\n#   linker flag, but it needs to be passed via the compiler.\n#CFLAG_RUNTIME_LIBRARY_PATH=\n\n# * `CPP' - C pre-processor.\n#CPP=\n\n# * `CPPFLAGS' - C pre-processor flags.\n#CPPFLAGS=\n\n# * `CXX' - C++ compiler.\nCXX=x86_64-saf-g++\n\n# * `CXXFLAGS' - C++ compiler flags.\n#CXXFLAGS=\n\n# * `LD' - Linker.\nLD=x86_64-saf-ld\n\n# * `LDFLAGS' - Linker flags.\n#LDFLAGS=\n\n# * `LIBS' - Libraries.\n#LIBS=\n\n## -- *D*ynamic *E*rlang *D*river Linking --\n\n## *NOTE*! Either set all or none of the `DED_LD*' variables.\n\n# * `DED_LD' - Linker for Dynamically loaded Erlang Drivers.\n#DED_LD=\n\n# * `DED_LDFLAGS' - Linker flags to use with `DED_LD'.\n#DED_LDFLAGS=\n\n# * `DED_LD_FLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for shared libraries when linking with `DED_LD'.\n#DED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\n## -- Large File Support --\n\n## *NOTE*! Either set all or none of the `LFS_*' variables.\n\n# * `LFS_CFLAGS' - Large file support C compiler flags.\n#LFS_CFLAGS=\n\n# * `LFS_LDFLAGS' - Large file support linker flags.\n#LFS_LDFLAGS=\n\n# * `LFS_LIBS' - Large file support libraries.\n#LFS_LIBS=\n\n## -- Other Tools --\n\n# * `RANLIB' - `ranlib' archive index tool.\nRANLIB=x86_64-saf-ranlib\n\n# * `AR' - `ar' archiving tool.\nAR=x86_64-saf-ar\n\n# * `GETCONF' - `getconf' system configuration inspection tool. `getconf' is\n#   currently used for finding out large file support flags to use, and\n#   on Linux systems for finding out if we have an NPTL thread library or\n#   not.\n#GETCONF=\n\n## -- Cross System Root Locations ----------------------------------------------\n\n# * `erl_xcomp_sysroot' - The absolute path to the system root of the cross\n#   compilation environment. Currently, the `crypto', `odbc', `ssh' and\n#   `ssl' applications need the system root. These applications will be\n#   skipped if the system root has not been set. The system root might be\n#   needed for other things too. If this is the case and the system root\n#   has not been set, `configure' will fail and request you to set it.\nerl_xcomp_sysroot=\"$SAF_SYSROOT_X86_64\"\n\n# * `erl_xcomp_isysroot' - The absolute path to the system root for includes\n#   of the cross compilation environment. If not set, this value defaults\n#   to `$erl_xcomp_sysroot', i.e., only set this value if the include system\n#   root path is not the same as the system root path.\n#erl_xcomp_isysroot=\n\n## -- Optional Feature, and Bug Tests ------------------------------------------\n\n## These tests cannot (always) be done automatically when cross compiling. You\n## usually do not need to set these variables. Only set these if you really\n## know what you are doing.\n\n## Note that some of these values will override results of tests performed\n## by `configure', and some will not be used until `configure' is sure that\n## it cannot figure the result out.\n\n## The `configure' script will issue a warning when a default value is used.\n## When a variable has been set, no warning will be issued.\n\n# * `erl_xcomp_after_morecore_hook' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `__after_morecore_hook' that can be\n#   used for tracking used `malloc()' implementations core memory usage.\n#   This is currently only used by unsupported features.\nerl_xcomp_after_morecore_hook=yes\n\n# * `erl_xcomp_bigendian' - `yes|no'. No default. If `yes', the target system\n#   must be big endian. If `no', little endian. This can often be\n#   automatically detected, but not always. If not automatically detected,\n#   `configure' will fail unless this variable is set. Since no default\n#   value is used, `configure' will try to figure this out automatically.\n#erl_xcomp_bigendian=\n\n# * `erl_xcomp_double_middle_endian` - `yes|no`. No default. If `yes`, the\n#   target system must have doubles in \"middle-endian\" format. If\n#   `no`, it has \"regular\" endianness. This can often be automatically\n#   detected, but not always. If not automatically detected,\n#   `configure` will fail unless this variable is set. Since no\n#   default value is used, `configure` will try to figure this out\n#   automatically.\n#erl_xcomp_double_middle_endian\n\n# * `erl_xcomp_clock_gettime_cpu_time' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `clock_gettime()' implementation\n#   that can be used for retrieving process CPU time.\n#erl_xcomp_clock_gettime_cpu_time=\n\n# * `erl_xcomp_getaddrinfo' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `getaddrinfo()' implementation that can\n#   handle both IPv4 and IPv6.\nerl_xcomp_getaddrinfo=yes\n\n# * `erl_xcomp_gethrvtime_procfs_ioctl' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `gethrvtime()' implementation and\n#   is used with procfs `ioctl()'.\n#erl_xcomp_gethrvtime_procfs_ioctl=\n\n# * `erl_xcomp_dlsym_brk_wrappers' - `yes|no'. Defaults to `no'. If `yes', the\n#   target system must have a working `dlsym(RTLD_NEXT, <S>)' implementation\n#   that can be used on `brk' and `sbrk' symbols used by the `malloc()'\n#   implementation in use, and by this track the `malloc()' implementations\n#   core memory usage. This is currently only used by unsupported features.\n#erl_xcomp_dlsym_brk_wrappers=\n\n# * `erl_xcomp_kqueue' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `kqueue()' implementation that returns a file\n#   descriptor which can be used by `poll()' and/or `select()'. If `no' and\n#   the target system has not got `epoll()' or `/dev/poll', the kernel-poll\n#   feature will be disabled.\n#erl_xcomp_kqueue=\n\n# * `erl_xcomp_linux_clock_gettime_correction' - `yes|no'. Defaults to `yes' on\n#   Linux; otherwise, `no'. If `yes', `clock_gettime(CLOCK_MONOTONIC, _)' on\n#   the target system must work. This variable is recommended to be set to\n#   `no' on Linux systems with kernel versions less than 2.6.\n#erl_xcomp_linux_clock_gettime_correction=\n\n# * `erl_xcomp_linux_nptl' - `yes|no'. Defaults to `yes' on Linux; otherwise,\n#   `no'. If `yes', the target system must have NPTL (Native POSIX Thread\n#   Library). Older Linux systems have LinuxThreads instead of NPTL (Linux\n#   kernel versions typically less than 2.6).\n#erl_xcomp_linux_nptl=\n\n# * `erl_xcomp_linux_usable_sigaltstack' - `yes|no'. Defaults to `yes' on Linux;\n#   otherwise, `no'. If `yes', `sigaltstack()' must be usable on the target\n#   system. `sigaltstack()' on Linux kernel versions less than 2.4 are\n#   broken.\n#erl_xcomp_linux_usable_sigaltstack=\n\n# * `erl_xcomp_linux_usable_sigusrx' - `yes|no'. Defaults to `yes'. If `yes',\n#   the `SIGUSR1' and `SIGUSR2' signals must be usable by the ERTS. Old\n#   LinuxThreads thread libraries (Linux kernel versions typically less than\n#   2.2) used these signals and made them unusable by the ERTS.\n#erl_xcomp_linux_usable_sigusrx=\n\n# * `erl_xcomp_poll' - `yes|no'. Defaults to `no' on Darwin/MacOSX; otherwise,\n#   `yes'. If `yes', the target system must have a working `poll()'\n#   implementation that also can handle devices. If `no', `select()' will be\n#   used instead of `poll()'.\n#erl_xcomp_poll=\n\n# * `erl_xcomp_putenv_copy' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a `putenv()' implementation that stores a copy of the\n#   key/value pair.\n#erl_xcomp_putenv_copy=\n\n# * `erl_xcomp_reliable_fpe' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have reliable floating point exceptions.\n#erl_xcomp_reliable_fpe=\n\n## -----------------------------------------------------------------------------\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/xcomp/erl-xcomp.conf.template": "## -*-shell-script-*-\n##\n## %CopyrightBegin%\n##\n## Copyright Ericsson AB 2009-2012. All Rights Reserved.\n##\n## Licensed under the Apache License, Version 2.0 (the \"License\");\n## you may not use this file except in compliance with the License.\n## You may obtain a copy of the License at\n##\n##     http://www.apache.org/licenses/LICENSE-2.0\n##\n## Unless required by applicable law or agreed to in writing, software\n## distributed under the License is distributed on an \"AS IS\" BASIS,\n## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n## See the License for the specific language governing permissions and\n## limitations under the License.\n##\n## %CopyrightEnd%\n##\n## File: erl-xcomp.conf.template\n## Author: Rickard Green\n##\n## -----------------------------------------------------------------------------\n## When cross compiling Erlang/OTP using `otp_build', copy this file and set\n## the variables needed below. Then pass the path to the copy of this file as\n## an argument to `otp_build' in the configure stage:\n##   `otp_build configure --xcomp-conf=<FILE>'\n## -----------------------------------------------------------------------------\n\n## Note that you cannot define arbitrary variables in a cross compilation\n## configuration file. Only the ones listed below will be guaranteed to be\n## visible throughout the whole execution of all `configure' scripts. Other\n## variables needs to be defined as arguments to `configure' or exported in\n## the environment.\n\n## -- Variables for `otp_build' Only -------------------------------------------\n\n## Variables in this section are only used, when configuring Erlang/OTP for\n## cross compilation using `$ERL_TOP/otp_build configure'.\n\n## *NOTE*! These variables currently have *no* effect if you configure using\n## the `configure' script directly.\n\n# * `erl_xcomp_build' - The build system used. This value will be passed as\n#   `--build=$erl_xcomp_build' argument to the `configure' script. It does\n#   not have to be a full `CPU-VENDOR-OS' triplet, but can be. The full\n#   `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_build'. If set to `guess',\n#   the build system will be guessed using\n#   `$ERL_TOP/erts/autoconf/config.guess'.\n#erl_xcomp_build=\n\n# * `erl_xcomp_host' - Cross host/target system to build for. This value will\n#   be passed as `--host=$erl_xcomp_host' argument to the `configure' script.\n#   It does not have to be a full `CPU-VENDOR-OS' triplet, but can be. The\n#   full `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_host'.\n#erl_xcomp_host=\n\n# * `erl_xcomp_configure_flags' - Extra configure flags to pass to the\n#   `configure' script.\n#erl_xcomp_configure_flags=\n\n## -- Cross Compiler and Other Tools -------------------------------------------\n\n## If the cross compilation tools are prefixed by `<HOST>-' you probably do\n## not need to set these variables (where `<HOST>' is what has been passed as\n## `--host=<HOST>' argument to `configure').\n\n## All variables in this section can also be used when native compiling.\n\n# * `CC' - C compiler.\n#CC=\n\n# * `CFLAGS' - C compiler flags.\n#CFLAGS=\n\n# * `STATIC_CFLAGS' - Static C compiler flags.\n#STATIC_CFLAGS=\n\n# * `CFLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for the shared libraries. Note that this actually is a\n#   linker flag, but it needs to be passed via the compiler.\n#CFLAG_RUNTIME_LIBRARY_PATH=\n\n# * `CPP' - C pre-processor.\n#CPP=\n\n# * `CPPFLAGS' - C pre-processor flags.\n#CPPFLAGS=\n\n# * `CXX' - C++ compiler.\n#CXX=\n\n# * `CXXFLAGS' - C++ compiler flags.\n#CXXFLAGS=\n\n# * `LD' - Linker.\n#LD=\n\n# * `LDFLAGS' - Linker flags.\n#LDFLAGS=\n\n# * `LIBS' - Libraries.\n#LIBS=\n\n## -- *D*ynamic *E*rlang *D*river Linking --\n\n## *NOTE*! Either set all or none of the `DED_LD*' variables.\n\n# * `DED_LD' - Linker for Dynamically loaded Erlang Drivers.\n#DED_LD=\n\n# * `DED_LDFLAGS' - Linker flags to use with `DED_LD'.\n#DED_LDFLAGS=\n\n# * `DED_LD_FLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for shared libraries when linking with `DED_LD'.\n#DED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\n## -- Large File Support --\n\n## *NOTE*! Either set all or none of the `LFS_*' variables.\n\n# * `LFS_CFLAGS' - Large file support C compiler flags.\n#LFS_CFLAGS=\n\n# * `LFS_LDFLAGS' - Large file support linker flags.\n#LFS_LDFLAGS=\n\n# * `LFS_LIBS' - Large file support libraries.\n#LFS_LIBS=\n\n## -- Other Tools --\n\n# * `RANLIB' - `ranlib' archive index tool.\n#RANLIB=\n\n# * `AR' - `ar' archiving tool.\n#AR=\n\n# * `GETCONF' - `getconf' system configuration inspection tool. `getconf' is\n#   currently used for finding out large file support flags to use, and\n#   on Linux systems for finding out if we have an NPTL thread library or\n#   not.\n#GETCONF=\n\n## -- Cross System Root Locations ----------------------------------------------\n\n# * `erl_xcomp_sysroot' - The absolute path to the system root of the cross\n#   compilation environment. Currently, the `crypto', `odbc', `ssh' and\n#   `ssl' applications need the system root. These applications will be\n#   skipped if the system root has not been set. The system root might be\n#   needed for other things too. If this is the case and the system root\n#   has not been set, `configure' will fail and request you to set it.\n#erl_xcomp_sysroot=\n\n# * `erl_xcomp_isysroot' - The absolute path to the system root for includes\n#   of the cross compilation environment. If not set, this value defaults\n#   to `$erl_xcomp_sysroot', i.e., only set this value if the include system\n#   root path is not the same as the system root path.\n#erl_xcomp_isysroot=\n\n## -- Optional Feature, and Bug Tests ------------------------------------------\n\n## These tests cannot (always) be done automatically when cross compiling. You\n## usually do not need to set these variables. Only set these if you really\n## know what you are doing.\n\n## Note that some of these values will override results of tests performed\n## by `configure', and some will not be used until `configure' is sure that\n## it cannot figure the result out.\n\n## The `configure' script will issue a warning when a default value is used.\n## When a variable has been set, no warning will be issued.\n\n# * `erl_xcomp_after_morecore_hook' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `__after_morecore_hook' that can be\n#   used for tracking used `malloc()' implementations core memory usage.\n#   This is currently only used by unsupported features.\n#erl_xcomp_after_morecore_hook=\n\n# * `erl_xcomp_bigendian' - `yes|no'. No default. If `yes', the target system\n#   must be big endian. If `no', little endian. This can often be\n#   automatically detected, but not always. If not automatically detected,\n#   `configure' will fail unless this variable is set. Since no default\n#   value is used, `configure' will try to figure this out automatically.\n#erl_xcomp_bigendian=\n\n# * `erl_xcomp_double_middle` - `yes|no`. No default. If `yes`, the\n#   target system must have doubles in \"middle-endian\" format. If\n#   `no`, it has \"regular\" endianness. This can often be automatically\n#   detected, but not always. If not automatically detected,\n#   `configure` will fail unless this variable is set. Since no\n#   default value is used, `configure` will try to figure this out\n#   automatically.\n#erl_xcomp_double_middle_endian\n\n# * `erl_xcomp_clock_gettime_cpu_time' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `clock_gettime()' implementation\n#   that can be used for retrieving process CPU time.\n#erl_xcomp_clock_gettime_cpu_time=\n\n# * `erl_xcomp_getaddrinfo' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `getaddrinfo()' implementation that can\n#   handle both IPv4 and IPv6.\n#erl_xcomp_getaddrinfo=\n\n# * `erl_xcomp_gethrvtime_procfs_ioctl' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `gethrvtime()' implementation and\n#   is used with procfs `ioctl()'.\n#erl_xcomp_gethrvtime_procfs_ioctl=\n\n# * `erl_xcomp_dlsym_brk_wrappers' - `yes|no'. Defaults to `no'. If `yes', the\n#   target system must have a working `dlsym(RTLD_NEXT, <S>)' implementation\n#   that can be used on `brk' and `sbrk' symbols used by the `malloc()'\n#   implementation in use, and by this track the `malloc()' implementations\n#   core memory usage. This is currently only used by unsupported features.\n#erl_xcomp_dlsym_brk_wrappers=\n\n# * `erl_xcomp_kqueue' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `kqueue()' implementation that returns a file\n#   descriptor which can be used by `poll()' and/or `select()'. If `no' and\n#   the target system has not got `epoll()' or `/dev/poll', the kernel-poll\n#   feature will be disabled.\n#erl_xcomp_kqueue=\n\n# * `erl_xcomp_linux_clock_gettime_correction' - `yes|no'. Defaults to `yes' on\n#   Linux; otherwise, `no'. If `yes', `clock_gettime(CLOCK_MONOTONIC, _)' on\n#   the target system must work. This variable is recommended to be set to\n#   `no' on Linux systems with kernel versions less than 2.6.\n#erl_xcomp_linux_clock_gettime_correction=\n\n# * `erl_xcomp_linux_nptl' - `yes|no'. Defaults to `yes' on Linux; otherwise,\n#   `no'. If `yes', the target system must have NPTL (Native POSIX Thread\n#   Library). Older Linux systems have LinuxThreads instead of NPTL (Linux\n#   kernel versions typically less than 2.6).\n#erl_xcomp_linux_nptl=\n\n# * `erl_xcomp_linux_usable_sigaltstack' - `yes|no'. Defaults to `yes' on Linux;\n#   otherwise, `no'. If `yes', `sigaltstack()' must be usable on the target\n#   system. `sigaltstack()' on Linux kernel versions less than 2.4 are\n#   broken.\n#erl_xcomp_linux_usable_sigaltstack=\n\n# * `erl_xcomp_linux_usable_sigusrx' - `yes|no'. Defaults to `yes'. If `yes',\n#   the `SIGUSR1' and `SIGUSR2' signals must be usable by the ERTS. Old\n#   LinuxThreads thread libraries (Linux kernel versions typically less than\n#   2.2) used these signals and made them unusable by the ERTS.\n#erl_xcomp_linux_usable_sigusrx=\n\n# * `erl_xcomp_poll' - `yes|no'. Defaults to `no' on Darwin/MacOSX; otherwise,\n#   `yes'. If `yes', the target system must have a working `poll()'\n#   implementation that also can handle devices. If `no', `select()' will be\n#   used instead of `poll()'.\n#erl_xcomp_poll=\n\n# * `erl_xcomp_putenv_copy' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a `putenv()' implementation that stores a copy of the\n#   key/value pair.\n#erl_xcomp_putenv_copy=\n\n# * `erl_xcomp_reliable_fpe' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have reliable floating point exceptions.\n#erl_xcomp_reliable_fpe=\n\n# * `erl_xcomp_posix_memalign' - `yes|no'. Defaults to `yes' if `posix_memalign'\n#   system call exists; otherwise `no'. If `yes', the target system must have a\n#   `posix_memalign' implementation that accepts larger than page size\n#   alignment.\n#erl_xcomp_posix_memalign=\n\n# * `erl_xcomp_code_model_small` - `yes|no`. Default to `no`. If `yes`, the target\n#   system must place the beam.smp executable in the lower 2 GB of memory. That is it\n#   should not use position independent executable.\n#erl_xcomp_code_model_small=\n\n## -----------------------------------------------------------------------------\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/xcomp/erl-xcomp-TileraMDE2.0-tilepro.conf": "## -*-shell-script-*-\n##\n## %CopyrightBegin%\n##\n## Copyright Ericsson AB 2009-2012. All Rights Reserved.\n##\n## Licensed under the Apache License, Version 2.0 (the \"License\");\n## you may not use this file except in compliance with the License.\n## You may obtain a copy of the License at\n##\n##     http://www.apache.org/licenses/LICENSE-2.0\n##\n## Unless required by applicable law or agreed to in writing, software\n## distributed under the License is distributed on an \"AS IS\" BASIS,\n## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n## See the License for the specific language governing permissions and\n## limitations under the License.\n##\n## %CopyrightEnd%\n##\n## File: erl-xcomp-TileraMDE2.0-tilepro.conf\n## Author: Rickard Green\n## Tested on: TileraMDE-2.0, TileraMDE-3.0.1.125620\n##\n## -----------------------------------------------------------------------------\n## When cross compiling Erlang/OTP using `otp_build', copy this file and set\n## the variables needed below. Then pass the path to the copy of this file as\n## an argument to `otp_build' in the configure stage:\n##   `otp_build configure --xcomp-conf=<FILE>'\n## -----------------------------------------------------------------------------\n\n## Note that you cannot define arbitrary variables in a cross compilation\n## configuration file. Only the ones listed below will be guaranteed to be\n## visible throughout the whole execution of all `configure' scripts. Other\n## variables needs to be defined as arguments to `configure' or exported in\n## the environment.\n\n## -- Variables for `otp_build' Only -------------------------------------------\n\n## Variables in this section are only used, when configuring Erlang/OTP for\n## cross compilation using `$ERL_TOP/otp_build configure'.\n\n## *NOTE*! These variables currently have *no* effect if you configure using\n## the `configure' script directly.\n\n# * `erl_xcomp_build' - The build system used. This value will be passed as\n#   `--build=$erl_xcomp_build' argument to the `configure' script. It does\n#   not have to be a full `CPU-VENDOR-OS' triplet, but can be. The full\n#   `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_build'. If set to `guess',\n#   the build system will be guessed using\n#   `$ERL_TOP/erts/autoconf/config.guess'.\nerl_xcomp_build=guess\n\n# * `erl_xcomp_host' - Cross host/target system to build for. This value will\n#   be passed as `--host=$erl_xcomp_host' argument to the `configure' script.\n#   It does not have to be a full `CPU-VENDOR-OS' triplet, but can be. The\n#   full `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_host'.\nerl_xcomp_host=tile\n\n# * `erl_xcomp_configure_flags' - Extra configure flags to pass to the\n#   `configure' script.\nerl_xcomp_configure_flags=\"--without-termcap\"\n\n## -- Cross Compiler and Other Tools -------------------------------------------\n\n## If the cross compilation tools are prefixed by `<HOST>-' you probably do\n## not need to set these variables (where `<HOST>' is what has been passed as\n## `--host=<HOST>' argument to `configure').\n\n## All variables in this section can also be used when native compiling.\n\n# * `CC' - C compiler.\n#CC=\n\n# * `CFLAGS' - C compiler flags.\n#CFLAGS=\n\n# * `STATIC_CFLAGS' - Static C compiler flags.\n#STATIC_CFLAGS=\n\n# * `CFLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for the shared libraries. Note that this actually is a\n#   linker flag, but it needs to be passed via the compiler.\n#CFLAG_RUNTIME_LIBRARY_PATH=\n\n# * `CPP' - C pre-processor.\n#CPP=\n\n# * `CPPFLAGS' - C pre-processor flags.\n#CPPFLAGS=\n\n# * `CXX' - C++ compiler.\n#CXX=\n\n# * `CXXFLAGS' - C++ compiler flags.\n#CXXFLAGS=\n\n# * `LD' - Linker.\n#LD=\n\n# * `LDFLAGS' - Linker flags.\n#LDFLAGS=\n\n# * `LIBS' - Libraries.\n#LIBS=\n\n## -- *D*ynamic *E*rlang *D*river Linking --\n\n## *NOTE*! Either set all or none of the `DED_LD*' variables.\n\n# * `DED_LD' - Linker for Dynamically loaded Erlang Drivers.\n#DED_LD=\n\n# * `DED_LDFLAGS' - Linker flags to use with `DED_LD'.\n#DED_LDFLAGS=\n\n# * `DED_LD_FLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for shared libraries when linking with `DED_LD'.\n#DED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\n## -- Large File Support --\n\n## *NOTE*! Either set all or none of the `LFS_*' variables.\n\n# * `LFS_CFLAGS' - Large file support C compiler flags.\n#LFS_CFLAGS=\n\n# * `LFS_LDFLAGS' - Large file support linker flags.\n#LFS_LDFLAGS=\n\n# * `LFS_LIBS' - Large file support libraries.\n#LFS_LIBS=\n\n## -- Other Tools --\n\n# * `RANLIB' - `ranlib' archive index tool.\n#RANLIB=\n\n# * `AR' - `ar' archiving tool.\n#AR=\n\n# * `GETCONF' - `getconf' system configuration inspection tool. `getconf' is\n#   currently used for finding out large file support flags to use, and\n#   on Linux systems for finding out if we have an NPTL thread library or\n#   not.\n#GETCONF=\n\n## -- Cross System Root Locations ----------------------------------------------\n\n# * `erl_xcomp_sysroot' - The absolute path to the system root of the cross\n#   compilation environment. Currently, the `crypto', `odbc', `ssh' and\n#   `ssl' applications need the system root. These applications will be\n#   skipped if the system root has not been set. The system root might be\n#   needed for other things too. If this is the case and the system root\n#   has not been set, `configure' will fail and request you to set it.\nerl_xcomp_sysroot=\"$TILERA_ROOT/tile\"\n\n# * `erl_xcomp_isysroot' - The absolute path to the system root for includes\n#   of the cross compilation environment. If not set, this value defaults\n#   to `$erl_xcomp_sysroot', i.e., only set this value if the include system\n#   root path is not the same as the system root path.\n#erl_xcomp_isysroot=\n\n## -- Optional Feature, and Bug Tests ------------------------------------------\n\n## These tests cannot (always) be done automatically when cross compiling. You\n## usually do not need to set these variables. Only set these if you really\n## know what you are doing.\n\n## Note that some of these values will override results of tests performed\n## by `configure', and some will not be used until `configure' is sure that\n## it cannot figure the result out.\n\n## The `configure' script will issue a warning when a default value is used.\n## When a variable has been set, no warning will be issued.\n\n# * `erl_xcomp_after_morecore_hook' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `__after_morecore_hook' that can be\n#   used for tracking used `malloc()' implementations core memory usage.\n#   This is currently only used by unsupported features.\n#erl_xcomp_after_morecore_hook=\n\n# * `erl_xcomp_bigendian' - `yes|no'. No default. If `yes', the target system\n#   must be big endian. If `no', little endian. This can often be\n#   automatically detected, but not always. If not automatically detected,\n#   `configure' will fail unless this variable is set. Since no default\n#   value is used, `configure' will try to figure this out automatically.\n#erl_xcomp_bigendian=\n\n# * `erl_xcomp_double_middle_endian` - `yes|no`. No default. If `yes`, the\n#   target system must have doubles in \"middle-endian\" format. If\n#   `no`, it has \"regular\" endianness. This can often be automatically\n#   detected, but not always. If not automatically detected,\n#   `configure` will fail unless this variable is set. Since no\n#   default value is used, `configure` will try to figure this out\n#   automatically.\n#erl_xcomp_double_middle_endian\n\n# * `erl_xcomp_clock_gettime_cpu_time' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `clock_gettime()' implementation\n#   that can be used for retrieving process CPU time.\n#erl_xcomp_clock_gettime_cpu_time=\n\n# * `erl_xcomp_getaddrinfo' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `getaddrinfo()' implementation that can\n#   handle both IPv4 and IPv6.\nerl_xcomp_getaddrinfo=yes\n\n# * `erl_xcomp_gethrvtime_procfs_ioctl' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `gethrvtime()' implementation and\n#   is used with procfs `ioctl()'.\n#erl_xcomp_gethrvtime_procfs_ioctl=\n\n# * `erl_xcomp_dlsym_brk_wrappers' - `yes|no'. Defaults to `no'. If `yes', the\n#   target system must have a working `dlsym(RTLD_NEXT, <S>)' implementation\n#   that can be used on `brk' and `sbrk' symbols used by the `malloc()'\n#   implementation in use, and by this track the `malloc()' implementations\n#   core memory usage. This is currently only used by unsupported features.\n#erl_xcomp_dlsym_brk_wrappers=\n\n# * `erl_xcomp_kqueue' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `kqueue()' implementation that returns a file\n#   descriptor which can be used by `poll()' and/or `select()'. If `no' and\n#   the target system has not got `epoll()' or `/dev/poll', the kernel-poll\n#   feature will be disabled.\n#erl_xcomp_kqueue=\n\n# * `erl_xcomp_linux_clock_gettime_correction' - `yes|no'. Defaults to `yes' on\n#   Linux; otherwise, `no'. If `yes', `clock_gettime(CLOCK_MONOTONIC, _)' on\n#   the target system must work. This variable is recommended to be set to\n#   `no' on Linux systems with kernel versions less than 2.6.\n#erl_xcomp_linux_clock_gettime_correction=\n\n# * `erl_xcomp_linux_nptl' - `yes|no'. Defaults to `yes' on Linux; otherwise,\n#   `no'. If `yes', the target system must have NPTL (Native POSIX Thread\n#   Library). Older Linux systems have LinuxThreads instead of NPTL (Linux\n#   kernel versions typically less than 2.6).\n#erl_xcomp_linux_nptl=\n\n# * `erl_xcomp_linux_usable_sigaltstack' - `yes|no'. Defaults to `yes' on Linux;\n#   otherwise, `no'. If `yes', `sigaltstack()' must be usable on the target\n#   system. `sigaltstack()' on Linux kernel versions less than 2.4 are\n#   broken.\n#erl_xcomp_linux_usable_sigaltstack=\n\n# * `erl_xcomp_linux_usable_sigusrx' - `yes|no'. Defaults to `yes'. If `yes',\n#   the `SIGUSR1' and `SIGUSR2' signals must be usable by the ERTS. Old\n#   LinuxThreads thread libraries (Linux kernel versions typically less than\n#   2.2) used these signals and made them unusable by the ERTS.\n#erl_xcomp_linux_usable_sigusrx=\n\n# * `erl_xcomp_poll' - `yes|no'. Defaults to `no' on Darwin/MacOSX; otherwise,\n#   `yes'. If `yes', the target system must have a working `poll()'\n#   implementation that also can handle devices. If `no', `select()' will be\n#   used instead of `poll()'.\n#erl_xcomp_poll=\n\n# * `erl_xcomp_putenv_copy' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a `putenv()' implementation that stores a copy of the\n#   key/value pair.\n#erl_xcomp_putenv_copy=\n\n# * `erl_xcomp_reliable_fpe' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have reliable floating point exceptions.\n#erl_xcomp_reliable_fpe=\n\n## -----------------------------------------------------------------------------\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/xcomp/erl-xcomp-powerpc64-bgq-linux.conf": "## -*-shell-script-*-\n##\n## %CopyrightBegin%\n##\n## Copyright Ericsson AB 2009-2013. All Rights Reserved.\n##\n## Licensed under the Apache License, Version 2.0 (the \"License\");\n## you may not use this file except in compliance with the License.\n## You may obtain a copy of the License at\n##\n##     http://www.apache.org/licenses/LICENSE-2.0\n##\n## Unless required by applicable law or agreed to in writing, software\n## distributed under the License is distributed on an \"AS IS\" BASIS,\n## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n## See the License for the specific language governing permissions and\n## limitations under the License.\n##\n## %CopyrightEnd%\n##\n## File: erl-xcomp.conf.template\n## Author: Rickard Green\n##\n## -----------------------------------------------------------------------------\n## When cross compiling Erlang/OTP using `otp_build', copy this file and set\n## the variables needed below. Then pass the path to the copy of this file as\n## an argument to `otp_build' in the configure stage:\n##   `otp_build configure --xcomp-conf=<FILE>'\n## -----------------------------------------------------------------------------\n\n## Note that you cannot define arbitrary variables in a cross compilation\n## configuration file. Only the ones listed below will be guaranteed to be\n## visible throughout the whole execution of all `configure' scripts. Other\n## variables needs to be defined as arguments to `configure' or exported in\n## the environment.\n\n## -- Variables for `otp_build' Only -------------------------------------------\n\n## Variables in this section are only used, when configuring Erlang/OTP for\n## cross compilation using `$ERL_TOP/otp_build configure'.\n\n## *NOTE*! These variables currently have *no* effect if you configure using\n## the `configure' script directly.\n\n# * `erl_xcomp_build' - The build system used. This value will be passed as\n#   `--build=$erl_xcomp_build' argument to the `configure' script. It does\n#   not have to be a full `CPU-VENDOR-OS' triplet, but can be. The full\n#   `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_build'. If set to `guess',\n#   the build system will be guessed using\n#   `$ERL_TOP/erts/autoconf/config.guess'.\nerl_xcomp_build=guess\n\n# * `erl_xcomp_host' - Cross host/target system to build for. This value will\n#   be passed as `--host=$erl_xcomp_host' argument to the `configure' script.\n#   It does not have to be a full `CPU-VENDOR-OS' triplet, but can be. The\n#   full `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_host'.\nerl_xcomp_host=powerpc64-bgq-linux\n\n# * `erl_xcomp_configure_flags' - Extra configure flags to pass to the\n#   `configure' script.\nerl_xcomp_configure_flags=\"--without-termcap\"\n\n## -- Cross Compiler and Other Tools -------------------------------------------\n\n## If the cross compilation tools are prefixed by `<HOST>-' you probably do\n## not need to set these variables (where `<HOST>' is what has been passed as\n## `--host=<HOST>' argument to `configure').\n\n## This path should really be part of the user's PATH environment, but\n## since it is highly unlikely that it will differ between Blue Gene/Q\n## installations, the path is hard-coded here for convenience.\nTOP_BIN=/bgsys/drivers/ppcfloor/gnu-linux/bin\n\n## All variables in this section can also be used when native compiling.\n\n# * `CC' - C compiler.\nCC=${TOP_BIN}/${erl_xcomp_host}-gcc\n\n# * `CFLAGS' - C compiler flags.\n#CFLAGS=\n\n# * `STATIC_CFLAGS' - Static C compiler flags.\n#STATIC_CFLAGS=\n\n# * `CFLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for the shared libraries. Note that this actually is a\n#   linker flag, but it needs to be passed via the compiler.\n#CFLAG_RUNTIME_LIBRARY_PATH=\n\n# * `CPP' - C pre-processor.\n#CPP=\n\n# * `CPPFLAGS' - C pre-processor flags.\n#CPPFLAGS=\n\n# * `CXX' - C++ compiler.\nCXX=${TOP_BIN}/${erl_xcomp_host}-g++\n\n# * `CXXFLAGS' - C++ compiler flags.\n#CXXFLAGS=\n\n# * `LD' - Linker.\nLD=${TOP_BIN}/${erl_xcomp_host}-ld\n\n# * `LDFLAGS' - Linker flags.\n#LDFLAGS=\n\n# * `LIBS' - Libraries.\n#LIBS=\n\n## -- *D*ynamic *E*rlang *D*river Linking --\n\n## *NOTE*! Either set all or none of the `DED_LD*' variables.\n\n# * `DED_LD' - Linker for Dynamically loaded Erlang Drivers.\n#DED_LD=\n\n# * `DED_LDFLAGS' - Linker flags to use with `DED_LD'.\n#DED_LDFLAGS=\n\n# * `DED_LD_FLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for shared libraries when linking with `DED_LD'.\n#DED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\n## -- Large File Support --\n\n## *NOTE*! Either set all or none of the `LFS_*' variables.\n\n# * `LFS_CFLAGS' - Large file support C compiler flags.\n#LFS_CFLAGS=\n\n# * `LFS_LDFLAGS' - Large file support linker flags.\n#LFS_LDFLAGS=\n\n# * `LFS_LIBS' - Large file support libraries.\n#LFS_LIBS=\n\n## -- Other Tools --\n\n# * `RANLIB' - `ranlib' archive index tool.\nRANLIB=${TOP_BIN}/${erl_xcomp_host}-ranlib\n\n# * `AR' - `ar' archiving tool.\nAR=${TOP_BIN}/${erl_xcomp_host}-ar\n\n# * `GETCONF' - `getconf' system configuration inspection tool. `getconf' is\n#   currently used for finding out large file support flags to use, and\n#   on Linux systems for finding out if we have an NPTL thread library or\n#   not.\n#GETCONF=\n\n## -- Cross System Root Locations ----------------------------------------------\n\n# * `erl_xcomp_sysroot' - The absolute path to the system root of the cross\n#   compilation environment. Currently, the `crypto', `odbc', `ssh' and\n#   `ssl' applications need the system root. These applications will be\n#   skipped if the system root has not been set. The system root might be\n#   needed for other things too. If this is the case and the system root\n#   has not been set, `configure' will fail and request you to set it.\n#erl_xcomp_sysroot=\n\n# * `erl_xcomp_isysroot' - The absolute path to the system root for includes\n#   of the cross compilation environment. If not set, this value defaults\n#   to `$erl_xcomp_sysroot', i.e., only set this value if the include system\n#   root path is not the same as the system root path.\n#erl_xcomp_isysroot=\n\n## -- Optional Feature, and Bug Tests ------------------------------------------\n\n## These tests cannot (always) be done automatically when cross compiling. You\n## usually do not need to set these variables. Only set these if you really\n## know what you are doing.\n\n## Note that some of these values will override results of tests performed\n## by `configure', and some will not be used until `configure' is sure that\n## it cannot figure the result out.\n\n## The `configure' script will issue a warning when a default value is used.\n## When a variable has been set, no warning will be issued.\n\n# * `erl_xcomp_after_morecore_hook' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `__after_morecore_hook' that can be\n#   used for tracking used `malloc()' implementations core memory usage.\n#   This is currently only used by unsupported features.\n#erl_xcomp_after_morecore_hook=\n\n# * `erl_xcomp_bigendian' - `yes|no'. No default. If `yes', the target system\n#   must be big endian. If `no', little endian. This can often be\n#   automatically detected, but not always. If not automatically detected,\n#   `configure' will fail unless this variable is set. Since no default\n#   value is used, `configure' will try to figure this out automatically.\n#erl_xcomp_bigendian=\n\n# * `erl_xcomp_double_middle` - `yes|no`. No default. If `yes`, the\n#   target system must have doubles in \"middle-endian\" format. If\n#   `no`, it has \"regular\" endianness. This can often be automatically\n#   detected, but not always. If not automatically detected,\n#   `configure` will fail unless this variable is set. Since no\n#   default value is used, `configure` will try to figure this out\n#   automatically.\n#erl_xcomp_double_middle_endian\n\n# * `erl_xcomp_clock_gettime_cpu_time' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `clock_gettime()' implementation\n#   that can be used for retrieving process CPU time.\n#erl_xcomp_clock_gettime_cpu_time=\n\n# * `erl_xcomp_getaddrinfo' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `getaddrinfo()' implementation that can\n#   handle both IPv4 and IPv6.\n#erl_xcomp_getaddrinfo=\n\n# * `erl_xcomp_gethrvtime_procfs_ioctl' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `gethrvtime()' implementation and\n#   is used with procfs `ioctl()'.\n#erl_xcomp_gethrvtime_procfs_ioctl=\n\n# * `erl_xcomp_dlsym_brk_wrappers' - `yes|no'. Defaults to `no'. If `yes', the\n#   target system must have a working `dlsym(RTLD_NEXT, <S>)' implementation\n#   that can be used on `brk' and `sbrk' symbols used by the `malloc()'\n#   implementation in use, and by this track the `malloc()' implementations\n#   core memory usage. This is currently only used by unsupported features.\n#erl_xcomp_dlsym_brk_wrappers=\n\n# * `erl_xcomp_kqueue' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `kqueue()' implementation that returns a file\n#   descriptor which can be used by `poll()' and/or `select()'. If `no' and\n#   the target system has not got `epoll()' or `/dev/poll', the kernel-poll\n#   feature will be disabled.\n#erl_xcomp_kqueue=\n\n# * `erl_xcomp_linux_clock_gettime_correction' - `yes|no'. Defaults to `yes' on\n#   Linux; otherwise, `no'. If `yes', `clock_gettime(CLOCK_MONOTONIC, _)' on\n#   the target system must work. This variable is recommended to be set to\n#   `no' on Linux systems with kernel versions less than 2.6.\n#erl_xcomp_linux_clock_gettime_correction=\n\n# * `erl_xcomp_linux_nptl' - `yes|no'. Defaults to `yes' on Linux; otherwise,\n#   `no'. If `yes', the target system must have NPTL (Native POSIX Thread\n#   Library). Older Linux systems have LinuxThreads instead of NPTL (Linux\n#   kernel versions typically less than 2.6).\n#erl_xcomp_linux_nptl=\n\n# * `erl_xcomp_linux_usable_sigaltstack' - `yes|no'. Defaults to `yes' on Linux;\n#   otherwise, `no'. If `yes', `sigaltstack()' must be usable on the target\n#   system. `sigaltstack()' on Linux kernel versions less than 2.4 are\n#   broken.\n#erl_xcomp_linux_usable_sigaltstack=\n\n# * `erl_xcomp_linux_usable_sigusrx' - `yes|no'. Defaults to `yes'. If `yes',\n#   the `SIGUSR1' and `SIGUSR2' signals must be usable by the ERTS. Old\n#   LinuxThreads thread libraries (Linux kernel versions typically less than\n#   2.2) used these signals and made them unusable by the ERTS.\n#erl_xcomp_linux_usable_sigusrx=\n\n# * `erl_xcomp_poll' - `yes|no'. Defaults to `no' on Darwin/MacOSX; otherwise,\n#   `yes'. If `yes', the target system must have a working `poll()'\n#   implementation that also can handle devices. If `no', `select()' will be\n#   used instead of `poll()'.\n#erl_xcomp_poll=\n\n# * `erl_xcomp_putenv_copy' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a `putenv()' implementation that stores a copy of the\n#   key/value pair.\n#erl_xcomp_putenv_copy=\n\n# * `erl_xcomp_reliable_fpe' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have reliable floating point exceptions.\n#erl_xcomp_reliable_fpe=\n\n## -----------------------------------------------------------------------------\n",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/xcomp/erl-xcomp-vxworks_ppc32.conf": "## -*-shell-script-*-\n##\n## %CopyrightBegin%\n##\n## Copyright Ericsson AB 2009-2012. All Rights Reserved.\n##\n## Licensed under the Apache License, Version 2.0 (the \"License\");\n## you may not use this file except in compliance with the License.\n## You may obtain a copy of the License at\n##\n##     http://www.apache.org/licenses/LICENSE-2.0\n##\n## Unless required by applicable law or agreed to in writing, software\n## distributed under the License is distributed on an \"AS IS\" BASIS,\n## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n## See the License for the specific language governing permissions and\n## limitations under the License.\n##\n## %CopyrightEnd%\n##\n## File: erl-xcomp-vxworks_ppc32.conf\n## Author: Rickard Green/Patrik Nyblom\n##\n## -----------------------------------------------------------------------------\n## When cross compiling Erlang/OTP using `otp_build', copy this file and set\n## the variables needed below. Then pass the path to the copy of this file as\n## an argument to `otp_build' in the configure stage:\n##   `otp_build configure --xcomp-conf=<FILE>'\n## -----------------------------------------------------------------------------\n\n## Note that you cannot define arbitrary variables in a cross compilation\n## configuration file. Only the ones listed below will be guaranteed to be\n## visible throughout the whole execution of all `configure' scripts. Other\n## variables needs to be defined as arguments to `configure' or exported in\n## the environment.\n\n## -- Variables for `otp_build' Only -------------------------------------------\n\n## Variables in this section are only used, when configuring Erlang/OTP for\n## cross compilation using `$ERL_TOP/otp_build configure'.\n\n## *NOTE*! These variables currently have *no* effect if you configure using\n## the `configure' script directly.\n\n# * `erl_xcomp_build' - The build system used. This value will be passed as\n#   `--build=$erl_xcomp_build' argument to the `configure' script. It does\n#   not have to be a full `CPU-VENDOR-OS' triplet, but can be. The full\n#   `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_build'. If set to `guess',\n#   the build system will be guessed using\n#   `$ERL_TOP/erts/autoconf/config.guess'.\nerl_xcomp_build=guess\n\n# * `erl_xcomp_host' - Cross host/target system to build for. This value will\n#   be passed as `--host=$erl_xcomp_host' argument to the `configure' script.\n#   It does not have to be a full `CPU-VENDOR-OS' triplet, but can be. The\n#   full `CPU-VENDOR-OS' triplet will be created by\n#   `$ERL_TOP/erts/autoconf/config.sub $erl_xcomp_host'.\nerl_xcomp_host=powerpc-wrs-vxworks\n\n# * `erl_xcomp_configure_flags' - Extra configure flags to pass to the\n#   `configure' script.\nerl_xcomp_configure_flags=\"--disable-threads --without-termcap\"\n\n## -- Cross Compiler and Other Tools -------------------------------------------\n\n## If the cross compilation tools are prefixed by `<HOST>-' you probably do\n## not need to set these variables (where `<HOST>' is what has been passed as\n## `--host=<HOST>' argument to `configure').\n\n## All variables in this section can also be used when native compiling.\n\n# * `CC' - C compiler.\nCC=\"$WIND_BASE/gnu/3.4.4-vxworks-6.3/$WIND_HOST_TYPE/bin/ccppc\"\n\n# * `CFLAGS' - C compiler flags.\nCFLAGS=\"-DCPU=PPC32 -DTOOL_FAMILY=gnu -DTOOL=gnu -DWANT_NONBLOCKING -DHAVE_SENS -DHAVE_MEMMOVE -DVXWORKS -I$WIND_BASE/vxworks-6.3/target/h -I$WIND_BASE/gnu/3.4.4-vxworks-6.3/$WIND_HOST_TYPE/lib/gcc/powerpc-wrs-vxworks/3.4.4/include -I$WIND_BASE/vxworks-6.3/target/h/wrn/coreip -I$WIND_BASE/vxworks-6.3/target/h -mstrict-align -fvolatile -fno-builtin -mlongcall\"\n\n# * `STATIC_CFLAGS' - Static C compiler flags.\n#STATIC_CFLAGS=\n\n# * `CFLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for the shared libraries. Note that this actually is a\n#   linker flag, but it needs to be passed via the compiler.\n#CFLAG_RUNTIME_LIBRARY_PATH=\n\n# * `CPP' - C pre-processor.\nCPP=\"$CC $CFLAGS -E\"\n\n# * `CPPFLAGS' - C pre-processor flags.\n#CPPFLAGS=\n\n# * `CXX' - C++ compiler.\n#CXX=\n\n# * `CXXFLAGS' - C++ compiler flags.\n#CXXFLAGS=\n\n# * `LD' - Linker.\nLD=\"$WIND_BASE/gnu/3.4.4-vxworks-6.3/$WIND_HOST_TYPE/bin/ldppc\"\n\n# * `LDFLAGS' - Linker flags.\nLDFLAGS=\"-mlongcall\"\n\n# * `LIBS' - Libraries.\n#LIBS=\n\n## -- *D*ynamic *E*rlang *D*river Linking --\n\n## *NOTE*! Either set all or none of the `DED_LD*' variables.\n\n# * `DED_LD' - Linker for Dynamically loaded Erlang Drivers.\n#DED_LD=\n\n# * `DED_LDFLAGS' - Linker flags to use with `DED_LD'.\n#DED_LDFLAGS=\n\n# * `DED_LD_FLAG_RUNTIME_LIBRARY_PATH' - This flag should set runtime library\n#   search path for shared libraries when linking with `DED_LD'.\n#DED_LD_FLAG_RUNTIME_LIBRARY_PATH=\n\n## -- Large File Support --\n\n## *NOTE*! Either set all or none of the `LFS_*' variables.\n\n# * `LFS_CFLAGS' - Large file support C compiler flags.\n#LFS_CFLAGS=\n\n# * `LFS_LDFLAGS' - Large file support linker flags.\n#LFS_LDFLAGS=\n\n# * `LFS_LIBS' - Large file support libraries.\n#LFS_LIBS=\n\n## -- Other Tools --\n\n# * `RANLIB' - `ranlib' archive index tool.\nRANLIB=\"$WIND_BASE/gnu/3.4.4-vxworks-6.3/$WIND_HOST_TYPE/bin/ranlibppc\"\n\n# * `AR' - `ar' archiving tool.\nAR=\"$WIND_BASE/gnu/3.4.4-vxworks-6.3/$WIND_HOST_TYPE/bin/arppc\"\n\n# * `GETCONF' - `getconf' system configuration inspection tool. `getconf' is\n#   currently used for finding out large file support flags to use, and\n#   on Linux systems for finding out if we have an NPTL thread library or\n#   not.\n#GETCONF=\n\n## -- Cross System Root Locations ----------------------------------------------\n\n# * `erl_xcomp_sysroot' - The absolute path to the system root of the cross\n#   compilation environment. Currently, the `crypto', `odbc', `ssh' and\n#   `ssl' applications need the system root. These applications will be\n#   skipped if the system root has not been set. The system root might be\n#   needed for other things too. If this is the case and the system root\n#   has not been set, `configure' will fail and request you to set it.\n#erl_xcomp_sysroot=\n\n# * `erl_xcomp_isysroot' - The absolute path to the system root for includes\n#   of the cross compilation environment. If not set, this value defaults\n#   to `$erl_xcomp_sysroot', i.e., only set this value if the include system\n#   root path is not the same as the system root path.\n#erl_xcomp_isysroot=\n\n## -- Optional Feature, and Bug Tests ------------------------------------------\n\n## These tests cannot (always) be done automatically when cross compiling. You\n## usually do not need to set these variables. Only set these if you really\n## know what you are doing.\n\n## Note that some of these values will override results of tests performed\n## by `configure', and some will not be used until `configure' is sure that\n## it cannot figure the result out.\n\n## The `configure' script will issue a warning when a default value is used.\n## When a variable has been set, no warning will be issued.\n\n# * `erl_xcomp_after_morecore_hook' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `__after_morecore_hook' that can be\n#   used for tracking used `malloc()' implementations core memory usage.\n#   This is currently only used by unsupported features.\n#erl_xcomp_after_morecore_hook=\n\n# * `erl_xcomp_bigendian' - `yes|no'. No default. If `yes', the target system\n#   must be big endian. If `no', little endian. This can often be\n#   automatically detected, but not always. If not automatically detected,\n#   `configure' will fail unless this variable is set. Since no default\n#   value is used, `configure' will try to figure this out automatically.\nerl_xcomp_bigendian=yes\n\n# * `erl_xcomp_double_middle_endian` - `yes|no`. No default. If `yes`, the\n#   target system must have doubles in \"middle-endian\" format. If\n#   `no`, it has \"regular\" endianness. This can often be automatically\n#   detected, but not always. If not automatically detected,\n#   `configure` will fail unless this variable is set. Since no\n#   default value is used, `configure` will try to figure this out\n#   automatically.\n#erl_xcomp_double_middle_endian\n\n# * `erl_xcomp_clock_gettime_cpu_time' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `clock_gettime()' implementation\n#   that can be used for retrieving process CPU time.\n#erl_xcomp_clock_gettime_cpu_time=\n\n# * `erl_xcomp_getaddrinfo' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `getaddrinfo()' implementation that can\n#   handle both IPv4 and IPv6.\n#erl_xcomp_getaddrinfo=\n\n# * `erl_xcomp_gethrvtime_procfs_ioctl' - `yes|no'. Defaults to `no'. If `yes',\n#   the target system must have a working `gethrvtime()' implementation and\n#   is used with procfs `ioctl()'.\n#erl_xcomp_gethrvtime_procfs_ioctl=\n\n# * `erl_xcomp_dlsym_brk_wrappers' - `yes|no'. Defaults to `no'. If `yes', the\n#   target system must have a working `dlsym(RTLD_NEXT, <S>)' implementation\n#   that can be used on `brk' and `sbrk' symbols used by the `malloc()'\n#   implementation in use, and by this track the `malloc()' implementations\n#   core memory usage. This is currently only used by unsupported features.\n#erl_xcomp_dlsym_brk_wrappers=\n\n# * `erl_xcomp_kqueue' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a working `kqueue()' implementation that returns a file\n#   descriptor which can be used by `poll()' and/or `select()'. If `no' and\n#   the target system has not got `epoll()' or `/dev/poll', the kernel-poll\n#   feature will be disabled.\n#erl_xcomp_kqueue=\n\n# * `erl_xcomp_linux_clock_gettime_correction' - `yes|no'. Defaults to `yes' on\n#   Linux; otherwise, `no'. If `yes', `clock_gettime(CLOCK_MONOTONIC, _)' on\n#   the target system must work. This variable is recommended to be set to\n#   `no' on Linux systems with kernel versions less than 2.6.\n#erl_xcomp_linux_clock_gettime_correction=\n\n# * `erl_xcomp_linux_nptl' - `yes|no'. Defaults to `yes' on Linux; otherwise,\n#   `no'. If `yes', the target system must have NPTL (Native POSIX Thread\n#   Library). Older Linux systems have LinuxThreads instead of NPTL (Linux\n#   kernel versions typically less than 2.6).\n#erl_xcomp_linux_nptl=\n\n# * `erl_xcomp_linux_usable_sigaltstack' - `yes|no'. Defaults to `yes' on Linux;\n#   otherwise, `no'. If `yes', `sigaltstack()' must be usable on the target\n#   system. `sigaltstack()' on Linux kernel versions less than 2.4 are\n#   broken.\n#erl_xcomp_linux_usable_sigaltstack=\n\n# * `erl_xcomp_linux_usable_sigusrx' - `yes|no'. Defaults to `yes'. If `yes',\n#   the `SIGUSR1' and `SIGUSR2' signals must be usable by the ERTS. Old\n#   LinuxThreads thread libraries (Linux kernel versions typically less than\n#   2.2) used these signals and made them unusable by the ERTS.\n#erl_xcomp_linux_usable_sigusrx=\n\n# * `erl_xcomp_poll' - `yes|no'. Defaults to `no' on Darwin/MacOSX; otherwise,\n#   `yes'. If `yes', the target system must have a working `poll()'\n#   implementation that also can handle devices. If `no', `select()' will be\n#   used instead of `poll()'.\n#erl_xcomp_poll=\n\n# * `erl_xcomp_putenv_copy' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have a `putenv()' implementation that stores a copy of the\n#   key/value pair.\n#erl_xcomp_putenv_copy=\n\n# * `erl_xcomp_reliable_fpe' - `yes|no'. Defaults to `no'. If `yes', the target\n#   system must have reliable floating point exceptions.\n#erl_xcomp_reliable_fpe=\n\n## -----------------------------------------------------------------------------\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/oam/snmp_model_1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/oam/snmp_model_3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/oam/terminology.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/oam/snmp_model_2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/tutorial/port_driver.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/tutorial/port.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/design_principles/dist3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/design_principles/dist5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/design_principles/dist4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/design_principles/code_lock_2.dia",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/design_principles/dist2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/design_principles/dist1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/design_principles/inclappls.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/design_principles/sup6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/design_principles/sup4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/design_principles/clientserver.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/design_principles/code_lock.dia",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/system/doc/design_principles/sup5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/bootstrap/bin/no_dot_erlang.boot",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/bootstrap/bin/start.boot",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/bootstrap/bin/start_clean.boot",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/erl_prim_loader.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/erl_init.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/socket.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/zlib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/prim_zip.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/otp_ring0.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/persistent_term.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/atomics.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/prim_eval.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/prim_net.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/erts_code_purger.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/counters.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/erts_dirty_process_signal_handler.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/prim_buffer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/erl_tracer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/prim_inet.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/erts_literal_area_collector.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/prim_file.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/erlang.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/init.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/preloaded/ebin/erts_internal.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/test/nt_SUITE_data/nt_info.c",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/test/erl_print_SUITE_data/erl_print_tests.c",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/test/erl_print_SUITE_data/character_test.h",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/test/erl_print_SUITE_data/string_test.h",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/test/erl_print_SUITE_data/snprintf_test.h",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/etc/win32/hrl_icon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/etc/win32/erl_icon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/etc/win32/beam_icon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/etc/win32/toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/etc/win32/erlang.ico",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/etc/win32/beam.rc",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/etc/win32/cygwin_tools/vc/ld_wrap.c",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/etc/win32/cygwin_tools/vc/cc_wrap.c",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/etc/win32/nsis/custom_modern.exe",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/etc/win32/nsis/erlang_inst.ico",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/etc/win32/nsis/erlang_uninst.ico",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/doc/src/erl_fix_alloc.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/doc/src/erl_ext_fig.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/internal_doc/figures/gc-start.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/internal_doc/figures/gc-rootset-scan.dia",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/internal_doc/figures/gc-watermark.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/internal_doc/figures/gc-watermark-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/internal_doc/figures/gc-heap-stop.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/internal_doc/figures/gc-heap-scan1.dia",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/internal_doc/figures/gc-rootset-scan.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/internal_doc/figures/gc-start.dia",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/internal_doc/figures/gc-watermark-2.dia",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/internal_doc/figures/gc-heap-scan1.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/internal_doc/figures/gc-watermark.dia",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/internal_doc/figures/gc-heap-stop.dia",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/pcre/pcre_latin_1_table.c",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/pcre/pcre-8.43.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/test/send_term_SUITE_data/ext_terms.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/test/map_SUITE_data/badmap_17.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/hipe/hipe_x86.c",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/hipe/hipe_amd64.c",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/erts/emulator/hipe/hipe_amd64_abi.txt",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_kernel_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_frag_hash.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_app.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_index.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_backend_type.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_sp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_dumper.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_event.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_locker.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_loader.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_bup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_text.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_registry.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_subscr.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_checkpoint_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_frag.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_snmp_hook.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_log.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_late_loader.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_monitor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_checkpoint.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_tm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_schema.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_ext_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_controller.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_recover.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/ebin/mnesia_backup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/doc/src/company.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/mnesia/doc/misc/implementation.txt",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/tls_connection_1_3.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_v3.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_listen_tracker_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/tls_record.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/tls_handshake_1_3.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_record.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/tls_socket.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_connection.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_certificate.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_crl_cache_api.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/tls_sender.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_dist_connection_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_config.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/dtls_packet_demux.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_dist_admin_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_pkix_db.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/tls_record_1_3.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_crl_cache.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_manager.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/inet_tls_dist.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_crl_hash_dir.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_crl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_session_cache.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_logger.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_alert.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/tls_v1.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_dist_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/dtls_connection.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_handshake.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/tls_connection_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_session.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/dtls_socket.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_pem_cache.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/dtls_connection_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_srp_primes.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/dtls_listener_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_cipher_format.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/dtls_handshake.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/tls_handshake.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_connection_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/dtls_v1.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_dh_groups.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_admin_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_session_cache_api.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/tls_connection.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_cipher.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/inet6_tls_dist.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/dtls_record.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/ebin/ssl_app.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssl/examples/ebin/client_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_run.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_config_xml.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_gen_conn.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_ssh.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_slave.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/unix_telnet.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/test_server_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/erl2html2.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_framework.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_hooks_lock.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_master_event.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_telnet.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_rpc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_ftp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/test_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_telnet_client.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_master_logs.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_config.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/test_server_gl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_config_plain.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/cth_conn_log.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_release_test.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_property_test.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_conn_log_h.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_testspec.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_hooks.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_cover.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_default_gl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_netconfc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_event.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/cth_log_redirect.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/test_server_ctrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/cth_surefire.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_repeat.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_groups.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/test_server_io.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_logs.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_master_status.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_util.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_snmp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_master.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/ct_make.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/ebin/test_server_node.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/priv/tile1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/doc/src/config.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/doc/src/tc_execution.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/doc/src/html_logs.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/common_test/doc/src/filestruct.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/public_key/ebin/OTP-PUB-KEY.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/public_key/ebin/pubkey_cert.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/public_key/ebin/public_key.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/public_key/ebin/PKCS-FRAME.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/public_key/ebin/pubkey_cert_records.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/public_key/ebin/pubkey_ssh.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/public_key/ebin/pubkey_pem.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/public_key/ebin/pubkey_pbe.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/public_key/ebin/pubkey_crl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/public_key/test/pkits_SUITE_data/pkits/certs/TrustAnchorRootCertificate.crt",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/public_key/asn1/OTP-PUB-KEY.asn1db",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/public_key/asn1/PKCS-FRAME.asn1db",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc_tags.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc_macros.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc_scanner.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc_parser.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc_doclet.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc_extract.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc_layout.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc_data.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc_types.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc_wiki.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc_specs.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc_report.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc_refs.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/ebin/edoc_run.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/priv/erlang.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/test/edoc_SUITE_data/un2.erl",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/test/edoc_SUITE_data/un1.erl",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/test/edoc_SUITE_data/un3.erl",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/edoc/test/edoc_SUITE_data/un_atom1.erl",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_supervisor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_mib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_local_db.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_trap.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_net_if.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_mib_storage_mnesia.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_server_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_target_cache.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_conf.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_net_if_mt.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_discovery_handler_default.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_acm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_misc_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpc_tok.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_svbl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_authentication_service.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_app.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_error_io.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_conf.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_mpd.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_set_mechanism.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_notification_delivery_info_receiver.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_standard_mib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_network_interface_filter.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_mib_storage_ets.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_user_old.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_log.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_mpd.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_conf.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_user_default.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_usm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_misc_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_agent_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_get.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_app.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_note_store.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_shadow_table.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_view_based_acm_mib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_set.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_error_report.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_get_mechanism.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_config.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_net_if.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_mib_storage_dets.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_error.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_net_if_filter.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_network_interface.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_usm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_user_based_sm_mib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_generic_mnesia.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_index.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_target_mib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_symbolic_store.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_mib_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_vacm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_network_interface.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_verbosity.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_config.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_mib_data.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_generic.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_community_mib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_agent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpc_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_net_if_filter.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpc_misc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_pdus.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_error_logger.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_user.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_notification_mib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_supervisor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_usm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_mini_mib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_set_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpc_mib_to_hrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_mib_storage.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_discovery_handler.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_framework_mib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_get_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_notification_filter.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_app_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmp_misc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpm_network_interface_filter.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpa_mib_data_tttn.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/ebin/snmpc_mib_gram.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/SNMP-VIEW-BASED-ACM-MIB.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/SNMP-USM-AES-MIB.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/TRANSPORT-ADDRESS-MIB.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/OTP-REG.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/SNMP-TARGET-MIB.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/RFC1213-MIB.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/SNMPv2-TM.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/SNMP-COMMUNITY-MIB.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/STANDARD-MIB.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/SNMP-NOTIFICATION-MIB.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/SNMPv2-MIB.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/SNMP-FRAMEWORK-MIB.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/INET-ADDRESS-MIB.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/SNMP-MPD-MIB.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/OTP-SNMPEA-MIB.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/SNMP-USER-BASED-SM-MIB.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/priv/mibs/OTP-TC.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/test/exp/snmp_agent_v3_test.erl",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/test/exp/snmp_agent_v1_test.erl",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/test/exp/snmp_agent_v2_test.erl",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/test/exp/snmp_agent_mt_test.erl",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/test/exp/snmp_agent_bl_test.erl",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/test/exp/snmp_agent_ms_test.erl",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/test/snmp_to_snmpnet_SUITE_data/TestTrapv2.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/examples/ex2/snmp_ex2_simple_standard_test.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/examples/ex2/snmp_ex2_manager.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/examples/ex1/ex1.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/examples/ex1/EX1-MIBv2.mib",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/examples/ex1/EX1-MIB.bin",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/doc/src/MIB_mechanism.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/doc/src/getnext4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/doc/src/getnext2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/doc/src/getnext1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/doc/src/snmp-um-1-image-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/doc/src/structure.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/doc/src/snmp_manager_netif_1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/doc/src/snmp_agent_netif_1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/doc/src/snmp-um-1-image-8.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/doc/src/snmp-um-1-image-3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/doc/src/getnext3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/snmp/doc/src/snmp-um-1-image-2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tftp/ebin/tftp_binary.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tftp/ebin/tftp_logger.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tftp/ebin/tftp_app.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tftp/ebin/tftp_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tftp/ebin/tftp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tftp/ebin/tftp_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tftp/ebin/tftp_engine.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tftp/ebin/tftp_file.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMessageDialog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxEraseEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxCalendarDateAttr.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxTreebook.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGraphicsFont.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGridCellNumberRenderer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMenu.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxAuiDockArt.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxTreeCtrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxFont.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxLayoutAlgorithm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxScrolledWindow.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxe_util.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxBitmap.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxStyledTextCtrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxProgressDialog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxCloseEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxFocusEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxAcceleratorTable.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMirrorDC.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSplitterEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPrintData.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMenuItem.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMemoryDC.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxControlWithItems.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxContextMenuEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxTopLevelWindow.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxInitDialogEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxClipboardTextEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxFlexGridSizer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxScrollEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxTextDataObject.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxStaticLine.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxImageList.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxFontPickerCtrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPrintDialogData.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxLogNull.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxColourDialog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxIconBundle.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxDropFilesEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxDatePickerCtrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wx_object.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxHtmlLinkEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGCDC.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxToggleButton.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxNotebook.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxListCtrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxFontData.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMenuBar.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxComboBox.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSingleChoiceDialog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxFontDialog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMDIChildFrame.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxListbook.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPaletteChangedEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxBrush.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGraphicsPen.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGraphicsPath.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxAuiNotebookEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMouseCaptureLostEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPen.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGridBagSizer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxStyledTextEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSizerFlags.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxToolBar.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxCheckBox.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxHelpEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxStaticBox.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPopupWindow.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxFileDataObject.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPreviewFrame.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSlider.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGridCellRenderer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxRadioBox.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxEvtHandler.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxFileDialog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPasswordEntryDialog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxToolbook.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxFileDirPickerEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPostScriptDC.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMDIParentFrame.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGraphicsBrush.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGridCellChoiceEditor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxUpdateUIEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxDateEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxWindowCreateEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGenericDirCtrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxArtProvider.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxRegion.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxClipboard.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxStaticText.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPaintEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxTextAttr.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxIcon.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGridEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxAuiTabArt.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxAuiSimpleTabArt.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPrintout.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxScreenDC.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSplashScreen.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxListEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxBitmapDataObject.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxTreeEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxWindowDestroyEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxDisplayChangedEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPreviewControlBar.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxLocale.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxDisplay.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPopupTransientWindow.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxCheckListBox.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxTextCtrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxHtmlWindow.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxImage.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxe_master.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGrid.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGraphicsRenderer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGridCellFloatRenderer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxCommandEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxListItem.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxNavigationKeyEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxQueryNewPaletteEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/gl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxFilePickerCtrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxWindow.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSetCursorEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxStdDialogButtonSizer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxRadioButton.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxClientDC.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wx_misc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxe_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxColourData.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSystemSettings.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPickerBase.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSpinCtrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxListBox.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxChildFocusEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxStatusBar.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxTextEntryDialog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSpinEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPalette.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxChoicebook.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxStaticBitmap.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxDataObject.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxFindReplaceData.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxDialog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSizer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxAcceleratorEntry.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxActivateEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxJoystickEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxCalendarEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPageSetupDialog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxKeyEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSplitterWindow.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSashEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxBufferedDC.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxDC.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxBoxSizer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGLCanvas.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxAuiManager.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxCalendarCtrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGridCellNumberEditor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxButton.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxFindReplaceDialog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxOverlay.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMouseCaptureChangedEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMoveEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMDIClientWindow.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGBSizerItem.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPanel.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxXmlResource.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxTaskBarIcon.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxChoice.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSashLayoutWindow.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGauge.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSizerItem.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPageSetupDialogData.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxScrollWinEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPaintDC.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGridCellTextEditor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxListItemAttr.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxControl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGridCellEditor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGridCellStringRenderer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxWindowDC.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxCursor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGridCellBoolEditor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxListView.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxIconizeEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMouseEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxAuiNotebook.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGridSizer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGraphicsContext.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxToolTip.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/glu.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxDirPickerCtrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGridCellBoolRenderer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPrinter.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGridCellFloatEditor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGridCellAttr.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxBitmapButton.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxStaticBoxSizer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPrintDialog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMultiChoiceDialog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxCaret.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxNotebookEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGraphicsMatrix.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxScrollBar.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSizeEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMask.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMenuEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPreviewCanvas.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxFrame.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxDirDialog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxBufferedPaintDC.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSashWindow.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxAuiPaneInfo.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxDCOverlay.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxIdleEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxColourPickerEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSpinButton.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxAuiManagerEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMaximizeEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxFontPickerEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxShowEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxPrintPreview.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxGraphicsObject.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSysColourChangedEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxNotifyEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxColourPickerCtrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxTaskBarIconEvent.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxSystemOptions.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxMiniFrame.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/ebin/wxHtmlEasyPrinting.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/priv/erlang-logo64.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/priv/erlang-logo128.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/priv/erlang-logo32.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_splitterWindow.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/erlang.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_static.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_sashWindow.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/demo.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_choices.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_graphicsContext.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_gl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_popupMenu.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_slider.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_textCtrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_dialogs.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_gauge.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_treeCtrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_button.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_notebook.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/demo_html_tagger.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_frame_utils.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_htmlWindow.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_canvas.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_grid.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_sizers.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_aui.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_radioBox.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_listCtrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_cursor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_pickers.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/demo/ex_canvas_paint.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/sudoku/sudoku_board.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/sudoku/sudoku_gui.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/sudoku/sudoku_game.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/sudoku/sudoku.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/simple/minimal.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/simple/hello2.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/simple/hello.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/simple/menu.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/xrc/xrc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/xrc/rc/filesave.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/xrc/rc/throbber.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/xrc/rc/appicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/xrc/rc/update.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/xrc/rc/quotes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/xrc/rc/fuzzy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/wx/examples/xrc/rc/fileopen.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/wrap_log_reader.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/erl_distribution.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/gen_tcp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/hipe_unified_loader.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet_hosts.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet_sctp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet_res.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/application.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/erts_debug.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/logger_disk_log_h.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/standard_error.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet_tcp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/net.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/code_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet_dns.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/group_history.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet6_sctp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/logger_proxy.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/logger_backend.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/global_group.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/user_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/erl_epmd.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/erl_compile_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/local_udp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet_tcp_dist.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet_config.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/logger_std_h.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/rpc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet6_tcp_dist.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/user.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/kernel.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/dist_ac.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/erl_boot_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/logger_handler_watcher.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/erl_ddll.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/logger_formatter.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/raw_file_io_delayed.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/disk_log_1.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/file_io_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/logger_olp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/logger_config.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/pg2.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/logger_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/application_starter.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/net_kernel.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/seq_trace.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/file.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/raw_file_io_inflate.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/dist_util.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/heart.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/raw_file_io_raw.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/disk_log.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/gen_udp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet_udp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/logger_h_common.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet6_tcp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/application_master.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/logger_simple_h.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/error_logger.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/logger_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/kernel_refc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/os.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/user_drv.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/global_search.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/kernel_config.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/net_adm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/file_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/raw_file_io_list.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/logger.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/disk_log_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/group.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/code.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet_parse.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet_db.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/global.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/raw_file_io.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/erl_signal_handler.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/erl_reply.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/local_tcp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/gen_sctp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/application_controller.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/ram_file.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/error_handler.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/logger_filters.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet6_udp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/raw_file_io_deflate.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/inet_gethost_native.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/disk_log_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/raw_file_io_compressed.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/ebin/auth.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/os_SUITE_data/win32/abin/hello.exe",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/os_SUITE_data/win32/abin/my_ascii.com",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/prim_file_SUITE_data/corrupted.gz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/prim_file_SUITE_data/realmen.html.gz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/code_SUITE_data/clash/zork-0.8.ez",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/code_SUITE_data/clash/foobar-0.1.ez",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/file_SUITE_data/corrupted.gz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/file_SUITE_data/cooked_tar_problem.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/file_SUITE_data/realmen.html.gz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/disk_log_SUITE_data/kurt2.LOG.2",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/disk_log_SUITE_data/kurt.LOG.4",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/disk_log_SUITE_data/kurt.LOG.3",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/disk_log_SUITE_data/kurt2.LOG.1",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/disk_log_SUITE_data/kurt.LOG.1",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/disk_log_SUITE_data/old_terms.LOG",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/disk_log_SUITE_data/kurt2.LOG.3",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/disk_log_SUITE_data/kurt2.LOG.4",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/disk_log_SUITE_data/kurt.LOG.2",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/zlib_SUITE_data/zipdoc.txt.gz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/zlib_SUITE_data/zipdoc.1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/zlib_SUITE_data/png-compressed.zlib",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/zlib_SUITE_data/zipdoc.zip",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/ram_file_SUITE_data/corrupted.gz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/test/ram_file_SUITE_data/realmen.html.gz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/doc/src/logger_arch.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/kernel/doc/src/logger_arch.dia",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/runtime_tools/ebin/ttb_autostart.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/runtime_tools/ebin/runtime_tools.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/runtime_tools/ebin/dyntrace.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/runtime_tools/ebin/erts_alloc_config.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/runtime_tools/ebin/system_information.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/runtime_tools/ebin/appmon_info.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/runtime_tools/ebin/observer_backend.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/runtime_tools/ebin/scheduler.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/runtime_tools/ebin/dbg.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/runtime_tools/ebin/runtime_tools_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/runtime_tools/ebin/msacc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_transport_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_gen.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_dbg.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_dist.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_service_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_sctp_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_traffic.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_transport.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_dict_scanner.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_make.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_gen_relay.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_sync.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_misc_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_tcp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_peer_fsm_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_gen_base_accounting.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_codec.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_etcp_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_etcp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_callback.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_reg.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_stats.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_codegen.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_watchdog_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_dict_parser.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_service.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_gen_acct_rfc6733.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_gen_base_rfc3588.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_gen_base_rfc6733.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_dict_util.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_session.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_gen_doic_rfc7683.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_peer_fsm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_peer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_exprecs.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_app.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_tcp_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_capx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_info.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_types.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_watchdog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_config_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_config.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/diameter/ebin/diameter_sctp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_dataflow.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_explanation.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_coordinator.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/typer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_cl_parse.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_options.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_plt.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_succ_typings.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_typesig.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_contracts.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_worker.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_analysis_callgraph.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_callgraph.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_gui_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_codeserver.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_utils.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_race_data_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_races.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_cl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_timing.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_dep.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/dialyzer/ebin/dialyzer_behaviours.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/ebin/et_viewer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/ebin/et_selector.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/ebin/et_wx_viewer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/ebin/et_collector.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/ebin/et_wx_contents_viewer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/ebin/et.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/examples/et_demo.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/examples/et_trace_demo.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/examples/et_display_demo.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/doc/src/sim_trans_contents_viewer_mgr_actors.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/doc/src/sim_trans_contents_viewer_collector.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/doc/src/coffee_order.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/doc/src/sim_trans_move_actor.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/doc/src/sim_trans_mgr_actors.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/doc/src/sim_trans.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/doc/src/megaco_tracer.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/doc/src/sim_trans_write_lock.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/doc/src/megaco_filter.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/doc/src/megaco_collector.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/et/doc/src/live_trans.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/os_mon/ebin/cpu_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/os_mon/ebin/memsup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/os_mon/ebin/os_mon_sysinfo.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/os_mon/ebin/disksup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/os_mon/ebin/os_mon.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/os_mon/ebin/nteventlog.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/os_mon/ebin/os_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eunit/ebin/eunit_proc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eunit/ebin/eunit_tty.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eunit/ebin/eunit_surefire.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eunit/ebin/eunit_listener.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eunit/ebin/eunit_autoexport.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eunit/ebin/eunit_serial.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eunit/ebin/eunit_test.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eunit/ebin/eunit_striptests.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eunit/ebin/eunit_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eunit/ebin/eunit_tests.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eunit/ebin/eunit_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eunit/ebin/eunit.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eunit/ebin/eunit_data.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eunit/test/tlatin.erl",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/reltool/ebin/reltool_fgraph_win.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/reltool/ebin/reltool_sys_win.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/reltool/ebin/reltool_fgraph.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/reltool/ebin/reltool_app_win.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/reltool/ebin/reltool_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/reltool/ebin/reltool_mod_win.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/reltool/ebin/reltool_target.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/reltool/ebin/reltool.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/reltool/ebin/reltool_utils.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/systools_make.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/sasl_report_tty_h.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/rb_format_supp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/systools_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/erlsrv.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/systools_rc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/release_handler_1.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/alarm_handler.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/systools.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/release_handler.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/sasl_report.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/sasl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/systools_relup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/sasl_report_file_h.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/misc_supp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/format_lib_supp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/ebin/rb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/sasl/examples/ebin/target_system.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/cerl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_clean.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_ssa_dead.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_ssa_opt.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_utils.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/sys_core_alias.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_disasm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_ssa_bsm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_opcodes.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/v3_core.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_a.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_ssa_lint.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/core_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/compile.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_ssa_recv.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_ssa_codegen.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_ssa_pp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_z.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_jump.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/erl_bifs.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/core_scan.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/sys_core_fold.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/cerl_trees.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_flatten.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_ssa_pre_codegen.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_dict.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/sys_core_fold_lists.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_ssa_funs.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_ssa_share.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/cerl_clauses.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_block.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/v3_kernel.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_validator.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/cerl_sets.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/core_pp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_except.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/cerl_inline.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_ssa_type.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_ssa.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/sys_core_inline.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_listing.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_trim.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/core_parse.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/rec_env.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/sys_pre_attributes.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/v3_kernel_pp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/core_lint.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_peep.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_asm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/beam_kernel_to_ssa.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/ebin/sys_core_bsm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/compiler/test/compile_SUITE_data/key_compatibility.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpc_cookie.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpc_response.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_acceptor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_alias.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_auth_dets.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_trace.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/http_chunk.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_auth_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_acceptor_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_connection_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_get.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_custom_api.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/inets_service.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_misc_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_conf.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_manager.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_auth_mnesia.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_browser.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_security_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_log.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_range.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/inets_tftp_wrapper.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_log.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_auth_plain.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_security.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_esi.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_script_env.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_request.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpc_profile_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_response.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/inets.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_disk_log.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/inets_app.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/http_uri.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/inets_trace.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/inets_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpc_manager.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_example.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpc_handler_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_cgi.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpc_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_instance_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/http_request.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_esi.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_util.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_actions.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/http_response.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/inets_ftp_wrapper.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_socket.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_dir.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/inets_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_request_handler.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_head.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpc_request.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_responsecontrol.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_cgi.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_htaccess.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/mod_auth.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_custom.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpc_handler.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/http_util.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_file.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/httpd_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/ebin/http_transport.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/a.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/back.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/button5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/uu.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/pie0.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/pie6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/pie7.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/right.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/sound2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/hand.right.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/compressed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/ps.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/continued.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/tex.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/generic.sec.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/poweredby.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/tar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/comp.gray.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/buttonl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/generic.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/button7.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/comp.blue.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/image3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/generic.red.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/star_blank.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/image1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/quill.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/broken.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/bomb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/button1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/alert.red.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/button3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/button10.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/dir.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/pie5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/index.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/folder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/dvi.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/binhex.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/blank.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/left.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/sphere2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/box2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/icon.sheet.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/star.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/c.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/unknown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/world2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/button4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/patch.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/burst.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/button6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/layout.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/world1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/link.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/ball.red.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/pie1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/movie.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/htdig.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/sphere1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/sound1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/folder.sec.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/pie2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/script.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/uuencoded.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/pie8.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/p.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/f.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/ball.gray.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/forward.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/folder.open.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/apache_pb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/hand.up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/transfer.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/portal.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/button9.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/screw1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/button8.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/screw2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/binary.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/box1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/pie3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/alert.black.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/button2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/text.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/pie4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/buttonr.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/pdf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/down.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/icons/image2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/htdocs/open/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/htdocs/secret/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/htdocs/mnesia_secret/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/htdocs/dets_secret/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/htdocs/mnesia_open/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_SUITE_data/server_root/htdocs/dets_open/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/a.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/back.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/button5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/uu.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/pie0.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/pie6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/pie7.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/right.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/sound2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/hand.right.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/compressed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/ps.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/continued.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/tex.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/generic.sec.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/poweredby.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/tar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/comp.gray.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/buttonl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/generic.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/button7.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/comp.blue.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/image3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/generic.red.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/star_blank.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/image1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/quill.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/broken.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/bomb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/button1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/alert.red.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/button3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/button10.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/dir.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/pie5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/index.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/folder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/dvi.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/binhex.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/blank.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/left.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/sphere2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/box2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/icon.sheet.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/star.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/c.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/unknown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/world2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/button4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/patch.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/burst.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/button6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/layout.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/world1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/link.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/ball.red.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/pie1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/movie.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/htdig.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/sphere1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/sound1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/folder.sec.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/pie2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/script.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/uuencoded.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/pie8.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/p.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/f.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/ball.gray.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/forward.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/folder.open.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/apache_pb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/hand.up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/transfer.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/portal.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/button9.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/screw1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/button8.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/screw2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/binary.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/box1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/pie3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/alert.black.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/button2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/text.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/pie4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/buttonr.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/pdf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/down.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/icons/image2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/htdocs/open/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/htdocs/secret/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/htdocs/mnesia_secret/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/htdocs/dets_secret/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/htdocs/mnesia_open/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/test/httpd_test_data/server_root/htdocs/dets_open/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/httpd_load_test/hdlt.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/httpd_load_test/hdlt_logger.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/httpd_load_test/hdlt_random_html.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/httpd_load_test/hdlt_slave.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/httpd_load_test/hdlt_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/httpd_load_test/hdlt_client.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/httpd_load_test/hdlt_ctrl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/a.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/back.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/button5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/uu.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/pie0.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/pie6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/pie7.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/right.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/sound2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/hand.right.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/compressed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/ps.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/continued.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/tex.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/generic.sec.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/poweredby.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/tar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/comp.gray.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/buttonl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/generic.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/button7.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/comp.blue.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/image3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/generic.red.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/star_blank.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/image1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/quill.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/broken.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/bomb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/button1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/alert.red.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/button3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/button10.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/dir.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/pie5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/index.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/folder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/dvi.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/binhex.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/blank.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/left.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/sphere2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/box2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/icon.sheet.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/star.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/c.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/unknown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/world2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/button4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/patch.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/burst.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/button6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/layout.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/world1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/link.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/ball.red.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/pie1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/movie.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/htdig.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/sphere1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/sound1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/folder.sec.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/pie2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/script.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/uuencoded.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/pie8.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/p.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/f.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/ball.gray.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/forward.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/folder.open.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/apache_pb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/hand.up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/transfer.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/portal.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/button9.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/screw1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/button8.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/screw2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/binary.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/box1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/pie3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/alert.black.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/button2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/text.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/pie4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/buttonr.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/pdf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/down.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/icons/image2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/htdocs/open/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/htdocs/secret/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/htdocs/mnesia_secret/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/htdocs/dets_secret/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/htdocs/mnesia_open/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/examples/server_root/htdocs/dets_open/dummy.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/doc/src/marting_tankar.sdw",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/inets/doc/archive/rfc2616.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/crypto/ebin/crypto_ec_curves.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/crypto/ebin/crypto.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/crypto/test/crypto_SUITE_data/gcmtestvectors.zip",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/crypto/test/crypto_SUITE_data/aesmmt.zip",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/crypto/test/crypto_SUITE_data/cmactestvectors.zip",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/crypto/test/crypto_SUITE_data/KAT_AES.zip",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/crypto/test/crypto_SUITE_data/aes_ccm_vectors/ccmtestvectors.zip",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/erl_pp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/gen_fsm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/otp_internal.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/qlc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/array.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/edlin_expand.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/io_lib_format.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/erl_bits.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/rand.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/qlc_pt.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/escript.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/shell.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/dict.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/gen_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/uri_string.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/erl_abstract_code.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/gb_trees.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/string.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/shell_default.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/erl_anno.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/pool.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/error_logger_file_h.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/unicode_util.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/filename.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/ordsets.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/erl_compile.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/zip.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/maps.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/base64.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/erl_eval.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/unicode.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/ms_transform.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/timer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/supervisor_bridge.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/calendar.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/orddict.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/io_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/erl_posix_msg.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/dets_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/c.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/erl_tar.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/slave.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/eval_bits.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/erl_error.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/filelib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/io_lib_pretty.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/binary.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/win32reg.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/sets.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/dets_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/gen_statem.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/epp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/re.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/sys.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/beam_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/digraph.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/queue.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/proc_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/lists.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/random.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/dets_utils.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/gen.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/edlin.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/ets.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/sofs.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/supervisor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/error_logger_tty_h.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/dets_v9.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/gb_sets.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/io_lib_fread.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/erl_expand_records.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/dets.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/erl_parse.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/io.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/file_sorter.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/proplists.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/erl_lint.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/gen_event.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/erl_scan.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/math.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/digraph_utils.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/erl_internal.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/ebin/log_mf_h.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/zip_SUITE_data/test.jar",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/zip_SUITE_data/bad_eocd.zip",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/zip_SUITE_data/exploit.zip",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/zip_SUITE_data/bad_central_directory.zip",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/zip_SUITE_data/bad_crc.zip",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/zip_SUITE_data/abc.zip",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/zip_SUITE_data/bad_file_header.zip",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/tar_SUITE_data/gnu.tar",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/tar_SUITE_data/cooked_tar_problem.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/tar_SUITE_data/sparse00.tar",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/tar_SUITE_data/sparse01.tar",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/tar_SUITE_data/sparse10.tar",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/tar_SUITE_data/bsd.tar",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/dets_SUITE_data/version_9a.dets",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/dets_SUITE_data/version_8.dets",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/dets_SUITE_data/version_9b_phash.dat",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/io_proto_SUITE_data/testdata_utf16_big_bom.dat",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/io_proto_SUITE_data/testdata_utf16_little_bom.dat",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/io_proto_SUITE_data/testdata_utf32_little.dat",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/io_proto_SUITE_data/testdata_utf32_big.dat",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/io_proto_SUITE_data/testdata_utf32_big_bom.dat",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/io_proto_SUITE_data/external_utf16_little_bom.dat",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/io_proto_SUITE_data/testdata_utf32_little_bom.dat",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/io_proto_SUITE_data/testdata_latin1.dat",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/io_proto_SUITE_data/external_utf16_big_bom.dat",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/io_proto_SUITE_data/testdata_utf16_big.dat",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/stdlib/test/io_proto_SUITE_data/testdata_utf16_little.dat",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_name_resolver_prev3c.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_name_resolver_prev3b.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_udp_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_stats.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_transport.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_transformer_prev3c.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_pretty_text_encoder_v1.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_tcp_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_erl_dist_encoder_mc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_term_id_gen.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_sdp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_config.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_transformer_v3.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_text_parser_prev3b.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_ber_media_gateway_control_v2.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_name_resolver_prev3a.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_text_parser_v1.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_erl_dist_encoder.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_text_mini_decoder.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_ber_encoder.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_transformer_prev3b.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_ber_media_gateway_control_v1.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_pretty_text_encoder.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_misc_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_text_parser_prev3a.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_filter.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_per_media_gateway_control_prev3a.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_text_parser_v2.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_user_default.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_text_scanner.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_digit_map.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_ber_media_gateway_control_prev3c.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_pretty_text_encoder_v2.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_compact_text_encoder_prev3b.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_edist_compress.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_compact_text_encoder_v2.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_udp_server.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_transformer_prev3a.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_messenger_misc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_trans_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_name_resolver_v3.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_pretty_text_encoder_prev3b.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_transformer_v1.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_per_media_gateway_control_v1.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_text_mini_parser.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_term_id.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_encoder.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_ber_media_gateway_control_prev3a.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_trans_sender.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_text_parser_prev3c.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_user.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_name_resolver_v1.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_text_parser_v3.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_timer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_messenger.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_tcp_accept_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_ber_media_gateway_control_v3.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_tcp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_udp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_name_resolver_v2.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_transformer_v2.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_config_misc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_ber_media_gateway_control_prev3b.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_per_media_gateway_control_prev3c.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_tcp_connection_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_monitor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_tcp_accept.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_per_media_gateway_control_v3.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_per_encoder.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_compact_text_encoder_v3.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_per_media_gateway_control_v2.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_encoder_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_per_media_gateway_control_prev3b.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_compact_text_encoder.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_pretty_text_encoder_prev3a.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_compact_text_encoder_prev3a.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_pretty_text_encoder_prev3c.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_binary_encoder.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_tcp_connection.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_compact_text_encoder_prev3c.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_pretty_text_encoder_v3.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/ebin/megaco_compact_text_encoder_v1.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/src/flex/megaco_flex_scanner_drv.flex.src",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/examples/meas/megaco_codec_mstone2.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/examples/meas/megaco_codec_mstone_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/examples/meas/megaco_codec_transform.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/examples/meas/megaco_codec_meas.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/examples/meas/megaco_codec_mstone1.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/examples/simple/megaco_simple_mg.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/examples/simple/megaco_simple_mgc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/doc/src/single_node_config.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/doc/src/call_flow_cont.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/doc/src/megaco_sys_arch.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/doc/src/mstone1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/doc/src/MG_startup_call_flow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/doc/src/distr_node_config.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/doc/src/MGC_startup_call_flow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/doc/src/MG-startup_flow_noMID.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/doc/src/call_flow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/doc/standard/draft-ietf-megaco-h248v2-04.txt",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/megaco/doc/standard/implementors_guide_v10-13.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_no_io.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_daemon_channel.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_transport.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_info.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_shell.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_cli.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_client_channel.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_sftpd_file.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_sftp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_bits.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/sshc_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_system_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_acceptor_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_subsystem_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_sftpd.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_message.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_server_key_api.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_server_channel.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_server_channel_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_file.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_auth.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_connection.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_client_key_api.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/sshd_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_sftpd_file_api.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_dbg.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_connection_handler.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_connection_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_options.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_app.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_xfer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_channel.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_io.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/ebin/ssh_acceptor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/examples/ssh_sample_cli.erl",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ssh/doc/src/SSH_protocols.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/odbc/ebin/odbc_app.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/odbc/ebin/odbc_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/odbc/ebin/odbc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/odbc/doc/src/odbc_app_arc.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ftp/ebin/ftp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ftp/ebin/ftp_sup.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ftp/ebin/ftp_app.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ftp/ebin/ftp_progress.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/ftp/ebin/ftp_response.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/observer_tv_table.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/observer_perf_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_mod_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/etop_tr.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_persistent_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_port_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/etop.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/observer_tv_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_bin_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_timer_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_multi_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/observer_pro_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/observer_procinfo.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_info_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/observer_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/observer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/observer_trace_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_proc_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/observer_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/ttb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_sched_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/observer_app_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/observer_sys_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_term_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_virtual_list_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_gen_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/ttb_et.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/observer_port_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_atom_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_int_tab_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_fun_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_dist_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_table_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_detail_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/observer_alloc_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/observer_html_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_mem_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_html_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/observer_traceoptions_wx.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/etop_txt.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/cdv_ets_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/ebin/crashdump_viewer.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/priv/erlang_observer.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/doc/src/et_processes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/observer/doc/src/et_modsprocs.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_docgen/ebin/docgen_otp_specs.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_docgen/ebin/docgen_edoc_xml_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_docgen/ebin/docgen_xmerl_xml_cb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_docgen/priv/images/erlang-logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_docgen/priv/images/erlang-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_docgen/priv/images/erlang-old.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_docgen/priv/js/flipmenu/flip_open.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_docgen/priv/js/flipmenu/flip_closed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_docgen/priv/js/flipmenu/flip_static.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_docgen/doc/src/man.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_regexp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_xs.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_eventp.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_sax_old_dom.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_scan.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_validate.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_xpath_scan.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_text.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_otpsgml.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_xml.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_b64Bin_scan.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_sgml.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_xpath_parse.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_sax_simple_dom.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_sax_parser_utf8.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_xpath_pred.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_xpath_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_xsd_type.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_sax_parser_latin1.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_uri.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_sax_parser_utf16le.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_xsd.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_sax_parser_utf16be.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_sax_parser.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_html.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_ucs.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_xlate.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_xpath.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_simple.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_sax_parser_list.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/ebin/xmerl_b64Bin.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_std_SUITE_data/oasis.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_std_SUITE_data/xmltest.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_std_SUITE_data/japanese.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_std_SUITE_data/ibm.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_std_SUITE_data/sun.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_std_SUITE_data/w3c-copyright-19980720.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_xsd_NIST2002-01-16_SUITE_data/w3c-copyright-19990405.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_xsd_NIST2002-01-16_SUITE_data/nisttest.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_xsd_MS2002-01-16_SUITE_data/w3c-copyright-19990405.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_xsd_MS2002-01-16_SUITE_data/msxsdtest.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_xsd_Sun2002-01-16_SUITE_data/w3c-copyright-19990405.html",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_xsd_Sun2002-01-16_SUITE_data/suntest.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_SUITE_data/misc.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_SUITE_data/cpd.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_SUITE_data/eventp/CelloMOM.xml",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/test/xmerl_xsd_SUITE_data/sis/IntegratedSite.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/xmerl/doc/examples/sdocbook2xhtml.erl",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/parsetools/ebin/leex.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/parsetools/ebin/yeccparser.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/parsetools/ebin/yeccscan.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/parsetools/ebin/yecc.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_interface/test/ei_tmo_SUITE_data/ei_tmo_test.c",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_interface/test/ei_encode_SUITE_data/ei_encode_test.c",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_interface/test/erl_ext_SUITE_data/ext_test.c",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_interface/test/ei_decode_SUITE_data/ei_decode_test.c",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/erl_interface/test/ei_accept_SUITE_data/ei_accept_test.c",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eldap/ebin/ELDAPv3.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eldap/ebin/eldap.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/eldap/ebin/ELDAPv3.asn1db",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_iserver.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_wx_filedialog_win.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_wx_src_view.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_wx_break_win.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/debugger.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/int.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_wx_code.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_wx_settings.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_wx_mon.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_ieval.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_wx_view.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_debugged.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_wx_trace_win.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_wx_winman.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_wx_interpret.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_icmd.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_wx_win.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/i.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_istk.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_wx_mon_win.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_idb.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_wx_trace.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_wx_break.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/ebin/dbg_iload.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/priv/debugger.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/priv/erlang_bug.png",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/test/debugger_testdoc.fm5",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/doc/src/images/cond_break_dialog.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/doc/src/images/line_break_dialog.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/doc/src/images/function_break_dialog.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/doc/src/images/attach.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/doc/src/images/interpret.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/doc/src/images/monitor.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/debugger/doc/src/images/view.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/syntax_tools/ebin/erl_recomment.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/syntax_tools/ebin/erl_comment_scan.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/syntax_tools/ebin/erl_prettypr.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/syntax_tools/ebin/igor.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/syntax_tools/ebin/erl_syntax_lib.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/syntax_tools/ebin/erl_syntax.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/syntax_tools/ebin/epp_dodger.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/syntax_tools/ebin/merl_transform.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/syntax_tools/ebin/erl_tidy.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/syntax_tools/ebin/merl.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/syntax_tools/ebin/prettypr.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/syntax_tools/src/merl_transform.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/ebin/instrument.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/ebin/xref_parser.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/ebin/cover.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/ebin/xref.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/ebin/fprof.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/ebin/make.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/ebin/eprof.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/ebin/xref_compiler.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/ebin/xref_base.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/ebin/xref_utils.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/ebin/xref_reader.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/ebin/xref_scanner.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/ebin/cprof.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/ebin/tags.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/ebin/lcnt.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/test/lcnt_SUITE_data/big_bang_40.lcnt",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/test/lcnt_SUITE_data/ehb_3_3_hist.lcnt",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/test/xref_SUITE_data/depr_r9c.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/test/xref_SUITE_data/fun_mfa_r14.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/test/xref_SUITE_data/read/read.beam.v1",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/doc/src/venn1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/tools/doc/src/venn2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_gen_ber_bin_v2.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1rt_nif.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_check.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_table.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_constructed_per.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_pretty_format.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_name.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_parser2.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1_db.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_gen_check.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_func.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_tok.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_constructed_ber_bin_v2.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_value.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_eval_ext.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_gen_per.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_rtt.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_gen.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/ebin/asn1ct_imm.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/src/asn1rtt_ber.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/src/asn1rtt_uper.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/src/asn1rtt_real_common.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/src/asn1rtt_check.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/src/asn1rtt_per_common.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/src/prepare_templates.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/src/asn1rtt_per.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/src/asn1rtt_ext.beam",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/AA2.asn1db",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/RANAP-PDU-Contents.asn1",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/RANAP-IEs.asn1",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/Mvrasn-11-6.asn",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/Mvrasn-18-6.asn",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/rfcs/External-References.asn1",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/rfcs/ISO-STANDARD-9541-FONT-ATTRIBUTE-SET.asn1",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/rfcs/ISO9541-SN.asn1",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg19.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg21.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg23.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg16.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg5.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg22.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg17.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg12.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg1.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg13.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg4.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg2.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg25.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg11.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg6.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg10.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg24.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg20.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg18.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg15.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg7.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg8.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg9.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg3.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/test/asn1_SUITE_data/megacomessages/Msg14.val",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/doc/src/selective_TypeList.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/doc/src/exclusive_Win_But.gif",
        "/tmp/vanessa/spack-stage/spack-stage-erlang-22.1-qsw7xlrqgvlszdro5opxkglmfuwydead/spack-src/lib/asn1/doc/src/selective_Window2.gif"
    ],
    "total_files": 10632
}