{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/src/libexpr/primops.cc": "#include \"archive.hh\"\n#include \"derivations.hh\"\n#include \"download.hh\"\n#include \"eval-inline.hh\"\n#include \"eval.hh\"\n#include \"globals.hh\"\n#include \"json-to-value.hh\"\n#include \"names.hh\"\n#include \"store-api.hh\"\n#include \"util.hh\"\n#include \"json.hh\"\n#include \"value-to-json.hh\"\n#include \"value-to-xml.hh\"\n#include \"primops.hh\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <algorithm>\n#include <cstring>\n#include <regex>\n#include <dlfcn.h>\n\n\nnamespace nix {\n\n\n/*************************************************************\n * Miscellaneous\n *************************************************************/\n\n\n/* Decode a context string \u2018!<name>!<path>\u2019 into a pair <path,\n   name>. */\nstd::pair<string, string> decodeContext(const string & s)\n{\n    if (s.at(0) == '!') {\n        size_t index = s.find(\"!\", 1);\n        return std::pair<string, string>(string(s, index + 1), string(s, 1, index - 1));\n    } else\n        return std::pair<string, string>(s.at(0) == '/' ? s : string(s, 1), \"\");\n}\n\n\nInvalidPathError::InvalidPathError(const Path & path) :\n    EvalError(format(\"path '%1%' is not valid\") % path), path(path) {}\n\nvoid EvalState::realiseContext(const PathSet & context)\n{\n    PathSet drvs;\n\n    for (auto & i : context) {\n        std::pair<string, string> decoded = decodeContext(i);\n        Path ctx = decoded.first;\n        assert(store->isStorePath(ctx));\n        if (!store->isValidPath(ctx))\n            throw InvalidPathError(ctx);\n        if (!decoded.second.empty() && nix::isDerivation(ctx)) {\n            drvs.insert(decoded.first + \"!\" + decoded.second);\n\n            /* Add the output of this derivation to the allowed\n               paths. */\n            if (allowedPaths) {\n                auto drv = store->derivationFromPath(decoded.first);\n                DerivationOutputs::iterator i = drv.outputs.find(decoded.second);\n                if (i == drv.outputs.end())\n                    throw Error(\"derivation '%s' does not have an output named '%s'\", decoded.first, decoded.second);\n                allowedPaths->insert(i->second.path);\n            }\n        }\n    }\n\n    if (drvs.empty()) return;\n\n    if (!settings.enableImportFromDerivation)\n        throw EvalError(format(\"attempted to realize '%1%' during evaluation but 'allow-import-from-derivation' is false\") % *(drvs.begin()));\n\n    /* For performance, prefetch all substitute info. */\n    PathSet willBuild, willSubstitute, unknown;\n    unsigned long long downloadSize, narSize;\n    store->queryMissing(drvs, willBuild, willSubstitute, unknown, downloadSize, narSize);\n    store->buildPaths(drvs);\n}\n\n\n/* Load and evaluate an expression from path specified by the\n   argument. */\nstatic void prim_scopedImport(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path path = state.coerceToPath(pos, *args[1], context);\n\n    try {\n        state.realiseContext(context);\n    } catch (InvalidPathError & e) {\n        throw EvalError(format(\"cannot import '%1%', since path '%2%' is not valid, at %3%\")\n            % path % e.path % pos);\n    }\n\n    Path realPath = state.checkSourcePath(state.toRealPath(path, context));\n\n    if (state.store->isStorePath(path) && state.store->isValidPath(path) && isDerivation(path)) {\n        Derivation drv = readDerivation(realPath);\n        Value & w = *state.allocValue();\n        state.mkAttrs(w, 3 + drv.outputs.size());\n        Value * v2 = state.allocAttr(w, state.sDrvPath);\n        mkString(*v2, path, {\"=\" + path});\n        v2 = state.allocAttr(w, state.sName);\n        mkString(*v2, drv.env[\"name\"]);\n        Value * outputsVal =\n            state.allocAttr(w, state.symbols.create(\"outputs\"));\n        state.mkList(*outputsVal, drv.outputs.size());\n        unsigned int outputs_index = 0;\n\n        for (const auto & o : drv.outputs) {\n            v2 = state.allocAttr(w, state.symbols.create(o.first));\n            mkString(*v2, o.second.path, {\"!\" + o.first + \"!\" + path});\n            outputsVal->listElems()[outputs_index] = state.allocValue();\n            mkString(*(outputsVal->listElems()[outputs_index++]), o.first);\n        }\n        w.attrs->sort();\n        Value fun;\n        state.evalFile(settings.nixDataDir + \"/nix/corepkgs/imported-drv-to-derivation.nix\", fun);\n        state.forceFunction(fun, pos);\n        mkApp(v, fun, w);\n        state.forceAttrs(v, pos);\n    } else {\n        state.forceAttrs(*args[0]);\n        if (args[0]->attrs->empty())\n            state.evalFile(realPath, v);\n        else {\n            Env * env = &state.allocEnv(args[0]->attrs->size());\n            env->up = &state.baseEnv;\n\n            StaticEnv staticEnv(false, &state.staticBaseEnv);\n\n            unsigned int displ = 0;\n            for (auto & attr : *args[0]->attrs) {\n                staticEnv.vars[attr.name] = displ;\n                env->values[displ++] = attr.value;\n            }\n\n            printTalkative(\"evaluating file '%1%'\", realPath);\n            Expr * e = state.parseExprFromFile(resolveExprPath(realPath), staticEnv);\n\n            e->eval(state, *env, v);\n        }\n    }\n}\n\n\n/* Want reasonable symbol names, so extern C */\n/* !!! Should we pass the Pos or the file name too? */\nextern \"C\" typedef void (*ValueInitializer)(EvalState & state, Value & v);\n\n/* Load a ValueInitializer from a DSO and return whatever it initializes */\nvoid prim_importNative(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path path = state.coerceToPath(pos, *args[0], context);\n\n    try {\n        state.realiseContext(context);\n    } catch (InvalidPathError & e) {\n        throw EvalError(format(\"cannot import '%1%', since path '%2%' is not valid, at %3%\")\n            % path % e.path % pos);\n    }\n\n    path = state.checkSourcePath(path);\n\n    string sym = state.forceStringNoCtx(*args[1], pos);\n\n    void *handle = dlopen(path.c_str(), RTLD_LAZY | RTLD_LOCAL);\n    if (!handle)\n        throw EvalError(format(\"could not open '%1%': %2%\") % path % dlerror());\n\n    dlerror();\n    ValueInitializer func = (ValueInitializer) dlsym(handle, sym.c_str());\n    if(!func) {\n        char *message = dlerror();\n        if (message)\n            throw EvalError(format(\"could not load symbol '%1%' from '%2%': %3%\") % sym % path % message);\n        else\n            throw EvalError(format(\"symbol '%1%' from '%2%' resolved to NULL when a function pointer was expected\")\n                    % sym % path);\n    }\n\n    (func)(state, v);\n\n    /* We don't dlclose because v may be a primop referencing a function in the shared object file */\n}\n\n\n/* Execute a program and parse its output */\nvoid prim_exec(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceList(*args[0], pos);\n    auto elems = args[0]->listElems();\n    auto count = args[0]->listSize();\n    if (count == 0) {\n        throw EvalError(format(\"at least one argument to 'exec' required, at %1%\") % pos);\n    }\n    PathSet context;\n    auto program = state.coerceToString(pos, *elems[0], context, false, false);\n    Strings commandArgs;\n    for (unsigned int i = 1; i < args[0]->listSize(); ++i) {\n        commandArgs.emplace_back(state.coerceToString(pos, *elems[i], context, false, false));\n    }\n    try {\n        state.realiseContext(context);\n    } catch (InvalidPathError & e) {\n        throw EvalError(format(\"cannot execute '%1%', since path '%2%' is not valid, at %3%\")\n            % program % e.path % pos);\n    }\n\n    auto output = runProgram(program, true, commandArgs);\n    Expr * parsed;\n    try {\n        parsed = state.parseExprFromString(output, pos.file);\n    } catch (Error & e) {\n        e.addPrefix(format(\"While parsing the output from '%1%', at %2%\\n\") % program % pos);\n        throw;\n    }\n    try {\n        state.eval(parsed, v);\n    } catch (Error & e) {\n        e.addPrefix(format(\"While evaluating the output from '%1%', at %2%\\n\") % program % pos);\n        throw;\n    }\n}\n\n\n/* Return a string representing the type of the expression. */\nstatic void prim_typeOf(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    string t;\n    switch (args[0]->type) {\n        case tInt: t = \"int\"; break;\n        case tBool: t = \"bool\"; break;\n        case tString: t = \"string\"; break;\n        case tPath: t = \"path\"; break;\n        case tNull: t = \"null\"; break;\n        case tAttrs: t = \"set\"; break;\n        case tList1: case tList2: case tListN: t = \"list\"; break;\n        case tLambda:\n        case tPrimOp:\n        case tPrimOpApp:\n            t = \"lambda\";\n            break;\n        case tExternal:\n            t = args[0]->external->typeOf();\n            break;\n        case tFloat: t = \"float\"; break;\n        default: abort();\n    }\n    mkString(v, state.symbols.create(t));\n}\n\n\n/* Determine whether the argument is the null value. */\nstatic void prim_isNull(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->type == tNull);\n}\n\n\n/* Determine whether the argument is a function. */\nstatic void prim_isFunction(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->type == tLambda);\n}\n\n\n/* Determine whether the argument is an integer. */\nstatic void prim_isInt(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->type == tInt);\n}\n\n/* Determine whether the argument is a float. */\nstatic void prim_isFloat(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->type == tFloat);\n}\n\n/* Determine whether the argument is a string. */\nstatic void prim_isString(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->type == tString);\n}\n\n\n/* Determine whether the argument is a Boolean. */\nstatic void prim_isBool(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->type == tBool);\n}\n\n\nstruct CompareValues\n{\n    bool operator () (const Value * v1, const Value * v2) const\n    {\n        if (v1->type == tFloat && v2->type == tInt)\n            return v1->fpoint < v2->integer;\n        if (v1->type == tInt && v2->type == tFloat)\n            return v1->integer < v2->fpoint;\n        if (v1->type != v2->type)\n            throw EvalError(format(\"cannot compare %1% with %2%\") % showType(*v1) % showType(*v2));\n        switch (v1->type) {\n            case tInt:\n                return v1->integer < v2->integer;\n            case tFloat:\n                return v1->fpoint < v2->fpoint;\n            case tString:\n                return strcmp(v1->string.s, v2->string.s) < 0;\n            case tPath:\n                return strcmp(v1->path, v2->path) < 0;\n            default:\n                throw EvalError(format(\"cannot compare %1% with %2%\") % showType(*v1) % showType(*v2));\n        }\n    }\n};\n\n\n#if HAVE_BOEHMGC\ntypedef list<Value *, gc_allocator<Value *> > ValueList;\n#else\ntypedef list<Value *> ValueList;\n#endif\n\n\nstatic void prim_genericClosure(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceAttrs(*args[0], pos);\n\n    /* Get the start set. */\n    Bindings::iterator startSet =\n        args[0]->attrs->find(state.symbols.create(\"startSet\"));\n    if (startSet == args[0]->attrs->end())\n        throw EvalError(format(\"attribute 'startSet' required, at %1%\") % pos);\n    state.forceList(*startSet->value, pos);\n\n    ValueList workSet;\n    for (unsigned int n = 0; n < startSet->value->listSize(); ++n)\n        workSet.push_back(startSet->value->listElems()[n]);\n\n    /* Get the operator. */\n    Bindings::iterator op =\n        args[0]->attrs->find(state.symbols.create(\"operator\"));\n    if (op == args[0]->attrs->end())\n        throw EvalError(format(\"attribute 'operator' required, at %1%\") % pos);\n    state.forceValue(*op->value);\n\n    /* Construct the closure by applying the operator to element of\n       `workSet', adding the result to `workSet', continuing until\n       no new elements are found. */\n    ValueList res;\n    // `doneKeys' doesn't need to be a GC root, because its values are\n    // reachable from res.\n    set<Value *, CompareValues> doneKeys;\n    while (!workSet.empty()) {\n        Value * e = *(workSet.begin());\n        workSet.pop_front();\n\n        state.forceAttrs(*e, pos);\n\n        Bindings::iterator key =\n            e->attrs->find(state.symbols.create(\"key\"));\n        if (key == e->attrs->end())\n            throw EvalError(format(\"attribute 'key' required, at %1%\") % pos);\n        state.forceValue(*key->value);\n\n        if (doneKeys.find(key->value) != doneKeys.end()) continue;\n        doneKeys.insert(key->value);\n        res.push_back(e);\n\n        /* Call the `operator' function with `e' as argument. */\n        Value call;\n        mkApp(call, *op->value, *e);\n        state.forceList(call, pos);\n\n        /* Add the values returned by the operator to the work set. */\n        for (unsigned int n = 0; n < call.listSize(); ++n) {\n            state.forceValue(*call.listElems()[n]);\n            workSet.push_back(call.listElems()[n]);\n        }\n    }\n\n    /* Create the result list. */\n    state.mkList(v, res.size());\n    unsigned int n = 0;\n    for (auto & i : res)\n        v.listElems()[n++] = i;\n}\n\n\nstatic void prim_abort(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    string s = state.coerceToString(pos, *args[0], context);\n    throw Abort(format(\"evaluation aborted with the following error message: '%1%'\") % s);\n}\n\n\nstatic void prim_throw(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    string s = state.coerceToString(pos, *args[0], context);\n    throw ThrownError(s);\n}\n\n\nstatic void prim_addErrorContext(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    try {\n        state.forceValue(*args[1]);\n        v = *args[1];\n    } catch (Error & e) {\n        PathSet context;\n        e.addPrefix(format(\"%1%\\n\") % state.coerceToString(pos, *args[0], context));\n        throw;\n    }\n}\n\n\n/* Try evaluating the argument. Success => {success=true; value=something;},\n * else => {success=false; value=false;} */\nstatic void prim_tryEval(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.mkAttrs(v, 2);\n    try {\n        state.forceValue(*args[0]);\n        v.attrs->push_back(Attr(state.sValue, args[0]));\n        mkBool(*state.allocAttr(v, state.symbols.create(\"success\")), true);\n    } catch (AssertionError & e) {\n        mkBool(*state.allocAttr(v, state.sValue), false);\n        mkBool(*state.allocAttr(v, state.symbols.create(\"success\")), false);\n    }\n    v.attrs->sort();\n}\n\n\n/* Return an environment variable.  Use with care. */\nstatic void prim_getEnv(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string name = state.forceStringNoCtx(*args[0], pos);\n    mkString(v, settings.restrictEval || settings.pureEval ? \"\" : getEnv(name));\n}\n\n\n/* Evaluate the first argument, then return the second argument. */\nstatic void prim_seq(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    state.forceValue(*args[1]);\n    v = *args[1];\n}\n\n\n/* Evaluate the first argument deeply (i.e. recursing into lists and\n   attrsets), then return the second argument. */\nstatic void prim_deepSeq(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValueDeep(*args[0]);\n    state.forceValue(*args[1]);\n    v = *args[1];\n}\n\n\n/* Evaluate the first expression and print it on standard error.  Then\n   return the second expression.  Useful for debugging. */\nstatic void prim_trace(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    if (args[0]->type == tString)\n        printError(format(\"trace: %1%\") % args[0]->string.s);\n    else\n        printError(format(\"trace: %1%\") % *args[0]);\n    state.forceValue(*args[1]);\n    v = *args[1];\n}\n\n\nvoid prim_valueSize(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    /* We're not forcing the argument on purpose. */\n    mkInt(v, valueSize(*args[0]));\n}\n\n\n/*************************************************************\n * Derivations\n *************************************************************/\n\n\n/* Construct (as a unobservable side effect) a Nix derivation\n   expression that performs the derivation described by the argument\n   set.  Returns the original set extended with the following\n   attributes: `outPath' containing the primary output path of the\n   derivation; `drvPath' containing the path of the Nix expression;\n   and `type' set to `derivation' to indicate that this is a\n   derivation. */\nstatic void prim_derivationStrict(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceAttrs(*args[0], pos);\n\n    /* Figure out the name first (for stack backtraces). */\n    Bindings::iterator attr = args[0]->attrs->find(state.sName);\n    if (attr == args[0]->attrs->end())\n        throw EvalError(format(\"required attribute 'name' missing, at %1%\") % pos);\n    string drvName;\n    Pos & posDrvName(*attr->pos);\n    try {\n        drvName = state.forceStringNoCtx(*attr->value, pos);\n    } catch (Error & e) {\n        e.addPrefix(format(\"while evaluating the derivation attribute 'name' at %1%:\\n\") % posDrvName);\n        throw;\n    }\n\n    /* Check whether attributes should be passed as a JSON file. */\n    std::ostringstream jsonBuf;\n    std::unique_ptr<JSONObject> jsonObject;\n    attr = args[0]->attrs->find(state.sStructuredAttrs);\n    if (attr != args[0]->attrs->end() && state.forceBool(*attr->value, pos))\n        jsonObject = std::make_unique<JSONObject>(jsonBuf);\n\n    /* Check whether null attributes should be ignored. */\n    bool ignoreNulls = false;\n    attr = args[0]->attrs->find(state.sIgnoreNulls);\n    if (attr != args[0]->attrs->end())\n        ignoreNulls = state.forceBool(*attr->value, pos);\n\n    /* Build the derivation expression by processing the attributes. */\n    Derivation drv;\n\n    PathSet context;\n\n    std::experimental::optional<std::string> outputHash;\n    std::string outputHashAlgo;\n    bool outputHashRecursive = false;\n\n    StringSet outputs;\n    outputs.insert(\"out\");\n\n    for (auto & i : args[0]->attrs->lexicographicOrder()) {\n        if (i->name == state.sIgnoreNulls) continue;\n        const string & key = i->name;\n        vomit(\"processing attribute '%1%'\", key);\n\n        auto handleHashMode = [&](const std::string & s) {\n            if (s == \"recursive\") outputHashRecursive = true;\n            else if (s == \"flat\") outputHashRecursive = false;\n            else throw EvalError(\"invalid value '%s' for 'outputHashMode' attribute, at %s\", s, posDrvName);\n        };\n\n        auto handleOutputs = [&](const Strings & ss) {\n            outputs.clear();\n            for (auto & j : ss) {\n                if (outputs.find(j) != outputs.end())\n                    throw EvalError(format(\"duplicate derivation output '%1%', at %2%\") % j % posDrvName);\n                /* !!! Check whether j is a valid attribute\n                   name. */\n                /* Derivations cannot be named \u2018drv\u2019, because\n                   then we'd have an attribute \u2018drvPath\u2019 in\n                   the resulting set. */\n                if (j == \"drv\")\n                    throw EvalError(format(\"invalid derivation output name 'drv', at %1%\") % posDrvName);\n                outputs.insert(j);\n            }\n            if (outputs.empty())\n                throw EvalError(format(\"derivation cannot have an empty set of outputs, at %1%\") % posDrvName);\n        };\n\n        try {\n\n            if (ignoreNulls) {\n                state.forceValue(*i->value);\n                if (i->value->type == tNull) continue;\n            }\n\n            /* The `args' attribute is special: it supplies the\n               command-line arguments to the builder. */\n            if (i->name == state.sArgs) {\n                state.forceList(*i->value, pos);\n                for (unsigned int n = 0; n < i->value->listSize(); ++n) {\n                    string s = state.coerceToString(posDrvName, *i->value->listElems()[n], context, true);\n                    drv.args.push_back(s);\n                }\n            }\n\n            /* All other attributes are passed to the builder through\n               the environment. */\n            else {\n\n                if (jsonObject) {\n\n                    if (i->name == state.sStructuredAttrs) continue;\n\n                    auto placeholder(jsonObject->placeholder(key));\n                    printValueAsJSON(state, true, *i->value, placeholder, context);\n\n                    if (i->name == state.sBuilder)\n                        drv.builder = state.forceString(*i->value, context, posDrvName);\n                    else if (i->name == state.sSystem)\n                        drv.platform = state.forceStringNoCtx(*i->value, posDrvName);\n                    else if (i->name == state.sOutputHash)\n                        outputHash = state.forceStringNoCtx(*i->value, posDrvName);\n                    else if (i->name == state.sOutputHashAlgo)\n                        outputHashAlgo = state.forceStringNoCtx(*i->value, posDrvName);\n                    else if (i->name == state.sOutputHashMode)\n                        handleHashMode(state.forceStringNoCtx(*i->value, posDrvName));\n                    else if (i->name == state.sOutputs) {\n                        /* Require \u2018outputs\u2019 to be a list of strings. */\n                        state.forceList(*i->value, posDrvName);\n                        Strings ss;\n                        for (unsigned int n = 0; n < i->value->listSize(); ++n)\n                            ss.emplace_back(state.forceStringNoCtx(*i->value->listElems()[n], posDrvName));\n                        handleOutputs(ss);\n                    }\n\n                } else {\n                    auto s = state.coerceToString(posDrvName, *i->value, context, true);\n                    drv.env.emplace(key, s);\n                    if (i->name == state.sBuilder) drv.builder = s;\n                    else if (i->name == state.sSystem) drv.platform = s;\n                    else if (i->name == state.sOutputHash) outputHash = s;\n                    else if (i->name == state.sOutputHashAlgo) outputHashAlgo = s;\n                    else if (i->name == state.sOutputHashMode) handleHashMode(s);\n                    else if (i->name == state.sOutputs)\n                        handleOutputs(tokenizeString<Strings>(s));\n                }\n\n            }\n\n        } catch (Error & e) {\n            e.addPrefix(format(\"while evaluating the attribute '%1%' of the derivation '%2%' at %3%:\\n\")\n                % key % drvName % posDrvName);\n            throw;\n        }\n    }\n\n    if (jsonObject) {\n        jsonObject.reset();\n        drv.env.emplace(\"__json\", jsonBuf.str());\n    }\n\n    /* Everything in the context of the strings in the derivation\n       attributes should be added as dependencies of the resulting\n       derivation. */\n    for (auto & path : context) {\n\n        /* Paths marked with `=' denote that the path of a derivation\n           is explicitly passed to the builder.  Since that allows the\n           builder to gain access to every path in the dependency\n           graph of the derivation (including all outputs), all paths\n           in the graph must be added to this derivation's list of\n           inputs to ensure that they are available when the builder\n           runs. */\n        if (path.at(0) == '=') {\n            /* !!! This doesn't work if readOnlyMode is set. */\n            PathSet refs;\n            state.store->computeFSClosure(string(path, 1), refs);\n            for (auto & j : refs) {\n                drv.inputSrcs.insert(j);\n                if (isDerivation(j))\n                    drv.inputDrvs[j] = state.store->queryDerivationOutputNames(j);\n            }\n        }\n\n        /* See prim_unsafeDiscardOutputDependency. */\n        else if (path.at(0) == '~')\n            drv.inputSrcs.insert(string(path, 1));\n\n        /* Handle derivation outputs of the form \u2018!<name>!<path>\u2019. */\n        else if (path.at(0) == '!') {\n            std::pair<string, string> ctx = decodeContext(path);\n            drv.inputDrvs[ctx.first].insert(ctx.second);\n        }\n\n        /* Handle derivation contexts returned by\n           \u2018builtins.storePath\u2019. */\n        else if (isDerivation(path))\n            drv.inputDrvs[path] = state.store->queryDerivationOutputNames(path);\n\n        /* Otherwise it's a source file. */\n        else\n            drv.inputSrcs.insert(path);\n    }\n\n    /* Do we have all required attributes? */\n    if (drv.builder == \"\")\n        throw EvalError(format(\"required attribute 'builder' missing, at %1%\") % posDrvName);\n    if (drv.platform == \"\")\n        throw EvalError(format(\"required attribute 'system' missing, at %1%\") % posDrvName);\n\n    /* Check whether the derivation name is valid. */\n    checkStoreName(drvName);\n    if (isDerivation(drvName))\n        throw EvalError(format(\"derivation names are not allowed to end in '%1%', at %2%\")\n            % drvExtension % posDrvName);\n\n    if (outputHash) {\n        /* Handle fixed-output derivations. */\n        if (outputs.size() != 1 || *(outputs.begin()) != \"out\")\n            throw Error(format(\"multiple outputs are not supported in fixed-output derivations, at %1%\") % posDrvName);\n\n        HashType ht = parseHashType(outputHashAlgo);\n        if (ht == htUnknown)\n            throw EvalError(format(\"unknown hash algorithm '%1%', at %2%\") % outputHashAlgo % posDrvName);\n        Hash h(*outputHash, ht);\n        outputHash = h.to_string(Base16, false);\n        if (outputHashRecursive) outputHashAlgo = \"r:\" + outputHashAlgo;\n\n        Path outPath = state.store->makeFixedOutputPath(outputHashRecursive, h, drvName);\n        if (!jsonObject) drv.env[\"out\"] = outPath;\n        drv.outputs[\"out\"] = DerivationOutput(outPath, outputHashAlgo, *outputHash);\n    }\n\n    else {\n        /* Construct the \"masked\" store derivation, which is the final\n           one except that in the list of outputs, the output paths\n           are empty, and the corresponding environment variables have\n           an empty value.  This ensures that changes in the set of\n           output names do get reflected in the hash. */\n        for (auto & i : outputs) {\n            if (!jsonObject) drv.env[i] = \"\";\n            drv.outputs[i] = DerivationOutput(\"\", \"\", \"\");\n        }\n\n        /* Use the masked derivation expression to compute the output\n           path. */\n        Hash h = hashDerivationModulo(*state.store, drv);\n\n        for (auto & i : drv.outputs)\n            if (i.second.path == \"\") {\n                Path outPath = state.store->makeOutputPath(i.first, h, drvName);\n                if (!jsonObject) drv.env[i.first] = outPath;\n                i.second.path = outPath;\n            }\n    }\n\n    /* Write the resulting term into the Nix store directory. */\n    Path drvPath = writeDerivation(state.store, drv, drvName, state.repair);\n\n    printMsg(lvlChatty, format(\"instantiated '%1%' -> '%2%'\")\n        % drvName % drvPath);\n\n    /* Optimisation, but required in read-only mode! because in that\n       case we don't actually write store derivations, so we can't\n       read them later. */\n    drvHashes[drvPath] = hashDerivationModulo(*state.store, drv);\n\n    state.mkAttrs(v, 1 + drv.outputs.size());\n    mkString(*state.allocAttr(v, state.sDrvPath), drvPath, {\"=\" + drvPath});\n    for (auto & i : drv.outputs) {\n        mkString(*state.allocAttr(v, state.symbols.create(i.first)),\n            i.second.path, {\"!\" + i.first + \"!\" + drvPath});\n    }\n    v.attrs->sort();\n}\n\n\n/* Return a placeholder string for the specified output that will be\n   substituted by the corresponding output path at build time. For\n   example, 'placeholder \"out\"' returns the string\n   /1rz4g4znpzjwh1xymhjpm42vipw92pr73vdgl6xs1hycac8kf2n9. At build\n   time, any occurence of this string in an derivation attribute will\n   be replaced with the concrete path in the Nix store of the output\n   \u2018out\u2019. */\nstatic void prim_placeholder(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    mkString(v, hashPlaceholder(state.forceStringNoCtx(*args[0], pos)));\n}\n\n\n/*************************************************************\n * Paths\n *************************************************************/\n\n\n/* Convert the argument to a path.  !!! obsolete? */\nstatic void prim_toPath(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path path = state.coerceToPath(pos, *args[0], context);\n    mkString(v, canonPath(path), context);\n}\n\n\n/* Allow a valid store path to be used in an expression.  This is\n   useful in some generated expressions such as in nix-push, which\n   generates a call to a function with an already existing store path\n   as argument.  You don't want to use `toPath' here because it copies\n   the path to the Nix store, which yields a copy like\n   /nix/store/newhash-oldhash-oldname.  In the past, `toPath' had\n   special case behaviour for store paths, but that created weird\n   corner cases. */\nstatic void prim_storePath(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path path = state.checkSourcePath(state.coerceToPath(pos, *args[0], context));\n    /* Resolve symlinks in \u2018path\u2019, unless \u2018path\u2019 itself is a symlink\n       directly in the store.  The latter condition is necessary so\n       e.g. nix-push does the right thing. */\n    if (!state.store->isStorePath(path)) path = canonPath(path, true);\n    if (!state.store->isInStore(path))\n        throw EvalError(format(\"path '%1%' is not in the Nix store, at %2%\") % path % pos);\n    Path path2 = state.store->toStorePath(path);\n    if (!settings.readOnlyMode)\n        state.store->ensurePath(path2);\n    context.insert(path2);\n    mkString(v, path, context);\n}\n\n\nstatic void prim_pathExists(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path path = state.coerceToPath(pos, *args[0], context);\n    if (!context.empty())\n        throw EvalError(format(\"string '%1%' cannot refer to other paths, at %2%\") % path % pos);\n    try {\n        mkBool(v, pathExists(state.checkSourcePath(path)));\n    } catch (SysError & e) {\n        /* Don't give away info from errors while canonicalising\n           \u2018path\u2019 in restricted mode. */\n        mkBool(v, false);\n    } catch (RestrictedPathError & e) {\n        mkBool(v, false);\n    }\n}\n\n\n/* Return the base name of the given string, i.e., everything\n   following the last slash. */\nstatic void prim_baseNameOf(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    mkString(v, baseNameOf(state.coerceToString(pos, *args[0], context, false, false)), context);\n}\n\n\n/* Return the directory of the given path, i.e., everything before the\n   last slash.  Return either a path or a string depending on the type\n   of the argument. */\nstatic void prim_dirOf(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path dir = dirOf(state.coerceToPath(pos, *args[0], context));\n    if (args[0]->type == tPath) mkPath(v, dir.c_str()); else mkString(v, dir, context);\n}\n\n\n/* Return the contents of a file as a string. */\nstatic void prim_readFile(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path path = state.coerceToPath(pos, *args[0], context);\n    try {\n        state.realiseContext(context);\n    } catch (InvalidPathError & e) {\n        throw EvalError(format(\"cannot read '%1%', since path '%2%' is not valid, at %3%\")\n            % path % e.path % pos);\n    }\n    string s = readFile(state.checkSourcePath(state.toRealPath(path, context)));\n    if (s.find((char) 0) != string::npos)\n        throw Error(format(\"the contents of the file '%1%' cannot be represented as a Nix string\") % path);\n    mkString(v, s.c_str());\n}\n\n\n/* Find a file in the Nix search path. Used to implement <x> paths,\n   which are desugared to 'findFile __nixPath \"x\"'. */\nstatic void prim_findFile(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceList(*args[0], pos);\n\n    SearchPath searchPath;\n\n    for (unsigned int n = 0; n < args[0]->listSize(); ++n) {\n        Value & v2(*args[0]->listElems()[n]);\n        state.forceAttrs(v2, pos);\n\n        string prefix;\n        Bindings::iterator i = v2.attrs->find(state.symbols.create(\"prefix\"));\n        if (i != v2.attrs->end())\n            prefix = state.forceStringNoCtx(*i->value, pos);\n\n        i = v2.attrs->find(state.symbols.create(\"path\"));\n        if (i == v2.attrs->end())\n            throw EvalError(format(\"attribute 'path' missing, at %1%\") % pos);\n\n        PathSet context;\n        string path = state.coerceToString(pos, *i->value, context, false, false);\n\n        try {\n            state.realiseContext(context);\n        } catch (InvalidPathError & e) {\n            throw EvalError(format(\"cannot find '%1%', since path '%2%' is not valid, at %3%\")\n                % path % e.path % pos);\n        }\n\n        searchPath.emplace_back(prefix, path);\n    }\n\n    string path = state.forceStringNoCtx(*args[1], pos);\n\n    mkPath(v, state.checkSourcePath(state.findFile(searchPath, path, pos)).c_str());\n}\n\n/* Read a directory (without . or ..) */\nstatic void prim_readDir(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet ctx;\n    Path path = state.coerceToPath(pos, *args[0], ctx);\n    try {\n        state.realiseContext(ctx);\n    } catch (InvalidPathError & e) {\n        throw EvalError(format(\"cannot read '%1%', since path '%2%' is not valid, at %3%\")\n            % path % e.path % pos);\n    }\n\n    DirEntries entries = readDirectory(state.checkSourcePath(path));\n    state.mkAttrs(v, entries.size());\n\n    for (auto & ent : entries) {\n        Value * ent_val = state.allocAttr(v, state.symbols.create(ent.name));\n        if (ent.type == DT_UNKNOWN)\n            ent.type = getFileType(path + \"/\" + ent.name);\n        mkStringNoCopy(*ent_val,\n            ent.type == DT_REG ? \"regular\" :\n            ent.type == DT_DIR ? \"directory\" :\n            ent.type == DT_LNK ? \"symlink\" :\n            \"unknown\");\n    }\n\n    v.attrs->sort();\n}\n\n\n/*************************************************************\n * Creating files\n *************************************************************/\n\n\n/* Convert the argument (which can be any Nix expression) to an XML\n   representation returned in a string.  Not all Nix expressions can\n   be sensibly or completely represented (e.g., functions). */\nstatic void prim_toXML(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    std::ostringstream out;\n    PathSet context;\n    printValueAsXML(state, true, false, *args[0], out, context);\n    mkString(v, out.str(), context);\n}\n\n\n/* Convert the argument (which can be any Nix expression) to a JSON\n   string.  Not all Nix expressions can be sensibly or completely\n   represented (e.g., functions). */\nstatic void prim_toJSON(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    std::ostringstream out;\n    PathSet context;\n    printValueAsJSON(state, true, *args[0], out, context);\n    mkString(v, out.str(), context);\n}\n\n\n/* Parse a JSON string to a value. */\nstatic void prim_fromJSON(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string s = state.forceStringNoCtx(*args[0], pos);\n    parseJSON(state, s, v);\n}\n\n\n/* Store a string in the Nix store as a source file that can be used\n   as an input by derivations. */\nstatic void prim_toFile(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    string name = state.forceStringNoCtx(*args[0], pos);\n    string contents = state.forceString(*args[1], context, pos);\n\n    PathSet refs;\n\n    for (auto path : context) {\n        if (path.at(0) == '=') path = string(path, 1);\n        if (isDerivation(path)) {\n            /* See prim_unsafeDiscardOutputDependency. */\n            if (path.at(0) != '~')\n                throw EvalError(format(\"in 'toFile': the file '%1%' cannot refer to derivation outputs, at %2%\") % name % pos);\n            path = string(path, 1);\n        }\n        refs.insert(path);\n    }\n\n    Path storePath = settings.readOnlyMode\n        ? state.store->computeStorePathForText(name, contents, refs)\n        : state.store->addTextToStore(name, contents, refs, state.repair);\n\n    /* Note: we don't need to add `context' to the context of the\n       result, since `storePath' itself has references to the paths\n       used in args[1]. */\n\n    mkString(v, storePath, {storePath});\n}\n\n\nstatic void addPath(EvalState & state, const Pos & pos, const string & name, const Path & path_,\n    Value * filterFun, bool recursive, const Hash & expectedHash, Value & v)\n{\n    const auto path = settings.pureEval && expectedHash ?\n        path_ :\n        state.checkSourcePath(path_);\n    PathFilter filter = filterFun ? ([&](const Path & path) {\n        auto st = lstat(path);\n\n        /* Call the filter function.  The first argument is the path,\n           the second is a string indicating the type of the file. */\n        Value arg1;\n        mkString(arg1, path);\n\n        Value fun2;\n        state.callFunction(*filterFun, arg1, fun2, noPos);\n\n        Value arg2;\n        mkString(arg2,\n            S_ISREG(st.st_mode) ? \"regular\" :\n            S_ISDIR(st.st_mode) ? \"directory\" :\n            S_ISLNK(st.st_mode) ? \"symlink\" :\n            \"unknown\" /* not supported, will fail! */);\n\n        Value res;\n        state.callFunction(fun2, arg2, res, noPos);\n\n        return state.forceBool(res, pos);\n    }) : defaultPathFilter;\n\n    Path expectedStorePath;\n    if (expectedHash) {\n        expectedStorePath =\n            state.store->makeFixedOutputPath(recursive, expectedHash, name);\n    }\n    Path dstPath;\n    if (!expectedHash || !state.store->isValidPath(expectedStorePath)) {\n        dstPath = settings.readOnlyMode\n            ? state.store->computeStorePathForPath(name, path, recursive, htSHA256, filter).first\n            : state.store->addToStore(name, path, recursive, htSHA256, filter, state.repair);\n        if (expectedHash && expectedStorePath != dstPath) {\n            throw Error(format(\"store path mismatch in (possibly filtered) path added from '%1%'\") % path);\n        }\n    } else\n        dstPath = expectedStorePath;\n\n    mkString(v, dstPath, {dstPath});\n}\n\n\nstatic void prim_filterSource(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path path = state.coerceToPath(pos, *args[1], context);\n    if (!context.empty())\n        throw EvalError(format(\"string '%1%' cannot refer to other paths, at %2%\") % path % pos);\n\n    state.forceValue(*args[0]);\n    if (args[0]->type != tLambda)\n        throw TypeError(format(\"first argument in call to 'filterSource' is not a function but %1%, at %2%\") % showType(*args[0]) % pos);\n\n    addPath(state, pos, baseNameOf(path), path, args[0], true, Hash(), v);\n}\n\nstatic void prim_path(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceAttrs(*args[0], pos);\n    Path path;\n    string name;\n    Value * filterFun = nullptr;\n    auto recursive = true;\n    Hash expectedHash;\n\n    for (auto & attr : *args[0]->attrs) {\n        const string & n(attr.name);\n        if (n == \"path\") {\n            PathSet context;\n            path = state.coerceToPath(*attr.pos, *attr.value, context);\n            if (!context.empty())\n                throw EvalError(format(\"string '%1%' cannot refer to other paths, at %2%\") % path % *attr.pos);\n        } else if (attr.name == state.sName)\n            name = state.forceStringNoCtx(*attr.value, *attr.pos);\n        else if (n == \"filter\") {\n            state.forceValue(*attr.value);\n            filterFun = attr.value;\n        } else if (n == \"recursive\")\n            recursive = state.forceBool(*attr.value, *attr.pos);\n        else if (n == \"sha256\")\n            expectedHash = Hash(state.forceStringNoCtx(*attr.value, *attr.pos), htSHA256);\n        else\n            throw EvalError(format(\"unsupported argument '%1%' to 'addPath', at %2%\") % attr.name % *attr.pos);\n    }\n    if (path.empty())\n        throw EvalError(format(\"'path' required, at %1%\") % pos);\n    if (name.empty())\n        name = baseNameOf(path);\n\n    addPath(state, pos, name, path, filterFun, recursive, expectedHash, v);\n}\n\n\n/*************************************************************\n * Sets\n *************************************************************/\n\n\n/* Return the names of the attributes in a set as a sorted list of\n   strings. */\nstatic void prim_attrNames(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceAttrs(*args[0], pos);\n\n    state.mkList(v, args[0]->attrs->size());\n\n    size_t n = 0;\n    for (auto & i : *args[0]->attrs)\n        mkString(*(v.listElems()[n++] = state.allocValue()), i.name);\n\n    std::sort(v.listElems(), v.listElems() + n,\n              [](Value * v1, Value * v2) { return strcmp(v1->string.s, v2->string.s) < 0; });\n}\n\n\n/* Return the values of the attributes in a set as a list, in the same\n   order as attrNames. */\nstatic void prim_attrValues(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceAttrs(*args[0], pos);\n\n    state.mkList(v, args[0]->attrs->size());\n\n    unsigned int n = 0;\n    for (auto & i : *args[0]->attrs)\n        v.listElems()[n++] = (Value *) &i;\n\n    std::sort(v.listElems(), v.listElems() + n,\n        [](Value * v1, Value * v2) { return (string) ((Attr *) v1)->name < (string) ((Attr *) v2)->name; });\n\n    for (unsigned int i = 0; i < n; ++i)\n        v.listElems()[i] = ((Attr *) v.listElems()[i])->value;\n}\n\n\n/* Dynamic version of the `.' operator. */\nvoid prim_getAttr(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string attr = state.forceStringNoCtx(*args[0], pos);\n    state.forceAttrs(*args[1], pos);\n    // !!! Should we create a symbol here or just do a lookup?\n    Bindings::iterator i = args[1]->attrs->find(state.symbols.create(attr));\n    if (i == args[1]->attrs->end())\n        throw EvalError(format(\"attribute '%1%' missing, at %2%\") % attr % pos);\n    // !!! add to stack trace?\n    if (state.countCalls && i->pos) state.attrSelects[*i->pos]++;\n    state.forceValue(*i->value);\n    v = *i->value;\n}\n\n\n/* Return position information of the specified attribute. */\nvoid prim_unsafeGetAttrPos(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string attr = state.forceStringNoCtx(*args[0], pos);\n    state.forceAttrs(*args[1], pos);\n    Bindings::iterator i = args[1]->attrs->find(state.symbols.create(attr));\n    if (i == args[1]->attrs->end())\n        mkNull(v);\n    else\n        state.mkPos(v, i->pos);\n}\n\n\n/* Dynamic version of the `?' operator. */\nstatic void prim_hasAttr(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string attr = state.forceStringNoCtx(*args[0], pos);\n    state.forceAttrs(*args[1], pos);\n    mkBool(v, args[1]->attrs->find(state.symbols.create(attr)) != args[1]->attrs->end());\n}\n\n\n/* Determine whether the argument is a set. */\nstatic void prim_isAttrs(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->type == tAttrs);\n}\n\n\nstatic void prim_removeAttrs(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceAttrs(*args[0], pos);\n    state.forceList(*args[1], pos);\n\n    /* Get the attribute names to be removed. */\n    std::set<Symbol> names;\n    for (unsigned int i = 0; i < args[1]->listSize(); ++i) {\n        state.forceStringNoCtx(*args[1]->listElems()[i], pos);\n        names.insert(state.symbols.create(args[1]->listElems()[i]->string.s));\n    }\n\n    /* Copy all attributes not in that set.  Note that we don't need\n       to sort v.attrs because it's a subset of an already sorted\n       vector. */\n    state.mkAttrs(v, args[0]->attrs->size());\n    for (auto & i : *args[0]->attrs) {\n        if (names.find(i.name) == names.end())\n            v.attrs->push_back(i);\n    }\n}\n\n\n/* Builds a set from a list specifying (name, value) pairs.  To be\n   precise, a list [{name = \"name1\"; value = value1;} ... {name =\n   \"nameN\"; value = valueN;}] is transformed to {name1 = value1;\n   ... nameN = valueN;}.  In case of duplicate occurences of the same\n   name, the first takes precedence. */\nstatic void prim_listToAttrs(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceList(*args[0], pos);\n\n    state.mkAttrs(v, args[0]->listSize());\n\n    std::set<Symbol> seen;\n\n    for (unsigned int i = 0; i < args[0]->listSize(); ++i) {\n        Value & v2(*args[0]->listElems()[i]);\n        state.forceAttrs(v2, pos);\n\n        Bindings::iterator j = v2.attrs->find(state.sName);\n        if (j == v2.attrs->end())\n            throw TypeError(format(\"'name' attribute missing in a call to 'listToAttrs', at %1%\") % pos);\n        string name = state.forceStringNoCtx(*j->value, pos);\n\n        Symbol sym = state.symbols.create(name);\n        if (seen.find(sym) == seen.end()) {\n            Bindings::iterator j2 = v2.attrs->find(state.symbols.create(state.sValue));\n            if (j2 == v2.attrs->end())\n                throw TypeError(format(\"'value' attribute missing in a call to 'listToAttrs', at %1%\") % pos);\n\n            v.attrs->push_back(Attr(sym, j2->value, j2->pos));\n            seen.insert(sym);\n        }\n    }\n\n    v.attrs->sort();\n}\n\n\n/* Return the right-biased intersection of two sets as1 and as2,\n   i.e. a set that contains every attribute from as2 that is also a\n   member of as1. */\nstatic void prim_intersectAttrs(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceAttrs(*args[0], pos);\n    state.forceAttrs(*args[1], pos);\n\n    state.mkAttrs(v, std::min(args[0]->attrs->size(), args[1]->attrs->size()));\n\n    for (auto & i : *args[0]->attrs) {\n        Bindings::iterator j = args[1]->attrs->find(i.name);\n        if (j != args[1]->attrs->end())\n            v.attrs->push_back(*j);\n    }\n}\n\n\n/* Collect each attribute named `attr' from a list of attribute sets.\n   Sets that don't contain the named attribute are ignored.\n\n   Example:\n     catAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}]\n     => [1 2]\n*/\nstatic void prim_catAttrs(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    Symbol attrName = state.symbols.create(state.forceStringNoCtx(*args[0], pos));\n    state.forceList(*args[1], pos);\n\n    Value * res[args[1]->listSize()];\n    unsigned int found = 0;\n\n    for (unsigned int n = 0; n < args[1]->listSize(); ++n) {\n        Value & v2(*args[1]->listElems()[n]);\n        state.forceAttrs(v2, pos);\n        Bindings::iterator i = v2.attrs->find(attrName);\n        if (i != v2.attrs->end())\n            res[found++] = i->value;\n    }\n\n    state.mkList(v, found);\n    for (unsigned int n = 0; n < found; ++n)\n        v.listElems()[n] = res[n];\n}\n\n\n/* Return a set containing the names of the formal arguments expected\n   by the function `f'.  The value of each attribute is a Boolean\n   denoting whether the corresponding argument has a default value.  For instance,\n\n      functionArgs ({ x, y ? 123}: ...)\n   => { x = false; y = true; }\n\n   \"Formal argument\" here refers to the attributes pattern-matched by\n   the function.  Plain lambdas are not included, e.g.\n\n      functionArgs (x: ...)\n   => { }\n*/\nstatic void prim_functionArgs(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    if (args[0]->type != tLambda)\n        throw TypeError(format(\"'functionArgs' requires a function, at %1%\") % pos);\n\n    if (!args[0]->lambda.fun->matchAttrs) {\n        state.mkAttrs(v, 0);\n        return;\n    }\n\n    state.mkAttrs(v, args[0]->lambda.fun->formals->formals.size());\n    for (auto & i : args[0]->lambda.fun->formals->formals)\n        // !!! should optimise booleans (allocate only once)\n        mkBool(*state.allocAttr(v, i.name), i.def);\n    v.attrs->sort();\n}\n\n\n/*************************************************************\n * Lists\n *************************************************************/\n\n\n/* Determine whether the argument is a list. */\nstatic void prim_isList(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->isList());\n}\n\n\nstatic void elemAt(EvalState & state, const Pos & pos, Value & list, int n, Value & v)\n{\n    state.forceList(list, pos);\n    if (n < 0 || (unsigned int) n >= list.listSize())\n        throw Error(format(\"list index %1% is out of bounds, at %2%\") % n % pos);\n    state.forceValue(*list.listElems()[n]);\n    v = *list.listElems()[n];\n}\n\n\n/* Return the n-1'th element of a list. */\nstatic void prim_elemAt(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    elemAt(state, pos, *args[0], state.forceInt(*args[1], pos), v);\n}\n\n\n/* Return the first element of a list. */\nstatic void prim_head(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    elemAt(state, pos, *args[0], 0, v);\n}\n\n\n/* Return a list consisting of everything but the first element of\n   a list.  Warning: this function takes O(n) time, so you probably\n   don't want to use it!  */\nstatic void prim_tail(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceList(*args[0], pos);\n    if (args[0]->listSize() == 0)\n        throw Error(format(\"'tail' called on an empty list, at %1%\") % pos);\n    state.mkList(v, args[0]->listSize() - 1);\n    for (unsigned int n = 0; n < v.listSize(); ++n)\n        v.listElems()[n] = args[0]->listElems()[n + 1];\n}\n\n\n/* Apply a function to every element of a list. */\nstatic void prim_map(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceFunction(*args[0], pos);\n    state.forceList(*args[1], pos);\n\n    state.mkList(v, args[1]->listSize());\n\n    for (unsigned int n = 0; n < v.listSize(); ++n)\n        mkApp(*(v.listElems()[n] = state.allocValue()),\n            *args[0], *args[1]->listElems()[n]);\n}\n\n\n/* Filter a list using a predicate; that is, return a list containing\n   every element from the list for which the predicate function\n   returns true. */\nstatic void prim_filter(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceFunction(*args[0], pos);\n    state.forceList(*args[1], pos);\n\n    // FIXME: putting this on the stack is risky.\n    Value * vs[args[1]->listSize()];\n    unsigned int k = 0;\n\n    bool same = true;\n    for (unsigned int n = 0; n < args[1]->listSize(); ++n) {\n        Value res;\n        state.callFunction(*args[0], *args[1]->listElems()[n], res, noPos);\n        if (state.forceBool(res, pos))\n            vs[k++] = args[1]->listElems()[n];\n        else\n            same = false;\n    }\n\n    if (same)\n        v = *args[1];\n    else {\n        state.mkList(v, k);\n        for (unsigned int n = 0; n < k; ++n) v.listElems()[n] = vs[n];\n    }\n}\n\n\n/* Return true if a list contains a given element. */\nstatic void prim_elem(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    bool res = false;\n    state.forceList(*args[1], pos);\n    for (unsigned int n = 0; n < args[1]->listSize(); ++n)\n        if (state.eqValues(*args[0], *args[1]->listElems()[n])) {\n            res = true;\n            break;\n        }\n    mkBool(v, res);\n}\n\n\n/* Concatenate a list of lists. */\nstatic void prim_concatLists(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceList(*args[0], pos);\n    state.concatLists(v, args[0]->listSize(), args[0]->listElems(), pos);\n}\n\n\n/* Return the length of a list.  This is an O(1) time operation. */\nstatic void prim_length(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceList(*args[0], pos);\n    mkInt(v, args[0]->listSize());\n}\n\n\n/* Reduce a list by applying a binary operator, from left to\n   right. The operator is applied strictly. */\nstatic void prim_foldlStrict(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceFunction(*args[0], pos);\n    state.forceList(*args[2], pos);\n\n    Value * vCur = args[1];\n\n    if (args[2]->listSize())\n        for (unsigned int n = 0; n < args[2]->listSize(); ++n) {\n            Value vTmp;\n            state.callFunction(*args[0], *vCur, vTmp, pos);\n            vCur = n == args[2]->listSize() - 1 ? &v : state.allocValue();\n            state.callFunction(vTmp, *args[2]->listElems()[n], *vCur, pos);\n        }\n    else\n        v = *vCur;\n\n    state.forceValue(v);\n}\n\n\nstatic void anyOrAll(bool any, EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceFunction(*args[0], pos);\n    state.forceList(*args[1], pos);\n\n    Value vTmp;\n    for (unsigned int n = 0; n < args[1]->listSize(); ++n) {\n        state.callFunction(*args[0], *args[1]->listElems()[n], vTmp, pos);\n        bool res = state.forceBool(vTmp, pos);\n        if (res == any) {\n            mkBool(v, any);\n            return;\n        }\n    }\n\n    mkBool(v, !any);\n}\n\n\nstatic void prim_any(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    anyOrAll(true, state, pos, args, v);\n}\n\n\nstatic void prim_all(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    anyOrAll(false, state, pos, args, v);\n}\n\n\nstatic void prim_genList(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceFunction(*args[0], pos);\n    auto len = state.forceInt(*args[1], pos);\n\n    if (len < 0)\n        throw EvalError(format(\"cannot create list of size %1%, at %2%\") % len % pos);\n\n    state.mkList(v, len);\n\n    for (unsigned int n = 0; n < (unsigned int) len; ++n) {\n        Value * arg = state.allocValue();\n        mkInt(*arg, n);\n        mkApp(*(v.listElems()[n] = state.allocValue()), *args[0], *arg);\n    }\n}\n\n\nstatic void prim_lessThan(EvalState & state, const Pos & pos, Value * * args, Value & v);\n\n\nstatic void prim_sort(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceFunction(*args[0], pos);\n    state.forceList(*args[1], pos);\n\n    auto len = args[1]->listSize();\n    state.mkList(v, len);\n    for (unsigned int n = 0; n < len; ++n) {\n        state.forceValue(*args[1]->listElems()[n]);\n        v.listElems()[n] = args[1]->listElems()[n];\n    }\n\n\n    auto comparator = [&](Value * a, Value * b) {\n        /* Optimization: if the comparator is lessThan, bypass\n           callFunction. */\n        if (args[0]->type == tPrimOp && args[0]->primOp->fun == prim_lessThan)\n            return CompareValues()(a, b);\n\n        Value vTmp1, vTmp2;\n        state.callFunction(*args[0], *a, vTmp1, pos);\n        state.callFunction(vTmp1, *b, vTmp2, pos);\n        return state.forceBool(vTmp2, pos);\n    };\n\n    /* FIXME: std::sort can segfault if the comparator is not a strict\n       weak ordering. What to do? std::stable_sort() seems more\n       resilient, but no guarantees... */\n    std::stable_sort(v.listElems(), v.listElems() + len, comparator);\n}\n\n\nstatic void prim_partition(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceFunction(*args[0], pos);\n    state.forceList(*args[1], pos);\n\n    auto len = args[1]->listSize();\n\n    ValueVector right, wrong;\n\n    for (unsigned int n = 0; n < len; ++n) {\n        auto vElem = args[1]->listElems()[n];\n        state.forceValue(*vElem);\n        Value res;\n        state.callFunction(*args[0], *vElem, res, pos);\n        if (state.forceBool(res, pos))\n            right.push_back(vElem);\n        else\n            wrong.push_back(vElem);\n    }\n\n    state.mkAttrs(v, 2);\n\n    Value * vRight = state.allocAttr(v, state.sRight);\n    state.mkList(*vRight, right.size());\n    memcpy(vRight->listElems(), right.data(), sizeof(Value *) * right.size());\n\n    Value * vWrong = state.allocAttr(v, state.sWrong);\n    state.mkList(*vWrong, wrong.size());\n    memcpy(vWrong->listElems(), wrong.data(), sizeof(Value *) * wrong.size());\n\n    v.attrs->sort();\n}\n\n\n/*************************************************************\n * Integer arithmetic\n *************************************************************/\n\n\nstatic void prim_add(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    if (args[0]->type == tFloat || args[1]->type == tFloat)\n        mkFloat(v, state.forceFloat(*args[0], pos) + state.forceFloat(*args[1], pos));\n    else\n        mkInt(v, state.forceInt(*args[0], pos) + state.forceInt(*args[1], pos));\n}\n\n\nstatic void prim_sub(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    if (args[0]->type == tFloat || args[1]->type == tFloat)\n        mkFloat(v, state.forceFloat(*args[0], pos) - state.forceFloat(*args[1], pos));\n    else\n        mkInt(v, state.forceInt(*args[0], pos) - state.forceInt(*args[1], pos));\n}\n\n\nstatic void prim_mul(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    if (args[0]->type == tFloat || args[1]->type == tFloat)\n        mkFloat(v, state.forceFloat(*args[0], pos) * state.forceFloat(*args[1], pos));\n    else\n        mkInt(v, state.forceInt(*args[0], pos) * state.forceInt(*args[1], pos));\n}\n\n\nstatic void prim_div(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    NixFloat f2 = state.forceFloat(*args[1], pos);\n    if (f2 == 0) throw EvalError(format(\"division by zero, at %1%\") % pos);\n\n    if (args[0]->type == tFloat || args[1]->type == tFloat) {\n        mkFloat(v, state.forceFloat(*args[0], pos) / state.forceFloat(*args[1], pos));\n    } else {\n        NixInt i1 = state.forceInt(*args[0], pos);\n        NixInt i2 = state.forceInt(*args[1], pos);\n        /* Avoid division overflow as it might raise SIGFPE. */\n        if (i1 == std::numeric_limits<NixInt>::min() && i2 == -1)\n            throw EvalError(format(\"overflow in integer division, at %1%\") % pos);\n        mkInt(v, i1 / i2);\n    }\n}\n\n\nstatic void prim_lessThan(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    state.forceValue(*args[1]);\n    CompareValues comp;\n    mkBool(v, comp(args[0], args[1]));\n}\n\n\n/*************************************************************\n * String manipulation\n *************************************************************/\n\n\n/* Convert the argument to a string.  Paths are *not* copied to the\n   store, so `toString /foo/bar' yields `\"/foo/bar\"', not\n   `\"/nix/store/whatever...\"'. */\nstatic void prim_toString(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    string s = state.coerceToString(pos, *args[0], context, true, false);\n    mkString(v, s, context);\n}\n\n\n/* `substring start len str' returns the substring of `str' starting\n   at character position `min(start, stringLength str)' inclusive and\n   ending at `min(start + len, stringLength str)'.  `start' must be\n   non-negative. */\nstatic void prim_substring(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    int start = state.forceInt(*args[0], pos);\n    int len = state.forceInt(*args[1], pos);\n    PathSet context;\n    string s = state.coerceToString(pos, *args[2], context);\n\n    if (start < 0) throw EvalError(format(\"negative start position in 'substring', at %1%\") % pos);\n\n    mkString(v, (unsigned int) start >= s.size() ? \"\" : string(s, start, len), context);\n}\n\n\nstatic void prim_stringLength(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    string s = state.coerceToString(pos, *args[0], context);\n    mkInt(v, s.size());\n}\n\n\nstatic void prim_unsafeDiscardStringContext(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    string s = state.coerceToString(pos, *args[0], context);\n    mkString(v, s, PathSet());\n}\n\n\nstatic void prim_hasContext(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    state.forceString(*args[0], context, pos);\n    mkBool(v, !context.empty());\n}\n\n\n/* Sometimes we want to pass a derivation path (i.e. pkg.drvPath) to a\n   builder without causing the derivation to be built (for instance,\n   in the derivation that builds NARs in nix-push, when doing\n   source-only deployment).  This primop marks the string context so\n   that builtins.derivation adds the path to drv.inputSrcs rather than\n   drv.inputDrvs. */\nstatic void prim_unsafeDiscardOutputDependency(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    string s = state.coerceToString(pos, *args[0], context);\n\n    PathSet context2;\n    for (auto & p : context)\n        context2.insert(p.at(0) == '=' ? \"~\" + string(p, 1) : p);\n\n    mkString(v, s, context2);\n}\n\n\n/* Return the cryptographic hash of a string in base-16. */\nstatic void prim_hashString(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string type = state.forceStringNoCtx(*args[0], pos);\n    HashType ht = parseHashType(type);\n    if (ht == htUnknown)\n      throw Error(format(\"unknown hash type '%1%', at %2%\") % type % pos);\n\n    PathSet context; // discarded\n    string s = state.forceString(*args[1], context, pos);\n\n    mkString(v, hashString(ht, s).to_string(Base16, false), context);\n}\n\n\n/* Match a regular expression against a string and return either\n   \u2018null\u2019 or a list containing substring matches. */\nstatic void prim_match(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    auto re = state.forceStringNoCtx(*args[0], pos);\n\n    try {\n\n        std::regex regex(re, std::regex::extended);\n\n        PathSet context;\n        const std::string str = state.forceString(*args[1], context, pos);\n\n        std::smatch match;\n        if (!std::regex_match(str, match, regex)) {\n            mkNull(v);\n            return;\n        }\n\n        // the first match is the whole string\n        const size_t len = match.size() - 1;\n        state.mkList(v, len);\n        for (size_t i = 0; i < len; ++i) {\n            if (!match[i+1].matched)\n                mkNull(*(v.listElems()[i] = state.allocValue()));\n            else\n                mkString(*(v.listElems()[i] = state.allocValue()), match[i + 1].str().c_str());\n        }\n\n    } catch (std::regex_error &e) {\n        if (e.code() == std::regex_constants::error_space) {\n          // limit is _GLIBCXX_REGEX_STATE_LIMIT for libstdc++\n          throw EvalError(\"memory limit exceeded by regular expression '%s', at %s\", re, pos);\n        } else {\n          throw EvalError(\"invalid regular expression '%s', at %s\", re, pos);\n        }\n    }\n}\n\n\n/* Split a string with a regular expression, and return a list of the\n   non-matching parts interleaved by the lists of the matching groups. */\nstatic void prim_split(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    auto re = state.forceStringNoCtx(*args[0], pos);\n\n    try {\n\n        std::regex regex(re, std::regex::extended);\n\n        PathSet context;\n        const std::string str = state.forceString(*args[1], context, pos);\n\n        auto begin = std::sregex_iterator(str.begin(), str.end(), regex);\n        auto end = std::sregex_iterator();\n\n        // Any matches results are surrounded by non-matching results.\n        const size_t len = std::distance(begin, end);\n        state.mkList(v, 2 * len + 1);\n        size_t idx = 0;\n        Value * elem;\n\n        if (len == 0) {\n            v.listElems()[idx++] = args[1];\n            return;\n        }\n\n        for (std::sregex_iterator i = begin; i != end; ++i) {\n            assert(idx <= 2 * len + 1 - 3);\n            std::smatch match = *i;\n\n            // Add a string for non-matched characters.\n            elem = v.listElems()[idx++] = state.allocValue();\n            mkString(*elem, match.prefix().str().c_str());\n\n            // Add a list for matched substrings.\n            const size_t slen = match.size() - 1;\n            elem = v.listElems()[idx++] = state.allocValue();\n\n            // Start at 1, beacause the first match is the whole string.\n            state.mkList(*elem, slen);\n            for (size_t si = 0; si < slen; ++si) {\n                if (!match[si + 1].matched)\n                    mkNull(*(elem->listElems()[si] = state.allocValue()));\n                else\n                    mkString(*(elem->listElems()[si] = state.allocValue()), match[si + 1].str().c_str());\n            }\n\n            // Add a string for non-matched suffix characters.\n            if (idx == 2 * len) {\n                elem = v.listElems()[idx++] = state.allocValue();\n                mkString(*elem, match.suffix().str().c_str());\n            }\n        }\n        assert(idx == 2 * len + 1);\n\n    } catch (std::regex_error &e) {\n        if (e.code() == std::regex_constants::error_space) {\n          // limit is _GLIBCXX_REGEX_STATE_LIMIT for libstdc++\n          throw EvalError(\"memory limit exceeded by regular expression '%s', at %s\", re, pos);\n        } else {\n          throw EvalError(\"invalid regular expression '%s', at %s\", re, pos);\n        }\n    }\n}\n\n\nstatic void prim_concatStringSep(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n\n    auto sep = state.forceString(*args[0], context, pos);\n    state.forceList(*args[1], pos);\n\n    string res;\n    res.reserve((args[1]->listSize() + 32) * sep.size());\n    bool first = true;\n\n    for (unsigned int n = 0; n < args[1]->listSize(); ++n) {\n        if (first) first = false; else res += sep;\n        res += state.coerceToString(pos, *args[1]->listElems()[n], context);\n    }\n\n    mkString(v, res, context);\n}\n\n\nstatic void prim_replaceStrings(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceList(*args[0], pos);\n    state.forceList(*args[1], pos);\n    if (args[0]->listSize() != args[1]->listSize())\n        throw EvalError(format(\"'from' and 'to' arguments to 'replaceStrings' have different lengths, at %1%\") % pos);\n\n    vector<string> from;\n    from.reserve(args[0]->listSize());\n    for (unsigned int n = 0; n < args[0]->listSize(); ++n)\n        from.push_back(state.forceString(*args[0]->listElems()[n], pos));\n\n    vector<std::pair<string, PathSet>> to;\n    to.reserve(args[1]->listSize());\n    for (unsigned int n = 0; n < args[1]->listSize(); ++n) {\n        PathSet ctx;\n        auto s = state.forceString(*args[1]->listElems()[n], ctx, pos);\n        to.push_back(std::make_pair(std::move(s), std::move(ctx)));\n    }\n\n    PathSet context;\n    auto s = state.forceString(*args[2], context, pos);\n\n    string res;\n    // Loops one past last character to handle the case where 'from' contains an empty string.\n    for (size_t p = 0; p <= s.size(); ) {\n        bool found = false;\n        auto i = from.begin();\n        auto j = to.begin();\n        for (; i != from.end(); ++i, ++j)\n            if (s.compare(p, i->size(), *i) == 0) {\n                found = true;\n                res += j->first;\n                if (i->empty()) {\n                    if (p < s.size())\n                        res += s[p];\n                    p++;\n                } else {\n                    p += i->size();\n                }\n                for (auto& path : j->second)\n                    context.insert(path);\n                j->second.clear();\n                break;\n            }\n        if (!found) {\n            if (p < s.size())\n                res += s[p];\n            p++;\n        }\n    }\n\n    mkString(v, res, context);\n}\n\n\n/*************************************************************\n * Versions\n *************************************************************/\n\n\nstatic void prim_parseDrvName(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string name = state.forceStringNoCtx(*args[0], pos);\n    DrvName parsed(name);\n    state.mkAttrs(v, 2);\n    mkString(*state.allocAttr(v, state.sName), parsed.name);\n    mkString(*state.allocAttr(v, state.symbols.create(\"version\")), parsed.version);\n    v.attrs->sort();\n}\n\n\nstatic void prim_compareVersions(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string version1 = state.forceStringNoCtx(*args[0], pos);\n    string version2 = state.forceStringNoCtx(*args[1], pos);\n    mkInt(v, compareVersions(version1, version2));\n}\n\n\nstatic void prim_splitVersion(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string version = state.forceStringNoCtx(*args[0], pos);\n    auto iter = version.cbegin();\n    Strings components;\n    while (iter != version.cend()) {\n        auto component = nextComponent(iter, version.cend());\n        if (component.empty())\n            break;\n        components.emplace_back(std::move(component));\n    }\n    state.mkList(v, components.size());\n    unsigned int n = 0;\n    for (auto & component : components) {\n        auto listElem = v.listElems()[n++] = state.allocValue();\n        mkString(*listElem, std::move(component));\n    }\n}\n\n\n/*************************************************************\n * Networking\n *************************************************************/\n\n\nvoid fetch(EvalState & state, const Pos & pos, Value * * args, Value & v,\n    const string & who, bool unpack, const std::string & defaultName)\n{\n    string url;\n    Hash expectedHash;\n    string name = defaultName;\n\n    state.forceValue(*args[0]);\n\n    if (args[0]->type == tAttrs) {\n\n        state.forceAttrs(*args[0], pos);\n\n        for (auto & attr : *args[0]->attrs) {\n            string n(attr.name);\n            if (n == \"url\")\n                url = state.forceStringNoCtx(*attr.value, *attr.pos);\n            else if (n == \"sha256\")\n                expectedHash = Hash(state.forceStringNoCtx(*attr.value, *attr.pos), htSHA256);\n            else if (n == \"name\")\n                name = state.forceStringNoCtx(*attr.value, *attr.pos);\n            else\n                throw EvalError(format(\"unsupported argument '%1%' to '%2%', at %3%\") % attr.name % who % attr.pos);\n        }\n\n        if (url.empty())\n            throw EvalError(format(\"'url' argument required, at %1%\") % pos);\n\n    } else\n        url = state.forceStringNoCtx(*args[0], pos);\n\n    state.checkURI(url);\n\n    if (settings.pureEval && !expectedHash)\n        throw Error(\"in pure evaluation mode, '%s' requires a 'sha256' argument\", who);\n\n    Path res = getDownloader()->downloadCached(state.store, url, unpack, name, expectedHash);\n\n    if (state.allowedPaths)\n        state.allowedPaths->insert(res);\n\n    mkString(v, res, PathSet({res}));\n}\n\n\nstatic void prim_fetchurl(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    fetch(state, pos, args, v, \"fetchurl\", false, \"\");\n}\n\n\nstatic void prim_fetchTarball(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    fetch(state, pos, args, v, \"fetchTarball\", true, \"source\");\n}\n\n\n/*************************************************************\n * Primop registration\n *************************************************************/\n\n\nRegisterPrimOp::PrimOps * RegisterPrimOp::primOps;\n\n\nRegisterPrimOp::RegisterPrimOp(std::string name, size_t arity, PrimOpFun fun)\n{\n    if (!primOps) primOps = new PrimOps;\n    primOps->emplace_back(name, arity, fun);\n}\n\n\nvoid EvalState::createBaseEnv()\n{\n    baseEnv.up = 0;\n\n    /* Add global constants such as `true' to the base environment. */\n    Value v;\n\n    /* `builtins' must be first! */\n    mkAttrs(v, 128);\n    addConstant(\"builtins\", v);\n\n    mkBool(v, true);\n    addConstant(\"true\", v);\n\n    mkBool(v, false);\n    addConstant(\"false\", v);\n\n    mkNull(v);\n    addConstant(\"null\", v);\n\n    auto vThrow = addPrimOp(\"throw\", 1, prim_throw);\n\n    auto addPurityError = [&](const std::string & name) {\n        Value * v2 = allocValue();\n        mkString(*v2, fmt(\"'%s' is not allowed in pure evaluation mode\", name));\n        mkApp(v, *vThrow, *v2);\n        addConstant(name, v);\n    };\n\n    if (!settings.pureEval) {\n        mkInt(v, time(0));\n        addConstant(\"__currentTime\", v);\n    }\n\n    if (!settings.pureEval) {\n        mkString(v, settings.thisSystem);\n        addConstant(\"__currentSystem\", v);\n    }\n\n    mkString(v, nixVersion);\n    addConstant(\"__nixVersion\", v);\n\n    mkString(v, store->storeDir);\n    addConstant(\"__storeDir\", v);\n\n    /* Language version.  This should be increased every time a new\n       language feature gets added.  It's not necessary to increase it\n       when primops get added, because you can just use `builtins ?\n       primOp' to check. */\n    mkInt(v, 5);\n    addConstant(\"__langVersion\", v);\n\n    // Miscellaneous\n    auto vScopedImport = addPrimOp(\"scopedImport\", 2, prim_scopedImport);\n    Value * v2 = allocValue();\n    mkAttrs(*v2, 0);\n    mkApp(v, *vScopedImport, *v2);\n    forceValue(v);\n    addConstant(\"import\", v);\n    if (settings.enableNativeCode) {\n        addPrimOp(\"__importNative\", 2, prim_importNative);\n        addPrimOp(\"__exec\", 1, prim_exec);\n    }\n    addPrimOp(\"__typeOf\", 1, prim_typeOf);\n    addPrimOp(\"isNull\", 1, prim_isNull);\n    addPrimOp(\"__isFunction\", 1, prim_isFunction);\n    addPrimOp(\"__isString\", 1, prim_isString);\n    addPrimOp(\"__isInt\", 1, prim_isInt);\n    addPrimOp(\"__isFloat\", 1, prim_isFloat);\n    addPrimOp(\"__isBool\", 1, prim_isBool);\n    addPrimOp(\"__genericClosure\", 1, prim_genericClosure);\n    addPrimOp(\"abort\", 1, prim_abort);\n    addPrimOp(\"__addErrorContext\", 2, prim_addErrorContext);\n    addPrimOp(\"__tryEval\", 1, prim_tryEval);\n    addPrimOp(\"__getEnv\", 1, prim_getEnv);\n\n    // Strictness\n    addPrimOp(\"__seq\", 2, prim_seq);\n    addPrimOp(\"__deepSeq\", 2, prim_deepSeq);\n\n    // Debugging\n    addPrimOp(\"__trace\", 2, prim_trace);\n    addPrimOp(\"__valueSize\", 1, prim_valueSize);\n\n    // Paths\n    addPrimOp(\"__toPath\", 1, prim_toPath);\n    if (settings.pureEval)\n        addPurityError(\"__storePath\");\n    else\n        addPrimOp(\"__storePath\", 1, prim_storePath);\n    addPrimOp(\"__pathExists\", 1, prim_pathExists);\n    addPrimOp(\"baseNameOf\", 1, prim_baseNameOf);\n    addPrimOp(\"dirOf\", 1, prim_dirOf);\n    addPrimOp(\"__readFile\", 1, prim_readFile);\n    addPrimOp(\"__readDir\", 1, prim_readDir);\n    addPrimOp(\"__findFile\", 2, prim_findFile);\n\n    // Creating files\n    addPrimOp(\"__toXML\", 1, prim_toXML);\n    addPrimOp(\"__toJSON\", 1, prim_toJSON);\n    addPrimOp(\"__fromJSON\", 1, prim_fromJSON);\n    addPrimOp(\"__toFile\", 2, prim_toFile);\n    addPrimOp(\"__filterSource\", 2, prim_filterSource);\n    addPrimOp(\"__path\", 1, prim_path);\n\n    // Sets\n    addPrimOp(\"__attrNames\", 1, prim_attrNames);\n    addPrimOp(\"__attrValues\", 1, prim_attrValues);\n    addPrimOp(\"__getAttr\", 2, prim_getAttr);\n    addPrimOp(\"__unsafeGetAttrPos\", 2, prim_unsafeGetAttrPos);\n    addPrimOp(\"__hasAttr\", 2, prim_hasAttr);\n    addPrimOp(\"__isAttrs\", 1, prim_isAttrs);\n    addPrimOp(\"removeAttrs\", 2, prim_removeAttrs);\n    addPrimOp(\"__listToAttrs\", 1, prim_listToAttrs);\n    addPrimOp(\"__intersectAttrs\", 2, prim_intersectAttrs);\n    addPrimOp(\"__catAttrs\", 2, prim_catAttrs);\n    addPrimOp(\"__functionArgs\", 1, prim_functionArgs);\n\n    // Lists\n    addPrimOp(\"__isList\", 1, prim_isList);\n    addPrimOp(\"__elemAt\", 2, prim_elemAt);\n    addPrimOp(\"__head\", 1, prim_head);\n    addPrimOp(\"__tail\", 1, prim_tail);\n    addPrimOp(\"map\", 2, prim_map);\n    addPrimOp(\"__filter\", 2, prim_filter);\n    addPrimOp(\"__elem\", 2, prim_elem);\n    addPrimOp(\"__concatLists\", 1, prim_concatLists);\n    addPrimOp(\"__length\", 1, prim_length);\n    addPrimOp(\"__foldl'\", 3, prim_foldlStrict);\n    addPrimOp(\"__any\", 2, prim_any);\n    addPrimOp(\"__all\", 2, prim_all);\n    addPrimOp(\"__genList\", 2, prim_genList);\n    addPrimOp(\"__sort\", 2, prim_sort);\n    addPrimOp(\"__partition\", 2, prim_partition);\n\n    // Integer arithmetic\n    addPrimOp(\"__add\", 2, prim_add);\n    addPrimOp(\"__sub\", 2, prim_sub);\n    addPrimOp(\"__mul\", 2, prim_mul);\n    addPrimOp(\"__div\", 2, prim_div);\n    addPrimOp(\"__lessThan\", 2, prim_lessThan);\n\n    // String manipulation\n    addPrimOp(\"toString\", 1, prim_toString);\n    addPrimOp(\"__substring\", 3, prim_substring);\n    addPrimOp(\"__stringLength\", 1, prim_stringLength);\n    addPrimOp(\"__hasContext\", 1, prim_hasContext);\n    addPrimOp(\"__unsafeDiscardStringContext\", 1, prim_unsafeDiscardStringContext);\n    addPrimOp(\"__unsafeDiscardOutputDependency\", 1, prim_unsafeDiscardOutputDependency);\n    addPrimOp(\"__hashString\", 2, prim_hashString);\n    addPrimOp(\"__match\", 2, prim_match);\n    addPrimOp(\"__split\", 2, prim_split);\n    addPrimOp(\"__concatStringsSep\", 2, prim_concatStringSep);\n    addPrimOp(\"__replaceStrings\", 3, prim_replaceStrings);\n\n    // Versions\n    addPrimOp(\"__parseDrvName\", 1, prim_parseDrvName);\n    addPrimOp(\"__compareVersions\", 2, prim_compareVersions);\n    addPrimOp(\"__splitVersion\", 1, prim_splitVersion);\n\n    // Derivations\n    addPrimOp(\"derivationStrict\", 1, prim_derivationStrict);\n    addPrimOp(\"placeholder\", 1, prim_placeholder);\n\n    // Networking\n    addPrimOp(\"__fetchurl\", 1, prim_fetchurl);\n    addPrimOp(\"fetchTarball\", 1, prim_fetchTarball);\n\n    /* Add a wrapper around the derivation primop that computes the\n       `drvPath' and `outPath' attributes lazily. */\n    string path = canonPath(settings.nixDataDir + \"/nix/corepkgs/derivation.nix\", true);\n    sDerivationNix = symbols.create(path);\n    evalFile(path, v);\n    addConstant(\"derivation\", v);\n\n    /* Add a value containing the current Nix expression search path. */\n    mkList(v, searchPath.size());\n    int n = 0;\n    for (auto & i : searchPath) {\n        v2 = v.listElems()[n++] = allocValue();\n        mkAttrs(*v2, 2);\n        mkString(*allocAttr(*v2, symbols.create(\"path\")), i.second);\n        mkString(*allocAttr(*v2, symbols.create(\"prefix\")), i.first);\n        v2->attrs->sort();\n    }\n    addConstant(\"__nixPath\", v);\n\n    if (RegisterPrimOp::primOps)\n        for (auto & primOp : *RegisterPrimOp::primOps)\n            addPrimOp(std::get<0>(primOp), std::get<1>(primOp), std::get<2>(primOp));\n\n    /* Now that we've added all primops, sort the `builtins' set,\n       because attribute lookups expect it to be sorted. */\n    baseEnv.values[0]->attrs->sort();\n}\n\n\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/src/boost/format.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/src/boost/format/internals.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/src/boost/format/feed_args.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/src/boost/format/exceptions.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/src/boost/format/internals_fwd.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/src/boost/format/format_fwd.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/src/boost/format/group.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/src/boost/format/macros_default.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/src/boost/format/format_class.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/src/boost/format/format_implementation.cc",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/src/boost/format/free_funcs.cc",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/images/callouts/3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/images/callouts/12.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/images/callouts/5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/images/callouts/8.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/images/callouts/4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/images/callouts/13.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/images/callouts/11.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/images/callouts/14.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/images/callouts/2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/images/callouts/9.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/images/callouts/15.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/images/callouts/6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/images/callouts/7.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/images/callouts/10.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/images/callouts/1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/figures/user-environments.png",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-cccakppey5efb2pscfnkcj7lnutai65w/spack-src/doc/manual/figures/user-environments.sxd"
    ],
    "total_files": 698
}