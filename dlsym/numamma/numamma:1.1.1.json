{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-numamma-1.1.1-gozxe2icbhdr6xcoj4p5lgkcu7fnou6u/spack-src/src/mem_intercept.c": "/* -*- c-file-style: \"GNU\" -*- */\n#define _GNU_SOURCE\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <inttypes.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <sys/time.h>\n#include <pthread.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include \"numamma.h\"\n#include \"mem_intercept.h\"\n#include \"mem_analyzer.h\"\n#include \"mem_tools.h\"\n\nstruct numamma_settings settings;\nstatic char dump_filename[STRING_LEN];\nFILE* dump_file = NULL;\nstatic char dump_unmatched_filename[STRING_LEN];\nFILE* dump_unmatched_file = NULL;\n__thread volatile int is_recurse_unsafe = 0;\n\n/* set to 1 when all the hooks are set.\n * This is useful in order to avoid recursive calls\n */\nstatic int __memory_initialized = 0;\n\nvoid* (*libcalloc)(size_t nmemb, size_t size) = NULL;\nvoid* (*libmalloc)(size_t size) = NULL;\nvoid (*libfree)(void *ptr) = NULL;\nvoid* (*librealloc)(void *ptr, size_t size) = NULL;\nint  (*libpthread_create) (pthread_t * thread, const pthread_attr_t * attr,\n\t\t\t   void *(*start_routine) (void *), void *arg) = NULL;\nvoid (*libpthread_exit) (void *thread_return) = NULL;\nvoid* (*lib_Znwm)(size_t size) = NULL; /* the \"new\" operator in c++ 64bits  */\nvoid* (*lib_Znwj)(size_t size) = NULL; /* the \"new\" operator in c++ 32bits  */\n\n/* Custom malloc function. It is used when libmalloc=NULL (e.g. during startup)\n * This function is not thread-safe and is very likely to be bogus, so use with\n * caution\n */\nstatic void* hand_made_malloc(size_t size) {\n  /* allocate a 1MB buffer */\n#define POOL_SIZE (1024 * 1024)\n  static char mem[POOL_SIZE] = {'\\0'};\n\n  /* since this function is only used before we found libmalloc, there's no\n   * fancy memory management mechanism (block reuse, etc.)\n   */\n  static char* next_slot = &mem[0];\n  static int total_alloc = 0;\n\n  if (libmalloc)\n    /* let's use the real malloc */\n    return malloc(size);\n\n  struct mem_block_info *p_block = NULL;\n  INIT_MEM_INFO(p_block, next_slot, size, 1);\n\n  p_block->mem_type = MEM_TYPE_HAND_MADE_MALLOC;\n  total_alloc += size;\n  next_slot = next_slot + p_block->total_size;\n\n  return p_block->u_ptr;\n}\n\n\n#define STRINGIFY(x) #x\n#define GENERIC_MALLOC(FNAME, MALLOC_TYPE, CALLBACK)\t\t\t\\\n  void* FNAME(size_t size) {\t\t\t\t\t\t\\\n    /* if memory_init hasn't been called yet, we need to get libc's malloc \\\n     * address\t\t\t\t\t\t\t\t\\\n     */\t\t\t\t\t\t\t\t\t\\\n    if (!CALLBACK) {\t\t\t\t\t\t\t\\\n      if( !IS_RECURSE_SAFE) {\t\t\t\t\t\t\\\n\t/* protection flag says that malloc is already trying to retrieve the \\\n\t * address of malloc.\t\t\t\t\t\t\\\n\t * If we call dlsym now, there will be an infinite recursion, so let's \\\n\t * allocate memory 'by hand'\t\t\t\t\t\\\n\t */\t\t\t\t\t\t\t\t\\\n\treturn hand_made_malloc(size);\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      /* set the protection flag and retrieve the address of malloc.\t\\\n       * If dlsym calls malloc, memory will be allocated 'by hand'\t\\\n       */\t\t\t\t\t\t\t\t\\\n      PROTECT_FROM_RECURSION;\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\tCALLBACK = dlsym(RTLD_NEXT, STRINGIFY(FNAME));\t\t\t\\\n\tchar* error;\t\t\t\t\t\t\t\\\n\tif ((error = dlerror()) != NULL) {\t\t\t\t\\\n\t  fputs(error, stderr);\t\t\t\t\t\t\\\n\t  exit(1);\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n      /* it is now safe to call libmalloc */\t\t\t\t\\\n      UNPROTECT_FROM_RECURSION;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    /* allocate a buffer */\t\t\t\t\t\t\\\n    PROTECT_FROM_RECURSION;\t\t\t\t\t\t\\\n    void* pptr = CALLBACK(size + HEADER_SIZE + TAIL_SIZE);\t\t\\\n    UNPROTECT_FROM_RECURSION;\t\t\t\t\t\t\\\n    /* fill the information on the malloc'd buffer */\t\t\t\\\n    struct mem_block_info *p_block = NULL;\t\t\t\t\\\n    INIT_MEM_INFO(p_block, pptr, size, 1);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    if(__memory_initialized && IS_RECURSE_SAFE) {\t\t\t\\\n      PROTECT_FROM_RECURSION;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      p_block->mem_type = MALLOC_TYPE;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      /* let the analysis module record information on the malloc */\t\\\n      ma_record_malloc(p_block);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      UNPROTECT_FROM_RECURSION;\t\t\t\t\t\t\\\n    } else {\t\t\t\t\t\t\t\t\\\n      /* we are already processing a malloc/free function, so don't try to record information, \\\n       * just call the function\t\t\t\t\t\t\\\n       */\t\t\t\t\t\t\t\t\\\n      p_block->mem_type = MEM_TYPE_INTERNAL_MALLOC;\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n    return p_block->u_ptr;\t\t\\\n  }\t\t\t\t\t\t\t\t\t\\\n\nGENERIC_MALLOC(malloc, MEM_TYPE_MALLOC, libmalloc);\nGENERIC_MALLOC(_Znwj, MEM_TYPE_NEW, libmalloc);\nGENERIC_MALLOC(_Znwm, MEM_TYPE_NEW, libmalloc);\n\nvoid* realloc(void *ptr, size_t size) {\n\n  /* if ptr is NULL, realloc behaves like malloc */\n  if (!ptr)\n    return malloc(size);\n\n  /* if size=0 and ptr isn't NULL, realloc behaves like free */\n  if (!size && ptr) {\n    free(ptr);\n    return NULL;\n  }\n\n  if (!librealloc) {\n    PROTECT_FROM_RECURSION;\n    librealloc = dlsym(RTLD_NEXT, \"realloc\");\n    UNPROTECT_FROM_RECURSION;\n    char* error;\n    if ((error = dlerror()) != NULL) {\n      fputs(error, stderr);\n      exit(1);\n    }\n  }\n\n  if (!CANARY_OK(ptr)) {\n    /* we didn't malloc'ed this buffer */\n    fprintf(stderr,\"%s(%p). I can't find this pointer !\\n\", __FUNCTION__, ptr);\n    abort();\n    void* retval = librealloc(ptr, size);\n    debug_printf(\"--> %p\\n\", retval);\n    return retval;\n  }\n\n  struct mem_block_info *p_block;\n  USER_PTR_TO_BLOCK_INFO(ptr, p_block);\n  size_t old_size = p_block->size;\n  size_t header_size = p_block->total_size - p_block->size;\n\n  if (p_block->mem_type == MEM_TYPE_HAND_MADE_MALLOC) {\n    /* the buffer was allocated by hand_made_malloc.\n     * we need to emulate the behavior of realloc:\n     * allocate a buffer, and copy the data to the new buffer\n     */\n    void* pptr = malloc(size);\n    memcpy(pptr, p_block->u_ptr, p_block->size);\n    return pptr;\n  }\n  void *old_addr= p_block->u_ptr;\n  void *pptr = librealloc(p_block->p_ptr, size + header_size);\n  INIT_MEM_INFO(p_block, pptr, size, 1);\n\n  if(__memory_initialized && IS_RECURSE_SAFE) {\n    PROTECT_FROM_RECURSION;\n    /* retrieve the malloc information from the pointer */\n\n    if (!pptr) {\n      /* realloc failed */\n      UNPROTECT_FROM_RECURSION;\n      return NULL;\n    }\n\n    p_block->mem_type = MEM_TYPE_MALLOC;\n    void *new_addr= p_block->u_ptr;\n    ma_update_buffer_address(p_block, old_addr, new_addr);\n    UNPROTECT_FROM_RECURSION;\n  } else {\n    /* it is not safe to record information */\n    p_block->mem_type = MEM_TYPE_INTERNAL_MALLOC;\n  }\n  return p_block->u_ptr;\n}\n\nvoid* calloc(size_t nmemb, size_t size) {\n  if (!libcalloc) {\n    void* ret = hand_made_malloc(nmemb * size);\n    if (ret) {\n      memset(ret, 0, nmemb * size);\n    }\n    return ret;\n  }\n\n  /* compute the number of blocks for header */\n  int nb_memb_header = (HEADER_SIZE  + TAIL_SIZE)/ size;\n  if (size * nb_memb_header < HEADER_SIZE + TAIL_SIZE)\n    nb_memb_header++;\n\n  /* allocate buffer + header */\n  PROTECT_FROM_RECURSION;\n  void* p_ptr = libcalloc(nmemb + nb_memb_header, size);\n  UNPROTECT_FROM_RECURSION;\n  \n  struct mem_block_info *p_block = NULL;\n  INIT_MEM_INFO(p_block, p_ptr, nmemb, size);\n\n\n  if(__memory_initialized && IS_RECURSE_SAFE) {\n    PROTECT_FROM_RECURSION;\n    p_block->mem_type = MEM_TYPE_MALLOC;\n\n    ma_record_malloc(p_block);\n    UNPROTECT_FROM_RECURSION;\n  } else {\n    p_block->mem_type = MEM_TYPE_INTERNAL_MALLOC;\n    //  return libcalloc(nmemb, size);\n  }\n  return p_block->u_ptr;\n}\n\nvoid free(void* ptr) {\n\n  if (!libfree) {\n    PROTECT_FROM_RECURSION;\n    libfree = dlsym(RTLD_NEXT, \"free\");\n    UNPROTECT_FROM_RECURSION;\n    char* error;\n    if ((error = dlerror()) != NULL) {\n      fputs(error, stderr);\n      exit(1);\n    }\n  }\n  if (!ptr) {\n    PROTECT_FROM_RECURSION;\n    libfree(ptr);\n    UNPROTECT_FROM_RECURSION;\t\n    return;\n  }\n\n  /* first, check wether we malloc'ed the buffer */\n  if (!CANARY_OK(ptr)) {\n    /* we didn't malloc this buffer */\n    fprintf(stderr, \"%s(%p). I don't know this malloc !\\n\", __FUNCTION__, ptr);\n    //    abort();\n    PROTECT_FROM_RECURSION;\n    libfree(ptr);\n    UNPROTECT_FROM_RECURSION;\n    return;\n  }\n\n  struct mem_block_info *p_block;\n  USER_PTR_TO_BLOCK_INFO(ptr, p_block);\n\n  /* retrieve the block information and free it */\n  if(__memory_initialized && IS_RECURSE_SAFE &&\n     (p_block->mem_type == MEM_TYPE_MALLOC || p_block->mem_type == MEM_TYPE_NEW) ) {\n    PROTECT_FROM_RECURSION;\n\n    if(!TAIL_CANARY_OK(p_block)) {\n      fprintf(stderr, \"Warning: tail canary erased :'( (%\" PRIu64 \" instead of %\" PRIu64 \")\\n\", p_block->tail_block->canary, CANARY_PATTERN);\n      abort();\n    }\n\n    ma_record_free(p_block);\n    UNPROTECT_FROM_RECURSION;\n  } else {\n    /* internal malloc or hand made malloc, nothing to do */\n  }\n  PROTECT_FROM_RECURSION;\n  libfree(p_block->p_ptr);\n  UNPROTECT_FROM_RECURSION;     \n}\n\n/* Internal structure used for transmitting the function and argument\n * during pthread_create.\n */\nstruct __pthread_create_info_t {\n  void *(*func)(void *);\n  void *arg;\n  int thread_rank;\n};\n\nenum thread_status_t {\n  thread_status_none,\n  thread_status_created,\n  thread_status_finalized\n};\n\nstruct thread_info {\n  pthread_t tid;\n  enum thread_status_t status;\n};\nstruct thread_info thread_array[MAX_THREADS];\nint nb_threads = 0;\n\nstatic void __thread_cleanup_function(void* arg);\n/* Invoked by pthread_create on the new thread */\nstatic void *\n__pthread_new_thread(void *arg) {\n  PROTECT_FROM_RECURSION;\n  void* res = NULL;\n  struct __pthread_create_info_t *p_arg = (struct __pthread_create_info_t*) arg;\n  void *(*f)(void *) = p_arg->func;\n  void *__arg = p_arg->arg;\n  int thread_rank = p_arg->thread_rank;\n  libfree(p_arg);\n  ma_thread_init();\n  thread_array[thread_rank].status = thread_status_created;\n\n  UNPROTECT_FROM_RECURSION;\n  int oldtype;\n  pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldtype);\n\n  pthread_cleanup_push(__thread_cleanup_function,\n\t\t       &thread_array[thread_rank]);\n\n  res = (*f)(__arg);\n\n  pthread_cleanup_pop(0);\n  fprintf(stderr, \"End of thread [%d] %lu\\n\", thread_rank, thread_array[thread_rank].tid);\n  __thread_cleanup_function(&thread_array[thread_rank]);\n  return res;\n}\n\n\nstatic void __thread_cleanup_function(void* arg) {\n  struct thread_info* me = arg;\n  is_recurse_unsafe ++;\n  ma_thread_finalize();\n  me->status = thread_status_finalized;\n  is_recurse_unsafe --;\n}\n\nint\npthread_create (pthread_t *__restrict thread,\n\t\tconst pthread_attr_t *__restrict attr,\n\t\tvoid *(*start_routine) (void *),\n\t\tvoid *__restrict arg) {\n  FUNCTION_ENTRY;\n  struct __pthread_create_info_t * __args =\n    (struct __pthread_create_info_t*) libmalloc(sizeof(struct __pthread_create_info_t));\n  __args->func = start_routine;\n  __args->arg = arg;\n\n  if (!libpthread_create) {\n    libpthread_create = dlsym(RTLD_NEXT, \"pthread_create\");\n  }\n\n  int thread_rank = __sync_fetch_and_add( &nb_threads, 1 );\n  __args->thread_rank = thread_rank;\n\n  /* We do not call directly start_routine since we want to initialize stuff at the thread startup.\n   * Instead, let's invoke __pthread_new_thread that initialize the thread-specific things and call\n   * start_routine.\n   */\n  int retval = libpthread_create(&thread_array[thread_rank].tid, attr, __pthread_new_thread, __args);\n  memcpy(thread, &thread_array[thread_rank].tid, sizeof(pthread_t));\n\n  return retval;\n}\n\nvoid pthread_exit(void *thread_return) {\n  FUNCTION_ENTRY;\n  PROTECT_FROM_RECURSION;\n  {\n    ma_thread_finalize();\n  }\n  UNPROTECT_FROM_RECURSION;\n  libpthread_exit(thread_return);\n  __builtin_unreachable();\n}\n\nchar *counters_dir=NULL;\n\nchar* get_log_dir() {\n  if(!counters_dir) {\n    counters_dir = malloc(STRING_LEN);\n    snprintf(counters_dir, STRING_LEN, \"%s\", settings.output_dir);\n    mkdir(counters_dir, S_IRWXU);\n  }\n  return counters_dir;\n}\n\nvoid create_log_filename(char* basename, char *filename, int length) {\n  snprintf(filename, length, \"%s/%s\", get_log_dir(), basename);\n}\n\n#define getenv_int(var, envname, default_value) do {\t\\\n    char* str = getenv(envname);\t\t\t\\\n    (var) = default_value;\t\t\t\t\\\n    if(str) {\t\t\t\t\t\t\\\n      (var) = atoi(str);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\\\n  } while(0)\n\nstatic void read_settings() {\n  getenv_int(settings.verbose, \"NUMAMMA_VERBOSE\", SETTINGS_VERBOSE_DEFAULT);\n  getenv_int(settings.sampling_rate, \"NUMAMMA_SAMPLING_RATE\", SETTINGS_SAMPLING_RATE_DEFAULT);\n  getenv_int(settings.alarm, \"NUMAMMA_ALARM\", SETTINGS_ALARM_DEFAULT);\n  getenv_int(settings.flush, \"NUMAMMA_FLUSH\", SETTINGS_FLUSH_DEFAULT);\n  getenv_int(settings.buffer_size, \"NUMAMMA_BUFFER_SIZE\", SETTINGS_BUFFER_SIZE_DEFAULT);\n\n  char* str = getenv(\"NUMAMMA_OUTPUT_DIR\");\n  settings.output_dir = malloc(STRING_LEN);\n  if(str) {\n    strncpy(settings.output_dir, str, STRING_LEN);\n  } else {\n    snprintf(settings.output_dir, STRING_LEN, \"/tmp/numamma_%s\", getenv(\"USER\"));\n  }\n\n  getenv_int(settings.match_samples, \"NUMAMMA_MATCH_SAMPLES\", SETTINGS_MATCH_SAMPLES_DEFAULT);\n  getenv_int(settings.online_analysis, \"NUMAMMA_ONLINE_ANALYSIS\", SETTINGS_ONLINE_ANALYSIS_DEFAULT);\n  getenv_int(settings.dump, \"NUMAMMA_DUMP\", SETTINGS_DUMP_DEFAULT);\n  getenv_int(settings.dump_unmatched, \"NUMAMMA_DUMP_UNMATCHED\", SETTINGS_DUMP_UNMATCHED_DEFAULT);\n}\n\nstatic void print_settings() {\n  printf(\"-----------------------------------\\n\");\n  printf(\"NumaMMA settings\\n\");\n  printf(\"verbose        : %s\\n\", settings.verbose ? \"yes\":\"no\");\n  printf(\"sampling_rate  : %d\\n\", settings.sampling_rate);\n  printf(\"alarm          : %d\\n\", settings.alarm);\n  printf(\"flush          : %s\\n\", settings.flush? \"yes\":\"no\");\n  printf(\"buffer_size    : %d KB\\n\", settings.buffer_size);\n  printf(\"output_dir     : %s\\n\", settings.output_dir);\n  printf(\"match_samples  : %s\\n\", settings.match_samples? \"yes\":\"no\");\n  printf(\"online_analysis: %s\\n\", settings.online_analysis? \"yes\":\"no\");\n  printf(\"dump           : %s\\n\", settings.dump? \"yes\":\"no\");\n  printf(\"dump_unmatched : %s\\n\", settings.dump_unmatched? \"yes\":\"no\");\n  printf(\"-----------------------------------\\n\");\n}\n\nextern char**environ;\nchar ld_preload_value[4096];\n\n/* unset LD_PRELOAD\n * this makes sure that forked processes will not be analyzed\n */\nvoid unset_ld_preload() {\n  /* unset LD_PRELOAD */\n  char* ld_preload = getenv(\"LD_PRELOAD\");\n  if(!ld_preload) {\n    ld_preload_value[0]='\\0';\n    return;\n  }\n\n  /* save the value of ld_preload so that we can set it back later */\n  strncpy(ld_preload_value, ld_preload, 4096);\n  int ret = unsetenv(\"LD_PRELOAD\");\n  if(ret != 0 ){\n    fprintf(stderr, \"unsetenv failed ! %s\\n\", strerror(errno));\n    abort();\n  }\n\n  /* also change the environ variable since exec* function\n   * rely on it.\n   */\n  for (int i=0; environ[i]; i++) {\n    if (strstr(environ[i],\"LD_PRELOAD=\")) {\n      printf(\"hacking out LD_PRELOAD from environ[%d]\\n\",i);\n      environ[i][0] = '\\0';\n    }\n  }\n  char*plop=getenv(\"LD_PRELOAD\");\n  if(plop) {\n    fprintf(stderr, \"Warning: cannot unset LD_PRELOAD\\n\");\n    fprintf(stderr, \"This is likely to cause problems later.\\n\");\n  }\n}\n\n/* set LD_PRELOAD so that future forked processes are analyzed\n *  you need to call unset_ld_preload before calling this function\n */\nvoid reset_ld_preload() {\n  if(strlen(ld_preload_value)>0) {\n    debug_printf(\"Setting back ld_preload to %s\\n\", ld_preload_value);\n    setenv(\"LD_PRELOAD\", ld_preload_value, 1);\n  }\n}\n\nstatic void __memory_init(void) __attribute__ ((constructor));\nstatic void __memory_init(void) {\n  PROTECT_FROM_RECURSION;\n\n  libmalloc = dlsym(RTLD_NEXT, \"malloc\");\n  libcalloc = dlsym(RTLD_NEXT, \"calloc\");\n  librealloc = dlsym(RTLD_NEXT, \"realloc\");\n  libfree = dlsym(RTLD_NEXT, \"free\");\n  libpthread_create = dlsym(RTLD_NEXT, \"pthread_create\");\n  libpthread_exit = dlsym(RTLD_NEXT, \"pthread_exit\");\n\n  read_settings();\n  print_settings();\n\n  if(settings.dump_unmatched) {\n    create_log_filename(\"unmatched_samples.log\", dump_unmatched_filename, STRING_LEN);\n    dump_unmatched_file = fopen(dump_unmatched_filename, \"w\");\n    if(!dump_unmatched_file) {\n      fprintf(stderr, \"Cannot create %s: %s\\n\", dump_unmatched_filename, strerror(errno));\n      abort();\n    }\n  }\n\n  ma_init();\n\n  ma_get_variables();\n\n  __memory_initialized = 1;\n  UNPROTECT_FROM_RECURSION;\n}\n\nvoid wait_for_other_threads() {\n  int i;\n  for(i=0; i<nb_threads; i++) {\n    /* the thread is still running */\n    if(thread_array[i].status == thread_status_created) {\n      /* ask the thread to stop */\n      int retval = pthread_cancel(thread_array[i].tid);\n      if(retval != 0) {\n\tfprintf(stderr, \"pthread_cancel failed (%s)\\n\", strerror(errno));\n\tabort();\n      }\n\n      /* wait until the thread stopped */\n\n      /* we could use pthread_join, but join may fail if the thread is not joinable (OpenMP\n       * thread for instance)\n       */\n      while(thread_array[i].status == thread_status_created) {\n\tsched_yield();\n      }\n\n    }\n  }\n}\n\nstatic void __memory_conclude(void) __attribute__ ((destructor));\nstatic void __memory_conclude(void) {\n\n  wait_for_other_threads();\n  __memory_initialized = 0;\n\n  printf(\"\\n\\n\");\n  printf(\"-----------------------------------\\n\");\n  printf(\"NumaMMA report:\\n\");\n  \n  ma_finalize();\n\n  if(settings.dump_unmatched) {\n    fclose(dump_unmatched_file);\n  }\n\n  printf(\"Output directory: %s\\n\", get_log_dir());\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-numamma-1.1.1-gozxe2icbhdr6xcoj4p5lgkcu7fnou6u/spack-src/src/mem_run.c": "/* -*- c-file-style: \"GNU\" -*- */\n#define _GNU_SOURCE\n\n/* intercept a set of memory/pthread related functions\n * and modify their behavior\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <inttypes.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <sys/time.h>\n#include <pthread.h>\n#include <errno.h>\n#include <numaif.h>\n#include <numa.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n\n#include \"numamma.h\"\n#include \"mem_intercept.h\"\n#include \"mem_tools.h\"\n\n#define INTERCEPT_MALLOC 1\n\n//#define CHECK_PLACEMENT 1\n\n\n// not used, but me need to define the symbol\nstruct numamma_settings settings;\n\n\nint _dump = 0;\nFILE* dump_file = NULL; // useless\nint _verbose = 0;\n__thread volatile int is_recurse_unsafe = 0;\n\n/* set to 1 if thread binding is activated */\nint bind_threads=0;\n\nenum mbind_policy{\n  POLICY_NONE,\n  POLICY_INTERLEAVED,\n  POLICY_BLOCK,\n  POLICY_CUSTOM,\n  POLICY_MAX\n};\nenum mbind_policy _mbind_policy;\n\n/* array describing the binding of each thread */\nint thread_bindings[MAX_THREADS];\n/* number of valid entries in the array */\nint nb_thread_max=0;\n\n\nint page_size=4096;\t\t/* todo: detect this using sysconf */\nint nb_nodes=-1;\n\n\nstruct mbind_directive {\n  char block_identifier[4096]; // name of the variable to move\n  size_t buffer_len;\n  size_t nb_blocks;\n  void* base_addr;\n  enum {type_global, type_malloc} buffer_type;\n  struct block_bind *blocks;\n  struct mbind_directive *next;\n};\nstruct mbind_directive *directives = NULL;;\n  \nstruct block_bind {\n  int start_page;\n  int end_page;\n  int numa_node;\n};\n\n/* set to 1 when all the hooks are set.\n * This is useful in order to avoid recursive calls\n */\nstatic int __memory_initialized = 0;\n\nvoid* (*libcalloc)(size_t nmemb, size_t size) = NULL;\nvoid* (*libmalloc)(size_t size) = NULL;\nvoid (*libfree)(void *ptr) = NULL;\nvoid* (*librealloc)(void *ptr, size_t size) = NULL;\nint  (*libpthread_create) (pthread_t * thread, const pthread_attr_t * attr,\n\t\t\t   void *(*start_routine) (void *), void *arg) = NULL;\nvoid (*libpthread_exit) (void *thread_return) = NULL;\n\nstatic void bind_buffer(void* buffer, size_t len, char* buffer_id);\nstatic void bind_malloced_buffer(void* buffer, size_t len, char* buffer_id);\n\n/* Custom malloc function. It is used when libmalloc=NULL (e.g. during startup)\n * This function is not thread-safe and is very likely to be bogus, so use with\n * caution\n */\nstatic void* hand_made_malloc(size_t size) {\n  /* allocate a 1MB buffer */\n#define POOL_SIZE (1024 * 1024 * 10)\n  static char mem[POOL_SIZE] = {'\\0'};\n\n  /* since this function is only used before we found libmalloc, there's no\n   * fancy memory management mechanism (block reuse, etc.)\n   */\n  static char* next_slot = &mem[0];\n  static int total_alloc = 0;\n\n  if (libmalloc)\n    /* let's use the real malloc */\n    return malloc(size);\n\n  debug_printf(\"%s(size=%lu)\\n\", __FUNCTION__, size);\n  struct mem_block_info *p_block = NULL;\n  INIT_MEM_INFO(p_block, next_slot, size, 1);\n  p_block->mem_type = MEM_TYPE_HAND_MADE_MALLOC;\n\n  /* if you want to make this function thread-safe, these instructions should be protected\n   * by a mutex:\n   */\n  p_block->mem_type = MEM_TYPE_HAND_MADE_MALLOC;\n  total_alloc += size;\n  next_slot = next_slot + p_block->total_size;\n  debug_printf(\"%s returns: --> %p (p_block=%p)\\n\", __FUNCTION__, p_block->u_ptr, p_block);\n  return p_block->u_ptr;\n}\n\nstatic int nb_malloc=0;\nstatic int nb_free=0;\nstatic int nb_realloc=0;\nstatic int nb_calloc=0;\n\n#if INTERCEPT_MALLOC\n\nvoid* malloc(size_t size) {\n  nb_malloc++;\n  static int total_alloced=0;\n  /* if memory_init hasn't been called yet, we need to get libc's malloc\n   * address\n   */\n  if (!libmalloc) {\n    if( !IS_RECURSE_SAFE) {\n      /* protection flag says that malloc is already trying to retrieve the\n       * address of malloc.\n       * If we call dlsym now, there will be an infinite recursion, so let's\n       * allocate memory 'by hand'\n       */\n      return hand_made_malloc(size);\n    }\n\n    /* set the protection flag and retrieve the address of malloc.\n     * If dlsym calls malloc, memory will be allocated 'by hand'\n     */\n    PROTECT_FROM_RECURSION;\n    {\n      libmalloc = dlsym(RTLD_NEXT, \"malloc\");\n      char* error;\n      if ((error = dlerror()) != NULL) {\n\tfputs(error, stderr);\n\texit(1);\n      }\n    }\n    /* it is now safe to call libmalloc */\n    UNPROTECT_FROM_RECURSION;\n  }\n\n  /* allocate a buffer */\n  debug_printf(\"%s(size=%lu) \\n\", __FUNCTION__, size);\n  void* pptr = libmalloc(size + HEADER_SIZE + TAIL_SIZE);\n  total_alloced+=size + HEADER_SIZE + TAIL_SIZE;\n\n  if(!pptr){\n    return NULL;\n  }\n  struct mem_block_info *p_block = NULL;\n  INIT_MEM_INFO(p_block, pptr, size, 1);\n\n  if(__memory_initialized && IS_RECURSE_SAFE) {\n    PROTECT_FROM_RECURSION;\n    p_block->mem_type = MEM_TYPE_MALLOC;\n    /* TODO: use the callsite to generate a buffer_id */\n    bind_malloced_buffer(p_block->u_ptr, size, NULL);\n    UNPROTECT_FROM_RECURSION;\n    //    return p_block->u_ptr;\n  } else {\n    /* we are already processing a malloc/free function, so don't try to record information,\n     * just call the function\n     */\n    p_block->mem_type = MEM_TYPE_INTERNAL_MALLOC;\n  }\n  debug_printf(\"%s returns: --> %p (p_block=%p)\\n\", __FUNCTION__, p_block->u_ptr, p_block);\n\n  return p_block->u_ptr;\n}\n\nvoid* realloc(void *ptr, size_t size) {\n  nb_realloc++;\n  /* if ptr is NULL, realloc behaves like malloc */\n  if (!ptr)\n    return malloc(size);\n\n  /* if size=0 and ptr isn't NULL, realloc behaves like free */\n  if (!size && ptr) {\n    free(ptr);\n    return NULL;\n  }\n\n  //  FUNCTION_ENTRY;\n  if (!librealloc) {\n    librealloc = dlsym(RTLD_NEXT, \"realloc\");\n    char* error;\n    if ((error = dlerror()) != NULL) {\n      fputs(error, stderr);\n      exit(1);\n    }\n  }\n\n  debug_printf(\"%s(ptr=%p, size=%lu)\\n\", __FUNCTION__, ptr, size);\n  if (!CANARY_OK(ptr)) {\n    /* we didn't malloc'ed this buffer */\n    fprintf(stderr,\"%s(%p). I can't find this pointer !\\n\", __FUNCTION__, ptr);\n    abort();\n    void* retval = librealloc(ptr, size);\n    debug_printf(\"%s returns --> %p\\n\", retval, __FUNCTION__);\n    return retval;\n  }\n\n  struct mem_block_info *p_block;\n  USER_PTR_TO_BLOCK_INFO(ptr, p_block);\n  size_t old_size = p_block->size;\n  size_t header_size = p_block->total_size - p_block->size;\n\n  if (p_block->mem_type != MEM_TYPE_MALLOC) {\n    fprintf(stderr, \"Warning: realloc a ptr that was allocated by hand_made_malloc\\n\");\n  }\n  void *old_addr= p_block->u_ptr;\n  void *pptr = librealloc(p_block->p_ptr, size + header_size);\n  INIT_MEM_INFO(p_block, pptr, size, 1);\n\n  if(__memory_initialized && IS_RECURSE_SAFE) {\n    PROTECT_FROM_RECURSION;\n    /* retrieve the malloc information from the pointer */\n    if (!pptr) {\n      /* realloc failed */\n      UNPROTECT_FROM_RECURSION;\n      debug_printf(\"%s returns --> %p\\n\", __FUNCTION__, NULL);\n      return NULL;\n    }\n\n    p_block->mem_type = MEM_TYPE_MALLOC;\n    UNPROTECT_FROM_RECURSION;\n  } else {\n    /* it is not safe to record information */\n    p_block->mem_type = MEM_TYPE_INTERNAL_MALLOC;\n  }\n\n  debug_printf(\"%s returns --> %p (p_block=%p)\\n\", __FUNCTION__, p_block->u_ptr, p_block);\n  return p_block->u_ptr;\n}\n\nvoid* calloc(size_t nmemb, size_t size) {\n  nb_calloc++;\n  if (!libcalloc) {\n    void* ret = hand_made_malloc(nmemb * size);\n    if (ret) {\n      memset(ret, 0, nmemb * size);\n    }\n    return ret;\n  }\n\n  debug_printf(\"calloc(nmemb=%zu, size=%zu)\\n\", nmemb, size);\n\n  /* compute the number of blocks for header */\n  int nb_memb_header = (HEADER_SIZE  + TAIL_SIZE)/ size;\n  if (size * nb_memb_header < HEADER_SIZE + TAIL_SIZE)\n    nb_memb_header++;\n\n    /* allocate buffer + header */\n  void* p_ptr = libcalloc(nmemb + nb_memb_header, size);\n\n  struct mem_block_info *p_block = NULL;\n  INIT_MEM_INFO(p_block, p_ptr, nmemb, size);\n\n\n  if(__memory_initialized && IS_RECURSE_SAFE) {\n    PROTECT_FROM_RECURSION;\n    p_block->mem_type = MEM_TYPE_MALLOC;\n    /* todo: call mbind ? */\n    bind_malloced_buffer(p_block->u_ptr, size*nmemb, NULL);\n    UNPROTECT_FROM_RECURSION;\n  } else {\n    p_block->mem_type = MEM_TYPE_INTERNAL_MALLOC;\n  }\n  debug_printf(\"%s returns --> %p (p_block=%p)\\n\", __FUNCTION__, p_block->u_ptr, p_block);\n  return p_block->u_ptr;\n}\n\nvoid free(void* ptr) {\n  nb_free++;\n  if (!libfree) {\n    libfree = dlsym(RTLD_NEXT, \"free\");\n    char* error;\n    if ((error = dlerror()) != NULL) {\n      fputs(error, stderr);\n      exit(1);\n    }\n  }\n  if (!ptr) {\n    libfree(ptr);\n    return;\n  }\n\n  debug_printf(\"%s(%p)\\n\", __FUNCTION__, ptr);\n  /* first, check wether we malloc'ed the buffer */\n  if (!CANARY_OK(ptr)) {\n    /* we didn't malloc this buffer */\n    fprintf(stderr, \"%s(%p). I don't know this malloc !\\n\", __FUNCTION__, ptr);\n    abort();\n    libfree(ptr);\n    return;\n  }\n\n  struct mem_block_info *p_block;\n  USER_PTR_TO_BLOCK_INFO(ptr, p_block);\n\n  void* start_ptr = p_block->p_ptr;\n  ERASE_CANARY(ptr);\n  //  memset(start_ptr, 0x00, p_block->total_size);\n  libfree(start_ptr);\n}\n#endif\t/* INTERCEPT_MALLOC */\n\n/* Internal structure used for transmitting the function and argument\n * during pthread_create.\n */\nstruct __pthread_create_info_t {\n  void *(*func)(void *);\n  void *arg;\n  int thread_rank;\n};\n\nenum thread_status_t {\n  thread_status_none,\n  thread_status_created,\n  thread_status_finalized\n};\n\nstruct thread_info {\n  pthread_t tid;\n  enum thread_status_t status;\n};\nstruct thread_info thread_array[MAX_THREADS];\nint nb_threads = 0;\n\nstatic int __get_thread_rank(pthread_t thread_id) {\n  int i;\n  for(i=0; i< nb_threads; i++) {\n    if(thread_array[i].tid == thread_id)\n      return i;\n  }\n  return -1;\n}\n\nstatic void __thread_cleanup_function(void* arg);\n/* Invoked by pthread_create on the new thread */\nstatic void *\n__pthread_new_thread(void *arg) {\n  PROTECT_FROM_RECURSION;\n  void* res = NULL;\n  struct __pthread_create_info_t *p_arg = (struct __pthread_create_info_t*) arg;\n  void *(*f)(void *) = p_arg->func;\n  void *__arg = p_arg->arg;\n  int thread_rank = p_arg->thread_rank;\n  free(p_arg);\n\n  UNPROTECT_FROM_RECURSION;\n  int oldtype;\n  pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldtype);\n\n  pthread_cleanup_push(__thread_cleanup_function,\n\t\t       &thread_array[thread_rank]);\n\n  FUNCTION_ENTRY;\n  if(_verbose) {\n    pid_t tid = syscall(__NR_gettid);\n    printf(\"I'm thread %d (tid=%d) bound on cpu %d\\n\", thread_rank, tid, thread_bindings[thread_rank]);\n  }\n\n  res = (*f)(__arg);\n\n  pthread_cleanup_pop(0);\n  if(_verbose)\n    fprintf(stderr, \"End of thread %lu\\n\", thread_array[thread_rank].tid);\n  __thread_cleanup_function(&thread_array[thread_rank]);\n  return res;\n}\n\n\nstatic void __thread_cleanup_function(void* arg) {\n  struct thread_info* me = arg;\n  PROTECT_FROM_RECURSION;\n  me->status = thread_status_finalized;\n  UNPROTECT_FROM_RECURSION;\n}\n\nint\npthread_create (pthread_t *__restrict thread,\n\t\tconst pthread_attr_t *__restrict attr,\n\t\tvoid *(*start_routine) (void *),\n\t\tvoid *__restrict arg) {\n  FUNCTION_ENTRY;\n  PROTECT_FROM_RECURSION;\n  int thread_rank = __sync_fetch_and_add( &nb_threads, 1 );\n  thread_array[thread_rank].status = thread_status_created;\n  struct __pthread_create_info_t * __args =\n    (struct __pthread_create_info_t*) malloc(sizeof(struct __pthread_create_info_t));\n  __args->func = start_routine;\n  __args->arg = arg;\n  __args->thread_rank= thread_rank;\n\n  if (!libpthread_create) {\n    libpthread_create = dlsym(RTLD_NEXT, \"pthread_create\");\n  }\n\n  pthread_attr_t local_attr;\n  if(attr) {\n    memcpy(&local_attr, attr, sizeof(local_attr));\n  } else {\n    pthread_attr_init(&local_attr);\n  }\n  if(bind_threads && thread_rank < nb_thread_max) {\n    if(thread_bindings[thread_rank] >= 0) {\n      cpu_set_t cpuset;\n      CPU_ZERO(&cpuset);\n      CPU_SET(thread_bindings[thread_rank], &cpuset);\n#if 0\n      if(_verbose)\n\tprintf(\"[Mem_run] Binding %d to %d\\n\", thread_rank, thread_bindings[thread_rank]);\n#endif\n      int ret = pthread_attr_setaffinity_np(&local_attr,\n\t\t\t\t\t    sizeof(cpuset),\n\t\t\t\t\t    &cpuset);\n      if(ret != 0){\n\tperror(\"pthread_attr_setaffinity_np failed\");\n\tabort();\n      }\n    }\n  }\n  UNPROTECT_FROM_RECURSION;\n\n  /* We do not call directly start_routine since we want to initialize stuff at the thread startup.\n   * Instead, let's invoke __pthread_new_thread that initialize the thread-specific things and call\n   * start_routine.\n   */\n  int retval = libpthread_create(&thread_array[thread_rank].tid, &local_attr,\n\t\t\t\t __pthread_new_thread, __args);\n  memcpy(thread, &thread_array[thread_rank].tid, sizeof(pthread_t));\n  return retval;\n}\n\nvoid pthread_exit(void *thread_return) {\n  FUNCTION_ENTRY;\n\n  libpthread_exit(thread_return);\n  __builtin_unreachable();\n}\n\n/* bind the current thread on a cpu */\nstatic void bind_current_thread(int cpu) {\n  cpu_set_t cpuset;\n  CPU_ZERO(&cpuset);\n  CPU_SET(cpu, &cpuset);\n\n  pthread_t current_thread = pthread_self();\n  pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset);\n}\n\nstatic void get_thread_binding() {\n  char* str=getenv(\"NUMAMMA_THREAD_BIND\");\n  if(str) {\n    printf(\"[Mem_run] Thread binding activated: %s\\n\", str);\n\n    if(getenv(\"GOMP_CPU_AFFINITY\")) {\n      fprintf(stderr, \"Error: NUMAMMA_THREAD_BIND conflicts with GOMP_CPU_AFFINITY\\n\");\n      fprintf(stderr, \"  Please unset GOMP_CPU_AFFINITY\\n\");\n      abort();\n    }\n\n    for(int i = 0; i<MAX_THREADS; i++) {\n      thread_bindings[i] = -1;\n    }\n    char bindings[10*MAX_THREADS];\n    strncpy(bindings, str, 10*MAX_THREADS);\n    char* token = strtok(bindings, \",\");\n    while(token) {\n      thread_bindings[nb_thread_max] = atoi(token);\n      nb_thread_max++;\n      token = strtok(NULL, \",\");\n    }\n\n    bind_threads=1;\n    if(_verbose) {\n      for(int i=0; i<nb_thread_max; i++) {\n\tprintf(\"[Mem_run] Thread %d is bound to %d\\n\", i, thread_bindings[i]);\n      }\n    }\n\n    int thread_rank = nb_threads++;\n    thread_array[thread_rank].status = thread_status_created;\n\n#if 0\n    if(_verbose)\n      printf(\"[Mem_run] Binding %d to %d\\n\", thread_rank, thread_bindings[thread_rank]);\n#endif\n    bind_current_thread(thread_bindings[thread_rank]);\n  } else {\n    printf(\"[Mem_run] No thread binding policy selected.\\n\");\n    printf(\"[Mem_run] \\tYou can use NUMAMMA_THREAD_BIND\\n\");\n  }\n}\n\nstatic void load_custom_block(FILE*f) {\n  char block_identifier[4096];\n  size_t buffer_len=-1;\n  size_t nb_blocks=0;\n\n  struct mbind_directive *dir=malloc(sizeof(struct mbind_directive));\n  \n  int nread=fscanf(f, \"%s\\t%zu\\t%d\", dir->block_identifier, &dir->buffer_len, &dir->nb_blocks);\n  assert(nread==3);\n  if(_verbose)\n    printf(\"New custom block(id=%s, len=%d, nblocks=%d)\\n\", dir->block_identifier, dir->buffer_len, dir->nb_blocks);\n\n  if(strcmp(dir->block_identifier, \"malloc\") == 0) {\n    dir->buffer_type=type_malloc;\n  } else {\n    dir->buffer_type=type_global;\n  }\n  dir->blocks = malloc(sizeof(struct block_bind)* dir->nb_blocks);\n  char* line_buffer=NULL;\n  size_t line_size;\n  int block_id=0;\n  dir->next = directives;\n  directives = dir;\n\n  while((nread=getline(&line_buffer, &line_size, f)) != -1) {\n    if(strncmp(line_buffer, \"end_block\", 9) == 0)  {     \n      dir->nb_blocks=block_id;\n      return;\n    }\n    struct block_bind*block = &dir->blocks[block_id];\n    int numa_node, start_page, end_page;\n    nread=sscanf(line_buffer, \"%d\\t%d\\t%d\", &block->numa_node, &block->start_page, &block->end_page);\n    if(nread == 3) {\n      if(block->numa_node > nb_nodes-1) {\n\tfprintf(stderr, \"Warning: trying to bind %s[page %d] on node %d, but there are only %d nodes on this machine\\n\",\n\t\tdir->block_identifier, block->start_page, block->numa_node, nb_nodes);\n      }\n      block_id++;\n      if(block_id > dir->nb_blocks)\n\tbreak;\n    }\n  }\n}\n\nstatic void load_custom_mbind(const char*fname) {\n  FILE*f = fopen(fname, \"r\");\n  if(!f) {\n    perror(\"Cannot open mbind file\");\n    exit(1);\n  }\n  char *line_buffer=NULL;\n  size_t line_size;\n  int nread=0;\n  while((nread=getline(&line_buffer, &line_size, f)) != -1) {\n    if(strncmp(line_buffer, \"begin_block\", 11) == 0) {\n      load_custom_block(f);\n    } else {\n      /* Something else */\n    }\n  }\n  \n  fclose(f);\n}\n\nstatic void read_options() {\n  char* verbose_str = getenv(\"NUMAMMA_VERBOSE\");\n  if(verbose_str) {\n    if(strcmp(verbose_str, \"0\")!=0) {\n      _verbose = 1;\n      printf(\"Verbose mode enabled\\n\");\n    }\n  }\n\n  char* mbind_policy_str = getenv(\"NUMAMMA_MBIND_POLICY\");\n  if(mbind_policy_str) {\n    if(strcmp(mbind_policy_str, \"interleaved\")==0) {\n      _mbind_policy= POLICY_INTERLEAVED;\n      printf(\"Memory binding (interleaved) enabled\\n\");\n    } else if(strcmp(mbind_policy_str, \"block\")==0) {\n      _mbind_policy= POLICY_BLOCK;\n      printf(\"Memory binding (block) enabled\\n\");\n    } else if(strcmp(mbind_policy_str, \"none\")==0) {\n      _mbind_policy= POLICY_NONE;\n      printf(\"Memory binding (none) enabled\\n\");\n    } else if(strcmp(mbind_policy_str, \"custom\")==0) {\n      _mbind_policy= POLICY_CUSTOM;\n      char* mbind_file=getenv(\"NUMAMMA_MBIND_FILE\");\n      if(!mbind_file) {\n\tfprintf(stderr, \"Please set the NUMAMMA_MBIND_FILE variable\\n\");\n\texit(1);\n      }\n      load_custom_mbind(mbind_file);\n      printf(\"Memory binding (custom) enabled\\n\");\n    } \n  } else {\n    printf(\"[Mem_run] No memory binding policy selected.\\n\");\n    printf(\"[Mem_run] \\tYou can use NUMAMMA_MBIND_POLICY=interleaved|block|custom\\n\");\n  }\n\n  get_thread_binding();\n}\n\nextern char**environ;\nchar ld_preload_value[4096];\n\n/* unset LD_PRELOAD\n * this makes sure that forked processes will not be analyzed\n */\nvoid unset_ld_preload() {\n  /* unset LD_PRELOAD */\n  char* ld_preload = getenv(\"LD_PRELOAD\");\n  if(!ld_preload) {\n    ld_preload_value[0]='\\0';\n    return;\n  }\n\n  /* save the value of ld_preload so that we can set it back later */\n  strncpy(ld_preload_value, ld_preload, 4096);\n  int ret = unsetenv(\"LD_PRELOAD\");\n  if(ret != 0 ){\n    fprintf(stderr, \"unsetenv failed ! %s\\n\", strerror(errno));\n    abort();\n  }\n\n  /* also change the environ variable since exec* function\n   * rely on it.\n   */\n  for (int i=0; environ[i]; i++) {\n    if (strstr(environ[i],\"LD_PRELOAD=\")) {\n      printf(\"hacking out LD_PRELOAD from environ[%d]\\n\",i);\n      environ[i][0] = '\\0';\n    }\n  }\n  char*plop=getenv(\"LD_PRELOAD\");\n  if(plop) {\n    fprintf(stderr, \"Warning: cannot unset LD_PRELOAD\\n\");\n    fprintf(stderr, \"This is likely to cause problems later.\\n\");\n  }\n}\n\n/* set LD_PRELOAD so that future forked processes are analyzed\n *  you need to call unset_ld_preload before calling this function\n */\nvoid reset_ld_preload() {\n  if(strlen(ld_preload_value)>0) {\n    debug_printf(\"Setting back ld_preload to %s\\n\", ld_preload_value);\n    setenv(\"LD_PRELOAD\", ld_preload_value, 1);\n  }\n}\n\nuintptr_t align_ptr(uintptr_t ptr, int align) {\n  uintptr_t mask = ~(uintptr_t)(align - 1);\n  uintptr_t res = ptr & mask;\n  return ptr & mask;\n}\n\nint get_numa_node(void* address) {\n  void * ptr_to_check = address;\n  /*here you should align ptr_to_check to page boundary */\n  int status=-1;\n  int ret_code;\n  ret_code = move_pages(0 /*self memory */, 1, &ptr_to_check,\n\t\t\tNULL, &status, 0);\n  if(ret_code != 0) {\n    perror(\"move_pages failed\");\n    abort();\n  }\n  if(status < 0){\n    printf(\"move_pages failed: %s\\n\", strerror(-status));\n  }\n  return status;\n}\n\nstatic void bind_buffer_blocks(void*buffer, size_t len,\n\t\t\t       int n_blocks, struct block_bind* blocks) {\n  if(n_blocks*page_size > len+page_size) {\n    /* too many blocks ! */\n    abort();\n  }\n\n  uintptr_t base_addr=align_ptr((uintptr_t)buffer, page_size);\n\n  if(_verbose)\n    printf(\"[Mem_run] Binding %d blocks. starting at %p\\n\", n_blocks, base_addr);\n\n\n  for(int i=0; i<n_blocks; i++) {\n    uintptr_t start_addr=base_addr + ((uintptr_t)blocks[i].start_page*page_size);\n    start_addr+=page_size;\n    size_t block_len=((blocks[i].end_page+1 - blocks[i].start_page))*page_size;\n    const uint64_t nodeMask = 1UL << blocks[i].numa_node;\n\n    if(blocks[i].numa_node>nb_nodes) {\n      fprintf(stderr, \"Bad binding: binding on node %d requested, but only %d nodes are available\\n\", blocks[i].numa_node, nb_nodes);\n      abort();\n    }\n    if(_verbose)\n      printf(\"\\t[Mem_run] Binding pages %d-%d to node %d\\n\", blocks[i].start_page, blocks[i].end_page, blocks[i].numa_node);\n\n    if(start_addr+block_len > (uintptr_t)buffer+len) {\n      /* make sure there's no overflow */\n      block_len=(uintptr_t)buffer+len-start_addr;\n    }\n\n    int ret = mbind((void*)start_addr, block_len, MPOL_BIND, &nodeMask, sizeof(nodeMask)*8, MPOL_MF_MOVE | MPOL_MF_STRICT);\n    if(ret < 0) {\n      perror(\"mbind failed\");\n      abort();\n    }\n    \n#if CHECK_PLACEMENT\n    int effective_node=get_numa_node((void*)start_addr);\n    if(effective_node != blocks[i].numa_node ){\n      printf(\"Warning: when binding %p to node %d: page is actually on node %d\\n\",\n\t     start_addr, blocks[i].numa_node, effective_node);\n    } else {\n      printf(\"When binding %p to node %d: page is indeed on node %d\\n\",\n\t     start_addr, blocks[i].numa_node, effective_node);\n    }\n#endif\n  }\n}\n\nstatic void bind_block(void*buffer, size_t len) {\n  if(_mbind_policy != POLICY_BLOCK)\n    return;\n  int nb_pages=((len/page_size));\n  int nb_pages_per_node=1;\n  if(nb_pages > nb_nodes) {\n    nb_pages_per_node=nb_pages/nb_nodes;\n  }\n\n  int nb_blocks=0;\n  struct block_bind blocks[nb_nodes];\n  for(int i=0; i<nb_nodes; i++){\n    blocks[i].start_page = i * nb_pages_per_node;\n    blocks[i].end_page   = (i+1) * nb_pages_per_node;\n    blocks[i].numa_node = i;\n    nb_blocks++;\n    if(blocks[i].end_page > nb_pages) {\n      /* the last node gets all the remaining blocks */\n      blocks[i].end_page = nb_pages;\n      break;\n    }\n  }\n\n  bind_buffer_blocks(buffer, len, nb_blocks, blocks);\n}\n\nstatic void bind_interleaved(void* buffer, size_t len) {\n  if(_mbind_policy != POLICY_INTERLEAVED)\n    return;\n  int nblocks=(len/page_size)+1;\n  struct block_bind blocks[nblocks];\n  for(int i=0; i<nblocks; i++){\n    blocks[i].start_page=i;\n    blocks[i].end_page=i+1;\n    blocks[i].numa_node = i%nb_nodes;\n  }\n  bind_buffer_blocks(buffer, len, nblocks, blocks);\n}\n\nstatic void check_buffer_placement(struct mbind_directive *dir) {\n  assert(dir->base_addr);\n  uintptr_t base_addr=align_ptr((uintptr_t)dir->base_addr, page_size);\n\n  for(int i=0; i<dir->nb_blocks; i++) {\n    uintptr_t start_addr=base_addr + dir->blocks[i].start_page*page_size;\n    start_addr+=page_size;\n    size_t block_len=((dir->blocks[i].end_page - dir->blocks[i].start_page))*page_size;\n    const uint64_t nodeMask = 1UL << dir->blocks[i].numa_node;\n\n    if(start_addr+block_len > (uintptr_t)dir->base_addr+dir->buffer_len) {\n      /* make sure there's no overflow */\n      block_len=(uintptr_t)dir->base_addr+dir->buffer_len-start_addr;\n    }\n\n#if CHECK_PLACEMENT\n    int effective_node=get_numa_node((void*)start_addr);\n    if(effective_node != dir->blocks[i].numa_node ){\n      printf(\"Warning: %p/%d should be on node %d: page is actually on node %d\\n\",\n\t     start_addr, dir->blocks[i].start_page, dir->blocks[i].numa_node, effective_node);\n    }\n#endif\n  }\n}\n\nstatic void check_placement() {\n  struct mbind_directive *dir = directives;\n  while(dir) {\n    if( dir->base_addr)\n      check_buffer_placement(dir);\n    dir = dir->next;\n  }\n}\n\nstatic void bind_custom(void* buffer, size_t len, char* buffer_id) {\n  if(_mbind_policy != POLICY_CUSTOM || buffer_id == NULL)\n    return;\n\n  printf(\"Trying to bind %s\\n\", buffer_id);\n  /* search for buffer_id in the list of mbind directives */\n  struct mbind_directive *dir = directives;\n  while(dir) {\n    if(strcmp(dir->block_identifier, buffer_id)==0) {\n\n      if(dir->buffer_len != len) {\n\tfprintf(stderr, \"Warning: I found variable %s, but its length (%zu) is different from the specified length (%zu)\\n\",\n\t\tbuffer_id, len, dir->buffer_len);\n      } else {\n\tprintf(\"Binding %s\\n\", buffer_id);\n\tdir->base_addr = buffer;\n\tbind_buffer_blocks(buffer, len, dir->nb_blocks, dir->blocks);\n      }\n      return;\n    }\n    dir = dir->next;\n  }\n  printf(\"\\t%s not found\\n\", buffer_id);\n}\n\nstatic void bind_malloced_buffer(void* buffer, size_t len, char* buffer_id) {\n  struct mbind_directive* dir = directives;\n  while(dir) {\n    /* search for the directive corresponding to this malloc */\n\n    /* todo:\n     * - take the buffer_id into account\n     * - don't apply a directive several times\n     */\n    if(dir->buffer_type == type_malloc &&\n       dir->buffer_len == len) {\n\n      dir->base_addr = buffer;\n      if(_verbose) {\n\tprintf(\"Binding malloced buffer(len=%d)\\n\", len);\n      }\n      bind_buffer_blocks(buffer, len, dir->nb_blocks, dir->blocks);\n      return;\n    }\n\n    dir = dir->next;\n  }\n}\n\nstatic void bind_buffer(void* buffer, size_t len, char* buffer_id) {\n\n  if(len > page_size) {\n    switch(_mbind_policy) {\n    case POLICY_INTERLEAVED:\n      bind_interleaved(buffer, len);\n      break;\n    case POLICY_BLOCK:\n      bind_block(buffer, len);\n      break;\n    case POLICY_CUSTOM:\n      bind_custom(buffer, len, buffer_id);\n      break;\n      /* else: nothing to do */\n    }\n  }\n}\n\nchar null_str[]=\"\";\n\n/* get the list of global/static variables with their address and size, and bind them\n * according to _mbind_policy\n */\nvoid bind_global_variables() {\n  if(_mbind_policy == POLICY_NONE) {\n    /* nothing to do */\n    return;\n  }\n\n  /* TODO: this function, share a lot of code with the ma_get_global_variables defined\n   * in mem_analyzer.c\n   * Maybe we should merge them ?\n   */\n\n  /* make sure forked processes (eg nm, readlink, etc.) won't be analyzed */\n  unset_ld_preload();\n\n  debug_printf(\"Looking for global variables\\n\");\n  /* get the filename of the program being run */\n  char readlink_cmd[1024];\n  sprintf(readlink_cmd, \"readlink /proc/%d/exe\", getpid());\n  FILE* f = popen(readlink_cmd, \"r\");\n  char program_file[4096];\n  fgets(program_file, 4096, f);\n  strtok(program_file, \"\\n\"); // remove trailing newline\n  fclose(f);\n\n  debug_printf(\"  The program file is %s\\n\", program_file);\n  /* get the address at which the program is mapped in memory */\n  char cmd[4069];\n  char line[4096];\n  void *base_addr = NULL;\n  void *end_addr = NULL;\n\n  sprintf(cmd, \"file \\\"%s\\\" |grep \\\"shared object\\\" > plop\", program_file);\n  int ret = system(cmd);\n  if(WIFEXITED(ret)) {\n    /* find address range of the heap */\n    int exit_status= WEXITSTATUS(ret);\n    if(exit_status == EXIT_SUCCESS) {\n      /* process is compiled with -fPIE, thus, the addresses in the ELF are to be relocated */\n      //      sprintf(cmd, \"cat /proc/%d/maps |grep \\\"%s\\\" | grep  \\\" rw-p \\\"\", getpid(), program_file);\n      sprintf(cmd, \"cat /proc/%d/maps |grep \\\"[heap]\\\"\", getpid());\n      f = popen(cmd, \"r\");\n      fgets(line, 4096, f);\n      fclose(f);\n      sscanf(line, \"%p-%p\", &base_addr, &end_addr);\n      debug_printf(\"  This program was compiled with -fPIE. It is mapped at address %p\\n\", base_addr);\n    } else {\n      /* process is not compiled with -fPIE, thus, the addresses in the ELF are the addresses in the binary */\n      base_addr= NULL;\n      end_addr= NULL;\n      debug_printf(\"  This program was not compiled with -fPIE. It is mapped at address %p\\n\", base_addr);\n    }\n  }\n\n  /* get the list of global variables in the current binary */\n  char nm_cmd[1024];\n  sprintf(nm_cmd, \"nm -fs --defined-only -l -S %s\", program_file);\n  //sprintf(nm_cmd, \"nm --defined-only -l -S %s\", program_file);\n  f = popen(nm_cmd, \"r\");\n\n  while(!feof(f)) {\n    if( ! fgets(line, 4096, f) ) {\n      goto out;\n    }\n\n    char *addr = null_str;\n    char *size_str = null_str;\n    char *section = null_str;\n    char *symbol = null_str;\n    char *file = null_str;\n    char *type = null_str;\n\n    int nb_found;\n    /* line is in the form:\nsymbol_name |addr| section | type |symbol_size| [line]    |section    [file:line]\n    */\n    const char* delim=\"| \\t\\n\";\n\n    symbol = strtok(line, delim);\n    if(!symbol|| strcmp(symbol, \"_end\")==0) {\n      /* nothing to read */\n      continue;\n    }\n    \n    addr = strtok(NULL, delim);\n    if(!addr) {\n      /* nothing to read */\n      continue;\n    }\n\n    section = strtok(NULL, delim);\n    if(!section) {\n      /* nothing to read */\n      continue;\n    }\n    type = strtok(NULL, delim);\n    if(!type) {\n      /* nothing to read */\n      continue;\n    }\n\n    size_str = strtok(NULL, \" \\t\\n\");\n    if(!size_str) {\n      /* nothing to read */\n      continue;\n    }\n\n    if(!symbol) {\n      /* only 3 fields (addr section symbol) */\n      nb_found = 3;\n      symbol = section;\n      section = size_str;\n      size_str = null_str;\n      /* this is not enough (we need the size), skip this one */\n      continue;\n    } else {\n      nb_found = 4;\n      /*  fields */\n      file = strtok(NULL, \" \\t\\n\");\n      if(!file) {\n\tfile = null_str;\n      } else {\n\tnb_found = 5;\n      }\n    }\n\n    if(section[0]== 'b' || section[0]=='B' || /* BSS (uninitialized global vars) section */\n       section[0]== 'd' || section[0]=='D' || /* initialized data section */\n       section[0]== 'g' || section[0]=='G') { /* initialized data section for small objects */\n\n      if(strcmp(type, \"TLS\") == 0) {\n\tcontinue;\n      }\n      size_t size;\n      sscanf(size_str, \"%lx\", &size);\n      if(size) {\n\n\t\n#if 0\n\tstruct memory_info * mem_info = NULL;\n#ifdef USE_HASHTABLE\n\tmem_info = mem_allocator_alloc(mem_info_allocator);\n#else\n\tstruct memory_info_list * p_node = mem_allocator_alloc(mem_info_allocator);\n\tmem_info = &p_node->mem_info;\n#endif\n\n\tmem_info->alloc_date = 0;\n\tmem_info->free_date = 0;\n\tmem_info->initial_buffer_size = size;\n\tmem_info->buffer_size = mem_info->initial_buffer_size;\n#endif\n\t\n\t/* addr is the offset within the binary. The actual address of the variable is located at\n\t *  addr+base_addr\n\t */\n\tsize_t offset;\n\tsscanf(addr, \"%lx\", &offset);\n\tvoid* buffer_addr = offset + (uint8_t*)base_addr;\n\tsize_t buffer_size = size;\n\tchar caller[1024];\n\tsnprintf(caller, 1024, \"%s in %s\", symbol, file);\n\n\tdebug_printf(\"Found a global variable: %s (defined at %s). base addr=%p, size=%zu\\n\",\n\t\t     symbol, file, buffer_addr, buffer_size);\n\tbind_buffer(buffer_addr, buffer_size, symbol);\n      }\n    }\n  }\n out:\n  /* Restore LD_PRELOAD.\n   * This is usefull when the program is run with gdb. gdb creates a process than runs bash -e prog arg1\n   * Thus, the ld_preload affects bash. bash then calls execvp to execute the program.\n   * If we unset ld_preload, the ld_preload will only affect bash (and not the program\u00e0\n   * Hence, we need to restore ld_preload here.\n   */\n  reset_ld_preload();\n}\n\nstatic void __memory_init(void) __attribute__ ((constructor));\nstatic void __memory_init(void) {\n  PROTECT_FROM_RECURSION;\n  /* TODO: there's a race condition here: if I remove the printf, then mem_run\n   * fails while loading the custom mbind policy file. This should be investigated !\n   */\n  printf(\"[Mem_run] initializing stuff\\n\");\n#if INTERCEPT_MALLOC\n  printf(\"[Mem_run] malloc interception is enabled\\n\");\n#else\n    printf(\"[Mem_run] malloc interception is disabled\\n\");\n#endif\n  libmalloc = dlsym(RTLD_NEXT, \"malloc\");\n  libcalloc = dlsym(RTLD_NEXT, \"calloc\");\n  librealloc = dlsym(RTLD_NEXT, \"realloc\");\n  libfree = dlsym(RTLD_NEXT, \"free\");\n  libpthread_create = dlsym(RTLD_NEXT, \"pthread_create\");\n  libpthread_exit = dlsym(RTLD_NEXT, \"pthread_exit\");\n\n  nb_nodes = numa_num_configured_nodes();\n  read_options();\n\n  bind_global_variables();\n\n  __memory_initialized = 1;\n  printf(\"[Mem_run] initialization done\\n\");\n  UNPROTECT_FROM_RECURSION;\n}\n\nstatic void __memory_conclude(void) __attribute__ ((destructor));\nstatic void __memory_conclude(void) {\n  check_placement();\n  __memory_initialized = 0;\n  printf(\"Nb malloc: %d\\n\", nb_malloc);\n  printf(\"Nb realloc: %d\\n\", nb_realloc);\n  printf(\"Nb calloc: %d\\n\", nb_calloc);\n  printf(\"Nb free: %d\\n\", nb_free);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-numamma-1.1.1-gozxe2icbhdr6xcoj4p5lgkcu7fnou6u/spack-src/doc/screenshots/numamma-npb-ft-interactive-timeline.png",
        "/tmp/vanessa/spack-stage/spack-stage-numamma-1.1.1-gozxe2icbhdr6xcoj4p5lgkcu7fnou6u/spack-src/doc/screenshots/numamma-npb-lu-pages-threads-time-big.png",
        "/tmp/vanessa/spack-stage/spack-stage-numamma-1.1.1-gozxe2icbhdr6xcoj4p5lgkcu7fnou6u/spack-src/doc/screenshots/numamma-npb-lu-pages-threads-time.png",
        "/tmp/vanessa/spack-stage/spack-stage-numamma-1.1.1-gozxe2icbhdr6xcoj4p5lgkcu7fnou6u/spack-src/doc/screenshots/numamma-npb-cg-pages-threads.png",
        "/tmp/vanessa/spack-stage/spack-stage-numamma-1.1.1-gozxe2icbhdr6xcoj4p5lgkcu7fnou6u/spack-src/doc/screenshots/numamma-npb-cg-pages-threads-time-big.png",
        "/tmp/vanessa/spack-stage/spack-stage-numamma-1.1.1-gozxe2icbhdr6xcoj4p5lgkcu7fnou6u/spack-src/doc/screenshots/numamma-npb-cg-pages-threads-time.png",
        "/tmp/vanessa/spack-stage/spack-stage-numamma-1.1.1-gozxe2icbhdr6xcoj4p5lgkcu7fnou6u/spack-src/doc/screenshots/numamma-npb-cg-pages-threads-big.png"
    ],
    "total_files": 49
}