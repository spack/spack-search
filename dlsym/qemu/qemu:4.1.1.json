{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/dtc/tests/asm_tree_dump.c": "/*\n * libfdt - Flat Device Tree manipulation\n *\tTests if an asm tree built into a shared object matches a given dtb\n * Copyright (C) 2008 David Gibson, IBM Corporation.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\n#include <dlfcn.h>\n\n#include <libfdt.h>\n\n#include \"tests.h\"\n#include \"testdata.h\"\n\nint main(int argc, char *argv[])\n{\n\tvoid *sohandle;\n\tvoid *fdt;\n\tint err;\n\n\ttest_init(argc, argv);\n\tif (argc != 3)\n\t\tCONFIG(\"Usage: %s <so file> <dtb file>\", argv[0]);\n\n\tsohandle = dlopen(argv[1], RTLD_NOW);\n\tif (!sohandle)\n\t\tFAIL(\"Couldn't dlopen() %s\", argv[1]);\n\n\tfdt = dlsym(sohandle, \"dt_blob_start\");\n\tif (!fdt)\n\t\tFAIL(\"Couldn't locate \\\"dt_blob_start\\\" symbol in %s\",\n\t\t     argv[1]);\n\n\terr = fdt_check_header(fdt);\n\tif (err != 0)\n\t\tFAIL(\"%s contains invalid tree: %s\", argv[1],\n\t\t     fdt_strerror(err));\n\n\tsave_blob(argv[2], fdt);\n\n\tPASS();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/dtc/tests/value-labels.c": "/*\n * libfdt - Flat Device Tree manipulation\n *\tTest labels within values\n * Copyright (C) 2008 David Gibson, IBM Corporation.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\n#include <dlfcn.h>\n\n#include <libfdt.h>\n\n#include \"tests.h\"\n#include \"testdata.h\"\n\nstruct val_label {\n\tconst char *labelname;\n\tint propoff;\n};\n\nstatic struct val_label labels1[] = {\n\t{ \"start1\", 0 },\n\t{ \"mid1\", 2 },\n\t{ \"end1\", -1 },\n};\n\nstatic struct val_label labels2[] = {\n\t{ \"start2\", 0 },\n\t{ \"innerstart2\", 0 },\n\t{ \"innermid2\", 4 },\n\t{ \"innerend2\", -1 },\n\t{ \"end2\", -1 },\n};\n\nstatic struct val_label labels3[] = {\n\t{ \"start3\", 0 },\n\t{ \"innerstart3\", 0 },\n\t{ \"innermid3\", 1 },\n\t{ \"innerend3\", -1 },\n\t{ \"end3\", -1 },\n};\n\nstatic void check_prop_labels(void *sohandle, void *fdt, const char *name,\n\t\t\t      const struct val_label* labels, int n)\n{\n\tconst struct fdt_property *prop;\n\tconst char *p;\n\tint len;\n\tint i;\n\n\tprop = fdt_get_property(fdt, 0, name, &len);\n\tif (!prop)\n\t\tFAIL(\"Couldn't locate property \\\"%s\\\"\", name);\n\n\tp = dlsym(sohandle, name);\n\tif (!p)\n\t\tFAIL(\"Couldn't locate label symbol \\\"%s\\\"\", name);\n\n\tif (p != (const char *)prop)\n\t\tFAIL(\"Label \\\"%s\\\" does not point to correct property\", name);\n\n\tfor (i = 0; i < n; i++) {\n\t\tint off = labels[i].propoff;\n\n\t\tif (off == -1)\n\t\t\toff = len;\n\n\t\tp = dlsym(sohandle, labels[i].labelname);\n\t\tif (!p)\n\t\t\tFAIL(\"Couldn't locate label symbol \\\"%s\\\"\", name);\n\n\t\tif ((p - prop->data) != off)\n\t\t\tFAIL(\"Label \\\"%s\\\" points to offset %ld instead of %d\"\n\t\t\t     \"in property \\\"%s\\\"\", labels[i].labelname,\n\t\t\t     (long)(p - prop->data), off, name);\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tvoid *sohandle;\n\tvoid *fdt;\n\tint err;\n\n\ttest_init(argc, argv);\n\tif (argc != 2)\n\t\tCONFIG(\"Usage: %s <so file>\", argv[0]);\n\n\tsohandle = dlopen(argv[1], RTLD_NOW);\n\tif (!sohandle)\n\t\tFAIL(\"Couldn't dlopen() %s\", argv[1]);\n\n\tfdt = dlsym(sohandle, \"dt_blob_start\");\n\tif (!fdt)\n\t\tFAIL(\"Couldn't locate \\\"dt_blob_start\\\" symbol in %s\",\n\t\t     argv[1]);\n\n\terr = fdt_check_header(fdt);\n\tif (err != 0)\n\t\tFAIL(\"%s contains invalid tree: %s\", argv[1],\n\t\t     fdt_strerror(err));\n\n\n\tcheck_prop_labels(sohandle, fdt, \"prop1\", labels1, ARRAY_SIZE(labels1));\n\tcheck_prop_labels(sohandle, fdt, \"prop2\", labels2, ARRAY_SIZE(labels2));\n\tcheck_prop_labels(sohandle, fdt, \"prop3\", labels3, ARRAY_SIZE(labels3));\n\n\tPASS();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/EmulatorPkg/Unix/Host/Host.c": "/*++ @file\n\nCopyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>\nPortions copyright (c) 2008 - 2011, Apple Inc. All rights reserved.<BR>\nSPDX-License-Identifier: BSD-2-Clause-Patent\n\n**/\n\n#include \"Host.h\"\n\n#ifdef __APPLE__\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n\n\n//\n// Globals\n//\n\nEMU_THUNK_PPI mSecEmuThunkPpi = {\n  GasketSecUnixPeiAutoScan,\n  GasketSecUnixFdAddress,\n  GasketSecEmuThunkAddress\n};\n\nchar *gGdbWorkingFileName = NULL;\nunsigned int mScriptSymbolChangesCount = 0;\n\n\n//\n// Default information about where the FD is located.\n//  This array gets filled in with information from EFI_FIRMWARE_VOLUMES\n//  EFI_FIRMWARE_VOLUMES is a host environment variable set by system.cmd.\n//  The number of array elements is allocated base on parsing\n//  EFI_FIRMWARE_VOLUMES and the memory is never freed.\n//\nUINTN       gFdInfoCount = 0;\nEMU_FD_INFO *gFdInfo;\n\n//\n// Array that supports seperate memory rantes.\n//  The memory ranges are set in system.cmd via the EFI_MEMORY_SIZE variable.\n//  The number of array elements is allocated base on parsing\n//  EFI_MEMORY_SIZE and the memory is never freed.\n//\nUINTN              gSystemMemoryCount = 0;\nEMU_SYSTEM_MEMORY  *gSystemMemory;\n\n\n\nUINTN                        mImageContextModHandleArraySize = 0;\nIMAGE_CONTEXT_TO_MOD_HANDLE  *mImageContextModHandleArray = NULL;\n\nEFI_PEI_PPI_DESCRIPTOR  *gPpiList;\n\n\nint gInXcode = 0;\n\n\n/*++\n  Breakpoint target for Xcode project. Set in the Xcode XML\n\n  Xcode breakpoint will 'source Host.gdb'\n  gGdbWorkingFileName is set to Host.gdb\n\n**/\nVOID\nSecGdbConfigBreak (\n  VOID\n  )\n{\n}\n\n\n\n/*++\n\nRoutine Description:\n  Main entry point to SEC for Unix. This is a unix program\n\nArguments:\n  Argc - Number of command line arguments\n  Argv - Array of command line argument strings\n  Envp - Array of environment variable strings\n\nReturns:\n  0 - Normal exit\n  1 - Abnormal exit\n\n**/\nint\nmain (\n  IN  int   Argc,\n  IN  char  **Argv,\n  IN  char  **Envp\n  )\n{\n  EFI_STATUS            Status;\n  EFI_PHYSICAL_ADDRESS  InitialStackMemory;\n  UINT64                InitialStackMemorySize;\n  UINTN                 Index;\n  UINTN                 Index1;\n  UINTN                 Index2;\n  UINTN                 PeiIndex;\n  CHAR8                 *FileName;\n  BOOLEAN               Done;\n  EFI_PEI_FILE_HANDLE   FileHandle;\n  VOID                  *SecFile;\n  CHAR16                *MemorySizeStr;\n  CHAR16                *FirmwareVolumesStr;\n  UINTN                 *StackPointer;\n  FILE                  *GdbTempFile;\n\n  //\n  // Xcode does not support sourcing gdb scripts directly, so the Xcode XML\n  // has a break point script to source the GdbRun.sh script.\n  //\n  SecGdbConfigBreak ();\n\n  //\n  // If dlopen doesn't work, then we build a gdb script to allow the\n  // symbols to be loaded.\n  //\n  Index = strlen (*Argv);\n  gGdbWorkingFileName = AllocatePool (Index + strlen(\".gdb\") + 1);\n  strcpy (gGdbWorkingFileName, *Argv);\n  strcat (gGdbWorkingFileName, \".gdb\");\n\n  //\n  // Empty out the gdb symbols script file.\n  //\n  GdbTempFile = fopen (gGdbWorkingFileName, \"w\");\n  if (GdbTempFile != NULL) {\n    fclose (GdbTempFile);\n  }\n\n  printf (\"\\nEDK II UNIX Host Emulation Environment from http://www.tianocore.org/edk2/\\n\");\n\n  setbuf (stdout, 0);\n  setbuf (stderr, 0);\n\n  MemorySizeStr      = (CHAR16 *) PcdGetPtr (PcdEmuMemorySize);\n  FirmwareVolumesStr = (CHAR16 *) PcdGetPtr (PcdEmuFirmwareVolume);\n\n  //\n  // PPIs pased into PEI_CORE\n  //\n  AddThunkPpi (EFI_PEI_PPI_DESCRIPTOR_PPI, &gEmuThunkPpiGuid, &mSecEmuThunkPpi);\n\n  SecInitThunkProtocol ();\n\n  //\n  // Emulator Bus Driver Thunks\n  //\n  AddThunkProtocol (&gX11ThunkIo, (CHAR16 *)PcdGetPtr (PcdEmuGop), TRUE);\n  AddThunkProtocol (&gPosixFileSystemThunkIo, (CHAR16 *)PcdGetPtr (PcdEmuFileSystem), TRUE);\n  AddThunkProtocol (&gBlockIoThunkIo, (CHAR16 *)PcdGetPtr (PcdEmuVirtualDisk), TRUE);\n  AddThunkProtocol (&gSnpThunkIo, (CHAR16 *)PcdGetPtr (PcdEmuNetworkInterface), TRUE);\n\n  //\n  // Emulator other Thunks\n  //\n  AddThunkProtocol (&gPthreadThunkIo, (CHAR16 *)PcdGetPtr (PcdEmuApCount), FALSE);\n\n  // EmuSecLibConstructor ();\n\n  gPpiList = GetThunkPpiList ();\n\n  //\n  // Allocate space for gSystemMemory Array\n  //\n  gSystemMemoryCount  = CountSeparatorsInString (MemorySizeStr, '!') + 1;\n  gSystemMemory       = AllocateZeroPool (gSystemMemoryCount * sizeof (EMU_SYSTEM_MEMORY));\n  if (gSystemMemory == NULL) {\n    printf (\"ERROR : Can not allocate memory for system.  Exiting.\\n\");\n    exit (1);\n  }\n  //\n  // Allocate space for gSystemMemory Array\n  //\n  gFdInfoCount  = CountSeparatorsInString (FirmwareVolumesStr, '!') + 1;\n  gFdInfo       = AllocateZeroPool (gFdInfoCount * sizeof (EMU_FD_INFO));\n  if (gFdInfo == NULL) {\n    printf (\"ERROR : Can not allocate memory for fd info.  Exiting.\\n\");\n    exit (1);\n  }\n\n  printf (\"  BootMode 0x%02x\\n\", (unsigned int)PcdGet32 (PcdEmuBootMode));\n\n  //\n  // Open up a 128K file to emulate temp memory for SEC.\n  //  on a real platform this would be SRAM, or using the cache as RAM.\n  //  Set InitialStackMemory to zero so UnixOpenFile will allocate a new mapping\n  //\n  InitialStackMemorySize  = STACK_SIZE;\n  InitialStackMemory = (UINTN)MapMemory (\n                                0, (UINT32) InitialStackMemorySize,\n                                PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE\n                                );\n  if (InitialStackMemory == 0) {\n    printf (\"ERROR : Can not open SecStack Exiting\\n\");\n    exit (1);\n  }\n\n  printf (\"  OS Emulator passing in %u KB of temp RAM at 0x%08lx to SEC\\n\",\n    (unsigned int)(InitialStackMemorySize / 1024),\n    (unsigned long)InitialStackMemory\n    );\n\n  for (StackPointer = (UINTN*) (UINTN) InitialStackMemory;\n     StackPointer < (UINTN*)(UINTN)((UINTN) InitialStackMemory + (UINT64) InitialStackMemorySize);\n     StackPointer ++) {\n    *StackPointer = 0x5AA55AA5;\n  }\n\n  //\n  // Open All the firmware volumes and remember the info in the gFdInfo global\n  //\n  FileName = (CHAR8 *) AllocatePool (StrLen (FirmwareVolumesStr) + 1);\n  if (FileName == NULL) {\n    printf (\"ERROR : Can not allocate memory for firmware volume string\\n\");\n    exit (1);\n  }\n\n  Index2 = 0;\n  for (Done = FALSE, Index = 0, PeiIndex = 0, SecFile = NULL;\n       FirmwareVolumesStr[Index2] != 0;\n       Index++) {\n    for (Index1 = 0; (FirmwareVolumesStr[Index2] != '!') && (FirmwareVolumesStr[Index2] != 0); Index2++) {\n      FileName[Index1++] = FirmwareVolumesStr[Index2];\n    }\n    if (FirmwareVolumesStr[Index2] == '!') {\n      Index2++;\n    }\n    FileName[Index1]  = '\\0';\n\n    if (Index == 0) {\n      // Map FV Recovery Read Only and other areas Read/Write\n      Status = MapFd0 (\n                FileName,\n                &gFdInfo[0].Address,\n                &gFdInfo[0].Size\n                );\n    } else {\n      //\n      // Open the FD and remember where it got mapped into our processes address space\n      // Maps Read Only\n      //\n      Status = MapFile (\n                FileName,\n                &gFdInfo[Index].Address,\n                &gFdInfo[Index].Size\n                );\n    }\n    if (EFI_ERROR (Status)) {\n      printf (\"ERROR : Can not open Firmware Device File %s (%x).  Exiting.\\n\", FileName, (unsigned int)Status);\n      exit (1);\n    }\n\n    printf (\"  FD loaded from %s at 0x%08lx\",FileName, (unsigned long)gFdInfo[Index].Address);\n\n    if (SecFile == NULL) {\n      //\n      // Assume the beginning of the FD is an FV and look for the SEC Core.\n      // Load the first one we find.\n      //\n      FileHandle = NULL;\n      Status = PeiServicesFfsFindNextFile (\n                  EFI_FV_FILETYPE_SECURITY_CORE,\n                  (EFI_PEI_FV_HANDLE)(UINTN)gFdInfo[Index].Address,\n                  &FileHandle\n                  );\n      if (!EFI_ERROR (Status)) {\n        Status = PeiServicesFfsFindSectionData (EFI_SECTION_PE32, FileHandle, &SecFile);\n        if (!EFI_ERROR (Status)) {\n          PeiIndex = Index;\n          printf (\" contains SEC Core\");\n        }\n      }\n    }\n\n    printf (\"\\n\");\n  }\n\n  if (SecFile == NULL) {\n    printf (\"ERROR : SEC not found!\\n\");\n    exit (1);\n  }\n\n  //\n  // Calculate memory regions and store the information in the gSystemMemory\n  //  global for later use. The autosizing code will use this data to\n  //  map this memory into the SEC process memory space.\n  //\n  Index1 = 0;\n  Index = 0;\n  while (1) {\n    UINTN val = 0;\n    //\n    // Save the size of the memory.\n    //\n    while (MemorySizeStr[Index1] >= '0' && MemorySizeStr[Index1] <= '9') {\n      val = val * 10 + MemorySizeStr[Index1] - '0';\n      Index1++;\n    }\n    gSystemMemory[Index++].Size = val * 0x100000;\n    if (MemorySizeStr[Index1] == 0) {\n      break;\n    }\n    Index1++;\n  }\n\n  printf (\"\\n\");\n\n  //\n  // Hand off to SEC\n  //\n  SecLoadFromCore ((UINTN) InitialStackMemory, (UINTN) InitialStackMemorySize, (UINTN) gFdInfo[0].Address, SecFile);\n\n  //\n  // If we get here, then the SEC Core returned. This is an error as SEC should\n  //  always hand off to PEI Core and then on to DXE Core.\n  //\n  printf (\"ERROR : SEC returned\\n\");\n  exit (1);\n}\n\n\nEFI_PHYSICAL_ADDRESS *\nMapMemory (\n  IN INTN   fd,\n  IN UINT64 length,\n  IN INTN   prot,\n  IN INTN   flags\n  )\n{\n  STATIC UINTN base  = 0x40000000;\n  CONST UINTN  align = (1 << 24);\n  VOID         *res  = NULL;\n  BOOLEAN      isAligned = 0;\n\n  //\n  // Try to get an aligned block somewhere in the address space of this\n  // process.\n  //\n  while((!isAligned) && (base != 0)) {\n    res = mmap ((void *)base, length, prot, flags, fd, 0);\n    if (res == MAP_FAILED) {\n      return NULL;\n    }\n    if ((((UINTN)res) & ~(align-1)) == (UINTN)res) {\n      isAligned=1;\n    } else {\n      munmap(res, length);\n      base += align;\n    }\n  }\n  return res;\n}\n\n\n/*++\n\nRoutine Description:\n  Opens and memory maps a file using Unix services. If BaseAddress is non zero\n  the process will try and allocate the memory starting at BaseAddress.\n\nArguments:\n  FileName            - The name of the file to open and map\n  MapSize             - The amount of the file to map in bytes\n  CreationDisposition - The flags to pass to CreateFile().  Use to create new files for\n                        memory emulation, and exiting files for firmware volume emulation\n  BaseAddress         - The base address of the mapped file in the user address space.\n                         If passed in as NULL the a new memory region is used.\n                         If passed in as non NULL the request memory region is used for\n                          the mapping of the file into the process space.\n  Length              - The size of the mapped region in bytes\n\nReturns:\n  EFI_SUCCESS      - The file was opened and mapped.\n  EFI_NOT_FOUND    - FileName was not found in the current directory\n  EFI_DEVICE_ERROR - An error occured attempting to map the opened file\n\n**/\nEFI_STATUS\nMapFile (\n  IN  CHAR8                     *FileName,\n  IN OUT  EFI_PHYSICAL_ADDRESS  *BaseAddress,\n  OUT UINT64                    *Length\n  )\n{\n  int     fd;\n  VOID    *res;\n  UINTN   FileSize;\n\n  fd = open (FileName, O_RDWR);\n  if (fd < 0) {\n    return EFI_NOT_FOUND;\n  }\n  FileSize = lseek (fd, 0, SEEK_END);\n\n\n  res = MapMemory (fd, FileSize, PROT_READ | PROT_EXEC, MAP_PRIVATE);\n\n  close (fd);\n\n  if (res == NULL) {\n    perror (\"MapFile() Failed\");\n    return EFI_DEVICE_ERROR;\n  }\n\n  *Length = (UINT64) FileSize;\n  *BaseAddress = (EFI_PHYSICAL_ADDRESS) (UINTN) res;\n\n  return EFI_SUCCESS;\n}\n\nEFI_STATUS\nMapFd0 (\n  IN  CHAR8                     *FileName,\n  IN OUT  EFI_PHYSICAL_ADDRESS  *BaseAddress,\n  OUT UINT64                    *Length\n  )\n{\n  int     fd;\n  void    *res, *res2, *res3;\n  UINTN   FileSize;\n  UINTN   FvSize;\n  void    *EmuMagicPage;\n\n  fd = open (FileName, O_RDWR);\n  if (fd < 0) {\n    return EFI_NOT_FOUND;\n  }\n  FileSize = lseek (fd, 0, SEEK_END);\n\n  FvSize = FixedPcdGet64 (PcdEmuFlashFvRecoverySize);\n\n  // Assume start of FD is Recovery FV, and make it write protected\n  res = mmap (\n          (void *)(UINTN)FixedPcdGet64 (PcdEmuFlashFvRecoveryBase),\n          FvSize,\n          PROT_READ | PROT_EXEC,\n          MAP_PRIVATE,\n          fd,\n          0\n          );\n  if (res == MAP_FAILED) {\n    perror (\"MapFd0() Failed res =\");\n    close (fd);\n    return EFI_DEVICE_ERROR;\n  } else if (res != (void *)(UINTN)FixedPcdGet64 (PcdEmuFlashFvRecoveryBase)) {\n    // We could not load at the build address, so we need to allow writes\n    munmap (res, FvSize);\n    res = mmap (\n            (void *)(UINTN)FixedPcdGet64 (PcdEmuFlashFvRecoveryBase),\n            FvSize,\n            PROT_READ | PROT_WRITE | PROT_EXEC,\n            MAP_PRIVATE,\n            fd,\n            0\n            );\n    if (res == MAP_FAILED) {\n      perror (\"MapFd0() Failed res =\");\n      close (fd);\n      return EFI_DEVICE_ERROR;\n    }\n  }\n\n  // Map the rest of the FD as read/write\n  res2 = mmap (\n          (void *)(UINTN)(FixedPcdGet64 (PcdEmuFlashFvRecoveryBase) + FvSize),\n          FileSize - FvSize,\n          PROT_READ | PROT_WRITE | PROT_EXEC,\n          MAP_SHARED,\n          fd,\n          FvSize\n          );\n  close (fd);\n  if (res2 == MAP_FAILED) {\n    perror (\"MapFd0() Failed res2 =\");\n    return EFI_DEVICE_ERROR;\n  }\n\n  //\n  // If enabled use the magic page to communicate between modules\n  // This replaces the PI PeiServicesTable pointer mechanism that\n  // deos not work in the emulator. It also allows the removal of\n  // writable globals from SEC, PEI_CORE (libraries), PEIMs\n  //\n  EmuMagicPage = (void *)(UINTN)FixedPcdGet64 (PcdPeiServicesTablePage);\n  if (EmuMagicPage != NULL) {\n    res3 =  mmap (\n              (void *)EmuMagicPage,\n              4096,\n              PROT_READ | PROT_WRITE,\n              MAP_PRIVATE | MAP_ANONYMOUS,\n              0,\n              0\n              );\n    if (res3 != EmuMagicPage) {\n      printf (\"MapFd0(): Could not allocate PeiServicesTablePage @ %lx\\n\", (long unsigned int)EmuMagicPage);\n      return EFI_DEVICE_ERROR;\n    }\n  }\n\n  *Length = (UINT64) FileSize;\n  *BaseAddress = (EFI_PHYSICAL_ADDRESS) (UINTN) res;\n\n  return EFI_SUCCESS;\n}\n\n\n/*++\n\nRoutine Description:\n  This is the service to load the SEC Core from the Firmware Volume\n\nArguments:\n  LargestRegion           - Memory to use for SEC.\n  LargestRegionSize       - Size of Memory to use for PEI\n  BootFirmwareVolumeBase  - Start of the Boot FV\n  PeiCorePe32File         - SEC PE32\n\nReturns:\n  Success means control is transfered and thus we should never return\n\n**/\nVOID\nSecLoadFromCore (\n  IN  UINTN   LargestRegion,\n  IN  UINTN   LargestRegionSize,\n  IN  UINTN   BootFirmwareVolumeBase,\n  IN  VOID    *PeiCorePe32File\n  )\n{\n  EFI_STATUS                  Status;\n  EFI_PHYSICAL_ADDRESS        TopOfMemory;\n  VOID                        *TopOfStack;\n  EFI_PHYSICAL_ADDRESS        PeiCoreEntryPoint;\n  EFI_SEC_PEI_HAND_OFF        *SecCoreData;\n  UINTN                       PeiStackSize;\n\n  //\n  // Compute Top Of Memory for Stack and PEI Core Allocations\n  //\n  TopOfMemory  = LargestRegion + LargestRegionSize;\n  PeiStackSize = (UINTN)RShiftU64((UINT64)STACK_SIZE,1);\n\n  //\n  // |-----------| <---- TemporaryRamBase + TemporaryRamSize\n  // |   Heap    |\n  // |           |\n  // |-----------| <---- StackBase / PeiTemporaryMemoryBase\n  // |           |\n  // |  Stack    |\n  // |-----------| <---- TemporaryRamBase\n  //\n  TopOfStack  = (VOID *)(LargestRegion + PeiStackSize);\n  TopOfMemory = LargestRegion + PeiStackSize;\n\n  //\n  // Reservet space for storing PeiCore's parament in stack.\n  //\n  TopOfStack  = (VOID *)((UINTN)TopOfStack - sizeof (EFI_SEC_PEI_HAND_OFF) - CPU_STACK_ALIGNMENT);\n  TopOfStack  = ALIGN_POINTER (TopOfStack, CPU_STACK_ALIGNMENT);\n\n\n  //\n  // Bind this information into the SEC hand-off state\n  //\n  SecCoreData                         = (EFI_SEC_PEI_HAND_OFF*)(UINTN) TopOfStack;\n  SecCoreData->DataSize               = sizeof(EFI_SEC_PEI_HAND_OFF);\n  SecCoreData->BootFirmwareVolumeBase = (VOID*)BootFirmwareVolumeBase;\n  SecCoreData->BootFirmwareVolumeSize = PcdGet32 (PcdEmuFirmwareFdSize);\n  SecCoreData->TemporaryRamBase       = (VOID*)(UINTN)LargestRegion;\n  SecCoreData->TemporaryRamSize       = STACK_SIZE;\n  SecCoreData->StackBase              = SecCoreData->TemporaryRamBase;\n  SecCoreData->StackSize              = PeiStackSize;\n  SecCoreData->PeiTemporaryRamBase    = (VOID*) ((UINTN) SecCoreData->TemporaryRamBase + PeiStackSize);\n  SecCoreData->PeiTemporaryRamSize    = STACK_SIZE - PeiStackSize;\n\n  //\n  // Find the SEC Core Entry Point\n  //\n  Status = SecPeCoffGetEntryPoint (PeiCorePe32File, (VOID **)&PeiCoreEntryPoint);\n  if (EFI_ERROR (Status)) {\n    return ;\n  }\n\n  //\n  // Transfer control to the SEC Core\n  //\n  PeiSwitchStacks (\n    (SWITCH_STACK_ENTRY_POINT) (UINTN) PeiCoreEntryPoint,\n    SecCoreData,\n    (VOID *)gPpiList,\n    TopOfStack\n    );\n  //\n  // If we get here, then the SEC Core returned.  This is an error\n  //\n  return ;\n}\n\n\n/*++\n\nRoutine Description:\n  This service is called from Index == 0 until it returns EFI_UNSUPPORTED.\n  It allows discontinuous memory regions to be supported by the emulator.\n  It uses gSystemMemory[] and gSystemMemoryCount that were created by\n  parsing the host environment variable EFI_MEMORY_SIZE.\n  The size comes from the varaible and the address comes from the call to\n  UnixOpenFile.\n\nArguments:\n  Index      - Which memory region to use\n  MemoryBase - Return Base address of memory region\n  MemorySize - Return size in bytes of the memory region\n\nReturns:\n  EFI_SUCCESS - If memory region was mapped\n  EFI_UNSUPPORTED - If Index is not supported\n\n**/\nEFI_STATUS\nSecUnixPeiAutoScan (\n  IN  UINTN                 Index,\n  OUT EFI_PHYSICAL_ADDRESS  *MemoryBase,\n  OUT UINT64                *MemorySize\n  )\n{\n  void *res;\n\n  if (Index >= gSystemMemoryCount) {\n    return EFI_UNSUPPORTED;\n  }\n\n  *MemoryBase = 0;\n  res = MapMemory (\n          0, gSystemMemory[Index].Size,\n          PROT_READ | PROT_WRITE | PROT_EXEC,\n          MAP_PRIVATE | MAP_ANONYMOUS\n          );\n  if (res == MAP_FAILED) {\n    return EFI_DEVICE_ERROR;\n  }\n  *MemorySize = gSystemMemory[Index].Size;\n  *MemoryBase = (UINTN)res;\n  gSystemMemory[Index].Memory = *MemoryBase;\n\n  return EFI_SUCCESS;\n}\n\n\n/*++\n\nRoutine Description:\n Check to see if an address range is in the EFI GCD memory map.\n\n This is all of GCD for system memory passed to DXE Core. FV\n mapping and other device mapped into system memory are not\n inlcuded in the check.\n\nArguments:\n  Index      - Which memory region to use\n  MemoryBase - Return Base address of memory region\n  MemorySize - Return size in bytes of the memory region\n\nReturns:\n  TRUE -  Address is in the EFI GCD memory map\n  FALSE - Address is NOT in memory map\n\n**/\nBOOLEAN\nEfiSystemMemoryRange (\n  IN  VOID *MemoryAddress\n  )\n{\n  UINTN                 Index;\n  EFI_PHYSICAL_ADDRESS  MemoryBase;\n\n  MemoryBase = (EFI_PHYSICAL_ADDRESS)(UINTN)MemoryAddress;\n  for (Index = 0; Index < gSystemMemoryCount; Index++) {\n    if ((MemoryBase >= gSystemMemory[Index].Memory) &&\n        (MemoryBase < (gSystemMemory[Index].Memory + gSystemMemory[Index].Size)) ) {\n      return TRUE;\n    }\n  }\n\n  return FALSE;\n}\n\n\n/*++\n\nRoutine Description:\n  Since the SEC is the only Unix program in stack it must export\n  an interface to do POSIX calls.  gUnix is initialized in UnixThunk.c.\n\nArguments:\n  InterfaceSize - sizeof (EFI_WIN_NT_THUNK_PROTOCOL);\n  InterfaceBase - Address of the gUnix global\n\nReturns:\n  EFI_SUCCESS - Data returned\n\n**/\nVOID *\nSecEmuThunkAddress (\n  VOID\n  )\n{\n  return &gEmuThunkProtocol;\n}\n\n\n\nRETURN_STATUS\nEFIAPI\nSecPeCoffGetEntryPoint (\n  IN     VOID  *Pe32Data,\n  IN OUT VOID  **EntryPoint\n  )\n{\n  EFI_STATUS                    Status;\n  PE_COFF_LOADER_IMAGE_CONTEXT  ImageContext;\n\n  ZeroMem (&ImageContext, sizeof (ImageContext));\n  ImageContext.Handle     = Pe32Data;\n  ImageContext.ImageRead  = (PE_COFF_LOADER_READ_FILE) SecImageRead;\n\n  Status                  = PeCoffLoaderGetImageInfo (&ImageContext);\n  if (EFI_ERROR (Status)) {\n    return Status;\n  }\n\n  if (ImageContext.ImageAddress != (UINTN)Pe32Data) {\n    //\n    // Relocate image to match the address where it resides\n    //\n    ImageContext.ImageAddress = (UINTN)Pe32Data;\n    Status = PeCoffLoaderLoadImage (&ImageContext);\n    if (EFI_ERROR (Status)) {\n      return Status;\n    }\n\n    Status = PeCoffLoaderRelocateImage (&ImageContext);\n    if (EFI_ERROR (Status)) {\n      return Status;\n    }\n  } else {\n    //\n    // Or just return image entry point\n    //\n    ImageContext.PdbPointer = PeCoffLoaderGetPdbPointer (Pe32Data);\n    Status = PeCoffLoaderGetEntryPoint (Pe32Data, EntryPoint);\n    if (EFI_ERROR (Status)) {\n      return Status;\n    }\n    ImageContext.EntryPoint = (UINTN)*EntryPoint;\n  }\n\n  // On Unix a dlopen is done that will change the entry point\n  SecPeCoffRelocateImageExtraAction (&ImageContext);\n  *EntryPoint = (VOID *)(UINTN)ImageContext.EntryPoint;\n\n  return Status;\n}\n\n\n\n/*++\n\nRoutine Description:\n  Return the FD Size and base address. Since the FD is loaded from a\n  file into host memory only the SEC will know it's address.\n\nArguments:\n  Index  - Which FD, starts at zero.\n  FdSize - Size of the FD in bytes\n  FdBase - Start address of the FD. Assume it points to an FV Header\n  FixUp  - Difference between actual FD address and build address\n\nReturns:\n  EFI_SUCCESS     - Return the Base address and size of the FV\n  EFI_UNSUPPORTED - Index does nto map to an FD in the system\n\n**/\nEFI_STATUS\nSecUnixFdAddress (\n  IN     UINTN                 Index,\n  IN OUT EFI_PHYSICAL_ADDRESS  *FdBase,\n  IN OUT UINT64                *FdSize,\n  IN OUT EFI_PHYSICAL_ADDRESS  *FixUp\n  )\n{\n  if (Index >= gFdInfoCount) {\n    return EFI_UNSUPPORTED;\n  }\n\n  *FdBase = gFdInfo[Index].Address;\n  *FdSize = gFdInfo[Index].Size;\n  *FixUp  = 0;\n\n  if (*FdBase == 0 && *FdSize == 0) {\n    return EFI_UNSUPPORTED;\n  }\n\n  if (Index == 0) {\n    //\n    // FD 0 has XIP code and well known PCD values\n    // If the memory buffer could not be allocated at the FD build address\n    // the Fixup is the difference.\n    //\n    *FixUp = *FdBase - PcdGet64 (PcdEmuFdBaseAddress);\n  }\n\n  return EFI_SUCCESS;\n}\n\n\n/*++\n\nRoutine Description:\n  Count the number of separators in String\n\nArguments:\n  String    - String to process\n  Separator - Item to count\n\nReturns:\n  Number of Separator in String\n\n**/\nUINTN\nCountSeparatorsInString (\n  IN  const CHAR16   *String,\n  IN  CHAR16         Separator\n  )\n{\n  UINTN Count;\n\n  for (Count = 0; *String != '\\0'; String++) {\n    if (*String == Separator) {\n      Count++;\n    }\n  }\n\n  return Count;\n}\n\n\nEFI_STATUS\nEFIAPI\nSecImageRead (\n  IN     VOID    *FileHandle,\n  IN     UINTN   FileOffset,\n  IN OUT UINTN   *ReadSize,\n  OUT    VOID    *Buffer\n  )\n/*++\n\nRoutine Description:\n  Support routine for the PE/COFF Loader that reads a buffer from a PE/COFF file\n\nArguments:\n  FileHandle - The handle to the PE/COFF file\n  FileOffset - The offset, in bytes, into the file to read\n  ReadSize   - The number of bytes to read from the file starting at FileOffset\n  Buffer     - A pointer to the buffer to read the data into.\n\nReturns:\n  EFI_SUCCESS - ReadSize bytes of data were read into Buffer from the PE/COFF file starting at FileOffset\n\n**/\n{\n  CHAR8 *Destination8;\n  CHAR8 *Source8;\n  UINTN Length;\n\n  Destination8  = Buffer;\n  Source8       = (CHAR8 *) ((UINTN) FileHandle + FileOffset);\n  Length        = *ReadSize;\n  while (Length--) {\n    *(Destination8++) = *(Source8++);\n  }\n\n  return EFI_SUCCESS;\n}\n\n\n/*++\n\nRoutine Description:\n  Store the ModHandle in an array indexed by the Pdb File name.\n  The ModHandle is needed to unload the image.\n\nArguments:\n  ImageContext - Input data returned from PE Laoder Library. Used to find the\n                 .PDB file name of the PE Image.\n  ModHandle    - Returned from LoadLibraryEx() and stored for call to\n                 FreeLibrary().\n\nReturns:\n  EFI_SUCCESS - ModHandle was stored.\n\n**/\nEFI_STATUS\nAddHandle (\n  IN  PE_COFF_LOADER_IMAGE_CONTEXT         *ImageContext,\n  IN  VOID                                 *ModHandle\n  )\n{\n  UINTN                       Index;\n  IMAGE_CONTEXT_TO_MOD_HANDLE *Array;\n  UINTN                       PreviousSize;\n\n\n  Array = mImageContextModHandleArray;\n  for (Index = 0; Index < mImageContextModHandleArraySize; Index++, Array++) {\n    if (Array->ImageContext == NULL) {\n      //\n      // Make a copy of the stirng and store the ModHandle\n      //\n      Array->ImageContext = ImageContext;\n      Array->ModHandle    = ModHandle;\n      return EFI_SUCCESS;\n    }\n  }\n\n  //\n  // No free space in mImageContextModHandleArray so grow it by\n  // IMAGE_CONTEXT_TO_MOD_HANDLE entires. realloc will\n  // copy the old values to the new locaiton. But it does\n  // not zero the new memory area.\n  //\n  PreviousSize = mImageContextModHandleArraySize * sizeof (IMAGE_CONTEXT_TO_MOD_HANDLE);\n  mImageContextModHandleArraySize += MAX_IMAGE_CONTEXT_TO_MOD_HANDLE_ARRAY_SIZE;\n\n  mImageContextModHandleArray = ReallocatePool (\n                                  (mImageContextModHandleArraySize - 1) * sizeof (IMAGE_CONTEXT_TO_MOD_HANDLE),\n                                  mImageContextModHandleArraySize * sizeof (IMAGE_CONTEXT_TO_MOD_HANDLE),\n                                  mImageContextModHandleArray\n                                  );\n  if (mImageContextModHandleArray == NULL) {\n    ASSERT (FALSE);\n    return EFI_OUT_OF_RESOURCES;\n  }\n\n  memset (mImageContextModHandleArray + PreviousSize, 0, MAX_IMAGE_CONTEXT_TO_MOD_HANDLE_ARRAY_SIZE * sizeof (IMAGE_CONTEXT_TO_MOD_HANDLE));\n\n  return AddHandle (ImageContext, ModHandle);\n}\n\n\n/*++\n\nRoutine Description:\n  Return the ModHandle and delete the entry in the array.\n\nArguments:\n  ImageContext - Input data returned from PE Laoder Library. Used to find the\n                 .PDB file name of the PE Image.\n\nReturns:\n  ModHandle - ModHandle assoicated with ImageContext is returned\n  NULL      - No ModHandle associated with ImageContext\n\n**/\nVOID *\nRemoveHandle (\n  IN  PE_COFF_LOADER_IMAGE_CONTEXT         *ImageContext\n  )\n{\n  UINTN                        Index;\n  IMAGE_CONTEXT_TO_MOD_HANDLE  *Array;\n\n  if (ImageContext->PdbPointer == NULL) {\n    //\n    // If no PDB pointer there is no ModHandle so return NULL\n    //\n    return NULL;\n  }\n\n  Array = mImageContextModHandleArray;\n  for (Index = 0; Index < mImageContextModHandleArraySize; Index++, Array++) {\n    if (Array->ImageContext == ImageContext) {\n      //\n      // If you find a match return it and delete the entry\n      //\n      Array->ImageContext = NULL;\n      return Array->ModHandle;\n    }\n  }\n\n  return NULL;\n}\n\n\n\nBOOLEAN\nIsPdbFile (\n  IN  CHAR8   *PdbFileName\n  )\n{\n  UINTN Len;\n\n  if (PdbFileName == NULL) {\n    return FALSE;\n  }\n\n  Len = strlen (PdbFileName);\n  if ((Len < 5)|| (PdbFileName[Len - 4] != '.')) {\n    return FALSE;\n  }\n\n  if ((PdbFileName[Len - 3] == 'P' || PdbFileName[Len - 3] == 'p') &&\n      (PdbFileName[Len - 2] == 'D' || PdbFileName[Len - 2] == 'd') &&\n      (PdbFileName[Len - 1] == 'B' || PdbFileName[Len - 1] == 'b')) {\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\n#define MAX_SPRINT_BUFFER_SIZE 0x200\n\nvoid\nPrintLoadAddress (\n  IN PE_COFF_LOADER_IMAGE_CONTEXT          *ImageContext\n  )\n{\n  if (ImageContext->PdbPointer == NULL) {\n    fprintf (stderr,\n      \"0x%08lx Loading NO DEBUG with entry point 0x%08lx\\n\",\n      (unsigned long)(ImageContext->ImageAddress),\n      (unsigned long)ImageContext->EntryPoint\n      );\n  } else {\n    fprintf (stderr,\n      \"0x%08lx Loading %s with entry point 0x%08lx\\n\",\n      (unsigned long)(ImageContext->ImageAddress + ImageContext->SizeOfHeaders),\n      ImageContext->PdbPointer,\n      (unsigned long)ImageContext->EntryPoint\n      );\n  }\n  // Keep output synced up\n  fflush (stderr);\n}\n\n\n/**\n  Loads the image using dlopen so symbols will be automatically\n  loaded by gdb.\n\n  @param  ImageContext  The PE/COFF image context\n\n  @retval TRUE - The image was successfully loaded\n  @retval FALSE - The image was successfully loaded\n\n**/\nBOOLEAN\nDlLoadImage (\n  IN OUT PE_COFF_LOADER_IMAGE_CONTEXT         *ImageContext\n  )\n{\n\n#ifdef __APPLE__\n\n  return FALSE;\n\n#else\n\n  void        *Handle = NULL;\n  void        *Entry = NULL;\n\n  if (ImageContext->PdbPointer == NULL) {\n    return FALSE;\n  }\n\n  if (!IsPdbFile (ImageContext->PdbPointer)) {\n    return FALSE;\n  }\n\n  fprintf (\n     stderr,\n     \"Loading %s 0x%08lx - entry point 0x%08lx\\n\",\n     ImageContext->PdbPointer,\n     (unsigned long)ImageContext->ImageAddress,\n     (unsigned long)ImageContext->EntryPoint\n     );\n\n  Handle = dlopen (ImageContext->PdbPointer, RTLD_NOW);\n  if (Handle != NULL) {\n    Entry = dlsym (Handle, \"_ModuleEntryPoint\");\n    AddHandle (ImageContext, Handle);\n  } else {\n    printf(\"%s\\n\", dlerror());\n  }\n\n  if (Entry != NULL) {\n    ImageContext->EntryPoint = (UINTN)Entry;\n    printf (\"Change %s Entrypoint to :0x%08lx\\n\", ImageContext->PdbPointer, (unsigned long)Entry);\n    return TRUE;\n  } else {\n    return FALSE;\n  }\n\n#endif\n}\n\n\nVOID\nSecGdbScriptBreak (\n  char                *FileName,\n  int                 FileNameLength,\n  long unsigned int   LoadAddress,\n  int                 AddSymbolFlag\n  )\n{\n  return;\n}\n\n\n/**\n  Adds the image to a gdb script so it's symbols can be loaded.\n  The AddFirmwareSymbolFile helper macro is used.\n\n  @param  ImageContext  The PE/COFF image context\n\n**/\nVOID\nGdbScriptAddImage (\n  IN OUT PE_COFF_LOADER_IMAGE_CONTEXT         *ImageContext\n  )\n{\n\n  PrintLoadAddress (ImageContext);\n\n  if (ImageContext->PdbPointer != NULL && !IsPdbFile (ImageContext->PdbPointer)) {\n    FILE  *GdbTempFile;\n    if (FeaturePcdGet (PcdEmulatorLazyLoadSymbols)) {\n      GdbTempFile = fopen (gGdbWorkingFileName, \"a\");\n      if (GdbTempFile != NULL) {\n        long unsigned int SymbolsAddr = (long unsigned int)(ImageContext->ImageAddress + ImageContext->SizeOfHeaders);\n        mScriptSymbolChangesCount++;\n        fprintf (\n          GdbTempFile,\n          \"AddFirmwareSymbolFile 0x%x %s 0x%08lx\\n\",\n          mScriptSymbolChangesCount,\n          ImageContext->PdbPointer,\n          SymbolsAddr\n          );\n        fclose (GdbTempFile);\n        // This is for the lldb breakpoint only\n        SecGdbScriptBreak (ImageContext->PdbPointer, strlen (ImageContext->PdbPointer) + 1, (long unsigned int)(ImageContext->ImageAddress + ImageContext->SizeOfHeaders), 1);\n      } else {\n        ASSERT (FALSE);\n      }\n    } else {\n      GdbTempFile = fopen (gGdbWorkingFileName, \"w\");\n      if (GdbTempFile != NULL) {\n        fprintf (\n          GdbTempFile,\n          \"add-symbol-file %s 0x%08lx\\n\",\n          ImageContext->PdbPointer,\n          (long unsigned int)(ImageContext->ImageAddress + ImageContext->SizeOfHeaders)\n          );\n        fclose (GdbTempFile);\n\n        //\n        // Target for gdb breakpoint in a script that uses gGdbWorkingFileName to set a breakpoint.\n        // Hey what can you say scripting in gdb is not that great....\n        // Also used for the lldb breakpoint script. The lldb breakpoint script does\n        // not use the file, it uses the arguments.\n        //\n        SecGdbScriptBreak (ImageContext->PdbPointer, strlen (ImageContext->PdbPointer) + 1, (long unsigned int)(ImageContext->ImageAddress + ImageContext->SizeOfHeaders), 1);\n      } else {\n        ASSERT (FALSE);\n      }\n    }\n  }\n}\n\n\nVOID\nEFIAPI\nSecPeCoffRelocateImageExtraAction (\n  IN OUT PE_COFF_LOADER_IMAGE_CONTEXT         *ImageContext\n  )\n{\n  if (!DlLoadImage (ImageContext)) {\n    GdbScriptAddImage (ImageContext);\n  }\n}\n\n\n/**\n  Adds the image to a gdb script so it's symbols can be unloaded.\n  The RemoveFirmwareSymbolFile helper macro is used.\n\n  @param  ImageContext  The PE/COFF image context\n\n**/\nVOID\nGdbScriptRemoveImage (\n  IN OUT PE_COFF_LOADER_IMAGE_CONTEXT         *ImageContext\n  )\n{\n  FILE  *GdbTempFile;\n\n  //\n  // Need to skip .PDB files created from VC++\n  //\n  if (IsPdbFile (ImageContext->PdbPointer)) {\n    return;\n  }\n\n  if (FeaturePcdGet (PcdEmulatorLazyLoadSymbols)) {\n    //\n    // Write the file we need for the gdb script\n    //\n    GdbTempFile = fopen (gGdbWorkingFileName, \"a\");\n    if (GdbTempFile != NULL) {\n      mScriptSymbolChangesCount++;\n      fprintf (\n        GdbTempFile,\n        \"RemoveFirmwareSymbolFile 0x%x %s\\n\",\n        mScriptSymbolChangesCount,\n        ImageContext->PdbPointer\n        );\n      fclose (GdbTempFile);\n      SecGdbScriptBreak (ImageContext->PdbPointer, strlen (ImageContext->PdbPointer) + 1, 0, 0);\n    } else {\n      ASSERT (FALSE);\n    }\n  } else {\n    GdbTempFile = fopen (gGdbWorkingFileName, \"w\");\n    if (GdbTempFile != NULL) {\n      fprintf (GdbTempFile, \"remove-symbol-file %s\\n\", ImageContext->PdbPointer);\n      fclose (GdbTempFile);\n\n      //\n      // Target for gdb breakpoint in a script that uses gGdbWorkingFileName to set a breakpoint.\n      // Hey what can you say scripting in gdb is not that great....\n      //\n      SecGdbScriptBreak (ImageContext->PdbPointer, strlen (ImageContext->PdbPointer) + 1, 0, 0);\n    } else {\n      ASSERT (FALSE);\n    }\n  }\n}\n\n\nVOID\nEFIAPI\nSecPeCoffUnloadImageExtraAction (\n  IN PE_COFF_LOADER_IMAGE_CONTEXT         *ImageContext\n  )\n{\n  VOID *Handle;\n\n  //\n  // Check to see if the image symbols were loaded with gdb script, or dlopen\n  //\n  Handle = RemoveHandle (ImageContext);\n  if (Handle != NULL) {\n#ifndef __APPLE__\n    dlclose (Handle);\n#endif\n    return;\n  }\n\n  GdbScriptRemoveImage (ImageContext);\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/CryptoPkg/Library/OpensslLib/openssl/crypto/dso/dso_dlfcn.c": "/*\n * Copyright 2000-2018 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n/*\n * We need to do this early, because stdio.h includes the header files that\n * handle _GNU_SOURCE and other similar macros.  Defining it later is simply\n * too late, because those headers are protected from re- inclusion.\n */\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE            /* make sure dladdr is declared */\n#endif\n\n#include \"dso_locl.h\"\n#include \"e_os.h\"\n\n#ifdef DSO_DLFCN\n\n# ifdef HAVE_DLFCN_H\n#  ifdef __osf__\n#   define __EXTENSIONS__\n#  endif\n#  include <dlfcn.h>\n#  define HAVE_DLINFO 1\n#  if defined(__CYGWIN__) || \\\n     defined(__SCO_VERSION__) || defined(_SCO_ELF) || \\\n     (defined(__osf__) && !defined(RTLD_NEXT))     || \\\n     (defined(__OpenBSD__) && !defined(RTLD_SELF)) || \\\n        defined(__ANDROID__)\n#   undef HAVE_DLINFO\n#  endif\n# endif\n\n/* Part of the hack in \"dlfcn_load\" ... */\n# define DSO_MAX_TRANSLATED_SIZE 256\n\nstatic int dlfcn_load(DSO *dso);\nstatic int dlfcn_unload(DSO *dso);\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname);\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename);\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\n                          const char *filespec2);\nstatic int dlfcn_pathbyaddr(void *addr, char *path, int sz);\nstatic void *dlfcn_globallookup(const char *name);\n\nstatic DSO_METHOD dso_meth_dlfcn = {\n    \"OpenSSL 'dlfcn' shared library method\",\n    dlfcn_load,\n    dlfcn_unload,\n    dlfcn_bind_func,\n    NULL,                       /* ctrl */\n    dlfcn_name_converter,\n    dlfcn_merger,\n    NULL,                       /* init */\n    NULL,                       /* finish */\n    dlfcn_pathbyaddr,\n    dlfcn_globallookup\n};\n\nDSO_METHOD *DSO_METHOD_openssl(void)\n{\n    return &dso_meth_dlfcn;\n}\n\n/*\n * Prior to using the dlopen() function, we should decide on the flag we\n * send. There's a few different ways of doing this and it's a messy\n * venn-diagram to match up which platforms support what. So as we don't have\n * autoconf yet, I'm implementing a hack that could be hacked further\n * relatively easily to deal with cases as we find them. Initially this is to\n * cope with OpenBSD.\n */\n# if defined(__OpenBSD__) || defined(__NetBSD__)\n#  ifdef DL_LAZY\n#   define DLOPEN_FLAG DL_LAZY\n#  else\n#   ifdef RTLD_NOW\n#    define DLOPEN_FLAG RTLD_NOW\n#   else\n#    define DLOPEN_FLAG 0\n#   endif\n#  endif\n# else\n#  define DLOPEN_FLAG RTLD_NOW  /* Hope this works everywhere else */\n# endif\n\n/*\n * For this DSO_METHOD, our meth_data STACK will contain; (i) the handle\n * (void*) returned from dlopen().\n */\n\nstatic int dlfcn_load(DSO *dso)\n{\n    void *ptr = NULL;\n    /* See applicable comments in dso_dl.c */\n    char *filename = DSO_convert_filename(dso, NULL);\n    int flags = DLOPEN_FLAG;\n    int saveerrno = get_last_sys_error();\n\n    if (filename == NULL) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_NO_FILENAME);\n        goto err;\n    }\n# ifdef RTLD_GLOBAL\n    if (dso->flags & DSO_FLAG_GLOBAL_SYMBOLS)\n        flags |= RTLD_GLOBAL;\n# endif\n# ifdef _AIX\n    if (filename[strlen(filename) - 1] == ')')\n        flags |= RTLD_MEMBER;\n# endif\n    ptr = dlopen(filename, flags);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_LOAD_FAILED);\n        ERR_add_error_data(4, \"filename(\", filename, \"): \", dlerror());\n        goto err;\n    }\n    /*\n     * Some dlopen() implementations (e.g. solaris) do no preserve errno, even\n     * on a successful call.\n     */\n    set_sys_error(saveerrno);\n    if (!sk_void_push(dso->meth_data, (char *)ptr)) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_STACK_ERROR);\n        goto err;\n    }\n    /* Success */\n    dso->loaded_filename = filename;\n    return 1;\n err:\n    /* Cleanup! */\n    OPENSSL_free(filename);\n    if (ptr != NULL)\n        dlclose(ptr);\n    return 0;\n}\n\nstatic int dlfcn_unload(DSO *dso)\n{\n    void *ptr;\n    if (dso == NULL) {\n        DSOerr(DSO_F_DLFCN_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n    if (sk_void_num(dso->meth_data) < 1)\n        return 1;\n    ptr = sk_void_pop(dso->meth_data);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_UNLOAD, DSO_R_NULL_HANDLE);\n        /*\n         * Should push the value back onto the stack in case of a retry.\n         */\n        sk_void_push(dso->meth_data, ptr);\n        return 0;\n    }\n    /* For now I'm not aware of any errors associated with dlclose() */\n    dlclose(ptr);\n    return 1;\n}\n\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname)\n{\n    void *ptr;\n    union {\n        DSO_FUNC_TYPE sym;\n        void *dlret;\n    } u;\n\n    if ((dso == NULL) || (symname == NULL)) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);\n        return NULL;\n    }\n    if (sk_void_num(dso->meth_data) < 1) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_STACK_ERROR);\n        return NULL;\n    }\n    ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_NULL_HANDLE);\n        return NULL;\n    }\n    u.dlret = dlsym(ptr, symname);\n    if (u.dlret == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_SYM_FAILURE);\n        ERR_add_error_data(4, \"symname(\", symname, \"): \", dlerror());\n        return NULL;\n    }\n    return u.sym;\n}\n\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\n                          const char *filespec2)\n{\n    char *merged;\n\n    if (!filespec1 && !filespec2) {\n        DSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\n        return NULL;\n    }\n    /*\n     * If the first file specification is a rooted path, it rules. same goes\n     * if the second file specification is missing.\n     */\n    if (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\n        merged = OPENSSL_strdup(filespec1);\n        if (merged == NULL) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return NULL;\n        }\n    }\n    /*\n     * If the first file specification is missing, the second one rules.\n     */\n    else if (!filespec1) {\n        merged = OPENSSL_strdup(filespec2);\n        if (merged == NULL) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return NULL;\n        }\n    } else {\n        /*\n         * This part isn't as trivial as it looks.  It assumes that the\n         * second file specification really is a directory, and makes no\n         * checks whatsoever.  Therefore, the result becomes the\n         * concatenation of filespec2 followed by a slash followed by\n         * filespec1.\n         */\n        int spec2len, len;\n\n        spec2len = strlen(filespec2);\n        len = spec2len + strlen(filespec1);\n\n        if (spec2len && filespec2[spec2len - 1] == '/') {\n            spec2len--;\n            len--;\n        }\n        merged = OPENSSL_malloc(len + 2);\n        if (merged == NULL) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return NULL;\n        }\n        strcpy(merged, filespec2);\n        merged[spec2len] = '/';\n        strcpy(&merged[spec2len + 1], filespec1);\n    }\n    return merged;\n}\n\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename)\n{\n    char *translated;\n    int len, rsize, transform;\n\n    len = strlen(filename);\n    rsize = len + 1;\n    transform = (strstr(filename, \"/\") == NULL);\n    if (transform) {\n        /* We will convert this to \"%s.so\" or \"lib%s.so\" etc */\n        rsize += strlen(DSO_EXTENSION);    /* The length of \".so\" */\n        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\n            rsize += 3;         /* The length of \"lib\" */\n    }\n    translated = OPENSSL_malloc(rsize);\n    if (translated == NULL) {\n        DSOerr(DSO_F_DLFCN_NAME_CONVERTER, DSO_R_NAME_TRANSLATION_FAILED);\n        return NULL;\n    }\n    if (transform) {\n        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\n            sprintf(translated, \"lib%s\" DSO_EXTENSION, filename);\n        else\n            sprintf(translated, \"%s\" DSO_EXTENSION, filename);\n    } else\n        sprintf(translated, \"%s\", filename);\n    return translated;\n}\n\n# ifdef __sgi\n/*-\nThis is a quote from IRIX manual for dladdr(3c):\n\n     <dlfcn.h> does not contain a prototype for dladdr or definition of\n     Dl_info.  The #include <dlfcn.h>  in the SYNOPSIS line is traditional,\n     but contains no dladdr prototype and no IRIX library contains an\n     implementation.  Write your own declaration based on the code below.\n\n     The following code is dependent on internal interfaces that are not\n     part of the IRIX compatibility guarantee; however, there is no future\n     intention to change this interface, so on a practical level, the code\n     below is safe to use on IRIX.\n*/\n#  include <rld_interface.h>\n#  ifndef _RLD_INTERFACE_DLFCN_H_DLADDR\n#   define _RLD_INTERFACE_DLFCN_H_DLADDR\ntypedef struct Dl_info {\n    const char *dli_fname;\n    void *dli_fbase;\n    const char *dli_sname;\n    void *dli_saddr;\n    int dli_version;\n    int dli_reserved1;\n    long dli_reserved[4];\n} Dl_info;\n#  else\ntypedef struct Dl_info Dl_info;\n#  endif\n#  define _RLD_DLADDR             14\n\nstatic int dladdr(void *address, Dl_info *dl)\n{\n    void *v;\n    v = _rld_new_interface(_RLD_DLADDR, address, dl);\n    return (int)v;\n}\n# endif                         /* __sgi */\n\n# ifdef _AIX\n/*-\n * See IBM's AIX Version 7.2, Technical Reference:\n *  Base Operating System and Extensions, Volume 1 and 2\n *  https://www.ibm.com/support/knowledgecenter/ssw_aix_72/com.ibm.aix.base/technicalreferences.htm\n */\n#  include <sys/ldr.h>\n#  include <errno.h>\n/* ~ 64 * (sizeof(struct ld_info) + _XOPEN_PATH_MAX + _XOPEN_NAME_MAX) */\n#  define DLFCN_LDINFO_SIZE 86976\ntypedef struct Dl_info {\n    const char *dli_fname;\n} Dl_info;\n/*\n * This dladdr()-implementation will also find the ptrgl (Pointer Glue) virtual\n * address of a function, which is just located in the DATA segment instead of\n * the TEXT segment.\n */\nstatic int dladdr(void *ptr, Dl_info *dl)\n{\n    uintptr_t addr = (uintptr_t)ptr;\n    unsigned int found = 0;\n    struct ld_info *ldinfos, *next_ldi, *this_ldi;\n\n    if ((ldinfos = OPENSSL_malloc(DLFCN_LDINFO_SIZE)) == NULL) {\n        errno = ENOMEM;\n        dl->dli_fname = NULL;\n        return 0;\n    }\n\n    if ((loadquery(L_GETINFO, (void *)ldinfos, DLFCN_LDINFO_SIZE)) < 0) {\n        /*-\n         * Error handling is done through errno and dlerror() reading errno:\n         *  ENOMEM (ldinfos buffer is too small),\n         *  EINVAL (invalid flags),\n         *  EFAULT (invalid ldinfos ptr)\n         */\n        OPENSSL_free((void *)ldinfos);\n        dl->dli_fname = NULL;\n        return 0;\n    }\n    next_ldi = ldinfos;\n\n    do {\n        this_ldi = next_ldi;\n        if (((addr >= (uintptr_t)this_ldi->ldinfo_textorg)\n             && (addr < ((uintptr_t)this_ldi->ldinfo_textorg +\n                         this_ldi->ldinfo_textsize)))\n            || ((addr >= (uintptr_t)this_ldi->ldinfo_dataorg)\n                && (addr < ((uintptr_t)this_ldi->ldinfo_dataorg +\n                            this_ldi->ldinfo_datasize)))) {\n            char *buffer, *member;\n            size_t buffer_sz, member_len;\n\n            buffer_sz = strlen(this_ldi->ldinfo_filename) + 1;\n            member = this_ldi->ldinfo_filename + buffer_sz;\n            if ((member_len = strlen(member)) > 0)\n                buffer_sz += 1 + member_len + 1;\n            found = 1;\n            if ((buffer = OPENSSL_malloc(buffer_sz)) != NULL) {\n                OPENSSL_strlcpy(buffer, this_ldi->ldinfo_filename, buffer_sz);\n                if (member_len > 0) {\n                    /*\n                     * Need to respect a possible member name and not just\n                     * returning the path name in this case. See docs:\n                     * sys/ldr.h, loadquery() and dlopen()/RTLD_MEMBER.\n                     */\n                    OPENSSL_strlcat(buffer, \"(\", buffer_sz);\n                    OPENSSL_strlcat(buffer, member, buffer_sz);\n                    OPENSSL_strlcat(buffer, \")\", buffer_sz);\n                }\n                dl->dli_fname = buffer;\n            } else {\n                errno = ENOMEM;\n            }\n        } else {\n            next_ldi = (struct ld_info *)((uintptr_t)this_ldi +\n                                          this_ldi->ldinfo_next);\n        }\n    } while (this_ldi->ldinfo_next && !found);\n    OPENSSL_free((void *)ldinfos);\n    return (found && dl->dli_fname != NULL);\n}\n# endif                         /* _AIX */\n\nstatic int dlfcn_pathbyaddr(void *addr, char *path, int sz)\n{\n# ifdef HAVE_DLINFO\n    Dl_info dli;\n    int len;\n\n    if (addr == NULL) {\n        union {\n            int (*f) (void *, char *, int);\n            void *p;\n        } t = {\n            dlfcn_pathbyaddr\n        };\n        addr = t.p;\n    }\n\n    if (dladdr(addr, &dli)) {\n        len = (int)strlen(dli.dli_fname);\n        if (sz <= 0) {\n#  ifdef _AIX\n            OPENSSL_free((void *)dli.dli_fname);\n#  endif\n            return len + 1;\n        }\n        if (len >= sz)\n            len = sz - 1;\n        memcpy(path, dli.dli_fname, len);\n        path[len++] = 0;\n#  ifdef _AIX\n        OPENSSL_free((void *)dli.dli_fname);\n#  endif\n        return len;\n    }\n\n    ERR_add_error_data(2, \"dlfcn_pathbyaddr(): \", dlerror());\n# endif\n    return -1;\n}\n\nstatic void *dlfcn_globallookup(const char *name)\n{\n    void *ret = NULL, *handle = dlopen(NULL, RTLD_LAZY);\n\n    if (handle) {\n        ret = dlsym(handle, name);\n        dlclose(handle);\n    }\n\n    return ret;\n}\n#endif                          /* DSO_DLFCN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/CryptoPkg/Library/OpensslLib/openssl/test/shlibloadtest.c": "/*\n * Copyright 2016-2019 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <openssl/opensslv.h>\n#include <openssl/ssl.h>\n#include <openssl/ossl_typ.h>\n#include \"internal/dso_conf.h\"\n\ntypedef void DSO;\n\ntypedef const SSL_METHOD * (*TLS_method_t)(void);\ntypedef SSL_CTX * (*SSL_CTX_new_t)(const SSL_METHOD *meth);\ntypedef void (*SSL_CTX_free_t)(SSL_CTX *);\ntypedef int (*OPENSSL_init_crypto_t)(uint64_t, void *);\ntypedef int (*OPENSSL_atexit_t)(void (*handler)(void));\ntypedef unsigned long (*ERR_get_error_t)(void);\ntypedef unsigned long (*OpenSSL_version_num_t)(void);\ntypedef DSO * (*DSO_dsobyaddr_t)(void (*addr)(void), int flags);\ntypedef int (*DSO_free_t)(DSO *dso);\n\ntypedef enum test_types_en {\n    CRYPTO_FIRST,\n    SSL_FIRST,\n    JUST_CRYPTO,\n    DSO_REFTEST,\n    NO_ATEXIT\n} TEST_TYPE;\n\nstatic TEST_TYPE test_type;\nstatic const char *path_crypto;\nstatic const char *path_ssl;\nstatic const char *path_atexit;\n\n#ifdef DSO_DLFCN\n\n# include <dlfcn.h>\n\n# define SHLIB_INIT NULL\n\ntypedef void *SHLIB;\ntypedef void *SHLIB_SYM;\n\nstatic int shlib_load(const char *filename, SHLIB *lib)\n{\n    int dl_flags = (RTLD_GLOBAL|RTLD_LAZY);\n#ifdef _AIX\n    if (filename[strlen(filename) - 1] == ')')\n        dl_flags |= RTLD_MEMBER;\n#endif\n    *lib = dlopen(filename, dl_flags);\n    return *lib == NULL ? 0 : 1;\n}\n\nstatic int shlib_sym(SHLIB lib, const char *symname, SHLIB_SYM *sym)\n{\n    *sym = dlsym(lib, symname);\n    return *sym != NULL;\n}\n\nstatic int shlib_close(SHLIB lib)\n{\n    return dlclose(lib) != 0 ? 0 : 1;\n}\n#endif\n\n#ifdef DSO_WIN32\n\n# include <windows.h>\n\n# define SHLIB_INIT 0\n\ntypedef HINSTANCE SHLIB;\ntypedef void *SHLIB_SYM;\n\nstatic int shlib_load(const char *filename, SHLIB *lib)\n{\n    *lib = LoadLibraryA(filename);\n    return *lib == NULL ? 0 : 1;\n}\n\nstatic int shlib_sym(SHLIB lib, const char *symname, SHLIB_SYM *sym)\n{\n    *sym = (SHLIB_SYM)GetProcAddress(lib, symname);\n    return *sym != NULL;\n}\n\nstatic int shlib_close(SHLIB lib)\n{\n    return FreeLibrary(lib) == 0 ? 0 : 1;\n}\n#endif\n\n\n#if defined(DSO_DLFCN) || defined(DSO_WIN32)\n\nstatic int atexit_handler_done = 0;\n\nstatic void atexit_handler(void)\n{\n    FILE *atexit_file = fopen(path_atexit, \"w\");\n\n    if (atexit_file == NULL)\n        return;\n\n    fprintf(atexit_file, \"atexit() run\\n\");\n    fclose(atexit_file);\n    atexit_handler_done++;\n}\n\nstatic int test_lib(void)\n{\n    SHLIB ssllib = SHLIB_INIT;\n    SHLIB cryptolib = SHLIB_INIT;\n    SSL_CTX *ctx;\n    union {\n        void (*func)(void);\n        SHLIB_SYM sym;\n    } symbols[3];\n    TLS_method_t myTLS_method;\n    SSL_CTX_new_t mySSL_CTX_new;\n    SSL_CTX_free_t mySSL_CTX_free;\n    ERR_get_error_t myERR_get_error;\n    OpenSSL_version_num_t myOpenSSL_version_num;\n    OPENSSL_atexit_t myOPENSSL_atexit;\n    int result = 0;\n\n    switch (test_type) {\n    case JUST_CRYPTO:\n    case DSO_REFTEST:\n    case NO_ATEXIT:\n    case CRYPTO_FIRST:\n        if (!shlib_load(path_crypto, &cryptolib)) {\n            fprintf(stderr, \"Failed to load libcrypto\\n\");\n            goto end;\n        }\n        if (test_type != CRYPTO_FIRST)\n            break;\n        /* Fall through */\n\n    case SSL_FIRST:\n        if (!shlib_load(path_ssl, &ssllib)) {\n            fprintf(stderr, \"Failed to load libssl\\n\");\n            goto end;\n        }\n        if (test_type != SSL_FIRST)\n            break;\n        if (!shlib_load(path_crypto, &cryptolib)) {\n            fprintf(stderr, \"Failed to load libcrypto\\n\");\n            goto end;\n        }\n        break;\n    }\n\n    if (test_type == NO_ATEXIT) {\n        OPENSSL_init_crypto_t myOPENSSL_init_crypto;\n\n        if (!shlib_sym(cryptolib, \"OPENSSL_init_crypto\", &symbols[0].sym)) {\n            fprintf(stderr, \"Failed to load OPENSSL_init_crypto symbol\\n\");\n            goto end;\n        }\n        myOPENSSL_init_crypto = (OPENSSL_init_crypto_t)symbols[0].func;\n        if (!myOPENSSL_init_crypto(OPENSSL_INIT_NO_ATEXIT, NULL)) {\n            fprintf(stderr, \"Failed to initialise libcrypto\\n\");\n            goto end;\n        }\n    }\n\n    if (test_type != JUST_CRYPTO\n            && test_type != DSO_REFTEST\n            && test_type != NO_ATEXIT) {\n        if (!shlib_sym(ssllib, \"TLS_method\", &symbols[0].sym)\n                || !shlib_sym(ssllib, \"SSL_CTX_new\", &symbols[1].sym)\n                || !shlib_sym(ssllib, \"SSL_CTX_free\", &symbols[2].sym)) {\n            fprintf(stderr, \"Failed to load libssl symbols\\n\");\n            goto end;\n        }\n        myTLS_method = (TLS_method_t)symbols[0].func;\n        mySSL_CTX_new = (SSL_CTX_new_t)symbols[1].func;\n        mySSL_CTX_free = (SSL_CTX_free_t)symbols[2].func;\n        ctx = mySSL_CTX_new(myTLS_method());\n        if (ctx == NULL) {\n            fprintf(stderr, \"Failed to create SSL_CTX\\n\");\n            goto end;\n        }\n        mySSL_CTX_free(ctx);\n    }\n\n    if (!shlib_sym(cryptolib, \"ERR_get_error\", &symbols[0].sym)\n           || !shlib_sym(cryptolib, \"OpenSSL_version_num\", &symbols[1].sym)\n           || !shlib_sym(cryptolib, \"OPENSSL_atexit\", &symbols[2].sym)) {\n        fprintf(stderr, \"Failed to load libcrypto symbols\\n\");\n        goto end;\n    }\n    myERR_get_error = (ERR_get_error_t)symbols[0].func;\n    if (myERR_get_error() != 0) {\n        fprintf(stderr, \"Unexpected ERR_get_error() response\\n\");\n        goto end;\n    }\n\n    myOpenSSL_version_num = (OpenSSL_version_num_t)symbols[1].func;\n    if (myOpenSSL_version_num()  != OPENSSL_VERSION_NUMBER) {\n        fprintf(stderr, \"Invalid library version number\\n\");\n        goto end;\n    }\n\n    myOPENSSL_atexit = (OPENSSL_atexit_t)symbols[2].func;\n    if (!myOPENSSL_atexit(atexit_handler)) {\n        fprintf(stderr, \"Failed to register atexit handler\\n\");\n        goto end;\n    }\n\n    if (test_type == DSO_REFTEST) {\n# ifdef DSO_DLFCN\n        DSO_dsobyaddr_t myDSO_dsobyaddr;\n        DSO_free_t myDSO_free;\n\n        /*\n         * This is resembling the code used in ossl_init_base() and\n         * OPENSSL_atexit() to block unloading the library after dlclose().\n         * We are not testing this on Windows, because it is done there in a\n         * completely different way. Especially as a call to DSO_dsobyaddr()\n         * will always return an error, because DSO_pathbyaddr() is not\n         * implemented there.\n         */\n        if (!shlib_sym(cryptolib, \"DSO_dsobyaddr\", &symbols[0].sym)\n                || !shlib_sym(cryptolib, \"DSO_free\", &symbols[1].sym)) {\n            fprintf(stderr, \"Unable to load DSO symbols\\n\");\n            goto end;\n        }\n\n        myDSO_dsobyaddr = (DSO_dsobyaddr_t)symbols[0].func;\n        myDSO_free = (DSO_free_t)symbols[1].func;\n\n        {\n            DSO *hndl;\n            /* use known symbol from crypto module */\n            hndl = myDSO_dsobyaddr((void (*)(void))myERR_get_error, 0);\n            if (hndl == NULL) {\n                fprintf(stderr, \"DSO_dsobyaddr() failed\\n\");\n                goto end;\n            }\n            myDSO_free(hndl);\n        }\n# endif /* DSO_DLFCN */\n    }\n\n    if (!shlib_close(cryptolib)) {\n        fprintf(stderr, \"Failed to close libcrypto\\n\");\n        goto end;\n    }\n\n    if (test_type == CRYPTO_FIRST || test_type == SSL_FIRST) {\n        if (!shlib_close(ssllib)) {\n            fprintf(stderr, \"Failed to close libssl\\n\");\n            goto end;\n        }\n    }\n\n# if defined(OPENSSL_NO_PINSHARED) \\\n    && defined(__GLIBC__) \\\n    && defined(__GLIBC_PREREQ) \\\n    && defined(OPENSSL_SYS_LINUX)\n#  if __GLIBC_PREREQ(2, 3)\n    /*\n     * If we didn't pin the so then we are hopefully on a platform that supports\n     * running atexit() on so unload. If not we might crash. We know this is\n     * true on linux since glibc 2.2.3\n     */\n    if (test_type != NO_ATEXIT && atexit_handler_done != 1) {\n        fprintf(stderr, \"atexit() handler did not run\\n\");\n        goto end;\n    }\n#  endif\n# endif\n\n    result = 1;\nend:\n    return result;\n}\n#endif\n\n\n/*\n * shlibloadtest should not use the normal test framework because we don't want\n * it to link against libcrypto (which the framework uses). The point of the\n * test is to check dynamic loading and unloading of libcrypto/libssl.\n */\nint main(int argc, char *argv[])\n{\n    const char *p;\n\n    if (argc != 5) {\n        fprintf(stderr, \"Incorrect number of arguments\\n\");\n        return 1;\n    }\n\n    p = argv[1];\n\n    if (strcmp(p, \"-crypto_first\") == 0) {\n        test_type = CRYPTO_FIRST;\n    } else if (strcmp(p, \"-ssl_first\") == 0) {\n        test_type = SSL_FIRST;\n    } else if (strcmp(p, \"-just_crypto\") == 0) {\n        test_type = JUST_CRYPTO;\n    } else if (strcmp(p, \"-dso_ref\") == 0) {\n        test_type = DSO_REFTEST;\n    } else if (strcmp(p, \"-no_atexit\") == 0) {\n        test_type = NO_ATEXIT;\n    } else {\n        fprintf(stderr, \"Unrecognised argument\\n\");\n        return 1;\n    }\n    path_crypto = argv[2];\n    path_ssl = argv[3];\n    path_atexit = argv[4];\n    if (path_crypto == NULL || path_ssl == NULL) {\n        fprintf(stderr, \"Invalid libcrypto/libssl path\\n\");\n        return 1;\n    }\n\n#if defined(DSO_DLFCN) || defined(DSO_WIN32)\n    if (!test_lib())\n        return 1;\n#endif\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/openbios/arch/unix/plugins.c": "/* tag: plugin interface for openbios forth kernel\n *\n * Copyright (C) 2003, 2004 Stefan Reinauer\n *\n * See the file \"COPYING\" for further information about\n * the copyright and warranty status of this work.\n */\n\n#include \"sysinclude.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dlfcn.h>\n\n#include \"unix/plugins.h\"\n\nunsigned char *plugindir = \"/usr/share/OpenBIOS/plugins\";\n#define PLUGINDIR  plugindir\n#define PATHSIZE   256\n\n#define CONFIG_DEBUG_PLUGINS\n\ntypedef struct iorange iorange_t;\nstruct iorange {\n\tconst char *name;\n\tunsigned int start;\n\tunsigned int end;\n\tio_ops_t *ops;\n\tiorange_t *next;\n};\n\nstatic iorange_t *ioranges = NULL;\n\ntypedef struct plugin plugin_t;\nstruct plugin {\n\tconst char *name;\n\tplugin_t *next;\n};\n\nstatic plugin_t *plugins = NULL;\n\nio_ops_t *find_iorange(u32 reg)\n{\n\tiorange_t *range = ioranges;\n\twhile (range) {\n\t\tif (range->start <= reg && range->end >= reg)\n\t\t\treturn range->ops;\n\t\trange = range->next;\n\t}\n\treturn NULL;\n}\n\nint register_iorange(const char *name, io_ops_t * ops, unsigned int rstart,\n\t\t     unsigned int rend)\n{\n\tiorange_t *newrange;\n\n\t/* intersection check */\n\tnewrange = ioranges;\n\twhile (newrange) {\n\t\tint fail = 0;\n\t\t/* new section swallows old section */\n\t\tif (newrange->start >= rstart && newrange->end <= rend)\n\t\t\tfail = -1;\n\t\t/* new section start or end point are within range */\n\t\tif (newrange->start <= rstart && newrange->end >= rstart)\n\t\t\tfail = -1;\n\t\tif (newrange->start <= rend && newrange->end >= rend)\n\t\t\tfail = -1;\n\t\tif (fail) {\n\t\t\tprintf(\"Error: overlapping IO regions: %s and %s\\n\",\n\t\t\t\tnewrange->name, name);\n\t\t\treturn -1;\n\t\t}\n\t\tnewrange = newrange->next;\n\t}\n\n\tnewrange = malloc(sizeof(iorange_t));\n\n\tnewrange->name = name;\n\tnewrange->ops = ops;\n\tnewrange->start = rstart;\n\tnewrange->end = rend;\n\tnewrange->next = ioranges;\n\n\tioranges = newrange;\n\n\treturn 0;\n}\n\nint is_loaded(const char *plugin_name)\n{\n\tplugin_t *p = plugins;\n\twhile (p) {\n\t\tif (!strcmp(plugin_name, p->name))\n\t\t\treturn -1;\n\t\tp = p->next;\n\t}\n\treturn 0;\n}\n\nint load_plugin(const char *plugin_name)\n{\n\tvoid *handle;\n\tchar *error;\n\tchar path[PATHSIZE];\n\n\tint (*init_plugin) (void);\n\tchar **deps;\n\tchar **plugin_info;\n\tplugin_t *p;\n\n\tif (is_loaded(plugin_name)) {\n\t\tprintf(\"Plugin %s already loaded.\\n\", plugin_name);\n\t\treturn 0;\n\t}\n\n\tstrncpy(path, PLUGINDIR, PATHSIZE);\n\tstrncat(path, \"/plugin_\", PATHSIZE);\n\tstrncat(path, plugin_name, PATHSIZE);\n\tstrncat(path, \".so\", PATHSIZE);\n\n#if DEBUG\n\tprintf(\"Opening plugin %s\\n\", path);\n#endif\n\n\thandle = dlopen(path, RTLD_LAZY | RTLD_GLOBAL);\n\tif (!handle) {\n\t\terror = dlerror();\n\t\tprintf(\"Error: Could not open plugin \\\"%s\\\": %s\\n\",\n\t\t       plugin_name, error);\n\t\texit(1);\n\t}\n#ifdef CONFIG_DEBUG_PLUGINS\n\tplugin_info = dlsym(handle, \"plugin_author\");\n\tif ((error = dlerror()) == NULL)\n\t\tprintf(\"Plugin %s author:  %s\\n\", plugin_name, *plugin_info);\n\tplugin_info = dlsym(handle, \"plugin_license\");\n\tif ((error = dlerror()) == NULL)\n\t\tprintf(\"Plugin %s license: %s\\n\", plugin_name, *plugin_info);\n\tplugin_info = dlsym(handle, \"plugin_description\");\n\tif ((error = dlerror()) == NULL)\n\t\tprintf(\"Plugin %s descr.: %s\\n\", plugin_name, *plugin_info);\n#endif\n\tp = malloc(sizeof(plugin_t));\n\tp->next = plugins;\n\tp->name = plugin_name;\n\tplugins = p;\n\n\tdeps = dlsym(handle, \"plugin_deps\");\n\tif ((error = dlerror()) != NULL)\n\t\tdeps = NULL;\n\n\n\tstrncpy(path, \"plugin_\", PATHSIZE);\n\tstrncat(path, plugin_name, PATHSIZE);\n\tstrncat(path, \"_init\", PATHSIZE);\n\n\tinit_plugin = dlsym(handle, path);\n\tif ((error = dlerror()) != NULL) {\n\t\tprintf(\"error: %s\\n\", error);\n\t\texit(1);\n\t}\n\n\tif (deps) {\n\t\tint i = 0;\n\t\tchar *walk = deps[0];\n#ifdef CONFIG_DEBUG_PLUGINS\n\t\tprintf(\"\\nPlugin %s dependencies:\", plugin_name);\n#endif\n\t\twhile (walk) {\n\t\t\tprintf(\" %s\", walk);\n\t\t\tif (!is_loaded(walk)) {\n#ifdef CONFIG_DEBUG_PLUGINS\n\t\t\t\tprintf(\"(loading)\\n\");\n#endif\n\t\t\t\tload_plugin(walk);\n\t\t\t}\n#ifdef CONFIG_DEBUG_PLUGINS\n\t\t\telse {\n\t\t\t\tprintf(\"(loaded)\");\n\t\t\t}\n#endif\n\t\t\twalk = deps[++i];\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n#if DEBUG\n\tprintf(\"Initializing module:\\n\");\n#endif\n\n\treturn init_plugin();\n\n\t// We don't dlclose the handle here since\n\t// we want to keep our symbols for later use.\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/openbios/arch/unix/plugins/loader.c": "/* tag: openbios plugin loader\n *\n * Copyright (C) 2003 Stefan Reinauer\n *\n * See the file \"COPYING\" for further information about\n * the copyright and warranty status of this work.\n */\n\n/* This is a simple plugin loader. OpenBIOS duplicates some\n * of this code in kernel/arch/unix/plugins.c. This code is\n * here for reference and simple testing.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <unistd.h>\t\t// sleep\n\n#include \"unix/plugins.h\"\n\n#define PLUGINDIR  \"/usr/share/OpenBIOS/plugins\"\n#define PATHSIZE   256\n\n#define DEBUG_PLUGINS\n\ntypedef struct iorange iorange_t;\nstruct iorange {\n\tconst char *name;\n\tunsigned int start;\n\tunsigned int end;\n\tio_ops_t *ops;\n\tiorange_t *next;\n};\n\niorange_t *ioranges = NULL;\n\ntypedef struct plugin plugin_t;\nstruct plugin {\n\tconst char *name;\n\tplugin_t *next;\n};\n\nplugin_t *plugins = NULL;\n\nint register_iorange(const char *name, io_ops_t * ops, unsigned int rstart,\n\t\t     unsigned int rend)\n{\n\tiorange_t *newrange;\n\n\t/* intersection check */\n\tnewrange = ioranges;\n\twhile (newrange) {\n\t\tint fail = 0;\n\t\t/* new section swallows old section */\n\t\tif (newrange->start >= rstart && newrange->end <= rend)\n\t\t\tfail = -1;\n\t\t/* new section start or end point are within range */\n\t\tif (newrange->start <= rstart && newrange->end >= rstart)\n\t\t\tfail = -1;\n\t\tif (newrange->start <= rend && newrange->end >= rend)\n\t\t\tfail = -1;\n\t\tif (fail) {\n\t\t\tprintf(\"Error: overlapping IO regions: %s and %s\\n\",\n\t\t\t     newrange->name, name);\n\t\t\treturn -1;\n\t\t}\n\t\tnewrange = newrange->next;\n\t}\n\n\tnewrange = malloc(sizeof(iorange_t));\n\n\tnewrange->name = name;\n\tnewrange->ops = ops;\n\tnewrange->start = rstart;\n\tnewrange->end = rend;\n\tnewrange->next = ioranges;\n\n\tioranges = newrange;\n\n\treturn 0;\n}\n\nint is_loaded(const char *plugin_name)\n{\n\tplugin_t *p = plugins;\n\twhile (p) {\n\t\tif (!strcmp(plugin_name, p->name))\n\t\t\treturn -1;\n\t\tp = p->next;\n\t}\n\treturn 0;\n}\n\nint load_plugin(const char *plugin_name)\n{\n\tvoid *handle;\n\tchar *error;\n\tchar path[PATHSIZE];\n\n\tint (*init_plugin) (void);\n\tchar **deps;\n\tchar **plugin_info;\n\tplugin_t *p;\n\n\tif (is_loaded(plugin_name)) {\n\t\tprintf(\"Plugin %s already loaded.\\n\", plugin_name);\n\t\treturn 0;\n\t}\n\n\tstrncpy(path, PLUGINDIR, PATHSIZE);\n\tstrncat(path, \"/plugin_\", PATHSIZE);\n\tstrncat(path, plugin_name, PATHSIZE);\n\tstrncat(path, \".so\", PATHSIZE);\n\n#if DEBUG\n\tprintf(\"Opening plugin %s\\n\", path);\n#endif\n\n\thandle = dlopen(path, RTLD_LAZY | RTLD_GLOBAL);\n\tif (!handle) {\n\t\terror = dlerror();\n\t\tprintf(\"Error: Could not open plugin \\\"%s\\\": %s\\n\",\n\t\t       plugin_name, error);\n\t\texit(1);\n\t}\n#ifdef DEBUG_PLUGINS\n\tplugin_info = dlsym(handle, \"plugin_author\");\n\tif ((error = dlerror()) == NULL)\n\t\tprintf(\"Plugin %s author:  %s\\n\", plugin_name, *plugin_info);\n\tplugin_info = dlsym(handle, \"plugin_license\");\n\tif ((error = dlerror()) == NULL)\n\t\tprintf(\"Plugin %s license: %s\\n\", plugin_name, *plugin_info);\n\tplugin_info = dlsym(handle, \"plugin_description\");\n\tif ((error = dlerror()) == NULL)\n\t\tprintf(\"Plugin %s descr.: %s\\n\", plugin_name, *plugin_info);\n#endif\n\tp = malloc(sizeof(plugin_t));\n\tp->next = plugins;\n\tp->name = plugin_name;\n\tplugins = p;\n\n\tdeps = dlsym(handle, \"plugin_deps\");\n\tif ((error = dlerror()) != NULL)\n\t\tdeps = NULL;\n\n\n\tstrncpy(path, \"plugin_\", PATHSIZE);\n\tstrncat(path, plugin_name, PATHSIZE);\n\tstrncat(path, \"_init\", PATHSIZE);\n\n\tinit_plugin = dlsym(handle, path);\n\tif ((error = dlerror()) != NULL) {\n\t\tprintf(\"error: %s\\n\", error);\n\t\texit(1);\n\t}\n\n\tif (deps) {\n\t\tint i = 0;\n\t\tchar *walk = deps[0];\n#ifdef DEBUG_PLUGINS\n\t\tprintf(\"\\nPlugin %s dependencies:\", plugin_name);\n#endif\n\t\twhile (walk) {\n\t\t\tprintf(\" %s\", walk);\n\t\t\tif (!is_loaded(walk)) {\n#ifdef DEBUG_PLUGINS\n\t\t\t\tprintf(\"(loading)\\n\");\n#endif\n\t\t\t\tload_plugin(walk);\n\t\t\t}\n#ifdef DEBUG_PLUGINS\n\t\t\telse {\n\t\t\t\tprintf(\"(loaded)\");\n\t\t\t}\n#endif\n\t\t\twalk = deps[++i];\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n#if DEBUG\n\tprintf(\"Initializing module:\\n\");\n#endif\n\n\treturn init_plugin();\n\n\t// We don't dlclose the handle here since\n\t// we want to keep our symbols for later use.\n}\n\nint main(void)\n{\n\tiorange_t *r;\n\n\t// load_plugin(\"kbd\");\n\t// load_plugin(\"pci\");\n\tload_plugin(\"qt\");\n\n\tprintf(\"\\nRegistered IO Ranges:\\n\");\n\tr = ioranges;\n\twhile (r) {\n\t\tprintf(\"  %s: %x-%x\\n\", r->name, r->start, r->end);\n\t\tr = r->next;\n\t}\n\n\tsleep(10);\n\treturn 0;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/capstone/bindings/vb6/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/capstone/bindings/vb6/CX86Operand.cls",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/capstone/docs/BHUSA2014-capstone.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/SRAT.cphp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/DSDT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/APIC.cphp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/APIC.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/SRAT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/SRAT.mmio64",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/DSDT.numamem",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/DSDT.memhp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/DSDT.bridge",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/SSDT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/NFIT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/SRAT.memhp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/DSDT.ipmibt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/DSDT.cphp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/DSDT.mmio64",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/q35/SRAT.numamem",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/pc/SRAT.cphp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/pc/DSDT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/pc/APIC.cphp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/pc/APIC.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/pc/SRAT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/pc/DSDT.numamem",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/pc/DSDT.memhp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/pc/DSDT.bridge",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/pc/SSDT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/pc/NFIT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/pc/SRAT.memhp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/pc/DSDT.cphp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/pc/SRAT.numamem",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/acpi/pc/DSDT.ipmikcs",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/uefi-boot-images/bios-tables-test.aarch64.iso.qcow2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/uefi-boot-images/bios-tables-test.arm.iso.qcow2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/uefi-boot-images/bios-tables-test.i386.iso.qcow2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/data/uefi-boot-images/bios-tables-test.x86_64.iso.qcow2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/qemu-iotests/sample_images/afl9.vmdk.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/qemu-iotests/sample_images/iotest-version3.vmdk.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/qemu-iotests/sample_images/iotest-dirtylog-10G-4M.vhdx.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/qemu-iotests/sample_images/parallels-v1.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/qemu-iotests/sample_images/empty.bochs.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/qemu-iotests/sample_images/afl5.img.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/qemu-iotests/sample_images/test-disk2vhd.vhdx.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/qemu-iotests/sample_images/parallels-v2.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/qemu-iotests/sample_images/iotest-dynamic-1G.vhdx.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/qemu-iotests/sample_images/virtualpc-dynamic.vhd.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/qemu-iotests/sample_images/hyperv2012r2-dynamic.vhd.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/qemu-iotests/sample_images/simple-pattern.cloop.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/qemu-iotests/sample_images/grub_mbr.raw.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/qemu-iotests/sample_images/d2v-zerofilled.vhd.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/tests/qemu-iotests/sample_images/simple-dmg.dmg.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/qga/vss-win32/qga-vss.tlb",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/vgabios-ramfb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/edk2-x86_64-secure-code.fd.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/ppc_rom.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/slof.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/bamboo.dtb",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/edk2-x86_64-code.fd.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/pxe-ne2k_pci.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/edk2-aarch64-code.fd.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/edk2-arm-vars.fd.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/pxe-e1000.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/QEMU,cgthree.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/efi-rtl8139.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/efi-pcnet.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/pxe-rtl8139.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/bios.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/linuxboot_dma.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/kvmvapic.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/edk2-i386-secure-code.fd.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/bios-256k.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/vgabios-cirrus.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/vgabios-virtio.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/QEMU,tcx.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/edk2-i386-code.fd.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/spapr-rtas.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/vgabios-bochs-display.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/opensbi-riscv64-sifive_u-fw_jump.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/petalogix-ml605.dtb",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/s390-netboot.img",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/sgabios.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/pxe-eepro100.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/s390-ccw.img",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/qemu-nsis.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/vgabios.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/efi-vmxnet3.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/multiboot.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/efi-e1000.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/opensbi-riscv32-virt-fw_jump.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/skiboot.lid",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/efi-ne2k_pci.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/efi-e1000e.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/edk2-i386-vars.fd.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/hppa-firmware.img",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/linuxboot.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/pvh.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/vgabios-vmware.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/vgabios-ati.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/vgabios-qxl.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/qemu-nsis.ico",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/petalogix-s3adsp1800.dtb",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/efi-eepro100.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/edk2-arm-code.fd.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/pxe-virtio.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/opensbi-riscv64-virt-fw_jump.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/vgabios-stdvga.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/efi-virtio.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/u-boot-sam460-20100605.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/canyonlands.dtb",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/qemu_vga.ndrv",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/u-boot.e500",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/pc-bios/pxe-pcnet.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/ui/icons/qemu_32x32.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/ui/icons/qemu_16x16.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/ui/icons/qemu_128x128.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/ui/icons/qemu_24x24.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/ui/icons/qemu_64x64.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/ui/icons/qemu_32x32.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/ui/icons/qemu_512x512.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/ui/icons/qemu_48x48.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/ui/icons/qemu_256x256.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/qemu-palcode/osf.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/qemu-palcode/uart.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/qemu-palcode/uart.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/CHANGELOG-before-U-Boot-1.1.5",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/fs/fdos/dev.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/fs/fdos/fs.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/fs/fdos/fdos.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/fs/fdos/vfat.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/fs/fdos/fat.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/fs/fdos/dos.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/fs/fdos/subdir.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/fs/fdos/fdos.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/common/cmd_fdos.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/sparc/cpu/leon3/usb_uhci.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/include/asm/arch-s3c24x0/s3c2400.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/include/asm/arch-s3c24x0/s3c2410.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/include/asm/arch-s3c24x0/s3c24x0.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm946es/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm1136/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/lh7a40x/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm926ejs/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm926ejs/omap/reset.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm926ejs/versatile/reset.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm925t/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm920t/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/ixp/npe/include/IxOsal.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/ixp/npe/include/IxAtmdAccCtrl.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm_intcm/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/sa1100/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm720t/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/mips/include/asm/inca-ip.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/powerpc/cpu/mpc8260/cpu_init.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/lib/pci_type1.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/lib/bios.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/lib/pci.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/lib/video_bios.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/lib/interrupts.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/lib/pcat_interrupts.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/lib/realmode_switch.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/lib/bios_setup.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/lib/realmode.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/lib/video.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/lib/zimage.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/lib/pcat_timer.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/lib/timer.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/lib/bios.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/lib/bios_pci.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/realmode.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/ibmpc.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/zimage.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/pci.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/processor.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/u-boot-i386.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/i8259.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/interrupt.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/i8254.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/ic/pci.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/ic/sc520.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/config.mk",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/start16.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/interrupts.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/cpu.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/resetvec.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/sc520/sc520_pci.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/sc520/sc520_ssi.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/sc520/sc520_timer.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/sc520/sc520_asm.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/sc520/sc520.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/board/ACube/common/catweasel.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/board/ACube/common/cmd_boota.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/board/ACube/common/logo_sam460.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/board/ACube/common/cw4.firmware",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/board/ACube/common/logo_acube.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/board/ACube/bios_emulator/bios.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/lib/lzma/history.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/include/fdc.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/include/video_font.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/include/ali512x.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/include/sed13806.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/include/sm501.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/include/linux/mtd/mtd.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/include/configs/sc3.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/include/configs/sc520_spunk.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/include/configs/sc520_cdp.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/include/configs/sc520_spunk_rel.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/nand_spl/board/amcc/bamboo/sdram.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/drivers/video/ct69000.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/drivers/video/sed13806.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/drivers/video/sm501.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/drivers/rtc/s3c24x0_rtc.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/drivers/block/sata_sil3114.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/drivers/block/sata_sil3114.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/drivers/misc/ali512x.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/drivers/pcmcia/ti_pci1410a.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/tools/logos/ronetix.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/tools/logos/linux_logo_ttcontrol_palfin.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/tools/logos/atmel.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/tools/logos/denx.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/tools/logos/esd.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/tools/logos/linux_logo_ttcontrol.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/tools/easylogo/linux_blackfin.tga",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/tools/easylogo/linux_logo.tga",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/doc/README.m5373evb",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/doc/README.mpc7448hpc2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot-sam460ex/doc/README.RPXClassic",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/ipxe/src/drivers/infiniband/MT25408_PRM.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/ipxe/src/drivers/bus/eisa.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/ipxe/src/drivers/net/smc9000.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/ipxe/src/drivers/net/smc9000.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/UefiCpuPkg/ResetVector/Vtf0/Bin/ResetVector.x64.port80.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/UefiCpuPkg/ResetVector/Vtf0/Bin/ResetVector.x64.serial.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/UefiCpuPkg/ResetVector/Vtf0/Bin/ResetVector.ia32.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/UefiCpuPkg/ResetVector/Vtf0/Bin/ResetVector.ia32.serial.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/UefiCpuPkg/ResetVector/Vtf0/Bin/ResetVector.x64.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/UefiCpuPkg/ResetVector/Vtf0/Bin/ResetVector.ia32.port80.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/ShellPkg/Application/ShellCTestApp/TestArgv.log",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/BaseTools/Bin/Darwin-i386/Arm/RELEASE_XCODE31/CompilerIntrinsicsLib.lib",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/BaseTools/Bin/Darwin-i386/Arm/RELEASE_XCODE32/CompilerIntrinsicsLib.lib",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/BaseTools/Bin/Darwin-i386/Arm/DEBUG_XCODE31/CompilerIntrinsicsLib.lib",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/BaseTools/Bin/Darwin-i386/Arm/DEBUG_XCODE32/CompilerIntrinsicsLib.lib",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/BaseTools/Source/C/VfrCompile/Pccts/CHANGES_FROM_133.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/BaseTools/Source/C/VfrCompile/Pccts/dlg/DlgPPC.mak",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/BaseTools/Source/C/VfrCompile/Pccts/antlr/antlr.r",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/BaseTools/Source/C/VfrCompile/Pccts/antlr/AntlrPPC.mak",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/BaseTools/Source/C/BrotliCompress/docs/brotli-comparison-study-2015-09-22.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/BaseTools/Source/Python/Rsa2048Sha256Sign/TestSigningPublicKey.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/BaseTools/Source/Python/Pkcs7Sign/TestRoot.cer",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/BaseTools/Source/Python/Eot/LzmaCompressor.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/BaseTools/Source/Python/Eot/EfiCompressor.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/IntelFsp2Pkg/FspSecCore/Vtf0/Bin/ResetVec.ia32.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/IntelFspWrapperPkg/FspWrapperSecCore/Vtf0/Bin/ResetVec.ia32.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/IntelFspPkg/FspSecCore/Vtf0/Bin/ResetVec.ia32.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/IntelFspPkg/Tools/UserManuals/GenCfgOptUserManual.docx",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/IntelFspPkg/Tools/UserManuals/PatchFvUserManual.docx",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/ArmPkg/Drivers/ArmScmiDxe/ArmScmiPerformanceProtocolPrivate.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/ArmPkg/Library/GccLto/liblto-arm.a",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/ArmPkg/Library/GccLto/liblto-aarch64.a",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/CryptoPkg/Library/OpensslLib/openssl/test/shibboleth.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/CryptoPkg/Library/OpensslLib/openssl/test/d2i-tests/bad-cms.der",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/CryptoPkg/Library/OpensslLib/openssl/test/d2i-tests/high_tag.der",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/CryptoPkg/Library/OpensslLib/openssl/test/d2i-tests/intminus1.der",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/CryptoPkg/Library/OpensslLib/openssl/test/d2i-tests/bad_bio.der",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/CryptoPkg/Library/OpensslLib/openssl/test/d2i-tests/bad_cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/CryptoPkg/Library/OpensslLib/openssl/test/d2i-tests/bad_generalname.der",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/CryptoPkg/Library/OpensslLib/openssl/test/d2i-tests/bad-int-padminus1.der",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/CryptoPkg/Library/OpensslLib/openssl/test/recipes/ocsp-response.der",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/MdeModulePkg/Library/BrotliCustomDecompressLib/docs/brotli-comparison-study-2015-09-22.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/MdeModulePkg/Logo/Logo.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/edk2/EmbeddedPkg/Scripts/LauterbachT32/README.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/QemuMacDrivers/builds/qemu_vga_debugosi.ndrv",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/QemuMacDrivers/builds/qemu_vga.ndrv",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/QemuMacDrivers/QemuVGADriver/src/DriverQDCalls.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/QemuMacDrivers/QemuVGADriver/src/DriverQDCalls.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/openbios/forth/device/romfont.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/openbios/libopenbios/font_8x8.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/openbios/libopenbios/font_8x16.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/arch/arm/dts/sun4i-a10-inet97fv2.dts",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/include/video_font_data.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/drivers/video/fonts/ankacoder_c75_r.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/drivers/video/fonts/rufscript010.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/drivers/video/fonts/nimbus_sans_l_regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/drivers/video/fonts/cantoraone_regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/gateworks.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/compulab.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/ronetix.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/u-boot_logo.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/intercontrol.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/toradex.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/solidrun.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/siemens.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/linux_logo_ttcontrol_palfin.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/atmel.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/denx.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/microchip.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/wandboard.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/engicam.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/denx-comp.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/esd.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/linux_logo_ttcontrol.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/syteco.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/logos/freescale.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/easylogo/linux_blackfin.tga",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/easylogo/linux_logo.tga",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/tools/binman/test/descriptor.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/doc/chromium/devkeys/kernel.keyblock",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/u-boot/doc/chromium/devkeys/kernel_data_key.vbprivk",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/skiboot/external/gard/test/files/data1.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/skiboot/external/gard/test/files/data-p9.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/skiboot/external/gard/test/files/blank.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/skiboot/external/ffspart/test/files/16-create-blank.out",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/skiboot/external/ffspart/test/files/17-toc.out",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/skiboot/external/ffspart/test/files/03-tiny-pnor.out",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/skiboot/external/ffspart/test/files/04-tiny-pnor2.out",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/skiboot/hdata/test/p81-811.spira",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/skiboot/hdata/test/p8-840-spira.spirah",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/skiboot/hdata/test/p81-811.spira.heap",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/skiboot/hdata/test/op920.wsp.heap",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/skiboot/hdata/test/p8-840-spira.spiras",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/SLOF/FlashingSLOF.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/SLOF/lib/libipmi/libipmi.oco",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/SLOF/clients/takeover/takeover.oco",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/SLOF/board-js2x/rtas/ipmi_oem.oco",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/roms/SLOF/board-js2x/rtas/i2c_bmc.oco",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.1.1-h66bweevahra4wfgfsixswebwqfhc6ya/spack-src/docs/qemu_logo.pdf"
    ],
    "total_files": 38275
}