{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/loader/loader.c": "/*\n * Copyright (C) 2013 Rob Clark <robclark@freedesktop.org>\n * Copyright (C) 2014-2016 Emil Velikov <emil.l.velikov@gmail.com>\n * Copyright (C) 2016 Intel Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * Authors:\n *    Rob Clark <robclark@freedesktop.org>\n */\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/param.h>\n#ifdef MAJOR_IN_MKDEV\n#include <sys/mkdev.h>\n#endif\n#ifdef MAJOR_IN_SYSMACROS\n#include <sys/sysmacros.h>\n#endif\n#include <GL/gl.h>\n#include <GL/internal/dri_interface.h>\n#include \"loader.h\"\n\n#ifdef HAVE_LIBDRM\n#include <xf86drm.h>\n#define MAX_DRM_DEVICES 64\n#ifdef USE_DRICONF\n#include \"util/xmlconfig.h\"\n#include \"util/driconf.h\"\n#endif\n#endif\n\n#include \"util/macros.h\"\n\n#define __IS_LOADER\n#include \"pci_id_driver_map.h\"\n\n/* For systems like Hurd */\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\nstatic void default_logger(int level, const char *fmt, ...)\n{\n   if (level <= _LOADER_WARNING) {\n      va_list args;\n      va_start(args, fmt);\n      vfprintf(stderr, fmt, args);\n      va_end(args);\n   }\n}\n\nstatic loader_logger *log_ = default_logger;\n\nint\nloader_open_device(const char *device_name)\n{\n   int fd;\n#ifdef O_CLOEXEC\n   fd = open(device_name, O_RDWR | O_CLOEXEC);\n   if (fd == -1 && errno == EINVAL)\n#endif\n   {\n      fd = open(device_name, O_RDWR);\n      if (fd != -1)\n         fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n   }\n   if (fd == -1 && errno == EACCES) {\n      log_(_LOADER_WARNING, \"failed to open %s: %s\\n\",\n           device_name, strerror(errno));\n   }\n   return fd;\n}\n\nstatic char *loader_get_kernel_driver_name(int fd)\n{\n#if HAVE_LIBDRM\n   char *driver;\n   drmVersionPtr version = drmGetVersion(fd);\n\n   if (!version) {\n      log_(_LOADER_WARNING, \"failed to get driver name for fd %d\\n\", fd);\n      return NULL;\n   }\n\n   driver = strndup(version->name, version->name_len);\n   log_(driver ? _LOADER_DEBUG : _LOADER_WARNING, \"using driver %s for %d\\n\",\n        driver, fd);\n\n   drmFreeVersion(version);\n   return driver;\n#else\n   return NULL;\n#endif\n}\n\nbool\nis_kernel_i915(int fd)\n{\n   char *kernel_driver = loader_get_kernel_driver_name(fd);\n   bool is_i915 = kernel_driver && strcmp(kernel_driver, \"i915\") == 0;\n\n   free(kernel_driver);\n   return is_i915;\n}\n\n#if defined(HAVE_LIBDRM)\nint\nloader_open_render_node(const char *name)\n{\n   drmDevicePtr devices[MAX_DRM_DEVICES], device;\n   int i, num_devices, fd = -1;\n\n   num_devices = drmGetDevices2(0, devices, MAX_DRM_DEVICES);\n   if (num_devices <= 0)\n      return -ENOENT;\n\n   for (i = 0; i < num_devices; i++) {\n      device = devices[i];\n\n      if ((device->available_nodes & (1 << DRM_NODE_RENDER)) &&\n          (device->bustype == DRM_BUS_PLATFORM)) {\n         drmVersionPtr version;\n\n         fd = loader_open_device(device->nodes[DRM_NODE_RENDER]);\n         if (fd < 0)\n            continue;\n\n         version = drmGetVersion(fd);\n         if (!version) {\n            close(fd);\n            continue;\n         }\n\n         if (strcmp(version->name, name) != 0) {\n            drmFreeVersion(version);\n            close(fd);\n            continue;\n         }\n\n         drmFreeVersion(version);\n         break;\n      }\n   }\n   drmFreeDevices(devices, num_devices);\n\n   if (i == num_devices)\n      return -ENOENT;\n\n   return fd;\n}\n\n#ifdef USE_DRICONF\nstatic const driOptionDescription __driConfigOptionsLoader[] = {\n    DRI_CONF_SECTION_INITIALIZATION\n        DRI_CONF_DEVICE_ID_PATH_TAG()\n        DRI_CONF_DRI_DRIVER()\n    DRI_CONF_SECTION_END\n};\n\nstatic char *loader_get_dri_config_driver(int fd)\n{\n   driOptionCache defaultInitOptions;\n   driOptionCache userInitOptions;\n   char *dri_driver = NULL;\n   char *kernel_driver = loader_get_kernel_driver_name(fd);\n\n   driParseOptionInfo(&defaultInitOptions, __driConfigOptionsLoader,\n                      ARRAY_SIZE(__driConfigOptionsLoader));\n   driParseConfigFiles(&userInitOptions, &defaultInitOptions, 0,\n                       \"loader\", kernel_driver, NULL, 0, NULL, 0);\n   if (driCheckOption(&userInitOptions, \"dri_driver\", DRI_STRING)) {\n      char *opt = driQueryOptionstr(&userInitOptions, \"dri_driver\");\n      /* not an empty string */\n      if (*opt)\n         dri_driver = strdup(opt);\n   }\n   driDestroyOptionCache(&userInitOptions);\n   driDestroyOptionInfo(&defaultInitOptions);\n\n   free(kernel_driver);\n   return dri_driver;\n}\n\nstatic char *loader_get_dri_config_device_id(void)\n{\n   driOptionCache defaultInitOptions;\n   driOptionCache userInitOptions;\n   char *prime = NULL;\n\n   driParseOptionInfo(&defaultInitOptions, __driConfigOptionsLoader,\n                      ARRAY_SIZE(__driConfigOptionsLoader));\n   driParseConfigFiles(&userInitOptions, &defaultInitOptions, 0,\n                       \"loader\", NULL, NULL, 0, NULL, 0);\n   if (driCheckOption(&userInitOptions, \"device_id\", DRI_STRING))\n      prime = strdup(driQueryOptionstr(&userInitOptions, \"device_id\"));\n   driDestroyOptionCache(&userInitOptions);\n   driDestroyOptionInfo(&defaultInitOptions);\n\n   return prime;\n}\n#endif\n\nstatic char *drm_construct_id_path_tag(drmDevicePtr device)\n{\n   char *tag = NULL;\n\n   if (device->bustype == DRM_BUS_PCI) {\n      if (asprintf(&tag, \"pci-%04x_%02x_%02x_%1u\",\n                   device->businfo.pci->domain,\n                   device->businfo.pci->bus,\n                   device->businfo.pci->dev,\n                   device->businfo.pci->func) < 0) {\n         return NULL;\n      }\n   } else if (device->bustype == DRM_BUS_PLATFORM ||\n              device->bustype == DRM_BUS_HOST1X) {\n      char *fullname, *name, *address;\n\n      if (device->bustype == DRM_BUS_PLATFORM)\n         fullname = device->businfo.platform->fullname;\n      else\n         fullname = device->businfo.host1x->fullname;\n\n      name = strrchr(fullname, '/');\n      if (!name)\n         name = strdup(fullname);\n      else\n         name = strdup(name + 1);\n\n      address = strchr(name, '@');\n      if (address) {\n         *address++ = '\\0';\n\n         if (asprintf(&tag, \"platform-%s_%s\", address, name) < 0)\n            tag = NULL;\n      } else {\n         if (asprintf(&tag, \"platform-%s\", name) < 0)\n            tag = NULL;\n      }\n\n      free(name);\n   }\n   return tag;\n}\n\nstatic bool drm_device_matches_tag(drmDevicePtr device, const char *prime_tag)\n{\n   char *tag = drm_construct_id_path_tag(device);\n   int ret;\n\n   if (tag == NULL)\n      return false;\n\n   ret = strcmp(tag, prime_tag);\n\n   free(tag);\n   return ret == 0;\n}\n\nstatic char *drm_get_id_path_tag_for_fd(int fd)\n{\n   drmDevicePtr device;\n   char *tag;\n\n   if (drmGetDevice2(fd, 0, &device) != 0)\n       return NULL;\n\n   tag = drm_construct_id_path_tag(device);\n   drmFreeDevice(&device);\n   return tag;\n}\n\nint loader_get_user_preferred_fd(int default_fd, bool *different_device)\n{\n   const char *dri_prime = getenv(\"DRI_PRIME\");\n   char *default_tag, *prime = NULL;\n   drmDevicePtr devices[MAX_DRM_DEVICES];\n   int i, num_devices, fd = -1;\n\n   if (dri_prime)\n      prime = strdup(dri_prime);\n#ifdef USE_DRICONF\n   else\n      prime = loader_get_dri_config_device_id();\n#endif\n\n   if (prime == NULL) {\n      *different_device = false;\n      return default_fd;\n   }\n\n   default_tag = drm_get_id_path_tag_for_fd(default_fd);\n   if (default_tag == NULL)\n      goto err;\n\n   num_devices = drmGetDevices2(0, devices, MAX_DRM_DEVICES);\n   if (num_devices <= 0)\n      goto err;\n\n   for (i = 0; i < num_devices; i++) {\n      if (!(devices[i]->available_nodes & 1 << DRM_NODE_RENDER))\n         continue;\n\n      /* two formats of DRI_PRIME are supported:\n       * \"1\": choose any other card than the card used by default.\n       * id_path_tag: (for example \"pci-0000_02_00_0\") choose the card\n       * with this id_path_tag.\n       */\n      if (!strcmp(prime,\"1\")) {\n         if (drm_device_matches_tag(devices[i], default_tag))\n            continue;\n      } else {\n         if (!drm_device_matches_tag(devices[i], prime))\n            continue;\n      }\n\n      fd = loader_open_device(devices[i]->nodes[DRM_NODE_RENDER]);\n      break;\n   }\n   drmFreeDevices(devices, num_devices);\n\n   if (i == num_devices)\n      goto err;\n\n   if (fd < 0)\n      goto err;\n\n   close(default_fd);\n\n   *different_device = !!strcmp(default_tag, prime);\n\n   free(default_tag);\n   free(prime);\n   return fd;\n\n err:\n   *different_device = false;\n\n   free(default_tag);\n   free(prime);\n   return default_fd;\n}\n#else\nint\nloader_open_render_node(const char *name)\n{\n   return -1;\n}\n\nint loader_get_user_preferred_fd(int default_fd, bool *different_device)\n{\n   *different_device = false;\n   return default_fd;\n}\n#endif\n\n#if defined(HAVE_LIBDRM)\n\nstatic bool\ndrm_get_pci_id_for_fd(int fd, int *vendor_id, int *chip_id)\n{\n   drmDevicePtr device;\n\n   if (drmGetDevice2(fd, 0, &device) != 0) {\n      log_(_LOADER_WARNING, \"MESA-LOADER: failed to retrieve device information\\n\");\n      return false;\n   }\n\n   if (device->bustype != DRM_BUS_PCI) {\n      drmFreeDevice(&device);\n      log_(_LOADER_DEBUG, \"MESA-LOADER: device is not located on the PCI bus\\n\");\n      return false;\n   }\n\n   *vendor_id = device->deviceinfo.pci->vendor_id;\n   *chip_id = device->deviceinfo.pci->device_id;\n   drmFreeDevice(&device);\n   return true;\n}\n#endif\n\n\nbool\nloader_get_pci_id_for_fd(int fd, int *vendor_id, int *chip_id)\n{\n#if HAVE_LIBDRM\n   return drm_get_pci_id_for_fd(fd, vendor_id, chip_id);\n#endif\n   return false;\n}\n\nchar *\nloader_get_device_name_for_fd(int fd)\n{\n   char *result = NULL;\n\n#if HAVE_LIBDRM\n   result = drmGetDeviceNameFromFd2(fd);\n#endif\n\n   return result;\n}\n\nstatic char *\nloader_get_pci_driver(int fd)\n{\n   int vendor_id, chip_id, i, j;\n   char *driver = NULL;\n\n   if (!loader_get_pci_id_for_fd(fd, &vendor_id, &chip_id))\n      return NULL;\n\n   for (i = 0; i < ARRAY_SIZE(driver_map); i++) {\n      if (vendor_id != driver_map[i].vendor_id)\n         continue;\n\n      if (driver_map[i].predicate && !driver_map[i].predicate(fd))\n         continue;\n\n      if (driver_map[i].num_chips_ids == -1) {\n         driver = strdup(driver_map[i].driver);\n         goto out;\n      }\n\n      for (j = 0; j < driver_map[i].num_chips_ids; j++)\n         if (driver_map[i].chip_ids[j] == chip_id) {\n            driver = strdup(driver_map[i].driver);\n            goto out;\n         }\n   }\n\nout:\n   log_(driver ? _LOADER_DEBUG : _LOADER_WARNING,\n         \"pci id for fd %d: %04x:%04x, driver %s\\n\",\n         fd, vendor_id, chip_id, driver);\n   return driver;\n}\n\nchar *\nloader_get_driver_for_fd(int fd)\n{\n   char *driver;\n\n   /* Allow an environment variable to force choosing a different driver\n    * binary.  If that driver binary can't survive on this FD, that's the\n    * user's problem, but this allows vc4 simulator to run on an i965 host,\n    * and may be useful for some touch testing of i915 on an i965 host.\n    */\n   if (geteuid() == getuid()) {\n      driver = getenv(\"MESA_LOADER_DRIVER_OVERRIDE\");\n      if (driver)\n         return strdup(driver);\n   }\n\n#if defined(HAVE_LIBDRM) && defined(USE_DRICONF)\n   driver = loader_get_dri_config_driver(fd);\n   if (driver)\n      return driver;\n#endif\n\n   driver = loader_get_pci_driver(fd);\n   if (!driver)\n      driver = loader_get_kernel_driver_name(fd);\n\n   return driver;\n}\n\nvoid\nloader_set_logger(loader_logger *logger)\n{\n   log_ = logger;\n}\n\nchar *\nloader_get_extensions_name(const char *driver_name)\n{\n   char *name = NULL;\n\n   if (asprintf(&name, \"%s_%s\", __DRI_DRIVER_GET_EXTENSIONS, driver_name) < 0)\n      return NULL;\n\n   const size_t len = strlen(name);\n   for (size_t i = 0; i < len; i++) {\n      if (name[i] == '-')\n         name[i] = '_';\n   }\n\n   return name;\n}\n\n/**\n * Opens a DRI driver using its driver name, returning the __DRIextension\n * entrypoints.\n *\n * \\param driverName - a name like \"i965\", \"radeon\", \"nouveau\", etc.\n * \\param out_driver - Address where the dlopen() return value will be stored.\n * \\param search_path_vars - NULL-terminated list of env vars that can be used\n * to override the DEFAULT_DRIVER_DIR search path.\n */\nconst struct __DRIextensionRec **\nloader_open_driver(const char *driver_name,\n                   void **out_driver_handle,\n                   const char **search_path_vars)\n{\n   char path[PATH_MAX], *search_paths, *next, *end;\n   char *get_extensions_name;\n   const struct __DRIextensionRec **extensions = NULL;\n   const struct __DRIextensionRec **(*get_extensions)(void);\n\n   search_paths = NULL;\n   if (geteuid() == getuid() && search_path_vars) {\n      for (int i = 0; search_path_vars[i] != NULL; i++) {\n         search_paths = getenv(search_path_vars[i]);\n         if (search_paths)\n            break;\n      }\n   }\n   if (search_paths == NULL)\n      search_paths = DEFAULT_DRIVER_DIR;\n\n   void *driver = NULL;\n   char *dl_error = NULL;\n   end = search_paths + strlen(search_paths);\n   for (char *p = search_paths; p < end; p = next + 1) {\n      int len;\n      next = strchr(p, ':');\n      if (next == NULL)\n         next = end;\n\n      len = next - p;\n#if USE_ELF_TLS\n      snprintf(path, sizeof(path), \"%.*s/tls/%s_dri.so\", len, p, driver_name);\n      driver = dlopen(path, RTLD_NOW | RTLD_GLOBAL);\n#endif\n      if (driver == NULL) {\n         snprintf(path, sizeof(path), \"%.*s/%s_dri.so\", len, p, driver_name);\n         driver = dlopen(path, RTLD_NOW | RTLD_GLOBAL);\n         if (driver == NULL) {\n            dl_error = dlerror();\n            log_(_LOADER_DEBUG, \"MESA-LOADER: failed to open %s: %s\\n\",\n                 path, dl_error);\n         }\n      }\n      /* not need continue to loop all paths once the driver is found */\n      if (driver != NULL)\n         break;\n   }\n\n   if (driver == NULL) {\n      log_(_LOADER_WARNING, \"MESA-LOADER: failed to open %s: %s (search paths %s)\\n\",\n           driver_name, dl_error, search_paths);\n      *out_driver_handle = NULL;\n      return NULL;\n   }\n\n   log_(_LOADER_DEBUG, \"MESA-LOADER: dlopen(%s)\\n\", path);\n\n   get_extensions_name = loader_get_extensions_name(driver_name);\n   if (get_extensions_name) {\n      get_extensions = dlsym(driver, get_extensions_name);\n      if (get_extensions) {\n         extensions = get_extensions();\n      } else {\n         log_(_LOADER_DEBUG, \"MESA-LOADER: driver does not expose %s(): %s\\n\",\n              get_extensions_name, dlerror());\n      }\n      free(get_extensions_name);\n   }\n\n   if (!extensions)\n      extensions = dlsym(driver, __DRI_DRIVER_EXTENSIONS);\n   if (extensions == NULL) {\n      log_(_LOADER_WARNING,\n           \"MESA-LOADER: driver exports no extensions (%s)\\n\", dlerror());\n      dlclose(driver);\n   }\n\n   *out_driver_handle = driver;\n   return extensions;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/drm-shim/drm_shim.c": "/*\n * Copyright \u00a9 2018 Broadcom\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @file\n *\n * Implements wrappers of libc functions to fake having a DRM device that\n * isn't actually present in the kernel.\n */\n\n/* Prevent glibc from defining open64 when we want to alias it. */\n#undef _FILE_OFFSET_BITS\n#define _LARGEFILE64_SOURCE\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/sysmacros.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <dlfcn.h>\n#include <dirent.h>\n#include <c11/threads.h>\n#include <drm-uapi/drm.h>\n\n#include \"util/set.h\"\n#include \"util/u_debug.h\"\n#include \"drm_shim.h\"\n\n#define REAL_FUNCTION_POINTER(x) typeof(x) *real_##x\n\nstatic mtx_t shim_lock = _MTX_INITIALIZER_NP;\nstruct set *opendir_set;\nbool drm_shim_debug;\n\n/* If /dev/dri doesn't exist, we'll need an arbitrary pointer that wouldn't be\n * returned by any other opendir() call so we can return just our fake node.\n */\nDIR *fake_dev_dri = (void *)&opendir_set;\n\n/* XXX: implement REAL_FUNCTION_POINTER(close); */\nREAL_FUNCTION_POINTER(closedir);\nREAL_FUNCTION_POINTER(dup);\nREAL_FUNCTION_POINTER(fcntl);\nREAL_FUNCTION_POINTER(fopen);\nREAL_FUNCTION_POINTER(ioctl);\nREAL_FUNCTION_POINTER(mmap);\nREAL_FUNCTION_POINTER(open);\nREAL_FUNCTION_POINTER(opendir);\nREAL_FUNCTION_POINTER(readdir);\nREAL_FUNCTION_POINTER(readdir64);\nREAL_FUNCTION_POINTER(readlink);\nREAL_FUNCTION_POINTER(realpath);\nREAL_FUNCTION_POINTER(__xstat);\nREAL_FUNCTION_POINTER(__xstat64);\nREAL_FUNCTION_POINTER(__fxstat);\nREAL_FUNCTION_POINTER(__fxstat64);\n\n/* Full path of /dev/dri/renderD* */\nstatic char *render_node_path;\n/* renderD* */\nstatic char *render_node_dirent_name;\n/* /sys/dev/char/major:minor/device */\nstatic char *device_path;\n/* /sys/dev/char/major:minor/device/subsystem */\nstatic char *subsystem_path;\nint render_node_minor = -1;\n\nstruct file_override {\n   const char *path;\n   char *contents;\n};\nstatic struct file_override file_overrides[10];\nstatic int file_overrides_count;\nextern bool drm_shim_driver_prefers_first_render_node;\n\n#define nfasprintf(...)                         \\\n   {                                            \\\n      UNUSED int __ret = asprintf(__VA_ARGS__); \\\n      assert(__ret >= 0);                       \\\n   }\n#define nfvasprintf(...)                         \\\n   {                                             \\\n      UNUSED int __ret = vasprintf(__VA_ARGS__); \\\n      assert(__ret >= 0);                        \\\n   }\n\n/* Pick the minor and filename for our shimmed render node.  This can be\n * either a new one that didn't exist on the system, or if the driver wants,\n * it can replace the first render node.\n */\nstatic void\nget_dri_render_node_minor(void)\n{\n   for (int i = 0; i < 10; i++) {\n      UNUSED int minor = 128 + i;\n      nfasprintf(&render_node_dirent_name, \"renderD%d\", minor);\n      nfasprintf(&render_node_path, \"/dev/dri/%s\",\n                 render_node_dirent_name);\n      struct stat st;\n      if (drm_shim_driver_prefers_first_render_node ||\n          stat(render_node_path, &st) == -1) {\n\n         render_node_minor = minor;\n         return;\n      }\n   }\n\n   fprintf(stderr, \"Couldn't find a spare render node slot\\n\");\n}\n\nstatic void *get_function_pointer(const char *name)\n{\n   void *func = dlsym(RTLD_NEXT, name);\n   if (!func) {\n      fprintf(stderr, \"Failed to resolve %s\\n\", name);\n      abort();\n   }\n   return func;\n}\n\n#define GET_FUNCTION_POINTER(x) real_##x = get_function_pointer(#x)\n\nvoid\ndrm_shim_override_file(const char *contents, const char *path_format, ...)\n{\n   assert(file_overrides_count < ARRAY_SIZE(file_overrides));\n\n   char *path;\n   va_list ap;\n   va_start(ap, path_format);\n   nfvasprintf(&path, path_format, ap);\n   va_end(ap);\n\n   struct file_override *override = &file_overrides[file_overrides_count++];\n   override->path = path;\n   override->contents = strdup(contents);\n}\n\nstatic void\ndestroy_shim(void)\n{\n   _mesa_set_destroy(opendir_set, NULL);\n   free(render_node_path);\n   free(render_node_dirent_name);\n   free(subsystem_path);\n}\n\n/* Initialization, which will be called from the first general library call\n * that might need to be wrapped with the shim.\n */\nstatic void\ninit_shim(void)\n{\n   static bool inited = false;\n   drm_shim_debug = debug_get_bool_option(\"DRM_SHIM_DEBUG\", false);\n\n   /* We can't lock this, because we recurse during initialization. */\n   if (inited)\n      return;\n\n   /* This comes first (and we're locked), to make sure we don't recurse\n    * during initialization.\n    */\n   inited = true;\n\n   opendir_set = _mesa_set_create(NULL,\n                                  _mesa_hash_string,\n                                  _mesa_key_string_equal);\n\n   GET_FUNCTION_POINTER(closedir);\n   GET_FUNCTION_POINTER(dup);\n   GET_FUNCTION_POINTER(fcntl);\n   GET_FUNCTION_POINTER(fopen);\n   GET_FUNCTION_POINTER(ioctl);\n   GET_FUNCTION_POINTER(mmap);\n   GET_FUNCTION_POINTER(open);\n   GET_FUNCTION_POINTER(opendir);\n   GET_FUNCTION_POINTER(readdir);\n   GET_FUNCTION_POINTER(readdir64);\n   GET_FUNCTION_POINTER(readlink);\n   GET_FUNCTION_POINTER(realpath);\n   GET_FUNCTION_POINTER(__xstat);\n   GET_FUNCTION_POINTER(__xstat64);\n   GET_FUNCTION_POINTER(__fxstat);\n   GET_FUNCTION_POINTER(__fxstat64);\n\n   get_dri_render_node_minor();\n\n   if (drm_shim_debug) {\n      fprintf(stderr, \"Initializing DRM shim on %s\\n\",\n              render_node_path);\n   }\n\n   nfasprintf(&device_path,\n              \"/sys/dev/char/%d:%d/device\",\n              DRM_MAJOR, render_node_minor);\n\n   nfasprintf(&subsystem_path,\n              \"/sys/dev/char/%d:%d/device/subsystem\",\n              DRM_MAJOR, render_node_minor);\n\n   drm_shim_device_init();\n\n   atexit(destroy_shim);\n}\n\n/* Override libdrm's reading of various sysfs files for device enumeration. */\nPUBLIC FILE *fopen(const char *path, const char *mode)\n{\n   init_shim();\n\n   for (int i = 0; i < file_overrides_count; i++) {\n      if (strcmp(file_overrides[i].path, path) == 0) {\n         int fds[2];\n         pipe(fds);\n         write(fds[1], file_overrides[i].contents,\n               strlen(file_overrides[i].contents));\n         close(fds[1]);\n         return fdopen(fds[0], \"r\");\n      }\n   }\n\n   return real_fopen(path, mode);\n}\nPUBLIC FILE *fopen64(const char *path, const char *mode)\n   __attribute__((alias(\"fopen\")));\n\n/* Intercepts open(render_node_path) to redirect it to the simulator. */\nPUBLIC int open(const char *path, int flags, ...)\n{\n   init_shim();\n\n   va_list ap;\n   va_start(ap, flags);\n   mode_t mode = va_arg(ap, mode_t);\n   va_end(ap);\n\n   if (strcmp(path, render_node_path) != 0)\n      return real_open(path, flags, mode);\n\n   int fd = real_open(\"/dev/null\", O_RDWR, 0);\n\n   drm_shim_fd_register(fd, NULL);\n\n   return fd;\n}\nPUBLIC int open64(const char*, int, ...) __attribute__((alias(\"open\")));\n\n/* Fakes stat to return character device stuff for our fake render node. */\nPUBLIC int __xstat(int ver, const char *path, struct stat *st)\n{\n   init_shim();\n\n   /* Note: call real stat if we're in the process of probing for a free\n    * render node!\n    */\n   if (render_node_minor == -1)\n      return real___xstat(ver, path, st);\n\n   /* Fool libdrm's probe of whether the /sys dir for this char dev is\n    * there.\n    */\n   char *sys_dev_drm_dir;\n   nfasprintf(&sys_dev_drm_dir,\n              \"/sys/dev/char/%d:%d/device/drm\",\n              DRM_MAJOR, render_node_minor);\n   if (strcmp(path, sys_dev_drm_dir) == 0) {\n      free(sys_dev_drm_dir);\n      return 0;\n   }\n   free(sys_dev_drm_dir);\n\n   if (strcmp(path, render_node_path) != 0)\n      return real___xstat(ver, path, st);\n\n   memset(st, 0, sizeof(*st));\n   st->st_rdev = makedev(DRM_MAJOR, render_node_minor);\n   st->st_mode = S_IFCHR;\n\n   return 0;\n}\n\n/* Fakes stat to return character device stuff for our fake render node. */\nPUBLIC int __xstat64(int ver, const char *path, struct stat64 *st)\n{\n   init_shim();\n\n   /* Note: call real stat if we're in the process of probing for a free\n    * render node!\n    */\n   if (render_node_minor == -1)\n      return real___xstat64(ver, path, st);\n\n   /* Fool libdrm's probe of whether the /sys dir for this char dev is\n    * there.\n    */\n   char *sys_dev_drm_dir;\n   nfasprintf(&sys_dev_drm_dir,\n              \"/sys/dev/char/%d:%d/device/drm\",\n              DRM_MAJOR, render_node_minor);\n   if (strcmp(path, sys_dev_drm_dir) == 0) {\n      free(sys_dev_drm_dir);\n      return 0;\n   }\n   free(sys_dev_drm_dir);\n\n   if (strcmp(path, render_node_path) != 0)\n      return real___xstat64(ver, path, st);\n\n   memset(st, 0, sizeof(*st));\n   st->st_rdev = makedev(DRM_MAJOR, render_node_minor);\n   st->st_mode = S_IFCHR;\n\n   return 0;\n}\n\n/* Fakes fstat to return character device stuff for our fake render node. */\nPUBLIC int __fxstat(int ver, int fd, struct stat *st)\n{\n   init_shim();\n\n   struct shim_fd *shim_fd = drm_shim_fd_lookup(fd);\n\n   if (!shim_fd)\n      return real___fxstat(ver, fd, st);\n\n   memset(st, 0, sizeof(*st));\n   st->st_rdev = makedev(DRM_MAJOR, render_node_minor);\n   st->st_mode = S_IFCHR;\n\n   return 0;\n}\n\nPUBLIC int __fxstat64(int ver, int fd, struct stat64 *st)\n{\n   init_shim();\n\n   struct shim_fd *shim_fd = drm_shim_fd_lookup(fd);\n\n   if (!shim_fd)\n      return real___fxstat64(ver, fd, st);\n\n   memset(st, 0, sizeof(*st));\n   st->st_rdev = makedev(DRM_MAJOR, render_node_minor);\n   st->st_mode = S_IFCHR;\n\n   return 0;\n}\n\n/* Tracks if the opendir was on /dev/dri. */\nPUBLIC DIR *\nopendir(const char *name)\n{\n   init_shim();\n\n   DIR *dir = real_opendir(name);\n   if (strcmp(name, \"/dev/dri\") == 0) {\n      if (!dir) {\n         /* If /dev/dri didn't exist, we still want to be able to return our\n          * fake /dev/dri/render* even though we probably can't\n          * mkdir(\"/dev/dri\").  Return a fake DIR pointer for that.\n          */\n         dir = fake_dev_dri;\n      }\n\n      mtx_lock(&shim_lock);\n      _mesa_set_add(opendir_set, dir);\n      mtx_unlock(&shim_lock);\n   }\n\n   return dir;\n}\n\n/* If we've reached the end of the real directory list and we're\n * looking at /dev/dri, add our render node to the list.\n */\nPUBLIC struct dirent *\nreaddir(DIR *dir)\n{\n   init_shim();\n\n   struct dirent *ent = NULL;\n\n   if (dir != fake_dev_dri)\n      ent = real_readdir(dir);\n   static struct dirent render_node_dirent = { 0 };\n\n   if (!ent) {\n      mtx_lock(&shim_lock);\n      if (_mesa_set_search(opendir_set, dir)) {\n         strcpy(render_node_dirent.d_name,\n                render_node_dirent_name);\n         ent = &render_node_dirent;\n         _mesa_set_remove_key(opendir_set, dir);\n      }\n      mtx_unlock(&shim_lock);\n   }\n\n   return ent;\n}\n\n/* If we've reached the end of the real directory list and we're\n * looking at /dev/dri, add our render node to the list.\n */\nPUBLIC struct dirent64 *\nreaddir64(DIR *dir)\n{\n   init_shim();\n\n   struct dirent64 *ent = NULL;\n   if (dir != fake_dev_dri)\n      ent = real_readdir64(dir);\n   static struct dirent64 render_node_dirent = { 0 };\n\n   if (!ent) {\n      mtx_lock(&shim_lock);\n      if (_mesa_set_search(opendir_set, dir)) {\n         strcpy(render_node_dirent.d_name,\n                render_node_dirent_name);\n         ent = &render_node_dirent;\n         _mesa_set_remove_key(opendir_set, dir);\n      }\n      mtx_unlock(&shim_lock);\n   }\n\n   return ent;\n}\n\n/* Cleans up tracking of opendir(\"/dev/dri\") */\nPUBLIC int\nclosedir(DIR *dir)\n{\n   init_shim();\n\n   mtx_lock(&shim_lock);\n   _mesa_set_remove_key(opendir_set, dir);\n   mtx_unlock(&shim_lock);\n\n   if (dir != fake_dev_dri)\n      return real_closedir(dir);\n   else\n      return 0;\n}\n\n/* Handles libdrm's readlink to figure out what kind of device we have. */\nPUBLIC ssize_t\nreadlink(const char *path, char *buf, size_t size)\n{\n   init_shim();\n\n   if (strcmp(path, subsystem_path) != 0)\n      return real_readlink(path, buf, size);\n\n   static const struct {\n      const char *name;\n      int bus_type;\n   } bus_types[] = {\n      { \"/pci\", DRM_BUS_PCI },\n      { \"/usb\", DRM_BUS_USB },\n      { \"/platform\", DRM_BUS_PLATFORM },\n      { \"/spi\", DRM_BUS_PLATFORM },\n      { \"/host1x\", DRM_BUS_HOST1X },\n   };\n\n   for (uint32_t i = 0; i < ARRAY_SIZE(bus_types); i++) {\n      if (bus_types[i].bus_type != shim_device.bus_type)\n         continue;\n\n      strncpy(buf, bus_types[i].name, size);\n      buf[size - 1] = 0;\n      break;\n   }\n\n   return strlen(buf) + 1;\n}\n\n/* Handles libdrm's realpath to figure out what kind of device we have. */\nPUBLIC char *\nrealpath(const char *path, char *resolved_path)\n{\n   init_shim();\n\n   if (strcmp(path, device_path) != 0)\n      return real_realpath(path, resolved_path);\n\n   strcpy(resolved_path, path);\n\n   return resolved_path;\n}\n\n/* Main entrypoint to DRM drivers: the ioctl syscall.  We send all ioctls on\n * our DRM fd to drm_shim_ioctl().\n */\nPUBLIC int\nioctl(int fd, unsigned long request, ...)\n{\n   init_shim();\n\n   va_list ap;\n   va_start(ap, request);\n   void *arg = va_arg(ap, void *);\n   va_end(ap);\n\n   struct shim_fd *shim_fd = drm_shim_fd_lookup(fd);\n   if (!shim_fd)\n      return real_ioctl(fd, request, arg);\n\n   return drm_shim_ioctl(fd, request, arg);\n}\n\n/* Gallium uses this to dup the incoming fd on gbm screen creation */\nPUBLIC int\nfcntl(int fd, int cmd, ...)\n{\n   init_shim();\n\n   struct shim_fd *shim_fd = drm_shim_fd_lookup(fd);\n\n   va_list ap;\n   va_start(ap, cmd);\n   void *arg = va_arg(ap, void *);\n   va_end(ap);\n\n   int ret = real_fcntl(fd, cmd, arg);\n\n   if (shim_fd && (cmd == F_DUPFD || cmd == F_DUPFD_CLOEXEC))\n      drm_shim_fd_register(ret, shim_fd);\n\n   return ret;\n}\nPUBLIC int fcntl64(int, int, ...)\n   __attribute__((alias(\"fcntl\")));\n\n/* I wrote this when trying to fix gallium screen creation, leaving it around\n * since it's probably good to have.\n */\nPUBLIC int\ndup(int fd)\n{\n   init_shim();\n\n   int ret = real_dup(fd);\n\n   struct shim_fd *shim_fd = drm_shim_fd_lookup(fd);\n   if (shim_fd && ret >= 0)\n      drm_shim_fd_register(ret, shim_fd);\n\n   return ret;\n}\n\nPUBLIC void *\nmmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)\n{\n   init_shim();\n\n   struct shim_fd *shim_fd = drm_shim_fd_lookup(fd);\n   if (shim_fd)\n      return drm_shim_mmap(shim_fd, length, prot, flags, fd, offset);\n\n   return real_mmap(addr, length, prot, flags, fd, offset);\n}\nPUBLIC void *mmap64(void*, size_t, int, int, int, off_t)\n   __attribute__((alias(\"mmap\")));\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/gallium/auxiliary/target-helpers/drm_helper.h": "#ifndef DRM_HELPER_H\n#define DRM_HELPER_H\n\n#include <stdio.h>\n#include \"target-helpers/inline_debug_helper.h\"\n#include \"target-helpers/drm_helper_public.h\"\n#include \"frontend/drm_driver.h\"\n#include \"util/driconf.h\"\n\n/**\n * Instantiate a drm_driver_descriptor struct.\n */\n#define DEFINE_DRM_DRIVER_DESCRIPTOR(descriptor_name, driver, _driconf, _driconf_count, func) \\\nconst struct drm_driver_descriptor descriptor_name = {         \\\n   .driver_name = #driver,                                     \\\n   .driconf = _driconf,                                        \\\n   .driconf_count = _driconf_count,                            \\\n   .create_screen = func,                                      \\\n};\n\n/* The static pipe loader refers to the *_driver_descriptor structs for all\n * drivers, regardless of whether they are configured in this Mesa build, or\n * whether they're included in the specific gallium target.  The target (dri,\n * vdpau, etc.) will include this header with the #defines for the specific\n * drivers it's including, and the disabled drivers will have a descriptor\n * with a stub create function logging the failure.\n *\n * The dynamic pipe loader instead has target/pipeloader/pipe_*.c including\n * this header in a pipe_*.so for each driver which will have one driver's\n * GALLIUM_* defined.  We make a single driver_descriptor entrypoint that is\n * dlsym()ed by the dynamic pipe loader.\n */\n\n#ifdef PIPE_LOADER_DYNAMIC\n\n#define DRM_DRIVER_DESCRIPTOR(driver, driconf, driconf_count)           \\\n   PUBLIC DEFINE_DRM_DRIVER_DESCRIPTOR(driver_descriptor, driver, driconf, driconf_count, pipe_##driver##_create_screen)\n\n#define DRM_DRIVER_DESCRIPTOR_STUB(driver)\n\n#define DRM_DRIVER_DESCRIPTOR_ALIAS(driver, alias, driconf, driconf_count)\n\n#else\n\n#define DRM_DRIVER_DESCRIPTOR(driver, driconf, driconf_count)                          \\\n   DEFINE_DRM_DRIVER_DESCRIPTOR(driver##_driver_descriptor, driver, driconf, driconf_count, pipe_##driver##_create_screen)\n\n#define DRM_DRIVER_DESCRIPTOR_STUB(driver)                              \\\n   static struct pipe_screen *                                          \\\n   pipe_##driver##_create_screen(int fd, const struct pipe_screen_config *config) \\\n   {                                                                    \\\n      fprintf(stderr, #driver \": driver missing\\n\");                    \\\n      return NULL;                                                      \\\n   }                                                                    \\\n   DRM_DRIVER_DESCRIPTOR(driver, NULL, 0)\n\n#define DRM_DRIVER_DESCRIPTOR_ALIAS(driver, alias, driconf, driconf_count) \\\n   DEFINE_DRM_DRIVER_DESCRIPTOR(alias##_driver_descriptor, alias, driconf, \\\n                                driconf_count, pipe_##driver##_create_screen)\n\n#endif\n\n#ifdef GALLIUM_I915\n#include \"i915/drm/i915_drm_public.h\"\n#include \"i915/i915_public.h\"\n\nstatic struct pipe_screen *\npipe_i915_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct i915_winsys *iws;\n   struct pipe_screen *screen;\n\n   iws = i915_drm_winsys_create(fd);\n   if (!iws)\n      return NULL;\n\n   screen = i915_screen_create(iws);\n   return screen ? debug_screen_wrap(screen) : NULL;\n}\nDRM_DRIVER_DESCRIPTOR(i915, NULL, 0)\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(i915)\n#endif\n\n#ifdef GALLIUM_IRIS\n#include \"iris/drm/iris_drm_public.h\"\n\nstatic struct pipe_screen *\npipe_iris_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct pipe_screen *screen;\n\n   screen = iris_drm_screen_create(fd, config);\n   return screen ? debug_screen_wrap(screen) : NULL;\n}\n\nconst driOptionDescription iris_driconf[] = {\n      #include \"iris/driinfo_iris.h\"\n};\nDRM_DRIVER_DESCRIPTOR(iris, iris_driconf, ARRAY_SIZE(iris_driconf))\n\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(iris)\n#endif\n\n#ifdef GALLIUM_NOUVEAU\n#include \"nouveau/drm/nouveau_drm_public.h\"\n\nstatic struct pipe_screen *\npipe_nouveau_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct pipe_screen *screen;\n\n   screen = nouveau_drm_screen_create(fd);\n   return screen ? debug_screen_wrap(screen) : NULL;\n}\nDRM_DRIVER_DESCRIPTOR(nouveau, NULL, 0)\n\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(nouveau)\n#endif\n\n#if defined(GALLIUM_VC4) || defined(GALLIUM_V3D)\nconst driOptionDescription v3d_driconf[] = {\n      #include \"v3d/driinfo_v3d.h\"\n};\n#endif\n\n#ifdef GALLIUM_KMSRO\n#include \"kmsro/drm/kmsro_drm_public.h\"\n\nstatic struct pipe_screen *\npipe_kmsro_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct pipe_screen *screen;\n\n   screen = kmsro_drm_screen_create(fd, config);\n   return screen ? debug_screen_wrap(screen) : NULL;\n}\n#if defined(GALLIUM_VC4) || defined(GALLIUM_V3D)\nDRM_DRIVER_DESCRIPTOR(kmsro, v3d_driconf, ARRAY_SIZE(v3d_driconf))\n#else\nDRM_DRIVER_DESCRIPTOR(kmsro, NULL, 0)\n#endif\n\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(kmsro)\n#endif\n\n#ifdef GALLIUM_R300\n#include \"radeon/radeon_winsys.h\"\n#include \"radeon/drm/radeon_drm_public.h\"\n#include \"r300/r300_public.h\"\n\nstatic struct pipe_screen *\npipe_r300_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct radeon_winsys *rw;\n\n   rw = radeon_drm_winsys_create(fd, config, r300_screen_create);\n   return rw ? debug_screen_wrap(rw->screen) : NULL;\n}\nDRM_DRIVER_DESCRIPTOR(r300, NULL, 0)\n\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(r300)\n#endif\n\n#ifdef GALLIUM_R600\n#include \"radeon/radeon_winsys.h\"\n#include \"radeon/drm/radeon_drm_public.h\"\n#include \"r600/r600_public.h\"\n\nstatic struct pipe_screen *\npipe_r600_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct radeon_winsys *rw;\n\n   rw = radeon_drm_winsys_create(fd, config, r600_screen_create);\n   return rw ? debug_screen_wrap(rw->screen) : NULL;\n}\nDRM_DRIVER_DESCRIPTOR(r600, NULL, 0)\n\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(r600)\n#endif\n\n#ifdef GALLIUM_RADEONSI\n#include \"radeonsi/si_public.h\"\n\nstatic struct pipe_screen *\npipe_radeonsi_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct pipe_screen *screen = radeonsi_screen_create(fd, config);\n\n   return screen ? debug_screen_wrap(screen) : NULL;\n}\n\nconst driOptionDescription radeonsi_driconf[] = {\n      #include \"radeonsi/driinfo_radeonsi.h\"\n};\nDRM_DRIVER_DESCRIPTOR(radeonsi, radeonsi_driconf, ARRAY_SIZE(radeonsi_driconf))\n\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(radeonsi)\n#endif\n\n#ifdef GALLIUM_VMWGFX\n#include \"svga/drm/svga_drm_public.h\"\n#include \"svga/svga_public.h\"\n\nstatic struct pipe_screen *\npipe_vmwgfx_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct svga_winsys_screen *sws;\n   struct pipe_screen *screen;\n\n   sws = svga_drm_winsys_screen_create(fd);\n   if (!sws)\n      return NULL;\n\n   screen = svga_screen_create(sws);\n   return screen ? debug_screen_wrap(screen) : NULL;\n}\nDRM_DRIVER_DESCRIPTOR(vmwgfx, NULL, 0)\n\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(vmwgfx)\n#endif\n\n#ifdef GALLIUM_FREEDRENO\n#include \"freedreno/drm/freedreno_drm_public.h\"\n\nstatic struct pipe_screen *\npipe_msm_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct pipe_screen *screen;\n\n   screen = fd_drm_screen_create(fd, NULL);\n   return screen ? debug_screen_wrap(screen) : NULL;\n}\nDRM_DRIVER_DESCRIPTOR(msm, NULL, 0)\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(msm)\n#endif\nDRM_DRIVER_DESCRIPTOR_ALIAS(msm, kgsl, NULL, 0)\n\n#ifdef GALLIUM_VIRGL\n#include \"virgl/drm/virgl_drm_public.h\"\n#include \"virgl/virgl_public.h\"\n\nstatic struct pipe_screen *\npipe_virtio_gpu_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct pipe_screen *screen;\n\n   screen = virgl_drm_screen_create(fd, config);\n   return screen ? debug_screen_wrap(screen) : NULL;\n}\n\nconst driOptionDescription virgl_driconf[] = {\n      #include \"virgl/virgl_driinfo.h.in\"\n};\nDRM_DRIVER_DESCRIPTOR(virtio_gpu, virgl_driconf, ARRAY_SIZE(virgl_driconf))\n\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(virtio_gpu)\n#endif\n\n#ifdef GALLIUM_VC4\n#include \"vc4/drm/vc4_drm_public.h\"\n\nstatic struct pipe_screen *\npipe_vc4_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct pipe_screen *screen;\n\n   screen = vc4_drm_screen_create(fd, config);\n   return screen ? debug_screen_wrap(screen) : NULL;\n}\nDRM_DRIVER_DESCRIPTOR(vc4, v3d_driconf, ARRAY_SIZE(v3d_driconf))\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(vc4)\n#endif\n\n#ifdef GALLIUM_V3D\n#include \"v3d/drm/v3d_drm_public.h\"\n\nstatic struct pipe_screen *\npipe_v3d_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct pipe_screen *screen;\n\n   screen = v3d_drm_screen_create(fd, config);\n   return screen ? debug_screen_wrap(screen) : NULL;\n}\n\nDRM_DRIVER_DESCRIPTOR(v3d, v3d_driconf, ARRAY_SIZE(v3d_driconf))\n\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(v3d)\n#endif\n\n#ifdef GALLIUM_PANFROST\n#include \"panfrost/drm/panfrost_drm_public.h\"\n\nstatic struct pipe_screen *\npipe_panfrost_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct pipe_screen *screen;\n\n   screen = panfrost_drm_screen_create(fd);\n   return screen ? debug_screen_wrap(screen) : NULL;\n}\nDRM_DRIVER_DESCRIPTOR(panfrost, NULL, 0)\n\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(panfrost)\n#endif\n\n#ifdef GALLIUM_ETNAVIV\n#include \"etnaviv/drm/etnaviv_drm_public.h\"\n\nstatic struct pipe_screen *\npipe_etnaviv_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct pipe_screen *screen;\n\n   screen = etna_drm_screen_create(fd);\n   return screen ? debug_screen_wrap(screen) : NULL;\n}\nDRM_DRIVER_DESCRIPTOR(etnaviv, NULL, 0)\n\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(etnaviv)\n#endif\n\n#ifdef GALLIUM_TEGRA\n#include \"tegra/drm/tegra_drm_public.h\"\n\nstatic struct pipe_screen *\npipe_tegra_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct pipe_screen *screen;\n\n   screen = tegra_drm_screen_create(fd);\n\n   return screen ? debug_screen_wrap(screen) : NULL;\n}\nDRM_DRIVER_DESCRIPTOR(tegra, NULL, 0)\n\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(tegra)\n#endif\n\n#ifdef GALLIUM_LIMA\n#include \"lima/drm/lima_drm_public.h\"\n\nstatic struct pipe_screen *\npipe_lima_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct pipe_screen *screen;\n\n   screen = lima_drm_screen_create(fd);\n   return screen ? debug_screen_wrap(screen) : NULL;\n}\nDRM_DRIVER_DESCRIPTOR(lima, NULL, 0)\n\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(lima)\n#endif\n\n#ifdef GALLIUM_ZINK\n#include \"zink/zink_public.h\"\n\nstatic struct pipe_screen *\npipe_zink_create_screen(int fd, const struct pipe_screen_config *config)\n{\n   struct pipe_screen *screen;\n   screen = zink_drm_create_screen(fd, config);\n   return screen ? debug_screen_wrap(screen) : NULL;\n}\n\nconst driOptionDescription zink_driconf[] = {\n      #include \"zink/driinfo_zink.h\"\n};\nDRM_DRIVER_DESCRIPTOR(zink, zink_driconf, ARRAY_SIZE(zink_driconf))\n\n#else\nDRM_DRIVER_DESCRIPTOR_STUB(zink)\n#endif\n\n#endif /* DRM_HELPER_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/gallium/auxiliary/util/u_dl.c": "/**************************************************************************\n *\n * Copyright 2009 VMware, Inc.\n * Copyright 1999-2008  Brian Paul\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sub license, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL\n * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * The above copyright notice and this permission notice (including the\n * next paragraph) shall be included in all copies or substantial portions\n * of the Software.\n *\n **************************************************************************/\n\n\n#include \"pipe/p_config.h\"\n#include \"pipe/p_compiler.h\"\n\n#if defined(PIPE_OS_UNIX)\n#include <dlfcn.h>\n#endif\n#if defined(PIPE_OS_WINDOWS)\n#include <windows.h>\n#endif\n\n#include \"u_dl.h\"\n#include \"u_pointer.h\"\n\n\nstruct util_dl_library *\nutil_dl_open(const char *filename)\n{\n#if defined(PIPE_OS_UNIX)\n   return (struct util_dl_library *)dlopen(filename, RTLD_LAZY | RTLD_LOCAL);\n#elif defined(PIPE_OS_WINDOWS)\n   return (struct util_dl_library *)LoadLibraryA(filename);\n#else\n   return NULL;\n#endif\n}\n\n\nutil_dl_proc\nutil_dl_get_proc_address(struct util_dl_library *library,\n                         const char *procname)\n{\n#if defined(PIPE_OS_UNIX)\n   return (util_dl_proc) pointer_to_func(dlsym((void *)library, procname));\n#elif defined(PIPE_OS_WINDOWS)\n   return (util_dl_proc)GetProcAddress((HMODULE)library, procname);\n#else\n   return (util_dl_proc)NULL;\n#endif\n}\n\n\nvoid\nutil_dl_close(struct util_dl_library *library)\n{\n#if defined(PIPE_OS_UNIX)\n   dlclose((void *)library);\n#elif defined(PIPE_OS_WINDOWS)\n   FreeLibrary((HMODULE)library);\n#else\n   (void)library;\n#endif\n}\n\n\nconst char *\nutil_dl_error(void)\n{\n#if defined(PIPE_OS_UNIX)\n   return dlerror();\n#elif defined(PIPE_OS_WINDOWS)\n   return \"unknown error\";\n#else\n   return \"unknown error\";\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/gallium/include/frontend/opencl_interop.h": "/**************************************************************************\n *\n * Copyright 2015 Advanced Micro Devices, Inc.\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sub license, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice (including the\n * next paragraph) shall be included in all copies or substantial portions\n * of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR\n * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n **************************************************************************/\n\n#ifndef OPENCL_INTEROP_H\n#define OPENCL_INTEROP_H\n\n/* dlsym these without the \"_t\" suffix. You should get the correct symbols\n * if the OpenCL driver is loaded.\n */\n\ntypedef bool (*opencl_dri_event_add_ref_t)(void *cl_event);\ntypedef bool (*opencl_dri_event_release_t)(void *cl_event);\ntypedef bool (*opencl_dri_event_wait_t)(void *cl_event, uint64_t timeout);\ntypedef struct pipe_fence_handle *(*opencl_dri_event_get_fence_t)(void *cl_event);\n\n#endif /* OPENCL_INTEROP_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/gallium/frontends/dri/dri2.c": "/*\n * Mesa 3-D graphics library\n *\n * Copyright 2009, VMware, Inc.\n * All Rights Reserved.\n * Copyright (C) 2010 LunarG Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors:\n *    Keith Whitwell <keithw@vmware.com> Jakob Bornecrantz\n *    <wallbraker@gmail.com> Chia-I Wu <olv@lunarg.com>\n */\n\n#include <xf86drm.h>\n#include \"GL/mesa_glinterop.h\"\n#include \"util/disk_cache.h\"\n#include \"util/u_memory.h\"\n#include \"util/u_inlines.h\"\n#include \"util/format/u_format.h\"\n#include \"util/u_debug.h\"\n#include \"frontend/drm_driver.h\"\n#include \"state_tracker/st_cb_bufferobjects.h\"\n#include \"state_tracker/st_cb_fbo.h\"\n#include \"state_tracker/st_cb_texture.h\"\n#include \"state_tracker/st_texture.h\"\n#include \"state_tracker/st_context.h\"\n#include \"pipe-loader/pipe_loader.h\"\n#include \"main/bufferobj.h\"\n#include \"main/texobj.h\"\n\n#include \"dri_util.h\"\n\n#include \"dri_helpers.h\"\n#include \"dri_drawable.h\"\n#include \"dri_query_renderer.h\"\n\n#include \"drm-uapi/drm_fourcc.h\"\n\nstruct dri2_buffer\n{\n   __DRIbuffer base;\n   struct pipe_resource *resource;\n};\n\nstatic inline struct dri2_buffer *\ndri2_buffer(__DRIbuffer * driBufferPriv)\n{\n   return (struct dri2_buffer *) driBufferPriv;\n}\n\n/**\n * DRI2 flush extension.\n */\nstatic void\ndri2_flush_drawable(__DRIdrawable *dPriv)\n{\n   dri_flush(dPriv->driContextPriv, dPriv, __DRI2_FLUSH_DRAWABLE, -1);\n}\n\nstatic void\ndri2_invalidate_drawable(__DRIdrawable *dPriv)\n{\n   struct dri_drawable *drawable = dri_drawable(dPriv);\n\n   dri2InvalidateDrawable(dPriv);\n   drawable->dPriv->lastStamp = drawable->dPriv->dri2.stamp;\n   drawable->texture_mask = 0;\n\n   p_atomic_inc(&drawable->base.stamp);\n}\n\nstatic const __DRI2flushExtension dri2FlushExtension = {\n    .base = { __DRI2_FLUSH, 4 },\n\n    .flush                = dri2_flush_drawable,\n    .invalidate           = dri2_invalidate_drawable,\n    .flush_with_flags     = dri_flush,\n};\n\n/**\n * Retrieve __DRIbuffer from the DRI loader.\n */\nstatic __DRIbuffer *\ndri2_drawable_get_buffers(struct dri_drawable *drawable,\n                          const enum st_attachment_type *atts,\n                          unsigned *count)\n{\n   __DRIdrawable *dri_drawable = drawable->dPriv;\n   const __DRIdri2LoaderExtension *loader = drawable->sPriv->dri2.loader;\n   boolean with_format;\n   __DRIbuffer *buffers;\n   int num_buffers;\n   unsigned attachments[10];\n   unsigned num_attachments, i;\n\n   assert(loader);\n   with_format = dri_with_format(drawable->sPriv);\n\n   num_attachments = 0;\n\n   /* for Xserver 1.6.0 (DRI2 version 1) we always need to ask for the front */\n   if (!with_format)\n      attachments[num_attachments++] = __DRI_BUFFER_FRONT_LEFT;\n\n   for (i = 0; i < *count; i++) {\n      enum pipe_format format;\n      unsigned bind;\n      int att, depth;\n\n      dri_drawable_get_format(drawable, atts[i], &format, &bind);\n      if (format == PIPE_FORMAT_NONE)\n         continue;\n\n      switch (atts[i]) {\n      case ST_ATTACHMENT_FRONT_LEFT:\n         /* already added */\n         if (!with_format)\n            continue;\n         att = __DRI_BUFFER_FRONT_LEFT;\n         break;\n      case ST_ATTACHMENT_BACK_LEFT:\n         att = __DRI_BUFFER_BACK_LEFT;\n         break;\n      case ST_ATTACHMENT_FRONT_RIGHT:\n         att = __DRI_BUFFER_FRONT_RIGHT;\n         break;\n      case ST_ATTACHMENT_BACK_RIGHT:\n         att = __DRI_BUFFER_BACK_RIGHT;\n         break;\n      default:\n         continue;\n      }\n\n      /*\n       * In this switch statement we must support all formats that\n       * may occur as the stvis->color_format.\n       */\n      switch(format) {\n      case PIPE_FORMAT_R16G16B16A16_FLOAT:\n         depth = 64;\n         break;\n      case PIPE_FORMAT_R16G16B16X16_FLOAT:\n         depth = 48;\n         break;\n      case PIPE_FORMAT_B10G10R10A2_UNORM:\n      case PIPE_FORMAT_R10G10B10A2_UNORM:\n      case PIPE_FORMAT_BGRA8888_UNORM:\n      case PIPE_FORMAT_RGBA8888_UNORM:\n\t depth = 32;\n\t break;\n      case PIPE_FORMAT_R10G10B10X2_UNORM:\n      case PIPE_FORMAT_B10G10R10X2_UNORM:\n         depth = 30;\n         break;\n      case PIPE_FORMAT_BGRX8888_UNORM:\n      case PIPE_FORMAT_RGBX8888_UNORM:\n\t depth = 24;\n\t break;\n      case PIPE_FORMAT_B5G6R5_UNORM:\n\t depth = 16;\n\t break;\n      default:\n\t depth = util_format_get_blocksizebits(format);\n\t assert(!\"Unexpected format in dri2_drawable_get_buffers()\");\n      }\n\n      attachments[num_attachments++] = att;\n      if (with_format) {\n         attachments[num_attachments++] = depth;\n      }\n   }\n\n   if (with_format) {\n      num_attachments /= 2;\n      buffers = loader->getBuffersWithFormat(dri_drawable,\n            &dri_drawable->w, &dri_drawable->h,\n            attachments, num_attachments,\n            &num_buffers, dri_drawable->loaderPrivate);\n   }\n   else {\n      buffers = loader->getBuffers(dri_drawable,\n            &dri_drawable->w, &dri_drawable->h,\n            attachments, num_attachments,\n            &num_buffers, dri_drawable->loaderPrivate);\n   }\n\n   if (buffers)\n      *count = num_buffers;\n\n   return buffers;\n}\n\nstatic bool\ndri_image_drawable_get_buffers(struct dri_drawable *drawable,\n                               struct __DRIimageList *images,\n                               const enum st_attachment_type *statts,\n                               unsigned statts_count)\n{\n   __DRIdrawable *dPriv = drawable->dPriv;\n   __DRIscreen *sPriv = drawable->sPriv;\n   unsigned int image_format = __DRI_IMAGE_FORMAT_NONE;\n   enum pipe_format pf;\n   uint32_t buffer_mask = 0;\n   unsigned i, bind;\n\n   for (i = 0; i < statts_count; i++) {\n      dri_drawable_get_format(drawable, statts[i], &pf, &bind);\n      if (pf == PIPE_FORMAT_NONE)\n         continue;\n\n      switch (statts[i]) {\n      case ST_ATTACHMENT_FRONT_LEFT:\n         buffer_mask |= __DRI_IMAGE_BUFFER_FRONT;\n         break;\n      case ST_ATTACHMENT_BACK_LEFT:\n         buffer_mask |= __DRI_IMAGE_BUFFER_BACK;\n         break;\n      default:\n         continue;\n      }\n\n      switch (pf) {\n      case PIPE_FORMAT_R16G16B16A16_FLOAT:\n         image_format = __DRI_IMAGE_FORMAT_ABGR16161616F;\n         break;\n      case PIPE_FORMAT_R16G16B16X16_FLOAT:\n         image_format = __DRI_IMAGE_FORMAT_XBGR16161616F;\n         break;\n      case PIPE_FORMAT_B5G5R5A1_UNORM:\n         image_format = __DRI_IMAGE_FORMAT_ARGB1555;\n         break;\n      case PIPE_FORMAT_B5G6R5_UNORM:\n         image_format = __DRI_IMAGE_FORMAT_RGB565;\n         break;\n      case PIPE_FORMAT_BGRX8888_UNORM:\n         image_format = __DRI_IMAGE_FORMAT_XRGB8888;\n         break;\n      case PIPE_FORMAT_BGRA8888_UNORM:\n         image_format = __DRI_IMAGE_FORMAT_ARGB8888;\n         break;\n      case PIPE_FORMAT_RGBX8888_UNORM:\n         image_format = __DRI_IMAGE_FORMAT_XBGR8888;\n         break;\n      case PIPE_FORMAT_RGBA8888_UNORM:\n         image_format = __DRI_IMAGE_FORMAT_ABGR8888;\n         break;\n      case PIPE_FORMAT_B10G10R10X2_UNORM:\n         image_format = __DRI_IMAGE_FORMAT_XRGB2101010;\n         break;\n      case PIPE_FORMAT_B10G10R10A2_UNORM:\n         image_format = __DRI_IMAGE_FORMAT_ARGB2101010;\n         break;\n      case PIPE_FORMAT_R10G10B10X2_UNORM:\n         image_format = __DRI_IMAGE_FORMAT_XBGR2101010;\n         break;\n      case PIPE_FORMAT_R10G10B10A2_UNORM:\n         image_format = __DRI_IMAGE_FORMAT_ABGR2101010;\n         break;\n      default:\n         image_format = __DRI_IMAGE_FORMAT_NONE;\n         break;\n      }\n   }\n\n   return (*sPriv->image.loader->getBuffers) (dPriv, image_format,\n                                       (uint32_t *) &drawable->base.stamp,\n                                       dPriv->loaderPrivate, buffer_mask,\n                                       images);\n}\n\nstatic __DRIbuffer *\ndri2_allocate_buffer(__DRIscreen *sPriv,\n                     unsigned attachment, unsigned format,\n                     int width, int height)\n{\n   struct dri_screen *screen = dri_screen(sPriv);\n   struct dri2_buffer *buffer;\n   struct pipe_resource templ;\n   enum pipe_format pf;\n   unsigned bind = 0;\n   struct winsys_handle whandle;\n\n   switch (attachment) {\n      case __DRI_BUFFER_FRONT_LEFT:\n      case __DRI_BUFFER_FAKE_FRONT_LEFT:\n         bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;\n         break;\n      case __DRI_BUFFER_BACK_LEFT:\n         bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;\n         break;\n      case __DRI_BUFFER_DEPTH:\n      case __DRI_BUFFER_DEPTH_STENCIL:\n      case __DRI_BUFFER_STENCIL:\n            bind = PIPE_BIND_DEPTH_STENCIL; /* XXX sampler? */\n         break;\n   }\n\n   /* because we get the handle and stride */\n   bind |= PIPE_BIND_SHARED;\n\n   switch (format) {\n      case 64:\n         pf = PIPE_FORMAT_R16G16B16A16_FLOAT;\n         break;\n      case 48:\n         pf = PIPE_FORMAT_R16G16B16X16_FLOAT;\n         break;\n      case 32:\n         pf = PIPE_FORMAT_BGRA8888_UNORM;\n         break;\n      case 30:\n         pf = PIPE_FORMAT_B10G10R10X2_UNORM;\n         break;\n      case 24:\n         pf = PIPE_FORMAT_BGRX8888_UNORM;\n         break;\n      case 16:\n         pf = PIPE_FORMAT_Z16_UNORM;\n         break;\n      default:\n         return NULL;\n   }\n\n   buffer = CALLOC_STRUCT(dri2_buffer);\n   if (!buffer)\n      return NULL;\n\n   memset(&templ, 0, sizeof(templ));\n   templ.bind = bind;\n   templ.format = pf;\n   templ.target = PIPE_TEXTURE_2D;\n   templ.last_level = 0;\n   templ.width0 = width;\n   templ.height0 = height;\n   templ.depth0 = 1;\n   templ.array_size = 1;\n\n   buffer->resource =\n      screen->base.screen->resource_create(screen->base.screen, &templ);\n   if (!buffer->resource) {\n      FREE(buffer);\n      return NULL;\n   }\n\n   memset(&whandle, 0, sizeof(whandle));\n   if (screen->can_share_buffer)\n      whandle.type = WINSYS_HANDLE_TYPE_SHARED;\n   else\n      whandle.type = WINSYS_HANDLE_TYPE_KMS;\n\n   screen->base.screen->resource_get_handle(screen->base.screen, NULL,\n         buffer->resource, &whandle,\n         PIPE_HANDLE_USAGE_EXPLICIT_FLUSH);\n\n   buffer->base.attachment = attachment;\n   buffer->base.name = whandle.handle;\n   buffer->base.cpp = util_format_get_blocksize(pf);\n   buffer->base.pitch = whandle.stride;\n\n   return &buffer->base;\n}\n\nstatic void\ndri2_release_buffer(__DRIscreen *sPriv, __DRIbuffer *bPriv)\n{\n   struct dri2_buffer *buffer = dri2_buffer(bPriv);\n\n   pipe_resource_reference(&buffer->resource, NULL);\n   FREE(buffer);\n}\n\n/*\n * Backend functions for st_framebuffer interface.\n */\n\nstatic void\ndri2_allocate_textures(struct dri_context *ctx,\n                       struct dri_drawable *drawable,\n                       const enum st_attachment_type *statts,\n                       unsigned statts_count)\n{\n   __DRIscreen *sPriv = drawable->sPriv;\n   __DRIdrawable *dri_drawable = drawable->dPriv;\n   struct dri_screen *screen = dri_screen(sPriv);\n   struct pipe_resource templ;\n   boolean alloc_depthstencil = FALSE;\n   unsigned i, j, bind;\n   const __DRIimageLoaderExtension *image = sPriv->image.loader;\n   /* Image specific variables */\n   struct __DRIimageList images;\n   /* Dri2 specific variables */\n   __DRIbuffer *buffers = NULL;\n   struct winsys_handle whandle;\n   unsigned num_buffers = statts_count;\n\n   /* First get the buffers from the loader */\n   if (image) {\n      if (!dri_image_drawable_get_buffers(drawable, &images,\n                                          statts, statts_count))\n         return;\n   }\n   else {\n      buffers = dri2_drawable_get_buffers(drawable, statts, &num_buffers);\n      if (!buffers || (drawable->old_num == num_buffers &&\n                       drawable->old_w == dri_drawable->w &&\n                       drawable->old_h == dri_drawable->h &&\n                       memcmp(drawable->old, buffers,\n                              sizeof(__DRIbuffer) * num_buffers) == 0))\n         return;\n   }\n\n   /* Second clean useless resources*/\n\n   /* See if we need a depth-stencil buffer. */\n   for (i = 0; i < statts_count; i++) {\n      if (statts[i] == ST_ATTACHMENT_DEPTH_STENCIL) {\n         alloc_depthstencil = TRUE;\n         break;\n      }\n   }\n\n   /* Delete the resources we won't need. */\n   for (i = 0; i < ST_ATTACHMENT_COUNT; i++) {\n      /* Don't delete the depth-stencil buffer, we can reuse it. */\n      if (i == ST_ATTACHMENT_DEPTH_STENCIL && alloc_depthstencil)\n         continue;\n\n      /* Flush the texture before unreferencing, so that other clients can\n       * see what the driver has rendered.\n       */\n      if (i != ST_ATTACHMENT_DEPTH_STENCIL && drawable->textures[i]) {\n         struct pipe_context *pipe = ctx->st->pipe;\n         pipe->flush_resource(pipe, drawable->textures[i]);\n      }\n\n      pipe_resource_reference(&drawable->textures[i], NULL);\n   }\n\n   if (drawable->stvis.samples > 1) {\n      for (i = 0; i < ST_ATTACHMENT_COUNT; i++) {\n         boolean del = TRUE;\n\n         /* Don't delete MSAA resources for the attachments which are enabled,\n          * we can reuse them. */\n         for (j = 0; j < statts_count; j++) {\n            if (i == statts[j]) {\n               del = FALSE;\n               break;\n            }\n         }\n\n         if (del) {\n            pipe_resource_reference(&drawable->msaa_textures[i], NULL);\n         }\n      }\n   }\n\n   /* Third use the buffers retrieved to fill the drawable info */\n\n   memset(&templ, 0, sizeof(templ));\n   templ.target = screen->target;\n   templ.last_level = 0;\n   templ.depth0 = 1;\n   templ.array_size = 1;\n\n   if (image) {\n      if (images.image_mask & __DRI_IMAGE_BUFFER_FRONT) {\n         struct pipe_resource **buf =\n            &drawable->textures[ST_ATTACHMENT_FRONT_LEFT];\n         struct pipe_resource *texture = images.front->texture;\n\n         dri_drawable->w = texture->width0;\n         dri_drawable->h = texture->height0;\n\n         pipe_resource_reference(buf, texture);\n      }\n\n      if (images.image_mask & __DRI_IMAGE_BUFFER_BACK) {\n         struct pipe_resource **buf =\n            &drawable->textures[ST_ATTACHMENT_BACK_LEFT];\n         struct pipe_resource *texture = images.back->texture;\n\n         dri_drawable->w = texture->width0;\n         dri_drawable->h = texture->height0;\n\n         pipe_resource_reference(buf, texture);\n      }\n\n      /* Note: if there is both a back and a front buffer,\n       * then they have the same size.\n       */\n      templ.width0 = dri_drawable->w;\n      templ.height0 = dri_drawable->h;\n   }\n   else {\n      memset(&whandle, 0, sizeof(whandle));\n\n      /* Process DRI-provided buffers and get pipe_resources. */\n      for (i = 0; i < num_buffers; i++) {\n         __DRIbuffer *buf = &buffers[i];\n         enum st_attachment_type statt;\n         enum pipe_format format;\n\n         switch (buf->attachment) {\n         case __DRI_BUFFER_FRONT_LEFT:\n            if (!screen->auto_fake_front) {\n               continue; /* invalid attachment */\n            }\n            FALLTHROUGH;\n         case __DRI_BUFFER_FAKE_FRONT_LEFT:\n            statt = ST_ATTACHMENT_FRONT_LEFT;\n            break;\n         case __DRI_BUFFER_BACK_LEFT:\n            statt = ST_ATTACHMENT_BACK_LEFT;\n            break;\n         default:\n            continue; /* invalid attachment */\n         }\n\n         dri_drawable_get_format(drawable, statt, &format, &bind);\n         if (format == PIPE_FORMAT_NONE)\n            continue;\n\n         /* dri2_drawable_get_buffers has already filled dri_drawable->w\n          * and dri_drawable->h */\n         templ.width0 = dri_drawable->w;\n         templ.height0 = dri_drawable->h;\n         templ.format = format;\n         templ.bind = bind;\n         whandle.handle = buf->name;\n         whandle.stride = buf->pitch;\n         whandle.offset = 0;\n         whandle.format = format;\n         whandle.modifier = DRM_FORMAT_MOD_INVALID;\n         if (screen->can_share_buffer)\n            whandle.type = WINSYS_HANDLE_TYPE_SHARED;\n         else\n            whandle.type = WINSYS_HANDLE_TYPE_KMS;\n         drawable->textures[statt] =\n            screen->base.screen->resource_from_handle(screen->base.screen,\n                  &templ, &whandle,\n                  PIPE_HANDLE_USAGE_EXPLICIT_FLUSH);\n         assert(drawable->textures[statt]);\n      }\n   }\n\n   /* Allocate private MSAA colorbuffers. */\n   if (drawable->stvis.samples > 1) {\n      for (i = 0; i < statts_count; i++) {\n         enum st_attachment_type statt = statts[i];\n\n         if (statt == ST_ATTACHMENT_DEPTH_STENCIL)\n            continue;\n\n         if (drawable->textures[statt]) {\n            templ.format = drawable->textures[statt]->format;\n            templ.bind = drawable->textures[statt]->bind &\n                         ~(PIPE_BIND_SCANOUT | PIPE_BIND_SHARED);\n            templ.nr_samples = drawable->stvis.samples;\n            templ.nr_storage_samples = drawable->stvis.samples;\n\n            /* Try to reuse the resource.\n             * (the other resource parameters should be constant)\n             */\n            if (!drawable->msaa_textures[statt] ||\n                drawable->msaa_textures[statt]->width0 != templ.width0 ||\n                drawable->msaa_textures[statt]->height0 != templ.height0) {\n               /* Allocate a new one. */\n               pipe_resource_reference(&drawable->msaa_textures[statt], NULL);\n\n               drawable->msaa_textures[statt] =\n                  screen->base.screen->resource_create(screen->base.screen,\n                                                       &templ);\n               assert(drawable->msaa_textures[statt]);\n\n               /* If there are any MSAA resources, we should initialize them\n                * such that they contain the same data as the single-sample\n                * resources we just got from the X server.\n                *\n                * The reason for this is that the gallium frontend (and\n                * therefore the app) can access the MSAA resources only.\n                * The single-sample resources are not exposed\n                * to the gallium frontend.\n                *\n                */\n               dri_pipe_blit(ctx->st->pipe,\n                             drawable->msaa_textures[statt],\n                             drawable->textures[statt]);\n            }\n         }\n         else {\n            pipe_resource_reference(&drawable->msaa_textures[statt], NULL);\n         }\n      }\n   }\n\n   /* Allocate a private depth-stencil buffer. */\n   if (alloc_depthstencil) {\n      enum st_attachment_type statt = ST_ATTACHMENT_DEPTH_STENCIL;\n      struct pipe_resource **zsbuf;\n      enum pipe_format format;\n      unsigned bind;\n\n      dri_drawable_get_format(drawable, statt, &format, &bind);\n\n      if (format) {\n         templ.format = format;\n         templ.bind = bind & ~PIPE_BIND_SHARED;\n\n         if (drawable->stvis.samples > 1) {\n            templ.nr_samples = drawable->stvis.samples;\n            templ.nr_storage_samples = drawable->stvis.samples;\n            zsbuf = &drawable->msaa_textures[statt];\n         }\n         else {\n            templ.nr_samples = 0;\n            templ.nr_storage_samples = 0;\n            zsbuf = &drawable->textures[statt];\n         }\n\n         /* Try to reuse the resource.\n          * (the other resource parameters should be constant)\n          */\n         if (!*zsbuf ||\n             (*zsbuf)->width0 != templ.width0 ||\n             (*zsbuf)->height0 != templ.height0) {\n            /* Allocate a new one. */\n            pipe_resource_reference(zsbuf, NULL);\n            *zsbuf = screen->base.screen->resource_create(screen->base.screen,\n                                                          &templ);\n            assert(*zsbuf);\n         }\n      }\n      else {\n         pipe_resource_reference(&drawable->msaa_textures[statt], NULL);\n         pipe_resource_reference(&drawable->textures[statt], NULL);\n      }\n   }\n\n   /* For DRI2, we may get the same buffers again from the server.\n    * To prevent useless imports of gem names, drawable->old* is used\n    * to bypass the import if we get the same buffers. This doesn't apply\n    * to DRI3/Wayland, users of image.loader, since the buffer is managed\n    * by the client (no import), and the back buffer is going to change\n    * at every redraw.\n    */\n   if (!image) {\n      drawable->old_num = num_buffers;\n      drawable->old_w = dri_drawable->w;\n      drawable->old_h = dri_drawable->h;\n      memcpy(drawable->old, buffers, sizeof(__DRIbuffer) * num_buffers);\n   }\n}\n\nstatic void\ndri2_flush_frontbuffer(struct dri_context *ctx,\n                       struct dri_drawable *drawable,\n                       enum st_attachment_type statt)\n{\n   __DRIdrawable *dri_drawable = drawable->dPriv;\n   const __DRIimageLoaderExtension *image = drawable->sPriv->image.loader;\n   const __DRIdri2LoaderExtension *loader = drawable->sPriv->dri2.loader;\n   struct pipe_context *pipe = ctx->st->pipe;\n\n   if (statt != ST_ATTACHMENT_FRONT_LEFT)\n      return;\n\n   if (drawable->stvis.samples > 1) {\n      /* Resolve the front buffer. */\n      dri_pipe_blit(ctx->st->pipe,\n                    drawable->textures[ST_ATTACHMENT_FRONT_LEFT],\n                    drawable->msaa_textures[ST_ATTACHMENT_FRONT_LEFT]);\n   }\n\n   if (drawable->textures[ST_ATTACHMENT_FRONT_LEFT]) {\n      pipe->flush_resource(pipe, drawable->textures[ST_ATTACHMENT_FRONT_LEFT]);\n   }\n\n   pipe->flush(pipe, NULL, 0);\n\n   if (image) {\n      image->flushFrontBuffer(dri_drawable, dri_drawable->loaderPrivate);\n   }\n   else if (loader->flushFrontBuffer) {\n      loader->flushFrontBuffer(dri_drawable, dri_drawable->loaderPrivate);\n   }\n}\n\n/**\n * The struct dri_drawable flush_swapbuffers callback\n */\nstatic void\ndri2_flush_swapbuffers(struct dri_context *ctx,\n                       struct dri_drawable *drawable)\n{\n   __DRIdrawable *dri_drawable = drawable->dPriv;\n   const __DRIimageLoaderExtension *image = drawable->sPriv->image.loader;\n\n   if (image && image->base.version >= 3 && image->flushSwapBuffers) {\n      image->flushSwapBuffers(dri_drawable, dri_drawable->loaderPrivate);\n   }\n}\n\nstatic void\ndri2_update_tex_buffer(struct dri_drawable *drawable,\n                       struct dri_context *ctx,\n                       struct pipe_resource *res)\n{\n   /* no-op */\n}\n\nstatic const struct dri2_format_mapping r8_g8b8_mapping = {\n   DRM_FORMAT_NV12,\n   __DRI_IMAGE_FORMAT_NONE,\n   __DRI_IMAGE_COMPONENTS_Y_UV,\n   PIPE_FORMAT_R8_G8B8_420_UNORM,\n   2,\n   { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n     { 1, 1, 1, __DRI_IMAGE_FORMAT_GR88, 2 } }\n};\n\nstatic __DRIimage *\ndri2_create_image_from_winsys(__DRIscreen *_screen,\n                              int width, int height, const struct dri2_format_mapping *map,\n                              int num_handles, struct winsys_handle *whandle,\n                              bool is_protected_content,\n                              void *loaderPrivate)\n{\n   struct dri_screen *screen = dri_screen(_screen);\n   struct pipe_screen *pscreen = screen->base.screen;\n   __DRIimage *img;\n   struct pipe_resource templ;\n   unsigned tex_usage = 0;\n   int i;\n   bool use_lowered = false;\n   const unsigned format_planes = util_format_get_num_planes(map->pipe_format);\n\n   if (pscreen->is_format_supported(pscreen, map->pipe_format, screen->target, 0, 0,\n                                    PIPE_BIND_RENDER_TARGET))\n      tex_usage |= PIPE_BIND_RENDER_TARGET;\n   if (pscreen->is_format_supported(pscreen, map->pipe_format, screen->target, 0, 0,\n                                    PIPE_BIND_SAMPLER_VIEW))\n      tex_usage |= PIPE_BIND_SAMPLER_VIEW;\n   if (is_protected_content)\n      tex_usage |= PIPE_BIND_PROTECTED;\n\n   /* For NV12, see if we have support for sampling r8_b8g8 */\n   if (!tex_usage && map->pipe_format == PIPE_FORMAT_NV12 &&\n       pscreen->is_format_supported(pscreen, PIPE_FORMAT_R8_G8B8_420_UNORM,\n                                    screen->target, 0, 0, PIPE_BIND_SAMPLER_VIEW)) {\n      map = &r8_g8b8_mapping;\n      tex_usage |= PIPE_BIND_SAMPLER_VIEW;\n   }\n\n   if (!tex_usage && util_format_is_yuv(map->pipe_format)) {\n      /* YUV format sampling can be emulated by the GL gallium frontend by\n       * using multiple samplers of varying formats.\n       * If no tex_usage is set and we detect a YUV format,\n       * test for support of all planes' sampler formats and\n       * add sampler view usage.\n       */\n      use_lowered = true;\n      if (dri2_yuv_dma_buf_supported(screen, map))\n         tex_usage |= PIPE_BIND_SAMPLER_VIEW;\n   }\n\n   if (!tex_usage)\n      return NULL;\n\n   img = CALLOC_STRUCT(__DRIimageRec);\n   if (!img)\n      return NULL;\n\n   memset(&templ, 0, sizeof(templ));\n   templ.bind = tex_usage;\n   templ.target = screen->target;\n   templ.last_level = 0;\n   templ.depth0 = 1;\n   templ.array_size = 1;\n\n   for (i = num_handles - 1; i >= format_planes; i--) {\n      struct pipe_resource *tex;\n\n      templ.next = img->texture;\n\n      tex = pscreen->resource_from_handle(pscreen, &templ, &whandle[i],\n                                          PIPE_HANDLE_USAGE_FRAMEBUFFER_WRITE);\n      if (!tex) {\n         pipe_resource_reference(&img->texture, NULL);\n         FREE(img);\n         return NULL;\n      }\n\n      img->texture = tex;\n   }\n\n   for (i = (use_lowered ? map->nplanes : format_planes) - 1; i >= 0; i--) {\n      struct pipe_resource *tex;\n\n      templ.next = img->texture;\n      templ.width0 = width >> map->planes[i].width_shift;\n      templ.height0 = height >> map->planes[i].height_shift;\n      if (use_lowered)\n         templ.format = dri2_get_pipe_format_for_dri_format(map->planes[i].dri_format);\n      else\n         templ.format = map->pipe_format;\n      assert(templ.format != PIPE_FORMAT_NONE);\n\n      tex = pscreen->resource_from_handle(pscreen,\n               &templ, &whandle[use_lowered ? map->planes[i].buffer_index : i],\n               PIPE_HANDLE_USAGE_FRAMEBUFFER_WRITE);\n      if (!tex) {\n         pipe_resource_reference(&img->texture, NULL);\n         FREE(img);\n         return NULL;\n      }\n\n      /* Reject image creation if there's an inconsistency between\n       * content protection status of tex and img.\n       */\n      const struct driOptionCache *optionCache = &screen->dev->option_cache;\n      if (!driQueryOptionb(optionCache, \"disable_protected_content_check\") &&\n          (tex->bind & PIPE_BIND_PROTECTED) != is_protected_content) {\n         pipe_resource_reference(&img->texture, NULL);\n         pipe_resource_reference(&tex, NULL);\n         FREE(img);\n         return NULL;\n      }\n\n      img->texture = tex;\n   }\n\n   img->level = 0;\n   img->layer = 0;\n   img->use = 0;\n   img->loader_private = loaderPrivate;\n   img->sPriv = _screen;\n\n   return img;\n}\n\nstatic __DRIimage *\ndri2_create_image_from_name(__DRIscreen *_screen,\n                            int width, int height, int format,\n                            int name, int pitch, void *loaderPrivate)\n{\n   const struct dri2_format_mapping *map = dri2_get_mapping_by_format(format);\n   struct winsys_handle whandle;\n   __DRIimage *img;\n\n   if (!map)\n      return NULL;\n\n   memset(&whandle, 0, sizeof(whandle));\n   whandle.type = WINSYS_HANDLE_TYPE_SHARED;\n   whandle.handle = name;\n   whandle.format = map->pipe_format;\n   whandle.modifier = DRM_FORMAT_MOD_INVALID;\n\n   whandle.stride = pitch * util_format_get_blocksize(map->pipe_format);\n\n   img = dri2_create_image_from_winsys(_screen, width, height, map,\n                                       1, &whandle, false, loaderPrivate);\n\n   if (!img)\n      return NULL;\n\n   img->dri_components = map->dri_components;\n   img->dri_fourcc = map->dri_fourcc;\n   img->dri_format = map->dri_format;\n\n   return img;\n}\n\nstatic unsigned\ndri2_get_modifier_num_planes(__DRIscreen *_screen,\n                             uint64_t modifier, int fourcc)\n{\n   struct pipe_screen *pscreen = dri_screen(_screen)->base.screen;\n   const struct dri2_format_mapping *map = dri2_get_mapping_by_fourcc(fourcc);\n\n   if (!map)\n      return 0;\n\n   switch (modifier) {\n   case DRM_FORMAT_MOD_LINEAR:\n   /* DRM_FORMAT_MOD_NONE is the same as LINEAR */\n   case DRM_FORMAT_MOD_INVALID:\n      return util_format_get_num_planes(map->pipe_format);\n   default:\n      if (!pscreen->is_dmabuf_modifier_supported ||\n          !pscreen->is_dmabuf_modifier_supported(pscreen, modifier,\n                                                 map->pipe_format, NULL)) {\n         return 0;\n      }\n\n      if (pscreen->get_dmabuf_modifier_planes) {\n         return pscreen->get_dmabuf_modifier_planes(pscreen, modifier,\n                                                    map->pipe_format);\n      }\n\n      return map->nplanes;\n   }\n}\n\nstatic __DRIimage *\ndri2_create_image_from_fd(__DRIscreen *_screen,\n                          int width, int height, int fourcc,\n                          uint64_t modifier, int *fds, int num_fds,\n                          int *strides, int *offsets, bool protected_content,\n                          unsigned *error, void *loaderPrivate)\n{\n   struct winsys_handle whandles[4];\n   const struct dri2_format_mapping *map = dri2_get_mapping_by_fourcc(fourcc);\n   __DRIimage *img = NULL;\n   unsigned err = __DRI_IMAGE_ERROR_SUCCESS;\n   int i;\n   const int expected_num_fds = dri2_get_modifier_num_planes(_screen, modifier, fourcc);\n\n   if (!map || expected_num_fds == 0) {\n      err = __DRI_IMAGE_ERROR_BAD_MATCH;\n      goto exit;\n   }\n\n   if (num_fds != expected_num_fds) {\n      err = __DRI_IMAGE_ERROR_BAD_MATCH;\n      goto exit;\n   }\n\n   memset(whandles, 0, sizeof(whandles));\n\n   for (i = 0; i < num_fds; i++) {\n      if (fds[i] < 0) {\n         err = __DRI_IMAGE_ERROR_BAD_ALLOC;\n         goto exit;\n      }\n\n      whandles[i].type = WINSYS_HANDLE_TYPE_FD;\n      whandles[i].handle = (unsigned)fds[i];\n      whandles[i].stride = (unsigned)strides[i];\n      whandles[i].offset = (unsigned)offsets[i];\n      whandles[i].format = map->pipe_format;\n      whandles[i].modifier = modifier;\n      whandles[i].plane = i;\n   }\n\n   img = dri2_create_image_from_winsys(_screen, width, height, map,\n                                       num_fds, whandles, protected_content,\n                                       loaderPrivate);\n   if(img == NULL) {\n      err = __DRI_IMAGE_ERROR_BAD_ALLOC;\n      goto exit;\n   }\n\n   img->dri_components = map->dri_components;\n   img->dri_fourcc = fourcc;\n   img->dri_format = map->dri_format;\n   img->imported_dmabuf = TRUE;\n\nexit:\n   if (error)\n      *error = err;\n\n   return img;\n}\n\nstatic __DRIimage *\ndri2_create_image_common(__DRIscreen *_screen,\n                         int width, int height,\n                         int format, unsigned int use,\n                         const uint64_t *modifiers,\n                         const unsigned count,\n                         void *loaderPrivate)\n{\n   const struct dri2_format_mapping *map = dri2_get_mapping_by_format(format);\n   struct dri_screen *screen = dri_screen(_screen);\n   struct pipe_screen *pscreen = screen->base.screen;\n   __DRIimage *img;\n   struct pipe_resource templ;\n   unsigned tex_usage = 0;\n\n   if (!map)\n      return NULL;\n\n   if (pscreen->is_format_supported(pscreen, map->pipe_format, screen->target,\n                                    0, 0, PIPE_BIND_RENDER_TARGET))\n      tex_usage |= PIPE_BIND_RENDER_TARGET;\n   if (pscreen->is_format_supported(pscreen, map->pipe_format, screen->target,\n                                    0, 0, PIPE_BIND_SAMPLER_VIEW))\n      tex_usage |= PIPE_BIND_SAMPLER_VIEW;\n\n   if (!tex_usage)\n      return NULL;\n\n   if (use & __DRI_IMAGE_USE_SCANOUT)\n      tex_usage |= PIPE_BIND_SCANOUT;\n   if (use & __DRI_IMAGE_USE_SHARE)\n      tex_usage |= PIPE_BIND_SHARED;\n   if (use & __DRI_IMAGE_USE_LINEAR)\n      tex_usage |= PIPE_BIND_LINEAR;\n   if (use & __DRI_IMAGE_USE_CURSOR) {\n      if (width != 64 || height != 64)\n         return NULL;\n      tex_usage |= PIPE_BIND_CURSOR;\n   }\n   if (use & __DRI_IMAGE_USE_PROTECTED)\n      tex_usage |= PIPE_BIND_PROTECTED;\n\n   img = CALLOC_STRUCT(__DRIimageRec);\n   if (!img)\n      return NULL;\n\n   memset(&templ, 0, sizeof(templ));\n   templ.bind = tex_usage;\n   templ.format = map->pipe_format;\n   templ.target = PIPE_TEXTURE_2D;\n   templ.last_level = 0;\n   templ.width0 = width;\n   templ.height0 = height;\n   templ.depth0 = 1;\n   templ.array_size = 1;\n\n   if (modifiers)\n      img->texture =\n         screen->base.screen\n            ->resource_create_with_modifiers(screen->base.screen,\n                                             &templ,\n                                             modifiers,\n                                             count);\n   else\n      img->texture =\n         screen->base.screen->resource_create(screen->base.screen, &templ);\n   if (!img->texture) {\n      FREE(img);\n      return NULL;\n   }\n\n   img->level = 0;\n   img->layer = 0;\n   img->dri_format = format;\n   img->dri_fourcc = map->dri_fourcc;\n   img->dri_components = 0;\n   img->use = use;\n\n   img->loader_private = loaderPrivate;\n   img->sPriv = _screen;\n   return img;\n}\n\nstatic __DRIimage *\ndri2_create_image(__DRIscreen *_screen,\n                   int width, int height, int format,\n                   unsigned int use, void *loaderPrivate)\n{\n   return dri2_create_image_common(_screen, width, height, format, use,\n                                   NULL /* modifiers */, 0 /* count */,\n                                   loaderPrivate);\n}\n\nstatic __DRIimage *\ndri2_create_image_with_modifiers(__DRIscreen *dri_screen,\n                                 int width, int height, int format,\n                                 const uint64_t *modifiers,\n                                 const unsigned count,\n                                 void *loaderPrivate)\n{\n   return dri2_create_image_common(dri_screen, width, height, format,\n                                   __DRI_IMAGE_USE_SHARE, modifiers, count,\n                                   loaderPrivate);\n}\n\nstatic bool\ndri2_query_image_common(__DRIimage *image, int attrib, int *value)\n{\n   switch (attrib) {\n   case __DRI_IMAGE_ATTRIB_FORMAT:\n      *value = image->dri_format;\n      return true;\n   case __DRI_IMAGE_ATTRIB_WIDTH:\n      *value = image->texture->width0;\n      return true;\n   case __DRI_IMAGE_ATTRIB_HEIGHT:\n      *value = image->texture->height0;\n      return true;\n   case __DRI_IMAGE_ATTRIB_COMPONENTS:\n      if (image->dri_components == 0)\n         return false;\n      *value = image->dri_components;\n      return true;\n   case __DRI_IMAGE_ATTRIB_FOURCC:\n      if (image->dri_fourcc) {\n         *value = image->dri_fourcc;\n      } else {\n         const struct dri2_format_mapping *map;\n\n         map = dri2_get_mapping_by_format(image->dri_format);\n         if (!map)\n            return false;\n\n         *value = map->dri_fourcc;\n      }\n      return true;\n   default:\n      return false;\n   }\n}\n\nstatic bool\ndri2_query_image_by_resource_handle(__DRIimage *image, int attrib, int *value)\n{\n   struct pipe_screen *pscreen = image->texture->screen;\n   struct winsys_handle whandle;\n   struct pipe_resource *tex;\n   unsigned usage;\n   memset(&whandle, 0, sizeof(whandle));\n   whandle.plane = image->plane;\n   int i;\n\n   switch (attrib) {\n   case __DRI_IMAGE_ATTRIB_STRIDE:\n   case __DRI_IMAGE_ATTRIB_OFFSET:\n   case __DRI_IMAGE_ATTRIB_HANDLE:\n      whandle.type = WINSYS_HANDLE_TYPE_KMS;\n      break;\n   case __DRI_IMAGE_ATTRIB_NAME:\n      whandle.type = WINSYS_HANDLE_TYPE_SHARED;\n      break;\n   case __DRI_IMAGE_ATTRIB_FD:\n      whandle.type = WINSYS_HANDLE_TYPE_FD;\n      break;\n   case __DRI_IMAGE_ATTRIB_NUM_PLANES:\n      for (i = 0, tex = image->texture; tex; tex = tex->next)\n         i++;\n      *value = i;\n      return true;\n   case __DRI_IMAGE_ATTRIB_MODIFIER_UPPER:\n   case __DRI_IMAGE_ATTRIB_MODIFIER_LOWER:\n      whandle.type = WINSYS_HANDLE_TYPE_KMS;\n      whandle.modifier = DRM_FORMAT_MOD_INVALID;\n      break;\n   default:\n      return false;\n   }\n\n   usage = PIPE_HANDLE_USAGE_FRAMEBUFFER_WRITE;\n\n   if (image->use & __DRI_IMAGE_USE_BACKBUFFER)\n      usage |= PIPE_HANDLE_USAGE_EXPLICIT_FLUSH;\n\n   if (!pscreen->resource_get_handle(pscreen, NULL, image->texture,\n                                     &whandle, usage))\n      return false;\n\n   switch (attrib) {\n   case __DRI_IMAGE_ATTRIB_STRIDE:\n      *value = whandle.stride;\n      return true;\n   case __DRI_IMAGE_ATTRIB_OFFSET:\n      *value = whandle.offset;\n      return true;\n   case __DRI_IMAGE_ATTRIB_HANDLE:\n   case __DRI_IMAGE_ATTRIB_NAME:\n   case __DRI_IMAGE_ATTRIB_FD:\n      *value = whandle.handle;\n      return true;\n   case __DRI_IMAGE_ATTRIB_MODIFIER_UPPER:\n      if (whandle.modifier == DRM_FORMAT_MOD_INVALID)\n         return false;\n      *value = (whandle.modifier >> 32) & 0xffffffff;\n      return true;\n   case __DRI_IMAGE_ATTRIB_MODIFIER_LOWER:\n      if (whandle.modifier == DRM_FORMAT_MOD_INVALID)\n         return false;\n      *value = whandle.modifier & 0xffffffff;\n      return true;\n   default:\n      return false;\n   }\n}\n\nstatic bool\ndri2_resource_get_param(__DRIimage *image, enum pipe_resource_param param,\n                        unsigned handle_usage, uint64_t *value)\n{\n   struct pipe_screen *pscreen = image->texture->screen;\n   if (!pscreen->resource_get_param)\n      return false;\n\n   return pscreen->resource_get_param(pscreen, NULL, image->texture,\n                                      image->plane, 0, 0, param, handle_usage,\n                                      value);\n}\n\nstatic bool\ndri2_query_image_by_resource_param(__DRIimage *image, int attrib, int *value)\n{\n   enum pipe_resource_param param;\n   uint64_t res_param;\n   unsigned handle_usage;\n\n   if (!image->texture->screen->resource_get_param)\n      return false;\n\n   switch (attrib) {\n   case __DRI_IMAGE_ATTRIB_STRIDE:\n      param = PIPE_RESOURCE_PARAM_STRIDE;\n      break;\n   case __DRI_IMAGE_ATTRIB_OFFSET:\n      param = PIPE_RESOURCE_PARAM_OFFSET;\n      break;\n   case __DRI_IMAGE_ATTRIB_NUM_PLANES:\n      param = PIPE_RESOURCE_PARAM_NPLANES;\n      break;\n   case __DRI_IMAGE_ATTRIB_MODIFIER_UPPER:\n   case __DRI_IMAGE_ATTRIB_MODIFIER_LOWER:\n      param = PIPE_RESOURCE_PARAM_MODIFIER;\n      break;\n   case __DRI_IMAGE_ATTRIB_HANDLE:\n      param = PIPE_RESOURCE_PARAM_HANDLE_TYPE_KMS;\n      break;\n   case __DRI_IMAGE_ATTRIB_NAME:\n      param = PIPE_RESOURCE_PARAM_HANDLE_TYPE_SHARED;\n      break;\n   case __DRI_IMAGE_ATTRIB_FD:\n      param = PIPE_RESOURCE_PARAM_HANDLE_TYPE_FD;\n      break;\n   default:\n      return false;\n   }\n\n   handle_usage = PIPE_HANDLE_USAGE_FRAMEBUFFER_WRITE;\n\n   if (image->use & __DRI_IMAGE_USE_BACKBUFFER)\n      handle_usage |= PIPE_HANDLE_USAGE_EXPLICIT_FLUSH;\n\n   if (!dri2_resource_get_param(image, param, handle_usage, &res_param))\n      return false;\n\n   switch (attrib) {\n   case __DRI_IMAGE_ATTRIB_STRIDE:\n   case __DRI_IMAGE_ATTRIB_OFFSET:\n   case __DRI_IMAGE_ATTRIB_NUM_PLANES:\n      if (res_param > INT_MAX)\n         return false;\n      *value = (int)res_param;\n      return true;\n   case __DRI_IMAGE_ATTRIB_HANDLE:\n   case __DRI_IMAGE_ATTRIB_NAME:\n   case __DRI_IMAGE_ATTRIB_FD:\n      if (res_param > UINT_MAX)\n         return false;\n      *value = (int)res_param;\n      return true;\n   case __DRI_IMAGE_ATTRIB_MODIFIER_UPPER:\n      if (res_param == DRM_FORMAT_MOD_INVALID)\n         return false;\n      *value = (res_param >> 32) & 0xffffffff;\n      return true;\n   case __DRI_IMAGE_ATTRIB_MODIFIER_LOWER:\n      if (res_param == DRM_FORMAT_MOD_INVALID)\n         return false;\n      *value = res_param & 0xffffffff;\n      return true;\n   default:\n      return false;\n   }\n}\n\nstatic GLboolean\ndri2_query_image(__DRIimage *image, int attrib, int *value)\n{\n   if (dri2_query_image_common(image, attrib, value))\n      return GL_TRUE;\n   else if (dri2_query_image_by_resource_param(image, attrib, value))\n      return GL_TRUE;\n   else if (dri2_query_image_by_resource_handle(image, attrib, value))\n      return GL_TRUE;\n   else\n      return GL_FALSE;\n}\n\nstatic __DRIimage *\ndri2_dup_image(__DRIimage *image, void *loaderPrivate)\n{\n   __DRIimage *img;\n\n   img = CALLOC_STRUCT(__DRIimageRec);\n   if (!img)\n      return NULL;\n\n   img->texture = NULL;\n   pipe_resource_reference(&img->texture, image->texture);\n   img->level = image->level;\n   img->layer = image->layer;\n   img->dri_format = image->dri_format;\n   /* This should be 0 for sub images, but dup is also used for base images. */\n   img->dri_components = image->dri_components;\n   img->loader_private = loaderPrivate;\n   img->sPriv = image->sPriv;\n\n   return img;\n}\n\nstatic GLboolean\ndri2_validate_usage(__DRIimage *image, unsigned int use)\n{\n   if (!image || !image->texture)\n      return false;\n\n   struct pipe_screen *screen = image->texture->screen;\n   if (!screen->check_resource_capability)\n      return true;\n\n   /* We don't want to check these:\n    *   __DRI_IMAGE_USE_SHARE (all images are shareable)\n    *   __DRI_IMAGE_USE_BACKBUFFER (all images support this)\n    */\n   unsigned bind = 0;\n   if (use & __DRI_IMAGE_USE_SCANOUT)\n      bind |= PIPE_BIND_SCANOUT;\n   if (use & __DRI_IMAGE_USE_LINEAR)\n      bind |= PIPE_BIND_LINEAR;\n   if (use & __DRI_IMAGE_USE_CURSOR)\n      bind |= PIPE_BIND_CURSOR;\n\n   if (!bind)\n      return true;\n\n   return screen->check_resource_capability(screen, image->texture, bind);\n}\n\nstatic __DRIimage *\ndri2_from_names(__DRIscreen *screen, int width, int height, int format,\n                int *names, int num_names, int *strides, int *offsets,\n                void *loaderPrivate)\n{\n   const struct dri2_format_mapping *map = dri2_get_mapping_by_format(format);\n   __DRIimage *img;\n   struct winsys_handle whandle;\n\n   if (!map)\n      return NULL;\n\n   if (num_names != 1)\n      return NULL;\n\n   memset(&whandle, 0, sizeof(whandle));\n   whandle.type = WINSYS_HANDLE_TYPE_SHARED;\n   whandle.handle = names[0];\n   whandle.stride = strides[0];\n   whandle.offset = offsets[0];\n   whandle.format = map->pipe_format;\n   whandle.modifier = DRM_FORMAT_MOD_INVALID;\n\n   img = dri2_create_image_from_winsys(screen, width, height, map,\n                                       1, &whandle, false, loaderPrivate);\n   if (img == NULL)\n      return NULL;\n\n   img->dri_components = map->dri_components;\n   img->dri_fourcc = map->dri_fourcc;\n   img->dri_format = map->pipe_format;\n\n   return img;\n}\n\nstatic __DRIimage *\ndri2_from_planar(__DRIimage *image, int plane, void *loaderPrivate)\n{\n   __DRIimage *img;\n\n   if (plane < 0) {\n      return NULL;\n   } else if (plane > 0) {\n      uint64_t planes;\n      if (!dri2_resource_get_param(image, PIPE_RESOURCE_PARAM_NPLANES, 0,\n                                   &planes) ||\n          plane >= planes) {\n         return NULL;\n      }\n   }\n\n   if (image->dri_components == 0) {\n      uint64_t modifier;\n      if (!dri2_resource_get_param(image, PIPE_RESOURCE_PARAM_MODIFIER, 0,\n                                   &modifier) ||\n          modifier == DRM_FORMAT_MOD_INVALID) {\n         return NULL;\n      }\n   }\n\n   img = dri2_dup_image(image, loaderPrivate);\n   if (img == NULL)\n      return NULL;\n\n   if (img->texture->screen->resource_changed)\n      img->texture->screen->resource_changed(img->texture->screen,\n                                             img->texture);\n\n   /* set this to 0 for sub images. */\n   img->dri_components = 0;\n   img->plane = plane;\n   return img;\n}\n\nstatic __DRIimage *\ndri2_from_fds(__DRIscreen *screen, int width, int height, int fourcc,\n              int *fds, int num_fds, int *strides, int *offsets,\n              void *loaderPrivate)\n{\n   return dri2_create_image_from_fd(screen, width, height, fourcc,\n                                   DRM_FORMAT_MOD_INVALID, fds, num_fds,\n                                   strides, offsets, false, NULL, loaderPrivate);\n}\n\nstatic boolean\ndri2_query_dma_buf_modifiers(__DRIscreen *_screen, int fourcc, int max,\n                             uint64_t *modifiers, unsigned int *external_only,\n                             int *count)\n{\n   struct dri_screen *screen = dri_screen(_screen);\n   struct pipe_screen *pscreen = screen->base.screen;\n   const struct dri2_format_mapping *map = dri2_get_mapping_by_fourcc(fourcc);\n   enum pipe_format format;\n\n   if (!map)\n      return false;\n\n   format = map->pipe_format;\n\n   if (pscreen->is_format_supported(pscreen, format, screen->target, 0, 0,\n                                     PIPE_BIND_RENDER_TARGET) ||\n        pscreen->is_format_supported(pscreen, format, screen->target, 0, 0,\n                                     PIPE_BIND_SAMPLER_VIEW) ||\n        dri2_yuv_dma_buf_supported(screen, map)) {\n      if (pscreen->query_dmabuf_modifiers != NULL)\n         pscreen->query_dmabuf_modifiers(pscreen, format, max, modifiers,\n                                         external_only, count);\n      else\n         *count = 0;\n      return true;\n   }\n   return false;\n}\n\nstatic boolean\ndri2_query_dma_buf_format_modifier_attribs(__DRIscreen *_screen,\n                                           uint32_t fourcc, uint64_t modifier,\n                                           int attrib, uint64_t *value)\n{\n   struct dri_screen *screen = dri_screen(_screen);\n   struct pipe_screen *pscreen = screen->base.screen;\n\n   if (!pscreen->query_dmabuf_modifiers)\n      return false;\n\n   switch (attrib) {\n   case __DRI_IMAGE_FORMAT_MODIFIER_ATTRIB_PLANE_COUNT: {\n      uint64_t mod_planes = dri2_get_modifier_num_planes(_screen, modifier,\n                                                         fourcc);\n      if (mod_planes > 0)\n         *value = mod_planes;\n      return mod_planes > 0;\n   }\n   default:\n      return false;\n   }\n}\n\nstatic __DRIimage *\ndri2_from_dma_bufs(__DRIscreen *screen,\n                   int width, int height, int fourcc,\n                   int *fds, int num_fds,\n                   int *strides, int *offsets,\n                   enum __DRIYUVColorSpace yuv_color_space,\n                   enum __DRISampleRange sample_range,\n                   enum __DRIChromaSiting horizontal_siting,\n                   enum __DRIChromaSiting vertical_siting,\n                   unsigned *error,\n                   void *loaderPrivate)\n{\n   __DRIimage *img;\n\n   img = dri2_create_image_from_fd(screen, width, height, fourcc,\n                                   DRM_FORMAT_MOD_INVALID, fds, num_fds,\n                                   strides, offsets, false, error, loaderPrivate);\n   if (img == NULL)\n      return NULL;\n\n   img->yuv_color_space = yuv_color_space;\n   img->sample_range = sample_range;\n   img->horizontal_siting = horizontal_siting;\n   img->vertical_siting = vertical_siting;\n\n   *error = __DRI_IMAGE_ERROR_SUCCESS;\n   return img;\n}\n\nstatic __DRIimage *\ndri2_from_dma_bufs2(__DRIscreen *screen,\n                    int width, int height, int fourcc,\n                    uint64_t modifier, int *fds, int num_fds,\n                    int *strides, int *offsets,\n                    enum __DRIYUVColorSpace yuv_color_space,\n                    enum __DRISampleRange sample_range,\n                    enum __DRIChromaSiting horizontal_siting,\n                    enum __DRIChromaSiting vertical_siting,\n                    unsigned *error,\n                    void *loaderPrivate)\n{\n   __DRIimage *img;\n\n   img = dri2_create_image_from_fd(screen, width, height, fourcc,\n                                   modifier, fds, num_fds, strides, offsets,\n                                   false, error, loaderPrivate);\n   if (img == NULL)\n      return NULL;\n\n   img->yuv_color_space = yuv_color_space;\n   img->sample_range = sample_range;\n   img->horizontal_siting = horizontal_siting;\n   img->vertical_siting = vertical_siting;\n\n   *error = __DRI_IMAGE_ERROR_SUCCESS;\n   return img;\n}\n\nstatic __DRIimage *\ndri2_from_dma_bufs3(__DRIscreen *screen,\n                    int width, int height, int fourcc,\n                    uint64_t modifier, int *fds, int num_fds,\n                    int *strides, int *offsets,\n                    enum __DRIYUVColorSpace yuv_color_space,\n                    enum __DRISampleRange sample_range,\n                    enum __DRIChromaSiting horizontal_siting,\n                    enum __DRIChromaSiting vertical_siting,\n                    uint32_t flags,\n                    unsigned *error,\n                    void *loaderPrivate)\n{\n   __DRIimage *img;\n\n   img = dri2_create_image_from_fd(screen, width, height, fourcc,\n                                   modifier, fds, num_fds, strides, offsets,\n                                   flags & __DRI_IMAGE_PROTECTED_CONTENT_FLAG,\n                                   error, loaderPrivate);\n   if (img == NULL)\n      return NULL;\n\n   img->yuv_color_space = yuv_color_space;\n   img->sample_range = sample_range;\n   img->horizontal_siting = horizontal_siting;\n   img->vertical_siting = vertical_siting;\n\n   *error = __DRI_IMAGE_ERROR_SUCCESS;\n   return img;\n}\n\nstatic void\ndri2_blit_image(__DRIcontext *context, __DRIimage *dst, __DRIimage *src,\n                int dstx0, int dsty0, int dstwidth, int dstheight,\n                int srcx0, int srcy0, int srcwidth, int srcheight,\n                int flush_flag)\n{\n   struct dri_context *ctx = dri_context(context);\n   struct pipe_context *pipe = ctx->st->pipe;\n   struct pipe_screen *screen;\n   struct pipe_fence_handle *fence;\n   struct pipe_blit_info blit;\n\n   if (!dst || !src)\n      return;\n\n   memset(&blit, 0, sizeof(blit));\n   blit.dst.resource = dst->texture;\n   blit.dst.box.x = dstx0;\n   blit.dst.box.y = dsty0;\n   blit.dst.box.width = dstwidth;\n   blit.dst.box.height = dstheight;\n   blit.dst.box.depth = 1;\n   blit.dst.format = dst->texture->format;\n   blit.src.resource = src->texture;\n   blit.src.box.x = srcx0;\n   blit.src.box.y = srcy0;\n   blit.src.box.width = srcwidth;\n   blit.src.box.height = srcheight;\n   blit.src.box.depth = 1;\n   blit.src.format = src->texture->format;\n   blit.mask = PIPE_MASK_RGBA;\n   blit.filter = PIPE_TEX_FILTER_NEAREST;\n\n   pipe->blit(pipe, &blit);\n\n   if (flush_flag == __BLIT_FLAG_FLUSH) {\n      pipe->flush_resource(pipe, dst->texture);\n      ctx->st->flush(ctx->st, 0, NULL, NULL, NULL);\n   } else if (flush_flag == __BLIT_FLAG_FINISH) {\n      screen = dri_screen(ctx->sPriv)->base.screen;\n      pipe->flush_resource(pipe, dst->texture);\n      ctx->st->flush(ctx->st, 0, &fence, NULL, NULL);\n      (void) screen->fence_finish(screen, NULL, fence, PIPE_TIMEOUT_INFINITE);\n      screen->fence_reference(screen, &fence, NULL);\n   }\n}\n\nstatic void *\ndri2_map_image(__DRIcontext *context, __DRIimage *image,\n                int x0, int y0, int width, int height,\n                unsigned int flags, int *stride, void **data)\n{\n   struct dri_context *ctx = dri_context(context);\n   struct pipe_context *pipe = ctx->st->pipe;\n   enum pipe_map_flags pipe_access = 0;\n   struct pipe_transfer *trans;\n   void *map;\n\n   if (!image || !data || *data)\n      return NULL;\n\n   unsigned plane = image->plane;\n   if (plane >= dri2_get_mapping_by_format(image->dri_format)->nplanes)\n      return NULL;\n\n   struct pipe_resource *resource = image->texture;\n   while (plane--)\n      resource = resource->next;\n\n   if (flags & __DRI_IMAGE_TRANSFER_READ)\n         pipe_access |= PIPE_MAP_READ;\n   if (flags & __DRI_IMAGE_TRANSFER_WRITE)\n         pipe_access |= PIPE_MAP_WRITE;\n\n   map = pipe_transfer_map(pipe, resource, 0, 0, pipe_access, x0, y0,\n                           width, height, &trans);\n   if (map) {\n      *data = trans;\n      *stride = trans->stride;\n   }\n\n   return map;\n}\n\nstatic void\ndri2_unmap_image(__DRIcontext *context, __DRIimage *image, void *data)\n{\n   struct dri_context *ctx = dri_context(context);\n   struct pipe_context *pipe = ctx->st->pipe;\n\n   pipe_transfer_unmap(pipe, (struct pipe_transfer *)data);\n}\n\nstatic int\ndri2_get_capabilities(__DRIscreen *_screen)\n{\n   struct dri_screen *screen = dri_screen(_screen);\n\n   return (screen->can_share_buffer ? __DRI_IMAGE_CAP_GLOBAL_NAMES : 0);\n}\n\n/* The extension is modified during runtime if DRI_PRIME is detected */\nstatic const __DRIimageExtension dri2ImageExtensionTempl = {\n    .base = { __DRI_IMAGE, 18 },\n\n    .createImageFromName          = dri2_create_image_from_name,\n    .createImageFromRenderbuffer  = dri2_create_image_from_renderbuffer,\n    .destroyImage                 = dri2_destroy_image,\n    .createImage                  = dri2_create_image,\n    .queryImage                   = dri2_query_image,\n    .dupImage                     = dri2_dup_image,\n    .validateUsage                = dri2_validate_usage,\n    .createImageFromNames         = dri2_from_names,\n    .fromPlanar                   = dri2_from_planar,\n    .createImageFromTexture       = dri2_create_from_texture,\n    .createImageFromFds           = NULL,\n    .createImageFromDmaBufs       = NULL,\n    .blitImage                    = dri2_blit_image,\n    .getCapabilities              = dri2_get_capabilities,\n    .mapImage                     = dri2_map_image,\n    .unmapImage                   = dri2_unmap_image,\n    .createImageWithModifiers     = NULL,\n    .createImageFromDmaBufs2      = NULL,\n    .createImageFromDmaBufs3      = NULL,\n    .queryDmaBufFormats           = NULL,\n    .queryDmaBufModifiers         = NULL,\n    .queryDmaBufFormatModifierAttribs = NULL,\n    .createImageFromRenderbuffer2 = dri2_create_image_from_renderbuffer2,\n};\n\nstatic const __DRIrobustnessExtension dri2Robustness = {\n   .base = { __DRI2_ROBUSTNESS, 1 }\n};\n\nstatic int\ndri2_interop_query_device_info(__DRIcontext *_ctx,\n                               struct mesa_glinterop_device_info *out)\n{\n   struct pipe_screen *screen = dri_context(_ctx)->st->pipe->screen;\n\n   /* There is no version 0, thus we do not support it */\n   if (out->version == 0)\n      return MESA_GLINTEROP_INVALID_VERSION;\n\n   out->pci_segment_group = screen->get_param(screen, PIPE_CAP_PCI_GROUP);\n   out->pci_bus = screen->get_param(screen, PIPE_CAP_PCI_BUS);\n   out->pci_device = screen->get_param(screen, PIPE_CAP_PCI_DEVICE);\n   out->pci_function = screen->get_param(screen, PIPE_CAP_PCI_FUNCTION);\n\n   out->vendor_id = screen->get_param(screen, PIPE_CAP_VENDOR_ID);\n   out->device_id = screen->get_param(screen, PIPE_CAP_DEVICE_ID);\n\n   /* Instruct the caller that we support up-to version one of the interface */\n   out->version = 1;\n\n   return MESA_GLINTEROP_SUCCESS;\n}\n\nstatic int\ndri2_interop_export_object(__DRIcontext *_ctx,\n                           struct mesa_glinterop_export_in *in,\n                           struct mesa_glinterop_export_out *out)\n{\n   struct st_context_iface *st = dri_context(_ctx)->st;\n   struct pipe_screen *screen = st->pipe->screen;\n   struct gl_context *ctx = ((struct st_context *)st)->ctx;\n   struct pipe_resource *res = NULL;\n   struct winsys_handle whandle;\n   unsigned target, usage;\n   boolean success;\n\n   /* There is no version 0, thus we do not support it */\n   if (in->version == 0 || out->version == 0)\n      return MESA_GLINTEROP_INVALID_VERSION;\n\n   /* Validate the target. */\n   switch (in->target) {\n   case GL_TEXTURE_BUFFER:\n   case GL_TEXTURE_1D:\n   case GL_TEXTURE_2D:\n   case GL_TEXTURE_3D:\n   case GL_TEXTURE_RECTANGLE:\n   case GL_TEXTURE_1D_ARRAY:\n   case GL_TEXTURE_2D_ARRAY:\n   case GL_TEXTURE_CUBE_MAP_ARRAY:\n   case GL_TEXTURE_CUBE_MAP:\n   case GL_TEXTURE_2D_MULTISAMPLE:\n   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:\n   case GL_TEXTURE_EXTERNAL_OES:\n   case GL_RENDERBUFFER:\n   case GL_ARRAY_BUFFER:\n      target = in->target;\n      break;\n   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:\n   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:\n   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:\n   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:\n   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:\n   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:\n      target = GL_TEXTURE_CUBE_MAP;\n      break;\n   default:\n      return MESA_GLINTEROP_INVALID_TARGET;\n   }\n\n   /* Validate the simple case of miplevel. */\n   if ((target == GL_RENDERBUFFER || target == GL_ARRAY_BUFFER) &&\n       in->miplevel != 0)\n      return MESA_GLINTEROP_INVALID_MIP_LEVEL;\n\n   /* Validate the OpenGL object and get pipe_resource. */\n   simple_mtx_lock(&ctx->Shared->Mutex);\n\n   if (target == GL_ARRAY_BUFFER) {\n      /* Buffer objects.\n       *\n       * The error checking is based on the documentation of\n       * clCreateFromGLBuffer from OpenCL 2.0 SDK.\n       */\n      struct gl_buffer_object *buf = _mesa_lookup_bufferobj(ctx, in->obj);\n\n      /* From OpenCL 2.0 SDK, clCreateFromGLBuffer:\n       *  \"CL_INVALID_GL_OBJECT if bufobj is not a GL buffer object or is\n       *   a GL buffer object but does not have an existing data store or\n       *   the size of the buffer is 0.\"\n       */\n      if (!buf || buf->Size == 0) {\n         simple_mtx_unlock(&ctx->Shared->Mutex);\n         return MESA_GLINTEROP_INVALID_OBJECT;\n      }\n\n      res = st_buffer_object(buf)->buffer;\n      if (!res) {\n         /* this shouldn't happen */\n         simple_mtx_unlock(&ctx->Shared->Mutex);\n         return MESA_GLINTEROP_INVALID_OBJECT;\n      }\n\n      out->buf_offset = 0;\n      out->buf_size = buf->Size;\n\n      buf->UsageHistory |= USAGE_DISABLE_MINMAX_CACHE;\n   } else if (target == GL_RENDERBUFFER) {\n      /* Renderbuffers.\n       *\n       * The error checking is based on the documentation of\n       * clCreateFromGLRenderbuffer from OpenCL 2.0 SDK.\n       */\n      struct gl_renderbuffer *rb = _mesa_lookup_renderbuffer(ctx, in->obj);\n\n      /* From OpenCL 2.0 SDK, clCreateFromGLRenderbuffer:\n       *   \"CL_INVALID_GL_OBJECT if renderbuffer is not a GL renderbuffer\n       *    object or if the width or height of renderbuffer is zero.\"\n       */\n      if (!rb || rb->Width == 0 || rb->Height == 0) {\n         simple_mtx_unlock(&ctx->Shared->Mutex);\n         return MESA_GLINTEROP_INVALID_OBJECT;\n      }\n\n      /* From OpenCL 2.0 SDK, clCreateFromGLRenderbuffer:\n       *   \"CL_INVALID_OPERATION if renderbuffer is a multi-sample GL\n       *    renderbuffer object.\"\n       */\n      if (rb->NumSamples > 1) {\n         simple_mtx_unlock(&ctx->Shared->Mutex);\n         return MESA_GLINTEROP_INVALID_OPERATION;\n      }\n\n      /* From OpenCL 2.0 SDK, clCreateFromGLRenderbuffer:\n       *   \"CL_OUT_OF_RESOURCES if there is a failure to allocate resources\n       *    required by the OpenCL implementation on the device.\"\n       */\n      res = st_renderbuffer(rb)->texture;\n      if (!res) {\n         simple_mtx_unlock(&ctx->Shared->Mutex);\n         return MESA_GLINTEROP_OUT_OF_RESOURCES;\n      }\n\n      out->internal_format = rb->InternalFormat;\n      out->view_minlevel = 0;\n      out->view_numlevels = 1;\n      out->view_minlayer = 0;\n      out->view_numlayers = 1;\n   } else {\n      /* Texture objects.\n       *\n       * The error checking is based on the documentation of\n       * clCreateFromGLTexture from OpenCL 2.0 SDK.\n       */\n      struct gl_texture_object *obj = _mesa_lookup_texture(ctx, in->obj);\n\n      if (obj)\n         _mesa_test_texobj_completeness(ctx, obj);\n\n      /* From OpenCL 2.0 SDK, clCreateFromGLTexture:\n       *   \"CL_INVALID_GL_OBJECT if texture is not a GL texture object whose\n       *    type matches texture_target, if the specified miplevel of texture\n       *    is not defined, or if the width or height of the specified\n       *    miplevel is zero or if the GL texture object is incomplete.\"\n       */\n      if (!obj ||\n          obj->Target != target ||\n          !obj->_BaseComplete ||\n          (in->miplevel > 0 && !obj->_MipmapComplete)) {\n         simple_mtx_unlock(&ctx->Shared->Mutex);\n         return MESA_GLINTEROP_INVALID_OBJECT;\n      }\n\n      if (target == GL_TEXTURE_BUFFER) {\n         struct st_buffer_object *stBuf =\n            st_buffer_object(obj->BufferObject);\n\n         if (!stBuf || !stBuf->buffer) {\n            /* this shouldn't happen */\n            simple_mtx_unlock(&ctx->Shared->Mutex);\n            return MESA_GLINTEROP_INVALID_OBJECT;\n         }\n         res = stBuf->buffer;\n\n         out->internal_format = obj->BufferObjectFormat;\n         out->buf_offset = obj->BufferOffset;\n         out->buf_size = obj->BufferSize == -1 ? obj->BufferObject->Size :\n                                                 obj->BufferSize;\n\n         obj->BufferObject->UsageHistory |= USAGE_DISABLE_MINMAX_CACHE;\n      } else {\n         /* From OpenCL 2.0 SDK, clCreateFromGLTexture:\n          *   \"CL_INVALID_MIP_LEVEL if miplevel is less than the value of\n          *    levelbase (for OpenGL implementations) or zero (for OpenGL ES\n          *    implementations); or greater than the value of q (for both OpenGL\n          *    and OpenGL ES). levelbase and q are defined for the texture in\n          *    section 3.8.10 (Texture Completeness) of the OpenGL 2.1\n          *    specification and section 3.7.10 of the OpenGL ES 2.0.\"\n          */\n         if (in->miplevel < obj->Attrib.BaseLevel || in->miplevel > obj->_MaxLevel) {\n            simple_mtx_unlock(&ctx->Shared->Mutex);\n            return MESA_GLINTEROP_INVALID_MIP_LEVEL;\n         }\n\n         if (!st_finalize_texture(ctx, st->pipe, obj, 0)) {\n            simple_mtx_unlock(&ctx->Shared->Mutex);\n            return MESA_GLINTEROP_OUT_OF_RESOURCES;\n         }\n\n         res = st_get_texobj_resource(obj);\n         if (!res) {\n            /* Incomplete texture buffer object? This shouldn't really occur. */\n            simple_mtx_unlock(&ctx->Shared->Mutex);\n            return MESA_GLINTEROP_INVALID_OBJECT;\n         }\n\n         out->internal_format = obj->Image[0][0]->InternalFormat;\n         out->view_minlevel = obj->Attrib.MinLevel;\n         out->view_numlevels = obj->Attrib.NumLevels;\n         out->view_minlayer = obj->Attrib.MinLayer;\n         out->view_numlayers = obj->Attrib.NumLayers;\n      }\n   }\n\n   /* Get the handle. */\n   switch (in->access) {\n   case MESA_GLINTEROP_ACCESS_READ_ONLY:\n      usage = 0;\n      break;\n   case MESA_GLINTEROP_ACCESS_READ_WRITE:\n   case MESA_GLINTEROP_ACCESS_WRITE_ONLY:\n      usage = PIPE_HANDLE_USAGE_SHADER_WRITE;\n      break;\n   default:\n      usage = 0;\n   }\n\n   memset(&whandle, 0, sizeof(whandle));\n   whandle.type = WINSYS_HANDLE_TYPE_FD;\n\n   success = screen->resource_get_handle(screen, st->pipe, res, &whandle,\n                                         usage);\n   simple_mtx_unlock(&ctx->Shared->Mutex);\n\n   if (!success)\n      return MESA_GLINTEROP_OUT_OF_HOST_MEMORY;\n\n   out->dmabuf_fd = whandle.handle;\n   out->out_driver_data_written = 0;\n\n   if (res->target == PIPE_BUFFER)\n      out->buf_offset += whandle.offset;\n\n   /* Instruct the caller that we support up-to version one of the interface */\n   in->version = 1;\n   out->version = 1;\n\n   return MESA_GLINTEROP_SUCCESS;\n}\n\nstatic const __DRI2interopExtension dri2InteropExtension = {\n   .base = { __DRI2_INTEROP, 1 },\n   .query_device_info = dri2_interop_query_device_info,\n   .export_object = dri2_interop_export_object\n};\n\n/**\n * \\brief the DRI2bufferDamageExtension set_damage_region method\n */\nstatic void\ndri2_set_damage_region(__DRIdrawable *dPriv, unsigned int nrects, int *rects)\n{\n   struct dri_drawable *drawable = dri_drawable(dPriv);\n   struct pipe_box *boxes = NULL;\n\n   if (nrects) {\n      boxes = CALLOC(nrects, sizeof(*boxes));\n      assert(boxes);\n\n      for (unsigned int i = 0; i < nrects; i++) {\n         int *rect = &rects[i * 4];\n\n         u_box_2d(rect[0], rect[1], rect[2], rect[3], &boxes[i]);\n      }\n   }\n\n   FREE(drawable->damage_rects);\n   drawable->damage_rects = boxes;\n   drawable->num_damage_rects = nrects;\n\n   /* Only apply the damage region if the BACK_LEFT texture is up-to-date. */\n   if (drawable->texture_stamp == drawable->dPriv->lastStamp &&\n       (drawable->texture_mask & (1 << ST_ATTACHMENT_BACK_LEFT))) {\n      struct pipe_screen *screen = drawable->screen->base.screen;\n      struct pipe_resource *resource;\n\n      if (drawable->stvis.samples > 1)\n         resource = drawable->msaa_textures[ST_ATTACHMENT_BACK_LEFT];\n      else\n         resource = drawable->textures[ST_ATTACHMENT_BACK_LEFT];\n\n      screen->set_damage_region(screen, resource,\n                                drawable->num_damage_rects,\n                                drawable->damage_rects);\n   }\n}\n\nstatic const __DRI2bufferDamageExtension dri2BufferDamageExtensionTempl = {\n   .base = { __DRI2_BUFFER_DAMAGE, 1 },\n};\n\n/**\n * \\brief the DRI2ConfigQueryExtension configQueryb method\n */\nstatic int\ndri2GalliumConfigQueryb(__DRIscreen *sPriv, const char *var,\n                        unsigned char *val)\n{\n   struct dri_screen *screen = dri_screen(sPriv);\n\n   if (!driCheckOption(&screen->dev->option_cache, var, DRI_BOOL))\n      return dri2ConfigQueryExtension.configQueryb(sPriv, var, val);\n\n   *val = driQueryOptionb(&screen->dev->option_cache, var);\n\n   return 0;\n}\n\n/**\n * \\brief the DRI2ConfigQueryExtension configQueryi method\n */\nstatic int\ndri2GalliumConfigQueryi(__DRIscreen *sPriv, const char *var, int *val)\n{\n   struct dri_screen *screen = dri_screen(sPriv);\n\n   if (!driCheckOption(&screen->dev->option_cache, var, DRI_INT) &&\n       !driCheckOption(&screen->dev->option_cache, var, DRI_ENUM))\n      return dri2ConfigQueryExtension.configQueryi(sPriv, var, val);\n\n    *val = driQueryOptioni(&screen->dev->option_cache, var);\n\n    return 0;\n}\n\n/**\n * \\brief the DRI2ConfigQueryExtension configQueryf method\n */\nstatic int\ndri2GalliumConfigQueryf(__DRIscreen *sPriv, const char *var, float *val)\n{\n   struct dri_screen *screen = dri_screen(sPriv);\n\n   if (!driCheckOption(&screen->dev->option_cache, var, DRI_FLOAT))\n      return dri2ConfigQueryExtension.configQueryf(sPriv, var, val);\n\n    *val = driQueryOptionf(&screen->dev->option_cache, var);\n\n    return 0;\n}\n\n/**\n * \\brief the DRI2ConfigQueryExtension configQuerys method\n */\nstatic int\ndri2GalliumConfigQuerys(__DRIscreen *sPriv, const char *var, char **val)\n{\n   struct dri_screen *screen = dri_screen(sPriv);\n\n   if (!driCheckOption(&screen->dev->option_cache, var, DRI_STRING))\n      return dri2ConfigQueryExtension.configQuerys(sPriv, var, val);\n\n    *val = driQueryOptionstr(&screen->dev->option_cache, var);\n\n    return 0;\n}\n\n/**\n * \\brief the DRI2ConfigQueryExtension struct.\n *\n * We first query the driver option cache. Then the dri2 option cache.\n */\nstatic const __DRI2configQueryExtension dri2GalliumConfigQueryExtension = {\n   .base = { __DRI2_CONFIG_QUERY, 2 },\n\n   .configQueryb        = dri2GalliumConfigQueryb,\n   .configQueryi        = dri2GalliumConfigQueryi,\n   .configQueryf        = dri2GalliumConfigQueryf,\n   .configQuerys        = dri2GalliumConfigQuerys,\n};\n\n/**\n * \\brief the DRI2blobExtension set_cache_funcs method\n */\nstatic void\nset_blob_cache_funcs(__DRIscreen *sPriv, __DRIblobCacheSet set,\n                     __DRIblobCacheGet get)\n{\n   struct dri_screen *screen = dri_screen(sPriv);\n   struct pipe_screen *pscreen = screen->base.screen;\n\n   if (!pscreen->get_disk_shader_cache)\n      return;\n\n   struct disk_cache *cache = pscreen->get_disk_shader_cache(pscreen);\n\n   if (!cache)\n      return;\n\n   disk_cache_set_callbacks(cache, set, get);\n}\n\nstatic const __DRI2blobExtension driBlobExtension = {\n   .base = { __DRI2_BLOB, 1 },\n   .set_cache_funcs = set_blob_cache_funcs\n};\n\n/*\n * Backend function init_screen.\n */\n\nstatic const __DRIextension *dri_screen_extensions_base[] = {\n   &driTexBufferExtension.base,\n   &dri2FlushExtension.base,\n   &dri2RendererQueryExtension.base,\n   &dri2GalliumConfigQueryExtension.base,\n   &dri2ThrottleExtension.base,\n   &dri2FenceExtension.base,\n   &dri2InteropExtension.base,\n   &dri2NoErrorExtension.base,\n   &driBlobExtension.base,\n};\n\n/**\n * Set up the DRI extension list for this screen based on its underlying\n * gallium screen's capabilities.\n */\nstatic void\ndri2_init_screen_extensions(struct dri_screen *screen,\n                            struct pipe_screen *pscreen,\n                            bool is_kms_screen)\n{\n   const __DRIextension **nExt;\n\n   STATIC_ASSERT(sizeof(screen->screen_extensions) >=\n                 sizeof(dri_screen_extensions_base));\n   memcpy(&screen->screen_extensions, dri_screen_extensions_base,\n          sizeof(dri_screen_extensions_base));\n   screen->sPriv->extensions = screen->screen_extensions;\n\n   /* Point nExt at the end of the extension list */\n   nExt = &screen->screen_extensions[ARRAY_SIZE(dri_screen_extensions_base)];\n\n   screen->image_extension = dri2ImageExtensionTempl;\n   if (pscreen->resource_create_with_modifiers)\n      screen->image_extension.createImageWithModifiers =\n         dri2_create_image_with_modifiers;\n\n   if (pscreen->get_param(pscreen, PIPE_CAP_DMABUF)) {\n      uint64_t cap;\n\n      if (drmGetCap(screen->sPriv->fd, DRM_CAP_PRIME, &cap) == 0 &&\n          (cap & DRM_PRIME_CAP_IMPORT)) {\n         screen->image_extension.createImageFromFds = dri2_from_fds;\n         screen->image_extension.createImageFromDmaBufs = dri2_from_dma_bufs;\n         screen->image_extension.createImageFromDmaBufs2 = dri2_from_dma_bufs2;\n         screen->image_extension.createImageFromDmaBufs3 = dri2_from_dma_bufs3;\n         screen->image_extension.queryDmaBufFormats =\n            dri2_query_dma_buf_formats;\n         screen->image_extension.queryDmaBufModifiers =\n            dri2_query_dma_buf_modifiers;\n         if (!is_kms_screen) {\n            screen->image_extension.queryDmaBufFormatModifierAttribs =\n               dri2_query_dma_buf_format_modifier_attribs;\n         }\n      }\n   }\n   *nExt++ = &screen->image_extension.base;\n\n   if (!is_kms_screen) {\n      screen->buffer_damage_extension = dri2BufferDamageExtensionTempl;\n      if (pscreen->set_damage_region)\n         screen->buffer_damage_extension.set_damage_region =\n            dri2_set_damage_region;\n      *nExt++ = &screen->buffer_damage_extension.base;\n\n      if (pscreen->get_param(pscreen, PIPE_CAP_DEVICE_RESET_STATUS_QUERY)) {\n         *nExt++ = &dri2Robustness.base;\n         screen->has_reset_status_query = true;\n      }\n   }\n\n   /* Ensure the extension list didn't overrun its buffer and is still\n    * NULL-terminated */\n   assert(nExt - screen->screen_extensions <=\n          ARRAY_SIZE(screen->screen_extensions) - 1);\n   assert(!*nExt);\n}\n\n/**\n * This is the driver specific part of the createNewScreen entry point.\n *\n * Returns the struct gl_config supported by this driver.\n */\nstatic const __DRIconfig **\ndri2_init_screen(__DRIscreen * sPriv)\n{\n   const __DRIconfig **configs;\n   struct dri_screen *screen;\n   struct pipe_screen *pscreen = NULL;\n\n   screen = CALLOC_STRUCT(dri_screen);\n   if (!screen)\n      return NULL;\n\n   screen->sPriv = sPriv;\n   screen->fd = sPriv->fd;\n   (void) mtx_init(&screen->opencl_func_mutex, mtx_plain);\n\n   sPriv->driverPrivate = (void *)screen;\n\n   if (pipe_loader_drm_probe_fd(&screen->dev, screen->fd)) {\n      dri_init_options(screen);\n\n      pscreen = pipe_loader_create_screen(screen->dev);\n   }\n\n   if (!pscreen)\n       goto release_pipe;\n\n   screen->throttle = pscreen->get_param(pscreen, PIPE_CAP_THROTTLE);\n\n   dri2_init_screen_extensions(screen, pscreen, false);\n\n   configs = dri_init_screen_helper(screen, pscreen);\n   if (!configs)\n      goto destroy_screen;\n\n   screen->can_share_buffer = true;\n   screen->auto_fake_front = dri_with_format(sPriv);\n   screen->broken_invalidate = !sPriv->dri2.useInvalidate;\n   screen->lookup_egl_image = dri2_lookup_egl_image;\n\n   return configs;\n\ndestroy_screen:\n   dri_destroy_screen_helper(screen);\n\nrelease_pipe:\n   if (screen->dev)\n      pipe_loader_release(&screen->dev, 1);\n\n   FREE(screen);\n   return NULL;\n}\n\n/**\n * This is the driver specific part of the createNewScreen entry point.\n *\n * Returns the struct gl_config supported by this driver.\n */\nstatic const __DRIconfig **\ndri_kms_init_screen(__DRIscreen * sPriv)\n{\n#if defined(GALLIUM_SOFTPIPE)\n   const __DRIconfig **configs;\n   struct dri_screen *screen;\n   struct pipe_screen *pscreen = NULL;\n\n   screen = CALLOC_STRUCT(dri_screen);\n   if (!screen)\n      return NULL;\n\n   screen->sPriv = sPriv;\n   screen->fd = sPriv->fd;\n\n   sPriv->driverPrivate = (void *)screen;\n\n   if (pipe_loader_sw_probe_kms(&screen->dev, screen->fd)) {\n      dri_init_options(screen);\n      pscreen = pipe_loader_create_screen(screen->dev);\n   }\n\n   if (!pscreen)\n       goto release_pipe;\n\n   dri2_init_screen_extensions(screen, pscreen, true);\n\n   configs = dri_init_screen_helper(screen, pscreen);\n   if (!configs)\n      goto destroy_screen;\n\n   screen->can_share_buffer = false;\n   screen->auto_fake_front = dri_with_format(sPriv);\n   screen->broken_invalidate = !sPriv->dri2.useInvalidate;\n   screen->lookup_egl_image = dri2_lookup_egl_image;\n\n   return configs;\n\ndestroy_screen:\n   dri_destroy_screen_helper(screen);\n\nrelease_pipe:\n   if (screen->dev)\n      pipe_loader_release(&screen->dev, 1);\n\n   FREE(screen);\n#endif // GALLIUM_SOFTPIPE\n   return NULL;\n}\n\nstatic boolean\ndri2_create_buffer(__DRIscreen * sPriv,\n                   __DRIdrawable * dPriv,\n                   const struct gl_config * visual, boolean isPixmap)\n{\n   struct dri_drawable *drawable = NULL;\n\n   if (!dri_create_buffer(sPriv, dPriv, visual, isPixmap))\n      return FALSE;\n\n   drawable = dPriv->driverPrivate;\n\n   drawable->allocate_textures = dri2_allocate_textures;\n   drawable->flush_frontbuffer = dri2_flush_frontbuffer;\n   drawable->update_tex_buffer = dri2_update_tex_buffer;\n   drawable->flush_swapbuffers = dri2_flush_swapbuffers;\n\n   return TRUE;\n}\n\n/**\n * DRI driver virtual function table.\n *\n * DRI versions differ in their implementation of init_screen and swap_buffers.\n */\nconst struct __DriverAPIRec galliumdrm_driver_api = {\n   .InitScreen = dri2_init_screen,\n   .DestroyScreen = dri_destroy_screen,\n   .CreateContext = dri_create_context,\n   .DestroyContext = dri_destroy_context,\n   .CreateBuffer = dri2_create_buffer,\n   .DestroyBuffer = dri_destroy_buffer,\n   .MakeCurrent = dri_make_current,\n   .UnbindContext = dri_unbind_context,\n\n   .AllocateBuffer = dri2_allocate_buffer,\n   .ReleaseBuffer  = dri2_release_buffer,\n};\n\n/**\n * DRI driver virtual function table.\n *\n * KMS/DRM version of the DriverAPI above sporting a different InitScreen\n * hook. The latter is used to explicitly initialise the kms_swrast driver\n * rather than selecting the approapriate driver as suggested by the loader.\n */\nconst struct __DriverAPIRec dri_kms_driver_api = {\n   .InitScreen = dri_kms_init_screen,\n   .DestroyScreen = dri_destroy_screen,\n   .CreateContext = dri_create_context,\n   .DestroyContext = dri_destroy_context,\n   .CreateBuffer = dri2_create_buffer,\n   .DestroyBuffer = dri_destroy_buffer,\n   .MakeCurrent = dri_make_current,\n   .UnbindContext = dri_unbind_context,\n\n   .AllocateBuffer = dri2_allocate_buffer,\n   .ReleaseBuffer  = dri2_release_buffer,\n};\n\n/* This is the table of extensions that the loader will dlsym() for. */\nconst __DRIextension *galliumdrm_driver_extensions[] = {\n    &driCoreExtension.base,\n    &driImageDriverExtension.base,\n    &driDRI2Extension.base,\n    &gallium_config_options.base,\n    NULL\n};\n\n/* vim: set sw=3 ts=8 sts=3 expandtab: */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/gallium/frontends/dri/drisw.c": "/**************************************************************************\n *\n * Copyright 2009, VMware, Inc.\n * All Rights Reserved.\n * Copyright 2010 George Sapountzis <gsapountzis@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sub license, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice (including the\n * next paragraph) shall be included in all copies or substantial portions\n * of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.\n * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR\n * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n **************************************************************************/\n\n#include \"util/format/u_format.h\"\n#include \"util/u_memory.h\"\n#include \"util/u_inlines.h\"\n#include \"util/u_box.h\"\n#include \"pipe/p_context.h\"\n#include \"pipe-loader/pipe_loader.h\"\n#include \"frontend/drisw_api.h\"\n#include \"state_tracker/st_context.h\"\n\n#include \"dri_screen.h\"\n#include \"dri_context.h\"\n#include \"dri_drawable.h\"\n#include \"dri_helpers.h\"\n#include \"dri_query_renderer.h\"\n\nDEBUG_GET_ONCE_BOOL_OPTION(swrast_no_present, \"SWRAST_NO_PRESENT\", FALSE);\n\nstatic inline void\nget_drawable_info(__DRIdrawable *dPriv, int *x, int *y, int *w, int *h)\n{\n   __DRIscreen *sPriv = dPriv->driScreenPriv;\n   const __DRIswrastLoaderExtension *loader = sPriv->swrast_loader;\n\n   loader->getDrawableInfo(dPriv,\n                           x, y, w, h,\n                           dPriv->loaderPrivate);\n}\n\nstatic inline void\nput_image(__DRIdrawable *dPriv, void *data, unsigned width, unsigned height)\n{\n   __DRIscreen *sPriv = dPriv->driScreenPriv;\n   const __DRIswrastLoaderExtension *loader = sPriv->swrast_loader;\n\n   loader->putImage(dPriv, __DRI_SWRAST_IMAGE_OP_SWAP,\n                    0, 0, width, height,\n                    data, dPriv->loaderPrivate);\n}\n\nstatic inline void\nput_image2(__DRIdrawable *dPriv, void *data, int x, int y,\n           unsigned width, unsigned height, unsigned stride)\n{\n   __DRIscreen *sPriv = dPriv->driScreenPriv;\n   const __DRIswrastLoaderExtension *loader = sPriv->swrast_loader;\n\n   loader->putImage2(dPriv, __DRI_SWRAST_IMAGE_OP_SWAP,\n                     x, y, width, height, stride,\n                     data, dPriv->loaderPrivate);\n}\n\nstatic inline void\nput_image_shm(__DRIdrawable *dPriv, int shmid, char *shmaddr,\n              unsigned offset, unsigned offset_x, int x, int y,\n              unsigned width, unsigned height, unsigned stride)\n{\n   __DRIscreen *sPriv = dPriv->driScreenPriv;\n   const __DRIswrastLoaderExtension *loader = sPriv->swrast_loader;\n\n   /* if we have the newer interface, don't have to add the offset_x here. */\n   if (loader->base.version > 4 && loader->putImageShm2)\n     loader->putImageShm2(dPriv, __DRI_SWRAST_IMAGE_OP_SWAP,\n                          x, y, width, height, stride,\n                          shmid, shmaddr, offset, dPriv->loaderPrivate);\n   else\n     loader->putImageShm(dPriv, __DRI_SWRAST_IMAGE_OP_SWAP,\n                         x, y, width, height, stride,\n                         shmid, shmaddr, offset + offset_x, dPriv->loaderPrivate);\n}\n\nstatic inline void\nget_image(__DRIdrawable *dPriv, int x, int y, int width, int height, void *data)\n{\n   __DRIscreen *sPriv = dPriv->driScreenPriv;\n   const __DRIswrastLoaderExtension *loader = sPriv->swrast_loader;\n\n   loader->getImage(dPriv,\n                    x, y, width, height,\n                    data, dPriv->loaderPrivate);\n}\n\nstatic inline void\nget_image2(__DRIdrawable *dPriv, int x, int y, int width, int height, int stride, void *data)\n{\n   __DRIscreen *sPriv = dPriv->driScreenPriv;\n   const __DRIswrastLoaderExtension *loader = sPriv->swrast_loader;\n\n   /* getImage2 support is only in version 3 or newer */\n   if (loader->base.version < 3)\n      return;\n\n   loader->getImage2(dPriv,\n                     x, y, width, height, stride,\n                     data, dPriv->loaderPrivate);\n}\n\nstatic inline bool\nget_image_shm(__DRIdrawable *dPriv, int x, int y, int width, int height,\n              struct pipe_resource *res)\n{\n   __DRIscreen *sPriv = dPriv->driScreenPriv;\n   const __DRIswrastLoaderExtension *loader = sPriv->swrast_loader;\n   struct winsys_handle whandle;\n\n   whandle.type = WINSYS_HANDLE_TYPE_SHMID;\n\n   if (loader->base.version < 4 || !loader->getImageShm)\n      return FALSE;\n\n   if (!res->screen->resource_get_handle(res->screen, NULL, res, &whandle, PIPE_HANDLE_USAGE_FRAMEBUFFER_WRITE))\n      return FALSE;\n\n   if (loader->base.version > 5 && loader->getImageShm2)\n      return loader->getImageShm2(dPriv, x, y, width, height, whandle.handle, dPriv->loaderPrivate);\n\n   loader->getImageShm(dPriv, x, y, width, height, whandle.handle, dPriv->loaderPrivate);\n   return TRUE;\n}\n\nstatic void\ndrisw_update_drawable_info(struct dri_drawable *drawable)\n{\n   __DRIdrawable *dPriv = drawable->dPriv;\n   int x, y;\n\n   get_drawable_info(dPriv, &x, &y, &dPriv->w, &dPriv->h);\n}\n\nstatic void\ndrisw_get_image(struct dri_drawable *drawable,\n                int x, int y, unsigned width, unsigned height, unsigned stride,\n                void *data)\n{\n   __DRIdrawable *dPriv = drawable->dPriv;\n   int draw_x, draw_y, draw_w, draw_h;\n\n   get_drawable_info(dPriv, &draw_x, &draw_y, &draw_w, &draw_h);\n   get_image2(dPriv, x, y, draw_w, draw_h, stride, data);\n}\n\nstatic void\ndrisw_put_image(struct dri_drawable *drawable,\n                void *data, unsigned width, unsigned height)\n{\n   __DRIdrawable *dPriv = drawable->dPriv;\n\n   put_image(dPriv, data, width, height);\n}\n\nstatic void\ndrisw_put_image2(struct dri_drawable *drawable,\n                 void *data, int x, int y, unsigned width, unsigned height,\n                 unsigned stride)\n{\n   __DRIdrawable *dPriv = drawable->dPriv;\n\n   put_image2(dPriv, data, x, y, width, height, stride);\n}\n\nstatic inline void\ndrisw_put_image_shm(struct dri_drawable *drawable,\n                    int shmid, char *shmaddr, unsigned offset,\n                    unsigned offset_x,\n                    int x, int y, unsigned width, unsigned height,\n                    unsigned stride)\n{\n   __DRIdrawable *dPriv = drawable->dPriv;\n\n   put_image_shm(dPriv, shmid, shmaddr, offset, offset_x, x, y, width, height, stride);\n}\n\nstatic inline void\ndrisw_present_texture(struct pipe_context *pipe, __DRIdrawable *dPriv,\n                      struct pipe_resource *ptex, struct pipe_box *sub_box)\n{\n   struct dri_drawable *drawable = dri_drawable(dPriv);\n   struct dri_screen *screen = dri_screen(drawable->sPriv);\n\n   if (screen->swrast_no_present)\n      return;\n\n   screen->base.screen->flush_frontbuffer(screen->base.screen, pipe, ptex, 0, 0, drawable, sub_box);\n}\n\nstatic inline void\ndrisw_invalidate_drawable(__DRIdrawable *dPriv)\n{\n   struct dri_drawable *drawable = dri_drawable(dPriv);\n\n   drawable->texture_stamp = dPriv->lastStamp - 1;\n\n   p_atomic_inc(&drawable->base.stamp);\n}\n\nstatic inline void\ndrisw_copy_to_front(struct pipe_context *pipe,\n                    __DRIdrawable * dPriv,\n                    struct pipe_resource *ptex)\n{\n   drisw_present_texture(pipe, dPriv, ptex, NULL);\n\n   drisw_invalidate_drawable(dPriv);\n}\n\n/*\n * Backend functions for st_framebuffer interface and swap_buffers.\n */\n\nstatic void\ndrisw_swap_buffers(__DRIdrawable *dPriv)\n{\n   struct dri_context *ctx = dri_get_current(dPriv->driScreenPriv);\n   struct dri_drawable *drawable = dri_drawable(dPriv);\n   struct pipe_resource *ptex;\n\n   if (!ctx)\n      return;\n\n   ptex = drawable->textures[ST_ATTACHMENT_BACK_LEFT];\n\n   if (ptex) {\n      if (ctx->pp)\n         pp_run(ctx->pp, ptex, ptex, drawable->textures[ST_ATTACHMENT_DEPTH_STENCIL]);\n\n      if (ctx->hud)\n         hud_run(ctx->hud, ctx->st->cso_context, ptex);\n\n      ctx->st->flush(ctx->st, ST_FLUSH_FRONT, NULL, NULL, NULL);\n\n      if (drawable->stvis.samples > 1) {\n         /* Resolve the back buffer. */\n         dri_pipe_blit(ctx->st->pipe,\n                       drawable->textures[ST_ATTACHMENT_BACK_LEFT],\n                       drawable->msaa_textures[ST_ATTACHMENT_BACK_LEFT]);\n      }\n\n      drisw_copy_to_front(ctx->st->pipe, dPriv, ptex);\n   }\n}\n\nstatic void\ndrisw_copy_sub_buffer(__DRIdrawable *dPriv, int x, int y,\n                      int w, int h)\n{\n   struct dri_context *ctx = dri_get_current(dPriv->driScreenPriv);\n   struct dri_drawable *drawable = dri_drawable(dPriv);\n   struct pipe_resource *ptex;\n   struct pipe_box box;\n   if (!ctx)\n      return;\n\n   ptex = drawable->textures[ST_ATTACHMENT_BACK_LEFT];\n\n   if (ptex) {\n      if (ctx->pp && drawable->textures[ST_ATTACHMENT_DEPTH_STENCIL])\n         pp_run(ctx->pp, ptex, ptex, drawable->textures[ST_ATTACHMENT_DEPTH_STENCIL]);\n\n      ctx->st->flush(ctx->st, ST_FLUSH_FRONT, NULL, NULL, NULL);\n\n      u_box_2d(x, dPriv->h - y - h, w, h, &box);\n      drisw_present_texture(ctx->st->pipe, dPriv, ptex, &box);\n   }\n}\n\nstatic void\ndrisw_flush_frontbuffer(struct dri_context *ctx,\n                        struct dri_drawable *drawable,\n                        enum st_attachment_type statt)\n{\n   struct pipe_resource *ptex;\n\n   if (!ctx)\n      return;\n\n   if (drawable->stvis.samples > 1) {\n      /* Resolve the front buffer. */\n      dri_pipe_blit(ctx->st->pipe,\n                    drawable->textures[ST_ATTACHMENT_FRONT_LEFT],\n                    drawable->msaa_textures[ST_ATTACHMENT_FRONT_LEFT]);\n   }\n   ptex = drawable->textures[statt];\n\n   if (ptex) {\n      drisw_copy_to_front(ctx->st->pipe, ctx->dPriv, ptex);\n   }\n}\n\n/**\n * Allocate framebuffer attachments.\n *\n * During fixed-size operation, the function keeps allocating new attachments\n * as they are requested. Unused attachments are not removed, not until the\n * framebuffer is resized or destroyed.\n */\nstatic void\ndrisw_allocate_textures(struct dri_context *stctx,\n                        struct dri_drawable *drawable,\n                        const enum st_attachment_type *statts,\n                        unsigned count)\n{\n   struct dri_screen *screen = dri_screen(drawable->sPriv);\n   const __DRIswrastLoaderExtension *loader = drawable->dPriv->driScreenPriv->swrast_loader;\n   struct pipe_resource templ;\n   unsigned width, height;\n   boolean resized;\n   unsigned i;\n\n   width  = drawable->dPriv->w;\n   height = drawable->dPriv->h;\n\n   resized = (drawable->old_w != width ||\n              drawable->old_h != height);\n\n   /* remove outdated textures */\n   if (resized) {\n      for (i = 0; i < ST_ATTACHMENT_COUNT; i++) {\n         pipe_resource_reference(&drawable->textures[i], NULL);\n         pipe_resource_reference(&drawable->msaa_textures[i], NULL);\n      }\n   }\n\n   memset(&templ, 0, sizeof(templ));\n   templ.target = screen->target;\n   templ.width0 = width;\n   templ.height0 = height;\n   templ.depth0 = 1;\n   templ.array_size = 1;\n   templ.last_level = 0;\n\n   for (i = 0; i < count; i++) {\n      enum pipe_format format;\n      unsigned bind;\n\n      /* the texture already exists or not requested */\n      if (drawable->textures[statts[i]])\n         continue;\n\n      dri_drawable_get_format(drawable, statts[i], &format, &bind);\n\n      /* if we don't do any present, no need for display targets */\n      if (statts[i] != ST_ATTACHMENT_DEPTH_STENCIL && !screen->swrast_no_present)\n         bind |= PIPE_BIND_DISPLAY_TARGET;\n\n      if (format == PIPE_FORMAT_NONE)\n         continue;\n\n      templ.format = format;\n      templ.bind = bind;\n      templ.nr_samples = 0;\n      templ.nr_storage_samples = 0;\n\n      if (statts[i] == ST_ATTACHMENT_FRONT_LEFT &&\n          screen->base.screen->resource_create_front &&\n          loader->base.version >= 3) {\n         drawable->textures[statts[i]] =\n            screen->base.screen->resource_create_front(screen->base.screen, &templ, (const void *)drawable);\n      } else\n         drawable->textures[statts[i]] =\n            screen->base.screen->resource_create(screen->base.screen, &templ);\n\n      if (drawable->stvis.samples > 1) {\n         templ.bind = templ.bind &\n            ~(PIPE_BIND_SCANOUT | PIPE_BIND_SHARED | PIPE_BIND_DISPLAY_TARGET);\n         templ.nr_samples = drawable->stvis.samples;\n         templ.nr_storage_samples = drawable->stvis.samples;\n         drawable->msaa_textures[statts[i]] =\n            screen->base.screen->resource_create(screen->base.screen, &templ);\n\n         dri_pipe_blit(stctx->st->pipe,\n                       drawable->msaa_textures[statts[i]],\n                       drawable->textures[statts[i]]);\n      }\n   }\n\n   drawable->old_w = width;\n   drawable->old_h = height;\n}\n\nstatic void\ndrisw_update_tex_buffer(struct dri_drawable *drawable,\n                        struct dri_context *ctx,\n                        struct pipe_resource *res)\n{\n   __DRIdrawable *dPriv = drawable->dPriv;\n\n   struct st_context *st_ctx = (struct st_context *)ctx->st;\n   struct pipe_context *pipe = st_ctx->pipe;\n   struct pipe_transfer *transfer;\n   char *map;\n   int x, y, w, h;\n   int ximage_stride, line;\n   int cpp = util_format_get_blocksize(res->format);\n\n   get_drawable_info(dPriv, &x, &y, &w, &h);\n\n   map = pipe_transfer_map(pipe, res,\n                           0, 0, // level, layer,\n                           PIPE_MAP_WRITE,\n                           x, y, w, h, &transfer);\n\n   /* Copy the Drawable content to the mapped texture buffer */\n   if (!get_image_shm(dPriv, x, y, w, h, res))\n      get_image(dPriv, x, y, w, h, map);\n\n   /* The pipe transfer has a pitch rounded up to the nearest 64 pixels.\n      get_image() has a pitch rounded up to 4 bytes.  */\n   ximage_stride = ((w * cpp) + 3) & -4;\n   for (line = h-1; line; --line) {\n      memmove(&map[line * transfer->stride],\n              &map[line * ximage_stride],\n              ximage_stride);\n   }\n\n   pipe_transfer_unmap(pipe, transfer);\n}\n\nstatic __DRIimageExtension driSWImageExtension = {\n    .base = { __DRI_IMAGE, 6 },\n\n    .createImageFromRenderbuffer  = dri2_create_image_from_renderbuffer,\n    .createImageFromTexture = dri2_create_from_texture,\n    .destroyImage = dri2_destroy_image,\n};\n\nstatic const __DRIrobustnessExtension dri2Robustness = {\n   .base = { __DRI2_ROBUSTNESS, 1 }\n};\n\n/*\n * Backend function for init_screen.\n */\n\nstatic const __DRIextension *drisw_screen_extensions[] = {\n   &driTexBufferExtension.base,\n   &dri2RendererQueryExtension.base,\n   &dri2ConfigQueryExtension.base,\n   &dri2FenceExtension.base,\n   &dri2NoErrorExtension.base,\n   &driSWImageExtension.base,\n   &dri2FlushControlExtension.base,\n   NULL\n};\n\nstatic const __DRIextension *drisw_robust_screen_extensions[] = {\n   &driTexBufferExtension.base,\n   &dri2RendererQueryExtension.base,\n   &dri2ConfigQueryExtension.base,\n   &dri2FenceExtension.base,\n   &dri2NoErrorExtension.base,\n   &dri2Robustness.base,\n   &driSWImageExtension.base,\n   &dri2FlushControlExtension.base,\n   NULL\n};\n\nstatic const struct drisw_loader_funcs drisw_lf = {\n   .get_image = drisw_get_image,\n   .put_image = drisw_put_image,\n   .put_image2 = drisw_put_image2\n};\n\nstatic const struct drisw_loader_funcs drisw_shm_lf = {\n   .get_image = drisw_get_image,\n   .put_image = drisw_put_image,\n   .put_image2 = drisw_put_image2,\n   .put_image_shm = drisw_put_image_shm\n};\n\nstatic const __DRIconfig **\ndrisw_init_screen(__DRIscreen * sPriv)\n{\n   const __DRIswrastLoaderExtension *loader = sPriv->swrast_loader;\n   const __DRIconfig **configs;\n   struct dri_screen *screen;\n   struct pipe_screen *pscreen = NULL;\n   const struct drisw_loader_funcs *lf = &drisw_lf;\n\n   screen = CALLOC_STRUCT(dri_screen);\n   if (!screen)\n      return NULL;\n\n   screen->sPriv = sPriv;\n   screen->fd = -1;\n\n   screen->swrast_no_present = debug_get_option_swrast_no_present();\n\n   sPriv->driverPrivate = (void *)screen;\n\n   if (loader->base.version >= 4) {\n      if (loader->putImageShm)\n         lf = &drisw_shm_lf;\n   }\n\n   if (pipe_loader_sw_probe_dri(&screen->dev, lf)) {\n      dri_init_options(screen);\n\n      pscreen = pipe_loader_create_screen(screen->dev);\n   }\n\n   if (!pscreen)\n      goto fail;\n\n   configs = dri_init_screen_helper(screen, pscreen);\n   if (!configs)\n      goto fail;\n\n   if (pscreen->get_param(pscreen, PIPE_CAP_DEVICE_RESET_STATUS_QUERY)) {\n      sPriv->extensions = drisw_robust_screen_extensions;\n      screen->has_reset_status_query = true;\n   }\n   else\n      sPriv->extensions = drisw_screen_extensions;\n   screen->lookup_egl_image = dri2_lookup_egl_image;\n\n   return configs;\nfail:\n   dri_destroy_screen_helper(screen);\n   if (screen->dev)\n      pipe_loader_release(&screen->dev, 1);\n   FREE(screen);\n   return NULL;\n}\n\nstatic boolean\ndrisw_create_buffer(__DRIscreen * sPriv,\n                    __DRIdrawable * dPriv,\n                    const struct gl_config * visual, boolean isPixmap)\n{\n   struct dri_drawable *drawable = NULL;\n\n   if (!dri_create_buffer(sPriv, dPriv, visual, isPixmap))\n      return FALSE;\n\n   drawable = dPriv->driverPrivate;\n\n   drawable->allocate_textures = drisw_allocate_textures;\n   drawable->update_drawable_info = drisw_update_drawable_info;\n   drawable->flush_frontbuffer = drisw_flush_frontbuffer;\n   drawable->update_tex_buffer = drisw_update_tex_buffer;\n\n   return TRUE;\n}\n\n/**\n * DRI driver virtual function table.\n *\n * DRI versions differ in their implementation of init_screen and swap_buffers.\n */\nconst struct __DriverAPIRec galliumsw_driver_api = {\n   .InitScreen = drisw_init_screen,\n   .DestroyScreen = dri_destroy_screen,\n   .CreateContext = dri_create_context,\n   .DestroyContext = dri_destroy_context,\n   .CreateBuffer = drisw_create_buffer,\n   .DestroyBuffer = dri_destroy_buffer,\n   .SwapBuffers = drisw_swap_buffers,\n   .MakeCurrent = dri_make_current,\n   .UnbindContext = dri_unbind_context,\n   .CopySubBuffer = drisw_copy_sub_buffer,\n};\n\n/* This is the table of extensions that the loader will dlsym() for. */\nconst __DRIextension *galliumsw_driver_extensions[] = {\n    &driCoreExtension.base,\n    &driSWRastExtension.base,\n    &driCopySubBufferExtension.base,\n    &gallium_config_options.base,\n    NULL\n};\n\n/* vim: set sw=3 ts=8 sts=3 expandtab: */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/gallium/frontends/dri/dri_helpers.c": "/*\n * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <dlfcn.h>\n#include \"drm-uapi/drm_fourcc.h\"\n#include \"util/u_memory.h\"\n#include \"pipe/p_screen.h\"\n#include \"state_tracker/st_texture.h\"\n#include \"state_tracker/st_context.h\"\n#include \"state_tracker/st_cb_fbo.h\"\n#include \"main/texobj.h\"\n\n#include \"dri_helpers.h\"\n\nstatic bool\ndri2_is_opencl_interop_loaded_locked(struct dri_screen *screen)\n{\n   return screen->opencl_dri_event_add_ref &&\n          screen->opencl_dri_event_release &&\n          screen->opencl_dri_event_wait &&\n          screen->opencl_dri_event_get_fence;\n}\n\nstatic bool\ndri2_load_opencl_interop(struct dri_screen *screen)\n{\n#if defined(RTLD_DEFAULT)\n   bool success;\n\n   mtx_lock(&screen->opencl_func_mutex);\n\n   if (dri2_is_opencl_interop_loaded_locked(screen)) {\n      mtx_unlock(&screen->opencl_func_mutex);\n      return true;\n   }\n\n   screen->opencl_dri_event_add_ref =\n      dlsym(RTLD_DEFAULT, \"opencl_dri_event_add_ref\");\n   screen->opencl_dri_event_release =\n      dlsym(RTLD_DEFAULT, \"opencl_dri_event_release\");\n   screen->opencl_dri_event_wait =\n      dlsym(RTLD_DEFAULT, \"opencl_dri_event_wait\");\n   screen->opencl_dri_event_get_fence =\n      dlsym(RTLD_DEFAULT, \"opencl_dri_event_get_fence\");\n\n   success = dri2_is_opencl_interop_loaded_locked(screen);\n   mtx_unlock(&screen->opencl_func_mutex);\n   return success;\n#else\n   return false;\n#endif\n}\n\nstruct dri2_fence {\n   struct dri_screen *driscreen;\n   struct pipe_fence_handle *pipe_fence;\n   void *cl_event;\n};\n\nstatic unsigned dri2_fence_get_caps(__DRIscreen *_screen)\n{\n   struct dri_screen *driscreen = dri_screen(_screen);\n   struct pipe_screen *screen = driscreen->base.screen;\n   unsigned caps = 0;\n\n   if (screen->get_param(screen, PIPE_CAP_NATIVE_FENCE_FD))\n      caps |= __DRI_FENCE_CAP_NATIVE_FD;\n\n   return caps;\n}\n\nstatic void *\ndri2_create_fence(__DRIcontext *_ctx)\n{\n   struct st_context_iface *stapi = dri_context(_ctx)->st;\n   struct dri2_fence *fence = CALLOC_STRUCT(dri2_fence);\n\n   if (!fence)\n      return NULL;\n\n   stapi->flush(stapi, 0, &fence->pipe_fence, NULL, NULL);\n\n   if (!fence->pipe_fence) {\n      FREE(fence);\n      return NULL;\n   }\n\n   fence->driscreen = dri_screen(_ctx->driScreenPriv);\n   return fence;\n}\n\nstatic void *\ndri2_create_fence_fd(__DRIcontext *_ctx, int fd)\n{\n   struct st_context_iface *stapi = dri_context(_ctx)->st;\n   struct pipe_context *ctx = stapi->pipe;\n   struct dri2_fence *fence = CALLOC_STRUCT(dri2_fence);\n\n   if (fd == -1) {\n      /* exporting driver created fence, flush: */\n      stapi->flush(stapi, ST_FLUSH_FENCE_FD, &fence->pipe_fence, NULL, NULL);\n   } else {\n      /* importing a foreign fence fd: */\n      ctx->create_fence_fd(ctx, &fence->pipe_fence, fd, PIPE_FD_TYPE_NATIVE_SYNC);\n   }\n   if (!fence->pipe_fence) {\n      FREE(fence);\n      return NULL;\n   }\n\n   fence->driscreen = dri_screen(_ctx->driScreenPriv);\n   return fence;\n}\n\nstatic int\ndri2_get_fence_fd(__DRIscreen *_screen, void *_fence)\n{\n   struct dri_screen *driscreen = dri_screen(_screen);\n   struct pipe_screen *screen = driscreen->base.screen;\n   struct dri2_fence *fence = (struct dri2_fence*)_fence;\n\n   return screen->fence_get_fd(screen, fence->pipe_fence);\n}\n\nstatic void *\ndri2_get_fence_from_cl_event(__DRIscreen *_screen, intptr_t cl_event)\n{\n   struct dri_screen *driscreen = dri_screen(_screen);\n   struct dri2_fence *fence;\n\n   if (!dri2_load_opencl_interop(driscreen))\n      return NULL;\n\n   fence = CALLOC_STRUCT(dri2_fence);\n   if (!fence)\n      return NULL;\n\n   fence->cl_event = (void*)cl_event;\n\n   if (!driscreen->opencl_dri_event_add_ref(fence->cl_event)) {\n      free(fence);\n      return NULL;\n   }\n\n   fence->driscreen = driscreen;\n   return fence;\n}\n\nstatic void\ndri2_destroy_fence(__DRIscreen *_screen, void *_fence)\n{\n   struct dri_screen *driscreen = dri_screen(_screen);\n   struct pipe_screen *screen = driscreen->base.screen;\n   struct dri2_fence *fence = (struct dri2_fence*)_fence;\n\n   if (fence->pipe_fence)\n      screen->fence_reference(screen, &fence->pipe_fence, NULL);\n   else if (fence->cl_event)\n      driscreen->opencl_dri_event_release(fence->cl_event);\n   else\n      assert(0);\n\n   FREE(fence);\n}\n\nstatic GLboolean\ndri2_client_wait_sync(__DRIcontext *_ctx, void *_fence, unsigned flags,\n                      uint64_t timeout)\n{\n   struct dri2_fence *fence = (struct dri2_fence*)_fence;\n   struct dri_screen *driscreen = fence->driscreen;\n   struct pipe_screen *screen = driscreen->base.screen;\n\n   /* No need to flush. The context was flushed when the fence was created. */\n\n   if (fence->pipe_fence)\n      return screen->fence_finish(screen, NULL, fence->pipe_fence, timeout);\n   else if (fence->cl_event) {\n      struct pipe_fence_handle *pipe_fence =\n         driscreen->opencl_dri_event_get_fence(fence->cl_event);\n\n      if (pipe_fence)\n         return screen->fence_finish(screen, NULL, pipe_fence, timeout);\n      else\n         return driscreen->opencl_dri_event_wait(fence->cl_event, timeout);\n   }\n   else {\n      assert(0);\n      return false;\n   }\n}\n\nstatic void\ndri2_server_wait_sync(__DRIcontext *_ctx, void *_fence, unsigned flags)\n{\n   struct pipe_context *ctx = dri_context(_ctx)->st->pipe;\n   struct dri2_fence *fence = (struct dri2_fence*)_fence;\n\n   /* We might be called here with a NULL fence as a result of WaitSyncKHR\n    * on a EGL_KHR_reusable_sync fence. Nothing to do here in such case.\n    */\n   if (!fence)\n      return;\n\n   if (ctx->fence_server_sync)\n      ctx->fence_server_sync(ctx, fence->pipe_fence);\n}\n\nconst __DRI2fenceExtension dri2FenceExtension = {\n   .base = { __DRI2_FENCE, 2 },\n\n   .create_fence = dri2_create_fence,\n   .get_fence_from_cl_event = dri2_get_fence_from_cl_event,\n   .destroy_fence = dri2_destroy_fence,\n   .client_wait_sync = dri2_client_wait_sync,\n   .server_wait_sync = dri2_server_wait_sync,\n   .get_capabilities = dri2_fence_get_caps,\n   .create_fence_fd = dri2_create_fence_fd,\n   .get_fence_fd = dri2_get_fence_fd,\n};\n\n__DRIimage *\ndri2_lookup_egl_image(struct dri_screen *screen, void *handle)\n{\n   const __DRIimageLookupExtension *loader = screen->sPriv->dri2.image;\n   __DRIimage *img;\n\n   if (!loader->lookupEGLImage)\n      return NULL;\n\n   img = loader->lookupEGLImage(screen->sPriv,\n\t\t\t\thandle, screen->sPriv->loaderPrivate);\n\n   return img;\n}\n\n__DRIimage *\ndri2_create_image_from_renderbuffer2(__DRIcontext *context,\n\t\t\t\t     int renderbuffer, void *loaderPrivate,\n                                     unsigned *error)\n{\n   struct st_context *st_ctx = (struct st_context *)dri_context(context)->st;\n   struct gl_context *ctx = st_ctx->ctx;\n   struct pipe_context *p_ctx = st_ctx->pipe;\n   struct gl_renderbuffer *rb;\n   struct pipe_resource *tex;\n   __DRIimage *img;\n\n   /* Section 3.9 (EGLImage Specification and Management) of the EGL 1.5\n    * specification says:\n    *\n    *   \"If target is EGL_GL_RENDERBUFFER and buffer is not the name of a\n    *    renderbuffer object, or if buffer is the name of a multisampled\n    *    renderbuffer object, the error EGL_BAD_PARAMETER is generated.\"\n    *\n    *   \"If target is EGL_GL_TEXTURE_2D , EGL_GL_TEXTURE_CUBE_MAP_*,\n    *    EGL_GL_RENDERBUFFER or EGL_GL_TEXTURE_3D and buffer refers to the\n    *    default GL texture object (0) for the corresponding GL target, the\n    *    error EGL_BAD_PARAMETER is generated.\"\n    *   (rely on _mesa_lookup_renderbuffer returning NULL in this case)\n    */\n   rb = _mesa_lookup_renderbuffer(ctx, renderbuffer);\n   if (!rb || rb->NumSamples > 0) {\n      *error = __DRI_IMAGE_ERROR_BAD_PARAMETER;\n      return NULL;\n   }\n\n   tex = st_get_renderbuffer_resource(rb);\n   if (!tex) {\n      *error = __DRI_IMAGE_ERROR_BAD_PARAMETER;\n      return NULL;\n   }\n\n   img = CALLOC_STRUCT(__DRIimageRec);\n   if (!img) {\n      *error = __DRI_IMAGE_ERROR_BAD_ALLOC;\n      return NULL;\n   }\n\n   img->dri_format = driGLFormatToImageFormat(rb->Format);\n   img->loader_private = loaderPrivate;\n   img->sPriv = context->driScreenPriv;\n\n   pipe_resource_reference(&img->texture, tex);\n\n   /* If the resource supports EGL_MESA_image_dma_buf_export, make sure that\n    * it's in a shareable state. Do this now while we still have the access to\n    * the context.\n    */\n   if (dri2_get_mapping_by_format(img->dri_format))\n      p_ctx->flush_resource(p_ctx, tex);\n\n   *error = __DRI_IMAGE_ERROR_SUCCESS;\n   return img;\n}\n\n__DRIimage *\ndri2_create_image_from_renderbuffer(__DRIcontext *context,\n\t\t\t\t    int renderbuffer, void *loaderPrivate)\n{\n   unsigned error;\n   return dri2_create_image_from_renderbuffer2(context, renderbuffer,\n                                               loaderPrivate, &error);\n}\n\nvoid\ndri2_destroy_image(__DRIimage *img)\n{\n   const __DRIimageLoaderExtension *imgLoader = img->sPriv->image.loader;\n   const __DRIdri2LoaderExtension *dri2Loader = img->sPriv->dri2.loader;\n\n   if (imgLoader && imgLoader->base.version >= 4 &&\n         imgLoader->destroyLoaderImageState) {\n      imgLoader->destroyLoaderImageState(img->loader_private);\n   } else if (dri2Loader && dri2Loader->base.version >= 5 &&\n         dri2Loader->destroyLoaderImageState) {\n      dri2Loader->destroyLoaderImageState(img->loader_private);\n   }\n\n   pipe_resource_reference(&img->texture, NULL);\n   FREE(img);\n}\n\n\n__DRIimage *\ndri2_create_from_texture(__DRIcontext *context, int target, unsigned texture,\n                         int depth, int level, unsigned *error,\n                         void *loaderPrivate)\n{\n   __DRIimage *img;\n   struct st_context *st_ctx = (struct st_context *)dri_context(context)->st;\n   struct gl_context *ctx = st_ctx->ctx;\n   struct pipe_context *p_ctx = st_ctx->pipe;\n   struct gl_texture_object *obj;\n   struct pipe_resource *tex;\n   GLuint face = 0;\n\n   obj = _mesa_lookup_texture(ctx, texture);\n   if (!obj || obj->Target != target) {\n      *error = __DRI_IMAGE_ERROR_BAD_PARAMETER;\n      return NULL;\n   }\n\n   tex = st_get_texobj_resource(obj);\n   if (!tex) {\n      *error = __DRI_IMAGE_ERROR_BAD_PARAMETER;\n      return NULL;\n   }\n\n   if (target == GL_TEXTURE_CUBE_MAP)\n      face = depth;\n\n   _mesa_test_texobj_completeness(ctx, obj);\n   if (!obj->_BaseComplete || (level > 0 && !obj->_MipmapComplete)) {\n      *error = __DRI_IMAGE_ERROR_BAD_PARAMETER;\n      return NULL;\n   }\n\n   if (level < obj->Attrib.BaseLevel || level > obj->_MaxLevel) {\n      *error = __DRI_IMAGE_ERROR_BAD_MATCH;\n      return NULL;\n   }\n\n   if (target == GL_TEXTURE_3D && obj->Image[face][level]->Depth < depth) {\n      *error = __DRI_IMAGE_ERROR_BAD_MATCH;\n      return NULL;\n   }\n\n   img = CALLOC_STRUCT(__DRIimageRec);\n   if (!img) {\n      *error = __DRI_IMAGE_ERROR_BAD_ALLOC;\n      return NULL;\n   }\n\n   img->level = level;\n   img->layer = depth;\n   img->dri_format = driGLFormatToImageFormat(obj->Image[face][level]->TexFormat);\n\n   img->loader_private = loaderPrivate;\n   img->sPriv = context->driScreenPriv;\n\n   pipe_resource_reference(&img->texture, tex);\n\n   /* If the resource supports EGL_MESA_image_dma_buf_export, make sure that\n    * it's in a shareable state. Do this now while we still have the access to\n    * the context.\n    */\n   if (dri2_get_mapping_by_format(img->dri_format))\n      p_ctx->flush_resource(p_ctx, tex);\n\n   *error = __DRI_IMAGE_ERROR_SUCCESS;\n   return img;\n}\n\nstatic const struct dri2_format_mapping dri2_format_table[] = {\n      { DRM_FORMAT_ABGR16161616F, __DRI_IMAGE_FORMAT_ABGR16161616F,\n        __DRI_IMAGE_COMPONENTS_RGBA,      PIPE_FORMAT_R16G16B16A16_FLOAT, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_ABGR16161616F, 4 } } },\n      { DRM_FORMAT_XBGR16161616F, __DRI_IMAGE_FORMAT_XBGR16161616F,\n        __DRI_IMAGE_COMPONENTS_RGB,       PIPE_FORMAT_R16G16B16X16_FLOAT, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_XBGR16161616F, 4 } } },\n      { DRM_FORMAT_ARGB2101010,   __DRI_IMAGE_FORMAT_ARGB2101010,\n        __DRI_IMAGE_COMPONENTS_RGBA,      PIPE_FORMAT_B10G10R10A2_UNORM, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_ARGB2101010, 4 } } },\n      { DRM_FORMAT_XRGB2101010,   __DRI_IMAGE_FORMAT_XRGB2101010,\n        __DRI_IMAGE_COMPONENTS_RGB,       PIPE_FORMAT_B10G10R10X2_UNORM, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_XRGB2101010, 4 } } },\n      { DRM_FORMAT_ABGR2101010,   __DRI_IMAGE_FORMAT_ABGR2101010,\n        __DRI_IMAGE_COMPONENTS_RGBA,      PIPE_FORMAT_R10G10B10A2_UNORM, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_ABGR2101010, 4 } } },\n      { DRM_FORMAT_XBGR2101010,   __DRI_IMAGE_FORMAT_XBGR2101010,\n        __DRI_IMAGE_COMPONENTS_RGB,       PIPE_FORMAT_R10G10B10X2_UNORM, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_XBGR2101010, 4 } } },\n      { DRM_FORMAT_ARGB8888,      __DRI_IMAGE_FORMAT_ARGB8888,\n        __DRI_IMAGE_COMPONENTS_RGBA,      PIPE_FORMAT_BGRA8888_UNORM, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_ARGB8888, 4 } } },\n      { DRM_FORMAT_ABGR8888,      __DRI_IMAGE_FORMAT_ABGR8888,\n        __DRI_IMAGE_COMPONENTS_RGBA,      PIPE_FORMAT_RGBA8888_UNORM, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_ABGR8888, 4 } } },\n      { __DRI_IMAGE_FOURCC_SARGB8888,     __DRI_IMAGE_FORMAT_SARGB8,\n        __DRI_IMAGE_COMPONENTS_RGBA,      PIPE_FORMAT_BGRA8888_SRGB, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_SARGB8, 4 } } },\n      { DRM_FORMAT_XRGB8888,      __DRI_IMAGE_FORMAT_XRGB8888,\n        __DRI_IMAGE_COMPONENTS_RGB,       PIPE_FORMAT_BGRX8888_UNORM, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_XRGB8888, 4 }, } },\n      { DRM_FORMAT_XBGR8888,      __DRI_IMAGE_FORMAT_XBGR8888,\n        __DRI_IMAGE_COMPONENTS_RGB,       PIPE_FORMAT_RGBX8888_UNORM, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_XBGR8888, 4 }, } },\n      { DRM_FORMAT_ARGB1555,      __DRI_IMAGE_FORMAT_ARGB1555,\n        __DRI_IMAGE_COMPONENTS_RGBA,      PIPE_FORMAT_B5G5R5A1_UNORM, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_ARGB1555, 2 } } },\n      { DRM_FORMAT_RGB565,        __DRI_IMAGE_FORMAT_RGB565,\n        __DRI_IMAGE_COMPONENTS_RGB,       PIPE_FORMAT_B5G6R5_UNORM, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_RGB565, 2 } } },\n      { DRM_FORMAT_R8,            __DRI_IMAGE_FORMAT_R8,\n        __DRI_IMAGE_COMPONENTS_R,         PIPE_FORMAT_R8_UNORM, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 }, } },\n      { DRM_FORMAT_R16,           __DRI_IMAGE_FORMAT_R16,\n        __DRI_IMAGE_COMPONENTS_R,         PIPE_FORMAT_R16_UNORM, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R16, 1 }, } },\n      { DRM_FORMAT_GR88,          __DRI_IMAGE_FORMAT_GR88,\n        __DRI_IMAGE_COMPONENTS_RG,        PIPE_FORMAT_RG88_UNORM, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_GR88, 2 }, } },\n      { DRM_FORMAT_GR1616,        __DRI_IMAGE_FORMAT_GR1616,\n        __DRI_IMAGE_COMPONENTS_RG,        PIPE_FORMAT_RG1616_UNORM, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_GR1616, 2 }, } },\n\n      { DRM_FORMAT_YUV410, __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_U_V,     PIPE_FORMAT_IYUV, 3,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 1, 2, 2, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 2, 2, 2, __DRI_IMAGE_FORMAT_R8, 1 } } },\n      { DRM_FORMAT_YUV411, __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_U_V,     PIPE_FORMAT_IYUV, 3,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 1, 2, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 2, 2, 0, __DRI_IMAGE_FORMAT_R8, 1 } } },\n      { DRM_FORMAT_YUV420,        __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_U_V,     PIPE_FORMAT_IYUV, 3,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 1, 1, 1, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 2, 1, 1, __DRI_IMAGE_FORMAT_R8, 1 } } },\n      { DRM_FORMAT_YUV422,        __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_U_V,     PIPE_FORMAT_IYUV, 3,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 1, 1, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 2, 1, 0, __DRI_IMAGE_FORMAT_R8, 1 } } },\n      { DRM_FORMAT_YUV444,        __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_U_V,     PIPE_FORMAT_IYUV, 3,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 1, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 2, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 } } },\n\n      { DRM_FORMAT_YVU410,        __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_U_V,     PIPE_FORMAT_IYUV, 3,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 2, 2, 2, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 1, 2, 2, __DRI_IMAGE_FORMAT_R8, 1 } } },\n      { DRM_FORMAT_YVU411,        __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_U_V,     PIPE_FORMAT_IYUV, 3,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 2, 2, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 1, 2, 0, __DRI_IMAGE_FORMAT_R8, 1 } } },\n      { DRM_FORMAT_YVU420,        __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_U_V,     PIPE_FORMAT_IYUV, 3,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 2, 1, 1, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 1, 1, 1, __DRI_IMAGE_FORMAT_R8, 1 } } },\n      { DRM_FORMAT_YVU422,        __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_U_V,     PIPE_FORMAT_IYUV, 3,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 2, 1, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 1, 1, 0, __DRI_IMAGE_FORMAT_R8, 1 } } },\n      { DRM_FORMAT_YVU444,        __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_U_V,     PIPE_FORMAT_IYUV, 3,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 2, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 1, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 } } },\n\n      { DRM_FORMAT_NV12,          __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_UV,      PIPE_FORMAT_NV12, 2,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 1, 1, 1, __DRI_IMAGE_FORMAT_GR88, 2 } } },\n\n      { DRM_FORMAT_P010,          __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_UV,      PIPE_FORMAT_P010, 2,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R16, 2 },\n          { 1, 1, 1, __DRI_IMAGE_FORMAT_GR1616, 4 } } },\n      { DRM_FORMAT_P012,          __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_UV,      PIPE_FORMAT_P012, 2,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R16, 2 },\n          { 1, 1, 1, __DRI_IMAGE_FORMAT_GR1616, 4 } } },\n      { DRM_FORMAT_P016,          __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_UV,      PIPE_FORMAT_P016, 2,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R16, 2 },\n          { 1, 1, 1, __DRI_IMAGE_FORMAT_GR1616, 4 } } },\n\n      { DRM_FORMAT_NV16,          __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_UV,      PIPE_FORMAT_NV12, 2,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n          { 1, 1, 0, __DRI_IMAGE_FORMAT_GR88, 2 } } },\n\n      { DRM_FORMAT_AYUV,      __DRI_IMAGE_FORMAT_ABGR8888,\n        __DRI_IMAGE_COMPONENTS_AYUV,      PIPE_FORMAT_AYUV, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_ABGR8888, 4 } } },\n      { DRM_FORMAT_XYUV8888,      __DRI_IMAGE_FORMAT_XBGR8888,\n        __DRI_IMAGE_COMPONENTS_XYUV,      PIPE_FORMAT_XYUV, 1,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_XBGR8888, 4 } } },\n\n      /* For YUYV and UYVY buffers, we set up two overlapping DRI images\n       * and treat them as planar buffers in the compositors.\n       * Plane 0 is GR88 and samples YU or YV pairs and places Y into\n       * the R component, while plane 1 is ARGB/ABGR and samples YUYV/UYVY\n       * clusters and places pairs and places U into the G component and\n       * V into A.  This lets the texture sampler interpolate the Y\n       * components correctly when sampling from plane 0, and interpolate\n       * U and V correctly when sampling from plane 1. */\n      { DRM_FORMAT_YUYV,          __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_XUXV,    PIPE_FORMAT_YUYV, 2,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_GR88, 2 },\n          { 0, 1, 0, __DRI_IMAGE_FORMAT_ARGB8888, 4 } } },\n      { DRM_FORMAT_UYVY,          __DRI_IMAGE_FORMAT_NONE,\n        __DRI_IMAGE_COMPONENTS_Y_UXVX,    PIPE_FORMAT_UYVY, 2,\n        { { 0, 0, 0, __DRI_IMAGE_FORMAT_GR88, 2 },\n          { 0, 1, 0, __DRI_IMAGE_FORMAT_ABGR8888, 4 } } }\n};\n\nconst struct dri2_format_mapping *\ndri2_get_mapping_by_fourcc(int fourcc)\n{\n   for (unsigned i = 0; i < ARRAY_SIZE(dri2_format_table); i++) {\n      if (dri2_format_table[i].dri_fourcc == fourcc)\n         return &dri2_format_table[i];\n   }\n\n   return NULL;\n}\n\nconst struct dri2_format_mapping *\ndri2_get_mapping_by_format(int format)\n{\n   if (format == __DRI_IMAGE_FORMAT_NONE)\n      return NULL;\n\n   for (unsigned i = 0; i < ARRAY_SIZE(dri2_format_table); i++) {\n      if (dri2_format_table[i].dri_format == format)\n         return &dri2_format_table[i];\n   }\n\n   return NULL;\n}\n\nenum pipe_format\ndri2_get_pipe_format_for_dri_format(int format)\n{\n   for (unsigned i = 0; i < ARRAY_SIZE(dri2_format_table); i++) {\n      if (dri2_format_table[i].dri_format == format)\n         return dri2_format_table[i].pipe_format;\n   }\n\n   return PIPE_FORMAT_NONE;\n}\n\nboolean\ndri2_yuv_dma_buf_supported(struct dri_screen *screen,\n                           const struct dri2_format_mapping *map)\n{\n   struct pipe_screen *pscreen = screen->base.screen;\n\n   for (unsigned i = 0; i < map->nplanes; i++) {\n      if (!pscreen->is_format_supported(pscreen,\n            dri2_get_pipe_format_for_dri_format(map->planes[i].dri_format),\n            screen->target, 0, 0, PIPE_BIND_SAMPLER_VIEW))\n         return false;\n   }\n   return true;\n}\n\nboolean\ndri2_query_dma_buf_formats(__DRIscreen *_screen, int max, int *formats,\n                           int *count)\n{\n   struct dri_screen *screen = dri_screen(_screen);\n   struct pipe_screen *pscreen = screen->base.screen;\n   int i, j;\n\n   for (i = 0, j = 0; (i < ARRAY_SIZE(dri2_format_table)) &&\n         (j < max || max == 0); i++) {\n      const struct dri2_format_mapping *map = &dri2_format_table[i];\n\n      /* The sRGB format is not a real FourCC as defined by drm_fourcc.h, so we\n       * must not leak it out to clients.\n       */\n      if (dri2_format_table[i].dri_fourcc == __DRI_IMAGE_FOURCC_SARGB8888)\n         continue;\n\n      if (pscreen->is_format_supported(pscreen, map->pipe_format,\n                                       screen->target, 0, 0,\n                                       PIPE_BIND_RENDER_TARGET) ||\n          pscreen->is_format_supported(pscreen, map->pipe_format,\n                                       screen->target, 0, 0,\n                                       PIPE_BIND_SAMPLER_VIEW) ||\n          dri2_yuv_dma_buf_supported(screen, map)) {\n         if (j < max)\n            formats[j] = map->dri_fourcc;\n         j++;\n      }\n   }\n   *count = j;\n   return true;\n}\n\n/* vim: set sw=3 ts=8 sts=3 expandtab: */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/mesa/drivers/dri/common/megadriver_stub.c": "/*\n * Copyright \u00a9 2013 Intel Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include <stdio.h>\n#include \"dri_util.h\"\n#include <dlfcn.h>\n#include \"main/macros.h\"\n\n/* We need GNU extensions to dlfcn.h in order to provide backward\n * compatibility for the older DRI driver loader mechanism. (dladdr,\n * Dl_info, and RTLD_DEFAULT)\n */\n#if defined(RTLD_DEFAULT) && defined(HAVE_DLADDR)\n\n#define MEGADRIVER_STUB_MAX_EXTENSIONS 10\n#define LIB_PATH_SUFFIX \"_dri.so\"\n#define LIB_PATH_SUFFIX_LENGTH (sizeof(LIB_PATH_SUFFIX)-1)\n\n/* This is the table of extensions that the loader will dlsym() for.\n *\n * Initially it is empty for the megadriver stub, but the library\n * constructor may initialize it based on the name of the library that\n * is being loaded.\n */\nPUBLIC const __DRIextension *\n__driDriverExtensions[MEGADRIVER_STUB_MAX_EXTENSIONS] = {\n   NULL\n};\n\n/**\n * This is a constructor function for the megadriver dynamic library.\n *\n * When the driver is dlopen'ed, this function will run. It will\n * search for the name of the foo_dri.so file that was opened using\n * the dladdr function.\n *\n * After finding foo's name, it will call __driDriverGetExtensions_foo\n * and use the return to update __driDriverExtensions to enable\n * compatibility with older DRI driver loaders.\n */\n__attribute__((constructor)) static void\nmegadriver_stub_init(void)\n{\n   Dl_info info;\n   char *driver_name;\n   size_t name_len;\n   char *get_extensions_name;\n   const __DRIextension **(*get_extensions)(void);\n   const __DRIextension **extensions;\n   int i;\n\n   /* Call dladdr on __driDriverExtensions. We are really\n    * interested in the returned info.dli_fname so we can\n    * figure out the path name of the library being loaded.\n    */\n   i = dladdr((void*) __driDriverExtensions, &info);\n   if (i == 0)\n      return;\n\n   /* Search for the last '/' character in the path. */\n   driver_name = strrchr(info.dli_fname, '/');\n   if (driver_name != NULL) {\n      /* Skip '/' character */\n      driver_name++;\n   } else {\n      /* Try using the start of the path */\n      driver_name = (char*) info.dli_fname;\n   }\n\n   /* Make sure the path ends with _dri.so */\n   name_len = strlen(driver_name);\n   i = name_len - LIB_PATH_SUFFIX_LENGTH;\n   if (i < 0 || strcmp(driver_name + i, LIB_PATH_SUFFIX) != 0)\n      return;\n\n   /* Duplicate the string so we can modify it.\n    * So far we've been using info.dli_fname.\n    */\n   driver_name = strdup(driver_name);\n   if (!driver_name)\n      return;\n\n   /* The path ends with _dri.so. Chop this part of the\n    * string off. Then we'll have the driver's final name.\n    */\n   driver_name[i] = '\\0';\n\n   i = asprintf(&get_extensions_name, \"%s_%s\",\n                __DRI_DRIVER_GET_EXTENSIONS, driver_name);\n   free(driver_name);\n   if (i == -1)\n      return;\n\n   /* dlsym to get the driver's get extensions function. We\n    * don't have the dlopen handle, so we have to use\n    * RTLD_DEFAULT. It seems unlikely that the symbol will\n    * be found in another library, but this isn't optimal.\n    */\n   get_extensions = dlsym(RTLD_DEFAULT, get_extensions_name);\n   free(get_extensions_name);\n   if (!get_extensions)\n      return;\n\n   /* Use the newer DRI loader entrypoint to find extensions.\n    * We will then expose these extensions via the older\n    * __driDriverExtensions symbol.\n    */\n   extensions = get_extensions();\n\n   /* Copy the extensions into the __driDriverExtensions array\n    * we declared.\n    */\n   for (i = 0; i < ARRAY_SIZE(__driDriverExtensions); i++) {\n      __driDriverExtensions[i] = extensions[i];\n      if (extensions[i] == NULL)\n         break;\n   }\n\n   /* If the driver had more extensions than we reserved, then\n    * bail out.\n    */\n   if (i == ARRAY_SIZE(__driDriverExtensions)) {\n      __driDriverExtensions[0] = NULL;\n      fprintf(stderr, \"Megadriver stub did not reserve enough extension \"\n              \"slots.\\n\");\n      return;\n   }\n}\n\n#endif /* RTLD_DEFAULT && HAVE_DLADDR */\n\nstatic const\n__DRIconfig **stub_error_init_screen(__DRIscreen *psp)\n{\n   fprintf(stderr, \"An updated DRI driver loader (libGL.so or X Server) is \"\n           \"required for this Mesa driver.\\n\");\n   return NULL;\n}\n\n/**\n * This is a stub driDriverAPI that is referenced by dri_util.c but should\n * never be used.\n */\nconst struct __DriverAPIRec driDriverAPI = {\n   .InitScreen = stub_error_init_screen,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/mesa/drivers/dri/i915/intel_screen.c": "/**************************************************************************\n * \n * Copyright 2003 VMware, Inc.\n * All Rights Reserved.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sub license, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n * \n * The above copyright notice and this permission notice (including the\n * next paragraph) shall be included in all copies or substantial portions\n * of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.\n * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR\n * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n * \n **************************************************************************/\n\n#include <errno.h>\n#include <time.h>\n#include <unistd.h>\n#include \"drm-uapi/drm_fourcc.h\"\n#include \"main/glheader.h\"\n#include \"main/context.h\"\n#include \"main/framebuffer.h\"\n#include \"main/renderbuffer.h\"\n#include \"main/texobj.h\"\n#include \"main/hash.h\"\n#include \"main/fbobject.h\"\n#include \"main/version.h\"\n#include \"swrast/s_renderbuffer.h\"\n\n#include \"utils.h\"\n#include \"util/driconf.h\"\n#include \"util/u_memory.h\"\n\nstatic const driOptionDescription i915_driconf[] = {\n   DRI_CONF_SECTION_PERFORMANCE\n      /* Options correspond to DRI_CONF_BO_REUSE_DISABLED,\n       * DRI_CONF_BO_REUSE_ALL\n       */\n      DRI_CONF_OPT_E(bo_reuse, 1, 0, 1,\n                     \"Buffer object reuse\",\n                     DRI_CONF_ENUM(0, \"Disable buffer object reuse\")\n                     DRI_CONF_ENUM(1, \"Enable reuse of all sizes of buffer objects\"))\n\n      DRI_CONF_OPT_B(fragment_shader, true,\n                     \"Enable limited ARB_fragment_shader support on 915/945.\")\n\n   DRI_CONF_SECTION_END\n   DRI_CONF_SECTION_QUALITY\n   DRI_CONF_SECTION_END\n   DRI_CONF_SECTION_DEBUG\n      DRI_CONF_ALWAYS_FLUSH_BATCH(false)\n      DRI_CONF_ALWAYS_FLUSH_CACHE(false)\n      DRI_CONF_DISABLE_THROTTLING(false)\n      DRI_CONF_FORCE_GLSL_EXTENSIONS_WARN(false)\n      DRI_CONF_DISABLE_GLSL_LINE_CONTINUATIONS(false)\n      DRI_CONF_DISABLE_BLEND_FUNC_EXTENDED(false)\n\n      DRI_CONF_OPT_B(stub_occlusion_query, false, \"Enable stub ARB_occlusion_query support on 915/945.\")\n\n      DRI_CONF_OPT_B(shader_precompile, true, \"Perform code generation at shader link time.\")\n   DRI_CONF_SECTION_END\n};\n\nstatic char *\ni915_driconf_get_xml(const char *driver_name)\n{\n   return driGetOptionsXml(i915_driconf, ARRAY_SIZE(i915_driconf));\n}\n\nstatic const __DRIconfigOptionsExtension i915_config_options = {\n   .base = { __DRI_CONFIG_OPTIONS, 2 },\n   .xml = NULL,\n   .getXml = i915_driconf_get_xml,\n};\n\n#include \"intel_batchbuffer.h\"\n#include \"intel_buffers.h\"\n#include \"intel_bufmgr.h\"\n#include \"intel_chipset.h\"\n#include \"intel_fbo.h\"\n#include \"intel_mipmap_tree.h\"\n#include \"intel_screen.h\"\n#include \"intel_tex.h\"\n#include \"intel_regions.h\"\n\n#include \"drm-uapi/i915_drm.h\"\n\n/**\n * For debugging purposes, this returns a time in seconds.\n */\ndouble\nget_time(void)\n{\n   struct timespec tp;\n\n   clock_gettime(CLOCK_MONOTONIC, &tp);\n\n   return tp.tv_sec + tp.tv_nsec / 1000000000.0;\n}\n\nvoid\naub_dump_bmp(struct gl_context *ctx)\n{\n   struct gl_framebuffer *fb = ctx->DrawBuffer;\n\n   for (int i = 0; i < fb->_NumColorDrawBuffers; i++) {\n      struct intel_renderbuffer *irb =\n\t intel_renderbuffer(fb->_ColorDrawBuffers[i]);\n\n      if (irb && irb->mt) {\n\t enum aub_dump_bmp_format format;\n\n\t switch (irb->Base.Base.Format) {\n\t case MESA_FORMAT_B8G8R8A8_UNORM:\n\t case MESA_FORMAT_B8G8R8X8_UNORM:\n\t    format = AUB_DUMP_BMP_FORMAT_ARGB_8888;\n\t    break;\n\t default:\n\t    continue;\n\t }\n\n         assert(irb->mt->region->pitch % irb->mt->region->cpp == 0);\n\t drm_intel_gem_bo_aub_dump_bmp(irb->mt->region->bo,\n\t\t\t\t       irb->draw_x,\n\t\t\t\t       irb->draw_y,\n\t\t\t\t       irb->Base.Base.Width,\n\t\t\t\t       irb->Base.Base.Height,\n\t\t\t\t       format,\n\t\t\t\t       irb->mt->region->pitch,\n\t\t\t\t       0);\n      }\n   }\n}\n\nstatic const __DRItexBufferExtension intelTexBufferExtension = {\n   .base = { __DRI_TEX_BUFFER, 3 },\n\n   .setTexBuffer        = intelSetTexBuffer,\n   .setTexBuffer2       = intelSetTexBuffer2,\n   .releaseTexBuffer    = NULL,\n};\n\nstatic void\nintelDRI2Flush(__DRIdrawable *drawable)\n{\n   GET_CURRENT_CONTEXT(ctx);\n   struct intel_context *intel = intel_context(ctx);\n   if (intel == NULL)\n      return;\n\n   INTEL_FIREVERTICES(intel);\n\n   intel->need_throttle = true;\n\n   if (intel->batch.used)\n      intel_batchbuffer_flush(intel);\n\n   if (INTEL_DEBUG & DEBUG_AUB) {\n      aub_dump_bmp(ctx);\n   }\n}\n\nstatic const struct __DRI2flushExtensionRec intelFlushExtension = {\n    .base = { __DRI2_FLUSH, 3 },\n\n    .flush              = intelDRI2Flush,\n    .invalidate         = dri2InvalidateDrawable,\n};\n\nstatic struct intel_image_format intel_image_formats[] = {\n   { DRM_FORMAT_ARGB8888, __DRI_IMAGE_COMPONENTS_RGBA, 1,\n     { { 0, 0, 0, __DRI_IMAGE_FORMAT_ARGB8888, 4 } } },\n\n   { __DRI_IMAGE_FOURCC_SARGB8888, __DRI_IMAGE_COMPONENTS_RGBA, 1,\n     { { 0, 0, 0, __DRI_IMAGE_FORMAT_SARGB8, 4 } } },\n\n   { DRM_FORMAT_XRGB8888, __DRI_IMAGE_COMPONENTS_RGB, 1,\n     { { 0, 0, 0, __DRI_IMAGE_FORMAT_XRGB8888, 4 }, } },\n\n   { DRM_FORMAT_YUV410, __DRI_IMAGE_COMPONENTS_Y_U_V, 3,\n     { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n       { 1, 2, 2, __DRI_IMAGE_FORMAT_R8, 1 },\n       { 2, 2, 2, __DRI_IMAGE_FORMAT_R8, 1 } } },\n\n   { DRM_FORMAT_YUV411, __DRI_IMAGE_COMPONENTS_Y_U_V, 3,\n     { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n       { 1, 2, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n       { 2, 2, 0, __DRI_IMAGE_FORMAT_R8, 1 } } },\n\n   { DRM_FORMAT_YUV420, __DRI_IMAGE_COMPONENTS_Y_U_V, 3,\n     { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n       { 1, 1, 1, __DRI_IMAGE_FORMAT_R8, 1 },\n       { 2, 1, 1, __DRI_IMAGE_FORMAT_R8, 1 } } },\n\n   { DRM_FORMAT_YUV422, __DRI_IMAGE_COMPONENTS_Y_U_V, 3,\n     { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n       { 1, 1, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n       { 2, 1, 0, __DRI_IMAGE_FORMAT_R8, 1 } } },\n\n   { DRM_FORMAT_YUV444, __DRI_IMAGE_COMPONENTS_Y_U_V, 3,\n     { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n       { 1, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n       { 2, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 } } },\n\n   { DRM_FORMAT_NV12, __DRI_IMAGE_COMPONENTS_Y_UV, 2,\n     { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n       { 1, 1, 1, __DRI_IMAGE_FORMAT_GR88, 2 } } },\n\n   { DRM_FORMAT_NV16, __DRI_IMAGE_COMPONENTS_Y_UV, 2,\n     { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },\n       { 1, 1, 0, __DRI_IMAGE_FORMAT_GR88, 2 } } },\n\n   /* For YUYV and UYVY buffers, we set up two overlapping DRI images\n    * and treat them as planar buffers in the compositors.\n    * Plane 0 is GR88 and samples YU or YV pairs and places Y into\n    * the R component, while plane 1 is ARGB/ABGR and samples YUYV/UYVY\n    * clusters and places pairs and places U into the G component and\n    * V into A.  This lets the texture sampler interpolate the Y\n    * components correctly when sampling from plane 0, and interpolate\n    * U and V correctly when sampling from plane 1. */\n   { DRM_FORMAT_YUYV, __DRI_IMAGE_COMPONENTS_Y_XUXV, 2,\n     { { 0, 0, 0, __DRI_IMAGE_FORMAT_GR88, 2 },\n       { 0, 1, 0, __DRI_IMAGE_FORMAT_ARGB8888, 4 } } },\n   { DRM_FORMAT_UYVY, __DRI_IMAGE_COMPONENTS_Y_UXVX, 2,\n     { { 0, 0, 0, __DRI_IMAGE_FORMAT_GR88, 2 },\n       { 0, 1, 0, __DRI_IMAGE_FORMAT_ABGR8888, 4 } } }\n};\n\nstatic __DRIimage *\nintel_allocate_image(int dri_format, void *loaderPrivate)\n{\n    __DRIimage *image;\n\n    image = calloc(1, sizeof *image);\n    if (image == NULL)\n\treturn NULL;\n\n    image->dri_format = dri_format;\n    image->offset = 0;\n\n    image->format = driImageFormatToGLFormat(dri_format);\n    if (dri_format != __DRI_IMAGE_FORMAT_NONE &&\n        image->format == MESA_FORMAT_NONE) {\n       free(image);\n       return NULL;\n    }\n\n    image->internal_format = _mesa_get_format_base_format(image->format);\n    image->data = loaderPrivate;\n\n    return image;\n}\n\n/**\n * Sets up a DRIImage structure to point to our shared image in a region\n */\nstatic void\nintel_setup_image_from_mipmap_tree(struct intel_context *intel, __DRIimage *image,\n                                   struct intel_mipmap_tree *mt, GLuint level,\n                                   GLuint zoffset)\n{\n   unsigned int draw_x, draw_y;\n   uint32_t mask_x, mask_y;\n\n   intel_miptree_check_level_layer(mt, level, zoffset);\n\n   intel_region_get_tile_masks(mt->region, &mask_x, &mask_y);\n   intel_miptree_get_image_offset(mt, level, zoffset, &draw_x, &draw_y);\n\n   image->width = mt->level[level].width;\n   image->height = mt->level[level].height;\n   image->tile_x = draw_x & mask_x;\n   image->tile_y = draw_y & mask_y;\n\n   image->offset = intel_region_get_aligned_offset(mt->region,\n                                                   draw_x & ~mask_x,\n                                                   draw_y & ~mask_y);\n\n   intel_region_reference(&image->region, mt->region);\n}\n\nstatic void\nintel_setup_image_from_dimensions(__DRIimage *image)\n{\n   image->width    = image->region->width;\n   image->height   = image->region->height;\n   image->tile_x = 0;\n   image->tile_y = 0;\n}\n\nstatic __DRIimage *\nintel_create_image_from_name(__DRIscreen *screen,\n\t\t\t     int width, int height, int format,\n\t\t\t     int name, int pitch, void *loaderPrivate)\n{\n    struct intel_screen *intelScreen = screen->driverPrivate;\n    __DRIimage *image;\n    int cpp;\n\n    image = intel_allocate_image(format, loaderPrivate);\n    if (image == NULL)\n       return NULL;\n\n    if (image->format == MESA_FORMAT_NONE)\n       cpp = 1;\n    else\n       cpp = _mesa_get_format_bytes(image->format);\n    image->region = intel_region_alloc_for_handle(intelScreen,\n\t\t\t\t\t\t  cpp, width, height,\n\t\t\t\t\t\t  pitch * cpp, name, \"image\");\n    if (image->region == NULL) {\n       free(image);\n       return NULL;\n    }\n\n    intel_setup_image_from_dimensions(image);\n\n    return image;\t\n}\n\nstatic __DRIimage *\nintel_create_image_from_renderbuffer(__DRIcontext *context,\n\t\t\t\t     int renderbuffer, void *loaderPrivate)\n{\n   __DRIimage *image;\n   struct intel_context *intel = context->driverPrivate;\n   struct gl_renderbuffer *rb;\n   struct intel_renderbuffer *irb;\n\n   rb = _mesa_lookup_renderbuffer(&intel->ctx, renderbuffer);\n   if (!rb) {\n      _mesa_error(&intel->ctx,\n\t\t  GL_INVALID_OPERATION, \"glRenderbufferExternalMESA\");\n      return NULL;\n   }\n\n   irb = intel_renderbuffer(rb);\n   image = calloc(1, sizeof *image);\n   if (image == NULL)\n      return NULL;\n\n   image->internal_format = rb->InternalFormat;\n   image->format = rb->Format;\n   image->offset = 0;\n   image->data = loaderPrivate;\n   intel_region_reference(&image->region, irb->mt->region);\n   intel_setup_image_from_dimensions(image);\n   image->dri_format = driGLFormatToImageFormat(image->format);\n\n   rb->NeedsFinishRenderTexture = true;\n   return image;\n}\n\nstatic __DRIimage *\nintel_create_image_from_texture(__DRIcontext *context, int target,\n                                unsigned texture, int zoffset,\n                                int level,\n                                unsigned *error,\n                                void *loaderPrivate)\n{\n   __DRIimage *image;\n   struct intel_context *intel = context->driverPrivate;\n   struct gl_texture_object *obj;\n   struct intel_texture_object *iobj;\n   GLuint face = 0;\n\n   obj = _mesa_lookup_texture(&intel->ctx, texture);\n   if (!obj || obj->Target != target) {\n      *error = __DRI_IMAGE_ERROR_BAD_PARAMETER;\n      return NULL;\n   }\n\n   if (target == GL_TEXTURE_CUBE_MAP)\n      face = zoffset;\n\n   _mesa_test_texobj_completeness(&intel->ctx, obj);\n   iobj = intel_texture_object(obj);\n   if (!obj->_BaseComplete || (level > 0 && !obj->_MipmapComplete)) {\n      *error = __DRI_IMAGE_ERROR_BAD_PARAMETER;\n      return NULL;\n   }\n\n   if (level < obj->Attrib.BaseLevel || level > obj->_MaxLevel) {\n      *error = __DRI_IMAGE_ERROR_BAD_MATCH;\n      return NULL;\n   }\n\n   if (target == GL_TEXTURE_3D && obj->Image[face][level]->Depth < zoffset) {\n      *error = __DRI_IMAGE_ERROR_BAD_MATCH;\n      return NULL;\n   }\n   image = calloc(1, sizeof *image);\n   if (image == NULL) {\n      *error = __DRI_IMAGE_ERROR_BAD_ALLOC;\n      return NULL;\n   }\n\n   image->internal_format = obj->Image[face][level]->InternalFormat;\n   image->format = obj->Image[face][level]->TexFormat;\n   image->data = loaderPrivate;\n   intel_setup_image_from_mipmap_tree(intel, image, iobj->mt, level, zoffset);\n   image->dri_format = driGLFormatToImageFormat(image->format);\n   if (image->dri_format == __DRI_IMAGE_FORMAT_NONE) {\n      *error = __DRI_IMAGE_ERROR_BAD_PARAMETER;\n      free(image);\n      return NULL;\n   }\n\n   *error = __DRI_IMAGE_ERROR_SUCCESS;\n   return image;\n}\n\nstatic void\nintel_destroy_image(__DRIimage *image)\n{\n    intel_region_release(&image->region);\n    free(image);\n}\n\nstatic __DRIimage *\nintel_create_image(__DRIscreen *screen,\n\t\t   int width, int height, int format,\n\t\t   unsigned int use,\n\t\t   void *loaderPrivate)\n{\n   __DRIimage *image;\n   struct intel_screen *intelScreen = screen->driverPrivate;\n   uint32_t tiling;\n   int cpp;\n\n   tiling = I915_TILING_X;\n   if (use & __DRI_IMAGE_USE_CURSOR) {\n      if (width != 64 || height != 64)\n\t return NULL;\n      tiling = I915_TILING_NONE;\n   }\n\n   if (use & __DRI_IMAGE_USE_LINEAR)\n      tiling = I915_TILING_NONE;\n\n   image = intel_allocate_image(format, loaderPrivate);\n   if (image == NULL)\n      return NULL;\n\n   cpp = _mesa_get_format_bytes(image->format);\n   image->region =\n      intel_region_alloc(intelScreen, tiling, cpp, width, height, true);\n   if (image->region == NULL) {\n      free(image);\n      return NULL;\n   }\n   \n   intel_setup_image_from_dimensions(image);\n\n   return image;\n}\n\nstatic GLboolean\nintel_query_image(__DRIimage *image, int attrib, int *value)\n{\n   switch (attrib) {\n   case __DRI_IMAGE_ATTRIB_STRIDE:\n      *value = image->region->pitch;\n      return true;\n   case __DRI_IMAGE_ATTRIB_HANDLE:\n      *value = image->region->bo->handle;\n      return true;\n   case __DRI_IMAGE_ATTRIB_NAME:\n      return intel_region_flink(image->region, (uint32_t *) value);\n   case __DRI_IMAGE_ATTRIB_FORMAT:\n      *value = image->dri_format;\n      return true;\n   case __DRI_IMAGE_ATTRIB_WIDTH:\n      *value = image->region->width;\n      return true;\n   case __DRI_IMAGE_ATTRIB_HEIGHT:\n      *value = image->region->height;\n      return true;\n   case __DRI_IMAGE_ATTRIB_COMPONENTS:\n      if (image->planar_format == NULL)\n         return false;\n      *value = image->planar_format->components;\n      return true;\n   case __DRI_IMAGE_ATTRIB_FD:\n      return !drm_intel_bo_gem_export_to_prime(image->region->bo, value);\n  default:\n      return false;\n   }\n}\n\nstatic __DRIimage *\nintel_dup_image(__DRIimage *orig_image, void *loaderPrivate)\n{\n   __DRIimage *image;\n\n   image = calloc(1, sizeof *image);\n   if (image == NULL)\n      return NULL;\n\n   intel_region_reference(&image->region, orig_image->region);\n   if (image->region == NULL) {\n      free(image);\n      return NULL;\n   }\n\n   image->internal_format = orig_image->internal_format;\n   image->planar_format   = orig_image->planar_format;\n   image->dri_format      = orig_image->dri_format;\n   image->format          = orig_image->format;\n   image->offset          = orig_image->offset;\n   image->width           = orig_image->width;\n   image->height          = orig_image->height;\n   image->tile_x          = orig_image->tile_x;\n   image->tile_y          = orig_image->tile_y;\n   image->data            = loaderPrivate;\n\n   memcpy(image->strides, orig_image->strides, sizeof(image->strides));\n   memcpy(image->offsets, orig_image->offsets, sizeof(image->offsets));\n\n   return image;\n}\n\nstatic GLboolean\nintel_validate_usage(__DRIimage *image, unsigned int use)\n{\n   if (use & __DRI_IMAGE_USE_CURSOR) {\n      if (image->region->width != 64 || image->region->height != 64)\n\t return GL_FALSE;\n   }\n\n   return GL_TRUE;\n}\n\nstatic __DRIimage *\nintel_create_image_from_names(__DRIscreen *screen,\n                              int width, int height, int fourcc,\n                              int *names, int num_names,\n                              int *strides, int *offsets,\n                              void *loaderPrivate)\n{\n    struct intel_image_format *f = NULL;\n    __DRIimage *image;\n    int i, index;\n\n    if (screen == NULL || names == NULL || num_names != 1)\n        return NULL;\n\n    for (i = 0; i < ARRAY_SIZE(intel_image_formats); i++) {\n        if (intel_image_formats[i].fourcc == fourcc) {\n           f = &intel_image_formats[i];\n        }\n    }\n\n    if (f == NULL)\n        return NULL;\n\n    image = intel_create_image_from_name(screen, width, height,\n                                         __DRI_IMAGE_FORMAT_NONE,\n                                         names[0], strides[0],\n                                         loaderPrivate);\n\n   if (image == NULL)\n      return NULL;\n\n    image->planar_format = f;\n    for (i = 0; i < f->nplanes; i++) {\n        index = f->planes[i].buffer_index;\n        image->offsets[index] = offsets[index];\n        image->strides[index] = strides[index];\n    }\n\n    return image;\n}\n\nstatic __DRIimage *\nintel_create_image_from_fds(__DRIscreen *screen,\n                            int width, int height, int fourcc,\n                            int *fds, int num_fds, int *strides, int *offsets,\n                            void *loaderPrivate)\n{\n   struct intel_screen *intelScreen = screen->driverPrivate;\n   struct intel_image_format *f = NULL;\n   __DRIimage *image;\n   int i, index;\n\n   if (fds == NULL || num_fds != 1)\n      return NULL;\n\n   for (i = 0; i < ARRAY_SIZE(intel_image_formats); i++) {\n      if (intel_image_formats[i].fourcc == fourcc) {\n         f = &intel_image_formats[i];\n      }\n   }\n\n   if (f == NULL)\n      return NULL;\n\n   image = intel_allocate_image(__DRI_IMAGE_FORMAT_NONE, loaderPrivate);\n   if (image == NULL)\n      return NULL;\n\n   image->region = intel_region_alloc_for_fd(intelScreen,\n                                             f->planes[0].cpp, width, height, strides[0],\n                                             height * strides[0], fds[0], \"image\");\n   if (image->region == NULL) {\n      free(image);\n      return NULL;\n   }\n\n   intel_setup_image_from_dimensions(image);\n\n   image->planar_format = f;\n   for (i = 0; i < f->nplanes; i++) {\n      index = f->planes[i].buffer_index;\n      image->offsets[index] = offsets[index];\n      image->strides[index] = strides[index];\n   }\n\n   return image;\n}\n\n\nstatic __DRIimage *\nintel_from_planar(__DRIimage *parent, int plane, void *loaderPrivate)\n{\n    int width, height, offset, stride, dri_format, index;\n    struct intel_image_format *f;\n    uint32_t mask_x, mask_y;\n    __DRIimage *image;\n\n    if (parent == NULL || parent->planar_format == NULL)\n        return NULL;\n\n    f = parent->planar_format;\n\n    if (plane >= f->nplanes)\n        return NULL;\n\n    width = parent->region->width >> f->planes[plane].width_shift;\n    height = parent->region->height >> f->planes[plane].height_shift;\n    dri_format = f->planes[plane].dri_format;\n    index = f->planes[plane].buffer_index;\n    offset = parent->offsets[index];\n    stride = parent->strides[index];\n\n    image = intel_allocate_image(dri_format, loaderPrivate);\n    if (image == NULL)\n       return NULL;\n\n    if (offset + height * stride > parent->region->bo->size) {\n       _mesa_warning(NULL, \"intel_create_sub_image: subimage out of bounds\");\n       free(image);\n       return NULL;\n    }\n\n    image->region = calloc(sizeof(*image->region), 1);\n    if (image->region == NULL) {\n       free(image);\n       return NULL;\n    }\n\n    image->region->cpp = _mesa_get_format_bytes(image->format);\n    image->region->width = width;\n    image->region->height = height;\n    image->region->pitch = stride;\n    image->region->refcount = 1;\n    image->region->bo = parent->region->bo;\n    drm_intel_bo_reference(image->region->bo);\n    image->region->tiling = parent->region->tiling;\n    image->offset = offset;\n    intel_setup_image_from_dimensions(image);\n\n    intel_region_get_tile_masks(image->region, &mask_x, &mask_y);\n    if (offset & mask_x)\n       _mesa_warning(NULL,\n                     \"intel_create_sub_image: offset not on tile boundary\");\n\n    return image;\n}\n\nstatic const __DRIimageExtension intelImageExtension = {\n    .base = { __DRI_IMAGE, 7 },\n\n    .createImageFromName                = intel_create_image_from_name,\n    .createImageFromRenderbuffer        = intel_create_image_from_renderbuffer,\n    .destroyImage                       = intel_destroy_image,\n    .createImage                        = intel_create_image,\n    .queryImage                         = intel_query_image,\n    .dupImage                           = intel_dup_image,\n    .validateUsage                      = intel_validate_usage,\n    .createImageFromNames               = intel_create_image_from_names,\n    .fromPlanar                         = intel_from_planar,\n    .createImageFromTexture             = intel_create_image_from_texture,\n    .createImageFromFds                 = intel_create_image_from_fds\n};\n\nstatic int\ni915_query_renderer_integer(__DRIscreen *psp, int param, unsigned int *value)\n{\n   const struct intel_screen *const intelScreen =\n      (struct intel_screen *) psp->driverPrivate;\n\n   switch (param) {\n   case __DRI2_RENDERER_VENDOR_ID:\n      value[0] = 0x8086;\n      return 0;\n   case __DRI2_RENDERER_DEVICE_ID:\n      value[0] = intelScreen->deviceID;\n      return 0;\n   case __DRI2_RENDERER_ACCELERATED:\n      value[0] = 1;\n      return 0;\n   case __DRI2_RENDERER_VIDEO_MEMORY: {\n      /* Once a batch uses more than 75% of the maximum mappable size, we\n       * assume that there's some fragmentation, and we start doing extra\n       * flushing, etc.  That's the big cliff apps will care about.\n       */\n      size_t aper_size;\n      size_t mappable_size;\n\n      drm_intel_get_aperture_sizes(psp->fd, &mappable_size, &aper_size);\n\n      const unsigned gpu_mappable_megabytes =\n         (aper_size / (1024 * 1024)) * 3 / 4;\n\n      const long system_memory_pages = sysconf(_SC_PHYS_PAGES);\n      const long system_page_size = sysconf(_SC_PAGE_SIZE);\n\n      if (system_memory_pages <= 0 || system_page_size <= 0)\n         return -1;\n\n      const uint64_t system_memory_bytes = (uint64_t) system_memory_pages\n         * (uint64_t) system_page_size;\n\n      const unsigned system_memory_megabytes =\n         (unsigned) (system_memory_bytes / (1024 * 1024));\n\n      value[0] = MIN2(system_memory_megabytes, gpu_mappable_megabytes);\n      return 0;\n   }\n   case __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE:\n      value[0] = 1;\n      return 0;\n   case __DRI2_RENDERER_HAS_TEXTURE_3D:\n      value[0] = 1;\n      return 0;\n   default:\n      return driQueryRendererIntegerCommon(psp, param, value);\n   }\n\n   return -1;\n}\n\nstatic int\ni915_query_renderer_string(__DRIscreen *psp, int param, const char **value)\n{\n   const struct intel_screen *intelScreen =\n      (struct intel_screen *) psp->driverPrivate;\n\n   switch (param) {\n   case __DRI2_RENDERER_VENDOR_ID:\n      value[0] = i915_vendor_string;\n      return 0;\n   case __DRI2_RENDERER_DEVICE_ID:\n      value[0] = i915_get_renderer_string(intelScreen->deviceID);\n      return 0;\n   default:\n      break;\n   }\n\n   return -1;\n}\n\nstatic const __DRI2rendererQueryExtension intelRendererQueryExtension = {\n   .base = { __DRI2_RENDERER_QUERY, 1 },\n\n   .queryInteger = i915_query_renderer_integer,\n   .queryString = i915_query_renderer_string\n};\n\nstatic const __DRIextension *intelScreenExtensions[] = {\n    &intelTexBufferExtension.base,\n    &intelFenceExtension.base,\n    &intelFlushExtension.base,\n    &intelImageExtension.base,\n    &intelRendererQueryExtension.base,\n    &dri2ConfigQueryExtension.base,\n    &dri2NoErrorExtension.base,\n    NULL\n};\n\nstatic bool\nintel_get_param(__DRIscreen *psp, int param, int *value)\n{\n   int ret;\n   struct drm_i915_getparam gp;\n\n   memset(&gp, 0, sizeof(gp));\n   gp.param = param;\n   gp.value = value;\n\n   ret = drmCommandWriteRead(psp->fd, DRM_I915_GETPARAM, &gp, sizeof(gp));\n   if (ret) {\n      if (ret != -EINVAL)\n\t _mesa_warning(NULL, \"drm_i915_getparam: %d\", ret);\n      return false;\n   }\n\n   return true;\n}\n\nstatic bool\nintel_get_boolean(__DRIscreen *psp, int param)\n{\n   int value = 0;\n   return intel_get_param(psp, param, &value) && value;\n}\n\nstatic void\nintelDestroyScreen(__DRIscreen * sPriv)\n{\n   struct intel_screen *intelScreen = sPriv->driverPrivate;\n\n   dri_bufmgr_destroy(intelScreen->bufmgr);\n   driDestroyOptionInfo(&intelScreen->optionCache);\n\n   free(intelScreen);\n   sPriv->driverPrivate = NULL;\n}\n\n\n/**\n * This is called when we need to set up GL rendering to a new X window.\n */\nstatic GLboolean\nintelCreateBuffer(__DRIscreen * driScrnPriv,\n                  __DRIdrawable * driDrawPriv,\n                  const struct gl_config * mesaVis, GLboolean isPixmap)\n{\n   struct intel_renderbuffer *rb;\n   mesa_format rgbFormat;\n   struct gl_framebuffer *fb;\n\n   if (isPixmap)\n      return false;\n\n   fb = CALLOC_STRUCT(gl_framebuffer);\n   if (!fb)\n      return false;\n\n   _mesa_initialize_window_framebuffer(fb, mesaVis);\n\n   if (mesaVis->redBits == 5)\n      rgbFormat = MESA_FORMAT_B5G6R5_UNORM;\n   else if (mesaVis->sRGBCapable)\n      rgbFormat = MESA_FORMAT_B8G8R8A8_SRGB;\n   else if (mesaVis->alphaBits == 0)\n      rgbFormat = MESA_FORMAT_B8G8R8X8_UNORM;\n   else\n      rgbFormat = MESA_FORMAT_B8G8R8A8_UNORM;\n\n   /* setup the hardware-based renderbuffers */\n   rb = intel_create_renderbuffer(rgbFormat);\n   _mesa_attach_and_own_rb(fb, BUFFER_FRONT_LEFT, &rb->Base.Base);\n\n   if (mesaVis->doubleBufferMode) {\n      rb = intel_create_renderbuffer(rgbFormat);\n      _mesa_attach_and_own_rb(fb, BUFFER_BACK_LEFT, &rb->Base.Base);\n   }\n\n   /*\n    * Assert here that the gl_config has an expected depth/stencil bit\n    * combination: one of d24/s8, d16/s0, d0/s0. (See intelInitScreen2(),\n    * which constructs the advertised configs.)\n    */\n   if (mesaVis->depthBits == 24) {\n      assert(mesaVis->stencilBits == 8);\n\n      /*\n       * Use combined depth/stencil. Note that the renderbuffer is\n       * attached to two attachment points.\n       */\n      rb = intel_create_private_renderbuffer(MESA_FORMAT_Z24_UNORM_S8_UINT);\n      _mesa_attach_and_own_rb(fb, BUFFER_DEPTH, &rb->Base.Base);\n      _mesa_attach_and_reference_rb(fb, BUFFER_STENCIL, &rb->Base.Base);\n   }\n   else if (mesaVis->depthBits == 16) {\n      assert(mesaVis->stencilBits == 0);\n      rb = intel_create_private_renderbuffer(MESA_FORMAT_Z_UNORM16);\n      _mesa_attach_and_own_rb(fb, BUFFER_DEPTH, &rb->Base.Base);\n   }\n   else {\n      assert(mesaVis->depthBits == 0);\n      assert(mesaVis->stencilBits == 0);\n   }\n\n   /* now add any/all software-based renderbuffers we may need */\n   _swrast_add_soft_renderbuffers(fb,\n                                  false, /* never sw color */\n                                  false, /* never sw depth */\n                                  false, /* never sw stencil */\n                                  mesaVis->accumRedBits > 0,\n                                  false, /* never sw alpha */\n                                  false  /* never sw aux */ );\n   driDrawPriv->driverPrivate = fb;\n\n   return true;\n}\n\nstatic void\nintelDestroyBuffer(__DRIdrawable * driDrawPriv)\n{\n    struct gl_framebuffer *fb = driDrawPriv->driverPrivate;\n  \n    _mesa_reference_framebuffer(&fb, NULL);\n}\n\n/* There are probably better ways to do this, such as an\n * init-designated function to register chipids and createcontext\n * functions.\n */\nextern bool\ni830CreateContext(int api,\n                  const struct gl_config *mesaVis,\n\t\t  __DRIcontext *driContextPriv,\n\t\t  unsigned major_version,\n\t\t  unsigned minor_version,\n                  uint32_t flags,\n\t\t  unsigned *error,\n\t\t  void *sharedContextPrivate);\n\nextern bool\ni915CreateContext(int api,\n\t\t  const struct gl_config *mesaVis,\n\t\t  __DRIcontext *driContextPriv,\n                  unsigned major_version,\n                  unsigned minor_version,\n                  uint32_t flags,\n                  unsigned *error,\n\t\t  void *sharedContextPrivate);\n\nstatic GLboolean\nintelCreateContext(gl_api api,\n                   const struct gl_config * mesaVis,\n                   __DRIcontext * driContextPriv,\n                   const struct __DriverContextConfig *ctx_config,\n                   unsigned *error,\n                   void *sharedContextPrivate)\n{\n   bool success = false;\n\n   __DRIscreen *sPriv = driContextPriv->driScreenPriv;\n   struct intel_screen *intelScreen = sPriv->driverPrivate;\n\n   if (ctx_config->flags & ~(__DRI_CTX_FLAG_DEBUG | __DRI_CTX_FLAG_NO_ERROR)) {\n      *error = __DRI_CTX_ERROR_UNKNOWN_FLAG;\n      return false;\n   }\n\n   if (ctx_config->attribute_mask) {\n      *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;\n      return false;\n   }\n\n   if (IS_GEN3(intelScreen->deviceID)) {\n      success = i915CreateContext(api, mesaVis, driContextPriv,\n                                  ctx_config->major_version,\n                                  ctx_config->minor_version,\n                                  ctx_config->flags,\n                                  error, sharedContextPrivate);\n   } else {\n      intelScreen->no_vbo = true;\n      success = i830CreateContext(api, mesaVis, driContextPriv,\n                                  ctx_config->major_version,\n                                  ctx_config->minor_version,\n                                  ctx_config->flags,\n                                  error, sharedContextPrivate);\n   }\n\n   if (success)\n      return true;\n\n   if (driContextPriv->driverPrivate != NULL)\n      intelDestroyContext(driContextPriv);\n\n   return false;\n}\n\nstatic bool\nintel_init_bufmgr(struct intel_screen *intelScreen)\n{\n   __DRIscreen *spriv = intelScreen->driScrnPriv;\n\n   intelScreen->no_hw = getenv(\"INTEL_NO_HW\") != NULL;\n\n   intelScreen->bufmgr = intel_bufmgr_gem_init(spriv->fd, BATCH_SZ);\n   if (intelScreen->bufmgr == NULL) {\n      fprintf(stderr, \"[%s:%u] Error initializing buffer manager.\\n\",\n\t      __func__, __LINE__);\n      return false;\n   }\n\n   drm_intel_bufmgr_gem_enable_fenced_relocs(intelScreen->bufmgr);\n\n   if (!intel_get_boolean(spriv, I915_PARAM_HAS_RELAXED_DELTA)) {\n      fprintf(stderr, \"[%s: %u] Kernel 2.6.39 required.\\n\", __func__, __LINE__);\n      return false;\n   }\n\n   return true;\n}\n\nstatic __DRIconfig**\nintel_screen_make_configs(__DRIscreen *dri_screen)\n{\n   static const mesa_format formats[] = {\n      MESA_FORMAT_B5G6R5_UNORM,\n      MESA_FORMAT_B8G8R8A8_UNORM,\n      MESA_FORMAT_B8G8R8X8_UNORM\n   };\n\n   /* __DRI_ATTRIB_SWAP_COPY is not supported due to page flipping. */\n   static const GLenum back_buffer_modes[] = {\n      __DRI_ATTRIB_SWAP_UNDEFINED, __DRI_ATTRIB_SWAP_NONE\n   };\n\n   static const uint8_t singlesample_samples[1] = {0};\n\n   uint8_t depth_bits[4], stencil_bits[4];\n   __DRIconfig **configs = NULL;\n\n   /* Generate singlesample configs without accumulation buffer. */\n   for (int i = 0; i < ARRAY_SIZE(formats); i++) {\n      __DRIconfig **new_configs;\n      int num_depth_stencil_bits = 2;\n\n      /* Starting with DRI2 protocol version 1.1 we can request a depth/stencil\n       * buffer that has a different number of bits per pixel than the color\n       * buffer.\n       */\n      depth_bits[0] = 0;\n      stencil_bits[0] = 0;\n\n      if (formats[i] == MESA_FORMAT_B5G6R5_UNORM) {\n         depth_bits[1] = 16;\n         stencil_bits[1] = 0;\n      } else {\n         depth_bits[1] = 24;\n         stencil_bits[1] = 8;\n      }\n\n      new_configs = driCreateConfigs(formats[i],\n                                     depth_bits,\n                                     stencil_bits,\n                                     num_depth_stencil_bits,\n                                     back_buffer_modes, 2,\n                                     singlesample_samples, 1,\n                                     false, false, false);\n      configs = driConcatConfigs(configs, new_configs);\n   }\n\n   /* Generate the minimum possible set of configs that include an\n    * accumulation buffer.\n    */\n   for (int i = 0; i < ARRAY_SIZE(formats); i++) {\n      __DRIconfig **new_configs;\n\n      if (formats[i] == MESA_FORMAT_B5G6R5_UNORM) {\n         depth_bits[0] = 16;\n         stencil_bits[0] = 0;\n      } else {\n         depth_bits[0] = 24;\n         stencil_bits[0] = 8;\n      }\n\n      new_configs = driCreateConfigs(formats[i],\n                                     depth_bits, stencil_bits, 1,\n                                     back_buffer_modes, 1,\n                                     singlesample_samples, 1,\n                                     true, false, false);\n      configs = driConcatConfigs(configs, new_configs);\n   }\n\n   if (configs == NULL) {\n      fprintf(stderr, \"[%s:%u] Error creating FBConfig!\\n\", __func__,\n              __LINE__);\n      return NULL;\n   }\n\n   return configs;\n}\n\nstatic void\nset_max_gl_versions(struct intel_screen *screen)\n{\n   __DRIscreen *psp = screen->driScrnPriv;\n\n   switch (screen->gen) {\n   case 3: {\n      bool has_fragment_shader = driQueryOptionb(&screen->optionCache, \"fragment_shader\");\n      bool has_occlusion_query = driQueryOptionb(&screen->optionCache, \"stub_occlusion_query\");\n\n      psp->max_gl_core_version = 0;\n      psp->max_gl_es1_version = 11;\n      psp->max_gl_es2_version = 20;\n\n      if (has_fragment_shader && has_occlusion_query) {\n         psp->max_gl_compat_version = 21;\n      } else {\n         psp->max_gl_compat_version = 14;\n      }\n      break;\n   }\n   case 2:\n      psp->max_gl_core_version = 0;\n      psp->max_gl_compat_version = 13;\n      psp->max_gl_es1_version = 11;\n      psp->max_gl_es2_version = 0;\n      break;\n   default:\n      assert(!\"unrecognized intel_screen::gen\");\n      break;\n   }\n}\n\n/**\n * This is the driver specific part of the createNewScreen entry point.\n * Called when using DRI2.\n *\n * \\return the struct gl_config supported by this driver\n */\nstatic const\n__DRIconfig **intelInitScreen2(__DRIscreen *psp)\n{\n   struct intel_screen *intelScreen;\n\n   if (psp->image.loader) {\n   } else if (psp->dri2.loader->base.version <= 2 ||\n       psp->dri2.loader->getBuffersWithFormat == NULL) {\n      fprintf(stderr,\n\t      \"\\nERROR!  DRI2 loader with getBuffersWithFormat() \"\n\t      \"support required\\n\");\n      return false;\n   }\n\n   /* Allocate the private area */\n   intelScreen = calloc(1, sizeof *intelScreen);\n   if (!intelScreen) {\n      fprintf(stderr, \"\\nERROR!  Allocating private area failed\\n\");\n      return false;\n   }\n   /* parse information in __driConfigOptions */\n   driParseOptionInfo(&intelScreen->optionCache, i915_driconf,\n                      ARRAY_SIZE(i915_driconf));\n\n   intelScreen->driScrnPriv = psp;\n   psp->driverPrivate = (void *) intelScreen;\n\n   if (!intel_init_bufmgr(intelScreen))\n       return false;\n\n   intelScreen->deviceID = drm_intel_bufmgr_gem_get_devid(intelScreen->bufmgr);\n\n   if (IS_GEN3(intelScreen->deviceID)) {\n      intelScreen->gen = 3;\n   } else {\n      intelScreen->gen = 2;\n   }\n\n   set_max_gl_versions(intelScreen);\n\n   psp->extensions = intelScreenExtensions;\n\n   return (const __DRIconfig**) intel_screen_make_configs(psp);\n}\n\nstruct intel_buffer {\n   __DRIbuffer base;\n   struct intel_region *region;\n};\n\nstatic __DRIbuffer *\nintelAllocateBuffer(__DRIscreen *screen,\n\t\t    unsigned attachment, unsigned format,\n\t\t    int width, int height)\n{\n   struct intel_buffer *intelBuffer;\n   struct intel_screen *intelScreen = screen->driverPrivate;\n\n   assert(attachment == __DRI_BUFFER_FRONT_LEFT ||\n          attachment == __DRI_BUFFER_BACK_LEFT);\n\n   intelBuffer = calloc(1, sizeof *intelBuffer);\n   if (intelBuffer == NULL)\n      return NULL;\n\n   /* The front and back buffers are color buffers, which are X tiled. */\n   intelBuffer->region = intel_region_alloc(intelScreen,\n                                            I915_TILING_X,\n                                            format / 8,\n                                            width,\n                                            height,\n                                            true);\n   \n   if (intelBuffer->region == NULL) {\n\t   free(intelBuffer);\n\t   return NULL;\n   }\n   \n   intel_region_flink(intelBuffer->region, &intelBuffer->base.name);\n\n   intelBuffer->base.attachment = attachment;\n   intelBuffer->base.cpp = intelBuffer->region->cpp;\n   intelBuffer->base.pitch = intelBuffer->region->pitch;\n\n   return &intelBuffer->base;\n}\n\nstatic void\nintelReleaseBuffer(__DRIscreen *screen, __DRIbuffer *buffer)\n{\n   struct intel_buffer *intelBuffer = (struct intel_buffer *) buffer;\n\n   intel_region_release(&intelBuffer->region);\n   free(intelBuffer);\n}\n\n\nstatic const struct __DriverAPIRec i915_driver_api = {\n   .InitScreen\t\t = intelInitScreen2,\n   .DestroyScreen\t = intelDestroyScreen,\n   .CreateContext\t = intelCreateContext,\n   .DestroyContext\t = intelDestroyContext,\n   .CreateBuffer\t = intelCreateBuffer,\n   .DestroyBuffer\t = intelDestroyBuffer,\n   .MakeCurrent\t\t = intelMakeCurrent,\n   .UnbindContext\t = intelUnbindContext,\n   .AllocateBuffer       = intelAllocateBuffer,\n   .ReleaseBuffer        = intelReleaseBuffer\n};\n\nstatic const struct __DRIDriverVtableExtensionRec i915_vtable = {\n   .base = { __DRI_DRIVER_VTABLE, 1 },\n   .vtable = &i915_driver_api,\n};\n\n/* This is the table of extensions that the loader will dlsym() for. */\nstatic const __DRIextension *i915_driver_extensions[] = {\n    &driCoreExtension.base,\n    &driImageDriverExtension.base,\n    &driDRI2Extension.base,\n    &i915_vtable.base,\n    &i915_config_options.base,\n    NULL\n};\n\nPUBLIC const __DRIextension **__driDriverGetExtensions_i915(void)\n{\n   globalDriverAPI = &i915_driver_api;\n\n   return i915_driver_extensions;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/mesa/drivers/dri/r200/radeon_screen.c": "/**************************************************************************\n\nCopyright 2000, 2001 ATI Technologies Inc., Ontario, Canada, and\n                     VA Linux Systems Inc., Fremont, California.\n\nAll Rights Reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice (including the\nnext paragraph) shall be included in all copies or substantial\nportions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n**************************************************************************/\n\n/**\n * \\file radeon_screen.c\n * Screen initialization functions for the Radeon driver.\n *\n * \\author Kevin E. Martin <martin@valinux.com>\n * \\author  Gareth Hughes <gareth@valinux.com>\n */\n\n#include <errno.h>\n#include \"main/glheader.h\"\n#include \"main/mtypes.h\"\n#include \"main/framebuffer.h\"\n#include \"main/renderbuffer.h\"\n#include \"main/fbobject.h\"\n#include \"util/u_memory.h\"\n#include \"swrast/s_renderbuffer.h\"\n\n#include \"radeon_chipset.h\"\n#include \"radeon_screen.h\"\n#include \"radeon_common.h\"\n#include \"radeon_common_context.h\"\n#if defined(RADEON_R100)\n#include \"radeon_context.h\"\n#include \"radeon_tex.h\"\n#elif defined(RADEON_R200)\n#include \"r200_context.h\"\n#include \"r200_tex.h\"\n#endif\n\n#include \"utils.h\"\n\n#include \"GL/internal/dri_interface.h\"\n\n/* Radeon configuration\n */\n#include \"util/driconf.h\"\n\n#define DRI_CONF_COMMAND_BUFFER_SIZE(def,min,max) \\\n   DRI_CONF_OPT_I(command_buffer_size, def, min, max, \\\n                  \"Size of command buffer (in KB)\")\n\n#define DRI_CONF_MAX_TEXTURE_UNITS(def,min,max) \\\n   DRI_CONF_OPT_I(texture_units,def, min, max, \\\n                  \"Number of texture units used\")\n\n#define DRI_CONF_HYPERZ(def) \\\n   DRI_CONF_OPT_B(hyperz, def, \"Use HyperZ to boost performance\")\n\n#define DRI_CONF_TCL_MODE(def) \\\n   DRI_CONF_OPT_E(tcl_mode, def, 0, 3, \\\n                  \"TCL mode (Transformation, Clipping, Lighting)\", \\\n                  DRI_CONF_ENUM(0,\"Use software TCL pipeline\") \\\n                  DRI_CONF_ENUM(1,\"Use hardware TCL as first TCL pipeline stage\") \\\n                  DRI_CONF_ENUM(2,\"Bypass the TCL pipeline\") \\\n                  DRI_CONF_ENUM(3,\"Bypass the TCL pipeline with state-based machine code generated on-the-fly\"))\n\n#define DRI_CONF_NO_NEG_LOD_BIAS(def) \\\n   DRI_CONF_OPT_B(no_neg_lod_bias, def, \"Forbid negative texture LOD bias\")\n\n#define DRI_CONF_DEF_MAX_ANISOTROPY(def, min, max) \\\n   DRI_CONF_OPT_F(def_max_anisotropy,def, min, max, \\\n                  \"Initial maximum value for anisotropic texture filtering\")\n\n#if defined(RADEON_R100)\t/* R100 */\nstatic const driOptionDescription radeon_driconf[] = {\n    DRI_CONF_SECTION_PERFORMANCE\n        DRI_CONF_TCL_MODE(DRI_CONF_TCL_CODEGEN)\n        DRI_CONF_FTHROTTLE_MODE(DRI_CONF_FTHROTTLE_IRQS)\n        DRI_CONF_MAX_TEXTURE_UNITS(3,2,3)\n        DRI_CONF_HYPERZ(false)\n        DRI_CONF_COMMAND_BUFFER_SIZE(8, 8, 32)\n    DRI_CONF_SECTION_END\n    DRI_CONF_SECTION_QUALITY\n        DRI_CONF_TEXTURE_DEPTH(DRI_CONF_TEXTURE_DEPTH_FB)\n        DRI_CONF_DEF_MAX_ANISOTROPY(1.0, 1.0, 16.0)\n        DRI_CONF_NO_NEG_LOD_BIAS(false)\n        DRI_CONF_COLOR_REDUCTION(DRI_CONF_COLOR_REDUCTION_DITHER)\n        DRI_CONF_ROUND_MODE(DRI_CONF_ROUND_TRUNC)\n        DRI_CONF_DITHER_MODE(DRI_CONF_DITHER_XERRORDIFF)\n    DRI_CONF_SECTION_END\n};\n\n#elif defined(RADEON_R200)\nstatic const driOptionDescription radeon_driconf[] = {\n    DRI_CONF_SECTION_PERFORMANCE\n        DRI_CONF_TCL_MODE(DRI_CONF_TCL_CODEGEN)\n        DRI_CONF_FTHROTTLE_MODE(DRI_CONF_FTHROTTLE_IRQS)\n        DRI_CONF_MAX_TEXTURE_UNITS(6,2,6)\n        DRI_CONF_HYPERZ(false)\n        DRI_CONF_COMMAND_BUFFER_SIZE(8, 8, 32)\n    DRI_CONF_SECTION_END\n    DRI_CONF_SECTION_QUALITY\n        DRI_CONF_TEXTURE_DEPTH(DRI_CONF_TEXTURE_DEPTH_FB)\n        DRI_CONF_DEF_MAX_ANISOTROPY(1.0, 1.0, 16.0)\n        DRI_CONF_NO_NEG_LOD_BIAS(false)\n        DRI_CONF_COLOR_REDUCTION(DRI_CONF_COLOR_REDUCTION_DITHER)\n        DRI_CONF_ROUND_MODE(DRI_CONF_ROUND_TRUNC)\n        DRI_CONF_DITHER_MODE(DRI_CONF_DITHER_XERRORDIFF)\n        DRI_CONF_OPT_F(texture_blend_quality, 1.0, 0.0, 1.0,\n                       \"Texture filtering quality vs. speed, AKA \u201cbrilinear\u201d texture filtering\")\n    DRI_CONF_SECTION_END\n};\n#endif\n\nstatic char *\nradeon_driconf_get_xml(const char *driver_name)\n{\n   return driGetOptionsXml(radeon_driconf, ARRAY_SIZE(radeon_driconf));\n}\n\nstatic const __DRIconfigOptionsExtension radeon_config_options = {\n   .base = { __DRI_CONFIG_OPTIONS, 2 },\n   .xml = NULL,\n   .getXml = radeon_driconf_get_xml,\n};\n\nstatic int\nradeonGetParam(__DRIscreen *sPriv, int param, void *value)\n{\n  struct drm_radeon_info info = { 0 };\n\n  info.value = (uint64_t)(uintptr_t)value;\n  switch (param) {\n  case RADEON_PARAM_DEVICE_ID:\n    info.request = RADEON_INFO_DEVICE_ID;\n    break;\n  case RADEON_PARAM_NUM_GB_PIPES:\n    info.request = RADEON_INFO_NUM_GB_PIPES;\n    break;\n  case RADEON_PARAM_NUM_Z_PIPES:\n    info.request = RADEON_INFO_NUM_Z_PIPES;\n    break;\n  case RADEON_INFO_TILING_CONFIG:\n    info.request = RADEON_INFO_TILING_CONFIG;\n    break;\n  default:\n    return -EINVAL;\n  }\n  return drmCommandWriteRead(sPriv->fd, DRM_RADEON_INFO, &info, sizeof(info));\n}\n\n#if defined(RADEON_R100)\nstatic const __DRItexBufferExtension radeonTexBufferExtension = {\n   .base = { __DRI_TEX_BUFFER, 3 },\n\n   .setTexBuffer        = radeonSetTexBuffer,\n   .setTexBuffer2       = radeonSetTexBuffer2,\n   .releaseTexBuffer    = NULL,\n};\n#elif defined(RADEON_R200)\nstatic const __DRItexBufferExtension r200TexBufferExtension = {\n   .base = { __DRI_TEX_BUFFER, 3 },\n\n   .setTexBuffer        = r200SetTexBuffer,\n   .setTexBuffer2       = r200SetTexBuffer2,\n   .releaseTexBuffer    = NULL,\n};\n#endif\n\nstatic void\nradeonDRI2Flush(__DRIdrawable *drawable)\n{\n    radeonContextPtr rmesa;\n\n    rmesa = (radeonContextPtr) drawable->driContextPriv->driverPrivate;\n    radeonFlush(&rmesa->glCtx);\n}\n\nstatic const struct __DRI2flushExtensionRec radeonFlushExtension = {\n   .base = { __DRI2_FLUSH, 3 },\n\n   .flush               = radeonDRI2Flush,\n   .invalidate          = dri2InvalidateDrawable,\n};\n\nstatic __DRIimage *\nradeon_create_image_from_name(__DRIscreen *screen,\n                              int width, int height, int format,\n                              int name, int pitch, void *loaderPrivate)\n{\n   __DRIimage *image;\n   radeonScreenPtr radeonScreen = screen->driverPrivate;\n\n   if (name == 0)\n      return NULL;\n\n   image = calloc(1, sizeof *image);\n   if (image == NULL)\n      return NULL;\n\n   switch (format) {\n   case __DRI_IMAGE_FORMAT_RGB565:\n      image->format = MESA_FORMAT_B5G6R5_UNORM;\n      image->internal_format = GL_RGB;\n      image->data_type = GL_UNSIGNED_BYTE;\n      break;\n   case __DRI_IMAGE_FORMAT_XRGB8888:\n      image->format = MESA_FORMAT_B8G8R8X8_UNORM;\n      image->internal_format = GL_RGB;\n      image->data_type = GL_UNSIGNED_BYTE;\n      break;\n   case __DRI_IMAGE_FORMAT_ARGB8888:\n      image->format = MESA_FORMAT_B8G8R8A8_UNORM;\n      image->internal_format = GL_RGBA;\n      image->data_type = GL_UNSIGNED_BYTE;\n      break;\n   default:\n      free(image);\n      return NULL;\n   }\n\n   image->data = loaderPrivate;\n   image->cpp = _mesa_get_format_bytes(image->format);\n   image->width = width;\n   image->pitch = pitch;\n   image->height = height;\n\n   image->bo = radeon_bo_open(radeonScreen->bom,\n                              (uint32_t)name,\n                              image->pitch * image->height * image->cpp,\n                              0,\n                              RADEON_GEM_DOMAIN_VRAM,\n                              0);\n\n   if (image->bo == NULL) {\n      free(image);\n      return NULL;\n   }\n\n   return image;\n}\n\nstatic __DRIimage *\nradeon_create_image_from_renderbuffer(__DRIcontext *context,\n                                      int renderbuffer, void *loaderPrivate)\n{\n   __DRIimage *image;\n   radeonContextPtr radeon = context->driverPrivate;\n   struct gl_renderbuffer *rb;\n   struct radeon_renderbuffer *rrb;\n\n   rb = _mesa_lookup_renderbuffer(&radeon->glCtx, renderbuffer);\n   if (!rb) {\n      _mesa_error(&radeon->glCtx,\n                  GL_INVALID_OPERATION, \"glRenderbufferExternalMESA\");\n      return NULL;\n   }\n\n   rrb = radeon_renderbuffer(rb);\n   image = calloc(1, sizeof *image);\n   if (image == NULL)\n      return NULL;\n\n   image->internal_format = rb->InternalFormat;\n   image->format = rb->Format;\n   image->cpp = rrb->cpp;\n   image->data_type = GL_UNSIGNED_BYTE;\n   image->data = loaderPrivate;\n   radeon_bo_ref(rrb->bo);\n   image->bo = rrb->bo;\n\n   image->width = rb->Width;\n   image->height = rb->Height;\n   image->pitch = rrb->pitch / image->cpp;\n\n   return image;\n}\n\nstatic void\nradeon_destroy_image(__DRIimage *image)\n{\n   radeon_bo_unref(image->bo);\n   free(image);\n}\n\nstatic __DRIimage *\nradeon_create_image(__DRIscreen *screen,\n                    int width, int height, int format,\n                    unsigned int use,\n                    void *loaderPrivate)\n{\n   __DRIimage *image;\n   radeonScreenPtr radeonScreen = screen->driverPrivate;\n\n   image = calloc(1, sizeof *image);\n   if (image == NULL)\n      return NULL;\n\n   image->dri_format = format;\n\n   switch (format) {\n   case __DRI_IMAGE_FORMAT_RGB565:\n      image->format = MESA_FORMAT_B5G6R5_UNORM;\n      image->internal_format = GL_RGB;\n      image->data_type = GL_UNSIGNED_BYTE;\n      break;\n   case __DRI_IMAGE_FORMAT_XRGB8888:\n      image->format = MESA_FORMAT_B8G8R8X8_UNORM;\n      image->internal_format = GL_RGB;\n      image->data_type = GL_UNSIGNED_BYTE;\n      break;\n   case __DRI_IMAGE_FORMAT_ARGB8888:\n      image->format = MESA_FORMAT_B8G8R8A8_UNORM;\n      image->internal_format = GL_RGBA;\n      image->data_type = GL_UNSIGNED_BYTE;\n      break;\n   default:\n      free(image);\n      return NULL;\n   }\n\n   image->data = loaderPrivate;\n   image->cpp = _mesa_get_format_bytes(image->format);\n   image->width = width;\n   image->height = height;\n   image->pitch = ((image->cpp * image->width + 255) & ~255) / image->cpp;\n\n   image->bo = radeon_bo_open(radeonScreen->bom,\n                              0,\n                              image->pitch * image->height * image->cpp,\n                              0,\n                              RADEON_GEM_DOMAIN_VRAM,\n                              0);\n\n   if (image->bo == NULL) {\n      free(image);\n      return NULL;\n   }\n\n   return image;\n}\n\nstatic GLboolean\nradeon_query_image(__DRIimage *image, int attrib, int *value)\n{\n   switch (attrib) {\n   case __DRI_IMAGE_ATTRIB_STRIDE:\n      *value = image->pitch * image->cpp;\n      return GL_TRUE;\n   case __DRI_IMAGE_ATTRIB_HANDLE:\n      *value = image->bo->handle;\n      return GL_TRUE;\n   case __DRI_IMAGE_ATTRIB_NAME:\n      radeon_gem_get_kernel_name(image->bo, (uint32_t *) value);\n      return GL_TRUE;\n   default:\n      return GL_FALSE;\n   }\n}\n\nstatic const __DRIimageExtension radeonImageExtension = {\n   .base = { __DRI_IMAGE, 1 },\n\n   .createImageFromName         = radeon_create_image_from_name,\n   .createImageFromRenderbuffer = radeon_create_image_from_renderbuffer,\n   .destroyImage                = radeon_destroy_image,\n   .createImage                 = radeon_create_image,\n   .queryImage                  = radeon_query_image\n};\n\nstatic int radeon_set_screen_flags(radeonScreenPtr screen, int device_id)\n{\n   screen->device_id = device_id;\n   screen->chip_flags = 0;\n   switch ( device_id ) {\n#if defined(RADEON_R100)\n   case PCI_CHIP_RN50_515E:\n   case PCI_CHIP_RN50_5969:\n\treturn -1;\n\n   case PCI_CHIP_RADEON_LY:\n   case PCI_CHIP_RADEON_LZ:\n   case PCI_CHIP_RADEON_QY:\n   case PCI_CHIP_RADEON_QZ:\n      screen->chip_family = CHIP_FAMILY_RV100;\n      break;\n\n   case PCI_CHIP_RS100_4136:\n   case PCI_CHIP_RS100_4336:\n      screen->chip_family = CHIP_FAMILY_RS100;\n      break;\n\n   case PCI_CHIP_RS200_4137:\n   case PCI_CHIP_RS200_4337:\n   case PCI_CHIP_RS250_4237:\n   case PCI_CHIP_RS250_4437:\n      screen->chip_family = CHIP_FAMILY_RS200;\n      break;\n\n   case PCI_CHIP_RADEON_QD:\n   case PCI_CHIP_RADEON_QE:\n   case PCI_CHIP_RADEON_QF:\n   case PCI_CHIP_RADEON_QG:\n      /* all original radeons (7200) presumably have a stencil op bug */\n      screen->chip_family = CHIP_FAMILY_R100;\n      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_BROKEN_STENCIL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;\n      break;\n\n   case PCI_CHIP_RV200_QW:\n   case PCI_CHIP_RV200_QX:\n   case PCI_CHIP_RADEON_LW:\n   case PCI_CHIP_RADEON_LX:\n      screen->chip_family = CHIP_FAMILY_RV200;\n      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;\n      break;\n\n#elif defined(RADEON_R200)\n   case PCI_CHIP_R200_BB:\n   case PCI_CHIP_R200_QH:\n   case PCI_CHIP_R200_QL:\n   case PCI_CHIP_R200_QM:\n      screen->chip_family = CHIP_FAMILY_R200;\n      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;\n      break;\n\n   case PCI_CHIP_RV250_If:\n   case PCI_CHIP_RV250_Ig:\n   case PCI_CHIP_RV250_Ld:\n   case PCI_CHIP_RV250_Lf:\n   case PCI_CHIP_RV250_Lg:\n      screen->chip_family = CHIP_FAMILY_RV250;\n      screen->chip_flags = R200_CHIPSET_YCBCR_BROKEN | RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;\n      break;\n\n   case PCI_CHIP_RV280_4C6E:\n   case PCI_CHIP_RV280_5960:\n   case PCI_CHIP_RV280_5961:\n   case PCI_CHIP_RV280_5962:\n   case PCI_CHIP_RV280_5964:\n   case PCI_CHIP_RV280_5965:\n   case PCI_CHIP_RV280_5C61:\n   case PCI_CHIP_RV280_5C63:\n      screen->chip_family = CHIP_FAMILY_RV280;\n      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;\n      break;\n\n   case PCI_CHIP_RS300_5834:\n   case PCI_CHIP_RS300_5835:\n   case PCI_CHIP_RS350_7834:\n   case PCI_CHIP_RS350_7835:\n      screen->chip_family = CHIP_FAMILY_RS300;\n      screen->chip_flags = RADEON_CHIPSET_DEPTH_ALWAYS_TILED;\n      break;\n#endif\n\n   default:\n      fprintf(stderr, \"unknown chip id 0x%x, can't guess.\\n\",\n\t      device_id);\n      return -1;\n   }\n\n   return 0;\n}\n\nstatic int\nradeonQueryRendererInteger(__DRIscreen *psp, int param,\n\t\t\t       unsigned int *value)\n{\n   radeonScreenPtr screen = (radeonScreenPtr)psp->driverPrivate;\n\n   switch (param) {\n   case __DRI2_RENDERER_VENDOR_ID:\n      value[0] = 0x1002;\n      return 0;\n   case __DRI2_RENDERER_DEVICE_ID:\n      value[0] = screen->device_id;\n      return 0;\n   case __DRI2_RENDERER_ACCELERATED:\n      value[0] = 1;\n      return 0;\n   case __DRI2_RENDERER_VIDEO_MEMORY: {\n      struct drm_radeon_gem_info gem_info;\n      int retval;\n      memset(&gem_info, 0, sizeof(gem_info));\n\n      /* Get GEM info. */\n      retval = drmCommandWriteRead(psp->fd, DRM_RADEON_GEM_INFO, &gem_info,\n\t\t\t\t   sizeof(gem_info));\n\n      if (retval) {\n         fprintf(stderr, \"radeon: Failed to get MM info, error number %d\\n\",\n                retval);\n         return -1;\n\n      }\n      /* XXX: Do we want to return vram_size or vram_visible ? */\n      value[0] = gem_info.vram_size >> 20;\n      return 0;\n   }\n   case __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE:\n      value[0] = 0;\n      return 0;\n   default:\n      return driQueryRendererIntegerCommon(psp, param, value);\n   }\n}\n\nstatic int\nradeonQueryRendererString(__DRIscreen *psp, int param, const char **value)\n{\n   radeonScreenPtr screen = (radeonScreenPtr)psp->driverPrivate;\n\n   switch (param) {\n   case __DRI2_RENDERER_VENDOR_ID:\n      value[0] = radeonVendorString;\n      return 0;\n   case __DRI2_RENDERER_DEVICE_ID:\n      value[0] = radeonGetRendererString(screen);\n      return 0;\n   default:\n      return -1;\n   }\n}\n\nstatic const __DRI2rendererQueryExtension radeonRendererQueryExtension = {\n   .base = { __DRI2_RENDERER_QUERY, 1 },\n\n   .queryInteger        = radeonQueryRendererInteger,\n   .queryString         = radeonQueryRendererString\n};\n\n\nstatic const __DRIextension *radeon_screen_extensions[] = {\n    &dri2ConfigQueryExtension.base,\n#if defined(RADEON_R100)\n    &radeonTexBufferExtension.base,\n#elif defined(RADEON_R200)\n    &r200TexBufferExtension.base,\n#endif\n    &radeonFlushExtension.base,\n    &radeonImageExtension.base,\n    &radeonRendererQueryExtension.base,\n    &dri2NoErrorExtension.base,\n    NULL\n};\n\nstatic radeonScreenPtr\nradeonCreateScreen2(__DRIscreen *sPriv)\n{\n   radeonScreenPtr screen;\n   int ret;\n   uint32_t device_id = 0;\n\n   /* Allocate the private area */\n   screen = calloc(1, sizeof(*screen));\n   if ( !screen ) {\n      fprintf(stderr, \"%s: Could not allocate memory for screen structure\", __func__);\n      fprintf(stderr, \"leaving here\\n\");\n      return NULL;\n   }\n\n   radeon_init_debug();\n\n   /* parse information in __driConfigOptions */\n   driParseOptionInfo (&screen->optionCache, radeon_driconf,\n                       ARRAY_SIZE(radeon_driconf));\n\n   screen->chip_flags = 0;\n\n   screen->irq = 1;\n\n   ret = radeonGetParam(sPriv, RADEON_PARAM_DEVICE_ID, &device_id);\n   if (ret) {\n     free( screen );\n     fprintf(stderr, \"drm_radeon_getparam_t (RADEON_PARAM_DEVICE_ID): %d\\n\", ret);\n     return NULL;\n   }\n\n   ret = radeon_set_screen_flags(screen, device_id);\n   if (ret == -1) {\n     free(screen);\n     return NULL;\n   }\n\n   if (getenv(\"RADEON_NO_TCL\"))\n\t   screen->chip_flags &= ~RADEON_CHIPSET_TCL;\n\n   sPriv->extensions = radeon_screen_extensions;\n\n   screen->driScreen = sPriv;\n   screen->bom = radeon_bo_manager_gem_ctor(sPriv->fd);\n   if (screen->bom == NULL) {\n       free(screen);\n       return NULL;\n   }\n   return screen;\n}\n\n/* Destroy the device specific screen private data struct.\n */\nstatic void\nradeonDestroyScreen( __DRIscreen *sPriv )\n{\n    radeonScreenPtr screen = (radeonScreenPtr)sPriv->driverPrivate;\n\n    if (!screen)\n        return;\n\n#ifdef RADEON_BO_TRACK\n    radeon_tracker_print(&screen->bom->tracker, stderr);\n#endif\n    radeon_bo_manager_gem_dtor(screen->bom);\n\n    /* free all option information */\n    driDestroyOptionInfo (&screen->optionCache);\n\n    free( screen );\n    sPriv->driverPrivate = NULL;\n}\n\n\n/* Initialize the driver specific screen private data.\n */\nstatic GLboolean\nradeonInitDriver( __DRIscreen *sPriv )\n{\n    sPriv->driverPrivate = (void *) radeonCreateScreen2( sPriv );\n    if ( !sPriv->driverPrivate ) {\n        radeonDestroyScreen( sPriv );\n        return GL_FALSE;\n    }\n\n    return GL_TRUE;\n}\n\n\n\n/**\n * Create the Mesa framebuffer and renderbuffers for a given window/drawable.\n *\n * \\todo This function (and its interface) will need to be updated to support\n * pbuffers.\n */\nstatic GLboolean\nradeonCreateBuffer( __DRIscreen *driScrnPriv,\n                    __DRIdrawable *driDrawPriv,\n                    const struct gl_config *mesaVis,\n                    GLboolean isPixmap )\n{\n    radeonScreenPtr screen = (radeonScreenPtr) driScrnPriv->driverPrivate;\n\n    const GLboolean swDepth = GL_FALSE;\n    const GLboolean swAlpha = GL_FALSE;\n    const GLboolean swAccum = mesaVis->accumRedBits > 0;\n    const GLboolean swStencil = mesaVis->stencilBits > 0 &&\n\tmesaVis->depthBits != 24;\n    mesa_format rgbFormat;\n    struct radeon_framebuffer *rfb;\n\n    if (isPixmap)\n      return GL_FALSE; /* not implemented */\n\n    rfb = CALLOC_STRUCT(radeon_framebuffer);\n    if (!rfb)\n      return GL_FALSE;\n\n    _mesa_initialize_window_framebuffer(&rfb->base, mesaVis);\n\n    if (mesaVis->redBits == 5)\n        rgbFormat =\n#if UTIL_ARCH_LITTLE_ENDIAN\n           MESA_FORMAT_B5G6R5_UNORM;\n#else\n           MESA_FORMAT_R5G6B5_UNORM;\n#endif\n    else if (mesaVis->alphaBits == 0)\n        rgbFormat =\n#if UTIL_ARCH_LITTLE_ENDIAN\n           MESA_FORMAT_B8G8R8X8_UNORM;\n#else\n           MESA_FORMAT_X8R8G8B8_UNORM;\n#endif\n    else\n        rgbFormat =\n#if UTIL_ARCH_LITTLE_ENDIAN\n           MESA_FORMAT_B8G8R8A8_UNORM;\n#else\n           MESA_FORMAT_A8R8G8B8_UNORM;\n#endif\n\n    /* front color renderbuffer */\n    rfb->color_rb[0] = radeon_create_renderbuffer(rgbFormat, driDrawPriv);\n    _mesa_attach_and_own_rb(&rfb->base, BUFFER_FRONT_LEFT, &rfb->color_rb[0]->base.Base);\n    rfb->color_rb[0]->has_surface = 1;\n\n    /* back color renderbuffer */\n    if (mesaVis->doubleBufferMode) {\n      rfb->color_rb[1] = radeon_create_renderbuffer(rgbFormat, driDrawPriv);\n\t_mesa_attach_and_own_rb(&rfb->base, BUFFER_BACK_LEFT, &rfb->color_rb[1]->base.Base);\n\trfb->color_rb[1]->has_surface = 1;\n    }\n\n    if (mesaVis->depthBits == 24) {\n      if (mesaVis->stencilBits == 8) {\n\tstruct radeon_renderbuffer *depthStencilRb =\n           radeon_create_renderbuffer(MESA_FORMAT_Z24_UNORM_S8_UINT, driDrawPriv);\n\t_mesa_attach_and_own_rb(&rfb->base, BUFFER_DEPTH, &depthStencilRb->base.Base);\n\t_mesa_attach_and_reference_rb(&rfb->base, BUFFER_STENCIL, &depthStencilRb->base.Base);\n\tdepthStencilRb->has_surface = screen->depthHasSurface;\n      } else {\n\t/* depth renderbuffer */\n\tstruct radeon_renderbuffer *depth =\n           radeon_create_renderbuffer(MESA_FORMAT_Z24_UNORM_X8_UINT, driDrawPriv);\n\t_mesa_attach_and_own_rb(&rfb->base, BUFFER_DEPTH, &depth->base.Base);\n\tdepth->has_surface = screen->depthHasSurface;\n      }\n    } else if (mesaVis->depthBits == 16) {\n        /* just 16-bit depth buffer, no hw stencil */\n\tstruct radeon_renderbuffer *depth =\n           radeon_create_renderbuffer(MESA_FORMAT_Z_UNORM16, driDrawPriv);\n\t_mesa_attach_and_own_rb(&rfb->base, BUFFER_DEPTH, &depth->base.Base);\n\tdepth->has_surface = screen->depthHasSurface;\n    }\n\n    _swrast_add_soft_renderbuffers(&rfb->base,\n\t    GL_FALSE, /* color */\n\t    swDepth,\n\t    swStencil,\n\t    swAccum,\n\t    swAlpha,\n\t    GL_FALSE /* aux */);\n    driDrawPriv->driverPrivate = (void *) rfb;\n\n    return (driDrawPriv->driverPrivate != NULL);\n}\n\n\nstatic void radeon_cleanup_renderbuffers(struct radeon_framebuffer *rfb)\n{\n\tstruct radeon_renderbuffer *rb;\n\n\trb = rfb->color_rb[0];\n\tif (rb && rb->bo) {\n\t\tradeon_bo_unref(rb->bo);\n\t\trb->bo = NULL;\n\t}\n\trb = rfb->color_rb[1];\n\tif (rb && rb->bo) {\n\t\tradeon_bo_unref(rb->bo);\n\t\trb->bo = NULL;\n\t}\n\trb = radeon_get_renderbuffer(&rfb->base, BUFFER_DEPTH);\n\tif (rb && rb->bo) {\n\t\tradeon_bo_unref(rb->bo);\n\t\trb->bo = NULL;\n\t}\n}\n\nvoid\nradeonDestroyBuffer(__DRIdrawable *driDrawPriv)\n{\n    struct radeon_framebuffer *rfb;\n    if (!driDrawPriv)\n\treturn;\n\n    rfb = (void*)driDrawPriv->driverPrivate;\n    if (!rfb)\n\treturn;\n    radeon_cleanup_renderbuffers(rfb);\n    _mesa_reference_framebuffer((struct gl_framebuffer **)(&(driDrawPriv->driverPrivate)), NULL);\n}\n\n/**\n * This is the driver specific part of the createNewScreen entry point.\n * Called when using DRI2.\n *\n * \\return the struct gl_config supported by this driver\n */\nstatic const\n__DRIconfig **radeonInitScreen2(__DRIscreen *psp)\n{\n   static const mesa_format formats[3] = {\n      MESA_FORMAT_B5G6R5_UNORM,\n      MESA_FORMAT_B8G8R8X8_UNORM,\n      MESA_FORMAT_B8G8R8A8_UNORM\n   };\n\n   static const GLenum back_buffer_modes[] = {\n      __DRI_ATTRIB_SWAP_NONE, __DRI_ATTRIB_SWAP_UNDEFINED\n   };\n   uint8_t depth_bits[4], stencil_bits[4], msaa_samples_array[1];\n   int color;\n   __DRIconfig **configs = NULL;\n\n   psp->max_gl_compat_version = 13;\n   psp->max_gl_es1_version = 11;\n\n   if (!radeonInitDriver(psp)) {\n       return NULL;\n    }\n   depth_bits[0] = 0;\n   stencil_bits[0] = 0;\n   depth_bits[1] = 16;\n   stencil_bits[1] = 0;\n   depth_bits[2] = 24;\n   stencil_bits[2] = 0;\n   depth_bits[3] = 24;\n   stencil_bits[3] = 8;\n\n   msaa_samples_array[0] = 0;\n\n   for (color = 0; color < ARRAY_SIZE(formats); color++) {\n      __DRIconfig **new_configs;\n\n      new_configs = driCreateConfigs(formats[color],\n\t\t\t\t     depth_bits,\n\t\t\t\t     stencil_bits,\n\t\t\t\t     ARRAY_SIZE(depth_bits),\n\t\t\t\t     back_buffer_modes,\n\t\t\t\t     ARRAY_SIZE(back_buffer_modes),\n\t\t\t\t     msaa_samples_array,\n\t\t\t\t     ARRAY_SIZE(msaa_samples_array),\n\t\t\t\t     GL_TRUE, GL_FALSE, GL_FALSE);\n      configs = driConcatConfigs(configs, new_configs);\n   }\n\n   if (configs == NULL) {\n      fprintf(stderr, \"[%s:%u] Error creating FBConfig!\\n\", __func__,\n              __LINE__);\n      return NULL;\n   }\n\n   return (const __DRIconfig **)configs;\n}\n\nstatic const struct __DriverAPIRec radeon_driver_api = {\n   .InitScreen      = radeonInitScreen2,\n   .DestroyScreen   = radeonDestroyScreen,\n#if defined(RADEON_R200)\n   .CreateContext   = r200CreateContext,\n   .DestroyContext  = r200DestroyContext,\n#else\n   .CreateContext   = r100CreateContext,\n   .DestroyContext  = radeonDestroyContext,\n#endif\n   .CreateBuffer    = radeonCreateBuffer,\n   .DestroyBuffer   = radeonDestroyBuffer,\n   .MakeCurrent     = radeonMakeCurrent,\n   .UnbindContext   = radeonUnbindContext,\n};\n\nstatic const struct __DRIDriverVtableExtensionRec radeon_vtable = {\n   .base = { __DRI_DRIVER_VTABLE, 1 },\n   .vtable = &radeon_driver_api,\n};\n\n/* This is the table of extensions that the loader will dlsym() for. */\nstatic const __DRIextension *radeon_driver_extensions[] = {\n    &driCoreExtension.base,\n    &driDRI2Extension.base,\n    &radeon_config_options.base,\n    &radeon_vtable.base,\n    NULL\n};\n\n#ifdef RADEON_R200\nPUBLIC const __DRIextension **__driDriverGetExtensions_r200(void)\n{\n   globalDriverAPI = &radeon_driver_api;\n\n   return radeon_driver_extensions;\n}\n#else\nPUBLIC const __DRIextension **__driDriverGetExtensions_radeon(void)\n{\n   globalDriverAPI = &radeon_driver_api;\n\n   return radeon_driver_extensions;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/mesa/drivers/dri/radeon/radeon_screen.c": "/**************************************************************************\n\nCopyright 2000, 2001 ATI Technologies Inc., Ontario, Canada, and\n                     VA Linux Systems Inc., Fremont, California.\n\nAll Rights Reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice (including the\nnext paragraph) shall be included in all copies or substantial\nportions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n**************************************************************************/\n\n/**\n * \\file radeon_screen.c\n * Screen initialization functions for the Radeon driver.\n *\n * \\author Kevin E. Martin <martin@valinux.com>\n * \\author  Gareth Hughes <gareth@valinux.com>\n */\n\n#include <errno.h>\n#include \"main/glheader.h\"\n#include \"main/mtypes.h\"\n#include \"main/framebuffer.h\"\n#include \"main/renderbuffer.h\"\n#include \"main/fbobject.h\"\n#include \"util/u_memory.h\"\n#include \"swrast/s_renderbuffer.h\"\n\n#include \"radeon_chipset.h\"\n#include \"radeon_screen.h\"\n#include \"radeon_common.h\"\n#include \"radeon_common_context.h\"\n#if defined(RADEON_R100)\n#include \"radeon_context.h\"\n#include \"radeon_tex.h\"\n#elif defined(RADEON_R200)\n#include \"r200_context.h\"\n#include \"r200_tex.h\"\n#endif\n\n#include \"utils.h\"\n\n#include \"GL/internal/dri_interface.h\"\n\n/* Radeon configuration\n */\n#include \"util/driconf.h\"\n\n#define DRI_CONF_COMMAND_BUFFER_SIZE(def,min,max) \\\n   DRI_CONF_OPT_I(command_buffer_size, def, min, max, \\\n                  \"Size of command buffer (in KB)\")\n\n#define DRI_CONF_MAX_TEXTURE_UNITS(def,min,max) \\\n   DRI_CONF_OPT_I(texture_units,def, min, max, \\\n                  \"Number of texture units used\")\n\n#define DRI_CONF_HYPERZ(def) \\\n   DRI_CONF_OPT_B(hyperz, def, \"Use HyperZ to boost performance\")\n\n#define DRI_CONF_TCL_MODE(def) \\\n   DRI_CONF_OPT_E(tcl_mode, def, 0, 3, \\\n                  \"TCL mode (Transformation, Clipping, Lighting)\", \\\n                  DRI_CONF_ENUM(0,\"Use software TCL pipeline\") \\\n                  DRI_CONF_ENUM(1,\"Use hardware TCL as first TCL pipeline stage\") \\\n                  DRI_CONF_ENUM(2,\"Bypass the TCL pipeline\") \\\n                  DRI_CONF_ENUM(3,\"Bypass the TCL pipeline with state-based machine code generated on-the-fly\"))\n\n#define DRI_CONF_NO_NEG_LOD_BIAS(def) \\\n   DRI_CONF_OPT_B(no_neg_lod_bias, def, \"Forbid negative texture LOD bias\")\n\n#define DRI_CONF_DEF_MAX_ANISOTROPY(def, min, max) \\\n   DRI_CONF_OPT_F(def_max_anisotropy,def, min, max, \\\n                  \"Initial maximum value for anisotropic texture filtering\")\n\n#if defined(RADEON_R100)\t/* R100 */\nstatic const driOptionDescription radeon_driconf[] = {\n    DRI_CONF_SECTION_PERFORMANCE\n        DRI_CONF_TCL_MODE(DRI_CONF_TCL_CODEGEN)\n        DRI_CONF_FTHROTTLE_MODE(DRI_CONF_FTHROTTLE_IRQS)\n        DRI_CONF_MAX_TEXTURE_UNITS(3,2,3)\n        DRI_CONF_HYPERZ(false)\n        DRI_CONF_COMMAND_BUFFER_SIZE(8, 8, 32)\n    DRI_CONF_SECTION_END\n    DRI_CONF_SECTION_QUALITY\n        DRI_CONF_TEXTURE_DEPTH(DRI_CONF_TEXTURE_DEPTH_FB)\n        DRI_CONF_DEF_MAX_ANISOTROPY(1.0, 1.0, 16.0)\n        DRI_CONF_NO_NEG_LOD_BIAS(false)\n        DRI_CONF_COLOR_REDUCTION(DRI_CONF_COLOR_REDUCTION_DITHER)\n        DRI_CONF_ROUND_MODE(DRI_CONF_ROUND_TRUNC)\n        DRI_CONF_DITHER_MODE(DRI_CONF_DITHER_XERRORDIFF)\n    DRI_CONF_SECTION_END\n};\n\n#elif defined(RADEON_R200)\nstatic const driOptionDescription radeon_driconf[] = {\n    DRI_CONF_SECTION_PERFORMANCE\n        DRI_CONF_TCL_MODE(DRI_CONF_TCL_CODEGEN)\n        DRI_CONF_FTHROTTLE_MODE(DRI_CONF_FTHROTTLE_IRQS)\n        DRI_CONF_MAX_TEXTURE_UNITS(6,2,6)\n        DRI_CONF_HYPERZ(false)\n        DRI_CONF_COMMAND_BUFFER_SIZE(8, 8, 32)\n    DRI_CONF_SECTION_END\n    DRI_CONF_SECTION_QUALITY\n        DRI_CONF_TEXTURE_DEPTH(DRI_CONF_TEXTURE_DEPTH_FB)\n        DRI_CONF_DEF_MAX_ANISOTROPY(1.0, 1.0, 16.0)\n        DRI_CONF_NO_NEG_LOD_BIAS(false)\n        DRI_CONF_COLOR_REDUCTION(DRI_CONF_COLOR_REDUCTION_DITHER)\n        DRI_CONF_ROUND_MODE(DRI_CONF_ROUND_TRUNC)\n        DRI_CONF_DITHER_MODE(DRI_CONF_DITHER_XERRORDIFF)\n        DRI_CONF_OPT_F(texture_blend_quality, 1.0, 0.0, 1.0,\n                       \"Texture filtering quality vs. speed, AKA \u201cbrilinear\u201d texture filtering\")\n    DRI_CONF_SECTION_END\n};\n#endif\n\nstatic char *\nradeon_driconf_get_xml(const char *driver_name)\n{\n   return driGetOptionsXml(radeon_driconf, ARRAY_SIZE(radeon_driconf));\n}\n\nstatic const __DRIconfigOptionsExtension radeon_config_options = {\n   .base = { __DRI_CONFIG_OPTIONS, 2 },\n   .xml = NULL,\n   .getXml = radeon_driconf_get_xml,\n};\n\nstatic int\nradeonGetParam(__DRIscreen *sPriv, int param, void *value)\n{\n  struct drm_radeon_info info = { 0 };\n\n  info.value = (uint64_t)(uintptr_t)value;\n  switch (param) {\n  case RADEON_PARAM_DEVICE_ID:\n    info.request = RADEON_INFO_DEVICE_ID;\n    break;\n  case RADEON_PARAM_NUM_GB_PIPES:\n    info.request = RADEON_INFO_NUM_GB_PIPES;\n    break;\n  case RADEON_PARAM_NUM_Z_PIPES:\n    info.request = RADEON_INFO_NUM_Z_PIPES;\n    break;\n  case RADEON_INFO_TILING_CONFIG:\n    info.request = RADEON_INFO_TILING_CONFIG;\n    break;\n  default:\n    return -EINVAL;\n  }\n  return drmCommandWriteRead(sPriv->fd, DRM_RADEON_INFO, &info, sizeof(info));\n}\n\n#if defined(RADEON_R100)\nstatic const __DRItexBufferExtension radeonTexBufferExtension = {\n   .base = { __DRI_TEX_BUFFER, 3 },\n\n   .setTexBuffer        = radeonSetTexBuffer,\n   .setTexBuffer2       = radeonSetTexBuffer2,\n   .releaseTexBuffer    = NULL,\n};\n#elif defined(RADEON_R200)\nstatic const __DRItexBufferExtension r200TexBufferExtension = {\n   .base = { __DRI_TEX_BUFFER, 3 },\n\n   .setTexBuffer        = r200SetTexBuffer,\n   .setTexBuffer2       = r200SetTexBuffer2,\n   .releaseTexBuffer    = NULL,\n};\n#endif\n\nstatic void\nradeonDRI2Flush(__DRIdrawable *drawable)\n{\n    radeonContextPtr rmesa;\n\n    rmesa = (radeonContextPtr) drawable->driContextPriv->driverPrivate;\n    radeonFlush(&rmesa->glCtx);\n}\n\nstatic const struct __DRI2flushExtensionRec radeonFlushExtension = {\n   .base = { __DRI2_FLUSH, 3 },\n\n   .flush               = radeonDRI2Flush,\n   .invalidate          = dri2InvalidateDrawable,\n};\n\nstatic __DRIimage *\nradeon_create_image_from_name(__DRIscreen *screen,\n                              int width, int height, int format,\n                              int name, int pitch, void *loaderPrivate)\n{\n   __DRIimage *image;\n   radeonScreenPtr radeonScreen = screen->driverPrivate;\n\n   if (name == 0)\n      return NULL;\n\n   image = calloc(1, sizeof *image);\n   if (image == NULL)\n      return NULL;\n\n   switch (format) {\n   case __DRI_IMAGE_FORMAT_RGB565:\n      image->format = MESA_FORMAT_B5G6R5_UNORM;\n      image->internal_format = GL_RGB;\n      image->data_type = GL_UNSIGNED_BYTE;\n      break;\n   case __DRI_IMAGE_FORMAT_XRGB8888:\n      image->format = MESA_FORMAT_B8G8R8X8_UNORM;\n      image->internal_format = GL_RGB;\n      image->data_type = GL_UNSIGNED_BYTE;\n      break;\n   case __DRI_IMAGE_FORMAT_ARGB8888:\n      image->format = MESA_FORMAT_B8G8R8A8_UNORM;\n      image->internal_format = GL_RGBA;\n      image->data_type = GL_UNSIGNED_BYTE;\n      break;\n   default:\n      free(image);\n      return NULL;\n   }\n\n   image->data = loaderPrivate;\n   image->cpp = _mesa_get_format_bytes(image->format);\n   image->width = width;\n   image->pitch = pitch;\n   image->height = height;\n\n   image->bo = radeon_bo_open(radeonScreen->bom,\n                              (uint32_t)name,\n                              image->pitch * image->height * image->cpp,\n                              0,\n                              RADEON_GEM_DOMAIN_VRAM,\n                              0);\n\n   if (image->bo == NULL) {\n      free(image);\n      return NULL;\n   }\n\n   return image;\n}\n\nstatic __DRIimage *\nradeon_create_image_from_renderbuffer(__DRIcontext *context,\n                                      int renderbuffer, void *loaderPrivate)\n{\n   __DRIimage *image;\n   radeonContextPtr radeon = context->driverPrivate;\n   struct gl_renderbuffer *rb;\n   struct radeon_renderbuffer *rrb;\n\n   rb = _mesa_lookup_renderbuffer(&radeon->glCtx, renderbuffer);\n   if (!rb) {\n      _mesa_error(&radeon->glCtx,\n                  GL_INVALID_OPERATION, \"glRenderbufferExternalMESA\");\n      return NULL;\n   }\n\n   rrb = radeon_renderbuffer(rb);\n   image = calloc(1, sizeof *image);\n   if (image == NULL)\n      return NULL;\n\n   image->internal_format = rb->InternalFormat;\n   image->format = rb->Format;\n   image->cpp = rrb->cpp;\n   image->data_type = GL_UNSIGNED_BYTE;\n   image->data = loaderPrivate;\n   radeon_bo_ref(rrb->bo);\n   image->bo = rrb->bo;\n\n   image->width = rb->Width;\n   image->height = rb->Height;\n   image->pitch = rrb->pitch / image->cpp;\n\n   return image;\n}\n\nstatic void\nradeon_destroy_image(__DRIimage *image)\n{\n   radeon_bo_unref(image->bo);\n   free(image);\n}\n\nstatic __DRIimage *\nradeon_create_image(__DRIscreen *screen,\n                    int width, int height, int format,\n                    unsigned int use,\n                    void *loaderPrivate)\n{\n   __DRIimage *image;\n   radeonScreenPtr radeonScreen = screen->driverPrivate;\n\n   image = calloc(1, sizeof *image);\n   if (image == NULL)\n      return NULL;\n\n   image->dri_format = format;\n\n   switch (format) {\n   case __DRI_IMAGE_FORMAT_RGB565:\n      image->format = MESA_FORMAT_B5G6R5_UNORM;\n      image->internal_format = GL_RGB;\n      image->data_type = GL_UNSIGNED_BYTE;\n      break;\n   case __DRI_IMAGE_FORMAT_XRGB8888:\n      image->format = MESA_FORMAT_B8G8R8X8_UNORM;\n      image->internal_format = GL_RGB;\n      image->data_type = GL_UNSIGNED_BYTE;\n      break;\n   case __DRI_IMAGE_FORMAT_ARGB8888:\n      image->format = MESA_FORMAT_B8G8R8A8_UNORM;\n      image->internal_format = GL_RGBA;\n      image->data_type = GL_UNSIGNED_BYTE;\n      break;\n   default:\n      free(image);\n      return NULL;\n   }\n\n   image->data = loaderPrivate;\n   image->cpp = _mesa_get_format_bytes(image->format);\n   image->width = width;\n   image->height = height;\n   image->pitch = ((image->cpp * image->width + 255) & ~255) / image->cpp;\n\n   image->bo = radeon_bo_open(radeonScreen->bom,\n                              0,\n                              image->pitch * image->height * image->cpp,\n                              0,\n                              RADEON_GEM_DOMAIN_VRAM,\n                              0);\n\n   if (image->bo == NULL) {\n      free(image);\n      return NULL;\n   }\n\n   return image;\n}\n\nstatic GLboolean\nradeon_query_image(__DRIimage *image, int attrib, int *value)\n{\n   switch (attrib) {\n   case __DRI_IMAGE_ATTRIB_STRIDE:\n      *value = image->pitch * image->cpp;\n      return GL_TRUE;\n   case __DRI_IMAGE_ATTRIB_HANDLE:\n      *value = image->bo->handle;\n      return GL_TRUE;\n   case __DRI_IMAGE_ATTRIB_NAME:\n      radeon_gem_get_kernel_name(image->bo, (uint32_t *) value);\n      return GL_TRUE;\n   default:\n      return GL_FALSE;\n   }\n}\n\nstatic const __DRIimageExtension radeonImageExtension = {\n   .base = { __DRI_IMAGE, 1 },\n\n   .createImageFromName         = radeon_create_image_from_name,\n   .createImageFromRenderbuffer = radeon_create_image_from_renderbuffer,\n   .destroyImage                = radeon_destroy_image,\n   .createImage                 = radeon_create_image,\n   .queryImage                  = radeon_query_image\n};\n\nstatic int radeon_set_screen_flags(radeonScreenPtr screen, int device_id)\n{\n   screen->device_id = device_id;\n   screen->chip_flags = 0;\n   switch ( device_id ) {\n#if defined(RADEON_R100)\n   case PCI_CHIP_RN50_515E:\n   case PCI_CHIP_RN50_5969:\n\treturn -1;\n\n   case PCI_CHIP_RADEON_LY:\n   case PCI_CHIP_RADEON_LZ:\n   case PCI_CHIP_RADEON_QY:\n   case PCI_CHIP_RADEON_QZ:\n      screen->chip_family = CHIP_FAMILY_RV100;\n      break;\n\n   case PCI_CHIP_RS100_4136:\n   case PCI_CHIP_RS100_4336:\n      screen->chip_family = CHIP_FAMILY_RS100;\n      break;\n\n   case PCI_CHIP_RS200_4137:\n   case PCI_CHIP_RS200_4337:\n   case PCI_CHIP_RS250_4237:\n   case PCI_CHIP_RS250_4437:\n      screen->chip_family = CHIP_FAMILY_RS200;\n      break;\n\n   case PCI_CHIP_RADEON_QD:\n   case PCI_CHIP_RADEON_QE:\n   case PCI_CHIP_RADEON_QF:\n   case PCI_CHIP_RADEON_QG:\n      /* all original radeons (7200) presumably have a stencil op bug */\n      screen->chip_family = CHIP_FAMILY_R100;\n      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_BROKEN_STENCIL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;\n      break;\n\n   case PCI_CHIP_RV200_QW:\n   case PCI_CHIP_RV200_QX:\n   case PCI_CHIP_RADEON_LW:\n   case PCI_CHIP_RADEON_LX:\n      screen->chip_family = CHIP_FAMILY_RV200;\n      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;\n      break;\n\n#elif defined(RADEON_R200)\n   case PCI_CHIP_R200_BB:\n   case PCI_CHIP_R200_QH:\n   case PCI_CHIP_R200_QL:\n   case PCI_CHIP_R200_QM:\n      screen->chip_family = CHIP_FAMILY_R200;\n      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;\n      break;\n\n   case PCI_CHIP_RV250_If:\n   case PCI_CHIP_RV250_Ig:\n   case PCI_CHIP_RV250_Ld:\n   case PCI_CHIP_RV250_Lf:\n   case PCI_CHIP_RV250_Lg:\n      screen->chip_family = CHIP_FAMILY_RV250;\n      screen->chip_flags = R200_CHIPSET_YCBCR_BROKEN | RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;\n      break;\n\n   case PCI_CHIP_RV280_4C6E:\n   case PCI_CHIP_RV280_5960:\n   case PCI_CHIP_RV280_5961:\n   case PCI_CHIP_RV280_5962:\n   case PCI_CHIP_RV280_5964:\n   case PCI_CHIP_RV280_5965:\n   case PCI_CHIP_RV280_5C61:\n   case PCI_CHIP_RV280_5C63:\n      screen->chip_family = CHIP_FAMILY_RV280;\n      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;\n      break;\n\n   case PCI_CHIP_RS300_5834:\n   case PCI_CHIP_RS300_5835:\n   case PCI_CHIP_RS350_7834:\n   case PCI_CHIP_RS350_7835:\n      screen->chip_family = CHIP_FAMILY_RS300;\n      screen->chip_flags = RADEON_CHIPSET_DEPTH_ALWAYS_TILED;\n      break;\n#endif\n\n   default:\n      fprintf(stderr, \"unknown chip id 0x%x, can't guess.\\n\",\n\t      device_id);\n      return -1;\n   }\n\n   return 0;\n}\n\nstatic int\nradeonQueryRendererInteger(__DRIscreen *psp, int param,\n\t\t\t       unsigned int *value)\n{\n   radeonScreenPtr screen = (radeonScreenPtr)psp->driverPrivate;\n\n   switch (param) {\n   case __DRI2_RENDERER_VENDOR_ID:\n      value[0] = 0x1002;\n      return 0;\n   case __DRI2_RENDERER_DEVICE_ID:\n      value[0] = screen->device_id;\n      return 0;\n   case __DRI2_RENDERER_ACCELERATED:\n      value[0] = 1;\n      return 0;\n   case __DRI2_RENDERER_VIDEO_MEMORY: {\n      struct drm_radeon_gem_info gem_info;\n      int retval;\n      memset(&gem_info, 0, sizeof(gem_info));\n\n      /* Get GEM info. */\n      retval = drmCommandWriteRead(psp->fd, DRM_RADEON_GEM_INFO, &gem_info,\n\t\t\t\t   sizeof(gem_info));\n\n      if (retval) {\n         fprintf(stderr, \"radeon: Failed to get MM info, error number %d\\n\",\n                retval);\n         return -1;\n\n      }\n      /* XXX: Do we want to return vram_size or vram_visible ? */\n      value[0] = gem_info.vram_size >> 20;\n      return 0;\n   }\n   case __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE:\n      value[0] = 0;\n      return 0;\n   default:\n      return driQueryRendererIntegerCommon(psp, param, value);\n   }\n}\n\nstatic int\nradeonQueryRendererString(__DRIscreen *psp, int param, const char **value)\n{\n   radeonScreenPtr screen = (radeonScreenPtr)psp->driverPrivate;\n\n   switch (param) {\n   case __DRI2_RENDERER_VENDOR_ID:\n      value[0] = radeonVendorString;\n      return 0;\n   case __DRI2_RENDERER_DEVICE_ID:\n      value[0] = radeonGetRendererString(screen);\n      return 0;\n   default:\n      return -1;\n   }\n}\n\nstatic const __DRI2rendererQueryExtension radeonRendererQueryExtension = {\n   .base = { __DRI2_RENDERER_QUERY, 1 },\n\n   .queryInteger        = radeonQueryRendererInteger,\n   .queryString         = radeonQueryRendererString\n};\n\n\nstatic const __DRIextension *radeon_screen_extensions[] = {\n    &dri2ConfigQueryExtension.base,\n#if defined(RADEON_R100)\n    &radeonTexBufferExtension.base,\n#elif defined(RADEON_R200)\n    &r200TexBufferExtension.base,\n#endif\n    &radeonFlushExtension.base,\n    &radeonImageExtension.base,\n    &radeonRendererQueryExtension.base,\n    &dri2NoErrorExtension.base,\n    NULL\n};\n\nstatic radeonScreenPtr\nradeonCreateScreen2(__DRIscreen *sPriv)\n{\n   radeonScreenPtr screen;\n   int ret;\n   uint32_t device_id = 0;\n\n   /* Allocate the private area */\n   screen = calloc(1, sizeof(*screen));\n   if ( !screen ) {\n      fprintf(stderr, \"%s: Could not allocate memory for screen structure\", __func__);\n      fprintf(stderr, \"leaving here\\n\");\n      return NULL;\n   }\n\n   radeon_init_debug();\n\n   /* parse information in __driConfigOptions */\n   driParseOptionInfo (&screen->optionCache, radeon_driconf,\n                       ARRAY_SIZE(radeon_driconf));\n\n   screen->chip_flags = 0;\n\n   screen->irq = 1;\n\n   ret = radeonGetParam(sPriv, RADEON_PARAM_DEVICE_ID, &device_id);\n   if (ret) {\n     free( screen );\n     fprintf(stderr, \"drm_radeon_getparam_t (RADEON_PARAM_DEVICE_ID): %d\\n\", ret);\n     return NULL;\n   }\n\n   ret = radeon_set_screen_flags(screen, device_id);\n   if (ret == -1) {\n     free(screen);\n     return NULL;\n   }\n\n   if (getenv(\"RADEON_NO_TCL\"))\n\t   screen->chip_flags &= ~RADEON_CHIPSET_TCL;\n\n   sPriv->extensions = radeon_screen_extensions;\n\n   screen->driScreen = sPriv;\n   screen->bom = radeon_bo_manager_gem_ctor(sPriv->fd);\n   if (screen->bom == NULL) {\n       free(screen);\n       return NULL;\n   }\n   return screen;\n}\n\n/* Destroy the device specific screen private data struct.\n */\nstatic void\nradeonDestroyScreen( __DRIscreen *sPriv )\n{\n    radeonScreenPtr screen = (radeonScreenPtr)sPriv->driverPrivate;\n\n    if (!screen)\n        return;\n\n#ifdef RADEON_BO_TRACK\n    radeon_tracker_print(&screen->bom->tracker, stderr);\n#endif\n    radeon_bo_manager_gem_dtor(screen->bom);\n\n    /* free all option information */\n    driDestroyOptionInfo (&screen->optionCache);\n\n    free( screen );\n    sPriv->driverPrivate = NULL;\n}\n\n\n/* Initialize the driver specific screen private data.\n */\nstatic GLboolean\nradeonInitDriver( __DRIscreen *sPriv )\n{\n    sPriv->driverPrivate = (void *) radeonCreateScreen2( sPriv );\n    if ( !sPriv->driverPrivate ) {\n        radeonDestroyScreen( sPriv );\n        return GL_FALSE;\n    }\n\n    return GL_TRUE;\n}\n\n\n\n/**\n * Create the Mesa framebuffer and renderbuffers for a given window/drawable.\n *\n * \\todo This function (and its interface) will need to be updated to support\n * pbuffers.\n */\nstatic GLboolean\nradeonCreateBuffer( __DRIscreen *driScrnPriv,\n                    __DRIdrawable *driDrawPriv,\n                    const struct gl_config *mesaVis,\n                    GLboolean isPixmap )\n{\n    radeonScreenPtr screen = (radeonScreenPtr) driScrnPriv->driverPrivate;\n\n    const GLboolean swDepth = GL_FALSE;\n    const GLboolean swAlpha = GL_FALSE;\n    const GLboolean swAccum = mesaVis->accumRedBits > 0;\n    const GLboolean swStencil = mesaVis->stencilBits > 0 &&\n\tmesaVis->depthBits != 24;\n    mesa_format rgbFormat;\n    struct radeon_framebuffer *rfb;\n\n    if (isPixmap)\n      return GL_FALSE; /* not implemented */\n\n    rfb = CALLOC_STRUCT(radeon_framebuffer);\n    if (!rfb)\n      return GL_FALSE;\n\n    _mesa_initialize_window_framebuffer(&rfb->base, mesaVis);\n\n    if (mesaVis->redBits == 5)\n        rgbFormat =\n#if UTIL_ARCH_LITTLE_ENDIAN\n           MESA_FORMAT_B5G6R5_UNORM;\n#else\n           MESA_FORMAT_R5G6B5_UNORM;\n#endif\n    else if (mesaVis->alphaBits == 0)\n        rgbFormat =\n#if UTIL_ARCH_LITTLE_ENDIAN\n           MESA_FORMAT_B8G8R8X8_UNORM;\n#else\n           MESA_FORMAT_X8R8G8B8_UNORM;\n#endif\n    else\n        rgbFormat =\n#if UTIL_ARCH_LITTLE_ENDIAN\n           MESA_FORMAT_B8G8R8A8_UNORM;\n#else\n           MESA_FORMAT_A8R8G8B8_UNORM;\n#endif\n\n    /* front color renderbuffer */\n    rfb->color_rb[0] = radeon_create_renderbuffer(rgbFormat, driDrawPriv);\n    _mesa_attach_and_own_rb(&rfb->base, BUFFER_FRONT_LEFT, &rfb->color_rb[0]->base.Base);\n    rfb->color_rb[0]->has_surface = 1;\n\n    /* back color renderbuffer */\n    if (mesaVis->doubleBufferMode) {\n      rfb->color_rb[1] = radeon_create_renderbuffer(rgbFormat, driDrawPriv);\n\t_mesa_attach_and_own_rb(&rfb->base, BUFFER_BACK_LEFT, &rfb->color_rb[1]->base.Base);\n\trfb->color_rb[1]->has_surface = 1;\n    }\n\n    if (mesaVis->depthBits == 24) {\n      if (mesaVis->stencilBits == 8) {\n\tstruct radeon_renderbuffer *depthStencilRb =\n           radeon_create_renderbuffer(MESA_FORMAT_Z24_UNORM_S8_UINT, driDrawPriv);\n\t_mesa_attach_and_own_rb(&rfb->base, BUFFER_DEPTH, &depthStencilRb->base.Base);\n\t_mesa_attach_and_reference_rb(&rfb->base, BUFFER_STENCIL, &depthStencilRb->base.Base);\n\tdepthStencilRb->has_surface = screen->depthHasSurface;\n      } else {\n\t/* depth renderbuffer */\n\tstruct radeon_renderbuffer *depth =\n           radeon_create_renderbuffer(MESA_FORMAT_Z24_UNORM_X8_UINT, driDrawPriv);\n\t_mesa_attach_and_own_rb(&rfb->base, BUFFER_DEPTH, &depth->base.Base);\n\tdepth->has_surface = screen->depthHasSurface;\n      }\n    } else if (mesaVis->depthBits == 16) {\n        /* just 16-bit depth buffer, no hw stencil */\n\tstruct radeon_renderbuffer *depth =\n           radeon_create_renderbuffer(MESA_FORMAT_Z_UNORM16, driDrawPriv);\n\t_mesa_attach_and_own_rb(&rfb->base, BUFFER_DEPTH, &depth->base.Base);\n\tdepth->has_surface = screen->depthHasSurface;\n    }\n\n    _swrast_add_soft_renderbuffers(&rfb->base,\n\t    GL_FALSE, /* color */\n\t    swDepth,\n\t    swStencil,\n\t    swAccum,\n\t    swAlpha,\n\t    GL_FALSE /* aux */);\n    driDrawPriv->driverPrivate = (void *) rfb;\n\n    return (driDrawPriv->driverPrivate != NULL);\n}\n\n\nstatic void radeon_cleanup_renderbuffers(struct radeon_framebuffer *rfb)\n{\n\tstruct radeon_renderbuffer *rb;\n\n\trb = rfb->color_rb[0];\n\tif (rb && rb->bo) {\n\t\tradeon_bo_unref(rb->bo);\n\t\trb->bo = NULL;\n\t}\n\trb = rfb->color_rb[1];\n\tif (rb && rb->bo) {\n\t\tradeon_bo_unref(rb->bo);\n\t\trb->bo = NULL;\n\t}\n\trb = radeon_get_renderbuffer(&rfb->base, BUFFER_DEPTH);\n\tif (rb && rb->bo) {\n\t\tradeon_bo_unref(rb->bo);\n\t\trb->bo = NULL;\n\t}\n}\n\nvoid\nradeonDestroyBuffer(__DRIdrawable *driDrawPriv)\n{\n    struct radeon_framebuffer *rfb;\n    if (!driDrawPriv)\n\treturn;\n\n    rfb = (void*)driDrawPriv->driverPrivate;\n    if (!rfb)\n\treturn;\n    radeon_cleanup_renderbuffers(rfb);\n    _mesa_reference_framebuffer((struct gl_framebuffer **)(&(driDrawPriv->driverPrivate)), NULL);\n}\n\n/**\n * This is the driver specific part of the createNewScreen entry point.\n * Called when using DRI2.\n *\n * \\return the struct gl_config supported by this driver\n */\nstatic const\n__DRIconfig **radeonInitScreen2(__DRIscreen *psp)\n{\n   static const mesa_format formats[3] = {\n      MESA_FORMAT_B5G6R5_UNORM,\n      MESA_FORMAT_B8G8R8X8_UNORM,\n      MESA_FORMAT_B8G8R8A8_UNORM\n   };\n\n   static const GLenum back_buffer_modes[] = {\n      __DRI_ATTRIB_SWAP_NONE, __DRI_ATTRIB_SWAP_UNDEFINED\n   };\n   uint8_t depth_bits[4], stencil_bits[4], msaa_samples_array[1];\n   int color;\n   __DRIconfig **configs = NULL;\n\n   psp->max_gl_compat_version = 13;\n   psp->max_gl_es1_version = 11;\n\n   if (!radeonInitDriver(psp)) {\n       return NULL;\n    }\n   depth_bits[0] = 0;\n   stencil_bits[0] = 0;\n   depth_bits[1] = 16;\n   stencil_bits[1] = 0;\n   depth_bits[2] = 24;\n   stencil_bits[2] = 0;\n   depth_bits[3] = 24;\n   stencil_bits[3] = 8;\n\n   msaa_samples_array[0] = 0;\n\n   for (color = 0; color < ARRAY_SIZE(formats); color++) {\n      __DRIconfig **new_configs;\n\n      new_configs = driCreateConfigs(formats[color],\n\t\t\t\t     depth_bits,\n\t\t\t\t     stencil_bits,\n\t\t\t\t     ARRAY_SIZE(depth_bits),\n\t\t\t\t     back_buffer_modes,\n\t\t\t\t     ARRAY_SIZE(back_buffer_modes),\n\t\t\t\t     msaa_samples_array,\n\t\t\t\t     ARRAY_SIZE(msaa_samples_array),\n\t\t\t\t     GL_TRUE, GL_FALSE, GL_FALSE);\n      configs = driConcatConfigs(configs, new_configs);\n   }\n\n   if (configs == NULL) {\n      fprintf(stderr, \"[%s:%u] Error creating FBConfig!\\n\", __func__,\n              __LINE__);\n      return NULL;\n   }\n\n   return (const __DRIconfig **)configs;\n}\n\nstatic const struct __DriverAPIRec radeon_driver_api = {\n   .InitScreen      = radeonInitScreen2,\n   .DestroyScreen   = radeonDestroyScreen,\n#if defined(RADEON_R200)\n   .CreateContext   = r200CreateContext,\n   .DestroyContext  = r200DestroyContext,\n#else\n   .CreateContext   = r100CreateContext,\n   .DestroyContext  = radeonDestroyContext,\n#endif\n   .CreateBuffer    = radeonCreateBuffer,\n   .DestroyBuffer   = radeonDestroyBuffer,\n   .MakeCurrent     = radeonMakeCurrent,\n   .UnbindContext   = radeonUnbindContext,\n};\n\nstatic const struct __DRIDriverVtableExtensionRec radeon_vtable = {\n   .base = { __DRI_DRIVER_VTABLE, 1 },\n   .vtable = &radeon_driver_api,\n};\n\n/* This is the table of extensions that the loader will dlsym() for. */\nstatic const __DRIextension *radeon_driver_extensions[] = {\n    &driCoreExtension.base,\n    &driDRI2Extension.base,\n    &radeon_config_options.base,\n    &radeon_vtable.base,\n    NULL\n};\n\n#ifdef RADEON_R200\nPUBLIC const __DRIextension **__driDriverGetExtensions_r200(void)\n{\n   globalDriverAPI = &radeon_driver_api;\n\n   return radeon_driver_extensions;\n}\n#else\nPUBLIC const __DRIextension **__driDriverGetExtensions_radeon(void)\n{\n   globalDriverAPI = &radeon_driver_api;\n\n   return radeon_driver_extensions;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/mesa/drivers/dri/nouveau/nouveau_screen.c": "/*\n * Copyright (C) 2009 Francisco Jerez.\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice (including the\n * next paragraph) shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\n\n#include <stdio.h>\n#include <xf86drm.h>\n#include <nouveau_drm.h>\n#include \"nouveau_driver.h\"\n#include \"nouveau_context.h\"\n#include \"nouveau_fbo.h\"\n#include \"nouveau_texture.h\"\n#include \"nv04_driver.h\"\n#include \"nv10_driver.h\"\n#include \"nv20_driver.h\"\n\n#include \"main/framebuffer.h\"\n#include \"main/fbobject.h\"\n#include \"main/renderbuffer.h\"\n#include \"util/u_memory.h\"\n#include \"swrast/s_renderbuffer.h\"\n\n#include <nvif/class.h>\n#include <nvif/cl0080.h>\n\nstatic const __DRIextension *nouveau_screen_extensions[];\n\nstatic void\nnouveau_destroy_screen(__DRIscreen *dri_screen);\n\nstatic const __DRIconfig **\nnouveau_get_configs(uint32_t chipset)\n{\n\t__DRIconfig **configs = NULL;\n\tint i;\n\n\tconst uint8_t depth_bits[]   = { 0, 16, 24, 24 };\n\tconst uint8_t stencil_bits[] = { 0,  0,  0,  8 };\n\tconst uint8_t msaa_samples[] = { 0 };\n\n\tstatic const mesa_format formats[3] = {\n\t\tMESA_FORMAT_B5G6R5_UNORM,\n\t\tMESA_FORMAT_B8G8R8A8_UNORM,\n\t\tMESA_FORMAT_B8G8R8X8_UNORM,\n\t};\n\n\tconst GLenum back_buffer_modes[] = {\n\t\t__DRI_ATTRIB_SWAP_NONE, __DRI_ATTRIB_SWAP_UNDEFINED\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++) {\n\t\t__DRIconfig **config;\n\n\t\tconfig = driCreateConfigs(formats[i],\n\t\t\t\t\t  depth_bits, stencil_bits,\n\t\t\t\t\t  ARRAY_SIZE(depth_bits),\n\t\t\t\t\t  back_buffer_modes,\n\t\t\t\t\t  ARRAY_SIZE(back_buffer_modes),\n\t\t\t\t\t  msaa_samples,\n\t\t\t\t\t  ARRAY_SIZE(msaa_samples),\n\t\t\t\t\t  GL_TRUE, chipset < 0x10, GL_FALSE);\n\t\tassert(config);\n\n\t\tconfigs = driConcatConfigs(configs, config);\n\t}\n\n\treturn (const __DRIconfig **)configs;\n}\n\nstatic const __DRIconfig **\nnouveau_init_screen2(__DRIscreen *dri_screen)\n{\n\tconst __DRIconfig **configs;\n\tstruct nouveau_screen *screen;\n\tint ret;\n\n\t/* Allocate the screen. */\n\tscreen = CALLOC_STRUCT(nouveau_screen);\n\tif (!screen)\n\t\treturn NULL;\n\n\tdri_screen->driverPrivate = screen;\n\n\t/* Open the DRM device. */\n\tret = nouveau_drm_new(dri_screen->fd, &screen->drm);\n\tif (ret) {\n\t\tnouveau_error(\"Error opening the DRM device.\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = nouveau_device_new(&screen->drm->client, NV_DEVICE,\n\t\t\t\t &(struct nv_device_v0) {\n\t\t\t\t\t.device = ~0ULL,\n\t\t\t\t }, sizeof(struct nv_device_v0),\n\t\t\t\t &screen->device);\n\tif (ret) {\n\t\tnouveau_error(\"Error creating device object.\\n\");\n\t\tgoto fail;\n\t}\n\n\t/* Choose the card specific function pointers. */\n\tswitch (screen->device->chipset & 0xf0) {\n\tcase 0x00:\n\t\tscreen->driver = &nv04_driver;\n\t\tdri_screen->max_gl_compat_version = 12;\n\t\tbreak;\n\tcase 0x10:\n\t\tscreen->driver = &nv10_driver;\n\t\tdri_screen->max_gl_compat_version = 12;\n\t\tdri_screen->max_gl_es1_version = 10;\n\t\tbreak;\n\tcase 0x20:\n\tcase 0x30:\n\t\tscreen->driver = &nv20_driver;\n\t\tdri_screen->max_gl_compat_version = 13;\n\t\tdri_screen->max_gl_es1_version = 10;\n\t\tbreak;\n\tdefault:\n\t\tnouveau_error(\"Unknown chipset: %02X\\n\",\n\t\t\t      screen->device->chipset);\n\t\tgoto fail;\n\t}\n\n\tdri_screen->extensions = nouveau_screen_extensions;\n\tscreen->dri_screen = dri_screen;\n\n\tconfigs = nouveau_get_configs(screen->device->chipset);\n\tif (!configs)\n\t\tgoto fail;\n\n\treturn configs;\nfail:\n\tnouveau_destroy_screen(dri_screen);\n\treturn NULL;\n\n}\n\nstatic int\nnouveau_query_renderer_integer(__DRIscreen *psp, int param,\n\t\t\t       unsigned int *value)\n{\n\tconst struct nouveau_screen *const screen =\n\t\t(struct nouveau_screen *) psp->driverPrivate;\n\n\tswitch (param) {\n\tcase __DRI2_RENDERER_VENDOR_ID:\n\t\tvalue[0] = 0x10de;\n\t\treturn 0;\n\tcase __DRI2_RENDERER_DEVICE_ID: {\n\t\tuint64_t device_id;\n\n\t\tif (nouveau_getparam(screen->device,\n\t\t\t\t     NOUVEAU_GETPARAM_PCI_DEVICE,\n\t\t\t\t     &device_id)) {\n\t\t\tnouveau_error(\"Error retrieving the device PCIID.\\n\");\n\t\t\tdevice_id = -1;\n\t\t}\n\t\tvalue[0] = (unsigned int) device_id;\n\t\treturn 0;\n\t}\n\tcase __DRI2_RENDERER_ACCELERATED:\n\t\tvalue[0] = 1;\n\t\treturn 0;\n\tcase __DRI2_RENDERER_VIDEO_MEMORY:\n\t\t/* XXX: return vram_size or vram_limit ? */\n\t\tvalue[0] = screen->device->vram_size >> 20;\n\t\treturn 0;\n\tcase __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE:\n\t\tvalue[0] = 0;\n\t\treturn 0;\n\tdefault:\n\t\treturn driQueryRendererIntegerCommon(psp, param, value);\n\t}\n}\n\nstatic int\nnouveau_query_renderer_string(__DRIscreen *psp, int param, const char **value)\n{\n\tconst struct nouveau_screen *const screen =\n\t\t(struct nouveau_screen *) psp->driverPrivate;\n\n\tswitch (param) {\n\tcase __DRI2_RENDERER_VENDOR_ID:\n\t\tvalue[0] = nouveau_vendor_string;\n\t\treturn 0;\n\tcase __DRI2_RENDERER_DEVICE_ID:\n\t\tvalue[0] = nouveau_get_renderer_string(screen->device->chipset);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n   }\n}\n\nstatic const __DRI2rendererQueryExtension nouveau_renderer_query_extension = {\n\t.base = { __DRI2_RENDERER_QUERY, 1 },\n\n\t.queryInteger        = nouveau_query_renderer_integer,\n\t.queryString         = nouveau_query_renderer_string\n};\n\nstatic void\nnouveau_destroy_screen(__DRIscreen *dri_screen)\n{\n\tstruct nouveau_screen *screen = dri_screen->driverPrivate;\n\n\tif (!screen)\n\t\treturn;\n\n\tnouveau_device_del(&screen->device);\n\tnouveau_drm_del(&screen->drm);\n\n\tfree(screen);\n\tdri_screen->driverPrivate = NULL;\n}\n\nstatic GLboolean\nnouveau_create_buffer(__DRIscreen *dri_screen,\n\t\t      __DRIdrawable *drawable,\n\t\t      const struct gl_config *visual,\n\t\t      GLboolean is_pixmap)\n{\n\tstruct gl_renderbuffer *rb;\n\tstruct gl_framebuffer *fb;\n\tGLenum color_format;\n\n\tif (is_pixmap)\n\t\treturn GL_FALSE; /* not implemented */\n\n\tif (visual->redBits == 5)\n\t\tcolor_format = GL_RGB5;\n\telse if (visual->alphaBits == 0)\n\t\tcolor_format = GL_RGB8;\n\telse\n\t\tcolor_format = GL_RGBA8;\n\n\tfb = nouveau_framebuffer_dri_new(visual);\n\tif (!fb)\n\t\treturn GL_FALSE;\n\n\t/* Front buffer. */\n\trb = nouveau_renderbuffer_dri_new(color_format, drawable);\n\t_mesa_attach_and_own_rb(fb, BUFFER_FRONT_LEFT, rb);\n\n\t/* Back buffer */\n\tif (visual->doubleBufferMode) {\n\t\trb = nouveau_renderbuffer_dri_new(color_format, drawable);\n\t\t_mesa_attach_and_own_rb(fb, BUFFER_BACK_LEFT, rb);\n\t}\n\n\t/* Depth/stencil buffer. */\n\tif (visual->depthBits == 24 && visual->stencilBits == 8) {\n\t\trb = nouveau_renderbuffer_dri_new(GL_DEPTH24_STENCIL8_EXT, drawable);\n\t\t_mesa_attach_and_own_rb(fb, BUFFER_DEPTH, rb);\n\t\t_mesa_attach_and_reference_rb(fb, BUFFER_STENCIL, rb);\n\n\t} else if (visual->depthBits == 24) {\n\t\trb = nouveau_renderbuffer_dri_new(GL_DEPTH_COMPONENT24, drawable);\n\t\t_mesa_attach_and_own_rb(fb, BUFFER_DEPTH, rb);\n\n\t} else if (visual->depthBits == 16) {\n\t\trb = nouveau_renderbuffer_dri_new(GL_DEPTH_COMPONENT16, drawable);\n\t\t_mesa_attach_and_own_rb(fb, BUFFER_DEPTH, rb);\n\t}\n\n\t/* Software renderbuffers. */\n\t_swrast_add_soft_renderbuffers(fb, GL_FALSE, GL_FALSE, GL_FALSE,\n                                       visual->accumRedBits > 0,\n                                       GL_FALSE, GL_FALSE);\n\n\tdrawable->driverPrivate = fb;\n\n\treturn GL_TRUE;\n}\n\nstatic void\nnouveau_destroy_buffer(__DRIdrawable *drawable)\n{\n\t_mesa_reference_framebuffer(\n\t\t(struct gl_framebuffer **)&drawable->driverPrivate, NULL);\n}\n\nstatic void\nnouveau_drawable_flush(__DRIdrawable *draw)\n{\n}\n\nstatic const struct __DRI2flushExtensionRec nouveau_flush_extension = {\n   .base = { __DRI2_FLUSH, 3 },\n\n   .flush               = nouveau_drawable_flush,\n   .invalidate          = dri2InvalidateDrawable,\n};\n\nstatic const struct __DRItexBufferExtensionRec nouveau_texbuffer_extension = {\n   .base = { __DRI_TEX_BUFFER, 3 },\n\n   .setTexBuffer        = NULL,\n   .setTexBuffer2       = nouveau_set_texbuffer,\n   .releaseTexBuffer    = NULL,\n};\n\nstatic const __DRIextension *nouveau_screen_extensions[] = {\n    &nouveau_flush_extension.base,\n    &nouveau_texbuffer_extension.base,\n    &nouveau_renderer_query_extension.base,\n    &dri2ConfigQueryExtension.base,\n    &dri2NoErrorExtension.base,\n    NULL\n};\n\nconst struct __DriverAPIRec nouveau_driver_api = {\n\t.InitScreen      = nouveau_init_screen2,\n\t.DestroyScreen   = nouveau_destroy_screen,\n\t.CreateBuffer    = nouveau_create_buffer,\n\t.DestroyBuffer   = nouveau_destroy_buffer,\n\t.CreateContext   = nouveau_context_create,\n\t.DestroyContext  = nouveau_context_destroy,\n\t.MakeCurrent     = nouveau_context_make_current,\n\t.UnbindContext   = nouveau_context_unbind,\n};\n\nstatic const struct __DRIDriverVtableExtensionRec nouveau_vtable = {\n   .base = { __DRI_DRIVER_VTABLE, 1 },\n   .vtable = &nouveau_driver_api,\n};\n\n/* This is the table of extensions that the loader will dlsym() for. */\nstatic const __DRIextension *nouveau_driver_extensions[] = {\n\t&driCoreExtension.base,\n\t&driDRI2Extension.base,\n\t&nouveau_vtable.base,\n\tNULL\n};\n\nPUBLIC const __DRIextension **__driDriverGetExtensions_nouveau_vieux(void)\n{\n   globalDriverAPI = &nouveau_driver_api;\n\n   return nouveau_driver_extensions;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/mapi/glapi/gen/gl_gentable.py": "\n# (C) Copyright IBM Corporation 2004, 2005\n# (C) Copyright Apple Inc. 2011\n# Copyright (C) 2015 Intel Corporation\n# All Rights Reserved.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a\n# copy of this software and associated documentation files (the \"Software\"),\n# to deal in the Software without restriction, including without limitation\n# on the rights to use, copy, modify, merge, publish, distribute, sub\n# license, and/or sell copies of the Software, and to permit persons to whom\n# the Software is furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice (including the next\n# paragraph) shall be included in all copies or substantial portions of the\n# Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL\n# IBM AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n# IN THE SOFTWARE.\n#\n# Authors:\n#    Jeremy Huddleston <jeremyhu@apple.com>\n#\n# Based on code ogiginally by:\n#    Ian Romanick <idr@us.ibm.com>\n\nfrom __future__ import print_function\n\nimport argparse\n\nimport license\nimport gl_XML, glX_XML\n\nheader = \"\"\"/* GLXEXT is the define used in the xserver when the GLX extension is being\n * built.  Hijack this to determine whether this file is being built for the\n * server or the client.\n */\n#ifdef HAVE_DIX_CONFIG_H\n#include <dix-config.h>\n#endif\n\n#if (defined(GLXEXT) && defined(HAVE_BACKTRACE)) \\\\\n\t|| (!defined(GLXEXT) && defined(DEBUG) && defined(HAVE_EXECINFO_H))\n#define USE_BACKTRACE\n#endif\n\n#ifdef USE_BACKTRACE\n#include <execinfo.h>\n#endif\n\n#ifndef _WIN32\n#include <dlfcn.h>\n#endif\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"main/glheader.h\"\n\n#include \"glapi.h\"\n#include \"glapitable.h\"\n\n#ifdef GLXEXT\n#include \"os.h\"\n#endif\n\nstatic void\n__glapi_gentable_NoOp(void) {\n    const char *fstr = \"Unknown\";\n\n    /* Silence potential GCC warning for some #ifdef paths.\n     */\n    (void) fstr;\n#if defined(USE_BACKTRACE)\n#if !defined(GLXEXT)\n    if (getenv(\"MESA_DEBUG\") || getenv(\"LIBGL_DEBUG\"))\n#endif\n    {\n        void *frames[2];\n\n        if(backtrace(frames, 2) == 2) {\n            Dl_info info;\n            dladdr(frames[1], &info);\n            if(info.dli_sname)\n                fstr = info.dli_sname;\n        }\n\n#if !defined(GLXEXT)\n        fprintf(stderr, \"Call to unimplemented API: %s\\\\n\", fstr);\n#endif\n    }\n#endif\n#if defined(GLXEXT)\n    LogMessage(X_ERROR, \"GLX: Call to unimplemented API: %s\\\\n\", fstr);\n#endif\n}\n\nstatic void\n__glapi_gentable_set_remaining_noop(struct _glapi_table *disp) {\n    GLuint entries = _glapi_get_dispatch_table_size();\n    void **dispatch = (void **) disp;\n    unsigned i;\n\n    /* ISO C is annoying sometimes */\n    union {_glapi_proc p; void *v;} p;\n    p.p = __glapi_gentable_NoOp;\n\n    for(i=0; i < entries; i++)\n        if(dispatch[i] == NULL)\n            dispatch[i] = p.v;\n}\n\n\"\"\"\n\nfooter = \"\"\"\nstruct _glapi_table *\n_glapi_create_table_from_handle(void *handle, const char *symbol_prefix) {\n    struct _glapi_table *disp = calloc(_glapi_get_dispatch_table_size(), sizeof(_glapi_proc));\n    char symboln[512];\n\n    if(!disp)\n        return NULL;\n\n    if(symbol_prefix == NULL)\n        symbol_prefix = \"\";\n\n    /* Note: This code relies on _glapi_table_func_names being sorted by the\n     * entry point index of each function.\n     */\n    for (int func_index = 0; func_index < GLAPI_TABLE_COUNT; ++func_index) {\n        const char *name = _glapi_table_func_names[func_index];\n        void ** procp = &((void **)disp)[func_index];\n\n        snprintf(symboln, sizeof(symboln), \\\"%s%s\\\", symbol_prefix, name);\n#ifdef _WIN32\n        *procp = GetProcAddress(handle, symboln);\n#else\n        *procp = dlsym(handle, symboln);\n#endif\n    }\n    __glapi_gentable_set_remaining_noop(disp);\n\n    return disp;\n}\n\nvoid\n _glapi_table_patch(struct _glapi_table *table, const char *name, void *wrapper)\n{\n   for (int func_index = 0; func_index < GLAPI_TABLE_COUNT; ++func_index) {\n      if (!strcmp(_glapi_table_func_names[func_index], name)) {\n            ((void **)table)[func_index] = wrapper;\n            return;\n         }\n   }\n   fprintf(stderr, \"could not patch %s in dispatch table\\\\n\", name);\n}\n\n\"\"\"\n\n\nclass PrintCode(gl_XML.gl_print_base):\n\n    def __init__(self):\n        gl_XML.gl_print_base.__init__(self)\n\n        self.name = \"gl_gentable.py (from Mesa)\"\n        self.license = license.bsd_license_template % ( \\\n\"\"\"Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.\n(C) Copyright IBM Corporation 2004, 2005\n(C) Copyright Apple Inc 2011\"\"\", \"BRIAN PAUL, IBM\")\n\n        return\n\n\n    def get_stack_size(self, f):\n        size = 0\n        for p in f.parameterIterator():\n            if p.is_padding:\n                continue\n\n            size += p.get_stack_size()\n\n        return size\n\n\n    def printRealHeader(self):\n        print(header)\n        return\n\n\n    def printRealFooter(self):\n        print(footer)\n        return\n\n\n    def printBody(self, api):\n\n        # Determine how many functions have a defined offset.\n        func_count = 0\n        for f in api.functions_by_name.values():\n            if f.offset != -1:\n                func_count += 1\n\n        # Build the mapping from offset to function name.\n        funcnames = [None] * func_count\n        for f in api.functions_by_name.values():\n            if f.offset != -1:\n                if not (funcnames[f.offset] is None):\n                    raise Exception(\"Function table has more than one function with same offset (offset %d, func %s)\" % (f.offset, f.name))\n                funcnames[f.offset] = f.name\n\n        # Check that the table has no gaps.  We expect a function at every offset,\n        # and the code which generates the table relies on this.\n        for i in range(0, func_count):\n            if funcnames[i] is None:\n                raise Exception(\"Function table has no function at offset %d\" % (i))\n\n        print(\"#define GLAPI_TABLE_COUNT %d\" % func_count)\n        print(\"static const char * const _glapi_table_func_names[GLAPI_TABLE_COUNT] = {\")\n        for i in range(0, func_count):\n            print(\"    /* %5d */ \\\"%s\\\",\" % (i, funcnames[i]))\n        print(\"};\")\n\n        return\n\n\ndef _parser():\n    \"\"\"Parse arguments and return a namespace object.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-f',\n                        dest='filename',\n                        default='gl_API.xml',\n                        help='An XML file description of an API')\n\n    return parser.parse_args()\n\n\ndef main():\n    \"\"\"Main function.\"\"\"\n    args = _parser()\n\n    printer = PrintCode()\n\n    api = gl_XML.parse_GL_API(args.filename, glX_XML.glx_item_factory())\n    printer.Print(api)\n\n\nif __name__ == '__main__':\n    main()\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/intel/tools/intel_dump_gpu.c": "/*\n * Copyright \u00a9 2015 Intel Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/sysmacros.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include \"drm-uapi/i915_drm.h\"\n#include <inttypes.h>\n\n#include \"intel_aub.h\"\n#include \"aub_write.h\"\n\n#include \"dev/gen_debug.h\"\n#include \"dev/gen_device_info.h\"\n#include \"util/macros.h\"\n\nstatic int close_init_helper(int fd);\nstatic int ioctl_init_helper(int fd, unsigned long request, ...);\nstatic int munmap_init_helper(void *addr, size_t length);\n\nstatic int (*libc_close)(int fd) = close_init_helper;\nstatic int (*libc_ioctl)(int fd, unsigned long request, ...) = ioctl_init_helper;\nstatic int (*libc_munmap)(void *addr, size_t length) = munmap_init_helper;\n\nstatic int drm_fd = -1;\nstatic char *output_filename = NULL;\nstatic FILE *output_file = NULL;\nstatic int verbose = 0;\nstatic bool device_override = false;\nstatic bool capture_only = false;\nstatic int64_t frame_id = -1;\nstatic bool capture_finished = false;\n\n#define MAX_FD_COUNT 64\n#define MAX_BO_COUNT 64 * 1024\n\nstruct bo {\n   uint32_t size;\n   uint64_t offset;\n   void *map;\n   /* Whether the buffer has been positionned in the GTT already. */\n   bool gtt_mapped : 1;\n   /* Tracks userspace mmapping of the buffer */\n   bool user_mapped : 1;\n   /* Using the i915-gem mmapping ioctl & execbuffer ioctl, track whether a\n    * buffer has been updated.\n    */\n   bool dirty : 1;\n};\n\nstatic struct bo *bos;\n\n#define DRM_MAJOR 226\n\n/* We set bit 0 in the map pointer for userptr BOs so we know not to\n * munmap them on DRM_IOCTL_GEM_CLOSE.\n */\n#define USERPTR_FLAG 1\n#define IS_USERPTR(p) ((uintptr_t) (p) & USERPTR_FLAG)\n#define GET_PTR(p) ( (void *) ((uintptr_t) p & ~(uintptr_t) 1) )\n\n#define fail_if(cond, ...) _fail_if(cond, \"intel_dump_gpu\", __VA_ARGS__)\n\nstatic struct bo *\nget_bo(unsigned fd, uint32_t handle)\n{\n   struct bo *bo;\n\n   fail_if(handle >= MAX_BO_COUNT, \"bo handle too large\\n\");\n   fail_if(fd >= MAX_FD_COUNT, \"bo fd too large\\n\");\n   bo = &bos[handle + fd * MAX_BO_COUNT];\n\n   return bo;\n}\n\nstatic inline uint32_t\nalign_u32(uint32_t v, uint32_t a)\n{\n   return (v + a - 1) & ~(a - 1);\n}\n\nstatic struct gen_device_info devinfo = {0};\nstatic int device = 0;\nstatic struct aub_file aub_file;\n\nstatic void\nensure_device_info(int fd)\n{\n   /* We can't do this at open time as we're not yet authenticated. */\n   if (device == 0) {\n      fail_if(!gen_get_device_info_from_fd(fd, &devinfo),\n              \"failed to identify chipset.\\n\");\n      device = devinfo.chipset_id;\n   } else if (devinfo.gen == 0) {\n      fail_if(!gen_get_device_info_from_pci_id(device, &devinfo),\n              \"failed to identify chipset.\\n\");\n   }\n}\n\nstatic void *\nrelocate_bo(int fd, struct bo *bo, const struct drm_i915_gem_execbuffer2 *execbuffer2,\n            const struct drm_i915_gem_exec_object2 *obj)\n{\n   const struct drm_i915_gem_exec_object2 *exec_objects =\n      (struct drm_i915_gem_exec_object2 *) (uintptr_t) execbuffer2->buffers_ptr;\n   const struct drm_i915_gem_relocation_entry *relocs =\n      (const struct drm_i915_gem_relocation_entry *) (uintptr_t) obj->relocs_ptr;\n   void *relocated;\n   int handle;\n\n   relocated = malloc(bo->size);\n   fail_if(relocated == NULL, \"out of memory\\n\");\n   memcpy(relocated, GET_PTR(bo->map), bo->size);\n   for (size_t i = 0; i < obj->relocation_count; i++) {\n      fail_if(relocs[i].offset >= bo->size, \"reloc outside bo\\n\");\n\n      if (execbuffer2->flags & I915_EXEC_HANDLE_LUT)\n         handle = exec_objects[relocs[i].target_handle].handle;\n      else\n         handle = relocs[i].target_handle;\n\n      aub_write_reloc(&devinfo, ((char *)relocated) + relocs[i].offset,\n                      get_bo(fd, handle)->offset + relocs[i].delta);\n   }\n\n   return relocated;\n}\n\nstatic int\ngem_ioctl(int fd, unsigned long request, void *argp)\n{\n   int ret;\n\n   do {\n      ret = libc_ioctl(fd, request, argp);\n   } while (ret == -1 && (errno == EINTR || errno == EAGAIN));\n\n   return ret;\n}\n\nstatic void *\ngem_mmap(int fd, uint32_t handle, uint64_t offset, uint64_t size)\n{\n   struct drm_i915_gem_mmap mmap = {\n      .handle = handle,\n      .offset = offset,\n      .size = size\n   };\n\n   if (gem_ioctl(fd, DRM_IOCTL_I915_GEM_MMAP, &mmap) == -1)\n      return MAP_FAILED;\n\n   return (void *)(uintptr_t) mmap.addr_ptr;\n}\n\nstatic enum drm_i915_gem_engine_class\nengine_class_from_ring_flag(uint32_t ring_flag)\n{\n   switch (ring_flag) {\n   case I915_EXEC_DEFAULT:\n   case I915_EXEC_RENDER:\n      return I915_ENGINE_CLASS_RENDER;\n   case I915_EXEC_BSD:\n      return I915_ENGINE_CLASS_VIDEO;\n   case I915_EXEC_BLT:\n      return I915_ENGINE_CLASS_COPY;\n   case I915_EXEC_VEBOX:\n      return I915_ENGINE_CLASS_VIDEO_ENHANCE;\n   default:\n      return I915_ENGINE_CLASS_INVALID;\n   }\n}\n\nstatic void\ndump_execbuffer2(int fd, struct drm_i915_gem_execbuffer2 *execbuffer2)\n{\n   struct drm_i915_gem_exec_object2 *exec_objects =\n      (struct drm_i915_gem_exec_object2 *) (uintptr_t) execbuffer2->buffers_ptr;\n   uint32_t ring_flag = execbuffer2->flags & I915_EXEC_RING_MASK;\n   uint32_t offset;\n   struct drm_i915_gem_exec_object2 *obj;\n   struct bo *bo, *batch_bo;\n   int batch_index;\n   void *data;\n\n   ensure_device_info(fd);\n\n   if (capture_finished)\n      return;\n\n   if (!aub_file.file) {\n      aub_file_init(&aub_file, output_file,\n                    verbose == 2 ? stdout : NULL,\n                    device, program_invocation_short_name);\n      aub_write_default_setup(&aub_file);\n\n      if (verbose)\n         printf(\"[running, output file %s, chipset id 0x%04x, gen %d]\\n\",\n                output_filename, device, devinfo.gen);\n   }\n\n   if (aub_use_execlists(&aub_file))\n      offset = 0x1000;\n   else\n      offset = aub_gtt_size(&aub_file);\n\n   for (uint32_t i = 0; i < execbuffer2->buffer_count; i++) {\n      obj = &exec_objects[i];\n      bo = get_bo(fd, obj->handle);\n\n      /* If bo->size == 0, this means they passed us an invalid\n       * buffer.  The kernel will reject it and so should we.\n       */\n      if (bo->size == 0) {\n         if (verbose)\n            printf(\"BO #%d is invalid!\\n\", obj->handle);\n         return;\n      }\n\n      if (obj->flags & EXEC_OBJECT_PINNED) {\n         if (bo->offset != obj->offset)\n            bo->gtt_mapped = false;\n         bo->offset = obj->offset;\n      } else {\n         if (obj->alignment != 0)\n            offset = align_u32(offset, obj->alignment);\n         bo->offset = offset;\n         offset = align_u32(offset + bo->size + 4095, 4096);\n      }\n\n      if (bo->map == NULL && bo->size > 0)\n         bo->map = gem_mmap(fd, obj->handle, 0, bo->size);\n      fail_if(bo->map == MAP_FAILED, \"bo mmap failed\\n\");\n   }\n\n   uint64_t current_frame_id = 0;\n   if (frame_id >= 0) {\n      for (uint32_t i = 0; i < execbuffer2->buffer_count; i++) {\n         obj = &exec_objects[i];\n         bo = get_bo(fd, obj->handle);\n\n         /* Check against frame_id requirements. */\n         if (memcmp(bo->map, intel_debug_identifier(),\n                    intel_debug_identifier_size()) == 0) {\n            const struct gen_debug_block_frame *frame_desc =\n               intel_debug_get_identifier_block(bo->map, bo->size,\n                                                GEN_DEBUG_BLOCK_TYPE_FRAME);\n\n            current_frame_id = frame_desc ? frame_desc->frame_id : 0;\n            break;\n         }\n      }\n   }\n\n   if (verbose)\n      printf(\"Dumping execbuffer2 (frame_id=%\"PRIu64\", buffers=%u):\\n\",\n             current_frame_id, execbuffer2->buffer_count);\n\n   /* Check whether we can stop right now. */\n   if (frame_id >= 0) {\n      if (current_frame_id < frame_id)\n         return;\n\n      if (current_frame_id > frame_id) {\n         aub_file_finish(&aub_file);\n         capture_finished = true;\n         return;\n      }\n   }\n\n\n   /* Map buffers into the PPGTT. */\n   for (uint32_t i = 0; i < execbuffer2->buffer_count; i++) {\n      obj = &exec_objects[i];\n      bo = get_bo(fd, obj->handle);\n\n      if (verbose) {\n         printf(\"BO #%d (%dB) @ 0x%\" PRIx64 \"\\n\",\n                obj->handle, bo->size, bo->offset);\n      }\n\n      if (aub_use_execlists(&aub_file) && !bo->gtt_mapped) {\n         aub_map_ppgtt(&aub_file, bo->offset, bo->size);\n         bo->gtt_mapped = true;\n      }\n   }\n\n   /* Write the buffer content into the Aub. */\n   batch_index = (execbuffer2->flags & I915_EXEC_BATCH_FIRST) ? 0 :\n      execbuffer2->buffer_count - 1;\n   batch_bo = get_bo(fd, exec_objects[batch_index].handle);\n   for (uint32_t i = 0; i < execbuffer2->buffer_count; i++) {\n      obj = &exec_objects[i];\n      bo = get_bo(fd, obj->handle);\n\n      if (obj->relocation_count > 0)\n         data = relocate_bo(fd, bo, execbuffer2, obj);\n      else\n         data = bo->map;\n\n      bool write = !capture_only || (obj->flags & EXEC_OBJECT_CAPTURE);\n\n      if (write && bo->dirty) {\n         if (bo == batch_bo) {\n            aub_write_trace_block(&aub_file, AUB_TRACE_TYPE_BATCH,\n                                  GET_PTR(data), bo->size, bo->offset);\n         } else {\n            aub_write_trace_block(&aub_file, AUB_TRACE_TYPE_NOTYPE,\n                                  GET_PTR(data), bo->size, bo->offset);\n         }\n\n         if (!bo->user_mapped)\n            bo->dirty = false;\n      }\n\n      if (data != bo->map)\n         free(data);\n   }\n\n   uint32_t ctx_id = execbuffer2->rsvd1;\n\n   aub_write_exec(&aub_file, ctx_id,\n                  batch_bo->offset + execbuffer2->batch_start_offset,\n                  offset, engine_class_from_ring_flag(ring_flag));\n\n   if (device_override &&\n       (execbuffer2->flags & I915_EXEC_FENCE_ARRAY) != 0) {\n      struct drm_i915_gem_exec_fence *fences =\n         (void*)(uintptr_t)execbuffer2->cliprects_ptr;\n      for (uint32_t i = 0; i < execbuffer2->num_cliprects; i++) {\n         if ((fences[i].flags & I915_EXEC_FENCE_SIGNAL) != 0) {\n            struct drm_syncobj_array arg = {\n               .handles = (uintptr_t)&fences[i].handle,\n               .count_handles = 1,\n               .pad = 0,\n            };\n            libc_ioctl(fd, DRM_IOCTL_SYNCOBJ_SIGNAL, &arg);\n         }\n      }\n   }\n}\n\nstatic void\nadd_new_bo(unsigned fd, int handle, uint64_t size, void *map)\n{\n   struct bo *bo = &bos[handle + fd * MAX_BO_COUNT];\n\n   fail_if(handle >= MAX_BO_COUNT, \"bo handle out of range\\n\");\n   fail_if(fd >= MAX_FD_COUNT, \"bo fd out of range\\n\");\n   fail_if(size == 0, \"bo size is invalid\\n\");\n\n   bo->size = size;\n   bo->map = map;\n   bo->user_mapped = false;\n   bo->gtt_mapped = false;\n}\n\nstatic void\nremove_bo(int fd, int handle)\n{\n   struct bo *bo = get_bo(fd, handle);\n\n   if (bo->map && !IS_USERPTR(bo->map))\n      munmap(bo->map, bo->size);\n   memset(bo, 0, sizeof(*bo));\n}\n\n__attribute__ ((visibility (\"default\"))) int\nclose(int fd)\n{\n   if (fd == drm_fd)\n      drm_fd = -1;\n\n   return libc_close(fd);\n}\n\nstatic int\nget_pci_id(int fd, int *pci_id)\n{\n   struct drm_i915_getparam gparam;\n\n   if (device_override) {\n      *pci_id = device;\n      return 0;\n   }\n\n   gparam.param = I915_PARAM_CHIPSET_ID;\n   gparam.value = pci_id;\n   return libc_ioctl(fd, DRM_IOCTL_I915_GETPARAM, &gparam);\n}\n\nstatic void\nmaybe_init(int fd)\n{\n   static bool initialized = false;\n   FILE *config;\n   char *key, *value;\n\n   if (initialized)\n      return;\n\n   initialized = true;\n\n   const char *config_path = getenv(\"INTEL_DUMP_GPU_CONFIG\");\n   fail_if(config_path == NULL, \"INTEL_DUMP_GPU_CONFIG is not set\\n\");\n\n   config = fopen(config_path, \"r\");\n   fail_if(config == NULL, \"failed to open file %s\\n\", config_path);\n\n   while (fscanf(config, \"%m[^=]=%m[^\\n]\\n\", &key, &value) != EOF) {\n      if (!strcmp(key, \"verbose\")) {\n         if (!strcmp(value, \"1\")) {\n            verbose = 1;\n         } else if (!strcmp(value, \"2\")) {\n            verbose = 2;\n         }\n      } else if (!strcmp(key, \"device\")) {\n         fail_if(device != 0, \"Device/Platform override specified multiple times.\\n\");\n         fail_if(sscanf(value, \"%i\", &device) != 1,\n                 \"failed to parse device id '%s'\\n\",\n                 value);\n         device_override = true;\n      } else if (!strcmp(key, \"platform\")) {\n         fail_if(device != 0, \"Device/Platform override specified multiple times.\\n\");\n         device = gen_device_name_to_pci_device_id(value);\n         fail_if(device == -1, \"Unknown platform '%s'\\n\", value);\n         device_override = true;\n      } else if (!strcmp(key, \"file\")) {\n         output_filename = strdup(value);\n         output_file = fopen(output_filename, \"w+\");\n         fail_if(output_file == NULL,\n                 \"failed to open file '%s'\\n\",\n                 output_filename);\n      } else if (!strcmp(key, \"capture_only\")) {\n         capture_only = atoi(value);\n      } else if (!strcmp(key, \"frame\")) {\n         frame_id = atol(value);\n      } else {\n         fprintf(stderr, \"unknown option '%s'\\n\", key);\n      }\n\n      free(key);\n      free(value);\n   }\n   fclose(config);\n\n   bos = calloc(MAX_FD_COUNT * MAX_BO_COUNT, sizeof(bos[0]));\n   fail_if(bos == NULL, \"out of memory\\n\");\n\n   int ret = get_pci_id(fd, &device);\n   assert(ret == 0);\n\n   aub_file_init(&aub_file, output_file,\n                 verbose == 2 ? stdout : NULL,\n                 device, program_invocation_short_name);\n   aub_write_default_setup(&aub_file);\n\n   if (verbose)\n      printf(\"[running, output file %s, chipset id 0x%04x, gen %d]\\n\",\n             output_filename, device, devinfo.gen);\n}\n\n__attribute__ ((visibility (\"default\"))) int\nioctl(int fd, unsigned long request, ...)\n{\n   va_list args;\n   void *argp;\n   int ret;\n   struct stat buf;\n\n   va_start(args, request);\n   argp = va_arg(args, void *);\n   va_end(args);\n\n   if (_IOC_TYPE(request) == DRM_IOCTL_BASE &&\n       drm_fd != fd && fstat(fd, &buf) == 0 &&\n       (buf.st_mode & S_IFMT) == S_IFCHR && major(buf.st_rdev) == DRM_MAJOR) {\n      drm_fd = fd;\n      if (verbose)\n         printf(\"[intercept drm ioctl on fd %d]\\n\", fd);\n   }\n\n   if (fd == drm_fd) {\n      maybe_init(fd);\n\n      switch (request) {\n      case DRM_IOCTL_SYNCOBJ_WAIT:\n      case DRM_IOCTL_I915_GEM_WAIT: {\n         if (device_override)\n            return 0;\n         return libc_ioctl(fd, request, argp);\n      }\n\n      case DRM_IOCTL_I915_GET_RESET_STATS: {\n         if (device_override) {\n            struct drm_i915_reset_stats *stats = argp;\n\n            stats->reset_count = 0;\n            stats->batch_active = 0;\n            stats->batch_pending = 0;\n            return 0;\n         }\n         return libc_ioctl(fd, request, argp);\n      }\n\n      case DRM_IOCTL_I915_GETPARAM: {\n         struct drm_i915_getparam *getparam = argp;\n\n         ensure_device_info(fd);\n\n         if (getparam->param == I915_PARAM_CHIPSET_ID)\n            return get_pci_id(fd, getparam->value);\n\n         if (device_override) {\n            switch (getparam->param) {\n            case I915_PARAM_CS_TIMESTAMP_FREQUENCY:\n               *getparam->value = devinfo.timestamp_frequency;\n               return 0;\n\n            case I915_PARAM_HAS_WAIT_TIMEOUT:\n            case I915_PARAM_HAS_EXECBUF2:\n            case I915_PARAM_MMAP_VERSION:\n            case I915_PARAM_HAS_EXEC_ASYNC:\n            case I915_PARAM_HAS_EXEC_FENCE:\n            case I915_PARAM_HAS_EXEC_FENCE_ARRAY:\n               *getparam->value = 1;\n               return 0;\n\n            case I915_PARAM_HAS_EXEC_SOFTPIN:\n               *getparam->value = devinfo.gen >= 8 && !devinfo.is_cherryview;\n               return 0;\n\n            default:\n               return -1;\n            }\n         }\n\n         return libc_ioctl(fd, request, argp);\n      }\n\n      case DRM_IOCTL_I915_GEM_CONTEXT_GETPARAM: {\n         struct drm_i915_gem_context_param *getparam = argp;\n\n         ensure_device_info(fd);\n\n         if (device_override) {\n            switch (getparam->param) {\n            case I915_CONTEXT_PARAM_GTT_SIZE:\n               if (devinfo.is_elkhartlake)\n                  getparam->value = 1ull << 36;\n               else if (devinfo.gen >= 8 && !devinfo.is_cherryview)\n                  getparam->value = 1ull << 48;\n               else\n                  getparam->value = 1ull << 31;\n               return 0;\n\n            default:\n               return -1;\n            }\n         }\n\n         return libc_ioctl(fd, request, argp);\n      }\n\n      case DRM_IOCTL_I915_GEM_EXECBUFFER: {\n         static bool once;\n         if (!once) {\n            fprintf(stderr,\n                    \"application uses DRM_IOCTL_I915_GEM_EXECBUFFER, not handled\\n\");\n            once = true;\n         }\n         return libc_ioctl(fd, request, argp);\n      }\n\n      case DRM_IOCTL_I915_GEM_EXECBUFFER2:\n      case DRM_IOCTL_I915_GEM_EXECBUFFER2_WR: {\n         dump_execbuffer2(fd, argp);\n         if (device_override)\n            return 0;\n\n         return libc_ioctl(fd, request, argp);\n      }\n\n      case DRM_IOCTL_I915_GEM_CONTEXT_CREATE: {\n         uint32_t *ctx_id = NULL;\n         struct drm_i915_gem_context_create *create = argp;\n         ret = 0;\n         if (!device_override) {\n            ret = libc_ioctl(fd, request, argp);\n            ctx_id = &create->ctx_id;\n         }\n\n         if (ret == 0)\n            create->ctx_id = aub_write_context_create(&aub_file, ctx_id);\n\n         return ret;\n      }\n\n      case DRM_IOCTL_I915_GEM_CONTEXT_CREATE_EXT: {\n         uint32_t *ctx_id = NULL;\n         struct drm_i915_gem_context_create_ext *create = argp;\n         ret = 0;\n         if (!device_override) {\n            ret = libc_ioctl(fd, request, argp);\n            ctx_id = &create->ctx_id;\n         }\n\n         if (ret == 0)\n            create->ctx_id = aub_write_context_create(&aub_file, ctx_id);\n\n         return ret;\n      }\n\n      case DRM_IOCTL_I915_GEM_CREATE: {\n         struct drm_i915_gem_create *create = argp;\n\n         ret = libc_ioctl(fd, request, argp);\n         if (ret == 0)\n            add_new_bo(fd, create->handle, create->size, NULL);\n\n         return ret;\n      }\n\n      case DRM_IOCTL_I915_GEM_USERPTR: {\n         struct drm_i915_gem_userptr *userptr = argp;\n\n         ret = libc_ioctl(fd, request, argp);\n         if (ret == 0)\n            add_new_bo(fd, userptr->handle, userptr->user_size,\n                       (void *) (uintptr_t) (userptr->user_ptr | USERPTR_FLAG));\n\n         return ret;\n      }\n\n      case DRM_IOCTL_GEM_CLOSE: {\n         struct drm_gem_close *close = argp;\n\n         remove_bo(fd, close->handle);\n\n         return libc_ioctl(fd, request, argp);\n      }\n\n      case DRM_IOCTL_GEM_OPEN: {\n         struct drm_gem_open *open = argp;\n\n         ret = libc_ioctl(fd, request, argp);\n         if (ret == 0)\n            add_new_bo(fd, open->handle, open->size, NULL);\n\n         return ret;\n      }\n\n      case DRM_IOCTL_PRIME_FD_TO_HANDLE: {\n         struct drm_prime_handle *prime = argp;\n\n         ret = libc_ioctl(fd, request, argp);\n         if (ret == 0) {\n            off_t size;\n\n            size = lseek(prime->fd, 0, SEEK_END);\n            fail_if(size == -1, \"failed to get prime bo size\\n\");\n            add_new_bo(fd, prime->handle, size, NULL);\n\n         }\n\n         return ret;\n      }\n\n      case DRM_IOCTL_I915_GEM_MMAP: {\n         ret = libc_ioctl(fd, request, argp);\n         if (ret == 0) {\n            struct drm_i915_gem_mmap *mmap = argp;\n            struct bo *bo = get_bo(fd, mmap->handle);\n            bo->user_mapped = true;\n            bo->dirty = true;\n         }\n         return ret;\n      }\n\n      case DRM_IOCTL_I915_GEM_MMAP_OFFSET: {\n         ret = libc_ioctl(fd, request, argp);\n         if (ret == 0) {\n            struct drm_i915_gem_mmap_offset *mmap = argp;\n            struct bo *bo = get_bo(fd, mmap->handle);\n            bo->user_mapped = true;\n            bo->dirty = true;\n         }\n         return ret;\n      }\n\n      default:\n         return libc_ioctl(fd, request, argp);\n      }\n   } else {\n      return libc_ioctl(fd, request, argp);\n   }\n}\n\nstatic void\ninit(void)\n{\n   libc_close = dlsym(RTLD_NEXT, \"close\");\n   libc_ioctl = dlsym(RTLD_NEXT, \"ioctl\");\n   libc_munmap = dlsym(RTLD_NEXT, \"munmap\");\n   fail_if(libc_close == NULL || libc_ioctl == NULL,\n           \"failed to get libc ioctl or close\\n\");\n}\n\nstatic int\nclose_init_helper(int fd)\n{\n   init();\n   return libc_close(fd);\n}\n\nstatic int\nioctl_init_helper(int fd, unsigned long request, ...)\n{\n   va_list args;\n   void *argp;\n\n   va_start(args, request);\n   argp = va_arg(args, void *);\n   va_end(args);\n\n   init();\n   return libc_ioctl(fd, request, argp);\n}\n\nstatic int\nmunmap_init_helper(void *addr, size_t length)\n{\n   init();\n   for (uint32_t i = 0; i < MAX_FD_COUNT * MAX_BO_COUNT; i++) {\n      struct bo *bo = &bos[i];\n      if (bo->map == addr) {\n         bo->user_mapped = false;\n         break;\n      }\n   }\n   return libc_munmap(addr, length);\n}\n\nstatic void __attribute__ ((destructor))\nfini(void)\n{\n   if (devinfo.gen != 0) {\n      free(output_filename);\n      if (!capture_finished)\n         aub_file_finish(&aub_file);\n      free(bos);\n   }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/intel/tools/intel_sanitize_gpu.c": "/*\n * Copyright \u00a9 2015-2018 Intel Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#undef _FILE_OFFSET_BITS /* prevent #define open open64 */\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <sys/sysmacros.h>\n#include <dlfcn.h>\n#include <pthread.h>\n#include \"drm-uapi/i915_drm.h\"\n\n#include \"util/hash_table.h\"\n#include \"util/u_math.h\"\n\n#define MESA_LOG_TAG \"INTEL-SANITIZE-GPU\"\n#include \"util/log.h\"\n#include \"common/gen_clflush.h\"\n\nstatic int (*libc_open)(const char *pathname, int flags, mode_t mode);\nstatic int (*libc_close)(int fd);\nstatic int (*libc_ioctl)(int fd, unsigned long request, void *argp);\nstatic int (*libc_fcntl)(int fd, int cmd, int param);\n\n#define DRM_MAJOR 226\n\n/* TODO: we want to make sure that the padding forces\n * the BO to take another page on the (PP)GTT; 4KB\n * may or may not be the page size for the BO. Indeed,\n * depending on GPU, kernel version and GEM size, the\n * page size can be one of 4KB, 64KB or 2M.\n */\n#define PADDING_SIZE 4096\n\nstruct refcnt_hash_table {\n   struct hash_table *t;\n   int refcnt;\n};\n\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n#define MUTEX_LOCK() do {                        \\\n   if (unlikely(pthread_mutex_lock(&mutex))) {   \\\n      mesa_loge(\"mutex_lock failed\");           \\\n      abort();                                   \\\n   }                                             \\\n} while (0)\n#define MUTEX_UNLOCK() do {                      \\\n   if (unlikely(pthread_mutex_unlock(&mutex))) { \\\n      mesa_loge(\"mutex_unlock failed\");         \\\n      abort();                                   \\\n   }                                             \\\n} while (0)\n\nstatic struct hash_table *fds_to_bo_sizes = NULL;\n\nstatic inline struct hash_table*\nbo_size_table(int fd)\n{\n   struct hash_entry *e = _mesa_hash_table_search(fds_to_bo_sizes,\n                                                  (void*)(uintptr_t)fd);\n   return e ? ((struct refcnt_hash_table*)e->data)->t : NULL;\n}\n\nstatic inline uint64_t\nbo_size(int fd, uint32_t handle)\n{\n   struct hash_table *t = bo_size_table(fd);\n   if (!t)\n      return UINT64_MAX;\n   struct hash_entry *e = _mesa_hash_table_search(t, (void*)(uintptr_t)handle);\n   return e ? (uint64_t)e->data : UINT64_MAX;\n}\n\nstatic inline bool\nis_drm_fd(int fd)\n{\n   return !!bo_size_table(fd);\n}\n\nstatic inline void\nadd_drm_fd(int fd)\n{\n   struct refcnt_hash_table *r = malloc(sizeof(*r));\n   r->refcnt = 1;\n   r->t = _mesa_pointer_hash_table_create(NULL);\n   _mesa_hash_table_insert(fds_to_bo_sizes, (void*)(uintptr_t)fd,\n                           (void*)(uintptr_t)r);\n}\n\nstatic inline void\ndup_drm_fd(int old_fd, int new_fd)\n{\n   struct hash_entry *e = _mesa_hash_table_search(fds_to_bo_sizes,\n                                                  (void*)(uintptr_t)old_fd);\n   struct refcnt_hash_table *r = e->data;\n   r->refcnt++;\n   _mesa_hash_table_insert(fds_to_bo_sizes, (void*)(uintptr_t)new_fd,\n                           (void*)(uintptr_t)r);\n}\n\nstatic inline void\ndel_drm_fd(int fd)\n{\n   struct hash_entry *e = _mesa_hash_table_search(fds_to_bo_sizes,\n                                                  (void*)(uintptr_t)fd);\n   struct refcnt_hash_table *r = e->data;\n   if (!--r->refcnt) {\n      _mesa_hash_table_remove(fds_to_bo_sizes, e);\n      _mesa_hash_table_destroy(r->t, NULL);\n      free(r);\n   }\n}\n\n/* Our goal is not to have noise good enough for cryto,\n * but instead values that are unique-ish enough that\n * it is incredibly unlikely that a buffer overwrite\n * will produce the exact same values.\n */\nstatic uint8_t\nnext_noise_value(uint8_t prev_noise)\n{\n   uint32_t v = prev_noise;\n   return (v * 103u + 227u) & 0xFF;\n}\n\nstatic void\nfill_noise_buffer(uint8_t *dst, uint8_t start, uint32_t length)\n{\n   for(uint32_t i = 0; i < length; ++i) {\n      dst[i] = start;\n      start = next_noise_value(start);\n   }\n}\n\nstatic bool\npadding_is_good(int fd, uint32_t handle)\n{\n   struct drm_i915_gem_mmap mmap_arg = {\n      .handle = handle,\n      .offset = align64(bo_size(fd, handle), 4096),\n      .size = PADDING_SIZE,\n      .flags = 0,\n   };\n\n   /* Unknown bo, maybe prime or userptr. Ignore */\n   if (mmap_arg.offset == UINT64_MAX)\n      return true;\n\n   uint8_t *mapped;\n   int ret;\n   uint8_t expected_value;\n\n   ret = libc_ioctl(fd, DRM_IOCTL_I915_GEM_MMAP, &mmap_arg);\n   if (ret != 0) {\n      mesa_logd(\"Unable to map buffer %d for pad checking.\", handle);\n      return false;\n   }\n\n   mapped = (uint8_t*) (uintptr_t) mmap_arg.addr_ptr;\n   /* bah-humbug, we need to see the latest contents and\n    * if the bo is not cache coherent we likely need to\n    * invalidate the cache lines to get it.\n    */\n   gen_invalidate_range(mapped, PADDING_SIZE);\n\n   expected_value = handle & 0xFF;\n   for (uint32_t i = 0; i < PADDING_SIZE; ++i) {\n      if (expected_value != mapped[i]) {\n         munmap(mapped, PADDING_SIZE);\n         return false;\n      }\n      expected_value = next_noise_value(expected_value);\n   }\n   munmap(mapped, PADDING_SIZE);\n\n   return true;\n}\n\nstatic int\ncreate_with_padding(int fd, struct drm_i915_gem_create *create)\n{\n   uint64_t original_size = create->size;\n\n   create->size = align64(original_size, 4096) + PADDING_SIZE;\n   int ret = libc_ioctl(fd, DRM_IOCTL_I915_GEM_CREATE, create);\n   create->size = original_size;\n\n   if (ret != 0)\n      return ret;\n\n   uint8_t *noise_values;\n   struct drm_i915_gem_mmap mmap_arg = {\n      .handle = create->handle,\n      .offset = align64(create->size, 4096),\n      .size = PADDING_SIZE,\n      .flags = 0,\n   };\n\n   ret = libc_ioctl(fd, DRM_IOCTL_I915_GEM_MMAP, &mmap_arg);\n   if (ret != 0) {\n      mesa_logd(\"Unable to map buffer %d for pad creation.\\n\", create->handle);\n      return 0;\n   }\n\n   noise_values = (uint8_t*) (uintptr_t) mmap_arg.addr_ptr;\n   fill_noise_buffer(noise_values, create->handle & 0xFF,\n                     PADDING_SIZE);\n   munmap(noise_values, PADDING_SIZE);\n\n   _mesa_hash_table_insert(bo_size_table(fd), (void*)(uintptr_t)create->handle,\n                           (void*)(uintptr_t)create->size);\n\n   return 0;\n}\n\nstatic int\nexec_and_check_padding(int fd, unsigned long request,\n                       struct drm_i915_gem_execbuffer2 *exec)\n{\n   int ret = libc_ioctl(fd, request, exec);\n   if (ret != 0)\n      return ret;\n\n   struct drm_i915_gem_exec_object2 *objects =\n      (void*)(uintptr_t)exec->buffers_ptr;\n   uint32_t batch_bo = exec->flags & I915_EXEC_BATCH_FIRST ? objects[0].handle :\n      objects[exec->buffer_count - 1].handle;\n\n   struct drm_i915_gem_wait wait = {\n      .bo_handle = batch_bo,\n      .timeout_ns = -1,\n   };\n   ret = libc_ioctl(fd, DRM_IOCTL_I915_GEM_WAIT, &wait);\n   if (ret != 0)\n      return ret;\n\n   bool detected_out_of_bounds_write = false;\n\n   for (int i = 0; i < exec->buffer_count; i++) {\n      uint32_t handle = objects[i].handle;\n\n      if (!padding_is_good(fd, handle)) {\n         detected_out_of_bounds_write = true;\n         mesa_loge(\"Detected buffer out-of-bounds write in bo %d\", handle);\n      }\n   }\n\n   if (unlikely(detected_out_of_bounds_write)) {\n      abort();\n   }\n\n   return 0;\n}\n\nstatic int\ngem_close(int fd, struct drm_gem_close *close)\n{\n   int ret = libc_ioctl(fd, DRM_IOCTL_GEM_CLOSE, close);\n   if (ret != 0)\n      return ret;\n\n   struct hash_table *t = bo_size_table(fd);\n   struct hash_entry *e =\n      _mesa_hash_table_search(t, (void*)(uintptr_t)close->handle);\n\n   if (e)\n      _mesa_hash_table_remove(t, e);\n\n   return 0;\n}\n\nstatic bool\nis_i915(int fd) {\n   struct stat stat;\n   if (fstat(fd, &stat))\n      return false;\n\n   if (!S_ISCHR(stat.st_mode) || major(stat.st_rdev) != DRM_MAJOR)\n      return false;\n\n   char name[5] = \"\";\n   drm_version_t version = {\n      .name = name,\n      .name_len = sizeof(name) - 1,\n   };\n   if (libc_ioctl(fd, DRM_IOCTL_VERSION, &version))\n      return false;\n\n   return strcmp(\"i915\", name) == 0;\n}\n\n__attribute__ ((visibility (\"default\"))) int\nopen(const char *path, int flags, ...)\n{\n   va_list args;\n   mode_t mode;\n\n   va_start(args, flags);\n   mode = va_arg(args, int);\n   va_end(args);\n\n   int fd = libc_open(path, flags, mode);\n\n   MUTEX_LOCK();\n\n   if (fd >= 0 && is_i915(fd))\n      add_drm_fd(fd);\n\n   MUTEX_UNLOCK();\n\n   return fd;\n}\n\n__attribute__ ((visibility (\"default\"), alias (\"open\"))) int\nopen64(const char *path, int flags, ...);\n\n__attribute__ ((visibility (\"default\"))) int\nclose(int fd)\n{\n   MUTEX_LOCK();\n\n   if (is_drm_fd(fd))\n      del_drm_fd(fd);\n\n   MUTEX_UNLOCK();\n\n   return libc_close(fd);\n}\n\n__attribute__ ((visibility (\"default\"))) int\nfcntl(int fd, int cmd, ...)\n{\n   va_list args;\n   int param;\n\n   va_start(args, cmd);\n   param = va_arg(args, int);\n   va_end(args);\n\n   int res = libc_fcntl(fd, cmd, param);\n\n   MUTEX_LOCK();\n\n   if (is_drm_fd(fd) && cmd == F_DUPFD_CLOEXEC)\n      dup_drm_fd(fd, res);\n\n   MUTEX_UNLOCK();\n\n   return res;\n}\n\n__attribute__ ((visibility (\"default\"))) int\nioctl(int fd, unsigned long request, ...)\n{\n   int res;\n   va_list args;\n   void *argp;\n\n   MUTEX_LOCK();\n\n   va_start(args, request);\n   argp = va_arg(args, void *);\n   va_end(args);\n\n   if (_IOC_TYPE(request) == DRM_IOCTL_BASE && !is_drm_fd(fd) && is_i915(fd)) {\n      mesa_loge(\"missed drm fd %d\", fd);\n      add_drm_fd(fd);\n   }\n\n   if (is_drm_fd(fd)) {\n      switch (request) {\n      case DRM_IOCTL_GEM_CLOSE:\n         res = gem_close(fd, (struct drm_gem_close*)argp);\n         goto out;\n\n      case DRM_IOCTL_I915_GEM_CREATE:\n         res = create_with_padding(fd, (struct drm_i915_gem_create*)argp);\n         goto out;\n\n      case DRM_IOCTL_I915_GEM_EXECBUFFER2:\n      case DRM_IOCTL_I915_GEM_EXECBUFFER2_WR:\n         res = exec_and_check_padding(fd, request,\n                                      (struct drm_i915_gem_execbuffer2*)argp);\n         goto out;\n\n      default:\n         break;\n      }\n   }\n   res = libc_ioctl(fd, request, argp);\n\n out:\n   MUTEX_UNLOCK();\n   return res;\n}\n\nstatic void __attribute__ ((constructor))\ninit(void)\n{\n   fds_to_bo_sizes = _mesa_pointer_hash_table_create(NULL);\n   libc_open = dlsym(RTLD_NEXT, \"open\");\n   libc_close = dlsym(RTLD_NEXT, \"close\");\n   libc_fcntl = dlsym(RTLD_NEXT, \"fcntl\");\n   libc_ioctl = dlsym(RTLD_NEXT, \"ioctl\");\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/glx/applegl_glx.c": "/*\n * Copyright \u00a9 2010 Intel Corporation\n * Copyright \u00a9 2011 Apple Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Soft-\n * ware\"), to deal in the Software without restriction, including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, provided that the above copyright\n * notice(s) and this permission notice appear in all copies of the Soft-\n * ware and that both the above copyright notice(s) and this permission\n * notice appear in supporting documentation.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-\n * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY\n * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN\n * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-\n * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-\n * MANCE OF THIS SOFTWARE.\n *\n * Except as contained in this notice, the name of a copyright holder shall\n * not be used in advertising or otherwise to promote the sale, use or\n * other dealings in this Software without prior written authorization of\n * the copyright holder.\n *\n * Authors:\n *   Kristian H\u00f8gsberg (krh@bitplanet.net)\n */\n\n#if defined(GLX_USE_APPLEGL)\n\n#include <stdbool.h>\n#include <dlfcn.h>\n\n#include \"glxclient.h\"\n#include \"apple/apple_glx_context.h\"\n#include \"apple/apple_glx.h\"\n#include \"apple/apple_cgl.h\"\n#include \"glx_error.h\"\n\nstatic void\napplegl_destroy_context(struct glx_context *gc)\n{\n   apple_glx_destroy_context(&gc->driContext, gc->psc->dpy);\n}\n\nstatic int\napplegl_bind_context(struct glx_context *gc, struct glx_context *old,\n\t\t     GLXDrawable draw, GLXDrawable read)\n{\n   Display *dpy = gc->psc->dpy;\n   bool error = apple_glx_make_current_context(dpy,\n\t\t\t\t\t       (old && old != &dummyContext) ? old->driContext : NULL,\n\t\t\t\t\t       gc ? gc->driContext : NULL, draw);\n\n   apple_glx_diagnostic(\"%s: error %s\\n\", __func__, error ? \"YES\" : \"NO\");\n   if (error)\n      return 1; /* GLXBadContext is the same as Success (0) */\n\n   apple_glapi_set_dispatch();\n\n   return Success;\n}\n\nstatic void\napplegl_unbind_context(struct glx_context *gc, struct glx_context *new)\n{\n   Display *dpy;\n   bool error;\n\n   /* If we don't have a context, then we have nothing to unbind */\n   if (!gc)\n      return;\n\n   /* If we have a new context, keep this one around and remove it during bind. */\n   if (new)\n      return;\n\n   dpy = gc->psc->dpy;\n\n   error = apple_glx_make_current_context(dpy,\n\t\t\t\t\t  (gc != &dummyContext) ? gc->driContext : NULL,\n\t\t\t\t\t  NULL, None);\n\n   apple_glx_diagnostic(\"%s: error %s\\n\", __func__, error ? \"YES\" : \"NO\");\n}\n\nstatic void\napplegl_wait_gl(struct glx_context *gc)\n{\n   glFinish();\n}\n\nstatic void\napplegl_wait_x(struct glx_context *gc)\n{\n   Display *dpy = gc->psc->dpy;\n   apple_glx_waitx(dpy, gc->driContext);\n}\n\nstatic void *\napplegl_get_proc_address(const char *symbol)\n{\n   return dlsym(apple_cgl_get_dl_handle(), symbol);\n}\n\nstatic const struct glx_context_vtable applegl_context_vtable = {\n   .destroy             = applegl_destroy_context,\n   .bind                = applegl_bind_context,\n   .unbind              = applegl_unbind_context,\n   .wait_gl             = applegl_wait_gl,\n   .wait_x              = applegl_wait_x,\n   .use_x_font          = DRI_glXUseXFont,\n   .bind_tex_image      = NULL,\n   .release_tex_image   = NULL,\n   .get_proc_address    = applegl_get_proc_address,\n};\n\nstruct glx_context *\napplegl_create_context(struct glx_screen *psc,\n\t\t       struct glx_config *config,\n\t\t       struct glx_context *shareList, int renderType)\n{\n   struct glx_context *gc;\n   int errorcode;\n   bool x11error;\n   Display *dpy = psc->dpy;\n   int screen = psc->scr;\n\n   /* TODO: Integrate this with apple_glx_create_context and make\n    * struct apple_glx_context inherit from struct glx_context. */\n\n   gc = calloc(1, sizeof(*gc));\n   if (gc == NULL)\n      return NULL;\n\n   if (!glx_context_init(gc, psc, config)) {\n      free(gc);\n      return NULL;\n   }\n\n   gc->vtable = &applegl_context_vtable;\n   gc->driContext = NULL;\n\n   /* TODO: darwin: Integrate with above to do indirect */\n   if(apple_glx_create_context(&gc->driContext, dpy, screen, config, \n\t\t\t       shareList ? shareList->driContext : NULL,\n\t\t\t       &errorcode, &x11error)) {\n      __glXSendError(dpy, errorcode, 0, X_GLXCreateContext, x11error);\n      gc->vtable->destroy(gc);\n      return NULL;\n   }\n\n   gc->currentContextTag = -1;\n   gc->config = config;\n   gc->isDirect = GL_TRUE;\n   gc->xid = 1; /* Just something not None, so we know when to destroy\n\t\t * it in MakeContextCurrent. */\n\n   return gc;\n}\n\nstatic const struct glx_screen_vtable applegl_screen_vtable = {\n   .create_context         = applegl_create_context,\n   .create_context_attribs = NULL,\n   .query_renderer_integer = NULL,\n   .query_renderer_string  = NULL,\n};\n\n_X_HIDDEN struct glx_screen *\napplegl_create_screen(int screen, struct glx_display * priv)\n{\n   struct glx_screen *psc;\n\n   psc = calloc(1, sizeof *psc);\n   if (psc == NULL)\n      return NULL;\n\n   glx_screen_init(psc, screen, priv);\n   psc->vtable = &applegl_screen_vtable;\n\n   return psc;\n}\n\n_X_HIDDEN int\napplegl_create_display(struct glx_display *glx_dpy)\n{\n   if(!apple_init_glx(glx_dpy->dpy))\n      return 1;\n\n   return GLXBadContext;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/glx/dri_common.c": "/*\n * Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.\n * Copyright \u00a9 2008 Red Hat, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Soft-\n * ware\"), to deal in the Software without restriction, including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, provided that the above copyright\n * notice(s) and this permission notice appear in all copies of the Soft-\n * ware and that both the above copyright notice(s) and this permission\n * notice appear in supporting documentation.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-\n * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY\n * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN\n * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-\n * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-\n * MANCE OF THIS SOFTWARE.\n *\n * Except as contained in this notice, the name of a copyright holder shall\n * not be used in advertising or otherwise to promote the sale, use or\n * other dealings in this Software without prior written authorization of\n * the copyright holder.\n *\n * Authors:\n *   Kevin E. Martin <kevin@precisioninsight.com>\n *   Brian Paul <brian@precisioninsight.com>\n *   Kristian H\u00f8gsberg (krh@redhat.com)\n */\n\n#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)\n\n#include <unistd.h>\n#include <dlfcn.h>\n#include <stdarg.h>\n#include \"glxclient.h\"\n#include \"dri_common.h\"\n#include \"loader.h\"\n\n#ifndef RTLD_NOW\n#define RTLD_NOW 0\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n_X_HIDDEN void\ndri_message(int level, const char *f, ...)\n{\n   va_list args;\n   int threshold = _LOADER_WARNING;\n   const char *libgl_debug;\n\n   libgl_debug = getenv(\"LIBGL_DEBUG\");\n   if (libgl_debug) {\n      if (strstr(libgl_debug, \"quiet\"))\n         threshold = _LOADER_FATAL;\n      else if (strstr(libgl_debug, \"verbose\"))\n         threshold = _LOADER_DEBUG;\n   }\n\n   /* Note that the _LOADER_* levels are lower numbers for more severe. */\n   if (level <= threshold) {\n      fprintf(stderr, \"libGL%s: \", level <= _LOADER_WARNING ? \" error\" : \"\");\n      va_start(args, f);\n      vfprintf(stderr, f, args);\n      va_end(args);\n   }\n}\n\n#ifndef GL_LIB_NAME\n#define GL_LIB_NAME \"libGL.so.1\"\n#endif\n\n/**\n * Try to \\c dlopen the named driver.\n *\n * This function adds the \"_dri.so\" suffix to the driver name and searches the\n * directories specified by the \\c LIBGL_DRIVERS_PATH environment variable in\n * order to find the driver.\n *\n * \\param driverName - a name like \"i965\", \"radeon\", \"nouveau\", etc.\n * \\param out_driver_handle - Address to return the resulting dlopen() handle.\n *\n * \\returns\n * The __DRIextension entrypoint table for the driver, or \\c NULL if driver\n * file not found.\n */\n_X_HIDDEN const __DRIextension **\ndriOpenDriver(const char *driverName, void **out_driver_handle)\n{\n   void *glhandle;\n\n   /* Attempt to make sure libGL symbols will be visible to the driver */\n   glhandle = dlopen(GL_LIB_NAME, RTLD_NOW | RTLD_GLOBAL);\n\n   static const char *search_path_vars[] = {\n      \"LIBGL_DRIVERS_PATH\",\n      \"LIBGL_DRIVERS_DIR\", /* deprecated */\n      NULL\n   };\n\n   const __DRIextension **extensions =\n      loader_open_driver(driverName, out_driver_handle, search_path_vars);\n\n   if (glhandle)\n      dlclose(glhandle);\n\n   return extensions;\n}\n\n#define __ATTRIB(attrib, field) \\\n    { attrib, offsetof(struct glx_config, field) }\n\nstatic const struct\n{\n   unsigned int attrib, offset;\n} attribMap[] = {\n   __ATTRIB(__DRI_ATTRIB_BUFFER_SIZE, rgbBits),\n      __ATTRIB(__DRI_ATTRIB_LEVEL, level),\n      __ATTRIB(__DRI_ATTRIB_RED_SIZE, redBits),\n      __ATTRIB(__DRI_ATTRIB_GREEN_SIZE, greenBits),\n      __ATTRIB(__DRI_ATTRIB_BLUE_SIZE, blueBits),\n      __ATTRIB(__DRI_ATTRIB_ALPHA_SIZE, alphaBits),\n      __ATTRIB(__DRI_ATTRIB_DEPTH_SIZE, depthBits),\n      __ATTRIB(__DRI_ATTRIB_STENCIL_SIZE, stencilBits),\n      __ATTRIB(__DRI_ATTRIB_ACCUM_RED_SIZE, accumRedBits),\n      __ATTRIB(__DRI_ATTRIB_ACCUM_GREEN_SIZE, accumGreenBits),\n      __ATTRIB(__DRI_ATTRIB_ACCUM_BLUE_SIZE, accumBlueBits),\n      __ATTRIB(__DRI_ATTRIB_ACCUM_ALPHA_SIZE, accumAlphaBits),\n      __ATTRIB(__DRI_ATTRIB_SAMPLE_BUFFERS, sampleBuffers),\n      __ATTRIB(__DRI_ATTRIB_SAMPLES, samples),\n      __ATTRIB(__DRI_ATTRIB_DOUBLE_BUFFER, doubleBufferMode),\n      __ATTRIB(__DRI_ATTRIB_STEREO, stereoMode),\n      __ATTRIB(__DRI_ATTRIB_AUX_BUFFERS, numAuxBuffers),\n#if 0\n      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_TYPE, transparentPixel),\n      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_INDEX_VALUE, transparentIndex),\n      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_RED_VALUE, transparentRed),\n      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_GREEN_VALUE, transparentGreen),\n      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_BLUE_VALUE, transparentBlue),\n      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_ALPHA_VALUE, transparentAlpha),\n      __ATTRIB(__DRI_ATTRIB_RED_MASK, redMask),\n      __ATTRIB(__DRI_ATTRIB_GREEN_MASK, greenMask),\n      __ATTRIB(__DRI_ATTRIB_BLUE_MASK, blueMask),\n      __ATTRIB(__DRI_ATTRIB_ALPHA_MASK, alphaMask),\n      __ATTRIB(__DRI_ATTRIB_RED_SHIFT, redShift),\n      __ATTRIB(__DRI_ATTRIB_GREEN_SHIFT, greenShift),\n      __ATTRIB(__DRI_ATTRIB_BLUE_SHIFT, blueShift),\n      __ATTRIB(__DRI_ATTRIB_ALPHA_SHIFT, alphaShift),\n#endif\n      __ATTRIB(__DRI_ATTRIB_MAX_PBUFFER_WIDTH, maxPbufferWidth),\n      __ATTRIB(__DRI_ATTRIB_MAX_PBUFFER_HEIGHT, maxPbufferHeight),\n      __ATTRIB(__DRI_ATTRIB_MAX_PBUFFER_PIXELS, maxPbufferPixels),\n      __ATTRIB(__DRI_ATTRIB_OPTIMAL_PBUFFER_WIDTH, optimalPbufferWidth),\n      __ATTRIB(__DRI_ATTRIB_OPTIMAL_PBUFFER_HEIGHT, optimalPbufferHeight),\n      __ATTRIB(__DRI_ATTRIB_SWAP_METHOD, swapMethod),\n      __ATTRIB(__DRI_ATTRIB_BIND_TO_TEXTURE_RGB, bindToTextureRgb),\n      __ATTRIB(__DRI_ATTRIB_BIND_TO_TEXTURE_RGBA, bindToTextureRgba),\n      __ATTRIB(__DRI_ATTRIB_BIND_TO_MIPMAP_TEXTURE,\n                     bindToMipmapTexture),\n      __ATTRIB(__DRI_ATTRIB_YINVERTED, yInverted),\n      __ATTRIB(__DRI_ATTRIB_FRAMEBUFFER_SRGB_CAPABLE, sRGBCapable)\n};\n\nstatic int\nscalarEqual(struct glx_config *mode, unsigned int attrib, unsigned int value)\n{\n   unsigned glxValue, i;\n\n   for (i = 0; i < ARRAY_SIZE(attribMap); i++)\n      if (attribMap[i].attrib == attrib) {\n         glxValue = *(unsigned int *) ((char *) mode + attribMap[i].offset);\n         return glxValue == GLX_DONT_CARE || glxValue == value;\n      }\n\n   return GL_TRUE;              /* Is a non-existing attribute equal to value? */\n}\n\nstatic int\ndriConfigEqual(const __DRIcoreExtension *core,\n               struct glx_config *config, const __DRIconfig *driConfig)\n{\n   unsigned int attrib, value, glxValue;\n   int i;\n\n   i = 0;\n   while (core->indexConfigAttrib(driConfig, i++, &attrib, &value)) {\n      switch (attrib) {\n      case __DRI_ATTRIB_RENDER_TYPE:\n         glxValue = 0;\n         if (value & __DRI_ATTRIB_RGBA_BIT) {\n            glxValue |= GLX_RGBA_BIT;\n         }\n         if (value & __DRI_ATTRIB_COLOR_INDEX_BIT) {\n            glxValue |= GLX_COLOR_INDEX_BIT;\n         }\n         if (value & __DRI_ATTRIB_FLOAT_BIT) {\n            glxValue |= GLX_RGBA_FLOAT_BIT_ARB;\n         }\n         if (value & __DRI_ATTRIB_UNSIGNED_FLOAT_BIT) {\n            glxValue |= GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT;\n         }\n         if (glxValue != config->renderType)\n            return GL_FALSE;\n         break;\n\n      case __DRI_ATTRIB_CONFIG_CAVEAT:\n         if (value & __DRI_ATTRIB_NON_CONFORMANT_CONFIG)\n            glxValue = GLX_NON_CONFORMANT_CONFIG;\n         else if (value & __DRI_ATTRIB_SLOW_BIT)\n            glxValue = GLX_SLOW_CONFIG;\n         else\n            glxValue = GLX_NONE;\n         if (glxValue != config->visualRating)\n            return GL_FALSE;\n         break;\n\n      case __DRI_ATTRIB_BIND_TO_TEXTURE_TARGETS:\n         glxValue = 0;\n         if (value & __DRI_ATTRIB_TEXTURE_1D_BIT)\n            glxValue |= GLX_TEXTURE_1D_BIT_EXT;\n         if (value & __DRI_ATTRIB_TEXTURE_2D_BIT)\n            glxValue |= GLX_TEXTURE_2D_BIT_EXT;\n         if (value & __DRI_ATTRIB_TEXTURE_RECTANGLE_BIT)\n            glxValue |= GLX_TEXTURE_RECTANGLE_BIT_EXT;\n         if (config->bindToTextureTargets != GLX_DONT_CARE &&\n             glxValue != config->bindToTextureTargets)\n            return GL_FALSE;\n         break;\n\n      case __DRI_ATTRIB_SWAP_METHOD:\n         if (value == __DRI_ATTRIB_SWAP_EXCHANGE)\n            glxValue = GLX_SWAP_EXCHANGE_OML;\n         else if (value == __DRI_ATTRIB_SWAP_COPY)\n            glxValue = GLX_SWAP_COPY_OML;\n         else\n            glxValue = GLX_SWAP_UNDEFINED_OML;\n\n         if (!scalarEqual(config, attrib, glxValue))\n            return GL_FALSE;\n\n         break;\n\n      default:\n         if (!scalarEqual(config, attrib, value))\n            return GL_FALSE;\n      }\n   }\n\n   return GL_TRUE;\n}\n\nstatic struct glx_config *\ncreateDriMode(const __DRIcoreExtension * core,\n\t      struct glx_config *config, const __DRIconfig **driConfigs)\n{\n   __GLXDRIconfigPrivate *driConfig;\n   int i;\n\n   for (i = 0; driConfigs[i]; i++) {\n      if (driConfigEqual(core, config, driConfigs[i]))\n         break;\n   }\n\n   if (driConfigs[i] == NULL)\n      return NULL;\n\n   driConfig = malloc(sizeof *driConfig);\n   if (driConfig == NULL)\n      return NULL;\n\n   driConfig->base = *config;\n   driConfig->driConfig = driConfigs[i];\n\n   return &driConfig->base;\n}\n\n_X_HIDDEN struct glx_config *\ndriConvertConfigs(const __DRIcoreExtension * core,\n                  struct glx_config *configs, const __DRIconfig **driConfigs)\n{\n   struct glx_config head, *tail, *m;\n\n   tail = &head;\n   head.next = NULL;\n   for (m = configs; m; m = m->next) {\n      tail->next = createDriMode(core, m, driConfigs);\n      if (tail->next == NULL) {\n         /* no matching dri config for m */\n         continue;\n      }\n\n\n      tail = tail->next;\n   }\n\n   return head.next;\n}\n\n_X_HIDDEN void\ndriDestroyConfigs(const __DRIconfig **configs)\n{\n   int i;\n\n   for (i = 0; configs[i]; i++)\n      free((__DRIconfig *) configs[i]);\n   free(configs);\n}\n\nstatic struct glx_config *\ndriInferDrawableConfig(struct glx_screen *psc, GLXDrawable draw)\n{\n   unsigned int fbconfig = 0;\n\n   if (__glXGetDrawableAttribute(psc->dpy, draw, GLX_FBCONFIG_ID, &fbconfig)) {\n      return glx_config_find_fbconfig(psc->configs, fbconfig);\n   }\n\n   return NULL;\n}\n\n_X_HIDDEN __GLXDRIdrawable *\ndriFetchDrawable(struct glx_context *gc, GLXDrawable glxDrawable)\n{\n   struct glx_display *const priv = __glXInitialize(gc->psc->dpy);\n   __GLXDRIdrawable *pdraw;\n   struct glx_screen *psc;\n   struct glx_config *config = gc->config;\n\n   if (priv == NULL)\n      return NULL;\n\n   if (glxDrawable == None)\n      return NULL;\n\n   psc = priv->screens[gc->screen];\n   if (priv->drawHash == NULL)\n      return NULL;\n\n   if (__glxHashLookup(priv->drawHash, glxDrawable, (void *) &pdraw) == 0) {\n      pdraw->refcount ++;\n      return pdraw;\n   }\n\n   if (config == NULL)\n      config = driInferDrawableConfig(gc->psc, glxDrawable);\n   if (config == NULL)\n      return NULL;\n\n   pdraw = psc->driScreen->createDrawable(psc, glxDrawable, glxDrawable,\n                                          config);\n\n   if (pdraw == NULL) {\n      ErrorMessageF(\"failed to create drawable\\n\");\n      return NULL;\n   }\n\n   if (__glxHashInsert(priv->drawHash, glxDrawable, pdraw)) {\n      (*pdraw->destroyDrawable) (pdraw);\n      return NULL;\n   }\n   pdraw->refcount = 1;\n\n   return pdraw;\n}\n\n_X_HIDDEN void\ndriReleaseDrawables(struct glx_context *gc)\n{\n   const struct glx_display *priv = gc->psc->display;\n   __GLXDRIdrawable *pdraw;\n\n   if (priv == NULL)\n      return;\n\n   if (__glxHashLookup(priv->drawHash,\n\t\t       gc->currentDrawable, (void *) &pdraw) == 0) {\n      if (pdraw->drawable == pdraw->xDrawable) {\n\t pdraw->refcount --;\n\t if (pdraw->refcount == 0) {\n\t    pdraw->destroyDrawable(pdraw);\n\t    __glxHashDelete(priv->drawHash, gc->currentDrawable);\n\t }\n      }\n   }\n\n   if (__glxHashLookup(priv->drawHash,\n\t\t       gc->currentReadable, (void *) &pdraw) == 0) {\n      if (pdraw->drawable == pdraw->xDrawable) {\n\t pdraw->refcount --;\n\t if (pdraw->refcount == 0) {\n\t    pdraw->destroyDrawable(pdraw);\n\t    __glxHashDelete(priv->drawHash, gc->currentReadable);\n\t }\n      }\n   }\n\n   gc->currentDrawable = None;\n   gc->currentReadable = None;\n\n}\n\n_X_HIDDEN bool\ndri2_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,\n                         unsigned *major_ver, unsigned *minor_ver,\n                         uint32_t *render_type, uint32_t *flags, unsigned *api,\n                         int *reset, int *release, unsigned *error)\n{\n   unsigned i;\n   bool got_profile = false;\n   int no_error = 0;\n   uint32_t profile;\n\n   *major_ver = 1;\n   *minor_ver = 0;\n   *render_type = GLX_RGBA_TYPE;\n   *reset = __DRI_CTX_RESET_NO_NOTIFICATION;\n   *release = __DRI_CTX_RELEASE_BEHAVIOR_FLUSH;\n   *flags = 0;\n   *api = __DRI_API_OPENGL;\n\n   if (num_attribs == 0) {\n      return true;\n   }\n\n   /* This is actually an internal error, but what the heck.\n    */\n   if (attribs == NULL) {\n      *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;\n      return false;\n   }\n\n   for (i = 0; i < num_attribs; i++) {\n      switch (attribs[i * 2]) {\n      case GLX_CONTEXT_MAJOR_VERSION_ARB:\n\t *major_ver = attribs[i * 2 + 1];\n\t break;\n      case GLX_CONTEXT_MINOR_VERSION_ARB:\n\t *minor_ver = attribs[i * 2 + 1];\n\t break;\n      case GLX_CONTEXT_FLAGS_ARB:\n\t *flags = attribs[i * 2 + 1];\n\t break;\n      case GLX_CONTEXT_OPENGL_NO_ERROR_ARB:\n\t no_error = attribs[i * 2 + 1];\n\t break;\n      case GLX_CONTEXT_PROFILE_MASK_ARB:\n\t profile = attribs[i * 2 + 1];\n\t got_profile = true;\n\t break;\n      case GLX_RENDER_TYPE:\n         *render_type = attribs[i * 2 + 1];\n\t break;\n      case GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB:\n         switch (attribs[i * 2 + 1]) {\n         case GLX_NO_RESET_NOTIFICATION_ARB:\n            *reset = __DRI_CTX_RESET_NO_NOTIFICATION;\n            break;\n         case GLX_LOSE_CONTEXT_ON_RESET_ARB:\n            *reset = __DRI_CTX_RESET_LOSE_CONTEXT;\n            break;\n         default:\n            *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;\n            return false;\n         }\n         break;\n      case GLX_CONTEXT_RELEASE_BEHAVIOR_ARB:\n         switch (attribs[i * 2 + 1]) {\n         case GLX_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB:\n            *release = __DRI_CTX_RELEASE_BEHAVIOR_NONE;\n            break;\n         case GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB:\n            *release = __DRI_CTX_RELEASE_BEHAVIOR_FLUSH;\n            break;\n         default:\n            *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;\n            return false;\n         }\n         break;\n      default:\n\t /* If an unknown attribute is received, fail.\n\t  */\n\t *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;\n\t return false;\n      }\n   }\n\n   if (no_error) {\n      *flags |= __DRI_CTX_FLAG_NO_ERROR;\n   }\n\n   if (!got_profile) {\n      if (*major_ver > 3 || (*major_ver == 3 && *minor_ver >= 2))\n\t *api = __DRI_API_OPENGL_CORE;\n   } else {\n      switch (profile) {\n      case GLX_CONTEXT_CORE_PROFILE_BIT_ARB:\n\t /* There are no profiles before OpenGL 3.2.  The\n\t  * GLX_ARB_create_context_profile spec says:\n\t  *\n\t  *     \"If the requested OpenGL version is less than 3.2,\n\t  *     GLX_CONTEXT_PROFILE_MASK_ARB is ignored and the functionality\n\t  *     of the context is determined solely by the requested version.\"\n\t  */\n\t *api = (*major_ver > 3 || (*major_ver == 3 && *minor_ver >= 2))\n\t    ? __DRI_API_OPENGL_CORE : __DRI_API_OPENGL;\n\t break;\n      case GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB:\n\t *api = __DRI_API_OPENGL;\n\t break;\n      case GLX_CONTEXT_ES_PROFILE_BIT_EXT:\n         if (*major_ver >= 3)\n            *api = __DRI_API_GLES3;\n         else if (*major_ver == 2 && *minor_ver == 0)\n            *api = __DRI_API_GLES2;\n         else if (*major_ver == 1 && *minor_ver < 2)\n            *api = __DRI_API_GLES;\n         else {\n            *error = __DRI_CTX_ERROR_BAD_API;\n            return false;\n         }\n         break;\n      default:\n\t *error = __DRI_CTX_ERROR_BAD_API;\n\t return false;\n      }\n   }\n\n   /* Unknown flag value.\n    */\n   if (*flags & ~(__DRI_CTX_FLAG_DEBUG | __DRI_CTX_FLAG_FORWARD_COMPATIBLE\n                  | __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS\n                  | __DRI_CTX_FLAG_NO_ERROR)) {\n      *error = __DRI_CTX_ERROR_UNKNOWN_FLAG;\n      return false;\n   }\n\n   /* There are no forward-compatible contexts before OpenGL 3.0.  The\n    * GLX_ARB_create_context spec says:\n    *\n    *     \"Forward-compatible contexts are defined only for OpenGL versions\n    *     3.0 and later.\"\n    */\n   if (*major_ver < 3 && (*flags & __DRI_CTX_FLAG_FORWARD_COMPATIBLE) != 0) {\n      *error = __DRI_CTX_ERROR_BAD_FLAG;\n      return false;\n   }\n\n   if (*major_ver >= 3 && *render_type == GLX_COLOR_INDEX_TYPE) {\n      *error = __DRI_CTX_ERROR_BAD_FLAG;\n      return false;\n   }\n\n   *error = __DRI_CTX_ERROR_SUCCESS;\n   return true;\n}\n\n_X_HIDDEN bool\ndri2_check_no_error(uint32_t flags, struct glx_context *share_context,\n                    int major, unsigned *error)\n{\n   Bool noError = flags & __DRI_CTX_FLAG_NO_ERROR;\n\n   /* The KHR_no_error specs say:\n    *\n    *    Requires OpenGL ES 2.0 or OpenGL 2.0.\n    */\n   if (noError && major < 2) {\n      *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;\n      return false;\n   }\n\n   /* The GLX_ARB_create_context_no_error specs say:\n    *\n    *    BadMatch is generated if the value of GLX_CONTEXT_OPENGL_NO_ERROR_ARB\n    *    used to create <share_context> does not match the value of\n    *    GLX_CONTEXT_OPENGL_NO_ERROR_ARB for the context being created.\n    */\n   if (share_context && !!share_context->noError != !!noError) {\n      *error = __DRI_CTX_ERROR_BAD_FLAG;\n      return false;\n   }\n\n   /* The GLX_ARB_create_context_no_error specs say:\n    *\n    *    BadMatch is generated if the GLX_CONTEXT_OPENGL_NO_ERROR_ARB is TRUE at\n    *    the same time as a debug or robustness context is specified.\n    *\n    */\n   if (noError && ((flags & __DRI_CTX_FLAG_DEBUG) ||\n                   (flags & __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS))) {\n      *error = __DRI_CTX_ERROR_BAD_FLAG;\n      return false;\n   }\n\n   return true;\n}\n\nstruct glx_context *\ndri_common_create_context(struct glx_screen *base,\n                          struct glx_config *config_base,\n                          struct glx_context *shareList,\n                          int renderType)\n{\n   unsigned int error;\n   uint32_t attribs[2] = { GLX_RENDER_TYPE, renderType };\n\n   return base->vtable->create_context_attribs(base, config_base, shareList,\n                                               1, attribs, &error);\n}\n\n\n/*\n * Given a display pointer and screen number, determine the name of\n * the DRI driver for the screen (i.e., \"i965\", \"radeon\", \"nouveau\", etc).\n * Return True for success, False for failure.\n */\nstatic Bool\ndriGetDriverName(Display * dpy, int scrNum, char **driverName)\n{\n   struct glx_screen *glx_screen = GetGLXScreenConfigs(dpy, scrNum);\n\n   if (!glx_screen || !glx_screen->vtable->get_driver_name)\n      return False;\n\n   *driverName = glx_screen->vtable->get_driver_name(glx_screen);\n   return True;\n}\n\n/*\n * Exported function for querying the DRI driver for a given screen.\n *\n * The returned char pointer points to a static array that will be\n * overwritten by subsequent calls.\n */\n_GLX_PUBLIC const char *\nglXGetScreenDriver(Display * dpy, int scrNum)\n{\n   static char ret[32];\n   char *driverName;\n\n   if (driGetDriverName(dpy, scrNum, &driverName)) {\n      int len;\n      if (!driverName)\n         return NULL;\n      len = strlen(driverName);\n      if (len >= 31)\n         return NULL;\n      memcpy(ret, driverName, len + 1);\n      free(driverName);\n      return ret;\n   }\n   return NULL;\n}\n\n/* glXGetDriverConfig must return a pointer with a static lifetime. To avoid\n * keeping drivers loaded and other leaks, we keep a cache of results here that\n * is cleared by an atexit handler.\n */\nstruct driver_config_entry {\n   struct driver_config_entry *next;\n   char *driverName;\n   char *config;\n};\n\nstatic pthread_mutex_t driver_config_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic struct driver_config_entry *driver_config_cache = NULL;\n\n/* Called as an atexit function. Otherwise, this would have to be called with\n * driver_config_mutex locked.\n */\nstatic void\nclear_driver_config_cache()\n{\n   while (driver_config_cache) {\n      struct driver_config_entry *e = driver_config_cache;\n      driver_config_cache = e->next;\n\n      free(e->driverName);\n      free(e->config);\n      free(e);\n   }\n}\n\nstatic char *\nget_driver_config(const char *driverName)\n{\n   void *handle;\n   char *config = NULL;\n   const __DRIextension **extensions = driOpenDriver(driverName, &handle);\n   if (extensions) {\n      for (int i = 0; extensions[i]; i++) {\n         if (strcmp(extensions[i]->name, __DRI_CONFIG_OPTIONS) != 0)\n            continue;\n\n         __DRIconfigOptionsExtension *ext =\n            (__DRIconfigOptionsExtension *)extensions[i];\n\n         if (ext->base.version >= 2)\n            config = ext->getXml(driverName);\n         else\n            config = strdup(ext->xml);\n\n         break;\n      }\n   }\n\n   if (!config) {\n      /* Fall back to the old method */\n      config = dlsym(handle, \"__driConfigOptions\");\n      if (config)\n         config = strdup(config);\n   }\n\n   dlclose(handle);\n\n   return config;\n}\n\n/*\n * Exported function for obtaining a driver's option list (UTF-8 encoded XML).\n *\n * The returned char pointer points directly into the driver. Therefore\n * it should be treated as a constant.\n *\n * If the driver was not found or does not support configuration NULL is\n * returned.\n */\n_GLX_PUBLIC const char *\nglXGetDriverConfig(const char *driverName)\n{\n   struct driver_config_entry *e;\n\n   pthread_mutex_lock(&driver_config_mutex);\n\n   for (e = driver_config_cache; e; e = e->next) {\n      if (strcmp(e->driverName, driverName) == 0)\n         goto out;\n   }\n\n   e = malloc(sizeof(*e));\n   if (!e)\n      goto out;\n\n   e->config = get_driver_config(driverName);\n   e->driverName = strdup(driverName);\n   if (!e->config || !e->driverName) {\n      free(e->config);\n      free(e->driverName);\n      free(e);\n      e = NULL;\n      goto out;\n   }\n\n   e->next = driver_config_cache;\n   driver_config_cache = e;\n\n   if (!e->next)\n      atexit(clear_driver_config_cache);\n\nout:\n   pthread_mutex_unlock(&driver_config_mutex);\n\n   return e ? e->config : NULL;\n}\n\n#endif /* GLX_DIRECT_RENDERING */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/glx/windows/windowsgl.c": "/*\n * Copyright \u00a9 2014 Jon Turney\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"windowsgl.h\"\n#include \"windowsgl_internal.h\"\n\n#include \"glapi.h\"\n#include \"wgl.h\"\n\n#include <dlfcn.h>\n#include <assert.h>\n#include <stdio.h>\n#include <strings.h>\n\nstatic struct _glapi_table *windows_api = NULL;\n\nstatic void *\nwindows_get_dl_handle(void)\n{\n   static void *dl_handle = NULL;\n\n   if (!dl_handle)\n      dl_handle = dlopen(\"cygnativeGLthunk.dll\", RTLD_NOW);\n\n   return dl_handle;\n}\n\nstatic void\nwindows_glapi_create_table(void)\n{\n   if (windows_api)\n      return;\n\n   windows_api = _glapi_create_table_from_handle(windows_get_dl_handle(), \"gl\");\n   assert(windows_api);\n}\n\nstatic void windows_glapi_set_dispatch(void)\n{\n   windows_glapi_create_table();\n   _glapi_set_dispatch(windows_api);\n}\n\nwindowsContext *\nwindows_create_context(int pxfi, windowsContext *shared)\n{\n   windowsContext *gc;\n\n   gc = calloc(1, sizeof *gc);\n   if (gc == NULL)\n      return NULL;\n\n   // create a temporary, invisible window\n#define GL_TEMP_WINDOW_CLASS \"glTempWndClass\"\n   {\n      static wATOM glTempWndClass = 0;\n\n      if (glTempWndClass == 0) {\n         WNDCLASSEX wc;\n         wc.cbSize = sizeof(WNDCLASSEX);\n         wc.style = CS_HREDRAW | CS_VREDRAW;\n         wc.lpfnWndProc = DefWindowProc;\n         wc.cbClsExtra = 0;\n         wc.cbWndExtra = 0;\n         wc.hInstance = GetModuleHandle(NULL);\n         wc.hIcon = 0;\n         wc.hCursor = 0;\n         wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);\n         wc.lpszMenuName = NULL;\n         wc.lpszClassName = GL_TEMP_WINDOW_CLASS;\n         wc.hIconSm = 0;\n         RegisterClassEx(&wc);\n      }\n   }\n\n   HWND hwnd = CreateWindowExA(0,\n                               GL_TEMP_WINDOW_CLASS,\n                               \"glWindow\",\n                               0,\n                               0, 0, 0, 0,\n                               NULL, NULL, GetModuleHandle(NULL), NULL);\n   HDC hdc = GetDC(hwnd);\n\n   // We must set the windows pixel format before we can create a WGL context\n   gc->pxfi = pxfi;\n   SetPixelFormat(hdc, gc->pxfi, NULL);\n\n   gc->ctx = wglCreateContext(hdc);\n\n   if (shared && gc->ctx)\n      wglShareLists(shared->ctx, gc->ctx);\n\n   ReleaseDC(hwnd, hdc);\n   DestroyWindow(hwnd);\n\n   if (!gc->ctx)\n   {\n     free(gc);\n     return NULL;\n   }\n\n   return gc;\n}\n\nwindowsContext *\nwindows_create_context_attribs(int pxfi, windowsContext *shared, const int *attribList)\n{\n   windowsContext *gc;\n\n   gc = calloc(1, sizeof *gc);\n   if (gc == NULL)\n      return NULL;\n\n   // create a temporary, invisible window\n#define GL_TEMP_WINDOW_CLASS \"glTempWndClass\"\n   {\n      static wATOM glTempWndClass = 0;\n\n      if (glTempWndClass == 0) {\n         WNDCLASSEX wc;\n         wc.cbSize = sizeof(WNDCLASSEX);\n         wc.style = CS_HREDRAW | CS_VREDRAW;\n         wc.lpfnWndProc = DefWindowProc;\n         wc.cbClsExtra = 0;\n         wc.cbWndExtra = 0;\n         wc.hInstance = GetModuleHandle(NULL);\n         wc.hIcon = 0;\n         wc.hCursor = 0;\n         wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);\n         wc.lpszMenuName = NULL;\n         wc.lpszClassName = GL_TEMP_WINDOW_CLASS;\n         wc.hIconSm = 0;\n         RegisterClassEx(&wc);\n      }\n   }\n\n   HWND hwnd = CreateWindowExA(0,\n                               GL_TEMP_WINDOW_CLASS,\n                               \"glWindow\",\n                               0,\n                               0, 0, 0, 0,\n                               NULL, NULL, GetModuleHandle(NULL), NULL);\n   HDC hdc = GetDC(hwnd);\n   HGLRC shareContext = NULL;\n   if (shared)\n      shareContext = shared->ctx;\n\n   // We must set the windows pixel format before we can create a WGL context\n   gc->pxfi = pxfi;\n   SetPixelFormat(hdc, gc->pxfi, NULL);\n\n   gc->ctx = wglCreateContextAttribsARB(hdc, shareContext, attribList);\n\n   ReleaseDC(hwnd, hdc);\n   DestroyWindow(hwnd);\n\n   if (!gc->ctx)\n   {\n     free(gc);\n     return NULL;\n   }\n\n   return gc;\n}\n\nvoid\nwindows_destroy_context(windowsContext *context)\n{\n   wglDeleteContext(context->ctx);\n   context->ctx = NULL;\n   free(context);\n}\n\nint windows_bind_context(windowsContext *context, windowsDrawable *draw, windowsDrawable *read)\n{\n   HDC drawDc = draw->callbacks->getdc(draw);\n\n   if (!draw->pxfi)\n   {\n      SetPixelFormat(drawDc, context->pxfi, NULL);\n      draw->pxfi = context->pxfi;\n   }\n\n   if ((read != NULL) &&  (read != draw))\n   {\n      /*\n        If there is a separate read drawable, create a separate read DC, and\n        use the wglMakeContextCurrent extension to make the context current\n        drawing to one DC and reading from the other\n\n        Should only occur when WGL_ARB_make_current_read extension is present\n      */\n      HDC readDc = read->callbacks->getdc(read);\n\n      BOOL ret = wglMakeContextCurrentARB(drawDc, readDc, context->ctx);\n\n      read->callbacks->releasedc(read, readDc);\n\n      if (!ret) {\n         printf(\"wglMakeContextCurrentARB error: %08x\\n\", (int)GetLastError());\n         return FALSE;\n      }\n   }\n   else\n   {\n      /* Otherwise, just use wglMakeCurrent */\n      BOOL ret = wglMakeCurrent(drawDc, context->ctx);\n      if (!ret) {\n         printf(\"wglMakeCurrent error: %08x\\n\", (int)GetLastError());\n         return FALSE;\n      }\n   }\n\n   draw->callbacks->releasedc(draw, drawDc);\n\n   windows_glapi_set_dispatch();\n\n   return TRUE;\n}\n\nvoid windows_unbind_context(windowsContext * context)\n{\n   wglMakeCurrent(NULL, NULL);\n}\n\n/*\n *\n */\n\nvoid\nwindows_swap_buffers(windowsDrawable *draw)\n{\n   HDC drawDc = GetDC(draw->hWnd);\n   SwapBuffers(drawDc);\n   ReleaseDC(draw->hWnd, drawDc);\n}\n\n\ntypedef void (__stdcall * PFNGLADDSWAPHINTRECTWIN) (GLint x, GLint y,\n                                                    GLsizei width,\n                                                    GLsizei height);\n\nstatic void\nglAddSwapHintRectWIN(GLint x, GLint y, GLsizei width,\n                            GLsizei height)\n{\n   PFNGLADDSWAPHINTRECTWIN proc = (PFNGLADDSWAPHINTRECTWIN)wglGetProcAddress(\"glAddSwapHintRectWIN\");\n   if (proc)\n      proc(x, y, width, height);\n}\n\nvoid\nwindows_copy_subbuffer(windowsDrawable *draw,\n                      int x, int y, int width, int height)\n{\n   glAddSwapHintRectWIN(x, y, width, height);\n   windows_swap_buffers(draw);\n}\n\n/*\n * Helper function for calling a test function on an initial context\n */\nstatic void\nwindows_call_with_context(void (*proc)(HDC, void *), void *args)\n{\n   // create window class\n#define WIN_GL_TEST_WINDOW_CLASS \"GLTest\"\n   {\n      static wATOM glTestWndClass = 0;\n\n      if (glTestWndClass == 0) {\n         WNDCLASSEX wc;\n\n         wc.cbSize = sizeof(WNDCLASSEX);\n         wc.style = CS_HREDRAW | CS_VREDRAW;\n         wc.lpfnWndProc = DefWindowProc;\n         wc.cbClsExtra = 0;\n         wc.cbWndExtra = 0;\n         wc.hInstance = GetModuleHandle(NULL);\n         wc.hIcon = 0;\n         wc.hCursor = 0;\n         wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);\n         wc.lpszMenuName = NULL;\n         wc.lpszClassName = WIN_GL_TEST_WINDOW_CLASS;\n         wc.hIconSm = 0;\n         glTestWndClass = RegisterClassEx(&wc);\n      }\n   }\n\n   // create an invisible window for a scratch DC\n   HWND hwnd = CreateWindowExA(0,\n                               WIN_GL_TEST_WINDOW_CLASS,\n                               \"GL Renderer Capabilities Test Window\",\n                               0, 0, 0, 0, 0, NULL, NULL, GetModuleHandle(NULL),\n                               NULL);\n   if (hwnd) {\n      HDC hdc = GetDC(hwnd);\n\n      // we must set a pixel format before we can create a context, just use the first one...\n      SetPixelFormat(hdc, 1, NULL);\n      HGLRC hglrc = wglCreateContext(hdc);\n      wglMakeCurrent(hdc, hglrc);\n\n      // call the test function\n      proc(hdc, args);\n\n      // clean up\n      wglMakeCurrent(NULL, NULL);\n      wglDeleteContext(hglrc);\n      ReleaseDC(hwnd, hdc);\n      DestroyWindow(hwnd);\n   }\n}\n\nstatic void\nwindows_check_render_test(HDC hdc, void *args)\n{\n   int *result = (int *)args;\n\n   /* Rather than play linkage games using stdcall to ensure we get\n      glGetString from opengl32.dll here, use dlsym */\n   void *dlhandle = windows_get_dl_handle();\n   const char *(*proc)(int) = dlsym(dlhandle, \"glGetString\");\n   const char *gl_renderer = (const char *)proc(GL_RENDERER);\n\n   if ((!gl_renderer) || (strcasecmp(gl_renderer, \"GDI Generic\") == 0))\n      *result = FALSE;\n   else\n      *result = TRUE;\n}\n\nint\nwindows_check_renderer(void)\n{\n   int result;\n   windows_call_with_context(windows_check_render_test, &result);\n   return result;\n}\n\ntypedef struct {\n   char *gl_extensions;\n   char *wgl_extensions;\n} windows_extensions_result;\n\nstatic void\nwindows_extensions_test(HDC hdc, void *args)\n{\n   windows_extensions_result *r = (windows_extensions_result *)args;\n\n   void *dlhandle = windows_get_dl_handle();\n   const char *(*proc)(int) = dlsym(dlhandle, \"glGetString\");\n\n   r->gl_extensions = strdup(proc(GL_EXTENSIONS));\n\n   wglResolveExtensionProcs();\n   r->wgl_extensions = strdup(wglGetExtensionsStringARB(hdc));\n}\n\nvoid\nwindows_extensions(char **gl_extensions, char **wgl_extensions)\n{\n   windows_extensions_result result;\n\n   *gl_extensions = \"\";\n   *wgl_extensions = \"\";\n\n   windows_call_with_context(windows_extensions_test, &result);\n\n   *gl_extensions = result.gl_extensions;\n   *wgl_extensions = result.wgl_extensions;\n}\n\nvoid windows_setTexBuffer(windowsContext *context, int textureTarget,\n                         int textureFormat, windowsDrawable *drawable)\n{\n   // not yet implemented\n}\n\nvoid windows_releaseTexBuffer(windowsContext *context, int textureTarget,\n                             windowsDrawable *drawable)\n{\n   // not yet implemented\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/glx/apple/apple_cgl.c": "/*\n Copyright (c) 2008 Apple Inc.\n \n Permission is hereby granted, free of charge, to any person\n obtaining a copy of this software and associated documentation files\n (the \"Software\"), to deal in the Software without restriction,\n including without limitation the rights to use, copy, modify, merge,\n publish, distribute, sublicense, and/or sell copies of the Software,\n and to permit persons to whom the Software is furnished to do so,\n subject to the following conditions:\n \n The above copyright notice and this permission notice shall be\n included in all copies or substantial portions of the Software.\n \n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT\n HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n DEALINGS IN THE SOFTWARE.\n \n Except as contained in this notice, the name(s) of the above\n copyright holders shall not be used in advertising or otherwise to\n promote the sale, use or other dealings in this Software without\n prior written authorization.\n*/\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n\n#include \"apple_cgl.h\"\n#include \"apple_glx.h\"\n\n#ifndef OPENGL_FRAMEWORK_PATH\n#define OPENGL_FRAMEWORK_PATH \"/System/Library/Frameworks/OpenGL.framework/Versions/A/OpenGL\"\n#endif\n\nstatic void *dl_handle = NULL;\n\nstruct apple_cgl_api apple_cgl;\n\nstatic bool initialized = false;\n\nstatic void *\nsym(void *h, const char *name)\n{\n   void *s;\n\n   s = dlsym(h, name);\n\n   if (NULL == s) {\n      fprintf(stderr, \"error: %s\\n\", dlerror());\n      abort();\n   }\n\n   return s;\n}\n\nvoid\napple_cgl_init(void)\n{\n   void *h;\n   const char *opengl_framework_path;\n\n   if (initialized)\n      return;\n\n   opengl_framework_path = getenv(\"OPENGL_FRAMEWORK_PATH\");\n   if (!opengl_framework_path) {\n      opengl_framework_path = OPENGL_FRAMEWORK_PATH;\n   }\n\n   (void) dlerror();            /*drain dlerror */\n   h = dlopen(opengl_framework_path, RTLD_NOW);\n\n   if (NULL == h) {\n      fprintf(stderr, \"error: unable to dlopen %s : %s\\n\",\n              opengl_framework_path, dlerror());\n      abort();\n   }\n\n   dl_handle = h;\n\n   apple_cgl.get_version = sym(h, \"CGLGetVersion\");\n\n   apple_cgl.get_version(&apple_cgl.version_major, &apple_cgl.version_minor);\n\n   apple_glx_diagnostic(\"CGL major %d minor %d\\n\", apple_cgl.version_major, apple_cgl.version_minor);\n\n   if (1 != apple_cgl.version_major) {\n      fprintf(stderr, \"WARNING: the CGL major version has changed!\\n\"\n              \"libGL may be incompatible!\\n\");\n   }\n\n   apple_cgl.choose_pixel_format = sym(h, \"CGLChoosePixelFormat\");\n   apple_cgl.destroy_pixel_format = sym(h, \"CGLDestroyPixelFormat\");\n\n   apple_cgl.clear_drawable = sym(h, \"CGLClearDrawable\");\n   apple_cgl.flush_drawable = sym(h, \"CGLFlushDrawable\");\n\n   apple_cgl.create_context = sym(h, \"CGLCreateContext\");\n   apple_cgl.destroy_context = sym(h, \"CGLDestroyContext\");\n\n   apple_cgl.set_current_context = sym(h, \"CGLSetCurrentContext\");\n   apple_cgl.get_current_context = sym(h, \"CGLGetCurrentContext\");\n   apple_cgl.error_string = sym(h, \"CGLErrorString\");\n\n   apple_cgl.set_off_screen = sym(h, \"CGLSetOffScreen\");\n\n   apple_cgl.copy_context = sym(h, \"CGLCopyContext\");\n\n   apple_cgl.create_pbuffer = sym(h, \"CGLCreatePBuffer\");\n   apple_cgl.destroy_pbuffer = sym(h, \"CGLDestroyPBuffer\");\n   apple_cgl.set_pbuffer = sym(h, \"CGLSetPBuffer\");\n\n   initialized = true;\n}\n\nvoid *\napple_cgl_get_dl_handle(void)\n{\n   return dl_handle;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/include/GL/internal/dri_interface.h": "/*\n * Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.\n * Copyright 2007-2008 Red Hat, Inc.\n * (C) Copyright IBM Corporation 2004\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * on the rights to use, copy, modify, merge, publish, distribute, sub\n * license, and/or sell copies of the Software, and to permit persons to whom\n * the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDERS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * \\file dri_interface.h\n *\n * This file contains all the types and functions that define the interface\n * between a DRI driver and driver loader.  Currently, the most common driver\n * loader is the XFree86 libGL.so.  However, other loaders do exist, and in\n * the future the server-side libglx.a will also be a loader.\n * \n * \\author Kevin E. Martin <kevin@precisioninsight.com>\n * \\author Ian Romanick <idr@us.ibm.com>\n * \\author Kristian H\u00f8gsberg <krh@redhat.com>\n */\n\n#ifndef DRI_INTERFACE_H\n#define DRI_INTERFACE_H\n\n#ifdef HAVE_LIBDRM\n#include <drm.h>\n#else\ntypedef unsigned int drm_context_t;\ntypedef unsigned int drm_drawable_t;\ntypedef struct drm_clip_rect drm_clip_rect_t;\n#endif\n\n#include <GL/gl.h>\n\n#include <stdint.h>\n\n/**\n * \\name DRI interface structures\n *\n * The following structures define the interface between the GLX client\n * side library and the DRI (direct rendering infrastructure).\n */\n/*@{*/\ntypedef struct __DRIdisplayRec\t\t__DRIdisplay;\ntypedef struct __DRIscreenRec\t\t__DRIscreen;\ntypedef struct __DRIcontextRec\t\t__DRIcontext;\ntypedef struct __DRIdrawableRec\t\t__DRIdrawable;\ntypedef struct __DRIconfigRec\t\t__DRIconfig;\ntypedef struct __DRIframebufferRec\t__DRIframebuffer;\ntypedef struct __DRIversionRec\t\t__DRIversion;\n\ntypedef struct __DRIcoreExtensionRec\t\t__DRIcoreExtension;\ntypedef struct __DRIextensionRec\t\t__DRIextension;\ntypedef struct __DRIcopySubBufferExtensionRec\t__DRIcopySubBufferExtension;\ntypedef struct __DRIswapControlExtensionRec\t__DRIswapControlExtension;\ntypedef struct __DRIframeTrackingExtensionRec\t__DRIframeTrackingExtension;\ntypedef struct __DRImediaStreamCounterExtensionRec\t__DRImediaStreamCounterExtension;\ntypedef struct __DRItexOffsetExtensionRec\t__DRItexOffsetExtension;\ntypedef struct __DRItexBufferExtensionRec\t__DRItexBufferExtension;\ntypedef struct __DRIlegacyExtensionRec\t\t__DRIlegacyExtension;\ntypedef struct __DRIswrastExtensionRec\t\t__DRIswrastExtension;\ntypedef struct __DRIbufferRec\t\t\t__DRIbuffer;\ntypedef struct __DRIdri2ExtensionRec\t\t__DRIdri2Extension;\ntypedef struct __DRIdri2LoaderExtensionRec\t__DRIdri2LoaderExtension;\ntypedef struct __DRI2flushExtensionRec\t__DRI2flushExtension;\ntypedef struct __DRI2throttleExtensionRec\t__DRI2throttleExtension;\ntypedef struct __DRI2fenceExtensionRec          __DRI2fenceExtension;\ntypedef struct __DRI2interopExtensionRec\t__DRI2interopExtension;\ntypedef struct __DRI2blobExtensionRec           __DRI2blobExtension;\ntypedef struct __DRI2bufferDamageExtensionRec   __DRI2bufferDamageExtension;\n\ntypedef struct __DRIimageLoaderExtensionRec     __DRIimageLoaderExtension;\ntypedef struct __DRIimageDriverExtensionRec     __DRIimageDriverExtension;\n\n/*@}*/\n\n\n/**\n * Extension struct.  Drivers 'inherit' from this struct by embedding\n * it as the first element in the extension struct.\n *\n * We never break API in for a DRI extension.  If we need to change\n * the way things work in a non-backwards compatible manner, we\n * introduce a new extension.  During a transition period, we can\n * leave both the old and the new extension in the driver, which\n * allows us to move to the new interface without having to update the\n * loader(s) in lock step.\n *\n * However, we can add entry points to an extension over time as long\n * as we don't break the old ones.  As we add entry points to an\n * extension, we increase the version number.  The corresponding\n * #define can be used to guard code that accesses the new entry\n * points at compile time and the version field in the extension\n * struct can be used at run-time to determine how to use the\n * extension.\n */\nstruct __DRIextensionRec {\n    const char *name;\n    int version;\n};\n\n/**\n * The first set of extension are the screen extensions, returned by\n * __DRIcore::getExtensions().  This entry point will return a list of\n * extensions and the loader can use the ones it knows about by\n * casting them to more specific extensions and advertising any GLX\n * extensions the DRI extensions enables.\n */\n\n/**\n * Used by drivers to indicate support for setting the read drawable.\n */\n#define __DRI_READ_DRAWABLE \"DRI_ReadDrawable\"\n#define __DRI_READ_DRAWABLE_VERSION 1\n\n/**\n * Used by drivers that implement the GLX_MESA_copy_sub_buffer extension.\n */\n#define __DRI_COPY_SUB_BUFFER \"DRI_CopySubBuffer\"\n#define __DRI_COPY_SUB_BUFFER_VERSION 1\nstruct __DRIcopySubBufferExtensionRec {\n    __DRIextension base;\n    void (*copySubBuffer)(__DRIdrawable *drawable, int x, int y, int w, int h);\n};\n\n/**\n * Used by drivers that implement the GLX_SGI_swap_control or\n * GLX_MESA_swap_control extension.\n */\n#define __DRI_SWAP_CONTROL \"DRI_SwapControl\"\n#define __DRI_SWAP_CONTROL_VERSION 1\nstruct __DRIswapControlExtensionRec {\n    __DRIextension base;\n    void (*setSwapInterval)(__DRIdrawable *drawable, unsigned int inteval);\n    unsigned int (*getSwapInterval)(__DRIdrawable *drawable);\n};\n\n/**\n * Used by drivers that implement the GLX_MESA_swap_frame_usage extension.\n */\n#define __DRI_FRAME_TRACKING \"DRI_FrameTracking\"\n#define __DRI_FRAME_TRACKING_VERSION 1\nstruct __DRIframeTrackingExtensionRec {\n    __DRIextension base;\n\n    /**\n     * Enable or disable frame usage tracking.\n     * \n     * \\since Internal API version 20030317.\n     */\n    int (*frameTracking)(__DRIdrawable *drawable, GLboolean enable);\n\n    /**\n     * Retrieve frame usage information.\n     * \n     * \\since Internal API version 20030317.\n     */\n    int (*queryFrameTracking)(__DRIdrawable *drawable,\n\t\t\t      int64_t * sbc, int64_t * missedFrames,\n\t\t\t      float * lastMissedUsage, float * usage);\n};\n\n\n/**\n * Used by drivers that implement the GLX_SGI_video_sync extension.\n */\n#define __DRI_MEDIA_STREAM_COUNTER \"DRI_MediaStreamCounter\"\n#define __DRI_MEDIA_STREAM_COUNTER_VERSION 1\nstruct __DRImediaStreamCounterExtensionRec {\n    __DRIextension base;\n\n    /**\n     * Wait for the MSC to equal target_msc, or, if that has already passed,\n     * the next time (MSC % divisor) is equal to remainder.  If divisor is\n     * zero, the function will return as soon as MSC is greater than or equal\n     * to target_msc.\n     */\n    int (*waitForMSC)(__DRIdrawable *drawable,\n\t\t      int64_t target_msc, int64_t divisor, int64_t remainder,\n\t\t      int64_t * msc, int64_t * sbc);\n\n    /**\n     * Get the number of vertical refreshes since some point in time before\n     * this function was first called (i.e., system start up).\n     */\n    int (*getDrawableMSC)(__DRIscreen *screen, __DRIdrawable *drawable,\n\t\t\t  int64_t *msc);\n};\n\n\n#define __DRI_TEX_OFFSET \"DRI_TexOffset\"\n#define __DRI_TEX_OFFSET_VERSION 1\nstruct __DRItexOffsetExtensionRec {\n    __DRIextension base;\n\n    /**\n     * Method to override base texture image with a driver specific 'offset'.\n     * The depth passed in allows e.g. to ignore the alpha channel of texture\n     * images where the non-alpha components don't occupy a whole texel.\n     *\n     * For GLX_EXT_texture_from_pixmap with AIGLX.\n     */\n    void (*setTexOffset)(__DRIcontext *pDRICtx, GLint texname,\n\t\t\t unsigned long long offset, GLint depth, GLuint pitch);\n};\n\n\n/* Valid values for format in the setTexBuffer2 function below.  These\n * values match the GLX tokens for compatibility reasons, but we\n * define them here since the DRI interface can't depend on GLX. */\n#define __DRI_TEXTURE_FORMAT_NONE        0x20D8\n#define __DRI_TEXTURE_FORMAT_RGB         0x20D9\n#define __DRI_TEXTURE_FORMAT_RGBA        0x20DA\n\n#define __DRI_TEX_BUFFER \"DRI_TexBuffer\"\n#define __DRI_TEX_BUFFER_VERSION 3\nstruct __DRItexBufferExtensionRec {\n    __DRIextension base;\n\n    /**\n     * Method to override base texture image with the contents of a\n     * __DRIdrawable. \n     *\n     * For GLX_EXT_texture_from_pixmap with AIGLX.  Deprecated in favor of\n     * setTexBuffer2 in version 2 of this interface\n     */\n    void (*setTexBuffer)(__DRIcontext *pDRICtx,\n\t\t\t GLint target,\n\t\t\t __DRIdrawable *pDraw);\n\n    /**\n     * Method to override base texture image with the contents of a\n     * __DRIdrawable, including the required texture format attribute.\n     *\n     * For GLX_EXT_texture_from_pixmap with AIGLX.\n     *\n     * \\since 2\n     */\n    void (*setTexBuffer2)(__DRIcontext *pDRICtx,\n\t\t\t  GLint target,\n\t\t\t  GLint format,\n\t\t\t  __DRIdrawable *pDraw);\n    /**\n     * Method to release texture buffer in case some special platform\n     * need this.\n     *\n     * For GLX_EXT_texture_from_pixmap with AIGLX.\n     *\n     * \\since 3\n     */\n    void (*releaseTexBuffer)(__DRIcontext *pDRICtx,\n\t\t\tGLint target,\n\t\t\t__DRIdrawable *pDraw);\n};\n\n/**\n * Used by drivers that implement DRI2\n */\n#define __DRI2_FLUSH \"DRI2_Flush\"\n#define __DRI2_FLUSH_VERSION 4\n\n#define __DRI2_FLUSH_DRAWABLE (1 << 0) /* the drawable should be flushed. */\n#define __DRI2_FLUSH_CONTEXT  (1 << 1) /* glFlush should be called */\n#define __DRI2_FLUSH_INVALIDATE_ANCILLARY (1 << 2)\n\nenum __DRI2throttleReason {\n   __DRI2_THROTTLE_SWAPBUFFER,\n   __DRI2_THROTTLE_COPYSUBBUFFER,\n   __DRI2_THROTTLE_FLUSHFRONT\n};\n\nstruct __DRI2flushExtensionRec {\n    __DRIextension base;\n    void (*flush)(__DRIdrawable *drawable);\n\n    /**\n     * Ask the driver to call getBuffers/getBuffersWithFormat before\n     * it starts rendering again.\n     *\n     * \\param drawable the drawable to invalidate\n     *\n     * \\since 3\n     */\n    void (*invalidate)(__DRIdrawable *drawable);\n\n    /**\n     * This function reduces the number of flushes in the driver by combining\n     * several operations into one call.\n     *\n     * It can:\n     * - throttle\n     * - flush a drawable\n     * - flush a context\n     *\n     * \\param context           the context\n     * \\param drawable          the drawable to flush\n     * \\param flags             a combination of _DRI2_FLUSH_xxx flags\n     * \\param throttle_reason   the reason for throttling, 0 = no throttling\n     *\n     * \\since 4\n     */\n    void (*flush_with_flags)(__DRIcontext *ctx,\n                             __DRIdrawable *drawable,\n                             unsigned flags,\n                             enum __DRI2throttleReason throttle_reason);\n};\n\n\n/**\n * Extension that the driver uses to request\n * throttle callbacks.\n */\n\n#define __DRI2_THROTTLE \"DRI2_Throttle\"\n#define __DRI2_THROTTLE_VERSION 1\n\nstruct __DRI2throttleExtensionRec {\n   __DRIextension base;\n   void (*throttle)(__DRIcontext *ctx,\n\t\t    __DRIdrawable *drawable,\n\t\t    enum __DRI2throttleReason reason);\n};\n\n/**\n * Extension for EGL_ANDROID_blob_cache\n */\n\n#define __DRI2_BLOB \"DRI2_Blob\"\n#define __DRI2_BLOB_VERSION 1\n\ntypedef void\n(*__DRIblobCacheSet) (const void *key, signed long keySize,\n                      const void *value, signed long valueSize);\n\ntypedef signed long\n(*__DRIblobCacheGet) (const void *key, signed long keySize,\n                      void *value, signed long valueSize);\n\nstruct __DRI2blobExtensionRec {\n   __DRIextension base;\n\n   /**\n    * Set cache functions for setting and getting cache entries.\n    */\n   void (*set_cache_funcs) (__DRIscreen *screen,\n                            __DRIblobCacheSet set, __DRIblobCacheGet get);\n};\n\n/**\n * Extension for fences / synchronization objects.\n */\n\n#define __DRI2_FENCE \"DRI2_Fence\"\n#define __DRI2_FENCE_VERSION 2\n\n#define __DRI2_FENCE_TIMEOUT_INFINITE     0xffffffffffffffffull\n\n#define __DRI2_FENCE_FLAG_FLUSH_COMMANDS  (1 << 0)\n\n/**\n * \\name Capabilities that might be returned by __DRI2fenceExtensionRec::get_capabilities\n */\n/*@{*/\n#define __DRI_FENCE_CAP_NATIVE_FD 1\n/*@}*/\n\nstruct __DRI2fenceExtensionRec {\n   __DRIextension base;\n\n   /**\n    * Create and insert a fence into the command stream of the context.\n    */\n   void *(*create_fence)(__DRIcontext *ctx);\n\n   /**\n    * Get a fence associated with the OpenCL event object.\n    * This can be NULL, meaning that OpenCL interoperability is not supported.\n    */\n   void *(*get_fence_from_cl_event)(__DRIscreen *screen, intptr_t cl_event);\n\n   /**\n    * Destroy a fence.\n    */\n   void (*destroy_fence)(__DRIscreen *screen, void *fence);\n\n   /**\n    * This function waits and doesn't return until the fence is signalled\n    * or the timeout expires. It returns true if the fence has been signaled.\n    *\n    * \\param ctx     the context where commands are flushed\n    * \\param fence   the fence\n    * \\param flags   a combination of __DRI2_FENCE_FLAG_xxx flags\n    * \\param timeout the timeout in ns or __DRI2_FENCE_TIMEOUT_INFINITE\n    */\n   GLboolean (*client_wait_sync)(__DRIcontext *ctx, void *fence,\n                                 unsigned flags, uint64_t timeout);\n\n   /**\n    * This function enqueues a wait command into the command stream of\n    * the context and then returns. When the execution reaches the wait\n    * command, no further execution will be done in the context until\n    * the fence is signaled. This is a no-op if the device doesn't support\n    * parallel execution of contexts.\n    *\n    * \\param ctx     the context where the waiting is done\n    * \\param fence   the fence\n    * \\param flags   a combination of __DRI2_FENCE_FLAG_xxx flags that make\n    *                sense with this function (right now there are none)\n    */\n   void (*server_wait_sync)(__DRIcontext *ctx, void *fence, unsigned flags);\n\n   /**\n    * Query for general capabilities of the driver that concern fences.\n    * Returns a bitmask of __DRI_FENCE_CAP_x\n    *\n    * \\since 2\n    */\n   unsigned (*get_capabilities)(__DRIscreen *screen);\n\n   /**\n    * Create an fd (file descriptor) associated fence.  If the fence fd\n    * is -1, this behaves similarly to create_fence() except that when\n    * rendering is flushed the driver creates a fence fd.  Otherwise,\n    * the driver wraps an existing fence fd.\n    *\n    * This is used to implement the EGL_ANDROID_native_fence_sync extension.\n    *\n    * \\since 2\n    *\n    * \\param ctx     the context associated with the fence\n    * \\param fd      the fence fd or -1\n    */\n   void *(*create_fence_fd)(__DRIcontext *ctx, int fd);\n\n   /**\n    * For fences created with create_fence_fd(), after rendering is flushed,\n    * this retrieves the native fence fd.  Caller takes ownership of the\n    * fd and will close() it when it is no longer needed.\n    *\n    * \\since 2\n    *\n    * \\param screen  the screen associated with the fence\n    * \\param fence   the fence\n    */\n   int (*get_fence_fd)(__DRIscreen *screen, void *fence);\n};\n\n\n/**\n * Extension for API interop.\n * See GL/mesa_glinterop.h.\n */\n\n#define __DRI2_INTEROP \"DRI2_Interop\"\n#define __DRI2_INTEROP_VERSION 1\n\nstruct mesa_glinterop_device_info;\nstruct mesa_glinterop_export_in;\nstruct mesa_glinterop_export_out;\n\nstruct __DRI2interopExtensionRec {\n   __DRIextension base;\n\n   /** Same as MesaGLInterop*QueryDeviceInfo. */\n   int (*query_device_info)(__DRIcontext *ctx,\n                            struct mesa_glinterop_device_info *out);\n\n   /** Same as MesaGLInterop*ExportObject. */\n   int (*export_object)(__DRIcontext *ctx,\n                        struct mesa_glinterop_export_in *in,\n                        struct mesa_glinterop_export_out *out);\n};\n\n\n/**\n * Extension for limiting window system back buffer rendering to user-defined\n * scissor region.\n */\n\n#define __DRI2_BUFFER_DAMAGE \"DRI2_BufferDamage\"\n#define __DRI2_BUFFER_DAMAGE_VERSION 1\n\nstruct __DRI2bufferDamageExtensionRec {\n   __DRIextension base;\n\n   /**\n    * Provides an array of rectangles representing an overriding scissor region\n    * for rendering operations performed to the specified drawable. These\n    * rectangles do not replace client API scissor regions or draw\n    * co-ordinates, but instead inform the driver of the overall bounds of all\n    * operations which will be issued before the next flush.\n    *\n    * Any rendering operations writing pixels outside this region to the\n    * drawable will have an undefined effect on the entire drawable.\n    *\n    * This entrypoint may only be called after the drawable has either been\n    * newly created or flushed, and before any rendering operations which write\n    * pixels to the drawable. Calling this entrypoint at any other time will\n    * have an undefined effect on the entire drawable.\n    *\n    * Calling this entrypoint with @nrects 0 and @rects NULL will reset the\n    * region to the buffer's full size. This entrypoint may be called once to\n    * reset the region, followed by a second call with a populated region,\n    * before a rendering call is made.\n    *\n    * Used to implement EGL_KHR_partial_update.\n    *\n    * \\param drawable affected drawable\n    * \\param nrects   number of rectangles provided\n    * \\param rects    the array of rectangles, lower-left origin\n    */\n   void (*set_damage_region)(__DRIdrawable *drawable, unsigned int nrects,\n                             int *rects);\n};\n\n/*@}*/\n\n/**\n * The following extensions describe loader features that the DRI\n * driver can make use of.  Some of these are mandatory, such as the\n * getDrawableInfo extension for DRI and the DRI Loader extensions for\n * DRI2, while others are optional, and if present allow the driver to\n * expose certain features.  The loader pass in a NULL terminated\n * array of these extensions to the driver in the createNewScreen\n * constructor.\n */\n\ntypedef struct __DRIgetDrawableInfoExtensionRec __DRIgetDrawableInfoExtension;\ntypedef struct __DRIsystemTimeExtensionRec __DRIsystemTimeExtension;\ntypedef struct __DRIdamageExtensionRec __DRIdamageExtension;\ntypedef struct __DRIloaderExtensionRec __DRIloaderExtension;\ntypedef struct __DRIswrastLoaderExtensionRec __DRIswrastLoaderExtension;\n\n\n/**\n * Callback to getDrawableInfo protocol\n */\n#define __DRI_GET_DRAWABLE_INFO \"DRI_GetDrawableInfo\"\n#define __DRI_GET_DRAWABLE_INFO_VERSION 1\nstruct __DRIgetDrawableInfoExtensionRec {\n    __DRIextension base;\n\n    /**\n     * This function is used to get information about the position, size, and\n     * clip rects of a drawable.\n     */\n    GLboolean (* getDrawableInfo) ( __DRIdrawable *drawable,\n\tunsigned int * index, unsigned int * stamp,\n        int * x, int * y, int * width, int * height,\n        int * numClipRects, drm_clip_rect_t ** pClipRects,\n        int * backX, int * backY,\n\tint * numBackClipRects, drm_clip_rect_t ** pBackClipRects,\n\tvoid *loaderPrivate);\n};\n\n/**\n * Callback to get system time for media stream counter extensions.\n */\n#define __DRI_SYSTEM_TIME \"DRI_SystemTime\"\n#define __DRI_SYSTEM_TIME_VERSION 1\nstruct __DRIsystemTimeExtensionRec {\n    __DRIextension base;\n\n    /**\n     * Get the 64-bit unadjusted system time (UST).\n     */\n    int (*getUST)(int64_t * ust);\n\n    /**\n     * Get the media stream counter (MSC) rate.\n     * \n     * Matching the definition in GLX_OML_sync_control, this function returns\n     * the rate of the \"media stream counter\".  In practical terms, this is\n     * the frame refresh rate of the display.\n     */\n    GLboolean (*getMSCRate)(__DRIdrawable *draw,\n\t\t\t    int32_t * numerator, int32_t * denominator,\n\t\t\t    void *loaderPrivate);\n};\n\n/**\n * Damage reporting\n */\n#define __DRI_DAMAGE \"DRI_Damage\"\n#define __DRI_DAMAGE_VERSION 1\nstruct __DRIdamageExtensionRec {\n    __DRIextension base;\n\n    /**\n     * Reports areas of the given drawable which have been modified by the\n     * driver.\n     *\n     * \\param drawable which the drawing was done to.\n     * \\param rects rectangles affected, with the drawable origin as the\n     *\t      origin.\n     * \\param x X offset of the drawable within the screen (used in the\n     *\t      front_buffer case)\n     * \\param y Y offset of the drawable within the screen.\n     * \\param front_buffer boolean flag for whether the drawing to the\n     * \t      drawable was actually done directly to the front buffer (instead\n     *\t      of backing storage, for example)\n     * \\param loaderPrivate the data passed in at createNewDrawable time\n     */\n    void (*reportDamage)(__DRIdrawable *draw,\n\t\t\t int x, int y,\n\t\t\t drm_clip_rect_t *rects, int num_rects,\n\t\t\t GLboolean front_buffer,\n\t\t\t void *loaderPrivate);\n};\n\n#define __DRI_SWRAST_IMAGE_OP_DRAW\t1\n#define __DRI_SWRAST_IMAGE_OP_CLEAR\t2\n#define __DRI_SWRAST_IMAGE_OP_SWAP\t3\n\n/**\n * SWRast Loader extension.\n */\n#define __DRI_SWRAST_LOADER \"DRI_SWRastLoader\"\n#define __DRI_SWRAST_LOADER_VERSION 6\nstruct __DRIswrastLoaderExtensionRec {\n    __DRIextension base;\n\n    /*\n     * Drawable position and size\n     */\n    void (*getDrawableInfo)(__DRIdrawable *drawable,\n\t\t\t    int *x, int *y, int *width, int *height,\n\t\t\t    void *loaderPrivate);\n\n    /**\n     * Put image to drawable\n     */\n    void (*putImage)(__DRIdrawable *drawable, int op,\n\t\t     int x, int y, int width, int height,\n\t\t     char *data, void *loaderPrivate);\n\n    /**\n     * Get image from readable\n     */\n    void (*getImage)(__DRIdrawable *readable,\n\t\t     int x, int y, int width, int height,\n\t\t     char *data, void *loaderPrivate);\n\n    /**\n     * Put image to drawable\n     *\n     * \\since 2\n     */\n    void (*putImage2)(__DRIdrawable *drawable, int op,\n                      int x, int y, int width, int height, int stride,\n                      char *data, void *loaderPrivate);\n\n   /**\n     * Put image to drawable\n     *\n     * \\since 3\n     */\n   void (*getImage2)(__DRIdrawable *readable,\n\t\t     int x, int y, int width, int height, int stride,\n\t\t     char *data, void *loaderPrivate);\n\n    /**\n     * Put shm image to drawable\n     *\n     * \\since 4\n     */\n    void (*putImageShm)(__DRIdrawable *drawable, int op,\n                        int x, int y, int width, int height, int stride,\n                        int shmid, char *shmaddr, unsigned offset,\n                        void *loaderPrivate);\n    /**\n     * Get shm image from readable\n     *\n     * \\since 4\n     */\n    void (*getImageShm)(__DRIdrawable *readable,\n                        int x, int y, int width, int height,\n                        int shmid, void *loaderPrivate);\n\n   /**\n     * Put shm image to drawable (v2)\n     *\n     * The original version fixes srcx/y to 0, and expected\n     * the offset to be adjusted. This version allows src x,y\n     * to not be included in the offset. This is needed to\n     * avoid certain overflow checks in the X server, that\n     * result in lost rendering.\n     *\n     * \\since 5\n     */\n    void (*putImageShm2)(__DRIdrawable *drawable, int op,\n                         int x, int y,\n                         int width, int height, int stride,\n                         int shmid, char *shmaddr, unsigned offset,\n                         void *loaderPrivate);\n\n    /**\n     * get shm image to drawable (v2)\n     *\n     * There are some cases where GLX can't use SHM, but DRI\n     * still tries, we need to get a return type for when to\n     * fallback to the non-shm path.\n     *\n     * \\since 6\n     */\n    GLboolean (*getImageShm2)(__DRIdrawable *readable,\n                              int x, int y, int width, int height,\n                              int shmid, void *loaderPrivate);\n};\n\n/**\n * Invalidate loader extension.  The presence of this extension\n * indicates to the DRI driver that the loader will call invalidate in\n * the __DRI2_FLUSH extension, whenever the needs to query for new\n * buffers.  This means that the DRI driver can drop the polling in\n * glViewport().\n *\n * The extension doesn't provide any functionality, it's only use to\n * indicate to the driver that it can use the new semantics.  A DRI\n * driver can use this to switch between the different semantics or\n * just refuse to initialize if this extension isn't present.\n */\n#define __DRI_USE_INVALIDATE \"DRI_UseInvalidate\"\n#define __DRI_USE_INVALIDATE_VERSION 1\n\ntypedef struct __DRIuseInvalidateExtensionRec __DRIuseInvalidateExtension;\nstruct __DRIuseInvalidateExtensionRec {\n   __DRIextension base;\n};\n\n/**\n * The remaining extensions describe driver extensions, immediately\n * available interfaces provided by the driver.  To start using the\n * driver, dlsym() for the __DRI_DRIVER_EXTENSIONS symbol and look for\n * the extension you need in the array.\n */\n#define __DRI_DRIVER_EXTENSIONS \"__driDriverExtensions\"\n\n/**\n * This symbol replaces the __DRI_DRIVER_EXTENSIONS symbol, and will be\n * suffixed by \"_drivername\", allowing multiple drivers to be built into one\n * library, and also giving the driver the chance to return a variable driver\n * extensions struct depending on the driver name being loaded or any other\n * system state.\n *\n * The function prototype is:\n *\n * const __DRIextension **__driDriverGetExtensions_drivername(void);\n */\n#define __DRI_DRIVER_GET_EXTENSIONS \"__driDriverGetExtensions\"\n\n/**\n * Tokens for __DRIconfig attribs.  A number of attributes defined by\n * GLX or EGL standards are not in the table, as they must be provided\n * by the loader.  For example, FBConfig ID or visual ID, drawable type.\n */\n\n#define __DRI_ATTRIB_BUFFER_SIZE\t\t 1\n#define __DRI_ATTRIB_LEVEL\t\t\t 2\n#define __DRI_ATTRIB_RED_SIZE\t\t\t 3\n#define __DRI_ATTRIB_GREEN_SIZE\t\t\t 4\n#define __DRI_ATTRIB_BLUE_SIZE\t\t\t 5\n#define __DRI_ATTRIB_LUMINANCE_SIZE\t\t 6\n#define __DRI_ATTRIB_ALPHA_SIZE\t\t\t 7\n#define __DRI_ATTRIB_ALPHA_MASK_SIZE\t\t 8\n#define __DRI_ATTRIB_DEPTH_SIZE\t\t\t 9\n#define __DRI_ATTRIB_STENCIL_SIZE\t\t10\n#define __DRI_ATTRIB_ACCUM_RED_SIZE\t\t11\n#define __DRI_ATTRIB_ACCUM_GREEN_SIZE\t\t12\n#define __DRI_ATTRIB_ACCUM_BLUE_SIZE\t\t13\n#define __DRI_ATTRIB_ACCUM_ALPHA_SIZE\t\t14\n#define __DRI_ATTRIB_SAMPLE_BUFFERS\t\t15\n#define __DRI_ATTRIB_SAMPLES\t\t\t16\n#define __DRI_ATTRIB_RENDER_TYPE\t\t17\n#define __DRI_ATTRIB_CONFIG_CAVEAT\t\t18\n#define __DRI_ATTRIB_CONFORMANT\t\t\t19\n#define __DRI_ATTRIB_DOUBLE_BUFFER\t\t20\n#define __DRI_ATTRIB_STEREO\t\t\t21\n#define __DRI_ATTRIB_AUX_BUFFERS\t\t22\n#define __DRI_ATTRIB_TRANSPARENT_TYPE\t\t23\n#define __DRI_ATTRIB_TRANSPARENT_INDEX_VALUE\t24\n#define __DRI_ATTRIB_TRANSPARENT_RED_VALUE\t25\n#define __DRI_ATTRIB_TRANSPARENT_GREEN_VALUE\t26\n#define __DRI_ATTRIB_TRANSPARENT_BLUE_VALUE\t27\n#define __DRI_ATTRIB_TRANSPARENT_ALPHA_VALUE\t28\n#define __DRI_ATTRIB_FLOAT_MODE\t\t\t29\n#define __DRI_ATTRIB_RED_MASK\t\t\t30\n#define __DRI_ATTRIB_GREEN_MASK\t\t\t31\n#define __DRI_ATTRIB_BLUE_MASK\t\t\t32\n#define __DRI_ATTRIB_ALPHA_MASK\t\t\t33\n#define __DRI_ATTRIB_MAX_PBUFFER_WIDTH\t\t34\n#define __DRI_ATTRIB_MAX_PBUFFER_HEIGHT\t\t35\n#define __DRI_ATTRIB_MAX_PBUFFER_PIXELS\t\t36\n#define __DRI_ATTRIB_OPTIMAL_PBUFFER_WIDTH\t37\n#define __DRI_ATTRIB_OPTIMAL_PBUFFER_HEIGHT\t38\n#define __DRI_ATTRIB_VISUAL_SELECT_GROUP\t39\n#define __DRI_ATTRIB_SWAP_METHOD\t\t40\n#define __DRI_ATTRIB_MAX_SWAP_INTERVAL\t\t41\n#define __DRI_ATTRIB_MIN_SWAP_INTERVAL\t\t42\n#define __DRI_ATTRIB_BIND_TO_TEXTURE_RGB\t43\n#define __DRI_ATTRIB_BIND_TO_TEXTURE_RGBA\t44\n#define __DRI_ATTRIB_BIND_TO_MIPMAP_TEXTURE\t45\n#define __DRI_ATTRIB_BIND_TO_TEXTURE_TARGETS\t46\n#define __DRI_ATTRIB_YINVERTED\t\t\t47\n#define __DRI_ATTRIB_FRAMEBUFFER_SRGB_CAPABLE\t48\n#define __DRI_ATTRIB_MUTABLE_RENDER_BUFFER\t49 /* EGL_MUTABLE_RENDER_BUFFER_BIT_KHR */\n#define __DRI_ATTRIB_RED_SHIFT\t\t\t50\n#define __DRI_ATTRIB_GREEN_SHIFT\t\t51\n#define __DRI_ATTRIB_BLUE_SHIFT\t\t\t52\n#define __DRI_ATTRIB_ALPHA_SHIFT\t\t53\n#define __DRI_ATTRIB_MAX\t\t\t54\n\n/* __DRI_ATTRIB_RENDER_TYPE */\n#define __DRI_ATTRIB_RGBA_BIT\t\t\t0x01\t\n#define __DRI_ATTRIB_COLOR_INDEX_BIT\t\t0x02\n#define __DRI_ATTRIB_LUMINANCE_BIT\t\t0x04\n#define __DRI_ATTRIB_FLOAT_BIT\t\t\t0x08\n#define __DRI_ATTRIB_UNSIGNED_FLOAT_BIT\t\t0x10\n\n/* __DRI_ATTRIB_CONFIG_CAVEAT */\n#define __DRI_ATTRIB_SLOW_BIT\t\t\t0x01\n#define __DRI_ATTRIB_NON_CONFORMANT_CONFIG\t0x02\n\n/* __DRI_ATTRIB_TRANSPARENT_TYPE */\n#define __DRI_ATTRIB_TRANSPARENT_RGB\t\t0x00\n#define __DRI_ATTRIB_TRANSPARENT_INDEX\t\t0x01\n\n/* __DRI_ATTRIB_BIND_TO_TEXTURE_TARGETS\t */\n#define __DRI_ATTRIB_TEXTURE_1D_BIT\t\t0x01\n#define __DRI_ATTRIB_TEXTURE_2D_BIT\t\t0x02\n#define __DRI_ATTRIB_TEXTURE_RECTANGLE_BIT\t0x04\n\n/* __DRI_ATTRIB_SWAP_METHOD */\n/* Note that with the exception of __DRI_ATTRIB_SWAP_NONE, we need to define\n * the same tokens as GLX. This is because old and current X servers will\n * transmit the driconf value grabbed from the AIGLX driver untranslated as\n * the GLX fbconfig value. __DRI_ATTRIB_SWAP_NONE is only used by dri drivers\n * to signal to the dri core that the driconfig is single-buffer.\n */\n#define __DRI_ATTRIB_SWAP_NONE                  0x0000\n#define __DRI_ATTRIB_SWAP_EXCHANGE              0x8061\n#define __DRI_ATTRIB_SWAP_COPY                  0x8062\n#define __DRI_ATTRIB_SWAP_UNDEFINED             0x8063\n\n/**\n * This extension defines the core DRI functionality.\n *\n * Version >= 2 indicates that getConfigAttrib with __DRI_ATTRIB_SWAP_METHOD\n * returns a reliable value.\n */\n#define __DRI_CORE \"DRI_Core\"\n#define __DRI_CORE_VERSION 2\n\nstruct __DRIcoreExtensionRec {\n    __DRIextension base;\n\n    __DRIscreen *(*createNewScreen)(int screen, int fd,\n\t\t\t\t    unsigned int sarea_handle,\n\t\t\t\t    const __DRIextension **extensions,\n\t\t\t\t    const __DRIconfig ***driverConfigs,\n\t\t\t\t    void *loaderPrivate);\n\n    void (*destroyScreen)(__DRIscreen *screen);\n\n    const __DRIextension **(*getExtensions)(__DRIscreen *screen);\n\n    int (*getConfigAttrib)(const __DRIconfig *config,\n\t\t\t   unsigned int attrib,\n\t\t\t   unsigned int *value);\n\n    int (*indexConfigAttrib)(const __DRIconfig *config, int index,\n\t\t\t     unsigned int *attrib, unsigned int *value);\n\n    __DRIdrawable *(*createNewDrawable)(__DRIscreen *screen,\n\t\t\t\t\tconst __DRIconfig *config,\n\t\t\t\t\tunsigned int drawable_id,\n\t\t\t\t\tunsigned int head,\n\t\t\t\t\tvoid *loaderPrivate);\n\n    void (*destroyDrawable)(__DRIdrawable *drawable);\n\n    void (*swapBuffers)(__DRIdrawable *drawable);\n\n    __DRIcontext *(*createNewContext)(__DRIscreen *screen,\n\t\t\t\t      const __DRIconfig *config,\n\t\t\t\t      __DRIcontext *shared,\n\t\t\t\t      void *loaderPrivate);\n\n    int (*copyContext)(__DRIcontext *dest,\n\t\t       __DRIcontext *src,\n\t\t       unsigned long mask);\n\n    void (*destroyContext)(__DRIcontext *context);\n\n    int (*bindContext)(__DRIcontext *ctx,\n\t\t       __DRIdrawable *pdraw,\n\t\t       __DRIdrawable *pread);\n\n    int (*unbindContext)(__DRIcontext *ctx);\n};\n\n/**\n * Stored version of some component (i.e., server-side DRI module, kernel-side\n * DRM, etc.).\n * \n * \\todo\n * There are several data structures that explicitly store a major version,\n * minor version, and patch level.  These structures should be modified to\n * have a \\c __DRIversionRec instead.\n */\nstruct __DRIversionRec {\n    int    major;        /**< Major version number. */\n    int    minor;        /**< Minor version number. */\n    int    patch;        /**< Patch-level. */\n};\n\n/**\n * Framebuffer information record.  Used by libGL to communicate information\n * about the framebuffer to the driver's \\c __driCreateNewScreen function.\n * \n * In XFree86, most of this information is derrived from data returned by\n * calling \\c XF86DRIGetDeviceInfo.\n *\n * \\sa XF86DRIGetDeviceInfo __DRIdisplayRec::createNewScreen\n *     __driUtilCreateNewScreen CallCreateNewScreen\n *\n * \\bug This structure could be better named.\n */\nstruct __DRIframebufferRec {\n    unsigned char *base;    /**< Framebuffer base address in the CPU's\n\t\t\t     * address space.  This value is calculated by\n\t\t\t     * calling \\c drmMap on the framebuffer handle\n\t\t\t     * returned by \\c XF86DRIGetDeviceInfo (or a\n\t\t\t     * similar function).\n\t\t\t     */\n    int size;               /**< Framebuffer size, in bytes. */\n    int stride;             /**< Number of bytes from one line to the next. */\n    int width;              /**< Pixel width of the framebuffer. */\n    int height;             /**< Pixel height of the framebuffer. */\n    int dev_priv_size;      /**< Size of the driver's dev-priv structure. */\n    void *dev_priv;         /**< Pointer to the driver's dev-priv structure. */\n};\n\n\n/**\n * This extension provides alternative screen, drawable and context\n * constructors for legacy DRI functionality.  This is used in\n * conjunction with the core extension.\n */\n#define __DRI_LEGACY \"DRI_Legacy\"\n#define __DRI_LEGACY_VERSION 1\n\nstruct __DRIlegacyExtensionRec {\n    __DRIextension base;\n\n    __DRIscreen *(*createNewScreen)(int screen,\n\t\t\t\t    const __DRIversion *ddx_version,\n\t\t\t\t    const __DRIversion *dri_version,\n\t\t\t\t    const __DRIversion *drm_version,\n\t\t\t\t    const __DRIframebuffer *frame_buffer,\n\t\t\t\t    void *pSAREA, int fd, \n\t\t\t\t    const __DRIextension **extensions,\n\t\t\t\t    const __DRIconfig ***driver_configs,\n\t\t\t\t    void *loaderPrivate);\n\n    __DRIdrawable *(*createNewDrawable)(__DRIscreen *screen,\n\t\t\t\t\tconst __DRIconfig *config,\n\t\t\t\t\tdrm_drawable_t hwDrawable,\n\t\t\t\t\tint renderType, const int *attrs,\n\t\t\t\t\tvoid *loaderPrivate);\n\n    __DRIcontext *(*createNewContext)(__DRIscreen *screen,\n\t\t\t\t      const __DRIconfig *config,\n\t\t\t\t      int render_type,\n\t\t\t\t      __DRIcontext *shared,\n\t\t\t\t      drm_context_t hwContext,\n\t\t\t\t      void *loaderPrivate);\n};\n\n/**\n * This extension provides alternative screen, drawable and context\n * constructors for swrast DRI functionality.  This is used in\n * conjunction with the core extension.\n */\n#define __DRI_SWRAST \"DRI_SWRast\"\n#define __DRI_SWRAST_VERSION 4\n\nstruct __DRIswrastExtensionRec {\n    __DRIextension base;\n\n    __DRIscreen *(*createNewScreen)(int screen,\n\t\t\t\t    const __DRIextension **extensions,\n\t\t\t\t    const __DRIconfig ***driver_configs,\n\t\t\t\t    void *loaderPrivate);\n\n    __DRIdrawable *(*createNewDrawable)(__DRIscreen *screen,\n\t\t\t\t\tconst __DRIconfig *config,\n\t\t\t\t\tvoid *loaderPrivate);\n\n   /* Since version 2 */\n   __DRIcontext *(*createNewContextForAPI)(__DRIscreen *screen,\n                                           int api,\n                                           const __DRIconfig *config,\n                                           __DRIcontext *shared,\n                                           void *data);\n\n   /**\n    * Create a context for a particular API with a set of attributes\n    *\n    * \\since version 3\n    *\n    * \\sa __DRIdri2ExtensionRec::createContextAttribs\n    */\n   __DRIcontext *(*createContextAttribs)(__DRIscreen *screen,\n\t\t\t\t\t int api,\n\t\t\t\t\t const __DRIconfig *config,\n\t\t\t\t\t __DRIcontext *shared,\n\t\t\t\t\t unsigned num_attribs,\n\t\t\t\t\t const uint32_t *attribs,\n\t\t\t\t\t unsigned *error,\n\t\t\t\t\t void *loaderPrivate);\n\n   /**\n    * createNewScreen() with the driver extensions passed in.\n    *\n    * \\since version 4\n    */\n   __DRIscreen *(*createNewScreen2)(int screen,\n                                    const __DRIextension **loader_extensions,\n                                    const __DRIextension **driver_extensions,\n                                    const __DRIconfig ***driver_configs,\n                                    void *loaderPrivate);\n\n};\n\n/** Common DRI function definitions, shared among DRI2 and Image extensions\n */\n\ntypedef __DRIscreen *\n(*__DRIcreateNewScreen2Func)(int screen, int fd,\n                             const __DRIextension **extensions,\n                             const __DRIextension **driver_extensions,\n                             const __DRIconfig ***driver_configs,\n                             void *loaderPrivate);\n\ntypedef __DRIdrawable *\n(*__DRIcreateNewDrawableFunc)(__DRIscreen *screen,\n                              const __DRIconfig *config,\n                              void *loaderPrivate);\n\ntypedef __DRIcontext *\n(*__DRIcreateContextAttribsFunc)(__DRIscreen *screen,\n                                 int api,\n                                 const __DRIconfig *config,\n                                 __DRIcontext *shared,\n                                 unsigned num_attribs,\n                                 const uint32_t *attribs,\n                                 unsigned *error,\n                                 void *loaderPrivate);\n\ntypedef unsigned int\n(*__DRIgetAPIMaskFunc)(__DRIscreen *screen);\n\n/**\n * DRI2 Loader extension.\n */\n#define __DRI_BUFFER_FRONT_LEFT\t\t0\n#define __DRI_BUFFER_BACK_LEFT\t\t1\n#define __DRI_BUFFER_FRONT_RIGHT\t2\n#define __DRI_BUFFER_BACK_RIGHT\t\t3\n#define __DRI_BUFFER_DEPTH\t\t4\n#define __DRI_BUFFER_STENCIL\t\t5\n#define __DRI_BUFFER_ACCUM\t\t6\n#define __DRI_BUFFER_FAKE_FRONT_LEFT\t7\n#define __DRI_BUFFER_FAKE_FRONT_RIGHT\t8\n#define __DRI_BUFFER_DEPTH_STENCIL\t9  /**< Only available with DRI2 1.1 */\n#define __DRI_BUFFER_HIZ\t\t10\n\n/* Inofficial and for internal use. Increase when adding a new buffer token. */\n#define __DRI_BUFFER_COUNT\t\t11\n\nstruct __DRIbufferRec {\n    unsigned int attachment;\n    unsigned int name;\n    unsigned int pitch;\n    unsigned int cpp;\n    unsigned int flags;\n};\n\n#define __DRI_DRI2_LOADER \"DRI_DRI2Loader\"\n#define __DRI_DRI2_LOADER_VERSION 5\n\nenum dri_loader_cap {\n   /* Whether the loader handles RGBA channel ordering correctly. If not,\n    * only BGRA ordering can be exposed.\n    */\n   DRI_LOADER_CAP_RGBA_ORDERING,\n   DRI_LOADER_CAP_FP16,\n};\n\nstruct __DRIdri2LoaderExtensionRec {\n    __DRIextension base;\n\n    __DRIbuffer *(*getBuffers)(__DRIdrawable *driDrawable,\n\t\t\t       int *width, int *height,\n\t\t\t       unsigned int *attachments, int count,\n\t\t\t       int *out_count, void *loaderPrivate);\n\n    /**\n     * Flush pending front-buffer rendering\n     *\n     * Any rendering that has been performed to the\n     * \\c __DRI_BUFFER_FAKE_FRONT_LEFT will be flushed to the\n     * \\c __DRI_BUFFER_FRONT_LEFT.\n     *\n     * \\param driDrawable    Drawable whose front-buffer is to be flushed\n     * \\param loaderPrivate  Loader's private data that was previously passed\n     *                       into __DRIdri2ExtensionRec::createNewDrawable\n     *\n     * \\since 2\n     */\n    void (*flushFrontBuffer)(__DRIdrawable *driDrawable, void *loaderPrivate);\n\n\n    /**\n     * Get list of buffers from the server\n     *\n     * Gets a list of buffer for the specified set of attachments.  Unlike\n     * \\c ::getBuffers, this function takes a list of attachments paired with\n     * opaque \\c unsigned \\c int value describing the format of the buffer.\n     * It is the responsibility of the caller to know what the service that\n     * allocates the buffers will expect to receive for the format.\n     *\n     * \\param driDrawable    Drawable whose buffers are being queried.\n     * \\param width          Output where the width of the buffers is stored.\n     * \\param height         Output where the height of the buffers is stored.\n     * \\param attachments    List of pairs of attachment ID and opaque format\n     *                       requested for the drawable.\n     * \\param count          Number of attachment / format pairs stored in\n     *                       \\c attachments.\n     * \\param loaderPrivate  Loader's private data that was previously passed\n     *                       into __DRIdri2ExtensionRec::createNewDrawable.\n     *\n     * \\since 3\n     */\n    __DRIbuffer *(*getBuffersWithFormat)(__DRIdrawable *driDrawable,\n\t\t\t\t\t int *width, int *height,\n\t\t\t\t\t unsigned int *attachments, int count,\n\t\t\t\t\t int *out_count, void *loaderPrivate);\n\n    /**\n     * Return a loader capability value. If the loader doesn't know the enum,\n     * it will return 0.\n     *\n     * \\param loaderPrivate The last parameter of createNewScreen or\n     *                      createNewScreen2.\n     * \\param cap           See the enum.\n     *\n     * \\since 4\n     */\n    unsigned (*getCapability)(void *loaderPrivate, enum dri_loader_cap cap);\n\n    /**\n     * Clean up any loader state associated with an image.\n     *\n     * \\param loaderPrivate  Loader's private data that was previously passed\n     *                       into a __DRIimageExtensionRec::createImage function\n     * \\since 5\n     */\n    void (*destroyLoaderImageState)(void *loaderPrivate);\n};\n\n/**\n * This extension provides alternative screen, drawable and context\n * constructors for DRI2.\n */\n#define __DRI_DRI2 \"DRI_DRI2\"\n#define __DRI_DRI2_VERSION 4\n\n#define __DRI_API_OPENGL\t0\t/**< OpenGL compatibility profile */\n#define __DRI_API_GLES\t\t1\t/**< OpenGL ES 1.x */\n#define __DRI_API_GLES2\t\t2\t/**< OpenGL ES 2.x */\n#define __DRI_API_OPENGL_CORE\t3\t/**< OpenGL 3.2+ core profile */\n#define __DRI_API_GLES3\t\t4\t/**< OpenGL ES 3.x */\n\n#define __DRI_CTX_ATTRIB_MAJOR_VERSION\t\t0\n#define __DRI_CTX_ATTRIB_MINOR_VERSION\t\t1\n#define __DRI_CTX_ATTRIB_FLAGS\t\t\t2\n\n/**\n * \\requires __DRI2_ROBUSTNESS.\n */\n#define __DRI_CTX_ATTRIB_RESET_STRATEGY\t\t3\n\n#define __DRI_CTX_FLAG_DEBUG\t\t\t0x00000001\n#define __DRI_CTX_FLAG_FORWARD_COMPATIBLE\t0x00000002\n\n/**\n * \\requires __DRI2_ROBUSTNESS.\n */\n#define __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS\t0x00000004\n\n/**\n * \\requires __DRI2_NO_ERROR.\n *\n */\n#define __DRI_CTX_FLAG_NO_ERROR\t\t\t0x00000008\n\n/**\n * \\name Context reset strategies.\n */\n/*@{*/\n#define __DRI_CTX_RESET_NO_NOTIFICATION\t\t0\n#define __DRI_CTX_RESET_LOSE_CONTEXT\t\t1\n/*@}*/\n\n#define __DRI_CTX_ATTRIB_PRIORITY\t\t4\n\n#define __DRI_CTX_PRIORITY_LOW\t\t\t0\n#define __DRI_CTX_PRIORITY_MEDIUM\t\t1\n#define __DRI_CTX_PRIORITY_HIGH\t\t\t2\n\n/**\n * \\name Context release behaviors.\n */\n/*@{*/\n#define __DRI_CTX_ATTRIB_RELEASE_BEHAVIOR\t5\n\n#define __DRI_CTX_RELEASE_BEHAVIOR_NONE         0\n#define __DRI_CTX_RELEASE_BEHAVIOR_FLUSH        1\n/*@}*/\n\n/**\n * \\name Reasons that __DRIdri2Extension::createContextAttribs might fail\n */\n/*@{*/\n/** Success! */\n#define __DRI_CTX_ERROR_SUCCESS\t\t\t0\n\n/** Memory allocation failure */\n#define __DRI_CTX_ERROR_NO_MEMORY\t\t1\n\n/** Client requested an API (e.g., OpenGL ES 2.0) that the driver can't do. */\n#define __DRI_CTX_ERROR_BAD_API\t\t\t2\n\n/** Client requested an API version that the driver can't do. */\n#define __DRI_CTX_ERROR_BAD_VERSION\t\t3\n\n/** Client requested a flag or combination of flags the driver can't do. */\n#define __DRI_CTX_ERROR_BAD_FLAG\t\t4\n\n/** Client requested an attribute the driver doesn't understand. */\n#define __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE\t5\n\n/** Client requested a flag the driver doesn't understand. */\n#define __DRI_CTX_ERROR_UNKNOWN_FLAG\t\t6\n/*@}*/\n\nstruct __DRIdri2ExtensionRec {\n    __DRIextension base;\n\n    __DRIscreen *(*createNewScreen)(int screen, int fd,\n\t\t\t\t    const __DRIextension **extensions,\n\t\t\t\t    const __DRIconfig ***driver_configs,\n\t\t\t\t    void *loaderPrivate);\n\n   __DRIcreateNewDrawableFunc   createNewDrawable;\n   __DRIcontext *(*createNewContext)(__DRIscreen *screen,\n                                     const __DRIconfig *config,\n                                     __DRIcontext *shared,\n                                     void *loaderPrivate);\n\n   /* Since version 2 */\n   __DRIgetAPIMaskFunc          getAPIMask;\n\n   __DRIcontext *(*createNewContextForAPI)(__DRIscreen *screen,\n\t\t\t\t\t   int api,\n\t\t\t\t\t   const __DRIconfig *config,\n\t\t\t\t\t   __DRIcontext *shared,\n\t\t\t\t\t   void *data);\n\n   __DRIbuffer *(*allocateBuffer)(__DRIscreen *screen,\n\t\t\t\t  unsigned int attachment,\n\t\t\t\t  unsigned int format,\n\t\t\t\t  int width,\n\t\t\t\t  int height);\n   void (*releaseBuffer)(__DRIscreen *screen,\n\t\t\t __DRIbuffer *buffer);\n\n   /**\n    * Create a context for a particular API with a set of attributes\n    *\n    * \\since version 3\n    *\n    * \\sa __DRIswrastExtensionRec::createContextAttribs\n    */\n   __DRIcreateContextAttribsFunc        createContextAttribs;\n\n   /**\n    * createNewScreen with the driver's extension list passed in.\n    *\n    * \\since version 4\n    */\n   __DRIcreateNewScreen2Func            createNewScreen2;\n};\n\n\n/**\n * This extension provides functionality to enable various EGLImage\n * extensions.\n */\n#define __DRI_IMAGE \"DRI_IMAGE\"\n#define __DRI_IMAGE_VERSION 18\n\n/**\n * These formats correspond to the similarly named MESA_FORMAT_*\n * tokens, except in the native endian of the CPU.  For example, on\n * little endian __DRI_IMAGE_FORMAT_XRGB8888 corresponds to\n * MESA_FORMAT_XRGB8888, but MESA_FORMAT_XRGB8888_REV on big endian.\n *\n * __DRI_IMAGE_FORMAT_NONE is for images that aren't directly usable\n * by the driver (YUV planar formats) but serve as a base image for\n * creating sub-images for the different planes within the image.\n *\n * R8, GR88 and NONE should not be used with createImageFromName or\n * createImage, and are returned by query from sub images created with\n * createImageFromNames (NONE, see above) and fromPlane (R8 & GR88).\n */\n#define __DRI_IMAGE_FORMAT_RGB565       0x1001\n#define __DRI_IMAGE_FORMAT_XRGB8888     0x1002\n#define __DRI_IMAGE_FORMAT_ARGB8888     0x1003\n#define __DRI_IMAGE_FORMAT_ABGR8888     0x1004\n#define __DRI_IMAGE_FORMAT_XBGR8888     0x1005\n#define __DRI_IMAGE_FORMAT_R8           0x1006 /* Since version 5 */\n#define __DRI_IMAGE_FORMAT_GR88         0x1007\n#define __DRI_IMAGE_FORMAT_NONE         0x1008\n#define __DRI_IMAGE_FORMAT_XRGB2101010  0x1009\n#define __DRI_IMAGE_FORMAT_ARGB2101010  0x100a\n#define __DRI_IMAGE_FORMAT_SARGB8       0x100b\n#define __DRI_IMAGE_FORMAT_ARGB1555     0x100c\n#define __DRI_IMAGE_FORMAT_R16          0x100d\n#define __DRI_IMAGE_FORMAT_GR1616       0x100e\n#define __DRI_IMAGE_FORMAT_YUYV         0x100f\n#define __DRI_IMAGE_FORMAT_XBGR2101010  0x1010\n#define __DRI_IMAGE_FORMAT_ABGR2101010  0x1011\n#define __DRI_IMAGE_FORMAT_SABGR8       0x1012\n#define __DRI_IMAGE_FORMAT_UYVY         0x1013\n#define __DRI_IMAGE_FORMAT_XBGR16161616F 0x1014\n#define __DRI_IMAGE_FORMAT_ABGR16161616F 0x1015\n#define __DRI_IMAGE_FORMAT_SXRGB8       0x1016\n\n#define __DRI_IMAGE_USE_SHARE\t\t0x0001\n#define __DRI_IMAGE_USE_SCANOUT\t\t0x0002\n#define __DRI_IMAGE_USE_CURSOR\t\t0x0004 /* Deprecated */\n#define __DRI_IMAGE_USE_LINEAR\t\t0x0008\n/* The buffer will only be read by an external process after SwapBuffers,\n * in contrary to gbm buffers, front buffers and fake front buffers, which\n * could be read after a flush.\"\n */\n#define __DRI_IMAGE_USE_BACKBUFFER      0x0010\n#define __DRI_IMAGE_USE_PROTECTED       0x0020\n\n\n#define __DRI_IMAGE_TRANSFER_READ            0x1\n#define __DRI_IMAGE_TRANSFER_WRITE           0x2\n#define __DRI_IMAGE_TRANSFER_READ_WRITE      \\\n        (__DRI_IMAGE_TRANSFER_READ | __DRI_IMAGE_TRANSFER_WRITE)\n\n/**\n * Extra fourcc formats used internally to Mesa with createImageFromNames.\n * The externally-available fourccs are defined by drm_fourcc.h (DRM_FORMAT_*)\n * and WL_DRM_FORMAT_* from wayland_drm.h.\n *\n * \\since 5\n */\n\n#define __DRI_IMAGE_FOURCC_SARGB8888\t0x83324258\n#define __DRI_IMAGE_FOURCC_SABGR8888\t0x84324258\n#define __DRI_IMAGE_FOURCC_SXRGB8888\t0x85324258\n\n/**\n * Queryable on images created by createImageFromNames.\n *\n * RGB and RGBA are may be usable directly as images but its still\n * recommended to call fromPlanar with plane == 0.\n *\n * Y_U_V, Y_UV,Y_XUXV and Y_UXVX all requires call to fromPlanar to create\n * usable sub-images, sampling from images return raw YUV data and\n * color conversion needs to be done in the shader.\n *\n * \\since 5\n */\n\n#define __DRI_IMAGE_COMPONENTS_RGB\t0x3001\n#define __DRI_IMAGE_COMPONENTS_RGBA\t0x3002\n#define __DRI_IMAGE_COMPONENTS_Y_U_V\t0x3003\n#define __DRI_IMAGE_COMPONENTS_Y_UV\t0x3004\n#define __DRI_IMAGE_COMPONENTS_Y_XUXV\t0x3005\n#define __DRI_IMAGE_COMPONENTS_Y_UXVX\t0x3008\n#define __DRI_IMAGE_COMPONENTS_AYUV\t0x3009\n#define __DRI_IMAGE_COMPONENTS_XYUV\t0x300A\n#define __DRI_IMAGE_COMPONENTS_R\t0x3006\n#define __DRI_IMAGE_COMPONENTS_RG\t0x3007\n\n\n/**\n * queryImage attributes\n */\n\n#define __DRI_IMAGE_ATTRIB_STRIDE\t0x2000\n#define __DRI_IMAGE_ATTRIB_HANDLE\t0x2001\n#define __DRI_IMAGE_ATTRIB_NAME\t\t0x2002\n#define __DRI_IMAGE_ATTRIB_FORMAT\t0x2003 /* available in versions 3+ */\n#define __DRI_IMAGE_ATTRIB_WIDTH\t0x2004 /* available in versions 4+ */\n#define __DRI_IMAGE_ATTRIB_HEIGHT\t0x2005\n#define __DRI_IMAGE_ATTRIB_COMPONENTS\t0x2006 /* available in versions 5+ */\n#define __DRI_IMAGE_ATTRIB_FD           0x2007 /* available in versions\n                                                * 7+. Each query will return a\n                                                * new fd. */\n#define __DRI_IMAGE_ATTRIB_FOURCC       0x2008 /* available in versions 11 */\n#define __DRI_IMAGE_ATTRIB_NUM_PLANES   0x2009 /* available in versions 11 */\n\n#define __DRI_IMAGE_ATTRIB_OFFSET 0x200A /* available in versions 13 */\n#define __DRI_IMAGE_ATTRIB_MODIFIER_LOWER 0x200B /* available in versions 14 */\n#define __DRI_IMAGE_ATTRIB_MODIFIER_UPPER 0x200C /* available in versions 14 */\n\nenum __DRIYUVColorSpace {\n   __DRI_YUV_COLOR_SPACE_UNDEFINED = 0,\n   __DRI_YUV_COLOR_SPACE_ITU_REC601 = 0x327F,\n   __DRI_YUV_COLOR_SPACE_ITU_REC709 = 0x3280,\n   __DRI_YUV_COLOR_SPACE_ITU_REC2020 = 0x3281\n};\n\nenum __DRISampleRange {\n   __DRI_YUV_RANGE_UNDEFINED = 0,\n   __DRI_YUV_FULL_RANGE = 0x3282,\n   __DRI_YUV_NARROW_RANGE = 0x3283\n};\n\nenum __DRIChromaSiting {\n   __DRI_YUV_CHROMA_SITING_UNDEFINED = 0,\n   __DRI_YUV_CHROMA_SITING_0 = 0x3284,\n   __DRI_YUV_CHROMA_SITING_0_5 = 0x3285\n};\n\n/**\n * \\name Reasons that __DRIimageExtensionRec::createImageFromTexture or\n * __DRIimageExtensionRec::createImageFromDmaBufs might fail\n */\n/*@{*/\n/** Success! */\n#define __DRI_IMAGE_ERROR_SUCCESS       0\n\n/** Memory allocation failure */\n#define __DRI_IMAGE_ERROR_BAD_ALLOC     1\n\n/** Client requested an invalid attribute */\n#define __DRI_IMAGE_ERROR_BAD_MATCH     2\n\n/** Client requested an invalid texture object */\n#define __DRI_IMAGE_ERROR_BAD_PARAMETER 3\n\n/** Client requested an invalid pitch and/or offset */\n#define __DRI_IMAGE_ERROR_BAD_ACCESS    4\n/*@}*/\n\n/**\n * \\name Capabilities that might be returned by __DRIimageExtensionRec::getCapabilities\n */\n/*@{*/\n#define __DRI_IMAGE_CAP_GLOBAL_NAMES 1\n/*@}*/\n\n/**\n * blitImage flags\n */\n\n#define __BLIT_FLAG_FLUSH\t\t0x0001\n#define __BLIT_FLAG_FINISH\t\t0x0002\n\n/**\n * Flags for createImageFromDmaBufs3\n */\n#define __DRI_IMAGE_PROTECTED_CONTENT_FLAG 0x00000001\n\n/**\n * queryDmaBufFormatModifierAttribs attributes\n */\n\n/* Available in version 16 */\n#define __DRI_IMAGE_FORMAT_MODIFIER_ATTRIB_PLANE_COUNT   0x0001\n\ntypedef struct __DRIimageRec          __DRIimage;\ntypedef struct __DRIimageExtensionRec __DRIimageExtension;\nstruct __DRIimageExtensionRec {\n    __DRIextension base;\n\n    __DRIimage *(*createImageFromName)(__DRIscreen *screen,\n\t\t\t\t       int width, int height, int format,\n\t\t\t\t       int name, int pitch,\n\t\t\t\t       void *loaderPrivate);\n\n    /* Deprecated since version 17; see createImageFromRenderbuffer2 */\n    __DRIimage *(*createImageFromRenderbuffer)(__DRIcontext *context,\n\t\t\t\t\t       int renderbuffer,\n\t\t\t\t\t       void *loaderPrivate);\n\n    void (*destroyImage)(__DRIimage *image);\n\n    __DRIimage *(*createImage)(__DRIscreen *screen,\n\t\t\t       int width, int height, int format,\n\t\t\t       unsigned int use,\n\t\t\t       void *loaderPrivate);\n\n   GLboolean (*queryImage)(__DRIimage *image, int attrib, int *value);\n\n   /**\n    * The new __DRIimage will share the content with the old one, see dup(2).\n    */\n   __DRIimage *(*dupImage)(__DRIimage *image, void *loaderPrivate);\n\n   /**\n    * Validate that a __DRIimage can be used a certain way.\n    *\n    * \\since 2\n    */\n   GLboolean (*validateUsage)(__DRIimage *image, unsigned int use);\n\n   /**\n    * Unlike createImageFromName __DRI_IMAGE_FORMAT is not used but instead\n    * DRM_FORMAT_*, and strides are in bytes not pixels. Stride is\n    * also per block and not per pixel (for non-RGB, see gallium blocks).\n    *\n    * \\since 5\n    */\n   __DRIimage *(*createImageFromNames)(__DRIscreen *screen,\n                                       int width, int height, int fourcc,\n                                       int *names, int num_names,\n                                       int *strides, int *offsets,\n                                       void *loaderPrivate);\n\n   /**\n    * Create an image out of a sub-region of a parent image.  This\n    * entry point lets us create individual __DRIimages for different\n    * planes in a planar buffer (typically yuv), for example.  While a\n    * sub-image shares the underlying buffer object with the parent\n    * image and other sibling sub-images, the life times of parent and\n    * sub-images are not dependent.  Destroying the parent or a\n    * sub-image doesn't affect other images.  The underlying buffer\n    * object is free when no __DRIimage remains that references it.\n    *\n    * Sub-images may overlap, but rendering to overlapping sub-images\n    * is undefined.\n    *\n    * \\since 5\n    */\n    __DRIimage *(*fromPlanar)(__DRIimage *image, int plane,\n                              void *loaderPrivate);\n\n    /**\n     * Create image from texture.\n     *\n     * \\since 6\n     */\n   __DRIimage *(*createImageFromTexture)(__DRIcontext *context,\n                                         int target,\n                                         unsigned texture,\n                                         int depth,\n                                         int level,\n                                         unsigned *error,\n                                         void *loaderPrivate);\n   /**\n    * Like createImageFromNames, but takes a prime fd instead.\n    *\n    * \\since 7\n    */\n   __DRIimage *(*createImageFromFds)(__DRIscreen *screen,\n                                     int width, int height, int fourcc,\n                                     int *fds, int num_fds,\n                                     int *strides, int *offsets,\n                                     void *loaderPrivate);\n\n   /**\n    * Like createImageFromFds, but takes additional attributes.\n    *\n    * For EGL_EXT_image_dma_buf_import.\n    *\n    * \\since 8\n    */\n   __DRIimage *(*createImageFromDmaBufs)(__DRIscreen *screen,\n                                         int width, int height, int fourcc,\n                                         int *fds, int num_fds,\n                                         int *strides, int *offsets,\n                                         enum __DRIYUVColorSpace color_space,\n                                         enum __DRISampleRange sample_range,\n                                         enum __DRIChromaSiting horiz_siting,\n                                         enum __DRIChromaSiting vert_siting,\n                                         unsigned *error,\n                                         void *loaderPrivate);\n\n   /**\n    * Blit a part of a __DRIimage to another and flushes\n    *\n    * flush_flag:\n    *    0:                  no flush\n    *    __BLIT_FLAG_FLUSH:  flush after the blit operation\n    *    __BLIT_FLAG_FINISH: flush and wait the blit finished\n    *\n    * \\since 9\n    */\n   void (*blitImage)(__DRIcontext *context, __DRIimage *dst, __DRIimage *src,\n                     int dstx0, int dsty0, int dstwidth, int dstheight,\n                     int srcx0, int srcy0, int srcwidth, int srcheight,\n                     int flush_flag);\n\n   /**\n    * Query for general capabilities of the driver that concern\n    * buffer sharing and image importing.\n    *\n    * \\since 10\n    */\n   int (*getCapabilities)(__DRIscreen *screen);\n\n   /**\n    * Returns a map of the specified region of a __DRIimage for the specified usage.\n    *\n    * flags may include __DRI_IMAGE_TRANSFER_READ, which will populate the\n    * mapping with the current buffer content. If __DRI_IMAGE_TRANSFER_READ\n    * is not included in the flags, the buffer content at map time is\n    * undefined. Users wanting to modify the mapping must include\n    * __DRI_IMAGE_TRANSFER_WRITE; if __DRI_IMAGE_TRANSFER_WRITE is not\n    * included, behaviour when writing the mapping is undefined.\n    *\n    * Returns the byte stride in *stride, and an opaque pointer to data\n    * tracking the mapping in **data, which must be passed to unmapImage().\n    *\n    * \\since 12\n    */\n   void *(*mapImage)(__DRIcontext *context, __DRIimage *image,\n                     int x0, int y0, int width, int height,\n                     unsigned int flags, int *stride, void **data);\n\n   /**\n    * Unmap a previously mapped __DRIimage\n    *\n    * \\since 12\n    */\n   void (*unmapImage)(__DRIcontext *context, __DRIimage *image, void *data);\n\n\n   /**\n    * Creates an image with implementation's favorite modifiers.\n    *\n    * This acts like createImage except there is a list of modifiers passed in\n    * which the implementation may selectively use to create the DRIimage. The\n    * result should be the implementation selects one modifier (perhaps it would\n    * hold on to a few and later pick).\n    *\n    * The created image should be destroyed with destroyImage().\n    *\n    * Returns the new DRIimage. The chosen modifier can be obtained later on\n    * and passed back to things like the kernel's AddFB2 interface.\n    *\n    * \\sa __DRIimageRec::createImage\n    *\n    * \\since 14\n    */\n   __DRIimage *(*createImageWithModifiers)(__DRIscreen *screen,\n                                           int width, int height, int format,\n                                           const uint64_t *modifiers,\n                                           const unsigned int modifier_count,\n                                           void *loaderPrivate);\n\n   /*\n    * Like createImageFromDmaBufs, but takes also format modifiers.\n    *\n    * For EGL_EXT_image_dma_buf_import_modifiers.\n    *\n    * \\since 15\n    */\n   __DRIimage *(*createImageFromDmaBufs2)(__DRIscreen *screen,\n                                          int width, int height, int fourcc,\n                                          uint64_t modifier,\n                                          int *fds, int num_fds,\n                                          int *strides, int *offsets,\n                                          enum __DRIYUVColorSpace color_space,\n                                          enum __DRISampleRange sample_range,\n                                          enum __DRIChromaSiting horiz_siting,\n                                          enum __DRIChromaSiting vert_siting,\n                                          unsigned *error,\n                                          void *loaderPrivate);\n\n   /*\n    * dmabuf format query to support EGL_EXT_image_dma_buf_import_modifiers.\n    *\n    * \\param max      Maximum number of formats that can be accomodated into\n    *                 \\param formats. If zero, no formats are returned -\n    *                 instead, the driver returns the total number of\n    *                 supported dmabuf formats in \\param count.\n    * \\param formats  Buffer to fill formats into.\n    * \\param count    Count of formats returned, or, total number of\n    *                 supported formats in case \\param max is zero.\n    *\n    * Returns true on success.\n    *\n    * \\since 15\n    */\n   GLboolean (*queryDmaBufFormats)(__DRIscreen *screen, int max,\n                                   int *formats, int *count);\n\n   /*\n    * dmabuf format modifier query for a given format to support\n    * EGL_EXT_image_dma_buf_import_modifiers.\n    *\n    * \\param fourcc    The format to query modifiers for. If this format\n    *                  is not supported by the driver, return false.\n    * \\param max       Maximum number of modifiers that can be accomodated in\n    *                  \\param modifiers. If zero, no modifiers are returned -\n    *                  instead, the driver returns the total number of\n    *                  modifiers for \\param format in \\param count.\n    * \\param modifiers Buffer to fill modifiers into.\n    * \\param count     Count of the modifiers returned, or, total number of\n    *                  supported modifiers for \\param fourcc in case\n    *                  \\param max is zero.\n    *\n    * Returns true upon success.\n    *\n    * \\since 15\n    */\n   GLboolean (*queryDmaBufModifiers)(__DRIscreen *screen, int fourcc,\n                                     int max, uint64_t *modifiers,\n                                     unsigned int *external_only,\n                                     int *count);\n\n   /**\n    * dmabuf format modifier attribute query for a given format and modifier.\n    *\n    * \\param fourcc    The format to query. If this format is not supported by\n    *                  the driver, return false.\n    * \\param modifier  The modifier to query. If this format+modifier is not\n    *                  supported by the driver, return false.\n    * \\param attrib    The __DRI_IMAGE_FORMAT_MODIFIER_ATTRIB to query.\n    * \\param value     A pointer to where to store the result of the query.\n    *\n    * Returns true upon success.\n    *\n    * \\since 16\n    */\n   GLboolean (*queryDmaBufFormatModifierAttribs)(__DRIscreen *screen,\n                                                 uint32_t fourcc, uint64_t modifier,\n                                                 int attrib, uint64_t *value);\n\n   /**\n    * Create a DRI image from the given renderbuffer.\n    *\n    * \\param context       the current DRI context\n    * \\param renderbuffer  the GL name of the renderbuffer\n    * \\param loaderPrivate for callbacks into the loader related to the image\n    * \\param error         will be set to one of __DRI_IMAGE_ERROR_xxx\n    * \\return the newly created image on success, or NULL otherwise\n    *\n    * \\since 17\n    */\n    __DRIimage *(*createImageFromRenderbuffer2)(__DRIcontext *context,\n                                                int renderbuffer,\n                                                void *loaderPrivate,\n                                                unsigned *error);\n\n   /*\n    * Like createImageFromDmaBufs2, but with an added flags parameter.\n    *\n    * See __DRI_IMAGE_*_FLAG for valid definitions of flags.\n    *\n    * \\since 18\n    */\n   __DRIimage *(*createImageFromDmaBufs3)(__DRIscreen *screen,\n                                          int width, int height, int fourcc,\n                                          uint64_t modifier,\n                                          int *fds, int num_fds,\n                                          int *strides, int *offsets,\n                                          enum __DRIYUVColorSpace color_space,\n                                          enum __DRISampleRange sample_range,\n                                          enum __DRIChromaSiting horiz_siting,\n                                          enum __DRIChromaSiting vert_siting,\n                                          uint32_t flags,\n                                          unsigned *error,\n                                          void *loaderPrivate);\n};\n\n\n/**\n * This extension must be implemented by the loader and passed to the\n * driver at screen creation time.  The EGLImage entry points in the\n * various client APIs take opaque EGLImage handles and use this\n * extension to map them to a __DRIimage.  At version 1, this\n * extensions allows mapping EGLImage pointers to __DRIimage pointers,\n * but future versions could support other EGLImage-like, opaque types\n * with new lookup functions.\n */\n#define __DRI_IMAGE_LOOKUP \"DRI_IMAGE_LOOKUP\"\n#define __DRI_IMAGE_LOOKUP_VERSION 1\n\ntypedef struct __DRIimageLookupExtensionRec __DRIimageLookupExtension;\nstruct __DRIimageLookupExtensionRec {\n    __DRIextension base;\n\n    __DRIimage *(*lookupEGLImage)(__DRIscreen *screen, void *image,\n\t\t\t\t  void *loaderPrivate);\n};\n\n/**\n * This extension allows for common DRI2 options\n */\n#define __DRI2_CONFIG_QUERY \"DRI_CONFIG_QUERY\"\n#define __DRI2_CONFIG_QUERY_VERSION 2\n\ntypedef struct __DRI2configQueryExtensionRec __DRI2configQueryExtension;\nstruct __DRI2configQueryExtensionRec {\n   __DRIextension base;\n\n   int (*configQueryb)(__DRIscreen *screen, const char *var, unsigned char *val);\n   int (*configQueryi)(__DRIscreen *screen, const char *var, int *val);\n   int (*configQueryf)(__DRIscreen *screen, const char *var, float *val);\n   int (*configQuerys)(__DRIscreen *screen, const char *var, char **val);\n};\n\n/**\n * Robust context driver extension.\n *\n * Existence of this extension means the driver can accept the\n * \\c __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS flag and the\n * \\c __DRI_CTX_ATTRIB_RESET_STRATEGY attribute in\n * \\c __DRIdri2ExtensionRec::createContextAttribs.\n */\n#define __DRI2_ROBUSTNESS \"DRI_Robustness\"\n#define __DRI2_ROBUSTNESS_VERSION 1\n\ntypedef struct __DRIrobustnessExtensionRec __DRIrobustnessExtension;\nstruct __DRIrobustnessExtensionRec {\n   __DRIextension base;\n};\n\n/**\n * No-error context driver extension.\n *\n * Existence of this extension means the driver can accept the\n * __DRI_CTX_FLAG_NO_ERROR flag.\n */\n#define __DRI2_NO_ERROR \"DRI_NoError\"\n#define __DRI2_NO_ERROR_VERSION 1\n\ntypedef struct __DRInoErrorExtensionRec {\n   __DRIextension base;\n} __DRInoErrorExtension;\n\n/*\n * Flush control driver extension.\n *\n * Existence of this extension means the driver can accept the\n * \\c __DRI_CTX_ATTRIB_RELEASE_BEHAVIOR attribute in\n * \\c __DRIdri2ExtensionRec::createContextAttribs.\n */\n#define __DRI2_FLUSH_CONTROL \"DRI_FlushControl\"\n#define __DRI2_FLUSH_CONTROL_VERSION 1\n\ntypedef struct __DRI2flushControlExtensionRec __DRI2flushControlExtension;\nstruct __DRI2flushControlExtensionRec {\n   __DRIextension base;\n};\n\n/**\n * DRI config options extension.\n *\n * This extension provides the XML string containing driver options for use by\n * the loader in supporting the driconf application.\n *\n * v2:\n * - Add the getXml getter function which allows the driver more flexibility in\n *   how the XML is provided.\n * - Deprecate the direct xml pointer. It is only provided as a fallback for\n *   older versions of libGL and must not be used by clients that are aware of\n *   the newer version. Future driver versions may set it to NULL.\n */\n#define __DRI_CONFIG_OPTIONS \"DRI_ConfigOptions\"\n#define __DRI_CONFIG_OPTIONS_VERSION 2\n\ntypedef struct __DRIconfigOptionsExtensionRec {\n   __DRIextension base;\n   const char *xml; /**< deprecated since v2, use getXml instead */\n\n   /**\n    * Get an XML string that describes available driver options for use by a\n    * config application.\n    *\n    * The returned string must be heap-allocated. The caller is responsible for\n    * freeing it.\n    */\n   char *(*getXml)(const char *driver_name);\n} __DRIconfigOptionsExtension;\n\n/**\n * This extension provides a driver vtable to a set of common driver helper\n * functions (driCoreExtension, driDRI2Extension) within the driver\n * implementation, as opposed to having to pass them through a global\n * variable.\n *\n * It is not intended to be public API to the actual loader, and the vtable\n * layout may change at any time.\n */\n#define __DRI_DRIVER_VTABLE \"DRI_DriverVtable\"\n#define __DRI_DRIVER_VTABLE_VERSION 1\n\ntypedef struct __DRIDriverVtableExtensionRec {\n    __DRIextension base;\n    const struct __DriverAPIRec *vtable;\n} __DRIDriverVtableExtension;\n\n/**\n * Query renderer driver extension\n *\n * This allows the window system layer (either EGL or GLX) to query aspects of\n * hardware and driver support without creating a context.\n */\n#define __DRI2_RENDERER_QUERY \"DRI_RENDERER_QUERY\"\n#define __DRI2_RENDERER_QUERY_VERSION 1\n\n#define __DRI2_RENDERER_VENDOR_ID                             0x0000\n#define __DRI2_RENDERER_DEVICE_ID                             0x0001\n#define __DRI2_RENDERER_VERSION                               0x0002\n#define __DRI2_RENDERER_ACCELERATED                           0x0003\n#define __DRI2_RENDERER_VIDEO_MEMORY                          0x0004\n#define __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE           0x0005\n#define __DRI2_RENDERER_PREFERRED_PROFILE                     0x0006\n#define __DRI2_RENDERER_OPENGL_CORE_PROFILE_VERSION           0x0007\n#define __DRI2_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION  0x0008\n#define __DRI2_RENDERER_OPENGL_ES_PROFILE_VERSION             0x0009\n#define __DRI2_RENDERER_OPENGL_ES2_PROFILE_VERSION            0x000a\n#define __DRI2_RENDERER_HAS_TEXTURE_3D                        0x000b\n/* Whether there is an sRGB format support for every supported 32-bit UNORM\n * color format.\n */\n#define __DRI2_RENDERER_HAS_FRAMEBUFFER_SRGB                  0x000c\n\n/* Bitmaks of supported/available context priorities - must match\n * __EGL_CONTEXT_PRIORITY_LOW_BIT et al\n */\n#define __DRI2_RENDERER_HAS_CONTEXT_PRIORITY                  0x000d\n#define   __DRI2_RENDERER_HAS_CONTEXT_PRIORITY_LOW            (1 << 0)\n#define   __DRI2_RENDERER_HAS_CONTEXT_PRIORITY_MEDIUM         (1 << 1)\n#define   __DRI2_RENDERER_HAS_CONTEXT_PRIORITY_HIGH           (1 << 2)\n\n#define __DRI2_RENDERER_HAS_PROTECTED_CONTENT                 0x000e\n\ntypedef struct __DRI2rendererQueryExtensionRec __DRI2rendererQueryExtension;\nstruct __DRI2rendererQueryExtensionRec {\n   __DRIextension base;\n\n   int (*queryInteger)(__DRIscreen *screen, int attribute, unsigned int *val);\n   int (*queryString)(__DRIscreen *screen, int attribute, const char **val);\n};\n\n/**\n * Image Loader extension. Drivers use this to allocate color buffers\n */\n\n/**\n * See __DRIimageLoaderExtensionRec::getBuffers::buffer_mask.\n */\nenum __DRIimageBufferMask {\n   __DRI_IMAGE_BUFFER_BACK = (1 << 0),\n   __DRI_IMAGE_BUFFER_FRONT = (1 << 1),\n\n   /**\n    * A buffer shared between application and compositor. The buffer may be\n    * simultaneously accessed by each.\n    *\n    * A shared buffer is equivalent to an EGLSurface whose EGLConfig contains\n    * EGL_MUTABLE_RENDER_BUFFER_BIT_KHR and whose active EGL_RENDER_BUFFER (as\n    * opposed to any pending, requested change to EGL_RENDER_BUFFER) is\n    * EGL_SINGLE_BUFFER.\n    *\n    * If buffer_mask contains __DRI_IMAGE_BUFFER_SHARED, then must contains no\n    * other bits. As a corollary, a __DRIdrawable that has a \"shared\" buffer\n    * has no front nor back buffer.\n    *\n    * The loader returns __DRI_IMAGE_BUFFER_SHARED in buffer_mask if and only\n    * if:\n    *     - The loader supports __DRI_MUTABLE_RENDER_BUFFER_LOADER.\n    *     - The driver supports __DRI_MUTABLE_RENDER_BUFFER_DRIVER.\n    *     - The EGLConfig of the drawable EGLSurface contains\n    *       EGL_MUTABLE_RENDER_BUFFER_BIT_KHR.\n    *     - The EGLContext's EGL_RENDER_BUFFER is EGL_SINGLE_BUFFER.\n    *       Equivalently, the EGLSurface's active EGL_RENDER_BUFFER (as\n    *       opposed to any pending, requested change to EGL_RENDER_BUFFER) is\n    *       EGL_SINGLE_BUFFER. (See the EGL 1.5 and\n    *       EGL_KHR_mutable_render_buffer spec for details about \"pending\" vs\n    *       \"active\" EGL_RENDER_BUFFER state).\n    *\n    * A shared buffer is similar to a front buffer in that all rendering to the\n    * buffer should appear promptly on the screen. It is different from\n    * a front buffer in that its behavior is independent from the\n    * GL_DRAW_BUFFER state. Specifically, if GL_DRAW_FRAMEBUFFER is 0 and the\n    * __DRIdrawable's buffer_mask is __DRI_IMAGE_BUFFER_SHARED, then all\n    * rendering should appear promptly on the screen if GL_DRAW_BUFFER is not\n    * GL_NONE.\n    *\n    * The difference between a shared buffer and a front buffer is motivated\n    * by the constraints of Android and OpenGL ES. OpenGL ES does not support\n    * front-buffer rendering. Android's SurfaceFlinger protocol provides the\n    * EGL driver only a back buffer and no front buffer. The shared buffer\n    * mode introduced by EGL_KHR_mutable_render_buffer is a backdoor though\n    * EGL that allows Android OpenGL ES applications to render to what is\n    * effectively the front buffer, a backdoor that required no change to the\n    * OpenGL ES API and little change to the SurfaceFlinger API.\n    */\n   __DRI_IMAGE_BUFFER_SHARED = (1 << 2),\n};\n\nstruct __DRIimageList {\n   uint32_t image_mask;\n   __DRIimage *back;\n   __DRIimage *front;\n};\n\n#define __DRI_IMAGE_LOADER \"DRI_IMAGE_LOADER\"\n#define __DRI_IMAGE_LOADER_VERSION 4\n\nstruct __DRIimageLoaderExtensionRec {\n    __DRIextension base;\n\n   /**\n    * Allocate color buffers.\n    *\n    * \\param driDrawable\n    * \\param width              Width of allocated buffers\n    * \\param height             Height of allocated buffers\n    * \\param format             one of __DRI_IMAGE_FORMAT_*\n    * \\param stamp              Address of variable to be updated when\n    *                           getBuffers must be called again\n    * \\param loaderPrivate      The loaderPrivate for driDrawable\n    * \\param buffer_mask        Set of buffers to allocate. A bitmask of\n    *                           __DRIimageBufferMask.\n    * \\param buffers            Returned buffers\n    */\n   int (*getBuffers)(__DRIdrawable *driDrawable,\n                     unsigned int format,\n                     uint32_t *stamp,\n                     void *loaderPrivate,\n                     uint32_t buffer_mask,\n                     struct __DRIimageList *buffers);\n\n    /**\n     * Flush pending front-buffer rendering\n     *\n     * Any rendering that has been performed to the\n     * fake front will be flushed to the front\n     *\n     * \\param driDrawable    Drawable whose front-buffer is to be flushed\n     * \\param loaderPrivate  Loader's private data that was previously passed\n     *                       into __DRIdri2ExtensionRec::createNewDrawable\n     */\n    void (*flushFrontBuffer)(__DRIdrawable *driDrawable, void *loaderPrivate);\n\n    /**\n     * Return a loader capability value. If the loader doesn't know the enum,\n     * it will return 0.\n     *\n     * \\since 2\n     */\n    unsigned (*getCapability)(void *loaderPrivate, enum dri_loader_cap cap);\n\n    /**\n     * Flush swap buffers\n     *\n     * Make sure any outstanding swap buffers have been submitted to the\n     * device.\n     *\n     * \\param driDrawable    Drawable whose swaps need to be flushed\n     * \\param loaderPrivate  Loader's private data that was previously passed\n     *                       into __DRIdri2ExtensionRec::createNewDrawable\n     *\n     * \\since 3\n     */\n    void (*flushSwapBuffers)(__DRIdrawable *driDrawable, void *loaderPrivate);\n\n    /**\n     * Clean up any loader state associated with an image.\n     *\n     * \\param loaderPrivate  Loader's private data that was previously passed\n     *                       into a __DRIimageExtensionRec::createImage function\n     * \\since 4\n     */\n    void (*destroyLoaderImageState)(void *loaderPrivate);\n};\n\n/**\n * DRI extension.\n */\n\n#define __DRI_IMAGE_DRIVER           \"DRI_IMAGE_DRIVER\"\n#define __DRI_IMAGE_DRIVER_VERSION   1\n\nstruct __DRIimageDriverExtensionRec {\n   __DRIextension               base;\n\n   /* Common DRI functions, shared with DRI2 */\n   __DRIcreateNewScreen2Func            createNewScreen2;\n   __DRIcreateNewDrawableFunc           createNewDrawable;\n   __DRIcreateContextAttribsFunc        createContextAttribs;\n   __DRIgetAPIMaskFunc                  getAPIMask;\n};\n\n/**\n * Background callable loader extension.\n *\n * Loaders expose this extension to indicate to drivers that they are capable\n * of handling callbacks from the driver's background drawing threads.\n */\n#define __DRI_BACKGROUND_CALLABLE \"DRI_BackgroundCallable\"\n#define __DRI_BACKGROUND_CALLABLE_VERSION 1\n\ntypedef struct __DRIbackgroundCallableExtensionRec __DRIbackgroundCallableExtension;\nstruct __DRIbackgroundCallableExtensionRec {\n   __DRIextension base;\n\n   /**\n    * Indicate that this thread is being used by the driver as a background\n    * drawing thread which may make callbacks to the loader.\n    *\n    * \\param loaderPrivate is the value that was passed to to the driver when\n    * the context was created.  This can be used by the loader to identify\n    * which context any callbacks are associated with.\n    *\n    * If this function is called more than once from any given thread, each\n    * subsequent call overrides the loaderPrivate data that was passed in the\n    * previous call.  The driver can take advantage of this to re-use a\n    * background thread to perform drawing on behalf of multiple contexts.\n    *\n    * It is permissible for the driver to call this function from a\n    * non-background thread (i.e. a thread that has already been bound to a\n    * context using __DRIcoreExtensionRec::bindContext()); when this happens,\n    * the \\c loaderPrivate pointer must be equal to the pointer that was\n    * passed to the driver when the currently bound context was created.\n    *\n    * This call should execute quickly enough that the driver can call it with\n    * impunity whenever a background thread starts performing drawing\n    * operations (e.g. it should just set a thread-local variable).\n    */\n   void (*setBackgroundContext)(void *loaderPrivate);\n\n   /**\n    * Indicate that it is multithread safe to use glthread.  For GLX/EGL\n    * platforms using Xlib, that involves calling XInitThreads, before\n    * opening an X display.\n    *\n    * Note: only supported if extension version is at least 2.\n    *\n    * \\param loaderPrivate is the value that was passed to to the driver when\n    * the context was created.  This can be used by the loader to identify\n    * which context any callbacks are associated with.\n    */\n   GLboolean (*isThreadSafe)(void *loaderPrivate);\n};\n\n/**\n * The driver portion of EGL_KHR_mutable_render_buffer.\n *\n * If the driver creates a __DRIconfig with\n * __DRI_ATTRIB_MUTABLE_RENDER_BUFFER, then it must support this extension.\n *\n * To support this extension:\n *\n *    - The driver should create at least one __DRIconfig with\n *      __DRI_ATTRIB_MUTABLE_RENDER_BUFFER. This is strongly recommended but\n *      not required.\n *\n *    - The driver must be able to handle __DRI_IMAGE_BUFFER_SHARED if\n *      returned by __DRIimageLoaderExtension:getBuffers().\n *\n *    - When rendering to __DRI_IMAGE_BUFFER_SHARED, it must call\n *      __DRImutableRenderBufferLoaderExtension::displaySharedBuffer() in\n *      response to glFlush and glFinish.  (This requirement is not documented\n *      in EGL_KHR_mutable_render_buffer, but is a de-facto requirement in the\n *      Android ecosystem. Android applications expect that glFlush will\n *      immediately display the buffer when in shared buffer mode, and Android\n *      drivers comply with this expectation).  It :may: call\n *      displaySharedBuffer() more often than required.\n *\n *    - When rendering to __DRI_IMAGE_BUFFER_SHARED, it must ensure that the\n *      buffer is always in a format compatible for display because the\n *      display engine (usually SurfaceFlinger or hwcomposer) may display the\n *      image at any time, even concurrently with 3D rendering. For example,\n *      display hardware and the GL hardware may be able to access the buffer\n *      simultaneously. In particular, if the buffer is compressed then take\n *      care that SurfaceFlinger and hwcomposer can consume the compression\n *      format.\n *\n * \\see __DRI_IMAGE_BUFFER_SHARED\n * \\see __DRI_ATTRIB_MUTABLE_RENDER_BUFFER\n * \\see __DRI_MUTABLE_RENDER_BUFFER_LOADER\n */\n#define __DRI_MUTABLE_RENDER_BUFFER_DRIVER \"DRI_MutableRenderBufferDriver\"\n#define __DRI_MUTABLE_RENDER_BUFFER_DRIVER_VERSION 1\n\ntypedef struct __DRImutableRenderBufferDriverExtensionRec __DRImutableRenderBufferDriverExtension;\nstruct __DRImutableRenderBufferDriverExtensionRec {\n   __DRIextension base;\n};\n\n/**\n * The loader portion of EGL_KHR_mutable_render_buffer.\n *\n * Requires loader extension DRI_IMAGE_LOADER, through which the loader sends\n * __DRI_IMAGE_BUFFER_SHARED to the driver.\n *\n * \\see __DRI_MUTABLE_RENDER_BUFFER_DRIVER\n */\n#define __DRI_MUTABLE_RENDER_BUFFER_LOADER \"DRI_MutableRenderBufferLoader\"\n#define __DRI_MUTABLE_RENDER_BUFFER_LOADER_VERSION 1\n\ntypedef struct __DRImutableRenderBufferLoaderExtensionRec __DRImutableRenderBufferLoaderExtension;\nstruct __DRImutableRenderBufferLoaderExtensionRec {\n   __DRIextension base;\n\n   /**\n    * Inform the display engine (that is, SurfaceFlinger and/or hwcomposer)\n    * that the __DRIdrawable has new content.\n    *\n    * The display engine may ignore this call, for example, if it continually\n    * refreshes and displays the buffer on every frame, as in\n    * EGL_ANDROID_front_buffer_auto_refresh. On the other extreme, the display\n    * engine may refresh and display the buffer only in frames in which the\n    * driver calls this.\n    *\n    * If the fence_fd is not -1, then the display engine will display the\n    * buffer only after the fence signals.\n    *\n    * The drawable's current __DRIimageBufferMask, as returned by\n    * __DRIimageLoaderExtension::getBuffers(), must be\n    * __DRI_IMAGE_BUFFER_SHARED.\n    */\n   void (*displaySharedBuffer)(__DRIdrawable *drawable, int fence_fd,\n                               void *loaderPrivate);\n};\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/freedreno/.gitlab-ci/traces/dEQP-GLES2.functional.texture.specification.basic_teximage2d.rgba16f_2d.rd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/freedreno/.gitlab-ci/traces/shadow.rd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/freedreno/.gitlab-ci/traces/es2gears-a320.rd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/freedreno/.gitlab-ci/traces/fd-clouds.rd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/freedreno/.gitlab-ci/traces/glxgears-a420.rd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/freedreno/.gitlab-ci/traces/dEQP-VK.draw.indirect_draw.indexed.indirect_draw_count.triangle_list.rd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/freedreno/.gitlab-ci/reference/afuc_test.fw",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/gallium/drivers/svga/include/svga3d_surfacedefs.h",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/mesa/x86/mmx_blendtmp.h",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/src/panfrost/util/nir_lower_blend.h",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/.git/objects/pack/pack-ec76ffbdba4135eb16587e0fb588c82bbab48445.pack",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/.git/objects/pack/pack-ec76ffbdba4135eb16587e0fb588c82bbab48445.idx",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-ay3lp5yd6m34jw72abxrlimfebu7u6vd/spack-src/docs/favicon.ico"
    ],
    "total_files": 8078
}