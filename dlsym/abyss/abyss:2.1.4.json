{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-abyss-2.1.4-zem2yfpgnu7lxrjuw7p4kayqd3gq6bwa/spack-src/configure.ac": "AC_PREREQ(2.62)\nAC_INIT(ABySS, 2.1.4, abyss-users@bcgsc.ca, abyss,\n\t\thttp://www.bcgsc.ca/platform/bioinfo/software/abyss)\nm4_include(m4/m4_ax_pthread.m4)\nAM_INIT_AUTOMAKE(1.9.6 foreign subdir-objects)\nAC_CONFIG_SRCDIR([ABYSS/abyss.cc])\nAC_CONFIG_HEADER([config.h])\n\n# Checks for programs.\nAC_PROG_AWK\nAC_PROG_CC\nAC_PROG_CPP\nAC_PROG_CXX\nAC_PROG_INSTALL\nAC_PROG_RANLIB\nAC_CHECK_TOOL(GHC, ghc)\nAM_CONDITIONAL([HAVE_GHC], [\"$GHC\" --version])\nAC_CHECK_PROG(PANDOC, pandoc, yes)\nAM_CONDITIONAL([HAVE_PANDOC], [test x\"$PANDOC\" = x\"yes\"])\n\n# Checks for header files.\nAC_CHECK_HEADERS([dlfcn.h fcntl.h float.h limits.h \\\n\tstddef.h stdint.h stdlib.h sys/param.h])\nAC_HEADER_STDBOOL\nAC_HEADER_STDC\n\n# Checks for typedefs, structures, and compiler characteristics.\nAC_C_BIGENDIAN\nAC_C_CONST\nAC_C_INLINE\nAC_CHECK_TYPES([ptrdiff_t])\nAC_TYPE_MODE_T\nAC_TYPE_PID_T\nAC_TYPE_SIZE_T\nAC_TYPE_SSIZE_T\nAC_TYPE_INT64_T\nAC_TYPE_UINT8_T\nAC_TYPE_UINT16_T\nAC_TYPE_UINT32_T\nAC_TYPE_UINT64_T\n\n# Check for std::hash and std::tr1::hash.\nAC_LANG_PUSH([C++])\nAC_CHECK_TYPE([std::hash<int>],\n\tAC_DEFINE(HAVE_STD_HASH, [1],\n\t\t[Define if the system provides std::hash]),\n\t[], [\n#ifdef __FUJITSU\n#include <string>\n#else\n#include <functional>\n#endif])\nAC_CHECK_TYPE([std::tr1::hash<int>],\n\tAC_DEFINE(HAVE_STD_TR1_HASH, [1],\n\t\t[Define if the system provides std::tr1::hash]),\n\t[], [#include <tr1/functional>])\nAC_CHECK_TYPE([std::tr1::tuple<int>],\n\tAC_DEFINE(HAVE_STD_TR1_TUPLE, [1],\n\t\t[Define if the system provides std::tr1::tuple]),\n\t[], [#include <tr1/tuple>])\nif test \"x$ac_cv_type_std__tr1__tuple_int_\" = \"xyes\"; then\n\t# Avoid double-declaration of std::tr1::tuple by boost.\n\t# See http://stackoverflow.com/questions/1156003/c-namespace-collision-with-gtest-and-boost\n\t# for explanation.\n\tAC_DEFINE(BOOST_HAS_TR1_TUPLE, [1],\n\t[Define to disable declaration of std::tr1::tuple by boost])\nfi\nAM_CONDITIONAL([HAVE_TR1_TUPLE], [test x\"$ac_cv_type_std__tr1__tuple_int_\" = x\"yes\"])\nAC_LANG_POP([C++])\n\n# Checks for library functions.\nAC_CHECK_FUNCS([dup2 gethostname getopt_long getpagesize \\\n\t\t\t\tmemset strdup strerror strtoul])\nAC_FUNC_FORK\nAC_FUNC_MALLOC\nAC_FUNC_MEMCMP\nAC_FUNC_REALLOC\nAC_FUNC_SETVBUF_REVERSED\nAC_FUNC_VPRINTF\n\n# Checks for library constants.\nAC_CHECK_DECL(HOST_NAME_MAX, [],\n\tAC_DEFINE(HOST_NAME_MAX, [_POSIX_HOST_NAME_MAX],\n\t\t\t  [Define if the system does not provide HOST_NAME_MAX]),\n\t[#include <limits.h>])\n\n# Options to configure.\n# Boost\nAC_ARG_WITH(boost, AS_HELP_STRING([--with-boost=PATH],\n\t\t\t[specify directory for the boost header files]))\nif test \"$with_boost\" -a -d \"$with_boost\"; then\n\tboost_cppflags=\"-isystem$with_boost -isystem$with_boost/include\"\nfi\n\n# MPI\nAC_ARG_WITH(mpi, AS_HELP_STRING([--with-mpi=PATH],\n\t[specify prefix directory for the installed MPI parallel\n\tcomputing library]))\nif test \"$with_mpi\" -a -d \"$with_mpi\"; then\n\tmpi_cppflags=\"-isystem$with_mpi/include\"\n\tif test -d \"$with_mpi/lib64\"; then\n\t\tmpi_ldflags=\"-L$with_mpi/lib64\"\n\telse\n\t\tmpi_ldflags=\"-L$with_mpi/lib\"\n\tfi\nfi\n\nAC_ARG_ENABLE(mpich, AS_HELP_STRING([--enable-mpich],\n\t[use MPICH (default is to use Open MPI)]))\nAC_ARG_ENABLE(lammpi, AS_HELP_STRING([--enable-lammpi],\n\t[use LAM/MPI (default is to use Open MPI)]))\n\n# SQLite\nAC_ARG_WITH(sqlite, AS_HELP_STRING([--with-sqlite=PATH],\n\t[specify prefix directory for the installed sqlite library]))\nif test \"$with_sqlite\" -a \"$with_sqlite\" != \"no\" -a -d \"$with_sqlite\"; then\n\tsqlite_cppflags=\"-I$with_sqlite/include\"\n\tif test -d \"$with_sqlite/lib64\"; then\n\t\tsqlite_ldflags=\"-L$with_sqlite/lib64 -lsqlite3\"\n\telse\n\t\tsqlite_ldflags=\"-L$with_sqlite/lib -lsqlite3\"\n\tfi\nfi\n\n# SparseHash\nAC_ARG_WITH(sparsehash, AS_HELP_STRING([--with-sparsehash=PATH],\n\t[specify prefix directory for the installed sparsehash library]))\nif test \"$with_sparsehash\" -a \"$with_sparsehash\" != \"no\" -a -d \"$with_sparsehash\" ; then\n\tsparsehash_cppflags=\"-isystem$with_sparsehash/include\"\n\tsparsehash_ldflags=\"-L$with_sparsehash/lib\"\nfi\n\nAC_ARG_ENABLE(fm, AS_HELP_STRING([--enable-fm],\n\t[specify the width of the FM-index in bits (default is 64-bit)]),\n\t[], [enable_fm=64])\nAC_DEFINE_UNQUOTED(FMBITS, $enable_fm,\n\t\t\t\t   [Width of bits of the FM-index in bits])\n\nAC_ARG_ENABLE(maxk, AS_HELP_STRING([--enable-maxk=N],\n\t[set the maximum k-mer length (default is 128)]),\n\t[], [enable_maxk=128])\nAC_DEFINE_UNQUOTED(MAX_KMER, [$enable_maxk], [maximum k-mer length])\n\nAC_ARG_ENABLE(max-hashes, AS_HELP_STRING([--enable-max-hashes],\n\t[set the maximum number of Bloom filter hash functions (default is 32)]),\n\t[], [enable_max_hashes=32])\nAC_DEFINE_UNQUOTED(MAX_HASHES, [$enable_max_hashes], [maximum Bloom filter hash functions])\n\n# Find the absolute path to the source.\nmy_abs_srcdir=$(cd $srcdir; pwd)\n\n# Set compiler flags.\nboost_ver=1.56.0\nboost_ver_dir=boost_1_56_0\nAC_SUBST(CPPFLAGS,\n\t\t \"-I$my_abs_srcdir $boost_cppflags $mpi_cppflags $sqlite_cppflags $sparsehash_cppflags $CPPFLAGS -isystem$my_abs_srcdir/$boost_ver_dir\")\nAC_SUBST(LDFLAGS, \"$mpi_ldflags $sqlite_ldflags $sparsehash_ldflags $LDFLAGS\")\n\n# Check for pthread.h / libpthread\n# (optional 'make check' dependency)\nAX_PTHREAD([have_pthread=\"yes\"])\nAM_CONDITIONAL([HAVE_PTHREAD], [test x\"$have_pthread\" = x\"yes\"])\n\n# Check for the MPI parallel computing library.\nlibs=\"$LIBS\"\nAC_DEFINE(MPICH_SKIP_MPICXX, 1,\n\t\t  [Define to disable MPICH C++ bindings])\nAC_DEFINE(OMPI_SKIP_MPICXX, 1,\n\t\t  [Define to disable OpenMPI C++ bindings])\nAC_CHECK_HEADERS([mpi.h])\nif test \"$enable_mpich\"; then\n\tAC_CHECK_LIB([pthread], [pthread_create])\n\tAC_CHECK_LIB([mpl], [MPL_env2int])\n\tAC_CHECK_LIB([mpich], [MPI_Init])\n\tac_cv_lib_mpi_MPI_Init=$ac_cv_lib_mpich_MPI_Init\nelif test \"$enable_lammpi\"; then\n\tAC_CHECK_LIB([pthread], [pthread_create])\n\tAC_CHECK_LIB([dl], [dlopen])\n\tAC_CHECK_LIB([lam], [lam_mutex_lock])\n\tAC_CHECK_LIB([mpi], [MPI_Init])\n\tAC_LANG_PUSH([C++])\n\tAC_CHECK_LIB([lammpi++], [main])\n\tAC_LANG_POP([C++])\nelse\n\tAC_CHECK_LIB([mpi], [MPI_Init])\nfi\nAM_CONDITIONAL([HAVE_LIBMPI],\n\t[test $ac_cv_header_mpi_h = yes -a $ac_cv_lib_mpi_MPI_Init = yes])\nAC_SUBST(MPI_LIBS, \"$LIBS\")\nLIBS=\"$libs\"\n\n# Check for the math library.\nAC_CHECK_LIB([m], [sqrt])\nAC_CHECK_FUNCS([pow sqrt])\nAC_CHECK_FUNC(ceilf, [], AC_DEFINE(ceilf, [ceil],\n\t\t\t  [Define if the system does not provide ceilf]))\n\n# Check for the dynamic linking library.\nAC_CHECK_LIB([dl], [dlsym])\n\n# Check for popcnt instruction.\nAC_COMPILE_IFELSE(\n\t[AC_LANG_PROGRAM([[#include <stdint.h>],\n\t\t\t\t\t  [uint64_t x = 0;]],\n\t\t\t\t\t [[__asm__(\"popcnt %1,%0\" : \"=r\" (x) : \"r\" (x));]])],\n\t[AC_DEFINE([HAVE_POPCNT], 1, [Define to 1 if you have popcnt.])],\n\t[AC_DEFINE([HAVE_POPCNT], 0, [Define to 0 if you do not have popcnt.])])\n\n# Check for the hash table implementation.\nAC_LANG([C++])\nAC_CHECK_HEADERS([ \\\n\tfunctional \\\n\ttr1/functional \\\n\tboost/functional/hash.hpp \\\n\tboost/property_map/property_map.hpp \\\n\tgoogle/sparse_hash_map \\\n\tunordered_map tr1/unordered_map \\\n\tunordered_set tr1/unordered_set \\\n\tboost/unordered_set.hpp \\\n])\n\n# Check for Boost.\nif test $ac_cv_header_boost_property_map_property_map_hpp != yes; then\n\tAC_MSG_ERROR([ABySS requires the Boost C++ libraries, which may\n\tbe downloaded from here: http://www.boost.org/users/download/\n\tIt is not necessary to compile Boost before installing it. The\n\tfollowing commands will download and install Boost for ABySS:\n\tcd $my_abs_srcdir\n\twget http://downloads.sourceforge.net/project/boost/boost/$boost_ver/$boost_ver_dir.tar.bz2\n\ttar jxf $boost_ver_dir.tar.bz2\n\tcd -])\nfi\n\n# Check for SQLite\nlibs=\"$LIBS\"\nif test \"$with_sqlite\" != \"no\"; then\n\tAC_CHECK_HEADERS([sqlite3.h])\n\tAC_CHECK_LIB([sqlite3],[main])\nfi\nif (test \"$ac_cv_header_sqlite3_h\" = \"yes\" -a \"$ac_cv_lib_sqlite3_main\" = \"yes\"); then\n\tAC_DEFINE(_SQL, 1, [Define to 1 if you have sqlite lib/header])\nfi\nAM_CONDITIONAL(HAVE_SQLITE3,\n\t[test \"$ac_cv_header_sqlite3_h\" = \"yes\" -a \"$ac_cv_lib_sqlite3_main\" = \"yes\"],\n\t[Define to 1 if you have sqlite lib/header])\nAC_SUBST(SQLITE_LIBS, \"$LIBS\")\nLIBS=$libs\n\n# Check for OpenMP.\nAC_OPENMP\nif test -z $OPENMP_CXXFLAGS; then\n\tOPENMP_CXXFLAGS=-Wno-unknown-pragmas\nfi\n\n# Set compiler flags.\n\nAC_ARG_ENABLE([werror], AS_HELP_STRING([--disable-werror],\n\t[do not treat compiler warnings as errors]))\n\nif test x\"$enable_werror\" = x\"no\"; then\n\tAC_SUBST(AM_CXXFLAGS, '-Wall -Wextra')\nelif test x\"$enable_werror\" = x\"yes\"; then\n\tAC_SUBST(AM_CXXFLAGS, '-Wall -Wextra -Werror')\nelse\n\t# default\n\tAC_SUBST(AM_CXXFLAGS, '-Wall -Wextra -Werror')\nfi\n\n# Build abyss-paired-dbg and abyss-paired-dbg-mpi\nAM_CONDITIONAL([PAIRED_DBG], [true])\n\nAC_CONFIG_FILES([\n\tMakefile\n\tABYSS/Makefile\n\tAlign/Makefile\n\tAssembly/Makefile\n\tCommon/Makefile\n\tDataLayer/Makefile\n\tFMIndex/Makefile\n\tGraph/Makefile\n\tParallel/Makefile\n\tbin/Makefile\n\tdoc/Makefile\n\tdialign/Makefile\n\tkmerprint/Makefile\n\tAdjList/Makefile\n\tKonnector/Makefile\n\tDAssembler/Makefile\n\tDistanceEst/Makefile\n\tLayout/Makefile\n\tMap/Makefile\n\tMisc/Makefile\n\tOverlap/Makefile\n\tPopBubbles/Makefile\n\tScaffold/Makefile\n\tSimpleGraph/Makefile\n\tMergePaths/Makefile\n\tKAligner/Makefile\n\tPairedDBG/Makefile\n\tParseAligns/Makefile\n\tPathOverlap/Makefile\n\tConsensus/Makefile\n\tFilterGraph/Makefile\n\tGapFiller/Makefile\n\tSealer/Makefile\n\tlib/gtest-1.7.0/Makefile\n\tUnittest/Makefile\n\tLogKmerCount/Makefile\n\tBloom/Makefile\n\tBloomDBG/Makefile\n\tDataBase/Makefile\n\tlib/bloomfilter/Makefile\n\tlib/nthash/Makefile\n])\n\nif test \"$with_sparsehash\" != \"no\" -a \"$ac_cv_header_google_sparse_hash_map\" != \"yes\"; then\n\tAC_MSG_ERROR([ABySS should be compiled with Google sparsehash to\n\treduce memory usage. It may be downloaded here:\n\thttps://code.google.com/p/sparsehash/\n\n\tIf you do not wish to use sparsehash, specify --without-sparsehash.])\nfi\n\nif test x\"$have_pthread\" != x\"yes\"; then\n\tAC_MSG_WARN([Warning: Running the unit tests with 'make check' has been disabled\n\tbecause pthread.h and/or libpthread could not be found.])\nfi\n\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-abyss-2.1.4-zem2yfpgnu7lxrjuw7p4kayqd3gq6bwa/spack-src/Common/Uncompress.cpp": "/** Uncompress input files using pipes.\n * Hook the standard file opening functions, open, fopen and fopen64.\n * If the extension of the file being opened indicates the file is\n * compressed (.gz, .bz2, .xz), open a pipe to a program that\n * decompresses that file (gunzip, bunzip2 or xzdec) and return a\n * handle to the open pipe.\n * @author Shaun Jackman <sjackman@bcgsc.ca>\n */\n\n#include \"config.h\"\n#if HAVE_LIBDL\n\n#include \"Fcontrol.h\"\n#include \"SignalHandler.h\"\n#include \"StringUtil.h\"\n#include <cassert>\n#include <cstdio> // for perror\n#include <cstdlib>\n#include <dlfcn.h>\n#include <string>\n#include <unistd.h>\n\nusing namespace std;\n\nstatic const char* wgetExec(const string& path)\n{\n\treturn\n\t\tstartsWith(path, \"http://\") ? \"wget -O-\" :\n\t\tstartsWith(path, \"https://\") ? \"wget -O-\" :\n\t\tstartsWith(path, \"ftp://\") ? \"wget -O-\" :\n\t\tNULL;\n}\n\nstatic const char* zcatExec(const string& path)\n{\n\treturn\n\t\tendsWith(path, \".ar\") ? \"ar -p\" :\n\t\tendsWith(path, \".tar\") ? \"tar -xOf\" :\n\t\tendsWith(path, \".tar.Z\") ? \"tar -zxOf\" :\n\t\tendsWith(path, \".tar.gz\") ? \"tar -zxOf\" :\n\t\tendsWith(path, \".tar.bz2\") ? \"tar -jxOf\" :\n\t\tendsWith(path, \".tar.xz\") ?\n\t\t\t\"tar --use-compress-program=xzdec -xOf\" :\n\t\tendsWith(path, \".Z\") ? \"gunzip -c\" :\n\t\tendsWith(path, \".gz\") ? \"gunzip -c\" :\n\t\tendsWith(path, \".bz2\") ? \"bunzip2 -c\" :\n\t\tendsWith(path, \".xz\") ? \"xzdec -c\" :\n\t\tendsWith(path, \".zip\") ? \"unzip -p\" :\n\t\tendsWith(path, \".bam\") ? \"samtools view -h\" :\n\t\tendsWith(path, \".cram\") ? \"samtools view -h\" :\n\t\tendsWith(path, \".jf\") ? \"jellyfish dump\" :\n\t\tendsWith(path, \".jfq\") ? \"jellyfish qdump\" :\n\t\tendsWith(path, \".sra\") ? \"fastq-dump -Z --split-spot\" :\n\t\tendsWith(path, \".url\") ? \"wget -O- -i\" :\n\t        endsWith(path, \".fqz\") ? \"fqz_comp -d\" :\n\t\tNULL;\n}\n\nextern \"C\" {\n\n/** Open a pipe to uncompress the specified file.\n * Not thread safe.\n * @return a file descriptor\n */\nstatic int uncompress(const char *path)\n{\n\tconst char *wget = wgetExec(path);\n\tconst char *zcat = wget != NULL ? wget : zcatExec(path);\n\tassert(zcat != NULL);\n\n\tint fd[2];\n\tif (pipe(fd) == -1)\n\t\treturn -1;\n\tint err = setCloexec(fd[0]);\n\tassert(err == 0);\n\t(void)err;\n\n\tchar arg0[16], arg1[16], arg2[16];\n\tint n = sscanf(zcat, \"%s %s %s\", arg0, arg1, arg2);\n\tassert(n == 2 || n == 3);\n\n\t/* It would be more portable to use fork than vfork, but fork can\n\t * fail with ENOMEM when the process calling fork is using a lot\n\t * of memory. A workaround for this problem is to set\n\t * sysctl vm.overcommit_memory=1\n\t */\n#if HAVE_WORKING_VFORK\n\tpid_t pid = vfork();\n#else\n\tpid_t pid = fork();\n#endif\n\tif (pid == -1)\n\t\treturn -1;\n\n\tif (pid == 0) {\n\t\tdup2(fd[1], STDOUT_FILENO);\n\t\tclose(fd[1]);\n\t\tif (n == 2)\n\t\t\texeclp(arg0, arg0, arg1, path, NULL);\n\t\telse\n\t\t\texeclp(arg0, arg0, arg1, arg2, path, NULL);\n\t\t// Calling perror after vfork is not allowed, but we're about\n\t\t// to exit and an error message would be really helpful.\n\t\tperror(arg0);\n\t\t_exit(EXIT_FAILURE);\n\t} else {\n\t\tclose(fd[1]);\n\t\treturn fd[0];\n\t}\n}\n\n/** Open a pipe to uncompress the specified file.\n * @return a FILE pointer\n */\nstatic FILE* funcompress(const char* path)\n{\n\tint fd = uncompress(path);\n\tif (fd == -1) {\n\t\tperror(path);\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn fdopen(fd, \"r\");\n}\n\ntypedef FILE* (*fopen_t)(const char *path, const char *mode);\n\n/** If the specified file is compressed, return a pipe that\n * uncompresses it.\n */\nFILE *fopen(const char *path, const char *mode)\n{\n\tstatic fopen_t real_fopen;\n\tif (real_fopen == NULL)\n\t\treal_fopen = (fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tif (real_fopen == NULL) {\n\t\tfprintf(stderr, \"error: dlsym fopen: %s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// open a web address\n\tif (wgetExec(path) != NULL)\n\t\treturn funcompress(path);\n\t\n\t// to check if the file exists, we need to attempt to open it\n\tFILE* stream = real_fopen(path, mode);\n\tif (string(mode) != \"r\" || !stream || zcatExec(path) == NULL)\n\t\treturn stream;\n\telse {\n\t\tfclose(stream);\n\t\treturn funcompress(path);\n\t}\n}\n\n/** If the specified file is compressed, return a pipe that\n * uncompresses it.\n */\nFILE *fopen64(const char *path, const char *mode)\n{\n\tstatic fopen_t real_fopen64;\n\tif (real_fopen64 == NULL)\n\t\treal_fopen64 = (fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\tif (real_fopen64 == NULL) {\n\t\tfprintf(stderr, \"error: dlsym fopen64: %s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// open a web address\n\tif (wgetExec(path) != NULL)\n\t\treturn funcompress(path);\n\t\n\t// to check if the file exists, we need to attempt to open it\n\tFILE* stream = real_fopen64(path, mode);\n\tif (string(mode) != \"r\" || !stream || zcatExec(path) == NULL)\n\t\treturn stream;\n\telse {\n\t\tfclose(stream);\n\t\treturn funcompress(path);\n\t}\n}\n\ntypedef int (*open_t)(const char *path, int flags, mode_t mode);\n\n/** If the specified file is compressed, return a pipe that\n * uncompresses it.\n */\nint open(const char *path, int flags, mode_t mode)\n{\n\tstatic open_t real_open;\n\tif (real_open == NULL)\n\t\treal_open = (open_t)dlsym(RTLD_NEXT, \"open\");\n\tif (real_open == NULL) {\n\t\tfprintf(stderr, \"error: dlsym open: %s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// open a web address\n\tif (wgetExec(path) != NULL)\n\t\treturn uncompress(path);\n\t\n\t// to check if the file exists, we need to attempt to open it\n\tint filedesc = real_open(path, flags, mode);\n\tif (mode != ios_base::in || filedesc < 0\n\t\t\t|| zcatExec(path) == NULL)\n\t\treturn filedesc;\n\telse {\n\t\tclose(filedesc);\n\t\treturn uncompress(path);\n\t}\n}\n\n} // extern \"C\"\n\n#endif // HAVE_LIBDL\n\n/** Initialize the uncompress module. */\nbool uncompress_init()\n{\n#if HAVE_LIBDL\n\tsignalInit();\n#endif\n\treturn HAVE_LIBDL;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-abyss-2.1.4-zem2yfpgnu7lxrjuw7p4kayqd3gq6bwa/spack-src/dialign/parameters.h",
        "/tmp/vanessa/spack-stage/spack-stage-abyss-2.1.4-zem2yfpgnu7lxrjuw7p4kayqd3gq6bwa/spack-src/dialign/prob.c",
        "/tmp/vanessa/spack-stage/spack-stage-abyss-2.1.4-zem2yfpgnu7lxrjuw7p4kayqd3gq6bwa/spack-src/doc/flowchart_simplified.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-abyss-2.1.4-zem2yfpgnu7lxrjuw7p4kayqd3gq6bwa/spack-src/doc/flowchart.pdf"
    ],
    "total_files": 405
}