{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-abyss-1.5.2-vvabwsxv36cmfw2x72bsr2pkeo3jgybb/spack-src/configure.ac": "AC_PREREQ(2.62)\nAC_INIT(ABySS, 1.5.2, abyss-users@bcgsc.ca, abyss,\n\t\thttp://www.bcgsc.ca/platform/bioinfo/software/abyss)\nAM_INIT_AUTOMAKE(1.9.6 foreign subdir-objects)\nAC_CONFIG_SRCDIR([ABYSS/Abyss.cpp])\nAC_CONFIG_HEADER([config.h])\n\n# Checks for programs.\nAC_PROG_AWK\nAC_PROG_CC\nAC_PROG_CPP\nAC_PROG_CXX\nAC_PROG_INSTALL\nAC_PROG_RANLIB\nAC_CHECK_TOOL(GHC, ghc)\nAC_CHECK_TOOL(GHC_PKG, ghc-pkg)\nAM_CONDITIONAL([HAVE_GHC_MMAP], [\"$GHC_PKG\" list |grep -q mmap])\n\n# Checks for header files.\nAC_CHECK_HEADERS([dlfcn.h fcntl.h float.h limits.h \\\n\tstddef.h stdint.h stdlib.h sys/param.h])\nAC_HEADER_STDBOOL\nAC_HEADER_STDC\n\n# Checks for typedefs, structures, and compiler characteristics.\nAC_C_BIGENDIAN\nAC_C_CONST\nAC_C_INLINE\nAC_CHECK_TYPES([ptrdiff_t])\nAC_TYPE_MODE_T\nAC_TYPE_PID_T\nAC_TYPE_SIZE_T\nAC_TYPE_SSIZE_T\nAC_TYPE_INT64_T\nAC_TYPE_UINT8_T\nAC_TYPE_UINT16_T\nAC_TYPE_UINT32_T\nAC_TYPE_UINT64_T\n\n# Check for std::hash and std::tr1::hash.\nAC_LANG_PUSH([C++])\nAC_CHECK_TYPE([std::hash<int>],\n\tAC_DEFINE(HAVE_STD_HASH, [1],\n\t\t[Define if the system provides std::hash]),\n\t[], [\n#ifdef __FUJITSU\n#include <string>\n#else\n#include <functional>\n#endif])\nAC_CHECK_TYPE([std::tr1::hash<int>],\n\tAC_DEFINE(HAVE_STD_TR1_HASH, [1],\n\t\t[Define if the system provides std::tr1::hash]),\n\t[], [#include <tr1/functional>])\nAC_LANG_POP([C++])\n\n# Checks for library functions.\nAC_CHECK_FUNCS([dup2 gethostname getopt_long getpagesize \\\n\t\t\t\tmemset strdup strerror strtoul])\nAC_FUNC_FORK\nAC_FUNC_MALLOC\nAC_FUNC_MEMCMP\nAC_FUNC_REALLOC\nAC_FUNC_SETVBUF_REVERSED\nAC_FUNC_VPRINTF\n\n# Checks for library constants.\nAC_CHECK_DECL(HOST_NAME_MAX, [],\n\tAC_DEFINE(HOST_NAME_MAX, [_POSIX_HOST_NAME_MAX],\n\t\t\t  [Define if the system does not provide HOST_NAME_MAX]),\n\t[#include <limits.h>])\n\n# Options to configure.\n# Boost\nAC_ARG_WITH(boost, AS_HELP_STRING([--with-boost=PATH],\n\t\t\t[specify directory for the boost header files]))\nif test \"$with_boost\" -a -d \"$with_boost\"; then\n\tboost_cppflags=\"-isystem$with_boost\"\nfi\n# MPI\nAC_ARG_WITH(mpi, AS_HELP_STRING([--with-mpi=PATH],\n\t[specify prefix directory for the installed MPI parallel\n\tcomputing library]))\nif test \"$with_mpi\" -a -d \"$with_mpi\"; then\n\tmpi_cppflags=\"-isystem$with_mpi/include\"\n\tmpi_ldflags=\"-L$with_mpi/lib\"\nfi\n\n# GTest\nAC_ARG_WITH(gtest, AS_HELP_STRING([--with-gtest=PATH],\n\t[specify prefix directory for the installed gtest library]))\nif test \"$with_gtest\" -a -d \"$with_gtest\"; then\n\tgtest_cppflags=\"-I$with_gtest/include\"\n\tgtest_ldflags=\"-L$with_gtest/lib\"\nfi\n\nAC_ARG_ENABLE(mpich, AS_HELP_STRING([--enable-mpich],\n\t[use MPICH (default is to use Open MPI)]))\nAC_ARG_ENABLE(lammpi, AS_HELP_STRING([--enable-lammpi],\n\t[use LAM/MPI (default is to use Open MPI)]))\n\nAC_ARG_ENABLE(fm, AS_HELP_STRING([--enable-fm],\n\t[specify the width of the FM-index in bits (default is 64-bit)]),\n\t[], [enable_fm=64])\nAC_DEFINE_UNQUOTED(FMBITS, $enable_fm,\n\t\t\t\t   [Width of bits of the FM-index in bits])\n\nAC_ARG_ENABLE(maxk, AS_HELP_STRING([--enable-maxk=N],\n\t[set the maximum k-mer length (default is 64)]),\n\t[], [enable_maxk=64])\nAC_DEFINE_UNQUOTED(MAX_KMER, [$enable_maxk], [maximum k-mer length])\n\n# Find the absolute path to the source.\nmy_abs_srcdir=$(cd $srcdir; pwd)\n\n# Set compiler flags.\nboost_ver=1.55.0\nboost_ver_dir=boost_1_55_0\nAC_SUBST(CPPFLAGS,\n\t\t \"-I$my_abs_srcdir $boost_cppflags $mpi_cppflags $gtest_cppflags $CPPFLAGS -isystem$my_abs_srcdir/$boost_ver_dir\")\nAC_SUBST(LDFLAGS, \"$mpi_ldflags $gtest_ldflags $LDFLAGS\")\n\n# Check for the MPI parallel computing library.\nlibs=\"$LIBS\"\nAC_DEFINE(MPICH_SKIP_MPICXX, 1,\n\t\t  [Define to disable MPICH C++ bindings])\nAC_DEFINE(OMPI_SKIP_MPICXX, 1,\n\t\t  [Define to disable OpenMPI C++ bindings])\nAC_CHECK_HEADERS([mpi.h])\nif test \"$enable_mpich\"; then\n\tAC_CHECK_LIB([pthread], [pthread_create])\n\tAC_CHECK_LIB([mpl], [MPL_env2int])\n\tAC_CHECK_LIB([mpich], [MPI_Init])\n\tac_cv_lib_mpi_MPI_Init=$ac_cv_lib_mpich_MPI_Init\nelif test \"$enable_lammpi\"; then\n\tAC_CHECK_LIB([pthread], [pthread_create])\n\tAC_CHECK_LIB([dl], [dlopen])\n\tAC_CHECK_LIB([lam], [lam_mutex_lock])\n\tAC_CHECK_LIB([mpi], [MPI_Init])\n\tAC_LANG_PUSH([C++])\n\tAC_CHECK_LIB([lammpi++], [main]) \n\tAC_LANG_POP([C++])\nelse\n\tAC_CHECK_LIB([mpi], [MPI_Init])\nfi\nAM_CONDITIONAL([HAVE_LIBMPI],\n\t[test $ac_cv_header_mpi_h = yes -a $ac_cv_lib_mpi_MPI_Init = yes])\nAC_SUBST(MPI_LIBS, \"$LIBS\")\nLIBS=\"$libs\"\n\n# Check for the math library.\nAC_CHECK_LIB([m], [sqrt])\nAC_CHECK_FUNCS([pow sqrt])\nAC_CHECK_FUNC(ceilf, [], AC_DEFINE(ceilf, [ceil],\n\t\t\t  [Define if the system does not provide ceilf]))\n\n# Check for the dynamic linking library.\nAC_CHECK_LIB([dl], [dlsym])\n\n# Check for popcnt instruction.\nAC_COMPILE_IFELSE(\n\t[AC_LANG_PROGRAM([[#include <stdint.h>],\n\t\t\t\t\t  [uint64_t x = 0;]],\n\t\t\t\t\t [[__asm__(\"popcnt %1,%0\" : \"=r\" (x) : \"r\" (x));]])],\n\t[AC_DEFINE([HAVE_POPCNT], 1, [Define to 1 if you have popcnt.])],\n\t[AC_DEFINE([HAVE_POPCNT], 0, [Define to 0 if you do not have popcnt.])])\n\n# Check for the hash table implementation.\nAC_LANG([C++])\nAC_CHECK_HEADERS([ \\\n\tfunctional \\\n\ttr1/functional \\\n\tboost/functional/hash.hpp \\\n\tboost/property_map/property_map.hpp \\\n\tgoogle/sparse_hash_map \\\n\tunordered_map tr1/unordered_map \\\n\tunordered_set tr1/unordered_set \\\n\tboost/unordered_set.hpp \\\n])\n\n# Check for Boost.\nif test $ac_cv_header_boost_property_map_property_map_hpp != yes; then\n\tAC_MSG_ERROR([ABySS requires the Boost C++ libraries, which may\n\tbe downloaded from here: http://www.boost.org/users/download/\n\tIt is not necessary to compile Boost before installing it. The\n\tfollowing commands will download and install Boost for ABySS:\n\tcd $my_abs_srcdir\n\twget http://downloads.sourceforge.net/project/boost/boost/$boost_ver/$boost_ver_dir.tar.bz2\n\ttar jxf $boost_ver_dir.tar.bz2\n\tcd -])\nfi\n\n# Check for gtest\nlibs=\"$LIBS\"\nAC_CHECK_HEADERS([gtest/gtest.h])\nAC_CHECK_LIB([pthread], [pthread_create])\nAC_CHECK_LIB([gtest_main],[main])\nAM_CONDITIONAL([HAVE_GTEST], [test $ac_cv_header_gtest_gtest_h = yes -a $ac_cv_lib_gtest_main_main = yes])\nAC_SUBST(GTEST_LIBS, \"$LIBS\")\nLIBS=$libs\n\n# Check for OpenMP.\nAC_OPENMP\nif test -z $OPENMP_CXXFLAGS; then\n\tOPENMP_CXXFLAGS=-Wno-unknown-pragmas\nfi\n\n# Set compiler flags.\nAC_SUBST(AM_CXXFLAGS, '-Wall -Wextra -Werror')\n\nAC_CONFIG_FILES([\n\tMakefile\n\tABYSS/Makefile\n\tAlign/Makefile\n\tAssembly/Makefile\n\tCommon/Makefile\n\tDataLayer/Makefile\n\tFMIndex/Makefile\n\tGraph/Makefile\n\tParallel/Makefile\n\tbin/Makefile\n\tdoc/Makefile\n\tdialign/Makefile\n\tkmerprint/Makefile\n\tAdjList/Makefile\n\tKonnector/Makefile\n\tDAssembler/Makefile\n\tDistanceEst/Makefile\n\tLayout/Makefile\n\tMap/Makefile\n\tMisc/Makefile\n\tOverlap/Makefile\n\tPopBubbles/Makefile\n\tScaffold/Makefile\n\tSimpleGraph/Makefile\n\tMergePaths/Makefile\n\tKAligner/Makefile\n\tParseAligns/Makefile\n\tPathOverlap/Makefile\n\tConsensus/Makefile\n\tFilterGraph/Makefile\n\tGapFiller/Makefile\n\tUnittest/Makefile\n\tLogKmerCount/Makefile\n\tBloom/Makefile\n])\nAC_OUTPUT\n\nif test $ac_cv_header_google_sparse_hash_map != yes; then\n\tAC_MSG_WARN([ABySS should be compiled with Google sparsehash to\n\treduce memory usage. It may be downloaded here:\n\thttp://code.google.com/p/google-sparsehash])\nfi\n",
        "/tmp/vanessa/spack-stage/spack-stage-abyss-1.5.2-vvabwsxv36cmfw2x72bsr2pkeo3jgybb/spack-src/Common/Uncompress.cpp": "/** Uncompress input files using pipes.\n * Hook the standard file opening functions, open, fopen and fopen64.\n * If the extension of the file being opened indicates the file is\n * compressed (.gz, .bz2, .xz), open a pipe to a program that\n * decompresses that file (gunzip, bunzip2 or xzdec) and return a\n * handle to the open pipe.\n * @author Shaun Jackman <sjackman@bcgsc.ca>\n */\n\n#include \"config.h\"\n#if HAVE_LIBDL\n\n#include \"Fcontrol.h\"\n#include \"SignalHandler.h\"\n#include \"StringUtil.h\"\n#include <cassert>\n#include <cstdio> // for perror\n#include <cstdlib>\n#include <dlfcn.h>\n#include <string>\n#include <unistd.h>\n\nusing namespace std;\n\nstatic const char* wgetExec(const string& path)\n{\n\treturn\n\t\tstartsWith(path, \"http://\") ? \"wget -O-\" :\n\t\tstartsWith(path, \"https://\") ? \"wget -O-\" :\n\t\tstartsWith(path, \"ftp://\") ? \"wget -O-\" :\n\t\tNULL;\n}\n\nstatic const char* zcatExec(const string& path)\n{\n\treturn\n\t\tendsWith(path, \".ar\") ? \"ar -p\" :\n\t\tendsWith(path, \".tar\") ? \"tar -xOf\" :\n\t\tendsWith(path, \".tar.Z\") ? \"tar -zxOf\" :\n\t\tendsWith(path, \".tar.gz\") ? \"tar -zxOf\" :\n\t\tendsWith(path, \".tar.bz2\") ? \"tar -jxOf\" :\n\t\tendsWith(path, \".tar.xz\") ?\n\t\t\t\"tar --use-compress-program=xzdec -xOf\" :\n\t\tendsWith(path, \".Z\") ? \"gunzip -c\" :\n\t\tendsWith(path, \".gz\") ? \"gunzip -c\" :\n\t\tendsWith(path, \".bz2\") ? \"bunzip2 -c\" :\n\t\tendsWith(path, \".xz\") ? \"xzdec -c\" :\n\t\tendsWith(path, \".zip\") ? \"unzip -p\" :\n\t\tendsWith(path, \".bam\") ? \"samtools view -h\" :\n\t\tendsWith(path, \".jf\") ? \"jellyfish dump\" :\n\t\tendsWith(path, \".jfq\") ? \"jellyfish qdump\" :\n\t\tendsWith(path, \".sra\") ? \"fastq-dump -Z --split-spot\" :\n\t\tendsWith(path, \".url\") ? \"wget -O- -i\" :\n\t        endsWith(path, \".fqz\") ? \"fqz_comp -d\" :\n\t\tNULL;\n}\n\nextern \"C\" {\n\n/** Open a pipe to uncompress the specified file.\n * Not thread safe.\n * @return a file descriptor\n */\nstatic int uncompress(const char *path)\n{\n\tconst char *wget = wgetExec(path);\n\tconst char *zcat = wget != NULL ? wget : zcatExec(path);\n\tassert(zcat != NULL);\n\n\tint fd[2];\n\tif (pipe(fd) == -1)\n\t\treturn -1;\n\tint err = setCloexec(fd[0]);\n\tassert(err == 0);\n\t(void)err;\n\n\tchar arg0[16], arg1[16], arg2[16];\n\tint n = sscanf(zcat, \"%s %s %s\", arg0, arg1, arg2);\n\tassert(n == 2 || n == 3);\n\n\t/* It would be more portable to use fork than vfork, but fork can\n\t * fail with ENOMEM when the process calling fork is using a lot\n\t * of memory. A workaround for this problem is to set\n\t * sysctl vm.overcommit_memory=1\n\t */\n#if HAVE_WORKING_VFORK\n\tpid_t pid = vfork();\n#else\n\tpid_t pid = fork();\n#endif\n\tif (pid == -1)\n\t\treturn -1;\n\n\tif (pid == 0) {\n\t\tdup2(fd[1], STDOUT_FILENO);\n\t\tclose(fd[1]);\n\t\tif (n == 2)\n\t\t\texeclp(arg0, arg0, arg1, path, NULL);\n\t\telse\n\t\t\texeclp(arg0, arg0, arg1, arg2, path, NULL);\n\t\t// Calling perror after vfork is not allowed, but we're about\n\t\t// to exit and an error message would be really helpful.\n\t\tperror(arg0);\n\t\t_exit(EXIT_FAILURE);\n\t} else {\n\t\tclose(fd[1]);\n\t\treturn fd[0];\n\t}\n}\n\n/** Open a pipe to uncompress the specified file.\n * @return a FILE pointer\n */\nstatic FILE* funcompress(const char* path)\n{\n\tint fd = uncompress(path);\n\tif (fd == -1) {\n\t\tperror(path);\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn fdopen(fd, \"r\");\n}\n\ntypedef FILE* (*fopen_t)(const char *path, const char *mode);\n\n/** If the specified file is compressed, return a pipe that\n * uncompresses it.\n */\nFILE *fopen(const char *path, const char *mode)\n{\n\tstatic fopen_t real_fopen;\n\tif (real_fopen == NULL)\n\t\treal_fopen = (fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tif (real_fopen == NULL) {\n\t\tfprintf(stderr, \"error: dlsym fopen: %s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// open a web address\n\tif (wgetExec(path) != NULL)\n\t\treturn funcompress(path);\n\t\n\t// to check if the file exists, we need to attempt to open it\n\tFILE* stream = real_fopen(path, mode);\n\tif (string(mode) != \"r\" || !stream || zcatExec(path) == NULL)\n\t\treturn stream;\n\telse {\n\t\tfclose(stream);\n\t\treturn funcompress(path);\n\t}\n}\n\n/** If the specified file is compressed, return a pipe that\n * uncompresses it.\n */\nFILE *fopen64(const char *path, const char *mode)\n{\n\tstatic fopen_t real_fopen64;\n\tif (real_fopen64 == NULL)\n\t\treal_fopen64 = (fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\tif (real_fopen64 == NULL) {\n\t\tfprintf(stderr, \"error: dlsym fopen64: %s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// open a web address\n\tif (wgetExec(path) != NULL)\n\t\treturn funcompress(path);\n\t\n\t// to check if the file exists, we need to attempt to open it\n\tFILE* stream = real_fopen64(path, mode);\n\tif (string(mode) != \"r\" || !stream || zcatExec(path) == NULL)\n\t\treturn stream;\n\telse {\n\t\tfclose(stream);\n\t\treturn funcompress(path);\n\t}\n}\n\ntypedef int (*open_t)(const char *path, int flags, mode_t mode);\n\n/** If the specified file is compressed, return a pipe that\n * uncompresses it.\n */\nint open(const char *path, int flags, mode_t mode)\n{\n\tstatic open_t real_open;\n\tif (real_open == NULL)\n\t\treal_open = (open_t)dlsym(RTLD_NEXT, \"open\");\n\tif (real_open == NULL) {\n\t\tfprintf(stderr, \"error: dlsym open: %s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// open a web address\n\tif (wgetExec(path) != NULL)\n\t\treturn uncompress(path);\n\t\n\t// to check if the file exists, we need to attempt to open it\n\tint filedesc = real_open(path, flags, mode);\n\tif (mode != ios_base::in || filedesc < 0\n\t\t\t|| zcatExec(path) == NULL)\n\t\treturn filedesc;\n\telse {\n\t\tclose(filedesc);\n\t\treturn uncompress(path);\n\t}\n}\n\n} // extern \"C\"\n\n#endif // HAVE_LIBDL\n\n/** Initialize the uncompress module. */\nbool uncompress_init()\n{\n#if HAVE_LIBDL\n\tsignalInit();\n#endif\n\treturn HAVE_LIBDL;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-abyss-1.5.2-vvabwsxv36cmfw2x72bsr2pkeo3jgybb/spack-src/dialign/parameters.h",
        "/tmp/vanessa/spack-stage/spack-stage-abyss-1.5.2-vvabwsxv36cmfw2x72bsr2pkeo3jgybb/spack-src/dialign/prob.c",
        "/tmp/vanessa/spack-stage/spack-stage-abyss-1.5.2-vvabwsxv36cmfw2x72bsr2pkeo3jgybb/spack-src/doc/flowchart_simplified.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-abyss-1.5.2-vvabwsxv36cmfw2x72bsr2pkeo3jgybb/spack-src/doc/flowchart.pdf"
    ],
    "total_files": 296
}