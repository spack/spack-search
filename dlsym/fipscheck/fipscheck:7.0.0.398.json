{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-fipscheck-7.0.0.398-mrhelk3uszeyyzy4wovniyg672k3txef/spack-src/src/library.c": "/* library.c */\n/*\n * Copyright (C) 2008, 2009, 2013 Red Hat Inc. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY RED HAT, INC. ''AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * The views and conclusions contained in the software and documentation are those\n * of the authors and should not be interpreted as representing official policies,\n * either expressed or implied, of Red Hat, Inc.\n */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#include \"fipscheck.h\"\n#include \"filehmac.h\"\n\n#define MAX_PATH_LEN 4096\n#define SELFLINK \"/proc/self/exe\"\n#ifndef PATH_FIPSCHECK\n#define PATH_FIPSCHECK \"/usr/bin/fipscheck\"\n#endif\n#define FIPS_MODE_SWITCH_FILE \"/proc/sys/crypto/fips_enabled\"\n\nint\nFIPSCHECK_get_binary_path(char *path, size_t pathlen)\n{\n\tssize_t len;\n\n\tlen = readlink(SELFLINK, path, pathlen-1);\n\t\n\tif (len < 0) {\n\t\treturn -1;\n\t}\n\t\n\tpath[len] = '\\0';\n\treturn 0;\n}\n\n\nint\nFIPSCHECK_get_library_path(const char *libname, const char *symbolname, char *path, size_t pathlen)\n{\n\tDl_info info;\n\tvoid *dl, *sym;\n\tint rv = -1;\n\n        dl = dlopen(libname, RTLD_NODELETE|RTLD_NOLOAD|RTLD_LAZY);\n        if (dl == NULL) {\n\t        return -1;\n        }       \n\n\tsym = dlsym(dl, symbolname);\n\n\tif (sym != NULL && dladdr(sym, &info)) {\n\t\tstrncpy(path, info.dli_fname, pathlen-1);\n\t\tpath[pathlen-1] = '\\0';\n\t\trv = 0;\n\t}\n\n\tdlclose(dl);\n\t\n\treturn rv;\n}\n\n\nstatic int\nrun_fipscheck_helper(const char *hmac_suffix, const char *paths[])\n{\n\tint rv = -1, child;\n\tvoid (*sighandler)(int) = NULL;\n\n\tsighandler = signal(SIGCHLD, SIG_DFL);\n\n\t/* fork */\n\tchild = fork();\n\tif (child == 0) {\n\t\tstatic char *envp[] = { NULL };\n\t\tchar **args;\n\t\tint i, offset = 1;\n\n\t\tfor (i = 0; paths[i] != NULL; i++);\n\n\t\tif (i < 1) /* nothing to check */\n\t\t\t_exit(127);\n\n\t\targs = calloc(i + 4, sizeof(*args));\n\n\t\tif (args == NULL)\n\t\t\t_exit(127);\n\n\t\targs[0] = PATH_FIPSCHECK;\n\t\tif (hmac_suffix) {\n\t\t\targs[1] = \"-s\";\n\t\t\targs[2] = (char *)hmac_suffix;\n\t\t\toffset = 3;\n\t\t}\n\t\tmemcpy(&args[offset], paths, sizeof(*args)*(i + 1));\n\n\t\texecve(PATH_FIPSCHECK, args, envp);\n\n\t\t/* if we get here: exit with error */\n\t\t_exit(127);\n\n\t} else if (child > 0) {\n\t\tint status;\n\n\t\twhile ((rv=waitpid(child, &status, 0)) == -1 &&   /* wait for fipscheck to complete */\n\t\t\terrno == EINTR);\n\t\tif (rv > 0 && WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t\trv = 0;\n\t\t} else {\n\t\t\trv = -1;\n\t\t}\n\t} /* else failed fork */\n\n\tif (sighandler != SIG_ERR) {\n\t\t(void) signal(SIGCHLD, sighandler);   /* restore old signal handler */\n\t}\n\n\treturn rv;\n}\n\nstatic int\ntest_hmac_installed(const char *path, const char *hmac_suffix)\n{\n\tconst char *hmacdir = PATH_HMACDIR;\n\tchar *hmacpath;\n\tint rv;\n\n\tdo {\n\t\thmacpath = make_hmac_path(path, hmacdir, hmac_suffix);\n\t\tif (hmacpath == NULL) {\n\t\t\t/* we must fail later */\n\t\t\treturn 1;\n\t\t}\n\n\t\trv = access(hmacpath, F_OK);\n\t\tif (rv < 0 && errno != ENOENT) {\n\t\t\trv = 0;\n\t\t}\n\n\t\tfree(hmacpath);\n\n\t\tif (rv < 0 && hmacdir == NULL) {\n\t\t\t/* hmac not found */\n\t\t\treturn 0;\n\t\t}\n\n\t\thmacdir = NULL;\n        } while (rv < 0);\n\t/* hmac found */\n        return 1;\n}\n\nint\nFIPSCHECK_verify(const char *libname, const char *symbolname)\n{\n\treturn FIPSCHECK_verify_ex(libname, symbolname, NULL, 1);\n}\n\nint\nFIPSCHECK_verify_ex(const char *libname, const char *symbolname, const char *hmac_suffix, int fail_if_missing)\n{\n\tchar path[MAX_PATH_LEN];\n\tconst char *files[] = {path, NULL};\n\tint rv;\n\n\tif (libname == NULL || symbolname == NULL) {\n\t\trv = FIPSCHECK_get_binary_path(path, sizeof(path));\n\t} else {\n\t\trv = FIPSCHECK_get_library_path(libname, symbolname, path, sizeof(path));\n\t}\n\n\tif (rv < 0)\n\t\treturn 0;\n\n\tif (!fail_if_missing && !test_hmac_installed(path, hmac_suffix))\n\t\treturn 1;\n\n\trv = run_fipscheck_helper(hmac_suffix, files);\n\n\tif (rv < 0)\n\t\treturn 0;\n\n\t/* check successful */\n\treturn 1;\n}\n\nint\nFIPSCHECK_verify_files(const char *files[])\n{\n\treturn FIPSCHECK_verify_files_ex(NULL, 1, files);\n}\n\nint\nFIPSCHECK_verify_files_ex(const char *hmac_suffix, int fail_if_missing, const char *files[])\n{\n\tint rv;\n\n\tif (!fail_if_missing && !test_hmac_installed(files[0], hmac_suffix))\n\t\treturn 1;\n\n\trv = run_fipscheck_helper(hmac_suffix, files);\n\n\tif (rv < 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nint\nFIPSCHECK_fips_module_installed(const char *libname, const char *symbolname, const char *hmac_suffix)\n{\n\tchar path[MAX_PATH_LEN];\n\tint rv;\n\n\tif (libname == NULL || symbolname == NULL) {\n\t\trv = FIPSCHECK_get_binary_path(path, sizeof(path));\n\t} else {\n\t\trv = FIPSCHECK_get_library_path(libname, symbolname, path, sizeof(path));\n\t}\n\n\tif (rv < 0)\n\t\t/* Fail safe - that is as if the module was installed */\n\t\treturn 1;\n\n\treturn test_hmac_installed(path, hmac_suffix);\n}\n\nint\nFIPSCHECK_kernel_fips_mode(void)\n{\n\tint fd;\n\tchar buf[1] = \"\";\n\n\tif ((fd=open(FIPS_MODE_SWITCH_FILE, O_RDONLY)) >= 0) {\n\t\twhile (read(fd, buf, sizeof(buf)) < 0 && errno == EINTR);\n\t\tclose(fd);\n\t}\n\tif (buf[0] == '1')\n\t\treturn 1;\n\treturn 0;\n}\n"
    },
    "skipped": [],
    "total_files": 18
}