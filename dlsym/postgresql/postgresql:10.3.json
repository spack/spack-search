{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/include/fmgr.h": "/*-------------------------------------------------------------------------\n *\n * fmgr.h\n *\t  Definitions for the Postgres function manager and function-call\n *\t  interface.\n *\n * This file must be included by all Postgres modules that either define\n * or call fmgr-callable functions.\n *\n *\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/include/fmgr.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef FMGR_H\n#define FMGR_H\n\n/* We don't want to include primnodes.h here, so make some stub references */\ntypedef struct Node *fmNodePtr;\ntypedef struct Aggref *fmAggrefPtr;\n\n/* Likewise, avoid including execnodes.h here */\ntypedef void (*fmExprContextCallbackFunction) (Datum arg);\n\n/* Likewise, avoid including stringinfo.h here */\ntypedef struct StringInfoData *fmStringInfo;\n\n\n/*\n * All functions that can be called directly by fmgr must have this signature.\n * (Other functions can be called by using a handler that does have this\n * signature.)\n */\n\ntypedef struct FunctionCallInfoData *FunctionCallInfo;\n\ntypedef Datum (*PGFunction) (FunctionCallInfo fcinfo);\n\n/*\n * This struct holds the system-catalog information that must be looked up\n * before a function can be called through fmgr.  If the same function is\n * to be called multiple times, the lookup need be done only once and the\n * info struct saved for re-use.\n *\n * Note that fn_expr really is parse-time-determined information about the\n * arguments, rather than about the function itself.  But it's convenient\n * to store it here rather than in FunctionCallInfoData, where it might more\n * logically belong.\n *\n * fn_extra is available for use by the called function; all other fields\n * should be treated as read-only after the struct is created.\n */\ntypedef struct FmgrInfo\n{\n\tPGFunction\tfn_addr;\t\t/* pointer to function or handler to be called */\n\tOid\t\t\tfn_oid;\t\t\t/* OID of function (NOT of handler, if any) */\n\tshort\t\tfn_nargs;\t\t/* number of input args (0..FUNC_MAX_ARGS) */\n\tbool\t\tfn_strict;\t\t/* function is \"strict\" (NULL in => NULL out) */\n\tbool\t\tfn_retset;\t\t/* function returns a set */\n\tunsigned char fn_stats;\t\t/* collect stats if track_functions > this */\n\tvoid\t   *fn_extra;\t\t/* extra space for use by handler */\n\tMemoryContext fn_mcxt;\t\t/* memory context to store fn_extra in */\n\tfmNodePtr\tfn_expr;\t\t/* expression parse tree for call, or NULL */\n} FmgrInfo;\n\n/*\n * This struct is the data actually passed to an fmgr-called function.\n *\n * The called function is expected to set isnull, and possibly resultinfo or\n * fields in whatever resultinfo points to.  It should not change any other\n * fields.  (In particular, scribbling on the argument arrays is a bad idea,\n * since some callers assume they can re-call with the same arguments.)\n */\ntypedef struct FunctionCallInfoData\n{\n\tFmgrInfo   *flinfo;\t\t\t/* ptr to lookup info used for this call */\n\tfmNodePtr\tcontext;\t\t/* pass info about context of call */\n\tfmNodePtr\tresultinfo;\t\t/* pass or return extra info about result */\n\tOid\t\t\tfncollation;\t/* collation for function to use */\n\tbool\t\tisnull;\t\t\t/* function must set true if result is NULL */\n\tshort\t\tnargs;\t\t\t/* # arguments actually passed */\n\tDatum\t\targ[FUNC_MAX_ARGS]; /* Arguments passed to function */\n\tbool\t\targnull[FUNC_MAX_ARGS]; /* T if arg[i] is actually NULL */\n} FunctionCallInfoData;\n\n/*\n * This routine fills a FmgrInfo struct, given the OID\n * of the function to be called.\n */\nextern void fmgr_info(Oid functionId, FmgrInfo *finfo);\n\n/*\n * Same, when the FmgrInfo struct is in a memory context longer-lived than\n * CurrentMemoryContext.  The specified context will be set as fn_mcxt\n * and used to hold all subsidiary data of finfo.\n */\nextern void fmgr_info_cxt(Oid functionId, FmgrInfo *finfo,\n\t\t\t  MemoryContext mcxt);\n\n/* Convenience macro for setting the fn_expr field */\n#define fmgr_info_set_expr(expr, finfo) \\\n\t((finfo)->fn_expr = (expr))\n\n/*\n * Copy an FmgrInfo struct\n */\nextern void fmgr_info_copy(FmgrInfo *dstinfo, FmgrInfo *srcinfo,\n\t\t\t   MemoryContext destcxt);\n\n/*\n * This macro initializes all the fields of a FunctionCallInfoData except\n * for the arg[] and argnull[] arrays.  Performance testing has shown that\n * the fastest way to set up argnull[] for small numbers of arguments is to\n * explicitly set each required element to false, so we don't try to zero\n * out the argnull[] array in the macro.\n */\n#define InitFunctionCallInfoData(Fcinfo, Flinfo, Nargs, Collation, Context, Resultinfo) \\\n\tdo { \\\n\t\t(Fcinfo).flinfo = (Flinfo); \\\n\t\t(Fcinfo).context = (Context); \\\n\t\t(Fcinfo).resultinfo = (Resultinfo); \\\n\t\t(Fcinfo).fncollation = (Collation); \\\n\t\t(Fcinfo).isnull = false; \\\n\t\t(Fcinfo).nargs = (Nargs); \\\n\t} while (0)\n\n/*\n * This macro invokes a function given a filled-in FunctionCallInfoData\n * struct.  The macro result is the returned Datum --- but note that\n * caller must still check fcinfo->isnull!\tAlso, if function is strict,\n * it is caller's responsibility to verify that no null arguments are present\n * before calling.\n */\n#define FunctionCallInvoke(fcinfo)\t((* (fcinfo)->flinfo->fn_addr) (fcinfo))\n\n\n/*-------------------------------------------------------------------------\n *\t\tSupport macros to ease writing fmgr-compatible functions\n *\n * A C-coded fmgr-compatible function should be declared as\n *\n *\t\tDatum\n *\t\tfunction_name(PG_FUNCTION_ARGS)\n *\t\t{\n *\t\t\t...\n *\t\t}\n *\n * It should access its arguments using appropriate PG_GETARG_xxx macros\n * and should return its result using PG_RETURN_xxx.\n *\n *-------------------------------------------------------------------------\n */\n\n/* Standard parameter list for fmgr-compatible functions */\n#define PG_FUNCTION_ARGS\tFunctionCallInfo fcinfo\n\n/*\n * Get collation function should use.\n */\n#define PG_GET_COLLATION()\t(fcinfo->fncollation)\n\n/*\n * Get number of arguments passed to function.\n */\n#define PG_NARGS() (fcinfo->nargs)\n\n/*\n * If function is not marked \"proisstrict\" in pg_proc, it must check for\n * null arguments using this macro.  Do not try to GETARG a null argument!\n */\n#define PG_ARGISNULL(n)  (fcinfo->argnull[n])\n\n/*\n * Support for fetching detoasted copies of toastable datatypes (all of\n * which are varlena types).  pg_detoast_datum() gives you either the input\n * datum (if not toasted) or a detoasted copy allocated with palloc().\n * pg_detoast_datum_copy() always gives you a palloc'd copy --- use it\n * if you need a modifiable copy of the input.  Caller is expected to have\n * checked for null inputs first, if necessary.\n *\n * pg_detoast_datum_packed() will return packed (1-byte header) datums\n * unmodified.  It will still expand an externally toasted or compressed datum.\n * The resulting datum can be accessed using VARSIZE_ANY() and VARDATA_ANY()\n * (beware of multiple evaluations in those macros!)\n *\n * In consumers oblivious to data alignment, call PG_DETOAST_DATUM_PACKED(),\n * VARDATA_ANY(), VARSIZE_ANY() and VARSIZE_ANY_EXHDR().  Elsewhere, call\n * PG_DETOAST_DATUM(), VARDATA() and VARSIZE().  Directly fetching an int16,\n * int32 or wider field in the struct representing the datum layout requires\n * aligned data.  memcpy() is alignment-oblivious, as are most operations on\n * datatypes, such as text, whose layout struct contains only char fields.\n *\n * Note: it'd be nice if these could be macros, but I see no way to do that\n * without evaluating the arguments multiple times, which is NOT acceptable.\n */\nextern struct varlena *pg_detoast_datum(struct varlena *datum);\nextern struct varlena *pg_detoast_datum_copy(struct varlena *datum);\nextern struct varlena *pg_detoast_datum_slice(struct varlena *datum,\n\t\t\t\t\t   int32 first, int32 count);\nextern struct varlena *pg_detoast_datum_packed(struct varlena *datum);\n\n#define PG_DETOAST_DATUM(datum) \\\n\tpg_detoast_datum((struct varlena *) DatumGetPointer(datum))\n#define PG_DETOAST_DATUM_COPY(datum) \\\n\tpg_detoast_datum_copy((struct varlena *) DatumGetPointer(datum))\n#define PG_DETOAST_DATUM_SLICE(datum,f,c) \\\n\t\tpg_detoast_datum_slice((struct varlena *) DatumGetPointer(datum), \\\n\t\t(int32) (f), (int32) (c))\n/* WARNING -- unaligned pointer */\n#define PG_DETOAST_DATUM_PACKED(datum) \\\n\tpg_detoast_datum_packed((struct varlena *) DatumGetPointer(datum))\n\n/*\n * Support for cleaning up detoasted copies of inputs.  This must only\n * be used for pass-by-ref datatypes, and normally would only be used\n * for toastable types.  If the given pointer is different from the\n * original argument, assume it's a palloc'd detoasted copy, and pfree it.\n * NOTE: most functions on toastable types do not have to worry about this,\n * but we currently require that support functions for indexes not leak\n * memory.\n */\n#define PG_FREE_IF_COPY(ptr,n) \\\n\tdo { \\\n\t\tif ((Pointer) (ptr) != PG_GETARG_POINTER(n)) \\\n\t\t\tpfree(ptr); \\\n\t} while (0)\n\n/* Macros for fetching arguments of standard types */\n\n#define PG_GETARG_DATUM(n)\t (fcinfo->arg[n])\n#define PG_GETARG_INT32(n)\t DatumGetInt32(PG_GETARG_DATUM(n))\n#define PG_GETARG_UINT32(n)  DatumGetUInt32(PG_GETARG_DATUM(n))\n#define PG_GETARG_INT16(n)\t DatumGetInt16(PG_GETARG_DATUM(n))\n#define PG_GETARG_UINT16(n)  DatumGetUInt16(PG_GETARG_DATUM(n))\n#define PG_GETARG_CHAR(n)\t DatumGetChar(PG_GETARG_DATUM(n))\n#define PG_GETARG_BOOL(n)\t DatumGetBool(PG_GETARG_DATUM(n))\n#define PG_GETARG_OID(n)\t DatumGetObjectId(PG_GETARG_DATUM(n))\n#define PG_GETARG_POINTER(n) DatumGetPointer(PG_GETARG_DATUM(n))\n#define PG_GETARG_CSTRING(n) DatumGetCString(PG_GETARG_DATUM(n))\n#define PG_GETARG_NAME(n)\t DatumGetName(PG_GETARG_DATUM(n))\n/* these macros hide the pass-by-reference-ness of the datatype: */\n#define PG_GETARG_FLOAT4(n)  DatumGetFloat4(PG_GETARG_DATUM(n))\n#define PG_GETARG_FLOAT8(n)  DatumGetFloat8(PG_GETARG_DATUM(n))\n#define PG_GETARG_INT64(n)\t DatumGetInt64(PG_GETARG_DATUM(n))\n/* use this if you want the raw, possibly-toasted input datum: */\n#define PG_GETARG_RAW_VARLENA_P(n)\t((struct varlena *) PG_GETARG_POINTER(n))\n/* use this if you want the input datum de-toasted: */\n#define PG_GETARG_VARLENA_P(n) PG_DETOAST_DATUM(PG_GETARG_DATUM(n))\n/* and this if you can handle 1-byte-header datums: */\n#define PG_GETARG_VARLENA_PP(n) PG_DETOAST_DATUM_PACKED(PG_GETARG_DATUM(n))\n/* DatumGetFoo macros for varlena types will typically look like this: */\n#define DatumGetByteaPP(X)\t\t\t((bytea *) PG_DETOAST_DATUM_PACKED(X))\n#define DatumGetTextPP(X)\t\t\t((text *) PG_DETOAST_DATUM_PACKED(X))\n#define DatumGetBpCharPP(X)\t\t\t((BpChar *) PG_DETOAST_DATUM_PACKED(X))\n#define DatumGetVarCharPP(X)\t\t((VarChar *) PG_DETOAST_DATUM_PACKED(X))\n#define DatumGetHeapTupleHeader(X)\t((HeapTupleHeader) PG_DETOAST_DATUM(X))\n/* And we also offer variants that return an OK-to-write copy */\n#define DatumGetByteaPCopy(X)\t\t((bytea *) PG_DETOAST_DATUM_COPY(X))\n#define DatumGetTextPCopy(X)\t\t((text *) PG_DETOAST_DATUM_COPY(X))\n#define DatumGetBpCharPCopy(X)\t\t((BpChar *) PG_DETOAST_DATUM_COPY(X))\n#define DatumGetVarCharPCopy(X)\t\t((VarChar *) PG_DETOAST_DATUM_COPY(X))\n#define DatumGetHeapTupleHeaderCopy(X)\t((HeapTupleHeader) PG_DETOAST_DATUM_COPY(X))\n/* Variants which return n bytes starting at pos. m */\n#define DatumGetByteaPSlice(X,m,n)\t((bytea *) PG_DETOAST_DATUM_SLICE(X,m,n))\n#define DatumGetTextPSlice(X,m,n)\t((text *) PG_DETOAST_DATUM_SLICE(X,m,n))\n#define DatumGetBpCharPSlice(X,m,n) ((BpChar *) PG_DETOAST_DATUM_SLICE(X,m,n))\n#define DatumGetVarCharPSlice(X,m,n) ((VarChar *) PG_DETOAST_DATUM_SLICE(X,m,n))\n/* GETARG macros for varlena types will typically look like this: */\n#define PG_GETARG_BYTEA_PP(n)\t\tDatumGetByteaPP(PG_GETARG_DATUM(n))\n#define PG_GETARG_TEXT_PP(n)\t\tDatumGetTextPP(PG_GETARG_DATUM(n))\n#define PG_GETARG_BPCHAR_PP(n)\t\tDatumGetBpCharPP(PG_GETARG_DATUM(n))\n#define PG_GETARG_VARCHAR_PP(n)\t\tDatumGetVarCharPP(PG_GETARG_DATUM(n))\n#define PG_GETARG_HEAPTUPLEHEADER(n)\tDatumGetHeapTupleHeader(PG_GETARG_DATUM(n))\n/* And we also offer variants that return an OK-to-write copy */\n#define PG_GETARG_BYTEA_P_COPY(n)\tDatumGetByteaPCopy(PG_GETARG_DATUM(n))\n#define PG_GETARG_TEXT_P_COPY(n)\tDatumGetTextPCopy(PG_GETARG_DATUM(n))\n#define PG_GETARG_BPCHAR_P_COPY(n)\tDatumGetBpCharPCopy(PG_GETARG_DATUM(n))\n#define PG_GETARG_VARCHAR_P_COPY(n) DatumGetVarCharPCopy(PG_GETARG_DATUM(n))\n#define PG_GETARG_HEAPTUPLEHEADER_COPY(n)\tDatumGetHeapTupleHeaderCopy(PG_GETARG_DATUM(n))\n/* And a b-byte slice from position a -also OK to write */\n#define PG_GETARG_BYTEA_P_SLICE(n,a,b) DatumGetByteaPSlice(PG_GETARG_DATUM(n),a,b)\n#define PG_GETARG_TEXT_P_SLICE(n,a,b)  DatumGetTextPSlice(PG_GETARG_DATUM(n),a,b)\n#define PG_GETARG_BPCHAR_P_SLICE(n,a,b) DatumGetBpCharPSlice(PG_GETARG_DATUM(n),a,b)\n#define PG_GETARG_VARCHAR_P_SLICE(n,a,b) DatumGetVarCharPSlice(PG_GETARG_DATUM(n),a,b)\n/*\n * Obsolescent variants that guarantee INT alignment for the return value.\n * Few operations on these particular types need alignment, mainly operations\n * that cast the VARDATA pointer to a type like int16[].  Most code should use\n * the ...PP(X) counterpart.  Nonetheless, these appear frequently in code\n * predating the PostgreSQL 8.3 introduction of the ...PP(X) variants.\n */\n#define DatumGetByteaP(X)\t\t\t((bytea *) PG_DETOAST_DATUM(X))\n#define DatumGetTextP(X)\t\t\t((text *) PG_DETOAST_DATUM(X))\n#define DatumGetBpCharP(X)\t\t\t((BpChar *) PG_DETOAST_DATUM(X))\n#define DatumGetVarCharP(X)\t\t\t((VarChar *) PG_DETOAST_DATUM(X))\n#define PG_GETARG_BYTEA_P(n)\t\tDatumGetByteaP(PG_GETARG_DATUM(n))\n#define PG_GETARG_TEXT_P(n)\t\t\tDatumGetTextP(PG_GETARG_DATUM(n))\n#define PG_GETARG_BPCHAR_P(n)\t\tDatumGetBpCharP(PG_GETARG_DATUM(n))\n#define PG_GETARG_VARCHAR_P(n)\t\tDatumGetVarCharP(PG_GETARG_DATUM(n))\n\n/* To return a NULL do this: */\n#define PG_RETURN_NULL()  \\\n\tdo { fcinfo->isnull = true; return (Datum) 0; } while (0)\n\n/* A few internal functions return void (which is not the same as NULL!) */\n#define PG_RETURN_VOID()\t return (Datum) 0\n\n/* Macros for returning results of standard types */\n\n#define PG_RETURN_DATUM(x)\t return (x)\n#define PG_RETURN_INT32(x)\t return Int32GetDatum(x)\n#define PG_RETURN_UINT32(x)  return UInt32GetDatum(x)\n#define PG_RETURN_INT16(x)\t return Int16GetDatum(x)\n#define PG_RETURN_UINT16(x)  return UInt16GetDatum(x)\n#define PG_RETURN_CHAR(x)\t return CharGetDatum(x)\n#define PG_RETURN_BOOL(x)\t return BoolGetDatum(x)\n#define PG_RETURN_OID(x)\t return ObjectIdGetDatum(x)\n#define PG_RETURN_POINTER(x) return PointerGetDatum(x)\n#define PG_RETURN_CSTRING(x) return CStringGetDatum(x)\n#define PG_RETURN_NAME(x)\t return NameGetDatum(x)\n/* these macros hide the pass-by-reference-ness of the datatype: */\n#define PG_RETURN_FLOAT4(x)  return Float4GetDatum(x)\n#define PG_RETURN_FLOAT8(x)  return Float8GetDatum(x)\n#define PG_RETURN_INT64(x)\t return Int64GetDatum(x)\n/* RETURN macros for other pass-by-ref types will typically look like this: */\n#define PG_RETURN_BYTEA_P(x)   PG_RETURN_POINTER(x)\n#define PG_RETURN_TEXT_P(x)    PG_RETURN_POINTER(x)\n#define PG_RETURN_BPCHAR_P(x)  PG_RETURN_POINTER(x)\n#define PG_RETURN_VARCHAR_P(x) PG_RETURN_POINTER(x)\n#define PG_RETURN_HEAPTUPLEHEADER(x)  return HeapTupleHeaderGetDatum(x)\n\n\n/*-------------------------------------------------------------------------\n *\t\tSupport for detecting call convention of dynamically-loaded functions\n *\n * Dynamically loaded functions currently can only use the version-1 (\"new\n * style\") calling convention.  Version-0 (\"old style\") is not supported\n * anymore.  Version 1 is the call convention defined in this header file, and\n * must be accompanied by the macro call\n *\n *\t\tPG_FUNCTION_INFO_V1(function_name);\n *\n * Note that internal functions do not need this decoration since they are\n * assumed to be version-1.\n *\n *-------------------------------------------------------------------------\n */\n\ntypedef struct\n{\n\tint\t\t\tapi_version;\t/* specifies call convention version number */\n\t/* More fields may be added later, for version numbers > 1. */\n} Pg_finfo_record;\n\n/* Expected signature of an info function */\ntypedef const Pg_finfo_record *(*PGFInfoFunction) (void);\n\n/*\n *\tMacro to build an info function associated with the given function name.\n *\n *\tAs a convenience, also provide an \"extern\" declaration for the given\n *\tfunction name, so that writers of C functions need not write that too.\n *\n *\tOn Windows, the function and info function must be exported.  Our normal\n *\tbuild processes take care of that via .DEF files or --export-all-symbols.\n *\tModule authors using a different build process might need to manually\n *\tdeclare the function PGDLLEXPORT.  We do that automatically here for the\n *\tinfo function, since authors shouldn't need to be explicitly aware of it.\n */\n#define PG_FUNCTION_INFO_V1(funcname) \\\nextern Datum funcname(PG_FUNCTION_ARGS); \\\nextern PGDLLEXPORT const Pg_finfo_record * CppConcat(pg_finfo_,funcname)(void); \\\nconst Pg_finfo_record * \\\nCppConcat(pg_finfo_,funcname) (void) \\\n{ \\\n\tstatic const Pg_finfo_record my_finfo = { 1 }; \\\n\treturn &my_finfo; \\\n} \\\nextern int no_such_variable\n\n\n/*-------------------------------------------------------------------------\n *\t\tSupport for verifying backend compatibility of loaded modules\n *\n * We require dynamically-loaded modules to include the macro call\n *\t\tPG_MODULE_MAGIC;\n * so that we can check for obvious incompatibility, such as being compiled\n * for a different major PostgreSQL version.\n *\n * To compile with versions of PostgreSQL that do not support this,\n * you may put an #ifdef/#endif test around it.  Note that in a multiple-\n * source-file module, the macro call should only appear once.\n *\n * The specific items included in the magic block are intended to be ones that\n * are custom-configurable and especially likely to break dynamically loaded\n * modules if they were compiled with other values.  Also, the length field\n * can be used to detect definition changes.\n *\n * Note: we compare magic blocks with memcmp(), so there had better not be\n * any alignment pad bytes in them.\n *\n * Note: when changing the contents of magic blocks, be sure to adjust the\n * incompatible_module_error() function in dfmgr.c.\n *-------------------------------------------------------------------------\n */\n\n/* Definition of the magic block structure */\ntypedef struct\n{\n\tint\t\t\tlen;\t\t\t/* sizeof(this struct) */\n\tint\t\t\tversion;\t\t/* PostgreSQL major version */\n\tint\t\t\tfuncmaxargs;\t/* FUNC_MAX_ARGS */\n\tint\t\t\tindexmaxkeys;\t/* INDEX_MAX_KEYS */\n\tint\t\t\tnamedatalen;\t/* NAMEDATALEN */\n\tint\t\t\tfloat4byval;\t/* FLOAT4PASSBYVAL */\n\tint\t\t\tfloat8byval;\t/* FLOAT8PASSBYVAL */\n} Pg_magic_struct;\n\n/* The actual data block contents */\n#define PG_MODULE_MAGIC_DATA \\\n{ \\\n\tsizeof(Pg_magic_struct), \\\n\tPG_VERSION_NUM / 100, \\\n\tFUNC_MAX_ARGS, \\\n\tINDEX_MAX_KEYS, \\\n\tNAMEDATALEN, \\\n\tFLOAT4PASSBYVAL, \\\n\tFLOAT8PASSBYVAL \\\n}\n\n/*\n * Declare the module magic function.  It needs to be a function as the dlsym\n * in the backend is only guaranteed to work on functions, not data\n */\ntypedef const Pg_magic_struct *(*PGModuleMagicFunction) (void);\n\n#define PG_MAGIC_FUNCTION_NAME Pg_magic_func\n#define PG_MAGIC_FUNCTION_NAME_STRING \"Pg_magic_func\"\n\n#define PG_MODULE_MAGIC \\\nextern PGDLLEXPORT const Pg_magic_struct *PG_MAGIC_FUNCTION_NAME(void); \\\nconst Pg_magic_struct * \\\nPG_MAGIC_FUNCTION_NAME(void) \\\n{ \\\n\tstatic const Pg_magic_struct Pg_magic_data = PG_MODULE_MAGIC_DATA; \\\n\treturn &Pg_magic_data; \\\n} \\\nextern int no_such_variable\n\n\n/*-------------------------------------------------------------------------\n *\t\tSupport routines and macros for callers of fmgr-compatible functions\n *-------------------------------------------------------------------------\n */\n\n/* These are for invocation of a specifically named function with a\n * directly-computed parameter list.  Note that neither arguments nor result\n * are allowed to be NULL.\n */\nextern Datum DirectFunctionCall1Coll(PGFunction func, Oid collation,\n\t\t\t\t\t\tDatum arg1);\nextern Datum DirectFunctionCall2Coll(PGFunction func, Oid collation,\n\t\t\t\t\t\tDatum arg1, Datum arg2);\nextern Datum DirectFunctionCall3Coll(PGFunction func, Oid collation,\n\t\t\t\t\t\tDatum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3);\nextern Datum DirectFunctionCall4Coll(PGFunction func, Oid collation,\n\t\t\t\t\t\tDatum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4);\nextern Datum DirectFunctionCall5Coll(PGFunction func, Oid collation,\n\t\t\t\t\t\tDatum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5);\nextern Datum DirectFunctionCall6Coll(PGFunction func, Oid collation,\n\t\t\t\t\t\tDatum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t\tDatum arg6);\nextern Datum DirectFunctionCall7Coll(PGFunction func, Oid collation,\n\t\t\t\t\t\tDatum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t\tDatum arg6, Datum arg7);\nextern Datum DirectFunctionCall8Coll(PGFunction func, Oid collation,\n\t\t\t\t\t\tDatum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t\tDatum arg6, Datum arg7, Datum arg8);\nextern Datum DirectFunctionCall9Coll(PGFunction func, Oid collation,\n\t\t\t\t\t\tDatum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t\tDatum arg6, Datum arg7, Datum arg8,\n\t\t\t\t\t\tDatum arg9);\n\n/*\n * These functions work like the DirectFunctionCall functions except that\n * they use the flinfo parameter to initialise the fcinfo for the call.\n * It's recommended that the callee only use the fn_extra and fn_mcxt\n * fields, as other fields will typically describe the calling function\n * not the callee.  Conversely, the calling function should not have\n * used fn_extra, unless its use is known to be compatible with the callee's.\n */\nextern Datum CallerFInfoFunctionCall1(PGFunction func, FmgrInfo *flinfo,\n\t\t\t\t\t\t Oid collation, Datum arg1);\nextern Datum CallerFInfoFunctionCall2(PGFunction func, FmgrInfo *flinfo,\n\t\t\t\t\t\t Oid collation, Datum arg1, Datum arg2);\n\n/* These are for invocation of a previously-looked-up function with a\n * directly-computed parameter list.  Note that neither arguments nor result\n * are allowed to be NULL.\n */\nextern Datum FunctionCall1Coll(FmgrInfo *flinfo, Oid collation,\n\t\t\t\t  Datum arg1);\nextern Datum FunctionCall2Coll(FmgrInfo *flinfo, Oid collation,\n\t\t\t\t  Datum arg1, Datum arg2);\nextern Datum FunctionCall3Coll(FmgrInfo *flinfo, Oid collation,\n\t\t\t\t  Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3);\nextern Datum FunctionCall4Coll(FmgrInfo *flinfo, Oid collation,\n\t\t\t\t  Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4);\nextern Datum FunctionCall5Coll(FmgrInfo *flinfo, Oid collation,\n\t\t\t\t  Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4, Datum arg5);\nextern Datum FunctionCall6Coll(FmgrInfo *flinfo, Oid collation,\n\t\t\t\t  Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t  Datum arg6);\nextern Datum FunctionCall7Coll(FmgrInfo *flinfo, Oid collation,\n\t\t\t\t  Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t  Datum arg6, Datum arg7);\nextern Datum FunctionCall8Coll(FmgrInfo *flinfo, Oid collation,\n\t\t\t\t  Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t  Datum arg6, Datum arg7, Datum arg8);\nextern Datum FunctionCall9Coll(FmgrInfo *flinfo, Oid collation,\n\t\t\t\t  Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t  Datum arg6, Datum arg7, Datum arg8,\n\t\t\t\t  Datum arg9);\n\n/* These are for invocation of a function identified by OID with a\n * directly-computed parameter list.  Note that neither arguments nor result\n * are allowed to be NULL.  These are essentially fmgr_info() followed by\n * FunctionCallN().  If the same function is to be invoked repeatedly, do the\n * fmgr_info() once and then use FunctionCallN().\n */\nextern Datum OidFunctionCall0Coll(Oid functionId, Oid collation);\nextern Datum OidFunctionCall1Coll(Oid functionId, Oid collation,\n\t\t\t\t\t Datum arg1);\nextern Datum OidFunctionCall2Coll(Oid functionId, Oid collation,\n\t\t\t\t\t Datum arg1, Datum arg2);\nextern Datum OidFunctionCall3Coll(Oid functionId, Oid collation,\n\t\t\t\t\t Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3);\nextern Datum OidFunctionCall4Coll(Oid functionId, Oid collation,\n\t\t\t\t\t Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4);\nextern Datum OidFunctionCall5Coll(Oid functionId, Oid collation,\n\t\t\t\t\t Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5);\nextern Datum OidFunctionCall6Coll(Oid functionId, Oid collation,\n\t\t\t\t\t Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t Datum arg6);\nextern Datum OidFunctionCall7Coll(Oid functionId, Oid collation,\n\t\t\t\t\t Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t Datum arg6, Datum arg7);\nextern Datum OidFunctionCall8Coll(Oid functionId, Oid collation,\n\t\t\t\t\t Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t Datum arg6, Datum arg7, Datum arg8);\nextern Datum OidFunctionCall9Coll(Oid functionId, Oid collation,\n\t\t\t\t\t Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t Datum arg6, Datum arg7, Datum arg8,\n\t\t\t\t\t Datum arg9);\n\n/* These macros allow the collation argument to be omitted (with a default of\n * InvalidOid, ie, no collation).  They exist mostly for backwards\n * compatibility of source code.\n */\n#define DirectFunctionCall1(func, arg1) \\\n\tDirectFunctionCall1Coll(func, InvalidOid, arg1)\n#define DirectFunctionCall2(func, arg1, arg2) \\\n\tDirectFunctionCall2Coll(func, InvalidOid, arg1, arg2)\n#define DirectFunctionCall3(func, arg1, arg2, arg3) \\\n\tDirectFunctionCall3Coll(func, InvalidOid, arg1, arg2, arg3)\n#define DirectFunctionCall4(func, arg1, arg2, arg3, arg4) \\\n\tDirectFunctionCall4Coll(func, InvalidOid, arg1, arg2, arg3, arg4)\n#define DirectFunctionCall5(func, arg1, arg2, arg3, arg4, arg5) \\\n\tDirectFunctionCall5Coll(func, InvalidOid, arg1, arg2, arg3, arg4, arg5)\n#define DirectFunctionCall6(func, arg1, arg2, arg3, arg4, arg5, arg6) \\\n\tDirectFunctionCall6Coll(func, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6)\n#define DirectFunctionCall7(func, arg1, arg2, arg3, arg4, arg5, arg6, arg7) \\\n\tDirectFunctionCall7Coll(func, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7)\n#define DirectFunctionCall8(func, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) \\\n\tDirectFunctionCall8Coll(func, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)\n#define DirectFunctionCall9(func, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) \\\n\tDirectFunctionCall9Coll(func, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)\n#define FunctionCall1(flinfo, arg1) \\\n\tFunctionCall1Coll(flinfo, InvalidOid, arg1)\n#define FunctionCall2(flinfo, arg1, arg2) \\\n\tFunctionCall2Coll(flinfo, InvalidOid, arg1, arg2)\n#define FunctionCall3(flinfo, arg1, arg2, arg3) \\\n\tFunctionCall3Coll(flinfo, InvalidOid, arg1, arg2, arg3)\n#define FunctionCall4(flinfo, arg1, arg2, arg3, arg4) \\\n\tFunctionCall4Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4)\n#define FunctionCall5(flinfo, arg1, arg2, arg3, arg4, arg5) \\\n\tFunctionCall5Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4, arg5)\n#define FunctionCall6(flinfo, arg1, arg2, arg3, arg4, arg5, arg6) \\\n\tFunctionCall6Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6)\n#define FunctionCall7(flinfo, arg1, arg2, arg3, arg4, arg5, arg6, arg7) \\\n\tFunctionCall7Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7)\n#define FunctionCall8(flinfo, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) \\\n\tFunctionCall8Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)\n#define FunctionCall9(flinfo, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) \\\n\tFunctionCall9Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)\n#define OidFunctionCall0(functionId) \\\n\tOidFunctionCall0Coll(functionId, InvalidOid)\n#define OidFunctionCall1(functionId, arg1) \\\n\tOidFunctionCall1Coll(functionId, InvalidOid, arg1)\n#define OidFunctionCall2(functionId, arg1, arg2) \\\n\tOidFunctionCall2Coll(functionId, InvalidOid, arg1, arg2)\n#define OidFunctionCall3(functionId, arg1, arg2, arg3) \\\n\tOidFunctionCall3Coll(functionId, InvalidOid, arg1, arg2, arg3)\n#define OidFunctionCall4(functionId, arg1, arg2, arg3, arg4) \\\n\tOidFunctionCall4Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4)\n#define OidFunctionCall5(functionId, arg1, arg2, arg3, arg4, arg5) \\\n\tOidFunctionCall5Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4, arg5)\n#define OidFunctionCall6(functionId, arg1, arg2, arg3, arg4, arg5, arg6) \\\n\tOidFunctionCall6Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6)\n#define OidFunctionCall7(functionId, arg1, arg2, arg3, arg4, arg5, arg6, arg7) \\\n\tOidFunctionCall7Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7)\n#define OidFunctionCall8(functionId, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) \\\n\tOidFunctionCall8Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)\n#define OidFunctionCall9(functionId, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) \\\n\tOidFunctionCall9Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)\n\n\n/* Special cases for convenient invocation of datatype I/O functions. */\nextern Datum InputFunctionCall(FmgrInfo *flinfo, char *str,\n\t\t\t\t  Oid typioparam, int32 typmod);\nextern Datum OidInputFunctionCall(Oid functionId, char *str,\n\t\t\t\t\t Oid typioparam, int32 typmod);\nextern char *OutputFunctionCall(FmgrInfo *flinfo, Datum val);\nextern char *OidOutputFunctionCall(Oid functionId, Datum val);\nextern Datum ReceiveFunctionCall(FmgrInfo *flinfo, fmStringInfo buf,\n\t\t\t\t\tOid typioparam, int32 typmod);\nextern Datum OidReceiveFunctionCall(Oid functionId, fmStringInfo buf,\n\t\t\t\t\t   Oid typioparam, int32 typmod);\nextern bytea *SendFunctionCall(FmgrInfo *flinfo, Datum val);\nextern bytea *OidSendFunctionCall(Oid functionId, Datum val);\n\n\n/*\n * Routines in fmgr.c\n */\nextern const Pg_finfo_record *fetch_finfo_record(void *filehandle, const char *funcname);\nextern void clear_external_function_hash(void *filehandle);\nextern Oid\tfmgr_internal_function(const char *proname);\nextern Oid\tget_fn_expr_rettype(FmgrInfo *flinfo);\nextern Oid\tget_fn_expr_argtype(FmgrInfo *flinfo, int argnum);\nextern Oid\tget_call_expr_argtype(fmNodePtr expr, int argnum);\nextern bool get_fn_expr_arg_stable(FmgrInfo *flinfo, int argnum);\nextern bool get_call_expr_arg_stable(fmNodePtr expr, int argnum);\nextern bool get_fn_expr_variadic(FmgrInfo *flinfo);\nextern bool CheckFunctionValidatorAccess(Oid validatorOid, Oid functionOid);\n\n/*\n * Routines in dfmgr.c\n */\nextern char *Dynamic_library_path;\n\nextern PGFunction load_external_function(const char *filename, const char *funcname,\n\t\t\t\t\t   bool signalNotFound, void **filehandle);\nextern PGFunction lookup_external_function(void *filehandle, const char *funcname);\nextern void load_file(const char *filename, bool restricted);\nextern void **find_rendezvous_variable(const char *varName);\nextern Size EstimateLibraryStateSpace(void);\nextern void SerializeLibraryState(Size maxsize, char *start_address);\nextern void RestoreLibraryState(char *start_address);\n\n/*\n * Support for aggregate functions\n *\n * These are actually in executor/nodeAgg.c, but we declare them here since\n * the whole point is for callers to not be overly friendly with nodeAgg.\n */\n\n/* AggCheckCallContext can return one of the following codes, or 0: */\n#define AGG_CONTEXT_AGGREGATE\t1\t/* regular aggregate */\n#define AGG_CONTEXT_WINDOW\t\t2\t/* window function */\n\nextern int AggCheckCallContext(FunctionCallInfo fcinfo,\n\t\t\t\t\tMemoryContext *aggcontext);\nextern fmAggrefPtr AggGetAggref(FunctionCallInfo fcinfo);\nextern MemoryContext AggGetTempMemoryContext(FunctionCallInfo fcinfo);\nextern void AggRegisterCallback(FunctionCallInfo fcinfo,\n\t\t\t\t\tfmExprContextCallbackFunction func,\n\t\t\t\t\tDatum arg);\n\n/*\n * We allow plugin modules to hook function entry/exit.  This is intended\n * as support for loadable security policy modules, which may want to\n * perform additional privilege checks on function entry or exit, or to do\n * other internal bookkeeping.  To make this possible, such modules must be\n * able not only to support normal function entry and exit, but also to trap\n * the case where we bail out due to an error; and they must also be able to\n * prevent inlining.\n */\ntypedef enum FmgrHookEventType\n{\n\tFHET_START,\n\tFHET_END,\n\tFHET_ABORT\n} FmgrHookEventType;\n\ntypedef bool (*needs_fmgr_hook_type) (Oid fn_oid);\n\ntypedef void (*fmgr_hook_type) (FmgrHookEventType event,\n\t\t\t\t\t\t\t\tFmgrInfo *flinfo, Datum *arg);\n\nextern PGDLLIMPORT needs_fmgr_hook_type needs_fmgr_hook;\nextern PGDLLIMPORT fmgr_hook_type fmgr_hook;\n\n#define FmgrHookIsNeeded(fn_oid)\t\t\t\t\t\t\t\\\n\t(!needs_fmgr_hook ? false : (*needs_fmgr_hook)(fn_oid))\n\n/*\n * !!! OLD INTERFACE !!!\n *\n * fmgr() is the only remaining vestige of the old-style caller support\n * functions.  It's no longer used anywhere in the Postgres distribution,\n * but we should leave it around for a release or two to ease the transition\n * for user-supplied C functions.  OidFunctionCallN() replaces it for new\n * code.\n */\n\n/*\n * DEPRECATED, DO NOT USE IN NEW CODE\n */\nextern char *fmgr(Oid procedureId,...);\n\n#endif\t\t\t\t\t\t\t/* FMGR_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/include/utils/dynamic_loader.h": "/*-------------------------------------------------------------------------\n *\n * dynamic_loader.h\n *\n *\n *\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/include/utils/dynamic_loader.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef DYNAMIC_LOADER_H\n#define DYNAMIC_LOADER_H\n\n#include \"fmgr.h\"\n\n\nextern void *pg_dlopen(char *filename);\nextern PGFunction pg_dlsym(void *handle, char *funcname);\nextern void pg_dlclose(void *handle);\nextern char *pg_dlerror(void);\n\n#endif\t\t\t\t\t\t\t/* DYNAMIC_LOADER_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/win32.h": "/*\n * src/backend/port/dynloader/win32.h\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include \"utils/dynamic_loader.h\"\t/* pgrminclude ignore */\n\n#define pg_dlopen(f)\tdlopen((f), 1)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\nchar\t   *dlerror(void);\nint\t\t\tdlclose(void *handle);\nvoid\t   *dlsym(void *handle, const char *symbol);\nvoid\t   *dlopen(const char *path, int mode);\n\n#endif\t\t\t\t\t\t\t/* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/cygwin.h": "/*-------------------------------------------------------------------------\n *\n * Dynamic loader declarations for Cygwin\n *\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/cygwin.h\n *\n *-------------------------------------------------------------------------\n  */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\t/* pgrminclude ignore */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif\t\t\t\t\t\t\t/* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/freebsd.h": "/*-------------------------------------------------------------------------\n *\n * freebsd.h\n *\t  port-specific prototypes for FreeBSD\n *\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/freebsd.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"utils/dynamic_loader.h\"\t/* pgrminclude ignore */\n\n/*\n * Dynamic Loader on NetBSD 1.0.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n *\n * agc - I know this is all a bit crufty, but it does work, is fairly\n * portable, and works (the stipulation that the d.l. function must\n * begin with an underscore is fairly tricky, and some versions of\n * NetBSD (like 1.0, and 1.0A pre June 1995) have no dlerror.)\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define\t\t   pg_dlopen(f)    BSD44_derived_dlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define\t\t   pg_dlsym\t\t   BSD44_derived_dlsym\n#define\t\t   pg_dlclose\t   BSD44_derived_dlclose\n#define\t\t   pg_dlerror\t   BSD44_derived_dlerror\n\nchar\t   *BSD44_derived_dlerror(void);\nvoid\t   *BSD44_derived_dlopen(const char *filename, int num);\nvoid\t   *BSD44_derived_dlsym(void *handle, const char *name);\nvoid\t\tBSD44_derived_dlclose(void *handle);\n\n#endif\t\t\t\t\t\t\t/* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/darwin.h": "/* src/backend/port/dynloader/darwin.h */\n\n#include \"fmgr.h\"\n\nvoid\t   *pg_dlopen(char *filename);\nPGFunction\tpg_dlsym(void *handle, char *funcname);\nvoid\t\tpg_dlclose(void *handle);\nchar\t   *pg_dlerror(void);\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/win32.c": "/* src/backend/port/dynloader/win32.c */\n\n#include \"postgres.h\"\n\nchar\t   *dlerror(void);\nint\t\t\tdlclose(void *handle);\nvoid\t   *dlsym(void *handle, const char *symbol);\nvoid\t   *dlopen(const char *path, int mode);\n\nstatic char last_dyn_error[512];\n\nstatic void\nset_dl_error(void)\n{\n\tDWORD\t\terr = GetLastError();\n\n\tif (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS |\n\t\t\t\t\t  FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  err,\n\t\t\t\t\t  MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),\n\t\t\t\t\t  last_dyn_error,\n\t\t\t\t\t  sizeof(last_dyn_error) - 1,\n\t\t\t\t\t  NULL) == 0)\n\t{\n\t\tsnprintf(last_dyn_error, sizeof(last_dyn_error) - 1,\n\t\t\t\t \"unknown error %lu\", err);\n\t}\n}\n\nchar *\ndlerror(void)\n{\n\tif (last_dyn_error[0])\n\t\treturn last_dyn_error;\n\telse\n\t\treturn NULL;\n}\n\nint\ndlclose(void *handle)\n{\n\tif (!FreeLibrary((HMODULE) handle))\n\t{\n\t\tset_dl_error();\n\t\treturn 1;\n\t}\n\tlast_dyn_error[0] = 0;\n\treturn 0;\n}\n\nvoid *\ndlsym(void *handle, const char *symbol)\n{\n\tvoid\t   *ptr;\n\n\tptr = GetProcAddress((HMODULE) handle, symbol);\n\tif (!ptr)\n\t{\n\t\tset_dl_error();\n\t\treturn NULL;\n\t}\n\tlast_dyn_error[0] = 0;\n\treturn ptr;\n}\n\nvoid *\ndlopen(const char *path, int mode)\n{\n\tHMODULE\t\th;\n\tint\t\t\tprevmode;\n\n\t/* Disable popup error messages when loading DLLs */\n\tprevmode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);\n\th = LoadLibrary(path);\n\tSetErrorMode(prevmode);\n\n\tif (!h)\n\t{\n\t\tset_dl_error();\n\t\treturn NULL;\n\t}\n\tlast_dyn_error[0] = 0;\n\treturn (void *) h;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/hpux.h": "/*-------------------------------------------------------------------------\n *\n * dynloader.h\n *\t  dynamic loader for HP-UX using the shared library mechanism\n *\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  src/backend/port/dynloader/hpux.h\n *\n *\tNOTES\n *\t\tall functions are defined here -- it's impossible to trace the\n *\t\tshl_* routines from the bundled HP-UX debugger.\n *\n *-------------------------------------------------------------------------\n */\n/* System includes */\n#include \"fmgr.h\"\n\nextern void *pg_dlopen(char *filename);\nextern PGFunction pg_dlsym(void *handle, char *funcname);\nextern void pg_dlclose(void *handle);\nextern char *pg_dlerror(void);\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/solaris.h": "/*-------------------------------------------------------------------------\n *\n * solaris.h\n *\t  port-specific prototypes for Solaris\n *\n *\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/solaris.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\t/* pgrminclude ignore */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif\t\t\t\t\t\t\t/* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/netbsd.c": "/*\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * src/backend/port/dynloader/netbsd.c\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *\t  notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *\t  notice, this list of conditions and the following disclaimer in the\n *\t  documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *\t  may be used to endorse or promote products derived from this software\n *\t  without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#if defined(LIBC_SCCS) && !defined(lint)\nstatic char sccsid[] = \"@(#)dl.c\t5.4 (Berkeley) 2/23/91\";\n#endif\t\t\t\t\t\t\t/* LIBC_SCCS and not lint */\n\n#include \"postgres.h\"\n\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"dynloader.h\"\n\nstatic char error_message[BUFSIZ];\n\nchar *\nBSD44_derived_dlerror(void)\n{\n\tstatic char ret[BUFSIZ];\n\n\tstrcpy(ret, error_message);\n\terror_message[0] = 0;\n\treturn (ret[0] == 0) ? NULL : ret;\n}\n\nvoid *\nBSD44_derived_dlopen(const char *file, int num)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlopen (%s) not supported\", file);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n\tif ((vp = dlopen((char *) file, num)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlopen (%s) failed: %s\", file, dlerror());\n\treturn vp;\n#endif\n}\n\nvoid *\nBSD44_derived_dlsym(void *handle, const char *name)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlsym (%s) failed\", name);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n#ifndef __ELF__\n\tchar\t\tbuf[BUFSIZ];\n\n\tif (*name != '_')\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"_%s\", name);\n\t\tname = buf;\n\t}\n#endif\t\t\t\t\t\t\t/* !__ELF__ */\n\tif ((vp = dlsym(handle, (char *) name)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlsym (%s) failed\", name);\n\treturn vp;\n#endif\n}\n\nvoid\nBSD44_derived_dlclose(void *handle)\n{\n#if defined(HAVE_DLOPEN)\n\tdlclose(handle);\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/aix.h": "/*-------------------------------------------------------------------------\n *\n * aix.h\n *\t  prototypes for AIX-specific routines\n *\n *\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/aix.h\n *\n *-------------------------------------------------------------------------\n */\n\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\t/* pgrminclude ignore */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define  pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define  pg_dlsym(h, f) ((PGFunction) dlsym(h, f))\n#define  pg_dlclose(h)\tdlclose(h)\n#define  pg_dlerror()\tdlerror()\n\n#endif\t\t\t\t\t\t\t/* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/netbsd.h": "/*-------------------------------------------------------------------------\n *\n * netbsd.h\n *\t  port-specific prototypes for NetBSD\n *\n *\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/netbsd.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"utils/dynamic_loader.h\"\t/* pgrminclude ignore */\n\n/*\n * Dynamic Loader on NetBSD 1.0.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n *\n * agc - I know this is all a bit crufty, but it does work, is fairly\n * portable, and works (the stipulation that the d.l. function must\n * begin with an underscore is fairly tricky, and some versions of\n * NetBSD (like 1.0, and 1.0A pre June 1995) have no dlerror.)\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define\t\t   pg_dlopen(f)    BSD44_derived_dlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define\t\t   pg_dlsym\t\t   BSD44_derived_dlsym\n#define\t\t   pg_dlclose\t   BSD44_derived_dlclose\n#define\t\t   pg_dlerror\t   BSD44_derived_dlerror\n\nchar\t   *BSD44_derived_dlerror(void);\nvoid\t   *BSD44_derived_dlopen(const char *filename, int num);\nvoid\t   *BSD44_derived_dlsym(void *handle, const char *name);\nvoid\t\tBSD44_derived_dlclose(void *handle);\n\n#endif\t\t\t\t\t\t\t/* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/openbsd.h": "/*-------------------------------------------------------------------------\n *\n * openbsd.h\n *\t  port-specific prototypes for OpenBSD\n *\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/openbsd.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"utils/dynamic_loader.h\"\t/* pgrminclude ignore */\n\n/*\n * Dynamic Loader on NetBSD 1.0.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n *\n * agc - I know this is all a bit crufty, but it does work, is fairly\n * portable, and works (the stipulation that the d.l. function must\n * begin with an underscore is fairly tricky, and some versions of\n * NetBSD (like 1.0, and 1.0A pre June 1995) have no dlerror.)\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define\t\t   pg_dlopen(f)    BSD44_derived_dlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define\t\t   pg_dlsym\t\t   BSD44_derived_dlsym\n#define\t\t   pg_dlclose\t   BSD44_derived_dlclose\n#define\t\t   pg_dlerror\t   BSD44_derived_dlerror\n\nchar\t   *BSD44_derived_dlerror(void);\nvoid\t   *BSD44_derived_dlopen(const char *filename, int num);\nvoid\t   *BSD44_derived_dlsym(void *handle, const char *name);\nvoid\t\tBSD44_derived_dlclose(void *handle);\n\n#endif\t\t\t\t\t\t\t/* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/linux.c": "/*-------------------------------------------------------------------------\n *\n * linux.c\n *\t  Dynamic Loader for Postgres for Linux, generated from those for\n *\t  Ultrix.\n *\n *\t  You need to install the dld library on your Linux system!\n *\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  src/backend/port/dynloader/linux.c\n *\n *-------------------------------------------------------------------------\n */\n\n#include \"postgres.h\"\n\n#ifdef HAVE_DLD_H\n#include <dld.h>\n#endif\n\n#include \"dynloader.h\"\n#include \"miscadmin.h\"\n\n\n#ifndef HAVE_DLOPEN\n\nvoid *\npg_dlopen(char *filename)\n{\n#ifndef HAVE_DLD_H\n\telog(ERROR, \"dynamic load not supported\");\n\treturn NULL;\n#else\n\tstatic int\tdl_initialized = 0;\n\n\t/*\n\t * initializes the dynamic loader with the executable's pathname. (only\n\t * needs to do this the first time pg_dlopen is called.)\n\t */\n\tif (!dl_initialized)\n\t{\n\t\tif (dld_init(dld_find_executable(my_exec_path)))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * if there are undefined symbols, we want dl to search from the\n\t\t * following libraries also.\n\t\t */\n\t\tdl_initialized = 1;\n\t}\n\n\t/*\n\t * link the file, then check for undefined symbols!\n\t */\n\tif (dld_link(filename))\n\t\treturn NULL;\n\n\t/*\n\t * If undefined symbols: try to link with the C and math libraries! This\n\t * could be smarter, if the dynamic linker was able to handle shared libs!\n\t */\n\tif (dld_undefined_sym_count > 0)\n\t{\n\t\tif (dld_link(\"/usr/lib/libc.a\"))\n\t\t{\n\t\t\telog(WARNING, \"could not link C library\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (dld_undefined_sym_count > 0)\n\t\t{\n\t\t\tif (dld_link(\"/usr/lib/libm.a\"))\n\t\t\t{\n\t\t\t\telog(WARNING, \"could not link math library\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (dld_undefined_sym_count > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tcount = dld_undefined_sym_count;\n\t\t\t\tchar\t  **list = dld_list_undefined_sym();\n\n\t\t\t\t/* list the undefined symbols, if any */\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\telog(WARNING, \"\\\"%s\\\" is undefined\", *list);\n\t\t\t\t\tlist++;\n\t\t\t\t\tcount--;\n\t\t\t\t} while (count > 0);\n\n\t\t\t\tdld_unlink_by_file(filename, 1);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (void *) strdup(filename);\n#endif\n}\n\nPGFunction\npg_dlsym(void *handle, char *funcname)\n{\n#ifndef HAVE_DLD_H\n\treturn NULL;\n#else\n\treturn (PGFunction) dld_get_func((funcname));\n#endif\n}\n\nvoid\npg_dlclose(void *handle)\n{\n#ifndef HAVE_DLD_H\n#else\n\tdld_unlink_by_file(handle, 1);\n\tfree(handle);\n#endif\n}\n\nchar *\npg_dlerror(void)\n{\n#ifndef HAVE_DLD_H\n\treturn \"dynaloader unsupported\";\n#else\n\treturn dld_strerror(dld_errno);\n#endif\n}\n\n#endif\t\t\t\t\t\t\t/* !HAVE_DLOPEN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/freebsd.c": "/*\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * src/backend/port/dynloader/freebsd.c\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *\t  notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *\t  notice, this list of conditions and the following disclaimer in the\n *\t  documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *\t  may be used to endorse or promote products derived from this software\n *\t  without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#if defined(LIBC_SCCS) && !defined(lint)\nstatic char sccsid[] = \"@(#)dl.c\t5.4 (Berkeley) 2/23/91\";\n#endif\t\t\t\t\t\t\t/* LIBC_SCCS and not lint */\n\n#include \"postgres.h\"\n\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"dynloader.h\"\n\nstatic char error_message[BUFSIZ];\n\nchar *\nBSD44_derived_dlerror(void)\n{\n\tstatic char ret[BUFSIZ];\n\n\tstrcpy(ret, error_message);\n\terror_message[0] = 0;\n\treturn (ret[0] == 0) ? NULL : ret;\n}\n\nvoid *\nBSD44_derived_dlopen(const char *file, int num)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlopen (%s) not supported\", file);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n\tif ((vp = dlopen((char *) file, num)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlopen (%s) failed: %s\", file, dlerror());\n\treturn vp;\n#endif\n}\n\nvoid *\nBSD44_derived_dlsym(void *handle, const char *name)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlsym (%s) failed\", name);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n#ifndef __ELF__\n\tchar\t\tbuf[BUFSIZ];\n\n\tif (*name != '_')\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"_%s\", name);\n\t\tname = buf;\n\t}\n#endif\t\t\t\t\t\t\t/* !__ELF__ */\n\tif ((vp = dlsym(handle, (char *) name)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlsym (%s) failed\", name);\n\treturn vp;\n#endif\n}\n\nvoid\nBSD44_derived_dlclose(void *handle)\n{\n#if defined(HAVE_DLOPEN)\n\tdlclose(handle);\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/openbsd.c": "/*\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * src/backend/port/dynloader/openbsd.c\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *\t  notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *\t  notice, this list of conditions and the following disclaimer in the\n *\t  documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *\t  may be used to endorse or promote products derived from this software\n *\t  without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#if defined(LIBC_SCCS) && !defined(lint)\nstatic char sccsid[] = \"@(#)dl.c\t5.4 (Berkeley) 2/23/91\";\n#endif\t\t\t\t\t\t\t/* LIBC_SCCS and not lint */\n\n#include \"postgres.h\"\n\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"dynloader.h\"\n\nstatic char error_message[BUFSIZ];\n\nchar *\nBSD44_derived_dlerror(void)\n{\n\tstatic char ret[BUFSIZ];\n\n\tstrcpy(ret, error_message);\n\terror_message[0] = 0;\n\treturn (ret[0] == 0) ? NULL : ret;\n}\n\nvoid *\nBSD44_derived_dlopen(const char *file, int num)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlopen (%s) not supported\", file);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n\tif ((vp = dlopen((char *) file, num)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlopen (%s) failed: %s\", file, dlerror());\n\treturn vp;\n#endif\n}\n\nvoid *\nBSD44_derived_dlsym(void *handle, const char *name)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlsym (%s) failed\", name);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n#ifndef __ELF__\n\tchar\t\tbuf[BUFSIZ];\n\n\tif (*name != '_')\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"_%s\", name);\n\t\tname = buf;\n\t}\n#endif\t\t\t\t\t\t\t/* !__ELF__ */\n\tif ((vp = dlsym(handle, (char *) name)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlsym (%s) failed\", name);\n\treturn vp;\n#endif\n}\n\nvoid\nBSD44_derived_dlclose(void *handle)\n{\n#if defined(HAVE_DLOPEN)\n\tdlclose(handle);\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/darwin.c": "/*\n * Dynamic loading support for macOS (Darwin)\n *\n * If dlopen() is available (Darwin 10.3 and later), we just use it.\n * Otherwise we emulate it with the older, now deprecated, NSLinkModule API.\n *\n * src/backend/port/dynloader/darwin.c\n */\n#include \"postgres.h\"\n\n#ifdef HAVE_DLOPEN\n#include <dlfcn.h>\n#else\n#include <mach-o/dyld.h>\n#endif\n\n#include \"dynloader.h\"\n\n\n#ifdef HAVE_DLOPEN\n\nvoid *\npg_dlopen(char *filename)\n{\n\treturn dlopen(filename, RTLD_NOW | RTLD_GLOBAL);\n}\n\nvoid\npg_dlclose(void *handle)\n{\n\tdlclose(handle);\n}\n\nPGFunction\npg_dlsym(void *handle, char *funcname)\n{\n\t/* Do not prepend an underscore: see dlopen(3) */\n\treturn dlsym(handle, funcname);\n}\n\nchar *\npg_dlerror(void)\n{\n\treturn dlerror();\n}\n#else\t\t\t\t\t\t\t/* !HAVE_DLOPEN */\n\n/*\n * These routines were taken from the Apache source, but were made\n * available with a PostgreSQL-compatible license.  Kudos Wilfredo\n * S\u00e1nchez <wsanchez@apple.com>.\n */\n\nstatic NSObjectFileImageReturnCode cofiff_result = NSObjectFileImageFailure;\n\nvoid *\npg_dlopen(char *filename)\n{\n\tNSObjectFileImage image;\n\n\tcofiff_result = NSCreateObjectFileImageFromFile(filename, &image);\n\tif (cofiff_result != NSObjectFileImageSuccess)\n\t\treturn NULL;\n\treturn NSLinkModule(image, filename,\n\t\t\t\t\t\tNSLINKMODULE_OPTION_BINDNOW |\n\t\t\t\t\t\tNSLINKMODULE_OPTION_RETURN_ON_ERROR);\n}\n\nvoid\npg_dlclose(void *handle)\n{\n\tNSUnLinkModule(handle, FALSE);\n}\n\nPGFunction\npg_dlsym(void *handle, char *funcname)\n{\n\tNSSymbol symbol;\n\tchar\t   *symname = (char *) malloc(strlen(funcname) + 2);\n\n\tif (!symname)\n\t\treturn NULL;\n\n\tsprintf(symname, \"_%s\", funcname);\n\tif (NSIsSymbolNameDefined(symname))\n\t{\n\t\tsymbol = NSLookupAndBindSymbol(symname);\n\n\t\tfree(symname);\n\t\treturn (PGFunction) NSAddressOfSymbol(symbol);\n\t}\n\telse\n\t{\n\t\tfree(symname);\n\t\treturn NULL;\n\t}\n}\n\nchar *\npg_dlerror(void)\n{\n\tNSLinkEditErrors c;\n\tint\t\t\terrorNumber;\n\tconst char *fileName;\n\tconst char *errorString = NULL;\n\n\tswitch (cofiff_result)\n\t{\n\t\tcase NSObjectFileImageSuccess:\n\t\t\t/* must have failed in NSLinkModule */\n\t\t\tNSLinkEditError(&c, &errorNumber, &fileName, &errorString);\n\t\t\tif (errorString == NULL || *errorString == '\\0')\n\t\t\t\terrorString = \"unknown link-edit failure\";\n\t\t\tbreak;\n\t\tcase NSObjectFileImageFailure:\n\t\t\terrorString = \"failed to open object file\";\n\t\t\tbreak;\n\t\tcase NSObjectFileImageInappropriateFile:\n\t\t\terrorString = \"inappropriate object file\";\n\t\t\tbreak;\n\t\tcase NSObjectFileImageArch:\n\t\t\terrorString = \"object file is for wrong architecture\";\n\t\t\tbreak;\n\t\tcase NSObjectFileImageFormat:\n\t\t\terrorString = \"object file has wrong format\";\n\t\t\tbreak;\n\t\tcase NSObjectFileImageAccess:\n\t\t\terrorString = \"insufficient permissions for object file\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrorString = \"unknown failure to open object file\";\n\t\t\tbreak;\n\t}\n\n\treturn (char *) errorString;\n}\n\n#endif\t\t\t\t\t\t\t/* HAVE_DLOPEN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/hpux.c": "/*-------------------------------------------------------------------------\n *\n * dynloader.c\n *\t  dynamic loader for HP-UX using the shared library mechanism\n *\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  src/backend/port/dynloader/hpux.c\n *\n *\tNOTES\n *\t\tall functions are defined here -- it's impossible to trace the\n *\t\tshl_* routines from the bundled HP-UX debugger.\n *\n *-------------------------------------------------------------------------\n */\n#include \"postgres.h\"\n\n/* System includes */\n#include <a.out.h>\n#include <dl.h>\n\n#include \"dynloader.h\"\n#include \"utils/dynamic_loader.h\"\n\nvoid *\npg_dlopen(char *filename)\n{\n\t/*\n\t * Use BIND_IMMEDIATE so that undefined symbols cause a failure return\n\t * from shl_load(), rather than an abort() later on when we attempt to\n\t * call the library!\n\t */\n\tshl_t\t\thandle = shl_load(filename,\n\t\t\t\t\t\t\t\t  BIND_IMMEDIATE | BIND_VERBOSE | DYNAMIC_PATH,\n\t\t\t\t\t\t\t\t  0L);\n\n\treturn (void *) handle;\n}\n\nPGFunction\npg_dlsym(void *handle, char *funcname)\n{\n\tPGFunction\tf;\n\n\tif (shl_findsym((shl_t *) & handle, funcname, TYPE_PROCEDURE, &f) == -1)\n\t\tf = (PGFunction) NULL;\n\treturn f;\n}\n\nvoid\npg_dlclose(void *handle)\n{\n\tshl_unload((shl_t) handle);\n}\n\nchar *\npg_dlerror(void)\n{\n\tstatic char errmsg[] = \"shl_load failed\";\n\n\tif (errno)\n\t\treturn strerror(errno);\n\n\treturn errmsg;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/port/dynloader/linux.h": "/*-------------------------------------------------------------------------\n *\n * linux.h\n *\t\tPort-specific prototypes for Linux\n *\n *\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/linux.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include \"utils/dynamic_loader.h\"\t/* pgrminclude ignore */\n#ifdef HAVE_DLOPEN\n#include <dlfcn.h>\n#endif\n\n\n#ifdef HAVE_DLOPEN\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n#endif\t\t\t\t\t\t\t/* HAVE_DLOPEN */\n\n#endif\t\t\t\t\t\t\t/* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/utils/fmgr/dfmgr.c": "/*-------------------------------------------------------------------------\n *\n * dfmgr.c\n *\t  Dynamic function manager code.\n *\n * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  src/backend/utils/fmgr/dfmgr.c\n *\n *-------------------------------------------------------------------------\n */\n#include \"postgres.h\"\n\n#include <sys/stat.h>\n\n#include \"dynloader.h\"\n#include \"lib/stringinfo.h\"\n#include \"miscadmin.h\"\n#include \"storage/shmem.h\"\n#include \"utils/dynamic_loader.h\"\n#include \"utils/hsearch.h\"\n\n\n/* signatures for PostgreSQL-specific library init/fini functions */\ntypedef void (*PG_init_t) (void);\ntypedef void (*PG_fini_t) (void);\n\n/* hashtable entry for rendezvous variables */\ntypedef struct\n{\n\tchar\t\tvarName[NAMEDATALEN];\t/* hash key (must be first) */\n\tvoid\t   *varValue;\n} rendezvousHashEntry;\n\n/*\n * List of dynamically loaded files (kept in malloc'd memory).\n */\n\ntypedef struct df_files\n{\n\tstruct df_files *next;\t\t/* List link */\n\tdev_t\t\tdevice;\t\t\t/* Device file is on */\n#ifndef WIN32\t\t\t\t\t/* ensures we never again depend on this under\n\t\t\t\t\t\t\t\t * win32 */\n\tino_t\t\tinode;\t\t\t/* Inode number of file */\n#endif\n\tvoid\t   *handle;\t\t\t/* a handle for pg_dl* functions */\n\tchar\t\tfilename[FLEXIBLE_ARRAY_MEMBER];\t/* Full pathname of file */\n} DynamicFileList;\n\nstatic DynamicFileList *file_list = NULL;\nstatic DynamicFileList *file_tail = NULL;\n\n/* stat() call under Win32 returns an st_ino field, but it has no meaning */\n#ifndef WIN32\n#define SAME_INODE(A,B) ((A).st_ino == (B).inode && (A).st_dev == (B).device)\n#else\n#define SAME_INODE(A,B) false\n#endif\n\nchar\t   *Dynamic_library_path;\n\nstatic void *internal_load_library(const char *libname);\nstatic void incompatible_module_error(const char *libname,\n\t\t\t\t\t\t  const Pg_magic_struct *module_magic_data) pg_attribute_noreturn();\nstatic void internal_unload_library(const char *libname);\nstatic bool file_exists(const char *name);\nstatic char *expand_dynamic_library_name(const char *name);\nstatic void check_restricted_library_name(const char *name);\nstatic char *substitute_libpath_macro(const char *name);\nstatic char *find_in_dynamic_libpath(const char *basename);\n\n/* Magic structure that module needs to match to be accepted */\nstatic const Pg_magic_struct magic_data = PG_MODULE_MAGIC_DATA;\n\n\n/*\n * Load the specified dynamic-link library file, and look for a function\n * named funcname in it.\n *\n * If the function is not found, we raise an error if signalNotFound is true,\n * else return (PGFunction) NULL.  Note that errors in loading the library\n * will provoke ereport() regardless of signalNotFound.\n *\n * If filehandle is not NULL, then *filehandle will be set to a handle\n * identifying the library file.  The filehandle can be used with\n * lookup_external_function to lookup additional functions in the same file\n * at less cost than repeating load_external_function.\n */\nPGFunction\nload_external_function(const char *filename, const char *funcname,\n\t\t\t\t\t   bool signalNotFound, void **filehandle)\n{\n\tchar\t   *fullname;\n\tvoid\t   *lib_handle;\n\tPGFunction\tretval;\n\n\t/* Expand the possibly-abbreviated filename to an exact path name */\n\tfullname = expand_dynamic_library_name(filename);\n\n\t/* Load the shared library, unless we already did */\n\tlib_handle = internal_load_library(fullname);\n\n\t/* Return handle if caller wants it */\n\tif (filehandle)\n\t\t*filehandle = lib_handle;\n\n\t/*\n\t * Look up the function within the library.  According to POSIX dlsym()\n\t * should declare its second argument as \"const char *\", but older\n\t * platforms might not, so for the time being we just cast away const.\n\t */\n\tretval = (PGFunction) pg_dlsym(lib_handle, (char *) funcname);\n\n\tif (retval == NULL && signalNotFound)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"could not find function \\\"%s\\\" in file \\\"%s\\\"\",\n\t\t\t\t\t\tfuncname, fullname)));\n\n\tpfree(fullname);\n\treturn retval;\n}\n\n/*\n * This function loads a shlib file without looking up any particular\n * function in it.  If the same shlib has previously been loaded,\n * unload and reload it.\n *\n * When 'restricted' is true, only libraries in the presumed-secure\n * directory $libdir/plugins may be referenced.\n */\nvoid\nload_file(const char *filename, bool restricted)\n{\n\tchar\t   *fullname;\n\n\t/* Apply security restriction if requested */\n\tif (restricted)\n\t\tcheck_restricted_library_name(filename);\n\n\t/* Expand the possibly-abbreviated filename to an exact path name */\n\tfullname = expand_dynamic_library_name(filename);\n\n\t/* Unload the library if currently loaded */\n\tinternal_unload_library(fullname);\n\n\t/* Load the shared library */\n\t(void) internal_load_library(fullname);\n\n\tpfree(fullname);\n}\n\n/*\n * Lookup a function whose library file is already loaded.\n * Return (PGFunction) NULL if not found.\n */\nPGFunction\nlookup_external_function(void *filehandle, const char *funcname)\n{\n\t/* as above, cast away const for the time being */\n\treturn (PGFunction) pg_dlsym(filehandle, (char *) funcname);\n}\n\n\n/*\n * Load the specified dynamic-link library file, unless it already is\n * loaded.  Return the pg_dl* handle for the file.\n *\n * Note: libname is expected to be an exact name for the library file.\n */\nstatic void *\ninternal_load_library(const char *libname)\n{\n\tDynamicFileList *file_scanner;\n\tPGModuleMagicFunction magic_func;\n\tchar\t   *load_error;\n\tstruct stat stat_buf;\n\tPG_init_t\tPG_init;\n\n\t/*\n\t * Scan the list of loaded FILES to see if the file has been loaded.\n\t */\n\tfor (file_scanner = file_list;\n\t\t file_scanner != NULL &&\n\t\t strcmp(libname, file_scanner->filename) != 0;\n\t\t file_scanner = file_scanner->next)\n\t\t;\n\n\tif (file_scanner == NULL)\n\t{\n\t\t/*\n\t\t * Check for same files - different paths (ie, symlink or link)\n\t\t */\n\t\tif (stat(libname, &stat_buf) == -1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not access file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tlibname)));\n\n\t\tfor (file_scanner = file_list;\n\t\t\t file_scanner != NULL &&\n\t\t\t !SAME_INODE(stat_buf, *file_scanner);\n\t\t\t file_scanner = file_scanner->next)\n\t\t\t;\n\t}\n\n\tif (file_scanner == NULL)\n\t{\n\t\t/*\n\t\t * File not loaded yet.\n\t\t */\n\t\tfile_scanner = (DynamicFileList *)\n\t\t\tmalloc(offsetof(DynamicFileList, filename) + strlen(libname) + 1);\n\t\tif (file_scanner == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\tMemSet(file_scanner, 0, offsetof(DynamicFileList, filename));\n\t\tstrcpy(file_scanner->filename, libname);\n\t\tfile_scanner->device = stat_buf.st_dev;\n#ifndef WIN32\n\t\tfile_scanner->inode = stat_buf.st_ino;\n#endif\n\t\tfile_scanner->next = NULL;\n\n\t\tfile_scanner->handle = pg_dlopen(file_scanner->filename);\n\t\tif (file_scanner->handle == NULL)\n\t\t{\n\t\t\tload_error = (char *) pg_dlerror();\n\t\t\tfree((char *) file_scanner);\n\t\t\t/* errcode_for_file_access might not be appropriate here? */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not load library \\\"%s\\\": %s\",\n\t\t\t\t\t\t\tlibname, load_error)));\n\t\t}\n\n\t\t/* Check the magic function to determine compatibility */\n\t\tmagic_func = (PGModuleMagicFunction)\n\t\t\tpg_dlsym(file_scanner->handle, PG_MAGIC_FUNCTION_NAME_STRING);\n\t\tif (magic_func)\n\t\t{\n\t\t\tconst Pg_magic_struct *magic_data_ptr = (*magic_func) ();\n\n\t\t\tif (magic_data_ptr->len != magic_data.len ||\n\t\t\t\tmemcmp(magic_data_ptr, &magic_data, magic_data.len) != 0)\n\t\t\t{\n\t\t\t\t/* copy data block before unlinking library */\n\t\t\t\tPg_magic_struct module_magic_data = *magic_data_ptr;\n\n\t\t\t\t/* try to unlink library */\n\t\t\t\tpg_dlclose(file_scanner->handle);\n\t\t\t\tfree((char *) file_scanner);\n\n\t\t\t\t/* issue suitable complaint */\n\t\t\t\tincompatible_module_error(libname, &module_magic_data);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* try to unlink library */\n\t\t\tpg_dlclose(file_scanner->handle);\n\t\t\tfree((char *) file_scanner);\n\t\t\t/* complain */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errmsg(\"incompatible library \\\"%s\\\": missing magic block\",\n\t\t\t\t\t\t\tlibname),\n\t\t\t\t\t errhint(\"Extension libraries are required to use the PG_MODULE_MAGIC macro.\")));\n\t\t}\n\n\t\t/*\n\t\t * If the library has a _PG_init() function, call it.\n\t\t */\n\t\tPG_init = (PG_init_t) pg_dlsym(file_scanner->handle, \"_PG_init\");\n\t\tif (PG_init)\n\t\t\t(*PG_init) ();\n\n\t\t/* OK to link it into list */\n\t\tif (file_list == NULL)\n\t\t\tfile_list = file_scanner;\n\t\telse\n\t\t\tfile_tail->next = file_scanner;\n\t\tfile_tail = file_scanner;\n\t}\n\n\treturn file_scanner->handle;\n}\n\n/*\n * Report a suitable error for an incompatible magic block.\n */\nstatic void\nincompatible_module_error(const char *libname,\n\t\t\t\t\t\t  const Pg_magic_struct *module_magic_data)\n{\n\tStringInfoData details;\n\n\t/*\n\t * If the version doesn't match, just report that, because the rest of the\n\t * block might not even have the fields we expect.\n\t */\n\tif (magic_data.version != module_magic_data->version)\n\t{\n\t\tchar\t\tlibrary_version[32];\n\n\t\tif (module_magic_data->version >= 1000)\n\t\t\tsnprintf(library_version, sizeof(library_version), \"%d\",\n\t\t\t\t\t module_magic_data->version / 100);\n\t\telse\n\t\t\tsnprintf(library_version, sizeof(library_version), \"%d.%d\",\n\t\t\t\t\t module_magic_data->version / 100,\n\t\t\t\t\t module_magic_data->version % 100);\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"incompatible library \\\"%s\\\": version mismatch\",\n\t\t\t\t\t\tlibname),\n\t\t\t\t errdetail(\"Server is version %d, library is version %s.\",\n\t\t\t\t\t\t   magic_data.version / 100, library_version)));\n\t}\n\n\t/*\n\t * Otherwise, spell out which fields don't agree.\n\t *\n\t * XXX this code has to be adjusted any time the set of fields in a magic\n\t * block change!\n\t */\n\tinitStringInfo(&details);\n\n\tif (module_magic_data->funcmaxargs != magic_data.funcmaxargs)\n\t{\n\t\tif (details.len)\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\tappendStringInfo(&details,\n\t\t\t\t\t\t _(\"Server has FUNC_MAX_ARGS = %d, library has %d.\"),\n\t\t\t\t\t\t magic_data.funcmaxargs,\n\t\t\t\t\t\t module_magic_data->funcmaxargs);\n\t}\n\tif (module_magic_data->indexmaxkeys != magic_data.indexmaxkeys)\n\t{\n\t\tif (details.len)\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\tappendStringInfo(&details,\n\t\t\t\t\t\t _(\"Server has INDEX_MAX_KEYS = %d, library has %d.\"),\n\t\t\t\t\t\t magic_data.indexmaxkeys,\n\t\t\t\t\t\t module_magic_data->indexmaxkeys);\n\t}\n\tif (module_magic_data->namedatalen != magic_data.namedatalen)\n\t{\n\t\tif (details.len)\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\tappendStringInfo(&details,\n\t\t\t\t\t\t _(\"Server has NAMEDATALEN = %d, library has %d.\"),\n\t\t\t\t\t\t magic_data.namedatalen,\n\t\t\t\t\t\t module_magic_data->namedatalen);\n\t}\n\tif (module_magic_data->float4byval != magic_data.float4byval)\n\t{\n\t\tif (details.len)\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\tappendStringInfo(&details,\n\t\t\t\t\t\t _(\"Server has FLOAT4PASSBYVAL = %s, library has %s.\"),\n\t\t\t\t\t\t magic_data.float4byval ? \"true\" : \"false\",\n\t\t\t\t\t\t module_magic_data->float4byval ? \"true\" : \"false\");\n\t}\n\tif (module_magic_data->float8byval != magic_data.float8byval)\n\t{\n\t\tif (details.len)\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\tappendStringInfo(&details,\n\t\t\t\t\t\t _(\"Server has FLOAT8PASSBYVAL = %s, library has %s.\"),\n\t\t\t\t\t\t magic_data.float8byval ? \"true\" : \"false\",\n\t\t\t\t\t\t module_magic_data->float8byval ? \"true\" : \"false\");\n\t}\n\n\tif (details.len == 0)\n\t\tappendStringInfoString(&details,\n\t\t\t\t\t\t\t   _(\"Magic block has unexpected length or padding difference.\"));\n\n\tereport(ERROR,\n\t\t\t(errmsg(\"incompatible library \\\"%s\\\": magic block mismatch\",\n\t\t\t\t\tlibname),\n\t\t\t errdetail_internal(\"%s\", details.data)));\n}\n\n/*\n * Unload the specified dynamic-link library file, if it is loaded.\n *\n * Note: libname is expected to be an exact name for the library file.\n *\n * XXX for the moment, this is disabled, resulting in LOAD of an already-loaded\n * library always being a no-op.  We might re-enable it someday if we can\n * convince ourselves we have safe protocols for un-hooking from hook function\n * pointers, releasing custom GUC variables, and perhaps other things that\n * are definitely unsafe currently.\n */\nstatic void\ninternal_unload_library(const char *libname)\n{\n#ifdef NOT_USED\n\tDynamicFileList *file_scanner,\n\t\t\t   *prv,\n\t\t\t   *nxt;\n\tstruct stat stat_buf;\n\tPG_fini_t\tPG_fini;\n\n\t/*\n\t * We need to do stat() in order to determine whether this is the same\n\t * file as a previously loaded file; it's also handy so as to give a good\n\t * error message if bogus file name given.\n\t */\n\tif (stat(libname, &stat_buf) == -1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not access file \\\"%s\\\": %m\", libname)));\n\n\t/*\n\t * We have to zap all entries in the list that match on either filename or\n\t * inode, else internal_load_library() will still think it's present.\n\t */\n\tprv = NULL;\n\tfor (file_scanner = file_list; file_scanner != NULL; file_scanner = nxt)\n\t{\n\t\tnxt = file_scanner->next;\n\t\tif (strcmp(libname, file_scanner->filename) == 0 ||\n\t\t\tSAME_INODE(stat_buf, *file_scanner))\n\t\t{\n\t\t\tif (prv)\n\t\t\t\tprv->next = nxt;\n\t\t\telse\n\t\t\t\tfile_list = nxt;\n\n\t\t\t/*\n\t\t\t * If the library has a _PG_fini() function, call it.\n\t\t\t */\n\t\t\tPG_fini = (PG_fini_t) pg_dlsym(file_scanner->handle, \"_PG_fini\");\n\t\t\tif (PG_fini)\n\t\t\t\t(*PG_fini) ();\n\n\t\t\tclear_external_function_hash(file_scanner->handle);\n\t\t\tpg_dlclose(file_scanner->handle);\n\t\t\tfree((char *) file_scanner);\n\t\t\t/* prv does not change */\n\t\t}\n\t\telse\n\t\t\tprv = file_scanner;\n\t}\n#endif\t\t\t\t\t\t\t/* NOT_USED */\n}\n\nstatic bool\nfile_exists(const char *name)\n{\n\tstruct stat st;\n\n\tAssertArg(name != NULL);\n\n\tif (stat(name, &st) == 0)\n\t\treturn S_ISDIR(st.st_mode) ? false : true;\n\telse if (!(errno == ENOENT || errno == ENOTDIR || errno == EACCES))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not access file \\\"%s\\\": %m\", name)));\n\n\treturn false;\n}\n\n\n/* Example format: \".so\" */\n#ifndef DLSUFFIX\n#error \"DLSUFFIX must be defined to compile this file.\"\n#endif\n\n/*\n * If name contains a slash, check if the file exists, if so return\n * the name.  Else (no slash) try to expand using search path (see\n * find_in_dynamic_libpath below); if that works, return the fully\n * expanded file name.  If the previous failed, append DLSUFFIX and\n * try again.  If all fails, just return the original name.\n *\n * The result will always be freshly palloc'd.\n */\nstatic char *\nexpand_dynamic_library_name(const char *name)\n{\n\tbool\t\thave_slash;\n\tchar\t   *new;\n\tchar\t   *full;\n\n\tAssertArg(name);\n\n\thave_slash = (first_dir_separator(name) != NULL);\n\n\tif (!have_slash)\n\t{\n\t\tfull = find_in_dynamic_libpath(name);\n\t\tif (full)\n\t\t\treturn full;\n\t}\n\telse\n\t{\n\t\tfull = substitute_libpath_macro(name);\n\t\tif (file_exists(full))\n\t\t\treturn full;\n\t\tpfree(full);\n\t}\n\n\tnew = psprintf(\"%s%s\", name, DLSUFFIX);\n\n\tif (!have_slash)\n\t{\n\t\tfull = find_in_dynamic_libpath(new);\n\t\tpfree(new);\n\t\tif (full)\n\t\t\treturn full;\n\t}\n\telse\n\t{\n\t\tfull = substitute_libpath_macro(new);\n\t\tpfree(new);\n\t\tif (file_exists(full))\n\t\t\treturn full;\n\t\tpfree(full);\n\t}\n\n\t/*\n\t * If we can't find the file, just return the string as-is. The ensuing\n\t * load attempt will fail and report a suitable message.\n\t */\n\treturn pstrdup(name);\n}\n\n/*\n * Check a restricted library name.  It must begin with \"$libdir/plugins/\"\n * and there must not be any directory separators after that (this is\n * sufficient to prevent \"..\" style attacks).\n */\nstatic void\ncheck_restricted_library_name(const char *name)\n{\n\tif (strncmp(name, \"$libdir/plugins/\", 16) != 0 ||\n\t\tfirst_dir_separator(name + 16) != NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"access to library \\\"%s\\\" is not allowed\",\n\t\t\t\t\t\tname)));\n}\n\n/*\n * Substitute for any macros appearing in the given string.\n * Result is always freshly palloc'd.\n */\nstatic char *\nsubstitute_libpath_macro(const char *name)\n{\n\tconst char *sep_ptr;\n\n\tAssertArg(name != NULL);\n\n\t/* Currently, we only recognize $libdir at the start of the string */\n\tif (name[0] != '$')\n\t\treturn pstrdup(name);\n\n\tif ((sep_ptr = first_dir_separator(name)) == NULL)\n\t\tsep_ptr = name + strlen(name);\n\n\tif (strlen(\"$libdir\") != sep_ptr - name ||\n\t\tstrncmp(name, \"$libdir\", strlen(\"$libdir\")) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid macro name in dynamic library path: %s\",\n\t\t\t\t\t\tname)));\n\n\treturn psprintf(\"%s%s\", pkglib_path, sep_ptr);\n}\n\n\n/*\n * Search for a file called 'basename' in the colon-separated search\n * path Dynamic_library_path.  If the file is found, the full file name\n * is returned in freshly palloc'd memory.  If the file is not found,\n * return NULL.\n */\nstatic char *\nfind_in_dynamic_libpath(const char *basename)\n{\n\tconst char *p;\n\tsize_t\t\tbaselen;\n\n\tAssertArg(basename != NULL);\n\tAssertArg(first_dir_separator(basename) == NULL);\n\tAssertState(Dynamic_library_path != NULL);\n\n\tp = Dynamic_library_path;\n\tif (strlen(p) == 0)\n\t\treturn NULL;\n\n\tbaselen = strlen(basename);\n\n\tfor (;;)\n\t{\n\t\tsize_t\t\tlen;\n\t\tchar\t   *piece;\n\t\tchar\t   *mangled;\n\t\tchar\t   *full;\n\n\t\tpiece = first_path_var_separator(p);\n\t\tif (piece == p)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t\t errmsg(\"zero-length component in parameter \\\"dynamic_library_path\\\"\")));\n\n\t\tif (piece == NULL)\n\t\t\tlen = strlen(p);\n\t\telse\n\t\t\tlen = piece - p;\n\n\t\tpiece = palloc(len + 1);\n\t\tstrlcpy(piece, p, len + 1);\n\n\t\tmangled = substitute_libpath_macro(piece);\n\t\tpfree(piece);\n\n\t\tcanonicalize_path(mangled);\n\n\t\t/* only absolute paths */\n\t\tif (!is_absolute_path(mangled))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t\t errmsg(\"component in parameter \\\"dynamic_library_path\\\" is not an absolute path\")));\n\n\t\tfull = palloc(strlen(mangled) + 1 + baselen + 1);\n\t\tsprintf(full, \"%s/%s\", mangled, basename);\n\t\tpfree(mangled);\n\n\t\telog(DEBUG3, \"find_in_dynamic_libpath: trying \\\"%s\\\"\", full);\n\n\t\tif (file_exists(full))\n\t\t\treturn full;\n\n\t\tpfree(full);\n\n\t\tif (p[len] == '\\0')\n\t\t\tbreak;\n\t\telse\n\t\t\tp += len + 1;\n\t}\n\n\treturn NULL;\n}\n\n\n/*\n * Find (or create) a rendezvous variable that one dynamically\n * loaded library can use to meet up with another.\n *\n * On the first call of this function for a particular varName,\n * a \"rendezvous variable\" is created with the given name.\n * The value of the variable is a void pointer (initially set to NULL).\n * Subsequent calls with the same varName just return the address of\n * the existing variable.  Once created, a rendezvous variable lasts\n * for the life of the process.\n *\n * Dynamically loaded libraries can use rendezvous variables\n * to find each other and share information: they just need to agree\n * on the variable name and the data it will point to.\n */\nvoid\t  **\nfind_rendezvous_variable(const char *varName)\n{\n\tstatic HTAB *rendezvousHash = NULL;\n\n\trendezvousHashEntry *hentry;\n\tbool\t\tfound;\n\n\t/* Create a hashtable if we haven't already done so in this process */\n\tif (rendezvousHash == NULL)\n\t{\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = NAMEDATALEN;\n\t\tctl.entrysize = sizeof(rendezvousHashEntry);\n\t\trendezvousHash = hash_create(\"Rendezvous variable hash\",\n\t\t\t\t\t\t\t\t\t 16,\n\t\t\t\t\t\t\t\t\t &ctl,\n\t\t\t\t\t\t\t\t\t HASH_ELEM);\n\t}\n\n\t/* Find or create the hashtable entry for this varName */\n\thentry = (rendezvousHashEntry *) hash_search(rendezvousHash,\n\t\t\t\t\t\t\t\t\t\t\t\t varName,\n\t\t\t\t\t\t\t\t\t\t\t\t HASH_ENTER,\n\t\t\t\t\t\t\t\t\t\t\t\t &found);\n\n\t/* Initialize to NULL if first time */\n\tif (!found)\n\t\thentry->varValue = NULL;\n\n\treturn &hentry->varValue;\n}\n\n/*\n * Estimate the amount of space needed to serialize the list of libraries\n * we have loaded.\n */\nSize\nEstimateLibraryStateSpace(void)\n{\n\tDynamicFileList *file_scanner;\n\tSize\t\tsize = 1;\n\n\tfor (file_scanner = file_list;\n\t\t file_scanner != NULL;\n\t\t file_scanner = file_scanner->next)\n\t\tsize = add_size(size, strlen(file_scanner->filename) + 1);\n\n\treturn size;\n}\n\n/*\n * Serialize the list of libraries we have loaded to a chunk of memory.\n */\nvoid\nSerializeLibraryState(Size maxsize, char *start_address)\n{\n\tDynamicFileList *file_scanner;\n\n\tfor (file_scanner = file_list;\n\t\t file_scanner != NULL;\n\t\t file_scanner = file_scanner->next)\n\t{\n\t\tSize\t\tlen;\n\n\t\tlen = strlcpy(start_address, file_scanner->filename, maxsize) + 1;\n\t\tAssert(len < maxsize);\n\t\tmaxsize -= len;\n\t\tstart_address += len;\n\t}\n\tstart_address[0] = '\\0';\n}\n\n/*\n * Load every library the serializing backend had loaded.\n */\nvoid\nRestoreLibraryState(char *start_address)\n{\n\twhile (*start_address != '\\0')\n\t{\n\t\tinternal_load_library(start_address);\n\t\tstart_address += strlen(start_address) + 1;\n\t}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/port/gettimeofday.c": "/*\n * gettimeofday.c\n *\t  Win32 gettimeofday() replacement\n *\n * src/port/gettimeofday.c\n *\n * Copyright (c) 2003 SRA, Inc.\n * Copyright (c) 2003 SKC, Inc.\n *\n * Permission to use, copy, modify, and distribute this software and\n * its documentation for any purpose, without fee, and without a\n * written agreement is hereby granted, provided that the above\n * copyright notice and this paragraph and the following two\n * paragraphs appear in all copies.\n *\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT,\n * INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING\n * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS\n * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN \"AS\n * IS\" BASIS, AND THE AUTHOR HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE,\n * SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n */\n\n#include \"c.h\"\n\n#include <sys/time.h>\n\n/* FILETIME of Jan 1 1970 00:00:00, the PostgreSQL epoch */\nstatic const unsigned __int64 epoch = UINT64CONST(116444736000000000);\n\n/*\n * FILETIME represents the number of 100-nanosecond intervals since\n * January 1, 1601 (UTC).\n */\n#define FILETIME_UNITS_PER_SEC\t10000000L\n#define FILETIME_UNITS_PER_USEC 10\n\n/*\n * Both GetSystemTimeAsFileTime and GetSystemTimePreciseAsFileTime share a\n * signature, so we can just store a pointer to whichever we find. This\n * is the pointer's type.\n */\ntypedef VOID(WINAPI * PgGetSystemTimeFn) (LPFILETIME);\n\n/* One-time initializer function, must match that signature. */\nstatic void WINAPI init_gettimeofday(LPFILETIME lpSystemTimeAsFileTime);\n\n/* Storage for the function we pick at runtime */\nstatic PgGetSystemTimeFn pg_get_system_time = &init_gettimeofday;\n\n/*\n * One time initializer.  Determine whether GetSystemTimePreciseAsFileTime\n * is available and if so, plan to use it; if not, fall back to\n * GetSystemTimeAsFileTime.\n */\nstatic void WINAPI\ninit_gettimeofday(LPFILETIME lpSystemTimeAsFileTime)\n{\n\t/*\n\t * Because it's guaranteed that kernel32.dll will be linked into our\n\t * address space already, we don't need to LoadLibrary it and worry about\n\t * closing it afterwards, so we're not using Pg's dlopen/dlsym() wrapper.\n\t *\n\t * We'll just look up the address of GetSystemTimePreciseAsFileTime if\n\t * present.\n\t *\n\t * While we could look up the Windows version and skip this on Windows\n\t * versions below Windows 8 / Windows Server 2012 there isn't much point,\n\t * and determining the windows version is its self somewhat Windows\n\t * version and development SDK specific...\n\t */\n\tpg_get_system_time = (PgGetSystemTimeFn) GetProcAddress(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGetModuleHandle(TEXT(\"kernel32.dll\")),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"GetSystemTimePreciseAsFileTime\");\n\tif (pg_get_system_time == NULL)\n\t{\n\t\t/*\n\t\t * The expected error from GetLastError() is ERROR_PROC_NOT_FOUND, if\n\t\t * the function isn't present. No other error should occur.\n\t\t *\n\t\t * We can't report an error here because this might be running in\n\t\t * frontend code; and even if we're in the backend, it's too early to\n\t\t * elog(...) if we get some unexpected error.  Also, it's not a\n\t\t * serious problem, so just silently fall back to\n\t\t * GetSystemTimeAsFileTime irrespective of why the failure occurred.\n\t\t */\n\t\tpg_get_system_time = &GetSystemTimeAsFileTime;\n\t}\n\n\t(*pg_get_system_time) (lpSystemTimeAsFileTime);\n}\n\n/*\n * timezone information is stored outside the kernel so tzp isn't used anymore.\n *\n * Note: this function is not for Win32 high precision timing purposes. See\n * elapsed_time().\n */\nint\ngettimeofday(struct timeval *tp, struct timezone *tzp)\n{\n\tFILETIME\tfile_time;\n\tULARGE_INTEGER ularge;\n\n\t(*pg_get_system_time) (&file_time);\n\tularge.LowPart = file_time.dwLowDateTime;\n\tularge.HighPart = file_time.dwHighDateTime;\n\n\ttp->tv_sec = (long) ((ularge.QuadPart - epoch) / FILETIME_UNITS_PER_SEC);\n\ttp->tv_usec = (long) (((ularge.QuadPart - epoch) % FILETIME_UNITS_PER_SEC)\n\t\t\t\t\t\t  / FILETIME_UNITS_PER_USEC);\n\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/contrib/test_decoding/test_decoding.c": "/*-------------------------------------------------------------------------\n *\n * test_decoding.c\n *\t\t  example logical decoding output plugin\n *\n * Copyright (c) 2012-2017, PostgreSQL Global Development Group\n *\n * IDENTIFICATION\n *\t\t  contrib/test_decoding/test_decoding.c\n *\n *-------------------------------------------------------------------------\n */\n#include \"postgres.h\"\n\n#include \"access/sysattr.h\"\n\n#include \"catalog/pg_class.h\"\n#include \"catalog/pg_type.h\"\n\n#include \"nodes/parsenodes.h\"\n\n#include \"replication/output_plugin.h\"\n#include \"replication/logical.h\"\n#include \"replication/message.h\"\n#include \"replication/origin.h\"\n\n#include \"utils/builtins.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/relcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n\nPG_MODULE_MAGIC;\n\n/* These must be available to pg_dlsym() */\nextern void _PG_init(void);\nextern void _PG_output_plugin_init(OutputPluginCallbacks *cb);\n\ntypedef struct\n{\n\tMemoryContext context;\n\tbool\t\tinclude_xids;\n\tbool\t\tinclude_timestamp;\n\tbool\t\tskip_empty_xacts;\n\tbool\t\txact_wrote_changes;\n\tbool\t\tonly_local;\n} TestDecodingData;\n\nstatic void pg_decode_startup(LogicalDecodingContext *ctx, OutputPluginOptions *opt,\n\t\t\t\t  bool is_init);\nstatic void pg_decode_shutdown(LogicalDecodingContext *ctx);\nstatic void pg_decode_begin_txn(LogicalDecodingContext *ctx,\n\t\t\t\t\tReorderBufferTXN *txn);\nstatic void pg_output_begin(LogicalDecodingContext *ctx,\n\t\t\t\tTestDecodingData *data,\n\t\t\t\tReorderBufferTXN *txn,\n\t\t\t\tbool last_write);\nstatic void pg_decode_commit_txn(LogicalDecodingContext *ctx,\n\t\t\t\t\t ReorderBufferTXN *txn, XLogRecPtr commit_lsn);\nstatic void pg_decode_change(LogicalDecodingContext *ctx,\n\t\t\t\t ReorderBufferTXN *txn, Relation rel,\n\t\t\t\t ReorderBufferChange *change);\nstatic bool pg_decode_filter(LogicalDecodingContext *ctx,\n\t\t\t\t RepOriginId origin_id);\nstatic void pg_decode_message(LogicalDecodingContext *ctx,\n\t\t\t\t  ReorderBufferTXN *txn, XLogRecPtr message_lsn,\n\t\t\t\t  bool transactional, const char *prefix,\n\t\t\t\t  Size sz, const char *message);\n\nvoid\n_PG_init(void)\n{\n\t/* other plugins can perform things here */\n}\n\n/* specify output plugin callbacks */\nvoid\n_PG_output_plugin_init(OutputPluginCallbacks *cb)\n{\n\tAssertVariableIsOfType(&_PG_output_plugin_init, LogicalOutputPluginInit);\n\n\tcb->startup_cb = pg_decode_startup;\n\tcb->begin_cb = pg_decode_begin_txn;\n\tcb->change_cb = pg_decode_change;\n\tcb->commit_cb = pg_decode_commit_txn;\n\tcb->filter_by_origin_cb = pg_decode_filter;\n\tcb->shutdown_cb = pg_decode_shutdown;\n\tcb->message_cb = pg_decode_message;\n}\n\n\n/* initialize this plugin */\nstatic void\npg_decode_startup(LogicalDecodingContext *ctx, OutputPluginOptions *opt,\n\t\t\t\t  bool is_init)\n{\n\tListCell   *option;\n\tTestDecodingData *data;\n\n\tdata = palloc0(sizeof(TestDecodingData));\n\tdata->context = AllocSetContextCreate(ctx->context,\n\t\t\t\t\t\t\t\t\t\t  \"text conversion context\",\n\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\tdata->include_xids = true;\n\tdata->include_timestamp = false;\n\tdata->skip_empty_xacts = false;\n\tdata->only_local = false;\n\n\tctx->output_plugin_private = data;\n\n\topt->output_type = OUTPUT_PLUGIN_TEXTUAL_OUTPUT;\n\n\tforeach(option, ctx->output_plugin_options)\n\t{\n\t\tDefElem    *elem = lfirst(option);\n\n\t\tAssert(elem->arg == NULL || IsA(elem->arg, String));\n\n\t\tif (strcmp(elem->defname, \"include-xids\") == 0)\n\t\t{\n\t\t\t/* if option does not provide a value, it means its value is true */\n\t\t\tif (elem->arg == NULL)\n\t\t\t\tdata->include_xids = true;\n\t\t\telse if (!parse_bool(strVal(elem->arg), &data->include_xids))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not parse value \\\"%s\\\" for parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstrVal(elem->arg), elem->defname)));\n\t\t}\n\t\telse if (strcmp(elem->defname, \"include-timestamp\") == 0)\n\t\t{\n\t\t\tif (elem->arg == NULL)\n\t\t\t\tdata->include_timestamp = true;\n\t\t\telse if (!parse_bool(strVal(elem->arg), &data->include_timestamp))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not parse value \\\"%s\\\" for parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstrVal(elem->arg), elem->defname)));\n\t\t}\n\t\telse if (strcmp(elem->defname, \"force-binary\") == 0)\n\t\t{\n\t\t\tbool\t\tforce_binary;\n\n\t\t\tif (elem->arg == NULL)\n\t\t\t\tcontinue;\n\t\t\telse if (!parse_bool(strVal(elem->arg), &force_binary))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not parse value \\\"%s\\\" for parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstrVal(elem->arg), elem->defname)));\n\n\t\t\tif (force_binary)\n\t\t\t\topt->output_type = OUTPUT_PLUGIN_BINARY_OUTPUT;\n\t\t}\n\t\telse if (strcmp(elem->defname, \"skip-empty-xacts\") == 0)\n\t\t{\n\n\t\t\tif (elem->arg == NULL)\n\t\t\t\tdata->skip_empty_xacts = true;\n\t\t\telse if (!parse_bool(strVal(elem->arg), &data->skip_empty_xacts))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not parse value \\\"%s\\\" for parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstrVal(elem->arg), elem->defname)));\n\t\t}\n\t\telse if (strcmp(elem->defname, \"only-local\") == 0)\n\t\t{\n\n\t\t\tif (elem->arg == NULL)\n\t\t\t\tdata->only_local = true;\n\t\t\telse if (!parse_bool(strVal(elem->arg), &data->only_local))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not parse value \\\"%s\\\" for parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstrVal(elem->arg), elem->defname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"option \\\"%s\\\" = \\\"%s\\\" is unknown\",\n\t\t\t\t\t\t\telem->defname,\n\t\t\t\t\t\t\telem->arg ? strVal(elem->arg) : \"(null)\")));\n\t\t}\n\t}\n}\n\n/* cleanup this plugin's resources */\nstatic void\npg_decode_shutdown(LogicalDecodingContext *ctx)\n{\n\tTestDecodingData *data = ctx->output_plugin_private;\n\n\t/* cleanup our own resources via memory context reset */\n\tMemoryContextDelete(data->context);\n}\n\n/* BEGIN callback */\nstatic void\npg_decode_begin_txn(LogicalDecodingContext *ctx, ReorderBufferTXN *txn)\n{\n\tTestDecodingData *data = ctx->output_plugin_private;\n\n\tdata->xact_wrote_changes = false;\n\tif (data->skip_empty_xacts)\n\t\treturn;\n\n\tpg_output_begin(ctx, data, txn, true);\n}\n\nstatic void\npg_output_begin(LogicalDecodingContext *ctx, TestDecodingData *data, ReorderBufferTXN *txn, bool last_write)\n{\n\tOutputPluginPrepareWrite(ctx, last_write);\n\tif (data->include_xids)\n\t\tappendStringInfo(ctx->out, \"BEGIN %u\", txn->xid);\n\telse\n\t\tappendStringInfoString(ctx->out, \"BEGIN\");\n\tOutputPluginWrite(ctx, last_write);\n}\n\n/* COMMIT callback */\nstatic void\npg_decode_commit_txn(LogicalDecodingContext *ctx, ReorderBufferTXN *txn,\n\t\t\t\t\t XLogRecPtr commit_lsn)\n{\n\tTestDecodingData *data = ctx->output_plugin_private;\n\n\tif (data->skip_empty_xacts && !data->xact_wrote_changes)\n\t\treturn;\n\n\tOutputPluginPrepareWrite(ctx, true);\n\tif (data->include_xids)\n\t\tappendStringInfo(ctx->out, \"COMMIT %u\", txn->xid);\n\telse\n\t\tappendStringInfoString(ctx->out, \"COMMIT\");\n\n\tif (data->include_timestamp)\n\t\tappendStringInfo(ctx->out, \" (at %s)\",\n\t\t\t\t\t\t timestamptz_to_str(txn->commit_time));\n\n\tOutputPluginWrite(ctx, true);\n}\n\nstatic bool\npg_decode_filter(LogicalDecodingContext *ctx,\n\t\t\t\t RepOriginId origin_id)\n{\n\tTestDecodingData *data = ctx->output_plugin_private;\n\n\tif (data->only_local && origin_id != InvalidRepOriginId)\n\t\treturn true;\n\treturn false;\n}\n\n/*\n * Print literal `outputstr' already represented as string of type `typid'\n * into stringbuf `s'.\n *\n * Some builtin types aren't quoted, the rest is quoted. Escaping is done as\n * if standard_conforming_strings were enabled.\n */\nstatic void\nprint_literal(StringInfo s, Oid typid, char *outputstr)\n{\n\tconst char *valptr;\n\n\tswitch (typid)\n\t{\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase OIDOID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\t/* NB: We don't care about Inf, NaN et al. */\n\t\t\tappendStringInfoString(s, outputstr);\n\t\t\tbreak;\n\n\t\tcase BITOID:\n\t\tcase VARBITOID:\n\t\t\tappendStringInfo(s, \"B'%s'\", outputstr);\n\t\t\tbreak;\n\n\t\tcase BOOLOID:\n\t\t\tif (strcmp(outputstr, \"t\") == 0)\n\t\t\t\tappendStringInfoString(s, \"true\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(s, \"false\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tappendStringInfoChar(s, '\\'');\n\t\t\tfor (valptr = outputstr; *valptr; valptr++)\n\t\t\t{\n\t\t\t\tchar\t\tch = *valptr;\n\n\t\t\t\tif (SQL_STR_DOUBLE(ch, false))\n\t\t\t\t\tappendStringInfoChar(s, ch);\n\t\t\t\tappendStringInfoChar(s, ch);\n\t\t\t}\n\t\t\tappendStringInfoChar(s, '\\'');\n\t\t\tbreak;\n\t}\n}\n\n/* print the tuple 'tuple' into the StringInfo s */\nstatic void\ntuple_to_stringinfo(StringInfo s, TupleDesc tupdesc, HeapTuple tuple, bool skip_nulls)\n{\n\tint\t\t\tnatt;\n\tOid\t\t\toid;\n\n\t/* print oid of tuple, it's not included in the TupleDesc */\n\tif ((oid = HeapTupleHeaderGetOid(tuple->t_data)) != InvalidOid)\n\t{\n\t\tappendStringInfo(s, \" oid[oid]:%u\", oid);\n\t}\n\n\t/* print all columns individually */\n\tfor (natt = 0; natt < tupdesc->natts; natt++)\n\t{\n\t\tForm_pg_attribute attr; /* the attribute itself */\n\t\tOid\t\t\ttypid;\t\t/* type of current attribute */\n\t\tOid\t\t\ttypoutput;\t/* output function */\n\t\tbool\t\ttypisvarlena;\n\t\tDatum\t\torigval;\t/* possibly toasted Datum */\n\t\tbool\t\tisnull;\t\t/* column is null? */\n\n\t\tattr = tupdesc->attrs[natt];\n\n\t\t/*\n\t\t * don't print dropped columns, we can't be sure everything is\n\t\t * available for them\n\t\t */\n\t\tif (attr->attisdropped)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Don't print system columns, oid will already have been printed if\n\t\t * present.\n\t\t */\n\t\tif (attr->attnum < 0)\n\t\t\tcontinue;\n\n\t\ttypid = attr->atttypid;\n\n\t\t/* get Datum from tuple */\n\t\torigval = heap_getattr(tuple, natt + 1, tupdesc, &isnull);\n\n\t\tif (isnull && skip_nulls)\n\t\t\tcontinue;\n\n\t\t/* print attribute name */\n\t\tappendStringInfoChar(s, ' ');\n\t\tappendStringInfoString(s, quote_identifier(NameStr(attr->attname)));\n\n\t\t/* print attribute type */\n\t\tappendStringInfoChar(s, '[');\n\t\tappendStringInfoString(s, format_type_be(typid));\n\t\tappendStringInfoChar(s, ']');\n\n\t\t/* query output function */\n\t\tgetTypeOutputInfo(typid,\n\t\t\t\t\t\t  &typoutput, &typisvarlena);\n\n\t\t/* print separator */\n\t\tappendStringInfoChar(s, ':');\n\n\t\t/* print data */\n\t\tif (isnull)\n\t\t\tappendStringInfoString(s, \"null\");\n\t\telse if (typisvarlena && VARATT_IS_EXTERNAL_ONDISK(origval))\n\t\t\tappendStringInfoString(s, \"unchanged-toast-datum\");\n\t\telse if (!typisvarlena)\n\t\t\tprint_literal(s, typid,\n\t\t\t\t\t\t  OidOutputFunctionCall(typoutput, origval));\n\t\telse\n\t\t{\n\t\t\tDatum\t\tval;\t/* definitely detoasted Datum */\n\n\t\t\tval = PointerGetDatum(PG_DETOAST_DATUM(origval));\n\t\t\tprint_literal(s, typid, OidOutputFunctionCall(typoutput, val));\n\t\t}\n\t}\n}\n\n/*\n * callback for individual changed tuples\n */\nstatic void\npg_decode_change(LogicalDecodingContext *ctx, ReorderBufferTXN *txn,\n\t\t\t\t Relation relation, ReorderBufferChange *change)\n{\n\tTestDecodingData *data;\n\tForm_pg_class class_form;\n\tTupleDesc\ttupdesc;\n\tMemoryContext old;\n\n\tdata = ctx->output_plugin_private;\n\n\t/* output BEGIN if we haven't yet */\n\tif (data->skip_empty_xacts && !data->xact_wrote_changes)\n\t{\n\t\tpg_output_begin(ctx, data, txn, false);\n\t}\n\tdata->xact_wrote_changes = true;\n\n\tclass_form = RelationGetForm(relation);\n\ttupdesc = RelationGetDescr(relation);\n\n\t/* Avoid leaking memory by using and resetting our own context */\n\told = MemoryContextSwitchTo(data->context);\n\n\tOutputPluginPrepareWrite(ctx, true);\n\n\tappendStringInfoString(ctx->out, \"table \");\n\tappendStringInfoString(ctx->out,\n\t\t\t\t\t\t   quote_qualified_identifier(\n\t\t\t\t\t\t\t\t\t\t\t\t\t  get_namespace_name(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_rel_namespace(RelationGetRelid(relation))),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  NameStr(class_form->relname)));\n\tappendStringInfoChar(ctx->out, ':');\n\n\tswitch (change->action)\n\t{\n\t\tcase REORDER_BUFFER_CHANGE_INSERT:\n\t\t\tappendStringInfoString(ctx->out, \" INSERT:\");\n\t\t\tif (change->data.tp.newtuple == NULL)\n\t\t\t\tappendStringInfoString(ctx->out, \" (no-tuple-data)\");\n\t\t\telse\n\t\t\t\ttuple_to_stringinfo(ctx->out, tupdesc,\n\t\t\t\t\t\t\t\t\t&change->data.tp.newtuple->tuple,\n\t\t\t\t\t\t\t\t\tfalse);\n\t\t\tbreak;\n\t\tcase REORDER_BUFFER_CHANGE_UPDATE:\n\t\t\tappendStringInfoString(ctx->out, \" UPDATE:\");\n\t\t\tif (change->data.tp.oldtuple != NULL)\n\t\t\t{\n\t\t\t\tappendStringInfoString(ctx->out, \" old-key:\");\n\t\t\t\ttuple_to_stringinfo(ctx->out, tupdesc,\n\t\t\t\t\t\t\t\t\t&change->data.tp.oldtuple->tuple,\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\tappendStringInfoString(ctx->out, \" new-tuple:\");\n\t\t\t}\n\n\t\t\tif (change->data.tp.newtuple == NULL)\n\t\t\t\tappendStringInfoString(ctx->out, \" (no-tuple-data)\");\n\t\t\telse\n\t\t\t\ttuple_to_stringinfo(ctx->out, tupdesc,\n\t\t\t\t\t\t\t\t\t&change->data.tp.newtuple->tuple,\n\t\t\t\t\t\t\t\t\tfalse);\n\t\t\tbreak;\n\t\tcase REORDER_BUFFER_CHANGE_DELETE:\n\t\t\tappendStringInfoString(ctx->out, \" DELETE:\");\n\n\t\t\t/* if there was no PK, we only know that a delete happened */\n\t\t\tif (change->data.tp.oldtuple == NULL)\n\t\t\t\tappendStringInfoString(ctx->out, \" (no-tuple-data)\");\n\t\t\t/* In DELETE, only the replica identity is present; display that */\n\t\t\telse\n\t\t\t\ttuple_to_stringinfo(ctx->out, tupdesc,\n\t\t\t\t\t\t\t\t\t&change->data.tp.oldtuple->tuple,\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tAssert(false);\n\t}\n\n\tMemoryContextSwitchTo(old);\n\tMemoryContextReset(data->context);\n\n\tOutputPluginWrite(ctx, true);\n}\n\nstatic void\npg_decode_message(LogicalDecodingContext *ctx,\n\t\t\t\t  ReorderBufferTXN *txn, XLogRecPtr lsn, bool transactional,\n\t\t\t\t  const char *prefix, Size sz, const char *message)\n{\n\tOutputPluginPrepareWrite(ctx, true);\n\tappendStringInfo(ctx->out, \"message: transactional: %d prefix: %s, sz: %zu content:\",\n\t\t\t\t\t transactional, prefix, sz);\n\tappendBinaryStringInfo(ctx->out, message, sz);\n\tOutputPluginWrite(ctx, true);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/bin/pg_config/po/nb.po",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/timezone/tznames/Europe.txt",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/backend/utils/mb/conversion_procs/README.euc_jp",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/port/win32.ico",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/expected/big5.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/expected/mule_internal.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/expected/euc_kr.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/expected/sjis.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/expected/euc_jp.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/expected/gb18030.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/expected/euc_cn.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/expected/euc_tw.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/sql/big5.sql",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/sql/euc_cn.sql",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/sql/gb18030.sql",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/sql/euc_jp.sql",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/sql/mule_internal.sql",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/sql/euc_tw.sql",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/sql/sjis.sql",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/mb/sql/euc_kr.sql",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/gr_GR.ISO8859-7/test-gr-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/gr_GR.ISO8859-7/test-gr-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/gr_GR.ISO8859-7/test-gr.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/gr-ctype.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-to-win1251/test-koi8.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-to-win1251/test-koi8-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-to-win1251/test-koi8-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/de_DE.ISO8859-1/test-de-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/de_DE.ISO8859-1/test-de.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/de_DE.ISO8859-1/test-de-upper.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/de_DE.ISO8859-1/test-de-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-upper-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/de_DE.ISO8859-1/expected/de-ctype.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-upper-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-upper-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-r/test-koi8.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-r/test-koi8-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-r/test-koi8-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-r/expected/test-koi8-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-r/expected/koi8-ctype.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-r/expected/test-koi8-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-r/expected/test-koi8-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-r/expected/test-koi8-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/src/test/locale/koi8-r/expected/test-koi8-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/contrib/unaccent/expected/unaccent.out",
        "/tmp/vanessa/spack-stage/spack-stage-postgresql-10.3-jdb2v3bssiwk326mnglhdlggvs53oylc/spack-src/contrib/unaccent/sql/unaccent.sql"
    ],
    "total_files": 6508
}