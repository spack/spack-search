{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/src/delayed_util/dlfcn.f90": "!***********************************************************************\n! This file is part of OpenMolcas.                                     *\n!                                                                      *\n! OpenMolcas is free software; you can redistribute it and/or modify   *\n! it under the terms of the GNU Lesser General Public License, v. 2.1. *\n! OpenMolcas is distributed in the hope that it will be useful, but it *\n! is provided \"as is\" and without any express or implied warranties.   *\n! For more details see the full text of the license in the file        *\n! LICENSE or in <http://www.gnu.org/licenses/>.                        *\n!***********************************************************************\nMODULE ISO_C_UTILITIES\n   USE ISO_C_BINDING ! Intrinsic module\n\n   CHARACTER(KIND=C_CHAR), DIMENSION(1), SAVE, TARGET, PRIVATE :: dummy_string=\"?\"\n\nCONTAINS\n\n   FUNCTION C_F_STRING(CPTR) RESULT(FPTR)\n      ! Convert a null-terminated C string into a Fortran character array pointer\n      TYPE(C_PTR), INTENT(IN) :: CPTR ! The C address\n      CHARACTER(KIND=C_CHAR), DIMENSION(:), POINTER :: FPTR\n\n      INTERFACE ! strlen is a standard C function from <string.h>\n         ! int strlen(char *string)\n         FUNCTION strlen(string) RESULT(len) BIND(C,NAME=\"strlen\")\n            USE ISO_C_BINDING\n            TYPE(C_PTR), VALUE :: string ! A C pointer\n            INTEGER(KIND=C_INT) :: len\n         END FUNCTION\n      END INTERFACE\n\n      IF (C_ASSOCIATED(CPTR)) THEN\n         CALL C_F_POINTER(FPTR=FPTR, CPTR=CPTR, SHAPE=[strlen(CPTR)])\n      ELSE\n         ! To avoid segfaults, associate FPTR with a dummy target:\n         FPTR=>dummy_string\n      END IF\n\n   END FUNCTION\n\nEND MODULE\n\nMODULE DLFCN\n   USE ISO_C_BINDING\n   USE ISO_C_UTILITIES\n   IMPLICIT NONE\n   PRIVATE\n\n   PUBLIC :: DLOpen, DLSym, DLClose, DLError, DLAddr ! DL API\n\n   ! Valid modes for mode in DLOpen:\n   INTEGER, PARAMETER, PUBLIC :: RTLD_LAZY=1, RTLD_NOW=2, RTLD_GLOBAL=256, RTLD_LOCAL=0\n      ! Obtained from the output of the previously listed C program\n\n   ! Struct for DLAddr\n   TYPE, BIND(C), PUBLIC :: DL_info\n      TYPE(C_PTR) :: dli_fname\n      TYPE(C_FUNPTR) :: dli_fbase\n      TYPE(C_PTR) :: dli_sname\n      TYPE(C_FUNPTR) :: dli_saddr\n   END TYPE DL_info\n\n   INTERFACE ! All we need is interfaces for the prototypes in <dlfcn.h>\n      FUNCTION DLOpen(file,mode) RESULT(handle) BIND(C,NAME=\"dlopen\")\n         ! void *dlopen(const char *file, int mode);\n         USE ISO_C_BINDING\n         CHARACTER(C_CHAR), DIMENSION(*), INTENT(IN) :: file\n            ! C strings should be declared as character arrays\n         INTEGER(C_INT), VALUE :: mode\n         TYPE(C_PTR) :: handle\n      END FUNCTION\n      FUNCTION DLSym(handle,name) RESULT(funptr) BIND(C,NAME=\"dlsym\")\n         ! void *dlsym(void *handle, const char *name);\n         USE ISO_C_BINDING\n         TYPE(C_PTR), VALUE :: handle\n         CHARACTER(C_CHAR), DIMENSION(*), INTENT(IN) :: name\n         TYPE(C_FUNPTR) :: funptr ! A function pointer\n      END FUNCTION\n      FUNCTION DLClose(handle) RESULT(status) BIND(C,NAME=\"dlclose\")\n         ! int dlclose(void *handle);\n         USE ISO_C_BINDING\n         TYPE(C_PTR), VALUE :: handle\n         INTEGER(C_INT) :: status\n      END FUNCTION\n      FUNCTION DLError() RESULT(error) BIND(C,NAME=\"dlerror\")\n         ! char *dlerror(void);\n         USE ISO_C_BINDING\n         TYPE(C_PTR) :: error\n      END FUNCTION\n      ! dladdr is a Glibc extension, not POSIX\n      FUNCTION DLAddr(funptr,info) RESULT(output) BIND(C,NAME=\"dladdr\")\n         ! int dladdr(void *addr, Dl_info *info)\n         USE ISO_C_BINDING\n         TYPE(C_FUNPTR), VALUE :: funptr ! A function pointer\n         TYPE(C_PTR), VALUE :: info\n         INTEGER(C_INT) :: output\n      END FUNCTION\n   END INTERFACE\n\nEND MODULE\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/src/delayed_util/link_blas.f90": "!***********************************************************************\n! This file is part of OpenMolcas.                                     *\n!                                                                      *\n! OpenMolcas is free software; you can redistribute it and/or modify   *\n! it under the terms of the GNU Lesser General Public License, v. 2.1. *\n! OpenMolcas is distributed in the hope that it will be useful, but it *\n! is provided \"as is\" and without any express or implied warranties.   *\n! For more details see the full text of the license in the file        *\n! LICENSE or in <http://www.gnu.org/licenses/>.                        *\n!                                                                      *\n! Copyright (C) 2015,2017, Ignacio Fdez. Galvan                        *\n!***********************************************************************\nmodule link_blas\n  use iso_c_binding\n  use iso_c_utilities\n  use dlfcn\n#include \"f1.fh\"\n\n  implicit none\n\n  type(c_ptr), dimension(:), allocatable, private :: handles\n!\n! Initializing procedure pointers is a F2008 feature, not supported by all compilers.\n! When it is implemented, the pointers below should look like:\n!\n!   procedure(int_dasum), pointer :: lb_dasum=>int_dasum\n!\n! and then the exact placement of the initialization call (in start.f) is not critical\n!\n#include \"f2.fh\"\n\ncontains\n\n!define _DEBUG_\n\n!===============================================================================\n\n  subroutine lb_initialize(lib,prlev)\n    character(len=*), intent(in) :: lib\n    integer, intent(in) :: prlev\n    character(len=1024), dimension(:), allocatable :: libs\n    character(kind=c_char,len=1024) :: libname\n    type(c_funptr) :: funptr=c_null_funptr\n    type(DL_Info), target :: info\n    integer :: i\n    logical :: try_load,loaded\n\n    try_load = (lib /= 'Internal')\n\n    call lb_close()\n\n!***************************************************\n!   Try to load all the libraries specified by \"lib\"\n!***************************************************\n    call split_string(lib,libs)\n\n    allocate(handles(size(libs)))\n    handles(:)=c_null_ptr\n\n    loaded=.false.\n    if (try_load) then\n      do i=1,size(libs)\n        libname=libs(i)\n        if (len_trim(libs(i)) > 0) then\n          handles(i)=dlopen(trim(libname)//c_null_char, int(ior(rtld_global,rtld_lazy),kind=c_int))\n          loaded=(loaded .or. c_associated(handles(i)))\n          if (prlev > 0) then\n            if (c_associated(handles(i))) then\n              write (6,*) trim(libname),' loaded'\n            else\n              write(6,*) c_f_string(dlerror())\n            end if\n          end if\n        end if\n      end do\n    end if\n\n    deallocate(libs)\n\n!********************************************************************\n!   Associate all BLAS and LAPACK routines with the library functions\n!********************************************************************\n    if (loaded) then\n#include \"f3.fh\"\n!\n!\n!****************************************\n!   Or use the fallback internal routines\n!****************************************\n    else\n      if (prlev > 0) then\n        write(6,*) 'Using internal BLAS+LAPACK'\n      end if\n#include \"f4.fh\"\n    end if\n\n    if (prlev > 0) then\n#include \"f5.fh\"\n    end if\n\n  end subroutine lb_initialize\n\n!===============================================================================\n\n  subroutine lb_close()\n    integer :: i,rc\n\n    if (allocated(handles)) then\n      do i=1,size(handles)\n        if (c_associated(handles(i))) then\n          rc = dlclose(handles(i))\n          if (rc /= 0) then\n            write(6,*) c_f_string(dlerror())\n          end if\n        end if\n      end do\n      deallocate(handles)\n    end if\n\n  end subroutine lb_close\n\n!===============================================================================\n\n  subroutine split_string(string,array)\n    character(len=*) :: string\n    character(len=*), dimension(:), allocatable :: array\n    integer :: i,n,offset,lim\n\n    n=1\n    do i=1,len(string)\n      if (string(i:i) == ':') n=n+1\n    end do\n    allocate(array(n))\n    offset=0\n    do i=1,n-1\n      lim=offset+index(string(offset+1:),':')\n      array(i)=string(offset+1:lim-1)\n      offset=lim\n    end do\n    array(n)=string(offset+1:)\n\n  end subroutine split_string\n\n!===============================================================================\n\n  function link_func(funname)\n    character(kind=c_char,len=*) :: funname\n    type(c_funptr) :: link_func\n    integer :: i\n    logical :: success\n\n!******************************************************\n!   Try to associate a function on all loaded libraries\n!******************************************************\n    success=.false.\n    link_func=c_null_funptr\n    do i=1,size(handles)\n      link_func=dlsym(handles(i),trim(funname)//'_'//c_null_char)\n      if (c_associated(link_func)) then\n        success=.true.\n        exit\n#ifdef _DEBUG_\n      else\n        write(6,*) c_f_string(dlerror())\n#endif\n      end if\n    end do\n#ifdef _DEBUG_\n    if (.not. success) then\n      write(6,*) 'no ',trim(funname),' found'\n    end if\n#endif\n\n  end function link_func\n\nend module link_blas\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/_static/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/_static/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/users.guide/programs/fragment.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/users.guide/programs/gas.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/users.guide/programs/seward.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/users.guide/programs/ubar.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/tutorials/flow-all.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/tutorials/acrolein.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/advanced.examples/carbene.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/advanced.examples/job0.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/advanced.examples/reaction.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/advanced.examples/thiophene.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/advanced.examples/dmabn.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/advanced.examples/guanine.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/advanced.examples/acrolein.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/advanced.examples/job5.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/advanced.examples/biphenyl.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/advanced.examples/cyclope.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/advanced.examples/job3.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/source/advanced.examples/ex-99.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmolcas-19.11-riw2i5nsq7aqcfzsmc5tgx62i7m445y4/spack-src/doc/doxygen/logo_55.png"
    ],
    "total_files": 7244
}