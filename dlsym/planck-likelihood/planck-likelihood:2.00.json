{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-planck-likelihood-2.00-slmuk5nzhmgvwmawtpqoou6rzftvz6jg/spack-src/src/clik_helper.c": "#include \"clik_helper.h\"\n\n// NO USER SERVICEABLE PART HERE.\n// THINGS CAN CHANGE WITHOUT NOTICE. \n\n\n\n// ARE YOU STILL READING ?\n\n// YOU HAVE BEEN WARNED !\n\n\n#define _dealwitherr error *lerr,**err; if(_err==NULL) {lerr=NULL;err=&lerr;} else {err=_err;}\n\n#define _forwardError(A,B,C) if(_err!=NULL) {forwardError(A,B,C);} else {quitOnError(A,B,stderr);}\n#define _testErrorRetVA(A,B,C,D,E,F,...) if(_err!=NULL) {testErrorRetVA(A,B,C,D,E,F,__VA_ARGS__);} else {testErrorExitVA(A,B,C,D,E,__VA_ARGS__);}\n\nint clik_getenviron_integer(char* name, int sfg, error **err) {\n  int res;\n  char *cres;\n  int flg;\n  \n  cres = getenv(name);\n  if (cres!=NULL) {\n    flg = sscanf(cres,\"%d\",&res);\n    if (flg==1) {\n      return res;\n    }\n  }\n  return sfg;\n}\n\ndouble clik_getenviron_real(char* name, double sfg, error **err) {\n  double res;\n  char *cres;\n  int flg;\n\n  cres = getenv(name);\n  if (cres!=NULL) {\n    flg = sscanf(cres,\"%lg\",&res);\n    if (flg==1) {\n      return res;\n    }\n  }\n  return sfg;\n}\n\n\nchar* clik_getenviron_string(char* name, char* sfg, error **err) {\n  char *cres;\n  \n  cres = getenv(name);\n  if (cres!=NULL) {\n    return cres;\n  }\n  return sfg;\n}\n\nint clik_getenviron_numthread(char* name, int sfg, error **err) {\n  int np;\n  char fullname[2048];\n  int i;\n  \n  sprintf(fullname,\"%s_NUMTHREADS\",name);\n  for(i=0;i<strlen(name);i++) {\n    fullname[i] = toupper(fullname[i]);\n  }\n  \n  np = clik_getenviron_integer(fullname,sfg,err);\n  forwardError(*err,__LINE__,sfg);\n  \n  testErrorRetVA(np<0 && np!=sfg, -100,\"%s env variable meaningless\",*err,__LINE__,sfg,fullname);\n  //_DEBUGHERE_(\"%s = %d\",fullname,np);\n  return np;\n}\n\nint mtot(int mT,int mP,int *has_cl) {\n  int nr_channels = mT * (has_cl[0] | has_cl[3] | has_cl[4])\n                  + mP * (has_cl[1] | has_cl[3] | has_cl[5])\n                  + mP * (has_cl[2] | has_cl[4] | has_cl[5]);\n  return nr_channels;\n}\n\ncmblkl * clik_lklobject_init(cldf *df,error **err) {\n  cmblkl *clkl;\n  parname lkl_type;\n  char *version;\n  int has_cl[6];\n  int nell, *ell,nbins,i,cli;\n  double *wl,*bins;\n  double unit;\n  int lmin, lmax;\n  char init_func_name[2048];\n  clik_lkl_init_func *clik_dl_init;\n  //clik_addon_init_func *clik_addondl_init;\n  void* dlhandle;   \n  char cur_addon[256];\n  char *addon_type;\n  int i_add,n_addons;\n  int sz;\n  char *dm;\n  int *dmi;\n  int hk,j;\n\n#ifdef HAS_RTLD_DEFAULT \n  dlhandle = RTLD_DEFAULT;\n#else\n  dlhandle = NULL;\n#endif\n\n  // get the lkl type\n  memset(lkl_type,0,_pn_size*sizeof(char));\n  dm = cldf_readstr(df,\"lkl_type\",NULL,err);\n  forwardError(*err,__LINE__,NULL);\n  sprintf(lkl_type,\"%s\",dm);\n  free(dm);\n\n  // get unit\n  unit = cldf_readfloat(df,\"unit\",err);\n  forwardError(*err,__LINE__,NULL);\n  \n  sz = 6;\n  dmi = cldf_readintarray(df,\"has_cl\",&sz,err);\n  forwardError(*err,__LINE__,NULL);\n  for(j=0;j<6;j++) {\n    has_cl[j] = dmi[j];\n  }\n  free(dmi);\n\n  // get ells\n  hk = cldf_haskey(df,\"lmax\",err);\n  forwardError(*err,__LINE__,NULL);\n  if (hk==1) {\n    // has lmax !\n    lmax = cldf_readint(df,\"lmax\",err);\n    forwardError(*err,__LINE__,NULL);\n    \n    lmin = cldf_readint_default(df,\"lmin\",0,err);\n    forwardError(*err,__LINE__,NULL);\n    \n    nell = lmax+1-lmin;\n    ell = malloc_err(sizeof(int)*(nell),err);\n    forwardError(*err,__LINE__,NULL);\n    for(i=lmin;i<lmax+1;i++) {\n      ell[i-lmin] = i;\n    }\n  } else {\n    nell = -1;\n    ell = cldf_readintarray(df,\"ell\",&nell,err);\n    forwardError(*err,__LINE__,NULL);\n  }  \n  \n  lmax = ell[nell-1];\n  \n  // get wl\n  wl = NULL;\n  hk = cldf_haskey(df,\"wl\",err);\n  forwardError(*err,__LINE__,NULL);\n  if (hk==1) {\n    int nwl;\n    nwl = lmax+1;\n    wl = cldf_readfloatarray(df,\"wl\",&nwl,err);\n    forwardError(*err,__LINE__,NULL);\n  }\n  \n  // deals with bins\n  nbins = 0;\n  bins = NULL;\n  nbins = cldf_readint_default(df,\"nbins\",0,err);\n  forwardError(*err,__LINE__,NULL);  \n  \n  if (nbins!=0) {\n    int nd;\n    int ncl;\n    \n    nd = 0;\n    ncl = 0;\n    for(cli=0;cli<6;cli++) {\n      if (has_cl[cli]==1) {\n        nd += nell;\n        ncl++;\n      }\n    }\n\n    hk = cldf_haskey(df,\"bins\",err);\n    forwardError(*err,__LINE__,NULL);\n    if (hk==1) { // full binning matrix\n      int nbn;\n      nbn = nbins*nd;\n\n      bins = cldf_readfloatarray(df,\"bins\",&nbn,err);\n      forwardError(*err,__LINE__,NULL);  \n    } else { //packed binning matrix\n      double *bin_ws;\n      int *ellmin,*ellmax;\n      int nw; \n      int ib,jb,il;\n      int wsz;\n      \n      nw=-1;\n      bin_ws = cldf_readfloatarray(df,\"bin_ws\",&nw,err);\n      forwardError(*err,__LINE__,NULL);  \n      \n      ellmin = cldf_readintarray(df,\"bin_lmin\",&nbins,err);\n      forwardError(*err,__LINE__,NULL);  \n\n      ellmax = cldf_readintarray(df,\"bin_lmax\",&nbins,err);\n      forwardError(*err,__LINE__,NULL);  \n      \n      bins = malloc_err(sizeof(double)*nd*nbins,err);\n      forwardError(*err,__LINE__,NULL);  \n      memset(bins,0,sizeof(double)*nd*nbins);\n      \n      jb=0;\n      for(ib=0;ib<nbins;ib++) {        \n        wsz = ellmax[ib] - ellmin[ib] + 1;\n        testErrorRetVA(jb+wsz>nw,-11111,\"argl bins\",*err,__LINE__,NULL,\"\");\n        memcpy(&(bins[ib*nd+ellmin[ib]]),&(bin_ws[jb]),wsz*sizeof(double));\n        jb+=wsz;\n      }\n      free(ellmin);\n      free(ellmax);\n      free(bin_ws);\n    }\n    \n  }\n  \n  clkl = NULL;\n\n  sprintf(init_func_name,\"clik_%s_init\",lkl_type);\n  clik_dl_init = dlsym(dlhandle,init_func_name);\n  testErrorRetVA(clik_dl_init==NULL,-1111,\"Cannot initialize lkl type %s from %s dl error : %s\",*err,__LINE__,NULL,lkl_type,df->root,dlerror()); \n\n  clkl = clik_dl_init(df,nell,ell,has_cl,unit,wl,bins,nbins,err);\n  forwardError(*err,__LINE__,NULL); \n\n  hk = cldf_haskey(df,\"pipeid\",err);\n  forwardError(*err,__LINE__,NULL);\n  if (hk==1) { \n    char vv[1000];\n    version = cldf_readstr(df,\"pipeid\",NULL,err);\n    forwardError(*err,__LINE__,NULL);  \n      \n    sprintf(vv,\"%s %s\",lkl_type,version);\n    cmblkl_set_version(clkl,vv);\n    free(version);\n  } else {\n    cmblkl_set_version(clkl,lkl_type);\n  }\n\n  hk = cldf_haskey(df,\"free_calib\",err);\n  forwardError(*err,__LINE__,NULL);\n  if (hk==1) {\n    char *free_cal_name;\n    char **xnames;\n    parname *xnames_buf;\n    int xdim;\n\n    free_cal_name = cldf_readstr(df,\"free_calib\",NULL,err);\n    forwardError(*err,__LINE__,NULL);\n    \n    xdim = clkl->xdim;\n    xdim +=1;\n\n    xnames = malloc_err(sizeof(char*)*xdim,err);\n    forwardError(*err,__LINE__,NULL);\n  \n    xnames_buf = malloc_err(sizeof(parname)*xdim,err);\n    forwardError(*err,__LINE__,NULL);\n    \n    for(i=0;i<xdim-1;i++) {\n      sprintf(xnames_buf[i],\"%s\",clkl->xnames[i]);\n      xnames[i] = (char*) &(xnames_buf[i]);\n    }\n    xnames[xdim-1] = free_cal_name;\n\n    clkl->xdim = xdim;\n    cmblkl_set_names(clkl, xnames,err);\n    forwardError(*err,__LINE__,NULL);\n\n    free(xnames);\n    free(xnames_buf);\n    free(free_cal_name);\n    clkl->free_calib_id = clkl->xdim-1;\n\n  }\n\n  hk = cldf_haskey(df,\"self_calib\",err);\n  forwardError(*err,__LINE__,NULL);\n  if (hk==1) {\n    char *free_cal_name;\n    char **xnames;\n    parname *xnames_buf;\n    int xdim;\n\n    free_cal_name = cldf_readstr(df,\"self_calib\",NULL,err);\n    forwardError(*err,__LINE__,NULL);\n    \n    xdim = clkl->xdim;\n    xdim +=1;\n\n    xnames = malloc_err(sizeof(char*)*xdim,err);\n    forwardError(*err,__LINE__,NULL);\n  \n    xnames_buf = malloc_err(sizeof(parname)*xdim,err);\n    forwardError(*err,__LINE__,NULL);\n    \n    for(i=0;i<xdim-1;i++) {\n      sprintf(xnames_buf[i],\"%s\",clkl->xnames[i]);\n      xnames[i] = (char*) &(xnames_buf[i]);\n    }\n    xnames[xdim-1] = free_cal_name;\n\n    clkl->xdim = xdim;\n    cmblkl_set_names(clkl, xnames,err);\n    forwardError(*err,__LINE__,NULL);\n\n    free(xnames);\n    free(xnames_buf);\n    free(free_cal_name);\n    clkl->self_calib_id = clkl->xdim-1;\n\n  }\n\n  // cleanups\n  if(wl!=NULL) {\n    free(wl);    \n  }\n  if(bins!=NULL) {\n    free(bins);    \n  }\n  free(ell);\n  \n  // look for addons\n  //n_addons = cldf_readint_default(df,\"n_addons\",0,err);\n  //forwardError(*err,__LINE__,NULL);\n  //\n  //for (i_add=0;i_add<n_addons;i_add++) {\n  //  cldf *cdf;\n  //  sprintf(cur_addon,\"addon_%d\",i_add);\n  //  cdf  = cldf_openchild(df,cur_addon,err);\n  //  forwardError(*err,__LINE__,NULL);\n  //  addon_type = cldf_readstr(cdf,\"addon_type\",NULL,err);\n  //  forwardError(*err,__LINE__,NULL);\n  //\n  //  sprintf(init_func_name,\"clik_addon_%s_init\",addon_type);\n  //  clik_addondl_init = dlsym(dlhandle,init_func_name);\n  //  testErrorRetVA(clik_addondl_init==NULL,-1111,\"Cannot initialize addon type %s from %s/%s dl error : %s\",*err,__LINE__,NULL,addon_type,df->root,cur_addon,dlerror());\n  //  \n  //  // pretty print purpose\n  //  sprintf(cur_addon,\"%s\",cdf->root);\n  //  \n  //  clkl = clik_addondl_init(clkl,add_group_id,cur_addon,err);\n  //  forwardError(*err,__LINE__,NULL);  \n  //\n  //  cldf_close(&cdf);\n  //  free(addon_type);\n  //}\n  \n  return clkl;\n}\n\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-planck-likelihood-2.00-slmuk5nzhmgvwmawtpqoou6rzftvz6jg/spack-src/src/plik/clik_hfipack.c": "#include \"clik_helper.h\"\n#include \"smica.h\"\n\ntypedef SmicaComp * clik_smica_comp_init_func(cldf * df,int nb, int mT,int mP, int nell, int* ell, int* has_cl, double unit,double* wl, double *bins, int nbins,error **err);\n\n# ifndef REL_EXT\ncmblkl* clik_smica_init(cldf * df, int nell, int* ell, int* has_cl, double unit,double* wl, double *bins, int nbins, error **err) {\n  Smica *ing;\n  cmblkl *cing;  \n  double zero;\n  int n;\n  int *Ml;\n  double *wq,*rq_hat,*rq_0;\n  int m;\n  SmicaComp **SCs;\n  int ic;\n  int mT,mP,nc;\n  double *A_cmb;\n  Smica *smic;\n  int ncl,icl,nb;\n  size_t ddum;\n  int cnt,xdim;\n  char **xnames;\n  parname *xnames_buf;\n  int hk;\n  int mT_plus_mP;\n\n  zero = 0;\n\n  ncl = 0;\n  for(icl=0;icl<6;icl++) {\n    if (has_cl[icl]==1) {\n      ncl++;\n    }\n  }\n  \n  nb = nell;\n  if (nbins!=0) {\n    nb = nbins/ncl;  \n  }  \n    \n  // try to read the bin weights\n  wq = NULL;\n  hk = cldf_haskey(df,\"wq\",err);\n  forwardError(*err,__LINE__,NULL);\n  if (hk==1) {\n    wq = cldf_readfloatarray(df,\"wq\",&nb,err);\n    forwardError(*err,__LINE__,NULL);\n  }\n  \n  \n  // read the number of channels\n  mT = cldf_readint(df,\"m_channel_T\",err);\n  forwardError(*err,__LINE__,NULL);\n  mP = cldf_readint(df,\"m_channel_P\",err);\n  forwardError(*err,__LINE__,NULL);\n  \n  m = mtot(mT, mP, has_cl);\n  mT_plus_mP = mT+mP;\n\n  // read rq_hat\n  int nrq;\n  \n  nrq = nb*m*m;\n  rq_hat = cldf_readfloatarray(df,\"Rq_hat\",&nrq,err);\n  forwardError(*err,__LINE__,NULL);  \n  \n  // try to read rq_0\n  rq_0 = NULL;\n  hk = cldf_haskey(df,\"Rq_0\",err);\n  forwardError(*err,__LINE__,NULL);  \n  if (hk==1) {\n    rq_0 = cldf_readfloatarray(df,\"Rq_0\",&nrq,err);\n    forwardError(*err,__LINE__,NULL);  \n  }\n  \n  // how many components ?\n  nc = cldf_readint(df,\"n_component\",err);\n  forwardError(*err,__LINE__,NULL);\n  \n  SCs = malloc_err(sizeof(SmicaComp*) * nc,err);\n  forwardError(*err,__LINE__,NULL);\n  \n  // now deal with the CMB component\n  // read A_cmb\n  A_cmb = cldf_readfloatarray(df,\"A_cmb\",&mT_plus_mP,err);\n  forwardError(*err,__LINE__,NULL);    \n\n  // init cmb comp\n  SCs[0] = comp_CMB_init(nb, mT,mP, has_cl, A_cmb, err);\n  forwardError(*err,__LINE__,NULL);    \n  SC_set_compname(SCs[0],\"CMB\");\n  \n  free(A_cmb);\n  \n  // deal with other components\n  xdim = 0;\n  for(ic=1;ic<nc;ic++) {\n    char cur_cmp[256];\n    char cur_cmp_tot[256];\n    clik_smica_comp_init_func *smica_dl_init;\n    void* dlhandle;\n    char init_func_name[256];\n    parname comp_type;\n    cldf *comp_df;\n\n#ifdef HAS_RTLD_DEFAULT \n    dlhandle = RTLD_DEFAULT;\n#else\n    dlhandle = NULL;\n#endif\n    \n    SCs[ic] = NULL;\n    \n    sprintf(cur_cmp,\"component_%d\",ic);\n    comp_df = cldf_openchild(df,cur_cmp,err);\n    forwardError(*err,__LINE__,NULL);\n\n    // get type\n    char * cmt;\n\n    cmt = cldf_readstr(comp_df,\"component_type\",NULL,err);\n    forwardError(*err,__LINE__,NULL);\n    sprintf(comp_type,\"%s\",cmt);\n    free(cmt);\n\n    sprintf(init_func_name,\"clik_smica_comp_%s_init\",comp_type);\n    smica_dl_init = dlsym(dlhandle,init_func_name);\n    testErrorRetVA(smica_dl_init==NULL,-1111,\"Cannot initialize smica component type %s from %s dl error : %s\",*err,__LINE__,NULL,comp_type,df->root,dlerror()); \n \n    SCs[ic] = smica_dl_init(comp_df,nb,mT,mP, nell, ell, has_cl, unit, wl, bins,nb,err);\n \n    forwardError(*err,__LINE__,NULL);\n    sprintf(comp_type,\"%s_%d\",comp_type,ic);\n    SC_set_compname(SCs[ic],comp_type);\n      \n    cldf_close(&comp_df);\n    \n    xdim += SCs[ic]->ndim;\n \n  \n  }\n  \n  // deal with names and xdims\n  if (xdim!=0) {\n    xnames = malloc_err(sizeof(char*)*xdim,err);\n    forwardError(*err,__LINE__,NULL);\n  \n    xnames_buf = malloc_err(sizeof(parname)*xdim,err);\n    forwardError(*err,__LINE__,NULL);\n    cnt = 0;\n    for(ic=1;ic<nc;ic++) {\n      int ix;\n      for(ix=0;ix<SCs[ic]->ndim;ix++) {\n        if (SCs[ic]->names!=NULL) {\n          xnames[cnt]=(char*)&(SCs[ic]->names[ix]);\n        } else {\n          sprintf(xnames_buf[cnt],\"SMICA_COMP_%d_%d\",ic,ix);\n          xnames[cnt]=(char*)&(xnames_buf[cnt]);\n        }\n        cnt++;\n      }\n    }\n  }\n    \n  smic = Smica_init(nb, wq, m, rq_hat, rq_0, nc, SCs,err);\n  forwardError(*err,__LINE__,NULL);\n    \n  // deal with criterion\n  hk = cldf_haskey(df,\"criterion\",err);\n  forwardError(*err,__LINE__,NULL);\n  \n  if (hk == 1) {\n    char *crit_name;\n    \n    crit_name = cldf_readstr(df,\"criterion\",NULL,err);\n    forwardError(*err,__LINE__,NULL);\n    if(strcmp(crit_name,\"classic\")==0) {\n      //nothing to do here, we are fine\n    } else if(strcmp(crit_name,\"gauss\")==0) {\n      double *quad_crit;\n      int *mask;\n      int *ordering;\n      int nqu;\n\n      nqu = -1;\n      quad_crit = cldf_readfloatarray(df,\"criterion_gauss_mat\",&nqu,err);\n      forwardError(*err,__LINE__,NULL);\n      mask = NULL;\n      hk = cldf_haskey(df,\"criterion_gauss_mask\",err);\n      forwardError(*err,__LINE__,NULL);\n      if (hk == 1) { \n        int i;\n        nqu = nb*m*m;\n        mask = cldf_readintarray(df,\"criterion_gauss_mask\",&nqu,err);\n        forwardError(*err,__LINE__,NULL);\n      }\n      ordering = NULL;\n      hk = cldf_haskey(df,\"criterion_gauss_ordering\",err);\n      forwardError(*err,__LINE__,NULL);\n      if (hk == 1) { \n        int i;\n        nqu = m*(m+1);\n        ordering = cldf_readintarray(df,\"criterion_gauss_ordering\",&nqu,err);\n        forwardError(*err,__LINE__,NULL);\n        //_DEBUGHERE_(\"\",\"\");\n      }\n\n      smica_set_crit_gauss(smic, quad_crit,mask,ordering,err);\n      forwardError(*err,__LINE__,NULL);\n      \n      if (mask!=NULL) {\n        free(mask);  \n      }\n      if (ordering!=NULL) {\n        free(ordering);  \n      }\n      free(quad_crit);\n    } else {\n      testErrorRetVA(1==1,hdf5_base,\"does not understand criterion '%s' in %s\",*err,__LINE__,NULL,crit_name,df->root);\n    }\n    free(crit_name);\n  }\n  \n  free(rq_hat);\n  \n  if (rq_0!=NULL) {\n    free(rq_0);\n  }    \n  \n  if (wq!=NULL) {\n    free(wq);\n  }  \n  \n  cing = init_cmblkl(smic, &Smica_lkl, \n                     &free_Smica,\n                     nell,ell,\n                     has_cl,ell[nell-1],unit,wl,0,bins,nbins,xdim,err);\n  forwardError(*err,__LINE__,NULL);\n  if (xdim!=0) {\n    cmblkl_set_names(cing, xnames,err);\n    forwardError(*err,__LINE__,NULL);\n  \n    free(xnames);\n    free(xnames_buf);\n  }\n  \n  \n  \n  return cing;  \n}\n#endif\n\n\nSmicaComp * clik_smica_comp_1d_init(cldf *df,int nb, int mT, int mP, int nell, int* ell, int* has_cl, double unit,double* wl, double *bins, int nbins, error **err) {\n  double *someA;\n  int nA;\n  SmicaComp *SC;\n  int hk;\n  int m;\n\n  m = mtot(mT,mP,has_cl);\n  // try to read A\n\n  someA = NULL;\n  \n  //hstat = H5LTfind_attribute(comp_id, \"A\");\n  hk = cldf_haskey(df,\"A\",err);\n  forwardError(*err,__LINE__,NULL);\n  if (hk==1) {\n    nA = -1;\n    //someA = hdf5_double_attarray(comp_id,cur_lkl,\"A\",&nA,err);\n    someA = cldf_readfloatarray(df,\"A\",&nA,err);\n    forwardError(*err,__LINE__,NULL);\n  }\n  testErrorRetVA(someA!=NULL && nA!=m,-100,\"Not enough data in %s (expected %d got %d)\",*err,__LINE__,NULL,df->root,nA,m);\n  SC = comp_1D_init(nb, m, someA, err);\n  forwardError(*err,__LINE__,NULL);    \n  if (someA!=NULL) {\n    free(someA);\n  }\n  return SC;\n}\n\nSmicaComp * clik_smica_comp_nd_init(cldf *df,int nb, int mT,int mP,int nell, int* ell, int* has_cl, double unit,double* wl, double *bins, int nbins, error **err) {\n  double *someA;\n  int nA;\n  int nd;\n  SmicaComp *SC;\n  int hk;\n  // try to read A\n  int m;\n\n  m = mtot(mT,mP,has_cl);\n  \n  nd = cldf_readint(df,\"nd\",err);\n  forwardError(*err,__LINE__,NULL);    \n  \n  //hstat = H5LTget_attribute_int(comp_id, \".\", \"nd\",  &nd);\n  //testErrorRetVA(hstat<0,hdf5_base,\"cannot read nd in component %s (got %d)\",*err,__LINE__,NULL,cur_lkl,hstat);\n\n  someA = NULL;\n  hk = cldf_haskey(df,\"A\",err);\n  forwardError(*err,__LINE__,NULL);\n  //hstat = H5LTfind_attribute(comp_id, \"A\");\n  if (hk==1) {\n    nA = -1;\n    //someA = hdf5_double_attarray(comp_id,cur_lkl,\"A\",&nA,err);\n    someA = cldf_readfloatarray(df,\"A\",&nA,err);\n    forwardError(*err,__LINE__,NULL);\n  }\n  \n  testErrorRetVA(someA!=NULL && nA!=m*nd,-100,\"Not enough data in %s (expected %d got %d)\",*err,__LINE__,NULL,df->root,nA,m*nd);\n  SC = comp_nD_init(nb, m, nd, someA, err);\n  forwardError(*err,__LINE__,NULL);    \n  if (someA!=NULL) {\n    free(someA);\n  }\n  return SC;\n}\n\n\n\nSmicaComp * clik_smica_comp_calTP_init(cldf *df,int nb, int mT,int mP, int nell, int* ell, int* has_cl, double unit,double* wl, double *bins, int nbins,error **err) {\n  SmicaComp *SC; \n  int npar,i;\n  int *im,*jm;\n  double *tpl;\n  int tot_tpl;\n  char *bnames, **xnames;\n  int m;\n  int dsz;\n  double *w;\n  int *other;\n  int hk,im1,im2;\n\n  m = mtot(mT,mP,has_cl);\n  \n  npar = -1;\n  im =  cldf_readintarray(df,\"im\",&npar,err);\n  forwardError(*err,__LINE__,NULL);    \n\n\n  hk = cldf_haskey(df,\"w\",err);\n  forwardError(*err,__LINE__,NULL);\n  //hstat = H5LTfind_attribute(comp_id, \"A\");\n  if (hk==1) {\n    int sz;\n    sz = m*m*2;\n    w = cldf_readfloatarray(df,\"w\",&sz,err);\n    forwardError(*err,__LINE__,NULL);\n    other = cldf_readintarray(df,\"other\",&sz,err);\n    forwardError(*err,__LINE__,NULL);\n  } else {\n    //_DEBUGHERE_(\"%d\",m);\n    w = malloc_err(sizeof(double)*m*m*2,err);\n    forwardError(*err,__LINE__,NULL);\n    other = malloc_err(sizeof(int)*m*m*2,err);\n    forwardError(*err,__LINE__,NULL);\n    for(im1=0;im1<m;im1++) {\n      for(im2=im1;im2<m;im2++) {\n        w[(im1*m+im2)*2 + 0] = 1;\n        w[(im1*m+im2)*2 + 1] = 0;\n        w[(im2*m+im1)*2 + 0] = 1;\n        w[(im2*m+im1)*2 + 1] = 0;\n        other[(im1*m+im2)*2 + 0] = im1;\n        other[(im1*m+im2)*2 + 1] = im2;\n        other[(im2*m+im1)*2 + 0] = im2;\n        other[(im2*m+im1)*2 + 1] = im1;\n        //_DEBUGHERE_(\"%d w %d,%d->%g,%g, other %d,%d->%d,%d\",(im1*m+im2)*2,im1,im2,w[(im1*m+im2)*2 + 0],w[(im1*m+im2)*2 + 1],im1,im2,other[(im1*m+im2)*2 + 0],other[(im1*m+im2)*2 + 1])\n        //_DEBUGHERE_(\"%d %d %d %d | %d\",(im1*m+im2)*2 + 0, (im1*m+im2)*2 + 1, (im2*m+im1)*2 + 0, (im2*m+im1)*2 + 1,m*m*2);\n      }\n    }\n  }\n  \n\n  SC = comp_calTP_init(nb, mT,mP,has_cl, npar, im,w,other,  err);\n  forwardError(*err,__LINE__,NULL);    \n  \n  free(im);\n  free(w);\n  free(other);\n\n  dsz = -1;\n  bnames = cldf_readstr(df,\"names\",&dsz, err);\n  forwardError(*err,__LINE__,NULL); \n  xnames = malloc_err(sizeof(char*)*npar,err);\n  for(i=0;i<npar;i++) {\n    xnames[i] =&(bnames[i*256]);\n  } \n  SC_setnames(SC, xnames, err);\n  forwardError(*err,__LINE__,NULL);\n  free(xnames); \n  free(bnames); \n  \n  return SC;\n}\n\nSmicaComp * clik_smica_comp_icalTP_init(cldf *df,int nb, int mT,int mP, int nell, int* ell, int* has_cl, double unit,double* wl, double *bins, int nbins,error **err) {\n  SmicaComp *SC; \n  int npar,i;\n  int *im,*jm;\n  double *tpl;\n  int tot_tpl;\n  char *bnames, **xnames;\n  int m;\n  int dsz;\n  double *w;\n  int *other;\n  int hk,im1,im2;\n\n  m = mtot(mT,mP,has_cl);\n  \n  npar = -1;\n  im =  cldf_readintarray(df,\"im\",&npar,err);\n  forwardError(*err,__LINE__,NULL);    \n\n\n  hk = cldf_haskey(df,\"w\",err);\n  forwardError(*err,__LINE__,NULL);\n  //hstat = H5LTfind_attribute(comp_id, \"A\");\n  if (hk==1) {\n    int sz;\n    sz = m*m*2;\n    w = cldf_readfloatarray(df,\"w\",&sz,err);\n    forwardError(*err,__LINE__,NULL);\n    other = cldf_readintarray(df,\"other\",&sz,err);\n    forwardError(*err,__LINE__,NULL);\n  } else {\n    //_DEBUGHERE_(\"%d\",m);\n    w = malloc_err(sizeof(double)*m*m*2,err);\n    forwardError(*err,__LINE__,NULL);\n    other = malloc_err(sizeof(int)*m*m*2,err);\n    forwardError(*err,__LINE__,NULL);\n    for(im1=0;im1<m;im1++) {\n      for(im2=im1;im2<m;im2++) {\n        w[(im1*m+im2)*2 + 0] = 1;\n        w[(im1*m+im2)*2 + 1] = 0;\n        w[(im2*m+im1)*2 + 0] = 1;\n        w[(im2*m+im1)*2 + 1] = 0;\n        other[(im1*m+im2)*2 + 0] = im1;\n        other[(im1*m+im2)*2 + 1] = im2;\n        other[(im2*m+im1)*2 + 0] = im2;\n        other[(im2*m+im1)*2 + 1] = im1;\n        //_DEBUGHERE_(\"%d w %d,%d->%g,%g, other %d,%d->%d,%d\",(im1*m+im2)*2,im1,im2,w[(im1*m+im2)*2 + 0],w[(im1*m+im2)*2 + 1],im1,im2,other[(im1*m+im2)*2 + 0],other[(im1*m+im2)*2 + 1])\n        //_DEBUGHERE_(\"%d %d %d %d | %d\",(im1*m+im2)*2 + 0, (im1*m+im2)*2 + 1, (im2*m+im1)*2 + 0, (im2*m+im1)*2 + 1,m*m*2);\n      }\n    }\n  }\n  \n\n  SC = comp_icalTP_init(nb, mT,mP,has_cl, npar, im,w,other,  err);\n  forwardError(*err,__LINE__,NULL);    \n  \n  free(im);\n  free(w);\n  free(other);\n\n  dsz = -1;\n  bnames = cldf_readstr(df,\"names\",&dsz, err);\n  forwardError(*err,__LINE__,NULL); \n  xnames = malloc_err(sizeof(char*)*npar,err);\n  for(i=0;i<npar;i++) {\n    xnames[i] =&(bnames[i*256]);\n  } \n  SC_setnames(SC, xnames, err);\n  forwardError(*err,__LINE__,NULL);\n  free(xnames); \n  free(bnames); \n  \n  return SC;\n}\n\nSmicaComp * clik_smica_comp_beamTP_init(cldf *df,int nb, int mT,int mP, int nell, int* ell, int* has_cl, double unit,double* wl, double *bins, int nbins,error **err) {\n  SmicaComp *SC; \n  int npar,i;\n  int *im,*jm;\n  double *tpl;\n  int tot_tpl;\n  char *bnames, **xnames;\n  int m;\n  int dsz;\n  double *w;\n  int *other;\n  int hk,im1,im2;\n  int neigen;\n  double *modes;\n\n  m = mtot(mT,mP,has_cl);\n  \n  neigen = cldf_readint(df,\"neigen\",err);\n  forwardError(*err,__LINE__,NULL);    \n\n  npar = cldf_readint(df,\"npar\",err);\n  forwardError(*err,__LINE__,NULL);\n\n  dsz = m*m*neigen;\n  im =  cldf_readintarray(df,\"im\",&dsz,err);\n  forwardError(*err,__LINE__,NULL);    \n\n  dsz = m*m*neigen*nb;\n  modes = cldf_readfloatarray(df,\"modes\",&dsz,err);\n  forwardError(*err,__LINE__,NULL);    \n\n  SC = comp_beamTP_init(nb, mT,mP,has_cl,npar, im, neigen, modes ,err);\n  forwardError(*err,__LINE__,NULL);    \n\n  free(im);\n  free(modes);\n\n  dsz = -1;\n  bnames = cldf_readstr(df,\"names\",&dsz, err);\n  forwardError(*err,__LINE__,NULL); \n  xnames = malloc_err(sizeof(char*)*npar,err);\n  for(i=0;i<npar;i++) {\n    xnames[i] =&(bnames[i*256]);\n  } \n  SC_setnames(SC, xnames, err);\n  forwardError(*err,__LINE__,NULL);\n  free(xnames); \n  free(bnames); \n\n  return SC;\n}\n\nSmicaComp * clik_smica_comp_totcal_init(cldf *df,int nb, int mT,int mP, int nell, int* ell, int* has_cl, double unit,double* wl, double *bins, int nbins,error **err) {\n  SmicaComp *SC; \n  int npar,i;\n  int *im,*jm;\n  double *tpl;\n  int tot_tpl;\n  char *calname;\n  int m;\n  int dsz;\n  double *w;\n  int *other;\n  int hk,im1,im2;\n  int neigen;\n  double *modes;\n\n  m = mtot(mT,mP,has_cl);\n  \n  dsz = -1;\n  calname = cldf_readstr(df,\"calname\",&dsz, err);\n  forwardError(*err,__LINE__,NULL);  \n\n  SC = comp_totcal_init(nb, mT,mP,has_cl,err);\n  forwardError(*err,__LINE__,NULL);    \n\n  SC_setnames(SC, &calname, err);\n  forwardError(*err,__LINE__,NULL);\n  \n  free(calname); \n\n  return SC;\n}\n\nSmicaComp * clik_smica_comp_totcalP_init(cldf *df,int nb, int mT,int mP, int nell, int* ell, int* has_cl, double unit,double* wl, double *bins, int nbins,error **err) {\n  SmicaComp *SC; \n  int npar,i;\n  int *im,*jm;\n  double *tpl;\n  int tot_tpl;\n  char *calname;\n  int m;\n  int dsz;\n  double *w;\n  int *other;\n  int hk,im1,im2;\n  int neigen;\n  double *modes;\n\n  m = mtot(mT,mP,has_cl);\n  \n  dsz = -1;\n  calname = cldf_readstr(df,\"calnameP\",&dsz, err);\n  forwardError(*err,__LINE__,NULL);  \n\n  SC = comp_totcalP_init(nb, mT,mP,has_cl,err);\n  forwardError(*err,__LINE__,NULL);    \n\n  SC_setnames(SC, &calname, err);\n  forwardError(*err,__LINE__,NULL);\n  \n  free(calname); \n\n  return SC;\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-planck-likelihood-2.00-slmuk5nzhmgvwmawtpqoou6rzftvz6jg/spack-src/plc_2.0/hi_l/plik_lite/plik_lite_v18_TT.clik/clik/lkl_0/_external/c_matrix_plik_v18.dat",
        "/tmp/vanessa/spack-stage/spack-stage-planck-likelihood-2.00-slmuk5nzhmgvwmawtpqoou6rzftvz6jg/spack-src/plc_2.0/hi_l/plik_lite/plik_lite_v18_TTTEEE.clik/clik/lkl_0/_external/c_matrix_plik_v18.dat",
        "/tmp/vanessa/spack-stage/spack-stage-planck-likelihood-2.00-slmuk5nzhmgvwmawtpqoou6rzftvz6jg/spack-src/plc_2.0/low_l/commander/commander_rc2_v1.1_l2_29_B.clik/clik/lkl_0/_external/sigma.fits",
        "/tmp/vanessa/spack-stage/spack-stage-planck-likelihood-2.00-slmuk5nzhmgvwmawtpqoou6rzftvz6jg/spack-src/plc_2.0/low_l/bflike/lowl_SMW_70_dx11d_2014_10_03_v5c_Ap.clik/clik/lkl_0/_external/dataset_bflike_191014_70dx11d.dat",
        "/tmp/vanessa/spack-stage/spack-stage-planck-likelihood-2.00-slmuk5nzhmgvwmawtpqoou6rzftvz6jg/spack-src/plc_2.0/low_l/bflike/lowl_SMW_70_dx11d_2014_10_03_v5c_Ap.clik/clik/lkl_0/_external/dataset_bflike_191014_70dx11d.fits",
        "/tmp/vanessa/spack-stage/spack-stage-planck-likelihood-2.00-slmuk5nzhmgvwmawtpqoou6rzftvz6jg/spack-src/plc_2.0/low_l/bflike/lowl_SMW_70_dx11d_2014_10_03_v5c_Ap.clik/clik/lkl_0/_external/bflike_plm_191014_70dx11d.dat"
    ],
    "total_files": 158
}