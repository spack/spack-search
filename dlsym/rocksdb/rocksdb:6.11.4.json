{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/env/env_posix.cc": "//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.\n//  This source code is licensed under both the GPLv2 (found in the\n//  COPYING file in the root directory) and Apache 2.0 License\n//  (found in the LICENSE.Apache file in the root directory).\n//\n// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file. See the AUTHORS file for names of contributors\n#include <dirent.h>\n#ifndef ROCKSDB_NO_DYNAMIC_EXTENSION\n#include <dlfcn.h>\n#endif\n#include <errno.h>\n#include <fcntl.h>\n\n#if defined(OS_LINUX)\n#include <linux/fs.h>\n#endif\n#if defined(ROCKSDB_IOURING_PRESENT)\n#include <liburing.h>\n#endif\n#include <pthread.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#if defined(OS_LINUX) || defined(OS_SOLARIS) || defined(OS_ANDROID)\n#include <sys/statfs.h>\n#include <sys/syscall.h>\n#include <sys/sysmacros.h>\n#endif\n#include <sys/statvfs.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#if defined(ROCKSDB_IOURING_PRESENT)\n#include <sys/uio.h>\n#endif\n#include <time.h>\n#include <algorithm>\n// Get nano time includes\n#if defined(OS_LINUX) || defined(OS_FREEBSD)\n#elif defined(__MACH__)\n#include <Availability.h>\n#include <mach/clock.h>\n#include <mach/mach.h>\n#else\n#include <chrono>\n#endif\n#include <deque>\n#include <set>\n#include <vector>\n\n#include \"env/composite_env_wrapper.h\"\n#include \"env/io_posix.h\"\n#include \"logging/logging.h\"\n#include \"logging/posix_logger.h\"\n#include \"monitoring/iostats_context_imp.h\"\n#include \"monitoring/thread_status_updater.h\"\n#include \"port/port.h\"\n#include \"rocksdb/options.h\"\n#include \"rocksdb/slice.h\"\n#include \"test_util/sync_point.h\"\n#include \"util/coding.h\"\n#include \"util/compression_context_cache.h\"\n#include \"util/random.h\"\n#include \"util/string_util.h\"\n#include \"util/thread_local.h\"\n#include \"util/threadpool_imp.h\"\n\n#if !defined(TMPFS_MAGIC)\n#define TMPFS_MAGIC 0x01021994\n#endif\n#if !defined(XFS_SUPER_MAGIC)\n#define XFS_SUPER_MAGIC 0x58465342\n#endif\n#if !defined(EXT4_SUPER_MAGIC)\n#define EXT4_SUPER_MAGIC 0xEF53\n#endif\n\nnamespace ROCKSDB_NAMESPACE {\n#if defined(OS_WIN)\nstatic const std::string kSharedLibExt = \".dll\";\nstatic const char kPathSeparator = ';';\n#else\nstatic const char kPathSeparator = ':';\n#if defined(OS_MACOSX)\nstatic const std::string kSharedLibExt = \".dylib\";\n#else\nstatic const std::string kSharedLibExt = \".so\";\n#endif\n#endif\n\nnamespace {\n\nThreadStatusUpdater* CreateThreadStatusUpdater() {\n  return new ThreadStatusUpdater();\n}\n\n#ifndef ROCKSDB_NO_DYNAMIC_EXTENSION\nclass PosixDynamicLibrary : public DynamicLibrary {\n public:\n  PosixDynamicLibrary(const std::string& name, void* handle)\n      : name_(name), handle_(handle) {}\n  ~PosixDynamicLibrary() override { dlclose(handle_); }\n\n  Status LoadSymbol(const std::string& sym_name, void** func) override {\n    assert(nullptr != func);\n    dlerror();  // Clear any old error\n    *func = dlsym(handle_, sym_name.c_str());\n    if (*func != nullptr) {\n      return Status::OK();\n    } else {\n      char* err = dlerror();\n      return Status::NotFound(\"Error finding symbol: \" + sym_name, err);\n    }\n  }\n\n  const char* Name() const override { return name_.c_str(); }\n\n private:\n  std::string name_;\n  void* handle_;\n};\n#endif  // !ROCKSDB_NO_DYNAMIC_EXTENSION\n\nclass PosixEnv : public CompositeEnvWrapper {\n public:\n  // This constructor is for constructing non-default Envs, mainly by\n  // NewCompositeEnv(). It allows new instances to share the same\n  // threadpool and other resources as the default Env, while allowing\n  // a non-default FileSystem implementation\n  PosixEnv(const PosixEnv* default_env, std::shared_ptr<FileSystem> fs);\n\n  ~PosixEnv() override {\n    if (this == Env::Default()) {\n      for (const auto tid : threads_to_join_) {\n        pthread_join(tid, nullptr);\n      }\n      for (int pool_id = 0; pool_id < Env::Priority::TOTAL; ++pool_id) {\n        thread_pools_[pool_id].JoinAllThreads();\n      }\n      // Do not delete the thread_status_updater_ in order to avoid the\n      // free after use when Env::Default() is destructed while some other\n      // child threads are still trying to update thread status. All\n      // PosixEnv instances use the same thread_status_updater_, so never\n      // explicitly delete it.\n    }\n  }\n\n  void SetFD_CLOEXEC(int fd, const EnvOptions* options) {\n    if ((options == nullptr || options->set_fd_cloexec) && fd > 0) {\n      fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n    }\n  }\n\n#ifndef ROCKSDB_NO_DYNAMIC_EXTENSION\n  // Loads the named library into the result.\n  // If the input name is empty, the current executable is loaded\n  // On *nix systems, a \"lib\" prefix is added to the name if one is not supplied\n  // Comparably, the appropriate shared library extension is added to the name\n  // if not supplied. If search_path is not specified, the shared library will\n  // be loaded using the default path (LD_LIBRARY_PATH) If search_path is\n  // specified, the shared library will be searched for in the directories\n  // provided by the search path\n  Status LoadLibrary(const std::string& name, const std::string& path,\n                     std::shared_ptr<DynamicLibrary>* result) override {\n    Status status;\n    assert(result != nullptr);\n    if (name.empty()) {\n      void* hndl = dlopen(NULL, RTLD_NOW);\n      if (hndl != nullptr) {\n        result->reset(new PosixDynamicLibrary(name, hndl));\n        return Status::OK();\n      }\n    } else {\n      std::string library_name = name;\n      if (library_name.find(kSharedLibExt) == std::string::npos) {\n        library_name = library_name + kSharedLibExt;\n      }\n#if !defined(OS_WIN)\n      if (library_name.find('/') == std::string::npos &&\n          library_name.compare(0, 3, \"lib\") != 0) {\n        library_name = \"lib\" + library_name;\n      }\n#endif\n      if (path.empty()) {\n        void* hndl = dlopen(library_name.c_str(), RTLD_NOW);\n        if (hndl != nullptr) {\n          result->reset(new PosixDynamicLibrary(library_name, hndl));\n          return Status::OK();\n        }\n      } else {\n        std::string local_path;\n        std::stringstream ss(path);\n        while (getline(ss, local_path, kPathSeparator)) {\n          if (!path.empty()) {\n            std::string full_name = local_path + \"/\" + library_name;\n            void* hndl = dlopen(full_name.c_str(), RTLD_NOW);\n            if (hndl != nullptr) {\n              result->reset(new PosixDynamicLibrary(full_name, hndl));\n              return Status::OK();\n            }\n          }\n        }\n      }\n    }\n    return Status::IOError(\n        IOErrorMsg(\"Failed to open shared library: xs\", name), dlerror());\n  }\n#endif  // !ROCKSDB_NO_DYNAMIC_EXTENSION\n\n  void Schedule(void (*function)(void* arg1), void* arg, Priority pri = LOW,\n                void* tag = nullptr,\n                void (*unschedFunction)(void* arg) = nullptr) override;\n\n  int UnSchedule(void* arg, Priority pri) override;\n\n  void StartThread(void (*function)(void* arg), void* arg) override;\n\n  void WaitForJoin() override;\n\n  unsigned int GetThreadPoolQueueLen(Priority pri = LOW) const override;\n\n  Status GetThreadList(std::vector<ThreadStatus>* thread_list) override {\n    assert(thread_status_updater_);\n    return thread_status_updater_->GetThreadList(thread_list);\n  }\n\n  static uint64_t gettid(pthread_t tid) {\n    uint64_t thread_id = 0;\n    memcpy(&thread_id, &tid, std::min(sizeof(thread_id), sizeof(tid)));\n    return thread_id;\n  }\n\n  static uint64_t gettid() {\n    pthread_t tid = pthread_self();\n    return gettid(tid);\n  }\n\n  uint64_t GetThreadID() const override { return gettid(pthread_self()); }\n\n  uint64_t NowMicros() override {\n    struct timeval tv;\n    gettimeofday(&tv, nullptr);\n    return static_cast<uint64_t>(tv.tv_sec) * 1000000 + tv.tv_usec;\n  }\n\n  uint64_t NowNanos() override {\n#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_AIX)\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    return static_cast<uint64_t>(ts.tv_sec) * 1000000000 + ts.tv_nsec;\n#elif defined(OS_SOLARIS)\n    return gethrtime();\n#elif defined(__MACH__)\n    clock_serv_t cclock;\n    mach_timespec_t ts;\n    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &cclock);\n    clock_get_time(cclock, &ts);\n    mach_port_deallocate(mach_task_self(), cclock);\n    return static_cast<uint64_t>(ts.tv_sec) * 1000000000 + ts.tv_nsec;\n#else\n    return std::chrono::duration_cast<std::chrono::nanoseconds>(\n       std::chrono::steady_clock::now().time_since_epoch()).count();\n#endif\n  }\n\n  uint64_t NowCPUNanos() override {\n#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_AIX) || \\\n    (defined(__MACH__) && defined(__MAC_10_12))\n    struct timespec ts;\n    clock_gettime(CLOCK_THREAD_CPUTIME_ID, &ts);\n    return static_cast<uint64_t>(ts.tv_sec) * 1000000000 + ts.tv_nsec;\n#endif\n    return 0;\n  }\n\n  void SleepForMicroseconds(int micros) override { usleep(micros); }\n\n  Status GetHostName(char* name, uint64_t len) override {\n    int ret = gethostname(name, static_cast<size_t>(len));\n    if (ret < 0) {\n      if (errno == EFAULT || errno == EINVAL) {\n        return Status::InvalidArgument(strerror(errno));\n      } else {\n        return IOError(\"GetHostName\", name, errno);\n      }\n    }\n    return Status::OK();\n  }\n\n  Status GetCurrentTime(int64_t* unix_time) override {\n    time_t ret = time(nullptr);\n    if (ret == (time_t) -1) {\n      return IOError(\"GetCurrentTime\", \"\", errno);\n    }\n    *unix_time = (int64_t) ret;\n    return Status::OK();\n  }\n\n  ThreadStatusUpdater* GetThreadStatusUpdater() const override {\n    return Env::GetThreadStatusUpdater();\n  }\n\n  std::string GenerateUniqueId() override { return Env::GenerateUniqueId(); }\n\n  // Allow increasing the number of worker threads.\n  void SetBackgroundThreads(int num, Priority pri) override {\n    assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n    thread_pools_[pri].SetBackgroundThreads(num);\n  }\n\n  int GetBackgroundThreads(Priority pri) override {\n    assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n    return thread_pools_[pri].GetBackgroundThreads();\n  }\n\n  Status SetAllowNonOwnerAccess(bool allow_non_owner_access) override {\n    allow_non_owner_access_ = allow_non_owner_access;\n    return Status::OK();\n  }\n\n  // Allow increasing the number of worker threads.\n  void IncBackgroundThreadsIfNeeded(int num, Priority pri) override {\n    assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n    thread_pools_[pri].IncBackgroundThreadsIfNeeded(num);\n  }\n\n  void LowerThreadPoolIOPriority(Priority pool = LOW) override {\n    assert(pool >= Priority::BOTTOM && pool <= Priority::HIGH);\n#ifdef OS_LINUX\n    thread_pools_[pool].LowerIOPriority();\n#else\n    (void)pool;\n#endif\n  }\n\n  void LowerThreadPoolCPUPriority(Priority pool = LOW) override {\n    assert(pool >= Priority::BOTTOM && pool <= Priority::HIGH);\n#ifdef OS_LINUX\n    thread_pools_[pool].LowerCPUPriority();\n#else\n    (void)pool;\n#endif\n  }\n\n  std::string TimeToString(uint64_t secondsSince1970) override {\n    const time_t seconds = (time_t)secondsSince1970;\n    struct tm t;\n    int maxsize = 64;\n    std::string dummy;\n    dummy.reserve(maxsize);\n    dummy.resize(maxsize);\n    char* p = &dummy[0];\n    localtime_r(&seconds, &t);\n    snprintf(p, maxsize,\n             \"%04d/%02d/%02d-%02d:%02d:%02d \",\n             t.tm_year + 1900,\n             t.tm_mon + 1,\n             t.tm_mday,\n             t.tm_hour,\n             t.tm_min,\n             t.tm_sec);\n    return dummy;\n  }\n\n private:\n  friend Env* Env::Default();\n  // Constructs the default Env, a singleton\n  PosixEnv();\n\n  // The below 4 members are only used by the default PosixEnv instance.\n  // Non-default instances simply maintain references to the backing\n  // members in te default instance\n  std::vector<ThreadPoolImpl> thread_pools_storage_;\n  pthread_mutex_t mu_storage_;\n  std::vector<pthread_t> threads_to_join_storage_;\n  bool allow_non_owner_access_storage_;\n\n  std::vector<ThreadPoolImpl>& thread_pools_;\n  pthread_mutex_t& mu_;\n  std::vector<pthread_t>& threads_to_join_;\n  // If true, allow non owner read access for db files. Otherwise, non-owner\n  //  has no access to db files.\n  bool& allow_non_owner_access_;\n};\n\nPosixEnv::PosixEnv()\n    : CompositeEnvWrapper(this, FileSystem::Default()),\n      thread_pools_storage_(Priority::TOTAL),\n      allow_non_owner_access_storage_(true),\n      thread_pools_(thread_pools_storage_),\n      mu_(mu_storage_),\n      threads_to_join_(threads_to_join_storage_),\n      allow_non_owner_access_(allow_non_owner_access_storage_) {\n  ThreadPoolImpl::PthreadCall(\"mutex_init\", pthread_mutex_init(&mu_, nullptr));\n  for (int pool_id = 0; pool_id < Env::Priority::TOTAL; ++pool_id) {\n    thread_pools_[pool_id].SetThreadPriority(\n        static_cast<Env::Priority>(pool_id));\n    // This allows later initializing the thread-local-env of each thread.\n    thread_pools_[pool_id].SetHostEnv(this);\n  }\n  thread_status_updater_ = CreateThreadStatusUpdater();\n}\n\nPosixEnv::PosixEnv(const PosixEnv* default_env, std::shared_ptr<FileSystem> fs)\n  : CompositeEnvWrapper(this, fs),\n    thread_pools_(default_env->thread_pools_),\n    mu_(default_env->mu_),\n    threads_to_join_(default_env->threads_to_join_),\n    allow_non_owner_access_(default_env->allow_non_owner_access_) {\n  thread_status_updater_ = default_env->thread_status_updater_;\n}\n\nvoid PosixEnv::Schedule(void (*function)(void* arg1), void* arg, Priority pri,\n                        void* tag, void (*unschedFunction)(void* arg)) {\n  assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n  thread_pools_[pri].Schedule(function, arg, tag, unschedFunction);\n}\n\nint PosixEnv::UnSchedule(void* arg, Priority pri) {\n  return thread_pools_[pri].UnSchedule(arg);\n}\n\nunsigned int PosixEnv::GetThreadPoolQueueLen(Priority pri) const {\n  assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n  return thread_pools_[pri].GetQueueLen();\n}\n\nstruct StartThreadState {\n  void (*user_function)(void*);\n  void* arg;\n};\n\nstatic void* StartThreadWrapper(void* arg) {\n  StartThreadState* state = reinterpret_cast<StartThreadState*>(arg);\n  state->user_function(state->arg);\n  delete state;\n  return nullptr;\n}\n\nvoid PosixEnv::StartThread(void (*function)(void* arg), void* arg) {\n  pthread_t t;\n  StartThreadState* state = new StartThreadState;\n  state->user_function = function;\n  state->arg = arg;\n  ThreadPoolImpl::PthreadCall(\n      \"start thread\", pthread_create(&t, nullptr, &StartThreadWrapper, state));\n  ThreadPoolImpl::PthreadCall(\"lock\", pthread_mutex_lock(&mu_));\n  threads_to_join_.push_back(t);\n  ThreadPoolImpl::PthreadCall(\"unlock\", pthread_mutex_unlock(&mu_));\n}\n\nvoid PosixEnv::WaitForJoin() {\n  for (const auto tid : threads_to_join_) {\n    pthread_join(tid, nullptr);\n  }\n  threads_to_join_.clear();\n}\n\n}  // namespace\n\nstd::string Env::GenerateUniqueId() {\n  std::string uuid_file = \"/proc/sys/kernel/random/uuid\";\n\n  Status s = FileExists(uuid_file);\n  if (s.ok()) {\n    std::string uuid;\n    s = ReadFileToString(this, uuid_file, &uuid);\n    if (s.ok()) {\n      return uuid;\n    }\n  }\n  // Could not read uuid_file - generate uuid using \"nanos-random\"\n  Random64 r(time(nullptr));\n  uint64_t random_uuid_portion =\n    r.Uniform(std::numeric_limits<uint64_t>::max());\n  uint64_t nanos_uuid_portion = NowNanos();\n  char uuid2[200];\n  snprintf(uuid2,\n           200,\n           \"%lx-%lx\",\n           (unsigned long)nanos_uuid_portion,\n           (unsigned long)random_uuid_portion);\n  return uuid2;\n}\n\n//\n// Default Posix Env\n//\nEnv* Env::Default() {\n  // The following function call initializes the singletons of ThreadLocalPtr\n  // right before the static default_env.  This guarantees default_env will\n  // always being destructed before the ThreadLocalPtr singletons get\n  // destructed as C++ guarantees that the destructions of static variables\n  // is in the reverse order of their constructions.\n  //\n  // Since static members are destructed in the reverse order\n  // of their construction, having this call here guarantees that\n  // the destructor of static PosixEnv will go first, then the\n  // the singletons of ThreadLocalPtr.\n  ThreadLocalPtr::InitSingletons();\n  CompressionContextCache::InitSingleton();\n  INIT_SYNC_POINT_SINGLETONS();\n  static PosixEnv default_env;\n  return &default_env;\n}\n\nstd::unique_ptr<Env> NewCompositeEnv(std::shared_ptr<FileSystem> fs) {\n  PosixEnv* default_env = static_cast<PosixEnv*>(Env::Default());\n  return std::unique_ptr<Env>(new PosixEnv(default_env, fs));\n}\n\n}  // namespace ROCKSDB_NAMESPACE\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/WINDOWS_PORT.md",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/favicon.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/og_image.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/pcache-filelayout.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/pcache-blockindex.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/pcache-readiopath.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/Resize-of-20140327_200754-300x225.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/pcache-writeiopath.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/pcache-fileindex.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/bloom_fp_vs_bpk.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/pcache-tieredstorage.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/tree_example1.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/binaryseek.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/compaction/l0-l1-contend.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/compaction/l1-l2-contend.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/compaction/part-range-old.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/compaction/full-range.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/delrange/delrange_collapsed.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/delrange/delrange_sst_blocks.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/delrange/delrange_write_path.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/delrange/delrange_key_schema.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/delrange/delrange_uncollapsed.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/data-block-hash-index/perf-cache-miss.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/data-block-hash-index/hash-index-data-structure.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/data-block-hash-index/block-format-binary-seek.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/data-block-hash-index/block-format-hash-index.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/data-block-hash-index/perf-throughput.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/rate-limiter/write-KBps-series.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/rate-limiter/write-KBps-cdf.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/images/rate-limiter/auto-tuned-write-KBps-series.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/fonts/LatoLatin-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/fonts/LatoLatin-Black.woff",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/fonts/LatoLatin-BlackItalic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/fonts/LatoLatin-Regular.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/fonts/LatoLatin-Italic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/fonts/LatoLatin-Italic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/fonts/LatoLatin-Light.woff",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/fonts/LatoLatin-BlackItalic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/fonts/LatoLatin-Light.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.11.4-gcm7z3psxbdi556ty6kaide3qhsorzdl/spack-src/docs/static/fonts/LatoLatin-Black.woff2"
    ],
    "total_files": 1604
}