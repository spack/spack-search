{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/env/env_posix.cc": "//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.\n//  This source code is licensed under both the GPLv2 (found in the\n//  COPYING file in the root directory) and Apache 2.0 License\n//  (found in the LICENSE.Apache file in the root directory).\n//\n// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file. See the AUTHORS file for names of contributors\n#include <dirent.h>\n#ifndef ROCKSDB_NO_DYNAMIC_EXTENSION\n#include <dlfcn.h>\n#endif\n#include <errno.h>\n#include <fcntl.h>\n\n#if defined(OS_LINUX)\n#include <linux/fs.h>\n#endif\n#include <pthread.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#if defined(OS_LINUX) || defined(OS_SOLARIS) || defined(OS_ANDROID)\n#include <sys/statfs.h>\n#include <sys/syscall.h>\n#include <sys/sysmacros.h>\n#endif\n#include <sys/statvfs.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <time.h>\n#include <algorithm>\n// Get nano time includes\n#if defined(OS_LINUX) || defined(OS_FREEBSD)\n#elif defined(__MACH__)\n#include <Availability.h>\n#include <mach/clock.h>\n#include <mach/mach.h>\n#else\n#include <chrono>\n#endif\n#include <deque>\n#include <set>\n#include <vector>\n\n#include \"env/io_posix.h\"\n#include \"logging/logging.h\"\n#include \"logging/posix_logger.h\"\n#include \"monitoring/iostats_context_imp.h\"\n#include \"monitoring/thread_status_updater.h\"\n#include \"port/port.h\"\n#include \"rocksdb/options.h\"\n#include \"rocksdb/slice.h\"\n#include \"test_util/sync_point.h\"\n#include \"util/coding.h\"\n#include \"util/compression_context_cache.h\"\n#include \"util/random.h\"\n#include \"util/string_util.h\"\n#include \"util/thread_local.h\"\n#include \"util/threadpool_imp.h\"\n\n#if !defined(TMPFS_MAGIC)\n#define TMPFS_MAGIC 0x01021994\n#endif\n#if !defined(XFS_SUPER_MAGIC)\n#define XFS_SUPER_MAGIC 0x58465342\n#endif\n#if !defined(EXT4_SUPER_MAGIC)\n#define EXT4_SUPER_MAGIC 0xEF53\n#endif\n\nnamespace rocksdb {\n#if defined(OS_WIN)\nstatic const std::string kSharedLibExt = \".dll\";\nstatic const char kPathSeparator = ';';\n#else\nstatic const char kPathSeparator = ':';\n#if defined(OS_MACOSX)\nstatic const std::string kSharedLibExt = \".dylib\";\n#else\nstatic const std::string kSharedLibExt = \".so\";\n#endif\n#endif\n\nnamespace {\n\nThreadStatusUpdater* CreateThreadStatusUpdater() {\n  return new ThreadStatusUpdater();\n}\n\ninline mode_t GetDBFileMode(bool allow_non_owner_access) {\n  return allow_non_owner_access ? 0644 : 0600;\n}\n\n// list of pathnames that are locked\nstatic std::set<std::string> lockedFiles;\nstatic port::Mutex mutex_lockedFiles;\n\nstatic int LockOrUnlock(int fd, bool lock) {\n  errno = 0;\n  struct flock f;\n  memset(&f, 0, sizeof(f));\n  f.l_type = (lock ? F_WRLCK : F_UNLCK);\n  f.l_whence = SEEK_SET;\n  f.l_start = 0;\n  f.l_len = 0;        // Lock/unlock entire file\n  int value = fcntl(fd, F_SETLK, &f);\n\n  return value;\n}\n\nclass PosixFileLock : public FileLock {\n public:\n  int fd_;\n  std::string filename;\n};\n\nint cloexec_flags(int flags, const EnvOptions* options) {\n  // If the system supports opening the file with cloexec enabled,\n  // do so, as this avoids a race condition if a db is opened around\n  // the same time that a child process is forked\n#ifdef O_CLOEXEC\n  if (options == nullptr || options->set_fd_cloexec) {\n    flags |= O_CLOEXEC;\n  }\n#endif\n  return flags;\n}\n\n#ifndef ROCKSDB_NO_DYNAMIC_EXTENSION\nclass PosixDynamicLibrary : public DynamicLibrary {\n public:\n  PosixDynamicLibrary(const std::string& name, void* handle)\n      : name_(name), handle_(handle) {}\n  ~PosixDynamicLibrary() override { dlclose(handle_); }\n\n  Status LoadSymbol(const std::string& sym_name, void** func) override {\n    assert(nullptr != func);\n    dlerror();  // Clear any old error\n    *func = dlsym(handle_, sym_name.c_str());\n    if (*func != nullptr) {\n      return Status::OK();\n    } else {\n      char* err = dlerror();\n      return Status::NotFound(\"Error finding symbol: \" + sym_name, err);\n    }\n  }\n\n  const char* Name() const override { return name_.c_str(); }\n\n private:\n  std::string name_;\n  void* handle_;\n};\n#endif  // !ROCKSDB_NO_DYNAMIC_EXTENSION\n\nclass PosixEnv : public Env {\n public:\n  PosixEnv();\n\n  ~PosixEnv() override {\n    for (const auto tid : threads_to_join_) {\n      pthread_join(tid, nullptr);\n    }\n    for (int pool_id = 0; pool_id < Env::Priority::TOTAL; ++pool_id) {\n      thread_pools_[pool_id].JoinAllThreads();\n    }\n    // Delete the thread_status_updater_ only when the current Env is not\n    // Env::Default().  This is to avoid the free-after-use error when\n    // Env::Default() is destructed while some other child threads are\n    // still trying to update thread status.\n    if (this != Env::Default()) {\n      delete thread_status_updater_;\n    }\n  }\n\n  void SetFD_CLOEXEC(int fd, const EnvOptions* options) {\n    if ((options == nullptr || options->set_fd_cloexec) && fd > 0) {\n      fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n    }\n  }\n\n  Status NewSequentialFile(const std::string& fname,\n                           std::unique_ptr<SequentialFile>* result,\n                           const EnvOptions& options) override {\n    result->reset();\n    int fd = -1;\n    int flags = cloexec_flags(O_RDONLY, &options);\n    FILE* file = nullptr;\n\n    if (options.use_direct_reads && !options.use_mmap_reads) {\n#ifdef ROCKSDB_LITE\n      return Status::IOError(fname, \"Direct I/O not supported in RocksDB lite\");\n#endif  // !ROCKSDB_LITE\n#if !defined(OS_MACOSX) && !defined(OS_OPENBSD) && !defined(OS_SOLARIS)\n      flags |= O_DIRECT;\n#endif\n    }\n\n    do {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      fd = open(fname.c_str(), flags, GetDBFileMode(allow_non_owner_access_));\n    } while (fd < 0 && errno == EINTR);\n    if (fd < 0) {\n      return IOError(\"While opening a file for sequentially reading\", fname,\n                     errno);\n    }\n\n    SetFD_CLOEXEC(fd, &options);\n\n    if (options.use_direct_reads && !options.use_mmap_reads) {\n#ifdef OS_MACOSX\n      if (fcntl(fd, F_NOCACHE, 1) == -1) {\n        close(fd);\n        return IOError(\"While fcntl NoCache\", fname, errno);\n      }\n#endif\n    } else {\n      do {\n        IOSTATS_TIMER_GUARD(open_nanos);\n        file = fdopen(fd, \"r\");\n      } while (file == nullptr && errno == EINTR);\n      if (file == nullptr) {\n        close(fd);\n        return IOError(\"While opening file for sequentially read\", fname,\n                       errno);\n      }\n    }\n    result->reset(new PosixSequentialFile(fname, file, fd, options));\n    return Status::OK();\n  }\n\n  Status NewRandomAccessFile(const std::string& fname,\n                             std::unique_ptr<RandomAccessFile>* result,\n                             const EnvOptions& options) override {\n    result->reset();\n    Status s;\n    int fd;\n    int flags = cloexec_flags(O_RDONLY, &options);\n\n    if (options.use_direct_reads && !options.use_mmap_reads) {\n#ifdef ROCKSDB_LITE\n      return Status::IOError(fname, \"Direct I/O not supported in RocksDB lite\");\n#endif  // !ROCKSDB_LITE\n#if !defined(OS_MACOSX) && !defined(OS_OPENBSD) && !defined(OS_SOLARIS)\n      flags |= O_DIRECT;\n      TEST_SYNC_POINT_CALLBACK(\"NewRandomAccessFile:O_DIRECT\", &flags);\n#endif\n    }\n\n    do {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      fd = open(fname.c_str(), flags, GetDBFileMode(allow_non_owner_access_));\n    } while (fd < 0 && errno == EINTR);\n    if (fd < 0) {\n      return IOError(\"While open a file for random read\", fname, errno);\n    }\n    SetFD_CLOEXEC(fd, &options);\n\n    if (options.use_mmap_reads && sizeof(void*) >= 8) {\n      // Use of mmap for random reads has been removed because it\n      // kills performance when storage is fast.\n      // Use mmap when virtual address-space is plentiful.\n      uint64_t size;\n      s = GetFileSize(fname, &size);\n      if (s.ok()) {\n        void* base = mmap(nullptr, size, PROT_READ, MAP_SHARED, fd, 0);\n        if (base != MAP_FAILED) {\n          result->reset(new PosixMmapReadableFile(fd, fname, base,\n                                                  size, options));\n        } else {\n          s = IOError(\"while mmap file for read\", fname, errno);\n          close(fd);\n        }\n      }\n    } else {\n      if (options.use_direct_reads && !options.use_mmap_reads) {\n#ifdef OS_MACOSX\n        if (fcntl(fd, F_NOCACHE, 1) == -1) {\n          close(fd);\n          return IOError(\"while fcntl NoCache\", fname, errno);\n        }\n#endif\n      }\n      result->reset(new PosixRandomAccessFile(fname, fd, options));\n    }\n    return s;\n  }\n\n  virtual Status OpenWritableFile(const std::string& fname,\n                                  std::unique_ptr<WritableFile>* result,\n                                  const EnvOptions& options,\n                                  bool reopen = false) {\n    result->reset();\n    Status s;\n    int fd = -1;\n    int flags = (reopen) ? (O_CREAT | O_APPEND) : (O_CREAT | O_TRUNC);\n    // Direct IO mode with O_DIRECT flag or F_NOCAHCE (MAC OSX)\n    if (options.use_direct_writes && !options.use_mmap_writes) {\n      // Note: we should avoid O_APPEND here due to ta the following bug:\n      // POSIX requires that opening a file with the O_APPEND flag should\n      // have no affect on the location at which pwrite() writes data.\n      // However, on Linux, if a file is opened with O_APPEND, pwrite()\n      // appends data to the end of the file, regardless of the value of\n      // offset.\n      // More info here: https://linux.die.net/man/2/pwrite\n#ifdef ROCKSDB_LITE\n      return Status::IOError(fname, \"Direct I/O not supported in RocksDB lite\");\n#endif  // ROCKSDB_LITE\n      flags |= O_WRONLY;\n#if !defined(OS_MACOSX) && !defined(OS_OPENBSD) && !defined(OS_SOLARIS)\n      flags |= O_DIRECT;\n#endif\n      TEST_SYNC_POINT_CALLBACK(\"NewWritableFile:O_DIRECT\", &flags);\n    } else if (options.use_mmap_writes) {\n      // non-direct I/O\n      flags |= O_RDWR;\n    } else {\n      flags |= O_WRONLY;\n    }\n\n    flags = cloexec_flags(flags, &options);\n\n    do {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      fd = open(fname.c_str(), flags, GetDBFileMode(allow_non_owner_access_));\n    } while (fd < 0 && errno == EINTR);\n\n    if (fd < 0) {\n      s = IOError(\"While open a file for appending\", fname, errno);\n      return s;\n    }\n    SetFD_CLOEXEC(fd, &options);\n\n    if (options.use_mmap_writes) {\n      if (!checkedDiskForMmap_) {\n        // this will be executed once in the program's lifetime.\n        // do not use mmapWrite on non ext-3/xfs/tmpfs systems.\n        if (!SupportsFastAllocate(fname)) {\n          forceMmapOff_ = true;\n        }\n        checkedDiskForMmap_ = true;\n      }\n    }\n    if (options.use_mmap_writes && !forceMmapOff_) {\n      result->reset(new PosixMmapFile(fname, fd, page_size_, options));\n    } else if (options.use_direct_writes && !options.use_mmap_writes) {\n#ifdef OS_MACOSX\n      if (fcntl(fd, F_NOCACHE, 1) == -1) {\n        close(fd);\n        s = IOError(\"While fcntl NoCache an opened file for appending\", fname,\n                    errno);\n        return s;\n      }\n#elif defined(OS_SOLARIS)\n      if (directio(fd, DIRECTIO_ON) == -1) {\n        if (errno != ENOTTY) { // ZFS filesystems don't support DIRECTIO_ON\n          close(fd);\n          s = IOError(\"While calling directio()\", fname, errno);\n          return s;\n        }\n      }\n#endif\n      result->reset(new PosixWritableFile(fname, fd, options));\n    } else {\n      // disable mmap writes\n      EnvOptions no_mmap_writes_options = options;\n      no_mmap_writes_options.use_mmap_writes = false;\n      result->reset(new PosixWritableFile(fname, fd, no_mmap_writes_options));\n    }\n    return s;\n  }\n\n  Status NewWritableFile(const std::string& fname,\n                         std::unique_ptr<WritableFile>* result,\n                         const EnvOptions& options) override {\n    return OpenWritableFile(fname, result, options, false);\n  }\n\n  Status ReopenWritableFile(const std::string& fname,\n                            std::unique_ptr<WritableFile>* result,\n                            const EnvOptions& options) override {\n    return OpenWritableFile(fname, result, options, true);\n  }\n\n  Status ReuseWritableFile(const std::string& fname,\n                           const std::string& old_fname,\n                           std::unique_ptr<WritableFile>* result,\n                           const EnvOptions& options) override {\n    result->reset();\n    Status s;\n    int fd = -1;\n\n    int flags = 0;\n    // Direct IO mode with O_DIRECT flag or F_NOCAHCE (MAC OSX)\n    if (options.use_direct_writes && !options.use_mmap_writes) {\n#ifdef ROCKSDB_LITE\n      return Status::IOError(fname, \"Direct I/O not supported in RocksDB lite\");\n#endif  // !ROCKSDB_LITE\n      flags |= O_WRONLY;\n#if !defined(OS_MACOSX) && !defined(OS_OPENBSD) && !defined(OS_SOLARIS)\n      flags |= O_DIRECT;\n#endif\n      TEST_SYNC_POINT_CALLBACK(\"NewWritableFile:O_DIRECT\", &flags);\n    } else if (options.use_mmap_writes) {\n      // mmap needs O_RDWR mode\n      flags |= O_RDWR;\n    } else {\n      flags |= O_WRONLY;\n    }\n\n    flags = cloexec_flags(flags, &options);\n\n    do {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      fd = open(old_fname.c_str(), flags,\n                GetDBFileMode(allow_non_owner_access_));\n    } while (fd < 0 && errno == EINTR);\n    if (fd < 0) {\n      s = IOError(\"while reopen file for write\", fname, errno);\n      return s;\n    }\n\n    SetFD_CLOEXEC(fd, &options);\n    // rename into place\n    if (rename(old_fname.c_str(), fname.c_str()) != 0) {\n      s = IOError(\"while rename file to \" + fname, old_fname, errno);\n      close(fd);\n      return s;\n    }\n\n    if (options.use_mmap_writes) {\n      if (!checkedDiskForMmap_) {\n        // this will be executed once in the program's lifetime.\n        // do not use mmapWrite on non ext-3/xfs/tmpfs systems.\n        if (!SupportsFastAllocate(fname)) {\n          forceMmapOff_ = true;\n        }\n        checkedDiskForMmap_ = true;\n      }\n    }\n    if (options.use_mmap_writes && !forceMmapOff_) {\n      result->reset(new PosixMmapFile(fname, fd, page_size_, options));\n    } else if (options.use_direct_writes && !options.use_mmap_writes) {\n#ifdef OS_MACOSX\n      if (fcntl(fd, F_NOCACHE, 1) == -1) {\n        close(fd);\n        s = IOError(\"while fcntl NoCache for reopened file for append\", fname,\n                    errno);\n        return s;\n      }\n#elif defined(OS_SOLARIS)\n      if (directio(fd, DIRECTIO_ON) == -1) {\n        if (errno != ENOTTY) { // ZFS filesystems don't support DIRECTIO_ON\n          close(fd);\n          s = IOError(\"while calling directio()\", fname, errno);\n          return s;\n        }\n      }\n#endif\n      result->reset(new PosixWritableFile(fname, fd, options));\n    } else {\n      // disable mmap writes\n      EnvOptions no_mmap_writes_options = options;\n      no_mmap_writes_options.use_mmap_writes = false;\n      result->reset(new PosixWritableFile(fname, fd, no_mmap_writes_options));\n    }\n    return s;\n  }\n\n  Status NewRandomRWFile(const std::string& fname,\n                         std::unique_ptr<RandomRWFile>* result,\n                         const EnvOptions& options) override {\n    int fd = -1;\n    int flags = cloexec_flags(O_RDWR, &options);\n\n    while (fd < 0) {\n      IOSTATS_TIMER_GUARD(open_nanos);\n\n      fd = open(fname.c_str(), flags, GetDBFileMode(allow_non_owner_access_));\n      if (fd < 0) {\n        // Error while opening the file\n        if (errno == EINTR) {\n          continue;\n        }\n        return IOError(\"While open file for random read/write\", fname, errno);\n      }\n    }\n\n    SetFD_CLOEXEC(fd, &options);\n    result->reset(new PosixRandomRWFile(fname, fd, options));\n    return Status::OK();\n  }\n\n  Status NewMemoryMappedFileBuffer(\n      const std::string& fname,\n      std::unique_ptr<MemoryMappedFileBuffer>* result) override {\n    int fd = -1;\n    Status status;\n    int flags = cloexec_flags(O_RDWR, nullptr);\n\n    while (fd < 0) {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      fd = open(fname.c_str(), flags, 0644);\n      if (fd < 0) {\n        // Error while opening the file\n        if (errno == EINTR) {\n          continue;\n        }\n        status =\n            IOError(\"While open file for raw mmap buffer access\", fname, errno);\n        break;\n      }\n    }\n    uint64_t size;\n    if (status.ok()) {\n      status = GetFileSize(fname, &size);\n    }\n    void* base = nullptr;\n    if (status.ok()) {\n      base = mmap(nullptr, static_cast<size_t>(size), PROT_READ | PROT_WRITE,\n                  MAP_SHARED, fd, 0);\n      if (base == MAP_FAILED) {\n        status = IOError(\"while mmap file for read\", fname, errno);\n      }\n    }\n    if (status.ok()) {\n      result->reset(\n          new PosixMemoryMappedFileBuffer(base, static_cast<size_t>(size)));\n    }\n    if (fd >= 0) {\n      // don't need to keep it open after mmap has been called\n      close(fd);\n    }\n    return status;\n  }\n\n  Status NewDirectory(const std::string& name,\n                      std::unique_ptr<Directory>* result) override {\n    result->reset();\n    int fd;\n    int flags = cloexec_flags(0, nullptr);\n    {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      fd = open(name.c_str(), flags);\n    }\n    if (fd < 0) {\n      return IOError(\"While open directory\", name, errno);\n    } else {\n      result->reset(new PosixDirectory(fd));\n    }\n    return Status::OK();\n  }\n\n  Status FileExists(const std::string& fname) override {\n    int result = access(fname.c_str(), F_OK);\n\n    if (result == 0) {\n      return Status::OK();\n    }\n\n    int err = errno;\n    switch (err) {\n      case EACCES:\n      case ELOOP:\n      case ENAMETOOLONG:\n      case ENOENT:\n      case ENOTDIR:\n        return Status::NotFound();\n      default:\n        assert(err == EIO || err == ENOMEM);\n        return Status::IOError(\"Unexpected error(\" + ToString(err) +\n                               \") accessing file `\" + fname + \"' \");\n    }\n  }\n\n  Status GetChildren(const std::string& dir,\n                     std::vector<std::string>* result) override {\n    result->clear();\n    DIR* d = opendir(dir.c_str());\n    if (d == nullptr) {\n      switch (errno) {\n        case EACCES:\n        case ENOENT:\n        case ENOTDIR:\n          return Status::NotFound();\n        default:\n          return IOError(\"While opendir\", dir, errno);\n      }\n    }\n    struct dirent* entry;\n    while ((entry = readdir(d)) != nullptr) {\n      result->push_back(entry->d_name);\n    }\n    closedir(d);\n    return Status::OK();\n  }\n\n  Status DeleteFile(const std::string& fname) override {\n    Status result;\n    if (unlink(fname.c_str()) != 0) {\n      result = IOError(\"while unlink() file\", fname, errno);\n    }\n    return result;\n  };\n\n  Status CreateDir(const std::string& name) override {\n    Status result;\n    if (mkdir(name.c_str(), 0755) != 0) {\n      result = IOError(\"While mkdir\", name, errno);\n    }\n    return result;\n  };\n\n  Status CreateDirIfMissing(const std::string& name) override {\n    Status result;\n    if (mkdir(name.c_str(), 0755) != 0) {\n      if (errno != EEXIST) {\n        result = IOError(\"While mkdir if missing\", name, errno);\n      } else if (!DirExists(name)) { // Check that name is actually a\n                                     // directory.\n        // Message is taken from mkdir\n        result = Status::IOError(\"`\"+name+\"' exists but is not a directory\");\n      }\n    }\n    return result;\n  };\n\n  Status DeleteDir(const std::string& name) override {\n    Status result;\n    if (rmdir(name.c_str()) != 0) {\n      result = IOError(\"file rmdir\", name, errno);\n    }\n    return result;\n  };\n\n  Status GetFileSize(const std::string& fname, uint64_t* size) override {\n    Status s;\n    struct stat sbuf;\n    if (stat(fname.c_str(), &sbuf) != 0) {\n      *size = 0;\n      s = IOError(\"while stat a file for size\", fname, errno);\n    } else {\n      *size = sbuf.st_size;\n    }\n    return s;\n  }\n\n  Status GetFileModificationTime(const std::string& fname,\n                                 uint64_t* file_mtime) override {\n    struct stat s;\n    if (stat(fname.c_str(), &s) !=0) {\n      return IOError(\"while stat a file for modification time\", fname, errno);\n    }\n    *file_mtime = static_cast<uint64_t>(s.st_mtime);\n    return Status::OK();\n  }\n  Status RenameFile(const std::string& src,\n                    const std::string& target) override {\n    Status result;\n    if (rename(src.c_str(), target.c_str()) != 0) {\n      result = IOError(\"While renaming a file to \" + target, src, errno);\n    }\n    return result;\n  }\n\n  Status LinkFile(const std::string& src, const std::string& target) override {\n    Status result;\n    if (link(src.c_str(), target.c_str()) != 0) {\n      if (errno == EXDEV) {\n        return Status::NotSupported(\"No cross FS links allowed\");\n      }\n      result = IOError(\"while link file to \" + target, src, errno);\n    }\n    return result;\n  }\n\n  Status NumFileLinks(const std::string& fname, uint64_t* count) override {\n    struct stat s;\n    if (stat(fname.c_str(), &s) != 0) {\n      return IOError(\"while stat a file for num file links\", fname, errno);\n    }\n    *count = static_cast<uint64_t>(s.st_nlink);\n    return Status::OK();\n  }\n\n  Status AreFilesSame(const std::string& first, const std::string& second,\n                      bool* res) override {\n    struct stat statbuf[2];\n    if (stat(first.c_str(), &statbuf[0]) != 0) {\n      return IOError(\"stat file\", first, errno);\n    }\n    if (stat(second.c_str(), &statbuf[1]) != 0) {\n      return IOError(\"stat file\", second, errno);\n    }\n\n    if (major(statbuf[0].st_dev) != major(statbuf[1].st_dev) ||\n        minor(statbuf[0].st_dev) != minor(statbuf[1].st_dev) ||\n        statbuf[0].st_ino != statbuf[1].st_ino) {\n      *res = false;\n    } else {\n      *res = true;\n    }\n    return Status::OK();\n  }\n\n  Status LockFile(const std::string& fname, FileLock** lock) override {\n    *lock = nullptr;\n    Status result;\n\n    mutex_lockedFiles.Lock();\n    // If it already exists in the lockedFiles set, then it is already locked,\n    // and fail this lock attempt. Otherwise, insert it into lockedFiles.\n    // This check is needed because fcntl() does not detect lock conflict\n    // if the fcntl is issued by the same thread that earlier acquired\n    // this lock.\n    // We must do this check *before* opening the file:\n    // Otherwise, we will open a new file descriptor. Locks are associated with\n    // a process, not a file descriptor and when *any* file descriptor is closed,\n    // all locks the process holds for that *file* are released\n    if (lockedFiles.insert(fname).second == false) {\n      mutex_lockedFiles.Unlock();\n      errno = ENOLCK;\n      return IOError(\"lock \", fname, errno);\n    }\n\n    int fd;\n    int flags = cloexec_flags(O_RDWR | O_CREAT, nullptr);\n\n    {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      fd = open(fname.c_str(), flags, 0644);\n    }\n    if (fd < 0) {\n      result = IOError(\"while open a file for lock\", fname, errno);\n    } else if (LockOrUnlock(fd, true) == -1) {\n      // if there is an error in locking, then remove the pathname from lockedfiles\n      lockedFiles.erase(fname);\n      result = IOError(\"While lock file\", fname, errno);\n      close(fd);\n    } else {\n      SetFD_CLOEXEC(fd, nullptr);\n      PosixFileLock* my_lock = new PosixFileLock;\n      my_lock->fd_ = fd;\n      my_lock->filename = fname;\n      *lock = my_lock;\n    }\n\n    mutex_lockedFiles.Unlock();\n    return result;\n  }\n\n  Status UnlockFile(FileLock* lock) override {\n    PosixFileLock* my_lock = reinterpret_cast<PosixFileLock*>(lock);\n    Status result;\n    mutex_lockedFiles.Lock();\n    // If we are unlocking, then verify that we had locked it earlier,\n    // it should already exist in lockedFiles. Remove it from lockedFiles.\n    if (lockedFiles.erase(my_lock->filename) != 1) {\n      errno = ENOLCK;\n      result = IOError(\"unlock\", my_lock->filename, errno);\n    } else if (LockOrUnlock(my_lock->fd_, false) == -1) {\n      result = IOError(\"unlock\", my_lock->filename, errno);\n    }\n    close(my_lock->fd_);\n    delete my_lock;\n    mutex_lockedFiles.Unlock();\n    return result;\n  }\n\n#ifndef ROCKSDB_NO_DYNAMIC_EXTENSION\n  // Loads the named library into the result.\n  // If the input name is empty, the current executable is loaded\n  // On *nix systems, a \"lib\" prefix is added to the name if one is not supplied\n  // Comparably, the appropriate shared library extension is added to the name\n  // if not supplied. If search_path is not specified, the shared library will\n  // be loaded using the default path (LD_LIBRARY_PATH) If search_path is\n  // specified, the shared library will be searched for in the directories\n  // provided by the search path\n  Status LoadLibrary(const std::string& name, const std::string& path,\n                     std::shared_ptr<DynamicLibrary>* result) override {\n    Status status;\n    assert(result != nullptr);\n    if (name.empty()) {\n      void* hndl = dlopen(NULL, RTLD_NOW);\n      if (hndl != nullptr) {\n        result->reset(new PosixDynamicLibrary(name, hndl));\n        return Status::OK();\n      }\n    } else {\n      std::string library_name = name;\n      if (library_name.find(kSharedLibExt) == std::string::npos) {\n        library_name = library_name + kSharedLibExt;\n      }\n#if !defined(OS_WIN)\n      if (library_name.find('/') == std::string::npos &&\n          library_name.compare(0, 3, \"lib\") != 0) {\n        library_name = \"lib\" + library_name;\n      }\n#endif\n      if (path.empty()) {\n        void* hndl = dlopen(library_name.c_str(), RTLD_NOW);\n        if (hndl != nullptr) {\n          result->reset(new PosixDynamicLibrary(library_name, hndl));\n          return Status::OK();\n        }\n      } else {\n        std::string local_path;\n        std::stringstream ss(path);\n        while (getline(ss, local_path, kPathSeparator)) {\n          if (!path.empty()) {\n            std::string full_name = local_path + \"/\" + library_name;\n            void* hndl = dlopen(full_name.c_str(), RTLD_NOW);\n            if (hndl != nullptr) {\n              result->reset(new PosixDynamicLibrary(full_name, hndl));\n              return Status::OK();\n            }\n          }\n        }\n      }\n    }\n    return Status::IOError(\n        IOErrorMsg(\"Failed to open shared library: xs\", name), dlerror());\n  }\n#endif  // !ROCKSDB_NO_DYNAMIC_EXTENSION\n\n  void Schedule(void (*function)(void* arg1), void* arg, Priority pri = LOW,\n                void* tag = nullptr,\n                void (*unschedFunction)(void* arg) = nullptr) override;\n\n  int UnSchedule(void* arg, Priority pri) override;\n\n  void StartThread(void (*function)(void* arg), void* arg) override;\n\n  void WaitForJoin() override;\n\n  unsigned int GetThreadPoolQueueLen(Priority pri = LOW) const override;\n\n  Status GetTestDirectory(std::string* result) override {\n    const char* env = getenv(\"TEST_TMPDIR\");\n    if (env && env[0] != '\\0') {\n      *result = env;\n    } else {\n      char buf[100];\n      snprintf(buf, sizeof(buf), \"/tmp/rocksdbtest-%d\", int(geteuid()));\n      *result = buf;\n    }\n    // Directory may already exist\n    CreateDir(*result);\n    return Status::OK();\n  }\n\n  Status GetThreadList(std::vector<ThreadStatus>* thread_list) override {\n    assert(thread_status_updater_);\n    return thread_status_updater_->GetThreadList(thread_list);\n  }\n\n  static uint64_t gettid(pthread_t tid) {\n    uint64_t thread_id = 0;\n    memcpy(&thread_id, &tid, std::min(sizeof(thread_id), sizeof(tid)));\n    return thread_id;\n  }\n\n  static uint64_t gettid() {\n    pthread_t tid = pthread_self();\n    return gettid(tid);\n  }\n\n  uint64_t GetThreadID() const override { return gettid(pthread_self()); }\n\n  Status GetFreeSpace(const std::string& fname, uint64_t* free_space) override {\n    struct statvfs sbuf;\n\n    if (statvfs(fname.c_str(), &sbuf) < 0) {\n      return IOError(\"While doing statvfs\", fname, errno);\n    }\n\n    *free_space = ((uint64_t)sbuf.f_bsize * sbuf.f_bfree);\n    return Status::OK();\n  }\n\n  Status NewLogger(const std::string& fname,\n                   std::shared_ptr<Logger>* result) override {\n    FILE* f;\n    {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      f = fopen(fname.c_str(),\n                \"w\"\n#ifdef __GLIBC_PREREQ\n#if __GLIBC_PREREQ(2, 7)\n                \"e\"  // glibc extension to enable O_CLOEXEC\n#endif\n#endif\n      );\n    }\n    if (f == nullptr) {\n      result->reset();\n      return IOError(\"when fopen a file for new logger\", fname, errno);\n    } else {\n      int fd = fileno(f);\n#ifdef ROCKSDB_FALLOCATE_PRESENT\n      fallocate(fd, FALLOC_FL_KEEP_SIZE, 0, 4 * 1024);\n#endif\n      SetFD_CLOEXEC(fd, nullptr);\n      result->reset(new PosixLogger(f, &PosixEnv::gettid, this));\n      return Status::OK();\n    }\n  }\n\n  uint64_t NowMicros() override {\n    struct timeval tv;\n    gettimeofday(&tv, nullptr);\n    return static_cast<uint64_t>(tv.tv_sec) * 1000000 + tv.tv_usec;\n  }\n\n  uint64_t NowNanos() override {\n#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_AIX)\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    return static_cast<uint64_t>(ts.tv_sec) * 1000000000 + ts.tv_nsec;\n#elif defined(OS_SOLARIS)\n    return gethrtime();\n#elif defined(__MACH__)\n    clock_serv_t cclock;\n    mach_timespec_t ts;\n    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &cclock);\n    clock_get_time(cclock, &ts);\n    mach_port_deallocate(mach_task_self(), cclock);\n    return static_cast<uint64_t>(ts.tv_sec) * 1000000000 + ts.tv_nsec;\n#else\n    return std::chrono::duration_cast<std::chrono::nanoseconds>(\n       std::chrono::steady_clock::now().time_since_epoch()).count();\n#endif\n  }\n\n  uint64_t NowCPUNanos() override {\n#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_AIX) || \\\n    (defined(__MACH__) && defined(__MAC_10_12))\n    struct timespec ts;\n    clock_gettime(CLOCK_THREAD_CPUTIME_ID, &ts);\n    return static_cast<uint64_t>(ts.tv_sec) * 1000000000 + ts.tv_nsec;\n#endif\n    return 0;\n  }\n\n  void SleepForMicroseconds(int micros) override { usleep(micros); }\n\n  Status GetHostName(char* name, uint64_t len) override {\n    int ret = gethostname(name, static_cast<size_t>(len));\n    if (ret < 0) {\n      if (errno == EFAULT || errno == EINVAL)\n        return Status::InvalidArgument(strerror(errno));\n      else\n        return IOError(\"GetHostName\", name, errno);\n    }\n    return Status::OK();\n  }\n\n  Status GetCurrentTime(int64_t* unix_time) override {\n    time_t ret = time(nullptr);\n    if (ret == (time_t) -1) {\n      return IOError(\"GetCurrentTime\", \"\", errno);\n    }\n    *unix_time = (int64_t) ret;\n    return Status::OK();\n  }\n\n  Status GetAbsolutePath(const std::string& db_path,\n                         std::string* output_path) override {\n    if (!db_path.empty() && db_path[0] == '/') {\n      *output_path = db_path;\n      return Status::OK();\n    }\n\n    char the_path[256];\n    char* ret = getcwd(the_path, 256);\n    if (ret == nullptr) {\n      return Status::IOError(strerror(errno));\n    }\n\n    *output_path = ret;\n    return Status::OK();\n  }\n\n  // Allow increasing the number of worker threads.\n  void SetBackgroundThreads(int num, Priority pri) override {\n    assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n    thread_pools_[pri].SetBackgroundThreads(num);\n  }\n\n  int GetBackgroundThreads(Priority pri) override {\n    assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n    return thread_pools_[pri].GetBackgroundThreads();\n  }\n\n  Status SetAllowNonOwnerAccess(bool allow_non_owner_access) override {\n    allow_non_owner_access_ = allow_non_owner_access;\n    return Status::OK();\n  }\n\n  // Allow increasing the number of worker threads.\n  void IncBackgroundThreadsIfNeeded(int num, Priority pri) override {\n    assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n    thread_pools_[pri].IncBackgroundThreadsIfNeeded(num);\n  }\n\n  void LowerThreadPoolIOPriority(Priority pool = LOW) override {\n    assert(pool >= Priority::BOTTOM && pool <= Priority::HIGH);\n#ifdef OS_LINUX\n    thread_pools_[pool].LowerIOPriority();\n#else\n    (void)pool;\n#endif\n  }\n\n  void LowerThreadPoolCPUPriority(Priority pool = LOW) override {\n    assert(pool >= Priority::BOTTOM && pool <= Priority::HIGH);\n#ifdef OS_LINUX\n    thread_pools_[pool].LowerCPUPriority();\n#else\n    (void)pool;\n#endif\n  }\n\n  std::string TimeToString(uint64_t secondsSince1970) override {\n    const time_t seconds = (time_t)secondsSince1970;\n    struct tm t;\n    int maxsize = 64;\n    std::string dummy;\n    dummy.reserve(maxsize);\n    dummy.resize(maxsize);\n    char* p = &dummy[0];\n    localtime_r(&seconds, &t);\n    snprintf(p, maxsize,\n             \"%04d/%02d/%02d-%02d:%02d:%02d \",\n             t.tm_year + 1900,\n             t.tm_mon + 1,\n             t.tm_mday,\n             t.tm_hour,\n             t.tm_min,\n             t.tm_sec);\n    return dummy;\n  }\n\n  EnvOptions OptimizeForLogWrite(const EnvOptions& env_options,\n                                 const DBOptions& db_options) const override {\n    EnvOptions optimized = env_options;\n    optimized.use_mmap_writes = false;\n    optimized.use_direct_writes = false;\n    optimized.bytes_per_sync = db_options.wal_bytes_per_sync;\n    // TODO(icanadi) it's faster if fallocate_with_keep_size is false, but it\n    // breaks TransactionLogIteratorStallAtLastRecord unit test. Fix the unit\n    // test and make this false\n    optimized.fallocate_with_keep_size = true;\n    optimized.writable_file_max_buffer_size =\n        db_options.writable_file_max_buffer_size;\n    return optimized;\n  }\n\n  EnvOptions OptimizeForManifestWrite(\n      const EnvOptions& env_options) const override {\n    EnvOptions optimized = env_options;\n    optimized.use_mmap_writes = false;\n    optimized.use_direct_writes = false;\n    optimized.fallocate_with_keep_size = true;\n    return optimized;\n  }\n\n private:\n  bool checkedDiskForMmap_;\n  bool forceMmapOff_;  // do we override Env options?\n\n  // Returns true iff the named directory exists and is a directory.\n  virtual bool DirExists(const std::string& dname) {\n    struct stat statbuf;\n    if (stat(dname.c_str(), &statbuf) == 0) {\n      return S_ISDIR(statbuf.st_mode);\n    }\n    return false; // stat() failed return false\n  }\n\n  bool SupportsFastAllocate(const std::string& path) {\n#ifdef ROCKSDB_FALLOCATE_PRESENT\n    struct statfs s;\n    if (statfs(path.c_str(), &s)){\n      return false;\n    }\n    switch (s.f_type) {\n      case EXT4_SUPER_MAGIC:\n        return true;\n      case XFS_SUPER_MAGIC:\n        return true;\n      case TMPFS_MAGIC:\n        return true;\n      default:\n        return false;\n    }\n#else\n    (void)path;\n    return false;\n#endif\n  }\n\n  size_t page_size_;\n\n  std::vector<ThreadPoolImpl> thread_pools_;\n  pthread_mutex_t mu_;\n  std::vector<pthread_t> threads_to_join_;\n  // If true, allow non owner read access for db files. Otherwise, non-owner\n  //  has no access to db files.\n  bool allow_non_owner_access_;\n};\n\nPosixEnv::PosixEnv()\n    : checkedDiskForMmap_(false),\n      forceMmapOff_(false),\n      page_size_(getpagesize()),\n      thread_pools_(Priority::TOTAL),\n      allow_non_owner_access_(true) {\n  ThreadPoolImpl::PthreadCall(\"mutex_init\", pthread_mutex_init(&mu_, nullptr));\n  for (int pool_id = 0; pool_id < Env::Priority::TOTAL; ++pool_id) {\n    thread_pools_[pool_id].SetThreadPriority(\n        static_cast<Env::Priority>(pool_id));\n    // This allows later initializing the thread-local-env of each thread.\n    thread_pools_[pool_id].SetHostEnv(this);\n  }\n  thread_status_updater_ = CreateThreadStatusUpdater();\n}\n\nvoid PosixEnv::Schedule(void (*function)(void* arg1), void* arg, Priority pri,\n                        void* tag, void (*unschedFunction)(void* arg)) {\n  assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n  thread_pools_[pri].Schedule(function, arg, tag, unschedFunction);\n}\n\nint PosixEnv::UnSchedule(void* arg, Priority pri) {\n  return thread_pools_[pri].UnSchedule(arg);\n}\n\nunsigned int PosixEnv::GetThreadPoolQueueLen(Priority pri) const {\n  assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n  return thread_pools_[pri].GetQueueLen();\n}\n\nstruct StartThreadState {\n  void (*user_function)(void*);\n  void* arg;\n};\n\nstatic void* StartThreadWrapper(void* arg) {\n  StartThreadState* state = reinterpret_cast<StartThreadState*>(arg);\n  state->user_function(state->arg);\n  delete state;\n  return nullptr;\n}\n\nvoid PosixEnv::StartThread(void (*function)(void* arg), void* arg) {\n  pthread_t t;\n  StartThreadState* state = new StartThreadState;\n  state->user_function = function;\n  state->arg = arg;\n  ThreadPoolImpl::PthreadCall(\n      \"start thread\", pthread_create(&t, nullptr, &StartThreadWrapper, state));\n  ThreadPoolImpl::PthreadCall(\"lock\", pthread_mutex_lock(&mu_));\n  threads_to_join_.push_back(t);\n  ThreadPoolImpl::PthreadCall(\"unlock\", pthread_mutex_unlock(&mu_));\n}\n\nvoid PosixEnv::WaitForJoin() {\n  for (const auto tid : threads_to_join_) {\n    pthread_join(tid, nullptr);\n  }\n  threads_to_join_.clear();\n}\n\n}  // namespace\n\nstd::string Env::GenerateUniqueId() {\n  std::string uuid_file = \"/proc/sys/kernel/random/uuid\";\n\n  Status s = FileExists(uuid_file);\n  if (s.ok()) {\n    std::string uuid;\n    s = ReadFileToString(this, uuid_file, &uuid);\n    if (s.ok()) {\n      return uuid;\n    }\n  }\n  // Could not read uuid_file - generate uuid using \"nanos-random\"\n  Random64 r(time(nullptr));\n  uint64_t random_uuid_portion =\n    r.Uniform(std::numeric_limits<uint64_t>::max());\n  uint64_t nanos_uuid_portion = NowNanos();\n  char uuid2[200];\n  snprintf(uuid2,\n           200,\n           \"%lx-%lx\",\n           (unsigned long)nanos_uuid_portion,\n           (unsigned long)random_uuid_portion);\n  return uuid2;\n}\n\n//\n// Default Posix Env\n//\nEnv* Env::Default() {\n  // The following function call initializes the singletons of ThreadLocalPtr\n  // right before the static default_env.  This guarantees default_env will\n  // always being destructed before the ThreadLocalPtr singletons get\n  // destructed as C++ guarantees that the destructions of static variables\n  // is in the reverse order of their constructions.\n  //\n  // Since static members are destructed in the reverse order\n  // of their construction, having this call here guarantees that\n  // the destructor of static PosixEnv will go first, then the\n  // the singletons of ThreadLocalPtr.\n  ThreadLocalPtr::InitSingletons();\n  CompressionContextCache::InitSingleton();\n  INIT_SYNC_POINT_SINGLETONS();\n  static PosixEnv default_env;\n  return &default_env;\n}\n\n}  // namespace rocksdb\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/WINDOWS_PORT.md",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/favicon.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/og_image.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/pcache-filelayout.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/pcache-blockindex.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/pcache-readiopath.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/Resize-of-20140327_200754-300x225.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/pcache-writeiopath.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/pcache-fileindex.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/pcache-tieredstorage.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/tree_example1.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/binaryseek.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/compaction/l0-l1-contend.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/compaction/l1-l2-contend.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/compaction/part-range-old.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/compaction/full-range.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/delrange/delrange_collapsed.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/delrange/delrange_sst_blocks.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/delrange/delrange_write_path.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/delrange/delrange_key_schema.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/delrange/delrange_uncollapsed.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/data-block-hash-index/perf-cache-miss.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/data-block-hash-index/hash-index-data-structure.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/data-block-hash-index/block-format-binary-seek.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/data-block-hash-index/block-format-hash-index.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/data-block-hash-index/perf-throughput.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/rate-limiter/write-KBps-series.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/rate-limiter/write-KBps-cdf.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/images/rate-limiter/auto-tuned-write-KBps-series.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/fonts/LatoLatin-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/fonts/LatoLatin-Black.woff",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/fonts/LatoLatin-BlackItalic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/fonts/LatoLatin-Regular.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/fonts/LatoLatin-Italic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/fonts/LatoLatin-Italic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/fonts/LatoLatin-Light.woff",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/fonts/LatoLatin-BlackItalic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/fonts/LatoLatin-Light.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.5.3-dleqga24yku2p2hp44ueaa7afnaqfczd/spack-src/docs/static/fonts/LatoLatin-Black.woff2"
    ],
    "total_files": 1485
}