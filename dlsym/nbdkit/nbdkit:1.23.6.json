{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/configure.ac": "# nbdkit\n# Copyright (C) 2013-2020 Red Hat Inc.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n#\n# * Redistributions of source code must retain the above copyright\n# notice, this list of conditions and the following disclaimer.\n#\n# * Redistributions in binary form must reproduce the above copyright\n# notice, this list of conditions and the following disclaimer in the\n# documentation and/or other materials provided with the distribution.\n#\n# * Neither the name of Red Hat nor the names of its contributors may be\n# used to endorse or promote products derived from this software without\n# specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY RED HAT AND CONTRIBUTORS ''AS IS'' AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RED HAT OR\n# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n\nm4_define([NBDKIT_VERSION_MAJOR], [1])\nm4_define([NBDKIT_VERSION_MINOR], [23])\nm4_define([NBDKIT_VERSION_MICRO], [6])\nAC_INIT([nbdkit],\n        NBDKIT_VERSION_MAJOR.NBDKIT_VERSION_MINOR.NBDKIT_VERSION_MICRO)\nAC_CONFIG_MACRO_DIR([m4])\nm4_ifdef([AC_USE_SYSTEM_EXTENSIONS],[],\n         [m4_define([AC_USE_SYSTEM_EXTENSIONS],[])])\n\ndnl This must be used very early else you will get\ndnl \"warning: AC_RUN_IFELSE was called before AC_USE_SYSTEM_EXTENSIONS\"\nAC_USE_SYSTEM_EXTENSIONS\n\ndnl NB: Do not [quote] this parameter.\nAM_INIT_AUTOMAKE(foreign)\nAC_PROG_LIBTOOL\nLT_INIT([win32-dll])\n\ndnl List of plugins and filters.\nlang_plugins=\"\\\n        cc \\\n        golang \\\n        lua \\\n        ocaml \\\n        perl \\\n        python \\\n        ruby \\\n        rust \\\n        sh \\\n        tcl \\\n        \"\nnon_lang_plugins=\"\\\n        cdi \\\n        curl \\\n        data \\\n        eval \\\n        example1 \\\n        example2 \\\n        example3 \\\n        example4 \\\n        file \\\n        floppy \\\n        full \\\n        guestfs \\\n        gzip \\\n        info \\\n        iso \\\n        libvirt \\\n        linuxdisk \\\n        memory \\\n        nbd \\\n        null \\\n        ondemand \\\n        partitioning \\\n        pattern \\\n        random \\\n        split \\\n        ssh \\\n        streaming \\\n        tar \\\n        tmpdisk \\\n        torrent \\\n        vddk \\\n        zero \\\n        \"\nplugins=\"$(echo $(printf %s\\\\n $lang_plugins $non_lang_plugins | sort -u))\"\nfilters=\"\\\n        blocksize \\\n        cache \\\n        cacheextents \\\n        cow \\\n        ddrescue \\\n        delay \\\n        error \\\n        exitlast \\\n\texportname \\\n        ext2 \\\n        extentlist \\\n        fua \\\n        gzip \\\n        ip \\\n        limit \\\n        log \\\n        nocache \\\n        noextents \\\n        nofilter \\\n        noparallel \\\n        nozero \\\n        offset \\\n        partition \\\n        pause \\\n        rate \\\n        readahead \\\n        retry \\\n        stats \\\n        swab \\\n        tar \\\n\ttls-fallback \\\n        truncate \\\n        xz \\\n        \"\nAC_SUBST([plugins])\nAC_SUBST([lang_plugins])\nAC_SUBST([non_lang_plugins])\nAC_SUBST([filters])\n\ndnl Some very basic tools.\nAC_PROG_SED\n\ndnl Check for basic C environment.\nAC_PROG_CC_STDC\nAC_PROG_INSTALL\nAC_PROG_CPP\nAC_SYS_LARGEFILE\n\nAC_C_PROTOTYPES\ntest \"x$U\" != \"x\" && AC_MSG_ERROR([Compiler not ANSI compliant])\n\nAM_PROG_CC_C_O\n\ndnl Define the host CPU architecture (defines 'host_cpu').\nAC_CANONICAL_HOST\nAC_DEFINE_UNQUOTED([host_cpu],[\"$host_cpu\"],[Host architecture.])\n\ndnl Define 'host_os'.\nAC_DEFINE_UNQUOTED([host_os],[\"$host_os\"],[Host operating system.])\n\ndnl Defines WORDS_BIGENDIAN on big endian platforms.\nAC_C_BIGENDIAN\n\ndnl Check for C++ (optional, we just use this to test the header\ndnl can be included from C++ code).\nAC_PROG_CXX\n\ndnl The C++ compiler test is pretty useless because even if it fails\ndnl it sets CXX=g++.  So test the compiler actually works.\nAC_MSG_CHECKING([if the C++ compiler really really works])\nAS_IF([$CXX --version >&AS_MESSAGE_LOG_FD 2>&1],[have_cxx=yes],[have_cxx=no])\nAC_MSG_RESULT([$have_cxx])\nAM_CONDITIONAL([HAVE_CXX], [test \"$have_cxx\" = \"yes\"])\n\nAC_ARG_ENABLE([gcc-warnings],\n    [AS_HELP_STRING([--enable-gcc-warnings],\n                    [turn on lots of GCC warnings (for developers)])],\n     [case $enableval in\n      yes|no) ;;\n      *)      AC_MSG_ERROR([bad value $enableval for gcc-warnings option]) ;;\n      esac\n      gcc_warnings=$enableval],\n      [gcc_warnings=no]\n)\nif test \"x$gcc_warnings\" = \"xyes\"; then\n    WARNINGS_CFLAGS=\"-Wall -Wshadow -Wvla -Werror\"\n    AC_SUBST([WARNINGS_CFLAGS])\nfi\n\ndnl Check if the compiler supports -std=c90 flag.  This is only used\ndnl during a test.  OpenBSD GCC does not support this flag so we skip\ndnl that test.\nAC_MSG_CHECKING([if the compiler supports -std=c90 for ANSI C test])\nold_CFLAGS=\"$CFLAGS\"\nCFLAGS=\"$CFLAGS -std=c90\"\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([])],\n    [supports_std_c90=yes],\n    [supports_std_c90=no])\nCFLAGS=\"$old_CFLAGS\"\nAC_MSG_RESULT([$supports_std_c90])\nAM_CONDITIONAL([CAN_TEST_ANSI_C], [test \"x$supports_std_c90\" = \"xyes\"])\n\ndnl On Haiku we must use BSD-compatibility headers to get the endian\ndnl macros we use.\nAC_MSG_CHECKING(whether OS-dependent include paths are required)\nAS_CASE([$host_os],\n  [haiku*], [CFLAGS=\"$CFLAGS -I`findpaths -p /system B_FIND_PATH_HEADERS_DIRECTORY`/bsd\"; AC_MSG_RESULT(yes)],\n  [AC_MSG_RESULT(no)]\n)\n\ndnl On Linux /tmp is often tmpfs which is not large enough, so use /var/tmp.\ndnl But Haiku only has /tmp.\nAC_MSG_CHECKING([for temporary directory for large files])\nAS_CASE([$host_os],\n  [haiku*], [LARGE_TMPDIR=/tmp],\n  [LARGE_TMPDIR=/var/tmp]\n)\nAC_MSG_RESULT([$LARGE_TMPDIR])\nAC_DEFINE_UNQUOTED([LARGE_TMPDIR],[\"$LARGE_TMPDIR\"],\n                   [Temporary directory for large files])\n\ndnl Check if libc has program_invocation_short_name.\nAC_CHECK_DECLS([program_invocation_short_name], [], [], [#include <errno.h>])\n\nAX_PTHREAD\n\ndnl Check if __attribute__((cleanup(...))) works.\ndnl Set -Werror, otherwise gcc will only emit a warning for attributes\ndnl that it doesn't understand.\nacx_nbdkit_save_CFLAGS=\"${CFLAGS}\"\nCFLAGS=\"${CFLAGS} -Werror\"\nAC_MSG_CHECKING([if __attribute__((cleanup(...))) works with this compiler])\nAC_COMPILE_IFELSE([\nAC_LANG_SOURCE([[\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid\nfreep (void *ptr)\n{\n  exit (EXIT_SUCCESS);\n}\n\nvoid\ntest (void)\n{\n  __attribute__((cleanup(freep))) char *ptr = malloc (100);\n}\n\nint\nmain (int argc, char *argv[])\n{\n  test ();\n  exit (EXIT_FAILURE);\n}\n]])\n    ],[\n    AC_MSG_RESULT([yes])\n    ],[\n    AC_MSG_RESULT([no])\n    AC_MSG_ERROR(\n['__attribute__((cleanup(...)))' does not work.\n\nYou may not be using a sufficiently recent version of GCC or CLANG, or\nyou may be using a C compiler which does not support this attribute,\nor the configure test may be wrong.\n\nThis code requires the attribute to work for proper locking between threads.])])\nCFLAGS=\"${acx_nbdkit_save_CFLAGS}\"\n\ndnl Check for __auto_type (GCC extension).\nAC_MSG_CHECKING([if __auto_type is available in this compiler])\nAC_COMPILE_IFELSE([\nAC_LANG_SOURCE([[\nstatic int\ntest (int a)\n{\n  __auto_type at = a;\n  return at;\n}\n]])\n    ],[\n    AC_MSG_RESULT([yes])\n    AC_DEFINE([HAVE_AUTO_TYPE],[1],[__auto_type is available])\n    ],[\n    AC_MSG_RESULT([no])\n    ]\n)\n\ndnl 'environ' is not always declared in public header files:\ndnl Linux => <unistd.h>  Haiku => <stdlib.h>\ndnl FreeBSD & OpenBSD => not declared\ndnl On platforms where it's not declared we must add an extern decl.\nAC_MSG_CHECKING([if environ is declared in header files])\nAC_COMPILE_IFELSE([\nAC_LANG_SOURCE([[\n#include <stdlib.h>\n#include <unistd.h>\nstatic int\ntest (void)\n{\n  const char **env = environ;\n  return env ? 1 : 0; // this just forces env to be used\n}\n]])\n    ],[\n    AC_MSG_RESULT([yes])\n    AC_DEFINE([HAVE_ENVIRON_DECL],[1],[environ is declared in headers])\n    ],[\n    AC_MSG_RESULT([no])\n    ]\n)\n\ndnl Check for other headers, all optional.\nAC_CHECK_HEADERS([\\\n\talloca.h \\\n\tafunix.h \\\n\tarpa/inet.h \\\n\tbyteswap.h \\\n\tendian.h \\\n\tgrp.h \\\n\tnetdb.h \\\n\tnetinet/in.h \\\n\tnetinet/tcp.h \\\n\tpwd.h \\\n\ttermios.h \\\n\tstdatomic.h \\\n\tsyslog.h \\\n\tsys/endian.h \\\n\tsys/ioctl.h \\\n\tsys/mman.h \\\n\tsys/prctl.h \\\n\tsys/procctl.h \\\n\tsys/socket.h \\\n\tsys/statvfs.h \\\n\tsys/un.h \\\n\tsys/wait.h])\n\nAC_CHECK_HEADERS([linux/vm_sockets.h], [], [], [#include <sys/socket.h>])\n\ndnl Check for functions in libc, all optional.\nAC_CHECK_FUNCS([\\\n\taccept4 \\\n\tfdatasync \\\n\tflockfile \\\n\tfunlockfile \\\n\tmkostemp \\\n\tmlock \\\n\tmlockall \\\n\tmunlock \\\n\topen_memstream \\\n\tpipe \\\n\tpipe2 \\\n\tppoll \\\n\tposix_fadvise])\nAC_CHECK_MEMBERS([struct dirent.d_type], [], [], [[#include <dirent.h>]])\n\ndnl Replacement functions that we provide for some platforms.\nAC_CONFIG_LIBOBJ_DIR([common/replacements])\nAC_REPLACE_FUNCS([\\\n\tfdatasync \\\n\tfsync \\\n\tget_current_dir_name \\\n\tgetdelim \\\n\tgetline \\\n\topenlog \\\n\topen_memstream \\\n\tpoll \\\n\tpread \\\n\tpwrite \\\n\trealpath \\\n\tstrndup \\\n\tsyslog \\\n\tvsyslog])\n\ndnl Check whether printf(\"%m\") works\nAC_CACHE_CHECK([whether the printf family supports %m],\n  [nbdkit_cv_func_printf_percent_m],\n  [AC_RUN_IFELSE(\n    [AC_LANG_PROGRAM([[\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n    ]], [[\n    char buf[200] = \"\";\n    errno = EINVAL;\n    snprintf(buf, sizeof buf, \"%m\");\n    return !!strcmp (buf, strerror (EINVAL));\n    ]])],\n    [nbdkit_cv_func_printf_percent_m=yes],\n    [nbdkit_cv_func_printf_percent_m=no],\n    [[\n    case \"$host_os\" in\n      *-gnu* | gnu*) nbdkit_cv_func_printf_percent_m=yes;;\n      *) nbdkit_cv_func_printf_percent_m=\"guessing no\";;\n    esac\n    ]])])\nAS_IF([test \"x$nbdkit_cv_func_printf_percent_m\" = xyes],\n  [AC_DEFINE([HAVE_VFPRINTF_PERCENT_M],[1],\n    [Define to 1 if vfprintf supports %m.])])\n\nold_LIBS=\"$LIBS\"\nAC_SEARCH_LIBS([dlsym], [dl dld], [\n        AS_IF([test \"x$ac_cv_search_dlsym\" != \"xnone required\"],\n\t    [DL_LIBS=\"$ac_cv_search_dlsym\"], [DL_LIBS=])\n        AC_SUBST([DL_LIBS])\n    ], [AC_MSG_ERROR([unable to find the dlsym() function])\n])\nLIBS=\"$old_LIBS\"\n\ndnl Test if <iconv.h> header can build working binaries.\ndnl\ndnl On FreeBSD: iconv and libiconv both exist, both can be installed\ndnl simultaneously, <iconv.h> can exist in two separate places, and\ndnl if you get the wrong header/library mix everything breaks.\ndnl\ndnl On Haiku: libiconv is required to link to iconv_* functions.\nAC_ARG_WITH([iconv],\n    [AS_HELP_STRING([--without-iconv],\n                    [don't try to link against iconv @<:@default=check@:>@])],\n    [],\n    [with_iconv=check])\nAS_IF([test \"x$with_iconv\" != \"xno\"],[\n    AC_CHECK_HEADER([iconv.h],[\n        AC_MSG_CHECKING([if <iconv.h> can be used to link a program])\n        AC_LINK_IFELSE([\nAC_LANG_SOURCE([[\n#include <stdio.h>\n#include <stdlib.h>\n#include <iconv.h>\nint\nmain (int argc, char *argv[])\n{\n  iconv_t ic = iconv_open (\"\", \"\");\n  iconv_close (ic);\n  exit (0);\n}\n]])\n            ],[\n            AC_MSG_RESULT([yes])\n            iconv_working=yes\n            ],[\n            AC_MSG_RESULT([no])\n            ])\n        ])\n    ])\nAM_CONDITIONAL([HAVE_ICONV], [test \"x$iconv_working\" = \"xyes\"])\n\ndnl Don't use linker script for the server on FreeBSD because\ndnl FreeBSD's linker is broken.  See eg:\ndnl https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=190851\nAC_MSG_CHECKING([if we should use a linker script for the server])\nAS_CASE([$host_os],\n  [freebsd*], [use_linker_script_for_server=no],\n  [use_linker_script_for_server=yes]\n)\nAC_MSG_RESULT([$use_linker_script_for_server])\nAM_CONDITIONAL([USE_LINKER_SCRIPT_FOR_SERVER],\n               [test \"x$use_linker_script_for_server\" = \"xyes\"])\n\ndnl Check if -rdynamic linker flag works.\nacx_nbdkit_save_LDFLAGS=\"${LDFLAGS}\"\nLDFLAGS=\"${LDFLAGS} -rdynamic\"\nAC_MSG_CHECKING([if linker supports -rdynamic])\nAC_LINK_IFELSE([\nAC_LANG_SOURCE([[\n#include <stdlib.h>\nint\nmain (int argc, char *argv[])\n{\n  exit (EXIT_SUCCESS);\n}\n]])\n    ],[\n    AC_MSG_RESULT([yes])\n    DL_LDFLAGS=-rdynamic\n    ],[\n    AC_MSG_RESULT([no])\n])\ndnl restore CFLAGS\nLDFLAGS=\"${acx_nbdkit_save_LDFLAGS}\"\nAC_SUBST([DL_LDFLAGS])\n\ndnl Check for dladdr in -ldl, optional.  This is a glibc extension.\nold_LIBS=\"$LIBS\"\nLIBS=\"$DL_LIBS $LIBS\"\nAC_CHECK_FUNCS([dladdr])\nLIBS=\"$old_LIBS\"\n\ndnl Is this Windows?\nAC_MSG_CHECKING([if the target is Windows])\nAS_CASE([$host_os],\n    [mingw*|msys*], [\n        is_windows=yes\n        LIBS=\"$LIBS -lmsvcrt -lkernel32 -luser32\"\n        NO_UNDEFINED_ON_WINDOWS=\"-no-undefined\"\n        IMPORT_LIBRARY_ON_WINDOWS='-Wl,-L$(top_builddir)/server -Wl,-lnbdkit'\n        SOEXT=\"dll\"\n        DIR_SEPARATOR_STR='\\\\'\n    ],\n    [is_windows=no\n     SOEXT=\"so\"\n     DIR_SEPARATOR_STR=/]\n)\nAC_MSG_RESULT([$is_windows])\nAC_SUBST([NO_UNDEFINED_ON_WINDOWS])\nAC_SUBST([IMPORT_LIBRARY_ON_WINDOWS])\nAC_SUBST([SOEXT])\nAC_DEFINE_UNQUOTED([SOEXT],[\"$SOEXT\"],[Extension used for shared objects/DLLs.])\nAC_DEFINE_UNQUOTED([EXEEXT],[\"$EXEEXT\"],[Extension used for executables.])\nAC_DEFINE_UNQUOTED([DIR_SEPARATOR_STR],[\"$DIR_SEPARATOR_STR\"],\n                   [String that separates path elements.])\nAM_CONDITIONAL([IS_WINDOWS],[test \"x$is_windows\" = \"xyes\"])\n\nAS_IF([test \"x$is_windows\" = \"xyes\"],[\n    dnl For Windows, look for the mc/windmc utility.\n    dnl XXX Do we need to check for mc.exe as well?\n    AC_CHECK_TOOLS([MC],[windmc mc],[no])\n    AS_IF([test \"x$MC\" = \"xno\"],\n          [AC_MSG_ERROR([mc/windmc utility must be available when compiling for Windows])])\n\n    dnl On Windows look for dlltool.\n    AC_CHECK_TOOLS([DLLTOOL],[dlltool],[no])\n    AS_IF([test \"x$DLLTOOL\" = \"xno\"],\n          [AC_MSG_ERROR([dlltool utility must be available when compiling for Windows])])\n\n    dnl On Windows we require winsock2.\n    AC_CHECK_LIB([ws2_32], [socket])\n])\n\nAC_SEARCH_LIBS([getaddrinfo], [network socket])\n\ndnl Check for SELinux socket labelling (optional).\nPKG_CHECK_MODULES([LIBSELINUX], [libselinux], [\n    AC_SUBST([LIBSELINUX_CFLAGS])\n    AC_SUBST([LIBSELINUX_LIBS])\n    AC_DEFINE([HAVE_LIBSELINUX],[1],[libselinux found at compile time.])\n], [\n    AC_MSG_WARN([libselinux not found, SELinux socket labelling support will be disabled.])\n])\n\ndnl Check for GnuTLS (optional, for TLS support).\nPKG_CHECK_MODULES([GNUTLS], [gnutls >= 3.3.0], [\n    AC_SUBST([GNUTLS_CFLAGS])\n    AC_SUBST([GNUTLS_LIBS])\n    AC_DEFINE([HAVE_GNUTLS],[1],[gnutls found at compile time.])\n], [\n    AC_MSG_WARN([gnutls not found or < 3.3.0, TLS support will be disabled.])\n])\n\nAS_IF([test \"$GNUTLS_LIBS\" != \"\"],[\n    AC_MSG_CHECKING([for default TLS session priority string])\n    AC_ARG_WITH([tls-priority],\n        [AS_HELP_STRING([--with-tls-priority],\n                        [default TLS session priority string @<:@default=NORMAL@:>@])],\n        [tls_priority=$withval],\n        [tls_priority=NORMAL])\n    AC_MSG_RESULT([$tls_priority])\n    AC_DEFINE_UNQUOTED([TLS_PRIORITY],[\"$tls_priority\"],\n                       [Default TLS session priority string])\n\n    # Check for APIs which may not be present.\n    old_LIBS=\"$LIBS\"\n    LIBS=\"$GNUTLS_LIBS $LIBS\"\n    AC_CHECK_FUNCS([\\\n\tgnutls_base64_decode2 \\\n\tgnutls_certificate_set_known_dh_params \\\n\tgnutls_session_set_verify_cert])\n    LIBS=\"$old_LIBS\"\n])\n\nAC_ARG_ENABLE([linuxdisk],\n    [AS_HELP_STRING([--disable-linuxdisk],\n                    [disable linuxdisk plugin @<:@default=check@:>@])],\n    [],\n    [enable_linuxdisk=check])\ndnl Check for mke2fs -d (used by linuxdisk plugin).  There are two\ndnl possible outcomes that we care about: (1) We have mke2fs and\ndnl it supports the -d option.  (2) We either don't have mke2fs\ndnl or it's too old to support the -d option (eg. on RHEL 7).\nmke2fs_with_d=no\nAS_IF([test \"$enable_linuxdisk\" != \"no\"], [\n    AC_MSG_CHECKING([for mke2fs supporting the -d option])\n    AS_IF([mke2fs -V >/dev/null 2>&1], [\n        AS_IF([LANG=C mke2fs -d 2>&1 | grep -sq \"option requires an argument\"], [\n            mke2fs_with_d=yes\n        ])\n    ])\n    AC_MSG_RESULT([$mke2fs_with_d])\n])\nAM_CONDITIONAL([HAVE_MKE2FS_WITH_D],[test \"x$mke2fs_with_d\" = \"xyes\"])\n\ndnl Check for valgrind.\nAC_CHECK_PROG([VALGRIND],[valgrind],[valgrind],[no])\n\ndnl If valgrind headers are available (optional).\ndnl Since this is only useful for developers, you have to enable\ndnl it explicitly using --enable-valgrind.\nAC_ARG_ENABLE([valgrind],\n    [AS_HELP_STRING([--enable-valgrind],\n                    [enable Valgrind extensions (for developers)])],\n    [enable_valgrind=yes],\n    [enable_valgrind=no])\nAS_IF([test \"x$enable_valgrind\" = \"xyes\"],[\n    PKG_CHECK_MODULES([VALGRIND], [valgrind], [\n        AC_SUBST([VALGRIND_CFLAGS])\n        AC_SUBST([VALGRIND_LIBS])\n        AC_DEFINE([HAVE_VALGRIND],[1],[Valgrind headers found at compile time])\n    ],[\n        AC_MSG_ERROR([--enable-valgrind given, but Valgrind headers are not available])\n    ])\n])\n\ndnl Build the special libFuzzer version of nbdkit.  DO NOT USE THIS for\ndnl normal builds.  See fuzzing/README.\nAC_ARG_ENABLE([libfuzzer],\n    [AS_HELP_STRING([--enable-libfuzzer],\n                    [build libFuzzer test binary (developers only)])],\n    [enable_libfuzzer=yes],\n    [enable_libfuzzer=no])\nAS_IF([test \"x$enable_libfuzzer\" = \"xyes\"],[\n    AC_DEFINE([ENABLE_LIBFUZZER],[1],[Enable special libFuzzer binary])\n])\nAM_CONDITIONAL([ENABLE_LIBFUZZER],[test \"x$enable_libfuzzer\" = \"xyes\"])\n\ndnl Bash completion.\nPKG_CHECK_MODULES([BASH_COMPLETION], [bash-completion >= 2.0], [\n    bash_completion=yes\n    AC_MSG_CHECKING([for bash-completions directory])\n    m4_ifdef([PKG_CHECK_VAR],[\n        PKG_CHECK_VAR(bashcompdir, [bash-completion], [completionsdir])\n    ])\n    AS_IF([test -z \"$bashcompdir\"], [\n        bashcompdir=\"${sysconfdir}/bash_completion.d\"\n    ])\n    AC_MSG_RESULT([$bashcompdir])\n    AC_SUBST([bashcompdir])\n],[\n    bash_completion=no\n    AC_MSG_WARN([bash-completion not installed])\n])\nAM_CONDITIONAL([HAVE_BASH_COMPLETION],[test \"x$bash_completion\" = \"xyes\"])\n\ndnl Check we have enough to run podwrapper.\nAC_CHECK_PROG([PERL],[perl],[perl],[no])\nAS_IF([test \"x$PERL\" != \"xno\"],[\n    AC_MSG_CHECKING([if we have perl Pod::Man and Pod::Simple])\n    AS_IF([$PERL -MPod::Man -MPod::Simple -e 1 >&AS_MESSAGE_LOG_FD 2>&1],[\n        enable_pod=yes\n    ],[\n        enable_pod=no\n    ])\n    AC_MSG_RESULT([$enable_pod])\n])\nAM_CONDITIONAL([HAVE_POD],\n               [test \"x$PERL\" != \"xno\" && test \"x$enable_pod\" = \"xyes\"])\n\ndnl Define the path to the podwrapper program.\nPODWRAPPER=\"$PERL $(pwd)/podwrapper.pl\"\nAC_SUBST([PODWRAPPER])\n\ndnl Allow all plugins and filters to be disabled.\nAC_ARG_ENABLE([plugins],\n    [AS_HELP_STRING([--disable-plugins],\n                    [disable all bundled plugins and filters])])\nAM_CONDITIONAL([HAVE_PLUGINS], [test \"x$enable_plugins\" != \"xno\"])\n\ndnl Check for Perl, for embedding in the perl plugin.\ndnl Note that the perl binary is checked above.\nAC_ARG_ENABLE([perl],\n    [AS_HELP_STRING([--disable-perl], [disable Perl embed plugin])],\n    [],\n    [enable_perl=yes])\nAS_IF([test \"x$PERL\" != \"xno\" && test \"x$enable_perl\" != \"xno\"],[\n    dnl Check for Perl archlib.\n    AC_MSG_CHECKING([for Perl embed archlib])\n    PERL_ARCHLIB=\"$($PERL -MConfig -e 'print $Config{archlib}')\"\n    AS_IF([ test -n \"$PERL_ARCHLIB\" ],[\n        AC_MSG_RESULT([$PERL_ARCHLIB])\n    ],[\n        AC_MSG_NOTICE([Perl embed module disabled])\n        enable_perl=no\n    ])\n\n    dnl Check for Perl CFLAGS.\n    AC_MSG_CHECKING([for Perl embed CFLAGS])\n    PERL_CFLAGS=\"$($PERL -MExtUtils::Embed -e 'ccflags')\"\n    AS_IF([ test -n \"$PERL_CFLAGS\" ],[\n        AC_MSG_RESULT([$PERL_CFLAGS])\n    ],[\n        AC_MSG_NOTICE([Perl embed module disabled])\n        enable_perl=no\n    ])\n\n    dnl Check for Perl LDOPTS.\n    AC_MSG_CHECKING([for Perl embed LDOPTS])\n    PERL_LDOPTS=\"$($PERL -MExtUtils::Embed -e 'ldopts')\"\n    AC_MSG_RESULT([$PERL_LDOPTS])\n\n    dnl XXX Could check these actually work.\n])\nAM_CONDITIONAL([HAVE_PERL],[test \"x$enable_perl\" != \"xno\" && test \"x$PERL\" != \"xno\"])\nAC_SUBST([PERL_ARCHLIB])\nAC_SUBST([PERL_CFLAGS])\nAC_SUBST([PERL_LDOPTS])\n\ndnl Check for Python 3, for embedding in the python plugin.\nAC_PATH_PROGS([PYTHON],[python3 python],[no])\nAC_ARG_ENABLE([python],\n    [AS_HELP_STRING([--disable-python], [disable Python embed plugin])],\n    [],\n    [enable_python=yes])\nAS_IF([test \"x$PYTHON\" != \"xno\" && test \"x$enable_python\" != \"xno\"],[\n    AC_MSG_CHECKING([version of $PYTHON])\n    PYTHON_VERSION_MAJOR=`$PYTHON -c \"import sys; print (sys.version_info@<:@0@:>@)\"`\n    PYTHON_VERSION_MINOR=`$PYTHON -c \"import sys; print (sys.version_info@<:@1@:>@)\"`\n    PYTHON_VERSION=\"$PYTHON_VERSION_MAJOR.$PYTHON_VERSION_MINOR\"\n    AS_IF([test -n \"$PYTHON_VERSION\"],[\n        AC_MSG_RESULT([$PYTHON_VERSION])\n    ],[\n        AC_MSG_NOTICE([Python embed module disabled])\n        enable_python=no\n    ])\n\n    AC_MSG_CHECKING([Python major version is 3])\n    AS_IF([test \"x$PYTHON_VERSION_MAJOR\" = \"x3\"],[\n        AC_MSG_RESULT([yes])\n    ],[\n        AC_MSG_RESULT([no])\n        AC_MSG_ERROR([Python $PYTHON_VERSION_MAJOR <> 3 is no longer supported.\n\nPython 2 end of life is 2020-01-01 and nbdkit >= 1.16 no longer\nsupports it.\n\nIf you want to use Python 2, you will need to use nbdkit 1.14.])\n    ])\n\n    dnl Check for Python CFLAGS, libraries.\n    dnl For Python >= 3.8 we have to use python-<VERSION>-embed.pc, see:\n    dnl https://docs.python.org/3.8/whatsnew/3.8.html#debug-build-uses-the-same-abi-as-release-build\n    dnl The python.pc is called python-<VERSION>.pc on Debian and\n    dnl later versions of Fedora, and python.pc on older versions\n    dnl of Fedora.\n    PKG_CHECK_MODULES([PYTHON], [python-\"$PYTHON_VERSION\"-embed], [\n        AC_SUBST([PYTHON_CFLAGS])\n        AC_SUBST([PYTHON_LIBS])\n        AC_SUBST([PYTHON_VERSION])\n        AC_DEFINE([HAVE_PYTHON],[1],[Python library found at compile time])\n    ],[\n    PKG_CHECK_MODULES([PYTHON], [python-\"$PYTHON_VERSION\"], [\n        AC_SUBST([PYTHON_CFLAGS])\n        AC_SUBST([PYTHON_LIBS])\n        AC_SUBST([PYTHON_VERSION])\n        AC_DEFINE([HAVE_PYTHON],[1],[Python library found at compile time])\n    ],[\n    PKG_CHECK_MODULES([PYTHON], [python], [\n        AC_SUBST([PYTHON_CFLAGS])\n        AC_SUBST([PYTHON_LIBS])\n        AC_SUBST([PYTHON_VERSION])\n        AC_DEFINE([HAVE_PYTHON],[1],[Python library found at compile time])\n    ],[\n        AC_MSG_WARN([python $PYTHON_VERSION not found])\n        enable_python=no\n    ])])])\n])\nAM_CONDITIONAL([HAVE_PYTHON],[test \"x$enable_python\" != \"xno\" && test \"x$PYTHON\" != \"xno\"])\nAC_SUBST([PYTHON_CFLAGS])\nAC_SUBST([PYTHON_LIBS])\nAC_SUBST([PYTHON_LDFLAGS])\n\ndnl For the OCaml plugin, you can set OCAMLOPTFLAGS before running\ndnl ./configure to specify any extra flags you want to pass to\ndnl ocamlopt.\nAC_SUBST([OCAMLOPTFLAGS])\n\ndnl Check for OCaml, for embedding in the ocaml plugin.\nAC_PROG_OCAML\nAC_ARG_ENABLE([ocaml],\n    [AS_HELP_STRING([--disable-ocaml], [disable OCaml embed plugin])],\n    [],\n    [enable_ocaml=yes])\nAS_IF([test \"x$OCAMLOPT\" != \"xno\" && test \"x$enable_ocaml\" != \"xno\"],[\n    dnl Check OCaml can create a shared library (see README for details).\n    AC_MSG_CHECKING([if $OCAMLOPT can create a shared library])\n    echo 'print_endline \"test\"' > conftest.ml\n    AS_IF([$OCAMLOPT $OCAMLOPTFLAGS -output-obj -runtime-variant _pic -o conftest.so conftest.ml >&AS_MESSAGE_LOG_FD 2>&1],[\n        AC_MSG_RESULT([yes])\n        ocaml_link_shared=yes\n    ],[\n        AC_MSG_RESULT([no])\n    ])\n    rm -f conftest.ml conftest.cmi conftest.cmx conftest.so conftest.o\n])\nAM_CONDITIONAL([HAVE_OCAML],[test \"x$OCAMLOPT\" != \"xno\" &&\n                             test \"x$ocaml_link_shared\" = \"xyes\"])\n\ndnl Check if OCaml has caml_alloc_initialized_string (added 2017).\nAS_IF([test \"x$OCAMLC\" != \"xno\" && test \"x$OCAMLFIND\" != \"xno\" && \\\n       test \"x$enable_ocaml\" = \"xyes\"],[\n    AC_MSG_CHECKING([for caml_alloc_initialized_string])\n    cat >conftest.c <<'EOF'\n#include <caml/alloc.h>\nint main () { char *p = (void *) caml_alloc_initialized_string; return 0; }\nEOF\n    AS_IF([$OCAMLC conftest.c >&AS_MESSAGE_LOG_FD 2>&1],[\n        AC_MSG_RESULT([yes])\n        AC_DEFINE([HAVE_CAML_ALLOC_INITIALIZED_STRING],[1],\n                  [caml_alloc_initialized_string found at compile time.])\n    ],[\n        AC_MSG_RESULT([no])\n    ])\n    rm -f conftest.c conftest.o\n])\n\ndnl For developing plugins in Rust, optional.\nAC_CHECK_PROG([CARGO],[cargo],[cargo],[no])\nAC_ARG_ENABLE([rust],\n    [AS_HELP_STRING([--disable-rust], [disable Rust plugin])],\n    [],\n    [enable_rust=yes])\nAM_CONDITIONAL([HAVE_RUST],\n               [test \"x$CARGO\" != \"xno\" && test \"x$enable_rust\" != \"xno\"])\n\ndnl Check for Ruby, for embedding in the Ruby plugin.\nAC_CHECK_PROG([RUBY],[ruby],[ruby],[no])\nAC_ARG_ENABLE([ruby],\n    [AS_HELP_STRING([--disable-ruby], [disable Ruby plugin])],\n    [],\n    [enable_ruby=yes])\nAS_IF([test \"x$RUBY\" != \"xno\" && test \"x$enable_ruby\" != \"xno\"],[\n    PKG_CHECK_MODULES([RUBY], [ruby], [\n        AC_SUBST([RUBY_CFLAGS])\n        AC_SUBST([RUBY_LIBS])\n    ],[\n        AC_MSG_WARN([ruby not found])\n        enable_ruby=no\n    ])\n])\nAM_CONDITIONAL([HAVE_RUBY],[test \"x$RUBY\" != \"xno\" &&\n                            test \"x$enable_ruby\" = \"xyes\"])\n\ndnl Check for Tcl, for embedding in the Tcl plugin.\nAC_ARG_ENABLE([tcl],\n    [AS_HELP_STRING([--disable-tcl], [disable Tcl plugin])],\n    [],\n    [enable_tcl=yes])\nAS_IF([test \"x$enable_tcl\" != \"xno\"],[\n    PKG_CHECK_MODULES([TCL], [tcl], [\n        AC_SUBST([TCL_CFLAGS])\n        AC_SUBST([TCL_LIBS])\n    ],[\n        AC_MSG_WARN([Tcl not found])\n        enable_tcl=no\n    ])\n])\nAM_CONDITIONAL([HAVE_TCL],[test \"x$enable_tcl\" = \"xyes\"])\n\ndnl Check for Lua, for embedding in the Lua plugin.\nAC_ARG_ENABLE([lua],\n    [AS_HELP_STRING([--disable-lua], [disable Lua plugin])],\n    [],\n    [enable_lua=yes])\nAS_IF([test \"x$enable_lua\" != \"xno\"],[\n    PKG_CHECK_MODULES([LUA], [lua], [\n        AC_SUBST([LUA_CFLAGS])\n        AC_SUBST([LUA_LIBS])\n\n\tdnl Lua 5.1 used by RHEL 7 does not have lua_isinteger.\n\told_LIBS=\"$LIBS\"\n\tLIBS=\"$LUA_LIBS $LIBS\"\n\tAC_CHECK_FUNCS([lua_isinteger])\n\tLIBS=\"$old_LIBS\"\n    ],[\n        AC_MSG_WARN([Lua not found])\n        enable_lua=no\n    ])\n])\nAM_CONDITIONAL([HAVE_LUA],[test \"x$enable_lua\" = \"xyes\"])\n\ndnl Check for golang.\nAC_ARG_ENABLE([golang],\n    AS_HELP_STRING([--disable-golang], [disable Go language plugin]),\n        [],\n        [enable_golang=yes])\nAS_IF([test \"x$enable_golang\" != \"xno\"],[\n    AC_CHECK_PROG([GOLANG],[go],[go],[no])\n    AS_IF([test \"x$GOLANG\" != \"xno\"],[\n        AC_MSG_CHECKING([if $GOLANG is usable])\n        AS_IF([$GOLANG run $srcdir/plugins/golang/config-test.go 2>&AS_MESSAGE_LOG_FD],[\n            AC_MSG_RESULT([yes])\n\n            # Substitute some golang environment.\n            GOOS=`$GOLANG env GOOS`\n            GOARCH=`$GOLANG env GOARCH`\n            GOROOT=`$GOLANG env GOROOT`\n            AC_SUBST([GOOS])\n            AC_SUBST([GOARCH])\n            AC_SUBST([GOROOT])\n        ],[\n            AC_MSG_RESULT([no])\n            AC_MSG_WARN([golang ($GOLANG) is installed but not usable])\n            GOLANG=no\n        ])\n    ])\n],[GOLANG=no])\nAM_CONDITIONAL([HAVE_GOLANG],[test \"x$GOLANG\" != \"xno\"])\n\ndnl Check for curl (only if you want to compile the curl plugin).\nAC_ARG_WITH([curl],\n    [AS_HELP_STRING([--without-curl],\n                    [disable curl plugin @<:@default=check@:>@])],\n    [],\n    [with_curl=check])\nAS_IF([test \"$with_curl\" != \"no\"],[\n    PKG_CHECK_MODULES([CURL], [libcurl],[\n        AC_SUBST([CURL_CFLAGS])\n        AC_SUBST([CURL_LIBS])\n        AC_DEFINE([HAVE_CURL],[1],[curl found at compile time.])\n        AC_CHECK_DECL([CURLOPT_UNIX_SOCKET_PATH], [\n            AC_DEFINE([HAVE_CURLOPT_UNIX_SOCKET_PATH],[1],\n                      [CURLOPT_UNIX_SOCKET_PATH found at compile time.])\n            ], [], [#include <curl/curl.h>])\n    ],\n    [AC_MSG_WARN([curl not found, curl plugin will be disabled])])\n])\nAM_CONDITIONAL([HAVE_CURL],[test \"x$CURL_LIBS\" != \"x\"])\n\ndnl Check for libssh (only if you want to compile the ssh plugin).\nAC_ARG_WITH([ssh],\n    [AS_HELP_STRING([--without-ssh],\n                    [disable ssh plugin @<:@default=check@:>@])],\n    [],\n    [with_ssh=check])\nAS_IF([test \"$with_ssh\" != \"no\"],[\n    PKG_CHECK_MODULES([SSH], [libssh >= 0.8.0],[\n        AC_SUBST([SSH_CFLAGS])\n        AC_SUBST([SSH_LIBS])\n    ],\n    [AC_MSG_WARN([libssh not found, ssh plugin will be disabled])])\n])\nAM_CONDITIONAL([HAVE_SSH],[test \"x$SSH_LIBS\" != \"x\"])\n\ndnl Check for genisoimage or mkisofs\ndnl (only if you want to compile the iso plugin).\nISOPROG=\"no\"\nAC_ARG_WITH([iso],\n    [AS_HELP_STRING([--without-iso],\n                    [disable iso plugin @<:@default=check@:>@])],\n    [],\n    [with_iso=check])\nAS_IF([test \"$with_iso\" != \"no\"],[\n    AC_CHECK_PROG([GENISOIMAGE],[genisoimage],[genisoimage],[no])\n    AC_CHECK_PROG([MKISOFS],[mkisofs],[mkisofs],[no])\n    AS_IF([test \"x$GENISOIMAGE\" != \"xno\"],[\n        ISOPROG=\"$GENISOIMAGE\"\n    ],[\n        AS_IF([test \"x$MKISOFS\" != \"xno\"],[\n            ISOPROG=\"$MKISOFS\"\n        ])\n    ])\n    AS_IF([test \"x$ISOPROG\" != \"xno\"],[\n        AC_DEFINE_UNQUOTED([ISOPROG],[\"$ISOPROG\"],\n                           [Program used by iso plugin to make ISOs.])\n    ])\n])\nAC_SUBST([ISOPROG])\nAM_CONDITIONAL([HAVE_ISO],[test \"x$ISOPROG\" != \"xno\"])\n\ndnl Check for libvirt (only if you want to compile the libvirt plugin).\nAC_ARG_WITH([libvirt],\n    [AS_HELP_STRING([--without-libvirt],\n                    [disable libvirt plugin @<:@default=check@:>@])],\n    [],\n    [with_libvirt=check])\nAS_IF([test \"$with_libvirt\" != \"no\"],[\n    PKG_CHECK_MODULES([LIBVIRT], [libvirt],[\n        AC_SUBST([LIBVIRT_CFLAGS])\n        AC_SUBST([LIBVIRT_LIBS])\n        AC_DEFINE([HAVE_LIBVIRT],[1],[libvirt found at compile time.])\n    ],\n    [AC_MSG_WARN([libvirt not found, libvirt plugin will be disabled])])\n])\nAM_CONDITIONAL([HAVE_LIBVIRT],[test \"x$LIBVIRT_LIBS\" != \"x\"])\n\ndnl Check for zlib (only if you want to compile the gzip filter).\nAC_ARG_WITH([zlib],\n    [AS_HELP_STRING([--without-zlib],\n                    [disable gzip filter @<:@default=check@:>@])],\n    [],\n    [with_zlib=check])\nAS_IF([test \"$with_zlib\" != \"no\"],[\n    PKG_CHECK_MODULES([ZLIB], [zlib >= 1.2.3.5],[\n        AC_SUBST([ZLIB_CFLAGS])\n        AC_SUBST([ZLIB_LIBS])\n        AC_DEFINE([HAVE_ZLIB],[1],[zlib found at compile time.])\n    ],\n    [AC_MSG_WARN([zlib >= 1.2.3.5 not found, gzip filter will be disabled])])\n])\nAM_CONDITIONAL([HAVE_ZLIB],[test \"x$ZLIB_LIBS\" != \"x\"])\n\ndnl Check for libnbd (only if you want to compile the nbd plugin).\nAC_ARG_WITH([libnbd],\n    [AS_HELP_STRING([--without-libnbd],\n                    [disable nbd plugin @<:@default=check@:>@])],\n    [],\n    [with_libnbd=check])\nAS_IF([test \"$with_libnbd\" != \"no\"],[\n    PKG_CHECK_MODULES([LIBNBD], [libnbd >= 0.9.8],[\n        AC_SUBST([LIBNBD_CFLAGS])\n        AC_SUBST([LIBNBD_LIBS])\n        AC_DEFINE([HAVE_LIBNBD],[1],[libnbd found at compile time.])\n    ],\n    [AC_MSG_WARN([libnbd >= 0.9.8 not found, nbd plugin will be crippled])])\n])\n\ndnl For backwards compatibilty, we have a second way to disable the nbd plugin.\nAC_ARG_ENABLE([nbd-plugin],\n    [AS_HELP_STRING([--disable-nbd-plugin], [disable nbd plugin (deprecated, use --without-libnbd)])],\n    [],\n    [enable_nbd_plugin=yes])\nAM_CONDITIONAL([HAVE_LIBNBD],\n  [test \"x$LIBNBD_LIBS\" != \"x\" && test \"x$enable_nbd_plugin\" = \"xyes\"])\n\ndnl Check for liblzma (only if you want to compile the xz filter).\nAC_ARG_WITH([liblzma],\n    [AS_HELP_STRING([--without-liblzma],\n                    [disable xz filter @<:@default=check@:>@])],\n    [],\n    [with_liblzma=check])\nAS_IF([test \"$with_liblzma\" != \"no\"],[\n    PKG_CHECK_MODULES([LIBLZMA], [liblzma],[\n        AC_SUBST([LIBLZMA_CFLAGS])\n        AC_SUBST([LIBLZMA_LIBS])\n        AC_DEFINE([HAVE_LIBLZMA],[1],[liblzma found at compile time.])\n    ],\n    [AC_MSG_WARN([liblzma not found, xz filter will be disabled])])\n])\nAM_CONDITIONAL([HAVE_LIBLZMA],[test \"x$LIBLZMA_LIBS\" != \"x\"])\n\ndnl Check for zstd (only if you want to compile allocator=zstd).\nAC_ARG_WITH([libzstd],\n    [AS_HELP_STRING([--without-libzstd],\n                    [disable allocator=zstd @<:@default=check@:>@])],\n    [],\n    [with_libzstd=check])\nAS_IF([test \"$with_libzstd\" != \"no\"],[\n    PKG_CHECK_MODULES([LIBZSTD], [libzstd],[\n        AC_SUBST([LIBZSTD_CFLAGS])\n        AC_SUBST([LIBZSTD_LIBS])\n        AC_DEFINE([HAVE_LIBZSTD],[1],[libzstd found at compile time.])\n    ],\n    [AC_MSG_WARN([libzstd not found, allocator=zstd will be disabled])])\n])\nAM_CONDITIONAL([HAVE_LIBZSTD],[test \"x$LIBZSTD_LIBS\" != \"x\"])\n\ndnl Check for libguestfs (only for the guestfs plugin and the test suite).\nAC_ARG_WITH([libguestfs],\n    [AS_HELP_STRING([--without-libguestfs],\n                    [disable guestfs plugin and tests @<:@default=check@:>@])],\n    [],\n    [with_libguestfs=check])\nAS_IF([test \"$with_libguestfs\" != \"no\"],[\n    PKG_CHECK_MODULES([LIBGUESTFS], [libguestfs],[\n        # Although the library was found, we want to make sure it supports nbd\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <guestfs.h>\n        ]], [[\n#ifndef GUESTFS_ADD_DRIVE_OPTS_PROTOCOL\n#error unsupported\n#endif\n        ]])], [\n        AC_SUBST([LIBGUESTFS_CFLAGS])\n        AC_SUBST([LIBGUESTFS_LIBS])\n        AC_DEFINE([HAVE_LIBGUESTFS],[1],[libguestfs found at compile time.])\n        ],[\n        LIBGUESTFS_LIBS=\n        AC_MSG_WARN([libguestfs too old, guestfs plugin and tests will be disabled])])\n    ],\n    [AC_MSG_WARN([libguestfs not found, guestfs plugin and tests will be disabled])])\n])\nAM_CONDITIONAL([HAVE_LIBGUESTFS],[test \"x$LIBGUESTFS_LIBS\" != \"x\"])\n\ndnl Check for guestfish (only needed for some of the tests).\nAC_CHECK_PROG([GUESTFISH], [guestfish], [guestfish], [no])\nAM_CONDITIONAL([HAVE_GUESTFISH], [test \"x$GUESTFISH\" != \"xno\"])\n\ndnl Check for ext2fs and com_err, for the ext2 filter.\nAC_ARG_WITH([ext2],\n    [AS_HELP_STRING([--without-ext2],\n                    [disable ext2 filter @<:@default=check@:>@])],\n    [],\n    [with_ext2=check])\nAS_IF([test \"$with_ext2\" != \"no\"], [\n    PKG_CHECK_MODULES([EXT2FS], [ext2fs], [\n        AC_SUBST([EXT2FS_CFLAGS])\n        AC_SUBST([EXT2FS_LIBS])\n        AC_DEFINE([HAVE_EXT2FS],[1],[ext2fs found at compile time.])\n    ],\n    [AC_MSG_WARN([ext2fs not found, ext2 filter will be disabled])])\n    PKG_CHECK_MODULES([COM_ERR], [com_err], [\n        AC_SUBST([COM_ERR_CFLAGS])\n        AC_SUBST([COM_ERR_LIBS])\n        AC_DEFINE([HAVE_COM_ERR],[1],[com_err found at compile time.])\n    ],\n    [AC_MSG_WARN([com_err not found, ext2 filter will be disabled])])\n\n    AC_CHECK_MEMBERS([struct struct_io_manager.cache_readahead,\n                      struct struct_io_manager.zeroout])\n])\nAM_CONDITIONAL([HAVE_EXT2],\n               [test \"x$EXT2FS_LIBS\" != \"x\" && test \"x$COM_ERR_LIBS\" != \"x\"])\n\ndnl libtorrent-rasterbar for the bittorrent plugin.\nAC_ARG_ENABLE([torrent],\n    [AS_HELP_STRING([--disable-torrent],\n                    [disable bittorrent plugin])],\n    [],\n    [enable_torrent=check]\n)\nAS_IF([test \"$enable_torrent\" != \"xno\"], [\n    PKG_CHECK_MODULES([LIBTORRENT], [libtorrent-rasterbar], [\n        AC_SUBST([LIBTORRENT_CFLAGS])\n        AC_SUBST([LIBTORRENT_LIBS])\n    ],\n    [AC_MSG_WARN([libtorrent-rasterbar not found, bittorrent plugin will be disabled])])\n])\nAM_CONDITIONAL([HAVE_TORRENT],\n               [test \"x$have_cxx\" = \"xyes\" && test \"x$LIBTORRENT_LIBS\" != \"x\"])\n\ndnl Check if the user wants to disable VDDK support.\ndnl See plugins/vddk/README.VDDK.\nAC_ARG_ENABLE([vddk],\n    [AS_HELP_STRING([--disable-vddk],\n                    [disable VMware VDDK plugin])],\n    [],\n    [\n     dnl While VDDK was available on i686 in 5.1.1, we only support 5.5.5\n     dnl and newer, which is supported only on x86-64.  Don't compile on\n     dnl other platforms.\n     AC_MSG_CHECKING([if the host CPU is compatible with VDDK])\n     AS_IF([test \"$host_cpu\" = \"x86_64\"],[\n        AC_MSG_RESULT([yes ($host_cpu)])\n        enable_vddk=yes\n     ],[\n        AC_MSG_RESULT([no ($host_cpu)])\n        enable_vddk=no\n     ])\n    ])\nAM_CONDITIONAL([HAVE_VDDK], [test \"x$enable_vddk\" = \"xyes\"])\n\ndnl Expose version information to the public headers\n[NBDKIT_]VERSION_MAJOR=NBDKIT_VERSION_MAJOR\n[NBDKIT_]VERSION_MINOR=NBDKIT_VERSION_MINOR\n[NBDKIT_]VERSION_MICRO=NBDKIT_VERSION_MICRO\nAC_SUBST([NBDKIT_VERSION_MAJOR])\nAC_SUBST([NBDKIT_VERSION_MINOR])\nAC_SUBST([NBDKIT_VERSION_MICRO])\n\ndnl Produce output files.\nAC_CONFIG_HEADERS([config.h])\nAC_CONFIG_FILES([podwrapper.pl],\n                [chmod +x,-w podwrapper.pl])\nAC_CONFIG_FILES([common/protocol/generate-protostrings.sh],\n                [chmod +x,-w common/protocol/generate-protostrings.sh])\nAC_CONFIG_FILES([Makefile\n                 bash/Makefile\n                 common/allocators/Makefile\n                 common/bitmap/Makefile\n                 common/gpt/Makefile\n                 common/include/Makefile\n                 common/protocol/Makefile\n                 common/regions/Makefile\n                 common/replacements/Makefile\n                 common/replacements/win32/Makefile\n                 common/utils/Makefile\n                 docs/Makefile\n                 include/Makefile\n                 include/nbdkit-version.h\n                 plugins/Makefile\n                 plugins/cc/Makefile\n                 plugins/cdi/Makefile\n                 plugins/curl/Makefile\n                 plugins/data/Makefile\n                 plugins/eval/Makefile\n                 plugins/example1/Makefile\n                 plugins/example2/Makefile\n                 plugins/example3/Makefile\n                 plugins/example4/Makefile\n                 plugins/file/Makefile\n                 plugins/floppy/Makefile\n                 plugins/full/Makefile\n                 plugins/golang/Makefile\n                 plugins/guestfs/Makefile\n                 plugins/gzip/Makefile\n                 plugins/info/Makefile\n                 plugins/iso/Makefile\n                 plugins/libvirt/Makefile\n                 plugins/linuxdisk/Makefile\n                 plugins/lua/Makefile\n                 plugins/memory/Makefile\n                 plugins/nbd/Makefile\n                 plugins/null/Makefile\n                 plugins/ocaml/Makefile\n                 plugins/ondemand/Makefile\n                 plugins/partitioning/Makefile\n                 plugins/pattern/Makefile\n                 plugins/perl/Makefile\n                 plugins/python/Makefile\n                 plugins/random/Makefile\n                 plugins/ruby/Makefile\n                 plugins/rust/Makefile\n                 plugins/sh/Makefile\n                 plugins/ssh/Makefile\n                 plugins/split/Makefile\n                 plugins/streaming/Makefile\n                 plugins/tar/Makefile\n                 plugins/tcl/Makefile\n                 plugins/tmpdisk/Makefile\n                 plugins/torrent/Makefile\n                 plugins/vddk/Makefile\n                 plugins/zero/Makefile\n                 filters/Makefile\n                 filters/blocksize/Makefile\n                 filters/cache/Makefile\n                 filters/cacheextents/Makefile\n                 filters/cow/Makefile\n                 filters/ddrescue/Makefile\n                 filters/delay/Makefile\n                 filters/error/Makefile\n                 filters/exitlast/Makefile\n                 filters/exportname/Makefile\n                 filters/ext2/Makefile\n                 filters/extentlist/Makefile\n                 filters/fua/Makefile\n                 filters/gzip/Makefile\n                 filters/ip/Makefile\n                 filters/limit/Makefile\n                 filters/log/Makefile\n                 filters/nocache/Makefile\n                 filters/noextents/Makefile\n                 filters/nofilter/Makefile\n                 filters/noparallel/Makefile\n                 filters/nozero/Makefile\n                 filters/offset/Makefile\n                 filters/partition/Makefile\n                 filters/pause/Makefile\n                 filters/rate/Makefile\n                 filters/readahead/Makefile\n                 filters/retry/Makefile\n                 filters/stats/Makefile\n                 filters/swab/Makefile\n                 filters/tar/Makefile\n                 filters/tls-fallback/Makefile\n                 filters/truncate/Makefile\n                 filters/xz/Makefile\n                 fuzzing/Makefile\n                 server/local/nbdkit.pc\n                 server/Makefile\n                 server/nbdkit.pc\n                 tests/functions.sh\n                 tests/Makefile\n                 valgrind/Makefile])\n\nAC_OUTPUT\n\ndnl Summary.\necho\necho\necho \"----------------------------------------------------------------------\"\necho \"Thank you for downloading $PACKAGE_STRING\"\necho\necho \"This is how we have configured the optional components for you today:\"\necho\n\nfeature ()\n{\n    printf %s \"    $1\"\n    shift\n    if \"$@\"; then echo \"yes\"; else echo \"no\"; fi\n}\n\necho \"Optional server features:\"\necho\nfeature \"bash-completion ........................ \" \\\n        test \"x$HAVE_BASH_COMPLETION_TRUE\" = \"x\"\nfeature \"manual pages ........................... \" \\\n        test \"x$HAVE_POD_TRUE\" = \"x\"\nfeature \"SELinux ................................ \" \\\n        test \"x$LIBSELINUX_LIBS\" != \"x\"\nfeature \"TLS .................................... \" \\\n        test \"x$GNUTLS_LIBS\" != \"x\"\n\necho\necho \"Optional plugins:\"\necho\nfeature \"curl ................................... \" \\\n        test \"x$HAVE_CURL_TRUE\" = \"x\"\nfeature \"example4 ............................... \" \\\n        test \"x$HAVE_PERL_TRUE\" = \"x\"\nfeature \"floppy ................................. \" \\\n        test \"x$HAVE_ICONV_TRUE\" = \"x\"\nfeature \"guestfs ................................ \" \\\n        test \"x$HAVE_LIBGUESTFS_TRUE\" = \"x\"\nfeature \"gzip ................................... \" \\\n        test \"x$HAVE_ZLIB_TRUE\" = \"x\"\nfeature \"iso .................................... \" \\\n        test \"x$HAVE_ISO_TRUE\" = \"x\"\nfeature \"libvirt ................................ \" \\\n        test \"x$HAVE_LIBVIRT_TRUE\" = \"x\"\nfeature \"linuxdisk .............................. \" \\\n        test \"x$HAVE_MKE2FS_WITH_D_TRUE\" = \"x\"\nfeature \"nbd .................................... \" \\\n        test \"x$HAVE_LIBNBD_TRUE\" = \"x\"\nfeature \"ssh .................................... \" \\\n        test \"x$HAVE_SSH_TRUE\" = \"x\"\nfeature \"torrent ................................ \" \\\n        test \"x$HAVE_TORRENT_TRUE\" = \"x\"\nfeature \"vddk ................................... \" \\\n        test \"x$HAVE_VDDK_TRUE\" = \"x\"\n\necho\necho \"Languages:\"\necho\nfeature \"go ..................................... \" \\\n        test \"x$HAVE_GOLANG_TRUE\" = \"x\"\nfeature \"lua .................................... \" \\\n        test \"x$HAVE_LUA_TRUE\" = \"x\"\nfeature \"ocaml .................................. \" \\\n        test \"x$HAVE_OCAML_TRUE\" = \"x\"\nfeature \"perl ................................... \" \\\n        test \"x$HAVE_PERL_TRUE\" = \"x\"\nfeature \"python ................................. \" \\\n        test \"x$HAVE_PYTHON_TRUE\" = \"x\"\nfeature \"ruby ................................... \" \\\n        test \"x$HAVE_RUBY_TRUE\" = \"x\"\nfeature \"rust ................................... \" \\\n        test \"x$HAVE_RUST_TRUE\" = \"x\"\nfeature \"tcl .................................... \" \\\n        test \"x$HAVE_TCL_TRUE\" = \"x\"\n\necho\necho \"Optional filters:\"\necho\nfeature \"ext2 ................................... \" \\\n        test \"x$HAVE_EXT2_TRUE\" = \"x\"\nfeature \"gzip ................................... \" \\\n        test \"x$HAVE_ZLIB_TRUE\" = \"x\"\nfeature \"xz ..................................... \" \\\n        test \"x$HAVE_LIBLZMA_TRUE\" = \"x\"\n\necho\necho \"Other optional features:\"\necho\nfeature \"allocator=zstd ......................... \" \\\n        test \"x$HAVE_LIBZSTD_TRUE\" = \"x\"\n\necho\necho \"If any optional component is configured \u2018no\u2019 when you expected \u2018yes\u2019\"\necho \"then you should check the preceding messages and README.\"\necho\necho \"Please report bugs back to the mailing list:\"\necho \"http://www.redhat.com/mailman/listinfo/libguestfs\"\necho\necho \"Next you should type 'make' to build the package,\"\necho \"then 'make check' to run the tests.\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/server/debug-flags.c": "/* nbdkit\n * Copyright (C) 2013-2020 Red Hat Inc.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * * Neither the name of Red Hat nor the names of its contributors may be\n * used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY RED HAT AND CONTRIBUTORS ''AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RED HAT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <dlfcn.h>\n\n#include \"internal.h\"\n\nstruct debug_flag {\n  struct debug_flag *next;\n  char *name;                   /* plugin or filter name */\n  char *flag;                   /* flag name */\n  char *symbol;                 /* symbol, eg. \"myplugin_debug_foo\" */\n  int value;                    /* value of flag */\n  bool used;                    /* if flag was successfully set */\n};\n\n/* Synthesize the name of the *_debug_* variable from the plugin name\n * and flag.\n */\nstatic char *\nsymbol_of_debug_flag (const char *name, const char *flag)\n{\n  char *var;\n  size_t i;\n  int len;\n\n  len = asprintf (&var, \"%s_debug_%s\", name, flag);\n  if (len == -1) {\n    perror (\"asprintf\");\n    exit (EXIT_FAILURE);\n  }\n\n  /* If there are any '.'s remaining in the name, convert them to '_'. */\n  for (i = 0; i < (size_t) len; ++i) {\n    if (var[i] == '.')\n      var[i] = '_';\n  }\n\n  return var;                   /* caller frees */\n}\n\n/* Parse and add a single -D flag from the command line.\n *\n * Debug Flag must be \"NAME.FLAG=N\".\n *                     ^    ^    ^\n *                   arg    p    q  (after +1 adjustment below)\n */\nvoid\nadd_debug_flag (const char *arg)\n{\n  struct debug_flag *flag;\n  char *p, *q;\n\n  p = strchr (arg, '.');\n  q = strchr (arg, '=');\n  if (p == NULL || q == NULL) {\n  bad_debug_flag:\n    fprintf (stderr,\n             \"%s: -D (Debug Flag) must have the format NAME.FLAG=N\\n\",\n             program_name);\n    exit (EXIT_FAILURE);\n  }\n  p++;                          /* +1 adjustment */\n  q++;\n\n  if (p - arg <= 1) goto bad_debug_flag; /* NAME too short */\n  if (p > q) goto bad_debug_flag;\n  if (q - p <= 1) goto bad_debug_flag;   /* FLAG too short */\n  if (*q == '\\0') goto bad_debug_flag;   /* N too short */\n\n  flag = malloc (sizeof *flag);\n  if (flag == NULL) {\n  debug_flag_perror:\n    perror (\"malloc\");\n    exit (EXIT_FAILURE);\n  }\n\n  flag->name = strndup (arg, p-arg-1);\n  if (!flag->name) goto debug_flag_perror;\n  flag->flag = strndup (p, q-p-1);\n  if (!flag->flag) goto debug_flag_perror;\n  if (nbdkit_parse_int (\"flag\", q, &flag->value) == -1)\n    goto bad_debug_flag;\n  flag->used = false;\n  flag->symbol = symbol_of_debug_flag (flag->name, flag->flag);\n\n  /* Add flag to the linked list. */\n  flag->next = debug_flags;\n  debug_flags = flag;\n}\n\n/* Apply all debug flags applicable to this backend. */\nvoid\napply_debug_flags (void *dl, const char *name)\n{\n  struct debug_flag *flag;\n\n  for (flag = debug_flags; flag != NULL; flag = flag->next) {\n    if (!flag->used && strcmp (name, flag->name) == 0) {\n      int *sym;\n\n      /* Find the symbol. */\n      sym = dlsym (dl, flag->symbol);\n      if (sym) {\n        /* Set the flag. */\n        *sym = flag->value;\n      }\n      else {\n        fprintf (stderr,\n                 \"%s: warning: -D %s.%s: %s does not contain a \"\n                 \"global variable called %s\\n\",\n                 program_name, name, flag->flag, name, flag->symbol);\n      }\n\n      /* Mark this flag as used. */\n      flag->used = true;\n    }\n  }\n}\n\nvoid\nfree_debug_flags (void)\n{\n  while (debug_flags != NULL) {\n    struct debug_flag *next = debug_flags->next;\n\n    if (!debug_flags->used)\n      fprintf (stderr, \"%s: warning: debug flag -D %s.%s was not used\\n\",\n               program_name, debug_flags->name, debug_flags->flag);\n    free (debug_flags->name);\n    free (debug_flags->flag);\n    free (debug_flags->symbol);\n    free (debug_flags);\n    debug_flags = next;\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/server/main.c": "/* nbdkit\n * Copyright (C) 2013-2020 Red Hat Inc.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * * Neither the name of Red Hat nor the names of its contributors may be\n * used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY RED HAT AND CONTRIBUTORS ''AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RED HAT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#ifdef HAVE_SYS_MMAN_H\n#include <sys/mman.h>\n#endif\n\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n\n#ifdef HAVE_LINUX_VM_SOCKETS_H\n#include <linux/vm_sockets.h>\n#endif\n\n#include <pthread.h>\n\n#include <dlfcn.h>\n\n#include \"ascii-string.h\"\n#include \"exit-with-parent.h\"\n#include \"nbd-protocol.h\"\n#include \"realpath.h\"\n#include \"strndup.h\"\n#include \"syslog.h\"\n#include \"utils.h\"\n\n#include \"internal.h\"\n#include \"options.h\"\n\n#ifdef ENABLE_LIBFUZZER\n#define main fuzzer_main\n#endif\n\nstatic char *make_random_fifo (void);\nstatic struct backend *open_plugin_so (size_t i, const char *filename, int short_name);\nstatic struct backend *open_filter_so (struct backend *next, size_t i, const char *filename, int short_name);\nstatic void start_serving (void);\nstatic void write_pidfile (void);\nstatic bool is_config_key (const char *key, size_t len);\nstatic void error_if_stdio_closed (void);\nstatic void switch_stdio (void);\nstatic void winsock_init (void);\n\nstruct debug_flag *debug_flags; /* -D */\nbool exit_with_parent;          /* --exit-with-parent */\nconst char *export_name;        /* -e */\nbool foreground;                /* -f */\nconst char *ipaddr;             /* -i */\nenum log_to log_to = LOG_TO_DEFAULT; /* --log */\nunsigned mask_handshake = ~0U;  /* --mask-handshake */\nbool newstyle = true;           /* false = -o, true = -n */\nbool no_sr;                     /* --no-sr */\nchar *pidfile;                  /* -P */\nconst char *port;               /* -p */\nbool read_only;                 /* -r */\nconst char *run;                /* --run */\nbool listen_stdin;              /* -s */\nconst char *selinux_label;      /* --selinux-label */\nbool swap;                      /* --swap */\nunsigned threads;               /* -t */\nint tls;                        /* --tls : 0=off 1=on 2=require */\nconst char *tls_certificates_dir; /* --tls-certificates */\nconst char *tls_psk;            /* --tls-psk */\nbool tls_verify_peer;           /* --tls-verify-peer */\nchar *unixsocket;               /* -U */\nconst char *user, *group;       /* -u & -g */\nbool verbose;                   /* -v */\nbool vsock;                     /* --vsock */\nunsigned int socket_activation; /* $LISTEN_FDS and $LISTEN_PID set */\nbool configured;                /* .config_complete done */\nint saved_stdin = -1;           /* dup'd stdin during -s/--run */\nint saved_stdout = -1;          /* dup'd stdout during -s/--run */\n\n/* The linked list of zero or more filters, and one plugin. */\nstruct backend *top;\n\nstatic char *random_fifo_dir = NULL;\nstatic char *random_fifo = NULL;\n\nstatic void\nusage (void)\n{\n  /* --{short,long}-options remain undocumented */\n  const char *opt_list =\n#include \"synopsis.c\"\n\t  ;\n  printf (\"%s\\n\", opt_list);\n  printf (\"Please read the nbdkit(1) manual page for full usage.\\n\");\n}\n\nstatic void\ndisplay_version (void)\n{\n  printf (\"%s %s\\n\", PACKAGE_NAME, PACKAGE_VERSION);\n}\n\nstatic void\ndump_config (void)\n{\n  CLEANUP_FREE char *binary = NULL;\n\n#ifdef __linux__\n  binary = realpath (\"/proc/self/exe\", NULL);\n#else\n#ifdef WIN32\n  /* GetModuleFileNameA has a crappy interface that prevents us from\n   * getting the length of the path so we just have to guess at an\n   * upper limit here.  It will at least truncate it properly with \\0.\n   * _get_pgmptr would be a better alternative except that it isn't\n   * implemented in MinGW.  XXX\n   */\n  binary = malloc (256);\n  if (!GetModuleFileNameA (NULL, binary, 256)) {\n    free (binary);\n    binary = NULL;\n  }\n#endif\n#endif\n\n  if (binary != NULL)\n    printf (\"%s=%s\\n\", \"binary\", binary);\n  printf (\"%s=%s\\n\", \"bindir\", bindir);\n  printf (\"%s=%s\\n\", \"filterdir\", filterdir);\n  printf (\"%s=%s\\n\", \"host_cpu\", host_cpu);\n  printf (\"%s=%s\\n\", \"host_os\", host_os);\n  printf (\"%s=%s\\n\", \"libdir\", libdir);\n  printf (\"%s=%s\\n\", \"mandir\", mandir);\n  printf (\"%s=%s\\n\", \"name\", PACKAGE_NAME);\n  printf (\"%s=%s\\n\", \"plugindir\", plugindir);\n  printf (\"%s=%s\\n\", \"root_tls_certificates_dir\", root_tls_certificates_dir);\n  printf (\"%s=%s\\n\", \"sbindir\", sbindir);\n#ifdef HAVE_LIBSELINUX\n  printf (\"selinux=yes\\n\");\n#else\n  printf (\"selinux=no\\n\");\n#endif\n  printf (\"%s=%s\\n\", \"sysconfdir\", sysconfdir);\n#ifdef HAVE_GNUTLS\n  printf (\"tls=yes\\n\");\n#else\n  printf (\"tls=no\\n\");\n#endif\n  printf (\"%s=%s\\n\", \"version\", PACKAGE_VERSION);\n  printf (\"%s=%d\\n\", \"version_major\", NBDKIT_VERSION_MAJOR);\n  printf (\"%s=%d\\n\", \"version_minor\", NBDKIT_VERSION_MINOR);\n#ifdef HAVE_LIBZSTD\n  printf (\"zstd=yes\\n\");\n#else\n  printf (\"zstd=no\\n\");\n#endif\n}\n\nint\nmain (int argc, char *argv[])\n{\n  int c;\n  bool help = false, version = false, dump_plugin = false;\n  int tls_set_on_cli = false;\n  bool short_name;\n  const char *filename;\n  char *p;\n  static struct filter_filename {\n    struct filter_filename *next;\n    const char *filename;\n  } *filter_filenames = NULL;\n  size_t i;\n  const char *magic_config_key;\n\n  error_if_stdio_closed ();\n  winsock_init ();\n\n#if !ENABLE_LIBFUZZER\n  threadlocal_init ();\n#else\n  static bool main_called = false;\n  if (!main_called) {\n    threadlocal_init ();\n    main_called = true;\n  }\n#endif\n\n  /* The default setting for TLS depends on whether we were\n   * compiled with GnuTLS.\n   */\n#ifdef HAVE_GNUTLS\n  tls = 1;\n#else\n  tls = 0;\n#endif\n\n  /* Returns 0 if no socket activation, or the number of FDs. */\n  socket_activation = get_socket_activation ();\n\n  for (;;) {\n    c = getopt_long (argc, argv, short_options, long_options, NULL);\n    if (c == -1)\n      break;\n\n    switch (c) {\n    case DUMP_CONFIG_OPTION:\n      dump_config ();\n      exit (EXIT_SUCCESS);\n\n    case DUMP_PLUGIN_OPTION:\n      dump_plugin = true;\n      break;\n\n    case EXIT_WITH_PARENT_OPTION:\n#ifdef HAVE_EXIT_WITH_PARENT\n      exit_with_parent = true;\n      foreground = true;\n      break;\n#else\n      fprintf (stderr,\n               \"%s: --exit-with-parent is not implemented \"\n               \"for this operating system\\n\",\n               program_name);\n      exit (EXIT_FAILURE);\n#endif\n\n    case FILTER_OPTION:\n      {\n        struct filter_filename *t;\n\n        t = malloc (sizeof *t);\n        if (t == NULL) {\n          perror (\"malloc\");\n          exit (EXIT_FAILURE);\n        }\n        t->next = filter_filenames;\n        t->filename = optarg;\n        filter_filenames = t;\n      }\n      break;\n\n    case LOG_OPTION:\n      if (strcmp (optarg, \"stderr\") == 0)\n        log_to = LOG_TO_STDERR;\n      else if (strcmp (optarg, \"syslog\") == 0)\n        log_to = LOG_TO_SYSLOG;\n      else if (strcmp (optarg, \"null\") == 0)\n        log_to = LOG_TO_NULL;\n      else {\n        fprintf (stderr, \"%s: \"\n                 \"--log must be \\\"stderr\\\", \\\"syslog\\\" or \\\"null\\\"\\n\",\n                 program_name);\n        exit (EXIT_FAILURE);\n      }\n      break;\n\n    case LONG_OPTIONS_OPTION:\n      for (i = 0; long_options[i].name != NULL; ++i) {\n        if (strcmp (long_options[i].name, \"long-options\") != 0 &&\n            strcmp (long_options[i].name, \"short-options\") != 0)\n          printf (\"--%s\\n\", long_options[i].name);\n      }\n      exit (EXIT_SUCCESS);\n\n    case RUN_OPTION:\n      if (socket_activation) {\n        fprintf (stderr, \"%s: cannot use socket activation with --run flag\\n\",\n                 program_name);\n        exit (EXIT_FAILURE);\n      }\n      run = optarg;\n      foreground = true;\n      break;\n\n    case SELINUX_LABEL_OPTION:\n      selinux_label = optarg;\n      break;\n\n    case SHORT_OPTIONS_OPTION:\n      for (i = 0; short_options[i]; ++i) {\n        if (short_options[i] != ':')\n          printf (\"-%c\\n\", short_options[i]);\n      }\n      exit (EXIT_SUCCESS);\n\n    case SWAP_OPTION:\n      swap = 1;\n      break;\n\n    case TLS_OPTION:\n      tls_set_on_cli = true;\n      if (ascii_strcasecmp (optarg, \"require\") == 0 ||\n          ascii_strcasecmp (optarg, \"required\") == 0 ||\n          ascii_strcasecmp (optarg, \"force\") == 0)\n        tls = 2;\n      else {\n        tls = nbdkit_parse_bool (optarg);\n        if (tls == -1)\n          exit (EXIT_FAILURE);\n      }\n      break;\n\n    case TLS_CERTIFICATES_OPTION:\n      tls_certificates_dir = optarg;\n      break;\n\n    case TLS_PSK_OPTION:\n      tls_psk = optarg;\n      break;\n\n    case TLS_VERIFY_PEER_OPTION:\n      tls_verify_peer = true;\n      break;\n\n    case VSOCK_OPTION:\n#ifdef AF_VSOCK\n      vsock = true;\n      break;\n#else\n      fprintf (stderr, \"%s: AF_VSOCK is not supported on this platform\\n\",\n               program_name);\n      exit (EXIT_FAILURE);\n#endif\n\n    case 'D':\n      add_debug_flag (optarg);\n      break;\n\n    case 'e':\n      export_name = optarg;\n      break;\n\n    case 'f':\n      foreground = true;\n      break;\n\n    case 'g':\n      group = optarg;\n      break;\n\n    case 'i':\n      if (socket_activation) {\n        fprintf (stderr, \"%s: cannot use socket activation with -i flag\\n\",\n                 program_name);\n        exit (EXIT_FAILURE);\n      }\n      ipaddr = optarg;\n      break;\n\n    case MASK_HANDSHAKE_OPTION:\n      if (nbdkit_parse_unsigned (\"mask-handshake\",\n                                 optarg, &mask_handshake) == -1)\n        exit (EXIT_FAILURE);\n      break;\n\n    case 'n':\n      newstyle = true;\n      break;\n\n    case NO_SR_OPTION:\n      no_sr = true;\n      break;\n\n    case 'o':\n      newstyle = false;\n      break;\n\n    case 'P':\n      pidfile = nbdkit_absolute_path (optarg);\n      if (pidfile == NULL)\n        exit (EXIT_FAILURE);\n      break;\n\n    case 'p':\n      if (socket_activation) {\n        fprintf (stderr, \"%s: cannot use socket activation with -p flag\\n\",\n                 program_name);\n        exit (EXIT_FAILURE);\n      }\n      port = optarg;\n      break;\n\n    case 'r':\n      read_only = true;\n      break;\n\n    case 's':\n      if (socket_activation) {\n        fprintf (stderr, \"%s: cannot use socket activation with -s flag\\n\",\n                 program_name);\n        exit (EXIT_FAILURE);\n      }\n      listen_stdin = true;\n#ifdef WIN32\n      /* This could be implemented with a bit of work.  The problem\n       * currently is that we try to use recv() on the stdio file\n       * descriptor which winsock does not support (nor Linux in\n       * fact).  We would need to implement a test to see if the file\n       * descriptor is a socket or not and use either read or recv as\n       * appropriate.\n       */\n      NOT_IMPLEMENTED_ON_WINDOWS (\"-s\");\n#endif\n      break;\n\n    case 't':\n      if (nbdkit_parse_unsigned (\"threads\", optarg, &threads) == -1)\n        exit (EXIT_FAILURE);\n      /* XXX Worth a maximimum limit on threads? */\n      break;\n\n    case 'U':\n      if (socket_activation) {\n        fprintf (stderr, \"%s: cannot use socket activation with -U flag\\n\",\n                 program_name);\n        exit (EXIT_FAILURE);\n      }\n      if (strcmp (optarg, \"-\") == 0)\n        unixsocket = make_random_fifo ();\n      else\n        unixsocket = nbdkit_absolute_path (optarg);\n      if (unixsocket == NULL)\n        exit (EXIT_FAILURE);\n      break;\n\n    case 'u':\n      user = optarg;\n      break;\n\n    case 'v':\n      verbose = true;\n      break;\n\n    case 'V':\n      version = true;\n      break;\n\n    case HELP_OPTION:\n      help = true;\n      break;\n\n    default:\n      usage ();\n      exit (EXIT_FAILURE);\n    }\n  }\n\n  /* No extra parameters. */\n  if (optind >= argc) {\n    if (help) {\n      usage ();\n      exit (EXIT_SUCCESS);\n    }\n    if (version) {\n      display_version ();\n      exit (EXIT_SUCCESS);\n    }\n    if (dump_plugin) {\n      /* Incorrect use of --dump-plugin. */\n      fprintf (stderr,\n               \"%s: use 'nbdkit plugin --dump-plugin' or\\n\"\n               \"'nbdkit /path/to/plugin.\" SOEXT \" --dump-plugin'\\n\",\n               program_name);\n      exit (EXIT_FAILURE);\n    }\n\n    /* Otherwise this is an error. */\n    fprintf (stderr,\n             \"%s: no plugins given on the command line.\\n\"\n             \"Use '%s --help' or \"\n             \"read the nbdkit(1) manual page for documentation.\\n\",\n             program_name, program_name);\n    exit (EXIT_FAILURE);\n  }\n\n  /* --tls=require and oldstyle won't work. */\n  if (tls == 2 && !newstyle) {\n    fprintf (stderr,\n             \"%s: cannot use oldstyle protocol (-o) and require TLS\\n\",\n             program_name);\n    exit (EXIT_FAILURE);\n  }\n\n  /* Set the umask to a known value.  This makes the behaviour of\n   * plugins when creating files more predictable, and also removes an\n   * implicit dependency on umask when calling mkstemp(3).\n   */\n  umask (0022);\n\n  /* If we will or might use syslog. */\n  if (log_to == LOG_TO_SYSLOG || log_to == LOG_TO_DEFAULT)\n    openlog (program_name, LOG_PID, 0);\n\n  /* Initialize TLS. */\n  crypto_init (tls_set_on_cli);\n  assert (tls != -1);\n\n  /* Implement --exit-with-parent early in case plugin initialization\n   * takes a long time and the parent exits during that time.\n   */\n#ifdef HAVE_EXIT_WITH_PARENT\n  if (exit_with_parent) {\n    if (set_exit_with_parent () == -1) {\n      perror (\"nbdkit: --exit-with-parent\");\n      exit (EXIT_FAILURE);\n    }\n  }\n#endif\n\n  /* If the user has mixed up -p/--run/-s/-U/--vsock options, then\n   * give an error.\n   *\n   * XXX Actually the server could easily be extended to handle both\n   * TCP/IP and Unix sockets, or even multiple TCP/IP ports.\n   */\n  if ((port && unixsocket) ||\n      (port && listen_stdin) ||\n      (unixsocket && listen_stdin) ||\n      (listen_stdin && run) ||\n      (listen_stdin && dump_plugin) ||\n      (vsock && unixsocket) ||\n      (vsock && listen_stdin) ||\n      (vsock && run)) {\n    fprintf (stderr,\n             \"%s: --dump-plugin, -p, --run, -s, -U or --vsock options \"\n             \"cannot be used in this combination\\n\",\n             program_name);\n    exit (EXIT_FAILURE);\n  }\n\n  /* The remaining command line arguments are the plugin name and\n   * parameters.  If --help, --version or --dump-plugin were specified\n   * then we open the plugin so that we can display the per-plugin\n   * help/version/plugin information.\n   */\n  filename = argv[optind++];\n  short_name = is_short_name (filename);\n\n  /* Is there an executable script located in the plugindir?\n   * If so we simply execute it with the current command line.\n   */\n  if (short_name) {\n    struct stat statbuf;\n    CLEANUP_FREE char *script;\n\n    if (asprintf (&script,\n                  \"%s/nbdkit-%s-plugin\", plugindir, filename) == -1) {\n      perror (\"asprintf\");\n      exit (EXIT_FAILURE);\n    }\n\n    if (stat (script, &statbuf) == 0 &&\n        (statbuf.st_mode & S_IXUSR) != 0) {\n      /* We're going to execute the plugin directly.\n       * Replace argv[0] with argv[optind-1] and move further arguments\n       * down the list.\n       */\n      argv[0] = argv[optind-1];\n      for (i = optind; i <= argc; i++)\n        argv[i-1] = argv[i];\n      execv (script, argv);\n      perror (script);\n      exit (EXIT_FAILURE);\n    }\n  }\n\n  /* Open the plugin (first) and then wrap the plugin with the\n   * filters.  The filters are wrapped in reverse order that they\n   * appear on the command line so that in the end \u2018top\u2019 points to\n   * the first filter on the command line.\n   */\n  top = open_plugin_so (0, filename, short_name);\n  i = 1;\n  while (filter_filenames) {\n    struct filter_filename *t = filter_filenames;\n\n    filename = t->filename;\n    short_name = is_short_name (filename);\n\n    top = open_filter_so (top, i++, filename, short_name);\n\n    filter_filenames = t->next;\n    free (t);\n  }\n\n  /* Apply nbdkit.* flags for the server. */\n  apply_debug_flags (RTLD_DEFAULT, \"nbdkit\");\n\n  /* Check all debug flags were used, and free them. */\n  free_debug_flags ();\n\n  if (help) {\n    struct backend *b;\n\n    usage ();\n    for_each_backend (b) {\n      printf (\"\\n\");\n      b->usage (b);\n    }\n    top->free (top);\n    exit (EXIT_SUCCESS);\n  }\n\n  if (version) {\n    const char *v;\n    struct backend *b;\n\n    display_version ();\n    for_each_backend (b) {\n      printf (\"%s\", b->name);\n      if ((v = b->version (b)) != NULL)\n        printf (\" %s\", v);\n      printf (\"\\n\");\n    }\n    top->free (top);\n    exit (EXIT_SUCCESS);\n  }\n\n  /* Call config and config_complete to parse the parameters.\n   *\n   * If the plugin provides magic_config_key then any \"bare\" values\n   * (ones not containing \"=\") are prefixed with this key.\n   *\n   * For backwards compatibility with old plugins, and to support\n   * scripting languages, if magic_config_key == NULL then if the\n   * first parameter is bare it is prefixed with the key \"script\", and\n   * any other bare parameters are errors.\n   *\n   * Keys must live for the life of nbdkit.  Since we want to avoid\n   * modifying argv (so that /proc/PID/cmdline remains sane) but we\n   * need to create a key from argv[i] = \"key=value\" we must intern\n   * the keys, which are then freed at the end of main().\n   */\n  magic_config_key = top->magic_config_key (top);\n  for (i = 0; optind < argc; ++i, ++optind) {\n    size_t n;\n\n    p = strchr (argv[optind], '=');\n    n = p - argv[optind];\n    if (p && is_config_key (argv[optind], n)) { /* Is it key=value? */\n      const char *key = nbdkit_strndup_intern (argv[optind], n);\n      if (key == NULL)\n        exit (EXIT_FAILURE);\n      top->config (top, key, p+1);\n    }\n    else if (magic_config_key == NULL) {\n      if (i == 0)               /* magic script parameter */\n        top->config (top, \"script\", argv[optind]);\n      else {\n        fprintf (stderr,\n                 \"%s: expecting key=value on the command line but got: %s\\n\",\n                 program_name, argv[optind]);\n        exit (EXIT_FAILURE);\n      }\n    }\n    else {                      /* magic config key */\n      top->config (top, magic_config_key, argv[optind]);\n    }\n  }\n\n  /* This must run after parsing the parameters so that the script can\n   * be loaded for scripting languages.  But it must be called before\n   * config_complete so that the plugin doesn't check for missing\n   * parameters.\n   */\n  if (dump_plugin) {\n    top->dump_fields (top);\n    top->free (top);\n    free_interns ();\n    exit (EXIT_SUCCESS);\n  }\n\n  top->config_complete (top);\n\n  /* Select the correct thread model based on config. */\n  lock_init_thread_model ();\n\n  /* Tell the plugin that we are about to start serving.  This must be\n   * called before we change user, fork, or open any sockets.\n   */\n  top->get_ready (top);\n\n  switch_stdio ();\n  configured = true;\n\n  start_serving ();\n\n  top->free (top);\n  top = NULL;\n\n  free (unixsocket);\n  free (pidfile);\n\n  if (random_fifo) {\n    unlink (random_fifo);\n    free (random_fifo);\n  }\n\n  if (random_fifo_dir) {\n    rmdir (random_fifo_dir);\n    free (random_fifo_dir);\n  }\n\n  crypto_free ();\n  close_quit_pipe ();\n\n  free_interns ();\n\n  /* Note: Don't exit here, otherwise this won't work when compiled\n   * for libFuzzer.\n   */\n  return EXIT_SUCCESS;\n}\n\n/* Implementation of '-U -' */\nstatic char *\nmake_random_fifo (void)\n{\n  char *sock;\n\n  random_fifo_dir = make_temporary_directory ();\n  if (random_fifo_dir == NULL) {\n    perror (\"make_temporary_directory\");\n    return NULL;\n  }\n\n  if (asprintf (&random_fifo, \"%s\" DIR_SEPARATOR_STR \"socket\",\n                random_fifo_dir) == -1) {\n    perror (\"asprintf\");\n    goto error;\n  }\n\n  sock = strdup (random_fifo);\n  if (sock == NULL) {\n    perror (\"strdup\");\n    goto error;\n  }\n\n  return sock;\n\n error:\n  free (random_fifo);\n  random_fifo = NULL;\n  rmdir (random_fifo_dir);\n  free (random_fifo_dir);\n  random_fifo_dir = NULL;\n  return NULL;\n}\n\nstatic struct backend *\nopen_plugin_so (size_t i, const char *name, int short_name)\n{\n  struct backend *ret;\n  char *filename = (char *) name;\n  bool free_filename = false;\n  void *dl;\n  struct nbdkit_plugin *(*plugin_init) (void);\n  char *error;\n\n  if (short_name) {\n    /* Short names are rewritten relative to the plugindir. */\n    if (asprintf (&filename,\n                  \"%s/nbdkit-%s-plugin.\" SOEXT, plugindir, name) == -1) {\n      perror (\"asprintf\");\n      exit (EXIT_FAILURE);\n    }\n    free_filename = true;\n  }\n\n  dl = dlopen (filename, RTLD_NOW|RTLD_GLOBAL);\n  if (dl == NULL) {\n    fprintf (stderr,\n             \"%s: error: cannot open plugin '%s': %s\\n\"\n             \"Use '%s --help' or \"\n             \"read the nbdkit(1) manual page for documentation.\\n\",\n             program_name, name, dlerror (),\n             program_name);\n    exit (EXIT_FAILURE);\n  }\n\n  /* Initialize the plugin.  See dlopen(3) to understand C weirdness. */\n  dlerror ();\n  *(void **) (&plugin_init) = dlsym (dl, \"plugin_init\");\n  if ((error = dlerror ()) != NULL) {\n    fprintf (stderr, \"%s: %s: %s\\n\", program_name, name, error);\n    exit (EXIT_FAILURE);\n  }\n  if (!plugin_init) {\n    fprintf (stderr, \"%s: %s: invalid plugin_init\\n\", program_name, name);\n    exit (EXIT_FAILURE);\n  }\n\n  /* Register the plugin. */\n  ret = plugin_register (i, filename, dl, plugin_init);\n\n  if (free_filename)\n    free (filename);\n\n  return ret;\n}\n\nstatic struct backend *\nopen_filter_so (struct backend *next, size_t i,\n                const char *name, int short_name)\n{\n  struct backend *ret;\n  char *filename = (char *) name;\n  bool free_filename = false;\n  void *dl;\n  struct nbdkit_filter *(*filter_init) (void);\n  char *error;\n\n  if (short_name) {\n    /* Short names are rewritten relative to the filterdir. */\n    if (asprintf (&filename,\n                  \"%s/nbdkit-%s-filter.\" SOEXT, filterdir, name) == -1) {\n      perror (\"asprintf\");\n      exit (EXIT_FAILURE);\n    }\n    free_filename = true;\n  }\n\n  dl = dlopen (filename, RTLD_NOW|RTLD_GLOBAL);\n  if (dl == NULL) {\n    fprintf (stderr, \"%s: error: cannot open filter '%s': %s\\n\",\n             program_name, name, dlerror ());\n    exit (EXIT_FAILURE);\n  }\n\n  /* Initialize the filter.  See dlopen(3) to understand C weirdness. */\n  dlerror ();\n  *(void **) (&filter_init) = dlsym (dl, \"filter_init\");\n  if ((error = dlerror ()) != NULL) {\n    fprintf (stderr, \"%s: %s: %s\\n\", program_name, name, error);\n    exit (EXIT_FAILURE);\n  }\n  if (!filter_init) {\n    fprintf (stderr, \"%s: %s: invalid filter_init\\n\", program_name, name);\n    exit (EXIT_FAILURE);\n  }\n\n  /* Register the filter. */\n  ret = filter_register (next, i, filename, dl, filter_init);\n\n  if (free_filename)\n    free (filename);\n\n  return ret;\n}\n\nstatic void\nstart_serving (void)\n{\n  sockets socks = empty_vector;\n  size_t i;\n\n  set_up_quit_pipe ();\n#if !ENABLE_LIBFUZZER\n  set_up_signals ();\n#endif\n\n  /* Lock the process into memory if requested. */\n  if (swap) {\n#ifdef HAVE_MLOCKALL\n    if (mlockall (MCL_CURRENT | MCL_FUTURE) == -1) {\n      fprintf (stderr, \"%s: --swap: mlockall: %m\\n\", program_name);\n      exit (EXIT_FAILURE);\n    }\n    debug (\"mlockall done\");\n#else\n    fprintf (stderr, \"%s: mlockall (--swap option) \"\n             \"is not supported on this platform\\n\", program_name);\n    exit (EXIT_FAILURE);\n#endif\n  }\n\n  /* Socket activation: the \u2018socket_activation\u2019 variable (> 0) is the\n   * number of file descriptors from FIRST_SOCKET_ACTIVATION_FD to\n   * FIRST_SOCKET_ACTIVATION_FD+socket_activation-1.\n   */\n  if (socket_activation) {\n      if (sockets_reserve (&socks, socket_activation) == -1) {\n        perror (\"realloc\");\n        exit (EXIT_FAILURE);\n      }\n    for (i = 0; i < socket_activation; ++i) {\n      int s = FIRST_SOCKET_ACTIVATION_FD + i, r;\n      /* This can't fail because of the reservation above. */\n      r = sockets_append (&socks, s);\n      assert (r == 0);\n    }\n    debug (\"using socket activation, nr_socks = %zu\", socks.size);\n    change_user ();\n    write_pidfile ();\n    top->after_fork (top);\n    accept_incoming_connections (&socks);\n    return;\n  }\n\n  /* Handling a single connection on stdin/stdout. */\n  if (listen_stdin) {\n    change_user ();\n    write_pidfile ();\n    top->after_fork (top);\n    threadlocal_new_server_thread ();\n    handle_single_connection (saved_stdin, saved_stdout);\n    return;\n  }\n\n  /* Handling multiple connections on TCP/IP, Unix domain socket or\n   * AF_VSOCK.\n   */\n  if (unixsocket)\n    bind_unix_socket (&socks);\n  else if (vsock)\n    bind_vsock (&socks);\n  else\n    bind_tcpip_socket (&socks);\n\n  run_command ();\n  change_user ();\n  fork_into_background ();\n  write_pidfile ();\n  top->after_fork (top);\n  accept_incoming_connections (&socks);\n}\n\nstatic void\nwrite_pidfile (void)\n{\n  int fd;\n  pid_t pid;\n  char pidstr[64];\n  size_t len;\n\n  if (!pidfile)\n    return;\n\n  pid = getpid ();\n  /* Don't put a trailing \\n after the PID file on Windows. It is\n   * turned into \\r\\n which causes problems if you process the file\n   * using a Unix tool like bash, especially when running the test\n   * suite.\n   */\n  snprintf (pidstr, sizeof pidstr, \"%d\"\n#ifndef WIN32\n            \"\\n\"\n#endif\n            , (int) pid);\n  len = strlen (pidstr);\n\n  fd = open (pidfile, O_WRONLY|O_TRUNC|O_CREAT|O_CLOEXEC|O_NOCTTY, 0644);\n  if (fd == -1) {\n    perror (pidfile);\n    exit (EXIT_FAILURE);\n  }\n\n  if (write (fd, pidstr, len) < len ||\n      close (fd) == -1) {\n    perror (pidfile);\n    exit (EXIT_FAILURE);\n  }\n\n  debug (\"written pidfile %s\", pidfile);\n}\n\n/* When parsing plugin and filter config key=value from the command\n * line, is the key a simple alphanumeric with period, underscore or\n * dash?\n */\nstatic bool\nis_config_key (const char *key, size_t len)\n{\n  static const char allowed_first[] =\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  static const char allowed[] =\n    \"._-\"\n    \"0123456789\"\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n  if (len == 0)\n    return false;\n\n  if (strchr (allowed_first, key[0]) == NULL)\n    return false;\n\n  /* This works in context of the caller since key[len] == '='. */\n  if (strspn (key, allowed) != len)\n    return false;\n\n  return true;\n}\n\n/* Refuse to run if stdin/out/err are closed, whether or not -s is used. */\nstatic void\nerror_if_stdio_closed (void)\n{\n#ifdef F_GETFL\n  if (fcntl (STDERR_FILENO, F_GETFL) == -1) {\n    /* Nowhere we can report the error. Oh well. */\n    exit (EXIT_FAILURE);\n  }\n  if (fcntl (STDIN_FILENO, F_GETFL) == -1 ||\n      fcntl (STDOUT_FILENO, F_GETFL) == -1) {\n    perror (\"expecting stdin/stdout to be opened\");\n    exit (EXIT_FAILURE);\n  }\n#endif\n}\n\n/* Sanitize stdin/stdout to /dev/null, after saving the originals\n * when needed.  We are still single-threaded at this point, and\n * already checked that stdin/out were open, so we don't have to\n * worry about other threads accidentally grabbing our intended fds,\n * or races on FD_CLOEXEC.  POSIX says that 'fflush(NULL)' is\n * supposed to reset the underlying offset of seekable stdin, but\n * glibc is buggy and requires an explicit fflush(stdin) as\n * well. https://sourceware.org/bugzilla/show_bug.cgi?id=12799\n */\nstatic void\nswitch_stdio (void)\n{\n#if defined(F_DUPFD_CLOEXEC) || defined(F_DUPFD)\n  fflush (stdin);\n  fflush (NULL);\n  if (listen_stdin || run) {\n#ifndef F_DUPFD_CLOEXEC\n#define F_DUPFD_CLOEXEC F_DUPFD\n#endif\n    saved_stdin = fcntl (STDIN_FILENO, F_DUPFD_CLOEXEC, STDERR_FILENO + 1);\n    saved_stdout = fcntl (STDOUT_FILENO, F_DUPFD_CLOEXEC, STDERR_FILENO + 1);\n#if F_DUPFD == F_DUPFD_CLOEXEC\n    saved_stdin = set_cloexec (saved_stdin);\n    saved_stdout = set_cloexec (saved_stdout);\n#endif\n    if (saved_stdin == -1 || saved_stdout == -1) {\n      perror (\"fcntl\");\n      exit (EXIT_FAILURE);\n    }\n  }\n#endif\n#ifndef WIN32\n  close (STDIN_FILENO);\n  close (STDOUT_FILENO);\n  if (open (\"/dev/null\", O_RDONLY) != STDIN_FILENO ||\n      open (\"/dev/null\", O_WRONLY) != STDOUT_FILENO) {\n    perror (\"open\");\n    exit (EXIT_FAILURE);\n  }\n#endif\n}\n\n/* On Windows the Winsock library must be initialized early.\n * https://docs.microsoft.com/en-us/windows/win32/winsock/initializing-winsock\n */\nstatic void\nwinsock_init (void)\n{\n#ifdef WIN32\n  WSADATA wsaData;\n  int result;\n\n  result = WSAStartup (MAKEWORD (2, 2), &wsaData);\n  if (result != 0) {\n    fprintf (stderr, \"WSAStartup failed: %d\\n\", result);\n    exit (EXIT_FAILURE);\n  }\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/plugins/vddk/vddk-stubs.h": "/* nbdkit\n * Copyright (C) 2013-2020 Red Hat Inc.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * * Neither the name of Red Hat nor the names of its contributors may be\n * used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY RED HAT AND CONTRIBUTORS ''AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RED HAT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/* This header file lists the functions in VDDK that we will try to\n * dlsym.  It is included in several places in the main plugin, each\n * time with STUB and OPTIONAL_STUB macros expanding to different\n * things depending on the context.\n *\n * The three parameters of STUB and OPTIONAL_STUB macros are always:\n * function name, return value, arguments.\n */\n\n/* Required stubs, present in all versions of VDDK that we support.  I\n * have checked that all these exist in at least VDDK 5.5.5 (2015)\n * which is the earliest version of VDDK that we support.\n */\n\nSTUB (VixDiskLib_InitEx,\n      VixError,\n      (uint32_t major, uint32_t minor,\n       VixDiskLibGenericLogFunc *log_function,\n       VixDiskLibGenericLogFunc *warn_function,\n       VixDiskLibGenericLogFunc *panic_function,\n       const char *lib_dir,\n       const char *config_file));\nSTUB (VixDiskLib_Exit,\n      void,\n      (void));\nSTUB (VixDiskLib_GetErrorText,\n      char *,\n      (VixError err, const char *unused));\nSTUB (VixDiskLib_FreeErrorText,\n      void,\n      (char *text));\nSTUB (VixDiskLib_FreeConnectParams,\n      void,\n      (VixDiskLibConnectParams *params));\nSTUB (VixDiskLib_ConnectEx,\n      VixError,\n      (const VixDiskLibConnectParams *params,\n       char read_only,\n       const char *snapshot_ref,\n       const char *transport_modes,\n       VixDiskLibConnection *connection));\nSTUB (VixDiskLib_Open,\n      VixError,\n      (const VixDiskLibConnection connection,\n       const char *path,\n       uint32_t flags,\n       VixDiskLibHandle *handle));\nSTUB (VixDiskLib_GetTransportMode,\n      const char *,\n      (VixDiskLibHandle handle));\nSTUB (VixDiskLib_Close,\n      VixError,\n      (VixDiskLibHandle handle));\nSTUB (VixDiskLib_Disconnect,\n      VixError,\n      (VixDiskLibConnection connection));\nSTUB (VixDiskLib_GetInfo,\n      VixError,\n      (VixDiskLibHandle handle,\n       VixDiskLibInfo **info));\nSTUB (VixDiskLib_FreeInfo,\n      void,\n      (VixDiskLibInfo *info));\nSTUB (VixDiskLib_Read,\n      VixError,\n      (VixDiskLibHandle handle,\n       uint64_t start_sector, uint64_t nr_sectors,\n       unsigned char *buf));\nSTUB (VixDiskLib_Write,\n      VixError,\n      (VixDiskLibHandle handle,\n       uint64_t start_sector, uint64_t nr_sectors,\n       const unsigned char *buf));\n\n/* Added in VDDK 6.0, this will be NULL in earlier versions. */\nOPTIONAL_STUB (VixDiskLib_Flush,\n               VixError,\n               (VixDiskLibHandle handle));\n\n  /* Added in VDDK 6.7, these will be NULL for earlier versions: */\nOPTIONAL_STUB (VixDiskLib_QueryAllocatedBlocks,\n               VixError,\n               (VixDiskLibHandle diskHandle,\n                uint64_t start_sector, uint64_t nr_sectors,\n                uint64_t chunk_size,\n                VixDiskLibBlockList **block_list));\nOPTIONAL_STUB (VixDiskLib_FreeBlockList,\n               VixError,\n               (VixDiskLibBlockList *block_list));\nOPTIONAL_STUB (VixDiskLib_AllocateConnectParams,\n               VixDiskLibConnectParams *,\n               (void));\n",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/plugins/vddk/vddk.c": "/* nbdkit\n * Copyright (C) 2013-2020 Red Hat Inc.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * * Neither the name of Red Hat nor the names of its contributors may be\n * used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY RED HAT AND CONTRIBUTORS ''AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RED HAT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n#include <unistd.h>\n#include <assert.h>\n#include <dlfcn.h>\n#include <libgen.h>\n\n#include <pthread.h>\n\n#define NBDKIT_API_VERSION 2\n#include <nbdkit-plugin.h>\n\n#include \"cleanup.h\"\n#include \"isaligned.h\"\n#include \"minmax.h\"\n#include \"rounding.h\"\n\n#include \"vddk.h\"\n#include \"vddk-structs.h\"\n\n/* Debug flags. */\nint vddk_debug_diskinfo;\nint vddk_debug_extents;\nint vddk_debug_datapath = 1;\n\n/* For each VDDK API define a static global variable.  These globals\n * are initialized when the plugin is loaded (by vddk_get_ready).\n */\n#define STUB(fn,ret,args) static ret (*fn) args\n#define OPTIONAL_STUB(fn,ret,args) static ret (*fn) args\n#include \"vddk-stubs.h\"\n#undef STUB\n#undef OPTIONAL_STUB\n\n/* Parameters passed to InitEx. */\n#define VDDK_MAJOR 5\n#define VDDK_MINOR 5\n\nstatic void *dl;                           /* dlopen handle */\nstatic bool init_called;                   /* was InitEx called */\nstatic __thread int error_suppression;     /* threadlocal error suppression */\n\nstatic char *config;                       /* config */\nstatic const char *cookie;                 /* cookie */\nstatic const char *filename;               /* file */\nchar *libdir;                              /* libdir */\nstatic uint16_t nfc_host_port;             /* nfchostport */\nchar *password;                            /* password */\nstatic uint16_t port;                      /* port */\nstatic const char *server_name;            /* server */\nstatic bool single_link;                   /* single-link */\nstatic const char *snapshot_moref;         /* snapshot */\nstatic const char *thumb_print;            /* thumbprint */\nstatic const char *transport_modes;        /* transports */\nstatic bool unbuffered;                    /* unbuffered */\nstatic const char *username;               /* user */\nstatic const char *vmx_spec;               /* vm */\nstatic bool is_remote;\n\n#define VDDK_ERROR(err, fs, ...)                                \\\n  do {                                                          \\\n    char *vddk_err_msg;                                         \\\n    vddk_err_msg = VixDiskLib_GetErrorText ((err), NULL);       \\\n    nbdkit_error (fs \": %s\", ##__VA_ARGS__, vddk_err_msg);      \\\n    VixDiskLib_FreeErrorText (vddk_err_msg);                    \\\n  } while (0)\n\n#define DEBUG_CALL(fn, fs, ...)                                 \\\n  nbdkit_debug (\"VDDK call: %s (\" fs \")\", fn, ##__VA_ARGS__)\n#define DEBUG_CALL_DATAPATH(fn, fs, ...)                        \\\n  if (vddk_debug_datapath)                                      \\\n    nbdkit_debug (\"VDDK call: %s (\" fs \")\", fn, ##__VA_ARGS__)\n\n/* Unload the plugin. */\nstatic void\nvddk_unload (void)\n{\n  if (init_called) {\n    DEBUG_CALL (\"VixDiskLib_Exit\", \"\");\n    VixDiskLib_Exit ();\n  }\n  if (dl)\n    dlclose (dl);\n  free (config);\n  free (libdir);\n  free (password);\n}\n\nstatic void\ntrim (char *str)\n{\n  size_t len = strlen (str);\n\n  if (len > 0 && str[len-1] == '\\n')\n    str[len-1] = '\\0';\n}\n\n/* Turn log messages from the library into nbdkit_debug. */\nstatic void\ndebug_function (const char *fs, va_list args)\n{\n  CLEANUP_FREE char *str = NULL;\n\n  if (vasprintf (&str, fs, args) == -1) {\n    nbdkit_debug (\"lost debug message: %s\", fs);\n    return;\n  }\n\n  trim (str);\n\n  nbdkit_debug (\"%s\", str);\n}\n\n/* Turn error messages from the library into nbdkit_error. */\nstatic void\nerror_function (const char *fs, va_list args)\n{\n  CLEANUP_FREE char *str = NULL;\n\n  /* If the thread-local error_suppression flag is non-zero then we\n   * will suppress error messages from VDDK in this thread.\n   */\n  if (error_suppression) return;\n\n  if (vasprintf (&str, fs, args) == -1) {\n    nbdkit_error (\"lost error message: %s\", fs);\n    return;\n  }\n\n  trim (str);\n\n  /* VDDK 7 added a useless error message about their \"phone home\"\n   * system called CEIP which only panics users.  Demote it to a debug\n   * statement.  https://bugzilla.redhat.com/show_bug.cgi?id=1834267\n   */\n  if (strstr (str, \"Get CEIP status failed\") != NULL) {\n    nbdkit_debug (\"%s\", str);\n    return;\n  }\n\n  nbdkit_error (\"%s\", str);\n}\n\n/* Configuration. */\nstatic int\nvddk_config (const char *key, const char *value)\n{\n  int r;\n\n  if (strcmp (key, \"config\") == 0) {\n    /* See FILENAMES AND PATHS in nbdkit-plugin(3). */\n    free (config);\n    config = nbdkit_realpath (value);\n    if (!config)\n      return -1;\n  }\n  else if (strcmp (key, \"cookie\") == 0) {\n    cookie = value;\n  }\n  else if (strcmp (key, \"file\") == 0) {\n    /* NB: Don't convert this to an absolute path, because in the\n     * remote case this can be a path located on the VMware server.\n     * For local paths the user must supply an absolute path.\n     */\n    filename = value;\n  }\n  else if (strcmp (key, \"libdir\") == 0) {\n    /* See FILENAMES AND PATHS in nbdkit-plugin(3). */\n    free (libdir);\n    libdir = nbdkit_realpath (value);\n    if (!libdir)\n      return -1;\n  }\n  else if (strcmp (key, \"nfchostport\") == 0) {\n    if (nbdkit_parse_uint16_t (\"nfchostport\", value, &nfc_host_port) == -1)\n      return -1;\n  }\n  else if (strcmp (key, \"noreexec\") == 0) {\n    /* This undocumented option disables reexec.  The caller must set\n     * LD_LIBRARY_PATH correctly as for older versions of the plugin.\n     * This option is only for use when debugging reexec, eg. to see\n     * if it causing a problem.\n     */\n    r = nbdkit_parse_bool (value);\n    if (r == -1)\n      return -1;\n    noreexec = r;\n  }\n  else if (strcmp (key, \"password\") == 0) {\n    free (password);\n    if (nbdkit_read_password (value, &password) == -1)\n      return -1;\n  }\n  else if (strcmp (key, \"port\") == 0) {\n    if (nbdkit_parse_uint16_t (\"port\", value, &port) == -1)\n      return -1;\n  }\n  else if (strcmp (key, \"reexeced_\") == 0) {\n    /* Special name because it is only for internal use. */\n    reexeced = (char *)value;\n  }\n  else if (strcmp (key, \"server\") == 0) {\n    server_name = value;\n  }\n  else if (strcmp (key, \"single-link\") == 0) {\n    r = nbdkit_parse_bool (value);\n    if (r == -1)\n      return -1;\n    single_link = r;\n  }\n  else if (strcmp (key, \"snapshot\") == 0) {\n    snapshot_moref = value;\n  }\n  else if (strcmp (key, \"thumbprint\") == 0) {\n    thumb_print = value;\n  }\n  else if (strcmp (key, \"transports\") == 0) {\n    transport_modes = value;\n  }\n  else if (strcmp (key, \"unbuffered\") == 0) {\n    r = nbdkit_parse_bool (value);\n    if (r == -1)\n      return -1;\n    unbuffered = r;\n  }\n  else if (strcmp (key, \"user\") == 0) {\n    username = value;\n  }\n  else if (strcmp (key, \"vimapiver\") == 0) {\n    /* Ignored for backwards compatibility. */\n  }\n  else if (strcmp (key, \"vm\") == 0) {\n    vmx_spec = value;\n  }\n  else {\n    nbdkit_error (\"unknown parameter '%s'\", key);\n    return -1;\n  }\n\n  return 0;\n}\n\n/* Load the VDDK library. */\nstatic void\nload_library (bool load_error_is_fatal)\n{\n  static const char *sonames[] = {\n    /* Prefer the newest library in case multiple exist.  Check two\n     * possible directories: the usual VDDK installation puts .so\n     * files in an arch-specific subdirectory of $libdir (our minimum\n     * supported version is VDDK 5.5.5, which only supports x64-64);\n     * but our testsuite is easier to write if we point libdir\n     * directly to a stub .so.\n     */\n    \"lib64/libvixDiskLib.so.7\",\n    \"libvixDiskLib.so.7\",\n    \"lib64/libvixDiskLib.so.6\",\n    \"libvixDiskLib.so.6\",\n    \"lib64/libvixDiskLib.so.5\",\n    \"libvixDiskLib.so.5\",\n  };\n  size_t i;\n  CLEANUP_FREE char *orig_error = NULL;\n\n  if (!libdir) {\n    libdir = strdup (VDDK_LIBDIR);\n    if (!libdir) {\n      nbdkit_error (\"strdup: %m\");\n      exit (EXIT_FAILURE);\n    }\n  }\n\n  for (i = 0; i < sizeof sonames / sizeof sonames[0]; ++i) {\n    CLEANUP_FREE char *path;\n\n    /* Set the full path so that dlopen will preferentially load the\n     * system libraries from the same directory.\n     */\n    if (asprintf (&path, \"%s/%s\", libdir, sonames[i]) == -1) {\n      nbdkit_error (\"asprintf: %m\");\n      exit (EXIT_FAILURE);\n    }\n\n    dl = dlopen (path, RTLD_NOW);\n    if (dl != NULL) {\n      /* Now that we found the library, ensure that LD_LIBRARY_PATH\n       * includes its directory for all future loads.  This may modify\n       * path in-place and/or re-exec nbdkit, but that's okay.\n       */\n      reexec_if_needed (dirname (path));\n      break;\n    }\n    if (i == 0) {\n      orig_error = dlerror ();\n      if (orig_error)\n        orig_error = strdup (orig_error);\n    }\n  }\n  if (dl == NULL) {\n    if (!load_error_is_fatal)\n      return;\n    nbdkit_error (\"%s\\n\\n\"\n                  \"If '%s' is located on a non-standard path you may need to\\n\"\n                  \"set libdir=/path/to/vmware-vix-disklib-distrib.\\n\\n\"\n                  \"See the nbdkit-vddk-plugin(1) man page for details.\",\n                  orig_error ? : \"(unknown error)\", sonames[0]);\n    exit (EXIT_FAILURE);\n  }\n\n  /* Load symbols. */\n#define STUB(fn,ret,args)                                         \\\n  do {                                                            \\\n    fn = dlsym (dl, #fn);                                         \\\n    if (fn == NULL) {                                             \\\n      nbdkit_error (\"required VDDK symbol \\\"%s\\\" is missing: %s\", \\\n                    #fn, dlerror ());                             \\\n      exit (EXIT_FAILURE);                                        \\\n    }                                                             \\\n  } while (0)\n#define OPTIONAL_STUB(fn,ret,args) fn = dlsym (dl, #fn)\n#include \"vddk-stubs.h\"\n#undef STUB\n#undef OPTIONAL_STUB\n}\n\nstatic int\nvddk_config_complete (void)\n{\n  if (filename == NULL) {\n    nbdkit_error (\"you must supply the file=<FILENAME> parameter \"\n                  \"after the plugin name on the command line\");\n    return -1;\n  }\n\n  /* For remote connections, check all the parameters have been\n   * passed.  Note that VDDK will segfault if parameters that it\n   * expects are NULL (and there's no real way to tell what parameters\n   * it is expecting).  This implements the same test that the VDDK\n   * sample program does.\n   */\n  is_remote =\n    vmx_spec ||\n    server_name ||\n    username ||\n    password ||\n    cookie ||\n    thumb_print ||\n    port ||\n    nfc_host_port;\n\n  if (is_remote) {\n#define missing(test, param)                                            \\\n    if (test) {                                                         \\\n      nbdkit_error (\"remote connection requested, missing parameter: %s\", \\\n                    param);                                             \\\n      return -1;                                                        \\\n    }\n    missing (!server_name, \"server\");\n    missing (!username, \"user\");\n    missing (!password, \"password\");\n    missing (!vmx_spec, \"vm\");\n#undef missing\n  }\n\n  /* Restore original LD_LIBRARY_PATH after reexec. */\n  if (restore_ld_library_path () == -1)\n    return -1;\n\n  return 0;\n}\n\n#define vddk_config_help \\\n  \"[file=]<FILENAME>   (required) The filename (eg. VMDK file) to serve.\\n\" \\\n  \"Many optional parameters are supported, see nbdkit-vddk-plugin(3).\"\n\nstatic int\nvddk_get_ready (void)\n{\n  load_library (true);\n  return 0;\n}\n\n/* Defer VDDK initialization until after fork because it is known to\n * create background threads from VixDiskLib_InitEx.  Unfortunately\n * error reporting from this callback is difficult, but we have\n * already checked in .get_ready that the library is dlopenable.\n *\n * For various hangs and failures which were caused by background\n * threads and fork see:\n * https://bugzilla.redhat.com/show_bug.cgi?id=1846309#c9\n * https://www.redhat.com/archives/libguestfs/2019-April/msg00090.html\n */\nstatic int\nvddk_after_fork (void)\n{\n  VixError err;\n\n  /* Initialize VDDK library. */\n  DEBUG_CALL (\"VixDiskLib_InitEx\",\n              \"%d, %d, &debug_fn, &error_fn, &error_fn, %s, %s\",\n              VDDK_MAJOR, VDDK_MINOR,\n              libdir, config ? : \"NULL\");\n  err = VixDiskLib_InitEx (VDDK_MAJOR, VDDK_MINOR,\n                           &debug_function, /* log function */\n                           &error_function, /* warn function */\n                           &error_function, /* panic function */\n                           libdir, config);\n  if (err != VIX_OK) {\n    VDDK_ERROR (err, \"VixDiskLib_InitEx\");\n    exit (EXIT_FAILURE);\n  }\n  init_called = true;\n\n  return 0;\n}\n\nstatic void\nvddk_dump_plugin (void)\n{\n  load_library (false);\n\n  printf (\"vddk_default_libdir=%s\\n\", VDDK_LIBDIR);\n  printf (\"vddk_has_nfchostport=1\\n\");\n\n#if defined(HAVE_DLADDR)\n  /* It would be nice to print the version of VDDK from the shared\n   * library, but VDDK does not provide it.  Instead we can get the\n   * path to the library using the glibc extension dladdr, and then\n   * resolve symlinks using realpath.  The final pathname should\n   * contain the version number.\n   */\n  Dl_info info;\n  CLEANUP_FREE char *p = NULL;\n  if (dl != NULL &&\n      dladdr (VixDiskLib_InitEx, &info) != 0 &&\n      info.dli_fname != NULL &&\n      (p = nbdkit_realpath (info.dli_fname)) != NULL) {\n    printf (\"vddk_dll=%s\\n\", p);\n  }\n#endif\n}\n\n/* The rules on threads and VDDK are here:\n * https://code.vmware.com/docs/11750/virtual-disk-development-kit-programming-guide/GUID-6BE903E8-DC70-46D9-98E4-E34A2002C2AD.html\n *\n * Before nbdkit 1.22 we used SERIALIZE_ALL_REQUESTS.  Since nbdkit\n * 1.22 we changed this to SERIALIZE_REQUESTS and added a mutex around\n * calls to VixDiskLib_Open and VixDiskLib_Close.  This is not quite\n * within the letter of the rules, but is within the spirit.\n */\n#define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_REQUESTS\n\n/* Lock protecting open/close calls - see above. */\nstatic pthread_mutex_t open_close_lock = PTHREAD_MUTEX_INITIALIZER;\n\n/* The per-connection handle. */\nstruct vddk_handle {\n  VixDiskLibConnectParams *params; /* connection parameters */\n  VixDiskLibConnection connection; /* connection */\n  VixDiskLibHandle handle;         /* disk handle */\n};\n\nstatic inline VixDiskLibConnectParams *\nallocate_connect_params (void)\n{\n  VixDiskLibConnectParams *ret;\n\n  if (VixDiskLib_AllocateConnectParams != NULL) {\n    DEBUG_CALL (\"VixDiskLib_AllocateConnectParams\", \"\");\n    ret = VixDiskLib_AllocateConnectParams ();\n  }\n  else\n    ret = calloc (1, sizeof (VixDiskLibConnectParams));\n\n  return ret;\n}\n\nstatic inline void\nfree_connect_params (VixDiskLibConnectParams *params)\n{\n  /* Only use FreeConnectParams if AllocateConnectParams was\n   * originally called.  Otherwise use free.\n   */\n  if (VixDiskLib_AllocateConnectParams != NULL) {\n    DEBUG_CALL (\"VixDiskLib_FreeConnectParams\", \"params\");\n    VixDiskLib_FreeConnectParams (params);\n  }\n  else\n    free (params);\n}\n\n/* Create the per-connection handle. */\nstatic void *\nvddk_open (int readonly)\n{\n  ACQUIRE_LOCK_FOR_CURRENT_SCOPE (&open_close_lock);\n  struct vddk_handle *h;\n  VixError err;\n  uint32_t flags;\n\n  h = malloc (sizeof *h);\n  if (h == NULL) {\n    nbdkit_error (\"malloc: %m\");\n    return NULL;\n  }\n\n  h->params = allocate_connect_params ();\n  if (h->params == NULL) {\n    nbdkit_error (\"allocate VixDiskLibConnectParams: %m\");\n    goto err0;\n  }\n\n  if (is_remote) {\n    h->params->vmxSpec = (char *) vmx_spec;\n    h->params->serverName = (char *) server_name;\n    if (cookie == NULL) {\n      h->params->credType = VIXDISKLIB_CRED_UID;\n      h->params->creds.uid.userName = (char *) username;\n      h->params->creds.uid.password = password;\n    }\n    else {\n      h->params->credType = VIXDISKLIB_CRED_SESSIONID;\n      h->params->creds.sessionId.cookie = (char *) cookie;\n      h->params->creds.sessionId.userName = (char *) username;\n      h->params->creds.sessionId.key = password;\n    }\n    h->params->thumbPrint = (char *) thumb_print;\n    h->params->port = port;\n    h->params->nfcHostPort = nfc_host_port;\n    h->params->specType = VIXDISKLIB_SPEC_VMX;\n  }\n\n  /* XXX Some documentation suggests we should call\n   * VixDiskLib_PrepareForAccess here.  It may be required for\n   * Advanced Transport modes, but I could not make it work with\n   * either ESXi or vCenter servers.\n   */\n\n  DEBUG_CALL (\"VixDiskLib_ConnectEx\",\n              \"h->params, %d, %s, %s, &connection\",\n              readonly,\n              snapshot_moref ? : \"NULL\",\n              transport_modes ? : \"NULL\");\n  err = VixDiskLib_ConnectEx (h->params,\n                              readonly,\n                              snapshot_moref,\n                              transport_modes,\n                              &h->connection);\n  if (err != VIX_OK) {\n    VDDK_ERROR (err, \"VixDiskLib_ConnectEx\");\n    goto err1;\n  }\n\n  flags = 0;\n  if (readonly)\n    flags |= VIXDISKLIB_FLAG_OPEN_READ_ONLY;\n  if (single_link)\n    flags |= VIXDISKLIB_FLAG_OPEN_SINGLE_LINK;\n  if (unbuffered)\n    flags |= VIXDISKLIB_FLAG_OPEN_UNBUFFERED;\n\n  DEBUG_CALL (\"VixDiskLib_Open\",\n              \"connection, %s, %d, &handle\", filename, flags);\n  err = VixDiskLib_Open (h->connection, filename, flags, &h->handle);\n  if (err != VIX_OK) {\n    VDDK_ERROR (err, \"VixDiskLib_Open: %s\", filename);\n    goto err2;\n  }\n\n  nbdkit_debug (\"transport mode: %s\",\n                VixDiskLib_GetTransportMode (h->handle));\n\n  return h;\n\n err2:\n  DEBUG_CALL (\"VixDiskLib_Disconnect\", \"connection\");\n  VixDiskLib_Disconnect (h->connection);\n err1:\n  free_connect_params (h->params);\n err0:\n  free (h);\n  return NULL;\n}\n\n/* Free up the per-connection handle. */\nstatic void\nvddk_close (void *handle)\n{\n  ACQUIRE_LOCK_FOR_CURRENT_SCOPE (&open_close_lock);\n  struct vddk_handle *h = handle;\n\n  DEBUG_CALL (\"VixDiskLib_Close\", \"handle\");\n  VixDiskLib_Close (h->handle);\n  DEBUG_CALL (\"VixDiskLib_Disconnect\", \"connection\");\n  VixDiskLib_Disconnect (h->connection);\n  free_connect_params (h->params);\n  free (h);\n}\n\n/* Get the file size. */\nstatic int64_t\nvddk_get_size (void *handle)\n{\n  struct vddk_handle *h = handle;\n  VixDiskLibInfo *info;\n  VixError err;\n  uint64_t size;\n\n  DEBUG_CALL (\"VixDiskLib_GetInfo\", \"handle, &info\");\n  err = VixDiskLib_GetInfo (h->handle, &info);\n  if (err != VIX_OK) {\n    VDDK_ERROR (err, \"VixDiskLib_GetInfo\");\n    return -1;\n  }\n\n  size = info->capacity * (uint64_t)VIXDISKLIB_SECTOR_SIZE;\n\n  if (vddk_debug_diskinfo) {\n    nbdkit_debug (\"disk info: capacity: %\" PRIu64 \" (size: %\" PRIi64 \")\",\n                  info->capacity, size);\n    nbdkit_debug (\"disk info: biosGeo: C:%\" PRIu32 \" H:%\" PRIu32 \" S:%\" PRIu32,\n                  info->biosGeo.cylinders,\n                  info->biosGeo.heads,\n                  info->biosGeo.sectors);\n    nbdkit_debug (\"disk info: physGeo: C:%\" PRIu32 \" H:%\" PRIu32 \" S:%\" PRIu32,\n                  info->physGeo.cylinders,\n                  info->physGeo.heads,\n                  info->physGeo.sectors);\n    nbdkit_debug (\"disk info: adapter type: %d\",\n                  (int) info->adapterType);\n    nbdkit_debug (\"disk info: num links: %d\", info->numLinks);\n    nbdkit_debug (\"disk info: parent filename hint: %s\",\n                  info->parentFileNameHint ? : \"NULL\");\n    nbdkit_debug (\"disk info: uuid: %s\",\n                  info->uuid ? : \"NULL\");\n  }\n\n  DEBUG_CALL (\"VixDiskLib_FreeInfo\", \"info\");\n  VixDiskLib_FreeInfo (info);\n\n  return (int64_t) size;\n}\n\n/* Read data from the file.\n *\n * Note that reads have to be aligned to sectors (XXX).\n */\nstatic int\nvddk_pread (void *handle, void *buf, uint32_t count, uint64_t offset,\n            uint32_t flags)\n{\n  struct vddk_handle *h = handle;\n  VixError err;\n\n  /* Align to sectors. */\n  if (!IS_ALIGNED (offset, VIXDISKLIB_SECTOR_SIZE)) {\n    nbdkit_error (\"%s is not aligned to sectors\", \"read\");\n    return -1;\n  }\n  if (!IS_ALIGNED (count, VIXDISKLIB_SECTOR_SIZE)) {\n    nbdkit_error (\"%s is not aligned to sectors\", \"read\");\n    return -1;\n  }\n  offset /= VIXDISKLIB_SECTOR_SIZE;\n  count /= VIXDISKLIB_SECTOR_SIZE;\n\n  DEBUG_CALL_DATAPATH (\"VixDiskLib_Read\",\n                       \"handle, %\" PRIu64 \" sectors, \"\n                       \"%\" PRIu32 \" sectors, buffer\",\n                       offset, count);\n  err = VixDiskLib_Read (h->handle, offset, count, buf);\n  if (err != VIX_OK) {\n    VDDK_ERROR (err, \"VixDiskLib_Read\");\n    return -1;\n  }\n\n  return 0;\n}\n\nstatic int vddk_flush (void *handle, uint32_t flags);\n\n/* Write data to the file.\n *\n * Note that writes have to be aligned to sectors (XXX).\n */\nstatic int\nvddk_pwrite (void *handle, const void *buf, uint32_t count, uint64_t offset,\n             uint32_t flags)\n{\n  const bool fua = flags & NBDKIT_FLAG_FUA;\n  struct vddk_handle *h = handle;\n  VixError err;\n\n  /* Align to sectors. */\n  if (!IS_ALIGNED (offset, VIXDISKLIB_SECTOR_SIZE)) {\n    nbdkit_error (\"%s is not aligned to sectors\", \"write\");\n    return -1;\n  }\n  if (!IS_ALIGNED (count, VIXDISKLIB_SECTOR_SIZE)) {\n    nbdkit_error (\"%s is not aligned to sectors\", \"write\");\n    return -1;\n  }\n  offset /= VIXDISKLIB_SECTOR_SIZE;\n  count /= VIXDISKLIB_SECTOR_SIZE;\n\n  DEBUG_CALL_DATAPATH (\"VixDiskLib_Write\",\n                       \"handle, %\" PRIu64 \" sectors, \"\n                       \"%\" PRIu32 \" sectors, buffer\",\n                       offset, count);\n  err = VixDiskLib_Write (h->handle, offset, count, buf);\n  if (err != VIX_OK) {\n    VDDK_ERROR (err, \"VixDiskLib_Write\");\n    return -1;\n  }\n\n  if (fua && vddk_flush (handle, 0) == -1)\n    return -1;\n\n  return 0;\n}\n\n/* Flush data to the file. */\nstatic int\nvddk_flush (void *handle, uint32_t flags)\n{\n  struct vddk_handle *h = handle;\n  VixError err;\n\n  /* The Flush call was not available in VDDK < 6.0 so this is simply\n   * ignored on earlier versions.\n   */\n  if (VixDiskLib_Flush == NULL)\n    return 0;\n\n  DEBUG_CALL (\"VixDiskLib_Flush\", \"handle\");\n  err = VixDiskLib_Flush (h->handle);\n  if (err != VIX_OK) {\n    VDDK_ERROR (err, \"VixDiskLib_Flush\");\n    return -1;\n  }\n\n  return 0;\n}\n\nstatic int\nvddk_can_extents (void *handle)\n{\n  struct vddk_handle *h = handle;\n  VixError err;\n  VixDiskLibBlockList *block_list;\n\n  /* This call was added in VDDK 6.7.  In earlier versions the\n   * function pointer will be NULL and we cannot query extents.\n   */\n  if (VixDiskLib_QueryAllocatedBlocks == NULL) {\n    nbdkit_debug (\"can_extents: VixDiskLib_QueryAllocatedBlocks == NULL, \"\n                  \"probably this is VDDK < 6.7\");\n    return 0;\n  }\n\n  /* Suppress errors around this call.  See:\n   * https://bugzilla.redhat.com/show_bug.cgi?id=1709211#c7\n   */\n  error_suppression = 1;\n\n  /* However even when the call is available it rarely works well so\n   * the best thing we can do here is to try the call and if it's\n   * non-functional return false.\n   */\n  DEBUG_CALL (\"VixDiskLib_QueryAllocatedBlocks\",\n              \"handle, 0, %d sectors, %d sectors\",\n              VIXDISKLIB_MIN_CHUNK_SIZE, VIXDISKLIB_MIN_CHUNK_SIZE);\n  err = VixDiskLib_QueryAllocatedBlocks (h->handle,\n                                         0, VIXDISKLIB_MIN_CHUNK_SIZE,\n                                         VIXDISKLIB_MIN_CHUNK_SIZE,\n                                         &block_list);\n  error_suppression = 0;\n  if (err == VIX_OK) {\n    DEBUG_CALL (\"VixDiskLib_FreeBlockList\", \"block_list\");\n    VixDiskLib_FreeBlockList (block_list);\n  }\n  if (err != VIX_OK) {\n    char *errmsg = VixDiskLib_GetErrorText (err, NULL);\n    nbdkit_debug (\"can_extents: VixDiskLib_QueryAllocatedBlocks test failed, \"\n                  \"extents support will be disabled: \"\n                  \"original error: %s\",\n                  errmsg);\n    VixDiskLib_FreeErrorText (errmsg);\n    return 0;\n  }\n\n  return 1;\n}\n\nstatic int\nadd_extent (struct nbdkit_extents *extents,\n            uint64_t *position, uint64_t next_position, bool is_hole)\n{\n  uint32_t type = 0;\n  const uint64_t length = next_position - *position;\n\n  if (is_hole) {\n    type = NBDKIT_EXTENT_HOLE;\n    /* Images opened as single link might be backed by another file in the\n       chain, so the holes are not guaranteed to be zeroes. */\n    if (!single_link)\n      type |= NBDKIT_EXTENT_ZERO;\n  }\n\n  assert (*position <= next_position);\n  if (*position == next_position)\n    return 0;\n\n  if (vddk_debug_extents)\n    nbdkit_debug (\"adding extent type %s at [%\" PRIu64 \"...%\" PRIu64 \"]\",\n                  is_hole ? \"hole\" : \"allocated data\",\n                  *position, next_position-1);\n  if (nbdkit_add_extent (extents, *position, length, type) == -1)\n    return -1;\n\n  *position = next_position;\n  return 0;\n}\n\nstatic int\nvddk_extents (void *handle, uint32_t count, uint64_t offset, uint32_t flags,\n              struct nbdkit_extents *extents)\n{\n  struct vddk_handle *h = handle;\n  bool req_one = flags & NBDKIT_FLAG_REQ_ONE;\n  uint64_t position, end, start_sector;\n\n  position = offset;\n  end = offset + count;\n\n  /* We can only query whole chunks.  Therefore start with the first\n   * chunk before offset.\n   */\n  start_sector =\n    ROUND_DOWN (offset, VIXDISKLIB_MIN_CHUNK_SIZE * VIXDISKLIB_SECTOR_SIZE)\n    / VIXDISKLIB_SECTOR_SIZE;\n  while (start_sector * VIXDISKLIB_SECTOR_SIZE < end) {\n    VixError err;\n    uint32_t i;\n    uint64_t nr_chunks, nr_sectors;\n    VixDiskLibBlockList *block_list;\n\n    assert (IS_ALIGNED (start_sector, VIXDISKLIB_MIN_CHUNK_SIZE));\n\n    nr_chunks =\n      ROUND_UP (end - start_sector * VIXDISKLIB_SECTOR_SIZE,\n                VIXDISKLIB_MIN_CHUNK_SIZE * VIXDISKLIB_SECTOR_SIZE)\n      / (VIXDISKLIB_MIN_CHUNK_SIZE * VIXDISKLIB_SECTOR_SIZE);\n    nr_chunks = MIN (nr_chunks, VIXDISKLIB_MAX_CHUNK_NUMBER);\n    nr_sectors = nr_chunks * VIXDISKLIB_MIN_CHUNK_SIZE;\n\n    DEBUG_CALL (\"VixDiskLib_QueryAllocatedBlocks\",\n                \"handle, %\" PRIu64 \" sectors, %\" PRIu64 \" sectors, \"\n                \"%d sectors\",\n                start_sector, nr_sectors, VIXDISKLIB_MIN_CHUNK_SIZE);\n    err = VixDiskLib_QueryAllocatedBlocks (h->handle,\n                                           start_sector, nr_sectors,\n                                           VIXDISKLIB_MIN_CHUNK_SIZE,\n                                           &block_list);\n    if (err != VIX_OK) {\n      VDDK_ERROR (err, \"VixDiskLib_QueryAllocatedBlocks\");\n      return -1;\n    }\n\n    for (i = 0; i < block_list->numBlocks; ++i) {\n      uint64_t blk_offset, blk_length;\n\n      blk_offset = block_list->blocks[i].offset * VIXDISKLIB_SECTOR_SIZE;\n      blk_length = block_list->blocks[i].length * VIXDISKLIB_SECTOR_SIZE;\n\n      /* The query returns allocated blocks.  We must insert holes\n       * between the blocks as necessary.\n       */\n      if ((position < blk_offset &&\n           add_extent (extents, &position, blk_offset, true) == -1) ||\n          (add_extent (extents,\n                       &position, blk_offset + blk_length, false) == -1)) {\n        DEBUG_CALL (\"VixDiskLib_FreeBlockList\", \"block_list\");\n        VixDiskLib_FreeBlockList (block_list);\n        return -1;\n      }\n    }\n    DEBUG_CALL (\"VixDiskLib_FreeBlockList\", \"block_list\");\n    VixDiskLib_FreeBlockList (block_list);\n\n    /* There's an implicit hole after the returned list of blocks, up\n     * to the end of the QueryAllocatedBlocks request.\n     */\n    if (add_extent (extents,\n                    &position,\n                    (start_sector + nr_sectors) * VIXDISKLIB_SECTOR_SIZE,\n                    true) == -1)\n      return -1;\n\n    start_sector += nr_sectors;\n\n    /* If one extent was requested, as long as we've added an extent\n     * overlapping the original offset we're done.\n     */\n    if (req_one && position > offset)\n      break;\n  }\n\n  return 0;\n}\n\nstatic struct nbdkit_plugin plugin = {\n  .name              = \"vddk\",\n  .longname          = \"VMware VDDK plugin\",\n  .version           = PACKAGE_VERSION,\n  .unload            = vddk_unload,\n  .config            = vddk_config,\n  .config_complete   = vddk_config_complete,\n  .config_help       = vddk_config_help,\n  .magic_config_key  = \"file\",\n  .dump_plugin       = vddk_dump_plugin,\n  .get_ready         = vddk_get_ready,\n  .after_fork        = vddk_after_fork,\n  .open              = vddk_open,\n  .close             = vddk_close,\n  .get_size          = vddk_get_size,\n  .pread             = vddk_pread,\n  .pwrite            = vddk_pwrite,\n  .flush             = vddk_flush,\n  .can_extents       = vddk_can_extents,\n  .extents           = vddk_extents,\n};\n\nNBDKIT_REGISTER_PLUGIN(plugin)\n",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/plugins/cc/cc.c": "/* nbdkit\n * Copyright (C) 2018-2020 Red Hat Inc.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * * Neither the name of Red Hat nor the names of its contributors may be\n * used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY RED HAT AND CONTRIBUTORS ''AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RED HAT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <dlfcn.h>\n\n#define NBDKIT_API_VERSION 2\n#include <nbdkit-plugin.h>\n\n#include \"cleanup.h\"\n#include \"utils.h\"\n#include \"vector.h\"\n\n/* The script name. */\nstatic char *script;\nstatic bool unlink_on_exit = false;\n\n/* C compiler and flags. */\nstatic const char *cc = CC;\nstatic const char *cflags = CFLAGS;\nstatic const char *extra_cflags;\n\n/* List of parameters for the subplugin. */\nstruct key_value { const char *key, *value; };\nDEFINE_VECTOR_TYPE(string_vector, struct key_value);\nstatic string_vector params = empty_vector;\n\n/* The subplugin. */\nstatic void *dl;\nstatic struct nbdkit_plugin subplugin;\n\nstatic void\ncc_unload (void)\n{\n  if (subplugin.unload)\n    subplugin.unload ();\n\n  if (unlink_on_exit)\n    unlink (script);\n  if (dl)\n    dlclose (dl);\n  free (params.ptr);\n  free (script);\n}\n\nstatic void\ncc_dump_plugin (void)\n{\n  printf (\"CC=%s\\n\", CC);\n  printf (\"CFLAGS=%s\\n\", CFLAGS);\n}\n\n#define cc_config_help \\\n  \"[script=]<FILENAME>   (required) The shell script to run.\\n\" \\\n  \"CC=<CC>                          C compiler.\\n\" \\\n  \"CFLAGS=<CFLAGS>                  C compiler flags.\\n\" \\\n  \"EXTRA_CFLAGS=<CFLAGS>            Extra C compiler flags.\\n\" \\\n  \"[other arguments may be used by the plugin that you load]\"\n\nstatic char *\ninline_script (void)\n{\n  CLEANUP_FREE char *cmd = NULL;\n  int fd;\n\n  if (!nbdkit_stdio_safe ()) {\n    nbdkit_error (\"inline script is incompatible with -s\");\n    return NULL;\n  }\n\n  script = strdup (\"/tmp/ccXXXXXX.c\");\n  if (script == NULL) {\n    nbdkit_error (\"strdup: %m\");\n    return NULL;\n  }\n\n  fd = mkstemps (script, 2);\n  if (fd == -1) {\n    nbdkit_error (\"mkstemps: %m\");\n    return NULL;\n  }\n  close (fd);\n  unlink_on_exit = true;\n\n  if (asprintf (&cmd, \"cat > %s\", script) == -1) {\n    nbdkit_error (\"asprintf: %m\");\n    return NULL;\n  }\n\n  if (system (cmd) != 0) {\n    nbdkit_error (\"cc: failed to copy inline script to temporary file\");\n    return NULL;\n  }\n\n  return script;\n}\n\nstatic int\ncc_config (const char *key, const char *value)\n{\n  if (!script) {\n    /* The first parameter must be \"script\". */\n    if (strcmp (key, \"script\") != 0) {\n      nbdkit_error (\"cc: the first parameter must be the C file or \\\"-\\\"\");\n      return -1;\n    }\n    if (strcmp (value, \"-\") != 0)\n      script = nbdkit_realpath (value);\n    else\n      script = inline_script ();\n    if (script == NULL)\n      return -1;\n\n    return 0;\n  }\n  else {\n    /* Although not impossible, it's likely to be a bug if there is a\n     * further parameter called \"script\" so disallow it.\n     */\n    if (strcmp (key, \"script\") == 0) {\n      nbdkit_error (\"cc: script parameter must appear only once\");\n      return -1;\n    }\n    /* Otherwise parse our parameters. */\n    else if (strcmp (key, \"CC\") == 0)\n      cc = value;\n    else if (strcmp (key, \"CFLAGS\") == 0)\n      cflags = value;\n    else if (strcmp (key, \"EXTRA_CFLAGS\") == 0)\n      extra_cflags = value;\n    else {\n      /* Anything else is saved for the subplugin. */\n      struct key_value kv = { .key = key, .value = value };\n\n      if (string_vector_append (&params, kv) == -1) {\n        nbdkit_error (\"realloc: %m\");\n        return -1;\n      }\n    }\n    return 0;\n  }\n}\n\n/* We must compile and load the subplugin here (not in get_ready)\n * because we must find the subplugin's thread model, and the core\n * server will query that straight after config_complete.\n */\nstatic int\ncc_config_complete (void)\n{\n  CLEANUP_FREE char *command = NULL;\n  size_t len = 0, size, i;\n  FILE *fp;\n  int fd, r;\n  char tmpfile[] = \"/tmp/ccXXXXXX.so\";\n  struct nbdkit_plugin *(*plugin_init) (void);\n  char *error;\n  const struct nbdkit_plugin *ptr;\n\n  if (!script) {\n    nbdkit_error (\"cc: no C program name (or \\\"-\\\") given\");\n    return -1;\n  }\n\n  /* Create a temporary file to store the compiled plugin. */\n  fd = mkstemps (tmpfile, 3);\n  if (fd == -1) {\n    nbdkit_error (\"mkstemps: %m\");\n    return -1;\n  }\n  close (fd);\n\n  /* Compile the C program. */\n  fp = open_memstream (&command, &len);\n  if (fp == NULL) {\n    nbdkit_error (\"open_memstream: %m\");\n    return -1;\n  }\n  /* The C compiler and C flags don't need to be quoted. */\n  fprintf (fp, \"%s %s \", cc, cflags);\n  if (extra_cflags)\n    fprintf (fp, \"%s \", extra_cflags);\n  shell_quote (script, fp);\n  fprintf (fp, \" -o \");\n  shell_quote (tmpfile, fp);\n  if (fclose (fp) == EOF) {\n    nbdkit_error (\"memstream failed: %m\");\n    return -1;\n  }\n\n  nbdkit_debug (\"cc: %s\", command);\n  r = system (command);\n  if (exit_status_to_nbd_error (r, cc) == -1) {\n    unlink (tmpfile);\n    return -1;\n  }\n\n  /* Load the subplugin. */\n  dl = dlopen (tmpfile, RTLD_NOW);\n  unlink (tmpfile);\n  if (dl == NULL) {\n    nbdkit_error (\"cannot open the compiled plugin: %s\", dlerror ());\n    return -1;\n  }\n\n  /* Now we basically behave like core nbdkit when it loads a plugin. */\n  dlerror ();\n  *(void **) (&plugin_init) = dlsym (dl, \"plugin_init\");\n  if ((error = dlerror ()) != NULL) {\n    nbdkit_error (\"no plugin_init symbol found: %s\", dlerror ());\n    return -1;\n  }\n  if (!plugin_init) {\n    nbdkit_error (\"invalid plugin_init symbol\");\n    return -1;\n  }\n  ptr = plugin_init ();\n  if (!ptr) {\n    nbdkit_error (\"plugin registration failed\");\n    return -1;\n  }\n\n  /* Are the APIs compatible? */\n  if (ptr->_api_version != NBDKIT_API_VERSION) {\n    nbdkit_error (\"plugin uses the wrong NBDKIT_API_VERSION, it must be %d\",\n                  NBDKIT_API_VERSION);\n    return -1;\n  }\n\n  /* Copy the subplugins struct into our plugin global, padding or\n   * truncating as necessary.\n   */\n  size = sizeof subplugin;      /* Size of our struct. */\n  if (size > ptr->_struct_size)\n    size = ptr->_struct_size;\n  memcpy (&subplugin, ptr, size);\n\n  /* Check that the plugin has .open, .get_size and .pread. */\n  if (subplugin.open == NULL) {\n    nbdkit_error (\"plugin must have a .open callback\");\n    return -1;\n  }\n  if (subplugin.get_size == NULL) {\n    nbdkit_error (\"plugin must have a .get_size callback\");\n    return -1;\n  }\n  if (subplugin.pread == NULL) {\n    nbdkit_error (\"plugin must have a .pread callback\");\n    return -1;\n  }\n\n  /* Now we have to call the subplugin's load, config and\n   * config_complete.  Everything after that will be called via the\n   * core server through our forwarding functions below.\n   */\n  if (subplugin.load)\n    subplugin.load ();\n  if (subplugin.config) {\n    for (i = 0; i < params.size; ++i) {\n      if (subplugin.config (params.ptr[i].key, params.ptr[i].value) == -1)\n        return -1;\n    }\n  }\n  else if (params.size > 0) {\n    /* Just print the first one in the error message. */\n    nbdkit_error (\"unknown parameter: %s\", params.ptr[0].key);\n    return -1;\n  }\n  if (subplugin.config_complete) {\n    if (subplugin.config_complete () == -1)\n      return -1;\n  }\n\n  return 0;\n}\n\n/* This is adjusted when we load the subplugin. */\n#define THREAD_MODEL NBDKIT_THREAD_MODEL_PARALLEL\n\n/* Set the thread model from the subplugin. */\nstatic int\ncc_thread_model (void)\n{\n  if (subplugin.thread_model != NULL)\n    return subplugin.thread_model ();\n  else\n    return subplugin._thread_model;\n}\n\n/* All other calls are forwarded to the subplugin. */\nstatic int\ncc_get_ready (void)\n{\n  if (subplugin.get_ready)\n    return subplugin.get_ready ();\n  return 0;\n}\n\nstatic int\ncc_after_fork (void)\n{\n  if (subplugin.after_fork)\n    return subplugin.after_fork ();\n  return 0;\n}\n\nstatic int\ncc_preconnect (int readonly)\n{\n  if (subplugin.preconnect)\n    return subplugin.preconnect (readonly);\n  return 0;\n}\n\nstatic int\ncc_list_exports (int readonly, int is_tls, struct nbdkit_exports *exports)\n{\n  if (subplugin.list_exports)\n    return subplugin.list_exports (readonly, is_tls, exports);\n  return nbdkit_use_default_export (exports);\n}\n\nstatic const char *\ncc_default_export (int readonly, int is_tls)\n{\n  if (subplugin.default_export)\n    return subplugin.default_export (readonly, is_tls);\n  return \"\";\n}\n\nstatic void *\ncc_open (int readonly)\n{\n  return subplugin.open (readonly);\n}\n\nstatic void\ncc_close (void *handle)\n{\n  if (subplugin.close)\n    subplugin.close (handle);\n}\n\nstatic const char *\ncc_export_description (void *handle)\n{\n  if (subplugin.export_description)\n    return subplugin.export_description (handle);\n  return NULL;\n}\n\nstatic int64_t\ncc_get_size (void *handle)\n{\n  return subplugin.get_size (handle);\n}\n\nstatic int\ncc_can_write (void *handle)\n{\n  if (subplugin.can_write)\n    return subplugin.can_write (handle);\n  else\n    return !!subplugin.pwrite;\n}\n\nstatic int\ncc_can_flush (void *handle)\n{\n  if (subplugin.can_flush)\n    return subplugin.can_flush (handle);\n  else\n    return !!subplugin.flush;\n}\n\nstatic int\ncc_is_rotational (void *handle)\n{\n  if (subplugin.is_rotational)\n    return subplugin.is_rotational (handle);\n  else\n    return 0;\n}\n\nstatic int\ncc_can_trim (void *handle)\n{\n  if (subplugin.can_trim)\n    return subplugin.can_trim (handle);\n  else\n    return !!subplugin.trim;\n}\n\nstatic int\ncc_can_zero (void *handle)\n{\n  if (subplugin.can_zero)\n    return subplugin.can_zero (handle);\n  else\n    return !!subplugin.zero;\n}\n\nstatic int\ncc_can_fast_zero (void *handle)\n{\n  if (subplugin.can_fast_zero)\n    return subplugin.can_fast_zero (handle);\n  else\n    return 0;\n}\n\nstatic int\ncc_can_extents (void *handle)\n{\n  if (subplugin.can_extents)\n    return subplugin.can_extents (handle);\n  else\n    return !!subplugin.extents;\n}\n\nstatic int\ncc_can_fua (void *handle)\n{\n  if (subplugin.can_fua)\n    return subplugin.can_fua (handle);\n  else if (cc_can_flush (handle))\n    return NBDKIT_FUA_EMULATE;\n  else\n    return NBDKIT_FUA_NONE;\n}\n\nstatic int\ncc_can_multi_conn (void *handle)\n{\n  if (subplugin.can_multi_conn)\n    return subplugin.can_multi_conn (handle);\n  else\n    return 0;\n}\n\nstatic int\ncc_can_cache (void *handle)\n{\n  if (subplugin.can_cache)\n    return subplugin.can_cache (handle);\n  else if (subplugin.cache)\n    return NBDKIT_CACHE_NATIVE;\n  else\n    return NBDKIT_CACHE_NONE;\n}\n\nstatic int\ncc_pread (void *handle, void *buf, uint32_t count, uint64_t offset,\n          uint32_t flags)\n{\n  return subplugin.pread (handle, buf, count, offset, flags);\n}\n\nstatic int\ncc_pwrite (void *handle, const void *buf, uint32_t count, uint64_t offset,\n           uint32_t flags)\n{\n  if (subplugin.pwrite)\n    return subplugin.pwrite (handle, buf, count, offset, flags);\n  else {\n    nbdkit_error (\"missing %s callback\", \"pwrite\");\n    errno = EROFS;\n    return -1;\n  }\n}\n\nstatic int\ncc_flush (void *handle, uint32_t flags)\n{\n  if (subplugin.flush)\n    return subplugin.flush (handle, flags);\n  else {\n    nbdkit_error (\"missing %s callback\", \"flush\");\n    errno = EINVAL;\n    return -1;\n  }\n}\n\nstatic int\ncc_trim (void *handle, uint32_t count, uint64_t offset, uint32_t flags)\n{\n  if (subplugin.trim)\n    return subplugin.trim (handle, count, offset, flags);\n  else {\n    nbdkit_error (\"missing %s callback\", \"trim\");\n    errno = EINVAL;\n    return -1;\n  }\n}\n\nstatic int\ncc_zero (void *handle, uint32_t count, uint64_t offset, uint32_t flags)\n{\n  if (subplugin.zero)\n    return subplugin.zero (handle, count, offset, flags);\n  else {\n    /* Inform nbdkit to fall back to pwrite. */\n    nbdkit_error (\"missing %s callback\", \"zero\");\n    errno = EOPNOTSUPP;\n    return -1;\n  }\n}\n\nstatic int\ncc_extents (void *handle, uint32_t count, uint64_t offset,\n            uint32_t flags, struct nbdkit_extents *extents)\n{\n  if (subplugin.extents)\n    return subplugin.extents (handle, count, offset, flags, extents);\n  else {\n    nbdkit_error (\"missing %s callback\", \"extents\");\n    errno = EINVAL;\n    return -1;\n  }\n}\n\nstatic int\ncc_cache (void *handle, uint32_t count, uint64_t offset, uint32_t flags)\n{\n  if (subplugin.cache)\n    return subplugin.cache (handle, count, offset, flags);\n  else\n    /* A plugin may advertise caching but not provide .cache; in that\n     * case, caching is explicitly a no-op.\n     */\n    return 0;\n}\n\nstatic struct nbdkit_plugin plugin = {\n  .name              = \"cc\",\n  .longname          = \"nbdkit C compiler plugin\",\n  .version           = PACKAGE_VERSION,\n\n  /* These are the callbacks that this plugin overrides. */\n  .unload            = cc_unload,\n  .dump_plugin       = cc_dump_plugin,\n  .config            = cc_config,\n  .config_complete   = cc_config_complete,\n  .config_help       = cc_config_help,\n  .thread_model      = cc_thread_model,\n\n  /* And we must provide callbacks for everything else, which are\n   * passed through to the subplugin.\n   */\n  .get_ready          = cc_get_ready,\n  .after_fork         = cc_after_fork,\n\n  .preconnect         = cc_preconnect,\n  .list_exports       = cc_list_exports,\n  .default_export     = cc_default_export,\n  .open               = cc_open,\n  .close              = cc_close,\n\n  .export_description = cc_export_description,\n  .get_size           = cc_get_size,\n  .can_write          = cc_can_write,\n  .can_flush          = cc_can_flush,\n  .is_rotational      = cc_is_rotational,\n  .can_trim           = cc_can_trim,\n  .can_zero           = cc_can_zero,\n  .can_fast_zero      = cc_can_fast_zero,\n  .can_extents        = cc_can_extents,\n  .can_fua            = cc_can_fua,\n  .can_multi_conn     = cc_can_multi_conn,\n  .can_cache          = cc_can_cache,\n\n  .pread              = cc_pread,\n  .pwrite             = cc_pwrite,\n  .flush              = cc_flush,\n  .trim               = cc_trim,\n  .zero               = cc_zero,\n  .extents            = cc_extents,\n  .cache              = cc_cache,\n\n  .errno_is_preserved = 1,\n};\n\nNBDKIT_REGISTER_PLUGIN(plugin)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/tests/old-plugins/i686/Linux/v1.8.4-3-g11f5a90d/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/tests/old-plugins/i686/Linux/v1.0.0/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/tests/old-plugins/i686/Linux/v1.12.8-2-g1e2ccc27/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/tests/old-plugins/i686/Linux/v1.2.8-2-gd2d934df/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/tests/old-plugins/i686/Linux/v1.18.4/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/tests/old-plugins/x86_64/Linux/v1.0.0/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/tests/old-plugins/x86_64/Linux/v1.8.4/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/tests/old-plugins/x86_64/Linux/v1.18.2/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/tests/old-plugins/x86_64/Linux/v1.2.8/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.6-ssehwsix2qn44zr2ygyyhdorcr2x4dnr/spack-src/tests/old-plugins/x86_64/Linux/v1.12.8/nbdkit-file-plugin.so"
    ],
    "total_files": 758
}