{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/ChangeLogP520.txt": "2013-08-02  \n\n  * 6b62d586 man/man1/papi_avail.1 man/man1/papi_clockres.1\n  man/man1/papi_command_line.1...: Update the manpages for a pending 5.2\n  release.  New pages for PAPI[F]_epc and papi_version.\n\n  * 1ae08835 src/linux-common.c: try to properly detect number of sockets  Use\n  totalcpus rather than ncpu in the calculation.  This change fixes things on a\n  Sandybridge-EP machine.  We should maybe find a more robust way to detect\n  this.\n\n  * 79c37fbf .../perf_event_uncore/tests/perf_event_uncore.c\n  .../tests/perf_event_uncore_multiple.c: perf_event_uncore: have tests skip if\n  component disabled rather than fail\n\n  * 638ccf6b .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  change order of uncore detection logic  This way it will report an error of\n  \"no uncore found\" before it reports \"not enough permissions\".  That way a\n  user won't waste time getting permissions only to find out they didn't have\n  an uncore anyway.\n\n  * 30582773 src/components/perf_event/pe_libpfm4_events.c: perf_event: fix\n  papi_native_avail output  A recent change of mine that added stricter error\n  checking for libpfm4 event lookup broke event enumeration on perf_event,\n  specifically papi_native_avail output.  libpfm4 will return an error on some\n  events if no UMASK or improper UMASK is supplied, but papi_native_avail\n  always wants to print the root event and umasks separately.  this temporary\n  fix just ignores libpfm4 umask errors; we might in the future want to\n  properly indicate which events are only valid when certain umasks are\n  present.\n\n  * c7612326 src/utils/native_avail.c: papi_native_avail: fix empty component\n  case  If a component had no events, papi_native_avail would ignore the error\n  returned by PAPI_enum_cmp_event( PAPI_ENUM_FIRST ); and try to print a first\n  event anyway.\n\n  * e1b064eb .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  disable component if no events found  This can happen on older (pre 3.6)\n  kernels with the new libpfm4 that does proper uncore detection.\n\n2013-08-01  \n\n  * 9a54633a src/components/host_micpower/linux-host_micpower.c\n  src/components/infiniband/linux-infiniband.c\n  src/components/nvml/linux-nvml.c...: Components: Use the cuda dlopen fix all\n  cases.  See 4cb76a9b for details, the short version is if you call dlopen\n  when you have been statically linked to libc, it gets ugly.\n\n2013-07-31  \n\n  * dbc44ed1 src/components/perf_event/pe_libpfm4_events.c\n  .../perf_event_uncore/perf_event_uncore.c\n  .../perf_event_uncore/peu_libpfm4_events.c: perf_event libpfm4 events --\n  correctly handle invalid events  It was possible for event names to be\n  obtained from libpfm4 during enumeration that were not valid events.  This\n  usually happens with uncore events, where the uncore is listed as available\n  based on cpuid but when libpfm4 tries to get the uncore type from the kernel\n  finds out it is unsupported.  This change makes this properly fail, instead\n  of just returning \"0\" for all the event paramaters (which is a valid event on\n  x86).  Also make this change in the regular perf_event component, even though\n  it is less likely to happen in practice.\n\n  * 4720890a .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  remove check_permissions() test  It was trying to see if an EventSet was\n  runnable by using the current permissions and adding the PERF_HW_INSTRUCTIONS\n  event. That doesn't really make sense on uncore.  The perf_event component\n  uses this test to try to give errors early, at set_opt() time rather than at\n  the first run time, although in practice now we can probably make intelligent\n  guesses based on the current permission levels.\n\n  * 113d35f7 .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  remove unused kernel workarounds  uncore only works on Linux 3.6 or newer so\n  all of the pre-2.6.35 workarounds aren't necessary.  If someone has\n  backported the uncore support to kernels that old, hopefully they've also\n  backported all the other bugfixes too.\n\n2013-07-25  \n\n  * 4cb76a9b src/components/cuda/linux-cuda.c: Trial fix for the cuda component\n  static libc linking issue.  Weak link against _dl_non_dynamic_init, this\n  appears in my limited testing to be in gnu libc.a and not in the so.  For\n  background, it was reported by Steve Kaufmann that statically linking tools\n  with a PAPI library configured with the CUDA component segfaulted. It appears\n  that calling any of the dynamic linker functions from a static executable is\n  asking for pain.  See Trac bug 182\n  https://icl.cs.utk.edu/trac/papi/ticket/182\n\n2013-07-24  \n\n  * ad47cfb9 src/configure src/configure.in: Add linux-pfm-ia64 to configure \n  I'm not sure if this is enough to fix itanium support but it's a start.\n\n  * 098294c5 src/components/example/tests/example_basic.c\n  .../example/tests/example_multiple_components.c: Fixed tests for example\n  component. Both tests failed due to incorrect check of the components PAPI\n  has been configured with.\n\n2013-07-23  \n\n  * c0c4caf4 src/linux-memory.c src/papi_events.csv: Add initial support for\n  IBM POWER8 processor  Add initial support for IBM POWER8 processor  The IBM\n  POWER8 processor (to be publicly announced at some future date) has some\n  preliminary support in libpfm with a subset of native events.  These\n  POWER8-related libpfm changes were pulled into PAPI on July 3, so further\n  updates in PAPI were required to support this new processor.  This patch adds\n  that required support.  NOTE: Due to the fact that only a subset of native\n  events have been publicised at this point (and pushed into libpfm), not all\n  of the usual PAPI preset events have corresponding native events. The rest of\n  the POWER8 native events will be pushed upstream once they are verified, and\n  then we can flesh out the PAPI preset events.  With this initial POWER8\n  support patch, 5 of the ctests and ftests fail, compared to 3 when PAPI is\n  run on a POWER7. At least one of the failing testcases is due to testing\n  being done on an early POWER8 processor with some known hardware problems. We\n  presume the number of failing tests will decrease once we have GA-level\n  hardware to test on. \n\n2013-07-22  \n\n  * 6c231d1a src/configure: Rerun autoconf  for f4ec143e Correct versioning of\n  libpapi.so\n\n  * f4ec143e src/configure.in: Correct versioning of libpapi.so  The configure\n  for linux always set the soname to libpapi.so.  This causes problems when\n  /sbin/ldconfig tries to update the library information on linux.  The shared\n  library is installed as /lib{64}/libpapi.so.$VERSION, but the shared library\n  has the soname of libpapi.so.  ldconfig makes a symbolic link from\n  /lib/libpapi.so to the actual versioned shared library,\n  /lib/{64}/libpapi.so$VERSION. The configure should get the soname correct to\n  avoid creating this symbolic link.  This patch only addresses the issues for\n  some of the possible platforms and similar patches may be needed for other\n  platforms. \n\n2013-07-19  \n\n  * 92356bbd src/papi.c src/threads.c src/threads.h: Attempt to fix a memory\n  leak in fork2 test.  Fork2 does the following: PAPI_library_init() fork(); / \n    \\ parent   child wait()     PAPI_shutdown()\t->\n  _papi_hwi_shutdown_global_threads() -> foreach(threadinfo we allocated):\n  _papi_hwi_shutdown_thread() PAPI_library_init()  _papi_hwi_shutdown_thread\n  checks who allocated a ThreadInfo entry in the global list, and will only\n  free it if our thread did the allocation.  When threading is not initialized,\n  we fall back to getpid(), now in the child process, the one ThreadInfo item\n  on the list was allocated by our parent, so at shutdown time we don't free\n  this, and thus leak it.  Solution is to add a parameter to\n  _hwi_shutdown_thread to force shutdown even if we didn't allocate it. At\n  _papi_hwi_shutdown_global_threads() time, who cares, its closing time.\n\n  * c04d908e src/cpus.c: Fix a deadlock in _papi_hwi_lookup_cpu().  If cpu_num\n  is not found by _papi_hwi_lookup_cpu(), _papi_hwi_initialize_cpu() calls\n  insert_cpu(), which locks CPUS_LOCK, which was already held by\n  _papi_hwi_lookup_cpu().\n\n  * efac24c4 src/components/micpower/linux-micpower.c: micpower: fix return\n  value check  Also add a time check at stop time.\n\n2013-07-16  \n\n  * b9fd9dd1 src/configure src/configure.in: configure: Fix AIX build \n  perfctr_ppc was not the only system that relied on ppc64_events.h, power*.h,\n  and friends. First run at a fix is -Icomponents/perfctr_ppc for the C and F\n  flags...\n\n  * 46042e68 src/components/micpower/linux-micpower.c: micpower: update some\n  indexing code\n\n2013-07-15  \n\n  * 5220e7d2 INSTALL.txt: INSTALL.txt: typo  --with-arch=, not --arch=; Thanks\n  to Karl Schulz for catching this.\n\n  * 207e0ee0 src/papi_libpfm_events.h: papi_libpfm_events: needs include files\n  for types.  Include papi.h and papi_vector.h for papi_vector_t and\n  PAPI_component_info_t\n\n  * d96c01c7 src/components/perfctr/perfctr.c: perfctr: cleanup a warning \n  Include papi_libpfm_events.h for _papi_libpfm_init() decl.\n\n  * 367e1b38 src/components/perfctr/perfctr-x86.c\n  src/components/perfctr/perfctr.c: perfctr: refactor out setup_x86_presets \n  The setup_presets function served only to call _papi_libpfm_init, so we go\n  the rest of the way and completly remove the function, calling\n  _papi_libpfm_init directly from _perfctr_init_component.\n\n  * 1ba38ce5 src/components/perfctr/perfctr-x86.c: perfctr: cleanup unused\n  parameter warning.  The perfctr code was refactored to only call into the\n  table loading code one time. This had the side effect of removing most of\n  what setup_x86_presets does.\n\n  * 02710ced src/configure src/configure.in: configure: remove debugging\n  message  The compiler detection code had a stray AC_MSG_RESULT.\n\n2013-07-12  \n\n  * 028ce29d src/components/lustre/linux-lustre.c: lustre: use whole directory\n  name as event  Gary Mohr reported that on a trial system he was seeing many\n  events of the form fs3-* which were all chopped to fs3, not helpful.  I've\n  not actually been able to figure out exactly how lustre names things, I've\n  seen it described as  <fs>-<uid>  But have no clue what uid promisses.\n\n2013-07-15  \n\n  * 129d4587 src/papi.c: allow more than one EventSet attach to a CPU at a time\n   This is necessary for perf_event_uncore support, as multiple uncores will\n  want to attach to a CPU.  It looks like this change won't break anything, and\n  the tests pass on my test machines.  I am a bit concerned about\n  cpu->running_eventset, though no one seems to use that value...\n\n  * bcda5ddd src/components/perf_event_uncore/tests/Makefile\n  .../tests/perf_event_uncore_nogran.c: perf_event_uncore: remove\n  perf_event_uncore_nogran test  It is unnecessary after recent changes to the\n  uncore component.\n\n  * b1b9f654 src/components/perf_event_uncore/tests/Makefile\n  .../tests/perf_event_uncore_cbox.c: perf_event_uncore: add\n  perf_event_uncore_cbox test  This adds a non-trivial test of the CBOX\n  uncores. It turned up various bugs in the PAPI uncore implementation.\n\n  * df1b6453 src/linux-common.c: linux: properly set hwinfo->socket value  It\n  was being derived from hwinfo->ncpu but being calculated before hwinfo->ncpu\n  was set.\n\n2013-07-13  \n\n  * ee537448 .../perf_event_uncore/perf_event_uncore.c\n  .../perf_event_uncore/peu_libpfm4_events.c\n  .../perf_event_uncore/peu_libpfm4_events.h: perf_event_uncore: properly\n  report number of total counters available\n\n  * 7eb93917 src/components/perf_event/Rules.perf_event\n  src/components/perf_event/pe_libpfm4_events.c\n  src/components/perf_event/pe_libpfm4_events.h...:\n  perf_event/perf_event_uncore/libpfm4 -- rearrange files  Give perf_event and\n  perf_event_uncore copies of papi_libpfm4_events to work with, as they will\n  have different needs for the code.  Get rid of the perf_event_lib stuff.  It\n  was a hack to begin with and in the end not much code will be shared.  Maybe\n  we can re-share things once uncore support is complete.\n\n2013-07-12  \n\n  * 6810af2a src/components/perf_event/perf_event.c\n  .../perf_event_uncore/perf_event_uncore.c src/papi_libpfm4_events.c...:\n  papi_libpfm4: properly call pfm_terminate() in papi_libpfm4_shutdown\n\n  * 010497f4 src/components/perf_event/perf_event.c\n  .../perf_event_uncore/perf_event_uncore.c src/papi_libpfm4_events.c...: split\n  papi_libpfm4_init()  split this function because the perf_event_uncore()\n  component is going to want to initialize things differently than plain\n  perf_event\n\n  * d9023411 src/components/perf_event/perf_event.c: perf_event: on old kernels\n  if SW Multiplex enabled, then report proper number of MPX counters available \n  it may be different than the amount HW supports\n\n  * 7595a840 src/components/perf_event/perf_event_lib.c: perf_event: use\n  PERF_IOC_FLAG_GROUP when resetting events  This ioctl argument specifies to\n  reset all events in a group, so we don't have to iterate.  This argument\n  dates back to the introduction of perf_event and it makes the code a bit\n  cleaner.\n\n  * f220fd19 src/ctests/Makefile src/ctests/reset_multiplex.c: Add\n  reset_multiplex.c  PAPI_reset() potentially exercises different paths when\n  resetting normal and multiplexed eventsets, so make sure we test both.\n\n  * f784a489 src/components/lustre/linux-lustre.c: lustre: botched a conflict\n  resolution  properly do error checking on addCounter()\n\n  * c1350fc8 src/components/perf_event/perf_event.c\n  src/components/perf_event/perf_event_lib.c\n  src/components/perf_event/perf_event_lib.h: perf_event: move overflow and\n  profile code out of common lib  the perf_event_uncore component doesn't need\n  it\n\n  * 8dde03fc .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  remove profiling and overflow code  perf_event doesn't support sampling or\n  overflow on uncore\n\n  * 30d23636 src/components/lustre/linux-lustre.c: lustre component: Several\n  fixes  1. create a dynamic native events table in pathalogical cases, lustre\n  can have lots of events.  2. resolve some warnings change signature of\n  init_component properly error check addCounter  3. Add a preprocessor flag to\n  fake interface Set LIBCFLAGS=\"-DFAKE_LUSTRE\"\n\n  * 7ef51566 .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  remove dispatch timer call  perf_event  doesn't support sampling on uncore\n  events\n\n  * 667661c6 src/components/perf_event/perf_event.c\n  src/components/perf_event/perf_event_lib.c\n  src/components/perf_event/perf_event_lib.h: perf_event: move rdpmc detection\n  back into perf_event.c  It was in the perf_event_lib but uncore won't use the\n  feature.\n\n  * d46f01e1 .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  check the paranoid file  Disable the component if paranoid isn't 0 or lower,\n  and we're not running as root.\n\n  * e4ec67d1 src/components/perf_event/perf_event.c: perf_event and paranoid\n  level 2  If paranoid level 2 (no kernel events) was set we were removing\n  PAPI_DOM_KERNEL from the allowable domains  We were doing this even if the\n  user was root.  This code checks for uid 0 and overrides the restriction.\n\n  * c5501081 src/components/perf_event/perf_event_lib.c\n  src/components/perf_event/perf_event_lib.h: rename sys_perf_event_open2()\n  call back to sys_perf_event_open()  This was changed when merging code to\n  avoid a conflict but wasn't renamed back whe the conflict was fixed.\n\n2013-07-11  \n\n  * e263ea60 src/configure src/configure.in: configure: libpfm selection logic\n  rework  If configure detected perfctr it would force libpfm3 to be used, even\n  with --with-perf_events, now force libpfm4 if perf_events is requested.\n\n2013-07-10  \n\n  * 7a3ce030 .../host_micpower/Makefile.host_micpower.in\n  src/components/host_micpower/Rules.host_micpower\n  src/components/host_micpower/configure...: Component: host_micpower  This is\n  a component that exports power information for Intel Xeon Phi cards (MIC).\n  The component makes use of the MicAccessAPI distributed with the Intel\n  Manycore Platform Software Stack.\n  \n  k-mpss)\n\n  * 9d9bd9c2 src/ctests/shlib.c: Fwd: Re: [Ptools-perfapi] ctests/shlib FAILED \n  Should have sent this to the papi devel list. -Will  -------- Original\n  Message -------- Subject: Re: [Ptools-perfapi] ctests/shlib FAILED Date: Tue,\n  09 Jul 2013 23:20:10 -0400 From: William Cohen <wcohen@redhat.com> To:\n  ptools-perfapi@eecs.utk.edu  On 03/09/2012 03:40 PM, William Cohen wrote: > I\n  was looking through the test results and found that ctests/shlib FAILED on\n  all the machines I tested on because libm shared library is already linked\n  in. There is no difference in the number of shared libraries before and after\n  the dlopen. The test ctests/shlib fails as a reult of this. > > -Will >\n  _______________________________________________ > Ptools-perfapi mailing list\n  > Ptools-perfapi@eecs.utk.edu >\n  http://lists.eecs.utk.edu/mailman/listinfo/ptools-perfapi >  I did some more\n  investigation of this problem today.  I found that the lmsensor component\n  implicitly pulls in the libm.  As an alternative, I wrote the attached patch\n  that uses setkey() and encrypt() in libcrypt.so instead.  It works on various\n  linux machines, but I do not know whether it is going to work on other OS. \n  -Will  >From c53c97e1de2d1c7dc0bca64d1906287ff73343c6 Mon Sep 17 00:00:00\n  2001 From: William Cohen <wcohen@redhat.com> Date: Tue, 9 Jul 2013 22:37:27\n  -0400 Subject: [PATCH] Avoid using libm.so for ctests/shlib because of\n  implicit use in some components  The lmsensors component can implicitly pull\n  in libm.so into the executable.  Unfortunately, the ctests/shlib test expects\n  that libm.so is not loaded and will fail because there is no change in the\n  count of shared libraries.  The patch uses libcrypt.so library setkey and\n  encrypt functions to test PAPI_get_shared_lib_info( ) instead of libm.so\n  library pow function. \n\n2013-07-09  \n\n  * bdc9b34b .../tests/perf_event_amd_northbridge.c:\n  Perf_event_amd_northbridge_test: Use buffer event_name instead of\n  uncore_event  The variable uncore_event is initialized to NULL and is never\n  changed during execution of the test. PAPI_add_named_event fails and the\n  event set cannot be started. The correct event name is stored in event_name,\n  replacing all occurrences of uncore_event with event_name therefore fixes the\n  problem metioned above.\n\n2013-07-08  \n\n  * a1678388 src/components/micpower/linux-micpower.c: micpower:  Fix output in\n  native_avail and component_avail. It uses cmp_info.name, not .short_name? \n  Native Events in Component: mic-power Name:   mic-power              \n  Component for reading power on Intel Xeon Phi (MIC)  Should both match what\n  is prepended to event names, so change .name from mic-power to micpower.\n\n  * e0582f2d src/components/micpower/linux-micpower.c: Micpower: fix a typo \n  subsystem, not sybsystem...\n\n  * c7b357ec INSTALL.txt: INSTALL.txt: update instructions for MIC.\n\n  * 34a1124e src/components/perf_event_uncore/tests/Makefile\n  .../tests/perf_event_amd_northbridge.c: Add perf_event_amd_northbridge test \n  The test should show how to write a program using AMD fam15h NB with a 3.9\n  kernel.  Once libpfm4 gets updated we can see if it's possible to also have\n  the test properly run on 3.10 kernels (in that case the regular\n  perf_event_uncore test should work w/o changes)\n\n  * 41b6507c .../perf_event_uncore/tests/perf_event_uncore.c\n  .../tests/perf_event_uncore_multiple.c: Make perf_event_uncore tests use\n  PAPI_get_component_index()  They were open-coding the component name search\n  for no good reason.\n\n2013-07-05  \n\n  * abf38945 src/papi_libpfm4_events.c: avoid having a \"default\" PMU for the\n  uncore component  on the main CPU component we have a \"default\" PMU where you\n  can leave out the PMU part of the event name.  This is unnecessary and\n  sometimes confusing on uncore, so always print the full event name if it's an\n  uncore PMU.\n\n  * b9fe5c3e .../perf_event_uncore/tests/perf_event_uncore.c\n  .../tests/perf_event_uncore_multiple.c: Update perf_event_uncore tests to\n  properly fail if they don't have enough permissions\n\n  * 32ae1686 .../perf_event_uncore/tests/perf_event_uncore.c:\n  perf_event_uncore_test : properly use uncore component  The sample code was\n  still hardcoding to component \"0\" which shouldn't have worked.  Thanks to\n  Claris Castillo for pointing out this problem.\n\n  * 59e73b51 src/papi_libpfm4_events.c: have _papi_libpfm4_ntv_name_to_code\n  properly check pmu_type  With the existing code, uncore events were being\n  found by the perf_event component even when that component has uncore events\n  distabled.\n\n2013-07-03  \n\n  * a01394eb .../tests/perf_event_uncore_lib.c: perf_event_uncore: fix ivb\n  event in uncore test  Now that libpfm4 officially supports plain ivb uncore,\n  make sure the test event we were using matches what libpfm4 supports.\n\n2013-07-01  \n\n  * f10342a8 src/utils/cost.c: Clean up option handling in papi_cost  The\n  papi_cost used strstr to seach for the substring that matched the option. \n  this is pretty inexact.  Made sure that the options matched exactly and the\n  option argments for -b and -t were greater than 0. Also make papi_cost print\n  out the help if there was an option that it didn't understand. \n\n  * b5adc561 src/utils/native_avail.c: Clean up option handling for\n  papi_native_avail  Corrected the help to reflect the name of the option\n  \"--noumasks\". Print error message if the \"-i\", \"-e\", and \"-x\" option\n  arguments are invalid. Avoid using strstr() for \"-h\", use strcmp instead.\n  Also check for \"--help\" option. \n\n  * 8933be9b src/utils/decode.c: Clean up option handling in papi_decode \n  papi_decode used strstr() to match options; this can lead to inexact matchs.\n  The code should used strcmp instead.  Make sure command name is not processed\n  as an option.  Also print help iformation is some argument is not understood.\n\n  * d94ac43a src/utils/component.c: Improve option matching in papi_component\n  and add \"--help\" option \n\n  * bb63fe5c src/utils/command_line.c: Add options to papi_command_line man\n  page and improve opt handling  Add options mention in the -h to the man page.\n   Also improve the matching of the options. \n\n  * 09059c82 doc/Makefile src/utils/version.c: Add information for papi_version\n  to be complete \n\n  * 4f2eee8c src/configure src/configure.in: add a --disable-perf-event-uncore\n  option to configure\n\n2013-06-29  \n\n  * 901c5cc2 src/components/perf_event/perf_event.c\n  src/components/perf_event/perf_event_lib.c\n  .../perf_event_uncore/perf_event_uncore.c...: remove syscalls.h  it's no\n  longer needed\n\n  * 4d7e3666 src/Rules.perfmon2 src/components/perfmon2/Rules.perfmon2\n  src/components/perfmon2/perfmon.c...: move perfmon modules to their own\n  component directory\n\n  * a7e9c5f1 src/Rules.perfctr src/Rules.perfctr-pfm\n  src/components/perfctr/Rules.perfctr...: move perfctr files to\n  components/perfctr directory  verified that perfctr-x86 still builds and\n  works  perfctr_ppc has all the files to build, but it doesn't work. It looks\n  like no one has tried to build perfctr-ppc for a very very long time.\n\n2013-06-27  \n\n  * e9dec1fd src/ctests/hl_rates.c src/papi.h src/papi_fwrappers.c...: debugged\n  versions of these files\n\n  * e282034e src/utils/native_avail.c: native_avail: Fix parse_unit_mask code \n  Reported by Steve Kaufmann -------------------------- I noticed while\n  developing a new component that the output from papi_native_avail was\n  incorrectly presented for the component. I believe this is because the \":::\"\n  prefix is not being taken into account, so the base event name is interpreted\n  as a unit mask and is prepend with a : before each legitimate unit mask\n  associated with the event. I think this is just now happening because mine is\n  the first component that has unit masks. I have include a fix below. The\n  output of the unit masks by papi_native_avail now appears correctly for my\n  component.  Thanks, Steve\n\n2013-06-26  \n\n  * ff096786 src/ctests/fork2.c: fork2: Return fork2 test to its old\n  functionality  Once upon a time fork2 did: PAPI_library_init() \u2026 if (\n  fork() == 0) PAPI_shutdown() PAPI_library_init() \u2026\n\n2013-06-25  \n\n  * 978d0d3d src/examples/PAPI_add_remove_event.c src/papi.c: Modify\n  PAPI_list_events functionality to match documentation. You can now pass in a\n  NULL event array and a zero count to get back the valid number of events.\n  This can then be used to allocate the array and retrieve the exact number of\n  events. Thanks to Nils Smeds and Alain Miniussi for pointing this out.\n\n  * 13c52402 src/examples/PAPI_add_remove_event.c src/papi.c: Modify\n  PAPI_list_events functionality to match documentation. You can now pass in a\n  NULL event array and a zero count to get back the valid number of events.\n  This can then be used to allocate the array and retrieve the exact number of\n  events. Thanks to Nils Smeds and Alain Miniussi for pointing this out.\n\n  * 656e703e src/ctests/zero_fork.c: zero_fork ctest : make documentation match\n  code\n\n  * 96aad0c7 src/ctests/forkexec.c: forkexec ctest : make comments match code\n\n  * b7c70953 src/ctests/forkexec4.c: forkexec4 ctest : make comments match the\n  code\n\n  * 7ffb0245 src/ctests/forkexec3.c: forkexec3 ctest : make documentation match\n  code\n\n  * 55ea846c src/ctests/forkexec2.c: forkexec2 ctest: have comments match what\n  source does\n\n  * 7a601e2a src/ctests/Makefile src/ctests/fork2.c: fork2 ctest: remove; was\n  an exact duplicate of fork\n\n  * 9deff49b src/ctests/fork.c: fork ctest: make comments match what file\n  actually does\n\n2013-06-24  \n\n  * 2770d2c5 src/components/perf_event/perf_event_lib.c: perf_event: fix\n  failure on ARM due to domain settings  forgot to git add the perf_event_lib.c\n  file :(\n\n  * bf7c4c50 src/components/perf_event/perf_event.c\n  src/components/perf_event/perf_event_lib.h: perf_event: fix failure on ARM\n  due to domain settings  On Cortex A8 and A9 it's not possible to set\n  exclude_kernel (hardware does not support it).  Make sure the rdpmc detection\n  code doesn't try to set exclude_kernel.\n\n2013-06-18  \n\n  * 2b1433d8 src/ctests/all_native_events.c src/ctests/get_event_component.c:\n  ctests: Skip calling into disabled components.  This patch fixes a problem\n  that was causing two test cases to abort when they were run on a system which\n  has disabled components.  Code was added to check if the component is\n  disabled and just go to the next component in the list when the check is\n  true.  This prevents calls to code in components which may abort because the\n  component was unable to initialize itself correctly.  Thanks to Gary Mohr and\n  Chuck LaCasse from Bull for reporting.\n\n2013-06-14  \n\n  * 1872453c src/testlib/do_loops.c: testlib: don't change the iter count  The\n  first argument to do_misses is an iteration count, for some reason the code\n  was dividing this in half before doing work. Most places that call do_misses\n  call it as do_misses ( 1, ...)  void do_misses( int n, int bytes ) { {...} n\n  = n / 2; for ( j = 0; j < n; j++ ) {  1/2 == 0; so our do_misses call was\n  usually not.  Thanks Nils Smeds for reporting.\n\n2013-06-12  \n\n  * c113e5b6 src/components/infiniband/Makefile.infiniband.in\n  src/components/infiniband/Rules.infiniband\n  src/components/infiniband/configure...: Infiniband component: switch over to\n  weak linking  Thnaks to Gary Mohr for the patch.\n  ---------------------------------- The infiniband component needs include\n  files and libraries from both the infiniband ibmad and ibumad packages.  When\n  these packages are installed on a system, both packages normally install\n  their files in the same place (includes in /usr/include/infiniband and\n  libraries in /usr/lib64).  The current component configure script allows you\n  to provide a single include path and a single library path which gets used to\n  access files from both packages.  If these two packages have different\n  install prefixes (or you are trying to build from install images of each\n  package which are not located under the same directory) then the configure\n  script fails because it can not find all the files it needs.  These changes\n  modify the configure script to replace the include and library dir's with an\n  ibmad_dir and ibumad_dir and then uses the correct packages directory when\n  looking for includes and libraries from that package.  This makes it work\n  like the cuda and nvml components with respect to configuring how to find\n  files from a package the component depends on.  There are also changes in\n  this patch file to remove an unneeded variable in the dlopen code to resolve\n  some defects reported by coverity.\n\n2013-06-11  \n\n  * d5be5643 src/components/rapl/tests/rapl_basic.c: rapl tests: make the error\n  messages a little more verbose\n\n  * 0c9f1a8c src/run_tests_exclude.txt src/run_tests_exclude_cuda.txt:\n  run_tests_exclude files: Exclude a template file \n  ------------------------------------------- It also adds the cpi.pbs file to\n  the list of files to excluded when the tests are run. This file is just a\n  template and attempts to run it hang the run_tests script on our systems.\n  -------------------------------------------\n\n  * 0a063619 src/run_tests.sh: run_tests.sh: fix exclude check.  The script\n  failed to remove .cu files, this patch fixes the check. Thanks Gary Mohr for\n  reporting/patching.\n\n2013-06-10  \n\n  * 87399477 src/components/cuda/linux-cuda.c: cuda component: Address a\n  coverity issue  The library linking code saved return values in a local var\n  but never used them. Thanks to Gary Mohr for submitting this patch.\n\n  * 99b5b685 src/components/coretemp/tests/coretemp_basic.c: coretemp_basic:\n  update test to properly enumerate events  The code was old and was searching\n  the entire native event list for ones that started with \"hwmon\".  This\n  updates the test to first find the coretemp component, then enumerate all\n  events contained within.\n\n  * b5c0795b src/components/rapl/tests/rapl_overflow.c: rapl component: address\n  potential looping issue in test.  A rapl component test has a do/while which\n  only exited when PAPI_add_named_event returned 0 ( and only 0; the PAPI_E*\n  error codes would not terminate a while( retval ) loop), this felt fragile,\n  minimal checks are now inplace.\n\n  * 4e9484a5 src/components/rapl/tests/rapl_overflow.c: rapl components:\n  coverity fixes  Reported/patched by Gary Mohr -----------------------------\n  The rapl component also has 1 defect in a test case.  The complaint is that\n  there is code that can never be executed.  But this one is not as clear, it\n  says that you can not exit the do/while loop that preceeds a test of retval\n  until retval=0 which means the test can never be true.  The patch I am\n  providing is to again remove the if test and its contents.  But I am\n  concerned that the do/while loop preceeding the test could result in a hard\n  loop that would hang the test case forever.  It seems to me like something\n  should also be done to insure the loop will exit at some point.  Here is a\n  patch that provides at least part of the fix: -----------------------------\n\n  * 0a533810 src/components/net/tests/net_values_by_name.c: net components:\n  coverity fixes  Reported/patched by Gary Mohr -----------------------------\n  The net component has one defect in one of the test cases.  The complaint is\n  that there is code that can never be executed.  There is a test to see if\n  event_count == 0 which can never be true at that place in the code.  So I\n  removed the if statement and its contents.  Here is the patch:\n  -----------------------------\n\n2013-06-07  \n\n  * b784b063 src/components/nvml/Rules.nvml src/components/nvml/configure\n  src/components/nvml/configure.in...: nvml: Apply Gary Mohr's dlopen patch. \n  Move the nvml component over to using the dlopen and weak linking\n  infrastructure of the cuda component. Thanks, Gary.\n\n  * d6505b76 src/components/rapl/utils/rapl_plot.c: rapl: update the rapl_plot\n  utility  Get the event names by enumerating the ones available with the RAPL\n  component rather than having a hard-coded list.\n\n  * 2094c5b1 src/components/rapl/linux-rapl.c: rapl: add better error messages\n  on component init failure\n\n  * d0e668fb src/ctests/Makefile src/ctests/high-level.c\n  src/ctests/hl_rates.c...: First round of changes to implement a PAPI high\n  level event per cycle call. Untested.\n\n2013-06-05  \n\n  * 63074f82 src/components/rapl/linux-rapl.c: rapl: Add Ivb-EP support  The\n  Intel docs are spotty on what is actually supported. They state: 14.7.2 RAPL\n  Domains and Platform Specificity The specific RAPL domains available in a\n  platform varies across product segments. Platforms targeting client segment\n  support the following RAPL domain hierarchy: * Package * Two power planes:\n  PP0 and PP1 (PP1 may reflect to uncore devices) Platforms targeting server\n  segment support the following RAPL domain hierarchy: * Package * Power plane:\n  PP0 * DRAM\n\n2013-05-31  \n\n  * 31b4702d src/cpus.c: cpus.c: Don't run init_thread/shutdown_thread for\n  disabled components.\n\n2013-05-29  \n\n  * c48087d2 ChangeLogP511.txt RELEASENOTES.txt: Grab the updated ChangeLog\n  from 5.1.1  Create a ChangeLog and update RELEASENOTES for a 5.1.1 release.\n\n2013-05-24  \n\n  * d1c8769e src/components/perf_event/tests/Makefile\n  src/components/perf_event/tests/event_name_lib.c\n  .../perf_event/tests/perf_event_user_kernel.c: Add perf_event user/kernel\n  domain test  This will be useful if/when we start handling domains properly.\n\n  * 89e1aeba src/components/perf_event/tests/Makefile\n  src/components/perf_event/tests/event_name_lib.c\n  src/components/perf_event/tests/event_name_lib.h...: Add perf_event offcore\n  response test  Does a quick check to see if offcore response events are\n  working.\n\n  * bda86616 .../perf_event_uncore/perf_event_uncore.c\n  src/ctests/get_event_component.c src/papi_internal.c: Some more ctest fixes\n  involving disabled components.  We enforce disabled components sometime in\n  the PAPI routines and sometimes in the components themselves.  A bit\n  confusing.  It is tough with perf_event and perf_event_uncore because we\n  share libpfm4 by both, so the naming library for perf_event_uncore will be\n  active even if the component is disabled, which can cause some confusing\n  results if your test code ignores PAPI_ENOCMP error messages and accesses a\n  disabled component anyway.  This at least fixes our test cases, we might have\n  to revisit this later.\n\n  * b596621e doc/Doxyfile-common papi.spec src/Makefile.in...: Bump version\n  numbers  Call this 5.2.0.0 simple because its greater than (and some\n  components are completely incompatible with) 5.1.1\n\n  * eb77a91e .../perf_event_uncore/perf_event_uncore.c src/papi.c: Disallow\n  enumerating events on disabled components.  This was causing segfaults on\n  tests where enumeration was trying to enumerate uncore events on machines w/o\n  uncores.\n\n  * 4e991a8a .../perf_event/tests/perf_event_system_wide.c:\n  perf_event_system_wide: SKIP instead of FAIL if we don't have proper\n  permissions\n\n  * 7654bb1f src/Makefile.inc src/components/perf_event/tests/Makefile\n  .../perf_event/tests/perf_event_system_wide.c...: move the perf_event\n  specific tests to be with their component  This means the perf_event tests\n  will only be run if perf_event is enabled\n\n  * d82e343f src/ctests/perf_event_uncore_multiple.c:\n  ctests/perf_event_uncore_multiple: Improve this test a bit\n\n  * b1a594bf src/perf_events.c src/sys_perf_event_open.c: Remove the no-longer\n  needed perf_events files  Now we use the versions in the\n  components/perf_event directory\n\n  * a9a277f3 src/Makefile.in src/Makefile.inc src/configure...: Split up\n  CPUCOMPONENT configure variable  Now it is CPUCOMPONENT_NAME CPUCOMPONENT_C\n  CPUCOMPONENT_OBJ This allows having setups with no CPUCOMPONENT set\n  (perf_event used as a component) while keeping backward compatible with\n  non-component CPU components.  This has been tested on perf_event and\n  perfctr.  It might break other architectures, so test if you can.\n\n  * 69e29526 src/configure src/configure.in: configure: have --with-components\n  append comonents to existing value  This allows configure to earlier set the\n  components value to include \"perf_event\" if detected and then later append\n  the values passed in with --with-components\n\n  * 9d28df4c src/components/perf_event/Rules.perf_event\n  src/components/perf_event/perf_event.c\n  src/components/perf_event/perf_event_lib.c...: add perf_event and\n  perf_event_uncore components  This adds perf_event as a standalone component.\n  Currently it is not compiled or built, some changes need to be made to the\n  build system before this will work.\n\n2013-05-21  \n\n  * ea996661 src/components/cuda/linux-cuda.c: eliminate warnings of unused\n  vars\n\n  * 691bf114 src/components/cuda/linux-cuda.c: eliminate warnings of unused\n  vars\n\n  * 221bfdab src/components/cuda/linux-cuda.c\n  src/components/cuda/tests/HelloWorld.cu: Problem with cleanup_eventset():\n  after destroying the CUDA eventset, update_control_state() is called again\n  which operates on the already destroyed eventset.\n\n2013-05-17  \n\n  * 84925f50 src/components/cuda/linux-cuda.c: When adding multiple CUDA events\n  to an event set, PAPI_add_event() error 14 (CUPTI_ERROR_NOT_COMPATIBLE) is\n  being raised from the CUPTI library.  Turns out that the CUDA update control\n  state wasn't cleaning the event set up properly before adding new events.\n  It's fixed now.\n\n  * 2337aa3a src/perf_events.c: perf_event: allow running with\n  perf_event_paranoid is 2  perf_event_paranoid set to 2 means allow user\n  monitoring only (no kernel domain).  The code before this mistakenly disabled\n  all events in this case. Also set the allowed domains to exclude\n  PAPI_DOM_KERNEL.\n\n2013-05-16  \n\n  * 617d9fbb src/papi_events.csv: papi_events.csv Revert a little mishap in\n  adding ivbep support  Somehow the contents of papi_hl.c ended up in the\n  events file.\n\n  * 2aff4596 src/papi_events.csv: Add identifier for ivb_ep\n\n  * 1810ddf9 src/papi_libpfm4_events.c src/papi_libpfm4_events.h\n  src/perf_events.c: papi_libpfm4_events: allow specifying\n  core/uncore/os_generic PMUs  This allows you to specify you only want your\n  perf_event/libpfm4 based component to only export the PMU types you want. \n  Now we can have an uncore-only component.\n\n  * 6554f3f0 src/papi_libpfm4_events.c: papi_libpfm4_events.c: only enable\n  presets for component 0  If we have multiple events using libpfm4, we only\n  want to load the presets if it is component 0.\n\n  * 6a4a4594 src/papi.c: PAPI_get_component_index() was matching names\n  improperly  For example, it was matching perf_event and perf_event_uncore as\n  the same component.\n\n  * 1b94e157 src/papi_hl.c: papi_hl.c : fix IPC calculation  I broke it a while\n  back while trying to clear out use of MHz.  The code was uncommented and very\n  confusing.  It is slightly better now.\n\n  * 92d4552e src/papi_libpfm4_events.c src/papi_libpfm4_events.h\n  src/perf_events.c: papi_libpfm4_events: code changes to allow multiple\n  component access  the PAPI libpfm4 code has been modified to allow multiple\n  users at once.  This will allow multiple components to use libpfm4, for\n  example a CPU component and an uncore component.\n\n  * 7902b30e src/cpus.c: cpus: fix debug compile  I always forget to compile\n  with --with-debug and miss changes in the DEBUG statements.\n\n2013-05-15  \n\n  * 7ddc05ff src/cpus.c src/cpus.h: cpus.c: Add reference count to cpu\n  structure  It is possible to have multiple eventsets all attached to the same\n  CPU, as long as only one eventset is running at a time.  At EventSet cleanup,\n  PAPI would free the CpuInfo_t structure even if other EventSets were still\n  using it.  This patch adds a reference count to the structure and only frees\n  it after the last user is cleaned up.  I also fixed a few locking bugs,\n  hopefully I didn't introduce any new ones.\n\n  * 6a61f9a2 src/cpus.c: more cleanup of the cpus.c file  mostly formatting and\n  added comments.\n\n  * 710d269f src/cpus.c src/cpus.h src/papi.c...: cleanup cpus.h  It had a lot\n  of extraneous stuff in it.  Also make sure it only gets included in files\n  that need it.\n\n  * 422226c9 src/papi.c: papi.c: add some extra debug messages\n\n  * b1297058 src/cpus.c: Clean up cpus.c a bit  Tracking down a segfault in the\n  cpu attach cleanup code.\n\n  * 7b6023cf src/ctests/perf_event_system_wide.c:\n  ctests/perf_event_system_wide: much improved output  It segfaults at the end\n  though, unclear if this is a bug in the test or a bug in PAPI.  Will\n  investigate.\n\n  * 38397aa3 src/components/cuda/configure src/components/cuda/configure.in\n  src/components/cuda/linux-cuda.c...: Cuda component: Update library search\n  path  From Gary Mohr: It turns out that with the changes I gave you the path\n  to the libcuda.so library is still hard coded to /usr/lib64.  This assumes\n  that the NVIDIA-Linux package is installed on the system where the build is\n  being done.  In Bull's case (and probably other users also) this is not\n  always the case.  To add the flexibility we need, I have added a new\n  configure argument to the cuda configure script.  The new argument is\n  \"--with-cudrv_dir\" and it allows the user to specify where the cuda driver\n  package (ie: NVIDIA-Linux) to be used for the build can be found.  This new\n  argument is optional and if not provided a value of \"/usr\" will be used. This\n  allows existing configure calls to continue to work like before.\n\n  * f8873d1c src/ctests/perf_event_system_wide.c:\n  ctests/perf_event_system_wide: clean up the output a lot  Still working on\n  understanding it.\n\n  * ebf20589 src/ctests/perf_event_system_wide.c: perf_event_system_wide:\n  testing various DOMAIN and GRANULARITY settings  pushing the limits of\n  PAPI/perf_event trying to see why system-wide measurement doesn't work.\n\n2013-05-14  \n\n  * 0c1ef3f5 src/components/cuda/linux-cuda.c: CUDA component: Update\n  description field  Also removes a strcpy in the init code, which overwrote\n  the name field. Thanks to Gary Mohr\n\n  * 474fc00e src/ctests/perf_event_uncore_lib.c: Add AMD fam15h northbridge\n  event to ctests/perf_event_uncore_lib.c\n\n2013-05-13  \n\n  * cf56cdac src/perf_events.c: perf_event component: update error returns \n  This passes more error return values back to PAPI. Before this change a lot\n  of places were hardcoded to PAPI_EPERM even if sys_perf_event_open() was\n  reporting a different error.\n\n  * c824471b src/ctests/Makefile src/ctests/perf_event_system_wide.c\n  src/ctests/perf_event_uncore.c...: Update the perf_event specific tests. \n  This adds a few more uncore tests, which are currently showing some bugs in\n  the implementation.  The tests all need root permissions to run, so should\n  default to \"SKIPPED\" for most users.\n\n2013-05-08  \n\n  * e0204914 src/configure src/configure.in: Force the use of pthread_mutexes\n  on ARM  This lets the system libraries worry about the best way to define\n  mutexes, rather than trying to hand-code in assembly around all of the\n  various issues there are with atomic instructions in the ARM architecture. \n  It might make sense to enable this for *all* Linux architectures, but for now\n  just do it for ARM.\n\n  * f21b1b27 src/linux-lock.h: Commit 59d3d7584b2925bd05b4b5d0f4fe89666eb8494a\n  removed the definition of mb().  mb() was defined as rmb().  This just\n  corrects it back.   (Note from VMW -- this fixes some things, but ARM still\n  won't build on a Cortex A9 pandaboard due to the use of the \"swp\"\n  instruction. Proper fix is probably to enforce posix-mutexes on ARM)\n\n2013-05-06  \n\n  * 913f0795 src/components/nvml/configure src/components/nvml/configure.in:\n  NVML: Update wording for configure options.  Thanks for pointing out the\n  ambigous wording, Heike.\n\n  * 81a86c2b src/components/infiniband/Rules.infiniband\n  src/components/infiniband/linux-infiniband.c\n  src/components/infiniband/tests/Makefile: Infiniband component: use\n  dlopen/dlsym for symbols  Apply Gary Mohr's patch to switch the infiniband\n  component over to dl* with the same motivations as the cuda component.\n\n2013-05-02  \n\n  * 2e6bcb2a src/utils/native_avail.c: Add two command line switches: -i\n  EVENTSTR includes only events whose names contain EVENTSTR; -x EVENTSTR\n  excludes all events whose names contain EVENTSTR.  These two switches can be\n  combined, but only one string per switch can be used. This allows you to, for\n  example, filter events by component name, or eliminate all uncore events on\n  Sandy Bridge\u2026\n\n2013-05-01  \n\n  * 3163cc83 src/ctests/perf_event_uncore.c: ctests/perf_event_uncore: add\n  IvyBridge support  this needs an updated libpfm4 to work\n\n2013-04-30  \n\n  * 55c89673 src/examples/add_event/Papi_add_env_event.c\n  src/examples/overflow_pthreads.c: Examples: Missed two instances of %x printf\n  formating.\n\n2013-04-29  \n\n  * b3c5bd47 src/components/appio/tests/appio_list_events.c\n  src/components/appio/tests/appio_values_by_code.c\n  src/components/appio/tests/appio_values_by_name.c...: Address TRAC 174: Let\n  printf do the formatting  https://icl.cs.utk.edu/trac/papi/ticket/174 174:\n  PAPI's debuggin/info output should use %# conversions for octal and hex\n  ------------------------+-------------------- Reporter:  sbk@\u2026        |    \n   Owner: Type:  enhancement  |     Status:  new Priority:  normal       | \n  Component:  All Version:  HEAD         |   Severity:  normal Keywords:       \n         | ------------------------+-------------------- Email sent to James\n  Ralph:  Seeing your latest change reminded me: Anytime there is a value\n  issued in hex or octal the \"%#\" conversion should be used so the value is\n  always preceded with a \"0\" for octal or a \"0x\" for hex. Otherwise when a\n  value is printed one can not tell the base it is in (one shouldn't have to\n  rely on internal knowledge of the code or the context to tell). For variables\n  that are pointers the \"%p\" conversion can be used (this will always use an\n  hex syntax).  It would be nice to apply this to all PAPI print statements in\n  their entirety.\n\n2013-04-25  \n\n  * 87ec9286 src/components/vmware/Rules.vmware: Rules.vmware: Use $(LDL) no\n  -ldl  Minor cleanup, but configure sets it, so why not use it.\n\n2013-04-26  \n\n  * 8dddd587 src/papi_hl.c: papi_hl: Use PAPI_get_virt_usec() for process time \n  The code was using cycles / MHz which is not guaranteed to work on modern\n  machines.  It also was sometimes using (instructions / estimated IPC) / MHz\n  which hopefully isn't necessary for any machine PAPI currently supports. \n  Instead use PAPI_get_virt_usec() which should give the right value.\n\n2013-04-25  \n\n  * 9dd36088 src/ctests/perf_event_uncore.c: ctests/perf_event_uncore: make\n  more modular  Cleans up the code to make it easier to add tests for\n  architectures other than SandyBridge-EP.  I was doing this so I could add\n  support for IvyBridge but it turns out neither Linux nor libpfm4 supports\n  uncore on IvyBridge yet.  hmmm.\n\n  * 52ff0293 src/components/cuda/Rules.cuda: Rules.cuda:  The cuda component\n  now depend on the dynamic linking loader and on some systems one has to\n  explicitly link to it.  Add $(LDL) to LD_FLAGS, configure sets it if we need\n  it.\n\n  * 97a4a5ea src/components/cuda/Rules.cuda src/components/cuda/linux-cuda.c\n  src/components/cuda/tests/Makefile: Cuda component enhancement. \n  ---------------- From Gary's submission--------------------------------- The\n  current packaging of the cuda component in PAPI has a fairly unfriendly side\n  effect.  When PAPI is built with the cuda component, then that copy of PAPI\n  can only be used on systems where the cuda libraries are installed. If it is\n  installed on a system without these libraries then all PAPI services fail\n  because they have references to libraries which can not be found.  Even\n  papi_avail which you would think has nothing to do with cuda reports the\n  error.  This issue significantly complicates the delivery and install of the\n  PAPI package on large clusters where some of the nodes have NVIDIA GPU's (and\n  the cuda libraries to talk to them) and other nodes do not have GPU's (and\n  therefore no software to access them).  I have been working with the help of\n  Phil Mucci to eliminate this dependency so that a copy of PAPI built with a\n  cuda component could be installed on all nodes in the cluster and if the node\n  had NVIDIA GPU's (and libraries available) then the cuda component would get\n  enabled and could be used.  If the node did not have the hardware or the\n  access libraries were not available, then the cuda component would just\n  disable itself at component initialization so it could not be used (but all\n  other PAPI services would still work).  Phil has provided some gentle\n  prodding and lots of valuable suggestions to assist this effort.  I now think\n  that I have a working version of this capability and am ready to share it\n  with the community.\n  -----------------------------------------------------------------------  Many\n  thanks to Gary Mohr and Phil Mucci for this much needed functionality.\n\n2013-04-23  \n\n  * 99c8e352 src/papi_internal.c: papi_internal.c: Print an eventcode in hex vs\n  decimal.  Thanks, Gary Mohr.\n\n2013-04-22  \n\n  * 1fc5dae2 src/run_tests.sh: The test for determining whether to run valgrind\n  was backwards. Correcting that allow the run_test.sh script to stay the same\n  and one just needs to define \"VALGRIND=yes\" (or any non-null string) to make\n  run_test.sh use valgrind.  --- src/run_tests.sh | 6 ++---- 1 file changed, 2\n  insertions(+), 4 deletions(-)  diff --git a/src/run_tests.sh\n  b/src/run_tests.sh index d1ce205..9337ff2 100755 --- a/src/run_tests.sh +++\n  b/src/run_tests.sh @@ -19,10 +19,8 @@ else export TESTS_QUIET fi  -if [\n  \"x$VALGRIND\" = \"x\" ]; then -# Uncomment the following line to run tests using\n  Valgrind -# VALGRIND=\"valgrind --leak-check=full\"; -    VALGRIND=\"\"; +if [\n  \"x$VALGRIND\" != \"x\" ]; then +    VALGRIND=\"valgrind --leak-check=full\"; fi \n  #CTESTS=`find ctests -maxdepth 1 -perm -u+x -type f`; --\n\n2013-04-19  \n\n  * 4cf16234 src/components/README src/components/bgpm/README\n  src/components/coretemp_freebsd/README...: Restructure README files for\n  components so that the file in the components directory doesn't document\n  individual component details. Add README files to each component directory\n  that requires further installation detail. Update RAPL instructions to\n  capture how to enable reading the MSRs. These files are supposedly configured\n  with Doxygen markup, but I don't think the master README ever got built. It\n  probably should.\n\n2013-04-17  \n\n  * bf75d226 src/components/cuda/tests/HelloWorld.cu: cuda/tests/HelloWorld.cu:\n  workaround a segfault.  Report from Gary Hohr\n  \n   I was running the Cuda test case on a system which did not actually have any\n  NVIDIA GPU's installed on it (but the cuda software was installed and papi\n  was built with the cuda component).  I modified the test case to put an real\n  cuda event in the source (as suggested in the source).  When I run the test\n  case the cuda component gets disabled in PAPI_library_init (because\n  detectDevice function can not find any GPU's) which is the correct behavior.\n  The test case then calls PAPI_event_name_to_code which failed because the\n  cuda component was disabled.  The test case then created an event set and\n  called PAPI_add_events with an empty list of events to be added.  This led to\n  a segfault somewhere inside libpfm4.  The attached patch makes some minor\n  changes to protect against this problem.  I noticed this test case does not\n  use the PAPI test framework utilities (test_xxxx functions) so I did not\n  modify the test to use them.\n\n2013-04-15  \n\n  * 457bfd74 src/components/cuda/linux-cuda.c: When creating two event sets -\n  one for the CUDA and one for the CPU component  - the order of event set\n  creation appears crucial. When the CPU event set has been created before the\n  CUDA event set then PAPI_start() for the CUDA event set works fine. However,\n  if the CUDA event set has been created before the CPU event set, then\n  PAPI_start(CUDA_event_set) forces the CUDA control state to be updated one\n  more time, even if the CUDA event set has not been modified. The CUDA control\n  state function did not properly handle this case and hence cause PAPI_start()\n  to fail. This has been fixed.\n\n  * 807120b6 src/components/cuda/linux-cuda.h: linux-cuda.c\n\n2013-03-28  \n\n  * 7b0eec7a src/run_tests.sh: run_tests.sh: further refine component test find\n   Exclude *.cu when looking for component tests.\n\n2013-03-25  \n\n  * 6a40c8ba src/run_tests.sh: run_tests.sh: File mode changes.  run_tests.sh\n  is now expected to run from the install location in addition to src. The\n  script tried to remove execute from *.[c|h], now it just excludes *.[c|h]\n  from the find commands.\n\n2013-03-18  \n\n  * 2ba9f473 src/perfctr-x86.c: perfctr: don't read in event table multiple\n  times  papi_libpfm3_events.c now reads in the predefined events, we don't\n  also need to do this in perfctr setup_x86_presets()\n\n  * 326401b1 src/perfctr.c: Fix segfault in perfctr.c  The preset lookup uses\n  the cidx index, but in perfctr.c we weren't passing a cidx value (it was\n  being left off).  The old perfctr code plays games with defining extern\n  functions so the compiler wasn't giving us a warning.\n\n2013-03-14  \n\n  * 50130c6f src/components/bgpm/L2unit/linux-L2unit.c src/linux-bgq.c: If a\n  counter is not set to overflow (threshold==0; happens when PAPI_shutdown is\n  called) then we do not want to rebuild the BGPM event set, even if the event\n  set has been used previously and hence \"applied or attached\". Usually if an\n  event set has been applied or attached prior to setting overflow, the BGPM\n  event set needs to be deleted and recreated (which implies malloc() from\n  within BGPM). Not so, though, if threshold is 0 which is the case when\n  PAPI_shutdown is called.  Note, this only applies to Punit and L2unit, not\n  IOunit since an IOunit event set in not applied or attached.\n\n2013-03-13  \n\n  * 1a143003 src/components/bgpm/IOunit/linux-IOunit.c\n  src/components/bgpm/IOunit/linux-IOunit.h\n  src/components/bgpm/L2unit/linux-L2unit.c...: Overflow issue on BG/Q\n  resolved. Overflow with multiple components worked; overflow with multiple\n  components and multiple events did not work as supposed to.\n\n  * 42741a40 src/components/cuda/Rules.cuda: Added one more library to linker\n  command.\n\n2013-03-12  \n\n  * 1431eb3f src/components/nvml/Makefile.nvml.in\n  src/components/nvml/Rules.nvml src/components/nvml/configure...: NVML\n  component: build system work  Adopt the cuda component's method for\n  specifying library location.\n\n2013-03-11  \n\n  * ce66feac src/components/mx/linux-mx.c: mx component: Modernize init\n  routine.  Add component index to _mx_component_init()s signarure and set the\n  bit in component info.\n\n  * 1c1bc177 src/components/cuda/Makefile.cuda.in\n  src/components/cuda/Rules.cuda src/components/cuda/configure...: Resolve\n  configure issues for CUDA component.\n\n2013-03-07  \n\n  * f3572537 src/linux-common.c src/linux-memory.c: Fix the build on\n  Linux-SPARC  I dug out an old SPARC machine and fixed the PAPI build on it.\n\n  * 2c7f102c src/perf_events.c: More comprehensive sys_perf_open to PAPI error\n  mappings  This tries to cover more of the errors returned by sys_perf_open\n  and map them to better results.  EINVAL is a problem because it can mean\n  Conflict as well as Event not found and many other things, so it's unclear\n  what to do with it.\n\n  * 299070ef src/perf_events.c src/sys_perf_event_open.c: Return proper error\n  codes for sys_perf_event_open  For some reason on x86 and x86_64 we were\n  trying to set errno manually and thus over-writing the proper errno value,\n  causing all errors to look like PAPI_EPERM  This removes that code, as well\n  as adds code to report ENOENT as PAPI_ENOEVENT.  With this change, on IVY\n  this happens which looks more correct.  ./utils/papi_command_line\n  perf::L1-ICACHE-PREFETCHES Failed adding: perf::L1-ICACHE-PREFETCHES because:\n  Event does not exist command_line.c                       PASSED\n\n2013-03-06  \n\n  * baa557ca src/papi_libpfm4_events.c src/papi_user_events.c: Coverity fixes: \n  Coverity pointed out that there was a case where load_user_eent_table() could\n  leak memory.  The change in the location of the papi_free(foo) ensures that\n  the allocated memory is freed.  Coverity pointed out one path through the\n  code in _papi_libpfm4_ntv_code_to_descr() that did not free up memory\n  allocated in the function.  Added a free on the path in free up that memory. \n  Thanks Will Cohen.\n\n2013-02-14  \n\n  * 395b7bc7 src/Makefile.inc src/components/README\n  src/components/appio/tests/Makefile...: Add component tests' to the\n  install-[all|tests] target.  Thanks to Gary Mohr. ------------------- This\n  makes a fairly small change to src/Makefile.inc to add logic that adds a new\n  install-comp_tests target which calls the install target for each component\n  being built. This new target is listed as a dependency on the install-tests\n  target so it will happen when the 'install-all', 'install-tests', or\n  'install-comp_tests' targets are used. A note about this change, I am not\n  real familiar with the auto make and auto conf tools. This change was enough\n  to make it work for me but if there is another file that should also be\n  changed for this modification, please help me out here.  The patch also adds\n  install targets to the Makefiles for all of the components which have 'tests'\n  directories and updates the README file which talks about how to create\n  component tests.  Another note, I only compile with a couple of components\n  (ours, rapl, and example) so if I fat fingered something in one of the other\n  components Makefiles I would not have noticed. Please keep me honest and make\n  sure you compile with them all enabled.  Thanks for adding this capability\n  for us. Gary ---------------------------  Makefile.inc: Add run_tests and\n  friends to install-tests target.  Component test Makefiles' get their install\n  location to mirror what runtests expects.\n\n2013-03-04  \n\n  * 448d21ab src/components/rapl/linux-rapl.c: Remove a stray debug statement.\n  Thanks to Harald Servat for catching this.\n\n2013-03-01  \n\n  * df1a75cc src/utils/command_line.c: Wrestled some horribly convoluted\n  indexing into shape. The -u and -x options now print as expected (I think).\n\n2013-01-31  \n\n  * b0f5f4d6 src/components/nvml/linux-nvml.c: linux-nvml.c: Fix type warning. \n  CUDA and NVML have an signed vs unsigned thing going on in their returned\n  device counts, cast away the warning.\n\n2013-01-29  \n\n  * 8490b4ee src/papi.c: General doxygen cleanup: remove all \"No known bugs\"\n  messages; correct and cleanup examples for PAPI_code_to_name and\n  PAPI_name_to_code\n\n2013-01-23  \n\n  * 89e45a9b src/linux-memory.c src/linux-timer.c: ia64 fixes.  Thanks to Tony\n  Jones <tonyj@suse.de> for patches.\n\n2013-01-16  \n\n  * 23e0ba2d src/components/nvml/linux-nvml.c: nvml component: cleanup a memory\n  leak  We did not free a buffer at shutdown time.\n\n2013-01-15  \n\n  * f3db85fc src/papi.h: papi.h bump version number.\n\n  * dfa80287 src/buildbot_configure_with_components.sh: Buildbot configure\n  script.  Add cuda and nvml components, if configured, to the buildbot\n  coverage test. Note: Script now checks for existance of Makefile.cuda and\n  then Makefile.nvml so see if it can build the cuda component and then if it\n  can build the nvml component.\n\n  * cf416e27 src/threads.c: Cleaned up compiler warning (gcc version 4.4.6)\n\n  * 59cbc8fc src/components/bgpm/CNKunit/linux-CNKunit.c\n  src/components/bgpm/IOunit/linux-IOunit.c\n  src/components/bgpm/L2unit/linux-L2unit.c...: Cleaned up compiler warnings on\n  BG/Q (gcc version 4.4.6 (BGQ-V1R1M2-120920))\n\n2013-01-14  \n\n  * 3af71658 .../build/lib.linux-x86_64-2.7/perfmon/__init__.py\n  .../lib.linux-x86_64-2.7/perfmon/perfmon_int.py\n  .../build/lib.linux-x86_64-2.7/perfmon/pmu.py...: libpfm4: remove extraneous\n  build artifacts.  Steve Kaufmann reported differences between the libpfm4 I\n  imported into PAPI and the libpfm4 that can be attained with a git clone\n  git://perfmon2.git.sourceforge.net/gitroot/perfmon2/libpfm4  Self: Do libpfm4\n  imports from a fresh clone of libpfm4.\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/threads.c": "/****************************/\n/* THIS IS OPEN SOURCE CODE */\n/****************************/\n\n/*\n* File:    threads.c\n* Author:  Philip Mucci\n*          mucci@cs.utk.edu\n* Mods:    Kevin London\n*          london@cs.utk.edu\n*/\n\n/* This file contains thread allocation and bookkeeping functions */\n\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n#include <string.h>\n#include <unistd.h>\n\n/*****************/\n/* BEGIN GLOBALS */\n/*****************/\n\n/* The following globals get initialized and cleared by:\n   extern int _papi_hwi_init_global_threads(void);\n   extern int _papi_hwi_shutdown_thread(ThreadInfo_t *thread); */\n\n/* list of threads, gets initialized to master process with TID of getpid() */\n\nvolatile ThreadInfo_t *_papi_hwi_thread_head;\n\n/* If we have TLS, this variable ALWAYS points to our thread descriptor. It's like magic! */\n\n#if defined(HAVE_THREAD_LOCAL_STORAGE)\nTHREAD_LOCAL_STORAGE_KEYWORD ThreadInfo_t *_papi_hwi_my_thread;\n#endif\n\n/* Function that returns and unsigned long thread identifier */\n\nunsigned long ( *_papi_hwi_thread_id_fn ) ( void );\n\n/* Function that sends a signal to other threads */\n\n#ifdef ANY_THREAD_GETS_SIGNAL\nint ( *_papi_hwi_thread_kill_fn ) ( int, int );\n#endif\n\n/*****************/\n/*  END  GLOBALS */\n/*****************/\n\nstatic int\nlookup_and_set_thread_symbols( void )\n{\n#if defined(ANY_THREAD_GETS_SIGNAL)\n\tint retval;\n\tchar *error_ptc = NULL, *error_ptk = NULL;\n\tvoid *symbol_ptc = NULL, *symbol_ptk = NULL, *handle = NULL;\n\n\thandle = dlopen( NULL, RTLD_LAZY );\n\tif ( handle == NULL ) {\n\t\tPAPIERROR( \"Error from dlopen(NULL, RTLD_LAZY): %d %s\", errno,\n\t\t\t\t   dlerror(  ) );\n\t\treturn ( PAPI_ESYS );\n\t}\n\n\tsymbol_ptc = dlsym( handle, \"pthread_self\" );\n\tif ( symbol_ptc == NULL ) {\n\t\terror_ptc = dlerror(  );\n\t\tTHRDBG( \"dlsym(%p,pthread_self) returned NULL: %s\\n\",\n\t\t\t\t( error_ptc ? error_ptc : \"No error, NULL symbol!\" ) );\n\t}\n\n\tsymbol_ptk = dlsym( handle, \"pthread_kill\" );\n\tif ( symbol_ptk == NULL ) {\n\t\terror_ptk = dlerror(  );\n\t\tTHRDBG( \"dlsym(%p,pthread_kill) returned NULL: %s\\n\",\n\t\t\t\t( error_ptk ? error_ptk : \"No error, NULL symbol!\" ) );\n\t}\n\n\tdlclose( handle );\n\n\tif ( !( ( _papi_hwi_thread_kill_fn && _papi_hwi_thread_id_fn ) ||\n\t\t\t( !_papi_hwi_thread_kill_fn && !_papi_hwi_thread_id_fn ) ) )\n\t\treturn ( PAPI_EMISC );\n\n\t_papi_hwi_thread_kill_fn = ( int ( * )( int, int ) ) symbol_ptk;\n\t_papi_hwi_thread_id_fn = ( unsigned long ( * )( void ) ) symbol_ptc;\n#endif\n\treturn ( PAPI_OK );\n}\n\nstatic ThreadInfo_t *\nallocate_thread( int tid )\n{\n\tThreadInfo_t *thread;\n\tint i;\n\n\t/* The Thread EventSet is special. It is not in the EventSet list, but is pointed\n\t   to by each EventSet of that particular thread. */\n\n\tthread = ( ThreadInfo_t * ) papi_malloc( sizeof ( ThreadInfo_t ) );\n\tif ( thread == NULL )\n\t\treturn ( NULL );\n\tmemset( thread, 0x00, sizeof ( ThreadInfo_t ) );\n\n\tthread->context =\n\t\t( hwd_context_t ** ) papi_malloc( sizeof ( hwd_context_t * ) *\n\t\t\t\t\t\t\t\t\t\t  ( size_t ) papi_num_components );\n\tif ( !thread->context ) {\n\t\tpapi_free( thread );\n\t\treturn ( NULL );\n\t}\n\n\tthread->running_eventset =\n\t\t( EventSetInfo_t ** ) papi_malloc( sizeof ( EventSetInfo_t * ) *\n\t\t\t\t\t\t\t\t\t\t   ( size_t ) papi_num_components );\n\tif ( !thread->running_eventset ) {\n\t\tpapi_free( thread->context );\n\t\tpapi_free( thread );\n\t\treturn ( NULL );\n\t}\n\n\tfor ( i = 0; i < papi_num_components; i++ ) {\n\t\tthread->context[i] =\n\t\t\t( void * ) papi_malloc( ( size_t ) _papi_hwd[i]->size.context );\n\t\tthread->running_eventset[i] = NULL;\n\t\tif ( thread->context[i] == NULL ) {\n\t\t\tfor ( i--; i >= 0; i-- )\n\t\t\t\tpapi_free( thread->context[i] );\n\t\t\tpapi_free( thread->context );\n\t\t\tpapi_free( thread );\n\t\t\treturn ( NULL );\n\t\t}\n\t\tmemset( thread->context[i], 0x00,\n\t\t\t\t( size_t ) _papi_hwd[i]->size.context );\n\t}\n\n\tif ( _papi_hwi_thread_id_fn ) {\n           thread->tid = ( *_papi_hwi_thread_id_fn ) (  );\n\t}\n\telse {\n\t   thread->tid = ( unsigned long ) getpid(  );\n\t}\n\n\tthread->allocator_tid=thread->tid;\n\n\tif (tid == 0 ) {\n\t}\n\telse {\n\t  thread->tid=tid;\n\t}\n\n\tTHRDBG( \"Allocated thread %ld at %p, allocator: %ld\\n\", thread->tid, \n\t\tthread,\n\t\tthread->allocator_tid );\n\n\treturn thread;\n}\n\nstatic void\nfree_thread( ThreadInfo_t ** thread )\n{\n\tint i;\n\tTHRDBG( \"Freeing thread %ld at %p\\n\", ( *thread )->tid, *thread );\n\n\tfor ( i = 0; i < papi_num_components; i++ ) {\n\t\tif ( ( *thread )->context[i] )\n\t\t\tpapi_free( ( *thread )->context[i] );\n\t}\n\n\tif ( ( *thread )->context )\n\t\tpapi_free( ( *thread )->context );\n\n\tif ( ( *thread )->running_eventset )\n\t\tpapi_free( ( *thread )->running_eventset );\n\n\tmemset( *thread, 0x00, sizeof ( ThreadInfo_t ) );\n\tpapi_free( *thread );\n\t*thread = NULL;\n}\n\nstatic void\ninsert_thread( ThreadInfo_t * entry, int tid )\n{\n\t_papi_hwi_lock( THREADS_LOCK );\n\n\tif ( _papi_hwi_thread_head == NULL ) {\t/* 0 elements */\n\t\tTHRDBG( \"_papi_hwi_thread_head is NULL\\n\" );\n\t\tentry->next = entry;\n\t} else if ( _papi_hwi_thread_head->next == _papi_hwi_thread_head ) {\t/* 1 elements */\n\t\tTHRDBG( \"_papi_hwi_thread_head was thread %ld at %p\\n\",\n\t\t\t\t_papi_hwi_thread_head->tid, _papi_hwi_thread_head );\n\t\t_papi_hwi_thread_head->next = entry;\n\t\tentry->next = ( ThreadInfo_t * ) _papi_hwi_thread_head;\n\t} else {\t\t\t\t /* 2+ elements */\n\n\t\tTHRDBG( \"_papi_hwi_thread_head was thread %ld at %p\\n\",\n\t\t\t\t_papi_hwi_thread_head->tid, _papi_hwi_thread_head );\n\t\tentry->next = _papi_hwi_thread_head->next;\n\t\t_papi_hwi_thread_head->next = entry;\n\t}\n\n\t_papi_hwi_thread_head = entry;\n\n\tTHRDBG( \"_papi_hwi_thread_head now thread %ld at %p\\n\",\n\t\t\t_papi_hwi_thread_head->tid, _papi_hwi_thread_head );\n\n\t_papi_hwi_unlock( THREADS_LOCK );\n\n#if defined(HAVE_THREAD_LOCAL_STORAGE)\n\t/* Don't set the current local thread if we are a fake attach thread */\n        if (tid==0) {\n\t   _papi_hwi_my_thread = entry;\n\t   THRDBG( \"TLS for thread %ld is now %p\\n\", entry->tid,\n\t\t\t_papi_hwi_my_thread );\n\t}\n#else\n\t( void ) tid;\n#endif\n}\n\nstatic int\nremove_thread( ThreadInfo_t * entry )\n{\n\tThreadInfo_t *tmp = NULL, *prev = NULL;\n\n\t_papi_hwi_lock( THREADS_LOCK );\n\n\tTHRDBG( \"_papi_hwi_thread_head was thread %ld at %p\\n\",\n\t\t\t_papi_hwi_thread_head->tid, _papi_hwi_thread_head );\n\n\t/* Find the preceding element and the matched element,\n\t   short circuit if we've seen the head twice */\n\n\tfor ( tmp = ( ThreadInfo_t * ) _papi_hwi_thread_head;\n\t\t  ( entry != tmp ) || ( prev == NULL ); tmp = tmp->next ) {\n\t\tprev = tmp;\n\t}\n\n\tif ( tmp != entry ) {\n\t\tTHRDBG( \"Thread %ld at %p was not found in the thread list!\\n\",\n\t\t\t\tentry->tid, entry );\n\t\treturn ( PAPI_EBUG );\n\t}\n\n\t/* Only 1 element in list */\n\n\tif ( prev == tmp ) {\n\t\t_papi_hwi_thread_head = NULL;\n\t\ttmp->next = NULL;\n\t\tTHRDBG( \"_papi_hwi_thread_head now NULL\\n\" );\n\t} else {\n\t\tprev->next = tmp->next;\n\t\t/* If we're removing the head, better advance it! */\n\t\tif ( _papi_hwi_thread_head == tmp ) {\n\t\t\t_papi_hwi_thread_head = tmp->next;\n\t\t\tTHRDBG( \"_papi_hwi_thread_head now thread %ld at %p\\n\",\n\t\t\t\t\t_papi_hwi_thread_head->tid, _papi_hwi_thread_head );\n\t\t}\n\t\tTHRDBG( \"Removed thread %p from list\\n\", tmp );\n\t}\n\n\t_papi_hwi_unlock( THREADS_LOCK );\n\n#if defined(HAVE_THREAD_LOCAL_STORAGE)\n\t_papi_hwi_my_thread = NULL;\n\tTHRDBG( \"TLS for thread %ld is now %p\\n\", entry->tid,\n\t\t\t_papi_hwi_my_thread );\n#endif\n\n\treturn PAPI_OK;\n}\n\nint\n_papi_hwi_initialize_thread( ThreadInfo_t ** dest, int tid )\n{\n\tint retval;\n\tThreadInfo_t *thread;\n\tint i;\n\n\tif ( ( thread = allocate_thread( tid  ) ) == NULL ) {\n\t\t*dest = NULL;\n\t\treturn PAPI_ENOMEM;\n\t}\n\n\t/* Call the component to fill in anything special. */\n\n\tfor ( i = 0; i < papi_num_components; i++ ) {\n\t    if (_papi_hwd[i]->cmp_info.disabled) continue;\n\t    retval = _papi_hwd[i]->init_thread( thread->context[i] );\n\t    if ( retval ) {\n\t       free_thread( &thread );\n\t       *dest = NULL;\n\t       return retval;\n\t    }\n\t}\n\n\tinsert_thread( thread, tid );\n\n\t*dest = thread;\n\treturn PAPI_OK;\n}\n\n#if defined(ANY_THREAD_GETS_SIGNAL)\n\n/* This is ONLY defined for systems that enable ANY_THREAD_GETS_SIGNAL\n   since we must forward signals sent to non-PAPI threads.\n\n   This is NOT compatible with thread local storage, since to broadcast\n   the signal, we need a list of threads. */\n\nint\n_papi_hwi_broadcast_signal( unsigned int mytid )\n{\n\tint i, retval, didsomething = 0;\n\tvolatile ThreadInfo_t *foo = NULL;\n\n\t_papi_hwi_lock( THREADS_LOCK );\n\n\tfor ( foo = _papi_hwi_thread_head; foo != NULL; foo = foo->next ) {\n\t\t/* xxxx Should this be hardcoded to index 0 or walk the list or what? */\n\t\tfor ( i = 0; i < papi_num_components; i++ ) {\n\t\t\tif ( ( foo->tid != mytid ) && ( foo->running_eventset[i] ) &&\n\t\t\t\t ( foo->running_eventset[i]->\n\t\t\t\t   state & ( PAPI_OVERFLOWING | PAPI_MULTIPLEXING ) ) ) {\n\t\t\t\t/* xxxx mpx_info inside _papi_mdi_t _papi_hwi_system_info is commented out.\n\t\t\t\t   See papi_internal.h for details. The multiplex_timer_sig value is now part of that structure */\n\t\t\t  THRDBG(\"Thread %ld sending signal %d to thread %ld\\n\",mytid,foo->tid,\n\t\t\t\t  (foo->running_eventset[i]->state & PAPI_OVERFLOWING ? _papi_hwd[i]->cmp_info.hardware_intr_sig : _papi_os_info.itimer_sig));\n\t\t\t  retval = (*_papi_hwi_thread_kill_fn)(foo->tid, \n\t\t\t\t  (foo->running_eventset[i]->state & PAPI_OVERFLOWING ? _papi_hwd[i]->cmp_info.hardware_intr_sig : _papi_os_info.itimer_sig));\n\t\t\t  if (retval != 0)\n\t\t\t\treturn(PAPI_EMISC);\n\t\t\t}\n\t\t}\n\t\tif ( foo->next == _papi_hwi_thread_head )\n\t\t  break;\n\t}\n\t_papi_hwi_unlock( THREADS_LOCK );\n\n\treturn ( PAPI_OK );\n}\n#endif\n\n/* This is undefined for systems that enable ANY_THREAD_GETS_SIGNAL\n   since we always must enable threads for safety. */\n\nint\n_papi_hwi_set_thread_id_fn( unsigned long ( *id_fn ) ( void ) )\n{\n#if !defined(ANY_THREAD_GETS_SIGNAL)\n\t/* Check for multiple threads still in the list, if so, we can't change it */\n\n\tif ( _papi_hwi_thread_head->next != _papi_hwi_thread_head )\n\t\treturn ( PAPI_EINVAL );\n\n\t/* We can't change the thread id function from one to another, \n\t   only NULL to non-NULL and vice versa. */\n\n\tif ( ( id_fn != NULL ) && ( _papi_hwi_thread_id_fn != NULL ) )\n\t\treturn ( PAPI_EINVAL );\n\n\t_papi_hwi_thread_id_fn = id_fn;\n\n\tTHRDBG( \"Set new thread id function to %p\\n\", id_fn );\n\n\tif ( id_fn )\n\t\t_papi_hwi_thread_head->tid = ( *_papi_hwi_thread_id_fn ) (  );\n\telse\n\t\t_papi_hwi_thread_head->tid = ( unsigned long ) getpid(  );\n\n\tTHRDBG( \"New master tid is %ld\\n\", _papi_hwi_thread_head->tid );\n#else\n\tTHRDBG( \"Skipping set of thread id function\\n\" );\n#endif\n\n\treturn PAPI_OK;\n}\n\n\nstatic int _papi_hwi_thread_free_eventsets(long tid) {\n\n   EventSetInfo_t *ESI;\n   ThreadInfo_t *master;\n   DynamicArray_t *map = &_papi_hwi_system_info.global_eventset_map;\n   int i;\n\n   master = _papi_hwi_lookup_thread( tid );\n\n   _papi_hwi_lock( INTERNAL_LOCK );\n\n   for( i = 0; i < map->totalSlots; i++ ) {\n      ESI = map->dataSlotArray[i];\n      if ( ( ESI ) && (ESI->master!=NULL) ) {\n\n\t if ( ESI->master == master ) {\n\t    THRDBG(\"Attempting to remove %d from tid %ld\\n\",ESI->EventSetIndex,tid);\n\n\t    /* Code copied from _papi_hwi_remove_EventSet(ESI);      */\n\t    _papi_hwi_free_EventSet( ESI );\n\t    map->dataSlotArray[i] = NULL;\n\t    map->availSlots++;\n\t    map->fullSlots--;\n\t }\n      }\n   }\n\n   _papi_hwi_unlock( INTERNAL_LOCK );\n\n   return PAPI_OK;\n}\n\n\nint\n_papi_hwi_shutdown_thread( ThreadInfo_t * thread, int force_shutdown )\n{\n\tint retval = PAPI_OK;\n\tunsigned long tid;\n\tint i, failure = 0;\n\n\tif ( _papi_hwi_thread_id_fn )\n\t\ttid = ( *_papi_hwi_thread_id_fn ) (  );\n\telse\n\t\ttid = ( unsigned long ) getpid(  );\n\n        THRDBG(\"Want to shutdown thread %ld, alloc %ld, our_tid: %ld\\n\",\n\t       thread->tid,\n\t       thread->allocator_tid,\n\t       tid);\n\n\tif ((thread->tid==tid) || ( thread->allocator_tid == tid ) || force_shutdown) {\n\n                _papi_hwi_thread_free_eventsets(tid);\n\n\t\tremove_thread( thread );\n\t\tTHRDBG( \"Shutting down thread %ld at %p\\n\", thread->tid, thread );\n\t\tfor( i = 0; i < papi_num_components; i++ ) {\n\t\t   if (_papi_hwd[i]->cmp_info.disabled) continue;\n\t\t   retval = _papi_hwd[i]->shutdown_thread( thread->context[i]);\n\t\t   if ( retval != PAPI_OK ) failure = retval;\n\t\t}\n\t\tfree_thread( &thread );\n\t\treturn ( failure );\n\t}\n\n\tTHRDBG( \"Skipping shutdown thread %ld at %p, thread %ld not allocator!\\n\",\n\t\t\tthread->tid, thread, tid );\n\treturn PAPI_EBUG;\n}\n\n/* THESE MUST BE CALLED WITH A GLOBAL LOCK */\n\nint\n_papi_hwi_shutdown_global_threads( void )\n{\n        int err,num_threads,i;\n\tThreadInfo_t *tmp,*next;\n\tunsigned long our_tid;\n\n\ttmp = _papi_hwi_lookup_thread( 0 );\n\n\tif ( tmp == NULL ) {\n\t   THRDBG( \"Did not find my thread for shutdown!\\n\" );\n\t   err = PAPI_EBUG;\n\t}\n\telse {\n\t   our_tid=tmp->tid;\n\t   (void)our_tid;\n\n\t   THRDBG(\"Shutting down %ld\\n\",our_tid);\n\n\t   err = _papi_hwi_shutdown_thread( tmp, 1 );\n\n\t   /* count threads */\n\t   tmp = ( ThreadInfo_t * ) _papi_hwi_thread_head;\n\t   num_threads=0;\n\t   while(tmp!=NULL) {\n\t      num_threads++;\n\t      if (tmp->next==_papi_hwi_thread_head) break;\n\t      tmp=tmp->next;\n\t   }\n\n\t   /* Shut down all threads allocated by this thread */\n\t   /* Urgh it's a circular list where we removed in the loop  */\n\t   /* so the only sane way to do it is get a count in advance */\n\t   tmp = ( ThreadInfo_t * ) _papi_hwi_thread_head;\n\n\t   for(i=0;i<num_threads;i++) {\n\n\t      next=tmp->next;\n\n\t      THRDBG(\"looking at #%d %ld our_tid: %ld alloc_tid: %ld\\n\",\n\t\t     i,tmp->tid,our_tid,tmp->allocator_tid);\n\n\t\t THRDBG(\"Also removing thread %ld\\n\",tmp->tid);\n\t         err = _papi_hwi_shutdown_thread( tmp, 1 );\n\n\t      tmp=next;\n\n\t   }\n\t}\n\n\n#ifdef DEBUG\n\tif ( ISLEVEL( DEBUG_THREADS ) ) {\n\t\tif ( _papi_hwi_thread_head ) {\n\t\t\tTHRDBG( \"Thread head %p still exists!\\n\", _papi_hwi_thread_head );\n\t\t}\n\t}\n#endif\n\n#if defined(HAVE_THREAD_LOCAL_STORAGE)\n\t_papi_hwi_my_thread = NULL;\n#endif\n\t_papi_hwi_thread_head = NULL;\n\t_papi_hwi_thread_id_fn = NULL;\n#if defined(ANY_THREAD_GETS_SIGNAL)\n\t_papi_hwi_thread_kill_fn = NULL;\n#endif\n\n\treturn err;\n}\n\nint\n_papi_hwi_init_global_threads( void )\n{\n\tint retval;\n\tThreadInfo_t *tmp;\n\n\t_papi_hwi_lock( GLOBAL_LOCK );\n\n#if defined(HAVE_THREAD_LOCAL_STORAGE)\n\t_papi_hwi_my_thread = NULL;\n#endif\n\t_papi_hwi_thread_head = NULL;\n\t_papi_hwi_thread_id_fn = NULL;\n#if defined(ANY_THREAD_GETS_SIGNAL)\n\t_papi_hwi_thread_kill_fn = NULL;\n#endif\n\n\tretval = _papi_hwi_initialize_thread( &tmp , 0);\n\tif ( retval == PAPI_OK ) {\n\t   retval = lookup_and_set_thread_symbols(  );\n\t}\n\n\t_papi_hwi_unlock( GLOBAL_LOCK );\n\n\treturn ( retval );\n}\n\nint\n_papi_hwi_gather_all_thrspec_data( int tag, PAPI_all_thr_spec_t * where )\n{\n\tint didsomething = 0;\n\tThreadInfo_t *foo = NULL;\n\n\t_papi_hwi_lock( THREADS_LOCK );\n\n\tfor ( foo = ( ThreadInfo_t * ) _papi_hwi_thread_head; foo != NULL;\n\t\t  foo = foo->next ) {\n\t\t/* If we want thread ID's */\n\t\tif ( where->id )\n\t\t\tmemcpy( &where->id[didsomething], &foo->tid,\n\t\t\t\t\tsizeof ( where->id[didsomething] ) );\n\n\t\t/* If we want data pointers */\n\t\tif ( where->data )\n\t\t\twhere->data[didsomething] = foo->thread_storage[tag];\n\n\t\tdidsomething++;\n\n\t\tif ( ( where->id ) || ( where->data ) ) {\n\t\t\tif ( didsomething >= where->num )\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ( foo->next == _papi_hwi_thread_head )\n\t\t\tbreak;\n\t}\n\n\twhere->num = didsomething;\n\t_papi_hwi_unlock( THREADS_LOCK );\n\n\treturn ( PAPI_OK );\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/configure.in": "# Process this file with autoconf to produce a configure script.\n# File: configure.in\n\n# cross compile sample\n# ARCH=mips CC=scgcc ./configure --with-arch=mips --host=mips64el-gentoo-linux-gnu- --with-ffsll --with-libpfm4 --with-perf-events --with-virtualtimer=times --with-walltimer=gettimeofday --with-tls=__thread --with-CPU=mips\n# cross compiling should work differently...\n\nAC_PREREQ(2.59)\nAC_INIT(PAPI, 5.5.1.0, ptools-perfapi@eecs.utk.edu)\nAC_CONFIG_SRCDIR([papi.c])\nAC_CONFIG_HEADER([config.h])\n\nAC_DEFUN([AS_AC_EXPAND],\n         [EXP_VAR=[$1]\n          FROM_VAR=[$2]\n          prefix_save=$prefix\n          exec_prefix_save=$exec_prefix\n          if test \"x$prefix\" = \"xNONE\"; then\n            prefix=\"$ac_default_prefix\"\n          fi\n          if test \"x$exec_prefix\" = \"xNONE\"; then\n            exec_prefix=$prefix\n          fi\n          full_var=\"$FROM_VAR\"\n          while true; \n            do\n              new_full_var=\"`eval echo $full_var`\"\n              if test \"x$new_full_var\" = \"x$full_var\"; then \n                break; \n              fi\n              full_var=$new_full_var\n            done\n          full_var=$new_full_var\n          AC_DEFINE_UNQUOTED([$1], \"$full_var\")\n          prefix=$prefix_save\n          exec_prefix=$exec_prefix_save ])\n\nAC_MSG_CHECKING(for architecture)\nAC_ARG_WITH(arch,\n\t       [  --with-arch=<arch>\t\tSpecify architecture (uname -m)],\n\t       [arch=$withval],\n\t       [arch=`uname -m`])\nAC_MSG_RESULT($arch)\n\nAC_ARG_WITH(bitmode,\n            [  --with-bitmode=<32,64>\t\tSpecify bit mode of library],\n            [bitmode=$withval])\n\nAC_MSG_CHECKING(for OS)\nAC_ARG_WITH(OS,\n           [  --with-OS=<os>       \t\tSpecify operating system],\n           [OS=$withval],\n\t       [OS=\"`uname | tr '[A-Z]' '[a-z]'`\"\n            if (test \"$OS\" = \"SunOS\" || test \"$OS\" = \"sunos\"); then\n              OS=solaris\n            fi ])\nAC_MSG_RESULT($OS)\n\nAC_MSG_CHECKING(for OS version)\nAC_ARG_WITH(OSVER,\n           [  --with-OSVER=<ver>\t\tSpecify operating system version],\n           [OSVER=$withval],\n\t       [if test \"$OS\" != \"bgp\" -o \"$OS\" != \"bgq\"; then\n              OSVER=\"`uname -r`\"\n            fi ])\nAC_MSG_RESULT($OSVER)\n\nAC_MSG_CHECKING(for user events)\n\nAC_MSG_CHECKING(for static user events build)\nAC_ARG_WITH(static_user_events,\n\t\t\t\t\t\t\t  [ --with-static-user-events             Build with a static user events file papi_static_user_events.h.],\n\t\t\t\t\t\t\t  [STATIC_USER_EVENTS=yes])\nAC_MSG_RESULT($STATIC_USER_EVENTS)\n\nAC_MSG_CHECKING(for perf_event workaround level)\nAC_ARG_WITH(assumed_kernel,\n\t\t[  --with-assumed-kernel=<ver>\tAssume kernel version is <ver> for purposes of workarounds],\n\t\t[assumed_kernel=$withval; CFLAGS=\"$CFLAGS -DASSUME_KERNEL=\\\\\\\"$with_assumed_kernel\\\\\\\"\"],\n                [assumed_kernel=\"autodetect\"]\n\t\t)\t\t\nAC_MSG_RESULT($assumed_kernel)\n\nAC_MSG_CHECKING([for if MIC should be used])\n\t\tAC_ARG_WITH(mic,\n\t\t\t\t\t\t[ --with-mic To compile for Intel MIC ],\n\t\t\t\t\t\t[MIC=yes\n\t\t\t\t\t\ttls=__thread\n\t\t\t\t\t\tvirtualtimer=cputime_id\n\t\t\t\t\t\tperf_events=yes\n\t\t\t\t\t\twalltimer=clock_realtime_hr\n\t\t\t\t\t\tffsll=no\n\t\t\t\t\t\tcross_compiling=yes\n\t\t\t\t\t\tarch=k1om],\n\t\t\t\t\t\t[MIC=no])\nAC_MSG_RESULT($MIC)\nAC_SUBST(MIC)\n\nCFLAGS=\"$CFLAGS -g\"\n#If not set, set FFLAGS to null to prevent AC_PROG_F77 from defaulting it to -g -O2\nif test \"x$FFLAGS\" = \"x\"; then\n  FFLAGS=\"\"\nfi\nOPTFLAGS=\"-O2\" \nTOPTFLAGS=\"-O0\" \nAC_PROG_CC([xlc icc gcc cc])\nAC_PROG_F77([xlf ifort gfortran f95 f90 f77])\nif test \"x$F77\" = \"x\"; then\n   F77=\nfi\nAC_CHECK_PROG( [MPICC], mpicc, [mpicc], [])\n\n# Lets figure out what CC actually is...\n# Used in later checks to set compiler specific options\nif `$CC -V 2>&1 | grep '^Intel(R) C' >/dev/null 2>&1` ; then\n\tCC_COMMON_NAME=\"icc\"\nelif `$CC -v 2>&1 | grep 'gcc version' >/dev/null 2>&1` ; then\n\tCC_COMMON_NAME=\"gcc\"  \nelif `$CC -qversion 2>&1 | grep 'IBM XL C' >/dev/null 2>&1`; then\n\tCC_COMMON_NAME=\"xlc\"\nelse\n\tCC_COMMON_NAME=\"unknown\"\nfi\n\n#prevent icc warnings about overriding optimization settings set by AC_PROG_CC\n# remark #869: parameter was never referenced \n# remark #271: trailing comma is nonstandard\nif test \"$CC_COMMON_NAME\" = \"icc\"; then\n  CC=\"$CC -diag-disable 188,869,271\"\n  if test \"$MIC\" = \"yes\"; then\n     CC=\"$CC -mmic -fPIC\"\n  fi\nfi\n\nif test \"$F77\" = \"ifort\" -a \"$MIC\" = \"yes\"; then\n  F77=\"$F77 -mmic -fPIC\"\nfi\n\nAC_PROG_AWK\nAC_PROG_CPP\nAC_PROG_LN_S\nAC_PROG_MAKE_SET\nAC_PROG_RANLIB   \nAC_GNU_SOURCE\nAC_HEADER_STDC\nAC_C_INLINE\nAC_HEADER_TIME\nAC_CHECK_HEADERS([sys/time.h c_asm.h intrinsics.h mach/mach_time.h sched.h])\nAC_CHECK_FUNCS([gethrtime read_real_time time_base_to_time clock_gettime mach_absolute_time sched_getcpu])\n\n#\n# Check if the system provides dl* symbols without -ldl, and if not,\n# check for -ldl existance.\n#\n\nAC_MSG_CHECKING([for dlopen and dlerror symbols in base system])\nAC_TRY_LINK([#include <dlfcn.h>],\n\t[void *p = dlopen (\"\", 0); char *c = dlerror();],\n\t[dlsymbols_in_base=\"yes\"], [dlsymbols_in_base=\"no\"])\nif test \"${dlsymbols_in_base}\" = \"yes\"; then\n\tAC_MSG_RESULT([found])\n\tLDL=\"\"\nelse\n\tAC_MSG_RESULT([not found])\n\tAC_MSG_CHECKING([for dlopen and dlerror symbols in -ldl])\n\tSAVED_LIBS=${LIBS}\n\tLIBS=\"${LIBS} -ldl\"\n\tAC_TRY_LINK([#include <dlfcn.h>],\n\t\t[void *p = dlopen (\"\", 0); char *c = dlerror();],\n\t\t[has_ldl=\"yes\"], [has_ldl=\"no\"])\n\tLIBS=${SAVED_LIBS}\n\tif test \"${has_ldl}\" = \"yes\" ; then\n\t\tAC_MSG_RESULT([found])\n  \tLDL=\"-ldl\"\n\telse\n\t\tAC_MSG_ERROR([cannot find dlopen and dlerror symbols neither in the base system libraries nor in -ldl])\n\tfi\nfi\nAC_SUBST(LDL)\n        \n    \nif test \"$OS\" = \"CLE\"; then\n  virtualtimer=times\n  tls=__thread\n  walltimer=cycle\n  ffsll=yes\n  cross_compiling=yes\n  STATIC=\"-static\"\n  # _rtc is only defined when using the Cray compiler\n  AC_MSG_CHECKING([for _rtc intrinsic])\n  rtc_ok=yes\n  AC_TRY_LINK([#ifdef HAVE_INTRINSICS_H\n               #include <intrinsics.h>\n               #endif], [_rtc()], [AC_DEFINE(HAVE__RTC,1,[Define for _rtc() intrinsic.])], \n              [rtc_ok=no\n               AC_DEFINE(NO_RTC_INTRINSIC,1,[Define if _rtc() is not found.])])\n  AC_MSG_RESULT($rtc_ok)\nelif test \"$OS\" = \"bgp\"; then\n  CC=powerpc-bgp-linux-gcc \n  F77=powerpc-bgp-linux-gfortran\n  walltimer=cycle\n  virtualtimer=perfctr\n  tls=no\n  ffsll=yes\n  cross_compiling=yes\nelif test \"$OS\" = \"bgq\"; then\n  AC_ARG_WITH(bgpm_installdir,\n              [  --with-bgpm_installdir=<path> Specify the installation path of BGPM],\n              [BGPM_INSTALL_DIR=$withval\n              CFLAGS=\"$CFLAGS -I$withval\"],\n              [AC_MSG_ERROR([BGQ CPU component requires installation path of BGPM (see --with-bgpm_installdir)])])\n  bitmode=64\n  tls=no\nelif test \"$OS\" = \"linux\"; then\n  if test \"$arch\" = \"ppc64\" -o \"$arch\" = \"x86_64\"; then\n    if test \"$bitmode\" = \"64\" -a \"$libdir\" = '${exec_prefix}/lib'; then\n      libdir='${exec_prefix}/lib64'\n    fi\n  fi\nelif test \"$OS\" = \"solaris\"; then\n  AC_CHECK_TYPE([hrtime_t],\n                [AC_DEFINE(HAVE_HRTIME_T, 1, [Define if hrtime_t is defined in <sys/time.h>])],[],\n                [#if HAVE_SYS_TIME_H\n                 #include <sys/time.h>\n                 #endif])\n  if test \"x$AR\" = \"x\"; then\n    AR=/usr/ccs/bin/ar\n  fi\n\nfi\n\nif test \"x$AR\" = \"x\"; then\n  AR=ar\nfi\n\nif test \"$cross_compiling\" = \"yes\" ; then\n  AC_MSG_CHECKING(for native compiler for header generation)\n  AC_ARG_WITH(nativecc,\n\t         [  --with-nativecc=<path>\t\tSpecify native C compiler for header generation ],\n\t         [nativecc=$withval],\n\t         [nativecc=gcc])\n  AC_MSG_RESULT($nativecc)\nfi\n\nAC_ARG_WITH(tests,\n        \t[  --with-tests=<ctests,ftests,\"ctests ftests\">\t\tSpecify which tests to run on install ],\n        \t[tests=$withval],\n        \t[tests=\"ctests ftests\"]) \n\nAC_MSG_CHECKING(for debug build)\nAC_ARG_WITH(debug,\n            [  --with-debug=<yes,memory>\t\tYes builds a debug version of the library and memory disables PAPI_NO_MEMORY_MANAGEMENT ],\n            [debug=$withval])\nif test \"$debug\" = \"yes\"; then\n  if test \"$CC_COMMON_NAME\" = \"gcc\"; then\n    CFLAGS=\"$CFLAGS -g3\"\n  else\n    CFLAGS=\"$CFLAGS -g\"\n  fi\n  OPTFLAGS=\"-O0\"\n  DEBUGFLAGS=\"-DDEBUG\" \nelif test \"$debug\" = \"memory\"; then\n  DEBUGFLAGS=\"\" \nelse\n  DEBUGFLAGS=\"-DPAPI_NO_MEMORY_MANAGEMENT\" \t\t\t\nfi\nAC_MSG_RESULT($debug)\n\nif test \"$CC_COMMON_NAME\" = \"gcc\"; then\n  gcc_version=`gcc -v 2>&1 | tail -n 1 | awk '{printf $3}'`\n  major=`echo $gcc_version | sed 's/\\([[^.]][[^.]]*\\).*/\\1/'`\n  minor=`echo $gcc_version | sed 's/[[^.]][[^.]]*.\\([[^.]][[^.]]*\\).*/\\1/'`\n  if (test \"$major\" -ge 4 || test \"$major\" = 3 -a \"$minor\" -ge 4); then\n    EXTRA_CFLAGS=\"-Wextra\"\n  else\n    EXTRA_CFLAGS=\"-W\"\n  fi\n# -Wextra => -Woverride-init on gcc >= 4.2\n# This issues a warning (error under -Werror) for some libpfm4 code. \n\tAC_MSG_CHECKING( for -Wno-override-init)\n\t\toldcflags=\"$CFLAGS\"\n\t\tCFLAGS+=\" -Wall -Wextra -Werror -Wno-override-init\"\n\t\tAC_COMPILE_IFELSE( \n\t\t\t\t\t\t[ struct A { int x; int y; };\n\t\t\t\t\t\tint main(void) { struct A a = {.x = 0, .y = 0, .y = 5 }; return a.x; }\n\t\t\t\t\t\t], \n\t\t\t\t\t\t[HAVE_NO_OVERRIDE_INIT=1],\n\t\t\t\t\t\t[HAVE_NO_OVERRIDE_INIT=0] )\n\t\tCFLAGS=\"$oldcflags\"\nAC_MSG_RESULT($HAVE_NO_OVERRIDE_INIT)\n\nfi\nAC_MSG_CHECKING(for CPU type)\nAC_ARG_WITH(CPU,\n            [  --with-CPU=<cpu>\t\tSpecify CPU type],\n            [CPU=$withval\n             case \"$CPU\" in\n               core|core2|i7|atom|p4|p3|opteron|athlon)\n                   MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n             esac],\n\t        [case \"$OS\" in\n               aix)\n                 CPU=\"`/usr/sbin/lsattr -E -l proc0 | grep type | cut -d '_' -f 2 | cut -d ' ' -f 1 | tr '[A-Z]' '[a-z]'`\"\n                 if test \"$CPU\" = \"\"; then\n                   CPU=\"`/usr/sbin/lsattr -E -l proc1 | grep type | cut -d '_' -f 2 | cut -d ' ' -f 1 | tr '[A-Z]' '[a-z]'`\"\n                 fi ;;\n\t       freebsd)\n                   family=`uname -m`\n\n\t\t   if test \"$family\" = \"amd64\"; then\n                      MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n\n\t\t   elif test \"$family\" = \"i386\"; then\n                      MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n\t\t   fi ;;\n\n\t       darwin)\n                   family=`uname -m`\n\n                   MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n\n\t\t   ;;\n\n               linux)\n                   family=`uname -m`\n\n\t\t   if test \"$family\" = \"x86_64\"; then\n                      MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n\t\t      CPU=\"x86\"\n\n\t\t   elif test \"$family\" = \"i686\"; then\n                      MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n\t\t      CPU=\"x86\"\n\n                   elif test \"$family\" = \"ppc64\"; then\n                     CPU_info=\"`cat /proc/cpuinfo | grep cpu | cut -d: -f2 | cut -d' ' -f2 | sed '2,$d'`\"\n                     case \"$CPU_info\" in\n                       PPC970*) CPU=\"PPC970\";;\n                       POWER5)  CPU=\"POWER5\";;\n                       POWER5+) CPU=\"POWER5+\";;\n                       POWER6)  CPU=\"POWER6\";;\n                       POWER7)  CPU=\"POWER7\";;\n                     esac\n\t           fi ;;\n               solaris)\n                 AC_CHECK_HEADER([libcpc.h],\n                                 [CFLAGS=\"$CFLAGS -lcpc\"\n                                  AC_TRY_RUN([#include <stdlib.h>\n                                              #include <libcpc.h> \n                                              int main() {\n                                              // Check for libcpc 2\n                                              if(CPC_VER_CURRENT == 2) \n                                                exit(0);\n                                              exit(1);\n                                              } ], \n                                             [cpc_version=2], \n                                             [cpc_version=0])],\n                                 [AC_MSG_ERROR([libcpc is needed for running PAPI on Solaris]) ])\n                 processor=`uname -p`\n                 machinetype=`uname -m`\n                 if test \"$processor\" = \"sparc\"; then\n                   if test \"$machinetype\" = \"sun4u\"; then\n                     CPU=ultra\n                     AC_CHECK_LIB([cpc], [cpc_take_sample], [], \n                                  [AC_MSG_ERROR([libcpc.a is needed on Solaris, install SUNWcpc]) ])\n                   elif test \"$machinetype\" = \"sun4v\"; then\n                     CPU=niagara2\n                     if test \"$cpc_version\" != \"2\"; then\n                       AC_MSG_ERROR([libcpc2 needed for Niagara 2])\n                     fi\n                   else\n                     AC_MSG_ERROR([$machinetype not supported])\n                   fi\n                 else\n                   AC_MSG_ERROR([Only SPARC processors are supported on Solaris])\n                 fi ;;\n               bgp)\n\t             CPU=bgp ;;\n\t\t\t   bgq)\n\t             CPU=bgq ;;\n               esac ])\nAC_MSG_RESULT($CPU)\nAC_DEFINE_UNQUOTED(CPU,$CPU,[cpu type])\n\n# First set pthread-mutexes based on arch                                       \ncase $arch in\n  aarch64|arm*)\n    pthread_mutexes=yes\n    CFLAGS=\"$CFLAGS -DUSE_PTHREAD_MUTEXES\"\n    echo \"forcing use of pthread mutexes... \" >&6\n  ;;\nesac\n\n\nAC_ARG_WITH(pthread-mutexes,\n              [  --with-pthread-mutexes\t\tSpecify use of pthread mutexes rather than custom PAPI locks],\n              [pthread_mutexes=yes\n\t      CFLAGS=\"$CFLAGS -DUSE_PTHREAD_MUTEXES\"\n\t      ])\n\n  AC_ARG_WITH(ffsll,\n\t          [  --with-ffsll\t\tSpecify use of the ffsll() function ],\n\t          [ffsll=$withval],\n\t          [if test \"$cross_compiling\" = \"yes\" ; then\n                 AC_MSG_ERROR([ffsll must be specified for cross compile])\n\t\t       fi\n               didcheck=1\n               AC_CHECK_FUNC(ffsll,[ffsll=yes],[ffsll=no]) ])\nif test \"$didcheck\" != \"1\"; then\n  AC_MSG_CHECKING(for ffsll)\n  if test \"$ffsll\" = \"yes\" ; then\n    AC_DEFINE(HAVE_FFSLL, 1, This platform has the ffsll() function)\n  fi\n  AC_MSG_RESULT($ffsll)\nfi\n\nAC_MSG_CHECKING(for working gettid)\nAC_LINK_IFELSE([#include <sys/types.h>\n                main() { pid_t a = gettid(); }],\n               [AC_MSG_RESULT(yes)\n                AC_DEFINE(HAVE_GETTID, 1, [Full gettid function])],\n               [AC_MSG_RESULT(no)\n                AC_MSG_CHECKING(for working syscall(SYS_gettid))\n                AC_LINK_IFELSE([#include <sys/types.h>\n                                #include <sys/syscall.h>\n                                main() { pid_t a = syscall(SYS_gettid); }],\n                               [AC_MSG_RESULT(yes)\n                                AC_DEFINE(HAVE_SYSCALL_GETTID, 1, [gettid syscall function])],\n                               [AC_MSG_RESULT(no)]) ])\n\nAC_ARG_WITH(walltimer,\n            [  --with-walltimer=<gettimeofday,mmtimer,clock_realtime_hr,clock_realtime,cycle>\t\tSpecify realtime timer ],\n            [walltimer=$withval],\n            [if test \"$cross_compiling\" = \"yes\" ; then\n               AC_MSG_ERROR([walltimer must be specified for cross compile])\n             fi\n             AC_MSG_CHECKING(for working MMTIMER)\n             AC_TRY_RUN([#include <unistd.h>\n                         #include <fcntl.h>\n                         #include <errno.h>\n                         #include <stdlib.h>\n                         #include <sys/ioctl.h>\n                         #include <linux/mmtimer.h>\n                         #ifndef MMTIMER_FULLNAME\n                         #define MMTIMER_FULLNAME \"/dev/mmtimer\"\n                         #endif\n                         int main() {\n                           int offset;\n                           int fd;\n                           if((fd = open(MMTIMER_FULLNAME, O_RDONLY)) == -1) \n                             exit(1);\n                           if ((offset = ioctl(fd, MMTIMER_GETOFFSET, 0)) < 0) \n                             exit(1);\n                           close(fd);\n                           exit(0);\n                         } ],\n                        [walltimer=\"mmtimer\"\n\t                     AC_MSG_RESULT(yes)],\n                        [AC_MSG_RESULT(no)\n                         AC_MSG_CHECKING(for working CLOCK_REALTIME_HR POSIX 1b timer)\n                         AC_TRY_RUN([#include <unistd.h>\n                                     #include <stdlib.h>\n                                     #include <stdio.h>\n                                     #include <time.h>\n                                     #include <syscall.h>\n                                     main() {\n                                       struct timespec t1, t2;\n                                       double seconds;\n                                       if (syscall(__NR_clock_gettime,CLOCK_REALTIME_HR,&t1) == -1) exit(1);\n                                         sleep(1);\n                                       if (syscall(__NR_clock_gettime,CLOCK_REALTIME_HR,&t2) == -1) exit(1);\n                                         seconds = ((double)t2.tv_sec + (double)t2.tv_nsec/1000000000.0) - ((double)t1.tv_sec + (double)t1.tv_nsec/1000000000.0);\n                                       if (seconds > 1.0)\n                                         exit(0);\n                                       else\n                                         exit(1);\n                                     } ],\n                                    [walltimer=\"clock_realtime_hr\"\n\t                                 AC_MSG_RESULT(yes)],\n                                    [AC_MSG_RESULT(no)\n                                     AC_MSG_CHECKING(for working CLOCK_REALTIME POSIX 1b timer)\n                                     AC_TRY_RUN([#include <unistd.h>\n                                                 #include <stdlib.h>\n                                                 #include <stdio.h>\n                                                 #include <time.h>\n                                                 #include <syscall.h>\n                                                 main() {\n                                                   struct timespec t1, t2;\n                                                   double seconds;\n                                                   if (syscall(__NR_clock_gettime,CLOCK_REALTIME,&t1) == -1) exit(1);\n                                                     sleep(1);\n                                                   if (syscall(__NR_clock_gettime,CLOCK_REALTIME,&t2) == -1) exit(1);\n                                                     seconds = ((double)t2.tv_sec + (double)t2.tv_nsec/1000000000.0) - ((double)t1.tv_sec + (double)t1.tv_nsec/1000000000.0);\n                                                   if (seconds > 1.0)\n                                                     exit(0);\n                                                   else\n                                                     exit(1);\n                                                 } ],\n                                                [walltimer=\"clock_realtime\"\n\t                                             AC_MSG_RESULT(yes)\t],\n                                                [walltimer=\"cycle\"\n\t                                             AC_MSG_RESULT(no)]) ]) ])  ])\nAC_MSG_CHECKING(for real time clock or cycle counter)\nif test \"$walltimer\" = \"gettimeofday\"; then\n  AC_DEFINE(HAVE_GETTIMEOFDAY, 1, [Normal gettimeofday timer])\nelif test \"$walltimer\" = \"mmtimer\"; then\n  AC_DEFINE(HAVE_MMTIMER, 1, [Altix memory mapped global cycle counter])\n  altix=\"-DALTIX\"\nelif test \"$walltimer\" = \"clock_realtime_hr\"; then\n  AC_DEFINE(HAVE_CLOCK_GETTIME, 1, [POSIX 1b clock])\n  AC_DEFINE(HAVE_CLOCK_GETTIME_REALTIME_HR, 1, [POSIX 1b realtime HR clock])\nelif test \"$walltimer\" = \"clock_realtime\"; then\n  AC_DEFINE(HAVE_CLOCK_GETTIME, 1, [POSIX 1b clock])\n  AC_DEFINE(HAVE_CLOCK_GETTIME_REALTIME, 1, [POSIX 1b realtime clock])\nelif test \"$walltimer\" = \"cycle\"; then\n  AC_DEFINE(HAVE_CYCLE, 1, [Native access to a hardware cycle counter])\nelse\n  AC_MSG_ERROR([Unknown value for walltimer])\nfi\n\nSAVED_LIBS=$LIBS\nSAVED_LDFLAGS=$LDFLAGS\nSAVED_CFLAGS=$CFLAGS\nLIBS=\"\"\nLDFLAGS=\"\"\nCFLAGS=\"-pthread\"\n\nAC_ARG_WITH(tls,\n              [  --with-tls=<keyword>\t\tThis platform supports thread local storage with a keyword ],\n              [tls=$withval],\n              [if test \"$cross_compiling\" = \"yes\" ; then\n                 AC_MSG_ERROR([tls must be specified for cross compile])\n               fi\n               AC_MSG_CHECKING(for working __thread)\n               AC_TRY_RUN([#include <pthread.h>\n                           #include <unistd.h>\n                           extern __thread int i;\n                           static int res1, res2;\n                           void thread_main (void *arg) {\n                             i = (int)arg;\n                             sleep (1);\n                             if ((int)arg == 1)\n\t\t                       res1 = (i == (int)arg);\n                             else\n\t\t                       res2 = (i == (int)arg);\n                           }\n\t                       __thread int i;\n                           int main () {\n                             pthread_t t1, t2;\n                             i = 5;\n                             pthread_create (&t1, NULL, thread_main, (void *)1);\n                             pthread_create (&t2, NULL, thread_main, (void *)2);\n                             pthread_join (t1, NULL);\n                             pthread_join (t2, NULL);\n                             return !(res1 + res2 == 2);\n                           } ], \n                          [AC_MSG_RESULT(yes)\n\t                       tls=\"__thread\"], \n                          [AC_MSG_RESULT(no)\n                           tls=\"no\" ])\n               if test \"$OS\" = \"linux\"; then\n                 if test \"x$tls\" = \"x__thread\"; then\n                   # On some linux distributions, TLS works in executables, but linking against\n                   # a shared library containing TLS fails with: undefined reference to `__tls_get_addr'\n                   rm -f conftest.c conftest.so conftest\n                   echo \"static __thread int foo; void main () { foo = 5; }\" > conftest.c\n                   gcc -fPIC --shared -o conftest.so conftest.c > /dev/null 2>&1\n                   gcc -o conftest conftest.so > /dev/null 2>&1\n                     if test ! -f conftest; then\n                       AC_MSG_WARN([Disabling usage of __thread.]);\n                       tls=\"no\"\n                     fi\n                   rm -f conftest.c conftest.so conftest\n                 fi\n               fi])\nAC_MSG_CHECKING(for high performance thread local storage)\nif test \"$tls\" = \"no\"; then\n  NOTLS=\"-DNO_TLS\"\nelif test \"x$tls\" != \"x\"; then\n  if test \"$tls\" = \"yes\"; then\n    tls=\"__thread\"\n  fi\n  NOTLS=\"-DUSE_COMPILER_TLS\"\n  AC_DEFINE_UNQUOTED(HAVE_THREAD_LOCAL_STORAGE,$tls,[Keyword for per-thread variables])\nfi\nAC_MSG_RESULT($tls)\n\nAC_ARG_WITH(virtualtimer,\n              [  --with-virtualtimer=<clock_thread_cputime_id,times,proc,getrusage,perfctr>\t\tSpecify per-thread virtual timer ],\n              [virtualtimer=$withval],\n              [if test \"$cross_compiling\" = \"yes\" ; then\n                 AC_MSG_ERROR([virtualtimer must be specified for cross compile])\n               fi\n               AC_MSG_CHECKING(for working CLOCK_THREAD_CPUTIME_ID POSIX 1b timer)\n               AC_TRY_RUN([#include <pthread.h>\n                           #include <sys/signal.h>\n                           #include <sys/times.h>\n                           #include <assert.h>\n                           #include <stdio.h>\n                           #include <sys/types.h>\n                           #include <unistd.h>\n                           #include <sys/unistd.h>\n                           #include <syscall.h>\n                           #include <stdlib.h>\n                           #if !defined( SYS_gettid )\n                           #define SYS_gettid 1105\n                           #endif\n                           struct timespec threadone = { 0, 0 };\n                           struct timespec threadtwo = { 0, 0 };\n                           pthread_t threadOne, threadTwo;\n                           volatile int done = 0;\n  \n                           int gettid() {\n                             return syscall( SYS_gettid );\n                           }\n  \n                           void *doThreadOne( void * v ) {\n                             while (!done)\n\t                           sleep(1);\n                             if (syscall(__NR_clock_gettime,CLOCK_THREAD_CPUTIME_ID,&threadone) == -1) {\n                               perror(\"clock_gettime(CLOCK_THREAD_CPUTIME_ID)\");\n                               exit(1);\n                             }\n                             return 0;\n                           } \n  \n                           void *doThreadTwo( void * v ) {\n                             long i, j = 0xdeadbeef;     \n                             for( i = 0; i < 0xFFFFFFF; ++i ) { j = j ^ i; }\n  \n                             if (syscall(__NR_clock_gettime,CLOCK_THREAD_CPUTIME_ID,&threadtwo) == -1) {\n                               perror(\"clock_gettime(CLOCK_THREAD_CPUTIME_ID)\");\n                               exit(1);\n                             }        \n                             done = 1;\n\t                         return j;\n                           } \n  \n                           int main( int argc, char ** argv ) {\n                             int status = pthread_create( & threadOne, NULL, doThreadOne, NULL );\n                             assert( status == 0 );\n                             status = pthread_create( & threadTwo, NULL, doThreadTwo, NULL );\n                             assert( status == 0 );  \n                             status = pthread_join( threadTwo, NULL );\n                             assert( status == 0 );\n                             status = pthread_join( threadOne, NULL );\n                             assert( status == 0 );\n                             if ((threadone.tv_sec != threadtwo.tv_sec) || (threadone.tv_nsec != threadtwo.tv_nsec))\n                               exit(0);\n                             else {\t\n                               fprintf(stderr,\"T1 %ld %ld T2 %ld %ld\\n\",threadone.tv_sec,threadone.tv_nsec,threadtwo.tv_sec,threadtwo.tv_nsec);\n\t                           exit(1); \n                             }\n                           } ], \n                          [AC_MSG_RESULT(yes)\n                           virtualtimer=\"clock_thread_cputime_id\"], \n                          [AC_MSG_RESULT(no)\n                           # *** Checks for working per thread timer***\n                           AC_MSG_CHECKING(for working per-thread times() timer)\n                           AC_TRY_RUN([#include <pthread.h>\n                                       #include <sys/signal.h>\n                                       #include <sys/times.h>\n                                       #include <assert.h>\n                                       #include <stdio.h>\n                                       #include <sys/types.h>\n                                       #include <unistd.h>\n                                       #include <sys/unistd.h>\n                                       #include <syscall.h>\n                                       #include <stdlib.h>\n                                       #if !defined( SYS_gettid )\n                                       #define SYS_gettid 1105\n                                       #endif\n                                       long threadone = 0, threadtwo = 0;\n                                       pthread_t threadOne, threadTwo;\n                                       volatile int done = 0;\n  \n                                       int gettid() {\n                                         return syscall( SYS_gettid );\n                                       } \n                                       int doThreadOne( void * v ) {\n                                         struct tms tm;\n                                         int status;\n                                         while (!done)\n\t                                       sleep(1);\n                                         status = times( & tm );\n                                         assert( status != -1 );\n                                         threadone = tm.tms_utime;\n                                         return 0;\n                                       }   \n                                       int doThreadTwo( void * v ) {\n                                         struct tms tm;\n                                         long i, j = 0xdeadbeef;\n                                         int status;\n                                         for( i = 0; i < 0xFFFFFFF; ++i ) { j = j ^ i; }\n                                         status = times( & tm );\n                                         assert( status != -1 );\n                                         threadtwo = tm.tms_utime;\n                                         done = 1;\n\t                                     return j;\n                                       } \n                                       int main( int argc, char ** argv ) {\n                                         int status = pthread_create( & threadOne, NULL, doThreadOne, NULL );\n                                         assert( status == 0 );\n                                         status = pthread_create( & threadTwo, NULL, doThreadTwo, NULL );\n                                         assert( status == 0 );  \n                                         status = pthread_join( threadTwo, NULL );\n                                         assert( status == 0 );\n                                         status = pthread_join( threadOne, NULL );\n                                         assert( status == 0 );\n\t                                     return (threadone == threadtwo);\n                                       } ],\n                                      [AC_MSG_RESULT(yes)\n\t                                   virtualtimer=\"times\"],\n                                      [AC_MSG_RESULT(no)\n\t                                   virtualtimer=\"default\"]) ]) ])\nLDFLAGS=$SAVED_LDFLAGS\nCFLAGS=$SAVED_CFLAGS\nLIBS=$SAVED_LIBS\n\nAC_MSG_CHECKING(for thread virtual clock or cycle counter)\ncase \"$virtualtimer\" in\n  times)\n    AC_DEFINE(HAVE_PER_THREAD_TIMES, 1, [Working per thread timer]) ;;\n  getrusage)\n    AC_DEFINE(HAVE_PER_THREAD_GETRUSAGE, 1, [Working per thread getrusage]) ;;\n  clock_thread_cputime_id)\n    AC_DEFINE(HAVE_CLOCK_GETTIME_THREAD, CLOCK_THREAD_CPUTIME_ID, [POSIX 1b per-thread clock]) ;;\n  proc|default|perfctr)\n    AC_DEFINE(USE_PROC_PTTIMER, 1, [Use /proc for per-thread times])\n    AC_DEFINE(USE_PERFCTR_PTTIMER, 1, [Use the perfctr virtual TSC for per-thread times]) ;;\nesac\nAC_MSG_RESULT($virtualtimer)\n\nif test \"$OS\" = \"aix\"; then\n  AC_ARG_WITH(pmapi,\n              [  --with-pmapi=<path>\t\tSpecify path of pmapi on aix system ],\n              [PMAPI=$withval],\n              [PMAPI=\"/usr/pmapi\"])\n  LIBS=\"-L$PMAPI/lib -lpmapi\"\n  CPPFLAGS=\"$CPPFLAGS -I$PMAPI/include\"\n  AC_CHECK_LIB([pmapi], [pm_initialize], \n               [PMINIT=\"-DPM_INITIALIZE\"], \n               [AC_CHECK_LIB([pmapi], [pm_init], \n                             [PMINIT=\"-DPM_INIT\"], \n                             [AC_MSG_ERROR([libpmapi.a not found, rerun configure with different flags]) ]) ])\nfi\n\nAC_ARG_WITH(papi_events,\n            [  --with-papi-events=<file>\t\tSpecify events file to use],\n            [papi_events=$withval],\n            [papi_events=\"static\" \n             papi_events_table=\"papi_events_table.h\"\n             CFLAGS=\"$CFLAGS -DSTATIC_PAPI_EVENTS_TABLE\"])\n\nAC_ARG_WITH(static_tools,\n            [  --with-static-tools\t\tSpecify static build of tests and utilities],\n            [STATIC=\"-static\"])\n\nAC_MSG_CHECKING(for which libraries to build)\nAC_ARG_WITH(static_lib,\n            [  --with-static-lib=<yes,no>\t\tSpecify whether to build a static library of Papi],\n            [static_lib=$withval],\n            [static_lib=yes])\nAC_ARG_WITH(shared_lib,\n            [  --with-shared-lib=<yes,no>\t\tSpecify whether to build a shared library of Papi],\n            [shared_lib=$withval],\n            [shared_lib=yes])\nif test \"$shared_lib\" = \"yes\"; then\n  papiLIBS=\"shared\"\nfi\nif test \"$static_lib\" = \"yes\"; then\n  papiLIBS=\"$papiLIBS static\"\nfi\nif test \"$shared_lib\" = \"no\" -a \"$static_lib\" = \"no\"; then\n  AC_MSG_ERROR(Both shared and static libs are disabled)\nelse\n  AC_MSG_RESULT($papiLIBS)\nfi\n\nAC_MSG_CHECKING(for link test cases with shared library)\nAC_ARG_WITH(shlib,\n\t        [  --with-shlib\t\tSpecify dynamic linking of papi library with test cases and utilities],\n \t        [shlib=yes\n             SETPATH='export LD_LIBRARY_PATH=$(PWD):$(PWD)/libpfm-3.y/lib:$(PWD)/libpfm4/lib;export LIBPATH=.:./libpfm-3.y/lib:./libpfm4/lib;'   \n             LINKLIB='$(SHLIB)'],\n \t        [if test \"$papiLIBS\" = \"shared\"; then\n               shlib=yes\n               SETPATH='export LD_LIBRARY_PATH=$(PWD):$(PWD)/libpfm-3.y/lib:$(PWD)/libpfm4/lib;export LIBPATH=.:./libpfm-3.y/lib:./libpfm4/lib;'   \n               LINKLIB='$(SHLIB)'\n             else\n               LINKLIB='$(LIBRARY)'\n             fi])\nif test \"$papiLIBS\" != \"shared static\"; then\n  if test \"$shlib\" = \"yes\"; then\n    if echo \"x$papiLIBS\" | grep static > /dev/null; then\n      AC_MSG_ERROR([Building static but specified shared linking])\n    fi\n  elif echo \"x$papiLIBS\" | grep shared > /dev/null; then\n    AC_MSG_ERROR([Building shared but specified static linking])\n  fi\nfi\nAC_MSG_RESULT($shlib)\n\n# default\npfm_incdir=\"libpfm4/include\"\n\n##################################################\n#          perfctr\n##################################################\nperfctr=0\nforce_perfctr=no\n\nAC_ARG_WITH(perfctr,\n            [  --with-perfctr\t\tSpecify perfctr as the performance interface ],\n\t    force_perfctr=yes\n            [user_specified_interface=perfctr\n\t     if test \"$arch\" != \"ppc64\"; then\n\t     perfctr=6\n\t     else\n\t     perfctr=7\n\t     fi],\n            [perfctr=0])\n\nif test \"$cross_compiling\" = \"no\" ; then\n  AC_CHECK_FILE(/sys/class/perfctr,[perfctr=7],[AC_CHECK_FILE(/dev/perfctr,[perfctr=6])])\nfi \n\nif test \"$perfctr\" != 0; then \n  pfm_incdir=\"libpfm-3.y/include/\"\n  AC_MSG_CHECKING(for perfctr version)\n  if test \"$perfctr\" = 7 -a \"$arch\" != \"ppc64\"; then\n    AC_MSG_ERROR([Perfctr 2.7.x only works on PPC64 machines. Patch kernel with 2.6.x.])\n  fi\n  AC_MSG_RESULT(2.$perfctr)\nfi\n\nAC_ARG_WITH(perfctr_root,\n            [  --with-perfctr-root=<path>\t\tSpecify path to source tree (for use by developers only) ],\n            [perfctr_root=$withval\n             user_specified_interface=perfctr])\nAC_ARG_WITH(perfctr_prefix,\n            [  --with-perfctr-prefix=<path>\t\tSpecify prefix to installed perfctr distribution ],\n            [perfctr_prefix=$withval\n             user_specified_interface=perfctr])\nAC_ARG_WITH(perfctr_incdir,\n           [  --with-perfctr-incdir=<path>\t\tSpecify directory of perfctr header files in non-standard location ],\n           [perfctr_incdir=$withval\n            user_specified_interface=perfctr])\nAC_ARG_WITH(perfctr_libdir,\n           [  --with-perfctr-libdir=<path>\t\tSpecify directory of perfctr library in non-standard location ],\n           [perfctr_libdir=$withval\n            user_specified_interface=perfctr])\n\nif test \"$perfctr\" != 0; then\n\n  dotest=0\n  if test \"x$perfctr_root\" != \"x\"; then\n    LIBS=\"-L$perfctr_root/usr.lib -lperfctr\"\n    CPPFLAGS=\"$CPPFLAGS -I$perfctr_root/usr.lib -I$perfctr_root/linux/include\"\n    dotest=1\n  elif test \"x$perfctr_prefix\" != \"x\"; then\n    LIBS=\"-L$perfctr_prefix/lib -lperfctr\"\n    CPPFLAGS=\"$CPPFLAGS -I$perfctr_prefix/include\"\n    perfctr_libdir=\"$perfctr_prefix/lib\"\n    perfctr_incdir=\"$perfctr_prefix/include\"\n    dotest=1\n  else\n    if test \"x$perfctr_libdir\" != \"x\"; then\n      LIBS=\"-L$perfctr_libdir -lperfctr\"\n      dotest=1\n    fi\n    if test \"x$perfctr_incdir\" != \"x\"; then\n      CPPFLAGS=\"-I$perfctr_incdir\"\n      dotest=1\n    fi\n  fi\n\n  if test \"$dotest\" = 1; then\n    AC_CHECK_LIB([perfctr], [vperfctr_open], \n                 [AC_CHECK_HEADERS([libperfctr.h], \n                                   [oCFLAGS=$CFLAGS\n\t                                CFLAGS=\"$CFLAGS -static\"\n\t                                AC_TRY_RUN([#include <stdlib.h>\n\t                                            #include \"libperfctr.h\"\n\t                                            int main() {\n\t\t                                          if ((PERFCTR_ABI_VERSION >> 24) != 5) \n                                                    exit(1); \n                                                  exit(0);\n\t                                            } ],\n                                                [perfctr=6],\n                                                [perfctr=7])\n\t                                CFLAGS=$oCFLAGS], \n                                    [AC_MSG_ERROR([libperfctr.h not found, rerun configure with different flags])])],\n                 [AC_MSG_ERROR([libperfctr.a not found, rerun configure with different flags]) ])\n  else\n    AC_DEFINE(HAVE_LIBPERFCTR_H,1,[perfctr header file])\n  fi\nfi\n\nuser_specified_interface=no\n##################################################\n#          perfmon\n##################################################\nold_pfmv2=n\nperfmon=0\nperfmon2=no\nforce_perfmon2=no\n\nAC_ARG_WITH(perfmon,\n            [  --with-perfmon=<x.y>\t\tSpecify perfmon as the performance interface and specify version],\n            [perfmon=$withval \n             user_specified_interface=perfmon\n\t     force_perfmon2=yes\n\t     pfm_incdir=\"libpfm-3.y/include\"\n             perfmon=`echo ${perfmon} | sed 's/^[ \\t]*//;s/[ \\t]*$//'`\n             perfmon=`echo ${perfmon} | grep -e '[[1-9]]\\.[[0-9]][[0-9]]*'`\n             if test \"x$perfmon\" = \"x\"; then\n               AC_MSG_ERROR(\"Badly formed perfmon version string\")\n             fi\n             perfmon=`echo ${perfmon} | sed 's/\\.//'`\n             if test $perfmon -gt 20; then\n               perfmon2=yes\n             fi\n             if test $perfmon -lt 25; then\n               old_pfmv2=y\n\t       PFMCFLAGS=\"-DPFMLIB_OLD_PFMV2\"\n             fi],\n            [perfmon=0\n\t         if test \"$cross_compiling\" = \"no\" ; then\n\t           AC_CHECK_FILE(/sys/kernel/perfmon/version,\n                             [perfmon=`cat /sys/kernel/perfmon/version`],\n                             [AC_CHECK_FILE(/proc/perfmon,\n                                            [perfmon=`cat /proc/perfmon | grep version | cut -d: -f2`],\n                                            [perfmon=0])])\n               if test \"$perfmon\" != 0; then\n\t         pfm_incdir=\"libpfm-3.y/include\"\n                 perfmon=`echo ${perfmon} | sed 's/^[ \\t]*//;s/[ \\t]*$//'`\n                 perfmon=`echo ${perfmon} | grep -e '[[1-9]]\\.[[0-9]][[0-9]]*'`\n                 perfmon=`echo ${perfmon} | sed 's/\\.//'`\n                 if test $perfmon -gt 20; then\n                   perfmon2=yes\n                 fi\n                 if test $perfmon -lt 25; then\n# must be y, not yes, or libpfm breaks\n                   old_pfmv2=\"y\"           \n                   PFMCFLAGS=\"-DPFMLIB_OLD_PFMV2\"\n                 fi\n               fi\n\t         fi])\n\n\nforce_pfm_incdir=no\n\nAC_ARG_WITH(pfm_root,\n           [  --with-pfm-root=<path>\t\tSpecify path to source tree (for use by developers only) ],\n           [pfm_root=$withval])\nAC_ARG_WITH(pfm_prefix,\n           [  --with-pfm-prefix=<path>\t\tSpecify prefix to installed pfm distribution ],\n           [pfm_prefix=$withval])\nAC_ARG_WITH(pfm_incdir,\n           [  --with-pfm-incdir=<path>\t\tSpecify directory of pfm header files in non-standard location ],\n           [force_pfm_incdir=yes\n            pfm_incdir=$withval])\nAC_ARG_WITH(pfm_libdir,\n           [  --with-pfm-libdir=<path>\t\tSpecify directory of pfm library in non-standard location ],\n           [pfm_libdir=$withval])\n\n\n##################################################\n#          Linux perf_event/perf_counter\n##################################################\n\nif test \"x$mic\" = \"xno\"; then\n       perf_events=no\nfi\n\nforce_perf_events=no\ndisable_uncore=yes\n\nAC_ARG_WITH(perf_events,\n              [  --with-perf-events\t\tSpecify use of Linux Performance Event (requires kernel 2.6.32 or greater)],\n              [force_perf_events=yes\n\t       user_specified_interface=pe])\n\nAC_ARG_ENABLE(perf_event_uncore,\n\t\t[  --disable-perf-event-uncore\t\tDisable perf_event uncore component])\n\nAS_IF([test \"x$enable_perf_event_uncore\" != \"xno\"],[\n\tdisable_uncore=no\n])\n\nif test \"$force_pfm_incdir\" != \"yes\"; then\n  if test \"$force_perf_events\" = \"yes\"; then\n\tpfm_incdir=\"libpfm4/include\"\n  fi\nfi\npe_incdir=\"$pfm_incdir/perfmon\"\n\nAC_ARG_WITH(pe_incdir,\n\t          [  --with-pe-incdir=<path>\t\tSpecify path to the correct perf header file],\n              [pe_incdir=$with_pe_incdir \n               force_perf_events=yes\n\t       user_specified_interface=pe])\n\n# Check for perf_event.h\n  if test \"$force_perf_events\" = \"yes\"; then\n\tperf_events=\"yes\"\n  fi\n  if test \"$cross_compiling\" = \"no\"; then \n\tAC_CHECK_FILE(/proc/sys/kernel/perf_event_paranoid,[\n\tAC_CHECK_FILE($pe_incdir/perf_event.h,perf_events=\"yes\")])\n  fi\n  if test \"$perf_events\" = \"yes\"; then\n      PECFLAGS=\"-DPEINCLUDE=\\\\\\\"$pe_incdir/perf_event.h\\\\\\\"\"\n  fi\n\n#\n# Sort out the choice of the user vs. what we detected\n#\n# MESSING WITH CFLAGS IS STUPID!\n#\nif test \"$user_specified_interface\" != \"no\"; then\n   if test \"$user_specified_interface\" = \"perfctr\"; then\n      perfmon=0\n      perf_events=\"no\"\n   else\n\tif test \"$user_specified_interface\" = \"perfmon\"; then\n\t   perfctr=0\n\t   perf_events=\"no\"\n\t   CFLAGS=\"$CFLAGS $PFMCFLAGS\"\n\telse\n\t\tif test \"$user_specified_interface\" = \"pe\"; then\n\t\t\t   perfctr=0\n\t\t\t   perfmon=0\n\t\t\t   CFLAGS=\"$CFLAGS $PECFLAGS\"\n\t\telse\n\t\t\tAC_MSG_ERROR(\"Unknown user_specified_interface=$user_specified_interface perfctr=$perfctr perfmon=$perfmon perfmon2=$perfmon2 perf-events=$perf_events\")\n\t\tfi\t\t\t\t\t\t\t\t \n\tfi\n   fi\nelse\n\tif test \"$perfmon\" != 0; then\n\t   CFLAGS=\"$CFLAGS $PFMCFLAGS\"\n\tfi\n\tif test \"$perf_events\" = \"yes\"; then\n\t   CFLAGS=\"$CFLAGS $PECFLAGS\"\n\tfi\nfi\n\n\n#\n# User has made no choice, so we default to the ordering below in the platform section, if\n# we detect more than one.\n#\n\n#\n# What does this next section do?\n#\n\nif test \"$perfmon\" != 0 -o \"$perf_events\" = \"yes\"; then\n  dotest=0\n  if test \"x$pfm_root\" != \"x\"; then\n    LIBS=\"-L$pfm_root/lib -lpfm\"\n    CPPFLAGS=\"$CPPFLAGS -I$pfm_root/include\"\n    dotest=1\n  elif test \"x$pfm_prefix\" != \"x\"; then\n    LIBS=\"-L$pfm_prefix/lib -lpfm\"\n    CPPFLAGS=\"$CPPFLAGS -I$pfm_prefix/include\"\n    if test \"x$pfm_libdir\" = \"x\"; then\n      pfm_libdir=\"$pfm_prefix/lib\"\n    fi\n    if test \"x$pfm_prefix\" = \"x\"; then\n      pfm_incdir=\"$pfm_prefix/include\"\n    fi\n    dotest=1\n  else\n    if test \"x$pfm_libdir\" != \"x\"; then\n      LIBS=\"-L$pfm_libdir -lpfm\"\n      dotest=1\n    fi\n    if test \"x$pfm_incdir\" != \"x\"; then\n      CPPFLAGS=\"$CPPFLAGS -I$pfm_incdir\"\n    fi\n  fi\n  if test \"$dotest\" = 1; then\n    AC_CHECK_LIB([pfm], [pfm_initialize], \n                 [AC_CHECK_HEADERS([perfmon/pfmlib.h],\n                                   [if test \"$arch\" = \"ia64\"; then\n   \t\t                              AC_CHECK_HEADERS([perfmon/pfmlib_montecito.h])\n                                    fi\n   \t                                AC_CHECK_FUNC(pfm_get_event_description, \n                                                  [AC_DEFINE(HAVE_PFM_GET_EVENT_DESCRIPTION,1,[event description function])],[])\n   \t                                AC_CHECK_MEMBER(pfmlib_reg_t.reg_evt_idx, \n                                                    [AC_DEFINE(HAVE_PFM_REG_EVT_IDX,1,[old reg_evt_idx])],[],[#include \"perfmon/pfmlib.h\"])\n   \t                                AC_CHECK_MEMBER(pfmlib_output_param_t.pfp_pmd_count, \n                                                    [AC_DEFINE(HAVE_PFMLIB_OUTPUT_PFP_PMD_COUNT,1,[new pfmlib_output_param_t])],[],[#include \"perfmon/pfmlib.h\"])\n   \t                                AC_CHECK_MEMBER(pfm_msg_t.type, \n                                                    [AC_DEFINE(HAVE_PFM_MSG_TYPE,1,[new pfm_msg_t])],[],[#include \"perfmon/perfmon.h\"]) ], \n                                   [AC_MSG_ERROR([perfmon/pfmlib.h not found, rerun configure with different flags]) ]) ], \n                 [AC_MSG_ERROR([libpfm.a not found, rerun configure with different flags]) ])\n  else\n    AC_DEFINE(HAVE_PERFMON_PFMLIB_MONTECITO_H,1,[Montecito headers])\n    AC_DEFINE(HAVE_PFM_GET_EVENT_DESCRIPTION,1,[event description function])\n    AC_DEFINE(HAVE_PFMLIB_OUTPUT_PFP_PMD_COUNT,1,[new pfmlib_output_param_t])\n  fi\nfi\n\n##################################################\n#          Checking platform\n##################################################\nAC_MSG_CHECKING(platform)\ncase \"$OS\" in\n  aix)\n    MAKEVER=\"$OS\"-\"$CPU\" ;;\n  bgp)\n    MAKEVER=bgp ;;\n  bgq)\n    MAKEVER=bgq ;;\n  CLE)\n    if test \"$perfmon2\" = \"yes\"; then\n#  major_version=`echo $OSVER | sed 's/\\([[^.]][[^.]]*\\).*/\\1/'`\n#  minor_version=`echo $OSVER | sed 's/[[^.]][[^.]]*.\\([[^.]][[^.]]*\\).*/\\1/'`\n#  point_version=`echo $OSVER | sed -e 's/[[^.]][[^.]]*.[[^.]][[^.]]*.\\(.*\\)/\\1/' -e 's/[[^0-9]].*//'`\n#    if (test \"$major_version\" = 2 -a \"$minor_version\" = 6 -a \"$point_version\" -lt 31 -a \"$perfmon2\" != \"yes\" ); then\n       MAKEVER=\"$OS\"-perfmon2\n    else\n       MAKEVER=\"$OS\"-pe\n    fi ;;\n  freebsd)\n    MAKEVER=\"freebsd\"\n    LDFLAGS=\"-lpmc\"\n    # HWPMC driver is available for FreeBSD >= 6\n    FREEBSD_VERSION=`uname -r | cut -d'.' -f1`\n    if test \"${FREEBSD_VERSION}\" -lt 6 ; then\n      AC_MSG_ERROR([PAPI requires FreeBSD 6 or greater])\n    fi\n    # Determine if HWPMC module is on the kernel\n    dmesg | grep hwpmc 2> /dev/null > /dev/null\n    if test \"$?\" != \"0\" ; then\n      AC_MSG_ERROR([HWPMC module not found. (see INSTALL.TXT)])\n    fi\n    # Determine the number of counters\n    echo \"/* Automatically generated file by configure */\" > freebsd-config.h\n    echo \"#ifndef _FREEBSD_CONFIG_H_\" >> freebsd-config.h\n    echo \"#define _FREEBSD_CONFIG_H_\" >> freebsd-config.h\n    echo \"\" >> freebsd-config.h\n    AC_TRY_LINK([#include <unistd.h>\n                 #include <pmc.h>],\n                [int i = pmc_init();],\n                [pmc_pmc_init_linked=\"yes\"], [pmc_pmc_init_linked=\"no\"])\n    if test \"${pmc_init_linked}\" = \"no\" ; then\n      AC_MSG_ERROR([Failed to link hwpmc example])\n    fi\n    AC_TRY_RUN([#include <unistd.h>\n                #include <pmc.h>\n                int main() { \n                  const struct pmc_cpuinfo *info;\n                  if (pmc_init() < 0) return 0;\n                  if (pmc_cpuinfo (&info) < 0) return 0;\n                  return info->pm_npmc-1;\n                } ],\n               [ num_counters=\"0\" ], \n               [ num_counters=\"$?\"])\n    if test \"${num_counters}\" = \"0\" ; then\n      AC_MSG_ERROR([pmc_npmc info returned 0. Determine if the HWPMC module is loaded (see hwpmc(4))])\n    fi\n    echo \"#define HWPMC_NUM_COUNTERS ${num_counters}\" >> freebsd-config.h\n    echo \"\" >> freebsd-config.h\n    echo \"#endif\" >> freebsd-config.h ;;\n  linux)\n    if test \"$force_perf_events\" = \"yes\" ; then\n      MAKEVER=\"$OS\"-pe\n    elif test \"$force_perfmon2\" = \"yes\" ; then\n      MAKEVER=\"$OS\"-perfmon2\n    elif test \"$force_perfctr\" = \"yes\" ; then\n      MAKEVER=\"$OS\"-perfctr-x86\n      case \"$CPU\" in\n        itanium2|montecito)\n          if test \"$bitmode\" = \"32\"; then\n            AC_MSG_ERROR([The bitmode you specified is not supported])\n          fi\n\t  MAKEVER=\"$OS\"-pfm-\"$CPU\"\n\t  ;;\n        POWER5|POWER5+|POWER6|POWER7|PPC970)\n          MAKEVER=\"$OS\"-perfctr-\"$CPU\" ;;\n     esac\n    elif test \"$perf_events\" = \"yes\" ; then\n      MAKEVER=\"$OS\"-pe\n    elif test \"$perfmon2\" = \"yes\" ; then\n      MAKEVER=\"$OS\"-perfmon2\n    elif test \"$old_pfmv2\" = \"y\" ; then\n      MAKEVER=\"$OS\"-pfm-\"$CPU\"\n    elif test \"$perfctr\" != 0 ; then\n      case \"$CPU\" in\n        itanium2|montecito)\n          if test \"$bitmode\" = \"32\"; then\n            AC_MSG_ERROR([The bitmode you specified is not supported])\n          fi\n\t  MAKEVER=\"$OS\"-pfm-\"$CPU\"\n\t  ;;\n        x86)\n\t        MAKEVER=\"$OS\"-perfctr-x86 ;;\n        POWER5|POWER5+|POWER6|POWER7|PPC970)\n          MAKEVER=\"$OS\"-perfctr-\"$CPU\" ;;\n        *)\n          MAKEVER=\"$OS\"-generic ;;\n     esac\n    else\n      MAKEVER=\"$OS\"-generic\n    fi ;;\t   \n  solaris)\n    if test \"$bitmode\" = \"64\" -a \"`isainfo -v | grep \"64\"`\" = \"\"; then\n      AC_MSG_ERROR([The bitmode you specified is not supported])\n    fi\n    MAKEVER=\"$OS\"-\"$CPU\" ;;\n  darwin)\n    MAKEVER=\"$OS\" ;;\nesac\n\nAC_MSG_RESULT($MAKEVER)\nif test \"x$MAKEVER\" = \"x\"; then\n  AC_MSG_NOTICE(This platform is not supported so a generic build without CPU counters will be used)\n  MAKEVER=\"generic_platform\"\nfi \n\n##################################################\n#          Set build macros \n##################################################\nFILENAME=Makefile.inc\nSHOW_CONF=showconf\nCTEST_TARGETS=\"all\"\nFTEST_TARGETS=\"all\"\nUTIL_TARGETS=\"papi_avail papi_mem_info papi_cost papi_clockres papi_native_avail papi_command_line papi_event_chooser papi_decode papi_xml_event_info papi_version papi_multiplex_cost papi_component_avail papi_error_codes\"\nLIBRARY=libpapi.a\nSHLIB='libpapi.so.AC_PACKAGE_VERSION'\nVLIB='libpapi.so.$(PAPIVER)'\nOMPCFLGS=-fopenmp\nCC_R='$(CC) -pthread'\nCC_SHR='$(CC) -fPIC -DPIC -shared -Wl,-soname -Wl,$(VLIB) -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\"'\nif test \"$CC_COMMON_NAME\" = \"gcc\"; then\n\tif test \"$bitmode\" = \"32\"; then\n\t\tBITFLAGS=-m32\n\telif test \"$bitmode\" = \"64\"; then\n\t\tBITFLAGS=-m64\n\tfi\nfi\n\nOPTFLAGS=\"$OPTFLAGS $DEBUGFLAGS\"\nCFLAGS=\"$CFLAGS -D_REENTRANT -D_GNU_SOURCE $NOTLS $BITFLAGS\"\nif test \"$CC_COMMON_NAME\" = \"gcc\"; then\n\tCFLAGS=\"$CFLAGS -Wall\"\nfi\nFFLAGS=\"$FFLAGS $BITFLAGS -Dlinux\"\n\n# OS Support\n\nif (test \"$OS\" = \"aix\"); then\n    OSFILESSRC=aix-memory.c\n    OSLOCK=aix-lock.h\n    OSCONTEXT=aix-context.h\nelif (test \"$OS\" = \"bgp\"); then\n    OSFILESSRC=linux-bgp-memory.c\n    OSLOCK=linux-bgp-lock.h\n    OSCONTEXT=linux-bgp-context.h\nelif (test \"$OS\" = \"bgq\"); then\n    OSFILESSRC=linux-bgq-memory.c\n    OSLOCK=linux-bgq-lock.h\n    OSCONTEXT=linux-context.h\nelif (test \"$OS\" = \"freebsd\"); then\n    OSFILESSRC=freebsd-memory.c\n    OSLOCK=\"freebsd-lock.h\"\n    OSCONTEXT=\"freebsd-context.h\"\nelif (test \"$OS\" = \"linux\"); then\n    OSFILESSRC=\"linux-memory.c linux-timer.c linux-common.c\"\n    OSFILESHDR=\"linux-memory.h linux-timer.h linux-common.h\"\n    OSLOCK=\"linux-lock.h\"\n    OSCONTEXT=\"linux-context.h\"\nelif (test \"$OS\" = \"solaris\"); then\n    OSFILESSRC=\"solaris-memory.c solaris-common.c\"\n    OSFILESHDR=\"solaris-memory.h solaris-common.h\"\n    OSLOCK=\"solaris-lock.h\"\n    OSCONTEXT=\"solaris-context.h\"\nelif (test \"$OS\" = \"darwin\"); then\n    OSFILESSRC=\"darwin-memory.c darwin-common.c\"\n    OSFILESHDR=\"darwin-memory.h darwin-common.h\"\n    OSLOCK=\"darwin-lock.h\"\n    OSCONTEXT=\"darwin-context.h\"\nfi\n\nOSFILESOBJ='$(OSFILESSRC:.c=.o)'\n\n\nif (test \"$MAKEVER\" = \"aix-power5\" || test \"$MAKEVER\" = \"aix-power6\" || test \"$MAKEVER\" = \"aix-power7\"); then\n  if test \"$bitmode\" = \"64\"; then\n    LIBRARY=libpapi64.a\n    SHLIB=libpapi64.so\n# By default AIX enforces a limit on heap space \n#( limiting the heap to share the same 256MB memory segment as stack )\n# changing the max data paramater moves the heap off the stack's memory segment\n    BITFLAGS='-q64 -bmaxdata:0x07000000000000'\n    ARG64=-X64\n  else\n# If the issue ever comes up, /dsa requires AIX v5.1 or higher\n# and the Large address-space model (-bmaxdata) requires v4.3 or later\n# see http://publib.boulder.ibm.com/infocenter/pseries/v5r3/topic/com.ibm.aix.genprogc/doc/genprogc/lrg_prg_support.htm#a179c11c5d\n    SHLIB=libpapi.so\n    BITFLAGS=\"-bmaxdata:0x80000000/dsa\"\n  fi\n\n    CPUCOMPONENT_NAME=aix\n    CPUCOMPONENT_C=aix.c\n    CPUCOMPONENT_OBJ=aix.o\n    VECTOR=_aix_vector\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n    MISCHDRS=\"aix.h components/perfctr_ppc/ppc64_events.h papi_events_table.h\"\n    MISCSRCS=\"aix.c\"\n\tSAVED_CFLAGS=\"$CFLAGS\"\n    CFLAGS='$(DEBUGFLAGS) $(FLAGS) -qenum=4 -Icomponents/perfctr_ppc -DNO_VARARG_MACRO -D_AIX -D_$(CPU_MODEL) -DNEED_FFSLL -DARCH_EVTS=\\\"$(ARCH_EVENTS).h\\\" -DCOMP_VECTOR=_ppc64_vectors -DSTATIC_PAPI_EVENTS_TABLE'\n\tCFLAGS=\"$SAVED_CFLAGS $CFLAGS\"\n    FFLAGS='$(FLAGS) -WF,-D_$(CPU_MODEL) -WF,-DARCH_EVTS=\\\"$(ARCH_EVENTS).h\\\"'\n\n  FLAGS='-I$(PMAPI)/include -Icomponents/perfctr_ppc -qmaxmem=-1 -qarch=$(cpu_option) -qtune=$(cpu_option) -qlanglvl=extended $(BITFLAGS)'\n  if test $debug != \"yes\"; then\n\tOPTFLAGS='-O3 -qstrict $(PMINIT)'\n  else\n\tOPTFLAGS='$(PMINIT)'\n  fi\n  SMPCFLGS=-qsmp\n  OMPCFLGS='-qsmp=omp'\n  LDFLAGS='-L$(PMAPI)/lib -lpmapi'\n  CC_R=xlc_r\n  CC=xlc\n  CC_SHR=\"xlc -G -bnoentry\"\n  AC_CHECK_PROGS( [MPICC], [mpicc mpcc], [])\n  F77=xlf\n  CPP='xlc -E $(CPPFLAGS)'\n  if test \"$MAKEVER\" = \"aix-power5\"; then\n    ARCH_EVENTS=power5_events\n    CPU_MODEL=POWER5\n    cpu_option=pwr5\n    DESCR=\"AIX 5.1.0 or greater with POWER5\"\n    if test \"$bitmode\" = \"64\"; then\n      DESCR=\"$DESCR 64 bit build\"\n    fi\n  elif test \"$MAKEVER\" = \"aix-power6\"; then\n    ARCH_EVENTS=power6_events\n    CPU_MODEL=POWER6\n    cpu_option=pwr6\n    DESCR=\"AIX 5.1.0 or greater with POWER6\"\n    CPPFLAGS=\"-qlanglvl=extended\"\n    if test \"$bitmode\" = \"64\"; then\n      DESCR=\"$DESCR 64 bit build\"\n    fi\n  elif test \"$MAKEVER\" = \"aix-power7\"; then\n    ARCH_EVENTS=power7_events\n    CPU_MODEL=POWER7\n    cpu_option=pwr7\n    DESCR=\"AIX 5.1.0 or greater with POWER7\"\n    CPPFLAGS=\"-qlanglvl=extended\"\n    if test \"$bitmode\" = \"64\"; then\n      DESCR=\"$DESCR 64 bit build\"\n    fi\n  fi\nelif test \"$MAKEVER\" = \"bgp\"; then\n  CPP=\"$CC -E\"\n    CPUCOMPONENT_NAME=linux-bgp\n    CPUCOMPONENT_C=linux-bgp.c\n    CPUCOMPONENT_OBJ=linux-bgp.o\n    VECTOR=_bgp_vectors\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n    MISCSRCS=\n    CFLAGS='-g -gdwarf-2 -O2 -Wall -I. -I$(BGP_SYSDIR)/arch/include -DCOMP_VECTOR=_bgp_vectors'\n    tests=\"$tests bgp_tests\"\n  SHOW_CONF=show_bgp_conf\n  BGP_SYSDIR=/bgsys/drivers/ppcfloor\n  BGP_GNU_LINUX_PATH='${BGP_SYSDIR}/gnu-linux'\n  LDFLAGS='-L$(BGP_SYSDIR)/runtime/SPI -lSPI.cna'\n  FFLAGS='-g -gdwarf-2 -O2 -Wall -I. -Dlinux'\n  OPTFLAGS=\"-g -Wall -O3\"\n  TOPTFLAGS=\"-g -Wall -O0\"\n  SHLIB=libpapi.so\n  DESCR=\"Linux for BlueGene/P\"\n  LIBS=static\n  CC_SHR='$(CC) -shared -Xlinker \"-soname\" -Xlinker \"$(SHLIB)\" -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\"'\n  OMPCFLGS=\"\"\n\nelif test \"$MAKEVER\" = \"bgq\"; then\n  FILENAME=Rules.bgpm\n  VECTOR=_bgq_vectors\n  CPUCOMPONENT_NAME=linux-bgq\n  CPUCOMPONENT_C=linux-bgq.c\n  CPUCOMPONENT_OBJ=linux-bgq.o\n  PAPI_EVENTS_CSV=\"papi_events.csv\"\n  MISCSRCS=\"linux-bgq-common.c\"\n  OPTFLAGS=\"-g -Wall -O3\"\n  TOPTFLAGS=\"-g -Wall -O0\"\n  SHLIB=libpapi.so\n  DESCR=\"Linux for Blue Gene/Q\"\n  CC_SHR='$(CC) -fPIC -DPIC -shared -Wl,-soname -Wl,$(SHLIB) -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\"'\n  OMPCFLGS=\"\"\n\nelif test \"$MAKEVER\" = \"CLE-perfmon2\"; then \n    FILENAME=Rules.perfmon2\n    CPUCOMPONENT_NAME=perfmon\n    CPUCOMPONENT_C=perfmon.c\n    CPUCOMPONENT_OBJ=perfmon.o\n    VECTOR=_papi_pfm_vector\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n  F77=gfortran\n  CFLAGS=\"$CFLAGS -D__crayxt\"\n  FFLAGS=\"\"\n\nelif test \"$MAKEVER\" = \"freebsd\"; then\n    CPUCOMPONENT_NAME=freebsd\n    CPUCOMPONENT_C=freebsd.c\n    CPUCOMPONENT_OBJ=freebsd.o\n    VECTOR=_papi_freebsd_vector\n    PAPI_EVENTS_CSV=\"freebsd_events.csv\"\n    MISCHDRS=\"freebsd/map-unknown.h freebsd/map.h freebsd/map-p6.h freebsd/map-p6-m.h freebsd/map-p6-3.h freebsd/map-p6-2.h freebsd/map-p6-c.h freebsd/map-k7.h freebsd/map-k8.h freebsd/map-p4.h freebsd/map-atom.h freebsd/map-core.h freebsd/map-core2.h freebsd/map-core2-extreme.h freebsd/map-i7.h freebsd/map-westme\\\nre.h\"\n    MISCSRCS=\"$MISCSRCS freebsd/map-unknown.c freebsd/map.c freebsd/map-p6.c freebsd/map-p6-m.c freebsd/map-p6-3.c freebsd/map-p6-2.c freebsd/map-p6-c.c freebsd/map-k7.c freebsd/map-k8.c freebsd/map-p4.c freebsd/map-atom.c freebsd/map-core.c freebsd/map-core2.c freebsd/map-core2-extreme.c freebsd/map-i7.c freebsd/map-westme\\\nre.c\"\n  DESCR=\"FreeBSD -over libpmc- \"\n  CFLAGS=\"$CFLAGS -I. -Ifreebsd -DPIC -fPIC $DEBUGFLAGS\"\n  CC_SHR='$(CC) -shared -Xlinker \"-soname\" -Xlinker \"libpapi.so\" -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\" -DPIC -fPIC -I. -Ifreebsd'\n\nelif test \"$MAKEVER\" = \"linux-generic\"; then\n    CPUCOMPONENT_NAME=linux-generic\n    CPUCOMPONENT_C=linux-generic.c\n    CPUCOMPONENT_OBJ=linux-generic.o\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n    VECTOR=_papi_dummy_vector\n\nelif test \"$MAKEVER\" = \"linux-pe\"; then\n    FILENAME=Rules.pfm4_pe\n    CPUCOMPONENT_NAME=perf_event \n    components=\"perf_event\"\n    if test \"$disable_uncore\" = \"no\"; then\n       components=\"$components perf_event_uncore\"\n    fi\n\nelif test \"$MAKEVER\" = \"linux-perfctr-x86\"; then\n    FILENAME=Rules.perfctr-pfm\n    CPUCOMPONENT_NAME=perfctr-x86\n    VERSION=2.6.x  \n    components=\"perfctr\"\n\nelif (test \"$MAKEVER\" = \"linux-perfctr-POWER5\" || test \"$MAKEVER\" = \"linux-perfctr-POWER5+\" || test \"$MAKEVER\" = \"linux-perfctr-POWER6\" || test \"$MAKEVER\" = \"linux-perfctr-POWER7\" || test \"$MAKEVER\" = \"linux-perfctr-PPC970\"); then\n    FILENAME=Rules.perfctr\n    CPUCOMPONENT_NAME=perfctr-ppc\n    VERSION=2.7.x\n    components=\"perfctr_ppc\"\n    CPU=ppc64\n    if test \"$MAKEVER\" = \"linux-perfctr-POWER5\"; then\n      CPU_MODEL=POWER5\n      ARCH_EVENTS=power5_events\n      ARCH_SPEC_EVTS=power5_events_map.c\n    elif test \"$MAKEVER\" = \"linux-perfctr-POWER5+\"; then\n      CPU_MODEL=POWER5p\n      ARCH_EVENTS=power5+_events\n      ARCH_SPEC_EVTS=power5+_events_map.c\n    elif test \"$MAKEVER\" = \"linux-perfctr-POWER6\"; then\n      CPU_MODEL=POWER6\n      ARCH_EVENTS=power6_events\n      ARCH_SPEC_EVTS=power6_events_map.c\n    elif test \"$MAKEVER\" = \"linux-perfctr-POWER7\"; then\n      CPU_MODEL=POWER7\n      ARCH_EVENTS=power7_events\n      ARCH_SPEC_EVTS=power7_events_map.c\n    elif test \"$MAKEVER\" = \"linux-perfctr-PPC970\"; then\n      CPU_MODEL=PPC970\n      ARCH_EVENTS=ppc970_events\n      ARCH_SPEC_EVTS=ppc970_events_map.c\n    fi\n    CFLAGS=\"$CFLAGS -DPPC64 -D_$(CPU_MODEL) -D__perfctr__ -DARCH_EVTS=\\\"$(ARCH_EVENTS).h\\\" -DCOMP_VECTOR=_ppc64_vectors\"\n    FFLAGS='-D_$(CPU_MODEL)'\n\nelif test \"$MAKEVER\" = \"linux-perfmon2\"; then\n    FILENAME=Rules.perfmon2\n    CPUCOMPONENT_NAME=perfmon2\n    components=\"perfmon2\"\n\nelif (test \"$MAKEVER\" = \"linux-pfm-ia64\" || test \"$MAKEVER\" = \"linux-pfm-itanium2\" || test \"$MAKEVER\" = \"linux-pfm-montecito\"); then\n    FILENAME=Rules.pfm\n    CPUCOMPONENT_NAME=perfmon-ia64\n    components=\"perfmon_ia64\"\n    VERSION=3.y\n    if test \"$MAKEVER\" = \"linux-pfm-itanium2\"; then\n      CPU=2\n    else\n      CPU=3\n    fi\n    CFLAGS=\"$CFLAGS -DITANIUM$CPU\"\n    FFLAGS=\"$FFLAGS -DITANIUM$CPU\"\n\n  CC_SHR='$(CC) -fPIC -DPIC -shared -Wl,-soname -Wl,$(SHLIB) -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\"'\n\nelif test \"$MAKEVER\" = \"solaris-ultra\"; then\n    CPUCOMPONENT_NAME=solaris-ultra\n    CPUCOMPONENT_C=solaris-ultra.c\n    CPUCOMPONENT_OBJ=solaris-ultra.obj\n    VECTOR=_solaris_vector\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n  DESCR=\"Solaris 5.8 or greater with UltraSPARC I, II or III\"\n  if test \"$CC\" = \"gcc\"; then\n    F77=g77\n    CPP=\"$CC -E\"\n    CC_R=\"$CC\" \n    CC_SHR=\"$CC -shared -fpic\"\n    OPTFLAGS=-O3\n    CFLAGS=\"$CFLAGS -DNEED_FFSLL\"\n    FFLAGS=$CFLAGS\n  else \n    # Sun Workshop compilers: V5.0 and V6.0 R2\n    CPP=\"$CC -E\"\n    CC_R=\"$CC -mt\"\n    CC_SHR=\"$CC -ztext -G -Kpic\" \n      CFLAGS=\"-xtarget=ultra3 -xarch=v8plusa -DNO_VARARG_MACRO -D__EXTENSIONS__ -DPAPI_NO_MEMORY_MANAGEMENT -DCOMP_VECTOR=_solaris_vectors\"\n    SMPCFLGS=-xexplicitpar\n    OMPCFLGS=-xopenmp\n    F77=f90\n    FFLAGS=$CFLAGS\n    NOOPT=-xO0 \n    OPTFLAGS=\"-g -fast -xtarget=ultra3 -xarch=v8plusa\" \n  fi\n  LDFLAGS=\"$LDFLAGS -lcpc\" \n  if test \"$bitmode\" = \"64\"; then\n    LIBRARY=libpapi64.a\n    SHLIB=libpapi64.so\n      CFLAGS=\"-xtarget=ultra3 -xarch=v9a -DNO_VARARG_MACRO -D__EXTENSIONS__ -DPAPI_NO_MEMORY_MANAGEMENT  -DCOMP_VECTOR=_solaris_vectors\"\n    OPTFLAGS=\"-g -fast -xtarget=ultra3 -xarch=v9a\"\n  fi\n\nelif test \"$MAKEVER\" = \"solaris-niagara2\"; then\n    CPUCOMPONENT_NAME=solaris-niagara2\n    CPUCOMPONENT_C=solaris-niagara2.c\n    CPUCOMPONENT_OBJ=solaris-niagara2.obj\n    VECTOR=_niagara2_vector\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n    CFLAGS=\"-xtarget=native -xarch=native -DNO_VARARG_MACRO -D__EXTENSIONS__ -DCOMP_VECTOR=_niagara2_vector\"\n    ORY_MANAGEMENT=\"-DCOMP_VECTOR=_solaris_vector\"\n  DESCR=\"Solaris 10 with libcpc2 and UltraSPARC T2 (Niagara 2)\"\n  CPP=\"$CC -E\"\n  CC_R=\"$CC -mt\"\n  CC_SHR=\"$CC -ztext -G -Kpic\"  \n  SMPCFLGS=-xexplicitpar\n  OMPCFLGS=-xopenmp\n  F77=f90\n  FFLAGS=$CFLAGS\n  NOOPT=-xO0 \n  OPTFLAGS=\"-fast\" \n  FOPTFLAGS=$OPTFLAGS\n  LDFLAGS=\"$LDFLAGS -lcpc\" \n  if test \"$bitmode\" = \"64\";  then\n    LIBRARY=libpapi64.a\n    SHLIB=libpapi64.so\n    CFLAGS=\"$CFLAGS -m64\"\n    FFLAGS=\"$FFLAGS -m64\"\n  fi\nelif test \"$MAKEVER\" = \"darwin\"; then\n  DESCR=\"Darwin\"\n  CPUCOMPONENT_NAME=darwin\n  CPUCOMPONENT=linux-generic.c\n  CPUCOMPONENT=linux-generic.obj\n  CFLAGS=\"-DNEED_FFSLL\"\n  CC_SHR='$(CC) -fPIC -DPIC -shared -Wl,-dylib -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\"'\n  SHLIB=libpapi.dylib\nelif test \"$MAKEVER\" = \"generic_platform\"; then\n  DESCR=\"Generic platform\"\nfi\n\nMISCOBJS='$(MISCSRCS:.c=.o)'\n\n\n\nif test \"$F77\" = \"pgf77\"; then\n  FFLAGS=\"$FFLAGS -Wall -Mextend\"\nelif test \"$F77\" = \"ifort\"; then\n  FFLAGS=\"$FFLAGS -warn all\"\nelif test \"$F77\" != \"xlf\"; then\n  FFLAGS=\"$FFLAGS -Wall -ffixed-line-length-132\"\nfi\n\nif test \"$CC_COMMON_NAME\" = \"icc\"; then\n    OMPCFLGS=-openmp\nfi\n\nAC_MSG_CHECKING(for components to build)\nCOMPONENT_RULES=components/Rules.components\necho \"/* Automatically generated by configure */\" > components_config.h\necho \"#ifndef COMPONENTS_CONFIG_H\" >> components_config.h\necho \"#define COMPONENTS_CONFIG_H\" >> components_config.h\necho \"\" >> components_config.h\n\nAC_ARG_WITH(components,\n        \t[  --with-components=<\"component1 component2\">\t\tSpecify which components to build ],\n        \t[components=\"$components $withval\"]) \n\n# This is an ugly hack to keep building on configurations covered by any-null in the past.\nif test \"$VECTOR\" = \"_papi_dummy_vector\"; then\n\tif test \"x$components\" = \"x\"; then \n\t\techo \"papi_vector_t ${VECTOR} = {\" >> components_config.h \n \t\techo \"\t.size = {\n\t\t.context = sizeof ( int ),\n\t\t.control_state = sizeof ( int ),\n\t\t.reg_value = sizeof ( int ),\n\t\t.reg_alloc = sizeof ( int ),\n\t}, \n\t.cmp_info = { \n\t\t.num_native_events = 0, \n\t\t.num_preset_events = 0, \n\t\t.num_cntrs = 0,\n\t\t.name = \\\"Your system is unsupported! \\\",\n\t\t.short_name = \\\"UNSUPPORTED!\\\" \n\t},\n\t.dispatch_timer = NULL,\n    .get_overflow_address = NULL,\n    .start = NULL,\n    .stop = NULL,\n    .read = NULL,\n    .reset = NULL,\n    .write = NULL,\n\t.cleanup_eventset = NULL,\n    .stop_profiling = NULL,\n    .init_component = NULL,\n    .init_thread = NULL,\n    .init_control_state = NULL,\n    .update_control_state = NULL,\n    .ctl = NULL,\n    .set_overflow = NULL,\n    .set_profile\t = NULL,\n    .set_domain = NULL,\n    .ntv_enum_events = NULL,\n    .ntv_name_to_code = NULL,\n    .ntv_code_to_name = NULL,\n    .ntv_code_to_descr = NULL,\n    .ntv_code_to_bits = NULL,\n    .ntv_code_to_info = NULL,\n    .allocate_registers = NULL,\n    .shutdown_thread = NULL,\n    .shutdown_component = NULL,\n    .user = NULL,\n};\" >> components_config.h\n\t# but in the face of actual components, we don't have to do hacky size games\n\telse\n\t\tVECTOR=\"\"\n\tfi\nelif test \"x$VECTOR\" != \"x\"; then\n   echo \"extern papi_vector_t ${VECTOR};\" >> components_config.h\nfi\n    \n\n\nfor comp in $components; do\n  idx=`echo \"$comp\" | sed -n \"s/\\/.*//p\" | wc -c`\n  if test \"$idx\" = 0; then\n\tsubcomp=$comp\n  else\n      subcomp=`echo $comp | sed -E \"s/^.{${idx}}//\"`\n  fi\n  COMPONENT_RULES=\"$COMPONENT_RULES components/$comp/Rules.$subcomp\"\n  echo \"extern papi_vector_t _${subcomp}_vector;\" >> components_config.h\ndone\necho \"\" >> components_config.h\necho \"struct papi_vectors *_papi_hwd[[]] = {\" >> components_config.h\n\nif test \"x$VECTOR\" != \"x\"; then\n   echo \"   &${VECTOR},\" >> components_config.h\nfi\n\nfor comp in $components; do\n  idx=`echo \"$comp\" | sed -n \"s/\\/.*//p\" | wc -c` \n  if test \"$idx\" = 0; then\n\tsubcomp=$comp\n  else\n      subcomp=`echo $comp | sed -E \"s/^.{${idx}}//\"`\n  fi\n  echo \"   &_${subcomp}_vector,\" >> components_config.h\ndone\necho \"   NULL\" >> components_config.h\necho \"};\" >> components_config.h\necho \"\" >> components_config.h\necho \"#endif\" >> components_config.h \n\n# check for component tests\nfor comp in $components; do\n  if test \"`find components/$comp -name \"tests\"`\" != \"\" ; then\n\tCOMPONENTS=\"$COMPONENTS $comp\"\n  fi\ndone\ntests=\"$tests comp_tests\"\n\nAC_MSG_RESULT($components)\n\nif test \"$STATIC_USER_EVENTS\" = \"yes\"; then\n\tCFLAGS=\"$CFLAGS -DSTATIC_USER_EVENTS\"\nfi\n\nif test \"x$PAPI_EVENTS_CSV\" == \"x\"; then\n   PAPI_EVENTS_CSV=\"papi_events.csv\"\nfi\n\n\nAC_SUBST(prefix)\nAC_SUBST(exec_prefix)\nAC_SUBST(libdir)\nAC_SUBST(includedir)\nAC_SUBST(mandir)\nAC_SUBST(bindir)\nAC_SUBST(datadir)\nAC_SUBST(datarootdir)\nAC_SUBST(docdir)\nAC_SUBST(PACKAGE_TARNAME)\nAC_SUBST(arch)\nAC_SUBST(DEBUGFLAGS)\nAC_SUBST(MAKEVER)\nAC_SUBST(PMAPI)\nAC_SUBST(PMINIT)\nAC_SUBST(F77)\nAC_SUBST(CPP)\nAC_SUBST(CC)\nAC_SUBST(AR)\nAC_SUBST(papiLIBS)\nAC_SUBST(STATIC)\nAC_SUBST(LDFLAGS)\nAC_SUBST(NOTLS)\nAC_SUBST(altix)\nAC_SUBST(perfctr_root)\nAC_SUBST(perfctr_prefix)\nAC_SUBST(perfctr_incdir)\nAC_SUBST(perfctr_libdir)\nAC_SUBST(pfm_root)\nAC_SUBST(old_pfmv2)\nAC_SUBST(pfm_prefix)\nAC_SUBST(pfm_incdir)\nAC_SUBST(pfm_libdir)\nAC_SUBST(OS)\nAC_SUBST(CFLAGS)\nAC_SUBST(FFLAGS)\nAC_SUBST(CPPFLAGS)\nAC_SUBST(papi_events)\nAC_SUBST(papi_events_table)\nAC_SUBST(SETPATH)\nAC_SUBST(LINKLIB)\nAC_SUBST(VERSION)\nAC_SUBST(CPU)\nAC_SUBST(FILENAME)\nAC_SUBST(LIBRARY)\nAC_SUBST(SHLIB)\nAC_SUBST(VLIB)\nAC_SUBST(OPTFLAGS)\nAC_SUBST(CPUCOMPONENT_NAME)\nAC_SUBST(CPUCOMPONENT_C)\nAC_SUBST(CPUCOMPONENT_OBJ)\nAC_SUBST(OSFILESSRC)\nAC_SUBST(OSFILESOBJ)\nAC_SUBST(OSFILESHDR)\nAC_SUBST(OSLOCK)\nAC_SUBST(OSCONTEXT)\nAC_SUBST(DESCR)\nAC_SUBST(LIBS)\nAC_SUBST(CTEST_TARGETS)\nAC_SUBST(CC_R)\nAC_SUBST(CC_SHR)\nAC_SUBST(SMPCFLGS)\nAC_SUBST(OMPCFLGS)\nAC_SUBST(NOOPT)\nAC_SUBST(MISCSRCS)\nAC_SUBST(MISCOBJS)\nAC_SUBST(POST_BUILD)\nAC_SUBST(ARCH_EVENTS)\nAC_SUBST(CPU_MODEL)\nAC_SUBST(cpu_option)\nAC_SUBST(ARG64)\nAC_SUBST(FLAGS)\nAC_SUBST(MPICC)\nAC_SUBST(MISCHDRS)\nAC_SUBST(SHLIBDEPS)\nAC_SUBST(TOPTFLAGS)\nAC_SUBST(TESTS)\nAC_SUBST(tests)\nAC_SUBST(SHOW_CONF)\nAC_SUBST(BGP_SYSDIR)\nAC_SUBST(BITFLAGS)\nAC_SUBST(COMPONENT_RULES)\nAC_SUBST(COMPONENTS)\nAC_SUBST(FTEST_TARGETS)\nAC_SUBST(UTIL_TARGETS)\nAC_SUBST(EXTRA_CFLAGS)\nAC_SUBST(HAVE_NO_OVERRIDE_INIT)\nAC_SUBST(PAPI_EVENTS_CSV)\nAC_SUBST(BGPM_INSTALL_DIR)\nAC_SUBST(CC_COMMON_NAME)\n\nif test \"$cross_compiling\" = \"yes\" ; then\n  AC_MSG_NOTICE(Compiling genpapifdef with $nativecc because cross compiling)\n  $nativecc -I. genpapifdef.c -o genpapifdef\nelse\n  AC_MSG_NOTICE(Compiling genpapifdef with $CC)\n  $CC -I. genpapifdef.c -o genpapifdef\nfi\n\nAC_MSG_NOTICE(Generating fpapi.h)\n./genpapifdef -c > fpapi.h\nAC_MSG_NOTICE(Generating f77papi.h)\n./genpapifdef -f77 > f77papi.h\nAC_MSG_NOTICE(Generating f90papi.h)\n./genpapifdef -f90 > f90papi.h\n\nAC_MSG_NOTICE($FILENAME will be included in the generated Makefile)\nAC_CONFIG_FILES([Makefile papi.pc])\nAC_CONFIG_FILES([components/Makefile_comp_tests.target testlib/Makefile.target ctests/Makefile.target ftests/Makefile.target])\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/ctests/shlib.c": "/* \n* File:    profile.c\n* CVS:     $Id$\n* Author:  Philip Mucci\n*          mucci@cs.utk.edu\n* Mods:    <your name here>\n*          <your email address>\n*/\n#include \"papi_test.h\"\n\nvoid print_shlib_info_map(const PAPI_shlib_info_t *shinfo)\n{\n\tPAPI_address_map_t *map = shinfo->map;\n\tint i;\n\tif (NULL == map) {\n\t    test_fail(__FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1);\n\t}\n\n\tfor ( i = 0; i < shinfo->count; i++ ) {\n\t\tprintf( \"Library: %s\\n\", map->name );\n\t\tprintf( \"Text start: %p, Text end: %p\\n\", map->text_start,\n\t\t\t\tmap->text_end );\n\t\tprintf( \"Data start: %p, Data end: %p\\n\", map->data_start,\n\t\t\t\tmap->data_end );\n\t\tprintf( \"Bss start: %p, Bss end: %p\\n\", map->bss_start, map->bss_end );\n\n\t\tif ( strlen( &(map->name[0]) ) == 0 )\n\t\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t\tif ( ( map->text_start == 0x0 ) || ( map->text_end == 0x0 ) ||\n\t\t\t ( map->text_start >= map->text_end ) )\n\t\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n/*\n       if ((map->data_start == 0x0) || (map->data_end == 0x0) ||\n\t   (map->data_start >= map->data_end))\n\t test_fail(__FILE__, __LINE__, \"PAPI_get_shared_lib_info\",1);\n       if (((map->bss_start) && (!map->bss_end)) ||\n\t   ((!map->bss_start) && (map->bss_end)) ||\n\t   (map->bss_start > map->bss_end))\n\t test_fail(__FILE__, __LINE__, \"PAPI_get_shared_lib_info\",1);\n*/\n\n\t\tmap++;\n\t}\n}\n\nvoid display( char *msg )\n{\n\tint i;\n\tfor (i=0; i<64; i++)\n\t{\n\t\tprintf( \"%1d\", (msg[i] ? 1 : 0) );\n\t}\n\tprintf(\"\\n\");\n}\n\nint\nmain( int argc, char **argv )\n{\n\tint retval;\n\n\tconst PAPI_shlib_info_t *shinfo;\n\n\ttests_quiet( argc, argv );\t/* Set TESTS_QUIET variable */\n\n\tif ( ( retval =\n\t\t   PAPI_library_init( PAPI_VER_CURRENT ) ) != PAPI_VER_CURRENT )\n\t\ttest_fail( __FILE__, __LINE__, \"PAPI_library_init\", retval );\n\n\tif ( ( shinfo = PAPI_get_shared_lib_info(  ) ) == NULL ) {\n\t\ttest_skip( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t}\n\n\tif ( ( shinfo->count == 0 ) && ( shinfo->map ) ) {\n\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t}\n\n\tprint_shlib_info_map(shinfo);\n\n\tsleep( 1 );\t\t\t\t /* Needed for debugging, so you can ^Z and stop the process, inspect /proc to see if it's right */\n\n#ifndef NO_DLFCN\n\t{\n\t\tchar *_libname = \"libcrypt.so\";\n\t\tvoid *handle;\n\t\tvoid ( *setkey) (const char *key);\n\t\tvoid ( *encrypt) (char block[64], int edflag);\n\t\tchar key[64]={\n\t\t\t1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,\n\t\t\t1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,\n\t\t\t1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,\n\t\t\t1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,\n\t\t}; /* bit pattern for key */\n\t\tchar orig[64];      /* bit pattern for messages */\n\t\tchar txt[64];      \t    /* bit pattern for messages */\n\n\t\tint oldcount;\n\n\t\thandle = dlopen( _libname, RTLD_NOW );\n\t\tif ( !handle ) {\n\t\t\tprintf( \"dlopen: %s\\n\", dlerror(  ) );\n\t\t\tprintf\n\t\t\t\t( \"Did you forget to set the environmental variable LIBPATH (in AIX) or LD_LIBRARY_PATH (in linux) ?\\n\" );\n\t\t\ttest_fail( __FILE__, __LINE__, \"dlopen\", 1 );\n\t\t}\n\n\t\tsetkey = dlsym( handle, \"setkey\" );\n\t\tencrypt = dlsym( handle, \"encrypt\" );\n\t\tif ( setkey == NULL || encrypt == NULL) {\n\t\t\tprintf( \"dlsym: %s\\n\", dlerror(  ) );\n\t\t\ttest_fail( __FILE__, __LINE__, \"dlsym\", 1 );\n\t\t}\n\n\t\tmemset(orig,0,64);\n\t\tmemcpy(txt,orig,64);\n\t\tsetkey(key);\n\t\t\n\t\tprintf(\"original  \"); display(txt);\n\t\tencrypt(txt, 0);   /* encode */\n\t\tprintf(\"encrypted \"); display(txt);\n\t\tif (!memcmp(txt,orig,64))\n\t\t\ttest_fail( __FILE__, __LINE__, \"encode\", 1 );\n\t\tencrypt(txt, 1);   /* decode */\n\t\tprintf(\"decrypted \"); display(txt);\n\t\tif (memcmp(txt,orig,64))\n\t\t\ttest_fail( __FILE__, __LINE__, \"decode\", 1 );\n \n\n\t\toldcount = shinfo->count;\n\n\t\tif ( ( shinfo = PAPI_get_shared_lib_info(  ) ) == NULL ) {\n\t\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t\t}\n\n\t\tsleep( 1 );\t\t\t /* Needed for debugging, so you can ^Z and stop the process, inspect /proc to see if it's right */\n\n\t\tif ( ( shinfo->count == 0 ) && ( shinfo->map ) ) {\n\t\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t\t}\n\n\t\tif ( shinfo->count <= oldcount ) {\n\t\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t\t}\n\n\t\tprint_shlib_info_map(shinfo);\n\n\t\tsleep( 1 );\t\t\t /* Needed for debugging, so you can ^Z and stop the process, inspect /proc to see if it's right */\n\n\t\tdlclose( handle );\n\t}\n#endif\n\n\ttest_pass( __FILE__, NULL, 0 );\n\texit( 0 );\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/components/vmware/vmware.c": "/****************************/\n/* THIS IS OPEN SOURCE CODE */\n/****************************/\n\n/**\n * @file    mware.c\n * @author  Matt Johnson\n *          mrj@eecs.utk.edu\n * @author  John Nelson\n *          jnelso37@eecs.utk.edu\n * @author  Vince Weaver\n *          vweaver1@eecs.utk.edu\n *\n * @ingroup papi_components\n *\n * VMware component\n *\n * @brief\n *\tThis is the VMware component for PAPI-V. It will allow user access to\n *\thardware information available from a VMware virtual machine.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n#include <unistd.h>\n#include <dlfcn.h>\n\n/* Headers required by PAPI */\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\n#define VMWARE_MAX_COUNTERS 256\n\n#define VMWARE_CPU_LIMIT_MHZ            0\n#define VMWARE_CPU_RESERVATION_MHZ      1\n#define VMWARE_CPU_SHARES               2\n#define VMWARE_CPU_STOLEN_MS            3\n#define VMWARE_CPU_USED_MS              4\n#define VMWARE_ELAPSED_MS               5\n\n#define VMWARE_MEM_ACTIVE_MB            6\n#define VMWARE_MEM_BALLOONED_MB         7\n#define VMWARE_MEM_LIMIT_MB             8\n#define VMWARE_MEM_MAPPED_MB            9\n#define VMWARE_MEM_OVERHEAD_MB          10\n#define VMWARE_MEM_RESERVATION_MB       11\n#define VMWARE_MEM_SHARED_MB            12\n#define VMWARE_MEM_SHARES               13\n#define VMWARE_MEM_SWAPPED_MB           14\n#define VMWARE_MEM_TARGET_SIZE_MB       15\n#define VMWARE_MEM_USED_MB              16\n\n#define VMWARE_HOST_CPU_MHZ             17\n\n/* The following 3 require VMWARE_PSEUDO_PERFORMANCE env_var to be set. */\n\n#define VMWARE_HOST_TSC\t\t\t18\n#define VMWARE_ELAPSED_TIME             19\n#define VMWARE_ELAPSED_APPARENT         20\n\n/* Begin PAPI definitions */\npapi_vector_t _vmware_vector;\n\n\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));\n\n/** Structure that stores private information for each event */\nstruct _vmware_register {\n    unsigned int selector;\n    /**< Signifies which counter slot is being used */\n    /**< Indexed from 1 as 0 has a special meaning  */\n};\n\n/** This structure is used to build the table of events */\nstruct _vmware_native_event_entry {\n\tchar name[PAPI_MAX_STR_LEN];        /**< Name of the counter         */\n\tchar description[PAPI_HUGE_STR_LEN]; /**< Description of counter     */\n        char units[PAPI_MIN_STR_LEN];\n        int which_counter;\n        int report_difference;\n};\n\nstruct _vmware_reg_alloc {\n\tstruct _vmware_register ra_bits;\n};\n\n\ninline uint64_t rdpmc(int c)\n{\n  uint32_t low, high;\n  __asm__ __volatile__(\"rdpmc\" : \"=a\" (low), \"=d\" (high) : \"c\" (c));\n  return (uint64_t)high << 32 | (uint64_t)low;\n}\n\n\n\n#ifdef VMGUESTLIB\n/* Headers required by VMware */\n#include \"vmGuestLib.h\"\n\n/* Functions to dynamically load from the GuestLib library. */\nchar const * (*GuestLib_GetErrorText)(VMGuestLibError);\nVMGuestLibError (*GuestLib_OpenHandle)(VMGuestLibHandle*);\nVMGuestLibError (*GuestLib_CloseHandle)(VMGuestLibHandle);\nVMGuestLibError (*GuestLib_UpdateInfo)(VMGuestLibHandle handle);\nVMGuestLibError (*GuestLib_GetSessionId)(VMGuestLibHandle handle, VMSessionId *id);\nVMGuestLibError (*GuestLib_GetCpuReservationMHz)(VMGuestLibHandle handle, uint32 *cpuReservationMHz);\nVMGuestLibError (*GuestLib_GetCpuLimitMHz)(VMGuestLibHandle handle, uint32 *cpuLimitMHz);\nVMGuestLibError (*GuestLib_GetCpuShares)(VMGuestLibHandle handle, uint32 *cpuShares);\nVMGuestLibError (*GuestLib_GetCpuUsedMs)(VMGuestLibHandle handle, uint64 *cpuUsedMs);\nVMGuestLibError (*GuestLib_GetHostProcessorSpeed)(VMGuestLibHandle handle, uint32 *mhz);\nVMGuestLibError (*GuestLib_GetMemReservationMB)(VMGuestLibHandle handle, uint32 *memReservationMB);\nVMGuestLibError (*GuestLib_GetMemLimitMB)(VMGuestLibHandle handle, uint32 *memLimitMB);\nVMGuestLibError (*GuestLib_GetMemShares)(VMGuestLibHandle handle, uint32 *memShares);\nVMGuestLibError (*GuestLib_GetMemMappedMB)(VMGuestLibHandle handle, uint32 *memMappedMB);\nVMGuestLibError (*GuestLib_GetMemActiveMB)(VMGuestLibHandle handle, uint32 *memActiveMB);\nVMGuestLibError (*GuestLib_GetMemOverheadMB)(VMGuestLibHandle handle, uint32 *memOverheadMB);\nVMGuestLibError (*GuestLib_GetMemBalloonedMB)(VMGuestLibHandle handle, uint32 *memBalloonedMB);\nVMGuestLibError (*GuestLib_GetMemSwappedMB)(VMGuestLibHandle handle, uint32 *memSwappedMB);\nVMGuestLibError (*GuestLib_GetMemSharedMB)(VMGuestLibHandle handle, uint32 *memSharedMB);\nVMGuestLibError (*GuestLib_GetMemSharedSavedMB)(VMGuestLibHandle handle, uint32 *memSharedSavedMB);\nVMGuestLibError (*GuestLib_GetMemUsedMB)(VMGuestLibHandle handle, uint32 *memUsedMB);\nVMGuestLibError (*GuestLib_GetElapsedMs)(VMGuestLibHandle handle, uint64 *elapsedMs);\nVMGuestLibError (*GuestLib_GetResourcePoolPath)(VMGuestLibHandle handle, size_t *bufferSize, char *pathBuffer);\nVMGuestLibError (*GuestLib_GetCpuStolenMs)(VMGuestLibHandle handle, uint64 *cpuStolenMs);\nVMGuestLibError (*GuestLib_GetMemTargetSizeMB)(VMGuestLibHandle handle, uint64 *memTargetSizeMB);\nVMGuestLibError (*GuestLib_GetHostNumCpuCores)(VMGuestLibHandle handle, uint32 *hostNumCpuCores);\nVMGuestLibError (*GuestLib_GetHostCpuUsedMs)(VMGuestLibHandle handle, uint64 *hostCpuUsedMs);\nVMGuestLibError (*GuestLib_GetHostMemSwappedMB)(VMGuestLibHandle handle, uint64 *hostMemSwappedMB);\nVMGuestLibError (*GuestLib_GetHostMemSharedMB)(VMGuestLibHandle handle, uint64 *hostMemSharedMB);\nVMGuestLibError (*GuestLib_GetHostMemUsedMB)(VMGuestLibHandle handle, uint64 *hostMemUsedMB);\nVMGuestLibError (*GuestLib_GetHostMemPhysMB)(VMGuestLibHandle handle, uint64 *hostMemPhysMB);\nVMGuestLibError (*GuestLib_GetHostMemPhysFreeMB)(VMGuestLibHandle handle, uint64 *hostMemPhysFreeMB);\nVMGuestLibError (*GuestLib_GetHostMemKernOvhdMB)(VMGuestLibHandle handle, uint64 *hostMemKernOvhdMB);\nVMGuestLibError (*GuestLib_GetHostMemMappedMB)(VMGuestLibHandle handle, uint64 *hostMemMappedMB);\nVMGuestLibError (*GuestLib_GetHostMemUnmappedMB)(VMGuestLibHandle handle, uint64 *hostMemUnmappedMB);\n\n\nstatic void *dlHandle = NULL;\n\n\n/*\n * Macro to load a single GuestLib function from the shared library.\n */\n\n#define LOAD_ONE_FUNC(funcname)                                 \\\ndo {                                                            \\\nfuncname = dlsym(dlHandle, \"VM\" #funcname);                     \\\nif ((dlErrStr = dlerror()) != NULL) {                           \\\nfprintf(stderr, \"Failed to load \\'%s\\': \\'%s\\'\\n\",              \\\n#funcname, dlErrStr);                                           \\\nreturn FALSE;                                                   \\\n}                                                               \\\n} while (0)\n\n#endif\n\n/** Holds control flags, usually out-of band configuration of the hardware */\nstruct _vmware_control_state {\n   long long value[VMWARE_MAX_COUNTERS];\n   int which_counter[VMWARE_MAX_COUNTERS];\n   int num_events;\n};\n\n/** Holds per-thread information */\nstruct _vmware_context {\n  long long values[VMWARE_MAX_COUNTERS];\n  long long start_values[VMWARE_MAX_COUNTERS];\n#ifdef VMGUESTLIB\n  VMGuestLibHandle glHandle;\n#endif\n};\n\n\n\n\n\n\n/*\n *-----------------------------------------------------------------------------\n *\n * LoadFunctions --\n *\n *      Load the functions from the shared library.\n *\n * Results:\n *      TRUE on success\n *      FALSE on failure\n *\n * Side effects:\n *      None\n *\n * Credit: VMware\n *-----------------------------------------------------------------------------\n */\n\nstatic int\nLoadFunctions(void)\n{\n\n#ifdef VMGUESTLIB\n\t/*\n\t * First, try to load the shared library.\n\t */\n\n\t/* Attempt to guess if we were statically linked to libc, if so bail */\n\tif ( _dl_non_dynamic_init != NULL ) {\n\t\tstrncpy(_vmware_vector.cmp_info.disabled_reason, \"The VMware component does not support statically linking of libc.\", PAPI_MAX_STR_LEN);\n\t\treturn PAPI_ENOSUPP;\n\t}\n\n\tchar const *dlErrStr;\n\tchar filename[BUFSIZ];\n\n\tsprintf(filename,\"%s\",\"libvmGuestLib.so\");\n\tdlHandle = dlopen(filename, RTLD_NOW);\n\tif (!dlHandle) {\n\t   dlErrStr = dlerror();\n\t   fprintf(stderr, \"dlopen of %s failed: \\'%s\\'\\n\", filename, \n\t\t   dlErrStr);\n\n\t   sprintf(filename,\"%s/lib/lib64/libvmGuestLib.so\",VMWARE_INCDIR);\n\t   dlHandle = dlopen(filename, RTLD_NOW);\n\t   if (!dlHandle) {\n\t      dlErrStr = dlerror();\n\t      fprintf(stderr, \"dlopen of %s failed: \\'%s\\'\\n\", filename, \n\t\t   dlErrStr);\n\n\t      sprintf(filename,\"%s/lib/lib32/libvmGuestLib.so\",VMWARE_INCDIR);\n\t      dlHandle = dlopen(filename, RTLD_NOW);\n\t      if (!dlHandle) {\n\t         dlErrStr = dlerror();\n\t         fprintf(stderr, \"dlopen of %s failed: \\'%s\\'\\n\", filename, \n\t\t      dlErrStr);\n\t\t return PAPI_ECMP;\n\t      }\n\t   }\n\t}\n\n\t/* Load all the individual library functions. */\n\tLOAD_ONE_FUNC(GuestLib_GetErrorText);\n\tLOAD_ONE_FUNC(GuestLib_OpenHandle);\n\tLOAD_ONE_FUNC(GuestLib_CloseHandle);\n\tLOAD_ONE_FUNC(GuestLib_UpdateInfo);\n\tLOAD_ONE_FUNC(GuestLib_GetSessionId);\n\tLOAD_ONE_FUNC(GuestLib_GetCpuReservationMHz);\n\tLOAD_ONE_FUNC(GuestLib_GetCpuLimitMHz);\n\tLOAD_ONE_FUNC(GuestLib_GetCpuShares);\n\tLOAD_ONE_FUNC(GuestLib_GetCpuUsedMs);\n\tLOAD_ONE_FUNC(GuestLib_GetHostProcessorSpeed);\n\tLOAD_ONE_FUNC(GuestLib_GetMemReservationMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemLimitMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemShares);\n\tLOAD_ONE_FUNC(GuestLib_GetMemMappedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemActiveMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemOverheadMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemBalloonedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemSwappedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemSharedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemSharedSavedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemUsedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetElapsedMs);\n\tLOAD_ONE_FUNC(GuestLib_GetResourcePoolPath);\n\tLOAD_ONE_FUNC(GuestLib_GetCpuStolenMs);\n\tLOAD_ONE_FUNC(GuestLib_GetMemTargetSizeMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostNumCpuCores);\n\tLOAD_ONE_FUNC(GuestLib_GetHostCpuUsedMs);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemSwappedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemSharedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemUsedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemPhysMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemPhysFreeMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemKernOvhdMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemMappedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemUnmappedMB);\n#endif\n\treturn PAPI_OK;\n}\n\n\n\n/** This table contains the native events */\nstatic struct _vmware_native_event_entry *_vmware_native_table;\n/** number of events in the table*/\nstatic int num_events = 0;\nstatic int use_pseudo=0;\nstatic int use_guestlib=0;\n\n/************************************************************************/\n/* Below is the actual \"hardware implementation\" of our VMWARE counters */\n/************************************************************************/\n\n/** Code that reads event values.\n You might replace this with code that accesses\n hardware or reads values from the operatings system. */\nstatic long long\n_vmware_hardware_read( struct _vmware_context *context, int starting)\n{\n\n  int i;\n\n\tif (use_pseudo) {\n           context->values[VMWARE_HOST_TSC]=rdpmc(0x10000);\n           context->values[VMWARE_ELAPSED_TIME]=rdpmc(0x10001);\n           context->values[VMWARE_ELAPSED_APPARENT]=rdpmc(0x10002);\n\t}\n\n\n#ifdef VMGUESTLIB\n\tstatic VMSessionId sessionId = 0;\n\tVMSessionId tmpSession;\n\tuint32_t temp32;\n\tuint64_t temp64;\n\tVMGuestLibError glError;\n\n\tif (use_guestlib) {\n\n\tglError = GuestLib_UpdateInfo(context->glHandle);\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"UpdateInfo failed: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   \t   return PAPI_ECMP;\n\t}\n\n\t/* Retrieve and check the session ID */\n\tglError = GuestLib_GetSessionId(context->glHandle, &tmpSession);\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get session ID: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tif (tmpSession == 0) {\n\t   fprintf(stderr, \"Error: Got zero sessionId from GuestLib\\n\");\n\t   return PAPI_ECMP;\n\t}\n\n\tif (sessionId == 0) {\n\t   sessionId = tmpSession;\n\t} else if (tmpSession != sessionId) {\n\t   sessionId = tmpSession;\n\t}\n\n\tglError = GuestLib_GetCpuLimitMHz(context->glHandle,&temp32);\n\tcontext->values[VMWARE_CPU_LIMIT_MHZ]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"Failed to get CPU limit: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetCpuReservationMHz(context->glHandle,&temp32); \n\tcontext->values[VMWARE_CPU_RESERVATION_MHZ]=temp32;\n        if (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"Failed to get CPU reservation: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t\n\tglError = GuestLib_GetCpuShares(context->glHandle,&temp32);\n\tcontext->values[VMWARE_CPU_SHARES]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"Failed to get cpu shares: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetCpuStolenMs(context->glHandle,&temp64);\n\tcontext->values[VMWARE_CPU_STOLEN_MS]=temp64;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   if (glError == VMGUESTLIB_ERROR_UNSUPPORTED_VERSION) {\n\t      context->values[VMWARE_CPU_STOLEN_MS]=0;\n\t      fprintf(stderr, \"Skipping CPU stolen, not supported...\\n\");\n\t   } else {\n\t      fprintf(stderr, \"Failed to get CPU stolen: %s\\n\", \n\t\t      GuestLib_GetErrorText(glError));\n\t      return PAPI_ECMP;\n\t   }\n\t}\n\n\tglError = GuestLib_GetCpuUsedMs(context->glHandle,&temp64);\n\tcontext->values[VMWARE_CPU_USED_MS]=temp64;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get used ms: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t\n\tglError = GuestLib_GetElapsedMs(context->glHandle, &temp64);\n\tcontext->values[VMWARE_ELAPSED_MS]=temp64;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get elapsed ms: %s\\n\",\n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetMemActiveMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_ACTIVE_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get active mem: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t\n\tglError = GuestLib_GetMemBalloonedMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_BALLOONED_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get ballooned mem: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t\n\tglError = GuestLib_GetMemLimitMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_LIMIT_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"Failed to get mem limit: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n        glError = GuestLib_GetMemMappedMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_MAPPED_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get mapped mem: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetMemOverheadMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_OVERHEAD_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get overhead mem: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetMemReservationMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_RESERVATION_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get mem reservation: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n        glError = GuestLib_GetMemSharedMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_SHARED_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get swapped mem: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetMemShares(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_SHARES]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   if (glError == VMGUESTLIB_ERROR_NOT_AVAILABLE) {\n\t      context->values[VMWARE_MEM_SHARES]=0;\n\t      fprintf(stderr, \"Skipping mem shares, not supported...\\n\");\n\t   } else {\n\t      fprintf(stderr, \"Failed to get mem shares: %s\\n\", \n\t\t      GuestLib_GetErrorText(glError));\n\t      return PAPI_ECMP;\n\t   }\n\t}\n\n\tglError = GuestLib_GetMemSwappedMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_SWAPPED_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get swapped mem: %s\\n\",\n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t\n\tglError = GuestLib_GetMemTargetSizeMB(context->glHandle, &temp64);\n\tcontext->values[VMWARE_MEM_TARGET_SIZE_MB]=temp64;\n        if (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   if (glError == VMGUESTLIB_ERROR_UNSUPPORTED_VERSION) {\n\t      context->values[VMWARE_MEM_TARGET_SIZE_MB]=0;\n\t      fprintf(stderr, \"Skipping target mem size, not supported...\\n\");\n\t   } else {\n\t      fprintf(stderr, \"Failed to get target mem size: %s\\n\", \n\t\t      GuestLib_GetErrorText(glError));\n\t      return PAPI_ECMP;\n\t   }\n\t}\n\n        glError = GuestLib_GetMemUsedMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_USED_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get swapped mem: %s\\n\",\n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n        glError = GuestLib_GetHostProcessorSpeed(context->glHandle, &temp32); \n\tcontext->values[VMWARE_HOST_CPU_MHZ]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get host proc speed: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t}\n\n#endif\n\n\tif (starting) {\n\n\t  for(i=0;i<VMWARE_MAX_COUNTERS;i++) {\n\t    context->start_values[i]=context->values[i];\n\t  }\n\n\t}\n\n\treturn PAPI_OK;\n}\n\n/********************************************************************/\n/* Below are the functions required by the PAPI component interface */\n/********************************************************************/\n\n/** This is called whenever a thread is initialized */\nint\n_vmware_init_thread( hwd_context_t *ctx )\n{\n\t(void) ctx;\n\n\n#ifdef VMGUESTLIB\n\n\tstruct _vmware_context *context;\n\tVMGuestLibError glError;\n\n\tcontext=(struct _vmware_context *)ctx;\n\n\tif (use_guestlib) {\n\t   glError = GuestLib_OpenHandle(&(context->glHandle));\n\t   if (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t      fprintf(stderr,\"OpenHandle failed: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t      return PAPI_ECMP;\n\t   }\n\t}\n\n#endif\n\n\treturn PAPI_OK;\n}\n\n\n/** Initialize hardware counters, setup the function vector table\n * and get hardware information, this routine is called when the\n * PAPI process is initialized (IE PAPI_library_init)\n */\nint\n_vmware_init_component( int cidx )\n{\n\n  (void) cidx;\n\n  int result;\n\n\tSUBDBG( \"_vmware_init_component...\" );\n\n\t/* Initialize and try to load the VMware library */\n\t/* Try to load the library. */\n\tresult=LoadFunctions();\n\n\tif (result!=PAPI_OK) {\n\t   strncpy(_vmware_vector.cmp_info.disabled_reason,\n\t\t  \"GuestLibTest: Failed to load shared library\",\n\t\t   PAPI_MAX_STR_LEN);\n\t   return PAPI_ECMP;\n\t}\n\n\t/* we know in advance how many events we want                       */\n\t/* for actual hardware this might have to be determined dynamically */\n\n\t/* Allocate memory for the our event table */\n\t_vmware_native_table = ( struct _vmware_native_event_entry * )\n\t  calloc( VMWARE_MAX_COUNTERS, sizeof ( struct _vmware_native_event_entry ));\n\tif ( _vmware_native_table == NULL ) {\n\t   return PAPI_ENOMEM;\n\t}\n\n\n#ifdef VMGUESTLIB\n\n\t/* Detect if GuestLib works */\n\t{\n\n        VMGuestLibError glError;\n        VMGuestLibHandle glHandle;\n\n\tuse_guestlib=0;\n\n\t/* try to open */\n\tglError = GuestLib_OpenHandle(&glHandle);\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"OpenHandle failed: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t}\n\telse {\n\t   /* open worked, try to update */\n\t   glError = GuestLib_UpdateInfo(glHandle);\n\t   if (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t      fprintf(stderr,\"UpdateInfo failed: %s\\n\", \n\t\t      GuestLib_GetErrorText(glError));\n\t   }\n\t   else {\n\t      /* update worked, things work! */\n\t      use_guestlib=1;\n\t   }\n\t   /* shut things down */\n\t   glError = GuestLib_CloseHandle(glHandle);\n\t}\n\n        }\n\n\n\n\tif (use_guestlib) {\n\n\t/* fill in the event table parameters */\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"CPU_LIMIT\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the upper limit of processor use in MHz \"\n\t\t\"available to the virtual machine.\",\n\t\tPAPI_HUGE_STR_LEN);\n\tstrcpy( _vmware_native_table[num_events].units,\"MHz\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_CPU_LIMIT_MHZ;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"CPU_RESERVATION\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the minimum processing power in MHz \"\n\t\t\"reserved for the virtual machine.\",\n\t\tPAPI_HUGE_STR_LEN);\n\tstrcpy( _vmware_native_table[num_events].units,\"MHz\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_CPU_RESERVATION_MHZ;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"CPU_SHARES\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the number of CPU shares allocated \"\n\t\t\"to the virtual machine.\",\n\t\tPAPI_HUGE_STR_LEN);\n\tstrcpy( _vmware_native_table[num_events].units,\"shares\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_CPU_SHARES;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"CPU_STOLEN\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the number of milliseconds that the \"\n\t\t\"virtual machine was in a ready state (able to \"\n\t\t\"transition to a run state), but was not scheduled to run.\",\n\t\tPAPI_HUGE_STR_LEN);\n\tstrcpy( _vmware_native_table[num_events].units,\"ms\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_CPU_STOLEN_MS;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"CPU_USED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the number of milliseconds during which \"\n\t\t\"the virtual machine has used the CPU. This value \"\n\t\t\"includes the time used by the guest operating system \"\n\t\t\"and the time used by virtualization code for tasks for \"\n\t\t\"this virtual machine. You can combine this value with \"\n\t\t\"the elapsed time (VMWARE_ELAPSED) to estimate the \"\n\t\t\"effective virtual machine CPU speed. This value is a \"\n\t\t\"subset of elapsedMs.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"ms\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_CPU_USED_MS;\n\t_vmware_native_table[num_events].report_difference=1;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"ELAPSED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the number of milliseconds that have passed \"\n\t\t\"in the virtual machine since it last started running on \"\n\t\t\"the server. The count of elapsed time restarts each time \"\n\t\t\"the virtual machine is powered on, resumed, or migrated \"\n\t\t\"using VMotion. This value counts milliseconds, regardless \"\n\t\t\"of whether the virtual machine is using processing power \"\n\t\t\"during that time. You can combine this value with the CPU \"\n\t\t\"time used by the virtual machine (VMWARE_CPU_USED) to \"\n\t\t\"estimate the effective virtual machine xCPU speed. \"\n\t\t\"cpuUsedMS is a subset of this value.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"ms\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_ELAPSED_MS;\n\t_vmware_native_table[num_events].report_difference=1;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_ACTIVE\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t \"Retrieves the amount of memory the virtual machine is \"\n\t\t \"actively using in MB - Its estimated working set size.\",\n\t\t PAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n                 VMWARE_MEM_ACTIVE_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_BALLOONED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the amount of memory that has been reclaimed \"\n\t\t\"from this virtual machine by the vSphere memory balloon \"\n\t\t\"driver (also referred to as the 'vmemctl' driver) in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_BALLOONED_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_LIMIT\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the upper limit of memory that is available \"\n\t\t\"to the virtual machine in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_LIMIT_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_MAPPED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the amount of memory that is allocated to \"\n\t\t\"the virtual machine in MB. Memory that is ballooned, \"\n\t\t\"swapped, or has never been accessed is excluded.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_MAPPED_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_OVERHEAD\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the amount of 'overhead' memory associated \"\n\t\t\"with this virtual machine that is currently consumed \"\n\t\t\"on the host system in MB. Overhead memory is additional \"\n\t\t\"memory that is reserved for data structures required by \"\n\t\t\"the virtualization layer.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_OVERHEAD_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_RESERVATION\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the minimum amount of memory that is \"\n\t\t\"reserved for the virtual machine in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_RESERVATION_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_SHARED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the amount of physical memory associated \"\n\t\t\"with this virtual machine that is copy-on-write (COW) \"\n\t\t\"shared on the host in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_SHARED_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_SHARES\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the number of memory shares allocated to \"\n\t\t\"the virtual machine.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"shares\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_SHARES;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_SWAPPED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the amount of memory that has been reclaimed \"\n\t\t\"from this virtual machine by transparently swapping \"\n\t\t\"guest memory to disk in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_SWAPPED_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_TARGET_SIZE\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the size of the target memory allocation \"\n\t\t\"for this virtual machine in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_TARGET_SIZE_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_USED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the estimated amount of physical host memory \"\n\t\t\"currently consumed for this virtual machine's \"\n\t\t\"physical memory.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_USED_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"HOST_CPU\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the speed of the ESX system's physical \"\n\t\t\"CPU in MHz.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MHz\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_HOST_CPU_MHZ;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\t}\n\n#endif\n\n\t/* For VMWare Pseudo Performance Counters */\n\tif ( getenv( \"PAPI_VMWARE_PSEUDOPERFORMANCE\" ) ) {\n\n\t        use_pseudo=1;\n\n\t\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\t\"HOST_TSC\" );\n\t\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\t\"Physical host TSC\",\n\t\t\tPAPI_HUGE_STR_LEN );\n\t\tstrcpy( _vmware_native_table[num_events].units,\"cycles\");\n\t\t_vmware_native_table[num_events].which_counter=\n\t\t        VMWARE_HOST_TSC;\n\t        _vmware_native_table[num_events].report_difference=1;\n\t\tnum_events++;\n\n\t\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\t\"ELAPSED_TIME\" );\n\t\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\t\"Elapsed real time in ns.\",\n\t\t\tPAPI_HUGE_STR_LEN );\n\t        strcpy( _vmware_native_table[num_events].units,\"ns\");\n\t\t_vmware_native_table[num_events].which_counter=\n\t\t        VMWARE_ELAPSED_TIME;\n\t        _vmware_native_table[num_events].report_difference=1;\n\t\tnum_events++;\n\n\t\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\t\"ELAPSED_APPARENT\" );\n\t\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\t\"Elapsed apparent time in ns.\",\n\t\t\tPAPI_HUGE_STR_LEN );\n\t        strcpy( _vmware_native_table[num_events].units,\"ns\");\n\t\t_vmware_native_table[num_events].which_counter=\n\t\t        VMWARE_ELAPSED_APPARENT;\n\t        _vmware_native_table[num_events].report_difference=1;\n\t\tnum_events++;\n\t}\n\n\tif (num_events==0) {\n\t   strncpy(_vmware_vector.cmp_info.disabled_reason,\n\t\t  \"VMware SDK not installed, and PAPI_VMWARE_PSEUDOPERFORMANCE not set\",\n\t\t   PAPI_MAX_STR_LEN);\n\t  return PAPI_ECMP;\n\t}\n\n\t_vmware_vector.cmp_info.num_native_events = num_events;\n\n\treturn PAPI_OK;\n}\n\n/** Setup the counter control structure */\nint\n_vmware_init_control_state( hwd_control_state_t *ctl )\n{\n  (void) ctl;\n\n\treturn PAPI_OK;\n}\n\n/** Enumerate Native Events \n @param EventCode is the event of interest\n @param modifier is one of PAPI_ENUM_FIRST, PAPI_ENUM_EVENTS\n */\nint\n_vmware_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n\n\tswitch ( modifier ) {\n\t\t\t/* return EventCode of first event */\n\t\tcase PAPI_ENUM_FIRST:\n\t\t     if (num_events==0) return PAPI_ENOEVNT;\n\t\t     *EventCode = 0;\n\t\t     return PAPI_OK;\n\t\t     break;\n\t\t\t/* return EventCode of passed-in Event */\n\t\tcase PAPI_ENUM_EVENTS:{\n\t\t     int index = *EventCode;\n\n\t\t     if ( index < num_events - 1 ) {\n\t\t\t*EventCode = *EventCode + 1;\n\t\t\treturn PAPI_OK;\n\t\t     } else {\n\t\t\treturn PAPI_ENOEVNT;\n\t\t     }\n\t\t     break;\n\t\t}\n\t\tdefault:\n\t\t     return PAPI_EINVAL;\n\t}\n\treturn PAPI_EINVAL;\n}\n\nint\n_vmware_ntv_code_to_info(unsigned int EventCode, PAPI_event_info_t *info) \n{\n\n  int index = EventCode;\n\n  if ( ( index < 0) || (index >= num_events )) return PAPI_ENOEVNT;\n\n  strncpy( info->symbol, _vmware_native_table[index].name, \n           sizeof(info->symbol));\n\n  strncpy( info->long_descr, _vmware_native_table[index].description, \n           sizeof(info->symbol));\n\n  strncpy( info->units, _vmware_native_table[index].units, \n           sizeof(info->units));\n\n  return PAPI_OK;\n}\n\n\n/** Takes a native event code and passes back the name \n @param EventCode is the native event code\n @param name is a pointer for the name to be copied to\n @param len is the size of the string\n */\nint\n_vmware_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n\tint index = EventCode;\n\n\tif ( index >= 0 && index < num_events ) {\n\t   strncpy( name, _vmware_native_table[index].name, len );\n\t}\n\treturn PAPI_OK;\n}\n\n/** Takes a native event code and passes back the event description\n @param EventCode is the native event code\n @param name is a pointer for the description to be copied to\n @param len is the size of the string\n */\nint\n_vmware_ntv_code_to_descr( unsigned int EventCode, char *name, int len )\n{\n  int index = EventCode;\n\n\tif ( index >= 0 && index < num_events ) {\n\t   strncpy( name, _vmware_native_table[index].description, len );\n\t}\n\treturn PAPI_OK;\n}\n\n/** Triggered by eventset operations like add or remove */\nint\n_vmware_update_control_state( hwd_control_state_t *ctl, \n\t\t\t      NativeInfo_t *native, \n\t\t\t      int count, \n\t\t\t      hwd_context_t *ctx )\n{\n\t(void) ctx;\n\n\tstruct _vmware_control_state *control;\n\n\tint i, index;\n\n\tcontrol=(struct _vmware_control_state *)ctl;\n\n\tfor ( i = 0; i < count; i++ ) {\n\t    index = native[i].ni_event;\n\t    control->which_counter[i]=_vmware_native_table[index].which_counter;\n\t    native[i].ni_position = i;\n\t}\n\tcontrol->num_events=count;\n\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_start() */\nint\n_vmware_start( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\tstruct _vmware_context *context;\n\t(void) ctl;\n\n\tcontext=(struct _vmware_context *)ctx;\n\n\t_vmware_hardware_read( context, 1 );\n\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_stop() */\nint\n_vmware_stop( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\n\tstruct _vmware_context *context;\n\t(void) ctl;\n\n\tcontext=(struct _vmware_context *)ctx;\n\n\t_vmware_hardware_read( context, 0 );\t\n\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_read() */\nint\n_vmware_read( hwd_context_t *ctx, \n\t      hwd_control_state_t *ctl,\n\t      long_long **events, int flags )\n{\n\n\tstruct _vmware_context *context;\n\tstruct _vmware_control_state *control;\n\n\t(void) flags;\n\tint i;\n\n\tcontext=(struct _vmware_context *)ctx;\n\tcontrol=(struct _vmware_control_state *)ctl;\n\n\t_vmware_hardware_read( context, 0 );\n\n\tfor (i=0; i<control->num_events; i++) {\n\t  \n\t  if (_vmware_native_table[\n              _vmware_native_table[control->which_counter[i]].which_counter].\n             report_difference) {\n\t     control->value[i]=context->values[control->which_counter[i]]-\n\t                       context->start_values[control->which_counter[i]];\n\t  } else {\n\t     control->value[i]=context->values[control->which_counter[i]];\n\t  }\n\t  //\t  printf(\"%d %d %lld-%lld=%lld\\n\",i,control->which_counter[i],\n\t  // context->values[control->which_counter[i]],\n\t  //\t context->start_values[control->which_counter[i]],\n\t  //\t control->value[i]);\n\n\t}\n\n\t*events = control->value;\n\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_write(), but only if the counters are running */\n/*    otherwise, the updated state is written to ESI->hw_start      */\nint\n_vmware_write( hwd_context_t * ctx, hwd_control_state_t * ctrl, long_long events[] )\n{\n\t(void) ctx;\n\t(void) ctrl;\n\t(void) events;\n\tSUBDBG( \"_vmware_write... %p %p\", ctx, ctrl );\n\t/* FIXME... this should actually carry out the write, though     */\n\t/*  this is non-trivial as which counter being written has to be */\n\t/*  determined somehow.                                          */\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_reset */\nint\n_vmware_reset( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\t(void) ctx;\n\t(void) ctl;\n\n\treturn PAPI_OK;\n}\n\n/** Shutting down a context */\nint\n_vmware_shutdown_thread( hwd_context_t *ctx )\n{\n\t(void) ctx;\n\n#ifdef VMGUESTLIB\n        VMGuestLibError glError;\n\tstruct _vmware_context *context;\n\n\tcontext=(struct _vmware_context *)ctx;\n\n\tif (use_guestlib) {\n           glError = GuestLib_CloseHandle(context->glHandle);\n           if (glError != VMGUESTLIB_ERROR_SUCCESS) {\n               fprintf(stderr, \"Failed to CloseHandle: %s\\n\", \n\t\t       GuestLib_GetErrorText(glError));\n               return PAPI_ECMP;\n\t   }\n\t}\n#endif\n\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_shutdown() */\nint\n_vmware_shutdown_component( void )\n{\n\n#ifdef VMGUESTLIB\n\tif (dlclose(dlHandle)) {\n\t\tfprintf(stderr, \"dlclose failed\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n#endif\n\n\treturn PAPI_OK;\n}\n\n\n/** This function sets various options in the component\n @param ctx\n @param code valid are PAPI_SET_DEFDOM, PAPI_SET_DOMAIN, PAPI_SETDEFGRN, PAPI_SET_GRANUL and PAPI_SET_INHERIT\n @param option\n */\nint\n_vmware_ctl( hwd_context_t *ctx, int code, _papi_int_option_t *option )\n{\n\n\t(void) ctx;\n\t(void) code;\n\t(void) option;\n\n\tSUBDBG( \"_vmware_ctl...\" );\n\n\treturn PAPI_OK;\n}\n\n/** This function has to set the bits needed to count different domains\n In particular: PAPI_DOM_USER, PAPI_DOM_KERNEL PAPI_DOM_OTHER\n By default return PAPI_EINVAL if none of those are specified\n and PAPI_OK with success\n PAPI_DOM_USER is only user context is counted\n PAPI_DOM_KERNEL is only the Kernel/OS context is counted\n PAPI_DOM_OTHER  is Exception/transient mode (like user TLB misses)\n PAPI_DOM_ALL   is all of the domains\n */\nint\n_vmware_set_domain( hwd_control_state_t *ctl, int domain )\n{\n\t(void) ctl;\n\n\tint found = 0;\n\tSUBDBG( \"_vmware_set_domain...\" );\n\tif ( PAPI_DOM_USER & domain ) {\n\t\tSUBDBG( \" PAPI_DOM_USER \" );\n\t\tfound = 1;\n\t}\n\tif ( PAPI_DOM_KERNEL & domain ) {\n\t\tSUBDBG( \" PAPI_DOM_KERNEL \" );\n\t\tfound = 1;\n\t}\n\tif ( PAPI_DOM_OTHER & domain ) {\n\t\tSUBDBG( \" PAPI_DOM_OTHER \" );\n\t\tfound = 1;\n\t}\n\tif ( PAPI_DOM_ALL & domain ) {\n\t\tSUBDBG( \" PAPI_DOM_ALL \" );\n\t\tfound = 1;\n\t}\n\tif ( !found ) {\n\t\treturn ( PAPI_EINVAL );\n\t}\n\treturn PAPI_OK;\n}\n\n/** Vector that points to entry points for our component */\npapi_vector_t _vmware_vector = {\n\t.cmp_info = {\n\t\t/* default component information (unspecified values are initialized to 0) */\n\t\t.name = \"vmware\",\n\t\t.short_name = \"vmware\",\n\t\t.description = \"Provide support for VMware vmguest and pseudo counters\",\n\t\t.version = \"5.0\",\n\t\t.num_mpx_cntrs = VMWARE_MAX_COUNTERS,\n\t\t.num_cntrs = VMWARE_MAX_COUNTERS,\n\t\t.default_domain = PAPI_DOM_USER,\n\t\t.available_domains = PAPI_DOM_USER,\n\t\t.default_granularity = PAPI_GRN_THR,\n\t\t.available_granularities = PAPI_GRN_THR,\n\t\t.hardware_intr_sig = PAPI_INT_SIGNAL,\n\n\t\t/* component specific cmp_info initializations */\n\t\t.fast_real_timer = 0,\n\t\t.fast_virtual_timer = 0,\n\t\t.attach = 0,\n\t\t.attach_must_ptrace = 0,\n\t},\n\t/* sizes of framework-opaque component-private structures */\n\t.size = {\n\t\t.context = sizeof ( struct _vmware_context ),\n\t\t.control_state = sizeof ( struct _vmware_control_state ),\n\t\t.reg_value = sizeof ( struct _vmware_register ),\n\t\t.reg_alloc = sizeof ( struct _vmware_reg_alloc ),\n\t}\n\t,\n\t/* function pointers in this component */\n\t.init_thread =        _vmware_init_thread,\n\t.init_component =     _vmware_init_component,\n\t.init_control_state = _vmware_init_control_state,\n\t.start =              _vmware_start,\n\t.stop =               _vmware_stop,\n\t.read =               _vmware_read,\n\t.write =              _vmware_write,\n\t.shutdown_thread =    _vmware_shutdown_thread,\n\t.shutdown_component = _vmware_shutdown_component,\n\t.ctl =                _vmware_ctl,\n\n\t.update_control_state = _vmware_update_control_state,\n\t.set_domain = _vmware_set_domain,\n\t.reset = _vmware_reset,\n\n\t.ntv_enum_events = _vmware_ntv_enum_events,\n\t.ntv_code_to_name = _vmware_ntv_code_to_name,\n\t.ntv_code_to_descr = _vmware_ntv_code_to_descr,\n\t.ntv_code_to_info = _vmware_ntv_code_to_info,\n\n};\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/components/nvml/linux-nvml.c": "/****************************/\n/* THIS IS OPEN SOURCE CODE */\n/****************************/\n\n/**\n * @file    linux-nvml.c\n * @author  Kiran Kumar Kasichayanula\n *          kkasicha@utk.edu \n * @author  James Ralph\n *          ralph@eecs.utk.edu\n * @ingroup papi_components\n *\n * @brief\n *\tThis is an NVML component, it demos the component interface\n *  and implements two counters nvmlDeviceGetPowerUsage, nvmlDeviceGetTemperature\n *  from Nvidia Management Library. Please refer to NVML documentation for details\n * about nvmlDeviceGetPowerUsage, nvmlDeviceGetTemperature. Power is reported in mW\n * and temperature in Celcius.\n */\n#include <dlfcn.h>\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <inttypes.h>\n#include <string.h>\n/* Headers required by PAPI */\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\n#include \"linux-nvml.h\"\n\n#include \"nvml.h\"\n#include \"cuda.h\"\n#include \"cuda_runtime_api.h\"\n\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));\n\n/*****  CHANGE PROTOTYPES TO DECLARE CUDA AND NVML LIBRARY SYMBOLS AS WEAK  *****\n *  This is done so that a version of PAPI built with the nvml component can    *\n *  be installed on a system which does not have the cuda libraries installed.  *\n *                                                                              *\n *  If this is done without these prototypes, then all papi services on the     *\n *  system without the cuda libraries installed will fail.  The PAPI libraries  *\n *  contain references to the cuda libraries which are not installed.  The      *\n *  load of PAPI commands fails because the cuda library references can not be  *\n *  resolved.                                                                   *\n *                                                                              *\n *  This also defines pointers to the cuda library functions that we call.      *\n *  These function pointers will be resolved with dlopen/dlsym calls at         *\n *  component initialization time.  The component then calls the cuda library   *\n *  functions through these function pointers.                                  *\n ********************************************************************************/\n#undef CUDAAPI\n#define CUDAAPI __attribute__((weak))\nCUresult CUDAAPI cuInit(unsigned int);\n\nCUresult (*cuInitPtr)(unsigned int);\n\n#undef CUDARTAPI\n#define CUDARTAPI __attribute__((weak))\ncudaError_t CUDARTAPI cudaGetDevice(int *);\ncudaError_t CUDARTAPI cudaGetDeviceCount(int *);\ncudaError_t CUDARTAPI cudaDeviceGetPCIBusId(char *, int, int);\n\ncudaError_t (*cudaGetDevicePtr)(int *);\ncudaError_t (*cudaGetDeviceCountPtr)(int *);\ncudaError_t (*cudaDeviceGetPCIBusIdPtr)(char *, int, int);\n\n#undef DECLDIR\n#define DECLDIR __attribute__((weak))\nnvmlReturn_t DECLDIR nvmlDeviceGetClockInfo                (nvmlDevice_t, nvmlClockType_t, unsigned int *);\nconst char*  DECLDIR nvmlErrorString                       (nvmlReturn_t);\nnvmlReturn_t DECLDIR nvmlDeviceGetDetailedEccErrors        (nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, nvmlEccErrorCounts_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetFanSpeed                 (nvmlDevice_t, unsigned int *);\nnvmlReturn_t DECLDIR nvmlDeviceGetMemoryInfo               (nvmlDevice_t, nvmlMemory_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetPerformanceState         (nvmlDevice_t, nvmlPstates_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetPowerUsage               (nvmlDevice_t, unsigned int *);\nnvmlReturn_t DECLDIR nvmlDeviceGetTemperature              (nvmlDevice_t, nvmlTemperatureSensors_t, unsigned int *);\nnvmlReturn_t DECLDIR nvmlDeviceGetTotalEccErrors           (nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, unsigned long long *);\nnvmlReturn_t DECLDIR nvmlDeviceGetUtilizationRates         (nvmlDevice_t, nvmlUtilization_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetHandleByIndex            (unsigned int, nvmlDevice_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetPciInfo                  (nvmlDevice_t, nvmlPciInfo_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetName                     (nvmlDevice_t, char *, unsigned int);\nnvmlReturn_t DECLDIR nvmlDeviceGetInforomVersion           (nvmlDevice_t, nvmlInforomObject_t, char *, unsigned int);\nnvmlReturn_t DECLDIR nvmlDeviceGetEccMode                  (nvmlDevice_t, nvmlEnableState_t *, nvmlEnableState_t *);\nnvmlReturn_t DECLDIR nvmlInit                              (void);\nnvmlReturn_t DECLDIR nvmlDeviceGetCount                    (unsigned int *);\nnvmlReturn_t DECLDIR nvmlShutdown                          (void);\n\nnvmlReturn_t       (*nvmlDeviceGetClockInfoPtr)            (nvmlDevice_t, nvmlClockType_t, unsigned int *);\nchar*              (*nvmlErrorStringPtr)                   (nvmlReturn_t);\nnvmlReturn_t       (*nvmlDeviceGetDetailedEccErrorsPtr)    (nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, nvmlEccErrorCounts_t *);\nnvmlReturn_t       (*nvmlDeviceGetFanSpeedPtr)             (nvmlDevice_t, unsigned int *);\nnvmlReturn_t       (*nvmlDeviceGetMemoryInfoPtr)           (nvmlDevice_t, nvmlMemory_t *);\nnvmlReturn_t       (*nvmlDeviceGetPerformanceStatePtr)     (nvmlDevice_t, nvmlPstates_t *);\nnvmlReturn_t       (*nvmlDeviceGetPowerUsagePtr)           (nvmlDevice_t, unsigned int *);\nnvmlReturn_t       (*nvmlDeviceGetTemperaturePtr)          (nvmlDevice_t, nvmlTemperatureSensors_t, unsigned int *);\nnvmlReturn_t       (*nvmlDeviceGetTotalEccErrorsPtr)       (nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, unsigned long long *);\nnvmlReturn_t       (*nvmlDeviceGetUtilizationRatesPtr)     (nvmlDevice_t, nvmlUtilization_t *);\nnvmlReturn_t       (*nvmlDeviceGetHandleByIndexPtr)        (unsigned int, nvmlDevice_t *);\nnvmlReturn_t       (*nvmlDeviceGetPciInfoPtr)              (nvmlDevice_t, nvmlPciInfo_t *);\nnvmlReturn_t       (*nvmlDeviceGetNamePtr)                 (nvmlDevice_t, char *, unsigned int);\nnvmlReturn_t       (*nvmlDeviceGetInforomVersionPtr)       (nvmlDevice_t, nvmlInforomObject_t, char *, unsigned int);\nnvmlReturn_t       (*nvmlDeviceGetEccModePtr)              (nvmlDevice_t, nvmlEnableState_t *, nvmlEnableState_t *);\nnvmlReturn_t       (*nvmlInitPtr)                          (void);\nnvmlReturn_t       (*nvmlDeviceGetCountPtr)                (unsigned int *);\nnvmlReturn_t       (*nvmlShutdownPtr)                      (void);\n\n\n// file handles used to access cuda libraries with dlopen\nstatic void* dl1 = NULL;\nstatic void* dl2 = NULL;\nstatic void* dl3 = NULL;\n\nstatic int linkCudaLibraries ();\n\n\n/* Declare our vector in advance */\npapi_vector_t _nvml_vector;\n\n/* upto 25 events per card how many cards per system should we allow for?! */\n#define NVML_MAX_COUNTERS 100\n\n/** Holds control flags.  Usually there's one of these per event-set.\n *    Usually this is out-of band configuration of the hardware \n */\ntypedef struct nvml_control_state\n{\n\t\tint num_events;\n\t\tint which_counter[NVML_MAX_COUNTERS];\n\t\tlong long counter[NVML_MAX_COUNTERS];   /**< Copy of counts, holds results when stopped */\n} nvml_control_state_t;\n\n/** Holds per-thread information */\ntypedef struct nvml_context\n{\n\t\tnvml_control_state_t state;\n} nvml_context_t;\n\n/** This table contains the native events */\nstatic nvml_native_event_entry_t *nvml_native_table=NULL;\n\n/** Number of devices detected at component_init time */\nstatic int device_count = 0;\n\n/** number of events in the table*/\nstatic int num_events = 0;\n\nstatic nvmlDevice_t* devices=NULL;\nstatic int*\t\t\t features=NULL;\n\nunsigned long long\ngetClockSpeed( nvmlDevice_t dev, nvmlClockType_t which_one )\n{\n\t\tunsigned int ret = 0;\n\t\tnvmlReturn_t bad; \n\t\tbad = (*nvmlDeviceGetClockInfoPtr)( dev, which_one, &ret );\n\n\t\tif ( NVML_SUCCESS != bad ) {\n\t\t\t\tSUBDBG( \"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n\t\t}\n\n\t\treturn (unsigned long long)ret;\n}\n\n\t\tunsigned long long\ngetEccLocalErrors( nvmlDevice_t dev, nvmlEccBitType_t bits, int which_one)\n{\n\t\tnvmlEccErrorCounts_t counts;\n\n\t\tnvmlReturn_t bad; \n\t\tbad = (*nvmlDeviceGetDetailedEccErrorsPtr)( dev, bits, NVML_VOLATILE_ECC , &counts);\n\n\t\tif ( NVML_SUCCESS != bad ) {\n\t\t\t\tSUBDBG( \"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n\t\t}\n\n\n\t\tswitch ( which_one ) {\n\t\t\t\tcase LOCAL_ECC_REGFILE:\n\t\t\t\t\t\treturn counts.registerFile;\n\t\t\t\tcase LOCAL_ECC_L1:\n\t\t\t\t\t\treturn counts.l1Cache;\n\t\t\t\tcase LOCAL_ECC_L2:\n\t\t\t\t\t\treturn counts.l2Cache;\n\t\t\t\tcase LOCAL_ECC_MEM:\n\t\t\t\t\t\treturn counts.deviceMemory;\n\t\t\t\tdefault:\n\t\t\t\t\t\t;\n\t\t}\n\t\treturn (unsigned long long)-1;\n}\n\n\t\tunsigned long long \ngetFanSpeed( nvmlDevice_t dev ) \n{\n\t\tunsigned int ret = 0;\n\t\tnvmlReturn_t bad; \n\t\tbad = (*nvmlDeviceGetFanSpeedPtr)( dev, &ret );\n\n\t\tif ( NVML_SUCCESS != bad ) {\n\t\t\t\tSUBDBG( \"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n\t\t}\n\n\n\t\treturn (unsigned long long)ret; \n}\n\n\t\tunsigned long long\ngetMaxClockSpeed( nvmlDevice_t dev, nvmlClockType_t which_one)\n{\n\t\tunsigned int ret = 0;\n\t\tnvmlReturn_t bad; \n\t\tbad = (*nvmlDeviceGetClockInfoPtr)( dev, which_one, &ret );\n\n\t\tif ( NVML_SUCCESS != bad ) {\n\t\t\t\tSUBDBG( \"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n\t\t}\n\n\n\t\treturn (unsigned long long) ret;\n}\n\n\t\tunsigned long long\ngetMemoryInfo( nvmlDevice_t dev, int which_one )\n{\n\t\tnvmlMemory_t meminfo;\n\t\tnvmlReturn_t bad; \n\t\tbad = (*nvmlDeviceGetMemoryInfoPtr)( dev, &meminfo );\n\n\t\tif ( NVML_SUCCESS != bad ) {\n\t\t\t\tSUBDBG( \"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n\t\t}\n\n\t\tswitch (which_one) {\n\t\t\t\tcase MEMINFO_TOTAL_MEMORY:\n\t\t\t\t\t\treturn meminfo.total;\n\t\t\t\tcase MEMINFO_UNALLOCED:\n\t\t\t\t\t\treturn meminfo.free;\n\t\t\t\tcase MEMINFO_ALLOCED:\n\t\t\t\t\t\treturn meminfo.used;\n\t\t\t\tdefault:\n\t\t\t\t\t\t;\n\t\t}\n\t\treturn (unsigned long long)-1;\n}\n\n\t\tunsigned long long\ngetPState( nvmlDevice_t dev ) \n{\n\t\tunsigned int ret = 0;\n\t\tnvmlPstates_t state = NVML_PSTATE_15;\n\t\tnvmlReturn_t bad; \n\t\tbad = (*nvmlDeviceGetPerformanceStatePtr)( dev, &state );\n\n\t\tif ( NVML_SUCCESS != bad ) {\n\t\t\t\tSUBDBG( \"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n\t\t}\n\n\n\t\tswitch ( state ) {\n\t\t\t\tcase NVML_PSTATE_15:\n\t\t\t\t\t\tret++;\n\t\t\t\tcase NVML_PSTATE_14:\n\t\t\t\t\t\tret++;\n\t\t\t\tcase NVML_PSTATE_13:\n\t\t\t\t\t\tret++;\n\t\t\t\tcase NVML_PSTATE_12:\n\t\t\t\t\t\tret++;\n\t\t\t\tcase NVML_PSTATE_11:\n\t\t\t\t\t\tret++;\n\t\t\t\tcase NVML_PSTATE_10:\n\t\t\t\t\t\tret++;\n\t\t\t\tcase NVML_PSTATE_9:\n\t\t\t\t\t\tret++;\n\t\t\t\tcase NVML_PSTATE_8:\n\t\t\t\t\t\tret++;\n\t\t\t\tcase NVML_PSTATE_7:\n\t\t\t\t\t\tret++;\n\t\t\t\tcase NVML_PSTATE_6:\n\t\t\t\t\t\tret++;\n\t\t\t\tcase NVML_PSTATE_5:\n\t\t\t\t\t\tret++;\n\t\t\t\tcase NVML_PSTATE_4:\n\t\t\t\t\t\tret++;\n\t\t\t\tcase NVML_PSTATE_3:\n\t\t\t\t\t\tret++;\n\t\t\t\tcase NVML_PSTATE_2:\n\t\t\t\t\t\tret++;\n\t\t\t\tcase NVML_PSTATE_1:\n\t\t\t\t\t\tret++;\n\t\t\t\tcase NVML_PSTATE_0:\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase NVML_PSTATE_UNKNOWN:\n\t\t\t\tdefault:\n\t\t\t\t\t\t/* This should never happen? \n\t\t\t\t\t\t * The API docs just state Unknown performance state... */\n\t\t\t\t\t\treturn (unsigned long long) -1;\n\t\t}\n\n\t\treturn (unsigned long long)ret;\n}\n\n\t\tunsigned long long\ngetPowerUsage( nvmlDevice_t dev )\n{\n\t\tunsigned int power;\n\t\tnvmlReturn_t bad; \n\t\tbad = (*nvmlDeviceGetPowerUsagePtr)( dev, &power );\n\n\t\tif ( NVML_SUCCESS != bad ) {\n\t\t\t\tSUBDBG( \"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n\t\t}\n\n\n\t\treturn (unsigned long long) power;\n}\n\n\t\tunsigned long long\ngetTemperature( nvmlDevice_t dev )\n{\n\t\tunsigned int ret = 0;\n\t\tnvmlReturn_t bad; \n\t\tbad = (*nvmlDeviceGetTemperaturePtr)( dev, NVML_TEMPERATURE_GPU, &ret );\n\n\t\tif ( NVML_SUCCESS != bad ) {\n\t\t\t\tSUBDBG( \"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n\t\t}\n\n\n\t\treturn (unsigned long long)ret;\n}\n\n\t\tunsigned long long\ngetTotalEccErrors( nvmlDevice_t dev, nvmlEccBitType_t bits) \n{\n\t\tunsigned long long counts = 0;\n\t\tnvmlReturn_t bad; \n\t\tbad = (*nvmlDeviceGetTotalEccErrorsPtr)( dev, bits, NVML_VOLATILE_ECC , &counts);\n\n\t\tif ( NVML_SUCCESS != bad ) {\n\t\t\t\tSUBDBG( \"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n\t\t}\n\n\n\t\treturn counts;\n}\n\n/* \t0 => gpu util\n\t1 => memory util\n */\n\t\tunsigned long long\ngetUtilization( nvmlDevice_t dev, int which_one )\n{\n\t\tnvmlUtilization_t util;\n\t\tnvmlReturn_t bad; \n\t\tbad = (*nvmlDeviceGetUtilizationRatesPtr)( dev, &util );\n\n\t\tif ( NVML_SUCCESS != bad ) {\n\t\t\t\tSUBDBG( \"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n\t\t}\n\n\n\t\tswitch (which_one) {\n\t\t\t\tcase GPU_UTILIZATION:\n\t\t\t\t\t\treturn (unsigned long long) util.gpu;\n\t\t\t\tcase MEMORY_UTILIZATION:\n\t\t\t\t\t\treturn (unsigned long long) util.memory;\n\t\t\t\tdefault:\n\t\t\t\t\t\t;\n\t\t}\n\n\t\treturn (unsigned long long) -1;\n}\n\n\t\tstatic void\nnvml_hardware_reset(  )\n{\n\t\t/* nvmlDeviceSet* and nvmlDeviceClear* calls require root/admin access, so while \n\t\t * possible to implement a reset on the ECC counters, we pass */\n\t\t/* \n\t\t   int i;\n\t\t   for ( i=0; i < device_count; i++ )\n\t\t   nvmlDeviceClearEccErrorCounts( device[i], NVML_VOLATILE_ECC ); \n\t\t */\n}\n\n/** Code that reads event values.                         */\n/*   You might replace this with code that accesses       */\n/*   hardware or reads values from the operatings system. */\n\t\tstatic int \nnvml_hardware_read( long long *value, int which_one)\n\t\t//, nvml_context_t *ctx)\n{\n\t\tnvml_native_event_entry_t *entry;\n\t\tnvmlDevice_t handle;\n\t\tint cudaIdx = -1;\n\n\t\tentry = &nvml_native_table[which_one];\n\t\t*value = (long long) -1;\n\t\t/* replace entry->resources with the current cuda_device->nvml device */\n\t\t(*cudaGetDevicePtr)( &cudaIdx );\n\n\t\tif ( cudaIdx < 0 || cudaIdx > device_count )\n\t\t\treturn PAPI_EINVAL;\n\n\t\t/* Make sure the device we are running on has the requested event */\n\t\tif ( !HAS_FEATURE( features[cudaIdx] , entry->type) ) \n\t\t\t\treturn PAPI_EINVAL;\n\n\t\thandle = devices[cudaIdx];\n\n\t\tswitch (entry->type) {\n\t\t\t\tcase FEATURE_CLOCK_INFO:\n\t\t\t\t\t\t*value =  getClockSpeed( \thandle, \n\t\t\t\t\t\t\t\t\t\t(nvmlClockType_t)entry->options.clock );\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase FEATURE_ECC_LOCAL_ERRORS:\n\t\t\t\t\t\t*value = getEccLocalErrors( \thandle, \n\t\t\t\t\t\t\t\t\t\t(nvmlEccBitType_t)entry->options.ecc_opts.bits, \n\t\t\t\t\t\t\t\t\t\t(int)entry->options.ecc_opts.which_one);\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase FEATURE_FAN_SPEED:\n\t\t\t\t\t\t*value = getFanSpeed( handle );\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase FEATURE_MAX_CLOCK:\n\t\t\t\t\t\t*value = getMaxClockSpeed( \thandle, \n\t\t\t\t\t\t\t\t\t\t(nvmlClockType_t)entry->options.clock );\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase FEATURE_MEMORY_INFO:\n\t\t\t\t\t\t*value = getMemoryInfo( \thandle, \n\t\t\t\t\t\t\t\t\t\t(int)entry->options.which_one );\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase FEATURE_PERF_STATES:\n\t\t\t\t\t\t*value = getPState( handle );\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase FEATURE_POWER:\n\t\t\t\t\t\t*value = getPowerUsage( handle );\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase FEATURE_TEMP:\n\t\t\t\t\t\t*value = getTemperature( handle );\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase FEATURE_ECC_TOTAL_ERRORS:\n\t\t\t\t\t\t*value = getTotalEccErrors( \thandle, \n\t\t\t\t\t\t\t\t\t\t(nvmlEccBitType_t)entry->options.ecc_opts.bits );\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase FEATURE_UTILIZATION:\n\t\t\t\t\t\t*value = getUtilization( \thandle, \n\t\t\t\t\t\t\t\t\t\t(int)entry->options.which_one );\n\t\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t\treturn PAPI_EINVAL;\n\t\t}\n\n\t\treturn PAPI_OK;\n\n\n}\n\n/********************************************************************/\n/* Below are the functions required by the PAPI component interface */\n/********************************************************************/\n\n/** This is called whenever a thread is initialized */\n\t\tint\n_papi_nvml_init_thread( hwd_context_t * ctx )\n{\n\t\t(void) ctx;\n\n\t\tSUBDBG( \"Enter: ctx: %p\\n\", ctx );\n\n\t\treturn PAPI_OK;\n}\n\n\t\tstatic int \ndetectDevices( ) \n{\n\t\tnvmlReturn_t ret;\n\t\tnvmlEnableState_t mode = NVML_FEATURE_DISABLED;\n\t\tnvmlDevice_t handle;\n\t\tnvmlPciInfo_t info;\n\n\t\tcudaError_t cuerr;\n\n\t\tchar busId[16];\n\t\tchar name[64];\n\t\tchar inforomECC[16];\n\t\tchar inforomPower[16];\n\t\tchar names[device_count][64];\n\t\tchar nvml_busIds[device_count][16];\n\n\t\tfloat ecc_version = 0.0, power_version = 0.0;\n\n\t\tint i = 0,\n\t\t\tj = 0;\n\t\tint isTesla = 0;\n\t\tint isFermi\t= 0;\n\t\tint isUnique = 1;\n\n\t\tunsigned int temp = 0;\n\n\n\t\t/* list of nvml pci_busids */\n\tfor (i=0; i < device_count; i++) {\n\t\tret = (*nvmlDeviceGetHandleByIndexPtr)( i, &handle );\n\t\tif ( NVML_SUCCESS != ret ) {\n\t\t\tSUBDBG(\"nvmlDeviceGetHandleByIndex(%d) failed\\n\", i);\n\t\t\treturn PAPI_ESYS;\n\t\t}\n\n\t\tret = (*nvmlDeviceGetPciInfoPtr)( handle, &info );\n\t\tif ( NVML_SUCCESS != ret ) {\n\t\t\tSUBDBG(\"nvmlDeviceGetPciInfo() failed %s\\n\", (*nvmlErrorStringPtr)(ret) );\n\t\t\treturn PAPI_ESYS;\n\t\t}\n\t\tstrncpy(nvml_busIds[i], info.busId, sizeof(nvml_busIds[i])-1);\n\t\tnvml_busIds[i][sizeof(nvml_busIds[i])-1] = '\\0';\n\t}\n\n\t/* We want to key our list of nvmlDevice_ts by each device's cuda index */\n\tfor (i=0; i < device_count; i++) {\n\t\t\tcuerr = (*cudaDeviceGetPCIBusIdPtr)( busId, 16, i );\n\t\t\tif ( CUDA_SUCCESS != cuerr ) {\n\t\t\t\tSUBDBG(\"cudaDeviceGetPCIBusId failed.\\n\");\n\t\t\t\treturn PAPI_ESYS;\n\t\t\t}\n\t\t\tfor (j=0; j < device_count; j++ ) {\n\t\t\t\t\tif ( !strncmp( busId, nvml_busIds[j], 16) ) {\n\t\t\t\t\t\t\tret = (*nvmlDeviceGetHandleByIndexPtr)(j, &devices[i] );\n\t\t\t\t\t\t\tif ( NVML_SUCCESS != ret ) {\n\t\t\t\t\t\t\t\tSUBDBG(\"nvmlDeviceGetHandleByIndex(%d, &devices[%d]) failed.\\n\", j, i);\n\t\t\t\t\t\t\t\treturn PAPI_ESYS;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\t\n\t}\n\n\t\tmemset(names, 0x0, device_count*64);\n\t\t/* So for each card, check whats querable */\n\t\tfor (i=0; i < device_count; i++ ) {\n\t\t\t\tisTesla=0;\n\t\t\t\tisFermi=1;\n\t\t\t\tisUnique = 1;\n\t\t\t\tfeatures[i] = 0;\n\n\t\t\t\tret = (*nvmlDeviceGetNamePtr)( devices[i], name, sizeof(name)-1 );\n\t\t\t\tif ( NVML_SUCCESS != ret) {\n\t\t\t\t\tSUBDBG(\"nvmlDeviceGetName failed \\n\");\n\t\t\t\t\treturn PAPI_ESYS;\n\t\t\t\t}\n\n\t\t\t\tname[sizeof(name)-1] = '\\0';\t// to safely use strstr operation below, the variable 'name' must be null terminated\n\n\t\t\t\tfor (j=0; j < i; j++ ) \n\t\t\t\t\t\tif ( 0 == strncmp( name, names[j], 64 ) ) {\n\t\t\t\t\t\t\t\t/* if we have a match, and IF everything is sane, \n\t\t\t\t\t\t\t\t * devices with the same name eg Tesla C2075 share features */\n\t\t\t\t\t\t\t\tisUnique = 0;\n\t\t\t\t\t\t\t\tfeatures[i] = features[j];\n\n\t\t\t\t\t\t}\n\n\t\t\t\tif ( isUnique ) {\n\t\t\t\t\t\tret = (*nvmlDeviceGetInforomVersionPtr)( devices[i], NVML_INFOROM_ECC, inforomECC, 16);\n\t\t\t\t\t\tif ( NVML_SUCCESS != ret ) {\n\t\t\t\t\t\t\t\tSUBDBG(\"nvmlGetInforomVersion carps %s\\n\", (*nvmlErrorStringPtr)(ret ) );\n\t\t\t\t\t\t\t\tisFermi = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret = (*nvmlDeviceGetInforomVersionPtr)( devices[i], NVML_INFOROM_POWER, inforomPower, 16);\n\t\t\t\t\t\tif ( NVML_SUCCESS != ret ) {\n\t\t\t\t\t\t\t\t/* This implies the card is older then Fermi */\n\t\t\t\t\t\t\t\tSUBDBG(\"nvmlGetInforomVersion carps %s\\n\", (*nvmlErrorStringPtr)(ret ) );\n\t\t\t\t\t\t\t\tSUBDBG(\"Based upon the return to nvmlGetInforomVersion, we conclude this card is older then Fermi.\\n\");\n\t\t\t\t\t\t\t\tisFermi = 0;\n\t\t\t\t\t\t} \n\n\t\t\t\t\t\tecc_version = strtof(inforomECC, NULL );\n\t\t\t\t\t\tpower_version = strtof( inforomPower, NULL);\n\n\t\t\t\t\t\tisTesla = ( NULL == strstr(name, \"Tesla\") ) ? 0:1;\n\n\t\t\t\t\t\t/* For Tesla and Quadro products from Fermi and Kepler families. */\n\t\t\t\t\t\tif ( isFermi ) {\n\t\t\t\t\t\t\t\tfeatures[i] |= FEATURE_CLOCK_INFO;\n\t\t\t\t\t\t\t\tnum_events += 3;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* \tFor Tesla and Quadro products from Fermi and Kepler families. \n\t\t\t\t\t\t\trequires NVML_INFOROM_ECC 2.0 or higher for location-based counts\n\t\t\t\t\t\t\trequires NVML_INFOROM_ECC 1.0 or higher for all other ECC counts\n\t\t\t\t\t\t\trequires ECC mode to be enabled. */\n\t\t\t\t\t\tret = (*nvmlDeviceGetEccModePtr)( devices[i], &mode, NULL );\n\t\t\t\t\t\tif ( NVML_SUCCESS == ret ) {\n\t\t\t\t\t\t    if ( NVML_FEATURE_ENABLED == mode) {\n\t\t\t\t\t\t\tif ( ecc_version >= 2.0 ) {\n\t\t\t\t\t\t\t    features[i] |= FEATURE_ECC_LOCAL_ERRORS;\n\t\t\t\t\t\t\t    num_events += 8; /* {single bit, two bit errors} x { reg, l1, l2, memory } */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( ecc_version >= 1.0 ) {\n\t\t\t\t\t\t\t    features[i] |= FEATURE_ECC_TOTAL_ERRORS;\n\t\t\t\t\t\t\t    num_events += 2; /* single bit errors, double bit errors */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t    SUBDBG(\"nvmlDeviceGetEccMode does not appear to be supported. (nvml\\\nreturn code %d)\\n\", ret);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* For all discrete products with dedicated fans */\n\t\t\t\t\t\tfeatures[i] |= FEATURE_FAN_SPEED;\n\t\t\t\t\t\tnum_events++;\n\n\t\t\t\t\t\t/* For Tesla and Quadro products from Fermi and Kepler families. */\n\t\t\t\t\t\tif ( isFermi ) {\n\t\t\t\t\t\t\t\tfeatures[i] |= FEATURE_MAX_CLOCK;\n\t\t\t\t\t\t\t\tnum_events += 3;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* For all products */\n\t\t\t\t\t\tfeatures[i] |= FEATURE_MEMORY_INFO;\n\t\t\t\t\t\tnum_events += 3; /* total, free, used */\n\n\t\t\t\t\t\t/* For Tesla and Quadro products from the Fermi and Kepler families. */\n\t\t\t\t\t\tif ( isFermi ) {\n\t\t\t\t\t\t\t\tfeatures[i] |= FEATURE_PERF_STATES;\n\t\t\t\t\t\t\t\tnum_events++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* \tFor \"GF11x\" Tesla and Quadro products from the Fermi family\n\t\t\t\t\t\t\trequires NVML_INFOROM_POWER 3.0 or higher\n\t\t\t\t\t\t\tFor Tesla and Quadro products from the Kepler family\n\t\t\t\t\t\t\tdoes not require NVML_INFOROM_POWER */\n\t\t\t\t\t\t/* Just try reading power, if it works, enable it*/\n\t\t\t\t\t\tret = (*nvmlDeviceGetPowerUsagePtr)( devices[i], &temp);\n\t\t\t\t\t\tif ( NVML_SUCCESS == ret ) {\n\t\t\t\t\t\t    features[i] |= FEATURE_POWER;\n\t\t\t\t\t\t    num_events++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t    SUBDBG(\"nvmlDeviceGetPowerUsage does not appear to be supported on\\\nthis card. (nvml return code %d)\\n\", ret );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* For all discrete and S-class products. */\n\t\t\t\t\t\tfeatures[i] |= FEATURE_TEMP;\n\t\t\t\t\t\tnum_events++;\n\n\t\t\t\t\t\t/* For Tesla and Quadro products from the Fermi and Kepler families */\n\t\t\t\t\t\tif (isFermi) {\n\t\t\t\t\t\t\t\tfeatures[i] |= FEATURE_UTILIZATION;\n\t\t\t\t\t\t\t\tnum_events += 2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstrncpy( names[i], name, sizeof(names[0])-1);\n\t\t\t\t\t\tnames[i][sizeof(names[0])-1] = '\\0';\n\t\t\t\t}\n\t\t}\n\t\treturn PAPI_OK;\n}\n\n    static void\ncreateNativeEvents( )\n{\n\t\tchar name[64];\n\t\tchar sanitized_name[PAPI_MAX_STR_LEN];\n\t\tchar names[device_count][64];\n\n\t\tint i, nameLen = 0, j;\n\t\tint isUnique = 1;\n\n\t\tnvml_native_event_entry_t* entry;\n\t\tnvmlReturn_t ret;\n\n\t\tnvml_native_table = (nvml_native_event_entry_t*) papi_malloc( \n\t\t\t\t\t\tsizeof(nvml_native_event_entry_t) * num_events ); \t\n\t\tmemset( nvml_native_table, 0x0, sizeof(nvml_native_event_entry_t) * num_events );\n\t\tentry = &nvml_native_table[0];\n\n\t\tfor (i=0; i < device_count; i++ ) {\n\t\t\t\tmemset( names[i], 0x0, 64 );\n\t\t\t\tisUnique = 1;\n\t\t\t\tret = (*nvmlDeviceGetNamePtr)( devices[i], name, sizeof(name)-1 );\n\t\t\t\tname[sizeof(name)-1] = '\\0';\t// to safely use strlen operation below, the variable 'name' must be null terminated\n\n\t\t\t\tfor (j=0; j < i; j++ ) \n\t\t\t\t{\n\t\t\t\t\t\tif ( 0 == strncmp( name, names[j], 64 ) )\n\t\t\t\t\t\t\t\tisUnique = 0;\n\t\t\t\t}\n\n\t\t\t\tif ( isUnique ) {\n\t\t\t\t\t\tnameLen = strlen(name);\n\t\t\t\t\t\tstrncpy(sanitized_name, name, PAPI_MAX_STR_LEN );\n\t\t\t\t\t\tfor (j=0; j < nameLen; j++)\n\t\t\t\t\t\t\t\tif ( ' ' == sanitized_name[j] )\n\t\t\t\t\t\t\t\t\t\tsanitized_name[j] = '_';\n\n\n\n\t\t\t\t\t\tif ( HAS_FEATURE( features[i], FEATURE_CLOCK_INFO ) ) {\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:graphics_clock\", sanitized_name );\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Graphics clock domain (MHz).\", PAPI_MAX_STR_LEN );\n\t\t\t\t\t\t\t\tentry->options.clock = NVML_CLOCK_GRAPHICS;\n\t\t\t\t\t\t\t\tentry->type = FEATURE_CLOCK_INFO;\n\t\t\t\t\t\t\t\tentry++;\n\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:sm_clock\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"SM clock domain (MHz).\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.clock = NVML_CLOCK_SM;\n\t\t\t\t\t\t\t\tentry->type = FEATURE_CLOCK_INFO;\n\t\t\t\t\t\t\t\tentry++;\n\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:memory_clock\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Memory clock domain (MHz).\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.clock = NVML_CLOCK_MEM;\n\t\t\t\t\t\t\t\tentry->type = FEATURE_CLOCK_INFO;\n\t\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t}\t\n\n\t\t\t\t\t\tif ( HAS_FEATURE( features[i], FEATURE_ECC_LOCAL_ERRORS ) ) { \n\t\t\t\t\t\t\t\tsprintf(entry->name, \"%s:l1_single_ecc_errors\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"L1 cache single bit ECC\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.ecc_opts = (struct local_ecc){\n\t\t\t\t\t\t\t\t\t\t.bits = NVML_SINGLE_BIT_ECC,\n\t\t\t\t\t\t\t\t\t\t\t\t.which_one = LOCAL_ECC_L1,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tentry->type = FEATURE_ECC_LOCAL_ERRORS;\n\t\t\t\t\t\t\t\tentry++;\n\n\t\t\t\t\t\t\t\tsprintf(entry->name, \"%s:l2_single_ecc_errors\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"L2 cache single bit ECC\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.ecc_opts = (struct local_ecc){\n\t\t\t\t\t\t\t\t\t\t.bits = NVML_SINGLE_BIT_ECC,\n\t\t\t\t\t\t\t\t\t\t\t\t.which_one = LOCAL_ECC_L2,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tentry->type = FEATURE_ECC_LOCAL_ERRORS;\n\t\t\t\t\t\t\t\tentry++;\n\n\t\t\t\t\t\t\t\tsprintf(entry->name, \"%s:memory_single_ecc_errors\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Device memory single bit ECC\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.ecc_opts = (struct local_ecc){\n\t\t\t\t\t\t\t\t\t\t.bits = NVML_SINGLE_BIT_ECC,\n\t\t\t\t\t\t\t\t\t\t\t\t.which_one = LOCAL_ECC_MEM,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tentry->type = FEATURE_ECC_LOCAL_ERRORS;\n\t\t\t\t\t\t\t\tentry++;\n\n\t\t\t\t\t\t\t\tsprintf(entry->name, \"%s:regfile_single_ecc_errors\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Register file single bit ECC\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.ecc_opts = (struct local_ecc){\n\t\t\t\t\t\t\t\t\t\t.bits = NVML_SINGLE_BIT_ECC,\n\t\t\t\t\t\t\t\t\t\t\t\t.which_one = LOCAL_ECC_REGFILE,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tentry->type = FEATURE_ECC_LOCAL_ERRORS;\n\t\t\t\t\t\t\t\tentry++;\n\n\t\t\t\t\t\t\t\tsprintf(entry->name, \"%s:1l_double_ecc_errors\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"L1 cache double bit ECC\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.ecc_opts = (struct local_ecc){\n\t\t\t\t\t\t\t\t\t\t.bits = NVML_DOUBLE_BIT_ECC,\n\t\t\t\t\t\t\t\t\t\t\t\t.which_one = LOCAL_ECC_L1,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tentry->type = FEATURE_ECC_LOCAL_ERRORS;\n\t\t\t\t\t\t\t\tentry++;\n\n\t\t\t\t\t\t\t\tsprintf(entry->name, \"%s:l2_double_ecc_errors\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"L2 cache double bit ECC\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.ecc_opts = (struct local_ecc){\n\t\t\t\t\t\t\t\t\t\t.bits = NVML_DOUBLE_BIT_ECC,\n\t\t\t\t\t\t\t\t\t\t\t\t.which_one = LOCAL_ECC_L2,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tentry->type = FEATURE_ECC_LOCAL_ERRORS;\n\t\t\t\t\t\t\t\tentry++;\n\n\t\t\t\t\t\t\t\tsprintf(entry->name, \"%s:memory_double_ecc_errors\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Device memory double bit ECC\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.ecc_opts = (struct local_ecc){\n\t\t\t\t\t\t\t\t\t\t.bits = NVML_DOUBLE_BIT_ECC,\n\t\t\t\t\t\t\t\t\t\t\t\t.which_one = LOCAL_ECC_MEM,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tentry->type = FEATURE_ECC_LOCAL_ERRORS;\n\t\t\t\t\t\t\t\tentry++;\n\n\t\t\t\t\t\t\t\tsprintf(entry->name, \"%s:regfile_double_ecc_errors\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Register file double bit ECC\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.ecc_opts = (struct local_ecc){\n\t\t\t\t\t\t\t\t\t\t.bits = NVML_DOUBLE_BIT_ECC,\n\t\t\t\t\t\t\t\t\t\t\t\t.which_one = LOCAL_ECC_REGFILE,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tentry->type = FEATURE_ECC_LOCAL_ERRORS;\n\t\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( HAS_FEATURE( features[i], FEATURE_FAN_SPEED ) ) {\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:fan_speed\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"The fan speed expressed as a percent of the maximum, i.e. full speed is 100%\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->type = FEATURE_FAN_SPEED;\n\t\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( HAS_FEATURE( features[i], FEATURE_MAX_CLOCK ) ) {\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:graphics_max_clock\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Maximal Graphics clock domain (MHz).\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.clock = NVML_CLOCK_GRAPHICS;\n\t\t\t\t\t\t\t\tentry->type = FEATURE_MAX_CLOCK;\n\t\t\t\t\t\t\t\tentry++;\n\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:sm_max_clock\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Maximal SM clock domain (MHz).\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.clock = NVML_CLOCK_SM;\n\t\t\t\t\t\t\t\tentry->type = FEATURE_MAX_CLOCK;\n\t\t\t\t\t\t\t\tentry++;\n\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:memory_max_clock\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Maximal Memory clock domain (MHz).\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.clock = NVML_CLOCK_MEM;\n\t\t\t\t\t\t\t\tentry->type = FEATURE_MAX_CLOCK;\n\t\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( HAS_FEATURE( features[i], FEATURE_MEMORY_INFO ) ) {\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:total_memory\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Total installed FB memory (in bytes).\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.which_one = MEMINFO_TOTAL_MEMORY;\n\t\t\t\t\t\t\t\tentry->type = FEATURE_MEMORY_INFO;\n\t\t\t\t\t\t\t\tentry++;\n\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:unallocated_memory\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Uncallocated FB memory (in bytes).\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.which_one = MEMINFO_UNALLOCED;\n\t\t\t\t\t\t\t\tentry->type = FEATURE_MEMORY_INFO;\n\t\t\t\t\t\t\t\tentry++;\n\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:allocated_memory\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\t\"Allocated FB memory (in bytes). Note that the driver/GPU always sets aside a small amount of memory for bookkeeping.\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.which_one = MEMINFO_ALLOCED;\n\t\t\t\t\t\t\t\tentry->type = FEATURE_MEMORY_INFO;\n\t\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( HAS_FEATURE( features[i], FEATURE_PERF_STATES ) ) {\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:pstate\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"The performance state of the device.\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->type = FEATURE_PERF_STATES;\n\t\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( HAS_FEATURE( features[i], FEATURE_POWER ) ) {\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:power\", sanitized_name);\n\t\t\t\t\t\t\t\t// set the power event units value to \"mW\" for miliwatts\n\t\t\t\t\t\t\t\tstrncpy( entry->units, \"mW\",PAPI_MIN_STR_LEN);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Power usage reading for the device, in miliwatts. This is the power draw (+/-5 watts) for the entire board: GPU, memory, etc.\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->type = FEATURE_POWER;\n\t\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( HAS_FEATURE( features[i], FEATURE_TEMP ) ) {\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:temperature\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Current temperature readings for the device, in degrees C.\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->type = FEATURE_TEMP;\n\t\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( HAS_FEATURE( features[i], FEATURE_ECC_TOTAL_ERRORS ) ) {\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:total_ecc_errors\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Total single bit errors.\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.ecc_opts = (struct local_ecc){ \n\t\t\t\t\t\t\t\t\t\t.bits = NVML_SINGLE_BIT_ECC, \n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tentry->type = FEATURE_ECC_TOTAL_ERRORS;\n\t\t\t\t\t\t\t\tentry++;\n\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:total_ecc_errors\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Total double bit errors.\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.ecc_opts = (struct local_ecc){ \n\t\t\t\t\t\t\t\t\t\t.bits = NVML_DOUBLE_BIT_ECC, \n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tentry->type = FEATURE_ECC_TOTAL_ERRORS;\n\t\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( HAS_FEATURE( features[i], FEATURE_UTILIZATION ) ) {\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:gpu_utilization\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Percent of time over the past second during which one or more kernels was executing on the GPU.\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.which_one = GPU_UTILIZATION;\n\t\t\t\t\t\t\t\tentry->type = FEATURE_UTILIZATION;\n\t\t\t\t\t\t\t\tentry++;\n\n\t\t\t\t\t\t\t\tsprintf( entry->name, \"%s:memory_utilization\", sanitized_name);\n\t\t\t\t\t\t\t\tstrncpy(entry->description,\"Percent of time over the past second during which global (device) memory was being read or written.\", PAPI_MAX_STR_LEN);\n\t\t\t\t\t\t\t\tentry->options.which_one = MEMORY_UTILIZATION;\n\t\t\t\t\t\t\t\tentry->type = FEATURE_UTILIZATION;\n\t\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstrncpy( names[i], name, sizeof(names[0])-1);\n\t\t\t\t\t\tnames[i][sizeof(names[0])-1] = '\\0';\n\t\t\t\t}\n\t\t}\n}\n\n/** Initialize hardware counters, setup the function vector table\n * and get hardware information, this routine is called when the\n * PAPI process is initialized (IE PAPI_library_init)\n */\n\t\tint\n_papi_nvml_init_component( int cidx )\n{\n\t\tSUBDBG (\"Entry: cidx: %d\\n\", cidx);\n\t\tnvmlReturn_t ret;\n\t\tcudaError_t cuerr;\n\t\tint papi_errorcode;\n\n\t\tint cuda_count = 0;\n\t\tunsigned int nvml_count = 0;\n\n\t\t/* link in the cuda and nvml libraries and resolve the symbols we need to use */\n\t\tif (linkCudaLibraries() != PAPI_OK) {\n\t\t\tSUBDBG (\"Dynamic link of CUDA libraries failed, component will be disabled.\\n\");\n\t\t\tSUBDBG (\"See disable reason in papi_component_avail output for more details.\\n\");\n\t\t\treturn (PAPI_ENOSUPP);\n\t\t}\n\n\t\tret = (*nvmlInitPtr)();\n\t\tif ( NVML_SUCCESS != ret ) {\n\t\t\t\tstrcpy(_nvml_vector.cmp_info.disabled_reason, \"The NVIDIA managament library failed to initialize.\");\n\t\t\t\treturn PAPI_ENOSUPP;\n\t\t}\n\n\t\tcuerr = (*cuInitPtr)( 0 );\n\t\tif ( CUDA_SUCCESS != cuerr ) {\n\t\t\t\tstrcpy(_nvml_vector.cmp_info.disabled_reason, \"The CUDA library failed to initialize.\");\n\t\t\t\treturn PAPI_ENOSUPP;\n\t\t}\n\n\t\t/* Figure out the number of CUDA devices in the system */\n\t\tret = (*nvmlDeviceGetCountPtr)( &nvml_count );\n\t\tif ( NVML_SUCCESS != ret ) {\n\t\t\t\tstrcpy(_nvml_vector.cmp_info.disabled_reason, \"Unable to get a count of devices from the NVIDIA managament library.\");\n\t\t\t\treturn PAPI_ENOSUPP;\n\t\t}\n\n\t\tcuerr = (*cudaGetDeviceCountPtr)( &cuda_count );\n\t\tif ( CUDA_SUCCESS != cuerr ) {\n\t\t\t\tstrcpy(_nvml_vector.cmp_info.disabled_reason, \"Unable to get a device count from CUDA.\");\n\t\t\t\treturn PAPI_ENOSUPP;\n\t\t}\n\n\t\t/* We can probably recover from this, when we're clever */\n\t\tif ( (cuda_count > 0) && (nvml_count != (unsigned int)cuda_count ) ) {\n\t\t\t\tstrcpy(_nvml_vector.cmp_info.disabled_reason, \"Cuda and the NVIDIA managament library have different device counts.\");\n\t\t\t\treturn PAPI_ENOSUPP;\n\t\t}\n\n\t\tdevice_count = cuda_count;\n\n\t\t/* A per device representation of what events are present */\n\t\tfeatures = (int*)papi_malloc(sizeof(int) * device_count );\n\n\t\t/* Handles to each device */\n\t\tdevices = (nvmlDevice_t*)papi_malloc(sizeof(nvmlDevice_t) * device_count);\n\n\t\t/* Figure out what events are supported on each card. */\n\t\tif ( (papi_errorcode = detectDevices( ) ) != PAPI_OK ) {\n\t\t\tpapi_free(features);\n\t\t\tpapi_free(devices);\n\t\t\tsprintf(_nvml_vector.cmp_info.disabled_reason, \"An error occured in device feature detection, please check your NVIDIA Management Library and CUDA install.\" );\n\t\t\treturn PAPI_ENOSUPP;\n\t\t}\n\n\t\t/* The assumption is that if everything went swimmingly in detectDevices, \n\t\t\tall nvml calls here should be fine. */\n\t\tcreateNativeEvents( );\n\n\t\t/* Export the total number of events available */\n\t\t_nvml_vector.cmp_info.num_native_events = num_events;\n\n\t\t/* Export the component id */\n\t\t_nvml_vector.cmp_info.CmpIdx = cidx;\n\n\t\t/* Export the number of 'counters' */\n\t\t_nvml_vector.cmp_info.num_cntrs = num_events;\n\t\t_nvml_vector.cmp_info.num_mpx_cntrs = num_events;\n\n\t\treturn PAPI_OK;\n}\n\n\n/*\n * Link the necessary CUDA libraries to use the cuda component.  If any of them can not be found, then\n * the CUDA component will just be disabled.  This is done at runtime so that a version of PAPI built\n * with the CUDA component can be installed and used on systems which have the CUDA libraries installed\n * and on systems where these libraries are not installed.\n */\nstatic int\nlinkCudaLibraries ()\n{\n\t/* Attempt to guess if we were statically linked to libc, if so bail */\n\tif ( _dl_non_dynamic_init != NULL ) {\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML component does not support statically linking of libc.\", PAPI_MAX_STR_LEN);\n\t\treturn PAPI_ENOSUPP;\n\t}\n\n\t/* Need to link in the cuda libraries, if not found disable the component */\n\tdl1 = dlopen(\"libcuda.so\", RTLD_NOW | RTLD_GLOBAL);\n\tif (!dl1)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDA library libcuda.so not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tcuInitPtr = dlsym(dl1, \"cuInit\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDA function cuInit not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\tdl2 = dlopen(\"libcudart.so\", RTLD_NOW | RTLD_GLOBAL);\n\tif (!dl2)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDA runtime library libcudart.so not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tcudaGetDevicePtr = dlsym(dl2, \"cudaGetDevice\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDART function cudaGetDevice not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tcudaGetDeviceCountPtr = dlsym(dl2, \"cudaGetDeviceCount\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDART function cudaGetDeviceCount not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tcudaDeviceGetPCIBusIdPtr = dlsym(dl2, \"cudaDeviceGetPCIBusId\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDART function cudaDeviceGetPCIBusId not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\tdl3 = dlopen(\"libnvidia-ml.so\", RTLD_NOW | RTLD_GLOBAL);\n\tif (!dl3)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML runtime library libnvidia-ml.so not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlDeviceGetClockInfoPtr = dlsym(dl3, \"nvmlDeviceGetClockInfo\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetClockInfo not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlErrorStringPtr = dlsym(dl3, \"nvmlErrorString\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlErrorString not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlDeviceGetDetailedEccErrorsPtr = dlsym(dl3, \"nvmlDeviceGetDetailedEccErrors\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetDetailedEccErrors not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlDeviceGetFanSpeedPtr = dlsym(dl3, \"nvmlDeviceGetFanSpeed\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetFanSpeed not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlDeviceGetMemoryInfoPtr = dlsym(dl3, \"nvmlDeviceGetMemoryInfo\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetMemoryInfo not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlDeviceGetPerformanceStatePtr = dlsym(dl3, \"nvmlDeviceGetPerformanceState\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetPerformanceState not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlDeviceGetPowerUsagePtr = dlsym(dl3, \"nvmlDeviceGetPowerUsage\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetPowerUsage not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlDeviceGetTemperaturePtr = dlsym(dl3, \"nvmlDeviceGetTemperature\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetTemperature not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlDeviceGetTotalEccErrorsPtr = dlsym(dl3, \"nvmlDeviceGetTotalEccErrors\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetTotalEccErrors not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlDeviceGetUtilizationRatesPtr = dlsym(dl3, \"nvmlDeviceGetUtilizationRates\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetUtilizationRates not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlDeviceGetHandleByIndexPtr = dlsym(dl3, \"nvmlDeviceGetHandleByIndex\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetHandleByIndex not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlDeviceGetPciInfoPtr = dlsym(dl3, \"nvmlDeviceGetPciInfo\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetPciInfo not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlDeviceGetNamePtr = dlsym(dl3, \"nvmlDeviceGetName\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetName not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlDeviceGetInforomVersionPtr = dlsym(dl3, \"nvmlDeviceGetInforomVersion\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetInforomVersion not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlDeviceGetEccModePtr = dlsym(dl3, \"nvmlDeviceGetEccMode\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetEccMode not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlInitPtr = dlsym(dl3, \"nvmlInit\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlInit not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlDeviceGetCountPtr = dlsym(dl3, \"nvmlDeviceGetCount\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetCount not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tnvmlShutdownPtr = dlsym(dl3, \"nvmlShutdown\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlShutdown not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\treturn ( PAPI_OK );\n}\n\n\n/** Setup a counter control state.\n *   In general a control state holds the hardware info for an\n *   EventSet.\n */\n\n\t\tint\n_papi_nvml_init_control_state( hwd_control_state_t * ctl )\n{\n\t\tSUBDBG( \"nvml_init_control_state... %p\\n\", ctl );\n\t\tnvml_control_state_t *nvml_ctl = ( nvml_control_state_t * ) ctl;\n\t\tmemset( nvml_ctl, 0, sizeof ( nvml_control_state_t ) );\n\n\t\treturn PAPI_OK;\n}\n\n\n/** Triggered by eventset operations like add or remove */\n\t\tint\n_papi_nvml_update_control_state( hwd_control_state_t *ctl, \n\t\t\t\tNativeInfo_t *native,\n\t\t\t\tint count, \n\t\t\t\thwd_context_t *ctx )\n{\n\t\tSUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n\t\tint i, index;\n\n\t\tnvml_control_state_t *nvml_ctl = ( nvml_control_state_t * ) ctl;   \n\t\t(void) ctx;\n\n\n\t\t/* if no events, return */\n\t\tif (count==0) return PAPI_OK;\n\n\t\tfor( i = 0; i < count; i++ ) {\n\t\t\t\tindex = native[i].ni_event;\n\t\t\t\tnvml_ctl->which_counter[i]=index;\n\t\t\t\t/* We have no constraints on event position, so any event */\n\t\t\t\t/* can be in any slot.                                    */\n\t\t\t\tnative[i].ni_position = i;\n\t\t}\n\t\tnvml_ctl->num_events=count;\n\t\treturn PAPI_OK;\n}\n/** Triggered by PAPI_start() */\n\t\tint\n_papi_nvml_start( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\t\tSUBDBG( \"Enter: ctx: %p, ctl: %p\\n\", ctx, ctl );\n\n\t\t(void) ctx;\n\t\t(void) ctl;\n\n\t\t/* anything that would need to be set at counter start time */\n\n\t\t/* reset */\n\t\t/* start the counting */\n\n\t\treturn PAPI_OK;\n}\n\n\n/** Triggered by PAPI_stop() */\n\t\tint\n_papi_nvml_stop( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\t\tSUBDBG( \"Enter: ctx: %p, ctl: %p\\n\", ctx, ctl );\n\n\t\tint i;\n\t\t(void) ctx;\n\t\t(void) ctl;\n\t\tint ret;\n\n\t\tnvml_control_state_t* nvml_ctl = ( nvml_control_state_t*) ctl;\n\n\t\tfor (i=0;i<nvml_ctl->num_events;i++) {\n\t\t\t\tif ( PAPI_OK != \n\t\t\t\t\t\t\t\t( ret = nvml_hardware_read( &nvml_ctl->counter[i], \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnvml_ctl->which_counter[i]) ))\n\t\t\t\t\t\treturn ret;\n\n\t\t}\n\n\t\treturn PAPI_OK;\n}\n\n\n/** Triggered by PAPI_read() */\n\t\tint\n_papi_nvml_read( hwd_context_t *ctx, hwd_control_state_t *ctl,\n\t\t\t\tlong long **events, int flags )\n{\n\t\tSUBDBG( \"Enter: ctx: %p, flags: %d\\n\", ctx, flags );\n\n\t\t(void) ctx;\n\t\t(void) flags;\n\t\tint i;\n\t\tint ret;\n\t\tnvml_control_state_t* nvml_ctl = ( nvml_control_state_t*) ctl;   \n\n\n\t\tfor (i=0;i<nvml_ctl->num_events;i++) {\n\t\t\t\tif ( PAPI_OK != \n\t\t\t\t\t\t\t\t( ret = nvml_hardware_read( &nvml_ctl->counter[i], \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnvml_ctl->which_counter[i]) ))\n\t\t\t\t\t\treturn ret;\n\n\t\t}\n\t\t/* return pointer to the values we read */\n\t\t*events = nvml_ctl->counter;\t\n\t\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_write(), but only if the counters are running */\n/*    otherwise, the updated state is written to ESI->hw_start      */\n\t\tint\n_papi_nvml_write( hwd_context_t *ctx, hwd_control_state_t *ctl,\n\t\t\t\tlong long *events )\n{\n\t\tSUBDBG( \"Enter: ctx: %p, ctl: %p\\n\", ctx, ctl );\n\n\t\t(void) ctx;\n\t\t(void) ctl;\n\t\t(void) events;\n\n\n\t\t/* You can change ECC mode and compute exclusivity modes on the cards */\n\t\t/* But I don't see this as a function of a PAPI component at this time */\n\t\t/* All implementation issues aside. */\n\t\treturn PAPI_OK;\n}\n\n\n/** Triggered by PAPI_reset() but only if the EventSet is currently running */\n/*  If the eventset is not currently running, then the saved value in the   */\n/*  EventSet is set to zero without calling this routine.                   */\n\t\tint\n_papi_nvml_reset( hwd_context_t * ctx, hwd_control_state_t * ctl )\n{\n\t\tSUBDBG( \"Enter: ctx: %p, ctl: %p\\n\", ctx, ctl );\n\t\t\n\t\t(void) ctx;\n\t\t(void) ctl;\n\n\t\t/* Reset the hardware */\n\t\tnvml_hardware_reset(  );\n\n\t\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_shutdown() */\n\t\tint\n_papi_nvml_shutdown_component()\n{\n\t\tSUBDBG( \"Enter:\\n\" );\n\n\tif (nvml_native_table != NULL)\n\t\tpapi_free(nvml_native_table);\n\tif (devices != NULL)\n\t\tpapi_free(devices);\n\tif (features != NULL)\n\t\tpapi_free(features);\n\n\t\t(*nvmlShutdownPtr)();\n\n\t\tdevice_count = 0;\n\t\tnum_events = 0;\n\n\t\t// close the dynamic libraries needed by this component (opened in the init component call)\n\t\tdlclose(dl1);\n\t\tdlclose(dl2);\n\t\tdlclose(dl3);\n\n\t\treturn PAPI_OK;\n}\n\n/** Called at thread shutdown */\n\t\tint\n_papi_nvml_shutdown_thread( hwd_context_t *ctx )\n{\n\t\tSUBDBG( \"Enter: ctx: %p\\n\", ctx );\n\n\t\t(void) ctx;\n\n\t\t/* Last chance to clean up thread */\n\n\t\treturn PAPI_OK;\n}\n\n\n\n/** This function sets various options in the component\n  @param code valid are PAPI_SET_DEFDOM, PAPI_SET_DOMAIN, PAPI_SETDEFGRN, PAPI_SET_GRANUL and PAPI_SET_INHERIT\n */\n\t\tint\n_papi_nvml_ctl( hwd_context_t * ctx, int code, _papi_int_option_t * option )\n{\n\t\tSUBDBG( \"Enter: ctx: %p, code: %d\\n\", ctx, code );\n\n\t\t(void) ctx;\n\t\t(void) code;\n\t\t(void) option;\n\n\n\t\t/* FIXME.  This should maybe set up more state, such as which counters are active and */\n\t\t/*         counter mappings. */\n\n\t\treturn PAPI_OK;\n}\n\n/** This function has to set the bits needed to count different domains\n  In particular: PAPI_DOM_USER, PAPI_DOM_KERNEL PAPI_DOM_OTHER\n  By default return PAPI_EINVAL if none of those are specified\n  and PAPI_OK with success\n  PAPI_DOM_USER is only user context is counted\n  PAPI_DOM_KERNEL is only the Kernel/OS context is counted\n  PAPI_DOM_OTHER  is Exception/transient mode (like user TLB misses)\n  PAPI_DOM_ALL   is all of the domains\n */\n\t\tint\n_papi_nvml_set_domain( hwd_control_state_t * cntrl, int domain )\n{\n\t\tSUBDBG( \"Enter: cntrl: %p, domain: %d\\n\", cntrl, domain );\n\n\t\t(void) cntrl;\n\n\t\tint found = 0;\n\n\t\tif ( PAPI_DOM_USER & domain ) {\n\t\t\t\tSUBDBG( \" PAPI_DOM_USER \\n\" );\n\t\t\t\tfound = 1;\n\t\t}\n\t\tif ( PAPI_DOM_KERNEL & domain ) {\n\t\t\t\tSUBDBG( \" PAPI_DOM_KERNEL \\n\" );\n\t\t\t\tfound = 1;\n\t\t}\n\t\tif ( PAPI_DOM_OTHER & domain ) {\n\t\t\t\tSUBDBG( \" PAPI_DOM_OTHER \\n\" );\n\t\t\t\tfound = 1;\n\t\t}\n\t\tif ( PAPI_DOM_ALL & domain ) {\n\t\t\t\tSUBDBG( \" PAPI_DOM_ALL \\n\" );\n\t\t\t\tfound = 1;\n\t\t}\n\t\tif ( !found )\n\t\t\t\treturn ( PAPI_EINVAL );\n\n\t\treturn PAPI_OK;\n}\n\n\n/**************************************************************/\n/* Naming functions, used to translate event numbers to names */\n/**************************************************************/\n\n\n/** Enumerate Native Events\n *   @param EventCode is the event of interest\n *   @param modifier is one of PAPI_ENUM_FIRST, PAPI_ENUM_EVENTS\n *  If your component has attribute masks then these need to\n *   be handled here as well.\n */\n\t\tint\n_papi_nvml_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n\t\tint index;\n\n\t\tswitch ( modifier ) {\n\n\t\t\t\t/* return EventCode of first event */\n\t\t\t\tcase PAPI_ENUM_FIRST:\n\t\t\t\t\t\t/* return the first event that we support */\n\n\t\t\t\t\t\t*EventCode = 0;\n\t\t\t\t\t\treturn PAPI_OK;\n\n\t\t\t\t\t\t/* return EventCode of next available event */\n\t\t\t\tcase PAPI_ENUM_EVENTS:\n\t\t\t\t\t\tindex = *EventCode;\n\n\t\t\t\t\t\t/* Make sure we are in range */\n\t\t\t\t\t\tif ( index < num_events - 1 ) {\n\n\t\t\t\t\t\t\t\t/* This assumes a non-sparse mapping of the events */\n\t\t\t\t\t\t\t\t*EventCode = *EventCode + 1;\n\t\t\t\t\t\t\t\treturn PAPI_OK;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn PAPI_ENOEVNT;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t\treturn PAPI_EINVAL;\n\t\t}\n\n\t\treturn PAPI_EINVAL;\n}\n\n/** Takes a native event code and passes back the name \n * @param EventCode is the native event code\n * @param name is a pointer for the name to be copied to\n * @param len is the size of the name string\n */\n\t\tint\n_papi_nvml_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n\t\tSUBDBG(\"Entry: EventCode: %#x, name: %s, len: %d\\n\", EventCode, name, len);\n\t\tint index;\n\n\t\tindex = EventCode;\n\n\t\t/* Make sure we are in range */\n\t\tif (index >= num_events) return PAPI_ENOEVNT;\n\n\t\tstrncpy( name, nvml_native_table[index].name, len );\n\n\t\treturn PAPI_OK;\n}\n\n/** Takes a native event code and passes back the event description\n * @param EventCode is the native event code\n * @param descr is a pointer for the description to be copied to\n * @param len is the size of the descr string\n */\n\t\tint\n_papi_nvml_ntv_code_to_descr( unsigned int EventCode, char *descr, int len )\n{\n\t\tint index;\n\t\tindex = EventCode;\n\n\t\tif (index >= num_events) return PAPI_ENOEVNT;\n\n\t\tstrncpy( descr, nvml_native_table[index].description, len );\n\n\t\treturn PAPI_OK;\n}\n\n/** Takes a native event code and passes back the event info\n * @param EventCode is the native event code\n * @param info is a pointer for the info to be copied to\n */\nint\n_papi_nvml_ntv_code_to_info(unsigned int EventCode, PAPI_event_info_t *info) \n{\n\n  int index = EventCode;\n\n  if ( ( index < 0) || (index >= num_events )) return PAPI_ENOEVNT;\n\n  strncpy( info->symbol, nvml_native_table[index].name, sizeof(info->symbol)-1);\n  info->symbol[sizeof(info->symbol)-1] = '\\0';\n\n  strncpy( info->units, nvml_native_table[index].units, sizeof(info->units)-1);\n  info->units[sizeof(info->units)-1] = '\\0';\n\n  strncpy( info->long_descr, nvml_native_table[index].description, sizeof(info->long_descr)-1);\n  info->long_descr[sizeof(info->long_descr)-1] = '\\0';\n\n//  info->data_type = nvml_native_table[index].return_type;\n\n  return PAPI_OK;\n}\n\n/** Vector that points to entry points for our component */\npapi_vector_t _nvml_vector = {\n\t\t.cmp_info = {\n\t\t\t\t/* default component information */\n\t\t\t\t/* (unspecified values are initialized to 0) */\n\n\t\t\t\t.name = \"nvml\",\n\t\t\t\t.short_name=\"nvml\",\n\t\t\t\t.version = \"1.0\",\n\t\t\t\t.description = \"NVML provides the API for monitoring NVIDIA hardware (power usage, temperature, fan speed, etc)\",\n\t\t\t\t.support_version = \"n/a\",\n\t\t\t\t.kernel_version = \"n/a\",\n\n\t\t\t\t.num_preset_events = 0,\n\t\t\t\t.num_native_events = 0, /* set by init_component */\n\t\t\t\t.default_domain = PAPI_DOM_USER,\n\t\t\t\t.available_domains = PAPI_DOM_USER,\n\t\t\t\t.default_granularity = PAPI_GRN_THR,\n\t\t\t\t.available_granularities = PAPI_GRN_THR,\n\t\t\t\t.hardware_intr_sig = PAPI_INT_SIGNAL,\n\n\n\t\t\t\t/* component specific cmp_info initializations */\n\t\t\t\t.hardware_intr = 0,\n\t\t\t\t.precise_intr = 0,\n\t\t\t\t.posix1b_timers = 0,\n\t\t\t\t.kernel_profile = 0,\n\t\t\t\t.kernel_multiplex = 0,\n\t\t\t\t.fast_counter_read = 0,\n\t\t\t\t.fast_real_timer = 0,\n\t\t\t\t.fast_virtual_timer = 0,\n\t\t\t\t.attach = 0,\n\t\t\t\t.attach_must_ptrace = 0,\n\t\t\t\t.cntr_umasks = 0,\n\t\t\t\t.cpu = 0,\n\t\t\t\t.inherit = 0,\n\t\t},\n\n\t\t/* sizes of framework-opaque component-private structures */\n\t\t.size = {\n\t\t     .context = sizeof ( nvml_context_t ),\n\t\t     .control_state = sizeof ( nvml_control_state_t ),\n\t\t     .reg_value = sizeof ( nvml_register_t ),\n                     //\t.reg_alloc = sizeof ( nvml_reg_alloc_t ),\n\t\t},\n\n\t\t/* function pointers */\n\n\t\t/* Used for general PAPI interactions */\n\t\t.start =                _papi_nvml_start,\n\t\t.stop =                 _papi_nvml_stop,\n\t\t.read =                 _papi_nvml_read,\n\t\t.reset =                _papi_nvml_reset,\t\n\t\t.write =                _papi_nvml_write,\n\t\t.init_component =       _papi_nvml_init_component,\t\n\t\t.init_thread =          _papi_nvml_init_thread,\n\t\t.init_control_state =   _papi_nvml_init_control_state,\n\t\t.update_control_state = _papi_nvml_update_control_state,\n\t\t.ctl =                  _papi_nvml_ctl,\t\n\t\t.shutdown_thread =      _papi_nvml_shutdown_thread,\n\t\t.shutdown_component =   _papi_nvml_shutdown_component,\n\t\t.set_domain =           _papi_nvml_set_domain,\n\t\t.cleanup_eventset =     NULL,\n\t\t/* called in add_native_events() */\n\t\t.allocate_registers =   NULL,\n\n\t\t/* Used for overflow/profiling */\n\t\t.dispatch_timer =       NULL,\n\t\t.get_overflow_address = NULL,\n\t\t.stop_profiling =       NULL,\n\t\t.set_overflow =         NULL,\n\t\t.set_profile =          NULL,\n\n\t\t/* Name Mapping Functions */\n\t\t.ntv_enum_events =   _papi_nvml_ntv_enum_events,\n\t\t.ntv_name_to_code  = NULL,\n    .ntv_code_to_name =  _papi_nvml_ntv_code_to_name,\n    .ntv_code_to_descr = _papi_nvml_ntv_code_to_descr,\n    .ntv_code_to_info = _papi_nvml_ntv_code_to_info,\n\n};\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/components/appio/appio.c": "/****************************/\n/* THIS IS OPEN SOURCE CODE */\n/****************************/\n\n/**\n * @file    appio.c\n *\n * @author  Philip Mucci\n *          phil.mucci@samaratechnologygroup.com\n *\n * @author  Tushar Mohan\n *          tusharmohan@gmail.com\n *\n * Credit to: \n *          Jose Pedro Oliveira\n *          jpo@di.uminho.pt\n * whose code in the linux net component was used as a template for\n * many sections of code in this component.\n *\n * @ingroup papi_components\n *\n * @brief appio component\n *  This file contains the source code for a component that enables\n *  PAPI to access application level file and socket I/O information.\n *  It does this through function replacement in the first person and\n *  by trapping syscalls in the third person.\n */\n\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/select.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <sys/stat.h>\n\n/* Headers required by PAPI */\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\n#include \"appio.h\"\n\n// The PIC test implies it's built for shared linkage\n#ifdef PIC\n#  include \"dlfcn.h\"\n#endif\n\n/*\n#pragma weak dlerror\nstatic void *_dlsym_fake(void *handle, const char* symbol) { (void) handle; (void) symbol; return NULL; }\nvoid *dlsym(void *handle, const char* symbol) __attribute__ ((weak, alias (\"_dlsym_fake\")));\n*/\n\npapi_vector_t _appio_vector;\n\n/*********************************************************************\n * Private\n ********************************************************************/\n\n//#define APPIO_FOO 1\n\nstatic APPIO_native_event_entry_t * _appio_native_events;\n\n\n/* If you modify the appio_stats_t below, you MUST update APPIO_MAX_COUNTERS */\nstatic __thread long long _appio_register_current[APPIO_MAX_COUNTERS];\ntypedef enum {\n  READ_BYTES = 0,\n  READ_CALLS,\n  READ_ERR,\n  READ_INTERRUPTED,\n  READ_WOULD_BLOCK,\n  READ_SHORT,\n  READ_EOF,\n  READ_BLOCK_SIZE,\n  READ_USEC,\n  WRITE_BYTES,\n  WRITE_CALLS,\n  WRITE_ERR,\n  WRITE_SHORT,\n  WRITE_INTERRUPTED,\n  WRITE_WOULD_BLOCK,\n  WRITE_BLOCK_SIZE,\n  WRITE_USEC,\n  OPEN_CALLS,\n  OPEN_ERR,\n  OPEN_FDS,\n  SELECT_USEC,\n  RECV_BYTES,\n  RECV_CALLS,\n  RECV_ERR,\n  RECV_INTERRUPTED,\n  RECV_WOULD_BLOCK,\n  RECV_SHORT,\n  RECV_EOF,\n  RECV_BLOCK_SIZE,\n  RECV_USEC,\n  SOCK_READ_BYTES,\n  SOCK_READ_CALLS,\n  SOCK_READ_ERR,\n  SOCK_READ_SHORT,\n  SOCK_READ_WOULD_BLOCK,\n  SOCK_READ_USEC,\n  SOCK_WRITE_BYTES,\n  SOCK_WRITE_CALLS,\n  SOCK_WRITE_ERR,\n  SOCK_WRITE_SHORT,\n  SOCK_WRITE_WOULD_BLOCK,\n  SOCK_WRITE_USEC,\n  SEEK_CALLS,\n  SEEK_ABS_STRIDE_SIZE,\n  SEEK_USEC\n} _appio_stats_t ;\n\nstatic const struct appio_counters {\n    const char *name;\n    const char *description;\n} _appio_counter_info[APPIO_MAX_COUNTERS] = {\n    { \"READ_BYTES\",      \"Bytes read\"},\n    { \"READ_CALLS\",      \"Number of read calls\"},\n    { \"READ_ERR\",        \"Number of read calls that resulted in an error\"},\n    { \"READ_INTERRUPTED\",\"Number of read calls that timed out or were interruped\"},\n    { \"READ_WOULD_BLOCK\",\"Number of read calls that would have blocked\"},\n    { \"READ_SHORT\",      \"Number of read calls that returned less bytes than requested\"},\n    { \"READ_EOF\",        \"Number of read calls that returned an EOF\"},\n    { \"READ_BLOCK_SIZE\", \"Average block size of reads\"},\n    { \"READ_USEC\",       \"Real microseconds spent in reads\"},\n    { \"WRITE_BYTES\",     \"Bytes written\"},\n    { \"WRITE_CALLS\",     \"Number of write calls\"},\n    { \"WRITE_ERR\",       \"Number of write calls that resulted in an error\"},\n    { \"WRITE_SHORT\",     \"Number of write calls that wrote less bytes than requested\"},\n    { \"WRITE_INTERRUPTED\",\"Number of write calls that timed out or were interrupted\"},\n    { \"WRITE_WOULD_BLOCK\",\"Number of write calls that would have blocked\"},\n    { \"WRITE_BLOCK_SIZE\",\"Mean block size of writes\"},\n    { \"WRITE_USEC\",      \"Real microseconds spent in writes\"},\n    { \"OPEN_CALLS\",      \"Number of open calls\"},\n    { \"OPEN_ERR\",        \"Number of open calls that resulted in an error\"},\n    { \"OPEN_FDS\",        \"Number of currently open descriptors\"},\n    { \"SELECT_USEC\",     \"Real microseconds spent in select calls\"},\n    { \"RECV_BYTES\",      \"Bytes read in recv/recvmsg/recvfrom\"},\n    { \"RECV_CALLS\",      \"Number of recv/recvmsg/recvfrom calls\"},\n    { \"RECV_ERR\",        \"Number of recv/recvmsg/recvfrom calls that resulted in an error\"},\n    { \"RECV_INTERRUPTED\",\"Number of recv/recvmsg/recvfrom calls that timed out or were interruped\"},\n    { \"RECV_WOULD_BLOCK\",\"Number of recv/recvmsg/recvfrom calls that would have blocked\"},\n    { \"RECV_SHORT\",      \"Number of recv/recvmsg/recvfrom calls that returned less bytes than requested\"},\n    { \"RECV_EOF\",        \"Number of recv/recvmsg/recvfrom calls that returned an EOF\"},\n    { \"RECV_BLOCK_SIZE\", \"Average block size of recv/recvmsg/recvfrom\"},\n    { \"RECV_USEC\",       \"Real microseconds spent in recv/recvmsg/recvfrom\"},\n    { \"SOCK_READ_BYTES\", \"Bytes read from socket\"},\n    { \"SOCK_READ_CALLS\", \"Number of read calls on socket\"},\n    { \"SOCK_READ_ERR\",   \"Number of read calls on socket that resulted in an error\"},\n    { \"SOCK_READ_SHORT\", \"Number of read calls on socket that returned less bytes than requested\"},\n    { \"SOCK_READ_WOULD_BLOCK\", \"Number of read calls on socket that would have blocked\"},\n    { \"SOCK_READ_USEC\",  \"Real microseconds spent in read(s) on socket(s)\"},\n    { \"SOCK_WRITE_BYTES\",\"Bytes written to socket\"},\n    { \"SOCK_WRITE_CALLS\",\"Number of write calls to socket\"},\n    { \"SOCK_WRITE_ERR\",  \"Number of write calls to socket that resulted in an error\"},\n    { \"SOCK_WRITE_SHORT\",\"Number of write calls to socket that wrote less bytes than requested\"},\n    { \"SOCK_WRITE_WOULD_BLOCK\",\"Number of write calls to socket that would have blocked\"},\n    { \"SOCK_WRITE_USEC\", \"Real microseconds spent in write(s) to socket(s)\"},\n    { \"SEEK_CALLS\",      \"Number of seek calls\"},\n    { \"SEEK_ABS_STRIDE_SIZE\", \"Average absolute stride size of seeks\"},\n    { \"SEEK_USEC\",       \"Real microseconds spent in seek calls\"}\n};\n\n\n/*********************************************************************\n ***  BEGIN FUNCTIONS  USED INTERNALLY SPECIFIC TO THIS COMPONENT ****\n ********************************************************************/\n\nint __close(int fd);\nint close(int fd) {\n  int retval;\n  SUBDBG(\"appio: intercepted close(%d)\\n\", fd);\n  retval = __close(fd);\n  if ((retval == 0) && (_appio_register_current[OPEN_FDS]>0)) _appio_register_current[OPEN_FDS]--;\n  return retval;\n}\n\nint __open(const char *pathname, int flags, mode_t mode);\nint open(const char *pathname, int flags, mode_t mode) {\n  int retval;\n  SUBDBG(\"appio: intercepted open(%s,%d,%d)\\n\", pathname, flags, mode);\n  retval = __open(pathname,flags,mode);\n  _appio_register_current[OPEN_CALLS]++;\n  if (retval < 0) _appio_register_current[OPEN_ERR]++;\n  else _appio_register_current[OPEN_FDS]++;\n  return retval;\n}\n\n/* we use timeval as a zero value timeout to select in read/write\n   for polling if the operation would block */\nstruct timeval zerotv; /* this has to be zero, so define it here */\n\nint __select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\nint select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout) {\n  int retval;\n  SUBDBG(\"appio: intercepted select(%d,%p,%p,%p,%p)\\n\", nfds,readfds,writefds,exceptfds,timeout);\n  long long start_ts = PAPI_get_real_usec();\n  retval = __select(nfds,readfds,writefds,exceptfds,timeout);\n  long long duration = PAPI_get_real_usec() - start_ts;\n  _appio_register_current[SELECT_USEC] += duration;\n  return retval;\n}\n\noff_t __lseek(int fd, off_t offset, int whence);\noff_t lseek(int fd, off_t offset, int whence) {\n  off_t retval;\n  SUBDBG(\"appio: intercepted lseek(%d,%ld,%d)\\n\", fd, offset, whence);\n  long long start_ts = PAPI_get_real_usec();\n  retval = __lseek(fd, offset, whence);\n  long long duration = PAPI_get_real_usec() - start_ts;\n  int n = _appio_register_current[SEEK_CALLS]++;\n  _appio_register_current[SEEK_USEC] += duration;\n  if (offset < 0) offset = -offset; // get abs offset\n  _appio_register_current[SEEK_ABS_STRIDE_SIZE]= (n * _appio_register_current[SEEK_ABS_STRIDE_SIZE] + offset)/(n+1); // mean absolute stride size\n  return retval;\n}\n\nextern int errno;\nssize_t __read(int fd, void *buf, size_t count);\nssize_t read(int fd, void *buf, size_t count) {\n  int retval;\n  SUBDBG(\"appio: intercepted read(%d,%p,%lu)\\n\", fd, buf, (unsigned long)count);\n\n  struct stat st;\n  int issocket = 0;\n  if (fstat(fd, &st) == 0) {\n    if ((st.st_mode & S_IFMT) == S_IFSOCK) issocket = 1;\n  }\n  // check if read would block on descriptor\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(fd, &readfds);\n  int ready = __select(fd+1, &readfds, NULL, NULL, &zerotv);\n  if (ready == 0) {\n     _appio_register_current[READ_WOULD_BLOCK]++; \n     if (issocket) _appio_register_current[SOCK_READ_WOULD_BLOCK]++; \n  }\n\n  long long start_ts = PAPI_get_real_usec();\n  retval = __read(fd,buf, count);\n  long long duration = PAPI_get_real_usec() - start_ts;\n  int n = _appio_register_current[READ_CALLS]++; // read calls\n  if (issocket) _appio_register_current[SOCK_READ_CALLS]++; // read calls\n  if (retval > 0) {\n    _appio_register_current[READ_BLOCK_SIZE]= (n * _appio_register_current[READ_BLOCK_SIZE] + count)/(n+1); // mean size\n    _appio_register_current[READ_BYTES] += retval; // read bytes\n    if (issocket) _appio_register_current[SOCK_READ_BYTES] += retval;\n    if (retval < (int)count) {\n       _appio_register_current[READ_SHORT]++; // read short\n       if (issocket) _appio_register_current[SOCK_READ_SHORT]++; // read short\n    }\n    _appio_register_current[READ_USEC] += duration;\n    if (issocket) _appio_register_current[SOCK_READ_USEC] += duration;\n  }\n  if (retval < 0) { \n    _appio_register_current[READ_ERR]++; // read err\n    if (issocket) _appio_register_current[SOCK_READ_ERR]++; // read err\n    if (EINTR == errno)\n      _appio_register_current[READ_INTERRUPTED]++; // signal interrupted the read\n    //if ((EAGAIN == errno) || (EWOULDBLOCK == errno)) {\n    //  _appio_register_current[READ_WOULD_BLOCK]++; //read would block on descriptor marked as non-blocking\n    //  if (issocket) _appio_register_current[SOCK_READ_WOULD_BLOCK]++; //read would block on descriptor marked as non-blocking\n    //}\n  }\n  if (retval == 0) _appio_register_current[READ_EOF]++; // read eof\n  return retval;\n}\n\nsize_t _IO_fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) {\n  size_t retval;\n  SUBDBG(\"appio: intercepted fread(%p,%lu,%lu,%p)\\n\", ptr, (unsigned long) size, (unsigned long) nmemb, (void*) stream);\n  long long start_ts = PAPI_get_real_usec();\n  retval = _IO_fread(ptr,size,nmemb,stream);\n  long long duration = PAPI_get_real_usec() - start_ts;\n  int n = _appio_register_current[READ_CALLS]++; // read calls\n  if (retval > 0) {\n    _appio_register_current[READ_BLOCK_SIZE]= (n * _appio_register_current[READ_BLOCK_SIZE]+ size*nmemb)/(n+1);//mean size\n    _appio_register_current[READ_BYTES]+= retval * size; // read bytes\n    if (retval < nmemb) _appio_register_current[READ_SHORT]++; // read short\n    _appio_register_current[READ_USEC] += duration;\n  }\n\n  /* A value of zero returned means one of two things..*/\n  if (retval == 0) {\n     if (feof(stream)) _appio_register_current[READ_EOF]++; // read eof\n     else _appio_register_current[READ_ERR]++; // read err\n  }\n  return retval;\n}\n\nssize_t __write(int fd, const void *buf, size_t count);\nssize_t write(int fd, const void *buf, size_t count) {\n  int retval;\n  SUBDBG(\"appio: intercepted write(%d,%p,%lu)\\n\", fd, buf, (unsigned long)count);\n  struct stat st;\n  int issocket = 0;\n  if (fstat(fd, &st) == 0) {\n    if ((st.st_mode & S_IFMT) == S_IFSOCK) issocket = 1;\n  }\n\n  // check if write would block on descriptor\n  fd_set writefds;\n  FD_ZERO(&writefds);\n  FD_SET(fd, &writefds);\n  int ready = __select(fd+1, NULL, &writefds, NULL, &zerotv);\n  if (ready == 0) {\n    _appio_register_current[WRITE_WOULD_BLOCK]++; \n    if (issocket) _appio_register_current[SOCK_WRITE_WOULD_BLOCK]++; \n  }\n\n  long long start_ts = PAPI_get_real_usec();\n  retval = __write(fd,buf, count);\n  long long duration = PAPI_get_real_usec() - start_ts;\n  int n = _appio_register_current[WRITE_CALLS]++; // write calls\n  if (issocket) _appio_register_current[SOCK_WRITE_CALLS]++; // socket write\n  if (retval >= 0) {\n    _appio_register_current[WRITE_BLOCK_SIZE]= (n * _appio_register_current[WRITE_BLOCK_SIZE] + count)/(n+1); // mean size\n    _appio_register_current[WRITE_BYTES]+= retval; // write bytes\n    if (issocket) _appio_register_current[SOCK_WRITE_BYTES] += retval;\n    if (retval < (int)count) {\n      _appio_register_current[WRITE_SHORT]++; // short write\n      if (issocket) _appio_register_current[SOCK_WRITE_SHORT]++; \n    }\n    _appio_register_current[WRITE_USEC] += duration;\n    if (issocket) _appio_register_current[SOCK_WRITE_USEC] += duration;\n  }\n  if (retval < 0) {\n    _appio_register_current[WRITE_ERR]++; // err\n    if (issocket) _appio_register_current[SOCK_WRITE_ERR]++;\n    if (EINTR == errno)\n      _appio_register_current[WRITE_INTERRUPTED]++; // signal interrupted the op\n    //if ((EAGAIN == errno) || (EWOULDBLOCK == errno)) {\n    //  _appio_register_current[WRITE_WOULD_BLOCK]++; //op would block on descriptor marked as non-blocking\n    //  if (issocket) _appio_register_current[SOCK_WRITE_WOULD_BLOCK]++;\n    //}\n  }\n  return retval;\n}\n\n// The PIC test implies it's built for shared linkage\n#ifdef PIC\nstatic ssize_t (*__recv)(int sockfd, void *buf, size_t len, int flags) = NULL;\nssize_t recv(int sockfd, void *buf, size_t len, int flags) {\n  int retval;\n  SUBDBG(\"appio: intercepted recv(%d,%p,%lu,%d)\\n\", sockfd, buf, (unsigned long)len, flags);\n  if (!__recv) __recv  = dlsym(RTLD_NEXT, \"recv\");\n  if (!__recv) {\n    fprintf(stderr, \"appio,c Internal Error: Could not obtain handle for real recv\\n\");\n    exit(1);\n  }\n  // check if recv would block on descriptor\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(sockfd, &readfds);\n  int ready = __select(sockfd+1, &readfds, NULL, NULL, &zerotv);\n  if (ready == 0) _appio_register_current[RECV_WOULD_BLOCK]++; \n\n  long long start_ts = PAPI_get_real_usec();\n  retval = __recv(sockfd, buf, len, flags);\n  long long duration = PAPI_get_real_usec() - start_ts;\n  int n = _appio_register_current[RECV_CALLS]++; // read calls\n  if (retval > 0) {\n    _appio_register_current[RECV_BLOCK_SIZE]= (n * _appio_register_current[RECV_BLOCK_SIZE] + len)/(n+1); // mean size\n    _appio_register_current[RECV_BYTES] += retval; // read bytes\n    if (retval < (int)len) _appio_register_current[RECV_SHORT]++; // read short\n    _appio_register_current[RECV_USEC] += duration;\n  }\n  if (retval < 0) { \n    _appio_register_current[RECV_ERR]++; // read err\n    if (EINTR == errno)\n      _appio_register_current[RECV_INTERRUPTED]++; // signal interrupted the read\n    if ((EAGAIN == errno) || (EWOULDBLOCK == errno)) \n      _appio_register_current[RECV_WOULD_BLOCK]++; //read would block on descriptor marked as non-blocking\n  }\n  if (retval == 0) _appio_register_current[RECV_EOF]++; // read eof\n  return retval;\n}\n#endif /* PIC */\n\nsize_t _IO_fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) {\n  size_t retval;\n  SUBDBG(\"appio: intercepted fwrite(%p,%lu,%lu,%p)\\n\", ptr, (unsigned long) size, (unsigned long) nmemb, (void*) stream);\n  long long start_ts = PAPI_get_real_usec();\n  retval = _IO_fwrite(ptr,size,nmemb,stream);\n  long long duration = PAPI_get_real_usec() - start_ts;\n  int n = _appio_register_current[WRITE_CALLS]++; // write calls\n  if (retval > 0) {\n    _appio_register_current[WRITE_BLOCK_SIZE]= (n * _appio_register_current[WRITE_BLOCK_SIZE] + size*nmemb)/(n+1); // mean block size\n    _appio_register_current[WRITE_BYTES]+= retval * size; // write bytes\n    if (retval < nmemb) _appio_register_current[WRITE_SHORT]++; // short write\n    _appio_register_current[WRITE_USEC] += duration;\n  }\n  if (retval == 0) _appio_register_current[WRITE_ERR]++; // err\n  return retval;\n}\n\n\n/*********************************************************************\n ***************  BEGIN PAPI's COMPONENT REQUIRED FUNCTIONS  *********\n *********************************************************************/\n\n/*\n * This is called whenever a thread is initialized\n */\nstatic int\n_appio_init_thread( hwd_context_t *ctx )\n{\n    ( void ) ctx;\n    SUBDBG(\"_appio_init_thread %p\\n\", ctx);\n    return PAPI_OK;\n}\n\n\n/* Initialize hardware counters, setup the function vector table\n * and get hardware information, this routine is called when the \n * PAPI process is initialized (IE PAPI_library_init)\n */\nstatic int\n_appio_init_component( int cidx  )\n{\n\n    SUBDBG(\"_appio_component %d\\n\", cidx);\n    _appio_native_events = (APPIO_native_event_entry_t *) papi_calloc(sizeof(APPIO_native_event_entry_t), APPIO_MAX_COUNTERS);\n\n    if (_appio_native_events == NULL ) {\n      PAPIERROR( \"malloc():Could not get memory for events table\" );\n      return PAPI_ENOMEM;\n    }\n    int i;\n    for (i=0; i<APPIO_MAX_COUNTERS; i++) {\n      _appio_native_events[i].name = _appio_counter_info[i].name;\n      _appio_native_events[i].description = _appio_counter_info[i].description;\n      _appio_native_events[i].resources.selector = i + 1;\n    }\n  \n    /* Export the total number of events available */\n    _appio_vector.cmp_info.num_native_events = APPIO_MAX_COUNTERS;;\n\n    /* Export the component id */\n    _appio_vector.cmp_info.CmpIdx = cidx;\n\n    return PAPI_OK;\n}\n\n\n/*\n * Control of counters (Reading/Writing/Starting/Stopping/Setup)\n * functions\n */\nstatic int\n_appio_init_control_state( hwd_control_state_t *ctl )\n{\n    ( void ) ctl;\n\n    return PAPI_OK;\n}\n\n\nstatic int\n_appio_start( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n    ( void ) ctx;\n\n    SUBDBG(\"_appio_start %p %p\\n\", ctx, ctl);\n    APPIO_control_state_t *appio_ctl = (APPIO_control_state_t *) ctl;\n\n    /* this memset needs to move to thread_init */\n    memset(_appio_register_current, 0, APPIO_MAX_COUNTERS * sizeof(_appio_register_current[0]));\n\n    /* set initial values to 0 */\n    memset(appio_ctl->values, 0, APPIO_MAX_COUNTERS*sizeof(appio_ctl->values[0]));\n    \n    return PAPI_OK;\n}\n\n\nstatic int\n_appio_read( hwd_context_t *ctx, hwd_control_state_t *ctl,\n    long long ** events, int flags )\n{\n    (void) flags;\n    (void) ctx;\n\n    SUBDBG(\"_appio_read %p %p\\n\", ctx, ctl);\n    APPIO_control_state_t *appio_ctl = (APPIO_control_state_t *) ctl;\n    int i;\n\n    for ( i=0; i<appio_ctl->num_events; i++ ) {\n            int index = appio_ctl->counter_bits[i];\n            SUBDBG(\"event=%d, index=%d, val=%lld\\n\", i, index, _appio_register_current[index]);\n            appio_ctl->values[index] = _appio_register_current[index];\n    }\n    *events = appio_ctl->values;\n\n    return PAPI_OK;\n}\n\n\nstatic int\n_appio_stop( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n    (void) ctx;\n\n    SUBDBG(\"_appio_stop ctx=%p ctl=%p\\n\", ctx, ctl);\n    APPIO_control_state_t *appio_ctl = (APPIO_control_state_t *) ctl;\n    int i;\n    for ( i=0; i<appio_ctl->num_events; i++ ) {\n            int index = appio_ctl->counter_bits[i];\n            SUBDBG(\"event=%d, index=%d, val=%lld\\n\", i, index, _appio_register_current[index]);\n            appio_ctl->values[i] = _appio_register_current[index];\n    }\n\n    return PAPI_OK;\n}\n\n\n/*\n * Thread shutdown\n */\nstatic int\n_appio_shutdown_thread( hwd_context_t *ctx )\n{\n    ( void ) ctx;\n\n    return PAPI_OK;\n}\n\n\n/*\n * Clean up what was setup in appio_init_component().\n */\nstatic int\n_appio_shutdown_component( void )\n{\n    papi_free( _appio_native_events );\n    return PAPI_OK;\n}\n\n\n/* This function sets various options in the component\n * The valid codes being passed in are PAPI_SET_DEFDOM,\n * PAPI_SET_DOMAIN, PAPI_SETDEFGRN, PAPI_SET_GRANUL and\n * PAPI_SET_INHERIT\n */\nstatic int\n_appio_ctl( hwd_context_t *ctx, int code, _papi_int_option_t *option )\n{\n    ( void ) ctx;\n    ( void ) code;\n    ( void ) option;\n\n    return PAPI_OK;\n}\n\n\nstatic int\n_appio_update_control_state( hwd_control_state_t *ctl,\n        NativeInfo_t *native, int count, hwd_context_t *ctx )\n{\n    ( void ) ctx;\n    ( void ) ctl;\n\n    SUBDBG(\"_appio_update_control_state ctx=%p ctl=%p num_events=%d\\n\", ctx, ctl, count);\n    int i, index;\n    APPIO_control_state_t *appio_ctl = (APPIO_control_state_t *) ctl;\n    (void) ctx;\n\n    for ( i = 0; i < count; i++ ) {\n        index = native[i].ni_event;\n        appio_ctl->counter_bits[i] = index;\n        native[i].ni_position = index;\n    }\n    appio_ctl->num_events = count;\n\n    return PAPI_OK;\n}\n\n\n/*\n * This function has to set the bits needed to count different domains\n * In particular: PAPI_DOM_USER, PAPI_DOM_KERNEL PAPI_DOM_OTHER\n * By default return PAPI_EINVAL if none of those are specified\n * and PAPI_OK with success\n * PAPI_DOM_USER   is only user context is counted\n * PAPI_DOM_KERNEL is only the Kernel/OS context is counted\n * PAPI_DOM_OTHER  is Exception/transient mode (like user TLB misses)\n * PAPI_DOM_ALL    is all of the domains\n */\nstatic int\n_appio_set_domain( hwd_control_state_t *ctl, int domain )\n{\n    ( void ) ctl;\n\n    int found = 0;\n\n    if ( PAPI_DOM_USER == domain )   found = 1;\n\n    if ( !found )\n        return PAPI_EINVAL;\n\n    return PAPI_OK;\n}\n\n\nstatic int\n_appio_reset( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n    ( void ) ctx;\n    ( void ) ctl;\n\n    return PAPI_OK;\n}\n\n\n/*\n * Native Event functions\n */\nstatic int\n_appio_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n    int index;\n\n    switch ( modifier ) {\n        case PAPI_ENUM_FIRST:\n            *EventCode = 0;\n            return PAPI_OK;\n            break;\n\n        case PAPI_ENUM_EVENTS:\n            index = *EventCode;\n            if ( index < APPIO_MAX_COUNTERS - 1 ) {\n                *EventCode = *EventCode + 1;\n                return PAPI_OK;\n            } else {\n                return PAPI_ENOEVNT;\n            }\n            break;\n\n        default:\n            return PAPI_EINVAL;\n            break;\n    }\n    return PAPI_EINVAL;\n}\n\n\n/*\n *\n */\nstatic int\n_appio_ntv_name_to_code( char *name, unsigned int *EventCode )\n{\n    int i;\n\n    for ( i=0; i<APPIO_MAX_COUNTERS; i++) {\n        if (strcmp(name, _appio_counter_info[i].name) == 0) {\n            *EventCode = i;\n            return PAPI_OK;\n        }\n    }\n\n    return PAPI_ENOEVNT;\n}\n\n\n/*\n *\n */\nstatic int\n_appio_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n    int index = EventCode;\n\n    if ( index >= 0 && index < APPIO_MAX_COUNTERS ) {\n        strncpy( name, _appio_counter_info[index].name, len );\n        return PAPI_OK;\n    }\n\n    return PAPI_ENOEVNT;\n}\n\n\n/*\n *\n */\nstatic int\n_appio_ntv_code_to_descr( unsigned int EventCode, char *desc, int len )\n{\n    int index = EventCode;\n\n    if ( index >= 0 && index < APPIO_MAX_COUNTERS ) {\n        strncpy(desc, _appio_counter_info[index].description, len );\n        return PAPI_OK;\n    }\n\n    return PAPI_ENOEVNT;\n}\n\n\n/*\n *\n */\nstatic int\n_appio_ntv_code_to_bits( unsigned int EventCode, hwd_register_t *bits )\n{\n    int index = EventCode;\n\n    if ( index >= 0 && index < APPIO_MAX_COUNTERS ) {\n        memcpy( ( APPIO_register_t * ) bits,\n                &( _appio_native_events[index].resources ),\n                sizeof ( APPIO_register_t ) );\n        return PAPI_OK;\n    }\n\n    return PAPI_ENOEVNT;\n}\n\n\n/*\n *\n */\npapi_vector_t _appio_vector = {\n    .cmp_info = {\n        /* default component information (unspecified values are initialized to 0) */\n        .name                  = \"appio\",\n        .short_name            = \"appio\",\n        .version               = \"1.1.2.4\",\n        .CmpIdx                = 0,              /* set by init_component */\n        .num_mpx_cntrs         = APPIO_MAX_COUNTERS,\n        .num_cntrs             = APPIO_MAX_COUNTERS,\n        .default_domain        = PAPI_DOM_USER,\n        .available_domains   = PAPI_DOM_USER,\n        .default_granularity   = PAPI_GRN_THR,\n        .available_granularities = PAPI_GRN_THR,\n        .hardware_intr_sig     = PAPI_INT_SIGNAL,\n\n        /* component specific cmp_info initializations */\n        .fast_real_timer       = 0,\n        .fast_virtual_timer    = 0,\n        .attach                = 0,\n        .attach_must_ptrace    = 0,\n    },\n\n    /* sizes of framework-opaque component-private structures */\n    .size = {\n        .context               = sizeof ( APPIO_context_t ),\n        .control_state         = sizeof ( APPIO_control_state_t ),\n        .reg_value             = sizeof ( APPIO_register_t ),\n        .reg_alloc             = sizeof ( APPIO_reg_alloc_t ),\n    },\n\n    /* function pointers in this component */\n    .init_thread               = _appio_init_thread,\n    .init_component            = _appio_init_component,\n    .init_control_state        = _appio_init_control_state,\n    .start                     = _appio_start,\n    .stop                      = _appio_stop,\n    .read                      = _appio_read,\n    .shutdown_thread           = _appio_shutdown_thread,\n    .shutdown_component        = _appio_shutdown_component,\n    .ctl                       = _appio_ctl,\n\n    .update_control_state      = _appio_update_control_state,\n    .set_domain                = _appio_set_domain,\n    .reset                     = _appio_reset,\n\n    .ntv_enum_events           = _appio_ntv_enum_events,\n    .ntv_name_to_code          = _appio_ntv_name_to_code,\n    .ntv_code_to_name          = _appio_ntv_code_to_name,\n    .ntv_code_to_descr         = _appio_ntv_code_to_descr,\n    .ntv_code_to_bits          = _appio_ntv_code_to_bits\n    /* .ntv_bits_to_info          = NULL, */\n};\n\n/* vim:set ts=4 sw=4 sts=4 et: */\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/components/libmsr/linux-libmsr.c": "/**\n * @file    linux-libmsr.c\n * @author  Asim YarKhan\n *\n * @ingroup papi_components\n *\n * @brief libmsr component\n *\n * This PAPI component provides access to libmsr from LLNL\n * (https://github.com/scalability-llnl/libmsr), specifically the RAPL\n * (Running Average Power Level) access in libmsr, which provides\n * energy measurements on modern Intel CPUs.\n *\n * To work, either msr_safe kernel module from LLNL\n * (https://github.com/scalability-llnl/msr-safe), or the x86 generic\n * MSR driver must be installed (CONFIG_X86_MSR) and the\n * /dev/cpu/?/<msr_safe | msr> files must have read permissions\n *\n * If /dev/cpu/?/{msr_safe,msr} have appropriate write permissions,\n * you can write to the events PACKAGE_POWER_LIMIT_{1,2} to change the\n * average power (in watts) consumed by the packages/sockets over a\n * certain time window specified by events\n * PKG_TIME_WINDOW_POWER_LIMIT_{1,2} respectively.\n */\n/* Based on the rapl component by Vince Weaver */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\n/* Headers required by PAPI */\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\n#include <msr/msr_core.h>\n#include <msr/msr_rapl.h>\n#include <msr/msr_counters.h>\n\ntypedef enum {\n    PKG_ENERGY=0,\n    PKG_ELAPSED,\n    PKG_DELTA_ENERGY,\n    PKG_WATTS,\n    PKG_POWER_LIMIT_1,\n    PKG_TIME_WINDOW_POWER_LIMIT_1,\n    PKG_POWER_LIMIT_2,\n    PKG_TIME_WINDOW_POWER_LIMIT_2,\n    NUM_OF_EVENTTYPES\n} eventtype_enum;\n\ntypedef struct _libmsr_register {\n    unsigned int selector;\n} _libmsr_register_t;\n\ntypedef struct _libmsr_native_event_entry {\n    char name[PAPI_MAX_STR_LEN];\n    char units[PAPI_MIN_STR_LEN];\n    char description[PAPI_MAX_STR_LEN];\n    int package_num;            /* which package/socket for this event */\n    eventtype_enum eventtype;\n    int return_type;\n    _libmsr_register_t resources;\n} _libmsr_native_event_entry_t;\n\ntypedef struct _libmsr_reg_alloc {\n    _libmsr_register_t ra_bits;\n} _libmsr_reg_alloc_t;\n\n/* actually 32? But setting this to be safe? */\n#define LIBMSR_MAX_COUNTERS 64\n#define LIBMSR_MAX_PACKAGES 64\n\ntypedef struct _libmsr_control_state {\n    /* The following are one per event being measured */\n    int num_events_measured;\n    /* int domain; */\n    /* int multiplexed; */\n    /* int overflow; */\n    /* int inherit; */\n    int being_measured[LIBMSR_MAX_COUNTERS];\n    int which_counter[LIBMSR_MAX_COUNTERS];\n    long long count[LIBMSR_MAX_COUNTERS];\n    /* The following is boolean: Is package NN active in for event */\n    int package_being_measured[LIBMSR_MAX_PACKAGES];\n} _libmsr_control_state_t;\n\ntypedef struct _libmsr_context {\n    _libmsr_control_state_t state;\n} _libmsr_context_t;\n\npapi_vector_t _libmsr_vector;\n\nstatic _libmsr_native_event_entry_t *libmsr_native_events = NULL;\nstatic int num_events_global = 0;\nstatic int already_called_libmsr_rapl_initialized_global = 0;\n\n/***************************************************************************/\n\n/* For dynamic linking to libmsr */\n/* Using weak symbols allows PAPI to be built with the component, but\n * installed in a system without the required library */\n#include <dlfcn.h>\nstatic void* dllib1 = NULL;\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));\n\n/* Functions pointers */\nstatic int (*init_msr_ptr)();\nstatic int (*finalize_msr_ptr)();\nstatic int (*rapl_init_ptr)(struct rapl_data ** rapl, uint64_t ** rapl_flags);\nstatic int (*poll_rapl_data_ptr) ( );\nstatic void (*set_pkg_rapl_limit_ptr) ( const int socket, struct rapl_limit* limit1, struct rapl_limit* limit2 );\nstatic void (*get_pkg_rapl_limit_ptr) ( const int socket, struct rapl_limit* limit1, struct rapl_limit* limit2 );\nstatic int (*core_config_ptr) (uint64_t * coresPerSocket, uint64_t * threadsPerCore, uint64_t * sysSockets, int * HTenabled);\nstatic int (*rapl_storage_ptr) (struct rapl_data ** data, uint64_t ** flags);\nstatic int (*get_rapl_power_info_ptr) ( const unsigned socket, struct rapl_power_info *info);\n\n/* Local wrappers for function pointers */\nstatic int libmsr_init_msr () { return ((*init_msr_ptr)()); }\nstatic int libmsr_finalize_msr () { return ((*finalize_msr_ptr)()); }\nstatic int libmsr_rapl_init (struct rapl_data ** rapl_data, uint64_t ** rapl_flags) { return (*rapl_init_ptr)( rapl_data, rapl_flags ); }\nstatic int libmsr_poll_rapl_data ( ) { return (*poll_rapl_data_ptr) (); }\nstatic void libmsr_set_pkg_rapl_limit ( const int socket, struct rapl_limit* limit1, struct rapl_limit* limit2 ) { return (*set_pkg_rapl_limit_ptr) ( socket, limit1, limit2 ); }\nstatic void libmsr_get_pkg_rapl_limit ( const int socket, struct rapl_limit* limit1, struct rapl_limit* limit2 ) { return (*get_pkg_rapl_limit_ptr) ( socket, limit1, limit2 ); }\nstatic int libmsr_core_config(uint64_t * coresPerSocket, uint64_t * threadsPerCore, uint64_t * sysSockets, int * HTenabled) { return (*core_config_ptr) ( coresPerSocket, threadsPerCore, sysSockets, HTenabled ); }\nstatic int libmsr_rapl_storage(struct rapl_data ** data, uint64_t ** flags) { return (*rapl_storage_ptr) (data, flags); }\nstatic int libmsr_get_rapl_power_info( const unsigned socket, struct rapl_power_info *info) { return (*get_rapl_power_info_ptr) ( socket, info); }\n\n\n#define CHECK_DL_STATUS( err, str ) if( err ) { strncpy( _libmsr_vector.cmp_info.disabled_reason, str, PAPI_MAX_STR_LEN ); return ( PAPI_ENOSUPP ); }\nstatic int _local_linkDynamicLibraries()\n{\n    if ( _dl_non_dynamic_init != NULL ) {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"The libmsr component REQUIRES dynamic linking capabilities.\", PAPI_MAX_STR_LEN);\n        return PAPI_ENOSUPP;\n    }\n    dllib1 = dlopen(\"libmsr.so\", RTLD_NOW | RTLD_GLOBAL);\n    CHECK_DL_STATUS( !dllib1 , \"Component library libmsr.so not found.\" );\n    init_msr_ptr = dlsym( dllib1, \"init_msr\" );\n    CHECK_DL_STATUS( dlerror()!=NULL , \"libmsr function init_msr not found.\" );\n    finalize_msr_ptr = dlsym( dllib1, \"finalize_msr\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function finalize_msr not found.\" );\n    rapl_init_ptr = dlsym( dllib1, \"rapl_init\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function rapl_init not found.\" );\n    poll_rapl_data_ptr = dlsym( dllib1, \"poll_rapl_data\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function poll_rapl_data not found.\" );\n    set_pkg_rapl_limit_ptr = dlsym( dllib1, \"set_pkg_rapl_limit\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function set_pkg_rapl_limit not found.\" );\n    get_pkg_rapl_limit_ptr = dlsym( dllib1, \"get_pkg_rapl_limit\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function get_pkg_rapl_limit not found.\" );\n    core_config_ptr = dlsym( dllib1, \"core_config\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function core_config not found.\" );\n    rapl_storage_ptr = dlsym( dllib1, \"rapl_storage\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function rapl_storage not found.\" );\n    get_rapl_power_info_ptr = dlsym( dllib1, \"get_rapl_power_info\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function get_rapl_power_info not found.\" );\n    return( PAPI_OK);\n}\n\n/***************************************************************************/\n/******  BEGIN FUNCTIONS  USED INTERNALLY SPECIFIC TO THIS COMPONENT *******/\n/***************************************************************************/\n\n/* Null terminated version of strncpy */\nstatic char * _local_strlcpy( char *dst, const char *src, size_t size )\n{\n    char *retval = strncpy( dst, src, size );\n    if ( size>0 ) dst[size-1] = '\\0';\n    return( retval );\n}\n\n\nvoid _local_set_to_defaults()\n{\n    uint64_t socket, numSockets;\n    struct rapl_power_info raplinfo;\n    struct rapl_limit socketlim, socketlim2;\n\n    SUBDBG(\"Enter: Resetting the sockets to defaults\\n\");\n    libmsr_core_config( NULL, NULL, &numSockets, NULL);\n    for (socket = 0; socket < numSockets; socket++)  {\n        libmsr_get_rapl_power_info(socket, &raplinfo);\n        socketlim.bits = 0;\n        socketlim.watts = raplinfo.pkg_therm_power;\n        socketlim.seconds = 1;\n        socketlim2.bits = 0;\n        socketlim2.watts = raplinfo.pkg_therm_power * 1.2;\n        socketlim2.seconds = 3;\n        SUBDBG(\"Resetting socket %ld to defaults (%f,%f) (%f,%f)\\n\", socket, socketlim.watts, socketlim.seconds, socketlim2.watts, socketlim2.seconds);\n        libmsr_set_pkg_rapl_limit(socket, &socketlim, &socketlim2);\n    }\n}\n\n\n/************************* PAPI Functions **********************************/\n\n/*\n * This is called whenever a thread is initialized\n */\nint _libmsr_init_thread( hwd_context_t * ctx )\n{\n    ( void ) ctx;\n    return PAPI_OK;\n}\n\n\n/*\n * Called when PAPI process is initialized (i.e. PAPI_library_init)\n */\nint _libmsr_init_component( int cidx )\n{\n    SUBDBG( \"Enter: cidx: %d\\n\", cidx );\n    int i, j;\n    /* int package; */\n    /* FILE *fff; */\n    /* char filename[BUFSIZ]; */\n    int num_packages;\n    /* int num_cpus; */\n    const PAPI_hw_info_t *hw_info;\n    int retval;\n    struct rapl_data * libmsr_rapl_data;\n    uint64_t * libmsr_rapl_flags;\n    uint64_t coresPerSocket, threadsPerCore, numSockets;\n    int HTenabled;\n\n    /* check if Intel processor */\n    hw_info = &( _papi_hwi_system_info.hw_info );\n    /* Can't use PAPI_get_hardware_info() if PAPI library not done initializing yet */\n    if( hw_info->vendor != PAPI_VENDOR_INTEL ) {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Not an Intel processor\", PAPI_MAX_STR_LEN );\n        return PAPI_ENOSUPP;\n    }\n\n    /* Dynamically load libmsr API and libraries  */\n    retval = _local_linkDynamicLibraries();\n    if ( retval!=PAPI_OK ) {\n        SUBDBG (\"Dynamic link of libmsr.so libraries failed, component will be disabled.\\n\");\n        SUBDBG (\"See disable reason in papi_component_avail output for more details.\\n\");\n        return (PAPI_ENOSUPP);\n    }\n\n    /* initialize libmsr */\n    if ( libmsr_init_msr() != 0 ) {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Library libmsr could not initialize (libmsr/init_msr failed)\", PAPI_MAX_STR_LEN );\n        SUBDBG( \"init_msr (libmsr) returned error.  Possible problems accessing /dev/cpu/<n>/msr_safe or /dev/cpu/<n>/msr\"); \n        return PAPI_ENOSUPP; \n    }\n\n    /* Initialize libmsr RAPL */\n    if ( already_called_libmsr_rapl_initialized_global==0 ) {\n        if ( libmsr_rapl_init( &libmsr_rapl_data, &libmsr_rapl_flags ) < 0 ) {\n            strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Library libmsr could not initialize RAPL (libmsr/rapl_init failed)\", PAPI_MAX_STR_LEN );\n            SUBDBG( \"Library libmsr could not initialize RAPL (libmsr/rapl_init failed)\"); \n            return PAPI_ENOSUPP;\n        }\n        already_called_libmsr_rapl_initialized_global = 1;\n    }\n\n    /* Get the numbers of cores, threads, sockets, ht */\n    libmsr_core_config(&coresPerSocket, &threadsPerCore, &numSockets, &HTenabled);\n\n    /* Fill packages and cpus with sentinel values */\n    /* int packages[numSockets]; */\n    /* for( i = 0; i < numSockets; ++i ) packages[i] = -1; */\n    /* num_cpus = numSockets*coresPerSocket; */\n    num_packages = numSockets;\n\n    /* /\\* Detect how many packages and count num_cpus *\\/ */\n    /* num_cpus = 0; */\n    /* while( 1 ) { */\n    /*     int num_read; */\n    /*     sprintf( filename, \"/sys/devices/system/cpu/cpu%d/topology/physical_package_id\", num_cpus ); */\n    /*     fff = fopen( filename, \"r\" ); */\n    /*     if( fff == NULL ) break; */\n    /*     num_read = fscanf( fff, \"%d\", &package ); */\n    /*     fclose( fff ); */\n    /*     if( num_read != 1 ) { */\n    /*         strcpy( _libmsr_vector.cmp_info.disabled_reason, \"Error reading file: \" ); */\n    /*         strncat( _libmsr_vector.cmp_info.disabled_reason, filename, PAPI_MAX_STR_LEN - strlen( _libmsr_vector.cmp_info.disabled_reason ) - 1 ); */\n    /*         _libmsr_vector.cmp_info.disabled_reason[PAPI_MAX_STR_LEN - 1] = '\\0'; */\n    /*         return PAPI_ESYS; */\n    /*     } */\n    /*     /\\* Check if a new package *\\/ */\n    /*     if( ( package >= 0 ) && ( package < nr_cpus ) ) { */\n    /*         if( packages[package] == -1 ) { */\n    /*             SUBDBG( \"Found package %d out of total %d\\n\", package, num_packages ); */\n    /*             packages[package] = package; */\n    /*             num_packages++; */\n    /*         } */\n    /*     } else { */\n    /*         SUBDBG( \"Package outside of allowed range\\n\" ); */\n    /*         strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Package outside of allowed range\", PAPI_MAX_STR_LEN ); */\n    /*         return PAPI_ESYS; */\n    /*     } */\n    /*     num_cpus++; */\n    /* } */\n\n    /* /\\* Error if no accessible packages *\\/ */\n    /* if( num_packages == 0 ) { */\n    /*     SUBDBG( \"Can't access any physical packages\\n\" ); */\n    /*     strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Can't access /sys/devices/system/cpu/cpu<d>/topology/physical_package_id\", PAPI_MAX_STR_LEN ); */\n    /*     return PAPI_ESYS; */\n    /* } */\n    /* SUBDBG( \"Found %d packages with %d cpus\\n\", num_packages, num_cpus ); */\n\n    int max_num_events = ( NUM_OF_EVENTTYPES * num_packages );\n    /* Allocate space for events */\n    libmsr_native_events = ( _libmsr_native_event_entry_t * ) calloc( sizeof( _libmsr_native_event_entry_t ), max_num_events );\n    if ( !libmsr_native_events ) SUBDBG(\"Could not allocate memory\\n\" );\n\n    /* Create events for package power info */\n    num_events_global = 0;\n    i = 0;\n    for( j = 0; j < num_packages; j++ ) {\n\n        sprintf( libmsr_native_events[i].name, \"PKG_ENERGY:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"J\", PAPI_MIN_STR_LEN );\n        sprintf(libmsr_native_events[i].description,\"Number of Joules consumed by all cores and last level cache on package.  Unit is Joules (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_ENERGY;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_WATTS:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"W\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Watts consumed by package. Unit is Watts (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_WATTS;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_ELAPSED:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"S\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Time elapsed since last LIBMSR data reading from package. Unit is seconds (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_ELAPSED;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_DELTA_ENERGY:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"J\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Number of Joules consumed by package since last LIBMSR data reading.  Unit is Joules (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_DELTA_ENERGY;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_POWER_LIMIT_1:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"W\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Average power limit over PKG_TIME_WINDOW_POWER_LIMIT_1 for package. Read/Write. Unit is Watts (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_POWER_LIMIT_1;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_TIME_WINDOW_POWER_LIMIT_1:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"S\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Time window used for averaging PACKAGE_POWER_LIMIT_1 for package.  Read/Write.  Unit is seconds (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_TIME_WINDOW_POWER_LIMIT_1;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_POWER_LIMIT_2:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"W\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Average power limit over PKG_TIME_WINDOW_POWER_LIMIT_2 for package. Read/Write. Unit is Watts (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_POWER_LIMIT_2;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_TIME_WINDOW_POWER_LIMIT_2:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"S\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Time window used for averaging PACKAGE_POWER_LIMIT_2 for package.  Read/Write.  Unit is seconds (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_TIME_WINDOW_POWER_LIMIT_2;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        // TODO Add DRAM values\n        // DRAM_ENERGY\n        // DRAM_DELTA_ENERGY\n        // DRAM_WATTS\n        // TODO Add PP0, PP1 events\n    }\n    num_events_global = i;\n\n    /* Export the total number of events available */\n    _libmsr_vector.cmp_info.num_native_events = num_events_global;\n    _libmsr_vector.cmp_info.num_cntrs = _libmsr_vector.cmp_info.num_native_events;\n    _libmsr_vector.cmp_info.num_mpx_cntrs = _libmsr_vector.cmp_info.num_native_events;\n\n    /* Export the component id */\n    _libmsr_vector.cmp_info.CmpIdx = cidx;\n\n    return PAPI_OK;\n}\n\n\n/*\n * Control of counters (Reading/Writing/Starting/Stopping/Setup)\n */\nint _libmsr_init_control_state( hwd_control_state_t * ctl )\n{\n    SUBDBG( \"Enter: ctl: %p\\n\", ctl );\n    _libmsr_control_state_t *control = ( _libmsr_control_state_t * ) ctl;\n    int i;\n\n    for( i = 0; i < LIBMSR_MAX_COUNTERS; i++ )\n        control->which_counter[i] = 0;\n    for( i = 0; i < LIBMSR_MAX_PACKAGES; i++ )\n        control->package_being_measured[i] = 0;\n    control->num_events_measured = 0;\n\n    return PAPI_OK;\n}\n\n\nint _libmsr_update_control_state( hwd_control_state_t * ctl, NativeInfo_t * native, int count, hwd_context_t * ctx )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    int nn, index;\n    ( void ) ctx;\n    _libmsr_control_state_t *control = ( _libmsr_control_state_t * ) ctl;\n\n    control->num_events_measured = 0;\n    /* Track which events need to be measured */\n    for( nn = 0; nn < count; nn++ ) {\n        index = native[nn].ni_event & PAPI_NATIVE_AND_MASK;\n        native[nn].ni_position = nn;\n        control->which_counter[nn] = index;\n        control->count[nn] = 0;\n        /* Track (on/off vector) which packages/sockets need to be measured for these events */\n        control->package_being_measured[libmsr_native_events[index].package_num] = 1;\n        control->num_events_measured++;\n    }\n    return PAPI_OK;\n}\n\n\nint _libmsr_start( hwd_context_t * ctx, hwd_control_state_t * ctl )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    ( void ) ctx;\n    ( void ) ctl;\n\n    /* Read once to get initial data */\n    if ( libmsr_poll_rapl_data() < 0 ) {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Function libmsr.so:poll_rapl_data failed. \", PAPI_MAX_STR_LEN );\n        return PAPI_ESYS;\n    }\n    return PAPI_OK;\n}\n\n\nint _libmsr_read( hwd_context_t * ctx, hwd_control_state_t * ctl, long long **events, int flags )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    ( void ) flags;\n    ( void ) ctx;\n    _libmsr_control_state_t *control = ( _libmsr_control_state_t * ) ctl;\n    int nn, pp, ee;                 /* native, package, event indices */\n    union { long long ll; double dbl; } event_value_union;\n    struct rapl_limit limit1, limit2;\n    eventtype_enum eventtype;\n    struct rapl_data * libmsr_rapl_data;\n    uint64_t * libmsr_rapl_flags;\n\n    /* Get a pointer to the rapl_data data storage  */\n    if ( libmsr_rapl_storage( &libmsr_rapl_data, &libmsr_rapl_flags)!=0 )  {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Function libmsr.so:rapl_storage failed. \", PAPI_MAX_STR_LEN );\n        return PAPI_ESYS;\n    }\n\n    /* If any socket/package needs to be read, call the poll once to read all packages */\n    for ( pp = 0; pp < LIBMSR_MAX_PACKAGES; pp++ ) {\n        if ( control->package_being_measured[pp] ) {\n            SUBDBG(\"Calling poll_rapl_data to read state from all sockets\\n\");\n            if ( libmsr_poll_rapl_data()!= 0 ) {\n                strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Function libmsr.so:poll_rapl_data failed. \", PAPI_MAX_STR_LEN );\n                return PAPI_ESYS;\n            }\n            break;\n        }\n    }\n\n    /* Go thru events, assign package data to events as needed */\n    SUBDBG(\"Go thru events, assign package data to events as needed\\n\");\n    for( nn = 0; nn < control->num_events_measured; nn++ ) {\n        ee = control->which_counter[nn];\n        pp = libmsr_native_events[ee].package_num;\n        event_value_union.ll = 0LL;\n        eventtype = libmsr_native_events[ee].eventtype;\n        SUBDBG(\"nn %d ee %d pp %d eventtype %d\\n\", nn, ee, pp, eventtype);\n        switch (eventtype) {\n        case PKG_ENERGY:\n            event_value_union.dbl = libmsr_rapl_data->pkg_joules[pp];\n            break;\n        case PKG_ELAPSED:\n            event_value_union.dbl = libmsr_rapl_data->elapsed;\n            break;\n        case PKG_DELTA_ENERGY:\n            event_value_union.dbl = libmsr_rapl_data->pkg_delta_joules[pp];\n            break;\n        case PKG_WATTS:\n            event_value_union.dbl = libmsr_rapl_data->pkg_watts[pp];\n            break;\n        case PKG_POWER_LIMIT_1:\n            limit1.bits = 0;  limit1.watts = 0; limit1.seconds = 0;\n            libmsr_get_pkg_rapl_limit( pp, &limit1, NULL );\n            event_value_union.dbl = limit1.watts;\n            break;\n        case PKG_TIME_WINDOW_POWER_LIMIT_1:\n            limit1.bits = 0;  limit1.watts = 0; limit1.seconds = 0;\n            libmsr_get_pkg_rapl_limit( pp, &limit1, NULL );\n            event_value_union.dbl = limit1.seconds;\n            break;\n        case PKG_POWER_LIMIT_2:\n            limit2.bits = 0;  limit2.watts = 0; limit2.seconds = 0;\n            libmsr_get_pkg_rapl_limit( pp, NULL, &limit2 );\n            event_value_union.dbl = limit2.watts;\n            break;\n        case PKG_TIME_WINDOW_POWER_LIMIT_2:\n            limit2.bits = 0;  limit2.watts = 0; limit2.seconds = 0;\n            libmsr_get_pkg_rapl_limit( pp, NULL, &limit2 );\n            event_value_union.dbl = limit2.seconds;\n            break;\n        default:\n            SUBDBG(\"This LIBMSR event is unknown\\n\");\n            /* error here */\n        }\n        control->count[nn] = event_value_union.ll;\n    }\n    /* Pass back a pointer to our results */\n    if ( events!=NULL ) *events = ( ( _libmsr_control_state_t * ) ctl )->count;\n    return PAPI_OK;\n}\n\n\nstatic long long _local_get_eventval_from_values( _libmsr_control_state_t *control, long long *invalues, int package_num, eventtype_enum eventtype, long long defaultval )\n{\n    int nn, pp, ee;                 /* native, package, event indices */\n    /* Loop thru all the events, if package and repltype match, return the value  */\n    for( nn = 0; nn < control->num_events_measured; nn++ ) {\n        ee = control->which_counter[nn];\n        pp = libmsr_native_events[ee].package_num;\n        if ( pp == package_num && libmsr_native_events[ee].eventtype == eventtype )\n            return invalues[ee];\n    }\n    return defaultval;\n}\n\n\nint _libmsr_write( hwd_context_t * ctx, hwd_control_state_t * ctl, long long *values )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    /* write values */\n    ( void ) ctx;\n    _libmsr_control_state_t *control = ( _libmsr_control_state_t * ) ctl;\n    //long long now = PAPI_get_real_usec();\n    int nn, pp, ee;                 /* native, package, event indices */\n    union { long long ll; double dbl; } event_value_union;\n    union { long long ll; double dbl; } timewin_union;\n    struct rapl_limit limit1, limit2;\n    eventtype_enum eventtype;\n\n    /* Go thru events, assign package data to events as needed */\n    for( nn = 0; nn < control->num_events_measured; nn++ ) {\n        ee = control->which_counter[nn];\n        pp = libmsr_native_events[ee].package_num;\n        /* grab value and put into the union structure */\n        event_value_union.ll = values[nn];\n        /* If this is a NULL value, it means that the user does not want to write this value */\n        if ( event_value_union.ll == PAPI_NULL ) continue;\n        eventtype = libmsr_native_events[ee].eventtype;\n        SUBDBG(\"nn %d ee %d pp %d eventtype %d\\n\", nn, ee, pp, eventtype);\n        switch (eventtype) {\n        case PKG_ENERGY:\n        case PKG_ELAPSED:\n        case PKG_WATTS:\n        case PKG_DELTA_ENERGY:\n            /* Read only so do nothing */\n            break;\n        case PKG_POWER_LIMIT_1:\n            timewin_union.ll = _local_get_eventval_from_values( control, values, pp, PKG_TIME_WINDOW_POWER_LIMIT_1, -1 );\n            if ( timewin_union.ll > 0 ) {\n                limit1.watts = event_value_union.dbl;\n                limit1.seconds = timewin_union.dbl;\n                limit1.bits = 0;\n                //printf(\"set_libmsr_limit package %d limit1 %lf %lf\\n\", pp, limit1.watts, limit1.seconds);\n                libmsr_set_pkg_rapl_limit( pp, &limit1, NULL  );\n            } else {\n                // Note error - power limit1 is not updated\n                SUBDBG(\"PACKAGE_POWER_LIMIT_1 needs PKG_TIME_WINDOW_POWER_LIMIT_1: Power cap not updated. \");\n            }\n            break;\n        case PKG_POWER_LIMIT_2:\n            timewin_union.ll = _local_get_eventval_from_values( control, values, pp, PKG_TIME_WINDOW_POWER_LIMIT_2, -1 );\n            if ( timewin_union.ll > 0 ) {\n                limit2.watts = event_value_union.dbl;\n                limit2.seconds = timewin_union.dbl;\n                limit2.bits = 0;\n                //printf(\"set_libmsr_limit package %d limit2 %lf %lf \\n\", pp, limit2.watts, limit2.seconds);\n                libmsr_set_pkg_rapl_limit( pp, NULL, &limit2 );\n            } else {\n                // Write error\n                PAPIERROR(\"PACKAGE_POWER_LIMIT_1 needs PKG_TIME_WINDOW_POWER_LIMIT_1: Powercap not updated.\");\n            }\n            break;\n        case PKG_TIME_WINDOW_POWER_LIMIT_1:\n        case PKG_TIME_WINDOW_POWER_LIMIT_2:\n            /* These are only meaningful (and looked up) if the power limits are set */\n            break;\n        default:\n            SUBDBG(\"This LIBMSR information type is unknown\\n\");\n            /* error here */\n        }\n    }\n    return PAPI_OK;\n}\n\n\nint _libmsr_stop( hwd_context_t * ctx, hwd_control_state_t * ctl )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    ( void ) ctx;\n    ( void ) ctl;\n    _local_set_to_defaults();\n    return PAPI_OK;\n}\n\n\n/* Shutdown a thread */\nint _libmsr_shutdown_thread( hwd_context_t * ctx )\n{\n    SUBDBG( \"Enter: ctl: %p\\n\", ctx );\n    ( void ) ctx;\n    return PAPI_OK;\n}\n\n\n/*\n * Clean up what was setup in  libmsr_init_component().\n */\nint _libmsr_shutdown_component( void )\n{\n    SUBDBG( \"Enter\\n\" );\n\n    _local_set_to_defaults();\n\n    if ( libmsr_finalize_msr()!=0 ) {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Function libmsr.so:finalize_msr failed. \", PAPI_MAX_STR_LEN );\n        return PAPI_ESYS;\n    }\n    if( libmsr_native_events ) {\n        free( libmsr_native_events );\n        libmsr_native_events = NULL;\n    }\n    dlclose( dllib1 );\n    return PAPI_OK;\n}\n\n\n/* This function sets various options in the component The valid codes\n * being passed in are PAPI_SET_DEFDOM, PAPI_SET_DOMAIN,\n * PAPI_SETDEFGRN, PAPI_SET_GRANUL * and PAPI_SET_INHERIT */\nint _libmsr_ctl( hwd_context_t * ctx, int code, _papi_int_option_t * option )\n{\n    SUBDBG( \"Enter: ctx: %p\\n\", ctx );\n    ( void ) ctx;\n    ( void ) code;\n    ( void ) option;\n\n    return PAPI_OK;\n}\n\n\n/*\n * This function has to set the bits needed to count different domains\n * In particular: PAPI_DOM_USER, PAPI_DOM_KERNEL PAPI_DOM_OTHER\n * By default return PAPI_EINVAL if none of those are specified\n * and PAPI_OK with success\n * PAPI_DOM_USER is only user context is counted\n * PAPI_DOM_KERNEL is only the Kernel/OS context is counted\n * PAPI_DOM_OTHER  is Exception/transient mode (like user TLB misses)\n * PAPI_DOM_ALL   is all of the domains\n */\nint _libmsr_set_domain( hwd_control_state_t * ctl, int domain )\n{\n    SUBDBG( \"Enter: ctl: %p\\n\", ctl );\n    ( void ) ctl;\n    /* In theory we only support system-wide mode */\n    /* How to best handle that? */\n    if( domain != PAPI_DOM_ALL )\n        return PAPI_EINVAL;\n    return PAPI_OK;\n}\n\n\nint _libmsr_reset( hwd_context_t * ctx, hwd_control_state_t * ctl )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    ( void ) ctx;\n    ( void ) ctl;\n\n    return PAPI_OK;\n}\n\n\n/*\n * Native Event functions\n */\nint _libmsr_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n    SUBDBG( \"Enter: EventCode: %d\\n\", *EventCode );\n    int index;\n    if ( num_events_global == 0 )\n        return PAPI_ENOEVNT;\n\n    switch ( modifier ) {\n    case PAPI_ENUM_FIRST:\n        *EventCode = 0;\n        return PAPI_OK;\n        break;\n    case PAPI_ENUM_EVENTS:\n        index = *EventCode & PAPI_NATIVE_AND_MASK;\n        if ( index < num_events_global - 1 ) {\n            *EventCode = *EventCode + 1;\n            return PAPI_OK;\n        } else {\n            return PAPI_ENOEVNT;\n        }\n        break;\n        // case PAPI_NTV_ENUM_UMASKS:\n    default:\n        return PAPI_EINVAL;\n    }\n\n    return PAPI_EINVAL;\n}\n\n\n/*\n *\n */\nint _libmsr_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n    SUBDBG( \"Enter: EventCode: %d\\n\", EventCode );\n    int index = EventCode & PAPI_NATIVE_AND_MASK;\n\n    if( index >= 0 && index < num_events_global ) {\n        _local_strlcpy( name, libmsr_native_events[index].name, len );\n        return PAPI_OK;\n    }\n    return PAPI_ENOEVNT;\n}\n\n\nint _libmsr_ntv_code_to_descr( unsigned int EventCode, char *name, int len )\n{\n    SUBDBG( \"Enter: EventCode: %d\\n\", EventCode );\n    int index = EventCode;\n\n    if( ( index < 0 ) || ( index >= num_events_global ) )\n        return PAPI_ENOEVNT;\n\n    _local_strlcpy( name, libmsr_native_events[index].description, len );\n    return PAPI_OK;\n}\n\n\nint _libmsr_ntv_code_to_info( unsigned int EventCode, PAPI_event_info_t * info )\n{\n    SUBDBG( \"Enter: EventCode: %d\\n\", EventCode );\n    int index = EventCode;\n\n    if( ( index < 0 ) || ( index >= num_events_global ) )\n        return PAPI_ENOEVNT;\n\n    _local_strlcpy( info->symbol, libmsr_native_events[index].name, sizeof( info->symbol ) );\n    _local_strlcpy( info->long_descr, libmsr_native_events[index].description, sizeof( info->long_descr ) );\n    _local_strlcpy( info->units, libmsr_native_events[index].units, sizeof( info->units ) );\n    info->data_type = libmsr_native_events[index].return_type;\n    return PAPI_OK;\n}\n\n\npapi_vector_t _libmsr_vector = {\n    .cmp_info = {               /* (unspecified values are initialized to 0) */\n        .name = \"libmsr\",\n        .short_name = \"libmsr\",\n        .description = \"PAPI component for libmsr from LANL for power (RAPL) read/write\",\n        .version = \"5.3.0\",\n        .default_domain = PAPI_DOM_ALL,\n        .default_granularity = PAPI_GRN_SYS,\n        .available_granularities = PAPI_GRN_SYS,\n        .hardware_intr_sig = PAPI_INT_SIGNAL,\n        .available_domains = PAPI_DOM_ALL,\n    },\n    /* sizes of framework-opaque component-private structures */\n    .size = {\n        .context = sizeof( _libmsr_context_t ),\n        .control_state = sizeof( _libmsr_control_state_t ),\n        .reg_value = sizeof( _libmsr_register_t ),\n        .reg_alloc = sizeof( _libmsr_reg_alloc_t ),\n    },\n    /* function pointers in this component */\n    .start = _libmsr_start,\n    .stop = _libmsr_stop,\n    .read = _libmsr_read,\n    .reset = _libmsr_reset,\n    .write = _libmsr_write,\n    .init_component = _libmsr_init_component,\n    .init_thread = _libmsr_init_thread,\n    .init_control_state = _libmsr_init_control_state,\n    .update_control_state = _libmsr_update_control_state,\n    .ctl = _libmsr_ctl,\n    .set_domain = _libmsr_set_domain,\n    .ntv_enum_events = _libmsr_ntv_enum_events,\n    .ntv_code_to_name = _libmsr_ntv_code_to_name,\n    .ntv_code_to_descr = _libmsr_ntv_code_to_descr,\n    .ntv_code_to_info = _libmsr_ntv_code_to_info,\n    .shutdown_thread = _libmsr_shutdown_thread,\n    .shutdown_component = _libmsr_shutdown_component,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/components/host_micpower/linux-host_micpower.c": "/** linux-host_micpower.c\n *\t@author James Ralph\n *\tralph@icl.utk.edu\n *\n *\t@ingroup papi_components\n *\n *\t@brief\n *\t\tThis component wraps the MicAccessAPI to provide hostside \n *\t\tpower information for attached Intel Xeon Phi (MIC) cards.\n*/ \n\n/* From intel examples, see $(mic_dir)/sysmgt/sdk/Examples/Usage */\n#define MAX_DEVICES (32)\n#define EVENTS_PER_DEVICE 10\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <dlfcn.h> \n\n#include \"MicAccessTypes.h\"\n#include \"MicBasicTypes.h\"\n#include \"MicAccessErrorTypes.h\"\n#include \"MicAccessApi.h\"\n#include \"MicPowerManagerAPI.h\"\n\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));\n\n/* This is a guess, refine this later */\n#define UPDATEFREQ 500000\n\npapi_vector_t _host_micpower_vector;\n\ntypedef struct host_micpower_register {\n\t/** Corresponds to counter slot, indexed from 1, 0 has a special meaning */\n\tunsigned int selector;\n} host_micpower_register_t;\n\ntypedef struct host_micpower_reg_alloc {\n\thost_micpower_register_t ra_bits;\n} host_micpower_reg_alloc_t;\n\n/** Internal structure used to build the table of events */\ntypedef struct host_micpower_native_event_entry {\n\thost_micpower_register_t resources; \n\tchar name[PAPI_MAX_STR_LEN];\n\tchar description[PAPI_MAX_STR_LEN];\n\tchar units[3];\n} host_micpower_native_event_entry_t;\n\n/** Per-eventset structure used to hold control flags. */\ntypedef struct host_micpower_control_state {\n\tint num_events;\n\tint resident[MAX_DEVICES*EVENTS_PER_DEVICE];\n\tlong long counts[MAX_DEVICES*EVENTS_PER_DEVICE];\n\tlong long lastupdate[MAX_DEVICES];\n} host_micpower_control_state_t;\n\n/** Per-thread data */\ntypedef struct host_micpower_context {\n\thost_micpower_control_state_t state;\n} host_micpower_context_t; \n\n/* Global state info */\nstatic MicDeviceOnSystem adapters[MAX_DEVICES];\nstatic HANDLE handles[MAX_DEVICES];\nstatic long long lastupdate[MAX_DEVICES];\nstatic HANDLE accessHandle = NULL;\nstatic U32 nAdapters = MAX_DEVICES;\n\nstatic void* mic_access \t= \tNULL;\nstatic void* scif_access\t=\tNULL;\n\n#undef MICACCESS_API\n#define MICACCESS_API __attribute__((weak))\nconst char *MicGetErrorString(U32);\nU32 MICACCESS_API MicCloseAdapter(HANDLE);\nU32 MICACCESS_API MicInitAPI(HANDLE *, ETarget, MicDeviceOnSystem *, U32 *);\nU32 MICACCESS_API MicCloseAPI(HANDLE *);\nU32 MICACCESS_API MicInitAdapter(HANDLE *, MicDeviceOnSystem *);\nU32 MICACCESS_API MicGetPowerUsage(HANDLE, MicPwrUsage *);\n\nconst char *(*MicGetErrorStringPtr)(U32);\nU32 (*MicCloseAdapterPtr)(HANDLE);\nU32 (*MicInitAPIPtr)(HANDLE *, ETarget, MicDeviceOnSystem *, U32 *);\nU32 (*MicCloseAPIPtr)(HANDLE *);\nU32 (*MicInitAdapterPtr)(HANDLE *, MicDeviceOnSystem *);\nU32 (*MicGetPowerUsagePtr)(HANDLE, MicPwrUsage *);\nstatic host_micpower_native_event_entry_t *native_events_table = NULL;\n\nstruct powers {\n\t\tint total0;\n\t\tint total1;\n\t\tint\tinst;\n\t\tint imax;\n\t\tint pcie;\n\t\tint c2x3;\n\t\tint c2x4;\n\t\tint vccp;\n\t\tint vddg;\n\t\tint vddq;\n};\n\ntypedef union {\n\t\tstruct powers power;\n\t\tint array[EVENTS_PER_DEVICE]; \n} power_t;\n\nstatic power_t cached_values[MAX_DEVICES];\n\nstatic int \nloadFunctionPtrs()\n{\n\t/* Attempt to guess if we were statically linked to libc, if so bail */\n\tif ( _dl_non_dynamic_init != NULL ) {\n\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"The host_micpower component does not support statically linking of libc.\", PAPI_MAX_STR_LEN);\n\t\treturn PAPI_ENOSUPP;\n\t}\n\n\t  /* Need to link in the cuda libraries, if not found disable the component */\n\tscif_access = dlopen(\"libscif.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (NULL == scif_access)\n    {\n        snprintf(_host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Problem loading the SCIF library: %s\\n\", dlerror());\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n        return ( PAPI_ENOSUPP );\n    }\n\n    mic_access = dlopen(\"libMicAccessSDK.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (NULL == mic_access)\n    {\n        snprintf(_host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Problem loading libMicAccessSDK.so: %s\\n\", dlerror());\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n        return ( PAPI_ENOSUPP );\n    }\n\n\tMicGetErrorStringPtr = dlsym(mic_access, \"MicGetErrorString\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicGetErrorString not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tMicCloseAdapterPtr = dlsym(mic_access, \"MicCloseAdapter\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicCloseAdapter not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tMicInitAPIPtr = dlsym(mic_access, \"MicInitAPI\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicInitAPI not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tMicCloseAPIPtr = dlsym(mic_access, \"MicCloseAPI\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicCloseAPI not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tMicInitAdapterPtr = dlsym(mic_access, \"MicInitAdapter\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicInitAdapter not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\tMicGetPowerUsagePtr = dlsym(mic_access, \"MicGetPowerUsage\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicGetPowerUsage not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\treturn 0;\n}\n\n\n/* ###############################################\n * \t\t\tComponent Interface code \n * ############################################### */\n\n\nint \n_host_micpower_init_component( int cidx ) \n{\n\tU32 ret = MIC_ACCESS_API_ERROR_UNKNOWN;\n\tU32 adapterNum = 0;\n\tU32 throwaway = 1;\n\n\t_host_micpower_vector.cmp_info.CmpIdx = cidx;\n\n\tif ( loadFunctionPtrs() ) {\n\t\tgoto disable_me;\n\t}\n\n\tmemset( lastupdate, 0x0, sizeof(lastupdate));\n\tmemset( cached_values, 0x0, sizeof(struct powers)*MAX_DEVICES );\n\tret = MicInitAPIPtr( &accessHandle, eTARGET_SCIF_DRIVER, adapters, &nAdapters );\n\tif ( MIC_ACCESS_API_SUCCESS != ret ) {\n\t\tsnprintf( _host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Failed to init: %s\", MicGetErrorStringPtr(ret));\n\t\tMicCloseAPIPtr(&accessHandle);\n\t\tgoto disable_me;\n\t}\n\t/* Sanity check on array size */\n\tif ( nAdapters >= MAX_DEVICES ) {\n\t\tsnprintf(_host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Too many MIC cards [%d] found, bailing.\", nAdapters);\n\t\tMicCloseAPIPtr(&accessHandle);\n\t\tgoto disable_me;\n\t}\n\n/* XXX: This code initializes a token for each adapter, in testing this appeared to be required/\n *\tOne has to call MicInitAdapter() before calling into that adapter's entries */\n\tfor (adapterNum=0; adapterNum < nAdapters; adapterNum++) {\n\t\t\tret = MicInitAPIPtr( &handles[adapterNum], eTARGET_SCIF_DRIVER, adapters, &throwaway );\n\t\t\tthrowaway = 1;\n\t\t\tif (MIC_ACCESS_API_SUCCESS != ret) {\n\t\t\t\t\tfprintf(stderr, \"%d:MicInitAPI carps: %s\\n\", __LINE__, MicGetErrorStringPtr(ret));\n\t\t\t\t\tnAdapters = adapterNum;\n\t\t\t\t\tfor (adapterNum=0; adapterNum < nAdapters; adapterNum++)\n\t\t\t\t\t\t\tMicCloseAdapterPtr( handles[adapterNum] );\n\t\t\t\t\tMicCloseAPIPtr( &accessHandle );\n\t\t\t\t\tsnprintf(_host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN,\n\t\t\t\t\t\t\"Failed to initialize card %d's interface.\", nAdapters);\n\t\t\t\t\tgoto disable_me;\n\t\t\t}\n\t\t\tret = MicInitAdapterPtr(&handles[adapterNum], &adapters[adapterNum]);\n\t\t\tif (MIC_ACCESS_API_SUCCESS != ret) {\n\t\t\t\t\tfprintf(stderr, \"%d:MicInitAdapter carps: %s\\n\", __LINE__, MicGetErrorStringPtr(ret));\n\t\t\t\t\tnAdapters = adapterNum;\n\t\t\t\t\tfor (adapterNum=0; adapterNum < nAdapters; adapterNum++)\n\t\t\t\t\t\t\tMicCloseAdapterPtr( handles[adapterNum] );\n\t\t\t\t\tMicCloseAPIPtr( &accessHandle );\n\t\t\t\t\tsnprintf(_host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN,\n\t\t\t\t\t\t\"Failed to initialize card %d's interface.\", nAdapters);\n\t\t\t\t\tgoto disable_me;\n\t\t\t}\n\t}\n\n\tnative_events_table = ( host_micpower_native_event_entry_t*)papi_malloc( nAdapters * EVENTS_PER_DEVICE * sizeof(host_micpower_native_event_entry_t));\n\tif ( NULL == native_events_table ) {\n\t\treturn PAPI_ENOMEM;\n\t}\n\tfor (adapterNum=0; adapterNum < nAdapters; adapterNum++) {\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE].name, PAPI_MAX_STR_LEN, \"mic%d:tot0\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE].description, PAPI_MAX_STR_LEN, \"Total power utilization, Averaged over Time Window 0 (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE].resources.selector = adapterNum*EVENTS_PER_DEVICE + 1;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 1].name, PAPI_MAX_STR_LEN, \"mic%d:tot1\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 1].description, PAPI_MAX_STR_LEN, \"Total power utilization, Averaged over Time Window 1 (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 1].resources.selector = adapterNum*EVENTS_PER_DEVICE + 2;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 1].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 2].name, PAPI_MAX_STR_LEN, \"mic%d:pcie\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 2].description, PAPI_MAX_STR_LEN, \"PCI-E connector power (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 2].resources.selector = adapterNum*EVENTS_PER_DEVICE + 3;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 2].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 3].name, PAPI_MAX_STR_LEN, \"mic%d:inst\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 3].description, PAPI_MAX_STR_LEN, \"Instantaneous power (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 3].resources.selector = adapterNum*EVENTS_PER_DEVICE + 4;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 3].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 4].name, PAPI_MAX_STR_LEN, \"mic%d:imax\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 4].description, PAPI_MAX_STR_LEN, \"Max instantaneous power (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 4].resources.selector = adapterNum*EVENTS_PER_DEVICE + 5;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 4].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 5].name, PAPI_MAX_STR_LEN, \"mic%d:c2x3\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 5].description, PAPI_MAX_STR_LEN, \"2x3 connector power (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 5].resources.selector = adapterNum*EVENTS_PER_DEVICE + 6;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 5].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 6].name, PAPI_MAX_STR_LEN, \"mic%d:c2x4\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 6].description, PAPI_MAX_STR_LEN, \"2x4 connector power (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 6].resources.selector = adapterNum*EVENTS_PER_DEVICE + 7;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 6].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 7].name, PAPI_MAX_STR_LEN, \"mic%d:vccp\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 7].description, PAPI_MAX_STR_LEN, \"Core rail (uVolts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 7].resources.selector = adapterNum*EVENTS_PER_DEVICE + 8;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 7].units, PAPI_MIN_STR_LEN, \"uV\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 8].name, PAPI_MAX_STR_LEN, \"mic%d:vddg\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 8].description, PAPI_MAX_STR_LEN, \"Uncore rail (uVolts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 8].resources.selector = adapterNum*EVENTS_PER_DEVICE + 9;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 8].units, PAPI_MIN_STR_LEN, \"uV\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 9].name, PAPI_MAX_STR_LEN, \"mic%d:vddq\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 9].description, PAPI_MAX_STR_LEN, \"Memory subsystem rail (uVolts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 9].resources.selector = adapterNum*EVENTS_PER_DEVICE + 10;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 9].units, PAPI_MIN_STR_LEN, \"uV\");\n\t}\n\n\t_host_micpower_vector.cmp_info.num_cntrs = EVENTS_PER_DEVICE*nAdapters;\n\t_host_micpower_vector.cmp_info.num_mpx_cntrs = EVENTS_PER_DEVICE*nAdapters;\n\n\t_host_micpower_vector.cmp_info.num_native_events = EVENTS_PER_DEVICE*nAdapters;\n\n\treturn PAPI_OK;\n\ndisable_me:\n\t_host_micpower_vector.cmp_info.num_cntrs = 0;\n\t_host_micpower_vector.cmp_info.num_mpx_cntrs = 0;\n\t_host_micpower_vector.cmp_info.num_native_events = 0;\n\t_host_micpower_vector.cmp_info.disabled = 1;\n\n\tnAdapters = 0;\n\treturn PAPI_ENOSUPP;\n}\n\nint _host_micpower_init_thread( hwd_context_t *ctx) {\n\t(void)ctx;\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_shutdown_component( void ) {\n\tU32 i = 0;\n\tfor( i=0; i<nAdapters; i++) {\n\t\tMicCloseAdapterPtr( handles[i] );\n\t}\n\n\tpapi_free(native_events_table);\n\treturn PAPI_OK;\n}\n\t\nint\n_host_micpower_shutdown_thread( hwd_context_t *ctx ) {\n    (void) ctx;\n\treturn PAPI_OK;\n}\n\nint _host_micpower_init_control_state ( hwd_control_state_t *ctl ) {\n\thost_micpower_control_state_t *state = (host_micpower_control_state_t*) ctl;\n\tmemset( state, 0, sizeof(host_micpower_control_state_t));\n\n\treturn PAPI_OK;\n}\n\nint _host_micpower_update_control_state(hwd_control_state_t *ctl, \n\t\t\t\t\t\t\t\t\t\tNativeInfo_t *info, \n\t\t\t\t\t\t\t\t\t\tint count,\n\t\t\t\t\t\t\t\t\t\thwd_context_t* ctx ) {\n\n\t(void) ctx;\n\tint i, index;\n\t\n\thost_micpower_control_state_t *state = (host_micpower_control_state_t*)ctl;\n\n\tfor (i=0; i<MAX_DEVICES*EVENTS_PER_DEVICE; i++)\n\t\tstate->resident[i] = 0;\n\n\tfor (i=0; i < count; i++) {\n\t\tindex = info[i].ni_event&PAPI_NATIVE_AND_MASK;\n\t\tinfo[i].ni_position=native_events_table[index].resources.selector-1;\n\t\tstate->resident[index] = 1;\n\t}\n\tstate->num_events = count;\n\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_start( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\t(void) ctx;\n\t(void) ctl;\n\treturn PAPI_OK;\n}\n\nstatic int \nread_power( struct powers *pwr, int which_one ) \n{\n\tMicPwrUsage power;\n\tU32 ret = MIC_ACCESS_API_ERROR_UNKNOWN;\n\n\tif ( which_one < 0 || which_one > (int)nAdapters )\n\t\treturn PAPI_ENOEVNT;\n\t\n\n\tret = MicGetPowerUsagePtr(handles[which_one], &power);\n\tif (MIC_ACCESS_API_SUCCESS != ret) {\n\t\t\tfprintf(stderr,\"Oops MicGetPowerUsage failed: %s\\n\", \n\t\t\t\t\t\t\tMicGetErrorStringPtr(ret));\n\t\t\treturn PAPI_ECMP;\n\t}\n\n\tpwr->total0 = power.total0.prr;\n\tpwr->total1 = power.total1.prr;\n\tpwr->inst = power.inst.prr;\n\tpwr->imax = power.imax.prr;\n\tpwr->pcie = power.pcie.prr;\n\tpwr->c2x3 = power.c2x3.prr;\n\tpwr->c2x4 = power.c2x4.prr;\n\tpwr->vccp = power.vccp.pwr;\n\tpwr->vddg = power.vddg.pwr;\n\tpwr->vddq = power.vddq.pwr;\n\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_read( hwd_context_t *ctx, hwd_control_state_t *ctl, \n\t\t\t\t\t long long **events, int flags) \n{\n\t(void)flags;\n\t(void)events;\n\t(void)ctx;\n\tunsigned int i,j;\n\tint needs_update = 0;\n\thost_micpower_control_state_t* control = (host_micpower_control_state_t*)ctl;\n\tlong long now = PAPI_get_real_usec();\n\n\tfor( i=0; i<nAdapters; i++) {\n\t\t\tneeds_update = 0;\n\t\t\tfor (j=0; j<EVENTS_PER_DEVICE; j++) {\n\t\t\t\tif ( control->resident[EVENTS_PER_DEVICE*i+j]) {\n\t\t\t\t\t\tneeds_update = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( needs_update ) {\n\t\t\t\t\t/* Do the global update */\n\t\t\t\t\tif ( now >= lastupdate[i] + UPDATEFREQ) {\n\t\t\t\t\t\t\tread_power( &cached_values[i].power, i );\n\t\t\t\t\t\t\tlastupdate[i] = now;\n\t\t\t\t\t}\n\t\t\t\t\t/* update from cached values */\n\t\t\t\t\tif ( control->lastupdate[i] < lastupdate[i]) {\n\t\t\t\t\t\t\tcontrol->lastupdate[i] = lastupdate[i];\n\t\t\t\t\t}\n\t\t\t\t\tfor (j=0; j<EVENTS_PER_DEVICE; j++) {\n\t\t\t\t\t\tif ( control->resident[EVENTS_PER_DEVICE*i+j] ) {\n\t\t\t\t\t\t\tcontrol->counts[EVENTS_PER_DEVICE*i+j] = (long long)cached_values[i].array[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t}\n\n\t*events = control->counts;\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_stop( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\t(void)ctx;\n\tint needs_update = 0;\n\tunsigned int i,j;\n\thost_micpower_control_state_t* control = (host_micpower_control_state_t*)ctl;\n\tlong long now = PAPI_get_real_usec();\n\n\tfor( i=0; i<nAdapters; i++) {\n\t\t\tneeds_update = 0;\n\t\t\tfor (j=0; j<EVENTS_PER_DEVICE; j++) {\n\t\t\t\tif ( control->resident[EVENTS_PER_DEVICE*i+j]) {\n\t\t\t\t\t\tneeds_update = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( needs_update ) {\n\t\t\t\t\t/* Do the global update */\n\t\t\t\t\tif ( now >= lastupdate[i] + UPDATEFREQ) {\n\t\t\t\t\t\t\tread_power( &cached_values[i].power, i );\n\t\t\t\t\t\t\tlastupdate[i] = now;\n\t\t\t\t\t}\n\t\t\t\t\t/* update from cached values */\n\t\t\t\t\tif ( control->lastupdate[i] < lastupdate[i]) {\n\t\t\t\t\t\t\tcontrol->lastupdate[i] = lastupdate[i];\n\t\t\t\t\t}\n\t\t\t\t\tfor (j=0; j<EVENTS_PER_DEVICE; j++) {\n\t\t\t\t\t\tif ( control->resident[EVENTS_PER_DEVICE*i+j] ) {\n\t\t\t\t\t\t\tcontrol->counts[EVENTS_PER_DEVICE*i+j] = (long long)cached_values[i].array[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t}\n\treturn PAPI_OK;\n\n}\n\nint _host_micpower_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n\tint index;\n\tswitch (modifier) {\n\t\tcase PAPI_ENUM_FIRST:\n\t\t\tif (0 == _host_micpower_vector.cmp_info.num_cntrs)\n\t\t\t\treturn PAPI_ENOEVNT;\n\t\t\t*EventCode = 0;\n\t\t\treturn PAPI_OK;\n\t\tcase PAPI_ENUM_EVENTS:\n\t\t\tindex = *EventCode;\n\t\t\tif ( index < _host_micpower_vector.cmp_info.num_cntrs - 1) {\n\t\t\t\t*EventCode = *EventCode + 1;\n\t\t\t\treturn PAPI_OK;\n\t\t\t} else {\n\t\t\t\treturn PAPI_ENOEVNT;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn PAPI_EINVAL;\n\t}\n\treturn PAPI_EINVAL;\n}\n\nint\n_host_micpower_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n\tunsigned int code = EventCode & PAPI_NATIVE_AND_MASK;\n\tif ( code < _host_micpower_vector.cmp_info.num_cntrs ) {\n\t\tstrncpy( name, native_events_table[code].name, len);\n\t\treturn PAPI_OK;\n\t}\n\n\treturn PAPI_ENOEVNT;\n}\n\nint\n_host_micpower_ntv_code_to_descr( unsigned int EventCode, char *name, int len )\n{\n\tunsigned int code = EventCode & PAPI_NATIVE_AND_MASK;\n\tif ( code < _host_micpower_vector.cmp_info.num_cntrs ) {\n\t\tstrncpy( name, native_events_table[code].description, len );\n\t\treturn PAPI_OK;\n\t}\n\n\treturn PAPI_ENOEVNT;\n}\n\nint\n_host_micpower_ntv_code_to_info( unsigned int EventCode, PAPI_event_info_t *info)\n{\n\tunsigned int code = EventCode & PAPI_NATIVE_AND_MASK;\n\tif ( code >= _host_micpower_vector.cmp_info.num_cntrs)\n\t\treturn PAPI_ENOEVNT;\n\tstrncpy( info->symbol, native_events_table[code].name, sizeof(info->symbol) );\n\tstrncpy( info->long_descr, native_events_table[code].description, sizeof(info->long_descr) );\n\tstrncpy( info->units, native_events_table[code].units, sizeof(info->units) );\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_ctl( hwd_context_t* ctx, int code, _papi_int_option_t *option)\n{\n\t(void)ctx;\n\t(void)code;\n\t(void)option;\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_set_domain( hwd_control_state_t* ctl, int domain)\n{\n\t(void)ctl;\n\tif ( PAPI_DOM_ALL != domain )\n\t    return PAPI_EINVAL;\n\treturn PAPI_OK;\n}\n\npapi_vector_t _host_micpower_vector = {\n\t.cmp_info = {\n\t\t.name = \"host_micpower\", \n\t\t.short_name = \"host_micpower\", \n\t\t.description = \"A host-side component to read power usage on MIC guest cards.\",\n\t\t.version = \"0.1\",\n\t\t.support_version = \"n/a\",\n\t\t.kernel_version = \"n/a\",\n\t\t.num_cntrs = 0,\n\t\t.num_mpx_cntrs = 0,\n\t\t.default_domain \t\t\t= PAPI_DOM_ALL,\n\t\t.available_domains \t\t\t= PAPI_DOM_ALL,\n\t\t.default_granularity \t\t= PAPI_GRN_SYS,\n\t\t.available_granularities \t= PAPI_GRN_SYS,\n\t\t.hardware_intr_sig \t\t\t= PAPI_INT_SIGNAL,\n\t}, \n\n\t.size  = {\n\t\t.context \t\t= sizeof(host_micpower_context_t), \n\t\t.control_state\t= sizeof(host_micpower_control_state_t),\n\t\t.reg_value\t\t= sizeof(host_micpower_register_t),\n\t\t.reg_alloc\t\t= sizeof(host_micpower_reg_alloc_t),\n\t},\n\n\t.start\t\t\t\t\t= _host_micpower_start,\n\t.stop\t\t\t\t\t= _host_micpower_start,\n\t.read\t\t\t\t\t= _host_micpower_read, \n\t.reset\t\t\t\t\t= NULL,\n\t.write\t\t\t\t\t= NULL,\n\t.init_component\t\t\t= _host_micpower_init_component,\n\t.init_thread\t\t\t= _host_micpower_init_thread,\n\t.init_control_state\t\t= _host_micpower_init_control_state,\n\t.update_control_state\t= _host_micpower_update_control_state,\n\t.ctl\t\t\t\t\t= _host_micpower_ctl, \n\t.shutdown_thread\t\t= _host_micpower_shutdown_thread,\n\t.shutdown_component\t\t= _host_micpower_shutdown_component,\n\t.set_domain\t\t\t\t= _host_micpower_set_domain,\n\n\t.ntv_enum_events\t\t= _host_micpower_ntv_enum_events, \n\t.ntv_code_to_name\t\t= _host_micpower_ntv_code_to_name,\n\t.ntv_code_to_descr\t\t= _host_micpower_ntv_code_to_descr,\n\t.ntv_code_to_info\t\t= _host_micpower_ntv_code_to_info,\n\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/components/cuda/linux-cuda.c": "/****************************/\n/* THIS IS OPEN SOURE CODE */\n/****************************/\n\n/**\n * @file    linux-cuda.c\n * @author  Asim YarKhan yarkhan@icl.utk.edu (updated in 2015 for multiple CUDA contexts/devices)\n * @author  Heike Jagode (in collaboration with Robert Dietrich, TU Dresden) jagode@eecs.utk.edu\n *\n * @ingroup papi_components\n *\n * @brief This implements a PAPI component that enables PAPI-C to\n *  access hardware monitoring counters for NVIDIA CUDA GPU devices\n *  through the CUPTI library.\n */\n\n#include <dlfcn.h>\n#include <cupti.h>\n#include <cuda_runtime_api.h>\n\n#include \"papi.h\"\n#include \"papi_memory.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n\n/* this number assumes that there will never be more events than indicated */\n#define PAPICUDA_MAX_COUNTERS 512\n\n/* Contains device list, pointer to device desciption, and the list of available events */\ntypedef struct papicuda_context {\n    int deviceCount;\n    struct papicuda_device_desc *deviceArray;\n    uint32_t availEventSize;\n    CUpti_EventID* availEventIDArray;\n    int* availEventDeviceNum;\n    struct papicuda_name_desc* availEventDesc;\n} papicuda_context_t;\n\n/* Store the name and description for an event */\ntypedef struct papicuda_name_desc  {\n    char name[PAPI_MAX_STR_LEN];\n    char description[PAPI_2MAX_STR_LEN];\n} papicuda_name_desc_t;\n\n/* For a device, store device description */\ntypedef struct papicuda_device_desc {\n    CUdevice cuDev;             /* CUDA device */\n    unsigned int deviceNum;\n    char deviceName[PAPI_MIN_STR_LEN];\n    uint32_t maxDomains;        /* number of domains per device */\n    CUpti_EventDomainID *domainIDArray; /* Array[maxDomains] of domain IDs */\n    uint32_t *domainIDNumEvents; /* Array[maxDomains] of num of events in that domain */\n} papicuda_device_desc_t;\n\n/* Control structure tracks array of active contexts, records active events and their values */\ntypedef struct papicuda_control {\n    int countOfActiveCUContexts;\n    struct papicuda_active_cucontext_s *arrayOfActiveCUContexts[PAPICUDA_MAX_COUNTERS];\n    int activeEventCount;\n    int activeEventIndex[PAPICUDA_MAX_COUNTERS];\n    int activeEventContextIdx[PAPICUDA_MAX_COUNTERS];\n    long long activeEventValues[PAPICUDA_MAX_COUNTERS];\n} papicuda_control_t;\n\n/* For each active context, which CUDA events are being measured, context eventgroups containing events */\ntypedef struct papicuda_active_cucontext_s {\n    CUcontext context;\n    int deviceNum;\n    int numEventGroups;\n    CUpti_EventGroup eventGroup[PAPICUDA_MAX_COUNTERS];\n} papicuda_active_cucontext_t;\n\n// file handles used to access cuda libraries with dlopen\nstatic void *dl1 = NULL;\nstatic void *dl2 = NULL;\nstatic void *dl3 = NULL;\n\n/* The PAPI side (external) variable as a global */\npapi_vector_t _cuda_vector;\n\n/* Global variable for hardware description, event and metric lists */\nstatic papicuda_context_t *global_papicuda_context = NULL;\n\n/* This global variable points to the head of the control state list */\nstatic papicuda_control_t *global_papicuda_control = NULL;\n\n/* Macros for error checking... each arg is only referenced/evaluated once */\n#define CHECK_CU_ERROR(err, cufunc)                                     \\\n    if( (err) != CUDA_SUCCESS ) { PAPIERROR( \"CUDA Driver API function failed '%s'\", cufunc ); return -1; }\n\n#define CHECK_CUPTI_ERROR(err, cuptifunc)                               \\\n    if( (err) != CUPTI_SUCCESS ) { PAPIERROR( \"CUPTI API function failed '%s'\", cuptifunc ); return -1; }\n\n#define CHECK_PRINT_EVAL( err, str, eval )      \\\n    if( (err) ) { PAPIERROR( \"%s\", str ); eval; }\n\n/********  CHANGE PROTOTYPES TO DECLARE CUDA LIBRARY SYMBOLS AS WEAK  **********\n *  This is done so that a version of PAPI built with the cuda component can   *\n *  be installed on a system which does not have the cuda libraries installed. *\n *                                                                             *\n *  If this is done without these prototypes, then all papi services on the    *\n *  system without the cuda libraries installed will fail.  The PAPI libraries *\n *  contain references to the cuda libraries which are not installed.  The     *\n *  load of PAPI commands fails because the cuda library references can not be *\n *  resolved.                                                                  *\n *                                                                             *\n *  This also defines pointers to the cuda library functions that we call.     *\n *  These function pointers will be resolved with dlopen/dlsym calls at        *\n *  component initialization time.  The component then calls the cuda library  *\n *  functions through these function pointers.                                 *\n *******************************************************************************/\nvoid ( *_dl_non_dynamic_init )( void ) __attribute__( ( weak ) );\n#undef CUDAAPI\n#define CUDAAPI __attribute__((weak))\nCUresult CUDAAPI cuCtxGetCurrent( CUcontext * );\nCUresult CUDAAPI cuDeviceGet( CUdevice *, int );\nCUresult CUDAAPI cuDeviceGetCount( int * );\nCUresult CUDAAPI cuDeviceGetName( char *, int, CUdevice );\nCUresult CUDAAPI cuDeviceGetName( char *, int, CUdevice );\nCUresult CUDAAPI cuInit( unsigned int );\nCUresult CUDAAPI cuCtxPopCurrent( CUcontext * pctx );\nCUresult CUDAAPI cuCtxPushCurrent( CUcontext pctx );\n\nCUresult( *cuCtxCreatePtr )( CUcontext * pctx, unsigned int flags, CUdevice dev );\nCUresult( *cuCtxDestroyPtr )( CUcontext );\nCUresult( *cuCtxGetCurrentPtr )( CUcontext * );\nCUresult( *cuDeviceGetPtr )( CUdevice *, int );\nCUresult( *cuDeviceGetCountPtr )( int * );\nCUresult( *cuDeviceGetNamePtr )( char *, int, CUdevice );\nCUresult( *cuInitPtr )( unsigned int );\nCUresult( *cuCtxPopCurrentPtr )( CUcontext * pctx );\nCUresult( *cuCtxPushCurrentPtr )( CUcontext pctx );\n\n#undef CUDARTAPI\n#define CUDARTAPI __attribute__((weak))\ncudaError_t CUDARTAPI cudaGetDevice( int * );\ncudaError_t CUDARTAPI cudaSetDevice( int );\ncudaError_t CUDARTAPI cudaFree( void * );\n\ncudaError_t ( *cudaGetDevicePtr )( int * );\ncudaError_t ( *cudaSetDevicePtr )( int );\ncudaError_t (*cudaFreePtr)(void *);\n\n#undef CUPTIAPI\n#define CUPTIAPI __attribute__((weak))\nCUptiResult CUPTIAPI cuptiDeviceEnumEventDomains( CUdevice, size_t *, CUpti_EventDomainID * );\nCUptiResult CUPTIAPI cuptiDeviceGetNumEventDomains( CUdevice, uint32_t * );\nCUptiResult CUPTIAPI cuptiEventDomainEnumEvents( CUpti_EventDomainID, size_t *, CUpti_EventID * );\nCUptiResult CUPTIAPI cuptiEventDomainGetNumEvents( CUpti_EventDomainID, uint32_t * );\nCUptiResult CUPTIAPI cuptiEventDomainGetAttribute ( CUpti_EventDomainID eventDomain, CUpti_EventDomainAttribute attrib, size_t* valueSize, void* value );\nCUptiResult CUPTIAPI cuptiEventGroupAddEvent( CUpti_EventGroup, CUpti_EventID );\nCUptiResult CUPTIAPI cuptiEventGroupCreate( CUcontext, CUpti_EventGroup *, uint32_t );\nCUptiResult CUPTIAPI cuptiEventGroupDestroy( CUpti_EventGroup );\nCUptiResult CUPTIAPI cuptiEventGroupDisable( CUpti_EventGroup );\nCUptiResult CUPTIAPI cuptiEventGroupEnable( CUpti_EventGroup );\nCUptiResult CUPTIAPI cuptiEventGroupReadAllEvents( CUpti_EventGroup, CUpti_ReadEventFlags, size_t *, uint64_t *, size_t *, CUpti_EventID *, size_t * );\nCUptiResult CUPTIAPI cuptiEventGroupResetAllEvents( CUpti_EventGroup );\nCUptiResult CUPTIAPI cuptiEventGetAttribute( CUpti_EventID, CUpti_EventAttribute, size_t *, void * );\n\nCUptiResult( *cuptiDeviceEnumEventDomainsPtr )( CUdevice, size_t *, CUpti_EventDomainID * );\nCUptiResult( *cuptiDeviceGetNumEventDomainsPtr )( CUdevice, uint32_t * );\nCUptiResult( *cuptiEventDomainEnumEventsPtr )( CUpti_EventDomainID, size_t *, CUpti_EventID * );\nCUptiResult( *cuptiEventDomainGetNumEventsPtr )( CUpti_EventDomainID, uint32_t * );\nCUptiResult( *cuptiEventDomainGetAttributePtr ) ( CUpti_EventDomainID eventDomain, CUpti_EventDomainAttribute attrib, size_t* valueSize, void* value );\nCUptiResult( *cuptiEventGroupAddEventPtr )( CUpti_EventGroup, CUpti_EventID );\nCUptiResult( *cuptiEventGroupCreatePtr )( CUcontext, CUpti_EventGroup *, uint32_t );\nCUptiResult( *cuptiEventGroupDestroyPtr )( CUpti_EventGroup );\nCUptiResult( *cuptiEventGroupDisablePtr )( CUpti_EventGroup );\nCUptiResult( *cuptiEventGroupEnablePtr )( CUpti_EventGroup );\nCUptiResult( *cuptiEventGroupReadAllEventsPtr )( CUpti_EventGroup, CUpti_ReadEventFlags, size_t *, uint64_t *, size_t *, CUpti_EventID *, size_t * );\nCUptiResult( *cuptiEventGroupResetAllEventsPtr )( CUpti_EventGroup );\nCUptiResult( *cuptiEventGetAttributePtr )( CUpti_EventID, CUpti_EventAttribute, size_t *, void * );\n\n/******************************************************************************\n ********  BEGIN FUNCTIONS USED INTERNALLY SPECIFIC TO THIS COMPONENT *********\n *****************************************************************************/\n\n/*\n * Link the necessary CUDA libraries to use the cuda component.  If any of them can not be found, then\n * the CUDA component will just be disabled.  This is done at runtime so that a version of PAPI built\n * with the CUDA component can be installed and used on systems which have the CUDA libraries installed\n * and on systems where these libraries are not installed.\n */\n#define CHECK_DL_STATUS( err, str ) if( err ) { strncpy( _cuda_vector.cmp_info.disabled_reason, str, PAPI_MAX_STR_LEN ); return ( PAPI_ENOSUPP ); }\n\nstatic int papicuda_linkCudaLibraries()\n{\n    /* Attempt to guess if we were statically linked to libc, if so bail */\n    if( _dl_non_dynamic_init != NULL ) {\n        strncpy( _cuda_vector.cmp_info.disabled_reason, \"The cuda component does not support statically linking to libc.\", PAPI_MAX_STR_LEN );\n        return PAPI_ENOSUPP;\n    }\n    /* Need to link in the cuda libraries, if not found disable the component */\n    dl1 = dlopen( \"libcuda.so\", RTLD_NOW | RTLD_GLOBAL );\n    CHECK_DL_STATUS( !dl1 , \"CUDA library libcuda.so not found.\" );\n    cuCtxGetCurrentPtr = dlsym( dl1, \"cuCtxGetCurrent\" );\n    CHECK_DL_STATUS( dlerror()!=NULL , \"CUDA function cuCtxGetCurrent not found.\" );\n    cuDeviceGetPtr = dlsym( dl1, \"cuDeviceGet\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUDA function cuDeviceGet not found.\" );\n    cuDeviceGetCountPtr = dlsym( dl1, \"cuDeviceGetCount\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUDA function cuDeviceGetCount not found.\" );\n    cuDeviceGetNamePtr = dlsym( dl1, \"cuDeviceGetName\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUDA function cuDeviceGetName not found.\" );\n    cuInitPtr = dlsym( dl1, \"cuInit\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUDA function cuInit not found.\" );\n    cuCtxPopCurrentPtr = dlsym( dl1, \"cuCtxPopCurrent\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUDA function cuCtxPopCurrent not found.\" );\n    cuCtxPushCurrentPtr = dlsym( dl1, \"cuCtxPushCurrent\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUDA function cuCtxPushCurrent not found.\" );\n\n    dl2 = dlopen( \"libcudart.so\", RTLD_NOW | RTLD_GLOBAL );\n    CHECK_DL_STATUS( !dl2, \"CUDA runtime library libcudart.so not found.\" );\n    cudaGetDevicePtr = dlsym( dl2, \"cudaGetDevice\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUDART function cudaGetDevice not found.\" );\n    cudaSetDevicePtr = dlsym( dl2, \"cudaSetDevice\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUDART function cudaSetDevice not found.\" );\n    cudaFreePtr = dlsym( dl2, \"cudaFree\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUDART function cudaFree not found.\" );\n\n    dl3 = dlopen( \"libcupti.so\", RTLD_NOW | RTLD_GLOBAL );\n    CHECK_DL_STATUS( !dl3, \"CUDA runtime library libcupti.so not found.\" );\n    cuptiDeviceEnumEventDomainsPtr = dlsym( dl3, \"cuptiDeviceEnumEventDomains\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUPTI function cuptiDeviceEnumEventDomains not found.\" );\n    cuptiDeviceGetNumEventDomainsPtr = dlsym( dl3, \"cuptiDeviceGetNumEventDomains\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUPTI function cuptiDeviceGetNumEventDomains not found.\" );\n    cuptiEventDomainEnumEventsPtr = dlsym( dl3, \"cuptiEventDomainEnumEvents\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUPTI function cuptiEventDomainEnumEvents not found.\" );\n    cuptiEventDomainGetNumEventsPtr = dlsym( dl3, \"cuptiEventDomainGetNumEvents\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUPTI function cuptiEventDomainGetNumEvents not found.\" );\n    cuptiEventGetAttributePtr = dlsym( dl3, \"cuptiEventGetAttribute\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUPTI function cuptiEventGetAttribute not found.\" );\n    cuptiEventGroupAddEventPtr = dlsym( dl3, \"cuptiEventGroupAddEvent\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUPTI function cuptiEventGroupAddEvent not found.\" );\n    cuptiEventGroupCreatePtr = dlsym( dl3, \"cuptiEventGroupCreate\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUPTI function cuptiEventGroupCreate not found.\" );\n    cuptiEventGroupDestroyPtr = dlsym( dl3, \"cuptiEventGroupDestroy\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUPTI function cuptiEventGroupDestroy not found.\" );\n    cuptiEventGroupDisablePtr = dlsym( dl3, \"cuptiEventGroupDisable\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUPTI function cuptiEventGroupDisable not found.\" );\n    cuptiEventGroupEnablePtr = dlsym( dl3, \"cuptiEventGroupEnable\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUPTI function cuptiEventGroupEnable not found.\" );\n    cuptiEventGroupReadAllEventsPtr = dlsym( dl3, \"cuptiEventGroupReadAllEvents\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUPTI function cuptiEventGroupReadAllEvents not found.\" );\n    cuptiEventGroupResetAllEventsPtr = dlsym( dl3, \"cuptiEventGroupResetAllEvents\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"CUPTI function cuptiEventGroupResetAllEvents not found.\" );\n    return ( PAPI_OK );\n}\n\n/* Called during component initialization to get a list of all available events */\nstatic int papicuda_list_all_events( papicuda_context_t *gctxt )\n{\n    SUBDBG( \"Entering\\n\" );\n    CUptiResult cuptiErr;\n    CUresult cuErr;\n    unsigned int deviceNum;\n    uint32_t domainNum, eventNum;\n    papicuda_device_desc_t *mydevice;\n    char tmpStr[PAPI_MIN_STR_LEN];\n    tmpStr[PAPI_MIN_STR_LEN-1]='\\0';\n    size_t tmpSizeBytes;\n    int ii;\n\n    /* How many gpgpu devices do we have? */\n    cuErr = ( *cuDeviceGetCountPtr )( &gctxt->deviceCount );\n    if ( cuErr==CUDA_ERROR_NOT_INITIALIZED ) {\n        /* If CUDA not initilaized, initialized CUDA and retry the device list */\n        /* This is required for some of the PAPI tools, that do not call the init functions */\n        if ( (( *cuInitPtr )( 0 )) != CUDA_SUCCESS ) {\n            strncpy( _cuda_vector.cmp_info.disabled_reason, \"CUDA cannot be found and initialized (cuInit failed).\", PAPI_MAX_STR_LEN );\n            return PAPI_ENOSUPP;\n        }\n        cuErr = ( *cuDeviceGetCountPtr )( &gctxt->deviceCount );\n    }\n    CHECK_CU_ERROR( cuErr, \"cuDeviceGetCount\" );\n    if ( gctxt->deviceCount==0 ) {\n        strncpy( _cuda_vector.cmp_info.disabled_reason, \"CUDA initialized but no CUDA devices found.\", PAPI_MAX_STR_LEN );\n        return PAPI_ENOSUPP;\n    }\n    SUBDBG( \"Found %d devices\\n\", gctxt->deviceCount );\n\n    /* allocate memory for device information */\n    gctxt->deviceArray = ( papicuda_device_desc_t * ) papi_calloc( gctxt->deviceCount, sizeof( papicuda_device_desc_t ) );\n    CHECK_PRINT_EVAL( !gctxt->deviceArray, \"ERROR CUDA: Could not allocate memory for CUDA device structure\", return( PAPI_ENOSUPP ) );\n\n    /* For each device, get domains and domain-events counts */\n    gctxt->availEventSize = 0;\n    for( deviceNum = 0; deviceNum < ( uint )gctxt->deviceCount; deviceNum++ ) {\n        mydevice = &gctxt->deviceArray[deviceNum];\n        /* Get device id for each device */\n        CHECK_CU_ERROR( ( *cuDeviceGetPtr )( &mydevice->cuDev, deviceNum ), \"cuDeviceGet\" );\n        /* Get device name */\n        CHECK_CU_ERROR( ( *cuDeviceGetNamePtr )( mydevice->deviceName, PAPI_MIN_STR_LEN-1, mydevice->cuDev ), \"cuDeviceGetName\" );\n        mydevice->deviceName[PAPI_MIN_STR_LEN-1]='\\0';\n        /* Get max num domains for each device */\n        CHECK_CUPTI_ERROR( ( *cuptiDeviceGetNumEventDomainsPtr )( mydevice->cuDev, &mydevice->maxDomains ), \"cuptiDeviceGetNumEventDomains\" );\n        /* Allocate space to hold domain IDs */\n        mydevice->domainIDArray = ( CUpti_EventDomainID * ) papi_calloc( mydevice->maxDomains, sizeof( CUpti_EventDomainID ) );\n        CHECK_PRINT_EVAL( !mydevice->domainIDArray, \"ERROR CUDA: Could not allocate memory for CUDA device domains\", return( PAPI_ENOMEM ) );\n        /* Put domain ids into allocated space */\n        size_t domainarraysize = mydevice->maxDomains * sizeof( CUpti_EventDomainID );\n        CHECK_CUPTI_ERROR( ( *cuptiDeviceEnumEventDomainsPtr )( mydevice->cuDev, &domainarraysize, mydevice->domainIDArray ), \"cuptiDeviceEnumEventDomains\" );\n        /* Allocate space to hold domain event counts  */\n        mydevice->domainIDNumEvents = ( uint32_t * ) papi_calloc( mydevice->maxDomains, sizeof( uint32_t ) );\n        CHECK_PRINT_EVAL( !mydevice->domainIDNumEvents, \"ERROR CUDA: Could not allocate memory for domain event counts\", return( PAPI_ENOMEM ) );\n        /* For each domain, get event counts in domainNumEvents[]  */\n        for ( domainNum=0; domainNum < mydevice->maxDomains; domainNum++ ) {\n            CUpti_EventDomainID domainID = mydevice->domainIDArray[domainNum];\n            /* Get num events in domain */\n            //SUBDBG( \"Device %d:%d calling cuptiEventDomainGetNumEventsPtr with domainID %d \\n\", deviceNum, mydevice->cuDev, domainID );\n            CHECK_CUPTI_ERROR(  ( *cuptiEventDomainGetNumEventsPtr ) ( domainID, &mydevice->domainIDNumEvents[domainNum] ), \"cuptiEventDomainGetNumEvents\" );\n            /* Keep track of overall number of events */\n            gctxt->availEventSize += mydevice->domainIDNumEvents[domainNum];\n        }\n    }\n\n    /* Allocate space for all events and descriptors */\n    gctxt->availEventIDArray = ( CUpti_EventID * ) papi_calloc( gctxt->availEventSize, sizeof( CUpti_EventID ) );\n    CHECK_PRINT_EVAL( !gctxt->availEventIDArray, \"ERROR CUDA: Could not allocate memory for events\", return( PAPI_ENOMEM ) );\n    gctxt->availEventDeviceNum = ( int * ) papi_calloc( gctxt->availEventSize, sizeof( int ) );\n    CHECK_PRINT_EVAL( !gctxt->availEventDeviceNum, \"ERROR CUDA: Could not allocate memory\", return( PAPI_ENOMEM ) );\n    gctxt->availEventDesc = ( papicuda_name_desc_t * ) papi_calloc( gctxt->availEventSize, sizeof( papicuda_name_desc_t ) );\n    CHECK_PRINT_EVAL( !gctxt->availEventDesc, \"ERROR CUDA: Could not allocate memory for events\", return( PAPI_ENOMEM ) );\n    /* Record the events and descriptions */\n    int idxEventArray = 0;\n    for( deviceNum = 0; deviceNum < ( uint )gctxt->deviceCount; deviceNum++ ) {\n        mydevice = &gctxt->deviceArray[deviceNum];\n        //SUBDBG( \"For device %d %d maxdomains %d \\n\", deviceNum, mydevice->cuDev, mydevice->maxDomains );\n        /* Get and store event IDs, names, descriptions into the large arrays allocated */\n        for ( domainNum=0; domainNum < mydevice->maxDomains; domainNum++ ) {\n            /* Get domain id */\n            CUpti_EventDomainID domainID = mydevice->domainIDArray[domainNum];\n            uint32_t domainNumEvents = mydevice->domainIDNumEvents[domainNum];\n            SUBDBG( \"For device %d domain %d %d numEvents %d\\n\", mydevice->cuDev, domainNum, domainID, domainNumEvents );\n            /* Allocate temp space for eventIDs for this domain */\n            CUpti_EventID *domainEventIDArray = ( CUpti_EventID * ) papi_calloc( domainNumEvents, sizeof( CUpti_EventID ) );\n            CHECK_PRINT_EVAL( !domainEventIDArray, \"ERROR CUDA: Could not allocate memory for events\", return( PAPI_ENOMEM ) );\n            /* Load the domain eventIDs in temp space */\n            size_t domainEventArraySize = domainNumEvents * sizeof( CUpti_EventID );\n            cuptiErr = ( *cuptiEventDomainEnumEventsPtr )  ( domainID, &domainEventArraySize, domainEventIDArray );\n            CHECK_CUPTI_ERROR( cuptiErr, \"cuptiEventDomainEnumEvents\" );\n            /* For each event, get and store name and description */\n            for ( eventNum=0; eventNum<domainNumEvents; eventNum++ ) {\n                /* Record the event IDs in native event array */\n                CUpti_EventID myeventID = domainEventIDArray[eventNum];\n                gctxt->availEventIDArray[idxEventArray] = myeventID;\n                gctxt->availEventDeviceNum[idxEventArray] = deviceNum;\n                /* Get event name */\n                tmpSizeBytes = PAPI_MIN_STR_LEN-1 * sizeof( char );\n                cuptiErr = ( *cuptiEventGetAttributePtr ) ( myeventID, CUPTI_EVENT_ATTR_NAME, &tmpSizeBytes, tmpStr ) ;\n                CHECK_CUPTI_ERROR( cuptiErr, \"cuptiEventGetAttribute\" );\n                /* Save a full path for the event, filling spaces with underscores */\n                //snprintf( gctxt->availEventDesc[idxEventArray].name, PAPI_MIN_STR_LEN, \"%s:%d:%s\", mydevice->deviceName, deviceNum, tmpStr );\n                snprintf( gctxt->availEventDesc[idxEventArray].name, PAPI_MIN_STR_LEN, \"device:%d:%s\", deviceNum, tmpStr );\n                gctxt->availEventDesc[idxEventArray].name[PAPI_MIN_STR_LEN-1] = '\\0';\n                char *nameTmpPtr = gctxt->availEventDesc[idxEventArray].name;\n                for ( ii = 0; ii < ( int )strlen( nameTmpPtr ); ii++ ) if ( nameTmpPtr[ii] == ' ' ) nameTmpPtr[ii] = '_';\n                /* Save description in the native event array */\n                tmpSizeBytes = PAPI_2MAX_STR_LEN-1 * sizeof( char );\n                cuptiErr = ( *cuptiEventGetAttributePtr ) ( myeventID, CUPTI_EVENT_ATTR_SHORT_DESCRIPTION, &tmpSizeBytes, gctxt->availEventDesc[idxEventArray].description );\n                CHECK_CUPTI_ERROR( cuptiErr, \"cuptiEventGetAttribute\" );\n                gctxt->availEventDesc[idxEventArray].description[PAPI_2MAX_STR_LEN-1] = '\\0';\n                // SUBDBG( \"Event ID:%d Name:%s Desc:%s\\n\", gctxt->availEventIDArray[idxEventArray], gctxt->availEventDesc[idxEventArray].name, gctxt->availEventDesc[idxEventArray].description );\n                /* Increment index past events in this domain to start of next domain */\n                idxEventArray++;\n            }\n            papi_free ( domainEventIDArray );\n        }\n    }\n    /* return 0 if everything went OK */\n    return 0;\n}\n\n\n/*****************************************************************************\n *******************  BEGIN PAPI's COMPONENT REQUIRED FUNCTIONS  *************\n *****************************************************************************/\n\n/*\n * This is called whenever a thread is initialized.\n */\nstatic int papicuda_init_thread( hwd_context_t * ctx )\n{\n    ( void ) ctx;\n    SUBDBG( \"Entering\\n\" );\n\n    return PAPI_OK;\n}\n\n\n/** Initialize hardware counters, setup the function vector table\n * and get hardware information, this routine is called when the\n * PAPI process is initialized (IE PAPI_library_init)\n */\n/* NOTE: only called by main thread (not by every thread) !!! Starting\n   in CUDA 4.0, multiple CPU threads can access the same CUDA\n   context. This is a much easier programming model then pre-4.0 as\n   threads - using the same context - can share memory, data,\n   etc. It's possible to create a different context for each thread.\n   That's why CUDA context creation is done in CUDA_init_component()\n   (called only by main thread) rather than CUDA_init() or\n   CUDA_init_control_state() (both called by each thread). */\nstatic int papicuda_init_component( int cidx )\n{\n    SUBDBG( \"Entering with cidx: %d\\n\", cidx );\n    int err;\n\n    /* link in all the cuda libraries and resolve the symbols we need to use */\n    if( papicuda_linkCudaLibraries() != PAPI_OK ) {\n        SUBDBG (\"Dynamic link of CUDA libraries failed, component will be disabled.\\n\");\n        SUBDBG (\"See disable reason in papi_component_avail output for more details.\\n\");\n        return (PAPI_ENOSUPP);\n    }\n\n    /* Create the structure */\n    if ( !global_papicuda_context )\n        global_papicuda_context = ( papicuda_context_t* ) papi_calloc( 1, sizeof( papicuda_context_t ) );\n\n    /* Get list of all native CUDA events supported */\n    err = papicuda_list_all_events( global_papicuda_context );\n    if ( err!=0 ) return( err );\n\n    /* Export some information */\n    _cuda_vector.cmp_info.CmpIdx = cidx;\n    _cuda_vector.cmp_info.num_native_events = global_papicuda_context->availEventSize;\n    _cuda_vector.cmp_info.num_cntrs = _cuda_vector.cmp_info.num_native_events;\n    _cuda_vector.cmp_info.num_mpx_cntrs = _cuda_vector.cmp_info.num_native_events;\n\n    //SUBDBG( \"Exiting PAPI_OK\\n\" );\n    return ( PAPI_OK );\n}\n\n\n/** Setup a counter control state.\n *   In general a control state holds the hardware info for an\n *   EventSet.\n */\nstatic int papicuda_init_control_state( hwd_control_state_t *ctrl )\n{\n    SUBDBG( \"Entering\\n\" );\n    ( void ) ctrl;\n    papicuda_context_t *gctxt = global_papicuda_context;\n\n    CHECK_PRINT_EVAL( !gctxt, \"Error: The PAPI CUDA component needs to be initialized first\", return( PAPI_ENOINIT ) );\n    /* If no events were found during the initial component initialization, return error  */\n    if( global_papicuda_context->availEventSize <= 0 ) {\n        strncpy( _cuda_vector.cmp_info.disabled_reason, \"ERROR CUDA: No events exist\", PAPI_MAX_STR_LEN );\n        return ( PAPI_EMISC );\n    }\n    /* If it does not exist, create the global structure to hold CUDA contexts and active events */\n    if ( !global_papicuda_control ) {\n        global_papicuda_control = ( papicuda_control_t* ) papi_calloc( 1, sizeof( papicuda_control_t ) );\n        global_papicuda_control->countOfActiveCUContexts = 0;\n        global_papicuda_control->activeEventCount = 0;\n    }\n    return PAPI_OK;\n}\n\n/** Triggered by eventset operations like add or remove.  For CUDA,\n * needs to be called multiple times from each seperate CUDA context\n * with the events to be measured from that context.  For each\n * context, create eventgroups for the events.\n */\nstatic int papicuda_update_control_state( hwd_control_state_t *ctrl, NativeInfo_t *nativeInfo, int nativeCount, hwd_context_t *ctx )\n{\n    /* Note: NativeInfo_t is defined in papi_internal.h */\n    SUBDBG( \"Entering with nativeCount %d\\n\", nativeCount );\n    ( void ) ctx;\n    ( void ) ctrl;\n    papicuda_control_t *gctrl = global_papicuda_control;\n    papicuda_context_t *gctxt = global_papicuda_context;\n    papicuda_active_cucontext_t *currctrl;\n    int currDeviceNum, currContextIdx, cuContextIdx;\n    CUcontext currCuCtx;\n    int index, ii, jj;\n\n    if ( nativeCount == 0 ) {\n        /* Does nativeCount=0 implies that the component is being reset!? */\n        /* gctrl->activeEventCount = 0;  */\n    } else {\n        /* nativecount>0 so we need to process the events */\n        // SUBDBG( \"There are currently %d contexts\\n\", gctrl->countOfActiveCUContexts );\n\n        /* Get/query some device and context specific information  */\n        CHECK_PRINT_EVAL( ( *cudaGetDevicePtr )( &currDeviceNum )!=cudaSuccess, \"cudaGetDevice: CUDA device MUST be set before adding events\", return( PAPI_EMISC ) );\n        CHECK_PRINT_EVAL( ( *cudaFreePtr )( NULL )!=cudaSuccess, \"cudaFree: Failed to free in this CUDA context\", return( PAPI_EMISC ) );\n        CHECK_PRINT_EVAL( ( *cuCtxGetCurrentPtr )( &currCuCtx )!=CUDA_SUCCESS, \"cuCtxGetCurrent: CUDA context MUST be initialized before adding events\", return ( PAPI_EMISC ) );\n\n        /* Find current context/control, creating it if does not exist */\n        for ( cuContextIdx=0; cuContextIdx<gctrl->countOfActiveCUContexts; cuContextIdx++ )\n            if ( gctrl->arrayOfActiveCUContexts[cuContextIdx]->context == currCuCtx ) break;\n        CHECK_PRINT_EVAL( cuContextIdx==PAPICUDA_MAX_COUNTERS,  \"Exceeded hardcoded maximum number of contexts (PAPICUDA_MAX_COUNTERS)\", return( PAPI_EMISC ) );\n        if ( cuContextIdx==gctrl->countOfActiveCUContexts ) {\n            gctrl->arrayOfActiveCUContexts[cuContextIdx] = papi_calloc( 1, sizeof( papicuda_active_cucontext_t ) );\n            CHECK_PRINT_EVAL( ( gctrl->arrayOfActiveCUContexts[cuContextIdx]==NULL ), \"Memory allocation for new active context failed\", return( PAPI_ENOMEM ) ) ;\n            gctrl->arrayOfActiveCUContexts[cuContextIdx]->context = currCuCtx;\n            gctrl->arrayOfActiveCUContexts[cuContextIdx]->deviceNum = currDeviceNum;\n            gctrl->countOfActiveCUContexts++;\n            SUBDBG( \"Added a new context ... now %d\\n\", gctrl->countOfActiveCUContexts );\n        }\n        currContextIdx = cuContextIdx;\n        currctrl = gctrl->arrayOfActiveCUContexts[currContextIdx];\n        /* At this point, currCuCtx is at index cuContextIdx in the arrayOfActiveCUContexts array */\n\n        /* For each event, check if it is already added.  If not, try to added it to the current context.\n           Try each existing eventgroup.  If none will have this event, create a new event group.  If new event group will not have it... fail */\n        /* For each event */\n        for( ii = 0; ii < nativeCount; ii++ ) {\n            index = nativeInfo[ii].ni_event; /* Get the PAPI event index from the user */\n            /* Check to see if event is already in some context */\n            SUBDBG( \"Searching %d active events to see if event %d %s is already in some context\\n\", gctrl->activeEventCount, index, gctxt->availEventDesc[index].name );\n            int eventAlreadyAdded=0;\n            for( jj = 0; jj < gctrl->activeEventCount; jj++ ) {\n                if ( gctrl->activeEventIndex[jj] == index ) {\n                    eventAlreadyAdded=1;\n                    break;\n                }\n            }\n\n            /* If event was not found in any context.. try to insert it into current context */\n            if ( !eventAlreadyAdded ) {\n                SUBDBG( \"Need to add event %d %s to the current context\\n\", index, gctxt->availEventDesc[index].name );\n                /* Make sure that the device number for the event matches the device for this context */\n                CHECK_PRINT_EVAL( (currDeviceNum!=gctxt->availEventDeviceNum[index]), \"Current CUDA device cannot use this event\", return( PAPI_EINVAL ) );\n                /* if this event index corresponds to something from availEventIDArray */\n                if ( index < ( int )gctxt->availEventSize ) {\n                    /* lookup cuptieventid for this event index */\n                    CUpti_EventID cuptieventid = gctxt->availEventIDArray[index];\n                    CUpti_EventGroup cuptieventgroup;\n                    int addstatus=!CUPTI_SUCCESS, gg;\n                    SUBDBG( \"Event %s is going to be added to current context %d having %d eventgroups\\n\", gctxt->availEventDesc[index].name, currContextIdx, currctrl->numEventGroups );\n                    /* For each existing eventgroup, try to insert this event */\n                    for ( gg=0; gg<currctrl->numEventGroups; gg++ ) {\n                        cuptieventgroup = currctrl->eventGroup[gg];\n                        addstatus = ( *cuptiEventGroupAddEventPtr )( cuptieventgroup, cuptieventid );\n                        if ( addstatus==CUPTI_SUCCESS ) {\n                            SUBDBG( \"Event %s successfully added to current eventgroup %d:%d\\n\", gctxt->availEventDesc[index].name, currContextIdx, gg );\n                            break;\n                        }\n                    }\n                    /* If the event could not be added to any earlier eventgroup, create a new one and try again.  Fail if this does not succeed */\n                    if ( addstatus!=CUPTI_SUCCESS ) {\n                        //SUBDBG( \"Event %s needs a new eventgroup\\n\", gctxt->availEventDesc[index].name );\n                        CHECK_PRINT_EVAL( ( gg>PAPICUDA_MAX_COUNTERS-1 ), \"For current CUDA device, could not add event (no more eventgroups can be added)\", return( PAPI_EMISC ) );\n                        //SUBDBG( \"gg %d context %d %p\\n\", gg, currctrl->context, currctrl->context  );\n                        CHECK_CUPTI_ERROR( ( *cuptiEventGroupCreatePtr )( currctrl->context, &currctrl->eventGroup[gg], 0 ), \"cuptiEventGroupCreate\" );\n                        cuptieventgroup = currctrl->eventGroup[gg];\n                        currctrl->numEventGroups++;\n                        addstatus = ( *cuptiEventGroupAddEventPtr )( cuptieventgroup, cuptieventid );\n                        CHECK_PRINT_EVAL( ( addstatus!=CUPTI_SUCCESS ), \"cuptiEventGroupAddEvent: Could not add event (event may not match CUDA context)\", return( PAPI_EMISC ) );\n                        SUBDBG( \"Event %s successfully added to new eventgroup %d:%d\\n\", gctxt->availEventDesc[index].name, currContextIdx, gg );\n                    }\n                }\n\n                /* Record index of this active event back into the nativeInfo structure */\n                nativeInfo[ii].ni_position = gctrl->activeEventCount;\n                /* record added event at the higher level */\n                CHECK_PRINT_EVAL( ( gctrl->activeEventCount==PAPICUDA_MAX_COUNTERS-1 ), \"Exceeded maximum num of events (PAPI_MAX_COUNTERS)\", return( PAPI_EMISC ) );\n                gctrl->activeEventIndex[gctrl->activeEventCount] = index;\n                gctrl->activeEventContextIdx[gctrl->activeEventCount] = currContextIdx;\n                gctrl->activeEventValues[gctrl->activeEventCount] = 0;\n                gctrl->activeEventCount++;\n\n            }\n        }\n    }\n    return ( PAPI_OK );\n}\n\n/** Triggered by PAPI_start().\n * For CUDA component, switch to each context and start all eventgroups.\n*/\nstatic int papicuda_start( hwd_context_t * ctx, hwd_control_state_t * ctrl )\n{\n    SUBDBG( \"Entering\\n\" );\n    ( void ) ctx;\n    ( void ) ctrl;\n    papicuda_control_t *gctrl = global_papicuda_control;\n    //papicuda_context_t *gctxt = global_papicuda_context;\n    papicuda_active_cucontext_t *currctrl;\n    int cuContextIdx, gg, ii;\n    CUptiResult cuptiErr;\n    CUcontext saveCtx, tmpCtx;\n\n    //SUBDBG( \"Reset all active event values\\n\" );\n    for ( ii=0; ii<gctrl->activeEventCount; ii++ )\n        gctrl->activeEventValues[ii] = 0;\n\n    // SUBDBG( \"Switch to each context and enable CUDA eventgroups associated with that context\\n\" );\n    /* Save current cuda context */\n    CHECK_CU_ERROR( ( *cuCtxPopCurrentPtr ) ( &saveCtx ), \"cuCtxPopCurrent\" );\n    /* Switch to each context and enable CUDA eventgroups */\n    for ( cuContextIdx=0; cuContextIdx<gctrl->countOfActiveCUContexts; cuContextIdx++ ) {\n        currctrl = gctrl->arrayOfActiveCUContexts[cuContextIdx];\n        //SUBDBG( \"Try to switch to context %d associated with device %d\\n\", cuContextIdx, currctrl->deviceNum );\n        CHECK_CU_ERROR( ( *cuCtxPushCurrentPtr ) ( currctrl->context ),  \"cuCtxPushCurrent\" );\n        for ( gg=0; gg<currctrl->numEventGroups; gg++ ) {\n            // SUBDBG( \"Enable event group\\n\" );\n            cuptiErr = ( *cuptiEventGroupEnablePtr )( currctrl->eventGroup[gg] );\n            CHECK_PRINT_EVAL( ( cuptiErr!=CUPTI_SUCCESS ), \"cuptiEventGroupEnable: Could not enable one of the event groups\", return( PAPI_EMISC ) );\n            // SUBDBG( \"Reset events in eventgroup\\n\" );\n            cuptiErr = ( *cuptiEventGroupResetAllEventsPtr )( currctrl->eventGroup[gg] );\n            CHECK_PRINT_EVAL( ( cuptiErr!=CUPTI_SUCCESS ), \"cuptiEventGroupResetAllEvents: Could not reset the event groups\", return( PAPI_EMISC ) );\n            SUBDBG( \"For papicuda context %d on device %d event group %d was enabled and reset\\n\", cuContextIdx, currctrl->deviceNum, gg );\n        }\n        // SUBDBG( \"Pop temp context\\n\" );\n        CHECK_CU_ERROR( ( *cuCtxPopCurrentPtr ) ( &tmpCtx ),  \"cuCtxPopCurrent\" );\n    }\n    //SUBDBG( \"Restore original context\\n\" );\n    CHECK_CU_ERROR( ( *cuCtxPushCurrentPtr ) ( saveCtx ),  \"cuCtxPushCurrent\" );\n    return ( PAPI_OK );\n}\n\n/** Triggered by PAPI_stop() */\nstatic int papicuda_stop( hwd_context_t * ctx, hwd_control_state_t * ctrl )\n{\n    SUBDBG( \"Entering to disable all CUPTI eventgroups\\n\" );\n    ( void ) ctx;\n    ( void ) ctrl;\n    papicuda_control_t *gctrl = global_papicuda_control;\n    papicuda_active_cucontext_t *currctrl;\n    int cuContextIdx, gg;\n    CUptiResult cuptiErr;\n    CUcontext saveCtx, tmpCtx;\n\n    // SUBDBG( \"Save initial CUDA context\\n\" );\n    CHECK_CU_ERROR( ( *cuCtxPopCurrentPtr ) ( &saveCtx ), \"cuCtxPopCurrent\" );\n    // SUBDBG( \"Switch to each context and disable CUDA eventgroups\\n\" );\n    for ( cuContextIdx=0; cuContextIdx<gctrl->countOfActiveCUContexts; cuContextIdx++ ) {\n        currctrl = gctrl->arrayOfActiveCUContexts[cuContextIdx];\n        //SUBDBG( \"Try to switch to context %d associated with device %d\\n\", cuContextIdx, currctrl->deviceNum );\n        CHECK_CU_ERROR( ( *cuCtxPushCurrentPtr ) ( currctrl->context ),  \"cuCtxPushCurrent\" );\n        for ( gg=0; gg<currctrl->numEventGroups; gg++ ) {\n            // SUBDBG( \"Disable events in eventgroup\\n\" );\n            cuptiErr = ( *cuptiEventGroupDisablePtr )( currctrl->eventGroup[gg] );\n            CHECK_PRINT_EVAL( ( cuptiErr!=CUPTI_SUCCESS ), \"cuptiEventGroupDisable: Could not disable the event groups\", return( PAPI_EMISC ) );\n            SUBDBG( \"For papicuda context %d on device %d event group %d was disabled\\n\", cuContextIdx, currctrl->deviceNum, gg );\n        }\n        CHECK_CU_ERROR( ( *cuCtxPopCurrentPtr ) ( &tmpCtx ),  \"cuCtxPopCurrent\" );\n    }\n    //SUBDBG( \"Restore original context\\n\" );\n    CHECK_CU_ERROR( ( *cuCtxPushCurrentPtr ) ( saveCtx ),  \"cuCtxPushCurrent\" );\n    return ( PAPI_OK );\n}\n\n\n/** Triggered by PAPI_read().  For CUDA component, switch to each\n * context, read all the eventgroups, and put the values in the\n * correct places. */\nstatic int papicuda_read( hwd_context_t * ctx, hwd_control_state_t * ctrl, long long ** events, int flags )\n{\n    SUBDBG( \"Entering\\n\" );\n    ( void ) ctx;\n    ( void ) ctrl;\n    ( void ) flags;\n    papicuda_control_t *gctrl = global_papicuda_control;\n    papicuda_context_t *gctxt = global_papicuda_context;\n    papicuda_active_cucontext_t *currctrl;\n    int cuContextIdx, gg, ii, jj;\n    CUcontext saveCtx, tmpCtx;\n    CUptiResult cuptiErr;\n    size_t readEventValueBufferSize = sizeof( uint64_t )*PAPICUDA_MAX_COUNTERS;\n    uint64_t readEventValueBuffer[PAPICUDA_MAX_COUNTERS];\n    size_t readEventIDArraySize = sizeof( CUpti_EventID )*PAPICUDA_MAX_COUNTERS;\n    CUpti_EventID readEventIDArray[PAPICUDA_MAX_COUNTERS];\n    size_t numEventIDsRead;\n\n    SUBDBG( \"Switch to each context and read CUDA eventgroups\\n\" );\n    // SUBDBG( \"Save initial CUDA context\\n\" );\n    CHECK_CU_ERROR( ( *cuCtxPopCurrentPtr ) ( &saveCtx ), \"cuCtxPopCurrent\" );\n    /* Switch to each context and enable CUDA eventgroups */\n    for ( cuContextIdx=0; cuContextIdx<gctrl->countOfActiveCUContexts; cuContextIdx++ ) {\n        currctrl = gctrl->arrayOfActiveCUContexts[cuContextIdx];\n        // SUBDBG( \"Switch to context %d associated with device %d\\n\", cuContextIdx, currctrl->deviceNum );\n        CHECK_CU_ERROR( ( *cuCtxPushCurrentPtr ) ( currctrl->context ),  \"cuCtxPushCurrent\" );\n        for ( gg=0; gg<currctrl->numEventGroups; gg++ ) {\n            // SUBDBG( \"Read from context %d eventgroup %d\\n\", cuContextIdx, gg );\n            cuptiErr = ( *cuptiEventGroupReadAllEventsPtr )( currctrl->eventGroup[gg], CUPTI_EVENT_READ_FLAG_NONE, &readEventValueBufferSize, readEventValueBuffer, &readEventIDArraySize, readEventIDArray, &numEventIDsRead );\n            CHECK_PRINT_EVAL( ( cuptiErr!=CUPTI_SUCCESS ), \"cuptiEventGroupReadAllEvents: Could not read from CUPTI eventgroup\", return( PAPI_EMISC ) );\n            /* Match read values against active events by scanning activeEvents array and matching associated availEventIDs  */\n            for( ii = 0; ii < ( int )numEventIDsRead; ii++ ) {\n                for( jj = 0; jj < gctrl->activeEventCount; jj++ ) {\n                    int eventIndex = gctrl->activeEventIndex[jj];\n                    if ( gctrl->activeEventContextIdx[jj]==cuContextIdx && gctxt->availEventIDArray[eventIndex]==readEventIDArray[ii] ) {\n                        gctrl->activeEventValues[jj] += ( long long )readEventValueBuffer[ii];\n                        SUBDBG( \"Matched read-eventID %d:%d value %ld activeEvent %d value %lld \\n\", jj, (int)readEventIDArray[ii], readEventValueBuffer[ii], eventIndex, gctrl->activeEventValues[jj] );\n                        break;\n                    }\n                }\n            }\n        }\n        CUresult cuErr = ( *cuCtxPopCurrentPtr ) ( &tmpCtx );\n        if ( cuErr != CUDA_SUCCESS ) PAPIERROR ( \"Error popping context %d\\n\", cuErr );\n        CHECK_CU_ERROR( cuErr,  \"cuCtxPopCurrent\" );\n    }\n    //SUBDBG( \"Restore original context\\n\" );\n    CHECK_CU_ERROR( ( *cuCtxPushCurrentPtr ) ( saveCtx ),  \"cuCtxPushCurrent\" );\n    *events = gctrl->activeEventValues;\n    return ( PAPI_OK );\n}\n\n/** Called at thread shutdown. Does nothing in the CUDA component. */\nint papicuda_shutdown_thread( hwd_context_t * ctx )\n{\n    SUBDBG( \"Entering\\n\" );\n    ( void ) ctx;\n\n    return ( PAPI_OK );\n}\n\n/** Triggered by PAPI_shutdown() and frees memory allocated in the CUDA component. */\nstatic int papicuda_shutdown_component( void )\n{\n    SUBDBG( \"Entering\\n\" );\n    papicuda_control_t *gctrl = global_papicuda_control;\n    papicuda_context_t *gctxt = global_papicuda_context;\n    int deviceNum, cuContextIdx;\n    /* Free context  */\n    if ( gctxt ) {\n        for( deviceNum = 0; deviceNum < gctxt->deviceCount; deviceNum++ ) {\n            papicuda_device_desc_t *mydevice = &gctxt->deviceArray[deviceNum];\n            papi_free( mydevice->domainIDArray );\n            papi_free( mydevice->domainIDNumEvents );\n        }\n        papi_free( gctxt->availEventIDArray );\n        papi_free( gctxt->availEventDeviceNum );\n        papi_free( gctxt->availEventDesc );\n        papi_free( gctxt->deviceArray );\n        papi_free( gctxt );\n        global_papicuda_context = gctxt = NULL;\n    }\n    /* Free control  */\n    if ( gctrl ) {\n        for ( cuContextIdx=0; cuContextIdx<gctrl->countOfActiveCUContexts; cuContextIdx++ )\n            if ( gctrl->arrayOfActiveCUContexts[cuContextIdx]!=NULL )\n                papi_free( gctrl->arrayOfActiveCUContexts[cuContextIdx] );\n        papi_free( gctrl );\n        global_papicuda_control = gctrl = NULL;\n    }\n    // close the dynamic libraries needed by this component (opened in the init substrate call)\n    dlclose( dl1 );\n    dlclose( dl2 );\n    dlclose( dl3 );\n    return ( PAPI_OK );\n}\n\n\n/** This function sets various options in the component - Does nothing in the CUDA component.\n  @param[in] ctx -- hardware context\n  @param[in] code valid are PAPI_SET_DEFDOM, PAPI_SET_DOMAIN, PAPI_SETDEFGRN, PAPI_SET_GRANUL and PAPI_SET_INHERIT\n  @param[in] option -- options to be set\n */\nstatic int papicuda_ctrl( hwd_context_t * ctx, int code, _papi_int_option_t * option )\n{\n    SUBDBG( \"Entering\\n\" );\n    ( void ) ctx;\n    ( void ) code;\n    ( void ) option;\n    return ( PAPI_OK );\n}\n\n\n/*\n * This function has to set the bits needed to count different domains\n * In particular: PAPI_DOM_USER, PAPI_DOM_KERNEL PAPI_DOM_OTHER\n * By default return PAPI_EINVAL if none of those are specified\n * and PAPI_OK with success\n * PAPI_DOM_USER is only user context is counted\n * PAPI_DOM_KERNEL is only the Kernel/OS context is counted\n * PAPI_DOM_OTHER  is Exception/transient mode (like user TLB misses)\n * PAPI_DOM_ALL   is all of the domains\n */\nstatic int papicuda_set_domain( hwd_control_state_t * ctrl, int domain )\n{\n    SUBDBG( \"Entering\\n\" );\n    ( void ) ctrl;\n    if ( ( PAPI_DOM_USER & domain ) ||\n            ( PAPI_DOM_KERNEL & domain ) ||\n            ( PAPI_DOM_OTHER & domain ) )\n        return ( PAPI_OK );\n    else\n        return ( PAPI_EINVAL );\n    return ( PAPI_OK );\n}\n\n\n/** Triggered by PAPI_reset() but only if the EventSet is currently\n *  running. If the eventset is not currently running, then the saved\n *  value in the EventSet is set to zero without calling this\n *  routine.  */\nstatic int papicuda_reset( hwd_context_t * ctx, hwd_control_state_t * ctrl )\n{\n    SUBDBG( \"Entering\\n\" );\n    ( void ) ctx;\n    ( void ) ctrl;\n    papicuda_control_t *gctrl = global_papicuda_control;\n    papicuda_active_cucontext_t *currctrl;\n    int cuContextIdx, gg, ii;\n    CUptiResult cuptiErr;\n    CUcontext saveCtx, tmpCtx;\n\n    //SUBDBG( \"Reset all active event values\\n\" );\n    for ( ii=0; ii<gctrl->activeEventCount; ii++ )\n        gctrl->activeEventValues[ii] = 0;\n    // SUBDBG( \"Save initial CUDA context and restore later\\n\" );\n    CHECK_CU_ERROR( ( *cuCtxPopCurrentPtr ) ( &saveCtx ), \"cuCtxPopCurrent\" );\n    // SUBDBG( \"Switch to each context and reset CUDA eventgroups\\n\" );\n    for ( cuContextIdx=0; cuContextIdx<gctrl->countOfActiveCUContexts; cuContextIdx++ ) {\n        currctrl = gctrl->arrayOfActiveCUContexts[cuContextIdx];\n        //SUBDBG( \"Try to switch to context %d associated with device %d\\n\", cuContextIdx, currctrl->deviceNum );\n        CHECK_CU_ERROR( ( *cuCtxPushCurrentPtr ) ( currctrl->context ),  \"cuCtxPushCurrent\" );\n        for ( gg=0; gg<currctrl->numEventGroups; gg++ ) {\n            // SUBDBG( \"Reset events in eventgroup\\n\" );\n            cuptiErr = ( *cuptiEventGroupResetAllEventsPtr )( currctrl->eventGroup[gg] );\n            CHECK_PRINT_EVAL( ( cuptiErr!=CUPTI_SUCCESS ), \"cuptiEventGroupResetAllEvents: Could not reset the event groups\", return( PAPI_EMISC ) );\n            SUBDBG( \"For papicuda context %d on device %d event group %d was enabled and reset\\n\", cuContextIdx, currctrl->deviceNum, gg );\n        }\n        CHECK_CU_ERROR( ( *cuCtxPopCurrentPtr ) ( &tmpCtx ),  \"cuCtxPopCurrent\" );\n    }\n    // SUBDBG( \"Restore original context\\n\" );\n    CHECK_CU_ERROR( ( *cuCtxPushCurrentPtr ) ( saveCtx ),  \"cuCtxPushCurrent\" );\n    return ( PAPI_OK );\n}\n\n\n/*\n * Disable and destroy the CUDA eventGroup\n*/\nstatic int papicuda_cleanup_eventset( hwd_control_state_t * ctrl )\n{\n    SUBDBG( \"Entering\\n\" );\n    ( void ) ctrl;\n    papicuda_control_t *gctrl = global_papicuda_control;\n    papicuda_active_cucontext_t *currctrl;\n    int cuContextIdx, gg;\n    CUptiResult cuptiErr;\n    CUcontext saveCtx, tmpCtx;\n\n    SUBDBG( \"Switch to each context and disable CUDA eventgroups\\n\" );\n    /* Save current cuda context and restore later */\n    CHECK_CU_ERROR( ( *cuCtxPopCurrentPtr ) ( &saveCtx ), \"cuCtxPopCurrent\" );\n    /* Switch to each context and enable CUDA eventgroups */\n    for ( cuContextIdx=0; cuContextIdx<gctrl->countOfActiveCUContexts; cuContextIdx++ ) {\n        currctrl = gctrl->arrayOfActiveCUContexts[cuContextIdx];\n        /* Switch to this device / cuda context */\n        CHECK_CU_ERROR( ( *cuCtxPushCurrentPtr ) ( currctrl->context ),  \"cuCtxPushCurrent\" );\n        for ( gg=0; gg<currctrl->numEventGroups; gg++ ) {\n            /* Destroy the eventGroups; it also frees the perfmon hardware on the GPU */\n            cuptiErr = ( *cuptiEventGroupDestroyPtr )( currctrl->eventGroup[gg] );\n            CHECK_CUPTI_ERROR( cuptiErr, \"cuptiEventGroupDestroy\" );\n        }\n        currctrl->numEventGroups = 0;\n        CHECK_CU_ERROR( ( *cuCtxPopCurrentPtr ) ( &tmpCtx ),  \"cuCtxPopCurrent\" );\n    }\n    CHECK_CU_ERROR( ( *cuCtxPushCurrentPtr ) ( saveCtx ),  \"cuCtxPushCurrent\" );\n    /* Record that there are no active contexts or events */\n    gctrl->activeEventCount = 0;\n    return ( PAPI_OK );\n}\n\n\n/** Enumerate Native Events.\n *   @param EventCode is the event of interest\n *   @param modifier is one of PAPI_ENUM_FIRST, PAPI_ENUM_EVENTS\n */\nstatic int papicuda_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n    //SUBDBG( \"Entering\\n\" );\n    switch( modifier ) {\n    case PAPI_ENUM_FIRST:\n        *EventCode = 0;\n        return ( PAPI_OK );\n        break;\n    case PAPI_ENUM_EVENTS:\n        if( *EventCode < global_papicuda_context->availEventSize - 1 ) {\n            *EventCode = *EventCode + 1;\n            return ( PAPI_OK );\n        } else\n            return ( PAPI_ENOEVNT );\n        break;\n    default:\n        return ( PAPI_EINVAL );\n    }\n    return ( PAPI_OK );\n}\n\n\n/** Takes a native event code and passes back the name\n * @param EventCode is the native event code\n * @param name is a pointer for the name to be copied to\n * @param len is the size of the name string\n */\nstatic int papicuda_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n    //SUBDBG( \"Entering EventCode %d\\n\", EventCode );\n    unsigned int index = EventCode;\n    papicuda_context_t *gctxt = global_papicuda_context;\n    if ( index < gctxt->availEventSize ) {\n        strncpy( name, gctxt->availEventDesc[index].name, len );\n    } else {\n        return ( PAPI_EINVAL );\n    }\n    //SUBDBG( \"EventCode %d: Exit %s\\n\", EventCode, name );\n    return ( PAPI_OK );\n}\n\n\n/** Takes a native event code and passes back the event description\n * @param EventCode is the native event code\n * @param descr is a pointer for the description to be copied to\n * @param len is the size of the descr string\n */\nstatic int papicuda_ntv_code_to_descr( unsigned int EventCode, char *name, int len )\n{\n    //SUBDBG( \"Entering\\n\" );\n    unsigned int index = EventCode;\n    papicuda_context_t *gctxt = global_papicuda_context;\n    if ( index < gctxt->availEventSize ) {\n        strncpy( name, gctxt->availEventDesc[index].description, len );\n    } else {\n        return ( PAPI_EINVAL );\n    }\n    return ( PAPI_OK );\n}\n\n\n/** Vector that points to entry points for the component */\npapi_vector_t _cuda_vector = {\n    .cmp_info = {\n        /* default component information (unspecified values are initialized to 0) */\n        .name = \"cuda\",\n        .short_name = \"cuda\",\n        .version = \"5.1\",\n        .description = \"The CUDA component uses CuPTI for NVIDIA GPU hardware events\",\n        .num_mpx_cntrs = PAPICUDA_MAX_COUNTERS,\n        .num_cntrs = PAPICUDA_MAX_COUNTERS,\n        .default_domain = PAPI_DOM_USER,\n        .default_granularity = PAPI_GRN_THR,\n        .available_granularities = PAPI_GRN_THR,\n        .hardware_intr_sig = PAPI_INT_SIGNAL,\n        /* component specific cmp_info initializations */\n        .fast_real_timer = 0,\n        .fast_virtual_timer = 0,\n        .attach = 0,\n        .attach_must_ptrace = 0,\n        .available_domains = PAPI_DOM_USER | PAPI_DOM_KERNEL,\n    },\n    /* sizes of framework-opaque component-private structures... these are all unused in this component */\n    .size = {\n        .context = 1, /* sizeof( papicuda_context_t ), */\n        .control_state = 1, /*sizeof( papicuda_control_t ), */\n        .reg_value = 1, /*sizeof( papicuda_register_t ), */\n        .reg_alloc = 1, /*sizeof( papicuda_reg_alloc_t ), */\n    },\n    /* function pointers in this component */\n    .init_thread = papicuda_init_thread, /* ( hwd_context_t * ctx ) */\n    .init_component = papicuda_init_component, /* ( int cidx ) */\n    .init_control_state = papicuda_init_control_state, /* ( hwd_control_state_t * ctrl ) */\n    .start = papicuda_start, /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl ) */\n    .stop = papicuda_stop, /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl ) */\n    .read = papicuda_read, /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl, long_long ** events, int flags ) */\n    .shutdown_component = papicuda_shutdown_component, /* ( void ) */\n    .shutdown_thread = papicuda_shutdown_thread, /* ( hwd_context_t * ctx ) */\n    .cleanup_eventset = papicuda_cleanup_eventset, /* ( hwd_control_state_t * ctrl ) */\n    .ctl = papicuda_ctrl, /* ( hwd_context_t * ctx, int code, _papi_int_option_t * option ) */\n    .update_control_state = papicuda_update_control_state, /* ( hwd_control_state_t * ptr, NativeInfo_t * native, int count, hwd_context_t * ctx ) */\n    .set_domain = papicuda_set_domain, /* ( hwd_control_state_t * cntrl, int domain ) */\n    .reset = papicuda_reset, /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl ) */\n    .ntv_enum_events = papicuda_ntv_enum_events, /* ( unsigned int *EventCode, int modifier ) */\n    .ntv_code_to_name = papicuda_ntv_code_to_name, /* ( unsigned int EventCode, char *name, int len ) */\n    .ntv_code_to_descr = papicuda_ntv_code_to_descr, /* ( unsigned int EventCode, char *name, int len ) */\n    //.ntv_code_to_bits = papicuda_ntv_code_to_bits,   /* ( unsigned int EventCode, hwd_register_t * bits ) */\n\n};\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/components/cuda/tests/cuda_ld_preload_example.c": "/*\n  Example of using LD_PRELOAD with the CUDA component.  \n  Asim YarKhan\n\n  This is designed to work with the simpleMultiGPU_no_counters binary\n  in the PAPI CUDA component tests directory.  First trace the library\n  calls in simpleMultiGPU_no_counters binary using ltrace.  Note in\n  the ltrace output that the CUDA C APIs are different from the CUDA\n  calls visible to nvcc. Then figure out appropriate place to attach\n  the PAPI calls.  The initialization is attached to the first entry\n  to cudaSetDevice.  Each cudaSetDevice is also used to setup the PAPI\n  events for that device.  It was harder to figure out where to attach\n  the PAPI_start.  After running some tests, I attached it to the 18th\n  invocation of gettimeofday (kind of arbitrary! Sorry!).  The\n  PAPI_stop was attached to the first invocation of cudaFreeHost.\n\n*/\n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <dlfcn.h>\n\n#include \"papi.h\"\n\n#define MAXDEVICES 5\nint EventSet = PAPI_NULL;\nint devseen[MAXDEVICES] = {0};\n\nstatic void *dl1;\nint (*PAPI_library_init_ptr)(int version); /**< initialize the PAPI library */\nint (*PAPI_create_eventset_ptr)(int *EventSet); /**< create a new empty PAPI event set */\nint (*PAPI_add_named_event_ptr)(int EventSet, char *EventName); /**< add an event by name to a PAPI event set */\nint (*PAPI_start_ptr)(int EventSet); /**< start counting hardware events in an event set */\nint (*PAPI_stop_ptr)(int EventSet, long long * values); /**< stop counting hardware events in an event set and return current events */\n\n\nint cudaSetDevice(int devnum, int n1, int n2, int n3, void *ptr1) \n{\n    static int onetime = 0;\n    int retval, retval_cudaSetDevice;\n    //printf(\"cudaSetDevice wrapper %d\\n\", devnum);\n    if ( onetime==0 ) {\n        onetime=1;\n        // Load the papi library dynamically and read the relevant functions\n        dl1 = dlopen( \"libpapi.so\", RTLD_NOW | RTLD_GLOBAL );\n        if ( dl1==NULL ) printf(\"Intercept cudaSetDevice: Cannot load libpapi.so\\n\");\n        PAPI_library_init_ptr = dlsym( dl1, \"PAPI_library_init\" );\n        PAPI_create_eventset_ptr = dlsym( dl1, \"PAPI_create_eventset\" );\n        PAPI_add_named_event_ptr = dlsym( dl1, \"PAPI_add_named_event\" );\n        PAPI_start_ptr = dlsym( dl1, \"PAPI_start\" );\n        PAPI_stop_ptr = dlsym( dl1, \"PAPI_stop\" );\n        // Start using PAPI\n        printf(\"Intercept cudaSetDevice: Initializing PAPI on device %d\\n\", devnum);\n        retval = (PAPI_library_init_ptr)( PAPI_VER_CURRENT );\n        if( retval != PAPI_VER_CURRENT ) fprintf( stdout, \"PAPI_library_init failed\\n\" );\n        printf( \"PAPI version: %d.%d.%d\\n\", PAPI_VERSION_MAJOR( PAPI_VERSION ), PAPI_VERSION_MINOR( PAPI_VERSION ), PAPI_VERSION_REVISION( PAPI_VERSION ) );\n        retval = (PAPI_create_eventset_ptr)( &EventSet );\n        if( retval != PAPI_OK ) fprintf( stdout, \"PAPI_create_eventset failed\\n\" );\n    }\n    int (*original_function)(int devnum, int n1, int n2, int n3, void *ptr1);\n    original_function = dlsym(RTLD_NEXT, \"cudaSetDevice\");\n    retval_cudaSetDevice = (*original_function)( devnum, n1, n2, n3, ptr1 );\n    if ( devseen[devnum]==0 ) {\n        devseen[devnum]=1;\n        char tmpEventName[120];\n        printf(\"Intercept cudaSetDevice: Attaching events for device on device %d\\n\", devnum);\n        snprintf( tmpEventName, 110, \"cuda:::device:%d:%s\", devnum, \"inst_executed\" );\n        retval = (PAPI_add_named_event_ptr)( EventSet, tmpEventName );\n        if (retval!=PAPI_OK) printf( \"Could not add event %s\\n\", tmpEventName );\n    }\n    return retval_cudaSetDevice;\n}\n\n\nint gettimeofday(void *ptr1, void *ptr2)\n{\n    static int onetime = 0;\n    onetime++;\n    // printf(\"gettimeofday onetime %d\\n\", onetime);\n    // Use above print statement to determine that the N-th gettime of day works\n    if ( onetime==17 ) {\n        printf(\"Intercept gettimeofday: Attaching PAPI_start to the %d th call to gettimeofday (this may need to be adjusted)\\n\", onetime);\n        int retval = (PAPI_start_ptr)( EventSet );\n        printf(\"Starting PAPI\\n\");\n        if( retval!=PAPI_OK ) fprintf( stdout, \"PAPI_start failed\\n\" );\n    }\n    int (*original_function)(void *ptr1, void *ptr2);\n    original_function = dlsym(RTLD_NEXT, \"gettimeofday\");\n    return (*original_function)(ptr1, ptr2);\n}\n\nint cudaFreeHost(void *ptr1, void *ptr2, int n1, int n2, void *ptr3) \n{\n    static int onetime = 0;\n    long long values[10];\n    int retval, devnum;\n    onetime++;\n    if ( onetime==1 ) {\n        printf(\"Intercept cudaFreeHost: Used to get PAPI results\\n\" );\n        retval = (PAPI_stop_ptr)( EventSet, values );\n        if( retval != PAPI_OK )  fprintf( stderr, \"PAPI_stop failed\\n\" );\n        for( devnum = 0; devnum < MAXDEVICES && devseen[devnum]==1  ; devnum++ )\n            printf( \"PAPI counterValue: cuda::device:%d:%s: %12lld \\n\", devnum, \"inst_executed\", values[devnum] );\n    }\n    int (*original_function)(void *ptr1, void *ptr2, int n1, int n2, void *ptr3);\n    original_function = dlsym(RTLD_NEXT, \"cudaFreeHost\");\n    return (*original_function)(ptr1, ptr2, n1, n2, ptr3);\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/components/infiniband_umad/linux-infiniband_umad.c": "/****************************/\n/* THIS IS OPEN SOURCE CODE */\n/****************************/\n\n/** \n * @file    linux-infiniband.c\n * @author  Heike Jagode (in collaboration with Michael Kluge, TU Dresden)\n *          jagode@eecs.utk.edu\n *\n * @ingroup papi_components \t\t\n * \n * InfiniBand component \n * \n * Tested version of OFED: 1.4\n *\n * @brief\n *  This file has the source code for a component that enables PAPI-C to \n *  access hardware monitoring counters for InfiniBand devices through the  \n *  OFED library. Since a new interface was introduced with OFED version 1.4 \n *  (released Dec 2008), the current InfiniBand component does not support \n *  OFED versions < 1.4.\n */\n#include <dlfcn.h>\n\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\n#include \"linux-infiniband_umad.h\"\n\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));\n\n/********  CHANGE PROTOTYPES TO DECLARE Infiniband LIBRARY SYMBOLS AS WEAK  **********\n *  This is done so that a version of PAPI built with the infiniband component can   *\n *  be installed on a system which does not have the infiniband libraries installed. *\n *                                                                                   *\n *  If this is done without these prototypes, then all papi services on the system   *\n *  without the infiniband libraries installed will fail.  The PAPI libraries        *\n *  contain references to the infiniband libraries which are not installed.  The     *\n *  load of PAPI commands fails because the infiniband library references can not    *\n *  be resolved.                                                                     *\n *                                                                                   *\n *  This also defines pointers to the infiniband library functions that we call.     *\n *  These function pointers will be resolved with dlopen/dlsym calls at component    *\n *  initialization time.  The component then calls the infiniband library functions  *\n *  through these function pointers.                                                 *\n *************************************************************************************/\nint                 __attribute__((weak)) umad_init              ( void );\nint                 __attribute__((weak)) umad_get_cas_names     ( char [][UMAD_CA_NAME_LEN], int  );\nint                 __attribute__((weak)) umad_get_ca            ( char *, umad_ca_t * );\nvoid                __attribute__((weak)) mad_decode_field       ( unsigned char *, enum MAD_FIELDS, void *);\nstruct ibmad_port * __attribute__((weak)) mad_rpc_open_port      ( char *, int, int *, int );\nint                 __attribute__((weak)) ib_resolve_self_via    ( ib_portid_t *, int *, ibmad_gid_t *, const struct ibmad_port * );\nuint8_t *           __attribute__((weak)) performance_reset_via  ( void *, ib_portid_t *, int, unsigned, unsigned, unsigned, const struct ibmad_port * );\nuint8_t *           __attribute__((weak)) pma_query_via          ( void *, ib_portid_t *, int, unsigned, unsigned, const struct ibmad_port * );\n\nint                  (*umad_initPtr)             ( void );\nint                  (*umad_get_cas_namesPtr)    ( char [][UMAD_CA_NAME_LEN], int );\nint                  (*umad_get_caPtr)           ( char *, umad_ca_t * );\nvoid                 (*mad_decode_fieldPtr)      ( unsigned char *, enum MAD_FIELDS, void * );\nstruct ibmad_port *  (*mad_rpc_open_portPtr)     ( char *, int, int *, int );\nint                  (*ib_resolve_self_viaPtr)   (ib_portid_t *, int *, ibmad_gid_t *, const struct ibmad_port * );\nuint8_t *            (*performance_reset_viaPtr) (void *, ib_portid_t *, int, unsigned, unsigned, unsigned, const struct ibmad_port * );\nuint8_t *            (*pma_query_viaPtr)         (void *, ib_portid_t *, int, unsigned, unsigned, const struct ibmad_port * );\n\n// file handles used to access Infiniband libraries with dlopen\nstatic void* dl1 = NULL;\nstatic void* dl2 = NULL;\n\nstatic int linkInfinibandLibraries ();\n\npapi_vector_t _infiniband_vector;\n\n\n\nstruct ibmad_port *srcport;\nstatic ib_portid_t portid;\nstatic int ib_timeout = 0;\nstatic int ibportnum = 0;\n\nstatic counter_info *subscriptions[INFINIBAND_MAX_COUNTERS];\nstatic int is_initialized = 0;\nstatic int num_counters = 0;\nstatic int is_finalized = 0;\n\n/* counters are kept in a list */\nstatic counter_info *root_counter = NULL;\n/* IB ports found are kept in a list */\nstatic ib_port *root_ib_port = NULL;\nstatic ib_port *active_ib_port = NULL;\n\n#define infiniband_native_table subscriptions\n/* macro to initialize entire structs to 0 */\n#define InitStruct(var, type) type var; memset(&var, 0, sizeof(type))\n\nlong long _papi_hwd_infiniband_register_start[INFINIBAND_MAX_COUNTERS];\nlong long _papi_hwd_infiniband_register[INFINIBAND_MAX_COUNTERS];\n\n\n/*******************************************************************************\n ********  BEGIN FUNCTIONS  USED INTERNALLY SPECIFIC TO THIS COMPONENT *********\n ******************************************************************************/\n\n/**\n * use libumad to discover IB ports\n */\nstatic void\ninit_ib_counter(  )\n{\n\tchar names[20][UMAD_CA_NAME_LEN];\n\tint n, i;\n\tchar *ca_name;\n\tumad_ca_t ca;\n\tint r;\n\tint portnum;\n\n//\tif ( umad_init(  ) < 0 ) {\n//\t\tfprintf( stderr, \"can't init UMAD library\\n\" );\n//\t\texit( 1 );\n//\t}\n\n\tif ( ( n = (*umad_get_cas_namesPtr)( ( void * ) names, UMAD_CA_NAME_LEN ) ) < 0 ) {\n\t\tfprintf( stderr, \"can't list IB device names\\n\" );\n\t\texit( 1 );\n\t}\n\n\tfor ( i = 0; i < n; i++ ) {\n\t\tca_name = names[i];\n\n\t\tif ( ( r = (*umad_get_caPtr)( ca_name, &ca ) ) < 0 ) {\n\t\t\tfprintf( stderr, \"can't read ca from IB device\\n\" );\n\t\t\texit( 1 );\n\t\t}\n\n\t\tif ( !ca.node_type )\n\t\t\tcontinue;\n\n\t\t/* port numbers are '1' based in OFED */\n\t\tfor ( portnum = 1; portnum <= ca.numports; portnum++ )\n\t\t\taddIBPort( ca.ca_name, ca.ports[portnum] );\n\t}\n}\n\n\n/**\n * add a counter to the list of available counters\n * @param name the short name of the counter\n * @param desc a longer description\n * @param unit the unit for this counter\n */\nstatic counter_info *\naddCounter( const char *name, const char *desc, const char *unit )\n{\n\tcounter_info *cntr, *last;\n\n\tcntr = ( counter_info * ) malloc( sizeof ( counter_info ) );\n\tif ( cntr == NULL ) {\n\t\tfprintf( stderr, \"can not allocate memory for new counter\\n\" );\n\t\texit( 1 );\n\t}\n\tcntr->name = strdup( name );\n\tcntr->description = strdup( desc );\n\tcntr->unit = strdup( unit );\n\tcntr->value = 0;\n\tcntr->next = NULL;\n\n\tif ( root_counter == NULL ) {\n\t\troot_counter = cntr;\n\t} else {\n\t\tlast = root_counter;\n\t\twhile ( last->next != NULL )\n\t\t\tlast = last->next;\n\t\tlast->next = cntr;\n\t}\n\n\treturn cntr;\n}\n\n\n/**\n * add one IB port to the list of available ports and add the\n * counters related to this port to the global counter list\n */\nstatic void\naddIBPort( const char *ca_name, umad_port_t * port )\n{\n\tib_port *nwif, *last;\n\tchar counter_name[512];\n\n\tnwif = ( ib_port * ) malloc( sizeof ( ib_port ) );\n\n\tif ( nwif == NULL ) {\n\t\tfprintf( stderr, \"can not allocate memory for IB port description\\n\" );\n\t\texit( 1 );\n\t}\n\n\tsprintf( counter_name, \"%s_%d\", ca_name, port->portnum );\n\tnwif->name = strdup( counter_name );\n\n\tsprintf( counter_name, \"%s_%d_recv\", ca_name, port->portnum );\n\tnwif->recv_cntr =\n\t\taddCounter( counter_name, \"bytes received on this IB port\", \"bytes\" );\n\n\tsprintf( counter_name, \"%s_%d_send\", ca_name, port->portnum );\n\tnwif->send_cntr =\n\t\taddCounter( counter_name, \"bytes written to this IB port\", \"bytes\" );\n\n\tnwif->port_rate = port->rate;\n\tnwif->is_initialized = 0;\n\tnwif->port_number = port->portnum;\n\tnwif->next = NULL;\n\n\tnum_counters += 2;\n\n\tif ( root_ib_port == NULL ) {\n\t\troot_ib_port = nwif;\n\t} else {\n\t\tlast = root_ib_port;\n\t\twhile ( last->next != NULL )\n\t\t\tlast = last->next;\n\t\tlast->next = nwif;\n\t}\n}\n\n\n/**\n * initialize one IB port so that we are able to read values from it\n */\nstatic int\ninit_ib_port( ib_port * portdata )\n{\n\tint mgmt_classes[4] = { IB_SMI_CLASS, IB_SMI_DIRECT_CLASS, IB_SA_CLASS,\n\t\tIB_PERFORMANCE_CLASS\n\t};\n\tchar *ca = 0;\n\tstatic uint8_t pc[1024];\n\tint mask = 0xFFFF;\n\n\tsrcport = (*mad_rpc_open_portPtr)( ca, portdata->port_number, mgmt_classes, 4 );\n\tif ( !srcport ) {\n\t\tfprintf( stderr, \"Failed to open '%s' port '%d'\\n\", ca,\n\t\t\t\t portdata->port_number );\n\t\texit( 1 );\n\t}\n\n\tif ( (*ib_resolve_self_viaPtr)( &portid, &ibportnum, 0, srcport ) < 0 ) {\n\t\tfprintf( stderr, \"can't resolve self port\\n\" );\n\t\texit( 1 );\n\t}\n\n\t/* PerfMgt ClassPortInfo is a required attribute */\n\t/* might be redundant, could be left out for fast implementation */\n\tif ( !(*pma_query_viaPtr) ( pc, &portid, ibportnum, ib_timeout, CLASS_PORT_INFO, srcport ) ) {\n\t\tfprintf( stderr, \"classportinfo query\\n\" );\n\t\texit( 1 );\n\t}\n\n\tif ( !(*performance_reset_viaPtr) ( pc, &portid, ibportnum, mask, ib_timeout, IB_GSI_PORT_COUNTERS, srcport ) ) {\n\t\tfprintf( stderr, \"perf reset\\n\" );\n\t\texit( 1 );\n\t}\n\n\t/* read the initial values */\n\t(*mad_decode_fieldPtr)( pc, IB_PC_XMT_BYTES_F, &portdata->last_send_val );\n\tportdata->sum_send_val = 0;\n\t(*mad_decode_fieldPtr)( pc, IB_PC_RCV_BYTES_F, &portdata->last_recv_val );\n\tportdata->sum_recv_val = 0;\n\n\tportdata->is_initialized = 1;\n\n\treturn 0;\n}\n\n\n/**\n * read and reset IB counters (reset on demand)\n */\nstatic int\nread_ib_counter(  )\n{\n\tuint32_t send_val;\n\tuint32_t recv_val;\n\tuint8_t pc[1024];\n\t/* 32 bit counter FFFFFFFF */\n\tuint32_t max_val = 4294967295;\n\t/* if it is bigger than this -> reset */\n\tuint32_t reset_limit = max_val * 0.7;\n\tint mask = 0xFFFF;\n\n\tif ( active_ib_port == NULL )\n\t\treturn 0;\n\n\t/* reading cost ~70 mirco secs */\n\tif ( !(*pma_query_viaPtr) ( pc, &portid, ibportnum, ib_timeout, IB_GSI_PORT_COUNTERS, srcport ) ) {\n\t\tfprintf( stderr, \"perfquery\\n\" );\n\t\texit( 1 );\n\t}\n\n\t(*mad_decode_fieldPtr)( pc, IB_PC_XMT_BYTES_F, &send_val );\n\t(*mad_decode_fieldPtr)( pc, IB_PC_RCV_BYTES_F, &recv_val );\n\n\t/* multiply the numbers read by 4 as the IB port counters are not\n\t   counting bytes. they always count 32dwords. see man page of\n\t   perfquery for details\n\t   internally a uint64_t ia used to sum up the values */\n\tactive_ib_port->sum_send_val +=\n\t\t( send_val - active_ib_port->last_send_val ) * 4;\n\tactive_ib_port->sum_recv_val +=\n\t\t( recv_val - active_ib_port->last_recv_val ) * 4;\n\n\tactive_ib_port->send_cntr->value = active_ib_port->sum_send_val;\n\tactive_ib_port->recv_cntr->value = active_ib_port->sum_recv_val;\n\n\tif ( send_val > reset_limit || recv_val > reset_limit ) {\n\t\t/* reset cost ~70 mirco secs */\n\t\tif ( !(*performance_reset_viaPtr) ( pc, &portid, ibportnum, mask, ib_timeout, IB_GSI_PORT_COUNTERS, srcport ) ) {\n\t\t\tfprintf( stderr, \"perf reset\\n\" );\n\t\t\texit( 1 );\n\t\t}\n\n\t\t(*mad_decode_fieldPtr)( pc, IB_PC_XMT_BYTES_F, &active_ib_port->last_send_val );\n\t\t(*mad_decode_fieldPtr)( pc, IB_PC_RCV_BYTES_F, &active_ib_port->last_recv_val );\n\t} else {\n\t\tactive_ib_port->last_send_val = send_val;\n\t\tactive_ib_port->last_recv_val = recv_val;\n\t}\n\n\treturn 0;\n}\n\n\nvoid\nhost_read_values( long long *data )\n{\n\tint loop;\n\n\tread_ib_counter(  );\n\n\tfor ( loop = 0; loop < INFINIBAND_MAX_COUNTERS; loop++ ) {\n\t\tif ( subscriptions[loop] == NULL )\n\t\t\tbreak;\n\n\t\tdata[loop] = subscriptions[loop]->value;\n\t}\n}\n\n\n/**\n * find the pointer for a counter_info structure based on the counter name\n */\nstatic counter_info *\ncounterFromName( const char *cntr )\n{\n\tint loop = 0;\n\tchar tmp[512];\n\tcounter_info *local_cntr = root_counter;\n\n\twhile ( local_cntr != NULL ) {\n\t\tif ( strcmp( cntr, local_cntr->name ) == 0 )\n\t\t\treturn local_cntr;\n\n\t\tlocal_cntr = local_cntr->next;\n\t\tloop++;\n\t}\n\n\tgethostname( tmp, 512 );\n\tfprintf( stderr, \"can not find host counter: %s on %s\\n\", cntr, tmp );\n\tfprintf( stderr, \"we only have: \" );\n\tlocal_cntr = root_counter;\n\n\twhile ( local_cntr != NULL ) {\n\t\tfprintf( stderr, \"'%s' \", local_cntr->name );\n\t\tlocal_cntr = local_cntr->next;\n\t\tloop++;\n\t}\n\n\tfprintf( stderr, \"\\n\" );\n\texit( 1 );\n\t/* never reached */\n\treturn 0;\n}\n\n\n/**\n * allow external code to subscribe to a counter based on the counter name\n */\nstatic uint64_t\nhost_subscribe( const char *cntr )\n{\n\tint loop;\n\tint len;\n\tchar tmp_name[512];\n\tib_port *aktp;\n\n\tcounter_info *counter = counterFromName( cntr );\n\n\tfor ( loop = 0; loop < INFINIBAND_MAX_COUNTERS; loop++ ) {\n\t\tif ( subscriptions[loop] == NULL ) {\n\t\t\tsubscriptions[loop] = counter;\n\t\t\tcounter->idx = loop;\n\n\t\t\t/* we have an IB counter if the name ends with _send or _recv and\n\t\t\t   the prefix before that is in the ib_port list */\n\t\t\tif ( ( len = strlen( cntr ) ) > 5 ) {\n\t\t\t\tif ( strcmp( &cntr[len - 5], \"_recv\" ) == 0 ||\n\t\t\t\t\t strcmp( &cntr[len - 5], \"_send\" ) == 0 ) {\n\t\t\t\t\t/* look through all IB_counters */\n\t\t\t\t\tstrncpy( tmp_name, cntr, len - 5 );\n\t\t\t\t\ttmp_name[len - 5] = 0;\n\t\t\t\t\taktp = root_ib_port;\n\t\t\t\t\t// printf(\"looking for IB port '%s'\\n\", tmp_name);\n\t\t\t\t\twhile ( aktp != NULL ) {\n\t\t\t\t\t\tif ( strcmp( aktp->name, tmp_name ) == 0 ) {\n\t\t\t\t\t\t\tif ( !aktp->is_initialized ) {\n\t\t\t\t\t\t\t\tinit_ib_port( aktp );\n\t\t\t\t\t\t\t\tactive_ib_port = aktp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn loop + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* name does not match, if this counter is\n\t\t\t\t\t\t   initialized, we can't have two active IB ports */\n\t\t\t\t\t\tif ( aktp->is_initialized ) {\n#if 0\t/* not necessary with OFED version >= 1.4 */\n\t\t\t\t\t\t\tfprintf( stderr,\n\t\t\t\t\t\t\t\t\t \"unable to activate IB port monitoring for more than one port\\n\" );\n\t\t\t\t\t\t\texit( 1 );\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t\taktp = aktp->next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn loop + 1;\n\t\t}\n\t}\n\tfprintf( stderr, \"please subscribe only once to each counter\\n\" );\n\texit( 1 );\n\t/* never reached */\n\treturn 0;\n}\n\n\n/**\n * return a newly allocated list of strings containing all counter names\n */\nstatic string_list *\nhost_listCounter( int num_counters1 )\n{\n\tstring_list *list;\n\tcounter_info *cntr = root_counter;\n\n\tlist = malloc( sizeof ( string_list ) );\n\tif ( list == NULL ) {\n\t\tfprintf( stderr, \"unable to allocate memory for new string_list\" );\n\t\texit( 1 );\n\t}\n\tlist->count = 0;\n\tlist->data = ( char ** ) malloc( num_counters1 * sizeof ( char * ) );\n\n\tif ( list->data == NULL ) {\n\t\tfprintf( stderr,\n\t\t\t\t \"unable to allocate memory for %d pointers in a new string_list\\n\",\n\t\t\t\t num_counters1 );\n\t\texit( 1 );\n\t}\n\n\twhile ( cntr != NULL ) {\n\t\tlist->data[list->count++] = strdup( cntr->name );\n\t\tcntr = cntr->next;\n\t}\n\n\treturn list;\n}\n\n\n/**\n * finalizes the library\n */\nstatic void\nhost_finalize(  )\n{\n\tcounter_info *cntr, *next;\n\n\tif ( is_finalized )\n\t\treturn;\n\n\tcntr = root_counter;\n\n\twhile ( cntr != NULL ) {\n\t\tnext = cntr->next;\n\t\tfree( cntr->name );\n\t\tfree( cntr->description );\n\t\tfree( cntr->unit );\n\t\tfree( cntr );\n\t\tcntr = next;\n\t}\n\n\troot_counter = NULL;\n\n\tis_finalized = 1;\n}\n\n\n/**\n * delete a list of strings\n */\nstatic void\nhost_deleteStringList( string_list * to_delete )\n{\n\tint loop;\n\n\tif ( to_delete->data != NULL ) {\n\t\tfor ( loop = 0; loop < to_delete->count; loop++ )\n\t\t\tfree( to_delete->data[loop] );\n\n\t\tfree( to_delete->data );\n\t}\n\n\tfree( to_delete );\n}\n\n\n/*****************************************************************************\n *******************  BEGIN PAPI's COMPONENT REQUIRED FUNCTIONS  *************\n *****************************************************************************/\n\n/*\n * This is called whenever a thread is initialized\n */\nint\nINFINIBAND_init_thread( hwd_context_t * ctx )\n{\n\tstring_list *counter_list = NULL;\n\tint i;\n\tint loop;\n\n\t/* initialize portid struct of type ib_portid_t to 0 */\n\tInitStruct( portid, ib_portid_t );\n\n\tif ( is_initialized )\n\t\treturn PAPI_OK;\n\n\tis_initialized = 1;\n\n\tinit_ib_counter(  );\n\n\tfor ( loop = 0; loop < INFINIBAND_MAX_COUNTERS; loop++ )\n\t\tsubscriptions[loop] = NULL;\n\n\tcounter_list = host_listCounter( num_counters );\n\n\tfor ( i = 0; i < counter_list->count; i++ )\n\t\thost_subscribe( counter_list->data[i] );\n\n\t( ( INFINIBAND_context_t * ) ctx )->state.ncounter = counter_list->count;\n\n\thost_deleteStringList( counter_list );\n\n\treturn PAPI_OK;\n}\n\n\n/* Initialize hardware counters, setup the function vector table\n * and get hardware information, this routine is called when the \n * PAPI process is initialized (IE PAPI_library_init)\n */\nint\nINFINIBAND_init_component( int cidx )\n{\n\tSUBDBG (\"Entry: cidx: %d\\n\", cidx);\n\tint i;\n\n\t/* link in all the infiniband libraries and resolve the symbols we need to use */\n\tif (linkInfinibandLibraries() != PAPI_OK) {\n\t\tSUBDBG (\"Dynamic link of Infiniband libraries failed, component will be disabled.\\n\");\n\t\tSUBDBG (\"See disable reason in papi_component_avail output for more details.\\n\");\n\t\treturn (PAPI_ENOSUPP);\n\t}\n\n\t/* make sure that the infiniband library finds the kernel module loaded. */\n\tif ( (*umad_initPtr)(  ) < 0 ) {\n\t\tstrncpy(_infiniband_vector.cmp_info.disabled_reason, \"Call to initialize umad library failed.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\tfor ( i = 0; i < INFINIBAND_MAX_COUNTERS; i++ ) {\n\t\t_papi_hwd_infiniband_register_start[i] = -1;\n\t\t_papi_hwd_infiniband_register[i] = -1;\n\t}\n\n\t/* Export the component id */\n\t_infiniband_vector.cmp_info.CmpIdx = cidx;\n\n\treturn ( PAPI_OK );\n}\n\n\n/*\n * Link the necessary Infiniband libraries to use the Infiniband component.  If any of them can not be found, then\n * the Infiniband component will just be disabled.  This is done at runtime so that a version of PAPI built\n * with the Infiniband component can be installed and used on systems which have the Infiniband libraries installed\n * and on systems where these libraries are not installed.\n */\nstatic int\nlinkInfinibandLibraries ()\n{\n\t/* Attempt to guess if we were statically linked to libc, if so bail */\n\tif ( _dl_non_dynamic_init != NULL ) {\n\t\tstrncpy(_infiniband_vector.cmp_info.disabled_reason, \"The Infiniband component does not support statically linking of libc.\", PAPI_MAX_STR_LEN);\n\t\treturn PAPI_ENOSUPP;\n\t}\n\n\t/* Need to link in the Infiniband libraries, if not found disable the component */\n\tdl1 = dlopen(\"libibumad.so\", RTLD_NOW | RTLD_GLOBAL);\n\tif (!dl1)\n\t{\n\t\tstrncpy(_infiniband_vector.cmp_info.disabled_reason, \"Infiniband library libibumad.so not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tumad_initPtr = dlsym(dl1, \"umad_init\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_vector.cmp_info.disabled_reason, \"Infiniband function umad_init not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tumad_get_cas_namesPtr = dlsym(dl1, \"umad_get_cas_names\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_vector.cmp_info.disabled_reason, \"Infiniband function umad_get_cas_names not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tumad_get_caPtr = dlsym(dl1, \"umad_get_ca\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_vector.cmp_info.disabled_reason, \"Infiniband function umad_get_ca not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\t/* Need to link in the Infiniband libraries, if not found disable the component */\n\tdl2 = dlopen(\"libibmad.so\", RTLD_NOW | RTLD_GLOBAL);\n\tif (!dl2)\n\t{\n\t\tstrncpy(_infiniband_vector.cmp_info.disabled_reason, \"Infiniband library libibmad.so not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tmad_decode_fieldPtr = dlsym(dl2, \"mad_decode_field\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_vector.cmp_info.disabled_reason, \"Infiniband function mad_decode_field not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tmad_rpc_open_portPtr = dlsym(dl2, \"mad_rpc_open_port\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_vector.cmp_info.disabled_reason, \"Infiniband function mad_rpc_open_port not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tib_resolve_self_viaPtr = dlsym(dl2, \"ib_resolve_self_via\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_vector.cmp_info.disabled_reason, \"Infiniband function ib_resolve_self_via not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tperformance_reset_viaPtr = dlsym(dl2, \"performance_reset_via\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_vector.cmp_info.disabled_reason, \"Infiniband function performance_reset_via not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tpma_query_viaPtr = dlsym(dl2, \"pma_query_via\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_vector.cmp_info.disabled_reason, \"Infiniband function pma_query_via not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\treturn ( PAPI_OK );\n}\n\n\n/*\n * Control of counters (Reading/Writing/Starting/Stopping/Setup)\n * functions\n */\nint\nINFINIBAND_init_control_state( hwd_control_state_t * ctrl )\n{\n\t( void ) ctrl;\n\treturn PAPI_OK;\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_start( hwd_context_t * ctx, hwd_control_state_t * ctrl )\n{\n\t( void ) ctx;\n\t( void ) ctrl;\n\n\thost_read_values( _papi_hwd_infiniband_register_start );\n\n\tmemcpy( _papi_hwd_infiniband_register, _papi_hwd_infiniband_register_start,\n\t\t\tINFINIBAND_MAX_COUNTERS * sizeof ( long long ) );\n\n\treturn ( PAPI_OK );\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_stop( hwd_context_t * ctx, hwd_control_state_t * ctrl )\n{\n\tint i;\n\t( void ) ctx;\n\n\thost_read_values( _papi_hwd_infiniband_register );\n\n\tfor ( i = 0; i < ( ( INFINIBAND_context_t * ) ctx )->state.ncounter; i++ ) {\n\t\t( ( INFINIBAND_control_state_t * ) ctrl )->counts[i] =\n\t\t\t_papi_hwd_infiniband_register[i] -\n\t\t\t_papi_hwd_infiniband_register_start[i];\n\t}\n\n\treturn ( PAPI_OK );\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_read( hwd_context_t * ctx, hwd_control_state_t * ctrl,\n\t\t\t\t long_long ** events, int flags )\n{\n\tint i;\n\t( void ) flags;\n\n\thost_read_values( _papi_hwd_infiniband_register );\n\n\tfor ( i = 0; i < ( ( INFINIBAND_context_t * ) ctx )->state.ncounter; i++ ) {\n\t\t( ( INFINIBAND_control_state_t * ) ctrl )->counts[i] =\n\t\t\t_papi_hwd_infiniband_register[i] -\n\t\t\t_papi_hwd_infiniband_register_start[i];\n\t}\n\n\t*events = ( ( INFINIBAND_control_state_t * ) ctrl )->counts;\n\treturn ( PAPI_OK );\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_shutdown_thread( hwd_context_t * ctx )\n{\n\t( void ) ctx;\n\thost_finalize(  );\n\treturn ( PAPI_OK );\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_shutdown_component( void )\n{\n\t// close the dynamic libraries needed by this component (opened in the init substrate call)\n\tdlclose(dl1);\n\tdlclose(dl2);\n\n\treturn ( PAPI_OK );\n}\n\n\n/* This function sets various options in the component\n * The valid codes being passed in are PAPI_SET_DEFDOM,\n * PAPI_SET_DOMAIN, PAPI_SETDEFGRN, PAPI_SET_GRANUL * and PAPI_SET_INHERIT\n */\nint\nINFINIBAND_ctl( hwd_context_t * ctx, int code, _papi_int_option_t * option )\n{\n\t( void ) ctx;\n\t( void ) code;\n\t( void ) option;\n\treturn ( PAPI_OK );\n}\n\n\n//int INFINIBAND_ntv_code_to_bits ( unsigned int EventCode, hwd_register_t * bits );\n\n\n/*\n *\n */\nint\nINFINIBAND_update_control_state( hwd_control_state_t * ptr,\n\t\t\t\t\t\t\t\t NativeInfo_t * native, int count,\n\t\t\t\t\t\t\t\t hwd_context_t * ctx )\n{\n\t( void ) ptr;\n\t( void ) ctx;\n\tint i, index;\n\n\tfor ( i = 0; i < count; i++ ) {\n\t\tindex = native[i].ni_event;\n\t\tnative[i].ni_position = index;\n\t}\n\n\treturn ( PAPI_OK );\n}\n\n\n/*\n * Infiniband counts are system wide, so this is the only domain we will respond to\n */\nint\nINFINIBAND_set_domain( hwd_control_state_t * cntrl, int domain )\n{\n\t(void) cntrl;\n\tif ( PAPI_DOM_ALL != domain )\n\t\treturn ( PAPI_EINVAL );\n\n\treturn ( PAPI_OK );\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_reset( hwd_context_t * ctx, hwd_control_state_t * ctrl )\n{\n\tINFINIBAND_start( ctx, ctrl );\n\treturn ( PAPI_OK );\n}\n\n\n/*\n * Native Event functions\n */\nint\nINFINIBAND_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n\tif ( modifier == PAPI_ENUM_FIRST ) {\n\t\t*EventCode = 0;\n\t\treturn PAPI_OK;\n\t}\n\n\tif ( modifier == PAPI_ENUM_EVENTS ) {\n\t\tint index = *EventCode;\n\n\t\tif ( infiniband_native_table[index + 1] ) {\n\t\t\t*EventCode = *EventCode + 1;\n\t\t\treturn ( PAPI_OK );\n\t\t} else\n\t\t\treturn ( PAPI_ENOEVNT );\n\t} else\n\t\treturn ( PAPI_EINVAL );\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n\tstrncpy( name, infiniband_native_table[EventCode]->name, len );\n\n\treturn PAPI_OK;\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_ntv_code_to_descr( unsigned int EventCode, char *name, int len )\n{\n\tstrncpy( name, infiniband_native_table[EventCode]->description, len );\n\n\treturn PAPI_OK;\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_ntv_code_to_bits( unsigned int EventCode, hwd_register_t * bits )\n{\n\tmemcpy( ( INFINIBAND_register_t * ) bits,\n\t\t\tinfiniband_native_table[EventCode],\n\t\t\tsizeof ( INFINIBAND_register_t ) );\n\n\treturn PAPI_OK;\n}\n\n\n/*\n *\n */\npapi_vector_t _infiniband_vector = {\n\t.cmp_info = {\n\t\t\t\t /* default component information (unspecified values are initialized to 0) */\n\t\t\t\t .name =\"infiniband\",\n\t\t\t\t .short_name=\"infiniband\",\n\t\t\t\t .version = \"4.2.1\",\n\t\t\t\t .description = \"Infiniband statistics\",\n\t\t\t\t .num_mpx_cntrs = INFINIBAND_MAX_COUNTERS,\n\t\t\t\t .num_cntrs = INFINIBAND_MAX_COUNTERS,\n\t\t\t\t .default_domain = PAPI_DOM_ALL,\n\t\t\t\t .available_domains = PAPI_DOM_ALL,\n\t\t\t\t .default_granularity = PAPI_GRN_SYS,\n\t\t\t\t .available_granularities = PAPI_GRN_SYS,\n\t\t\t\t .hardware_intr_sig = PAPI_INT_SIGNAL,\n\n\t\t\t\t /* component specific cmp_info initializations */\n\t\t\t\t .fast_real_timer = 0,\n\t\t\t\t .fast_virtual_timer = 0,\n\t\t\t\t .attach = 0,\n\t\t\t\t .attach_must_ptrace = 0,\n\t\t\t\t }\n\t,\n\n\t/* sizes of framework-opaque component-private structures */\n\t.size = {\n\t\t\t .context = sizeof ( INFINIBAND_context_t ),\n\t\t\t .control_state = sizeof ( INFINIBAND_control_state_t ),\n\t\t\t .reg_value = sizeof ( INFINIBAND_register_t ),\n\t\t\t .reg_alloc = sizeof ( INFINIBAND_reg_alloc_t ),\n\t\t\t }\n\t,\n\t/* function pointers in this component */\n\t.init_thread = INFINIBAND_init_thread,\n\t.init_component = INFINIBAND_init_component,\n\t.init_control_state = INFINIBAND_init_control_state,\n\t.start = INFINIBAND_start,\n\t.stop = INFINIBAND_stop,\n\t.read = INFINIBAND_read,\n\t.shutdown_component = INFINIBAND_shutdown_component,\n\t.shutdown_thread = INFINIBAND_shutdown_thread,\n\t.ctl = INFINIBAND_ctl,\n\n\t.update_control_state = INFINIBAND_update_control_state,\n\t.set_domain = INFINIBAND_set_domain,\n\t.reset = INFINIBAND_reset,\n\n\t.ntv_enum_events = INFINIBAND_ntv_enum_events,\n\t.ntv_code_to_name = INFINIBAND_ntv_code_to_name,\n\t.ntv_code_to_descr = INFINIBAND_ntv_code_to_descr,\n\t.ntv_code_to_bits = INFINIBAND_ntv_code_to_bits,\n};\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/ChangeLogP421.txt",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/x86_cpuid_info.c",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/sw_multiplex.c",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/libpfm-3.y/lib/intel_corei7_events.h",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/ctests/bgp/papi_1.c",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.7.x/linux/drivers/perfctr/virtual.c",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.11",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.14-rc5-mm1",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.16.21-SLES10",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.12-rc1",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.14",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.14-mm1",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.12-rc2",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.16",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.12-rc5",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/components/vmware/PAPI-VMwareComponentDocument.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/components/cuda/sampling/test/sass_source_map.cubin",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.6.x/linux/drivers/perfctr/virtual.c",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.11",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.15",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.13",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.12",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.14",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.10",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.16",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.5.1-42zspotumf2fh42ed4rzyvnvywexp6gx/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.16.46-0.12-suse"
    ],
    "total_files": 1700
}