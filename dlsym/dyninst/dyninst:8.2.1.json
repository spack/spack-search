{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/common/src/serialize-xml.C": "/*\n * See the dyninst/COPYRIGHT file for copyright information.\n * \n * We provide the Paradyn Tools (below described as \"Paradyn\")\n * on an AS IS basis, and do not warrant its validity or performance.\n * We reserve the right to update, modify, or discontinue this\n * software at any time.  We shall have no obligation to supply such\n * updates or modifications or any other form of support to you.\n * \n * By your use of Paradyn, you understand and agree that we (or any\n * other person or entity with proprietary rights in Paradyn) are\n * under no obligation to provide either maintenance services,\n * update services, notices of latent defects, or correction of\n * defects for Paradyn.\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"common/src/serialize.h\"\n\n#if !defined(SERIALIZATION_DISABLED)\n\n#if !defined(os_windows)\n#include \"common/src/pathName.h\"\n#include <dlfcn.h>\n#if defined (cap_have_libxml)\n//libxml2 functions\nvoid *hXML;\n#endif\n#else\n#include \"windows.h\"\n#if defined (cap_have_libxml)\n#include <libxml/xmlversion.h>\n#undef LIBXML_ICONV_ENABLED\nHINSTANCE hXML;\n#endif\n#endif\n\n#if defined (cap_have_libxml)\n#if defined (os_linux)\n//  gcc is complaining about the constness of the library-provided\n//  typecast (BAD_CAST) (which is defined in xmlstring.h), so we make our own\n#define XMLCHAR_CAST (const xmlChar *)\n#else\n#define XMLCHAR_CAST BAD_CAST\n#endif\n\n#else\n#define XMLCHAR_CAST (const char *)\n#endif\n\n#if 0\nSerDesXML &SerializerXML::getSD_xml()\n{\n   SerDes &sd = getSD();\n   SerDesXML *sdxml = dynamic_cast<SerDesXML *> (&sd);\n   assert(sdxml);\n   return *sdxml;\n}\n#endif\n\n\n#if 0\nbool end_xml_element(SerializerBase *, const char *);\n#endif\n\n\n\n// DLLEXPORT SerDesXML(xmlTextWriterPtr w, iomode_t mode)  : SerDes(mode), writer(w) { }\n// DLLEXPORT static xmlTextWriterPtr init(std::string fname, iomode_t mode, bool verbose);\n\n#if defined (cap_have_libxml)\nxmlTextWriterPtr(*my_xmlNewTextWriterFilename)(const char *,int) = NULL;\n\nint (*my_xmlTextWriterStartDocument)(xmlTextWriterPtr, \n      const char *, const char *, const char * ) = NULL;\n\nint (*my_xmlTextWriterStartElement)(xmlTextWriterPtr, \n      const xmlChar *) = NULL;\n\nint (*my_xmlTextWriterWriteFormatElement)(xmlTextWriterPtr,\n      const xmlChar *,const char *,...) = NULL;\n\nint (*my_xmlTextWriterEndDocument)(xmlTextWriterPtr) = NULL;\n\nvoid (*my_xmlFreeTextWriter)(xmlTextWriterPtr) = NULL;\n\nint (*my_xmlTextWriterWriteFormatAttribute)(xmlTextWriterPtr, \n      const xmlChar *,const char *,...) = NULL;\n\nint (*my_xmlTextWriterEndElement)(xmlTextWriterPtr) = NULL;\n\nxmlTextWriterPtr SerDesXML::init(std::string fname, iomode_t /*mode*/, bool /*verbose*/) \n{\n#if defined(_MSC_VER)\n   hXML = LoadLibrary(LPCSTR(\"../../../i386-unknown-nt4.0/lib/libxml2.dll\"));\n   if (hXML == NULL)\n   {\n      char buf[1000];\n      DWORD result = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        buf, 1000, NULL);\n      SER_ERR(buf);\n   }\n\n    my_xmlNewTextWriterFilename = \n       (xmlTextWriterPtr (*)(const char *,int)) GetProcAddress(hXML,\"xmlNewTextWriterFilename\");\n    \n    my_xmlTextWriterStartDocument = \n       (int (*)(xmlTextWriterPtr, const char *, const char *, const char * ))GetProcAddress(hXML,\"xmlTextWriterStartDocument\");\n    \n    my_xmlTextWriterStartElement = \n       (int (*)(xmlTextWriterPtr, const xmlChar *))GetProcAddress(hXML,\"xmlTextWriterStartElement\");\n\n    my_xmlTextWriterWriteFormatElement = \n       (int (*)(xmlTextWriterPtr,const xmlChar *,const char *,...))GetProcAddress(hXML,\"xmlTextWriterWriteFormatElement\");\n\n    my_xmlTextWriterEndDocument = \n       (int (*)(xmlTextWriterPtr))GetProcAddress(hXML,\"xmlTextWriterEndDocument\");\n\n    my_xmlFreeTextWriter = \n       (void (*)(xmlTextWriterPtr))GetProcAddress(hXML,\"xmlFreeTextWriter\");\n\n    my_xmlTextWriterWriteFormatAttribute = \n       (int (*)(xmlTextWriterPtr, const xmlChar *,const char *,...))GetProcAddress(hXML,\"xmlTextWriterWriteFormatAttribute\");\n    \n    my_xmlTextWriterEndElement = \n       (int (*)(xmlTextWriterPtr))GetProcAddress(hXML,\"xmlTextWriterEndElement\");\n\n#else\n\n    hXML = dlopen(\"libxml2.so\", RTLD_LAZY);\n\n    if (hXML == NULL)\n    {\n      SER_ERR(\"Unable to find libxml2\");\n      return NULL;\n    }\n\n    my_xmlNewTextWriterFilename = (xmlTextWriterPtr(*)(const char *,int))dlsym(hXML,\"xmlNewTextWriterFilename\");\n    my_xmlTextWriterStartDocument = (int(*)(xmlTextWriterPtr, const char *, const char *, const char * ))dlsym(hXML,\"xmlTextWriterStartDocument\");\n    my_xmlTextWriterStartElement = (int(*)(xmlTextWriterPtr, const xmlChar *))dlsym(hXML,\"xmlTextWriterStartElement\");\n    my_xmlTextWriterWriteFormatElement = (int(*)(xmlTextWriterPtr,const xmlChar *,const char *,...))dlsym(hXML,\"xmlTextWriterWriteFormatElement\");\n    my_xmlTextWriterEndDocument = (int(*)(xmlTextWriterPtr))dlsym(hXML,\"xmlTextWriterEndDocument\");\n    my_xmlFreeTextWriter = (void(*)(xmlTextWriterPtr))dlsym(hXML,\"xmlFreeTextWriter\");\n    my_xmlTextWriterWriteFormatAttribute = (int(*)(xmlTextWriterPtr, const xmlChar *,const char *,...))dlsym(hXML,\"xmlTextWriterWriteFormatAttribute\");\n    my_xmlTextWriterEndElement = (int(*)(xmlTextWriterPtr))dlsym(hXML,\"xmlTextWriterEndElement\");\n\n#endif\n\n    /* Create a new XmlWriter for DOM */\n\n    xmlTextWriterPtr writer = my_xmlNewTextWriterFilename(fname.c_str(), 0);\n\n    if (writer == NULL) \n    {\n        SER_ERR(\"testXmlwriterDoc: Error creating the xml writer\");\n      return NULL;\n    }\n\n    int rc = my_xmlTextWriterStartDocument(writer, NULL, \"ISO-8859-1\", NULL);\n\n    if (rc < 0) \n    {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartDocument\");\n    return NULL;\n    }\n\n    return writer;\n}\n\n#endif // defined (cap_have_libxml)\n\n\nnamespace Dyninst {\n#if defined (cap_have_libxml)\n//int (*my_xmlTextWriterStartElement)(xmlTextWriterPtr, \n//      const xmlChar *) = NULL;\nbool start_xml_elem(void *writer, const char *tag)\n{\n    int rc = my_xmlTextWriterStartElement((xmlTextWriterPtr) writer, XMLCHAR_CAST tag);\n    return (rc >= 0);\n}\n//    my_xmlTextWriterEndElement(writer);\n\nbool end_xml_elem(void *writer)\n{\n    int rc = my_xmlTextWriterEndElement((xmlTextWriterPtr) writer);\n    return (rc >= 0);\n}\n\nbool write_xml_elem(void *writer, const char *tag, const char *fmt, ...)\n{\n   va_list ap;\n   va_start(ap, fmt);\n\n   int rc = my_xmlTextWriterWriteFormatElement((xmlTextWriterPtr) writer, XMLCHAR_CAST tag, fmt, ap);\n\n   if (rc < 0) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n   va_end(ap);\n\n   return (rc >= 0);\n}\n#else\n\nbool start_xml_elem(void * /*writer*/, const char * /*xmlChar*/)\n{\n   fprintf(stderr, \"%s[%d]:  xml output is disabled\\n\", FILE__, __LINE__);\n   return false;\n}\n\nbool end_xml_elem(void * /*writer*/)\n{\n   fprintf(stderr, \"%s[%d]:  xml output is disabled\\n\", FILE__, __LINE__);\n   return false;\n}\n\nbool write_xml_elem(void * /*writer*/, const char * /*tag*/, const char * /*fmt*/, ...)\n{\n   fprintf(stderr, \"%s[%d]:  xml output is disabled\\n\", FILE__, __LINE__);\n   return false;\n}\n#endif\n}\n\nnamespace Dyninst {\nbool start_xml_elem(SerDesXML &s, const char *tag)\n{\n\treturn start_xml_elem(s.writer, tag);\n}\nbool end_xml_elem(SerDesXML &s)\n{\n\treturn end_xml_elem(s.writer);\n}\n}\n\nnamespace Dyninst {\nbool ifxml_start_element(SerializerBase *sb, const char *tag)\n{\n#if 0\n   SerializerXML *sxml = dynamic_cast<SerializerXML *>(sb);\n   if (!sxml) \n   {\n      return false;\n   }\n\n   if (sxml->iomode() == sd_deserialize) \n   {\n      fprintf(stderr, \"%s[%d]:  ERROR:  request to deserialize xml\\n\", FILE__, __LINE__);\n      return false;\n   }\n#endif\n   if (!sb->isXML())\n\t   return false;\n   if (!sb->isOutput())\n   {\n      fprintf(stderr, \"%s[%d]:  ERROR:  request to deserialize xml\\n\", FILE__, __LINE__);\n      return false;\n   }\n\n   SerDes &sd = sb->getSD();\n   SerDesXML *sdxml = dynamic_cast<SerDesXML *>(&sd);\n   assert(sdxml);\n   ::start_xml_elem(sdxml->writer, tag);\n\n#if 0\n   sxml->getSD_xml().start_element(tag);\n#endif\n\n   return true;\n}\n}\n\nnamespace Dyninst {\nCOMMON_EXPORT bool ifxml_end_element(SerializerBase *sb, const char * /*tag*/)\n{\n#if 0\n   SerializerXML *sxml = dynamic_cast<SerializerXML *>(sb);\n\n   if (!sxml) \n   {\n      return false;\n   }\n\n   if (sxml->iomode() == sd_deserialize) \n   {\n      fprintf(stderr, \"%s[%d]:  ERROR:  request to deserialize xml\\n\", FILE__, __LINE__);\n      return false;\n   }\n#endif\n   if (!sb->isXML())\n\t   return false;\n   if (!sb->isOutput())\n   {\n      fprintf(stderr, \"%s[%d]:  ERROR:  request to deserialize xml\\n\", FILE__, __LINE__);\n      return false;\n   }\n\n   SerDes &sd = sb->getSD();\n   SerDesXML *sdxml = dynamic_cast<SerDesXML *>(&sd);\n   assert(sdxml);\n   ::end_xml_elem(sdxml->writer);\n   \n#if 0\n   sxml->getSD_xml().end_element();\n#endif\n\n   return true;\n}\n}\n\nbool SerializerXML::start_xml_element(SerializerBase *sb, const char *tag)\n{\n\tSerializerXML *sxml = dynamic_cast<SerializerXML *>(sb);\n\n\tif (!sxml)\n\t{\n\t\tfprintf(stderr, \"%s[%d]:  FIXME:  called xml function with non xml serializer\\n\",\n\t\t\t\tFILE__, __LINE__);\n\t\treturn false;\n\t}\n\n\tSerDesXML sdxml = sxml->getSD_xml();\n\tstart_xml_elem(sdxml, tag);\n\treturn true;\n\n}\n#if 0\nbool SerializerXML::start_xml_element(SerializerBase *sb, const char *tag)\n{\n\tSerializerXML *sxml = dynamic_cast<SerializerXML *>(sb);\n\n\tif (!sxml) \n\t{\n      fprintf(stderr, \"%s[%d]:  FIXME:  called xml function with non xml serializer\\n\", \n            FILE__, __LINE__);\n      return false;\n   }\n\n   SerDesXML sdxml = sxml->getSD_xml();\n   start_xml_elem(sdxml.writer, tag);\n\n#if 0\n   sdxml.start_element(tag); \n#endif\n\n   return true;\n}\n#endif\n\nSerDesXML &SerializerXML::getSD_xml()\n{\n\tSerializerBase *sb = this;\n\tSerDes &sd = sb->getSD();\n\tSerDesXML *sdxml = dynamic_cast<SerDesXML *> (&sd);\n\tassert(sdxml);\n\treturn *sdxml;\n}\n\nbool SerializerXML::end_xml_element(SerializerBase * sb, const char  * /*tag*/)\n{\n   SerializerXML *sxml = dynamic_cast<SerializerXML *>(sb);\n\n   if (!sxml) \n   {\n      fprintf(stderr, \"%s[%d]:  FIXME:  called xml function with non xml serializer\\n\", \n            FILE__, __LINE__);\n      return false;\n   }\n\n   SerDesXML sdxml = sxml->getSD_xml();\n   end_xml_elem(sdxml);\n\n#if 0\n   sdxml.end_element(); \n#endif\n   return true;\n}\n\nSerDesXML::~SerDesXML()\n{\n#if defined (cap_have_libxml)\n    my_xmlFreeTextWriter(writer);\n#endif\n\n}\n\nvoid SerDesXML::vector_start(unsigned long &/*size*/, const char *tag) DECLTHROW(SerializerError)\n{\n   bool rc = ::start_xml_elem(writer, tag);\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterStartElement(writer, XMLCHAR_CAST tag);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::vector_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterEndElement(writer);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::multimap_start(unsigned long &/*size*/, const char *tag) DECLTHROW(SerializerError)\n{\n   bool rc = ::start_xml_elem(writer, tag);\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n#if 0\n    int rc = my_xmlTextWriterStartElement(writer, XMLCHAR_CAST tag);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::multimap_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterEndElement(writer);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::pair_start(const char *tag) DECLTHROW(SerializerError)\n{\n   bool rc = ::start_xml_elem(writer, tag);\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n#if 0\n    int rc = my_xmlTextWriterStartElement(writer, XMLCHAR_CAST tag);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::pair_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterEndElement(writer);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\nvoid SerDesXML::hash_map_start(unsigned long &/*size*/, const char *tag) DECLTHROW(SerializerError)\n{\n   bool rc = ::start_xml_elem(writer,  tag);\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n#if 0\n    int rc = my_xmlTextWriterStartElement(writer, XMLCHAR_CAST tag);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::hash_map_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterEndElement(writer);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::annotation_start(Dyninst::AnnotationClassID &a_id, void *& parent_id, sparse_or_dense_anno_t &sod, const char * /*id*/, const char * tag) \n{\n   bool rc = ::start_xml_elem(writer, tag);\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n   translate(a_id, \"annotationID\");\n   translate((Address &)parent_id, \"annotatableID\");\n   translate((int &) sod, \"SparseOrDense\");\n   //char sodstr[12];\n   //sprintf(sodstr, \"%s\", sod == sparse ? \"sparse\" : \"dense\");\n   //const char *sodstr = (sod == sparse) ? \"sparse\" : \"dense\";\n   //translate((const char *&)const_cast<const char *>(sodstr), 12, \"SparseOrDense\");\n}\n\nvoid SerDesXML::annotation_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n}\n\nvoid SerDesXML::annotation_container_start(void *& id) \n{\n   bool rc = ::start_xml_elem(writer, \"AnnotationContainer\");\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n   translate((Address &)id, \"containerID\");\n}\n\nvoid SerDesXML::annotation_container_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n}\n\nvoid SerDesXML::annotation_container_item_start(void *& id) \n{\n   bool rc = ::start_xml_elem(writer, \"AnnotationContainerItem\");\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n   translate((Address &)id, \"containerID\");\n}\n\nvoid SerDesXML::annotation_container_item_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n}\nvoid SerDesXML::annotation_list_start(Address &/*id*/, unsigned long &/*nelem*/, const char * tag) \n{\n   bool rc = ::start_xml_elem(writer, tag);\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n}\n\nvoid SerDesXML::annotation_list_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n}\nvoid SerDesXML::translate(bool &param, const char *tag)\n{       \n   bool rc = write_xml_elem(writer, tag,\n         \"%s\", param ? \"true\" : \"false\");\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                \"%s\", param ? \"true\" : \"false\");\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n    \n}     \n\nvoid SerDesXML::translate(char &param, const char *tag)\n{       \n   bool rc = write_xml_elem(writer, tag,\n         \"%c\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                \"%c\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n    \n}     \n\nvoid SerDesXML::translate(int &param, const char *tag)\n{   \n   bool rc = write_xml_elem(writer, tag,\n         \"%d\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n    \n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%d\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(long &param, const char *tag)\n{   \n   bool rc = write_xml_elem(writer, tag,\n         \"%l\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n    \n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%l\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(short &param, const char *tag)\n{   \n   bool rc = write_xml_elem(writer, tag,\n         \"%h\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n    \n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%h\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(unsigned short &param, const char *tag)\n{   \n   bool rc = write_xml_elem(writer, tag,\n         \"%h\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n    \n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%h\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\nvoid SerDesXML::translate(unsigned int &param, const char *tag)\n{   \n  translate( param, tag);\n}\n\n#if 0\nvoid SerDesXML::translate(OFFSET &param, const char *tag)\n{\n\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%lx\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n}\n#endif\n\nvoid SerDesXML::translate(float &param, const char *tag)\n{\n   bool rc = write_xml_elem(writer, tag,\n         \"%e\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%e\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(double &param, const char *tag)\n{\n   bool rc = write_xml_elem(writer, tag,\n         \"%g\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%g\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(Address &param, const char *tag)\n{\n   bool rc = write_xml_elem(writer, tag,\n         \"%p\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%p\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(void * &param, const char *tag)\n{\n   bool rc = write_xml_elem(writer, tag,\n         \"%p\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%p\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\nvoid SerDesXML::translate(const char * &param, int /*bufsize*/, const char *tag)\n{\n   bool rc = write_xml_elem(writer, tag,\n         \"%s\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%s\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(char * &param, int /*bufsize*/, const char *tag)\n{\n   bool rc = write_xml_elem(writer, tag,\n         \"%s\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%s\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(std::string &param, const char *tag)\n{\n   assert(tag);\n   assert(param.c_str());\n\n   bool rc = write_xml_elem(writer, tag,\n         \"%s\", param.c_str());\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%s\", param.c_str());\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\n#if 0\nvoid SerDesXML::translate(pdstring &param, const char *tag)\n{\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%s\", param.c_str());\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n}\n#endif\n\nvoid SerDesXML::translate(std::vector<std::string> &param, const char *tag,\n                          const char *elem_tag)\n{\n   bool rc = ::start_xml_elem(writer, tag);\n   if (!rc)\n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterStartElement(writer, XMLCHAR_CAST tag) ;\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n\n    for (unsigned int i = 0; i < param.size(); ++i) \n      translate(param[i], elem_tag);\n    \n\n   rc = ::end_xml_elem(writer);\n   if (!rc)\n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterEndElement\");\n   }\n\n#if 0\n    rc = my_xmlTextWriterEndElement(writer);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\n#if 0\nvoid SerDesXML::start_element(const char *tag)\n{\n   int rc = my_xmlTextWriterStartElement(writer, XMLCHAR_CAST tag) ;\n   if (rc < 0) {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n}\n\nvoid SerDesXML::end_element()\n{\n   int rc = my_xmlTextWriterEndElement(writer);\n   if (rc < 0) {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n}\n\nvoid SerDesXML::xml_value(const char *s, const char *tag)\n{\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%s\", s);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n}\n#endif\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/proccontrol/src/int_thread_db.C": "/*\n * See the dyninst/COPYRIGHT file for copyright information.\n * \n * We provide the Paradyn Tools (below described as \"Paradyn\")\n * on an AS IS basis, and do not warrant its validity or performance.\n * We reserve the right to update, modify, or discontinue this\n * software at any time.  We shall have no obligation to supply such\n * updates or modifications or any other form of support to you.\n * \n * By your use of Paradyn, you understand and agree that we (or any\n * other person or entity with proprietary rights in Paradyn) are\n * under no obligation to provide either maintenance services,\n * update services, notices of latent defects, or correction of\n * defects for Paradyn.\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"common/src/Types.h\"\n#include \"proccontrol/src/int_thread_db.h\"\n\n\n#include <cassert>\n#include <cerrno>\n#include <cstdarg>\n#include <cstring>\n#include <set>\n#include <dlfcn.h>\n#include <iostream>\n\n#include \"common/src/dthread.h\"\n#include \"common/h/SymReader.h\"\n#include \"proccontrol/src/int_event.h\"\n#include \"proccontrol/h/Mailbox.h\"\n\nusing namespace std;\n\n#if defined(cap_thread_db)\n\n/* \n * proc_service interface implementation, needed by libthread_db\n */\n\nps_err_e ps_pglobal_lookup(struct ps_prochandle *handle, const char *objName, \n        const char *symName, psaddr_t *symbolAddr)\n{\n    pthrd_printf(\"Looking up symbol %s in %s\\n\", symName, objName);\n    return handle->thread_db_proc->getSymbolAddr(objName, symName, symbolAddr);\n}\n\nps_err_e ps_pread(struct ps_prochandle *handle, psaddr_t remote, void *local, size_t size) {\n   thread_db_process *llproc = handle->thread_db_proc;\n   pthrd_printf(\"thread_db reading from %#lx to %#lx, size = %d on %d\\n\",\n                (unsigned long)remote, (unsigned long)local, (int)size, llproc->getPid());\n\n   llproc->resps.clear();\n   async_ret_t result = llproc->getMemCache()->readMemory(local, (Address) remote, size,\n                                                          llproc->resps,\n                                                          llproc->triggerThread());\n   \n\n   switch (result) {\n      case aret_success:\n         llproc->hasAsyncPending = false;\n         return PS_OK;\n      case aret_async:\n         llproc->hasAsyncPending = true;\n         pthrd_printf(\"Incomplete async read in thread_db read\\n\");\n         return PS_ERR;\n      case aret_error:\n         llproc->hasAsyncPending = false;\n         pthrd_printf(\"Unexpected read error in thread_db read\\n\");\n         return PS_ERR;\n   }\n   assert(0);\n   return PS_ERR;\n}\n\nps_err_e ps_pdread(struct ps_prochandle *handle, psaddr_t remote, void *local, size_t size) {\n   return ps_pread(handle, remote, local, size);\n}\n\nps_err_e ps_ptread(struct ps_prochandle *handle, psaddr_t remote, void *local, size_t size) {\n   return ps_pread(handle, remote, local, size);\n}\n\nps_err_e ps_pwrite(struct ps_prochandle *handle, psaddr_t remote, const void *local, size_t size) {\n    pthrd_printf(\"thread_db writing to %#lx from %#lx, size = %d on %d\\n\",\n            (unsigned long)remote, (unsigned long)local, (int)size, handle->thread_db_proc->getPid());\n\n    thread_db_process *proc = handle->thread_db_proc;\n\n    async_ret_t result = proc->getMemCache()->writeMemory((Address) remote, \n                                                          const_cast<void *>(local), \n                                                          size, \n                                                          proc->res_resps, \n                                                          proc->triggerThread());\n    switch (result) {\n      case aret_success:\n         proc->hasAsyncPending = false;\n         return PS_OK;\n      case aret_async:\n         proc->hasAsyncPending = true;\n         pthrd_printf(\"Incomplete async write in thread_db write\\n\");\n         return PS_ERR;\n      case aret_error:\n         proc->hasAsyncPending = false;\n         pthrd_printf(\"Unexpected read error in thread_db write\\n\");\n         return PS_ERR;\n    }\n    assert(0);\n    return PS_ERR;\n}\n\nps_err_e ps_pdwrite(struct ps_prochandle *handle, psaddr_t remote, const void *local, size_t size) {\n   return ps_pwrite(handle, remote, local, size);\n}\n\nps_err_e ps_ptwrite(struct ps_prochandle *handle, psaddr_t remote, const void *local, size_t size) {\n   return ps_pwrite(handle, remote, local, size);\n}\n\nps_err_e ps_linfo(struct ps_prochandle *handle, lwpid_t lwp, void *lwpInfo) {\n   if( !handle->thread_db_proc->plat_getLWPInfo(lwp, lwpInfo) ) {\n      pthrd_printf(\"thread_db called ps_linfo, returning error\\n\");\n      return PS_ERR;\n   }\n   pthrd_printf(\"thread_db called ps_linfo, returning info\\n\");\n   return PS_OK;\n}\n\nps_err_e ps_lstop(struct ps_prochandle *handle, lwpid_t lwp) {\n   int_process *proc = handle->thread_db_proc;\n   int_threadPool *tp = proc->threadPool();\n   assert(tp);\n   int_thread *thr = tp->findThreadByLWP((Dyninst::LWP) lwp);\n   if (!thr) {\n      perr_printf(\"ps_lstop is unable to find LWP %d in process %d\\n\",\n                  lwp, proc->getPid());\n      return PS_ERR;\n   }\n   pthrd_printf(\"ps_lstop on %d/%d\\n\", proc->getPid(), thr->getLWP());\n   \n   if (thr->getInternalState().getState() == int_thread::stopped) {\n      return PS_OK;\n   }\n   else if (thr->getInternalState().getState() != int_thread::running) {\n      perr_printf(\"Error, ps_lstop on thread in bad state\\n\");\n      return PS_ERR;\n   }\n\n   thr->getInternalState().setState(int_thread::stopped);\n   \n   return PS_OK;\n}\n\nps_err_e ps_lcontinue(struct ps_prochandle *handle, lwpid_t lwp) {\n   int_process *proc = handle->thread_db_proc;\n   int_threadPool *tp = proc->threadPool();\n   assert(tp);\n   int_thread *thr = tp->findThreadByLWP((Dyninst::LWP) lwp);\n   if (!thr) {\n      perr_printf(\"ps_lcontinue is unable to find LWP %d in process %d\\n\",\n                  lwp, proc->getPid());\n      return PS_ERR;\n   }\n   pthrd_printf(\"ps_lcontinue on %d/%d\\n\", proc->getPid(), thr->getLWP());\n   \n   if (thr->getInternalState().getState() == int_thread::running) {\n      return PS_OK;\n   }\n   else if (thr->getInternalState().getState() != int_thread::stopped) {\n      perr_printf(\"Error, ps_lcontinue on thread in bad state\\n\");\n      return PS_ERR;\n   }\n   \n   thr->getInternalState().setState(int_thread::stopped);\n   return PS_OK;\n}\n\nps_err_e ps_lgetregs(struct ps_prochandle *handle, lwpid_t lwp, prgregset_t regs) {\n   thread_db_process *proc = handle->thread_db_proc;\n   int_threadPool *tp = proc->threadPool();\n   assert(tp);\n   int_thread *llthr = tp->findThreadByLWP((Dyninst::LWP) lwp);\n   if (!llthr) {\n      perr_printf(\"ps_lgetregs is unable to find LWP %d in process %d\\n\",\n                  lwp, proc->getPid());\n      return PS_ERR;\n   }\n\n   thread_db_thread *thr = dynamic_cast<thread_db_thread *>(llthr);\n   \n   pthrd_printf(\"thread_db reading registers on thread %d/%d\\n\",\n                proc->getPid(), thr->getLWP());\n   \n   int_registerPool pool;\n   async_ret_t result = proc->getMemCache()->getRegisters(llthr, pool);\n   if (result == aret_async) {\n      pthrd_printf(\"Async return during get reg\\n\");\n      return PS_ERR;\n   }\n   if (result == aret_error) {\n      pthrd_printf(\"Error return during get reg\\n\");\n      return PS_ERR;\n   }\n\n   bool bresult = thr->plat_convertToSystemRegs(pool, (unsigned char *) regs, true);\n   if (!bresult) {\n      pthrd_printf(\"Error convering to system regs\\n\");\n      return PS_ERR;\n   }\n   return PS_OK;\n}\n\npid_t ps_getpid (struct ps_prochandle *ph)\n{\n   int pid = ph->thread_db_proc->threaddb_getPid();\n   pthrd_printf(\"thread_db called ps_getpid.  Returning %d\\n\", pid);\n   return pid;\n}\n\nvoid ps_plog(const char *format, ...) {\n   pthrd_printf(\"thread_db called ps_plog\\n\");\n    if( !dyninst_debug_proccontrol ) return;\n    if( NULL == format ) return;\n\n    va_list va;\n    va_start(va, format);\n    vfprintf(pctrl_err_out, format, va);\n    va_end(va);\n}\n\n#define NA_IMPLEMENTED \"This function is not implemented\"\n\nps_err_e ps_lgetfpregs(struct ps_prochandle *, lwpid_t, prfpregset_t *) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_lsetfpregs(struct ps_prochandle *, lwpid_t, const prfpregset_t *) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_lsetregs(struct ps_prochandle *, lwpid_t, const prgregset_t) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_lgetxmmregs (struct ps_prochandle *, lwpid_t, char *) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_lsetxmmregs (struct ps_prochandle *, lwpid_t, const char *) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_pcontinue(struct ps_prochandle *) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_pdmodel(struct ps_prochandle *, int *) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_pstop(struct ps_prochandle *) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_get_thread_area(const struct ps_prochandle *phandle, lwpid_t lwp, int val, psaddr_t *addr)\n{\n   thread_db_process *tdb_proc = phandle->thread_db_proc;\n   thread_db_thread *tdb_thread = dynamic_cast<thread_db_thread *>(tdb_proc->threadPool()->findThreadByLWP(lwp));\n\n   Dyninst::Address daddr = 0;\n   bool result = tdb_thread->thrdb_getThreadArea(val, daddr);\n   if (addr && result)\n      *addr = (psaddr_t) daddr;\n      \n   pthrd_printf(\"thread_db called ps_get_thread_area.  Returning %s\\n\", result ? \"PS_OK\" : \"PS_ERR\");\n   return result ? PS_OK : PS_ERR;\n}\n\n#if defined(THREAD_DB_STATIC)\n#define TDB_BIND(SYM) \\\n   p_ ## SYM = SYM\n#else\n#define TDB_BIND(SYM) \\\n   do { \\\n     p_ ## SYM = (SYM ## _t) dlsym(libhandle, #SYM); \\\n     if (!p_ ## SYM) { \\\n       const char *errmsg = dlerror();                                       \\\n       perr_printf(\"Error looking up %s in threaddb.so: %s\\n\", #SYM, errmsg); \\\n       return false; \\\n     } \\\n   } while (0)\n#endif\n\n#if defined(THREAD_DB_PATH)\n#define THREAD_DB_PATH_STR THREAD_DB_PATH\n#else\n#define THREAD_DB_PATH_STR NULL\n#endif\n\nthread_db_process::td_init_t thread_db_process::p_td_init;\nthread_db_process::td_ta_new_t thread_db_process::p_td_ta_new;\nthread_db_process::td_ta_delete_t thread_db_process::p_td_ta_delete;\nthread_db_process::td_ta_event_addr_t thread_db_process::p_td_ta_event_addr;\nthread_db_process::td_ta_set_event_t thread_db_process::p_td_ta_set_event;\nthread_db_process::td_ta_map_lwp2thr_t thread_db_process::p_td_ta_map_lwp2thr;\nthread_db_process::td_ta_event_getmsg_t thread_db_process::p_td_ta_event_getmsg;\nthread_db_process::td_thr_get_info_t thread_db_process::p_td_thr_get_info;\nthread_db_process::td_thr_event_enable_t thread_db_process::p_td_thr_event_enable;\nthread_db_process::td_thr_set_event_t thread_db_process::p_td_thr_set_event;\nthread_db_process::td_thr_event_getmsg_t thread_db_process::p_td_thr_event_getmsg;\nthread_db_process::td_thr_dbsuspend_t thread_db_process::p_td_thr_dbsuspend;\nthread_db_process::td_thr_dbresume_t thread_db_process::p_td_thr_dbresume;\n\nbool thread_db_process::tdb_loaded = false;\nbool thread_db_process::tdb_loaded_result = false;\n\n#if !defined(THREAD_DB_STATIC)\nstatic void *dlopenThreadDB(char *path)\n{\n   std::string filename;\n   std::string alt_filename;\n   if (path) {\n      filename = std::string(path);\n      if (*filename.rend() != '/') {\n         filename += std::string(\"/\");\n      }\n      filename += std::string(\"libthread_db.so\");\n#if !defined(os_bg)\n      //On BG alt_filename would try to load /lib/libthread_db.so, which is\n      // for the IO node.\n      alt_filename = std::string(\"libthread_db.so\");\n#endif\n\n   }\n   else {\n      filename = std::string(\"libthread_db.so\");\n   }\n\n#if defined(os_bgq)\n   alt_filename = filename;\n   filename = std::string(\"/bgsys/drivers/ppcfloor/gnu-linux/powerpc64-bgq-linux/lib/libthread_db.so.1\");\n#endif\n\n   pthrd_printf(\"Opening thread_db with %s\\n\", filename.c_str());\n   void *libhandle = dlopen(filename.c_str(), RTLD_LAZY);\n   if (!libhandle && !alt_filename.empty()) {\n   pthrd_printf(\"Opening thread_db with %s\\n\", alt_filename.c_str());\n      libhandle = dlopen(alt_filename.c_str(), RTLD_LAZY);\n   }\n   if (!libhandle) {\n      const char *errmsg = dlerror();\n      perr_printf(\"Error loading libthread_db.so: %s\\n\", errmsg);\n      return NULL;\n   }\n   return libhandle;\n}\n\n#else\nstatic void *dlopenThreadDB(char *)\n{\n   return (void *) 0x1;  //Return anything non-NULL\n}\n#endif\n\nbool thread_db_process::loadedThreadDBLibrary()\n{\n   if (tdb_loaded)\n      return tdb_loaded_result;\n   tdb_loaded = true;\n   \n   void *libhandle = dlopenThreadDB(THREAD_DB_PATH_STR);\n   if (!libhandle)\n      return false;\n\n   TDB_BIND(td_init);\n   TDB_BIND(td_ta_new);\n   TDB_BIND(td_ta_delete);\n   TDB_BIND(td_ta_event_addr);\n   TDB_BIND(td_ta_set_event);\n   TDB_BIND(td_ta_event_getmsg);\n   TDB_BIND(td_ta_map_lwp2thr);\n   TDB_BIND(td_thr_get_info);\n   TDB_BIND(td_thr_event_enable);\n   TDB_BIND(td_thr_set_event);\n   TDB_BIND(td_thr_event_getmsg);\n   TDB_BIND(td_thr_dbsuspend);\n   TDB_BIND(td_thr_dbresume);\n\n   pthrd_printf(\"Successfully loaded thread_db.so library\\n\");\n   tdb_loaded_result = true;\n   return true;\n}\n\n#ifndef CASE_RETURN_STR\n#define CASE_RETURN_STR(x) case x: return #x;\n#endif\n\nstatic const char *tdErr2Str(td_err_e errVal) {\n    switch(errVal) {\n        CASE_RETURN_STR(TD_ERR)\n        CASE_RETURN_STR(TD_OK)\n        CASE_RETURN_STR(TD_BADKEY)\n        CASE_RETURN_STR(TD_BADPH)\n        CASE_RETURN_STR(TD_BADSH)\n        CASE_RETURN_STR(TD_BADTA)\n        CASE_RETURN_STR(TD_BADTH)\n        CASE_RETURN_STR(TD_DBERR)\n        CASE_RETURN_STR(TD_MALLOC)\n        CASE_RETURN_STR(TD_NOAPLIC)\n        CASE_RETURN_STR(TD_NOCAPAB)\n        CASE_RETURN_STR(TD_NOEVENT)\n        CASE_RETURN_STR(TD_NOFPREGS)\n        CASE_RETURN_STR(TD_NOLIBTHREAD)\n        CASE_RETURN_STR(TD_NOLWP)\n        CASE_RETURN_STR(TD_NOMSG)\n        CASE_RETURN_STR(TD_NOSV)\n        CASE_RETURN_STR(TD_NOTHR)\n        CASE_RETURN_STR(TD_NOTSD)\n        CASE_RETURN_STR(TD_NOXREGS)\n        CASE_RETURN_STR(TD_PARTIALREG)\n        default:\n            return \"?\";\n    }\n}\n\nEvent::ptr thread_db_process::decodeThreadEvent(td_event_msg_t *eventMsg, bool &async)\n{\n   td_thrinfo_t info;\n   async = false;\n#if !defined(os_freebsd)\n   td_thrhandle_t *handle = const_cast<td_thrhandle_t *>(eventMsg->th_p);\n#else\n   td_thrhandle_t *handle = (td_thrhandle_t *)(eventMsg->th_p);\n#endif\n   pthrd_printf(\"Decoding thread event on %u\\n\", getPid());\n   async_ret_t result = ll_fetchThreadInfo(handle, &info);\n   if (result == aret_error) {\n      pthrd_printf(\"Failed to fetch thread info\\n\");\n      return Event::ptr();\n   }\n   if (result == aret_async) {\n      async = true;\n      pthrd_printf(\"Returning async from decodeThreadEvent\\n\");\n      return Event::ptr();\n   }\n   Dyninst::LWP lwp = (Dyninst::LWP) info.ti_lid;\n   int_thread *thr = threadPool()->findThreadByLWP(lwp); //thr may be NULL if OS doesn't support LWP events (BG/P) \n   switch(eventMsg->event) {\n      case TD_CREATE:\n      {\n         pthrd_printf(\"Decoded to user thread create of %d/%d\\n\", getPid(), lwp);\n\n         EventNewUserThread::ptr new_ev = EventNewUserThread::ptr(new EventNewUserThread());\n         new_ev->setProcess(proc());\n         new_ev->setThread(thr ? thr->thread() : Thread::ptr());\n         new_ev->setSyncType(Event::sync_process);\n         int_eventNewUserThread *iev = new_ev->getInternalEvent();\n\n         new_thread_data_t *thrdata = (new_thread_data_t *) malloc(sizeof(new_thread_data_t));\n         thrdata->thr_handle = new td_thrhandle_t(*handle);\n         thrdata->thr_info = info;\n         thrdata->threadHandle_alloced = true;\n\n         iev->raw_data = (void *) thrdata;\n         iev->lwp = lwp;\n\n         if (threadPool()->initialThread() == thr)\n            initialThreadEventCreated = true;\n\n         return new_ev;\n      }\n      case TD_DEATH: {\n         pthrd_printf(\"Decoded to user thread death of %d/%d\\n\", getPid(), lwp);\n         if (!thr) {\n            perr_printf(\"Error.  Got thread delete event for unknown LWP\\n\");\n            return Event::ptr();\n         }\n\n         EventUserThreadDestroy::ptr new_ev = EventUserThreadDestroy::ptr(new EventUserThreadDestroy(EventType::Pre));\n         new_ev->setProcess(proc());\n         new_ev->setThread(thr->thread());\n         new_ev->setSyncType(Event::sync_process);\n\n         return new_ev;\n      }\n      default: {\n         pthrd_printf(\"Unimplemented libthread_db event encountered. Skipping for now.\\n\");\n         break;\n      }\n   }\n\n   return Event::ptr();\n}\n\nvolatile bool thread_db_process::thread_db_initialized = false;\nMutex<> thread_db_process::thread_db_init_lock;\n\nthread_db_process::thread_db_process(Dyninst::PID p, std::string e, std::vector<std::string> envp, std::vector<std::string> a, std::map<int, int> f) :\n  int_process(p, e, a, envp, f),\n  int_threadTracking(p, e, a, envp, f),\n  thread_db_proc_initialized(false),\n  threadAgent(NULL),\n  createdThreadAgent(false),\n  self(NULL),\n  trigger_thread(NULL),\n  hasAsyncPending(false),\n  initialThreadEventCreated(false),\n  setEventSet(false),\n  completed_post(false),\n  track_threads(ThreadTracking::getDefaultTrackThreads())\n{\n   if (!loadedThreadDBLibrary())\n      return;\n   self = new ps_prochandle();\n   assert(self);\n   self->thread_db_proc = this;\n}\n\nthread_db_process::thread_db_process(Dyninst::PID pid_, int_process *p) :\n  int_process(pid_, p),\n  int_threadTracking(pid_, p), \n  thread_db_proc_initialized(false),\n  threadAgent(NULL),\n  createdThreadAgent(false),\n  self(NULL),\n  trigger_thread(NULL),\n  hasAsyncPending(false),\n  initialThreadEventCreated(false),\n  setEventSet(false),\n  completed_post(false),\n  track_threads(ThreadTracking::getDefaultTrackThreads())\n{\n   if (!loadedThreadDBLibrary())\n      return;\n   self = new ps_prochandle();\n   assert(self);\n   self->thread_db_proc = this;\n}\n\nthread_db_process::~thread_db_process() \n{\n    // Free the breakpoints allocated for events\n    map<Dyninst::Address, pair<int_breakpoint *, EventType> >::iterator brkptIter;\n    for(brkptIter = addr2Event.begin(); brkptIter != addr2Event.end(); ++brkptIter) {\n        delete brkptIter->second.first;\n    }\n\n    if (self)\n       delete self;\n}\n\nasync_ret_t thread_db_process::initThreadWithHandle(td_thrhandle_t *thr, td_thrinfo_t *info, LWP lwp)\n{\n   pthrd_printf(\"initThreadWithHandle on %d/%d\\n\", getPid(), lwp);\n\n   td_thrinfo_t tinfo;\n   if (!info) {\n      async_ret_t result = ll_fetchThreadInfo(thr, &tinfo);\n      if (result == aret_error) {\n         pthrd_printf(\"Error calling ll_fetchThreadInfo from initThreadWithHandle\\n\");\n         return aret_error;\n      }\n      if (result == aret_async) {\n         pthrd_printf(\"Returning async from initThreadWithHandle\\n\");\n         return aret_async;\n      }\n      info = &tinfo;\n   }\n\n   if (lwp == NULL_LWP) {\n      lwp = (Dyninst::LWP) info->ti_lid;\n      pthrd_printf(\"initThreadWithHandle found thread %d/%d\\n\", getPid(), lwp);\n   }\n   thread_db_thread *tdb_thread = dynamic_cast<thread_db_thread *>(threadPool()->findThreadByLWP(lwp));\n   if (!tdb_thread) {\n      perr_printf(\"Error.  Thread_db reports thread %d/%d, but couldn't find existing LWP\\n\",\n                  getPid(), lwp);\n      return aret_error;\n   }\n   if (tdb_thread->thread_initialized) {\n      return aret_success;\n   }\n   pthrd_printf(\"thread_db handling thread create for %d/%d\\n\", getPid(), lwp);\n   tdb_thread->threadHandle = thr;\n   tdb_thread->tinfo = *info;\n   if (info->ti_tid)\n      tdb_thread->tinfo_initialized = true;\n\n   getMemCache()->markToken(token_seteventreporting);\n   async_ret_t result = tdb_thread->setEventReporting(true);\n   if (result == aret_error) {\n      pthrd_printf(\"Error in setEventReporting for %d/%d\\n\", getPid(), tdb_thread->getLWP());\n      return aret_error;\n   }\n   if (result == aret_async) {\n      pthrd_printf(\"Async return in setEventReporting for %d/%d\\n\", getPid(), tdb_thread->getLWP());\n      return aret_async;\n   }\n   getMemCache()->condense();\n   tdb_thread->thread_initialized = true;\n   return aret_success;\n}\n\n\nasync_ret_t thread_db_process::handleThreadAttach(td_thrhandle_t *thr, Dyninst::LWP lwp)\n{\n   return initThreadWithHandle(thr, NULL, lwp);\n}\n\nasync_ret_t thread_db_process::initThreadDB() {\n    // Q: Why isn't this in the constructor? \n    // A: This function depends on the corresponding thread library being loaded\n    // and this event occurs some time after process creation.\n\n   if (!track_threads) {\n      return aret_success;\n   }\n    // Make sure thread_db is initialized - only once for all instances\n   if( !thread_db_initialized ) {\n      pthrd_printf(\"Initializing thread_db library\\n\");\n      thread_db_init_lock.lock();\n      if( !thread_db_initialized ) {\n         if (!loadedThreadDBLibrary()) {\n            setLastError(err_internal, \"libthread_db was not loaded\");\n            thread_db_init_lock.unlock();\n            return aret_error;\n         }\n         td_err_e errVal;\n         if( TD_OK != (errVal = p_td_init()) ) {\n            perr_printf(\"Failed to initialize libthread_db: %s(%d)\\n\",\n                        tdErr2Str(errVal), errVal);\n            setLastError(err_internal, \"libthread_db initialization failed\");\n            thread_db_init_lock.unlock();\n            return aret_error;\n          }\n         pthrd_printf(\"Sucessfully initialized thread_db\\n\");\n         thread_db_initialized = true;\n      }\n      thread_db_init_lock.unlock();\n   }\n   if (thread_db_proc_initialized) {\n      return aret_success;\n   }\n\n   getMemCache()->markToken(token_init);   \n   // Create the thread agent\n   td_err_e errVal;\n   if (!createdThreadAgent)\n   {\n      pthrd_printf(\"Creating threadAgent\\n\");\n      errVal = p_td_ta_new(self, &threadAgent);\n      switch(errVal) {\n         case TD_OK:\n            pthrd_printf(\"Retrieved thread agent from thread_db\\n\");\n            break;\n         case TD_NOLIBTHREAD:\n            pthrd_printf(\"Debuggee isn't multithreaded at this point, libthread_db not enabled\\n\");\n            return aret_success;\n         case TD_ERR:\n            if (getMemCache()->hasPendingAsync()) {\n               pthrd_printf(\"Postponing thread_db initialization for async\\n\");\n               return aret_async;\n            }\n            //FALLTHROUGH\n         default:\n            perr_printf(\"Failed to create thread agent: %s(%d)\\n\",\n                        tdErr2Str(errVal), errVal);\n            thread_db_proc_initialized = true;\n            setLastError(err_internal, \"Failed to create libthread_db agent\");\n            return aret_error;\n      }\n      createdThreadAgent = true;\n   }\n\n   bool hasAsync = false;\n   set<pair<td_thrhandle_t *, LWP> > all_handles;\n   for (int_threadPool::iterator i = threadPool()->begin(); i != threadPool()->end(); i++) {\n      thread_db_thread *tdb_thread = dynamic_cast<thread_db_thread *>(*i);\n      \n      if (tdb_thread->threadHandle_alloced) {\n         all_handles.insert(pair<td_thrhandle_t *, LWP>(tdb_thread->threadHandle, tdb_thread->getLWP()));\n         continue;\n      }\n      \n      if (!tdb_thread->threadHandle) {\n         tdb_thread->threadHandle = new td_thrhandle_t;\n         memset(tdb_thread->threadHandle, 0, sizeof(td_thrhandle_t));\n      }\n      \n      pthrd_printf(\"lwp2thr on %d/%d\\n\", getPid(), tdb_thread->getLWP());\n      errVal = p_td_ta_map_lwp2thr(getThreadDBAgent(), tdb_thread->getLWP(), tdb_thread->threadHandle);\n      if (errVal != TD_OK) {\n         if (getMemCache()->hasPendingAsync()) {\n            pthrd_printf(\"Hit async during lwp2thr\\n\");\n            hasAsync = true;\n            continue;\n         }\n         perr_printf(\"Failed to map LWP %d to thread_db thread: %s(%d)\\n\",\n                     tdb_thread->getLWP(), tdErr2Str(errVal), errVal);\n         setLastError(err_internal, \"Failed to get thread_db thread handle\");\n         delete tdb_thread->threadHandle;\n         tdb_thread->threadHandle = NULL;\n         continue;\n      }\n      pthrd_printf(\"Successful lwp2thr on %d/%d\\n\", getPid(), tdb_thread->getLWP());\n      tdb_thread->threadHandle_alloced = true;\n      all_handles.insert(pair<td_thrhandle_t *, LWP>(tdb_thread->threadHandle, tdb_thread->getLWP()));\n   }\n   if (hasAsync) {\n      pthrd_printf(\"Postponing lwp2thr for async\\n\");\n      return aret_async;\n   }\n\n   pthrd_printf(\"handleThreadAttach for %d threads\\n\", (int) all_handles.size());\n   for (set<pair<td_thrhandle_t *, LWP> >::iterator i = all_handles.begin(); i != all_handles.end(); i++)\n   {\n      async_ret_t result = handleThreadAttach(i->first, i->second);\n      if (result == aret_error) {\n         perr_printf(\"Error handling thread_db attach\\n\");\n         return aret_error;\n      }\n      if (result == aret_async) {\n         pthrd_printf(\"handleThreadAttach returned async in initThreadDB\\n\");\n         return aret_async;\n      }\n   }\n   \n   // Enable all events\n   td_thr_events_t eventMask;\n#if defined(td_event_fillset)\n   //Macro on GNU libc\n   td_event_fillset(&eventMask);\n#elif defined(os_freebsd)\n   //Inline header file function on FreeBSD\n   td_event_fillset(&eventMask);\n#else\n//Need to make td_event_fillset a function pointer if this hits\n#error td_event_fillset is not a macro on this platform\n#endif\n\n   if (!setEventSet) {\n      getMemCache()->markToken(token_setevent);\n      errVal = p_td_ta_set_event(threadAgent, &eventMask);\n      if( errVal != TD_OK && getMemCache()->hasPendingAsync()) {\n         pthrd_printf(\"Async return from td_ta_set_event in initThreadDB\\n\");\n         return aret_async;\n      }\n      setEventSet = true;\n      getMemCache()->condense();\n      if (errVal != TD_OK) {\n         perr_printf(\"Failed to enable events: %s(%d)\\n\",\n                     tdErr2Str(errVal), errVal);\n         setLastError(err_internal, \"Failed to enable libthread_db events\");\n         thread_db_proc_initialized = true;\n         return aret_error;\n      }\n   }\n\n    // Determine the addresses for all events\n   td_event_e allEvents[] = { TD_CATCHSIG, TD_CONCURRENCY, TD_CREATE,\n                              TD_DEATH, TD_IDLE, TD_LOCK_TRY, TD_PREEMPT, TD_PRI_INHERIT,\n                              TD_READY, TD_REAP, TD_SLEEP, TD_SWITCHFROM, TD_SWITCHTO,\n                              TD_TIMEOUT };\n\n   for(unsigned i = 0; i < (sizeof(allEvents)/sizeof(td_event_e)); ++i) {\n      td_notify_t notifyResult;\n      errVal = p_td_ta_event_addr(threadAgent, allEvents[i], &notifyResult);\n      \n      // This indicates that the event isn't supported\n      if( TD_OK != errVal ) continue;\n      \n      assert( notifyResult.type == NOTIFY_BPT && \"Untested notify type\" );\n      \n      EventType newEvent;\n      switch(allEvents[i]) {\n         case TD_CREATE:\n            newEvent = EventType(EventType::Post, EventType::ThreadCreate);\n            pthrd_printf(\"Installing breakpoint for thread creation events\\n\");\n            break;\n         case TD_DEATH:\n            newEvent = EventType(EventType::Post, EventType::ThreadDestroy);\n            pthrd_printf(\"Installing breakpoint for thread destroy events\\n\");\n            break;\n         default:\n            pthrd_printf(\"Unimplemented libthread_db event encountered. Skipping for now.\\n\");\n            continue;\n      }\n      \n      Address addr = (Address) notifyResult.u.bptaddr;\n      pthrd_printf(\"Received address of 0x%lx for breakpoint, checking platform conversion\\n\",\n\t\t   addr);\n      if( !plat_convertToBreakpointAddress(addr, triggerThread()) ) {\n         perr_printf(\"Failed to determine breakpoint address\\n\");\n         setLastError(err_internal, \"Failed to install new thread_db event breakpoint\");\n         thread_db_proc_initialized = true;\n         return aret_error;\n      }\n      pthrd_printf(\"Post-conversion, using address of 0x%lx\\n\", addr);\n#if defined(os_freebsd)\n      notifyResult.u.bptaddr = (psaddr_t) addr;\n#else\n      notifyResult.u.bptaddr = (void *) addr;\n#endif \n      int_breakpoint *newEventBrkpt = new int_breakpoint(Breakpoint::ptr());\n      newEventBrkpt->setProcessStopper(true);\n      if( !addBreakpoint(addr, newEventBrkpt))\n      {\n         perr_printf(\"Failed to install new event breakpoint\\n\");\n         setLastError(err_internal, \"Failed to install new thread_db event breakpoint\");\n         delete newEventBrkpt;\n         thread_db_proc_initialized = true;\n         return aret_error;\n         }\n      \n      pair<map<Dyninst::Address, pair<int_breakpoint *, EventType> >::iterator, bool> insertIter;\n      insertIter = addr2Event.insert(make_pair(addr, make_pair(newEventBrkpt, newEvent)));\n\n      assert( insertIter.second && \"event breakpoint address not unique\" );\n   }\n   \n   thread_db_proc_initialized = true;\n   return aret_success;\n}\n\nvoid thread_db_process::freeThreadDBAgent() {\n    // This code cannot be in the destructor because it makes use of\n    // the proc_service interface and this makes calls to functions\n    // that are pure virtual in this class.\n    //\n    // A possible, better solution would be to make the functions static\n    // but we lose all the convenience of pure virtual functions\n    //\n    // At any rate, this function should be called from a derived class' \n    // destructor for the time being.\n\n    if( thread_db_initialized && threadAgent ) {\n        td_err_e errVal = p_td_ta_delete(threadAgent);\n        if( TD_OK != errVal ) {\n            perr_printf(\"Failed to delete thread agent: %s(%d)\\n\",\n                    tdErr2Str(errVal), errVal);\n        }\n        assert( TD_OK == errVal && \"Failed to delete thread agent\" );\n        threadAgent = NULL;\n    }\n}\n\nconst char *thread_db_process::getThreadLibName(const char *)\n{\n   return \"\";\n}\n\nbool thread_db_process::decodeTdbLWPExit(EventLWPDestroy::ptr lwp_ev)\n{\n   thread_db_thread *db_thread = dynamic_cast<thread_db_thread *>(lwp_ev->getThread()->llthrd());\n   assert(db_thread);\n   \n   if (db_thread->destroyed || !db_thread->thread_initialized)\n      return false;\n\n   pthrd_printf(\"Decoded LWP exit without thread exit on %d/%d.  Faking thread exit event\\n\",\n                db_thread->llproc()->getPid(), db_thread->getLWP());\n\n   EventUserThreadDestroy::ptr new_ev = EventUserThreadDestroy::ptr(new EventUserThreadDestroy(EventType::Post));\n   new_ev->setProcess(db_thread->llproc()->proc());\n   new_ev->setThread(db_thread->thread());\n   new_ev->setSyncType(Event::async);\n   lwp_ev->addSubservientEvent(new_ev);\n\n   return true;\n}\n\nasync_ret_t thread_db_process::decodeTdbBreakpoint(EventBreakpoint::ptr bp)\n{ \n    // Decoding thread_db events needs to be a two-step process:\n    // 1) Create events depending on the breakpoint address\n    //    Don't get events from thread_db as this can write to memory\n    //    and threads could currently be running -- introduces some race\n    //    conditions where the running threads could be modifying data\n    //    structures thread_db is accessing\n    //    Just create placeholder events that can later be filled in with\n    //    more information\n    // 2) Get events from thread_db in the handler for the event, at this\n    //    point all threads are stopped and it is safe to make changes to\n    //    memory because the parent event is a breakpoint and requires\n    //    that all threads are stopped\n    Dyninst::Address addr = bp->getAddress();\n    \n    // Determine what type of event occurs at the specified address\n    map<Dyninst::Address, pair<int_breakpoint *, EventType> >::iterator addrIter;\n    addrIter = addr2Event.find(addr);\n    if (addrIter == addr2Event.end()) \n       return aret_error;\n\n    vector<Event::ptr> threadEvents;\n\n    EventType::Code ecode = addrIter->second.second.code();\n    pthrd_printf(\"Address 0x%lx corresponds to a thread %s breakpoint.\\n\",\n                 addr, ecode == EventType::ThreadCreate ? \"create\" : \"destroy\");\n    switch(ecode) {\n       case EventType::ThreadCreate:\n       case EventType::ThreadDestroy:\n          threadEvents.push_back(EventThreadDB::ptr(new EventThreadDB()));\n          break;\n       default:\n          pthrd_printf(\"Failed to decode any thread events due to the breakpoint\\n\");\n          return aret_error;\n    }\n\n    for (vector<Event::ptr>::iterator i = threadEvents.begin(); i != threadEvents.end(); i++) {\n       Event::ptr ev = *i;\n       if (!ev->getThread()) \n          ev->setThread(bp->getThread());\n       if (!ev->getProcess()) \n          ev->setProcess(proc());\n       if (ev->getSyncType() == Event::unset)\n          ev->setSyncType(Event::sync_process);\n       bp->addSubservientEvent(ev);\n    }\n    bp->setSuppressCB(true);\n    return aret_success;\n}\n\ntd_thragent_t *thread_db_process::getThreadDBAgent() {\n    return threadAgent;\n}\n\nstatic string stripLibraryName(const char *libname)\n{\n   const char *filename_c = strrchr(libname, '/');\n   if (!filename_c)\n      filename_c = strrchr(libname, '\\\\');\n   if (!filename_c) \n      filename_c = libname;\n   else \n      filename_c++;\n   \n   const char *lesser_ext = NULL;\n   const char *dot_ext = strchr(filename_c, '.');\n   if (dot_ext)\n      lesser_ext = dot_ext;\n   const char *dash_ext = strchr(filename_c, '-');\n   if (dash_ext && (!lesser_ext || dash_ext < lesser_ext))\n      lesser_ext = dash_ext;\n\n   if (!lesser_ext) {\n      return std::string(filename_c);\n   }\n   return std::string(filename_c, lesser_ext - filename_c);\n}\n\nps_err_e thread_db_process::getSymbolAddr(const char *objName, const char *symName,\n        psaddr_t *symbolAddr)\n{\n    SymReader *objSymReader = NULL;\n    int_library *lib = NULL;\n    \n    if (plat_isStaticBinary()) {\n       // For static executables, we need to search the executable instead of the\n       // thread library. \n       assert(memory()->libs.size() == 1);\n       lib = *memory()->libs.begin();\n    }\n    else\n    {\n       // FreeBSD implementation doesn't set objName\n       const char *name_c = objName ? objName : getThreadLibName(symName);\n       std::string name = stripLibraryName(name_c);\n       \n       for (set<int_library *>::iterator i = memory()->libs.begin(); i != memory()->libs.end(); i++) {\n          int_library *l = *i;\n          if (strstr(l->getName().c_str(), name.c_str())) {\n             lib = l;\n             break;\n          }\n       }\n    }\n\n    if( NULL == lib ) {\n       pthrd_printf(\"Didn't yet find loaded thread library\\n\");\n       return PS_ERR;\n    }\n\n    objSymReader = getSymReader()->openSymbolReader(lib->getName());\n    if( NULL == objSymReader ) {\n        perr_printf(\"Failed to open symbol reader for %s\\n\",\n                    lib->getName().c_str());\n        setLastError(err_internal, \"Failed to open executable for symbol reading\");\n        return PS_ERR;\n    }\n\n    Symbol_t lookupSym = objSymReader->getSymbolByName(string(symName));\n\n    if( !objSymReader->isValidSymbol(lookupSym) ) {\n       pthrd_printf(\"thread_db getSymbolAddr(%s, %s) = none\\n\", objName ? objName : \"NULL\", \n                    symName ? symName : \"NULL\");\n       return PS_NOSYM;\n    }\n    \n    Address tmp = lib->getAddr() + objSymReader->getSymbolOffset(lookupSym);\n    if (getAddressWidth() == 4) {\n       tmp &= 0xffffffff;\n    }\n    \n    *symbolAddr = (psaddr_t) tmp;\n\n    pthrd_printf(\"thread_db getSymbolAddr(%s, %s) = %p\\n\", objName ? objName : \"NULL\", \n                 symName ? symName : \"NULL\", (void *) *symbolAddr);\n    return PS_OK;\n}\n\n\nasync_ret_t thread_db_process::post_create(std::set<response::ptr> &async_responses)\n{\n   async_ret_t result;\n   if (!completed_post) {\n      result = int_process::post_create(async_responses);\n      if (result != aret_success)\n         return result;\n      completed_post = true;\n   }\n\n   err_t last_error = getLastError();\n   const char *last_err_msg = getLastErrorMsg();\n\n   getMemCache()->setSyncHandling(true);\n   for (;;) {\n      result = initThreadDB();\n      if (result != aret_async)\n         break;\n      getMemCache()->getPendingAsyncs(async_responses);\n      return aret_async;\n   }\n   getMemCache()->setSyncHandling(false);\n\n   setLastError(last_error, last_err_msg);\n   return aret_success; //Swallow these errors, thread_db failure does not bring down rest of startup\n}\n\nasync_ret_t thread_db_process::post_attach(bool wasDetached, set<response::ptr> &aresps) {\n   async_ret_t result;\n   if (!completed_post) {\n      result = int_process::post_attach(wasDetached, aresps);\n      if (result != aret_success)\n         return result;\n      completed_post = true;\n   }\n   \n   err_t last_error = getLastError();\n   const char *last_err_msg = getLastErrorMsg();\n\n   getMemCache()->setSyncHandling(true);\n   for (;;) {\n      result = initThreadDB();\n      if (result != aret_async)\n         break;\n      getMemCache()->getPendingAsyncs(aresps);\n      return aret_async;\n   }\n   getMemCache()->setSyncHandling(false);\n\n   setLastError(last_error, last_err_msg);\n   return aret_success; //Swallow these errors, thread_db failure does not bring down rest of startup\n}\n\n#if 0\n#warning TODO fix detach part in post attach rewrite\nbool thread_db_process::post_attach(bool wasDetached) {\n    if( !int_process::post_attach(wasDetached) ) return false;\n\n    if( !wasDetached ) {\n        return initThreadDB();\n    }else{\n        // Need to initialize all new threads\n        bool success = true;\n        td_err_e errVal;\n        for (int_threadPool::iterator i = threadPool()->begin(); i != threadPool()->end(); i++) {\n           thread_db_thread *tdb_thread = static_cast<thread_db_thread *>(*i);\n           if( tdb_thread->thread_initialized ) continue;\n\n           tdb_thread->threadHandle = new td_thrhandle_t;\n\n           errVal = td_ta_map_lwp2thr(getThreadDBAgent(), tdb_thread->getLWP(), tdb_thread->threadHandle);\n           if (errVal != TD_OK) {\n              perr_printf(\"Failed to map LWP %d to thread_db thread: %s(%d)\\n\",\n                          tdb_thread->getLWP(), tdErr2Str(errVal), errVal);\n              setLastError(err_internal, \"Failed to get thread_db thread handle\");\n              delete tdb_thread->threadHandle;\n              tdb_thread->threadHandle = NULL;\n              success = false;\n              continue;\n           }\n           tdb_thread->threadHandle_alloced = true;\n\n           if( !handleThreadAttach(tdb_thread->threadHandle) ) {\n               perr_printf(\"Error handling thread_db attach\\n\");\n               success = false;\n           }\n        }\n\n        return success;\n    }\n}\n#endif\n\nbool thread_db_process::isSupportedThreadLib(string libName) {\n   return (libName.find(\"libpthread\") != string::npos);\n}\n\nvoid thread_db_process::addThreadDBHandlers(HandlerPool *hpool) {\n   static bool initialized = false;\n   static ThreadDBLibHandler *libHandler = NULL;\n   static ThreadDBCreateHandler *createHandler = NULL;\n   static ThreadDBDestroyHandler *destroyHandler = NULL;\n   static ThreadDBDispatchHandler *dispatchHandler = NULL;\n   if( !initialized ) {\n      libHandler = new ThreadDBLibHandler();\n      createHandler = new ThreadDBCreateHandler();\n      destroyHandler = new ThreadDBDestroyHandler();\n      dispatchHandler = new ThreadDBDispatchHandler();\n      initialized = true;\n   }\n   hpool->addHandler(libHandler);\n   hpool->addHandler(createHandler);\n   hpool->addHandler(destroyHandler);\n   hpool->addHandler(dispatchHandler);\n}\n\nbool thread_db_process::plat_getLWPInfo(lwpid_t, void *) \n{\n   perr_printf(\"Attempt to use unsupported plat_getLWPInfo\\n\");\n   return false;\n}\n\nbool thread_db_process::plat_supportThreadEvents()\n{\n   if (!loadedThreadDBLibrary()) {\n      return false;\n   }\n   return true;\n}\n\nbool thread_db_thread::plat_convertToSystemRegs(const int_registerPool &,\n                                                unsigned char *, bool)\n{\n    return true;\n}\n\nint_thread *thread_db_process::triggerThread() const\n{\n   return trigger_thread;\n}\n\nasync_ret_t thread_db_process::ll_fetchThreadInfo(td_thrhandle_t *th, td_thrinfo_t *info)\n{\n   td_err_e result = thread_db_process::p_td_thr_get_info(th, info);\n   if (result != TD_OK) {\n      if (getMemCache()->hasPendingAsync()) {\n         pthrd_printf(\"Async return from td_thr_get_info in ll_fetchThreadInfo\\n\");\n         return aret_async;\n      }\n      perr_printf(\"Error calling td_thr_get_info: %s (%d)\\n\", tdErr2Str(result), (int) result);\n      return aret_error;\n   }\n   pthrd_printf(\"Successful ll_fetchThreadInfo for handle %p - tid = %lu, lid = %lu\\n\", th, (unsigned long) info->ti_tid, (unsigned long) info->ti_lid);\n   return aret_success;\n}\n\nThreadDBDispatchHandler::ThreadDBDispatchHandler() :\n   Handler(\"thread_db Dispatch Handler\")\n{\n}\n\nThreadDBDispatchHandler::~ThreadDBDispatchHandler()\n{\n}\n\nint ThreadDBDispatchHandler::getPriority() const\n{\n   return Handler::PostPlatformPriority;\n}\n\nHandler::handler_ret_t ThreadDBDispatchHandler::handleEvent(Event::ptr ev)\n{\n   /**\n    * All we know is that we got a thread_db breakpoint, but we don't\n    * know whether that was a thread create/destroy, or any information\n    * about those events.  We'll collect that info here, then add\n    * UserThreadCreate or UserThreadDestroy events as 'late' events \n    * (means they were generated at handle time) to this event.\n    **/\n   pthrd_printf(\"At top of ThreadDB Dispatch handler\\n\");\n   EventThreadDB::ptr etdb = ev->getEventThreadDB();\n   assert(etdb);\n   int_eventThreadDB *int_ev = etdb->getInternal();\n   assert(int_ev);\n\n   thread_db_process *proc = dynamic_cast<thread_db_process *>(etdb->getProcess()->llproc());\n   assert(proc);\n\n   if (proc->dispatch_event && proc->dispatch_event != etdb) {\n      //We don't need to handle a new dispatch event if another is in\n      //progress.  We'll drop the second.\n      pthrd_printf(\"Dropping dispatch event, another is in progress\\n\");\n      return ret_success;\n   }\n   proc->dispatch_event = etdb;\n\n   if (!int_ev->completed_new_evs) {\n      async_ret_t result = proc->getEventForThread(int_ev);\n      if (result == aret_async) {\n         pthrd_printf(\"getEventForThread returned async\\n\");\n         return ret_async;\n      }\n      int_ev->completed_new_evs = true;\n      if (result == aret_error) {\n         pthrd_printf(\"getEventForThread returned error\\n\");\n         proc->dispatch_event = EventThreadDB::ptr();\n         return ret_error;\n      }\n   }\n\n   thread_db_thread *main_thread = dynamic_cast<thread_db_thread *>(proc->threadPool()->initialThread());\n   if (main_thread->tinfo_initialized)\n      proc->initialThreadEventCreated = true;\n\n   if (!proc->initialThreadEventCreated) {\n      pthrd_printf(\"Creating thread event for main thread\\n\");\n\n      if (!main_thread->threadHandle) {\n         main_thread->threadHandle = new td_thrhandle_t;\n         bzero(&main_thread->threadHandle, sizeof(td_thrhandle_t));\n         main_thread->threadHandle_alloced = true;\n      }\n\n      int td_result = thread_db_process::p_td_ta_map_lwp2thr(proc->getThreadDBAgent(), main_thread->getLWP(), main_thread->threadHandle);\n      if (td_result == TD_ERR && proc->getMemCache()->hasPendingAsync()) {\n         pthrd_printf(\"async return from td_ta_map_lwp2thr while creating event for main thread\\n\");\n         std::set<response::ptr> resps;\n         proc->getMemCache()->getPendingAsyncs(resps);\n         proc->handlerPool()->notifyOfPendingAsyncs(resps, ev);\n         return Handler::ret_async;\n      }\n      else if (td_result == TD_ERR) {\n         perr_printf(\"Error return from td_ta_map_lwp2thr while creating event for main thread\\n\");\n         proc->dispatch_event = EventThreadDB::ptr();\n         return ret_error;\n      }\n\n      td_thrinfo_t tinfo;\n      bzero(&tinfo, sizeof(td_thrinfo_t));\n      async_ret_t result = proc->ll_fetchThreadInfo(main_thread->threadHandle, &tinfo);\n      if (result == aret_async) {\n         pthrd_printf(\"Async return during ll_fetchThreadInfo for main thread\\n\");\n         std::set<response::ptr> resps;\n         proc->getMemCache()->getPendingAsyncs(resps);\n         proc->handlerPool()->notifyOfPendingAsyncs(resps, ev);\n         return Handler::ret_async;         \n      }\n      if (result == aret_error) {\n         pthrd_printf(\"Error return during ll_fetchThreadInfo for main thread\\n\");\n         proc->dispatch_event = EventThreadDB::ptr();\n         return Handler::ret_error;\n      }\n      if (tinfo.ti_tid) {\n         new_thread_data_t *thrdata = (new_thread_data_t *) malloc(sizeof(new_thread_data_t));\n         thrdata->thr_handle = main_thread->threadHandle;\n         thrdata->thr_info = tinfo;\n         thrdata->threadHandle_alloced = main_thread->threadHandle_alloced;\n         \n         EventNewUserThread::ptr new_ev = EventNewUserThread::ptr(new EventNewUserThread());\n         new_ev->setProcess(proc->proc());\n         new_ev->setThread(main_thread->thread());\n         new_ev->setSyncType(Event::sync_process);\n         new_ev->getInternalEvent()->thr = main_thread;\n         new_ev->getInternalEvent()->lwp = main_thread->getLWP();\n         new_ev->getInternalEvent()->raw_data = (void *) thrdata;\n         proc->initialThreadEventCreated = true;\n         int_ev->new_evs.insert(new_ev);\n         pthrd_printf(\"Success creating event for main thread\\n\");\n      }\n      else {\n         pthrd_printf(\"TID info for main thread not ready yet\\n\");\n      }\n   }\n   pthrd_printf(\"Got %u events, adding as late events\\n\", (unsigned int) int_ev->new_evs.size());\n   for (set<Event::ptr>::iterator i = int_ev->new_evs.begin(); i != int_ev->new_evs.end(); i++) {\n      proc->handlerPool()->addLateEvent(*i);\n   }\n   proc->dispatch_event = EventThreadDB::ptr();\n   return ret_success;\n}\n\nvoid ThreadDBDispatchHandler::getEventTypesHandled(std::vector<EventType> &etypes)\n{\n   etypes.push_back(EventType(EventType::None, EventType::ThreadDB));\n}\n\nThreadDBLibHandler::ThreadDBLibHandler() :\n    Handler(\"thread_db Library Handler\")\n{\n}\n\nThreadDBLibHandler::~ThreadDBLibHandler() \n{\n}\n\nHandler::handler_ret_t ThreadDBLibHandler::handleEvent(Event::ptr ev) {\n   if (!thread_db_process::loadedThreadDBLibrary()) {\n      pthrd_printf(\"Failed to load thread_db.  Not running handlers\\n\");\n      return Handler::ret_success;\n   }\n\n   EventLibrary::const_ptr libEv = ev->getEventLibrary();\n   thread_db_process *proc = dynamic_cast<thread_db_process *>(ev->getProcess()->llproc());\n   const set<Library::ptr> &addLibs = libEv->libsAdded();\n\n   set<Library::ptr>::iterator libIter;\n   for( libIter = addLibs.begin(); libIter != addLibs.end(); ++libIter ) {\n      if( ! proc->isSupportedThreadLib((*libIter)->getName()) )\n         continue;\n      \n      pthrd_printf(\"Enabling thread_db support for pid %d\\n\",\n                   proc->getPid());\n      async_ret_t ret = proc->initThreadDB();\n \n      if (ret == aret_error) {\n         pthrd_printf(\"Failed to initialize thread_db for pid %d\\n\",\n                      proc->getPid());\n         return Handler::ret_error;\n      }\n      else if (ret == aret_success) {\n         return Handler::ret_success;\n      }\n      else if (ret == aret_async) {\n         std::set<response::ptr> resps;\n         proc->getMemCache()->getPendingAsyncs(resps);\n         proc->handlerPool()->notifyOfPendingAsyncs(resps, ev);\n         return Handler::ret_async;\n      }\n   }\n   \n   return Handler::ret_success;\n}\n\nint ThreadDBLibHandler::getPriority() const {\n    return PostPlatformPriority;\n}\n\nvoid ThreadDBLibHandler::getEventTypesHandled(vector<EventType> &etypes) {\n    etypes.push_back(EventType(EventType::None, EventType::Library));\n}\n\nThreadDBCreateHandler::ThreadDBCreateHandler() :\n    Handler(\"thread_db New Thread Handler\")\n{\n}\n\nThreadDBCreateHandler::~ThreadDBCreateHandler() \n{\n}\n\nint ThreadDBCreateHandler::getPriority() const\n{\n   //After dispatch handler, which runs at PostPlatformPriority\n   return Handler::PostPlatformPriority + 1;\n}\n\nHandler::handler_ret_t ThreadDBCreateHandler::handleEvent(Event::ptr ev) {\n  pthrd_printf(\"ThreadDBCreateHandler::handleEvent\\n\");\n   if (!thread_db_process::loadedThreadDBLibrary()) {\n      pthrd_printf(\"Failed to load thread_db.  Not running handlers\");\n      return Handler::ret_success;\n   }\n\n   EventNewUserThread::ptr threadEv = ev->getEventNewUserThread();\n   thread_db_process *tdb_proc = dynamic_cast<thread_db_process *>(threadEv->getProcess()->llproc());\n   thread_db_thread *tdb_thread = dynamic_cast<thread_db_thread *>(threadEv->getNewThread()->llthrd());\n\n   pthrd_printf(\"ThreadDBCreateHandler::handleEvent for %d/%d\\n\", tdb_proc->getPid(), tdb_thread->getLWP());\n   if (threadEv->getInternalEvent()->needs_update) {\n      pthrd_printf(\"Updating user thread data for %d/%d in thread_db create handler\\n\",\n                   tdb_proc->getPid(), tdb_thread->getLWP());\n      assert(tdb_proc);\n      new_thread_data_t *thrdata = (new_thread_data_t *) threadEv->getInternalEvent()->raw_data;\n      \n      async_ret_t result = tdb_proc->initThreadWithHandle(thrdata->thr_handle, &thrdata->thr_info, NULL_LWP);\n      if (result == aret_error) {\n         pthrd_printf(\"ThreadDBCreateHandler returning error\\n\");\n         return Handler::ret_error;\n      }\n      if (result == aret_async) {\n         pthrd_printf(\"ThreadDBCreateHandler returning async\\n\");\n         return Handler::ret_async;\n      }\n      if (thrdata->threadHandle_alloced) tdb_thread->threadHandle_alloced = true;\n   }\n   \n   return Handler::ret_success;\n}\n\nvoid ThreadDBCreateHandler::getEventTypesHandled(vector<EventType> &etypes) {\n   etypes.push_back(EventType(EventType::Any, EventType::UserThreadCreate));\n}\n\nThreadDBDestroyHandler::ThreadDBDestroyHandler() :\n   Handler(\"thread_db Destroy Handler\")\n{\n}\n\nThreadDBDestroyHandler::~ThreadDBDestroyHandler()\n{\n}\n\nint ThreadDBDestroyHandler::getPriority() const\n{\n   //After dispatch handler, which runs at PostPlatformPriority\n   return Handler::PostPlatformPriority + 1;\n}\n\nHandler::handler_ret_t ThreadDBDestroyHandler::handleEvent(Event::ptr ev) {\n   if (!thread_db_process::loadedThreadDBLibrary()) {\n      pthrd_printf(\"Failed to load thread_db.  Not running handlers\\n\");\n      return Handler::ret_success;\n   }\n   thread_db_process *proc = dynamic_cast<thread_db_process *>(ev->getProcess()->llproc());\n   thread_db_thread *thrd = dynamic_cast<thread_db_thread *>(ev->getThread()->llthrd());\n   pthrd_printf(\"Running ThreadDBDestroyHandler on %d/%d\\n\", proc->getPid(), thrd->getLWP());\n   thrd->markDestroyed();\n\n   return Handler::ret_success;\n}\n\nvoid ThreadDBDestroyHandler::getEventTypesHandled(vector<EventType> &etypes) {\n    etypes.push_back(EventType(EventType::Any, EventType::UserThreadDestroy));\n}\n\nthread_db_thread::thread_db_thread(int_process *p, Dyninst::THR_ID t, Dyninst::LWP l) :\n   int_thread(p, t, l),\n   threadHandle(NULL),\n   destroyed(false),\n   tinfo_initialized(false),\n   thread_initialized(false),\n   threadHandle_alloced(false),\n   enabled_event_reporting(false)\n{\n   memset(&tinfo, 0, sizeof(tinfo));\n}\n\nthread_db_thread::~thread_db_thread() \n{\n   if (threadHandle_alloced)\n      delete threadHandle;\n}\n\nbool thread_db_thread::initThreadHandle() {\n    if( NULL != threadHandle ) return true;\n\n    thread_db_process *lproc = dynamic_cast<thread_db_process *>(llproc());\n    if( NULL == lproc->getThreadDBAgent() ) return false;\n\n    threadHandle = new td_thrhandle_t;\n\n    td_err_e errVal = thread_db_process::p_td_ta_map_lwp2thr(lproc->getThreadDBAgent(),\n                                          lwp, threadHandle);\n    if( TD_OK != errVal ) {\n        perr_printf(\"Failed to map LWP %d to thread_db thread: %s(%d)\\n\",\n                lwp, tdErr2Str(errVal), errVal);\n        setLastError(err_internal, \"Failed to get thread_db thread handle\");\n        delete threadHandle;\n        threadHandle = NULL;\n        return false;\n    }\n    threadHandle_alloced = true;\n\n    return true;\n}\n\nasync_ret_t thread_db_process::getEventForThread(int_eventThreadDB *iev) {\n   // These specific calls into thread_db can modify the memory of the process\n   // and can introduce some race conditions if the platform allows memory reads\n   // while some threads are running\n   assert( threadPool()->allHandlerStopped() );\n  \n   // We need to save thread_db generated events because we need to use the\n   // process-level event retrieval call to get thread creation events (at\n   // least on some platforms).\n\n   bool local_async = false;\n   td_err_e msgErr = TD_OK;\n\n   if (!iev->completed_getmsgs) {\n      getMemCache()->markToken(token_getmsg);\n      vector<td_event_msg_t> msgs;\n      vector<td_thrhandle_t> handles;\n\n      td_event_msg_t evMsg;\n\n      for (;;) {\n         msgErr = p_td_ta_event_getmsg(threadAgent, &evMsg);\n         if (msgErr != TD_OK) {\n            if (getMemCache()->hasPendingAsync()) {\n               pthrd_printf(\"Async return in getEventForThread from td_ta_event_getmsg\\n\");\n               return aret_async;\n            }\n            else if (msgErr == TD_NOMSG) {\n               pthrd_printf(\"No more messages ready in thread_db\\n\");\n               break;\n            }\n            else {\n               perr_printf(\"Error reading messages from thread_db\\n\");\n               return aret_error;\n            }\n         }\n         msgs.push_back(evMsg);\n         //GLIBC's thread_db returns a pointer to a static variable inside\n         // evMsg.  Thus subsequent calls will override the data from prior\n         // calls.  Annoying.  Make a copy of the th_p in handles to avoid\n         // this problem.\n         handles.push_back(*evMsg.th_p);\n      }\n      pthrd_printf(\"Received %lu messages from thread_db on %d\\n\", (unsigned long)msgs.size(), getPid());\n      iev->msgs = msgs;\n      iev->handles = handles;\n      iev->completed_getmsgs = true;\n   }\n\n   getMemCache()->condense();\n\n   for (int i=iev->msgs.size()-1; i>=0; i--) {\n      td_event_msg_t &evMsg = iev->msgs[i];\n      evMsg.th_p = & iev->handles[i];\n      Event::ptr newEvent = decodeThreadEvent(&evMsg, local_async);\n      if (local_async) {\n         pthrd_printf(\"Async return from decodeThreadEvent\\n\");\n         return aret_async;\n      }\n      if (newEvent)\n         iev->new_evs.insert(newEvent);\n      iev->msgs.pop_back();\n      iev->handles.pop_back();\n   }\n  \n   return aret_success;\n}\n\nbool thread_db_process::setTrackThreads(bool b, std::set<std::pair<int_breakpoint *, Address> > &bps,\n                                                 bool &add_bp)\n{\n   if (b == track_threads) {\n      pthrd_printf(\"User wants to %s thread_db on %d, which is already done.  Leaving in same state\\n\",\n                   b ? \"enable\" : \"disable\", getPid());\n      return true;\n   }\n   track_threads = b;\n   \n   std::map<Address, pair<int_breakpoint *, EventType> >::iterator i;\n   for (i = addr2Event.begin(); i != addr2Event.end(); i++) {\n      Address addr = i->first;\n      int_breakpoint *bp = i->second.first;\n      bps.insert(make_pair(bp, addr));\n   }\n\n   add_bp = b;\n   return true;\n}\n\nbool thread_db_process::isTrackingThreads()\n{\n   return track_threads;\n}\n\nbool thread_db_process::refreshThreads()\n{\n   EventThreadDB::ptr ev = EventThreadDB::ptr(new EventThreadDB());\n   ev->setSyncType(Event::async);\n   ev->setProcess(proc());\n   ev->setThread(threadPool()->initialThread()->thread());\n   mbox()->enqueue(ev);\n   return true;\n}\n\nint thread_db_process::threaddb_getPid()\n{\n   return getPid();\n}\n\nasync_ret_t thread_db_thread::setEventReporting(bool on) {\n    if( !initThreadHandle() ) return aret_error;\n    if (enabled_event_reporting == on) return aret_success;\n\n    pthrd_printf(\"Enabled thread_db events for LWP %d\\n\", lwp);\n    td_err_e errVal = thread_db_process::p_td_thr_event_enable(threadHandle, (on ? 1 : 0 ));\n    if (errVal != TD_OK && llproc()->getMemCache()->hasPendingAsync()) {\n       pthrd_printf(\"td_thr_event_enable returned async in setEventReporting\\n\");\n       return aret_async;\n    }\n    enabled_event_reporting = on;\n    if (errVal != TD_OK) {\n       perr_printf(\"Failed to enable events for LWP %d: %s(%d)\\n\",\n                   lwp, tdErr2Str(errVal), errVal);\n       setLastError(err_internal, \"Failed to enable thread_db events\");\n       return aret_error;\n    }\n\n    return aret_success;\n}\n\nbool thread_db_thread::fetchThreadInfo() {\n   if (!thread_db_process::loadedThreadDBLibrary()) {\n      perr_printf(\"Failed to load thread_db.  Not fetching thread data.\");\n      setLastError(err_unsupported, \"thread_db.so not loaded.  User-level thread data unavailable.\");\n      return false;\n   }\n   if (!thread_initialized) {\n      perr_printf(\"Attempt to read user thread info of %d/%d before user thread create\\n\",\n                  llproc()->getPid(), getLWP());\n      setLastError(err_nouserthrd, \"Attempted to read user thread info, but user thread has not been created.\");\n      return false;\n   }\n   if (tinfo_initialized) {\n      return true;\n   }\n   if( !initThreadHandle() ) return false;\n\n   pthrd_printf(\"Calling td_thr_get_info on %d/%d\\n\", llproc()->getPid(), getLWP());\n   thread_db_process *tdb_proc = dynamic_cast<thread_db_process *>(llproc());\n   async_ret_t result = tdb_proc->ll_fetchThreadInfo(threadHandle, &tinfo);\n   if (result == aret_error) {\n      pthrd_printf(\"Returning error in fetchThreadInfo due to ll_fetchThreadInfo\\n\");\n      return false;\n   }\n   while (result == aret_async) {\n      std::set<response::ptr> resps;\n      llproc()->getMemCache()->getPendingAsyncs(resps);\n      llproc()->waitForAsyncEvent(resps);\n      result = tdb_proc->ll_fetchThreadInfo(threadHandle, &tinfo);\n      if (result == aret_error) {\n         pthrd_printf(\"Returning error in fetchThreadInfo due to ll_fetchThreadInfo\\n\");\n         return false;\n      }\n   }\n\n   if( tinfo.ti_tid ) tinfo_initialized = true;\n   return true;\n}\n\nvoid thread_db_thread::markDestroyed() {\n    destroyed = true;\n}\n\nbool thread_db_thread::isDestroyed() {\n    return destroyed;\n}\n\nbool thread_db_thread::thrdb_getThreadArea(int, Dyninst::Address &)\n{\n   assert(0); //Unsupported.  Currently only known to be needed on linux/x86_64\n   return false;\n}\n\nbool thread_db_thread::haveUserThreadInfo()\n{\n   pthrd_printf(\"haveUserThreadInfo (%d/%d): %d\\n\", (llproc() ? llproc()->getPid() : 0), lwp, thread_initialized);\n   return thread_initialized;\n}\n\nbool thread_db_thread::getTID(Dyninst::THR_ID &tid)\n{\n   if (!fetchThreadInfo()) {\n      return false;\n   }\n#if defined(os_freebsd)\n   tid = (Dyninst::THR_ID) tinfo.ti_thread;\n#else\n   tid = (Dyninst::THR_ID) tinfo.ti_tid;\n#endif\n   return true;\n}\n\nbool thread_db_thread::getStartFuncAddress(Dyninst::Address &addr)\n{\n   if (!fetchThreadInfo()) {\n      return false;\n   }\n   addr = (Dyninst::Address) tinfo.ti_startfunc;\n   return true;\n}\n\nbool thread_db_thread::getStackBase(Dyninst::Address &addr)\n{\n   if (!fetchThreadInfo()) {\n      return false;\n   }\n   addr = (Dyninst::Address) tinfo.ti_stkbase;\n   return true;\n}\n\nbool thread_db_thread::getStackSize(unsigned long &size)\n{\n   if (!fetchThreadInfo()) {\n      return false;\n   }\n   size = (unsigned long) tinfo.ti_stksize;\n   return true;\n}\n\nbool thread_db_thread::getTLSPtr(Dyninst::Address &addr)\n{\n   if (!fetchThreadInfo()) {\n      return false;\n   }\n   addr = (Dyninst::Address) tinfo.ti_tls;\n   return true;\n}\n\n#else\n\n//Empty place holder functions in-case we're built on a machine without libthread_db.so\n\nthread_db_process::thread_db_process(Dyninst::PID p, std::string e, std::vector<std::string> a, std::vector<std::string> envp, std::map<int, int> f) : \n   int_threadTracking(p, e, a, envp, f)\n{\n  cerr << \"Thread DB process constructor\" << endl;\n}\n\nthread_db_process::thread_db_process(Dyninst::PID pid_, int_process *p) :\n   int_threadTracking(pid_, p)\n{\n}\n\nthread_db_process::~thread_db_process()\n{\n}\n\nbool thread_db_process::decodeTdbLWPExit(EventLWPDestroy::ptr)\n{\n   return false;\n}\n\nasync_ret_t thread_db_process::decodeTdbBreakpoint(EventBreakpoint::ptr)\n{\n   return aret_error;\n}\n\nvoid thread_db_process::addThreadDBHandlers(HandlerPool *)\n{\n}\n\nthread_db_thread::thread_db_thread(int_process *p, Dyninst::THR_ID t, Dyninst::LWP l) : \n   int_thread(p, t, l)\n{\n}\n\nthread_db_thread::~thread_db_thread()\n{\n}\n\nbool thread_db_thread::thrdb_getThreadArea(int, Dyninst::Address &)\n{\n   assert(0); //Should not be called if there's no thread_db\n   return false;\n}\n\nbool thread_db_thread::haveUserThreadInfo()\n{\n   return false;\n}\n\nbool thread_db_thread::getTID(Dyninst::THR_ID &)\n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return false;\n}\n\nbool thread_db_thread::getStartFuncAddress(Dyninst::Address &)\n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return false;\n}\n\nbool thread_db_thread::getStackBase(Dyninst::Address &)\n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return false;\n}\n\nbool thread_db_thread::getStackSize(unsigned long &)\n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return false;\n}\n\nbool thread_db_thread::getTLSPtr(Dyninst::Address &)\n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return false;\n}\n\nbool thread_db_thread::plat_convertToSystemRegs(const int_registerPool &,\n                                                unsigned char *, bool)\n{\n   return true;\n}\n\nasync_ret_t thread_db_process::post_attach(bool b, set<response::ptr> &s) {\n   return int_process::post_attach(b, s);\n}\n\nasync_ret_t thread_db_process::post_create(std::set<response::ptr> &async_responses) {\n   return int_process::post_create(async_responses);\n}\n\nbool thread_db_process::plat_getLWPInfo(lwpid_t, void *) {\n   return false;\n}\n\nconst char *thread_db_process::getThreadLibName(const char *)\n{\n   return \"\";\n}\n\nvoid thread_db_process::freeThreadDBAgent() {\n}\n\nasync_ret_t thread_db_process::getEventForThread(int_eventThreadDB *) \n{\n   return aret_error;\n}\n\nbool thread_db_process::isSupportedThreadLib(string) {\n   return false;\n}\n\nbool thread_db_process::plat_supportThreadEvents() {\n   return false;\n}\n\nbool thread_db_process::setTrackThreads(bool, std::set<std::pair<int_breakpoint *, Address> > &,\n                                                 bool &)\n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return false;\n}\n\nbool thread_db_process::isTrackingThreads()\n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return false;\n}\n\nThreadTracking *thread_db_process::threaddb_getThreadTracking() \n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return NULL;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/dyninstAPI_RT/src/RTmutatedBinary_ELF.c": "/*\n * See the dyninst/COPYRIGHT file for copyright information.\n * \n * We provide the Paradyn Tools (below described as \"Paradyn\")\n * on an AS IS basis, and do not warrant its validity or performance.\n * We reserve the right to update, modify, or discontinue this\n * software at any time.  We shall have no obligation to supply such\n * updates or modifications or any other form of support to you.\n * \n * By your use of Paradyn, you understand and agree that we (or any\n * other person or entity with proprietary rights in Paradyn) are\n * under no obligation to provide either maintenance services,\n * update services, notices of latent defects, or correction of\n * defects for Paradyn.\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/* $Id: RTmutatedBinary_ELF.c,v 1.29 2007/07/11 17:58:24 ssuen Exp $ */\n\n/* this file contains the code to restore the necessary\n   data for a mutated binary \n */\n\n#include <stdlib.h>\n#include \"dyninstAPI_RT/h/dyninstAPI_RT.h\"\n#include <unistd.h>\n#include  <fcntl.h>\n#include <string.h>\n\n#include <libelf.h>\n\n\n\n#if defined(i386_unknown_linux2_0) \\\n || (defined(arch_power) && defined(os_linux)) \\\n || defined(x86_64_unknown_linux2_4) /* Blind duplication - Ray */\n#define __USE_GNU\n#endif\n\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <link.h> /* ccw 23 jan 2002 */\n#include <limits.h>\n\n#if defined(i386_unknown_linux2_0) \\\n   || defined(x86_64_unknown_linux2_4) /* Blind duplication - Ray */\nextern ElfW(Dyn) _DYNAMIC[];\n\n#endif\n\n/* Borrowed from Linux's link.h: Allows us to use functions from\n   libelf regardless of word size. */\n//#define ELF_FUNC(type)      _ELF_FUNC (elf, __ELF_NATIVE_CLASS, type)\n#define ELF_FUNC(type)      _ELF_FUNC (Elf, __ELF_NATIVE_CLASS, type)\n#define _ELF_FUNC(e,w,t)    _ELF_FUNC_1 (e, w, _##t)\n#define _ELF_FUNC_1(e,w,t)  e##w##t\n\ntypedef struct {\n      ElfW(Sword) d_tag;\n      union {\n          ElfW(Sword) d_val;\n          ElfW(Addr) d_ptr;\n      } d_un;\n  } __Elf_Dyn;\n\nunsigned long checkAddr;\n/*extern int isMutatedExec;\nchar *buffer;\n*/\n\nstruct link_map* map=NULL;\n\nchar *sharedLibraryInfo = NULL;\nunsigned int originalInsnBkpt;\nunsigned int addressBkpt;\n\n/* \tthis is not misnamed.  In the future, this function will contain\n\tcode to patch the instrumentation of a shared library that has \n\tbeen loaded into a different place during a mutated binary run.\n\n\tNow, it just exit()s, as you can see\n*/\n\nvoid fixInstrumentation(char* soName, unsigned long currAddr, unsigned long oldAddr){\n\tprintf(\" %s loaded at wrong address: 0x%lx (expected at 0x%lx) \\n\", soName, currAddr, oldAddr);\n\tprintf(\" This is an unrecoverable error, the instrumentation will not\");\n\tprintf(\"\\n run correctly if shared libraries are loaded at a different address\\n\");\n\tprintf(\"\\n Exiting.....\\n\");\n\tfflush(stdout);\n        //while(1);\n\t//exit(9);\n}\n\n/* \tthis function checks the shared library (soName) to see if it\n\tis currently loaded (loadAddr) at the same place it was before (address).\n\tIf the shared library is not found in the list (sharedLibraryInfo) that\n\tmean the shared library was *NOT* instrumented and can be loaded\n\tanywhere\n*/\nunsigned long checkSOLoadAddr(char *soName, unsigned long loadAddr){\n\tunsigned long result=0, found = 0;\n\tunsigned long address;\n\tchar *ptr = sharedLibraryInfo;\n\twhile(ptr &&  *ptr && !found ){\n\t\t/*fprintf(stderr,\" CHECKING FOR %s in %s\\n\", ptr, soName);*/\n\n        \tif(strstr(soName, ptr) || strstr(ptr,soName)){\n                \tfound = 1;\n\t\t\tptr += (strlen(ptr) +1);\n\t\t\tmemcpy(&address, ptr, sizeof(unsigned long)); \n\t\t\t/* previous line is done b/c of alignment issues on sparc*/\n\t\t\tif(loadAddr == address) {\n\t\t\t\tresult = 0;\n\t\t\t}else{\n\t\t\t\tresult = address;\n\t\t\t}\t\n\t\t}\n\n\t\tptr += (strlen(ptr) +1);\n\t\tptr += sizeof(unsigned long);\n\t\tptr += sizeof(unsigned long); /* for flag */\n\n\n\t}\n\tif(!found){\n\t\tresult = 0;\n\t\t/*fprintf(stderr,\" NOT FOUND %s\\n\",soName);*/\n\t}\n\n\t/*fprintf(stderr,\" checkSOLoadAddr: %s %lx %lx\\n\", soName, loadAddr, result);*/\n\treturn result;\n}\n\n\n#if defined(i386_unknown_linux2_0) \\\n || defined(x86_64_unknown_linux2_4) /* Blind duplication - Ray */\nunsigned long loadAddr;\nvoid (*dl_debug_state_func)(void);\n\nvoid dyninst_dl_debug_state(){\n\tasm(\"nop\");\n\tif(_r_debug.r_state == 1){\n\tdo {\n\t\t\tif(map->l_next){\n\t\t\t\tmap = map->l_next;\n\t\t\t}\n\t\t\tloadAddr = checkSOLoadAddr(map->l_name, (unsigned long)map->l_ld);/*l_addr*/\n\t\t\tif(loadAddr){\n\t\t\t\tfixInstrumentation(map->l_name, (unsigned long)map->l_ld, loadAddr);/*l_addr*/\n\t\t\t}\n\t\t}while(map->l_next);\n\n\t}\n\n\t/* the following call is used to call\n\t * _dl_debug_state to ensure correctness (if\n\t * someone relies on it being called it is\n\t * execuated after this function)\n\t * The value stored in dl_debug_state_func is\n\t * the address of the function _dl_debug_state\n\t * and is set in checkElfFile\n\t */\n\tasm(\"nop\");\n\tasm(\"nop\");\n\tasm(\"nop\");\n\t(*dl_debug_state_func)();\n\tasm(\"nop\");\n\n}\n\nvoid hack_ld_linux_plt(unsigned long pltEntryAddr){ \n/* this is ugly.\n * save the world needs to check each shared library\n * that is loaded to ensure that it is loaded at the\n * same base address it was loaded at when the mutator/mutatee\n * pair ran.  \n * So, we know dlopen calls _dl_debug_state per the r_debug\n * interface to let the process know a shared library has changed\n * state.\n * with this function we change the Procedure Linkage Table (.plt)\n * for ld-linux.so so that the entry that used to point to\n * _dl_debug_state points to dyninst_dl_debug_state.\n *\n * dyninst_dl_debug_state then calls _dl_debug_state before\n * exiting \n *\n * dont try this at home\n */\n\tunsigned long mprotectAddr = pltEntryAddr - (pltEntryAddr % getpagesize());\t\n\tunsigned long newTarget = (unsigned long) &dyninst_dl_debug_state ;\n\t\n\tmprotect( (void*) mprotectAddr, pltEntryAddr - mprotectAddr + sizeof(long), \n\t\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC);\n\n\tmemcpy( (void*) dl_debug_state_func, (void*) pltEntryAddr, sizeof(long)); \n\n\tmemcpy( (void*) pltEntryAddr, &newTarget, sizeof(long));\n}\n#endif\n\nunsigned (*Elf_version)(unsigned) = NULL;\nElf *(*Elf_begin)(int fildes, Elf_Cmd cmd, Elf *ref) = NULL;\nElf_Scn *(*Elf_getscn)(Elf *elf, size_t index) = NULL;\nElf_Data *(*Elf_getdata)(Elf_Scn *scn, Elf_Data *data) = NULL;\nElf_Scn *(*Elf_nextscn)(Elf *elf, Elf_Scn *scn) = NULL;\nElf32_Shdr *(*Elf32_getshdr)(Elf_Scn *scn) = NULL;\nElf32_Ehdr *(*Elf32_getehdr)(Elf *elf) = NULL;\nElf64_Shdr *(*Elf64_getshdr)(Elf_Scn *scn) = NULL;\nElf64_Ehdr *(*Elf64_getehdr)(Elf *elf) = NULL;\nconst char *(*Elf_errmsg)(int err) = NULL;\nint (*Elf_errno)(void) = NULL;\nint (*Elf_end)(Elf *elf) = NULL;\n\n\nint checkSO(char* soName){\n\tElfW(Shdr) *shdr;\n\tElfW(Ehdr) *   ehdr;\n    \tElf *          elf;\n\tint       fd;\n\tElf_Data *strData;\n\tElf_Scn *scn;\n\tint result = 0;\n\n \tif((fd = (int) open(soName, O_RDONLY)) == -1){\n\t\tRTprintf(\"cannot open : %s\\n\",soName);\n    \t\tfflush(stdout); \n\t\treturn result;\n\t}\n\tif((elf = Elf_begin(fd, ELF_C_READ, NULL)) ==NULL){\n\t\tRTprintf(\"%s %s \\n\",soName, Elf_errmsg(Elf_errno()));\n\t\tRTprintf(\"cannot elf_begin\\n\");\n\t\tfflush(stdout);\n\t\tclose(fd);\n\t\treturn result;\n\t}\n\n\tehdr = ELF_FUNC( getehdr(elf) );\n\tscn = Elf_getscn(elf, ehdr->e_shstrndx);\n\tstrData = Elf_getdata(scn,NULL);\n   \tfor( scn = NULL; !result && (scn = Elf_nextscn(elf, scn)); ){\n\t\tshdr = ELF_FUNC( getshdr(scn) );\n\t\tif(!strcmp((char *)strData->d_buf + shdr->sh_name, \".dyninst_mutated\")) {\n\t\t\tresult = 1;\n\t\t}\n\t}\n\tElf_end(elf);\n\tclose(fd);\n\n\treturn result;\n}\n\nint checkMutatedFile(){\n\n    /* Apparently a future section stomps on the tramp guard. Whoops. Instead,\n       we'll keep the address around and initialize the guard at the end. */\n    int *trampGuardBase_ = NULL;\n    int trampGuardSize_ = 0;\n\n\tElfW(Shdr) *shdr;\n\tElfW(Ehdr) *   ehdr;\n\tElf *          elf;\n\tint       cnt,fd;\n\tElf_Data *elfData,*strData;\n\tElf_Scn *scn;\n\tchar *execStr;\n\tint retVal = 0;\n\tunsigned long mmapAddr;\n\tint pageSize;\n\tAddress dataAddress;\n\tint dataSize;\n\tchar* tmpPtr;\n\tunsigned long updateAddress, updateSize, updateOffset;\n\tunsigned long *dataPtr;\n\tunsigned int numberUpdates,i ;\n\tchar* oldPageData;\n\tDl_info dlip;\n\tint soError = 0; \n\n     char * error_msg = NULL;\n     void * elfHandle = NULL;\n\n\t//fprintf(stderr,\"SBRK 0x%x\\n\",sbrk(1));;\n\n//     elfHandle = dlopen(\"/usr/lib/libelf.so.1\", RTLD_NOW);\n\n     elfHandle = dlopen(\"libelf.so\", RTLD_NOW);\n     if(! elfHandle){\n        error_msg = dlerror();\n        if (error_msg) {\n          //fprintf(stderr,\"Could not open lib: %s- %s\\n\",\"libelf\",error_msg);\n        }\n        else{\n          //fprintf(stderr, \"failure\\n\");\n        }\n\treturn 0;\n     }\n\n     Elf_version = (unsigned (*)(unsigned)) dlsym(elfHandle, \"elf_version\");\n     Elf_begin = (Elf *(*)(int,Elf_Cmd,Elf *)) dlsym(elfHandle, \"elf_begin\");\n     Elf_getscn = (Elf_Scn *(*)(Elf *, size_t)) dlsym(elfHandle, \"elf_getscn\");\n     Elf_nextscn = (Elf_Scn *(*)(Elf *, Elf_Scn *)) dlsym(elfHandle, \"elf_nextscn\");\n     Elf_getdata = (Elf_Data *(*)(Elf_Scn *, Elf_Data *)) dlsym(elfHandle, \"elf_getdata\");\n     Elf32_getehdr = (Elf32_Ehdr *(*)(Elf *)) dlsym(elfHandle, \"elf32_getehdr\");\n     Elf32_getshdr = (Elf32_Shdr *(*)(Elf_Scn *)) dlsym(elfHandle, \"elf32_getshdr\");\n     Elf64_getehdr = (Elf64_Ehdr *(*)(Elf *)) dlsym(elfHandle, \"elf64_getehdr\");\n     Elf64_getshdr = (Elf64_Shdr *(*)(Elf_Scn *)) dlsym(elfHandle, \"elf64_getshdr\");\n     Elf_errmsg = (const char *(*)(int)) dlsym(elfHandle, \"elf_errmsg\");\n     Elf_errno = (int (*)(void)) dlsym(elfHandle, \"elf_errno\");\n     Elf_end = (int (*)(Elf *)) dlsym(elfHandle, \"elf_end\");\n\n\tElf_version(EV_CURRENT);\n\n\texecStr = (char*) malloc(1024);\n\tmemset(execStr,'\\0',1024);\n\n#if defined(i386_unknown_linux2_0) \\\n   || defined(x86_64_unknown_linux2_4) /* Blind duplication - Ray */ \\\n   || (defined(os_linux) && defined(arch_power))\n\tsprintf(execStr,\"/proc/%d/exe\",getpid());\n#endif\n\n\tif((fd = (int) open(execStr, O_RDONLY)) == -1){\n\t\tprintf(\"cannot open : %s\\n\",execStr);\n    \t\tfflush(stdout); \n\t\treturn retVal;\n\t}\n\tif((elf = Elf_begin(fd, ELF_C_READ, NULL)) ==NULL){\n\t\tprintf(\"%s %s \\n\",execStr, Elf_errmsg( Elf_errno()));\n\t\tprintf(\"cannot Elf_begin\\n\");\n\t\tfflush(stdout);\n\t\tclose(fd);\n\t\treturn retVal;\n\t}\n\n\tehdr = ELF_FUNC( getehdr(elf) );\n\tscn = Elf_getscn(elf, ehdr->e_shstrndx);\n\tstrData = Elf_getdata(scn,NULL);\n\tpageSize =  getpagesize();\n\n\t/*fprintf(stderr,\"IN MUTATED FILE\\n\");*/\n   \tfor(cnt = 0, scn = NULL; !soError &&  (scn = Elf_nextscn(elf, scn));cnt++){\n\t\tshdr = ELF_FUNC( getshdr(scn) );\n\t\tif(!strncmp((char *)strData->d_buf + shdr->sh_name, \"dyninstAPItrampgu\", 17)) {\n\t\t\tdataAddress = shdr->sh_addr;\n\t\t\telfData = Elf_getdata(scn, NULL);\n\t\t\ttmpPtr = elfData->d_buf;\n\t\t\t//fprintf(stderr,\"tramp guard addr %x, tmpPtr %p (%d)\\n\", dataAddress, tmpPtr, *tmpPtr);\n                        trampGuardBase_ = (int *)dataAddress;\n                        trampGuardSize_ = *(int *)tmpPtr;\n\n\n\t\t\t/* \twe already own it. \n\t\n\t\t\t\tbecause we have moved the start of the heap beyond this address\n\t\t\t*/\n\n\t\t\t/* set tramp guard to 1 */\n\t\t\tfor(i=0;i<*(int*)tmpPtr;i++){\n                            ((unsigned*) dataAddress)[i]=1;\n                        }\n                        /* This may get reverted, so we'll re-do the work below. */\n\n\t\t}else if(!strncmp((char *)strData->d_buf + shdr->sh_name, \"dyninstAPI_data\", 15)) {\n\t\t\telfData = Elf_getdata(scn, NULL);\n\t\t\ttmpPtr = elfData->d_buf;\n\t\t\tdataAddress = -1;\n\t\t\twhile( dataAddress != 0 ) { \n\t\t\t\t/*tmpPtr may not be aligned on the correct boundry\n\t\t\t\tso use memcpy to set dataSize\n\t\t\t\tdataSize = *(int*) tmpPtr;*/\n\t\t\t\tmemcpy((char*) & dataSize, tmpPtr, sizeof(int));\n\n\t\t\t\ttmpPtr+=sizeof(int);\n\t\t\t\tmemcpy( (char*) & dataAddress, tmpPtr, sizeof(Address));\n\n\t\t\t\ttmpPtr += sizeof(Address);\n\t\t\t\tif(dataAddress){\n\t\t\t\t\tmemcpy((char*) dataAddress, tmpPtr, dataSize);\n\n\t\t\t\t\ttmpPtr += dataSize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else if(!strncmp((char *)strData->d_buf + shdr->sh_name, \"dyninstAPI_\",11)){ \n\t\t\tchar *tmpStr = strchr((char *)strData->d_buf + shdr->sh_name, (int)'_'); ;\n\n\t\t\ttmpStr ++;\n\n\t\t\tif( *tmpStr>=0x30 && *tmpStr <= 0x39 ) {\n\t\t\t\t/* we dont want to do this unless this is a dyninstAPI_### section\n\t\t\t\t\tspecifically, dont do this for dyninstAPI_SharedLibraries*/\n\t\t\t\tretVal = 1; /* this is a restored run */\n\n\t\t\t\tif( *tmpStr>=0x30 && *tmpStr <= 0x39 ) {\n\t\t\t\t\t/* this is a heap tramp section */\n\n\t\t\t\t\t/* \tthe new starting address of the heap is immediately AFTER the last\n\t\t\t\t\t\tdyninstAPI_### section, so we can ALWAYS memcpy the data into place\n\t\t\t\t\t\tsee the value of newHeapAddr in writeBackElf.C\n\t\t\t\t\t*/\n\t\t\t\t\telfData = Elf_getdata(scn, NULL);\n\t\t\t\t\tmemcpy((void*)shdr->sh_addr, elfData->d_buf, shdr->sh_size);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!strcmp((char *)strData->d_buf + shdr->sh_name, \"dyninstAPI_mutatedSO\")){\n\t\t\t/* make sure the mutated SOs are loaded, not the original ones */\n\t\t\tchar *soNames;\n\t\t\tint mutatedFlag = 0;\n\t\t\tint totallen=0;\n#if defined(i386_unknown_linux2_0) \\\n   || (defined(arch_power) && defined(os_linux)) \\\n   || defined(x86_64_unknown_linux2_4) /* Blind duplication - Ray */\n\t\t\tstruct link_map *lmap=0;\n#endif\n\t\t\tchar *loadedname, *dyninstname;\n\n\t\t\telfData = Elf_getdata(scn, NULL);\n\n\t\t\tsharedLibraryInfo = (char*) malloc(elfData->d_size);\n\t\t\tmemcpy(sharedLibraryInfo, elfData->d_buf, elfData->d_size);\n\t\t\tlmap = _r_debug.r_map;\n\n\t\t\tfor(soNames = (char*) elfData->d_buf ; totallen<elfData->d_size; \n\t\t\t\tsoNames = &((char*) elfData->d_buf)[strlen(soNames)+1+sizeof(unsigned int) +sizeof(unsigned int)]){\n\t\t\t\t/* added a +sizeof(unsigned int) above for flag */\n\t\t\t\ttotallen += strlen(soNames) + 1 + sizeof(unsigned int) +sizeof(unsigned int); /*for flag*/\n\t\t\t\tmemcpy(&mutatedFlag, &((char*) elfData->d_buf)[totallen-sizeof(unsigned int)], sizeof(unsigned int));\n\t\t\t\tlmap = _r_debug.r_map;\n\t\t\t\twhile(lmap){\n\t\t\t\t\tloadedname = strrchr(lmap->l_name,'/');\n\t\t\t\t\tdyninstname =  strrchr((const char *)soNames,(int)'/');\n\t\t\t\t\tif(loadedname == 0){\n\t\t\t\t\t\tloadedname = lmap->l_name;\n\t\t\t\t\t}\n\t\t\t\t\tif(dyninstname == 0){\n\t\t\t\t\t\tdyninstname = soNames;\n\t\t\t\t\t}\t\n\t\t\t\t\tif(mutatedFlag && !strcmp(loadedname, dyninstname)) {\n\t\t\t\t\t\tif(!checkSO(lmap->l_name)){\n\t\t\tprintf(\"ERROR: %s was mutated during saveworld and\",lmap->l_name);\n\t\t\tprintf(\" the currently loaded %s has not been mutated\\n\", lmap->l_name);\n\t\t\tprintf(\" check your LD path to be sure the mutated %s is visible\\n\", soNames);\n\t\t\t\t\t\t\tsoError = 1;\n\t\t\n\t\t\t\t\t\t}\n\n\t\t\n\t\t\t\t\t}\n\t\t\t\t\tlmap = lmap->l_next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!strcmp((char *)strData->d_buf + shdr->sh_name, \"rtlib_addr\")){\n\t\t\tunsigned int ptr;\n\t\t\tint done = 0;\n\n\n\t\t\telfData = Elf_getdata(scn, NULL);\n\n\t\t\t/*ptr = elfData->d_buf;*/\n\t\t\t/* use memcpy because of alignment issues on sparc */\t\n\t\t\tmemcpy(&ptr,elfData->d_buf,sizeof(unsigned int));\n\n\t\n\t\t\tmap = _r_debug.r_map;\n\n\t\t\twhile(map && !done){\n\t\t\t\t/*fprintf(stderr,\"CHECKING %s 0x%x\\n\", map->l_name,map->l_addr);*/\n\t\t\t\tif( * map->l_name  && strstr(map->l_name, \"libdyninstAPI_RT\")){\n\t\t\t\t\tunsigned long loadaddr = (unsigned long)map->l_addr;\n\n\t\t\t\t\t/* \tLINUX PROBLEM. in the link_map structure the map->l_addr field is NOT\n\t\t\t\t\t\tthe load address of the dynamic object, as the documentation says.  It is the\n\t\t\t\t\t\tRELOCATED address of the object. If the object was not relocated then the\n\t\t\t\t\t\tvalue is ZERO.\n\n\t\t\t\t\t\tSo, on LINUX we check the address of the dynamic section, map->l_ld, which is\n\t\t\t\t\t\tcorrect.\n\t\t\t\t\t*/\n#if defined(i386_unknown_linux2_0) || defined(x86_64_unknown_linux2_4)\n\t\t\t\t\tloadaddr = (unsigned long)map->l_ld;\n#endif\n\n\t\t\t\t\t/*fprintf(stderr,\" loadadd %x ptr %x\\n\", loadaddr, ptr);*/\n\t\t\t\t\tif( loadaddr !=  (ptr)){\n\t\t\t\t\t\tfixInstrumentation(map->l_name, loadaddr,  (ptr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* check every loaded SO but leave map such that map->l_next == NULL.\n\t\t\t\t\tThe next time a SO is loaded it will be placed at \n\t\t\t\t\tmap->l_next, so keep a tail pointer such that we \n\t\t\t\t\tdont need to loop through the entire list again\n\t\t\t\t*/\n\t\t\t\tif(map->l_next){\n\t\t\t\t\tmap = map->l_next;\n\t\t\t\t}else{\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!strcmp((char *)strData->d_buf + shdr->sh_name, \"dyninstAPI_SharedLibraries\")){\n\t\t\tunsigned long diffAddr;\n\t\t\tunsigned long ld_linuxBaseAddr;\n\t\t\tchar *ptr;\n\t\t\tint done = 0;\n\n\n\t\t\telfData = Elf_getdata(scn, NULL);\n\n\t\t\tptr = elfData->d_buf;\n\t\t\n\t\t\tmap = _r_debug.r_map;\n\n\t\t\twhile(map && !done){\n\t\t\t\tif( map->l_name && * map->l_name ){\n\t\t\t\t\tunsigned int loadaddr = map->l_addr;\n\n\t\t\t\t\t/* \tLINUX PROBLEM. in the link_map structure the map->l_addr field is NOT\n\t\t\t\t\t\tthe load address of the dynamic object, as the documentation says.  It is the\n\t\t\t\t\t\tRELOCATED address of the object. If the object was not relocated then the\n\t\t\t\t\t\tvalue is ZERO.\n\n\t\t\t\t\t\tSo, on LINUX we check the address of the dynamic section, map->l_ld, which is\n\t\t\t\t\t\tcorrect.\n\t\t\t\t\t*/\n#if defined(i386_unknown_linux2_0) || defined(x86_64_unknown_linux2_4)\n\t\t\t\t\tloadaddr = (unsigned long)map->l_ld;\n#endif\n\n\t\t\t\t\t/*fprintf(stderr,\" CHECKING: %s %x\\n\",map->l_name, map->l_addr);*/\n\t\t\t\t\tdiffAddr = checkSOLoadAddr(map->l_name, loadaddr);\n\t\t\t\t\tif(diffAddr){\n\t\t\t\t\t\tfixInstrumentation(map->l_name, loadaddr, diffAddr);\n\t\t\t\t\t}\n#if defined(i386_unknown_linux2_0) \\\n || defined(x86_64_unknown_linux2_4) /* Blind duplication - Ray */\n\t\t\t\t\t/* ld-linux.so will never be hand relocated so l_addr should be correct. right? */\n\t\t\t\t\tif(strstr(map->l_name, \"ld-linux.so\")){\n\t\t\t\t\t\tld_linuxBaseAddr = map->l_addr;\n\t\t\t\t\t}\t\n#endif\n\t\t\t\t}\n\t\t\t\t/* check every loaded SO but leave map such that map->l_next == NULL.\n\t\t\t\t\tThe next time a SO is loaded it will be placed at \n\t\t\t\t\tmap->l_next, so keep a tail pointer such that we \n\t\t\t\t\tdont need to loop through the entire list again\n\t\t\t\t*/\n\t\t\t\tif(map->l_next){\n\t\t\t\t\tmap = map->l_next;\n\t\t\t\t}else{\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( shdr->sh_addr != 0){\n\t\t\t\t/* if the addr is zero, then there is \n\t\t\t\t\tno PLT entry for dlopen.  if there is\n\t\t\t\t\tno entry for dlopen the mutatee must not\n\t\t\t\t\tcall it.  -- what about calling it from\n\t\t\t\t\ta shared lib that is statically loaded?\n\t\t\t\t*/\n\n\t\t\t/* WHY IS THERE A POUND DEFINE HERE? \n\n\t\t\t\twell, we need to intercept the dlopen calls from the mutated binary\n\t\t\t\tbecause our trampolines expect the shared libraries to be in\n\t\t\t\ta particular location and if they are not where they are expected\n\t\t\t\tour trampolines can jump off into nothingness, or even worse, some\n\t\t\t\trandom bit of executable code.  \n\n\t\t\t\tSo we must intercept the dlopen call and then check to be sure\n\t\t\t\tthe shared libraries are loaded in the same place as before.  If\n\t\t\t\tthey are not we exit with a message to the user saying this is\n\t\t\t\ta fatal error.\n\t\t\n\t\t\t\tNote, only shared libraries that have been instrumented are checked\n\t\t\t\there.  \n\t\t\t*/\n\n#if defined(i386_unknown_linux2_0) \\\n   || defined(x86_64_unknown_linux2_4) /* Blind duplication - Ray */\n\t\t\t/* install jump to catch call to _dl_debug_state */\n\t\t\t/* see comment int hack_ld_linux_plt for explainations */\n\t\t\thack_ld_linux_plt(ld_linuxBaseAddr + shdr->sh_addr); \n#endif\n\t\t}/* shdr->sh_addr != 0 */ \n\t\t}\n\t\tif( !strncmp((char *)strData->d_buf + shdr->sh_name, \"dyninstAPIhighmem_\",18)){\n\t\t\t/*the layout of dyninstAPIhighmem_ is:\n\t\t\tpageData\n\t\t\taddress of update\n\t\t\tsize of update\n\t\t\t...\t\n\t\t\taddress of update\n\t\t\tsize of update\t\n\t\t\tnumber of updates\n\t\n\t\t\twe must ONLY overwrite the updates, the other\n\t\t\tareas of the page may be important (and different than\n\t\t\tthe saved data in the file.  we first copy out the\n\t\t\tpage, the apply the updates to it, and then\n\t\t\twrite it back.\n\t\t\t*/\n\n\t\t\tint oldPageDataSize;\n\t\t\tint count =0;\n\n\t\t\tretVal = 1; /* just to be sure */\n\t\t\telfData = Elf_getdata(scn, NULL);\n\t\t\tnumberUpdates = 0;\n\t\t\t\n\t\t\t/*this section may be padded out with zeros to align the next section\n\t\t\t  so we need to look backwards until we find a nonzero value */\n\t\t\twhile(numberUpdates == 0){\n\t\t\t\tcount++;\n\t\t\t\tnumberUpdates = (unsigned int) ( ((unsigned int*) elfData->d_buf)[\n\t\t\t\t\t(elfData->d_size - (sizeof(unsigned int)*count))/ sizeof(unsigned int) ]);\n\t\t\t}\n\n\t\t\t/*fprintf(stderr,\" numberUpdates: %d :: (%d - 4) / 4  %x\\n\", numberUpdates, elfData->d_size, (unsigned int*) &elfData->d_buf );*/\n\n\t\t\toldPageDataSize = shdr->sh_size-(((2*numberUpdates)* sizeof(unsigned int)) +((sizeof(unsigned int)*count))) ;\n\n\n\t\t\toldPageData = (char*) malloc(oldPageDataSize+sizeof(unsigned long));\n\t\t\t/*fprintf(stderr,\"oldpagedatasize %d datasize %d \\n\",oldPageDataSize,elfData->d_size);\n\t\t\tperror(\"malloc\");*/\n\t\t\t/*copy old page data */\n\n\n\t\t\t/* probe memory to see if we own it */\n\t\t\tcheckAddr = dladdr((void*)shdr->sh_addr, &dlip);\n\n\n\t\t\tupdateSize  = shdr->sh_size-((2*numberUpdates)* (sizeof(unsigned int)) -(count* (sizeof(unsigned int))));\n\t\t\t/*fprintf(stderr,\" updateSize : %d-((2 * %d + 1) * 4))\",shdr->sh_size, numberUpdates);*/\n\t\n\t\t\tif(!checkAddr){ \n\t\t\t\t/* we dont own it,mmap it!*/\n\n                        \tmmapAddr = shdr->sh_offset;\n                        \tmmapAddr =(unsigned long) mmap((void*) shdr->sh_addr,oldPageDataSize,\n                                \tPROT_READ|PROT_WRITE|PROT_EXEC,MAP_FIXED|MAP_PRIVATE,fd,mmapAddr);\n\t\t\t\t\t/*fprintf(stderr,\"MMAP %x %d %x size: %x\\n\",shdr->sh_addr, mmapAddr,shdr->sh_offset,oldPageDataSize);*/\n\t\t\t\t\t\n\n\t\t\t}else{\n\t\t\t\t/*we own it, finish the memcpy */\n\t\t\t\tmmapAddr = (unsigned long) memcpy((void*) oldPageData, \n                                      (const void*) shdr->sh_addr, oldPageDataSize);\n\t\t\t\t/*fprintf(stderr,\"memcpy %x %d\\n\",shdr->sh_addr, updateSize);*/\n\n\t\t\t}\n\n\t\t\tdataPtr =(unsigned long *) &(((char*)  elfData->d_buf)[oldPageDataSize]);\t\n\t\t\t/*apply updates*/\n\t\t\tfor(i = 0; i< numberUpdates; i++){\n\t\t\t\tupdateAddress = *dataPtr; \n\t\t\t\tupdateSize = *(++dataPtr);\n\n\t\t\t\tupdateOffset = updateAddress - shdr->sh_addr;\n\t\t\t\t/*do update*/\t\n\t\t\t\t/*fprintf(stderr,\"updateAddress %x : %x %x %d %d\\n\",updateAddress,&( oldPageData[updateOffset]), &(((char*)elfData->d_buf)[updateOffset]) , updateSize,updateOffset);*/\n\t\t\t\tmemcpy(&( oldPageData[updateOffset]),\n\t\t\t\t\t\t&(((char*)elfData->d_buf)[updateOffset]) , updateSize);\t\n\n\t\t\t\tdataPtr ++;\n\n\t\t\t\n\t\t\t} \n\t\t\tif(!checkAddr){\n\t\t\t\tmmapAddr = shdr->sh_offset ;\n\n\t\t\t\tmmapAddr =(unsigned long) mmap((void*) shdr->sh_addr,oldPageDataSize, \n\t\t\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC, MAP_FIXED| MAP_PRIVATE,fd,mmapAddr);\n\n\t\t\t\t\t/*fprintf(stderr,\"2MMAP %x %d\\n\",shdr->sh_addr, mmapAddr);*/\n\n\n\t\t\t}else{\n\n\t\t\t\tmemcpy((void*) shdr->sh_addr, oldPageData,oldPageDataSize );\n\t\t\t\t/*fprintf(stderr,\"2memcpy %x %d\\n\",shdr->sh_addr, oldPageDataSize);*/\n\n\t\t\t}\n\t\t}\n\t\tif(!strcmp((char *)strData->d_buf + shdr->sh_name, \"dyninstAPI_loadLib\")){\n\t\t\t/* ccw 14 may 2002 */\n\t\t\t/* this section loads shared libraries into the mutated binary\n\t\t\t\tthat were loaded by BPatch_thread::loadLibrary */\n\t\t\tvoid * handle =NULL;\n\t\t\telfData = Elf_getdata(scn, NULL);\n\t\t\ttmpPtr = elfData->d_buf;\n\n\t\t\twhile(*tmpPtr) { \n\t\t\t\thandle = dlopen(tmpPtr, RTLD_LAZY);\n\t\t\t\tif(handle){\n\n\t\t\t\t}else{\n\n\t\t\t\t\tprintf(\" %s cannot be loaded at the correct address\\n\", tmpPtr );\n\t\t\t\t\tprintf(\" This is an unrecoverable error, the instrumentation will not\");\n\t\t\t\t\tprintf(\"\\n run correctly if shared libraries are loaded at a different address\\n\");\n\t\t\t\t\tprintf(\"\\n Exiting.....\\n\");\n\n\t\t\t\t\tprintf(\"\\n%s\\n\",dlerror());\n\t\t\t\t\tfflush(stdout);\n\t\t\t\t\texit(9);\n\n\t\t\t\t}\n                                /* brk ptr not used for ELF */\n\t\t\t\ttmpPtr += (strlen(tmpPtr) +1 + sizeof(void *));\t\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\n        Elf_end(elf);\n        close(fd);\n\n\tfree(execStr);\n\n\tif(soError){\n\t\texit(2);\n\t}\n\n        for(i=0;i < trampGuardSize_; i++){\n            trampGuardBase_[i]=1;\n        }\n        \n\treturn retVal;\n}\n/* vim:set ts=5: */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/symtabAPI/doc/paradyn_logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/symtabAPI/doc/symtabapi.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/symtabAPI/doc/symtab-text.txt",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/symtabAPI/doc/API/Symtab/.DS_Store",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/patchAPI/doc/paradyn_logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/patchAPI/doc/patchapi.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/patchAPI/doc/figure/abstraction/img.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/patchAPI/doc/figure/command/img.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/.git/objects/pack/pack-593da7349d733fdcdb7163ec158abe109f63e7ae.pack",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/.git/objects/pack/pack-593da7349d733fdcdb7163ec158abe109f63e7ae.idx",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/parseAPI/doc/paradyn_logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/parseAPI/doc/parseapi.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/stackwalk/doc/paradyn_logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/stackwalk/doc/stackwalkerapi.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/paradyn_logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/instructionapi.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/fig/instruction_representation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/fig/ownership_graph.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/fig/refman.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/fig/decoder_use.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/fig/full_inheritance_graph.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/fig/deref-eval.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/fig/ast_ownership.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/dynC_API/doc/paradyn_logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/dynC_API/doc/dyncapi.pdf"
    ],
    "total_files": 1164
}