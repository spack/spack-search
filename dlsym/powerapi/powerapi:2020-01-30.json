{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-powerapi-2020-01-30-giwlssthujnxpyczqytcu32zk42zyssv/spack-src/src/pwr/pluginMeta.h": "/*\n * Copyright 2014-2016 Sandia Corporation. Under the terms of Contract\n * DE-AC04-94AL85000, there is a non-exclusive license for use of this work\n * by or on behalf of the U.S. Government. Export of this program may require\n * a license from the United States Government.\n *\n * This file is part of the Power API Prototype software package. For license\n * information, see the LICENSE file in the top level directory of the\n * distribution.\n*/\n\n#include <dlfcn.h>\n#include <map>\n#include <set>\n//#include <deque>\n#include <vector>\n#include \"util.h\"\n#include \"pwrdev.h\"\n\n#ifndef _PLUGINMETA_H\n#define _PLUGINMETA_H\n\nclass PluginMeta {\n\tstruct Object {\n\t};\n  public:\n\tPluginMeta( std::string libName ) {\n\n    \tvoid* m_lib = dlopen( libName.c_str(), RTLD_LAZY);\n\t\tif ( NULL == m_lib ) {\n\t\t\tprintf(\"%s() could not open %s\\n\",__func__,libName.c_str());\n\t\t\texit(-1);\n\t\t}\n\t\tassert(m_lib);\n\n    \tgetMetaFuncPtr_t func =   (getMetaFuncPtr_t)dlsym(m_lib, GETMETAFUNC );\n    \tassert(func);\n\n    \tm_meta = (*func)();\n\n    \t//printf(\"%d\\n\",meta->numObjs());\n\t    //std::vector< PWR_ObjType > objs( meta->numObjs() );\n\n\t\tm_objVec.resize( m_meta->numObjs() );\n   \t\tm_meta->readObjs( m_objVec.size(), &m_objVec[0] );\n    \tfor ( unsigned i = 0; i < m_objVec.size(); i++ ) {\n\t\t\tstd::vector< PWR_AttrName > attrs( m_meta->numAttrs(m_objVec[i]) );\n        \t//printf(\"%s\\n\", objTypeToString( m_objVec[i] ) );\n\t\t\t\n        \tm_meta->readAttrs( m_objVec[i], attrs.size(), &attrs[0]);\n        \tfor ( unsigned j = 0; j < attrs.size(); j++ ) {\n            \t//printf(\"add %s %s\\n\", objTypeToString( m_objVec[i] ), \n\t\t\t\t//\t\t\tattrNameToString(attrs[j]));\n\t\t\t\tm_objMap[ m_objVec[i] ].insert( attrs[j] ); \n        \t}\n\t\t}\n\t}\n    ~PluginMeta() {\n        dlclose( m_lib );\n    }\n\n\tbool findAttr( PWR_ObjType type, PWR_AttrName attr ) {\n\t\tstd::string retval;\t\n\t\tif ( m_objMap.find( type ) != m_objMap.end() ) {\n\t\t\tif ( m_objMap[type].find( attr ) != m_objMap[type].end() ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n    std::string getPluginName( ) {\n\t\tchar buf[100];\n        m_meta->getPluginName( 100, buf ); \n        return buf; \n    }\n\t\n    std::string getDevInitStr( std::string devName ) {\n        std::string ret(100,' '); \n        m_meta->getDevInitStr( &devName[0], 100, &ret[0] );  \n        return ret; \n    }\n\n    std::string getDevName( PWR_ObjType type ) {\n        std::string ret(100,' '); \n        m_meta->getDevName( type, 100, &ret[0] ); \n        return ret; \n    }\n\n    std::string getDevOpenStr( PWR_ObjType type, int global_index  ) {\n        std::string ret(100,' '); \n        m_meta->getDevOpenStr( type, global_index, 100, &ret[0] );\n        return ret; \n    }\n\n    bool isObjectSupported( PWR_ObjType obj, PWR_AttrName attr ) {\n        return m_objMap.find(obj) != m_objMap.end() &&\n\t\t\t\tm_objMap[obj].find(attr) != m_objMap[obj].end();\n    }\n    \n\n  private:\n    void*           m_lib;\n   \tplugin_meta_t*  m_meta;\n    std::map< PWR_ObjType,std::set<PWR_AttrName> > m_objMap;\n\tstd::vector< PWR_ObjType > \t\t\t\t\t   m_objVec;\n};\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-powerapi-2020-01-30-giwlssthujnxpyczqytcu32zk42zyssv/spack-src/src/pwr/dynamic.cc": "/*\n * Copyright 2014-2016 Sandia Corporation. Under the terms of Contract\n * DE-AC04-94AL85000, there is a non-exclusive license for use of this work\n * by or on behalf of the U.S. Government. Export of this program may require\n * a license from the United States Government.\n *\n * This file is part of the Power API Prototype software package. For license\n * information, see the LICENSE file in the top level directory of the\n * distribution.\n*/\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"distCntxt.h\"\n#include \"debug.h\"\n#include \"pwrdev.h\"\n\nusing namespace PowerAPI;\n\nplugin_dev_t* DistCntxt::getDev( std::string lib, std::string name )\n{\n\tDBGX(\"lib %s name=`%s`\\n\", lib.c_str(), name.c_str() );\n    void* ptr = dlopen( lib.c_str(), RTLD_LAZY);\n    if ( NULL == ptr ) {\n        printf(\"error: can't find plugin library `%s`\\n\", lib.c_str());\n        exit(-1);\n    }\n\n    getDevFuncPtr_t funcPtr = (getDevFuncPtr_t) dlsym( ptr, GETDEVFUNC ); \n\tassert(funcPtr);\n\treturn funcPtr();\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-powerapi-2020-01-30-giwlssthujnxpyczqytcu32zk42zyssv/spack-src/.git/objects/pack/pack-5924218bcf3917f9004f3b64e3f47b846e41d204.idx",
        "/tmp/vanessa/spack-stage/spack-stage-powerapi-2020-01-30-giwlssthujnxpyczqytcu32zk42zyssv/spack-src/.git/objects/pack/pack-5924218bcf3917f9004f3b64e3f47b846e41d204.pack"
    ],
    "total_files": 256
}