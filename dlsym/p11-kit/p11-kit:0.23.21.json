{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/common/compat.h": "/*\n * Copyright (c) 2011 Collabora Ltd.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *     * Redistributions of source code must retain the above\n *       copyright notice, this list of conditions and the\n *       following disclaimer.\n *     * Redistributions in binary form must reproduce the\n *       above copyright notice, this list of conditions and\n *       the following disclaimer in the documentation and/or\n *       other materials provided with the distribution.\n *     * The names of contributors to this software may not be\n *       used to endorse or promote products derived from this\n *       software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Author: Stef Walter <stefw@collabora.co.uk>\n */\n\n#ifndef __COMPAT_H__\n#define __COMPAT_H__\n\n#include \"config.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#if !defined(__cplusplus) && (__GNUC__ > 2)\n#define GNUC_PRINTF(x, y) __attribute__((__format__(__printf__, x, y)))\n#else\n#define GNUC_PRINTF(x, y)\n#endif\n\n#if __GNUC__ >= 4\n#define GNUC_NULL_TERMINATED __attribute__((__sentinel__))\n#else\n#define GNUC_NULL_TERMINATED\n#endif\n\n#if (201112L <= __STDC_VERSION__ \\\n     || (!defined __STRICT_ANSI__ && 4 < __GNUC__ + (6 <= __GNUC_MINOR__)))\n# define P11_STATIC_ASSERT(x) _Static_assert(x, \"static assertion failed\")\n#else\n# define P11_STATIC_ASSERT(x)\n#endif\n\n/* For detecting clang features */\n#ifndef __has_feature\n#define __has_feature(x) 0\n#endif\n\n#ifndef CLANG_ANALYZER_NORETURN\n#if __has_feature(attribute_analyzer_noreturn)\n#define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn))\n#else\n#define CLANG_ANALYZER_NORETURN\n#endif\n#endif\n\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\n#ifndef O_CLOEXEC\n#define O_CLOEXEC 0\n#endif\n\n#ifndef HAVE_GETPROGNAME\nconst char * getprogname (void);\n#endif\n\n#ifndef HAVE_MKSTEMP\n\nint          mkstemp     (char *template);\n\n#endif /* HAVE_MKSTEMP */\n\n#ifndef HAVE_MKDTEMP\n\nchar *       mkdtemp     (char *template);\n\n#endif /* HAVE_MKDTEMP */\n\nchar *       strdup_path_mangle (const char *template);\n\nvoid         p11_dl_close       (void * dl);\n\n/* -----------------------------------------------------------------------------\n * WIN32\n */\n\n#ifdef OS_WIN32\n\n#ifndef _WIN32_WINNT\n#define _WIN32_WINNT 0x500\n#endif\n\n#ifndef _WIN32_IE\n#define _WIN32_IE 0x500\n#endif\n\n#define WIN32_LEAN_AND_MEAN 1\n#include <windows.h>\n\n#include <io.h>\n\n/* Oh ... my ... god */\n#undef CreateMutex\n\ntypedef CRITICAL_SECTION p11_mutex_t;\n\ntypedef HANDLE p11_thread_t;\n\ntypedef DWORD p11_thread_id_t;\n\n#define P11_RECURSIVE_MUTEX_INIT(m) \\\n\t(InitializeCriticalSection (&m))\n#define p11_mutex_init(m) \\\n\t(InitializeCriticalSection (m))\n#define p11_mutex_lock(m) \\\n\t(EnterCriticalSection (m))\n#define p11_mutex_unlock(m) \\\n\t(LeaveCriticalSection (m))\n#define p11_mutex_uninit(m) \\\n\t(DeleteCriticalSection (m))\n\ntypedef void * (*p11_thread_routine) (void *arg);\n\nint p11_thread_create (p11_thread_t *thread, p11_thread_routine, void *arg);\n\nint p11_thread_join (p11_thread_t thread);\n\n/* Returns a thread_id_t */\n#define p11_thread_id_self() \\\n\t(GetCurrentThreadId ())\n\ntypedef HMODULE dl_module_t;\n\n#define p11_dl_open(f) \\\n\t(LoadLibrary (f))\n#define p11_dl_symbol(d, s) \\\n\t((void *)GetProcAddress ((d), (s)))\n\nchar *    p11_dl_error       (void);\n\n#define p11_sleep_ms(ms) \\\n\t(Sleep (ms))\n\ntypedef struct _p11_mmap p11_mmap;\n\np11_mmap *  p11_mmap_open   (const char *path,\n                             struct stat *sb,\n                             void **data,\n                             size_t *size);\n\nvoid        p11_mmap_close  (p11_mmap *map);\n\n#ifndef HAVE_SETENV\n#define setenv(n, v, z) _putenv_s(n, v)\n#endif /* HAVE_SETENV */\n\n#endif /* OS_WIN32 */\n\n/* ----------------------------------------------------------------------------\n * UNIX\n */\n\n#ifdef OS_UNIX\n\n#include <pthread.h>\n#include <dlfcn.h>\n#include <time.h>\n#include <unistd.h>\n\ntypedef pthread_mutex_t p11_mutex_t;\n\n#ifdef PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP\n\n/* No implementation, because done by static initializer */\n#define P11_RECURSIVE_MUTEX_INIT(mutex)\n\n#else\n\n#define P11_RECURSIVE_MUTEX_INIT(mutex) \\\n\t(p11_recursive_mutex_init (&(mutex)))\n\nvoid        p11_recursive_mutex_init          (p11_mutex_t *mutex);\n\n#endif\n\n#define p11_mutex_init(m) \\\n\t(pthread_mutex_init (m, NULL))\n#define p11_mutex_lock(m) \\\n\t(pthread_mutex_lock (m))\n#define p11_mutex_unlock(m) \\\n\t(pthread_mutex_unlock (m))\n#define p11_mutex_uninit(m) \\\n\t(pthread_mutex_destroy(m))\n\ntypedef pthread_cond_t p11_cond_t;\n\n#define p11_cond_init(c) \\\n\t(pthread_cond_init (c, NULL))\n#define p11_cond_wait(c, m) \\\n        (pthread_cond_wait (c, m))\n#define p11_cond_signal(c) \\\n        (pthread_cond_signal (c))\n#define p11_cond_broadcast(c) \\\n        (pthread_cond_broadcast (c))\n#define p11_cond_uninit(c) \\\n        (pthread_cond_destroy (c))\n\ntypedef pthread_t p11_thread_t;\n\ntypedef pthread_t p11_thread_id_t;\n\ntypedef void * (*p11_thread_routine) (void *arg);\n\n#define p11_thread_create(t, r, a) \\\n\t(pthread_create ((t), NULL, (r), (a)))\n#define p11_thread_join(t) \\\n\t(pthread_join ((t), NULL))\n#define p11_thread_id_self(m) \\\n\t(pthread_self ())\n\ntypedef void * dl_module_t;\n\n#define p11_dl_open(f) \\\n\t(dlopen ((f), RTLD_LOCAL | RTLD_NOW))\n#define p11_dl_symbol(d, s) \\\n\t(dlsym ((d), (s)))\n\nchar * p11_dl_error (void);\n\n#define p11_sleep_ms(ms) \\\n\tdo { int _ms = (ms); \\\n\tstruct timespec _ts = { _ms / 1000, (_ms % 1000) * 1000 * 1000 }; \\\n\tnanosleep (&_ts, NULL); \\\n\t} while(0)\n\ntypedef struct _p11_mmap p11_mmap;\n\np11_mmap *  p11_mmap_open   (const char *path,\n                             struct stat *sb,\n                             void **data,\n                             size_t *size);\n\nvoid        p11_mmap_close  (p11_mmap *map);\n\n#endif /* OS_UNIX */\n\n/* ----------------------------------------------------------------------------\n * MORE COMPAT\n */\n\n#ifdef\tHAVE_ERRNO_H\n#include <errno.h>\n#endif\t/* HAVE_ERRNO_H */\n\n#ifndef HAVE_STRNSTR\n\nchar *     strnstr          (const char *s,\n                             const char *find,\n                             size_t slen);\n\n#endif /* HAVE_STRNSTR */\n\n#ifndef HAVE_MEMDUP\n\nvoid *     memdup           (const void *data,\n                             size_t length);\n\n#endif /* HAVE_MEMDUP */\n\n#ifndef HAVE_STRNDUP\n\nchar *     strndup          (const char *data,\n                             size_t length);\n\n#endif /* HAVE_STRDUP */\n\n#if defined HAVE_DECL_REALLOCARRAY && !HAVE_DECL_REALLOCARRAY\n\nvoid *     reallocarray     (void *ptr,\n                             size_t nmemb,\n                             size_t size);\n\n#endif /* HAVE_REALLOCARRAY */\n\n#ifdef HAVE_STDBOOL_H\n#include <stdbool.h>\n#else\ntypedef enum { false, true } bool;\n#endif\n\n#ifndef HAVE_STRCONCAT\n\nchar *     strconcat        (const char *first,\n                             ...) GNUC_NULL_TERMINATED;\n\n#endif /* HAVE_STRCONCAT */\n\n#if defined HAVE_DECL_ASPRINTF && !HAVE_DECL_ASPRINTF\n\nint        asprintf         (char **strp,\n                             const char *fmt,\n                             ...);\n\n#endif /* HAVE_ASPRINTF */\n\n#if defined HAVE_DECL_VASPRINTF && !HAVE_DECL_VASPRINTF\n#include <stdarg.h>\n\nint        vasprintf        (char **strp,\n                             const char *fmt,\n                             va_list ap);\n\n#endif /* HAVE_DECL_VASPRINTF */\n\n#ifndef HAVE_GMTIME_R\n#include <time.h>\n\nstruct tm * gmtime_r        (const time_t *timep,\n                             struct tm *result);\n\n#endif /* HAVE_GMTIME_R */\n\n#ifndef HAVE_TIMEGM\n#include <time.h>\n\ntime_t      timegm          (struct tm *tm);\n\n#endif /* HAVE_TIMEGM */\n\n#ifdef HAVE_GETAUXVAL\n\n#include <sys/auxv.h>\n\n#else /* !HAVE_GETAUXVAL */\n\nunsigned long     getauxval (unsigned long type);\n\n#define AT_SECURE 23\n\n#endif /* !HAVE_GETAUXVAL */\n\nchar *            secure_getenv (const char *name);\n\n#ifndef HAVE_STRERROR_R\n\nint         strerror_r      (int errnum,\n                             char *buf,\n                             size_t buflen);\n\n#endif /* HAVE_STRERROR_R */\n\n#ifndef HAVE_FDWALK\n\nint        fdwalk           (int (* cb) (void *data, int fd),\n                             void *data);\n\n#endif\n\n/* If either locale_t or newlocale() is not available, strerror_l()\n * cannot be used */\n#if !defined(HAVE_LOCALE_T) || !defined(HAVE_NEWLOCALE)\n#undef HAVE_STRERROR_L\n#endif\n\nint        p11_ascii_tolower (int c);\nint        p11_ascii_toupper (int c);\n\n#endif /* __COMPAT_H__ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/frob-multi-init.c": "/*\n * gcc -Wall -o frob-multi-init $(pkg-config p11-kit-1 --cflags --libs) -ldl frob-multi-init.c\n */\n\n#include <assert.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#include <p11-kit/p11-kit.h>\n\n#define TRUST_SO \"/usr/lib64/pkcs11/p11-kit-trust.so\"\n\nint\nmain (void)\n{\n\tCK_C_INITIALIZE_ARGS args =\n\t\t{ NULL, NULL, NULL, NULL, CKF_OS_LOCKING_OK, NULL, };\n\tCK_C_GetFunctionList C_GetFunctionList;\n\tCK_SESSION_HANDLE session;\n\tCK_FUNCTION_LIST *module;\n\tCK_SLOT_ID slots[8];\n\tCK_SESSION_INFO info;\n\tCK_ULONG count;\n\tCK_RV rv;\n\tvoid *dl;\n\n\tdl = dlopen (TRUST_SO, RTLD_LOCAL | RTLD_NOW);\n\tif (dl == NULL)\n\t\tfprintf (stderr, \"%s\\n\", dlerror());\n\tassert (dl != NULL);\n\n\tC_GetFunctionList = dlsym (dl, \"C_GetFunctionList\");\n\tassert (C_GetFunctionList != NULL);\n\n\trv = C_GetFunctionList (&module);\n\tassert (rv == CKR_OK);\n\tassert (module != NULL);\n\n\trv = module->C_Initialize (&args);\n\tassert (rv == CKR_OK);\n\n\tcount = 8;\n\trv = module->C_GetSlotList (CK_TRUE, slots, &count);\n\tassert (rv == CKR_OK);\n\tassert (count > 1);\n\n\trv = module->C_OpenSession (slots[0], CKF_SERIAL_SESSION, NULL, NULL, &session);\n\tassert (rv == CKR_OK);\n\n\trv = module->C_GetSessionInfo (session, &info);\n\tassert (rv == CKR_OK);\n\n\trv = p11_kit_initialize_registered ();\n\tassert (rv == CKR_OK);\n\n\trv = module->C_GetSessionInfo (session, &info);\n\tif (rv == CKR_OK) {\n\t\tprintf (\"no reinitialization bug\\n\");\n\t\treturn 0;\n\n\t} else if (rv == CKR_SESSION_HANDLE_INVALID) {\n\t\tprintf (\"reinitialization bug present\\n\");\n\t\treturn 1;\n\n\t} else {\n\t\tprintf (\"another error: %lu\\n\", rv);\n\t\treturn 1;\n\t}\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/build/certs/testing-ca.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/build/certs/testing-server.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/build/certs/redhat-newca.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/build/certs/verisign-v1.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/build/certs/cacert-ca.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/build/certs/distant-end-date.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/build/certs/entrust-invalid.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/build/certs/self-server.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/build/certs/self-signed-with-eku.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/build/certs/self-signed-with-ku.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/build/certs/cacert3.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/fixtures/testing-server.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/fixtures/verisign-v1.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/fixtures/cacert-ca.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/fixtures/duplicated1.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/fixtures/redhat-ca.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/fixtures/multiple.jks",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/fixtures/self-signed-with-eku.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/fixtures/multiple.edk2",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/fixtures/duplicated2.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/fixtures/duplicated.jks",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/fixtures/self-signed-with-ku.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/fixtures/cacert3.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/input/cacert-ca.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/input/anchors/testing-ca.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/input/anchors/cacert3.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.21-ufbb2pdy7fy3w427hirpv5kwhccpol4r/spack-src/trust/input/blacklist/self-server.der"
    ],
    "total_files": 447
}