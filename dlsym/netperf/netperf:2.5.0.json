{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-netperf-2.5.0-7sspxmiopgxznu7eyanaphgnvtowhprg/spack-src/src/netsec_linux.c": "#if defined(HAVE_CONFIG_H)\n#include \"config.h\"\n#endif\n\n#if defined(HAVE_STRING_H)\n#include <string.h>\n#endif\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <dlfcn.h>\n\nvoid *messiah;  /* Handel's... */\n\n/* for the NSEC_mumble defines */\n#include \"netlib.h\"\n\n\nvoid\nfind_security_info_selinux(int *enabled, int *type, char **specific){\n\n  int ret;\n  int enforcing;\n\n  /* at some point we should probably get these from\n     selinux/selinux.h? */\n  int (*getenforce)(int *);\n  int (*getpolicy)(char **);\n\n  *enabled = NSEC_UNKNOWN;\n  *type    = NSEC_TYPE_SELINUX;\n\n  getenforce = dlsym(messiah, \"selinux_getenforcemode\");\n  if (NULL == getenforce) {\n    dlclose(messiah);\n    *specific = strdup(\"no getenforcemode\");\n    return;\n  }\n\n  ret = (*getenforce)(&enforcing);\n#if defined(NETPERF_STANDALONE_DEBUG)\n  printf(\"after selinux_getenforcemode() ret is %d\\n\",ret);\n#endif\n\n  switch(enforcing) {\n  case -1: \n    *enabled = NSEC_DISABLED;\n    break;\n  case 0:\n    *enabled = NSEC_PERMISSIVE;\n    break;\n  case 1:\n    *enabled = NSEC_ENFORCING;\n    break;\n  default:\n    *enabled = NSEC_UNKNOWN;\n  }\n    \n  getpolicy = dlsym(messiah, \"selinux_getpolicytype\");\n  if (NULL == getpolicy) {\n    dlclose(messiah);\n    *specific = strdup(\"no getpolicytype\");\n    return;\n  }\n\n  ret = (*getpolicy)(specific);\n#if defined(NETPERF_STANDALONE_DEBUG)\n  printf(\"after selinux_getpolicytype ret is %d\\n\",ret);\n#endif\n\n  return;\n}\n\n/* presently we only know about SELinux or nothing. at some point we\n   probably need to learn about AppArmor and the like.  raj\n   20081020 */\n\nvoid\nfind_security_info(int *enabled, int *type, char **specific) {\n\n  /* first, might it be selinux? */\n  messiah = dlopen(\"libselinux.so\", RTLD_LAZY);\n  if (NULL != messiah) {\n    dlerror();\n    return find_security_info_selinux(enabled, type, specific);\n  }\n  else {\n    *enabled = NSEC_UNKNOWN;\n    *type = NSEC_TYPE_UNKNOWN;\n    *specific = \"unknown\";\n    return;\n  }\n}\n\n#if defined(NETPERF_STANDALONE_DEBUG)\n\n/* these are normally found in src/netlib.c but we put copies here for\n   the nefaious popoise of standalone debugging */\n\nchar *\nnsec_enabled_to_str(int enabled) {\n  switch (enabled) {\n  case NSEC_UNKNOWN:\n    return(\"Unknown\");\n  case NSEC_DISABLED:\n    return(\"Disabled\");\n  case NSEC_PERMISSIVE:\n    return(\"Permissive\");\n  case NSEC_ENFORCING:\n    return(\"Enforcing\");\n  default:\n    return(\"UNKNOWN MODE\");\n  }\n}\n\nchar * nsec_type_to_str(int type) {\n  switch (type) {\n  case NSEC_TYPE_UNKNOWN:\n    return(\"Unknown\");\n  case NSEC_TYPE_SELINUX:\n    return(\"SELinux\");\n  default:\n    return(\"UNKNOWN TYPE\");\n  }\n}\n\nint\nmain(int argc, char *argv[]) {\n\n  char *specific;\n  int enabled;\n  int type;\n\n  find_security_info(&enabled, &type, &specific);\n\n  printf(\"Security info: enabled %s (%d) type %s (0x%x) specific %s\\n\",\n\t nsec_enabled_to_str(enabled),\n\t enabled,\n\t nsec_type_to_str(type),\n\t type,\n\t specific);\n\n  return 0;\n}\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-netperf-2.5.0-7sspxmiopgxznu7eyanaphgnvtowhprg/spack-src/src/missing/inet_ntop.c",
        "/tmp/vanessa/spack-stage/spack-stage-netperf-2.5.0-7sspxmiopgxznu7eyanaphgnvtowhprg/spack-src/doc/netperf.pdf"
    ],
    "total_files": 109
}