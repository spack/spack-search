{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-dcap-2.47.12-6gsnz3jne4g37hyz2eyvnu7mse6xgqad/spack-src/src/win32_libdl.c": "\n/*\n * $Id: win32_libdl.c,v 1.2 2004-11-01 19:33:30 tigran Exp $\n */\n\n#include <windows.h>\n#include <stdio.h>\n\n#include \"win32_libdl.h\"\n\nstatic char errbuf[512];\n\nvoid *dlopen(const char *name, int mode)\n{\n  HINSTANCE hdll;\n\n  hdll = LoadLibrary(name);\n#ifdef _WIN32\n  if (! hdll) {\n    sprintf(errbuf, \"error code %d loading library %s\", GetLastError(), name);\n    return NULL;\n  }\n#else\n  if ((UINT) hdll < 32) {\n    sprintf(errbuf, \"error code %d loading library %s\", (UINT) hdll, name);\n    return NULL;\n  }\n#endif\n  return (void *) hdll;\n}\n\nvoid *dlsym(void *lib, const char *name)\n{\n  HMODULE hdll = (HMODULE) lib;\n  void *symAddr;\n  symAddr = (void *) GetProcAddress(hdll, name);\n  if (symAddr == NULL)\n    sprintf(errbuf, \"can't find symbol %s\", name);\n  return symAddr;\n}\n\nint dlclose(void *lib)\n{\n  HMODULE hdll = (HMODULE) lib;\n\n#ifdef _WIN32\n  if (FreeLibrary(hdll))\n    return 0;\n  else {\n    sprintf(errbuf, \"error code %d closing library\", GetLastError());\n    return -1;\n  }\n#else\n  FreeLibrary(hdll);\n  return 0;\n#endif\n}\n\nchar *dlerror()\n{\n  return errbuf;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dcap-2.47.12-6gsnz3jne4g37hyz2eyvnu7mse6xgqad/spack-src/src/tunnelManager.c": "/*\n *   DCAP - dCache Access Protocol client interface\n *\n *   Copyright (C) 2000,2004 DESY Hamburg DMG-Division.\n *\n *   AUTHOR: Tigran Mkrtchayn (tigran.mkrtchyan@desy.de)\n *\n *   This program can be distributed under the terms of the GNU LGPL.\n *   See the file COPYING.LIB\n *\n */\n \n \n/*\n * $Id: tunnelManager.c,v 1.11 2004-11-01 19:33:30 tigran Exp $\n */\n\n#ifndef WIN32\n#   include <dlfcn.h>\n#   include <unistd.h>\n#else\n#    include \"win32_libdl.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"dcap.h\"\n#include \"sysdep.h\"\n#include \"debug_level.h\"\n#include \"ioTunnel.h\"\n#include \"tunnelManager.h\"\n\ntypedef struct {\n\tint sock;\n\tioTunnel *tunnel;\n} tunnelPair;\n\nstatic MUTEX(gLock);\n\nstatic tunnelPair *tunnelMap;\nstatic unsigned int qLen = 0; /* number of elements in the memory*/\n\n\nint setTunnelPair(int sock, ioTunnel *tunnel)\n{\n\ttunnelPair *tmp;\n\tm_lock(&gLock);\n\t\n\ttmp = realloc(tunnelMap, sizeof(tunnelPair)*(qLen +1));\n\tif(tmp == NULL) {\n\t\tm_unlock(&gLock);\n\t\treturn -1;\n\t}\n\t\n\ttunnelMap = tmp;\n\ttunnelMap[qLen].sock = sock;\n\ttunnelMap[qLen].tunnel = tunnel;\n\t\n\t++qLen;\n\t\n\tm_unlock(&gLock);\n\treturn 0;\n}\n\nioTunnel * getTunnelPair(int sock)\n{\n\n\tunsigned int i;\n\tioTunnel *en;\n\t\n\tm_lock(&gLock);\n\tfor(i = 0; i < qLen; i++) {\n\t\tif(tunnelMap[i].sock == sock) {\t\t\n\t\t\ten =  tunnelMap[i].tunnel;\n\t\t\tm_unlock(&gLock);\n\t\t\treturn en;\n\t\t}\n\t}\n\tm_unlock(&gLock);\n\treturn NULL;\n}\n\n\nioTunnel *addIoPlugin(const char *libname)\n{\n\tvoid *handle;\n\tioTunnel *tunnel;\n\tchar *fullpath;\n\n\tif(libname == NULL) {\n\t\tdc_debug(DC_ERROR, \"Bad tunnel name\");\n\t\treturn NULL;\n\t}\n\n\t/* magick library name, do nothing */\n\tif( strcmp(libname, \"null\") == 0 ) {\n\t\treturn NULL;\n\t}\n\n\thandle = dlopen( libname, RTLD_NOW);\n\t\t\n\tif(handle == NULL) {\n\t\tfullpath = malloc(strlen(TUNNELLIBDIR) + strlen(libname) + 2);\n\t\tstrcpy(fullpath, TUNNELLIBDIR);\n\t\tstrcat(fullpath, \"/\");\n\t\tstrcat(fullpath, libname);\n\t\thandle = dlopen(fullpath, RTLD_NOW);\n\t\tfree(fullpath);\n\t}\n\n\tif(handle == NULL) {\t\t\n\t\tgoto fail;\n\t}\n\n\ttunnel = (ioTunnel *)malloc(sizeof(ioTunnel));\n\tif(tunnel == NULL) {\n\t\tdc_debug(DC_ERROR, \"Failed to allocate memory for tunnel\");\n\t\tdlclose(handle);\n\t\treturn NULL;\n\t}\n\n\t\n\ttunnel->eRead = (ssize_t (*)(int , void *, size_t ))dlsym(handle, \"eRead\");\n\tif(tunnel->eRead == NULL) goto fail;\n\t\n\ttunnel->eWrite = (ssize_t (*)(int ,const void *, size_t ))dlsym(handle, \"eWrite\");\n\tif(tunnel->eWrite == NULL) goto fail;\n\t\n\ttunnel->eInit = (int(*)(int))dlsym(handle, \"eInit\");\t\n\tif(tunnel->eInit == NULL) goto fail;\n\t\n\ttunnel->eDestroy = (int(*)(int))dlsym(handle, \"eDestroy\");\n\tif(tunnel->eDestroy == NULL) goto fail;\n\t\t\n\n\tdc_debug(DC_INFO, \"Activating IO tunnel. Provider: [%s].\", libname);\n\t\t\n\treturn tunnel;\n\t\nfail:\n\tdc_debug(DC_ERROR, \"Failed to add IO tunnel (%s). Provider: [%s].\", dlerror(), libname);\n\n\tif(handle != NULL ) {\n\t\tdlclose(handle);\n\t}\n\treturn NULL;\t\n\t\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dcap-2.47.12-6gsnz3jne4g37hyz2eyvnu7mse6xgqad/spack-src/src/win32_libdl.h": "/*\n *   DCAP - dCache Access Protocol client interface\n *\n *   Copyright (C) 2000,2004 DESY Hamburg DMG-Division.\n *\n *   AUTHOR: Tigran Mkrtchayn (tigran.mkrtchyan@desy.de)\n *\n *   This program can be distributed under the terms of the GNU LGPL.\n *   See the file COPYING.LIB\n *\n */\n\n\n/*\n * $Id: win32_libdl.h,v 1.2 2004-11-01 19:33:30 tigran Exp $\n */\n\n#ifndef WIN32_LIBDL_H\n#define WIN32_LIBDL_H\n\n#define RTLD_LAZY 1\n#define RTLD_NOW  2\n\nextern void  *dlopen(const char *, int);\nextern void  *dlsym(void *, const char *);\nextern int   dlclose(void *);\nextern char  *dlerror(void);\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dcap-2.47.12-6gsnz3jne4g37hyz2eyvnu7mse6xgqad/spack-src/src/system_io.c": "/*\n *   DCAP - dCache Access Protocol client interface\n *\n *   Copyright (C) 2000,2004 DESY Hamburg DMG-Division.\n *\n *   AUTHOR: Tigran Mkrtchayn (tigran.mkrtchyan@desy.de)\n *   FIXED BY: Vladimir Podstavkov (podstvkv@fnal.gov)\n *\n *   This program can be distributed under the terms of the GNU LGPL.\n *   See the file COPYING.LIB\n *\n */\n\n\n/*\n * $Id: system_io.c,v 1.54 2006-09-26 07:41:11 tigran Exp $\n */\n\n#ifdef LIBC_SYSCALLS\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n#include \"dcap_debug.h\"\n#include \"sysdep.h\"\n#include <signal.h>\n\nstatic MUTEX(gLock);\nstatic void *handle;\n\n#ifdef __APPLE__\n#define off64_t off_t\n#endif\n\n/*\n *  Convert from (void *) to different function pointer\n *  types.  For details why this is necessary, please\n *  see dlsym man-page:\n *\n *    http://www.opengroup.org/onlinepubs/009695399/functions/dlsym.html\n */\nunion pointer_converter {\n  void *symbol;\n  int (*s_open)           (const char *, int, ...);\n  ssize_t (*s_read)       (int, void *, size_t);\n  ssize_t (*s_readv)      (int, const struct iovec *vector, int count);\n  ssize_t (*s_pread)      (int, void *, size_t, off_t);\n  ssize_t (*s_pread64)    (int, void *, size_t, off64_t);\n  ssize_t (*s_write)      (int, const void *, size_t);\n  ssize_t (*s_writev)     (int, const struct iovec *vector, int count);\n  ssize_t (*s_pwrite)     (int, const void *, size_t, off_t);\n  ssize_t (*s_pwrite64)   (int, const void *, size_t, off64_t);\n  off64_t (*s_lseek64)    (int, off64_t, int);\n  int (*s_close)          (int);\n#ifdef _STAT_VER\n  int (*s_stat)           (int , const char *, struct stat *);\n  int (*s_fstat)          (int, int, struct stat *);\n  int (*s_stat64)         (int , const char *, struct stat64 *);\n  int (*s_lstat64)        (int , const char *, struct stat64 *);\n  int (*s_lstat)          (int , const char *, struct stat *);\n  int (*s_fstat64)        (int, int, struct stat64 *);\n#else\n  int (*s_stat)           (const char *, struct stat *);\n  int (*s_fstat)          (int, struct stat *);\n  int (*s_stat64)         (const char *, struct stat64 *);\n  int (*s_lstat64)        (const char *, struct stat64 *);\n  int (*s_lstat)          (const char *, struct stat *);\n  int (*s_fstat64)        (int, struct stat64 *);\n#endif\n  int (*s_fsync)          (int);\n  int (*s_dup)            (int);\n  int (*s_closedir)       (DIR *);\n  DIR *(*s_opendir)       (const char *);\n  struct dirent *(*s_readdir) (DIR *);\n  struct dirent64 *(*s_readdir64) (DIR *);\n  off_t (*s_telldir)      (DIR *);\n  void (*s_seekdir)       (DIR *, off_t);\n  int (*s_unlink)         (const char *);\n  int (*s_rmdir)          (const char *);\n  int (*s_mkdir)          (const char *, mode_t);\n  int (*s_chmod)          (const char *, mode_t);\n  int (*s_chown)          (const char *, uid_t, gid_t);\n  int (*s_access)         (const char *, int);\n  int (*s_rename)         (const char *, const char *);\n  int (*s_acl)            (const char *, int, int, void *);\n  int (*s_facl)           (int, int, int, void *);\n  FILE *(*s_fopen)        (const char *, const char *);\n  FILE *(*s_fopen64)      (const char *, const char *);\n  FILE *(*s_fdopen)       (int, const char *);\n  int (*s_fclose)         (FILE *);\n  size_t (*s_fwrite)      (const void *, size_t, size_t, FILE *);\n  size_t (*s_fread)       (void *, size_t, size_t, FILE *);\n  int (*s_fseeko64)       (FILE *, off64_t, int);\n  off64_t (*s_ftello64)   (FILE *);\n  int (*s_ferror)         (FILE *);\n  int (*s_fflush)         (FILE *);\n  int (*s_feof)           (FILE *);\n  char *(*s_fgets)        (char *, int, FILE *);\n  int (*s_fgetc)          (FILE *);\n};\n\n#define ASSIGN_FN(FN_VARIABLE, CONVERTER, HANDLE, SYMBOL) \\\n  do {                                                    \\\n    CONVERTER.symbol = dlsym( HANDLE, SYMBOL);            \\\n    FN_VARIABLE = CONVERTER. FN_VARIABLE;                 \\\n  } while(0)\n\n#ifndef LIBC\n#define LIBC NULL\n#endif\nstatic char *libname = LIBC;\nstatic int (*s_open)           (const char *, int, ...);\nstatic ssize_t (*s_read)       (int, void *, size_t);\nstatic ssize_t (*s_readv)      (int, const struct iovec *vector, int count);\nstatic ssize_t (*s_pread)      (int, void *, size_t, off_t);\nstatic ssize_t (*s_pread64)    (int, void *, size_t, off64_t);\nstatic ssize_t (*s_write)      (int, const void *, size_t);\nstatic ssize_t (*s_writev)     (int, const struct iovec *vector, int count);\nstatic ssize_t (*s_pwrite)     (int, const void *, size_t, off_t);\nstatic ssize_t (*s_pwrite64)   (int, const void *, size_t, off64_t);\nstatic off64_t (*s_lseek64)    (int, off64_t, int);\nstatic int (*s_close)          (int);\n\n/*\n * A version number is included in the x86 SVR4 stat interface\n * so that SVR3 binaries can be supported\n */\n#ifdef _STAT_VER\nstatic int (*s_stat)       (int , const char *, struct stat *);\nstatic int (*s_fstat)      (int, int, struct stat *);\nstatic int (*s_stat64)     (int , const char *, struct stat64 *);\nstatic int (*s_lstat64)    (int , const char *, struct stat64 *);\nstatic int (*s_lstat)      (int , const char *, struct stat *);\nstatic int (*s_fstat64)    (int, int, struct stat64 *);\n#else\nstatic int (*s_stat)       (const char *, struct stat *);\nstatic int (*s_fstat)      (int, struct stat *);\nstatic int (*s_stat64)     (const char *, struct stat64 *);\nstatic int (*s_lstat64)    (const char *, struct stat64 *);\nstatic int (*s_lstat)      (const char *, struct stat *);\nstatic int (*s_fstat64)    (int, struct stat64 *);\n#endif\nstatic int (*s_fsync)      (int);\nstatic int (*s_dup)        (int);\nstatic int              (*s_closedir)   (DIR *);\nstatic DIR *            (*s_opendir)    (const char *);\nstatic struct dirent *  (*s_readdir)    (DIR *);\nstatic struct dirent64 *(*s_readdir64)  (DIR *);\nstatic off_t            (*s_telldir)    (DIR *);\nstatic void             (*s_seekdir)    (DIR *, off_t);\nstatic int              (*s_unlink)(const char *);\nstatic int              (*s_rmdir)(const char *);\nstatic int              (*s_mkdir)(const char *, mode_t);\nstatic int              (*s_chmod)(const char *, mode_t);\nstatic int              (*s_chown)(const char *, uid_t, gid_t);\nstatic int              (*s_access)(const char *, int);\nstatic int              (*s_rename)(const char *, const char *);\n#ifdef HAVE_ACL\nstatic int              (*s_acl)(const char *, int, int, void *);\n#endif /* HAVE_ACL */\n#ifdef HAVE_FACL\nstatic int              (*s_facl)(int, int, int, void *);\n#endif /* HAVE_FACL */\n\nstatic FILE * (*s_fopen)(const char *, const char *);\nstatic FILE * (*s_fopen64)(const char *, const char *);\nstatic FILE * (*s_fdopen)(int, const char *);\nstatic int  (*s_fclose)(FILE *);\nstatic size_t (*s_fwrite)(const void *, size_t, size_t, FILE *);\nstatic size_t (*s_fread)(void *, size_t, size_t, FILE *);\nstatic int (*s_fseeko64)(FILE *, off64_t, int);\nstatic off64_t (*s_ftello64)(FILE *);\nstatic int (*s_ferror)(FILE *);\nstatic int (*s_fflush)(FILE *);\nstatic int (*s_feof)(FILE *);\nstatic char * (*s_fgets)(char *, int, FILE *);\nstatic int (*s_fgetc)(FILE *);\n\nstatic int initIfNeeded();\nstatic void stat64to32(struct stat *st32, const struct stat64 *st64);\n\n\n/* FIXME: stat64to32 is duplicated in dcap_stat.c */\nvoid stat64to32(struct stat *st32, const struct stat64 *st64)\n{\n\tmemset(st32, 0, sizeof(struct stat) );\n\n\tst32->st_dev = st64->st_dev;\n\tst32->st_ino = st64->st_ino;\n\tst32->st_mode = st64->st_mode;\n\tst32->st_nlink = st64->st_nlink;\n\tst32->st_uid = st64->st_uid;\n\tst32->st_gid = st64->st_gid;\n\tst32->st_rdev = st64->st_rdev;\n\tst32->st_size = st64->st_size;\n\tst32->st_blksize = st64->st_blksize;\n\tst32->st_blocks = st64->st_blocks;\n\tst32->st_atime = st64->st_atime;\n\tst32->st_mtime = st64->st_mtime;\n\tst32->st_ctime = st64->st_ctime;\n}\n\nint initIfNeeded()\n{\n\tunion pointer_converter convert;\n\tchar *em;\n\n\tsigset_t block_set;\n\n\n\t/* we do not want to be interrupted */\n\tsigemptyset(&block_set);\n\tsigaddset(&block_set, SIGALRM);\n\tsigprocmask(SIG_BLOCK, &block_set, NULL);\n\n\tm_lock(&gLock);\n\n\tif(handle != NULL) {\n\t\tm_unlock(&gLock);\n/*\t\tdc_debug(DC_TRACE, \"System IO already initialized.\");\t\t*/\n\n\t\t/* restore signal handling */\n\t\tsigprocmask(SIG_UNBLOCK, &block_set, NULL);\n\t\treturn 0;\n\t}\n\n/*\tdc_debug(DC_IO, \"Initializing System IO.\"); */\n\tif( getenv(\"DCACHE_IOLIB\") != NULL ) {\n\t\tlibname = getenv(\"DCACHE_IOLIB\");\n\t}\n\tif( libname != NULL ) {\n\t\thandle = dlopen( libname, RTLD_NOW | RTLD_GLOBAL);\n\t\tif(handle == NULL) {\n\t\t\tm_unlock(&gLock);\n/*\t\t\tdc_debug(DC_ERROR, \"Failed to initialize System IO: (%s).\", dlerror()); */\n#if 0\n\t\t\tperror(dlerror() );\n#endif\n\t\t\t/* restore signal handling */\n\t\t\tsigprocmask(SIG_UNBLOCK, &block_set, NULL);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t#ifdef RTLD_NEXT\n\telse{\n\t\t/* try to use other dynamic libraries to get requaried functions */\n\n\t\thandle = RTLD_NEXT;\n\t}\n\t#endif\n\n\n\tASSIGN_FN( s_open,     convert, handle, OPEN_SYM);\n\tASSIGN_FN( s_read,     convert, handle, READ_SYM);\n\tASSIGN_FN( s_readv,    convert, handle, READV_SYM);\n\tASSIGN_FN( s_pread,    convert, handle, PREAD_SYM);\n\tASSIGN_FN( s_pread64,  convert, handle, PREAD64_SYM);\n\tASSIGN_FN( s_write,    convert, handle, WRITE_SYM);\n\tASSIGN_FN( s_writev,   convert, handle, WRITEV_SYM);\n\tASSIGN_FN( s_pwrite,   convert, handle, PWRITE_SYM);\n\tASSIGN_FN( s_pwrite64, convert, handle, PWRITE64_SYM);\n\tASSIGN_FN( s_lseek64,  convert, handle, LSEEK64_SYM);\n\tASSIGN_FN( s_close,    convert, handle, CLOSE_SYM);\n\tASSIGN_FN( s_stat,     convert, handle, STAT64_SYM);\n\tASSIGN_FN( s_stat64,   convert, handle, STAT64_SYM);\n\tASSIGN_FN( s_lstat,    convert, handle, LSTAT_SYM);\n\tASSIGN_FN( s_lstat64,  convert, handle, LSTAT64_SYM);\n\tASSIGN_FN( s_fstat,    convert, handle, FSTAT_SYM);\n\tASSIGN_FN( s_fstat64,  convert, handle, FSTAT64_SYM);\n\n\tASSIGN_FN( s_fsync,    convert, handle, FSYNC_SYM);\n\n\tASSIGN_FN( s_dup,      convert, handle, DUP_SYM);\n\n\tASSIGN_FN( s_opendir,  convert, handle, OPENDIR_SYM);\n\tASSIGN_FN( s_closedir, convert, handle, CLOSEDIR_SYM);\n\tASSIGN_FN( s_readdir,  convert, handle, READDIR_SYM);\n\tASSIGN_FN( s_readdir64, convert, handle, READDIR64_SYM);\n\tASSIGN_FN( s_telldir,  convert, handle, TELLDIR_SYM);\n\tASSIGN_FN( s_seekdir,  convert, handle, SEEKDIR_SYM);\n\n\tASSIGN_FN( s_unlink,   convert, handle, UNLINK_SYM);\n\tASSIGN_FN( s_rmdir,    convert, handle, RMDIR_SYM);\n\tASSIGN_FN( s_mkdir,    convert, handle, MKDIR_SYM);\n\tASSIGN_FN( s_chmod,    convert, handle, CHMOD_SYM);\n\tASSIGN_FN( s_chown,    convert, handle, CHOWN_SYM);\n\tASSIGN_FN( s_access,   convert, handle, ACCESS_SYM);\n\tASSIGN_FN( s_rename,   convert, handle, RENAME_SYM);\n#ifdef HAVE_ACL\n\tASSIGN_FN( s_acl,      convert, handle, ACL_SYM);\n#endif /* HAVE_ACL */\n#ifdef HAVE_FACL\n\tASSIGN_FN( s_facl,     convert, handle, FACL_SYM);\n#endif /* HAVE_FACL */\n\n\tASSIGN_FN( s_fopen,    convert, handle, \"fopen\");\n\tASSIGN_FN( s_fopen64,  convert, handle, \"fopen64\");\n\tASSIGN_FN( s_fdopen,   convert, handle, \"fdopen\");\n\tASSIGN_FN( s_fread,    convert, handle, \"fread\");\n\tASSIGN_FN( s_fwrite,   convert, handle, \"fwrite\");\n\tASSIGN_FN( s_fseeko64, convert, handle, \"fseeko64\");\n\tASSIGN_FN( s_fclose,   convert, handle, \"fclose\");\n\tASSIGN_FN( s_fflush,   convert, handle, \"fflush\");\n\tASSIGN_FN( s_ftello64, convert, handle, \"ftello64\");\n\tASSIGN_FN( s_feof,     convert, handle, \"feof\");\n\tASSIGN_FN( s_ferror,   convert, handle, \"ferror\");\n\tASSIGN_FN( s_fgets,    convert, handle, \"fgets\");\n\tASSIGN_FN( s_fgetc,    convert, handle, \"fgetc\");\n\n\tif( (s_open == NULL) || (s_read == NULL) ||\n\t\t(s_pread == NULL) || (s_write == NULL) ||\n\t\t(s_pwrite == NULL) || (s_pread64 == NULL) || (s_pwrite64 == NULL) ||\n\t\t(s_lseek64 == NULL) || (s_close == NULL) ||\n\t\t(s_stat == NULL) || (s_fstat == NULL ) || (s_fsync == NULL) ||\n\t\t(s_stat64 == NULL) || (s_fstat64 == NULL ) ||\n\t\t(s_lstat == NULL) || (s_lstat64 == NULL ) ||\n\t\t(s_dup == NULL) || (s_opendir == NULL) || (s_closedir == NULL) ||\n\t\t(s_readdir == NULL) || (s_readdir64 ==  NULL) ||\n\t\t(s_telldir == NULL) || (s_seekdir == NULL) ||\n\t\t(s_unlink == NULL ) || (s_rmdir == NULL ) ||\n\t\t(s_mkdir == NULL ) || (s_chmod == NULL ) || (s_access == NULL )  ||\n#ifdef HAVE_ACL\n\t\t(s_acl == NULL ) ||\n#endif /* HAVE_ACL */\n#ifdef HAVE_FACL\n\t\t(s_facl == NULL ) ||\n#endif /* HAVE_FACL */\n\n\t\t(s_chown == NULL ) ) {\n\n\t\t/* try to write error message it's possible */\n\t\tif( s_write != NULL ) {\n\t\t\tem = dlerror();\n\t\t\tif(em != NULL ) {\n\t\t\t\ts_write(2, em, strlen(em) );\n\t\t\t}\n\t\t}\n\n/*\t\tdc_debug(DC_ERROR, \"Failed to initialize System IO: (%s).\", dlerror()); */\n\t\tdlclose(handle);\n\t\thandle = NULL;\n\t\tm_unlock(&gLock);\n\n#if 0\n\t\tperror( dlerror() );\n\n\t\tfprintf(stderr, \"open 0x%x\\n\", sOpen);\n\t\tfprintf(stderr, \"read 0x%x\\n\", sRead);\n\t\tfprintf(stderr, \"write 0x%x\\n\", sWrite);\n\t\tfprintf(stderr, \"pread 0x%x\\n\", sPread);\n\t\tfprintf(stderr, \"pwrite 0x%x\\n\", sPwrite);\n\t\tfprintf(stderr, \"lseek 0x%x\\n\", sLseek);\n\t\tfprintf(stderr, \"close 0x%x\\n\", sClose);\n\t\tfprintf(stderr, \"stat 0x%x\\n\", sStat);\n\t\tfprintf(stderr, \"stat64 0x%x\\n\", sStat64);\n\t\tfprintf(stderr, \"fstat 0x%x\\n\", sFstat);\n\t\tfprintf(stderr, \"fstat64 0x%x\\n\", sFstat64);\n\t\tfprintf(stderr, \"lstat 0x%x\\n\", sLstat);\n\t\tfprintf(stderr, \"lstat64 0x%x\\n\", sLstat64);\n\t\tfprintf(stderr, \"dup 0x%x\\n\", sDup);\n\t\tfprintf(stderr, \"fsync 0x%x\\n\", sFsync);\n\t\tfprintf(stderr, \"opendir 0x%x\\n\", sOpendir);\n\t\tfprintf(stderr, \"readdir 0x%x\\n\", sReaddir);\n\t\tfprintf(stderr, \"readdir64 0x%x\\n\", sReaddir64);\n\t\tfprintf(stderr, \"closedir 0x%x\\n\", sClosedir);\n\t\tfprintf(stderr, \"seekdir 0x%x\\n\", sSeekdir);\n\t\tfprintf(stderr, \"telldir 0x%x\\n\", sTelldir);\n\t\tfflush(stderr);\n#endif\n\t\t/* restore signal handling */\n\t\tsigprocmask(SIG_UNBLOCK, &block_set, NULL);\n\n\t\treturn -17;\n\n\n\t}\n\n\tm_unlock(&gLock);\n\n\t/* restore signal handling */\n\tsigprocmask(SIG_UNBLOCK, &block_set, NULL);\n\n\treturn 0;\n\n}\n\nint\nsystem_open(const char *fd, int flags, mode_t mode)\n{\n\treturn initIfNeeded() == 0 ? s_open(fd, flags, mode) : -1;\n}\n\nint\nsystem_read(int fd, void *buf, size_t buflen)\n{\n\treturn initIfNeeded() == 0 ? s_read( fd, buf, buflen) : -1;\n}\n\nint\nsystem_readv(int fd, const struct iovec *vector, int count)\n{\n\treturn initIfNeeded() == 0 ? s_readv( fd, vector, count) : -1;\n}\n\nint system_pread(int fd, void *buf, size_t buflen, off_t offset)\n{\n\treturn initIfNeeded() == 0 ? s_pread( fd, buf, buflen, offset) : -1;\n}\n\nint system_pread64(int fd, void *buf, size_t buflen, off64_t offset)\n{\n\treturn initIfNeeded() == 0 ? s_pread64( fd, buf, buflen, offset) : -1;\n}\n\nint system_write(int fd, const void *buf, size_t buflen)\n{\n\treturn initIfNeeded() == 0 ? s_write( fd, buf, buflen) : -1;\n}\n\nint\nsystem_writev(int fd, const struct iovec *vector, int count)\n{\n\treturn initIfNeeded() == 0 ? s_writev( fd, vector, count) : -1;\n}\n\nint system_pwrite(int fd, void *buf, size_t buflen, off_t offset)\n{\n\treturn initIfNeeded() == 0 ? s_pwrite( fd, buf, buflen, offset) : -1;\n}\n\nint system_pwrite64(int fd, void *buf, size_t buflen, off64_t offset)\n{\n\treturn initIfNeeded() == 0 ? s_pwrite64( fd, buf, buflen, offset) : -1;\n}\n\nint system_close(int fd)\n{\n\treturn initIfNeeded() == 0 ? s_close(fd) : -1;\n}\n\n\noff64_t\nsystem_lseek64(int fd, off64_t offset, int whence)\n{\n\treturn initIfNeeded() == 0 ? s_lseek64(fd, offset, whence) : -1;\n}\n\n#ifdef _STAT_VER\nint system_fstat( int fd, struct stat *buf)\n{\n\tstruct stat64 s;\n\tint rc;\n\n\tif ( initIfNeeded() != 0 ) {\n\t\treturn -1;\n\t}\n\n\trc = s_fstat64(_STAT_VER, fd, &s);\n\n\tstat64to32(buf, &s);\n\treturn rc;\n\n}\n\nint system_stat64( const char *path, struct stat64 *buf)\n{\n\treturn initIfNeeded() == 0 ? s_stat64(_STAT_VER, path, buf) : -1;\n}\n\n\nint system_fstat64( int fd, struct stat64 *buf)\n{\n\treturn initIfNeeded() == 0 ? s_fstat64(_STAT_VER, fd, buf) : -1;\n}\n\nint system_stat( const char *path, struct stat *buf)\n{\n\tstruct stat64 s;\n\tint rc;\n\n\tif ( initIfNeeded() != 0 ) {\n\t\treturn -1;\n\t}\n\n\trc = s_stat64(_STAT_VER, path, &s);\n\n\tstat64to32(buf, &s);\n\treturn rc;\n}\n\n\nint system_lstat( const char *path, struct stat *buf)\n{\n\tstruct stat64 s;\n\tint rc;\n\tif ( initIfNeeded() != 0 ) {\n\t\treturn -1;\n\t}\n\n\trc = s_lstat64(_STAT_VER, path, &s);\n\n\tstat64to32(buf, &s);\n\treturn rc;\n}\n\nint system_lstat64( const char *path, struct stat64 *buf)\n{\n\treturn initIfNeeded() == 0 ? s_lstat64(_STAT_VER, path, buf) : -1;\n}\n#else\nint system_fstat( int fd, struct stat *buf)\n{\n\tstruct stat64 s;\n\tint rc;\n\n\tif ( initIfNeeded() != 0 ) {\n\t\treturn -1;\n\t}\n\n\trc = s_fstat64(fd, &s);\n\n\tstat64to32(buf, &s);\n\treturn rc;\n\n}\n\nint system_stat64( const char *path, struct stat64 *buf)\n{\n\treturn initIfNeeded() == 0 ? s_stat64(path, buf) : -1;\n}\n\n\nint system_fstat64( int fd, struct stat64 *buf)\n{\n\treturn initIfNeeded() == 0 ? s_fstat64(fd, buf) : -1;\n}\n\nint system_stat( const char *path, struct stat *buf)\n{\n\tstruct stat64 s;\n\tint rc;\n\n\tif ( initIfNeeded() != 0 ) {\n\t\treturn -1;\n\t}\n\n\trc = s_stat64(path, &s);\n\n\tstat64to32(buf, &s);\n\treturn rc;\n}\n\n\nint system_lstat( const char *path, struct stat *buf)\n{\n\tstruct stat64 s;\n\tint rc;\n\tif ( initIfNeeded() != 0 ) {\n\t\treturn -1;\n\t}\n\n\trc = s_lstat64(path, &s);\n\n\tstat64to32(buf, &s);\n\treturn rc;\n}\n\nint system_lstat64( const char *path, struct stat64 *buf)\n{\n\treturn initIfNeeded() == 0 ? s_lstat64(path, buf) : -1;\n}\n#endif\n\n\nint system_fsync(int fd)\n{\n\treturn initIfNeeded() == 0 ? s_fsync(fd) : -1;\n}\n\nint system_dup(int fd)\n{\n\treturn initIfNeeded() == 0 ? s_dup(fd) : -1;\n}\n\nDIR * system_opendir(const char *path)\n{\n\treturn initIfNeeded() == 0? s_opendir(path) : NULL;\n}\n\nint system_closedir( DIR *dir )\n{\n\treturn initIfNeeded() == 0? s_closedir(dir) : -1;\n}\n\nstruct dirent * system_readdir(DIR *dir)\n{\n\treturn initIfNeeded() == 0? s_readdir(dir) : NULL;\n}\n\nstruct dirent64 * system_readdir64(DIR *dir)\n{\n\treturn initIfNeeded() == 0? s_readdir64(dir) : NULL;\n}\n\noff_t system_telldir( DIR *dir)\n{\n\treturn initIfNeeded() == 0?  s_telldir(dir) : -1;\n}\n\nvoid system_seekdir( DIR *dir, off_t offset)\n{\n\tif ( initIfNeeded() == 0 ) {\n\t\ts_seekdir(dir, offset );\n\t}\n}\n\n\nFILE * system_fopen( const char *path, const char *mode)\n{\n\treturn initIfNeeded() == 0 ? s_fopen(path, mode) : NULL;\n}\n\nFILE * system_fopen64( const char *path, const char *mode)\n{\n\treturn initIfNeeded() == 0 ? s_fopen64(path, mode) : NULL;\n}\n\nFILE * system_fdopen( int fd, const char *mode)\n{\n\treturn initIfNeeded() == 0 ? s_fdopen(fd, mode) : NULL;\n}\n\nsize_t system_fread( void *buf, size_t i , size_t n, FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_fread(buf, i, n, stream) : 0;\n}\n\nsize_t system_fwrite( const void *buf, size_t i , size_t n, FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_fwrite(buf, i, n, stream) : 0;\n}\n\nint system_fclose(FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_fclose(stream) : -1;\n}\n\nint system_feof(FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_feof(stream) : -1;\n}\n\nint system_ferror(FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_ferror(stream) : -1;\n}\n\nint system_fflush(FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_fflush(stream) : -1;\n}\n\nlong system_ftello64(FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_ftello64(stream) : -1;\n}\n\nint system_fseeko64(FILE *stream, off64_t offset, int w)\n{\n\treturn initIfNeeded() == 0 ? s_fseeko64(stream, offset, w) : -1;\n}\n\nchar * system_fgets( char *s, int size, FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_fgets(s, size, stream) : NULL;\n}\n\nint system_fgetc(FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_fgetc(stream) : -1;\n}\n\nint system_unlink(const char *path)\n{\n\treturn initIfNeeded() == 0 ? s_unlink(path) : -1;\n}\n\nint system_rmdir(const char *path)\n{\n\treturn initIfNeeded() == 0 ? s_rmdir(path) : -1;\n}\n\nint system_mkdir(const char *path, mode_t mode)\n{\n\treturn initIfNeeded() == 0 ? s_mkdir(path, mode) : -1;\n}\n\nint system_chmod(const char *path, mode_t mode)\n{\n        return initIfNeeded() == 0 ? s_chmod(path, mode) : -1;\n}\n\nint system_chown(const char *path, uid_t uid, gid_t gid)\n{\n        return initIfNeeded() == 0 ? s_chown(path, uid, gid) : -1;\n}\n\nint system_access(const char *path, int mode)\n{\n        return initIfNeeded() == 0 ? s_access(path, mode) : -1;\n}\n\n\nint system_rename(const char *oldPath, const char *newPath)\n{\n        return initIfNeeded() == 0 ? s_rename(oldPath, newPath) : -1;\n}\n\n#ifdef HAVE_ACL\nint system_acl(const char *path, int cmd, int cnt, void *buf)\n{\n        return initIfNeeded() == 0 ? s_acl(path, cmd, cnt, buf) : -1;\n}\n#endif /* HAVE_ACL */\n\n#ifdef HAVE_FACL\nint system_facl(int fd, int cmd, int cnt, void *buf)\n{\n        return initIfNeeded() == 0 ? s_facl(fd, cmd, cnt, buf) : -1;\n}\n#endif /* HAVE_FACL */\n\n#endif /* LIBC_SYSCALLS */\n"
    },
    "skipped": [],
    "total_files": 166
}