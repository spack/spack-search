{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/runtime/phobos/std/net/curl.d": "// Written in the D programming language.\n\n/**\nNetworking client functionality as provided by $(HTTP _curl.haxx.se/libcurl,\nlibcurl). The libcurl library must be installed on the system in order to use\nthis module.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW High level) $(TD $(MYREF download) $(MYREF upload) $(MYREF get)\n$(MYREF post) $(MYREF put) $(MYREF del) $(MYREF options) $(MYREF trace)\n$(MYREF connect) $(MYREF byLine) $(MYREF byChunk)\n$(MYREF byLineAsync) $(MYREF byChunkAsync) )\n)\n$(TR $(TDNW Low level) $(TD $(MYREF HTTP) $(MYREF FTP) $(MYREF\nSMTP) )\n)\n)\n)\n\nNote:\nYou may need to link to the $(B curl) library, e.g. by adding $(D \"libs\": [\"curl\"])\nto your $(B dub.json) file if you are using $(LINK2 http://code.dlang.org, DUB).\n\nWindows x86 note:\nA DMD compatible libcurl static library can be downloaded from the dlang.org\n$(LINK2 http://dlang.org/download.html, download page).\n\nCompared to using libcurl directly this module allows simpler client code for\ncommon uses, requires no unsafe operations, and integrates better with the rest\nof the language. Futhermore it provides <a href=\"std_range.html\">$(D range)</a>\naccess to protocols supported by libcurl both synchronously and asynchronously.\n\nA high level and a low level API are available. The high level API is built\nentirely on top of the low level one.\n\nThe high level API is for commonly used functionality such as HTTP/FTP get. The\n$(LREF byLineAsync) and $(LREF byChunkAsync) provides asynchronous <a\nhref=\"std_range.html\">$(D ranges)</a> that performs the request in another\nthread while handling a line/chunk in the current thread.\n\nThe low level API allows for streaming and other advanced features.\n\n$(BOOKTABLE Cheat Sheet,\n$(TR $(TH Function Name) $(TH Description)\n)\n$(LEADINGROW High level)\n$(TR $(TDNW $(LREF download)) $(TD $(D\ndownload(\"ftp.digitalmars.com/sieve.ds\", \"/tmp/downloaded-ftp-file\"))\ndownloads file from URL to file system.)\n)\n$(TR $(TDNW $(LREF upload)) $(TD $(D\nupload(\"/tmp/downloaded-ftp-file\", \"ftp.digitalmars.com/sieve.ds\");)\nuploads file from file system to URL.)\n)\n$(TR $(TDNW $(LREF get)) $(TD $(D\nget(\"dlang.org\")) returns a char[] containing the dlang.org web page.)\n)\n$(TR $(TDNW $(LREF put)) $(TD $(D\nput(\"dlang.org\", \"Hi\")) returns a char[] containing\nthe dlang.org web page. after a HTTP PUT of \"hi\")\n)\n$(TR $(TDNW $(LREF post)) $(TD $(D\npost(\"dlang.org\", \"Hi\")) returns a char[] containing\nthe dlang.org web page. after a HTTP POST of \"hi\")\n)\n$(TR $(TDNW $(LREF byLine)) $(TD $(D\nbyLine(\"dlang.org\")) returns a range of char[] containing the\ndlang.org web page.)\n)\n$(TR $(TDNW $(LREF byChunk)) $(TD $(D\nbyChunk(\"dlang.org\", 10)) returns a range of ubyte[10] containing the\ndlang.org web page.)\n)\n$(TR $(TDNW $(LREF byLineAsync)) $(TD $(D\nbyLineAsync(\"dlang.org\")) returns a range of char[] containing the dlang.org web\n page asynchronously.)\n)\n$(TR $(TDNW $(LREF byChunkAsync)) $(TD $(D\nbyChunkAsync(\"dlang.org\", 10)) returns a range of ubyte[10] containing the\ndlang.org web page asynchronously.)\n)\n$(LEADINGROW Low level\n)\n$(TR $(TDNW $(LREF HTTP)) $(TD $(D HTTP) struct for advanced usage))\n$(TR $(TDNW $(LREF FTP)) $(TD $(D FTP) struct for advanced usage))\n$(TR $(TDNW $(LREF SMTP)) $(TD $(D SMTP) struct for advanced usage))\n)\n\n\nExample:\n---\nimport std.net.curl, std.stdio;\n\n// Return a char[] containing the content specified by a URL\nauto content = get(\"dlang.org\");\n\n// Post data and return a char[] containing the content specified by a URL\nauto content = post(\"mydomain.com/here.cgi\", [\"name1\" : \"value1\", \"name2\" : \"value2\"]);\n\n// Get content of file from ftp server\nauto content = get(\"ftp.digitalmars.com/sieve.ds\");\n\n// Post and print out content line by line. The request is done in another thread.\nforeach (line; byLineAsync(\"dlang.org\", \"Post data\"))\n    writeln(line);\n\n// Get using a line range and proxy settings\nauto client = HTTP();\nclient.proxy = \"1.2.3.4\";\nforeach (line; byLine(\"dlang.org\", client))\n    writeln(line);\n---\n\nFor more control than the high level functions provide, use the low level API:\n\nExample:\n---\nimport std.net.curl, std.stdio;\n\n// GET with custom data receivers\nauto http = HTTP(\"dlang.org\");\nhttp.onReceiveHeader =\n    (in char[] key, in char[] value) { writeln(key, \": \", value); };\nhttp.onReceive = (ubyte[] data) { /+ drop +/ return data.length; };\nhttp.perform();\n---\n\nFirst, an instance of the reference-counted HTTP struct is created. Then the\ncustom delegates are set. These will be called whenever the HTTP instance\nreceives a header and a data buffer, respectively. In this simple example, the\nheaders are written to stdout and the data is ignored. If the request should be\nstopped before it has finished then return something less than data.length from\nthe onReceive callback. See $(LREF onReceiveHeader)/$(LREF onReceive) for more\ninformation. Finally the HTTP request is effected by calling perform(), which is\nsynchronous.\n\nSource: $(PHOBOSSRC std/net/_curl.d)\n\nCopyright: Copyright Jonas Drewsen 2011-2012\nLicense: $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors: Jonas Drewsen. Some of the SMTP code contributed by Jimmy Cao.\n\nCredits: The functionally is based on $(HTTP _curl.haxx.se/libcurl, libcurl).\n         LibCurl is licensed under an MIT/X derivative license.\n*/\n/*\n         Copyright Jonas Drewsen 2011 - 2012.\nDistributed under the Boost Software License, Version 1.0.\n   (See accompanying file LICENSE_1_0.txt or copy at\n         http://www.boost.org/LICENSE_1_0.txt)\n*/\nmodule std.net.curl;\n\nimport core.thread;\nimport etc.c.curl;\nimport std.algorithm;\nimport std.array;\nimport std.concurrency;\nimport std.conv;\nimport std.datetime;\nimport std.encoding;\nimport std.exception;\nimport std.meta;\nimport std.regex;\nimport std.socket : InternetAddress;\nimport std.string;\nimport std.traits;\nimport std.typecons;\n\nimport std.internal.cstring;\n\npublic import etc.c.curl : CurlOption;\n\nversion(unittest)\n{\n    // Run unit test with the PHOBOS_TEST_ALLOW_NET=1 set in order to\n    // allow net traffic\n    import std.stdio;\n    import std.range;\n    import std.process : environment;\n    import std.file : deleteme;\n    import std.path : buildPath;\n\n    import std.socket : Address, INADDR_LOOPBACK, Socket, TcpSocket;\n\n    private struct TestServer\n    {\n        string addr() { return _addr; }\n\n        void handle(void function(Socket s) dg)\n        {\n            tid.send(dg);\n        }\n\n    private:\n        string _addr;\n        Tid tid;\n\n        static void loop(shared TcpSocket listener)\n        {\n            try while (true)\n            {\n                void function(Socket) handler = void;\n                try\n                    handler = receiveOnly!(typeof(handler));\n                catch (OwnerTerminated)\n                    return;\n                handler((cast()listener).accept);\n            }\n            catch (Throwable e)\n            {\n                import core.stdc.stdlib : exit, EXIT_FAILURE;\n                stderr.writeln(e);\n                exit(EXIT_FAILURE); // Bugzilla 7018\n            }\n        }\n    }\n\n    private TestServer startServer()\n    {\n        auto sock = new TcpSocket;\n        sock.bind(new InternetAddress(INADDR_LOOPBACK, InternetAddress.PORT_ANY));\n        sock.listen(1);\n        auto addr = sock.localAddress.toString();\n        auto tid = spawn(&TestServer.loop, cast(shared)sock);\n        return TestServer(addr, tid);\n    }\n\n    private ref TestServer testServer()\n    {\n        __gshared TestServer server;\n        return initOnce!server(startServer());\n    }\n\n    private struct Request(T)\n    {\n        string hdrs;\n        immutable(T)[] bdy;\n    }\n\n    private Request!T recvReq(T=char)(Socket s)\n    {\n        ubyte[1024] tmp=void;\n        ubyte[] buf;\n\n        while (true)\n        {\n            auto nbytes = s.receive(tmp[]);\n            assert(nbytes >= 0);\n\n            immutable beg = buf.length > 3 ? buf.length - 3 : 0;\n            buf ~= tmp[0 .. nbytes];\n            auto bdy = buf[beg .. $].find(cast(ubyte[])\"\\r\\n\\r\\n\");\n            if (bdy.empty)\n                continue;\n\n            auto hdrs = cast(string)buf[0 .. $ - bdy.length];\n            bdy.popFrontN(4);\n            // no support for chunked transfer-encoding\n            if (auto m = hdrs.matchFirst(ctRegex!(`Content-Length: ([0-9]+)`, \"i\")))\n            {\n                import std.uni : asUpperCase;\n                if (hdrs.asUpperCase.canFind(\"EXPECT: 100-CONTINUE\"))\n                    s.send(httpContinue);\n\n                size_t remain = m.captures[1].to!size_t - bdy.length;\n                while (remain)\n                {\n                    nbytes = s.receive(tmp[0 .. min(remain, $)]);\n                    assert(nbytes >= 0);\n                    buf ~= tmp[0 .. nbytes];\n                    remain -= nbytes;\n                }\n            }\n            else\n            {\n                assert(bdy.empty);\n            }\n            bdy = buf[hdrs.length + 4 .. $];\n            return typeof(return)(hdrs, cast(immutable(T)[])bdy);\n        }\n    }\n\n    private string httpOK(string msg)\n    {\n        return \"HTTP/1.1 200 OK\\r\\n\"~\n            \"Content-Type: text/plain\\r\\n\"~\n            \"Content-Length: \"~msg.length.to!string~\"\\r\\n\"~\n            \"\\r\\n\"~\n            msg;\n    }\n\n    private string httpOK()\n    {\n        return \"HTTP/1.1 200 OK\\r\\n\"~\n            \"Content-Length: 0\\r\\n\"~\n            \"\\r\\n\";\n    }\n\n    private string httpNotFound()\n    {\n        return \"HTTP/1.1 404 Not Found\\r\\n\"~\n            \"Content-Length: 0\\r\\n\"~\n            \"\\r\\n\";\n    }\n\n    private enum httpContinue = \"HTTP/1.1 100 Continue\\r\\n\\r\\n\";\n}\nversion(StdDdoc) import std.stdio;\n\n// Default data timeout for Protocols\nprivate enum _defaultDataTimeout = dur!\"minutes\"(2);\n\n/**\nMacros:\n\nCALLBACK_PARAMS = $(TABLE ,\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM dlTotal))\n        $(DDOC_PARAM_DESC total bytes to download)\n        )\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM dlNow))\n        $(DDOC_PARAM_DESC currently downloaded bytes)\n        )\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM ulTotal))\n        $(DDOC_PARAM_DESC total bytes to upload)\n        )\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM ulNow))\n        $(DDOC_PARAM_DESC currently uploaded bytes)\n        )\n)\n*/\n\n/** Connection type used when the URL should be used to auto detect the protocol.\n  *\n  * This struct is used as placeholder for the connection parameter when calling\n  * the high level API and the connection type (HTTP/FTP) should be guessed by\n  * inspecting the URL parameter.\n  *\n  * The rules for guessing the protocol are:\n  * 1, if URL starts with ftp://, ftps:// or ftp. then FTP connection is assumed.\n  * 2, HTTP connection otherwise.\n  *\n  * Example:\n  * ---\n  * import std.net.curl;\n  * // Two requests below will do the same.\n  * string content;\n  *\n  * // Explicit connection provided\n  * content = get!HTTP(\"dlang.org\");\n  *\n  * // Guess connection type by looking at the URL\n  * content = get!AutoProtocol(\"ftp://foo.com/file\");\n  * // and since AutoProtocol is default this is the same as\n  * content = get(\"ftp://foo.com/file\");\n  * // and will end up detecting FTP from the url and be the same as\n  * content = get!FTP(\"ftp://foo.com/file\");\n  * ---\n  */\nstruct AutoProtocol { }\n\n// Returns true if the url points to an FTP resource\nprivate bool isFTPUrl(const(char)[] url)\n{\n    return startsWith(url.toLower(), \"ftp://\", \"ftps://\", \"ftp.\") != 0;\n}\n\n// Is true if the Conn type is a valid Curl Connection type.\nprivate template isCurlConn(Conn)\n{\n    enum auto isCurlConn = is(Conn : HTTP) ||\n        is(Conn : FTP) || is(Conn : AutoProtocol);\n}\n\n/** HTTP/FTP download to local file system.\n *\n * Params:\n * url = resource to download\n * saveToPath = path to store the downloaded content on local disk\n * conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n *        guess connection type and create a new instance for this call only.\n *\n * Example:\n * ----\n * import std.net.curl;\n * download(\"d-lang.appspot.com/testUrl2\", \"/tmp/downloaded-http-file\");\n * ----\n */\nvoid download(Conn = AutoProtocol)(const(char)[] url, string saveToPath, Conn conn = Conn())\n    if (isCurlConn!Conn)\n{\n    static if (is(Conn : HTTP) || is(Conn : FTP))\n    {\n        import std.stdio : File;\n        conn.url = url;\n        auto f = File(saveToPath, \"wb\");\n        conn.onReceive = (ubyte[] data) { f.rawWrite(data); return data.length; };\n        conn.perform();\n    }\n    else\n    {\n        if (isFTPUrl(url))\n            return download!FTP(url, saveToPath, FTP());\n        else\n            return download!HTTP(url, saveToPath, HTTP());\n    }\n}\n\nunittest\n{\n    static import std.file;\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            assert(s.recvReq.hdrs.canFind(\"GET /\"));\n            s.send(httpOK(\"Hello world\"));\n        });\n        auto fn = std.file.deleteme;\n        scope (exit) std.file.remove(fn);\n        download(host, fn);\n        assert(std.file.readText(fn) == \"Hello world\");\n    }\n}\n\n/** Upload file from local files system using the HTTP or FTP protocol.\n *\n * Params:\n * loadFromPath = path load data from local disk.\n * url = resource to upload to\n * conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n *        guess connection type and create a new instance for this call only.\n *\n * Example:\n * ----\n * import std.net.curl;\n * upload(\"/tmp/downloaded-ftp-file\", \"ftp.digitalmars.com/sieve.ds\");\n * upload(\"/tmp/downloaded-http-file\", \"d-lang.appspot.com/testUrl2\");\n * ----\n */\nvoid upload(Conn = AutoProtocol)(string loadFromPath, const(char)[] url, Conn conn = Conn())\n    if (isCurlConn!Conn)\n{\n    static if (is(Conn : HTTP))\n    {\n        conn.url = url;\n        conn.method = HTTP.Method.put;\n    }\n    else static if (is(Conn : FTP))\n    {\n        conn.url = url;\n        conn.handle.set(CurlOption.upload, 1L);\n    }\n    else\n    {\n        if (isFTPUrl(url))\n            return upload!FTP(loadFromPath, url, FTP());\n        else\n            return upload!HTTP(loadFromPath, url, HTTP());\n    }\n\n    static if (is(Conn : HTTP) || is(Conn : FTP))\n    {\n        import std.stdio : File;\n        auto f = File(loadFromPath, \"rb\");\n        conn.onSend = buf => f.rawRead(buf).length;\n        auto sz = f.size;\n        if (sz != ulong.max)\n            conn.contentLength = sz;\n        conn.perform();\n    }\n}\n\nunittest\n{\n    static import std.file;\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        auto fn = std.file.deleteme;\n        scope (exit) std.file.remove(fn);\n        std.file.write(fn, \"upload data\\n\");\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            assert(req.hdrs.canFind(\"PUT /path\"));\n            assert(req.bdy.canFind(\"upload data\"));\n            s.send(httpOK());\n        });\n        upload(fn, host ~ \"/path\");\n    }\n}\n\n/** HTTP/FTP get content.\n *\n * Params:\n * url = resource to get\n * conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n *        guess connection type and create a new instance for this call only.\n *\n * The template parameter $(D T) specifies the type to return. Possible values\n * are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]). If asking\n * for $(D char), content will be converted from the connection character set\n * (specified in HTTP response headers or FTP connection properties, both ISO-8859-1\n * by default) to UTF-8.\n *\n * Example:\n * ----\n * import std.net.curl;\n * auto content = get(\"d-lang.appspot.com/testUrl2\");\n * ----\n *\n * Returns:\n * A T[] range containing the content of the resource pointed to by the URL.\n *\n * Throws:\n *\n * $(D CurlException) on error.\n *\n * See_Also: $(LREF HTTP.Method)\n */\nT[] get(Conn = AutoProtocol, T = char)(const(char)[] url, Conn conn = Conn())\n    if ( isCurlConn!Conn && (is(T == char) || is(T == ubyte)) )\n{\n    static if (is(Conn : HTTP))\n    {\n        conn.method = HTTP.Method.get;\n        return _basicHTTP!(T)(url, \"\", conn);\n\n    }\n    else static if (is(Conn : FTP))\n    {\n        return _basicFTP!(T)(url, \"\", conn);\n    }\n    else\n    {\n        if (isFTPUrl(url))\n            return get!(FTP,T)(url, FTP());\n        else\n            return get!(HTTP,T)(url, HTTP());\n    }\n}\n\nunittest\n{\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            assert(s.recvReq.hdrs.canFind(\"GET /path\"));\n            s.send(httpOK(\"GETRESPONSE\"));\n        });\n        auto res = get(host ~ \"/path\");\n        assert(res == \"GETRESPONSE\");\n    }\n}\n\n\n/** HTTP post content.\n *\n * Params:\n *     url = resource to post to\n *     postDict = data to send as the body of the request. An associative array\n *                of $(D string) is accepted and will be encoded using\n *                www-form-urlencoding\n *     postData = data to send as the body of the request. An array\n *                of an arbitrary type is accepted and will be cast to ubyte[]\n *                before sending it.\n *     conn = HTTP connection to use\n *     T    = The template parameter $(D T) specifies the type to return. Possible values\n *            are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]). If asking\n *            for $(D char), content will be converted from the connection character set\n *            (specified in HTTP response headers or FTP connection properties, both ISO-8859-1\n *            by default) to UTF-8.\n *\n * Examples:\n * ----\n * import std.net.curl;\n *\n * auto content1 = post(\"d-lang.appspot.com/testUrl2\", [\"name1\" : \"value1\", \"name2\" : \"value2\"]);\n * auto content2 = post(\"d-lang.appspot.com/testUrl2\", [1,2,3,4]);\n * ----\n *\n * Returns:\n * A T[] range containing the content of the resource pointed to by the URL.\n *\n * See_Also: $(LREF HTTP.Method)\n */\nT[] post(T = char, PostUnit)(const(char)[] url, const(PostUnit)[] postData, HTTP conn = HTTP())\nif (is(T == char) || is(T == ubyte))\n{\n    conn.method = HTTP.Method.post;\n    return _basicHTTP!(T)(url, postData, conn);\n}\n\nunittest\n{\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            assert(req.hdrs.canFind(\"POST /path\"));\n            assert(req.bdy.canFind(\"POSTBODY\"));\n            s.send(httpOK(\"POSTRESPONSE\"));\n        });\n        auto res = post(host ~ \"/path\", \"POSTBODY\");\n        assert(res == \"POSTRESPONSE\");\n    }\n}\n\nunittest\n{\n    auto data = new ubyte[](256);\n    foreach (i, ref ub; data)\n        ub = cast(ubyte)i;\n\n    testServer.handle((s) {\n        auto req = s.recvReq!ubyte;\n        assert(req.bdy.canFind(cast(ubyte[])[0, 1, 2, 3, 4]));\n        assert(req.bdy.canFind(cast(ubyte[])[253, 254, 255]));\n        s.send(httpOK(cast(ubyte[])[17, 27, 35, 41]));\n    });\n    auto res = post!ubyte(testServer.addr, data);\n    assert(res == cast(ubyte[])[17, 27, 35, 41]);\n}\n\n/// ditto\nT[] post(T = char)(const(char)[] url, string[string] postDict, HTTP conn = HTTP())\nif (is(T == char) || is(T == ubyte))\n{\n    import std.uri : urlEncode;\n\n    return post(url, urlEncode(postDict), conn);\n}\n\nunittest\n{\n    foreach (host; [testServer.addr, \"http://\" ~ testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq!char;\n            s.send(httpOK(req.bdy));\n        });\n        auto res = post(host ~ \"/path\", [\"name1\" : \"value1\", \"name2\" : \"value2\"]);\n        assert(res == \"name1=value1&name2=value2\");\n    }\n}\n\n/** HTTP/FTP put content.\n *\n * Params:\n * url = resource to put\n * putData = data to send as the body of the request. An array\n *           of an arbitrary type is accepted and will be cast to ubyte[]\n *           before sending it.\n * conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n *        guess connection type and create a new instance for this call only.\n *\n * The template parameter $(D T) specifies the type to return. Possible values\n * are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]). If asking\n * for $(D char), content will be converted from the connection character set\n * (specified in HTTP response headers or FTP connection properties, both ISO-8859-1\n * by default) to UTF-8.\n *\n * Example:\n * ----\n * import std.net.curl;\n * auto content = put(\"d-lang.appspot.com/testUrl2\",\n *                      \"Putting this data\");\n * ----\n *\n * Returns:\n * A T[] range containing the content of the resource pointed to by the URL.\n *\n * See_Also: $(LREF HTTP.Method)\n */\nT[] put(Conn = AutoProtocol, T = char, PutUnit)(const(char)[] url, const(PutUnit)[] putData,\n                                                  Conn conn = Conn())\n    if ( isCurlConn!Conn && (is(T == char) || is(T == ubyte)) )\n{\n    static if (is(Conn : HTTP))\n    {\n        conn.method = HTTP.Method.put;\n        return _basicHTTP!(T)(url, putData, conn);\n    }\n    else static if (is(Conn : FTP))\n    {\n        return _basicFTP!(T)(url, putData, conn);\n    }\n    else\n    {\n        if (isFTPUrl(url))\n            return put!(FTP,T)(url, putData, FTP());\n        else\n            return put!(HTTP,T)(url, putData, HTTP());\n    }\n}\n\nunittest\n{\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            assert(req.hdrs.canFind(\"PUT /path\"));\n            assert(req.bdy.canFind(\"PUTBODY\"));\n            s.send(httpOK(\"PUTRESPONSE\"));\n        });\n        auto res = put(host ~ \"/path\", \"PUTBODY\");\n        assert(res == \"PUTRESPONSE\");\n    }\n}\n\n\n/** HTTP/FTP delete content.\n *\n * Params:\n * url = resource to delete\n * conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n *        guess connection type and create a new instance for this call only.\n *\n * Example:\n * ----\n * import std.net.curl;\n * del(\"d-lang.appspot.com/testUrl2\");\n * ----\n *\n * See_Also: $(LREF HTTP.Method)\n */\nvoid del(Conn = AutoProtocol)(const(char)[] url, Conn conn = Conn())\n    if (isCurlConn!Conn)\n{\n    static if (is(Conn : HTTP))\n    {\n        conn.method = HTTP.Method.del;\n        _basicHTTP!char(url, cast(void[]) null, conn);\n    }\n    else static if (is(Conn : FTP))\n    {\n        auto trimmed = url.findSplitAfter(\"ftp://\")[1];\n        auto t = trimmed.findSplitAfter(\"/\");\n        enum minDomainNameLength = 3;\n        enforce!CurlException(t[0].length > minDomainNameLength,\n                                text(\"Invalid FTP URL for delete \", url));\n        conn.url = t[0];\n\n        enforce!CurlException(!t[1].empty,\n                                text(\"No filename specified to delete for URL \", url));\n        conn.addCommand(\"DELE \" ~ t[1]);\n        conn.perform();\n    }\n    else\n    {\n        if (isFTPUrl(url))\n            return del!FTP(url, FTP());\n        else\n            return del!HTTP(url, HTTP());\n    }\n}\n\nunittest\n{\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            assert(req.hdrs.canFind(\"DELETE /path\"));\n            s.send(httpOK());\n        });\n        del(host ~ \"/path\");\n    }\n}\n\n\n/** HTTP options request.\n *\n * Params:\n * url = resource make a option call to\n * conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n *        guess connection type and create a new instance for this call only.\n *\n * The template parameter $(D T) specifies the type to return. Possible values\n * are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]).\n *\n * Example:\n * ----\n * import std.net.curl;\n * auto http = HTTP();\n * options(\"d-lang.appspot.com/testUrl2\", http);\n * writeln(\"Allow set to \" ~ http.responseHeaders[\"Allow\"]);\n * ----\n *\n * Returns:\n * A T[] range containing the options of the resource pointed to by the URL.\n *\n * See_Also: $(LREF HTTP.Method)\n */\nT[] options(T = char)(const(char)[] url, HTTP conn = HTTP())\n    if (is(T == char) || is(T == ubyte))\n{\n    conn.method = HTTP.Method.options;\n    return _basicHTTP!(T)(url, null, conn);\n}\n\n// Explicitly undocumented. It will be removed in February 2017. @@@DEPRECATED_2017-02@@@\ndeprecated(\"options does not send any data\")\nT[] options(T = char, OptionsUnit)(const(char)[] url,\n                                   const(OptionsUnit)[] optionsData = null,\n                                   HTTP conn = HTTP())\n    if (is(T == char) || is(T == ubyte))\n{\n    return options!T(url, conn);\n}\n\nunittest\n{\n    testServer.handle((s) {\n        auto req = s.recvReq;\n        assert(req.hdrs.canFind(\"OPTIONS /path\"));\n        s.send(httpOK(\"OPTIONSRESPONSE\"));\n    });\n    auto res = options(testServer.addr ~ \"/path\");\n    assert(res == \"OPTIONSRESPONSE\");\n}\n\n\n/** HTTP trace request.\n *\n * Params:\n * url = resource make a trace call to\n * conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n *        guess connection type and create a new instance for this call only.\n *\n * The template parameter $(D T) specifies the type to return. Possible values\n * are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]).\n *\n * Example:\n * ----\n * import std.net.curl;\n * trace(\"d-lang.appspot.com/testUrl1\");\n * ----\n *\n * Returns:\n * A T[] range containing the trace info of the resource pointed to by the URL.\n *\n * See_Also: $(LREF HTTP.Method)\n */\nT[] trace(T = char)(const(char)[] url, HTTP conn = HTTP())\n   if (is(T == char) || is(T == ubyte))\n{\n    conn.method = HTTP.Method.trace;\n    return _basicHTTP!(T)(url, cast(void[]) null, conn);\n}\n\nunittest\n{\n    testServer.handle((s) {\n        auto req = s.recvReq;\n        assert(req.hdrs.canFind(\"TRACE /path\"));\n        s.send(httpOK(\"TRACERESPONSE\"));\n    });\n    auto res = trace(testServer.addr ~ \"/path\");\n    assert(res == \"TRACERESPONSE\");\n}\n\n\n/** HTTP connect request.\n *\n * Params:\n * url = resource make a connect to\n * conn = HTTP connection to use\n *\n * The template parameter $(D T) specifies the type to return. Possible values\n * are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]).\n *\n * Example:\n * ----\n * import std.net.curl;\n * connect(\"d-lang.appspot.com/testUrl1\");\n * ----\n *\n * Returns:\n * A T[] range containing the connect info of the resource pointed to by the URL.\n *\n * See_Also: $(LREF HTTP.Method)\n */\nT[] connect(T = char)(const(char)[] url, HTTP conn = HTTP())\n   if (is(T == char) || is(T == ubyte))\n{\n    conn.method = HTTP.Method.connect;\n    return _basicHTTP!(T)(url, cast(void[]) null, conn);\n}\n\nunittest\n{\n    testServer.handle((s) {\n        auto req = s.recvReq;\n        assert(req.hdrs.canFind(\"CONNECT /path\"));\n        s.send(httpOK(\"CONNECTRESPONSE\"));\n    });\n    auto res = connect(testServer.addr ~ \"/path\");\n    assert(res == \"CONNECTRESPONSE\");\n}\n\n\n/** HTTP patch content.\n *\n * Params:\n * url = resource to patch\n * patchData = data to send as the body of the request. An array\n *           of an arbitrary type is accepted and will be cast to ubyte[]\n *           before sending it.\n * conn = HTTP connection to use\n *\n * The template parameter $(D T) specifies the type to return. Possible values\n * are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]).\n *\n * Example:\n * ----\n * auto http = HTTP();\n * http.addRequestHeader(\"Content-Type\", \"application/json\");\n * auto content = patch(\"d-lang.appspot.com/testUrl2\", `{\"title\": \"Patched Title\"}`, http);\n * ----\n *\n * Returns:\n * A T[] range containing the content of the resource pointed to by the URL.\n *\n * See_Also: $(LREF HTTP.Method)\n */\nT[] patch(T = char, PatchUnit)(const(char)[] url, const(PatchUnit)[] patchData,\n                               HTTP conn = HTTP())\n    if (is(T == char) || is(T == ubyte))\n{\n    conn.method = HTTP.Method.patch;\n    return _basicHTTP!(T)(url, patchData, conn);\n}\n\nunittest\n{\n    testServer.handle((s) {\n        auto req = s.recvReq;\n        assert(req.hdrs.canFind(\"PATCH /path\"));\n        assert(req.bdy.canFind(\"PATCHBODY\"));\n        s.send(httpOK(\"PATCHRESPONSE\"));\n    });\n    auto res = patch(testServer.addr ~ \"/path\", \"PATCHBODY\");\n    assert(res == \"PATCHRESPONSE\");\n}\n\n\n/*\n * Helper function for the high level interface.\n *\n * It performs an HTTP request using the client which must have\n * been setup correctly before calling this function.\n */\nprivate auto _basicHTTP(T)(const(char)[] url, const(void)[] sendData, HTTP client)\n{\n    immutable doSend = sendData !is null &&\n        (client.method == HTTP.Method.post ||\n         client.method == HTTP.Method.put ||\n         client.method == HTTP.Method.patch);\n\n    scope (exit)\n    {\n        client.onReceiveHeader = null;\n        client.onReceiveStatusLine = null;\n        client.onReceive = null;\n\n        if (doSend)\n        {\n            client.onSend = null;\n            client.handle.onSeek = null;\n            client.contentLength = 0;\n        }\n    }\n    client.url = url;\n    HTTP.StatusLine statusLine;\n    import std.array : appender;\n    auto content = appender!(ubyte[])();\n    client.onReceive = (ubyte[] data)\n    {\n        content ~= data;\n        return data.length;\n    };\n\n    if (doSend)\n    {\n        client.contentLength = sendData.length;\n        auto remainingData = sendData;\n        client.onSend = delegate size_t(void[] buf)\n        {\n            size_t minLen = min(buf.length, remainingData.length);\n            if (minLen == 0) return 0;\n            buf[0..minLen] = remainingData[0..minLen];\n            remainingData = remainingData[minLen..$];\n            return minLen;\n        };\n        client.handle.onSeek = delegate(long offset, CurlSeekPos mode)\n        {\n            switch (mode)\n            {\n                case CurlSeekPos.set:\n                    remainingData = sendData[cast(size_t)offset..$];\n                    return CurlSeek.ok;\n                default:\n                    // As of curl 7.18.0, libcurl will not pass\n                    // anything other than CurlSeekPos.set.\n                    return CurlSeek.cantseek;\n            }\n        };\n    }\n\n    client.onReceiveHeader = (in char[] key,\n                              in char[] value)\n    {\n        if (key == \"content-length\")\n        {\n            import std.conv : to;\n            content.reserve(value.to!size_t);\n        }\n    };\n    client.onReceiveStatusLine = (HTTP.StatusLine l) { statusLine = l; };\n    client.perform();\n    enforce!CurlException(statusLine.code / 100 == 2,\n                            format(\"HTTP request returned status code %d (%s)\",\n                                   statusLine.code, statusLine.reason));\n\n    return _decodeContent!T(content.data, client.p.charset);\n}\n\nunittest\n{\n    testServer.handle((s) {\n        auto req = s.recvReq;\n        assert(req.hdrs.canFind(\"GET /path\"));\n        s.send(httpNotFound());\n    });\n    auto e = collectException!CurlException(get(testServer.addr ~ \"/path\"));\n    assert(e.msg == \"HTTP request returned status code 404 (Not Found)\");\n}\n\n// Bugzilla 14760 - content length must be reset after post\nunittest\n{\n    testServer.handle((s) {\n        auto req = s.recvReq;\n        assert(req.hdrs.canFind(\"POST /\"));\n        assert(req.bdy.canFind(\"POSTBODY\"));\n        s.send(httpOK(\"POSTRESPONSE\"));\n\n        req = s.recvReq;\n        assert(req.hdrs.canFind(\"TRACE /\"));\n        assert(req.bdy.empty);\n        s.blocking = false;\n        ubyte[6] buf = void;\n        assert(s.receive(buf[]) < 0);\n        s.send(httpOK(\"TRACERESPONSE\"));\n    });\n    auto http = HTTP();\n    auto res = post(testServer.addr, \"POSTBODY\", http);\n    assert(res == \"POSTRESPONSE\");\n    res = trace(testServer.addr, http);\n    assert(res == \"TRACERESPONSE\");\n}\n\nunittest // charset detection and transcoding to T\n{\n    testServer.handle((s) {\n        s.send(\"HTTP/1.1 200 OK\\r\\n\"~\n        \"Content-Length: 4\\r\\n\"~\n        \"Content-Type: text/plain; charset=utf-8\\r\\n\" ~\n        \"\\r\\n\" ~\n        \"\u00e4bc\");\n    });\n    auto client = HTTP();\n    auto result = _basicHTTP!char(testServer.addr, \"\", client);\n    assert(result == \"\u00e4bc\");\n\n    testServer.handle((s) {\n        s.send(\"HTTP/1.1 200 OK\\r\\n\"~\n        \"Content-Length: 3\\r\\n\"~\n        \"Content-Type: text/plain; charset=iso-8859-1\\r\\n\" ~\n        \"\\r\\n\" ~\n        0xE4 ~ \"bc\");\n    });\n    client = HTTP();\n    result = _basicHTTP!char(testServer.addr, \"\", client);\n    assert(result == \"\u00e4bc\");\n}\n\n/*\n * Helper function for the high level interface.\n *\n * It performs an FTP request using the client which must have\n * been setup correctly before calling this function.\n */\nprivate auto _basicFTP(T)(const(char)[] url, const(void)[] sendData, FTP client)\n{\n    scope (exit)\n    {\n        client.onReceive = null;\n        if (!sendData.empty)\n            client.onSend = null;\n    }\n\n    ubyte[] content;\n\n    if (client.encoding.empty)\n        client.encoding = \"ISO-8859-1\";\n\n    client.url = url;\n    client.onReceive = (ubyte[] data)\n    {\n        content ~= data;\n        return data.length;\n    };\n\n    if (!sendData.empty)\n    {\n        client.handle.set(CurlOption.upload, 1L);\n        client.onSend = delegate size_t(void[] buf)\n        {\n            size_t minLen = min(buf.length, sendData.length);\n            if (minLen == 0) return 0;\n            buf[0..minLen] = sendData[0..minLen];\n            sendData = sendData[minLen..$];\n            return minLen;\n        };\n    }\n\n    client.perform();\n\n    return _decodeContent!T(content, client.encoding);\n}\n\n/* Used by _basicHTTP() and _basicFTP() to decode ubyte[] to\n * correct string format\n */\nprivate auto _decodeContent(T)(ubyte[] content, string encoding)\n{\n    static if (is(T == ubyte))\n    {\n        return content;\n    }\n    else\n    {\n        // Optimally just return the utf8 encoded content\n        if (encoding == \"UTF-8\")\n            return cast(char[])(content);\n\n        // The content has to be re-encoded to utf8\n        auto scheme = EncodingScheme.create(encoding);\n        enforce!CurlException(scheme !is null,\n                                format(\"Unknown encoding '%s'\", encoding));\n\n        auto strInfo = decodeString(content, scheme);\n        enforce!CurlException(strInfo[0] != size_t.max,\n                                format(\"Invalid encoding sequence for encoding '%s'\",\n                                       encoding));\n\n        return strInfo[1];\n    }\n}\n\nalias KeepTerminator = Flag!\"keepTerminator\";\n/+\nstruct ByLineBuffer(Char)\n{\n    bool linePresent;\n    bool EOF;\n    Char[] buffer;\n    ubyte[] decodeRemainder;\n\n    bool append(const(ubyte)[] data)\n    {\n        byLineBuffer ~= data;\n    }\n\n    @property bool linePresent()\n    {\n        return byLinePresent;\n    }\n\n    Char[] get()\n    {\n        if (!linePresent)\n        {\n            // Decode ubyte[] into Char[] until a Terminator is found.\n            // If not Terminator is found and EOF is false then raise an\n            // exception.\n        }\n        return byLineBuffer;\n    }\n\n}\n++/\n/** HTTP/FTP fetch content as a range of lines.\n *\n * A range of lines is returned when the request is complete. If the method or\n * other request properties is to be customized then set the $(D conn) parameter\n * with a HTTP/FTP instance that has these properties set.\n *\n * Example:\n * ----\n * import std.net.curl, std.stdio;\n * foreach (line; byLine(\"dlang.org\"))\n *     writeln(line);\n * ----\n *\n * Params:\n * url = The url to receive content from\n * keepTerminator = $(D Yes.keepTerminator) signals that the line terminator should be\n *                  returned as part of the lines in the range.\n * terminator = The character that terminates a line\n * conn = The connection to use e.g. HTTP or FTP.\n *\n * Returns:\n * A range of Char[] with the content of the resource pointer to by the URL\n */\nauto byLine(Conn = AutoProtocol, Terminator = char, Char = char)\n           (const(char)[] url, KeepTerminator keepTerminator = No.keepTerminator,\n            Terminator terminator = '\\n', Conn conn = Conn())\nif (isCurlConn!Conn && isSomeChar!Char && isSomeChar!Terminator)\n{\n    static struct SyncLineInputRange\n    {\n\n        private Char[] lines;\n        private Char[] current;\n        private bool currentValid;\n        private bool keepTerminator;\n        private Terminator terminator;\n\n        this(Char[] lines, bool kt, Terminator terminator)\n        {\n            this.lines = lines;\n            this.keepTerminator = kt;\n            this.terminator = terminator;\n            currentValid = true;\n            popFront();\n        }\n\n        @property @safe bool empty()\n        {\n            return !currentValid;\n        }\n\n        @property @safe Char[] front()\n        {\n            enforce!CurlException(currentValid, \"Cannot call front() on empty range\");\n            return current;\n        }\n\n        void popFront()\n        {\n            enforce!CurlException(currentValid, \"Cannot call popFront() on empty range\");\n            if (lines.empty)\n            {\n                currentValid = false;\n                return;\n            }\n\n            if (keepTerminator)\n            {\n                auto r = findSplitAfter(lines, [ terminator ]);\n                if (r[0].empty)\n                {\n                    current = r[1];\n                    lines = r[0];\n                }\n                else\n                {\n                    current = r[0];\n                    lines = r[1];\n                }\n            }\n            else\n            {\n                auto r = findSplit(lines, [ terminator ]);\n                current = r[0];\n                lines = r[2];\n            }\n        }\n    }\n\n    auto result = _getForRange!Char(url, conn);\n    return SyncLineInputRange(result, keepTerminator == Yes.keepTerminator, terminator);\n}\n\nunittest\n{\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            s.send(httpOK(\"Line1\\nLine2\\nLine3\"));\n        });\n        assert(byLine(host).equal([\"Line1\", \"Line2\", \"Line3\"]));\n    }\n}\n\n/** HTTP/FTP fetch content as a range of chunks.\n *\n * A range of chunks is returned when the request is complete. If the method or\n * other request properties is to be customized then set the $(D conn) parameter\n * with a HTTP/FTP instance that has these properties set.\n *\n * Example:\n * ----\n * import std.net.curl, std.stdio;\n * foreach (chunk; byChunk(\"dlang.org\", 100))\n *     writeln(chunk); // chunk is ubyte[100]\n * ----\n *\n * Params:\n * url = The url to receive content from\n * chunkSize = The size of each chunk\n * conn = The connection to use e.g. HTTP or FTP.\n *\n * Returns:\n * A range of ubyte[chunkSize] with the content of the resource pointer to by the URL\n */\nauto byChunk(Conn = AutoProtocol)\n            (const(char)[] url, size_t chunkSize = 1024, Conn conn = Conn())\n    if (isCurlConn!(Conn))\n{\n    static struct SyncChunkInputRange\n    {\n        private size_t chunkSize;\n        private ubyte[] _bytes;\n        private size_t offset;\n\n        this(ubyte[] bytes, size_t chunkSize)\n        {\n            this._bytes = bytes;\n            this.chunkSize = chunkSize;\n        }\n\n        @property @safe auto empty()\n        {\n            return offset == _bytes.length;\n        }\n\n        @property ubyte[] front()\n        {\n            size_t nextOffset = offset + chunkSize;\n            if (nextOffset > _bytes.length) nextOffset = _bytes.length;\n            return _bytes[offset..nextOffset];\n        }\n\n        @safe void popFront()\n        {\n            offset += chunkSize;\n            if (offset > _bytes.length) offset = _bytes.length;\n        }\n    }\n\n    auto result = _getForRange!ubyte(url, conn);\n    return SyncChunkInputRange(result, chunkSize);\n}\n\nunittest\n{\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            s.send(httpOK(cast(ubyte[])[0, 1, 2, 3, 4, 5]));\n        });\n        assert(byChunk(host, 2).equal([[0, 1], [2, 3], [4, 5]]));\n    }\n}\n\nprivate T[] _getForRange(T,Conn)(const(char)[] url, Conn conn)\n{\n    static if (is(Conn : HTTP))\n    {\n        conn.method = conn.method == HTTP.Method.undefined ? HTTP.Method.get : conn.method;\n        return _basicHTTP!(T)(url, null, conn);\n    }\n    else static if (is(Conn : FTP))\n    {\n        return _basicFTP!(T)(url, null, conn);\n    }\n    else\n    {\n        if (isFTPUrl(url))\n            return get!(FTP,T)(url, FTP());\n        else\n            return get!(HTTP,T)(url, HTTP());\n    }\n}\n\n/*\n  Main thread part of the message passing protocol used for all async\n  curl protocols.\n */\nprivate mixin template WorkerThreadProtocol(Unit, alias units)\n{\n    @property bool empty()\n    {\n        tryEnsureUnits();\n        return state == State.done;\n    }\n\n    @property Unit[] front()\n    {\n        tryEnsureUnits();\n        assert(state == State.gotUnits,\n               format(\"Expected %s but got $s\",\n                      State.gotUnits, state));\n        return units;\n    }\n\n    void popFront()\n    {\n        tryEnsureUnits();\n        assert(state == State.gotUnits,\n               format(\"Expected %s but got $s\",\n                      State.gotUnits, state));\n        state = State.needUnits;\n        // Send to worker thread for buffer reuse\n        workerTid.send(cast(immutable(Unit)[]) units);\n        units = null;\n    }\n\n    /** Wait for duration or until data is available and return true if data is\n         available\n    */\n    bool wait(Duration d)\n    {\n        if (state == State.gotUnits)\n            return true;\n\n        enum noDur = dur!\"hnsecs\"(0);\n        StopWatch sw;\n        sw.start();\n        while (state != State.gotUnits && d > noDur)\n        {\n            final switch (state)\n            {\n            case State.needUnits:\n                receiveTimeout(d,\n                        (Tid origin, CurlMessage!(immutable(Unit)[]) _data)\n                        {\n                            if (origin != workerTid)\n                                return false;\n                            units = cast(Unit[]) _data.data;\n                            state = State.gotUnits;\n                            return true;\n                        },\n                        (Tid origin, CurlMessage!bool f)\n                        {\n                            if (origin != workerTid)\n                                return false;\n                            state = state.done;\n                            return true;\n                        }\n                        );\n                break;\n            case State.gotUnits: return true;\n            case State.done:\n                return false;\n            }\n            d -= sw.peek();\n            sw.reset();\n        }\n        return state == State.gotUnits;\n    }\n\n    enum State\n    {\n        needUnits,\n        gotUnits,\n        done\n    }\n    State state;\n\n    void tryEnsureUnits()\n    {\n        while (true)\n        {\n            final switch (state)\n            {\n            case State.needUnits:\n                receive(\n                        (Tid origin, CurlMessage!(immutable(Unit)[]) _data)\n                        {\n                            if (origin != workerTid)\n                                return false;\n                            units = cast(Unit[]) _data.data;\n                            state = State.gotUnits;\n                            return true;\n                        },\n                        (Tid origin, CurlMessage!bool f)\n                        {\n                            if (origin != workerTid)\n                                return false;\n                            state = state.done;\n                            return true;\n                        }\n                        );\n                break;\n            case State.gotUnits: return;\n            case State.done:\n                return;\n            }\n        }\n    }\n}\n\n// @@@@BUG 15831@@@@\n// this should be inside byLineAsync\n// Range that reads one line at a time asynchronously.\nprivate static struct AsyncLineInputRange(Char)\n{\n    private Char[] line;\n    mixin WorkerThreadProtocol!(Char, line);\n\n    private Tid workerTid;\n    private State running;\n\n    private this(Tid tid, size_t transmitBuffers, size_t bufferSize)\n    {\n        workerTid = tid;\n        state = State.needUnits;\n\n        // Send buffers to other thread for it to use.  Since no mechanism is in\n        // place for moving ownership a cast to shared is done here and casted\n        // back to non-shared in the receiving end.\n        foreach (i ; 0..transmitBuffers)\n        {\n            auto arr = new Char[](bufferSize);\n            workerTid.send(cast(immutable(Char[]))arr);\n        }\n    }\n}\n\n/** HTTP/FTP fetch content as a range of lines asynchronously.\n *\n * A range of lines is returned immediately and the request that fetches the\n * lines is performed in another thread. If the method or other request\n * properties is to be customized then set the $(D conn) parameter with a\n * HTTP/FTP instance that has these properties set.\n *\n * If $(D postData) is non-_null the method will be set to $(D post) for HTTP\n * requests.\n *\n * The background thread will buffer up to transmitBuffers number of lines\n * before it stops receiving data from network. When the main thread reads the\n * lines from the range it frees up buffers and allows for the background thread\n * to receive more data from the network.\n *\n * If no data is available and the main thread accesses the range it will block\n * until data becomes available. An exception to this is the $(D wait(Duration)) method on\n * the $(LREF AsyncLineInputRange). This method will wait at maximum for the\n * specified duration and return true if data is available.\n *\n * Example:\n * ----\n * import std.net.curl, std.stdio;\n * // Get some pages in the background\n * auto range1 = byLineAsync(\"www.google.com\");\n * auto range2 = byLineAsync(\"www.wikipedia.org\");\n * foreach (line; byLineAsync(\"dlang.org\"))\n *     writeln(line);\n *\n * // Lines already fetched in the background and ready\n * foreach (line; range1) writeln(line);\n * foreach (line; range2) writeln(line);\n * ----\n *\n * ----\n * import std.net.curl, std.stdio;\n * // Get a line in a background thread and wait in\n * // main thread for 2 seconds for it to arrive.\n * auto range3 = byLineAsync(\"dlang.com\");\n * if (range3.wait(dur!\"seconds\"(2)))\n *     writeln(range3.front);\n * else\n *     writeln(\"No line received after 2 seconds!\");\n * ----\n *\n * Params:\n * url = The url to receive content from\n * postData = Data to HTTP Post\n * keepTerminator = $(D Yes.keepTerminator) signals that the line terminator should be\n *                  returned as part of the lines in the range.\n * terminator = The character that terminates a line\n * transmitBuffers = The number of lines buffered asynchronously\n * conn = The connection to use e.g. HTTP or FTP.\n *\n * Returns:\n * A range of Char[] with the content of the resource pointer to by the\n * URL.\n */\nauto byLineAsync(Conn = AutoProtocol, Terminator = char, Char = char, PostUnit)\n            (const(char)[] url, const(PostUnit)[] postData,\n             KeepTerminator keepTerminator = No.keepTerminator,\n             Terminator terminator = '\\n',\n             size_t transmitBuffers = 10, Conn conn = Conn())\n    if (isCurlConn!Conn && isSomeChar!Char && isSomeChar!Terminator)\n{\n    static if (is(Conn : AutoProtocol))\n    {\n        if (isFTPUrl(url))\n            return byLineAsync(url, postData, keepTerminator,\n                               terminator, transmitBuffers, FTP());\n        else\n            return byLineAsync(url, postData, keepTerminator,\n                               terminator, transmitBuffers, HTTP());\n    }\n    else\n    {\n        // 50 is just an arbitrary number for now\n        setMaxMailboxSize(thisTid, 50, OnCrowding.block);\n        auto tid = spawn(&_spawnAsync!(Conn, Char, Terminator));\n        tid.send(thisTid);\n        tid.send(terminator);\n        tid.send(keepTerminator == Yes.keepTerminator);\n\n        _asyncDuplicateConnection(url, conn, postData, tid);\n\n        return AsyncLineInputRange!Char(tid, transmitBuffers,\n                                        Conn.defaultAsyncStringBufferSize);\n    }\n}\n\n/// ditto\nauto byLineAsync(Conn = AutoProtocol, Terminator = char, Char = char)\n            (const(char)[] url, KeepTerminator keepTerminator = No.keepTerminator,\n             Terminator terminator = '\\n',\n             size_t transmitBuffers = 10, Conn conn = Conn())\n{\n    static if (is(Conn : AutoProtocol))\n    {\n        if (isFTPUrl(url))\n            return byLineAsync(url, cast(void[])null, keepTerminator,\n                               terminator, transmitBuffers, FTP());\n        else\n            return byLineAsync(url, cast(void[])null, keepTerminator,\n                               terminator, transmitBuffers, HTTP());\n    }\n    else\n    {\n        return byLineAsync(url, cast(void[])null, keepTerminator,\n                           terminator, transmitBuffers, conn);\n    }\n}\n\nunittest\n{\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            s.send(httpOK(\"Line1\\nLine2\\nLine3\"));\n        });\n        assert(byLineAsync(host).equal([\"Line1\", \"Line2\", \"Line3\"]));\n    }\n}\n\n// @@@@BUG 15831@@@@\n// this should be inside byLineAsync\n// Range that reads one chunk at a time asynchronously.\nprivate static struct AsyncChunkInputRange\n{\n    private ubyte[] chunk;\n    mixin WorkerThreadProtocol!(ubyte, chunk);\n\n    private Tid workerTid;\n    private State running;\n\n    private this(Tid tid, size_t transmitBuffers, size_t chunkSize)\n    {\n        workerTid = tid;\n        state = State.needUnits;\n\n        // Send buffers to other thread for it to use.  Since no mechanism is in\n        // place for moving ownership a cast to shared is done here and a cast\n        // back to non-shared in the receiving end.\n        foreach (i ; 0..transmitBuffers)\n        {\n            ubyte[] arr = new ubyte[](chunkSize);\n            workerTid.send(cast(immutable(ubyte[]))arr);\n        }\n    }\n}\n\n/** HTTP/FTP fetch content as a range of chunks asynchronously.\n *\n * A range of chunks is returned immediately and the request that fetches the\n * chunks is performed in another thread. If the method or other request\n * properties is to be customized then set the $(D conn) parameter with a\n * HTTP/FTP instance that has these properties set.\n *\n * If $(D postData) is non-_null the method will be set to $(D post) for HTTP\n * requests.\n *\n * The background thread will buffer up to transmitBuffers number of chunks\n * before is stops receiving data from network. When the main thread reads the\n * chunks from the range it frees up buffers and allows for the background\n * thread to receive more data from the network.\n *\n * If no data is available and the main thread access the range it will block\n * until data becomes available. An exception to this is the $(D wait(Duration))\n * method on the $(LREF AsyncChunkInputRange). This method will wait at maximum for the specified\n * duration and return true if data is available.\n *\n * Example:\n * ----\n * import std.net.curl, std.stdio;\n * // Get some pages in the background\n * auto range1 = byChunkAsync(\"www.google.com\", 100);\n * auto range2 = byChunkAsync(\"www.wikipedia.org\");\n * foreach (chunk; byChunkAsync(\"dlang.org\"))\n *     writeln(chunk); // chunk is ubyte[100]\n *\n * // Chunks already fetched in the background and ready\n * foreach (chunk; range1) writeln(chunk);\n * foreach (chunk; range2) writeln(chunk);\n * ----\n *\n * ----\n * import std.net.curl, std.stdio;\n * // Get a line in a background thread and wait in\n * // main thread for 2 seconds for it to arrive.\n * auto range3 = byChunkAsync(\"dlang.com\", 10);\n * if (range3.wait(dur!\"seconds\"(2)))\n *     writeln(range3.front);\n * else\n *     writeln(\"No chunk received after 2 seconds!\");\n * ----\n *\n * Params:\n * url = The url to receive content from\n * postData = Data to HTTP Post\n * chunkSize = The size of the chunks\n * transmitBuffers = The number of chunks buffered asynchronously\n * conn = The connection to use e.g. HTTP or FTP.\n *\n * Returns:\n * A range of ubyte[chunkSize] with the content of the resource pointer to by\n * the URL.\n */\nauto byChunkAsync(Conn = AutoProtocol, PostUnit)\n           (const(char)[] url, const(PostUnit)[] postData,\n            size_t chunkSize = 1024, size_t transmitBuffers = 10,\n            Conn conn = Conn())\n    if (isCurlConn!(Conn))\n{\n    static if (is(Conn : AutoProtocol))\n    {\n        if (isFTPUrl(url))\n            return byChunkAsync(url, postData, chunkSize,\n                                transmitBuffers, FTP());\n        else\n            return byChunkAsync(url, postData, chunkSize,\n                                transmitBuffers, HTTP());\n    }\n    else\n    {\n        // 50 is just an arbitrary number for now\n        setMaxMailboxSize(thisTid, 50, OnCrowding.block);\n        auto tid = spawn(&_spawnAsync!(Conn, ubyte));\n        tid.send(thisTid);\n\n        _asyncDuplicateConnection(url, conn, postData, tid);\n\n        return AsyncChunkInputRange(tid, transmitBuffers, chunkSize);\n    }\n}\n\n/// ditto\nauto byChunkAsync(Conn = AutoProtocol)\n           (const(char)[] url,\n            size_t chunkSize = 1024, size_t transmitBuffers = 10,\n            Conn conn = Conn())\n    if (isCurlConn!(Conn))\n{\n    static if (is(Conn : AutoProtocol))\n    {\n        if (isFTPUrl(url))\n            return byChunkAsync(url, cast(void[])null, chunkSize,\n                                transmitBuffers, FTP());\n        else\n            return byChunkAsync(url, cast(void[])null, chunkSize,\n                                transmitBuffers, HTTP());\n    }\n    else\n    {\n        return byChunkAsync(url, cast(void[])null, chunkSize,\n                            transmitBuffers, conn);\n    }\n}\n\nunittest\n{\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            s.send(httpOK(cast(ubyte[])[0, 1, 2, 3, 4, 5]));\n        });\n        assert(byChunkAsync(host, 2).equal([[0, 1], [2, 3], [4, 5]]));\n    }\n}\n\n\n/* Used by byLineAsync/byChunkAsync to duplicate an existing connection\n * that can be used exclusively in a spawned thread.\n */\nprivate void _asyncDuplicateConnection(Conn, PostData)\n    (const(char)[] url, Conn conn, PostData postData, Tid tid)\n{\n    // no move semantic available in std.concurrency ie. must use casting.\n    auto connDup = conn.dup();\n    connDup.url = url;\n\n    static if ( is(Conn : HTTP) )\n    {\n        connDup.p.headersOut = null;\n        connDup.method = conn.method == HTTP.Method.undefined ?\n            HTTP.Method.get : conn.method;\n        if (postData !is null)\n        {\n            if (connDup.method == HTTP.Method.put)\n            {\n                connDup.handle.set(CurlOption.infilesize_large,\n                                   postData.length);\n            }\n            else\n            {\n                // post\n                connDup.method = HTTP.Method.post;\n                connDup.handle.set(CurlOption.postfieldsize_large,\n                                   postData.length);\n            }\n            connDup.handle.set(CurlOption.copypostfields,\n                               cast(void*) postData.ptr);\n        }\n        tid.send(cast(ulong)connDup.handle.handle);\n        tid.send(connDup.method);\n    }\n    else\n    {\n        enforce!CurlException(postData is null,\n                                \"Cannot put ftp data using byLineAsync()\");\n        tid.send(cast(ulong)connDup.handle.handle);\n        tid.send(HTTP.Method.undefined);\n    }\n    connDup.p.curl.handle = null; // make sure handle is not freed\n}\n\n/*\n  Mixin template for all supported curl protocols. This is the commom\n  functionallity such as timeouts and network interface settings. This should\n  really be in the HTTP/FTP/SMTP structs but the documentation tool does not\n  support a mixin to put its doc strings where a mixin is done. Therefore docs\n  in this template is copied into each of HTTP/FTP/SMTP below.\n*/\nprivate mixin template Protocol()\n{\n\n    /// Value to return from $(D onSend)/$(D onReceive) delegates in order to\n    /// pause a request\n    alias requestPause = CurlReadFunc.pause;\n\n    /// Value to return from onSend delegate in order to abort a request\n    alias requestAbort = CurlReadFunc.abort;\n\n    static uint defaultAsyncStringBufferSize = 100;\n\n    /**\n       The curl handle used by this connection.\n    */\n    @property ref Curl handle() return\n    {\n        return p.curl;\n    }\n\n    /**\n       True if the instance is stopped. A stopped instance is not usable.\n    */\n    @property bool isStopped()\n    {\n        return p.curl.stopped;\n    }\n\n    /// Stop and invalidate this instance.\n    void shutdown()\n    {\n        p.curl.shutdown();\n    }\n\n    /** Set verbose.\n        This will print request information to stderr.\n     */\n    @property void verbose(bool on)\n    {\n        p.curl.set(CurlOption.verbose, on ? 1L : 0L);\n    }\n\n    // Connection settings\n\n    /// Set timeout for activity on connection.\n    @property void dataTimeout(Duration d)\n    {\n        p.curl.set(CurlOption.low_speed_limit, 1);\n        p.curl.set(CurlOption.low_speed_time, d.total!\"seconds\");\n    }\n\n    /** Set maximum time an operation is allowed to take.\n        This includes dns resolution, connecting, data transfer, etc.\n     */\n    @property void operationTimeout(Duration d)\n    {\n        p.curl.set(CurlOption.timeout_ms, d.total!\"msecs\");\n    }\n\n    /// Set timeout for connecting.\n    @property void connectTimeout(Duration d)\n    {\n        p.curl.set(CurlOption.connecttimeout_ms, d.total!\"msecs\");\n    }\n\n    // Network settings\n\n    /** Proxy\n     *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy)\n     */\n    @property void proxy(const(char)[] host)\n    {\n        p.curl.set(CurlOption.proxy, host);\n    }\n\n    /** Proxy port\n     *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT, _proxy_port)\n     */\n    @property void proxyPort(ushort port)\n    {\n        p.curl.set(CurlOption.proxyport, cast(long) port);\n    }\n\n    /// Type of proxy\n    alias CurlProxy = etc.c.curl.CurlProxy;\n\n    /** Proxy type\n     *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy_type)\n     */\n    @property void proxyType(CurlProxy type)\n    {\n        p.curl.set(CurlOption.proxytype, cast(long) type);\n    }\n\n    /// DNS lookup timeout.\n    @property void dnsTimeout(Duration d)\n    {\n        p.curl.set(CurlOption.dns_cache_timeout, d.total!\"msecs\");\n    }\n\n    /**\n     * The network interface to use in form of the the IP of the interface.\n     *\n     * Example:\n     * ----\n     * theprotocol.netInterface = \"192.168.1.32\";\n     * theprotocol.netInterface = [ 192, 168, 1, 32 ];\n     * ----\n     *\n     * See: $(REF InternetAddress, std,socket)\n     */\n    @property void netInterface(const(char)[] i)\n    {\n        p.curl.set(CurlOption.intrface, i);\n    }\n\n    /// ditto\n    @property void netInterface(const(ubyte)[4] i)\n    {\n        const str = format(\"%d.%d.%d.%d\", i[0], i[1], i[2], i[3]);\n        netInterface = str;\n    }\n\n    /// ditto\n    @property void netInterface(InternetAddress i)\n    {\n        netInterface = i.toAddrString();\n    }\n\n    /**\n       Set the local outgoing port to use.\n       Params:\n       port = the first outgoing port number to try and use\n    */\n    @property void localPort(ushort port)\n    {\n        p.curl.set(CurlOption.localport, cast(long)port);\n    }\n\n    /**\n       Set the local outgoing port range to use.\n       This can be used together with the localPort property.\n       Params:\n       range = if the first port is occupied then try this many\n               port number forwards\n    */\n    @property void localPortRange(ushort range)\n    {\n        p.curl.set(CurlOption.localportrange, cast(long)range);\n    }\n\n    /** Set the tcp no-delay socket option on or off.\n        See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY, nodelay)\n    */\n    @property void tcpNoDelay(bool on)\n    {\n        p.curl.set(CurlOption.tcp_nodelay, cast(long) (on ? 1 : 0) );\n    }\n\n    /** Sets whether SSL peer certificates should be verified.\n        See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTSSLVERIFYPEER, verifypeer)\n    */\n    @property void verifyPeer(bool on)\n    {\n      p.curl.set(CurlOption.ssl_verifypeer, on ? 1 : 0);\n    }\n\n    /** Sets whether the host within an SSL certificate should be verified.\n        See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTSSLVERIFYHOST, verifypeer)\n    */\n    @property void verifyHost(bool on)\n    {\n      p.curl.set(CurlOption.ssl_verifyhost, on ? 2 : 0);\n    }\n\n    // Authentication settings\n\n    /**\n       Set the user name, password and optionally domain for authentication\n       purposes.\n\n       Some protocols may need authentication in some cases. Use this\n       function to provide credentials.\n\n       Params:\n       username = the username\n       password = the password\n       domain = used for NTLM authentication only and is set to the NTLM domain\n                name\n    */\n    void setAuthentication(const(char)[] username, const(char)[] password,\n                           const(char)[] domain = \"\")\n    {\n        if (!domain.empty)\n            username = format(\"%s/%s\", domain, username);\n        p.curl.set(CurlOption.userpwd, format(\"%s:%s\", username, password));\n    }\n\n    unittest\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            assert(req.hdrs.canFind(\"GET /\"));\n            assert(req.hdrs.canFind(\"Basic dXNlcjpwYXNz\"));\n            s.send(httpOK());\n        });\n\n        auto http = HTTP(testServer.addr);\n        http.onReceive = (ubyte[] data) { return data.length; };\n        http.setAuthentication(\"user\", \"pass\");\n        http.perform();\n    }\n\n    /**\n       Set the user name and password for proxy authentication.\n\n       Params:\n       username = the username\n       password = the password\n    */\n    void setProxyAuthentication(const(char)[] username, const(char)[] password)\n    {\n        p.curl.set(CurlOption.proxyuserpwd,\n            format(\"%s:%s\",\n                username.replace(\":\", \"%3A\"),\n                password.replace(\":\", \"%3A\"))\n        );\n    }\n\n    /**\n     * The event handler that gets called when data is needed for sending. The\n     * length of the $(D void[]) specifies the maximum number of bytes that can\n     * be sent.\n     *\n     * Returns:\n     * The callback returns the number of elements in the buffer that have been\n     * filled and are ready to send.\n     * The special value $(D .abortRequest) can be returned in order to abort the\n     * current request.\n     * The special value $(D .pauseRequest) can be returned in order to pause the\n     * current request.\n     *\n     * Example:\n     * ----\n     * import std.net.curl;\n     * string msg = \"Hello world\";\n     * auto client = HTTP(\"dlang.org\");\n     * client.onSend = delegate size_t(void[] data)\n     * {\n     *     auto m = cast(void[])msg;\n     *     size_t length = m.length > data.length ? data.length : m.length;\n     *     if (length == 0) return 0;\n     *     data[0..length] = m[0..length];\n     *     msg = msg[length..$];\n     *     return length;\n     * };\n     * client.perform();\n     * ----\n     */\n    @property void onSend(size_t delegate(void[]) callback)\n    {\n        p.curl.clear(CurlOption.postfields); // cannot specify data when using callback\n        p.curl.onSend = callback;\n    }\n\n    /**\n      * The event handler that receives incoming data. Be sure to copy the\n      * incoming ubyte[] since it is not guaranteed to be valid after the\n      * callback returns.\n      *\n      * Returns:\n      * The callback returns the number of incoming bytes read. If the entire array is\n      * not read the request will abort.\n      * The special value .pauseRequest can be returned in order to pause the\n      * current request.\n      *\n      * Example:\n      * ----\n      * import std.net.curl, std.stdio;\n      * auto client = HTTP(\"dlang.org\");\n      * client.onReceive = (ubyte[] data)\n      * {\n      *     writeln(\"Got data\", to!(const(char)[])(data));\n      *     return data.length;\n      * };\n      * client.perform();\n      * ----\n      */\n    @property void onReceive(size_t delegate(ubyte[]) callback)\n    {\n        p.curl.onReceive = callback;\n    }\n\n    /**\n      * The event handler that gets called to inform of upload/download progress.\n      *\n      * Params:\n      * dlTotal = total bytes to download\n      * dlNow = currently downloaded bytes\n      * ulTotal = total bytes to upload\n      * ulNow = currently uploaded bytes\n      *\n      * Returns:\n      * Return 0 from the callback to signal success, return non-zero to abort\n      *          transfer\n      *\n      * Example:\n      * ----\n      * import std.net.curl, std.stdio;\n      * auto client = HTTP(\"dlang.org\");\n      * client.onProgress = delegate int(size_t dl, size_t dln, size_t ul, size_t ult)\n      * {\n      *     writeln(\"Progress: downloaded \", dln, \" of \", dl);\n      *     writeln(\"Progress: uploaded \", uln, \" of \", ul);\n      * };\n      * client.perform();\n      * ----\n      */\n    @property void onProgress(int delegate(size_t dlTotal, size_t dlNow,\n                                           size_t ulTotal, size_t ulNow) callback)\n    {\n        p.curl.onProgress = callback;\n    }\n}\n\n/*\n  Decode $(D ubyte[]) array using the provided EncodingScheme up to maxChars\n  Returns: Tuple of ubytes read and the $(D Char[]) characters decoded.\n           Not all ubytes are guaranteed to be read in case of decoding error.\n*/\nprivate Tuple!(size_t,Char[])\ndecodeString(Char = char)(const(ubyte)[] data,\n                          EncodingScheme scheme,\n                          size_t maxChars = size_t.max)\n{\n    Char[] res;\n    immutable startLen = data.length;\n    size_t charsDecoded = 0;\n    while (data.length && charsDecoded < maxChars)\n    {\n        dchar dc = scheme.safeDecode(data);\n        if (dc == INVALID_SEQUENCE)\n        {\n            return typeof(return)(size_t.max, cast(Char[])null);\n        }\n        charsDecoded++;\n        res ~= dc;\n    }\n    return typeof(return)(startLen-data.length, res);\n}\n\n/*\n  Decode $(D ubyte[]) array using the provided $(D EncodingScheme) until a the\n  line terminator specified is found. The basesrc parameter is effectively\n  prepended to src as the first thing.\n\n  This function is used for decoding as much of the src buffer as\n  possible until either the terminator is found or decoding fails. If\n  it fails as the last data in the src it may mean that the src buffer\n  were missing some bytes in order to represent a correct code\n  point. Upon the next call to this function more bytes have been\n  received from net and the failing bytes should be given as the\n  basesrc parameter. It is done this way to minimize data copying.\n\n  Returns: true if a terminator was found\n           Not all ubytes are guaranteed to be read in case of decoding error.\n           any decoded chars will be inserted into dst.\n*/\nprivate bool decodeLineInto(Terminator, Char = char)(ref const(ubyte)[] basesrc,\n                                                     ref const(ubyte)[] src,\n                                                     ref Char[] dst,\n                                                     EncodingScheme scheme,\n                                                     Terminator terminator)\n{\n    // if there is anything in the basesrc then try to decode that\n    // first.\n    if (basesrc.length != 0)\n    {\n        // Try to ensure 4 entries in the basesrc by copying from src.\n        immutable blen = basesrc.length;\n        immutable len = (basesrc.length + src.length) >= 4 ?\n                     4 : basesrc.length + src.length;\n        basesrc.length = len;\n\n        dchar dc = scheme.safeDecode(basesrc);\n        if (dc == INVALID_SEQUENCE)\n        {\n            enforce!CurlException(len != 4, \"Invalid code sequence\");\n            return false;\n        }\n        dst ~= dc;\n        src = src[len-basesrc.length-blen .. $]; // remove used ubytes from src\n        basesrc.length = 0;\n    }\n\n    while (src.length)\n    {\n        const lsrc = src;\n        dchar dc = scheme.safeDecode(src);\n        if (dc == INVALID_SEQUENCE)\n        {\n            if (src.empty)\n            {\n                // The invalid sequence was in the end of the src.  Maybe there\n                // just need to be more bytes available so these last bytes are\n                // put back to src for later use.\n                src = lsrc;\n                return false;\n            }\n            dc = '?';\n        }\n        dst ~= dc;\n\n        if (dst.endsWith(terminator))\n            return true;\n    }\n    return false; // no terminator found\n}\n\n/**\n  * HTTP client functionality.\n  *\n  * Example:\n  * ---\n  * import std.net.curl, std.stdio;\n  *\n  * // Get with custom data receivers\n  * auto http = HTTP(\"dlang.org\");\n  * http.onReceiveHeader =\n  *     (in char[] key, in char[] value) { writeln(key ~ \": \" ~ value); };\n  * http.onReceive = (ubyte[] data) { /+ drop +/ return data.length; };\n  * http.perform();\n  *\n  * // Put with data senders\n  * auto msg = \"Hello world\";\n  * http.contentLength = msg.length;\n  * http.onSend = (void[] data)\n  * {\n  *     auto m = cast(void[])msg;\n  *     size_t len = m.length > data.length ? data.length : m.length;\n  *     if (len == 0) return len;\n  *     data[0..len] = m[0..len];\n  *     msg = msg[len..$];\n  *     return len;\n  * };\n  * http.perform();\n  *\n  * // Track progress\n  * http.method = HTTP.Method.get;\n  * http.url = \"http://upload.wikimedia.org/wikipedia/commons/\"\n  *            \"5/53/Wikipedia-logo-en-big.png\";\n  * http.onReceive = (ubyte[] data) { return data.length; };\n  * http.onProgress = (size_t dltotal, size_t dlnow,\n  *                    size_t ultotal, size_t ulnow)\n  * {\n  *     writeln(\"Progress \", dltotal, \", \", dlnow, \", \", ultotal, \", \", ulnow);\n  *     return 0;\n  * };\n  * http.perform();\n  * ---\n  *\n  * See_Also: $(HTTP www.ietf.org/rfc/rfc2616.txt, RFC2616)\n  *\n  */\nstruct HTTP\n{\n    mixin Protocol;\n\n    /// Authentication method equal to $(REF CurlAuth, etc,c,curl)\n    alias AuthMethod = CurlAuth;\n\n    static private uint defaultMaxRedirects = 10;\n\n    private struct Impl\n    {\n        ~this()\n        {\n            if (headersOut !is null)\n                Curl.curl.slist_free_all(headersOut);\n            if (curl.handle !is null) // work around RefCounted/emplace bug\n                curl.shutdown();\n        }\n        Curl curl;\n        curl_slist* headersOut;\n        string[string] headersIn;\n        string charset;\n\n        /// The status line of the final sub-request in a request.\n        StatusLine status;\n        private void delegate(StatusLine) onReceiveStatusLine;\n\n        /// The HTTP method to use.\n        Method method = Method.undefined;\n\n        @system @property void onReceiveHeader(void delegate(in char[] key,\n                                                     in char[] value) callback)\n        {\n            // Wrap incoming callback in order to separate http status line from\n            // http headers.  On redirected requests there may be several such\n            // status lines. The last one is the one recorded.\n            auto dg = (in char[] header)\n            {\n                import std.utf : UTFException;\n                try\n                {\n                    if (header.empty)\n                    {\n                        // header delimiter\n                        return;\n                    }\n                    if (header.startsWith(\"HTTP/\"))\n                    {\n                        headersIn.clear();\n\n                        const m = match(header, regex(r\"^HTTP/(\\d+)\\.(\\d+) (\\d+) (.*)$\"));\n                        if (m.empty)\n                        {\n                            // Invalid status line\n                        }\n                        else\n                        {\n                            status.majorVersion = to!ushort(m.captures[1]);\n                            status.minorVersion = to!ushort(m.captures[2]);\n                            status.code = to!ushort(m.captures[3]);\n                            status.reason = m.captures[4].idup;\n                            if (onReceiveStatusLine != null)\n                                onReceiveStatusLine(status);\n                        }\n                        return;\n                    }\n\n                    // Normal http header\n                    auto m = match(cast(char[]) header, regex(\"(.*?): (.*)$\"));\n\n                    auto fieldName = m.captures[1].toLower().idup;\n                    if (fieldName == \"content-type\")\n                    {\n                        auto mct = match(cast(char[]) m.captures[2],\n                                         regex(\"charset=([^;]*)\", \"i\"));\n                        if (!mct.empty && mct.captures.length > 1)\n                            charset = mct.captures[1].idup;\n                    }\n\n                    if (!m.empty && callback !is null)\n                        callback(fieldName, m.captures[2]);\n                    headersIn[fieldName] = m.captures[2].idup;\n                }\n                catch (UTFException e)\n                {\n                    //munch it - a header should be all ASCII, any \"wrong UTF\" is broken header\n                }\n            };\n\n            curl.onReceiveHeader = dg;\n        }\n    }\n\n    private RefCounted!Impl p;\n\n    /** Time condition enumeration as an alias of $(REF CurlTimeCond, etc,c,curl)\n\n        $(HTTP www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25, _RFC2616 Section 14.25)\n    */\n    alias TimeCond = CurlTimeCond;\n\n    /**\n       Constructor taking the url as parameter.\n    */\n    static HTTP opCall(const(char)[] url)\n    {\n        HTTP http;\n        http.initialize();\n        http.url = url;\n        return http;\n    }\n\n    ///\n    static HTTP opCall()\n    {\n        HTTP http;\n        http.initialize();\n        return http;\n    }\n\n    ///\n    HTTP dup()\n    {\n        HTTP copy;\n        copy.initialize();\n        copy.p.method = p.method;\n        curl_slist* cur = p.headersOut;\n        curl_slist* newlist = null;\n        while (cur)\n        {\n            newlist = Curl.curl.slist_append(newlist, cur.data);\n            cur = cur.next;\n        }\n        copy.p.headersOut = newlist;\n        copy.p.curl.set(CurlOption.httpheader, copy.p.headersOut);\n        copy.p.curl = p.curl.dup();\n        copy.dataTimeout = _defaultDataTimeout;\n        copy.onReceiveHeader = null;\n        return copy;\n    }\n\n    private void initialize()\n    {\n        p.curl.initialize();\n        maxRedirects = HTTP.defaultMaxRedirects;\n        p.charset = \"ISO-8859-1\"; // Default charset defined in HTTP RFC\n        p.method = Method.undefined;\n        setUserAgent(HTTP.defaultUserAgent);\n        dataTimeout = _defaultDataTimeout;\n        onReceiveHeader = null;\n        verifyPeer = true;\n        verifyHost = true;\n    }\n\n    /**\n       Perform a http request.\n\n       After the HTTP client has been setup and possibly assigned callbacks the\n       $(D perform()) method will start performing the request towards the\n       specified server.\n\n       Params:\n       throwOnError = whether to throw an exception or return a CurlCode on error\n    */\n    CurlCode perform(ThrowOnError throwOnError = Yes.throwOnError)\n    {\n        p.status.reset();\n\n        CurlOption opt;\n        final switch (p.method)\n        {\n        case Method.head:\n            p.curl.set(CurlOption.nobody, 1L);\n            opt = CurlOption.nobody;\n            break;\n        case Method.undefined:\n        case Method.get:\n            p.curl.set(CurlOption.httpget, 1L);\n            opt = CurlOption.httpget;\n            break;\n        case Method.post:\n            p.curl.set(CurlOption.post, 1L);\n            opt = CurlOption.post;\n            break;\n        case Method.put:\n            p.curl.set(CurlOption.upload, 1L);\n            opt = CurlOption.upload;\n            break;\n        case Method.del:\n            p.curl.set(CurlOption.customrequest, \"DELETE\");\n            opt = CurlOption.customrequest;\n            break;\n        case Method.options:\n            p.curl.set(CurlOption.customrequest, \"OPTIONS\");\n            opt = CurlOption.customrequest;\n            break;\n        case Method.trace:\n            p.curl.set(CurlOption.customrequest, \"TRACE\");\n            opt = CurlOption.customrequest;\n            break;\n        case Method.connect:\n            p.curl.set(CurlOption.customrequest, \"CONNECT\");\n            opt = CurlOption.customrequest;\n            break;\n        case Method.patch:\n            p.curl.set(CurlOption.customrequest, \"PATCH\");\n            opt = CurlOption.customrequest;\n            break;\n        }\n\n        scope (exit) p.curl.clear(opt);\n        return p.curl.perform(throwOnError);\n    }\n\n    /// The URL to specify the location of the resource.\n    @property void url(const(char)[] url)\n    {\n        if (!startsWith(url.toLower(), \"http://\", \"https://\"))\n            url = \"http://\" ~ url;\n        p.curl.set(CurlOption.url, url);\n    }\n\n    /// Set the CA certificate bundle file to use for SSL peer verification\n    @property void caInfo(const(char)[] caFile)\n    {\n        p.curl.set(CurlOption.cainfo, caFile);\n    }\n\n    // This is a workaround for mixed in content not having its\n    // docs mixed in.\n    version (StdDdoc)\n    {\n        /// Value to return from $(D onSend)/$(D onReceive) delegates in order to\n        /// pause a request\n        alias requestPause = CurlReadFunc.pause;\n\n        /// Value to return from onSend delegate in order to abort a request\n        alias requestAbort = CurlReadFunc.abort;\n\n        /**\n           True if the instance is stopped. A stopped instance is not usable.\n        */\n        @property bool isStopped();\n\n        /// Stop and invalidate this instance.\n        void shutdown();\n\n        /** Set verbose.\n            This will print request information to stderr.\n        */\n        @property void verbose(bool on);\n\n        // Connection settings\n\n        /// Set timeout for activity on connection.\n        @property void dataTimeout(Duration d);\n\n        /** Set maximum time an operation is allowed to take.\n            This includes dns resolution, connecting, data transfer, etc.\n          */\n        @property void operationTimeout(Duration d);\n\n        /// Set timeout for connecting.\n        @property void connectTimeout(Duration d);\n\n        // Network settings\n\n        /** Proxy\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy)\n         */\n        @property void proxy(const(char)[] host);\n\n        /** Proxy port\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT, _proxy_port)\n         */\n        @property void proxyPort(ushort port);\n\n        /// Type of proxy\n        alias CurlProxy = etc.c.curl.CurlProxy;\n\n        /** Proxy type\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy_type)\n         */\n        @property void proxyType(CurlProxy type);\n\n        /// DNS lookup timeout.\n        @property void dnsTimeout(Duration d);\n\n        /**\n         * The network interface to use in form of the the IP of the interface.\n         *\n         * Example:\n         * ----\n         * theprotocol.netInterface = \"192.168.1.32\";\n         * theprotocol.netInterface = [ 192, 168, 1, 32 ];\n         * ----\n         *\n         * See: $(REF InternetAddress, std,socket)\n         */\n        @property void netInterface(const(char)[] i);\n\n        /// ditto\n        @property void netInterface(const(ubyte)[4] i);\n\n        /// ditto\n        @property void netInterface(InternetAddress i);\n\n        /**\n           Set the local outgoing port to use.\n           Params:\n           port = the first outgoing port number to try and use\n        */\n        @property void localPort(ushort port);\n\n        /**\n           Set the local outgoing port range to use.\n           This can be used together with the localPort property.\n           Params:\n           range = if the first port is occupied then try this many\n           port number forwards\n        */\n        @property void localPortRange(ushort range);\n\n        /** Set the tcp no-delay socket option on or off.\n            See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY, nodelay)\n        */\n        @property void tcpNoDelay(bool on);\n\n        // Authentication settings\n\n        /**\n           Set the user name, password and optionally domain for authentication\n           purposes.\n\n           Some protocols may need authentication in some cases. Use this\n           function to provide credentials.\n\n           Params:\n           username = the username\n           password = the password\n           domain = used for NTLM authentication only and is set to the NTLM domain\n           name\n        */\n        void setAuthentication(const(char)[] username, const(char)[] password,\n                               const(char)[] domain = \"\");\n\n        /**\n           Set the user name and password for proxy authentication.\n\n           Params:\n           username = the username\n           password = the password\n        */\n        void setProxyAuthentication(const(char)[] username, const(char)[] password);\n\n        /**\n         * The event handler that gets called when data is needed for sending. The\n         * length of the $(D void[]) specifies the maximum number of bytes that can\n         * be sent.\n         *\n         * Returns:\n         * The callback returns the number of elements in the buffer that have been\n         * filled and are ready to send.\n         * The special value $(D .abortRequest) can be returned in order to abort the\n         * current request.\n         * The special value $(D .pauseRequest) can be returned in order to pause the\n         * current request.\n         *\n         * Example:\n         * ----\n         * import std.net.curl;\n         * string msg = \"Hello world\";\n         * auto client = HTTP(\"dlang.org\");\n         * client.onSend = delegate size_t(void[] data)\n         * {\n         *     auto m = cast(void[])msg;\n         *     size_t length = m.length > data.length ? data.length : m.length;\n         *     if (length == 0) return 0;\n         *     data[0..length] = m[0..length];\n         *     msg = msg[length..$];\n         *     return length;\n         * };\n         * client.perform();\n         * ----\n         */\n        @property void onSend(size_t delegate(void[]) callback);\n\n        /**\n         * The event handler that receives incoming data. Be sure to copy the\n         * incoming ubyte[] since it is not guaranteed to be valid after the\n         * callback returns.\n         *\n         * Returns:\n         * The callback returns the incoming bytes read. If not the entire array is\n         * the request will abort.\n         * The special value .pauseRequest can be returned in order to pause the\n         * current request.\n         *\n         * Example:\n         * ----\n         * import std.net.curl, std.stdio;\n         * auto client = HTTP(\"dlang.org\");\n         * client.onReceive = (ubyte[] data)\n         * {\n         *     writeln(\"Got data\", to!(const(char)[])(data));\n         *     return data.length;\n         * };\n         * client.perform();\n         * ----\n         */\n        @property void onReceive(size_t delegate(ubyte[]) callback);\n\n        /**\n         * Register an event handler that gets called to inform of\n         * upload/download progress.\n         *\n         * Callback_parameters:\n         * $(CALLBACK_PARAMS)\n         *\n         * Callback_returns: Return 0 to signal success, return non-zero to\n         * abort transfer.\n         *\n         * Example:\n         * ----\n         * import std.net.curl, std.stdio;\n         * auto client = HTTP(\"dlang.org\");\n         * client.onProgress = delegate int(size_t dl, size_t dln, size_t ul, size_t ult)\n         * {\n         *     writeln(\"Progress: downloaded \", dln, \" of \", dl);\n         *     writeln(\"Progress: uploaded \", uln, \" of \", ul);\n         * };\n         * client.perform();\n         * ----\n         */\n        @property void onProgress(int delegate(size_t dlTotal, size_t dlNow,\n                                               size_t ulTotal, size_t ulNow) callback);\n    }\n\n    /** Clear all outgoing headers.\n    */\n    void clearRequestHeaders()\n    {\n        if (p.headersOut !is null)\n            Curl.curl.slist_free_all(p.headersOut);\n        p.headersOut = null;\n        p.curl.clear(CurlOption.httpheader);\n    }\n\n    /** Add a header e.g. \"X-CustomField: Something is fishy\".\n     *\n     * There is no remove header functionality. Do a $(LREF clearRequestHeaders)\n     * and set the needed headers instead.\n     *\n     * Example:\n     * ---\n     * import std.net.curl;\n     * auto client = HTTP();\n     * client.addRequestHeader(\"X-Custom-ABC\", \"This is the custom value\");\n     * auto content = get(\"dlang.org\", client);\n     * ---\n     */\n    void addRequestHeader(const(char)[] name, const(char)[] value)\n    {\n        if (icmp(name, \"User-Agent\") == 0)\n            return setUserAgent(value);\n        string nv = format(\"%s: %s\", name, value);\n        p.headersOut = Curl.curl.slist_append(p.headersOut,\n                                              nv.tempCString().buffPtr);\n        p.curl.set(CurlOption.httpheader, p.headersOut);\n    }\n\n    /**\n     * The default \"User-Agent\" value send with a request.\n     * It has the form \"Phobos-std.net.curl/$(I PHOBOS_VERSION) (libcurl/$(I CURL_VERSION))\"\n     */\n    static string defaultUserAgent() @property\n    {\n        import std.compiler : version_major, version_minor;\n\n        // http://curl.haxx.se/docs/versions.html\n        enum fmt = \"Phobos-std.net.curl/%d.%03d (libcurl/%d.%d.%d)\";\n        enum maxLen = fmt.length - \"%d%03d%d%d%d\".length + 10 + 10 + 3 + 3 + 3;\n\n        static char[maxLen] buf = void;\n        static string userAgent;\n\n        if (!userAgent.length)\n        {\n            auto curlVer = Curl.curl.version_info(CURLVERSION_NOW).version_num;\n            userAgent = cast(immutable)sformat(\n                buf, fmt, version_major, version_minor,\n                curlVer >> 16 & 0xFF, curlVer >> 8 & 0xFF, curlVer & 0xFF);\n        }\n        return userAgent;\n    }\n\n    /** Set the value of the user agent request header field.\n     *\n     * By default a request has it's \"User-Agent\" field set to $(LREF\n     * defaultUserAgent) even if $(D setUserAgent) was never called.  Pass\n     * an empty string to suppress the \"User-Agent\" field altogether.\n     */\n    void setUserAgent(const(char)[] userAgent)\n    {\n        p.curl.set(CurlOption.useragent, userAgent);\n    }\n\n    /** The headers read from a successful response.\n     *\n     */\n    @property string[string] responseHeaders()\n    {\n        return p.headersIn;\n    }\n\n    /// HTTP method used.\n    @property void method(Method m)\n    {\n        p.method = m;\n    }\n\n    /// ditto\n    @property Method method()\n    {\n        return p.method;\n    }\n\n    /**\n       HTTP status line of last response. One call to perform may\n       result in several requests because of redirection.\n    */\n    @property StatusLine statusLine()\n    {\n        return p.status;\n    }\n\n    /// Set the active cookie string e.g. \"name1=value1;name2=value2\"\n    void setCookie(const(char)[] cookie)\n    {\n        p.curl.set(CurlOption.cookie, cookie);\n    }\n\n    /// Set a file path to where a cookie jar should be read/stored.\n    void setCookieJar(const(char)[] path)\n    {\n        p.curl.set(CurlOption.cookiefile, path);\n        if (path.length)\n            p.curl.set(CurlOption.cookiejar, path);\n    }\n\n    /// Flush cookie jar to disk.\n    void flushCookieJar()\n    {\n        p.curl.set(CurlOption.cookielist, \"FLUSH\");\n    }\n\n    /// Clear session cookies.\n    void clearSessionCookies()\n    {\n        p.curl.set(CurlOption.cookielist, \"SESS\");\n    }\n\n    /// Clear all cookies.\n    void clearAllCookies()\n    {\n        p.curl.set(CurlOption.cookielist, \"ALL\");\n    }\n\n    /**\n       Set time condition on the request.\n\n       Params:\n       cond =  $(D CurlTimeCond.{none,ifmodsince,ifunmodsince,lastmod})\n       timestamp = Timestamp for the condition\n\n       $(HTTP www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25, _RFC2616 Section 14.25)\n    */\n    void setTimeCondition(HTTP.TimeCond cond, SysTime timestamp)\n    {\n        p.curl.set(CurlOption.timecondition, cond);\n        p.curl.set(CurlOption.timevalue, timestamp.toUnixTime());\n    }\n\n    /** Specifying data to post when not using the onSend callback.\n      *\n      * The data is NOT copied by the library.  Content-Type will default to\n      * application/octet-stream.  Data is not converted or encoded by this\n      * method.\n      *\n      * Example:\n      * ----\n      * import std.net.curl, std.stdio;\n      * auto http = HTTP(\"http://www.mydomain.com\");\n      * http.onReceive = (ubyte[] data) { writeln(to!(const(char)[])(data)); return data.length; };\n      * http.postData = [1,2,3,4,5];\n      * http.perform();\n      * ----\n      */\n    @property void postData(const(void)[] data)\n    {\n        setPostData(data, \"application/octet-stream\");\n    }\n\n    /** Specifying data to post when not using the onSend callback.\n      *\n      * The data is NOT copied by the library.  Content-Type will default to\n      * text/plain.  Data is not converted or encoded by this method.\n      *\n      * Example:\n      * ----\n      * import std.net.curl, std.stdio;\n      * auto http = HTTP(\"http://www.mydomain.com\");\n      * http.onReceive = (ubyte[] data) { writeln(to!(const(char)[])(data)); return data.length; };\n      * http.postData = \"The quick....\";\n      * http.perform();\n      * ----\n      */\n    @property void postData(const(char)[] data)\n    {\n        setPostData(data, \"text/plain\");\n    }\n\n    /**\n     * Specify data to post when not using the onSend callback, with\n     * user-specified Content-Type.\n     * Params:\n     *  data = Data to post.\n     *  contentType = MIME type of the data, for example, \"text/plain\" or\n     *      \"application/octet-stream\". See also:\n     *      $(LINK2 http://en.wikipedia.org/wiki/Internet_media_type,\n     *      Internet media type) on Wikipedia.\n     * -----\n     * import std.net.curl;\n     * auto http = HTTP(\"http://onlineform.example.com\");\n     * auto data = \"app=login&username=bob&password=s00perS3kret\";\n     * http.setPostData(data, \"application/x-www-form-urlencoded\");\n     * http.onReceive = (ubyte[] data) { return data.length; };\n     * http.perform();\n     * -----\n     */\n    void setPostData(const(void)[] data, string contentType)\n    {\n        // cannot use callback when specifying data directly so it is disabled here.\n        p.curl.clear(CurlOption.readfunction);\n        addRequestHeader(\"Content-Type\", contentType);\n        p.curl.set(CurlOption.postfields, cast(void*)data.ptr);\n        p.curl.set(CurlOption.postfieldsize, data.length);\n        if (method == Method.undefined)\n            method = Method.post;\n    }\n\n    unittest\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq!ubyte;\n            assert(req.hdrs.canFind(\"POST /path\"));\n            assert(req.bdy.canFind(cast(ubyte[])[0, 1, 2, 3, 4]));\n            assert(req.bdy.canFind(cast(ubyte[])[253, 254, 255]));\n            s.send(httpOK(cast(ubyte[])[17, 27, 35, 41]));\n        });\n        auto data = new ubyte[](256);\n        foreach (i, ref ub; data)\n            ub = cast(ubyte)i;\n\n        auto http = HTTP(testServer.addr~\"/path\");\n        http.postData = data;\n        ubyte[] res;\n        http.onReceive = (data) { res ~= data; return data.length; };\n        http.perform();\n        assert(res == cast(ubyte[])[17, 27, 35, 41]);\n    }\n\n    /**\n      * Set the event handler that receives incoming headers.\n      *\n      * The callback will receive a header field key, value as parameter. The\n      * $(D const(char)[]) arrays are not valid after the delegate has returned.\n      *\n      * Example:\n      * ----\n      * import std.net.curl, std.stdio;\n      * auto http = HTTP(\"dlang.org\");\n      * http.onReceive = (ubyte[] data) { writeln(to!(const(char)[])(data)); return data.length; };\n      * http.onReceiveHeader = (in char[] key, in char[] value) { writeln(key, \" = \", value); };\n      * http.perform();\n      * ----\n      */\n    @property void onReceiveHeader(void delegate(in char[] key,\n                                                 in char[] value) callback)\n    {\n        p.onReceiveHeader = callback;\n    }\n\n    /**\n       Callback for each received StatusLine.\n\n       Notice that several callbacks can be done for each call to\n       $(D perform()) due to redirections.\n\n       See_Also: $(LREF StatusLine)\n     */\n    @property void onReceiveStatusLine(void delegate(StatusLine) callback)\n    {\n        p.onReceiveStatusLine = callback;\n    }\n\n    /**\n       The content length in bytes when using request that has content\n       e.g. POST/PUT and not using chunked transfer. Is set as the\n       \"Content-Length\" header.  Set to ulong.max to reset to chunked transfer.\n    */\n    @property void contentLength(ulong len)\n    {\n        CurlOption lenOpt;\n\n        // Force post if necessary\n        if (p.method != Method.put && p.method != Method.post &&\n            p.method != Method.patch)\n            p.method = Method.post;\n\n        if (p.method == Method.post || p.method == Method.patch)\n            lenOpt = CurlOption.postfieldsize_large;\n        else\n            lenOpt = CurlOption.infilesize_large;\n\n        if (size_t.max != ulong.max && len == size_t.max)\n            len = ulong.max; // check size_t.max for backwards compat, turn into error\n\n        if (len == ulong.max)\n        {\n            // HTTP 1.1 supports requests with no length header set.\n            addRequestHeader(\"Transfer-Encoding\", \"chunked\");\n            addRequestHeader(\"Expect\", \"100-continue\");\n        }\n        else\n        {\n            p.curl.set(lenOpt, to!curl_off_t(len));\n        }\n    }\n\n    /**\n       Authentication method as specified in $(LREF AuthMethod).\n    */\n    @property void authenticationMethod(AuthMethod authMethod)\n    {\n        p.curl.set(CurlOption.httpauth, cast(long) authMethod);\n    }\n\n    /**\n       Set max allowed redirections using the location header.\n       uint.max for infinite.\n    */\n    @property void maxRedirects(uint maxRedirs)\n    {\n        if (maxRedirs == uint.max)\n        {\n            // Disable\n            p.curl.set(CurlOption.followlocation, 0);\n        }\n        else\n        {\n            p.curl.set(CurlOption.followlocation, 1);\n            p.curl.set(CurlOption.maxredirs, maxRedirs);\n        }\n    }\n\n    /** <a name=\"HTTP.Method\"/>The standard HTTP methods :\n     *  $(HTTP www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1, _RFC2616 Section 5.1.1)\n     */\n    enum Method\n    {\n        undefined,\n        head, ///\n        get,  ///\n        post, ///\n        put,  ///\n        del,  ///\n        options, ///\n        trace,   ///\n        connect,  ///\n        patch, ///\n    }\n\n    /**\n       HTTP status line ie. the first line returned in an HTTP response.\n\n       If authentication or redirections are done then the status will be for\n       the last response received.\n    */\n    struct StatusLine\n    {\n        ushort majorVersion; /// Major HTTP version ie. 1 in HTTP/1.0.\n        ushort minorVersion; /// Minor HTTP version ie. 0 in HTTP/1.0.\n        ushort code;         /// HTTP status line code e.g. 200.\n        string reason;       /// HTTP status line reason string.\n\n        /// Reset this status line\n        @safe void reset()\n        {\n            majorVersion = 0;\n            minorVersion = 0;\n            code = 0;\n            reason = \"\";\n        }\n\n        ///\n        string toString() const\n        {\n            return format(\"%s %s (%s.%s)\",\n                          code, reason, majorVersion, minorVersion);\n        }\n    }\n\n} // HTTP\n\nunittest // charset/Charset/CHARSET/...\n{\n    import std.meta : AliasSeq;\n\n    foreach (c; AliasSeq!(\"charset\", \"Charset\", \"CHARSET\", \"CharSet\", \"charSet\",\n        \"ChArSeT\", \"cHaRsEt\"))\n    {\n        testServer.handle((s) {\n            s.send(\"HTTP/1.1 200 OK\\r\\n\"~\n                \"Content-Length: 0\\r\\n\"~\n                \"Content-Type: text/plain; \" ~ c ~ \"=foo\\r\\n\" ~\n                \"\\r\\n\");\n        });\n\n        auto http = HTTP(testServer.addr);\n        http.perform();\n        assert(http.p.charset == \"foo\");\n    }\n}\n\n/**\n   FTP client functionality.\n\n   See_Also: $(HTTP tools.ietf.org/html/rfc959, RFC959)\n*/\nstruct FTP\n{\n\n    mixin Protocol;\n\n    private struct Impl\n    {\n        ~this()\n        {\n            if (commands !is null)\n                Curl.curl.slist_free_all(commands);\n            if (curl.handle !is null) // work around RefCounted/emplace bug\n                curl.shutdown();\n        }\n        curl_slist* commands;\n        Curl curl;\n        string encoding;\n    }\n\n    private RefCounted!Impl p;\n\n    /**\n       FTP access to the specified url.\n    */\n    static FTP opCall(const(char)[] url)\n    {\n        FTP ftp;\n        ftp.initialize();\n        ftp.url = url;\n        return ftp;\n    }\n\n    ///\n    static FTP opCall()\n    {\n        FTP ftp;\n        ftp.initialize();\n        return ftp;\n    }\n\n    ///\n    FTP dup()\n    {\n        FTP copy = FTP();\n        copy.initialize();\n        copy.p.encoding = p.encoding;\n        copy.p.curl = p.curl.dup();\n        curl_slist* cur = p.commands;\n        curl_slist* newlist = null;\n        while (cur)\n        {\n            newlist = Curl.curl.slist_append(newlist, cur.data);\n            cur = cur.next;\n        }\n        copy.p.commands = newlist;\n        copy.p.curl.set(CurlOption.postquote, copy.p.commands);\n        copy.dataTimeout = _defaultDataTimeout;\n        return copy;\n    }\n\n    private void initialize()\n    {\n        p.curl.initialize();\n        p.encoding = \"ISO-8859-1\";\n        dataTimeout = _defaultDataTimeout;\n    }\n\n    /**\n       Performs the ftp request as it has been configured.\n\n       After a FTP client has been setup and possibly assigned callbacks the $(D\n       perform()) method will start performing the actual communication with the\n       server.\n\n       Params:\n       throwOnError = whether to throw an exception or return a CurlCode on error\n    */\n    CurlCode perform(ThrowOnError throwOnError = Yes.throwOnError)\n    {\n        return p.curl.perform(throwOnError);\n    }\n\n    /// The URL to specify the location of the resource.\n    @property void url(const(char)[] url)\n    {\n        if (!startsWith(url.toLower(), \"ftp://\", \"ftps://\"))\n            url = \"ftp://\" ~ url;\n        p.curl.set(CurlOption.url, url);\n    }\n\n    // This is a workaround for mixed in content not having its\n    // docs mixed in.\n    version (StdDdoc)\n    {\n        /// Value to return from $(D onSend)/$(D onReceive) delegates in order to\n        /// pause a request\n        alias requestPause = CurlReadFunc.pause;\n\n        /// Value to return from onSend delegate in order to abort a request\n        alias requestAbort = CurlReadFunc.abort;\n\n        /**\n           True if the instance is stopped. A stopped instance is not usable.\n        */\n        @property bool isStopped();\n\n        /// Stop and invalidate this instance.\n        void shutdown();\n\n        /** Set verbose.\n            This will print request information to stderr.\n        */\n        @property void verbose(bool on);\n\n        // Connection settings\n\n        /// Set timeout for activity on connection.\n        @property void dataTimeout(Duration d);\n\n        /** Set maximum time an operation is allowed to take.\n            This includes dns resolution, connecting, data transfer, etc.\n          */\n        @property void operationTimeout(Duration d);\n\n        /// Set timeout for connecting.\n        @property void connectTimeout(Duration d);\n\n        // Network settings\n\n        /** Proxy\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy)\n         */\n        @property void proxy(const(char)[] host);\n\n        /** Proxy port\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT, _proxy_port)\n         */\n        @property void proxyPort(ushort port);\n\n        /// Type of proxy\n        alias CurlProxy = etc.c.curl.CurlProxy;\n\n        /** Proxy type\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy_type)\n         */\n        @property void proxyType(CurlProxy type);\n\n        /// DNS lookup timeout.\n        @property void dnsTimeout(Duration d);\n\n        /**\n         * The network interface to use in form of the the IP of the interface.\n         *\n         * Example:\n         * ----\n         * theprotocol.netInterface = \"192.168.1.32\";\n         * theprotocol.netInterface = [ 192, 168, 1, 32 ];\n         * ----\n         *\n         * See: $(REF InternetAddress, std,socket)\n         */\n        @property void netInterface(const(char)[] i);\n\n        /// ditto\n        @property void netInterface(const(ubyte)[4] i);\n\n        /// ditto\n        @property void netInterface(InternetAddress i);\n\n        /**\n           Set the local outgoing port to use.\n           Params:\n           port = the first outgoing port number to try and use\n        */\n        @property void localPort(ushort port);\n\n        /**\n           Set the local outgoing port range to use.\n           This can be used together with the localPort property.\n           Params:\n           range = if the first port is occupied then try this many\n           port number forwards\n        */\n        @property void localPortRange(ushort range);\n\n        /** Set the tcp no-delay socket option on or off.\n            See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY, nodelay)\n        */\n        @property void tcpNoDelay(bool on);\n\n        // Authentication settings\n\n        /**\n           Set the user name, password and optionally domain for authentication\n           purposes.\n\n           Some protocols may need authentication in some cases. Use this\n           function to provide credentials.\n\n           Params:\n           username = the username\n           password = the password\n           domain = used for NTLM authentication only and is set to the NTLM domain\n           name\n        */\n        void setAuthentication(const(char)[] username, const(char)[] password,\n                               const(char)[] domain = \"\");\n\n        /**\n           Set the user name and password for proxy authentication.\n\n           Params:\n           username = the username\n           password = the password\n        */\n        void setProxyAuthentication(const(char)[] username, const(char)[] password);\n\n        /**\n         * The event handler that gets called when data is needed for sending. The\n         * length of the $(D void[]) specifies the maximum number of bytes that can\n         * be sent.\n         *\n         * Returns:\n         * The callback returns the number of elements in the buffer that have been\n         * filled and are ready to send.\n         * The special value $(D .abortRequest) can be returned in order to abort the\n         * current request.\n         * The special value $(D .pauseRequest) can be returned in order to pause the\n         * current request.\n         *\n         */\n        @property void onSend(size_t delegate(void[]) callback);\n\n        /**\n         * The event handler that receives incoming data. Be sure to copy the\n         * incoming ubyte[] since it is not guaranteed to be valid after the\n         * callback returns.\n         *\n         * Returns:\n         * The callback returns the incoming bytes read. If not the entire array is\n         * the request will abort.\n         * The special value .pauseRequest can be returned in order to pause the\n         * current request.\n         *\n         */\n        @property void onReceive(size_t delegate(ubyte[]) callback);\n\n        /**\n         * The event handler that gets called to inform of upload/download progress.\n         *\n         * Callback_parameters:\n         * $(CALLBACK_PARAMS)\n         *\n         * Callback_returns:\n         * Return 0 from the callback to signal success, return non-zero to\n         * abort transfer.\n         */\n        @property void onProgress(int delegate(size_t dlTotal, size_t dlNow,\n                                               size_t ulTotal, size_t ulNow) callback);\n    }\n\n    /** Clear all commands send to ftp server.\n    */\n    void clearCommands()\n    {\n        if (p.commands !is null)\n            Curl.curl.slist_free_all(p.commands);\n        p.commands = null;\n        p.curl.clear(CurlOption.postquote);\n    }\n\n    /** Add a command to send to ftp server.\n     *\n     * There is no remove command functionality. Do a $(LREF clearCommands) and\n     * set the needed commands instead.\n     *\n     * Example:\n     * ---\n     * import std.net.curl;\n     * auto client = FTP();\n     * client.addCommand(\"RNFR my_file.txt\");\n     * client.addCommand(\"RNTO my_renamed_file.txt\");\n     * upload(\"my_file.txt\", \"ftp.digitalmars.com\", client);\n     * ---\n     */\n    void addCommand(const(char)[] command)\n    {\n        p.commands = Curl.curl.slist_append(p.commands,\n                                            command.tempCString().buffPtr);\n        p.curl.set(CurlOption.postquote, p.commands);\n    }\n\n    /// Connection encoding. Defaults to ISO-8859-1.\n    @property void encoding(string name)\n    {\n        p.encoding = name;\n    }\n\n    /// ditto\n    @property string encoding()\n    {\n        return p.encoding;\n    }\n\n    /**\n       The content length in bytes of the ftp data.\n    */\n    @property void contentLength(ulong len)\n    {\n        p.curl.set(CurlOption.infilesize_large, to!curl_off_t(len));\n    }\n}\n\n/**\n  * Basic SMTP protocol support.\n  *\n  * Example:\n  * ---\n  * import std.net.curl;\n  *\n  * // Send an email with SMTPS\n  * auto smtp = SMTP(\"smtps://smtp.gmail.com\");\n  * smtp.setAuthentication(\"from.addr@gmail.com\", \"password\");\n  * smtp.mailTo = [\"<to.addr@gmail.com>\"];\n  * smtp.mailFrom = \"<from.addr@gmail.com>\";\n  * smtp.message = \"Example Message\";\n  * smtp.perform();\n  * ---\n  *\n  * See_Also: $(HTTP www.ietf.org/rfc/rfc2821.txt, RFC2821)\n  */\nstruct SMTP\n{\n    mixin Protocol;\n\n    private struct Impl\n    {\n        ~this()\n        {\n            if (curl.handle !is null) // work around RefCounted/emplace bug\n                curl.shutdown();\n        }\n        Curl curl;\n\n        @property void message(string msg)\n        {\n            auto _message = msg;\n            /**\n                This delegate reads the message text and copies it.\n            */\n            curl.onSend = delegate size_t(void[] data)\n            {\n                if (!msg.length) return 0;\n                size_t to_copy = min(data.length, _message.length);\n                data[0..to_copy] = (cast(void[])_message)[0..to_copy];\n                _message = _message[to_copy..$];\n                return to_copy;\n            };\n        }\n    }\n\n    private RefCounted!Impl p;\n\n    /**\n        Sets to the URL of the SMTP server.\n    */\n    static SMTP opCall(const(char)[] url)\n    {\n        SMTP smtp;\n        smtp.initialize();\n        smtp.url = url;\n        return smtp;\n    }\n\n    ///\n    static SMTP opCall()\n    {\n        SMTP smtp;\n        smtp.initialize();\n        return smtp;\n    }\n\n    /+ TODO: The other structs have this function.\n    SMTP dup()\n    {\n        SMTP copy = SMTP();\n        copy.initialize();\n        copy.p.encoding = p.encoding;\n        copy.p.curl = p.curl.dup();\n        curl_slist* cur = p.commands;\n        curl_slist* newlist = null;\n        while (cur)\n        {\n            newlist = Curl.curl.slist_append(newlist, cur.data);\n            cur = cur.next;\n        }\n        copy.p.commands = newlist;\n        copy.p.curl.set(CurlOption.postquote, copy.p.commands);\n        copy.dataTimeout = _defaultDataTimeout;\n        return copy;\n    }\n    +/\n\n    /**\n        Performs the request as configured.\n        Params:\n        throwOnError = whether to throw an exception or return a CurlCode on error\n    */\n    CurlCode perform(ThrowOnError throwOnError = Yes.throwOnError)\n    {\n        return p.curl.perform(throwOnError);\n    }\n\n    /// The URL to specify the location of the resource.\n    @property void url(const(char)[] url)\n    {\n        auto lowered = url.toLower();\n\n        if (lowered.startsWith(\"smtps://\"))\n        {\n            p.curl.set(CurlOption.use_ssl, CurlUseSSL.all);\n        }\n        else\n        {\n            enforce!CurlException(lowered.startsWith(\"smtp://\"),\n                                    \"The url must be for the smtp protocol.\");\n        }\n        p.curl.set(CurlOption.url, url);\n    }\n\n    private void initialize()\n    {\n        p.curl.initialize();\n        p.curl.set(CurlOption.upload, 1L);\n        dataTimeout = _defaultDataTimeout;\n        verifyPeer = true;\n        verifyHost = true;\n    }\n\n    // This is a workaround for mixed in content not having its\n    // docs mixed in.\n    version (StdDdoc)\n    {\n        /// Value to return from $(D onSend)/$(D onReceive) delegates in order to\n        /// pause a request\n        alias requestPause = CurlReadFunc.pause;\n\n        /// Value to return from onSend delegate in order to abort a request\n        alias requestAbort = CurlReadFunc.abort;\n\n        /**\n           True if the instance is stopped. A stopped instance is not usable.\n        */\n        @property bool isStopped();\n\n        /// Stop and invalidate this instance.\n        void shutdown();\n\n        /** Set verbose.\n            This will print request information to stderr.\n        */\n        @property void verbose(bool on);\n\n        // Connection settings\n\n        /// Set timeout for activity on connection.\n        @property void dataTimeout(Duration d);\n\n        /** Set maximum time an operation is allowed to take.\n            This includes dns resolution, connecting, data transfer, etc.\n          */\n        @property void operationTimeout(Duration d);\n\n        /// Set timeout for connecting.\n        @property void connectTimeout(Duration d);\n\n        // Network settings\n\n        /** Proxy\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy)\n         */\n        @property void proxy(const(char)[] host);\n\n        /** Proxy port\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT, _proxy_port)\n         */\n        @property void proxyPort(ushort port);\n\n        /// Type of proxy\n        alias CurlProxy = etc.c.curl.CurlProxy;\n\n        /** Proxy type\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy_type)\n         */\n        @property void proxyType(CurlProxy type);\n\n        /// DNS lookup timeout.\n        @property void dnsTimeout(Duration d);\n\n        /**\n         * The network interface to use in form of the the IP of the interface.\n         *\n         * Example:\n         * ----\n         * theprotocol.netInterface = \"192.168.1.32\";\n         * theprotocol.netInterface = [ 192, 168, 1, 32 ];\n         * ----\n         *\n         * See: $(REF InternetAddress, std,socket)\n         */\n        @property void netInterface(const(char)[] i);\n\n        /// ditto\n        @property void netInterface(const(ubyte)[4] i);\n\n        /// ditto\n        @property void netInterface(InternetAddress i);\n\n        /**\n           Set the local outgoing port to use.\n           Params:\n           port = the first outgoing port number to try and use\n        */\n        @property void localPort(ushort port);\n\n        /**\n           Set the local outgoing port range to use.\n           This can be used together with the localPort property.\n           Params:\n           range = if the first port is occupied then try this many\n           port number forwards\n        */\n        @property void localPortRange(ushort range);\n\n        /** Set the tcp no-delay socket option on or off.\n            See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY, nodelay)\n        */\n        @property void tcpNoDelay(bool on);\n\n        // Authentication settings\n\n        /**\n           Set the user name, password and optionally domain for authentication\n           purposes.\n\n           Some protocols may need authentication in some cases. Use this\n           function to provide credentials.\n\n           Params:\n           username = the username\n           password = the password\n           domain = used for NTLM authentication only and is set to the NTLM domain\n           name\n        */\n        void setAuthentication(const(char)[] username, const(char)[] password,\n                               const(char)[] domain = \"\");\n\n        /**\n           Set the user name and password for proxy authentication.\n\n           Params:\n           username = the username\n           password = the password\n        */\n        void setProxyAuthentication(const(char)[] username, const(char)[] password);\n\n        /**\n         * The event handler that gets called when data is needed for sending. The\n         * length of the $(D void[]) specifies the maximum number of bytes that can\n         * be sent.\n         *\n         * Returns:\n         * The callback returns the number of elements in the buffer that have been\n         * filled and are ready to send.\n         * The special value $(D .abortRequest) can be returned in order to abort the\n         * current request.\n         * The special value $(D .pauseRequest) can be returned in order to pause the\n         * current request.\n         */\n        @property void onSend(size_t delegate(void[]) callback);\n\n        /**\n         * The event handler that receives incoming data. Be sure to copy the\n         * incoming ubyte[] since it is not guaranteed to be valid after the\n         * callback returns.\n         *\n         * Returns:\n         * The callback returns the incoming bytes read. If not the entire array is\n         * the request will abort.\n         * The special value .pauseRequest can be returned in order to pause the\n         * current request.\n         */\n        @property void onReceive(size_t delegate(ubyte[]) callback);\n\n        /**\n         * The event handler that gets called to inform of upload/download progress.\n         *\n         * Callback_parameters:\n         * $(CALLBACK_PARAMS)\n         *\n         * Callback_returns:\n         * Return 0 from the callback to signal success, return non-zero to\n         * abort transfer.\n         */\n        @property void onProgress(int delegate(size_t dlTotal, size_t dlNow,\n                                               size_t ulTotal, size_t ulNow) callback);\n    }\n\n    /**\n        Setter for the sender's email address.\n    */\n    @property void mailFrom()(const(char)[] sender)\n    {\n        assert(!sender.empty, \"Sender must not be empty\");\n        p.curl.set(CurlOption.mail_from, sender);\n    }\n\n    /**\n        Setter for the recipient email addresses.\n    */\n    void mailTo()(const(char)[][] recipients...)\n    {\n        assert(!recipients.empty, \"Recipient must not be empty\");\n        curl_slist* recipients_list = null;\n        foreach (recipient; recipients)\n        {\n            recipients_list =\n                Curl.curl.slist_append(recipients_list,\n                                  recipient.tempCString().buffPtr);\n        }\n        p.curl.set(CurlOption.mail_rcpt, recipients_list);\n    }\n\n    /**\n        Sets the message body text.\n    */\n\n    @property void message(string msg)\n    {\n        p.message = msg;\n    }\n}\n\n/++\n    Exception thrown on errors in std.net.curl functions.\n+/\nclass CurlException : Exception\n{\n    /++\n        Params:\n            msg  = The message for the exception.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n            next = The previous exception in the chain of exceptions, if any.\n      +/\n    @safe pure nothrow\n    this(string msg,\n         string file = __FILE__,\n         size_t line = __LINE__,\n         Throwable next = null)\n    {\n        super(msg, file, line, next);\n    }\n}\n\n/++\n    Exception thrown on timeout errors in std.net.curl functions.\n+/\nclass CurlTimeoutException : CurlException\n{\n    /++\n        Params:\n            msg  = The message for the exception.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n            next = The previous exception in the chain of exceptions, if any.\n      +/\n    @safe pure nothrow\n    this(string msg,\n         string file = __FILE__,\n         size_t line = __LINE__,\n         Throwable next = null)\n    {\n        super(msg, file, line, next);\n    }\n}\n\n/// Equal to $(REF CURLcode, etc,c,curl)\nalias CurlCode = CURLcode;\n\nimport std.typecons : Flag, Yes, No;\n/// Flag to specify whether or not an exception is thrown on error.\nalias ThrowOnError = Flag!\"throwOnError\";\n\nprivate struct CurlAPI\n{\n    static struct API\n    {\n    extern(C):\n        import core.stdc.config : c_long;\n        CURLcode function(c_long flags) global_init;\n        void function() global_cleanup;\n        curl_version_info_data * function(CURLversion) version_info;\n        CURL* function() easy_init;\n        CURLcode function(CURL *curl, CURLoption option,...) easy_setopt;\n        CURLcode function(CURL *curl) easy_perform;\n        CURL* function(CURL *curl) easy_duphandle;\n        char* function(CURLcode) easy_strerror;\n        CURLcode function(CURL *handle, int bitmask) easy_pause;\n        void function(CURL *curl) easy_cleanup;\n        curl_slist* function(curl_slist *, char *) slist_append;\n        void function(curl_slist *) slist_free_all;\n    }\n    __gshared API _api;\n    __gshared void* _handle;\n\n    static ref API instance() @property\n    {\n        import std.concurrency : initOnce;\n        initOnce!_handle(loadAPI());\n        return _api;\n    }\n\n    static void* loadAPI()\n    {\n        version (Posix)\n        {\n            import core.sys.posix.dlfcn : dlsym, dlopen, dlclose, RTLD_LAZY;\n            alias loadSym = dlsym;\n        }\n        else version (Windows)\n        {\n            import core.sys.windows.windows : GetProcAddress, GetModuleHandleA,\n                LoadLibraryA;\n            alias loadSym = GetProcAddress;\n        }\n        else\n            static assert(0, \"unimplemented\");\n\n        void* handle;\n        version (Posix)\n            handle = dlopen(null, RTLD_LAZY);\n        else version (Windows)\n            handle = GetModuleHandleA(null);\n        assert(handle !is null);\n\n        // try to load curl from the executable to allow static linking\n        if (loadSym(handle, \"curl_global_init\") is null)\n        {\n            version (Posix)\n                dlclose(handle);\n\n            version (OSX)\n                static immutable names = [\"libcurl.4.dylib\"];\n            else version (Posix)\n            {\n                static immutable names = [\"libcurl.so\", \"libcurl.so.4\",\n                \"libcurl-gnutls.so.4\", \"libcurl-nss.so.4\", \"libcurl.so.3\"];\n            }\n            else version (Windows)\n                static immutable names = [\"libcurl.dll\", \"curl.dll\"];\n\n            foreach (name; names)\n            {\n                version (Posix)\n                    handle = dlopen(name.ptr, RTLD_LAZY);\n                else version (Windows)\n                    handle = LoadLibraryA(name.ptr);\n                if (handle !is null) break;\n            }\n\n            enforce!CurlException(handle !is null, \"Failed to load curl, tried %(%s, %).\".format(names));\n        }\n\n        foreach (i, FP; typeof(API.tupleof))\n        {\n            enum name = __traits(identifier, _api.tupleof[i]);\n            auto p = enforce!CurlException(loadSym(handle, \"curl_\"~name),\n                                           \"Couldn't load curl_\"~name~\" from libcurl.\");\n            _api.tupleof[i] = cast(FP) p;\n        }\n\n        enforce!CurlException(!_api.global_init(CurlGlobal.all),\n                              \"Failed to initialize libcurl\");\n\n        return handle;\n    }\n\n    shared static ~this()\n    {\n        if (_handle is null) return;\n\n        _api.global_cleanup();\n        version (Posix)\n        {\n            import core.sys.posix.dlfcn : dlclose;\n            dlclose(_handle);\n        }\n        else version (Windows)\n        {\n            import core.sys.windows.windows : FreeLibrary;\n            FreeLibrary(_handle);\n        }\n        else\n            static assert(0, \"unimplemented\");\n\n        _api = API.init;\n        _handle = null;\n    }\n}\n\n/**\n  Wrapper to provide a better interface to libcurl than using the plain C API.\n  It is recommended to use the $(D HTTP)/$(D FTP) etc. structs instead unless\n  raw access to libcurl is needed.\n\n  Warning: This struct uses interior pointers for callbacks. Only allocate it\n  on the stack if you never move or copy it. This also means passing by reference\n  when passing Curl to other functions. Otherwise always allocate on\n  the heap.\n*/\nstruct Curl\n{\n    alias OutData = void[];\n    alias InData = ubyte[];\n    private bool _stopped;\n\n    private static auto ref curl() @property { return CurlAPI.instance; }\n\n    // A handle should not be used by two threads simultaneously\n    private CURL* handle;\n\n    // May also return $(D CURL_READFUNC_ABORT) or $(D CURL_READFUNC_PAUSE)\n    private size_t delegate(OutData) _onSend;\n    private size_t delegate(InData) _onReceive;\n    private void delegate(in char[]) _onReceiveHeader;\n    private CurlSeek delegate(long,CurlSeekPos) _onSeek;\n    private int delegate(curl_socket_t,CurlSockType) _onSocketOption;\n    private int delegate(size_t dltotal, size_t dlnow,\n                         size_t ultotal, size_t ulnow) _onProgress;\n\n    alias requestPause = CurlReadFunc.pause;\n    alias requestAbort = CurlReadFunc.abort;\n\n    /**\n       Initialize the instance by creating a working curl handle.\n    */\n    void initialize()\n    {\n        enforce!CurlException(!handle, \"Curl instance already initialized\");\n        handle = curl.easy_init();\n        enforce!CurlException(handle, \"Curl instance couldn't be initialized\");\n        _stopped = false;\n        set(CurlOption.nosignal, 1);\n    }\n\n    ///\n    @property bool stopped() const\n    {\n        return _stopped;\n    }\n\n    /**\n       Duplicate this handle.\n\n       The new handle will have all options set as the one it was duplicated\n       from. An exception to this is that all options that cannot be shared\n       across threads are reset thereby making it safe to use the duplicate\n       in a new thread.\n    */\n    Curl dup()\n    {\n        Curl copy;\n        copy.handle = curl.easy_duphandle(handle);\n        copy._stopped = false;\n\n        with (CurlOption) {\n            auto tt = AliasSeq!(file, writefunction, writeheader,\n                headerfunction, infile, readfunction, ioctldata, ioctlfunction,\n                seekdata, seekfunction, sockoptdata, sockoptfunction,\n                opensocketdata, opensocketfunction, progressdata,\n                progressfunction, debugdata, debugfunction, interleavedata,\n                interleavefunction, chunk_data, chunk_bgn_function,\n                chunk_end_function, fnmatch_data, fnmatch_function, cookiejar, postfields);\n\n            foreach (option; tt)\n                copy.clear(option);\n        }\n\n        // The options are only supported by libcurl when it has been built\n        // against certain versions of OpenSSL - if your libcurl uses an old\n        // OpenSSL, or uses an entirely different SSL engine, attempting to\n        // clear these normally will raise an exception\n        copy.clearIfSupported(CurlOption.ssl_ctx_function);\n        copy.clearIfSupported(CurlOption.ssh_keydata);\n\n        // Enable for curl version > 7.21.7\n        static if (LIBCURL_VERSION_MAJOR >= 7 &&\n                   LIBCURL_VERSION_MINOR >= 21 &&\n                   LIBCURL_VERSION_PATCH >= 7)\n        {\n            copy.clear(CurlOption.closesocketdata);\n            copy.clear(CurlOption.closesocketfunction);\n        }\n\n        copy.set(CurlOption.nosignal, 1);\n\n        // copy.clear(CurlOption.ssl_ctx_data); Let ssl function be shared\n        // copy.clear(CurlOption.ssh_keyfunction); Let key function be shared\n\n        /*\n          Allow sharing of conv functions\n          copy.clear(CurlOption.conv_to_network_function);\n          copy.clear(CurlOption.conv_from_network_function);\n          copy.clear(CurlOption.conv_from_utf8_function);\n        */\n\n        return copy;\n    }\n\n    private void _check(CurlCode code)\n    {\n        enforce!CurlTimeoutException(code != CurlError.operation_timedout,\n                                       errorString(code));\n\n        enforce!CurlException(code == CurlError.ok,\n                                errorString(code));\n    }\n\n    private string errorString(CurlCode code)\n    {\n        import core.stdc.string : strlen;\n\n        auto msgZ = curl.easy_strerror(code);\n        // doing the following (instead of just using std.conv.to!string) avoids 1 allocation\n        return format(\"%s on handle %s\", msgZ[0 .. strlen(msgZ)], handle);\n    }\n\n    private void throwOnStopped(string message = null)\n    {\n        auto def = \"Curl instance called after being cleaned up\";\n        enforce!CurlException(!stopped,\n                                message == null ? def : message);\n    }\n\n    /**\n        Stop and invalidate this curl instance.\n        Warning: Do not call this from inside a callback handler e.g. $(D onReceive).\n    */\n    void shutdown()\n    {\n        throwOnStopped();\n        _stopped = true;\n        curl.easy_cleanup(this.handle);\n        this.handle = null;\n    }\n\n    /**\n       Pausing and continuing transfers.\n    */\n    void pause(bool sendingPaused, bool receivingPaused)\n    {\n        throwOnStopped();\n        _check(curl.easy_pause(this.handle,\n                               (sendingPaused ? CurlPause.send_cont : CurlPause.send) |\n                               (receivingPaused ? CurlPause.recv_cont : CurlPause.recv)));\n    }\n\n    /**\n       Set a string curl option.\n       Params:\n       option = A $(REF CurlOption, etc,c,curl) as found in the curl documentation\n       value = The string\n    */\n    void set(CurlOption option, const(char)[] value)\n    {\n        throwOnStopped();\n        _check(curl.easy_setopt(this.handle, option, value.tempCString().buffPtr));\n    }\n\n    /**\n       Set a long curl option.\n       Params:\n       option = A $(REF CurlOption, etc,c,curl) as found in the curl documentation\n       value = The long\n    */\n    void set(CurlOption option, long value)\n    {\n        throwOnStopped();\n        _check(curl.easy_setopt(this.handle, option, value));\n    }\n\n    /**\n       Set a void* curl option.\n       Params:\n       option = A $(REF CurlOption, etc,c,curl) as found in the curl documentation\n       value = The pointer\n    */\n    void set(CurlOption option, void* value)\n    {\n        throwOnStopped();\n        _check(curl.easy_setopt(this.handle, option, value));\n    }\n\n    /**\n       Clear a pointer option.\n       Params:\n       option = A $(REF CurlOption, etc,c,curl) as found in the curl documentation\n    */\n    void clear(CurlOption option)\n    {\n        throwOnStopped();\n        _check(curl.easy_setopt(this.handle, option, null));\n    }\n\n    /**\n       Clear a pointer option. Does not raise an exception if the underlying\n       libcurl does not support the option. Use sparingly.\n       Params:\n       option = A $(REF CurlOption, etc,c,curl) as found in the curl documentation\n    */\n    void clearIfSupported(CurlOption option)\n    {\n        throwOnStopped();\n        auto rval = curl.easy_setopt(this.handle, option, null);\n        if (rval != CurlError.unknown_option && rval != CurlError.not_built_in)\n            _check(rval);\n    }\n\n    /**\n       perform the curl request by doing the HTTP,FTP etc. as it has\n       been setup beforehand.\n\n       Params:\n       throwOnError = whether to throw an exception or return a CurlCode on error\n    */\n    CurlCode perform(ThrowOnError throwOnError = Yes.throwOnError)\n    {\n        throwOnStopped();\n        CurlCode code = curl.easy_perform(this.handle);\n        if (throwOnError)\n            _check(code);\n        return code;\n    }\n\n    /**\n      * The event handler that receives incoming data.\n      *\n      * Params:\n      * callback = the callback that receives the $(D ubyte[]) data.\n      * Be sure to copy the incoming data and not store\n      * a slice.\n      *\n      * Returns:\n      * The callback returns the incoming bytes read. If not the entire array is\n      * the request will abort.\n      * The special value HTTP.pauseRequest can be returned in order to pause the\n      * current request.\n      *\n      * Example:\n      * ----\n      * import std.net.curl, std.stdio;\n      * Curl curl;\n      * curl.initialize();\n      * curl.set(CurlOption.url, \"http://dlang.org\");\n      * curl.onReceive = (ubyte[] data) { writeln(\"Got data\", to!(const(char)[])(data)); return data.length;};\n      * curl.perform();\n      * ----\n      */\n    @property void onReceive(size_t delegate(InData) callback)\n    {\n        _onReceive = (InData id)\n        {\n            throwOnStopped(\"Receive callback called on cleaned up Curl instance\");\n            return callback(id);\n        };\n        set(CurlOption.file, cast(void*) &this);\n        set(CurlOption.writefunction, cast(void*) &Curl._receiveCallback);\n    }\n\n    /**\n      * The event handler that receives incoming headers for protocols\n      * that uses headers.\n      *\n      * Params:\n      * callback = the callback that receives the header string.\n      * Make sure the callback copies the incoming params if\n      * it needs to store it because they are references into\n      * the backend and may very likely change.\n      *\n      * Example:\n      * ----\n      * import std.net.curl, std.stdio;\n      * Curl curl;\n      * curl.initialize();\n      * curl.set(CurlOption.url, \"http://dlang.org\");\n      * curl.onReceiveHeader = (in char[] header) { writeln(header); };\n      * curl.perform();\n      * ----\n      */\n    @property void onReceiveHeader(void delegate(in char[]) callback)\n    {\n        _onReceiveHeader = (in char[] od)\n        {\n            throwOnStopped(\"Receive header callback called on \"~\n                           \"cleaned up Curl instance\");\n            callback(od);\n        };\n        set(CurlOption.writeheader, cast(void*) &this);\n        set(CurlOption.headerfunction,\n            cast(void*) &Curl._receiveHeaderCallback);\n    }\n\n    /**\n      * The event handler that gets called when data is needed for sending.\n      *\n      * Params:\n      * callback = the callback that has a $(D void[]) buffer to be filled\n      *\n      * Returns:\n      * The callback returns the number of elements in the buffer that have been\n      * filled and are ready to send.\n      * The special value $(D Curl.abortRequest) can be returned in\n      * order to abort the current request.\n      * The special value $(D Curl.pauseRequest) can be returned in order to\n      * pause the current request.\n      *\n      * Example:\n      * ----\n      * import std.net.curl;\n      * Curl curl;\n      * curl.initialize();\n      * curl.set(CurlOption.url, \"http://dlang.org\");\n      *\n      * string msg = \"Hello world\";\n      * curl.onSend = (void[] data)\n      * {\n      *     auto m = cast(void[])msg;\n      *     size_t length = m.length > data.length ? data.length : m.length;\n      *     if (length == 0) return 0;\n      *     data[0..length] = m[0..length];\n      *     msg = msg[length..$];\n      *     return length;\n      * };\n      * curl.perform();\n      * ----\n      */\n    @property void onSend(size_t delegate(OutData) callback)\n    {\n        _onSend = (OutData od)\n        {\n            throwOnStopped(\"Send callback called on cleaned up Curl instance\");\n            return callback(od);\n        };\n        set(CurlOption.infile, cast(void*) &this);\n        set(CurlOption.readfunction, cast(void*) &Curl._sendCallback);\n    }\n\n    /**\n      * The event handler that gets called when the curl backend needs to seek\n      * the data to be sent.\n      *\n      * Params:\n      * callback = the callback that receives a seek offset and a seek position\n      *            $(REF CurlSeekPos, etc,c,curl)\n      *\n      * Returns:\n      * The callback returns the success state of the seeking\n      * $(REF CurlSeek, etc,c,curl)\n      *\n      * Example:\n      * ----\n      * import std.net.curl;\n      * Curl curl;\n      * curl.initialize();\n      * curl.set(CurlOption.url, \"http://dlang.org\");\n      * curl.onSeek = (long p, CurlSeekPos sp)\n      * {\n      *     return CurlSeek.cantseek;\n      * };\n      * curl.perform();\n      * ----\n      */\n    @property void onSeek(CurlSeek delegate(long, CurlSeekPos) callback)\n    {\n        _onSeek = (long ofs, CurlSeekPos sp)\n        {\n            throwOnStopped(\"Seek callback called on cleaned up Curl instance\");\n            return callback(ofs, sp);\n        };\n        set(CurlOption.seekdata, cast(void*) &this);\n        set(CurlOption.seekfunction, cast(void*) &Curl._seekCallback);\n    }\n\n    /**\n      * The event handler that gets called when the net socket has been created\n      * but a $(D connect()) call has not yet been done. This makes it possible to set\n      * misc. socket options.\n      *\n      * Params:\n      * callback = the callback that receives the socket and socket type\n      * $(REF CurlSockType, etc,c,curl)\n      *\n      * Returns:\n      * Return 0 from the callback to signal success, return 1 to signal error\n      * and make curl close the socket\n      *\n      * Example:\n      * ----\n      * import std.net.curl;\n      * Curl curl;\n      * curl.initialize();\n      * curl.set(CurlOption.url, \"http://dlang.org\");\n      * curl.onSocketOption = delegate int(curl_socket_t s, CurlSockType t) { /+ do stuff +/ };\n      * curl.perform();\n      * ----\n      */\n    @property void onSocketOption(int delegate(curl_socket_t,\n                                               CurlSockType) callback)\n    {\n        _onSocketOption = (curl_socket_t sock, CurlSockType st)\n        {\n            throwOnStopped(\"Socket option callback called on \"~\n                           \"cleaned up Curl instance\");\n            return callback(sock, st);\n        };\n        set(CurlOption.sockoptdata, cast(void*) &this);\n        set(CurlOption.sockoptfunction,\n            cast(void*) &Curl._socketOptionCallback);\n    }\n\n    /**\n      * The event handler that gets called to inform of upload/download progress.\n      *\n      * Params:\n      * callback = the callback that receives the (total bytes to download,\n      * currently downloaded bytes, total bytes to upload, currently uploaded\n      * bytes).\n      *\n      * Returns:\n      * Return 0 from the callback to signal success, return non-zero to abort\n      * transfer\n      *\n      * Example:\n      * ----\n      * import std.net.curl;\n      * Curl curl;\n      * curl.initialize();\n      * curl.set(CurlOption.url, \"http://dlang.org\");\n      * curl.onProgress = delegate int(size_t dltotal, size_t dlnow, size_t ultotal, size_t uln)\n      * {\n      *     writeln(\"Progress: downloaded bytes \", dlnow, \" of \", dltotal);\n      *     writeln(\"Progress: uploaded bytes \", ulnow, \" of \", ultotal);\n      *     curl.perform();\n      * };\n      * ----\n      */\n    @property void onProgress(int delegate(size_t dlTotal,\n                                           size_t dlNow,\n                                           size_t ulTotal,\n                                           size_t ulNow) callback)\n    {\n        _onProgress = (size_t dlt, size_t dln, size_t ult, size_t uln)\n        {\n            throwOnStopped(\"Progress callback called on cleaned \"~\n                           \"up Curl instance\");\n            return callback(dlt, dln, ult, uln);\n        };\n        set(CurlOption.noprogress, 0);\n        set(CurlOption.progressdata, cast(void*) &this);\n        set(CurlOption.progressfunction, cast(void*) &Curl._progressCallback);\n    }\n\n    // Internal C callbacks to register with libcurl\n    extern (C) private static\n    size_t _receiveCallback(const char* str,\n                            size_t size, size_t nmemb, void* ptr)\n    {\n        auto b = cast(Curl*) ptr;\n        if (b._onReceive != null)\n            return b._onReceive(cast(InData)(str[0..size*nmemb]));\n        return size*nmemb;\n    }\n\n    extern (C) private static\n    size_t _receiveHeaderCallback(const char* str,\n                                  size_t size, size_t nmemb, void* ptr)\n    {\n        auto b = cast(Curl*) ptr;\n        auto s = str[0..size*nmemb].chomp();\n        if (b._onReceiveHeader != null)\n            b._onReceiveHeader(s);\n\n        return size*nmemb;\n    }\n\n    extern (C) private static\n    size_t _sendCallback(char *str, size_t size, size_t nmemb, void *ptr)\n    {\n        Curl* b = cast(Curl*) ptr;\n        auto a = cast(void[]) str[0..size*nmemb];\n        if (b._onSend == null)\n            return 0;\n        return b._onSend(a);\n    }\n\n    extern (C) private static\n    int _seekCallback(void *ptr, curl_off_t offset, int origin)\n    {\n        auto b = cast(Curl*) ptr;\n        if (b._onSeek == null)\n            return CurlSeek.cantseek;\n\n        // origin: CurlSeekPos.set/current/end\n        // return: CurlSeek.ok/fail/cantseek\n        return b._onSeek(cast(long) offset, cast(CurlSeekPos) origin);\n    }\n\n    extern (C) private static\n    int _socketOptionCallback(void *ptr,\n                              curl_socket_t curlfd, curlsocktype purpose)\n    {\n        auto b = cast(Curl*) ptr;\n        if (b._onSocketOption == null)\n            return 0;\n\n        // return: 0 ok, 1 fail\n        return b._onSocketOption(curlfd, cast(CurlSockType) purpose);\n    }\n\n    extern (C) private static\n    int _progressCallback(void *ptr,\n                          double dltotal, double dlnow,\n                          double ultotal, double ulnow)\n    {\n        auto b = cast(Curl*) ptr;\n        if (b._onProgress == null)\n            return 0;\n\n        // return: 0 ok, 1 fail\n        return b._onProgress(cast(size_t)dltotal, cast(size_t)dlnow,\n                             cast(size_t)ultotal, cast(size_t)ulnow);\n    }\n\n}\n\n// Internal messages send between threads.\n// The data is wrapped in this struct in order to ensure that\n// other std.concurrency.receive calls does not pick up our messages\n// by accident.\nprivate struct CurlMessage(T)\n{\n    public T data;\n}\n\nprivate static CurlMessage!T curlMessage(T)(T data)\n{\n    return CurlMessage!T(data);\n}\n\n// Pool of to be used for reusing buffers\nprivate struct Pool(Data)\n{\n    private struct Entry\n    {\n        Data data;\n        Entry* next;\n    }\n    private Entry*  root;\n    private Entry* freeList;\n\n    @safe @property bool empty()\n    {\n        return root == null;\n    }\n\n    @safe nothrow void push(Data d)\n    {\n        if (freeList == null)\n        {\n            // Allocate new Entry since there is no one\n            // available in the freeList\n            freeList = new Entry;\n        }\n        freeList.data = d;\n        Entry* oldroot = root;\n        root = freeList;\n        freeList = freeList.next;\n        root.next = oldroot;\n    }\n\n    @safe Data pop()\n    {\n        enforce!Exception(root != null, \"pop() called on empty pool\");\n        auto d = root.data;\n        auto n = root.next;\n        root.next = freeList;\n        freeList = root;\n        root = n;\n        return d;\n    }\n}\n\n// Shared function for reading incoming chunks of data and\n// sending the to a parent thread\nprivate static size_t _receiveAsyncChunks(ubyte[] data, ref ubyte[] outdata,\n                                          Pool!(ubyte[]) freeBuffers,\n                                          ref ubyte[] buffer, Tid fromTid,\n                                          ref bool aborted)\n{\n    immutable datalen = data.length;\n\n    // Copy data to fill active buffer\n    while (!data.empty)\n    {\n\n        // Make sure a buffer is present\n        while ( outdata.empty && freeBuffers.empty)\n        {\n            // Active buffer is invalid and there are no\n            // available buffers in the pool. Wait for buffers\n            // to return from main thread in order to reuse\n            // them.\n            receive((immutable(ubyte)[] buf)\n                    {\n                        buffer = cast(ubyte[])buf;\n                        outdata = buffer[];\n                    },\n                    (bool flag) { aborted = true; }\n                    );\n            if (aborted) return cast(size_t)0;\n        }\n        if (outdata.empty)\n        {\n            buffer = freeBuffers.pop();\n            outdata = buffer[];\n        }\n\n        // Copy data\n        auto copyBytes = outdata.length < data.length ?\n            outdata.length : data.length;\n\n        outdata[0..copyBytes] = data[0..copyBytes];\n        outdata = outdata[copyBytes..$];\n        data = data[copyBytes..$];\n\n        if (outdata.empty)\n            fromTid.send(thisTid, curlMessage(cast(immutable(ubyte)[])buffer));\n    }\n\n    return datalen;\n}\n\n// ditto\nprivate static void _finalizeAsyncChunks(ubyte[] outdata, ref ubyte[] buffer,\n                                         Tid fromTid)\n{\n    if (!outdata.empty)\n    {\n        // Resize the last buffer\n        buffer.length = buffer.length - outdata.length;\n        fromTid.send(thisTid, curlMessage(cast(immutable(ubyte)[])buffer));\n    }\n}\n\n\n// Shared function for reading incoming lines of data and sending the to a\n// parent thread\nprivate static size_t _receiveAsyncLines(Terminator, Unit)\n    (const(ubyte)[] data, ref EncodingScheme encodingScheme,\n     bool keepTerminator, Terminator terminator,\n     ref const(ubyte)[] leftOverBytes, ref bool bufferValid,\n     ref Pool!(Unit[]) freeBuffers, ref Unit[] buffer,\n     Tid fromTid, ref bool aborted)\n{\n\n    immutable datalen = data.length;\n\n    // Terminator is specified and buffers should be resized as determined by\n    // the terminator\n\n    // Copy data to active buffer until terminator is found.\n\n    // Decode as many lines as possible\n    while (true)\n    {\n\n        // Make sure a buffer is present\n        while (!bufferValid && freeBuffers.empty)\n        {\n            // Active buffer is invalid and there are no available buffers in\n            // the pool. Wait for buffers to return from main thread in order to\n            // reuse them.\n            receive((immutable(Unit)[] buf)\n                    {\n                        buffer = cast(Unit[])buf;\n                        buffer.length = 0;\n                        buffer.assumeSafeAppend();\n                        bufferValid = true;\n                    },\n                    (bool flag) { aborted = true; }\n                    );\n            if (aborted) return cast(size_t)0;\n        }\n        if (!bufferValid)\n        {\n            buffer = freeBuffers.pop();\n            bufferValid = true;\n        }\n\n        // Try to read a line from left over bytes from last onReceive plus the\n        // newly received bytes.\n        try\n        {\n            if (decodeLineInto(leftOverBytes, data, buffer,\n                               encodingScheme, terminator))\n            {\n                if (keepTerminator)\n                {\n                    fromTid.send(thisTid,\n                                 curlMessage(cast(immutable(Unit)[])buffer));\n                }\n                else\n                {\n                    static if (isArray!Terminator)\n                        fromTid.send(thisTid,\n                                     curlMessage(cast(immutable(Unit)[])\n                                             buffer[0..$-terminator.length]));\n                    else\n                        fromTid.send(thisTid,\n                                     curlMessage(cast(immutable(Unit)[])\n                                             buffer[0..$-1]));\n                }\n                bufferValid = false;\n            }\n            else\n            {\n                // Could not decode an entire line. Save\n                // bytes left in data for next call to\n                // onReceive. Can be up to a max of 4 bytes.\n                enforce!CurlException(data.length <= 4,\n                                        format(\n                                        \"Too many bytes left not decoded %s\"~\n                                        \" > 4. Maybe the charset specified in\"~\n                                        \" headers does not match \"~\n                                        \"the actual content downloaded?\",\n                                        data.length));\n                leftOverBytes ~= data;\n                break;\n            }\n        }\n        catch (CurlException ex)\n        {\n            prioritySend(fromTid, cast(immutable(CurlException))ex);\n            return cast(size_t)0;\n        }\n    }\n    return datalen;\n}\n\n// ditto\nprivate static\nvoid _finalizeAsyncLines(Unit)(bool bufferValid, Unit[] buffer, Tid fromTid)\n{\n    if (bufferValid && buffer.length != 0)\n        fromTid.send(thisTid, curlMessage(cast(immutable(Unit)[])buffer[0..$]));\n}\n\n\n// Spawn a thread for handling the reading of incoming data in the\n// background while the delegate is executing.  This will optimize\n// throughput by allowing simultaneous input (this struct) and\n// output (e.g. AsyncHTTPLineOutputRange).\nprivate static void _spawnAsync(Conn, Unit, Terminator = void)()\n{\n    Tid fromTid = receiveOnly!Tid();\n\n    // Get buffer to read into\n    Pool!(Unit[]) freeBuffers;  // Free list of buffer objects\n\n    // Number of bytes filled into active buffer\n    Unit[] buffer;\n    bool aborted = false;\n\n    EncodingScheme encodingScheme;\n    static if ( !is(Terminator == void))\n    {\n        // Only lines reading will receive a terminator\n        const terminator = receiveOnly!Terminator();\n        const keepTerminator = receiveOnly!bool();\n\n        // max number of bytes to carry over from an onReceive\n        // callback. This is 4 because it is the max code units to\n        // decode a code point in the supported encodings.\n        auto leftOverBytes =  new const(ubyte)[4];\n        leftOverBytes.length = 0;\n        auto bufferValid = false;\n    }\n    else\n    {\n        Unit[] outdata;\n    }\n\n    // no move semantic available in std.concurrency ie. must use casting.\n    auto connDup = cast(CURL*)receiveOnly!ulong();\n    auto client = Conn();\n    client.p.curl.handle = connDup;\n\n    // receive a method for both ftp and http but just use it for http\n    auto method = receiveOnly!(HTTP.Method)();\n\n    client.onReceive = (ubyte[] data)\n    {\n        // If no terminator is specified the chunk size is fixed.\n        static if ( is(Terminator == void) )\n            return _receiveAsyncChunks(data, outdata, freeBuffers, buffer,\n                                       fromTid, aborted);\n        else\n            return _receiveAsyncLines(data, encodingScheme,\n                                      keepTerminator, terminator, leftOverBytes,\n                                      bufferValid, freeBuffers, buffer,\n                                      fromTid, aborted);\n    };\n\n    static if ( is(Conn == HTTP) )\n    {\n        client.method = method;\n        // register dummy header handler\n        client.onReceiveHeader = (in char[] key, in char[] value)\n        {\n            if (key == \"content-type\")\n                encodingScheme = EncodingScheme.create(client.p.charset);\n        };\n    }\n    else\n    {\n        encodingScheme = EncodingScheme.create(client.encoding);\n    }\n\n    // Start the request\n    CurlCode code;\n    try\n    {\n        code = client.perform(No.throwOnError);\n    }\n    catch (Exception ex)\n    {\n        prioritySend(fromTid, cast(immutable(Exception)) ex);\n        fromTid.send(thisTid, curlMessage(true)); // signal done\n        return;\n    }\n\n    if (code != CurlError.ok)\n    {\n        if (aborted && (code == CurlError.aborted_by_callback ||\n                        code == CurlError.write_error))\n        {\n            fromTid.send(thisTid, curlMessage(true)); // signal done\n            return;\n        }\n        prioritySend(fromTid, cast(immutable(CurlException))\n                     new CurlException(client.p.curl.errorString(code)));\n\n        fromTid.send(thisTid, curlMessage(true)); // signal done\n        return;\n    }\n\n    // Send remaining data that is not a full chunk size\n    static if ( is(Terminator == void) )\n        _finalizeAsyncChunks(outdata, buffer, fromTid);\n    else\n        _finalizeAsyncLines(bufferValid, buffer, fromTid);\n\n    fromTid.send(thisTid, curlMessage(true)); // signal done\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/runtime/druntime/src/core/sys/posix/dlfcn.d": "/**\n * D header file for POSIX.\n *\n * Copyright: Copyright Sean Kelly 2005 - 2009.\n * License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n * Authors:   Sean Kelly, Alex R\u00f8nne Petersen\n * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition\n */\n\n/*          Copyright Sean Kelly 2005 - 2009.\n * Distributed under the Boost Software License, Version 1.0.\n *    (See accompanying file LICENSE or copy at\n *          http://www.boost.org/LICENSE_1_0.txt)\n */\nmodule core.sys.posix.dlfcn;\n\nprivate import core.sys.posix.config;\n\nversion (OSX)\n    version = Darwin;\nelse version (iOS)\n    version = Darwin;\nelse version (TVOS)\n    version = Darwin;\nelse version (WatchOS)\n    version = Darwin;\n\nversion (Posix):\nextern (C):\nnothrow:\n@nogc:\n\n//\n// XOpen (XSI)\n//\n/*\nRTLD_LAZY\nRTLD_NOW\nRTLD_GLOBAL\nRTLD_LOCAL\n\nint   dlclose(void*);\nchar* dlerror();\nvoid* dlopen(in char*, int);\nvoid* dlsym(void*, in char*);\n*/\n\nversion( CRuntime_Glibc )\n{\n    version (X86)\n    {\n        enum RTLD_LAZY      = 0x00001;\n        enum RTLD_NOW       = 0x00002;\n        enum RTLD_GLOBAL    = 0x00100;\n        enum RTLD_LOCAL     = 0x00000;\n    }\n    else version (X86_64)\n    {\n        enum RTLD_LAZY      = 0x00001;\n        enum RTLD_NOW       = 0x00002;\n        enum RTLD_GLOBAL    = 0x00100;\n        enum RTLD_LOCAL     = 0x00000;\n    }\n    else version (MIPS32)\n    {\n        enum RTLD_LAZY      = 0x0001;\n        enum RTLD_NOW       = 0x0002;\n        enum RTLD_GLOBAL    = 0x0004;\n        enum RTLD_LOCAL     = 0;\n    }\n    else version (MIPS64)\n    {\n        enum RTLD_LAZY      = 0x0001;\n        enum RTLD_NOW       = 0x0002;\n        enum RTLD_GLOBAL    = 0x0004;\n        enum RTLD_LOCAL     = 0;\n    }\n    else version (PPC)\n    {\n        enum RTLD_LAZY      = 0x00001;\n        enum RTLD_NOW       = 0x00002;\n        enum RTLD_GLOBAL    = 0x00100;\n        enum RTLD_LOCAL     = 0;\n    }\n    else version (PPC64)\n    {\n        enum RTLD_LAZY      = 0x00001;\n        enum RTLD_NOW       = 0x00002;\n        enum RTLD_GLOBAL    = 0x00100;\n        enum RTLD_LOCAL     = 0;\n    }\n    else version (ARM)\n    {\n        enum RTLD_LAZY      = 0x00001;\n        enum RTLD_NOW       = 0x00002;\n        enum RTLD_GLOBAL    = 0x00100;\n        enum RTLD_LOCAL     = 0;\n    }\n    else version (AArch64)\n    {\n        enum RTLD_LAZY      = 0x00001;\n        enum RTLD_NOW       = 0x00002;\n        enum RTLD_GLOBAL    = 0x00100;\n        enum RTLD_LOCAL     = 0;\n    }\n    else version (SystemZ)\n    {\n        enum RTLD_LAZY      = 0x00001;\n        enum RTLD_NOW       = 0x00002;\n        enum RTLD_GLOBAL    = 0x00100;\n        enum RTLD_LOCAL     = 0;\n    }\n    else\n        static assert(0, \"unimplemented\");\n\n    int   dlclose(void*);\n    char* dlerror();\n    void* dlopen(in char*, int);\n    void* dlsym(void*, in char*);\n\n    deprecated(\"Please use core.sys.linux.dlfcn for non-POSIX extensions\")\n    {\n        int   dladdr(in void* addr, Dl_info* info);\n        void* dlvsym(void* handle, in char* symbol, in char* version_);\n\n        struct Dl_info\n        {\n            const(char)* dli_fname;\n            void*        dli_fbase;\n            const(char)* dli_sname;\n            void*        dli_saddr;\n        }\n    }\n}\nelse version( Darwin )\n{\n    enum RTLD_LAZY      = 0x00001;\n    enum RTLD_NOW       = 0x00002;\n    enum RTLD_GLOBAL    = 0x00100;\n    enum RTLD_LOCAL     = 0x00000;\n\n    int   dlclose(void*);\n    char* dlerror();\n    void* dlopen(in char*, int);\n    void* dlsym(void*, in char*);\n\n    deprecated(\"Please use core.sys.osx.dlfcn for non-POSIX extensions\")\n    {\n        int dladdr(in void* addr, Dl_info* info);\n\n        struct Dl_info\n        {\n            const(char)* dli_fname;\n            void*        dli_fbase;\n            const(char)* dli_sname;\n            void*        dli_saddr;\n        }\n    }\n}\nelse version( FreeBSD )\n{\n    enum RTLD_LAZY      = 1;\n    enum RTLD_NOW       = 2;\n    enum RTLD_GLOBAL    = 0x100;\n    enum RTLD_LOCAL     = 0;\n\n    int   dlclose(void*);\n    char* dlerror();\n    void* dlopen(in char*, int);\n    void* dlsym(void*, in char*);\n    int   dladdr(const(void)* addr, Dl_info* info);\n\n    struct Dl_info\n    {\n        const(char)* dli_fname;\n        void*        dli_fbase;\n        const(char)* dli_sname;\n        void*        dli_saddr;\n    }\n}\nelse version(NetBSD)\n{\n    enum RTLD_LAZY      = 1;\n    enum RTLD_NOW       = 2;\n    enum RTLD_GLOBAL    = 0x100;\n    enum RTLD_LOCAL     = 0x200;\n    enum RTLD_NODELETE  = 0x01000;         /* Do not remove members. */\n    enum RTLD_NOLOAD    = 0x02000;\n\n    int   dlclose(void*);\n    char* dlerror();\n    void* dlopen(in char*, int);\n    void* dlsym(void*, in char*);\n    int   dladdr(const(void)* addr, Dl_info* info);\n\n    struct Dl_info\n    {\n        const(char)* dli_fname;\n        void*        dli_fbase;\n        const(char)* dli_sname;\n        void*        dli_saddr;\n    }\n}\nelse version( OpenBSD )\n{\n    enum RTLD_LAZY      = 1;\n    enum RTLD_NOW       = 2;\n    enum RTLD_GLOBAL    = 0x100;\n    enum RTLD_LOCAL     = 0;\n\n    int   dlclose(void*);\n    char* dlerror();\n    void* dlopen(in char*, int);\n    void* dlsym(void*, in char*);\n    int   dladdr(const(void)* addr, Dl_info* info);\n\n    struct Dl_info\n    {\n        const(char)* dli_fname;\n        void*        dli_fbase;\n        const(char)* dli_sname;\n        void*        dli_saddr;\n    }\n}\nelse version( Solaris )\n{\n    enum RTLD_LAZY      = 1;\n    enum RTLD_NOW       = 2;\n    enum RTLD_GLOBAL    = 0x100;\n    enum RTLD_LOCAL     = 0;\n\n    int   dlclose(void*);\n    char* dlerror();\n    void* dlopen(in char*, int);\n    void* dlsym(void*, in char*);\n    int   dladdr(const(void)* addr, Dl_info* info);\n\n    struct Dl_info\n    {\n        const(char)* dli_fname;\n        void*        dli_fbase;\n        const(char)* dli_sname;\n        void*        dli_saddr;\n    }\n}\nelse version( CRuntime_Bionic )\n{\n    enum\n    {\n        RTLD_NOW    = 0,\n        RTLD_LAZY   = 1,\n        RTLD_LOCAL  = 0,\n        RTLD_GLOBAL = 2\n    }\n\n    int          dladdr(in void*, Dl_info*);\n    int          dlclose(void*);\n    const(char)* dlerror();\n    void*        dlopen(in char*, int);\n    void*        dlsym(void*, in char*);\n\n    struct Dl_info\n    {\n        const(char)* dli_fname;\n        void*        dli_fbase;\n        const(char)* dli_sname;\n        void*        dli_saddr;\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/runtime/druntime/src/core/sys/linux/dlfcn.d": "/**\n * D header file for GNU/Linux\n *\n * $(LINK2 http://sourceware.org/git/?p=glibc.git;a=blob;f=dlfcn/dlfcn.h, glibc dlfcn/dlfcn.h)\n */\nmodule core.sys.linux.dlfcn;\n\nversion (linux):\nextern (C):\nnothrow:\n\npublic import core.sys.posix.dlfcn;\nimport core.sys.linux.config;\n\n// <bits/dlfcn.h>\nversion (X86)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n    // enum RTLD_LAZY = 0x00001; // POSIX\n    // enum RTLD_NOW = 0x00002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00004;\n    enum RTLD_DEEPBIND = 0x00008;\n\n    // enum RTLD_GLOBAL = 0x00100; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (X86_64)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n    // enum RTLD_LAZY = 0x00001; // POSIX\n    // enum RTLD_NOW = 0x00002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00004;\n    enum RTLD_DEEPBIND = 0x00008;\n\n    // enum RTLD_GLOBAL = 0x00100; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (MIPS32)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=ports/sysdeps/mips/bits/dlfcn.h\n    // enum RTLD_LAZY = 0x0001; // POSIX\n    // enum RTLD_NOW = 0x0002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00008;\n    enum RTLD_DEEPBIND = 0x00010;\n\n    // enum RTLD_GLOBAL = 0x0004; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (MIPS64)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=ports/sysdeps/mips/bits/dlfcn.h\n    // enum RTLD_LAZY = 0x0001; // POSIX\n    // enum RTLD_NOW = 0x0002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00008;\n    enum RTLD_DEEPBIND = 0x00010;\n\n    // enum RTLD_GLOBAL = 0x0004; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (PPC)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n    // enum RTLD_LAZY = 0x0001; // POSIX\n    // enum RTLD_NOW = 0x0002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00004;\n    enum RTLD_DEEPBIND = 0x00008;\n\n    // enum RTLD_GLOBAL = 0x00100; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (PPC64)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n    // enum RTLD_LAZY = 0x0001; // POSIX\n    // enum RTLD_NOW = 0x0002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00004;\n    enum RTLD_DEEPBIND = 0x00008;\n\n    // enum RTLD_GLOBAL = 0x00100; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (ARM)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n    // enum RTLD_LAZY = 0x0001; // POSIX\n    // enum RTLD_NOW = 0x0002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00004;\n    enum RTLD_DEEPBIND = 0x00008;\n\n    // enum RTLD_GLOBAL = 0x00100; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (AArch64)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n    // enum RTLD_LAZY = 0x0001; // POSIX\n    // enum RTLD_NOW = 0x0002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00004;\n    enum RTLD_DEEPBIND = 0x00008;\n\n    // enum RTLD_GLOBAL = 0x00100; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (SystemZ)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n    // enum RTLD_LAZY = 0x0001; // POSIX\n    // enum RTLD_NOW = 0x0002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00004;\n    enum RTLD_DEEPBIND = 0x00008;\n\n    // enum RTLD_GLOBAL = 0x00100; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse\n    static assert(0, \"unimplemented\");\n\n// <bits/dlfcn.h>\n\nstatic if (__USE_GNU)\n{\n    enum RTLD_NEXT = cast(void *)-1L;\n    enum RTLD_DEFAULT = cast(void *)0;\n    alias c_long Lmid_t;\n    enum LM_ID_BASE = 0;\n    enum LM_ID_NEWLM = -1;\n}\n\n// void* dlopen(in char* __file, int __mode); // POSIX\n// int dlclose(void* __handle); // POSIX\n// void* dlsym(void* __handle, in char* __name); // POSIX\n\nstatic if (__USE_GNU)\n{\n    void* dlmopen(Lmid_t __nsid, in char* __file, int __mode);\n    void* dlvsym(void* __handle, in char* __name, in char* __version);\n}\n\n// char* dlerror(); // POSIX\n\nstatic if (__USE_GNU)\n{\n    struct Dl_info\n    {\n        const(char)* dli_fname;\n        void* dli_fbase;\n        const(char)* dli_sname;\n        void* dli_saddr;\n    }\n\n    int dladdr(in void* __address, Dl_info* __info);\n    int dladdr1(void* __address, Dl_info* __info, void** __extra_info, int __flags);\n\n    enum\n    {\n        RTLD_DL_SYMENT = 1,\n        RTLD_DL_LINKMAP = 2,\n    }\n\n    int dlinfo(void* __handle, int __request, void* __arg);\n\n    enum\n    {\n        RTLD_DI_LMID = 1,\n        RTLD_DI_LINKMAP = 2,\n        RTLD_DI_CONFIGADDR = 3,\n        RTLD_DI_SERINFO = 4,\n        RTLD_DI_SERINFOSIZE = 5,\n        RTLD_DI_ORIGIN = 6,\n        RTLD_DI_PROFILENAME = 7,\n        RTLD_DI_PROFILEOUT = 8,\n        RTLD_DI_TLS_MODID = 9,\n        RTLD_DI_TLS_DATA = 10,\n        RTLD_DI_MAX = 10,\n    }\n\n    struct Dl_serpath\n    {\n        char* dls_name;\n        uint dls_flags;\n    }\n\n    struct Dl_serinfo\n    {\n        size_t dls_size;\n        uint dls_cnt;\n        Dl_serpath[1] dls_serpath;\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/runtime/druntime/src/core/sys/freebsd/dlfcn.d": "/**\n * D header file for FreeBSD.\n *\n * Copyright: Copyright Martin Nowak 2012.\n * License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n * Authors:   Martin Nowak\n */\nmodule core.sys.freebsd.dlfcn;\n\npublic import core.sys.posix.dlfcn;\n\nversion (FreeBSD):\nextern (C):\nnothrow:\n\nenum __BSD_VISIBLE = true;\n\n/*\n * Modes and flags for dlopen().\n */\nstatic assert(RTLD_LAZY   == 1);\nstatic assert(RTLD_NOW    == 2);\nenum RTLD_MODEMASK        =  0x3;\nstatic assert(RTLD_GLOBAL == 0x100);\nstatic assert(RTLD_LOCAL  == 0);\nenum RTLD_TRACE           =  0x200;\nenum RTLD_NODELETE        =  0x01000;\nenum RTLD_NOLOAD          =  0x02000;\n\n/*\n * Request arguments for dlinfo().\n */\nenum RTLD_DI_LINKMAP     = 2;    /* Obtain link map. */\nenum RTLD_DI_SERINFO     = 4;    /* Obtain search path info. */\nenum RTLD_DI_SERINFOSIZE = 5;    /*  ... query for required space. */\nenum RTLD_DI_ORIGIN      = 6;    /* Obtain object origin */\nenum RTLD_DI_MAX         = RTLD_DI_ORIGIN;\n\n/*\n * Special handle arguments for dlsym()/dlinfo().\n */\nenum RTLD_NEXT    = cast(void *)-1;    /* Search subsequent objects. */\nenum RTLD_DEFAULT = cast(void *)-2;    /* Use default search algorithm. */\nenum RTLD_SELF    = cast(void *)-3;    /* Search the caller itself. */\n\nstatic if (__BSD_VISIBLE)\n{\n    /*\n     * Structure filled in by dladdr().\n     */\n    struct Dl_info {\n        const(char)     *dli_fname;     /* Pathname of shared object. */\n        void            *dli_fbase;     /* Base address of shared object. */\n        const(char)     *dli_sname;     /* Name of nearest symbol. */\n        void            *dli_saddr;     /* Address of nearest symbol. */\n    };\n\n    /*-\n     * The actual type declared by this typedef is immaterial, provided that\n     * it is a function pointer.  Its purpose is to provide a return type for\n     * dlfunc() which can be cast to a function pointer type without depending\n     * on behavior undefined by the C standard, which might trigger a compiler\n     * diagnostic.  We intentionally declare a unique type signature to force\n     * a diagnostic should the application not cast the return value of dlfunc()\n     * appropriately.\n     */\n    struct __dlfunc_arg {\n        int     __dlfunc_dummy;\n    };\n\n    alias void function(__dlfunc_arg) dlfunc_t;\n\n    /*\n     * Structures, returned by the RTLD_DI_SERINFO dlinfo() request.\n     */\n    struct Dl_serpath {\n        char *          dls_name;       /* single search path entry */\n        uint            dls_flags;      /* path information */\n    };\n\n    struct Dl_serinfo {\n        size_t          dls_size;       /* total buffer size */\n        uint            dls_cnt;        /* number of path entries */\n        Dl_serpath[1]   dls_serpath;    /* there may be more than one */\n    };\n}\n\nprivate template __externC(RT, P...)\n{\n    alias extern(C) RT function(P) nothrow @nogc __externC;\n}\n\n/* XSI functions first. */\nstatic assert(is(typeof(&dlclose) == __externC!(int, void*)));\nstatic assert(is(typeof(&dlerror) == __externC!(char*)));\nstatic assert(is(typeof(&dlopen)  == __externC!(void*, const char*, int)));\nstatic assert(is(typeof(&dlsym)   == __externC!(void*, void*, const char*)));\n\nstatic if (__BSD_VISIBLE)\n{\n    void*    fdlopen(int, int);\n    int      dladdr(const(void)*, Dl_info*);\n    dlfunc_t dlfunc(void*, const(char)*);\n    int      dlinfo(void*, int, void*);\n    void     dllockinit(void* _context,\n        void* function(void* _context) _lock_create,\n        void  function(void* _lock)    _rlock_acquire,\n        void  function(void* _lock)    _wlock_acquire,\n        void  function(void* _lock)    _lock_release,\n        void  function(void* _lock)    _lock_destroy,\n        void  function(void* _context) _context_destroy);\n    void*    dlvsym(void*, const(char)*, const(char)*);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/runtime/druntime/src/core/sys/netbsd/dlfcn.d": "/**\n * D header file for NetBSD.\n *\n * Copyright: Copyright Martin Nowak 2012.\n * License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n * Authors:   Martin Nowak\n *\n * http://cvsweb.netbsd.org/bsdweb.cgi/~checkout~/src/include/dlfcn.h\n */\nmodule core.sys.netbsd.dlfcn;\n\npublic import core.sys.posix.dlfcn;\n\nversion (NetBSD):\nextern (C):\nnothrow:\n@nogc:\n\nenum __BSD_VISIBLE = true;\n\n/*\n * Modes and flags for dlopen().\n */\nstatic assert(RTLD_LAZY   == 1);\nstatic assert(RTLD_NOW    == 2);\nstatic assert(RTLD_GLOBAL == 0x100);\nstatic assert(RTLD_LOCAL  == 0x200);\n//enum RTLD_TRACE           =  0x200;\nenum RTLD_NODELETE        =  0x01000;\nenum RTLD_NOLOAD          =  0x02000;\n\n/*\n * Request arguments for dlinfo().\n */\nenum RTLD_DI_LINKMAP     = 3;    /* Obtain link map. */\nenum RTLD_DI_SERINFO     = 5;    /* Obtain search path info. */\nenum RTLD_DI_SERINFOSIZE = 6;    /*  ... query for required space. */\nenum RTLD_DI_ORIGIN      = 7;    /* Obtain object origin */\nenum RTLD_DI_MAX         = RTLD_DI_ORIGIN;\n\n/*\n * Special handle arguments for dlsym()/dlinfo().\n */\nenum RTLD_NEXT    = cast(void *)-1;    /* Search subsequent objects. */\nenum RTLD_DEFAULT = cast(void *)-2;    /* Use default search algorithm. */\nenum RTLD_SELF    = cast(void *)-3;    /* Search the caller itself. */\n\nstatic if (__BSD_VISIBLE)\n{\n    /*\n     * Structure filled in by dladdr().\n     */\n    struct Dl_info {\n        const(char)     *dli_fname;     /* Pathname of shared object. */\n        void            *dli_fbase;     /* Base address of shared object. */\n        const(char)     *dli_sname;     /* Name of nearest symbol. */\n        void            *dli_saddr;     /* Address of nearest symbol. */\n    };\n\n    /*-\n     * The actual type declared by this typedef is immaterial, provided that\n     * it is a function pointer.  Its purpose is to provide a return type for\n     * dlfunc() which can be cast to a function pointer type without depending\n     * on behavior undefined by the C standard, which might trigger a compiler\n     * diagnostic.  We intentionally declare a unique type signature to force\n     * a diagnostic should the application not cast the return value of dlfunc()\n     * appropriately.\n     */\n    struct __dlfunc_arg {\n        int     __dlfunc_dummy;\n    };\n\n    alias dlfunc_t = void function(__dlfunc_arg);\n\n    /*\n     * Structures, returned by the RTLD_DI_SERINFO dlinfo() request.\n     */\n    struct Dl_serpath {\n        char *          dls_name;       /* single search path entry */\n        uint            dls_flags;      /* path information */\n    };\n\n    struct Dl_serinfo {\n        size_t          dls_size;       /* total buffer size */\n        uint            dls_cnt;        /* number of path entries */\n        Dl_serpath[1]   dls_serpath;    /* there may be more than one */\n    };\n}\n\nprivate template __externC(RT, P...)\n{\n    alias __externC = extern(C) RT function(P) nothrow @nogc;\n}\n\n/* XSI functions first. */\nstatic assert(is(typeof(&dlclose) == __externC!(int, void*)));\nstatic assert(is(typeof(&dlerror) == __externC!(char*)));\nstatic assert(is(typeof(&dlopen)  == __externC!(void*, const char*, int)));\nstatic assert(is(typeof(&dlsym)   == __externC!(void*, void*, const char*)));\n\nstatic if (__BSD_VISIBLE)\n{\n    //void*    fdlopen(int, int);\n    int      dladdr(const(void)*, Dl_info*);\n    //dlfunc_t dlfunc(void*, const(char)*);\n    //int      dlinfo(void*, int, void*);\n    /+void     dllockinit(void* _context,\n        void* function(void* _context) _lock_create,\n        void  function(void* _lock)    _rlock_acquire,\n        void  function(void* _lock)    _wlock_acquire,\n        void  function(void* _lock)    _lock_release,\n        void  function(void* _lock)    _lock_destroy,\n        void  function(void* _context) _context_destroy);+/\n    void*    dlvsym(void*, const(char)*, const(char)*);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/runtime/druntime/test/shared/src/loadDR.c": "#include <stdlib.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <assert.h>\n\nint main(int argc, char* argv[])\n{\n    if (argc != 2)\n        return EXIT_FAILURE;\n    void *h = dlopen(argv[1], RTLD_LAZY); // load druntime\n    assert(h != NULL);\n\n    int (*rt_init)(void) = dlsym(h, \"rt_init\");\n    int (*rt_term)(void) = dlsym(h, \"rt_term\");\n    void* (*rt_loadLibrary)(const char*) = dlsym(h, \"rt_loadLibrary\");\n    int (*rt_unloadLibrary)(void*) = dlsym(h, \"rt_unloadLibrary\");\n\n    int res = EXIT_FAILURE;\n    if (!rt_init()) goto Lexit;\n\n    const size_t pathlen = strrchr(argv[0], '/') - argv[0] + 1;\n    char *name = malloc(pathlen + sizeof(\"lib.so\"));\n    memcpy(name, argv[0], pathlen);\n    memcpy(name+pathlen, \"lib.so\", sizeof(\"lib.so\"));\n\n    void *dlib = rt_loadLibrary(name);\n    free(name);\n    assert(dlib);\n\n    int (*runTests)(void) = dlsym(dlib, \"runTests\");\n    assert(runTests());\n    assert(rt_unloadLibrary(dlib));\n\n    if (rt_term()) res = EXIT_SUCCESS;\n\nLexit:\n    assert(dlclose(h) == 0);\n    return res;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/runtime/druntime/test/shared/src/host.c": "#include <stdlib.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <assert.h>\n\nint main(int argc, char* argv[])\n{\n#if defined(__FreeBSD__)\n    // workaround for Bugzilla 14824\n    void *druntime = dlopen(argv[1], RTLD_LAZY); // load druntime\n    assert(druntime);\n#endif\n\n    const size_t pathlen = strrchr(argv[0], '/') - argv[0] + 1;\n    char *name = malloc(pathlen + sizeof(\"plugin1.so\"));\n    memcpy(name, argv[0], pathlen);\n    memcpy(name+pathlen, \"plugin1.so\", sizeof(\"plugin1.so\"));\n\n    void* plugin1 = dlopen(name, RTLD_LAZY);\n    name[pathlen + sizeof(\"plugin1.so\") - 5] = '2';\n    void* plugin2 = dlopen(name, RTLD_LAZY);\n\n    int (*plugin1_init)() = dlsym(plugin1, \"plugin_init\");\n    int (*plugin1_term)() = dlsym(plugin1, \"plugin_term\");\n    int (*runTests1)() = dlsym(plugin1, \"runTests\");\n    int (*plugin2_init)() = dlsym(plugin2, \"plugin_init\");\n    int (*plugin2_term)() = dlsym(plugin2, \"plugin_term\");\n    int (*runTests2)() = dlsym(plugin2, \"runTests\");\n    assert(plugin1_init());\n    assert(runTests1());\n    assert(plugin2_init());\n    assert(runTests2());\n\n    assert(plugin1_term());\n    assert(dlclose(plugin1) == 0);\n    assert(runTests2());\n\n    name[pathlen + sizeof(\"plugin1.so\") - 5] = '1';\n    plugin1 = dlopen(name, RTLD_LAZY);\n    plugin1_init = dlsym(plugin1, \"plugin_init\");\n    plugin1_term = dlsym(plugin1, \"plugin_term\");\n    runTests1 = dlsym(plugin1, \"runTests\");\n    assert(plugin1_init());\n    assert(runTests1());\n    assert(runTests2());\n\n    assert(plugin2_term());\n    assert(dlclose(plugin2) == 0);\n    assert(runTests1());\n\n    assert(plugin1_term());\n    assert(dlclose(plugin1) == 0);\n\n    free(name);\n\n#if defined(__FreeBSD__)\n    dlclose(druntime);\n#endif\n    return EXIT_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/runtime/druntime/test/shared/src/linkDR.c": "#include <stdlib.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <assert.h>\n\nextern void* rt_loadLibrary(const char*);\nextern int rt_unloadLibrary(void*);\nextern int rt_init(void);\nextern int rt_term(void);\n\nint main(int argc, char* argv[])\n{\n    if (!rt_init()) return EXIT_FAILURE;\n    const size_t pathlen = strrchr(argv[0], '/') - argv[0] + 1;\n    char *name = malloc(pathlen + sizeof(\"lib.so\"));\n    memcpy(name, argv[0], pathlen);\n    memcpy(name+pathlen, \"lib.so\", sizeof(\"lib.so\"));\n\n    void *dlib = rt_loadLibrary(name);\n    free(name);\n    assert(dlib);\n\n    int (*runTests)(void) = dlsym(dlib, \"runTests\");\n    assert(runTests());\n    assert(rt_unloadLibrary(dlib));\n    if (!rt_term()) return EXIT_FAILURE;\n    return EXIT_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/runtime/druntime/test/shared/src/load_13414.d": "import core.runtime, core.atomic, core.sys.posix.dlfcn;\n\nshared uint tlsDtor, dtor;\nvoid staticDtorHook() { atomicOp!\"+=\"(tlsDtor, 1); }\nvoid sharedStaticDtorHook() { atomicOp!\"+=\"(dtor, 1); }\n\nvoid runTest(string name)\n{\n    auto h = Runtime.loadLibrary(name);\n    assert(h !is null);\n\n    *cast(void function()*).dlsym(h, \"_D9lib_1341414staticDtorHookOPFZv\") = &staticDtorHook;\n    *cast(void function()*).dlsym(h, \"_D9lib_1341420sharedStaticDtorHookOPFZv\") = &sharedStaticDtorHook;\n\n    Runtime.unloadLibrary(h);\n    assert(tlsDtor == 1);\n    assert(dtor == 1);\n}\n\nvoid main(string[] args)\n{\n    auto name = args[0];\n    assert(name[$-\"load_13414\".length-1 .. $] == \"/load_13414\");\n    name = name[0 .. $-\"load_13414\".length] ~ \"lib_13414.so\";\n\n    runTest(name);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/runtime/druntime/test/shared/src/finalize.d": "import core.runtime, core.stdc.stdio, core.thread, core.sys.posix.dlfcn;\n\nvoid runTest()\n{\n    Object obj;\n    obj = Object.factory(\"lib.MyFinalizer\");\n    assert(obj.toString() == \"lib.MyFinalizer\");\n    obj = Object.factory(\"lib.MyFinalizerBig\");\n    assert(obj.toString() == \"lib.MyFinalizerBig\");\n}\n\nclass NoFinalize\n{\n    size_t _finalizeCounter;\n\n    ~this()\n    {\n        ++_finalizeCounter;\n    }\n}\n\nclass NoFinalizeBig : NoFinalize\n{\n    ubyte[4096] _big = void;\n}\n\nextern (C) alias SetFinalizeCounter = void function(shared(size_t*));\n\nvoid main(string[] args)\n{\n    auto name = args[0];\n    assert(name[$-9 .. $] == \"/finalize\");\n    name = name[0 .. $-8] ~ \"lib.so\";\n\n    auto h = Runtime.loadLibrary(name);\n    assert(h !is null);\n\n    auto nf1 = new NoFinalize;\n    auto nf2 = new NoFinalizeBig;\n\n    shared size_t finalizeCounter;\n    auto setFinalizeCounter = cast(SetFinalizeCounter)dlsym(h, \"setFinalizeCounter\");\n    setFinalizeCounter(&finalizeCounter);\n\n    runTest();\n    auto thr = new Thread(&runTest);\n    thr.start();\n    thr.join();\n\n    auto r = Runtime.unloadLibrary(h);\n    if (!r)\n        assert(0);\n    if (finalizeCounter != 4)\n        assert(0);\n    if (nf1._finalizeCounter)\n        assert(0);\n    if (nf2._finalizeCounter)\n        assert(0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/runtime/druntime/test/shared/src/libloaddep.d": "import core.runtime, core.sys.posix.dlfcn;\n\nextern(C) alias RunTests = int function();\n\nextern(C) int runDepTests(const char* name)\n{\n    auto h = rt_loadLibrary(name);\n    if (h is null) return false;\n    auto runTests = cast(RunTests).dlsym(h, \"runTests\");\n    assert(runTests !is null);\n    if (!runTests()) return false;\n    return rt_unloadLibrary(h);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/runtime/druntime/test/shared/src/load_linkdep.d": "import core.runtime, core.sys.posix.dlfcn;\n\nextern(C) alias RunDepTests = int function();\n\nvoid main(string[] args)\n{\n    auto name = args[0];\n    assert(name[$-13 .. $] == \"/load_linkdep\");\n    name = name[0 .. $-12] ~ \"liblinkdep.so\";\n\n    auto h = Runtime.loadLibrary(name);\n    assert(h);\n    auto runDepTests = cast(RunDepTests)dlsym(h, \"runDepTests\");\n    assert(runDepTests());\n    assert(Runtime.unloadLibrary(h));\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/runtime/druntime/test/shared/src/load.d": "import core.runtime, core.stdc.stdio, core.thread;\n\nversion (linux) import core.sys.linux.dlfcn;\nelse version (FreeBSD) import core.sys.freebsd.dlfcn;\nelse version (OSX) import core.sys.osx.dlfcn;\nelse version (NetBSD) import core.sys.netbsd.dlfcn;\nelse static assert(0, \"unimplemented\");\n\nvoid loadSym(T)(void* handle, ref T val, const char* mangle)\n{\n    val = cast(T).dlsym(handle, mangle);\n}\n\nvoid* openLib(string s)\n{\n    auto h = Runtime.loadLibrary(s);\n    assert(h !is null);\n\n    loadSym(h, libThrowException, \"_D3lib14throwExceptionFZv\");\n    loadSym(h, libCollectException, \"_D3lib16collectExceptionFDFZvZC9Exception\");\n\n    loadSym(h, libAlloc, \"_D3lib5allocFZv\");\n    loadSym(h, libTlsAlloc, \"_D3lib9tls_allocFZv\");\n    loadSym(h, libAccess, \"_D3lib6accessFZv\");\n    loadSym(h, libTlsAccess, \"_D3lib10tls_accessFZv\");\n    loadSym(h, libFree, \"_D3lib4freeFZv\");\n    loadSym(h, libTlsFree, \"_D3lib8tls_freeFZv\");\n\n    loadSym(h, libSharedStaticCtor, \"_D3lib18shared_static_ctorOk\");\n    loadSym(h, libSharedStaticDtor, \"_D3lib18shared_static_dtorOk\");\n    loadSym(h, libStaticCtor, \"_D3lib11static_ctorOk\");\n    loadSym(h, libStaticDtor, \"_D3lib11static_dtorOk\");\n\n    return h;\n}\n\nvoid closeLib(void* h)\n{\n    Runtime.unloadLibrary(h);\n}\n\n__gshared\n{\n    void function() libThrowException;\n    Exception function(void delegate()) libCollectException;\n\n    void function() libAlloc;\n    void function() libTlsAlloc;\n    void function() libAccess;\n    void function() libTlsAccess;\n    void function() libFree;\n    void function() libTlsFree;\n\n    shared uint* libSharedStaticCtor;\n    shared uint* libSharedStaticDtor;\n    shared uint* libStaticCtor;\n    shared uint* libStaticDtor;\n}\n\nvoid testEH()\n{\n    bool passed;\n    try\n        libThrowException();\n    catch (Exception e)\n        passed = true;\n    assert(passed); passed = false;\n\n    assert(libCollectException({throw new Exception(null);}) !is null);\n    assert(libCollectException({libThrowException();}) !is null);\n}\n\nvoid testGC()\n{\n    import core.memory;\n    libAlloc();\n    libTlsAlloc();\n    libAccess();\n    libTlsAccess();\n    GC.collect();\n    libTlsAccess();\n    libAccess();\n    libTlsFree();\n    libFree();\n}\n\nvoid testInit()\n{\n\n    assert(*libStaticCtor == 1);\n    assert(*libStaticDtor == 0);\n    static void run()\n    {\n        assert(*libSharedStaticCtor == 1);\n        assert(*libSharedStaticDtor == 0);\n        assert(*libStaticCtor == 2);\n        assert(*libStaticDtor == 0);\n    }\n    auto thr = new Thread(&run);\n    thr.start();\n    thr.join();\n    assert(*libSharedStaticCtor == 1);\n    assert(*libSharedStaticDtor == 0);\n    assert(*libStaticCtor == 2);\n    assert(*libStaticDtor == 1);\n}\n\nconst(ModuleInfo)* findModuleInfo(string name)\n{\n    foreach (m; ModuleInfo)\n        if (m.name == name) return m;\n    return null;\n}\n\nvoid runTests(string libName)\n{\n    assert(findModuleInfo(\"lib\") is null);\n    auto handle = openLib(libName);\n    assert(findModuleInfo(\"lib\") !is null);\n\n    testEH();\n    testGC();\n    testInit();\n\n    closeLib(handle);\n    assert(findModuleInfo(\"lib\") is null);\n}\n\nvoid main(string[] args)\n{\n    auto name = args[0];\n    assert(name[$-5 .. $] == \"/load\");\n    name = name[0 .. $-4] ~ \"lib.so\";\n\n    runTests(name);\n\n    // lib is no longer resident\n    name ~= '\\0';\n    assert(.dlopen(name.ptr, RTLD_LAZY | RTLD_NOLOAD) is null);\n    name = name[0 .. $-1];\n\n    auto thr = new Thread({runTests(name);});\n    thr.start();\n    thr.join();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/runtime/druntime/test/shared/src/load_loaddep.d": "import core.runtime, core.sys.posix.dlfcn;\n\nextern(C) alias RunDepTests = int function(const char*);\n\nvoid main(string[] args)\n{\n    auto root = args[0][0..$-\"load_loaddep\".length];\n    auto libloaddep = root ~ \"libloaddep.so\";\n    auto h = Runtime.loadLibrary(libloaddep);\n    auto runDepTests = cast(RunDepTests)dlsym(h, \"runDepTests\");\n    assert(runDepTests((root ~ \"lib.so\\0\").ptr));\n    assert(Runtime.unloadLibrary(h));\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/tests/d2/dmd-testsuite/runnable/helloUTF16.d",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/tests/d2/dmd-testsuite/runnable/testUTF32.d",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/tests/d2/dmd-testsuite/runnable/helloUTF16BE.d",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/tests/d2/dmd-testsuite/fail_compilation/fail6458.d",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/gen/binops.h",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/gen/trycatchfinally.h",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/gen/abi-ppc64le.h",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/gen/abi-aarch64.h",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/gen/trycatchfinally.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/gen/ms-cxx-helper.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/gen/ldctraits.h",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/gen/ctfloat.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/gen/ms-cxx-helper.h",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/gen/abi-mips64.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/gen/abi-ppc.h",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/gen/abi-mips64.h",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/runtime/druntime/src/rt/minit.obj",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/driver/archiver.h",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/driver/linker-gcc.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-ldc-1.3.0-y3lkhm7cgk535umq3jxbfw3d74km63iz/spack-src/driver/linker-msvc.cpp"
    ],
    "total_files": 3909
}