{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-umoci-0.4.1-tn3pqddju56yubkedof6u2hatxtyfvqa/spack-src/vendor/golang.org/x/crypto/ssh/test/sshd_test_pw.c": "// Copyright 2017 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// sshd_test_pw.c\n// Wrapper to inject test password data for sshd PAM authentication\n//\n// This wrapper implements custom versions of getpwnam, getpwnam_r,\n// getspnam and getspnam_r. These functions first call their real\n// libc versions, then check if the requested user matches test user\n// specified in env variable TEST_USER and if so replace the password\n// with crypted() value of TEST_PASSWD env variable.\n//\n// Compile:\n// gcc -Wall -shared -o sshd_test_pw.so -fPIC sshd_test_pw.c\n//\n// Compile with debug:\n// gcc -DVERBOSE -Wall -shared -o sshd_test_pw.so -fPIC sshd_test_pw.c\n//\n// Run sshd:\n// LD_PRELOAD=\"sshd_test_pw.so\" TEST_USER=\"...\" TEST_PASSWD=\"...\" sshd ...\n\n// +build ignore\n\n#define _GNU_SOURCE\n#include <string.h>\n#include <pwd.h>\n#include <shadow.h>\n#include <dlfcn.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\n#ifdef VERBOSE\n#define DEBUG(X...) fprintf(stderr, X)\n#else\n#define DEBUG(X...) while (0) { }\n#endif\n\n/* crypt() password */\nstatic char *\npwhash(char *passwd) {\n  return strdup(crypt(passwd, \"$6$\"));\n}\n\n/* Pointers to real functions in libc */\nstatic struct passwd * (*real_getpwnam)(const char *) = NULL;\nstatic int (*real_getpwnam_r)(const char *, struct passwd *, char *, size_t, struct passwd **) = NULL;\nstatic struct spwd * (*real_getspnam)(const char *) = NULL;\nstatic int (*real_getspnam_r)(const char *, struct spwd *, char *, size_t, struct spwd **) = NULL;\n\n/* Cached test user and test password */\nstatic char *test_user = NULL;\nstatic char *test_passwd_hash = NULL;\n\nstatic void\ninit(void) {\n  /* Fetch real libc function pointers */\n  real_getpwnam = dlsym(RTLD_NEXT, \"getpwnam\");\n  real_getpwnam_r = dlsym(RTLD_NEXT, \"getpwnam_r\");\n  real_getspnam = dlsym(RTLD_NEXT, \"getspnam\");\n  real_getspnam_r = dlsym(RTLD_NEXT, \"getspnam_r\");\n  \n  /* abort if env variables are not defined */\n  if (getenv(\"TEST_USER\") == NULL || getenv(\"TEST_PASSWD\") == NULL) {\n    fprintf(stderr, \"env variables TEST_USER and TEST_PASSWD are missing\\n\");\n    abort();\n  }\n\n  /* Fetch test user and test password from env */\n  test_user = strdup(getenv(\"TEST_USER\"));\n  test_passwd_hash = pwhash(getenv(\"TEST_PASSWD\"));\n\n  DEBUG(\"sshd_test_pw init():\\n\");\n  DEBUG(\"\\treal_getpwnam: %p\\n\", real_getpwnam);\n  DEBUG(\"\\treal_getpwnam_r: %p\\n\", real_getpwnam_r);\n  DEBUG(\"\\treal_getspnam: %p\\n\", real_getspnam);\n  DEBUG(\"\\treal_getspnam_r: %p\\n\", real_getspnam_r);\n  DEBUG(\"\\tTEST_USER: '%s'\\n\", test_user);\n  DEBUG(\"\\tTEST_PASSWD: '%s'\\n\", getenv(\"TEST_PASSWD\"));\n  DEBUG(\"\\tTEST_PASSWD_HASH: '%s'\\n\", test_passwd_hash);\n}\n\nstatic int\nis_test_user(const char *name) {\n  if (test_user != NULL && strcmp(test_user, name) == 0)\n    return 1;\n  return 0;\n}\n\n/* getpwnam */\n\nstruct passwd *\ngetpwnam(const char *name) {\n  struct passwd *pw;\n\n  DEBUG(\"sshd_test_pw getpwnam(%s)\\n\", name);\n  \n  if (real_getpwnam == NULL)\n    init();\n  if ((pw = real_getpwnam(name)) == NULL)\n    return NULL;\n\n  if (is_test_user(name))\n    pw->pw_passwd = strdup(test_passwd_hash);\n      \n  return pw;\n}\n\n/* getpwnam_r */\n\nint\ngetpwnam_r(const char *name,\n\t   struct passwd *pwd,\n\t   char *buf,\n\t   size_t buflen,\n\t   struct passwd **result) {\n  int r;\n\n  DEBUG(\"sshd_test_pw getpwnam_r(%s)\\n\", name);\n  \n  if (real_getpwnam_r == NULL)\n    init();\n  if ((r = real_getpwnam_r(name, pwd, buf, buflen, result)) != 0 || *result == NULL)\n    return r;\n\n  if (is_test_user(name))\n    pwd->pw_passwd = strdup(test_passwd_hash);\n  \n  return 0;\n}\n\n/* getspnam */\n\nstruct spwd *\ngetspnam(const char *name) {\n  struct spwd *sp;\n\n  DEBUG(\"sshd_test_pw getspnam(%s)\\n\", name);\n  \n  if (real_getspnam == NULL)\n    init();\n  if ((sp = real_getspnam(name)) == NULL)\n    return NULL;\n\n  if (is_test_user(name))\n    sp->sp_pwdp = strdup(test_passwd_hash);\n  \n  return sp;\n}\n\n/* getspnam_r */\n\nint\ngetspnam_r(const char *name,\n\t   struct spwd *spbuf,\n\t   char *buf,\n\t   size_t buflen,\n\t   struct spwd **spbufp) {\n  int r;\n\n  DEBUG(\"sshd_test_pw getspnam_r(%s)\\n\", name);\n  \n  if (real_getspnam_r == NULL)\n    init();\n  if ((r = real_getspnam_r(name, spbuf, buf, buflen, spbufp)) != 0)\n    return r;\n\n  if (is_test_user(name))\n    spbuf->sp_pwdp = strdup(test_passwd_hash);\n  \n  return r;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-umoci-0.4.1-tn3pqddju56yubkedof6u2hatxtyfvqa/spack-src/contrib/logo/umoci-black.png",
        "/tmp/vanessa/spack-stage/spack-stage-umoci-0.4.1-tn3pqddju56yubkedof6u2hatxtyfvqa/spack-src/contrib/logo/umoci-white.png",
        "/tmp/vanessa/spack-stage/spack-stage-umoci-0.4.1-tn3pqddju56yubkedof6u2hatxtyfvqa/spack-src/contrib/logo/umoci.sketch"
    ],
    "total_files": 678
}