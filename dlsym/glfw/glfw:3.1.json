{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1-dqlqhkfisba43sqhbv762wxt7uzpn5le/spack-src/src/x11_init.c": "//========================================================================\n// GLFW 3.1 X11 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <X11/Xresource.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <locale.h>\n\n\n// Translate an X11 key code to a GLFW key code.\n//\nstatic int translateKey(int scancode)\n{\n    int keySym;\n\n    // Valid key code range is  [8,255], according to the Xlib manual\n    if (scancode < 8 || scancode > 255)\n        return GLFW_KEY_UNKNOWN;\n\n    if (_glfw.x11.xkb.available)\n    {\n        // Try secondary keysym, for numeric keypad keys\n        // Note: This way we always force \"NumLock = ON\", which is intentional\n        // since the returned key code should correspond to a physical\n        // location.\n        keySym = XkbKeycodeToKeysym(_glfw.x11.display, scancode, 0, 1);\n        switch (keySym)\n        {\n            case XK_KP_0:           return GLFW_KEY_KP_0;\n            case XK_KP_1:           return GLFW_KEY_KP_1;\n            case XK_KP_2:           return GLFW_KEY_KP_2;\n            case XK_KP_3:           return GLFW_KEY_KP_3;\n            case XK_KP_4:           return GLFW_KEY_KP_4;\n            case XK_KP_5:           return GLFW_KEY_KP_5;\n            case XK_KP_6:           return GLFW_KEY_KP_6;\n            case XK_KP_7:           return GLFW_KEY_KP_7;\n            case XK_KP_8:           return GLFW_KEY_KP_8;\n            case XK_KP_9:           return GLFW_KEY_KP_9;\n            case XK_KP_Separator:\n            case XK_KP_Decimal:     return GLFW_KEY_KP_DECIMAL;\n            case XK_KP_Equal:       return GLFW_KEY_KP_EQUAL;\n            case XK_KP_Enter:       return GLFW_KEY_KP_ENTER;\n            default:                break;\n        }\n\n        // Now try primary keysym for function keys (non-printable keys). These\n        // should not be layout dependent (i.e. US layout and international\n        // layouts should give the same result).\n        keySym = XkbKeycodeToKeysym(_glfw.x11.display, scancode, 0, 0);\n    }\n    else\n    {\n        int dummy;\n        KeySym* keySyms;\n\n        keySyms = XGetKeyboardMapping(_glfw.x11.display, scancode, 1, &dummy);\n        keySym = keySyms[0];\n        XFree(keySyms);\n    }\n\n    switch (keySym)\n    {\n        case XK_Escape:         return GLFW_KEY_ESCAPE;\n        case XK_Tab:            return GLFW_KEY_TAB;\n        case XK_Shift_L:        return GLFW_KEY_LEFT_SHIFT;\n        case XK_Shift_R:        return GLFW_KEY_RIGHT_SHIFT;\n        case XK_Control_L:      return GLFW_KEY_LEFT_CONTROL;\n        case XK_Control_R:      return GLFW_KEY_RIGHT_CONTROL;\n        case XK_Meta_L:\n        case XK_Alt_L:          return GLFW_KEY_LEFT_ALT;\n        case XK_Mode_switch: // Mapped to Alt_R on many keyboards\n        case XK_ISO_Level3_Shift: // AltGr on at least some machines\n        case XK_Meta_R:\n        case XK_Alt_R:          return GLFW_KEY_RIGHT_ALT;\n        case XK_Super_L:        return GLFW_KEY_LEFT_SUPER;\n        case XK_Super_R:        return GLFW_KEY_RIGHT_SUPER;\n        case XK_Menu:           return GLFW_KEY_MENU;\n        case XK_Num_Lock:       return GLFW_KEY_NUM_LOCK;\n        case XK_Caps_Lock:      return GLFW_KEY_CAPS_LOCK;\n        case XK_Print:          return GLFW_KEY_PRINT_SCREEN;\n        case XK_Scroll_Lock:    return GLFW_KEY_SCROLL_LOCK;\n        case XK_Pause:          return GLFW_KEY_PAUSE;\n        case XK_Delete:         return GLFW_KEY_DELETE;\n        case XK_BackSpace:      return GLFW_KEY_BACKSPACE;\n        case XK_Return:         return GLFW_KEY_ENTER;\n        case XK_Home:           return GLFW_KEY_HOME;\n        case XK_End:            return GLFW_KEY_END;\n        case XK_Page_Up:        return GLFW_KEY_PAGE_UP;\n        case XK_Page_Down:      return GLFW_KEY_PAGE_DOWN;\n        case XK_Insert:         return GLFW_KEY_INSERT;\n        case XK_Left:           return GLFW_KEY_LEFT;\n        case XK_Right:          return GLFW_KEY_RIGHT;\n        case XK_Down:           return GLFW_KEY_DOWN;\n        case XK_Up:             return GLFW_KEY_UP;\n        case XK_F1:             return GLFW_KEY_F1;\n        case XK_F2:             return GLFW_KEY_F2;\n        case XK_F3:             return GLFW_KEY_F3;\n        case XK_F4:             return GLFW_KEY_F4;\n        case XK_F5:             return GLFW_KEY_F5;\n        case XK_F6:             return GLFW_KEY_F6;\n        case XK_F7:             return GLFW_KEY_F7;\n        case XK_F8:             return GLFW_KEY_F8;\n        case XK_F9:             return GLFW_KEY_F9;\n        case XK_F10:            return GLFW_KEY_F10;\n        case XK_F11:            return GLFW_KEY_F11;\n        case XK_F12:            return GLFW_KEY_F12;\n        case XK_F13:            return GLFW_KEY_F13;\n        case XK_F14:            return GLFW_KEY_F14;\n        case XK_F15:            return GLFW_KEY_F15;\n        case XK_F16:            return GLFW_KEY_F16;\n        case XK_F17:            return GLFW_KEY_F17;\n        case XK_F18:            return GLFW_KEY_F18;\n        case XK_F19:            return GLFW_KEY_F19;\n        case XK_F20:            return GLFW_KEY_F20;\n        case XK_F21:            return GLFW_KEY_F21;\n        case XK_F22:            return GLFW_KEY_F22;\n        case XK_F23:            return GLFW_KEY_F23;\n        case XK_F24:            return GLFW_KEY_F24;\n        case XK_F25:            return GLFW_KEY_F25;\n\n        // Numeric keypad\n        case XK_KP_Divide:      return GLFW_KEY_KP_DIVIDE;\n        case XK_KP_Multiply:    return GLFW_KEY_KP_MULTIPLY;\n        case XK_KP_Subtract:    return GLFW_KEY_KP_SUBTRACT;\n        case XK_KP_Add:         return GLFW_KEY_KP_ADD;\n\n        // These should have been detected in secondary keysym test above!\n        case XK_KP_Insert:      return GLFW_KEY_KP_0;\n        case XK_KP_End:         return GLFW_KEY_KP_1;\n        case XK_KP_Down:        return GLFW_KEY_KP_2;\n        case XK_KP_Page_Down:   return GLFW_KEY_KP_3;\n        case XK_KP_Left:        return GLFW_KEY_KP_4;\n        case XK_KP_Right:       return GLFW_KEY_KP_6;\n        case XK_KP_Home:        return GLFW_KEY_KP_7;\n        case XK_KP_Up:          return GLFW_KEY_KP_8;\n        case XK_KP_Page_Up:     return GLFW_KEY_KP_9;\n        case XK_KP_Delete:      return GLFW_KEY_KP_DECIMAL;\n        case XK_KP_Equal:       return GLFW_KEY_KP_EQUAL;\n        case XK_KP_Enter:       return GLFW_KEY_KP_ENTER;\n\n        // Last resort: Check for printable keys (should not happen if the XKB\n        // extension is available). This will give a layout dependent mapping\n        // (which is wrong, and we may miss some keys, especially on non-US\n        // keyboards), but it's better than nothing...\n        case XK_a:              return GLFW_KEY_A;\n        case XK_b:              return GLFW_KEY_B;\n        case XK_c:              return GLFW_KEY_C;\n        case XK_d:              return GLFW_KEY_D;\n        case XK_e:              return GLFW_KEY_E;\n        case XK_f:              return GLFW_KEY_F;\n        case XK_g:              return GLFW_KEY_G;\n        case XK_h:              return GLFW_KEY_H;\n        case XK_i:              return GLFW_KEY_I;\n        case XK_j:              return GLFW_KEY_J;\n        case XK_k:              return GLFW_KEY_K;\n        case XK_l:              return GLFW_KEY_L;\n        case XK_m:              return GLFW_KEY_M;\n        case XK_n:              return GLFW_KEY_N;\n        case XK_o:              return GLFW_KEY_O;\n        case XK_p:              return GLFW_KEY_P;\n        case XK_q:              return GLFW_KEY_Q;\n        case XK_r:              return GLFW_KEY_R;\n        case XK_s:              return GLFW_KEY_S;\n        case XK_t:              return GLFW_KEY_T;\n        case XK_u:              return GLFW_KEY_U;\n        case XK_v:              return GLFW_KEY_V;\n        case XK_w:              return GLFW_KEY_W;\n        case XK_x:              return GLFW_KEY_X;\n        case XK_y:              return GLFW_KEY_Y;\n        case XK_z:              return GLFW_KEY_Z;\n        case XK_1:              return GLFW_KEY_1;\n        case XK_2:              return GLFW_KEY_2;\n        case XK_3:              return GLFW_KEY_3;\n        case XK_4:              return GLFW_KEY_4;\n        case XK_5:              return GLFW_KEY_5;\n        case XK_6:              return GLFW_KEY_6;\n        case XK_7:              return GLFW_KEY_7;\n        case XK_8:              return GLFW_KEY_8;\n        case XK_9:              return GLFW_KEY_9;\n        case XK_0:              return GLFW_KEY_0;\n        case XK_space:          return GLFW_KEY_SPACE;\n        case XK_minus:          return GLFW_KEY_MINUS;\n        case XK_equal:          return GLFW_KEY_EQUAL;\n        case XK_bracketleft:    return GLFW_KEY_LEFT_BRACKET;\n        case XK_bracketright:   return GLFW_KEY_RIGHT_BRACKET;\n        case XK_backslash:      return GLFW_KEY_BACKSLASH;\n        case XK_semicolon:      return GLFW_KEY_SEMICOLON;\n        case XK_apostrophe:     return GLFW_KEY_APOSTROPHE;\n        case XK_grave:          return GLFW_KEY_GRAVE_ACCENT;\n        case XK_comma:          return GLFW_KEY_COMMA;\n        case XK_period:         return GLFW_KEY_PERIOD;\n        case XK_slash:          return GLFW_KEY_SLASH;\n        case XK_less:           return GLFW_KEY_WORLD_1; // At least in some layouts...\n        default:                break;\n    }\n\n    // No matching translation was found\n    return GLFW_KEY_UNKNOWN;\n}\n\n// Create key code translation tables\n//\nstatic void createKeyTables(void)\n{\n    int scancode, key;\n\n    memset(_glfw.x11.publicKeys, -1, sizeof(_glfw.x11.publicKeys));\n\n    if (_glfw.x11.xkb.available)\n    {\n        // Use XKB to determine physical key locations independently of the current\n        // keyboard layout\n\n        char name[XkbKeyNameLength + 1];\n        XkbDescPtr descr = XkbGetKeyboard(_glfw.x11.display,\n                                          XkbAllComponentsMask,\n                                          XkbUseCoreKbd);\n\n        // Find the X11 key code -> GLFW key code mapping\n        for (scancode = descr->min_key_code;  scancode <= descr->max_key_code;  scancode++)\n        {\n            memcpy(name, descr->names->keys[scancode].name, XkbKeyNameLength);\n            name[XkbKeyNameLength] = 0;\n\n            // Map the key name to a GLFW key code. Note: We only map printable\n            // keys here, and we use the US keyboard layout. The rest of the\n            // keys (function keys) are mapped using traditional KeySym\n            // translations.\n            if (strcmp(name, \"TLDE\") == 0) key = GLFW_KEY_GRAVE_ACCENT;\n            else if (strcmp(name, \"AE01\") == 0) key = GLFW_KEY_1;\n            else if (strcmp(name, \"AE02\") == 0) key = GLFW_KEY_2;\n            else if (strcmp(name, \"AE03\") == 0) key = GLFW_KEY_3;\n            else if (strcmp(name, \"AE04\") == 0) key = GLFW_KEY_4;\n            else if (strcmp(name, \"AE05\") == 0) key = GLFW_KEY_5;\n            else if (strcmp(name, \"AE06\") == 0) key = GLFW_KEY_6;\n            else if (strcmp(name, \"AE07\") == 0) key = GLFW_KEY_7;\n            else if (strcmp(name, \"AE08\") == 0) key = GLFW_KEY_8;\n            else if (strcmp(name, \"AE09\") == 0) key = GLFW_KEY_9;\n            else if (strcmp(name, \"AE10\") == 0) key = GLFW_KEY_0;\n            else if (strcmp(name, \"AE11\") == 0) key = GLFW_KEY_MINUS;\n            else if (strcmp(name, \"AE12\") == 0) key = GLFW_KEY_EQUAL;\n            else if (strcmp(name, \"AD01\") == 0) key = GLFW_KEY_Q;\n            else if (strcmp(name, \"AD02\") == 0) key = GLFW_KEY_W;\n            else if (strcmp(name, \"AD03\") == 0) key = GLFW_KEY_E;\n            else if (strcmp(name, \"AD04\") == 0) key = GLFW_KEY_R;\n            else if (strcmp(name, \"AD05\") == 0) key = GLFW_KEY_T;\n            else if (strcmp(name, \"AD06\") == 0) key = GLFW_KEY_Y;\n            else if (strcmp(name, \"AD07\") == 0) key = GLFW_KEY_U;\n            else if (strcmp(name, \"AD08\") == 0) key = GLFW_KEY_I;\n            else if (strcmp(name, \"AD09\") == 0) key = GLFW_KEY_O;\n            else if (strcmp(name, \"AD10\") == 0) key = GLFW_KEY_P;\n            else if (strcmp(name, \"AD11\") == 0) key = GLFW_KEY_LEFT_BRACKET;\n            else if (strcmp(name, \"AD12\") == 0) key = GLFW_KEY_RIGHT_BRACKET;\n            else if (strcmp(name, \"AC01\") == 0) key = GLFW_KEY_A;\n            else if (strcmp(name, \"AC02\") == 0) key = GLFW_KEY_S;\n            else if (strcmp(name, \"AC03\") == 0) key = GLFW_KEY_D;\n            else if (strcmp(name, \"AC04\") == 0) key = GLFW_KEY_F;\n            else if (strcmp(name, \"AC05\") == 0) key = GLFW_KEY_G;\n            else if (strcmp(name, \"AC06\") == 0) key = GLFW_KEY_H;\n            else if (strcmp(name, \"AC07\") == 0) key = GLFW_KEY_J;\n            else if (strcmp(name, \"AC08\") == 0) key = GLFW_KEY_K;\n            else if (strcmp(name, \"AC09\") == 0) key = GLFW_KEY_L;\n            else if (strcmp(name, \"AC10\") == 0) key = GLFW_KEY_SEMICOLON;\n            else if (strcmp(name, \"AC11\") == 0) key = GLFW_KEY_APOSTROPHE;\n            else if (strcmp(name, \"AB01\") == 0) key = GLFW_KEY_Z;\n            else if (strcmp(name, \"AB02\") == 0) key = GLFW_KEY_X;\n            else if (strcmp(name, \"AB03\") == 0) key = GLFW_KEY_C;\n            else if (strcmp(name, \"AB04\") == 0) key = GLFW_KEY_V;\n            else if (strcmp(name, \"AB05\") == 0) key = GLFW_KEY_B;\n            else if (strcmp(name, \"AB06\") == 0) key = GLFW_KEY_N;\n            else if (strcmp(name, \"AB07\") == 0) key = GLFW_KEY_M;\n            else if (strcmp(name, \"AB08\") == 0) key = GLFW_KEY_COMMA;\n            else if (strcmp(name, \"AB09\") == 0) key = GLFW_KEY_PERIOD;\n            else if (strcmp(name, \"AB10\") == 0) key = GLFW_KEY_SLASH;\n            else if (strcmp(name, \"BKSL\") == 0) key = GLFW_KEY_BACKSLASH;\n            else if (strcmp(name, \"LSGT\") == 0) key = GLFW_KEY_WORLD_1;\n            else key = GLFW_KEY_UNKNOWN;\n\n            if ((scancode >= 0) && (scancode < 256))\n                _glfw.x11.publicKeys[scancode] = key;\n        }\n\n        XkbFreeKeyboard(descr, 0, True);\n    }\n\n    // Translate the un-translated key codes using traditional X11 KeySym\n    // lookups\n    for (scancode = 0;  scancode < 256;  scancode++)\n    {\n        if (_glfw.x11.publicKeys[scancode] < 0)\n            _glfw.x11.publicKeys[scancode] = translateKey(scancode);\n    }\n}\n\n// Check whether the IM has a usable style\n//\nstatic GLboolean hasUsableInputMethodStyle(void)\n{\n    unsigned int i;\n    GLboolean found = GL_FALSE;\n    XIMStyles* styles = NULL;\n\n    if (XGetIMValues(_glfw.x11.im, XNQueryInputStyle, &styles, NULL) != NULL)\n        return GL_FALSE;\n\n    for (i = 0;  i < styles->count_styles;  i++)\n    {\n        if (styles->supported_styles[i] == (XIMPreeditNothing | XIMStatusNothing))\n        {\n            found = GL_TRUE;\n            break;\n        }\n    }\n\n    XFree(styles);\n    return found;\n}\n\n// Check whether the specified atom is supported\n//\nstatic Atom getSupportedAtom(Atom* supportedAtoms,\n                             unsigned long atomCount,\n                             const char* atomName)\n{\n    Atom atom = XInternAtom(_glfw.x11.display, atomName, True);\n    if (atom != None)\n    {\n        unsigned long i;\n\n        for (i = 0;  i < atomCount;  i++)\n        {\n            if (supportedAtoms[i] == atom)\n                return atom;\n        }\n    }\n\n    return None;\n}\n\n// Check whether the running window manager is EWMH-compliant\n//\nstatic void detectEWMH(void)\n{\n    Window* windowFromRoot = NULL;\n    Window* windowFromChild = NULL;\n\n    // First we need a couple of atoms, which should already be there\n    Atom supportingWmCheck =\n        XInternAtom(_glfw.x11.display, \"_NET_SUPPORTING_WM_CHECK\", True);\n    Atom wmSupported =\n        XInternAtom(_glfw.x11.display, \"_NET_SUPPORTED\", True);\n    if (supportingWmCheck == None || wmSupported == None)\n        return;\n\n    // Then we look for the _NET_SUPPORTING_WM_CHECK property of the root window\n    if (_glfwGetWindowProperty(_glfw.x11.root,\n                               supportingWmCheck,\n                               XA_WINDOW,\n                               (unsigned char**) &windowFromRoot) != 1)\n    {\n        if (windowFromRoot)\n            XFree(windowFromRoot);\n        return;\n    }\n\n    _glfwGrabXErrorHandler();\n\n    // It should be the ID of a child window (of the root)\n    // Then we look for the same property on the child window\n    if (_glfwGetWindowProperty(*windowFromRoot,\n                               supportingWmCheck,\n                               XA_WINDOW,\n                               (unsigned char**) &windowFromChild) != 1)\n    {\n        XFree(windowFromRoot);\n        if (windowFromChild)\n            XFree(windowFromChild);\n        return;\n    }\n\n    _glfwReleaseXErrorHandler();\n\n    // It should be the ID of that same child window\n    if (*windowFromRoot != *windowFromChild)\n    {\n        XFree(windowFromRoot);\n        XFree(windowFromChild);\n        return;\n    }\n\n    XFree(windowFromRoot);\n    XFree(windowFromChild);\n\n    // We are now fairly sure that an EWMH-compliant window manager is running\n\n    Atom* supportedAtoms;\n    unsigned long atomCount;\n\n    // Now we need to check the _NET_SUPPORTED property of the root window\n    // It should be a list of supported WM protocol and state atoms\n    atomCount = _glfwGetWindowProperty(_glfw.x11.root,\n                                       wmSupported,\n                                       XA_ATOM,\n                                       (unsigned char**) &supportedAtoms);\n\n    // See which of the atoms we support that are supported by the WM\n    _glfw.x11.NET_WM_STATE =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE\");\n    _glfw.x11.NET_WM_STATE_ABOVE =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_ABOVE\");\n    _glfw.x11.NET_WM_STATE_FULLSCREEN =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_FULLSCREEN\");\n    _glfw.x11.NET_WM_FULLSCREEN_MONITORS =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_FULLSCREEN_MONITORS\");\n    _glfw.x11.NET_WM_NAME =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_NAME\");\n    _glfw.x11.NET_WM_ICON_NAME =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_ICON_NAME\");\n    _glfw.x11.NET_WM_PID =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_PID\");\n    _glfw.x11.NET_WM_PING =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_PING\");\n    _glfw.x11.NET_ACTIVE_WINDOW =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_ACTIVE_WINDOW\");\n    _glfw.x11.NET_FRAME_EXTENTS =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_FRAME_EXTENTS\");\n    _glfw.x11.NET_REQUEST_FRAME_EXTENTS =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_REQUEST_FRAME_EXTENTS\");\n    _glfw.x11.NET_WM_BYPASS_COMPOSITOR =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_BYPASS_COMPOSITOR\");\n\n    XFree(supportedAtoms);\n\n    _glfw.x11.hasEWMH = GL_TRUE;\n}\n\n// Initialize X11 display and look for supported X11 extensions\n//\nstatic GLboolean initExtensions(void)\n{\n    // Find or create window manager atoms\n    _glfw.x11.WM_PROTOCOLS = XInternAtom(_glfw.x11.display,\n                                         \"WM_PROTOCOLS\",\n                                         False);\n    _glfw.x11.WM_STATE = XInternAtom(_glfw.x11.display, \"WM_STATE\", False);\n    _glfw.x11.WM_DELETE_WINDOW = XInternAtom(_glfw.x11.display,\n                                             \"WM_DELETE_WINDOW\",\n                                             False);\n    _glfw.x11.MOTIF_WM_HINTS = XInternAtom(_glfw.x11.display,\n                                           \"_MOTIF_WM_HINTS\",\n                                           False);\n\n    // Check for XF86VidMode extension\n    _glfw.x11.vidmode.available =\n        XF86VidModeQueryExtension(_glfw.x11.display,\n                                  &_glfw.x11.vidmode.eventBase,\n                                  &_glfw.x11.vidmode.errorBase);\n\n    // Check for RandR extension\n    _glfw.x11.randr.available =\n        XRRQueryExtension(_glfw.x11.display,\n                          &_glfw.x11.randr.eventBase,\n                          &_glfw.x11.randr.errorBase);\n\n    if (_glfw.x11.randr.available)\n    {\n        XRRScreenResources* sr;\n\n        if (!XRRQueryVersion(_glfw.x11.display,\n                             &_glfw.x11.randr.versionMajor,\n                             &_glfw.x11.randr.versionMinor))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"X11: Failed to query RandR version\");\n            return GL_FALSE;\n        }\n\n        // The GLFW RandR path requires at least version 1.3\n        if (_glfw.x11.randr.versionMajor == 1 &&\n            _glfw.x11.randr.versionMinor < 3)\n        {\n            _glfw.x11.randr.available = GL_FALSE;\n        }\n\n        sr = XRRGetScreenResources(_glfw.x11.display, _glfw.x11.root);\n\n        if (!sr->ncrtc || !XRRGetCrtcGammaSize(_glfw.x11.display, sr->crtcs[0]))\n        {\n            // This is either a headless system or an older Nvidia binary driver\n            // with broken gamma support\n            // Flag it as useless and fall back to Xf86VidMode gamma, if\n            // available\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"X11: RandR gamma ramp support seems broken\");\n            _glfw.x11.randr.gammaBroken = GL_TRUE;\n        }\n\n        XRRFreeScreenResources(sr);\n    }\n\n    if (XineramaQueryExtension(_glfw.x11.display,\n                               &_glfw.x11.xinerama.versionMajor,\n                               &_glfw.x11.xinerama.versionMinor))\n    {\n        if (XineramaIsActive(_glfw.x11.display))\n            _glfw.x11.xinerama.available = GL_TRUE;\n    }\n\n    if (XQueryExtension(_glfw.x11.display,\n                        \"XInputExtension\",\n                        &_glfw.x11.xi.majorOpcode,\n                        &_glfw.x11.xi.eventBase,\n                        &_glfw.x11.xi.errorBase))\n    {\n        _glfw.x11.xi.versionMajor = 2;\n        _glfw.x11.xi.versionMinor = 0;\n\n        if (XIQueryVersion(_glfw.x11.display,\n                           &_glfw.x11.xi.versionMajor,\n                           &_glfw.x11.xi.versionMinor) != BadRequest)\n        {\n            _glfw.x11.xi.available = GL_TRUE;\n        }\n    }\n\n    // Check if Xkb is supported on this display\n    _glfw.x11.xkb.versionMajor = 1;\n    _glfw.x11.xkb.versionMinor = 0;\n    _glfw.x11.xkb.available =\n        XkbQueryExtension(_glfw.x11.display,\n                          &_glfw.x11.xkb.majorOpcode,\n                          &_glfw.x11.xkb.eventBase,\n                          &_glfw.x11.xkb.errorBase,\n                          &_glfw.x11.xkb.versionMajor,\n                          &_glfw.x11.xkb.versionMinor);\n\n    if (_glfw.x11.xkb.available)\n    {\n        Bool supported;\n\n        if (XkbSetDetectableAutoRepeat(_glfw.x11.display, True, &supported))\n        {\n            if (supported)\n                _glfw.x11.xkb.detectable = GL_TRUE;\n        }\n    }\n\n    // Update the key code LUT\n    // FIXME: We should listen to XkbMapNotify events to track changes to\n    // the keyboard mapping.\n    createKeyTables();\n\n    // Detect whether an EWMH-conformant window manager is running\n    detectEWMH();\n\n    // Find or create string format atoms\n    _glfw.x11._NULL = XInternAtom(_glfw.x11.display, \"NULL\", False);\n    _glfw.x11.UTF8_STRING =\n        XInternAtom(_glfw.x11.display, \"UTF8_STRING\", False);\n    _glfw.x11.COMPOUND_STRING =\n        XInternAtom(_glfw.x11.display, \"COMPOUND_STRING\", False);\n    _glfw.x11.ATOM_PAIR = XInternAtom(_glfw.x11.display, \"ATOM_PAIR\", False);\n\n    // Find or create selection property atom\n    _glfw.x11.GLFW_SELECTION =\n        XInternAtom(_glfw.x11.display, \"GLFW_SELECTION\", False);\n\n    // Find or create standard clipboard atoms\n    _glfw.x11.TARGETS = XInternAtom(_glfw.x11.display, \"TARGETS\", False);\n    _glfw.x11.MULTIPLE = XInternAtom(_glfw.x11.display, \"MULTIPLE\", False);\n    _glfw.x11.CLIPBOARD = XInternAtom(_glfw.x11.display, \"CLIPBOARD\", False);\n\n    // Find or create clipboard manager atoms\n    _glfw.x11.CLIPBOARD_MANAGER =\n        XInternAtom(_glfw.x11.display, \"CLIPBOARD_MANAGER\", False);\n    _glfw.x11.SAVE_TARGETS =\n        XInternAtom(_glfw.x11.display, \"SAVE_TARGETS\", False);\n\n    // Find Xdnd (drag and drop) atoms, if available\n    _glfw.x11.XdndAware = XInternAtom(_glfw.x11.display, \"XdndAware\", True);\n    _glfw.x11.XdndEnter = XInternAtom(_glfw.x11.display, \"XdndEnter\", True);\n    _glfw.x11.XdndPosition = XInternAtom(_glfw.x11.display, \"XdndPosition\", True);\n    _glfw.x11.XdndStatus = XInternAtom(_glfw.x11.display, \"XdndStatus\", True);\n    _glfw.x11.XdndActionCopy = XInternAtom(_glfw.x11.display, \"XdndActionCopy\", True);\n    _glfw.x11.XdndDrop = XInternAtom(_glfw.x11.display, \"XdndDrop\", True);\n    _glfw.x11.XdndLeave = XInternAtom(_glfw.x11.display, \"XdndLeave\", True);\n    _glfw.x11.XdndFinished = XInternAtom(_glfw.x11.display, \"XdndFinished\", True);\n    _glfw.x11.XdndSelection = XInternAtom(_glfw.x11.display, \"XdndSelection\", True);\n\n    return GL_TRUE;\n}\n\n// Create a blank cursor for hidden and disabled cursor modes\n//\nstatic Cursor createNULLCursor(void)\n{\n    unsigned char pixels[16 * 16 * 4];\n    GLFWimage image = { 16, 16, pixels };\n\n    memset(pixels, 0, sizeof(pixels));\n\n    return _glfwCreateCursor(&image, 0, 0);\n}\n\n// X error handler\n//\nstatic int errorHandler(Display *display, XErrorEvent* event)\n{\n    _glfw.x11.errorCode = event->error_code;\n    return 0;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Sets the X error handler callback\n//\nvoid _glfwGrabXErrorHandler(void)\n{\n    _glfw.x11.errorCode = Success;\n    XSetErrorHandler(errorHandler);\n}\n\n// Clears the X error handler callback\n//\nvoid _glfwReleaseXErrorHandler(void)\n{\n    // Synchronize to make sure all commands are processed\n    XSync(_glfw.x11.display, False);\n    XSetErrorHandler(NULL);\n}\n\n// Reports the specified error, appending information about the last X error\n//\nvoid _glfwInputXError(int error, const char* message)\n{\n    char buffer[8192];\n    XGetErrorText(_glfw.x11.display, _glfw.x11.errorCode,\n                  buffer, sizeof(buffer));\n\n    _glfwInputError(error, \"%s: %s\", message, buffer);\n}\n\n// Creates a native cursor object from the specified image and hotspot\n//\nCursor _glfwCreateCursor(const GLFWimage* image, int xhot, int yhot)\n{\n    int i;\n    Cursor cursor;\n\n    XcursorImage* native = XcursorImageCreate(image->width, image->height);\n    if (native == NULL)\n        return None;\n\n    native->xhot = xhot;\n    native->yhot = yhot;\n\n    unsigned char* source = (unsigned char*) image->pixels;\n    XcursorPixel* target = native->pixels;\n\n    for (i = 0;  i < image->width * image->height;  i++, target++, source += 4)\n    {\n        *target = (source[3] << 24) |\n                  (source[0] << 16) |\n                  (source[1] <<  8) |\n                   source[2];\n    }\n\n    cursor = XcursorImageLoadCursor(_glfw.x11.display, native);\n    XcursorImageDestroy(native);\n\n    return cursor;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nint _glfwPlatformInit(void)\n{\n    if (strcmp(setlocale(LC_CTYPE, NULL), \"C\") == 0)\n        setlocale(LC_CTYPE, \"\");\n\n    XInitThreads();\n\n    _glfw.x11.display = XOpenDisplay(NULL);\n    if (!_glfw.x11.display)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"X11: Failed to open X display\");\n        return GL_FALSE;\n    }\n\n    _glfw.x11.screen = DefaultScreen(_glfw.x11.display);\n    _glfw.x11.root = RootWindow(_glfw.x11.display, _glfw.x11.screen);\n    _glfw.x11.context = XUniqueContext();\n\n    if (!initExtensions())\n        return GL_FALSE;\n\n    _glfw.x11.cursor = createNULLCursor();\n\n    if (XSupportsLocale())\n    {\n        XSetLocaleModifiers(\"\");\n\n        _glfw.x11.im = XOpenIM(_glfw.x11.display, 0, 0, 0);\n        if (_glfw.x11.im)\n        {\n            if (!hasUsableInputMethodStyle())\n            {\n                XCloseIM(_glfw.x11.im);\n                _glfw.x11.im = NULL;\n            }\n        }\n    }\n\n    if (!_glfwInitContextAPI())\n        return GL_FALSE;\n\n    if (!_glfwInitJoysticks())\n        return GL_FALSE;\n\n    _glfwInitTimer();\n\n    return GL_TRUE;\n}\n\nvoid _glfwPlatformTerminate(void)\n{\n    if (_glfw.x11.cursor)\n    {\n        XFreeCursor(_glfw.x11.display, _glfw.x11.cursor);\n        _glfw.x11.cursor = (Cursor) 0;\n    }\n\n    free(_glfw.x11.clipboardString);\n\n    if (_glfw.x11.im)\n    {\n        XCloseIM(_glfw.x11.im);\n        _glfw.x11.im = NULL;\n    }\n\n    _glfwTerminateJoysticks();\n    _glfwTerminateContextAPI();\n\n    if (_glfw.x11.display)\n    {\n        XCloseDisplay(_glfw.x11.display);\n        _glfw.x11.display = NULL;\n    }\n}\n\nconst char* _glfwPlatformGetVersionString(void)\n{\n    const char* version = _GLFW_VERSION_NUMBER \" X11\"\n#if defined(_GLFW_GLX)\n        \" GLX\"\n#elif defined(_GLFW_EGL)\n        \" EGL\"\n#endif\n#if defined(_GLFW_HAS_GLXGETPROCADDRESS)\n        \" glXGetProcAddress\"\n#elif defined(_GLFW_HAS_GLXGETPROCADDRESSARB)\n        \" glXGetProcAddressARB\"\n#elif defined(_GLFW_HAS_GLXGETPROCADDRESSEXT)\n        \" glXGetProcAddressEXT\"\n#elif defined(_GLFW_DLOPEN_LIBGL)\n        \" dlsym(libGL)\"\n#endif\n#if defined(_POSIX_TIMERS) && defined(_POSIX_MONOTONIC_CLOCK)\n        \" clock_gettime\"\n#endif\n#if defined(__linux__)\n        \" /dev/js\"\n#endif\n#if defined(_GLFW_BUILD_DLL)\n        \" shared\"\n#endif\n        ;\n\n    return version;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1-dqlqhkfisba43sqhbv762wxt7uzpn5le/spack-src/src/glx_context.h": "//========================================================================\n// GLFW 3.1 GLX - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _glx_context_h_\n#define _glx_context_h_\n\n#define GLX_GLXEXT_LEGACY\n#include <GL/glx.h>\n\n// This path may need to be changed if you build GLFW using your own setup\n// We ship and use our own copy of glxext.h since GLFW uses fairly new\n// extensions and not all operating systems come with an up-to-date version\n#include \"../deps/GL/glxext.h\"\n\n// Do we have support for dlopen/dlsym?\n#if defined(_GLFW_HAS_DLOPEN)\n #include <dlfcn.h>\n#endif\n\n// We support four different ways for getting addresses for GL/GLX\n// extension functions: glXGetProcAddress, glXGetProcAddressARB,\n// glXGetProcAddressEXT, and dlsym\n#if defined(_GLFW_HAS_GLXGETPROCADDRESSARB)\n #define _glfw_glXGetProcAddress(x) glXGetProcAddressARB(x)\n#elif defined(_GLFW_HAS_GLXGETPROCADDRESS)\n #define _glfw_glXGetProcAddress(x) glXGetProcAddress(x)\n#elif defined(_GLFW_HAS_GLXGETPROCADDRESSEXT)\n #define _glfw_glXGetProcAddress(x) glXGetProcAddressEXT(x)\n#elif defined(_GLFW_HAS_DLOPEN)\n #define _glfw_glXGetProcAddress(x) dlsym(_glfw.glx.libGL, x)\n #define _GLFW_DLOPEN_LIBGL\n#else\n #error \"No OpenGL entry point retrieval mechanism was enabled\"\n#endif\n\n#define _GLFW_PLATFORM_FBCONFIG                 GLXFBConfig     glx\n#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextGLX glx\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryGLX glx\n\n#ifndef GLX_MESA_swap_control\ntypedef int (*PFNGLXSWAPINTERVALMESAPROC)(int);\n#endif\n\n\n// GLX-specific per-context data\n//\ntypedef struct _GLFWcontextGLX\n{\n    // Rendering context\n    GLXContext      context;\n    // Visual of selected GLXFBConfig\n    XVisualInfo*    visual;\n\n} _GLFWcontextGLX;\n\n\n// GLX-specific global data\n//\ntypedef struct _GLFWlibraryGLX\n{\n    int             versionMajor, versionMinor;\n    int             eventBase;\n    int             errorBase;\n\n    // GLX extensions\n    PFNGLXSWAPINTERVALSGIPROC             SwapIntervalSGI;\n    PFNGLXSWAPINTERVALEXTPROC             SwapIntervalEXT;\n    PFNGLXSWAPINTERVALMESAPROC            SwapIntervalMESA;\n    PFNGLXCREATECONTEXTATTRIBSARBPROC     CreateContextAttribsARB;\n    GLboolean       SGI_swap_control;\n    GLboolean       EXT_swap_control;\n    GLboolean       MESA_swap_control;\n    GLboolean       ARB_multisample;\n    GLboolean       ARB_framebuffer_sRGB;\n    GLboolean       ARB_create_context;\n    GLboolean       ARB_create_context_profile;\n    GLboolean       ARB_create_context_robustness;\n    GLboolean       EXT_create_context_es2_profile;\n    GLboolean       ARB_context_flush_control;\n\n#if defined(_GLFW_DLOPEN_LIBGL)\n    // dlopen handle for libGL.so (for glfwGetProcAddress)\n    void*           libGL;\n#endif\n\n} _GLFWlibraryGLX;\n\n\nint _glfwInitContextAPI(void);\nvoid _glfwTerminateContextAPI(void);\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWctxconfig* ctxconfig,\n                       const _GLFWfbconfig* fbconfig);\nvoid _glfwDestroyContext(_GLFWwindow* window);\n\n#endif // _glx_context_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1-dqlqhkfisba43sqhbv762wxt7uzpn5le/spack-src/src/egl_context.h": "//========================================================================\n// GLFW 3.1 EGL - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _egl_context_h_\n#define _egl_context_h_\n\n#include <EGL/egl.h>\n\n// This path may need to be changed if you build GLFW using your own setup\n// We ship and use our own copy of eglext.h since GLFW uses fairly new\n// extensions and not all operating systems come with an up-to-date version\n#include \"../deps/EGL/eglext.h\"\n\n// Do we have support for dlopen/dlsym?\n#if defined(_GLFW_HAS_DLOPEN)\n #include <dlfcn.h>\n#endif\n\n#define _GLFW_PLATFORM_FBCONFIG                 EGLConfig       egl\n#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextEGL egl\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryEGL egl\n\n\n// EGL-specific per-context data\n//\ntypedef struct _GLFWcontextEGL\n{\n   EGLConfig      config;\n   EGLContext     context;\n   EGLSurface     surface;\n\n#if defined(_GLFW_X11)\n   XVisualInfo*   visual;\n#endif\n\n} _GLFWcontextEGL;\n\n\n// EGL-specific global data\n//\ntypedef struct _GLFWlibraryEGL\n{\n    EGLDisplay      display;\n    EGLint          versionMajor, versionMinor;\n\n    GLboolean       KHR_create_context;\n\n} _GLFWlibraryEGL;\n\n\nint _glfwInitContextAPI(void);\nvoid _glfwTerminateContextAPI(void);\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWctxconfig* ctxconfig,\n                       const _GLFWfbconfig* fbconfig);\nvoid _glfwDestroyContext(_GLFWwindow* window);\nint _glfwAnalyzeContext(const _GLFWwindow* window,\n                        const _GLFWctxconfig* ctxconfig,\n                        const _GLFWfbconfig* fbconfig);\n\n#endif // _egl_context_h_\n"
    },
    "skipped": [],
    "total_files": 134
}