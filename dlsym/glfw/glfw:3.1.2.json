{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.2-x6c6y6bid7i3cuhrzcx25eivkoimm5dy/spack-src/src/egl_context.c": "//========================================================================\n// GLFW 3.1 EGL - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\n\n// Return a description of the specified EGL error\n//\nstatic const char* getErrorString(EGLint error)\n{\n    switch (error)\n    {\n        case EGL_SUCCESS:\n            return \"Success\";\n        case EGL_NOT_INITIALIZED:\n            return \"EGL is not or could not be initialized\";\n        case EGL_BAD_ACCESS:\n            return \"EGL cannot access a requested resource\";\n        case EGL_BAD_ALLOC:\n            return \"EGL failed to allocate resources for the requested operation\";\n        case EGL_BAD_ATTRIBUTE:\n            return \"An unrecognized attribute or attribute value was passed in the attribute list\";\n        case EGL_BAD_CONTEXT:\n            return \"An EGLContext argument does not name a valid EGL rendering context\";\n        case EGL_BAD_CONFIG:\n            return \"An EGLConfig argument does not name a valid EGL frame buffer configuration\";\n        case EGL_BAD_CURRENT_SURFACE:\n            return \"The current surface of the calling thread is a window, pixel buffer or pixmap that is no longer valid\";\n        case EGL_BAD_DISPLAY:\n            return \"An EGLDisplay argument does not name a valid EGL display connection\";\n        case EGL_BAD_SURFACE:\n            return \"An EGLSurface argument does not name a valid surface configured for GL rendering\";\n        case EGL_BAD_MATCH:\n            return \"Arguments are inconsistent\";\n        case EGL_BAD_PARAMETER:\n            return \"One or more argument values are invalid\";\n        case EGL_BAD_NATIVE_PIXMAP:\n            return \"A NativePixmapType argument does not refer to a valid native pixmap\";\n        case EGL_BAD_NATIVE_WINDOW:\n            return \"A NativeWindowType argument does not refer to a valid native window\";\n        case EGL_CONTEXT_LOST:\n            return \"The application must destroy all contexts and reinitialise\";\n    }\n\n    return \"UNKNOWN EGL ERROR\";\n}\n\n// Returns the specified attribute of the specified EGLConfig\n//\nstatic int getConfigAttrib(EGLConfig config, int attrib)\n{\n    int value;\n    _glfw_eglGetConfigAttrib(_glfw.egl.display, config, attrib, &value);\n    return value;\n}\n\n// Return a list of available and usable framebuffer configs\n//\nstatic GLboolean chooseFBConfigs(const _GLFWctxconfig* ctxconfig,\n                                 const _GLFWfbconfig* desired,\n                                 EGLConfig* result)\n{\n    EGLConfig* nativeConfigs;\n    _GLFWfbconfig* usableConfigs;\n    const _GLFWfbconfig* closest;\n    int i, nativeCount, usableCount;\n\n    _glfw_eglGetConfigs(_glfw.egl.display, NULL, 0, &nativeCount);\n    if (!nativeCount)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"EGL: No EGLConfigs returned\");\n        return GL_FALSE;\n    }\n\n    nativeConfigs = calloc(nativeCount, sizeof(EGLConfig));\n    _glfw_eglGetConfigs(_glfw.egl.display, nativeConfigs,\n                        nativeCount, &nativeCount);\n\n    usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));\n    usableCount = 0;\n\n    for (i = 0;  i < nativeCount;  i++)\n    {\n        const EGLConfig n = nativeConfigs[i];\n        _GLFWfbconfig* u = usableConfigs + usableCount;\n\n#if defined(_GLFW_X11)\n        // Only consider EGLConfigs with associated visuals\n        if (!getConfigAttrib(n, EGL_NATIVE_VISUAL_ID))\n            continue;\n#endif // _GLFW_X11\n\n        // Only consider RGB(A) EGLConfigs\n        if (!(getConfigAttrib(n, EGL_COLOR_BUFFER_TYPE) & EGL_RGB_BUFFER))\n            continue;\n\n        // Only consider window EGLConfigs\n        if (!(getConfigAttrib(n, EGL_SURFACE_TYPE) & EGL_WINDOW_BIT))\n            continue;\n\n        if (ctxconfig->api == GLFW_OPENGL_ES_API)\n        {\n            if (ctxconfig->major == 1)\n            {\n                if (!(getConfigAttrib(n, EGL_RENDERABLE_TYPE) & EGL_OPENGL_ES_BIT))\n                    continue;\n            }\n            else\n            {\n                if (!(getConfigAttrib(n, EGL_RENDERABLE_TYPE) & EGL_OPENGL_ES2_BIT))\n                    continue;\n            }\n        }\n        else if (ctxconfig->api == GLFW_OPENGL_API)\n        {\n            if (!(getConfigAttrib(n, EGL_RENDERABLE_TYPE) & EGL_OPENGL_BIT))\n                continue;\n        }\n\n        u->redBits = getConfigAttrib(n, EGL_RED_SIZE);\n        u->greenBits = getConfigAttrib(n, EGL_GREEN_SIZE);\n        u->blueBits = getConfigAttrib(n, EGL_BLUE_SIZE);\n\n        u->alphaBits = getConfigAttrib(n, EGL_ALPHA_SIZE);\n        u->depthBits = getConfigAttrib(n, EGL_DEPTH_SIZE);\n        u->stencilBits = getConfigAttrib(n, EGL_STENCIL_SIZE);\n\n        u->samples = getConfigAttrib(n, EGL_SAMPLES);\n        u->doublebuffer = GL_TRUE;\n\n        u->egl = n;\n        usableCount++;\n    }\n\n    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);\n    if (closest)\n        *result = closest->egl;\n\n    free(nativeConfigs);\n    free(usableConfigs);\n\n    return closest ? GL_TRUE : GL_FALSE;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Initialize EGL\n//\nint _glfwInitContextAPI(void)\n{\n    int i;\n    const char* sonames[] =\n    {\n#if defined(_GLFW_WIN32)\n        \"libEGL.dll\",\n        \"EGL.dll\",\n#elif defined(_GLFW_COCOA)\n        \"libEGL.dylib\",\n#else\n        \"libEGL.so.1\",\n#endif\n        NULL\n    };\n\n    if (!_glfwCreateContextTLS())\n        return GL_FALSE;\n\n    for (i = 0;  sonames[i];  i++)\n    {\n        _glfw.egl.handle = _glfw_dlopen(sonames[i]);\n        if (_glfw.egl.handle)\n            break;\n    }\n\n    if (!_glfw.egl.handle)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"EGL: Failed to load EGL\");\n        return GL_FALSE;\n    }\n\n    _glfw.egl.GetConfigAttrib =\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetConfigAttrib\");\n    _glfw.egl.GetConfigs =\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetConfigs\");\n    _glfw.egl.GetDisplay =\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetDisplay\");\n    _glfw.egl.GetError =\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetError\");\n    _glfw.egl.Initialize =\n        _glfw_dlsym(_glfw.egl.handle, \"eglInitialize\");\n    _glfw.egl.Terminate =\n        _glfw_dlsym(_glfw.egl.handle, \"eglTerminate\");\n    _glfw.egl.BindAPI =\n        _glfw_dlsym(_glfw.egl.handle, \"eglBindAPI\");\n    _glfw.egl.CreateContext =\n        _glfw_dlsym(_glfw.egl.handle, \"eglCreateContext\");\n    _glfw.egl.DestroySurface =\n        _glfw_dlsym(_glfw.egl.handle, \"eglDestroySurface\");\n    _glfw.egl.DestroyContext =\n        _glfw_dlsym(_glfw.egl.handle, \"eglDestroyContext\");\n    _glfw.egl.CreateWindowSurface =\n        _glfw_dlsym(_glfw.egl.handle, \"eglCreateWindowSurface\");\n    _glfw.egl.MakeCurrent =\n        _glfw_dlsym(_glfw.egl.handle, \"eglMakeCurrent\");\n    _glfw.egl.SwapBuffers =\n        _glfw_dlsym(_glfw.egl.handle, \"eglSwapBuffers\");\n    _glfw.egl.SwapInterval =\n        _glfw_dlsym(_glfw.egl.handle, \"eglSwapInterval\");\n    _glfw.egl.QueryString =\n        _glfw_dlsym(_glfw.egl.handle, \"eglQueryString\");\n    _glfw.egl.GetProcAddress =\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetProcAddress\");\n\n    _glfw.egl.display =\n        _glfw_eglGetDisplay((EGLNativeDisplayType)_GLFW_EGL_NATIVE_DISPLAY);\n    if (_glfw.egl.display == EGL_NO_DISPLAY)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"EGL: Failed to get EGL display: %s\",\n                        getErrorString(_glfw_eglGetError()));\n        return GL_FALSE;\n    }\n\n    if (!_glfw_eglInitialize(_glfw.egl.display,\n                             &_glfw.egl.major,\n                             &_glfw.egl.minor))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"EGL: Failed to initialize EGL: %s\",\n                        getErrorString(_glfw_eglGetError()));\n        return GL_FALSE;\n    }\n\n    _glfw.egl.KHR_create_context =\n        _glfwPlatformExtensionSupported(\"EGL_KHR_create_context\");\n\n    return GL_TRUE;\n}\n\n// Terminate EGL\n//\nvoid _glfwTerminateContextAPI(void)\n{\n    if (_glfw_eglTerminate)\n        _glfw_eglTerminate(_glfw.egl.display);\n\n    if (_glfw.egl.handle)\n    {\n        _glfw_dlclose(_glfw.egl.handle);\n        _glfw.egl.handle = NULL;\n    }\n\n    _glfwDestroyContextTLS();\n}\n\n#define setEGLattrib(attribName, attribValue) \\\n{ \\\n    attribs[index++] = attribName; \\\n    attribs[index++] = attribValue; \\\n    assert((size_t) index < sizeof(attribs) / sizeof(attribs[0])); \\\n}\n\n// Create the OpenGL or OpenGL ES context\n//\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWctxconfig* ctxconfig,\n                       const _GLFWfbconfig* fbconfig)\n{\n    int attribs[40];\n    EGLConfig config;\n    EGLContext share = NULL;\n\n    if (ctxconfig->share)\n        share = ctxconfig->share->egl.context;\n\n    if (!chooseFBConfigs(ctxconfig, fbconfig, &config))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"EGL: Failed to find a suitable EGLConfig\");\n        return GL_FALSE;\n    }\n\n#if defined(_GLFW_X11)\n    // Retrieve the visual corresponding to the chosen EGL config\n    {\n        EGLint count = 0;\n        int mask;\n        EGLint redBits, greenBits, blueBits, alphaBits, visualID = 0;\n        XVisualInfo info;\n\n        _glfw_eglGetConfigAttrib(_glfw.egl.display, config,\n                                 EGL_NATIVE_VISUAL_ID, &visualID);\n\n        info.screen = _glfw.x11.screen;\n        mask = VisualScreenMask;\n\n        if (visualID)\n        {\n            // The X window visual must match the EGL config\n            info.visualid = visualID;\n            mask |= VisualIDMask;\n        }\n        else\n        {\n            // Some EGL drivers do not implement the EGL_NATIVE_VISUAL_ID\n            // attribute, so attempt to find the closest match\n\n            _glfw_eglGetConfigAttrib(_glfw.egl.display, config,\n                                     EGL_RED_SIZE, &redBits);\n            _glfw_eglGetConfigAttrib(_glfw.egl.display, config,\n                                     EGL_GREEN_SIZE, &greenBits);\n            _glfw_eglGetConfigAttrib(_glfw.egl.display, config,\n                                     EGL_BLUE_SIZE, &blueBits);\n            _glfw_eglGetConfigAttrib(_glfw.egl.display, config,\n                                     EGL_ALPHA_SIZE, &alphaBits);\n\n            info.depth = redBits + greenBits + blueBits + alphaBits;\n            mask |= VisualDepthMask;\n        }\n\n        window->egl.visual = XGetVisualInfo(_glfw.x11.display,\n                                            mask, &info, &count);\n        if (!window->egl.visual)\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"EGL: Failed to retrieve visual for EGLConfig\");\n            return GL_FALSE;\n        }\n    }\n#endif // _GLFW_X11\n\n    if (ctxconfig->api == GLFW_OPENGL_ES_API)\n    {\n        if (!_glfw_eglBindAPI(EGL_OPENGL_ES_API))\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"EGL: Failed to bind OpenGL ES: %s\",\n                            getErrorString(_glfw_eglGetError()));\n            return GL_FALSE;\n        }\n    }\n    else\n    {\n        if (!_glfw_eglBindAPI(EGL_OPENGL_API))\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"EGL: Failed to bind OpenGL: %s\",\n                            getErrorString(_glfw_eglGetError()));\n            return GL_FALSE;\n        }\n    }\n\n    if (_glfw.egl.KHR_create_context)\n    {\n        int index = 0, mask = 0, flags = 0;\n\n        if (ctxconfig->api == GLFW_OPENGL_API)\n        {\n            if (ctxconfig->forward)\n                flags |= EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR;\n\n            if (ctxconfig->profile == GLFW_OPENGL_CORE_PROFILE)\n                mask |= EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR;\n            else if (ctxconfig->profile == GLFW_OPENGL_COMPAT_PROFILE)\n                mask |= EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR;\n        }\n\n        if (ctxconfig->debug)\n            flags |= EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR;\n\n        if (ctxconfig->robustness)\n        {\n            if (ctxconfig->robustness == GLFW_NO_RESET_NOTIFICATION)\n            {\n                setEGLattrib(EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR,\n                             EGL_NO_RESET_NOTIFICATION_KHR);\n            }\n            else if (ctxconfig->robustness == GLFW_LOSE_CONTEXT_ON_RESET)\n            {\n                setEGLattrib(EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR,\n                             EGL_LOSE_CONTEXT_ON_RESET_KHR);\n            }\n\n            flags |= EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR;\n        }\n\n        if (ctxconfig->major != 1 || ctxconfig->minor != 0)\n        {\n            setEGLattrib(EGL_CONTEXT_MAJOR_VERSION_KHR, ctxconfig->major);\n            setEGLattrib(EGL_CONTEXT_MINOR_VERSION_KHR, ctxconfig->minor);\n        }\n\n        if (mask)\n            setEGLattrib(EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR, mask);\n\n        if (flags)\n            setEGLattrib(EGL_CONTEXT_FLAGS_KHR, flags);\n\n        setEGLattrib(EGL_NONE, EGL_NONE);\n    }\n    else\n    {\n        int index = 0;\n\n        if (ctxconfig->api == GLFW_OPENGL_ES_API)\n            setEGLattrib(EGL_CONTEXT_CLIENT_VERSION, ctxconfig->major);\n\n        setEGLattrib(EGL_NONE, EGL_NONE);\n    }\n\n    // Context release behaviors (GL_KHR_context_flush_control) are not yet\n    // supported on EGL but are not a hard constraint, so ignore and continue\n\n    window->egl.context = _glfw_eglCreateContext(_glfw.egl.display,\n                                                 config, share, attribs);\n\n    if (window->egl.context == EGL_NO_CONTEXT)\n    {\n        _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                        \"EGL: Failed to create context: %s\",\n                        getErrorString(_glfw_eglGetError()));\n        return GL_FALSE;\n    }\n\n    window->egl.config = config;\n\n    // Load the appropriate client library\n    {\n        int i;\n        const char** sonames;\n        const char* es1sonames[] =\n        {\n#if defined(_GLFW_WIN32)\n            \"GLESv1_CM.dll\",\n            \"libGLES_CM.dll\",\n#elif defined(_GLFW_COCOA)\n            \"libGLESv1_CM.dylib\",\n#else\n            \"libGLESv1_CM.so.1\",\n            \"libGLES_CM.so.1\",\n#endif\n            NULL\n        };\n        const char* es2sonames[] =\n        {\n#if defined(_GLFW_WIN32)\n            \"GLESv2.dll\",\n            \"libGLESv2.dll\",\n#elif defined(_GLFW_COCOA)\n            \"libGLESv2.dylib\",\n#else\n            \"libGLESv2.so.2\",\n#endif\n            NULL\n        };\n        const char* glsonames[] =\n        {\n#if defined(_GLFW_WIN32)\n#elif defined(_GLFW_COCOA)\n#else\n            \"libGL.so.1\",\n#endif\n            NULL\n        };\n\n        if (ctxconfig->api == GLFW_OPENGL_ES_API)\n        {\n            if (ctxconfig->major == 1)\n                sonames = es1sonames;\n            else\n                sonames = es2sonames;\n        }\n        else\n            sonames = glsonames;\n\n        for (i = 0;  sonames[i];  i++)\n        {\n            window->egl.client = _glfw_dlopen(sonames[i]);\n            if (window->egl.client)\n                break;\n        }\n\n        if (!window->egl.client)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"EGL: Failed to load client library\");\n            return GL_FALSE;\n        }\n    }\n\n    return GL_TRUE;\n}\n\n#undef setEGLattrib\n\n// Destroy the OpenGL context\n//\nvoid _glfwDestroyContext(_GLFWwindow* window)\n{\n#if defined(_GLFW_X11)\n    // NOTE: Do not unload libGL.so.1 while the X11 display is still open,\n    //       as it will make XCloseDisplay segfault\n    if (window->context.api != GLFW_OPENGL_API)\n#endif // _GLFW_X11\n    {\n        if (window->egl.client)\n        {\n            _glfw_dlclose(window->egl.client);\n            window->egl.client = NULL;\n        }\n    }\n\n#if defined(_GLFW_X11)\n    if (window->egl.visual)\n    {\n       XFree(window->egl.visual);\n       window->egl.visual = NULL;\n    }\n#endif // _GLFW_X11\n\n    if (window->egl.surface)\n    {\n        _glfw_eglDestroySurface(_glfw.egl.display, window->egl.surface);\n        window->egl.surface = EGL_NO_SURFACE;\n    }\n\n    if (window->egl.context)\n    {\n        _glfw_eglDestroyContext(_glfw.egl.display, window->egl.context);\n        window->egl.context = EGL_NO_CONTEXT;\n    }\n}\n\n// Analyzes the specified context for possible recreation\n//\nint _glfwAnalyzeContext(const _GLFWwindow* window,\n                        const _GLFWctxconfig* ctxconfig,\n                        const _GLFWfbconfig* fbconfig)\n{\n#if defined(_GLFW_WIN32)\n    return _GLFW_RECREATION_NOT_NEEDED;\n#else\n    return 0;\n#endif\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nvoid _glfwPlatformMakeContextCurrent(_GLFWwindow* window)\n{\n    if (window)\n    {\n        if (window->egl.surface == EGL_NO_SURFACE)\n        {\n            window->egl.surface =\n                _glfw_eglCreateWindowSurface(_glfw.egl.display,\n                                             window->egl.config,\n                                             (EGLNativeWindowType)_GLFW_EGL_NATIVE_WINDOW,\n                                             NULL);\n            if (window->egl.surface == EGL_NO_SURFACE)\n            {\n                _glfwInputError(GLFW_PLATFORM_ERROR,\n                                \"EGL: Failed to create window surface: %s\",\n                                getErrorString(_glfw_eglGetError()));\n            }\n        }\n\n        _glfw_eglMakeCurrent(_glfw.egl.display,\n                             window->egl.surface,\n                             window->egl.surface,\n                             window->egl.context);\n    }\n    else\n    {\n        _glfw_eglMakeCurrent(_glfw.egl.display,\n                             EGL_NO_SURFACE,\n                             EGL_NO_SURFACE,\n                             EGL_NO_CONTEXT);\n    }\n\n    _glfwSetContextTLS(window);\n}\n\nvoid _glfwPlatformSwapBuffers(_GLFWwindow* window)\n{\n    _glfw_eglSwapBuffers(_glfw.egl.display, window->egl.surface);\n}\n\nvoid _glfwPlatformSwapInterval(int interval)\n{\n    _glfw_eglSwapInterval(_glfw.egl.display, interval);\n}\n\nint _glfwPlatformExtensionSupported(const char* extension)\n{\n    const char* extensions = _glfw_eglQueryString(_glfw.egl.display,\n                                                  EGL_EXTENSIONS);\n    if (extensions)\n    {\n        if (_glfwStringInExtensionString(extension, extensions))\n            return GL_TRUE;\n    }\n\n    return GL_FALSE;\n}\n\nGLFWglproc _glfwPlatformGetProcAddress(const char* procname)\n{\n    _GLFWwindow* window = _glfwPlatformGetCurrentContext();\n\n    if (window->egl.client)\n    {\n        GLFWglproc proc = (GLFWglproc) _glfw_dlsym(window->egl.client, procname);\n        if (proc)\n            return proc;\n    }\n\n    return _glfw_eglGetProcAddress(procname);\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI EGLDisplay glfwGetEGLDisplay(void)\n{\n    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_DISPLAY);\n    return _glfw.egl.display;\n}\n\nGLFWAPI EGLContext glfwGetEGLContext(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_CONTEXT);\n    return window->egl.context;\n}\n\nGLFWAPI EGLSurface glfwGetEGLSurface(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_SURFACE);\n    return window->egl.surface;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.2-x6c6y6bid7i3cuhrzcx25eivkoimm5dy/spack-src/src/glx_context.c": "//========================================================================\n// GLFW 3.1 GLX - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <dlfcn.h>\n\n#ifndef GLXBadProfileARB\n #define GLXBadProfileARB 13\n#endif\n\n\n// Returns the specified attribute of the specified GLXFBConfig\n//\nstatic int getFBConfigAttrib(GLXFBConfig fbconfig, int attrib)\n{\n    int value;\n    _glfw_glXGetFBConfigAttrib(_glfw.x11.display, fbconfig, attrib, &value);\n    return value;\n}\n\n// Return a list of available and usable framebuffer configs\n//\nstatic GLboolean chooseFBConfig(const _GLFWfbconfig* desired, GLXFBConfig* result)\n{\n    GLXFBConfig* nativeConfigs;\n    _GLFWfbconfig* usableConfigs;\n    const _GLFWfbconfig* closest;\n    int i, nativeCount, usableCount;\n    const char* vendor;\n    GLboolean trustWindowBit = GL_TRUE;\n\n    // HACK: This is a (hopefully temporary) workaround for Chromium\n    //       (VirtualBox GL) not setting the window bit on any GLXFBConfigs\n    vendor = _glfw_glXGetClientString(_glfw.x11.display, GLX_VENDOR);\n    if (strcmp(vendor, \"Chromium\") == 0)\n        trustWindowBit = GL_FALSE;\n\n    nativeConfigs = _glfw_glXGetFBConfigs(_glfw.x11.display, _glfw.x11.screen,\n                                          &nativeCount);\n    if (!nativeCount)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: No GLXFBConfigs returned\");\n        return GL_FALSE;\n    }\n\n    usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));\n    usableCount = 0;\n\n    for (i = 0;  i < nativeCount;  i++)\n    {\n        const GLXFBConfig n = nativeConfigs[i];\n        _GLFWfbconfig* u = usableConfigs + usableCount;\n\n        // Only consider GLXFBConfigs with associated visuals\n        if (!getFBConfigAttrib(n, GLX_VISUAL_ID))\n            continue;\n\n        // Only consider RGBA GLXFBConfigs\n        if (!(getFBConfigAttrib(n, GLX_RENDER_TYPE) & GLX_RGBA_BIT))\n            continue;\n\n        // Only consider window GLXFBConfigs\n        if (!(getFBConfigAttrib(n, GLX_DRAWABLE_TYPE) & GLX_WINDOW_BIT))\n        {\n            if (trustWindowBit)\n                continue;\n        }\n\n        u->redBits = getFBConfigAttrib(n, GLX_RED_SIZE);\n        u->greenBits = getFBConfigAttrib(n, GLX_GREEN_SIZE);\n        u->blueBits = getFBConfigAttrib(n, GLX_BLUE_SIZE);\n\n        u->alphaBits = getFBConfigAttrib(n, GLX_ALPHA_SIZE);\n        u->depthBits = getFBConfigAttrib(n, GLX_DEPTH_SIZE);\n        u->stencilBits = getFBConfigAttrib(n, GLX_STENCIL_SIZE);\n\n        u->accumRedBits = getFBConfigAttrib(n, GLX_ACCUM_RED_SIZE);\n        u->accumGreenBits = getFBConfigAttrib(n, GLX_ACCUM_GREEN_SIZE);\n        u->accumBlueBits = getFBConfigAttrib(n, GLX_ACCUM_BLUE_SIZE);\n        u->accumAlphaBits = getFBConfigAttrib(n, GLX_ACCUM_ALPHA_SIZE);\n\n        u->auxBuffers = getFBConfigAttrib(n, GLX_AUX_BUFFERS);\n\n        if (getFBConfigAttrib(n, GLX_STEREO))\n            u->stereo = GL_TRUE;\n        if (getFBConfigAttrib(n, GLX_DOUBLEBUFFER))\n            u->doublebuffer = GL_TRUE;\n\n        if (_glfw.glx.ARB_multisample)\n            u->samples = getFBConfigAttrib(n, GLX_SAMPLES);\n\n        if (_glfw.glx.ARB_framebuffer_sRGB || _glfw.glx.EXT_framebuffer_sRGB)\n            u->sRGB = getFBConfigAttrib(n, GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB);\n\n        u->glx = n;\n        usableCount++;\n    }\n\n    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);\n    if (closest)\n        *result = closest->glx;\n\n    XFree(nativeConfigs);\n    free(usableConfigs);\n\n    return closest ? GL_TRUE : GL_FALSE;\n}\n\n// Create the OpenGL context using legacy API\n//\nstatic GLXContext createLegacyContext(_GLFWwindow* window,\n                                      GLXFBConfig fbconfig,\n                                      GLXContext share)\n{\n    return _glfw_glXCreateNewContext(_glfw.x11.display,\n                                     fbconfig,\n                                     GLX_RGBA_TYPE,\n                                     share,\n                                     True);\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Initialize GLX\n//\nint _glfwInitContextAPI(void)\n{\n#if defined(__CYGWIN__)\n    const char* soname = \"libGL-1.so\";\n#else\n    const char* soname = \"libGL.so.1\";\n#endif\n\n    if (!_glfwCreateContextTLS())\n        return GL_FALSE;\n\n    _glfw.glx.handle = dlopen(soname, RTLD_LAZY | RTLD_GLOBAL);\n    if (!_glfw.glx.handle)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: %s\", dlerror());\n        return GL_FALSE;\n    }\n\n    _glfw.glx.GetFBConfigs =\n        dlsym(_glfw.glx.handle, \"glXGetFBConfigs\");\n    _glfw.glx.GetFBConfigAttrib =\n        dlsym(_glfw.glx.handle, \"glXGetFBConfigAttrib\");\n    _glfw.glx.GetClientString =\n        dlsym(_glfw.glx.handle, \"glXGetClientString\");\n    _glfw.glx.QueryExtension =\n        dlsym(_glfw.glx.handle, \"glXQueryExtension\");\n    _glfw.glx.QueryVersion =\n        dlsym(_glfw.glx.handle, \"glXQueryVersion\");\n    _glfw.glx.DestroyContext =\n        dlsym(_glfw.glx.handle, \"glXDestroyContext\");\n    _glfw.glx.MakeCurrent =\n        dlsym(_glfw.glx.handle, \"glXMakeCurrent\");\n    _glfw.glx.SwapBuffers =\n        dlsym(_glfw.glx.handle, \"glXSwapBuffers\");\n    _glfw.glx.QueryExtensionsString =\n        dlsym(_glfw.glx.handle, \"glXQueryExtensionsString\");\n    _glfw.glx.CreateNewContext =\n        dlsym(_glfw.glx.handle, \"glXCreateNewContext\");\n    _glfw.glx.GetVisualFromFBConfig =\n        dlsym(_glfw.glx.handle, \"glXGetVisualFromFBConfig\");\n    _glfw.glx.GetProcAddress =\n        dlsym(_glfw.glx.handle, \"glXGetProcAddress\");\n    _glfw.glx.GetProcAddressARB =\n        dlsym(_glfw.glx.handle, \"glXGetProcAddressARB\");\n\n    if (!_glfw_glXQueryExtension(_glfw.x11.display,\n                                 &_glfw.glx.errorBase,\n                                 &_glfw.glx.eventBase))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: GLX extension not found\");\n        return GL_FALSE;\n    }\n\n    if (!_glfw_glXQueryVersion(_glfw.x11.display,\n                               &_glfw.glx.major,\n                               &_glfw.glx.minor))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: Failed to query GLX version\");\n        return GL_FALSE;\n    }\n\n    if (_glfw.glx.major == 1 && _glfw.glx.minor < 3)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: GLX version 1.3 is required\");\n        return GL_FALSE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_EXT_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)\n            _glfwPlatformGetProcAddress(\"glXSwapIntervalEXT\");\n\n        if (_glfw.glx.SwapIntervalEXT)\n            _glfw.glx.EXT_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_SGI_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalSGI = (PFNGLXSWAPINTERVALSGIPROC)\n            _glfwPlatformGetProcAddress(\"glXSwapIntervalSGI\");\n\n        if (_glfw.glx.SwapIntervalSGI)\n            _glfw.glx.SGI_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_MESA_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalMESA = (PFNGLXSWAPINTERVALMESAPROC)\n            _glfwPlatformGetProcAddress(\"glXSwapIntervalMESA\");\n\n        if (_glfw.glx.SwapIntervalMESA)\n            _glfw.glx.MESA_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_multisample\"))\n        _glfw.glx.ARB_multisample = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_framebuffer_sRGB\"))\n        _glfw.glx.ARB_framebuffer_sRGB = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_EXT_framebuffer_sRGB\"))\n        _glfw.glx.EXT_framebuffer_sRGB = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_create_context\"))\n    {\n        _glfw.glx.CreateContextAttribsARB = (PFNGLXCREATECONTEXTATTRIBSARBPROC)\n            _glfwPlatformGetProcAddress(\"glXCreateContextAttribsARB\");\n\n        if (_glfw.glx.CreateContextAttribsARB)\n            _glfw.glx.ARB_create_context = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_create_context_robustness\"))\n        _glfw.glx.ARB_create_context_robustness = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_create_context_profile\"))\n        _glfw.glx.ARB_create_context_profile = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_EXT_create_context_es2_profile\"))\n        _glfw.glx.EXT_create_context_es2_profile = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_context_flush_control\"))\n        _glfw.glx.ARB_context_flush_control = GL_TRUE;\n\n    return GL_TRUE;\n}\n\n// Terminate GLX\n//\nvoid _glfwTerminateContextAPI(void)\n{\n    // NOTE: This function may not call any X11 functions, as it is called after\n    //       XCloseDisplay (see _glfwPlatformTerminate for details)\n\n    if (_glfw.glx.handle)\n    {\n        dlclose(_glfw.glx.handle);\n        _glfw.glx.handle = NULL;\n    }\n\n    _glfwDestroyContextTLS();\n}\n\n#define setGLXattrib(attribName, attribValue) \\\n{ \\\n    attribs[index++] = attribName; \\\n    attribs[index++] = attribValue; \\\n    assert((size_t) index < sizeof(attribs) / sizeof(attribs[0])); \\\n}\n\n// Create the OpenGL or OpenGL ES context\n//\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWctxconfig* ctxconfig,\n                       const _GLFWfbconfig* fbconfig)\n{\n    int attribs[40];\n    GLXFBConfig native = NULL;\n    GLXContext share = NULL;\n\n    if (ctxconfig->share)\n        share = ctxconfig->share->glx.context;\n\n    if (!chooseFBConfig(fbconfig, &native))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"GLX: Failed to find a suitable GLXFBConfig\");\n        return GL_FALSE;\n    }\n\n    window->glx.visual = _glfw_glXGetVisualFromFBConfig(_glfw.x11.display,\n                                                        native);\n    if (!window->glx.visual)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to retrieve visual for GLXFBConfig\");\n        return GL_FALSE;\n    }\n\n    if (ctxconfig->api == GLFW_OPENGL_ES_API)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile ||\n            !_glfw.glx.EXT_create_context_es2_profile)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"GLX: OpenGL ES requested but GLX_EXT_create_context_es2_profile is unavailable\");\n            return GL_FALSE;\n        }\n    }\n\n    if (ctxconfig->forward)\n    {\n        if (!_glfw.glx.ARB_create_context)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: Forward compatibility requested but GLX_ARB_create_context_profile is unavailable\");\n            return GL_FALSE;\n        }\n    }\n\n    if (ctxconfig->profile)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: An OpenGL profile requested but GLX_ARB_create_context_profile is unavailable\");\n            return GL_FALSE;\n        }\n    }\n\n    _glfwGrabXErrorHandler();\n\n    if (_glfw.glx.ARB_create_context)\n    {\n        int index = 0, mask = 0, flags = 0;\n\n        if (ctxconfig->api == GLFW_OPENGL_API)\n        {\n            if (ctxconfig->forward)\n                flags |= GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB;\n\n            if (ctxconfig->profile == GLFW_OPENGL_CORE_PROFILE)\n                mask |= GLX_CONTEXT_CORE_PROFILE_BIT_ARB;\n            else if (ctxconfig->profile == GLFW_OPENGL_COMPAT_PROFILE)\n                mask |= GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB;\n        }\n        else\n            mask |= GLX_CONTEXT_ES2_PROFILE_BIT_EXT;\n\n        if (ctxconfig->debug)\n            flags |= GLX_CONTEXT_DEBUG_BIT_ARB;\n\n        if (ctxconfig->robustness)\n        {\n            if (_glfw.glx.ARB_create_context_robustness)\n            {\n                if (ctxconfig->robustness == GLFW_NO_RESET_NOTIFICATION)\n                {\n                    setGLXattrib(GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB,\n                                 GLX_NO_RESET_NOTIFICATION_ARB);\n                }\n                else if (ctxconfig->robustness == GLFW_LOSE_CONTEXT_ON_RESET)\n                {\n                    setGLXattrib(GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB,\n                                 GLX_LOSE_CONTEXT_ON_RESET_ARB);\n                }\n\n                flags |= GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB;\n            }\n        }\n\n        if (ctxconfig->release)\n        {\n            if (_glfw.glx.ARB_context_flush_control)\n            {\n                if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_NONE)\n                {\n                    setGLXattrib(GLX_CONTEXT_RELEASE_BEHAVIOR_ARB,\n                                 GLX_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB);\n                }\n                else if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_FLUSH)\n                {\n                    setGLXattrib(GLX_CONTEXT_RELEASE_BEHAVIOR_ARB,\n                                 GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB);\n                }\n            }\n        }\n\n        // NOTE: Only request an explicitly versioned context when necessary, as\n        //       explicitly requesting version 1.0 does not always return the\n        //       highest version supported by the driver\n        if (ctxconfig->major != 1 || ctxconfig->minor != 0)\n        {\n            setGLXattrib(GLX_CONTEXT_MAJOR_VERSION_ARB, ctxconfig->major);\n            setGLXattrib(GLX_CONTEXT_MINOR_VERSION_ARB, ctxconfig->minor);\n        }\n\n        if (mask)\n            setGLXattrib(GLX_CONTEXT_PROFILE_MASK_ARB, mask);\n\n        if (flags)\n            setGLXattrib(GLX_CONTEXT_FLAGS_ARB, flags);\n\n        setGLXattrib(None, None);\n\n        window->glx.context =\n            _glfw.glx.CreateContextAttribsARB(_glfw.x11.display,\n                                              native,\n                                              share,\n                                              True,\n                                              attribs);\n\n        // HACK: This is a fallback for broken versions of the Mesa\n        //       implementation of GLX_ARB_create_context_profile that fail\n        //       default 1.0 context creation with a GLXBadProfileARB error in\n        //       violation of the extension spec\n        if (!window->glx.context)\n        {\n            if (_glfw.x11.errorCode == _glfw.glx.errorBase + GLXBadProfileARB &&\n                ctxconfig->api == GLFW_OPENGL_API &&\n                ctxconfig->profile == GLFW_OPENGL_ANY_PROFILE &&\n                ctxconfig->forward == GL_FALSE)\n            {\n                window->glx.context = createLegacyContext(window, native, share);\n            }\n        }\n    }\n    else\n        window->glx.context = createLegacyContext(window, native, share);\n\n    _glfwReleaseXErrorHandler();\n\n    if (!window->glx.context)\n    {\n        _glfwInputXError(GLFW_VERSION_UNAVAILABLE, \"GLX: Failed to create context\");\n        return GL_FALSE;\n    }\n\n    return GL_TRUE;\n}\n\n#undef setGLXattrib\n\n// Destroy the OpenGL context\n//\nvoid _glfwDestroyContext(_GLFWwindow* window)\n{\n    if (window->glx.visual)\n    {\n        XFree(window->glx.visual);\n        window->glx.visual = NULL;\n    }\n\n    if (window->glx.context)\n    {\n        _glfw_glXDestroyContext(_glfw.x11.display, window->glx.context);\n        window->glx.context = NULL;\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nvoid _glfwPlatformMakeContextCurrent(_GLFWwindow* window)\n{\n    if (window)\n    {\n        _glfw_glXMakeCurrent(_glfw.x11.display,\n                             window->x11.handle,\n                             window->glx.context);\n    }\n    else\n        _glfw_glXMakeCurrent(_glfw.x11.display, None, NULL);\n\n    _glfwSetContextTLS(window);\n}\n\nvoid _glfwPlatformSwapBuffers(_GLFWwindow* window)\n{\n    _glfw_glXSwapBuffers(_glfw.x11.display, window->x11.handle);\n}\n\nvoid _glfwPlatformSwapInterval(int interval)\n{\n    _GLFWwindow* window = _glfwPlatformGetCurrentContext();\n\n    if (_glfw.glx.EXT_swap_control)\n    {\n        _glfw.glx.SwapIntervalEXT(_glfw.x11.display,\n                                  window->x11.handle,\n                                  interval);\n    }\n    else if (_glfw.glx.MESA_swap_control)\n        _glfw.glx.SwapIntervalMESA(interval);\n    else if (_glfw.glx.SGI_swap_control)\n    {\n        if (interval > 0)\n            _glfw.glx.SwapIntervalSGI(interval);\n    }\n}\n\nint _glfwPlatformExtensionSupported(const char* extension)\n{\n    const char* extensions =\n        _glfw_glXQueryExtensionsString(_glfw.x11.display, _glfw.x11.screen);\n    if (extensions)\n    {\n        if (_glfwStringInExtensionString(extension, extensions))\n            return GL_TRUE;\n    }\n\n    return GL_FALSE;\n}\n\nGLFWglproc _glfwPlatformGetProcAddress(const char* procname)\n{\n    if (_glfw.glx.GetProcAddress)\n        return _glfw.glx.GetProcAddress((const GLubyte*) procname);\n    else if (_glfw.glx.GetProcAddressARB)\n        return _glfw.glx.GetProcAddressARB((const GLubyte*) procname);\n    else\n        return dlsym(_glfw.glx.handle, procname);\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI GLXContext glfwGetGLXContext(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n    return window->glx.context;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.2-x6c6y6bid7i3cuhrzcx25eivkoimm5dy/spack-src/src/egl_context.h": "//========================================================================\n// GLFW 3.1 EGL - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _glfw3_egl_context_h_\n#define _glfw3_egl_context_h_\n\n#if defined(_GLFW_WIN32)\n #define _glfw_dlopen(name) LoadLibraryA(name)\n #define _glfw_dlclose(handle) FreeLibrary((HMODULE) handle)\n #define _glfw_dlsym(handle, name) GetProcAddress((HMODULE) handle, name)\n#else\n #include <dlfcn.h>\n #define _glfw_dlopen(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL)\n #define _glfw_dlclose(handle) dlclose(handle)\n #define _glfw_dlsym(handle, name) dlsym(handle, name)\n#endif\n\n#include <EGL/egl.h>\n\n// This path may need to be changed if you build GLFW using your own setup\n// We ship and use our own copy of eglext.h since GLFW uses fairly new\n// extensions and not all operating systems come with an up-to-date version\n#include \"../deps/EGL/eglext.h\"\n\n// EGL function pointer typedefs\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLGETCONFIGATTRIBPROC)(EGLDisplay,EGLConfig,EGLint,EGLint*);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLGETCONFIGSPROC)(EGLDisplay,EGLConfig*,EGLint,EGLint*);\ntypedef EGLDisplay (EGLAPIENTRY * PFNEGLGETDISPLAYPROC)(EGLNativeDisplayType);\ntypedef EGLint (EGLAPIENTRY * PFNEGLGETERRORPROC)(void);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLINITIALIZEPROC)(EGLDisplay,EGLint*,EGLint*);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLTERMINATEPROC)(EGLDisplay);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLBINDAPIPROC)(EGLenum);\ntypedef EGLContext (EGLAPIENTRY * PFNEGLCREATECONTEXTPROC)(EGLDisplay,EGLConfig,EGLContext,const EGLint*);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLDESTROYSURFACEPROC)(EGLDisplay,EGLSurface);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLDESTROYCONTEXTPROC)(EGLDisplay,EGLContext);\ntypedef EGLSurface (EGLAPIENTRY * PFNEGLCREATEWINDOWSURFACEPROC)(EGLDisplay,EGLConfig,EGLNativeWindowType,const EGLint*);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLMAKECURRENTPROC)(EGLDisplay,EGLSurface,EGLSurface,EGLContext);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLSWAPBUFFERSPROC)(EGLDisplay,EGLSurface);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLSWAPINTERVALPROC)(EGLDisplay,EGLint);\ntypedef const char* (EGLAPIENTRY * PFNEGLQUERYSTRINGPROC)(EGLDisplay,EGLint);\ntypedef GLFWglproc (EGLAPIENTRY * PFNEGLGETPROCADDRESSPROC)(const char*);\n#define _glfw_eglGetConfigAttrib _glfw.egl.GetConfigAttrib\n#define _glfw_eglGetConfigs _glfw.egl.GetConfigs\n#define _glfw_eglGetDisplay _glfw.egl.GetDisplay\n#define _glfw_eglGetError _glfw.egl.GetError\n#define _glfw_eglInitialize _glfw.egl.Initialize\n#define _glfw_eglTerminate _glfw.egl.Terminate\n#define _glfw_eglBindAPI _glfw.egl.BindAPI\n#define _glfw_eglCreateContext _glfw.egl.CreateContext\n#define _glfw_eglDestroySurface _glfw.egl.DestroySurface\n#define _glfw_eglDestroyContext _glfw.egl.DestroyContext\n#define _glfw_eglCreateWindowSurface _glfw.egl.CreateWindowSurface\n#define _glfw_eglMakeCurrent _glfw.egl.MakeCurrent\n#define _glfw_eglSwapBuffers _glfw.egl.SwapBuffers\n#define _glfw_eglSwapInterval _glfw.egl.SwapInterval\n#define _glfw_eglQueryString _glfw.egl.QueryString\n#define _glfw_eglGetProcAddress _glfw.egl.GetProcAddress\n\n#define _GLFW_PLATFORM_FBCONFIG                 EGLConfig       egl\n#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextEGL egl\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryEGL egl\n\n\n// EGL-specific per-context data\n//\ntypedef struct _GLFWcontextEGL\n{\n   EGLConfig        config;\n   EGLContext       context;\n   EGLSurface       surface;\n\n#if defined(_GLFW_X11)\n   XVisualInfo*     visual;\n#endif\n\n   void*            client;\n\n} _GLFWcontextEGL;\n\n\n// EGL-specific global data\n//\ntypedef struct _GLFWlibraryEGL\n{\n    EGLDisplay      display;\n    EGLint          major, minor;\n\n    GLboolean       KHR_create_context;\n\n    void*           handle;\n\n    PFNEGLGETCONFIGATTRIBPROC       GetConfigAttrib;\n    PFNEGLGETCONFIGSPROC            GetConfigs;\n    PFNEGLGETDISPLAYPROC            GetDisplay;\n    PFNEGLGETERRORPROC              GetError;\n    PFNEGLINITIALIZEPROC            Initialize;\n    PFNEGLTERMINATEPROC             Terminate;\n    PFNEGLBINDAPIPROC               BindAPI;\n    PFNEGLCREATECONTEXTPROC         CreateContext;\n    PFNEGLDESTROYSURFACEPROC        DestroySurface;\n    PFNEGLDESTROYCONTEXTPROC        DestroyContext;\n    PFNEGLCREATEWINDOWSURFACEPROC   CreateWindowSurface;\n    PFNEGLMAKECURRENTPROC           MakeCurrent;\n    PFNEGLSWAPBUFFERSPROC           SwapBuffers;\n    PFNEGLSWAPINTERVALPROC          SwapInterval;\n    PFNEGLQUERYSTRINGPROC           QueryString;\n    PFNEGLGETPROCADDRESSPROC        GetProcAddress;\n\n} _GLFWlibraryEGL;\n\n\nint _glfwInitContextAPI(void);\nvoid _glfwTerminateContextAPI(void);\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWctxconfig* ctxconfig,\n                       const _GLFWfbconfig* fbconfig);\nvoid _glfwDestroyContext(_GLFWwindow* window);\nint _glfwAnalyzeContext(const _GLFWwindow* window,\n                        const _GLFWctxconfig* ctxconfig,\n                        const _GLFWfbconfig* fbconfig);\n\n#endif // _glfw3_egl_context_h_\n"
    },
    "skipped": [],
    "total_files": 132
}