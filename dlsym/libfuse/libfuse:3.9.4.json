{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libfuse-3.9.4-aresw5fmrqlspfz4famoaeojpijkpwtm/spack-src/lib/fuse.c": "/*\n  FUSE: Filesystem in Userspace\n  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>\n\n  Implementation of the high-level FUSE API on top of the low-level\n  API.\n\n  This program can be distributed under the terms of the GNU LGPLv2.\n  See the file COPYING.LIB\n*/\n\n\n/* For pthread_rwlock_t */\n#define _GNU_SOURCE\n\n#include \"config.h\"\n#include \"fuse_i.h\"\n#include \"fuse_lowlevel.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"fuse_kernel.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <signal.h>\n#include <dlfcn.h>\n#include <assert.h>\n#include <poll.h>\n#include <sys/param.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/mman.h>\n#include <sys/file.h>\n\n#define FUSE_NODE_SLAB 1\n\n#ifndef MAP_ANONYMOUS\n#undef FUSE_NODE_SLAB\n#endif\n\n#ifndef RENAME_EXCHANGE\n#define RENAME_EXCHANGE\t\t(1 << 1)\t/* Exchange source and dest */\n#endif\n\n#define FUSE_DEFAULT_INTR_SIGNAL SIGUSR1\n\n#define FUSE_UNKNOWN_INO 0xffffffff\n#define OFFSET_MAX 0x7fffffffffffffffLL\n\n#define NODE_TABLE_MIN_SIZE 8192\n\nstruct fuse_fs {\n\tstruct fuse_operations op;\n\tstruct fuse_module *m;\n\tvoid *user_data;\n\tint debug;\n};\n\nstruct fusemod_so {\n\tvoid *handle;\n\tint ctr;\n};\n\nstruct lock_queue_element {\n\tstruct lock_queue_element *next;\n\tpthread_cond_t cond;\n\tfuse_ino_t nodeid1;\n\tconst char *name1;\n\tchar **path1;\n\tstruct node **wnode1;\n\tfuse_ino_t nodeid2;\n\tconst char *name2;\n\tchar **path2;\n\tstruct node **wnode2;\n\tint err;\n\tbool first_locked : 1;\n\tbool second_locked : 1;\n\tbool done : 1;\n};\n\nstruct node_table {\n\tstruct node **array;\n\tsize_t use;\n\tsize_t size;\n\tsize_t split;\n};\n\n#define container_of(ptr, type, member) ({                              \\\n\t\t\tconst typeof( ((type *)0)->member ) *__mptr = (ptr); \\\n\t\t\t(type *)( (char *)__mptr - offsetof(type,member) );})\n\n#define list_entry(ptr, type, member)           \\\n\tcontainer_of(ptr, type, member)\n\nstruct list_head {\n\tstruct list_head *next;\n\tstruct list_head *prev;\n};\n\nstruct node_slab {\n\tstruct list_head list;  /* must be the first member */\n\tstruct list_head freelist;\n\tint used;\n};\n\nstruct fuse {\n\tstruct fuse_session *se;\n\tstruct node_table name_table;\n\tstruct node_table id_table;\n\tstruct list_head lru_table;\n\tfuse_ino_t ctr;\n\tunsigned int generation;\n\tunsigned int hidectr;\n\tpthread_mutex_t lock;\n\tstruct fuse_config conf;\n\tint intr_installed;\n\tstruct fuse_fs *fs;\n\tstruct lock_queue_element *lockq;\n\tint pagesize;\n\tstruct list_head partial_slabs;\n\tstruct list_head full_slabs;\n\tpthread_t prune_thread;\n};\n\nstruct lock {\n\tint type;\n\toff_t start;\n\toff_t end;\n\tpid_t pid;\n\tuint64_t owner;\n\tstruct lock *next;\n};\n\nstruct node {\n\tstruct node *name_next;\n\tstruct node *id_next;\n\tfuse_ino_t nodeid;\n\tunsigned int generation;\n\tint refctr;\n\tstruct node *parent;\n\tchar *name;\n\tuint64_t nlookup;\n\tint open_count;\n\tstruct timespec stat_updated;\n\tstruct timespec mtime;\n\toff_t size;\n\tstruct lock *locks;\n\tunsigned int is_hidden : 1;\n\tunsigned int cache_valid : 1;\n\tint treelock;\n\tchar inline_name[32];\n};\n\n#define TREELOCK_WRITE -1\n#define TREELOCK_WAIT_OFFSET INT_MIN\n\nstruct node_lru {\n\tstruct node node;\n\tstruct list_head lru;\n\tstruct timespec forget_time;\n};\n\nstruct fuse_direntry {\n\tstruct stat stat;\n\tchar *name;\n\tstruct fuse_direntry *next;\n};\n\nstruct fuse_dh {\n\tpthread_mutex_t lock;\n\tstruct fuse *fuse;\n\tfuse_req_t req;\n\tchar *contents;\n\tstruct fuse_direntry *first;\n\tstruct fuse_direntry **last;\n\tunsigned len;\n\tunsigned size;\n\tunsigned needlen;\n\tint filled;\n\tuint64_t fh;\n\tint error;\n\tfuse_ino_t nodeid;\n};\n\nstruct fuse_context_i {\n\tstruct fuse_context ctx;\n\tfuse_req_t req;\n};\n\n/* Defined by FUSE_REGISTER_MODULE() in lib/modules/subdir.c and iconv.c.  */\nextern fuse_module_factory_t fuse_module_subdir_factory;\n#ifdef HAVE_ICONV\nextern fuse_module_factory_t fuse_module_iconv_factory;\n#endif\n\nstatic pthread_key_t fuse_context_key;\nstatic pthread_mutex_t fuse_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic int fuse_context_ref;\nstatic struct fuse_module *fuse_modules = NULL;\n\nstatic int fuse_register_module(const char *name,\n\t\t\t\tfuse_module_factory_t factory,\n\t\t\t\tstruct fusemod_so *so)\n{\n\tstruct fuse_module *mod;\n\n\tmod = calloc(1, sizeof(struct fuse_module));\n\tif (!mod) {\n\t\tfuse_log(FUSE_LOG_ERR, \"fuse: failed to allocate module\\n\");\n\t\treturn -1;\n\t}\n\tmod->name = strdup(name);\n\tif (!mod->name) {\n\t\tfuse_log(FUSE_LOG_ERR, \"fuse: failed to allocate module name\\n\");\n\t\tfree(mod);\n\t\treturn -1;\n\t}\n\tmod->factory = factory;\n\tmod->ctr = 0;\n\tmod->so = so;\n\tif (mod->so)\n\t\tmod->so->ctr++;\n\tmod->next = fuse_modules;\n\tfuse_modules = mod;\n\n\treturn 0;\n}\n\nstatic void fuse_unregister_module(struct fuse_module *m)\n{\n\tstruct fuse_module **mp;\n\tfor (mp = &fuse_modules; *mp; mp = &(*mp)->next) {\n\t\tif (*mp == m) {\n\t\t\t*mp = (*mp)->next;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(m->name);\n\tfree(m);\n}\n\nstatic int fuse_load_so_module(const char *module)\n{\n\tint ret = -1;\n\tchar *tmp;\n\tstruct fusemod_so *so;\n\tfuse_module_factory_t factory;\n\n\ttmp = malloc(strlen(module) + 64);\n\tif (!tmp) {\n\t\tfuse_log(FUSE_LOG_ERR, \"fuse: memory allocation failed\\n\");\n\t\treturn -1;\n\t}\n\tsprintf(tmp, \"libfusemod_%s.so\", module);\n\tso = calloc(1, sizeof(struct fusemod_so));\n\tif (!so) {\n\t\tfuse_log(FUSE_LOG_ERR, \"fuse: failed to allocate module so\\n\");\n\t\tgoto out;\n\t}\n\n\tso->handle = dlopen(tmp, RTLD_NOW);\n\tif (so->handle == NULL) {\n\t\tfuse_log(FUSE_LOG_ERR, \"fuse: dlopen(%s) failed: %s\\n\",\n\t\t\ttmp, dlerror());\n\t\tgoto out_free_so;\n\t}\n\n\tsprintf(tmp, \"fuse_module_%s_factory\", module);\n\t*(void**)(&factory) = dlsym(so->handle, tmp);\n\tif (factory == NULL) {\n\t\tfuse_log(FUSE_LOG_ERR, \"fuse: symbol <%s> not found in module: %s\\n\",\n\t\t\ttmp, dlerror());\n\t\tgoto out_dlclose;\n\t}\n\tret = fuse_register_module(module, factory, so);\n\tif (ret)\n\t\tgoto out_dlclose;\n\nout:\n\tfree(tmp);\n\treturn ret;\n\nout_dlclose:\n\tdlclose(so->handle);\nout_free_so:\n\tfree(so);\n\tgoto out;\n}\n\nstatic struct fuse_module *fuse_find_module(const char *module)\n{\n\tstruct fuse_module *m;\n\tfor (m = fuse_modules; m; m = m->next) {\n\t\tif (strcmp(module, m->name) == 0) {\n\t\t\tm->ctr++;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn m;\n}\n\nstatic struct fuse_module *fuse_get_module(const char *module)\n{\n\tstruct fuse_module *m;\n\n\tpthread_mutex_lock(&fuse_context_lock);\n\tm = fuse_find_module(module);\n\tif (!m) {\n\t\tint err = fuse_load_so_module(module);\n\t\tif (!err)\n\t\t\tm = fuse_find_module(module);\n\t}\n\tpthread_mutex_unlock(&fuse_context_lock);\n\treturn m;\n}\n\nstatic void fuse_put_module(struct fuse_module *m)\n{\n\tpthread_mutex_lock(&fuse_context_lock);\n\tif (m->so)\n\t\tassert(m->ctr > 0);\n\t/* Builtin modules may already have m->ctr == 0 */\n\tif (m->ctr > 0)\n\t\tm->ctr--;\n\tif (!m->ctr && m->so) {\n\t\tstruct fusemod_so *so = m->so;\n\t\tassert(so->ctr > 0);\n\t\tso->ctr--;\n\t\tif (!so->ctr) {\n\t\t\tstruct fuse_module **mp;\n\t\t\tfor (mp = &fuse_modules; *mp;) {\n\t\t\t\tif ((*mp)->so == so)\n\t\t\t\t\tfuse_unregister_module(*mp);\n\t\t\t\telse\n\t\t\t\t\tmp = &(*mp)->next;\n\t\t\t}\n\t\t\tdlclose(so->handle);\n\t\t\tfree(so);\n\t\t}\n\t} else if (!m->ctr) {\n\t\tfuse_unregister_module(m);\n\t}\n\tpthread_mutex_unlock(&fuse_context_lock);\n}\n\nstatic void init_list_head(struct list_head *list)\n{\n\tlist->next = list;\n\tlist->prev = list;\n}\n\nstatic int list_empty(const struct list_head *head)\n{\n\treturn head->next == head;\n}\n\nstatic void list_add(struct list_head *new, struct list_head *prev,\n\t\t     struct list_head *next)\n{\n\tnext->prev = new;\n\tnew->next = next;\n\tnew->prev = prev;\n\tprev->next = new;\n}\n\nstatic inline void list_add_head(struct list_head *new, struct list_head *head)\n{\n\tlist_add(new, head, head->next);\n}\n\nstatic inline void list_add_tail(struct list_head *new, struct list_head *head)\n{\n\tlist_add(new, head->prev, head);\n}\n\nstatic inline void list_del(struct list_head *entry)\n{\n\tstruct list_head *prev = entry->prev;\n\tstruct list_head *next = entry->next;\n\n\tnext->prev = prev;\n\tprev->next = next;\n}\n\nstatic inline int lru_enabled(struct fuse *f)\n{\n\treturn f->conf.remember > 0;\n}\n\nstatic struct node_lru *node_lru(struct node *node)\n{\n\treturn (struct node_lru *) node;\n}\n\nstatic size_t get_node_size(struct fuse *f)\n{\n\tif (lru_enabled(f))\n\t\treturn sizeof(struct node_lru);\n\telse\n\t\treturn sizeof(struct node);\n}\n\n#ifdef FUSE_NODE_SLAB\nstatic struct node_slab *list_to_slab(struct list_head *head)\n{\n\treturn (struct node_slab *) head;\n}\n\nstatic struct node_slab *node_to_slab(struct fuse *f, struct node *node)\n{\n\treturn (struct node_slab *) (((uintptr_t) node) & ~((uintptr_t) f->pagesize - 1));\n}\n\nstatic int alloc_slab(struct fuse *f)\n{\n\tvoid *mem;\n\tstruct node_slab *slab;\n\tchar *start;\n\tsize_t num;\n\tsize_t i;\n\tsize_t node_size = get_node_size(f);\n\n\tmem = mmap(NULL, f->pagesize, PROT_READ | PROT_WRITE,\n\t\t   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\tif (mem == MAP_FAILED)\n\t\treturn -1;\n\n\tslab = mem;\n\tinit_list_head(&slab->freelist);\n\tslab->used = 0;\n\tnum = (f->pagesize - sizeof(struct node_slab)) / node_size;\n\n\tstart = (char *) mem + f->pagesize - num * node_size;\n\tfor (i = 0; i < num; i++) {\n\t\tstruct list_head *n;\n\n\t\tn = (struct list_head *) (start + i * node_size);\n\t\tlist_add_tail(n, &slab->freelist);\n\t}\n\tlist_add_tail(&slab->list, &f->partial_slabs);\n\n\treturn 0;\n}\n\nstatic struct node *alloc_node(struct fuse *f)\n{\n\tstruct node_slab *slab;\n\tstruct list_head *node;\n\n\tif (list_empty(&f->partial_slabs)) {\n\t\tint res = alloc_slab(f);\n\t\tif (res != 0)\n\t\t\treturn NULL;\n\t}\n\tslab = list_to_slab(f->partial_slabs.next);\n\tslab->used++;\n\tnode = slab->freelist.next;\n\tlist_del(node);\n\tif (list_empty(&slab->freelist)) {\n\t\tlist_del(&slab->list);\n\t\tlist_add_tail(&slab->list, &f->full_slabs);\n\t}\n\tmemset(node, 0, sizeof(struct node));\n\n\treturn (struct node *) node;\n}\n\nstatic void free_slab(struct fuse *f, struct node_slab *slab)\n{\n\tint res;\n\n\tlist_del(&slab->list);\n\tres = munmap(slab, f->pagesize);\n\tif (res == -1)\n\t\tfuse_log(FUSE_LOG_WARNING, \"fuse warning: munmap(%p) failed\\n\",\n\t\t\t slab);\n}\n\nstatic void free_node_mem(struct fuse *f, struct node *node)\n{\n\tstruct node_slab *slab = node_to_slab(f, node);\n\tstruct list_head *n = (struct list_head *) node;\n\n\tslab->used--;\n\tif (slab->used) {\n\t\tif (list_empty(&slab->freelist)) {\n\t\t\tlist_del(&slab->list);\n\t\t\tlist_add_tail(&slab->list, &f->partial_slabs);\n\t\t}\n\t\tlist_add_head(n, &slab->freelist);\n\t} else {\n\t\tfree_slab(f, slab);\n\t}\n}\n#else\nstatic struct node *alloc_node(struct fuse *f)\n{\n\treturn (struct node *) calloc(1, get_node_size(f));\n}\n\nstatic void free_node_mem(struct fuse *f, struct node *node)\n{\n\t(void) f;\n\tfree(node);\n}\n#endif\n\nstatic size_t id_hash(struct fuse *f, fuse_ino_t ino)\n{\n\tuint64_t hash = ((uint32_t) ino * 2654435761U) % f->id_table.size;\n\tuint64_t oldhash = hash % (f->id_table.size / 2);\n\n\tif (oldhash >= f->id_table.split)\n\t\treturn oldhash;\n\telse\n\t\treturn hash;\n}\n\nstatic struct node *get_node_nocheck(struct fuse *f, fuse_ino_t nodeid)\n{\n\tsize_t hash = id_hash(f, nodeid);\n\tstruct node *node;\n\n\tfor (node = f->id_table.array[hash]; node != NULL; node = node->id_next)\n\t\tif (node->nodeid == nodeid)\n\t\t\treturn node;\n\n\treturn NULL;\n}\n\nstatic struct node *get_node(struct fuse *f, fuse_ino_t nodeid)\n{\n\tstruct node *node = get_node_nocheck(f, nodeid);\n\tif (!node) {\n\t\tfuse_log(FUSE_LOG_ERR, \"fuse internal error: node %llu not found\\n\",\n\t\t\t(unsigned long long) nodeid);\n\t\tabort();\n\t}\n\treturn node;\n}\n\nstatic void curr_time(struct timespec *now);\nstatic double diff_timespec(const struct timespec *t1,\n\t\t\t   const struct timespec *t2);\n\nstatic void remove_node_lru(struct node *node)\n{\n\tstruct node_lru *lnode = node_lru(node);\n\tlist_del(&lnode->lru);\n\tinit_list_head(&lnode->lru);\n}\n\nstatic void set_forget_time(struct fuse *f, struct node *node)\n{\n\tstruct node_lru *lnode = node_lru(node);\n\n\tlist_del(&lnode->lru);\n\tlist_add_tail(&lnode->lru, &f->lru_table);\n\tcurr_time(&lnode->forget_time);\n}\n\nstatic void free_node(struct fuse *f, struct node *node)\n{\n\tif (node->name != node->inline_name)\n\t\tfree(node->name);\n\tfree_node_mem(f, node);\n}\n\nstatic void node_table_reduce(struct node_table *t)\n{\n\tsize_t newsize = t->size / 2;\n\tvoid *newarray;\n\n\tif (newsize < NODE_TABLE_MIN_SIZE)\n\t\treturn;\n\n\tnewarray = realloc(t->array, sizeof(struct node *) * newsize);\n\tif (newarray != NULL)\n\t\tt->array = newarray;\n\n\tt->size = newsize;\n\tt->split = t->size / 2;\n}\n\nstatic void remerge_id(struct fuse *f)\n{\n\tstruct node_table *t = &f->id_table;\n\tint iter;\n\n\tif (t->split == 0)\n\t\tnode_table_reduce(t);\n\n\tfor (iter = 8; t->split > 0 && iter; iter--) {\n\t\tstruct node **upper;\n\n\t\tt->split--;\n\t\tupper = &t->array[t->split + t->size / 2];\n\t\tif (*upper) {\n\t\t\tstruct node **nodep;\n\n\t\t\tfor (nodep = &t->array[t->split]; *nodep;\n\t\t\t     nodep = &(*nodep)->id_next);\n\n\t\t\t*nodep = *upper;\n\t\t\t*upper = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void unhash_id(struct fuse *f, struct node *node)\n{\n\tstruct node **nodep = &f->id_table.array[id_hash(f, node->nodeid)];\n\n\tfor (; *nodep != NULL; nodep = &(*nodep)->id_next)\n\t\tif (*nodep == node) {\n\t\t\t*nodep = node->id_next;\n\t\t\tf->id_table.use--;\n\n\t\t\tif(f->id_table.use < f->id_table.size / 4)\n\t\t\t\tremerge_id(f);\n\t\t\treturn;\n\t\t}\n}\n\nstatic int node_table_resize(struct node_table *t)\n{\n\tsize_t newsize = t->size * 2;\n\tvoid *newarray;\n\n\tnewarray = realloc(t->array, sizeof(struct node *) * newsize);\n\tif (newarray == NULL)\n\t\treturn -1;\n\n\tt->array = newarray;\n\tmemset(t->array + t->size, 0, t->size * sizeof(struct node *));\n\tt->size = newsize;\n\tt->split = 0;\n\n\treturn 0;\n}\n\nstatic void rehash_id(struct fuse *f)\n{\n\tstruct node_table *t = &f->id_table;\n\tstruct node **nodep;\n\tstruct node **next;\n\tsize_t hash;\n\n\tif (t->split == t->size / 2)\n\t\treturn;\n\n\thash = t->split;\n\tt->split++;\n\tfor (nodep = &t->array[hash]; *nodep != NULL; nodep = next) {\n\t\tstruct node *node = *nodep;\n\t\tsize_t newhash = id_hash(f, node->nodeid);\n\n\t\tif (newhash != hash) {\n\t\t\tnext = nodep;\n\t\t\t*nodep = node->id_next;\n\t\t\tnode->id_next = t->array[newhash];\n\t\t\tt->array[newhash] = node;\n\t\t} else {\n\t\t\tnext = &node->id_next;\n\t\t}\n\t}\n\tif (t->split == t->size / 2)\n\t\tnode_table_resize(t);\n}\n\nstatic void hash_id(struct fuse *f, struct node *node)\n{\n\tsize_t hash = id_hash(f, node->nodeid);\n\tnode->id_next = f->id_table.array[hash];\n\tf->id_table.array[hash] = node;\n\tf->id_table.use++;\n\n\tif (f->id_table.use >= f->id_table.size / 2)\n\t\trehash_id(f);\n}\n\nstatic size_t name_hash(struct fuse *f, fuse_ino_t parent,\n\t\t\tconst char *name)\n{\n\tuint64_t hash = parent;\n\tuint64_t oldhash;\n\n\tfor (; *name; name++)\n\t\thash = hash * 31 + (unsigned char) *name;\n\n\thash %= f->name_table.size;\n\toldhash = hash % (f->name_table.size / 2);\n\tif (oldhash >= f->name_table.split)\n\t\treturn oldhash;\n\telse\n\t\treturn hash;\n}\n\nstatic void unref_node(struct fuse *f, struct node *node);\n\nstatic void remerge_name(struct fuse *f)\n{\n\tstruct node_table *t = &f->name_table;\n\tint iter;\n\n\tif (t->split == 0)\n\t\tnode_table_reduce(t);\n\n\tfor (iter = 8; t->split > 0 && iter; iter--) {\n\t\tstruct node **upper;\n\n\t\tt->split--;\n\t\tupper = &t->array[t->split + t->size / 2];\n\t\tif (*upper) {\n\t\t\tstruct node **nodep;\n\n\t\t\tfor (nodep = &t->array[t->split]; *nodep;\n\t\t\t     nodep = &(*nodep)->name_next);\n\n\t\t\t*nodep = *upper;\n\t\t\t*upper = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void unhash_name(struct fuse *f, struct node *node)\n{\n\tif (node->name) {\n\t\tsize_t hash = name_hash(f, node->parent->nodeid, node->name);\n\t\tstruct node **nodep = &f->name_table.array[hash];\n\n\t\tfor (; *nodep != NULL; nodep = &(*nodep)->name_next)\n\t\t\tif (*nodep == node) {\n\t\t\t\t*nodep = node->name_next;\n\t\t\t\tnode->name_next = NULL;\n\t\t\t\tunref_node(f, node->parent);\n\t\t\t\tif (node->name != node->inline_name)\n\t\t\t\t\tfree(node->name);\n\t\t\t\tnode->name = NULL;\n\t\t\t\tnode->parent = NULL;\n\t\t\t\tf->name_table.use--;\n\n\t\t\t\tif (f->name_table.use < f->name_table.size / 4)\n\t\t\t\t\tremerge_name(f);\n\t\t\t\treturn;\n\t\t\t}\n\t\tfuse_log(FUSE_LOG_ERR,\n\t\t\t\"fuse internal error: unable to unhash node: %llu\\n\",\n\t\t\t(unsigned long long) node->nodeid);\n\t\tabort();\n\t}\n}\n\nstatic void rehash_name(struct fuse *f)\n{\n\tstruct node_table *t = &f->name_table;\n\tstruct node **nodep;\n\tstruct node **next;\n\tsize_t hash;\n\n\tif (t->split == t->size / 2)\n\t\treturn;\n\n\thash = t->split;\n\tt->split++;\n\tfor (nodep = &t->array[hash]; *nodep != NULL; nodep = next) {\n\t\tstruct node *node = *nodep;\n\t\tsize_t newhash = name_hash(f, node->parent->nodeid, node->name);\n\n\t\tif (newhash != hash) {\n\t\t\tnext = nodep;\n\t\t\t*nodep = node->name_next;\n\t\t\tnode->name_next = t->array[newhash];\n\t\t\tt->array[newhash] = node;\n\t\t} else {\n\t\t\tnext = &node->name_next;\n\t\t}\n\t}\n\tif (t->split == t->size / 2)\n\t\tnode_table_resize(t);\n}\n\nstatic int hash_name(struct fuse *f, struct node *node, fuse_ino_t parentid,\n\t\t     const char *name)\n{\n\tsize_t hash = name_hash(f, parentid, name);\n\tstruct node *parent = get_node(f, parentid);\n\tif (strlen(name) < sizeof(node->inline_name)) {\n\t\tstrcpy(node->inline_name, name);\n\t\tnode->name = node->inline_name;\n\t} else {\n\t\tnode->name = strdup(name);\n\t\tif (node->name == NULL)\n\t\t\treturn -1;\n\t}\n\n\tparent->refctr ++;\n\tnode->parent = parent;\n\tnode->name_next = f->name_table.array[hash];\n\tf->name_table.array[hash] = node;\n\tf->name_table.use++;\n\n\tif (f->name_table.use >= f->name_table.size / 2)\n\t\trehash_name(f);\n\n\treturn 0;\n}\n\nstatic void delete_node(struct fuse *f, struct node *node)\n{\n\tif (f->conf.debug)\n\t\tfuse_log(FUSE_LOG_DEBUG, \"DELETE: %llu\\n\",\n\t\t\t(unsigned long long) node->nodeid);\n\n\tassert(node->treelock == 0);\n\tunhash_name(f, node);\n\tif (lru_enabled(f))\n\t\tremove_node_lru(node);\n\tunhash_id(f, node);\n\tfree_node(f, node);\n}\n\nstatic void unref_node(struct fuse *f, struct node *node)\n{\n\tassert(node->refctr > 0);\n\tnode->refctr --;\n\tif (!node->refctr)\n\t\tdelete_node(f, node);\n}\n\nstatic fuse_ino_t next_id(struct fuse *f)\n{\n\tdo {\n\t\tf->ctr = (f->ctr + 1) & 0xffffffff;\n\t\tif (!f->ctr)\n\t\t\tf->generation ++;\n\t} while (f->ctr == 0 || f->ctr == FUSE_UNKNOWN_INO ||\n\t\t get_node_nocheck(f, f->ctr) != NULL);\n\treturn f->ctr;\n}\n\nstatic struct node *lookup_node(struct fuse *f, fuse_ino_t parent,\n\t\t\t\tconst char *name)\n{\n\tsize_t hash = name_hash(f, parent, name);\n\tstruct node *node;\n\n\tfor (node = f->name_table.array[hash]; node != NULL; node = node->name_next)\n\t\tif (node->parent->nodeid == parent &&\n\t\t    strcmp(node->name, name) == 0)\n\t\t\treturn node;\n\n\treturn NULL;\n}\n\nstatic void inc_nlookup(struct node *node)\n{\n\tif (!node->nlookup)\n\t\tnode->refctr++;\n\tnode->nlookup++;\n}\n\nstatic struct node *find_node(struct fuse *f, fuse_ino_t parent,\n\t\t\t      const char *name)\n{\n\tstruct node *node;\n\n\tpthread_mutex_lock(&f->lock);\n\tif (!name)\n\t\tnode = get_node(f, parent);\n\telse\n\t\tnode = lookup_node(f, parent, name);\n\tif (node == NULL) {\n\t\tnode = alloc_node(f);\n\t\tif (node == NULL)\n\t\t\tgoto out_err;\n\n\t\tnode->nodeid = next_id(f);\n\t\tnode->generation = f->generation;\n\t\tif (f->conf.remember)\n\t\t\tinc_nlookup(node);\n\n\t\tif (hash_name(f, node, parent, name) == -1) {\n\t\t\tfree_node(f, node);\n\t\t\tnode = NULL;\n\t\t\tgoto out_err;\n\t\t}\n\t\thash_id(f, node);\n\t\tif (lru_enabled(f)) {\n\t\t\tstruct node_lru *lnode = node_lru(node);\n\t\t\tinit_list_head(&lnode->lru);\n\t\t}\n\t} else if (lru_enabled(f) && node->nlookup == 1) {\n\t\tremove_node_lru(node);\n\t}\n\tinc_nlookup(node);\nout_err:\n\tpthread_mutex_unlock(&f->lock);\n\treturn node;\n}\n\nstatic int lookup_path_in_cache(struct fuse *f,\n\t\tconst char *path, fuse_ino_t *inop)\n{\n\tchar *tmp = strdup(path);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tpthread_mutex_lock(&f->lock);\n\tfuse_ino_t ino = FUSE_ROOT_ID;\n\n\tint err = 0;\n\tchar *save_ptr;\n\tchar *path_element = strtok_r(tmp, \"/\", &save_ptr);\n\twhile (path_element != NULL) {\n\t\tstruct node *node = lookup_node(f, ino, path_element);\n\t\tif (node == NULL) {\n\t\t\terr = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\tino = node->nodeid;\n\t\tpath_element = strtok_r(NULL, \"/\", &save_ptr);\n\t}\n\tpthread_mutex_unlock(&f->lock);\n\tfree(tmp);\n\n\tif (!err)\n\t\t*inop = ino;\n\treturn err;\n}\n\nstatic char *add_name(char **buf, unsigned *bufsize, char *s, const char *name)\n{\n\tsize_t len = strlen(name);\n\n\tif (s - len <= *buf) {\n\t\tunsigned pathlen = *bufsize - (s - *buf);\n\t\tunsigned newbufsize = *bufsize;\n\t\tchar *newbuf;\n\n\t\twhile (newbufsize < pathlen + len + 1) {\n\t\t\tif (newbufsize >= 0x80000000)\n\t\t\t\tnewbufsize = 0xffffffff;\n\t\t\telse\n\t\t\t\tnewbufsize *= 2;\n\t\t}\n\n\t\tnewbuf = realloc(*buf, newbufsize);\n\t\tif (newbuf == NULL)\n\t\t\treturn NULL;\n\n\t\t*buf = newbuf;\n\t\ts = newbuf + newbufsize - pathlen;\n\t\tmemmove(s, newbuf + *bufsize - pathlen, pathlen);\n\t\t*bufsize = newbufsize;\n\t}\n\ts -= len;\n\tmemcpy(s, name, len);\n\ts--;\n\t*s = '/';\n\n\treturn s;\n}\n\nstatic void unlock_path(struct fuse *f, fuse_ino_t nodeid, struct node *wnode,\n\t\t\tstruct node *end)\n{\n\tstruct node *node;\n\n\tif (wnode) {\n\t\tassert(wnode->treelock == TREELOCK_WRITE);\n\t\twnode->treelock = 0;\n\t}\n\n\tfor (node = get_node(f, nodeid);\n\t     node != end && node->nodeid != FUSE_ROOT_ID; node = node->parent) {\n\t\tassert(node->treelock != 0);\n\t\tassert(node->treelock != TREELOCK_WAIT_OFFSET);\n\t\tassert(node->treelock != TREELOCK_WRITE);\n\t\tnode->treelock--;\n\t\tif (node->treelock == TREELOCK_WAIT_OFFSET)\n\t\t\tnode->treelock = 0;\n\t}\n}\n\nstatic int try_get_path(struct fuse *f, fuse_ino_t nodeid, const char *name,\n\t\t\tchar **path, struct node **wnodep, bool need_lock)\n{\n\tunsigned bufsize = 256;\n\tchar *buf;\n\tchar *s;\n\tstruct node *node;\n\tstruct node *wnode = NULL;\n\tint err;\n\n\t*path = NULL;\n\n\terr = -ENOMEM;\n\tbuf = malloc(bufsize);\n\tif (buf == NULL)\n\t\tgoto out_err;\n\n\ts = buf + bufsize - 1;\n\t*s = '\\0';\n\n\tif (name != NULL) {\n\t\ts = add_name(&buf, &bufsize, s, name);\n\t\terr = -ENOMEM;\n\t\tif (s == NULL)\n\t\t\tgoto out_free;\n\t}\n\n\tif (wnodep) {\n\t\tassert(need_lock);\n\t\twnode = lookup_node(f, nodeid, name);\n\t\tif (wnode) {\n\t\t\tif (wnode->treelock != 0) {\n\t\t\t\tif (wnode->treelock > 0)\n\t\t\t\t\twnode->treelock += TREELOCK_WAIT_OFFSET;\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\twnode->treelock = TREELOCK_WRITE;\n\t\t}\n\t}\n\n\tfor (node = get_node(f, nodeid); node->nodeid != FUSE_ROOT_ID;\n\t     node = node->parent) {\n\t\terr = -ENOENT;\n\t\tif (node->name == NULL || node->parent == NULL)\n\t\t\tgoto out_unlock;\n\n\t\terr = -ENOMEM;\n\t\ts = add_name(&buf, &bufsize, s, node->name);\n\t\tif (s == NULL)\n\t\t\tgoto out_unlock;\n\n\t\tif (need_lock) {\n\t\t\terr = -EAGAIN;\n\t\t\tif (node->treelock < 0)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tnode->treelock++;\n\t\t}\n\t}\n\n\tif (s[0])\n\t\tmemmove(buf, s, bufsize - (s - buf));\n\telse\n\t\tstrcpy(buf, \"/\");\n\n\t*path = buf;\n\tif (wnodep)\n\t\t*wnodep = wnode;\n\n\treturn 0;\n\n out_unlock:\n\tif (need_lock)\n\t\tunlock_path(f, nodeid, wnode, node);\n out_free:\n\tfree(buf);\n\n out_err:\n\treturn err;\n}\n\nstatic void queue_element_unlock(struct fuse *f, struct lock_queue_element *qe)\n{\n\tstruct node *wnode;\n\n\tif (qe->first_locked) {\n\t\twnode = qe->wnode1 ? *qe->wnode1 : NULL;\n\t\tunlock_path(f, qe->nodeid1, wnode, NULL);\n\t\tqe->first_locked = false;\n\t}\n\tif (qe->second_locked) {\n\t\twnode = qe->wnode2 ? *qe->wnode2 : NULL;\n\t\tunlock_path(f, qe->nodeid2, wnode, NULL);\n\t\tqe->second_locked = false;\n\t}\n}\n\nstatic void queue_element_wakeup(struct fuse *f, struct lock_queue_element *qe)\n{\n\tint err;\n\tbool first = (qe == f->lockq);\n\n\tif (!qe->path1) {\n\t\t/* Just waiting for it to be unlocked */\n\t\tif (get_node(f, qe->nodeid1)->treelock == 0)\n\t\t\tpthread_cond_signal(&qe->cond);\n\n\t\treturn;\n\t}\n\n\tif (!qe->first_locked) {\n\t\terr = try_get_path(f, qe->nodeid1, qe->name1, qe->path1,\n\t\t\t\t   qe->wnode1, true);\n\t\tif (!err)\n\t\t\tqe->first_locked = true;\n\t\telse if (err != -EAGAIN)\n\t\t\tgoto err_unlock;\n\t}\n\tif (!qe->second_locked && qe->path2) {\n\t\terr = try_get_path(f, qe->nodeid2, qe->name2, qe->path2,\n\t\t\t\t   qe->wnode2, true);\n\t\tif (!err)\n\t\t\tqe->second_locked = true;\n\t\telse if (err != -EAGAIN)\n\t\t\tgoto err_unlock;\n\t}\n\n\tif (qe->first_locked && (qe->second_locked || !qe->path2)) {\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Only let the first element be partially locked otherwise there could\n\t * be a deadlock.\n\t *\n\t * But do allow the first element to be partially locked to prevent\n\t * starvation.\n\t */\n\tif (!first)\n\t\tqueue_element_unlock(f, qe);\n\n\t/* keep trying */\n\treturn;\n\nerr_unlock:\n\tqueue_element_unlock(f, qe);\ndone:\n\tqe->err = err;\n\tqe->done = true;\n\tpthread_cond_signal(&qe->cond);\n}\n\nstatic void wake_up_queued(struct fuse *f)\n{\n\tstruct lock_queue_element *qe;\n\n\tfor (qe = f->lockq; qe != NULL; qe = qe->next)\n\t\tqueue_element_wakeup(f, qe);\n}\n\nstatic void debug_path(struct fuse *f, const char *msg, fuse_ino_t nodeid,\n\t\t       const char *name, bool wr)\n{\n\tif (f->conf.debug) {\n\t\tstruct node *wnode = NULL;\n\n\t\tif (wr)\n\t\t\twnode = lookup_node(f, nodeid, name);\n\n\t\tif (wnode) {\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"%s %llu (w)\\n\",\n\t\t\t\tmsg, (unsigned long long) wnode->nodeid);\n\t\t} else {\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"%s %llu\\n\",\n\t\t\t\tmsg, (unsigned long long) nodeid);\n\t\t}\n\t}\n}\n\nstatic void queue_path(struct fuse *f, struct lock_queue_element *qe)\n{\n\tstruct lock_queue_element **qp;\n\n\tqe->done = false;\n\tqe->first_locked = false;\n\tqe->second_locked = false;\n\tpthread_cond_init(&qe->cond, NULL);\n\tqe->next = NULL;\n\tfor (qp = &f->lockq; *qp != NULL; qp = &(*qp)->next);\n\t*qp = qe;\n}\n\nstatic void dequeue_path(struct fuse *f, struct lock_queue_element *qe)\n{\n\tstruct lock_queue_element **qp;\n\n\tpthread_cond_destroy(&qe->cond);\n\tfor (qp = &f->lockq; *qp != qe; qp = &(*qp)->next);\n\t*qp = qe->next;\n}\n\nstatic int wait_path(struct fuse *f, struct lock_queue_element *qe)\n{\n\tqueue_path(f, qe);\n\n\tdo {\n\t\tpthread_cond_wait(&qe->cond, &f->lock);\n\t} while (!qe->done);\n\n\tdequeue_path(f, qe);\n\n\treturn qe->err;\n}\n\nstatic int get_path_common(struct fuse *f, fuse_ino_t nodeid, const char *name,\n\t\t\t   char **path, struct node **wnode)\n{\n\tint err;\n\n\tpthread_mutex_lock(&f->lock);\n\terr = try_get_path(f, nodeid, name, path, wnode, true);\n\tif (err == -EAGAIN) {\n\t\tstruct lock_queue_element qe = {\n\t\t\t.nodeid1 = nodeid,\n\t\t\t.name1 = name,\n\t\t\t.path1 = path,\n\t\t\t.wnode1 = wnode,\n\t\t};\n\t\tdebug_path(f, \"QUEUE PATH\", nodeid, name, !!wnode);\n\t\terr = wait_path(f, &qe);\n\t\tdebug_path(f, \"DEQUEUE PATH\", nodeid, name, !!wnode);\n\t}\n\tpthread_mutex_unlock(&f->lock);\n\n\treturn err;\n}\n\nstatic int get_path(struct fuse *f, fuse_ino_t nodeid, char **path)\n{\n\treturn get_path_common(f, nodeid, NULL, path, NULL);\n}\n\nstatic int get_path_nullok(struct fuse *f, fuse_ino_t nodeid, char **path)\n{\n\tint err = 0;\n\n\tif (f->conf.nullpath_ok) {\n\t\t*path = NULL;\n\t} else {\n\t\terr = get_path_common(f, nodeid, NULL, path, NULL);\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t}\n\n\treturn err;\n}\n\nstatic int get_path_name(struct fuse *f, fuse_ino_t nodeid, const char *name,\n\t\t\t char **path)\n{\n\treturn get_path_common(f, nodeid, name, path, NULL);\n}\n\nstatic int get_path_wrlock(struct fuse *f, fuse_ino_t nodeid, const char *name,\n\t\t\t   char **path, struct node **wnode)\n{\n\treturn get_path_common(f, nodeid, name, path, wnode);\n}\n\n#if defined(__FreeBSD__)\n#define CHECK_DIR_LOOP\n#endif\n\n#if defined(CHECK_DIR_LOOP)\nstatic int check_dir_loop(struct fuse *f,\n\t\t\t  fuse_ino_t nodeid1, const char *name1,\n\t\t\t  fuse_ino_t nodeid2, const char *name2)\n{\n\tstruct node *node, *node1, *node2;\n\tfuse_ino_t id1, id2;\n\n\tnode1 = lookup_node(f, nodeid1, name1);\n\tid1 = node1 ? node1->nodeid : nodeid1;\n\n\tnode2 = lookup_node(f, nodeid2, name2);\n\tid2 = node2 ? node2->nodeid : nodeid2;\n\n\tfor (node = get_node(f, id2); node->nodeid != FUSE_ROOT_ID;\n\t     node = node->parent) {\n\t\tif (node->name == NULL || node->parent == NULL)\n\t\t\tbreak;\n\n\t\tif (node->nodeid != id2 && node->nodeid == id1)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (node2)\n\t{\n\t\tfor (node = get_node(f, id1); node->nodeid != FUSE_ROOT_ID;\n\t\t     node = node->parent) {\n\t\t\tif (node->name == NULL || node->parent == NULL)\n\t\t\t\tbreak;\n\n\t\t\tif (node->nodeid != id1 && node->nodeid == id2)\n\t\t\t\treturn -ENOTEMPTY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int try_get_path2(struct fuse *f, fuse_ino_t nodeid1, const char *name1,\n\t\t\t fuse_ino_t nodeid2, const char *name2,\n\t\t\t char **path1, char **path2,\n\t\t\t struct node **wnode1, struct node **wnode2)\n{\n\tint err;\n\n\t/* FIXME: locking two paths needs deadlock checking */\n\terr = try_get_path(f, nodeid1, name1, path1, wnode1, true);\n\tif (!err) {\n\t\terr = try_get_path(f, nodeid2, name2, path2, wnode2, true);\n\t\tif (err) {\n\t\t\tstruct node *wn1 = wnode1 ? *wnode1 : NULL;\n\n\t\t\tunlock_path(f, nodeid1, wn1, NULL);\n\t\t\tfree(*path1);\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int get_path2(struct fuse *f, fuse_ino_t nodeid1, const char *name1,\n\t\t     fuse_ino_t nodeid2, const char *name2,\n\t\t     char **path1, char **path2,\n\t\t     struct node **wnode1, struct node **wnode2)\n{\n\tint err;\n\n\tpthread_mutex_lock(&f->lock);\n\n#if defined(CHECK_DIR_LOOP)\n\tif (name1)\n\t{\n\t\t// called during rename; perform dir loop check\n\t\terr = check_dir_loop(f, nodeid1, name1, nodeid2, name2);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n#endif\n\n\terr = try_get_path2(f, nodeid1, name1, nodeid2, name2,\n\t\t\t    path1, path2, wnode1, wnode2);\n\tif (err == -EAGAIN) {\n\t\tstruct lock_queue_element qe = {\n\t\t\t.nodeid1 = nodeid1,\n\t\t\t.name1 = name1,\n\t\t\t.path1 = path1,\n\t\t\t.wnode1 = wnode1,\n\t\t\t.nodeid2 = nodeid2,\n\t\t\t.name2 = name2,\n\t\t\t.path2 = path2,\n\t\t\t.wnode2 = wnode2,\n\t\t};\n\n\t\tdebug_path(f, \"QUEUE PATH1\", nodeid1, name1, !!wnode1);\n\t\tdebug_path(f, \"      PATH2\", nodeid2, name2, !!wnode2);\n\t\terr = wait_path(f, &qe);\n\t\tdebug_path(f, \"DEQUEUE PATH1\", nodeid1, name1, !!wnode1);\n\t\tdebug_path(f, \"        PATH2\", nodeid2, name2, !!wnode2);\n\t}\n\n#if defined(CHECK_DIR_LOOP)\nout_unlock:\n#endif\n\tpthread_mutex_unlock(&f->lock);\n\n\treturn err;\n}\n\nstatic void free_path_wrlock(struct fuse *f, fuse_ino_t nodeid,\n\t\t\t     struct node *wnode, char *path)\n{\n\tpthread_mutex_lock(&f->lock);\n\tunlock_path(f, nodeid, wnode, NULL);\n\tif (f->lockq)\n\t\twake_up_queued(f);\n\tpthread_mutex_unlock(&f->lock);\n\tfree(path);\n}\n\nstatic void free_path(struct fuse *f, fuse_ino_t nodeid, char *path)\n{\n\tif (path)\n\t\tfree_path_wrlock(f, nodeid, NULL, path);\n}\n\nstatic void free_path2(struct fuse *f, fuse_ino_t nodeid1, fuse_ino_t nodeid2,\n\t\t       struct node *wnode1, struct node *wnode2,\n\t\t       char *path1, char *path2)\n{\n\tpthread_mutex_lock(&f->lock);\n\tunlock_path(f, nodeid1, wnode1, NULL);\n\tunlock_path(f, nodeid2, wnode2, NULL);\n\twake_up_queued(f);\n\tpthread_mutex_unlock(&f->lock);\n\tfree(path1);\n\tfree(path2);\n}\n\nstatic void forget_node(struct fuse *f, fuse_ino_t nodeid, uint64_t nlookup)\n{\n\tstruct node *node;\n\tif (nodeid == FUSE_ROOT_ID)\n\t\treturn;\n\tpthread_mutex_lock(&f->lock);\n\tnode = get_node(f, nodeid);\n\n\t/*\n\t * Node may still be locked due to interrupt idiocy in open,\n\t * create and opendir\n\t */\n\twhile (node->nlookup == nlookup && node->treelock) {\n\t\tstruct lock_queue_element qe = {\n\t\t\t.nodeid1 = nodeid,\n\t\t};\n\n\t\tdebug_path(f, \"QUEUE PATH (forget)\", nodeid, NULL, false);\n\t\tqueue_path(f, &qe);\n\n\t\tdo {\n\t\t\tpthread_cond_wait(&qe.cond, &f->lock);\n\t\t} while (node->nlookup == nlookup && node->treelock);\n\n\t\tdequeue_path(f, &qe);\n\t\tdebug_path(f, \"DEQUEUE_PATH (forget)\", nodeid, NULL, false);\n\t}\n\n\tassert(node->nlookup >= nlookup);\n\tnode->nlookup -= nlookup;\n\tif (!node->nlookup) {\n\t\tunref_node(f, node);\n\t} else if (lru_enabled(f) && node->nlookup == 1) {\n\t\tset_forget_time(f, node);\n\t}\n\tpthread_mutex_unlock(&f->lock);\n}\n\nstatic void unlink_node(struct fuse *f, struct node *node)\n{\n\tif (f->conf.remember) {\n\t\tassert(node->nlookup > 1);\n\t\tnode->nlookup--;\n\t}\n\tunhash_name(f, node);\n}\n\nstatic void remove_node(struct fuse *f, fuse_ino_t dir, const char *name)\n{\n\tstruct node *node;\n\n\tpthread_mutex_lock(&f->lock);\n\tnode = lookup_node(f, dir, name);\n\tif (node != NULL)\n\t\tunlink_node(f, node);\n\tpthread_mutex_unlock(&f->lock);\n}\n\nstatic int rename_node(struct fuse *f, fuse_ino_t olddir, const char *oldname,\n\t\t       fuse_ino_t newdir, const char *newname, int hide)\n{\n\tstruct node *node;\n\tstruct node *newnode;\n\tint err = 0;\n\n\tpthread_mutex_lock(&f->lock);\n\tnode  = lookup_node(f, olddir, oldname);\n\tnewnode\t = lookup_node(f, newdir, newname);\n\tif (node == NULL)\n\t\tgoto out;\n\n\tif (newnode != NULL) {\n\t\tif (hide) {\n\t\t\tfuse_log(FUSE_LOG_ERR, \"fuse: hidden file got created during hiding\\n\");\n\t\t\terr = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tunlink_node(f, newnode);\n\t}\n\n\tunhash_name(f, node);\n\tif (hash_name(f, node, newdir, newname) == -1) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (hide)\n\t\tnode->is_hidden = 1;\n\nout:\n\tpthread_mutex_unlock(&f->lock);\n\treturn err;\n}\n\nstatic int exchange_node(struct fuse *f, fuse_ino_t olddir, const char *oldname,\n\t\t\t fuse_ino_t newdir, const char *newname)\n{\n\tstruct node *oldnode;\n\tstruct node *newnode;\n\tint err;\n\n\tpthread_mutex_lock(&f->lock);\n\toldnode  = lookup_node(f, olddir, oldname);\n\tnewnode\t = lookup_node(f, newdir, newname);\n\n\tif (oldnode)\n\t\tunhash_name(f, oldnode);\n\tif (newnode)\n\t\tunhash_name(f, newnode);\n\n\terr = -ENOMEM;\n\tif (oldnode) {\n\t\tif (hash_name(f, oldnode, newdir, newname) == -1)\n\t\t\tgoto out;\n\t}\n\tif (newnode) {\n\t\tif (hash_name(f, newnode, olddir, oldname) == -1)\n\t\t\tgoto out;\n\t}\n\terr = 0;\nout:\n\tpthread_mutex_unlock(&f->lock);\n\treturn err;\n}\n\nstatic void set_stat(struct fuse *f, fuse_ino_t nodeid, struct stat *stbuf)\n{\n\tif (!f->conf.use_ino)\n\t\tstbuf->st_ino = nodeid;\n\tif (f->conf.set_mode)\n\t\tstbuf->st_mode = (stbuf->st_mode & S_IFMT) |\n\t\t\t\t (0777 & ~f->conf.umask);\n\tif (f->conf.set_uid)\n\t\tstbuf->st_uid = f->conf.uid;\n\tif (f->conf.set_gid)\n\t\tstbuf->st_gid = f->conf.gid;\n}\n\nstatic struct fuse *req_fuse(fuse_req_t req)\n{\n\treturn (struct fuse *) fuse_req_userdata(req);\n}\n\nstatic void fuse_intr_sighandler(int sig)\n{\n\t(void) sig;\n\t/* Nothing to do */\n}\n\nstruct fuse_intr_data {\n\tpthread_t id;\n\tpthread_cond_t cond;\n\tint finished;\n};\n\nstatic void fuse_interrupt(fuse_req_t req, void *d_)\n{\n\tstruct fuse_intr_data *d = d_;\n\tstruct fuse *f = req_fuse(req);\n\n\tif (d->id == pthread_self())\n\t\treturn;\n\n\tpthread_mutex_lock(&f->lock);\n\twhile (!d->finished) {\n\t\tstruct timeval now;\n\t\tstruct timespec timeout;\n\n\t\tpthread_kill(d->id, f->conf.intr_signal);\n\t\tgettimeofday(&now, NULL);\n\t\ttimeout.tv_sec = now.tv_sec + 1;\n\t\ttimeout.tv_nsec = now.tv_usec * 1000;\n\t\tpthread_cond_timedwait(&d->cond, &f->lock, &timeout);\n\t}\n\tpthread_mutex_unlock(&f->lock);\n}\n\nstatic void fuse_do_finish_interrupt(struct fuse *f, fuse_req_t req,\n\t\t\t\t     struct fuse_intr_data *d)\n{\n\tpthread_mutex_lock(&f->lock);\n\td->finished = 1;\n\tpthread_cond_broadcast(&d->cond);\n\tpthread_mutex_unlock(&f->lock);\n\tfuse_req_interrupt_func(req, NULL, NULL);\n\tpthread_cond_destroy(&d->cond);\n}\n\nstatic void fuse_do_prepare_interrupt(fuse_req_t req, struct fuse_intr_data *d)\n{\n\td->id = pthread_self();\n\tpthread_cond_init(&d->cond, NULL);\n\td->finished = 0;\n\tfuse_req_interrupt_func(req, fuse_interrupt, d);\n}\n\nstatic inline void fuse_finish_interrupt(struct fuse *f, fuse_req_t req,\n\t\t\t\t\t struct fuse_intr_data *d)\n{\n\tif (f->conf.intr)\n\t\tfuse_do_finish_interrupt(f, req, d);\n}\n\nstatic inline void fuse_prepare_interrupt(struct fuse *f, fuse_req_t req,\n\t\t\t\t\t  struct fuse_intr_data *d)\n{\n\tif (f->conf.intr)\n\t\tfuse_do_prepare_interrupt(req, d);\n}\n\nstatic const char* file_info_string(struct fuse_file_info *fi,\n\t\t\t      char* buf, size_t len)\n{\n\tif(fi == NULL)\n\t\treturn \"NULL\";\n\tsnprintf(buf, len, \"%llu\", (unsigned long long) fi->fh);\n\treturn buf;\n}\n\nint fuse_fs_getattr(struct fuse_fs *fs, const char *path, struct stat *buf,\n\t\t    struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.getattr) {\n\t\tif (fs->debug) {\n\t\t\tchar buf[10];\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"getattr[%s] %s\\n\",\n\t\t\t\tfile_info_string(fi, buf, sizeof(buf)),\n\t\t\t\tpath);\n\t\t}\n\t\treturn fs->op.getattr(path, buf, fi);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_rename(struct fuse_fs *fs, const char *oldpath,\n\t\t   const char *newpath, unsigned int flags)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.rename) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"rename %s %s 0x%x\\n\", oldpath, newpath,\n\t\t\t\tflags);\n\n\t\treturn fs->op.rename(oldpath, newpath, flags);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_unlink(struct fuse_fs *fs, const char *path)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.unlink) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"unlink %s\\n\", path);\n\n\t\treturn fs->op.unlink(path);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_rmdir(struct fuse_fs *fs, const char *path)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.rmdir) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"rmdir %s\\n\", path);\n\n\t\treturn fs->op.rmdir(path);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_symlink(struct fuse_fs *fs, const char *linkname, const char *path)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.symlink) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"symlink %s %s\\n\", linkname, path);\n\n\t\treturn fs->op.symlink(linkname, path);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_link(struct fuse_fs *fs, const char *oldpath, const char *newpath)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.link) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"link %s %s\\n\", oldpath, newpath);\n\n\t\treturn fs->op.link(oldpath, newpath);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_release(struct fuse_fs *fs,\t const char *path,\n\t\t    struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.release) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"release%s[%llu] flags: 0x%x\\n\",\n\t\t\t\tfi->flush ? \"+flush\" : \"\",\n\t\t\t\t(unsigned long long) fi->fh, fi->flags);\n\n\t\treturn fs->op.release(path, fi);\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nint fuse_fs_opendir(struct fuse_fs *fs, const char *path,\n\t\t    struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.opendir) {\n\t\tint err;\n\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"opendir flags: 0x%x %s\\n\", fi->flags,\n\t\t\t\tpath);\n\n\t\terr = fs->op.opendir(path, fi);\n\n\t\tif (fs->debug && !err)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"   opendir[%llu] flags: 0x%x %s\\n\",\n\t\t\t\t(unsigned long long) fi->fh, fi->flags, path);\n\n\t\treturn err;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nint fuse_fs_open(struct fuse_fs *fs, const char *path,\n\t\t struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.open) {\n\t\tint err;\n\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"open flags: 0x%x %s\\n\", fi->flags,\n\t\t\t\tpath);\n\n\t\terr = fs->op.open(path, fi);\n\n\t\tif (fs->debug && !err)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"   open[%llu] flags: 0x%x %s\\n\",\n\t\t\t\t(unsigned long long) fi->fh, fi->flags, path);\n\n\t\treturn err;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic void fuse_free_buf(struct fuse_bufvec *buf)\n{\n\tif (buf != NULL) {\n\t\tsize_t i;\n\n\t\tfor (i = 0; i < buf->count; i++)\n\t\t\tif (!(buf->buf[i].flags & FUSE_BUF_IS_FD))\n\t\t\t\tfree(buf->buf[i].mem);\n\t\tfree(buf);\n\t}\n}\n\nint fuse_fs_read_buf(struct fuse_fs *fs, const char *path,\n\t\t     struct fuse_bufvec **bufp, size_t size, off_t off,\n\t\t     struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.read || fs->op.read_buf) {\n\t\tint res;\n\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG,\n\t\t\t\t\"read[%llu] %zu bytes from %llu flags: 0x%x\\n\",\n\t\t\t\t(unsigned long long) fi->fh,\n\t\t\t\tsize, (unsigned long long) off, fi->flags);\n\n\t\tif (fs->op.read_buf) {\n\t\t\tres = fs->op.read_buf(path, bufp, size, off, fi);\n\t\t} else {\n\t\t\tstruct fuse_bufvec *buf;\n\t\t\tvoid *mem;\n\n\t\t\tbuf = malloc(sizeof(struct fuse_bufvec));\n\t\t\tif (buf == NULL)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmem = malloc(size);\n\t\t\tif (mem == NULL) {\n\t\t\t\tfree(buf);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\t*buf = FUSE_BUFVEC_INIT(size);\n\t\t\tbuf->buf[0].mem = mem;\n\t\t\t*bufp = buf;\n\n\t\t\tres = fs->op.read(path, mem, size, off, fi);\n\t\t\tif (res >= 0)\n\t\t\t\tbuf->buf[0].size = res;\n\t\t}\n\n\t\tif (fs->debug && res >= 0)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"   read[%llu] %zu bytes from %llu\\n\",\n\t\t\t\t(unsigned long long) fi->fh,\n\t\t\t\tfuse_buf_size(*bufp),\n\t\t\t\t(unsigned long long) off);\n\t\tif (res >= 0 && fuse_buf_size(*bufp) > size)\n\t\t\tfuse_log(FUSE_LOG_ERR, \"fuse: read too many bytes\\n\");\n\n\t\tif (res < 0)\n\t\t\treturn res;\n\n\t\treturn 0;\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_read(struct fuse_fs *fs, const char *path, char *mem, size_t size,\n\t\t off_t off, struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.read || fs->op.read_buf) {\n\t\tint res;\n\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG,\n\t\t\t\t\"read[%llu] %zu bytes from %llu flags: 0x%x\\n\",\n\t\t\t\t(unsigned long long) fi->fh,\n\t\t\t\tsize, (unsigned long long) off, fi->flags);\n\n\t\tif (fs->op.read_buf) {\n\t\t\tstruct fuse_bufvec *buf = NULL;\n\n\t\t\tres = fs->op.read_buf(path, &buf, size, off, fi);\n\t\t\tif (res == 0) {\n\t\t\t\tstruct fuse_bufvec dst = FUSE_BUFVEC_INIT(size);\n\n\t\t\t\tdst.buf[0].mem = mem;\n\t\t\t\tres = fuse_buf_copy(&dst, buf, 0);\n\t\t\t}\n\t\t\tfuse_free_buf(buf);\n\t\t} else {\n\t\t\tres = fs->op.read(path, mem, size, off, fi);\n\t\t}\n\n\t\tif (fs->debug && res >= 0)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"   read[%llu] %u bytes from %llu\\n\",\n\t\t\t\t(unsigned long long) fi->fh,\n\t\t\t\tres,\n\t\t\t\t(unsigned long long) off);\n\t\tif (res >= 0 && res > (int) size)\n\t\t\tfuse_log(FUSE_LOG_ERR, \"fuse: read too many bytes\\n\");\n\n\t\treturn res;\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_write_buf(struct fuse_fs *fs, const char *path,\n\t\t      struct fuse_bufvec *buf, off_t off,\n\t\t      struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.write_buf || fs->op.write) {\n\t\tint res;\n\t\tsize_t size = fuse_buf_size(buf);\n\n\t\tassert(buf->idx == 0 && buf->off == 0);\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG,\n\t\t\t\t\"write%s[%llu] %zu bytes to %llu flags: 0x%x\\n\",\n\t\t\t\tfi->writepage ? \"page\" : \"\",\n\t\t\t\t(unsigned long long) fi->fh,\n\t\t\t\tsize,\n\t\t\t\t(unsigned long long) off,\n\t\t\t\tfi->flags);\n\n\t\tif (fs->op.write_buf) {\n\t\t\tres = fs->op.write_buf(path, buf, off, fi);\n\t\t} else {\n\t\t\tvoid *mem = NULL;\n\t\t\tstruct fuse_buf *flatbuf;\n\t\t\tstruct fuse_bufvec tmp = FUSE_BUFVEC_INIT(size);\n\n\t\t\tif (buf->count == 1 &&\n\t\t\t    !(buf->buf[0].flags & FUSE_BUF_IS_FD)) {\n\t\t\t\tflatbuf = &buf->buf[0];\n\t\t\t} else {\n\t\t\t\tres = -ENOMEM;\n\t\t\t\tmem = malloc(size);\n\t\t\t\tif (mem == NULL)\n\t\t\t\t\tgoto out;\n\n\t\t\t\ttmp.buf[0].mem = mem;\n\t\t\t\tres = fuse_buf_copy(&tmp, buf, 0);\n\t\t\t\tif (res <= 0)\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\ttmp.buf[0].size = res;\n\t\t\t\tflatbuf = &tmp.buf[0];\n\t\t\t}\n\n\t\t\tres = fs->op.write(path, flatbuf->mem, flatbuf->size,\n\t\t\t\t\t   off, fi);\nout_free:\n\t\t\tfree(mem);\n\t\t}\nout:\n\t\tif (fs->debug && res >= 0)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"   write%s[%llu] %u bytes to %llu\\n\",\n\t\t\t\tfi->writepage ? \"page\" : \"\",\n\t\t\t\t(unsigned long long) fi->fh, res,\n\t\t\t\t(unsigned long long) off);\n\t\tif (res > (int) size)\n\t\t\tfuse_log(FUSE_LOG_ERR, \"fuse: wrote too many bytes\\n\");\n\n\t\treturn res;\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_write(struct fuse_fs *fs, const char *path, const char *mem,\n\t\t  size_t size, off_t off, struct fuse_file_info *fi)\n{\n\tstruct fuse_bufvec bufv = FUSE_BUFVEC_INIT(size);\n\n\tbufv.buf[0].mem = (void *) mem;\n\n\treturn fuse_fs_write_buf(fs, path, &bufv, off, fi);\n}\n\nint fuse_fs_fsync(struct fuse_fs *fs, const char *path, int datasync,\n\t\t  struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.fsync) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"fsync[%llu] datasync: %i\\n\",\n\t\t\t\t(unsigned long long) fi->fh, datasync);\n\n\t\treturn fs->op.fsync(path, datasync, fi);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_fsyncdir(struct fuse_fs *fs, const char *path, int datasync,\n\t\t     struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.fsyncdir) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"fsyncdir[%llu] datasync: %i\\n\",\n\t\t\t\t(unsigned long long) fi->fh, datasync);\n\n\t\treturn fs->op.fsyncdir(path, datasync, fi);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_flush(struct fuse_fs *fs, const char *path,\n\t\t  struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.flush) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"flush[%llu]\\n\",\n\t\t\t\t(unsigned long long) fi->fh);\n\n\t\treturn fs->op.flush(path, fi);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_statfs(struct fuse_fs *fs, const char *path, struct statvfs *buf)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.statfs) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"statfs %s\\n\", path);\n\n\t\treturn fs->op.statfs(path, buf);\n\t} else {\n\t\tbuf->f_namemax = 255;\n\t\tbuf->f_bsize = 512;\n\t\treturn 0;\n\t}\n}\n\nint fuse_fs_releasedir(struct fuse_fs *fs, const char *path,\n\t\t       struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.releasedir) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"releasedir[%llu] flags: 0x%x\\n\",\n\t\t\t\t(unsigned long long) fi->fh, fi->flags);\n\n\t\treturn fs->op.releasedir(path, fi);\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nint fuse_fs_readdir(struct fuse_fs *fs, const char *path, void *buf,\n\t\t    fuse_fill_dir_t filler, off_t off,\n\t\t    struct fuse_file_info *fi,\n\t\t    enum fuse_readdir_flags flags)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.readdir) {\n\t\tif (fs->debug) {\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"readdir%s[%llu] from %llu\\n\",\n\t\t\t\t(flags & FUSE_READDIR_PLUS) ? \"plus\" : \"\",\n\t\t\t\t(unsigned long long) fi->fh,\n\t\t\t\t(unsigned long long) off);\n\t\t}\n\n\t\treturn fs->op.readdir(path, buf, filler, off, fi, flags);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_create(struct fuse_fs *fs, const char *path, mode_t mode,\n\t\t   struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.create) {\n\t\tint err;\n\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG,\n\t\t\t\t\"create flags: 0x%x %s 0%o umask=0%03o\\n\",\n\t\t\t\tfi->flags, path, mode,\n\t\t\t\tfuse_get_context()->umask);\n\n\t\terr = fs->op.create(path, mode, fi);\n\n\t\tif (fs->debug && !err)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"   create[%llu] flags: 0x%x %s\\n\",\n\t\t\t\t(unsigned long long) fi->fh, fi->flags, path);\n\n\t\treturn err;\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_lock(struct fuse_fs *fs, const char *path,\n\t\t struct fuse_file_info *fi, int cmd, struct flock *lock)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.lock) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"lock[%llu] %s %s start: %llu len: %llu pid: %llu\\n\",\n\t\t\t\t(unsigned long long) fi->fh,\n\t\t\t\t(cmd == F_GETLK ? \"F_GETLK\" :\n\t\t\t\t (cmd == F_SETLK ? \"F_SETLK\" :\n\t\t\t\t  (cmd == F_SETLKW ? \"F_SETLKW\" : \"???\"))),\n\t\t\t\t(lock->l_type == F_RDLCK ? \"F_RDLCK\" :\n\t\t\t\t (lock->l_type == F_WRLCK ? \"F_WRLCK\" :\n\t\t\t\t  (lock->l_type == F_UNLCK ? \"F_UNLCK\" :\n\t\t\t\t   \"???\"))),\n\t\t\t\t(unsigned long long) lock->l_start,\n\t\t\t\t(unsigned long long) lock->l_len,\n\t\t\t\t(unsigned long long) lock->l_pid);\n\n\t\treturn fs->op.lock(path, fi, cmd, lock);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_flock(struct fuse_fs *fs, const char *path,\n\t\t  struct fuse_file_info *fi, int op)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.flock) {\n\t\tif (fs->debug) {\n\t\t\tint xop = op & ~LOCK_NB;\n\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"lock[%llu] %s%s\\n\",\n\t\t\t\t(unsigned long long) fi->fh,\n\t\t\t\txop == LOCK_SH ? \"LOCK_SH\" :\n\t\t\t\t(xop == LOCK_EX ? \"LOCK_EX\" :\n\t\t\t\t (xop == LOCK_UN ? \"LOCK_UN\" : \"???\")),\n\t\t\t\t(op & LOCK_NB) ? \"|LOCK_NB\" : \"\");\n\t\t}\n\t\treturn fs->op.flock(path, fi, op);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_chown(struct fuse_fs *fs, const char *path, uid_t uid,\n\t\t  gid_t gid, struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.chown) {\n\t\tif (fs->debug) {\n\t\t\tchar buf[10];\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"chown[%s] %s %lu %lu\\n\",\n\t\t\t\tfile_info_string(fi, buf, sizeof(buf)),\n\t\t\t\tpath, (unsigned long) uid, (unsigned long) gid);\n\t\t}\n\t\treturn fs->op.chown(path, uid, gid, fi);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_truncate(struct fuse_fs *fs, const char *path, off_t size,\n\t\t      struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.truncate) {\n\t\tif (fs->debug) {\n\t\t\tchar buf[10];\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"truncate[%s] %llu\\n\",\n\t\t\t\tfile_info_string(fi, buf, sizeof(buf)),\n\t\t\t\t(unsigned long long) size);\n\t\t}\n\t\treturn fs->op.truncate(path, size, fi);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_utimens(struct fuse_fs *fs, const char *path,\n\t\t    const struct timespec tv[2], struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.utimens) {\n\t\tif (fs->debug) {\n\t\t\tchar buf[10];\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"utimens[%s] %s %li.%09lu %li.%09lu\\n\",\n\t\t\t\tfile_info_string(fi, buf, sizeof(buf)),\n\t\t\t\tpath, tv[0].tv_sec, tv[0].tv_nsec,\n\t\t\t\ttv[1].tv_sec, tv[1].tv_nsec);\n\t\t}\n\t\treturn fs->op.utimens(path, tv, fi);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_access(struct fuse_fs *fs, const char *path, int mask)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.access) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"access %s 0%o\\n\", path, mask);\n\n\t\treturn fs->op.access(path, mask);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_readlink(struct fuse_fs *fs, const char *path, char *buf,\n\t\t     size_t len)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.readlink) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"readlink %s %lu\\n\", path,\n\t\t\t\t(unsigned long) len);\n\n\t\treturn fs->op.readlink(path, buf, len);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_mknod(struct fuse_fs *fs, const char *path, mode_t mode,\n\t\t  dev_t rdev)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.mknod) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"mknod %s 0%o 0x%llx umask=0%03o\\n\",\n\t\t\t\tpath, mode, (unsigned long long) rdev,\n\t\t\t\tfuse_get_context()->umask);\n\n\t\treturn fs->op.mknod(path, mode, rdev);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_mkdir(struct fuse_fs *fs, const char *path, mode_t mode)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.mkdir) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"mkdir %s 0%o umask=0%03o\\n\",\n\t\t\t\tpath, mode, fuse_get_context()->umask);\n\n\t\treturn fs->op.mkdir(path, mode);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_setxattr(struct fuse_fs *fs, const char *path, const char *name,\n\t\t     const char *value, size_t size, int flags)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.setxattr) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"setxattr %s %s %lu 0x%x\\n\",\n\t\t\t\tpath, name, (unsigned long) size, flags);\n\n\t\treturn fs->op.setxattr(path, name, value, size, flags);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_getxattr(struct fuse_fs *fs, const char *path, const char *name,\n\t\t     char *value, size_t size)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.getxattr) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"getxattr %s %s %lu\\n\",\n\t\t\t\tpath, name, (unsigned long) size);\n\n\t\treturn fs->op.getxattr(path, name, value, size);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_listxattr(struct fuse_fs *fs, const char *path, char *list,\n\t\t      size_t size)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.listxattr) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"listxattr %s %lu\\n\",\n\t\t\t\tpath, (unsigned long) size);\n\n\t\treturn fs->op.listxattr(path, list, size);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_bmap(struct fuse_fs *fs, const char *path, size_t blocksize,\n\t\t uint64_t *idx)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.bmap) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"bmap %s blocksize: %lu index: %llu\\n\",\n\t\t\t\tpath, (unsigned long) blocksize,\n\t\t\t\t(unsigned long long) *idx);\n\n\t\treturn fs->op.bmap(path, blocksize, idx);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_removexattr(struct fuse_fs *fs, const char *path, const char *name)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.removexattr) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"removexattr %s %s\\n\", path, name);\n\n\t\treturn fs->op.removexattr(path, name);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nint fuse_fs_ioctl(struct fuse_fs *fs, const char *path, unsigned int cmd,\n\t\t  void *arg, struct fuse_file_info *fi, unsigned int flags,\n\t\t  void *data)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.ioctl) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"ioctl[%llu] 0x%x flags: 0x%x\\n\",\n\t\t\t\t(unsigned long long) fi->fh, cmd, flags);\n\n\t\treturn fs->op.ioctl(path, cmd, arg, fi, flags, data);\n\t} else\n\t\treturn -ENOSYS;\n}\n\nint fuse_fs_poll(struct fuse_fs *fs, const char *path,\n\t\t struct fuse_file_info *fi, struct fuse_pollhandle *ph,\n\t\t unsigned *reventsp)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.poll) {\n\t\tint res;\n\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"poll[%llu] ph: %p, events 0x%x\\n\",\n\t\t\t\t(unsigned long long) fi->fh, ph,\n\t\t\t\tfi->poll_events);\n\n\t\tres = fs->op.poll(path, fi, ph, reventsp);\n\n\t\tif (fs->debug && !res)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"   poll[%llu] revents: 0x%x\\n\",\n\t\t\t\t(unsigned long long) fi->fh, *reventsp);\n\n\t\treturn res;\n\t} else\n\t\treturn -ENOSYS;\n}\n\nint fuse_fs_fallocate(struct fuse_fs *fs, const char *path, int mode,\n\t\toff_t offset, off_t length, struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.fallocate) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"fallocate %s mode %x, offset: %llu, length: %llu\\n\",\n\t\t\t\tpath,\n\t\t\t\tmode,\n\t\t\t\t(unsigned long long) offset,\n\t\t\t\t(unsigned long long) length);\n\n\t\treturn fs->op.fallocate(path, mode, offset, length, fi);\n\t} else\n\t\treturn -ENOSYS;\n}\n\nssize_t fuse_fs_copy_file_range(struct fuse_fs *fs, const char *path_in,\n\t\t\t\tstruct fuse_file_info *fi_in, off_t off_in,\n\t\t\t\tconst char *path_out,\n\t\t\t\tstruct fuse_file_info *fi_out, off_t off_out,\n\t\t\t\tsize_t len, int flags)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.copy_file_range) {\n\t\tif (fs->debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"copy_file_range from %s:%llu to \"\n\t\t\t                \"%s:%llu, length: %llu\\n\",\n\t\t\t\tpath_in,\n\t\t\t\t(unsigned long long) off_in,\n\t\t\t\tpath_out,\n\t\t\t\t(unsigned long long) off_out,\n\t\t\t\t(unsigned long long) len);\n\n\t\treturn fs->op.copy_file_range(path_in, fi_in, off_in, path_out,\n\t\t\t\t\t      fi_out, off_out, len, flags);\n\t} else\n\t\treturn -ENOSYS;\n}\n\noff_t fuse_fs_lseek(struct fuse_fs *fs, const char *path, off_t off, int whence,\n\t\t    struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.lseek) {\n\t\tif (fs->debug) {\n\t\t\tchar buf[10];\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"lseek[%s] %llu %d\\n\",\n\t\t\t\tfile_info_string(fi, buf, sizeof(buf)),\n\t\t\t\t(unsigned long long) off, whence);\n\t\t}\n\t\treturn fs->op.lseek(path, off, whence, fi);\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nstatic int is_open(struct fuse *f, fuse_ino_t dir, const char *name)\n{\n\tstruct node *node;\n\tint isopen = 0;\n\tpthread_mutex_lock(&f->lock);\n\tnode = lookup_node(f, dir, name);\n\tif (node && node->open_count > 0)\n\t\tisopen = 1;\n\tpthread_mutex_unlock(&f->lock);\n\treturn isopen;\n}\n\nstatic char *hidden_name(struct fuse *f, fuse_ino_t dir, const char *oldname,\n\t\t\t char *newname, size_t bufsize)\n{\n\tstruct stat buf;\n\tstruct node *node;\n\tstruct node *newnode;\n\tchar *newpath;\n\tint res;\n\tint failctr = 10;\n\n\tdo {\n\t\tpthread_mutex_lock(&f->lock);\n\t\tnode = lookup_node(f, dir, oldname);\n\t\tif (node == NULL) {\n\t\t\tpthread_mutex_unlock(&f->lock);\n\t\t\treturn NULL;\n\t\t}\n\t\tdo {\n\t\t\tf->hidectr ++;\n\t\t\tsnprintf(newname, bufsize, \".fuse_hidden%08x%08x\",\n\t\t\t\t (unsigned int) node->nodeid, f->hidectr);\n\t\t\tnewnode = lookup_node(f, dir, newname);\n\t\t} while(newnode);\n\n\t\tres = try_get_path(f, dir, newname, &newpath, NULL, false);\n\t\tpthread_mutex_unlock(&f->lock);\n\t\tif (res)\n\t\t\tbreak;\n\n\t\tmemset(&buf, 0, sizeof(buf));\n\t\tres = fuse_fs_getattr(f->fs, newpath, &buf, NULL);\n\t\tif (res == -ENOENT)\n\t\t\tbreak;\n\t\tfree(newpath);\n\t\tnewpath = NULL;\n\t} while(res == 0 && --failctr);\n\n\treturn newpath;\n}\n\nstatic int hide_node(struct fuse *f, const char *oldpath,\n\t\t     fuse_ino_t dir, const char *oldname)\n{\n\tchar newname[64];\n\tchar *newpath;\n\tint err = -EBUSY;\n\n\tnewpath = hidden_name(f, dir, oldname, newname, sizeof(newname));\n\tif (newpath) {\n\t\terr = fuse_fs_rename(f->fs, oldpath, newpath, 0);\n\t\tif (!err)\n\t\t\terr = rename_node(f, dir, oldname, dir, newname, 1);\n\t\tfree(newpath);\n\t}\n\treturn err;\n}\n\nstatic int mtime_eq(const struct stat *stbuf, const struct timespec *ts)\n{\n\treturn stbuf->st_mtime == ts->tv_sec &&\n\t\tST_MTIM_NSEC(stbuf) == ts->tv_nsec;\n}\n\n#ifndef CLOCK_MONOTONIC\n#define CLOCK_MONOTONIC CLOCK_REALTIME\n#endif\n\nstatic void curr_time(struct timespec *now)\n{\n\tstatic clockid_t clockid = CLOCK_MONOTONIC;\n\tint res = clock_gettime(clockid, now);\n\tif (res == -1 && errno == EINVAL) {\n\t\tclockid = CLOCK_REALTIME;\n\t\tres = clock_gettime(clockid, now);\n\t}\n\tif (res == -1) {\n\t\tperror(\"fuse: clock_gettime\");\n\t\tabort();\n\t}\n}\n\nstatic void update_stat(struct node *node, const struct stat *stbuf)\n{\n\tif (node->cache_valid && (!mtime_eq(stbuf, &node->mtime) ||\n\t\t\t\t  stbuf->st_size != node->size))\n\t\tnode->cache_valid = 0;\n\tnode->mtime.tv_sec = stbuf->st_mtime;\n\tnode->mtime.tv_nsec = ST_MTIM_NSEC(stbuf);\n\tnode->size = stbuf->st_size;\n\tcurr_time(&node->stat_updated);\n}\n\nstatic int do_lookup(struct fuse *f, fuse_ino_t nodeid, const char *name,\n\t\t     struct fuse_entry_param *e)\n{\n\tstruct node *node;\n\n\tnode = find_node(f, nodeid, name);\n\tif (node == NULL)\n\t\treturn -ENOMEM;\n\n\te->ino = node->nodeid;\n\te->generation = node->generation;\n\te->entry_timeout = f->conf.entry_timeout;\n\te->attr_timeout = f->conf.attr_timeout;\n\tif (f->conf.auto_cache) {\n\t\tpthread_mutex_lock(&f->lock);\n\t\tupdate_stat(node, &e->attr);\n\t\tpthread_mutex_unlock(&f->lock);\n\t}\n\tset_stat(f, e->ino, &e->attr);\n\treturn 0;\n}\n\nstatic int lookup_path(struct fuse *f, fuse_ino_t nodeid,\n\t\t       const char *name, const char *path,\n\t\t       struct fuse_entry_param *e, struct fuse_file_info *fi)\n{\n\tint res;\n\n\tmemset(e, 0, sizeof(struct fuse_entry_param));\n\tres = fuse_fs_getattr(f->fs, path, &e->attr, fi);\n\tif (res == 0) {\n\t\tres = do_lookup(f, nodeid, name, e);\n\t\tif (res == 0 && f->conf.debug) {\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"   NODEID: %llu\\n\",\n\t\t\t\t(unsigned long long) e->ino);\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic struct fuse_context_i *fuse_get_context_internal(void)\n{\n\treturn (struct fuse_context_i *) pthread_getspecific(fuse_context_key);\n}\n\nstatic struct fuse_context_i *fuse_create_context(struct fuse *f)\n{\n\tstruct fuse_context_i *c = fuse_get_context_internal();\n\tif (c == NULL) {\n\t\tc = (struct fuse_context_i *)\n\t\t\tcalloc(1, sizeof(struct fuse_context_i));\n\t\tif (c == NULL) {\n\t\t\t/* This is hard to deal with properly, so just\n\t\t\t   abort.  If memory is so low that the\n\t\t\t   context cannot be allocated, there's not\n\t\t\t   much hope for the filesystem anyway */\n\t\t\tfuse_log(FUSE_LOG_ERR, \"fuse: failed to allocate thread specific data\\n\");\n\t\t\tabort();\n\t\t}\n\t\tpthread_setspecific(fuse_context_key, c);\n\t} else {\n\t\tmemset(c, 0, sizeof(*c));\n\t}\n\tc->ctx.fuse = f;\n\n\treturn c;\n}\n\nstatic void fuse_freecontext(void *data)\n{\n\tfree(data);\n}\n\nstatic int fuse_create_context_key(void)\n{\n\tint err = 0;\n\tpthread_mutex_lock(&fuse_context_lock);\n\tif (!fuse_context_ref) {\n\t\terr = pthread_key_create(&fuse_context_key, fuse_freecontext);\n\t\tif (err) {\n\t\t\tfuse_log(FUSE_LOG_ERR, \"fuse: failed to create thread specific key: %s\\n\",\n\t\t\t\tstrerror(err));\n\t\t\tpthread_mutex_unlock(&fuse_context_lock);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfuse_context_ref++;\n\tpthread_mutex_unlock(&fuse_context_lock);\n\treturn 0;\n}\n\nstatic void fuse_delete_context_key(void)\n{\n\tpthread_mutex_lock(&fuse_context_lock);\n\tfuse_context_ref--;\n\tif (!fuse_context_ref) {\n\t\tfree(pthread_getspecific(fuse_context_key));\n\t\tpthread_key_delete(fuse_context_key);\n\t}\n\tpthread_mutex_unlock(&fuse_context_lock);\n}\n\nstatic struct fuse *req_fuse_prepare(fuse_req_t req)\n{\n\tstruct fuse_context_i *c = fuse_create_context(req_fuse(req));\n\tconst struct fuse_ctx *ctx = fuse_req_ctx(req);\n\tc->req = req;\n\tc->ctx.uid = ctx->uid;\n\tc->ctx.gid = ctx->gid;\n\tc->ctx.pid = ctx->pid;\n\tc->ctx.umask = ctx->umask;\n\treturn c->ctx.fuse;\n}\n\nstatic inline void reply_err(fuse_req_t req, int err)\n{\n\t/* fuse_reply_err() uses non-negated errno values */\n\tfuse_reply_err(req, -err);\n}\n\nstatic void reply_entry(fuse_req_t req, const struct fuse_entry_param *e,\n\t\t\tint err)\n{\n\tif (!err) {\n\t\tstruct fuse *f = req_fuse(req);\n\t\tif (fuse_reply_entry(req, e) == -ENOENT) {\n\t\t\t/* Skip forget for negative result */\n\t\t\tif  (e->ino != 0)\n\t\t\t\tforget_node(f, e->ino, 1);\n\t\t}\n\t} else\n\t\treply_err(req, err);\n}\n\nvoid fuse_fs_init(struct fuse_fs *fs, struct fuse_conn_info *conn,\n\t\t  struct fuse_config *cfg)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (!fs->op.write_buf)\n\t\tconn->want &= ~FUSE_CAP_SPLICE_READ;\n\tif (!fs->op.lock)\n\t\tconn->want &= ~FUSE_CAP_POSIX_LOCKS;\n\tif (!fs->op.flock)\n\t\tconn->want &= ~FUSE_CAP_FLOCK_LOCKS;\n\tif (fs->op.init)\n\t\tfs->user_data = fs->op.init(conn, cfg);\n}\n\nstatic void fuse_lib_init(void *data, struct fuse_conn_info *conn)\n{\n\tstruct fuse *f = (struct fuse *) data;\n\n\tfuse_create_context(f);\n\tif(conn->capable & FUSE_CAP_EXPORT_SUPPORT)\n\t\tconn->want |= FUSE_CAP_EXPORT_SUPPORT;\n\tfuse_fs_init(f->fs, conn, &f->conf);\n}\n\nvoid fuse_fs_destroy(struct fuse_fs *fs)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.destroy)\n\t\tfs->op.destroy(fs->user_data);\n\tif (fs->m)\n\t\tfuse_put_module(fs->m);\n\tfree(fs);\n}\n\nstatic void fuse_lib_destroy(void *data)\n{\n\tstruct fuse *f = (struct fuse *) data;\n\n\tfuse_create_context(f);\n\tfuse_fs_destroy(f->fs);\n\tf->fs = NULL;\n}\n\nstatic void fuse_lib_lookup(fuse_req_t req, fuse_ino_t parent,\n\t\t\t    const char *name)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_entry_param e;\n\tchar *path;\n\tint err;\n\tstruct node *dot = NULL;\n\n\tif (name[0] == '.') {\n\t\tint len = strlen(name);\n\n\t\tif (len == 1 || (name[1] == '.' && len == 2)) {\n\t\t\tpthread_mutex_lock(&f->lock);\n\t\t\tif (len == 1) {\n\t\t\t\tif (f->conf.debug)\n\t\t\t\t\tfuse_log(FUSE_LOG_DEBUG, \"LOOKUP-DOT\\n\");\n\t\t\t\tdot = get_node_nocheck(f, parent);\n\t\t\t\tif (dot == NULL) {\n\t\t\t\t\tpthread_mutex_unlock(&f->lock);\n\t\t\t\t\treply_entry(req, &e, -ESTALE);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdot->refctr++;\n\t\t\t} else {\n\t\t\t\tif (f->conf.debug)\n\t\t\t\t\tfuse_log(FUSE_LOG_DEBUG, \"LOOKUP-DOTDOT\\n\");\n\t\t\t\tparent = get_node(f, parent)->parent->nodeid;\n\t\t\t}\n\t\t\tpthread_mutex_unlock(&f->lock);\n\t\t\tname = NULL;\n\t\t}\n\t}\n\n\terr = get_path_name(f, parent, name, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\t\tif (f->conf.debug)\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"LOOKUP %s\\n\", path);\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = lookup_path(f, parent, name, path, &e, NULL);\n\t\tif (err == -ENOENT && f->conf.negative_timeout != 0.0) {\n\t\t\te.ino = 0;\n\t\t\te.entry_timeout = f->conf.negative_timeout;\n\t\t\terr = 0;\n\t\t}\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, parent, path);\n\t}\n\tif (dot) {\n\t\tpthread_mutex_lock(&f->lock);\n\t\tunref_node(f, dot);\n\t\tpthread_mutex_unlock(&f->lock);\n\t}\n\treply_entry(req, &e, err);\n}\n\nstatic void do_forget(struct fuse *f, fuse_ino_t ino, uint64_t nlookup)\n{\n\tif (f->conf.debug)\n\t\tfuse_log(FUSE_LOG_DEBUG, \"FORGET %llu/%llu\\n\", (unsigned long long)ino,\n\t\t\t(unsigned long long) nlookup);\n\tforget_node(f, ino, nlookup);\n}\n\nstatic void fuse_lib_forget(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)\n{\n\tdo_forget(req_fuse(req), ino, nlookup);\n\tfuse_reply_none(req);\n}\n\nstatic void fuse_lib_forget_multi(fuse_req_t req, size_t count,\n\t\t\t\t  struct fuse_forget_data *forgets)\n{\n\tstruct fuse *f = req_fuse(req);\n\tsize_t i;\n\n\tfor (i = 0; i < count; i++)\n\t\tdo_forget(f, forgets[i].ino, forgets[i].nlookup);\n\n\tfuse_reply_none(req);\n}\n\n\nstatic void fuse_lib_getattr(fuse_req_t req, fuse_ino_t ino,\n\t\t\t     struct fuse_file_info *fi)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct stat buf;\n\tchar *path;\n\tint err;\n\n\tmemset(&buf, 0, sizeof(buf));\n\n\tif (fi != NULL)\n\t\terr = get_path_nullok(f, ino, &path);\n\telse\n\t\terr = get_path(f, ino, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_getattr(f->fs, path, &buf, fi);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\tif (!err) {\n\t\tstruct node *node;\n\n\t\tpthread_mutex_lock(&f->lock);\n\t\tnode = get_node(f, ino);\n\t\tif (node->is_hidden && buf.st_nlink > 0)\n\t\t\tbuf.st_nlink--;\n\t\tif (f->conf.auto_cache)\n\t\t\tupdate_stat(node, &buf);\n\t\tpthread_mutex_unlock(&f->lock);\n\t\tset_stat(f, ino, &buf);\n\t\tfuse_reply_attr(req, &buf, f->conf.attr_timeout);\n\t} else\n\t\treply_err(req, err);\n}\n\nint fuse_fs_chmod(struct fuse_fs *fs, const char *path, mode_t mode,\n\t\t  struct fuse_file_info *fi)\n{\n\tfuse_get_context()->private_data = fs->user_data;\n\tif (fs->op.chmod) {\n\t\tif (fs->debug) {\n\t\t\tchar buf[10];\n\t\t\tfuse_log(FUSE_LOG_DEBUG, \"chmod[%s] %s %llo\\n\",\n\t\t\t\tfile_info_string(fi, buf, sizeof(buf)),\n\t\t\t\tpath, (unsigned long long) mode);\n\t\t}\n\t\treturn fs->op.chmod(path, mode, fi);\n\t}\n\telse\n\t\treturn -ENOSYS;\n}\n\nstatic void fuse_lib_setattr(fuse_req_t req, fuse_ino_t ino, struct stat *attr,\n\t\t\t     int valid, struct fuse_file_info *fi)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct stat buf;\n\tchar *path;\n\tint err;\n\n\tmemset(&buf, 0, sizeof(buf));\n\tif (fi != NULL)\n\t\terr = get_path_nullok(f, ino, &path);\n\telse\n\t\terr = get_path(f, ino, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = 0;\n\t\tif (!err && (valid & FUSE_SET_ATTR_MODE))\n\t\t\terr = fuse_fs_chmod(f->fs, path, attr->st_mode, fi);\n\t\tif (!err && (valid & (FUSE_SET_ATTR_UID | FUSE_SET_ATTR_GID))) {\n\t\t\tuid_t uid = (valid & FUSE_SET_ATTR_UID) ?\n\t\t\t\tattr->st_uid : (uid_t) -1;\n\t\t\tgid_t gid = (valid & FUSE_SET_ATTR_GID) ?\n\t\t\t\tattr->st_gid : (gid_t) -1;\n\t\t\terr = fuse_fs_chown(f->fs, path, uid, gid, fi);\n\t\t}\n\t\tif (!err && (valid & FUSE_SET_ATTR_SIZE)) {\n\t\t\terr = fuse_fs_truncate(f->fs, path,\n\t\t\t\t\t       attr->st_size, fi);\n\t\t}\n#ifdef HAVE_UTIMENSAT\n\t\tif (!err &&\n\t\t    (valid & (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME))) {\n\t\t\tstruct timespec tv[2];\n\n\t\t\ttv[0].tv_sec = 0;\n\t\t\ttv[1].tv_sec = 0;\n\t\t\ttv[0].tv_nsec = UTIME_OMIT;\n\t\t\ttv[1].tv_nsec = UTIME_OMIT;\n\n\t\t\tif (valid & FUSE_SET_ATTR_ATIME_NOW)\n\t\t\t\ttv[0].tv_nsec = UTIME_NOW;\n\t\t\telse if (valid & FUSE_SET_ATTR_ATIME)\n\t\t\t\ttv[0] = attr->st_atim;\n\n\t\t\tif (valid & FUSE_SET_ATTR_MTIME_NOW)\n\t\t\t\ttv[1].tv_nsec = UTIME_NOW;\n\t\t\telse if (valid & FUSE_SET_ATTR_MTIME)\n\t\t\t\ttv[1] = attr->st_mtim;\n\n\t\t\terr = fuse_fs_utimens(f->fs, path, tv, fi);\n\t\t} else\n#endif\n\t\tif (!err &&\n\t\t    (valid & (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME)) ==\n\t\t    (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME)) {\n\t\t\tstruct timespec tv[2];\n\t\t\ttv[0].tv_sec = attr->st_atime;\n\t\t\ttv[0].tv_nsec = ST_ATIM_NSEC(attr);\n\t\t\ttv[1].tv_sec = attr->st_mtime;\n\t\t\ttv[1].tv_nsec = ST_MTIM_NSEC(attr);\n\t\t\terr = fuse_fs_utimens(f->fs, path, tv, fi);\n\t\t}\n\t\tif (!err) {\n\t\t\terr = fuse_fs_getattr(f->fs, path, &buf, fi);\n\t\t}\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\tif (!err) {\n\t\tif (f->conf.auto_cache) {\n\t\t\tpthread_mutex_lock(&f->lock);\n\t\t\tupdate_stat(get_node(f, ino), &buf);\n\t\t\tpthread_mutex_unlock(&f->lock);\n\t\t}\n\t\tset_stat(f, ino, &buf);\n\t\tfuse_reply_attr(req, &buf, f->conf.attr_timeout);\n\t} else\n\t\treply_err(req, err);\n}\n\nstatic void fuse_lib_access(fuse_req_t req, fuse_ino_t ino, int mask)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tchar *path;\n\tint err;\n\n\terr = get_path(f, ino, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_access(f->fs, path, mask);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\treply_err(req, err);\n}\n\nstatic void fuse_lib_readlink(fuse_req_t req, fuse_ino_t ino)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tchar linkname[PATH_MAX + 1];\n\tchar *path;\n\tint err;\n\n\terr = get_path(f, ino, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_readlink(f->fs, path, linkname, sizeof(linkname));\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\tif (!err) {\n\t\tlinkname[PATH_MAX] = '\\0';\n\t\tfuse_reply_readlink(req, linkname);\n\t} else\n\t\treply_err(req, err);\n}\n\nstatic void fuse_lib_mknod(fuse_req_t req, fuse_ino_t parent, const char *name,\n\t\t\t   mode_t mode, dev_t rdev)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_entry_param e;\n\tchar *path;\n\tint err;\n\n\terr = get_path_name(f, parent, name, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = -ENOSYS;\n\t\tif (S_ISREG(mode)) {\n\t\t\tstruct fuse_file_info fi;\n\n\t\t\tmemset(&fi, 0, sizeof(fi));\n\t\t\tfi.flags = O_CREAT | O_EXCL | O_WRONLY;\n\t\t\terr = fuse_fs_create(f->fs, path, mode, &fi);\n\t\t\tif (!err) {\n\t\t\t\terr = lookup_path(f, parent, name, path, &e,\n\t\t\t\t\t\t  &fi);\n\t\t\t\tfuse_fs_release(f->fs, path, &fi);\n\t\t\t}\n\t\t}\n\t\tif (err == -ENOSYS) {\n\t\t\terr = fuse_fs_mknod(f->fs, path, mode, rdev);\n\t\t\tif (!err)\n\t\t\t\terr = lookup_path(f, parent, name, path, &e,\n\t\t\t\t\t\t  NULL);\n\t\t}\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, parent, path);\n\t}\n\treply_entry(req, &e, err);\n}\n\nstatic void fuse_lib_mkdir(fuse_req_t req, fuse_ino_t parent, const char *name,\n\t\t\t   mode_t mode)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_entry_param e;\n\tchar *path;\n\tint err;\n\n\terr = get_path_name(f, parent, name, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_mkdir(f->fs, path, mode);\n\t\tif (!err)\n\t\t\terr = lookup_path(f, parent, name, path, &e, NULL);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, parent, path);\n\t}\n\treply_entry(req, &e, err);\n}\n\nstatic void fuse_lib_unlink(fuse_req_t req, fuse_ino_t parent,\n\t\t\t    const char *name)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct node *wnode;\n\tchar *path;\n\tint err;\n\n\terr = get_path_wrlock(f, parent, name, &path, &wnode);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\tif (!f->conf.hard_remove && is_open(f, parent, name)) {\n\t\t\terr = hide_node(f, path, parent, name);\n\t\t} else {\n\t\t\terr = fuse_fs_unlink(f->fs, path);\n\t\t\tif (!err)\n\t\t\t\tremove_node(f, parent, name);\n\t\t}\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path_wrlock(f, parent, wnode, path);\n\t}\n\treply_err(req, err);\n}\n\nstatic void fuse_lib_rmdir(fuse_req_t req, fuse_ino_t parent, const char *name)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct node *wnode;\n\tchar *path;\n\tint err;\n\n\terr = get_path_wrlock(f, parent, name, &path, &wnode);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_rmdir(f->fs, path);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tif (!err)\n\t\t\tremove_node(f, parent, name);\n\t\tfree_path_wrlock(f, parent, wnode, path);\n\t}\n\treply_err(req, err);\n}\n\nstatic void fuse_lib_symlink(fuse_req_t req, const char *linkname,\n\t\t\t     fuse_ino_t parent, const char *name)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_entry_param e;\n\tchar *path;\n\tint err;\n\n\terr = get_path_name(f, parent, name, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_symlink(f->fs, linkname, path);\n\t\tif (!err)\n\t\t\terr = lookup_path(f, parent, name, path, &e, NULL);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, parent, path);\n\t}\n\treply_entry(req, &e, err);\n}\n\nstatic void fuse_lib_rename(fuse_req_t req, fuse_ino_t olddir,\n\t\t\t    const char *oldname, fuse_ino_t newdir,\n\t\t\t    const char *newname, unsigned int flags)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tchar *oldpath;\n\tchar *newpath;\n\tstruct node *wnode1;\n\tstruct node *wnode2;\n\tint err;\n\n\terr = get_path2(f, olddir, oldname, newdir, newname,\n\t\t\t&oldpath, &newpath, &wnode1, &wnode2);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\t\terr = 0;\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\tif (!f->conf.hard_remove && !(flags & RENAME_EXCHANGE) &&\n\t\t    is_open(f, newdir, newname))\n\t\t\terr = hide_node(f, newpath, newdir, newname);\n\t\tif (!err) {\n\t\t\terr = fuse_fs_rename(f->fs, oldpath, newpath, flags);\n\t\t\tif (!err) {\n\t\t\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\t\t\terr = exchange_node(f, olddir, oldname,\n\t\t\t\t\t\t\t    newdir, newname);\n\t\t\t\t} else {\n\t\t\t\t\terr = rename_node(f, olddir, oldname,\n\t\t\t\t\t\t\t  newdir, newname, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path2(f, olddir, newdir, wnode1, wnode2, oldpath, newpath);\n\t}\n\treply_err(req, err);\n}\n\nstatic void fuse_lib_link(fuse_req_t req, fuse_ino_t ino, fuse_ino_t newparent,\n\t\t\t  const char *newname)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_entry_param e;\n\tchar *oldpath;\n\tchar *newpath;\n\tint err;\n\n\terr = get_path2(f, ino, NULL, newparent, newname,\n\t\t\t&oldpath, &newpath, NULL, NULL);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_link(f->fs, oldpath, newpath);\n\t\tif (!err)\n\t\t\terr = lookup_path(f, newparent, newname, newpath,\n\t\t\t\t\t  &e, NULL);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path2(f, ino, newparent, NULL, NULL, oldpath, newpath);\n\t}\n\treply_entry(req, &e, err);\n}\n\nstatic void fuse_do_release(struct fuse *f, fuse_ino_t ino, const char *path,\n\t\t\t    struct fuse_file_info *fi)\n{\n\tstruct node *node;\n\tint unlink_hidden = 0;\n\n\tfuse_fs_release(f->fs, path, fi);\n\n\tpthread_mutex_lock(&f->lock);\n\tnode = get_node(f, ino);\n\tassert(node->open_count > 0);\n\t--node->open_count;\n\tif (node->is_hidden && !node->open_count) {\n\t\tunlink_hidden = 1;\n\t\tnode->is_hidden = 0;\n\t}\n\tpthread_mutex_unlock(&f->lock);\n\n\tif(unlink_hidden) {\n\t\tif (path) {\n\t\t\tfuse_fs_unlink(f->fs, path);\n\t\t} else if (f->conf.nullpath_ok) {\n\t\t\tchar *unlinkpath;\n\n\t\t\tif (get_path(f, ino, &unlinkpath) == 0)\n\t\t\t\tfuse_fs_unlink(f->fs, unlinkpath);\n\n\t\t\tfree_path(f, ino, unlinkpath);\n\t\t}\n\t}\n}\n\nstatic void fuse_lib_create(fuse_req_t req, fuse_ino_t parent,\n\t\t\t    const char *name, mode_t mode,\n\t\t\t    struct fuse_file_info *fi)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_intr_data d;\n\tstruct fuse_entry_param e;\n\tchar *path;\n\tint err;\n\n\terr = get_path_name(f, parent, name, &path);\n\tif (!err) {\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_create(f->fs, path, mode, fi);\n\t\tif (!err) {\n\t\t\terr = lookup_path(f, parent, name, path, &e, fi);\n\t\t\tif (err)\n\t\t\t\tfuse_fs_release(f->fs, path, fi);\n\t\t\telse if (!S_ISREG(e.attr.st_mode)) {\n\t\t\t\terr = -EIO;\n\t\t\t\tfuse_fs_release(f->fs, path, fi);\n\t\t\t\tforget_node(f, e.ino, 1);\n\t\t\t} else {\n\t\t\t\tif (f->conf.direct_io)\n\t\t\t\t\tfi->direct_io = 1;\n\t\t\t\tif (f->conf.kernel_cache)\n\t\t\t\t\tfi->keep_cache = 1;\n\n\t\t\t}\n\t\t}\n\t\tfuse_finish_interrupt(f, req, &d);\n\t}\n\tif (!err) {\n\t\tpthread_mutex_lock(&f->lock);\n\t\tget_node(f, e.ino)->open_count++;\n\t\tpthread_mutex_unlock(&f->lock);\n\t\tif (fuse_reply_create(req, &e, fi) == -ENOENT) {\n\t\t\t/* The open syscall was interrupted, so it\n\t\t\t   must be cancelled */\n\t\t\tfuse_do_release(f, e.ino, path, fi);\n\t\t\tforget_node(f, e.ino, 1);\n\t\t}\n\t} else {\n\t\treply_err(req, err);\n\t}\n\n\tfree_path(f, parent, path);\n}\n\nstatic double diff_timespec(const struct timespec *t1,\n\t\t\t    const struct timespec *t2)\n{\n\treturn (t1->tv_sec - t2->tv_sec) +\n\t\t((double) t1->tv_nsec - (double) t2->tv_nsec) / 1000000000.0;\n}\n\nstatic void open_auto_cache(struct fuse *f, fuse_ino_t ino, const char *path,\n\t\t\t    struct fuse_file_info *fi)\n{\n\tstruct node *node;\n\n\tpthread_mutex_lock(&f->lock);\n\tnode = get_node(f, ino);\n\tif (node->cache_valid) {\n\t\tstruct timespec now;\n\n\t\tcurr_time(&now);\n\t\tif (diff_timespec(&now, &node->stat_updated) >\n\t\t    f->conf.ac_attr_timeout) {\n\t\t\tstruct stat stbuf;\n\t\t\tint err;\n\t\t\tpthread_mutex_unlock(&f->lock);\n\t\t\terr = fuse_fs_getattr(f->fs, path, &stbuf, fi);\n\t\t\tpthread_mutex_lock(&f->lock);\n\t\t\tif (!err)\n\t\t\t\tupdate_stat(node, &stbuf);\n\t\t\telse\n\t\t\t\tnode->cache_valid = 0;\n\t\t}\n\t}\n\tif (node->cache_valid)\n\t\tfi->keep_cache = 1;\n\n\tnode->cache_valid = 1;\n\tpthread_mutex_unlock(&f->lock);\n}\n\nstatic void fuse_lib_open(fuse_req_t req, fuse_ino_t ino,\n\t\t\t  struct fuse_file_info *fi)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_intr_data d;\n\tchar *path;\n\tint err;\n\n\terr = get_path(f, ino, &path);\n\tif (!err) {\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_open(f->fs, path, fi);\n\t\tif (!err) {\n\t\t\tif (f->conf.direct_io)\n\t\t\t\tfi->direct_io = 1;\n\t\t\tif (f->conf.kernel_cache)\n\t\t\t\tfi->keep_cache = 1;\n\n\t\t\tif (f->conf.auto_cache)\n\t\t\t\topen_auto_cache(f, ino, path, fi);\n\t\t}\n\t\tfuse_finish_interrupt(f, req, &d);\n\t}\n\tif (!err) {\n\t\tpthread_mutex_lock(&f->lock);\n\t\tget_node(f, ino)->open_count++;\n\t\tpthread_mutex_unlock(&f->lock);\n\t\tif (fuse_reply_open(req, fi) == -ENOENT) {\n\t\t\t/* The open syscall was interrupted, so it\n\t\t\t   must be cancelled */\n\t\t\tfuse_do_release(f, ino, path, fi);\n\t\t}\n\t} else\n\t\treply_err(req, err);\n\n\tfree_path(f, ino, path);\n}\n\nstatic void fuse_lib_read(fuse_req_t req, fuse_ino_t ino, size_t size,\n\t\t\t  off_t off, struct fuse_file_info *fi)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_bufvec *buf = NULL;\n\tchar *path;\n\tint res;\n\n\tres = get_path_nullok(f, ino, &path);\n\tif (res == 0) {\n\t\tstruct fuse_intr_data d;\n\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\tres = fuse_fs_read_buf(f->fs, path, &buf, size, off, fi);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\n\tif (res == 0)\n\t\tfuse_reply_data(req, buf, FUSE_BUF_SPLICE_MOVE);\n\telse\n\t\treply_err(req, res);\n\n\tfuse_free_buf(buf);\n}\n\nstatic void fuse_lib_write_buf(fuse_req_t req, fuse_ino_t ino,\n\t\t\t       struct fuse_bufvec *buf, off_t off,\n\t\t\t       struct fuse_file_info *fi)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tchar *path;\n\tint res;\n\n\tres = get_path_nullok(f, ino, &path);\n\tif (res == 0) {\n\t\tstruct fuse_intr_data d;\n\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\tres = fuse_fs_write_buf(f->fs, path, buf, off, fi);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\n\tif (res >= 0)\n\t\tfuse_reply_write(req, res);\n\telse\n\t\treply_err(req, res);\n}\n\nstatic void fuse_lib_fsync(fuse_req_t req, fuse_ino_t ino, int datasync,\n\t\t\t   struct fuse_file_info *fi)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tchar *path;\n\tint err;\n\n\terr = get_path_nullok(f, ino, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_fsync(f->fs, path, datasync, fi);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\treply_err(req, err);\n}\n\nstatic struct fuse_dh *get_dirhandle(const struct fuse_file_info *llfi,\n\t\t\t\t     struct fuse_file_info *fi)\n{\n\tstruct fuse_dh *dh = (struct fuse_dh *) (uintptr_t) llfi->fh;\n\tmemset(fi, 0, sizeof(struct fuse_file_info));\n\tfi->fh = dh->fh;\n\treturn dh;\n}\n\nstatic void fuse_lib_opendir(fuse_req_t req, fuse_ino_t ino,\n\t\t\t     struct fuse_file_info *llfi)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_intr_data d;\n\tstruct fuse_dh *dh;\n\tstruct fuse_file_info fi;\n\tchar *path;\n\tint err;\n\n\tdh = (struct fuse_dh *) malloc(sizeof(struct fuse_dh));\n\tif (dh == NULL) {\n\t\treply_err(req, -ENOMEM);\n\t\treturn;\n\t}\n\tmemset(dh, 0, sizeof(struct fuse_dh));\n\tdh->fuse = f;\n\tdh->contents = NULL;\n\tdh->first = NULL;\n\tdh->len = 0;\n\tdh->filled = 0;\n\tdh->nodeid = ino;\n\tfuse_mutex_init(&dh->lock);\n\n\tllfi->fh = (uintptr_t) dh;\n\n\tmemset(&fi, 0, sizeof(fi));\n\tfi.flags = llfi->flags;\n\n\terr = get_path(f, ino, &path);\n\tif (!err) {\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_opendir(f->fs, path, &fi);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tdh->fh = fi.fh;\n\t}\n\tif (!err) {\n\t\tif (fuse_reply_open(req, llfi) == -ENOENT) {\n\t\t\t/* The opendir syscall was interrupted, so it\n\t\t\t   must be cancelled */\n\t\t\tfuse_fs_releasedir(f->fs, path, &fi);\n\t\t\tpthread_mutex_destroy(&dh->lock);\n\t\t\tfree(dh);\n\t\t}\n\t} else {\n\t\treply_err(req, err);\n\t\tpthread_mutex_destroy(&dh->lock);\n\t\tfree(dh);\n\t}\n\tfree_path(f, ino, path);\n}\n\nstatic int extend_contents(struct fuse_dh *dh, unsigned minsize)\n{\n\tif (minsize > dh->size) {\n\t\tchar *newptr;\n\t\tunsigned newsize = dh->size;\n\t\tif (!newsize)\n\t\t\tnewsize = 1024;\n\t\twhile (newsize < minsize) {\n\t\t\tif (newsize >= 0x80000000)\n\t\t\t\tnewsize = 0xffffffff;\n\t\t\telse\n\t\t\t\tnewsize *= 2;\n\t\t}\n\n\t\tnewptr = (char *) realloc(dh->contents, newsize);\n\t\tif (!newptr) {\n\t\t\tdh->error = -ENOMEM;\n\t\t\treturn -1;\n\t\t}\n\t\tdh->contents = newptr;\n\t\tdh->size = newsize;\n\t}\n\treturn 0;\n}\n\nstatic int fuse_add_direntry_to_dh(struct fuse_dh *dh, const char *name,\n\t\t\t\t   struct stat *st)\n{\n\tstruct fuse_direntry *de;\n\n\tde = malloc(sizeof(struct fuse_direntry));\n\tif (!de) {\n\t\tdh->error = -ENOMEM;\n\t\treturn -1;\n\t}\n\tde->name = strdup(name);\n\tif (!de->name) {\n\t\tdh->error = -ENOMEM;\n\t\tfree(de);\n\t\treturn -1;\n\t}\n\tde->stat = *st;\n\tde->next = NULL;\n\n\t*dh->last = de;\n\tdh->last = &de->next;\n\n\treturn 0;\n}\n\nstatic fuse_ino_t lookup_nodeid(struct fuse *f, fuse_ino_t parent,\n\t\t\t\tconst char *name)\n{\n\tstruct node *node;\n\tfuse_ino_t res = FUSE_UNKNOWN_INO;\n\n\tpthread_mutex_lock(&f->lock);\n\tnode = lookup_node(f, parent, name);\n\tif (node)\n\t\tres = node->nodeid;\n\tpthread_mutex_unlock(&f->lock);\n\n\treturn res;\n}\n\nstatic int fill_dir(void *dh_, const char *name, const struct stat *statp,\n\t\t    off_t off, enum fuse_fill_dir_flags flags)\n{\n\tstruct fuse_dh *dh = (struct fuse_dh *) dh_;\n\tstruct stat stbuf;\n\n\tif ((flags & ~FUSE_FILL_DIR_PLUS) != 0) {\n\t\tdh->error = -EIO;\n\t\treturn 1;\n\t}\n\n\tif (statp)\n\t\tstbuf = *statp;\n\telse {\n\t\tmemset(&stbuf, 0, sizeof(stbuf));\n\t\tstbuf.st_ino = FUSE_UNKNOWN_INO;\n\t}\n\n\tif (!dh->fuse->conf.use_ino) {\n\t\tstbuf.st_ino = FUSE_UNKNOWN_INO;\n\t\tif (dh->fuse->conf.readdir_ino) {\n\t\t\tstbuf.st_ino = (ino_t)\n\t\t\t\tlookup_nodeid(dh->fuse, dh->nodeid, name);\n\t\t}\n\t}\n\n\tif (off) {\n\t\tsize_t newlen;\n\n\t\tif (dh->filled) {\n\t\t\tdh->error = -EIO;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (dh->first) {\n\t\t\tdh->error = -EIO;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (extend_contents(dh, dh->needlen) == -1)\n\t\t\treturn 1;\n\n\t\tnewlen = dh->len +\n\t\t\tfuse_add_direntry(dh->req, dh->contents + dh->len,\n\t\t\t\t\t  dh->needlen - dh->len, name,\n\t\t\t\t\t  &stbuf, off);\n\t\tif (newlen > dh->needlen)\n\t\t\treturn 1;\n\n\t\tdh->len = newlen;\n\t} else {\n\t\tdh->filled = 1;\n\n\t\tif (fuse_add_direntry_to_dh(dh, name, &stbuf) == -1)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int is_dot_or_dotdot(const char *name)\n{\n\treturn name[0] == '.' && (name[1] == '\\0' ||\n\t\t\t\t  (name[1] == '.' && name[2] == '\\0'));\n}\n\nstatic int fill_dir_plus(void *dh_, const char *name, const struct stat *statp,\n\t\t\t off_t off, enum fuse_fill_dir_flags flags)\n{\n\tstruct fuse_dh *dh = (struct fuse_dh *) dh_;\n\tstruct fuse_entry_param e = {\n\t\t/* ino=0 tells the kernel to ignore readdirplus stat info */\n\t\t.ino = 0,\n\t};\n\tstruct fuse *f = dh->fuse;\n\tint res;\n\n\tif ((flags & ~FUSE_FILL_DIR_PLUS) != 0) {\n\t\tdh->error = -EIO;\n\t\treturn 1;\n\t}\n\n\tif (off && statp && (flags & FUSE_FILL_DIR_PLUS)) {\n\t\te.attr = *statp;\n\n\t\tif (!is_dot_or_dotdot(name)) {\n\t\t\tres = do_lookup(f, dh->nodeid, name, &e);\n\t\t\tif (res) {\n\t\t\t\tdh->error = res;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\te.attr.st_ino = FUSE_UNKNOWN_INO;\n\t\tif (!f->conf.use_ino && f->conf.readdir_ino) {\n\t\t\te.attr.st_ino = (ino_t)\n\t\t\t\tlookup_nodeid(f, dh->nodeid, name);\n\t\t}\n\t}\n\n\tif (off) {\n\t\tsize_t newlen;\n\n\t\tif (dh->filled) {\n\t\t\tdh->error = -EIO;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (dh->first) {\n\t\t\tdh->error = -EIO;\n\t\t\treturn 1;\n\t\t}\n\t\tif (extend_contents(dh, dh->needlen) == -1)\n\t\t\treturn 1;\n\n\t\tnewlen = dh->len +\n\t\t\tfuse_add_direntry_plus(dh->req, dh->contents + dh->len,\n\t\t\t\t\t       dh->needlen - dh->len, name,\n\t\t\t\t\t       &e, off);\n\t\tif (newlen > dh->needlen)\n\t\t\treturn 1;\n\t\tdh->len = newlen;\n\t} else {\n\t\tdh->filled = 1;\n\n\t\tif (fuse_add_direntry_to_dh(dh, name, &e.attr) == -1)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void free_direntries(struct fuse_direntry *de)\n{\n\twhile (de) {\n\t\tstruct fuse_direntry *next = de->next;\n\t\tfree(de->name);\n\t\tfree(de);\n\t\tde = next;\n\t}\n}\n\nstatic int readdir_fill(struct fuse *f, fuse_req_t req, fuse_ino_t ino,\n\t\t\tsize_t size, off_t off, struct fuse_dh *dh,\n\t\t\tstruct fuse_file_info *fi,\n\t\t\tenum fuse_readdir_flags flags)\n{\n\tchar *path;\n\tint err;\n\n\tif (f->fs->op.readdir)\n\t\terr = get_path_nullok(f, ino, &path);\n\telse\n\t\terr = get_path(f, ino, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\t\tfuse_fill_dir_t filler = fill_dir;\n\n\t\tif (flags & FUSE_READDIR_PLUS)\n\t\t\tfiller = fill_dir_plus;\n\n\t\tfree_direntries(dh->first);\n\t\tdh->first = NULL;\n\t\tdh->last = &dh->first;\n\t\tdh->len = 0;\n\t\tdh->error = 0;\n\t\tdh->needlen = size;\n\t\tdh->filled = 0;\n\t\tdh->req = req;\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_readdir(f->fs, path, dh, filler, off, fi, flags);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tdh->req = NULL;\n\t\tif (!err)\n\t\t\terr = dh->error;\n\t\tif (err)\n\t\t\tdh->filled = 0;\n\t\tfree_path(f, ino, path);\n\t}\n\treturn err;\n}\n\nstatic int readdir_fill_from_list(fuse_req_t req, struct fuse_dh *dh,\n\t\t\t\t  off_t off, enum fuse_readdir_flags flags)\n{\n\toff_t pos;\n\tstruct fuse_direntry *de = dh->first;\n\n\tdh->len = 0;\n\n\tif (extend_contents(dh, dh->needlen) == -1)\n\t\treturn dh->error;\n\n\tfor (pos = 0; pos < off; pos++) {\n\t\tif (!de)\n\t\t\tbreak;\n\n\t\tde = de->next;\n\t}\n\twhile (de) {\n\t\tchar *p = dh->contents + dh->len;\n\t\tunsigned rem = dh->needlen - dh->len;\n\t\tunsigned thislen;\n\t\tunsigned newlen;\n\t\tpos++;\n\n\t\tif (flags & FUSE_READDIR_PLUS) {\n\t\t\tstruct fuse_entry_param e = {\n\t\t\t\t.ino = 0,\n\t\t\t\t.attr = de->stat,\n\t\t\t};\n\t\t\tthislen = fuse_add_direntry_plus(req, p, rem,\n\t\t\t\t\t\t\t de->name, &e, pos);\n\t\t} else {\n\t\t\tthislen = fuse_add_direntry(req, p, rem,\n\t\t\t\t\t\t    de->name, &de->stat, pos);\n\t\t}\n\t\tnewlen = dh->len + thislen;\n\t\tif (newlen > dh->needlen)\n\t\t\tbreak;\n\t\tdh->len = newlen;\n\t\tde = de->next;\n\t}\n\treturn 0;\n}\n\nstatic void fuse_readdir_common(fuse_req_t req, fuse_ino_t ino, size_t size,\n\t\t\t\toff_t off, struct fuse_file_info *llfi,\n\t\t\t\tenum fuse_readdir_flags flags)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_file_info fi;\n\tstruct fuse_dh *dh = get_dirhandle(llfi, &fi);\n\tint err;\n\n\tpthread_mutex_lock(&dh->lock);\n\t/* According to SUS, directory contents need to be refreshed on\n\t   rewinddir() */\n\tif (!off)\n\t\tdh->filled = 0;\n\n\tif (!dh->filled) {\n\t\terr = readdir_fill(f, req, ino, size, off, dh, &fi, flags);\n\t\tif (err) {\n\t\t\treply_err(req, err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (dh->filled) {\n\t\tdh->needlen = size;\n\t\terr = readdir_fill_from_list(req, dh, off, flags);\n\t\tif (err) {\n\t\t\treply_err(req, err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfuse_reply_buf(req, dh->contents, dh->len);\nout:\n\tpthread_mutex_unlock(&dh->lock);\n}\n\nstatic void fuse_lib_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,\n\t\t\t     off_t off, struct fuse_file_info *llfi)\n{\n\tfuse_readdir_common(req, ino, size, off, llfi, 0);\n}\n\nstatic void fuse_lib_readdirplus(fuse_req_t req, fuse_ino_t ino, size_t size,\n\t\t\t\t  off_t off, struct fuse_file_info *llfi)\n{\n\tfuse_readdir_common(req, ino, size, off, llfi, FUSE_READDIR_PLUS);\n}\n\nstatic void fuse_lib_releasedir(fuse_req_t req, fuse_ino_t ino,\n\t\t\t\tstruct fuse_file_info *llfi)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_intr_data d;\n\tstruct fuse_file_info fi;\n\tstruct fuse_dh *dh = get_dirhandle(llfi, &fi);\n\tchar *path;\n\n\tget_path_nullok(f, ino, &path);\n\n\tfuse_prepare_interrupt(f, req, &d);\n\tfuse_fs_releasedir(f->fs, path, &fi);\n\tfuse_finish_interrupt(f, req, &d);\n\tfree_path(f, ino, path);\n\n\tpthread_mutex_lock(&dh->lock);\n\tpthread_mutex_unlock(&dh->lock);\n\tpthread_mutex_destroy(&dh->lock);\n\tfree_direntries(dh->first);\n\tfree(dh->contents);\n\tfree(dh);\n\treply_err(req, 0);\n}\n\nstatic void fuse_lib_fsyncdir(fuse_req_t req, fuse_ino_t ino, int datasync,\n\t\t\t      struct fuse_file_info *llfi)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_file_info fi;\n\tchar *path;\n\tint err;\n\n\tget_dirhandle(llfi, &fi);\n\n\terr = get_path_nullok(f, ino, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_fsyncdir(f->fs, path, datasync, &fi);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\treply_err(req, err);\n}\n\nstatic void fuse_lib_statfs(fuse_req_t req, fuse_ino_t ino)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct statvfs buf;\n\tchar *path = NULL;\n\tint err = 0;\n\n\tmemset(&buf, 0, sizeof(buf));\n\tif (ino)\n\t\terr = get_path(f, ino, &path);\n\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_statfs(f->fs, path ? path : \"/\", &buf);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\n\tif (!err)\n\t\tfuse_reply_statfs(req, &buf);\n\telse\n\t\treply_err(req, err);\n}\n\nstatic void fuse_lib_setxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n\t\t\t      const char *value, size_t size, int flags)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tchar *path;\n\tint err;\n\n\terr = get_path(f, ino, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_setxattr(f->fs, path, name, value, size, flags);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\treply_err(req, err);\n}\n\nstatic int common_getxattr(struct fuse *f, fuse_req_t req, fuse_ino_t ino,\n\t\t\t   const char *name, char *value, size_t size)\n{\n\tint err;\n\tchar *path;\n\n\terr = get_path(f, ino, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_getxattr(f->fs, path, name, value, size);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\treturn err;\n}\n\nstatic void fuse_lib_getxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n\t\t\t      size_t size)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tint res;\n\n\tif (size) {\n\t\tchar *value = (char *) malloc(size);\n\t\tif (value == NULL) {\n\t\t\treply_err(req, -ENOMEM);\n\t\t\treturn;\n\t\t}\n\t\tres = common_getxattr(f, req, ino, name, value, size);\n\t\tif (res > 0)\n\t\t\tfuse_reply_buf(req, value, res);\n\t\telse\n\t\t\treply_err(req, res);\n\t\tfree(value);\n\t} else {\n\t\tres = common_getxattr(f, req, ino, name, NULL, 0);\n\t\tif (res >= 0)\n\t\t\tfuse_reply_xattr(req, res);\n\t\telse\n\t\t\treply_err(req, res);\n\t}\n}\n\nstatic int common_listxattr(struct fuse *f, fuse_req_t req, fuse_ino_t ino,\n\t\t\t    char *list, size_t size)\n{\n\tchar *path;\n\tint err;\n\n\terr = get_path(f, ino, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_listxattr(f->fs, path, list, size);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\treturn err;\n}\n\nstatic void fuse_lib_listxattr(fuse_req_t req, fuse_ino_t ino, size_t size)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tint res;\n\n\tif (size) {\n\t\tchar *list = (char *) malloc(size);\n\t\tif (list == NULL) {\n\t\t\treply_err(req, -ENOMEM);\n\t\t\treturn;\n\t\t}\n\t\tres = common_listxattr(f, req, ino, list, size);\n\t\tif (res > 0)\n\t\t\tfuse_reply_buf(req, list, res);\n\t\telse\n\t\t\treply_err(req, res);\n\t\tfree(list);\n\t} else {\n\t\tres = common_listxattr(f, req, ino, NULL, 0);\n\t\tif (res >= 0)\n\t\t\tfuse_reply_xattr(req, res);\n\t\telse\n\t\t\treply_err(req, res);\n\t}\n}\n\nstatic void fuse_lib_removexattr(fuse_req_t req, fuse_ino_t ino,\n\t\t\t\t const char *name)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tchar *path;\n\tint err;\n\n\terr = get_path(f, ino, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_removexattr(f->fs, path, name);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\treply_err(req, err);\n}\n\nstatic struct lock *locks_conflict(struct node *node, const struct lock *lock)\n{\n\tstruct lock *l;\n\n\tfor (l = node->locks; l; l = l->next)\n\t\tif (l->owner != lock->owner &&\n\t\t    lock->start <= l->end && l->start <= lock->end &&\n\t\t    (l->type == F_WRLCK || lock->type == F_WRLCK))\n\t\t\tbreak;\n\n\treturn l;\n}\n\nstatic void delete_lock(struct lock **lockp)\n{\n\tstruct lock *l = *lockp;\n\t*lockp = l->next;\n\tfree(l);\n}\n\nstatic void insert_lock(struct lock **pos, struct lock *lock)\n{\n\tlock->next = *pos;\n\t*pos = lock;\n}\n\nstatic int locks_insert(struct node *node, struct lock *lock)\n{\n\tstruct lock **lp;\n\tstruct lock *newl1 = NULL;\n\tstruct lock *newl2 = NULL;\n\n\tif (lock->type != F_UNLCK || lock->start != 0 ||\n\t    lock->end != OFFSET_MAX) {\n\t\tnewl1 = malloc(sizeof(struct lock));\n\t\tnewl2 = malloc(sizeof(struct lock));\n\n\t\tif (!newl1 || !newl2) {\n\t\t\tfree(newl1);\n\t\t\tfree(newl2);\n\t\t\treturn -ENOLCK;\n\t\t}\n\t}\n\n\tfor (lp = &node->locks; *lp;) {\n\t\tstruct lock *l = *lp;\n\t\tif (l->owner != lock->owner)\n\t\t\tgoto skip;\n\n\t\tif (lock->type == l->type) {\n\t\t\tif (l->end < lock->start - 1)\n\t\t\t\tgoto skip;\n\t\t\tif (lock->end < l->start - 1)\n\t\t\t\tbreak;\n\t\t\tif (l->start <= lock->start && lock->end <= l->end)\n\t\t\t\tgoto out;\n\t\t\tif (l->start < lock->start)\n\t\t\t\tlock->start = l->start;\n\t\t\tif (lock->end < l->end)\n\t\t\t\tlock->end = l->end;\n\t\t\tgoto delete;\n\t\t} else {\n\t\t\tif (l->end < lock->start)\n\t\t\t\tgoto skip;\n\t\t\tif (lock->end < l->start)\n\t\t\t\tbreak;\n\t\t\tif (lock->start <= l->start && l->end <= lock->end)\n\t\t\t\tgoto delete;\n\t\t\tif (l->end <= lock->end) {\n\t\t\t\tl->end = lock->start - 1;\n\t\t\t\tgoto skip;\n\t\t\t}\n\t\t\tif (lock->start <= l->start) {\n\t\t\t\tl->start = lock->end + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*newl2 = *l;\n\t\t\tnewl2->start = lock->end + 1;\n\t\t\tl->end = lock->start - 1;\n\t\t\tinsert_lock(&l->next, newl2);\n\t\t\tnewl2 = NULL;\n\t\t}\n\tskip:\n\t\tlp = &l->next;\n\t\tcontinue;\n\n\tdelete:\n\t\tdelete_lock(lp);\n\t}\n\tif (lock->type != F_UNLCK) {\n\t\t*newl1 = *lock;\n\t\tinsert_lock(lp, newl1);\n\t\tnewl1 = NULL;\n\t}\nout:\n\tfree(newl1);\n\tfree(newl2);\n\treturn 0;\n}\n\nstatic void flock_to_lock(struct flock *flock, struct lock *lock)\n{\n\tmemset(lock, 0, sizeof(struct lock));\n\tlock->type = flock->l_type;\n\tlock->start = flock->l_start;\n\tlock->end =\n\t\tflock->l_len ? flock->l_start + flock->l_len - 1 : OFFSET_MAX;\n\tlock->pid = flock->l_pid;\n}\n\nstatic void lock_to_flock(struct lock *lock, struct flock *flock)\n{\n\tflock->l_type = lock->type;\n\tflock->l_start = lock->start;\n\tflock->l_len =\n\t\t(lock->end == OFFSET_MAX) ? 0 : lock->end - lock->start + 1;\n\tflock->l_pid = lock->pid;\n}\n\nstatic int fuse_flush_common(struct fuse *f, fuse_req_t req, fuse_ino_t ino,\n\t\t\t     const char *path, struct fuse_file_info *fi)\n{\n\tstruct fuse_intr_data d;\n\tstruct flock lock;\n\tstruct lock l;\n\tint err;\n\tint errlock;\n\n\tfuse_prepare_interrupt(f, req, &d);\n\tmemset(&lock, 0, sizeof(lock));\n\tlock.l_type = F_UNLCK;\n\tlock.l_whence = SEEK_SET;\n\terr = fuse_fs_flush(f->fs, path, fi);\n\terrlock = fuse_fs_lock(f->fs, path, fi, F_SETLK, &lock);\n\tfuse_finish_interrupt(f, req, &d);\n\n\tif (errlock != -ENOSYS) {\n\t\tflock_to_lock(&lock, &l);\n\t\tl.owner = fi->lock_owner;\n\t\tpthread_mutex_lock(&f->lock);\n\t\tlocks_insert(get_node(f, ino), &l);\n\t\tpthread_mutex_unlock(&f->lock);\n\n\t\t/* if op.lock() is defined FLUSH is needed regardless\n\t\t   of op.flush() */\n\t\tif (err == -ENOSYS)\n\t\t\terr = 0;\n\t}\n\treturn err;\n}\n\nstatic void fuse_lib_release(fuse_req_t req, fuse_ino_t ino,\n\t\t\t     struct fuse_file_info *fi)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_intr_data d;\n\tchar *path;\n\tint err = 0;\n\n\tget_path_nullok(f, ino, &path);\n\tif (fi->flush) {\n\t\terr = fuse_flush_common(f, req, ino, path, fi);\n\t\tif (err == -ENOSYS)\n\t\t\terr = 0;\n\t}\n\n\tfuse_prepare_interrupt(f, req, &d);\n\tfuse_do_release(f, ino, path, fi);\n\tfuse_finish_interrupt(f, req, &d);\n\tfree_path(f, ino, path);\n\n\treply_err(req, err);\n}\n\nstatic void fuse_lib_flush(fuse_req_t req, fuse_ino_t ino,\n\t\t\t   struct fuse_file_info *fi)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tchar *path;\n\tint err;\n\n\tget_path_nullok(f, ino, &path);\n\terr = fuse_flush_common(f, req, ino, path, fi);\n\tfree_path(f, ino, path);\n\n\treply_err(req, err);\n}\n\nstatic int fuse_lock_common(fuse_req_t req, fuse_ino_t ino,\n\t\t\t    struct fuse_file_info *fi, struct flock *lock,\n\t\t\t    int cmd)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tchar *path;\n\tint err;\n\n\terr = get_path_nullok(f, ino, &path);\n\tif (!err) {\n\t\tstruct fuse_intr_data d;\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_lock(f->fs, path, fi, cmd, lock);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\treturn err;\n}\n\nstatic void fuse_lib_getlk(fuse_req_t req, fuse_ino_t ino,\n\t\t\t   struct fuse_file_info *fi, struct flock *lock)\n{\n\tint err;\n\tstruct lock l;\n\tstruct lock *conflict;\n\tstruct fuse *f = req_fuse(req);\n\n\tflock_to_lock(lock, &l);\n\tl.owner = fi->lock_owner;\n\tpthread_mutex_lock(&f->lock);\n\tconflict = locks_conflict(get_node(f, ino), &l);\n\tif (conflict)\n\t\tlock_to_flock(conflict, lock);\n\tpthread_mutex_unlock(&f->lock);\n\tif (!conflict)\n\t\terr = fuse_lock_common(req, ino, fi, lock, F_GETLK);\n\telse\n\t\terr = 0;\n\n\tif (!err)\n\t\tfuse_reply_lock(req, lock);\n\telse\n\t\treply_err(req, err);\n}\n\nstatic void fuse_lib_setlk(fuse_req_t req, fuse_ino_t ino,\n\t\t\t   struct fuse_file_info *fi, struct flock *lock,\n\t\t\t   int sleep)\n{\n\tint err = fuse_lock_common(req, ino, fi, lock,\n\t\t\t\t   sleep ? F_SETLKW : F_SETLK);\n\tif (!err) {\n\t\tstruct fuse *f = req_fuse(req);\n\t\tstruct lock l;\n\t\tflock_to_lock(lock, &l);\n\t\tl.owner = fi->lock_owner;\n\t\tpthread_mutex_lock(&f->lock);\n\t\tlocks_insert(get_node(f, ino), &l);\n\t\tpthread_mutex_unlock(&f->lock);\n\t}\n\treply_err(req, err);\n}\n\nstatic void fuse_lib_flock(fuse_req_t req, fuse_ino_t ino,\n\t\t\t   struct fuse_file_info *fi, int op)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tchar *path;\n\tint err;\n\n\terr = get_path_nullok(f, ino, &path);\n\tif (err == 0) {\n\t\tstruct fuse_intr_data d;\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_flock(f->fs, path, fi, op);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\treply_err(req, err);\n}\n\nstatic void fuse_lib_bmap(fuse_req_t req, fuse_ino_t ino, size_t blocksize,\n\t\t\t  uint64_t idx)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_intr_data d;\n\tchar *path;\n\tint err;\n\n\terr = get_path(f, ino, &path);\n\tif (!err) {\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_bmap(f->fs, path, blocksize, &idx);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\tif (!err)\n\t\tfuse_reply_bmap(req, idx);\n\telse\n\t\treply_err(req, err);\n}\n\nstatic void fuse_lib_ioctl(fuse_req_t req, fuse_ino_t ino, unsigned int cmd,\n\t\t\t   void *arg, struct fuse_file_info *llfi,\n\t\t\t   unsigned int flags, const void *in_buf,\n\t\t\t   size_t in_bufsz, size_t out_bufsz)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_intr_data d;\n\tstruct fuse_file_info fi;\n\tchar *path, *out_buf = NULL;\n\tint err;\n\n\terr = -EPERM;\n\tif (flags & FUSE_IOCTL_UNRESTRICTED)\n\t\tgoto err;\n\n\tif (flags & FUSE_IOCTL_DIR)\n\t\tget_dirhandle(llfi, &fi);\n\telse\n\t\tfi = *llfi;\n\n\tif (out_bufsz) {\n\t\terr = -ENOMEM;\n\t\tout_buf = malloc(out_bufsz);\n\t\tif (!out_buf)\n\t\t\tgoto err;\n\t}\n\n\tassert(!in_bufsz || !out_bufsz || in_bufsz == out_bufsz);\n\tif (out_buf && in_bufsz)\n\t\tmemcpy(out_buf, in_buf, in_bufsz);\n\n\terr = get_path_nullok(f, ino, &path);\n\tif (err)\n\t\tgoto err;\n\n\tfuse_prepare_interrupt(f, req, &d);\n\n\terr = fuse_fs_ioctl(f->fs, path, cmd, arg, &fi, flags,\n\t\t\t    out_buf ? out_buf : (void *)in_buf);\n\n\tfuse_finish_interrupt(f, req, &d);\n\tfree_path(f, ino, path);\n\n\tfuse_reply_ioctl(req, err, out_buf, out_bufsz);\n\tgoto out;\nerr:\n\treply_err(req, err);\nout:\n\tfree(out_buf);\n}\n\nstatic void fuse_lib_poll(fuse_req_t req, fuse_ino_t ino,\n\t\t\t  struct fuse_file_info *fi, struct fuse_pollhandle *ph)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_intr_data d;\n\tchar *path;\n\tint err;\n\tunsigned revents = 0;\n\n\terr = get_path_nullok(f, ino, &path);\n\tif (!err) {\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_poll(f->fs, path, fi, ph, &revents);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\tif (!err)\n\t\tfuse_reply_poll(req, revents);\n\telse\n\t\treply_err(req, err);\n}\n\nstatic void fuse_lib_fallocate(fuse_req_t req, fuse_ino_t ino, int mode,\n\t\toff_t offset, off_t length, struct fuse_file_info *fi)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_intr_data d;\n\tchar *path;\n\tint err;\n\n\terr = get_path_nullok(f, ino, &path);\n\tif (!err) {\n\t\tfuse_prepare_interrupt(f, req, &d);\n\t\terr = fuse_fs_fallocate(f->fs, path, mode, offset, length, fi);\n\t\tfuse_finish_interrupt(f, req, &d);\n\t\tfree_path(f, ino, path);\n\t}\n\treply_err(req, err);\n}\n\nstatic void fuse_lib_copy_file_range(fuse_req_t req, fuse_ino_t nodeid_in,\n\t\t\t\t     off_t off_in, struct fuse_file_info *fi_in,\n\t\t\t\t     fuse_ino_t nodeid_out, off_t off_out,\n\t\t\t\t     struct fuse_file_info *fi_out, size_t len,\n\t\t\t\t     int flags)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_intr_data d;\n\tchar *path_in, *path_out;\n\tint err;\n\tssize_t res;\n\n\terr = get_path_nullok(f, nodeid_in, &path_in);\n\tif (err) {\n\t\treply_err(req, err);\n\t\treturn;\n\t}\n\n\terr = get_path_nullok(f, nodeid_out, &path_out);\n\tif (err) {\n\t\tfree_path(f, nodeid_in, path_in);\n\t\treply_err(req, err);\n\t\treturn;\n\t}\n\n\tfuse_prepare_interrupt(f, req, &d);\n\tres = fuse_fs_copy_file_range(f->fs, path_in, fi_in, off_in, path_out,\n\t\t\t\t      fi_out, off_out, len, flags);\n\tfuse_finish_interrupt(f, req, &d);\n\n\tif (res >= 0)\n\t\tfuse_reply_write(req, res);\n\telse\n\t\treply_err(req, res);\n\n\tfree_path(f, nodeid_in, path_in);\n\tfree_path(f, nodeid_out, path_out);\n}\n\nstatic void fuse_lib_lseek(fuse_req_t req, fuse_ino_t ino, off_t off, int whence,\n\t\t\t   struct fuse_file_info *fi)\n{\n\tstruct fuse *f = req_fuse_prepare(req);\n\tstruct fuse_intr_data d;\n\tchar *path;\n\tint err;\n\toff_t res;\n\n\terr = get_path(f, ino, &path);\n\tif (err) {\n\t\treply_err(req, err);\n\t\treturn;\n\t}\n\n\tfuse_prepare_interrupt(f, req, &d);\n\tres = fuse_fs_lseek(f->fs, path, off, whence, fi);\n\tfuse_finish_interrupt(f, req, &d);\n\tfree_path(f, ino, path);\n\tif (res >= 0)\n\t\tfuse_reply_lseek(req, res);\n\telse\n\t\treply_err(req, res);\n}\n\nstatic int clean_delay(struct fuse *f)\n{\n\t/*\n\t * This is calculating the delay between clean runs.  To\n\t * reduce the number of cleans we are doing them 10 times\n\t * within the remember window.\n\t */\n\tint min_sleep = 60;\n\tint max_sleep = 3600;\n\tint sleep_time = f->conf.remember / 10;\n\n\tif (sleep_time > max_sleep)\n\t\treturn max_sleep;\n\tif (sleep_time < min_sleep)\n\t\treturn min_sleep;\n\treturn sleep_time;\n}\n\nint fuse_clean_cache(struct fuse *f)\n{\n\tstruct node_lru *lnode;\n\tstruct list_head *curr, *next;\n\tstruct node *node;\n\tstruct timespec now;\n\n\tpthread_mutex_lock(&f->lock);\n\n\tcurr_time(&now);\n\n\tfor (curr = f->lru_table.next; curr != &f->lru_table; curr = next) {\n\t\tdouble age;\n\n\t\tnext = curr->next;\n\t\tlnode = list_entry(curr, struct node_lru, lru);\n\t\tnode = &lnode->node;\n\n\t\tage = diff_timespec(&now, &lnode->forget_time);\n\t\tif (age <= f->conf.remember)\n\t\t\tbreak;\n\n\t\tassert(node->nlookup == 1);\n\n\t\t/* Don't forget active directories */\n\t\tif (node->refctr > 1)\n\t\t\tcontinue;\n\n\t\tnode->nlookup = 0;\n\t\tunhash_name(f, node);\n\t\tunref_node(f, node);\n\t}\n\tpthread_mutex_unlock(&f->lock);\n\n\treturn clean_delay(f);\n}\n\nstatic struct fuse_lowlevel_ops fuse_path_ops = {\n\t.init = fuse_lib_init,\n\t.destroy = fuse_lib_destroy,\n\t.lookup = fuse_lib_lookup,\n\t.forget = fuse_lib_forget,\n\t.forget_multi = fuse_lib_forget_multi,\n\t.getattr = fuse_lib_getattr,\n\t.setattr = fuse_lib_setattr,\n\t.access = fuse_lib_access,\n\t.readlink = fuse_lib_readlink,\n\t.mknod = fuse_lib_mknod,\n\t.mkdir = fuse_lib_mkdir,\n\t.unlink = fuse_lib_unlink,\n\t.rmdir = fuse_lib_rmdir,\n\t.symlink = fuse_lib_symlink,\n\t.rename = fuse_lib_rename,\n\t.link = fuse_lib_link,\n\t.create = fuse_lib_create,\n\t.open = fuse_lib_open,\n\t.read = fuse_lib_read,\n\t.write_buf = fuse_lib_write_buf,\n\t.flush = fuse_lib_flush,\n\t.release = fuse_lib_release,\n\t.fsync = fuse_lib_fsync,\n\t.opendir = fuse_lib_opendir,\n\t.readdir = fuse_lib_readdir,\n\t.readdirplus = fuse_lib_readdirplus,\n\t.releasedir = fuse_lib_releasedir,\n\t.fsyncdir = fuse_lib_fsyncdir,\n\t.statfs = fuse_lib_statfs,\n\t.setxattr = fuse_lib_setxattr,\n\t.getxattr = fuse_lib_getxattr,\n\t.listxattr = fuse_lib_listxattr,\n\t.removexattr = fuse_lib_removexattr,\n\t.getlk = fuse_lib_getlk,\n\t.setlk = fuse_lib_setlk,\n\t.flock = fuse_lib_flock,\n\t.bmap = fuse_lib_bmap,\n\t.ioctl = fuse_lib_ioctl,\n\t.poll = fuse_lib_poll,\n\t.fallocate = fuse_lib_fallocate,\n\t.copy_file_range = fuse_lib_copy_file_range,\n\t.lseek = fuse_lib_lseek,\n};\n\nint fuse_notify_poll(struct fuse_pollhandle *ph)\n{\n\treturn fuse_lowlevel_notify_poll(ph);\n}\n\nstruct fuse_session *fuse_get_session(struct fuse *f)\n{\n\treturn f->se;\n}\n\nstatic int fuse_session_loop_remember(struct fuse *f)\n{\n\tstruct fuse_session *se = f->se;\n\tint res = 0;\n\tstruct timespec now;\n\ttime_t next_clean;\n\tstruct pollfd fds = {\n\t\t.fd = se->fd,\n\t\t.events = POLLIN\n\t};\n\tstruct fuse_buf fbuf = {\n\t\t.mem = NULL,\n\t};\n\n\tcurr_time(&now);\n\tnext_clean = now.tv_sec;\n\twhile (!fuse_session_exited(se)) {\n\t\tunsigned timeout;\n\n\t\tcurr_time(&now);\n\t\tif (now.tv_sec < next_clean)\n\t\t\ttimeout = next_clean - now.tv_sec;\n\t\telse\n\t\t\ttimeout = 0;\n\n\t\tres = poll(&fds, 1, timeout * 1000);\n\t\tif (res == -1) {\n\t\t\tif (errno == -EINTR)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t} else if (res > 0) {\n\t\t\tres = fuse_session_receive_buf_int(se, &fbuf, NULL);\n\n\t\t\tif (res == -EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (res <= 0)\n\t\t\t\tbreak;\n\n\t\t\tfuse_session_process_buf_int(se, &fbuf, NULL);\n\t\t} else {\n\t\t\ttimeout = fuse_clean_cache(f);\n\t\t\tcurr_time(&now);\n\t\t\tnext_clean = now.tv_sec + timeout;\n\t\t}\n\t}\n\n\tfree(fbuf.mem);\n\tfuse_session_reset(se);\n\treturn res < 0 ? -1 : 0;\n}\n\nint fuse_loop(struct fuse *f)\n{\n\tif (!f)\n\t\treturn -1;\n\n\tif (lru_enabled(f))\n\t\treturn fuse_session_loop_remember(f);\n\n\treturn fuse_session_loop(f->se);\n}\n\nFUSE_SYMVER(\".symver fuse_loop_mt_32,fuse_loop_mt@@FUSE_3.2\");\nint fuse_loop_mt_32(struct fuse *f, struct fuse_loop_config *config)\n{\n\tif (f == NULL)\n\t\treturn -1;\n\n\tint res = fuse_start_cleanup_thread(f);\n\tif (res)\n\t\treturn -1;\n\n\tres = fuse_session_loop_mt_32(fuse_get_session(f), config);\n\tfuse_stop_cleanup_thread(f);\n\treturn res;\n}\n\nint fuse_loop_mt_31(struct fuse *f, int clone_fd);\nFUSE_SYMVER(\".symver fuse_loop_mt_31,fuse_loop_mt@FUSE_3.0\");\nint fuse_loop_mt_31(struct fuse *f, int clone_fd)\n{\n\tstruct fuse_loop_config config;\n\tconfig.clone_fd = clone_fd;\n\tconfig.max_idle_threads = 10;\n\treturn fuse_loop_mt_32(f, &config);\n}\n\nvoid fuse_exit(struct fuse *f)\n{\n\tfuse_session_exit(f->se);\n}\n\nstruct fuse_context *fuse_get_context(void)\n{\n\tstruct fuse_context_i *c = fuse_get_context_internal();\n\n\tif (c)\n\t\treturn &c->ctx;\n\telse\n\t\treturn NULL;\n}\n\nint fuse_getgroups(int size, gid_t list[])\n{\n\tstruct fuse_context_i *c = fuse_get_context_internal();\n\tif (!c)\n\t\treturn -EINVAL;\n\n\treturn fuse_req_getgroups(c->req, size, list);\n}\n\nint fuse_interrupted(void)\n{\n\tstruct fuse_context_i *c = fuse_get_context_internal();\n\n\tif (c)\n\t\treturn fuse_req_interrupted(c->req);\n\telse\n\t\treturn 0;\n}\n\nint fuse_invalidate_path(struct fuse *f, const char *path) {\n\tfuse_ino_t ino;\n\tint err = lookup_path_in_cache(f, path, &ino);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn fuse_lowlevel_notify_inval_inode(f->se, ino, 0, 0);\n}\n\n#define FUSE_LIB_OPT(t, p, v) { t, offsetof(struct fuse_config, p), v }\n\nstatic const struct fuse_opt fuse_lib_opts[] = {\n\tFUSE_OPT_KEY(\"debug\",\t\t      FUSE_OPT_KEY_KEEP),\n\tFUSE_OPT_KEY(\"-d\",\t\t      FUSE_OPT_KEY_KEEP),\n\tFUSE_LIB_OPT(\"debug\",\t\t      debug, 1),\n\tFUSE_LIB_OPT(\"-d\",\t\t      debug, 1),\n\tFUSE_LIB_OPT(\"kernel_cache\",\t      kernel_cache, 1),\n\tFUSE_LIB_OPT(\"auto_cache\",\t      auto_cache, 1),\n\tFUSE_LIB_OPT(\"noauto_cache\",\t      auto_cache, 0),\n\tFUSE_LIB_OPT(\"umask=\",\t\t      set_mode, 1),\n\tFUSE_LIB_OPT(\"umask=%o\",\t      umask, 0),\n\tFUSE_LIB_OPT(\"uid=\",\t\t      set_uid, 1),\n\tFUSE_LIB_OPT(\"uid=%d\",\t\t      uid, 0),\n\tFUSE_LIB_OPT(\"gid=\",\t\t      set_gid, 1),\n\tFUSE_LIB_OPT(\"gid=%d\",\t\t      gid, 0),\n\tFUSE_LIB_OPT(\"entry_timeout=%lf\",     entry_timeout, 0),\n\tFUSE_LIB_OPT(\"attr_timeout=%lf\",      attr_timeout, 0),\n\tFUSE_LIB_OPT(\"ac_attr_timeout=%lf\",   ac_attr_timeout, 0),\n\tFUSE_LIB_OPT(\"ac_attr_timeout=\",      ac_attr_timeout_set, 1),\n\tFUSE_LIB_OPT(\"negative_timeout=%lf\",  negative_timeout, 0),\n\tFUSE_LIB_OPT(\"noforget\",              remember, -1),\n\tFUSE_LIB_OPT(\"remember=%u\",           remember, 0),\n\tFUSE_LIB_OPT(\"modules=%s\",\t      modules, 0),\n\tFUSE_OPT_END\n};\n\nstatic int fuse_lib_opt_proc(void *data, const char *arg, int key,\n\t\t\t     struct fuse_args *outargs)\n{\n\t(void) arg; (void) outargs; (void) data; (void) key;\n\n\t/* Pass through unknown options */\n\treturn 1;\n}\n\n\nstatic const struct fuse_opt fuse_help_opts[] = {\n\tFUSE_LIB_OPT(\"modules=%s\", modules, 1),\n\tFUSE_OPT_KEY(\"modules=%s\", FUSE_OPT_KEY_KEEP),\n\tFUSE_OPT_END\n};\n\nstatic void print_module_help(const char *name,\n\t\t\t      fuse_module_factory_t *fac)\n{\n\tstruct fuse_args a = FUSE_ARGS_INIT(0, NULL);\n\tif (fuse_opt_add_arg(&a, \"\") == -1 ||\n\t    fuse_opt_add_arg(&a, \"-h\") == -1)\n\t\treturn;\n\tprintf(\"\\nOptions for %s module:\\n\", name);\n\t(*fac)(&a, NULL);\n\tfuse_opt_free_args(&a);\n}\n\nvoid fuse_lib_help(struct fuse_args *args)\n{\n\t/* These are not all options, but only the ones that\n\t   may be of interest to an end-user */\n\tprintf(\n\"    -o kernel_cache        cache files in kernel\\n\"\n\"    -o [no]auto_cache      enable caching based on modification times (off)\\n\"\n\"    -o umask=M             set file permissions (octal)\\n\"\n\"    -o uid=N               set file owner\\n\"\n\"    -o gid=N               set file group\\n\"\n\"    -o entry_timeout=T     cache timeout for names (1.0s)\\n\"\n\"    -o negative_timeout=T  cache timeout for deleted names (0.0s)\\n\"\n\"    -o attr_timeout=T      cache timeout for attributes (1.0s)\\n\"\n\"    -o ac_attr_timeout=T   auto cache timeout for attributes (attr_timeout)\\n\"\n\"    -o noforget            never forget cached inodes\\n\"\n\"    -o remember=T          remember cached inodes for T seconds (0s)\\n\"\n\"    -o modules=M1[:M2...]  names of modules to push onto filesystem stack\\n\");\n\n\n\t/* Print low-level help */\n\tfuse_lowlevel_help();\n\n\t/* Print help for builtin modules */\n\tprint_module_help(\"subdir\", &fuse_module_subdir_factory);\n#ifdef HAVE_ICONV\n\tprint_module_help(\"iconv\", &fuse_module_iconv_factory);\n#endif\n\n\t/* Parse command line options in case we need to\n\t   activate more modules */\n\tstruct fuse_config conf = { .modules = NULL };\n\tif (fuse_opt_parse(args, &conf, fuse_help_opts,\n\t\t\t   fuse_lib_opt_proc) == -1\n\t    || !conf.modules)\n\t\treturn;\n\t\n\tchar *module;\n\tchar *next;\n\tstruct fuse_module *m;\n\n\t// Iterate over all modules\n\tfor (module = conf.modules; module; module = next) {\n\t\tchar *p;\n\t\tfor (p = module; *p && *p != ':'; p++);\n\t\tnext = *p ? p + 1 : NULL;\n\t\t*p = '\\0';\n\n\t\tm = fuse_get_module(module);\n\t\tif (m)\n\t\t\tprint_module_help(module, &m->factory);\n\t}\n}\n\n\t\t\t\t      \n\nstatic int fuse_init_intr_signal(int signum, int *installed)\n{\n\tstruct sigaction old_sa;\n\n\tif (sigaction(signum, NULL, &old_sa) == -1) {\n\t\tperror(\"fuse: cannot get old signal handler\");\n\t\treturn -1;\n\t}\n\n\tif (old_sa.sa_handler == SIG_DFL) {\n\t\tstruct sigaction sa;\n\n\t\tmemset(&sa, 0, sizeof(struct sigaction));\n\t\tsa.sa_handler = fuse_intr_sighandler;\n\t\tsigemptyset(&sa.sa_mask);\n\n\t\tif (sigaction(signum, &sa, NULL) == -1) {\n\t\t\tperror(\"fuse: cannot set interrupt signal handler\");\n\t\t\treturn -1;\n\t\t}\n\t\t*installed = 1;\n\t}\n\treturn 0;\n}\n\nstatic void fuse_restore_intr_signal(int signum)\n{\n\tstruct sigaction sa;\n\n\tmemset(&sa, 0, sizeof(struct sigaction));\n\tsa.sa_handler = SIG_DFL;\n\tsigaction(signum, &sa, NULL);\n}\n\n\nstatic int fuse_push_module(struct fuse *f, const char *module,\n\t\t\t    struct fuse_args *args)\n{\n\tstruct fuse_fs *fs[2] = { f->fs, NULL };\n\tstruct fuse_fs *newfs;\n\tstruct fuse_module *m = fuse_get_module(module);\n\n\tif (!m)\n\t\treturn -1;\n\n\tnewfs = m->factory(args, fs);\n\tif (!newfs) {\n\t\tfuse_put_module(m);\n\t\treturn -1;\n\t}\n\tnewfs->m = m;\n\tf->fs = newfs;\n\treturn 0;\n}\n\nstruct fuse_fs *fuse_fs_new(const struct fuse_operations *op, size_t op_size,\n\t\t\t    void *user_data)\n{\n\tstruct fuse_fs *fs;\n\n\tif (sizeof(struct fuse_operations) < op_size) {\n\t\tfuse_log(FUSE_LOG_ERR, \"fuse: warning: library too old, some operations may not not work\\n\");\n\t\top_size = sizeof(struct fuse_operations);\n\t}\n\n\tfs = (struct fuse_fs *) calloc(1, sizeof(struct fuse_fs));\n\tif (!fs) {\n\t\tfuse_log(FUSE_LOG_ERR, \"fuse: failed to allocate fuse_fs object\\n\");\n\t\treturn NULL;\n\t}\n\n\tfs->user_data = user_data;\n\tif (op)\n\t\tmemcpy(&fs->op, op, op_size);\n\treturn fs;\n}\n\nstatic int node_table_init(struct node_table *t)\n{\n\tt->size = NODE_TABLE_MIN_SIZE;\n\tt->array = (struct node **) calloc(1, sizeof(struct node *) * t->size);\n\tif (t->array == NULL) {\n\t\tfuse_log(FUSE_LOG_ERR, \"fuse: memory allocation failed\\n\");\n\t\treturn -1;\n\t}\n\tt->use = 0;\n\tt->split = 0;\n\n\treturn 0;\n}\n\nstatic void *fuse_prune_nodes(void *fuse)\n{\n\tstruct fuse *f = fuse;\n\tint sleep_time;\n\n\twhile(1) {\n\t\tsleep_time = fuse_clean_cache(f);\n\t\tsleep(sleep_time);\n\t}\n\treturn NULL;\n}\n\nint fuse_start_cleanup_thread(struct fuse *f)\n{\n\tif (lru_enabled(f))\n\t\treturn fuse_start_thread(&f->prune_thread, fuse_prune_nodes, f);\n\n\treturn 0;\n}\n\nvoid fuse_stop_cleanup_thread(struct fuse *f)\n{\n\tif (lru_enabled(f)) {\n\t\tpthread_mutex_lock(&f->lock);\n\t\tpthread_cancel(f->prune_thread);\n\t\tpthread_mutex_unlock(&f->lock);\n\t\tpthread_join(f->prune_thread, NULL);\n\t}\n}\n\n\nFUSE_SYMVER(\".symver fuse_new_31,fuse_new@@FUSE_3.1\");\nstruct fuse *fuse_new_31(struct fuse_args *args,\n\t\t      const struct fuse_operations *op,\n\t\t      size_t op_size, void *user_data)\n{\n\tstruct fuse *f;\n\tstruct node *root;\n\tstruct fuse_fs *fs;\n\tstruct fuse_lowlevel_ops llop = fuse_path_ops;\n\n\tf = (struct fuse *) calloc(1, sizeof(struct fuse));\n\tif (f == NULL) {\n\t\tfuse_log(FUSE_LOG_ERR, \"fuse: failed to allocate fuse object\\n\");\n\t\tgoto out;\n\t}\n\n\tf->conf.entry_timeout = 1.0;\n\tf->conf.attr_timeout = 1.0;\n\tf->conf.negative_timeout = 0.0;\n\tf->conf.intr_signal = FUSE_DEFAULT_INTR_SIGNAL;\n\n\t/* Parse options */\n\tif (fuse_opt_parse(args, &f->conf, fuse_lib_opts,\n\t\t\t   fuse_lib_opt_proc) == -1)\n\t\tgoto out_free;\n\n\tpthread_mutex_lock(&fuse_context_lock);\n\tstatic int builtin_modules_registered = 0;\n\t/* Have the builtin modules already been registered? */\n\tif (builtin_modules_registered == 0) {\n\t\t/* If not, register them. */\n\t\tfuse_register_module(\"subdir\", fuse_module_subdir_factory, NULL);\n#ifdef HAVE_ICONV\n\t\tfuse_register_module(\"iconv\", fuse_module_iconv_factory, NULL);\n#endif\n\t\tbuiltin_modules_registered= 1;\n\t}\n\tpthread_mutex_unlock(&fuse_context_lock);\n\n\tif (fuse_create_context_key() == -1)\n\t\tgoto out_free;\n\n\tfs = fuse_fs_new(op, op_size, user_data);\n\tif (!fs)\n\t\tgoto out_delete_context_key;\n\n\tf->fs = fs;\n\n\t/* Oh f**k, this is ugly! */\n\tif (!fs->op.lock) {\n\t\tllop.getlk = NULL;\n\t\tllop.setlk = NULL;\n\t}\n\n\tf->pagesize = getpagesize();\n\tinit_list_head(&f->partial_slabs);\n\tinit_list_head(&f->full_slabs);\n\tinit_list_head(&f->lru_table);\n\n\tif (f->conf.modules) {\n\t\tchar *module;\n\t\tchar *next;\n\n\t\tfor (module = f->conf.modules; module; module = next) {\n\t\t\tchar *p;\n\t\t\tfor (p = module; *p && *p != ':'; p++);\n\t\t\tnext = *p ? p + 1 : NULL;\n\t\t\t*p = '\\0';\n\t\t\tif (module[0] &&\n\t\t\t    fuse_push_module(f, module, args) == -1)\n\t\t\t\tgoto out_free_fs;\n\t\t}\n\t}\n\n\tif (!f->conf.ac_attr_timeout_set)\n\t\tf->conf.ac_attr_timeout = f->conf.attr_timeout;\n\n#if defined(__FreeBSD__) || defined(__NetBSD__)\n\t/*\n\t * In FreeBSD, we always use these settings as inode numbers\n\t * are needed to make getcwd(3) work.\n\t */\n\tf->conf.readdir_ino = 1;\n#endif\n\n\tf->se = fuse_session_new(args, &llop, sizeof(llop), f);\n\tif (f->se == NULL)\n\t\tgoto out_free_fs;\n\n\tif (f->conf.debug) {\n\t\tfuse_log(FUSE_LOG_DEBUG, \"nullpath_ok: %i\\n\", f->conf.nullpath_ok);\n\t}\n\n\t/* Trace topmost layer by default */\n\tf->fs->debug = f->conf.debug;\n\tf->ctr = 0;\n\tf->generation = 0;\n\tif (node_table_init(&f->name_table) == -1)\n\t\tgoto out_free_session;\n\n\tif (node_table_init(&f->id_table) == -1)\n\t\tgoto out_free_name_table;\n\n\tfuse_mutex_init(&f->lock);\n\n\troot = alloc_node(f);\n\tif (root == NULL) {\n\t\tfuse_log(FUSE_LOG_ERR, \"fuse: memory allocation failed\\n\");\n\t\tgoto out_free_id_table;\n\t}\n\tif (lru_enabled(f)) {\n\t\tstruct node_lru *lnode = node_lru(root);\n\t\tinit_list_head(&lnode->lru);\n\t}\n\n\tstrcpy(root->inline_name, \"/\");\n\troot->name = root->inline_name;\n\n\tif (f->conf.intr &&\n\t    fuse_init_intr_signal(f->conf.intr_signal,\n\t\t\t\t  &f->intr_installed) == -1)\n\t\tgoto out_free_root;\n\n\troot->parent = NULL;\n\troot->nodeid = FUSE_ROOT_ID;\n\tinc_nlookup(root);\n\thash_id(f, root);\n\n\treturn f;\n\nout_free_root:\n\tfree(root);\nout_free_id_table:\n\tfree(f->id_table.array);\nout_free_name_table:\n\tfree(f->name_table.array);\nout_free_session:\n\tfuse_session_destroy(f->se);\nout_free_fs:\n\tif (f->fs->m)\n\t\tfuse_put_module(f->fs->m);\n\tfree(f->fs);\n\tfree(f->conf.modules);\nout_delete_context_key:\n\tfuse_delete_context_key();\nout_free:\n\tfree(f);\nout:\n\treturn NULL;\n}\n\n/* Emulates 3.0-style fuse_new(), which processes --help */\nstruct fuse *fuse_new_30(struct fuse_args *args, const struct fuse_operations *op,\n\t\t\t size_t op_size, void *private_data);\nFUSE_SYMVER(\".symver fuse_new_30,fuse_new@FUSE_3.0\");\nstruct fuse *fuse_new_30(struct fuse_args *args,\n\t\t\t const struct fuse_operations *op,\n\t\t\t size_t op_size, void *user_data)\n{\n\tstruct fuse_config conf;\n\n\tmemset(&conf, 0, sizeof(conf));\n\n\tconst struct fuse_opt opts[] = {\n\t\tFUSE_LIB_OPT(\"-h\", show_help, 1),\n\t\tFUSE_LIB_OPT(\"--help\", show_help, 1),\n\t\tFUSE_OPT_END\n\t};\n\n\tif (fuse_opt_parse(args, &conf, opts,\n\t\t\t   fuse_lib_opt_proc) == -1)\n\t\treturn NULL;\n\n\tif (conf.show_help) {\n\t\tfuse_lib_help(args);\n\t\treturn NULL;\n\t} else\n\t\treturn fuse_new_31(args, op, op_size, user_data);\n}\n\nvoid fuse_destroy(struct fuse *f)\n{\n\tsize_t i;\n\n\tif (f->conf.intr && f->intr_installed)\n\t\tfuse_restore_intr_signal(f->conf.intr_signal);\n\n\tif (f->fs) {\n\t\tfuse_create_context(f);\n\n\t\tfor (i = 0; i < f->id_table.size; i++) {\n\t\t\tstruct node *node;\n\n\t\t\tfor (node = f->id_table.array[i]; node != NULL;\n\t\t\t     node = node->id_next) {\n\t\t\t\tif (node->is_hidden) {\n\t\t\t\t\tchar *path;\n\t\t\t\t\tif (try_get_path(f, node->nodeid, NULL, &path, NULL, false) == 0) {\n\t\t\t\t\t\tfuse_fs_unlink(f->fs, path);\n\t\t\t\t\t\tfree(path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < f->id_table.size; i++) {\n\t\tstruct node *node;\n\t\tstruct node *next;\n\n\t\tfor (node = f->id_table.array[i]; node != NULL; node = next) {\n\t\t\tnext = node->id_next;\n\t\t\tfree_node(f, node);\n\t\t\tf->id_table.use--;\n\t\t}\n\t}\n\tassert(list_empty(&f->partial_slabs));\n\tassert(list_empty(&f->full_slabs));\n\n\twhile (fuse_modules) {\n\t\tfuse_put_module(fuse_modules);\n\t}\n\tfree(f->id_table.array);\n\tfree(f->name_table.array);\n\tpthread_mutex_destroy(&f->lock);\n\tfuse_session_destroy(f->se);\n\tfree(f->conf.modules);\n\tfree(f);\n\tfuse_delete_context_key();\n}\n\nint fuse_mount(struct fuse *f, const char *mountpoint) {\n\treturn fuse_session_mount(fuse_get_session(f), mountpoint);\n}\n\n\nvoid fuse_unmount(struct fuse *f) {\n\tfuse_session_unmount(fuse_get_session(f));\n}\n\nint fuse_version(void)\n{\n\treturn FUSE_VERSION;\n}\n\nconst char *fuse_pkgversion(void)\n{\n\treturn PACKAGE_VERSION;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-libfuse-3.9.4-aresw5fmrqlspfz4famoaeojpijkpwtm/spack-src/doc/fast17-vangoor.pdf"
    ],
    "total_files": 93
}