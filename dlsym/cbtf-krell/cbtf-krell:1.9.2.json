{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.2-udvq3kxq3w57rec5olt2tuoem5qjwtps/spack-src/services/src/common/TLS.c": "/*******************************************************************************\n** Copyright (c) 2008 William Hachfeld. All Rights Reserved.\n** Copyright (c) 2010-2011 The Krell Institute. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n/** @file\n *\n * Definition of the CBTF_[Get|Set]]TLS() functions.\n *\n */\n\n#include \"KrellInstitute/Services/Common.h\"\n#include \"KrellInstitute/Services/TLS.h\"\n\n#include <dlfcn.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n\n\n/** Number of entries in the key/value maps. */\n#define MapSize 32\n\n/** Type representing a map of keys to their corresponding values. */\ntypedef struct {\n    uint32_t size;           /**< Actual number of entries in the map. */\n    uint32_t keys[MapSize];  /**< Keys. */\n    void* values[MapSize];   /**< Corresponding values. */\n} Map;\n\n\n\n/** Flag indicating if the process is multithreaded.  */\nstatic bool is_multithreaded = false;\n\n/** Pointer to pthread_key_create() if present. */\nstatic int (*f_pthread_key_create)(pthread_key_t*, void (*)(void*)) = NULL;\n\n/** Pointer to pthread_key_delete() if present. */\nstatic int (*f_pthread_key_delete)(pthread_key_t) = NULL;\n\n/** Pointer to pthread_getspecific() if present. */\nstatic void* (*f_pthread_getspecific)(pthread_key_t) = NULL;\n\t\t\t\t\t\t     \n/** Pointer to pthread_setspecific() if present. */\nstatic int (*f_pthread_setspecific)(pthread_key_t, const void*) = NULL;\n\n/** Key for accessing a thread's TLS map. */\nstatic pthread_key_t map_key;\n\n/** TLS map used when the process isn't actually multithreaded. */\nstatic Map map_for_process;\n\n\n\n/**\n * TLS initialization.\n *\n * Performs any one-time initialization of the internal TLS data structures.\n *\n * @note    One-time execution of this initialization is accomplished by\n *          applying the \"constructor\" attribute to this function. Doing\n *          so causes GCC to force it to be executed upon loading into a\n *          process. This attribute appears to be supported back to GCC\n *          2.95.3 or further.\n *\n * @sa    http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Function-Attributes.html\n *\n * @ingroup Implementation\n */\nstatic void __attribute__ ((constructor)) initialize()\n{\n    /* Get pointers to the Pthread functions if present in this process */\n    f_pthread_key_create = (int (*)(pthread_key_t*, void (*)(void*)))\n\tdlsym(RTLD_DEFAULT, \"pthread_key_create\");\n    f_pthread_key_delete = (int (*)(pthread_key_t))\n\tdlsym(RTLD_DEFAULT, \"pthread_key_delete\");\n    f_pthread_getspecific = (void* (*)(pthread_key_t))\n\tdlsym(RTLD_DEFAULT, \"pthread_getspecific\");\n    f_pthread_setspecific = (int (*)(pthread_key_t, const void*))\n\tdlsym(RTLD_DEFAULT, \"pthread_setspecific\");\n    \n    /* Decide if this process is multithreaded */\n    is_multithreaded = \n\t(f_pthread_key_create != NULL) && (f_pthread_key_delete != NULL) &&\n\t(f_pthread_getspecific != NULL) && (f_pthread_setspecific != NULL);\n\n    /* Is this process multithreaded? */\n    if(is_multithreaded) {\n\n\t/* Create the key for accessing a thread's TLS map */\n\tAssert((*f_pthread_key_create)(&map_key, free) == 0);\n\n    }\n    else {\n\n\t/* Initialize the process-wide TLS map */\n\tmemset(&map_for_process, 0, sizeof(Map));\n\n    }\t\n}\n\n\n\n/**\n * Get the value for a key.\n *\n * Returns a pointer to the value corresponding to the specified key.\n *\n * @param key    Key for which to get the value.\n * @return       Pointer to the current value corresponding to that key.\n *\n * @ingroup Implementation\n */\nstatic void** getValue(uint32_t key)\n{\n    Map* map = &map_for_process;\n    unsigned bucket;\n\n    /* Is this process multithreaded? */\n    if(is_multithreaded) {\n\t\n\t/** Get this thread's TLS map */\n\tmap = (Map*)(*f_pthread_getspecific)(map_key);\n\n\t/** Is this the first time this thread's TLS map was accessed? */\n\tif(map == NULL) {\n\t    \n\t    /* Allocate and initialize a new TLS map */\n\t    map = (Map*)malloc(sizeof(Map));\n\t    Assert(map != NULL);\n\t    memset(map, 0, sizeof(Map));\n\n\t    /* Make it this thread's TLS map */\n\t    Assert((*f_pthread_setspecific)(map_key, map) == 0);\n\t    \n\t}\n\t\n    }\n    \n    /* Check assertions */\n    Assert(map != NULL);\n\n    /*\n     * Search this thread's TLS map for an existing entry corresponding to the\n     * specified key. Use a hash table with a simple linear probe to accelerate\n     * the search.\n     */\n    bucket = key % MapSize;\n    while((map->keys[bucket] > 0) && (map->keys[bucket] != key))\n\tbucket = (bucket + 1) % MapSize;\n\n    /* Is this the first time accessing this key? */\n    if(map->keys[bucket] == 0) {\n\n\t/* Place this key into the map (with an initially-NULL value) */\n\tmap->keys[bucket] = key;\n\tmap->size++;\n\t\n\t/*\n\t * Check assertions. There must always be at least one empty (zero)\n\t * key in the map or the simple linear probe above would become an\n\t * infinite loop.\n\t */\n\tAssert(map->size < (MapSize - 1));\n\t\n    }\n\n    /* Return the value's pointer to the caller */\n    return &(map->values[bucket]);\n}\n\n\n\n/**\n * Get a TLS value.\n *\n * Returns the value in thread-local storage (TLS) corresponding to the\n * specified key.\n *\n * @sa    http://en.wikipedia.org/wiki/Thread-local_storage\n *\n * @param key    Key for which to get the value.\n * @return       Current value corresponding to that key.\n *\n * @ingroup RuntimeAPI\n */\nvoid* CBTF_GetTLS(uint32_t key)\n{\n//fprintf(stderr,\"CBTF_GetTLS GET gets key %#X\\n\",key);\n    void** map_value = NULL;\n    \n    /** Check preconditions */\n    Assert(key > 0);\n\n    /** Get a pointer to the value corresponding to this key */\n    map_value = getValue(key);\n    Assert(map_value != NULL);\n\n    /** Return the current value of this key to the caller */\n    return *map_value;\n}\n\n\n\n/**\n * Set a TLS value.\n *\n * Sets the value in thread-local storage (TLS) corresponding to the\n * specified key.\n *\n * @sa    http://en.wikipedia.org/wiki/Thread-local_storage\n *\n * @param key      Key for which to get the value.\n * @param value    New value corresponding to that key.\n *\n * @ingroup RuntimeAPI\n */\nvoid CBTF_SetTLS(uint32_t key, void* value)\n{\n//fprintf(stderr,\"CBTF_SetTLS SET sets key %#X\\n\",key);\n    void** map_value = NULL;\n    \n    /** Check preconditions */\n    Assert(key > 0);\n\n    /** Get a pointer to the value corresponding to this key */\n    map_value = getValue(key);\n    Assert(map_value != NULL);\n\n    /** Set this key's new value */\n    *map_value = value;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.2-udvq3kxq3w57rec5olt2tuoem5qjwtps/spack-src/core/collectors/mem/wrappers.c": "/*******************************************************************************\n** Copyright (c) 2011-18 The Krell Institute. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n#define _GNU_SOURCE\n#ifndef __USE_GNU \n#define __USE_GNU /* XXX for RTLD_NEXT on Linux */ \n#endif /* !__USE_GNU */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"KrellInstitute/Messages/Mem_data.h\"\n#include \"KrellInstitute/Services/Assert.h\"\n#include \"KrellInstitute/Services/Common.h\"\n#include \"KrellInstitute/Services/Time.h\"\n\n\n#if !defined(CBTF_SERVICE_USE_OFFLINE)\n#include <unistd.h>\n#include <fcntl.h>\n#endif\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <stdlib.h>\n\nextern bool_t mem_do_trace(const char* traced_func);\nextern void mem_start_event(CBTF_memt_event* event);\nextern void mem_record_event(const CBTF_memt_event* event, uint64_t function);\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n#if 0\nstatic bool is_initializing;\n\nstatic void* (*f_malloc)(size_t);\nstatic void* (*f_calloc)(size_t, size_t);\nstatic void* (*f_realloc)(void*, size_t);\nstatic void* (*f_free)(void*);\nstatic int (*f_posix_memalign)(void **, size_t, size_t);\nstatic int (*f_memalign)(size_t, size_t);\n\nstatic void mem_f_initialize()\n{\n    f_malloc = dlsym(RTLD_NEXT, \"malloc\");\n    f_calloc = dlsym(RTLD_NEXT, \"calloc\");\n    f_realloc = dlsym(RTLD_NEXT, \"realloc\");\n    f_free = dlsym(RTLD_NEXT, \"free\");\n    f_posix_memalign = dlsym(RTLD_NEXT, \"posix_memalign\");\n    f_memalign = dlsym(RTLD_NEXT, \"memalign\");\n}\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nvoid* __real_malloc(size_t);\nvoid* __real_calloc(size_t, size_t);\nvoid* __real_realloc(void*, size_t);\nvoid* __real_free(void*);\nint __real_posix_memalign(void **, size_t, size_t);\nint __real_memalign(size_t, size_t);\n#endif\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n#ifdef malloc\n#undef malloc\n#endif\nvoid* malloc(size_t size) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nvoid* __wrap_malloc(size_t size)\n#else\nvoid* memmalloc(size_t size)\n#endif\n{\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n#endif\n\n    void* retval;\n    CBTF_memt_event event;\n\n    bool_t dotrace = mem_do_trace(\"malloc\");\n\n    if (dotrace) {\n        mem_start_event(&event);\n        event.start_time = CBTF_GetTime();\n\tevent.mem_type = CBTF_MEM_MALLOC;\n    }\n\n    /* Call the real MEM function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_malloc(size);\n#else\n    static void* (*f_malloc)(size_t) = NULL;\n    if (!f_malloc)\n\tf_malloc = dlsym(RTLD_NEXT, \"malloc\");\n    retval = f_malloc(size);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n\tevent.ptr = 0;\n\tevent.size1 = size;\n\tevent.size2 = size;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        mem_record_event(&event, (uint64_t) __real_malloc);\n#else\n        mem_record_event(&event, CBTF_GetAddressOfFunction(f_malloc));\n#endif\n    }\n    \n    /* Return the real MEM function's return value to the caller */\n    return retval;\n}\n\n\n/* NOTE: The openmpi libraries call calloc before we are setup and\n * calloc calls fail.  In addition, using dlsym can also cause a crash.\n * The temporary solution for the dynamic case is to rely on __libc_calloc\n * as the real dynamic libc calloc call.\n */\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n#ifdef calloc\n#undef calloc\n#endif\nvoid* calloc(size_t count, size_t size) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nvoid* __wrap_calloc(size_t count, size_t size)\n#else\nvoid* memcalloc(size_t count, size_t size)\n#endif\n{\n    void* retval;\n    CBTF_memt_event event;\n\n    bool_t dotrace = mem_do_trace(\"calloc\");\n\n    if (dotrace) {\n        mem_start_event(&event);\n        event.start_time = CBTF_GetTime();\n\tevent.mem_type = CBTF_MEM_CALLOC;\n    }\n\n    /* Call the real MEM function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_calloc(count,size);\n#else\n    extern void *__libc_calloc(size_t, size_t);\n    retval = __libc_calloc(count,size);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n\tevent.ptr = 0;\n\tevent.size1 = count;\n\tevent.size2 = size;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        mem_record_event(&event, (uint64_t) __real_calloc);\n#else\n        mem_record_event(&event, CBTF_GetAddressOfFunction(__libc_calloc));\n#endif\n    }\n    \n    /* Return the real MEM function's return value to the caller */\n    return retval;\n}\n\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n#ifdef realloc\n#undef realloc\n#endif\nvoid* realloc(void* oldPtr, size_t size) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nvoid* __wrap_realloc(void* oldPtr, size_t size)\n#else\nvoid* memrealloc(void* oldPtr, size_t size)\n#endif\n{\n    static void* (*f_realloc)(void*, size_t);\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n    if (f_realloc == NULL) {\n\tf_realloc = dlsym (RTLD_NEXT, \"realloc\");\n    }\n    if (f_realloc == NULL)\n\treturn NULL;\n#endif\n\n    void* retval;\n    CBTF_memt_event event;\n\n    bool_t dotrace = mem_do_trace(\"realloc\");\n\n    if (dotrace) {\n        mem_start_event(&event);\n        event.start_time = CBTF_GetTime();\n\tevent.mem_type = CBTF_MEM_REALLOC;\n    }\n\n    /* Call the real MEM function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_realloc(oldPtr,size);\n#else\n    retval = f_realloc(oldPtr,size);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n\tevent.ptr = (uint64_t)oldPtr;\n\tevent.size1 = size;\n\tevent.size2 = size;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        mem_record_event(&event, (uint64_t) __real_realloc);\n#else\n        mem_record_event(&event, CBTF_GetAddressOfFunction(f_realloc));\n#endif\n    }\n    \n    /* Return the real MEM function's return value to the caller */\n    return retval;\n}\n\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint posix_memalign(void ** memptr, size_t alignment, size_t size)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_posix_memalign(void ** memptr, size_t alignment, size_t size)\n#else\nint memposix_memalign(void ** memptr, size_t alignment, size_t size)\n#endif\n{    \n    static int (*f_posix_memalign)(void **, size_t, size_t);\n    int retval;\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n    if (f_posix_memalign == NULL) {\n\tf_posix_memalign = dlsym (RTLD_NEXT, \"posix_memalign\");\n    }\n    if (f_posix_memalign == NULL)\n\treturn 0;\n#endif\n\n    CBTF_memt_event event;\n\n    bool_t dotrace = mem_do_trace(\"posix_memalign\");\n\n    if (dotrace) {\n        mem_start_event(&event);\n        event.start_time = CBTF_GetTime();\n\tevent.mem_type = CBTF_MEM_POSIX_MEMALIGN;\n    }\n\n    /* Call the real MEM function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_posix_memalign(memptr,alignment,size);\n#else\n    retval = f_posix_memalign(memptr,alignment,size);\n\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n\tevent.ptr = (uint64_t)(*memptr);\n\tevent.size1 = alignment;\n\tevent.size2 = size;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        mem_record_event(&event, (uint64_t) __real_posix_memalign);\n#else\n        mem_record_event(&event, CBTF_GetAddressOfFunction(f_posix_memalign));\n#endif\n    }\n    \n\n    /* Return the real MEM function's return value to the caller */\n    return retval;\n}\n\n\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint memalign(size_t blocksize, size_t bytes)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_memalign(size_t blocksize, size_t bytes)\n#else\nint memmemalign(size_t blocksize, size_t bytes)\n#endif\n{    \n    int retval;\n    static int (*f_memalign)(size_t, size_t);\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n    if (f_memalign == NULL) {\n\tf_memalign = dlsym (RTLD_NEXT, \"memalign\");\n    }\n    if (f_memalign == NULL)\n\treturn 0;\n#endif\n    CBTF_memt_event event;\n\n    bool_t dotrace = mem_do_trace(\"memalign\");\n\n    if (dotrace) {\n        mem_start_event(&event);\n        event.start_time = CBTF_GetTime();\n\tevent.mem_type = CBTF_MEM_MEMALIGN;\n    }\n\n    /* Call the real MEM function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_memalign(blocksize,bytes);\n#else\n    retval = f_memalign(blocksize,bytes);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n\tevent.ptr = 0;\n\tevent.size1 = blocksize;\n\tevent.size2 = bytes;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        mem_record_event(&event, (uint64_t) __real_memalign);\n#else\n        mem_record_event(&event, CBTF_GetAddressOfFunction(f_memalign));\n#endif\n    }\n    \n\n    /* Return the real MEM function's return value to the caller */\n    return retval;\n}\n\n\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n#ifdef free\n#undef free\n#endif\nvoid free(void * ptr)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nvoid __wrap_free(void * ptr)\n#else\nvoid memfree(void * ptr)\n#endif\n{\n    static void* (*f_free)(void*);\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n    if (f_free == NULL) {\n\tf_free = dlsym (RTLD_NEXT, \"free\");\n    }\n    if (f_free == NULL)\n\treturn;\n#endif\n    CBTF_memt_event event;\n\n    bool_t dotrace = mem_do_trace(\"free\");\n\n    /* when ptr is NULL free is a no-op. We could record these if desired\n     * but the cost is high.  Only reason to record is to pinpoint the\n     * locations where code is calling free with a NULL ptr.\n     */\n    if (ptr == NULL) dotrace = FALSE;\n\n    if (dotrace) {\n        mem_start_event(&event);\n        event.start_time = CBTF_GetTime();\n\tevent.mem_type = CBTF_MEM_FREE;\n    }\n\n    /* Call the real MEM function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    __real_free(ptr);\n#else\n    f_free(ptr);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = 0;\n\tevent.ptr = (uint64_t)ptr;\n\tevent.size1 = 0;\n\tevent.size2 = 0;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        mem_record_event(&event, (uint64_t) __real_free);\n#else\n        mem_record_event(&event, CBTF_GetAddressOfFunction(f_free));\n#endif\n    }\n    \n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.2-udvq3kxq3w57rec5olt2tuoem5qjwtps/spack-src/core/collectors/io/wrappers.c": "/*******************************************************************************\n** Copyright (c) 2005 Silicon Graphics, Inc. All Rights Reserved.\n** Copyright (c) 2006-2016 The Krell Institute. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n#define _GNU_SOURCE\n#ifndef __USE_GNU \n#define __USE_GNU /* XXX for RTLD_NEXT on Linux */ \n#endif /* !__USE_GNU */\n#define _XOPEN_SOURCE 500 /* for readlink */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"KrellInstitute/Messages/IO_data.h\"\n#include \"KrellInstitute/Services/Assert.h\"\n#include \"KrellInstitute/Services/Common.h\"\n#include \"KrellInstitute/Services/Time.h\"\n\n\n#if !defined(CBTF_SERVICE_USE_OFFLINE)\n#include <syscall.h>\n#include <unistd.h>\n#include <fcntl.h>\n#endif\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#if defined(PROFILE)\nextern void io_record_event(const CBTF_iop_event*, uint64_t);\nextern void io_start_event(CBTF_iop_event*);\n#else\n#if defined(EXTENDEDTRACE)\nextern void io_record_event(const CBTF_iot_event*, uint64_t);\nextern void io_start_event(CBTF_iot_event*);\n#else\nextern void io_record_event(const CBTF_io_event*, uint64_t);\nextern void io_start_event(CBTF_io_event*);\n#endif\n#endif\n\nextern bool_t io_do_trace(const char*);\n\n\n/* Start part 2 of 2 for Hack to get around inconsistent syscall definitions */\n#include <sys/syscall.h>\n#ifdef __NR_pread64  /* Newer kernels renamed but it's the same.  */\n# ifndef __NR_pread\n# define __NR_pread __NR_pread64\n# endif\n#endif\n\n#ifdef __NR_pwrite64  /* Newer kernels renamed but it's the same.  */\n# ifndef __NR_pwrite\n#  define __NR_pwrite __NR_pwrite64\n# endif\n#endif\n/* End part 2 of 2 for Hack to get around inconsistent syscall definitions */\n\n/*\n * IO Wrapper Functions\n *\n */\n\n/*\nThe following IO SYS calls are traced by the IOCollector.\nThese calls are traced using their weak names\n(e.g. \"open\" rather than \"__libc_open\").\nTo trace via the weak names requires a version dpcl that\ncreates FunctionObj's with the alt_name field set to\nthe alternate name returned by dyninst's findFunction.\nCurrently, dpcl-20051215-8 has the needed get_alt_name\ncall which the IOCollector depends on.\n\nsee /usr/include/bits/syscall.h for details.\nSYS_pread;\nSYS_read;\nSYS_readv;\nSYS_pwrite;\nSYS_write;\nSYS_writev;\nSYS_lseek;\nSYS_creat;\nSYS_open;\nSYS_close;\nSYS_dup;\nSYS_dup2;\nSYS_pipe;\nSYS_open64;\nSYS_creat64;\nSYS_pread64;\nSYS_pwrite64;\nSYS_lseek64;\n*/\n\n\n#if defined(EXTENDEDTRACE)\n/* used by io_record_event to record pathnames into pathnames buffer */\n/* currentpathname must be set prior to calling io_record_event. */\n/* io_record_event sets pathindex and so we must set event.pathindex */\n/* after the call to io_record_event in each wrapper. */\n/* Currently we record a pathname that is passed as an argument. */\n/* TODO: On linux, we can examine /proc/\"mypid\"/fd after an syscall is made */\n/* that uses a file descriptor (e.g. read). This is one way to map a */\n/* file descriptor to a pathname. */\n\nextern char currentpathname[PATH_MAX];\n#endif\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n#ifdef read\n#undef read\n#endif\nssize_t read(int fd, void *buf, size_t count) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_read(int fd, void *buf, size_t count) \n#else\nssize_t ioread(int fd, void *buf, size_t count) \n#endif\n{\n    ssize_t retval;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n    int status = -1;\n    char namebuf[1024];\n    char pf[256];\n    memset(namebuf, 0, sizeof(namebuf));\n    memset(pf, 0, sizeof(pf));\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"read\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_read(fd, buf, count);\n#else\n    ssize_t (*realfunc)() = dlsym (RTLD_NEXT, \"read\");\n    retval = (*realfunc)(fd, buf, count);\n#endif\n\n\n    if (dotrace) {\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n    event.syscallno = SYS_read;\n    event.nsysargs = 3;\n    event.sysargs[0] = fd;\n    event.sysargs[1] = (long) buf;\n    event.sysargs[2] = count;\n    event.retval = retval;\n\n#ifdef DEBUG_IOT\n    printf(\"iotread, fd=%d, namebuf=%s\\n\", fd, namebuf);\n#endif\n    /* use that to get the path into /proc. */\n    sprintf(pf,\"/proc/self/fd/%d\",fd);\n\n    /* Read the link the file descriptor points to in the /proc filesystem */\n    status = readlink(pf,namebuf,1024);\n    if (status > 1024) {\n      printf(\"ERROR, name too large\\n\");\n    }\n    namebuf[status] = 0;\n    strncpy(currentpathname,namebuf,strlen(namebuf));\n/*\n    event.sysargs[3] = namebuf;\n*/\n\n#ifdef DEBUG_IOT\n    printf(\"iotread, status=%d, namebuf=%s\\n\", status, namebuf);\n#endif\n\n#endif\n#endif\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_read));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_read);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n//#ifndef DEBUG\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nssize_t write(int fd, __const void *buf, size_t count) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_write(int fd, __const void *buf, size_t count) \n#else\nssize_t iowrite(int fd, void *buf, size_t count) \n#endif\n{    \n    ssize_t retval;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n    int status = -1;\n    char namebuf[1024];\n    char pf[256];\n    memset(namebuf, 0, sizeof(namebuf));\n    memset(pf, 0, sizeof(pf));\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"write\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_write(fd, buf, count);\n#else\n    ssize_t (*realfunc)() = dlsym (RTLD_NEXT, \"write\");\n    retval = (*realfunc)(fd, buf, count);\n#endif\n\n\n    if (dotrace) {\n\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n\n#else\n\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n    event.syscallno = SYS_write;\n    event.nsysargs = 3;\n    event.sysargs[0] = fd;\n    event.sysargs[1] = (long) buf;\n    event.sysargs[2] = count;\n    event.retval = retval;\n\n#ifdef DEBUG_IOT\n    printf(\"iotwrite, fd=%d, namebuf=%s\\n\", fd, namebuf);\n#endif\n    /* use that to get the path into /proc. */\n    sprintf(pf,\"/proc/self/fd/%d\",fd);\n\n    /* Read the link the file descriptor points to in the /proc filesystem */\n    status = readlink(pf,namebuf,1024);\n    if (status > 1024) {\n      printf(\"ERROR, name too large\\n\");\n    }\n    namebuf[status] = 0;\n    strncpy(currentpathname,namebuf,strlen(namebuf));\n#endif\n#endif\n\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_write));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_write);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n\n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n//#endif\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\noff_t lseek(int fd, off_t offset, int whence) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\noff_t __wrap_lseek(int fd, off_t offset, int whence) \n#else\noff_t iolseek(int fd, off_t offset, int whence) \n#endif\n{\n    off_t retval;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n    int status = -1;\n    char namebuf[1024];\n    char pf[256];\n    memset(namebuf, 0, sizeof(namebuf));\n    memset(pf, 0, sizeof(pf));\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"lseek\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_lseek(fd, offset, whence);\n#else\n    off_t (*realfunc)() = dlsym (RTLD_NEXT, \"lseek\");\n    retval = (*realfunc)(fd, offset, whence);\n#endif\n\n\n    if (dotrace) {\n#if defined(PROFILE)\n\n    event.time = CBTF_GetTime() - start_time;\n#else\n\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n    event.syscallno = SYS_lseek;\n    event.nsysargs = 3;\n    event.sysargs[0] = fd;\n    event.sysargs[1] = offset;\n    event.sysargs[2] = whence;\n    event.retval = retval;\n\n    /* use that to get the path into /proc. */\n    sprintf(pf,\"/proc/self/fd/%d\",fd);\n\n    /* Read the link the file descriptor points to in the /proc filesystem */\n    status = readlink(pf,namebuf,1024);\n    if (status > 1024) {\n      printf(\"ERROR, name too large\\n\");\n    }\n    namebuf[status] = 0;\n    strncpy(currentpathname,namebuf,strlen(namebuf));\n#ifdef DEBUG_IOT\n    printf(\"iotlseek, fd=%d, namebuf=%s\\n\", fd, namebuf);\n#endif\n\n#endif\n#endif\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_lseek));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_lseek);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n__off64_t lseek64(int fd, __off64_t offset, int whence) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n__off64_t __wrap_lseek64(int fd, __off64_t offset, int whence) \n#else\noff_t iolseek64(int fd, off_t offset, int whence) \n#endif\n{\n    off_t retval;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n    int status = -1;\n    char namebuf[1024];\n    char pf[256];\n    memset(namebuf, 0, sizeof(namebuf));\n    memset(pf, 0, sizeof(pf));\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"lseek64\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_lseek64(fd, offset, whence);\n#else\n    off_t (*realfunc)() = dlsym (RTLD_NEXT, \"lseek64\");\n    retval = (*realfunc)(fd, offset, whence);\n#endif\n\n\n    if (dotrace) {\n\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n    event.syscallno = SYS_lseek;\n    event.nsysargs = 3;\n    event.sysargs[0] = fd;\n    event.sysargs[1] = offset;\n    event.sysargs[2] = whence;\n    event.retval = retval;\n\n    /* use that to get the path into /proc. */\n    sprintf(pf,\"/proc/self/fd/%d\",fd);\n\n    /* Read the link the file descriptor points to in the /proc filesystem */\n    status = readlink(pf,namebuf,1024);\n    if (status > 1024) {\n      printf(\"ERROR, name too large\\n\");\n    }\n    namebuf[status] = 0;\n    strncpy(currentpathname,namebuf,strlen(namebuf));\n#ifdef DEBUG_IOT\n    printf(\"iotlseek64, fd=%d, namebuf=%s\\n\", fd, namebuf);\n#endif\n\n#endif\n#endif\n\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_lseek64));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_lseek64);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint open(const char *pathname, int flags, mode_t mode) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_open(const char *pathname, int flags, mode_t mode) \n#else\nint ioopen(const char *pathname, int flags, mode_t mode) \n#endif\n{\n    int retval = 0;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"open\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_open(pathname, flags, mode);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"open\");\n    retval = (*realfunc)(pathname, flags, mode);\n#endif\n\n\n    if (dotrace) {\n\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n    event.retval = retval;\n    event.syscallno = SYS_open;\n    event.nsysargs = 3;\n    event.sysargs[0] = (long) pathname;\n    event.sysargs[1] = flags;\n    event.sysargs[2] = mode;\n\n    strncpy(currentpathname,pathname,strlen(pathname));\n#endif\n#endif\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_open));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_open);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n\n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint open64(const char *pathname, int flags, mode_t mode) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_open64(const char *pathname, int flags, mode_t mode) \n#else\nint ioopen64(const char *pathname, int flags, mode_t mode) \n#endif\n{\n    int retval = 0;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"open64\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_open64(pathname, flags, mode);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"open64\");\n    retval = (*realfunc)(pathname, flags, mode);\n#endif\n\n\n    if (dotrace) {\n\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n    event.syscallno = SYS_open;\n    event.nsysargs = 3;\n    event.sysargs[0] = (long) pathname;\n    event.sysargs[1] = flags;\n    event.sysargs[2] = mode;\n    event.retval = retval;\n    strncpy(currentpathname,pathname,strlen(pathname));\n#endif\n#endif\n\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_open64));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_open64);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint close(int fd) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_close(int fd) \n#else\nint ioclose(int fd) \n#endif\n{\n    int retval;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n    int status = -1;\n    char namebuf[1024];\n    char pf[256];\n    memset(namebuf, 0, sizeof(namebuf));\n    memset(pf, 0, sizeof(pf));\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"close\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n\t/* use that to get the path into /proc. */\n\tsprintf(pf,\"/proc/self/fd/%d\",fd);\n\n\t/* Read the link the file descriptor points to in the /proc filesystem */\n\tstatus = readlink(pf,namebuf,1024);\n\tif (status > 1024) {\n\t    printf(\"ERROR, name too large\\n\");\n\t}\n\tnamebuf[status] = 0;\n#ifdef DEBUG_IOT\n\tprintf(\"iotclose, fd=%d, namebuf=%s\\n\", fd, namebuf);\n#endif\n\n\tstrncpy(currentpathname,namebuf,strlen(namebuf));\n#endif\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_close(fd);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"close\");\n    retval = (*realfunc)(fd);\n#endif\n\n\n    if (dotrace) {\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n    event.syscallno = SYS_close;\n    event.nsysargs = 1;\n    event.sysargs[0] = fd;\n    event.retval = retval;\n#endif\n#endif\n\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_close));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_close);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint dup(int oldfd) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_dup(int oldfd) \n#else\nint iodup(int oldfd) \n#endif\n{\n    int retval;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n    int status = -1;\n    char namebuf[1024];\n    char pf[256];\n    memset(namebuf, 0, sizeof(namebuf));\n    memset(pf, 0, sizeof(pf));\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"dup\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_dup(oldfd);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"dup\");\n    retval = (*realfunc)(oldfd);\n#endif\n\n\n    if (dotrace) {\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n    event.syscallno = SYS_dup;\n    event.nsysargs = 1;\n    event.sysargs[0] = oldfd;\n    event.retval = retval;\n\n    /* use that to get the path into /proc. */\n    sprintf(pf,\"/proc/self/fd/%d\",oldfd);\n\n    /* Read the link the file descriptor points to in the /proc filesystem */\n    status = readlink(pf,namebuf,1024);\n    if (status > 1024) {\n      printf(\"ERROR, name too large\\n\");\n    }\n    namebuf[status] = 0;\n    strncpy(currentpathname,namebuf,strlen(namebuf));\n#ifdef DEBUG_IOT\n    printf(\"iotdup, oldfd=%d, namebuf=%s\\n\", oldfd, namebuf);\n#endif\n\n#endif\n#endif\n\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_dup));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_dup);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint dup2(int oldfd, int newfd) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_dup2(int oldfd, int newfd) \n#else\nint iodup2(int oldfd, int newfd) \n#endif\n{\n    int retval;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n    int status = -1;\n    char namebuf[1024];\n    char pf[256];\n    memset(namebuf, 0, sizeof(namebuf));\n    memset(pf, 0, sizeof(pf));\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"dup2\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_dup2(oldfd,newfd);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"dup2\");\n    retval = (*realfunc)(oldfd,newfd);\n#endif\n\n\n    if (dotrace) {\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n    event.syscallno = SYS_dup2;\n    event.nsysargs = 2;\n    event.sysargs[0] = oldfd;\n    event.sysargs[1] = newfd;\n    event.retval = retval;\n\n    /* use that to get the path into /proc. */\n    sprintf(pf,\"/proc/self/fd/%d\",oldfd);\n\n    /* Read the link the file descriptor points to in the /proc filesystem */\n    status = readlink(pf,namebuf,1024);\n    if (status > 1024) {\n      printf(\"ERROR, name too large\\n\");\n    }\n    namebuf[status] = 0;\n    strncpy(currentpathname,namebuf,strlen(namebuf));\n#ifdef DEBUG_IOT\n    printf(\"iotdup2, oldfd=%d, namebuf=%s\\n\", oldfd, namebuf);\n#endif\n#endif\n#endif\n\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_dup2));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_dup2);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint creat(char *pathname, mode_t mode) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_creat(char *pathname, mode_t mode) \n#else\nint iocreat(char *pathname, mode_t mode) \n#endif\n{\n    int retval = 0;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"creat\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_creat(pathname,mode);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"creat\");\n    retval = (*realfunc)(pathname,mode);\n#endif\n\n\n    if (dotrace) {\n\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n    event.retval = retval;\n    event.syscallno = SYS_creat;\n    event.nsysargs = 2;\n    event.sysargs[0] = (long) pathname;\n    event.sysargs[1] = mode;\n\n    strncpy(currentpathname,pathname,strlen(pathname));\n#endif\n#endif\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_creat));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_creat);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }    \n\n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint creat64(char *pathname, mode_t mode) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_creat64(char *pathname, mode_t mode) \n#else\nint iocreat64(char *pathname, mode_t mode) \n#endif\n{\n    int retval;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"creat64\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_creat64(pathname,mode);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"creat64\");\n    retval = (*realfunc)(pathname,mode);\n#endif\n\n\n    if (dotrace) {\n\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n    event.syscallno = SYS_creat;\n    event.nsysargs = 2;\n    event.sysargs[0] = (long) pathname;\n    event.sysargs[1] = mode;\n    event.retval = retval;\n    strncpy(currentpathname,pathname,strlen(pathname));\n#endif\n#endif\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_creat64));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_creat64);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n\n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint pipe(int filedes[2]) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_pipe(int filedes[2]) \n#else\nint iopipe(int filedes[2]) \n#endif\n{\n    int retval;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"pipe\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pipe(filedes);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"pipe\");\n    retval = (*realfunc)(filedes);\n#endif\n\n\n    if (dotrace) {\n\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n    event.syscallno = SYS_pipe;\n    event.nsysargs = 1;\n    event.sysargs[0] = (long) filedes;\n    event.retval = retval;\n#endif\n#endif\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_pipe));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_pipe);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nssize_t pread(int fd, void *buf, size_t count, off_t offset) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_pread(int fd, void *buf, size_t count, off_t offset) \n#else\nssize_t iopread(int fd, void *buf, size_t count, off_t offset) \n#endif\n{\n    ssize_t retval;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"pread\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pread(fd, buf, count, offset);\n#else\n    ssize_t (*realfunc)() = dlsym (RTLD_NEXT, \"pread\");\n    retval = (*realfunc)(fd, buf, count, offset);\n#endif\n\n\n    if (dotrace) {\n\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n#if   defined(__linux) && defined(SYS_pread)\n    event.syscallno = SYS_pread;\n#elif defined(__linux) && defined(SYS_pread64)\n    event.syscallno = SYS_pread64;\n#else\n#error \"SYS_pread or SYS_pread64 is not defined\"\n#endif\n\n\n    event.nsysargs = 4;\n    event.sysargs[0] = fd;\n    event.sysargs[1] = (long) buf;\n    event.sysargs[2] = count;\n    event.sysargs[3] = offset;\n    event.retval = retval;\n#endif\n#endif\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_pread));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_pread);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nssize_t pread64(int fd, void *buf, size_t count, __off64_t offset) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_pread64(int fd, void *buf, size_t count, __off64_t offset) \n#else\nssize_t iopread64(int fd, void *buf, size_t count, off_t offset) \n#endif\n{\n    ssize_t retval;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n    int status = -1;\n    char namebuf[1024];\n    char pf[256];\n    memset(namebuf, 0, sizeof(namebuf));\n    memset(pf, 0, sizeof(pf));\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"pread64\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pread64(fd, buf, count, offset);\n#else\n    ssize_t (*realfunc)() = dlsym (RTLD_NEXT, \"pread64\");\n    retval = (*realfunc)(fd, buf, count, offset);\n#endif\n\n\n    if (dotrace) {\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n#if   defined(__linux) && defined(SYS_pread)\n    event.syscallno = SYS_pread;\n#elif defined(__linux) && defined(SYS_pread64)\n    event.syscallno = SYS_pread64;\n#else\n#error \"SYS_pread or SYS_pread64 is not defined\"\n#endif\n\n\n    event.nsysargs = 4;\n    event.sysargs[0] = fd;\n    event.sysargs[1] = (long) buf;\n    event.sysargs[2] = count;\n    event.sysargs[3] = offset;\n    event.retval = retval;\n\n#ifdef DEBUG_IOT\n    printf(\"iotpread64, fd=%d, namebuf=%s\\n\", fd, namebuf);\n#endif\n    /* use that to get the path into /proc. */\n    sprintf(pf,\"/proc/self/fd/%d\",fd);\n\n    /* Read the link the file descriptor points to in the /proc filesystem */\n    status = readlink(pf,namebuf,1024);\n    if (status > 1024) {\n      printf(\"ERROR, name too large\\n\");\n    }\n    namebuf[status] = 0;\n    strncpy(currentpathname,namebuf,strlen(namebuf));\n#endif\n#endif\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_pread64));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_pread64);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#ifndef DEBUG\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nssize_t pwrite(int fd, __const void *buf, size_t count, __off_t offset) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_pwrite(int fd, __const void *buf, size_t count, __off_t offset) \n#else\nssize_t iopwrite(int fd, void *buf, size_t count, off_t offset) \n#endif\n{\n    ssize_t retval;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n    int status = -1;\n    char namebuf[1024];\n    char pf[256];\n    memset(namebuf, 0, sizeof(namebuf));\n    memset(pf, 0, sizeof(pf));\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"pwrite\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pwrite(fd, buf, count, offset);\n#else\n    ssize_t (*realfunc)() = dlsym (RTLD_NEXT, \"pwrite\");\n    retval = (*realfunc)(fd, buf, count, offset);\n#endif\n\n\n    if (dotrace) {\n\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n#if   defined(__linux) && defined(SYS_pwrite)\n    event.syscallno = SYS_pwrite;\n#elif defined(__linux) && defined(SYS_pwrite64)\n    event.syscallno = SYS_pwrite64;\n#else\n#error \"SYS_pwrite or SYS_pwrite64 is not defined\"\n#endif\n\n\n    event.nsysargs = 4;\n    event.sysargs[0] = fd;\n    event.sysargs[1] = (long) buf;\n    event.sysargs[2] = count;\n    event.sysargs[3] = offset;\n    event.retval = retval;\n#ifdef DEBUG_IOT\n    printf(\"iotpwrite, fd=%d, namebuf=%s\\n\", fd, namebuf);\n#endif\n    /* use that to get the path into /proc. */\n    sprintf(pf,\"/proc/self/fd/%d\",fd);\n\n    /* Read the link the file descriptor points to in the /proc filesystem */\n    status = readlink(pf,namebuf,1024);\n    if (status > 1024) {\n      printf(\"ERROR, name too large\\n\");\n    }\n    namebuf[status] = 0;\n    strncpy(currentpathname,namebuf,strlen(namebuf));\n#endif\n#endif\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_pwrite));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_pwrite);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n#endif\n\n#ifndef DEBUG\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nssize_t pwrite64(int fd, __const void *buf, size_t count, __off64_t offset) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_pwrite64(int fd, __const void *buf, size_t count, __off64_t offset) \n#else\nssize_t iopwrite64(int fd, void *buf, size_t count, off_t offset) \n#endif\n{\n    ssize_t retval;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n    int status = -1;\n    char namebuf[1024];\n    char pf[256];\n    memset(namebuf, 0, sizeof(namebuf));\n    memset(pf, 0, sizeof(pf));\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"pwrite64\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pwrite64(fd, buf, count, offset);\n#else\n    ssize_t (*realfunc)() = dlsym (RTLD_NEXT, \"pwrite64\");\n    retval = (*realfunc)(fd, buf, count, offset);\n#endif\n\n\n    if (dotrace) {\n\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n#if   defined(__linux) && defined(SYS_pwrite)\n    event.syscallno = SYS_pwrite;\n#elif defined(__linux) && defined(SYS_pwrite64)\n    event.syscallno = SYS_pwrite64;\n#else\n#error \"SYS_pwrite or SYS_pwrite64 is not defined\"\n#endif\n\n\n    event.nsysargs = 4;\n    event.sysargs[0] = fd;\n    event.sysargs[1] = (long) buf;\n    event.sysargs[2] = count;\n    event.sysargs[3] = offset;\n    event.retval = retval;\n\n#ifdef DEBUG_IOT\n    printf(\"iotwrite64, fd=%d, namebuf=%s\\n\", fd, namebuf);\n#endif\n    /* use that to get the path into /proc. */\n    sprintf(pf,\"/proc/self/fd/%d\",fd);\n\n    /* Read the link the file descriptor points to in the /proc filesystem */\n    status = readlink(pf,namebuf,1024);\n    if (status > 1024) {\n      printf(\"ERROR, name too large\\n\");\n    }\n    namebuf[status] = 0;\n    strncpy(currentpathname,namebuf,strlen(namebuf));\n#endif\n#endif\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_pwrite64));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_pwrite64);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n#endif\n\n//#if !defined(CBTF_SERVICE_USE_OFFLINE)\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nssize_t readv(int fd, const struct iovec *vector, int count) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_readv(int fd, const struct iovec *vector, int count) \n#else\nssize_t ioreadv(int fd, const struct iovec *vector, int count) \n#endif\n{\n    ssize_t retval;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n    int status = -1;\n    char namebuf[1024];\n    char pf[256];\n    memset(namebuf, 0, sizeof(namebuf));\n    memset(pf, 0, sizeof(pf));\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"readv\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_readv(fd, vector, count);\n#else\n    ssize_t (*realfunc)() = dlsym (RTLD_NEXT, \"readv\");\n    retval = (*realfunc)(fd, vector, count);\n#endif\n\n\n    if (dotrace) {\n\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n    event.syscallno = SYS_readv;\n    event.nsysargs = 3;\n    event.sysargs[0] = fd;\n    event.sysargs[1] = (long) vector;\n    event.sysargs[2] = count;\n    event.retval = retval;\n#ifdef DEBUG_IOT\n    printf(\"iotreadv, fd=%d, namebuf=%s\\n\", fd, namebuf);\n#endif\n    /* use that to get the path into /proc. */\n    sprintf(pf,\"/proc/self/fd/%d\",fd);\n\n    /* Read the link the file descriptor points to in the /proc filesystem */\n    status = readlink(pf,namebuf,1024);\n    if (status > 1024) {\n      printf(\"ERROR, name too large\\n\");\n    }\n    namebuf[status] = 0;\n    strncpy(currentpathname,namebuf,strlen(namebuf));\n#endif\n#endif\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_readv));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_readv);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n\n//#ifndef DEBUG\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nssize_t writev(int fd, const struct iovec *vector, int count) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_writev(int fd, const struct iovec *vector, int count) \n#else\nssize_t iowritev(int fd, const struct iovec *vector, int count) \n#endif\n{\n    ssize_t retval;\n#if defined(PROFILE)\n    CBTF_iop_event event;\n    uint64_t start_time = 0;\n#else\n#if defined(EXTENDEDTRACE)\n    CBTF_iot_event event;\n    int status = -1;\n    char namebuf[1024];\n    char pf[256];\n    memset(namebuf, 0, sizeof(namebuf));\n    memset(pf, 0, sizeof(pf));\n#else\n    CBTF_io_event event;\n#endif\n#endif\n\n    bool_t dotrace = io_do_trace(\"writev\");\n\n    if (dotrace) {\n\tio_start_event(&event);\n#if defined(PROFILE)\n\tstart_time = CBTF_GetTime();\n#else\n\tevent.start_time = CBTF_GetTime();\n#endif\n    }\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_writev(fd, vector, count);\n#else\n    ssize_t (*realfunc)() = dlsym (RTLD_NEXT, \"writev\");\n    retval = (*realfunc)(fd, vector, count);\n#endif\n\n\n    if (dotrace) {\n#if defined(PROFILE)\n    event.time = CBTF_GetTime() - start_time;\n#else\n\n    event.stop_time = CBTF_GetTime();\n\n#if defined(EXTENDEDTRACE)\n    event.syscallno = SYS_writev;\n    event.nsysargs = 3;\n    event.sysargs[0] = fd;\n    event.sysargs[1] = (long) vector;\n    event.sysargs[2] = count;\n    event.retval = retval;\n\n#ifdef DEBUG_IOT\n    printf(\"iotwritev, fd=%d, namebuf=%s\\n\", fd, namebuf);\n#endif\n    /* use that to get the path into /proc. */\n    sprintf(pf,\"/proc/self/fd/%d\",fd);\n\n    /* Read the link the file descriptor points to in the /proc filesystem */\n    status = readlink(pf,namebuf,1024);\n    if (status > 1024) {\n      printf(\"ERROR, name too large\\n\");\n    }\n    namebuf[status] = 0;\n    strncpy(currentpathname,namebuf,strlen(namebuf));\n#endif\n#endif\n\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((const void *) __real_writev));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        io_record_event(&event, (uint64_t) __real_writev);\n#else\n        io_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n//#endif\n//#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.2-udvq3kxq3w57rec5olt2tuoem5qjwtps/spack-src/core/collectors/pthreads/wrappers.c": "/*******************************************************************************\n** Copyright (c) 2011-2015 The Krell Institute. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n#define _GNU_SOURCE\n#ifndef __USE_GNU \n#define __USE_GNU /* XXX for RTLD_NEXT on Linux */ \n#endif /* !__USE_GNU */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"KrellInstitute/Messages/Pthreads_data.h\"\n#include \"KrellInstitute/Services/Assert.h\"\n#include \"KrellInstitute/Services/Common.h\"\n#include \"KrellInstitute/Services/Time.h\"\n\n\n#if !defined(CBTF_SERVICE_USE_OFFLINE)\n#include <syscall.h>\n#include <unistd.h>\n#include <fcntl.h>\n#endif\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <pthread.h>\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n                          void *(*start_routine) (void *), void *arg)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n                          void *(*start_routine) (void *), void *arg)\n#else\nint pthreads_pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n                          void *(*start_routine) (void *), void *arg)\n#endif\n{\n    int retval,eval;\n    CBTF_pthreadt_event event;\n\n    bool_t dotrace = pthreads_do_trace(\"pthread_create\");\n\n    if (dotrace) {\n        eval = pthreads_start_event(&event);\n\tif (eval) {\n        event.start_time = CBTF_GetTime();\n        event.pthread_type = CBTF_PTHREAD_CREATE;\n\t} else {\n\t    dotrace = FALSE;\n\t}\n    }\n\n    /* Call the real POSIX thread function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pthread_create(thread,attr,start_routine,arg);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"pthread_create\");\n    retval = (*realfunc)(thread,attr,start_routine,arg);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n        event.ptr1 = (uint64_t)thread;\n        event.ptr2 = (uint64_t)attr;\n        event.ptr3 = (uint64_t)*start_routine;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        pthreads_record_event(&event, (uint64_t) __real_pthread_create);\n#else\n        pthreads_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint pthread_mutex_init( pthread_mutex_t* mtx,\n                       const pthread_mutexattr_t* attr)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_pthread_mutex_init( pthread_mutex_t* mtx,\n                       const pthread_mutexattr_t* attr)\n#else\nint pthreads_pthread_mutex_init( pthread_mutex_t* mtx,\n                       const pthread_mutexattr_t* attr)\n#endif\n{\n    int retval,eval;\n    CBTF_pthreadt_event event;\n\n    bool_t dotrace = pthreads_do_trace(\"pthread_mutex_init\");\n\n    if (dotrace) {\n        eval = pthreads_start_event(&event);\n\tif (eval) {\n        event.start_time = CBTF_GetTime();\n        event.pthread_type = CBTF_PTHREAD_MUTEX_INIT;\n\t} else {\n\t    dotrace = FALSE;\n\t}\n    }\n\n    /* Call the real POSIX thread function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pthread_mutex_init(mtx,attr);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"pthread_mutex_init\");\n    retval = (*realfunc)(mtx,attr);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n        event.ptr1 = (uint64_t)mtx;\n        event.ptr2 = (uint64_t)attr;\n        event.ptr3 = (uint64_t)NULL;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        pthreads_record_event(&event, (uint64_t) __real_pthread_mutex_init);\n#else\n        pthreads_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint pthread_mutex_destroy( pthread_mutex_t* mtx)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_pthread_mutex_destroy( pthread_mutex_t* mtx)\n#else\nint pthreads_pthread_mutex_init( pthread_mutex_t* mtx)\n#endif\n{\n    int retval,eval;\n    CBTF_pthreadt_event event;\n\n    bool_t dotrace = pthreads_do_trace(\"pthread_mutex_destroy\");\n\n    if (dotrace) {\n        eval = pthreads_start_event(&event);\n\tif (eval) {\n        event.start_time = CBTF_GetTime();\n        event.pthread_type = CBTF_PTHREAD_MUTEX_DESTROY;\n\t} else {\n\t    dotrace = FALSE;\n\t}\n    }\n\n    /* Call the real function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pthread_mutex_destroy(mtx);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"pthread_mutex_destroy\");\n    retval = (*realfunc)(mtx);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n        event.ptr1 = (uint64_t)mtx;\n        event.ptr2 = (uint64_t)NULL;\n        event.ptr3 = (uint64_t)NULL;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        pthreads_record_event(&event, (uint64_t) __real_pthread_mutex_destroy);\n#else\n        pthreads_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint pthread_mutex_lock( pthread_mutex_t* mtx)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_pthread_mutex_lock( pthread_mutex_t* mtx)\n#else\nint pthreads_pthread_mutex_lock( pthread_mutex_t* mtx)\n#endif\n{\n    int retval,eval;\n    CBTF_pthreadt_event event;\n\n    bool_t dotrace = pthreads_do_trace(\"pthread_mutex_lock\");\n\n    if (dotrace) {\n        eval = pthreads_start_event(&event);\n\tif (eval) {\n        event.start_time = CBTF_GetTime();\n        event.pthread_type = CBTF_PTHREAD_MUTEX_LOCK;\n\t} else {\n\t    dotrace = FALSE;\n\t}\n    }\n\n    /* Call the real function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pthread_mutex_lock(mtx);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"pthread_mutex_lock\");\n    retval = (*realfunc)(mtx);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n        event.ptr1 = (uint64_t)mtx;\n        event.ptr2 = (uint64_t)NULL;\n        event.ptr3 = (uint64_t)NULL;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        pthreads_record_event(&event, (uint64_t) __real_pthread_mutex_lock);\n#else\n        pthreads_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint pthread_mutex_unlock( pthread_mutex_t* mtx)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_pthread_mutex_unlock( pthread_mutex_t* mtx)\n#else\nint pthreads_pthread_mutex_unlock( pthread_mutex_t* mtx)\n#endif\n{\n    int retval,eval;\n    CBTF_pthreadt_event event;\n\n    bool_t dotrace = pthreads_do_trace(\"pthread_mutex_unlock\");\n\n    if (dotrace) {\n        eval = pthreads_start_event(&event);\n\tif (eval) {\n        event.start_time = CBTF_GetTime();\n        event.pthread_type = CBTF_PTHREAD_MUTEX_UNLOCK;\n\t} else {\n\t    dotrace = FALSE;\n\t}\n    }\n\n    /* Call the real function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pthread_mutex_unlock(mtx);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"pthread_mutex_unlock\");\n    retval = (*realfunc)(mtx);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n        event.ptr1 = (uint64_t)mtx;\n        event.ptr2 = (uint64_t)NULL;\n        event.ptr3 = (uint64_t)NULL;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        pthreads_record_event(&event, (uint64_t) __real_pthread_mutex_unlock);\n#else\n        pthreads_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint pthread_mutex_trylock( pthread_mutex_t* mtx)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_pthread_mutex_trylock( pthread_mutex_t* mtx)\n#else\nint pthreads_pthread_mutex_trylock( pthread_mutex_t* mtx)\n#endif\n{\n    int retval,eval;\n    CBTF_pthreadt_event event;\n\n    bool_t dotrace = pthreads_do_trace(\"pthread_mutex_trylock\");\n\n    if (dotrace) {\n        eval = pthreads_start_event(&event);\n\tif (eval) {\n        event.start_time = CBTF_GetTime();\n        event.pthread_type = CBTF_PTHREAD_MUTEX_TRYLOCK;\n\t} else {\n\t    dotrace = FALSE;\n\t}\n    }\n\n    /* Call the real function */\n    // if lock is held by any thread call returns immediately else\n    // the lock is aquired by calling thread.\n    // See manpage for details on how the calling threads mutex\n    // attributes affect this call.\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pthread_mutex_trylock(mtx);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"pthread_mutex_trylock\");\n    retval = (*realfunc)(mtx);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n        event.ptr1 = (uint64_t)mtx;\n        event.ptr2 = (uint64_t)NULL;\n        event.ptr3 = (uint64_t)NULL;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        pthreads_record_event(&event, (uint64_t) __real_pthread_mutex_trylock);\n#else\n        pthreads_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint pthread_cond_init(pthread_cond_t* cnd, const pthread_condattr_t* attr)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_pthread_cond_init(pthread_cond_t* cnd, const pthread_condattr_t* attr)\n#else\nint pthreads_pthread_cond_init(pthread_cond_t* cnd, const pthread_condattr_t* attr)\n#endif\n{\n    int retval,eval;\n    CBTF_pthreadt_event event;\n\n    bool_t dotrace = pthreads_do_trace(\"pthread_cond_init\");\n\n    if (dotrace) {\n        eval = pthreads_start_event(&event);\n\tif (eval) {\n        event.start_time = CBTF_GetTime();\n        event.pthread_type = CBTF_PTHREAD_COND_INIT;\n\t} else {\n\t    dotrace = FALSE;\n\t}\n    }\n\n    /* Call the real function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pthread_cond_init(cnd,attr);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"pthread_cond_init\");\n    retval = (*realfunc)(cnd,attr);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n        event.ptr1 = (uint64_t)cnd;\n        event.ptr2 = (uint64_t)attr;\n        event.ptr3 = (uint64_t)NULL;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        pthreads_record_event(&event, (uint64_t) __real_pthread_cond_init);\n#else\n        pthreads_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint pthread_cond_destroy(pthread_cond_t* cnd)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_pthread_cond_destroy(pthread_cond_t* cnd)\n#else\nint pthreads_pthread_cond_destroy(pthread_cond_t* cnd)\n#endif\n{\n    int retval,eval;\n    CBTF_pthreadt_event event;\n\n    bool_t dotrace = pthreads_do_trace(\"pthread_cond_destroy\");\n\n    if (dotrace) {\n        eval = pthreads_start_event(&event);\n\tif (eval) {\n        event.start_time = CBTF_GetTime();\n        event.pthread_type = CBTF_PTHREAD_COND_DESTROY;\n\t} else {\n\t    dotrace = FALSE;\n\t}\n    }\n\n    /* Call the real function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pthread_cond_destroy(cnd);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"pthread_cond_destroy\");\n    retval = (*realfunc)(cnd);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n        event.ptr1 = (uint64_t)cnd;\n        event.ptr2 = (uint64_t)NULL;\n        event.ptr3 = (uint64_t)NULL;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        pthreads_record_event(&event, (uint64_t) __real_pthread_cond_destroy);\n#else\n        pthreads_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint pthread_cond_signal(pthread_cond_t* cnd)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_pthread_cond_signal(pthread_cond_t* cnd)\n#else\nint pthreads_pthread_cond_signal(pthread_cond_t* cnd)\n#endif\n{\n    int retval,eval;\n    CBTF_pthreadt_event event;\n\n    bool_t dotrace = pthreads_do_trace(\"pthread_cond_signal\");\n\n    if (dotrace) {\n        eval = pthreads_start_event(&event);\n\tif (eval) {\n        event.start_time = CBTF_GetTime();\n        event.pthread_type = CBTF_PTHREAD_COND_SIGNAL;\n\t} else {\n\t    dotrace = FALSE;\n\t}\n    }\n\n    /* Call the real function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pthread_cond_signal(cnd);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"pthread_cond_signal\");\n    retval = (*realfunc)(cnd);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n        event.ptr1 = (uint64_t)cnd;\n        event.ptr2 = (uint64_t)NULL;\n        event.ptr3 = (uint64_t)NULL;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        pthreads_record_event(&event, (uint64_t) __real_pthread_cond_signal);\n#else\n        pthreads_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint pthread_cond_broadcast(pthread_cond_t* cnd)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_pthread_cond_broadcast(pthread_cond_t* cnd)\n#else\nint pthreads_pthread_cond_broadcast(pthread_cond_t* cnd)\n#endif\n{\n    int retval,eval;\n    CBTF_pthreadt_event event;\n\n    bool_t dotrace = pthreads_do_trace(\"pthread_cond_broadcast\");\n\n    if (dotrace) {\n        eval = pthreads_start_event(&event);\n\tif (eval) {\n        event.start_time = CBTF_GetTime();\n        event.pthread_type = CBTF_PTHREAD_COND_BROADCAST;\n\t} else {\n\t    dotrace = FALSE;\n\t}\n    }\n\n    /* Call the real function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pthread_cond_broadcast(cnd);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"pthread_cond_broadcast\");\n    retval = (*realfunc)(cnd);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n        event.ptr1 = (uint64_t)cnd;\n        event.ptr2 = (uint64_t)NULL;\n        event.ptr3 = (uint64_t)NULL;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        pthreads_record_event(&event, (uint64_t) __real_pthread_cond_broadcast);\n#else\n        pthreads_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint pthread_cond_wait(pthread_cond_t* cnd, pthread_mutex_t* mtx)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_pthread_cond_wait(pthread_cond_t* cnd, pthread_mutex_t* mtx)\n#else\nint pthreads_pthread_cond_wait(pthread_cond_t* cnd, pthread_mutex_t* mtx)\n#endif\n{\n    int retval,eval;\n    CBTF_pthreadt_event event;\n\n    bool_t dotrace = pthreads_do_trace(\"pthread_cond_wait\");\n\n    if (dotrace) {\n        eval = pthreads_start_event(&event);\n\tif (eval) {\n        event.start_time = CBTF_GetTime();\n        event.pthread_type = CBTF_PTHREAD_COND_WAIT;\n\t} else {\n\t    dotrace = FALSE;\n\t}\n    }\n\n    /* Call the real function */\n    // There is an implied unlock and then lock of the mutex.\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pthread_cond_wait(cnd,mtx);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"pthread_cond_wait\");\n    retval = (*realfunc)(cnd,mtx);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n        event.ptr1 = (uint64_t)cnd;\n        event.ptr2 = (uint64_t)mtx;\n        event.ptr3 = (uint64_t)NULL;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        pthreads_record_event(&event, (uint64_t) __real_pthread_cond_wait);\n#else\n        pthreads_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint pthread_cond_timedwait(pthread_cond_t* cnd, pthread_mutex_t* mtx,\n\t\t\t   const struct timespec* tspec)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_pthread_cond_timedwait(pthread_cond_t* cnd, pthread_mutex_t* mtx,\n\t\t\t   const struct timespec* tspec)\n#else\nint pthreads_pthread_cond_timedwait(pthread_cond_t* cnd, pthread_mutex_t* mtx,\n\t\t\t   const struct timespec* tspec)\n#endif\n{\n    int retval,eval;\n    CBTF_pthreadt_event event;\n\n    bool_t dotrace = pthreads_do_trace(\"pthread_cond_timedwait\");\n\n    if (dotrace) {\n        eval = pthreads_start_event(&event);\n\tif (eval) {\n        event.start_time = CBTF_GetTime();\n        event.pthread_type = CBTF_PTHREAD_COND_TIMEDWAIT;\n\t} else {\n\t    dotrace = FALSE;\n\t}\n    }\n\n    /* Call the real function */\n    // There is an implied unlock and then lock of the mutex.\n    // the return val will be ETIMEDOUT if condition is not\n    // met in the time specified by tspec.\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pthread_cond_timedwait(cnd,mtx,tspec);\n#else\n    int (*realfunc)() = dlsym (RTLD_NEXT, \"pthread_cond_timedwait\");\n    retval = (*realfunc)(cnd,mtx,tspec);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n        event.ptr1 = (uint64_t)cnd;\n        event.ptr2 = (uint64_t)mtx;\n        event.ptr3 = (uint64_t)NULL;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        pthreads_record_event(&event, (uint64_t) __real_pthread_cond_timedwait);\n#else\n        pthreads_record_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    }\n    \n    /* Return the real function's return value to the caller */\n    return retval;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.2-udvq3kxq3w57rec5olt2tuoem5qjwtps/spack-src/core/collectors/overview/mem/wrappers.c": "/*******************************************************************************\n** Copyright (c) 2017 The Krell Institute. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n#define _GNU_SOURCE\n#ifndef __USE_GNU \n#define __USE_GNU /* XXX for RTLD_NEXT on Linux */ \n#endif /* !__USE_GNU */\n\n#include \"KrellInstitute/Messages/Mem_data.h\"\n#include \"KrellInstitute/Services/Assert.h\"\n#include \"KrellInstitute/Services/Common.h\"\n#include \"KrellInstitute/Services/Time.h\"\n#include \"collector.h\"\n#include \"overviewTLS.h\"\n\n\n#if !defined(CBTF_SERVICE_USE_OFFLINE)\n#include <unistd.h>\n#include <fcntl.h>\n#endif\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#if 0\nextern bool collector_do_trace();\nextern void TLS_start_mem_event(CBTF_memt_event* event);\nextern void TLS_record_mem_event(const CBTF_memt_event* event, uint64_t function);\n#endif\n\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nvoid* __real_malloc(size_t);\nvoid* __real_calloc(size_t, size_t);\nvoid* __real_realloc(void*, size_t);\nvoid* __real_free(void*);\nint __real_posix_memalign(void **, size_t, size_t);\nint __real_memalign(size_t, size_t);\n#endif\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n#ifdef malloc\n#undef malloc\n#endif\nvoid* malloc(size_t size) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nvoid* __wrap_malloc(size_t size)\n#else\nvoid* memmalloc(size_t size)\n#endif\n{\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n#endif\n    void* retval;\n    CBTF_memt_event event;\n\n    bool dotrace = collector_do_trace();\n\n    if (dotrace) {\n        TLS_start_mem_event(&event);\n        event.start_time = CBTF_GetTime();\n\tevent.mem_type = CBTF_MEM_MALLOC;\n    }\n\n    /* Call the real MEM function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_malloc(size);\n#else\n    static void* (*f_malloc)(size_t) = NULL;\n    if (!f_malloc)\n\tf_malloc = dlsym(RTLD_NEXT, \"malloc\");\n    retval = f_malloc(size);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n\tevent.ptr = 0;\n\tevent.size1 = size;\n\tevent.size2 = size;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        TLS_record_mem_event(&event, (uint64_t) __real_malloc);\n#else\n        TLS_record_mem_event(&event, CBTF_GetAddressOfFunction(f_malloc));\n#endif\n    }\n    \n    /* Return the real MEM function's return value to the caller */\n    return retval;\n}\n\n\n/* NOTE: The openmpi libraries call calloc before we are setup and\n * calloc calls fail.  In addition, using dlsym can also cause a crash.\n * The temporary solution for the dynamic case is to rely on __libc_calloc\n * as the real dynamic libc calloc call.\n */\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n#ifdef calloc\n#undef calloc\n#endif\nvoid* calloc(size_t count, size_t size) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nvoid* __wrap_calloc(size_t count, size_t size)\n#else\nvoid* memcalloc(size_t count, size_t size)\n#endif\n{\n    void* retval;\n    CBTF_memt_event event;\n\n    bool dotrace = collector_do_trace();\n\n    if (dotrace) {\n        TLS_start_mem_event(&event);\n        event.start_time = CBTF_GetTime();\n\tevent.mem_type = CBTF_MEM_CALLOC;\n    }\n\n    /* Call the real MEM function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_calloc(count,size);\n#else\n    extern void *__libc_calloc(size_t, size_t);\n    retval = __libc_calloc(count,size);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n\tevent.ptr = 0;\n\tevent.size1 = count;\n\tevent.size2 = size;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        TLS_record_mem_event(&event, (uint64_t) __real_calloc);\n#else\n        TLS_record_mem_event(&event, CBTF_GetAddressOfFunction(__libc_calloc));\n#endif\n    }\n    \n    /* Return the real MEM function's return value to the caller */\n    return retval;\n}\n\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n#ifdef realloc\n#undef realloc\n#endif\nvoid* realloc(void* oldPtr, size_t size) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nvoid* __wrap_realloc(void* oldPtr, size_t size)\n#else\nvoid* memrealloc(void* oldPtr, size_t size)\n#endif\n{\n    static void* (*f_realloc)(void*, size_t);\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n    if (f_realloc == NULL) {\n\tf_realloc = dlsym (RTLD_NEXT, \"realloc\");\n    }\n    if (f_realloc == NULL)\n\treturn NULL;\n#endif\n\n    void* retval;\n    CBTF_memt_event event;\n\n    bool dotrace = collector_do_trace();\n\n    if (dotrace) {\n        TLS_start_mem_event(&event);\n        event.start_time = CBTF_GetTime();\n\tevent.mem_type = CBTF_MEM_REALLOC;\n    }\n\n    /* Call the real MEM function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_realloc(oldPtr,size);\n#else\n    retval = f_realloc(oldPtr,size);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n\tevent.ptr = (uint64_t)oldPtr;\n\tevent.size1 = size;\n\tevent.size2 = size;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        TLS_record_mem_event(&event, (uint64_t) __real_realloc);\n#else\n        TLS_record_mem_event(&event, CBTF_GetAddressOfFunction(f_realloc));\n#endif\n    }\n    \n    /* Return the real MEM function's return value to the caller */\n    return retval;\n}\n\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint posix_memalign(void ** memptr, size_t alignment, size_t size)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_posix_memalign(void ** memptr, size_t alignment, size_t size)\n#else\nint memposix_memalign(void ** memptr, size_t alignment, size_t size)\n#endif\n{    \n    static int (*f_posix_memalign)(void **, size_t, size_t);\n    int retval;\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n    if (f_posix_memalign == NULL) {\n\tf_posix_memalign = dlsym (RTLD_NEXT, \"posix_memalign\");\n    }\n    if (f_posix_memalign == NULL)\n\treturn 0;\n#endif\n\n    CBTF_memt_event event;\n\n    bool dotrace = collector_do_trace();\n\n    if (dotrace) {\n        TLS_start_mem_event(&event);\n        event.start_time = CBTF_GetTime();\n\tevent.mem_type = CBTF_MEM_POSIX_MEMALIGN;\n    }\n\n    /* Call the real MEM function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_posix_memalign(memptr,alignment,size);\n#else\n    retval = f_posix_memalign(memptr,alignment,size);\n\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n\tevent.ptr = (uint64_t)(*memptr);\n\tevent.size1 = alignment;\n\tevent.size2 = size;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        TLS_record_mem_event(&event, (uint64_t) __real_posix_memalign);\n#else\n        TLS_record_mem_event(&event, CBTF_GetAddressOfFunction(f_posix_memalign));\n#endif\n    }\n    \n\n    /* Return the real MEM function's return value to the caller */\n    return retval;\n}\n\n\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint memalign(size_t blocksize, size_t bytes)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_memalign(size_t blocksize, size_t bytes)\n#else\nint memmemalign(size_t blocksize, size_t bytes)\n#endif\n{    \n    int retval;\n    static int (*f_memalign)(size_t, size_t);\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n    if (f_memalign == NULL) {\n\tf_memalign = dlsym (RTLD_NEXT, \"memalign\");\n    }\n    if (f_memalign == NULL)\n\treturn 0;\n#endif\n    CBTF_memt_event event;\n\n    bool dotrace = collector_do_trace();\n\n    if (dotrace) {\n        TLS_start_mem_event(&event);\n        event.start_time = CBTF_GetTime();\n\tevent.mem_type = CBTF_MEM_MEMALIGN;\n    }\n\n    /* Call the real MEM function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_memalign(blocksize,bytes);\n#else\n    retval = f_memalign(blocksize,bytes);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = (uint64_t)retval;\n\tevent.ptr = 0;\n\tevent.size1 = blocksize;\n\tevent.size2 = bytes;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        TLS_record_mem_event(&event, (uint64_t) __real_memalign);\n#else\n        TLS_record_mem_event(&event, CBTF_GetAddressOfFunction(f_memalign));\n#endif\n    }\n    \n\n    /* Return the real MEM function's return value to the caller */\n    return retval;\n}\n\n\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n#ifdef free\n#undef free\n#endif\nvoid free(void * ptr)\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nvoid __wrap_free(void * ptr)\n#else\nvoid memfree(void * ptr)\n#endif\n{\n    static void* (*f_free)(void*);\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n    if (f_free == NULL) {\n\tf_free = dlsym (RTLD_NEXT, \"free\");\n    }\n    if (f_free == NULL)\n\treturn;\n#endif\n    CBTF_memt_event event;\n\n    bool dotrace = collector_do_trace();\n\n    /* when ptr is NULL free is a no-op. We could record these if desired\n     * but the cost is high.  Only reason to record is to pinpoint the\n     * locations where code is calling free with a NULL ptr.\n     */\n    if (ptr == NULL) dotrace = FALSE;\n\n    if (dotrace) {\n        TLS_start_mem_event(&event);\n        event.start_time = CBTF_GetTime();\n\tevent.mem_type = CBTF_MEM_FREE;\n    }\n\n    /* Call the real MEM function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    __real_free(ptr);\n#else\n    f_free(ptr);\n#endif\n\n\n    if (dotrace) {\n        event.stop_time = CBTF_GetTime();\n\tevent.retval = 0;\n\tevent.ptr = (uint64_t)ptr;\n\tevent.size1 = 0;\n\tevent.size2 = 0;\n\n    /* Record event and it's stacktrace*/\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n        TLS_record_mem_event(&event, (uint64_t) __real_free);\n#else\n        TLS_record_mem_event(&event, CBTF_GetAddressOfFunction(f_free));\n#endif\n    }\n    \n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.2-udvq3kxq3w57rec5olt2tuoem5qjwtps/spack-src/core/collectors/overview/io/wrappers.c": "/*******************************************************************************\n** Copyright (c) 2017 The Krell Institute. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n#define _GNU_SOURCE\n#ifndef __USE_GNU \n#define __USE_GNU /* XXX for RTLD_NEXT on Linux */ \n#endif /* !__USE_GNU */\n#define _XOPEN_SOURCE 500 /* for readlink */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"KrellInstitute/Messages/IO_data.h\"\n#include \"KrellInstitute/Services/Assert.h\"\n#include \"KrellInstitute/Services/Common.h\"\n#include \"KrellInstitute/Services/Time.h\"\n\n\n#if !defined(CBTF_SERVICE_USE_OFFLINE)\n#include <syscall.h>\n#include <unistd.h>\n#include <fcntl.h>\n#endif\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#include \"overviewTLS.h\"\n\n/* Start part 2 of 2 for Hack to get around inconsistent syscall definitions */\n#include <sys/syscall.h>\n#ifdef __NR_pread64  /* Newer kernels renamed but it's the same.  */\n# ifndef __NR_pread\n# define __NR_pread __NR_pread64\n# endif\n#endif\n\n#ifdef __NR_pwrite64  /* Newer kernels renamed but it's the same.  */\n# ifndef __NR_pwrite\n#  define __NR_pwrite __NR_pwrite64\n# endif\n#endif\n/* End part 2 of 2 for Hack to get around inconsistent syscall definitions */\n\n/*\n * IO Wrapper Functions\n *\n */\n\n/*\nThe following IO SYS calls are traced by the Overview Collector.\nThese calls are traced using their weak names\n(e.g. \"open\" rather than \"__libc_open\").\n\nsee /usr/include/bits/syscall.h for details.\nSYS_pread;\nSYS_read;\nSYS_readv;\nSYS_pwrite;\nSYS_write;\nSYS_writev;\nSYS_lseek;\nSYS_creat;\nSYS_open;\nSYS_close;\nSYS_dup;\nSYS_dup2;\nSYS_pipe;\nSYS_open64;\nSYS_creat64;\nSYS_pread64;\nSYS_pwrite64;\nSYS_lseek64;\n*/\n\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n#ifdef read\n#undef read\n#endif\nssize_t read(int fd, void *buf, size_t count) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_read(int fd, void *buf, size_t count) \n#else\nssize_t ioread(int fd, void *buf, size_t count) \n#endif\n{\n    ssize_t retval;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_read(fd, buf, count);\n#else\n    static ssize_t (*f_read) (int, void *, size_t) = NULL;\n    char *error;\n    dlerror();    /* Clear any existing error */\n    if (!f_read) {\n      *(void **) (&f_read) = dlsym(RTLD_NEXT, \"read\");\n\n      if ((error = dlerror()) != NULL)  {\n\tfprintf(stderr, \"%s\\n\", error);\n      }\n    }\n    retval = (*f_read)(fd, buf, count);\n#endif\n\n\n    event.bytes = retval;\n    event.kind = Read;\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_read));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_read);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*f_read)));\n#endif\n\n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n//#ifndef DEBUG\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nssize_t write(int fd, __const void *buf, size_t count) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_write(int fd, __const void *buf, size_t count) \n#else\nssize_t iowrite(int fd, void *buf, size_t count) \n#endif\n{    \n    ssize_t retval;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_write(fd, buf, count);\n#else\n    //ssize_t (*realfunc)() = dlsym (RTLD_NEXT, \"write\");\n    ssize_t (*realfunc) (int, const void *, size_t);\n    char *error;\n    dlerror();    /* Clear any existing error */\n    *(void **) (&realfunc) = dlsym(RTLD_NEXT, \"write\");\n    if ((error = dlerror()) != NULL)  {\n\tfprintf(stderr, \"%s\\n\", error);\n    }\n    retval = (*realfunc)(fd, buf, count);\n#endif\n\n\n    event.bytes = retval;\n    event.kind = Write;\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_write));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_write);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n\n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n//#endif\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\noff_t lseek(int fd, off_t offset, int whence) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\noff_t __wrap_lseek(int fd, off_t offset, int whence) \n#else\noff_t iolseek(int fd, off_t offset, int whence) \n#endif\n{\n    off_t retval;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_lseek(fd, offset, whence);\n#else\n    off_t (*realfunc) (int, off_t, int);\n    char *error;\n    dlerror();    /* Clear any existing error */\n    *(void **) (&realfunc) = dlsym(RTLD_NEXT, \"lseek\");\n    if ((error = dlerror()) != NULL)  {\n\tfprintf(stderr, \"%s\\n\", error);\n    }\n    retval = (*realfunc)(fd, offset, whence);\n#endif\n\n\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_lseek));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_lseek);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\n__off64_t lseek64(int fd, __off64_t offset, int whence) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n__off64_t __wrap_lseek64(int fd, __off64_t offset, int whence) \n#else\noff_t iolseek64(int fd, off_t offset, int whence) \n#endif\n{\n    off_t retval;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_lseek64(fd, offset, whence);\n#else\n    off_t (*realfunc) (int, off_t, int);\n    char *error;\n    dlerror();    /* Clear any existing error */\n    *(void **) (&realfunc) = dlsym(RTLD_NEXT, \"lseek64\");\n    if ((error = dlerror()) != NULL)  {\n\tfprintf(stderr, \"%s\\n\", error);\n    }\n    retval = (*realfunc)(fd, offset, whence);\n#endif\n\n\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_lseek64));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_lseek64);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint open(const char *pathname, int flags, mode_t mode) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_open(const char *pathname, int flags, mode_t mode) \n#else\nint ioopen(const char *pathname, int flags, mode_t mode) \n#endif\n{\n    int retval = 0;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_open(pathname, flags, mode);\n#else\n    int (*realfunc) (const char *, int, mode_t);\n    char *error;\n    dlerror();    /* Clear any existing error */\n    *(void **) (&realfunc) = dlsym(RTLD_NEXT, \"open\");\n    if ((error = dlerror()) != NULL)  {\n\tfprintf(stderr, \"%s\\n\", error);\n    }\n    retval = (*realfunc)(pathname, flags, mode);\n#endif\n\n\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_open));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_open);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n\n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint open64(const char *pathname, int flags, mode_t mode) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_open64(const char *pathname, int flags, mode_t mode) \n#else\nint ioopen64(const char *pathname, int flags, mode_t mode) \n#endif\n{\n    int retval = 0;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_open64(pathname, flags, mode);\n#else\n    int (*realfunc) (const char *, int, mode_t);\n    char *error;\n    dlerror();    /* Clear any existing error */\n    *(void **) (&realfunc) = dlsym(RTLD_NEXT, \"open64\");\n    if ((error = dlerror()) != NULL)  {\n\tfprintf(stderr, \"%s\\n\", error);\n    }\n    retval = (*realfunc)(pathname, flags, mode);\n#endif\n\n\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_open64));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_open64);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint close(int fd) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_close(int fd) \n#else\nint ioclose(int fd) \n#endif\n{\n    int retval;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_close(fd);\n#else\n    int (*realfunc) (int);\n    char *error;\n    dlerror();    /* Clear any existing error */\n    *(void **) (&realfunc) = dlsym(RTLD_NEXT, \"close\");\n    if ((error = dlerror()) != NULL)  {\n\tfprintf(stderr, \"%s\\n\", error);\n    }\n    retval = (*realfunc)(fd);\n#endif\n\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_close));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_close);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint dup(int oldfd) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_dup(int oldfd) \n#else\nint iodup(int oldfd) \n#endif\n{\n    int retval;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_dup(oldfd);\n#else\n    int (*realfunc) (int);\n    char *error;\n    dlerror();    /* Clear any existing error */\n    *(void **) (&realfunc) = dlsym(RTLD_NEXT, \"dup\");\n    if ((error = dlerror()) != NULL)  {\n\tfprintf(stderr, \"%s\\n\", error);\n    }\n    retval = (*realfunc)(oldfd);\n#endif\n\n\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_dup));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_dup);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint dup2(int oldfd, int newfd) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_dup2(int oldfd, int newfd) \n#else\nint iodup2(int oldfd, int newfd) \n#endif\n{\n    int retval;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_dup2(oldfd,newfd);\n#else\n    int (*realfunc) (int,int);\n    char *error;\n    dlerror();    /* Clear any existing error */\n    *(void **) (&realfunc) = dlsym(RTLD_NEXT, \"dup2\");\n    if ((error = dlerror()) != NULL)  {\n\tfprintf(stderr, \"%s\\n\", error);\n    }\n    retval = (*realfunc)(oldfd,newfd);\n#endif\n\n\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_dup2));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_dup2);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint creat(char *pathname, mode_t mode) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_creat(char *pathname, mode_t mode) \n#else\nint iocreat(char *pathname, mode_t mode) \n#endif\n{\n    int retval = 0;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_creat(pathname,mode);\n#else\n    int (*realfunc) (char *,mode_t);\n    char *error;\n    dlerror();    /* Clear any existing error */\n    *(void **) (&realfunc) = dlsym(RTLD_NEXT, \"creat\");\n    if ((error = dlerror()) != NULL)  {\n\tfprintf(stderr, \"%s\\n\", error);\n    }\n    retval = (*realfunc)(pathname,mode);\n#endif\n\n\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_creat));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_creat);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n\n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint creat64(char *pathname, mode_t mode) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_creat64(char *pathname, mode_t mode) \n#else\nint iocreat64(char *pathname, mode_t mode) \n#endif\n{\n    int retval;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_creat64(pathname,mode);\n#else\n    int (*realfunc) (char *,mode_t);\n    char *error;\n    dlerror();    /* Clear any existing error */\n    *(void **) (&realfunc) = dlsym(RTLD_NEXT, \"creat64\");\n    if ((error = dlerror()) != NULL)  {\n\tfprintf(stderr, \"%s\\n\", error);\n    }\n    retval = (*realfunc)(pathname,mode);\n#endif\n\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_creat64));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_creat64);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    \n\n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nint pipe(int filedes[2]) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nint __wrap_pipe(int filedes[2]) \n#else\nint iopipe(int filedes[2]) \n#endif\n{\n    int retval;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pipe(filedes);\n#else\n    int (*realfunc) (int *);\n    char *error;\n    dlerror();    /* Clear any existing error */\n    *(void **) (&realfunc) = dlsym(RTLD_NEXT, \"pipe\");\n    if ((error = dlerror()) != NULL)  {\n\tfprintf(stderr, \"%s\\n\", error);\n    }\n    retval = (*realfunc)(filedes);\n#endif\n\n\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_pipe));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_pipe);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nssize_t pread(int fd, void *buf, size_t count, off_t offset) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_pread(int fd, void *buf, size_t count, off_t offset) \n#else\nssize_t iopread(int fd, void *buf, size_t count, off_t offset) \n#endif\n{\n    ssize_t retval;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pread(fd, buf, count, offset);\n#else\n    ssize_t (*realfunc)() = dlsym (RTLD_NEXT, \"pread\");\n    retval = (*realfunc)(fd, buf, count, offset);\n#endif\n\n\n    event.bytes = retval;\n    event.kind = Read;\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_pread));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_pread);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nssize_t pread64(int fd, void *buf, size_t count, __off64_t offset) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_pread64(int fd, void *buf, size_t count, __off64_t offset) \n#else\nssize_t iopread64(int fd, void *buf, size_t count, off_t offset) \n#endif\n{\n    ssize_t retval;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pread64(fd, buf, count, offset);\n#else\n    ssize_t (*realfunc)() = dlsym (RTLD_NEXT, \"pread64\");\n    retval = (*realfunc)(fd, buf, count, offset);\n#endif\n\n\n    event.bytes = retval;\n    event.kind = Read;\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_pread64));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_pread64);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n#ifndef DEBUG\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nssize_t pwrite(int fd, __const void *buf, size_t count, __off_t offset) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_pwrite(int fd, __const void *buf, size_t count, __off_t offset) \n#else\nssize_t iopwrite(int fd, void *buf, size_t count, off_t offset) \n#endif\n{\n    ssize_t retval;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pwrite(fd, buf, count, offset);\n#else\n    ssize_t (*realfunc)() = dlsym (RTLD_NEXT, \"pwrite\");\n    retval = (*realfunc)(fd, buf, count, offset);\n#endif\n\n\n    event.bytes = retval;\n    event.kind = Write;\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_pwrite));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_pwrite);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n#endif\n\n#ifndef DEBUG\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nssize_t pwrite64(int fd, __const void *buf, size_t count, __off64_t offset) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_pwrite64(int fd, __const void *buf, size_t count, __off64_t offset) \n#else\nssize_t iopwrite64(int fd, void *buf, size_t count, off_t offset) \n#endif\n{\n    ssize_t retval;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_pwrite64(fd, buf, count, offset);\n#else\n    ssize_t (*realfunc)() = dlsym (RTLD_NEXT, \"pwrite64\");\n    retval = (*realfunc)(fd, buf, count, offset);\n#endif\n\n\n    event.bytes = retval;\n    event.kind = Write;\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_pwrite64));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_pwrite64);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n#endif\n\n//#if !defined(CBTF_SERVICE_USE_OFFLINE)\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nssize_t readv(int fd, const struct iovec *vector, int count) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_readv(int fd, const struct iovec *vector, int count) \n#else\nssize_t ioreadv(int fd, const struct iovec *vector, int count) \n#endif\n{\n    ssize_t retval;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_readv(fd, vector, count);\n#else\n    ssize_t (*realfunc)() = dlsym (RTLD_NEXT, \"readv\");\n    retval = (*realfunc)(fd, vector, count);\n#endif\n\n\n    event.bytes = retval;\n    event.kind = Read;\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_readv));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_readv);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n\n\n//#ifndef DEBUG\n#if defined (CBTF_SERVICE_USE_OFFLINE) && !defined(CBTF_SERVICE_BUILD_STATIC)\nssize_t writev(int fd, const struct iovec *vector, int count) \n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\nssize_t __wrap_writev(int fd, const struct iovec *vector, int count) \n#else\nssize_t iowritev(int fd, const struct iovec *vector, int count) \n#endif\n{\n    ssize_t retval;\n    CBTF_overview_iop_event event;\n    uint64_t start_time = 0;\n\n    TLS_start_io_event(&event);\n    start_time = CBTF_GetTime();\n\n    /* Call the real IO function */\n#if defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    retval = __real_writev(fd, vector, count);\n#else\n    ssize_t (*realfunc)() = dlsym (RTLD_NEXT, \"writev\");\n    retval = (*realfunc)(fd, vector, count);\n#endif\n\n\n    event.bytes = retval;\n    event.kind = Write;\n    event.time = CBTF_GetTime() - start_time;\n\n    /* Record event and it's stacktrace*/\n#if defined(RUNTIME_PLATFORM_BGQ)\n#if defined(HAVE_TARGET_SHARED) && ! defined (CBTF_SERVICE_BUILD_STATIC) \n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((const void *) __real_writev));\n#endif\n#elif defined (CBTF_SERVICE_BUILD_STATIC) && defined (CBTF_SERVICE_USE_OFFLINE)\n    TLS_record_io_event(&event, (uint64_t) __real_writev);\n#else\n    TLS_record_io_event(&event, CBTF_GetAddressOfFunction((*realfunc)));\n#endif\n    \n    /* Return the real IO function's return value to the caller */\n    return retval;\n}\n//#endif\n//#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.2-udvq3kxq3w57rec5olt2tuoem5qjwtps/spack-src/.git/objects/pack/pack-ea546c3539683d069a50370ec393e2769b89c498.idx",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.2-udvq3kxq3w57rec5olt2tuoem5qjwtps/spack-src/.git/objects/pack/pack-ea546c3539683d069a50370ec393e2769b89c498.pack",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.2-udvq3kxq3w57rec5olt2tuoem5qjwtps/spack-src/contrib/XXXXtool.tar.gz"
    ],
    "total_files": 606
}