{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/include/my_global.h": "/*\n   Copyright (c) 2001, 2017, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA */\n\n/* This is the include file that should be included 'first' in every C file. */\n\n#ifndef _global_h\n#define _global_h\n\n/* Client library users on Windows need this macro defined here. */\n#if !defined(__WIN__) && defined(_WIN32)\n#define __WIN__\n#endif\n\n/*\n  InnoDB depends on some MySQL internals which other plugins should not\n  need.  This is because of InnoDB's foreign key support, \"safe\" binlog\n  truncation, and other similar legacy features.\n\n  We define accessors for these internals unconditionally, but do not\n  expose them in mysql/plugin.h.  They are declared in ha_innodb.h for\n  InnoDB's use.\n*/\n#define INNODB_COMPATIBILITY_HOOKS\n\n#ifdef __CYGWIN__\n/* We use a Unix API, so pretend it's not Windows */\n#undef WIN\n#undef WIN32\n#undef _WIN\n#undef _WIN32\n#undef _WIN64\n#undef __WIN__\n#undef __WIN32__\n#define HAVE_ERRNO_AS_DEFINE\n#endif /* __CYGWIN__ */\n\n/* to make command line shorter we'll define USE_PRAGMA_INTERFACE here */\n#ifdef USE_PRAGMA_IMPLEMENTATION\n#define USE_PRAGMA_INTERFACE\n#endif\n\n#if defined(__OpenBSD__) && (OpenBSD >= 200411)\n#define HAVE_ERRNO_AS_DEFINE\n#endif\n\n#if defined(i386) && !defined(__i386__)\n#define __i386__\n#endif\n\n/* Macros to make switching between C and C++ mode easier */\n#ifdef __cplusplus\n#define C_MODE_START    extern \"C\" {\n#define C_MODE_END\t}\n#else\n#define C_MODE_START\n#define C_MODE_END\n#endif\n\n#ifdef __cplusplus\n#define CPP_UNNAMED_NS_START  namespace {\n#define CPP_UNNAMED_NS_END    }\n#endif\n\n#include <my_config.h>\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#define HAVE_PSI_INTERFACE\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n/* Make it easier to add conditional code in _expressions_ */\n#ifdef __WIN__\n#define IF_WIN(A,B) A\n#else\n#define IF_WIN(A,B) B\n#endif\n\n#ifdef HAVE_purify\n#define IF_PURIFY(A,B) A\n#else\n#define IF_PURIFY(A,B) B\n#endif\n\n#ifndef EMBEDDED_LIBRARY\n#ifdef WITH_NDB_BINLOG\n#define HAVE_NDB_BINLOG 1\n#endif\n#endif /* !EMBEDDED_LIBRARY */\n\n#ifndef EMBEDDED_LIBRARY\n#define HAVE_REPLICATION\n#define HAVE_EXTERNAL_CLIENT\n#endif\n\n#if defined (_WIN32)\n/*\n off_t is 32 bit long. We do not use C runtime functions\n with off_t but native Win32 file IO APIs, that work with\n 64 bit offsets.\n*/\n#undef SIZEOF_OFF_T\n#define SIZEOF_OFF_T 8\n\n/*\n Prevent inclusion of  Windows GDI headers - they define symbol\n ERROR that conflicts with mysql headers.\n*/\n#ifndef NOGDI\n#define NOGDI\n#endif\n\n/* Include common headers.*/\n#include <winsock2.h>\n#include <ws2tcpip.h> /* SOCKET */\n#include <io.h>       /* access(), chmod() */\n#include <process.h>  /* getpid() */\n\n#define sleep(a) Sleep((a)*1000)\n\n/* Define missing access() modes. */\n#define F_OK 0\n#define W_OK 2\n\n/* Define missing file locking constants. */\n#define F_RDLCK 1\n#define F_WRLCK 2\n#define F_UNLCK 3\n#define F_TO_EOF 0x3FFFFFFF\n\n/* Shared memory and named pipe connections are supported. */\n#define HAVE_SMEM 1\n#define HAVE_NAMED_PIPE 1\n#define shared_memory_buffer_length 16000\n#define default_shared_memory_base_name \"MYSQL\"\n#endif /* _WIN32*/\n\n\n/* Workaround for _LARGE_FILES and _LARGE_FILE_API incompatibility on AIX */\n#if defined(_AIX) && defined(_LARGE_FILE_API)\n#undef _LARGE_FILE_API\n#endif\n\n/*\n  The macros below are used to allow build of Universal/fat binaries of\n  MySQL and MySQL applications under darwin. \n*/\n#if defined(__APPLE__) && defined(__MACH__)\n#  undef SIZEOF_CHARP \n#  undef SIZEOF_SHORT \n#  undef SIZEOF_INT \n#  undef SIZEOF_LONG \n#  undef SIZEOF_LONG_LONG \n#  undef SIZEOF_OFF_T \n#  undef WORDS_BIGENDIAN\n#  define SIZEOF_SHORT 2\n#  define SIZEOF_INT 4\n#  define SIZEOF_LONG_LONG 8\n#  define SIZEOF_OFF_T 8\n#  if defined(__i386__) || defined(__ppc__)\n#    define SIZEOF_CHARP 4\n#    define SIZEOF_LONG 4\n#  elif defined(__x86_64__) || defined(__ppc64__)\n#    define SIZEOF_CHARP 8\n#    define SIZEOF_LONG 8\n#  else\n#    error Building FAT binary for an unknown architecture.\n#  endif\n#  if defined(__ppc__) || defined(__ppc64__)\n#    define WORDS_BIGENDIAN\n#  endif\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n\n/*\n  The macros below are borrowed from include/linux/compiler.h in the\n  Linux kernel. Use them to indicate the likelyhood of the truthfulness\n  of a condition. This serves two purposes - newer versions of gcc will be\n  able to optimize for branch predication, which could yield siginficant\n  performance gains in frequently executed sections of the code, and the\n  other reason to use them is for documentation\n*/\n\n#if !defined(__GNUC__) || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)\n#define __builtin_expect(x, expected_value) (x)\n#endif\n\n#define likely(x)\t__builtin_expect((x),1)\n#define unlikely(x)\t__builtin_expect((x),0)\n\n/* Fix problem with S_ISLNK() on Linux */\n#if defined(TARGET_OS_LINUX) || defined(__GLIBC__)\n#undef  _GNU_SOURCE\n#define _GNU_SOURCE 1\n#endif\n\n/*\n  Temporary solution to solve bug#7156. Include \"sys/types.h\" before\n  the thread headers, else the function madvise() will not be defined\n*/\n#if defined(HAVE_SYS_TYPES_H) && ( defined(sun) || defined(__sun) )\n#include <sys/types.h>\n#endif\n\n#ifdef HAVE_THREADS_WITHOUT_SOCKETS\n/* MIT pthreads does not work with unix sockets */\n#undef HAVE_SYS_UN_H\n#endif\n\n#define __EXTENSIONS__ 1\t/* We want some extension */\n#ifndef __STDC_EXT__\n#define __STDC_EXT__ 1          /* To get large file support on hpux */\n#endif\n\n/*\n  Solaris 9 include file <sys/feature_tests.h> refers to X/Open document\n\n    System Interfaces and Headers, Issue 5\n\n  saying we should define _XOPEN_SOURCE=500 to get POSIX.1c prototypes,\n  but apparently other systems (namely FreeBSD) don't agree.\n\n  On a newer Solaris 10, the above file recognizes also _XOPEN_SOURCE=600.\n  Furthermore, it tests that if a program requires older standard\n  (_XOPEN_SOURCE<600 or _POSIX_C_SOURCE<200112L) it cannot be\n  run on a new compiler (that defines _STDC_C99) and issues an #error.\n  It's also an #error if a program requires new standard (_XOPEN_SOURCE=600\n  or _POSIX_C_SOURCE=200112L) and a compiler does not define _STDC_C99.\n\n  To add more to this mess, Sun Studio C compiler defines _STDC_C99 while\n  C++ compiler does not!\n\n  So, in a desperate attempt to get correct prototypes for both\n  C and C++ code, we define either _XOPEN_SOURCE=600 or _XOPEN_SOURCE=500\n  depending on the compiler's announced C standard support.\n\n  Cleaner solutions are welcome.\n*/\n#ifdef __sun\n#if __STDC_VERSION__ - 0 >= 199901L\n#define _XOPEN_SOURCE 600\n#else\n#define _XOPEN_SOURCE 500\n#endif\n#endif\n\n#if !defined(__WIN__)\n#ifndef _POSIX_PTHREAD_SEMANTICS\n#define _POSIX_PTHREAD_SEMANTICS /* We want posix threads */\n#endif\n\n#if !defined(SCO)\n#define _REENTRANT\t1\t/* Some thread libraries require this */\n#endif\n#if !defined(_THREAD_SAFE) && !defined(_AIX)\n#define _THREAD_SAFE            /* Required for OSF1 */\n#endif\n#if defined(HPUX10) || defined(HPUX11)\nC_MODE_START\t\t\t/* HPUX needs this, signal.h bug */\n#include <pthread.h>\nC_MODE_END\n#else\n#include <pthread.h>\t\t/* AIX must have this included first */\n#endif\n#if !defined(SCO) && !defined(_REENTRANT)\n#define _REENTRANT\t1\t/* Threads requires reentrant code */\n#endif\n#endif /* !defined(__WIN__) */\n\n/* Go around some bugs in different OS and compilers */\n#ifdef _AIX\t\t\t/* By soren@t.dk */\n#define _H_STRINGS\n#define _SYS_STREAM_H\n/* #define _AIX32_CURSES */\t/* XXX: this breaks AIX 4.3.3 (others?). */\n#define ulonglong2double(A) my_ulonglong2double(A)\n#define my_off_t2double(A)  my_ulonglong2double(A)\nC_MODE_START\ninline double my_ulonglong2double(unsigned long long A) { return (double A); }\nC_MODE_END\n#endif /* _AIX */\n\n#ifdef HAVE_BROKEN_SNPRINTF\t/* HPUX 10.20 don't have this defined */\n#undef HAVE_SNPRINTF\n#endif\n#ifdef HAVE_BROKEN_PREAD\n/*\n  pread()/pwrite() are not 64 bit safe on HP-UX 11.0 without\n  installing the kernel patch PHKL_20349 or greater\n*/\n#undef HAVE_PREAD\n#undef HAVE_PWRITE\n#endif\n\n#ifdef UNDEF_HAVE_INITGROUPS\t\t\t/* For AIX 4.3 */\n#undef HAVE_INITGROUPS\n#endif\n\n/* gcc/egcs issues */\n\n#if defined(__GNUC) && defined(__EXCEPTIONS)\n#error \"Please add -fno-exceptions to CXXFLAGS and reconfigure/recompile\"\n#endif\n\n#if defined(_lint) && !defined(lint)\n#define lint\n#endif\n#if SIZEOF_LONG_LONG > 4 && !defined(_LONG_LONG)\n#define _LONG_LONG 1\t\t/* For AIX string library */\n#endif\n\n#ifndef stdin\n#include <stdio.h>\n#endif\n#include <stdarg.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STDDEF_H\n#include <stddef.h>\n#endif\n\n#include <math.h>\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#ifdef HAVE_FLOAT_H\n#include <float.h>\n#endif\n#ifdef HAVE_FENV_H\n#include <fenv.h> /* For fesetround() */\n#endif\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#ifdef HAVE_SYS_TIMEB_H\n#include <sys/timeb.h>\t\t\t\t/* Avoid warnings on SCO */\n#endif\n#if TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif /* TIME_WITH_SYS_TIME */\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#if defined(__cplusplus) && defined(NO_CPLUSPLUS_ALLOCA)\n#undef HAVE_ALLOCA\n#undef HAVE_ALLOCA_H\n#endif\n#ifdef HAVE_ALLOCA_H\n#include <alloca.h>\n#endif\n\n#include <errno.h>\t\t\t\t/* Recommended by debian */\n/* We need the following to go around a problem with openssl on solaris */\n#if defined(HAVE_CRYPT_H)\n#include <crypt.h>\n#endif\n\n/*\n  A lot of our programs uses asserts, so better to always include it\n  This also fixes a problem when people uses DBUG_ASSERT without including\n  assert.h\n*/\n#include <assert.h>\n\n/* an assert that works at compile-time. only for constant expression */\n#ifndef __GNUC__\n#define compile_time_assert(X)  do { } while(0)\n#else\n#define compile_time_assert(X)                                  \\\n  do                                                            \\\n  {                                                             \\\n    typedef char compile_time_assert[(X) ? 1 : -1] __attribute__((unused)); \\\n  } while(0)\n#endif\n\n/* Go around some bugs in different OS and compilers */\n#if defined (HPUX11) && defined(_LARGEFILE_SOURCE)\n#ifndef _LARGEFILE64_SOURCE\n#define _LARGEFILE64_SOURCE\n#endif\n#endif\n\n#if defined(_HPUX_SOURCE) && defined(HAVE_SYS_STREAM_H)\n#include <sys/stream.h>\t\t/* HPUX 10.20 defines ulong here. UGLY !!! */\n#define HAVE_ULONG\n#endif\n#if defined(HPUX10) && defined(_LARGEFILE64_SOURCE)\n/* Fix bug in setrlimit */\n#undef setrlimit\n#define setrlimit cma_setrlimit64\n#endif\n/* Declare madvise where it is not declared for C++, like Solaris */\n#if HAVE_MADVISE && !HAVE_DECL_MADVISE && defined(__cplusplus)\nextern \"C\" int madvise(void *addr, size_t len, int behav);\n#endif\n\n#define QUOTE_ARG(x)\t\t#x\t/* Quote argument (before cpp) */\n#define STRINGIFY_ARG(x) QUOTE_ARG(x)\t/* Quote argument, after cpp */\n\n/* Paranoid settings. Define I_AM_PARANOID if you are paranoid */\n#ifdef I_AM_PARANOID\n#define DONT_ALLOW_USER_CHANGE 1\n#define DONT_USE_MYSQL_PWD 1\n#endif\n\n/* Does the system remember a signal handler after a signal ? */\n#if !defined(HAVE_BSD_SIGNALS) && !defined(HAVE_SIGACTION)\n#define SIGNAL_HANDLER_RESET_ON_DELIVERY\n#endif\n\n/*\n  Deprecated workaround for false-positive uninitialized variables\n  warnings. Those should be silenced using tool-specific heuristics.\n\n  Enabled by default for g++ due to the bug referenced below.\n*/\n#if defined(_lint) || defined(FORCE_INIT_OF_VARS) || \\\n    (defined(__GNUC__) && defined(__cplusplus))\n#define LINT_INIT(var) var= 0\n#else\n#define LINT_INIT(var)\n#endif\n\n#ifndef SO_EXT\n#ifdef _WIN32\n#define SO_EXT \".dll\"\n#elif defined(__APPLE__)\n#define SO_EXT \".dylib\"\n#else\n#define SO_EXT \".so\"\n#endif\n#endif\n\n/*\n   Suppress uninitialized variable warning without generating code.\n\n   The _cplusplus is a temporary workaround for C++ code pending a fix\n   for a g++ bug (http://gcc.gnu.org/bugzilla/show_bug.cgi?id=34772).\n*/\n#if defined(_lint) || defined(FORCE_INIT_OF_VARS) || \\\n    defined(__cplusplus) || !defined(__GNUC__)\n#define UNINIT_VAR(x) x= 0\n#else\n/* GCC specific self-initialization which inhibits the warning. */\n#define UNINIT_VAR(x) x= x\n#endif\n\n#if !defined(HAVE_UINT)\n#undef HAVE_UINT\n#define HAVE_UINT\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\n#endif\n\n#define swap_variables(t, a, b) { t dummy; dummy= a; a= b; b= dummy; }\n#define test(a)\t\t((a) ? 1 : 0)\n#define set_if_bigger(a,b)  do { if ((a) < (b)) (a)=(b); } while(0)\n#define set_if_smaller(a,b) do { if ((a) > (b)) (a)=(b); } while(0)\n#define test_all_bits(a,b) (((a) & (b)) == (b))\n#define array_elements(A) ((uint) (sizeof(A)/sizeof(A[0])))\n\n/* Define some general constants */\n#ifndef TRUE\n#define TRUE\t\t(1)\t/* Logical true */\n#define FALSE\t\t(0)\t/* Logical false */\n#endif\n\n#include <my_compiler.h>\n\n/*\n  Wen using the embedded library, users might run into link problems,\n  duplicate declaration of __cxa_pure_virtual, solved by declaring it a\n  weak symbol.\n*/\n#if defined(USE_MYSYS_NEW) && ! defined(DONT_DECLARE_CXA_PURE_VIRTUAL)\nC_MODE_START\nint __cxa_pure_virtual () __attribute__ ((weak));\nC_MODE_END\n#endif\n\n/* The DBUG_ON flag always takes precedence over default DBUG_OFF */\n#if defined(DBUG_ON) && defined(DBUG_OFF)\n#undef DBUG_OFF\n#endif\n\n/* We might be forced to turn debug off, if not turned off already */\n#if (defined(FORCE_DBUG_OFF) || defined(_lint)) && !defined(DBUG_OFF)\n#  define DBUG_OFF\n#  ifdef DBUG_ON\n#    undef DBUG_ON\n#  endif\n#endif\n\n/* Some types that is different between systems */\n\ntypedef int\tFile;\t\t/* File descriptor */\n#ifdef _WIN32\ntypedef SOCKET my_socket;\n#else\ntypedef int\tmy_socket;\t/* File descriptor for sockets */\n#define INVALID_SOCKET -1\n#endif\n/* Type for fuctions that handles signals */\n#define sig_handler RETSIGTYPE\nC_MODE_START\ntypedef void\t(*sig_return)();/* Returns type from signal */\nC_MODE_END\n#if defined(__GNUC__) && !defined(_lint)\ntypedef char\tpchar;\t\t/* Mixed prototypes can take char */\ntypedef char\tpuchar;\t\t/* Mixed prototypes can take char */\ntypedef char\tpbool;\t\t/* Mixed prototypes can take char */\ntypedef short\tpshort;\t\t/* Mixed prototypes can take short int */\ntypedef float\tpfloat;\t\t/* Mixed prototypes can take float */\n#else\ntypedef int\tpchar;\t\t/* Mixed prototypes can't take char */\ntypedef uint\tpuchar;\t\t/* Mixed prototypes can't take char */\ntypedef int\tpbool;\t\t/* Mixed prototypes can't take char */\ntypedef int\tpshort;\t\t/* Mixed prototypes can't take short int */\ntypedef double\tpfloat;\t\t/* Mixed prototypes can't take float */\n#endif\nC_MODE_START\ntypedef int\t(*qsort_cmp)(const void *,const void *);\ntypedef int\t(*qsort_cmp2)(void*, const void *,const void *);\nC_MODE_END\n#define qsort_t RETQSORTTYPE\t/* Broken GCC cant handle typedef !!!! */\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\ntypedef SOCKET_SIZE_TYPE size_socket;\n\n#ifndef SOCKOPT_OPTLEN_TYPE\n#define SOCKOPT_OPTLEN_TYPE size_socket\n#endif\n\n/* file create flags */\n\n#ifndef O_SHARE\t\t\t/* Probably not windows */\n#define O_SHARE\t\t0\t/* Flag to my_open for shared files */\n#ifndef O_BINARY\n#define O_BINARY\t0\t/* Flag to my_open for binary files */\n#endif\n#ifndef FILE_BINARY\n#define FILE_BINARY\tO_BINARY /* Flag to my_fopen for binary streams */\n#endif\n#ifdef HAVE_FCNTL\n#define HAVE_FCNTL_LOCK\n#define F_TO_EOF\t0L\t/* Param to lockf() to lock rest of file */\n#endif\n#endif /* O_SHARE */\n\n#ifndef O_TEMPORARY\n#define O_TEMPORARY\t0\n#endif\n#ifndef O_SHORT_LIVED\n#define O_SHORT_LIVED\t0\n#endif\n#ifndef O_NOFOLLOW\n#define O_NOFOLLOW      0\n#endif\n\n/* additional file share flags for win32 */\n#ifdef __WIN__\n#define _SH_DENYRWD     0x110    /* deny read/write mode & delete */\n#define _SH_DENYWRD     0x120    /* deny write mode & delete      */\n#define _SH_DENYRDD     0x130    /* deny read mode & delete       */\n#define _SH_DENYDEL     0x140    /* deny delete only              */\n#endif /* __WIN__ */\n\n\n/* General constants */\n#define FN_LEN\t\t256\t/* Max file name len */\n#define FN_HEADLEN\t253\t/* Max length of filepart of file name */\n#define FN_EXTLEN\t20\t/* Max length of extension (part of FN_LEN) */\n#define FN_REFLEN\t512\t/* Max length of full path-name */\n#define FN_EXTCHAR\t'.'\n#define FN_HOMELIB\t'~'\t/* ~/ is used as abbrev for home dir */\n#define FN_CURLIB\t'.'\t/* ./ is used as abbrev for current dir */\n#define FN_PARENTDIR\t\"..\"\t/* Parent directory; Must be a string */\n\n#ifdef _WIN32\n#define FN_LIBCHAR\t'\\\\'\n#define FN_LIBCHAR2\t'/'\n#define FN_DIRSEP       \"/\\\\\"               /* Valid directory separators */\n#define FN_EXEEXT   \".exe\"\n#define FN_SOEXT    \".dll\"\n#define FN_ROOTDIR\t\"\\\\\"\n#define FN_DEVCHAR\t':'\n#define FN_NETWORK_DRIVES\t/* Uses \\\\ to indicate network drives */\n#define FN_NO_CASE_SENCE\t/* Files are not case-sensitive */\n#else\n#define FN_LIBCHAR\t'/'\n#define FN_LIBCHAR2\t'/'\n#define FN_DIRSEP       \"/\"     /* Valid directory separators */\n#define FN_EXEEXT   \"\"\n#define FN_SOEXT    \".so\"\n#define FN_ROOTDIR\t\"/\"\n#endif\n\n/* \n  MY_FILE_MIN is  Windows speciality and is used to quickly detect\n  the mismatch of CRT and mysys file IO usage on Windows at runtime.\n  CRT file descriptors can be in the range 0-2047, whereas descriptors returned\n  by my_open() will start with 2048. If a file descriptor with value less then\n  MY_FILE_MIN is passed to mysys IO function, chances are it stemms from\n  open()/fileno() and not my_open()/my_fileno.\n\n  For Posix,  mysys functions are light wrappers around libc, and MY_FILE_MIN\n  is logically 0.\n*/\n\n#ifdef _WIN32\n#define MY_FILE_MIN  2048\n#else\n#define MY_FILE_MIN  0\n#endif\n\n/* \n  MY_NFILE is the default size of my_file_info array.\n\n  It is larger on Windows, because it all file handles are stored in my_file_info\n  Default size is 16384 and this should be enough for most cases.If it is not \n  enough, --max-open-files with larger value can be used.\n\n  For Posix , my_file_info array is only used to store filenames for\n  error reporting and its size is not a limitation for number of open files.\n*/ \n#ifdef _WIN32\n#define MY_NFILE (16384 + MY_FILE_MIN)\n#else\n#define MY_NFILE 64\n#endif\n\n#ifndef OS_FILE_LIMIT\n#define OS_FILE_LIMIT\tUINT_MAX\n#endif\n\n/*\n  Io buffer size; Must be a power of 2 and a multiple of 512. May be\n  smaller what the disk page size. This influences the speed of the\n  isam btree library. eg to big to slow.\n*/\n#define IO_SIZE\t\t\t4096\n/*\n  How much overhead does malloc have. The code often allocates\n  something like 1024-MALLOC_OVERHEAD bytes\n*/\n#define MALLOC_OVERHEAD 8\n\n\t/* get memory in huncs */\n#define ONCE_ALLOC_INIT\t\t(uint) (4096-MALLOC_OVERHEAD)\n\t/* Typical record cash */\n#define RECORD_CACHE_SIZE\t(uint) (64*1024-MALLOC_OVERHEAD)\n\t/* Typical key cash */\n#define KEY_CACHE_SIZE\t\t(uint) (8*1024*1024)\n\t/* Default size of a key cache block  */\n#define KEY_CACHE_BLOCK_SIZE\t(uint) 1024\n\n\n\t/* Some things that this system doesn't have */\n\n#ifdef _WIN32\n#define NO_DIR_LIBRARY\t\t/* Not standard dir-library */\n#endif\n\n/* Some defines of functions for portability */\n\n#undef remove\t\t/* Crashes MySQL on SCO 5.0.0 */\n#ifndef __WIN__\n#define closesocket(A)\tclose(A)\n#endif\n\n#if (_MSC_VER)\n#if !defined(_WIN64)\ninline double my_ulonglong2double(unsigned long long value)\n{\n  long long nr=(long long) value;\n  if (nr >= 0)\n    return (double) nr;\n  return (18446744073709551616.0 + (double) nr);\n}\n#define ulonglong2double my_ulonglong2double\n#define my_off_t2double  my_ulonglong2double\n#endif /* _WIN64 */\ninline unsigned long long my_double2ulonglong(double d)\n{\n  double t= d - (double) 0x8000000000000000ULL;\n\n  if (t >= 0)\n    return  ((unsigned long long) t) + 0x8000000000000000ULL;\n  return (unsigned long long) d;\n}\n#define double2ulonglong my_double2ulonglong\n#endif\n\n#ifndef ulonglong2double\n#define ulonglong2double(A) ((double) (ulonglong) (A))\n#define my_off_t2double(A)  ((double) (my_off_t) (A))\n#endif\n#ifndef double2ulonglong\n#define double2ulonglong(A) ((ulonglong) (double) (A))\n#endif\n\n#ifndef offsetof\n#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n#endif\n#define ulong_to_double(X) ((double) (ulong) (X))\n\n#ifndef STACK_DIRECTION\n#error \"please add -DSTACK_DIRECTION=1 or -1 to your CPPFLAGS\"\n#endif\n\n#if !defined(HAVE_STRTOK_R)\n#define strtok_r(A,B,C) strtok((A),(B))\n#endif\n\n/* This is from the old m-machine.h file */\n\n#if SIZEOF_LONG_LONG > 4\n#define HAVE_LONG_LONG 1\n#endif\n\n/*\n  Some pre-ANSI-C99 systems like AIX 5.1 and Linux/GCC 2.95 define\n  ULONGLONG_MAX, LONGLONG_MIN, LONGLONG_MAX; we use them if they're defined.\n*/\n\n#if defined(HAVE_LONG_LONG) && !defined(LONGLONG_MIN)\n#define LONGLONG_MIN\t((long long) 0x8000000000000000LL)\n#define LONGLONG_MAX\t((long long) 0x7FFFFFFFFFFFFFFFLL)\n#endif\n\n#if defined(HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)\n/* First check for ANSI C99 definition: */\n#ifdef ULLONG_MAX\n#define ULONGLONG_MAX  ULLONG_MAX\n#else\n#define ULONGLONG_MAX ((unsigned long long)(~0ULL))\n#endif\n#endif /* defined (HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)*/\n\n#define INT_MIN64       (~0x7FFFFFFFFFFFFFFFLL)\n#define INT_MAX64       0x7FFFFFFFFFFFFFFFLL\n#define INT_MIN32       (~0x7FFFFFFFL)\n#define INT_MAX32       0x7FFFFFFFL\n#define UINT_MAX32      0xFFFFFFFFL\n#define INT_MIN24       (~0x007FFFFF)\n#define INT_MAX24       0x007FFFFF\n#define UINT_MAX24      0x00FFFFFF\n#define INT_MIN16       (~0x7FFF)\n#define INT_MAX16       0x7FFF\n#define UINT_MAX16      0xFFFF\n#define INT_MIN8        (~0x7F)\n#define INT_MAX8        0x7F\n#define UINT_MAX8       0xFF\n\n/* From limits.h instead */\n#ifndef DBL_MIN\n#define DBL_MIN\t\t4.94065645841246544e-324\n#define FLT_MIN\t\t((float)1.40129846432481707e-45)\n#endif\n#ifndef DBL_MAX\n#define DBL_MAX\t\t1.79769313486231470e+308\n#define FLT_MAX\t\t((float)3.40282346638528860e+38)\n#endif\n#ifndef SIZE_T_MAX\n#define SIZE_T_MAX      (~((size_t) 0))\n#endif\n\n#ifndef isfinite\n#ifdef HAVE_FINITE\n#define isfinite(x) finite(x)\n#else\n#define finite(x) (1.0 / fabs(x) > 0.0)\n#endif /* HAVE_FINITE */\n#endif /* isfinite */\n\n#ifndef HAVE_ISNAN\n#define isnan(x) ((x) != (x))\n#endif\n\n#ifdef HAVE_ISINF\n/* Check if C compiler is affected by GCC bug #39228 */\n#if !defined(__cplusplus) && defined(HAVE_BROKEN_ISINF)\n/* Force store/reload of the argument to/from a 64-bit double */\nstatic inline double my_isinf(double x)\n{\n  volatile double t= x;\n  return isinf(t);\n}\n#else\n/* System-provided isinf() is available and safe to use */\n#define my_isinf(X) isinf(X)\n#endif\n#else /* !HAVE_ISINF */\n#define my_isinf(X) (!finite(X) && !isnan(X))\n#endif\n\n/* Define missing math constants. */\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.7182818284590452354\n#endif\n#ifndef M_LN2\n#define M_LN2 0.69314718055994530942\n#endif\n\n/*\n  Max size that must be added to a so that we know Size to make\n  adressable obj.\n*/\n#if SIZEOF_CHARP == 4\ntypedef long\t\tmy_ptrdiff_t;\n#else\ntypedef long long\tmy_ptrdiff_t;\n#endif\n\n#define MY_ALIGN(A,L)\t(((A) + (L) - 1) & ~((L) - 1))\n#define ALIGN_SIZE(A)\tMY_ALIGN((A),sizeof(double))\n/* Size to make adressable obj. */\n#define ADD_TO_PTR(ptr,size,type) (type) ((uchar*) (ptr)+size)\n#define PTR_BYTE_DIFF(A,B) (my_ptrdiff_t) ((uchar*) (A) - (uchar*) (B))\n\n/*\n  Custom version of standard offsetof() macro which can be used to get\n  offsets of members in class for non-POD types (according to the current\n  version of C++ standard offsetof() macro can't be used in such cases and\n  attempt to do so causes warnings to be emitted, OTOH in many cases it is\n  still OK to assume that all instances of the class has the same offsets\n  for the same members).\n\n  This is temporary solution which should be removed once File_parser class\n  and related routines are refactored.\n*/\n\n#define my_offsetof(TYPE, MEMBER) \\\n        ((size_t)((char *)&(((TYPE *)0x10)->MEMBER) - (char*)0x10))\n\n#define NullS\t\t(char *) 0\n\n#ifdef STDCALL\n#undef STDCALL\n#endif\n\n#ifdef _WIN32\n#define STDCALL __stdcall\n#else\n#define STDCALL\n#endif\n\n/* Typdefs for easyier portability */\n\n#ifndef HAVE_UCHAR\ntypedef unsigned char\tuchar;\t/* Short for unsigned char */\n#endif\n\n#ifndef HAVE_INT8\ntypedef signed char int8;       /* Signed integer >= 8  bits */\n#endif\n#ifndef HAVE_UINT8\ntypedef unsigned char uint8;    /* Unsigned integer >= 8  bits */\n#endif\n#ifndef HAVE_INT16\ntypedef short int16;\n#endif\n#ifndef HAVE_UINT16\ntypedef unsigned short uint16;\n#endif\n#if SIZEOF_INT == 4\n#ifndef HAVE_INT32\ntypedef int int32;\n#endif\n#ifndef HAVE_UINT32\ntypedef unsigned int uint32;\n#endif\n#elif SIZEOF_LONG == 4\n#ifndef HAVE_INT32\ntypedef long int32;\n#endif\n#ifndef HAVE_UINT32\ntypedef unsigned long uint32;\n#endif\n#else\n#error Neither int or long is of 4 bytes width\n#endif\n\n#if !defined(HAVE_ULONG) && !defined(__USE_MISC)\ntypedef unsigned long\tulong;\t\t  /* Short for unsigned long */\n#endif\n#ifndef longlong_defined\n/* \n  Using [unsigned] long long is preferable as [u]longlong because we use \n  [unsigned] long long unconditionally in many places, \n  for example in constants with [U]LL suffix.\n*/\n#if defined(HAVE_LONG_LONG) && SIZEOF_LONG_LONG == 8\ntypedef unsigned long long int ulonglong; /* ulong or unsigned long long */\ntypedef long long int\tlonglong;\n#else\ntypedef unsigned long\tulonglong;\t  /* ulong or unsigned long long */\ntypedef long\t\tlonglong;\n#endif\n#endif\n#ifndef HAVE_INT64\ntypedef longlong int64;\n#endif\n#ifndef HAVE_UINT64\ntypedef ulonglong uint64;\n#endif\n\n#if defined(NO_CLIENT_LONG_LONG)\ntypedef unsigned long my_ulonglong;\n#elif defined (__WIN__)\ntypedef unsigned __int64 my_ulonglong;\n#else\ntypedef unsigned long long my_ulonglong;\n#endif\n\n#if SIZEOF_CHARP == SIZEOF_INT\ntypedef int intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG\ntypedef long intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG_LONG\ntypedef long long intptr;\n#else\n#error sizeof(void *) is neither sizeof(int) nor sizeof(long) nor sizeof(long long)\n#endif\n\n#define MY_ERRPTR ((void*)(intptr)1)\n\n#if defined(_WIN32)\ntypedef unsigned long long my_off_t;\ntypedef unsigned long long os_off_t;\n#else\ntypedef off_t os_off_t;\n#if SIZEOF_OFF_T > 4\ntypedef ulonglong my_off_t;\n#else\ntypedef unsigned long my_off_t;\n#endif\n#endif /*_WIN32*/\n#define MY_FILEPOS_ERROR\t(~(my_off_t) 0)\n\n/*\n  TODO Convert these to use Bitmap class.\n */\ntypedef ulonglong table_map;          /* Used for table bits in join */\ntypedef ulong nesting_map;  /* Used for flags of nesting constructs */\n\n#if defined(__WIN__)\n#define socket_errno\tWSAGetLastError()\n#define SOCKET_EINTR\tWSAEINTR\n#define SOCKET_EAGAIN\tWSAEINPROGRESS\n#define SOCKET_ETIMEDOUT WSAETIMEDOUT\n#define SOCKET_EWOULDBLOCK WSAEWOULDBLOCK\n#define SOCKET_EADDRINUSE WSAEADDRINUSE\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#else /* Unix */\n#define socket_errno\terrno\n#define closesocket(A)\tclose(A)\n#define SOCKET_EINTR\tEINTR\n#define SOCKET_EAGAIN\tEAGAIN\n#define SOCKET_ETIMEDOUT SOCKET_EINTR\n#define SOCKET_EWOULDBLOCK EWOULDBLOCK\n#define SOCKET_EADDRINUSE EADDRINUSE\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#endif\n\ntypedef int\t\tmyf;\t/* Type of MyFlags in my_funcs */\ntypedef char\t\tmy_bool; /* Small bool */\n\n/* Macros for converting *constants* to the right type */\n#define MYF(v)\t\t(myf) (v)\n\n#ifndef LL\n#ifdef HAVE_LONG_LONG\n#define LL(A) A ## LL\n#else\n#define LL(A) A ## L\n#endif\n#endif\n\n#ifndef ULL\n#ifdef HAVE_LONG_LONG\n#define ULL(A) A ## ULL\n#else\n#define ULL(A) A ## UL\n#endif\n#endif\n\n/*\n  Defines to make it possible to prioritize register assignments. No\n  longer that important with modern compilers.\n*/\n#ifndef USING_X\n#define reg1 register\n#define reg2 register\n#define reg3 register\n#define reg4 register\n#define reg5 register\n#define reg6 register\n#define reg7 register\n#define reg8 register\n#define reg9 register\n#define reg10 register\n#define reg11 register\n#define reg12 register\n#define reg13 register\n#define reg14 register\n#define reg15 register\n#define reg16 register\n#endif\n\n#include <my_dbug.h>\n\n/* Some helper macros */\n#define YESNO(X) ((X) ? \"yes\" : \"no\")\n\n#define MY_HOW_OFTEN_TO_ALARM\t2\t/* How often we want info on screen */\n#define MY_HOW_OFTEN_TO_WRITE\t1000\t/* How often we want info on screen */\n\n\n\n/*\n  Define-funktions for reading and storing in machine independent format\n  (low byte first)\n*/\n\n/* Optimized store functions for Intel x86 */\n#if defined(__i386__) || defined(_WIN32)\n#define sint2korr(A)\t(*((int16 *) (A)))\n#define sint3korr(A)\t((int32) ((((uchar) (A)[2]) & 128) ? \\\n\t\t\t\t  (((uint32) 255L << 24) | \\\n\t\t\t\t   (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t   (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t   ((uint32) (uchar) (A)[0])) : \\\n\t\t\t\t  (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t  (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t  ((uint32) (uchar) (A)[0])))\n#define sint4korr(A)\t(*((long *) (A)))\n#define uint2korr(A)\t(*((uint16 *) (A)))\n#define uint3korr(A)\t(uint32) (((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 16))\n#define uint4korr(A)\t(*((uint32 *) (A)))\n#define uint5korr(A)\t((ulonglong)(((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[3])) << 24)) +\\\n\t\t\t\t    (((ulonglong) ((uchar) (A)[4])) << 32))\n#define uint6korr(A)\t((ulonglong)(((uint32)    ((uchar) (A)[0]))          + \\\n                                     (((uint32)    ((uchar) (A)[1])) << 8)   + \\\n                                     (((uint32)    ((uchar) (A)[2])) << 16)  + \\\n                                     (((uint32)    ((uchar) (A)[3])) << 24)) + \\\n                         (((ulonglong) ((uchar) (A)[4])) << 32) +       \\\n                         (((ulonglong) ((uchar) (A)[5])) << 40))\n#define uint8korr(A)\t(*((ulonglong *) (A)))\n#define sint8korr(A)\t(*((longlong *) (A)))\n#define int2store(T,A)\t*((uint16*) (T))= (uint16) (A)\n#define int3store(T,A)  do { *(T)=  (uchar) ((A));\\\n                            *(T+1)=(uchar) (((uint) (A) >> 8));\\\n                            *(T+2)=(uchar) (((A) >> 16)); } while (0)\n#define int4store(T,A)\t*((long *) (T))= (long) (A)\n#define int5store(T,A)  do { *(T)= (uchar)((A));\\\n                             *((T)+1)=(uchar) (((A) >> 8));\\\n                             *((T)+2)=(uchar) (((A) >> 16));\\\n                             *((T)+3)=(uchar) (((A) >> 24)); \\\n                             *((T)+4)=(uchar) (((A) >> 32)); } while(0)\n#define int6store(T,A)  do { *(T)=    (uchar)((A));          \\\n                             *((T)+1)=(uchar) (((A) >> 8));  \\\n                             *((T)+2)=(uchar) (((A) >> 16)); \\\n                             *((T)+3)=(uchar) (((A) >> 24)); \\\n                             *((T)+4)=(uchar) (((A) >> 32)); \\\n                             *((T)+5)=(uchar) (((A) >> 40)); } while(0)\n#define int8store(T,A)\t*((ulonglong *) (T))= (ulonglong) (A)\n\ntypedef union {\n  double v;\n  long m[2];\n} doubleget_union;\n#define doubleget(V,M)\t\\\ndo { doubleget_union _tmp; \\\n     _tmp.m[0] = *((long*)(M)); \\\n     _tmp.m[1] = *(((long*) (M))+1); \\\n     (V) = _tmp.v; } while(0)\n#define doublestore(T,V) do { *((long *) T) = ((doubleget_union *)&V)->m[0]; \\\n\t\t\t     *(((long *) T)+1) = ((doubleget_union *)&V)->m[1]; \\\n                         } while (0)\n#define float4get(V,M)   do { *((float *) &(V)) = *((float*) (M)); } while(0)\n#define float8get(V,M)   doubleget((V),(M))\n#define float4store(V,M) memcpy((uchar*) V,(uchar*) (&M),sizeof(float))\n#define floatstore(T,V)  memcpy((uchar*)(T), (uchar*)(&V),sizeof(float))\n#define floatget(V,M)    memcpy((uchar*) &V,(uchar*) (M),sizeof(float))\n#define float8store(V,M) doublestore((V),(M))\n#else\n\n/*\n  We're here if it's not a IA-32 architecture (Win32 and UNIX IA-32 defines\n  were done before)\n*/\n#define sint2korr(A)\t(int16) (((int16) ((uchar) (A)[0])) +\\\n\t\t\t\t ((int16) ((int16) (A)[1]) << 8))\n#define sint3korr(A)\t((int32) ((((uchar) (A)[2]) & 128) ? \\\n\t\t\t\t  (((uint32) 255L << 24) | \\\n\t\t\t\t   (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t   (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t   ((uint32) (uchar) (A)[0])) : \\\n\t\t\t\t  (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t  (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t  ((uint32) (uchar) (A)[0])))\n#define sint4korr(A)\t(int32) (((int32) ((uchar) (A)[0])) +\\\n\t\t\t\t(((int32) ((uchar) (A)[1]) << 8)) +\\\n\t\t\t\t(((int32) ((uchar) (A)[2]) << 16)) +\\\n\t\t\t\t(((int32) ((int16) (A)[3]) << 24)))\n#define sint8korr(A)\t(longlong) uint8korr(A)\n#define uint2korr(A)\t(uint16) (((uint16) ((uchar) (A)[0])) +\\\n\t\t\t\t  ((uint16) ((uchar) (A)[1]) << 8))\n#define uint3korr(A)\t(uint32) (((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 16))\n#define uint4korr(A)\t(uint32) (((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[3])) << 24))\n#define uint5korr(A)\t((ulonglong)(((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[3])) << 24)) +\\\n\t\t\t\t    (((ulonglong) ((uchar) (A)[4])) << 32))\n#define uint6korr(A)\t((ulonglong)(((uint32)    ((uchar) (A)[0]))          + \\\n                                     (((uint32)    ((uchar) (A)[1])) << 8)   + \\\n                                     (((uint32)    ((uchar) (A)[2])) << 16)  + \\\n                                     (((uint32)    ((uchar) (A)[3])) << 24)) + \\\n                         (((ulonglong) ((uchar) (A)[4])) << 32) +       \\\n                         (((ulonglong) ((uchar) (A)[5])) << 40))\n#define uint8korr(A)\t((ulonglong)(((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[3])) << 24)) +\\\n\t\t\t(((ulonglong) (((uint32) ((uchar) (A)[4])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[5])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[6])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[7])) << 24))) <<\\\n\t\t\t\t    32))\n#define int2store(T,A)       do { uint def_temp= (uint) (A) ;\\\n                                  *((uchar*) (T))=  (uchar)(def_temp); \\\n                                   *((uchar*) (T)+1)=(uchar)((def_temp >> 8)); \\\n                             } while(0)\n#define int3store(T,A)       do { /*lint -save -e734 */\\\n                                  *((uchar*)(T))=(uchar) ((A));\\\n                                  *((uchar*) (T)+1)=(uchar) (((A) >> 8));\\\n                                  *((uchar*)(T)+2)=(uchar) (((A) >> 16)); \\\n                                  /*lint -restore */} while(0)\n#define int4store(T,A)       do { *((char *)(T))=(char) ((A));\\\n                                  *(((char *)(T))+1)=(char) (((A) >> 8));\\\n                                  *(((char *)(T))+2)=(char) (((A) >> 16));\\\n                                  *(((char *)(T))+3)=(char) (((A) >> 24)); } while(0)\n#define int5store(T,A)       do { *((char *)(T))=     (char)((A));  \\\n                                  *(((char *)(T))+1)= (char)(((A) >> 8)); \\\n                                  *(((char *)(T))+2)= (char)(((A) >> 16)); \\\n                                  *(((char *)(T))+3)= (char)(((A) >> 24)); \\\n                                  *(((char *)(T))+4)= (char)(((A) >> 32)); \\\n\t\t                } while(0)\n#define int6store(T,A)       do { *((char *)(T))=     (char)((A)); \\\n                                  *(((char *)(T))+1)= (char)(((A) >> 8)); \\\n                                  *(((char *)(T))+2)= (char)(((A) >> 16)); \\\n                                  *(((char *)(T))+3)= (char)(((A) >> 24)); \\\n                                  *(((char *)(T))+4)= (char)(((A) >> 32)); \\\n                                  *(((char *)(T))+5)= (char)(((A) >> 40)); \\\n                                } while(0)\n#define int8store(T,A)       do { uint def_temp= (uint) (A), def_temp2= (uint) ((A) >> 32); \\\n                                  int4store((T),def_temp); \\\n                                  int4store((T+4),def_temp2); } while(0)\n#ifdef WORDS_BIGENDIAN\n#define float4store(T,A) do { *(T)= ((uchar *) &A)[3];\\\n                              *((T)+1)=(char) ((uchar *) &A)[2];\\\n                              *((T)+2)=(char) ((uchar *) &A)[1];\\\n                              *((T)+3)=(char) ((uchar *) &A)[0]; } while(0)\n\n#define float4get(V,M)   do { float def_temp;\\\n                              ((uchar*) &def_temp)[0]=(M)[3];\\\n                              ((uchar*) &def_temp)[1]=(M)[2];\\\n                              ((uchar*) &def_temp)[2]=(M)[1];\\\n                              ((uchar*) &def_temp)[3]=(M)[0];\\\n                              (V)=def_temp; } while(0)\n#define float8store(T,V) do { *(T)= ((uchar *) &V)[7];\\\n                              *((T)+1)=(char) ((uchar *) &V)[6];\\\n                              *((T)+2)=(char) ((uchar *) &V)[5];\\\n                              *((T)+3)=(char) ((uchar *) &V)[4];\\\n                              *((T)+4)=(char) ((uchar *) &V)[3];\\\n                              *((T)+5)=(char) ((uchar *) &V)[2];\\\n                              *((T)+6)=(char) ((uchar *) &V)[1];\\\n                              *((T)+7)=(char) ((uchar *) &V)[0]; } while(0)\n\n#define float8get(V,M)   do { double def_temp;\\\n                              ((uchar*) &def_temp)[0]=(M)[7];\\\n                              ((uchar*) &def_temp)[1]=(M)[6];\\\n                              ((uchar*) &def_temp)[2]=(M)[5];\\\n                              ((uchar*) &def_temp)[3]=(M)[4];\\\n                              ((uchar*) &def_temp)[4]=(M)[3];\\\n                              ((uchar*) &def_temp)[5]=(M)[2];\\\n                              ((uchar*) &def_temp)[6]=(M)[1];\\\n                              ((uchar*) &def_temp)[7]=(M)[0];\\\n                              (V) = def_temp; } while(0)\n#else\n#define float4get(V,M)   memcpy(&V, (M), sizeof(float))\n#define float4store(V,M) memcpy(V, (&M), sizeof(float))\n\n#if defined(__FLOAT_WORD_ORDER) && (__FLOAT_WORD_ORDER == __BIG_ENDIAN)\n#define doublestore(T,V) do { *(((char*)T)+0)=(char) ((uchar *) &V)[4];\\\n                              *(((char*)T)+1)=(char) ((uchar *) &V)[5];\\\n                              *(((char*)T)+2)=(char) ((uchar *) &V)[6];\\\n                              *(((char*)T)+3)=(char) ((uchar *) &V)[7];\\\n                              *(((char*)T)+4)=(char) ((uchar *) &V)[0];\\\n                              *(((char*)T)+5)=(char) ((uchar *) &V)[1];\\\n                              *(((char*)T)+6)=(char) ((uchar *) &V)[2];\\\n                              *(((char*)T)+7)=(char) ((uchar *) &V)[3]; }\\\n                         while(0)\n#define doubleget(V,M)   do { double def_temp;\\\n                              ((uchar*) &def_temp)[0]=(M)[4];\\\n                              ((uchar*) &def_temp)[1]=(M)[5];\\\n                              ((uchar*) &def_temp)[2]=(M)[6];\\\n                              ((uchar*) &def_temp)[3]=(M)[7];\\\n                              ((uchar*) &def_temp)[4]=(M)[0];\\\n                              ((uchar*) &def_temp)[5]=(M)[1];\\\n                              ((uchar*) &def_temp)[6]=(M)[2];\\\n                              ((uchar*) &def_temp)[7]=(M)[3];\\\n                              (V) = def_temp; } while(0)\n#endif /* __FLOAT_WORD_ORDER */\n\n#define float8get(V,M)   doubleget((V),(M))\n#define float8store(V,M) doublestore((V),(M))\n#endif /* WORDS_BIGENDIAN */\n\n#endif /* __i386__ OR _WIN32 */\n\n/*\n  Macro for reading 32-bit integer from network byte order (big-endian)\n  from unaligned memory location.\n*/\n#define int4net(A)        (int32) (((uint32) ((uchar) (A)[3]))        |\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 8)  |\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 16) |\\\n\t\t\t\t  (((uint32) ((uchar) (A)[0])) << 24))\n/*\n  Define-funktions for reading and storing in machine format from/to\n  short/long to/from some place in memory V should be a (not\n  register) variable, M is a pointer to byte\n*/\n\n#ifdef WORDS_BIGENDIAN\n\n#define ushortget(V,M)  do { V = (uint16) (((uint16) ((uchar) (M)[1]))+\\\n                                 ((uint16) ((uint16) (M)[0]) << 8)); } while(0)\n#define shortget(V,M)   do { V = (short) (((short) ((uchar) (M)[1]))+\\\n                                 ((short) ((short) (M)[0]) << 8)); } while(0)\n#define longget(V,M)    do { int32 def_temp;\\\n                             ((uchar*) &def_temp)[0]=(M)[0];\\\n                             ((uchar*) &def_temp)[1]=(M)[1];\\\n                             ((uchar*) &def_temp)[2]=(M)[2];\\\n                             ((uchar*) &def_temp)[3]=(M)[3];\\\n                             (V)=def_temp; } while(0)\n#define ulongget(V,M)   do { uint32 def_temp;\\\n                            ((uchar*) &def_temp)[0]=(M)[0];\\\n                            ((uchar*) &def_temp)[1]=(M)[1];\\\n                            ((uchar*) &def_temp)[2]=(M)[2];\\\n                            ((uchar*) &def_temp)[3]=(M)[3];\\\n                            (V)=def_temp; } while(0)\n#define shortstore(T,A) do { uint def_temp=(uint) (A) ;\\\n                             *(((char*)T)+1)=(char)(def_temp); \\\n                             *(((char*)T)+0)=(char)(def_temp >> 8); } while(0)\n#define longstore(T,A)  do { *(((char*)T)+3)=((A));\\\n                             *(((char*)T)+2)=(((A) >> 8));\\\n                             *(((char*)T)+1)=(((A) >> 16));\\\n                             *(((char*)T)+0)=(((A) >> 24)); } while(0)\n\n#define floatget(V,M)    memcpy(&V, (M), sizeof(float))\n#define floatstore(T,V)  memcpy((T), (void*) (&V), sizeof(float))\n#define doubleget(V,M)\t memcpy(&V, (M), sizeof(double))\n#define doublestore(T,V) memcpy((T), (void *) &V, sizeof(double))\n#define longlongget(V,M) memcpy(&V, (M), sizeof(ulonglong))\n#define longlongstore(T,V) memcpy((T), &V, sizeof(ulonglong))\n\n#else\n\n#define ushortget(V,M)\tdo { V = uint2korr(M); } while(0)\n#define shortget(V,M)\tdo { V = sint2korr(M); } while(0)\n#define longget(V,M)\tdo { V = sint4korr(M); } while(0)\n#define ulongget(V,M)   do { V = uint4korr(M); } while(0)\n#define shortstore(T,V) int2store(T,V)\n#define longstore(T,V)\tint4store(T,V)\n#ifndef floatstore\n#define floatstore(T,V)  memcpy((T), (void *) (&V), sizeof(float))\n#define floatget(V,M)    memcpy(&V, (M), sizeof(float))\n#endif\n#ifndef doubleget\n#define doubleget(V,M)\t memcpy(&V, (M), sizeof(double))\n#define doublestore(T,V) memcpy((T), (void *) &V, sizeof(double))\n#endif /* doubleget */\n#define longlongget(V,M) memcpy(&V, (M), sizeof(ulonglong))\n#define longlongstore(T,V) memcpy((T), &V, sizeof(ulonglong))\n\n#endif /* WORDS_BIGENDIAN */\n\n#ifdef HAVE_CHARSET_utf8\n#define MYSQL_UNIVERSAL_CLIENT_CHARSET \"utf8\"\n#else\n#define MYSQL_UNIVERSAL_CLIENT_CHARSET MYSQL_DEFAULT_CHARSET_NAME\n#endif\n\n#if defined(EMBEDDED_LIBRARY) && !defined(HAVE_EMBEDDED_PRIVILEGE_CONTROL)\n#define NO_EMBEDDED_ACCESS_CHECKS\n#endif\n\n#if defined(_WIN32)\n#define dlsym(lib, name) (void*)GetProcAddress((HMODULE)lib, name)\n#define dlopen(libname, unused) LoadLibraryEx(libname, NULL, 0)\n#define dlclose(lib) FreeLibrary((HMODULE)lib)\n#ifndef HAVE_DLOPEN\n#define HAVE_DLOPEN\n#endif\n#endif\n\n#ifdef HAVE_DLOPEN\n#if defined(HAVE_DLFCN_H)\n#include <dlfcn.h>\n#endif\n#endif\n\n#ifndef HAVE_DLERROR\n#ifdef _WIN32\n#define DLERROR_GENERATE(errmsg, error_number) \\\n  char win_errormsg[2048]; \\\n  if(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, \\\n                   0, error_number, 0, win_errormsg, 2048, NULL)) \\\n  { \\\n    char *ptr; \\\n    for (ptr= &win_errormsg[0] + strlen(win_errormsg) - 1; \\\n         ptr >= &win_errormsg[0] && strchr(\"\\r\\n\\t\\0x20\", *ptr); \\\n         ptr--) \\\n      *ptr= 0; \\\n    errmsg= win_errormsg; \\\n  } \\\n  else \\\n    errmsg= \"\"\n#define dlerror() \"\"\n#define dlopen_errno GetLastError()\n#else /* _WIN32 */\n#define dlerror() \"No support for dynamic loading (static build?)\"\n#define DLERROR_GENERATE(errmsg, error_number) errmsg= dlerror()\n#define dlopen_errno errno\n#endif /* _WIN32 */\n#else /* HAVE_DLERROR */\n#define DLERROR_GENERATE(errmsg, error_number) errmsg= dlerror()\n#define dlopen_errno errno\n#endif /* HAVE_DLERROR */\n\n\n/*\n *  Include standard definitions of operator new and delete.\n */\n#ifdef __cplusplus\n#include <new>\n#endif\n\n/* Length of decimal number represented by INT32. */\n#define MY_INT32_NUM_DECIMAL_DIGITS 11\n\n/* Length of decimal number represented by INT64. */\n#define MY_INT64_NUM_DECIMAL_DIGITS 21\n\n/* Define some useful general macros (should be done after all headers). */\n#if !defined(max)\n#define max(a, b)\t((a) > (b) ? (a) : (b))\n#define min(a, b)\t((a) < (b) ? (a) : (b))\n#endif  \n\n/*\n  Only Linux is known to need an explicit sync of the directory to make sure a\n  file creation/deletion/renaming in(from,to) this directory durable.\n*/\n#ifdef TARGET_OS_LINUX\n#define NEED_EXPLICIT_SYNC_DIR 1\n#endif\n\n#if !defined(__cplusplus) && !defined(bool)\n#define bool In_C_you_should_use_my_bool_instead()\n#endif\n\n/* Provide __func__ macro definition for platforms that miss it. */\n#if __STDC_VERSION__ < 199901L\n#  if __GNUC__ >= 2\n#    define __func__ __FUNCTION__\n#  else\n#    define __func__ \"<unknown>\"\n#  endif\n#elif defined(_MSC_VER)\n#  if _MSC_VER < 1300\n#    define __func__ \"<unknown>\"\n#  else\n#    define __func__ __FUNCTION__\n#  endif\n#elif defined(__BORLANDC__)\n#  define __func__ __FUNC__\n#else\n#  define __func__ \"<unknown>\"\n#endif\n\n#ifndef HAVE_RINT\n/**\n   All integers up to this number can be represented exactly as double precision\n   values (DBL_MANT_DIG == 53 for IEEE 754 hardware).\n*/\n#define MAX_EXACT_INTEGER ((1LL << DBL_MANT_DIG) - 1)\n\n/**\n   rint(3) implementation for platforms that do not have it.\n   Always rounds to the nearest integer with ties being rounded to the nearest\n   even integer to mimic glibc's rint() behavior in the \"round-to-nearest\"\n   FPU mode. Hardware-specific optimizations are possible (frndint on x86).\n   Unlike this implementation, hardware will also honor the FPU rounding mode.\n*/\n\nstatic inline double rint(double x)\n{\n  double f, i;\n  f = modf(x, &i);\n  /*\n    All doubles with absolute values > MAX_EXACT_INTEGER are even anyway,\n    no need to check it.\n  */\n  if (x > 0.0)\n    i += (double) ((f > 0.5) || (f == 0.5 &&\n                                 i <= (double) MAX_EXACT_INTEGER &&\n                                 (longlong) i % 2));\n  else\n    i -= (double) ((f < -0.5) || (f == -0.5 &&\n                                  i >= (double) -MAX_EXACT_INTEGER &&\n                                  (longlong) i % 2));\n  return i;\n}\n#endif /* HAVE_RINT */\n\n/* \n  MYSQL_PLUGIN_IMPORT macro is used to export mysqld data\n  (i.e variables) for usage in storage engine loadable plugins.\n  Outside of Windows, it is dummy.\n*/\n#ifndef MYSQL_PLUGIN_IMPORT\n#if (defined(_WIN32) && defined(MYSQL_DYNAMIC_PLUGIN))\n#define MYSQL_PLUGIN_IMPORT __declspec(dllimport)\n#else\n#define MYSQL_PLUGIN_IMPORT\n#endif\n#endif\n\n/* Defines that are unique to the embedded version of MySQL */\n\n#ifdef EMBEDDED_LIBRARY\n\n/* Things we don't need in the embedded version of MySQL */\n/* TODO HF add #undef HAVE_VIO if we don't want client in embedded library */\n\n#undef HAVE_OPENSSL\n#undef HAVE_SMEM\t\t\t\t/* No shared memory */\n\n#endif /* EMBEDDED_LIBRARY */\n\n#endif /* my_global_h */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/plugin/auth/dialog.c": "/*  Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.\n\n    This program is free software; you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as\n    published by the Free Software Foundation; version 2 of the\n    License.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA */\n\n/**\n  @file\n\n  dialog client authentication plugin with examples\n\n  dialog is a general purpose client authentication plugin, it simply\n  asks the user the question, as provided by the server and reports\n  the answer back to the server. No encryption is involved,\n  the answers are sent in clear text.\n\n  Two examples are provided: two_questions server plugin, that asks\n  the password and an \"Are you sure?\" question with a reply \"yes, of course\".\n  It demonstrates the usage of \"password\" (input is hidden) and \"ordinary\"\n  (input can be echoed) questions, and how to mark the last question,\n  to avoid an extra roundtrip.\n\n  And three_attempts plugin that gives the user three attempts to enter\n  a correct password. It shows the situation when a number of questions\n  is not known in advance.\n*/\n#if defined (WIN32) && !defined (RTLD_DEFAULT)\n# define RTLD_DEFAULT GetModuleHandle(NULL)\n#endif\n\n#include <my_global.h>\n#include <mysql.h>\n#include <mysql/plugin_auth.h>\n#include <mysql/client_plugin.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#if !defined (_GNU_SOURCE)\n# define _GNU_SOURCE /* for RTLD_DEFAULT */\n#endif\n\n/**\n  first byte of the question string is the question \"type\".\n  It can be an \"ordinary\" or a \"password\" question.\n  The last bit set marks a last question in the authentication exchange.\n*/\n#define ORDINARY_QUESTION       \"\\2\"\n#define LAST_QUESTION           \"\\3\"\n#define PASSWORD_QUESTION       \"\\4\"\n#define LAST_PASSWORD           \"\\5\"\n\n/********************* SERVER SIDE ****************************************/\n\n/**\n  dialog demo with two questions, one password and one, the last, ordinary.\n*/\nstatic int two_questions(MYSQL_PLUGIN_VIO *vio, MYSQL_SERVER_AUTH_INFO *info)\n{\n  unsigned char *pkt;\n  int pkt_len;\n\n  /* send a password question */\n  if (vio->write_packet(vio, (const unsigned char *) PASSWORD_QUESTION \"Password, please:\", 18))\n    return CR_ERROR;\n\n  /* read the answer */\n  if ((pkt_len= vio->read_packet(vio, &pkt)) < 0)\n    return CR_ERROR;\n\n  info->password_used= PASSWORD_USED_YES;\n\n  /* fail if the password is wrong */\n  if (strcmp((const char *) pkt, info->auth_string))\n    return CR_ERROR;\n\n  /* send the last, ordinary, question */\n  if (vio->write_packet(vio, (const unsigned char *) LAST_QUESTION \"Are you sure ?\", 15))\n    return CR_ERROR;\n\n  /* read the answer */\n  if ((pkt_len= vio->read_packet(vio, &pkt)) < 0)\n    return CR_ERROR;\n\n  /* check the reply */\n  return strcmp((const char *) pkt, \"yes, of course\") ? CR_ERROR : CR_OK;\n}\n\nstatic struct st_mysql_auth two_handler=\n{\n  MYSQL_AUTHENTICATION_INTERFACE_VERSION,\n  \"dialog\", /* requires dialog client plugin */\n  two_questions\n};\n\n/* dialog demo where the number of questions is not known in advance */\nstatic int three_attempts(MYSQL_PLUGIN_VIO *vio, MYSQL_SERVER_AUTH_INFO *info)\n{\n  unsigned char *pkt;\n  int pkt_len, i;\n\n  for (i= 0; i < 3; i++)\n  {\n    /* send the prompt */\n    if (vio->write_packet(vio, \n\t\t(const unsigned char *) PASSWORD_QUESTION \"Password, please:\", 18))\n      return CR_ERROR;\n\n    /* read the password */\n    if ((pkt_len= vio->read_packet(vio, &pkt)) < 0)\n      return CR_ERROR;\n\n    info->password_used= PASSWORD_USED_YES;\n\n    /*\n      finish, if the password is correct.\n      note, that we did not mark the prompt packet as \"last\"\n    */\n    if (strcmp((const char *) pkt, info->auth_string) == 0)\n      return CR_OK;\n  }\n\n  return CR_ERROR;\n}\n\nstatic struct st_mysql_auth three_handler=\n{\n  MYSQL_AUTHENTICATION_INTERFACE_VERSION,\n  \"dialog\", /* requires dialog client plugin */\n  three_attempts \n};\n\nmysql_declare_plugin(dialog)\n{\n  MYSQL_AUTHENTICATION_PLUGIN,\n  &two_handler,\n  \"two_questions\",\n  \"Sergei Golubchik\",\n  \"Dialog plugin demo 1\",\n  PLUGIN_LICENSE_GPL,\n  NULL,\n  NULL,\n  0x0100,\n  NULL,\n  NULL,\n  NULL,\n  0,\n},\n{\n  MYSQL_AUTHENTICATION_PLUGIN,\n  &three_handler,\n  \"three_attempts\",\n  \"Sergei Golubchik\",\n  \"Dialog plugin demo 2\",\n  PLUGIN_LICENSE_GPL,\n  NULL,\n  NULL,\n  0x0100,\n  NULL,\n  NULL,\n  NULL,\n  0,\n}\nmysql_declare_plugin_end;\n\n/********************* CLIENT SIDE ***************************************/\n/*\n  This plugin performs a dialog with the user, asking questions and\n  reading answers. Depending on the client it may be desirable to do it\n  using GUI, or console, with or without curses, or read answers\n  from a smartcard, for example.\n\n  To support all this variety, the dialog plugin has a callback function\n  \"authentication_dialog_ask\". If the client has a function of this name\n  dialog plugin will use it for communication with the user. Otherwise\n  a default fgets() based implementation will be used.\n*/\n\n/**\n  type of the mysql_authentication_dialog_ask function\n\n  @param mysql          mysql\n  @param type           type of the input\n                        1 - ordinary string input\n                        2 - password string\n  @param prompt         prompt\n  @param buf            a buffer to store the use input\n  @param buf_len        the length of the buffer\n\n  @retval               a pointer to the user input string.\n                        It may be equal to 'buf' or to 'mysql->password'.\n                        In all other cases it is assumed to be an allocated\n                        string, and the \"dialog\" plugin will free() it.\n*/\ntypedef char *(*mysql_authentication_dialog_ask_t)(struct st_mysql *mysql,\n                      int type, const char *prompt, char *buf, int buf_len);\n\nstatic mysql_authentication_dialog_ask_t ask;\n\nstatic char *builtin_ask(MYSQL *mysql __attribute__((unused)),\n                         int type __attribute__((unused)),\n                         const char *prompt,\n                         char *buf, int buf_len)\n{\n  char *ptr;\n  fputs(prompt, stdout);\n  fputc(' ', stdout);\n  if (fgets(buf, buf_len, stdin) == NULL)\n    return NULL;\n  if ((ptr= strchr(buf, '\\n')))\n    *ptr= 0;\n\n  return buf;\n}\n\n/**\n  The main function of the dialog plugin.\n\n  Read the prompt, ask the question, send the reply, repeat until\n  the server is satisfied.\n\n  @note\n   1. this plugin shows how a client authentication plugin\n      may read a MySQL protocol OK packet internally - which is important\n      where a number of packets is not known in advance.\n   2. the first byte of the prompt is special. it is not\n      shown to the user, but signals whether it is the last question\n      (prompt[0] & 1 == 1) or not last (prompt[0] & 1 == 0),\n      and whether the input is a password (not echoed).\n   3. the prompt is expected to be sent zero-terminated\n*/\nstatic int perform_dialog(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql)\n{\n  unsigned char *pkt, cmd= 0;\n  int pkt_len, res;\n  char reply_buf[1024], *reply;\n\n  do\n  {\n    /* read the prompt */\n    pkt_len= vio->read_packet(vio, &pkt);\n    if (pkt_len < 0)\n      return CR_ERROR;\n\n    if (pkt == 0)\n    {\n      /*\n        in mysql_change_user() the client sends the first packet, so\n        the first vio->read_packet() does nothing (pkt == 0).\n\n        We send the \"password\", assuming the client knows what it's doing.\n        (in other words, the dialog plugin should be only set as a default\n        authentication plugin on the client if the first question\n        asks for a password - which will be sent in clear text, by the way)\n      */\n      reply= mysql->passwd;\n    }\n    else\n    {\n      cmd= *pkt++;\n\n      /* is it MySQL protocol packet ? */\n      if (cmd == 0 || cmd == 254)\n        return CR_OK_HANDSHAKE_COMPLETE; /* yes. we're done */\n\n      /*\n        asking for a password with an empty prompt means mysql->password\n        otherwise we ask the user and read the reply\n      */\n      if ((cmd >> 1) == 2 && *pkt == 0)\n        reply= mysql->passwd;\n      else\n        reply= ask(mysql, cmd >> 1, (const char *) pkt, \n\t\t\t\t   reply_buf, sizeof(reply_buf));\n      if (!reply)\n        return CR_ERROR;\n    }\n    /* send the reply to the server */\n    res= vio->write_packet(vio, (const unsigned char *) reply, \n\t\t\t\t\t\t   strlen(reply)+1);\n\n    if (reply != mysql->passwd && reply != reply_buf)\n      free(reply);\n\n    if (res)\n      return CR_ERROR;\n\n    /* repeat unless it was the last question */\n  } while ((cmd & 1) != 1);\n\n  /* the job of reading the ok/error packet is left to the server */\n  return CR_OK;\n}\n\n/**\n  initialization function of the dialog plugin\n\n  Pick up the client's authentication_dialog_ask() function, if exists,\n  or fall back to the default implementation.\n*/\n\nstatic int init_dialog(char *unused1   __attribute__((unused)), \n                       size_t unused2  __attribute__((unused)), \n                       int unused3     __attribute__((unused)), \n                       va_list unused4 __attribute__((unused)))\n{\n  void *sym= dlsym(RTLD_DEFAULT, \"mysql_authentication_dialog_ask\");\n  ask= sym ? (mysql_authentication_dialog_ask_t) sym : builtin_ask;\n  return 0;\n}\n\nmysql_declare_client_plugin(AUTHENTICATION)\n  \"dialog\",\n  \"Sergei Golubchik\",\n  \"Dialog Client Authentication Plugin\",\n  {0,1,0},\n  \"GPL\",\n  NULL,\n  init_dialog,\n  NULL,\n  NULL,\n  perform_dialog\nmysql_end_client_plugin;\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/sql-common/client_plugin.c": "/* Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/**\n  @file\n  \n  Support code for the client side (libmysql) plugins\n\n  Client plugins are somewhat different from server plugins, they are simpler.\n\n  They do not need to be installed or in any way explicitly loaded on the\n  client, they are loaded automatically on demand.\n  One client plugin per shared object, soname *must* match the plugin name.\n\n  There is no reference counting and no unloading either.\n*/\n\n#include <my_global.h>\n#include \"mysql.h\"\n#include <my_sys.h>\n#include <m_string.h>\n#include <my_pthread.h>\n\n#include <sql_common.h>\n#include \"errmsg.h\"\n#include <mysql/client_plugin.h>\n\nstruct st_client_plugin_int {\n  struct st_client_plugin_int *next;\n  void   *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n};\n\nstatic my_bool initialized= 0;\nstatic MEM_ROOT mem_root;\n\nstatic const char *plugin_declarations_sym= \"_mysql_client_plugin_declaration_\";\nstatic uint plugin_version[MYSQL_CLIENT_MAX_PLUGINS]=\n{\n  0, /* these two are taken by Connector/C */\n  0, /* these two are taken by Connector/C */\n  MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION\n};\n\n/*\n  Loaded plugins are stored in a linked list.\n  The list is append-only, the elements are added to the head (like in a stack).\n  The elements are added under a mutex, but the list can be read and traversed\n  without any mutex because once an element is added to the list, it stays\n  there. The main purpose of a mutex is to prevent two threads from\n  loading the same plugin twice in parallel.\n*/\nstruct st_client_plugin_int *plugin_list[MYSQL_CLIENT_MAX_PLUGINS];\nstatic pthread_mutex_t LOCK_load_client_plugin;\n\nstatic int is_not_initialized(MYSQL *mysql, const char *name)\n{\n  if (initialized)\n    return 0;\n\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n                           unknown_sqlstate, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n                           name, \"not initialized\");\n  return 1;\n}\n\n/**\n  finds a plugin in the list\n\n  @param name   plugin name to search for\n  @param type   plugin type\n\n  @note this does NOT necessarily need a mutex, take care!\n  \n  @retval a pointer to a found plugin or 0\n*/\nstatic struct st_mysql_client_plugin *\nfind_plugin(const char *name, int type)\n{\n  struct st_client_plugin_int *p;\n\n  DBUG_ASSERT(initialized);\n  DBUG_ASSERT(type >= 0 && type < MYSQL_CLIENT_MAX_PLUGINS);\n  if (type < 0 || type >= MYSQL_CLIENT_MAX_PLUGINS)\n    return 0;\n\n  for (p= plugin_list[type]; p; p= p->next)\n  {\n    if (strcmp(p->plugin->name, name) == 0)\n      return p->plugin;\n  }\n  return NULL;\n}\n\n/**\n  verifies the plugin and adds it to the list\n\n  @param mysql          MYSQL structure (for error reporting)\n  @param plugin         plugin to install\n  @param dlhandle       a handle to the shared object (returned by dlopen)\n                        or 0 if the plugin was not dynamically loaded\n  @param argc           number of arguments in the 'va_list args'\n  @param args           arguments passed to the plugin initialization function\n\n  @retval a pointer to an installed plugin or 0\n*/\nstatic struct st_mysql_client_plugin *\nadd_plugin(MYSQL *mysql, struct st_mysql_client_plugin *plugin, void *dlhandle,\n           int argc, va_list args)\n{\n  const char *errmsg;\n  struct st_client_plugin_int plugin_int, *p;\n  char errbuf[1024];\n\n  DBUG_ASSERT(initialized);\n\n  plugin_int.plugin= plugin;\n  plugin_int.dlhandle= dlhandle;\n\n  if (plugin->type >= MYSQL_CLIENT_MAX_PLUGINS)\n  {\n    errmsg= \"Unknown client plugin type\";\n    goto err1;\n  }\n\n  if (plugin->interface_version < plugin_version[plugin->type] ||\n      (plugin->interface_version >> 8) >\n       (plugin_version[plugin->type] >> 8))\n  {\n    errmsg= \"Incompatible client plugin interface\";\n    goto err1;\n  }\n\n  /* Call the plugin initialization function, if any */\n  if (plugin->init && plugin->init(errbuf, sizeof(errbuf), argc, args))\n  {\n    errmsg= errbuf;\n    goto err1;\n  }\n\n  p= (struct st_client_plugin_int *)\n    memdup_root(&mem_root, &plugin_int, sizeof(plugin_int));\n\n  if (!p)\n  {\n    errmsg= \"Out of memory\";\n    goto err2;\n  }\n\n  safe_mutex_assert_owner(&LOCK_load_client_plugin);\n\n  p->next= plugin_list[plugin->type];\n  plugin_list[plugin->type]= p;\n  net_clear_error(&mysql->net);\n\n  return plugin;\n\nerr2:\n  if (plugin->deinit)\n    plugin->deinit();\nerr1:\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER(CR_AUTH_PLUGIN_CANNOT_LOAD), plugin->name,\n                           errmsg);\n  if (dlhandle)\n    dlclose(dlhandle);\n  return NULL;\n}\n\n/**\n  Loads plugins which are specified in the environment variable\n  LIBMYSQL_PLUGINS.\n  \n  Multiple plugins must be separated by semicolon. This function doesn't\n  return or log an error.\n\n  The function is be called by mysql_client_plugin_init\n\n  @todo\n  Support extended syntax, passing parameters to plugins, for example\n  LIBMYSQL_PLUGINS=\"plugin1(param1,param2);plugin2;...\"\n  or\n  LIBMYSQL_PLUGINS=\"plugin1=int:param1,str:param2;plugin2;...\"\n*/\nstatic void load_env_plugins(MYSQL *mysql)\n{\n  char *plugs, *free_env, *s= getenv(\"LIBMYSQL_PLUGINS\");\n  char *enable_cleartext_plugin= getenv(\"LIBMYSQL_ENABLE_CLEARTEXT_PLUGIN\");\n\n  if (enable_cleartext_plugin && strchr(\"1Yy\", enable_cleartext_plugin[0]))\n    libmysql_cleartext_plugin_enabled= 1;\n\n  /* no plugins to load */\n  if(!s)\n    return;\n\n  free_env= plugs= my_strdup(s, MYF(MY_WME));\n\n  do {\n    if ((s= strchr(plugs, ';')))\n      *s= '\\0';\n    mysql_load_plugin(mysql, plugs, -1, 0);\n    plugs= s + 1;\n  } while (s);\n\n  my_free(free_env);\n\n}\n\n/********** extern functions to be used by libmysql *********************/\n\n/**\n  Initializes the client plugin layer.\n\n  This function must be called before any other client plugin function.\n\n  @retval 0    successful\n  @retval != 0 error occured\n*/\nint mysql_client_plugin_init()\n{\n  MYSQL mysql;\n  struct st_mysql_client_plugin **builtin;\n\n  if (initialized)\n    return 0;\n\n  bzero(&mysql, sizeof(mysql)); /* dummy mysql for set_mysql_extended_error */\n\n  pthread_mutex_init(&LOCK_load_client_plugin, MY_MUTEX_INIT_SLOW);\n  init_alloc_root(&mem_root, 128, 128);\n\n  bzero(&plugin_list, sizeof(plugin_list));\n\n  initialized= 1;\n\n  pthread_mutex_lock(&LOCK_load_client_plugin);\n\n  for (builtin= mysql_client_builtins; *builtin; builtin++)\n    add_plugin(&mysql, *builtin, 0, 0, 0);\n\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n\n  load_env_plugins(&mysql);\n\n  return 0;\n}\n\n/**\n  Deinitializes the client plugin layer.\n\n  Unloades all client plugins and frees any associated resources.\n*/\nvoid mysql_client_plugin_deinit()\n{\n  int i;\n  struct st_client_plugin_int *p;\n\n  if (!initialized)\n    return;\n\n  for (i=0; i < MYSQL_CLIENT_MAX_PLUGINS; i++)\n    for (p= plugin_list[i]; p; p= p->next)\n    {\n      if (p->plugin->deinit)\n        p->plugin->deinit();\n      if (p->dlhandle)\n        dlclose(p->dlhandle);\n    }\n\n  bzero(&plugin_list, sizeof(plugin_list));\n  initialized= 0;\n  free_root(&mem_root, MYF(0));\n  pthread_mutex_destroy(&LOCK_load_client_plugin);\n}\n\n/************* public facing functions, for client consumption *********/\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_client_register_plugin(MYSQL *mysql,\n                             struct st_mysql_client_plugin *plugin)\n{\n  if (is_not_initialized(mysql, plugin->name))\n    return NULL;\n\n  pthread_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (find_plugin(plugin->name, plugin->type))\n  {\n    set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n                             unknown_sqlstate, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n                             plugin->name, \"it is already loaded\");\n    plugin= NULL;\n  }\n  else\n    plugin= add_plugin(mysql, plugin, 0, 0, 0);\n\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n  return plugin;\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_load_plugin_v(MYSQL *mysql, const char *name, int type,\n                    int argc, va_list args)\n{\n  const char *errmsg;\n  char dlpath[FN_REFLEN+1];\n  void *sym, *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n#ifdef _WIN32\n  char win_errormsg[2048];\n#endif\n\n  DBUG_ENTER (\"mysql_load_plugin_v\");\n  DBUG_PRINT (\"entry\", (\"name=%s type=%d int argc=%d\", name, type, argc));\n  if (is_not_initialized(mysql, name))\n  {\n    DBUG_PRINT (\"leave\", (\"mysql not initialized\"));\n    DBUG_RETURN (NULL);\n  }\n\n  pthread_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (type >= 0 && find_plugin(name, type))\n  {\n    errmsg= \"it is already loaded\";\n    goto err;\n  }\n\n  /* Compile dll path */\n  strxnmov(dlpath, sizeof(dlpath) - 1,\n           mysql->options.extension && mysql->options.extension->plugin_dir ?\n           mysql->options.extension->plugin_dir : PLUGINDIR, \"/\",\n           name, SO_EXT, NullS);\n   \n  DBUG_PRINT (\"info\", (\"dlopeninig %s\", dlpath));\n  /* Open new dll handle */\n  if (!(dlhandle= dlopen(dlpath, RTLD_NOW)))\n  {\n#if defined(__APPLE__)\n    /* Apple supports plugins with .so also, so try this as well */\n    strxnmov(dlpath, sizeof(dlpath) - 1,\n             mysql->options.extension && mysql->options.extension->plugin_dir ?\n             mysql->options.extension->plugin_dir : PLUGINDIR, \"/\",\n             name, \".so\", NullS);\n    if ((dlhandle= dlopen(dlpath, RTLD_NOW)))\n      goto have_plugin;\n#endif\n\n    DBUG_PRINT (\"info\", (\"failed to dlopen\"));\n#ifdef _WIN32\n    if(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,\n                  0, GetLastError(), 0, win_errormsg, 2048, NULL))\n      errmsg= win_errormsg;\n    else\n      errmsg= \"\";\n#else\n    errmsg= dlerror();\n#endif\n    goto err;\n  }\n\n#if defined(__APPLE__)\nhave_plugin:  \n#endif\n  if (!(sym= dlsym(dlhandle, plugin_declarations_sym)))\n  {\n    errmsg= \"not a plugin\";\n    dlclose(dlhandle);\n    goto err;\n  }\n\n  plugin= (struct st_mysql_client_plugin*)sym;\n\n  if (type >=0 && type != plugin->type)\n  {\n    errmsg= \"type mismatch\";\n    goto err;\n  }\n\n  if (strcmp(name, plugin->name))\n  {\n    errmsg= \"name mismatch\";\n    goto err;\n  }\n\n  if (type < 0 && find_plugin(name, plugin->type))\n  {\n    errmsg= \"it is already loaded\";\n    goto err;\n  }\n\n  plugin= add_plugin(mysql, plugin, dlhandle, argc, args);\n\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n\n  DBUG_PRINT (\"leave\", (\"plugin loaded ok\"));\n  DBUG_RETURN (plugin);\n\nerr:\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n  DBUG_PRINT (\"leave\", (\"plugin load error : %s\", errmsg));\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name, errmsg);\n  DBUG_RETURN (NULL);\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_load_plugin(MYSQL *mysql, const char *name, int type, int argc, ...)\n{\n  struct st_mysql_client_plugin *p;\n  va_list args;\n  va_start(args, argc);\n  p= mysql_load_plugin_v(mysql, name, type, argc, args);\n  va_end(args);\n  return p;\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_client_find_plugin(MYSQL *mysql, const char *name, int type)\n{\n  struct st_mysql_client_plugin *p;\n\n  DBUG_ENTER (\"mysql_client_find_plugin\");\n  DBUG_PRINT (\"entry\", (\"name=%s, type=%d\", name, type));\n  if (is_not_initialized(mysql, name))\n    DBUG_RETURN (NULL);\n\n  if (type < 0 || type >= MYSQL_CLIENT_MAX_PLUGINS)\n  {\n    set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                             ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name,\n                             \"invalid type\");\n  }\n\n  if ((p= find_plugin(name, type)))\n  {\n    DBUG_PRINT (\"leave\", (\"found %p\", p));\n    DBUG_RETURN (p);\n  }\n\n  /* not found, load it */\n  p= mysql_load_plugin(mysql, name, type, 0);\n  DBUG_PRINT (\"leave\", (\"loaded %p\", p));\n  DBUG_RETURN (p);\n}\n\n\n/* see <mysql/client_plugin.h> for a full description */\nint mysql_plugin_options(struct st_mysql_client_plugin *plugin,\n                                 const char *option,\n                                 const void *value)\n{\n  DBUG_ENTER(\"mysql_plugin_options\");\n  /* does the plugin support options call? */\n  if (!plugin || !plugin->options)\n    DBUG_RETURN(1);\n  DBUG_RETURN(plugin->options(option, value));\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/valgrind.supp": "# Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Library General Public\n# License as published by the Free Software Foundation; version 2\n# of the License.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Library General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n#\n# Suppress some common (not fatal) errors in system libraries found by valgrind\n#\n\n#\n# Pthread doesn't free all thread specific memory before program exists\n#\n{\n   pthread allocate_tls memory loss\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_allocate_tls\n   fun:allocate_stack\n   fun:pthread_create*\n}\n\n{\n   pthread allocate_tls memory loss\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_allocate_tls\n   fun:pthread_create*\n\n}\n\n{\n   pthead_exit memory loss 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n}\n\n{\n   pthread_exit memory loss 2\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 3\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 4\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_check_map_versions\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 5\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n}\n\n{\n   pthread allocate_dtv memory loss\n   Memcheck:Leak\n   fun:calloc\n   fun:allocate_dtv\n   fun:_dl_allocate_tls_storage\n   fun:__GI__dl_allocate_tls\n   fun:pthread_create\n}\n\n{\n   pthread allocate_dtv memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:allocate_dtv\n   fun:_dl_allocate_tls\n   fun:pthread_create*\n}\n\n{\n   pthread memalign memory loss\n   Memcheck:Leak\n   fun:memalign\n   fun:_dl_allocate_tls_storage\n   fun:__GI__dl_allocate_tls\n   fun:pthread_create\n}\n\n{\n   pthread pthread_key_create\n   Memcheck:Leak\n   fun:malloc\n   fun:*\n   fun:*\n   fun:pthread_key_create\n   fun:my_thread_global_init\n}\n\n{\n   pthread strstr uninit\n   Memcheck:Cond\n   fun:strstr\n   obj:/lib/tls/libpthread.so.*\n   obj:/lib/tls/libpthread.so.*\n   fun:call_init\n   fun:_dl_init\n   obj:/lib/ld-*.so\n}\n\n{\n   pthread strstr uninit\n   Memcheck:Cond\n   fun:strstr\n   obj:/lib/tls/libpthread.so.*\n   obj:/lib/tls/libpthread.so.*\n   fun:call_init\n   fun:_dl_init\n   obj:/lib/ld-*.so\n}\n\n{  \n   strlen/_dl_init_paths/dl_main/_dl_sysdep_start(Cond)\n   Memcheck:Cond\n   fun:strlen\n   fun:_dl_init_paths\n   fun:dl_main\n   fun:_dl_sysdep_start\n}\n\n{\n   pthread errno\n   Memcheck:Leak\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlsym\n   fun:__errno_location\n}\n\n\n#\n# Warnings in libz becasue it works with aligned memory(?)\n#\n\n{\n   libz tr_flush_block\n   Memcheck:Cond\n   fun:_tr_flush_block\n   fun:deflate_slow\n   fun:deflate\n   fun:do_flush\n   fun:gzclose\n}\n\n{\n   libz tr_flush_block2\n   Memcheck:Cond\n   fun:_tr_flush_block\n   fun:deflate_slow\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz longest_match\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:do_flush\n}\n\n{\n   libz longest_match called from btr_store_big_rec_extern_fields\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:btr_store_big_rec_extern_fields\n}\n\n{\n   libz longest_match called from page_zip_compress\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:page_zip_compress\n}\n\n{\n   libz longest_match2\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz longest_match 3\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:gzclose\n}\n\n{\n   libz longest_match 4 \n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:gzflush\n}\n\n{\n   libz longest_match3\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:azflush\n}\n\n{\n   libz longest_match3\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:azclose\n}\n\n{\n   libz deflate\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz deflate2\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   obj:*/libz.so.*\n   fun:gzflush\n}\n\n{\n   libz deflate3\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   fun:do_flush\n}\n\n#\n# Warning from my_thread_init becasue mysqld dies before kill thread exists\n#\n\n{\n   my_thread_init kill thread memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:my_thread_init\n   fun:kill_server_thread\n}\n\n\n# Red Hat AS 4 32 bit\n{\n   dl_relocate_object\n   Memcheck:Cond\n   fun:_dl_relocate_object\n}\n\n#\n# Warning from my_thread_init becasue mysqld dies before kill thread exists\n#\n\n{\n   my_thread_init kill thread memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:my_thread_init\n   fun:kill_server_thread\n}\n\n#\n# Leaks reported in _dl_* internal functions on Linux amd64 / glibc2.3.2.\n#\n\n{\n   _dl_start invalid write8\n   Memcheck:Addr8\n   fun:_dl_start\n}\n\n{\n   _dl_start invalid write4\n   Memcheck:Addr4\n   fun:_dl_start\n}\n\n{\n   _dl_start/_dl_setup_hash invalid read8\n   Memcheck:Addr8\n   fun:_dl_setup_hash\n   fun:_dl_start\n}\n\n{\n   _dl_sysdep_start invalid write8\n   Memcheck:Addr8\n   fun:_dl_sysdep_start\n}\n\n{\n   _dl_init invalid write8\n   Memcheck:Addr8\n   fun:_dl_init\n}\n\n{\n   _dl_init invalid write4\n   Memcheck:Addr4\n   fun:_dl_init\n}\n\n{\n   _dl_init/_dl_init invalid read8\n   Memcheck:Addr8\n   fun:_dl_debug_initialize\n   fun:_dl_init\n}\n\n{\n   _dl_init/_dl_debug_state invalid read8\n   Memcheck:Addr8\n   fun:_dl_debug_state\n   fun:_dl_init\n}\n\n{\n   init invalid write8\n   Memcheck:Addr8\n   fun:init\n}\n\n{\n   fixup invalid write8\n   Memcheck:Addr8\n   fun:fixup\n}\n\n{\n   fixup/_dl_lookup_versioned_symbol invalid read8\n   Memcheck:Addr8\n   fun:_dl_lookup_versioned_symbol\n   fun:fixup\n}\n\n{\n   _dl_runtime_resolve invalid read8\n   Memcheck:Addr8\n   fun:_dl_runtime_resolve\n}\n\n{\n   __libc_start_main invalid write8\n   Memcheck:Addr8\n   fun:__libc_start_main\n}\n\n{\n   __libc_start_main/__sigjmp_save invalid write4\n   Memcheck:Addr4\n   fun:__sigjmp_save\n   fun:__libc_start_main\n}\n\n#\n# These seem to be libc threading stuff, not related to MySQL code (allocations\n# during pthread_exit()). Googling shows other projects also using these\n# suppressions.\n#\n# Note that these all stem from pthread_exit() deeper in the call stack, but\n# Valgrind only allows the top four calls in the suppressions.\n#\n\n{\n   libc pthread_exit 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   libc pthread_exit 2\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 3\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 4\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_check_map_versions\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 5\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   libc pthread_exit 6\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:openaux\n   fun:_dl_catch_error \n}\n\n{\n   libc pthread_exit 7\n   Memcheck:Leak\n   fun:malloc\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n}\n\n{\n   libc pthread_exit 8\n   Memcheck:Leak\n   fun:malloc\n   fun:local_strdup\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n{\n   libc pthread_exit 9\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_close_worker\n   fun:_dl_close\n   fun:_dl_catch_error\n}\n\n#\n# This is seen internally in the system libraries on 64-bit RHAS3.\n#\n\n{\n   __lll_mutex_unlock_wake uninitialized\n   Memcheck:Param\n   futex(utime)\n   fun:__lll_mutex_unlock_wake\n}\n\n#\n# BUG#19940: NDB sends uninitialized parts of field buffers across the wire.\n# This is \"works as designed\"; the uninitialized part is not used at the\n# other end (but Valgrind cannot see this).\n#\n{\n   bug19940\n   Memcheck:Param\n   socketcall.sendto(msg)\n   fun:send\n   fun:_ZN15TCP_Transporter6doSendEv\n   fun:_ZN19TransporterRegistry11performSendEv\n   fun:_ZN19TransporterRegistry14forceSendCheckEi\n}\n# Warning when printing stack trace (to suppress some not needed warnings)\n#\n\n{\n   vprintf on stacktrace\n   Memcheck:Cond\n   fun:vfprintf\n   fun:uffered_vfprintf\n   fun:vfprintf\n   fun:fprintf\n   fun:print_stacktrace\n}\n\n#\n# Safe warnings, that may happen because of thread scheduling\n#\n\n{\n   dbug initialization by kill_server\n   Memcheck:Leak\n   fun:malloc\n   fun:DbugMalloc\n   fun:code_state\n   fun:_db_enter_\n   fun:kill_server\n}\n\n#\n# Warning caused by small memory leak in threaded dlopen\n#\n\n{\n   dlopen threaded memory leak\n   Memcheck:Leak\n   fun:calloc\n   obj:*/libdl-*.so\n   fun:dlopen*\n}\n\n#\n# BUG#45630\n# Suppress valgrind failures within nptl_pthread_exit_hack_handler on Ubuntu 9.04, x86 (but not amd64)\n#\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 1\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 2\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 3\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 4\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 5\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n}\n\n# suppressions for glibc 2.6.1 64 bit\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 6\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 7\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 8\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 8\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n}\n\n#\n# Pthread doesn't free all thread specific memory before program exists\n#\n{\n   pthread allocate_tls memory loss in 2.6.1.\n   Memcheck:Leak \n   fun:calloc\n   obj:*/ld-*.so\n   fun:_dl_allocate_tls\n   fun:pthread_create*\n}\n\n{\n   buf_buddy_relocate peeking (space,page) in potentially free blocks\n   Memcheck:Addr1\n   fun:buf_buddy_relocate\n}\n\n#\n# See related Bug#56666\n# Race condition between the server main thread and the kill server thread.\n#\n# Because of this race condition, the call to shutdown_performance_schema()\n# was commented in sql/mysqld.cc, causing the reported leaks.\n#\n\n{\n   missing shutdown_performance_schema 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_Z10pfs_mallocmi\n}\n\n{\n   missing shutdown_performance_schema 2\n   Memcheck:Leak\n   fun:malloc\n   fun:my_malloc\n   fun:_lf_alloc_new\n   fun:lf_hash_insert\n}\n\n#\n# Note that initialize_bucket() is reccursive,\n# can't provide more stack context.\n#\n{\n   missing shutdown_performance_schema 3\n   Memcheck:Leak\n   fun:malloc\n   fun:my_malloc\n   fun:initialize_bucket\n}\n\n{\n   missing shutdown_performance_schema 4\n   Memcheck:Leak\n   fun:malloc\n   fun:my_malloc\n   fun:_lf_dynarray_lvalue\n   fun:_lf_pinbox_get_pins\n}\n\n{\n   missing shutdown_performance_schema 5\n   Memcheck:Leak\n   fun:malloc\n   fun:my_malloc\n   fun:_lf_dynarray_lvalue\n   fun:lf_hash_insert\n}\n\n{\n   missing shutdown_performance_schema 6\n   Memcheck:Leak\n   fun:malloc\n   fun:my_malloc\n   fun:_lf_dynarray_lvalue\n   fun:lf_hash_delete\n}\n\n{\n   missing shutdown_performance_schema 7\n   Memcheck:Leak\n   fun:malloc\n   fun:my_malloc\n   fun:_lf_dynarray_lvalue\n   fun:lf_hash_search\n}\n\n{\n   Bug 59874 Valgrind warning in InnoDB compression code\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:btr_store_big_rec_extern_fields_func\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:page_zip_compress\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:page_zip_compress_deflate\n}\n\n{\n   Bug 59875 Valgrind warning in buf0buddy.c\n   Memcheck:Addr1\n   fun:mach_read_from_4\n   fun:buf_buddy_relocate\n   fun:buf_buddy_free_low\n   fun:buf_buddy_free\n}\n\n# Note the wildcard in the (mangled) function signatures of\n# write_keys() and find_all_keys().\n# They both return ha_rows, which is platform dependent.\n#\n# The '...' wildcards are for 'fun:inline_mysql_file_write' and\n# 'fun:find_all_keys' which *may* be inlined.\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / one\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread*.so\n   fun:my_write\n   ...\n   fun:my_b_flush_io_cache\n   fun:_my_b_write\n   fun:_Z*10write_keysP13st_sort_paramPPhjP11st_io_cacheS4_\n   ...\n   fun:_Z8filesortP3THDP5TABLEP13st_sort_fieldjP10SQL_SELECTybPy\n}\n\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / two\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread*.so\n   fun:my_write\n   ...\n   fun:my_b_flush_io_cache\n   fun:_Z15merge_many_buffP13st_sort_paramPhP10st_buffpekPjP11st_io_cache\n   fun:_Z8filesortP3THDP5TABLEP13st_sort_fieldjP10SQL_SELECTybPy\n}\n\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / three\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread*.so\n   fun:my_write\n   ...\n   fun:my_b_flush_io_cache\n   fun:_Z8filesortP3THDP5TABLEP13st_sort_fieldjP10SQL_SELECTybPy\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/sql/sql_udf.cc": "/* Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/* This implements 'user defined functions' */\n\n/*\n   Known bugs:\n  \n   Memory for functions is never freed!\n   Shared libraries are not closed before mysqld exits;\n     - This is because we can't be sure if some threads are using\n       a function.\n  \n   The bugs only affect applications that create and free a lot of\n   dynamic functions, so this shouldn't be a real problem.\n*/\n\n#ifdef USE_PRAGMA_IMPLEMENTATION\n#pragma implementation\t\t\t\t// gcc: Class implementation\n#endif\n\n#include \"sql_priv.h\"\n#include \"unireg.h\"\n#include \"sql_base.h\"                           // close_mysql_tables\n#include \"sql_parse.h\"                        // check_identifier_name\n#include \"sql_table.h\"                        // write_bin_log\n#include \"records.h\"          // init_read_record, end_read_record\n#include <my_pthread.h>\n#include \"lock.h\"                               // MYSQL_LOCK_IGNORE_TIMEOUT\n\n#ifdef HAVE_DLOPEN\nextern \"C\"\n{\n#include <stdarg.h>\n#include <hash.h>\n}\n\nstatic bool initialized = 0;\nstatic MEM_ROOT mem;\nstatic HASH udf_hash;\nstatic mysql_rwlock_t THR_LOCK_udf;\n\n\nstatic udf_func *add_udf(LEX_STRING *name, Item_result ret,\n                         char *dl, Item_udftype typ);\nstatic void del_udf(udf_func *udf);\nstatic void *find_udf_dl(const char *dl);\n\nstatic char *init_syms(udf_func *tmp, char *nm)\n{\n  char *end;\n\n  if (!((tmp->func= (Udf_func_any) dlsym(tmp->dlhandle, tmp->name.str))))\n    return tmp->name.str;\n\n  end=strmov(nm,tmp->name.str);\n\n  if (tmp->type == UDFTYPE_AGGREGATE)\n  {\n    (void)strmov(end, \"_clear\");\n    if (!((tmp->func_clear= (Udf_func_clear) dlsym(tmp->dlhandle, nm))))\n      return nm;\n    (void)strmov(end, \"_add\");\n    if (!((tmp->func_add= (Udf_func_add) dlsym(tmp->dlhandle, nm))))\n      return nm;\n  }\n\n  (void) strmov(end,\"_deinit\");\n  tmp->func_deinit= (Udf_func_deinit) dlsym(tmp->dlhandle, nm);\n\n  (void) strmov(end,\"_init\");\n  tmp->func_init= (Udf_func_init) dlsym(tmp->dlhandle, nm);\n\n  /*\n    to prefent loading \"udf\" from, e.g. libc.so\n    let's ensure that at least one auxiliary symbol is defined\n  */\n  if (!tmp->func_init && !tmp->func_deinit && tmp->type != UDFTYPE_AGGREGATE)\n  {\n    if (!opt_allow_suspicious_udfs)\n      return nm;\n    if (current_thd->variables.log_warnings)\n      sql_print_warning(ER(ER_CANT_FIND_DL_ENTRY), nm);\n  }\n  return 0;\n}\n\n\nextern \"C\" uchar* get_hash_key(const uchar *buff, size_t *length,\n\t\t\t      my_bool not_used __attribute__((unused)))\n{\n  udf_func *udf=(udf_func*) buff;\n  *length=(uint) udf->name.length;\n  return (uchar*) udf->name.str;\n}\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_rwlock_key key_rwlock_THR_LOCK_udf;\n\nstatic PSI_rwlock_info all_udf_rwlocks[]=\n{\n  { &key_rwlock_THR_LOCK_udf, \"THR_LOCK_udf\", PSI_FLAG_GLOBAL}\n};\n\nstatic void init_udf_psi_keys(void)\n{\n  const char* category= \"sql\";\n  int count;\n\n  if (PSI_server == NULL)\n    return;\n\n  count= array_elements(all_udf_rwlocks);\n  PSI_server->register_rwlock(category, all_udf_rwlocks, count);\n}\n#endif\n\n/*\n  Read all predeclared functions from mysql.func and accept all that\n  can be used.\n*/\n\nvoid udf_init()\n{\n  udf_func *tmp;\n  TABLE_LIST tables;\n  READ_RECORD read_record_info;\n  TABLE *table;\n  int error;\n  DBUG_ENTER(\"ufd_init\");\n  char db[]= \"mysql\"; /* A subject to casednstr, can't be constant */\n\n  if (initialized)\n    DBUG_VOID_RETURN;\n\n#ifdef HAVE_PSI_INTERFACE\n  init_udf_psi_keys();\n#endif\n\n  mysql_rwlock_init(key_rwlock_THR_LOCK_udf, &THR_LOCK_udf);\n\n  init_sql_alloc(&mem, UDF_ALLOC_BLOCK_SIZE, 0);\n  THD *new_thd = new THD;\n  if (!new_thd ||\n      my_hash_init(&udf_hash,system_charset_info,32,0,0,get_hash_key, NULL, 0))\n  {\n    sql_print_error(\"Can't allocate memory for udf structures\");\n    my_hash_free(&udf_hash);\n    free_root(&mem,MYF(0));\n    delete new_thd;\n    DBUG_VOID_RETURN;\n  }\n  initialized = 1;\n  new_thd->thread_stack= (char*) &new_thd;\n  new_thd->store_globals();\n  new_thd->set_db(db, sizeof(db)-1);\n\n  tables.init_one_table(db, sizeof(db)-1, \"func\", 4, \"func\", TL_READ);\n\n  if (open_and_lock_tables(new_thd, &tables, FALSE, MYSQL_LOCK_IGNORE_TIMEOUT))\n  {\n    DBUG_PRINT(\"error\",(\"Can't open udf table\"));\n    sql_print_error(\"Can't open the mysql.func table. Please \"\n                    \"run mysql_upgrade to create it.\");\n    goto end;\n  }\n\n  table= tables.table;\n  init_read_record(&read_record_info, new_thd, table, NULL,1,0,FALSE);\n  table->use_all_columns();\n  while (!(error= read_record_info.read_record(&read_record_info)))\n  {\n    DBUG_PRINT(\"info\",(\"init udf record\"));\n    LEX_STRING name;\n    name.str=get_field(&mem, table->field[0]);\n    name.length = (uint) strlen(name.str);\n    char *dl_name= get_field(&mem, table->field[2]);\n    bool new_dl=0;\n    Item_udftype udftype=UDFTYPE_FUNCTION;\n    if (table->s->fields >= 4)\t\t\t// New func table\n      udftype=(Item_udftype) table->field[3]->val_int();\n\n    /*\n      Ensure that the .dll doesn't have a path\n      This is done to ensure that only approved dll from the system\n      directories are used (to make this even remotely secure).\n\n      On windows we must check both FN_LIBCHAR and '/'.\n    */\n    if (check_valid_path(dl_name, strlen(dl_name)) ||\n        check_string_char_length(&name, \"\", NAME_CHAR_LEN,\n                                 system_charset_info, 1))\n    {\n      sql_print_error(\"Invalid row in mysql.func table for function '%.64s'\",\n                      name.str);\n      continue;\n    }\n\n    if (!(tmp= add_udf(&name,(Item_result) table->field[1]->val_int(),\n                       dl_name, udftype)))\n    {\n      sql_print_error(\"Can't alloc memory for udf function: '%.64s'\", name.str);\n      continue;\n    }\n\n    void *dl = find_udf_dl(tmp->dl);\n    if (dl == NULL)\n    {\n      char dlpath[FN_REFLEN];\n      strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", tmp->dl,\n               NullS);\n      (void) unpack_filename(dlpath, dlpath);\n      if (!(dl= dlopen(dlpath, RTLD_NOW)))\n      {\n\tconst char *errmsg;\n\tint error_number= dlopen_errno;\n\tDLERROR_GENERATE(errmsg, error_number);\n\n\t/* Print warning to log */\n        sql_print_error(ER(ER_CANT_OPEN_LIBRARY), tmp->dl, error_number, errmsg);\n\t/* Keep the udf in the hash so that we can remove it later */\n\tcontinue;\n      }\n      new_dl=1;\n    }\n    tmp->dlhandle = dl;\n    {\n      char buf[NAME_LEN+16], *missing;\n      if ((missing= init_syms(tmp, buf)))\n      {\n        sql_print_error(ER(ER_CANT_FIND_DL_ENTRY), missing);\n        del_udf(tmp);\n        if (new_dl)\n          dlclose(dl);\n      }\n    }\n  }\n  if (error > 0)\n    sql_print_error(\"Got unknown error: %d\", my_errno);\n  end_read_record(&read_record_info);\n  table->m_needs_reopen= TRUE;                  // Force close to free memory\n\nend:\n  close_mysql_tables(new_thd);\n  delete new_thd;\n  /* Remember that we don't have a THD */\n  my_pthread_setspecific_ptr(THR_THD,  0);\n  DBUG_VOID_RETURN;\n}\n\n\nvoid udf_free()\n{\n  /* close all shared libraries */\n  DBUG_ENTER(\"udf_free\");\n  for (uint idx=0 ; idx < udf_hash.records ; idx++)\n  {\n    udf_func *udf=(udf_func*) my_hash_element(&udf_hash,idx);\n    if (udf->dlhandle)\t\t\t\t// Not closed before\n    {\n      /* Mark all versions using the same handler as closed */\n      for (uint j=idx+1 ;  j < udf_hash.records ; j++)\n      {\n\tudf_func *tmp=(udf_func*) my_hash_element(&udf_hash,j);\n\tif (udf->dlhandle == tmp->dlhandle)\n\t  tmp->dlhandle=0;\t\t\t// Already closed\n      }\n      dlclose(udf->dlhandle);\n    }\n  }\n  my_hash_free(&udf_hash);\n  free_root(&mem,MYF(0));\n  if (initialized)\n  {\n    initialized= 0;\n    mysql_rwlock_destroy(&THR_LOCK_udf);\n  }\n  DBUG_VOID_RETURN;\n}\n\n\nstatic void del_udf(udf_func *udf)\n{\n  DBUG_ENTER(\"del_udf\");\n  if (!--udf->usage_count)\n  {\n    my_hash_delete(&udf_hash,(uchar*) udf);\n    using_udf_functions=udf_hash.records != 0;\n  }\n  else\n  {\n    /*\n      The functions is in use ; Rename the functions instead of removing it.\n      The functions will be automaticly removed when the least threads\n      doesn't use it anymore\n    */\n    char *name= udf->name.str;\n    uint name_length=udf->name.length;\n    udf->name.str=(char*) \"*\";\n    udf->name.length=1;\n    my_hash_update(&udf_hash,(uchar*) udf,(uchar*) name,name_length);\n  }\n  DBUG_VOID_RETURN;\n}\n\n\nvoid free_udf(udf_func *udf)\n{\n  DBUG_ENTER(\"free_udf\");\n  \n  if (!initialized)\n    DBUG_VOID_RETURN;\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  if (!--udf->usage_count)\n  {\n    /*\n      We come here when someone has deleted the udf function\n      while another thread still was using the udf\n    */\n    my_hash_delete(&udf_hash,(uchar*) udf);\n    using_udf_functions=udf_hash.records != 0;\n    if (!find_udf_dl(udf->dl))\n      dlclose(udf->dlhandle);\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_VOID_RETURN;\n}\n\n\n/* This is only called if using_udf_functions != 0 */\n\nudf_func *find_udf(const char *name,uint length,bool mark_used)\n{\n  udf_func *udf=0;\n  DBUG_ENTER(\"find_udf\");\n\n  if (!initialized)\n    DBUG_RETURN(NULL);\n\n  /* TODO: This should be changed to reader locks someday! */\n  if (mark_used)\n    mysql_rwlock_wrlock(&THR_LOCK_udf);  /* Called during fix_fields */\n  else\n    mysql_rwlock_rdlock(&THR_LOCK_udf);  /* Called during parsing */\n\n  if ((udf=(udf_func*) my_hash_search(&udf_hash,(uchar*) name,\n                                      length ? length : (uint) strlen(name))))\n  {\n    if (!udf->dlhandle)\n      udf=0;\t\t\t\t\t// Could not be opened\n    else if (mark_used)\n      udf->usage_count++;\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_RETURN(udf);\n}\n\n\nstatic void *find_udf_dl(const char *dl)\n{\n  DBUG_ENTER(\"find_udf_dl\");\n\n  /*\n    Because only the function name is hashed, we have to search trough\n    all rows to find the dl.\n  */\n  for (uint idx=0 ; idx < udf_hash.records ; idx++)\n  {\n    udf_func *udf=(udf_func*) my_hash_element(&udf_hash,idx);\n    if (!strcmp(dl, udf->dl) && udf->dlhandle != NULL)\n      DBUG_RETURN(udf->dlhandle);\n  }\n  DBUG_RETURN(0);\n}\n\n\n/* Assume that name && dl is already allocated */\n\nstatic udf_func *add_udf(LEX_STRING *name, Item_result ret, char *dl,\n\t\t\t Item_udftype type)\n{\n  if (!name || !dl || !(uint) type || (uint) type > (uint) UDFTYPE_AGGREGATE)\n    return 0;\n  udf_func *tmp= (udf_func*) alloc_root(&mem, sizeof(udf_func));\n  if (!tmp)\n    return 0;\n  bzero((char*) tmp,sizeof(*tmp));\n  tmp->name = *name; //dup !!\n  tmp->dl = dl;\n  tmp->returns = ret;\n  tmp->type = type;\n  tmp->usage_count=1;\n  if (my_hash_insert(&udf_hash,(uchar*)  tmp))\n    return 0;\n  using_udf_functions=1;\n  return tmp;\n}\n\n\n/**\n  Create a user defined function. \n\n  @note Like implementations of other DDL/DML in MySQL, this function\n  relies on the caller to close the thread tables. This is done in the\n  end of dispatch_command().\n*/\n\nint mysql_create_function(THD *thd,udf_func *udf)\n{\n  int error;\n  void *dl=0;\n  bool new_dl=0;\n  TABLE *table;\n  TABLE_LIST tables;\n  udf_func *u_d;\n  bool save_binlog_row_based;\n  DBUG_ENTER(\"mysql_create_function\");\n\n  if (!initialized)\n  {\n    if (opt_noacl)\n      my_error(ER_CANT_INITIALIZE_UDF, MYF(0),\n               udf->name.str,\n               \"UDFs are unavailable with the --skip-grant-tables option\");\n    else\n      my_message(ER_OUT_OF_RESOURCES, ER(ER_OUT_OF_RESOURCES), MYF(0));\n    DBUG_RETURN(1);\n  }\n\n  /*\n    Ensure that the .dll doesn't have a path\n    This is done to ensure that only approved dll from the system\n    directories are used (to make this even remotely secure).\n  */\n  if (check_valid_path(udf->dl, strlen(udf->dl)))\n  {\n    my_message(ER_UDF_NO_PATHS, ER(ER_UDF_NO_PATHS), MYF(0));\n    DBUG_RETURN(1);\n  }\n  if (check_string_char_length(&udf->name, \"\", NAME_CHAR_LEN,\n                               system_charset_info, 1))\n  {\n    my_error(ER_TOO_LONG_IDENT, MYF(0), udf->name.str);\n    DBUG_RETURN(1);\n  }\n\n  /* \n    Turn off row binlogging of this statement and use statement-based \n    so that all supporting tables are updated for CREATE FUNCTION command.\n  */\n  if ((save_binlog_row_based= thd->is_current_stmt_binlog_format_row()))\n    thd->clear_current_stmt_binlog_format_row();\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  if ((my_hash_search(&udf_hash,(uchar*) udf->name.str, udf->name.length)))\n  {\n    my_error(ER_UDF_EXISTS, MYF(0), udf->name.str);\n    goto err;\n  }\n  if (!(dl = find_udf_dl(udf->dl)))\n  {\n    char dlpath[FN_REFLEN];\n    strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", udf->dl, NullS);\n    (void) unpack_filename(dlpath, dlpath);\n\n    if (!(dl = dlopen(dlpath, RTLD_NOW)))\n    {\n      const char *errmsg;\n      int error_number= dlopen_errno;\n      DLERROR_GENERATE(errmsg, error_number);\n\n      DBUG_PRINT(\"error\",(\"dlopen of %s failed, error: %d (%s)\",\n                          udf->dl, error_number, errmsg));\n      my_error(ER_CANT_OPEN_LIBRARY, MYF(0),\n               udf->dl, error_number, errmsg);\n      goto err;\n    }\n    new_dl=1;\n  }\n  udf->dlhandle=dl;\n  {\n    char buf[NAME_LEN+16], *missing;\n    if ((missing= init_syms(udf, buf)))\n    {\n      my_error(ER_CANT_FIND_DL_ENTRY, MYF(0), missing);\n      goto err;\n    }\n  }\n  udf->name.str=strdup_root(&mem,udf->name.str);\n  udf->dl=strdup_root(&mem,udf->dl);\n  if (!(u_d=add_udf(&udf->name,udf->returns,udf->dl,udf->type)))\n    goto err;\n  u_d->dlhandle = dl;\n  u_d->func=udf->func;\n  u_d->func_init=udf->func_init;\n  u_d->func_deinit=udf->func_deinit;\n  u_d->func_clear=udf->func_clear;\n  u_d->func_add=udf->func_add;\n\n  /* create entry in mysql.func table */\n\n  tables.init_one_table(\"mysql\", 5, \"func\", 4, \"func\", TL_WRITE);\n  /* Allow creation of functions even if we can't open func table */\n  if (!(table = open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT)))\n    goto err;\n  table->use_all_columns();\n  restore_record(table, s->default_values);\t// Default values for fields\n  table->field[0]->store(u_d->name.str, u_d->name.length, system_charset_info);\n  table->field[1]->store((longlong) u_d->returns, TRUE);\n  table->field[2]->store(u_d->dl,(uint) strlen(u_d->dl), system_charset_info);\n  if (table->s->fields >= 4)\t\t\t// If not old func format\n    table->field[3]->store((longlong) u_d->type, TRUE);\n  error = table->file->ha_write_row(table->record[0]);\n\n  if (error)\n  {\n    my_error(ER_ERROR_ON_WRITE, MYF(0), \"mysql.func\", error);\n    del_udf(u_d);\n    goto err;\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n\n  /* Binlog the create function. */\n  if (write_bin_log(thd, TRUE, thd->query(), thd->query_length()))\n  {\n    /* Restore the state of binlog format */\n    DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n    if (save_binlog_row_based)\n      thd->set_current_stmt_binlog_format_row();\n    DBUG_RETURN(1);\n  }\n  /* Restore the state of binlog format */\n  DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n  if (save_binlog_row_based)\n    thd->set_current_stmt_binlog_format_row();\n  DBUG_RETURN(0);\n\n err:\n  if (new_dl)\n    dlclose(dl);\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  /* Restore the state of binlog format */\n  DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n  if (save_binlog_row_based)\n    thd->set_current_stmt_binlog_format_row();\n  DBUG_RETURN(1);\n}\n\n\nint mysql_drop_function(THD *thd,const LEX_STRING *udf_name)\n{\n  TABLE *table;\n  TABLE_LIST tables;\n  udf_func *udf;\n  char *exact_name_str;\n  uint exact_name_len;\n  bool save_binlog_row_based;\n  DBUG_ENTER(\"mysql_drop_function\");\n\n  if (!initialized)\n  {\n    if (opt_noacl)\n      my_error(ER_FUNCTION_NOT_DEFINED, MYF(0), udf_name->str);\n    else\n      my_message(ER_OUT_OF_RESOURCES, ER(ER_OUT_OF_RESOURCES), MYF(0));\n    DBUG_RETURN(1);\n  }\n\n  /* \n    Turn off row binlogging of this statement and use statement-based\n    so that all supporting tables are updated for DROP FUNCTION command.\n  */\n  if ((save_binlog_row_based= thd->is_current_stmt_binlog_format_row()))\n    thd->clear_current_stmt_binlog_format_row();\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  if (!(udf=(udf_func*) my_hash_search(&udf_hash,(uchar*) udf_name->str,\n                                       (uint) udf_name->length)))\n  {\n    my_error(ER_FUNCTION_NOT_DEFINED, MYF(0), udf_name->str);\n    goto err;\n  }\n  exact_name_str= udf->name.str;\n  exact_name_len= udf->name.length;\n  del_udf(udf);\n  /*\n    Close the handle if this was function that was found during boot or\n    CREATE FUNCTION and it's not in use by any other udf function\n  */\n  if (udf->dlhandle && !find_udf_dl(udf->dl))\n    dlclose(udf->dlhandle);\n\n  tables.init_one_table(\"mysql\", 5, \"func\", 4, \"func\", TL_WRITE);\n\n  if (!(table = open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT)))\n    goto err;\n  table->use_all_columns();\n  table->field[0]->store(exact_name_str, exact_name_len, &my_charset_bin);\n  if (!table->file->index_read_idx_map(table->record[0], 0,\n                                       (uchar*) table->field[0]->ptr,\n                                       HA_WHOLE_KEY,\n                                       HA_READ_KEY_EXACT))\n  {\n    int error;\n    if ((error = table->file->ha_delete_row(table->record[0])))\n      table->file->print_error(error, MYF(0));\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n\n  /*\n    Binlog the drop function. Keep the table open and locked\n    while binlogging, to avoid binlog inconsistency.\n  */\n  if (write_bin_log(thd, TRUE, thd->query(), thd->query_length()))\n  {\n    /* Restore the state of binlog format */\n    DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n    if (save_binlog_row_based)\n      thd->set_current_stmt_binlog_format_row();\n    DBUG_RETURN(1);\n  }\n  /* Restore the state of binlog format */\n  DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n  if (save_binlog_row_based)\n    thd->set_current_stmt_binlog_format_row();\n  DBUG_RETURN(0);\nerr:\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  /* Restore the state of binlog format */\n  DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n  if (save_binlog_row_based)\n    thd->set_current_stmt_binlog_format_row();\n  DBUG_RETURN(1);\n}\n\n#endif /* HAVE_DLOPEN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/sql/sql_plugin.cc": "/*\n   Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */\n\n#include \"sql_priv.h\"                         // SHOW_MY_BOOL\n#include \"unireg.h\"\n#include \"my_global.h\"                       // REQUIRED by m_string.h\n#include \"sql_class.h\"                          // set_var.h: THD\n#include \"sys_vars_shared.h\"\n#include \"sql_locale.h\"\n#include \"sql_plugin.h\"\n#include \"sql_parse.h\"          // check_table_access\n#include \"sql_base.h\"                           // close_mysql_tables\n#include \"key.h\"                                // key_copy\n#include \"sql_show.h\"           // remove_status_vars, add_status_vars\n#include \"strfunc.h\"            // find_set\n#include \"sql_acl.h\"                       // *_ACL\n#include \"records.h\"          // init_read_record, end_read_record\n#include <my_pthread.h>\n#include <my_getopt.h>\n#include \"sql_audit.h\"\n#include <mysql/plugin_auth.h>\n#include \"lock.h\"                               // MYSQL_LOCK_IGNORE_TIMEOUT\n#include \"debug_sync.h\"\n#define REPORT_TO_LOG  1\n#define REPORT_TO_USER 2\n\nextern struct st_mysql_plugin *mysql_optional_plugins[];\nextern struct st_mysql_plugin *mysql_mandatory_plugins[];\n\n/**\n  @note The order of the enumeration is critical.\n  @see construct_options\n*/\nconst char *global_plugin_typelib_names[]=\n  { \"OFF\", \"ON\", \"FORCE\", \"FORCE_PLUS_PERMANENT\", NULL };\nstatic TYPELIB global_plugin_typelib=\n  { array_elements(global_plugin_typelib_names)-1,\n    \"\", global_plugin_typelib_names, NULL };\n\n\nchar *opt_plugin_load= NULL;\nchar *opt_plugin_dir_ptr;\nchar opt_plugin_dir[FN_REFLEN];\n/*\n  When you ad a new plugin type, add both a string and make sure that the\n  init and deinit array are correctly updated.\n*/\nconst LEX_STRING plugin_type_names[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  { C_STRING_WITH_LEN(\"UDF\") },\n  { C_STRING_WITH_LEN(\"STORAGE ENGINE\") },\n  { C_STRING_WITH_LEN(\"FTPARSER\") },\n  { C_STRING_WITH_LEN(\"DAEMON\") },\n  { C_STRING_WITH_LEN(\"INFORMATION SCHEMA\") },\n  { C_STRING_WITH_LEN(\"AUDIT\") },\n  { C_STRING_WITH_LEN(\"REPLICATION\") },\n  { C_STRING_WITH_LEN(\"AUTHENTICATION\") }\n};\n\nextern int initialize_schema_table(st_plugin_int *plugin);\nextern int finalize_schema_table(st_plugin_int *plugin);\n\nextern int initialize_audit_plugin(st_plugin_int *plugin);\nextern int finalize_audit_plugin(st_plugin_int *plugin);\n\n/*\n  The number of elements in both plugin_type_initialize and\n  plugin_type_deinitialize should equal to the number of plugins\n  defined.\n*/\nplugin_type_init plugin_type_initialize[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0,ha_initialize_handlerton,0,0,initialize_schema_table,\n  initialize_audit_plugin,0,0\n};\n\nplugin_type_init plugin_type_deinitialize[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0,ha_finalize_handlerton,0,0,finalize_schema_table,\n  finalize_audit_plugin,0,0\n};\n\n#ifdef HAVE_DLOPEN\nstatic const char *plugin_interface_version_sym=\n                   \"_mysql_plugin_interface_version_\";\nstatic const char *sizeof_st_plugin_sym=\n                   \"_mysql_sizeof_struct_st_plugin_\";\nstatic const char *plugin_declarations_sym= \"_mysql_plugin_declarations_\";\nstatic int min_plugin_interface_version= MYSQL_PLUGIN_INTERFACE_VERSION & ~0xFF;\n#endif\n\n/* Note that 'int version' must be the first field of every plugin\n   sub-structure (plugin->info).\n*/\nstatic int min_plugin_info_interface_version[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0x0000,\n  MYSQL_HANDLERTON_INTERFACE_VERSION,\n  MYSQL_FTPARSER_INTERFACE_VERSION,\n  MYSQL_DAEMON_INTERFACE_VERSION,\n  MYSQL_INFORMATION_SCHEMA_INTERFACE_VERSION,\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  MYSQL_REPLICATION_INTERFACE_VERSION,\n  MYSQL_AUTHENTICATION_INTERFACE_VERSION\n};\nstatic int cur_plugin_info_interface_version[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0x0000, /* UDF: not implemented */\n  MYSQL_HANDLERTON_INTERFACE_VERSION,\n  MYSQL_FTPARSER_INTERFACE_VERSION,\n  MYSQL_DAEMON_INTERFACE_VERSION,\n  MYSQL_INFORMATION_SCHEMA_INTERFACE_VERSION,\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  MYSQL_REPLICATION_INTERFACE_VERSION,\n  MYSQL_AUTHENTICATION_INTERFACE_VERSION\n};\n\n/* support for Services */\n\n#include \"sql_plugin_services.h\"\n\n/*\n  A mutex LOCK_plugin_delete must be acquired before calling plugin_del\n  function. \n*/\nmysql_mutex_t LOCK_plugin_delete;\n\n/*\n  A mutex LOCK_plugin must be acquired before accessing the\n  following variables/structures.\n  We are always manipulating ref count, so a rwlock here is unneccessary.\n*/\nmysql_mutex_t LOCK_plugin;\nstatic DYNAMIC_ARRAY plugin_dl_array;\nstatic DYNAMIC_ARRAY plugin_array;\nstatic HASH plugin_hash[MYSQL_MAX_PLUGIN_TYPE_NUM];\nstatic bool reap_needed= false;\nstatic int plugin_array_version=0;\n\nstatic bool initialized= 0;\n\n/*\n  write-lock on LOCK_system_variables_hash is required before modifying\n  the following variables/structures\n*/\nstatic MEM_ROOT plugin_mem_root;\nstatic uint global_variables_dynamic_size= 0;\nstatic HASH bookmark_hash;\n\n\n/*\n  hidden part of opaque value passed to variable check functions.\n  Used to provide a object-like structure to non C++ consumers.\n*/\nstruct st_item_value_holder : public st_mysql_value\n{\n  Item *item;\n};\n\n\n/*\n  stored in bookmark_hash, this structure is never removed from the\n  hash and is used to mark a single offset for a thd local variable\n  even if plugins have been uninstalled and reinstalled, repeatedly.\n  This structure is allocated from plugin_mem_root.\n\n  The key format is as follows:\n    1 byte         - variable type code\n    name_len bytes - variable name\n    '\\0'           - end of key\n*/\nstruct st_bookmark\n{\n  uint name_len;\n  int offset;\n  uint version;\n  char key[1];\n};\n\n\n/*\n  skeleton of a plugin variable - portion of structure common to all.\n*/\nstruct st_mysql_sys_var\n{\n  MYSQL_PLUGIN_VAR_HEADER;\n};\n\nstatic SHOW_TYPE pluginvar_show_type(st_mysql_sys_var *plugin_var);\n\n\n/*\n  sys_var class for access to all plugin variables visible to the user\n*/\nclass sys_var_pluginvar: public sys_var\n{\npublic:\n  struct st_plugin_int *plugin;\n  struct st_mysql_sys_var *plugin_var;\n  /**\n    variable name from whatever is hard-coded in the plugin source\n    and doesn't have pluginname- prefix is replaced by an allocated name\n    with a plugin prefix. When plugin is uninstalled we need to restore the\n    pointer to point to the hard-coded value, because plugin may be\n    installed/uninstalled many times without reloading the shared object.\n  */\n  const char *orig_pluginvar_name;\n\n  static void *operator new(size_t size, MEM_ROOT *mem_root)\n  { return (void*) alloc_root(mem_root, size); }\n  static void operator delete(void *ptr_arg,size_t size)\n  { TRASH(ptr_arg, size); }\n\n  sys_var_pluginvar(sys_var_chain *chain, const char *name_arg,\n                    struct st_mysql_sys_var *plugin_var_arg)\n    :sys_var(chain, name_arg, plugin_var_arg->comment,\n             (plugin_var_arg->flags & PLUGIN_VAR_THDLOCAL ? SESSION : GLOBAL) |\n             (plugin_var_arg->flags & PLUGIN_VAR_READONLY ? READONLY : 0),\n             0, -1, NO_ARG, pluginvar_show_type(plugin_var_arg), 0, 0,\n             VARIABLE_NOT_IN_BINLOG, NULL, NULL, NULL, PARSE_NORMAL),\n    plugin_var(plugin_var_arg), orig_pluginvar_name(plugin_var_arg->name)\n  { plugin_var->name= name_arg; }\n  sys_var_pluginvar *cast_pluginvar() { return this; }\n  bool check_update_type(Item_result type);\n  SHOW_TYPE show_type();\n  uchar* real_value_ptr(THD *thd, enum_var_type type);\n  TYPELIB* plugin_var_typelib(void);\n  uchar* do_value_ptr(THD *thd, enum_var_type type, LEX_STRING *base);\n  uchar* session_value_ptr(THD *thd, LEX_STRING *base)\n  { return do_value_ptr(thd, OPT_SESSION, base); }\n  uchar* global_value_ptr(THD *thd, LEX_STRING *base)\n  { return do_value_ptr(thd, OPT_GLOBAL, base); }\n  bool do_check(THD *thd, set_var *var);\n  virtual void session_save_default(THD *thd, set_var *var) {}\n  virtual void global_save_default(THD *thd, set_var *var) {}\n  bool session_update(THD *thd, set_var *var);\n  bool global_update(THD *thd, set_var *var);\n};\n\n\n/* prototypes */\nstatic void plugin_load(MEM_ROOT *tmp_root, int *argc, char **argv);\nstatic bool plugin_load_list(MEM_ROOT *tmp_root, int *argc, char **argv,\n                             const char *list);\nstatic int test_plugin_options(MEM_ROOT *, struct st_plugin_int *,\n                               int *, char **);\nstatic bool register_builtin(struct st_mysql_plugin *, struct st_plugin_int *,\n                             struct st_plugin_int **);\nstatic void unlock_variables(THD *thd, struct system_variables *vars);\nstatic void cleanup_variables(THD *thd, struct system_variables *vars);\nstatic void plugin_vars_free_values(sys_var *vars);\nstatic bool plugin_var_memalloc_session_update(THD *thd,\n                                               struct st_mysql_sys_var *var,\n                                               char **dest, const char *value);\nstatic bool plugin_var_memalloc_global_update(THD *thd,\n                                              struct st_mysql_sys_var *var,\n                                              char **dest, const char *value);\nstatic void plugin_var_memalloc_free(struct system_variables *vars);\nstatic void restore_pluginvar_names(sys_var *first);\nstatic void plugin_opt_set_limits(struct my_option *,\n                                  const struct st_mysql_sys_var *);\n#define my_intern_plugin_lock(A,B) intern_plugin_lock(A,B)\n#define my_intern_plugin_lock_ci(A,B) intern_plugin_lock(A,B)\nstatic plugin_ref intern_plugin_lock(LEX *lex, plugin_ref plugin);\nstatic void intern_plugin_unlock(LEX *lex, plugin_ref plugin);\nstatic void reap_plugins(void);\n\nstatic void report_error(int where_to, uint error, ...)\n{\n  va_list args;\n  if (where_to & REPORT_TO_USER)\n  {\n    va_start(args, error);\n    my_printv_error(error, ER(error), MYF(0), args);\n    va_end(args);\n  }\n  if (where_to & REPORT_TO_LOG)\n  {\n    va_start(args, error);\n    error_log_print(ERROR_LEVEL, ER_DEFAULT(error), args);\n    va_end(args);\n  }\n}\n\n/**\n   Check if the provided path is valid in the sense that it does cause\n   a relative reference outside the directory.\n\n   @note Currently, this function only check if there are any\n   characters in FN_DIRSEP in the string, but it might change in the\n   future.\n\n   @code\n   check_valid_path(\"../foo.so\") -> true\n   check_valid_path(\"foo.so\") -> false\n   @endcode\n */\nbool check_valid_path(const char *path, size_t len)\n{\n  size_t prefix= my_strcspn(files_charset_info, path, path + len, FN_DIRSEP);\n  return  prefix < len;\n}\n\n\n/****************************************************************************\n  Value type thunks, allows the C world to play in the C++ world\n****************************************************************************/\n\nstatic int item_value_type(struct st_mysql_value *value)\n{\n  switch (((st_item_value_holder*)value)->item->result_type()) {\n  case INT_RESULT:\n    return MYSQL_VALUE_TYPE_INT;\n  case REAL_RESULT:\n    return MYSQL_VALUE_TYPE_REAL;\n  default:\n    return MYSQL_VALUE_TYPE_STRING;\n  }\n}\n\nstatic const char *item_val_str(struct st_mysql_value *value,\n                                char *buffer, int *length)\n{\n  String str(buffer, *length, system_charset_info), *res;\n  if (!(res= ((st_item_value_holder*)value)->item->val_str(&str)))\n    return NULL;\n  *length= res->length();\n  if (res->c_ptr_quick() == buffer)\n    return buffer;\n\n  /*\n    Lets be nice and create a temporary string since the\n    buffer was too small\n  */\n  return current_thd->strmake(res->c_ptr_quick(), res->length());\n}\n\n\nstatic int item_val_int(struct st_mysql_value *value, long long *buf)\n{\n  Item *item= ((st_item_value_holder*)value)->item;\n  *buf= item->val_int();\n  if (item->is_null())\n    return 1;\n  return 0;\n}\n\nstatic int item_is_unsigned(struct st_mysql_value *value)\n{\n  Item *item= ((st_item_value_holder*)value)->item;\n  return item->unsigned_flag;\n}\n\nstatic int item_val_real(struct st_mysql_value *value, double *buf)\n{\n  Item *item= ((st_item_value_holder*)value)->item;\n  *buf= item->val_real();\n  if (item->is_null())\n    return 1;\n  return 0;\n}\n\n\n/****************************************************************************\n  Plugin support code\n****************************************************************************/\n\n#ifdef HAVE_DLOPEN\n\nstatic struct st_plugin_dl *plugin_dl_find(const LEX_STRING *dl)\n{\n  uint i;\n  struct st_plugin_dl *tmp;\n  DBUG_ENTER(\"plugin_dl_find\");\n  for (i= 0; i < plugin_dl_array.elements; i++)\n  {\n    tmp= *dynamic_element(&plugin_dl_array, i, struct st_plugin_dl **);\n    if (tmp->ref_count &&\n        ! my_strnncoll(files_charset_info,\n                       (const uchar *)dl->str, dl->length,\n                       (const uchar *)tmp->dl.str, tmp->dl.length))\n      DBUG_RETURN(tmp);\n  }\n  DBUG_RETURN(0);\n}\n\n\nstatic st_plugin_dl *plugin_dl_insert_or_reuse(struct st_plugin_dl *plugin_dl)\n{\n  uint i;\n  struct st_plugin_dl *tmp;\n  DBUG_ENTER(\"plugin_dl_insert_or_reuse\");\n  for (i= 0; i < plugin_dl_array.elements; i++)\n  {\n    tmp= *dynamic_element(&plugin_dl_array, i, struct st_plugin_dl **);\n    if (! tmp->ref_count)\n    {\n      memcpy(tmp, plugin_dl, sizeof(struct st_plugin_dl));\n      DBUG_RETURN(tmp);\n    }\n  }\n  if (insert_dynamic(&plugin_dl_array, (uchar*)&plugin_dl))\n    DBUG_RETURN(0);\n  tmp= *dynamic_element(&plugin_dl_array, plugin_dl_array.elements - 1,\n                        struct st_plugin_dl **)=\n      (struct st_plugin_dl *) memdup_root(&plugin_mem_root, (uchar*)plugin_dl,\n                                           sizeof(struct st_plugin_dl));\n  DBUG_RETURN(tmp);\n}\n#endif /* HAVE_DLOPEN */\n\n\nstatic inline void free_plugin_mem(struct st_plugin_dl *p)\n{\n#ifdef HAVE_DLOPEN\n  if (p->handle)\n    dlclose(p->handle);\n#endif\n  my_free(p->dl.str);\n  if (p->version != MYSQL_PLUGIN_INTERFACE_VERSION)\n    my_free(p->plugins);\n}\n\n\nstatic st_plugin_dl *plugin_dl_add(const LEX_STRING *dl, int report)\n{\n#ifdef HAVE_DLOPEN\n  char dlpath[FN_REFLEN];\n  uint plugin_dir_len, dummy_errors, dlpathlen, i;\n  struct st_plugin_dl *tmp, plugin_dl;\n  void *sym;\n  DBUG_ENTER(\"plugin_dl_add\");\n  DBUG_PRINT(\"enter\", (\"dl->str: '%s', dl->length: %d\",\n                       dl->str, (int) dl->length));\n  plugin_dir_len= strlen(opt_plugin_dir);\n  /*\n    Ensure that the dll doesn't have a path.\n    This is done to ensure that only approved libraries from the\n    plugin directory are used (to make this even remotely secure).\n  */\n  if (check_valid_path(dl->str, dl->length) ||\n      check_string_char_length((LEX_STRING *) dl, \"\", NAME_CHAR_LEN,\n                               system_charset_info, 1) ||\n      plugin_dir_len + dl->length + 1 >= FN_REFLEN)\n  {\n    report_error(report, ER_UDF_NO_PATHS);\n    DBUG_RETURN(0);\n  }\n  /* If this dll is already loaded just increase ref_count. */\n  if ((tmp= plugin_dl_find(dl)))\n  {\n    tmp->ref_count++;\n    DBUG_RETURN(tmp);\n  }\n  bzero(&plugin_dl, sizeof(plugin_dl));\n  /* Compile dll path */\n  dlpathlen=\n    strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", dl->str, NullS) -\n    dlpath;\n  (void) unpack_filename(dlpath, dlpath);\n  plugin_dl.ref_count= 1;\n  /* Open new dll handle */\n  if (!(plugin_dl.handle= dlopen(dlpath, RTLD_NOW)))\n  {\n    const char *errmsg;\n    int error_number= dlopen_errno;\n    DLERROR_GENERATE(errmsg, error_number);\n\n    if (!strncmp(dlpath, errmsg, dlpathlen))\n    { // if errmsg starts from dlpath, trim this prefix.\n      errmsg+=dlpathlen;\n      if (*errmsg == ':') errmsg++;\n      if (*errmsg == ' ') errmsg++;\n    }\n    report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, error_number, errmsg);\n    DBUG_RETURN(0);\n  }\n  /* Determine interface version */\n  if (!(sym= dlsym(plugin_dl.handle, plugin_interface_version_sym)))\n  {\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_CANT_FIND_DL_ENTRY, plugin_interface_version_sym);\n    DBUG_RETURN(0);\n  }\n  plugin_dl.version= *(int *)sym;\n  /* Versioning */\n  if (plugin_dl.version < min_plugin_interface_version ||\n      (plugin_dl.version >> 8) > (MYSQL_PLUGIN_INTERFACE_VERSION >> 8))\n  {\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, 0,\n                 \"plugin interface version mismatch\");\n    DBUG_RETURN(0);\n  }\n\n  /* link the services in */\n  for (i= 0; i < array_elements(list_of_services); i++)\n  {\n    if ((sym= dlsym(plugin_dl.handle, list_of_services[i].name)))\n    {\n      uint ver= (uint)(intptr)*(void**)sym;\n      if (ver > list_of_services[i].version ||\n        (ver >> 8) < (list_of_services[i].version >> 8))\n      {\n        char buf[MYSQL_ERRMSG_SIZE];\n        my_snprintf(buf, sizeof(buf),\n                    \"service '%s' interface version mismatch\",\n                    list_of_services[i].name);\n        report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, 0, buf);\n        DBUG_RETURN(0);\n      }\n      *(void**)sym= list_of_services[i].service;\n    }\n  }\n\n  /* Find plugin declarations */\n  if (!(sym= dlsym(plugin_dl.handle, plugin_declarations_sym)))\n  {\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_CANT_FIND_DL_ENTRY, plugin_declarations_sym);\n    DBUG_RETURN(0);\n  }\n\n  if (plugin_dl.version != MYSQL_PLUGIN_INTERFACE_VERSION)\n  {\n    uint sizeof_st_plugin;\n    struct st_mysql_plugin *old, *cur;\n    char *ptr= (char *)sym;\n\n    if ((sym= dlsym(plugin_dl.handle, sizeof_st_plugin_sym)))\n      sizeof_st_plugin= *(int *)sym;\n    else\n    {\n#ifdef ERROR_ON_NO_SIZEOF_PLUGIN_SYMBOL\n      report_error(report, ER_CANT_FIND_DL_ENTRY, sizeof_st_plugin_sym);\n      DBUG_RETURN(0);\n#else\n      /*\n        When the following assert starts failing, we'll have to switch\n        to the upper branch of the #ifdef\n      */\n      DBUG_ASSERT(min_plugin_interface_version == 0);\n      sizeof_st_plugin= (int)offsetof(struct st_mysql_plugin, version);\n#endif\n    }\n\n    /*\n      What's the purpose of this loop? If the goal is to catch a\n      missing 0 record at the end of a list, it will fail miserably\n      since the compiler is likely to optimize this away. /Matz\n     */\n    for (i= 0;\n         ((struct st_mysql_plugin *)(ptr+i*sizeof_st_plugin))->info;\n         i++)\n      /* no op */;\n\n    cur= (struct st_mysql_plugin*)\n      my_malloc((i+1)*sizeof(struct st_mysql_plugin), MYF(MY_ZEROFILL|MY_WME));\n    if (!cur)\n    {\n      free_plugin_mem(&plugin_dl);\n      report_error(report, ER_OUTOFMEMORY,\n                   static_cast<int>(plugin_dl.dl.length));\n      DBUG_RETURN(0);\n    }\n    /*\n      All st_plugin fields not initialized in the plugin explicitly, are\n      set to 0. It matches C standard behaviour for struct initializers that\n      have less values than the struct definition.\n    */\n    for (i=0;\n         (old=(struct st_mysql_plugin *)(ptr+i*sizeof_st_plugin))->info;\n         i++)\n      memcpy(cur+i, old, min(sizeof(cur[i]), sizeof_st_plugin));\n\n    sym= cur;\n  }\n  plugin_dl.plugins= (struct st_mysql_plugin *)sym;\n\n  /*\n    If report is REPORT_TO_USER, we were called from\n    mysql_install_plugin. Otherwise, we are called directly or\n    indirectly from plugin_init.\n   */\n  if (report == REPORT_TO_USER)\n  {\n    st_mysql_plugin *plugin= plugin_dl.plugins;\n    for ( ; plugin->info ; ++plugin)\n      if (plugin->flags & PLUGIN_OPT_NO_INSTALL)\n      {\n        report_error(report, ER_PLUGIN_NO_INSTALL, plugin->name);\n        free_plugin_mem(&plugin_dl);\n        DBUG_RETURN(0);\n   }\n  }\n\n  /* Duplicate and convert dll name */\n  plugin_dl.dl.length= dl->length * files_charset_info->mbmaxlen + 1;\n  if (! (plugin_dl.dl.str= (char*) my_malloc(plugin_dl.dl.length, MYF(0))))\n  {\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_OUTOFMEMORY,\n                 static_cast<int>(plugin_dl.dl.length));\n    DBUG_RETURN(0);\n  }\n  plugin_dl.dl.length= copy_and_convert(plugin_dl.dl.str, plugin_dl.dl.length,\n    files_charset_info, dl->str, dl->length, system_charset_info,\n    &dummy_errors);\n  plugin_dl.dl.str[plugin_dl.dl.length]= 0;\n  /* Add this dll to array */\n  if (! (tmp= plugin_dl_insert_or_reuse(&plugin_dl)))\n  {\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_OUTOFMEMORY,\n                 static_cast<int>(sizeof(struct st_plugin_dl)));\n    DBUG_RETURN(0);\n  }\n  DBUG_RETURN(tmp);\n#else\n  DBUG_ENTER(\"plugin_dl_add\");\n  report_error(report, ER_FEATURE_DISABLED, \"plugin\", \"HAVE_DLOPEN\");\n  DBUG_RETURN(0);\n#endif\n}\n\n\nstatic void plugin_dl_del(const LEX_STRING *dl)\n{\n#ifdef HAVE_DLOPEN\n  uint i;\n  DBUG_ENTER(\"plugin_dl_del\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  for (i= 0; i < plugin_dl_array.elements; i++)\n  {\n    struct st_plugin_dl *tmp= *dynamic_element(&plugin_dl_array, i,\n                                               struct st_plugin_dl **);\n    if (tmp->ref_count &&\n        ! my_strnncoll(files_charset_info,\n                       (const uchar *)dl->str, dl->length,\n                       (const uchar *)tmp->dl.str, tmp->dl.length))\n    {\n      /* Do not remove this element, unless no other plugin uses this dll. */\n      if (! --tmp->ref_count)\n      {\n        free_plugin_mem(tmp);\n        bzero(tmp, sizeof(struct st_plugin_dl));\n      }\n      break;\n    }\n  }\n  DBUG_VOID_RETURN;\n#endif\n}\n\n\nstatic struct st_plugin_int *plugin_find_internal(const LEX_STRING *name, int type)\n{\n  uint i;\n  DBUG_ENTER(\"plugin_find_internal\");\n  if (! initialized)\n    DBUG_RETURN(0);\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (type == MYSQL_ANY_PLUGIN)\n  {\n    for (i= 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n    {\n      struct st_plugin_int *plugin= (st_plugin_int *)\n        my_hash_search(&plugin_hash[i], (const uchar *)name->str, name->length);\n      if (plugin)\n        DBUG_RETURN(plugin);\n    }\n  }\n  else\n    DBUG_RETURN((st_plugin_int *)\n        my_hash_search(&plugin_hash[type], (const uchar *)name->str,\n                       name->length));\n  DBUG_RETURN(0);\n}\n\n\nstatic SHOW_COMP_OPTION plugin_status(const LEX_STRING *name, int type)\n{\n  SHOW_COMP_OPTION rc= SHOW_OPTION_NO;\n  struct st_plugin_int *plugin;\n  DBUG_ENTER(\"plugin_is_ready\");\n  mysql_mutex_lock(&LOCK_plugin);\n  if ((plugin= plugin_find_internal(name, type)))\n  {\n    rc= SHOW_OPTION_DISABLED;\n    if (plugin->state == PLUGIN_IS_READY)\n      rc= SHOW_OPTION_YES;\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\n\nbool plugin_is_ready(const LEX_STRING *name, int type)\n{\n  bool rc= FALSE;\n  if (plugin_status(name, type) == SHOW_OPTION_YES)\n    rc= TRUE;\n  return rc;\n}\n\n\nSHOW_COMP_OPTION plugin_status(const char *name, size_t len, int type)\n{\n  LEX_STRING plugin_name= { (char *) name, len };\n  return plugin_status(&plugin_name, type);\n}\n\n\nstatic plugin_ref intern_plugin_lock(LEX *lex, plugin_ref rc)\n{\n  st_plugin_int *pi= plugin_ref_to_int(rc);\n  DBUG_ENTER(\"intern_plugin_lock\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (pi->state & (PLUGIN_IS_READY | PLUGIN_IS_UNINITIALIZED))\n  {\n    plugin_ref plugin;\n#ifdef DBUG_OFF\n    /* built-in plugins don't need ref counting */\n    if (!pi->plugin_dl)\n      DBUG_RETURN(pi);\n\n    plugin= pi;\n#else\n    /*\n      For debugging, we do an additional malloc which allows the\n      memory manager and/or valgrind to track locked references and\n      double unlocks to aid resolving reference counting problems.\n    */\n    if (!(plugin= (plugin_ref) my_malloc(sizeof(pi), MYF(MY_WME))))\n      DBUG_RETURN(NULL);\n\n    *plugin= pi;\n#endif\n    pi->ref_count++;\n    DBUG_PRINT(\"info\",(\"thd: 0x%lx, plugin: \\\"%s\\\", ref_count: %d\",\n                       (long) current_thd, pi->name.str, pi->ref_count));\n\n    if (lex)\n      insert_dynamic(&lex->plugins, (uchar*)&plugin);\n    DBUG_RETURN(plugin);\n  }\n  DBUG_RETURN(NULL);\n}\n\n\nplugin_ref plugin_lock(THD *thd, plugin_ref *ptr)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  plugin_ref rc;\n  DBUG_ENTER(\"plugin_lock\");\n  mysql_mutex_lock(&LOCK_plugin);\n  rc= my_intern_plugin_lock_ci(lex, *ptr);\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\n\nplugin_ref plugin_lock_by_name(THD *thd, const LEX_STRING *name, int type)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  plugin_ref rc= NULL;\n  st_plugin_int *plugin;\n  DBUG_ENTER(\"plugin_lock_by_name\");\n  mysql_mutex_lock(&LOCK_plugin);\n  if ((plugin= plugin_find_internal(name, type)))\n    rc= my_intern_plugin_lock_ci(lex, plugin_int_to_ref(plugin));\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\n\nstatic st_plugin_int *plugin_insert_or_reuse(struct st_plugin_int *plugin)\n{\n  uint i;\n  struct st_plugin_int *tmp;\n  DBUG_ENTER(\"plugin_insert_or_reuse\");\n  for (i= 0; i < plugin_array.elements; i++)\n  {\n    tmp= *dynamic_element(&plugin_array, i, struct st_plugin_int **);\n    if (tmp->state == PLUGIN_IS_FREED)\n    {\n      memcpy(tmp, plugin, sizeof(struct st_plugin_int));\n      DBUG_RETURN(tmp);\n    }\n  }\n  if (insert_dynamic(&plugin_array, (uchar*)&plugin))\n    DBUG_RETURN(0);\n  tmp= *dynamic_element(&plugin_array, plugin_array.elements - 1,\n                        struct st_plugin_int **)=\n       (struct st_plugin_int *) memdup_root(&plugin_mem_root, (uchar*)plugin,\n                                            sizeof(struct st_plugin_int));\n  DBUG_RETURN(tmp);\n}\n\n\n/*\n  NOTE\n    Requires that a write-lock is held on LOCK_system_variables_hash\n*/\nstatic bool plugin_add(MEM_ROOT *tmp_root,\n                       const LEX_STRING *name, const LEX_STRING *dl,\n                       int *argc, char **argv, int report)\n{\n  struct st_plugin_int tmp;\n  struct st_mysql_plugin *plugin;\n  DBUG_ENTER(\"plugin_add\");\n  if (plugin_find_internal(name, MYSQL_ANY_PLUGIN))\n  {\n    report_error(report, ER_UDF_EXISTS, name->str);\n    DBUG_RETURN(TRUE);\n  }\n  /* Clear the whole struct to catch future extensions. */\n  bzero((char*) &tmp, sizeof(tmp));\n  if (! (tmp.plugin_dl= plugin_dl_add(dl, report)))\n    DBUG_RETURN(TRUE);\n  /* Find plugin by name */\n  for (plugin= tmp.plugin_dl->plugins; plugin->info; plugin++)\n  {\n    uint name_len= strlen(plugin->name);\n    if (plugin->type >= 0 && plugin->type < MYSQL_MAX_PLUGIN_TYPE_NUM &&\n        ! my_strnncoll(system_charset_info,\n                       (const uchar *)name->str, name->length,\n                       (const uchar *)plugin->name,\n                       name_len))\n    {\n      struct st_plugin_int *tmp_plugin_ptr;\n      if (*(int*)plugin->info <\n          min_plugin_info_interface_version[plugin->type] ||\n          ((*(int*)plugin->info) >> 8) >\n          (cur_plugin_info_interface_version[plugin->type] >> 8))\n      {\n        char buf[256];\n        strxnmov(buf, sizeof(buf) - 1, \"API version for \",\n                 plugin_type_names[plugin->type].str,\n                 \" plugin is too different\", NullS);\n        report_error(report, ER_CANT_OPEN_LIBRARY, dl->str, 0, buf);\n        goto err;\n      }\n      tmp.plugin= plugin;\n      tmp.name.str= (char *)plugin->name;\n      tmp.name.length= name_len;\n      tmp.ref_count= 0;\n      tmp.state= PLUGIN_IS_UNINITIALIZED;\n      tmp.load_option= PLUGIN_ON;\n      if (test_plugin_options(tmp_root, &tmp, argc, argv))\n        tmp.state= PLUGIN_IS_DISABLED;\n\n      if ((tmp_plugin_ptr= plugin_insert_or_reuse(&tmp)))\n      {\n        plugin_array_version++;\n        if (!my_hash_insert(&plugin_hash[plugin->type], (uchar*)tmp_plugin_ptr))\n        {\n          init_alloc_root(&tmp_plugin_ptr->mem_root, 4096, 4096);\n          DBUG_RETURN(FALSE);\n        }\n        tmp_plugin_ptr->state= PLUGIN_IS_FREED;\n      }\n      mysql_del_sys_var_chain(tmp.system_vars);\n      restore_pluginvar_names(tmp.system_vars);\n      goto err;\n\n      /* plugin was disabled */\n      plugin_dl_del(dl);\n      DBUG_RETURN(FALSE);\n    }\n  }\n  report_error(report, ER_CANT_FIND_DL_ENTRY, name->str);\nerr:\n  plugin_dl_del(dl);\n  DBUG_RETURN(TRUE);\n}\n\n\nstatic void plugin_deinitialize(struct st_plugin_int *plugin, bool ref_check)\n{\n  /*\n    we don't want to hold the LOCK_plugin mutex as it may cause\n    deinitialization to deadlock if plugins have worker threads\n    with plugin locks\n  */\n  mysql_mutex_assert_not_owner(&LOCK_plugin);\n\n  if (plugin->plugin->status_vars)\n  {\n#ifdef FIX_LATER\n    /**\n      @todo\n      unfortunately, status variables were introduced without a\n      pluginname_ namespace, that is pluginname_ was not added automatically\n      to status variable names. It should be fixed together with the next\n      incompatible API change.\n    */\n    SHOW_VAR array[2]= {\n      {plugin->plugin->name, (char*)plugin->plugin->status_vars, SHOW_ARRAY},\n      {0, 0, SHOW_UNDEF}\n    };\n    remove_status_vars(array);\n#else\n    remove_status_vars(plugin->plugin->status_vars);\n#endif /* FIX_LATER */\n  }\n\n  if (plugin_type_deinitialize[plugin->plugin->type])\n  {\n    if ((*plugin_type_deinitialize[plugin->plugin->type])(plugin))\n    {\n      sql_print_error(\"Plugin '%s' of type %s failed deinitialization\",\n                      plugin->name.str, plugin_type_names[plugin->plugin->type].str);\n    }\n  }\n  else if (plugin->plugin->deinit)\n  {\n    DBUG_PRINT(\"info\", (\"Deinitializing plugin: '%s'\", plugin->name.str));\n    if (plugin->plugin->deinit(plugin))\n    {\n      DBUG_PRINT(\"warning\", (\"Plugin '%s' deinit function returned error.\",\n                             plugin->name.str));\n    }\n  }\n  plugin->state= PLUGIN_IS_UNINITIALIZED;\n\n  /*\n    We do the check here because NDB has a worker THD which doesn't\n    exit until NDB is shut down.\n  */\n  if (ref_check && plugin->ref_count)\n    sql_print_error(\"Plugin '%s' has ref_count=%d after deinitialization.\",\n                    plugin->name.str, plugin->ref_count);\n}\n\nstatic void plugin_del(struct st_plugin_int *plugin)\n{\n  DBUG_ENTER(\"plugin_del(plugin)\");\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  mysql_mutex_assert_owner(&LOCK_plugin_delete);\n  /* Free allocated strings before deleting the plugin. */\n  mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n  mysql_del_sys_var_chain(plugin->system_vars);\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  restore_pluginvar_names(plugin->system_vars);\n  plugin_vars_free_values(plugin->system_vars);\n  my_hash_delete(&plugin_hash[plugin->plugin->type], (uchar*)plugin);\n  if (plugin->plugin_dl)\n    plugin_dl_del(&plugin->plugin_dl->dl);\n  plugin->state= PLUGIN_IS_FREED;\n  plugin_array_version++;\n  free_root(&plugin->mem_root, MYF(0));\n  DBUG_VOID_RETURN;\n}\n\nstatic void reap_plugins(void)\n{\n  uint count, idx;\n  struct st_plugin_int *plugin, **reap, **list;\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!reap_needed)\n    return;\n\n  reap_needed= false;\n  count= plugin_array.elements;\n  reap= (struct st_plugin_int **)my_alloca(sizeof(plugin)*(count+1));\n  *(reap++)= NULL;\n\n  for (idx= 0; idx < count; idx++)\n  {\n    plugin= *dynamic_element(&plugin_array, idx, struct st_plugin_int **);\n    if (plugin->state == PLUGIN_IS_DELETED && !plugin->ref_count)\n    {\n      /* change the status flag to prevent reaping by another thread */\n      plugin->state= PLUGIN_IS_DYING;\n      *(reap++)= plugin;\n    }\n  }\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  list= reap;\n  while ((plugin= *(--list)))\n    plugin_deinitialize(plugin, true);\n\n  mysql_mutex_lock(&LOCK_plugin_delete);\n  mysql_mutex_lock(&LOCK_plugin);\n\n  while ((plugin= *(--reap)))\n    plugin_del(plugin);\n\n  mysql_mutex_unlock(&LOCK_plugin_delete);\n\n  my_afree(reap);\n}\n\nstatic void intern_plugin_unlock(LEX *lex, plugin_ref plugin)\n{\n  int i;\n  st_plugin_int *pi;\n  DBUG_ENTER(\"intern_plugin_unlock\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!plugin)\n    DBUG_VOID_RETURN;\n\n  pi= plugin_ref_to_int(plugin);\n\n#ifdef DBUG_OFF\n  if (!pi->plugin_dl)\n    DBUG_VOID_RETURN;\n#else\n  my_free(plugin);\n#endif\n\n  DBUG_PRINT(\"info\",(\"unlocking plugin, name= %s, ref_count= %d\",\n                     pi->name.str, pi->ref_count));\n  if (lex)\n  {\n    /*\n      Remove one instance of this plugin from the use list.\n      We are searching backwards so that plugins locked last\n      could be unlocked faster - optimizing for LIFO semantics.\n    */\n    for (i= lex->plugins.elements - 1; i >= 0; i--)\n      if (plugin == *dynamic_element(&lex->plugins, i, plugin_ref*))\n      {\n        delete_dynamic_element(&lex->plugins, i);\n        break;\n      }\n    DBUG_ASSERT(i >= 0);\n  }\n\n  DBUG_ASSERT(pi->ref_count);\n  pi->ref_count--;\n\n  if (pi->state == PLUGIN_IS_DELETED && !pi->ref_count)\n    reap_needed= true;\n\n  DBUG_VOID_RETURN;\n}\n\n\nvoid plugin_unlock(THD *thd, plugin_ref plugin)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  DBUG_ENTER(\"plugin_unlock\");\n  if (!plugin)\n    DBUG_VOID_RETURN;\n#ifdef DBUG_OFF\n  /* built-in plugins don't need ref counting */\n  if (!plugin_dlib(plugin))\n    DBUG_VOID_RETURN;\n#endif\n  mysql_mutex_lock(&LOCK_plugin);\n  intern_plugin_unlock(lex, plugin);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_VOID_RETURN;\n}\n\n\nvoid plugin_unlock_list(THD *thd, plugin_ref *list, uint count)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  DBUG_ENTER(\"plugin_unlock_list\");\n  DBUG_ASSERT(list);\n  mysql_mutex_lock(&LOCK_plugin);\n  while (count--)\n    intern_plugin_unlock(lex, *list++);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_VOID_RETURN;\n}\n\n\nstatic int plugin_initialize(struct st_plugin_int *plugin)\n{\n  int ret= 1;\n  DBUG_ENTER(\"plugin_initialize\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  uint state= plugin->state;\n  DBUG_ASSERT(state == PLUGIN_IS_UNINITIALIZED);\n\n  mysql_mutex_unlock(&LOCK_plugin);\n  if (plugin_type_initialize[plugin->plugin->type])\n  {\n    if ((*plugin_type_initialize[plugin->plugin->type])(plugin))\n    {\n      sql_print_error(\"Plugin '%s' registration as a %s failed.\",\n                      plugin->name.str, plugin_type_names[plugin->plugin->type].str);\n      goto err;\n    }\n  }\n  else if (plugin->plugin->init)\n  {\n    if (plugin->plugin->init(plugin))\n    {\n      sql_print_error(\"Plugin '%s' init function returned error.\",\n                      plugin->name.str);\n      goto err;\n    }\n  }\n  state= PLUGIN_IS_READY; // plugin->init() succeeded\n\n  if (plugin->plugin->status_vars)\n  {\n#ifdef FIX_LATER\n    /*\n      We have a problem right now where we can not prepend without\n      breaking backwards compatibility. We will fix this shortly so\n      that engines have \"use names\" and we wil use those for\n      CREATE TABLE, and use the plugin name then for adding automatic\n      variable names.\n    */\n    SHOW_VAR array[2]= {\n      {plugin->plugin->name, (char*)plugin->plugin->status_vars, SHOW_ARRAY},\n      {0, 0, SHOW_UNDEF}\n    };\n    if (add_status_vars(array)) // add_status_vars makes a copy\n      goto err;\n#else\n    if (add_status_vars(plugin->plugin->status_vars))\n      goto err;\n#endif /* FIX_LATER */\n  }\n\n  /*\n    set the plugin attribute of plugin's sys vars so they are pointing\n    to the active plugin\n  */\n  if (plugin->system_vars)\n  {\n    sys_var_pluginvar *var= plugin->system_vars->cast_pluginvar();\n    for (;;)\n    {\n      var->plugin= plugin;\n      if (!var->next)\n        break;\n      var= var->next->cast_pluginvar();\n    }\n  }\n\n  ret= 0;\n\nerr:\n  mysql_mutex_lock(&LOCK_plugin);\n  plugin->state= state;\n\n  /* maintain the obsolete @@have_innodb variable */\n  if (!my_strcasecmp(&my_charset_latin1, plugin->name.str, \"InnoDB\"))\n    have_innodb= state & PLUGIN_IS_READY ? SHOW_OPTION_YES\n                                         : SHOW_OPTION_DISABLED;\n\n  DBUG_RETURN(ret);\n}\n\n\nextern \"C\" uchar *get_plugin_hash_key(const uchar *, size_t *, my_bool);\nextern \"C\" uchar *get_bookmark_hash_key(const uchar *, size_t *, my_bool);\n\n\nuchar *get_plugin_hash_key(const uchar *buff, size_t *length,\n                           my_bool not_used __attribute__((unused)))\n{\n  struct st_plugin_int *plugin= (st_plugin_int *)buff;\n  *length= (uint)plugin->name.length;\n  return((uchar *)plugin->name.str);\n}\n\n\nuchar *get_bookmark_hash_key(const uchar *buff, size_t *length,\n                             my_bool not_used __attribute__((unused)))\n{\n  struct st_bookmark *var= (st_bookmark *)buff;\n  *length= var->name_len + 1;\n  return (uchar*) var->key;\n}\n\nstatic inline void convert_dash_to_underscore(char *str, int len)\n{\n  for (char *p= str; p <= str+len; p++)\n    if (*p == '-')\n      *p= '_';\n}\n\nstatic inline void convert_underscore_to_dash(char *str, int len)\n{\n  for (char *p= str; p <= str+len; p++)\n    if (*p == '_')\n      *p= '-';\n}\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_mutex_key key_LOCK_plugin;\nstatic PSI_mutex_key key_LOCK_plugin_delete;\n\nstatic PSI_mutex_info all_plugin_mutexes[]=\n{\n  { &key_LOCK_plugin, \"LOCK_plugin\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_plugin_delete, \"LOCK_plugin_delete\", PSI_FLAG_GLOBAL}\n};\n\nstatic void init_plugin_psi_keys(void)\n{\n  const char* category= \"sql\";\n  int count;\n\n  if (PSI_server == NULL)\n    return;\n\n  count= array_elements(all_plugin_mutexes);\n  PSI_server->register_mutex(category, all_plugin_mutexes, count);\n}\n#endif /* HAVE_PSI_INTERFACE */\n\n/*\n  The logic is that we first load and initialize all compiled in plugins.\n  From there we load up the dynamic types (assuming we have not been told to\n  skip this part).\n\n  Finally we initialize everything, aka the dynamic that have yet to initialize.\n*/\nint plugin_init(int *argc, char **argv, int flags)\n{\n  uint i;\n  bool is_myisam;\n  struct st_mysql_plugin **builtins;\n  struct st_mysql_plugin *plugin;\n  struct st_plugin_int tmp, *plugin_ptr, **reap;\n  MEM_ROOT tmp_root;\n  bool reaped_mandatory_plugin= false;\n  bool mandatory= true;\n  DBUG_ENTER(\"plugin_init\");\n\n  if (initialized)\n    DBUG_RETURN(0);\n\n#ifdef HAVE_PSI_INTERFACE\n  init_plugin_psi_keys();\n#endif\n\n  init_alloc_root(&plugin_mem_root, 4096, 4096);\n  init_alloc_root(&tmp_root, 4096, 4096);\n\n  if (my_hash_init(&bookmark_hash, &my_charset_bin, 16, 0, 0,\n                   get_bookmark_hash_key, NULL, HASH_UNIQUE))\n      goto err;\n\n\n  mysql_mutex_init(key_LOCK_plugin, &LOCK_plugin, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_plugin_delete, &LOCK_plugin_delete, MY_MUTEX_INIT_FAST);\n\n  if (my_init_dynamic_array(&plugin_dl_array,\n                            sizeof(struct st_plugin_dl *),16,16) ||\n      my_init_dynamic_array(&plugin_array,\n                            sizeof(struct st_plugin_int *),16,16))\n    goto err;\n\n  for (i= 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n  {\n    if (my_hash_init(&plugin_hash[i], system_charset_info, 16, 0, 0,\n                     get_plugin_hash_key, NULL, HASH_UNIQUE))\n      goto err;\n  }\n\n  mysql_mutex_lock(&LOCK_plugin);\n\n  initialized= 1;\n\n  /*\n    First we register builtin plugins\n  */\n  for (builtins= mysql_mandatory_plugins; *builtins || mandatory; builtins++)\n  {\n    if (!*builtins)\n    {\n      builtins= mysql_optional_plugins;\n      mandatory= false;\n      if (!*builtins)\n        break;\n    }\n    for (plugin= *builtins; plugin->info; plugin++)\n    {\n      if (opt_ignore_builtin_innodb &&\n          !my_strnncoll(&my_charset_latin1, (const uchar*) plugin->name,\n                        6, (const uchar*) \"InnoDB\", 6))\n        continue;\n      bzero(&tmp, sizeof(tmp));\n      tmp.plugin= plugin;\n      tmp.name.str= (char *)plugin->name;\n      tmp.name.length= strlen(plugin->name);\n      tmp.state= 0;\n      tmp.load_option= mandatory ? PLUGIN_FORCE : PLUGIN_ON;\n\n      /*\n        If the performance schema is compiled in,\n        treat the storage engine plugin as 'mandatory',\n        to suppress any plugin-level options such as '--performance-schema'.\n        This is specific to the performance schema, and is done on purpose:\n        the server-level option '--performance-schema' controls the overall\n        performance schema initialization, which consists of much more that\n        the underlying storage engine initialization.\n        See mysqld.cc, set_vars.cc.\n        Suppressing ways to interfere directly with the storage engine alone\n        prevents awkward situations where:\n        - the user wants the performance schema functionality, by using\n          '--enable-performance-schema' (the server option),\n        - yet disable explicitly a component needed for the functionality\n          to work, by using '--skip-performance-schema' (the plugin)\n      */\n      if (!my_strcasecmp(&my_charset_latin1, plugin->name, \"PERFORMANCE_SCHEMA\"))\n        tmp.load_option= PLUGIN_FORCE;\n\n      free_root(&tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n      if (test_plugin_options(&tmp_root, &tmp, argc, argv))\n        tmp.state= PLUGIN_IS_DISABLED;\n      else\n        tmp.state= PLUGIN_IS_UNINITIALIZED;\n      if (register_builtin(plugin, &tmp, &plugin_ptr))\n        goto err_unlock;\n\n      /* only initialize MyISAM and CSV at this stage */\n      if (!(is_myisam=\n            !my_strcasecmp(&my_charset_latin1, plugin->name, \"MyISAM\")) &&\n          my_strcasecmp(&my_charset_latin1, plugin->name, \"CSV\"))\n        continue;\n\n      if (plugin_ptr->state != PLUGIN_IS_UNINITIALIZED ||\n          plugin_initialize(plugin_ptr))\n        goto err_unlock;\n\n      /*\n        initialize the global default storage engine so that it may\n        not be null in any child thread.\n      */\n      if (is_myisam)\n      {\n        DBUG_ASSERT(!global_system_variables.table_plugin);\n        global_system_variables.table_plugin=\n          my_intern_plugin_lock(NULL, plugin_int_to_ref(plugin_ptr));\n        DBUG_ASSERT(plugin_ptr->ref_count == 1);\n      }\n    }\n  }\n\n  /* should now be set to MyISAM storage engine */\n  DBUG_ASSERT(global_system_variables.table_plugin);\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  /* Register all dynamic plugins */\n  if (!(flags & PLUGIN_INIT_SKIP_DYNAMIC_LOADING))\n  {\n    if (opt_plugin_load)\n      plugin_load_list(&tmp_root, argc, argv, opt_plugin_load);\n    if (!(flags & PLUGIN_INIT_SKIP_PLUGIN_TABLE))\n      plugin_load(&tmp_root, argc, argv);\n  }\n\n  if (flags & PLUGIN_INIT_SKIP_INITIALIZATION)\n    goto end;\n\n  /*\n    Now we initialize all remaining plugins\n  */\n\n  mysql_mutex_lock(&LOCK_plugin);\n  reap= (st_plugin_int **) my_alloca((plugin_array.elements+1) * sizeof(void*));\n  *(reap++)= NULL;\n\n  for (i= 0; i < plugin_array.elements; i++)\n  {\n    plugin_ptr= *dynamic_element(&plugin_array, i, struct st_plugin_int **);\n    if (plugin_ptr->state == PLUGIN_IS_UNINITIALIZED)\n    {\n      if (plugin_initialize(plugin_ptr))\n      {\n        plugin_ptr->state= PLUGIN_IS_DYING;\n        *(reap++)= plugin_ptr;\n      }\n    }\n  }\n\n  /*\n    Check if any plugins have to be reaped\n  */\n  while ((plugin_ptr= *(--reap)))\n  {\n    mysql_mutex_unlock(&LOCK_plugin);\n    if (plugin_ptr->load_option == PLUGIN_FORCE ||\n        plugin_ptr->load_option == PLUGIN_FORCE_PLUS_PERMANENT)\n      reaped_mandatory_plugin= TRUE;\n    plugin_deinitialize(plugin_ptr, true);\n    mysql_mutex_lock(&LOCK_plugin_delete);\n    mysql_mutex_lock(&LOCK_plugin);\n    plugin_del(plugin_ptr);\n    mysql_mutex_unlock(&LOCK_plugin_delete);\n  }\n\n  mysql_mutex_unlock(&LOCK_plugin);\n  my_afree(reap);\n  if (reaped_mandatory_plugin)\n    goto err;\n\nend:\n  free_root(&tmp_root, MYF(0));\n\n  DBUG_RETURN(0);\n\nerr_unlock:\n  mysql_mutex_unlock(&LOCK_plugin);\nerr:\n  free_root(&tmp_root, MYF(0));\n  DBUG_RETURN(1);\n}\n\n\nstatic bool register_builtin(struct st_mysql_plugin *plugin,\n                             struct st_plugin_int *tmp,\n                             struct st_plugin_int **ptr)\n{\n  DBUG_ENTER(\"register_builtin\");\n  tmp->ref_count= 0;\n  tmp->plugin_dl= 0;\n\n  if (insert_dynamic(&plugin_array, (uchar*)&tmp))\n    DBUG_RETURN(1);\n\n  *ptr= *dynamic_element(&plugin_array, plugin_array.elements - 1,\n                         struct st_plugin_int **)=\n        (struct st_plugin_int *) memdup_root(&plugin_mem_root, (uchar*)tmp,\n                                             sizeof(struct st_plugin_int));\n\n  if (my_hash_insert(&plugin_hash[plugin->type],(uchar*) *ptr))\n    DBUG_RETURN(1);\n\n  DBUG_RETURN(0);\n}\n\n\n/*\n  called only by plugin_init()\n*/\nstatic void plugin_load(MEM_ROOT *tmp_root, int *argc, char **argv)\n{\n  THD thd;\n  TABLE_LIST tables;\n  TABLE *table;\n  READ_RECORD read_record_info;\n  int error;\n  THD *new_thd= &thd;\n  bool result;\n#ifdef EMBEDDED_LIBRARY\n  No_such_table_error_handler error_handler;\n#endif /* EMBEDDED_LIBRARY */\n  DBUG_ENTER(\"plugin_load\");\n\n  new_thd->thread_stack= (char*) &tables;\n  new_thd->store_globals();\n  new_thd->db= my_strdup(\"mysql\", MYF(0));\n  new_thd->db_length= 5;\n  bzero((char*) &thd.net, sizeof(thd.net));\n  tables.init_one_table(\"mysql\", 5, \"plugin\", 6, \"plugin\", TL_READ);\n\n#ifdef EMBEDDED_LIBRARY\n  /*\n    When building an embedded library, if the mysql.plugin table\n    does not exist, we silently ignore the missing table\n  */\n  new_thd->push_internal_handler(&error_handler);\n#endif /* EMBEDDED_LIBRARY */\n\n  result= open_and_lock_tables(new_thd, &tables, FALSE, MYSQL_LOCK_IGNORE_TIMEOUT);\n\n#ifdef EMBEDDED_LIBRARY\n  new_thd->pop_internal_handler();\n  if (error_handler.safely_trapped_errors())\n    goto end;\n#endif /* EMBEDDED_LIBRARY */\n\n  if (result)\n  {\n    DBUG_PRINT(\"error\",(\"Can't open plugin table\"));\n    sql_print_error(\"Can't open the mysql.plugin table. Please \"\n                    \"run mysql_upgrade to create it.\");\n    goto end;\n  }\n  table= tables.table;\n  init_read_record(&read_record_info, new_thd, table, NULL, 1, 0, FALSE);\n  table->use_all_columns();\n  /*\n    there're no other threads running yet, so we don't need a mutex.\n    but plugin_add() before is designed to work in multi-threaded\n    environment, and it uses mysql_mutex_assert_owner(), so we lock\n    the mutex here to satisfy the assert\n  */\n  mysql_mutex_lock(&LOCK_plugin);\n  while (!(error= read_record_info.read_record(&read_record_info)))\n  {\n    DBUG_PRINT(\"info\", (\"init plugin record\"));\n    String str_name, str_dl;\n    get_field(tmp_root, table->field[0], &str_name);\n    get_field(tmp_root, table->field[1], &str_dl);\n\n    LEX_STRING name= {(char *)str_name.ptr(), str_name.length()};\n    LEX_STRING dl= {(char *)str_dl.ptr(), str_dl.length()};\n\n    if (plugin_add(tmp_root, &name, &dl, argc, argv, REPORT_TO_LOG))\n      sql_print_warning(\"Couldn't load plugin named '%s' with soname '%s'.\",\n                        str_name.c_ptr(), str_dl.c_ptr());\n    free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n  if (error > 0)\n    sql_print_error(ER(ER_GET_ERRNO), my_errno);\n  end_read_record(&read_record_info);\n  table->m_needs_reopen= TRUE;                  // Force close to free memory\n  close_mysql_tables(new_thd);\nend:\n  /* Remember that we don't have a THD */\n  my_pthread_setspecific_ptr(THR_THD, 0);\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  called only by plugin_init()\n*/\nstatic bool plugin_load_list(MEM_ROOT *tmp_root, int *argc, char **argv,\n                             const char *list)\n{\n  char buffer[FN_REFLEN];\n  LEX_STRING name= {buffer, 0}, dl= {NULL, 0}, *str= &name;\n  struct st_plugin_dl *plugin_dl;\n  struct st_mysql_plugin *plugin;\n  char *p= buffer;\n  DBUG_ENTER(\"plugin_load_list\");\n  while (list)\n  {\n    if (p == buffer + sizeof(buffer) - 1)\n    {\n      sql_print_error(\"plugin-load parameter too long\");\n      DBUG_RETURN(TRUE);\n    }\n\n    switch ((*(p++)= *(list++))) {\n    case '\\0':\n      list= NULL; /* terminate the loop */\n      /* fall through */\n#ifndef __WIN__\n    case ':':     /* can't use this as delimiter as it may be drive letter */\n#endif\n    case ';':\n      str->str[str->length]= '\\0';\n      if (str == &name)  // load all plugins in named module\n      {\n        if (!name.length)\n        {\n          p--;    /* reset pointer */\n          continue;\n        }\n\n        dl= name;\n        mysql_mutex_lock(&LOCK_plugin);\n        if ((plugin_dl= plugin_dl_add(&dl, REPORT_TO_LOG)))\n        {\n          for (plugin= plugin_dl->plugins; plugin->info; plugin++)\n          {\n            name.str= (char *) plugin->name;\n            name.length= strlen(name.str);\n\n            free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n            if (plugin_add(tmp_root, &name, &dl, argc, argv, REPORT_TO_LOG))\n              goto error;\n          }\n          plugin_dl_del(&dl); // reduce ref count\n        }\n      }\n      else\n      {\n        free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n        mysql_mutex_lock(&LOCK_plugin);\n        if (plugin_add(tmp_root, &name, &dl, argc, argv, REPORT_TO_LOG))\n          goto error;\n      }\n      mysql_mutex_unlock(&LOCK_plugin);\n      name.length= dl.length= 0;\n      dl.str= NULL; name.str= p= buffer;\n      str= &name;\n      continue;\n    case '=':\n    case '#':\n      if (str == &name)\n      {\n        name.str[name.length]= '\\0';\n        str= &dl;\n        str->str= p;\n        continue;\n      }\n    default:\n      str->length++;\n      continue;\n    }\n  }\n  DBUG_RETURN(FALSE);\nerror:\n  mysql_mutex_unlock(&LOCK_plugin);\n  sql_print_error(\"Couldn't load plugin named '%s' with soname '%s'.\",\n                  name.str, dl.str);\n  DBUG_RETURN(TRUE);\n}\n\n\nvoid plugin_shutdown(void)\n{\n  uint i, count= plugin_array.elements;\n  struct st_plugin_int **plugins, *plugin;\n  struct st_plugin_dl **dl;\n  DBUG_ENTER(\"plugin_shutdown\");\n\n  if (initialized)\n  {\n    mysql_mutex_lock(&LOCK_plugin);\n\n    reap_needed= true;\n\n    /*\n      We want to shut down plugins in a reasonable order, this will\n      become important when we have plugins which depend upon each other.\n      Circular references cannot be reaped so they are forced afterwards.\n      TODO: Have an additional step here to notify all active plugins that\n      shutdown is requested to allow plugins to deinitialize in parallel.\n    */\n    while (reap_needed && (count= plugin_array.elements))\n    {\n      reap_plugins();\n      for (i= 0; i < count; i++)\n      {\n        plugin= *dynamic_element(&plugin_array, i, struct st_plugin_int **);\n        if (plugin->state == PLUGIN_IS_READY)\n        {\n          plugin->state= PLUGIN_IS_DELETED;\n          reap_needed= true;\n        }\n      }\n      if (!reap_needed)\n      {\n        /*\n          release any plugin references held.\n        */\n        unlock_variables(NULL, &global_system_variables);\n        unlock_variables(NULL, &max_system_variables);\n      }\n    }\n\n    plugins= (struct st_plugin_int **) my_alloca(sizeof(void*) * (count+1));\n\n    /*\n      If we have any plugins which did not die cleanly, we force shutdown\n    */\n    for (i= 0; i < count; i++)\n    {\n      plugins[i]= *dynamic_element(&plugin_array, i, struct st_plugin_int **);\n      /* change the state to ensure no reaping races */\n      if (plugins[i]->state == PLUGIN_IS_DELETED)\n        plugins[i]->state= PLUGIN_IS_DYING;\n    }\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    /*\n      We loop through all plugins and call deinit() if they have one.\n    */\n    for (i= 0; i < count; i++)\n      if (!(plugins[i]->state & (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_FREED |\n                                 PLUGIN_IS_DISABLED)))\n      {\n        sql_print_warning(\"Plugin '%s' will be forced to shutdown\",\n                          plugins[i]->name.str);\n        /*\n          We are forcing deinit on plugins so we don't want to do a ref_count\n          check until we have processed all the plugins.\n        */\n        plugin_deinitialize(plugins[i], false);\n      }\n\n    /*\n      It's perfectly safe not to lock LOCK_plugin, LOCK_plugin_delete, as\n      there're no concurrent threads anymore. But some functions called from\n      here use mysql_mutex_assert_owner(), so we lock the mutex to satisfy it\n    */\n    mysql_mutex_lock(&LOCK_plugin_delete);\n    mysql_mutex_lock(&LOCK_plugin);\n\n    /*\n      We defer checking ref_counts until after all plugins are deinitialized\n      as some may have worker threads holding on to plugin references.\n    */\n    for (i= 0; i < count; i++)\n    {\n      if (plugins[i]->ref_count)\n        sql_print_error(\"Plugin '%s' has ref_count=%d after shutdown.\",\n                        plugins[i]->name.str, plugins[i]->ref_count);\n      if (plugins[i]->state & PLUGIN_IS_UNINITIALIZED)\n        plugin_del(plugins[i]);\n    }\n\n    /*\n      Now we can deallocate all memory.\n    */\n\n    cleanup_variables(NULL, &global_system_variables);\n    cleanup_variables(NULL, &max_system_variables);\n    mysql_mutex_unlock(&LOCK_plugin);\n    mysql_mutex_unlock(&LOCK_plugin_delete);\n\n    initialized= 0;\n    mysql_mutex_destroy(&LOCK_plugin);\n    mysql_mutex_destroy(&LOCK_plugin_delete);\n\n    my_afree(plugins);\n  }\n\n  /* Dispose of the memory */\n\n  for (i= 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n    my_hash_free(&plugin_hash[i]);\n  delete_dynamic(&plugin_array);\n\n  count= plugin_dl_array.elements;\n  dl= (struct st_plugin_dl **)my_alloca(sizeof(void*) * count);\n  for (i= 0; i < count; i++)\n    dl[i]= *dynamic_element(&plugin_dl_array, i, struct st_plugin_dl **);\n  for (i= 0; i < plugin_dl_array.elements; i++)\n    free_plugin_mem(dl[i]);\n  my_afree(dl);\n  delete_dynamic(&plugin_dl_array);\n\n  my_hash_free(&bookmark_hash);\n  free_root(&plugin_mem_root, MYF(0));\n\n  global_variables_dynamic_size= 0;\n\n  DBUG_VOID_RETURN;\n}\n\n\nbool mysql_install_plugin(THD *thd, const LEX_STRING *name, const LEX_STRING *dl)\n{\n  TABLE_LIST tables;\n  TABLE *table;\n  int error, argc=orig_argc;\n  char **argv=orig_argv;\n  struct st_plugin_int *tmp;\n  DBUG_ENTER(\"mysql_install_plugin\");\n\n  if (opt_noacl)\n  {\n    my_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0), \"--skip-grant-tables\");\n    DBUG_RETURN(TRUE);\n  }\n\n  tables.init_one_table(\"mysql\", 5, \"plugin\", 6, \"plugin\", TL_WRITE);\n  if (check_table_access(thd, INSERT_ACL, &tables, FALSE, 1, FALSE))\n    DBUG_RETURN(TRUE);\n\n  /* need to open before acquiring LOCK_plugin or it will deadlock */\n  if (! (table = open_ltable(thd, &tables, TL_WRITE,\n                             MYSQL_LOCK_IGNORE_TIMEOUT)))\n    DBUG_RETURN(TRUE);\n\n  /*\n    Pre-acquire audit plugins for events that may potentially occur\n    during [UN]INSTALL PLUGIN.\n\n    When audit event is triggered, audit subsystem acquires interested\n    plugins by walking through plugin list. Evidently plugin list\n    iterator protects plugin list by acquiring LOCK_plugin, see\n    plugin_foreach_with_mask().\n\n    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin\n    rather for a long time.\n\n    When audit event is triggered during [UN]INSTALL PLUGIN, plugin\n    list iterator acquires the same lock (within the same thread)\n    second time.\n\n    This hack should be removed when LOCK_plugin is fixed so it\n    protects only what it supposed to protect.\n  */\n  mysql_audit_acquire_plugins(thd, MYSQL_AUDIT_GENERAL_CLASS);\n\n  mysql_mutex_lock(&LOCK_plugin);\n  DEBUG_SYNC(thd, \"acquired_LOCK_plugin\");\n  mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n\n  if (my_load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &argc, &argv, NULL))\n  {\n    report_error(REPORT_TO_USER, ER_PLUGIN_IS_NOT_LOADED, name->str);\n    goto err;\n  }\n  error= plugin_add(thd->mem_root, name, dl, &argc, argv, REPORT_TO_USER);\n  if (argv)\n    free_defaults(argv);\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n\n  if (error || !(tmp= plugin_find_internal(name, MYSQL_ANY_PLUGIN)))\n    goto err;\n\n  if (tmp->state == PLUGIN_IS_DISABLED)\n  {\n    push_warning_printf(thd, MYSQL_ERROR::WARN_LEVEL_WARN,\n                        ER_CANT_INITIALIZE_UDF, ER(ER_CANT_INITIALIZE_UDF),\n                        name->str, \"Plugin is disabled\");\n  }\n  else\n  {\n    if (plugin_initialize(tmp))\n    {\n      mysql_mutex_unlock(&LOCK_plugin);\n      my_error(ER_CANT_INITIALIZE_UDF, MYF(0), name->str,\n               \"Plugin initialization function failed.\");\n      goto deinit;\n    }\n  }\n\n  /*\n    We do not replicate the INSTALL PLUGIN statement. Disable binlogging\n    of the insert into the plugin table, so that it is not replicated in\n    row based mode.\n  */\n  mysql_mutex_unlock(&LOCK_plugin);\n  tmp_disable_binlog(thd);\n  table->use_all_columns();\n  restore_record(table, s->default_values);\n  table->field[0]->store(name->str, name->length, system_charset_info);\n  table->field[1]->store(dl->str, dl->length, files_charset_info);\n  error= table->file->ha_write_row(table->record[0]);\n  reenable_binlog(thd);\n  if (error)\n  {\n    table->file->print_error(error, MYF(0));\n    goto deinit;\n  }\n  DBUG_RETURN(FALSE);\ndeinit:\n  mysql_mutex_lock(&LOCK_plugin);\n  tmp->state= PLUGIN_IS_DELETED;\n  reap_needed= true;\n  reap_plugins();\nerr:\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(TRUE);\n}\n\n\nbool mysql_uninstall_plugin(THD *thd, const LEX_STRING *name)\n{\n  TABLE *table;\n  TABLE_LIST tables;\n  struct st_plugin_int *plugin;\n  DBUG_ENTER(\"mysql_uninstall_plugin\");\n\n  if (opt_noacl)\n  {\n    my_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0), \"--skip-grant-tables\");\n    DBUG_RETURN(TRUE);\n  }\n\n  tables.init_one_table(\"mysql\", 5, \"plugin\", 6, \"plugin\", TL_WRITE);\n\n  if (check_table_access(thd, DELETE_ACL, &tables, FALSE, 1, FALSE))\n    DBUG_RETURN(TRUE);\n\n  /* need to open before acquiring LOCK_plugin or it will deadlock */\n  if (! (table= open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT)))\n    DBUG_RETURN(TRUE);\n\n  if (!table->key_info)\n  {\n    my_printf_error(ER_UNKNOWN_ERROR,\n                    \"The table '%s.%s' does not have the necessary key(s) \"\n                    \"defined on it. Please check the table definition and \"\n                    \"create index(s) accordingly.\", MYF(0),\n                    table->s->db.str, table->s->table_name.str);\n    DBUG_RETURN(TRUE);\n  }\n\n  /*\n    Pre-acquire audit plugins for events that may potentially occur\n    during [UN]INSTALL PLUGIN.\n\n    When audit event is triggered, audit subsystem acquires interested\n    plugins by walking through plugin list. Evidently plugin list\n    iterator protects plugin list by acquiring LOCK_plugin, see\n    plugin_foreach_with_mask().\n\n    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin\n    rather for a long time.\n\n    When audit event is triggered during [UN]INSTALL PLUGIN, plugin\n    list iterator acquires the same lock (within the same thread)\n    second time.\n\n    This hack should be removed when LOCK_plugin is fixed so it\n    protects only what it supposed to protect.\n  */\n  mysql_audit_acquire_plugins(thd, MYSQL_AUDIT_GENERAL_CLASS);\n\n  mysql_mutex_lock(&LOCK_plugin);\n  if (!(plugin= plugin_find_internal(name, MYSQL_ANY_PLUGIN)) ||\n      plugin->state & (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_DYING))\n  {\n    my_error(ER_SP_DOES_NOT_EXIST, MYF(0), \"PLUGIN\", name->str);\n    goto err;\n  }\n  if (!plugin->plugin_dl)\n  {\n    push_warning(thd, MYSQL_ERROR::WARN_LEVEL_WARN,\n                 WARN_PLUGIN_DELETE_BUILTIN, ER(WARN_PLUGIN_DELETE_BUILTIN));\n    my_error(ER_SP_DOES_NOT_EXIST, MYF(0), \"PLUGIN\", name->str);\n    goto err;\n  }\n  if (plugin->load_option == PLUGIN_FORCE_PLUS_PERMANENT)\n  {\n    my_error(ER_PLUGIN_IS_PERMANENT, MYF(0), name->str);\n    goto err;\n  }\n  /*\n    Error message for ER_PLUGIN_IS_PERMANENT is not suitable for\n    plugins marked as not dynamically uninstallable, so we have a\n    separate one instead of changing the old one.\n   */\n  if (plugin->plugin->flags & PLUGIN_OPT_NO_UNINSTALL)\n  {\n    my_error(ER_PLUGIN_NO_UNINSTALL, MYF(0), plugin->plugin->name);\n    goto err;\n  }\n\n#ifdef HAVE_REPLICATION\n  /* Block Uninstallation of semi_sync plugins (Master/Slave)\n     when they are busy\n   */\n  char buff[20];\n  /*\n    Master: If there are active semi sync slaves for this Master,\n    then that means it is busy and rpl_semi_sync_master plugin\n    cannot be uninstalled. To check whether the master\n    has any semi sync slaves or not, check Rpl_semi_sync_master_cliens\n    status variable value, if it is not 0, that means it is busy.\n  */\n  if (!strcmp(name->str, \"rpl_semi_sync_master\") &&\n      get_status_var(thd,\n                     plugin->plugin->status_vars,\n                     \"Rpl_semi_sync_master_clients\",buff) &&\n      strcmp(buff,\"0\") )\n  {\n    sql_print_error(\"Plugin 'rpl_semi_sync_master' cannot be uninstalled now. \"\n                    \"Stop any active semisynchronous slaves of this master \"\n                    \"first.\\n\");\n    my_error(ER_UNKNOWN_ERROR, MYF(0), name->str);\n    goto err;\n  }\n  /* Slave: If there is semi sync enabled IO thread active on this Slave,\n    then that means plugin is busy and rpl_semi_sync_slave plugin\n    cannot be uninstalled. To check whether semi sync\n    IO thread is active or not, check Rpl_semi_sync_slave_status status\n    variable value, if it is ON, that means it is busy.\n  */\n  if (!strcmp(name->str, \"rpl_semi_sync_slave\") &&\n      get_status_var(thd, plugin->plugin->status_vars,\n                     \"Rpl_semi_sync_slave_status\", buff) &&\n      !strcmp(buff,\"ON\") )\n  {\n    sql_print_error(\"Plugin 'rpl_semi_sync_slave' cannot be uninstalled now. \"\n                    \"Stop any active semisynchronous I/O threads on this slave \"\n                    \"first.\\n\");\n    my_error(ER_UNKNOWN_ERROR, MYF(0), name->str);\n    goto err;\n  }\n#endif\n\n  plugin->state= PLUGIN_IS_DELETED;\n  if (plugin->ref_count)\n    push_warning(thd, MYSQL_ERROR::WARN_LEVEL_WARN,\n                 WARN_PLUGIN_BUSY, ER(WARN_PLUGIN_BUSY));\n  else\n    reap_needed= true;\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  uchar user_key[MAX_KEY_LENGTH];\n  table->use_all_columns();\n  table->field[0]->store(name->str, name->length, system_charset_info);\n  key_copy(user_key, table->record[0], table->key_info,\n           table->key_info->key_length);\n  if (! table->file->index_read_idx_map(table->record[0], 0, user_key,\n                                        HA_WHOLE_KEY, HA_READ_KEY_EXACT))\n  {\n    int error;\n    /*\n      We do not replicate the UNINSTALL PLUGIN statement. Disable binlogging\n      of the delete from the plugin table, so that it is not replicated in\n      row based mode.\n    */\n    tmp_disable_binlog(thd);\n    error= table->file->ha_delete_row(table->record[0]);\n    reenable_binlog(thd);\n    if (error)\n    {\n      table->file->print_error(error, MYF(0));\n      DBUG_RETURN(TRUE);\n    }\n  }\n  DBUG_RETURN(FALSE);\nerr:\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(TRUE);\n}\n\n\nbool plugin_foreach_with_mask(THD *thd, plugin_foreach_func *func,\n                       int type, uint state_mask, void *arg)\n{\n  uint idx, total;\n  struct st_plugin_int *plugin, **plugins;\n  int version=plugin_array_version;\n  DBUG_ENTER(\"plugin_foreach_with_mask\");\n\n  if (!initialized)\n    DBUG_RETURN(FALSE);\n\n  state_mask= ~state_mask; // do it only once\n\n  mysql_mutex_lock(&LOCK_plugin);\n  total= type == MYSQL_ANY_PLUGIN ? plugin_array.elements\n                                  : plugin_hash[type].records;\n  /*\n    Do the alloca out here in case we do have a working alloca:\n        leaving the nested stack frame invalidates alloca allocation.\n  */\n  plugins=(struct st_plugin_int **)my_alloca(total*sizeof(plugin));\n  if (type == MYSQL_ANY_PLUGIN)\n  {\n    for (idx= 0; idx < total; idx++)\n    {\n      plugin= *dynamic_element(&plugin_array, idx, struct st_plugin_int **);\n      plugins[idx]= !(plugin->state & state_mask) ? plugin : NULL;\n    }\n  }\n  else\n  {\n    HASH *hash= plugin_hash + type;\n    for (idx= 0; idx < total; idx++)\n    {\n      plugin= (struct st_plugin_int *) my_hash_element(hash, idx);\n      plugins[idx]= !(plugin->state & state_mask) ? plugin : NULL;\n    }\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  for (idx= 0; idx < total; idx++)\n  {\n    if (unlikely(version != plugin_array_version))\n    {\n      mysql_mutex_lock(&LOCK_plugin);\n      for (uint i=idx; i < total; i++)\n        if (plugins[i] && plugins[i]->state & state_mask)\n          plugins[i]=0;\n      mysql_mutex_unlock(&LOCK_plugin);\n    }\n    plugin= plugins[idx];\n    /* It will stop iterating on first engine error when \"func\" returns TRUE */\n    if (plugin && func(thd, plugin_int_to_ref(plugin), arg))\n        goto err;\n  }\n\n  my_afree(plugins);\n  DBUG_RETURN(FALSE);\nerr:\n  my_afree(plugins);\n  DBUG_RETURN(TRUE);\n}\n\n\n/****************************************************************************\n  Internal type declarations for variables support\n****************************************************************************/\n\n#undef MYSQL_SYSVAR_NAME\n#define MYSQL_SYSVAR_NAME(name) name\n#define PLUGIN_VAR_TYPEMASK 0x007f\n\n#define EXTRA_OPTIONS 3 /* options for: 'foo', 'plugin-foo' and NULL */\n\ntypedef DECLARE_MYSQL_SYSVAR_BASIC(sysvar_bool_t, my_bool);\ntypedef DECLARE_MYSQL_THDVAR_BASIC(thdvar_bool_t, my_bool);\ntypedef DECLARE_MYSQL_SYSVAR_BASIC(sysvar_str_t, char *);\ntypedef DECLARE_MYSQL_THDVAR_BASIC(thdvar_str_t, char *);\n\ntypedef DECLARE_MYSQL_SYSVAR_TYPELIB(sysvar_enum_t, unsigned long);\ntypedef DECLARE_MYSQL_THDVAR_TYPELIB(thdvar_enum_t, unsigned long);\ntypedef DECLARE_MYSQL_SYSVAR_TYPELIB(sysvar_set_t, ulonglong);\ntypedef DECLARE_MYSQL_THDVAR_TYPELIB(thdvar_set_t, ulonglong);\n\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_int_t, int);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_long_t, long);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_longlong_t, longlong);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_uint_t, uint);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_ulong_t, ulong);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_ulonglong_t, ulonglong);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_double_t, double);\n\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_int_t, int);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_long_t, long);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_longlong_t, longlong);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_uint_t, uint);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_ulong_t, ulong);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_ulonglong_t, ulonglong);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_double_t, double);\n\n\n/****************************************************************************\n  default variable data check and update functions\n****************************************************************************/\n\nstatic int check_func_bool(THD *thd, struct st_mysql_sys_var *var,\n                           void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  const char *str;\n  int result, length;\n  long long tmp;\n\n  if (value->value_type(value) == MYSQL_VALUE_TYPE_STRING)\n  {\n    length= sizeof(buff);\n    if (!(str= value->val_str(value, buff, &length)) ||\n        (result= find_type(&bool_typelib, str, length, 1)-1) < 0)\n      goto err;\n  }\n  else\n  {\n    if (value->val_int(value, &tmp) < 0)\n      goto err;\n    if (tmp > 1)\n      goto err;\n    result= (int) tmp;\n  }\n  *(my_bool *) save= -result;\n  return 0;\nerr:\n  return 1;\n}\n\n\nstatic int check_func_int(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  my_bool fixed1, fixed2;\n  long long orig, val;\n  struct my_option options;\n  value->val_int(value, &orig);\n  val= orig;\n  plugin_opt_set_limits(&options, var);\n\n  if (var->flags & PLUGIN_VAR_UNSIGNED)\n  {\n    if ((fixed1= (!value->is_unsigned(value) && val < 0)))\n      val=0;\n    *(uint *)save= (uint) getopt_ull_limit_value((ulonglong) val, &options,\n                                                   &fixed2);\n  }\n  else\n  {\n    if ((fixed1= (value->is_unsigned(value) && val < 0)))\n      val=LONGLONG_MAX;\n    *(int *)save= (int) getopt_ll_limit_value(val, &options, &fixed2);\n  }\n\n  return throw_bounds_warning(thd, var->name, fixed1 || fixed2,\n                              value->is_unsigned(value), (longlong) orig);\n}\n\n\nstatic int check_func_long(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  my_bool fixed1, fixed2;\n  long long orig, val;\n  struct my_option options;\n  value->val_int(value, &orig);\n  val= orig;\n  plugin_opt_set_limits(&options, var);\n\n  if (var->flags & PLUGIN_VAR_UNSIGNED)\n  {\n    if ((fixed1= (!value->is_unsigned(value) && val < 0)))\n      val=0;\n    *(ulong *)save= (ulong) getopt_ull_limit_value((ulonglong) val, &options,\n                                                   &fixed2);\n  }\n  else\n  {\n    if ((fixed1= (value->is_unsigned(value) && val < 0)))\n      val=LONGLONG_MAX;\n    *(long *)save= (long) getopt_ll_limit_value(val, &options, &fixed2);\n  }\n\n  return throw_bounds_warning(thd, var->name, fixed1 || fixed2,\n                              value->is_unsigned(value), (longlong) orig);\n}\n\n\nstatic int check_func_longlong(THD *thd, struct st_mysql_sys_var *var,\n                               void *save, st_mysql_value *value)\n{\n  my_bool fixed1, fixed2;\n  long long orig, val;\n  struct my_option options;\n  value->val_int(value, &orig);\n  val= orig;\n  plugin_opt_set_limits(&options, var);\n\n  if (var->flags & PLUGIN_VAR_UNSIGNED)\n  {\n    if ((fixed1= (!value->is_unsigned(value) && val < 0)))\n      val=0;\n    *(ulonglong *)save= getopt_ull_limit_value((ulonglong) val, &options,\n                                               &fixed2);\n  }\n  else\n  {\n    if ((fixed1= (value->is_unsigned(value) && val < 0)))\n      val=LONGLONG_MAX;\n    *(longlong *)save= getopt_ll_limit_value(val, &options, &fixed2);\n  }\n\n  return throw_bounds_warning(thd, var->name, fixed1 || fixed2,\n                              value->is_unsigned(value), (longlong) orig);\n}\n\nstatic int check_func_str(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  const char *str;\n  int length;\n\n  length= sizeof(buff);\n  if ((str= value->val_str(value, buff, &length)))\n    str= thd->strmake(str, length);\n  *(const char**)save= str;\n  return 0;\n}\n\n\nstatic int check_func_enum(THD *thd, struct st_mysql_sys_var *var,\n                           void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  const char *str;\n  TYPELIB *typelib;\n  long long tmp;\n  long result;\n  int length;\n\n  if (var->flags & PLUGIN_VAR_THDLOCAL)\n    typelib= ((thdvar_enum_t*) var)->typelib;\n  else\n    typelib= ((sysvar_enum_t*) var)->typelib;\n\n  if (value->value_type(value) == MYSQL_VALUE_TYPE_STRING)\n  {\n    length= sizeof(buff);\n    if (!(str= value->val_str(value, buff, &length)))\n      goto err;\n    if ((result= (long)find_type(typelib, str, length, 0) - 1) < 0)\n      goto err;\n  }\n  else\n  {\n    if (value->val_int(value, &tmp))\n      goto err;\n    if (tmp < 0 || tmp >= typelib->count)\n      goto err;\n    result= (long) tmp;\n  }\n  *(long*)save= result;\n  return 0;\nerr:\n  return 1;\n}\n\n\nstatic int check_func_set(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE], *error= 0;\n  const char *str;\n  TYPELIB *typelib;\n  ulonglong result;\n  uint error_len= 0;                            // init as only set on error\n  bool not_used;\n  int length;\n\n  if (var->flags & PLUGIN_VAR_THDLOCAL)\n    typelib= ((thdvar_set_t*) var)->typelib;\n  else\n    typelib= ((sysvar_set_t*)var)->typelib;\n\n  if (value->value_type(value) == MYSQL_VALUE_TYPE_STRING)\n  {\n    length= sizeof(buff);\n    if (!(str= value->val_str(value, buff, &length)))\n      goto err;\n    result= find_set(typelib, str, length, NULL,\n                     &error, &error_len, &not_used);\n    if (error_len)\n      goto err;\n  }\n  else\n  {\n    if (value->val_int(value, (long long *)&result))\n      goto err;\n    if (unlikely((result >= (1ULL << typelib->count)) &&\n                 (typelib->count < sizeof(long)*8)))\n      goto err;\n  }\n  *(ulonglong*)save= result;\n  return 0;\nerr:\n  return 1;\n}\n\nstatic int check_func_double(THD *thd, struct st_mysql_sys_var *var,\n                             void *save, st_mysql_value *value)\n{\n  double v;\n  my_bool fixed;\n  struct my_option option;\n\n  value->val_real(value, &v);\n  plugin_opt_set_limits(&option, var);\n  *(double *) save= getopt_double_limit_value(v, &option, &fixed);\n\n  return throw_bounds_warning(thd, var->name, fixed, v);\n}\n\n\nstatic void update_func_bool(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(my_bool *) tgt= *(my_bool *) save ? TRUE : FALSE;\n}\n\n\nstatic void update_func_int(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(int *)tgt= *(int *) save;\n}\n\n\nstatic void update_func_long(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(long *)tgt= *(long *) save;\n}\n\n\nstatic void update_func_longlong(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(longlong *)tgt= *(ulonglong *) save;\n}\n\n\nstatic void update_func_str(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(char **) tgt= *(char **) save;\n}\n\nstatic void update_func_double(THD *thd, struct st_mysql_sys_var *var,\n                               void *tgt, const void *save)\n{\n  *(double *) tgt= *(double *) save;\n}\n\n/****************************************************************************\n  System Variables support\n****************************************************************************/\n\n\nsys_var *find_sys_var(THD *thd, const char *str, uint length)\n{\n  sys_var *var;\n  sys_var_pluginvar *pi= NULL;\n  plugin_ref plugin;\n  DBUG_ENTER(\"find_sys_var\");\n\n  mysql_mutex_lock(&LOCK_plugin);\n  mysql_rwlock_rdlock(&LOCK_system_variables_hash);\n  if ((var= intern_find_sys_var(str, length)) &&\n      (pi= var->cast_pluginvar()))\n  {\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    LEX *lex= thd ? thd->lex : 0;\n    if (!(plugin= my_intern_plugin_lock(lex, plugin_int_to_ref(pi->plugin))))\n      var= NULL; /* failed to lock it, it must be uninstalling */\n    else\n    if (!(plugin_state(plugin) & PLUGIN_IS_READY))\n    {\n      /* initialization not completed */\n      var= NULL;\n      intern_plugin_unlock(lex, plugin);\n    }\n  }\n  else\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  if (!var)\n    my_error(ER_UNKNOWN_SYSTEM_VARIABLE, MYF(0), (char*) str);\n  DBUG_RETURN(var);\n}\n\n\n/*\n  called by register_var, construct_options and test_plugin_options.\n  Returns the 'bookmark' for the named variable.\n  LOCK_system_variables_hash should be at least read locked\n*/\nstatic st_bookmark *find_bookmark(const char *plugin, const char *name,\n                                  int flags)\n{\n  st_bookmark *result= NULL;\n  uint namelen, length, pluginlen= 0;\n  char *varname, *p;\n\n  if (!(flags & PLUGIN_VAR_THDLOCAL))\n    return NULL;\n\n  namelen= strlen(name);\n  if (plugin)\n    pluginlen= strlen(plugin) + 1;\n  length= namelen + pluginlen + 2;\n  varname= (char*) my_alloca(length);\n\n  if (plugin)\n  {\n    strxmov(varname + 1, plugin, \"_\", name, NullS);\n    for (p= varname + 1; *p; p++)\n      if (*p == '-')\n        *p= '_';\n  }\n  else\n    memcpy(varname + 1, name, namelen + 1);\n\n  varname[0]= flags & PLUGIN_VAR_TYPEMASK;\n\n  result= (st_bookmark*) my_hash_search(&bookmark_hash,\n                                        (const uchar*) varname, length - 1);\n\n  my_afree(varname);\n  return result;\n}\n\n\n/*\n  returns a bookmark for thd-local variables, creating if neccessary.\n  returns null for non thd-local variables.\n  Requires that a write lock is obtained on LOCK_system_variables_hash\n*/\nstatic st_bookmark *register_var(const char *plugin, const char *name,\n                                 int flags)\n{\n  uint length= strlen(plugin) + strlen(name) + 3, size= 0, offset, new_size;\n  st_bookmark *result;\n  char *varname, *p;\n\n  if (!(flags & PLUGIN_VAR_THDLOCAL))\n    return NULL;\n\n  switch (flags & PLUGIN_VAR_TYPEMASK) {\n  case PLUGIN_VAR_BOOL:\n    size= sizeof(my_bool);\n    break;\n  case PLUGIN_VAR_INT:\n    size= sizeof(int);\n    break;\n  case PLUGIN_VAR_LONG:\n  case PLUGIN_VAR_ENUM:\n    size= sizeof(long);\n    break;\n  case PLUGIN_VAR_LONGLONG:\n  case PLUGIN_VAR_SET:\n    size= sizeof(ulonglong);\n    break;\n  case PLUGIN_VAR_STR:\n    size= sizeof(char*);\n    break;\n  case PLUGIN_VAR_DOUBLE:\n    size= sizeof(double);\n    break;\n  default:\n    DBUG_ASSERT(0);\n    return NULL;\n  };\n\n  varname= ((char*) my_alloca(length));\n  strxmov(varname + 1, plugin, \"_\", name, NullS);\n  for (p= varname + 1; *p; p++)\n    if (*p == '-')\n      *p= '_';\n\n  if (!(result= find_bookmark(NULL, varname + 1, flags)))\n  {\n    result= (st_bookmark*) alloc_root(&plugin_mem_root,\n                                      sizeof(struct st_bookmark) + length-1);\n    varname[0]= flags & PLUGIN_VAR_TYPEMASK;\n    memcpy(result->key, varname, length);\n    result->name_len= length - 2;\n    result->offset= -1;\n\n    DBUG_ASSERT(size && !(size & (size-1))); /* must be power of 2 */\n\n    offset= global_system_variables.dynamic_variables_size;\n    offset= (offset + size - 1) & ~(size - 1);\n    result->offset= (int) offset;\n\n    new_size= (offset + size + 63) & ~63;\n\n    if (new_size > global_variables_dynamic_size)\n    {\n      global_system_variables.dynamic_variables_ptr= (char*)\n        my_realloc(global_system_variables.dynamic_variables_ptr, new_size,\n                   MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n      max_system_variables.dynamic_variables_ptr= (char*)\n        my_realloc(max_system_variables.dynamic_variables_ptr, new_size,\n                   MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n      /*\n        Clear the new variable value space. This is required for string\n        variables. If their value is non-NULL, it must point to a valid\n        string.\n      */\n      bzero(global_system_variables.dynamic_variables_ptr +\n            global_variables_dynamic_size,\n            new_size - global_variables_dynamic_size);\n      bzero(max_system_variables.dynamic_variables_ptr +\n            global_variables_dynamic_size,\n            new_size - global_variables_dynamic_size);\n      global_variables_dynamic_size= new_size;\n    }\n\n    global_system_variables.dynamic_variables_head= offset;\n    max_system_variables.dynamic_variables_head= offset;\n    global_system_variables.dynamic_variables_size= offset + size;\n    max_system_variables.dynamic_variables_size= offset + size;\n    global_system_variables.dynamic_variables_version++;\n    max_system_variables.dynamic_variables_version++;\n\n    result->version= global_system_variables.dynamic_variables_version;\n\n    /* this should succeed because we have already checked if a dup exists */\n    if (my_hash_insert(&bookmark_hash, (uchar*) result))\n    {\n      fprintf(stderr, \"failed to add placeholder to hash\");\n      DBUG_ASSERT(0);\n    }\n  }\n  my_afree(varname);\n  return result;\n}\n\nstatic void restore_pluginvar_names(sys_var *first)\n{\n  for (sys_var *var= first; var; var= var->next)\n  {\n    sys_var_pluginvar *pv= var->cast_pluginvar();\n    pv->plugin_var->name= pv->orig_pluginvar_name;\n  }\n}\n\n\n/*\n  returns a pointer to the memory which holds the thd-local variable or\n  a pointer to the global variable if thd==null.\n  If required, will sync with global variables if the requested variable\n  has not yet been allocated in the current thread.\n*/\nstatic uchar *intern_sys_var_ptr(THD* thd, int offset, bool global_lock)\n{\n  DBUG_ASSERT(offset >= 0);\n  DBUG_ASSERT((uint)offset <= global_system_variables.dynamic_variables_head);\n\n  if (!thd)\n    return (uchar*) global_system_variables.dynamic_variables_ptr + offset;\n\n  /*\n    dynamic_variables_head points to the largest valid offset\n  */\n  if (!thd->variables.dynamic_variables_ptr ||\n      (uint)offset > thd->variables.dynamic_variables_head)\n  {\n    uint idx;\n\n    mysql_rwlock_rdlock(&LOCK_system_variables_hash);\n\n    thd->variables.dynamic_variables_ptr= (char*)\n      my_realloc(thd->variables.dynamic_variables_ptr,\n                 global_variables_dynamic_size,\n                 MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n\n    if (global_lock)\n      mysql_mutex_lock(&LOCK_global_system_variables);\n\n    mysql_mutex_assert_owner(&LOCK_global_system_variables);\n\n    memcpy(thd->variables.dynamic_variables_ptr +\n             thd->variables.dynamic_variables_size,\n           global_system_variables.dynamic_variables_ptr +\n             thd->variables.dynamic_variables_size,\n           global_system_variables.dynamic_variables_size -\n             thd->variables.dynamic_variables_size);\n\n    /*\n      now we need to iterate through any newly copied 'defaults'\n      and if it is a string type with MEMALLOC flag, we need to strdup\n    */\n    for (idx= 0; idx < bookmark_hash.records; idx++)\n    {\n      sys_var_pluginvar *pi;\n      sys_var *var;\n      st_bookmark *v= (st_bookmark*) my_hash_element(&bookmark_hash,idx);\n\n      if (v->version <= thd->variables.dynamic_variables_version ||\n          !(var= intern_find_sys_var(v->key + 1, v->name_len)) ||\n          !(pi= var->cast_pluginvar()) ||\n          v->key[0] != (pi->plugin_var->flags & PLUGIN_VAR_TYPEMASK))\n        continue;\n\n      /* Here we do anything special that may be required of the data types */\n\n      if ((pi->plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR &&\n          pi->plugin_var->flags & PLUGIN_VAR_MEMALLOC)\n      {\n         int varoff= *(int *) (pi->plugin_var + 1);\n         char **thdvar= (char **) (thd->variables.\n                                   dynamic_variables_ptr + varoff);\n         char **sysvar= (char **) (global_system_variables.\n                                   dynamic_variables_ptr + varoff);\n         *thdvar= NULL;\n         plugin_var_memalloc_session_update(thd, NULL, thdvar, *sysvar);\n      }\n    }\n\n    if (global_lock)\n      mysql_mutex_unlock(&LOCK_global_system_variables);\n\n    thd->variables.dynamic_variables_version=\n           global_system_variables.dynamic_variables_version;\n    thd->variables.dynamic_variables_head=\n           global_system_variables.dynamic_variables_head;\n    thd->variables.dynamic_variables_size=\n           global_system_variables.dynamic_variables_size;\n\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  }\n  return (uchar*)thd->variables.dynamic_variables_ptr + offset;\n}\n\n\n/**\n  For correctness and simplicity's sake, a pointer to a function\n  must be compatible with pointed-to type, that is, the return and\n  parameters types must be the same. Thus, a callback function is\n  defined for each scalar type. The functions are assigned in\n  construct_options to their respective types.\n*/\n\nstatic char *mysql_sys_var_char(THD* thd, int offset)\n{\n  return (char *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic int *mysql_sys_var_int(THD* thd, int offset)\n{\n  return (int *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic long *mysql_sys_var_long(THD* thd, int offset)\n{\n  return (long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned long *mysql_sys_var_ulong(THD* thd, int offset)\n{\n  return (unsigned long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic long long *mysql_sys_var_longlong(THD* thd, int offset)\n{\n  return (long long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned long long *mysql_sys_var_ulonglong(THD* thd, int offset)\n{\n  return (unsigned long long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic char **mysql_sys_var_str(THD* thd, int offset)\n{\n  return (char **) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic double *mysql_sys_var_double(THD* thd, int offset)\n{\n  return (double *) intern_sys_var_ptr(thd, offset, true);\n}\n\nvoid plugin_thdvar_init(THD *thd)\n{\n  plugin_ref old_table_plugin= thd->variables.table_plugin;\n  DBUG_ENTER(\"plugin_thdvar_init\");\n  \n  thd->variables.table_plugin= NULL;\n  cleanup_variables(thd, &thd->variables);\n  \n  thd->variables= global_system_variables;\n  thd->variables.table_plugin= NULL;\n\n  /* we are going to allocate these lazily */\n  thd->variables.dynamic_variables_version= 0;\n  thd->variables.dynamic_variables_size= 0;\n  thd->variables.dynamic_variables_ptr= 0;\n\n  mysql_mutex_lock(&LOCK_plugin);\n  thd->variables.table_plugin=\n        my_intern_plugin_lock(NULL, global_system_variables.table_plugin);\n  intern_plugin_unlock(NULL, old_table_plugin);\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Unlocks all system variables which hold a reference\n*/\nstatic void unlock_variables(THD *thd, struct system_variables *vars)\n{\n  intern_plugin_unlock(NULL, vars->table_plugin);\n  vars->table_plugin= NULL;\n}\n\n\n/*\n  Frees memory used by system variables\n\n  Unlike plugin_vars_free_values() it frees all variables of all plugins,\n  it's used on shutdown.\n*/\nstatic void cleanup_variables(THD *thd, struct system_variables *vars)\n{\n  if (thd)\n    plugin_var_memalloc_free(&thd->variables);\n\n  DBUG_ASSERT(vars->table_plugin == NULL);\n\n  my_free(vars->dynamic_variables_ptr);\n  vars->dynamic_variables_ptr= NULL;\n  vars->dynamic_variables_size= 0;\n  vars->dynamic_variables_version= 0;\n}\n\n\nvoid plugin_thdvar_cleanup(THD *thd)\n{\n  uint idx;\n  plugin_ref *list;\n  DBUG_ENTER(\"plugin_thdvar_cleanup\");\n\n  mysql_mutex_lock(&LOCK_plugin);\n\n  unlock_variables(thd, &thd->variables);\n  cleanup_variables(thd, &thd->variables);\n\n  if ((idx= thd->lex->plugins.elements))\n  {\n    list= ((plugin_ref*) thd->lex->plugins.buffer) + idx - 1;\n    DBUG_PRINT(\"info\",(\"unlocking %d plugins\", idx));\n    while ((uchar*) list >= thd->lex->plugins.buffer)\n      intern_plugin_unlock(NULL, *list--);\n  }\n\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  reset_dynamic(&thd->lex->plugins);\n\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  @brief Free values of thread variables of a plugin.\n\n  This must be called before a plugin is deleted. Otherwise its\n  variables are no longer accessible and the value space is lost. Note\n  that only string values with PLUGIN_VAR_MEMALLOC are allocated and\n  must be freed.\n\n  @param[in]        vars        Chain of system variables of a plugin\n*/\n\nstatic void plugin_vars_free_values(sys_var *vars)\n{\n  DBUG_ENTER(\"plugin_vars_free_values\");\n\n  for (sys_var *var= vars; var; var= var->next)\n  {\n    sys_var_pluginvar *piv= var->cast_pluginvar();\n    if (piv &&\n        ((piv->plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR) &&\n        (piv->plugin_var->flags & PLUGIN_VAR_MEMALLOC))\n    {\n      /* Free the string from global_system_variables. */\n      char **valptr= (char**) piv->real_value_ptr(NULL, OPT_GLOBAL);\n      DBUG_PRINT(\"plugin\", (\"freeing value for: '%s'  addr: 0x%lx\",\n                            var->name.str, (long) valptr));\n      my_free(*valptr);\n      *valptr= NULL;\n    }\n  }\n  DBUG_VOID_RETURN;\n}\n\nstatic SHOW_TYPE pluginvar_show_type(st_mysql_sys_var *plugin_var)\n{\n  switch (plugin_var->flags & PLUGIN_VAR_TYPEMASK) {\n  case PLUGIN_VAR_BOOL:\n    return SHOW_MY_BOOL;\n  case PLUGIN_VAR_INT:\n    return SHOW_INT;\n  case PLUGIN_VAR_LONG:\n    return SHOW_LONG;\n  case PLUGIN_VAR_LONGLONG:\n    return SHOW_LONGLONG;\n  case PLUGIN_VAR_STR:\n    return SHOW_CHAR_PTR;\n  case PLUGIN_VAR_ENUM:\n  case PLUGIN_VAR_SET:\n    return SHOW_CHAR;\n  case PLUGIN_VAR_DOUBLE:\n    return SHOW_DOUBLE;\n  default:\n    DBUG_ASSERT(0);\n    return SHOW_UNDEF;\n  }\n}\n\n\n/**\n  Set value for thread local variable with PLUGIN_VAR_MEMALLOC flag.\n\n  @param[in]     thd   Thread context.\n  @param[in]     var   Plugin variable.\n  @param[in,out] dest  Destination memory pointer.\n  @param[in]     value '\\0'-terminated new value.\n\n  Most plugin variable values are stored on dynamic_variables_ptr.\n  Releasing memory occupied by these values is as simple as freeing\n  dynamic_variables_ptr.\n\n  An exception to the rule are PLUGIN_VAR_MEMALLOC variables, which\n  are stored on individual memory hunks. All of these hunks has to\n  be freed when it comes to cleanup.\n\n  It may happen that a plugin was uninstalled and descriptors of\n  it's variables are lost. In this case it is impossible to locate\n  corresponding values.\n\n  In addition to allocating and setting variable value, new element\n  is added to dynamic_variables_allocs list. When thread is done, it\n  has to call plugin_var_memalloc_free() to release memory used by\n  PLUGIN_VAR_MEMALLOC variables.\n\n  If var is NULL, variable update function is not called. This is\n  needed when we take snapshot of system variables during thread\n  initialization.\n\n  @note List element and variable value are stored on the same memory\n  hunk. List element is followed by variable value.\n\n  @return Completion status\n  @retval false Success\n  @retval true  Failure\n*/\n\nstatic bool plugin_var_memalloc_session_update(THD *thd,\n                                               struct st_mysql_sys_var *var,\n                                               char **dest, const char *value)\n\n{\n  LIST *old_element= NULL;\n  struct system_variables *vars= &thd->variables;\n  DBUG_ENTER(\"plugin_var_memalloc_session_update\");\n\n  if (value)\n  {\n    size_t length= strlen(value) + 1;\n    LIST *element;\n    if (!(element= (LIST *) my_malloc(sizeof(LIST) + length, MYF(MY_WME))))\n      DBUG_RETURN(true);\n    memcpy(element + 1, value, length);\n    value= (const char *) (element + 1);\n    vars->dynamic_variables_allocs= list_add(vars->dynamic_variables_allocs,\n                                             element);\n  }\n\n  if (*dest)\n    old_element= (LIST *) (*dest - sizeof(LIST));\n\n  if (var)\n    var->update(thd, var, (void **) dest, (const void *) &value);\n  else\n    *dest= (char *) value;\n\n  if (old_element)\n  {\n    vars->dynamic_variables_allocs= list_delete(vars->dynamic_variables_allocs,\n                                                old_element);\n    my_free(old_element);\n  }\n  DBUG_RETURN(false);\n}\n\n\n/**\n  Free all elements allocated by plugin_var_memalloc_session_update().\n\n  @param[in]     vars  system variables structure\n\n  @see plugin_var_memalloc_session_update\n*/\n\nstatic void plugin_var_memalloc_free(struct system_variables *vars)\n{\n  LIST *next, *root;\n  DBUG_ENTER(\"plugin_var_memalloc_free\");\n  for (root= vars->dynamic_variables_allocs; root; root= next)\n  {\n    next= root->next;\n    my_free(root);\n  }\n  vars->dynamic_variables_allocs= NULL;\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  Set value for global variable with PLUGIN_VAR_MEMALLOC flag.\n\n  @param[in]     thd   Thread context.\n  @param[in]     var   Plugin variable.\n  @param[in,out] dest  Destination memory pointer.\n  @param[in]     value '\\0'-terminated new value.\n\n  @return Completion status\n  @retval false Success\n  @retval true  Failure\n*/\n\nstatic bool plugin_var_memalloc_global_update(THD *thd,\n                                              struct st_mysql_sys_var *var,\n                                              char **dest, const char *value)\n{\n  char *old_value= *dest;\n  DBUG_ENTER(\"plugin_var_memalloc_global_update\");\n\n  if (value && !(value= my_strdup(value, MYF(MY_WME))))\n    DBUG_RETURN(true);\n\n  var->update(thd, var, (void **) dest, (const void *) &value);\n\n  if (old_value)\n    my_free(old_value);\n\n  DBUG_RETURN(false);\n}\n\n\nbool sys_var_pluginvar::check_update_type(Item_result type)\n{\n  switch (plugin_var->flags & PLUGIN_VAR_TYPEMASK) {\n  case PLUGIN_VAR_INT:\n  case PLUGIN_VAR_LONG:\n  case PLUGIN_VAR_LONGLONG:\n    return type != INT_RESULT;\n  case PLUGIN_VAR_STR:\n    return type != STRING_RESULT;\n  case PLUGIN_VAR_ENUM:\n  case PLUGIN_VAR_BOOL:\n  case PLUGIN_VAR_SET:\n    return type != STRING_RESULT && type != INT_RESULT;\n  case PLUGIN_VAR_DOUBLE:\n    return type != INT_RESULT && type != REAL_RESULT && type != DECIMAL_RESULT;\n  default:\n    return true;\n  }\n}\n\n\nuchar* sys_var_pluginvar::real_value_ptr(THD *thd, enum_var_type type)\n{\n  DBUG_ASSERT(thd || (type == OPT_GLOBAL));\n  if (plugin_var->flags & PLUGIN_VAR_THDLOCAL)\n  {\n    if (type == OPT_GLOBAL)\n      thd= NULL;\n\n    return intern_sys_var_ptr(thd, *(int*) (plugin_var+1), false);\n  }\n  return *(uchar**) (plugin_var+1);\n}\n\n\nTYPELIB* sys_var_pluginvar::plugin_var_typelib(void)\n{\n  switch (plugin_var->flags & (PLUGIN_VAR_TYPEMASK | PLUGIN_VAR_THDLOCAL)) {\n  case PLUGIN_VAR_ENUM:\n    return ((sysvar_enum_t *)plugin_var)->typelib;\n  case PLUGIN_VAR_SET:\n    return ((sysvar_set_t *)plugin_var)->typelib;\n  case PLUGIN_VAR_ENUM | PLUGIN_VAR_THDLOCAL:\n    return ((thdvar_enum_t *)plugin_var)->typelib;\n  case PLUGIN_VAR_SET | PLUGIN_VAR_THDLOCAL:\n    return ((thdvar_set_t *)plugin_var)->typelib;\n  default:\n    return NULL;\n  }\n  return NULL;\t/* Keep compiler happy */\n}\n\n\nuchar* sys_var_pluginvar::do_value_ptr(THD *thd, enum_var_type type,\n                                       LEX_STRING *base)\n{\n  uchar* result;\n\n  result= real_value_ptr(thd, type);\n\n  if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_ENUM)\n    result= (uchar*) get_type(plugin_var_typelib(), *(ulong*)result);\n  else if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_SET)\n    result= (uchar*) set_to_string(thd, 0, *(ulonglong*) result,\n                                   plugin_var_typelib()->type_names);\n  return result;\n}\n\nbool sys_var_pluginvar::do_check(THD *thd, set_var *var)\n{\n  st_item_value_holder value;\n  DBUG_ASSERT(!is_readonly());\n  DBUG_ASSERT(plugin_var->check);\n\n  value.value_type= item_value_type;\n  value.val_str= item_val_str;\n  value.val_int= item_val_int;\n  value.val_real= item_val_real;\n  value.is_unsigned= item_is_unsigned;\n  value.item= var->value;\n\n  return plugin_var->check(thd, plugin_var, &var->save_result, &value);\n}\n\nbool sys_var_pluginvar::session_update(THD *thd, set_var *var)\n{\n  bool rc= false;\n  DBUG_ASSERT(!is_readonly());\n  DBUG_ASSERT(plugin_var->flags & PLUGIN_VAR_THDLOCAL);\n  DBUG_ASSERT(thd == current_thd);\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  void *tgt= real_value_ptr(thd, var->type);\n  const void *src= var->value ? (void*)&var->save_result\n                              : (void*)real_value_ptr(thd, OPT_GLOBAL);\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR &&\n      plugin_var->flags & PLUGIN_VAR_MEMALLOC)\n    rc= plugin_var_memalloc_session_update(thd, plugin_var, (char **) tgt,\n                                           *(const char **) src);\n  else \n    plugin_var->update(thd, plugin_var, tgt, src);\n\n  return rc;\n}\n\nbool sys_var_pluginvar::global_update(THD *thd, set_var *var)\n{\n  bool rc= false;\n  DBUG_ASSERT(!is_readonly());\n  mysql_mutex_assert_owner(&LOCK_global_system_variables);\n\n  void *tgt= real_value_ptr(thd, var->type);\n  const void *src= &var->save_result;\n\n  if (!var->value)\n  {\n    switch (plugin_var->flags & (PLUGIN_VAR_TYPEMASK | PLUGIN_VAR_THDLOCAL)) {\n    case PLUGIN_VAR_INT:\n      src= &((sysvar_uint_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_LONG:\n      src= &((sysvar_ulong_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_LONGLONG:\n      src= &((sysvar_ulonglong_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_ENUM:\n      src= &((sysvar_enum_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_SET:\n      src= &((sysvar_set_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_BOOL:\n      src= &((sysvar_bool_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_STR:\n      src= &((sysvar_str_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_DOUBLE:\n      src= &((sysvar_double_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_INT | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_uint_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_LONG | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_ulong_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_ulonglong_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_ENUM | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_enum_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_SET | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_set_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_BOOL | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_bool_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_STR | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_str_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_DOUBLE | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_double_t*) plugin_var)->def_val;\n      break;\n    default:\n      DBUG_ASSERT(0);\n    }\n  }\n\n  if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR &&\n      plugin_var->flags & PLUGIN_VAR_MEMALLOC)\n    rc= plugin_var_memalloc_global_update(thd, plugin_var, (char **) tgt,\n                                          *(const char **) src);\n  else \n    plugin_var->update(thd, plugin_var, tgt, src);\n\n  return rc;\n}\n\n\n#define OPTION_SET_LIMITS(type, options, opt) \\\n  options->var_type= type; \\\n  options->def_value= (opt)->def_val; \\\n  options->min_value= (opt)->min_val; \\\n  options->max_value= (opt)->max_val; \\\n  options->block_size= (long) (opt)->blk_sz\n\n#define OPTION_SET_LIMITS_DOUBLE(options, opt) \\\n  options->var_type= GET_DOUBLE; \\\n  options->def_value= (longlong) getopt_double2ulonglong((opt)->def_val); \\\n  options->min_value= (longlong) getopt_double2ulonglong((opt)->min_val); \\\n  options->max_value= getopt_double2ulonglong((opt)->max_val); \\\n  options->block_size= (long) (opt)->blk_sz;\n\n\nstatic void plugin_opt_set_limits(struct my_option *options,\n                                  const struct st_mysql_sys_var *opt)\n{\n  options->sub_size= 0;\n\n  switch (opt->flags & (PLUGIN_VAR_TYPEMASK |\n                        PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL)) {\n  /* global system variables */\n  case PLUGIN_VAR_INT:\n    OPTION_SET_LIMITS(GET_INT, options, (sysvar_int_t*) opt);\n    break;\n  case PLUGIN_VAR_INT | PLUGIN_VAR_UNSIGNED:\n    OPTION_SET_LIMITS(GET_UINT, options, (sysvar_uint_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG:\n    OPTION_SET_LIMITS(GET_LONG, options, (sysvar_long_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_UNSIGNED:\n    OPTION_SET_LIMITS(GET_ULONG, options, (sysvar_ulong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG:\n    OPTION_SET_LIMITS(GET_LL, options, (sysvar_longlong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_UNSIGNED:\n    OPTION_SET_LIMITS(GET_ULL, options, (sysvar_ulonglong_t*) opt);\n    break;\n  case PLUGIN_VAR_ENUM:\n    options->var_type= GET_ENUM;\n    options->typelib= ((sysvar_enum_t*) opt)->typelib;\n    options->def_value= ((sysvar_enum_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= options->typelib->count - 1;\n    break;\n  case PLUGIN_VAR_SET:\n    options->var_type= GET_SET;\n    options->typelib= ((sysvar_set_t*) opt)->typelib;\n    options->def_value= ((sysvar_set_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= (1ULL << options->typelib->count) - 1;\n    break;\n  case PLUGIN_VAR_BOOL:\n    options->var_type= GET_BOOL;\n    options->def_value= ((sysvar_bool_t*) opt)->def_val;\n    break;\n  case PLUGIN_VAR_STR:\n    options->var_type= ((opt->flags & PLUGIN_VAR_MEMALLOC) ?\n                        GET_STR_ALLOC : GET_STR);\n    options->def_value= (intptr) ((sysvar_str_t*) opt)->def_val;\n    break;\n  case PLUGIN_VAR_DOUBLE:\n    OPTION_SET_LIMITS_DOUBLE(options, (sysvar_double_t*) opt);\n    break;\n  /* threadlocal variables */\n  case PLUGIN_VAR_INT | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_INT, options, (thdvar_int_t*) opt);\n    break;\n  case PLUGIN_VAR_INT | PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_UINT, options, (thdvar_uint_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_LONG, options, (thdvar_long_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_ULONG, options, (thdvar_ulong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_LL, options, (thdvar_longlong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_ULL, options, (thdvar_ulonglong_t*) opt);\n    break;\n  case PLUGIN_VAR_DOUBLE | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS_DOUBLE(options, (thdvar_double_t*) opt);\n    break;\n  case PLUGIN_VAR_ENUM | PLUGIN_VAR_THDLOCAL:\n    options->var_type= GET_ENUM;\n    options->typelib= ((thdvar_enum_t*) opt)->typelib;\n    options->def_value= ((thdvar_enum_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= options->typelib->count - 1;\n    break;\n  case PLUGIN_VAR_SET | PLUGIN_VAR_THDLOCAL:\n    options->var_type= GET_SET;\n    options->typelib= ((thdvar_set_t*) opt)->typelib;\n    options->def_value= ((thdvar_set_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= (1ULL << options->typelib->count) - 1;\n    break;\n  case PLUGIN_VAR_BOOL | PLUGIN_VAR_THDLOCAL:\n    options->var_type= GET_BOOL;\n    options->def_value= ((thdvar_bool_t*) opt)->def_val;\n    break;\n  case PLUGIN_VAR_STR | PLUGIN_VAR_THDLOCAL:\n    options->var_type= ((opt->flags & PLUGIN_VAR_MEMALLOC) ?\n                        GET_STR_ALLOC : GET_STR);\n    options->def_value= (intptr) ((thdvar_str_t*) opt)->def_val;\n    break;\n  default:\n    DBUG_ASSERT(0);\n  }\n  options->arg_type= REQUIRED_ARG;\n  if (opt->flags & PLUGIN_VAR_NOCMDARG)\n    options->arg_type= NO_ARG;\n  if (opt->flags & PLUGIN_VAR_OPCMDARG)\n    options->arg_type= OPT_ARG;\n}\n\nextern \"C\" my_bool get_one_plugin_option(int optid, const struct my_option *,\n                                         char *);\n\nmy_bool get_one_plugin_option(int optid __attribute__((unused)),\n                              const struct my_option *opt,\n                              char *argument)\n{\n  return 0;\n}\n\n\n/**\n  Creates a set of my_option objects associated with a specified plugin-\n  handle.\n\n  @param mem_root Memory allocator to be used.\n  @param tmp A pointer to a plugin handle\n  @param[out] options A pointer to a pre-allocated static array\n\n  The set is stored in the pre-allocated static array supplied to the function.\n  The size of the array is calculated as (number_of_plugin_varaibles*2+3). The\n  reason is that each option can have a prefix '--plugin-' in addtion to the\n  shorter form '--&lt;plugin-name&gt;'. There is also space allocated for\n  terminating NULL pointers.\n\n  @return\n    @retval -1 An error occurred\n    @retval 0 Success\n*/\n\nstatic int construct_options(MEM_ROOT *mem_root, struct st_plugin_int *tmp,\n                             my_option *options)\n{\n  const char *plugin_name= tmp->plugin->name;\n  const LEX_STRING plugin_dash = { C_STRING_WITH_LEN(\"plugin-\") };\n  uint plugin_name_len= strlen(plugin_name);\n  uint optnamelen;\n  const int max_comment_len= 180;\n  char *comment= (char *) alloc_root(mem_root, max_comment_len + 1);\n  char *optname;\n\n  int index= 0, offset= 0;\n  st_mysql_sys_var *opt, **plugin_option;\n  st_bookmark *v;\n\n  /** Used to circumvent the const attribute on my_option::name */\n  char *plugin_name_ptr, *plugin_name_with_prefix_ptr;\n\n  DBUG_ENTER(\"construct_options\");\n\n  plugin_name_ptr= (char*) alloc_root(mem_root, plugin_name_len + 1);\n  strcpy(plugin_name_ptr, plugin_name);\n  my_casedn_str(&my_charset_latin1, plugin_name_ptr);\n  convert_underscore_to_dash(plugin_name_ptr, plugin_name_len);\n  plugin_name_with_prefix_ptr= (char*) alloc_root(mem_root,\n                                                  plugin_name_len +\n                                                  plugin_dash.length + 1);\n  strxmov(plugin_name_with_prefix_ptr, plugin_dash.str, plugin_name_ptr, NullS);\n\n  if (tmp->load_option != PLUGIN_FORCE &&\n      tmp->load_option != PLUGIN_FORCE_PLUS_PERMANENT)\n  {\n    /* support --skip-plugin-foo syntax */\n    options[0].name= plugin_name_ptr;\n    options[1].name= plugin_name_with_prefix_ptr;\n    options[0].id= options[1].id= 0;\n    options[0].var_type= options[1].var_type= GET_ENUM;\n    options[0].arg_type= options[1].arg_type= OPT_ARG;\n    options[0].def_value= options[1].def_value= 1; /* ON */\n    options[0].typelib= options[1].typelib= &global_plugin_typelib;\n\n    strxnmov(comment, max_comment_len, \"Enable or disable \", plugin_name,\n            \" plugin. Possible values are ON, OFF, FORCE (don't start \"\n            \"if the plugin fails to load).\", NullS);\n    options[0].comment= comment;\n    /*\n      Allocate temporary space for the value of the tristate.\n      This option will have a limited lifetime and is not used beyond\n      server initialization.\n      GET_ENUM value is an unsigned long integer.\n    */\n    options[0].value= options[1].value=\n                      (uchar **)alloc_root(mem_root, sizeof(ulong));\n    *((ulong*) options[0].value)= (ulong) options[0].def_value;\n\n    options+= 2;\n  }\n\n  if (!my_strcasecmp(&my_charset_latin1, plugin_name_ptr, \"NDBCLUSTER\"))\n  {\n    plugin_name_ptr= const_cast<char*>(\"ndb\"); // Use legacy \"ndb\" prefix\n    plugin_name_len= 3;\n  }\n\n  /*\n    Two passes as the 2nd pass will take pointer addresses for use\n    by my_getopt and register_var() in the first pass uses realloc\n  */\n\n  for (plugin_option= tmp->plugin->system_vars;\n       plugin_option && *plugin_option; plugin_option++, index++)\n  {\n    opt= *plugin_option;\n    if (!(opt->flags & PLUGIN_VAR_THDLOCAL))\n      continue;\n    if (!(register_var(plugin_name_ptr, opt->name, opt->flags)))\n      continue;\n    switch (opt->flags & PLUGIN_VAR_TYPEMASK) {\n    case PLUGIN_VAR_BOOL:\n      ((thdvar_bool_t *) opt)->resolve= mysql_sys_var_char;\n      break;\n    case PLUGIN_VAR_INT:\n      ((thdvar_int_t *) opt)->resolve= mysql_sys_var_int;\n      break;\n    case PLUGIN_VAR_LONG:\n      ((thdvar_long_t *) opt)->resolve= mysql_sys_var_long;\n      break;\n    case PLUGIN_VAR_LONGLONG:\n      ((thdvar_longlong_t *) opt)->resolve= mysql_sys_var_longlong;\n      break;\n    case PLUGIN_VAR_STR:\n      ((thdvar_str_t *) opt)->resolve= mysql_sys_var_str;\n      break;\n    case PLUGIN_VAR_ENUM:\n      ((thdvar_enum_t *) opt)->resolve= mysql_sys_var_ulong;\n      break;\n    case PLUGIN_VAR_SET:\n      ((thdvar_set_t *) opt)->resolve= mysql_sys_var_ulonglong;\n      break;\n    case PLUGIN_VAR_DOUBLE:\n      ((thdvar_double_t *) opt)->resolve= mysql_sys_var_double;\n      break;\n    default:\n      sql_print_error(\"Unknown variable type code 0x%x in plugin '%s'.\",\n                      opt->flags, plugin_name);\n      DBUG_RETURN(-1);\n    };\n  }\n\n  for (plugin_option= tmp->plugin->system_vars;\n       plugin_option && *plugin_option; plugin_option++, index++)\n  {\n    switch ((opt= *plugin_option)->flags & PLUGIN_VAR_TYPEMASK) {\n    case PLUGIN_VAR_BOOL:\n      if (!opt->check)\n        opt->check= check_func_bool;\n      if (!opt->update)\n        opt->update= update_func_bool;\n      break;\n    case PLUGIN_VAR_INT:\n      if (!opt->check)\n        opt->check= check_func_int;\n      if (!opt->update)\n        opt->update= update_func_int;\n      break;\n    case PLUGIN_VAR_LONG:\n      if (!opt->check)\n        opt->check= check_func_long;\n      if (!opt->update)\n        opt->update= update_func_long;\n      break;\n    case PLUGIN_VAR_LONGLONG:\n      if (!opt->check)\n        opt->check= check_func_longlong;\n      if (!opt->update)\n        opt->update= update_func_longlong;\n      break;\n    case PLUGIN_VAR_STR:\n      if (!opt->check)\n        opt->check= check_func_str;\n      if (!opt->update)\n      {\n        opt->update= update_func_str;\n        if (!(opt->flags & (PLUGIN_VAR_MEMALLOC | PLUGIN_VAR_READONLY)))\n        {\n          opt->flags|= PLUGIN_VAR_READONLY;\n          sql_print_warning(\"Server variable %s of plugin %s was forced \"\n                            \"to be read-only: string variable without \"\n                            \"update_func and PLUGIN_VAR_MEMALLOC flag\",\n                            opt->name, plugin_name);\n        }\n      }\n      break;\n    case PLUGIN_VAR_ENUM:\n      if (!opt->check)\n        opt->check= check_func_enum;\n      if (!opt->update)\n        opt->update= update_func_long;\n      break;\n    case PLUGIN_VAR_SET:\n      if (!opt->check)\n        opt->check= check_func_set;\n      if (!opt->update)\n        opt->update= update_func_longlong;\n      break;\n    case PLUGIN_VAR_DOUBLE:\n      if (!opt->check)\n        opt->check= check_func_double;\n      if (!opt->update)\n        opt->update= update_func_double;\n      break;\n    default:\n      sql_print_error(\"Unknown variable type code 0x%x in plugin '%s'.\",\n                      opt->flags, plugin_name);\n      DBUG_RETURN(-1);\n    }\n\n    if ((opt->flags & (PLUGIN_VAR_NOCMDOPT | PLUGIN_VAR_THDLOCAL))\n                    == PLUGIN_VAR_NOCMDOPT)\n      continue;\n\n    if (!opt->name)\n    {\n      sql_print_error(\"Missing variable name in plugin '%s'.\",\n                      plugin_name);\n      DBUG_RETURN(-1);\n    }\n\n    if (!(opt->flags & PLUGIN_VAR_THDLOCAL))\n    {\n      optnamelen= strlen(opt->name);\n      optname= (char*) alloc_root(mem_root, plugin_name_len + optnamelen + 2);\n      strxmov(optname, plugin_name_ptr, \"-\", opt->name, NullS);\n      optnamelen= plugin_name_len + optnamelen + 1;\n    }\n    else\n    {\n      /* this should not fail because register_var should create entry */\n      if (!(v= find_bookmark(plugin_name_ptr, opt->name, opt->flags)))\n      {\n        sql_print_error(\"Thread local variable '%s' not allocated \"\n                        \"in plugin '%s'.\", opt->name, plugin_name);\n        DBUG_RETURN(-1);\n      }\n\n      *(int*)(opt + 1)= offset= v->offset;\n\n      if (opt->flags & PLUGIN_VAR_NOCMDOPT)\n        continue;\n\n      optname= (char*) memdup_root(mem_root, v->key + 1, \n                                   (optnamelen= v->name_len) + 1);\n    }\n\n    convert_underscore_to_dash(optname, optnamelen);\n\n    options->name= optname;\n    options->comment= opt->comment;\n    options->app_type= opt;\n    options->id= 0;\n\n    plugin_opt_set_limits(options, opt);\n\n    if (opt->flags & PLUGIN_VAR_THDLOCAL)\n      options->value= options->u_max_value= (uchar**)\n        (global_system_variables.dynamic_variables_ptr + offset);\n    else\n      options->value= options->u_max_value= *(uchar***) (opt + 1);\n\n    char *option_name_ptr;\n    options[1]= options[0];\n    options[1].name= option_name_ptr= (char*) alloc_root(mem_root,\n                                                        plugin_dash.length +\n                                                        optnamelen + 1);\n    options[1].comment= 0; /* Hidden from the help text */\n    strxmov(option_name_ptr, plugin_dash.str, optname, NullS);\n\n    options+= 2;\n  }\n\n  DBUG_RETURN(0);\n}\n\n\nstatic my_option *construct_help_options(MEM_ROOT *mem_root,\n                                         struct st_plugin_int *p)\n{\n  st_mysql_sys_var **opt;\n  my_option *opts;\n  uint count= EXTRA_OPTIONS;\n  DBUG_ENTER(\"construct_help_options\");\n\n  for (opt= p->plugin->system_vars; opt && *opt; opt++, count+= 2)\n    ;\n\n  if (!(opts= (my_option*) alloc_root(mem_root, sizeof(my_option) * count)))\n    DBUG_RETURN(NULL);\n\n  bzero(opts, sizeof(my_option) * count);\n\n  /**\n    some plugin variables (those that don't have PLUGIN_VAR_NOSYSVAR flag)\n    have their names prefixed with the plugin name. Restore the names here\n    to get the correct (not double-prefixed) help text.\n    We won't need @@sysvars anymore and don't care about their proper names.\n  */\n  restore_pluginvar_names(p->system_vars);\n\n  if (construct_options(mem_root, p, opts))\n    DBUG_RETURN(NULL);\n\n  DBUG_RETURN(opts);\n}\n\n/**\n  Create and register system variables supplied from the plugin and\n  assigns initial values from corresponding command line arguments.\n\n  @param tmp_root Temporary scratch space\n  @param[out] plugin Internal plugin structure\n  @param argc Number of command line arguments\n  @param argv Command line argument vector\n\n  The plugin will be updated with a policy on how to handle errors during\n  initialization.\n\n  @note Requires that a write-lock is held on LOCK_system_variables_hash\n\n  @return How initialization of the plugin should be handled.\n    @retval  0 Initialization should proceed.\n    @retval  1 Plugin is disabled.\n    @retval -1 An error has occurred.\n*/\n\nstatic int test_plugin_options(MEM_ROOT *tmp_root, struct st_plugin_int *tmp,\n                               int *argc, char **argv)\n{\n  struct sys_var_chain chain= { NULL, NULL };\n  bool disable_plugin;\n  enum_plugin_load_option plugin_load_option= tmp->load_option;\n\n  MEM_ROOT *mem_root= alloc_root_inited(&tmp->mem_root) ?\n                      &tmp->mem_root : &plugin_mem_root;\n  st_mysql_sys_var **opt;\n  my_option *opts= NULL;\n  LEX_STRING plugin_name;\n  char *varname;\n  int error;\n  sys_var *v __attribute__((unused));\n  struct st_bookmark *var;\n  uint len, count= EXTRA_OPTIONS;\n  DBUG_ENTER(\"test_plugin_options\");\n  DBUG_ASSERT(tmp->plugin && tmp->name.str);\n\n  /*\n    The 'federated' and 'ndbcluster' storage engines are always disabled by\n    default.\n  */\n  if (!(my_strcasecmp(&my_charset_latin1, tmp->name.str, \"federated\") &&\n      my_strcasecmp(&my_charset_latin1, tmp->name.str, \"ndbcluster\")))\n    plugin_load_option= PLUGIN_OFF;\n\n  for (opt= tmp->plugin->system_vars; opt && *opt; opt++)\n    count+= 2; /* --{plugin}-{optname} and --plugin-{plugin}-{optname} */\n\n  if (count > EXTRA_OPTIONS || (*argc > 1))\n  {\n    if (!(opts= (my_option*) alloc_root(tmp_root, sizeof(my_option) * count)))\n    {\n      sql_print_error(\"Out of memory for plugin '%s'.\", tmp->name.str);\n      DBUG_RETURN(-1);\n    }\n    bzero(opts, sizeof(my_option) * count);\n\n    if (construct_options(tmp_root, tmp, opts))\n    {\n      sql_print_error(\"Bad options for plugin '%s'.\", tmp->name.str);\n      DBUG_RETURN(-1);\n    }\n\n    /*\n      We adjust the default value to account for the hardcoded exceptions\n      we have set for the federated and ndbcluster storage engines.\n    */\n    if (tmp->load_option != PLUGIN_FORCE &&\n        tmp->load_option != PLUGIN_FORCE_PLUS_PERMANENT)\n      opts[0].def_value= opts[1].def_value= plugin_load_option;\n\n    error= handle_options(argc, &argv, opts, NULL);\n    (*argc)++; /* add back one for the program name */\n\n    if (error)\n    {\n       sql_print_error(\"Parsing options for plugin '%s' failed.\",\n                       tmp->name.str);\n       goto err;\n    }\n    /*\n     Set plugin loading policy from option value. First element in the option\n     list is always the <plugin name> option value.\n    */\n    if (tmp->load_option != PLUGIN_FORCE &&\n        tmp->load_option != PLUGIN_FORCE_PLUS_PERMANENT)\n      plugin_load_option= (enum_plugin_load_option) *(ulong*) opts[0].value;\n  }\n\n  disable_plugin= (plugin_load_option == PLUGIN_OFF);\n  tmp->load_option= plugin_load_option;\n\n  /*\n    If the plugin is disabled it should not be initialized.\n  */\n  if (disable_plugin)\n  {\n    if (global_system_variables.log_warnings)\n      sql_print_information(\"Plugin '%s' is disabled.\",\n                            tmp->name.str);\n    if (opts)\n      my_cleanup_options(opts);\n    DBUG_RETURN(1);\n  }\n\n  if (!my_strcasecmp(&my_charset_latin1, tmp->name.str, \"NDBCLUSTER\"))\n  {\n    plugin_name.str= const_cast<char*>(\"ndb\"); // Use legacy \"ndb\" prefix\n    plugin_name.length= 3;\n  }\n  else\n    plugin_name= tmp->name;\n\n  error= 1;\n  for (opt= tmp->plugin->system_vars; opt && *opt; opt++)\n  {\n    st_mysql_sys_var *o;\n    if (((o= *opt)->flags & PLUGIN_VAR_NOSYSVAR))\n      continue;\n    if ((var= find_bookmark(plugin_name.str, o->name, o->flags)))\n      v= new (mem_root) sys_var_pluginvar(&chain, var->key + 1, o);\n    else\n    {\n      len= plugin_name.length + strlen(o->name) + 2;\n      varname= (char*) alloc_root(mem_root, len);\n      strxmov(varname, plugin_name.str, \"-\", o->name, NullS);\n      my_casedn_str(&my_charset_latin1, varname);\n      convert_dash_to_underscore(varname, len-1);\n      v= new (mem_root) sys_var_pluginvar(&chain, varname, o);\n    }\n    DBUG_ASSERT(v); /* check that an object was actually constructed */\n  } /* end for */\n  if (chain.first)\n  {\n    chain.last->next = NULL;\n    if (mysql_add_sys_var_chain(chain.first))\n    {\n      sql_print_error(\"Plugin '%s' has conflicting system variables\",\n                      tmp->name.str);\n      goto err;\n    }\n    tmp->system_vars= chain.first;\n  }\n  DBUG_RETURN(0);\n  \nerr:\n  if (opts)\n    my_cleanup_options(opts);\n  DBUG_RETURN(error);\n}\n\n\n/****************************************************************************\n  Help Verbose text with Plugin System Variables\n****************************************************************************/\n\n\nvoid add_plugin_options(DYNAMIC_ARRAY *options, MEM_ROOT *mem_root)\n{\n  struct st_plugin_int *p;\n  my_option *opt;\n\n  if (!initialized)\n    return;\n\n  for (uint idx= 0; idx < plugin_array.elements; idx++)\n  {\n    p= *dynamic_element(&plugin_array, idx, struct st_plugin_int **);\n\n    if (!(opt= construct_help_options(mem_root, p)))\n      continue;\n\n    /* Only options with a non-NULL comment are displayed in help text */\n    for (;opt->name; opt++)\n      if (opt->comment)\n        insert_dynamic(options, (uchar*) opt);\n  }\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/innobase/include/ut0mem.h",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/innobase/include/os0file.h",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/innobase/os/os0file.c",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/common/util/getarg.cat3",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/ndbapi/NdbUtil.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/ndbapi/NdbUtil.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/kernel/blocks/new-block.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/kernel/blocks/dbtc/Dbtc.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/kernel/blocks/dbdih/Dbdih.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/kernel/blocks/dbdict/Slave_AddTable.sfl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/kernel/blocks/dbdict/Dbdict.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/external/WIN32.x86/sci/lib/sisci_api_md.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/external/WIN32.x86/sci/lib/SISCI_LIBRARY_WIN32.TXT",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/external/WIN32.x86/sci/lib/sisci_api.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/external/WIN32.x86/sci/lib/scilib_mt.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/external/WIN32.x86/sci/lib/scilib_md.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/external/WIN32.x86/sci/lib/scilib.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/external/WIN32.x86/sci/lib/sisci_api_mt.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/cw/cpcc-win32/C++/Closed.ICO",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/cw/cpcc-win32/C++/CPC_GUI.suo",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/cw/cpcc-win32/C++/small.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/cw/cpcc-win32/C++/CPC_GUI.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/cw/cpcc-win32/C++/bmp00001.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/cw/cpcc-win32/C++/toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/cw/cpcc-win32/C++/Open.ICO",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/cw/cpcc-win32/csharp/NDB_CPC.ncb",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/cw/cpcc-win32/csharp/DATABASE.ICO",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/src/cw/cpcc-win32/csharp/App.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/include/ndbapi/NdbScanFilter.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/include/transporter/TransporterCallback.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/test/ndbapi/bank/BankLoad.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/test/src/NDBT_Tables.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/test/src/getarg.c",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/test/include/getarg.h",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/test/run-test/atrt-example.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/test/odbc/driver/testOdbcDriver.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/storage/ndb/test/odbc/client/SQLPrepareTest.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/sql-bench/server-cfg.sh",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/sql-bench/crash-me.sh",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/sql-bench/limits/mysql-4.0.cfg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/sql-bench/limits/mysql-4.1.cfg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/sql-bench/Comments/postgres.benchmark",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/strings/decimal.c",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/strings/string.doc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/strings/ctype-latin1.c",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/strings/ctype-czech.c",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/packaging/WiX/AdminBackground.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/packaging/WiX/AdminHeader.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/packaging/WiX/MySQLServer.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/tests/fork2_test.pl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/tests/function.tst",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/tests/function.res",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/extra/yassl/taocrypt/benchmark/dsa1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/extra/yassl/taocrypt/benchmark/rsa1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/extra/yassl/taocrypt/benchmark/dh1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/extra/yassl/taocrypt/certs/client-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/extra/yassl/taocrypt/certs/client-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/extra/yassl/taocrypt/certs/dsa512.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/extra/yassl/certs/client-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/extra/yassl/certs/dsa1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/extra/yassl/certs/client-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug37631.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug49823.CSM",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/corrupt-relay-bin.000624",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/old_table-323.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug49823.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/14897.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/loaddata6.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug11747416_32228_binlog.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/cluster_7022_table.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug16266.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug47205.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug48265.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/master-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug47142_master-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug46565.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug47012.ARM",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug19371.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/corrupt_t1#P#p1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug47012.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/cluster_7022_table.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug33029-slave-relay-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/binlog_savepoint.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug36055.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/trunc_binlog.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/binlog_transaction.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug47012.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug37631.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/corrupt_t1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug36055.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug19371.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug40482-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug36055.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug19371.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/vchar.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/bug46565.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6_2.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6_3.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/parts/t1TIMESTAMP.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p1_first_1024.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/parts/t1.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p2.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/parts/t1_blackhole.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p3.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p2.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p4.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51_data_le/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51_data_le/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51_data_le/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51_data_le/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51_data_le/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51_data_le/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51_data_be/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51_data_be/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51_data_be/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51_data_be/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51_data_be/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51_data_be/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-2-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-2.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-2.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-2.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-2-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-2.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/std_data/ndb_backup51/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/include/ctype_utf8mb4.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/rpl/r/rpl_charset_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/rpl/r/rpl_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/rpl/r/rpl_set_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/rpl/t/rpl_row_mysqlbinlog.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/rpl/t/rpl_set_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/rpl/t/rpl_charset_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/rpl/t/rpl_temporary.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/std_data/update-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/std_data/write-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/std_data/ver_5_1-telco.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/std_data/ver_5_1_17.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/std_data/bug32407.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/std_data/write-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/std_data/ver_5_1_23.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/std_data/ver_5_1-wl2325_r.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/std_data/update-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/std_data/ver_5_1-wl2325_s.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/std_data/binlog_old_version_4_1.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/r/binlog_stm_ctype_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/r/binlog_row_ctype_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/r/binlog_mysqlbinlog_row_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/r/binlog_mysqlbinlog_row_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/r/binlog_mysqlbinlog_row.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/binlog/t/binlog_mysqlbinlog-cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/funcs_1/lib/DataGen_local.pl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/funcs_1/r/memory_func_view.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/funcs_1/r/innodb_func_view.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/funcs_1/r/myisam_func_view.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/std_data/jisx0208_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/std_data/jisx0212_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/std_data/jisx0201_sjis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/std_data/jisx0208_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis3.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/std_data/jisx0201_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/std_data/jisx0212_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/std_data/jisx0201_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/include/trim_sjis.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_rtrim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_join_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_create_tbl_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_alter_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_join_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_create_db_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_trim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_join_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_charset_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_create_tbl_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_ps_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_reverse_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_substring_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_insert_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_replace_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_replace_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_trim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_substring_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_charlength_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_subquery_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_reverse_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_select_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_length_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_where_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_subquery_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_create_db_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_convert_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_insert_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_like_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_union_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_convert_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_right_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_trim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_reverse_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_substring_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_subquery_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_update_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_alter_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_enum_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_like_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_replace_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_left_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_update_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_instr_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_alter_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_convert_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_length_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_ps_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_like_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_locate_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_charlength_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_rtrim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_enum_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_right_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_create_db_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_enum_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_lpad_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_charlength_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_left_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_charset_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_rpad_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_left_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_locate_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_charset_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_lpad_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_ltrim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_select_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_rtrim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_select_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_where_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_lpad_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_create_tbl_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_update_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_locate_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_instr_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_where_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_rpad_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_instr_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_insert_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_ltrim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_rpad_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_length_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_right_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/r/jp_ltrim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_rpad_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_ps_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_left_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_alter_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_create_tbl_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_ps_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_charset_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_create_db_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_insert_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_join_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_enum_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_charlength_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_instr_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_update_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_substring_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_subquery_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_reverse_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_locate_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_create_tbl_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_locate_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_create_tbl_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_where_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_insert_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_join_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_union_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_instr_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_substring_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_subquery_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_convert_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_replace_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_like_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_left_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_select_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_enum_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_enum_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_join_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_length_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_insert_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_select_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_length_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_right_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_reverse_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_instr_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_alter_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_convert_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_subquery_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_charlength_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_rtrim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_charset_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_convert_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_ltrim_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_like_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_where_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_lpad_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_create_db_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_lpad_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_rpad_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_like_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_right_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_locate_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_length_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_right_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_select_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_reverse_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_update_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_left_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_rtrim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_charset_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_ltrim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_rpad_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_rtrim_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_ltrim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_trim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_where_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_trim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_replace_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_create_db_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_substring_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_lpad_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_charlength_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_replace_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_alter_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/jp/t/jp_update_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_index.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_column.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_older_compatibility1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_column.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_older_compatibility1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/engines/funcs/t/rpl_temporary.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_index.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_table.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/engines/iuds/r/strings_charsets_update_delete.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/engines/iuds/r/type_bit_iuds.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/sql_big_tables_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/collation_database_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/sql_log_bin_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/sql_quote_show_create_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/character_set_results_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/sql_warnings_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/collation_server_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/engine_condition_pushdown_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/pseudo_slave_mode_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/sql_buffer_result_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/sql_big_selects_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/collation_connection_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/sql_low_priority_updates_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/innodb_table_locks_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/sql_notes_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/character_set_connection_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/character_set_client_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/query_cache_wlock_invalidate_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/character_set_client_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/innodb_support_xa_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/sql_safe_updates_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/sql_log_off_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/r/foreign_key_checks_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/sql_big_tables_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/sql_log_bin_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/sql_warnings_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/engine_condition_pushdown_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/sql_log_off_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/sql_notes_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/character_set_results_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/sql_buffer_result_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/character_set_client_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/sql_safe_updates_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/character_set_connection_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/sql_big_selects_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/collation_database_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/foreign_key_checks_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/sql_quote_show_create_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/innodb_table_locks_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/collation_server_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/pseudo_slave_mode_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/sql_low_priority_updates_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/innodb_support_xa_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/query_cache_wlock_invalidate_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/suite/sys_vars/t/collation_connection_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/extra/binlog_tests/ctype_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/extra/rpl_tests/rpl_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_big5.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/alias.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_ucs.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_utf8mb4_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_utf8mb4_heap.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/mysql_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/type_set.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/errors.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/show_check.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_collate.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/fulltext.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_utf8mb4.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/mysqldump.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/subselect2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/sp.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/cast.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_latin1_de.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/warnings.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/csv.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/query_cache.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/date_formats.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ddl_i18n_koi8r.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/binary.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/mysqltest.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ps.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_many.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/func_like.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_latin2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/rowid_order_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/type_decimal.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/func_in.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_latin1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_utf8mb4_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/log_tables.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_utf8.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/union.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/func_test.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_recoding.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/explain.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_tis620.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/outfile_loaddata.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_cp1250_ch.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/events_bugs.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/signal.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ddl_i18n_utf8.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/alter_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/func_des_encrypt.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/type_enum.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/func_gconcat.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/ctype_cp1251.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/events_1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/r/grant.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/type_set.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ctype_big5.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ctype_latin1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ctype_utf8.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/sp.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/union.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ctype_ucs.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/subselect2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/cast.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/warnings.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/query_cache.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/func_like.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ctype_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/errors.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/events_bugs.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/binary.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/mysql_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/bug13633383.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ctype_recoding.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/func_gconcat.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/alias.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/fulltext.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ctype_cp1251.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ctype_latin1_de.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/events_1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/func_test.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/explain.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ps.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ctype_collate.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ctype_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/func_in.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ctype_utf8mb4.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ctype_tis620.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/fulltext_left_join.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/mysqldump.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/show_check.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ddl_i18n_koi8r.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/mysqltest.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/alter_table.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ctype_many.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ctype_cp1250_ch.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/type_decimal.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/log_tables.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/grant.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/mysqlbinlog.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ctype_filesystem-master.opt",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/ddl_i18n_utf8.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/mysql-test/t/type_enum.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/sql/item_xmlfunc.cc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/sql/MSG00001.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/libmysqld/libmysqld.rc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/libmysqld/examples/builder-sample/emb_samples.dfm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/libmysqld/examples/builder-sample/snapshot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/libmysqld/examples/builder-sample/images/logo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/libmysqld/examples/builder-sample/images/mysql.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/libmysqld/examples/builder-sample/images/db.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/libmysqld/examples/builder-sample/images/net.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-nyqk72q4gzzftlpdwxssnfstyxleoo7y/spack-src/libmysqld/examples/builder-sample/images/find.ico"
    ],
    "total_files": 9421
}