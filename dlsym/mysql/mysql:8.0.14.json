{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/configure.cmake": "# Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.\n# \n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License, version 2.0,\n# as published by the Free Software Foundation.\n#\n# This program is also distributed with certain software (including\n# but not limited to OpenSSL) that is licensed under separate terms,\n# as designated in a particular file or component or in included license\n# documentation.  The authors of MySQL hereby grant you an additional\n# permission to link the program and your derivative works with the\n# separately licensed software that they have included with MySQL.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License, version 2.0, for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n#\n\nINCLUDE (CheckCSourceCompiles)\nINCLUDE (CheckCXXSourceCompiles)\nINCLUDE (CheckStructHasMember)\nINCLUDE (CheckLibraryExists)\nINCLUDE (CheckFunctionExists)\nINCLUDE (CheckCCompilerFlag)\nINCLUDE (CheckCSourceRuns)\nINCLUDE (CheckCXXSourceRuns)\nINCLUDE (CheckSymbolExists)\n\n\nIF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\" AND CMAKE_COMPILER_IS_GNUCXX)\n  ## We will be using gcc to generate .so files\n  ## Add C flags (e.g. -m64) to CMAKE_SHARED_LIBRARY_C_FLAGS\n  ## The client library contains C++ code, so add dependency on libstdc++\n  ## See cmake --help-policy CMP0018\n  SET(CMAKE_SHARED_LIBRARY_C_FLAGS\n    \"${CMAKE_SHARED_LIBRARY_C_FLAGS} ${CMAKE_C_FLAGS} -lstdc++\")\nENDIF()\n\n\n# System type affects version_compile_os variable \nIF(NOT SYSTEM_TYPE)\n  IF(PLATFORM)\n    SET(SYSTEM_TYPE ${PLATFORM})\n  ELSE()\n    SET(SYSTEM_TYPE ${CMAKE_SYSTEM_NAME})\n  ENDIF()\nENDIF()\n\n# Probobuf 2.6.1 on Sparc. Both gcc and Solaris Studio need this.\nIF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\" AND\n    SIZEOF_VOIDP EQUAL 8 AND CMAKE_SYSTEM_PROCESSOR MATCHES \"sparc\")\n  ADD_DEFINITIONS(-DSOLARIS_64BIT_ENABLED)\nENDIF()\n\n# Check to see if we are using LLVM's libc++ rather than e.g. libstd++\n# Can then check HAVE_LLBM_LIBCPP later without including e.g. ciso646.\nCHECK_CXX_SOURCE_RUNS(\"\n#include <ciso646>\nint main()\n{\n#ifdef _LIBCPP_VERSION\n  return 0;\n#else\n  return 1;\n#endif\n}\" HAVE_LLVM_LIBCPP)\n\n# Same for structs, setting HAVE_STRUCT_<name> instead\nFUNCTION(MY_CHECK_STRUCT_SIZE type defbase)\n  CHECK_TYPE_SIZE(\"struct ${type}\" SIZEOF_${defbase})\n  IF(SIZEOF_${defbase})\n    SET(HAVE_STRUCT_${defbase} 1 PARENT_SCOPE)\n  ENDIF()\nENDFUNCTION()\n\n# Searches function in libraries\n# if function is found, sets output parameter result to the name of the library\n# if function is found in libc, result will be empty \nFUNCTION(MY_SEARCH_LIBS func libs result)\n  IF(${${result}})\n    # Library is already found or was predefined\n    RETURN()\n  ENDIF()\n  CHECK_FUNCTION_EXISTS(${func} HAVE_${func}_IN_LIBC)\n  IF(HAVE_${func}_IN_LIBC)\n    SET(${result} \"\" PARENT_SCOPE)\n    RETURN()\n  ENDIF()\n  FOREACH(lib  ${libs})\n    CHECK_LIBRARY_EXISTS(${lib} ${func} \"\" HAVE_${func}_IN_${lib}) \n    IF(HAVE_${func}_IN_${lib})\n      SET(${result} ${lib} PARENT_SCOPE)\n      SET(HAVE_${result} 1 PARENT_SCOPE)\n      RETURN()\n    ENDIF()\n  ENDFOREACH()\nENDFUNCTION()\n\n# Find out which libraries to use.\n\n# Figure out threading library\n# Defines CMAKE_USE_PTHREADS_INIT and CMAKE_THREAD_LIBS_INIT.\nFIND_PACKAGE (Threads)\n\nIF(UNIX)\n  MY_SEARCH_LIBS(floor m LIBM)\n  IF(NOT LIBM)\n    MY_SEARCH_LIBS(__infinity m LIBM)\n  ENDIF()\n  IF(NOT LIBM)\n    MY_SEARCH_LIBS(log m LIBM)\n  ENDIF()\n  MY_SEARCH_LIBS(gethostbyname_r  \"nsl_r;nsl\" LIBNSL)\n  MY_SEARCH_LIBS(bind \"bind;socket\" LIBBIND)\n  MY_SEARCH_LIBS(crypt crypt LIBCRYPT)\n  MY_SEARCH_LIBS(setsockopt socket LIBSOCKET)\n  MY_SEARCH_LIBS(dlopen dl LIBDL)\n  # HAVE_dlopen_IN_LIBC\n  IF(NOT LIBDL)\n    MY_SEARCH_LIBS(dlsym dl LIBDL)\n  ENDIF()\n  MY_SEARCH_LIBS(sched_yield rt LIBRT)\n  IF(NOT LIBRT)\n    MY_SEARCH_LIBS(clock_gettime rt LIBRT)\n  ENDIF()\n  MY_SEARCH_LIBS(timer_create rt LIBRT)\n  MY_SEARCH_LIBS(atomic_thread_fence atomic LIBATOMIC)\n  MY_SEARCH_LIBS(backtrace execinfo LIBEXECINFO)\n\n  LIST(APPEND CMAKE_REQUIRED_LIBRARIES\n    ${LIBM} ${LIBNSL} ${LIBBIND} ${LIBCRYPT} ${LIBSOCKET} ${LIBDL}\n    ${CMAKE_THREAD_LIBS_INIT} ${LIBRT} ${LIBATOMIC} ${LIBEXECINFO}\n  )\n  # Need explicit pthread for gcc -fsanitize=address\n  IF(CMAKE_C_FLAGS MATCHES \"-fsanitize=\")\n    SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} pthread)\n  ENDIF()\n\n  # https://bugs.llvm.org/show_bug.cgi?id=16404\n  IF(LINUX AND HAVE_UBSAN AND CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n    SET(CMAKE_EXE_LINKER_FLAGS_DEBUG\n      \"${CMAKE_EXE_LINKER_FLAGS_DEBUG} -rtlib=compiler-rt -lgcc_s\")\n    SET(CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO\n      \"${CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO} -rtlib=compiler-rt -lgcc_s\")\n  ENDIF()\n\n  IF(WITH_ASAN)\n    SET(CMAKE_REQUIRED_FLAGS \"${CMAKE_REQUIRED_FLAGS} -fsanitize=address\")\n  ENDIF()\n\n  IF(WITH_ASAN OR WITH_TSAN)\n    IF(CMAKE_USE_PTHREADS_INIT AND NOT CMAKE_THREAD_LIBS_INIT)\n      MESSAGE(STATUS \"No CMAKE_THREAD_LIBS_INIT ??\")\n      SET(CMAKE_THREAD_LIBS_INIT \"-lpthread\")\n    ENDIF()\n  ENDIF()\n\n  LIST(LENGTH CMAKE_REQUIRED_LIBRARIES required_libs_length)\n  IF(${required_libs_length} GREATER 0)\n    LIST(REMOVE_DUPLICATES CMAKE_REQUIRED_LIBRARIES)\n  ENDIF()  \n  LINK_LIBRARIES(${CMAKE_THREAD_LIBS_INIT})\n  \n  OPTION(WITH_LIBWRAP \"Compile with tcp wrappers support\" OFF)\n  IF(WITH_LIBWRAP)\n    SET(SAVE_CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES})\n    SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} wrap)\n    CHECK_C_SOURCE_COMPILES(\n    \"\n    #include <tcpd.h>\n    int allow_severity = 0;\n    int deny_severity  = 0;\n    int main()\n    {\n      hosts_access(0);\n    }\"\n    HAVE_LIBWRAP)\n\n    IF(HAVE_LIBWRAP)\n      CHECK_CXX_SOURCE_COMPILES(\n      \"\n      #include <tcpd.h>\n      int main()\n      {\n        struct request_info req;\n        if (req.sink)\n          (req.sink)(req.fd);\n      }\"\n      HAVE_LIBWRAP_PROTOTYPES)\n    ENDIF()\n\n    SET(CMAKE_REQUIRED_LIBRARIES ${SAVE_CMAKE_REQUIRED_LIBRARIES})\n    IF(HAVE_LIBWRAP)\n      SET(LIBWRAP \"wrap\")\n    ELSE()\n      MESSAGE(FATAL_ERROR \n      \"WITH_LIBWRAP is defined, but can not find a working libwrap. \"\n      \"Make sure both the header files (tcpd.h) \"\n      \"and the library (libwrap) are installed.\")\n    ENDIF()\n  ENDIF()\nENDIF()\n\n#\n# Tests for header files\n#\nINCLUDE (CheckIncludeFiles)\n\nCHECK_INCLUDE_FILES (alloca.h HAVE_ALLOCA_H)\nCHECK_INCLUDE_FILES (arpa/inet.h HAVE_ARPA_INET_H)\nCHECK_INCLUDE_FILES (dlfcn.h HAVE_DLFCN_H)\nCHECK_INCLUDE_FILES (endian.h HAVE_ENDIAN_H)\nCHECK_INCLUDE_FILES (execinfo.h HAVE_EXECINFO_H)\nCHECK_INCLUDE_FILES (fpu_control.h HAVE_FPU_CONTROL_H)\nCHECK_INCLUDE_FILES (grp.h HAVE_GRP_H)\nCHECK_INCLUDE_FILES (ieeefp.h HAVE_IEEEFP_H)\nCHECK_INCLUDE_FILES (langinfo.h HAVE_LANGINFO_H)\nCHECK_INCLUDE_FILES (malloc.h HAVE_MALLOC_H)\nCHECK_INCLUDE_FILES (netinet/in.h HAVE_NETINET_IN_H)\nCHECK_INCLUDE_FILES (poll.h HAVE_POLL_H)\nCHECK_INCLUDE_FILES (pwd.h HAVE_PWD_H)\nIF(WITH_ASAN)\n  CHECK_INCLUDE_FILES (sanitizer/lsan_interface.h HAVE_LSAN_INTERFACE_H)\nENDIF()\nCHECK_INCLUDE_FILES (strings.h HAVE_STRINGS_H) # Used by NDB\nCHECK_INCLUDE_FILES (sys/cdefs.h HAVE_SYS_CDEFS_H) # Used by libedit\nCHECK_INCLUDE_FILES (sys/ioctl.h HAVE_SYS_IOCTL_H)\nCHECK_INCLUDE_FILES (sys/mman.h HAVE_SYS_MMAN_H)\nCHECK_INCLUDE_FILES (sys/prctl.h HAVE_SYS_PRCTL_H)\nCHECK_INCLUDE_FILES (sys/resource.h HAVE_SYS_RESOURCE_H)\nCHECK_INCLUDE_FILES (sys/select.h HAVE_SYS_SELECT_H)\nCHECK_INCLUDE_FILES (sys/socket.h HAVE_SYS_SOCKET_H)\nCHECK_INCLUDE_FILES (\"curses.h;term.h\" HAVE_TERM_H)\nCHECK_INCLUDE_FILES (termios.h HAVE_TERMIOS_H)\nCHECK_INCLUDE_FILES (termio.h HAVE_TERMIO_H)\nCHECK_INCLUDE_FILES (unistd.h HAVE_UNISTD_H)\nCHECK_INCLUDE_FILES (sys/wait.h HAVE_SYS_WAIT_H)\nCHECK_INCLUDE_FILES (sys/param.h HAVE_SYS_PARAM_H) # Used by NDB/libevent\nCHECK_INCLUDE_FILES (fnmatch.h HAVE_FNMATCH_H)\nCHECK_INCLUDE_FILES (sys/un.h HAVE_SYS_UN_H)\nCHECK_INCLUDE_FILES (vis.h HAVE_VIS_H) # Used by libedit\nCHECK_INCLUDE_FILES (sasl/sasl.h HAVE_SASL_SASL_H) # Used by memcached\n\n# For libevent\nCHECK_INCLUDE_FILES(sys/devpoll.h HAVE_DEVPOLL)\nIF(HAVE_DEVPOLL)\n  # Duplicate symbols, but keep it to avoid changing libevent code.\n  SET(HAVE_SYS_DEVPOLL_H 1)\nENDIF()\nCHECK_INCLUDE_FILES(sys/epoll.h HAVE_SYS_EPOLL_H)\nCHECK_SYMBOL_EXISTS (TAILQ_FOREACH \"sys/queue.h\" HAVE_TAILQFOREACH)\n\n#\n# Tests for functions\n#\nIF(WITH_ASAN)\n  CHECK_SYMBOL_EXISTS (__lsan_do_recoverable_leak_check\n    \"sanitizer/lsan_interface.h\" HAVE_LSAN_DO_RECOVERABLE_LEAK_CHECK)\nENDIF()\nCHECK_FUNCTION_EXISTS (_aligned_malloc HAVE_ALIGNED_MALLOC)\nCHECK_FUNCTION_EXISTS (backtrace HAVE_BACKTRACE)\nCHECK_FUNCTION_EXISTS (printstack HAVE_PRINTSTACK)\nCHECK_FUNCTION_EXISTS (index HAVE_INDEX)\nCHECK_FUNCTION_EXISTS (chown HAVE_CHOWN)\nCHECK_FUNCTION_EXISTS (cuserid HAVE_CUSERID)\nCHECK_FUNCTION_EXISTS (directio HAVE_DIRECTIO)\nCHECK_FUNCTION_EXISTS (ftruncate HAVE_FTRUNCATE)\nCHECK_FUNCTION_EXISTS (fchmod HAVE_FCHMOD)\nCHECK_FUNCTION_EXISTS (fcntl HAVE_FCNTL)\nCHECK_FUNCTION_EXISTS (fdatasync HAVE_FDATASYNC)\nCHECK_SYMBOL_EXISTS(fdatasync \"unistd.h\" HAVE_DECL_FDATASYNC)\nCHECK_FUNCTION_EXISTS (fedisableexcept HAVE_FEDISABLEEXCEPT)\nCHECK_FUNCTION_EXISTS (fseeko HAVE_FSEEKO)\nCHECK_FUNCTION_EXISTS (fsync HAVE_FSYNC)\nCHECK_FUNCTION_EXISTS (gethrtime HAVE_GETHRTIME)\nCHECK_FUNCTION_EXISTS (getnameinfo HAVE_GETNAMEINFO)\nCHECK_FUNCTION_EXISTS (getpass HAVE_GETPASS)\nCHECK_FUNCTION_EXISTS (getpassphrase HAVE_GETPASSPHRASE)\nCHECK_FUNCTION_EXISTS (getpwnam HAVE_GETPWNAM)\nCHECK_FUNCTION_EXISTS (getpwuid HAVE_GETPWUID)\nCHECK_FUNCTION_EXISTS (getrlimit HAVE_GETRLIMIT)\nCHECK_FUNCTION_EXISTS (getrusage HAVE_GETRUSAGE)\nCHECK_FUNCTION_EXISTS (initgroups HAVE_INITGROUPS)\nCHECK_FUNCTION_EXISTS (issetugid HAVE_ISSETUGID)\nCHECK_FUNCTION_EXISTS (getuid HAVE_GETUID)\nCHECK_FUNCTION_EXISTS (geteuid HAVE_GETEUID)\nCHECK_FUNCTION_EXISTS (getgid HAVE_GETGID)\nCHECK_FUNCTION_EXISTS (getegid HAVE_GETEGID)\nCHECK_FUNCTION_EXISTS (madvise HAVE_MADVISE)\nCHECK_FUNCTION_EXISTS (malloc_info HAVE_MALLOC_INFO)\nCHECK_FUNCTION_EXISTS (memrchr HAVE_MEMRCHR)\nCHECK_FUNCTION_EXISTS (mlock HAVE_MLOCK)\nCHECK_FUNCTION_EXISTS (mlockall HAVE_MLOCKALL)\nCHECK_FUNCTION_EXISTS (mmap64 HAVE_MMAP64)\nCHECK_FUNCTION_EXISTS (poll HAVE_POLL)\nCHECK_FUNCTION_EXISTS (posix_fallocate HAVE_POSIX_FALLOCATE)\nCHECK_FUNCTION_EXISTS (posix_memalign HAVE_POSIX_MEMALIGN)\nCHECK_FUNCTION_EXISTS (pread HAVE_PREAD) # Used by NDB\nCHECK_FUNCTION_EXISTS (pthread_condattr_setclock HAVE_PTHREAD_CONDATTR_SETCLOCK)\nCHECK_FUNCTION_EXISTS (pthread_sigmask HAVE_PTHREAD_SIGMASK)\nCHECK_FUNCTION_EXISTS (setfd HAVE_SETFD) # Used by libevent (never true)\nCHECK_FUNCTION_EXISTS (sigaction HAVE_SIGACTION)\nCHECK_FUNCTION_EXISTS (sleep HAVE_SLEEP)\nCHECK_FUNCTION_EXISTS (stpcpy HAVE_STPCPY)\nCHECK_FUNCTION_EXISTS (stpncpy HAVE_STPNCPY)\nCHECK_FUNCTION_EXISTS (strlcpy HAVE_STRLCPY)\nCHECK_FUNCTION_EXISTS (strndup HAVE_STRNDUP) # Used by libbinlogevents\nCHECK_FUNCTION_EXISTS (strlcat HAVE_STRLCAT)\nCHECK_FUNCTION_EXISTS (strsignal HAVE_STRSIGNAL)\nCHECK_FUNCTION_EXISTS (fgetln HAVE_FGETLN)\nCHECK_FUNCTION_EXISTS (strsep HAVE_STRSEP)\nCHECK_FUNCTION_EXISTS (tell HAVE_TELL)\nCHECK_FUNCTION_EXISTS (vasprintf HAVE_VASPRINTF)\nCHECK_FUNCTION_EXISTS (memalign HAVE_MEMALIGN)\nCHECK_FUNCTION_EXISTS (nl_langinfo HAVE_NL_LANGINFO)\nCHECK_FUNCTION_EXISTS (ntohll HAVE_HTONLL)\n\nCHECK_FUNCTION_EXISTS (epoll_create HAVE_EPOLL)\n# Temperarily  Quote event port out as we encounter error in port_getn\n# on solaris x86\n# CHECK_FUNCTION_EXISTS (port_create HAVE_EVENT_PORTS)\nCHECK_FUNCTION_EXISTS (inet_ntop HAVE_INET_NTOP)\nCHECK_FUNCTION_EXISTS (kqueue HAVE_WORKING_KQUEUE)\nCHECK_SYMBOL_EXISTS (timeradd \"sys/time.h\" HAVE_TIMERADD)\nCHECK_SYMBOL_EXISTS (timerclear \"sys/time.h\" HAVE_TIMERCLEAR)\nCHECK_SYMBOL_EXISTS (timercmp \"sys/time.h\" HAVE_TIMERCMP)\nCHECK_SYMBOL_EXISTS (timerisset \"sys/time.h\" HAVE_TIMERISSET)\n\n#--------------------------------------------------------------------\n# Support for WL#2373 (Use cycle counter for timing)\n#--------------------------------------------------------------------\n\nCHECK_INCLUDE_FILES(sys/time.h HAVE_SYS_TIME_H)\nCHECK_INCLUDE_FILES(sys/times.h HAVE_SYS_TIMES_H)\n\nCHECK_FUNCTION_EXISTS(times HAVE_TIMES)\nCHECK_FUNCTION_EXISTS(gettimeofday HAVE_GETTIMEOFDAY)\n\n\n#\n# Tests for symbols\n#\n\nCHECK_SYMBOL_EXISTS(lrand48 \"stdlib.h\" HAVE_LRAND48)\nCHECK_SYMBOL_EXISTS(TIOCGWINSZ \"sys/ioctl.h\" GWINSZ_IN_SYS_IOCTL)\nCHECK_SYMBOL_EXISTS(FIONREAD \"sys/ioctl.h\" FIONREAD_IN_SYS_IOCTL)\nCHECK_SYMBOL_EXISTS(FIONREAD \"sys/filio.h\" FIONREAD_IN_SYS_FILIO)\nCHECK_SYMBOL_EXISTS(MADV_DONTDUMP \"sys/mman.h\" HAVE_MADV_DONTDUMP)\n\n# On Solaris, it is only visible in C99 mode\nCHECK_SYMBOL_EXISTS(isinf \"math.h\" HAVE_C_ISINF)\n\n# isinf() prototype not found on Solaris\nCHECK_CXX_SOURCE_COMPILES(\n\"#include  <math.h>\nint main() { \n  isinf(0.0); \n  return 0;\n}\" HAVE_CXX_ISINF)\n\nIF (HAVE_C_ISINF AND HAVE_CXX_ISINF)\n  SET(HAVE_ISINF 1 CACHE INTERNAL \"isinf visible in C and C++\" FORCE)\nELSE()\n  SET(HAVE_ISINF 0 CACHE INTERNAL \"isinf visible in C and C++\" FORCE)\nENDIF()\n\n\n# The results of these four checks are only needed here, not in code.\nCHECK_FUNCTION_EXISTS (timer_create HAVE_TIMER_CREATE)\nCHECK_FUNCTION_EXISTS (timer_settime HAVE_TIMER_SETTIME)\nCHECK_FUNCTION_EXISTS (kqueue HAVE_KQUEUE)\nCHECK_SYMBOL_EXISTS(EVFILT_TIMER \"sys/types.h;sys/event.h;sys/time.h\" HAVE_EVFILT_TIMER)\nIF(HAVE_KQUEUE AND HAVE_EVFILT_TIMER)\n  SET(HAVE_KQUEUE_TIMERS 1 CACHE INTERNAL \"Have kqueue timer-related filter\")\nELSEIF(HAVE_TIMER_CREATE AND HAVE_TIMER_SETTIME)\n  SET(HAVE_POSIX_TIMERS 1 CACHE INTERNAL \"Have POSIX timer-related functions\")\nENDIF()\n\nIF(NOT HAVE_POSIX_TIMERS AND NOT HAVE_KQUEUE_TIMERS AND NOT WIN32)\n  MESSAGE(FATAL_ERROR \"No mysys timer support detected!\")\nENDIF()\n\n#\n# Test for endianess\n#\nINCLUDE(TestBigEndian)\nTEST_BIG_ENDIAN(WORDS_BIGENDIAN)\n\n#\n# Tests for type sizes (and presence)\n#\nINCLUDE (CheckTypeSize)\n\nset(CMAKE_REQUIRED_DEFINITIONS ${CMAKE_REQUIRED_DEFINITIONS}\n        -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64\n        -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS)\n\nSET(CMAKE_EXTRA_INCLUDE_FILES stdint.h stdio.h sys/types.h time.h)\n\nCHECK_TYPE_SIZE(uint8_t HAVE_UINT8_T)\nCHECK_TYPE_SIZE(uint16_t HAVE_UINT16_T)\nCHECK_TYPE_SIZE(uint32_t HAVE_UINT32_T)\nCHECK_TYPE_SIZE(uint64_t HAVE_UINT64_T)\n\nCHECK_TYPE_SIZE(\"void *\"    SIZEOF_VOIDP)\nCHECK_TYPE_SIZE(\"char *\"    SIZEOF_CHARP)\nCHECK_TYPE_SIZE(\"long\"      SIZEOF_LONG)\nCHECK_TYPE_SIZE(\"short\"     SIZEOF_SHORT)\nCHECK_TYPE_SIZE(\"int\"       SIZEOF_INT)\nCHECK_TYPE_SIZE(\"long long\" SIZEOF_LONG_LONG)\nCHECK_TYPE_SIZE(\"off_t\"     SIZEOF_OFF_T)\nCHECK_TYPE_SIZE(\"time_t\"    SIZEOF_TIME_T)\n\nCHECK_STRUCT_HAS_MEMBER(\"struct tm\"\n tm_gmtoff \"time.h\" HAVE_TM_GMTOFF)\n\n# If finds the size of a type, set SIZEOF_<type> and HAVE_<type>\nFUNCTION(MY_CHECK_TYPE_SIZE type defbase)\n  CHECK_TYPE_SIZE(\"${type}\" SIZEOF_${defbase})\n  IF(SIZEOF_${defbase})\n    SET(HAVE_${defbase} 1 PARENT_SCOPE)\n  ENDIF()\nENDFUNCTION()\n\n# We are only interested in presence for these\nMY_CHECK_TYPE_SIZE(ulong ULONG)\nMY_CHECK_TYPE_SIZE(u_int32_t U_INT32_T)\nSET(CMAKE_EXTRA_INCLUDE_FILES sys/socket.h)\nMY_CHECK_TYPE_SIZE(socklen_t SOCKLEN_T) # needed for libevent\n\nIF(HAVE_IEEEFP_H)\n  SET(CMAKE_EXTRA_INCLUDE_FILES ieeefp.h)\n  MY_CHECK_TYPE_SIZE(fp_except FP_EXCEPT)\nENDIF()\n\nSET(CMAKE_EXTRA_INCLUDE_FILES)\n\n# Support for tagging symbols with __attribute__((visibility(\"hidden\")))\nMY_CHECK_CXX_COMPILER_FLAG(\"-fvisibility=hidden\" HAVE_VISIBILITY_HIDDEN)\n\n#\n# Code tests\n#\n\nCHECK_C_SOURCE_RUNS(\"\n#include <time.h>\nint main()\n{\n  struct timespec ts;\n  return clock_gettime(CLOCK_MONOTONIC, &ts);\n}\" HAVE_CLOCK_GETTIME)\n\nCHECK_C_SOURCE_RUNS(\"\n#include <time.h>\nint main()\n{\n  struct timespec ts;\n  return clock_gettime(CLOCK_REALTIME, &ts);\n}\" HAVE_CLOCK_REALTIME)\n\nIF(NOT STACK_DIRECTION)\n  IF(CMAKE_CROSSCOMPILING)\n   MESSAGE(FATAL_ERROR \n   \"STACK_DIRECTION is not defined.  Please specify -DSTACK_DIRECTION=1 \"\n   \"or -DSTACK_DIRECTION=-1 when calling cmake.\")\n  ELSE()\n    TRY_RUN(STACKDIR_RUN_RESULT STACKDIR_COMPILE_RESULT    \n     ${CMAKE_BINARY_DIR} \n     ${CMAKE_SOURCE_DIR}/cmake/stack_direction.c\n     )\n     # Test program returns 0 (down) or 1 (up).\n     # Convert to -1 or 1\n     IF(STACKDIR_RUN_RESULT EQUAL 0)\n       SET(STACK_DIRECTION -1 CACHE INTERNAL \"Stack grows direction\")\n     ELSE()\n       SET(STACK_DIRECTION 1 CACHE INTERNAL \"Stack grows direction\")\n     ENDIF()\n     MESSAGE(STATUS \"Checking stack direction : ${STACK_DIRECTION}\")\n   ENDIF()\nENDIF()\n\nCHECK_INCLUDE_FILES(\"time.h;sys/time.h\" TIME_WITH_SYS_TIME)\nCHECK_SYMBOL_EXISTS(O_NONBLOCK \"unistd.h;fcntl.h\" HAVE_FCNTL_NONBLOCK)\nIF(NOT HAVE_FCNTL_NONBLOCK)\n SET(NO_FCNTL_NONBLOCK 1)\nENDIF()\n\nIF(NOT CMAKE_CROSSCOMPILING AND NOT MSVC)\n  STRING(TOLOWER ${CMAKE_SYSTEM_PROCESSOR}  processor)\n  IF(processor MATCHES \"86\" OR processor MATCHES \"amd64\" OR processor MATCHES \"x64\")\n    IF(NOT CMAKE_SYSTEM_NAME MATCHES \"SunOS\")\n      # The loader in some Solaris versions has a bug due to which it refuses to\n      # start a binary that has been compiled by GCC and uses __asm__(\"pause\")\n      # with the error:\n      # $ ./mysqld\n      # ld.so.1: mysqld: fatal: hardware capability unsupported: 0x2000 [ PAUSE ]\n      # Killed\n      # $\n      # Even though the CPU does have support for the instruction.\n      # Binaries that have been compiled by GCC and use __asm__(\"pause\")\n      # on a non-buggy Solaris get flagged with a \"uses pause\" flag and\n      # thus they are unusable if copied on buggy Solaris version. To\n      # circumvent this we explicitly disable __asm__(\"pause\") when\n      # compiling on Solaris. Subsequently the tests here will enable\n      # HAVE_FAKE_PAUSE_INSTRUCTION which will use __asm__(\"rep; nop\")\n      # which currently generates the same code as __asm__(\"pause\") - 0xf3 0x90\n      # but without flagging the binary as \"uses pause\".\n      CHECK_C_SOURCE_RUNS(\"\n      int main()\n      {\n        __asm__ __volatile__ (\\\"pause\\\");\n        return 0;\n      }\"  HAVE_PAUSE_INSTRUCTION)\n    ENDIF()\n  ENDIF()\n  IF (NOT HAVE_PAUSE_INSTRUCTION)\n    CHECK_C_SOURCE_COMPILES(\"\n    int main()\n    {\n     __asm__ __volatile__ (\\\"rep; nop\\\");\n     return 0;\n    }\n   \" HAVE_FAKE_PAUSE_INSTRUCTION)\n  ENDIF()\n  IF (NOT HAVE_PAUSE_INSTRUCTION)\n    CHECK_C_SOURCE_COMPILES(\"\n    int main()\n    {\n     __asm__ __volatile__ (\\\"or 1,1,1\\\");\n     __asm__ __volatile__ (\\\"or 2,2,2\\\");\n     return 0;\n    }\n    \" HAVE_HMT_PRIORITY_INSTRUCTION)\n  ENDIF()\nENDIF()\n  \nINCLUDE (CheckIncludeFileCXX)\nCHECK_INCLUDE_FILE_CXX(cxxabi.h HAVE_CXXABI_H)\nIF(HAVE_CXXABI_H)\nCHECK_CXX_SOURCE_COMPILES(\"\n #include <cxxabi.h>\n int main(int argc, char **argv) \n  {\n    char *foo= 0; int bar= 0;\n    foo= abi::__cxa_demangle(foo, foo, 0, &bar);\n    return 0;\n  }\"\n  HAVE_ABI_CXA_DEMANGLE)\nENDIF()\n\nCHECK_C_SOURCE_COMPILES(\"\nint main()\n{\n  __builtin_unreachable();\n  return 0;\n}\" HAVE_BUILTIN_UNREACHABLE)\n\nCHECK_C_SOURCE_COMPILES(\"\nint main()\n{\n  long l= 0;\n  __builtin_expect(l, 0);\n  return 0;\n}\" HAVE_BUILTIN_EXPECT)\n\n# GCC has __builtin_stpcpy but still calls stpcpy\nIF(NOT CMAKE_SYSTEM_NAME MATCHES \"SunOS\" OR NOT CMAKE_COMPILER_IS_GNUCC)\nCHECK_C_SOURCE_COMPILES(\"\nint main()\n{\n  char foo1[1];\n  char foo2[1];\n  __builtin_stpcpy(foo1, foo2);\n  return 0;\n}\" HAVE_BUILTIN_STPCPY)\nENDIF()\n\nCHECK_CXX_SOURCE_COMPILES(\"\n  int main()\n  {\n    int foo= -10; int bar= 10;\n    long long int foo64= -10; long long int bar64= 10;\n    if (!__atomic_fetch_add(&foo, bar, __ATOMIC_SEQ_CST) || foo)\n      return -1;\n    bar= __atomic_exchange_n(&foo, bar, __ATOMIC_SEQ_CST);\n    if (bar || foo != 10)\n      return -1;\n    bar= __atomic_compare_exchange_n(&bar, &foo, 15, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);\n    if (bar)\n      return -1;\n    if (!__atomic_fetch_add(&foo64, bar64, __ATOMIC_SEQ_CST) || foo64)\n      return -1;\n    bar64= __atomic_exchange_n(&foo64, bar64, __ATOMIC_SEQ_CST);\n    if (bar64 || foo64 != 10)\n      return -1;\n    bar64= __atomic_compare_exchange_n(&bar64, &foo64, 15, 0,\n                                       __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);\n    if (bar64)\n      return -1;\n    return 0;\n  }\"\n  HAVE_GCC_ATOMIC_BUILTINS)\n\nCHECK_CXX_SOURCE_COMPILES(\"\n  int main()\n  {\n    int foo= -10; int bar= 10;\n    long long int foo64= -10; long long int bar64= 10;\n    if (!__sync_fetch_and_add(&foo, bar) || foo)\n      return -1;\n    bar= __sync_lock_test_and_set(&foo, bar);\n    if (bar || foo != 10)\n      return -1;\n    bar= __sync_val_compare_and_swap(&bar, foo, 15);\n    if (bar)\n      return -1;\n    if (!__sync_fetch_and_add(&foo64, bar64) || foo64)\n      return -1;\n    bar64= __sync_lock_test_and_set(&foo64, bar64);\n    if (bar64 || foo64 != 10)\n      return -1;\n    bar64= __sync_val_compare_and_swap(&bar64, foo, 15);\n    if (bar64)\n      return -1;\n    return 0;\n  }\"\n  HAVE_GCC_SYNC_BUILTINS)\n\nIF(WITH_VALGRIND)\n  SET(VALGRIND_HEADERS \"valgrind/memcheck.h;valgrind/valgrind.h\")\n  CHECK_INCLUDE_FILES(\"${VALGRIND_HEADERS}\" HAVE_VALGRIND_HEADERS)\n  IF(HAVE_VALGRIND_HEADERS)\n    SET(HAVE_VALGRIND 1)\n  ELSE()\n    MESSAGE(FATAL_ERROR \"Unable to find Valgrind header files ${VALGRIND_HEADERS}. Make sure you have them in your include path.\")\n  ENDIF()\nENDIF()\n\n# Check for gettid() system call\nCHECK_C_SOURCE_COMPILES(\"\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <unistd.h>\nint main(int ac, char **av)\n{\n  unsigned long long tid = syscall(SYS_gettid);\n  return (tid != 0 ? 0 : 1);\n}\"\nHAVE_SYS_GETTID)\n\n# Check for pthread_getthreadid_np()\nCHECK_C_SOURCE_COMPILES(\"\n#include <pthread_np.h>\nint main(int ac, char **av)\n{\n  unsigned long long tid = pthread_getthreadid_np();\n  return (tid != 0 ? 0 : 1);\n}\"\nHAVE_PTHREAD_GETTHREADID_NP)\n\n# Check for pthread_threadid_np()\nCHECK_C_SOURCE_COMPILES(\"\n#include <pthread.h>\nint main(int ac, char **av)\n{\n  unsigned long long tid64;\n  pthread_threadid_np(NULL, &tid64);\n  return (tid64 != 0 ? 0 : 1);\n}\"\nHAVE_PTHREAD_THREADID_NP)\n\n# Check for pthread_self() returning an integer type\nCHECK_C_SOURCE_COMPILES(\"\n#include <sys/types.h>\n#include <pthread.h>\nint main(int ac, char **av)\n{\n  unsigned long long tid = pthread_self();\n  return (tid != 0 ? 0 : 1);\n}\"\nHAVE_INTEGER_PTHREAD_SELF\nFAIL_REGEX \"warning: incompatible pointer to integer conversion\"\n)\n\n#--------------------------------------------------------------------\n# Check for IPv6 support\n#--------------------------------------------------------------------\nCHECK_INCLUDE_FILE(netinet/in6.h HAVE_NETINET_IN6_H) # Used by libevent (never true)\nMY_CHECK_STRUCT_SIZE(\"in6_addr\" IN6_ADDR) # Used by libevent\n\nIF(UNIX)\n  SET(CMAKE_EXTRA_INCLUDE_FILES sys/types.h netinet/in.h sys/socket.h)\n  IF(HAVE_NETINET_IN6_H)\n    SET(CMAKE_EXTRA_INCLUDE_FILES ${CMAKE_EXTRA_INCLUDE_FILES} netinet/in6.h)\n  ENDIF()\nELSEIF(WIN32)\n  SET(CMAKE_EXTRA_INCLUDE_FILES ${CMAKE_EXTRA_INCLUDE_FILES} winsock2.h ws2ipdef.h)\nENDIF()\n\n#\n# Check if struct sockaddr_in::sin_len is available.\n#\n\nCHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_in\" sin_len\n  \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_IN_SIN_LEN)\n\n#\n# Check if struct sockaddr_in6::sin6_len is available.\n#\n\nCHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_in6\" sin6_len\n  \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_IN6_SIN6_LEN)\n\nSET(CMAKE_EXTRA_INCLUDE_FILES)\n\nCHECK_INCLUDE_FILES(numa.h HAVE_NUMA_H)\nCHECK_INCLUDE_FILES(numaif.h HAVE_NUMAIF_H)\n\nIF(HAVE_NUMA_H AND HAVE_NUMAIF_H)\n    SET(SAVE_CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES})\n    SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} numa)\n    CHECK_C_SOURCE_COMPILES(\n    \"\n    #include <numa.h>\n    #include <numaif.h>\n    int main()\n    {\n       struct bitmask *all_nodes= numa_all_nodes_ptr;\n       set_mempolicy(MPOL_DEFAULT, 0, 0);\n       return all_nodes != NULL;\n    }\"\n    HAVE_LIBNUMA)\n    SET(CMAKE_REQUIRED_LIBRARIES ${SAVE_CMAKE_REQUIRED_LIBRARIES})\nELSE()\n    SET(HAVE_LIBNUMA 0)\nENDIF()\n\nIF(NOT HAVE_LIBNUMA)\n  MESSAGE(STATUS \"NUMA library missing or required version not available\")\nENDIF()\n\nIF(HAVE_LIBNUMA AND HAVE_NUMA_H AND HAVE_NUMAIF_H)\n   OPTION(WITH_NUMA \"Explicitly set NUMA memory allocation policy\" ON)\nELSE()\n   OPTION(WITH_NUMA \"Explicitly set NUMA memory allocation policy\" OFF)\nENDIF()\n\nIF(WITH_NUMA AND NOT HAVE_LIBNUMA)\n  # Forget it in cache, abort the build.\n  UNSET(WITH_NUMA CACHE)\n  MESSAGE(FATAL_ERROR \"Could not find numa headers/libraries\")\nENDIF()\n\nIF(HAVE_LIBNUMA AND NOT WITH_NUMA)\n   SET(HAVE_LIBNUMA 0)\n   MESSAGE(STATUS \"Disabling NUMA on user's request\")\nENDIF()\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/src/common/portlib/NdbNuma.cpp": "/*\n   Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License, version 2.0,\n   as published by the Free Software Foundation.\n\n   This program is also distributed with certain software (including\n   but not limited to OpenSSL) that is licensed under separate terms,\n   as designated in a particular file or component or in included license\n   documentation.  The authors of MySQL hereby grant you an additional\n   permission to link the program and your derivative works with the\n   separately licensed software that they have included with MySQL.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License, version 2.0, for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n*/\n\n#include <NdbNuma.h>\n#include <ndb_global.h>\n\n#ifdef TEST_NDBNUMA\nstatic int NDB_TRACE_NUMA = 0;\n#else\n#define NDB_TRACE_NUMA (false)\n#endif\n\n#if defined HAVE_DLFCN_H && defined HAVE_DLOPEN\n#include <dlfcn.h>\n\n/**\n * Load libnuma using dlopen, not have to put link dependency on it...\n * - handle fact that there are 2 versions of libnuma...\n *   use existance of symbol \"numa_all_nodes_ptr\" to use v2 abi\n */\nstruct bitmask;\nextern \"C\"\n{\n  typedef int (* fun0)(void);\n  typedef void (* fun1)(struct bitmask*);\n  typedef void (* fun2)(int);\n  typedef int (* fun3)(int node, unsigned long * bug, int buflen);\n  typedef bitmask * (* fun4)();\n  typedef void (* fun5)(struct bitmask*);\n  typedef bitmask * (* fun6)(struct bitmask*);\n};\n\nclass NdbNuma\n{\npublic:\n  NdbNuma() { handle = 0;}\n  ~NdbNuma() { if (handle) dlclose(handle); }\n\n  int open();\n  int build_cputonodemap();\n\n  void * handle;\n  fun0 numa_available;\n\n  fun0 numa_max_node;\n  fun0 numa_max_possible_node;\n  fun1 numa_set_interleave_mask;\n  fun2 numa_set_strict;\n  fun3 numa_node_to_cpus;\n  fun4 numa_allocate_nodemask;\n  fun5 numa_bitmask_free;\n  fun6 numa_bitmask_setall;\n\n  struct bitmask * numa_all_nodes;\n  struct bitmask * numa_all_nodes_ptr;\n};\n\nstatic\nvoid*\nmy_dlopen(const char * name)\n{\n  void * p = dlopen(name, RTLD_LAZY);\n  if (NDB_TRACE_NUMA)\n  {\n    if (p == 0)\n      printf(\"info: failed to load %s\\n\", name);\n    else\n      printf(\"info: loaded %s\\n\", name);\n  }\n  return p;\n}\n\nstatic\nvoid*\nmy_dlsym(void * handle, const char * name)\n{\n  void * p = dlsym(handle, name);\n  if (NDB_TRACE_NUMA)\n  {\n    if (p != 0)\n    {\n      printf(\"info: %s OK\\n\", name);\n    }\n    else\n    {\n      printf(\"info: %s NOT FOUND\\n\", name);\n    }\n  }\n  return p;\n}\n\nint\nNdbNuma::open()\n{\n  handle = my_dlopen(\"libnuma.so\");\n  if (handle == 0)\n  {\n    handle = my_dlopen(\"libnuma.so.1\");\n  }\n  if (handle == 0)\n  {\n    return -1;\n  }\n\n  numa_available = (fun0)my_dlsym(handle, \"numa_available\");\n  if (numa_available == 0)\n  {\n    goto fail;\n  }\n\n  if ((* numa_available)() == -1)\n  {\n    if (NDB_TRACE_NUMA)\n    {\n      printf(\"info: numa_available() returns -1 => no numa support\\n\");\n    }\n    goto fail;\n  }\n\n  numa_max_node = (fun0)my_dlsym(handle, \"numa_max_node\");\n  numa_set_interleave_mask = (fun1)my_dlsym(handle, \"numa_set_interleave_mask\");\n  numa_set_strict = (fun2)my_dlsym(handle, \"numa_set_strict\");\n  numa_node_to_cpus = (fun3)my_dlsym(handle, \"numa_node_to_cpus\");\n  numa_all_nodes = (struct bitmask*)my_dlsym(handle, \"numa_all_nodes\");\n  numa_all_nodes_ptr = (struct bitmask*)my_dlsym(handle, \"numa_all_nodes_ptr\");\n  numa_allocate_nodemask = (fun4)my_dlsym(handle, \"numa_allocate_nodemask\");\n  numa_bitmask_free = (fun5)my_dlsym(handle, \"numa_bitmask_free\");\n  numa_bitmask_setall = (fun6)my_dlsym(handle, \"numa_bitmask_setall\");\n\n\n  return 0;\nfail:\n  dlclose(handle);\n  handle = 0;\n  return -1;\n}\n\nstatic\nbool\nbit_is_set(unsigned long * mask, int bit)\n{\n  int n = bit / (8 * sizeof(unsigned long));\n  int b = bit % (8 * sizeof(unsigned long));\n  return (mask[n] & (1UL << b)) != 0;\n}\n\nint\nNdbNuma::build_cputonodemap()\n{\n  int len = 512;\n  unsigned long * buf = (unsigned long*)malloc(len);\n  if (buf == 0)\n    return -1;\n\n  int m = (* numa_max_node)();\n  for (int i = 0; i <= m; i++)\n  {\nretry:\n    int r = (* numa_node_to_cpus)(i, buf, len);\n    if (r == -1)\n    {\n      if (errno != ERANGE)\n        goto fail;\n\n      len = len + 512;\n      if (len > 4096)\n        goto fail;\n\n      void * p = realloc(buf, len);\n      if (p == 0)\n        goto fail;\n\n      buf = (unsigned long*)p;\n      goto retry;\n    }\n    printf(\"node %d cpu(s): \", i);\n    for (int j = 0; j<8*len;j++)\n      if (bit_is_set(buf, j))\n        printf(\"%d \", j);\n    printf(\"\\n\");\n  }\n  free(buf);\n  return 0;\nfail:\n  free(buf);\n  return -1;\n}\n\nextern \"C\"\nint\nNdbNuma_setInterleaved()\n{\n  NdbNuma numa;\n  if (numa.open() == -1)\n    return -1;\n\n  if (numa.numa_set_interleave_mask == 0)\n    return -1;\n\n  if (numa.numa_all_nodes_ptr != 0)\n  {\n    /**\n     * libnuma v2\n     */\n    if (numa.numa_allocate_nodemask != 0 &&\n        numa.numa_bitmask_setall != 0 &&\n        numa.numa_bitmask_free != 0)\n    {\n      struct bitmask * bm = (* numa.numa_allocate_nodemask)();\n      if (bm != 0)\n      {\n        (* numa.numa_bitmask_setall)(bm);\n        (* numa.numa_set_interleave_mask)(bm);\n        (* numa.numa_bitmask_free)(bm);\n      }\n      else\n      {\n        return -1;\n      }\n    }\n    else\n    {\n      return -1;\n    }\n  }\n  else if (numa.numa_all_nodes != 0)\n  {\n    /**\n     * libnuma v1\n     */\n    (* numa.numa_set_interleave_mask)(numa.numa_all_nodes);\n  }\n  else\n  {\n    return -1;\n  }\n\n  return 0;\n}\n\n#else\nextern \"C\"\nint\nNdbNuma_setInterleaved()\n{\n  return -1;\n}\n#endif\n\n#ifdef TEST_NDBNUMA\n#include <NdbTap.hpp>\n\nTAPTEST(SetInterleaved)\n{\n  NDB_TRACE_NUMA = 1;\n  NdbNuma_setInterleaved();\n  return 1; // OK\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/memcache/CMakeLists.txt": "# Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.\n# \n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License, version 2.0,\n# as published by the Free Software Foundation.\n#\n# This program is also distributed with certain software (including\n# but not limited to OpenSSL) that is licensed under separate terms,\n# as designated in a particular file or component or in included license\n# documentation.  The authors of MySQL hereby grant you an additional\n# permission to link the program and your derivative works with the\n# separately licensed software that they have included with MySQL.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License, version 2.0, for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n\n# This is the CMakeLists for NDB/Memcache\n\n# Skip attempting to build this component on Windows (for now) \nIF(WIN32)\n  RETURN()\nENDIF()\n\n######### BUNDLED SOURCES FOR MEMCACHED AND LIBEVENT\n\noption(WITH_BUNDLED_MEMCACHED \"Use bundled memcached\" ON)\nif(WITH_BUNDLED_MEMCACHED)\n  #\n  # Build the memcached bundled with NDB\n  #\n\n  # Handle the deprecated option to build libevent from\n  # code bundled with NDB. I.e the libevent bundled with NDB\n  # is not built anymore and instead the libevent bundled\n  # with MySQL or system libs are used.\n  option(WITH_BUNDLED_LIBEVENT \"Deprecated, use WITH_LIBEVENT\")\n  mark_as_advanced(WITH_BUNDLED_LIBEVENT)\n  if(WITH_BUNDLED_LIBEVENT)\n    MESSAGE(WARNING \"Ignoring deprecated WITH_BUNDLED_LIBEVENT, use \"\n                   \"WITH_LIBEVENT to configure which library to use \"\n                   \"when building memcached\")\n  endif()\n\n\n  # The libevent library is needed to build memcached.\n  # Make sure it has been found or configured to build\n  # by the code in cmake/libevent.cmake\n  if (NOT LIBEVENT_FOUND)\n    MESSAGE(SEND_ERROR \"The libevent library is necessary to build \"\n                       \"memcached, use WITH_LIBEVENT to configure which \"\n                       \"library to use\")\n  else()\n    ndb_require_variable(LIBEVENT_LIBRARIES)\n    ndb_require_variable(LIBEVENT_INCLUDE_DIRS)\n  endif()\n\n  add_subdirectory(extra/memcached)\nendif()\n\n\n\n####################################################\n\n# Disable specific types of warnings for current directory\n# if the compiler supports the flag\nIF(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  INCLUDE(CheckCXXCompilerFlag)\n  FOREACH(warning\n          \"unused-but-set-variable\"\n          \"strict-aliasing\"\n          \"unused-parameter\")\n    STRING(REPLACE \"-\" \"_\" warning_ ${warning})\n    STRING(TOUPPER ${warning_} WARNING)\n    CHECK_CXX_COMPILER_FLAG(\"-W${warning}\" HAVE_${WARNING})\n    IF(HAVE_${WARNING})\n      SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wno-${warning}\")\n      SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wno-${warning}\")\n    ENDIF()\n  ENDFOREACH()\nENDIF()\n\n# Don't disable assert\nREMOVE_DEFINITIONS(-DNDEBUG)\nFOREACH(flag\n    CMAKE_C_FLAGS_DEBUG\n    CMAKE_C_FLAGS_RELWITHDEBINFO\n    CMAKE_C_FLAGS_RELEASE\n    CMAKE_C_FLAGS_MINSIZEREL\n    CMAKE_CXX_FLAGS_DEBUG\n    CMAKE_CXX_FLAGS_RELWITHDEBINFO\n    CMAKE_CXX_FLAGS_RELEASE\n    CMAKE_CXX_FLAGS_MINSIZEREL\n    )\n  STRING(REPLACE \"-DNDEBUG\"  \"\" \"${flag}\" \"${${flag}}\")\nENDFOREACH()\n\n\ninclude(\"FindMemcached.cmake\")\ninclude(CheckLibraryExists)\n\nIF(MEMCACHED_FOUND) \n  MESSAGE(STATUS \"Building NDB Memcache using \" ${MEMCACHED_ROOT_DIR})\nELSE()\n  MESSAGE(STATUS \"Skipping NDB Memcache (Memcached not found)\")\n  RETURN()\nENDIF()  \n\n# Check for atomic operations\ninclude(atomics.cmake)\nif(NO_ATOMICS)\n  RETURN()\nENDIF()\n\n# Reuse the default engine from the bundled source tree\nset(BUNDLED_MEMCACHED extra/memcached)\nset(CACHE_SRC ${BUNDLED_MEMCACHED}/engines/default_engine)\n\n# Paths to header files\ninclude_directories(BEFORE include)\ninclude_directories(BEFORE ${CACHE_SRC})\ninclude_directories(${NDB_SOURCE_DIR}/src/ndbapi/)\ninclude_directories(${CMAKE_BINARY_DIR}/storage/ndb/memcache/include/)\ninclude_directories(AFTER ${MEMCACHED_INCLUDE_DIR})\ninclude_directories(AFTER ${BUNDLED_MEMCACHED})\n\n# Source files for this module \nset(NDB_MEMCACHE_SOURCE_FILES\n    src/ClusterConnectionPool.cc\n    src/Configuration.cc\n    src/Config_v1.cc\n    src/ConnQueryPlanSet.cc\n    src/DataTypeHandler.cc\n    src/ExpireTime.cc\n    src/ExternalValue.cc\n    src/KeyPrefix.cc\n    src/NdbInstance.cc\n    src/Operation.cc\n    src/QueryPlan.cc\n    src/Record.cc\n    src/TabSeparatedValues.cc\n    src/TableSpec.cc\n    src/atomics.cc\n    src/debug.cc\n    src/hash_item_util.cc\n    src/ndb_configuration.cc\n    src/ndb_engine_errors.cc\n    src/ndb_engine_private.h\n    src/ndb_error_logger.cc\n    src/ndb_flush.cc\n    src/ndb_pipeline.cc\n    src/ndb_worker.cc\n    src/schedulers\n    src/thread_identifier.cc\n    src/timing.cc\n    src/workitem.cc\n    src/workqueue.cc\n    src/Scheduler.cc\n    src/GlobalConfigManager.cc\n    src/SchedulerConfigManager.cc\n    src/schedulers/S_sched.cc\n    src/schedulers/Stockholm.cc\n    src/schedulers/Scheduler73.cc\n    src/schedulers/Trondheim.cc\n    ${CACHE_SRC}/items.c\n    ${CACHE_SRC}/assoc.c\n    ${CACHE_SRC}/slabs.c\n    src/embedded_default_engine.c\n)\n\n# The sourced C files from storage/ndb/memcache/extra/memcached can't be built\n# with -Werror\nIF(CMAKE_C_FLAGS)\n  STRING(REGEX REPLACE \"-Werror( |$)\" \"\" CMAKE_C_FLAGS \"${CMAKE_C_FLAGS}\")\nENDIF()\n\n# Set extra flags for the C compiler\nIF(${CMAKE_COMPILER_IS_GNUCC})\n  SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} --std=gnu99 -Wall -Wredundant-decls\")\nELSEIF(CMAKE_C_COMPILER_ID MATCHES \"SunPro\")\n  SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -xc99=all\")\nENDIF()\n\n# Set extra flags for the C++ compiler\nIF(${CMAKE_COMPILER_IS_GNUCXX})\n  STRING(REPLACE \"-fno-implicit-templates\" \"\" CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS})\nENDIF()\n\nIF(${CMAKE_CXX_COMPILER_ID} STREQUAL \"SunPro\")\n  SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -features=extensions\") # __func__\nENDIF()\n\n\n########## ENVIRONMENT TESTS #########\n\n# Checks for system headers\nCHECK_INCLUDE_FILE(\"mach/mach_time.h\" HAVE_MACH_MACH_TIME_H)\n\n# Checks for library functions\nCHECK_FUNCTION_EXISTS(srandomdev HAVE_SRANDOMDEV)\nCHECK_FUNCTION_EXISTS(gethrtime  HAVE_GETHRTIME)\nCHECK_FUNCTION_EXISTS(gethrvtime HAVE_GETHRVTIME)\nCHECK_FUNCTION_EXISTS(memset     HAVE_MEMSET)\n# Also: log in libm, dlsym in libdl? \nCHECK_LIBRARY_EXISTS(dl dlsym \"\" HAVE_LIBDL)\nSET(LIBDL \"\")\nif(${HAVE_LIBDL}) \n    set(LIBDL \"dl\")\nendif()\n\nCHECK_CXX_SOURCE_COMPILES(\"\n    int main()  {\n      const char * f = __func__;\n      (void)f; // unused\n      return 0;\n    }\"\n    HAVE_FUNC_IN_CXX)\n\n# Define DEBUG_OUTPUT by default (enables runtime \"debug\" option in memcached)\n# if(HAVE_FUNC_IN_CXX)\n  add_definitions(-DDEBUG_OUTPUT)\n# endif()\n\n\n########### GENERATED FILES #############\n\n# Build ndbmemcache_config.h\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/include/ndbmemcache_config.in \n               ${CMAKE_CURRENT_BINARY_DIR}/include/ndbmemcache_config.h)\n\n# Build sandbox.sh\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/sandbox.sh.in\n               ${CMAKE_CURRENT_BINARY_DIR}/sandbox.sh)\n               \n# Build the perl include file used by mtr\n# - setup special variables since perl hasn't got\n#   the same understanding of \"boolean variables\" as cmake has.\n#   i.e the cmake variables can be \"1\", \"ON\", \"TRUE\" etc.\nset(NDB_MEMCACHED_IS_AVAILABLE 0)\nif (MEMCACHED_FOUND)\n  set(NDB_MEMCACHED_IS_AVAILABLE 1)\nendif()\nset(NDB_MEMCACHED_IS_BUNDLED 0)\nif (WITH_BUNDLED_MEMCACHED)\n  set(NDB_MEMCACHED_IS_BUNDLED 1)\nendif()\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/memcached_path.pl.in\n               ${CMAKE_CURRENT_BINARY_DIR}/memcached_path.pl)\n\n# Copy the SQL script into /scripts/ in the build directory.\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/scripts/ndb_memcache_metadata.sql\n               ${CMAKE_BINARY_DIR}/scripts/ndb_memcache_metadata.sql COPYONLY)\n\n# Build the \"memclient\" utility\nSET(MEMCACHE_PM ${CMAKE_SOURCE_DIR}/mysql-test/lib/My/Memcache.pm)\nSET(MEMCLIENT_PL ${CMAKE_CURRENT_SOURCE_DIR}/memclient.pl)\nSET(MEMCLIENT ${CMAKE_CURRENT_BINARY_DIR}/memclient)\nFILE(READ   ${MEMCLIENT_PL} CONTENTS)\nFILE(WRITE  ${MEMCLIENT} \"${CONTENTS}\")\nFILE(READ   ${MEMCACHE_PM} CONTENTS)\nFILE(APPEND ${MEMCLIENT} \"${CONTENTS}\")\n\n               \n######### TARGETS ############\n\n### Build the convenience library\nADD_CONVENIENCE_LIBRARY(ndbmemcache ${NDB_MEMCACHE_SOURCE_FILES})\n\ntarget_link_libraries(ndbmemcache\n                      ndbclient_static\n                      ndbgeneral\n                      ${MEMCACHED_UTILITIES_LIBRARY})\n\n### Build the module\nIF(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  # Turn off array-bounds warning in ndb_engine.cc wich occurs\n  # when it uses the struct engine_info in the external memcached\n  # file engine.h to define its engine capabilities.\n  ADD_COMPILE_FLAGS(src/ndb_engine.cc\n                   COMPILE_FLAGS \"-Wno-array-bounds\")\nENDIF()\n\nadd_library(ndb_engine MODULE src/ndb_engine.cc src/stub.cc)\n\nIF(APPLE)\n  SET_TARGET_PROPERTIES(ndb_engine PROPERTIES\n    MACOSX_RPATH ON\n  )\nENDIF()\n\nIF(APPLE AND HAVE_CRYPTO_DYLIB AND HAVE_OPENSSL_DYLIB)\n  ADD_DEPENDENCIES(ndb_engine copy_openssl_dlls)\n\n  ADD_CUSTOM_COMMAND(TARGET ndb_engine POST_BUILD\n    COMMAND install_name_tool -change\n    \"${CRYPTO_VERSION}\" \"@loader_path/${CRYPTO_VERSION}\"\n    $<TARGET_LINKER_FILE:ndb_engine>\n    COMMAND install_name_tool -change\n    \"${OPENSSL_VERSION}\" \"@loader_path/${OPENSSL_VERSION}\"\n    $<TARGET_LINKER_FILE:ndb_engine>\n    )\nENDIF()\n\n# Collect all dynamic libraries in the same directory\nSET_TARGET_PROPERTIES(ndb_engine PROPERTIES\n  LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/library_output_directory)\n\nIF(LINUX_INSTALL_RPATH_ORIGIN)\n  SET_PROPERTY(TARGET ndb_engine PROPERTY INSTALL_RPATH \"\\$ORIGIN/\")\nENDIF()\n\nIF(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  # Turn off array-bounds warning in ndb_engine.c wich occurs\n  # when it uses the struct engine_info in the external memcached\n  # file engine.h to define its engine capabilities.\n  ADD_COMPILE_FLAGS(src/ndb_engine.cc\n                   COMPILE_FLAGS \"-Wno-array-bounds\")\nENDIF()\n\ntarget_link_libraries(ndb_engine ndbmemcache ndbclient_static)\n\n### If we are using the bundled memcache, it is a dependency:\nif(WITH_BUNDLED_MEMCACHED)\n  add_dependencies(ndb_engine memcached)\nendif()\n\n### Extra linker flags because CMake's \"MODULE\" support is not quite right.  \nif(APPLE) \n  set(FINAL_LINK_FLAGS \"-flat_namespace -undefined suppress -bind_at_load\")\nelseif(${CMAKE_COMPILER_IS_GNUCC}) \n  set(FINAL_LINK_FLAGS \"-shared\")\nelseif(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\") \n  set(FINAL_LINK_FLAGS \"${CMAKE_CXX_LINK_FLAGS}\")\nelse()\n  set(FINAL_LINK_FLAGS \"\")\nendif()\n#  Prepend any link flags required for building shared lib\nset(FINAL_LINK_FLAGS \"${CMAKE_SHARED_LIBRARY_C_FLAGS} ${FINAL_LINK_FLAGS}\")\n\nset_target_properties(ndb_engine PROPERTIES\n                      PREFIX \"\"\n                      LINK_FLAGS \"${FINAL_LINK_FLAGS}\")\n\n############ INSTALLER RULES #########\n### Install the ndb_engine.so module\n###\ninstall(TARGETS ndb_engine DESTINATION ${INSTALL_LIBDIR})\n\n### Install memclient \n### \ninstall(PROGRAMS ${MEMCLIENT} DESTINATION ${INSTALL_BINDIR})\n\n### Install the memcache-api directory\n###\nSET(MEMCACHE_API_DIR \"${INSTALL_MYSQLSHAREDIR}/memcache-api\")\ninstall(DIRECTORY DESTINATION ${MEMCACHE_API_DIR} )\ninstall(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/sandbox.sh \n        DESTINATION  ${MEMCACHE_API_DIR})\ninstall(FILES README DESTINATION  ${MEMCACHE_API_DIR})\ninstall(FILES ${CMAKE_CURRENT_SOURCE_DIR}/scripts/ndb_memcache_metadata.sql \n        DESTINATION  ${MEMCACHE_API_DIR})\n# Upgrader scripts:\ninstall(DIRECTORY DESTINATION ${MEMCACHE_API_DIR}/upgrade)\ninstall(FILES ${CMAKE_CURRENT_SOURCE_DIR}/scripts/update_to_1.2.sql\n        DESTINATION ${MEMCACHE_API_DIR}/upgrade)\n        \n# memcached_path.pl is also installed, for use by installed mtr\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/memcached_path.pl\n        DESTINATION ${INSTALL_MYSQLTESTDIR}/lib)\n        \n######################################################## \n\n\nadd_subdirectory(unit)\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/memcache/extra/memcached/daemon/memcached.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n *  memcached - memory caching daemon\n *\n *       http://www.danga.com/memcached/\n *\n *  Copyright 2003 Danga Interactive, Inc.  All rights reserved.\n *\n *  Use and distribution licensed under the BSD license.  See\n *  the LICENSE file for full text.\n *\n *  Authors:\n *      Anatoly Vorobey <mellon@pobox.com>\n *      Brad Fitzpatrick <brad@danga.com>\n */\n#include \"config.h\"\n#include \"memcached.h\"\n#include \"memcached/extension_loggers.h\"\n#include \"utilities/engine_loader.h\"\n\n#include <signal.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <assert.h>\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stddef.h>\n\nstatic inline void item_set_cas(const void *cookie, item *it, uint64_t cas) {\n    settings.engine.v1->item_set_cas(settings.engine.v0, cookie, it, cas);\n}\n\n/* The item must always be called \"it\" */\n#define SLAB_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->slab_stats[info.clsid].slab_op++;\n\n#define THREAD_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->thread_op++;\n\n#define THREAD_GUTS2(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->slab_op++; \\\n    thread_stats->thread_op++;\n\n#define SLAB_THREAD_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    SLAB_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    THREAD_GUTS(conn, thread_stats, slab_op, thread_op)\n\n#define STATS_INCR1(GUTS, conn, slab_op, thread_op, key, nkey) { \\\n    struct independent_stats *independent_stats = get_independent_stats(conn); \\\n    struct thread_stats *thread_stats = \\\n        &independent_stats->thread_stats[conn->thread->index]; \\\n    topkeys_t *topkeys = independent_stats->topkeys; \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    GUTS(conn, thread_stats, slab_op, thread_op); \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n    TK(topkeys, slab_op, key, nkey, current_time); \\\n}\n\n#define STATS_INCR(conn, op, key, nkey) \\\n    STATS_INCR1(THREAD_GUTS, conn, op, op, key, nkey)\n\n#define SLAB_INCR(conn, op, key, nkey) \\\n    STATS_INCR1(SLAB_GUTS, conn, op, op, key, nkey)\n\n#define STATS_TWO(conn, slab_op, thread_op, key, nkey) \\\n    STATS_INCR1(THREAD_GUTS2, conn, slab_op, thread_op, key, nkey)\n\n#define SLAB_TWO(conn, slab_op, thread_op, key, nkey) \\\n    STATS_INCR1(SLAB_THREAD_GUTS, conn, slab_op, thread_op, key, nkey)\n\n#define STATS_HIT(conn, op, key, nkey) \\\n    SLAB_TWO(conn, op##_hits, cmd_##op, key, nkey)\n\n#define STATS_MISS(conn, op, key, nkey) \\\n    STATS_TWO(conn, op##_misses, cmd_##op, key, nkey)\n\n#define STATS_NOKEY(conn, op) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op++; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\n#define STATS_NOKEY2(conn, op1, op2) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op1++; \\\n    thread_stats->op2++; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\n#define STATS_ADD(conn, op, amt) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op += amt; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\nvolatile sig_atomic_t memcached_shutdown;\n\n/*\n * We keep the current time of day in a global variable that's updated by a\n * timer event. This saves us a bunch of time() system calls (we really only\n * need to get the time once a second, whereas there can be tens of thousands\n * of requests a second) and allows us to use server-start-relative timestamps\n * rather than absolute UNIX timestamps, a space savings on systems where\n * sizeof(time_t) > sizeof(unsigned int).\n */\nvolatile rel_time_t current_time;\n\n/*\n * forward declarations\n */\nstatic SOCKET new_socket(struct addrinfo *ai);\nstatic int try_read_command(conn *c);\nstatic inline struct independent_stats *get_independent_stats(conn *c);\nstatic inline struct thread_stats *get_thread_stats(conn *c);\nstatic void register_callback(ENGINE_HANDLE *eh,\n                              ENGINE_EVENT_TYPE type,\n                              EVENT_CALLBACK cb, const void *cb_data);\n\n\nenum try_read_result {\n    READ_DATA_RECEIVED,\n    READ_NO_DATA_RECEIVED,\n    READ_ERROR,            /** an error occured (on the socket) (or client closed connection) */\n    READ_MEMORY_ERROR      /** failed to allocate more memory */\n};\n\nstatic enum try_read_result try_read_network(conn *c);\nstatic enum try_read_result try_read_udp(conn *c);\n\n/* stats */\nstatic void stats_init(void);\nstatic void server_stats(ADD_STAT add_stats, conn *c, bool aggregate);\nstatic void process_stat_settings(ADD_STAT add_stats, void *c);\n\n\n/* defaults */\nstatic void settings_init(void);\n\n/* event handling, network IO */\nstatic void event_handler(const int fd, const short which, void *arg);\nstatic void complete_nread(conn *c);\nstatic char *process_command(conn *c, char *command);\nstatic void write_and_free(conn *c, char *buf, int bytes);\nstatic int ensure_iov_space(conn *c);\nstatic int add_iov(conn *c, const void *buf, int len);\nstatic int add_msghdr(conn *c);\n\n\n/* time handling */\nstatic void set_current_time(void);  /* update the global variable holding\n                              global 32-bit seconds-since-start time\n                              (to avoid 64 bit time_t) */\n\n/** exported globals **/\nstruct stats stats;\nstruct settings settings;\nstatic time_t process_started;     /* when the process was started */\n\n/** file scope variables **/\nstatic conn *listen_conn = NULL;\nstatic struct event_base *main_base;\nstatic struct independent_stats *default_independent_stats;\n\nstatic struct engine_event_handler *engine_event_handlers[MAX_ENGINE_EVENT_TYPE + 1];\n\nenum transmit_result {\n    TRANSMIT_COMPLETE,   /** All done writing. */\n    TRANSMIT_INCOMPLETE, /** More data remaining to write. */\n    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */\n    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */\n};\n\nstatic enum transmit_result transmit(conn *c);\n\n#define REALTIME_MAXDELTA 60*60*24*30\n\n// Perform all callbacks of a given type for the given connection.\nstatic void perform_callbacks(ENGINE_EVENT_TYPE type,\n                              const void *data,\n                              const void *c) {\n    for (struct engine_event_handler *h = engine_event_handlers[type];\n         h; h = h->next) {\n        h->cb(c, type, data, h->cb_data);\n    }\n}\n\n/*\n * given time value that's either unix time or delta from current unix time,\n * return unix time. Use the fact that delta can't exceed one month\n * (and real time value can't be that low).\n */\nstatic rel_time_t realtime(const time_t exptime) {\n    /* no. of seconds in 30 days - largest possible delta exptime */\n\n    if (exptime == 0) return 0; /* 0 means never expire */\n\n    if (exptime > REALTIME_MAXDELTA) {\n        /* if item expiration is at/before the server started, give it an\n           expiration time of 1 second after the server started.\n           (because 0 means don't expire).  without this, we'd\n           underflow and wrap around to some large value way in the\n           future, effectively making items expiring in the past\n           really expiring never */\n        if (exptime <= process_started)\n            return (rel_time_t)1;\n        return (rel_time_t)(exptime - process_started);\n    } else {\n        return (rel_time_t)(exptime + current_time);\n    }\n}\n\n/**\n * Convert the relative time to an absolute time (relative to EPOC ;) )\n */\nstatic time_t abstime(const rel_time_t exptime)\n{\n    return process_started + exptime;\n}\n\nstatic void stats_init(void) {\n    stats.daemon_conns = 0;\n    stats.rejected_conns = 0;\n    stats.curr_conns = stats.total_conns = stats.conn_structs = 0;\n\n    stats_prefix_init();\n}\n\nstatic void stats_reset(const void *cookie) {\n    struct conn *conn = (struct conn*)cookie;\n    STATS_LOCK();\n    stats.rejected_conns = 0;\n    stats.total_conns = 0;\n    stats_prefix_clear();\n    STATS_UNLOCK();\n    threadlocal_stats_reset(get_independent_stats(conn)->thread_stats);\n    settings.engine.v1->reset_stats(settings.engine.v0, cookie);\n}\n\nstatic void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 11211;\n    /* By default this string should be NULL for getaddrinfo() */\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */\n    settings.maxconns = 1000;         /* to limit connections-related memory to about 5MB */\n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */\n    settings.socketpath = NULL;       /* by default, not using a unix socket */\n    settings.factor = 1.25;\n    settings.chunk_size = 48;         /* space for a modest key and value */\n    settings.num_threads = 4;         /* N workers */\n    settings.num_threads_per_udp = 0;\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.allow_detailed = true;\n    settings.reqs_per_event = DEFAULT_REQS_PER_EVENT;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */\n    settings.topkeys = 0;\n    settings.require_sasl = false;\n    settings.extensions.logger = get_stderr_logger();\n}\n\n/*\n * Adds a message header to a connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int add_msghdr(conn *c)\n{\n    struct msghdr *msg;\n\n    assert(c != NULL);\n\n    if (c->msgsize == c->msgused) {\n        msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));\n        if (! msg)\n            return -1;\n        c->msglist = msg;\n        c->msgsize *= 2;\n    }\n\n    msg = c->msglist + c->msgused;\n\n    /* this wipes msg_iovlen, msg_control, msg_controllen, and\n       msg_flags, the last 3 of which aren't defined on solaris: */\n    memset(msg, 0, sizeof(struct msghdr));\n\n    msg->msg_iov = &c->iov[c->iovused];\n\n    if (c->request_addr_size > 0) {\n        msg->msg_name = &c->request_addr;\n        msg->msg_namelen = c->request_addr_size;\n    }\n\n    c->msgbytes = 0;\n    c->msgused++;\n\n    if (IS_UDP(c->transport)) {\n        /* Leave room for the UDP header, which we'll fill in later. */\n        return add_iov(c, NULL, UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\nstatic const char *prot_text(enum protocol prot) {\n    const char *rv = \"unknown\";\n    switch(prot) {\n        case ascii_prot:\n            rv = \"ascii\";\n            break;\n        case binary_prot:\n            rv = \"binary\";\n            break;\n        case negotiating_prot:\n            rv = \"auto-negotiate\";\n            break;\n    }\n    return rv;\n}\n\nstruct {\n    pthread_mutex_t mutex;\n    bool disabled;\n    ssize_t count;\n    uint64_t num_disable;\n} listen_state = { .mutex = PTHREAD_MUTEX_INITIALIZER };\n\nstatic bool is_listen_disabled(void) {\n    bool ret;\n    pthread_mutex_lock(&listen_state.mutex);\n    ret = listen_state.disabled;\n    pthread_mutex_unlock(&listen_state.mutex);\n    return ret;\n}\n\nstatic uint64_t get_listen_disabled_num(void) {\n    uint64_t ret;\n    pthread_mutex_lock(&listen_state.mutex);\n    ret = listen_state.num_disable;\n    pthread_mutex_unlock(&listen_state.mutex);\n    return ret;\n}\n\nstatic void disable_listen(void) {\n    conn *next;\n    pthread_mutex_lock(&listen_state.mutex);\n    listen_state.disabled = true;\n    listen_state.count = 10;\n    ++listen_state.num_disable;\n    pthread_mutex_unlock(&listen_state.mutex);\n\n    for (next = listen_conn; next; next = next->next) {\n        update_event(next, 0);\n        if (listen(next->sfd, 1) != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"listen() failed\",\n                                            strerror(errno));\n        }\n    }\n}\n\nvoid safe_close(SOCKET sfd) {\n    if (sfd != INVALID_SOCKET) {\n        int rval;\n        while ((rval = closesocket(sfd)) == SOCKET_ERROR &&\n               (errno == EINTR || errno == EAGAIN)) {\n            /* go ahead and retry */\n        }\n\n        if (rval == SOCKET_ERROR) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"Failed to close socket %d (%s)!!\\n\", (int)sfd,\n                                            strerror(errno));\n        } else {\n            STATS_LOCK();\n            stats.curr_conns--;\n            STATS_UNLOCK();\n\n            if (is_listen_disabled()) {\n                notify_dispatcher();\n            }\n        }\n    }\n}\n\n/*\n * Free list management for connections.\n */\ncache_t *conn_cache;      /* suffix cache */\n\n/**\n * Reset all of the dynamic buffers used by a connection back to their\n * default sizes. The strategy for resizing the buffers is to allocate a\n * new one of the correct size and free the old one if the allocation succeeds\n * instead of using realloc to change the buffer size (because realloc may\n * not shrink the buffers, and will also copy the memory). If the allocation\n * fails the buffer will be unchanged.\n *\n * @param c the connection to resize the buffers for\n * @return true if all allocations succeeded, false if one or more of the\n *         allocations failed.\n */\nstatic bool conn_reset_buffersize(conn *c) {\n    bool ret = true;\n\n    if (c->rsize != DATA_BUFFER_SIZE) {\n        void *ptr = malloc(DATA_BUFFER_SIZE);\n        if (ptr != NULL) {\n            free(c->rbuf);\n            c->rbuf = ptr;\n            c->rsize = DATA_BUFFER_SIZE;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->wsize != DATA_BUFFER_SIZE) {\n        void *ptr = malloc(DATA_BUFFER_SIZE);\n        if (ptr != NULL) {\n            free(c->wbuf);\n            c->wbuf = ptr;\n            c->wsize = DATA_BUFFER_SIZE;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->isize != ITEM_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(item *) * ITEM_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->ilist);\n            c->ilist = ptr;\n            c->isize = ITEM_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->suffixsize != SUFFIX_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(char *) * SUFFIX_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->suffixlist);\n            c->suffixlist = ptr;\n            c->suffixsize = SUFFIX_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->iovsize != IOV_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(struct iovec) * IOV_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->iov);\n            c->iov = ptr;\n            c->iovsize = IOV_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->msgsize != MSG_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(struct msghdr) * MSG_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->msglist);\n            c->msglist = ptr;\n            c->msgsize = MSG_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    return ret;\n}\n\n/**\n * Constructor for all memory allocations of connection objects. Initialize\n * all members and allocate the transfer buffers.\n *\n * @param buffer The memory allocated by the object cache\n * @param unused1 not used\n * @param unused2 not used\n * @return 0 on success, 1 if we failed to allocate memory\n */\nstatic int conn_constructor(void *buffer, void *unused1, int unused2) {\n    conn *c = buffer;\n    memset(c, 0, sizeof(*c));\n    MEMCACHED_CONN_CREATE(c);\n    (void)unused1; (void)unused2;\n\n    if (!conn_reset_buffersize(c)) {\n        free(c->rbuf);\n        free(c->wbuf);\n        free(c->ilist);\n        free(c->suffixlist);\n        free(c->iov);\n        free(c->msglist);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING,\n                                        NULL,\n                                        \"Failed to allocate buffers for connection\\n\");\n        return 1;\n    }\n\n    STATS_LOCK();\n    stats.conn_structs++;\n    STATS_UNLOCK();\n\n    return 0;\n}\n\n/**\n * Destructor for all connection objects. Release all allocated resources.\n *\n * @param buffer The memory allocated by the objec cache\n * @param unused not used\n */\nstatic void conn_destructor(void *buffer, void *unused) {\n    conn *c = buffer;\n    free(c->rbuf);\n    free(c->wbuf);\n    free(c->ilist);\n    free(c->suffixlist);\n    free(c->iov);\n    free(c->msglist);\n\n    STATS_LOCK();\n    stats.conn_structs--;\n    STATS_UNLOCK();\n    (void)unused;\n}\n\nconn *conn_new(const SOCKET sfd, STATE_FUNC init_state,\n               const int event_flags,\n               const int read_buffer_size, enum network_transport transport,\n               struct event_base *base, struct timeval *timeout) {\n    conn *c = cache_alloc(conn_cache);\n    if (c == NULL) {\n        return NULL;\n    }\n\n    assert(c->thread == NULL);\n\n    if (c->rsize < read_buffer_size) {\n        void *mem = malloc(read_buffer_size);\n        if (mem) {\n            c->rsize = read_buffer_size;\n            free(c->rbuf);\n            c->rbuf = mem;\n        } else {\n            assert(c->thread == NULL);\n            cache_free(conn_cache, c);\n            return NULL;\n        }\n    }\n\n    c->transport = transport;\n    c->protocol = settings.binding_protocol;\n\n    if (IS_UDP(transport)) {\n        c->request_addr_size = sizeof(c->request_addr);\n    } else {\n        c->request_addr_size = 0;\n    }\n\n    if (settings.verbose > 1) {\n        if (init_state == conn_listening) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d server listening (%s)\\n\", sfd,\n                                            prot_text(c->protocol));\n        } else if (IS_UDP(transport)) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d server listening (udp)\\n\", sfd);\n        } else if (c->protocol == negotiating_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new auto-negotiating client connection\\n\",\n                                            sfd);\n        } else if (c->protocol == ascii_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new ascii client connection.\\n\", sfd);\n        } else if (c->protocol == binary_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new binary client connection.\\n\", sfd);\n        } else {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new unknown (%d) client connection\\n\",\n                                            sfd, c->protocol);\n            assert(false);\n        }\n    }\n\n    c->sfd = sfd;\n    c->state = init_state;\n    c->rlbytes = 0;\n    c->cmd = -1;\n    c->ascii_cmd = NULL;\n    c->rbytes = c->wbytes = 0;\n    c->wcurr = c->wbuf;\n    c->rcurr = c->rbuf;\n    c->ritem = 0;\n    c->icurr = c->ilist;\n    c->suffixcurr = c->suffixlist;\n    c->ileft = 0;\n    c->suffixleft = 0;\n    c->iovused = 0;\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->next = NULL;\n    c->list_state = 0;\n\n    c->write_and_go = init_state;\n    c->write_and_free = 0;\n    c->item = 0;\n\n    c->noreply = false;\n\n    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = event_flags;\n\n    if (!register_event(c, timeout)) {\n        assert(c->thread == NULL);\n        cache_free(conn_cache, c);\n        return NULL;\n    }\n\n    STATS_LOCK();\n    stats.total_conns++;\n    STATS_UNLOCK();\n\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    c->refcount = 1;\n\n    MEMCACHED_CONN_ALLOCATE(c->sfd);\n\n    perform_callbacks(ON_CONNECT, NULL, c);\n\n    return c;\n}\n\nstatic void conn_cleanup(conn *c) {\n    assert(c != NULL);\n\n    if (c->item) {\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n\n    if (c->ileft != 0) {\n        for (; c->ileft > 0; c->ileft--,c->icurr++) {\n            settings.engine.v1->release(settings.engine.v0, c, *(c->icurr));\n        }\n    }\n\n    if (c->suffixleft != 0) {\n        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {\n            cache_free(c->thread->suffix_cache, *(c->suffixcurr));\n        }\n    }\n\n    if (c->write_and_free) {\n        free(c->write_and_free);\n        c->write_and_free = 0;\n    }\n\n    if (c->sasl_conn) {\n        sasl_dispose(&c->sasl_conn);\n        c->sasl_conn = NULL;\n    }\n\n    c->engine_storage = NULL;\n    c->tap_iterator = NULL;\n    c->thread = NULL;\n    assert(c->next == NULL);\n    c->ascii_cmd = NULL;\n    c->sfd = INVALID_SOCKET;\n}\n\nvoid conn_close(conn *c) {\n    assert(c != NULL);\n    assert(c->sfd == INVALID_SOCKET);\n\n    if (c->ascii_cmd != NULL) {\n        c->ascii_cmd->abort(c->ascii_cmd, c);\n    }\n\n    assert(c->thread);\n    LOCK_THREAD(c->thread);\n    /* remove from pending-io list */\n    if (settings.verbose > 1 && list_contains(c->thread->pending_io, c)) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Current connection was in the pending-io list.. Nuking it\\n\");\n    }\n    c->thread->pending_io = list_remove(c->thread->pending_io, c);\n    c->thread->pending_close = list_remove(c->thread->pending_close, c);\n    UNLOCK_THREAD(c->thread);\n\n    conn_cleanup(c);\n\n    /*\n     * The contract with the object cache is that we should return the\n     * object in a constructed state. Reset the buffers to the default\n     * size\n     */\n    conn_reset_buffersize(c);\n    assert(c->thread == NULL);\n    cache_free(conn_cache, c);\n}\n\n/*\n * Shrinks a connection's buffers if they're too big.  This prevents\n * periodic large \"get\" requests from permanently chewing lots of server\n * memory.\n *\n * This should only be called in between requests since it can wipe output\n * buffers!\n */\nstatic void conn_shrink(conn *c) {\n    assert(c != NULL);\n\n    if (IS_UDP(c->transport))\n        return;\n\n    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {\n        char *newbuf;\n\n        if (c->rcurr != c->rbuf)\n            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);\n\n        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);\n\n        if (newbuf) {\n            c->rbuf = newbuf;\n            c->rsize = DATA_BUFFER_SIZE;\n        }\n        /* TODO check other branch... */\n        c->rcurr = c->rbuf;\n    }\n\n    if (c->isize > ITEM_LIST_HIGHWAT) {\n        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));\n        if (newbuf) {\n            c->ilist = newbuf;\n            c->isize = ITEM_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->msgsize > MSG_LIST_HIGHWAT) {\n        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));\n        if (newbuf) {\n            c->msglist = newbuf;\n            c->msgsize = MSG_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->iovsize > IOV_LIST_HIGHWAT) {\n        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));\n        if (newbuf) {\n            c->iov = newbuf;\n            c->iovsize = IOV_LIST_INITIAL;\n        }\n    /* TODO check return value */\n    }\n}\n\n/**\n * Convert a state name to a human readable form.\n */\nconst char *state_text(STATE_FUNC state) {\n    if (state == conn_listening) {\n        return \"conn_listening\";\n    } else if (state == conn_new_cmd) {\n        return \"conn_new_cmd\";\n    } else if (state == conn_waiting) {\n        return \"conn_waiting\";\n    } else if (state == conn_read) {\n        return \"conn_read\";\n    } else if (state == conn_parse_cmd) {\n        return \"conn_parse_cmd\";\n    } else if (state == conn_write) {\n        return \"conn_write\";\n    } else if (state == conn_nread) {\n        return \"conn_nread\";\n    } else if (state == conn_swallow) {\n        return \"conn_swallow\";\n    } else if (state == conn_closing) {\n        return \"conn_closing\";\n    } else if (state == conn_mwrite) {\n        return \"conn_mwrite\";\n    } else if (state == conn_ship_log) {\n        return \"conn_ship_log\";\n    } else if (state == conn_add_tap_client) {\n        return \"conn_add_tap_client\";\n    } else if (state == conn_setup_tap_stream) {\n        return \"conn_setup_tap_stream\";\n    } else if (state == conn_pending_close) {\n        return \"conn_pending_close\";\n    } else if (state == conn_immediate_close) {\n        return \"conn_immediate_close\";\n    } else {\n        return \"Unknown\";\n    }\n}\n\n/*\n * Sets a connection's current state in the state machine. Any special\n * processing that needs to happen on certain state transitions can\n * happen here.\n */\nvoid conn_set_state(conn *c, STATE_FUNC state) {\n    assert(c != NULL);\n\n    if (state != c->state) {\n        /*\n         * The connections in the \"tap thread\" behaves differently than\n         * normal connections because they operate in a full duplex mode.\n         * New messages may appear from both sides, so we can't block on\n         * read from the nework / engine\n         */\n        if (c->thread == tap_thread) {\n            if (state == conn_waiting) {\n                c->which = EV_WRITE;\n                state = conn_ship_log;\n            }\n        }\n\n        if (settings.verbose > 2 || c->state == conn_closing\n            || c->state == conn_add_tap_client) {\n            settings.extensions.logger->log(EXTENSION_LOG_DETAIL, c,\n                                            \"%d: going from %s to %s\\n\",\n                                            c->sfd, state_text(c->state),\n                                            state_text(state));\n        }\n\n        if (state == conn_write || state == conn_mwrite) {\n            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);\n        }\n\n        c->state = state;\n    }\n}\n\n/*\n * Ensures that there is room for another struct iovec in a connection's\n * iov list.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int ensure_iov_space(conn *c) {\n    assert(c != NULL);\n\n    if (c->iovused >= c->iovsize) {\n        int i, iovnum;\n        struct iovec *new_iov = (struct iovec *)realloc(c->iov,\n                                (c->iovsize * 2) * sizeof(struct iovec));\n        if (! new_iov)\n            return -1;\n        c->iov = new_iov;\n        c->iovsize *= 2;\n\n        /* Point all the msghdr structures at the new list. */\n        for (i = 0, iovnum = 0; i < c->msgused; i++) {\n            c->msglist[i].msg_iov = &c->iov[iovnum];\n            iovnum += c->msglist[i].msg_iovlen;\n        }\n    }\n\n    return 0;\n}\n\n\n/*\n * Adds data to the list of pending data that will be written out to a\n * connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\n\nstatic int add_iov(conn *c, const void *buf, int len) {\n    struct msghdr *m;\n    int leftover;\n    bool limit_to_mtu;\n\n    assert(c != NULL);\n\n    do {\n        m = &c->msglist[c->msgused - 1];\n\n        /*\n         * Limit UDP packets, and the first payloads of TCP replies, to\n         * UDP_MAX_PAYLOAD_SIZE bytes.\n         */\n        limit_to_mtu = IS_UDP(c->transport) || (1 == c->msgused);\n\n        /* We may need to start a new msghdr if this one is full. */\n        if (m->msg_iovlen == IOV_MAX ||\n            (limit_to_mtu && c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {\n            add_msghdr(c);\n            m = &c->msglist[c->msgused - 1];\n        }\n\n        if (ensure_iov_space(c) != 0)\n            return -1;\n\n        /* If the fragment is too big to fit in the datagram, split it up */\n        if (limit_to_mtu && len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {\n            leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;\n            len -= leftover;\n        } else {\n            leftover = 0;\n        }\n\n        m = &c->msglist[c->msgused - 1];\n        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;\n        m->msg_iov[m->msg_iovlen].iov_len = len;\n\n        c->msgbytes += len;\n        c->iovused++;\n        m->msg_iovlen++;\n\n        buf = ((char *)buf) + len;\n        len = leftover;\n    } while (leftover > 0);\n\n    return 0;\n}\n\n\n/*\n * Constructs a set of UDP headers and attaches them to the outgoing messages.\n */\nstatic int build_udp_headers(conn *c) {\n    int i;\n    unsigned char *hdr;\n\n    assert(c != NULL);\n\n    if (c->msgused > c->hdrsize) {\n        void *new_hdrbuf;\n        if (c->hdrbuf)\n            new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);\n        else\n            new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);\n        if (! new_hdrbuf)\n            return -1;\n        c->hdrbuf = (unsigned char *)new_hdrbuf;\n        c->hdrsize = c->msgused * 2;\n    }\n\n    hdr = c->hdrbuf;\n    for (i = 0; i < c->msgused; i++) {\n        c->msglist[i].msg_iov[0].iov_base = (void*)hdr;\n        c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;\n        *hdr++ = c->request_id / 256;\n        *hdr++ = c->request_id % 256;\n        *hdr++ = i / 256;\n        *hdr++ = i % 256;\n        *hdr++ = c->msgused / 256;\n        *hdr++ = c->msgused % 256;\n        *hdr++ = 0;\n        *hdr++ = 0;\n        assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\n\nstatic void out_string(conn *c, const char *str) {\n    size_t len;\n\n    assert(c != NULL);\n\n    if (c->noreply) {\n        if (settings.verbose > 1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \">%d NOREPLY %s\\n\", c->sfd, str);\n        }\n        c->noreply = false;\n        if (c->sbytes > 0) {\n            conn_set_state(c, conn_swallow);\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n        return;\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d %s\\n\", c->sfd, str);\n    }\n\n    /* Nuke a partial output... */\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    add_msghdr(c);\n\n    len = strlen(str);\n    if ((len + 2) > c->wsize) {\n        /* ought to be always enough. just fail for simplicity */\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n\n    memcpy(c->wbuf, str, len);\n    memcpy(c->wbuf + len, \"\\r\\n\", 2);\n    c->wbytes = len + 2;\n    c->wcurr = c->wbuf;\n\n    conn_set_state(c, conn_write);\n\n    if (c->sbytes > 0) {\n        c->write_and_go = conn_swallow;\n    } else {\n        c->write_and_go = conn_new_cmd;\n    }\n\n    return;\n}\n\n/*\n * we get here after reading the value in set/add/replace commands. The command\n * has been stored in c->cmd, and the item is ready in c->item.\n */\nstatic void complete_update_ascii(conn *c) {\n    assert(c != NULL);\n\n    item *it = c->item;\n    item_info info = { .nvalue = 1 };\n    if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n        settings.engine.v1->release(settings.engine.v0, c, it);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: Failed to get item info\\n\",\n                                        c->sfd);\n        out_string(c, \"SERVER_ERROR failed to get item details\");\n        return;\n    }\n\n    c->sbytes = 2; // swallow \\r\\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->store(settings.engine.v0, c, it, &c->cas,\n                                        c->store_op, 0);\n    }\n\n#ifdef ENABLE_DTRACE\n    switch (c->store_op) {\n    case OPERATION_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, info.key, info.nkey,\n                                 (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_CAS:\n        MEMCACHED_COMMAND_CAS(c->sfd, info.key, info.nkey, info.nbytes, c->cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        out_string(c, \"STORED\");\n        break;\n    case ENGINE_KEY_EEXISTS:\n        out_string(c, \"EXISTS\");\n        break;\n    case ENGINE_KEY_ENOENT:\n        out_string(c, \"NOT_FOUND\");\n        break;\n    case ENGINE_NOT_STORED:\n        out_string(c, \"NOT_STORED\");\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        out_string(c, \"SERVER_ERROR not supported\");\n        break;\n    case ENGINE_ENOMEM:\n        out_string(c, \"SERVER_ERROR out of memory\");\n        break;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    case ENGINE_EINVAL:\n        out_string(c, \"CLIENT_ERROR invalid arguments\");\n        break;\n    case ENGINE_E2BIG:\n        out_string(c, \"CLIENT_ERROR value too big\");\n        break;\n    case ENGINE_EACCESS:\n        out_string(c, \"CLIENT_ERROR access control violation\");\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        out_string(c, \"SERVER_ERROR not my vbucket\");\n        break;\n    case ENGINE_FAILED:\n        out_string(c, \"SERVER_ERROR failure\");\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_WANT_MORE:\n        assert(false);\n        c->state = conn_closing;\n        break;\n\n    default:\n        out_string(c, \"SERVER_ERROR internal\");\n    }\n\n    if (c->store_op == OPERATION_CAS) {\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            SLAB_INCR(c, cas_hits, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_EEXISTS:\n            SLAB_INCR(c, cas_badval, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_ENOENT:\n            STATS_NOKEY(c, cas_misses);\n            break;\n        default:\n            ;\n        }\n    } else {\n        SLAB_INCR(c, cmd_set, info.key, info.nkey);\n    }\n\n    if (!c->ewouldblock) {\n        /* release the c->item reference */\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n}\n\n/**\n * get a pointer to the start of the request struct for the current command\n */\nstatic void* binary_get_request(conn *c) {\n    char *ret = c->rcurr;\n    ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +\n            c->binary_header.request.extlen);\n\n    assert(ret >= c->rbuf);\n    return ret;\n}\n\n/**\n * get a pointer to the key in this request\n */\nstatic char* binary_get_key(conn *c) {\n    return c->rcurr - (c->binary_header.request.keylen);\n}\n\n/**\n * Insert a key into a buffer, but replace all non-printable characters\n * with a '.'.\n *\n * @param dest where to store the output\n * @param destsz size of destination buffer\n * @param prefix string to insert before the data\n * @param client the client we are serving\n * @param from_client set to true if this data is from the client\n * @param key the key to add to the buffer\n * @param nkey the number of bytes in the key\n * @return number of bytes in dest if success, -1 otherwise\n */\nstatic ssize_t key_to_printable_buffer(char *dest, size_t destsz,\n                                       int client, bool from_client,\n                                       const char *prefix,\n                                       const char *key,\n                                       size_t nkey)\n{\n    ssize_t nw = snprintf(dest, destsz, \"%c%d %s \", from_client ? '>' : '<',\n                          client, prefix);\n    size_t ii;\n    char *ptr = dest + nw;\n    if (nw == -1) {\n        return -1;\n    }\n\n    destsz -= nw;\n    if (nkey > destsz) {\n        nkey = destsz;\n    }\n\n    for (ii = 0; ii < nkey; ++ii, ++key, ++ptr) {\n        if (isgraph(*key)) {\n            *ptr = *key;\n        } else {\n            *ptr = '.';\n        }\n    }\n\n    *ptr = '\\0';\n    return ptr - dest;\n}\n\n/**\n * Convert a byte array to a text string\n *\n * @param dest where to store the output\n * @param destsz size of destination buffer\n * @param prefix string to insert before the data\n * @param client the client we are serving\n * @param from_client set to true if this data is from the client\n * @param data the data to add to the buffer\n * @param size the number of bytes in data to print\n * @return number of bytes in dest if success, -1 otherwise\n */\nstatic ssize_t bytes_to_output_string(char *dest, size_t destsz,\n                                      int client, bool from_client,\n                                      const char *prefix,\n                                      const char *data,\n                                      size_t size)\n{\n    ssize_t nw = snprintf(dest, destsz, \"%c%d %s\", from_client ? '>' : '<',\n                          client, prefix);\n    size_t ii;\n    ssize_t offset = nw;\n    if (nw == -1) {\n        return -1;\n    }\n\n    for (ii = 0; ii < size; ++ii) {\n        if (ii % 4 == 0) {\n            if ((nw = snprintf(dest + offset, destsz - offset, \"\\n%c%d  \",\n                               from_client ? '>' : '<', client)) == -1) {\n                return  -1;\n            }\n            offset += nw;\n        }\n        if ((nw = snprintf(dest + offset, destsz - offset,\n                           \" 0x%02x\", (unsigned char)data[ii])) == -1) {\n            return -1;\n        }\n        offset += nw;\n    }\n\n    if ((nw = snprintf(dest + offset, destsz - offset, \"\\n\")) == -1) {\n        return -1;\n    }\n\n    return offset + nw;\n}\n\nstatic void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {\n    protocol_binary_response_header* header;\n\n    assert(c);\n\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        /* XXX:  out_string is inappropriate here */\n        out_string(c, \"SERVER_ERROR out of memory\");\n        return;\n    }\n\n    header = (protocol_binary_response_header *)c->wbuf;\n\n    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;\n    header->response.opcode = c->binary_header.request.opcode;\n    header->response.keylen = (uint16_t)htons(key_len);\n\n    header->response.extlen = (uint8_t)hdr_len;\n    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;\n    header->response.status = (uint16_t)htons(err);\n\n    header->response.bodylen = htonl(body_len);\n    header->response.opaque = c->opaque;\n    header->response.cas = htonll(c->cas);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (bytes_to_output_string(buffer, sizeof(buffer), c->sfd, false,\n                                   \"Writing bin response:\",\n                                   (const char*)header->bytes,\n                                   sizeof(header->bytes)) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"%s\", buffer);\n        }\n    }\n\n    add_iov(c, c->wbuf, sizeof(header->response));\n}\n\n/**\n * Convert an error code generated from the storage engine to the corresponding\n * error code used by the protocol layer.\n * @param e the error code as used in the engine\n * @return the error code as used by the protocol layer\n */\nstatic protocol_binary_response_status engine_error_2_protocol_error(ENGINE_ERROR_CODE e) {\n    protocol_binary_response_status ret;\n\n    switch (e) {\n    case ENGINE_SUCCESS:\n        return PROTOCOL_BINARY_RESPONSE_SUCCESS;\n    case ENGINE_KEY_ENOENT:\n        return PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n    case ENGINE_KEY_EEXISTS:\n        return PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n    case ENGINE_ENOMEM:\n        return PROTOCOL_BINARY_RESPONSE_ENOMEM;\n    case ENGINE_TMPFAIL:\n        return PROTOCOL_BINARY_RESPONSE_ETMPFAIL;\n    case ENGINE_NOT_STORED:\n        return PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n    case ENGINE_EINVAL:\n        return PROTOCOL_BINARY_RESPONSE_EINVAL;\n    case ENGINE_ENOTSUP:\n        return PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED;\n    case ENGINE_E2BIG:\n        return PROTOCOL_BINARY_RESPONSE_E2BIG;\n    case ENGINE_NOT_MY_VBUCKET:\n        return PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET;\n    case ENGINE_ERANGE:\n        return PROTOCOL_BINARY_RESPONSE_ERANGE;\n    default:\n        ret = PROTOCOL_BINARY_RESPONSE_EINTERNAL;\n    }\n\n    return ret;\n}\n\nstatic void write_bin_packet(conn *c, protocol_binary_response_status err, int swallow) {\n    ssize_t len;\n    char buffer[1024] = { [sizeof(buffer) - 1] = '\\0' };\n\n    switch (err) {\n    case PROTOCOL_BINARY_RESPONSE_SUCCESS:\n        len = 0;\n        break;\n    case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n        len = snprintf(buffer, sizeof(buffer), \"Out of memory\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_ETMPFAIL:\n        len = snprintf(buffer, sizeof(buffer), \"Temporary failure\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n        len = snprintf(buffer, sizeof(buffer), \"Unknown command\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n        len = snprintf(buffer, sizeof(buffer), \"Not found\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_EINVAL:\n        len = snprintf(buffer, sizeof(buffer), \"Invalid arguments\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n        len = snprintf(buffer, sizeof(buffer), \"Data exists for key\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_E2BIG:\n        len = snprintf(buffer, sizeof(buffer), \"Too large\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:\n        len = snprintf(buffer, sizeof(buffer),\n                       \"Non-numeric server-side value for incr or decr\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n        len = snprintf(buffer, sizeof(buffer), \"Not stored\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n        len = snprintf(buffer, sizeof(buffer), \"Auth failure\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED:\n        len = snprintf(buffer, sizeof(buffer), \"Not supported\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET:\n        len = snprintf(buffer, sizeof(buffer),\n                       \"I'm not responsible for this vbucket\");\n        break;\n\n    default:\n        len = snprintf(buffer, sizeof(buffer), \"UNHANDLED ERROR (%d)\", err);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \">%d UNHANDLED ERROR: %d\\n\", c->sfd, err);\n    }\n\n    /* Allow the engine to pass extra error information */\n    if (settings.engine.v1->errinfo != NULL) {\n        size_t elen = settings.engine.v1->errinfo(settings.engine.v0, c, buffer + len + 2,\n                                                  sizeof(buffer) - len - 3);\n\n        if (elen > 0) {\n            memcpy(buffer + len, \": \", 2);\n            len += elen + 2;\n        }\n    }\n\n    if (err != PROTOCOL_BINARY_RESPONSE_SUCCESS && settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d Writing an error: %s\\n\", c->sfd,\n                                        buffer);\n    }\n\n    add_bin_header(c, err, 0, 0, len);\n    if (len > 0) {\n        add_iov(c, buffer, len);\n    }\n    conn_set_state(c, conn_mwrite);\n    if (swallow > 0) {\n        c->sbytes = swallow;\n        c->write_and_go = conn_swallow;\n    } else {\n        c->write_and_go = conn_new_cmd;\n    }\n}\n\n/* Form and send a response to a command over the binary protocol */\nstatic void write_bin_response(conn *c, const void *d, int hlen, int keylen, int dlen) {\n    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||\n        c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n        add_bin_header(c, 0, hlen, keylen, dlen);\n        if(dlen > 0) {\n            add_iov(c, d, dlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        conn_set_state(c, conn_new_cmd);\n    }\n}\n\n\nstatic void complete_incr_bin(conn *c) {\n    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;\n    protocol_binary_request_incr* req = binary_get_request(c);\n\n    assert(c != NULL);\n    assert(c->wsize >= sizeof(*rsp));\n\n    /* fix byteorder in the request */\n    uint64_t delta = ntohll(req->message.body.delta);\n    uint64_t initial = ntohll(req->message.body.initial);\n    rel_time_t expiration = ntohl(req->message.body.expiration);\n    char *key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n    bool incr = (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT ||\n                 c->cmd == PROTOCOL_BINARY_CMD_INCREMENTQ);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        ssize_t nw;\n        nw = key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                     incr ? \"INCR\" : \"DECR\", key, nkey);\n        if (nw != -1) {\n            if (snprintf(buffer + nw, sizeof(buffer) - nw,\n                         \" %\" PRIu64 \", %\" PRIu64 \", %\" PRIu64 \"\\n\",\n                         delta, initial, (uint64_t)expiration) != -1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\",\n                                                buffer);\n            }\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->arithmetic(settings.engine.v0,\n                                             c, key, nkey, incr,\n                                             req->message.body.expiration != 0xffffffff,\n                                             delta, initial, expiration,\n                                             &c->cas,\n                                             &rsp->message.body.value,\n                                             c->binary_header.request.vbucket);\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        rsp->message.body.value = htonll(rsp->message.body.value);\n        write_bin_response(c, &rsp->message.body, 0, 0,\n                           sizeof (rsp->message.body.value));\n        if (incr) {\n            STATS_INCR(c, incr_hits, key, nkey);\n        } else {\n            STATS_INCR(c, decr_hits, key, nkey);\n        }\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n            STATS_INCR(c, incr_misses, key, nkey);\n        } else {\n            STATS_INCR(c, decr_misses, key, nkey);\n        }\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_EINVAL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, 0);\n        break;\n    case ENGINE_NOT_STORED:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED, 0);\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        abort();\n    }\n}\n\nstatic void complete_update_bin(conn *c) {\n    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;\n    assert(c != NULL);\n\n    item *it = c->item;\n    item_info info = { .nvalue = 1 };\n    if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n        settings.engine.v1->release(settings.engine.v0, c, it);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: Failed to get item info\\n\",\n                                        c->sfd);\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n        return;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->store(settings.engine.v0, c,\n                                        it, &c->cas, c->store_op,\n                                        c->binary_header.request.vbucket);\n    }\n\n#ifdef ENABLE_DTRACE\n    switch (c->cmd) {\n    case OPERATION_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, info.key, info.nkey,\n                                 (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        /* Stored */\n        write_bin_response(c, NULL, 0, 0, 0);\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    default:\n        if (c->store_op == OPERATION_ADD) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n        } else if(c->store_op == OPERATION_REPLACE) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n        } else {\n            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n        }\n        write_bin_packet(c, eno, 0);\n    }\n\n    if (c->store_op == OPERATION_CAS) {\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            SLAB_INCR(c, cas_hits, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_EEXISTS:\n            SLAB_INCR(c, cas_badval, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_ENOENT:\n            STATS_NOKEY(c, cas_misses);\n            break;\n        default:\n            ;\n        }\n    } else {\n        SLAB_INCR(c, cmd_set, info.key, info.nkey);\n    }\n\n    if (!c->ewouldblock) {\n        /* release the c->item reference */\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n}\n\nstatic void process_bin_get(conn *c) {\n    item *it;\n\n    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"GET\", key, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->get(settings.engine.v0, c, &it, key, nkey,\n                                      c->binary_header.request.vbucket);\n    }\n\n    uint16_t keylen;\n    uint32_t bodylen;\n    item_info info = { .nvalue = 1 };\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"%d: Failed to get item info\\n\",\n                                            c->sfd);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            break;\n        }\n\n        keylen = 0;\n        bodylen = sizeof(rsp->message.body) + info.nbytes;\n\n        STATS_HIT(c, get, key, nkey);\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            bodylen += nkey;\n            keylen = nkey;\n        }\n        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);\n        rsp->message.header.response.cas = htonll(info.cas);\n\n        // add the flags\n        rsp->message.body.flags = info.flags;\n        add_iov(c, &rsp->message.body, sizeof(rsp->message.body));\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            add_iov(c, info.key, nkey);\n        }\n\n        add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n        conn_set_state(c, conn_mwrite);\n        /* Remember this item so we can garbage collect it later */\n        c->item = it;\n        break;\n    case ENGINE_KEY_ENOENT:\n        STATS_MISS(c, get, key, nkey);\n\n        MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n\n        if (c->noreply) {\n            conn_set_state(c, conn_new_cmd);\n        } else {\n            if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n                char *ofs = c->wbuf + sizeof(protocol_binary_response_header);\n                add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,\n                               0, nkey, nkey);\n                memcpy(ofs, key, nkey);\n                add_iov(c, ofs, nkey);\n                conn_set_state(c, conn_mwrite);\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n            }\n        }\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n\n    default:\n        /* @todo add proper error handling! */\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Unknown error code: %d\\n\", ret);\n        abort();\n    }\n\n    if (settings.detail_enabled && ret != ENGINE_EWOULDBLOCK) {\n        stats_prefix_record_get(key, nkey, ret == ENGINE_SUCCESS);\n    }\n}\n\nstatic void append_bin_stats(const char *key, const uint16_t klen,\n                             const char *val, const uint32_t vlen,\n                             conn *c) {\n    char *buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    uint32_t bodylen = klen + vlen;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = PROTOCOL_BINARY_CMD_STAT,\n        .response.keylen = (uint16_t)htons(klen),\n        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,\n        .response.bodylen = htonl(bodylen),\n        .response.opaque = c->opaque\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (klen > 0) {\n        memcpy(buf, key, klen);\n        buf += klen;\n\n        if (vlen > 0) {\n            memcpy(buf, val, vlen);\n        }\n    }\n\n    c->dynamic_buffer.offset += sizeof(header.response) + bodylen;\n}\n\n/**\n * Append a key-value pair to the stats output buffer. This function assumes\n * that the output buffer is big enough (it will be if you call it through\n * append_stats)\n */\nstatic void append_ascii_stats(const char *key, const uint16_t klen,\n                               const char *val, const uint32_t vlen,\n                               conn *c) {\n    char *pos = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    uint32_t nbytes = 5; /* \"END\\r\\n\" or \"STAT \" */\n\n    if (klen == 0 && vlen == 0) {\n        memcpy(pos, \"END\\r\\n\", 5);\n    } else {\n        memcpy(pos, \"STAT \", 5);\n        memcpy(pos + nbytes, key, klen);\n        nbytes += klen;\n        if (vlen != 0) {\n            pos[nbytes] = ' ';\n            ++nbytes;\n            memcpy(pos + nbytes, val, vlen);\n            nbytes += vlen;\n        }\n        memcpy(pos + nbytes, \"\\r\\n\", 2);\n        nbytes += 2;\n    }\n\n    c->dynamic_buffer.offset += nbytes;\n}\n\nstatic bool grow_dynamic_buffer(conn *c, size_t needed) {\n    size_t nsize = c->dynamic_buffer.size;\n    size_t available = nsize - c->dynamic_buffer.offset;\n    bool rv = true;\n\n    /* Special case: No buffer -- need to allocate fresh */\n    if (c->dynamic_buffer.buffer == NULL) {\n        nsize = 1024;\n        available = c->dynamic_buffer.size = c->dynamic_buffer.offset = 0;\n    }\n\n    while (needed > available) {\n        assert(nsize > 0);\n        nsize = nsize << 1;\n        available = nsize - c->dynamic_buffer.offset;\n    }\n\n    if (nsize != c->dynamic_buffer.size) {\n        char *ptr = realloc(c->dynamic_buffer.buffer, nsize);\n        if (ptr) {\n            c->dynamic_buffer.buffer = ptr;\n            c->dynamic_buffer.size = nsize;\n        } else {\n            rv = false;\n        }\n    }\n\n    return rv;\n}\n\nstatic void append_stats(const char *key, const uint16_t klen,\n                         const char *val, const uint32_t vlen,\n                         const void *cookie)\n{\n    /* value without a key is invalid */\n    if (klen == 0 && vlen > 0) {\n        return ;\n    }\n\n    conn *c = (conn*)cookie;\n\n    if (c->protocol == binary_prot) {\n        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);\n        if (!grow_dynamic_buffer(c, needed)) {\n            return ;\n        }\n        append_bin_stats(key, klen, val, vlen, c);\n    } else {\n        size_t needed = vlen + klen + 10; // 10 == \"STAT = \\r\\n\"\n        if (!grow_dynamic_buffer(c, needed)) {\n            return ;\n        }\n        append_ascii_stats(key, klen, val, vlen, c);\n    }\n\n    assert(c->dynamic_buffer.offset <= c->dynamic_buffer.size);\n}\n\nstatic void process_bin_stat(conn *c) {\n    char *subcommand = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"STATS\", subcommand, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        if (nkey == 0) {\n            /* request all statistics */\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c, NULL, 0, append_stats);\n            if (ret == ENGINE_SUCCESS) {\n                server_stats(&append_stats, c, false);\n            }\n        } else if (strncmp(subcommand, \"reset\", 5) == 0) {\n            stats_reset(c);\n            settings.engine.v1->reset_stats(settings.engine.v0, c);\n        } else if (strncmp(subcommand, \"settings\", 8) == 0) {\n            process_stat_settings(&append_stats, c);\n        } else if (strncmp(subcommand, \"detail\", 6) == 0) {\n            char *subcmd_pos = subcommand + 6;\n            if (settings.allow_detailed) {\n                if (strncmp(subcmd_pos, \" dump\", 5) == 0) {\n                    int len;\n                    char *dump_buf = stats_prefix_dump(&len);\n                    if (dump_buf == NULL || len <= 0) {\n                        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n                        return ;\n                    } else {\n                        append_stats(\"detailed\", strlen(\"detailed\"), dump_buf, len, c);\n                        free(dump_buf);\n                    }\n                } else if (strncmp(subcmd_pos, \" on\", 3) == 0) {\n                    settings.detail_enabled = 1;\n                } else if (strncmp(subcmd_pos, \" off\", 4) == 0) {\n                    settings.detail_enabled = 0;\n                } else {\n                    write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n                    return;\n                }\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n                return;\n            }\n        } else if (strncmp(subcommand, \"aggregate\", 9) == 0) {\n            server_stats(&append_stats, c, true);\n        } else if (strncmp(subcommand, \"topkeys\", 7) == 0) {\n            topkeys_t *tk = get_independent_stats(c)->topkeys;\n            if (tk != NULL) {\n                topkeys_stats(tk, c, current_time, append_stats);\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n                return;\n            }\n        } else {\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c,\n                                                subcommand, nkey,\n                                                append_stats);\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        append_stats(NULL, 0, NULL, 0, c);\n        write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n        c->dynamic_buffer.buffer = NULL;\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n}\n\nstatic void bin_read_chunk(conn *c, enum bin_substates next_substate, uint32_t chunk) {\n    assert(c);\n    c->substate = next_substate;\n    c->rlbytes = chunk;\n\n    /* Ok... do we have room for everything in our buffer? */\n    ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;\n    if (c->rlbytes > c->rsize - offset) {\n        size_t nsize = c->rsize;\n        size_t size = c->rlbytes + sizeof(protocol_binary_request_header);\n\n        while (size > nsize) {\n            nsize *= 2;\n        }\n\n        if (nsize != c->rsize) {\n            char *newm;\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                        \"%d: Need to grow buffer from %lu to %lu\\n\",\n                        c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);\n            }\n            newm = realloc(c->rbuf, nsize);\n            if (newm == NULL) {\n                if (settings.verbose) {\n                    settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                            \"%d: Failed to grow buffer.. closing connection\\n\",\n                            c->sfd);\n                }\n                conn_set_state(c, conn_closing);\n                return;\n            }\n\n            c->rbuf= newm;\n            /* rcurr should point to the same offset in the packet */\n            c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);\n            c->rsize = nsize;\n        }\n        if (c->rbuf != c->rcurr) {\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n            c->rcurr = c->rbuf;\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                \"%d: Repack input buffer\\n\",\n                                                c->sfd);\n            }\n        }\n    }\n\n    /* preserve the header in the buffer.. */\n    c->ritem = c->rcurr + sizeof(protocol_binary_request_header);\n    conn_set_state(c, conn_nread);\n}\n\nstatic void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {\n    bin_read_chunk(c, next_substate, c->keylen + extra);\n}\n\n\n/* Just write an error message and disconnect the client */\nstatic void handle_binary_protocol_error(conn *c) {\n    write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                \"%d: Protocol error (opcode %02x), close connection\\n\",\n                c->sfd, c->binary_header.request.opcode);\n    }\n    c->write_and_go = conn_closing;\n}\n\nstatic void init_sasl_conn(conn *c) {\n    assert(c);\n    if (!c->sasl_conn) {\n        int result=sasl_server_new(\"memcached\",\n                                   NULL, NULL, NULL, NULL,\n                                   NULL, 0, &c->sasl_conn);\n        if (result != SASL_OK) {\n            if (settings.verbose) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                         \"%d: Failed to initialize SASL conn.\\n\",\n                         c->sfd);\n            }\n            c->sasl_conn = NULL;\n        }\n    }\n}\n\nstatic void get_auth_data(const void *cookie, auth_data_t *data) {\n    conn *c = (conn*)cookie;\n    if (c->sasl_conn) {\n        sasl_getprop(c->sasl_conn, SASL_USERNAME, (void*)&data->username);\n#ifdef ENABLE_ISASL\n        sasl_getprop(c->sasl_conn, ISASL_CONFIG, (void*)&data->config);\n#endif\n    }\n    (void)(data);\n}\n\n#ifdef SASL_ENABLED\nstatic void bin_list_sasl_mechs(conn *c) {\n    init_sasl_conn(c);\n    const char *result_string = NULL;\n    unsigned int string_length = 0;\n    int result=sasl_listmech(c->sasl_conn, NULL,\n                             \"\",   /* What to prepend the string with */\n                             \" \",  /* What to separate mechanisms with */\n                             \"\",   /* What to append to the string */\n                             &result_string, &string_length,\n                             NULL);\n    if (result != SASL_OK) {\n        /* Perhaps there's a better error for this... */\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                     \"%d: Failed to list SASL mechanisms.\\n\",\n                     c->sfd);\n        }\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        return;\n    }\n    write_bin_response(c, (char*)result_string, 0, 0, string_length);\n}\n#endif\n\nstruct sasl_tmp {\n    int ksize;\n    int vsize;\n    char data[]; /* data + ksize == value */\n};\n\nstatic void process_bin_sasl_auth(conn *c) {\n    assert(c->binary_header.request.extlen == 0);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    if (nkey > MAX_SASL_MECH_LEN) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    char *key = binary_get_key(c);\n    assert(key);\n\n    size_t buffer_size = sizeof(struct sasl_tmp) + nkey + vlen + 2;\n    struct sasl_tmp *data = calloc(sizeof(struct sasl_tmp) + buffer_size, 1);\n    if (!data) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    data->ksize = nkey;\n    data->vsize = vlen;\n    memcpy(data->data, key, nkey);\n\n    c->item = data;\n    c->ritem = data->data + nkey;\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_reading_sasl_auth_data;\n}\n\nstatic void process_bin_complete_sasl_auth(conn *c) {\n    const char *out = NULL;\n    unsigned int outlen = 0;\n\n    assert(c->item);\n    init_sasl_conn(c);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    struct sasl_tmp *stmp = c->item;\n    char mech[nkey+1];\n    memcpy(mech, stmp->data, nkey);\n    mech[nkey] = 0x00;\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                \"%d: mech: ``%s'' with %d bytes of data\\n\", c->sfd, mech, vlen);\n    }\n\n    const char *challenge = vlen == 0 ? NULL : (stmp->data + nkey);\n\n    int result=-1;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        result = sasl_server_start(c->sasl_conn, mech,\n                                   challenge, vlen,\n                                   &out, &outlen);\n        break;\n    case PROTOCOL_BINARY_CMD_SASL_STEP:\n        result = sasl_server_step(c->sasl_conn,\n                                  challenge, vlen,\n                                  &out, &outlen);\n        break;\n    default:\n        assert(false); /* CMD should be one of the above */\n        /* This code is pretty much impossible, but makes the compiler\n           happier */\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                    \"%d: Unhandled command %d with challenge %s\\n\",\n                    c->sfd, c->cmd, challenge);\n        }\n        break;\n    }\n\n    free(c->item);\n    c->item = NULL;\n    c->ritem = NULL;\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                        \"%d: sasl result code:  %d\\n\",\n                                        c->sfd, result);\n    }\n\n    switch(result) {\n    case SASL_OK:\n        write_bin_response(c, \"Authenticated\", 0, 0, strlen(\"Authenticated\"));\n        auth_data_t data;\n        get_auth_data(c, &data);\n        perform_callbacks(ON_AUTH, (const void*)&data, c);\n        STATS_NOKEY(c, auth_cmds);\n        break;\n    case SASL_CONTINUE:\n        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);\n        if(outlen > 0) {\n            add_iov(c, out, outlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n        break;\n    default:\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"%d: Unknown sasl response:  %d\\n\",\n                                            c->sfd, result);\n        }\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        STATS_NOKEY2(c, auth_cmds, auth_errors);\n    }\n}\n\nstatic bool authenticated(conn *c) {\n    bool rv = false;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */\n        rv = true;\n        break;\n    default:\n        if (c->sasl_conn) {\n            const void *uname = NULL;\n            sasl_getprop(c->sasl_conn, SASL_USERNAME, &uname);\n            rv = uname != NULL;\n        }\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                \"%d: authenticated() in cmd 0x%02x is %s\\n\",\n                c->sfd, c->cmd, rv ? \"true\" : \"false\");\n    }\n\n    return rv;\n}\n\nstatic bool binary_response_handler(const void *key, uint16_t keylen,\n                                    const void *ext, uint8_t extlen,\n                                    const void *body, uint32_t bodylen,\n                                    uint8_t datatype, uint16_t status,\n                                    uint64_t cas, const void *cookie)\n{\n    conn *c = (conn*)cookie;\n    /* Look at append_bin_stats */\n    size_t needed = keylen + extlen + bodylen + sizeof(protocol_binary_response_header);\n    if (!grow_dynamic_buffer(c, needed)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                    \"<%d ERROR: Failed to allocate memory for response\\n\",\n                    c->sfd);\n        }\n        return false;\n    }\n\n    char *buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = c->binary_header.request.opcode,\n        .response.keylen = (uint16_t)htons(keylen),\n        .response.extlen = extlen,\n        .response.datatype = datatype,\n        .response.status = (uint16_t)htons(status),\n        .response.bodylen = htonl(bodylen + keylen + extlen),\n        .response.opaque = c->opaque,\n        .response.cas = htonll(cas),\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (extlen > 0) {\n        memcpy(buf, ext, extlen);\n        buf += extlen;\n    }\n\n    if (keylen > 0) {\n        memcpy(buf, key, keylen);\n        buf += keylen;\n    }\n\n    if (bodylen > 0) {\n        memcpy(buf, body, bodylen);\n    }\n\n    c->dynamic_buffer.offset += needed;\n\n    return true;\n}\n\n/**\n * Tap stats (these are only used by the tap thread, so they don't need\n * to be in the threadlocal struct right now...\n */\nstruct tap_cmd_stats {\n    uint64_t connect;\n    uint64_t mutation;\n    uint64_t checkpoint_start;\n    uint64_t checkpoint_end;\n    uint64_t delete;\n    uint64_t flush;\n    uint64_t opaque;\n    uint64_t vbucket_set;\n};\n\nstruct tap_stats {\n    pthread_mutex_t mutex;\n    struct tap_cmd_stats sent;\n    struct tap_cmd_stats received;\n} tap_stats = { .mutex = PTHREAD_MUTEX_INITIALIZER };\n\nstatic void ship_tap_log(conn *c) {\n    assert(c->thread->type == TAP);\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"%d: Failed to create output headers. Shutting down tap connection\\n\", c->sfd);\n        }\n        conn_set_state(c, conn_closing);\n        return ;\n    }\n    /* @todo add check for buffer overflow of c->wbuf) */\n    c->wcurr = c->wbuf;\n\n    bool more_data = true;\n    bool send_data = false;\n    bool disconnect = false;\n\n    item *it;\n    uint32_t bodylen;\n    int ii = 0;\n    c->icurr = c->ilist;\n    do {\n        /* @todo fixme! */\n        if (ii++ == 10) {\n            break;\n        }\n\n        void *engine;\n        uint16_t nengine;\n        uint8_t ttl;\n        uint16_t tap_flags;\n        uint32_t seqno;\n        uint16_t vbucket;\n\n        tap_event_t event = c->tap_iterator(settings.engine.v0, c, &it,\n                                            &engine, &nengine, &ttl,\n                                            &tap_flags, &seqno, &vbucket);\n        union {\n            protocol_binary_request_tap_mutation mutation;\n            protocol_binary_request_tap_delete delete;\n            protocol_binary_request_tap_flush flush;\n            protocol_binary_request_tap_opaque opaque;\n            protocol_binary_request_noop noop;\n        } msg = {\n            .mutation.message.header.request.magic = (uint8_t)PROTOCOL_BINARY_REQ,\n        };\n\n        msg.opaque.message.header.request.opaque = htonl(seqno);\n        msg.opaque.message.body.tap.enginespecific_length = htons(nengine);\n        msg.opaque.message.body.tap.ttl = ttl;\n        msg.opaque.message.body.tap.flags = htons(tap_flags);\n        msg.opaque.message.header.request.extlen = 8;\n        msg.opaque.message.header.request.vbucket = htons(vbucket);\n        item_info info = { .nvalue = 1 };\n\n        switch (event) {\n        case TAP_NOOP :\n            send_data = true;\n            msg.noop.message.header.request.opcode = PROTOCOL_BINARY_CMD_NOOP;\n            msg.noop.message.header.request.extlen = 0;\n            msg.noop.message.header.request.bodylen = htonl(0);\n            memcpy(c->wcurr, msg.noop.bytes, sizeof(msg.noop.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.noop.bytes));\n            c->wcurr += sizeof(msg.noop.bytes);\n            c->wbytes += sizeof(msg.noop.bytes);\n            break;\n        case TAP_PAUSE :\n            more_data = false;\n            break;\n        case TAP_CHECKPOINT_START:\n        case TAP_CHECKPOINT_END:\n        case TAP_MUTATION:\n            if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: Failed to get item info\\n\", c->sfd);\n                break;\n            }\n            send_data = true;\n            c->ilist[c->ileft++] = it;\n\n            if (event == TAP_CHECKPOINT_START) {\n                msg.mutation.message.header.request.opcode =\n                    PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.checkpoint_start++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_CHECKPOINT_END) {\n                msg.mutation.message.header.request.opcode =\n                    PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.checkpoint_end++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_MUTATION) {\n                msg.mutation.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_MUTATION;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.mutation++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            }\n\n            msg.mutation.message.header.request.cas = htonll(info.cas);\n            msg.mutation.message.header.request.keylen = htons(info.nkey);\n            msg.mutation.message.header.request.extlen = 16;\n\n            bodylen = 16 + info.nkey + nengine;\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                bodylen += info.nbytes;\n            }\n            msg.mutation.message.header.request.bodylen = htonl(bodylen);\n            msg.mutation.message.body.item.flags = htonl(info.flags);\n            msg.mutation.message.body.item.expiration = htonl(info.exptime);\n            msg.mutation.message.body.tap.enginespecific_length = htons(nengine);\n            msg.mutation.message.body.tap.ttl = ttl;\n            msg.mutation.message.body.tap.flags = htons(tap_flags);\n            memcpy(c->wcurr, msg.mutation.bytes, sizeof(msg.mutation.bytes));\n\n            add_iov(c, c->wcurr, sizeof(msg.mutation.bytes));\n            c->wcurr += sizeof(msg.mutation.bytes);\n            c->wbytes += sizeof(msg.mutation.bytes);\n\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n\n            add_iov(c, info.key, info.nkey);\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n            }\n\n            break;\n        case TAP_DELETION:\n            /* This is a delete */\n            if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: Failed to get item info\\n\", c->sfd);\n                break;\n            }\n            send_data = true;\n            c->ilist[c->ileft++] = it;\n            msg.delete.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_DELETE;\n            msg.delete.message.header.request.cas = htonll(info.cas);\n            msg.delete.message.header.request.keylen = htons(info.nkey);\n\n            bodylen = 8 + info.nkey + nengine;\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                bodylen += info.nbytes;\n            }\n            msg.delete.message.header.request.bodylen = htonl(bodylen);\n\n            memcpy(c->wcurr, msg.delete.bytes, sizeof(msg.delete.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.delete.bytes));\n            c->wcurr += sizeof(msg.delete.bytes);\n            c->wbytes += sizeof(msg.delete.bytes);\n\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n\n            add_iov(c, info.key, info.nkey);\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n            }\n\n            pthread_mutex_lock(&tap_stats.mutex);\n            tap_stats.sent.delete++;\n            pthread_mutex_unlock(&tap_stats.mutex);\n            break;\n\n        case TAP_DISCONNECT:\n            disconnect = true;\n            more_data = false;\n            break;\n        case TAP_VBUCKET_SET:\n        case TAP_FLUSH:\n        case TAP_OPAQUE:\n            send_data = true;\n\n            if (event == TAP_OPAQUE) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_OPAQUE;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.opaque++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n\n            } else if (event == TAP_FLUSH) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_FLUSH;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.flush++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_VBUCKET_SET) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET;\n                msg.flush.message.body.tap.flags = htons(tap_flags);\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.vbucket_set++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            }\n\n            msg.flush.message.header.request.bodylen = htonl(8 + nengine);\n            memcpy(c->wcurr, msg.flush.bytes, sizeof(msg.flush.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.flush.bytes));\n            c->wcurr += sizeof(msg.flush.bytes);\n            c->wbytes += sizeof(msg.flush.bytes);\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n            break;\n        default:\n            abort();\n        }\n    } while (more_data);\n\n    c->ewouldblock = false;\n    if (send_data) {\n        conn_set_state(c, conn_mwrite);\n        if (disconnect) {\n            c->write_and_go = conn_closing;\n        } else {\n            c->write_and_go = conn_ship_log;\n        }\n    } else {\n        if (disconnect) {\n            conn_set_state(c, conn_closing);\n        } else {\n            /* No more items to ship to the slave at this time.. suspend.. */\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                \"%d: No more items in tap log.. waiting\\n\",\n                                                c->sfd);\n            }\n            c->ewouldblock = true;\n        }\n    }\n}\n\n\nstatic ENGINE_ERROR_CODE default_unknown_command(EXTENSION_BINARY_PROTOCOL_DESCRIPTOR *descriptor,\n                                                 ENGINE_HANDLE* handle,\n                                                 const void* cookie,\n                                                 protocol_binary_request_header *request,\n                                                 ADD_RESPONSE response)\n{\n    (void)(descriptor);\n    return settings.engine.v1->unknown_command(handle, cookie, request, response);\n}\n\nstruct request_lookup {\n    EXTENSION_BINARY_PROTOCOL_DESCRIPTOR *descriptor;\n    BINARY_COMMAND_CALLBACK callback;\n};\n\nstatic struct request_lookup request_handlers[0x100];\n\nstatic void initialize_binary_lookup_map(void) {\n    for (int ii = 0; ii < 0x100; ++ii) {\n        request_handlers[ii].descriptor = NULL;\n        request_handlers[ii].callback = default_unknown_command;\n    }\n}\n\nstatic void setup_binary_lookup_cmd(EXTENSION_BINARY_PROTOCOL_DESCRIPTOR *descriptor,\n                                    uint8_t cmd,\n                                    BINARY_COMMAND_CALLBACK new_handler) {\n    request_handlers[cmd].descriptor = descriptor;\n    request_handlers[cmd].callback = new_handler;\n}\n\nstatic void process_bin_unknown_packet(conn *c) {\n    void *packet = c->rcurr - (c->binary_header.request.bodylen +\n                               sizeof(c->binary_header));\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        struct request_lookup *rq = request_handlers + c->binary_header.request.opcode;\n        ret = rq->callback(rq->descriptor, settings.engine.v0, c, packet,\n                           binary_response_handler);\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        if (c->dynamic_buffer.buffer != NULL) {\n            write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n            c->dynamic_buffer.buffer = NULL;\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        conn_set_state(c, conn_closing);\n        break;\n    default:\n        // Release the dynamic buffer.. it may be partial..\n        free(c->dynamic_buffer.buffer);\n        c->dynamic_buffer.buffer = NULL;\n        write_bin_packet(c, engine_error_2_protocol_error(ret), 0);\n    }\n}\n\nstatic void process_bin_tap_connect(conn *c) {\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_tap_connect *req = (void*)packet;\n    const char *key = packet + sizeof(req->bytes);\n    const char *data = key + c->binary_header.request.keylen;\n    uint32_t flags = 0;\n    size_t ndata = c->binary_header.request.bodylen -\n        c->binary_header.request.extlen -\n        c->binary_header.request.keylen;\n\n    if (c->binary_header.request.extlen == 4) {\n        flags = ntohl(req->message.body.flags);\n\n        if (flags & TAP_CONNECT_FLAG_BACKFILL) {\n            /* the userdata has to be at least 8 bytes! */\n            if (ndata < 8) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: ERROR: Invalid tap connect message\\n\",\n                                                c->sfd);\n                conn_set_state(c, conn_closing);\n                return ;\n            }\n        }\n    } else {\n        data -= 4;\n        key -= 4;\n    }\n\n    if (settings.verbose && c->binary_header.request.keylen > 0) {\n        char buffer[1024];\n        unsigned int len = c->binary_header.request.keylen;\n        if (len >= sizeof(buffer)) {\n            len = sizeof(buffer) - 1;\n        }\n        memcpy(buffer, key, len);\n        buffer[len] = '\\0';\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"%d: Trying to connect with named tap connection: <%s>\\n\",\n                                        c->sfd, buffer);\n    }\n\n    TAP_ITERATOR iterator = settings.engine.v1->get_tap_iterator(\n        settings.engine.v0, c, key, c->binary_header.request.keylen,\n        flags, data, ndata);\n\n    if (iterator == NULL) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: FATAL: The engine does not support tap\\n\",\n                                        c->sfd);\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        c->write_and_go = conn_closing;\n    } else {\n        c->tap_iterator = iterator;\n        c->which = EV_WRITE;\n        conn_set_state(c, conn_ship_log);\n    }\n}\n\nstatic void process_bin_tap_packet(tap_event_t event, conn *c) {\n    assert(c != NULL);\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_tap_no_extras *tap = (void*)packet;\n    uint16_t nengine = ntohs(tap->message.body.tap.enginespecific_length);\n    uint16_t tap_flags = ntohs(tap->message.body.tap.flags);\n    uint32_t seqno = ntohl(tap->message.header.request.opaque);\n    uint8_t ttl = tap->message.body.tap.ttl;\n    char *engine_specific = packet + sizeof(tap->bytes);\n    char *key = engine_specific + nengine;\n    uint16_t nkey = c->binary_header.request.keylen;\n    char *data = key + nkey;\n    uint32_t flags = 0;\n    uint32_t exptime = 0;\n    uint32_t ndata = c->binary_header.request.bodylen - nengine - nkey - 8;\n    ENGINE_ERROR_CODE ret = c->aiostat;\n\n    if (ttl == 0) {\n        ret = ENGINE_EINVAL;\n    } else {\n        if (event == TAP_MUTATION || event == TAP_CHECKPOINT_START ||\n            event == TAP_CHECKPOINT_END) {\n            protocol_binary_request_tap_mutation *mutation = (void*)tap;\n            flags = ntohl(mutation->message.body.item.flags);\n            exptime = ntohl(mutation->message.body.item.expiration);\n            key += 8;\n            data += 8;\n            ndata -= 8;\n        }\n\n        if (ret == ENGINE_SUCCESS) {\n            ret = settings.engine.v1->tap_notify(settings.engine.v0, c,\n                                                 engine_specific, nengine,\n                                                 ttl - 1, tap_flags,\n                                                 event, seqno,\n                                                 key, nkey,\n                                                 flags, exptime,\n                                                 ntohll(tap->message.header.request.cas),\n                                                 data, ndata,\n                                                 c->binary_header.request.vbucket);\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_DISCONNECT:\n        conn_set_state(c, conn_closing);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        if ((tap_flags & TAP_FLAG_ACK) || (ret != ENGINE_SUCCESS)) {\n            write_bin_packet(c, engine_error_2_protocol_error(ret), 0);\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n    }\n}\n\nstatic void process_bin_tap_ack(conn *c) {\n    assert(c != NULL);\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_response_no_extras *rsp = (void*)packet;\n    uint32_t seqno = ntohl(rsp->message.header.response.opaque);\n    uint16_t status = ntohs(rsp->message.header.response.status);\n    char *key = packet + sizeof(rsp->bytes);\n\n    ENGINE_ERROR_CODE ret = ENGINE_DISCONNECT;\n    if (settings.engine.v1->tap_notify != NULL) {\n        ret = settings.engine.v1->tap_notify(settings.engine.v0, c, NULL, 0, 0, status,\n                                             TAP_ACK, seqno, key,\n                                             c->binary_header.request.keylen, 0, 0,\n                                             0, NULL, 0, 0);\n    }\n\n    if (ret == ENGINE_DISCONNECT) {\n        conn_set_state(c, conn_closing);\n    } else {\n        conn_set_state(c, conn_ship_log);\n    }\n}\n\n/**\n * We received a noop response.. just ignore it\n */\nstatic void process_bin_noop_response(conn *c) {\n    assert(c != NULL);\n    conn_set_state(c, conn_new_cmd);\n}\n\nstatic void process_bin_verbosity(conn *c) {\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_verbosity *req = (void*)packet;\n    uint32_t level = (uint32_t)ntohl(req->message.body.level);\n    if (level > MAX_VERBOSITY_LEVEL) {\n        level = MAX_VERBOSITY_LEVEL;\n    }\n    settings.verbose = (int)level;\n    perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n    write_bin_response(c, NULL, 0, 0, 0);\n}\n\nstatic void process_bin_packet(conn *c) {\n    /* @todo this should be an array of funciton pointers and call through */\n    switch (c->binary_header.request.opcode) {\n    case PROTOCOL_BINARY_CMD_TAP_CONNECT:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.connect++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        conn_set_state(c, conn_add_tap_client);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_MUTATION:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.mutation++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_MUTATION, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.checkpoint_start++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_CHECKPOINT_START, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.checkpoint_end++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_CHECKPOINT_END, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_DELETE:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.delete++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_DELETION, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_FLUSH:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.flush++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_FLUSH, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_OPAQUE:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.opaque++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_OPAQUE, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.vbucket_set++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_VBUCKET_SET, c);\n        break;\n    case PROTOCOL_BINARY_CMD_VERBOSITY:\n        process_bin_verbosity(c);\n        break;\n    default:\n        process_bin_unknown_packet(c);\n    }\n}\n\ntypedef void (*RESPONSE_HANDLER)(conn*);\n/**\n * A map between the response packets op-code and the function to handle\n * the response message.\n */\nstatic RESPONSE_HANDLER response_handlers[256] = {\n    [PROTOCOL_BINARY_CMD_NOOP] = process_bin_noop_response,\n    [PROTOCOL_BINARY_CMD_TAP_MUTATION] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_DELETE] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_FLUSH] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_OPAQUE] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END] = process_bin_tap_ack\n};\n\nstatic void dispatch_bin_command(conn *c) {\n    int protocol_error = 0;\n\n    int extlen = c->binary_header.request.extlen;\n    uint16_t keylen = c->binary_header.request.keylen;\n    uint32_t bodylen = c->binary_header.request.bodylen;\n\n    if (settings.require_sasl && !authenticated(c)) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        c->write_and_go = conn_closing;\n        return;\n    }\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n    c->noreply = true;\n\n    /* binprot supports 16bit keys, but internals are still 8bit */\n    if (keylen > KEY_MAX_LENGTH) {\n        handle_binary_protocol_error(c);\n        return;\n    }\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_SET;\n        break;\n    case PROTOCOL_BINARY_CMD_ADDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_ADD;\n        break;\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;\n        break;\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DELETE;\n        break;\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_QUITQ:\n        c->cmd = PROTOCOL_BINARY_CMD_QUIT;\n        break;\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;\n        break;\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_APPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_GETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GET;\n        break;\n    case PROTOCOL_BINARY_CMD_GETKQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GETK;\n        break;\n    default:\n        c->noreply = false;\n    }\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_VERSION:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_FLUSH:\n            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {\n                bin_read_key(c, bin_read_flush_exptime, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_NOOP:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {\n                bin_read_key(c, bin_reading_set_header, 8);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETK:\n            if (extlen == 0 && bodylen == keylen && keylen > 0) {\n                bin_read_key(c, bin_reading_get_key, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_DELETE:\n            if (keylen > 0 && extlen == 0 && bodylen == keylen) {\n                bin_read_key(c, bin_reading_del_header, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_INCREMENT:\n        case PROTOCOL_BINARY_CMD_DECREMENT:\n            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {\n                bin_read_key(c, bin_reading_incr_header, 20);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_APPEND:\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            if (keylen > 0 && extlen == 0) {\n                bin_read_key(c, bin_reading_set_header, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_STAT:\n            if (extlen == 0) {\n                bin_read_key(c, bin_reading_stat, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_QUIT:\n            if (keylen == 0 && extlen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n                c->write_and_go = conn_closing;\n                if (c->noreply) {\n                    conn_set_state(c, conn_closing);\n                }\n            } else {\n                protocol_error = 1;\n            }\n            break;\n       case PROTOCOL_BINARY_CMD_TAP_CONNECT:\n            if (settings.engine.v1->get_tap_iterator == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet,\n                               c->binary_header.request.bodylen);\n            }\n            break;\n       case PROTOCOL_BINARY_CMD_TAP_MUTATION:\n       case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START:\n       case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END:\n       case PROTOCOL_BINARY_CMD_TAP_DELETE:\n       case PROTOCOL_BINARY_CMD_TAP_FLUSH:\n       case PROTOCOL_BINARY_CMD_TAP_OPAQUE:\n       case PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET:\n            if (settings.engine.v1->tap_notify == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet, c->binary_header.request.bodylen);\n            }\n            break;\n#ifdef SASL_ENABLED\n        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                bin_list_sasl_mechs(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        case PROTOCOL_BINARY_CMD_SASL_STEP:\n            if (extlen == 0 && keylen != 0) {\n                bin_read_key(c, bin_reading_sasl_auth, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n#endif\n        case PROTOCOL_BINARY_CMD_VERBOSITY:\n            if (extlen == 4 && keylen == 0 && bodylen == 4) {\n                bin_read_chunk(c, bin_reading_packet,\n                               c->binary_header.request.bodylen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        default:\n            if (settings.engine.v1->unknown_command == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND,\n                                bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet, c->binary_header.request.bodylen);\n            }\n    }\n\n    if (protocol_error)\n        handle_binary_protocol_error(c);\n}\n\nstatic void process_bin_update(conn *c) {\n    char *key;\n    uint16_t nkey;\n    uint32_t vlen;\n    item *it;\n    protocol_binary_request_set* req = binary_get_request(c);\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n\n    /* fix byteorder in the request */\n    req->message.body.flags = req->message.body.flags;\n    rel_time_t expiration = ntohl(req->message.body.expiration);\n\n    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        const char *prefix;\n        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {\n            prefix = \"ADD\";\n        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            prefix = \"SET\";\n        } else {\n            prefix = \"REPLACE\";\n        }\n\n        size_t nw;\n        nw = key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                     prefix, key, nkey);\n\n        if (nw != -1) {\n            if (snprintf(buffer + nw, sizeof(buffer) - nw,\n                         \" Value len is %d\\n\", vlen)) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\",\n                                                buffer);\n            }\n        }\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    item_info info = { .nvalue = 1 };\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen,\n                                           req->message.body.flags,\n                                           expiration);\n        if (ret == ENGINE_SUCCESS && !settings.engine.v1->get_item_info(settings.engine.v0,\n                                                                        c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            return;\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, c->binary_header.request.cas);\n\n        switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_ADD:\n            c->store_op = OPERATION_ADD;\n            break;\n        case PROTOCOL_BINARY_CMD_SET:\n            c->store_op = OPERATION_SET;\n            break;\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            c->store_op = OPERATION_REPLACE;\n            break;\n        default:\n            assert(0);\n        }\n\n        if (c->binary_header.request.cas != 0) {\n            c->store_op = OPERATION_CAS;\n        }\n\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        conn_set_state(c, conn_nread);\n        c->substate = bin_read_set_value;\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n\n        /*\n         * Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET (but only if cas matches).\n         * Anywhere else too?\n         */\n        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            /* @todo fix this for the ASYNC interface! */\n            settings.engine.v1->remove(settings.engine.v0, c, key, nkey,\n                                       ntohll(req->message.header.request.cas),\n                                       c->binary_header.request.vbucket);\n        }\n\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n    }\n}\n\nstatic void process_bin_append_prepend(conn *c) {\n    char *key;\n    int nkey;\n    int vlen;\n    item *it;\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n    vlen = c->binary_header.request.bodylen - nkey;\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"Value len is %d\\n\", vlen);\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    item_info info = { .nvalue = 1 };\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen, 0, 0);\n        if (ret == ENGINE_SUCCESS && !settings.engine.v1->get_item_info(settings.engine.v0,\n                                                                        c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            return;\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, c->binary_header.request.cas);\n\n        switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_APPEND:\n            c->store_op = OPERATION_APPEND;\n            break;\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            c->store_op = OPERATION_PREPEND;\n            break;\n        default:\n            assert(0);\n        }\n\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        conn_set_state(c, conn_nread);\n        c->substate = bin_read_set_value;\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n    }\n}\n\nstatic void process_bin_flush(conn *c) {\n    time_t exptime = 0;\n    protocol_binary_request_flush* req = binary_get_request(c);\n\n    if (c->binary_header.request.extlen == sizeof(req->message.body)) {\n        exptime = ntohl(req->message.body.expiration);\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"%d: flush %ld\", c->sfd,\n                                        (long)exptime);\n    }\n\n    ENGINE_ERROR_CODE ret;\n    ret = settings.engine.v1->flush(settings.engine.v0, c, exptime);\n\n    if (ret == ENGINE_SUCCESS) {\n        write_bin_response(c, NULL, 0, 0, 0);\n    } else if (ret == ENGINE_ENOTSUP) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n    } else {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n    STATS_NOKEY(c, cmd_flush);\n}\n\nstatic void process_bin_delete(conn *c) {\n    protocol_binary_request_delete* req = binary_get_request(c);\n\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    assert(c != NULL);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"DELETE\", key, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        if (settings.detail_enabled) {\n            stats_prefix_record_delete(key, nkey);\n        }\n        ret = settings.engine.v1->remove(settings.engine.v0, c, key, nkey,\n                                         ntohll(req->message.header.request.cas),\n                                         c->binary_header.request.vbucket);\n    }\n\n    /* For some reason the SLAB_INCR tries to access this... */\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        write_bin_response(c, NULL, 0, 0, 0);\n        SLAB_INCR(c, delete_hits, key, nkey);\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        STATS_INCR(c, delete_misses, key, nkey);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n}\n\nstatic void complete_nread_binary(conn *c) {\n    assert(c != NULL);\n    assert(c->cmd >= 0);\n\n    switch(c->substate) {\n    case bin_reading_set_header:\n        if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||\n                c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {\n            process_bin_append_prepend(c);\n        } else {\n            process_bin_update(c);\n        }\n        break;\n    case bin_read_set_value:\n        complete_update_bin(c);\n        break;\n    case bin_reading_get_key:\n        process_bin_get(c);\n        break;\n    case bin_reading_stat:\n        process_bin_stat(c);\n        break;\n    case bin_reading_del_header:\n        process_bin_delete(c);\n        break;\n    case bin_reading_incr_header:\n        complete_incr_bin(c);\n        break;\n    case bin_read_flush_exptime:\n        process_bin_flush(c);\n        break;\n    case bin_reading_sasl_auth:\n        process_bin_sasl_auth(c);\n        break;\n    case bin_reading_sasl_auth_data:\n        process_bin_complete_sasl_auth(c);\n        break;\n    case bin_reading_packet:\n        if (c->binary_header.request.magic == PROTOCOL_BINARY_RES) {\n            RESPONSE_HANDLER handler;\n            handler = response_handlers[c->binary_header.request.opcode];\n            if (handler) {\n                handler(c);\n            } else {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                       \"%d: ERROR: Unsupported response packet received: %u\\n\",\n                        c->sfd, (unsigned int)c->binary_header.request.opcode);\n                conn_set_state(c, conn_closing);\n            }\n        } else {\n            process_bin_packet(c);\n        }\n        break;\n    default:\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                \"Not handling substate %d\\n\", c->substate);\n        abort();\n    }\n}\n\nstatic void reset_cmd_handler(conn *c) {\n    c->sbytes = 0;\n    c->ascii_cmd = NULL;\n    c->cmd = -1;\n    c->substate = bin_no_state;\n    if(c->item != NULL) {\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = NULL;\n    }\n    conn_shrink(c);\n    if (c->rbytes > 0) {\n        conn_set_state(c, conn_parse_cmd);\n    } else {\n        conn_set_state(c, conn_waiting);\n    }\n}\n\nstatic ENGINE_ERROR_CODE ascii_response_handler(const void *cookie,\n                                                int nbytes,\n                                                const char *dta)\n{\n    conn *c = (conn*)cookie;\n    char *buf;\n    if (!grow_dynamic_buffer(c, nbytes)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                    \"<%d ERROR: Failed to allocate memory for response\\n\",\n                    c->sfd);\n        }\n        return ENGINE_ENOMEM;\n    }\n\n    buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    memcpy(buf, dta, nbytes);\n    c->dynamic_buffer.offset += nbytes;\n\n    return ENGINE_SUCCESS;\n}\n\nstatic void complete_nread_ascii(conn *c) {\n    if (c->ascii_cmd != NULL) {\n        c->ewouldblock = false;\n        switch (c->ascii_cmd->execute(c->ascii_cmd->cookie, c, 0, NULL,\n                                      ascii_response_handler)) {\n        case ENGINE_SUCCESS:\n            if (c->dynamic_buffer.buffer != NULL) {\n                write_and_free(c, c->dynamic_buffer.buffer,\n                               c->dynamic_buffer.offset);\n                c->dynamic_buffer.buffer = NULL;\n            } else {\n                conn_set_state(c, conn_new_cmd);\n            }\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            break;\n        case ENGINE_DISCONNECT:\n        default:\n            conn_set_state(c, conn_closing);\n        }\n    } else {\n        complete_update_ascii(c);\n    }\n}\n\nstatic void complete_nread(conn *c) {\n    assert(c != NULL);\n    assert(c->protocol == ascii_prot\n           || c->protocol == binary_prot);\n\n    if (c->protocol == ascii_prot) {\n        complete_nread_ascii(c);\n    } else if (c->protocol == binary_prot) {\n        complete_nread_binary(c);\n    }\n}\n\n#define COMMAND_TOKEN 0\n#define SUBCOMMAND_TOKEN 1\n#define KEY_TOKEN 1\n\n#define MAX_TOKENS 30\n\n/*\n * Tokenize the command string by replacing whitespace with '\\0' and update\n * the token array tokens with pointer to start of each token and length.\n * Returns total number of tokens.  The last valid token is the terminal\n * token (value points to the first unprocessed character of the string and\n * length zero).\n *\n * Usage example:\n *\n *  while(tokenize_command(command, ncommand, tokens, max_tokens) > 0) {\n *      for(int ix = 0; tokens[ix].length != 0; ix++) {\n *          ...\n *      }\n *      ncommand = tokens[ix].value - command;\n *      command  = tokens[ix].value;\n *   }\n */\nstatic size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {\n    char *s, *e;\n    size_t ntokens = 0;\n\n    assert(command != NULL && tokens != NULL && max_tokens > 1);\n\n    for (s = e = command; ntokens < max_tokens - 1; ++e) {\n        if (*e == ' ') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n                *e = '\\0';\n            }\n            s = e + 1;\n        }\n        else if (*e == '\\0') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n            }\n\n            break; /* string end */\n        }\n    }\n\n    /*\n     * If we scanned the whole string, the terminal value pointer is null,\n     * otherwise it is the first unprocessed character.\n     */\n    tokens[ntokens].value =  *e == '\\0' ? NULL : e;\n    tokens[ntokens].length = 0;\n    ntokens++;\n\n    return ntokens;\n}\n\nstatic void detokenize(token_t *tokens, int ntokens, char **out, int *nbytes) {\n    int i, nb;\n    char *buf, *p;\n\n    nb = ntokens; // account for spaces, which is ntokens-1, plus the null\n    for (i = 0; i < ntokens; ++i) {\n        nb += tokens[i].length;\n    }\n\n    buf = malloc(nb * sizeof(char));\n    if (buf != NULL) {\n        p = buf;\n        for (i = 0; i < ntokens; ++i) {\n            memcpy(p, tokens[i].value, tokens[i].length);\n            p += tokens[i].length;\n            *p = ' ';\n            p++;\n        }\n        buf[nb - 1] = '\\0';\n        *nbytes = nb - 1;\n        *out = buf;\n    }\n}\n\n\n/* set up a connection to write a buffer then free it, used for stats */\nstatic void write_and_free(conn *c, char *buf, int bytes) {\n    if (buf) {\n        c->write_and_free = buf;\n        c->wcurr = buf;\n        c->wbytes = bytes;\n        conn_set_state(c, conn_write);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    }\n}\n\nstatic inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)\n{\n    int noreply_index = ntokens - 2;\n\n    /*\n      NOTE: this function is not the first place where we are going to\n      send the reply.  We could send it instead from process_command()\n      if the request line has wrong number of tokens.  However parsing\n      malformed line for \"noreply\" option is not reliable anyway, so\n      it can't be helped.\n    */\n    if (tokens[noreply_index].value\n        && strcmp(tokens[noreply_index].value, \"noreply\") == 0) {\n        c->noreply = true;\n    }\n    return c->noreply;\n}\n\nvoid append_stat(const char *name, ADD_STAT add_stats, conn *c,\n                 const char *fmt, ...) {\n    char val_str[STAT_VAL_LEN];\n    int vlen;\n    va_list ap;\n\n    assert(name);\n    assert(add_stats);\n    assert(c);\n    assert(fmt);\n\n    va_start(ap, fmt);\n    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);\n    va_end(ap);\n\n    add_stats(name, strlen(name), val_str, vlen, c);\n}\n\ninline static void process_stats_detail(conn *c, const char *command) {\n    assert(c != NULL);\n\n    if (settings.allow_detailed) {\n        if (strcmp(command, \"on\") == 0) {\n            settings.detail_enabled = 1;\n            out_string(c, \"OK\");\n        }\n        else if (strcmp(command, \"off\") == 0) {\n            settings.detail_enabled = 0;\n            out_string(c, \"OK\");\n        }\n        else if (strcmp(command, \"dump\") == 0) {\n            int len;\n            char *stats = stats_prefix_dump(&len);\n            write_and_free(c, stats, len);\n        }\n        else {\n            out_string(c, \"CLIENT_ERROR usage: stats detail on|off|dump\");\n        }\n    }\n    else {\n        out_string(c, \"CLIENT_ERROR detailed stats disabled\");\n    }\n}\n\nstatic void aggregate_callback(void *in, void *out) {\n    struct thread_stats *out_thread_stats = out;\n    struct independent_stats *in_independent_stats = in;\n    threadlocal_stats_aggregate(in_independent_stats->thread_stats,\n                                out_thread_stats);\n}\n\n/* return server specific stats only */\nstatic void server_stats(ADD_STAT add_stats, conn *c, bool aggregate) {\n    pid_t pid = getpid();\n    rel_time_t now = current_time;\n\n    struct thread_stats thread_stats;\n    threadlocal_stats_clear(&thread_stats);\n\n    if (aggregate && settings.engine.v1->aggregate_stats != NULL) {\n        settings.engine.v1->aggregate_stats(settings.engine.v0,\n                                            (const void *)c,\n                                            aggregate_callback,\n                                            &thread_stats);\n    } else {\n        threadlocal_stats_aggregate(get_independent_stats(c)->thread_stats,\n                                    &thread_stats);\n    }\n\n    struct slab_stats slab_stats;\n    slab_stats_aggregate(&thread_stats, &slab_stats);\n\n#ifndef __WIN32__\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n#endif\n\n    STATS_LOCK();\n\n    APPEND_STAT(\"pid\", \"%lu\", (long)pid);\n    APPEND_STAT(\"uptime\", \"%u\", now);\n    APPEND_STAT(\"time\", \"%ld\", now + (long)process_started);\n    APPEND_STAT(\"version\", \"%s\", VERSION);\n    APPEND_STAT(\"libevent\", \"%s\", event_get_version());\n    APPEND_STAT(\"pointer_size\", \"%d\", (int)(8 * sizeof(void *)));\n\n#ifndef __WIN32__\n    append_stat(\"rusage_user\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_utime.tv_sec,\n                (long)usage.ru_utime.tv_usec);\n    append_stat(\"rusage_system\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_stime.tv_sec,\n                (long)usage.ru_stime.tv_usec);\n#endif\n\n    APPEND_STAT(\"daemon_connections\", \"%u\", stats.daemon_conns);\n    APPEND_STAT(\"curr_connections\", \"%u\", stats.curr_conns);\n    APPEND_STAT(\"total_connections\", \"%u\", stats.total_conns);\n    APPEND_STAT(\"connection_structures\", \"%u\", stats.conn_structs);\n    APPEND_STAT(\"cmd_get\", \"%\"PRIu64, thread_stats.cmd_get);\n    APPEND_STAT(\"cmd_set\", \"%\"PRIu64, slab_stats.cmd_set);\n    APPEND_STAT(\"cmd_flush\", \"%\"PRIu64, thread_stats.cmd_flush);\n    APPEND_STAT(\"auth_cmds\", \"%\"PRIu64, thread_stats.auth_cmds);\n    APPEND_STAT(\"auth_errors\", \"%\"PRIu64, thread_stats.auth_errors);\n    APPEND_STAT(\"get_hits\", \"%\"PRIu64, slab_stats.get_hits);\n    APPEND_STAT(\"get_misses\", \"%\"PRIu64, thread_stats.get_misses);\n    APPEND_STAT(\"delete_misses\", \"%\"PRIu64, thread_stats.delete_misses);\n    APPEND_STAT(\"delete_hits\", \"%\"PRIu64, slab_stats.delete_hits);\n    APPEND_STAT(\"incr_misses\", \"%\"PRIu64, thread_stats.incr_misses);\n    APPEND_STAT(\"incr_hits\", \"%\"PRIu64, thread_stats.incr_hits);\n    APPEND_STAT(\"decr_misses\", \"%\"PRIu64, thread_stats.decr_misses);\n    APPEND_STAT(\"decr_hits\", \"%\"PRIu64, thread_stats.decr_hits);\n    APPEND_STAT(\"cas_misses\", \"%\"PRIu64, thread_stats.cas_misses);\n    APPEND_STAT(\"cas_hits\", \"%\"PRIu64, slab_stats.cas_hits);\n    APPEND_STAT(\"cas_badval\", \"%\"PRIu64, slab_stats.cas_badval);\n    APPEND_STAT(\"bytes_read\", \"%\"PRIu64, thread_stats.bytes_read);\n    APPEND_STAT(\"bytes_written\", \"%\"PRIu64, thread_stats.bytes_written);\n    APPEND_STAT(\"limit_maxbytes\", \"%\"PRIu64, settings.maxbytes);\n    APPEND_STAT(\"accepting_conns\", \"%u\",  is_listen_disabled() ? 0 : 1);\n    APPEND_STAT(\"listen_disabled_num\", \"%\"PRIu64, get_listen_disabled_num());\n    APPEND_STAT(\"rejected_conns\", \"%\" PRIu64, (unsigned long long)stats.rejected_conns);\n    APPEND_STAT(\"threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"conn_yields\", \"%\" PRIu64, (unsigned long long)thread_stats.conn_yields);\n    STATS_UNLOCK();\n\n    /*\n     * Add tap stats (only if non-zero)\n     */\n    struct tap_stats ts;\n    pthread_mutex_lock(&tap_stats.mutex);\n    ts = tap_stats;\n    pthread_mutex_unlock(&tap_stats.mutex);\n\n    if (ts.sent.connect) {\n        APPEND_STAT(\"tap_connect_sent\", \"%\"PRIu64, ts.sent.connect);\n    }\n    if (ts.sent.mutation) {\n        APPEND_STAT(\"tap_mutation_sent\", \"%\"PRIu64, ts.sent.mutation);\n    }\n    if (ts.sent.checkpoint_start) {\n        APPEND_STAT(\"tap_checkpoint_start_sent\", \"%\"PRIu64, ts.sent.checkpoint_start);\n    }\n    if (ts.sent.checkpoint_end) {\n        APPEND_STAT(\"tap_checkpoint_end_sent\", \"%\"PRIu64, ts.sent.checkpoint_end);\n    }\n    if (ts.sent.delete) {\n        APPEND_STAT(\"tap_delete_sent\", \"%\"PRIu64, ts.sent.delete);\n    }\n    if (ts.sent.flush) {\n        APPEND_STAT(\"tap_flush_sent\", \"%\"PRIu64, ts.sent.flush);\n    }\n    if (ts.sent.opaque) {\n        APPEND_STAT(\"tap_opaque_sent\", \"%\"PRIu64, ts.sent.opaque);\n    }\n    if (ts.sent.vbucket_set) {\n        APPEND_STAT(\"tap_vbucket_set_sent\", \"%\"PRIu64,\n                    ts.sent.vbucket_set);\n    }\n    if (ts.received.connect) {\n        APPEND_STAT(\"tap_connect_received\", \"%\"PRIu64, ts.received.connect);\n    }\n    if (ts.received.mutation) {\n        APPEND_STAT(\"tap_mutation_received\", \"%\"PRIu64, ts.received.mutation);\n    }\n    if (ts.received.checkpoint_start) {\n        APPEND_STAT(\"tap_checkpoint_start_received\", \"%\"PRIu64, ts.received.checkpoint_start);\n    }\n    if (ts.received.checkpoint_end) {\n        APPEND_STAT(\"tap_checkpoint_end_received\", \"%\"PRIu64, ts.received.checkpoint_end);\n    }\n    if (ts.received.delete) {\n        APPEND_STAT(\"tap_delete_received\", \"%\"PRIu64, ts.received.delete);\n    }\n    if (ts.received.flush) {\n        APPEND_STAT(\"tap_flush_received\", \"%\"PRIu64, ts.received.flush);\n    }\n    if (ts.received.opaque) {\n        APPEND_STAT(\"tap_opaque_received\", \"%\"PRIu64, ts.received.opaque);\n    }\n    if (ts.received.vbucket_set) {\n        APPEND_STAT(\"tap_vbucket_set_received\", \"%\"PRIu64,\n                    ts.received.vbucket_set);\n    }\n}\n\nstatic void process_stat_settings(ADD_STAT add_stats, void *c) {\n    assert(add_stats);\n    APPEND_STAT(\"maxbytes\", \"%u\", (unsigned int)settings.maxbytes);\n    APPEND_STAT(\"maxconns\", \"%d\", settings.maxconns);\n    APPEND_STAT(\"tcpport\", \"%d\", settings.port);\n    APPEND_STAT(\"udpport\", \"%d\", settings.udpport);\n    APPEND_STAT(\"inter\", \"%s\", settings.inter ? settings.inter : \"NULL\");\n    APPEND_STAT(\"verbosity\", \"%d\", settings.verbose);\n    APPEND_STAT(\"oldest\", \"%lu\", (unsigned long)settings.oldest_live);\n    APPEND_STAT(\"evictions\", \"%s\", settings.evict_to_free ? \"on\" : \"off\");\n    APPEND_STAT(\"domain_socket\", \"%s\",\n                settings.socketpath ? settings.socketpath : \"NULL\");\n    APPEND_STAT(\"umask\", \"%o\", settings.access);\n    APPEND_STAT(\"growth_factor\", \"%.2f\", settings.factor);\n    APPEND_STAT(\"chunk_size\", \"%d\", settings.chunk_size);\n    APPEND_STAT(\"num_threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"num_threads_per_udp\", \"%d\", settings.num_threads_per_udp);\n    APPEND_STAT(\"stat_key_prefix\", \"%c\", settings.prefix_delimiter);\n    APPEND_STAT(\"detail_enabled\", \"%s\",\n                settings.detail_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"allow_detailed\", \"%s\",\n                settings.allow_detailed ? \"yes\" : \"no\");\n    APPEND_STAT(\"reqs_per_event\", \"%d\", settings.reqs_per_event);\n    APPEND_STAT(\"reqs_per_tap_event\", \"%d\", settings.reqs_per_tap_event);\n    APPEND_STAT(\"cas_enabled\", \"%s\", settings.use_cas ? \"yes\" : \"no\");\n    APPEND_STAT(\"tcp_backlog\", \"%d\", settings.backlog);\n    APPEND_STAT(\"binding_protocol\", \"%s\",\n                prot_text(settings.binding_protocol));\n#ifdef SASL_ENABLED\n    APPEND_STAT(\"auth_enabled_sasl\", \"%s\", \"yes\");\n#else\n    APPEND_STAT(\"auth_enabled_sasl\", \"%s\", \"no\");\n#endif\n\n#ifdef ENABLE_ISASL\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"isasl\");\n#elif defined(ENABLE_SASL)\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"cyrus\");\n#else\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"none\");\n#endif\n    APPEND_STAT(\"auth_required_sasl\", \"%s\", settings.require_sasl ? \"yes\" : \"no\");\n    APPEND_STAT(\"item_size_max\", \"%d\", settings.item_size_max);\n    APPEND_STAT(\"topkeys\", \"%d\", settings.topkeys);\n\n    for (EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n         ptr != NULL;\n         ptr = ptr->next) {\n        APPEND_STAT(\"extension\", \"%s\", ptr->get_name());\n    }\n\n    APPEND_STAT(\"logger\", \"%s\", settings.extensions.logger->get_name());\n\n    for (EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *ptr = settings.extensions.ascii;\n         ptr != NULL;\n         ptr = ptr->next) {\n        APPEND_STAT(\"ascii_extension\", \"%s\", ptr->get_name(ptr->cookie));\n    }\n\n    for (EXTENSION_BINARY_PROTOCOL_DESCRIPTOR *ptr = settings.extensions.binary;\n         ptr != NULL;\n         ptr = ptr->next) {\n        APPEND_STAT(\"binary_extension\", \"%s\", ptr->get_name());\n    }\n}\n\nstatic char *process_stat(conn *c, token_t *tokens, const size_t ntokens) {\n    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;\n    c->dynamic_buffer.offset = 0;\n\n    if (ntokens == 2) {\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            server_stats(&append_stats, c, false);\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c,\n                                                NULL, 0, &append_stats);\n            if (ret == ENGINE_EWOULDBLOCK) {\n                c->ewouldblock = true;\n                return c->rcurr + 5;\n            }\n        }\n    } else if (strcmp(subcommand, \"reset\") == 0) {\n        stats_reset(c);\n        out_string(c, \"RESET\");\n        return NULL;\n    } else if (strcmp(subcommand, \"detail\") == 0) {\n        /* NOTE: how to tackle detail with binary? */\n        if (ntokens < 4) {\n            process_stats_detail(c, \"\");  /* outputs the error message */\n        } else {\n            process_stats_detail(c, tokens[2].value);\n        }\n        /* Output already generated */\n        return NULL;\n    } else if (strcmp(subcommand, \"settings\") == 0) {\n        process_stat_settings(&append_stats, c);\n    } else if (strcmp(subcommand, \"cachedump\") == 0) {\n        char *buf = NULL;\n        unsigned int bytes = 0, id, limit = 0;\n\n        if (ntokens < 5) {\n            out_string(c, \"CLIENT_ERROR bad command line\");\n            return NULL;\n        }\n\n        if (!safe_strtoul(tokens[2].value, &id) ||\n            !safe_strtoul(tokens[3].value, &limit)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return NULL;\n        }\n\n        if (id >= POWER_LARGEST) {\n            out_string(c, \"CLIENT_ERROR Illegal slab id\");\n            return NULL;\n        }\n\n#ifdef FUTURE\n        buf = item_cachedump(id, limit, &bytes);\n#endif\n        write_and_free(c, buf, bytes);\n        return NULL;\n    } else if (strcmp(subcommand, \"aggregate\") == 0) {\n        server_stats(&append_stats, c, true);\n    } else if (strcmp(subcommand, \"topkeys\") == 0) {\n        topkeys_t *tk = get_independent_stats(c)->topkeys;\n        if (tk != NULL) {\n            topkeys_stats(tk, c, current_time, append_stats);\n        } else {\n            out_string(c, \"ERROR\");\n            return NULL;\n        }\n    } else {\n        /* getting here means that the subcommand is either engine specific or\n           is invalid. query the engine and see. */\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            char *buf = NULL;\n            int nb = -1;\n            detokenize(&tokens[1], ntokens - 2, &buf, &nb);\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c, buf,\n                                                nb, append_stats);\n            free(buf);\n        }\n\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            append_stats(NULL, 0, NULL, 0, c);\n            write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n            c->dynamic_buffer.buffer = NULL;\n            break;\n        case ENGINE_ENOMEM:\n            out_string(c, \"SERVER_ERROR out of memory writing stats\");\n            break;\n        case ENGINE_DISCONNECT:\n            c->state = conn_closing;\n            break;\n        case ENGINE_ENOTSUP:\n            out_string(c, \"SERVER_ERROR not supported\");\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            return tokens[SUBCOMMAND_TOKEN].value;\n        default:\n            out_string(c, \"ERROR\");\n            break;\n        }\n\n        return NULL;\n    }\n\n    /* append terminator and start the transfer */\n    append_stats(NULL, 0, NULL, 0, c);\n\n    if (c->dynamic_buffer.buffer == NULL) {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    } else {\n        write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n        c->dynamic_buffer.buffer = NULL;\n    }\n\n    return NULL;\n}\n\n/**\n * Get a suffix buffer and insert it into the list of used suffix buffers\n * @param c the connection object\n * @return a pointer to a new suffix buffer or NULL if allocation failed\n */\nstatic char *get_suffix_buffer(conn *c) {\n    if (c->suffixleft == c->suffixsize) {\n        char **new_suffix_list;\n        size_t sz = sizeof(char*) * c->suffixsize * 2;\n\n        new_suffix_list = realloc(c->suffixlist, sz);\n        if (new_suffix_list) {\n            c->suffixsize *= 2;\n            c->suffixlist = new_suffix_list;\n        } else {\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                        \"=%d Failed to resize suffix buffer\\n\", c->sfd);\n            }\n\n            return NULL;\n        }\n    }\n\n    char *suffix = cache_alloc(c->thread->suffix_cache);\n    if (suffix != NULL) {\n        *(c->suffixlist + c->suffixleft) = suffix;\n        ++c->suffixleft;\n    }\n\n    return suffix;\n}\n\n/* ntokens is overwritten here... shrug.. */\nstatic inline char* process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n    char *key;\n    size_t nkey;\n    int i = c->ileft;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    assert(c != NULL);\n\n    do {\n        while(key_token->length != 0) {\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return NULL;\n            }\n\n            ENGINE_ERROR_CODE ret = c->aiostat;\n            c->aiostat = ENGINE_SUCCESS;\n\n            if (ret == ENGINE_SUCCESS) {\n                ret = settings.engine.v1->get(settings.engine.v0, c, &it, key, nkey, 0);\n            }\n\n            switch (ret) {\n            case ENGINE_EWOULDBLOCK:\n                c->ewouldblock = true;\n                c->ileft = i;\n                return key;\n\n            case ENGINE_SUCCESS:\n                break;\n            case ENGINE_KEY_ENOENT:\n            default:\n                it = NULL;\n                break;\n            }\n\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, nkey, NULL != it);\n            }\n\n            if (it) {\n                item_info info = { .nvalue = 1 };\n                if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it,\n                                                       &info)) {\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    out_string(c, \"SERVER_ERROR error getting item data\");\n                    break;\n                }\n\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        settings.engine.v1->release(settings.engine.v0, c, it);\n                        break;\n                    }\n                }\n\n                /* Rebuild the suffix */\n                char *suffix = get_suffix_buffer(c);\n                if (suffix == NULL) {\n                    out_string(c, \"SERVER_ERROR out of memory rebuilding suffix\");\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    return NULL;\n                }\n                int suffix_len = snprintf(suffix, SUFFIX_SIZE,\n                                          \" %u %u\\r\\n\", htonl(info.flags),\n                                          info.nbytes);\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                MEMCACHED_COMMAND_GET(c->sfd, info.key, info.nkey,\n                                      info.nbytes, info.cas);\n                if (return_cas)\n                {\n\n                  char *cas = get_suffix_buffer(c);\n                  if (cas == NULL) {\n                    out_string(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    return NULL;\n                  }\n                  int cas_len = snprintf(cas, SUFFIX_SIZE, \" %\"PRIu64\"\\r\\n\",\n                                         info.cas);\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, info.key, info.nkey) != 0 ||\n                      add_iov(c, suffix, suffix_len - 2) != 0 ||\n                      add_iov(c, cas, cas_len) != 0 ||\n                      add_iov(c, info.value[0].iov_base, info.value[0].iov_len) != 0 ||\n                      add_iov(c, \"\\r\\n\", 2) != 0)\n                      {\n                          settings.engine.v1->release(settings.engine.v0, c, it);\n                          break;\n                      }\n                }\n                else\n                {\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, info.key, info.nkey) != 0 ||\n                      add_iov(c, suffix, suffix_len) != 0 ||\n                      add_iov(c, info.value[0].iov_base, info.value[0].iov_len) != 0 ||\n                      add_iov(c, \"\\r\\n\", 2) != 0)\n                      {\n                          settings.engine.v1->release(settings.engine.v0, c, it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                    \">%d sending key %s\\n\",\n                                                    c->sfd, info.key);\n                }\n\n                /* item_get() has incremented it->refcount for us */\n                STATS_HIT(c, get, key, nkey);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                STATS_MISS(c, get, key, nkey);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            key_token++;\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    c->suffixcurr = c->suffixlist;\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d END\\n\", c->sfd);\n    }\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_string(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n\n    return NULL;\n}\n\nstatic void process_update_command(conn *c, token_t *tokens, const size_t ntokens, ENGINE_STORE_OPERATION store_op, bool handle_cas) {\n    char *key;\n    size_t nkey;\n    unsigned int flags;\n    int32_t exptime_int = 0;\n    time_t exptime;\n    int vlen;\n    uint64_t req_cas_id=0;\n    item *it;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)\n           && safe_strtol(tokens[3].value, &exptime_int)\n           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */\n    exptime = exptime_int;\n\n    // does cas value exist?\n    if (handle_cas) {\n        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n    }\n\n    if (vlen < 0) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen, htonl(flags), exptime);\n    }\n\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, req_cas_id);\n        if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            out_string(c, \"SERVER_ERROR error getting item data\");\n            break;\n        }\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        c->store_op = store_op;\n        conn_set_state(c, conn_nread);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            out_string(c, \"SERVER_ERROR object too large for cache\");\n        } else {\n            out_string(c, \"SERVER_ERROR out of memory storing object\");\n        }\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n        c->sbytes = vlen + 2;\n\n        /* Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET. Anywhere else too? */\n        if (store_op == OPERATION_SET) {\n            settings.engine.v1->remove(settings.engine.v0, c, key, nkey, 0, 0);\n        }\n    }\n}\n\nstatic char* process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {\n\n    uint64_t delta;\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return NULL;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (!safe_strtoull(tokens[2].value, &delta)) {\n        out_string(c, \"CLIENT_ERROR invalid numeric delta argument\");\n        return NULL;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    uint64_t cas;\n    uint64_t result;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->arithmetic(settings.engine.v0, c, key, nkey,\n                                             incr, false, delta, 0, 0, &cas,\n                                             &result, 0);\n    }\n\n    char temp[INCR_MAX_STORAGE_LEN];\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        if (incr) {\n            STATS_INCR(c, incr_hits, key, nkey);\n        } else {\n            STATS_INCR(c, decr_hits, key, nkey);\n        }\n        snprintf(temp, sizeof(temp), \"%\"PRIu64, result);\n        out_string(c, temp);\n        break;\n    case ENGINE_KEY_ENOENT:\n        if (incr) {\n            STATS_INCR(c, incr_misses, key, nkey);\n        } else {\n            STATS_INCR(c, decr_misses, key, nkey);\n        }\n        out_string(c, \"NOT_FOUND\");\n        break;\n    case ENGINE_ENOMEM:\n        out_string(c, \"SERVER_ERROR out of memory\");\n        break;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    case ENGINE_EINVAL:\n        out_string(c, \"CLIENT_ERROR cannot increment or decrement non-numeric value\");\n        break;\n    case ENGINE_NOT_STORED:\n        out_string(c, \"SERVER_ERROR failed to store item\");\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        out_string(c, \"SERVER_ERROR not supported\");\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        return key;\n    default:\n        abort();\n    }\n\n    return NULL;\n}\n\nstatic char *process_delete_command(conn *c, token_t *tokens,\n                                    const size_t ntokens) {\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    if (ntokens > 3) {\n        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, \"0\") == 0;\n        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);\n        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))\n            || (ntokens == 5 && hold_is_zero && sets_noreply);\n        if (!valid) {\n            out_string(c, \"CLIENT_ERROR bad command line format.  \"\n                       \"Usage: delete <key> [noreply]\");\n            return NULL;\n        }\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (nkey > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return NULL;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->remove(settings.engine.v0, c,\n                                         key, nkey, 0, 0);\n    }\n\n    /* For some reason the SLAB_INCR tries to access this... */\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        out_string(c, \"DELETED\");\n        SLAB_INCR(c, delete_hits, key, nkey);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        return key;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    default:\n        out_string(c, \"NOT_FOUND\");\n        STATS_INCR(c, delete_misses, key, nkey);\n    }\n\n    if (ret != ENGINE_EWOULDBLOCK && settings.detail_enabled) {\n        stats_prefix_record_delete(key, nkey);\n    }\n    return NULL;\n}\n\nstatic void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {\n    unsigned int level;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n    if (c->noreply && ntokens == 3) {\n        /* \"verbosity noreply\" is not according to the correct syntax */\n        c->noreply = false;\n        out_string(c, \"ERROR\");\n        return;\n    }\n\n    if (safe_strtoul(tokens[1].value, &level)) {\n        settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;\n        perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n        out_string(c, \"OK\");\n    } else {\n        out_string(c, \"ERROR\");\n    }\n}\n\nstatic char* process_command(conn *c, char *command) {\n\n    token_t tokens[MAX_TOKENS];\n    size_t ntokens;\n    int comm;\n    char *ret = NULL;\n\n    assert(c != NULL);\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"<%d %s\\n\", c->sfd, command);\n    }\n\n    /*\n     * for commands set/add/replace, we build an item and read the data\n     * directly into it, then continue in nread_complete().\n     */\n\n    if (c->ewouldblock) {\n        /*\n         * If we are retrying after the engine has completed a pending io for\n         * this command, skip add_msghdr() etc and clear the ewouldblock flag.\n         */\n        c->ewouldblock = false;\n    } else {\n        c->msgcurr = 0;\n        c->msgused = 0;\n        c->iovused = 0;\n        if (add_msghdr(c) != 0) {\n            out_string(c, \"SERVER_ERROR out of memory preparing response\");\n            return NULL;\n        }\n    }\n\n    ntokens = tokenize_command(command, tokens, MAX_TOKENS);\n    if (ntokens >= 3 &&\n        ((strcmp(tokens[COMMAND_TOKEN].value, \"get\") == 0) ||\n         (strcmp(tokens[COMMAND_TOKEN].value, \"bget\") == 0))) {\n\n        ret = process_get_command(c, tokens, ntokens, false);\n\n    } else if ((ntokens == 6 || ntokens == 7) &&\n               ((strcmp(tokens[COMMAND_TOKEN].value, \"add\") == 0 && (comm = (int)OPERATION_ADD)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"set\") == 0 && (comm = (int)OPERATION_SET)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"replace\") == 0 && (comm = (int)OPERATION_REPLACE)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"prepend\") == 0 && (comm = (int)OPERATION_PREPEND)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"append\") == 0 && (comm = (int)OPERATION_APPEND)) )) {\n\n        process_update_command(c, tokens, ntokens, (ENGINE_STORE_OPERATION)comm, false);\n\n    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, \"cas\") == 0 && (comm = (int)OPERATION_CAS))) {\n\n        process_update_command(c, tokens, ntokens, (ENGINE_STORE_OPERATION)comm, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"incr\") == 0)) {\n\n        ret = process_arithmetic_command(c, tokens, ntokens, 1);\n\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"gets\") == 0)) {\n\n        ret = process_get_command(c, tokens, ntokens, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"decr\") == 0)) {\n\n        ret = process_arithmetic_command(c, tokens, ntokens, 0);\n\n    } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, \"delete\") == 0)) {\n\n        ret = process_delete_command(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"stats\") == 0)) {\n\n        ret = process_stat(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"flush_all\") == 0)) {\n        time_t exptime;\n\n        set_noreply_maybe(c, tokens, ntokens);\n\n        if (ntokens == (c->noreply ? 3 : 2)) {\n            exptime = 0;\n        } else {\n            exptime = strtol(tokens[1].value, NULL, 10);\n            if(errno == ERANGE) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return NULL;\n            }\n        }\n\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            ret = settings.engine.v1->flush(settings.engine.v0, c, exptime);\n        }\n\n        switch (ret) {\n        case  ENGINE_SUCCESS:\n            out_string(c, \"OK\");\n            break;\n        case ENGINE_ENOTSUP:\n            out_string(c, \"SERVER_ERROR not supported\");\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            return c->rcurr + 9;\n        default:\n            out_string(c, \"SERVER_ERROR failed to flush cache\");\n        }\n\n        if (ret != ENGINE_EWOULDBLOCK) {\n            STATS_NOKEY(c, cmd_flush);\n        }\n        return NULL;\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"version\") == 0)) {\n\n        out_string(c, \"VERSION \" VERSION);\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"quit\") == 0)) {\n\n        conn_set_state(c, conn_closing);\n\n    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, \"verbosity\") == 0)) {\n        process_verbosity_command(c, tokens, ntokens);\n    } else if (settings.extensions.ascii != NULL) {\n        EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *cmd;\n        size_t nbytes = 0;\n        char *ptr;\n\n        if (ntokens > 0) {\n            if (ntokens == MAX_TOKENS) {\n                out_string(c, \"ERROR too many arguments\");\n                return NULL;\n            }\n\n            if (tokens[ntokens - 1].length == 0) {\n                --ntokens;\n            }\n        }\n\n        for (cmd = settings.extensions.ascii; cmd != NULL; cmd = cmd->next) {\n            if (cmd->accept(cmd->cookie, c, ntokens, tokens, &nbytes, &ptr)) {\n                break;\n            }\n        }\n\n        if (cmd == NULL) {\n            out_string(c, \"ERROR unknown command\");\n        } else if (nbytes == 0) {\n            switch (cmd->execute(cmd->cookie, c, ntokens, tokens,\n                                 ascii_response_handler)) {\n            case ENGINE_SUCCESS:\n                if (c->dynamic_buffer.buffer != NULL) {\n                    write_and_free(c, c->dynamic_buffer.buffer,\n                                   c->dynamic_buffer.offset);\n                    c->dynamic_buffer.buffer = NULL;\n                } else {\n                    conn_set_state(c, conn_new_cmd);\n                }\n                break;\n            case ENGINE_EWOULDBLOCK:\n                c->ewouldblock = true;\n                ret = tokens[KEY_TOKEN].value;;\n                break;\n            case ENGINE_DISCONNECT:\n            default:\n                conn_set_state(c, conn_closing);\n\n            }\n        } else {\n            c->rlbytes = nbytes;\n            c->ritem = ptr;\n            c->ascii_cmd = cmd;\n            /* NOT SUPPORTED YET! */\n            conn_set_state(c, conn_nread);\n        }\n    } else {\n        out_string(c, \"ERROR\");\n    }\n    return ret;\n}\n\n/*\n * if we have a complete line in the buffer, process it.\n */\nstatic int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                    \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                             \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                char buffer[1024];\n                ssize_t nw;\n                nw = bytes_to_output_string(buffer, sizeof(buffer), c->sfd,\n                                            true, \"Read binary protocol data:\",\n                                            (const char*)req->bytes,\n                                            sizeof(req->bytes));\n                if (nw != -1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                    \"%s\", buffer);\n                }\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.vbucket = ntohs(req->request.vbucket);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ &&\n                !(c->binary_header.request.magic == PROTOCOL_BINARY_RES &&\n                  response_handlers[c->binary_header.request.opcode])) {\n                if (settings.verbose) {\n                    if (c->binary_header.request.magic != PROTOCOL_BINARY_RES) {\n                        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                              \"%d: Invalid magic:  %x\\n\", c->sfd,\n                              c->binary_header.request.magic);\n                    } else {\n                        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                              \"%d: ERROR: Unsupported response packet received: %u\\n\",\n                              c->sfd, (unsigned int)c->binary_header.request.opcode);\n\n                    }\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont, *left, lb;\n\n        if (c->rbytes == 0) {\n            return 0;\n        }\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el) {\n            if (c->rbytes > 1024) {\n                /*\n                 * We didn't have a '\\n' in the first k. This _has_ to be a\n                 * large multiget, if not we should just nuke the connection.\n                 */\n                char *ptr = c->rcurr;\n                while (*ptr == ' ') { /* ignore leading whitespaces */\n                    ++ptr;\n                }\n\n                if (ptr - c->rcurr > 100 ||\n                    (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {\n\n                    conn_set_state(c, conn_closing);\n                    return 1;\n                }\n            }\n\n            return 0;\n        }\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        lb = *el;\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        LIBEVENT_THREAD *thread = c->thread;\n        LOCK_THREAD(thread);\n        left = process_command(c, c->rcurr);\n        if (c->ewouldblock) {\n            unregister_event(c);\n        }\n        UNLOCK_THREAD(thread);\n\n        if (left != NULL) {\n            /*\n             * We have not processed the entire command. This happens\n             * when the engine returns ENGINE_EWOULDBLOCK for one of the\n             * keys in a get/gets request.\n             */\n            assert (left <= el);\n\n            int count = strlen(c->rcurr);\n            if ((c->rcurr + count) == left) {\n                // Retry the entire command\n                cont = c->rcurr;\n            } else {\n                left -= (count + 1);\n                cont = left;\n                assert(cont >= c->rcurr);\n                if (cont > c->rcurr) {\n                    memmove(cont, c->rcurr, count);\n                }\n            }\n\n            /* de-tokenize the command */\n            while ((left = memchr(left, '\\0', el - left)) != NULL) {\n                *left = ' ';\n            }\n            *el = lb;\n        }\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}\n\n/*\n * read a UDP request.\n */\nstatic enum try_read_result try_read_udp(conn *c) {\n    int res;\n\n    assert(c != NULL);\n\n    c->request_addr_size = sizeof(c->request_addr);\n    res = recvfrom(c->sfd, c->rbuf, c->rsize,\n                   0, (struct sockaddr *)&c->request_addr, &c->request_addr_size);\n    if (res > 8) {\n        unsigned char *buf = (unsigned char *)c->rbuf;\n        STATS_ADD(c, bytes_read, res);\n\n        /* Beginning of UDP packet is the request ID; save it. */\n        c->request_id = buf[0] * 256 + buf[1];\n\n        /* If this is a multi-packet request, drop it. */\n        if (buf[4] != 0 || buf[5] != 1) {\n            out_string(c, \"SERVER_ERROR multi-packet request not supported\");\n            return READ_NO_DATA_RECEIVED;\n        }\n\n        /* Don't care about any of the rest of the header. */\n        res -= 8;\n        memmove(c->rbuf, c->rbuf + 8, res);\n\n        c->rbytes += res;\n        c->rcurr = c->rbuf;\n        return READ_DATA_RECEIVED;\n    }\n    return READ_NO_DATA_RECEIVED;\n}\n\n/*\n * read from network as much as we can, handle buffer overflow and connection\n * close.\n * before reading, move the remaining incomplete fragment of a command\n * (if any) to the beginning of the buffer.\n *\n * To protect us from someone flooding a connection with bogus data causing\n * the connection to eat up all available memory, break out and start looking\n * at the data I've got after a number of reallocs...\n *\n * @return enum try_read_result\n */\nstatic enum try_read_result try_read_network(conn *c) {\n    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n    int res;\n    int num_allocs = 0;\n    assert(c != NULL);\n\n    if (c->rcurr != c->rbuf) {\n        if (c->rbytes != 0) /* otherwise there's nothing to copy */\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n        c->rcurr = c->rbuf;\n    }\n\n    while (1) {\n        if (c->rbytes >= c->rsize) {\n            if (num_allocs == 4) {\n                return gotdata;\n            }\n            ++num_allocs;\n            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n            if (!new_rbuf) {\n                if (settings.verbose > 0) {\n                 settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                          \"Couldn't realloc input buffer\\n\");\n                }\n                c->rbytes = 0; /* ignore what we read */\n                out_string(c, \"SERVER_ERROR out of memory reading request\");\n                c->write_and_go = conn_closing;\n                return READ_MEMORY_ERROR;\n            }\n            c->rcurr = c->rbuf = new_rbuf;\n            c->rsize *= 2;\n        }\n\n        int avail = c->rsize - c->rbytes;\n        res = recv(c->sfd, c->rbuf + c->rbytes, avail, 0);\n        if (res > 0) {\n            STATS_ADD(c, bytes_read, res);\n            gotdata = READ_DATA_RECEIVED;\n            c->rbytes += res;\n            if (res == avail) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (res == 0) {\n            return READ_ERROR;\n        }\n        if (res == -1) {\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                break;\n            }\n            return READ_ERROR;\n        }\n    }\n    return gotdata;\n}\n\nbool register_event(conn *c, struct timeval *timeout) {\n    assert(!c->registered_in_libevent);\n\n    if (event_add(&c->event, timeout) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING,\n                                        NULL,\n                                        \"Failed to add connection to libevent: %s\",\n                                        strerror(errno));\n        return false;\n    }\n\n    c->registered_in_libevent = true;\n\n    return true;\n}\n\nbool unregister_event(conn *c) {\n    assert(c->registered_in_libevent);\n\n    if (event_del(&c->event) == -1) {\n        return false;\n    }\n\n    c->registered_in_libevent = false;\n\n    return true;\n}\n\n\nbool update_event(conn *c, const int new_flags) {\n    assert(c != NULL);\n\n    struct event_base *base = c->event.ev_base;\n    if (c->ev_flags == new_flags)\n        return true;\n\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                    \"Updated event for %d to read=%s, write=%s\\n\",\n                                    c->sfd, (new_flags & EV_READ ? \"yes\" : \"no\"),\n                                    (new_flags & EV_WRITE ? \"yes\" : \"no\"));\n\n    if (!unregister_event(c)) {\n        return false;\n    }\n\n    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = new_flags;\n\n    return register_event(c, NULL);\n}\n\n/*\n * Transmit the next chunk of data from our list of msgbuf structures.\n *\n * Returns:\n *   TRANSMIT_COMPLETE   All done writing.\n *   TRANSMIT_INCOMPLETE More data remaining to write.\n *   TRANSMIT_SOFT_ERROR Can't write any more right now.\n *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)\n */\nstatic enum transmit_result transmit(conn *c) {\n    assert(c != NULL);\n\n    if (c->msgcurr < c->msgused &&\n            c->msglist[c->msgcurr].msg_iovlen == 0) {\n        /* Finished writing the current msg; advance to the next. */\n        c->msgcurr++;\n    }\n    if (c->msgcurr < c->msgused) {\n        ssize_t res;\n        struct msghdr *m = &c->msglist[c->msgcurr];\n\n        res = sendmsg(c->sfd, m, 0);\n        if (res > 0) {\n            STATS_ADD(c, bytes_written, res);\n\n            /* We've written some of the data. Remove the completed\n               iovec entries from the list of pending writes. */\n            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {\n                res -= m->msg_iov->iov_len;\n                m->msg_iovlen--;\n                m->msg_iov++;\n            }\n\n            /* Might have written just part of the last iovec entry;\n               adjust it so the next write will do the rest. */\n            if (res > 0) {\n                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;\n                m->msg_iov->iov_len -= res;\n            }\n            return TRANSMIT_INCOMPLETE;\n        }\n        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                            \"Couldn't update event\\n\");\n                }\n                conn_set_state(c, conn_closing);\n                return TRANSMIT_HARD_ERROR;\n            }\n            return TRANSMIT_SOFT_ERROR;\n        }\n        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,\n           we have a real error, on which we close the connection */\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"Failed to write, and not due to blocking: %s\",\n                                            strerror(errno));\n        }\n\n        if (IS_UDP(c->transport))\n            conn_set_state(c, conn_read);\n        else\n            conn_set_state(c, conn_closing);\n        return TRANSMIT_HARD_ERROR;\n    } else {\n        return TRANSMIT_COMPLETE;\n    }\n}\n\nbool conn_listening(conn *c)\n{\n    int sfd;\n    struct sockaddr_storage addr;\n    socklen_t addrlen = sizeof(addr);\n\n    if ((sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen)) == -1) {\n        if (errno == EMFILE) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Too many open connections\\n\");\n            }\n            disable_listen();\n        } else if (errno != EAGAIN && errno != EWOULDBLOCK) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"Failed to accept new client: %s\\n\",\n                                            strerror(errno));\n        }\n\n        return false;\n    }\n\n    STATS_LOCK();\n    int curr_conns = ++stats.curr_conns;\n    STATS_UNLOCK();\n\n    if (curr_conns >= settings.maxconns) {\n        STATS_LOCK();\n        ++stats.rejected_conns;\n        STATS_UNLOCK();\n\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Too many open connections\\n\");\n        }\n\n        safe_close(sfd);\n        return false;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return false;\n    }\n\n    dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,\n                      DATA_BUFFER_SIZE, tcp_transport);\n\n    return false;\n}\n\n/**\n * Ship tap log to the other end. This state differs with all other states\n * in the way that it support full duplex dialog. We're listening to both read\n * and write events from libevent most of the time. If a read event occurs we\n * switch to the conn_read state to read and execute the input message (that would\n * be an ack message from the other side). If a write event occurs we continue to\n * send tap log to the other end.\n * @param c the tap connection to drive\n * @return true if we should continue to process work for this connection, false\n *              if we should start processing events for other connections.\n */\nbool conn_ship_log(conn *c) {\n    bool cont = false;\n\n    if (c->sfd == INVALID_SOCKET) {\n        return false;\n    }\n\n    short mask = EV_READ | EV_PERSIST | EV_WRITE;\n\n    if (c->which & EV_READ || c->rbytes > 0) {\n        if (c->rbytes > 0) {\n            if (try_read_command(c) == 0) {\n                conn_set_state(c, conn_read);\n            }\n        } else {\n            conn_set_state(c, conn_read);\n        }\n\n        // we're going to process something.. let's proceed\n        cont = true;\n\n        // We have a finite number of messages in the input queue\n        // so let's process all of them instead of backing off after\n        // reading a subset of them.\n        // Why? Because we've got every time we're calling ship_tap_log\n        // we try to send a chunk of items.. This means that if we end\n        // up in a situation where we're receiving a burst of nack messages\n        // we'll only process a subset of messages in our input queue,\n        // and it will slowly grow..\n        c->nevents = settings.reqs_per_tap_event;\n    } else if (c->which & EV_WRITE) {\n        --c->nevents;\n        if (c->nevents >= 0) {\n            LOCK_THREAD(c->thread);\n            c->ewouldblock = false;\n            ship_tap_log(c);\n            if (c->ewouldblock) {\n                mask = EV_READ | EV_PERSIST;\n            } else {\n                cont = true;\n            }\n            UNLOCK_THREAD(c->thread);\n        }\n    }\n\n    if (!update_event(c, mask)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO,\n                                            c, \"Couldn't update event\\n\");\n        }\n        conn_set_state(c, conn_closing);\n    }\n\n    return cont;\n}\n\nbool conn_waiting(conn *c) {\n    if (!update_event(c, EV_READ | EV_PERSIST)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Couldn't update event\\n\");\n        }\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n    conn_set_state(c, conn_read);\n    return false;\n}\n\nbool conn_read(conn *c) {\n    int res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);\n    switch (res) {\n    case READ_NO_DATA_RECEIVED:\n        conn_set_state(c, conn_waiting);\n        break;\n    case READ_DATA_RECEIVED:\n        conn_set_state(c, conn_parse_cmd);\n        break;\n    case READ_ERROR:\n        conn_set_state(c, conn_closing);\n        break;\n    case READ_MEMORY_ERROR: /* Failed to allocate more memory */\n        /* State already set by try_read_network */\n        break;\n    }\n\n    return true;\n}\n\nbool conn_parse_cmd(conn *c) {\n    if (try_read_command(c) == 0) {\n        /* wee need more data! */\n        conn_set_state(c, conn_waiting);\n    }\n\n    return !c->ewouldblock;\n}\n\nbool conn_new_cmd(conn *c) {\n    /* Only process nreqs at a time to avoid starving other connections */\n    --c->nevents;\n    if (c->nevents >= 0) {\n        reset_cmd_handler(c);\n    } else {\n        STATS_NOKEY(c, conn_yields);\n        if (c->rbytes > 0) {\n            /* We have already read in data into the input buffer,\n               so libevent will most likely not signal read events\n               on the socket (unless more data is available. As a\n               hack we should just put in a request to write data,\n               because that should be possible ;-)\n            */\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_INFO,\n                                                    c, \"Couldn't update event\\n\");\n                }\n                conn_set_state(c, conn_closing);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    return true;\n}\n\n\nbool conn_swallow(conn *c) {\n    ssize_t res;\n    /* we are reading sbytes and throwing them away */\n    if (c->sbytes == 0) {\n        conn_set_state(c, conn_new_cmd);\n        return true;\n    }\n\n    /* first check if we have leftovers in the conn_read buffer */\n    if (c->rbytes > 0) {\n        uint32_t tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;\n        c->sbytes -= tocopy;\n        c->rcurr += tocopy;\n        c->rbytes -= tocopy;\n        return true;\n    }\n\n    /*  now try reading from the socket */\n    res = recv(c->sfd, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize, 0);\n    if (res > 0) {\n        STATS_ADD(c, bytes_read, res);\n        c->sbytes -= res;\n        return true;\n    }\n    if (res == 0) { /* end of stream */\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n        if (!update_event(c, EV_READ | EV_PERSIST)) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't update event\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n        return false;\n    }\n\n    if (errno != ENOTCONN && errno != ECONNRESET) {\n        /* otherwise we have a real error, on which we close the connection */\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                        \"Failed to read, and not due to blocking (%s)\\n\",\n                                        strerror(errno));\n    }\n\n    conn_set_state(c, conn_closing);\n\n    return true;\n\n}\n\nbool conn_nread(conn *c) {\n    ssize_t res;\n\n    if (c->rlbytes == 0) {\n        LIBEVENT_THREAD *t = c->thread;\n        LOCK_THREAD(t);\n        bool block = c->ewouldblock = false;\n        complete_nread(c);\n        UNLOCK_THREAD(t);\n        /* Breaking this into two, as complete_nread may have\n           moved us to a different thread */\n        t = c->thread;\n        LOCK_THREAD(t);\n        if (c->ewouldblock) {\n            unregister_event(c);\n            block = true;\n        }\n        UNLOCK_THREAD(t);\n        return !block;\n    }\n    /* first check if we have leftovers in the conn_read buffer */\n    if (c->rbytes > 0) {\n        uint32_t tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;\n        if (c->ritem != c->rcurr) {\n            memmove(c->ritem, c->rcurr, tocopy);\n        }\n        c->ritem += tocopy;\n        c->rlbytes -= tocopy;\n        c->rcurr += tocopy;\n        c->rbytes -= tocopy;\n        if (c->rlbytes == 0) {\n            return true;\n        }\n    }\n\n    /*  now try reading from the socket */\n    res = recv(c->sfd, c->ritem, c->rlbytes, 0);\n    if (res > 0) {\n        STATS_ADD(c, bytes_read, res);\n        if (c->rcurr == c->ritem) {\n            c->rcurr += res;\n        }\n        c->ritem += res;\n        c->rlbytes -= res;\n        return true;\n    }\n    if (res == 0) { /* end of stream */\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n        if (!update_event(c, EV_READ | EV_PERSIST)) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't update event\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n        return false;\n    }\n\n    if (errno != ENOTCONN && errno != ECONNRESET) {\n        /* otherwise we have a real error, on which we close the connection */\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Failed to read, and not due to blocking:\\n\"\n                                        \"errno: %d %s \\n\"\n                                        \"rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\\n\",\n                                        errno, strerror(errno),\n                                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,\n                                        (int)c->rlbytes, (int)c->rsize);\n    }\n    conn_set_state(c, conn_closing);\n    return true;\n}\n\nbool conn_write(conn *c) {\n    /*\n     * We want to write out a simple response. If we haven't already,\n     * assemble it into a msgbuf list (this will be a single-entry\n     * list for TCP or a two-entry list for UDP).\n     */\n    if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {\n        if (add_iov(c, c->wcurr, c->wbytes) != 0) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't build response\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n    }\n\n    return conn_mwrite(c);\n}\n\nbool conn_mwrite(conn *c) {\n    if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Failed to build UDP headers\\n\");\n        }\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n\n    switch (transmit(c)) {\n    case TRANSMIT_COMPLETE:\n        if (c->state == conn_mwrite) {\n            while (c->ileft > 0) {\n                item *it = *(c->icurr);\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                c->icurr++;\n                c->ileft--;\n            }\n            while (c->suffixleft > 0) {\n                char *suffix = *(c->suffixcurr);\n                cache_free(c->thread->suffix_cache, suffix);\n                c->suffixcurr++;\n                c->suffixleft--;\n            }\n            /* XXX:  I don't know why this wasn't the general case */\n            if(c->protocol == binary_prot) {\n                conn_set_state(c, c->write_and_go);\n            } else {\n                conn_set_state(c, conn_new_cmd);\n            }\n        } else if (c->state == conn_write) {\n            if (c->write_and_free) {\n                free(c->write_and_free);\n                c->write_and_free = 0;\n            }\n            conn_set_state(c, c->write_and_go);\n        } else {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Unexpected state %d\\n\", c->state);\n            }\n            conn_set_state(c, conn_closing);\n        }\n        break;\n\n    case TRANSMIT_INCOMPLETE:\n    case TRANSMIT_HARD_ERROR:\n        break;                   /* Continue in state machine. */\n\n    case TRANSMIT_SOFT_ERROR:\n        return false;\n    }\n\n    return true;\n}\n\nbool conn_pending_close(conn *c) {\n    assert(c->sfd == INVALID_SOCKET);\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                    \"Awaiting clients to release the cookie (pending close for %p)\",\n                                    (void*)c);\n    LOCK_THREAD(c->thread);\n    c->thread->pending_io = list_remove(c->thread->pending_io, c);\n    if (!list_contains(c->thread->pending_close, c)) {\n        enlist_conn(c, &c->thread->pending_close);\n    }\n    UNLOCK_THREAD(c->thread);\n\n    /*\n     * tell the tap connection that we're disconnecting it now,\n     * but give it a grace period\n     */\n    perform_callbacks(ON_DISCONNECT, NULL, c);\n\n    /*\n     * disconnect callback may have changed the state for the object\n     * so we might complete the disconnect now\n     */\n    return c->state != conn_pending_close;\n}\n\nbool conn_immediate_close(conn *c) {\n    settings.extensions.logger->log(EXTENSION_LOG_DETAIL, c,\n                                    \"Immediate close of %p\",\n                                    (void*)c);\n    perform_callbacks(ON_DISCONNECT, NULL, c);\n    conn_close(c);\n\n    return false;\n}\n\nbool conn_closing(conn *c) {\n    if (IS_UDP(c->transport)) {\n        conn_cleanup(c);\n        return false;\n    }\n\n    // We don't want any network notifications anymore..\n    unregister_event(c);\n    safe_close(c->sfd);\n    c->sfd = INVALID_SOCKET;\n\n    if (c->refcount > 1) {\n        conn_set_state(c, conn_pending_close);\n    } else {\n        conn_set_state(c, conn_immediate_close);\n    }\n    return true;\n}\n\nbool conn_add_tap_client(conn *c) {\n    LIBEVENT_THREAD *tp = tap_thread;\n    LIBEVENT_THREAD *orig_thread = c->thread;\n\n    assert(orig_thread);\n    assert(orig_thread != tp);\n\n    c->ewouldblock = true;\n\n    unregister_event(c);\n\n    LOCK_THREAD(orig_thread);\n    /* Clean out the lists */\n    orig_thread->pending_io = list_remove(orig_thread->pending_io, c);\n    orig_thread->pending_close = list_remove(orig_thread->pending_close, c);\n\n    LOCK_THREAD(tp);\n    c->ev_flags = 0;\n    conn_set_state(c, conn_setup_tap_stream);\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                    \"Moving %d conn from %p to %p\\n\",\n                                    c->sfd, c->thread, tp);\n    c->thread = tp;\n    c->event.ev_base = tp->base;\n    assert(c->next == NULL);\n    assert(c->list_state == 0);\n    enlist_conn(c, &tp->pending_io);\n\n    UNLOCK_THREAD(tp);\n\n    UNLOCK_THREAD(orig_thread);\n\n    notify_thread(tp);\n\n    return false;\n}\n\nbool conn_setup_tap_stream(conn *c) {\n    process_bin_tap_connect(c);\n    return true;\n}\n\nvoid event_handler(const int fd, const short which, void *arg) {\n    conn *c;\n\n    c = (conn *)arg;\n    assert(c != NULL);\n\n    if (memcached_shutdown) {\n        event_base_loopbreak(c->event.ev_base);\n        return ;\n    }\n\n    c->which = which;\n\n    /* sanity */\n    if (fd != c->sfd) {\n        if (c->sfd != INVALID_SOCKET) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                    \"Catastrophic: event fd doesn't match conn fd!\\n\");\n        }\n        unregister_event(c);\n        if (c->sfd != INVALID_SOCKET && c->thread != NULL) {\n            conn_close(c);\n        }\n        return;\n    }\n\n    perform_callbacks(ON_SWITCH_CONN, c, c);\n\n    c->nevents = settings.reqs_per_event;\n    if (c->state == conn_ship_log) {\n        c->nevents = settings.reqs_per_tap_event;\n    }\n\n    LIBEVENT_THREAD *thr = c->thread;\n\n    // Do we have pending closes?\n    const size_t max_items = 256;\n    conn *pending_close[max_items];\n    size_t n_pending_close = 0;\n    if (thr != NULL) {\n        LOCK_THREAD(thr);\n        if (thr->pending_close && thr->last_checked != current_time) {\n            assert(!has_cycle(thr->pending_close));\n            thr->last_checked = current_time;\n\n            n_pending_close = list_to_array(pending_close, max_items,\n                                            &thr->pending_close);\n        }\n        UNLOCK_THREAD(thr);\n    }\n\n    if (settings.verbose) {\n        do {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"%d - Running task: (%s)\\n\",\n                                            c->sfd, state_text(c->state));\n        } while (c->state(c));\n    } else {\n        while (c->state(c)) {\n            /* empty */\n        }\n    }\n\n    /* Close any connections pending close */\n    if (n_pending_close > 0) {\n        for (size_t i = 0; i < n_pending_close; ++i) {\n            conn *ce = pending_close[i];\n            if (ce->refcount == 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                                \"OK, time to nuke: %p\\n\",\n                                                (void*)ce);\n                conn_close(ce);\n                pending_close[i] = NULL;\n            } else {\n                LOCK_THREAD(ce->thread);\n                enlist_conn(ce, &ce->thread->pending_close);\n                UNLOCK_THREAD(ce->thread);\n            }\n        }\n    }\n\n    if (thr != NULL) {\n        LOCK_THREAD(thr);\n        finalize_list(pending_close, n_pending_close);\n        UNLOCK_THREAD(thr);\n    }\n}\n\nstatic void dispatch_event_handler(int fd, short which, void *arg) {\n    char buffer[80];\n    ssize_t nr = recv(fd, buffer, sizeof(buffer), 0);\n\n    (void)(which);\n    (void)(arg);\n    if (nr != -1 && is_listen_disabled()) {\n        bool enable = false;\n        pthread_mutex_lock(&listen_state.mutex);\n        listen_state.count -= nr;\n        if (listen_state.count <= 0) {\n            enable = true;\n            listen_state.disabled = false;\n        }\n        pthread_mutex_unlock(&listen_state.mutex);\n        if (enable) {\n            conn *next;\n            for (next = listen_conn; next; next = next->next) {\n                update_event(next, EV_READ | EV_PERSIST);\n                if (listen(next->sfd, settings.backlog) != 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"listen() failed\",\n                                                    strerror(errno));\n                }\n            }\n        }\n    }\n}\n\n\n\nstatic SOCKET new_socket(struct addrinfo *ai) {\n    SOCKET sfd;\n\n    sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n    if (sfd == INVALID_SOCKET) {\n        return INVALID_SOCKET;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return INVALID_SOCKET;\n    }\n\n    return sfd;\n}\n\n\n/*\n * Sets a socket's send buffer size to the maximum allowed by the system.\n */\nstatic void maximize_sndbuf(const int sfd) {\n    socklen_t intsize = sizeof(int);\n    int last_good = 0;\n    int min, max, avg;\n    int old_size;\n\n    /* Start with the default size. */\n    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&old_size, &intsize) != 0) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"getsockopt(SO_SNDBUF): %s\",\n                                            strerror(errno));\n        }\n\n        return;\n    }\n\n    /* Binary-search for the real maximum. */\n    min = old_size;\n    max = MAX_SENDBUF_SIZE;\n\n    while (min <= max) {\n        avg = ((unsigned int)(min + max)) / 2;\n        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {\n            last_good = avg;\n            min = avg + 1;\n        } else {\n            max = avg - 1;\n        }\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                 \"<%d send buffer was %d, now %d\\n\", sfd, old_size, last_good);\n    }\n}\n\n\n\n/**\n * Create a socket and bind it to a specific port number\n * @param interface the interface to bind to\n * @param port the port number to bind to\n * @param transport the transport protocol (TCP / UDP)\n * @param portnumber_file A filepointer to write the port numbers to\n *        when they are successfully added to the list of ports we\n *        listen on.\n */\nstatic int server_socket(const char *interface,\n                         int port,\n                         enum network_transport transport,\n                         FILE *portnumber_file) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct addrinfo *ai;\n    struct addrinfo *next;\n    struct addrinfo hints = { .ai_flags = AI_PASSIVE,\n                              .ai_family = AF_UNSPEC };\n    char port_buf[NI_MAXSERV];\n    int error;\n    int success = 0;\n    int flags =1;\n\n    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;\n\n    if (port == -1) {\n        port = 0;\n    }\n    snprintf(port_buf, sizeof(port_buf), \"%d\", port);\n    error= getaddrinfo(interface, port_buf, &hints, &ai);\n    if (error != 0) {\n        if (error != EAI_SYSTEM) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                     \"getaddrinfo(): %s\\n\", gai_strerror(error));\n        } else {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                     \"getaddrinfo(): %s\\n\", strerror(error));\n        }\n        return 1;\n    }\n\n    for (next= ai; next; next= next->ai_next) {\n        conn *listen_conn_add;\n        if ((sfd = new_socket(next)) == INVALID_SOCKET) {\n            /* getaddrinfo can return \"junk\" addresses,\n             * we make sure at least one works before erroring.\n             */\n            continue;\n        }\n\n#ifdef IPV6_V6ONLY\n        if (next->ai_family == AF_INET6) {\n            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(IPV6_V6ONLY): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                continue;\n            }\n        }\n#endif\n\n        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n        if (IS_UDP(transport)) {\n            maximize_sndbuf(sfd);\n        } else {\n            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(SO_KEEPALIVE): %s\",\n                                                strerror(errno));\n            }\n\n            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(SO_LINGER): %s\",\n                                                strerror(errno));\n            }\n\n            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(TCP_NODELAY): %s\",\n                                                strerror(errno));\n            }\n        }\n\n        if (bind(sfd, next->ai_addr, next->ai_addrlen) == SOCKET_ERROR) {\n            if (errno != EADDRINUSE) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"bind(): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            safe_close(sfd);\n            continue;\n        } else {\n            success++;\n            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == SOCKET_ERROR) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"listen(): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            if (portnumber_file != NULL &&\n                (next->ai_addr->sa_family == AF_INET ||\n                 next->ai_addr->sa_family == AF_INET6)) {\n                union {\n                    struct sockaddr_in in;\n                    struct sockaddr_in6 in6;\n                } my_sockaddr;\n                socklen_t len = sizeof(my_sockaddr);\n                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {\n                    if (next->ai_addr->sa_family == AF_INET) {\n                        fprintf(portnumber_file, \"%s INET: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in.sin_port));\n                    } else {\n                        fprintf(portnumber_file, \"%s INET6: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in6.sin6_port));\n                    }\n                }\n            }\n        }\n\n        if (IS_UDP(transport)) {\n            int c;\n\n            for (c = 0; c < settings.num_threads_per_udp; c++) {\n                /* this is guaranteed to hit all threads because we round-robin */\n                dispatch_conn_new(sfd, conn_read, EV_READ | EV_PERSIST,\n                                  UDP_READ_BUFFER_SIZE, transport);\n                STATS_LOCK();\n                ++stats.curr_conns;\n                ++stats.daemon_conns;\n                STATS_UNLOCK();\n            }\n        } else {\n            if (!(listen_conn_add = conn_new(sfd, conn_listening,\n                                             EV_READ | EV_PERSIST, 1,\n                                             transport, main_base, NULL))) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"failed to create listening connection\\n\");\n                exit(EXIT_FAILURE);\n            }\n            listen_conn_add->next = listen_conn;\n            listen_conn = listen_conn_add;\n            STATS_LOCK();\n            ++stats.curr_conns;\n            ++stats.daemon_conns;\n            STATS_UNLOCK();\n        }\n    }\n\n    freeaddrinfo(ai);\n\n    /* Return zero iff we detected no errors in starting up connections */\n    return success == 0;\n}\n\nstatic int server_sockets(int port, enum network_transport transport,\n                          FILE *portnumber_file) {\n    if (settings.inter == NULL) {\n        return server_socket(settings.inter, port, transport, portnumber_file);\n    } else {\n        // tokenize them and bind to each one of them..\n        char *b;\n        int ret = 0;\n        char *list = strdup(settings.inter);\n\n        if (list == NULL) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"Failed to allocate memory for parsing server interface string\\n\");\n            return 1;\n        }\n        for (char *p = strtok_r(list, \";,\", &b);\n             p != NULL;\n             p = strtok_r(NULL, \";,\", &b)) {\n            int the_port = port;\n\n            char *s = strchr(p, ':');\n            if (s != NULL) {\n                *s = '\\0';\n                ++s;\n                if (!safe_strtol(s, &the_port)) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"Invalid port number: \\\"%s\\\"\", s);\n                    return 1;\n                }\n            }\n            if (strcmp(p, \"*\") == 0) {\n                p = NULL;\n            }\n            ret |= server_socket(p, the_port, transport, portnumber_file);\n        }\n        free(list);\n        return ret;\n    }\n}\n\nstatic int new_socket_unix(void) {\n    int sfd;\n\n    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == INVALID_SOCKET) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"socket(AF_UNIX, SOCK_STREAM, 0): %s\",\n                                        strerror(errno));\n        return INVALID_SOCKET;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return INVALID_SOCKET;\n    }\n    return sfd;\n}\n\n/* this will probably not work on windows */\nstatic int server_socket_unix(const char *path, int access_mask) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct sockaddr_un addr;\n    struct stat tstat;\n    int flags =1;\n    int old_umask;\n\n    if (!path) {\n        return 1;\n    }\n\n    if ((sfd = new_socket_unix()) == -1) {\n        return 1;\n    }\n\n    /*\n     * Clean up a previous socket file if we left it around\n     */\n    if (lstat(path, &tstat) == 0) {\n        if (S_ISSOCK(tstat.st_mode))\n            unlink(path);\n    }\n\n    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n\n    /*\n     * the memset call clears nonstandard fields in some impementations\n     * that otherwise mess things up.\n     */\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sun_family = AF_UNIX;\n    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);\n    assert(strcmp(addr.sun_path, path) == 0);\n    old_umask = umask( ~(access_mask&0777));\n    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"bind(): %s\",\n                                        strerror(errno));\n        safe_close(sfd);\n        umask(old_umask);\n        return 1;\n    }\n    umask(old_umask);\n    if (listen(sfd, settings.backlog) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"listen(): %s\",\n                                        strerror(errno));\n        safe_close(sfd);\n        return 1;\n    }\n    if (!(listen_conn = conn_new(sfd, conn_listening,\n                                 EV_READ | EV_PERSIST, 1,\n                                 local_transport, main_base, NULL))) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"failed to create listening connection\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    STATS_LOCK();\n    ++stats.daemon_conns;\n    STATS_UNLOCK();\n\n    return 0;\n}\n\nstatic struct event clockevent;\n\n/* time-sensitive callers can call it by hand with this, outside the normal ever-1-second timer */\nstatic void set_current_time(void) {\n    struct timeval timer;\n\n    gettimeofday(&timer, NULL);\n    current_time = (rel_time_t) (timer.tv_sec - process_started);\n}\n\nstatic void clock_handler(const int fd, const short which, void *arg) {\n    struct timeval t = {.tv_sec = 1, .tv_usec = 0};\n    static bool initialized = false;\n\n    (void)(fd);\n    (void)(which);\n    (void)(arg);\n\n    if (memcached_shutdown) {\n        event_base_loopbreak(main_base);\n        return ;\n    }\n\n    if (initialized) {\n        /* only delete the event if it's actually there. */\n        evtimer_del(&clockevent);\n    } else {\n        initialized = true;\n    }\n\n    evtimer_set(&clockevent, clock_handler, 0);\n    event_base_set(main_base, &clockevent);\n    evtimer_add(&clockevent, &t);\n\n    set_current_time();\n}\n\nstatic void usage(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\");\n    printf(\"-p <num>      TCP port number to listen on (default: 11211)\\n\"\n           \"-U <num>      UDP port number to listen on (default: 11211, 0 is off)\\n\"\n           \"-s <file>     UNIX socket path to listen on (disables network support)\\n\"\n           \"-a <mask>     access mask for UNIX socket, in octal (default: 0700)\\n\"\n           \"-l <addr>     interface to listen on (default: INADDR_ANY, all addresses)\\n\"\n           \"              <addr> may be specified as host:port. If you don't specify\\n\"\n           \"              a port number, the value you specified with -p or -U is\\n\"\n           \"              used. You may specify multiple addresses separated by comma\\n\"\n           \"              or by using -l multiple times\\n\"\n           \"-d            run as a daemon\\n\"\n           \"-r            maximize core file limit\\n\"\n           \"-u <username> assume identity of <username> (only when run as root)\\n\"\n           \"-m <num>      max memory to use for items in megabytes (default: 64 MB)\\n\"\n           \"-M            return error on memory exhausted (rather than removing items)\\n\"\n           \"-c <num>      max simultaneous connections (default: 1000)\\n\"\n           \"-k            lock down all paged memory.  Note that there is a\\n\"\n           \"              limit on how much memory you may lock.  Trying to\\n\"\n           \"              allocate more than that would fail, so be sure you\\n\"\n           \"              set the limit correctly for the user you started\\n\"\n           \"              the daemon with (not for -u <username> user;\\n\"\n           \"              under sh this is done with 'ulimit -S -l NUM_KB').\\n\"\n           \"-v            verbose (print errors/warnings while in event loop)\\n\"\n           \"-vv           very verbose (also print client commands/reponses)\\n\"\n           \"-vvv          extremely verbose (also print internal state transitions)\\n\"\n           \"-h            print this help and exit\\n\"\n           \"-i            print memcached and libevent license\\n\"\n           \"-P <file>     save PID in <file>, only used with -d option\\n\"\n           \"-f <factor>   chunk size growth factor (default: 1.25)\\n\"\n           \"-n <bytes>    minimum space allocated for key+value+flags (default: 48)\\n\");\n    printf(\"-L            Try to use large memory pages (if available). Increasing\\n\"\n           \"              the memory page size could reduce the number of TLB misses\\n\"\n           \"              and improve the performance. In order to get large pages\\n\"\n           \"              from the OS, memcached will allocate the total item-cache\\n\"\n           \"              in one large chunk.\\n\");\n    printf(\"-D <char>     Use <char> as the delimiter between key prefixes and IDs.\\n\"\n           \"              This is used for per-prefix stats reporting. The default is\\n\"\n           \"              \\\":\\\" (colon). If this option is specified, stats collection\\n\"\n           \"              is turned on automatically; if not, then it may be turned on\\n\"\n           \"              by sending the \\\"stats detail on\\\" command to the server.\\n\");\n    printf(\"-t <num>      number of threads to use (default: 4)\\n\");\n    printf(\"-R            Maximum number of requests per event, limits the number of\\n\"\n           \"              requests process for a given connection to prevent \\n\"\n           \"              starvation (default: 20)\\n\");\n    printf(\"-C            Disable use of CAS\\n\");\n    printf(\"-b            Set the backlog queue limit (default: 1024)\\n\");\n    printf(\"-B            Binding protocol - one of ascii, binary, or auto (default)\\n\");\n    printf(\"-I            Override the size of each slab page. Adjusts max item size\\n\"\n           \"              (default: 1mb, min: 1k, max: 128m)\\n\");\n    printf(\"-q            Disable detailed stats commands\\n\");\n#ifdef SASL_ENABLED\n    printf(\"-S            Require SASL authentication\\n\");\n#endif\n    printf(\"-X module,cfg Load the module and initialize it with the config\\n\");\n    printf(\"-E engine     Load engine as the storage engine\\n\");\n    printf(\"-e config     Pass config as configuration options to the storage engine\\n\");\n    printf(\"\\nEnvironment variables:\\n\"\n           \"MEMCACHED_PORT_FILENAME   File to write port information to\\n\"\n           \"MEMCACHED_TOP_KEYS        Number of top keys to keep track of\\n\"\n           \"MEMCACHED_REQS_TAP_EVENT  Similar to -R but for tap_ship_log\\n\");\n}\n\nstatic void usage_license(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\\n\");\n    printf(\n    \"Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions are\\n\"\n    \"met:\\n\"\n    \"\\n\"\n    \"    * Redistributions of source code must retain the above copyright\\n\"\n    \"notice, this list of conditions and the following disclaimer.\\n\"\n    \"\\n\"\n    \"    * Redistributions in binary form must reproduce the above\\n\"\n    \"copyright notice, this list of conditions and the following disclaimer\\n\"\n    \"in the documentation and/or other materials provided with the\\n\"\n    \"distribution.\\n\"\n    \"\\n\"\n    \"    * Neither the name of the Danga Interactive nor the names of its\\n\"\n    \"contributors may be used to endorse or promote products derived from\\n\"\n    \"this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n\"\n    \"\\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n\"\n    \"A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n\"\n    \"OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n\"\n    \"SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n\"\n    \"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    \"\\n\"\n    \"\\n\"\n    \"This product includes software developed by Niels Provos.\\n\"\n    \"\\n\"\n    \"[ libevent ]\\n\"\n    \"\\n\"\n    \"Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions\\n\"\n    \"are met:\\n\"\n    \"1. Redistributions of source code must retain the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer.\\n\"\n    \"2. Redistributions in binary form must reproduce the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer in the\\n\"\n    \"   documentation and/or other materials provided with the distribution.\\n\"\n    \"3. All advertising materials mentioning features or use of this software\\n\"\n    \"   must display the following acknowledgement:\\n\"\n    \"      This product includes software developed by Niels Provos.\\n\"\n    \"4. The name of the author may not be used to endorse or promote products\\n\"\n    \"   derived from this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\\n\"\n    \"IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\\n\"\n    \"OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\\n\"\n    \"IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\\n\"\n    \"INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\\n\"\n    \"NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\\n\"\n    \"THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    );\n\n    return;\n}\n\nstatic void save_pid(const char *pid_file) {\n    FILE *fp;\n\n    if (access(pid_file, F_OK) == 0) {\n        if ((fp = fopen(pid_file, \"r\")) != NULL) {\n            char buffer[1024];\n            if (fgets(buffer, sizeof(buffer), fp) != NULL) {\n                unsigned int pid;\n                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                               \"WARNING: The pid file contained the following (running) pid: %u\\n\", pid);\n                }\n            }\n            fclose(fp);\n        }\n    }\n\n    if ((fp = fopen(pid_file, \"w\")) == NULL) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"Could not open the pid file %s for writing: %s\\n\",\n                 pid_file, strerror(errno));\n        return;\n    }\n\n    fprintf(fp,\"%ld\\n\", (long)getpid());\n    if (fclose(fp) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not close the pid file %s: %s\\n\",\n                pid_file, strerror(errno));\n    }\n}\n\nstatic void remove_pidfile(const char *pid_file) {\n    if (pid_file != NULL) {\n        if (unlink(pid_file) != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Could not remove the pid file %s: %s\\n\",\n                    pid_file, strerror(errno));\n        }\n    }\n}\n\n#ifndef HAVE_SIGIGNORE\nstatic int sigignore(int sig) {\n    struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {\n        return -1;\n    }\n    return 0;\n}\n#endif /* !HAVE_SIGIGNORE */\n\nstatic void sigterm_handler(int sig) {\n    assert(sig == SIGTERM || sig == SIGINT);\n    memcached_shutdown = 1;\n}\n\nstatic int install_sigterm_handler(void) {\n    struct sigaction sa = {.sa_handler = sigterm_handler, .sa_flags = 0};\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(SIGTERM, &sa, 0) == -1 ||\n        sigaction(SIGINT, &sa, 0) == -1) {\n        return -1;\n    }\n\n    return 0;\n}\n\n/*\n * On systems that supports multiple page sizes we may reduce the\n * number of TLB-misses by using the biggest available page size\n */\nstatic int enable_large_pages(void) {\n#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)\n    int ret = -1;\n    size_t sizes[32];\n    int avail = getpagesizes(sizes, 32);\n    if (avail != -1) {\n        size_t max = sizes[0];\n        struct memcntl_mha arg = {0};\n        int ii;\n\n        for (ii = 1; ii < avail; ++ii) {\n            if (max < sizes[ii]) {\n                max = sizes[ii];\n            }\n        }\n\n        arg.mha_flags   = 0;\n        arg.mha_pagesize = max;\n        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;\n\n        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                  \"Failed to set large pages: %s\\nWill use default page size\\n\",\n                  strerror(errno));\n        } else {\n            ret = 0;\n        }\n    } else {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n          \"Failed to get supported pagesizes: %s\\nWill use default page size\\n\",\n          strerror(errno));\n    }\n\n    return ret;\n#else\n    return 0;\n#endif\n}\n\nstatic const char* get_server_version(void) {\n    return VERSION;\n}\n\nstatic void store_engine_specific(const void *cookie,\n                                  void *engine_data) {\n    conn *c = (conn*)cookie;\n    c->engine_storage = engine_data;\n}\n\nstatic void *get_engine_specific(const void *cookie) {\n    conn *c = (conn*)cookie;\n    return c->engine_storage;\n}\n\nstatic int get_socket_fd(const void *cookie) {\n    conn *c = (conn *)cookie;\n    return c->sfd;\n}\n\nstatic ENGINE_ERROR_CODE reserve_cookie(const void *cookie) {\n    conn *c = (conn *)cookie;\n    ++c->refcount;\n    return ENGINE_SUCCESS;\n}\n\nstatic ENGINE_ERROR_CODE release_cookie(const void *cookie) {\n    conn *c = (conn *)cookie;\n    --c->refcount;\n    return ENGINE_SUCCESS;\n}\n\nstatic int num_independent_stats(void) {\n    return settings.num_threads + 1;\n}\n\nstatic void *new_independent_stats(void) {\n    int ii;\n    int nrecords = num_independent_stats();\n    struct independent_stats *independent_stats = calloc(sizeof(independent_stats) + sizeof(struct thread_stats) * nrecords, 1);\n    if (settings.topkeys > 0)\n        independent_stats->topkeys = topkeys_init(settings.topkeys);\n    for (ii = 0; ii < nrecords; ii++)\n        pthread_mutex_init(&independent_stats->thread_stats[ii].mutex, NULL);\n    return independent_stats;\n}\n\nstatic void release_independent_stats(void *stats) {\n    int ii;\n    int nrecords = num_independent_stats();\n    struct independent_stats *independent_stats = stats;\n    if (independent_stats->topkeys)\n        topkeys_free(independent_stats->topkeys);\n    for (ii = 0; ii < nrecords; ii++)\n        pthread_mutex_destroy(&independent_stats->thread_stats[ii].mutex);\n    free(independent_stats);\n}\n\nstatic inline struct independent_stats *get_independent_stats(conn *c) {\n    struct independent_stats *independent_stats;\n    if (settings.engine.v1->get_stats_struct != NULL) {\n        independent_stats = settings.engine.v1->get_stats_struct(settings.engine.v0, (const void *)c);\n        if (independent_stats == NULL)\n            independent_stats = default_independent_stats;\n    } else {\n        independent_stats = default_independent_stats;\n    }\n    return independent_stats;\n}\n\nstatic inline struct thread_stats *get_thread_stats(conn *c) {\n    struct independent_stats *independent_stats = get_independent_stats(c);\n    assert(c->thread->index < num_independent_stats());\n    return &independent_stats->thread_stats[c->thread->index];\n}\n\nstatic void register_callback(ENGINE_HANDLE *eh,\n                              ENGINE_EVENT_TYPE type,\n                              EVENT_CALLBACK cb, const void *cb_data) {\n    struct engine_event_handler *h =\n        calloc(sizeof(struct engine_event_handler), 1);\n\n    assert(h);\n    h->cb = cb;\n    h->cb_data = cb_data;\n    h->next = engine_event_handlers[type];\n    engine_event_handlers[type] = h;\n    (void)(eh); /* unused */\n}\n\nstatic rel_time_t get_current_time(void)\n{\n    return current_time;\n}\n\nstatic void count_eviction(const void *cookie, const void *key, const int nkey) {\n    topkeys_t *tk = get_independent_stats((conn*)cookie)->topkeys;\n    TK(tk, evictions, key, nkey, get_current_time());\n}\n\n/**\n * To make it easy for engine implementors that doesn't want to care about\n * writing their own incr/decr code, they can just set the arithmetic function\n * to NULL and use this implementation. It is not efficient, due to the fact\n * that it does multiple calls through the interface (get and then cas store).\n * If you don't care, feel free to use it..\n */\nstatic ENGINE_ERROR_CODE internal_arithmetic(ENGINE_HANDLE* handle,\n                                             const void* cookie,\n                                             const void* key,\n                                             const int nkey,\n                                             const bool increment,\n                                             const bool create,\n                                             const uint64_t delta,\n                                             const uint64_t initial,\n                                             const rel_time_t exptime,\n                                             uint64_t *cas,\n                                             uint64_t *result,\n                                             uint16_t vbucket)\n{\n    ENGINE_HANDLE_V1 *e = (ENGINE_HANDLE_V1*)handle;\n\n    item *it = NULL;\n\n    ENGINE_ERROR_CODE ret;\n    ret = e->get(handle, cookie, &it, key, nkey, vbucket);\n\n    if (ret == ENGINE_SUCCESS) {\n        item_info info = { .nvalue = 1 };\n\n        if (!e->get_item_info(handle, cookie, it, &info)) {\n            e->release(handle, cookie, it);\n            return ENGINE_FAILED;\n        }\n\n        char value[80];\n\n        if (info.value[0].iov_len > (sizeof(value) - 1)) {\n            e->release(handle, cookie, it);\n            return ENGINE_EINVAL;\n        }\n\n        memcpy(value, info.value[0].iov_base, info.value[0].iov_len);\n        value[info.value[0].iov_len] = '\\0';\n\n        uint64_t val;\n        if (!safe_strtoull(value, &val)) {\n            e->release(handle, cookie, it);\n            return ENGINE_EINVAL;\n        }\n\n        if (increment) {\n            val += delta;\n        } else {\n            if (delta > val) {\n                val = 0;\n            } else {\n                val -= delta;\n            }\n        }\n\n        size_t nb = snprintf(value, sizeof(value), \"%\"PRIu64, val);\n        *result = val;\n        item *nit = NULL;\n        if (e->allocate(handle, cookie, &nit, key,\n                        nkey, nb, info.flags, info.exptime) != ENGINE_SUCCESS) {\n            e->release(handle, cookie, it);\n            return ENGINE_ENOMEM;\n        }\n\n        item_info i2 = { .nvalue = 1 };\n        if (!e->get_item_info(handle, cookie, nit, &i2)) {\n            e->release(handle, cookie, it);\n            e->release(handle, cookie, nit);\n            return ENGINE_FAILED;\n        }\n\n        memcpy(i2.value[0].iov_base, value, nb);\n        e->item_set_cas(handle, cookie, nit, info.cas);\n        ret = e->store(handle, cookie, nit, cas, OPERATION_CAS, vbucket);\n        e->release(handle, cookie, it);\n        e->release(handle, cookie, nit);\n    } else if (ret == ENGINE_KEY_ENOENT && create) {\n        char value[80];\n        size_t nb = snprintf(value, sizeof(value), \"%\"PRIu64\"\\r\\n\", initial);\n        *result = initial;\n        if (e->allocate(handle, cookie, &it, key, nkey, nb, 0, exptime) != ENGINE_SUCCESS) {\n            e->release(handle, cookie, it);\n            return ENGINE_ENOMEM;\n        }\n\n        item_info info = { .nvalue = 1 };\n        if (!e->get_item_info(handle, cookie, it, &info)) {\n            e->release(handle, cookie, it);\n            return ENGINE_FAILED;\n        }\n\n        memcpy(info.value[0].iov_base, value, nb);\n        ret = e->store(handle, cookie, it, cas, OPERATION_CAS, vbucket);\n        e->release(handle, cookie, it);\n    }\n\n    /* We had a race condition.. just call ourself recursively to retry */\n    if (ret == ENGINE_KEY_EEXISTS) {\n        return internal_arithmetic(handle, cookie, key, nkey, increment, create, delta,\n                                   initial, exptime, cas, result, vbucket);\n    }\n\n    return ret;\n}\n\n/**\n * Register an extension if it's not already registered\n *\n * @param type the type of the extension to register\n * @param extension the extension to register\n * @return true if success, false otherwise\n */\nstatic bool register_extension(extension_type_t type, void *extension)\n{\n    if (extension == NULL) {\n        return false;\n    }\n\n    switch (type) {\n    case EXTENSION_DAEMON:\n        for (EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n             ptr != NULL;\n             ptr = ptr->next) {\n            if (ptr == extension) {\n                return false;\n            }\n        }\n        ((EXTENSION_DAEMON_DESCRIPTOR *)(extension))->next = settings.extensions.daemons;\n        settings.extensions.daemons = extension;\n        return true;\n    case EXTENSION_LOGGER:\n        settings.extensions.logger = extension;\n        return true;\n    case EXTENSION_ASCII_PROTOCOL:\n        if (settings.extensions.ascii != NULL) {\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *last;\n            for (last = settings.extensions.ascii; last->next != NULL;\n                 last = last->next) {\n                if (last == extension) {\n                    return false;\n                }\n            }\n            if (last == extension) {\n                return false;\n            }\n            last->next = extension;\n            last->next->next = NULL;\n        } else {\n            settings.extensions.ascii = extension;\n            settings.extensions.ascii->next = NULL;\n        }\n        return true;\n\n    case EXTENSION_BINARY_PROTOCOL:\n        if (settings.extensions.binary != NULL) {\n            EXTENSION_BINARY_PROTOCOL_DESCRIPTOR *last;\n            for (last = settings.extensions.binary; last->next != NULL;\n                 last = last->next) {\n                if (last == extension) {\n                    return false;\n                }\n            }\n            if (last == extension) {\n                return false;\n            }\n            last->next = extension;\n            last->next->next = NULL;\n        } else {\n            settings.extensions.binary = extension;\n            settings.extensions.binary->next = NULL;\n        }\n\n        ((EXTENSION_BINARY_PROTOCOL_DESCRIPTOR*)extension)->setup(setup_binary_lookup_cmd);\n        return true;\n\n    default:\n        return false;\n    }\n}\n\n/**\n * Unregister an extension\n *\n * @param type the type of the extension to remove\n * @param extension the extension to remove\n */\nstatic void unregister_extension(extension_type_t type, void *extension)\n{\n    switch (type) {\n    case EXTENSION_DAEMON:\n        {\n            EXTENSION_DAEMON_DESCRIPTOR *prev = NULL;\n            EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n\n            while (ptr != NULL && ptr != extension) {\n                prev = ptr;\n                ptr = ptr->next;\n            }\n\n            if (ptr != NULL && prev != NULL) {\n                prev->next = ptr->next;\n            }\n\n            if (settings.extensions.daemons == ptr) {\n                settings.extensions.daemons = ptr->next;\n            }\n        }\n        break;\n    case EXTENSION_LOGGER:\n        if (settings.extensions.logger == extension) {\n            if (get_stderr_logger() == extension) {\n                settings.extensions.logger = get_null_logger();\n            } else {\n                settings.extensions.logger = get_stderr_logger();\n            }\n        }\n        break;\n    case EXTENSION_ASCII_PROTOCOL:\n        {\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *prev = NULL;\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *ptr = settings.extensions.ascii;\n\n            while (ptr != NULL && ptr != extension) {\n                prev = ptr;\n                ptr = ptr->next;\n            }\n\n            if (ptr != NULL && prev != NULL) {\n                prev->next = ptr->next;\n            }\n\n            if (settings.extensions.ascii == ptr) {\n                settings.extensions.ascii = ptr->next;\n            }\n        }\n        break;\n\n\n    case EXTENSION_BINARY_PROTOCOL:\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"You can't unregister a binary command handler!\");\n        abort();\n        break;\n\n    default:\n        ;\n    }\n\n}\n\n/**\n * Get the named extension\n */\nstatic void* get_extension(extension_type_t type)\n{\n    switch (type) {\n    case EXTENSION_DAEMON:\n        return settings.extensions.daemons;\n\n    case EXTENSION_LOGGER:\n        return settings.extensions.logger;\n\n    case EXTENSION_ASCII_PROTOCOL:\n        return settings.extensions.ascii;\n\n    case EXTENSION_BINARY_PROTOCOL:\n        return settings.extensions.binary;\n\n    default:\n        return NULL;\n    }\n}\n\nstatic void shutdown_server(void) {\n    memcached_shutdown = 1;\n}\n\nstatic EXTENSION_LOGGER_DESCRIPTOR* get_logger(void)\n{\n    return settings.extensions.logger;\n}\n\nstatic EXTENSION_LOG_LEVEL get_log_level(void)\n{\n    EXTENSION_LOG_LEVEL ret;\n    switch (settings.verbose) {\n    case 0: ret = EXTENSION_LOG_WARNING; break;\n    case 1: ret = EXTENSION_LOG_INFO; break;\n    case 2: ret = EXTENSION_LOG_DEBUG; break;\n    default:\n        ret = EXTENSION_LOG_DETAIL;\n    }\n    return ret;\n}\n\nstatic void set_log_level(EXTENSION_LOG_LEVEL severity)\n{\n    switch (severity) {\n    case EXTENSION_LOG_WARNING: settings.verbose = 0; break;\n    case EXTENSION_LOG_INFO: settings.verbose = 1; break;\n    case EXTENSION_LOG_DEBUG: settings.verbose = 2; break;\n    default:\n        settings.verbose = 3;\n    }\n}\n\nstatic void get_config_append_stats(const char *key, const uint16_t klen,\n                                    const char *val, const uint32_t vlen,\n                                    const void *cookie)\n{\n    if (klen == 0  || vlen == 0) {\n        return ;\n    }\n\n    char *pos = (char*)cookie;\n    size_t nbytes = strlen(pos);\n\n    if ((nbytes + klen + vlen + 3) > 1024) {\n        // Not enough size in the buffer..\n        return;\n    }\n\n    memcpy(pos + nbytes, key, klen);\n    nbytes += klen;\n    pos[nbytes] = '=';\n    ++nbytes;\n    memcpy(pos + nbytes, val, vlen);\n    nbytes += vlen;\n    memcpy(pos + nbytes, \";\", 2);\n}\n\nstatic bool get_config(struct config_item items[]) {\n    char config[1024];\n    config[0] = '\\0';\n    process_stat_settings(get_config_append_stats, config);\n    int rval = parse_config(config, items, NULL);\n    return rval >= 0;\n}\n\n/**\n * Callback the engines may call to get the public server interface\n * @return pointer to a structure containing the interface. The client should\n *         know the layout and perform the proper casts.\n */\nstatic SERVER_HANDLE_V1 *get_server_api(void)\n{\n    static SERVER_CORE_API core_api = {\n        .server_version = get_server_version,\n        .hash = hash,\n        .realtime = realtime,\n        .abstime = abstime,\n        .get_current_time = get_current_time,\n        .parse_config = parse_config,\n        .shutdown = shutdown_server,\n        .get_config = get_config\n    };\n\n    static SERVER_COOKIE_API server_cookie_api = {\n        .get_auth_data = get_auth_data,\n        .store_engine_specific = store_engine_specific,\n        .get_engine_specific = get_engine_specific,\n        .get_socket_fd = get_socket_fd,\n        .notify_io_complete = notify_io_complete,\n        .reserve = reserve_cookie,\n        .release = release_cookie\n    };\n\n    static SERVER_STAT_API server_stat_api = {\n        .new_stats = new_independent_stats,\n        .release_stats = release_independent_stats,\n        .evicting = count_eviction\n    };\n\n    static SERVER_LOG_API server_log_api = {\n        .get_logger = get_logger,\n        .get_level = get_log_level,\n        .set_level = set_log_level\n    };\n\n    static SERVER_EXTENSION_API extension_api = {\n        .register_extension = register_extension,\n        .unregister_extension = unregister_extension,\n        .get_extension = get_extension\n    };\n\n    static SERVER_CALLBACK_API callback_api = {\n        .register_callback = register_callback,\n        .perform_callbacks = perform_callbacks,\n    };\n\n    static SERVER_HANDLE_V1 rv = {\n        .interface = 1,\n        .core = &core_api,\n        .stat = &server_stat_api,\n        .extension = &extension_api,\n        .callback = &callback_api,\n        .log = &server_log_api,\n        .cookie = &server_cookie_api\n    };\n\n    if (rv.engine == NULL) {\n        rv.engine = settings.engine.v0;\n    }\n\n    return &rv;\n}\n\n/**\n * Load a shared object and initialize all the extensions in there.\n *\n * @param soname the name of the shared object (may not be NULL)\n * @param config optional configuration parameters\n * @return true if success, false otherwise\n */\nstatic bool load_extension(const char *soname, const char *config) {\n    if (soname == NULL) {\n        return false;\n    }\n\n    /* Hack to remove the warning from C99 */\n    union my_hack {\n        MEMCACHED_EXTENSIONS_INITIALIZE initialize;\n        void* voidptr;\n    } funky = {.initialize = NULL };\n\n    void *handle = dlopen(soname, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to open library \\\"%s\\\": %s\\n\",\n                soname, msg ? msg : \"unknown error\");\n        return false;\n    }\n\n    void *symbol = dlsym(handle, \"memcached_extensions_initialize\");\n    if (symbol == NULL) {\n        const char *msg = dlerror();\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not find symbol \\\"memcached_extensions_initialize\\\" in %s: %s\\n\",\n                soname, msg ? msg : \"unknown error\");\n        return false;\n    }\n    funky.voidptr = symbol;\n\n    EXTENSION_ERROR_CODE error = (*funky.initialize)(config, get_server_api);\n\n    if (error != EXTENSION_SUCCESS) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to initalize extensions from %s. Error code: %d\\n\",\n                soname, error);\n        dlclose(handle);\n        return false;\n    }\n\n    if (settings.verbose > 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, NULL,\n                \"Loaded extensions from: %s\\n\", soname);\n    }\n\n    return true;\n}\n\n/**\n * Do basic sanity check of the runtime environment\n * @return true if no errors found, false if we can't use this env\n */\nstatic bool sanitycheck(void) {\n    /* One of our biggest problems is old and bogus libevents */\n    const char *ever = event_get_version();\n    if (ever != NULL) {\n        if (strncmp(ever, \"1.\", 2) == 0) {\n            /* Require at least 1.3 (that's still a couple of years old) */\n            if ((ever[2] == '1' || ever[2] == '2') && !isdigit(ever[3])) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"You are using libevent %s.\\nPlease upgrade to\"\n                        \" a more recent version (1.3 or newer)\\n\",\n                        event_get_version());\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nint main (int argc, char **argv) {\n    int c;\n    bool lock_memory = false;\n    bool do_daemonize = false;\n    int maxcore = 0;\n    char *username = NULL;\n    char *pid_file = NULL;\n    struct passwd *pw;\n    struct rlimit rlim;\n    char unit = '\\0';\n    int size_max = 0;\n\n    bool protocol_specified = false;\n    bool tcp_specified = false;\n    bool udp_specified = false;\n\n    const char *engine = \"default_engine.so\";\n    const char *engine_config = NULL;\n    char old_options[1024] = { [0] = '\\0' };\n    char *old_opts = old_options;\n\n    /* make the time we started always be 2 seconds before we really\n       did, so time(0) - time.started is never zero.  if so, things\n       like 'settings.oldest_live' which act as booleans as well as\n       values are now false in boolean context... */\n    process_started = time(0) - 2;\n    set_current_time();\n\n    /* Initialize the socket subsystem */\n    initialize_sockets();\n\n    /* init settings */\n    settings_init();\n\n    initialize_binary_lookup_map();\n\n    if (memcached_initialize_stderr_logger(get_server_api) != EXTENSION_SUCCESS) {\n        fprintf(stderr, \"Failed to initialize log system\\n\");\n        return EX_OSERR;\n    }\n\n    if (!sanitycheck()) {\n        return EX_OSERR;\n    }\n\n    /* process arguments */\n    while (-1 != (c = getopt(argc, argv,\n          \"a:\"  /* access mask for unix socket */\n          \"p:\"  /* TCP port number to listen on */\n          \"s:\"  /* unix socket path to listen on */\n          \"U:\"  /* UDP port number to listen on */\n          \"m:\"  /* max memory to use for items in megabytes */\n          \"M\"   /* return error on memory exhausted */\n          \"c:\"  /* max simultaneous connections */\n          \"k\"   /* lock down all paged memory */\n          \"hi\"  /* help, licence info */\n          \"r\"   /* maximize core file limit */\n          \"v\"   /* verbose */\n          \"d\"   /* daemon mode */\n          \"l:\"  /* interface to listen on */\n          \"u:\"  /* user identity to run as */\n          \"P:\"  /* save PID in file */\n          \"f:\"  /* factor? */\n          \"n:\"  /* minimum space allocated for key+value+flags */\n          \"t:\"  /* threads */\n          \"D:\"  /* prefix delimiter? */\n          \"L\"   /* Large memory pages */\n          \"R:\"  /* max requests per event */\n          \"C\"   /* Disable use of CAS */\n          \"b:\"  /* backlog queue limit */\n          \"B:\"  /* Binding protocol */\n          \"I:\"  /* Max item size */\n          \"S\"   /* Sasl ON */\n          \"E:\"  /* Engine to load */\n          \"e:\"  /* Engine options */\n          \"q\"   /* Disallow detailed stats */\n          \"X:\"  /* Load extension */\n        ))) {\n        switch (c) {\n        case 'a':\n            /* access for unix domain socket, as octal mask (like chmod)*/\n            settings.access= strtol(optarg,NULL,8);\n            break;\n\n        case 'U':\n            settings.udpport = atoi(optarg);\n            udp_specified = true;\n            break;\n        case 'p':\n            settings.port = atoi(optarg);\n            tcp_specified = true;\n            break;\n        case 's':\n            settings.socketpath = optarg;\n            break;\n        case 'm':\n            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n             old_opts += sprintf(old_opts, \"cache_size=%lu;\",\n                                 (unsigned long)settings.maxbytes);\n           break;\n        case 'M':\n            settings.evict_to_free = 0;\n            old_opts += sprintf(old_opts, \"eviction=false;\");\n            break;\n        case 'c':\n            settings.maxconns = atoi(optarg);\n            break;\n        case 'h':\n            usage();\n            exit(EXIT_SUCCESS);\n        case 'i':\n            usage_license();\n            exit(EXIT_SUCCESS);\n        case 'k':\n            lock_memory = true;\n            break;\n        case 'v':\n            settings.verbose++;\n            perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n            break;\n        case 'l':\n            if (settings.inter != NULL) {\n                size_t len = strlen(settings.inter) + strlen(optarg) + 2;\n                char *p = malloc(len);\n                if (p == NULL) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"Failed to allocate memory\\n\");\n                    return 1;\n                }\n                snprintf(p, len, \"%s,%s\", settings.inter, optarg);\n                free(settings.inter);\n                settings.inter = p;\n            } else {\n                settings.inter= strdup(optarg);\n            }\n            break;\n        case 'd':\n            do_daemonize = true;\n            break;\n        case 'r':\n            maxcore = 1;\n            break;\n        case 'R':\n            settings.reqs_per_event = atoi(optarg);\n            if (settings.reqs_per_event <= 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                      \"Number of requests per event must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'u':\n            username = optarg;\n            break;\n        case 'P':\n            pid_file = optarg;\n            break;\n        case 'f':\n            settings.factor = atof(optarg);\n            if (settings.factor <= 1.0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Factor must be greater than 1\\n\");\n                return 1;\n            }\n             old_opts += sprintf(old_opts, \"factor=%f;\",\n                                 settings.factor);\n           break;\n        case 'n':\n            settings.chunk_size = atoi(optarg);\n            if (settings.chunk_size == 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Chunk size must be greater than 0\\n\");\n                return 1;\n            }\n            old_opts += sprintf(old_opts, \"chunk_size=%u;\",\n                                settings.chunk_size);\n            break;\n        case 't':\n            settings.num_threads = atoi(optarg);\n            if (settings.num_threads <= 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Number of threads must be greater than 0\\n\");\n                return 1;\n            }\n            /* There're other problems when you get above 64 threads.\n             * In the future we should portably detect # of cores for the\n             * default.\n             */\n            if (settings.num_threads > 64) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"WARNING: Setting a high number of worker\"\n                        \"threads is not recommended.\\n\"\n                        \" Set this value to the number of cores in\"\n                        \" your machine or less.\\n\");\n            }\n            break;\n        case 'D':\n            settings.prefix_delimiter = optarg[0];\n            settings.detail_enabled = 1;\n            break;\n        case 'L' :\n            if (enable_large_pages() == 0) {\n                old_opts += sprintf(old_opts, \"preallocate=true;\");\n            }\n            break;\n        case 'C' :\n            settings.use_cas = false;\n            break;\n        case 'b' :\n            settings.backlog = atoi(optarg);\n            break;\n        case 'B':\n            protocol_specified = true;\n            if (strcmp(optarg, \"auto\") == 0) {\n                settings.binding_protocol = negotiating_prot;\n            } else if (strcmp(optarg, \"binary\") == 0) {\n                settings.binding_protocol = binary_prot;\n            } else if (strcmp(optarg, \"ascii\") == 0) {\n                settings.binding_protocol = ascii_prot;\n            } else {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Invalid value for binding protocol: %s\\n\"\n                        \" -- should be one of auto, binary, or ascii\\n\", optarg);\n                exit(EX_USAGE);\n            }\n            break;\n        case 'I':\n            unit = optarg[strlen(optarg)-1];\n            if (unit == 'k' || unit == 'm' ||\n                unit == 'K' || unit == 'M') {\n                optarg[strlen(optarg)-1] = '\\0';\n                size_max = atoi(optarg);\n                if (unit == 'k' || unit == 'K')\n                    size_max *= 1024;\n                if (unit == 'm' || unit == 'M')\n                    size_max *= 1024 * 1024;\n                settings.item_size_max = size_max;\n            } else {\n                settings.item_size_max = atoi(optarg);\n            }\n            if (settings.item_size_max < 1024) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Item max size cannot be less than 1024 bytes.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024 * 128) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Cannot set item size limit higher than 128 mb.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"WARNING: Setting item max size above 1MB is not\"\n                    \" recommended!\\n\"\n                    \" Raising this limit increases the minimum memory requirements\\n\"\n                    \" and will decrease your memory efficiency.\\n\"\n                );\n            }\n#ifndef __WIN32__\n            old_opts += sprintf(old_opts, \"item_size_max=%zu;\",\n                                settings.item_size_max);\n#else\n            old_opts += sprintf(old_opts, \"item_size_max=%lu;\", (long unsigned)\n                                settings.item_size_max);\n#endif\n            break;\n        case 'E':\n            engine = optarg;\n            break;\n        case 'e':\n            engine_config = optarg;\n            break;\n        case 'q':\n            settings.allow_detailed = false;\n            break;\n        case 'S': /* set Sasl authentication to true. Default is false */\n#ifndef SASL_ENABLED\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"This server is not built with SASL support.\\n\");\n            exit(EX_USAGE);\n#else\n            settings.require_sasl = true;\n#endif\n            break;\n        case 'X' :\n            {\n                char *ptr = strchr(optarg, ',');\n                if (ptr != NULL) {\n                    *ptr = '\\0';\n                    ++ptr;\n                }\n                if (!load_extension(optarg, ptr)) {\n                    exit(EXIT_FAILURE);\n                }\n                if (ptr != NULL) {\n                    *(ptr - 1) = ',';\n                }\n            }\n            break;\n        default:\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n\n    /*\n     * Use one workerthread to serve each UDP port if the user specified\n     * multiple ports\n     */\n    if (settings.inter != NULL && strchr(settings.inter, ',')) {\n        settings.num_threads_per_udp = 1;\n    } else {\n        settings.num_threads_per_udp = settings.num_threads;\n    }\n\n    if (getenv(\"MEMCACHED_REQS_TAP_EVENT\") != NULL) {\n        settings.reqs_per_tap_event = atoi(getenv(\"MEMCACHED_REQS_TAP_EVENT\"));\n    }\n\n    if (settings.reqs_per_tap_event <= 0) {\n        settings.reqs_per_tap_event = DEFAULT_REQS_PER_TAP_EVENT;\n    }\n\n\n    if (install_sigterm_handler() != 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"Failed to install SIGTERM handler\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    char *topkeys_env = getenv(\"MEMCACHED_TOP_KEYS\");\n    if (topkeys_env != NULL) {\n        settings.topkeys = atoi(topkeys_env);\n        if (settings.topkeys < 0) {\n            settings.topkeys = 0;\n        }\n    }\n\n    if (settings.require_sasl) {\n        if (!protocol_specified) {\n            settings.binding_protocol = binary_prot;\n        } else {\n            if (settings.binding_protocol == negotiating_prot) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"ERROR: You cannot use auto-negotiating protocol while requiring SASL.\\n\");\n                exit(EX_USAGE);\n            }\n            if (settings.binding_protocol == ascii_prot) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"ERROR: You cannot use only ASCII protocol while requiring SASL.\\n\");\n                exit(EX_USAGE);\n            }\n        }\n    }\n\n    if (tcp_specified && !udp_specified) {\n        settings.udpport = settings.port;\n    } else if (udp_specified && !tcp_specified) {\n        settings.port = settings.udpport;\n    }\n\n    if (engine_config != NULL && strlen(old_options) > 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"ERROR: You can't mix -e with the old options\\n\");\n        return EX_USAGE;\n    } else if (engine_config == NULL && strlen(old_options) > 0) {\n        engine_config = old_options;\n    }\n\n    if (maxcore != 0) {\n        struct rlimit rlim_new;\n        /*\n         * First try raising to infinity; if that fails, try bringing\n         * the soft limit to the hard.\n         */\n        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {\n            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;\n            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {\n                /* failed. try raising just to the old max */\n                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;\n                (void)setrlimit(RLIMIT_CORE, &rlim_new);\n            }\n        }\n        /*\n         * getrlimit again to see what we ended up with. Only fail if\n         * the soft limit ends up 0, because then no core files will be\n         * created at all.\n         */\n\n        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to ensure corefile creation\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /*\n     * If needed, increase rlimits to allow as many connections\n     * as needed.\n     */\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"failed to getrlimit number of files\\n\");\n        exit(EX_OSERR);\n    } else {\n        unsigned int maxfiles = settings.maxconns + (3 * (settings.num_threads + 2));\n        int syslimit = rlim.rlim_cur;\n        if (rlim.rlim_cur < maxfiles) {\n            rlim.rlim_cur = maxfiles;\n        }\n        if (rlim.rlim_max < rlim.rlim_cur) {\n            rlim.rlim_max = rlim.rlim_cur;\n        }\n        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n            const char *fmt;\n            fmt = \"WARNING: maxconns cannot be set to (%d) connections due to \"\n                \"system\\nresouce restrictions. Increase the number of file \"\n                \"descriptors allowed\\nto the memcached user process or start \"\n                \"memcached as root (remember\\nto use the -u parameter).\\n\"\n                \"The maximum number of connections is set to %d.\\n\";\n            int req = settings.maxconns;\n            settings.maxconns = syslimit - (3 * (settings.num_threads + 2));\n            if (settings.maxconns < 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                         \"failed to set rlimit for open files. Try starting as\"\n                         \" root or requesting smaller maxconns value.\\n\");\n                exit(EX_OSERR);\n            }\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            fmt, req, settings.maxconns);\n        }\n    }\n\n    /* Sanity check for the connection structures */\n    int nfiles = 0;\n    if (settings.port != 0) {\n        nfiles += 2;\n    }\n    if (settings.udpport != 0) {\n        nfiles += settings.num_threads * 2;\n    }\n\n    if (settings.maxconns <= nfiles) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Configuratioin error. \\n\"\n                \"You specified %d connections, but the system will use at \"\n                \"least %d\\nconnection structures to start.\\n\",\n                settings.maxconns, nfiles);\n        exit(EX_USAGE);\n    }\n\n    /* lose root privileges if we have them */\n    if (getuid() == 0 || geteuid() == 0) {\n        if (username == 0 || *username == '\\0') {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"can't run as root without the -u switch\\n\");\n            exit(EX_USAGE);\n        }\n        if ((pw = getpwnam(username)) == 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"can't find the user %s to switch to\\n\", username);\n            exit(EX_NOUSER);\n        }\n        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to assume identity of user %s: %s\\n\", username,\n                    strerror(errno));\n            exit(EX_OSERR);\n        }\n    }\n\n#ifdef SASL_ENABLED\n    init_sasl();\n#endif /* SASL */\n\n    /* daemonize if requested */\n    /* if we want to ensure our ability to dump core, don't chdir to / */\n    if (do_daemonize) {\n        if (sigignore(SIGHUP) == -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Failed to ignore SIGHUP: \", strerror(errno));\n        }\n        if (daemonize(maxcore, settings.verbose) == -1) {\n             settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to daemon() in order to daemonize\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* lock paged memory if needed */\n    if (lock_memory) {\n#ifdef HAVE_MLOCKALL\n        int res = mlockall(MCL_CURRENT | MCL_FUTURE);\n        if (res != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"warning: -k invalid, mlockall() failed: %s\\n\",\n                    strerror(errno));\n        }\n#else\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\\n\");\n#endif\n    }\n\n    /* initialize main thread libevent instance */\n    main_base = event_init();\n\n    /* Load the storage engine */\n    ENGINE_HANDLE *engine_handle = NULL;\n    if (!load_engine(engine,get_server_api,settings.extensions.logger,&engine_handle)) {\n        /* Error already reported */\n        exit(EXIT_FAILURE);\n    }\n\n    if (!init_engine(engine_handle,engine_config,settings.extensions.logger)) {\n        return false;\n    }\n\n    if (settings.verbose > 0) {\n        log_engine_details(engine_handle,settings.extensions.logger);\n    }\n    settings.engine.v1 = (ENGINE_HANDLE_V1 *) engine_handle;\n\n    if (settings.engine.v1->arithmetic == NULL) {\n        settings.engine.v1->arithmetic = internal_arithmetic;\n    }\n\n    /* initialize other stuff */\n    stats_init();\n\n    if (!(conn_cache = cache_create(\"conn\", sizeof(conn), sizeof(void*),\n                                    conn_constructor, conn_destructor))) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to create connection cache\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    default_independent_stats = new_independent_stats();\n\n#ifndef __WIN32__\n    /*\n     * ignore SIGPIPE signals; we can use errno == EPIPE if we\n     * need that information\n     */\n    if (sigignore(SIGPIPE) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"failed to ignore SIGPIPE; sigaction\");\n        exit(EX_OSERR);\n    }\n#endif\n\n    /* start up worker threads if MT mode */\n    thread_init(settings.num_threads, main_base, dispatch_event_handler);\n\n    /* initialise clock event */\n    clock_handler(0, 0, 0);\n\n    /* create unix mode sockets after dropping privileges */\n    if (settings.socketpath != NULL) {\n        if (server_socket_unix(settings.socketpath,settings.access)) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"failed to listen on UNIX socket \\\"%s\\\": %s\",\n                                            settings.socketpath, strerror(errno));\n            exit(EX_OSERR);\n        }\n    }\n\n    /* create the listening socket, bind it, and init */\n    if (settings.socketpath == NULL) {\n        int udp_port;\n\n        const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");\n        char temp_portnumber_filename[PATH_MAX];\n        FILE *portnumber_file = NULL;\n\n        if (portnumber_filename != NULL) {\n            snprintf(temp_portnumber_filename,\n                     sizeof(temp_portnumber_filename),\n                     \"%s.lck\", portnumber_filename);\n\n            portnumber_file = fopen(temp_portnumber_filename, \"a\");\n            if (portnumber_file == NULL) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Failed to open \\\"%s\\\": %s\\n\",\n                        temp_portnumber_filename, strerror(errno));\n            }\n        }\n\n        if (settings.port && server_sockets(settings.port, tcp_transport,\n                                            portnumber_file)) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"failed to listen on TCP port %d: %s\",\n                                            settings.port, strerror(errno));\n            exit(EX_OSERR);\n        }\n\n        /*\n         * initialization order: first create the listening sockets\n         * (may need root on low ports), then drop root if needed,\n         * then daemonise if needed, then init libevent (in some cases\n         * descriptors created by libevent wouldn't survive forking).\n         */\n        udp_port = settings.udpport ? settings.udpport : settings.port;\n\n        /* create the UDP listening socket and bind it */\n        if (settings.udpport && server_sockets(udp_port, udp_transport,\n                                               portnumber_file)) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"failed to listen on UDP port %d: %s\",\n                                            settings.port, strerror(errno));\n            exit(EX_OSERR);\n        }\n\n        if (portnumber_file) {\n            fclose(portnumber_file);\n            rename(temp_portnumber_filename, portnumber_filename);\n        }\n    }\n\n    if (pid_file != NULL) {\n        save_pid(pid_file);\n    }\n\n    /* Drop privileges no longer needed */\n    drop_privileges();\n\n    if (!memcached_shutdown) {\n        /* enter the event loop */\n        event_base_loop(main_base, 0);\n    }\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, NULL,\n                                        \"Initiating shutdown\\n\");\n    }\n    threads_shutdown();\n\n    settings.engine.v1->destroy(settings.engine.v0, false);\n\n    /* remove the PID file if we're a daemon */\n    if (do_daemonize)\n        remove_pidfile(pid_file);\n    /* Clean up strdup() call for bind() address */\n    if (settings.inter)\n      free(settings.inter);\n\n    return EXIT_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/memcache/extra/memcached/utilities/engine_loader.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include \"config.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include \"utilities/engine_loader.h\"\n#include <memcached/types.h>\n\nstatic const char * const feature_descriptions[] = {\n    \"compare and swap\",\n    \"persistent storage\",\n    \"secondary engine\",\n    \"access control\",\n    \"multi tenancy\",\n    \"LRU\"\n};\n\nvoid *handle = NULL;\n\nbool load_engine(const char *soname,\n                 SERVER_HANDLE_V1 *(*get_server_api)(void),\n                 EXTENSION_LOGGER_DESCRIPTOR *logger,\n                 ENGINE_HANDLE **engine_handle)\n{\n    ENGINE_HANDLE *engine = NULL;\n    /* Hack to remove the warning from C99 */\n    union my_hack {\n        CREATE_INSTANCE create;\n        void* voidptr;\n    } my_create = {.create = NULL };\n\n    handle = dlopen(soname, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to open library \\\"%s\\\": %s\\n\",\n                soname ? soname : \"self\",\n                msg ? msg : \"unknown error\");\n        return false;\n    }\n\n    void *symbol = dlsym(handle, \"create_instance\");\n    if (symbol == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not find symbol \\\"create_instance\\\" in %s: %s\\n\",\n                soname ? soname : \"self\",\n                dlerror());\n        return false;\n    }\n    my_create.voidptr = symbol;\n\n    /* request a instance with protocol version 1 */\n    ENGINE_ERROR_CODE error = (*my_create.create)(1, get_server_api, &engine);\n\n    if (error != ENGINE_SUCCESS || engine == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to create instance. Error code: %d\\n\", error);\n        dlclose(handle);\n        return false;\n    }\n    *engine_handle = engine;\n    return true;\n}\n\nbool init_engine(ENGINE_HANDLE * engine,\n                 const char *config_str,\n                 EXTENSION_LOGGER_DESCRIPTOR *logger)\n{\n    ENGINE_HANDLE_V1 *engine_v1 = NULL;\n\n    if (handle == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to initialize engine, engine must fist be loaded.\");\n        return false;\n    }\n\n    if (engine->interface == 1) {\n        engine_v1 = (ENGINE_HANDLE_V1*)engine;\n\n        // validate that the required engine interface is implemented:\n        if (engine_v1->get_info == NULL || engine_v1->initialize == NULL ||\n            engine_v1->destroy == NULL || engine_v1->allocate == NULL ||\n            engine_v1->remove == NULL || engine_v1->release == NULL ||\n            engine_v1->get == NULL || engine_v1->store == NULL ||\n            engine_v1->flush == NULL ||\n            engine_v1->get_stats == NULL || engine_v1->reset_stats == NULL ||\n            engine_v1->item_set_cas == NULL ||\n            engine_v1->get_item_info == NULL)\n        {\n            logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Failed to initialize engine; it does not implement the engine interface.\");\n            return false;\n        }\n\n        ENGINE_ERROR_CODE error = engine_v1->initialize(engine,config_str);\n        if (error != ENGINE_SUCCESS) {\n            engine_v1->destroy(engine, false);\n            logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Failed to initialize instance. Error code: %d\\n\",\n                    error);\n            dlclose(handle);\n            return false;\n        }\n    } else {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"Unsupported interface level\\n\");\n        dlclose(handle);\n        return false;\n    }\n    return true;\n}\n\nvoid log_engine_details(ENGINE_HANDLE * engine,\n                        EXTENSION_LOGGER_DESCRIPTOR *logger)\n{\n    ENGINE_HANDLE_V1 *engine_v1 = (ENGINE_HANDLE_V1*)engine;\n    const engine_info *info;\n    info = engine_v1->get_info(engine);\n    if (info) {\n        char message[4096];\n        ssize_t nw = snprintf(message, sizeof(message), \"Loaded engine: %s\\n\",\n                                        info->description ?\n                                        info->description : \"Unknown\");\n        if (nw == -1) {\n            return;\n        }\n        ssize_t offset = nw;\n        bool comma = false;\n\n        if (info->num_features > 0) {\n            nw = snprintf(message + offset, sizeof(message) - offset,\n                          \"Supplying the following features: \");\n            if (nw == -1) {\n                return;\n            }\n            offset += nw;\n            for (int ii = 0; ii < info->num_features; ++ii) {\n                if (info->features[ii].description != NULL) {\n                    nw = snprintf(message + offset, sizeof(message) - offset,\n                                  \"%s%s\", comma ? \", \" : \"\",\n                                  info->features[ii].description);\n                } else {\n                    if (info->features[ii].feature <= LAST_REGISTERED_ENGINE_FEATURE) {\n                        nw = snprintf(message + offset, sizeof(message) - offset,\n                                      \"%s%s\", comma ? \", \" : \"\",\n                                      feature_descriptions[info->features[ii].feature]);\n                    } else {\n                        nw = snprintf(message + offset, sizeof(message) - offset,\n                                      \"%sUnknown feature: %d\", comma ? \", \" : \"\",\n                                      info->features[ii].feature);\n                    }\n                }\n                comma = true;\n                if (nw == -1) {\n                    return;\n                }\n                offset += nw;\n            }\n        }\n        logger->log(EXTENSION_LOG_INFO, NULL, \"%s\\n\", message);\n    } else {\n        logger->log(EXTENSION_LOG_INFO, NULL,\n                                        \"Loaded engine: Unknown\\n\");\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/memcache/extra/memcached/programs/engine_testapp.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include \"config.h\"\n#include <assert.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <signal.h>\n#include <pthread.h>\n#include \"utilities/engine_loader.h\"\n#include <memcached/engine_testapp.h>\n#include <memcached/extension_loggers.h>\n#include <mock_server.h>\n\nstruct mock_engine {\n    ENGINE_HANDLE_V1 me;\n    ENGINE_HANDLE_V1 *the_engine;\n    TAP_ITERATOR iterator;\n};\n\n#ifndef WIN32\nstatic sig_atomic_t alarmed;\n\nstatic void alarm_handler(int sig) {\n    alarmed = 1;\n}\n#endif\n\nstatic inline struct mock_engine* get_handle(ENGINE_HANDLE* handle) {\n    return (struct mock_engine*)handle;\n}\n\nstatic tap_event_t mock_tap_iterator(ENGINE_HANDLE* handle,\n                                     const void *cookie, item **itm,\n                                     void **es, uint16_t *nes, uint8_t *ttl,\n                                     uint16_t *flags, uint32_t *seqno,\n                                     uint16_t *vbucket) {\n   struct mock_engine *me = get_handle(handle);\n   return me->iterator((ENGINE_HANDLE*)me->the_engine, cookie, itm, es, nes,\n                       ttl, flags, seqno, vbucket);\n}\n\nstatic const engine_info* mock_get_info(ENGINE_HANDLE* handle) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_info((ENGINE_HANDLE*)me->the_engine);\n}\n\nstatic ENGINE_ERROR_CODE mock_initialize(ENGINE_HANDLE* handle,\n                                         const char* config_str) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->initialize((ENGINE_HANDLE*)me->the_engine, config_str);\n}\n\nstatic void mock_destroy(ENGINE_HANDLE* handle, const bool force) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->destroy((ENGINE_HANDLE*)me->the_engine, force);\n}\n\nstatic ENGINE_ERROR_CODE mock_allocate(ENGINE_HANDLE* handle,\n                                       const void* cookie,\n                                       item **item,\n                                       const void* key,\n                                       const size_t nkey,\n                                       const size_t nbytes,\n                                       const int flags,\n                                       const rel_time_t exptime) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->allocate((ENGINE_HANDLE*)me->the_engine, c,\n                                           item, key, nkey,\n                                           nbytes, flags,\n                                           exptime)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_remove(ENGINE_HANDLE* handle,\n                                     const void* cookie,\n                                     const void* key,\n                                     const size_t nkey,\n                                     uint64_t cas,\n                                     uint16_t vbucket)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->remove((ENGINE_HANDLE*)me->the_engine, c, key,\n                                         nkey, cas, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_release(ENGINE_HANDLE* handle,\n                         const void *cookie,\n                         item* item) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->release((ENGINE_HANDLE*)me->the_engine, cookie, item);\n}\n\nstatic ENGINE_ERROR_CODE mock_get(ENGINE_HANDLE* handle,\n                                  const void* cookie,\n                                  item** item,\n                                  const void* key,\n                                  const int nkey,\n                                  uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->get((ENGINE_HANDLE*)me->the_engine, c, item,\n                                      key, nkey, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_get_stats(ENGINE_HANDLE* handle,\n                                        const void* cookie,\n                                        const char* stat_key,\n                                        int nkey,\n                                        ADD_STAT add_stat)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->get_stats((ENGINE_HANDLE*)me->the_engine, c, stat_key,\n                                            nkey, add_stat)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_store(ENGINE_HANDLE* handle,\n                                    const void *cookie,\n                                    item* item,\n                                    uint64_t *cas,\n                                    ENGINE_STORE_OPERATION operation,\n                                    uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->store((ENGINE_HANDLE*)me->the_engine, c, item, cas,\n                                        operation, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_arithmetic(ENGINE_HANDLE* handle,\n                                         const void* cookie,\n                                         const void* key,\n                                         const int nkey,\n                                         const bool increment,\n                                         const bool create,\n                                         const uint64_t delta,\n                                         const uint64_t initial,\n                                         const rel_time_t exptime,\n                                         uint64_t *cas,\n                                         uint64_t *result,\n                                         uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->arithmetic((ENGINE_HANDLE*)me->the_engine, c, key,\n                                             nkey, increment, create,\n                                             delta, initial, exptime,\n                                             cas, result, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_flush(ENGINE_HANDLE* handle,\n                                    const void* cookie, time_t when) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->flush((ENGINE_HANDLE*)me->the_engine, c, when)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_reset_stats(ENGINE_HANDLE* handle, const void *cookie) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->reset_stats((ENGINE_HANDLE*)me->the_engine, cookie);\n}\n\nstatic ENGINE_ERROR_CODE mock_unknown_command(ENGINE_HANDLE* handle,\n                                              const void* cookie,\n                                              protocol_binary_request_header *request,\n                                              ADD_RESPONSE response)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->unknown_command((ENGINE_HANDLE*)me->the_engine, c,\n                                                  request, response)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_item_set_cas(ENGINE_HANDLE *handle, const void *cookie,\n                              item* item, uint64_t val)\n{\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->item_set_cas((ENGINE_HANDLE*)me->the_engine, cookie, item, val);\n}\n\n\nstatic bool mock_get_item_info(ENGINE_HANDLE *handle, const void *cookie,\n                               const item* item, item_info *item_info)\n{\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_item_info((ENGINE_HANDLE*)me->the_engine,\n                                         cookie, item, item_info);\n}\n\nstatic void *mock_get_stats_struct(ENGINE_HANDLE* handle, const void* cookie)\n{\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_stats_struct((ENGINE_HANDLE*)me->the_engine, cookie);\n}\n\nstatic ENGINE_ERROR_CODE mock_aggregate_stats(ENGINE_HANDLE* handle,\n                                              const void* cookie,\n                                              void (*callback)(void*, void*),\n                                              void *vptr)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->aggregate_stats((ENGINE_HANDLE*)me->the_engine, c,\n                                                  callback, vptr)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_tap_notify(ENGINE_HANDLE* handle,\n                                        const void *cookie,\n                                        void *engine_specific,\n                                        uint16_t nengine,\n                                        uint8_t ttl,\n                                        uint16_t tap_flags,\n                                        tap_event_t tap_event,\n                                        uint32_t tap_seqno,\n                                        const void *key,\n                                        size_t nkey,\n                                        uint32_t flags,\n                                        uint32_t exptime,\n                                        uint64_t cas,\n                                        const void *data,\n                                        size_t ndata,\n                                         uint16_t vbucket) {\n\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->tap_notify((ENGINE_HANDLE*)me->the_engine, c,\n                                             engine_specific, nengine, ttl, tap_flags,\n                                             tap_event, tap_seqno, key, nkey, flags,\n                                             exptime, cas, data, ndata, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\n\nstatic TAP_ITERATOR mock_get_tap_iterator(ENGINE_HANDLE* handle, const void* cookie,\n                                           const void* client, size_t nclient,\n                                           uint32_t flags,\n                                           const void* userdata, size_t nuserdata) {\n    struct mock_engine *me = get_handle(handle);\n    me->iterator = me->the_engine->get_tap_iterator((ENGINE_HANDLE*)me->the_engine, cookie,\n                                                    client, nclient, flags, userdata, nuserdata);\n    return (me->iterator != NULL) ? mock_tap_iterator : NULL;\n}\n\nstatic size_t mock_errinfo(ENGINE_HANDLE *handle, const void* cookie,\n                           char *buffer, size_t buffsz) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->errinfo((ENGINE_HANDLE*)me->the_engine, cookie,\n                                   buffer, buffsz);\n}\n\n\nstruct mock_engine default_mock_engine = {\n    .me = {\n        .interface = {\n            .interface = 1\n        },\n        .get_info = mock_get_info,\n        .initialize = mock_initialize,\n        .destroy = mock_destroy,\n        .allocate = mock_allocate,\n        .remove = mock_remove,\n        .release = mock_release,\n        .get = mock_get,\n        .store = mock_store,\n        .arithmetic = mock_arithmetic,\n        .flush = mock_flush,\n        .get_stats = mock_get_stats,\n        .reset_stats = mock_reset_stats,\n        .get_stats_struct = mock_get_stats_struct,\n        .aggregate_stats = mock_aggregate_stats,\n        .unknown_command = mock_unknown_command,\n        .tap_notify = mock_tap_notify,\n        .get_tap_iterator = mock_get_tap_iterator,\n        .item_set_cas = mock_item_set_cas,\n        .get_item_info = mock_get_item_info,\n        .errinfo = mock_errinfo\n    }\n};\nstruct mock_engine mock_engine;\n\nEXTENSION_LOGGER_DESCRIPTOR *logger_descriptor = NULL;\nstatic ENGINE_HANDLE *handle = NULL;\nstatic ENGINE_HANDLE_V1 *handle_v1 = NULL;\n\nstatic void usage(void) {\n    printf(\"\\n\");\n    printf(\"engine_testapp -E <path_to_engine_lib> -T <path_to_testlib>\\n\");\n    printf(\"               [-e <engine_config>] [-h]\\n\");\n    printf(\"\\n\");\n    printf(\"-E <path_to_engine_lib>      Path to the engine library file. The\\n\");\n    printf(\"                             engine library file is a library file\\n\");\n    printf(\"                             (.so or .dll) that the contains the \\n\");\n    printf(\"                             implementation of the engine being\\n\");\n    printf(\"                             tested.\\n\");\n    printf(\"\\n\");\n    printf(\"-T <path_to_testlib>         Path to the test library file. The test\\n\");\n    printf(\"                             library file is a library file (.so or\\n\");\n    printf(\"                             .dll) that contains the set of tests\\n\");\n    printf(\"                             to be executed.\\n\");\n    printf(\"\\n\");\n    printf(\"-t <timeout>                 Maximum time to run a test.\\n\");\n    printf(\"-e <engine_config>           Engine configuration string passed to\\n\");\n    printf(\"                             the engine.\\n\");\n    printf(\"-q                           Only print errors.\");\n    printf(\"-.                           Print a . for each executed test.\");\n    printf(\"\\n\");\n    printf(\"-h                           Prints this usage text.\\n\");\n    printf(\"\\n\");\n}\n\nstatic int report_test(const char *name, enum test_result r, bool quiet) {\n    int rc = 0;\n    char *msg = NULL;\n    bool color_enabled = getenv(\"TESTAPP_ENABLE_COLOR\") != NULL;\n    int color = 0;\n    char color_str[8] = { 0 };\n    char *reset_color = \"\\033[m\";\n    switch(r) {\n    case SUCCESS:\n        msg=\"OK\";\n        color = 32;\n        break;\n    case SKIPPED:\n        msg=\"SKIPPED\";\n        color = 32;\n        break;\n    case FAIL:\n        color = 31;\n        msg=\"FAIL\";\n        rc = 1;\n        break;\n    case DIED:\n        color = 31;\n        msg = \"DIED\";\n        rc = 1;\n        break;\n    case TIMEOUT:\n        color = 31;\n        msg = \"TIMED OUT\";\n        rc = 1;\n        break;\n    case CORE:\n        color = 31;\n        msg = \"CORE DUMPED\";\n        rc = 1;\n        break;\n    case PENDING:\n        color = 33;\n        msg = \"PENDING\";\n        break;\n    }\n    assert(msg);\n    if (color_enabled) {\n        snprintf(color_str, sizeof(color_str), \"\\033[%dm\", color);\n    }\n    if (quiet) {\n        if (r != SUCCESS) {\n            printf(\"%s:  %s%s%s\\n\", name, color_str, msg,\n                   color_enabled ? reset_color : \"\");\n            fflush(stdout);\n        }\n    } else {\n        printf(\"%s%s%s\\n\", color_str, msg, color_enabled ? reset_color : \"\");\n    }\n    return rc;\n}\n\nstatic ENGINE_HANDLE_V1 *start_your_engines(const char *engine, const char* cfg, bool engine_init) {\n\n    init_mock_server(handle);\n    if (!load_engine(engine, &get_mock_server_api, logger_descriptor, &handle)) {\n        fprintf(stderr, \"Failed to load engine %s.\\n\", engine);\n        return NULL;\n    }\n\n    if (engine_init) {\n        if(!init_engine(handle, cfg, logger_descriptor)) {\n            fprintf(stderr, \"Failed to init engine %s with config %s.\\n\", engine, cfg);\n            return NULL;\n        }\n    }\n\n    mock_engine = default_mock_engine;\n    handle_v1 = mock_engine.the_engine = (ENGINE_HANDLE_V1*)handle;\n    handle = (ENGINE_HANDLE*)&mock_engine.me;\n    handle_v1 = &mock_engine.me;\n\n    // Reset all members that aren't set (to allow the users to write\n    // testcases to verify that they initialize them..\n    assert(mock_engine.me.interface.interface == mock_engine.the_engine->interface.interface);\n\n    if (mock_engine.the_engine->get_stats_struct == NULL) {\n        mock_engine.me.get_stats_struct = NULL;\n    }\n    if (mock_engine.the_engine->aggregate_stats == NULL) {\n        mock_engine.me.aggregate_stats = NULL;\n    }\n    if (mock_engine.the_engine->unknown_command == NULL) {\n        mock_engine.me.unknown_command = NULL;\n    }\n    if (mock_engine.the_engine->tap_notify == NULL) {\n        mock_engine.me.tap_notify = NULL;\n    }\n    if (mock_engine.the_engine->get_tap_iterator == NULL) {\n        mock_engine.me.get_tap_iterator = NULL;\n    }\n    if (mock_engine.the_engine->errinfo == NULL) {\n        mock_engine.me.errinfo = NULL;\n    }\n\n    return &mock_engine.me;\n}\n\nstatic void destroy_engine(bool force) {\n    if (handle_v1) {\n        handle_v1->destroy(handle, force);\n        handle_v1 = NULL;\n        handle = NULL;\n    }\n}\n\nstatic void reload_engine(ENGINE_HANDLE **h, ENGINE_HANDLE_V1 **h1,\n                          const char* engine, const char *cfg, bool init, bool force) {\n    destroy_engine(force);\n    handle_v1 = start_your_engines(engine, cfg, init);\n    handle = (ENGINE_HANDLE*)(handle_v1);\n    *h1 = handle_v1;\n    *h = handle;\n}\n\nstatic engine_test_t* current_testcase;\n\nstatic const engine_test_t* get_current_testcase(void)\n{\n    return current_testcase;\n}\n\n\nstatic enum test_result run_test(engine_test_t test, const char *engine, const char *default_cfg) {\n    enum test_result ret = PENDING;\n    if (test.tfun != NULL) {\n#if !defined(USE_GCOV) && !defined(WIN32)\n        pid_t pid = fork();\n        if (pid == 0) {\n#endif\n            current_testcase = &test;\n            if (test.prepare != NULL) {\n                if ((ret = test.prepare(&test)) == SUCCESS) {\n                    ret = PENDING;\n                }\n            }\n\n            if (ret == PENDING) {\n                /* Start the engines and go */\n                start_your_engines(engine, test.cfg ? test.cfg : default_cfg, true);\n                if (test.test_setup != NULL) {\n                    if (!test.test_setup(handle, handle_v1)) {\n                        fprintf(stderr, \"Failed to run setup for test %s\\n\", test.name);\n#if !defined(USE_GCOV) && !defined(WIN32)\n                        exit((int)ret);\n#else\n                        return FAIL;\n#endif\n                    }\n                }\n                ret = test.tfun(handle, handle_v1);\n                if (test.test_teardown != NULL) {\n                    if (!test.test_teardown(handle, handle_v1)) {\n                        fprintf(stderr, \"WARNING: Failed to run teardown for test %s\\n\", test.name);\n                    }\n                }\n                destroy_engine(false);\n\n                if (test.cleanup) {\n                    test.cleanup(&test, ret);\n                }\n            }\n#if !defined(USE_GCOV) && !defined(WIN32)\n            exit((int)ret);\n        } else if (pid == (pid_t)-1) {\n            ret = FAIL;\n        } else {\n            int rc;\n            while (alarmed == 0 && waitpid(pid, &rc, 0) == (pid_t)-1) {\n                if (errno != EINTR) {\n                    abort();\n                }\n            }\n\n            if (alarmed) {\n                kill(pid, 9);\n                ret = TIMEOUT;\n            } else if (WIFEXITED(rc)) {\n                ret = (enum test_result)WEXITSTATUS(rc);\n            } else if (WIFSIGNALED(rc) && WCOREDUMP(rc)) {\n                ret = CORE;\n            } else {\n                ret = DIED;\n            }\n        }\n#endif\n    }\n\n    return ret;\n}\n\nstatic void setup_alarm_handler() {\n#ifndef WIN32\n    struct sigaction sig_handler;\n\n    sig_handler.sa_handler = alarm_handler;\n    sig_handler.sa_flags = 0;\n\n    sigaction(SIGALRM, &sig_handler, NULL);\n#endif\n}\n\nstatic void set_test_timeout(int timeout) {\n#ifndef WIN32\n    alarm(timeout);\n#endif\n}\n\nstatic void clear_test_timeout() {\n#ifndef WIN32\n    alarm(0);\n    alarmed = 0;\n#endif\n}\n\nint main(int argc, char **argv) {\n    int c, exitcode = 0, num_cases = 0, timeout = 0;\n    bool quiet = false;\n    bool dot = false;\n    const char *engine = NULL;\n    const char *engine_args = NULL;\n    const char *test_suite = NULL;\n    const char *test_case = NULL;\n    engine_test_t *testcases = NULL;\n    logger_descriptor = get_null_logger();\n\n    /* Hack to remove the warning from C99 */\n    union {\n        GET_TESTS get_tests;\n        void* voidptr;\n    } my_get_test = {.get_tests = NULL };\n\n    /* Hack to remove the warning from C99 */\n    union {\n        SETUP_SUITE setup_suite;\n        void* voidptr;\n    } my_setup_suite = {.setup_suite = NULL };\n\n    /* Hack to remove the warning from C99 */\n    union {\n        TEARDOWN_SUITE teardown_suite;\n        void* voidptr;\n    } my_teardown_suite = {.teardown_suite = NULL };\n\n\n    /* Use unbuffered stdio */\n    setbuf(stdout, NULL);\n    setbuf(stderr, NULL);\n\n    setup_alarm_handler();\n\n    /* process arguments */\n    while (-1 != (c = getopt(argc, argv,\n          \"h\"  /* usage */\n          \"E:\" /* Engine to load */\n          \"e:\" /* Engine options */\n          \"T:\" /* Library with tests to load */\n          \"t:\" /* Timeout */\n          \"q\"  /* Be more quiet (only report failures) */\n          \".\"  /* dot mode. */\n          \"n:\"  /* test case to run */\n        ))) {\n        switch (c) {\n        case 'E':\n            engine = optarg;\n            break;\n        case 'e':\n            engine_args = optarg;\n            break;\n        case 'h':\n            usage();\n            return 0;\n        case 'T':\n            test_suite = optarg;\n            break;\n        case 't':\n            timeout = atoi(optarg);\n            break;\n        case 'n':\n            test_case = optarg;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case '.':\n            dot = true;\n            break;\n        default:\n            fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n\n    //validate args\n    if (engine == NULL) {\n        fprintf(stderr, \"You must provide a path to the storage engine library.\\n\");\n        return 1;\n    }\n\n    if (test_suite == NULL) {\n        fprintf(stderr, \"You must provide a path to the testsuite library.\\n\");\n        return 1;\n    }\n\n    //load test_suite\n    void* handle = dlopen(test_suite, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        fprintf(stderr, \"Failed to load testsuite %s: %s\\n\", test_suite, msg ? msg : \"unknown error\");\n        return 1;\n    }\n\n    //get the test cases\n    void *symbol = dlsym(handle, \"get_tests\");\n    if (symbol == NULL) {\n        const char *msg = dlerror();\n        fprintf(stderr, \"Could not find get_tests function in testsuite %s: %s\\n\", test_suite, msg ? msg : \"unknown error\");\n        return 1;\n    }\n    my_get_test.voidptr = symbol;\n    testcases = (*my_get_test.get_tests)();\n\n    //set up the suite if needed\n    struct test_harness harness = { .default_engine_cfg = engine_args,\n                                    .engine_path = engine,\n                                    .reload_engine = reload_engine,\n                                    .start_engine = start_your_engines,\n                                    .create_cookie = create_mock_cookie,\n                                    .destroy_cookie = destroy_mock_cookie,\n                                    .set_ewouldblock_handling = mock_set_ewouldblock_handling,\n                                    .lock_cookie = lock_mock_cookie,\n                                    .unlock_cookie = unlock_mock_cookie,\n                                    .waitfor_cookie = waitfor_mock_cookie,\n                                    .time_travel = mock_time_travel,\n                                    .get_current_testcase = get_current_testcase };\n    symbol = dlsym(handle, \"setup_suite\");\n    if (symbol != NULL) {\n        my_setup_suite.voidptr = symbol;\n        if (!(*my_setup_suite.setup_suite)(&harness)) {\n            fprintf(stderr, \"Failed to set up test suite %s \\n\", test_suite);\n            return 1;\n        }\n    }\n\n\n    for (num_cases = 0; testcases[num_cases].name; num_cases++) {\n        /* Just counting */\n    }\n\n    if (!quiet) {\n        printf(\"1..%d\\n\", num_cases);\n    }\n\n    int i;\n    bool need_newline = false;\n    for (i = 0; testcases[i].name; i++) {\n        if (test_case != NULL && strcmp(test_case, testcases[i].name) != 0)\n            continue;\n        if (!quiet) {\n            printf(\"Running %s... \", testcases[i].name);\n            fflush(stdout);\n        } else if(dot) {\n            printf(\".\");\n            need_newline = true;\n            /* Add a newline every few tests */\n            if ((i+1) % 70 == 0) {\n                printf(\"\\n\");\n                need_newline = false;\n            }\n        }\n        set_test_timeout(timeout);\n        exitcode += report_test(testcases[i].name,\n                                run_test(testcases[i], engine, engine_args),\n                                quiet);\n        clear_test_timeout();\n    }\n\n    if (need_newline) {\n        printf(\"\\n\");\n    }\n\n    //tear down the suite if needed\n    symbol = dlsym(handle, \"teardown_suite\");\n    if (symbol != NULL) {\n        my_teardown_suite.voidptr = symbol;\n        if (!(*my_teardown_suite.teardown_suite)()) {\n            fprintf(stderr, \"Failed to teardown up test suite %s \\n\", test_suite);\n        }\n    }\n\n    printf(\"# Passed %d of %d tests\\n\", num_cases - exitcode, num_cases);\n\n    return exitcode;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/memcache/extra/memcached/win32/dlfcn.h": "#ifndef DLFCN_H\n#define DLFCN_H\nvoid* dlopen(const char* path, int mode);\nvoid* dlsym(void* handle, const char* symbol);\nint dlclose(void* handle);\nconst char *dlerror(void);\n\n#define RTLD_LAZY 1\n#define RTLD_LOCAL 2\n\n#define RTLD_NOW 0x00002\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/memcache/extra/memcached/win32/dlfcn.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include <stdio.h>\n#include <windows.h>\n#include <dlfcn.h>\n#include <stdbool.h>\n\n/*\n * Keep track if the user tried to call dlopen(NULL, xx) to be able to give a sane\n * error message\n */\nstatic bool self = false;\n\nvoid* dlopen(const char* path, int mode) {\n    if (path == NULL) {\n        // We don't support opening ourself\n        self = true;\n        return NULL;\n    }\n\n    void* handle = LoadLibrary(path);\n    if (handle == NULL) {\n        char *buf = malloc(strlen(path) + 20);\n        sprintf(buf, \"%s.dll\", path);\n        handle = LoadLibrary(buf);\n        free(buf);\n    }\n\n    return handle;\n}\n\nvoid* dlsym(void* handle, const char* symbol) {\n    return GetProcAddress(handle, symbol);\n}\n\nint dlclose(void* handle) {\n    // dlclose returns zero on success.\n    // FreeLibrary returns nonzero on success.\n    return FreeLibrary(handle) != 0;\n}\n\nstatic char dlerror_buf[200];\n\nconst char *dlerror(void) {\n    if (self) {\n        return \"not supported\";\n    }\n\n    DWORD err = GetLastError();\n    LPVOID error_msg;\n    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                      FORMAT_MESSAGE_FROM_SYSTEM |\n                      FORMAT_MESSAGE_IGNORE_INSERTS,\n                      NULL, err, 0, (LPTSTR)&error_msg, 0, NULL) != 0) {\n        strncpy(dlerror_buf, error_msg, sizeof(dlerror_buf));\n        dlerror_buf[sizeof(dlerror_buf) - 1] = '\\0';\n        LocalFree(error_msg);\n    } else {\n        return \"Failed to get error message\";\n    }\n\n    return dlerror_buf;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/router/src/plugin_info/src/library_file.cc": "/*\n  Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License, version 2.0,\n  as published by the Free Software Foundation.\n\n  This program is also distributed with certain software (including\n  but not limited to OpenSSL) that is licensed under separate terms,\n  as designated in a particular file or component or in included license\n  documentation.  The authors of MySQL hereby grant you an additional\n  permission to link the program and your derivative works with the\n  separately licensed software that they have included with MySQL.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include \"library_file.h\"\n\n#include <stdexcept>\n\n#ifndef _WIN32\n#include <dlfcn.h>\n#include <unistd.h>\n#else\n#include <Windows.h>\n#include \"mysql/harness/filesystem.h\"\n#endif\n\n#define USE_DLCLOSE 1\n\n// disable dlclose() when built with lsan\n//\n// clang has __has_feature(address_sanitizer)\n// gcc has __SANITIZE_ADDRESS__\n#if defined(__has_feature)\n#if __has_feature(address_sanitizer)\n#undef USE_DLCLOSE\n#define USE_DLCLOSE 0\n#endif\n#endif\n\n#if defined(__SANITIZE_ADDRESS__) && __SANITIZE_ADDRESS__ == 1\n#undef USE_DLCLOSE\n#define USE_DLCLOSE 0\n#endif\n\nstruct Library_file::Library_file_impl {\n#ifndef _WIN32\n  void *handle;\n#else\n  HMODULE handle;\n#endif\n};\n\n#ifdef _WIN32\nnamespace {\nvoid throw_current_error(const std::string &prefix) {\n  char buffer[512];\n  FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_MAX_WIDTH_MASK,\n                nullptr, GetLastError(), LANG_NEUTRAL, buffer, sizeof(buffer),\n                nullptr);\n  throw std::runtime_error(prefix + buffer);\n}\n}  // namespace\n#endif\n\nLibrary_file::Library_file(const std::string &file_name,\n                           const std::string &plugin_name)\n    : impl_(new Library_file_impl()),\n      plugin_name_(plugin_name),\n      file_name_(file_name) {\n#ifndef _WIN32\n  impl_->handle = dlopen(file_name.c_str(), RTLD_LOCAL | RTLD_LAZY);\n  if (impl_->handle == nullptr) {\n    throw std::runtime_error(\"Could not load plugin file: \" + file_name +\n                             \". Error: \" + dlerror());\n  }\n#else\n  mysql_harness::Path lib_file(file_name);\n  // we need to do this so all the dlls that plugin library needs could be found\n  auto res = SetCurrentDirectory(lib_file.dirname().c_str());\n  if (!res) {\n    throw_current_error(\"Could not switch directory to \" +\n                        lib_file.dirname().str() + \": \");\n  }\n  impl_->handle = LoadLibrary(lib_file.real_path().c_str());\n  if (impl_->handle == nullptr) {\n    throw_current_error(\"Could not load plugin file: \" + file_name + \". \");\n  }\n#endif\n}\n\nuint32_t Library_file::get_abi_version() const {\n  Plugin_abi *plugin = get_plugin_struct<Plugin_abi>(plugin_name_);\n\n  return plugin->abi_version;\n}\n\ntemplate <class T>\nT *Library_file::get_plugin_struct(const std::string &symbol) const {\n  // In the older MySQLRouter releases some plugins did not use harness_plugin_\n  // prefix for the plugin structure name. So we check harness_plugin_xxx and\n  // then xxx if the first check failed.\n\n  T *result{nullptr};\n  try {\n    result = get_plugin_struct_internal<T>(\"harness_plugin_\" + symbol);\n  } catch (const std::runtime_error &) {\n    result = get_plugin_struct_internal<T>(plugin_name_);\n  }\n\n  return result;\n}\n\ntemplate <class T>\nT *Library_file::get_plugin_struct_internal(const std::string &symbol) const {\n  T *result{nullptr};\n\n#ifndef _WIN32\n  result = reinterpret_cast<T *>(dlsym(impl_->handle, symbol.c_str()));\n  const char *error = dlerror();\n  if (error) {\n    throw std::runtime_error(\"Loading plugin information for '\" + file_name_ +\n                             \"' failed: \" + error);\n  }\n#else\n  SetLastError(0);\n  result = reinterpret_cast<T *>(GetProcAddress(impl_->handle, symbol.c_str()));\n  DWORD error = GetLastError();\n  if (error) {\n    throw_current_error(\"Loading plugin information for '\" + file_name_ +\n                        \"' failed: \");\n  }\n#endif\n\n  return result;\n}\n\ntemplate Plugin_abi *Library_file::get_plugin_struct<Plugin_abi>(\n    const std::string &) const;\ntemplate Plugin_v1 *Library_file::get_plugin_struct<Plugin_v1>(\n    const std::string &) const;\ntemplate Plugin_abi *Library_file::get_plugin_struct_internal<Plugin_abi>(\n    const std::string &) const;\ntemplate Plugin_v1 *Library_file::get_plugin_struct_internal<Plugin_v1>(\n    const std::string &) const;\n\nLibrary_file::~Library_file() {\n// disable dlclose() if run with address sanitizer to get good memleak reports\n#if USE_DLCLOSE\n#ifndef _WIN32\n  if (impl_->handle) dlclose(impl_->handle);\n#else\n  if (impl_->handle) {\n    FreeLibrary(impl_->handle);\n  }\n#endif\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/router/src/harness/src/loader-posix.cc": "/*\n  Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License, version 2.0,\n  as published by the Free Software Foundation.\n\n  This program is also distributed with certain software (including\n  but not limited to OpenSSL) that is licensed under separate terms,\n  as designated in a particular file or component or in included license\n  documentation.  The authors of MySQL hereby grant you an additional\n  permission to link the program and your derivative works with the\n  separately licensed software that they have included with MySQL.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include \"mysql/harness/loader.h\"\n\n#include \"mysql/harness/filesystem.h\"\n\n#include \"exception.h\"\n\n#include <dlfcn.h>\n#include <unistd.h>\n\n#include <cassert>\n#include <sstream>\n\n#define USE_DLCLOSE 1\n\n// disable dlclose() when built with lsan\n//\n// clang has __has_feature(address_sanitizer)\n// gcc has __SANITIZE_ADDRESS__\n#if defined(__has_feature)\n#if __has_feature(address_sanitizer)\n#undef USE_DLCLOSE\n#define USE_DLCLOSE 0\n#endif\n#endif\n\n#if defined(__SANITIZE_ADDRESS__) && __SANITIZE_ADDRESS__ == 1\n#undef USE_DLCLOSE\n#define USE_DLCLOSE 0\n#endif\n\nnamespace mysql_harness {\n\n////////////////////////////////////////////////////////////////\n// class Loader\n\nvoid Loader::platform_specific_init() {}\n\n////////////////////////////////////////////////////////////////\n// class Loader::PluginInfo::Impl\n\nclass Loader::PluginInfo::Impl {\n public:\n  // throws bad_plugin\n  Impl(const std::string &plugin_folder, const std::string &library_name);\n\n  ~Impl();\n\n  Path path;\n  void *handle;\n};\n\nLoader::PluginInfo::Impl::Impl(const std::string &plugin_folder,\n                               const std::string &library_name)\n    : path(Path::make_path(plugin_folder, library_name, \"so\")),\n      handle(dlopen(path.c_str(), RTLD_LOCAL | RTLD_NOW)) {\n  if (handle == nullptr) throw bad_plugin(dlerror());\n}\n\nLoader::PluginInfo::Impl::~Impl() {\n#if USE_DLCLOSE\n  dlclose(handle);\n#endif\n}\n\n////////////////////////////////////////////////////////////////\n// class Loader::PluginInfo\n\nLoader::PluginInfo::~PluginInfo() { delete impl_; }\n\nLoader::PluginInfo::PluginInfo(PluginInfo &&p) {\n  if (&p != this) {\n    this->impl_ = p.impl_;\n    p.impl_ = NULL;\n    this->plugin = p.plugin;\n    p.plugin = NULL;\n    this->handle = p.handle;\n    p.handle = NULL;\n  }\n}\n\nLoader::PluginInfo::PluginInfo(const std::string &plugin_folder,\n                               const std::string &library_name)\n    : impl_(new Impl(plugin_folder, library_name)) {}\n\nvoid Loader::PluginInfo::load_plugin(const std::string &name) {\n  assert(impl_->handle);\n\n  dlerror();  // clear any previous errors\n\n  std::string symbol = \"harness_plugin_\" + name;\n  Plugin *p = reinterpret_cast<Plugin *>(dlsym(impl_->handle, symbol.c_str()));\n\n  const char *error = dlerror();\n  if (error) {\n    std::ostringstream buffer;\n    buffer << \"Loading plugin '\" << name << \"' failed: \" << error;\n    throw bad_plugin(buffer.str());\n  }\n\n  this->plugin = p;\n}\n\n}  // namespace mysql_harness\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/include/my_sharedlib.h": "/*\n   Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License, version 2.0,\n   as published by the Free Software Foundation.\n\n   This program is also distributed with certain software (including\n   but not limited to OpenSSL) that is licensed under separate terms,\n   as designated in a particular file or component or in included license\n   documentation.  The authors of MySQL hereby grant you an additional\n   permission to link the program and your derivative works with the\n   separately licensed software that they have included with MySQL.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License, version 2.0, for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n#ifndef MY_SHAREDLIB_INCLUDED\n#define MY_SHAREDLIB_INCLUDED\n\n/**\n  @file include/my_sharedlib.h\n  Functions related to handling of plugins and other dynamically loaded\n  libraries.\n*/\n\n#if defined(_WIN32)\n#define dlsym(lib, name) (void *)GetProcAddress((HMODULE)lib, name)\n#define dlopen(libname, unused) LoadLibraryEx(libname, NULL, 0)\n#define dlclose(lib) FreeLibrary((HMODULE)lib)\n#define DLERROR_GENERATE(errmsg, error_number)                          \\\n  char win_errormsg[2048];                                              \\\n  if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, error_number, 0,     \\\n                    win_errormsg, 2048, NULL)) {                        \\\n    char *ptr;                                                          \\\n    for (ptr = &win_errormsg[0] + strlen(win_errormsg) - 1;             \\\n         ptr >= &win_errormsg[0] && strchr(\"\\r\\n\\t\\0x20\", *ptr); ptr--) \\\n      *ptr = 0;                                                         \\\n    errmsg = win_errormsg;                                              \\\n  } else                                                                \\\n    errmsg = \"\"\n#define dlerror() \"\"\n#define dlopen_errno GetLastError()\n\n#else /* _WIN32 */\n\n#ifndef MYSQL_ABI_CHECK\n#include <dlfcn.h>\n#include <errno.h>\n#endif\n\n#define DLERROR_GENERATE(errmsg, error_number) errmsg = dlerror()\n#define dlopen_errno errno\n#endif /* _WIN32 */\n\n/*\n  MYSQL_PLUGIN_IMPORT macro is used to export mysqld data\n  (i.e variables) for usage in storage engine loadable plugins.\n  Outside of Windows, it is dummy.\n*/\n#if (defined(_WIN32) && defined(MYSQL_DYNAMIC_PLUGIN))\n#define MYSQL_PLUGIN_IMPORT __declspec(dllimport)\n#else\n#define MYSQL_PLUGIN_IMPORT\n#endif\n\n#endif  // MY_SHAREDLIB_INCLUDED\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/plugin/auth/dialog.cc": "/*  Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License, version 2.0,\n    as published by the Free Software Foundation.\n\n    This program is also distributed with certain software (including\n    but not limited to OpenSSL) that is licensed under separate terms,\n    as designated in a particular file or component or in included license\n    documentation.  The authors of MySQL hereby grant you an additional\n    permission to link the program and your derivative works with the\n    separately licensed software that they have included with MySQL.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License, version 2.0, for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/**\n  @file\n\n  dialog client authentication plugin with examples\n\n  dialog is a general purpose client authentication plugin, it simply\n  asks the user the question, as provided by the server and reports\n  the answer back to the server. No encryption is involved,\n  the answers are sent in clear text.\n\n  Two examples are provided: two_questions server plugin, that asks\n  the password and an \"Are you sure?\" question with a reply \"yes, of course\".\n  It demonstrates the usage of \"password\" (input is hidden) and \"ordinary\"\n  (input can be echoed) questions, and how to mark the last question,\n  to avoid an extra roundtrip.\n\n  And three_attempts plugin that gives the user three attempts to enter\n  a correct password. It shows the situation when a number of questions\n  is not known in advance.\n*/\n#include \"my_config.h\"\n\n#if defined(WIN32) && !defined(RTLD_DEFAULT)\n#define RTLD_DEFAULT GetModuleHandle(NULL)\n#endif\n\n#include <mysql.h>\n#include <mysql/client_plugin.h>\n#include <mysql/plugin_auth.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"my_compiler.h\"\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#if !defined(_GNU_SOURCE)\n#define _GNU_SOURCE /* for RTLD_DEFAULT */\n#endif\n\n/**\n  first byte of the question string is the question \"type\".\n  It can be an \"ordinary\" or a \"password\" question.\n  The last bit set marks a last question in the authentication exchange.\n*/\n#define ORDINARY_QUESTION \"\\2\"\n#define LAST_QUESTION \"\\3\"\n#define PASSWORD_QUESTION \"\\4\"\n#define LAST_PASSWORD \"\\5\"\n\n/********************* SERVER SIDE ****************************************/\n\n/**\n  dialog demo with two questions, one password and one, the last, ordinary.\n*/\nstatic int two_questions(MYSQL_PLUGIN_VIO *vio, MYSQL_SERVER_AUTH_INFO *info) {\n  unsigned char *pkt;\n  int pkt_len;\n\n  /* send a password question */\n  if (vio->write_packet(\n          vio,\n          (const unsigned char *)PASSWORD_QUESTION \"Password, please:\", 18))\n    return CR_ERROR;\n\n  /* read the answer */\n  if ((pkt_len = vio->read_packet(vio, &pkt)) < 0) return CR_ERROR;\n\n  info->password_used = PASSWORD_USED_YES;\n\n  /* fail if the password is wrong */\n  if (strcmp((const char *)pkt, info->auth_string)) return CR_ERROR;\n\n  /* send the last, ordinary, question */\n  if (vio->write_packet(\n          vio, (const unsigned char *)LAST_QUESTION \"Are you sure ?\", 15))\n    return CR_ERROR;\n\n  /* read the answer */\n  if ((pkt_len = vio->read_packet(vio, &pkt)) < 0) return CR_ERROR;\n\n  /* check the reply */\n  return strcmp((const char *)pkt, \"yes, of course\") ? CR_ERROR : CR_OK;\n}\n\nstatic int generate_auth_string_hash(char *outbuf, unsigned int *buflen,\n                                     const char *inbuf, unsigned int inbuflen) {\n  /*\n    if buffer specified by server is smaller than the buffer given\n    by plugin then return error\n  */\n  if (*buflen < inbuflen) return 1;\n  strncpy(outbuf, inbuf, inbuflen);\n  *buflen = strlen(inbuf);\n  return 0;\n}\n\nstatic int validate_auth_string_hash(char *const inbuf MY_ATTRIBUTE((unused)),\n                                     unsigned int buflen\n                                         MY_ATTRIBUTE((unused))) {\n  return 0;\n}\n\nstatic int set_salt(const char *password MY_ATTRIBUTE((unused)),\n                    unsigned int password_len MY_ATTRIBUTE((unused)),\n                    unsigned char *salt MY_ATTRIBUTE((unused)),\n                    unsigned char *salt_len) {\n  *salt_len = 0;\n  return 0;\n}\n\nstatic struct st_mysql_auth two_handler = {\n    MYSQL_AUTHENTICATION_INTERFACE_VERSION,\n    \"dialog\", /* requires dialog client plugin */\n    two_questions,\n    generate_auth_string_hash,\n    validate_auth_string_hash,\n    set_salt,\n    AUTH_FLAG_PRIVILEGED_USER_FOR_PASSWORD_CHANGE,\n    NULL};\n\n/* dialog demo where the number of questions is not known in advance */\nstatic int three_attempts(MYSQL_PLUGIN_VIO *vio, MYSQL_SERVER_AUTH_INFO *info) {\n  unsigned char *pkt;\n  int pkt_len, i;\n\n  for (i = 0; i < 3; i++) {\n    /* send the prompt */\n    if (vio->write_packet(\n            vio,\n            (const unsigned char *)PASSWORD_QUESTION \"Password, please:\", 18))\n      return CR_ERROR;\n\n    /* read the password */\n    if ((pkt_len = vio->read_packet(vio, &pkt)) < 0) return CR_ERROR;\n\n    info->password_used = PASSWORD_USED_YES;\n\n    /*\n      finish, if the password is correct.\n      note, that we did not mark the prompt packet as \"last\"\n    */\n    if (strcmp((const char *)pkt, info->auth_string) == 0) return CR_OK;\n  }\n\n  return CR_ERROR;\n}\n\nstatic struct st_mysql_auth three_handler = {\n    MYSQL_AUTHENTICATION_INTERFACE_VERSION,\n    \"dialog\", /* requires dialog client plugin */\n    three_attempts,\n    generate_auth_string_hash,\n    validate_auth_string_hash,\n    set_salt,\n    AUTH_FLAG_PRIVILEGED_USER_FOR_PASSWORD_CHANGE,\n    NULL};\n\nmysql_declare_plugin(dialog){\n    MYSQL_AUTHENTICATION_PLUGIN,\n    &two_handler,\n    \"two_questions\",\n    \"Sergei Golubchik\",\n    \"Dialog plugin demo 1\",\n    PLUGIN_LICENSE_GPL,\n    NULL, /* Init */\n    NULL, /* Check uninstall */\n    NULL, /* Deinit */\n    0x0101,\n    NULL,\n    NULL,\n    NULL,\n    0,\n},\n    {\n        MYSQL_AUTHENTICATION_PLUGIN,\n        &three_handler,\n        \"three_attempts\",\n        \"Sergei Golubchik\",\n        \"Dialog plugin demo 2\",\n        PLUGIN_LICENSE_GPL,\n        NULL, /* Init */\n        NULL, /* Check uninstall */\n        NULL, /* Deinit */\n        0x0101,\n        NULL,\n        NULL,\n        NULL,\n        0,\n    } mysql_declare_plugin_end;\n\n/********************* CLIENT SIDE ***************************************/\n/*\n  This plugin performs a dialog with the user, asking questions and\n  reading answers. Depending on the client it may be desirable to do it\n  using GUI, or console, with or without curses, or read answers\n  from a smartcard, for example.\n\n  To support all this variety, the dialog plugin has a callback function\n  \"authentication_dialog_ask\". If the client has a function of this name\n  dialog plugin will use it for communication with the user. Otherwise\n  a default fgets() based implementation will be used.\n*/\n\n/**\n  type of the mysql_authentication_dialog_ask function\n\n  @param mysql          mysql\n  @param type           type of the input\n                        1 - ordinary string input\n                        2 - password string\n  @param prompt         prompt\n  @param buf            a buffer to store the use input\n  @param buf_len        the length of the buffer\n\n  @retval               a pointer to the user input string.\n                        It may be equal to 'buf' or to 'mysql->password'.\n                        In all other cases it is assumed to be an allocated\n                        string, and the \"dialog\" plugin will free() it.\n*/\ntypedef char *(*mysql_authentication_dialog_ask_t)(MYSQL *mysql, int type,\n                                                   const char *prompt,\n                                                   char *buf, int buf_len);\n\nstatic mysql_authentication_dialog_ask_t ask;\n\nstatic char *builtin_ask(MYSQL *mysql MY_ATTRIBUTE((unused)),\n                         int type MY_ATTRIBUTE((unused)), const char *prompt,\n                         char *buf, int buf_len) {\n  char *ptr;\n  fputs(prompt, stdout);\n  fputc(' ', stdout);\n  if (fgets(buf, buf_len, stdin) == NULL) return NULL;\n  if ((ptr = strchr(buf, '\\n'))) *ptr = 0;\n\n  return buf;\n}\n\n/**\n  The main function of the dialog plugin.\n\n  Read the prompt, ask the question, send the reply, repeat until\n  the server is satisfied.\n\n  @note\n   1. this plugin shows how a client authentication plugin\n      may read a MySQL protocol OK packet internally - which is important\n      where a number of packets is not known in advance.\n   2. the first byte of the prompt is special. it is not\n      shown to the user, but signals whether it is the last question\n      (prompt[0] & 1 == 1) or not last (prompt[0] & 1 == 0),\n      and whether the input is a password (not echoed).\n   3. the prompt is expected to be sent zero-terminated\n*/\nstatic int perform_dialog(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql) {\n  unsigned char *pkt, cmd = 0;\n  int pkt_len, res;\n  char reply_buf[1024], *reply;\n\n  do {\n    /* read the prompt */\n    pkt_len = vio->read_packet(vio, &pkt);\n    if (pkt_len < 0) return CR_ERROR;\n\n    if (pkt == 0) {\n      /*\n        in mysql_change_user() the client sends the first packet, so\n        the first vio->read_packet() does nothing (pkt == 0).\n\n        We send the \"password\", assuming the client knows what it's doing.\n        (in other words, the dialog plugin should be only set as a default\n        authentication plugin on the client if the first question\n        asks for a password - which will be sent in clear text, by the way)\n      */\n      reply = mysql->passwd;\n    } else {\n      cmd = *pkt++;\n\n      /* is it MySQL protocol packet ? */\n      if (cmd == 0 || cmd == 254)\n        return CR_OK_HANDSHAKE_COMPLETE; /* yes. we're done */\n\n      /*\n        asking for a password with an empty prompt means mysql->password\n        otherwise we ask the user and read the reply\n      */\n      if ((cmd >> 1) == 2 && *pkt == 0)\n        reply = mysql->passwd;\n      else\n        reply = ask(mysql, cmd >> 1, (const char *)pkt, reply_buf,\n                    sizeof(reply_buf));\n      if (!reply) return CR_ERROR;\n    }\n    /* send the reply to the server */\n    res = vio->write_packet(vio, (const unsigned char *)reply,\n                            (int)strlen(reply) + 1);\n\n    if (reply != mysql->passwd && reply != reply_buf) free(reply);\n\n    if (res) return CR_ERROR;\n\n    /* repeat unless it was the last question */\n  } while ((cmd & 1) != 1);\n\n  /* the job of reading the ok/error packet is left to the server */\n  return CR_OK;\n}\n\n/**\n  initialization function of the dialog plugin\n\n  Pick up the client's authentication_dialog_ask() function, if exists,\n  or fall back to the default implementation.\n*/\n\nstatic int init_dialog(char *unused1 MY_ATTRIBUTE((unused)),\n                       size_t unused2 MY_ATTRIBUTE((unused)),\n                       int unused3 MY_ATTRIBUTE((unused)),\n                       va_list unused4 MY_ATTRIBUTE((unused))) {\n  void *sym = dlsym(RTLD_DEFAULT, \"mysql_authentication_dialog_ask\");\n  ask = sym ? (mysql_authentication_dialog_ask_t)sym : builtin_ask;\n  return 0;\n}\n\nmysql_declare_client_plugin(AUTHENTICATION) \"dialog\", \"Sergei Golubchik\",\n    \"Dialog Client Authentication Plugin\", {0, 1, 0}, \"GPL\", NULL,\n    init_dialog, NULL, NULL, perform_dialog mysql_end_client_plugin;\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/plugin/innodb_memcached/daemon_memcached/daemon/memcached.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n *  memcached - memory caching daemon\n *\n *       http://www.danga.com/memcached/\n *  Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.\n *  Copyright 2003 Danga Interactive, Inc.  All rights reserved.\n *  This file was modified by Oracle on 28-08-2015 and 23-03-2016.\n *  Modifications copyright (c) 2015, 2016, Oracle and/or its affiliates.\n *  All rights reserved.\n *\n *  Use and distribution licensed under the BSD license.  See\n *  the LICENSE file for full text.\n *\n *  Authors:\n *      Anatoly Vorobey <mellon@pobox.com>\n *      Brad Fitzpatrick <brad@danga.com>\n *\n *  Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.\n */\n#include \"config.h\"\n#include \"config_static.h\"\n#include \"memcached.h\"\n#include \"memcached/extension_loggers.h\"\n#include \"utilities/engine_loader.h\"\n\n#include <signal.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <assert.h>\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <dlfcn.h>\n\n#include \"memcached_mysql.h\"\n\n#define INNODB_MEMCACHED\nvoid my_thread_init();\nvoid my_thread_end();\n\nstatic inline void item_set_cas(const void *cookie, item *it, uint64_t cas) {\n    settings.engine.v1->item_set_cas(settings.engine.v0, cookie, it, cas);\n}\n\n/* The item must always be called \"it\" */\n#define SLAB_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->slab_stats[info.clsid].slab_op++;\n\n#define THREAD_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->thread_op++;\n\n#define THREAD_GUTS2(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->slab_op++; \\\n    thread_stats->thread_op++;\n\n#define SLAB_THREAD_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    SLAB_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    THREAD_GUTS(conn, thread_stats, slab_op, thread_op)\n\n#define STATS_INCR1(GUTS, conn, slab_op, thread_op, key, nkey) { \\\n    struct independent_stats *independent_stats = get_independent_stats(conn); \\\n    struct thread_stats *thread_stats = \\\n        &independent_stats->thread_stats[conn->thread->index]; \\\n    topkeys_t *topkeys = independent_stats->topkeys; \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    GUTS(conn, thread_stats, slab_op, thread_op); \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n    TK(topkeys, slab_op, key, nkey, current_time); \\\n}\n\n#define STATS_INCR(conn, op, key, nkey) \\\n    STATS_INCR1(THREAD_GUTS, conn, op, op, key, nkey)\n\n#define SLAB_INCR(conn, op, key, nkey) \\\n    STATS_INCR1(SLAB_GUTS, conn, op, op, key, nkey)\n\n#define STATS_TWO(conn, slab_op, thread_op, key, nkey) \\\n    STATS_INCR1(THREAD_GUTS2, conn, slab_op, thread_op, key, nkey)\n\n#define SLAB_TWO(conn, slab_op, thread_op, key, nkey) \\\n    STATS_INCR1(SLAB_THREAD_GUTS, conn, slab_op, thread_op, key, nkey)\n\n#define STATS_HIT(conn, op, key, nkey) \\\n    SLAB_TWO(conn, op##_hits, cmd_##op, key, nkey)\n\n#define STATS_MISS(conn, op, key, nkey) \\\n    STATS_TWO(conn, op##_misses, cmd_##op, key, nkey)\n\n#if defined(HAVE_GCC_SYNC_BUILTINS)\n\n#define STATS_NOKEY(conn, op)\t\\\ndo { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n\t__sync_add_and_fetch(&thread_stats->op, 1); \\\n} while (0)\n\n#define STATS_NOKEY2(conn, op1, op2)\t\\\ndo { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n\t__sync_add_and_fetch(&thread_stats->op1, 1); \\\n\t__sync_add_and_fetch(&thread_stats->op2, 1); \\\n} while (0)\n\n#define STATS_ADD(conn, op, amt)\t\\\ndo { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n\t__sync_add_and_fetch(&thread_stats->op, amt); \\\n} while (0)\n\n#define MEMCACHED_ATOMIC_MSG\t\"InnoDB MEMCACHED: Memcached uses atomic increment \\n\"\n\n#else /* HAVE_GCC_SYNC_BUILTINS */\n#define STATS_NOKEY(conn, op) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op++; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\n#define STATS_NOKEY2(conn, op1, op2) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op1++; \\\n    thread_stats->op2++; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\n#define STATS_ADD(conn, op, amt) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op += amt; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\n#define MEMCACHED_ATOMIC_MSG\t\"InnoDB Memcached: Memcached DOES NOT use atomic increment\"\n#endif /* HAVE_GCC_SYNC_BUILTINS */\n\nvolatile sig_atomic_t memcached_shutdown;\nvolatile sig_atomic_t memcached_initialized;\n\n/*\n * We keep the current time of day in a global variable that's updated by a\n * timer event. This saves us a bunch of time() system calls (we really only\n * need to get the time once a second, whereas there can be tens of thousands\n * of requests a second) and allows us to use server-start-relative timestamps\n * rather than absolute UNIX timestamps, a space savings on systems where\n * sizeof(time_t) > sizeof(unsigned int).\n */\nvolatile rel_time_t current_time;\n\n/*\n * forward declarations\n */\nstatic SOCKET new_socket(struct addrinfo *ai);\nstatic int try_read_command(conn *c);\nstatic inline struct independent_stats *get_independent_stats(conn *c);\nstatic inline struct thread_stats *get_thread_stats(conn *c);\nstatic void register_callback(ENGINE_HANDLE *eh,\n                              ENGINE_EVENT_TYPE type,\n                              EVENT_CALLBACK cb, const void *cb_data);\nenum try_read_result {\n    READ_DATA_RECEIVED,\n    READ_NO_DATA_RECEIVED,\n    READ_ERROR,            /** an error occured (on the socket) (or client closed connection) */\n    READ_MEMORY_ERROR      /** failed to allocate more memory */\n};\n\nstatic enum try_read_result try_read_network(conn *c);\nstatic enum try_read_result try_read_udp(conn *c);\n\n/* stats */\nstatic void stats_init(void);\nstatic void server_stats(ADD_STAT add_stats, conn *c, bool aggregate);\nstatic void process_stat_settings(ADD_STAT add_stats, void *c);\n\n\n/* defaults */\nstatic void settings_init(void);\n\n/* event handling, network IO */\nstatic void event_handler(const int fd, const short which, void *arg);\nstatic void complete_nread(conn *c);\nstatic char *process_command(conn *c, char *command);\nstatic void write_and_free(conn *c, char *buf, int bytes);\nstatic int ensure_iov_space(conn *c);\nstatic int add_iov(conn *c, const void *buf, int len);\nstatic int add_msghdr(conn *c);\n\n\n/* time handling */\nstatic void set_current_time(void);  /* update the global variable holding\n                              global 32-bit seconds-since-start time\n                              (to avoid 64 bit time_t) */\n\n/** exported globals **/\nstruct stats stats;\nstruct settings settings;\nstatic time_t process_started;     /* when the process was started */\n\n/** file scope variables **/\nstatic conn *listen_conn = NULL;\nstatic int  udp_socket[100];\nstatic int  num_udp_socket;\nstatic struct event_base *main_base;\nstatic struct independent_stats *default_independent_stats;\n\nstatic struct engine_event_handler *engine_event_handlers[MAX_ENGINE_EVENT_TYPE + 1];\n\nenum transmit_result {\n    TRANSMIT_COMPLETE,   /** All done writing. */\n    TRANSMIT_INCOMPLETE, /** More data remaining to write. */\n    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */\n    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */\n};\n\nstatic enum transmit_result transmit(conn *c);\n\n#define REALTIME_MAXDELTA 60*60*24*30\n\n// Perform all callbacks of a given type for the given connection.\nstatic void perform_callbacks(ENGINE_EVENT_TYPE type,\n                              const void *data,\n                              const void *c) {\n    for (struct engine_event_handler *h = engine_event_handlers[type];\n         h; h = h->next) {\n        h->cb(c, type, data, h->cb_data);\n    }\n}\n\n/*\n * given time value that's either unix time or delta from current unix time,\n * return unix time. Use the fact that delta can't exceed one month\n * (and real time value can't be that low).\n */\nstatic rel_time_t realtime(const time_t exptime) {\n    /* no. of seconds in 30 days - largest possible delta exptime */\n\n    if (exptime == 0) return 0; /* 0 means never expire */\n\n    if (exptime > REALTIME_MAXDELTA) {\n        /* if item expiration is at/before the server started, give it an\n           expiration time of 1 second after the server started.\n           (because 0 means don't expire).  without this, we'd\n           underflow and wrap around to some large value way in the\n           future, effectively making items expiring in the past\n           really expiring never */\n        if (exptime <= process_started)\n            return (rel_time_t)1;\n        return (rel_time_t)(exptime - process_started);\n    } else {\n        return (rel_time_t)(exptime + current_time);\n    }\n}\n\n/**\n * Convert the relative time to an absolute time (relative to EPOC ;) )\n */\nstatic time_t abstime(const rel_time_t exptime)\n{\n    return process_started + exptime;\n}\n\nstatic void stats_init(void) {\n    stats.daemon_conns = 0;\n    stats.rejected_conns = 0;\n    stats.curr_conns = stats.total_conns = stats.conn_structs = 0;\n\n    stats_prefix_init();\n}\n\nstatic void stats_reset(const void *cookie) {\n    struct conn *conn = (struct conn*)cookie;\n    STATS_LOCK();\n    stats.rejected_conns = 0;\n    stats.total_conns = 0;\n    stats_prefix_clear();\n    STATS_UNLOCK();\n    threadlocal_stats_reset(get_independent_stats(conn)->thread_stats);\n    settings.engine.v1->reset_stats(settings.engine.v0, cookie);\n}\n\nstatic void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 11211;\n    /* By default this string should be NULL for getaddrinfo() */\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */\n    settings.maxconns = 1000;         /* to limit connections-related memory to about 5MB */\n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */\n    settings.socketpath = NULL;       /* by default, not using a unix socket */\n    settings.factor = 1.25;\n    settings.chunk_size = 48;         /* space for a modest key and value */\n    settings.num_threads = 4;         /* N workers */\n    settings.num_threads_per_udp = 0;\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.allow_detailed = true;\n    settings.reqs_per_event = DEFAULT_REQS_PER_EVENT;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */\n    settings.topkeys = 0;\n    settings.require_sasl = false;\n    settings.extensions.logger = get_stderr_logger();\n}\n\n/*\n * Adds a message header to a connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int add_msghdr(conn *c)\n{\n    struct msghdr *msg;\n\n    assert(c != NULL);\n\n    if (c->msgsize == c->msgused) {\n        msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));\n        if (! msg)\n            return -1;\n        c->msglist = msg;\n        c->msgsize *= 2;\n    }\n\n    msg = c->msglist + c->msgused;\n\n    /* this wipes msg_iovlen, msg_control, msg_controllen, and\n       msg_flags, the last 3 of which aren't defined on solaris: */\n    memset(msg, 0, sizeof(struct msghdr));\n\n    msg->msg_iov = &c->iov[c->iovused];\n\n    if (c->request_addr_size > 0) {\n        msg->msg_name = &c->request_addr;\n        msg->msg_namelen = c->request_addr_size;\n    }\n\n    c->msgbytes = 0;\n    c->msgused++;\n\n    if (IS_UDP(c->transport)) {\n        /* Leave room for the UDP header, which we'll fill in later. */\n        return add_iov(c, NULL, UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\nstatic const char *prot_text(enum protocol prot) {\n    char *rv = \"unknown\";\n    switch(prot) {\n        case ascii_prot:\n            rv = \"ascii\";\n            break;\n        case binary_prot:\n            rv = \"binary\";\n            break;\n        case negotiating_prot:\n            rv = \"auto-negotiate\";\n            break;\n    }\n    return rv;\n}\n\nstruct {\n    pthread_mutex_t mutex;\n    bool disabled;\n    ssize_t count;\n    uint64_t num_disable;\n} listen_state;\n\nstatic bool is_listen_disabled(void) {\n    bool ret;\n    pthread_mutex_lock(&listen_state.mutex);\n    ret = listen_state.disabled;\n    pthread_mutex_unlock(&listen_state.mutex);\n    return ret;\n}\n\nstatic uint64_t get_listen_disabled_num(void) {\n    uint64_t ret;\n    pthread_mutex_lock(&listen_state.mutex);\n    ret = listen_state.num_disable;\n    pthread_mutex_unlock(&listen_state.mutex);\n    return ret;\n}\n\nstatic void disable_listen(void) {\n    pthread_mutex_lock(&listen_state.mutex);\n    listen_state.disabled = true;\n    listen_state.count = 10;\n    ++listen_state.num_disable;\n    pthread_mutex_unlock(&listen_state.mutex);\n\n    conn *next;\n    for (next = listen_conn; next; next = next->next) {\n        update_event(next, 0);\n        if (listen(next->sfd, 1) != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"listen() failed\",\n                                            strerror(errno));\n        }\n    }\n}\n\nvoid safe_close(SOCKET sfd) {\n    if (sfd != INVALID_SOCKET) {\n        int rval;\n        while ((rval = closesocket(sfd)) == SOCKET_ERROR &&\n               (errno == EINTR || errno == EAGAIN)) {\n            /* go ahead and retry */\n        }\n\n        if (rval == SOCKET_ERROR) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"Failed to close socket %d (%s)!!\\n\", (int)sfd,\n                                            strerror(errno));\n        } else {\n            STATS_LOCK();\n            stats.curr_conns--;\n            STATS_UNLOCK();\n\n            if (is_listen_disabled()) {\n                notify_dispatcher();\n            }\n        }\n    }\n}\n\n/*\n * Free list management for connections.\n */\ncache_t *conn_cache;      /* suffix cache */\n\n/**\n * Reset all of the dynamic buffers used by a connection back to their\n * default sizes. The strategy for resizing the buffers is to allocate a\n * new one of the correct size and free the old one if the allocation succeeds\n * instead of using realloc to change the buffer size (because realloc may\n * not shrink the buffers, and will also copy the memory). If the allocation\n * fails the buffer will be unchanged.\n *\n * @param c the connection to resize the buffers for\n * @return true if all allocations succeeded, false if one or more of the\n *         allocations failed.\n */\nstatic bool conn_reset_buffersize(conn *c) {\n    bool ret = true;\n\n    if (c->rsize != DATA_BUFFER_SIZE) {\n        void *ptr = malloc(DATA_BUFFER_SIZE);\n        if (ptr != NULL) {\n            free(c->rbuf);\n            c->rbuf = ptr;\n            c->rsize = DATA_BUFFER_SIZE;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->wsize != DATA_BUFFER_SIZE) {\n        void *ptr = malloc(DATA_BUFFER_SIZE);\n        if (ptr != NULL) {\n            free(c->wbuf);\n            c->wbuf = ptr;\n            c->wsize = DATA_BUFFER_SIZE;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->isize != ITEM_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(item *) * ITEM_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->ilist);\n            c->ilist = ptr;\n            c->isize = ITEM_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->suffixsize != SUFFIX_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(char *) * SUFFIX_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->suffixlist);\n            c->suffixlist = ptr;\n            c->suffixsize = SUFFIX_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->iovsize != IOV_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(struct iovec) * IOV_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->iov);\n            c->iov = ptr;\n            c->iovsize = IOV_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->msgsize != MSG_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(struct msghdr) * MSG_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->msglist);\n            c->msglist = ptr;\n            c->msgsize = MSG_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    return ret;\n}\n\n/**\n * Constructor for all memory allocations of connection objects. Initialize\n * all members and allocate the transfer buffers.\n *\n * @param buffer The memory allocated by the object cache\n * @param unused1 not used\n * @param unused2 not used\n * @return 0 on success, 1 if we failed to allocate memory\n */\nstatic int conn_constructor(void *buffer, void *unused1, int unused2) {\n    (void)unused1; (void)unused2;\n\n    conn *c = buffer;\n    memset(c, 0, sizeof(*c));\n    MEMCACHED_CONN_CREATE(c);\n\n    if (!conn_reset_buffersize(c)) {\n        free(c->rbuf);\n        free(c->wbuf);\n        free(c->ilist);\n        free(c->suffixlist);\n        free(c->iov);\n        free(c->msglist);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING,\n                                        NULL,\n                                        \"Failed to allocate buffers for connection\\n\");\n        return 1;\n    }\n\n    STATS_LOCK();\n    stats.conn_structs++;\n    STATS_UNLOCK();\n\n    return 0;\n}\n\n/**\n * Destructor for all connection objects. Release all allocated resources.\n *\n * @param buffer The memory allocated by the objec cache\n * @param unused not used\n */\nstatic void conn_destructor(void *buffer, void *unused) {\n    (void)unused;\n    conn *c = buffer;\n    free(c->rbuf);\n    free(c->wbuf);\n    free(c->ilist);\n    free(c->suffixlist);\n    free(c->iov);\n    free(c->msglist);\n\n    STATS_LOCK();\n    stats.conn_structs--;\n    STATS_UNLOCK();\n}\n\nconn *conn_new(const SOCKET sfd, STATE_FUNC init_state,\n               const int event_flags,\n               const int read_buffer_size, enum network_transport transport,\n               struct event_base *base, struct timeval *timeout) {\n    conn *c = cache_alloc(conn_cache);\n    if (c == NULL) {\n        return NULL;\n    }\n\n    assert(c->thread == NULL);\n\n    if (c->rsize < read_buffer_size) {\n        void *mem = malloc(read_buffer_size);\n        if (mem) {\n            c->rsize = read_buffer_size;\n            free(c->rbuf);\n            c->rbuf = mem;\n        } else {\n            assert(c->thread == NULL);\n            cache_free(conn_cache, c);\n            return NULL;\n        }\n    }\n\n    c->transport = transport;\n    c->protocol = settings.binding_protocol;\n\n    /* unix socket mode doesn't need this, so zeroed out.  but why\n     * is this done for every command?  presumably for UDP\n     * mode.  */\n    if (!settings.socketpath) {\n        c->request_addr_size = sizeof(c->request_addr);\n    } else {\n        c->request_addr_size = 0;\n    }\n\n    if (settings.verbose > 1) {\n        if (init_state == conn_listening) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d server listening (%s)\\n\", sfd,\n                                            prot_text(c->protocol));\n        } else if (IS_UDP(transport)) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d server listening (udp)\\n\", sfd);\n        } else if (c->protocol == negotiating_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new auto-negotiating client connection\\n\",\n                                            sfd);\n        } else if (c->protocol == ascii_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new ascii client connection.\\n\", sfd);\n        } else if (c->protocol == binary_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new binary client connection.\\n\", sfd);\n        } else {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new unknown (%d) client connection\\n\",\n                                            sfd, c->protocol);\n            assert(false);\n        }\n    }\n\n    c->sfd = sfd;\n    c->state = init_state;\n    c->rlbytes = 0;\n    c->cmd = -1;\n    c->ascii_cmd = NULL;\n    c->rbytes = c->wbytes = 0;\n    c->wcurr = c->wbuf;\n    c->rcurr = c->rbuf;\n    c->ritem = 0;\n    c->icurr = c->ilist;\n    c->suffixcurr = c->suffixlist;\n    c->ileft = 0;\n    c->suffixleft = 0;\n    c->iovused = 0;\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->next = NULL;\n    c->list_state = 0;\n\n    c->write_and_go = init_state;\n    c->write_and_free = 0;\n    c->item = 0;\n\n    c->noreply = false;\n\n    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = event_flags;\n\n    if (!register_event(c, timeout)) {\n        assert(c->thread == NULL);\n        cache_free(conn_cache, c);\n        return NULL;\n    }\n\n    STATS_LOCK();\n    stats.total_conns++;\n    STATS_UNLOCK();\n\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    c->refcount = 1;\n\n    MEMCACHED_CONN_ALLOCATE(c->sfd);\n\n    perform_callbacks(ON_CONNECT, NULL, c);\n\n    return c;\n}\n\nstatic void conn_cleanup(conn *c) {\n    assert(c != NULL);\n\n    if (c->item) {\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n\n    if (c->ileft != 0) {\n        for (; c->ileft > 0; c->ileft--,c->icurr++) {\n            settings.engine.v1->release(settings.engine.v0, c, *(c->icurr));\n        }\n    }\n\n    if (c->suffixleft != 0) {\n        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {\n            cache_free(c->thread->suffix_cache, *(c->suffixcurr));\n        }\n    }\n\n    if (c->write_and_free) {\n        free(c->write_and_free);\n        c->write_and_free = 0;\n    }\n\n    if (c->sasl_conn) {\n        sasl_dispose(&c->sasl_conn);\n        c->sasl_conn = NULL;\n    }\n\n    if (c->engine_storage) {\n\tvoid* cleanup_data = c->engine_storage;\n\tc->engine_storage = NULL;\n\tsettings.engine.v1->clean_engine(settings.engine.v0, c, cleanup_data);\n    }\n\n    c->tap_iterator = NULL;\n    c->thread = NULL;\n    assert(c->next == NULL);\n    c->ascii_cmd = NULL;\n    c->sfd = INVALID_SOCKET;\n    c->tap_nack_mode = false;\n}\n\nvoid conn_close(conn *c) {\n    assert(c != NULL);\n    assert(c->sfd == INVALID_SOCKET);\n\n    if (c->ascii_cmd != NULL) {\n        c->ascii_cmd->abort(c->ascii_cmd, c);\n    }\n\n    assert(c->thread);\n    LOCK_THREAD(c->thread);\n    /* remove from pending-io list */\n    if (settings.verbose > 1 && list_contains(c->thread->pending_io, c)) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Current connection was in the pending-io list.. Nuking it\\n\");\n    }\n    c->thread->pending_io = list_remove(c->thread->pending_io, c);\n    c->thread->pending_close = list_remove(c->thread->pending_close, c);\n    UNLOCK_THREAD(c->thread);\n\n    conn_cleanup(c);\n\n    /*\n     * The contract with the object cache is that we should return the\n     * object in a constructed state. Reset the buffers to the default\n     * size\n     */\n    conn_reset_buffersize(c);\n    assert(c->thread == NULL);\n    cache_free(conn_cache, c);\n}\n\n/*\n * Shrinks a connection's buffers if they're too big.  This prevents\n * periodic large \"get\" requests from permanently chewing lots of server\n * memory.\n *\n * This should only be called in between requests since it can wipe output\n * buffers!\n */\nstatic void conn_shrink(conn *c) {\n    assert(c != NULL);\n\n    if (IS_UDP(c->transport))\n        return;\n\n    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {\n        char *newbuf;\n\n        if (c->rcurr != c->rbuf)\n            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);\n\n        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);\n\n        if (newbuf) {\n            c->rbuf = newbuf;\n            c->rsize = DATA_BUFFER_SIZE;\n        }\n        /* TODO check other branch... */\n        c->rcurr = c->rbuf;\n    }\n\n    if (c->isize > ITEM_LIST_HIGHWAT) {\n        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));\n        if (newbuf) {\n            c->ilist = newbuf;\n            c->isize = ITEM_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->msgsize > MSG_LIST_HIGHWAT) {\n        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));\n        if (newbuf) {\n            c->msglist = newbuf;\n            c->msgsize = MSG_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->iovsize > IOV_LIST_HIGHWAT) {\n        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));\n        if (newbuf) {\n            c->iov = newbuf;\n            c->iovsize = IOV_LIST_INITIAL;\n        }\n    /* TODO check return value */\n    }\n}\n\n/**\n * Convert a state name to a human readable form.\n */\nconst char *state_text(STATE_FUNC state) {\n    if (state == conn_listening) {\n        return \"conn_listening\";\n    } else if (state == conn_new_cmd) {\n        return \"conn_new_cmd\";\n    } else if (state == conn_waiting) {\n        return \"conn_waiting\";\n    } else if (state == conn_read) {\n        return \"conn_read\";\n    } else if (state == conn_parse_cmd) {\n        return \"conn_parse_cmd\";\n    } else if (state == conn_write) {\n        return \"conn_write\";\n    } else if (state == conn_nread) {\n        return \"conn_nread\";\n    } else if (state == conn_swallow) {\n        return \"conn_swallow\";\n    } else if (state == conn_closing) {\n        return \"conn_closing\";\n    } else if (state == conn_mwrite) {\n        return \"conn_mwrite\";\n    } else if (state == conn_ship_log) {\n        return \"conn_ship_log\";\n    } else if (state == conn_add_tap_client) {\n        return \"conn_add_tap_client\";\n    } else if (state == conn_setup_tap_stream) {\n        return \"conn_setup_tap_stream\";\n    } else if (state == conn_pending_close) {\n        return \"conn_pending_close\";\n    } else if (state == conn_immediate_close) {\n        return \"conn_immediate_close\";\n    } else {\n        return \"Unknown\";\n    }\n}\n\n/*\n * Sets a connection's current state in the state machine. Any special\n * processing that needs to happen on certain state transitions can\n * happen here.\n */\nvoid conn_set_state(conn *c, STATE_FUNC state) {\n    assert(c != NULL);\n\n    if (state != c->state) {\n        /*\n         * The connections in the \"tap thread\" behaves differently than\n         * normal connections because they operate in a full duplex mode.\n         * New messages may appear from both sides, so we can't block on\n         * read from the nework / engine\n         */\n        if (c->thread == tap_thread) {\n            if (state == conn_waiting) {\n                c->which = EV_WRITE;\n                state = conn_ship_log;\n            }\n        }\n\n        if (settings.verbose > 2 || c->state == conn_closing\n            || c->state == conn_add_tap_client) {\n            settings.extensions.logger->log(EXTENSION_LOG_DETAIL, c,\n                                            \"%d: going from %s to %s\\n\",\n                                            c->sfd, state_text(c->state),\n                                            state_text(state));\n        }\n\n        c->state = state;\n\n        if (state == conn_write || state == conn_mwrite) {\n            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);\n        }\n    }\n}\n\n/*\n * Ensures that there is room for another struct iovec in a connection's\n * iov list.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int ensure_iov_space(conn *c) {\n    assert(c != NULL);\n\n    if (c->iovused >= c->iovsize) {\n        int i, iovnum;\n        struct iovec *new_iov = (struct iovec *)realloc(c->iov,\n                                (c->iovsize * 2) * sizeof(struct iovec));\n        if (! new_iov)\n            return -1;\n        c->iov = new_iov;\n        c->iovsize *= 2;\n\n        /* Point all the msghdr structures at the new list. */\n        for (i = 0, iovnum = 0; i < c->msgused; i++) {\n            c->msglist[i].msg_iov = &c->iov[iovnum];\n            iovnum += c->msglist[i].msg_iovlen;\n        }\n    }\n\n    return 0;\n}\n\n\n/*\n * Adds data to the list of pending data that will be written out to a\n * connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\n\nstatic int add_iov(conn *c, const void *buf, int len) {\n    struct msghdr *m;\n    int leftover;\n    bool limit_to_mtu;\n\n    assert(c != NULL);\n\n    do {\n        m = &c->msglist[c->msgused - 1];\n\n        /*\n         * Limit UDP packets, and the first payloads of TCP replies, to\n         * UDP_MAX_PAYLOAD_SIZE bytes.\n         */\n        limit_to_mtu = IS_UDP(c->transport) || (1 == c->msgused);\n\n        /* We may need to start a new msghdr if this one is full. */\n        if (m->msg_iovlen == IOV_MAX ||\n            (limit_to_mtu && c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {\n            add_msghdr(c);\n            m = &c->msglist[c->msgused - 1];\n        }\n\n        if (ensure_iov_space(c) != 0)\n            return -1;\n\n        /* If the fragment is too big to fit in the datagram, split it up */\n        if (limit_to_mtu && len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {\n            leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;\n            len -= leftover;\n        } else {\n            leftover = 0;\n        }\n\n        m = &c->msglist[c->msgused - 1];\n        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;\n        m->msg_iov[m->msg_iovlen].iov_len = len;\n\n        c->msgbytes += len;\n        c->iovused++;\n        m->msg_iovlen++;\n\n        buf = ((char *)buf) + len;\n        len = leftover;\n    } while (leftover > 0);\n\n    return 0;\n}\n\n\n/*\n * Constructs a set of UDP headers and attaches them to the outgoing messages.\n */\nstatic int build_udp_headers(conn *c) {\n    int i;\n    unsigned char *hdr;\n\n    assert(c != NULL);\n\n    if (c->msgused > c->hdrsize) {\n        void *new_hdrbuf;\n        if (c->hdrbuf)\n            new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);\n        else\n            new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);\n        if (! new_hdrbuf)\n            return -1;\n        c->hdrbuf = (unsigned char *)new_hdrbuf;\n        c->hdrsize = c->msgused * 2;\n    }\n\n    hdr = c->hdrbuf;\n    for (i = 0; i < c->msgused; i++) {\n        c->msglist[i].msg_iov[0].iov_base = (void*)hdr;\n        c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;\n        *hdr++ = c->request_id / 256;\n        *hdr++ = c->request_id % 256;\n        *hdr++ = i / 256;\n        *hdr++ = i % 256;\n        *hdr++ = c->msgused / 256;\n        *hdr++ = c->msgused % 256;\n        *hdr++ = 0;\n        *hdr++ = 0;\n        assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\n\nstatic void out_string(conn *c, const char *str) {\n    size_t len;\n\n    assert(c != NULL);\n\n    if (c->noreply) {\n        if (settings.verbose > 1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \">%d NOREPLY %s\\n\", c->sfd, str);\n        }\n        c->noreply = false;\n        if (c->sbytes > 0) {\n            conn_set_state(c, conn_swallow);\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n        return;\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d %s\\n\", c->sfd, str);\n    }\n\n    /* Nuke a partial output... */\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    add_msghdr(c);\n\n    len = strlen(str);\n    if ((len + 2) > c->wsize) {\n        /* ought to be always enough. just fail for simplicity */\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n\n    memcpy(c->wbuf, str, len);\n    memcpy(c->wbuf + len, \"\\r\\n\", 2);\n    c->wbytes = len + 2;\n    c->wcurr = c->wbuf;\n\n    conn_set_state(c, conn_write);\n\n    if (c->sbytes > 0) {\n        c->write_and_go = conn_swallow;\n    } else {\n        c->write_and_go = conn_new_cmd;\n    }\n\n    return;\n}\n\n/*\n * we get here after reading the value in set/add/replace commands. The command\n * has been stored in c->cmd, and the item is ready in c->item.\n */\nstatic void complete_update_ascii(conn *c) {\n    assert(c != NULL);\n\n    item *it = c->item;\n    item_info info = { .nvalue = 1 };\n    if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n        settings.engine.v1->release(settings.engine.v0, c, it);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: Failed to get item info\\n\",\n                                        c->sfd);\n        out_string(c, \"SERVER_ERROR failed to get item details\");\n        return;\n    }\n\n    c->sbytes = 2; // swallow \\r\\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->store(settings.engine.v0, c, it, &c->cas,\n                                        c->store_op, 0);\n    }\n\n#ifdef ENABLE_DTRACE\n    switch (c->store_op) {\n    case OPERATION_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, info.key, info.nkey,\n                                 (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_CAS:\n        MEMCACHED_COMMAND_CAS(c->sfd, info.key, info.nkey, info.nbytes, c->cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        out_string(c, \"STORED\");\n        break;\n    case ENGINE_KEY_EEXISTS:\n        out_string(c, \"EXISTS\");\n        break;\n    case ENGINE_KEY_ENOENT:\n        out_string(c, \"NOT_FOUND\");\n        break;\n    case ENGINE_NOT_STORED:\n        out_string(c, \"NOT_STORED\");\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        out_string(c, \"SERVER_ERROR not supported\");\n        break;\n    case ENGINE_ENOMEM:\n        out_string(c, \"SERVER_ERROR out of memory\");\n        break;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    case ENGINE_EINVAL:\n        out_string(c, \"CLIENT_ERROR invalid arguments\");\n        break;\n    case ENGINE_E2BIG:\n        out_string(c, \"CLIENT_ERROR value too big\");\n        break;\n    case ENGINE_EACCESS:\n        out_string(c, \"CLIENT_ERROR access control violation\");\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        out_string(c, \"SERVER_ERROR not my vbucket\");\n        break;\n    case ENGINE_FAILED:\n        out_string(c, \"SERVER_ERROR failure\");\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_WANT_MORE:\n        assert(false);\n        c->state = conn_closing;\n        break;\n\n    default:\n        out_string(c, \"SERVER_ERROR internal\");\n    }\n\n    if (c->store_op == OPERATION_CAS) {\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            SLAB_INCR(c, cas_hits, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_EEXISTS:\n            SLAB_INCR(c, cas_badval, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_ENOENT:\n            STATS_NOKEY(c, cas_misses);\n            break;\n        default:\n            ;\n        }\n    } else {\n        SLAB_INCR(c, cmd_set, info.key, info.nkey);\n    }\n\n    if (!c->ewouldblock) {\n        /* release the c->item reference */\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n}\n\n/**\n * get a pointer to the start of the request struct for the current command\n */\nstatic void* binary_get_request(conn *c) {\n    char *ret = c->rcurr;\n    ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +\n            c->binary_header.request.extlen);\n\n    assert(ret >= c->rbuf);\n    return ret;\n}\n\n/**\n * get a pointer to the key in this request\n */\nstatic char* binary_get_key(conn *c) {\n    return c->rcurr - (c->binary_header.request.keylen);\n}\n\n/**\n * Insert a key into a buffer, but replace all non-printable characters\n * with a '.'.\n *\n * @param dest where to store the output\n * @param destsz size of destination buffer\n * @param prefix string to insert before the data\n * @param client the client we are serving\n * @param from_client set to true if this data is from the client\n * @param key the key to add to the buffer\n * @param nkey the number of bytes in the key\n * @return number of bytes in dest if success, -1 otherwise\n */\nstatic ssize_t key_to_printable_buffer(char *dest, size_t destsz,\n                                       int client, bool from_client,\n                                       const char *prefix,\n                                       const char *key,\n                                       size_t nkey)\n{\n    ssize_t nw = snprintf(dest, destsz, \"%c%d %s \", from_client ? '>' : '<',\n                          client, prefix);\n    if (nw == -1) {\n        return -1;\n    }\n\n    char *ptr = dest + nw;\n    destsz -= nw;\n    if (nkey > destsz) {\n        nkey = destsz;\n    }\n\n    for (ssize_t ii = 0; ii < nkey; ++ii, ++key, ++ptr) {\n        if (isgraph(*key)) {\n            *ptr = *key;\n        } else {\n            *ptr = '.';\n        }\n    }\n\n    *ptr = '\\0';\n    return ptr - dest;\n}\n\n/**\n * Convert a byte array to a text string\n *\n * @param dest where to store the output\n * @param destsz size of destination buffer\n * @param prefix string to insert before the data\n * @param client the client we are serving\n * @param from_client set to true if this data is from the client\n * @param data the data to add to the buffer\n * @param size the number of bytes in data to print\n * @return number of bytes in dest if success, -1 otherwise\n */\nstatic ssize_t bytes_to_output_string(char *dest, size_t destsz,\n                                      int client, bool from_client,\n                                      const char *prefix,\n                                      const char *data,\n                                      size_t size)\n{\n    ssize_t nw = snprintf(dest, destsz, \"%c%d %s\", from_client ? '>' : '<',\n                          client, prefix);\n    if (nw == -1) {\n        return -1;\n    }\n    ssize_t offset = nw;\n\n    for (ssize_t ii = 0; ii < size; ++ii) {\n        if (ii % 4 == 0) {\n            if ((nw = snprintf(dest + offset, destsz - offset, \"\\n%c%d  \",\n                               from_client ? '>' : '<', client)) == -1) {\n                return  -1;\n            }\n            offset += nw;\n        }\n        if ((nw = snprintf(dest + offset, destsz - offset,\n                           \" 0x%02x\", (unsigned char)data[ii])) == -1) {\n            return -1;\n        }\n        offset += nw;\n    }\n\n    if ((nw = snprintf(dest + offset, destsz - offset, \"\\n\")) == -1) {\n        return -1;\n    }\n\n    return offset + nw;\n}\n\nstatic void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {\n    protocol_binary_response_header* header;\n\n    assert(c);\n\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        /* XXX:  out_string is inappropriate here */\n        out_string(c, \"SERVER_ERROR out of memory\");\n        return;\n    }\n\n    header = (protocol_binary_response_header *)c->wbuf;\n\n    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;\n    header->response.opcode = c->binary_header.request.opcode;\n    header->response.keylen = (uint16_t)htons(key_len);\n\n    header->response.extlen = (uint8_t)hdr_len;\n    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;\n    header->response.status = (uint16_t)htons(err);\n\n    header->response.bodylen = htonl(body_len);\n    header->response.opaque = c->opaque;\n    header->response.cas = htonll(c->cas);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (bytes_to_output_string(buffer, sizeof(buffer), c->sfd, false,\n                                   \"Writing bin response:\",\n                                   (const char*)header->bytes,\n                                   sizeof(header->bytes)) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"%s\", buffer);\n        }\n    }\n\n    add_iov(c, c->wbuf, sizeof(header->response));\n}\n\n/**\n * Convert an error code generated from the storage engine to the corresponding\n * error code used by the protocol layer.\n * @param e the error code as used in the engine\n * @return the error code as used by the protocol layer\n */\nstatic protocol_binary_response_status engine_error_2_protocol_error(ENGINE_ERROR_CODE e) {\n    protocol_binary_response_status ret;\n\n    switch (e) {\n    case ENGINE_SUCCESS:\n        return PROTOCOL_BINARY_RESPONSE_SUCCESS;\n    case ENGINE_KEY_ENOENT:\n        return PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n    case ENGINE_KEY_EEXISTS:\n        return PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n    case ENGINE_ENOMEM:\n        return PROTOCOL_BINARY_RESPONSE_ENOMEM;\n    case ENGINE_TMPFAIL:\n        return PROTOCOL_BINARY_RESPONSE_ETMPFAIL;\n    case ENGINE_NOT_STORED:\n        return PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n    case ENGINE_EINVAL:\n        return PROTOCOL_BINARY_RESPONSE_EINVAL;\n    case ENGINE_ENOTSUP:\n        return PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED;\n    case ENGINE_E2BIG:\n        return PROTOCOL_BINARY_RESPONSE_E2BIG;\n    case ENGINE_NOT_MY_VBUCKET:\n        return PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET;\n    default:\n        ret = PROTOCOL_BINARY_RESPONSE_EINTERNAL;\n    }\n\n    return ret;\n}\n\nstatic void write_bin_packet(conn *c, protocol_binary_response_status err, int swallow) {\n    ssize_t len;\n    char buffer[1024] = { [sizeof(buffer) - 1] = '\\0' };\n\n    switch (err) {\n    case PROTOCOL_BINARY_RESPONSE_SUCCESS:\n        len = 0;\n        break;\n    case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n        len = snprintf(buffer, sizeof(buffer), \"Out of memory\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_ETMPFAIL:\n        len = snprintf(buffer, sizeof(buffer), \"Temporary failure\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n        len = snprintf(buffer, sizeof(buffer), \"Unknown command\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n        len = snprintf(buffer, sizeof(buffer), \"Not found\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_EINVAL:\n        len = snprintf(buffer, sizeof(buffer), \"Invalid arguments\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n        len = snprintf(buffer, sizeof(buffer), \"Data exists for key\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_E2BIG:\n        len = snprintf(buffer, sizeof(buffer), \"Too large\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:\n        len = snprintf(buffer, sizeof(buffer),\n                       \"Non-numeric server-side value for incr or decr\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n        len = snprintf(buffer, sizeof(buffer), \"Not stored\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n        len = snprintf(buffer, sizeof(buffer), \"Auth failure\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED:\n        len = snprintf(buffer, sizeof(buffer), \"Not supported\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET:\n        len = snprintf(buffer, sizeof(buffer),\n                       \"I'm not responsible for this vbucket\");\n        break;\n\n    default:\n        len = snprintf(buffer, sizeof(buffer), \"UNHANDLED ERROR (%d)\", err);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \">%d UNHANDLED ERROR: %d\\n\", c->sfd, err);\n    }\n\n    /* Allow the engine to pass extra error information */\n    if (settings.engine.v1->errinfo != NULL) {\n        size_t elen = settings.engine.v1->errinfo(settings.engine.v0, c, buffer + len + 2,\n                                                  sizeof(buffer) - len - 3);\n\n        if (elen > 0) {\n            memcpy(buffer + len, \": \", 2);\n            len += elen + 2;\n        }\n    }\n\n    if (err != PROTOCOL_BINARY_RESPONSE_SUCCESS && settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d Writing an error: %s\\n\", c->sfd,\n                                        buffer);\n    }\n\n    add_bin_header(c, err, 0, 0, len);\n    if (len > 0) {\n        add_iov(c, buffer, len);\n    }\n    conn_set_state(c, conn_mwrite);\n    if (swallow > 0) {\n        c->sbytes = swallow;\n        c->write_and_go = conn_swallow;\n    } else {\n        c->write_and_go = conn_new_cmd;\n    }\n}\n\n/* Form and send a response to a command over the binary protocol */\nstatic void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {\n    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||\n        c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n        add_bin_header(c, 0, hlen, keylen, dlen);\n        if(dlen > 0) {\n            add_iov(c, d, dlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        conn_set_state(c, conn_new_cmd);\n    }\n}\n\n\nstatic void complete_incr_bin(conn *c) {\n    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;\n    protocol_binary_request_incr* req = binary_get_request(c);\n\n    assert(c != NULL);\n    assert(c->wsize >= sizeof(*rsp));\n\n    /* fix byteorder in the request */\n    uint64_t delta = ntohll(req->message.body.delta);\n    uint64_t initial = ntohll(req->message.body.initial);\n    rel_time_t expiration = ntohl(req->message.body.expiration);\n    char *key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n    bool incr = (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT ||\n                 c->cmd == PROTOCOL_BINARY_CMD_INCREMENTQ);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        ssize_t nw;\n        nw = key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                     incr ? \"INCR\" : \"DECR\", key, nkey);\n        if (nw != -1) {\n            if (snprintf(buffer + nw, sizeof(buffer) - nw,\n                         \" %\" PRIu64 \", %\" PRIu64 \", %\" PRIu64 \"\\n\",\n                         delta, initial, (uint64_t)expiration) != -1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\",\n                                                buffer);\n            }\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->arithmetic(settings.engine.v0,\n                                             c, key, nkey, incr,\n                                             req->message.body.expiration != 0xffffffff,\n                                             delta, initial, expiration,\n                                             &c->cas,\n                                             &rsp->message.body.value,\n                                             c->binary_header.request.vbucket);\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        rsp->message.body.value = htonll(rsp->message.body.value);\n        write_bin_response(c, &rsp->message.body, 0, 0,\n                           sizeof (rsp->message.body.value));\n        if (incr) {\n            STATS_INCR(c, incr_hits, key, nkey);\n        } else {\n            STATS_INCR(c, decr_hits, key, nkey);\n        }\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n            STATS_INCR(c, incr_misses, key, nkey);\n        } else {\n            STATS_INCR(c, decr_misses, key, nkey);\n        }\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_EINVAL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, 0);\n        break;\n    case ENGINE_NOT_STORED:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED, 0);\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        abort();\n    }\n}\n\nstatic void complete_update_bin(conn *c) {\n    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;\n    assert(c != NULL);\n\n    item *it = c->item;\n    item_info info = { .nvalue = 1 };\n    if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n        settings.engine.v1->release(settings.engine.v0, c, it);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: Failed to get item info\\n\",\n                                        c->sfd);\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n        return;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->store(settings.engine.v0, c,\n                                        it, &c->cas, c->store_op,\n                                        c->binary_header.request.vbucket);\n    }\n\n#ifdef ENABLE_DTRACE\n    switch (c->cmd) {\n    case OPERATION_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, info.key, info.nkey,\n                                 (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        /* Stored */\n        write_bin_response(c, NULL, 0, 0, 0);\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    default:\n        if (c->store_op == OPERATION_ADD) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n        } else if(c->store_op == OPERATION_REPLACE) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n        } else {\n            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n        }\n        write_bin_packet(c, eno, 0);\n    }\n\n    if (c->store_op == OPERATION_CAS) {\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            SLAB_INCR(c, cas_hits, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_EEXISTS:\n            SLAB_INCR(c, cas_badval, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_ENOENT:\n            STATS_NOKEY(c, cas_misses);\n            break;\n        default:\n            ;\n        }\n    } else {\n        SLAB_INCR(c, cmd_set, info.key, info.nkey);\n    }\n\n    if (!c->ewouldblock) {\n        /* release the c->item reference */\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n}\n\nstatic void process_bin_get(conn *c) {\n    item *it = NULL;\n\n    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"GET\", key, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->get(settings.engine.v0, c, &it, key, nkey,\n                                      c->binary_header.request.vbucket);\n    }\n\n    uint16_t keylen;\n    uint32_t bodylen;\n    item_info info = { .nvalue = 1 };\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"%d: Failed to get item info\\n\",\n                                            c->sfd);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            break;\n        }\n\n        keylen = 0;\n        bodylen = sizeof(rsp->message.body) + info.nbytes;\n\n        STATS_HIT(c, get, key, nkey);\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            bodylen += nkey;\n            keylen = nkey;\n        }\n        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);\n        rsp->message.header.response.cas = htonll(info.cas);\n\n        // add the flags\n        rsp->message.body.flags = info.flags;\n        add_iov(c, &rsp->message.body, sizeof(rsp->message.body));\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            add_iov(c, info.key, nkey);\n        }\n\n        add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n        conn_set_state(c, conn_mwrite);\n        /* Remember this item so we can garbage collect it later */\n        c->item = it;\n        break;\n    case ENGINE_KEY_ENOENT:\n        STATS_MISS(c, get, key, nkey);\n\n        MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n\n        if (c->noreply) {\n            conn_set_state(c, conn_new_cmd);\n        } else {\n            if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n                char *ofs = c->wbuf + sizeof(protocol_binary_response_header);\n                add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,\n                               0, nkey, nkey);\n                memcpy(ofs, key, nkey);\n                add_iov(c, ofs, nkey);\n                conn_set_state(c, conn_mwrite);\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n            }\n        }\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_TMPFAIL:\n\tbreak;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    default:\n        /* @todo add proper error handling! */\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Unknown error code: %d\\n\", ret);\n        abort();\n    }\n\n    if (settings.detail_enabled && ret != ENGINE_EWOULDBLOCK) {\n        stats_prefix_record_get(key, nkey, ret == ENGINE_SUCCESS);\n    }\n}\n\nstatic void append_bin_stats(const char *key, const uint16_t klen,\n                             const char *val, const uint32_t vlen,\n                             conn *c) {\n    char *buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    uint32_t bodylen = klen + vlen;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = PROTOCOL_BINARY_CMD_STAT,\n        .response.keylen = (uint16_t)htons(klen),\n        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,\n        .response.bodylen = htonl(bodylen),\n        .response.opaque = c->opaque\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (klen > 0) {\n        memcpy(buf, key, klen);\n        buf += klen;\n\n        if (vlen > 0) {\n            memcpy(buf, val, vlen);\n        }\n    }\n\n    c->dynamic_buffer.offset += sizeof(header.response) + bodylen;\n}\n\n/**\n * Append a key-value pair to the stats output buffer. This function assumes\n * that the output buffer is big enough (it will be if you call it through\n * append_stats)\n */\nstatic void append_ascii_stats(const char *key, const uint16_t klen,\n                               const char *val, const uint32_t vlen,\n                               conn *c) {\n    char *pos = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    uint32_t nbytes = 5; /* \"END\\r\\n\" or \"STAT \" */\n\n    if (klen == 0 && vlen == 0) {\n        memcpy(pos, \"END\\r\\n\", 5);\n    } else {\n        memcpy(pos, \"STAT \", 5);\n        memcpy(pos + nbytes, key, klen);\n        nbytes += klen;\n        if (vlen != 0) {\n            pos[nbytes] = ' ';\n            ++nbytes;\n            memcpy(pos + nbytes, val, vlen);\n            nbytes += vlen;\n        }\n        memcpy(pos + nbytes, \"\\r\\n\", 2);\n        nbytes += 2;\n    }\n\n    c->dynamic_buffer.offset += nbytes;\n}\n\nstatic bool grow_dynamic_buffer(conn *c, size_t needed) {\n    size_t nsize = c->dynamic_buffer.size;\n    size_t available = nsize - c->dynamic_buffer.offset;\n    bool rv = true;\n\n    /* Special case: No buffer -- need to allocate fresh */\n    if (c->dynamic_buffer.buffer == NULL) {\n        nsize = 1024;\n        available = c->dynamic_buffer.size = c->dynamic_buffer.offset = 0;\n    }\n\n    while (needed > available) {\n        assert(nsize > 0);\n        nsize = nsize << 1;\n        available = nsize - c->dynamic_buffer.offset;\n    }\n\n    if (nsize != c->dynamic_buffer.size) {\n        char *ptr = realloc(c->dynamic_buffer.buffer, nsize);\n        if (ptr) {\n            c->dynamic_buffer.buffer = ptr;\n            c->dynamic_buffer.size = nsize;\n        } else {\n            rv = false;\n        }\n    }\n\n    return rv;\n}\n\nstatic void append_stats(const char *key, const uint16_t klen,\n                         const char *val, const uint32_t vlen,\n                         const void *cookie)\n{\n    /* value without a key is invalid */\n    if (klen == 0 && vlen > 0) {\n        return ;\n    }\n\n    conn *c = (conn*)cookie;\n\n    if (c->protocol == binary_prot) {\n        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);\n        if (!grow_dynamic_buffer(c, needed)) {\n            return ;\n        }\n        append_bin_stats(key, klen, val, vlen, c);\n    } else {\n        size_t needed = vlen + klen + 10; // 10 == \"STAT = \\r\\n\"\n        if (!grow_dynamic_buffer(c, needed)) {\n            return ;\n        }\n        append_ascii_stats(key, klen, val, vlen, c);\n    }\n\n    assert(c->dynamic_buffer.offset <= c->dynamic_buffer.size);\n}\n\nstatic void process_bin_stat(conn *c) {\n    char *subcommand = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"STATS\", subcommand, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        if (nkey == 0) {\n            /* request all statistics */\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c, NULL, 0, append_stats);\n            if (ret == ENGINE_SUCCESS) {\n                server_stats(&append_stats, c, false);\n            }\n        } else if (strncmp(subcommand, \"reset\", 5) == 0) {\n            stats_reset(c);\n            settings.engine.v1->reset_stats(settings.engine.v0, c);\n        } else if (strncmp(subcommand, \"settings\", 8) == 0) {\n            process_stat_settings(&append_stats, c);\n        } else if (strncmp(subcommand, \"detail\", 6) == 0) {\n            char *subcmd_pos = subcommand + 6;\n            if (settings.allow_detailed) {\n                if (strncmp(subcmd_pos, \" dump\", 5) == 0) {\n                    int len;\n                    char *dump_buf = stats_prefix_dump(&len);\n                    if (dump_buf == NULL || len <= 0) {\n                        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n                        return ;\n                    } else {\n                        append_stats(\"detailed\", strlen(\"detailed\"), dump_buf, len, c);\n                        free(dump_buf);\n                    }\n                } else if (strncmp(subcmd_pos, \" on\", 3) == 0) {\n                    settings.detail_enabled = 1;\n                } else if (strncmp(subcmd_pos, \" off\", 4) == 0) {\n                    settings.detail_enabled = 0;\n                } else {\n                    write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n                    return;\n                }\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n                return;\n            }\n        } else if (strncmp(subcommand, \"aggregate\", 9) == 0) {\n            server_stats(&append_stats, c, true);\n        } else if (strncmp(subcommand, \"topkeys\", 7) == 0) {\n            topkeys_t *tk = get_independent_stats(c)->topkeys;\n            if (tk != NULL) {\n                topkeys_stats(tk, c, current_time, append_stats);\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n                return;\n            }\n        } else {\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c,\n                                                subcommand, nkey,\n                                                append_stats);\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        append_stats(NULL, 0, NULL, 0, c);\n        write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n        c->dynamic_buffer.buffer = NULL;\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n}\n\nstatic void bin_read_chunk(conn *c, enum bin_substates next_substate, uint32_t chunk) {\n    assert(c);\n    c->substate = next_substate;\n    c->rlbytes = chunk;\n\n    /* Ok... do we have room for everything in our buffer? */\n    ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;\n    if (c->rlbytes > c->rsize - offset) {\n        size_t nsize = c->rsize;\n        size_t size = c->rlbytes + sizeof(protocol_binary_request_header);\n\n        while (size > nsize) {\n            nsize *= 2;\n        }\n\n        if (nsize != c->rsize) {\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                        \"%d: Need to grow buffer from %lu to %lu\\n\",\n                        c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);\n            }\n            char *newm = realloc(c->rbuf, nsize);\n            if (newm == NULL) {\n                if (settings.verbose) {\n                    settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                            \"%d: Failed to grow buffer.. closing connection\\n\",\n                            c->sfd);\n                }\n                conn_set_state(c, conn_closing);\n                return;\n            }\n\n            c->rbuf= newm;\n            /* rcurr should point to the same offset in the packet */\n            c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);\n            c->rsize = nsize;\n        }\n        if (c->rbuf != c->rcurr) {\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n            c->rcurr = c->rbuf;\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                \"%d: Repack input buffer\\n\",\n                                                c->sfd);\n            }\n        }\n    }\n\n    /* preserve the header in the buffer.. */\n    c->ritem = c->rcurr + sizeof(protocol_binary_request_header);\n    conn_set_state(c, conn_nread);\n}\n\nstatic void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {\n    bin_read_chunk(c, next_substate, c->keylen + extra);\n}\n\n\n/* Just write an error message and disconnect the client */\nstatic void handle_binary_protocol_error(conn *c) {\n    write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                \"%d: Protocol error (opcode %02x), close connection\\n\",\n                c->sfd, c->binary_header.request.opcode);\n    }\n    c->write_and_go = conn_closing;\n}\n\nstatic void init_sasl_conn(conn *c) {\n    assert(c);\n    if (!c->sasl_conn) {\n        int result=sasl_server_new(\"memcached\",\n                                   NULL, NULL, NULL, NULL,\n                                   NULL, 0, &c->sasl_conn);\n        if (result != SASL_OK) {\n            if (settings.verbose) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                         \"%d: Failed to initialize SASL conn.\\n\",\n                         c->sfd);\n            }\n            c->sasl_conn = NULL;\n        }\n    }\n}\n\nstatic void get_auth_data(const void *cookie, auth_data_t *data) {\n    conn *c = (conn*)cookie;\n    if (c->sasl_conn) {\n        sasl_getprop(c->sasl_conn, SASL_USERNAME, (void*)&data->username);\n#ifdef ENABLE_ISASL\n        sasl_getprop(c->sasl_conn, ISASL_CONFIG, (void*)&data->config);\n#endif\n    }\n}\n\n#ifdef SASL_ENABLED\nstatic void bin_list_sasl_mechs(conn *c) {\n    init_sasl_conn(c);\n    const char *result_string = NULL;\n    unsigned int string_length = 0;\n    int result=sasl_listmech(c->sasl_conn, NULL,\n                             \"\",   /* What to prepend the string with */\n                             \" \",  /* What to separate mechanisms with */\n                             \"\",   /* What to append to the string */\n                             &result_string, &string_length,\n                             NULL);\n    if (result != SASL_OK) {\n        /* Perhaps there's a better error for this... */\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                     \"%d: Failed to list SASL mechanisms.\\n\",\n                     c->sfd);\n        }\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        return;\n    }\n    write_bin_response(c, (char*)result_string, 0, 0, string_length);\n}\n#endif\n\nstruct sasl_tmp {\n    int ksize;\n    int vsize;\n    char data[]; /* data + ksize == value */\n};\n\nstatic void process_bin_sasl_auth(conn *c) {\n    assert(c->binary_header.request.extlen == 0);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    if (nkey > MAX_SASL_MECH_LEN) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    char *key = binary_get_key(c);\n    assert(key);\n\n    size_t buffer_size = sizeof(struct sasl_tmp) + nkey + vlen + 2;\n    struct sasl_tmp *data = calloc(sizeof(struct sasl_tmp) + buffer_size, 1);\n    if (!data) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    data->ksize = nkey;\n    data->vsize = vlen;\n    memcpy(data->data, key, nkey);\n\n    c->item = data;\n    c->ritem = data->data + nkey;\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_reading_sasl_auth_data;\n}\n\nstatic void process_bin_complete_sasl_auth(conn *c) {\n    const char *out = NULL;\n    unsigned int outlen = 0;\n\n    assert(c->item);\n    init_sasl_conn(c);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    struct sasl_tmp *stmp = c->item;\n    char mech[nkey+1];\n    memcpy(mech, stmp->data, nkey);\n    mech[nkey] = 0x00;\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                \"%d: mech: ``%s'' with %d bytes of data\\n\", c->sfd, mech, vlen);\n    }\n\n    const char *challenge = vlen == 0 ? NULL : (stmp->data + nkey);\n\n    int result=-1;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        result = sasl_server_start(c->sasl_conn, mech,\n                                   challenge, vlen,\n                                   &out, &outlen);\n        break;\n    case PROTOCOL_BINARY_CMD_SASL_STEP:\n        result = sasl_server_step(c->sasl_conn,\n                                  challenge, vlen,\n                                  &out, &outlen);\n        break;\n    default:\n        assert(false); /* CMD should be one of the above */\n        /* This code is pretty much impossible, but makes the compiler\n           happier */\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                    \"%d: Unhandled command %d with challenge %s\\n\",\n                    c->sfd, c->cmd, challenge);\n        }\n        break;\n    }\n\n    free(c->item);\n    c->item = NULL;\n    c->ritem = NULL;\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                        \"%d: sasl result code:  %d\\n\",\n                                        c->sfd, result);\n    }\n\n    switch(result) {\n    case SASL_OK:\n        write_bin_response(c, \"Authenticated\", 0, 0, strlen(\"Authenticated\"));\n        auth_data_t data;\n        get_auth_data(c, &data);\n        perform_callbacks(ON_AUTH, (const void*)&data, c);\n        STATS_NOKEY(c, auth_cmds);\n        break;\n    case SASL_CONTINUE:\n        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);\n        if(outlen > 0) {\n            add_iov(c, out, outlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n        break;\n    default:\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"%d: Unknown sasl response:  %d\\n\",\n                                            c->sfd, result);\n        }\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        STATS_NOKEY2(c, auth_cmds, auth_errors);\n    }\n}\n\nstatic bool authenticated(conn *c) {\n    bool rv = false;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */\n        rv = true;\n        break;\n    default:\n        if (c->sasl_conn) {\n            const void *uname = NULL;\n            sasl_getprop(c->sasl_conn, SASL_USERNAME, &uname);\n            rv = uname != NULL;\n        }\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                \"%d: authenticated() in cmd 0x%02x is %s\\n\",\n                c->sfd, c->cmd, rv ? \"true\" : \"false\");\n    }\n\n    return rv;\n}\n\nstatic bool binary_response_handler(const void *key, uint16_t keylen,\n                                    const void *ext, uint8_t extlen,\n                                    const void *body, uint32_t bodylen,\n                                    uint8_t datatype, uint16_t status,\n                                    uint64_t cas, const void *cookie)\n{\n    conn *c = (conn*)cookie;\n    /* Look at append_bin_stats */\n    size_t needed = keylen + extlen + bodylen + sizeof(protocol_binary_response_header);\n    if (!grow_dynamic_buffer(c, needed)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                    \"<%d ERROR: Failed to allocate memory for response\\n\",\n                    c->sfd);\n        }\n        return false;\n    }\n\n    char *buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = c->binary_header.request.opcode,\n        .response.keylen = (uint16_t)htons(keylen),\n        .response.extlen = extlen,\n        .response.datatype = datatype,\n        .response.status = (uint16_t)htons(status),\n        .response.bodylen = htonl(bodylen + keylen + extlen),\n        .response.opaque = c->opaque,\n        .response.cas = htonll(cas),\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (extlen > 0) {\n        memcpy(buf, ext, extlen);\n        buf += extlen;\n    }\n\n    if (keylen > 0) {\n        memcpy(buf, key, keylen);\n        buf += keylen;\n    }\n\n    if (bodylen > 0) {\n        memcpy(buf, body, bodylen);\n    }\n\n    c->dynamic_buffer.offset += needed;\n\n    return true;\n}\n\n/**\n * Tap stats (these are only used by the tap thread, so they don't need\n * to be in the threadlocal struct right now...\n */\nstruct tap_cmd_stats {\n    uint64_t connect;\n    uint64_t mutation;\n    uint64_t checkpoint_start;\n    uint64_t checkpoint_end;\n    uint64_t delete;\n    uint64_t flush;\n    uint64_t opaque;\n    uint64_t vbucket_set;\n};\n\nstruct tap_stats {\n    pthread_mutex_t mutex;\n    struct tap_cmd_stats sent;\n    struct tap_cmd_stats received;\n} tap_stats = { .mutex = PTHREAD_MUTEX_INITIALIZER };\n\nstatic void ship_tap_log(conn *c) {\n    assert(c->thread->type == TAP);\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"%d: Failed to create output headers. Shutting down tap connection\\n\", c->sfd);\n        }\n        conn_set_state(c, conn_closing);\n        return ;\n    }\n    /* @todo add check for buffer overflow of c->wbuf) */\n    c->wcurr = c->wbuf;\n\n    bool more_data = true;\n    bool send_data = false;\n    bool disconnect = false;\n\n    item *it;\n    uint32_t bodylen;\n    int ii = 0;\n    c->icurr = c->ilist;\n    do {\n        /* @todo fixme! */\n        if (ii++ == 10) {\n            break;\n        }\n\n        void *engine;\n        uint16_t nengine;\n        uint8_t ttl;\n        uint16_t tap_flags;\n        uint32_t seqno;\n        uint16_t vbucket;\n\n        tap_event_t event = c->tap_iterator(settings.engine.v0, c, &it,\n                                            &engine, &nengine, &ttl,\n                                            &tap_flags, &seqno, &vbucket);\n        union {\n            protocol_binary_request_tap_mutation mutation;\n            protocol_binary_request_tap_delete delete;\n            protocol_binary_request_tap_flush flush;\n            protocol_binary_request_tap_opaque opaque;\n            protocol_binary_request_noop noop;\n        } msg = {\n            .mutation.message.header.request.magic = (uint8_t)PROTOCOL_BINARY_REQ,\n        };\n\n        msg.opaque.message.header.request.opaque = htonl(seqno);\n        msg.opaque.message.body.tap.enginespecific_length = htons(nengine);\n        msg.opaque.message.body.tap.ttl = ttl;\n        msg.opaque.message.body.tap.flags = htons(tap_flags);\n        msg.opaque.message.header.request.extlen = 8;\n        msg.opaque.message.header.request.vbucket = htons(vbucket);\n        item_info info = { .nvalue = 1 };\n\n        switch (event) {\n        case TAP_NOOP :\n            send_data = true;\n            msg.noop.message.header.request.opcode = PROTOCOL_BINARY_CMD_NOOP;\n            msg.noop.message.header.request.extlen = 0;\n            msg.noop.message.header.request.bodylen = htonl(0);\n            memcpy(c->wcurr, msg.noop.bytes, sizeof(msg.noop.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.noop.bytes));\n            c->wcurr += sizeof(msg.noop.bytes);\n            c->wbytes += sizeof(msg.noop.bytes);\n            break;\n        case TAP_PAUSE :\n            more_data = false;\n            break;\n        case TAP_CHECKPOINT_START:\n        case TAP_CHECKPOINT_END:\n        case TAP_MUTATION:\n            if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: Failed to get item info\\n\", c->sfd);\n                break;\n            }\n            send_data = true;\n            c->ilist[c->ileft++] = it;\n\n            if (event == TAP_CHECKPOINT_START) {\n                msg.mutation.message.header.request.opcode =\n                    PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.checkpoint_start++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_CHECKPOINT_END) {\n                msg.mutation.message.header.request.opcode =\n                    PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.checkpoint_end++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_MUTATION) {\n                msg.mutation.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_MUTATION;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.mutation++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            }\n\n            msg.mutation.message.header.request.cas = htonll(info.cas);\n            msg.mutation.message.header.request.keylen = htons(info.nkey);\n            msg.mutation.message.header.request.extlen = 16;\n\n            bodylen = 16 + info.nkey + nengine;\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                bodylen += info.nbytes;\n            }\n            msg.mutation.message.header.request.bodylen = htonl(bodylen);\n            msg.mutation.message.body.item.flags = htonl(info.flags);\n            msg.mutation.message.body.item.expiration = htonl(info.exptime);\n            msg.mutation.message.body.tap.enginespecific_length = htons(nengine);\n            msg.mutation.message.body.tap.ttl = ttl;\n            msg.mutation.message.body.tap.flags = htons(tap_flags);\n            memcpy(c->wcurr, msg.mutation.bytes, sizeof(msg.mutation.bytes));\n\n            add_iov(c, c->wcurr, sizeof(msg.mutation.bytes));\n            c->wcurr += sizeof(msg.mutation.bytes);\n            c->wbytes += sizeof(msg.mutation.bytes);\n\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n\n            add_iov(c, info.key, info.nkey);\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n            }\n\n            break;\n        case TAP_DELETION:\n            /* This is a delete */\n            if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: Failed to get item info\\n\", c->sfd);\n                break;\n            }\n            send_data = true;\n            c->ilist[c->ileft++] = it;\n            msg.delete.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_DELETE;\n            msg.delete.message.header.request.cas = htonll(info.cas);\n            msg.delete.message.header.request.keylen = htons(info.nkey);\n\n            bodylen = 8 + info.nkey + nengine;\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                bodylen += info.nbytes;\n            }\n            msg.delete.message.header.request.bodylen = htonl(bodylen);\n\n            memcpy(c->wcurr, msg.delete.bytes, sizeof(msg.delete.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.delete.bytes));\n            c->wcurr += sizeof(msg.delete.bytes);\n            c->wbytes += sizeof(msg.delete.bytes);\n\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n\n            add_iov(c, info.key, info.nkey);\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n            }\n\n            pthread_mutex_lock(&tap_stats.mutex);\n            tap_stats.sent.delete++;\n            pthread_mutex_unlock(&tap_stats.mutex);\n            break;\n\n        case TAP_DISCONNECT:\n            disconnect = true;\n            more_data = false;\n            break;\n        case TAP_VBUCKET_SET:\n        case TAP_FLUSH:\n        case TAP_OPAQUE:\n            send_data = true;\n\n            if (event == TAP_OPAQUE) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_OPAQUE;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.opaque++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n\n            } else if (event == TAP_FLUSH) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_FLUSH;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.flush++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_VBUCKET_SET) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET;\n                msg.flush.message.body.tap.flags = htons(tap_flags);\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.vbucket_set++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            }\n\n            msg.flush.message.header.request.bodylen = htonl(8 + nengine);\n            memcpy(c->wcurr, msg.flush.bytes, sizeof(msg.flush.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.flush.bytes));\n            c->wcurr += sizeof(msg.flush.bytes);\n            c->wbytes += sizeof(msg.flush.bytes);\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n            break;\n        default:\n            abort();\n        }\n    } while (more_data);\n\n    c->ewouldblock = false;\n    if (send_data) {\n        conn_set_state(c, conn_mwrite);\n        if (disconnect) {\n            c->write_and_go = conn_closing;\n        } else {\n            c->write_and_go = conn_ship_log;\n        }\n    } else {\n        if (disconnect) {\n            conn_set_state(c, conn_closing);\n        } else {\n            /* No more items to ship to the slave at this time.. suspend.. */\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                \"%d: No more items in tap log.. waiting\\n\",\n                                                c->sfd);\n            }\n            c->ewouldblock = true;\n        }\n    }\n}\n\nstatic void process_bin_unknown_packet(conn *c) {\n    void *packet = c->rcurr - (c->binary_header.request.bodylen +\n                               sizeof(c->binary_header));\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->unknown_command(settings.engine.v0, c, packet,\n                                                  binary_response_handler);\n    }\n\n    if (ret == ENGINE_SUCCESS) {\n        if (c->dynamic_buffer.buffer != NULL) {\n            write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n            c->dynamic_buffer.buffer = NULL;\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n    } else if (ret == ENGINE_ENOTSUP) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, 0);\n    } else if (ret == ENGINE_EWOULDBLOCK) {\n        c->ewouldblock = true;\n    } else {\n        /* FATAL ERROR, shut down connection */\n        conn_set_state(c, conn_closing);\n    }\n}\n\nstatic void process_bin_tap_connect(conn *c) {\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_tap_connect *req = (void*)packet;\n    const char *key = packet + sizeof(req->bytes);\n    const char *data = key + c->binary_header.request.keylen;\n    uint32_t flags = 0;\n    size_t ndata = c->binary_header.request.bodylen -\n        c->binary_header.request.extlen -\n        c->binary_header.request.keylen;\n\n    if (c->binary_header.request.extlen == 4) {\n        flags = ntohl(req->message.body.flags);\n\n        if (flags & TAP_CONNECT_FLAG_BACKFILL) {\n            /* the userdata has to be at least 8 bytes! */\n            if (ndata < 8) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: ERROR: Invalid tap connect message\\n\",\n                                                c->sfd);\n                conn_set_state(c, conn_closing);\n                return ;\n            }\n        }\n    } else {\n        data -= 4;\n        key -= 4;\n    }\n\n    if (settings.verbose && c->binary_header.request.keylen > 0) {\n        char buffer[1024];\n        int len = c->binary_header.request.keylen;\n        if (len >= sizeof(buffer)) {\n            len = sizeof(buffer) - 1;\n        }\n        memcpy(buffer, key, len);\n        buffer[len] = '\\0';\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"%d: Trying to connect with named tap connection: <%s>\\n\",\n                                        c->sfd, buffer);\n    }\n\n    TAP_ITERATOR iterator = settings.engine.v1->get_tap_iterator(\n        settings.engine.v0, c, key, c->binary_header.request.keylen,\n        flags, data, ndata);\n\n    if (iterator == NULL) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: FATAL: The engine does not support tap\\n\",\n                                        c->sfd);\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        c->write_and_go = conn_closing;\n    } else {\n        c->tap_iterator = iterator;\n        c->which = EV_WRITE;\n        conn_set_state(c, conn_ship_log);\n    }\n}\n\nstatic void process_bin_tap_packet(tap_event_t event, conn *c) {\n    assert(c != NULL);\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_tap_no_extras *tap = (void*)packet;\n    uint16_t nengine = ntohs(tap->message.body.tap.enginespecific_length);\n    uint16_t tap_flags = ntohs(tap->message.body.tap.flags);\n    uint32_t seqno = ntohl(tap->message.header.request.opaque);\n    uint8_t ttl = tap->message.body.tap.ttl;\n    assert(ttl > 0);\n    char *engine_specific = packet + sizeof(tap->bytes);\n    char *key = engine_specific + nengine;\n    uint16_t nkey = c->binary_header.request.keylen;\n    char *data = key + nkey;\n    uint32_t flags = 0;\n    uint32_t exptime = 0;\n    uint32_t ndata = c->binary_header.request.bodylen - nengine - nkey - 8;\n\n    if (event == TAP_MUTATION || event == TAP_CHECKPOINT_START ||\n        event == TAP_CHECKPOINT_END) {\n        protocol_binary_request_tap_mutation *mutation = (void*)tap;\n        flags = ntohl(mutation->message.body.item.flags);\n        exptime = ntohl(mutation->message.body.item.expiration);\n        key += 8;\n        data += 8;\n        ndata -= 8;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->tap_notify(settings.engine.v0, c,\n                                             engine_specific, nengine,\n                                             ttl - 1, tap_flags,\n                                             event, seqno,\n                                             key, nkey,\n                                             flags, exptime,\n                                             ntohll(tap->message.header.request.cas),\n                                             data, ndata,\n                                             c->binary_header.request.vbucket);\n    }\n\n    switch (ret) {\n    case ENGINE_DISCONNECT:\n        conn_set_state(c, conn_closing);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        if ((tap_flags & TAP_FLAG_ACK) ||\n            (ret != ENGINE_SUCCESS && c->tap_nack_mode))\n        {\n            write_bin_packet(c, engine_error_2_protocol_error(ret), 0);\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n    }\n}\n\nstatic void process_bin_tap_ack(conn *c) {\n    assert(c != NULL);\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_response_no_extras *rsp = (void*)packet;\n    uint32_t seqno = ntohl(rsp->message.header.response.opaque);\n    uint16_t status = ntohs(rsp->message.header.response.status);\n    char *key = packet + sizeof(rsp->bytes);\n\n    ENGINE_ERROR_CODE ret = ENGINE_DISCONNECT;\n    if (settings.engine.v1->tap_notify != NULL) {\n        ret = settings.engine.v1->tap_notify(settings.engine.v0, c, NULL, 0, 0, status,\n                                             TAP_ACK, seqno, key,\n                                             c->binary_header.request.keylen, 0, 0,\n                                             0, NULL, 0, 0);\n    }\n\n    if (ret == ENGINE_DISCONNECT) {\n        conn_set_state(c, conn_closing);\n    } else {\n        conn_set_state(c, conn_ship_log);\n    }\n}\n\n/**\n * We received a noop response.. just ignore it\n */\nstatic void process_bin_noop_response(conn *c) {\n    assert(c != NULL);\n    conn_set_state(c, conn_new_cmd);\n}\n\nstatic void process_bin_verbosity(conn *c) {\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_verbosity *req = (void*)packet;\n    uint32_t level = (uint32_t)ntohl(req->message.body.level);\n    if (level > MAX_VERBOSITY_LEVEL) {\n        level = MAX_VERBOSITY_LEVEL;\n    }\n    settings.verbose = (int)level;\n    perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n    write_bin_response(c, NULL, 0, 0, 0);\n}\n\nstatic void process_bin_packet(conn *c) {\n    /* @todo this should be an array of funciton pointers and call through */\n    switch (c->binary_header.request.opcode) {\n    case PROTOCOL_BINARY_CMD_TAP_CONNECT:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.connect++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        conn_set_state(c, conn_add_tap_client);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_MUTATION:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.mutation++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_MUTATION, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.checkpoint_start++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_CHECKPOINT_START, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.checkpoint_end++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_CHECKPOINT_END, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_DELETE:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.delete++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_DELETION, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_FLUSH:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.flush++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_FLUSH, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_OPAQUE:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.opaque++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_OPAQUE, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.vbucket_set++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_VBUCKET_SET, c);\n        break;\n    case PROTOCOL_BINARY_CMD_VERBOSITY:\n        process_bin_verbosity(c);\n        break;\n    default:\n        process_bin_unknown_packet(c);\n    }\n}\n\n\n\ntypedef void (*RESPONSE_HANDLER)(conn*);\n/**\n * A map between the response packets op-code and the function to handle\n * the response message.\n */\nstatic RESPONSE_HANDLER response_handlers[256] = {\n    [PROTOCOL_BINARY_CMD_NOOP] = process_bin_noop_response,\n    [PROTOCOL_BINARY_CMD_TAP_MUTATION] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_DELETE] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_FLUSH] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_OPAQUE] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END] = process_bin_tap_ack\n};\n\nstatic void dispatch_bin_command(conn *c) {\n    int protocol_error = 0;\n\n    int extlen = c->binary_header.request.extlen;\n    uint16_t keylen = c->binary_header.request.keylen;\n    uint32_t bodylen = c->binary_header.request.bodylen;\n\n    if (settings.require_sasl && !authenticated(c)) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        c->write_and_go = conn_closing;\n        return;\n    }\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n    c->noreply = true;\n\n    /* binprot supports 16bit keys, but internals are still 8bit */\n    if (keylen > KEY_MAX_LENGTH) {\n        handle_binary_protocol_error(c);\n        return;\n    }\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_SET;\n        break;\n    case PROTOCOL_BINARY_CMD_ADDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_ADD;\n        break;\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;\n        break;\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DELETE;\n        break;\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_QUITQ:\n        c->cmd = PROTOCOL_BINARY_CMD_QUIT;\n        break;\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;\n        break;\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_APPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_GETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GET;\n        break;\n    case PROTOCOL_BINARY_CMD_GETKQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GETK;\n        break;\n    default:\n        c->noreply = false;\n    }\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_VERSION:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_FLUSH:\n            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {\n                bin_read_key(c, bin_read_flush_exptime, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_NOOP:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {\n                bin_read_key(c, bin_reading_set_header, 8);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETK:\n            if (extlen == 0 && bodylen == keylen && keylen > 0) {\n                bin_read_key(c, bin_reading_get_key, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_DELETE:\n            if (keylen > 0 && extlen == 0 && bodylen == keylen) {\n                bin_read_key(c, bin_reading_del_header, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_INCREMENT:\n        case PROTOCOL_BINARY_CMD_DECREMENT:\n            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {\n                bin_read_key(c, bin_reading_incr_header, 20);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_APPEND:\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            if (keylen > 0 && extlen == 0) {\n                bin_read_key(c, bin_reading_set_header, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_STAT:\n            if (extlen == 0) {\n                bin_read_key(c, bin_reading_stat, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_QUIT:\n            if (keylen == 0 && extlen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n                c->write_and_go = conn_closing;\n                if (c->noreply) {\n                    conn_set_state(c, conn_closing);\n                }\n            } else {\n                protocol_error = 1;\n            }\n            break;\n       case PROTOCOL_BINARY_CMD_TAP_CONNECT:\n            if (settings.engine.v1->get_tap_iterator == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet,\n                               c->binary_header.request.bodylen);\n            }\n            break;\n       case PROTOCOL_BINARY_CMD_TAP_MUTATION:\n       case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START:\n       case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END:\n       case PROTOCOL_BINARY_CMD_TAP_DELETE:\n       case PROTOCOL_BINARY_CMD_TAP_FLUSH:\n       case PROTOCOL_BINARY_CMD_TAP_OPAQUE:\n       case PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET:\n            if (settings.engine.v1->tap_notify == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet, c->binary_header.request.bodylen);\n            }\n            break;\n#ifdef SASL_ENABLED\n        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                bin_list_sasl_mechs(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        case PROTOCOL_BINARY_CMD_SASL_STEP:\n            if (extlen == 0 && keylen != 0) {\n                bin_read_key(c, bin_reading_sasl_auth, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n#endif\n        case PROTOCOL_BINARY_CMD_VERBOSITY:\n            if (extlen == 4 && keylen == 0 && bodylen == 4) {\n                bin_read_chunk(c, bin_reading_packet,\n                               c->binary_header.request.bodylen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        default:\n            if (settings.engine.v1->unknown_command == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND,\n                                bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet, c->binary_header.request.bodylen);\n            }\n    }\n\n    if (protocol_error)\n        handle_binary_protocol_error(c);\n}\n\nstatic void process_bin_update(conn *c) {\n    char *key;\n    uint16_t nkey;\n    uint32_t vlen;\n    item *it = NULL;\n    protocol_binary_request_set* req = binary_get_request(c);\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n\n    /* fix byteorder in the request */\n    req->message.body.flags = req->message.body.flags;\n    rel_time_t expiration = ntohl(req->message.body.expiration);\n\n    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        const char *prefix;\n        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {\n            prefix = \"ADD\";\n        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            prefix = \"SET\";\n        } else {\n            prefix = \"REPLACE\";\n        }\n\n        size_t nw;\n        nw = key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                     prefix, key, nkey);\n\n        if (nw != -1) {\n            if (snprintf(buffer + nw, sizeof(buffer) - nw,\n                         \" Value len is %d\\n\", vlen)) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\",\n                                                buffer);\n            }\n        }\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    item_info info = { .nvalue = 1 };\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen,\n                                           req->message.body.flags,\n                                           expiration);\n        if (ret == ENGINE_SUCCESS && !settings.engine.v1->get_item_info(settings.engine.v0,\n                                                                        c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            return;\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, c->binary_header.request.cas);\n\n        switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_ADD:\n            c->store_op = OPERATION_ADD;\n            break;\n        case PROTOCOL_BINARY_CMD_SET:\n            c->store_op = OPERATION_SET;\n            break;\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            c->store_op = OPERATION_REPLACE;\n            break;\n        default:\n            assert(0);\n        }\n\n        if (c->binary_header.request.cas != 0) {\n            c->store_op = OPERATION_CAS;\n        }\n\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        conn_set_state(c, conn_nread);\n        c->substate = bin_read_set_value;\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n\n        /*\n         * Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET (but only if cas matches).\n         * Anywhere else too?\n         */\n        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            /* @todo fix this for the ASYNC interface! */\n            settings.engine.v1->remove(settings.engine.v0, c, key, nkey,\n                                       ntohll(req->message.header.request.cas),\n                                       c->binary_header.request.vbucket);\n        }\n\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n    }\n}\n\nstatic void process_bin_append_prepend(conn *c) {\n    char *key;\n    int nkey;\n    int vlen;\n    item *it = NULL;\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n    vlen = c->binary_header.request.bodylen - nkey;\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"Value len is %d\\n\", vlen);\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    item_info info = { .nvalue = 1 };\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen, 0, 0);\n        if (ret == ENGINE_SUCCESS && !settings.engine.v1->get_item_info(settings.engine.v0,\n                                                                        c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            return;\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, c->binary_header.request.cas);\n\n        switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_APPEND:\n            c->store_op = OPERATION_APPEND;\n            break;\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            c->store_op = OPERATION_PREPEND;\n            break;\n        default:\n            assert(0);\n        }\n\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        conn_set_state(c, conn_nread);\n        c->substate = bin_read_set_value;\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n    }\n}\n\nstatic void process_bin_flush(conn *c) {\n    time_t exptime = 0;\n    protocol_binary_request_flush* req = binary_get_request(c);\n\n    if (c->binary_header.request.extlen == sizeof(req->message.body)) {\n        exptime = ntohl(req->message.body.expiration);\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"%d: flush %ld\", c->sfd,\n                                        (long)exptime);\n    }\n\n    ENGINE_ERROR_CODE ret;\n    ret = settings.engine.v1->flush(settings.engine.v0, c, exptime);\n\n    if (ret == ENGINE_SUCCESS) {\n        write_bin_response(c, NULL, 0, 0, 0);\n    } else if (ret == ENGINE_ENOTSUP) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n    } else {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n    STATS_NOKEY(c, cmd_flush);\n}\n\nstatic void process_bin_delete(conn *c) {\n    protocol_binary_request_delete* req = binary_get_request(c);\n\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    assert(c != NULL);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"DELETE\", key, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        if (settings.detail_enabled) {\n            stats_prefix_record_delete(key, nkey);\n        }\n        ret = settings.engine.v1->remove(settings.engine.v0, c, key, nkey,\n                                         ntohll(req->message.header.request.cas),\n                                         c->binary_header.request.vbucket);\n    }\n\n    /* For some reason the SLAB_INCR tries to access this... */\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        write_bin_response(c, NULL, 0, 0, 0);\n        SLAB_INCR(c, delete_hits, key, nkey);\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        STATS_INCR(c, delete_misses, key, nkey);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n}\n\nstatic void complete_nread_binary(conn *c) {\n    assert(c != NULL);\n    assert(c->cmd >= 0);\n\n    switch(c->substate) {\n    case bin_reading_set_header:\n        if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||\n                c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {\n            process_bin_append_prepend(c);\n        } else {\n            process_bin_update(c);\n        }\n        break;\n    case bin_read_set_value:\n        complete_update_bin(c);\n        break;\n    case bin_reading_get_key:\n        process_bin_get(c);\n        break;\n    case bin_reading_stat:\n        process_bin_stat(c);\n        break;\n    case bin_reading_del_header:\n        process_bin_delete(c);\n        break;\n    case bin_reading_incr_header:\n        complete_incr_bin(c);\n        break;\n    case bin_read_flush_exptime:\n        process_bin_flush(c);\n        break;\n    case bin_reading_sasl_auth:\n        process_bin_sasl_auth(c);\n        break;\n    case bin_reading_sasl_auth_data:\n        process_bin_complete_sasl_auth(c);\n        break;\n    case bin_reading_packet:\n        if (c->binary_header.request.magic == PROTOCOL_BINARY_RES) {\n            RESPONSE_HANDLER handler;\n            handler = response_handlers[c->binary_header.request.opcode];\n            if (handler) {\n                handler(c);\n            } else {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                       \"%d: ERROR: Unsupported response packet received: %u\\n\",\n                        c->sfd, (unsigned int)c->binary_header.request.opcode);\n                conn_set_state(c, conn_closing);\n            }\n        } else {\n            process_bin_packet(c);\n        }\n        break;\n    default:\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                \"Not handling substate %d\\n\", c->substate);\n        abort();\n    }\n}\n\nstatic void reset_cmd_handler(conn *c) {\n    c->sbytes = 0;\n    c->ascii_cmd = NULL;\n    c->cmd = -1;\n    c->substate = bin_no_state;\n    if(c->item != NULL) {\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = NULL;\n    }\n    conn_shrink(c);\n    if (c->rbytes > 0) {\n        conn_set_state(c, conn_parse_cmd);\n    } else {\n        conn_set_state(c, conn_waiting);\n    }\n}\n\nstatic ENGINE_ERROR_CODE ascii_response_handler(const void *cookie,\n                                                int nbytes,\n                                                const char *dta)\n{\n    conn *c = (conn*)cookie;\n    if (!grow_dynamic_buffer(c, nbytes)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                    \"<%d ERROR: Failed to allocate memory for response\\n\",\n                    c->sfd);\n        }\n        return ENGINE_ENOMEM;\n    }\n\n    char *buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    memcpy(buf, dta, nbytes);\n    c->dynamic_buffer.offset += nbytes;\n\n    return ENGINE_SUCCESS;\n}\n\nstatic void complete_nread_ascii(conn *c) {\n    if (c->ascii_cmd != NULL) {\n        c->ewouldblock = false;\n        switch (c->ascii_cmd->execute(c->ascii_cmd->cookie, c, 0, NULL,\n                                      ascii_response_handler)) {\n        case ENGINE_SUCCESS:\n            if (c->dynamic_buffer.buffer != NULL) {\n                write_and_free(c, c->dynamic_buffer.buffer,\n                               c->dynamic_buffer.offset);\n                c->dynamic_buffer.buffer = NULL;\n            } else {\n                conn_set_state(c, conn_new_cmd);\n            }\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            break;\n        case ENGINE_DISCONNECT:\n        default:\n            conn_set_state(c, conn_closing);\n        }\n    } else {\n        complete_update_ascii(c);\n    }\n}\n\nstatic void complete_nread(conn *c) {\n    assert(c != NULL);\n    assert(c->protocol == ascii_prot\n           || c->protocol == binary_prot);\n\n    if (c->protocol == ascii_prot) {\n        complete_nread_ascii(c);\n    } else if (c->protocol == binary_prot) {\n        complete_nread_binary(c);\n    }\n}\n\n#define COMMAND_TOKEN 0\n#define SUBCOMMAND_TOKEN 1\n#define KEY_TOKEN 1\n\n#define MAX_TOKENS 30\n\n/*\n * Tokenize the command string by replacing whitespace with '\\0' and update\n * the token array tokens with pointer to start of each token and length.\n * Returns total number of tokens.  The last valid token is the terminal\n * token (value points to the first unprocessed character of the string and\n * length zero).\n *\n * Usage example:\n *\n *  while(tokenize_command(command, ncommand, tokens, max_tokens) > 0) {\n *      for(int ix = 0; tokens[ix].length != 0; ix++) {\n *          ...\n *      }\n *      ncommand = tokens[ix].value - command;\n *      command  = tokens[ix].value;\n *   }\n */\nstatic size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {\n    char *s, *e;\n    size_t ntokens = 0;\n\n    assert(command != NULL && tokens != NULL && max_tokens > 1);\n\n    for (s = e = command; ntokens < max_tokens - 1; ++e) {\n        if (*e == ' ') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n                *e = '\\0';\n            }\n            s = e + 1;\n        }\n        else if (*e == '\\0') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n            }\n\n            break; /* string end */\n        }\n    }\n\n    /*\n     * If we scanned the whole string, the terminal value pointer is null,\n     * otherwise it is the first unprocessed character.\n     */\n    tokens[ntokens].value =  *e == '\\0' ? NULL : e;\n    tokens[ntokens].length = 0;\n    ntokens++;\n\n    return ntokens;\n}\n\n#ifdef INNODB_MEMCACHED\nstatic void detokenize(token_t *tokens, size_t ntokens, char **out, int *nbytes)\n#else\nstatic void detokenize(token_t *tokens, int ntokens, char **out, int *nbytes)\n#endif\n{\n    int i, nb;\n    char *buf, *p;\n\n    nb = ntokens; // account for spaces, which is ntokens-1, plus the null\n    for (i = 0; i < ntokens; ++i) {\n        nb += tokens[i].length;\n    }\n\n    buf = malloc(nb * sizeof(char));\n    if (buf != NULL) {\n        p = buf;\n        for (i = 0; i < ntokens; ++i) {\n            memcpy(p, tokens[i].value, tokens[i].length);\n            p += tokens[i].length;\n            *p = ' ';\n            p++;\n        }\n        buf[nb - 1] = '\\0';\n        *nbytes = nb - 1;\n        *out = buf;\n    }\n}\n\n\n/* set up a connection to write a buffer then free it, used for stats */\nstatic void write_and_free(conn *c, char *buf, int bytes) {\n    if (buf) {\n        c->write_and_free = buf;\n        c->wcurr = buf;\n        c->wbytes = bytes;\n        conn_set_state(c, conn_write);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    }\n}\n\nstatic inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)\n{\n    int noreply_index = ntokens - 2;\n\n    /*\n      NOTE: this function is not the first place where we are going to\n      send the reply.  We could send it instead from process_command()\n      if the request line has wrong number of tokens.  However parsing\n      malformed line for \"noreply\" option is not reliable anyway, so\n      it can't be helped.\n    */\n    if (tokens[noreply_index].value\n        && strcmp(tokens[noreply_index].value, \"noreply\") == 0) {\n        c->noreply = true;\n    }\n    return c->noreply;\n}\n\nvoid append_stat(const char *name, ADD_STAT add_stats, conn *c,\n                 const char *fmt, ...) {\n    char val_str[STAT_VAL_LEN];\n    int vlen;\n    va_list ap;\n\n    assert(name);\n    assert(add_stats);\n    assert(c);\n    assert(fmt);\n\n    va_start(ap, fmt);\n    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);\n    va_end(ap);\n\n    add_stats(name, strlen(name), val_str, vlen, c);\n}\n\ninline static void process_stats_detail(conn *c, const char *command) {\n    assert(c != NULL);\n\n    if (settings.allow_detailed) {\n        if (strcmp(command, \"on\") == 0) {\n            settings.detail_enabled = 1;\n            out_string(c, \"OK\");\n        }\n        else if (strcmp(command, \"off\") == 0) {\n            settings.detail_enabled = 0;\n            out_string(c, \"OK\");\n        }\n        else if (strcmp(command, \"dump\") == 0) {\n            int len;\n            char *stats = stats_prefix_dump(&len);\n            write_and_free(c, stats, len);\n        }\n        else {\n            out_string(c, \"CLIENT_ERROR usage: stats detail on|off|dump\");\n        }\n    }\n    else {\n        out_string(c, \"CLIENT_ERROR detailed stats disabled\");\n    }\n}\n\nstatic void aggregate_callback(void *in, void *out) {\n    struct thread_stats *out_thread_stats = out;\n    struct independent_stats *in_independent_stats = in;\n    threadlocal_stats_aggregate(in_independent_stats->thread_stats,\n                                out_thread_stats);\n}\n\n/* return server specific stats only */\nstatic void server_stats(ADD_STAT add_stats, conn *c, bool aggregate) {\n    pid_t pid = getpid();\n    rel_time_t now = current_time;\n\n    struct thread_stats thread_stats;\n    threadlocal_stats_clear(&thread_stats);\n\n    if (aggregate && settings.engine.v1->aggregate_stats != NULL) {\n        settings.engine.v1->aggregate_stats(settings.engine.v0,\n                                            (const void *)c,\n                                            aggregate_callback,\n                                            &thread_stats);\n    } else {\n        threadlocal_stats_aggregate(get_independent_stats(c)->thread_stats,\n                                    &thread_stats);\n    }\n\n    struct slab_stats slab_stats;\n    slab_stats_aggregate(&thread_stats, &slab_stats);\n\n#ifndef __WIN32__\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n#endif\n\n    STATS_LOCK();\n\n    APPEND_STAT(\"pid\", \"%lu\", (long)pid);\n    APPEND_STAT(\"uptime\", \"%u\", now);\n    APPEND_STAT(\"time\", \"%ld\", now + (long)process_started);\n    APPEND_STAT(\"version\", \"%s\", VERSION);\n    APPEND_STAT(\"libevent\", \"%s\", event_get_version());\n    APPEND_STAT(\"pointer_size\", \"%d\", (int)(8 * sizeof(void *)));\n\n#ifndef __WIN32__\n    append_stat(\"rusage_user\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_utime.tv_sec,\n                (long)usage.ru_utime.tv_usec);\n    append_stat(\"rusage_system\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_stime.tv_sec,\n                (long)usage.ru_stime.tv_usec);\n#endif\n\n    APPEND_STAT(\"daemon_connections\", \"%u\", stats.daemon_conns);\n    APPEND_STAT(\"curr_connections\", \"%u\", stats.curr_conns);\n    APPEND_STAT(\"total_connections\", \"%u\", stats.total_conns);\n    APPEND_STAT(\"connection_structures\", \"%u\", stats.conn_structs);\n    APPEND_STAT(\"cmd_get\", \"%\"PRIu64, thread_stats.cmd_get);\n    APPEND_STAT(\"cmd_set\", \"%\"PRIu64, slab_stats.cmd_set);\n    APPEND_STAT(\"cmd_flush\", \"%\"PRIu64, thread_stats.cmd_flush);\n    APPEND_STAT(\"auth_cmds\", \"%\"PRIu64, thread_stats.auth_cmds);\n    APPEND_STAT(\"auth_errors\", \"%\"PRIu64, thread_stats.auth_errors);\n    APPEND_STAT(\"get_hits\", \"%\"PRIu64, slab_stats.get_hits);\n    APPEND_STAT(\"get_misses\", \"%\"PRIu64, thread_stats.get_misses);\n    APPEND_STAT(\"delete_misses\", \"%\"PRIu64, thread_stats.delete_misses);\n    APPEND_STAT(\"delete_hits\", \"%\"PRIu64, slab_stats.delete_hits);\n    APPEND_STAT(\"incr_misses\", \"%\"PRIu64, thread_stats.incr_misses);\n    APPEND_STAT(\"incr_hits\", \"%\"PRIu64, thread_stats.incr_hits);\n    APPEND_STAT(\"decr_misses\", \"%\"PRIu64, thread_stats.decr_misses);\n    APPEND_STAT(\"decr_hits\", \"%\"PRIu64, thread_stats.decr_hits);\n    APPEND_STAT(\"cas_misses\", \"%\"PRIu64, thread_stats.cas_misses);\n    APPEND_STAT(\"cas_hits\", \"%\"PRIu64, slab_stats.cas_hits);\n    APPEND_STAT(\"cas_badval\", \"%\"PRIu64, slab_stats.cas_badval);\n    APPEND_STAT(\"bytes_read\", \"%\"PRIu64, thread_stats.bytes_read);\n    APPEND_STAT(\"bytes_written\", \"%\"PRIu64, thread_stats.bytes_written);\n    APPEND_STAT(\"limit_maxbytes\", \"%\"PRIu64, settings.maxbytes);\n    APPEND_STAT(\"accepting_conns\", \"%u\",  is_listen_disabled() ? 0 : 1);\n    APPEND_STAT(\"listen_disabled_num\", \"%\"PRIu64, get_listen_disabled_num());\n    APPEND_STAT(\"rejected_conns\", \"%\" PRIu64, (unsigned long long)stats.rejected_conns);\n    APPEND_STAT(\"threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"conn_yields\", \"%\" PRIu64, (unsigned long long)thread_stats.conn_yields);\n    STATS_UNLOCK();\n\n    /*\n     * Add tap stats (only if non-zero)\n     */\n    struct tap_stats ts;\n    pthread_mutex_lock(&tap_stats.mutex);\n    ts = tap_stats;\n    pthread_mutex_unlock(&tap_stats.mutex);\n\n    if (ts.sent.connect) {\n        APPEND_STAT(\"tap_connect_sent\", \"%\"PRIu64, ts.sent.connect);\n    }\n    if (ts.sent.mutation) {\n        APPEND_STAT(\"tap_mutation_sent\", \"%\"PRIu64, ts.sent.mutation);\n    }\n    if (ts.sent.checkpoint_start) {\n        APPEND_STAT(\"tap_checkpoint_start_sent\", \"%\"PRIu64, ts.sent.checkpoint_start);\n    }\n    if (ts.sent.checkpoint_end) {\n        APPEND_STAT(\"tap_checkpoint_end_sent\", \"%\"PRIu64, ts.sent.checkpoint_end);\n    }\n    if (ts.sent.delete) {\n        APPEND_STAT(\"tap_delete_sent\", \"%\"PRIu64, ts.sent.delete);\n    }\n    if (ts.sent.flush) {\n        APPEND_STAT(\"tap_flush_sent\", \"%\"PRIu64, ts.sent.flush);\n    }\n    if (ts.sent.opaque) {\n        APPEND_STAT(\"tap_opaque_sent\", \"%\"PRIu64, ts.sent.opaque);\n    }\n    if (ts.sent.vbucket_set) {\n        APPEND_STAT(\"tap_vbucket_set_sent\", \"%\"PRIu64,\n                    ts.sent.vbucket_set);\n    }\n    if (ts.received.connect) {\n        APPEND_STAT(\"tap_connect_received\", \"%\"PRIu64, ts.received.connect);\n    }\n    if (ts.received.mutation) {\n        APPEND_STAT(\"tap_mutation_received\", \"%\"PRIu64, ts.received.mutation);\n    }\n    if (ts.received.checkpoint_start) {\n        APPEND_STAT(\"tap_checkpoint_start_received\", \"%\"PRIu64, ts.received.checkpoint_start);\n    }\n    if (ts.received.checkpoint_end) {\n        APPEND_STAT(\"tap_checkpoint_end_received\", \"%\"PRIu64, ts.received.checkpoint_end);\n    }\n    if (ts.received.delete) {\n        APPEND_STAT(\"tap_delete_received\", \"%\"PRIu64, ts.received.delete);\n    }\n    if (ts.received.flush) {\n        APPEND_STAT(\"tap_flush_received\", \"%\"PRIu64, ts.received.flush);\n    }\n    if (ts.received.opaque) {\n        APPEND_STAT(\"tap_opaque_received\", \"%\"PRIu64, ts.received.opaque);\n    }\n    if (ts.received.vbucket_set) {\n        APPEND_STAT(\"tap_vbucket_set_received\", \"%\"PRIu64,\n                    ts.received.vbucket_set);\n    }\n}\n\nstatic void process_stat_settings(ADD_STAT add_stats, void *c) {\n    assert(add_stats);\n    APPEND_STAT(\"maxbytes\", \"%u\", (unsigned int)settings.maxbytes);\n    APPEND_STAT(\"maxconns\", \"%d\", settings.maxconns);\n    APPEND_STAT(\"tcpport\", \"%d\", settings.port);\n    APPEND_STAT(\"udpport\", \"%d\", settings.udpport);\n    APPEND_STAT(\"inter\", \"%s\", settings.inter ? settings.inter : \"NULL\");\n    APPEND_STAT(\"verbosity\", \"%d\", settings.verbose);\n    APPEND_STAT(\"oldest\", \"%lu\", (unsigned long)settings.oldest_live);\n    APPEND_STAT(\"evictions\", \"%s\", settings.evict_to_free ? \"on\" : \"off\");\n    APPEND_STAT(\"domain_socket\", \"%s\",\n                settings.socketpath ? settings.socketpath : \"NULL\");\n    APPEND_STAT(\"umask\", \"%o\", settings.access);\n    APPEND_STAT(\"growth_factor\", \"%.2f\", settings.factor);\n    APPEND_STAT(\"chunk_size\", \"%d\", settings.chunk_size);\n    APPEND_STAT(\"num_threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"num_threads_per_udp\", \"%d\", settings.num_threads_per_udp);\n    APPEND_STAT(\"stat_key_prefix\", \"%c\", settings.prefix_delimiter);\n    APPEND_STAT(\"detail_enabled\", \"%s\",\n                settings.detail_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"allow_detailed\", \"%s\",\n                settings.allow_detailed ? \"yes\" : \"no\");\n    APPEND_STAT(\"reqs_per_event\", \"%d\", settings.reqs_per_event);\n    APPEND_STAT(\"reqs_per_tap_event\", \"%d\", settings.reqs_per_tap_event);\n    APPEND_STAT(\"cas_enabled\", \"%s\", settings.use_cas ? \"yes\" : \"no\");\n    APPEND_STAT(\"tcp_backlog\", \"%d\", settings.backlog);\n    APPEND_STAT(\"binding_protocol\", \"%s\",\n                prot_text(settings.binding_protocol));\n#ifdef SASL_ENABLED\n    APPEND_STAT(\"auth_enabled_sasl\", \"%s\", \"yes\");\n#else\n    APPEND_STAT(\"auth_enabled_sasl\", \"%s\", \"no\");\n#endif\n\n#ifdef ENABLE_ISASL\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"isasl\");\n#elif defined(ENABLE_SASL)\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"cyrus\");\n#else\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"none\");\n#endif\n    APPEND_STAT(\"auth_required_sasl\", \"%s\", settings.require_sasl ? \"yes\" : \"no\");\n    APPEND_STAT(\"item_size_max\", \"%d\", settings.item_size_max);\n    APPEND_STAT(\"topkeys\", \"%d\", settings.topkeys);\n\n    for (EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n         ptr != NULL;\n         ptr = ptr->next) {\n        APPEND_STAT(\"extension\", \"%s\", ptr->get_name());\n    }\n\n    APPEND_STAT(\"logger\", \"%s\", settings.extensions.logger->get_name());\n\n    for (EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *ptr = settings.extensions.ascii;\n         ptr != NULL;\n         ptr = ptr->next) {\n        APPEND_STAT(\"ascii_extension\", \"%s\", ptr->get_name(ptr->cookie));\n    }\n}\n\nstatic char *process_stat(conn *c, token_t *tokens, const size_t ntokens) {\n    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;\n    c->dynamic_buffer.offset = 0;\n\n    if (ntokens == 2) {\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            server_stats(&append_stats, c, false);\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c,\n                                                NULL, 0, &append_stats);\n            if (ret == ENGINE_EWOULDBLOCK) {\n                c->ewouldblock = true;\n                return c->rcurr + 5;\n            }\n        }\n    } else if (strcmp(subcommand, \"reset\") == 0) {\n        stats_reset(c);\n        out_string(c, \"RESET\");\n        return NULL;\n    } else if (strcmp(subcommand, \"detail\") == 0) {\n        /* NOTE: how to tackle detail with binary? */\n        if (ntokens < 4) {\n            process_stats_detail(c, \"\");  /* outputs the error message */\n        } else {\n            process_stats_detail(c, tokens[2].value);\n        }\n        /* Output already generated */\n        return NULL;\n    } else if (strcmp(subcommand, \"settings\") == 0) {\n        process_stat_settings(&append_stats, c);\n    } else if (strcmp(subcommand, \"cachedump\") == 0) {\n        char *buf = NULL;\n        unsigned int bytes = 0, id, limit = 0;\n\n        if (ntokens < 5) {\n            out_string(c, \"CLIENT_ERROR bad command line\");\n            return NULL;\n        }\n\n        if (!safe_strtoul(tokens[2].value, &id) ||\n            !safe_strtoul(tokens[3].value, &limit)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return NULL;\n        }\n\n        if (id >= POWER_LARGEST) {\n            out_string(c, \"CLIENT_ERROR Illegal slab id\");\n            return NULL;\n        }\n\n#ifdef FUTURE\n        buf = item_cachedump(id, limit, &bytes);\n#endif\n        write_and_free(c, buf, bytes);\n        return NULL;\n    } else if (strcmp(subcommand, \"aggregate\") == 0) {\n        server_stats(&append_stats, c, true);\n    } else if (strcmp(subcommand, \"topkeys\") == 0) {\n        topkeys_t *tk = get_independent_stats(c)->topkeys;\n        if (tk != NULL) {\n            topkeys_stats(tk, c, current_time, append_stats);\n        } else {\n            out_string(c, \"ERROR\");\n            return NULL;\n        }\n    } else {\n        /* getting here means that the subcommand is either engine specific or\n           is invalid. query the engine and see. */\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            char *buf = NULL;\n            int nb = -1;\n            detokenize(&tokens[1], ntokens - 2, &buf, &nb);\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c, buf,\n                                                nb, append_stats);\n            free(buf);\n        }\n\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            append_stats(NULL, 0, NULL, 0, c);\n            write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n            c->dynamic_buffer.buffer = NULL;\n            break;\n        case ENGINE_ENOMEM:\n            out_string(c, \"SERVER_ERROR out of memory writing stats\");\n            break;\n        case ENGINE_DISCONNECT:\n            c->state = conn_closing;\n            break;\n        case ENGINE_ENOTSUP:\n            out_string(c, \"SERVER_ERROR not supported\");\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            return tokens[SUBCOMMAND_TOKEN].value;\n        default:\n            out_string(c, \"ERROR\");\n            break;\n        }\n\n        return NULL;\n    }\n\n    /* append terminator and start the transfer */\n    append_stats(NULL, 0, NULL, 0, c);\n\n    if (c->dynamic_buffer.buffer == NULL) {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    } else {\n        write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n        c->dynamic_buffer.buffer = NULL;\n    }\n\n    return NULL;\n}\n\n/**\n * Get a suffix buffer and insert it into the list of used suffix buffers\n * @param c the connection object\n * @return a pointer to a new suffix buffer or NULL if allocation failed\n */\nstatic char *get_suffix_buffer(conn *c) {\n    if (c->suffixleft == c->suffixsize) {\n        char **new_suffix_list;\n        size_t sz = sizeof(char*) * c->suffixsize * 2;\n\n        new_suffix_list = realloc(c->suffixlist, sz);\n        if (new_suffix_list) {\n            c->suffixsize *= 2;\n            c->suffixlist = new_suffix_list;\n        } else {\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                        \"=%d Failed to resize suffix buffer\\n\", c->sfd);\n            }\n\n            return NULL;\n        }\n    }\n\n    char *suffix = cache_alloc(c->thread->suffix_cache);\n    if (suffix != NULL) {\n        *(c->suffixlist + c->suffixleft) = suffix;\n        ++c->suffixleft;\n    }\n\n    return suffix;\n}\n\n/* ntokens is overwritten here... shrug.. */\nstatic inline char* process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n    char *key;\n    size_t nkey;\n    int i = c->ileft;\n    item *it = NULL;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    int range = false;\n    assert(c != NULL);\n\n    do {\n        while(key_token->length != 0) {\n            /* whether there are more keys to fetch */\n            bool next_get = (key_token + 1)->value;\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            /* whether this is a range search */\n            if (nkey >=  2 && key[0] == '@'\n\t\t&& (key[1] == '>' || key[1] == '<')) {\n\t\trange = true;\n            }\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return NULL;\n            }\n\n            ENGINE_ERROR_CODE ret = c->aiostat;\n            c->aiostat = ENGINE_SUCCESS;\n\n            if (ret == ENGINE_SUCCESS) {\n                ret = settings.engine.v1->get(settings.engine.v0, c, &it,\n\t\t\t\t\t      key, nkey, next_get);\n            }\n\n            switch (ret) {\n            case ENGINE_EWOULDBLOCK:\n                c->ewouldblock = true;\n                c->ileft = i;\n                return key;\n\n            case ENGINE_SUCCESS:\n                break;\n            case ENGINE_KEY_ENOENT:\n            default:\n                it = NULL;\n                break;\n            }\n\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, nkey, NULL != it);\n            }\n\n            if (it) {\n                item_info info = { .nvalue = 1 };\n                if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it,\n                                                       &info)) {\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    out_string(c, \"SERVER_ERROR error getting item data\");\n                    break;\n                }\n\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        settings.engine.v1->release(settings.engine.v0, c, it);\n                        break;\n                    }\n                }\n\n                /* Rebuild the suffix */\n                char *suffix = get_suffix_buffer(c);\n                if (suffix == NULL) {\n                    out_string(c, \"SERVER_ERROR out of memory rebuilding suffix\");\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    return NULL;\n                }\n                int suffix_len = snprintf(suffix, SUFFIX_SIZE,\n                                          \" %u %u\\r\\n\", htonl(info.flags),\n                                          info.nbytes);\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                MEMCACHED_COMMAND_GET(c->sfd, info.key, info.nkey,\n                                      info.nbytes, info.cas);\n                if (return_cas)\n                {\n\n                  char *cas = get_suffix_buffer(c);\n                  if (cas == NULL) {\n                    out_string(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    return NULL;\n                  }\n                  int cas_len = snprintf(cas, SUFFIX_SIZE, \" %\"PRIu64\"\\r\\n\",\n                                         info.cas);\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, info.key, info.nkey) != 0 ||\n                      add_iov(c, suffix, suffix_len - 2) != 0 ||\n                      add_iov(c, cas, cas_len) != 0 ||\n                      add_iov(c, info.value[0].iov_base, info.value[0].iov_len) != 0 ||\n                      add_iov(c, \"\\r\\n\", 2) != 0)\n                      {\n                          settings.engine.v1->release(settings.engine.v0, c, it);\n                          break;\n                      }\n                }\n                else\n                {\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, info.key, info.nkey) != 0 ||\n                      add_iov(c, suffix, suffix_len) != 0 ||\n                      add_iov(c, info.value[0].iov_base, info.value[0].iov_len) != 0 ||\n                      add_iov(c, \"\\r\\n\", 2) != 0)\n                      {\n                          settings.engine.v1->release(settings.engine.v0, c, it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                    \">%d sending key %s\\n\",\n                                                    c->sfd, info.key);\n                }\n\n                /* item_get() has incremented it->refcount for us */\n                STATS_HIT(c, get, key, nkey);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                STATS_MISS(c, get, key, nkey);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            if (!range) {\n\t\tkey_token++;\n            } else {\n\t\tif (ret == ENGINE_KEY_ENOENT) {\n\t\t\tkey_token->value = NULL;\n\t\t}\n\t\tbreak;\n\t    }\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    c->suffixcurr = c->suffixlist;\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d END\\n\", c->sfd);\n    }\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_string(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n\n    return NULL;\n}\n\nstatic void process_update_command(conn *c, token_t *tokens, const size_t ntokens, ENGINE_STORE_OPERATION store_op, bool handle_cas) {\n    char *key;\n    size_t nkey;\n    unsigned int flags;\n    int32_t exptime_int = 0;\n    time_t exptime;\n    int vlen = 0;\n    uint64_t req_cas_id=0;\n    item *it = NULL;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)\n           && safe_strtol(tokens[3].value, &exptime_int)\n           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    /* Negative expire values not allowed */\n\n    if (exptime_int < 0) {\n        out_string(c, \"CLIENT_ERROR Invalid expire time\");\n        return;\n    }\n\n    /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */\n    exptime = exptime_int;\n\n    // does cas value exist?\n    if (handle_cas) {\n        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n    }\n\n    if (vlen < 0) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen, htonl(flags), exptime);\n    }\n\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, req_cas_id);\n        if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            out_string(c, \"SERVER_ERROR error getting item data\");\n            break;\n        }\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        c->store_op = store_op;\n        conn_set_state(c, conn_nread);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            out_string(c, \"SERVER_ERROR object too large for cache\");\n        } else {\n            out_string(c, \"SERVER_ERROR out of memory storing object\");\n        }\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n        c->sbytes = vlen + 2;\n\n        /* Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET. Anywhere else too? */\n        if (store_op == OPERATION_SET) {\n            settings.engine.v1->remove(settings.engine.v0, c, key, nkey, 0, 0);\n        }\n    }\n}\n\nstatic char* process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {\n\n    uint64_t delta;\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return NULL;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (!safe_strtoull(tokens[2].value, &delta)) {\n        out_string(c, \"CLIENT_ERROR invalid numeric delta argument\");\n        return NULL;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    uint64_t cas;\n    uint64_t result = 0;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->arithmetic(settings.engine.v0, c, key, nkey,\n                                             incr, false, delta, 0, 0, &cas,\n                                             &result, 0);\n    }\n\n    char temp[INCR_MAX_STORAGE_LEN];\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        if (incr) {\n            STATS_INCR(c, incr_hits, key, nkey);\n        } else {\n            STATS_INCR(c, decr_hits, key, nkey);\n        }\n        snprintf(temp, sizeof(temp), \"%\"PRIu64, result);\n        out_string(c, temp);\n        break;\n    case ENGINE_KEY_ENOENT:\n        if (incr) {\n            STATS_INCR(c, incr_misses, key, nkey);\n        } else {\n            STATS_INCR(c, decr_misses, key, nkey);\n        }\n        out_string(c, \"NOT_FOUND\");\n        break;\n    case ENGINE_ENOMEM:\n        out_string(c, \"SERVER_ERROR out of memory\");\n        break;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    case ENGINE_EINVAL:\n        out_string(c, \"CLIENT_ERROR cannot increment or decrement non-numeric value\");\n        break;\n    case ENGINE_NOT_STORED:\n        out_string(c, \"SERVER_ERROR failed to store item\");\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        out_string(c, \"SERVER_ERROR not supported\");\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        return key;\n    default:\n        abort();\n    }\n\n    return NULL;\n}\n\nstatic char *process_delete_command(conn *c, token_t *tokens,\n                                    const size_t ntokens) {\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    if (ntokens > 3) {\n        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, \"0\") == 0;\n        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);\n        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))\n            || (ntokens == 5 && hold_is_zero && sets_noreply);\n        if (!valid) {\n            out_string(c, \"CLIENT_ERROR bad command line format.  \"\n                       \"Usage: delete <key> [noreply]\");\n            return NULL;\n        }\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (nkey > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return NULL;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->remove(settings.engine.v0, c,\n                                         key, nkey, 0, 0);\n    }\n\n    /* For some reason the SLAB_INCR tries to access this... */\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        out_string(c, \"DELETED\");\n        SLAB_INCR(c, delete_hits, key, nkey);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        return key;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    default:\n        out_string(c, \"NOT_FOUND\");\n        STATS_INCR(c, delete_misses, key, nkey);\n    }\n\n    if (ret != ENGINE_EWOULDBLOCK && settings.detail_enabled) {\n        stats_prefix_record_delete(key, nkey);\n    }\n    return NULL;\n}\n\nstatic char *process_bind_command(conn *c, token_t *tokens,\n                                  const size_t ntokens) {\n    char *name;\n    size_t name_len;\n\n    assert(c != NULL);\n\n    if (ntokens > 3) {\n        out_string(c, \"CLIENT_ERROR bad command line format.  \"\n                      \"Usage: bind <table_id_name>\");\n        return NULL;\n    }\n\n    name = tokens[KEY_TOKEN].value;\n    name_len = tokens[KEY_TOKEN].length;\n\n    if (name_len > KEY_MAX_LENGTH || name_len == 0) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return NULL;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->bind(settings.engine.v0, c,\n                                       name, name_len);\n    }\n\n    /* For some reason the SLAB_INCR tries to access this... */\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        out_string(c, \"SUCCEED\");\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        return name;\n    case ENGINE_TMPFAIL:\n    default:\n        out_string(c, \"NOT_FOUND\");\n    }\n\n    return NULL;\n}\n\nstatic void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {\n    unsigned int level;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n    if (c->noreply && ntokens == 3) {\n        /* \"verbosity noreply\" is not according to the correct syntax */\n        c->noreply = false;\n        out_string(c, \"ERROR\");\n        return;\n    }\n\n    if (safe_strtoul(tokens[1].value, &level)) {\n        settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;\n        perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n        out_string(c, \"OK\");\n    } else {\n        out_string(c, \"ERROR\");\n    }\n}\n\nstatic char* process_command(conn *c, char *command) {\n\n    token_t tokens[MAX_TOKENS];\n    size_t ntokens;\n    int comm;\n    char *ret = NULL;\n\n    assert(c != NULL);\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"<%d %s\\n\", c->sfd, command);\n    }\n\n    /*\n     * for commands set/add/replace, we build an item and read the data\n     * directly into it, then continue in nread_complete().\n     */\n\n    if (c->ewouldblock) {\n        /*\n         * If we are retrying after the engine has completed a pending io for\n         * this command, skip add_msghdr() etc and clear the ewouldblock flag.\n         */\n        c->ewouldblock = false;\n    } else {\n        c->msgcurr = 0;\n        c->msgused = 0;\n        c->iovused = 0;\n        if (add_msghdr(c) != 0) {\n            out_string(c, \"SERVER_ERROR out of memory preparing response\");\n            return NULL;\n        }\n    }\n\n    ntokens = tokenize_command(command, tokens, MAX_TOKENS);\n    if (ntokens >= 3 &&\n        ((strcmp(tokens[COMMAND_TOKEN].value, \"get\") == 0) ||\n         (strcmp(tokens[COMMAND_TOKEN].value, \"bget\") == 0))) {\n\n        ret = process_get_command(c, tokens, ntokens, false);\n\n    } else if ((ntokens == 6 || ntokens == 7) &&\n               ((strcmp(tokens[COMMAND_TOKEN].value, \"add\") == 0 && (comm = (int)OPERATION_ADD)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"set\") == 0 && (comm = (int)OPERATION_SET)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"replace\") == 0 && (comm = (int)OPERATION_REPLACE)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"prepend\") == 0 && (comm = (int)OPERATION_PREPEND)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"append\") == 0 && (comm = (int)OPERATION_APPEND)) )) {\n\n        process_update_command(c, tokens, ntokens, (ENGINE_STORE_OPERATION)comm, false);\n\n    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, \"cas\") == 0 && (comm = (int)OPERATION_CAS))) {\n\n        process_update_command(c, tokens, ntokens, (ENGINE_STORE_OPERATION)comm, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"incr\") == 0)) {\n\n        ret = process_arithmetic_command(c, tokens, ntokens, 1);\n\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"gets\") == 0)) {\n\n        ret = process_get_command(c, tokens, ntokens, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"decr\") == 0)) {\n\n        ret = process_arithmetic_command(c, tokens, ntokens, 0);\n\n    } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, \"delete\") == 0)) {\n\n        ret = process_delete_command(c, tokens, ntokens);\n\n    } else if (ntokens == 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"bind\") == 0)) {\n\n        ret = process_bind_command(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"stats\") == 0)) {\n\n        ret = process_stat(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"flush_all\") == 0)) {\n        time_t exptime;\n\n        set_noreply_maybe(c, tokens, ntokens);\n\n        if (ntokens == (c->noreply ? 3 : 2)) {\n            exptime = 0;\n        } else {\n            exptime = strtol(tokens[1].value, NULL, 10);\n            if(errno == ERANGE) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return NULL;\n            }\n        }\n\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            ret = settings.engine.v1->flush(settings.engine.v0, c, exptime);\n        }\n\n        switch (ret) {\n        case  ENGINE_SUCCESS:\n            out_string(c, \"OK\");\n            break;\n        case ENGINE_ENOTSUP:\n            out_string(c, \"SERVER_ERROR not supported\");\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            return c->rcurr + 9;\n        default:\n            out_string(c, \"SERVER_ERROR failed to flush cache\");\n        }\n\n        if (ret != ENGINE_EWOULDBLOCK) {\n            STATS_NOKEY(c, cmd_flush);\n        }\n        return NULL;\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"version\") == 0)) {\n\n        out_string(c, \"VERSION \" VERSION);\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"quit\") == 0)) {\n\n        conn_set_state(c, conn_closing);\n\n    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, \"verbosity\") == 0)) {\n        process_verbosity_command(c, tokens, ntokens);\n    } else if (settings.extensions.ascii != NULL) {\n        EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *cmd;\n        size_t nbytes = 0;\n        char *ptr = NULL;\n\n        if (ntokens > 0) {\n            if (ntokens == MAX_TOKENS) {\n                out_string(c, \"ERROR too many arguments\");\n                return NULL;\n            }\n\n            if (tokens[ntokens - 1].length == 0) {\n                --ntokens;\n            }\n        }\n\n        for (cmd = settings.extensions.ascii; cmd != NULL; cmd = cmd->next) {\n            if (cmd->accept(cmd->cookie, c, ntokens, tokens, &nbytes, &ptr)) {\n                break;\n            }\n        }\n\n        if (cmd == NULL) {\n            out_string(c, \"ERROR unknown command\");\n        } else if (nbytes == 0) {\n            switch (cmd->execute(cmd->cookie, c, ntokens, tokens,\n                                 ascii_response_handler)) {\n            case ENGINE_SUCCESS:\n                if (c->dynamic_buffer.buffer != NULL) {\n                    write_and_free(c, c->dynamic_buffer.buffer,\n                                   c->dynamic_buffer.offset);\n                    c->dynamic_buffer.buffer = NULL;\n                } else {\n                    conn_set_state(c, conn_new_cmd);\n                }\n                break;\n            case ENGINE_EWOULDBLOCK:\n                c->ewouldblock = true;\n                ret = tokens[KEY_TOKEN].value;;\n                break;\n            case ENGINE_DISCONNECT:\n            default:\n                conn_set_state(c, conn_closing);\n\n            }\n        } else {\n            c->rlbytes = nbytes;\n            c->ritem = ptr;\n            c->ascii_cmd = cmd;\n            /* NOT SUPPORTED YET! */\n            conn_set_state(c, conn_nread);\n        }\n    } else {\n        out_string(c, \"ERROR\");\n    }\n    return ret;\n}\n\n/*\n * if we have a complete line in the buffer, process it.\n */\nstatic int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                    \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                             \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                char buffer[1024];\n                ssize_t nw;\n                nw = bytes_to_output_string(buffer, sizeof(buffer), c->sfd,\n                                            true, \"Read binary protocol data:\",\n                                            (const char*)req->bytes,\n                                            sizeof(req->bytes));\n                if (nw != -1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                    \"%s\", buffer);\n                }\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.vbucket = ntohs(req->request.vbucket);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ &&\n                !(c->binary_header.request.magic == PROTOCOL_BINARY_RES &&\n                  response_handlers[c->binary_header.request.opcode])) {\n                if (settings.verbose) {\n                    if (c->binary_header.request.magic != PROTOCOL_BINARY_RES) {\n                        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                              \"%d: Invalid magic:  %x\\n\", c->sfd,\n                              c->binary_header.request.magic);\n                    } else {\n                        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                              \"%d: ERROR: Unsupported response packet received: %u\\n\",\n                              c->sfd, (unsigned int)c->binary_header.request.opcode);\n\n                    }\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont, *left, lb;\n\n        if (c->rbytes == 0) {\n            return 0;\n        }\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el) {\n            if (c->rbytes > 1024) {\n                /*\n                 * We didn't have a '\\n' in the first k. This _has_ to be a\n                 * large multiget, if not we should just nuke the connection.\n                 */\n                char *ptr = c->rcurr;\n                while (*ptr == ' ') { /* ignore leading whitespaces */\n                    ++ptr;\n                }\n\n                if (ptr - c->rcurr > 100 ||\n                    (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {\n\n                    conn_set_state(c, conn_closing);\n                    return 1;\n                }\n            }\n\n            return 0;\n        }\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        lb = *el;\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        LIBEVENT_THREAD *thread = c->thread;\n        LOCK_THREAD(thread);\n        left = process_command(c, c->rcurr);\n        if (c->ewouldblock) {\n            unregister_event(c);\n        }\n        UNLOCK_THREAD(thread);\n\n        if (left != NULL) {\n            /*\n             * We have not processed the entire command. This happens\n             * when the engine returns ENGINE_EWOULDBLOCK for one of the\n             * keys in a get/gets request.\n             */\n            assert (left <= el);\n\n            int count = strlen(c->rcurr);\n            if ((c->rcurr + count) == left) {\n                // Retry the entire command\n                cont = c->rcurr;\n            } else {\n                left -= (count + 1);\n                cont = left;\n                assert(cont >= c->rcurr);\n                if (cont > c->rcurr) {\n                    memmove(cont, c->rcurr, count);\n                }\n            }\n\n            /* de-tokenize the command */\n            while ((left = memchr(left, '\\0', el - left)) != NULL) {\n                *left = ' ';\n            }\n            *el = lb;\n        }\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}\n\n/*\n * read a UDP request.\n */\nstatic enum try_read_result try_read_udp(conn *c) {\n    int res;\n\n    assert(c != NULL);\n\n    c->request_addr_size = sizeof(c->request_addr);\n    res = recvfrom(c->sfd, c->rbuf, c->rsize,\n                   0, (struct sockaddr *)&c->request_addr, &c->request_addr_size);\n    if (res > 8) {\n        unsigned char *buf = (unsigned char *)c->rbuf;\n        STATS_ADD(c, bytes_read, res);\n\n        /* Beginning of UDP packet is the request ID; save it. */\n        c->request_id = buf[0] * 256 + buf[1];\n\n        /* If this is a multi-packet request, drop it. */\n        if (buf[4] != 0 || buf[5] != 1) {\n            out_string(c, \"SERVER_ERROR multi-packet request not supported\");\n            return READ_NO_DATA_RECEIVED;\n        }\n\n        /* Don't care about any of the rest of the header. */\n        res -= 8;\n        memmove(c->rbuf, c->rbuf + 8, res);\n\n        c->rbytes += res;\n        c->rcurr = c->rbuf;\n        return READ_DATA_RECEIVED;\n    }\n    return READ_NO_DATA_RECEIVED;\n}\n\n/*\n * read from network as much as we can, handle buffer overflow and connection\n * close.\n * before reading, move the remaining incomplete fragment of a command\n * (if any) to the beginning of the buffer.\n *\n * To protect us from someone flooding a connection with bogus data causing\n * the connection to eat up all available memory, break out and start looking\n * at the data I've got after a number of reallocs...\n *\n * @return enum try_read_result\n */\nstatic enum try_read_result try_read_network(conn *c) {\n    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n    int res;\n    int num_allocs = 0;\n    assert(c != NULL);\n\n    if (c->rcurr != c->rbuf) {\n        if (c->rbytes != 0) /* otherwise there's nothing to copy */\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n        c->rcurr = c->rbuf;\n    }\n\n    while (1) {\n        if (c->rbytes >= c->rsize) {\n            if (num_allocs == 4) {\n                return gotdata;\n            }\n            ++num_allocs;\n            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n            if (!new_rbuf) {\n                if (settings.verbose > 0) {\n                 settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                          \"Couldn't realloc input buffer\\n\");\n                }\n                c->rbytes = 0; /* ignore what we read */\n                out_string(c, \"SERVER_ERROR out of memory reading request\");\n                c->write_and_go = conn_closing;\n                return READ_MEMORY_ERROR;\n            }\n            c->rcurr = c->rbuf = new_rbuf;\n            c->rsize *= 2;\n        }\n\n        int avail = c->rsize - c->rbytes;\n        res = recv(c->sfd, c->rbuf + c->rbytes, avail, 0);\n        if (res > 0) {\n            STATS_ADD(c, bytes_read, res);\n            gotdata = READ_DATA_RECEIVED;\n            c->rbytes += res;\n            if (res == avail) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (res == 0) {\n            return READ_ERROR;\n        }\n        if (res == -1) {\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                break;\n            }\n            return READ_ERROR;\n        }\n    }\n    return gotdata;\n}\n\nbool register_event(conn *c, struct timeval *timeout) {\n#ifdef DEBUG\n    assert(!c->registered_in_libevent);\n#endif\n\n    if (event_add(&c->event, timeout) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING,\n                                        NULL,\n                                        \"Failed to add connection to libevent: %s\",\n                                        strerror(errno));\n        return false;\n    }\n\n#ifdef DEBUG\n    c->registered_in_libevent = true;\n#endif\n\n    return true;\n}\n\nbool unregister_event(conn *c) {\n#ifdef DEBUG\n    assert(c->registered_in_libevent);\n#endif\n\n    if (event_del(&c->event) == -1) {\n        return false;\n    }\n\n#ifdef DEBUG\n    c->registered_in_libevent = false;\n#endif\n\n    return true;\n}\n\n\nbool update_event(conn *c, const int new_flags) {\n    assert(c != NULL);\n\n    struct event_base *base = c->event.ev_base;\n    if (c->ev_flags == new_flags)\n        return true;\n\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                    \"Updated event for %d to read=%s, write=%s\\n\",\n                                    c->sfd, (new_flags & EV_READ ? \"yes\" : \"no\"),\n                                    (new_flags & EV_WRITE ? \"yes\" : \"no\"));\n\n    if (!unregister_event(c)) {\n        return false;\n    }\n\n    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = new_flags;\n\n    return register_event(c, NULL);\n}\n\n/*\n * Transmit the next chunk of data from our list of msgbuf structures.\n *\n * Returns:\n *   TRANSMIT_COMPLETE   All done writing.\n *   TRANSMIT_INCOMPLETE More data remaining to write.\n *   TRANSMIT_SOFT_ERROR Can't write any more right now.\n *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)\n */\nstatic enum transmit_result transmit(conn *c) {\n    assert(c != NULL);\n\n    if (c->msgcurr < c->msgused &&\n            c->msglist[c->msgcurr].msg_iovlen == 0) {\n        /* Finished writing the current msg; advance to the next. */\n        c->msgcurr++;\n    }\n    if (c->msgcurr < c->msgused) {\n        ssize_t res;\n        struct msghdr *m = &c->msglist[c->msgcurr];\n\n        res = sendmsg(c->sfd, m, 0);\n        if (res > 0) {\n            STATS_ADD(c, bytes_written, res);\n\n            /* We've written some of the data. Remove the completed\n               iovec entries from the list of pending writes. */\n            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {\n                res -= m->msg_iov->iov_len;\n                m->msg_iovlen--;\n                m->msg_iov++;\n            }\n\n            /* Might have written just part of the last iovec entry;\n               adjust it so the next write will do the rest. */\n            if (res > 0) {\n                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;\n                m->msg_iov->iov_len -= res;\n            }\n            return TRANSMIT_INCOMPLETE;\n        }\n        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                            \"Couldn't update event\\n\");\n                }\n                conn_set_state(c, conn_closing);\n                return TRANSMIT_HARD_ERROR;\n            }\n            return TRANSMIT_SOFT_ERROR;\n        }\n        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,\n           we have a real error, on which we close the connection */\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"Failed to write, and not due to blocking: %s\",\n                                            strerror(errno));\n        }\n\n        if (IS_UDP(c->transport))\n            conn_set_state(c, conn_read);\n        else\n            conn_set_state(c, conn_closing);\n        return TRANSMIT_HARD_ERROR;\n    } else {\n        return TRANSMIT_COMPLETE;\n    }\n}\n\nbool conn_listening(conn *c)\n{\n    int sfd;\n    struct sockaddr_storage addr;\n    socklen_t addrlen = sizeof(addr);\n\n    if ((sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen)) == -1) {\n        if (errno == EMFILE) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Too many open connections\\n\");\n            }\n            disable_listen();\n        } else if (errno != EAGAIN && errno != EWOULDBLOCK) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"Failed to accept new client: %s\\n\",\n                                            strerror(errno));\n        }\n\n        return false;\n    }\n\n    STATS_LOCK();\n    int curr_conns = ++stats.curr_conns;\n    STATS_UNLOCK();\n\n    if (curr_conns >= settings.maxconns) {\n        STATS_LOCK();\n        ++stats.rejected_conns;\n        STATS_UNLOCK();\n\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Too many open connections\\n\");\n        }\n\n        safe_close(sfd);\n        return false;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return false;\n    }\n\n    dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,\n                      DATA_BUFFER_SIZE, tcp_transport);\n\n    return false;\n}\n\n/**\n * Ship tap log to the other end. This state differs with all other states\n * in the way that it support full duplex dialog. We're listening to both read\n * and write events from libevent most of the time. If a read event occurs we\n * switch to the conn_read state to read and execute the input message (that would\n * be an ack message from the other side). If a write event occurs we continue to\n * send tap log to the other end.\n * @param c the tap connection to drive\n * @return true if we should continue to process work for this connection, false\n *              if we should start processing events for other connections.\n */\nbool conn_ship_log(conn *c) {\n    bool cont = false;\n\n    if (c->sfd == INVALID_SOCKET) {\n        return false;\n    }\n\n    short mask = EV_READ | EV_PERSIST | EV_WRITE;\n\n    if (c->which & EV_READ || c->rbytes > 0) {\n        if (c->rbytes > 0) {\n            if (try_read_command(c) == 0) {\n                conn_set_state(c, conn_read);\n            }\n        } else {\n            conn_set_state(c, conn_read);\n        }\n\n        // we're going to process something.. let's proceed\n        cont = true;\n\n        // We have a finite number of messages in the input queue\n        // so let's process all of them instead of backing off after\n        // reading a subset of them.\n        // Why? Because we've got every time we're calling ship_tap_log\n        // we try to send a chunk of items.. This means that if we end\n        // up in a situation where we're receiving a burst of nack messages\n        // we'll only process a subset of messages in our input queue,\n        // and it will slowly grow..\n        c->nevents = settings.reqs_per_tap_event;\n    } else if (c->which & EV_WRITE) {\n        --c->nevents;\n        if (c->nevents >= 0) {\n            LOCK_THREAD(c->thread);\n            c->ewouldblock = false;\n            ship_tap_log(c);\n            if (c->ewouldblock) {\n                mask = EV_READ | EV_PERSIST;\n            } else {\n                cont = true;\n            }\n            UNLOCK_THREAD(c->thread);\n        }\n    }\n\n    if (!update_event(c, mask)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO,\n                                            c, \"Couldn't update event\\n\");\n        }\n        conn_set_state(c, conn_closing);\n    }\n\n    return cont;\n}\n\nbool conn_waiting(conn *c) {\n    if (!update_event(c, EV_READ | EV_PERSIST)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Couldn't update event\\n\");\n        }\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n    conn_set_state(c, conn_read);\n    return false;\n}\n\nbool conn_read(conn *c) {\n    int res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);\n    switch (res) {\n    case READ_NO_DATA_RECEIVED:\n        conn_set_state(c, conn_waiting);\n        break;\n    case READ_DATA_RECEIVED:\n        conn_set_state(c, conn_parse_cmd);\n        break;\n    case READ_ERROR:\n        conn_set_state(c, conn_closing);\n        break;\n    case READ_MEMORY_ERROR: /* Failed to allocate more memory */\n        /* State already set by try_read_network */\n        break;\n    }\n\n    return true;\n}\n\nbool conn_parse_cmd(conn *c) {\n    if (try_read_command(c) == 0) {\n        /* wee need more data! */\n        conn_set_state(c, conn_waiting);\n    }\n\n    return !c->ewouldblock;\n}\n\nbool conn_new_cmd(conn *c) {\n    /* Only process nreqs at a time to avoid starving other connections */\n    --c->nevents;\n    if (c->nevents >= 0) {\n        reset_cmd_handler(c);\n    } else {\n        STATS_NOKEY(c, conn_yields);\n        if (c->rbytes > 0) {\n            /* We have already read in data into the input buffer,\n               so libevent will most likely not signal read events\n               on the socket (unless more data is available. As a\n               hack we should just put in a request to write data,\n               because that should be possible ;-)\n            */\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_INFO,\n                                                    c, \"Couldn't update event\\n\");\n                }\n                conn_set_state(c, conn_closing);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    return true;\n}\n\n\nbool conn_swallow(conn *c) {\n    ssize_t res;\n    /* we are reading sbytes and throwing them away */\n    if (c->sbytes == 0) {\n        conn_set_state(c, conn_new_cmd);\n        return true;\n    }\n\n    /* first check if we have leftovers in the conn_read buffer */\n    if (c->rbytes > 0) {\n        uint32_t tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;\n        c->sbytes -= tocopy;\n        c->rcurr += tocopy;\n        c->rbytes -= tocopy;\n        return true;\n    }\n\n    /*  now try reading from the socket */\n    res = recv(c->sfd, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize, 0);\n    if (res > 0) {\n        STATS_ADD(c, bytes_read, res);\n        c->sbytes -= res;\n        return true;\n    }\n    if (res == 0) { /* end of stream */\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n        if (!update_event(c, EV_READ | EV_PERSIST)) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't update event\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n        return false;\n    }\n\n    if (errno != ENOTCONN && errno != ECONNRESET) {\n        /* otherwise we have a real error, on which we close the connection */\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                        \"Failed to read, and not due to blocking (%s)\\n\",\n                                        strerror(errno));\n    }\n\n    conn_set_state(c, conn_closing);\n\n    return true;\n\n}\n\nbool conn_nread(conn *c) {\n    ssize_t res;\n\n    if (c->rlbytes == 0) {\n        LIBEVENT_THREAD *t = c->thread;\n        LOCK_THREAD(t);\n        bool block = c->ewouldblock = false;\n        complete_nread(c);\n        UNLOCK_THREAD(t);\n        /* Breaking this into two, as complete_nread may have\n           moved us to a different thread */\n        t = c->thread;\n        LOCK_THREAD(t);\n        if (c->ewouldblock) {\n            unregister_event(c);\n            block = true;\n        }\n        UNLOCK_THREAD(t);\n        return !block;\n    }\n    /* first check if we have leftovers in the conn_read buffer */\n    if (c->rbytes > 0) {\n        uint32_t tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;\n        if (c->ritem != c->rcurr) {\n            memmove(c->ritem, c->rcurr, tocopy);\n        }\n        c->ritem += tocopy;\n        c->rlbytes -= tocopy;\n        c->rcurr += tocopy;\n        c->rbytes -= tocopy;\n        if (c->rlbytes == 0) {\n            return true;\n        }\n    }\n\n    /*  now try reading from the socket */\n    res = recv(c->sfd, c->ritem, c->rlbytes, 0);\n    if (res > 0) {\n        STATS_ADD(c, bytes_read, res);\n        if (c->rcurr == c->ritem) {\n            c->rcurr += res;\n        }\n        c->ritem += res;\n        c->rlbytes -= res;\n        return true;\n    }\n    if (res == 0) { /* end of stream */\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n\n#ifdef INNODB_MEMCACHED\n    /* MEMCACHED_RESOLVE: on solaris platform, when connect through\n    telnet and waiting for input from an \"add\" or \"set\" command,\n    it could have res == -1 and errno == 0. Thus causing early termination\n    Add \"!errno\" condition here to deal with this scenario for now */\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK || !errno)) {\n#else\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n#endif /* INNODB_MEMCACHED */\n        if (!update_event(c, EV_READ | EV_PERSIST)) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't update event\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n        return false;\n    }\n\n    if (errno != ENOTCONN && errno != ECONNRESET) {\n        /* otherwise we have a real error, on which we close the connection */\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Failed to read, and not due to blocking:\\n\"\n                                        \"errno: %d %s \\n\"\n                                        \"rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\\n\",\n                                        errno, strerror(errno),\n                                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,\n                                        (int)c->rlbytes, (int)c->rsize);\n    }\n    conn_set_state(c, conn_closing);\n    return true;\n}\n\nbool conn_write(conn *c) {\n    /*\n     * We want to write out a simple response. If we haven't already,\n     * assemble it into a msgbuf list (this will be a single-entry\n     * list for TCP or a two-entry list for UDP).\n     */\n    if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {\n        if (add_iov(c, c->wcurr, c->wbytes) != 0) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't build response\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n    }\n\n    return conn_mwrite(c);\n}\n\nbool conn_mwrite(conn *c) {\n    if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Failed to build UDP headers\\n\");\n        }\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n\n    switch (transmit(c)) {\n    case TRANSMIT_COMPLETE:\n        if (c->state == conn_mwrite) {\n            while (c->ileft > 0) {\n                item *it = *(c->icurr);\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                c->icurr++;\n                c->ileft--;\n            }\n            while (c->suffixleft > 0) {\n                char *suffix = *(c->suffixcurr);\n                cache_free(c->thread->suffix_cache, suffix);\n                c->suffixcurr++;\n                c->suffixleft--;\n            }\n            /* XXX:  I don't know why this wasn't the general case */\n            if(c->protocol == binary_prot) {\n                conn_set_state(c, c->write_and_go);\n            } else {\n                conn_set_state(c, conn_new_cmd);\n            }\n        } else if (c->state == conn_write) {\n            if (c->write_and_free) {\n                free(c->write_and_free);\n                c->write_and_free = 0;\n            }\n            conn_set_state(c, c->write_and_go);\n        } else {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Unexpected state %d\\n\", c->state);\n            }\n            conn_set_state(c, conn_closing);\n        }\n        break;\n\n    case TRANSMIT_INCOMPLETE:\n    case TRANSMIT_HARD_ERROR:\n        break;                   /* Continue in state machine. */\n\n    case TRANSMIT_SOFT_ERROR:\n        return false;\n    }\n\n    return true;\n}\n\nbool conn_pending_close(conn *c) {\n    assert(c->sfd == INVALID_SOCKET);\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                    \"Awaiting clients to release the cookie (pending close for %p)\",\n                                    (void*)c);\n    LOCK_THREAD(c->thread);\n    c->thread->pending_io = list_remove(c->thread->pending_io, c);\n    if (!list_contains(c->thread->pending_close, c)) {\n        enlist_conn(c, &c->thread->pending_close);\n    }\n    UNLOCK_THREAD(c->thread);\n\n    /*\n     * tell the tap connection that we're disconnecting it now,\n     * but give it a grace period\n     */\n    perform_callbacks(ON_DISCONNECT, NULL, c);\n\n    /*\n     * disconnect callback may have changed the state for the object\n     * so we might complete the disconnect now\n     */\n    return c->state != conn_pending_close;\n}\n\nbool conn_immediate_close(conn *c) {\n    settings.extensions.logger->log(EXTENSION_LOG_DETAIL, c,\n                                    \"Immediate close of %p\",\n                                    (void*)c);\n    perform_callbacks(ON_DISCONNECT, NULL, c);\n    conn_close(c);\n\n    return false;\n}\n\nbool conn_closing(conn *c) {\n    if (IS_UDP(c->transport)) {\n        conn_cleanup(c);\n        return false;\n    }\n\n    // We don't want any network notifications anymore..\n    unregister_event(c);\n    safe_close(c->sfd);\n    c->sfd = INVALID_SOCKET;\n\n    if (c->refcount > 1) {\n        conn_set_state(c, conn_pending_close);\n    } else {\n        conn_set_state(c, conn_immediate_close);\n    }\n    return true;\n}\n\nbool conn_add_tap_client(conn *c) {\n    LIBEVENT_THREAD *tp = tap_thread;\n    LIBEVENT_THREAD *orig_thread = c->thread;\n\n    assert(orig_thread);\n    assert(orig_thread != tp);\n\n    c->ewouldblock = true;\n\n    unregister_event(c);\n\n    LOCK_THREAD(orig_thread);\n    /* Clean out the lists */\n    orig_thread->pending_io = list_remove(orig_thread->pending_io, c);\n    orig_thread->pending_close = list_remove(orig_thread->pending_close, c);\n\n    LOCK_THREAD(tp);\n    c->ev_flags = 0;\n    conn_set_state(c, conn_setup_tap_stream);\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                    \"Moving %d conn from %p to %p\\n\",\n                                    c->sfd, c->thread, tp);\n    c->thread = tp;\n    c->event.ev_base = tp->base;\n    assert(c->next == NULL);\n    assert(c->list_state == 0);\n    enlist_conn(c, &tp->pending_io);\n\n    UNLOCK_THREAD(tp);\n\n    UNLOCK_THREAD(orig_thread);\n\n    notify_thread(tp);\n\n    return false;\n}\n\nbool conn_setup_tap_stream(conn *c) {\n    process_bin_tap_connect(c);\n    return true;\n}\n\nvoid event_handler(const int fd, const short which, void *arg) {\n    conn *c;\n\n    c = (conn *)arg;\n    assert(c != NULL);\n\n    if (memcached_shutdown) {\n        event_base_loopbreak(c->event.ev_base);\n        return ;\n    }\n\n    c->which = which;\n\n    /* sanity */\n    if (fd != c->sfd) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                    \"Catastrophic: event fd doesn't match conn fd!\\n\");\n        }\n        conn_close(c);\n        return;\n    }\n\n    perform_callbacks(ON_SWITCH_CONN, c, c);\n\n    c->nevents = settings.reqs_per_event;\n    if (c->state == conn_ship_log) {\n        c->nevents = settings.reqs_per_tap_event;\n    }\n\n    LIBEVENT_THREAD *thr = c->thread;\n\n    // Do we have pending closes?\n    const size_t max_items = 256;\n    conn *pending_close[max_items];\n    size_t n_pending_close = 0;\n    if (thr != NULL) {\n        LOCK_THREAD(thr);\n        if (thr->pending_close && thr->last_checked != current_time) {\n            assert(!has_cycle(thr->pending_close));\n            thr->last_checked = current_time;\n\n            n_pending_close = list_to_array(pending_close, max_items,\n                                            &thr->pending_close);\n        }\n        UNLOCK_THREAD(thr);\n    }\n\n    if (settings.verbose) {\n        do {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"%d - Running task: (%s)\\n\",\n                                            c->sfd, state_text(c->state));\n        } while (c->state(c));\n    } else {\n        while (c->state(c)) {\n            /* empty */\n        }\n    }\n\n    /* Close any connections pending close */\n    if (n_pending_close > 0) {\n        for (size_t i = 0; i < n_pending_close; ++i) {\n            conn *ce = pending_close[i];\n            if (ce->refcount == 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                                \"OK, time to nuke: %p\\n\",\n                                                (void*)ce);\n                conn_close(ce);\n            } else {\n                LOCK_THREAD(ce->thread);\n                enlist_conn(ce, &ce->thread->pending_close);\n                UNLOCK_THREAD(ce->thread);\n            }\n        }\n    }\n\n    if (thr != NULL) {\n        LOCK_THREAD(thr);\n        finalize_list(pending_close, n_pending_close);\n        UNLOCK_THREAD(thr);\n    }\n}\n\nstatic void dispatch_event_handler(int fd, short which, void *arg) {\n    char buffer[80];\n    ssize_t nr = recv(fd, buffer, sizeof(buffer), 0);\n\n    if (nr != -1 && is_listen_disabled()) {\n        bool enable = false;\n        pthread_mutex_lock(&listen_state.mutex);\n        listen_state.count -= nr;\n        if (listen_state.count <= 0) {\n            enable = true;\n            listen_state.disabled = false;\n        }\n        pthread_mutex_unlock(&listen_state.mutex);\n        if (enable) {\n            conn *next;\n            for (next = listen_conn; next; next = next->next) {\n                update_event(next, EV_READ | EV_PERSIST);\n                if (listen(next->sfd, settings.backlog) != 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"listen() failed\",\n                                                    strerror(errno));\n                }\n            }\n        }\n    }\n}\n\n\n\nstatic SOCKET new_socket(struct addrinfo *ai) {\n    SOCKET sfd;\n\n    sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n    if (sfd == INVALID_SOCKET) {\n        return INVALID_SOCKET;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return INVALID_SOCKET;\n    }\n\n    return sfd;\n}\n\n\n/*\n * Sets a socket's send buffer size to the maximum allowed by the system.\n */\nstatic void maximize_sndbuf(const int sfd) {\n    socklen_t intsize = sizeof(int);\n    int last_good = 0;\n    int min, max, avg;\n    int old_size;\n\n    /* Start with the default size. */\n    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&old_size, &intsize) != 0) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"getsockopt(SO_SNDBUF): %s\",\n                                            strerror(errno));\n        }\n\n        return;\n    }\n\n    /* Binary-search for the real maximum. */\n    min = old_size;\n    max = MAX_SENDBUF_SIZE;\n\n    while (min <= max) {\n        avg = ((unsigned int)(min + max)) / 2;\n        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {\n            last_good = avg;\n            min = avg + 1;\n        } else {\n            max = avg - 1;\n        }\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                 \"<%d send buffer was %d, now %d\\n\", sfd, old_size, last_good);\n    }\n}\n\n\n\n/**\n * Create a socket and bind it to a specific port number\n * @param interface the interface to bind to\n * @param port the port number to bind to\n * @param transport the transport protocol (TCP / UDP)\n * @param portnumber_file A filepointer to write the port numbers to\n *        when they are successfully added to the list of ports we\n *        listen on.\n */\nstatic int server_socket(const char *interface,\n                         int port,\n                         enum network_transport transport,\n                         FILE *portnumber_file) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct addrinfo *ai;\n    struct addrinfo *next;\n    struct addrinfo hints = { .ai_flags = AI_PASSIVE,\n                              .ai_family = AF_UNSPEC };\n    char port_buf[NI_MAXSERV];\n    int error;\n    int success = 0;\n    int flags =1;\n    num_udp_socket = 0;\n\n    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;\n\n    if (port == -1) {\n        port = 0;\n    }\n    snprintf(port_buf, sizeof(port_buf), \"%d\", port);\n    error= getaddrinfo(interface, port_buf, &hints, &ai);\n    if (error != 0) {\n        if (error != EAI_SYSTEM) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                     \"getaddrinfo(): %s\\n\", gai_strerror(error));\n        } else {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                     \"getaddrinfo(): %s\\n\", strerror(error));\n        }\n        return 1;\n    }\n\n    for (next= ai; next; next= next->ai_next) {\n        conn *listen_conn_add;\n        if ((sfd = new_socket(next)) == INVALID_SOCKET) {\n            /* getaddrinfo can return \"junk\" addresses,\n             * we make sure at least one works before erroring.\n             */\n            continue;\n        }\n\n#ifdef IPV6_V6ONLY\n        if (next->ai_family == AF_INET6) {\n            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(IPV6_V6ONLY): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                continue;\n            }\n        }\n#endif\n\n        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n        if (IS_UDP(transport)) {\n            maximize_sndbuf(sfd);\n\t    udp_socket[num_udp_socket] = sfd;\n\t    num_udp_socket++;\n        } else {\n            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(SO_KEEPALIVE): %s\",\n                                                strerror(errno));\n            }\n\n            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(SO_LINGER): %s\",\n                                                strerror(errno));\n            }\n\n            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(TCP_NODELAY): %s\",\n                                                strerror(errno));\n            }\n        }\n\n        if (bind(sfd, next->ai_addr, next->ai_addrlen) == SOCKET_ERROR) {\n            if (errno != EADDRINUSE) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"bind(): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            safe_close(sfd);\n            continue;\n        } else {\n            success++;\n            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == SOCKET_ERROR) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"listen(): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            if (portnumber_file != NULL &&\n                (next->ai_addr->sa_family == AF_INET ||\n                 next->ai_addr->sa_family == AF_INET6)) {\n                union {\n                    struct sockaddr_in in;\n                    struct sockaddr_in6 in6;\n                } my_sockaddr;\n                socklen_t len = sizeof(my_sockaddr);\n                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {\n                    if (next->ai_addr->sa_family == AF_INET) {\n                        fprintf(portnumber_file, \"%s INET: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in.sin_port));\n                    } else {\n                        fprintf(portnumber_file, \"%s INET6: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in6.sin6_port));\n                    }\n                }\n            }\n        }\n\n        if (IS_UDP(transport)) {\n            int c;\n\n            for (c = 0; c < settings.num_threads_per_udp; c++) {\n                /* this is guaranteed to hit all threads because we round-robin */\n                dispatch_conn_new(sfd, conn_read, EV_READ | EV_PERSIST,\n                                  UDP_READ_BUFFER_SIZE, transport);\n                STATS_LOCK();\n                ++stats.curr_conns;\n                ++stats.daemon_conns;\n                STATS_UNLOCK();\n            }\n        } else {\n            if (!(listen_conn_add = conn_new(sfd, conn_listening,\n                                             EV_READ | EV_PERSIST, 1,\n                                             transport, main_base, NULL))) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"failed to create listening connection\\n\");\n                exit(EXIT_FAILURE);\n            }\n            listen_conn_add->next = listen_conn;\n            listen_conn = listen_conn_add;\n            STATS_LOCK();\n            ++stats.curr_conns;\n            ++stats.daemon_conns;\n            STATS_UNLOCK();\n        }\n    }\n\n    freeaddrinfo(ai);\n\n    /* Return zero iff we detected no errors in starting up connections */\n    return success == 0;\n}\n\nstatic int server_sockets(int port, enum network_transport transport,\n                          FILE *portnumber_file) {\n    if (settings.inter == NULL) {\n        return server_socket(settings.inter, port, transport, portnumber_file);\n    } else {\n        // tokenize them and bind to each one of them..\n        char *b;\n        int ret = 0;\n        char *list = strdup(settings.inter);\n\n        if (list == NULL) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"Failed to allocate memory for parsing server interface string\\n\");\n            return 1;\n        }\n        for (char *p = strtok_r(list, \";,\", &b);\n             p != NULL;\n             p = strtok_r(NULL, \";,\", &b)) {\n            int the_port = port;\n\n            char *s = strchr(p, ':');\n            if (s != NULL) {\n                *s = '\\0';\n                ++s;\n                if (!safe_strtol(s, &the_port)) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"Invalid port number: \\\"%s\\\"\", s);\n                    return 1;\n                }\n            }\n            if (strcmp(p, \"*\") == 0) {\n                p = NULL;\n            }\n            ret |= server_socket(p, the_port, transport, portnumber_file);\n        }\n        free(list);\n        return ret;\n    }\n}\n\nstatic int new_socket_unix(void) {\n    int sfd;\n\n    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == INVALID_SOCKET) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"socket(AF_UNIX, SOCK_STREAM, 0): %s\",\n                                        strerror(errno));\n        return INVALID_SOCKET;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return INVALID_SOCKET;\n    }\n    return sfd;\n}\n\n/* this will probably not work on windows */\nstatic int server_socket_unix(const char *path, int access_mask) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct sockaddr_un addr;\n    struct stat tstat;\n    int flags =1;\n    int old_umask;\n\n    if (!path) {\n        return 1;\n    }\n\n    if ((sfd = new_socket_unix()) == -1) {\n        return 1;\n    }\n\n    /*\n     * Clean up a previous socket file if we left it around\n     */\n    if (lstat(path, &tstat) == 0) {\n        if (S_ISSOCK(tstat.st_mode))\n            unlink(path);\n    }\n\n    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n\n    /*\n     * the memset call clears nonstandard fields in some impementations\n     * that otherwise mess things up.\n     */\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sun_family = AF_UNIX;\n    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);\n    assert(strcmp(addr.sun_path, path) == 0);\n    old_umask = umask( ~(access_mask&0777));\n    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"bind(): %s\",\n                                        strerror(errno));\n        safe_close(sfd);\n        umask(old_umask);\n        return 1;\n    }\n    umask(old_umask);\n    if (listen(sfd, settings.backlog) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"listen(): %s\",\n                                        strerror(errno));\n        safe_close(sfd);\n        return 1;\n    }\n    if (!(listen_conn = conn_new(sfd, conn_listening,\n                                 EV_READ | EV_PERSIST, 1,\n                                 local_transport, main_base, NULL))) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"failed to create listening connection\\n\");\n        exit(EXIT_FAILURE);\n    }\n    STATS_LOCK();\n    ++stats.daemon_conns;\n    STATS_UNLOCK();\n\n    return 0;\n}\n\nstatic struct event clockevent;\n\n/* time-sensitive callers can call it by hand with this, outside the normal ever-1-second timer */\nstatic void set_current_time(void) {\n    struct timeval timer;\n\n    gettimeofday(&timer, NULL);\n    current_time = (rel_time_t) (timer.tv_sec - process_started);\n}\n\nstatic void clock_handler(const int fd, const short which, void *arg) {\n    struct timeval t = {.tv_sec = 1, .tv_usec = 0};\n    static bool initialized = false;\n\n    if (memcached_shutdown) {\n        event_base_loopbreak(main_base);\n        return ;\n    }\n\n    if (initialized) {\n        /* only delete the event if it's actually there. */\n        evtimer_del(&clockevent);\n    } else {\n        initialized = true;\n    }\n\n    evtimer_set(&clockevent, clock_handler, 0);\n    event_base_set(main_base, &clockevent);\n    evtimer_add(&clockevent, &t);\n\n    set_current_time();\n}\n\nstatic void usage(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\");\n    printf(\"-p <num>      TCP port number to listen on (default: 11211)\\n\"\n           \"-U <num>      UDP port number to listen on (default: 11211, 0 is off)\\n\"\n           \"-s <file>     UNIX socket path to listen on (disables network support)\\n\"\n           \"-a <mask>     access mask for UNIX socket, in octal (default: 0700)\\n\"\n           \"-l <addr>     interface to listen on (default: INADDR_ANY, all addresses)\\n\"\n           \"              <addr> may be specified as host:port. If you don't specify\\n\"\n           \"              a port number, the value you specified with -p or -U is\\n\"\n           \"              used. You may specify multiple addresses separated by comma\\n\"\n           \"              or by using -l multiple times\\n\"\n           \"-d            run as a daemon\\n\"\n           \"-r            maximize core file limit\\n\"\n           \"-u <username> assume identity of <username> (only when run as root)\\n\"\n           \"-m <num>      max memory to use for items in megabytes (default: 64 MB)\\n\"\n           \"-M            return error on memory exhausted (rather than removing items)\\n\"\n           \"-c <num>      max simultaneous connections (default: 1000)\\n\"\n           \"-k            lock down all paged memory.  Note that there is a\\n\"\n           \"              limit on how much memory you may lock.  Trying to\\n\"\n           \"              allocate more than that would fail, so be sure you\\n\"\n           \"              set the limit correctly for the user you started\\n\"\n           \"              the daemon with (not for -u <username> user;\\n\"\n           \"              under sh this is done with 'ulimit -S -l NUM_KB').\\n\"\n           \"-v            verbose (print errors/warnings while in event loop)\\n\"\n           \"-vv           very verbose (also print client commands/reponses)\\n\"\n           \"-vvv          extremely verbose (also print internal state transitions)\\n\"\n           \"-h            print this help and exit\\n\"\n           \"-i            print memcached and libevent license\\n\"\n           \"-P <file>     save PID in <file>, only used with -d option\\n\"\n           \"-f <factor>   chunk size growth factor (default: 1.25)\\n\"\n           \"-n <bytes>    minimum space allocated for key+value+flags (default: 48)\\n\");\n    printf(\"-L            Try to use large memory pages (if available). Increasing\\n\"\n           \"              the memory page size could reduce the number of TLB misses\\n\"\n           \"              and improve the performance. In order to get large pages\\n\"\n           \"              from the OS, memcached will allocate the total item-cache\\n\"\n           \"              in one large chunk.\\n\");\n    printf(\"-D <char>     Use <char> as the delimiter between key prefixes and IDs.\\n\"\n           \"              This is used for per-prefix stats reporting. The default is\\n\"\n           \"              \\\":\\\" (colon). If this option is specified, stats collection\\n\"\n           \"              is turned on automatically; if not, then it may be turned on\\n\"\n           \"              by sending the \\\"stats detail on\\\" command to the server.\\n\");\n    printf(\"-t <num>      number of threads to use (default: 4)\\n\");\n    printf(\"-R            Maximum number of requests per event, limits the number of\\n\"\n           \"              requests process for a given connection to prevent \\n\"\n           \"              starvation (default: 20)\\n\");\n    printf(\"-C            Disable use of CAS\\n\");\n    printf(\"-b            Set the backlog queue limit (default: 1024)\\n\");\n    printf(\"-B            Binding protocol - one of ascii, binary, or auto (default)\\n\");\n    printf(\"-I            Override the size of each slab page. Adjusts max item size\\n\"\n           \"              (default: 1mb, min: 1k, max: 128m)\\n\");\n    printf(\"-q            Disable detailed stats commands\\n\");\n#ifdef SASL_ENABLED\n    printf(\"-S            Require SASL authentication\\n\");\n#endif\n    printf(\"-X module,cfg Load the module and initialize it with the config\\n\");\n    printf(\"-E engine     Load engine as the storage engine\\n\");\n    printf(\"-e config     Pass config as configuration options to the storage engine\\n\");\n    printf(\"\\nEnvironment variables:\\n\"\n           \"MEMCACHED_PORT_FILENAME   File to write port information to\\n\"\n           \"MEMCACHED_TOP_KEYS        Number of top keys to keep track of\\n\"\n           \"MEMCACHED_REQS_TAP_EVENT  Similar to -R but for tap_ship_log\\n\");\n}\nstatic void usage_license(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\\n\");\n    printf(\n    \"Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions are\\n\"\n    \"met:\\n\"\n    \"\\n\"\n    \"    * Redistributions of source code must retain the above copyright\\n\"\n    \"notice, this list of conditions and the following disclaimer.\\n\"\n    \"\\n\"\n    \"    * Redistributions in binary form must reproduce the above\\n\"\n    \"copyright notice, this list of conditions and the following disclaimer\\n\"\n    \"in the documentation and/or other materials provided with the\\n\"\n    \"distribution.\\n\"\n    \"\\n\"\n    \"    * Neither the name of the Danga Interactive nor the names of its\\n\"\n    \"contributors may be used to endorse or promote products derived from\\n\"\n    \"this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n\"\n    \"\\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n\"\n    \"A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n\"\n    \"OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n\"\n    \"SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n\"\n    \"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    \"\\n\"\n    \"\\n\"\n    \"This product includes software developed by Niels Provos.\\n\"\n    \"\\n\"\n    \"[ libevent ]\\n\"\n    \"\\n\"\n    \"Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions\\n\"\n    \"are met:\\n\"\n    \"1. Redistributions of source code must retain the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer.\\n\"\n    \"2. Redistributions in binary form must reproduce the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer in the\\n\"\n    \"   documentation and/or other materials provided with the distribution.\\n\"\n    \"3. All advertising materials mentioning features or use of this software\\n\"\n    \"   must display the following acknowledgement:\\n\"\n    \"      This product includes software developed by Niels Provos.\\n\"\n    \"4. The name of the author may not be used to endorse or promote products\\n\"\n    \"   derived from this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\\n\"\n    \"IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\\n\"\n    \"OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\\n\"\n    \"IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\\n\"\n    \"INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\\n\"\n    \"NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\\n\"\n    \"THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    );\n\n    return;\n}\n\nstatic void save_pid(const char *pid_file) {\n    FILE *fp;\n\n    if (access(pid_file, F_OK) == 0) {\n        if ((fp = fopen(pid_file, \"r\")) != NULL) {\n            char buffer[1024];\n            if (fgets(buffer, sizeof(buffer), fp) != NULL) {\n                unsigned int pid;\n                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                               \"WARNING: The pid file contained the following (running) pid: %u\\n\", pid);\n                }\n            }\n            fclose(fp);\n        }\n    }\n\n    if ((fp = fopen(pid_file, \"w\")) == NULL) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"Could not open the pid file %s for writing: %s\\n\",\n                 pid_file, strerror(errno));\n        return;\n    }\n\n    fprintf(fp,\"%ld\\n\", (long)getpid());\n    if (fclose(fp) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not close the pid file %s: %s\\n\",\n                pid_file, strerror(errno));\n    }\n}\n\nstatic void remove_pidfile(const char *pid_file) {\n    if (pid_file != NULL) {\n        if (unlink(pid_file) != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Could not remove the pid file %s: %s\\n\",\n                    pid_file, strerror(errno));\n        }\n    }\n}\n\n#ifndef HAVE_SIGIGNORE\nstatic int sigignore(int sig) {\n    struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {\n        return -1;\n    }\n    return 0;\n}\n#endif /* !HAVE_SIGIGNORE */\n\nstatic void sigterm_handler(int sig) {\n    assert(sig == SIGTERM || sig == SIGINT);\n    memcached_shutdown = 1;\n}\n\nstatic int install_sigterm_handler(void) {\n    struct sigaction sa = {.sa_handler = sigterm_handler, .sa_flags = 0};\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(SIGTERM, &sa, 0) == -1 ||\n        sigaction(SIGINT, &sa, 0) == -1) {\n        return -1;\n    }\n\n    return 0;\n}\n\n/*\n * On systems that supports multiple page sizes we may reduce the\n * number of TLB-misses by using the biggest available page size\n */\nstatic int enable_large_pages(void) {\n#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)\n    int ret = -1;\n    size_t sizes[32];\n    int avail = getpagesizes(sizes, 32);\n    if (avail != -1) {\n        size_t max = sizes[0];\n        struct memcntl_mha arg = {0};\n        int ii;\n\n        for (ii = 1; ii < avail; ++ii) {\n            if (max < sizes[ii]) {\n                max = sizes[ii];\n            }\n        }\n\n        arg.mha_flags   = 0;\n        arg.mha_pagesize = max;\n        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;\n\n        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                  \"Failed to set large pages: %s\\nWill use default page size\\n\",\n                  strerror(errno));\n        } else {\n            ret = 0;\n        }\n    } else {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n          \"Failed to get supported pagesizes: %s\\nWill use default page size\\n\",\n          strerror(errno));\n    }\n\n    return ret;\n#else\n    return 0;\n#endif\n}\n\nstatic const char* get_server_version(void) {\n    return VERSION;\n}\n\nstatic void store_engine_specific(const void *cookie,\n                                  void *engine_data) {\n    conn *c = (conn*)cookie;\n    c->engine_storage = engine_data;\n}\n\nstatic void *get_engine_specific(const void *cookie) {\n    conn *c = (conn*)cookie;\n    return c->engine_storage;\n}\n\nstatic int get_socket_fd(const void *cookie) {\n    conn *c = (conn *)cookie;\n    return c->sfd;\n}\n\nstatic void set_tap_nack_mode(const void *cookie, bool enable) {\n    conn *c = (conn *)cookie;\n    c->tap_nack_mode = enable;\n}\n\nstatic void reserve_cookie(const void *cookie) {\n    conn *c = (conn *)cookie;\n    ++c->refcount;\n}\n\nstatic void release_cookie(const void *cookie) {\n    conn *c = (conn *)cookie;\n    --c->refcount;\n}\n\nstatic int num_independent_stats(void) {\n    return settings.num_threads + 1;\n}\n\nstatic void *new_independent_stats(void) {\n    int ii;\n    int nrecords = num_independent_stats();\n    struct independent_stats *independent_stats = calloc(sizeof(independent_stats) + sizeof(struct thread_stats) * nrecords, 1);\n\n#ifdef INNODB_MEMCACHED\n    if (independent_stats == NULL) {\n\tfprintf(stderr, \"Unable to allocate memory for\"\n\t\t       \"independent_stats...\\n\");\n       return (NULL);\n    }\n#endif\n\n    if (settings.topkeys > 0)\n        independent_stats->topkeys = topkeys_init(settings.topkeys);\n    for (ii = 0; ii < nrecords; ii++)\n        pthread_mutex_init(&independent_stats->thread_stats[ii].mutex, NULL);\n    return independent_stats;\n}\n\nstatic void release_independent_stats(void *stats) {\n    int ii;\n    int nrecords = num_independent_stats();\n    struct independent_stats *independent_stats = stats;\n    if (independent_stats->topkeys)\n        topkeys_free(independent_stats->topkeys);\n    for (ii = 0; ii < nrecords; ii++)\n        pthread_mutex_destroy(&independent_stats->thread_stats[ii].mutex);\n    free(independent_stats);\n}\n\nstatic inline struct independent_stats *get_independent_stats(conn *c) {\n    struct independent_stats *independent_stats;\n    if (settings.engine.v1->get_stats_struct != NULL) {\n        independent_stats = settings.engine.v1->get_stats_struct(settings.engine.v0, (const void *)c);\n        if (independent_stats == NULL)\n            independent_stats = default_independent_stats;\n    } else {\n        independent_stats = default_independent_stats;\n    }\n    return independent_stats;\n}\n\nstatic inline struct thread_stats *get_thread_stats(conn *c) {\n    struct independent_stats *independent_stats = get_independent_stats(c);\n    assert(c->thread->index < num_independent_stats());\n    return &independent_stats->thread_stats[c->thread->index];\n}\n\nstatic void register_callback(ENGINE_HANDLE *eh,\n                              ENGINE_EVENT_TYPE type,\n                              EVENT_CALLBACK cb, const void *cb_data) {\n    struct engine_event_handler *h =\n        calloc(sizeof(struct engine_event_handler), 1);\n\n    assert(h);\n    h->cb = cb;\n    h->cb_data = cb_data;\n    h->next = engine_event_handlers[type];\n    engine_event_handlers[type] = h;\n}\n\nstatic rel_time_t get_current_time(void)\n{\n    return current_time;\n}\n\nstatic void count_eviction(const void *cookie, const void *key, const int nkey) {\n    topkeys_t *tk = get_independent_stats((conn*)cookie)->topkeys;\n    TK(tk, evictions, key, nkey, get_current_time());\n}\n\n/**\n * To make it easy for engine implementors that doesn't want to care about\n * writing their own incr/decr code, they can just set the arithmetic function\n * to NULL and use this implementation. It is not efficient, due to the fact\n * that it does multiple calls through the interface (get and then cas store).\n * If you don't care, feel free to use it..\n */\nstatic ENGINE_ERROR_CODE internal_arithmetic(ENGINE_HANDLE* handle,\n                                             const void* cookie,\n                                             const void* key,\n                                             const int nkey,\n                                             const bool increment,\n                                             const bool create,\n                                             const uint64_t delta,\n                                             const uint64_t initial,\n                                             const rel_time_t exptime,\n                                             uint64_t *cas,\n                                             uint64_t *result,\n                                             uint16_t vbucket)\n{\n    ENGINE_HANDLE_V1 *e = (ENGINE_HANDLE_V1*)handle;\n\n    item *it = NULL;\n\n    ENGINE_ERROR_CODE ret;\n    ret = e->get(handle, cookie, &it, key, nkey, vbucket);\n\n    if (ret == ENGINE_SUCCESS) {\n        item_info info = { .nvalue = 1 };\n\n        if (!e->get_item_info(handle, cookie, it, &info)) {\n            e->release(handle, cookie, it);\n            return ENGINE_FAILED;\n        }\n\n        char value[80];\n\n        if (info.value[0].iov_len > (sizeof(value) - 1)) {\n            e->release(handle, cookie, it);\n            return ENGINE_EINVAL;\n        }\n\n        memcpy(value, info.value[0].iov_base, info.value[0].iov_len);\n        value[info.value[0].iov_len] = '\\0';\n\n        uint64_t val;\n        if (!safe_strtoull(value, &val)) {\n            e->release(handle, cookie, it);\n            return ENGINE_EINVAL;\n        }\n\n        if (increment) {\n            val += delta;\n        } else {\n            if (delta > val) {\n                val = 0;\n            } else {\n                val -= delta;\n            }\n        }\n\n        size_t nb = snprintf(value, sizeof(value), \"%\"PRIu64, val);\n        *result = val;\n        item *nit = NULL;\n        if (e->allocate(handle, cookie, &nit, key,\n                        nkey, nb, info.flags, info.exptime) != ENGINE_SUCCESS) {\n            e->release(handle, cookie, it);\n            return ENGINE_ENOMEM;\n        }\n\n        item_info i2 = { .nvalue = 1 };\n        if (!e->get_item_info(handle, cookie, nit, &i2)) {\n            e->release(handle, cookie, it);\n            e->release(handle, cookie, nit);\n            return ENGINE_FAILED;\n        }\n\n        memcpy(i2.value[0].iov_base, value, nb);\n        e->item_set_cas(handle, cookie, nit, info.cas);\n        ret = e->store(handle, cookie, nit, cas, OPERATION_CAS, vbucket);\n        e->release(handle, cookie, it);\n        e->release(handle, cookie, nit);\n    } else if (ret == ENGINE_KEY_ENOENT && create) {\n        char value[80];\n        size_t nb = snprintf(value, sizeof(value), \"%\"PRIu64\"\\r\\n\", initial);\n        *result = initial;\n        if (e->allocate(handle, cookie, &it, key, nkey, nb, 0, exptime) != ENGINE_SUCCESS) {\n            e->release(handle, cookie, it);\n            return ENGINE_ENOMEM;\n        }\n\n        item_info info = { .nvalue = 1 };\n        if (!e->get_item_info(handle, cookie, it, &info)) {\n            e->release(handle, cookie, it);\n            return ENGINE_FAILED;\n        }\n\n        memcpy(info.value[0].iov_base, value, nb);\n        ret = e->store(handle, cookie, it, cas, OPERATION_CAS, vbucket);\n        e->release(handle, cookie, it);\n    }\n\n    /* We had a race condition.. just call ourself recursively to retry */\n    if (ret == ENGINE_KEY_EEXISTS) {\n        return internal_arithmetic(handle, cookie, key, nkey, increment, create, delta,\n                                   initial, exptime, cas, result, vbucket);\n    }\n\n    return ret;\n}\n\n/**\n * Register an extension if it's not already registered\n *\n * @param type the type of the extension to register\n * @param extension the extension to register\n * @return true if success, false otherwise\n */\nstatic bool register_extension(extension_type_t type, void *extension)\n{\n    if (extension == NULL) {\n        return false;\n    }\n\n    switch (type) {\n    case EXTENSION_DAEMON:\n        for (EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n             ptr != NULL;\n             ptr = ptr->next) {\n            if (ptr == extension) {\n                return false;\n            }\n        }\n        ((EXTENSION_DAEMON_DESCRIPTOR *)(extension))->next = settings.extensions.daemons;\n        settings.extensions.daemons = extension;\n        return true;\n    case EXTENSION_LOGGER:\n        settings.extensions.logger = extension;\n        return true;\n    case EXTENSION_ASCII_PROTOCOL:\n        if (settings.extensions.ascii != NULL) {\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *last;\n            for (last = settings.extensions.ascii; last->next != NULL;\n                 last = last->next) {\n                if (last == extension) {\n                    return false;\n                }\n            }\n            if (last == extension) {\n                return false;\n            }\n            last->next = extension;\n            last->next->next = NULL;\n        } else {\n            settings.extensions.ascii = extension;\n            settings.extensions.ascii->next = NULL;\n        }\n        return true;\n\n    default:\n        return false;\n    }\n}\n\n/**\n * Unregister an extension\n *\n * @param type the type of the extension to remove\n * @param extension the extension to remove\n */\nstatic void unregister_extension(extension_type_t type, void *extension)\n{\n    switch (type) {\n    case EXTENSION_DAEMON:\n        {\n            EXTENSION_DAEMON_DESCRIPTOR *prev = NULL;\n            EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n\n            while (ptr != NULL && ptr != extension) {\n                prev = ptr;\n                ptr = ptr->next;\n            }\n\n            if (ptr != NULL && prev != NULL) {\n                prev->next = ptr->next;\n            }\n\n            if (settings.extensions.daemons == ptr) {\n                settings.extensions.daemons = ptr->next;\n            }\n        }\n        break;\n    case EXTENSION_LOGGER:\n        if (settings.extensions.logger == extension) {\n            if (get_stderr_logger() == extension) {\n                settings.extensions.logger = get_null_logger();\n            } else {\n                settings.extensions.logger = get_stderr_logger();\n            }\n        }\n        break;\n    case EXTENSION_ASCII_PROTOCOL:\n        {\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *prev = NULL;\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *ptr = settings.extensions.ascii;\n\n            while (ptr != NULL && ptr != extension) {\n                prev = ptr;\n                ptr = ptr->next;\n            }\n\n            if (ptr != NULL && prev != NULL) {\n                prev->next = ptr->next;\n            }\n\n            if (settings.extensions.ascii == ptr) {\n                settings.extensions.ascii = ptr->next;\n            }\n        }\n        break;\n\n    default:\n        ;\n    }\n\n}\n\n/**\n * Get the named extension\n */\nstatic void* get_extension(extension_type_t type)\n{\n    switch (type) {\n    case EXTENSION_DAEMON:\n        return settings.extensions.daemons;\n\n    case EXTENSION_LOGGER:\n        return settings.extensions.logger;\n\n    case EXTENSION_ASCII_PROTOCOL:\n        return settings.extensions.ascii;\n\n    default:\n        return NULL;\n    }\n}\n\n#ifdef INNODB_MEMCACHED\nvoid shutdown_server(void) {\n#else\nstatic void shutdown_server(void) {\n#endif /* INNODB_MEMCACHED */\n#ifdef INNODB_MEMCACHED\n    int i;\n    /* Clean up connections */\n    while (listen_conn) {\n\tconn_closing(listen_conn);\n\tlisten_conn = listen_conn->next;\n    }\n\n    for (i = 0; i < num_udp_socket; i++) {\n\tsafe_close(udp_socket[i]);\n    }\n#endif\n    memcached_shutdown = 1;\n}\n\n#ifdef INNODB_MEMCACHED\nbool shutdown_complete(void)\n{\n    return(memcached_shutdown == 2);\n}\n\nbool init_complete(void)\n{\n    return(memcached_initialized == 1);\n}\n#endif\n\nstatic EXTENSION_LOGGER_DESCRIPTOR* get_logger(void)\n{\n    return settings.extensions.logger;\n}\n\nstatic EXTENSION_LOG_LEVEL get_log_level(void)\n{\n    EXTENSION_LOG_LEVEL ret;\n    switch (settings.verbose) {\n    case 0: ret = EXTENSION_LOG_WARNING; break;\n    case 1: ret = EXTENSION_LOG_INFO; break;\n    case 2: ret = EXTENSION_LOG_DEBUG; break;\n    default:\n        ret = EXTENSION_LOG_DETAIL;\n    }\n    return ret;\n}\n\nstatic void set_log_level(EXTENSION_LOG_LEVEL severity)\n{\n    switch (severity) {\n    case EXTENSION_LOG_WARNING: settings.verbose = 0; break;\n    case EXTENSION_LOG_INFO: settings.verbose = 1; break;\n    case EXTENSION_LOG_DEBUG: settings.verbose = 2; break;\n    default:\n        settings.verbose = 3;\n    }\n}\n\nstatic void get_config_append_stats(const char *key, const uint16_t klen,\n                                    const char *val, const uint32_t vlen,\n                                    const void *cookie)\n{\n    if (klen == 0  || vlen == 0) {\n        return ;\n    }\n\n    char *pos = (char*)cookie;\n    size_t nbytes = strlen(pos);\n\n    if ((nbytes + klen + vlen + 3) > 1024) {\n        // Not enough size in the buffer..\n        return;\n    }\n\n    memcpy(pos + nbytes, key, klen);\n    nbytes += klen;\n    pos[nbytes] = '=';\n    ++nbytes;\n    memcpy(pos + nbytes, val, vlen);\n    nbytes += vlen;\n    memcpy(pos + nbytes, \";\", 2);\n}\n\nstatic bool get_config(struct config_item items[]) {\n    char config[1024];\n    config[0] = '\\0';\n    process_stat_settings(get_config_append_stats, config);\n    int rval = parse_config(config, items, NULL);\n    return rval >= 0;\n}\n\n/**\n * Callback the engines may call to get the public server interface\n * @return pointer to a structure containing the interface. The client should\n *         know the layout and perform the proper casts.\n */\nstatic SERVER_HANDLE_V1 *get_server_api(void)\n{\n    static SERVER_CORE_API core_api = {\n        .server_version = get_server_version,\n        .hash = hash,\n        .realtime = realtime,\n        .abstime = abstime,\n        .get_current_time = get_current_time,\n        .parse_config = parse_config,\n        .shutdown = shutdown_server,\n        .get_config = get_config\n    };\n\n    static SERVER_COOKIE_API server_cookie_api = {\n        .get_auth_data = get_auth_data,\n        .store_engine_specific = store_engine_specific,\n        .get_engine_specific = get_engine_specific,\n        .get_socket_fd = get_socket_fd,\n        .set_tap_nack_mode = set_tap_nack_mode,\n        .notify_io_complete = notify_io_complete,\n        .reserve = reserve_cookie,\n        .release = release_cookie\n    };\n\n    static SERVER_STAT_API server_stat_api = {\n        .new_stats = new_independent_stats,\n        .release_stats = release_independent_stats,\n        .evicting = count_eviction\n    };\n\n    static SERVER_LOG_API server_log_api = {\n        .get_logger = get_logger,\n        .get_level = get_log_level,\n        .set_level = set_log_level\n    };\n    static SERVER_EXTENSION_API extension_api = {\n        .register_extension = register_extension,\n        .unregister_extension = unregister_extension,\n        .get_extension = get_extension\n    };\n\n    static SERVER_CALLBACK_API callback_api = {\n        .register_callback = register_callback,\n        .perform_callbacks = perform_callbacks,\n    };\n\n    static SERVER_HANDLE_V1 rv = {\n        .interface = 1,\n        .core = &core_api,\n        .stat = &server_stat_api,\n        .extension = &extension_api,\n        .callback = &callback_api,\n        .log = &server_log_api,\n        .cookie = &server_cookie_api\n    };\n\n    if (rv.engine == NULL) {\n        rv.engine = settings.engine.v0;\n    }\n\n    return &rv;\n}\n\n/**\n * Load a shared object and initialize all the extensions in there.\n *\n * @param soname the name of the shared object (may not be NULL)\n * @param config optional configuration parameters\n * @return true if success, false otherwise\n */\nstatic bool load_extension(const char *soname, const char *config) {\n    if (soname == NULL) {\n        return false;\n    }\n\n    /* Hack to remove the warning from C99 */\n    union my_hack {\n        MEMCACHED_EXTENSIONS_INITIALIZE initialize;\n        void* voidptr;\n    } funky = {.initialize = NULL };\n\n    void *handle = dlopen(soname, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to open library \\\"%s\\\": %s\\n\",\n                soname, msg ? msg : \"unknown error\");\n        return false;\n    }\n\n    void *symbol = dlsym(handle, \"memcached_extensions_initialize\");\n    if (symbol == NULL) {\n        const char *msg = dlerror();\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not find symbol \\\"memcached_extensions_initialize\\\" in %s: %s\\n\",\n                soname, msg ? msg : \"unknown error\");\n        return false;\n    }\n    funky.voidptr = symbol;\n\n    EXTENSION_ERROR_CODE error = (*funky.initialize)(config, get_server_api);\n\n    if (error != EXTENSION_SUCCESS) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to initalize extensions from %s. Error code: %d\\n\",\n                soname, error);\n        dlclose(handle);\n        return false;\n    }\n\n    if (settings.verbose > 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, NULL,\n                \"Loaded extensions from: %s\\n\", soname);\n    }\n\n    return true;\n}\n\n/**\n * Do basic sanity check of the runtime environment\n * @return true if no errors found, false if we can't use this env\n */\nstatic bool sanitycheck(void) {\n    /* One of our biggest problems is old and bogus libevents */\n    const char *ever = event_get_version();\n    if (ever != NULL) {\n        if (strncmp(ever, \"1.\", 2) == 0) {\n            /* Require at least 1.3 (that's still a couple of years old) */\n            if ((ever[2] == '1' || ever[2] == '2') && !isdigit(ever[3])) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"You are using libevent %s.\\nPlease upgrade to\"\n                        \" a more recent version (1.3 or newer)\\n\",\n                        event_get_version());\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n#ifdef INNODB_MEMCACHED\nstatic\nchar*\nmy_strdupl(const char* str, int len)\n{\n\tchar*   s = (char*) malloc(len + 1);\n\ts[len] = 0;\n\treturn((char*) memcpy(s, str, len));\n}\n\n/** Function that messages MySQL config variable string to something\nthat can be parsed by getopt() */\nstatic\nvoid\ndaemon_memcached_make_option(char* option, int* option_argc,\n                             char*** option_argv)\n{\n\tstatic const char*      sep = \" \";\n\tchar*                   last;\n\tchar*                   opt_str;\n\tchar*                   my_str;\n\tint                     num_arg = 0;\n\tint                     i = 1;\n\n\tmy_str = my_strdupl(option, strlen(option));\n\n\tfor (opt_str = strtok_r(my_str, sep, &last);\n\t     opt_str;\n\t     opt_str = strtok_r(NULL, sep, &last)) {\n\t\tnum_arg++;\n\t}\n\n\t/* reset my_str, since strtok_r could alter it */\n\tstrncpy(my_str, option, strlen(option));\n\n\t*option_argv = (char**) malloc((num_arg + 1)\n\t\t\t\t       * sizeof(**option_argv));\n\n\tfor (opt_str = strtok_r(my_str, sep, &last);\n\t     opt_str;\n\t     opt_str = strtok_r(NULL, sep, &last)) {\n\t\t(*option_argv)[i] = opt_str;\n\t\ti++;\n\t}\n\n\tassert(i == num_arg + 1);\n\n\t*option_argc = (num_arg + 1);\n\n\treturn;\n}\n\n/* Structure that adds the call back functions struture pointers,\npassed to InnoDB engine */\ntypedef struct eng_config_info {\n\tchar*           option_string;\n\tvoid*           cb_ptr;\n\tunsigned int    eng_r_batch_size;\n\tunsigned int    eng_w_batch_size;\n\tbool\t\tenable_binlog;\n} eng_config_info_t;\n#endif /* INNODB_MEMCACHED */\n\n#ifdef INNODB_MEMCACHED\nvoid* daemon_memcached_main(void *p) {\n#else\nint main (int argc, char **argv) {\n#endif\n    int c;\n    bool lock_memory = false;\n    bool do_daemonize = false;\n    bool preallocate = false;\n    int maxcore = 0;\n    char *username = NULL;\n    char *pid_file = NULL;\n    struct passwd *pw;\n    struct rlimit rlim;\n    char unit = '\\0';\n    int size_max = 0;\n\n    bool protocol_specified = false;\n    bool tcp_specified = false;\n    bool udp_specified = false;\n    memcached_context_t* m_config = (memcached_context_t*)p;\n    const char *engine;\n    const char *engine_config = NULL;\n    char old_options[1024] = { [0] = '\\0' };\n    char *old_opts = old_options;\n#ifdef INNODB_MEMCACHED\n    int option_argc = 0;\n    char** option_argv = NULL;\n    eng_config_info_t my_eng_config;\n\n    memcached_initialized = 0;\n\n    if (m_config->m_engine_library) {\n\tengine = m_config->m_engine_library;\n\n\t/* FIXME: We should have a better way to pass the callback structure\n\tpoint to storage engine. It is now appended in the configure\n\tstring in eng_config_info_t structure */\n\tmy_eng_config.cb_ptr = m_config->m_innodb_api_cb;\n\tmy_eng_config.eng_r_batch_size = m_config->m_r_batch_size;\n\tmy_eng_config.eng_w_batch_size = m_config->m_w_batch_size;\n\tmy_eng_config.enable_binlog = m_config->m_enable_binlog;\n\tmy_eng_config.option_string = old_opts;\n\tengine_config = (const char *) (&my_eng_config);\n\n    } else {\n\tengine = \"default_engine.so\";\n    }\n#else\n    engine = \"default_engine.so\";\n#endif /* INNODB_MEMCACHED */\n\n    memcached_shutdown = 0;\n    memcached_initialized = 0;\n\n    if (!sanitycheck()) {\n        return(NULL);\n    }\n\n    /* make the time we started always be 2 seconds before we really\n       did, so time(0) - time.started is never zero.  if so, things\n       like 'settings.oldest_live' which act as booleans as well as\n       values are now false in boolean context... */\n    process_started = time(0) - 2;\n    set_current_time();\n\n    /* Initialize the socket subsystem */\n    initialize_sockets();\n\n    /* init settings */\n    settings_init();\n\n    if (memcached_initialize_stderr_logger(get_server_api) != EXTENSION_SUCCESS) {\n        fprintf(stderr, \"Failed to initialize log system\\n\");\n        return (NULL);\n    }\n\n    if (m_config->m_mem_option) {\n\tdaemon_memcached_make_option(m_config->m_mem_option,\n\t\t\t\t     &option_argc,\n\t\t\t\t     &option_argv);\n    }\n\n#ifdef INNODB_MEMCACHED\n\n    if (option_argc > 0 && option_argv) {\n\t    /* Always reset the index to 1, since this function can\n\t    be invoked multiple times with install/uninstall plugins */\n\t    optind = 1;\n\t    while (-1 != (c = getopt(option_argc, option_argv,\n\t\t  \"a:\"  /* access mask for unix socket */\n\t\t  \"p:\"  /* TCP port number to listen on */\n\t\t  \"s:\"  /* unix socket path to listen on */\n\t\t  \"U:\"  /* UDP port number to listen on */\n\t\t  \"m:\"  /* max memory to use for items in megabytes */\n\t\t  \"M\"   /* return error on memory exhausted */\n\t\t  \"c:\"  /* max simultaneous connections */\n\t\t  \"k\"   /* lock down all paged memory */\n\t\t  \"hi\"  /* help, licence info */\n\t\t  \"r\"   /* maximize core file limit */\n\t\t  \"v\"   /* verbose */\n\t\t  \"d\"   /* daemon mode */\n\t\t  \"l:\"  /* interface to listen on */\n\t\t  \"u:\"  /* user identity to run as */\n\t\t  \"P:\"  /* save PID in file */\n\t\t  \"f:\"  /* factor? */\n\t\t  \"n:\"  /* minimum space allocated for key+value+flags */\n\t\t  \"t:\"  /* threads */\n\t\t  \"D:\"  /* prefix delimiter? */\n\t\t  \"L\"   /* Large memory pages */\n\t\t  \"R:\"  /* max requests per event */\n\t\t  \"C\"   /* Disable use of CAS */\n\t\t  \"b:\"  /* backlog queue limit */\n\t\t  \"B:\"  /* Binding protocol */\n\t\t  \"I:\"  /* Max item size */\n\t\t  \"S\"   /* Sasl ON */\n\t\t  \"E:\"  /* Engine to load */\n\t\t  \"e:\"  /* Engine options */\n\t\t  \"q\"   /* Disallow detailed stats */\n\t\t  \"X:\"  /* Load extension */\n\t\t))) {\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t    /* access for unix domain socket, as octal mask (like chmod)*/\n\t\t    settings.access= strtol(optarg,NULL,8);\n\t\t    break;\n\n\t\tcase 'U':\n\t\t    settings.udpport = atoi(optarg);\n\t\t    udp_specified = true;\n\t\t    break;\n\t\tcase 'p':\n\t\t    settings.port = atoi(optarg);\n\t\t    tcp_specified = true;\n\t\t    break;\n\t\tcase 's':\n\t\t    settings.socketpath = optarg;\n\t\t    break;\n\t\tcase 'm':\n\t\t    settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n\t\t     old_opts += sprintf(old_opts, \"cache_size=%lu;\",\n\t\t\t\t\t (unsigned long)settings.maxbytes);\n\t\t   break;\n\t\tcase 'M':\n\t\t    settings.evict_to_free = 0;\n\t\t    old_opts += sprintf(old_opts, \"eviction=false;\");\n\t\t    break;\n\t\tcase 'c':\n\t\t    settings.maxconns = atoi(optarg);\n\t\t    break;\n\t\tcase 'h':\n\t\t    usage();\n\t\t    exit(EXIT_SUCCESS);\n\t\tcase 'i':\n\t\t    usage_license();\n\t\t    exit(EXIT_SUCCESS);\n\t\tcase 'k':\n\t\t    lock_memory = true;\n\t\t    break;\n\t\tcase 'v':\n\t\t    settings.verbose++;\n\t\t    perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n\t\t    break;\n\t\tcase 'l':\n\t\t    settings.inter= strdup(optarg);\n\t\t    break;\n\t\tcase 'd':\n\t\t    do_daemonize = true;\n\t\t    break;\n\t\tcase 'r':\n\t\t    maxcore = 1;\n\t\t    break;\n\t\tcase 'R':\n\t\t    settings.reqs_per_event = atoi(optarg);\n\t\t    if (settings.reqs_per_event <= 0) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t      \"Number of requests per event must be greater than 0\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t    break;\n\t\tcase 'u':\n\t\t    username = optarg;\n\t\t    break;\n\t\tcase 'P':\n\t\t    pid_file = optarg;\n\t\t    break;\n\t\tcase 'f':\n\t\t    settings.factor = atof(optarg);\n\t\t    if (settings.factor <= 1.0) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Factor must be greater than 1\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t     old_opts += sprintf(old_opts, \"factor=%f;\",\n\t\t\t\t\t settings.factor);\n\t\t   break;\n\t\tcase 'n':\n\t\t    settings.chunk_size = atoi(optarg);\n\t\t    if (settings.chunk_size == 0) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Chunk size must be greater than 0\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t    old_opts += sprintf(old_opts, \"chunk_size=%u;\",\n\t\t\t\t\tsettings.chunk_size);\n\t\t    break;\n\t\tcase 't':\n\t\t    settings.num_threads = atoi(optarg);\n\t\t    if (settings.num_threads <= 0) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Number of threads must be greater than 0\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t    /* There're other problems when you get above 64 threads.\n\t\t     * In the future we should portably detect # of cores for the\n\t\t     * default.\n\t\t     */\n\t\t    if (settings.num_threads > 64) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"WARNING: Setting a high number of worker\"\n\t\t\t\t\"threads is not recommended.\\n\"\n\t\t\t\t\" Set this value to the number of cores in\"\n\t\t\t\t\" your machine or less.\\n\");\n\t\t    }\n\t\t    break;\n\t\tcase 'D':\n\t\t    settings.prefix_delimiter = optarg[0];\n\t\t    settings.detail_enabled = 1;\n\t\t    break;\n\t\tcase 'L' :\n\t\t    if (enable_large_pages() == 0) {\n\t\t\tpreallocate = true;\n\t\t\told_opts += sprintf(old_opts, \"preallocate=true;\");\n\t\t    }\n\t\t    break;\n\t\tcase 'C' :\n\t\t    settings.use_cas = false;\n\t\t    break;\n\t\tcase 'b' :\n\t\t    settings.backlog = atoi(optarg);\n\t\t    break;\n\t\tcase 'B':\n\t\t    protocol_specified = true;\n\t\t    if (strcmp(optarg, \"auto\") == 0) {\n\t\t\tsettings.binding_protocol = negotiating_prot;\n\t\t    } else if (strcmp(optarg, \"binary\") == 0) {\n\t\t\tsettings.binding_protocol = binary_prot;\n\t\t    } else if (strcmp(optarg, \"ascii\") == 0) {\n\t\t\tsettings.binding_protocol = ascii_prot;\n\t\t    } else {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Invalid value for binding protocol: %s\\n\"\n\t\t\t\t\" -- should be one of auto, binary, or ascii\\n\", optarg);\n\t\t\texit(EX_USAGE);\n\t\t    }\n\t\t    break;\n\t\tcase 'I':\n\t\t    unit = optarg[strlen(optarg)-1];\n\t\t    if (unit == 'k' || unit == 'm' ||\n\t\t\tunit == 'K' || unit == 'M') {\n\t\t\toptarg[strlen(optarg)-1] = '\\0';\n\t\t\tsize_max = atoi(optarg);\n\t\t\tif (unit == 'k' || unit == 'K')\n\t\t\t    size_max *= 1024;\n\t\t\tif (unit == 'm' || unit == 'M')\n\t\t\t    size_max *= 1024 * 1024;\n\t\t\tsettings.item_size_max = size_max;\n\t\t    } else {\n\t\t\tsettings.item_size_max = atoi(optarg);\n\t\t    }\n\t\t    if (settings.item_size_max < 1024) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Item max size cannot be less than 1024 bytes.\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t    if (settings.item_size_max > 1024 * 1024 * 128) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Cannot set item size limit higher than 128 mb.\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t    if (settings.item_size_max > 1024 * 1024) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t    \"WARNING: Setting item max size above 1MB is not\"\n\t\t\t    \" recommended!\\n\"\n\t\t\t    \" Raising this limit increases the minimum memory requirements\\n\"\n\t\t\t    \" and will decrease your memory efficiency.\\n\"\n\t\t\t);\n\t\t    }\n#ifndef __WIN32__\n\t\t    old_opts += sprintf(old_opts, \"item_size_max=%zu;\",\n\t\t\t\t\tsettings.item_size_max);\n#else\n\t\t    old_opts += sprintf(old_opts, \"item_size_max=%lu;\", (long unsigned)\n\t\t\t\t\tsettings.item_size_max);\n#endif\n\t\t    break;\n\t\tcase 'E':\n\t\t    engine = optarg;\n\t\t    break;\n\t\tcase 'e':\n\t\t    /* FIXME, we use engine_config to pass callback function\n\t\t    for now. Will need a better solution \n\t\t    engine_config = optarg; */\n\t\t    break;\n\t\tcase 'q':\n\t\t    settings.allow_detailed = false;\n\t\t    break;\n\t\tcase 'S': /* set Sasl authentication to true. Default is false */\n# ifdef ENABLE_MEMCACHED_SASL\n#  ifndef SASL_ENABLED\n\t\t    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t    \"This server is not built with SASL support.\\n\");\n\t\t    exit(EX_USAGE);\n#  endif /* !SASL_ENABLED */\n\t\t    settings.require_sasl = true;\n# endif /* ENABLE_MEMCACHED_SASL */\n\t\t    break;\n\t\tcase 'X' :\n\t\t    {\n\t\t\tchar *ptr = strchr(optarg, ',');\n\t\t\tif (ptr != NULL) {\n\t\t\t    *ptr = '\\0';\n\t\t\t    ++ptr;\n\t\t\t}\n\t\t\tif (!load_extension(optarg, ptr)) {\n\t\t\t    exit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tif (ptr != NULL) {\n\t\t\t    *(ptr - 1) = ',';\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t    \"Illegal argument \\\"%c\\\"\\n\", c);\n\t\t    return (void*)1;\n\t\t}\n\t}\n\n\tfree(option_argv);\n    }\n    fprintf(stderr, MEMCACHED_ATOMIC_MSG);\n#else\n    /* process arguments */\n    while (-1 != (c = getopt(argc, argv,\n          \"a:\"  /* access mask for unix socket */\n          \"p:\"  /* TCP port number to listen on */\n          \"s:\"  /* unix socket path to listen on */\n          \"U:\"  /* UDP port number to listen on */\n          \"m:\"  /* max memory to use for items in megabytes */\n          \"M\"   /* return error on memory exhausted */\n          \"c:\"  /* max simultaneous connections */\n          \"k\"   /* lock down all paged memory */\n          \"hi\"  /* help, licence info */\n          \"r\"   /* maximize core file limit */\n          \"v\"   /* verbose */\n          \"d\"   /* daemon mode */\n          \"l:\"  /* interface to listen on */\n          \"u:\"  /* user identity to run as */\n          \"P:\"  /* save PID in file */\n          \"f:\"  /* factor? */\n          \"n:\"  /* minimum space allocated for key+value+flags */\n          \"t:\"  /* threads */\n          \"D:\"  /* prefix delimiter? */\n          \"L\"   /* Large memory pages */\n          \"R:\"  /* max requests per event */\n          \"C\"   /* Disable use of CAS */\n          \"b:\"  /* backlog queue limit */\n          \"B:\"  /* Binding protocol */\n          \"I:\"  /* Max item size */\n          \"S\"   /* Sasl ON */\n          \"E:\"  /* Engine to load */\n          \"e:\"  /* Engine options */\n          \"q\"   /* Disallow detailed stats */\n          \"X:\"  /* Load extension */\n        ))) {\n        switch (c) {\n        case 'a':\n            /* access for unix domain socket, as octal mask (like chmod)*/\n            settings.access= strtol(optarg,NULL,8);\n            break;\n\n        case 'U':\n            settings.udpport = atoi(optarg);\n            udp_specified = true;\n            break;\n        case 'p':\n            settings.port = atoi(optarg);\n            tcp_specified = true;\n            break;\n        case 's':\n            settings.socketpath = optarg;\n            break;\n        case 'm':\n            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n             old_opts += sprintf(old_opts, \"cache_size=%lu;\",\n                                 (unsigned long)settings.maxbytes);\n           break;\n        case 'M':\n            settings.evict_to_free = 0;\n            old_opts += sprintf(old_opts, \"eviction=false;\");\n            break;\n        case 'c':\n            settings.maxconns = atoi(optarg);\n            break;\n        case 'h':\n            usage();\n            exit(EXIT_SUCCESS);\n        case 'i':\n            usage_license();\n            exit(EXIT_SUCCESS);\n        case 'k':\n            lock_memory = true;\n            break;\n        case 'v':\n            settings.verbose++;\n            perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n            break;\n        case 'l':\n            if (settings.inter != NULL) {\n                size_t len = strlen(settings.inter) + strlen(optarg) + 2;\n                char *p = malloc(len);\n                if (p == NULL) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"Failed to allocate memory\\n\");\n                    return 1;\n                }\n                snprintf(p, len, \"%s,%s\", settings.inter, optarg);\n                free(settings.inter);\n                settings.inter = p;\n            } else {\n                settings.inter= strdup(optarg);\n            }\n            break;\n        case 'd':\n            do_daemonize = true;\n            break;\n        case 'r':\n            maxcore = 1;\n            break;\n        case 'R':\n            settings.reqs_per_event = atoi(optarg);\n            if (settings.reqs_per_event <= 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                      \"Number of requests per event must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'u':\n            username = optarg;\n            break;\n        case 'P':\n            pid_file = optarg;\n            break;\n        case 'f':\n            settings.factor = atof(optarg);\n            if (settings.factor <= 1.0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Factor must be greater than 1\\n\");\n                return 1;\n            }\n             old_opts += sprintf(old_opts, \"factor=%f;\",\n                                 settings.factor);\n           break;\n        case 'n':\n            settings.chunk_size = atoi(optarg);\n            if (settings.chunk_size == 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Chunk size must be greater than 0\\n\");\n                return 1;\n            }\n            old_opts += sprintf(old_opts, \"chunk_size=%u;\",\n                                settings.chunk_size);\n            break;\n        case 't':\n            settings.num_threads = atoi(optarg);\n            if (settings.num_threads <= 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Number of threads must be greater than 0\\n\");\n                return 1;\n            }\n            /* There're other problems when you get above 64 threads.\n             * In the future we should portably detect # of cores for the\n             * default.\n             */\n            if (settings.num_threads > 64) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"WARNING: Setting a high number of worker\"\n                        \"threads is not recommended.\\n\"\n                        \" Set this value to the number of cores in\"\n                        \" your machine or less.\\n\");\n            }\n            break;\n        case 'D':\n            settings.prefix_delimiter = optarg[0];\n            settings.detail_enabled = 1;\n            break;\n        case 'L' :\n            if (enable_large_pages() == 0) {\n                preallocate = true;\n                old_opts += sprintf(old_opts, \"preallocate=true;\");\n            }\n            break;\n        case 'C' :\n            settings.use_cas = false;\n            break;\n        case 'b' :\n            settings.backlog = atoi(optarg);\n            break;\n        case 'B':\n            protocol_specified = true;\n            if (strcmp(optarg, \"auto\") == 0) {\n                settings.binding_protocol = negotiating_prot;\n            } else if (strcmp(optarg, \"binary\") == 0) {\n                settings.binding_protocol = binary_prot;\n            } else if (strcmp(optarg, \"ascii\") == 0) {\n                settings.binding_protocol = ascii_prot;\n            } else {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Invalid value for binding protocol: %s\\n\"\n                        \" -- should be one of auto, binary, or ascii\\n\", optarg);\n                exit(EX_USAGE);\n            }\n            break;\n        case 'I':\n            unit = optarg[strlen(optarg)-1];\n            if (unit == 'k' || unit == 'm' ||\n                unit == 'K' || unit == 'M') {\n                optarg[strlen(optarg)-1] = '\\0';\n                size_max = atoi(optarg);\n                if (unit == 'k' || unit == 'K')\n                    size_max *= 1024;\n                if (unit == 'm' || unit == 'M')\n                    size_max *= 1024 * 1024;\n                settings.item_size_max = size_max;\n            } else {\n                settings.item_size_max = atoi(optarg);\n            }\n            if (settings.item_size_max < 1024) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Item max size cannot be less than 1024 bytes.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024 * 128) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Cannot set item size limit higher than 128 mb.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"WARNING: Setting item max size above 1MB is not\"\n                    \" recommended!\\n\"\n                    \" Raising this limit increases the minimum memory requirements\\n\"\n                    \" and will decrease your memory efficiency.\\n\"\n                );\n            }\n#ifndef __WIN32__\n            old_opts += sprintf(old_opts, \"item_size_max=%zu;\",\n                                settings.item_size_max);\n#else\n            old_opts += sprintf(old_opts, \"item_size_max=%lu;\", (long unsigned)\n                                settings.item_size_max);\n#endif\n            break;\n        case 'E':\n            engine = optarg;\n            break;\n        case 'e':\n            engine_config = optarg;\n            break;\n        case 'q':\n            settings.allow_detailed = false;\n            break;\n        case 'S': /* set Sasl authentication to true. Default is false */\n#ifndef SASL_ENABLED\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"This server is not built with SASL support.\\n\");\n            exit(EX_USAGE);\n#endif\n            settings.require_sasl = true;\n            break;\n        case 'X' :\n            {\n                char *ptr = strchr(optarg, ',');\n                if (ptr != NULL) {\n                    *ptr = '\\0';\n                    ++ptr;\n                }\n                if (!load_extension(optarg, ptr)) {\n                    exit(EXIT_FAILURE);\n                }\n                if (ptr != NULL) {\n                    *(ptr - 1) = ',';\n                }\n            }\n            break;\n        default:\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n#endif /* INNODB_MEMCACHED */\n\n    if (getenv(\"MEMCACHED_REQS_TAP_EVENT\") != NULL) {\n        settings.reqs_per_tap_event = atoi(getenv(\"MEMCACHED_REQS_TAP_EVENT\"));\n    }\n\n    if (settings.reqs_per_tap_event <= 0) {\n        settings.reqs_per_tap_event = DEFAULT_REQS_PER_TAP_EVENT;\n    }\n\n\n    if (install_sigterm_handler() != 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"Failed to install SIGTERM handler\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    char *topkeys_env = getenv(\"MEMCACHED_TOP_KEYS\");\n    if (topkeys_env != NULL) {\n        settings.topkeys = atoi(topkeys_env);\n        if (settings.topkeys < 0) {\n            settings.topkeys = 0;\n        }\n    }\n\n    if (settings.require_sasl) {\n        if (!protocol_specified) {\n            settings.binding_protocol = binary_prot;\n        } else {\n            if (settings.binding_protocol == negotiating_prot) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"ERROR: You cannot use auto-negotiating protocol while requiring SASL.\\n\");\n                exit(EX_USAGE);\n            }\n            if (settings.binding_protocol == ascii_prot) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"ERROR: You cannot use only ASCII protocol while requiring SASL.\\n\");\n                exit(EX_USAGE);\n            }\n        }\n    }\n\n    if (tcp_specified && !udp_specified) {\n        settings.udpport = settings.port;\n    } else if (udp_specified && !tcp_specified) {\n        settings.port = settings.udpport;\n    }\n\n    /*\n    if (engine_config != NULL && strlen(old_options) > 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"ERROR: You can't mix -e with the old options\\n\");\n        return (NULL);\n    } else if (engine_config == NULL && strlen(old_options) > 0) {\n        engine_config = old_options;\n    } */\n\n    if (maxcore != 0) {\n        struct rlimit rlim_new;\n        /*\n         * First try raising to infinity; if that fails, try bringing\n         * the soft limit to the hard.\n         */\n        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {\n            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;\n            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {\n                /* failed. try raising just to the old max */\n                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;\n                (void)setrlimit(RLIMIT_CORE, &rlim_new);\n            }\n        }\n        /*\n         * getrlimit again to see what we ended up with. Only fail if\n         * the soft limit ends up 0, because then no core files will be\n         * created at all.\n         */\n\n        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to ensure corefile creation\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /*\n     * If needed, increase rlimits to allow as many connections\n     * as needed.\n     */\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"failed to getrlimit number of files\\n\");\n        exit(EX_OSERR);\n    } else {\n        int maxfiles = settings.maxconns;\n        if (rlim.rlim_cur < maxfiles)\n            rlim.rlim_cur = maxfiles;\n        if (rlim.rlim_max < rlim.rlim_cur)\n            rlim.rlim_max = rlim.rlim_cur;\n        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to set rlimit for open files. Try running as\"\n                    \" root or requesting smaller maxconns value.\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /* Sanity check for the connection structures */\n    int nfiles = 0;\n    if (settings.port != 0) {\n        nfiles += 2;\n    }\n    if (settings.udpport != 0) {\n        nfiles += settings.num_threads * 2;\n    }\n\n    if (settings.maxconns <= nfiles) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Configuratioin error. \\n\"\n                \"You specified %d connections, but the system will use at \"\n                \"least %d\\nconnection structures to start.\\n\",\n                settings.maxconns, nfiles);\n        exit(EX_USAGE);\n    }\n\n    /* lose root privileges if we have them */\n    if (getuid() == 0 || geteuid() == 0) {\n        if (username == 0 || *username == '\\0') {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"can't run as root without the -u switch\\n\");\n            exit(EX_USAGE);\n        }\n        if ((pw = getpwnam(username)) == 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"can't find the user %s to switch to\\n\", username);\n            exit(EX_NOUSER);\n        }\n        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to assume identity of user %s: %s\\n\", username,\n                    strerror(errno));\n            exit(EX_OSERR);\n        }\n    }\n\n#ifdef SASL_ENABLED\n    init_sasl();\n#endif /* SASL */\n\n    /* daemonize if requested */\n    /* if we want to ensure our ability to dump core, don't chdir to / */\n    if (do_daemonize) {\n        if (sigignore(SIGHUP) == -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Failed to ignore SIGHUP: \", strerror(errno));\n        }\n        if (daemonize(maxcore, settings.verbose) == -1) {\n             settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to daemon() in order to daemonize\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* lock paged memory if needed */\n    if (lock_memory) {\n#ifdef HAVE_MLOCKALL\n        int res = mlockall(MCL_CURRENT | MCL_FUTURE);\n        if (res != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"warning: -k invalid, mlockall() failed: %s\\n\",\n                    strerror(errno));\n        }\n#else\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\\n\");\n#endif\n    }\n\n    /* initialize main thread libevent instance */\n    main_base = event_init();\n\n    /* Load the storage engine */\n    ENGINE_HANDLE *engine_handle = NULL;\n    if (!load_engine(engine,get_server_api,settings.extensions.logger,&engine_handle)) {\n        /* Error already reported */\n        exit(EXIT_FAILURE);\n    }\n\n#ifdef INNODB_MEMCACHED\n    my_thread_init();\n#endif\n\n    if(!init_engine(engine_handle,engine_config,settings.extensions.logger)) {\n#ifdef INNODB_MEMCACHED\n\tmy_thread_end();\n        shutdown_server();\n        goto func_exit;\n#else\n\treturn(false);\n#endif /* INNODB_MEMCACHED */\n    }\n\n    if(settings.verbose > 0) {\n        log_engine_details(engine_handle,settings.extensions.logger);\n    }\n    settings.engine.v1 = (ENGINE_HANDLE_V1 *) engine_handle;\n\n    if (settings.engine.v1->arithmetic == NULL) {\n        settings.engine.v1->arithmetic = internal_arithmetic;\n    }\n\n    /* initialize other stuff */\n    stats_init();\n\n    if (!(conn_cache = cache_create(\"conn\", sizeof(conn), sizeof(void*),\n                                    conn_constructor, conn_destructor))) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to create connection cache\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    default_independent_stats = new_independent_stats();\n\n#ifdef INNODB_MEMCACHED\n    if (!default_independent_stats) {\n\texit(EXIT_FAILURE);\n    }\n#endif\n\n#ifndef __WIN32__\n    /*\n     * ignore SIGPIPE signals; we can use errno == EPIPE if we\n     * need that information\n     */\n    if (sigignore(SIGPIPE) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"failed to ignore SIGPIPE; sigaction\");\n        exit(EX_OSERR);\n    }\n#endif\n\n    /* start up worker threads if MT mode */\n    thread_init(settings.num_threads, main_base, dispatch_event_handler);\n\n    /* initialise clock event */\n    clock_handler(0, 0, 0);\n\n    /* create unix mode sockets after dropping privileges */\n    if (settings.socketpath != NULL) {\n        if (server_socket_unix(settings.socketpath,settings.access)) {\n            vperror(\"failed to listen on UNIX socket: %s\", settings.socketpath);\n            exit(EX_OSERR);\n        }\n    }\n\n    /* create the listening socket, bind it, and init */\n    if (settings.socketpath == NULL) {\n        int udp_port;\n\n        const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");\n        char temp_portnumber_filename[PATH_MAX];\n        FILE *portnumber_file = NULL;\n\n        if (portnumber_filename != NULL) {\n            snprintf(temp_portnumber_filename,\n                     sizeof(temp_portnumber_filename),\n                     \"%s.lck\", portnumber_filename);\n\n            portnumber_file = fopen(temp_portnumber_filename, \"a\");\n            if (portnumber_file == NULL) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Failed to open \\\"%s\\\": %s\\n\",\n                        temp_portnumber_filename, strerror(errno));\n            }\n        }\n\n        if (settings.port && server_sockets(settings.port, tcp_transport,\n                                            portnumber_file)) {\n\t\tvperror(\"failed to listen on TCP port %d\", settings.port);\n#ifdef INNODB_MEMCACHED\n\t\tmy_thread_end();\n\t\tshutdown_server();\n\t\tgoto func_exit;\n#else\n\t\texit(EX_OSERR);\n#endif /* INNODB_MEMCACHED */\n        }\n\n        /*\n         * initialization order: first create the listening sockets\n         * (may need root on low ports), then drop root if needed,\n         * then daemonise if needed, then init libevent (in some cases\n         * descriptors created by libevent wouldn't survive forking).\n         */\n        udp_port = settings.udpport ? settings.udpport : settings.port;\n\n        /* create the UDP listening socket and bind it */\n        if (settings.udpport && server_sockets(settings.udpport, udp_transport,\n                                               portnumber_file)) {\n            vperror(\"failed to listen on UDP port %d\", settings.udpport);\n            exit(EX_OSERR);\n        }\n\n        if (portnumber_file) {\n            fclose(portnumber_file);\n            rename(temp_portnumber_filename, portnumber_filename);\n        }\n    }\n\n    if (pid_file != NULL) {\n        save_pid(pid_file);\n    }\n\n    /* Drop privileges no longer needed */\n    drop_privileges();\n\n    memcached_initialized = 1;\n\n    /* enter the event loop */\n    event_base_loop(main_base, 0);\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, NULL,\n                                        \"Initiating shutdown\\n\");\n    }\n\nfunc_exit:\n\n    if (settings.engine.v1)\n      settings.engine.v1->destroy(settings.engine.v0, false);\n\n    threads_shutdown();\n\n    /* remove the PID file if we're a daemon */\n    if (do_daemonize)\n        remove_pidfile(pid_file);\n    /* Clean up strdup() call for bind() address */\n    if (settings.inter)\n      free(settings.inter);\n\n#ifdef INNODB_MEMCACHED\n    /* free event base */\n    if (main_base) {\n        event_base_free(main_base);\n        main_base = NULL;\n    }\n    my_thread_end();\n#endif\n\n    memcached_shutdown = 2;\n    memcached_initialized = 2;\n\n    return EXIT_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/plugin/innodb_memcached/daemon_memcached/utilities/engine_loader.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include \"config.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <dlfcn.h>\n#include \"utilities/engine_loader.h\"\n#include <memcached/types.h>\n\nstatic const char * const feature_descriptions[] = {\n    \"compare and swap\",\n    \"persistent storage\",\n    \"secondary engine\",\n    \"access control\",\n    \"multi tenancy\",\n    \"LRU\"\n};\n\nvoid *handle = NULL;\n\nbool load_engine(const char *soname,\n                 SERVER_HANDLE_V1 *(*get_server_api)(void),\n                 EXTENSION_LOGGER_DESCRIPTOR *logger,\n                 ENGINE_HANDLE **engine_handle)\n{\n    ENGINE_HANDLE *engine = NULL;\n    /* Hack to remove the warning from C99 */\n    union my_hack {\n        CREATE_INSTANCE create;\n        void* voidptr;\n    } my_create = {.create = NULL };\n\n    handle = dlopen(soname, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to open library \\\"%s\\\": %s\\n\",\n                soname ? soname : \"self\",\n                msg ? msg : \"unknown error\");\n        return false;\n    }\n\n    void *symbol = dlsym(handle, \"create_instance\");\n    if (symbol == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not find symbol \\\"create_instance\\\" in %s: %s\\n\",\n                soname ? soname : \"self\",\n                dlerror());\n        return false;\n    }\n    my_create.voidptr = symbol;\n\n    /* request a instance with protocol version 1 */\n    ENGINE_ERROR_CODE error = (*my_create.create)(1, get_server_api, &engine);\n\n    if (error != ENGINE_SUCCESS || engine == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to create instance. Error code: %d\\n\", error);\n        dlclose(handle);\n        return false;\n    }\n    *engine_handle = engine;\n    return true;\n}\n\nbool init_engine(ENGINE_HANDLE * engine,\n                 const char *config_str,\n                 EXTENSION_LOGGER_DESCRIPTOR *logger)\n{\n    ENGINE_HANDLE_V1 *engine_v1 = NULL;\n\n    if (handle == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to initialize engine, engine must fist be loaded.\");\n        return false;\n    }\n\n    if (engine->interface == 1) {\n        engine_v1 = (ENGINE_HANDLE_V1*)engine;\n\n        // validate that the required engine interface is implemented:\n        if (engine_v1->get_info == NULL || engine_v1->initialize == NULL ||\n            engine_v1->destroy == NULL || engine_v1->allocate == NULL ||\n            engine_v1->remove == NULL || engine_v1->release == NULL ||\n            engine_v1->get == NULL || engine_v1->store == NULL ||\n            engine_v1->flush == NULL ||\n            engine_v1->get_stats == NULL || engine_v1->reset_stats == NULL ||\n            engine_v1->item_set_cas == NULL ||\n            engine_v1->get_item_info == NULL)\n        {\n            logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Failed to initialize engine; it does not implement the engine interface.\");\n            return false;\n        }\n\n        ENGINE_ERROR_CODE error = engine_v1->initialize(engine,config_str);\n        if (error != ENGINE_SUCCESS) {\n            engine_v1->destroy(engine, false);\n            logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Failed to initialize instance. Error code: %d\\n\",\n                    error);\n            dlclose(handle);\n            return false;\n        }\n    } else {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"Unsupported interface level\\n\");\n        dlclose(handle);\n        return false;\n    }\n    return true;\n}\n\nvoid log_engine_details(ENGINE_HANDLE * engine,\n                        EXTENSION_LOGGER_DESCRIPTOR *logger)\n{\n    ENGINE_HANDLE_V1 *engine_v1 = (ENGINE_HANDLE_V1*)engine;\n    const engine_info *info;\n    info = engine_v1->get_info(engine);\n    if (info) {\n        char message[4096];\n        ssize_t nw = snprintf(message, sizeof(message), \"Loaded engine: %s\\n\",\n                                        info->description ?\n                                        info->description : \"Unknown\");\n        if (nw == -1) {\n            return;\n        }\n        ssize_t offset = nw;\n        bool comma = false;\n\n        if (info->num_features > 0) {\n            nw = snprintf(message + offset, sizeof(message) - offset,\n                          \"Supplying the following features: \");\n            if (nw == -1) {\n                return;\n            }\n            offset += nw;\n            for (int ii = 0; ii < info->num_features; ++ii) {\n                if (info->features[ii].description != NULL) {\n                    // We don't want to write partially from source\n                    if (sizeof(message)-offset <=\n                        2+strlen(info->features[ii].description))\n                    {\n                        return;\n                    }\n\n                    nw = snprintf(message + offset, sizeof(message) - offset,\n                                  \"%s%s\", comma ? \", \" : \"\",\n                                  info->features[ii].description);\n                } else {\n                    if (info->features[ii].feature <= LAST_REGISTERED_ENGINE_FEATURE) {\n                        nw = snprintf(message + offset, sizeof(message) - offset,\n                                      \"%s%s\", comma ? \", \" : \"\",\n                                      feature_descriptions[info->features[ii].feature]);\n                    } else {\n                        nw = snprintf(message + offset, sizeof(message) - offset,\n                                      \"%sUnknown feature: %d\", comma ? \", \" : \"\",\n                                      info->features[ii].feature);\n                    }\n                }\n                comma = true;\n                if (nw == -1) {\n                    return;\n                }\n                offset += nw;\n            }\n        }\n        logger->log(EXTENSION_LOG_INFO, NULL, \"%s\\n\", message);\n    } else {\n        logger->log(EXTENSION_LOG_INFO, NULL,\n                                        \"Loaded engine: Unknown\\n\");\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/plugin/innodb_memcached/daemon_memcached/programs/engine_testapp.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include \"config.h\"\n#include <assert.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <signal.h>\n#include <pthread.h>\n#include \"utilities/engine_loader.h\"\n#include <memcached/engine_testapp.h>\n#include <memcached/extension_loggers.h>\n#include <mock_server.h>\n\nstruct mock_engine {\n    ENGINE_HANDLE_V1 me;\n    ENGINE_HANDLE_V1 *the_engine;\n    TAP_ITERATOR iterator;\n};\n\n#ifndef WIN32\nstatic sig_atomic_t alarmed;\n\nstatic void alarm_handler(int sig) {\n    alarmed = 1;\n}\n#endif\n\nstatic inline struct mock_engine* get_handle(ENGINE_HANDLE* handle) {\n    return (struct mock_engine*)handle;\n}\n\nstatic tap_event_t mock_tap_iterator(ENGINE_HANDLE* handle,\n                                     const void *cookie, item **itm,\n                                     void **es, uint16_t *nes, uint8_t *ttl,\n                                     uint16_t *flags, uint32_t *seqno,\n                                     uint16_t *vbucket) {\n   struct mock_engine *me = get_handle(handle);\n   return me->iterator((ENGINE_HANDLE*)me->the_engine, cookie, itm, es, nes,\n                       ttl, flags, seqno, vbucket);\n}\n\nstatic const engine_info* mock_get_info(ENGINE_HANDLE* handle) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_info((ENGINE_HANDLE*)me->the_engine);\n}\n\nstatic ENGINE_ERROR_CODE mock_initialize(ENGINE_HANDLE* handle,\n                                         const char* config_str) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->initialize((ENGINE_HANDLE*)me->the_engine, config_str);\n}\n\nstatic void mock_destroy(ENGINE_HANDLE* handle, const bool force) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->destroy((ENGINE_HANDLE*)me->the_engine, force);\n}\n\nstatic ENGINE_ERROR_CODE mock_allocate(ENGINE_HANDLE* handle,\n                                       const void* cookie,\n                                       item **item,\n                                       const void* key,\n                                       const size_t nkey,\n                                       const size_t nbytes,\n                                       const int flags,\n                                       const rel_time_t exptime) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->allocate((ENGINE_HANDLE*)me->the_engine, c,\n                                           item, key, nkey,\n                                           nbytes, flags,\n                                           exptime)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_remove(ENGINE_HANDLE* handle,\n                                     const void* cookie,\n                                     const void* key,\n                                     const size_t nkey,\n                                     uint64_t cas,\n                                     uint16_t vbucket)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->remove((ENGINE_HANDLE*)me->the_engine, c, key,\n                                         nkey, cas, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_release(ENGINE_HANDLE* handle,\n                         const void *cookie,\n                         item* item) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->release((ENGINE_HANDLE*)me->the_engine, cookie, item);\n}\n\nstatic ENGINE_ERROR_CODE mock_get(ENGINE_HANDLE* handle,\n                                  const void* cookie,\n                                  item** item,\n                                  const void* key,\n                                  const int nkey,\n                                  uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->get((ENGINE_HANDLE*)me->the_engine, c, item,\n                                      key, nkey, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_get_stats(ENGINE_HANDLE* handle,\n                                        const void* cookie,\n                                        const char* stat_key,\n                                        int nkey,\n                                        ADD_STAT add_stat)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->get_stats((ENGINE_HANDLE*)me->the_engine, c, stat_key,\n                                            nkey, add_stat)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_store(ENGINE_HANDLE* handle,\n                                    const void *cookie,\n                                    item* item,\n                                    uint64_t *cas,\n                                    ENGINE_STORE_OPERATION operation,\n                                    uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->store((ENGINE_HANDLE*)me->the_engine, c, item, cas,\n                                        operation, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_arithmetic(ENGINE_HANDLE* handle,\n                                         const void* cookie,\n                                         const void* key,\n                                         const int nkey,\n                                         const bool increment,\n                                         const bool create,\n                                         const uint64_t delta,\n                                         const uint64_t initial,\n                                         const rel_time_t exptime,\n                                         uint64_t *cas,\n                                         uint64_t *result,\n                                         uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->arithmetic((ENGINE_HANDLE*)me->the_engine, c, key,\n                                             nkey, increment, create,\n                                             delta, initial, exptime,\n                                             cas, result, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_flush(ENGINE_HANDLE* handle,\n                                    const void* cookie, time_t when) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->flush((ENGINE_HANDLE*)me->the_engine, c, when)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_reset_stats(ENGINE_HANDLE* handle, const void *cookie) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->reset_stats((ENGINE_HANDLE*)me->the_engine, cookie);\n}\n\nstatic ENGINE_ERROR_CODE mock_unknown_command(ENGINE_HANDLE* handle,\n                                              const void* cookie,\n                                              protocol_binary_request_header *request,\n                                              ADD_RESPONSE response)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->unknown_command((ENGINE_HANDLE*)me->the_engine, c,\n                                                  request, response)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_item_set_cas(ENGINE_HANDLE *handle, const void *cookie,\n                              item* item, uint64_t val)\n{\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->item_set_cas((ENGINE_HANDLE*)me->the_engine, cookie, item, val);\n}\n\n\nstatic bool mock_get_item_info(ENGINE_HANDLE *handle, const void *cookie,\n                               const item* item, item_info *item_info)\n{\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_item_info((ENGINE_HANDLE*)me->the_engine,\n                                         cookie, item, item_info);\n}\n\nstatic void *mock_get_stats_struct(ENGINE_HANDLE* handle, const void* cookie)\n{\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_stats_struct((ENGINE_HANDLE*)me->the_engine, cookie);\n}\n\nstatic ENGINE_ERROR_CODE mock_aggregate_stats(ENGINE_HANDLE* handle,\n                                              const void* cookie,\n                                              void (*callback)(void*, void*),\n                                              void *vptr)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->aggregate_stats((ENGINE_HANDLE*)me->the_engine, c,\n                                                  callback, vptr)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_tap_notify(ENGINE_HANDLE* handle,\n                                        const void *cookie,\n                                        void *engine_specific,\n                                        uint16_t nengine,\n                                        uint8_t ttl,\n                                        uint16_t tap_flags,\n                                        tap_event_t tap_event,\n                                        uint32_t tap_seqno,\n                                        const void *key,\n                                        size_t nkey,\n                                        uint32_t flags,\n                                        uint32_t exptime,\n                                        uint64_t cas,\n                                        const void *data,\n                                        size_t ndata,\n                                         uint16_t vbucket) {\n\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->tap_notify((ENGINE_HANDLE*)me->the_engine, c,\n                                             engine_specific, nengine, ttl, tap_flags,\n                                             tap_event, tap_seqno, key, nkey, flags,\n                                             exptime, cas, data, ndata, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\n\nstatic TAP_ITERATOR mock_get_tap_iterator(ENGINE_HANDLE* handle, const void* cookie,\n                                           const void* client, size_t nclient,\n                                           uint32_t flags,\n                                           const void* userdata, size_t nuserdata) {\n    struct mock_engine *me = get_handle(handle);\n    me->iterator = me->the_engine->get_tap_iterator((ENGINE_HANDLE*)me->the_engine, cookie,\n                                                    client, nclient, flags, userdata, nuserdata);\n    return (me->iterator != NULL) ? mock_tap_iterator : NULL;\n}\n\nstatic size_t mock_errinfo(ENGINE_HANDLE *handle, const void* cookie,\n                           char *buffer, size_t buffsz) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->errinfo((ENGINE_HANDLE*)me->the_engine, cookie,\n                                   buffer, buffsz);\n}\n\n\nstruct mock_engine default_mock_engine = {\n    .me = {\n        .interface = {\n            .interface = 1\n        },\n        .get_info = mock_get_info,\n        .initialize = mock_initialize,\n        .destroy = mock_destroy,\n        .allocate = mock_allocate,\n        .remove = mock_remove,\n        .release = mock_release,\n        .get = mock_get,\n        .store = mock_store,\n        .arithmetic = mock_arithmetic,\n        .flush = mock_flush,\n        .get_stats = mock_get_stats,\n        .reset_stats = mock_reset_stats,\n        .get_stats_struct = mock_get_stats_struct,\n        .aggregate_stats = mock_aggregate_stats,\n        .unknown_command = mock_unknown_command,\n        .tap_notify = mock_tap_notify,\n        .get_tap_iterator = mock_get_tap_iterator,\n        .item_set_cas = mock_item_set_cas,\n        .get_item_info = mock_get_item_info,\n        .errinfo = mock_errinfo\n    }\n};\nstruct mock_engine mock_engine;\n\nEXTENSION_LOGGER_DESCRIPTOR *logger_descriptor = NULL;\nstatic ENGINE_HANDLE *handle = NULL;\nstatic ENGINE_HANDLE_V1 *handle_v1 = NULL;\n\nstatic void usage(void) {\n    printf(\"\\n\");\n    printf(\"engine_testapp -E <path_to_engine_lib> -T <path_to_testlib>\\n\");\n    printf(\"               [-e <engine_config>] [-h]\\n\");\n    printf(\"\\n\");\n    printf(\"-E <path_to_engine_lib>      Path to the engine library file. The\\n\");\n    printf(\"                             engine library file is a library file\\n\");\n    printf(\"                             (.so or .dll) that the contains the \\n\");\n    printf(\"                             implementation of the engine being\\n\");\n    printf(\"                             tested.\\n\");\n    printf(\"\\n\");\n    printf(\"-T <path_to_testlib>         Path to the test library file. The test\\n\");\n    printf(\"                             library file is a library file (.so or\\n\");\n    printf(\"                             .dll) that contains the set of tests\\n\");\n    printf(\"                             to be executed.\\n\");\n    printf(\"\\n\");\n    printf(\"-t <timeout>                 Maximum time to run a test.\\n\");\n    printf(\"-e <engine_config>           Engine configuration string passed to\\n\");\n    printf(\"                             the engine.\\n\");\n    printf(\"-q                           Only print errors.\");\n    printf(\"-.                           Print a . for each executed test.\");\n    printf(\"\\n\");\n    printf(\"-h                           Prints this usage text.\\n\");\n    printf(\"\\n\");\n}\n\nstatic int report_test(const char *name, enum test_result r, bool quiet) {\n    int rc = 0;\n    char *msg = NULL;\n    bool color_enabled = getenv(\"TESTAPP_ENABLE_COLOR\") != NULL;\n    int color = 0;\n    char color_str[8] = { 0 };\n    char *reset_color = \"\\033[m\";\n    switch(r) {\n    case SUCCESS:\n        msg=\"OK\";\n        color = 32;\n        break;\n    case SKIPPED:\n        msg=\"SKIPPED\";\n        color = 32;\n        break;\n    case FAIL:\n        color = 31;\n        msg=\"FAIL\";\n        rc = 1;\n        break;\n    case DIED:\n        color = 31;\n        msg = \"DIED\";\n        rc = 1;\n        break;\n    case TIMEOUT:\n        color = 31;\n        msg = \"TIMED OUT\";\n        rc = 1;\n        break;\n    case CORE:\n        color = 31;\n        msg = \"CORE DUMPED\";\n        rc = 1;\n        break;\n    case PENDING:\n        color = 33;\n        msg = \"PENDING\";\n        break;\n    }\n    assert(msg);\n    if (color_enabled) {\n        snprintf(color_str, sizeof(color_str), \"\\033[%dm\", color);\n    }\n    if (quiet) {\n        if (r != SUCCESS) {\n            printf(\"%s:  %s%s%s\\n\", name, color_str, msg,\n                   color_enabled ? reset_color : \"\");\n            fflush(stdout);\n        }\n    } else {\n        printf(\"%s%s%s\\n\", color_str, msg, color_enabled ? reset_color : \"\");\n    }\n    return rc;\n}\n\nstatic ENGINE_HANDLE_V1 *start_your_engines(const char *engine, const char* cfg, bool engine_init) {\n\n    init_mock_server(handle);\n    if (!load_engine(engine, &get_mock_server_api, logger_descriptor, &handle)) {\n        fprintf(stderr, \"Failed to load engine %s.\\n\", engine);\n        return NULL;\n    }\n\n    if (engine_init) {\n        if(!init_engine(handle, cfg, logger_descriptor)) {\n            fprintf(stderr, \"Failed to init engine %s with config %s.\\n\", engine, cfg);\n            return NULL;\n        }\n    }\n\n    mock_engine = default_mock_engine;\n    handle_v1 = mock_engine.the_engine = (ENGINE_HANDLE_V1*)handle;\n    handle = (ENGINE_HANDLE*)&mock_engine.me;\n    handle_v1 = &mock_engine.me;\n\n    // Reset all members that aren't set (to allow the users to write\n    // testcases to verify that they initialize them..\n    assert(mock_engine.me.interface.interface == mock_engine.the_engine->interface.interface);\n\n    if (mock_engine.the_engine->get_stats_struct == NULL) {\n        mock_engine.me.get_stats_struct = NULL;\n    }\n    if (mock_engine.the_engine->aggregate_stats == NULL) {\n        mock_engine.me.aggregate_stats = NULL;\n    }\n    if (mock_engine.the_engine->unknown_command == NULL) {\n        mock_engine.me.unknown_command = NULL;\n    }\n    if (mock_engine.the_engine->tap_notify == NULL) {\n        mock_engine.me.tap_notify = NULL;\n    }\n    if (mock_engine.the_engine->get_tap_iterator == NULL) {\n        mock_engine.me.get_tap_iterator = NULL;\n    }\n    if (mock_engine.the_engine->errinfo == NULL) {\n        mock_engine.me.errinfo = NULL;\n    }\n\n    return &mock_engine.me;\n}\n\nstatic void destroy_engine(bool force) {\n    if (handle_v1) {\n        handle_v1->destroy(handle, force);\n        handle_v1 = NULL;\n        handle = NULL;\n    }\n}\n\nstatic void reload_engine(ENGINE_HANDLE **h, ENGINE_HANDLE_V1 **h1,\n                          const char* engine, const char *cfg, bool init, bool force) {\n    destroy_engine(force);\n    handle_v1 = start_your_engines(engine, cfg, init);\n    handle = (ENGINE_HANDLE*)(handle_v1);\n    *h1 = handle_v1;\n    *h = handle;\n}\n\nstatic enum test_result run_test(engine_test_t test, const char *engine, const char *default_cfg) {\n    enum test_result ret = PENDING;\n    if (test.tfun != NULL) {\n#if !defined(USE_GCOV) && !defined(WIN32)\n        pid_t pid = fork();\n        if (pid == 0) {\n#endif\n            /* Start the engines and go */\n            start_your_engines(engine, test.cfg ? test.cfg : default_cfg, true);\n            if (test.test_setup != NULL) {\n                if (!test.test_setup(handle, handle_v1)) {\n                    fprintf(stderr, \"Failed to run setup for test %s\\n\", test.name);\n                    return FAIL;\n                }\n            }\n            ret = test.tfun(handle, handle_v1);\n            if (test.test_teardown != NULL) {\n                if (!test.test_teardown(handle, handle_v1)) {\n                    fprintf(stderr, \"WARNING: Failed to run teardown for test %s\\n\", test.name);\n                }\n            }\n            destroy_engine(false);\n#if !defined(USE_GCOV) && !defined(WIN32)\n            exit((int)ret);\n        } else if (pid == (pid_t)-1) {\n            ret = FAIL;\n        } else {\n            int rc;\n            while (alarmed == 0 && waitpid(pid, &rc, 0) == (pid_t)-1) {\n                if (errno != EINTR) {\n                    abort();\n                }\n            }\n\n            if (alarmed) {\n                kill(pid, 9);\n                ret = TIMEOUT;\n            } else if (WIFEXITED(rc)) {\n                ret = (enum test_result)WEXITSTATUS(rc);\n            } else if (WIFSIGNALED(rc) && WCOREDUMP(rc)) {\n                ret = CORE;\n            } else {\n                ret = DIED;\n            }\n        }\n#endif\n    }\n\n    return ret;\n}\n\nstatic void setup_alarm_handler() {\n#ifndef WIN32\n    struct sigaction sig_handler;\n\n    sig_handler.sa_handler = alarm_handler;\n    sig_handler.sa_flags = 0;\n\n    sigaction(SIGALRM, &sig_handler, NULL);\n#endif\n}\n\nstatic void set_test_timeout(int timeout) {\n#ifndef WIN32\n    alarm(timeout);\n#endif\n}\n\nstatic void clear_test_timeout() {\n#ifndef WIN32\n    alarm(0);\n    alarmed = 0;\n#endif\n}\n\nint main(int argc, char **argv) {\n    int c, exitcode = 0, num_cases = 0, timeout = 0;\n    bool quiet = false;\n    bool dot = false;\n    const char *engine = NULL;\n    const char *engine_args = NULL;\n    const char *test_suite = NULL;\n    const char *test_case = NULL;\n    engine_test_t *testcases = NULL;\n    logger_descriptor = get_null_logger();\n\n    /* Hack to remove the warning from C99 */\n    union {\n        GET_TESTS get_tests;\n        void* voidptr;\n    } my_get_test = {.get_tests = NULL };\n\n    /* Hack to remove the warning from C99 */\n    union {\n        SETUP_SUITE setup_suite;\n        void* voidptr;\n    } my_setup_suite = {.setup_suite = NULL };\n\n    /* Hack to remove the warning from C99 */\n    union {\n        TEARDOWN_SUITE teardown_suite;\n        void* voidptr;\n    } my_teardown_suite = {.teardown_suite = NULL };\n\n\n    /* Use unbuffered stdio */\n    setbuf(stdout, NULL);\n    setbuf(stderr, NULL);\n\n    setup_alarm_handler();\n\n    /* process arguments */\n    while (-1 != (c = getopt(argc, argv,\n          \"h\"  /* usage */\n          \"E:\" /* Engine to load */\n          \"e:\" /* Engine options */\n          \"T:\" /* Library with tests to load */\n          \"t:\" /* Timeout */\n          \"q\"  /* Be more quiet (only report failures) */\n          \".\"  /* dot mode. */\n          \"n:\"  /* test case to run */\n        ))) {\n        switch (c) {\n        case 'E':\n            engine = optarg;\n            break;\n        case 'e':\n            engine_args = optarg;\n            break;\n        case 'h':\n            usage();\n            return 0;\n        case 'T':\n            test_suite = optarg;\n            break;\n        case 't':\n            timeout = atoi(optarg);\n            break;\n        case 'n':\n            test_case = optarg;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case '.':\n            dot = true;\n            break;\n        default:\n            fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n\n    //validate args\n    if (engine == NULL) {\n        fprintf(stderr, \"You must provide a path to the storage engine library.\\n\");\n        return 1;\n    }\n\n    if (test_suite == NULL) {\n        fprintf(stderr, \"You must provide a path to the testsuite library.\\n\");\n        return 1;\n    }\n\n    //load test_suite\n    void* handle = dlopen(test_suite, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        fprintf(stderr, \"Failed to load testsuite %s: %s\\n\", test_suite, msg ? msg : \"unknown error\");\n        return 1;\n    }\n\n    //get the test cases\n    void *symbol = dlsym(handle, \"get_tests\");\n    if (symbol == NULL) {\n        const char *msg = dlerror();\n        fprintf(stderr, \"Could not find get_tests function in testsuite %s: %s\\n\", test_suite, msg ? msg : \"unknown error\");\n        return 1;\n    }\n    my_get_test.voidptr = symbol;\n    testcases = (*my_get_test.get_tests)();\n\n    //set up the suite if needed\n    struct test_harness harness = { .default_engine_cfg = engine_args,\n                                    .engine_path = engine,\n                                    .reload_engine = reload_engine,\n                                    .start_engine = start_your_engines,\n                                    .create_cookie = create_mock_cookie,\n                                    .destroy_cookie = destroy_mock_cookie,\n                                    .set_ewouldblock_handling = mock_set_ewouldblock_handling,\n                                    .lock_cookie = lock_mock_cookie,\n                                    .unlock_cookie = unlock_mock_cookie,\n                                    .waitfor_cookie = waitfor_mock_cookie,\n                                    .time_travel = mock_time_travel };\n    symbol = dlsym(handle, \"setup_suite\");\n    if (symbol != NULL) {\n        my_setup_suite.voidptr = symbol;\n        if (!(*my_setup_suite.setup_suite)(&harness)) {\n            fprintf(stderr, \"Failed to set up test suite %s \\n\", test_suite);\n            return 1;\n        }\n    }\n\n\n    for (num_cases = 0; testcases[num_cases].name; num_cases++) {\n        /* Just counting */\n    }\n\n    if (!quiet) {\n        printf(\"1..%d\\n\", num_cases);\n    }\n\n    int i;\n    bool need_newline = false;\n    for (i = 0; testcases[i].name; i++) {\n        if (test_case != NULL && strcmp(test_case, testcases[i].name) != 0)\n            continue;\n        if (!quiet) {\n            printf(\"Running %s... \", testcases[i].name);\n            fflush(stdout);\n        } else if(dot) {\n            printf(\".\");\n            need_newline = true;\n            /* Add a newline every few tests */\n            if ((i+1) % 70 == 0) {\n                printf(\"\\n\");\n                need_newline = false;\n            }\n        }\n        set_test_timeout(timeout);\n        exitcode += report_test(testcases[i].name,\n                                run_test(testcases[i], engine, engine_args),\n                                quiet);\n        clear_test_timeout();\n    }\n\n    if (need_newline) {\n        printf(\"\\n\");\n    }\n\n    //tear down the suite if needed\n    symbol = dlsym(handle, \"teardown_suite\");\n    if (symbol != NULL) {\n        my_teardown_suite.voidptr = symbol;\n        if (!(*my_teardown_suite.teardown_suite)()) {\n            fprintf(stderr, \"Failed to teardown up test suite %s \\n\", test_suite);\n        }\n    }\n\n    printf(\"# Passed %d of %d tests\\n\", num_cases - exitcode, num_cases);\n\n    return exitcode;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/plugin/innodb_memcached/daemon_memcached/win32/dlfcn.h": "#ifndef DLFCN_H\n#define DLFCN_H\nvoid* dlopen(const char* path, int mode);\nvoid* dlsym(void* handle, const char* symbol);\nint dlclose(void* handle);\nconst char *dlerror(void);\n\n#define RTLD_LAZY 1\n#define RTLD_LOCAL 2\n\n#define RTLD_NOW 0x00002\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/plugin/innodb_memcached/daemon_memcached/win32/dlfcn.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include <stdio.h>\n#include <windows.h>\n#include <dlfcn.h>\n#include <stdbool.h>\n\n/*\n * Keep track if the user tried to call dlopen(NULL, xx) to be able to give a sane\n * error message\n */\nstatic bool self = false;\n\nvoid* dlopen(const char* path, int mode) {\n    if (path == NULL) {\n        // We don't support opening ourself\n        self = true;\n        return NULL;\n    }\n\n    void* handle = LoadLibrary(path);\n    if (handle == NULL) {\n        char *buf = malloc(strlen(path) + 20);\n        sprintf(buf, \"%s.dll\", path);\n        handle = LoadLibrary(buf);\n        free(buf);\n    }\n\n    return handle;\n}\n\nvoid* dlsym(void* handle, const char* symbol) {\n    return GetProcAddress(handle, symbol);\n}\n\nint dlclose(void* handle) {\n    // dlclose returns zero on success.\n    // FreeLibrary returns nonzero on success.\n    return FreeLibrary(handle) != 0;\n}\n\nstatic char dlerror_buf[200];\n\nconst char *dlerror(void) {\n    if (self) {\n        return \"not supported\";\n    }\n\n    DWORD err = GetLastError();\n    LPVOID error_msg;\n    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                      FORMAT_MESSAGE_FROM_SYSTEM |\n                      FORMAT_MESSAGE_IGNORE_INSERTS,\n                      NULL, err, 0, (LPTSTR)&error_msg, 0, NULL) != 0) {\n        strncpy(dlerror_buf, error_msg, sizeof(dlerror_buf));\n        dlerror_buf[sizeof(dlerror_buf) - 1] = '\\0';\n        LocalFree(error_msg);\n    } else {\n        return \"Failed to get error message\";\n    }\n\n    return dlerror_buf;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/extra/icu/source/common/putilimp.h": "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/*\n******************************************************************************\n*\n*   Copyright (C) 1997-2016, International Business Machines\n*   Corporation and others.  All Rights Reserved.\n*\n******************************************************************************\n*\n*  FILE NAME : putilimp.h\n*\n*   Date        Name        Description\n*   10/17/04    grhoten     Move internal functions from putil.h to this file.\n******************************************************************************\n*/\n\n#ifndef PUTILIMP_H\n#define PUTILIMP_H\n\n#include \"unicode/utypes.h\"\n#include \"unicode/putil.h\"\n\n/**\n * \\def U_SIGNED_RIGHT_SHIFT_IS_ARITHMETIC\n * Nearly all CPUs and compilers implement a right-shift of a signed integer\n * as an Arithmetic Shift Right which copies the sign bit (the Most Significant Bit (MSB))\n * into the vacated bits (sign extension).\n * For example, (int32_t)0xfff5fff3>>4 becomes 0xffff5fff and -1>>1=-1.\n *\n * This can be useful for storing a signed value in the upper bits\n * and another bit field in the lower bits.\n * The signed value can be retrieved by simple right-shifting.\n *\n * This is consistent with the Java language.\n *\n * However, the C standard allows compilers to implement a right-shift of a signed integer\n * as a Logical Shift Right which copies a 0 into the vacated bits.\n * For example, (int32_t)0xfff5fff3>>4 becomes 0x0fff5fff and -1>>1=0x7fffffff.\n *\n * Code that depends on the natural behavior should be guarded with this macro,\n * with an alternate path for unusual platforms.\n * @internal\n */\n#ifdef U_SIGNED_RIGHT_SHIFT_IS_ARITHMETIC\n    /* Use the predefined value. */\n#else\n    /*\n     * Nearly all CPUs & compilers implement a right-shift of a signed integer\n     * as an Arithmetic Shift Right (with sign extension).\n     */\n#   define U_SIGNED_RIGHT_SHIFT_IS_ARITHMETIC 1\n#endif\n\n/** Define this to 1 if your platform supports IEEE 754 floating point,\n   to 0 if it does not. */\n#ifndef IEEE_754\n#   define IEEE_754 1\n#endif\n\n/**\n * uintptr_t is an optional part of the standard definitions in stdint.h.\n * The opengroup.org documentation for stdint.h says\n * \"On XSI-conformant systems, the intptr_t and uintptr_t types are required;\n * otherwise, they are optional.\"\n * We assume that when uintptr_t is defined, UINTPTR_MAX is defined as well.\n *\n * Do not use ptrdiff_t since it is signed. size_t is unsigned.\n */\n/* TODO: This check fails on some z environments. Filed a ticket #9357 for this. */\n#if !defined(__intptr_t_defined) && !defined(UINTPTR_MAX) && (U_PLATFORM != U_PF_OS390)\ntypedef size_t uintptr_t;\n#endif\n\n/**\n * \\def U_HAVE_MSVC_2003_OR_EARLIER\n * Flag for workaround of MSVC 2003 optimization bugs\n * @internal\n */\n#if !defined(U_HAVE_MSVC_2003_OR_EARLIER) && defined(_MSC_VER) && (_MSC_VER < 1400)\n#define U_HAVE_MSVC_2003_OR_EARLIER\n#endif\n\n/*===========================================================================*/\n/** @{ Information about POSIX support                                       */\n/*===========================================================================*/\n\n#ifdef U_HAVE_NL_LANGINFO_CODESET\n    /* Use the predefined value. */\n#elif U_PLATFORM_USES_ONLY_WIN32_API || U_PLATFORM == U_PF_ANDROID || U_PLATFORM == U_PF_QNX\n#   define U_HAVE_NL_LANGINFO_CODESET 0\n#else\n#   define U_HAVE_NL_LANGINFO_CODESET 1\n#endif\n\n#ifdef U_NL_LANGINFO_CODESET\n    /* Use the predefined value. */\n#elif !U_HAVE_NL_LANGINFO_CODESET\n#   define U_NL_LANGINFO_CODESET -1\n#elif U_PLATFORM == U_PF_OS400\n   /* not defined */\n#else\n#   define U_NL_LANGINFO_CODESET CODESET\n#endif\n\n#ifdef U_TZSET\n    /* Use the predefined value. */\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n    // UWP doesn't support tzset or environment variables for tz\n#if U_PLATFORM_HAS_WINUWP_API == 0\n#   define U_TZSET _tzset\n#endif\n#elif U_PLATFORM == U_PF_OS400\n   /* not defined */\n#else\n#   define U_TZSET tzset\n#endif\n\n#if defined(U_TIMEZONE) || defined(U_HAVE_TIMEZONE)\n    /* Use the predefined value. */\n#elif U_PLATFORM == U_PF_ANDROID\n#   define U_TIMEZONE timezone\n#elif U_PLATFORM_IS_LINUX_BASED\n#   if defined(__UCLIBC__)\n       /* uClibc does not have __timezone or _timezone. */\n#   elif defined(_NEWLIB_VERSION)\n#      define U_TIMEZONE      _timezone\n#   elif defined(__GLIBC__)\n       /* glibc */\n#      define U_TIMEZONE      __timezone\n#   endif\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n#   define U_TIMEZONE _timezone\n#elif U_PLATFORM == U_PF_BSD && !defined(__NetBSD__)\n   /* not defined */\n#elif U_PLATFORM == U_PF_OS400\n   /* not defined */\n#elif U_PLATFORM == U_PF_IPHONE\n   /* not defined */\n#else\n#   define U_TIMEZONE timezone\n#endif\n\n#ifdef U_TZNAME\n    /* Use the predefined value. */\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n    /* not usable on all windows platforms */\n#if U_PLATFORM_HAS_WINUWP_API == 0\n#   define U_TZNAME _tzname\n#endif\n#elif U_PLATFORM == U_PF_OS400\n   /* not defined */\n#else\n#   define U_TZNAME tzname\n#endif\n\n#ifdef U_HAVE_MMAP\n    /* Use the predefined value. */\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n#   define U_HAVE_MMAP 0\n#else\n#   define U_HAVE_MMAP 1\n#endif\n\n#ifdef U_HAVE_POPEN\n    /* Use the predefined value. */\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n#   define U_HAVE_POPEN 0\n#elif U_PLATFORM == U_PF_OS400\n#   define U_HAVE_POPEN 0\n#else\n#   define U_HAVE_POPEN 1\n#endif\n\n/**\n * \\def U_HAVE_DIRENT_H\n * Defines whether dirent.h is available.\n * @internal\n */\n#ifdef U_HAVE_DIRENT_H\n    /* Use the predefined value. */\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n#   define U_HAVE_DIRENT_H 0\n#else\n#   define U_HAVE_DIRENT_H 1\n#endif\n\n/** @} */\n\n/*===========================================================================*/\n/** @{ GCC built in functions for atomic memory operations                   */\n/*===========================================================================*/\n\n/**\n * \\def U_HAVE_GCC_ATOMICS\n * @internal\n */\n#ifdef U_HAVE_GCC_ATOMICS\n    /* Use the predefined value. */\n#elif U_PLATFORM == U_PF_MINGW\n    #define U_HAVE_GCC_ATOMICS 0\n#elif U_GCC_MAJOR_MINOR >= 404 || defined(__clang__)\n    /* TODO: Intel icc and IBM xlc on AIX also support gcc atomics.  (Intel originated them.)\n     *       Add them for these compilers.\n     * Note: Clang sets __GNUC__ defines for version 4.2, so misses the 4.4 test here.\n     */\n#   define U_HAVE_GCC_ATOMICS 1\n#else\n#   define U_HAVE_GCC_ATOMICS 0\n#endif\n\n/** @} */\n\n/**\n * \\def U_HAVE_STD_ATOMICS\n * Defines whether the standard C++11 <atomic> is available.\n * ICU will use this when avialable,\n * otherwise will fall back to compiler or platform specific alternatives.\n * @internal\n */\n#ifdef U_HAVE_STD_ATOMICS\n    /* Use the predefined value. */\n#elif U_CPLUSPLUS_VERSION < 11\n    /* Not C++11, disable use of atomics */\n#   define U_HAVE_STD_ATOMICS 0\n#elif __clang__ && __clang_major__==3 && __clang_minor__<=1\n    /* Clang 3.1, has atomic variable initializer bug. */\n#   define U_HAVE_STD_ATOMICS 0\n#else \n    /* U_HAVE_ATOMIC is typically set by an autoconf test of #include <atomic>  */\n    /*   Can be set manually, or left undefined, on platforms without autoconf. */\n#   if defined(U_HAVE_ATOMIC) &&  U_HAVE_ATOMIC \n#      define U_HAVE_STD_ATOMICS 1\n#   else\n#      define U_HAVE_STD_ATOMICS 0\n#   endif\n#endif\n\n\n/**\n *  \\def U_HAVE_CLANG_ATOMICS\n *  Defines whether Clang c11 style built-in atomics are avaialable.\n *  These are used in preference to gcc atomics when both are available.\n */\n#ifdef U_HAVE_CLANG_ATOMICS\n    /* Use the predefined value. */\n#elif __has_builtin(__c11_atomic_load) && \\\n    __has_builtin(__c11_atomic_store) && \\\n    __has_builtin(__c11_atomic_fetch_add) && \\\n    __has_builtin(__c11_atomic_fetch_sub)\n#    define U_HAVE_CLANG_ATOMICS 1\n#else\n#    define U_HAVE_CLANG_ATOMICS 0\n#endif\n\n/*===========================================================================*/\n/** @{ Programs used by ICU code                                             */\n/*===========================================================================*/\n\n/**\n * \\def U_MAKE_IS_NMAKE\n * Defines whether the \"make\" program is Windows nmake.\n */\n#ifdef U_MAKE_IS_NMAKE\n    /* Use the predefined value. */\n#elif U_PLATFORM == U_PF_WINDOWS\n#   define U_MAKE_IS_NMAKE 1\n#else\n#   define U_MAKE_IS_NMAKE 0\n#endif\n\n/** @} */\n\n/*==========================================================================*/\n/* Platform utilities                                                       */\n/*==========================================================================*/\n\n/**\n * Platform utilities isolates the platform dependencies of the\n * libarary.  For each platform which this code is ported to, these\n * functions may have to be re-implemented.\n */\n\n/**\n * Floating point utility to determine if a double is Not a Number (NaN).\n * @internal\n */\nU_INTERNAL UBool   U_EXPORT2 uprv_isNaN(double d);\n/**\n * Floating point utility to determine if a double has an infinite value.\n * @internal\n */\nU_INTERNAL UBool   U_EXPORT2 uprv_isInfinite(double d);\n/**\n * Floating point utility to determine if a double has a positive infinite value.\n * @internal\n */\nU_INTERNAL UBool   U_EXPORT2 uprv_isPositiveInfinity(double d);\n/**\n * Floating point utility to determine if a double has a negative infinite value.\n * @internal\n */\nU_INTERNAL UBool   U_EXPORT2 uprv_isNegativeInfinity(double d);\n/**\n * Floating point utility that returns a Not a Number (NaN) value.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_getNaN(void);\n/**\n * Floating point utility that returns an infinite value.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_getInfinity(void);\n\n/**\n * Floating point utility to truncate a double.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_trunc(double d);\n/**\n * Floating point utility to calculate the floor of a double.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_floor(double d);\n/**\n * Floating point utility to calculate the ceiling of a double.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_ceil(double d);\n/**\n * Floating point utility to calculate the absolute value of a double.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_fabs(double d);\n/**\n * Floating point utility to calculate the fractional and integer parts of a double.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_modf(double d, double* pinteger);\n/**\n * Floating point utility to calculate the remainder of a double divided by another double.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_fmod(double d, double y);\n/**\n * Floating point utility to calculate d to the power of exponent (d^exponent).\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_pow(double d, double exponent);\n/**\n * Floating point utility to calculate 10 to the power of exponent (10^exponent).\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_pow10(int32_t exponent);\n/**\n * Floating point utility to calculate the maximum value of two doubles.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_fmax(double d, double y);\n/**\n * Floating point utility to calculate the minimum value of two doubles.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_fmin(double d, double y);\n/**\n * Private utility to calculate the maximum value of two integers.\n * @internal\n */\nU_INTERNAL int32_t U_EXPORT2 uprv_max(int32_t d, int32_t y);\n/**\n * Private utility to calculate the minimum value of two integers.\n * @internal\n */\nU_INTERNAL int32_t U_EXPORT2 uprv_min(int32_t d, int32_t y);\n\n#if U_IS_BIG_ENDIAN\n#   define uprv_isNegative(number) (*((signed char *)&(number))<0)\n#else\n#   define uprv_isNegative(number) (*((signed char *)&(number)+sizeof(number)-1)<0)\n#endif\n\n/**\n * Return the largest positive number that can be represented by an integer\n * type of arbitrary bit length.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_maxMantissa(void);\n\n/**\n * Floating point utility to calculate the logarithm of a double.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_log(double d);\n\n/**\n * Does common notion of rounding e.g. uprv_floor(x + 0.5);\n * @param x the double number\n * @return the rounded double\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_round(double x);\n\n#if 0\n/**\n * Returns the number of digits after the decimal point in a double number x.\n *\n * @param x the double number\n * @return the number of digits after the decimal point in a double number x.\n * @internal\n */\n/*U_INTERNAL int32_t  U_EXPORT2 uprv_digitsAfterDecimal(double x);*/\n#endif\n\n#if !U_CHARSET_IS_UTF8\n/**\n * Please use ucnv_getDefaultName() instead.\n * Return the default codepage for this platform and locale.\n * This function can call setlocale() on Unix platforms. Please read the\n * platform documentation on setlocale() before calling this function.\n * @return the default codepage for this platform \n * @internal\n */\nU_INTERNAL const char*  U_EXPORT2 uprv_getDefaultCodepage(void);\n#endif\n\n/**\n * Please use uloc_getDefault() instead.\n * Return the default locale ID string by querying ths system, or\n *     zero if one cannot be found. \n * This function can call setlocale() on Unix platforms. Please read the\n * platform documentation on setlocale() before calling this function.\n * @return the default locale ID string\n * @internal\n */\nU_INTERNAL const char*  U_EXPORT2 uprv_getDefaultLocaleID(void);\n\n/**\n * Time zone utilities\n *\n * Wrappers for C runtime library functions relating to timezones.\n * The t_tzset() function (similar to tzset) uses the current setting\n * of the environment variable TZ to assign values to three global\n * variables: daylight, timezone, and tzname. These variables have the\n * following meanings, and are declared in &lt;time.h&gt;.\n *\n *   daylight   Nonzero if daylight-saving-time zone (DST) is specified\n *              in TZ; otherwise, 0. Default value is 1.\n *   timezone   Difference in seconds between coordinated universal\n *              time and local time. E.g., -28,800 for PST (GMT-8hrs)\n *   tzname(0)  Three-letter time-zone name derived from TZ environment\n *              variable. E.g., \"PST\".\n *   tzname(1)  Three-letter DST zone name derived from TZ environment\n *              variable.  E.g., \"PDT\". If DST zone is omitted from TZ,\n *              tzname(1) is an empty string.\n *\n * Notes: For example, to set the TZ environment variable to correspond\n * to the current time zone in Germany, you can use one of the\n * following statements:\n *\n *   set TZ=GST1GDT\n *   set TZ=GST+1GDT\n *\n * If the TZ value is not set, t_tzset() attempts to use the time zone\n * information specified by the operating system. Under Windows NT\n * and Windows 95, this information is specified in the Control Panel's\n * Date/Time application.\n * @internal\n */\nU_INTERNAL void     U_EXPORT2 uprv_tzset(void);\n\n/**\n * Difference in seconds between coordinated universal\n * time and local time. E.g., -28,800 for PST (GMT-8hrs)\n * @return the difference in seconds between coordinated universal time and local time.\n * @internal\n */\nU_INTERNAL int32_t  U_EXPORT2 uprv_timezone(void);\n\n/**\n *   tzname(0)  Three-letter time-zone name derived from TZ environment\n *              variable. E.g., \"PST\".\n *   tzname(1)  Three-letter DST zone name derived from TZ environment\n *              variable.  E.g., \"PDT\". If DST zone is omitted from TZ,\n *              tzname(1) is an empty string.\n * @internal\n */\nU_INTERNAL const char* U_EXPORT2 uprv_tzname(int n);\n\n/**\n * Reset the global tzname cache.\n * @internal\n */\nU_INTERNAL void uprv_tzname_clear_cache();\n\n/**\n * Get UTC (GMT) time measured in milliseconds since 0:00 on 1/1/1970.\n * This function is affected by 'faketime' and should be the bottleneck for all user-visible ICU time functions.\n * @return the UTC time measured in milliseconds\n * @internal\n */\nU_INTERNAL UDate U_EXPORT2 uprv_getUTCtime(void);\n\n/**\n * Get UTC (GMT) time measured in milliseconds since 0:00 on 1/1/1970.\n * This function is not affected by 'faketime', so it should only be used by low level test functions- not by anything that\n * exposes time to the end user.\n * @return the UTC time measured in milliseconds\n * @internal\n */\nU_INTERNAL UDate U_EXPORT2 uprv_getRawUTCtime(void);\n\n/**\n * Determine whether a pathname is absolute or not, as defined by the platform.\n * @param path Pathname to test\n * @return TRUE if the path is absolute\n * @internal (ICU 3.0)\n */\nU_INTERNAL UBool U_EXPORT2 uprv_pathIsAbsolute(const char *path);\n\n/**\n * Use U_MAX_PTR instead of this function.\n * @param void pointer to test\n * @return the largest possible pointer greater than the base\n * @internal (ICU 3.8)\n */\nU_INTERNAL void * U_EXPORT2 uprv_maximumPtr(void *base);\n\n/**\n * Maximum value of a (void*) - use to indicate the limit of an 'infinite' buffer.\n * In fact, buffer sizes must not exceed 2GB so that the difference between\n * the buffer limit and the buffer start can be expressed in an int32_t.\n *\n * The definition of U_MAX_PTR must fulfill the following conditions:\n * - return the largest possible pointer greater than base\n * - return a valid pointer according to the machine architecture (AS/400, 64-bit, etc.)\n * - avoid wrapping around at high addresses\n * - make sure that the returned pointer is not farther from base than 0x7fffffff bytes\n *\n * @param base The beginning of a buffer to find the maximum offset from\n * @internal\n */\n#ifndef U_MAX_PTR\n#  if U_PLATFORM == U_PF_OS390 && !defined(_LP64)\n    /* We have 31-bit pointers. */\n#    define U_MAX_PTR(base) ((void *)0x7fffffff)\n#  elif U_PLATFORM == U_PF_OS400\n#    define U_MAX_PTR(base) uprv_maximumPtr((void *)base)\n#  elif 0\n    /*\n     * For platforms where pointers are scalar values (which is normal, but unlike i5/OS)\n     * but that do not define uintptr_t.\n     *\n     * However, this does not work on modern compilers:\n     * The C++ standard does not define pointer overflow, and allows compilers to\n     * assume that p+u>p for any pointer p and any integer u>0.\n     * Thus, modern compilers optimize away the \">\" comparison.\n     * (See ICU tickets #7187 and #8096.)\n     */\n#    define U_MAX_PTR(base) \\\n    ((void *)(((char *)(base)+0x7fffffffu) > (char *)(base) \\\n        ? ((char *)(base)+0x7fffffffu) \\\n        : (char *)-1))\n#  else\n    /* Default version. C++ standard compliant for scalar pointers. */\n#    define U_MAX_PTR(base) \\\n    ((void *)(((uintptr_t)(base)+0x7fffffffu) > (uintptr_t)(base) \\\n        ? ((uintptr_t)(base)+0x7fffffffu) \\\n        : (uintptr_t)-1))\n#  endif\n#endif\n\n/*  Dynamic Library Functions */\n\ntypedef void (UVoidFunction)(void);\n\n#if U_ENABLE_DYLOAD\n/**\n * Load a library\n * @internal (ICU 4.4)\n */\nU_INTERNAL void * U_EXPORT2 uprv_dl_open(const char *libName, UErrorCode *status);\n\n/**\n * Close a library\n * @internal (ICU 4.4)\n */\nU_INTERNAL void U_EXPORT2 uprv_dl_close( void *lib, UErrorCode *status);\n\n/**\n * Extract a symbol from a library (function)\n * @internal (ICU 4.8)\n */\nU_INTERNAL UVoidFunction* U_EXPORT2 uprv_dlsym_func( void *lib, const char *symbolName, UErrorCode *status);\n\n/**\n * Extract a symbol from a library (function)\n * Not implemented, no clients.\n * @internal\n */\n/* U_INTERNAL void * U_EXPORT2 uprv_dlsym_data( void *lib, const char *symbolName, UErrorCode *status); */\n\n#endif\n\n/**\n * Define malloc and related functions\n * @internal\n */\n#if U_PLATFORM == U_PF_OS400\n# define uprv_default_malloc(x) _C_TS_malloc(x)\n# define uprv_default_realloc(x,y) _C_TS_realloc(x,y)\n# define uprv_default_free(x) _C_TS_free(x)\n/* also _C_TS_calloc(x) */\n#else\n/* C defaults */\n# define uprv_default_malloc(x) malloc(x)\n# define uprv_default_realloc(x,y) realloc(x,y)\n# define uprv_default_free(x) free(x)\n#endif\n\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/extra/icu/source/common/putil.cpp": "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/*\n******************************************************************************\n*\n*   Copyright (C) 1997-2016, International Business Machines\n*   Corporation and others.  All Rights Reserved.\n*\n******************************************************************************\n*\n*  FILE NAME : putil.c (previously putil.cpp and ptypes.cpp)\n*\n*   Date        Name        Description\n*   04/14/97    aliu        Creation.\n*   04/24/97    aliu        Added getDefaultDataDirectory() and\n*                            getDefaultLocaleID().\n*   04/28/97    aliu        Rewritten to assume Unix and apply general methods\n*                            for assumed case.  Non-UNIX platforms must be\n*                            special-cased.  Rewrote numeric methods dealing\n*                            with NaN and Infinity to be platform independent\n*                             over all IEEE 754 platforms.\n*   05/13/97    aliu        Restored sign of timezone\n*                            (semantics are hours West of GMT)\n*   06/16/98    erm         Added IEEE_754 stuff, cleaned up isInfinite, isNan,\n*                             nextDouble..\n*   07/22/98    stephen     Added remainder, max, min, trunc\n*   08/13/98    stephen     Added isNegativeInfinity, isPositiveInfinity\n*   08/24/98    stephen     Added longBitsFromDouble\n*   09/08/98    stephen     Minor changes for Mac Port\n*   03/02/99    stephen     Removed openFile().  Added AS400 support.\n*                            Fixed EBCDIC tables\n*   04/15/99    stephen     Converted to C.\n*   06/28/99    stephen     Removed mutex locking in u_isBigEndian().\n*   08/04/99    jeffrey R.  Added OS/2 changes\n*   11/15/99    helena      Integrated S/390 IEEE support.\n*   04/26/01    Barry N.    OS/400 support for uprv_getDefaultLocaleID\n*   08/15/01    Steven H.   OS/400 support for uprv_getDefaultCodepage\n*   01/03/08    Steven L.   Fake Time Support\n******************************************************************************\n*/\n\n// Defines _XOPEN_SOURCE for access to POSIX functions.\n// Must be before any other #includes.\n#include \"uposixdefs.h\"\n\n// First, the platform type. Need this for U_PLATFORM.\n#include \"unicode/platform.h\"\n\n#if U_PLATFORM == U_PF_MINGW && defined __STRICT_ANSI__\n/* tzset isn't defined in strict ANSI on MinGW. */\n#undef __STRICT_ANSI__\n#endif\n\n/*\n * Cygwin with GCC requires inclusion of time.h after the above disabling strict asci mode statement.\n */\n#include <time.h>\n\n#if !U_PLATFORM_USES_ONLY_WIN32_API\n#include <sys/time.h>\n#endif\n\n/* include the rest of the ICU headers */\n#include \"unicode/putil.h\"\n#include \"unicode/ustring.h\"\n#include \"putilimp.h\"\n#include \"uassert.h\"\n#include \"umutex.h\"\n#include \"cmemory.h\"\n#include \"cstring.h\"\n#include \"locmap.h\"\n#include \"ucln_cmn.h\"\n#include \"charstr.h\"\n\n/* Include standard headers. */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <locale.h>\n#include <float.h>\n\n#ifndef U_COMMON_IMPLEMENTATION\n#error U_COMMON_IMPLEMENTATION not set - must be set for all ICU source files in common/ - see http://userguide.icu-project.org/howtouseicu\n#endif\n\n\n/* include system headers */\n#if U_PLATFORM_USES_ONLY_WIN32_API\n    /*\n     * TODO: U_PLATFORM_USES_ONLY_WIN32_API includes MinGW.\n     * Should Cygwin be included as well (U_PLATFORM_HAS_WIN32_API)\n     * to use native APIs as much as possible?\n     */\n#ifndef WIN32_LEAN_AND_MEAN\n#   define WIN32_LEAN_AND_MEAN\n#endif\n#   define VC_EXTRALEAN\n#   define NOUSER\n#   define NOSERVICE\n#   define NOIME\n#   define NOMCX\n#   include <windows.h>\n#   include \"unicode\\uloc.h\"\n#if U_PLATFORM_HAS_WINUWP_API == 0\n#   include \"wintz.h\"\n#else // U_PLATFORM_HAS_WINUWP_API\ntypedef PVOID LPMSG; // TODO: figure out how to get rid of this typedef\n#include <Windows.Globalization.h>\n#include <windows.system.userprofile.h>\n#include <wrl\\wrappers\\corewrappers.h>\n#include <wrl\\client.h>\n\nusing namespace ABI::Windows::Foundation;\nusing namespace Microsoft::WRL;\nusing namespace Microsoft::WRL::Wrappers;\n#endif\n#elif U_PLATFORM == U_PF_OS400\n#   include <float.h>\n#   include <qusec.h>       /* error code structure */\n#   include <qusrjobi.h>\n#   include <qliept.h>      /* EPT_CALL macro  - this include must be after all other \"QSYSINCs\" */\n#   include <mih/testptr.h> /* For uprv_maximumPtr */\n#elif U_PLATFORM == U_PF_OS390\n#   include \"unicode/ucnv.h\"   /* Needed for UCNV_SWAP_LFNL_OPTION_STRING */\n#elif U_PLATFORM_IS_DARWIN_BASED || U_PLATFORM_IS_LINUX_BASED || U_PLATFORM == U_PF_BSD || U_PLATFORM == U_PF_SOLARIS\n#   include <limits.h>\n#   include <unistd.h>\n#   if U_PLATFORM == U_PF_SOLARIS\n#       ifndef _XPG4_2\n#           define _XPG4_2\n#       endif\n#   endif\n#elif U_PLATFORM == U_PF_QNX\n#   include <sys/neutrino.h>\n#endif\n\n/*\n * Only include langinfo.h if we have a way to get the codeset. If we later\n * depend on more feature, we can test on U_HAVE_NL_LANGINFO.\n *\n */\n\n#if U_HAVE_NL_LANGINFO_CODESET\n#include <langinfo.h>\n#endif\n\n/**\n * Simple things (presence of functions, etc) should just go in configure.in and be added to\n * icucfg.h via autoheader.\n */\n#if U_PLATFORM_IMPLEMENTS_POSIX\n#   if U_PLATFORM == U_PF_OS400\n#    define HAVE_DLFCN_H 0\n#    define HAVE_DLOPEN 0\n#   else\n#   ifndef HAVE_DLFCN_H\n#    define HAVE_DLFCN_H 1\n#   endif\n#   ifndef HAVE_DLOPEN\n#    define HAVE_DLOPEN 1\n#   endif\n#   endif\n#   ifndef HAVE_GETTIMEOFDAY\n#    define HAVE_GETTIMEOFDAY 1\n#   endif\n#else\n#   define HAVE_DLFCN_H 0\n#   define HAVE_DLOPEN 0\n#   define HAVE_GETTIMEOFDAY 0\n#endif\n\nU_NAMESPACE_USE\n\n/* Define the extension for data files, again... */\n#define DATA_TYPE \"dat\"\n\n/* Leave this copyright notice here! */\nstatic const char copyright[] = U_COPYRIGHT_STRING;\n\n/* floating point implementations ------------------------------------------- */\n\n/* We return QNAN rather than SNAN*/\n#define SIGN 0x80000000U\n\n/* Make it easy to define certain types of constants */\ntypedef union {\n    int64_t i64; /* This must be defined first in order to allow the initialization to work. This is a C89 feature. */\n    double d64;\n} BitPatternConversion;\nstatic const BitPatternConversion gNan = { (int64_t) INT64_C(0x7FF8000000000000) };\nstatic const BitPatternConversion gInf = { (int64_t) INT64_C(0x7FF0000000000000) };\n\n/*---------------------------------------------------------------------------\n  Platform utilities\n  Our general strategy is to assume we're on a POSIX platform.  Platforms which\n  are non-POSIX must declare themselves so.  The default POSIX implementation\n  will sometimes work for non-POSIX platforms as well (e.g., the NaN-related\n  functions).\n  ---------------------------------------------------------------------------*/\n\n#if U_PLATFORM_USES_ONLY_WIN32_API || U_PLATFORM == U_PF_OS400\n#   undef U_POSIX_LOCALE\n#else\n#   define U_POSIX_LOCALE    1\n#endif\n\n/*\n    WARNING! u_topNBytesOfDouble and u_bottomNBytesOfDouble\n    can't be properly optimized by the gcc compiler sometimes (i.e. gcc 3.2).\n*/\n#if !IEEE_754\nstatic char*\nu_topNBytesOfDouble(double* d, int n)\n{\n#if U_IS_BIG_ENDIAN\n    return (char*)d;\n#else\n    return (char*)(d + 1) - n;\n#endif\n}\n\nstatic char*\nu_bottomNBytesOfDouble(double* d, int n)\n{\n#if U_IS_BIG_ENDIAN\n    return (char*)(d + 1) - n;\n#else\n    return (char*)d;\n#endif\n}\n#endif   /* !IEEE_754 */\n\n#if IEEE_754\nstatic UBool\nu_signBit(double d) {\n    uint8_t hiByte;\n#if U_IS_BIG_ENDIAN\n    hiByte = *(uint8_t *)&d;\n#else\n    hiByte = *(((uint8_t *)&d) + sizeof(double) - 1);\n#endif\n    return (hiByte & 0x80) != 0;\n}\n#endif\n\n\n\n#if defined (U_DEBUG_FAKETIME)\n/* Override the clock to test things without having to move the system clock.\n * Assumes POSIX gettimeofday() will function\n */\nUDate fakeClock_t0 = 0; /** Time to start the clock from **/\nUDate fakeClock_dt = 0; /** Offset (fake time - real time) **/\nUBool fakeClock_set = FALSE; /** True if fake clock has spun up **/\nstatic UMutex fakeClockMutex = U_MUTEX_INTIALIZER;\n\nstatic UDate getUTCtime_real() {\n    struct timeval posixTime;\n    gettimeofday(&posixTime, NULL);\n    return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));\n}\n\nstatic UDate getUTCtime_fake() {\n    umtx_lock(&fakeClockMutex);\n    if(!fakeClock_set) {\n        UDate real = getUTCtime_real();\n        const char *fake_start = getenv(\"U_FAKETIME_START\");\n        if((fake_start!=NULL) && (fake_start[0]!=0)) {\n            sscanf(fake_start,\"%lf\",&fakeClock_t0);\n            fakeClock_dt = fakeClock_t0 - real;\n            fprintf(stderr,\"U_DEBUG_FAKETIME was set at compile time, so the ICU clock will start at a preset value\\n\"\n                    \"env variable U_FAKETIME_START=%.0f (%s) for an offset of %.0f ms from the current time %.0f\\n\",\n                    fakeClock_t0, fake_start, fakeClock_dt, real);\n        } else {\n          fakeClock_dt = 0;\n            fprintf(stderr,\"U_DEBUG_FAKETIME was set at compile time, but U_FAKETIME_START was not set.\\n\"\n                    \"Set U_FAKETIME_START to the number of milliseconds since 1/1/1970 to set the ICU clock.\\n\");\n        }\n        fakeClock_set = TRUE;\n    }\n    umtx_unlock(&fakeClockMutex);\n\n    return getUTCtime_real() + fakeClock_dt;\n}\n#endif\n\n#if U_PLATFORM_USES_ONLY_WIN32_API\ntypedef union {\n    int64_t int64;\n    FILETIME fileTime;\n} FileTimeConversion;   /* This is like a ULARGE_INTEGER */\n\n/* Number of 100 nanoseconds from 1/1/1601 to 1/1/1970 */\n#define EPOCH_BIAS  INT64_C(116444736000000000)\n#define HECTONANOSECOND_PER_MILLISECOND   10000\n\n#endif\n\n/*---------------------------------------------------------------------------\n  Universal Implementations\n  These are designed to work on all platforms.  Try these, and if they\n  don't work on your platform, then special case your platform with new\n  implementations.\n---------------------------------------------------------------------------*/\n\nU_CAPI UDate U_EXPORT2\nuprv_getUTCtime()\n{\n#if defined(U_DEBUG_FAKETIME)\n    return getUTCtime_fake(); /* Hook for overriding the clock */\n#else\n    return uprv_getRawUTCtime();\n#endif\n}\n\n/* Return UTC (GMT) time measured in milliseconds since 0:00 on 1/1/70.*/\nU_CAPI UDate U_EXPORT2\nuprv_getRawUTCtime()\n{\n#if U_PLATFORM_USES_ONLY_WIN32_API\n\n    FileTimeConversion winTime;\n    GetSystemTimeAsFileTime(&winTime.fileTime);\n    return (UDate)((winTime.int64 - EPOCH_BIAS) / HECTONANOSECOND_PER_MILLISECOND);\n#else\n\n#if HAVE_GETTIMEOFDAY\n    struct timeval posixTime;\n    gettimeofday(&posixTime, NULL);\n    return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));\n#else\n    time_t epochtime;\n    time(&epochtime);\n    return (UDate)epochtime * U_MILLIS_PER_SECOND;\n#endif\n\n#endif\n}\n\n/*-----------------------------------------------------------------------------\n  IEEE 754\n  These methods detect and return NaN and infinity values for doubles\n  conforming to IEEE 754.  Platforms which support this standard include X86,\n  Mac 680x0, Mac PowerPC, AIX RS/6000, and most others.\n  If this doesn't work on your platform, you have non-IEEE floating-point, and\n  will need to code your own versions.  A naive implementation is to return 0.0\n  for getNaN and getInfinity, and false for isNaN and isInfinite.\n  ---------------------------------------------------------------------------*/\n\nU_CAPI UBool U_EXPORT2\nuprv_isNaN(double number)\n{\n#if IEEE_754\n    BitPatternConversion convertedNumber;\n    convertedNumber.d64 = number;\n    /* Infinity is 0x7FF0000000000000U. Anything greater than that is a NaN */\n    return (UBool)((convertedNumber.i64 & U_INT64_MAX) > gInf.i64);\n\n#elif U_PLATFORM == U_PF_OS390\n    uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n    uint32_t lowBits  = *(uint32_t*)u_bottomNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n\n    return ((highBits & 0x7F080000L) == 0x7F080000L) &&\n      (lowBits == 0x00000000L);\n\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an NaN value,*/\n    /* you'll need to replace this default implementation with what's correct*/\n    /* for your platform.*/\n    return number != number;\n#endif\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_isInfinite(double number)\n{\n#if IEEE_754\n    BitPatternConversion convertedNumber;\n    convertedNumber.d64 = number;\n    /* Infinity is exactly 0x7FF0000000000000U. */\n    return (UBool)((convertedNumber.i64 & U_INT64_MAX) == gInf.i64);\n#elif U_PLATFORM == U_PF_OS390\n    uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n    uint32_t lowBits  = *(uint32_t*)u_bottomNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n\n    return ((highBits  & ~SIGN) == 0x70FF0000L) && (lowBits == 0x00000000L);\n\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an infinity*/\n    /* value, you'll need to replace this default implementation with what's*/\n    /* correct for your platform.*/\n    return number == (2.0 * number);\n#endif\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_isPositiveInfinity(double number)\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return (UBool)(number > 0 && uprv_isInfinite(number));\n#else\n    return uprv_isInfinite(number);\n#endif\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_isNegativeInfinity(double number)\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return (UBool)(number < 0 && uprv_isInfinite(number));\n\n#else\n    uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n    return((highBits & SIGN) && uprv_isInfinite(number));\n\n#endif\n}\n\nU_CAPI double U_EXPORT2\nuprv_getNaN()\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return gNan.d64;\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an NaN value,*/\n    /* you'll need to replace this default implementation with what's correct*/\n    /* for your platform.*/\n    return 0.0;\n#endif\n}\n\nU_CAPI double U_EXPORT2\nuprv_getInfinity()\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return gInf.d64;\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an infinity*/\n    /* value, you'll need to replace this default implementation with what's*/\n    /* correct for your platform.*/\n    return 0.0;\n#endif\n}\n\nU_CAPI double U_EXPORT2\nuprv_floor(double x)\n{\n    return floor(x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_ceil(double x)\n{\n    return ceil(x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_round(double x)\n{\n    return uprv_floor(x + 0.5);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fabs(double x)\n{\n    return fabs(x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_modf(double x, double* y)\n{\n    return modf(x, y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fmod(double x, double y)\n{\n    return fmod(x, y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_pow(double x, double y)\n{\n    /* This is declared as \"double pow(double x, double y)\" */\n    return pow(x, y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_pow10(int32_t x)\n{\n    return pow(10.0, (double)x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fmax(double x, double y)\n{\n#if IEEE_754\n    /* first handle NaN*/\n    if(uprv_isNaN(x) || uprv_isNaN(y))\n        return uprv_getNaN();\n\n    /* check for -0 and 0*/\n    if(x == 0.0 && y == 0.0 && u_signBit(x))\n        return y;\n\n#endif\n\n    /* this should work for all flt point w/o NaN and Inf special cases */\n    return (x > y ? x : y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fmin(double x, double y)\n{\n#if IEEE_754\n    /* first handle NaN*/\n    if(uprv_isNaN(x) || uprv_isNaN(y))\n        return uprv_getNaN();\n\n    /* check for -0 and 0*/\n    if(x == 0.0 && y == 0.0 && u_signBit(y))\n        return y;\n\n#endif\n\n    /* this should work for all flt point w/o NaN and Inf special cases */\n    return (x > y ? y : x);\n}\n\n/**\n * Truncates the given double.\n * trunc(3.3) = 3.0, trunc (-3.3) = -3.0\n * This is different than calling floor() or ceil():\n * floor(3.3) = 3, floor(-3.3) = -4\n * ceil(3.3) = 4, ceil(-3.3) = -3\n */\nU_CAPI double U_EXPORT2\nuprv_trunc(double d)\n{\n#if IEEE_754\n    /* handle error cases*/\n    if(uprv_isNaN(d))\n        return uprv_getNaN();\n    if(uprv_isInfinite(d))\n        return uprv_getInfinity();\n\n    if(u_signBit(d))    /* Signbit() picks up -0.0;  d<0 does not. */\n        return ceil(d);\n    else\n        return floor(d);\n\n#else\n    return d >= 0 ? floor(d) : ceil(d);\n\n#endif\n}\n\n/**\n * Return the largest positive number that can be represented by an integer\n * type of arbitrary bit length.\n */\nU_CAPI double U_EXPORT2\nuprv_maxMantissa(void)\n{\n    return pow(2.0, DBL_MANT_DIG + 1.0) - 1.0;\n}\n\nU_CAPI double U_EXPORT2\nuprv_log(double d)\n{\n    return log(d);\n}\n\nU_CAPI void * U_EXPORT2\nuprv_maximumPtr(void * base)\n{\n#if U_PLATFORM == U_PF_OS400\n    /*\n     * With the provided function we should never be out of range of a given segment\n     * (a traditional/typical segment that is).  Our segments have 5 bytes for the\n     * id and 3 bytes for the offset.  The key is that the casting takes care of\n     * only retrieving the offset portion minus x1000.  Hence, the smallest offset\n     * seen in a program is x001000 and when casted to an int would be 0.\n     * That's why we can only add 0xffefff.  Otherwise, we would exceed the segment.\n     *\n     * Currently, 16MB is the current addressing limitation on i5/OS if the activation is\n     * non-TERASPACE.  If it is TERASPACE it is 2GB - 4k(header information).\n     * This function determines the activation based on the pointer that is passed in and\n     * calculates the appropriate maximum available size for\n     * each pointer type (TERASPACE and non-TERASPACE)\n     *\n     * Unlike other operating systems, the pointer model isn't determined at\n     * compile time on i5/OS.\n     */\n    if ((base != NULL) && (_TESTPTR(base, _C_TERASPACE_CHECK))) {\n        /* if it is a TERASPACE pointer the max is 2GB - 4k */\n        return ((void *)(((char *)base)-((uint32_t)(base))+((uint32_t)0x7fffefff)));\n    }\n    /* otherwise 16MB since NULL ptr is not checkable or the ptr is not TERASPACE */\n    return ((void *)(((char *)base)-((uint32_t)(base))+((uint32_t)0xffefff)));\n\n#else\n    return U_MAX_PTR(base);\n#endif\n}\n\n/*---------------------------------------------------------------------------\n  Platform-specific Implementations\n  Try these, and if they don't work on your platform, then special case your\n  platform with new implementations.\n  ---------------------------------------------------------------------------*/\n\n/* Generic time zone layer -------------------------------------------------- */\n\n/* Time zone utilities */\nU_CAPI void U_EXPORT2\nuprv_tzset()\n{\n#if defined(U_TZSET)\n    U_TZSET();\n#else\n    /* no initialization*/\n#endif\n}\n\nU_CAPI int32_t U_EXPORT2\nuprv_timezone()\n{\n#ifdef U_TIMEZONE\n    return U_TIMEZONE;\n#else\n    time_t t, t1, t2;\n    struct tm tmrec;\n    int32_t tdiff = 0;\n\n    time(&t);\n    uprv_memcpy( &tmrec, localtime(&t), sizeof(tmrec) );\n#if U_PLATFORM != U_PF_IPHONE\n    UBool dst_checked = (tmrec.tm_isdst != 0); /* daylight savings time is checked*/\n#endif\n    t1 = mktime(&tmrec);                 /* local time in seconds*/\n    uprv_memcpy( &tmrec, gmtime(&t), sizeof(tmrec) );\n    t2 = mktime(&tmrec);                 /* GMT (or UTC) in seconds*/\n    tdiff = t2 - t1;\n\n#if U_PLATFORM != U_PF_IPHONE\n    /* imitate NT behaviour, which returns same timezone offset to GMT for\n       winter and summer.\n       This does not work on all platforms. For instance, on glibc on Linux\n       and on Mac OS 10.5, tdiff calculated above remains the same\n       regardless of whether DST is in effect or not. iOS is another\n       platform where this does not work. Linux + glibc and Mac OS 10.5\n       have U_TIMEZONE defined so that this code is not reached.\n    */\n    if (dst_checked)\n        tdiff += 3600;\n#endif\n    return tdiff;\n#endif\n}\n\n/* Note that U_TZNAME does *not* have to be tzname, but if it is,\n   some platforms need to have it declared here. */\n\n#if defined(U_TZNAME) && (U_PLATFORM == U_PF_IRIX || U_PLATFORM_IS_DARWIN_BASED)\n/* RS6000 and others reject char **tzname.  */\nextern U_IMPORT char *U_TZNAME[];\n#endif\n\n#if !UCONFIG_NO_FILE_IO && ((U_PLATFORM_IS_DARWIN_BASED && (U_PLATFORM != U_PF_IPHONE || defined(U_TIMEZONE))) || U_PLATFORM_IS_LINUX_BASED || U_PLATFORM == U_PF_BSD || U_PLATFORM == U_PF_SOLARIS)\n/* These platforms are likely to use Olson timezone IDs. */\n#define CHECK_LOCALTIME_LINK 1\n#if U_PLATFORM_IS_DARWIN_BASED\n#include <tzfile.h>\n#define TZZONEINFO      (TZDIR \"/\")\n#elif U_PLATFORM == U_PF_SOLARIS\n#define TZDEFAULT       \"/etc/localtime\"\n#define TZZONEINFO      \"/usr/share/lib/zoneinfo/\"\n#define TZZONEINFO2     \"../usr/share/lib/zoneinfo/\"\n#define TZ_ENV_CHECK    \"localtime\"\n#else\n#define TZDEFAULT       \"/etc/localtime\"\n#define TZZONEINFO      \"/usr/share/zoneinfo/\"\n#endif\n#if U_HAVE_DIRENT_H\n#define TZFILE_SKIP     \"posixrules\" /* tz file to skip when searching. */\n/* Some Linux distributions have 'localtime' in /usr/share/zoneinfo\n   symlinked to /etc/localtime, which makes searchForTZFile return\n   'localtime' when it's the first match. */\n#define TZFILE_SKIP2    \"localtime\"\n#define SEARCH_TZFILE\n#include <dirent.h>  /* Needed to search through system timezone files */\n#endif\nstatic char gTimeZoneBuffer[PATH_MAX];\nstatic char *gTimeZoneBufferPtr = NULL;\n#endif\n\n#if !U_PLATFORM_USES_ONLY_WIN32_API\n#define isNonDigit(ch) (ch < '0' || '9' < ch)\nstatic UBool isValidOlsonID(const char *id) {\n    int32_t idx = 0;\n\n    /* Determine if this is something like Iceland (Olson ID)\n    or AST4ADT (non-Olson ID) */\n    while (id[idx] && isNonDigit(id[idx]) && id[idx] != ',') {\n        idx++;\n    }\n\n    /* If we went through the whole string, then it might be okay.\n    The timezone is sometimes set to \"CST-7CDT\", \"CST6CDT5,J129,J131/19:30\",\n    \"GRNLNDST3GRNLNDDT\" or similar, so we cannot use it.\n    The rest of the time it could be an Olson ID. George */\n    return (UBool)(id[idx] == 0\n        || uprv_strcmp(id, \"PST8PDT\") == 0\n        || uprv_strcmp(id, \"MST7MDT\") == 0\n        || uprv_strcmp(id, \"CST6CDT\") == 0\n        || uprv_strcmp(id, \"EST5EDT\") == 0);\n}\n\n/* On some Unix-like OS, 'posix' subdirectory in\n   /usr/share/zoneinfo replicates the top-level contents. 'right'\n   subdirectory has the same set of files, but individual files\n   are different from those in the top-level directory or 'posix'\n   because 'right' has files for TAI (Int'l Atomic Time) while 'posix'\n   has files for UTC.\n   When the first match for /etc/localtime is in either of them\n   (usually in posix because 'right' has different file contents),\n   or TZ environment variable points to one of them, createTimeZone\n   fails because, say, 'posix/America/New_York' is not an Olson\n   timezone id ('America/New_York' is). So, we have to skip\n   'posix/' and 'right/' at the beginning. */\nstatic void skipZoneIDPrefix(const char** id) {\n    if (uprv_strncmp(*id, \"posix/\", 6) == 0\n        || uprv_strncmp(*id, \"right/\", 6) == 0)\n    {\n        *id += 6;\n    }\n}\n#endif\n\n#if defined(U_TZNAME) && !U_PLATFORM_USES_ONLY_WIN32_API\n\n#define CONVERT_HOURS_TO_SECONDS(offset) (int32_t)(offset*3600)\ntypedef struct OffsetZoneMapping {\n    int32_t offsetSeconds;\n    int32_t daylightType; /* 0=U_DAYLIGHT_NONE, 1=daylight in June-U_DAYLIGHT_JUNE, 2=daylight in December=U_DAYLIGHT_DECEMBER*/\n    const char *stdID;\n    const char *dstID;\n    const char *olsonID;\n} OffsetZoneMapping;\n\nenum { U_DAYLIGHT_NONE=0,U_DAYLIGHT_JUNE=1,U_DAYLIGHT_DECEMBER=2 };\n\n/*\nThis list tries to disambiguate a set of abbreviated timezone IDs and offsets\nand maps it to an Olson ID.\nBefore adding anything to this list, take a look at\nicu/source/tools/tzcode/tz.alias\nSometimes no daylight savings (0) is important to define due to aliases.\nThis list can be tested with icu/source/test/compat/tzone.pl\nMore values could be added to daylightType to increase precision.\n*/\nstatic const struct OffsetZoneMapping OFFSET_ZONE_MAPPINGS[] = {\n    {-45900, 2, \"CHAST\", \"CHADT\", \"Pacific/Chatham\"},\n    {-43200, 1, \"PETT\", \"PETST\", \"Asia/Kamchatka\"},\n    {-43200, 2, \"NZST\", \"NZDT\", \"Pacific/Auckland\"},\n    {-43200, 1, \"ANAT\", \"ANAST\", \"Asia/Anadyr\"},\n    {-39600, 1, \"MAGT\", \"MAGST\", \"Asia/Magadan\"},\n    {-37800, 2, \"LHST\", \"LHST\", \"Australia/Lord_Howe\"},\n    {-36000, 2, \"EST\", \"EST\", \"Australia/Sydney\"},\n    {-36000, 1, \"SAKT\", \"SAKST\", \"Asia/Sakhalin\"},\n    {-36000, 1, \"VLAT\", \"VLAST\", \"Asia/Vladivostok\"},\n    {-34200, 2, \"CST\", \"CST\", \"Australia/South\"},\n    {-32400, 1, \"YAKT\", \"YAKST\", \"Asia/Yakutsk\"},\n    {-32400, 1, \"CHOT\", \"CHOST\", \"Asia/Choibalsan\"},\n    {-31500, 2, \"CWST\", \"CWST\", \"Australia/Eucla\"},\n    {-28800, 1, \"IRKT\", \"IRKST\", \"Asia/Irkutsk\"},\n    {-28800, 1, \"ULAT\", \"ULAST\", \"Asia/Ulaanbaatar\"},\n    {-28800, 2, \"WST\", \"WST\", \"Australia/West\"},\n    {-25200, 1, \"HOVT\", \"HOVST\", \"Asia/Hovd\"},\n    {-25200, 1, \"KRAT\", \"KRAST\", \"Asia/Krasnoyarsk\"},\n    {-21600, 1, \"NOVT\", \"NOVST\", \"Asia/Novosibirsk\"},\n    {-21600, 1, \"OMST\", \"OMSST\", \"Asia/Omsk\"},\n    {-18000, 1, \"YEKT\", \"YEKST\", \"Asia/Yekaterinburg\"},\n    {-14400, 1, \"SAMT\", \"SAMST\", \"Europe/Samara\"},\n    {-14400, 1, \"AMT\", \"AMST\", \"Asia/Yerevan\"},\n    {-14400, 1, \"AZT\", \"AZST\", \"Asia/Baku\"},\n    {-10800, 1, \"AST\", \"ADT\", \"Asia/Baghdad\"},\n    {-10800, 1, \"MSK\", \"MSD\", \"Europe/Moscow\"},\n    {-10800, 1, \"VOLT\", \"VOLST\", \"Europe/Volgograd\"},\n    {-7200, 0, \"EET\", \"CEST\", \"Africa/Tripoli\"},\n    {-7200, 1, \"EET\", \"EEST\", \"Europe/Athens\"}, /* Conflicts with Africa/Cairo */\n    {-7200, 1, \"IST\", \"IDT\", \"Asia/Jerusalem\"},\n    {-3600, 0, \"CET\", \"WEST\", \"Africa/Algiers\"},\n    {-3600, 2, \"WAT\", \"WAST\", \"Africa/Windhoek\"},\n    {0, 1, \"GMT\", \"IST\", \"Europe/Dublin\"},\n    {0, 1, \"GMT\", \"BST\", \"Europe/London\"},\n    {0, 0, \"WET\", \"WEST\", \"Africa/Casablanca\"},\n    {0, 0, \"WET\", \"WET\", \"Africa/El_Aaiun\"},\n    {3600, 1, \"AZOT\", \"AZOST\", \"Atlantic/Azores\"},\n    {3600, 1, \"EGT\", \"EGST\", \"America/Scoresbysund\"},\n    {10800, 1, \"PMST\", \"PMDT\", \"America/Miquelon\"},\n    {10800, 2, \"UYT\", \"UYST\", \"America/Montevideo\"},\n    {10800, 1, \"WGT\", \"WGST\", \"America/Godthab\"},\n    {10800, 2, \"BRT\", \"BRST\", \"Brazil/East\"},\n    {12600, 1, \"NST\", \"NDT\", \"America/St_Johns\"},\n    {14400, 1, \"AST\", \"ADT\", \"Canada/Atlantic\"},\n    {14400, 2, \"AMT\", \"AMST\", \"America/Cuiaba\"},\n    {14400, 2, \"CLT\", \"CLST\", \"Chile/Continental\"},\n    {14400, 2, \"FKT\", \"FKST\", \"Atlantic/Stanley\"},\n    {14400, 2, \"PYT\", \"PYST\", \"America/Asuncion\"},\n    {18000, 1, \"CST\", \"CDT\", \"America/Havana\"},\n    {18000, 1, \"EST\", \"EDT\", \"US/Eastern\"}, /* Conflicts with America/Grand_Turk */\n    {21600, 2, \"EAST\", \"EASST\", \"Chile/EasterIsland\"},\n    {21600, 0, \"CST\", \"MDT\", \"Canada/Saskatchewan\"},\n    {21600, 0, \"CST\", \"CDT\", \"America/Guatemala\"},\n    {21600, 1, \"CST\", \"CDT\", \"US/Central\"}, /* Conflicts with Mexico/General */\n    {25200, 1, \"MST\", \"MDT\", \"US/Mountain\"}, /* Conflicts with Mexico/BajaSur */\n    {28800, 0, \"PST\", \"PST\", \"Pacific/Pitcairn\"},\n    {28800, 1, \"PST\", \"PDT\", \"US/Pacific\"}, /* Conflicts with Mexico/BajaNorte */\n    {32400, 1, \"AKST\", \"AKDT\", \"US/Alaska\"},\n    {36000, 1, \"HAST\", \"HADT\", \"US/Aleutian\"}\n};\n\n/*#define DEBUG_TZNAME*/\n\nstatic const char* remapShortTimeZone(const char *stdID, const char *dstID, int32_t daylightType, int32_t offset)\n{\n    int32_t idx;\n#ifdef DEBUG_TZNAME\n    fprintf(stderr, \"TZ=%s std=%s dst=%s daylight=%d offset=%d\\n\", getenv(\"TZ\"), stdID, dstID, daylightType, offset);\n#endif\n    for (idx = 0; idx < UPRV_LENGTHOF(OFFSET_ZONE_MAPPINGS); idx++)\n    {\n        if (offset == OFFSET_ZONE_MAPPINGS[idx].offsetSeconds\n            && daylightType == OFFSET_ZONE_MAPPINGS[idx].daylightType\n            && strcmp(OFFSET_ZONE_MAPPINGS[idx].stdID, stdID) == 0\n            && strcmp(OFFSET_ZONE_MAPPINGS[idx].dstID, dstID) == 0)\n        {\n            return OFFSET_ZONE_MAPPINGS[idx].olsonID;\n        }\n    }\n    return NULL;\n}\n#endif\n\n#ifdef SEARCH_TZFILE\n#define MAX_READ_SIZE 512\n\ntypedef struct DefaultTZInfo {\n    char* defaultTZBuffer;\n    int64_t defaultTZFileSize;\n    FILE* defaultTZFilePtr;\n    UBool defaultTZstatus;\n    int32_t defaultTZPosition;\n} DefaultTZInfo;\n\n/*\n * This method compares the two files given to see if they are a match.\n * It is currently use to compare two TZ files.\n */\nstatic UBool compareBinaryFiles(const char* defaultTZFileName, const char* TZFileName, DefaultTZInfo* tzInfo) {\n    FILE* file; \n    int64_t sizeFile;\n    int64_t sizeFileLeft;\n    int32_t sizeFileRead;\n    int32_t sizeFileToRead;\n    char bufferFile[MAX_READ_SIZE];\n    UBool result = TRUE;\n\n    if (tzInfo->defaultTZFilePtr == NULL) {\n        tzInfo->defaultTZFilePtr = fopen(defaultTZFileName, \"r\");\n    }\n    file = fopen(TZFileName, \"r\");\n\n    tzInfo->defaultTZPosition = 0; /* reset position to begin search */\n\n    if (file != NULL && tzInfo->defaultTZFilePtr != NULL) {\n        /* First check that the file size are equal. */\n        if (tzInfo->defaultTZFileSize == 0) {\n            fseek(tzInfo->defaultTZFilePtr, 0, SEEK_END);\n            tzInfo->defaultTZFileSize = ftell(tzInfo->defaultTZFilePtr);\n        }\n        fseek(file, 0, SEEK_END);\n        sizeFile = ftell(file);\n        sizeFileLeft = sizeFile;\n\n        if (sizeFile != tzInfo->defaultTZFileSize) {\n            result = FALSE;\n        } else {\n            /* Store the data from the files in seperate buffers and\n             * compare each byte to determine equality.\n             */\n            if (tzInfo->defaultTZBuffer == NULL) {\n                rewind(tzInfo->defaultTZFilePtr);\n                tzInfo->defaultTZBuffer = (char*)uprv_malloc(sizeof(char) * tzInfo->defaultTZFileSize);\n                sizeFileRead = fread(tzInfo->defaultTZBuffer, 1, tzInfo->defaultTZFileSize, tzInfo->defaultTZFilePtr);\n            }\n            rewind(file);\n            while(sizeFileLeft > 0) {\n                uprv_memset(bufferFile, 0, MAX_READ_SIZE);\n                sizeFileToRead = sizeFileLeft < MAX_READ_SIZE ? sizeFileLeft : MAX_READ_SIZE;\n\n                sizeFileRead = fread(bufferFile, 1, sizeFileToRead, file);\n                if (memcmp(tzInfo->defaultTZBuffer + tzInfo->defaultTZPosition, bufferFile, sizeFileRead) != 0) {\n                    result = FALSE;\n                    break;\n                }\n                sizeFileLeft -= sizeFileRead;\n                tzInfo->defaultTZPosition += sizeFileRead;\n            }\n        }\n    } else {\n        result = FALSE;\n    }\n\n    if (file != NULL) {\n        fclose(file);\n    }\n\n    return result;\n}\n\n\n/* dirent also lists two entries: \".\" and \"..\" that we can safely ignore. */\n#define SKIP1 \".\"\n#define SKIP2 \"..\"\nstatic UBool U_CALLCONV putil_cleanup(void);\nstatic CharString *gSearchTZFileResult = NULL;\n\n/*\n * This method recursively traverses the directory given for a matching TZ file and returns the first match.\n * This function is not thread safe - it uses a global, gSearchTZFileResult, to hold its results.\n */\nstatic char* searchForTZFile(const char* path, DefaultTZInfo* tzInfo) {\n    DIR* dirp = opendir(path);\n    DIR* subDirp = NULL;\n    struct dirent* dirEntry = NULL;\n\n    char* result = NULL;\n    if (dirp == NULL) {\n        return result;\n    }\n\n    if (gSearchTZFileResult == NULL) {\n        gSearchTZFileResult = new CharString;\n        if (gSearchTZFileResult == NULL) {\n            return NULL;\n        }\n        ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n    }\n\n    /* Save the current path */\n    UErrorCode status = U_ZERO_ERROR;\n    CharString curpath(path, -1, status);\n    if (U_FAILURE(status)) {\n        return NULL;\n    }\n\n    /* Check each entry in the directory. */\n    while((dirEntry = readdir(dirp)) != NULL) {\n        const char* dirName = dirEntry->d_name;\n        if (uprv_strcmp(dirName, SKIP1) != 0 && uprv_strcmp(dirName, SKIP2) != 0) {\n            /* Create a newpath with the new entry to test each entry in the directory. */\n            CharString newpath(curpath, status);\n            newpath.append(dirName, -1, status);\n            if (U_FAILURE(status)) {\n                return NULL;\n            }\n\n            if ((subDirp = opendir(newpath.data())) != NULL) {\n                /* If this new path is a directory, make a recursive call with the newpath. */\n                closedir(subDirp);\n                newpath.append('/', status);\n                if (U_FAILURE(status)) {\n                    return NULL;\n                }\n                result = searchForTZFile(newpath.data(), tzInfo);\n                /*\n                 Have to get out here. Otherwise, we'd keep looking\n                 and return the first match in the top-level directory\n                 if there's a match in the top-level. If not, this function\n                 would return NULL and set gTimeZoneBufferPtr to NULL in initDefault().\n                 It worked without this in most cases because we have a fallback of calling\n                 localtime_r to figure out the default timezone.\n                */\n                if (result != NULL)\n                    break;\n            } else if (uprv_strcmp(TZFILE_SKIP, dirName) != 0 && uprv_strcmp(TZFILE_SKIP2, dirName) != 0) {\n                if(compareBinaryFiles(TZDEFAULT, newpath.data(), tzInfo)) {\n                    int32_t amountToSkip = sizeof(TZZONEINFO) - 1;\n                    if (amountToSkip > newpath.length()) {\n                        amountToSkip = newpath.length();\n                    }\n                    const char* zoneid = newpath.data() + amountToSkip;\n                    skipZoneIDPrefix(&zoneid);\n                    gSearchTZFileResult->clear();\n                    gSearchTZFileResult->append(zoneid, -1, status);\n                    if (U_FAILURE(status)) {\n                        return NULL;\n                    }\n                    result = gSearchTZFileResult->data();\n                    /* Get out after the first one found. */\n                    break;\n                }\n            }\n        }\n    }\n    closedir(dirp);\n    return result;\n}\n#endif\n\nU_CAPI void U_EXPORT2\nuprv_tzname_clear_cache()\n{\n#if defined(CHECK_LOCALTIME_LINK) && !defined(DEBUG_SKIP_LOCALTIME_LINK)\n    gTimeZoneBufferPtr = NULL;\n#endif\n}\n\n// With the Universal Windows Platform we can just ask Windows for the name\n#if U_PLATFORM_HAS_WINUWP_API\nU_CAPI const char* U_EXPORT2\nuprv_getWindowsTimeZone()\n{\n    // Get default Windows timezone.   \n    ComPtr<IInspectable> calendar;\n    HRESULT hr = RoActivateInstance(\n        HStringReference(RuntimeClass_Windows_Globalization_Calendar).Get(),\n        &calendar);\n    if (SUCCEEDED(hr))\n    {\n        ComPtr<ABI::Windows::Globalization::ITimeZoneOnCalendar> timezone;\n        hr = calendar.As(&timezone);\n        if (SUCCEEDED(hr))\n        {\n            HString timezoneString;\n            hr = timezone->GetTimeZone(timezoneString.GetAddressOf());\n            if (SUCCEEDED(hr))\n            {\n                int32_t length = wcslen(timezoneString.GetRawBuffer(NULL));\n                char* asciiId = (char*)uprv_calloc(length + 1, sizeof(char));\n                if (asciiId != nullptr)\n                {\n                    u_UCharsToChars((UChar*)timezoneString.GetRawBuffer(NULL), asciiId, length);\n                    return asciiId;\n                }\n            }\n        }\n    }\n\n    // Failed\n    return nullptr;\n}\n#endif\n\nU_CAPI const char* U_EXPORT2\nuprv_tzname(int n)\n{\n    const char *tzid = NULL;\n#if U_PLATFORM_USES_ONLY_WIN32_API\n#if U_PLATFORM_HAS_WINUWP_API > 0\n    tzid = uprv_getWindowsTimeZone();\n#else\n    tzid = uprv_detectWindowsTimeZone();\n#endif\n\n    if (tzid != NULL) {\n        return tzid;\n    }\n\n#ifndef U_TZNAME\n    // The return value is free'd in timezone.cpp on Windows because\n    // the other code path returns a pointer to a heap location.\n    // If we don't have a name already, then tzname wouldn't be any\n    // better, so just fall back.\n    return uprv_strdup(\"Etc/UTC\");\n#endif // !U_TZNAME\n\n#else\n\n/*#if U_PLATFORM_IS_DARWIN_BASED\n    int ret;\n\n    tzid = getenv(\"TZFILE\");\n    if (tzid != NULL) {\n        return tzid;\n    }\n#endif*/\n\n/* This code can be temporarily disabled to test tzname resolution later on. */\n#ifndef DEBUG_TZNAME\n    tzid = getenv(\"TZ\");\n    if (tzid != NULL && isValidOlsonID(tzid)\n#if U_PLATFORM == U_PF_SOLARIS\n    /* When TZ equals localtime on Solaris, check the /etc/localtime file. */\n        && uprv_strcmp(tzid, TZ_ENV_CHECK) != 0\n#endif\n    ) {\n        /* The colon forces tzset() to treat the remainder as zoneinfo path */ \n        if (tzid[0] == ':') { \n            tzid++; \n        } \n        /* This might be a good Olson ID. */\n        skipZoneIDPrefix(&tzid);\n        return tzid;\n    }\n    /* else U_TZNAME will give a better result. */\n#endif\n\n#if defined(CHECK_LOCALTIME_LINK) && !defined(DEBUG_SKIP_LOCALTIME_LINK)\n    /* Caller must handle threading issues */\n    if (gTimeZoneBufferPtr == NULL) {\n        /*\n        This is a trick to look at the name of the link to get the Olson ID\n        because the tzfile contents is underspecified.\n        This isn't guaranteed to work because it may not be a symlink.\n        */\n        int32_t ret = (int32_t)readlink(TZDEFAULT, gTimeZoneBuffer, sizeof(gTimeZoneBuffer)-1);\n        if (0 < ret) {\n            int32_t tzZoneInfoLen = uprv_strlen(TZZONEINFO);\n            gTimeZoneBuffer[ret] = 0;\n            if (uprv_strncmp(gTimeZoneBuffer, TZZONEINFO, tzZoneInfoLen) == 0\n                && isValidOlsonID(gTimeZoneBuffer + tzZoneInfoLen))\n            {\n                return (gTimeZoneBufferPtr = gTimeZoneBuffer + tzZoneInfoLen);\n            }\n#if U_PLATFORM == U_PF_SOLARIS\n            else\n            {\n                tzZoneInfoLen = uprv_strlen(TZZONEINFO2);\n                if (uprv_strncmp(gTimeZoneBuffer, TZZONEINFO2, tzZoneInfoLen) == 0\n                                && isValidOlsonID(gTimeZoneBuffer + tzZoneInfoLen))\n                {\n                    return (gTimeZoneBufferPtr = gTimeZoneBuffer + tzZoneInfoLen);\n                }\n            }\n#endif\n        } else {\n#if defined(SEARCH_TZFILE)\n            DefaultTZInfo* tzInfo = (DefaultTZInfo*)uprv_malloc(sizeof(DefaultTZInfo));\n            if (tzInfo != NULL) {\n                tzInfo->defaultTZBuffer = NULL;\n                tzInfo->defaultTZFileSize = 0;\n                tzInfo->defaultTZFilePtr = NULL;\n                tzInfo->defaultTZstatus = FALSE;\n                tzInfo->defaultTZPosition = 0;\n\n                gTimeZoneBufferPtr = searchForTZFile(TZZONEINFO, tzInfo);\n\n                /* Free previously allocated memory */\n                if (tzInfo->defaultTZBuffer != NULL) {\n                    uprv_free(tzInfo->defaultTZBuffer);\n                }\n                if (tzInfo->defaultTZFilePtr != NULL) {\n                    fclose(tzInfo->defaultTZFilePtr);\n                }\n                uprv_free(tzInfo);\n            }\n\n            if (gTimeZoneBufferPtr != NULL && isValidOlsonID(gTimeZoneBufferPtr)) {\n                return gTimeZoneBufferPtr;\n            }\n#endif\n        }\n    }\n    else {\n        return gTimeZoneBufferPtr;\n    }\n#endif\n#endif\n\n#ifdef U_TZNAME\n#if U_PLATFORM_USES_ONLY_WIN32_API\n    /* The return value is free'd in timezone.cpp on Windows because\n     * the other code path returns a pointer to a heap location. */\n    return uprv_strdup(U_TZNAME[n]);\n#else\n    /*\n    U_TZNAME is usually a non-unique abbreviation, which isn't normally usable.\n    So we remap the abbreviation to an olson ID.\n\n    Since Windows exposes a little more timezone information,\n    we normally don't use this code on Windows because\n    uprv_detectWindowsTimeZone should have already given the correct answer.\n    */\n    {\n        struct tm juneSol, decemberSol;\n        int daylightType;\n        static const time_t juneSolstice=1182478260; /*2007-06-21 18:11 UT*/\n        static const time_t decemberSolstice=1198332540; /*2007-12-22 06:09 UT*/\n\n        /* This probing will tell us when daylight savings occurs.  */\n        localtime_r(&juneSolstice, &juneSol);\n        localtime_r(&decemberSolstice, &decemberSol);\n        if(decemberSol.tm_isdst > 0) {\n          daylightType = U_DAYLIGHT_DECEMBER;\n        } else if(juneSol.tm_isdst > 0) {\n          daylightType = U_DAYLIGHT_JUNE;\n        } else {\n          daylightType = U_DAYLIGHT_NONE;\n        }\n        tzid = remapShortTimeZone(U_TZNAME[0], U_TZNAME[1], daylightType, uprv_timezone());\n        if (tzid != NULL) {\n            return tzid;\n        }\n    }\n    return U_TZNAME[n];\n#endif\n#else\n    return \"\";\n#endif\n}\n\n/* Get and set the ICU data directory --------------------------------------- */\n\nstatic icu::UInitOnce gDataDirInitOnce = U_INITONCE_INITIALIZER;\nstatic char *gDataDirectory = NULL;\n\nUInitOnce gTimeZoneFilesInitOnce = U_INITONCE_INITIALIZER;\nstatic CharString *gTimeZoneFilesDirectory = NULL;\n\n#if U_POSIX_LOCALE || U_PLATFORM_USES_ONLY_WIN32_API\n static char *gCorrectedPOSIXLocale = NULL; /* Sometimes heap allocated */\n static bool gCorrectedPOSIXLocaleHeapAllocated = false;\n#endif\n\nstatic UBool U_CALLCONV putil_cleanup(void)\n{\n    if (gDataDirectory && *gDataDirectory) {\n        uprv_free(gDataDirectory);\n    }\n    gDataDirectory = NULL;\n    gDataDirInitOnce.reset();\n\n    delete gTimeZoneFilesDirectory;\n    gTimeZoneFilesDirectory = NULL;\n    gTimeZoneFilesInitOnce.reset();\n\n#ifdef SEARCH_TZFILE\n    delete gSearchTZFileResult;\n    gSearchTZFileResult = NULL;\n#endif\n\n#if U_POSIX_LOCALE || U_PLATFORM_USES_ONLY_WIN32_API\n    if (gCorrectedPOSIXLocale && gCorrectedPOSIXLocaleHeapAllocated) {\n        uprv_free(gCorrectedPOSIXLocale);\n        gCorrectedPOSIXLocale = NULL;\n        gCorrectedPOSIXLocaleHeapAllocated = false;\n    }\n#endif\n    return TRUE;\n}\n\n/*\n * Set the data directory.\n *    Make a copy of the passed string, and set the global data dir to point to it.\n */\nU_CAPI void U_EXPORT2\nu_setDataDirectory(const char *directory) {\n    char *newDataDir;\n    int32_t length;\n\n    if(directory==NULL || *directory==0) {\n        /* A small optimization to prevent the malloc and copy when the\n        shared library is used, and this is a way to make sure that NULL\n        is never returned.\n        */\n        newDataDir = (char *)\"\";\n    }\n    else {\n        length=(int32_t)uprv_strlen(directory);\n        newDataDir = (char *)uprv_malloc(length + 2);\n        /* Exit out if newDataDir could not be created. */\n        if (newDataDir == NULL) {\n            return;\n        }\n        uprv_strcpy(newDataDir, directory);\n\n#if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)\n        {\n            char *p;\n            while(p = uprv_strchr(newDataDir, U_FILE_ALT_SEP_CHAR)) {\n                *p = U_FILE_SEP_CHAR;\n            }\n        }\n#endif\n    }\n\n    if (gDataDirectory && *gDataDirectory) {\n        uprv_free(gDataDirectory);\n    }\n    gDataDirectory = newDataDir;\n    ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_pathIsAbsolute(const char *path)\n{\n  if(!path || !*path) {\n    return FALSE;\n  }\n\n  if(*path == U_FILE_SEP_CHAR) {\n    return TRUE;\n  }\n\n#if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)\n  if(*path == U_FILE_ALT_SEP_CHAR) {\n    return TRUE;\n  }\n#endif\n\n#if U_PLATFORM_USES_ONLY_WIN32_API\n  if( (((path[0] >= 'A') && (path[0] <= 'Z')) ||\n       ((path[0] >= 'a') && (path[0] <= 'z'))) &&\n      path[1] == ':' ) {\n    return TRUE;\n  }\n#endif\n\n  return FALSE;\n}\n\n/* Temporary backup setting of ICU_DATA_DIR_PREFIX_ENV_VAR\n   until some client wrapper makefiles are updated */\n#if U_PLATFORM_IS_DARWIN_BASED && TARGET_IPHONE_SIMULATOR\n# if !defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n#  define ICU_DATA_DIR_PREFIX_ENV_VAR \"IPHONE_SIMULATOR_ROOT\"\n# endif\n#endif\n\nstatic void U_CALLCONV dataDirectoryInitFn() {\n    /* If we already have the directory, then return immediately. Will happen if user called\n     * u_setDataDirectory().\n     */\n    if (gDataDirectory) {\n        return;\n    }\n\n    const char *path = NULL;\n#if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n    char datadir_path_buffer[PATH_MAX];\n#endif\n\n    /*\n    When ICU_NO_USER_DATA_OVERRIDE is defined, users aren't allowed to\n    override ICU's data with the ICU_DATA environment variable. This prevents\n    problems where multiple custom copies of ICU's specific version of data\n    are installed on a system. Either the application must define the data\n    directory with u_setDataDirectory, define ICU_DATA_DIR when compiling\n    ICU, set the data with udata_setCommonData or trust that all of the\n    required data is contained in ICU's data library that contains\n    the entry point defined by U_ICUDATA_ENTRY_POINT.\n\n    There may also be some platforms where environment variables\n    are not allowed.\n    */\n#   if !defined(ICU_NO_USER_DATA_OVERRIDE) && !UCONFIG_NO_FILE_IO\n    /* First try to get the environment variable */\n#       if U_PLATFORM_HAS_WINUWP_API == 0  // Windows UWP does not support getenv\n        path=getenv(\"ICU_DATA\");\n#       endif\n#   endif\n\n    /* ICU_DATA_DIR may be set as a compile option.\n     * U_ICU_DATA_DEFAULT_DIR is provided and is set by ICU at compile time\n     * and is used only when data is built in archive mode eliminating the need\n     * for ICU_DATA_DIR to be set. U_ICU_DATA_DEFAULT_DIR is set to the installation\n     * directory of the data dat file. Users should use ICU_DATA_DIR if they want to\n     * set their own path.\n     */\n#if defined(ICU_DATA_DIR) || defined(U_ICU_DATA_DEFAULT_DIR)\n    if(path==NULL || *path==0) {\n# if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n        const char *prefix = getenv(ICU_DATA_DIR_PREFIX_ENV_VAR);\n# endif\n# ifdef ICU_DATA_DIR\n        path=ICU_DATA_DIR;\n# else\n        path=U_ICU_DATA_DEFAULT_DIR;\n# endif\n# if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n        if (prefix != NULL) {\n            snprintf(datadir_path_buffer, PATH_MAX, \"%s%s\", prefix, path);\n            path=datadir_path_buffer;\n        }\n# endif\n    }\n#endif\n\n#if defined(ICU_DATA_DIR_WINDOWS) && U_PLATFORM_HAS_WINUWP_API != 0\n    // Use data from the %windir%\\globalization\\icu directory\n    // This is only available if ICU is built as a system component\n    char datadir_path_buffer[MAX_PATH];\n    UINT length = GetWindowsDirectoryA(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer));\n    if (length > 0 && length < (UPRV_LENGTHOF(datadir_path_buffer) - sizeof(ICU_DATA_DIR_WINDOWS) - 1))\n    {\n        if (datadir_path_buffer[length - 1] != '\\\\')\n        {\n            datadir_path_buffer[length++] = '\\\\';\n            datadir_path_buffer[length] = '\\0';\n        }\n\n        if ((length + 1 + sizeof(ICU_DATA_DIR_WINDOWS)) < UPRV_LENGTHOF(datadir_path_buffer))\n        {\n            uprv_strcat(datadir_path_buffer, ICU_DATA_DIR_WINDOWS);\n            path = datadir_path_buffer;\n        }\n    }\n#endif\n\n    if(path==NULL) {\n        /* It looks really bad, set it to something. */\n#if U_PLATFORM_HAS_WIN32_API\n        // Windows UWP will require icudtl.dat file in same directory as icuuc.dll\n        path = \".\\\\\";\n#else\n        path = \"\";\n#endif\n    }\n\n    u_setDataDirectory(path);\n    return;\n}\n\nU_CAPI const char * U_EXPORT2\nu_getDataDirectory(void) {\n    umtx_initOnce(gDataDirInitOnce, &dataDirectoryInitFn);\n    return gDataDirectory;\n}\n\nstatic void setTimeZoneFilesDir(const char *path, UErrorCode &status) {\n    if (U_FAILURE(status)) {\n        return;\n    }\n    gTimeZoneFilesDirectory->clear();\n    gTimeZoneFilesDirectory->append(path, status);\n#if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)\n    char *p = gTimeZoneFilesDirectory->data();\n    while (p = uprv_strchr(p, U_FILE_ALT_SEP_CHAR)) {\n        *p = U_FILE_SEP_CHAR;\n    }\n#endif\n}\n\n#define TO_STRING(x) TO_STRING_2(x) \n#define TO_STRING_2(x) #x\n\nstatic void U_CALLCONV TimeZoneDataDirInitFn(UErrorCode &status) {\n    U_ASSERT(gTimeZoneFilesDirectory == NULL);\n    ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n    gTimeZoneFilesDirectory = new CharString();\n    if (gTimeZoneFilesDirectory == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return;\n    }\n#if U_PLATFORM_HAS_WINUWP_API == 0\n    const char *dir = getenv(\"ICU_TIMEZONE_FILES_DIR\");\n#else\n    // TODO: UWP does not support alternate timezone data directories at this time\n    const char *dir = \"\";\n#endif // U_PLATFORM_HAS_WINUWP_API\n#if defined(U_TIMEZONE_FILES_DIR)\n    if (dir == NULL) {\n        dir = TO_STRING(U_TIMEZONE_FILES_DIR);\n    }\n#endif\n    if (dir == NULL) {\n        dir = \"\";\n    }\n    setTimeZoneFilesDir(dir, status);\n}\n\n\nU_CAPI const char * U_EXPORT2\nu_getTimeZoneFilesDirectory(UErrorCode *status) {\n    umtx_initOnce(gTimeZoneFilesInitOnce, &TimeZoneDataDirInitFn, *status);\n    return U_SUCCESS(*status) ? gTimeZoneFilesDirectory->data() : \"\";\n}\n\nU_CAPI void U_EXPORT2\nu_setTimeZoneFilesDirectory(const char *path, UErrorCode *status) {\n    umtx_initOnce(gTimeZoneFilesInitOnce, &TimeZoneDataDirInitFn, *status);\n    setTimeZoneFilesDir(path, *status);\n\n    // Note: this function does some extra churn, first setting based on the\n    //       environment, then immediately replacing with the value passed in.\n    //       The logic is simpler that way, and performance shouldn't be an issue.\n}\n\n\n#if U_POSIX_LOCALE\n/* A helper function used by uprv_getPOSIXIDForDefaultLocale and\n * uprv_getPOSIXIDForDefaultCodepage. Returns the posix locale id for\n * LC_CTYPE and LC_MESSAGES. It doesn't support other locale categories.\n */\nstatic const char *uprv_getPOSIXIDForCategory(int category)\n{\n    const char* posixID = NULL;\n    if (category == LC_MESSAGES || category == LC_CTYPE) {\n        /*\n        * On Solaris two different calls to setlocale can result in\n        * different values. Only get this value once.\n        *\n        * We must check this first because an application can set this.\n        *\n        * LC_ALL can't be used because it's platform dependent. The LANG\n        * environment variable seems to affect LC_CTYPE variable by default.\n        * Here is what setlocale(LC_ALL, NULL) can return.\n        * HPUX can return 'C C C C C C C'\n        * Solaris can return /en_US/C/C/C/C/C on the second try.\n        * Linux can return LC_CTYPE=C;LC_NUMERIC=C;...\n        *\n        * The default codepage detection also needs to use LC_CTYPE.\n        *\n        * Do not call setlocale(LC_*, \"\")! Using an empty string instead\n        * of NULL, will modify the libc behavior.\n        */\n        posixID = setlocale(category, NULL);\n        if ((posixID == 0)\n            || (uprv_strcmp(\"C\", posixID) == 0)\n            || (uprv_strcmp(\"POSIX\", posixID) == 0))\n        {\n            /* Maybe we got some garbage.  Try something more reasonable */\n            posixID = getenv(\"LC_ALL\");\n            /* Solaris speaks POSIX -  See IEEE Std 1003.1-2008 \n             * This is needed to properly handle empty env. variables\n             */\n#if U_PLATFORM == U_PF_SOLARIS\n            if ((posixID == 0) || (posixID[0] == '\\0')) {\n                posixID = getenv(category == LC_MESSAGES ? \"LC_MESSAGES\" : \"LC_CTYPE\");\n                if ((posixID == 0) || (posixID[0] == '\\0')) {\n#else\n            if (posixID == 0) {\n                posixID = getenv(category == LC_MESSAGES ? \"LC_MESSAGES\" : \"LC_CTYPE\");\n                if (posixID == 0) {\n#endif                    \n                    posixID = getenv(\"LANG\");\n                }\n            }\n        }\n    }\n    if ((posixID==0)\n        || (uprv_strcmp(\"C\", posixID) == 0)\n        || (uprv_strcmp(\"POSIX\", posixID) == 0))\n    {\n        /* Nothing worked.  Give it a nice POSIX default value. */\n        posixID = \"en_US_POSIX\";\n    }\n    return posixID;\n}\n\n/* Return just the POSIX id for the default locale, whatever happens to be in\n * it. It gets the value from LC_MESSAGES and indirectly from LC_ALL and LANG.\n */\nstatic const char *uprv_getPOSIXIDForDefaultLocale(void)\n{\n    static const char* posixID = NULL;\n    if (posixID == 0) {\n        posixID = uprv_getPOSIXIDForCategory(LC_MESSAGES);\n    }\n    return posixID;\n}\n\n#if !U_CHARSET_IS_UTF8\n/* Return just the POSIX id for the default codepage, whatever happens to be in\n * it. It gets the value from LC_CTYPE and indirectly from LC_ALL and LANG.\n */\nstatic const char *uprv_getPOSIXIDForDefaultCodepage(void)\n{\n    static const char* posixID = NULL;\n    if (posixID == 0) {\n        posixID = uprv_getPOSIXIDForCategory(LC_CTYPE);\n    }\n    return posixID;\n}\n#endif\n#endif\n\n/* NOTE: The caller should handle thread safety */\nU_CAPI const char* U_EXPORT2\nuprv_getDefaultLocaleID()\n{\n#if U_POSIX_LOCALE\n/*\n  Note that:  (a '!' means the ID is improper somehow)\n     LC_ALL  ---->     default_loc          codepage\n--------------------------------------------------------\n     ab.CD             ab                   CD\n     ab@CD             ab__CD               -\n     ab@CD.EF          ab__CD               EF\n\n     ab_CD.EF@GH       ab_CD_GH             EF\n\nSome 'improper' ways to do the same as above:\n  !  ab_CD@GH.EF       ab_CD_GH             EF\n  !  ab_CD.EF@GH.IJ    ab_CD_GH             EF\n  !  ab_CD@ZZ.EF@GH.IJ ab_CD_GH             EF\n\n     _CD@GH            _CD_GH               -\n     _CD.EF@GH         _CD_GH               EF\n\nThe variant cannot have dots in it.\nThe 'rightmost' variant (@xxx) wins.\nThe leftmost codepage (.xxx) wins.\n*/\n    char *correctedPOSIXLocale = 0;\n    const char* posixID = uprv_getPOSIXIDForDefaultLocale();\n    const char *p;\n    const char *q;\n    int32_t len;\n\n    /* Format: (no spaces)\n    ll [ _CC ] [ . MM ] [ @ VV]\n\n      l = lang, C = ctry, M = charmap, V = variant\n    */\n\n    if (gCorrectedPOSIXLocale != NULL) {\n        return gCorrectedPOSIXLocale;\n    }\n\n    if ((p = uprv_strchr(posixID, '.')) != NULL) {\n        /* assume new locale can't be larger than old one? */\n        correctedPOSIXLocale = static_cast<char *>(uprv_malloc(uprv_strlen(posixID)+1));\n        /* Exit on memory allocation error. */\n        if (correctedPOSIXLocale == NULL) {\n            return NULL;\n        }\n        uprv_strncpy(correctedPOSIXLocale, posixID, p-posixID);\n        correctedPOSIXLocale[p-posixID] = 0;\n\n        /* do not copy after the @ */\n        if ((p = uprv_strchr(correctedPOSIXLocale, '@')) != NULL) {\n            correctedPOSIXLocale[p-correctedPOSIXLocale] = 0;\n        }\n    }\n\n    /* Note that we scan the *uncorrected* ID. */\n    if ((p = uprv_strrchr(posixID, '@')) != NULL) {\n        if (correctedPOSIXLocale == NULL) {\n            correctedPOSIXLocale = static_cast<char *>(uprv_malloc(uprv_strlen(posixID)+1));\n            /* Exit on memory allocation error. */\n            if (correctedPOSIXLocale == NULL) {\n                return NULL;\n            }\n            uprv_strncpy(correctedPOSIXLocale, posixID, p-posixID);\n            correctedPOSIXLocale[p-posixID] = 0;\n        }\n        p++;\n\n        /* Take care of any special cases here.. */\n        if (!uprv_strcmp(p, \"nynorsk\")) {\n            p = \"NY\";\n            /* Don't worry about no__NY. In practice, it won't appear. */\n        }\n\n        if (uprv_strchr(correctedPOSIXLocale,'_') == NULL) {\n            uprv_strcat(correctedPOSIXLocale, \"__\"); /* aa@b -> aa__b */\n        }\n        else {\n            uprv_strcat(correctedPOSIXLocale, \"_\"); /* aa_CC@b -> aa_CC_b */\n        }\n\n        if ((q = uprv_strchr(p, '.')) != NULL) {\n            /* How big will the resulting string be? */\n            len = (int32_t)(uprv_strlen(correctedPOSIXLocale) + (q-p));\n            uprv_strncat(correctedPOSIXLocale, p, q-p);\n            correctedPOSIXLocale[len] = 0;\n        }\n        else {\n            /* Anything following the @ sign */\n            uprv_strcat(correctedPOSIXLocale, p);\n        }\n\n        /* Should there be a map from 'no@nynorsk' -> no_NO_NY here?\n         * How about 'russian' -> 'ru'?\n         * Many of the other locales using ISO codes will be handled by the\n         * canonicalization functions in uloc_getDefault.\n         */\n    }\n\n    /* Was a correction made? */\n    if (correctedPOSIXLocale != NULL) {\n        posixID = correctedPOSIXLocale;\n    }\n    else {\n        /* copy it, just in case the original pointer goes away.  See j2395 */\n        correctedPOSIXLocale = (char *)uprv_malloc(uprv_strlen(posixID) + 1);\n        /* Exit on memory allocation error. */\n        if (correctedPOSIXLocale == NULL) {\n            return NULL;\n        }\n        posixID = uprv_strcpy(correctedPOSIXLocale, posixID);\n    }\n\n    if (gCorrectedPOSIXLocale == NULL) {\n        gCorrectedPOSIXLocale = correctedPOSIXLocale;\n        gCorrectedPOSIXLocaleHeapAllocated = true;\n        ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n        correctedPOSIXLocale = NULL;\n    }\n\n    if (correctedPOSIXLocale != NULL) {  /* Was already set - clean up. */\n        uprv_free(correctedPOSIXLocale);\n    }\n\n    return posixID;\n\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n#define POSIX_LOCALE_CAPACITY 64\n    UErrorCode status = U_ZERO_ERROR;\n    char *correctedPOSIXLocale = 0;\n\n    // If we have already figured this out just use the cached value\n    if (gCorrectedPOSIXLocale != NULL) {\n        return gCorrectedPOSIXLocale;\n    }\n\n    // No cached value, need to determine the current value\n    static WCHAR windowsLocale[LOCALE_NAME_MAX_LENGTH];\n#if U_PLATFORM_HAS_WINUWP_API == 0 \n    // If not a Universal Windows App, we'll need user default language.\n    // Vista and above should use Locale Names instead of LCIDs\n    int length = GetUserDefaultLocaleName(windowsLocale, UPRV_LENGTHOF(windowsLocale));\n#else\n    // In a UWP app, we want the top language that the application and user agreed upon\n    ComPtr<ABI::Windows::Foundation::Collections::IVectorView<HSTRING>> languageList;\n\n    ComPtr<ABI::Windows::Globalization::IApplicationLanguagesStatics> applicationLanguagesStatics;\n    HRESULT hr = GetActivationFactory(\n        HStringReference(RuntimeClass_Windows_Globalization_ApplicationLanguages).Get(),\n        &applicationLanguagesStatics);\n    if (SUCCEEDED(hr))\n    {\n        hr = applicationLanguagesStatics->get_Languages(&languageList);\n    }\n\n    if (FAILED(hr))\n    {\n        // If there is no application context, then use the top language from the user language profile\n        ComPtr<ABI::Windows::System::UserProfile::IGlobalizationPreferencesStatics> globalizationPreferencesStatics;\n        hr = GetActivationFactory(\n            HStringReference(RuntimeClass_Windows_System_UserProfile_GlobalizationPreferences).Get(),\n            &globalizationPreferencesStatics);\n        if (SUCCEEDED(hr))\n        {\n            hr = globalizationPreferencesStatics->get_Languages(&languageList);\n        }\n    }\n\n    // We have a list of languages, ICU knows one, so use the top one for our locale\n    HString topLanguage;\n    if (SUCCEEDED(hr))\n    {\n        hr = languageList->GetAt(0, topLanguage.GetAddressOf());\n    }\n\n    if (FAILED(hr))\n    {\n        // Unexpected, use en-US by default\n        if (gCorrectedPOSIXLocale == NULL) {\n            gCorrectedPOSIXLocale = \"en_US\";\n        }\n\n        return gCorrectedPOSIXLocale;\n    }\n\n    // ResolveLocaleName will get a likely subtags form consistent with Windows behavior.\n    int length = ResolveLocaleName(topLanguage.GetRawBuffer(NULL), windowsLocale, UPRV_LENGTHOF(windowsLocale));\n#endif\n    // Now we should have a Windows locale name that needs converted to the POSIX style,\n    if (length > 0)\n    {\n        // First we need to go from UTF-16 to char (and also convert from _ to - while we're at it.)\n        char modifiedWindowsLocale[LOCALE_NAME_MAX_LENGTH];\n\n        int32_t i;\n        for (i = 0; i < UPRV_LENGTHOF(modifiedWindowsLocale); i++)\n        {\n            if (windowsLocale[i] == '_')\n            {\n                modifiedWindowsLocale[i] = '-';\n            }\n            else\n            {\n                modifiedWindowsLocale[i] = static_cast<char>(windowsLocale[i]);\n            }\n\n            if (modifiedWindowsLocale[i] == '\\0')\n            {\n                break;\n            }\n        }\n\n        if (i >= UPRV_LENGTHOF(modifiedWindowsLocale))\n        {\n            // Ran out of room, can't really happen, maybe we'll be lucky about a matching\n            // locale when tags are dropped\n            modifiedWindowsLocale[UPRV_LENGTHOF(modifiedWindowsLocale) - 1] = '\\0';\n        }\n\n        // Now normalize the resulting name\n        if (correctedPOSIXLocale)\n        {\n            int32_t posixLen = uloc_canonicalize(modifiedWindowsLocale, correctedPOSIXLocale, POSIX_LOCALE_CAPACITY, &status);\n            if (U_SUCCESS(status))\n            {\n                *(correctedPOSIXLocale + posixLen) = 0;\n                gCorrectedPOSIXLocale = correctedPOSIXLocale;\n                gCorrectedPOSIXLocaleHeapAllocated = true;\n                ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n            }\n            else\n            {\n                uprv_free(correctedPOSIXLocale);\n            }\n        }\n    }\n\n    // If unable to find a locale we can agree upon, use en-US by default\n    if (gCorrectedPOSIXLocale == NULL) {\n        gCorrectedPOSIXLocale = \"en_US\";\n    }\n    return gCorrectedPOSIXLocale;\n\n#elif U_PLATFORM == U_PF_OS400\n    /* locales are process scoped and are by definition thread safe */\n    static char correctedLocale[64];\n    const  char *localeID = getenv(\"LC_ALL\");\n           char *p;\n\n    if (localeID == NULL)\n        localeID = getenv(\"LANG\");\n    if (localeID == NULL)\n        localeID = setlocale(LC_ALL, NULL);\n    /* Make sure we have something... */\n    if (localeID == NULL)\n        return \"en_US_POSIX\";\n\n    /* Extract the locale name from the path. */\n    if((p = uprv_strrchr(localeID, '/')) != NULL)\n    {\n        /* Increment p to start of locale name. */\n        p++;\n        localeID = p;\n    }\n\n    /* Copy to work location. */\n    uprv_strcpy(correctedLocale, localeID);\n\n    /* Strip off the '.locale' extension. */\n    if((p = uprv_strchr(correctedLocale, '.')) != NULL) {\n        *p = 0;\n    }\n\n    /* Upper case the locale name. */\n    T_CString_toUpperCase(correctedLocale);\n\n    /* See if we are using the POSIX locale.  Any of the\n    * following are equivalent and use the same QLGPGCMA\n    * (POSIX) locale.\n    * QLGPGCMA2 means UCS2\n    * QLGPGCMA_4 means UTF-32\n    * QLGPGCMA_8 means UTF-8\n    */\n    if ((uprv_strcmp(\"C\", correctedLocale) == 0) ||\n        (uprv_strcmp(\"POSIX\", correctedLocale) == 0) ||\n        (uprv_strncmp(\"QLGPGCMA\", correctedLocale, 8) == 0))\n    {\n        uprv_strcpy(correctedLocale, \"en_US_POSIX\");\n    }\n    else\n    {\n        int16_t LocaleLen;\n\n        /* Lower case the lang portion. */\n        for(p = correctedLocale; *p != 0 && *p != '_'; p++)\n        {\n            *p = uprv_tolower(*p);\n        }\n\n        /* Adjust for Euro.  After '_E' add 'URO'. */\n        LocaleLen = uprv_strlen(correctedLocale);\n        if (correctedLocale[LocaleLen - 2] == '_' &&\n            correctedLocale[LocaleLen - 1] == 'E')\n        {\n            uprv_strcat(correctedLocale, \"URO\");\n        }\n\n        /* If using Lotus-based locale then convert to\n         * equivalent non Lotus.\n         */\n        else if (correctedLocale[LocaleLen - 2] == '_' &&\n            correctedLocale[LocaleLen - 1] == 'L')\n        {\n            correctedLocale[LocaleLen - 2] = 0;\n        }\n\n        /* There are separate simplified and traditional\n         * locales called zh_HK_S and zh_HK_T.\n         */\n        else if (uprv_strncmp(correctedLocale, \"zh_HK\", 5) == 0)\n        {\n            uprv_strcpy(correctedLocale, \"zh_HK\");\n        }\n\n        /* A special zh_CN_GBK locale...\n        */\n        else if (uprv_strcmp(correctedLocale, \"zh_CN_GBK\") == 0)\n        {\n            uprv_strcpy(correctedLocale, \"zh_CN\");\n        }\n\n    }\n\n    return correctedLocale;\n#endif\n\n}\n\n#if !U_CHARSET_IS_UTF8\n#if U_POSIX_LOCALE\n/*\nDue to various platform differences, one platform may specify a charset,\nwhen they really mean a different charset. Remap the names so that they are\ncompatible with ICU. Only conflicting/ambiguous aliases should be resolved\nhere. Before adding anything to this function, please consider adding unique\nnames to the ICU alias table in the data directory.\n*/\nstatic const char*\nremapPlatformDependentCodepage(const char *locale, const char *name) {\n    if (locale != NULL && *locale == 0) {\n        /* Make sure that an empty locale is handled the same way. */\n        locale = NULL;\n    }\n    if (name == NULL) {\n        return NULL;\n    }\n#if U_PLATFORM == U_PF_AIX\n    if (uprv_strcmp(name, \"IBM-943\") == 0) {\n        /* Use the ASCII compatible ibm-943 */\n        name = \"Shift-JIS\";\n    }\n    else if (uprv_strcmp(name, \"IBM-1252\") == 0) {\n        /* Use the windows-1252 that contains the Euro */\n        name = \"IBM-5348\";\n    }\n#elif U_PLATFORM == U_PF_SOLARIS\n    if (locale != NULL && uprv_strcmp(name, \"EUC\") == 0) {\n        /* Solaris underspecifies the \"EUC\" name. */\n        if (uprv_strcmp(locale, \"zh_CN\") == 0) {\n            name = \"EUC-CN\";\n        }\n        else if (uprv_strcmp(locale, \"zh_TW\") == 0) {\n            name = \"EUC-TW\";\n        }\n        else if (uprv_strcmp(locale, \"ko_KR\") == 0) {\n            name = \"EUC-KR\";\n        }\n    }\n    else if (uprv_strcmp(name, \"eucJP\") == 0) {\n        /*\n        ibm-954 is the best match.\n        ibm-33722 is the default for eucJP (similar to Windows).\n        */\n        name = \"eucjis\";\n    }\n    else if (uprv_strcmp(name, \"646\") == 0) {\n        /*\n         * The default codepage given by Solaris is 646 but the C library routines treat it as if it was\n         * ISO-8859-1 instead of US-ASCII(646).\n         */\n        name = \"ISO-8859-1\";\n    }\n#elif U_PLATFORM_IS_DARWIN_BASED\n    if (locale == NULL && *name == 0) {\n        /*\n        No locale was specified, and an empty name was passed in.\n        This usually indicates that nl_langinfo didn't return valid information.\n        Mac OS X uses UTF-8 by default (especially the locale data and console).\n        */\n        name = \"UTF-8\";\n    }\n    else if (uprv_strcmp(name, \"CP949\") == 0) {\n        /* Remap CP949 to a similar codepage to avoid issues with backslash and won symbol. */\n        name = \"EUC-KR\";\n    }\n    else if (locale != NULL && uprv_strcmp(locale, \"en_US_POSIX\") != 0 && uprv_strcmp(name, \"US-ASCII\") == 0) {\n        /*\n         * For non C/POSIX locale, default the code page to UTF-8 instead of US-ASCII.\n         */\n        name = \"UTF-8\";\n    }\n#elif U_PLATFORM == U_PF_BSD\n    if (uprv_strcmp(name, \"CP949\") == 0) {\n        /* Remap CP949 to a similar codepage to avoid issues with backslash and won symbol. */\n        name = \"EUC-KR\";\n    }\n#elif U_PLATFORM == U_PF_HPUX\n    if (locale != NULL && uprv_strcmp(locale, \"zh_HK\") == 0 && uprv_strcmp(name, \"big5\") == 0) {\n        /* HP decided to extend big5 as hkbig5 even though it's not compatible :-( */\n        /* zh_TW.big5 is not the same charset as zh_HK.big5! */\n        name = \"hkbig5\";\n    }\n    else if (uprv_strcmp(name, \"eucJP\") == 0) {\n        /*\n        ibm-1350 is the best match, but unavailable.\n        ibm-954 is mostly a superset of ibm-1350.\n        ibm-33722 is the default for eucJP (similar to Windows).\n        */\n        name = \"eucjis\";\n    }\n#elif U_PLATFORM == U_PF_LINUX\n    if (locale != NULL && uprv_strcmp(name, \"euc\") == 0) {\n        /* Linux underspecifies the \"EUC\" name. */\n        if (uprv_strcmp(locale, \"korean\") == 0) {\n            name = \"EUC-KR\";\n        }\n        else if (uprv_strcmp(locale, \"japanese\") == 0) {\n            /* See comment below about eucJP */\n            name = \"eucjis\";\n        }\n    }\n    else if (uprv_strcmp(name, \"eucjp\") == 0) {\n        /*\n        ibm-1350 is the best match, but unavailable.\n        ibm-954 is mostly a superset of ibm-1350.\n        ibm-33722 is the default for eucJP (similar to Windows).\n        */\n        name = \"eucjis\";\n    }\n    else if (locale != NULL && uprv_strcmp(locale, \"en_US_POSIX\") != 0 &&\n            (uprv_strcmp(name, \"ANSI_X3.4-1968\") == 0 || uprv_strcmp(name, \"US-ASCII\") == 0)) {\n        /*\n         * For non C/POSIX locale, default the code page to UTF-8 instead of US-ASCII.\n         */\n        name = \"UTF-8\";\n    }\n    /*\n     * Linux returns ANSI_X3.4-1968 for C/POSIX, but the call site takes care of\n     * it by falling back to 'US-ASCII' when NULL is returned from this\n     * function. So, we don't have to worry about it here.\n     */\n#endif\n    /* return NULL when \"\" is passed in */\n    if (*name == 0) {\n        name = NULL;\n    }\n    return name;\n}\n\nstatic const char*\ngetCodepageFromPOSIXID(const char *localeName, char * buffer, int32_t buffCapacity)\n{\n    char localeBuf[100];\n    const char *name = NULL;\n    char *variant = NULL;\n\n    if (localeName != NULL && (name = (uprv_strchr(localeName, '.'))) != NULL) {\n        size_t localeCapacity = uprv_min(sizeof(localeBuf), (name-localeName)+1);\n        uprv_strncpy(localeBuf, localeName, localeCapacity);\n        localeBuf[localeCapacity-1] = 0; /* ensure NULL termination */\n        name = uprv_strncpy(buffer, name+1, buffCapacity);\n        buffer[buffCapacity-1] = 0; /* ensure NULL termination */\n        if ((variant = const_cast<char *>(uprv_strchr(name, '@'))) != NULL) {\n            *variant = 0;\n        }\n        name = remapPlatformDependentCodepage(localeBuf, name);\n    }\n    return name;\n}\n#endif\n\nstatic const char*\nint_getDefaultCodepage()\n{\n#if U_PLATFORM == U_PF_OS400\n    uint32_t ccsid = 37; /* Default to ibm-37 */\n    static char codepage[64];\n    Qwc_JOBI0400_t jobinfo;\n    Qus_EC_t error = { sizeof(Qus_EC_t) }; /* SPI error code */\n\n    EPT_CALL(QUSRJOBI)(&jobinfo, sizeof(jobinfo), \"JOBI0400\",\n        \"*                         \", \"                \", &error);\n\n    if (error.Bytes_Available == 0) {\n        if (jobinfo.Coded_Char_Set_ID != 0xFFFF) {\n            ccsid = (uint32_t)jobinfo.Coded_Char_Set_ID;\n        }\n        else if (jobinfo.Default_Coded_Char_Set_Id != 0xFFFF) {\n            ccsid = (uint32_t)jobinfo.Default_Coded_Char_Set_Id;\n        }\n        /* else use the default */\n    }\n    sprintf(codepage,\"ibm-%d\", ccsid);\n    return codepage;\n\n#elif U_PLATFORM == U_PF_OS390\n    static char codepage[64];\n\n    strncpy(codepage, nl_langinfo(CODESET),63-strlen(UCNV_SWAP_LFNL_OPTION_STRING));\n    strcat(codepage,UCNV_SWAP_LFNL_OPTION_STRING);\n    codepage[63] = 0; /* NULL terminate */\n\n    return codepage;\n\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n    static char codepage[64];\n    DWORD codepageNumber = 0;\n\n#if U_PLATFORM_HAS_WINUWP_API > 0\n    // UWP doesn't have a direct API to get the default ACP as Microsoft would rather\n    // have folks use Unicode than a \"system\" code page, however this is the same\n    // codepage as the system default locale codepage.  (FWIW, the system locale is\n    // ONLY used for codepage, it should never be used for anything else)\n    GetLocaleInfoEx(LOCALE_NAME_SYSTEM_DEFAULT, LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,\n        (LPWSTR)&codepageNumber, sizeof(codepageNumber) / sizeof(WCHAR));\n#else\n    // Win32 apps can call GetACP\n    codepageNumber = GetACP();\n#endif\n    // Special case for UTF-8\n    if (codepageNumber == 65001)\n    { \n        return \"UTF-8\";\n    }\n    // Windows codepages can look like windows-1252, so format the found number\n    // the numbers are eclectic, however all valid system code pages, besides UTF-8\n    // are between 3 and 19999\n    if (codepageNumber > 0 && codepageNumber < 20000)\n    {\n        sprintf(codepage, \"windows-%ld\", codepageNumber);\n        return codepage;\n    }\n    // If the codepage number call failed then return UTF-8\n    return \"UTF-8\";\n\n#elif U_POSIX_LOCALE\n    static char codesetName[100];\n    const char *localeName = NULL;\n    const char *name = NULL;\n\n    localeName = uprv_getPOSIXIDForDefaultCodepage();\n    uprv_memset(codesetName, 0, sizeof(codesetName));\n    /* On Solaris nl_langinfo returns C locale values unless setlocale\n     * was called earlier.\n     */\n#if (U_HAVE_NL_LANGINFO_CODESET && U_PLATFORM != U_PF_SOLARIS)\n    /* When available, check nl_langinfo first because it usually gives more\n       useful names. It depends on LC_CTYPE.\n       nl_langinfo may use the same buffer as setlocale. */\n    {\n        const char *codeset = nl_langinfo(U_NL_LANGINFO_CODESET);\n#if U_PLATFORM_IS_DARWIN_BASED || U_PLATFORM_IS_LINUX_BASED\n        /*\n         * On Linux and MacOSX, ensure that default codepage for non C/POSIX locale is UTF-8\n         * instead of ASCII.\n         */\n        if (uprv_strcmp(localeName, \"en_US_POSIX\") != 0) {\n            codeset = remapPlatformDependentCodepage(localeName, codeset);\n        } else\n#endif\n        {\n            codeset = remapPlatformDependentCodepage(NULL, codeset);\n        }\n\n        if (codeset != NULL) {\n            uprv_strncpy(codesetName, codeset, sizeof(codesetName));\n            codesetName[sizeof(codesetName)-1] = 0;\n            return codesetName;\n        }\n    }\n#endif\n\n    /* Use setlocale in a nice way, and then check some environment variables.\n       Maybe the application used setlocale already.\n    */\n    uprv_memset(codesetName, 0, sizeof(codesetName));\n    name = getCodepageFromPOSIXID(localeName, codesetName, sizeof(codesetName));\n    if (name) {\n        /* if we can find the codeset name from setlocale, return that. */\n        return name;\n    }\n\n    if (*codesetName == 0)\n    {\n        /* Everything failed. Return US ASCII (ISO 646). */\n        (void)uprv_strcpy(codesetName, \"US-ASCII\");\n    }\n    return codesetName;\n#else\n    return \"US-ASCII\";\n#endif\n}\n\n\nU_CAPI const char*  U_EXPORT2\nuprv_getDefaultCodepage()\n{\n    static char const  *name = NULL;\n    umtx_lock(NULL);\n    if (name == NULL) {\n        name = int_getDefaultCodepage();\n    }\n    umtx_unlock(NULL);\n    return name;\n}\n#endif  /* !U_CHARSET_IS_UTF8 */\n\n\n/* end of platform-specific implementation -------------- */\n\n/* version handling --------------------------------------------------------- */\n\nU_CAPI void U_EXPORT2\nu_versionFromString(UVersionInfo versionArray, const char *versionString) {\n    char *end;\n    uint16_t part=0;\n\n    if(versionArray==NULL) {\n        return;\n    }\n\n    if(versionString!=NULL) {\n        for(;;) {\n            versionArray[part]=(uint8_t)uprv_strtoul(versionString, &end, 10);\n            if(end==versionString || ++part==U_MAX_VERSION_LENGTH || *end!=U_VERSION_DELIMITER) {\n                break;\n            }\n            versionString=end+1;\n        }\n    }\n\n    while(part<U_MAX_VERSION_LENGTH) {\n        versionArray[part++]=0;\n    }\n}\n\nU_CAPI void U_EXPORT2\nu_versionFromUString(UVersionInfo versionArray, const UChar *versionString) {\n    if(versionArray!=NULL && versionString!=NULL) {\n        char versionChars[U_MAX_VERSION_STRING_LENGTH+1];\n        int32_t len = u_strlen(versionString);\n        if(len>U_MAX_VERSION_STRING_LENGTH) {\n            len = U_MAX_VERSION_STRING_LENGTH;\n        }\n        u_UCharsToChars(versionString, versionChars, len);\n        versionChars[len]=0;\n        u_versionFromString(versionArray, versionChars);\n    }\n}\n\nU_CAPI void U_EXPORT2\nu_versionToString(const UVersionInfo versionArray, char *versionString) {\n    uint16_t count, part;\n    uint8_t field;\n\n    if(versionString==NULL) {\n        return;\n    }\n\n    if(versionArray==NULL) {\n        versionString[0]=0;\n        return;\n    }\n\n    /* count how many fields need to be written */\n    for(count=4; count>0 && versionArray[count-1]==0; --count) {\n    }\n\n    if(count <= 1) {\n        count = 2;\n    }\n\n    /* write the first part */\n    /* write the decimal field value */\n    field=versionArray[0];\n    if(field>=100) {\n        *versionString++=(char)('0'+field/100);\n        field%=100;\n    }\n    if(field>=10) {\n        *versionString++=(char)('0'+field/10);\n        field%=10;\n    }\n    *versionString++=(char)('0'+field);\n\n    /* write the following parts */\n    for(part=1; part<count; ++part) {\n        /* write a dot first */\n        *versionString++=U_VERSION_DELIMITER;\n\n        /* write the decimal field value */\n        field=versionArray[part];\n        if(field>=100) {\n            *versionString++=(char)('0'+field/100);\n            field%=100;\n        }\n        if(field>=10) {\n            *versionString++=(char)('0'+field/10);\n            field%=10;\n        }\n        *versionString++=(char)('0'+field);\n    }\n\n    /* NUL-terminate */\n    *versionString=0;\n}\n\nU_CAPI void U_EXPORT2\nu_getVersion(UVersionInfo versionArray) {\n    (void)copyright;   // Suppress unused variable warning from clang.\n    u_versionFromString(versionArray, U_ICU_VERSION);\n}\n\n/**\n * icucfg.h dependent code \n */\n\n#if U_ENABLE_DYLOAD\n \n#if HAVE_DLOPEN && !U_PLATFORM_USES_ONLY_WIN32_API\n\n#if HAVE_DLFCN_H\n\n#ifdef __MVS__\n#ifndef __SUSV3\n#define __SUSV3 1\n#endif\n#endif\n#include <dlfcn.h>\n#endif\n\nU_INTERNAL void * U_EXPORT2\nuprv_dl_open(const char *libName, UErrorCode *status) {\n  void *ret = NULL;\n  if(U_FAILURE(*status)) return ret;\n  ret =  dlopen(libName, RTLD_NOW|RTLD_GLOBAL);\n  if(ret==NULL) {\n#ifdef U_TRACE_DYLOAD\n    printf(\"dlerror on dlopen(%s): %s\\n\", libName, dlerror());\n#endif\n    *status = U_MISSING_RESOURCE_ERROR;\n  }\n  return ret;\n}\n\nU_INTERNAL void U_EXPORT2\nuprv_dl_close(void *lib, UErrorCode *status) {\n  if(U_FAILURE(*status)) return;\n  dlclose(lib);\n}\n\nU_INTERNAL UVoidFunction* U_EXPORT2\nuprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {\n  union {\n      UVoidFunction *fp;\n      void *vp;\n  } uret;\n  uret.fp = NULL;\n  if(U_FAILURE(*status)) return uret.fp;\n  uret.vp = dlsym(lib, sym);\n  if(uret.vp == NULL) {\n#ifdef U_TRACE_DYLOAD\n    printf(\"dlerror on dlsym(%p,%s): %s\\n\", lib,sym, dlerror());\n#endif\n    *status = U_MISSING_RESOURCE_ERROR;\n  }\n  return uret.fp;\n}\n\n#else\n\n/* null (nonexistent) implementation. */\n\nU_INTERNAL void * U_EXPORT2\nuprv_dl_open(const char *libName, UErrorCode *status) {\n  if(U_FAILURE(*status)) return NULL;\n  *status = U_UNSUPPORTED_ERROR;\n  return NULL;\n}\n\nU_INTERNAL void U_EXPORT2\nuprv_dl_close(void *lib, UErrorCode *status) {\n  if(U_FAILURE(*status)) return;\n  *status = U_UNSUPPORTED_ERROR;\n  return;\n}\n\n\nU_INTERNAL UVoidFunction* U_EXPORT2\nuprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {\n  if(U_SUCCESS(*status)) {\n    *status = U_UNSUPPORTED_ERROR;\n  }\n  return (UVoidFunction*)NULL;\n}\n\n\n\n#endif\n\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n\nU_INTERNAL void * U_EXPORT2\nuprv_dl_open(const char *libName, UErrorCode *status) {\n  HMODULE lib = NULL;\n  \n  if(U_FAILURE(*status)) return NULL;\n  \n  lib = LoadLibraryA(libName);\n  \n  if(lib==NULL) {\n    *status = U_MISSING_RESOURCE_ERROR;\n  }\n  \n  return (void*)lib;\n}\n\nU_INTERNAL void U_EXPORT2\nuprv_dl_close(void *lib, UErrorCode *status) {\n  HMODULE handle = (HMODULE)lib;\n  if(U_FAILURE(*status)) return;\n  \n  FreeLibrary(handle);\n  \n  return;\n}\n\n\nU_INTERNAL UVoidFunction* U_EXPORT2\nuprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {\n  HMODULE handle = (HMODULE)lib;\n  UVoidFunction* addr = NULL;\n  \n  if(U_FAILURE(*status) || lib==NULL) return NULL;\n  \n  addr = (UVoidFunction*)GetProcAddress(handle, sym);\n  \n  if(addr==NULL) {\n    DWORD lastError = GetLastError();\n    if(lastError == ERROR_PROC_NOT_FOUND) {\n      *status = U_MISSING_RESOURCE_ERROR;\n    } else {\n      *status = U_UNSUPPORTED_ERROR; /* other unknown error. */\n    }\n  }\n  \n  return addr;\n}\n\n\n#else\n\n/* No dynamic loading set. */\n\nU_INTERNAL void * U_EXPORT2\nuprv_dl_open(const char *libName, UErrorCode *status) {\n    (void)libName;\n    if(U_FAILURE(*status)) return NULL;\n    *status = U_UNSUPPORTED_ERROR;\n    return NULL;\n}\n\nU_INTERNAL void U_EXPORT2\nuprv_dl_close(void *lib, UErrorCode *status) {\n    (void)lib;\n    if(U_FAILURE(*status)) return;\n    *status = U_UNSUPPORTED_ERROR;\n    return;\n}\n\n\nU_INTERNAL UVoidFunction* U_EXPORT2\nuprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {\n  (void)lib;\n  (void)sym;\n  if(U_SUCCESS(*status)) {\n    *status = U_UNSUPPORTED_ERROR;\n  }\n  return (UVoidFunction*)NULL;\n}\n\n#endif /* U_ENABLE_DYLOAD */\n\n/*\n * Hey, Emacs, please set the following:\n *\n * Local Variables:\n * indent-tabs-mode: nil\n * End:\n *\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/extra/icu/source/common/icuplug.cpp": "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/*\n******************************************************************************\n*\n*   Copyright (C) 2009-2015, International Business Machines\n*   Corporation and others.  All Rights Reserved.\n*\n******************************************************************************\n*\n*  FILE NAME : icuplug.c\n*\n*   Date         Name        Description\n*   10/29/2009   sl          New.\n******************************************************************************\n*/\n\n#include \"unicode/icuplug.h\"\n\n\n#if UCONFIG_ENABLE_PLUGINS\n\n\n#include \"icuplugimp.h\"\n#include \"cstring.h\"\n#include \"cmemory.h\"\n#include \"putilimp.h\"\n#include \"ucln.h\"\n#include <stdio.h>\n#ifdef __MVS__  /* defined by z/OS compiler */\n#define _POSIX_SOURCE\n#include <cics.h> /* 12 Nov 2011 JAM iscics() function */\n#endif\n#include \"charstr.h\"\n\nusing namespace icu;\n\n#ifndef UPLUG_TRACE\n#define UPLUG_TRACE 0\n#endif\n\n#if UPLUG_TRACE\n#include <stdio.h>\n#define DBG(x) fprintf(stderr, \"%s:%d: \",__FILE__,__LINE__); fprintf x\n#endif\n\n/**\n * Internal structure of an ICU plugin. \n */\n\nstruct UPlugData {\n  UPlugEntrypoint  *entrypoint; /**< plugin entrypoint */\n  uint32_t structSize;    /**< initialized to the size of this structure */\n  uint32_t token;         /**< must be U_PLUG_TOKEN */\n  void *lib;              /**< plugin library, or NULL */\n  char libName[UPLUG_NAME_MAX];   /**< library name */\n  char sym[UPLUG_NAME_MAX];        /**< plugin symbol, or NULL */\n  char config[UPLUG_NAME_MAX];     /**< configuration data */\n  void *context;          /**< user context data */\n  char name[UPLUG_NAME_MAX];   /**< name of plugin */\n  UPlugLevel  level; /**< level of plugin */\n  UBool   awaitingLoad; /**< TRUE if the plugin is awaiting a load call */\n  UBool   dontUnload; /**< TRUE if plugin must stay resident (leak plugin and lib) */\n  UErrorCode pluginStatus; /**< status code of plugin */\n};\n\n\n\n#define UPLUG_LIBRARY_INITIAL_COUNT 8\n#define UPLUG_PLUGIN_INITIAL_COUNT 12\n\n/**\n * Remove an item\n * @param list the full list\n * @param listSize the number of entries in the list\n * @param memberSize the size of one member\n * @param itemToRemove the item number of the member\n * @return the new listsize \n */\nstatic int32_t uplug_removeEntryAt(void *list, int32_t listSize, int32_t memberSize, int32_t itemToRemove) {\n  uint8_t *bytePtr = (uint8_t *)list;\n    \n  /* get rid of some bad cases first */\n  if(listSize<1) {\n    return listSize;\n  }\n    \n  /* is there anything to move? */\n  if(listSize > itemToRemove+1) {\n    memmove(bytePtr+(itemToRemove*memberSize), bytePtr+((itemToRemove+1)*memberSize), memberSize);\n  }\n    \n  return listSize-1;\n}\n\n\n\n\n#if U_ENABLE_DYLOAD\n/**\n * Library management. Internal. \n * @internal\n */\nstruct UPlugLibrary;\n\n/**\n * Library management. Internal. \n * @internal\n */\ntypedef struct UPlugLibrary {\n  void *lib;                           /**< library ptr */\n  char name[UPLUG_NAME_MAX]; /**< library name */\n  uint32_t ref;                        /**< reference count */\n} UPlugLibrary;\n\nstatic UPlugLibrary   staticLibraryList[UPLUG_LIBRARY_INITIAL_COUNT];\nstatic UPlugLibrary * libraryList = staticLibraryList;\nstatic int32_t libraryCount = 0;\nstatic int32_t libraryMax = UPLUG_LIBRARY_INITIAL_COUNT;\n\n/**\n * Search for a library. Doesn't lock\n * @param libName libname to search for\n * @return the library's struct\n */\nstatic int32_t searchForLibraryName(const char *libName) {\n  int32_t i;\n    \n  for(i=0;i<libraryCount;i++) {\n    if(!uprv_strcmp(libName, libraryList[i].name)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nstatic int32_t searchForLibrary(void *lib) {\n  int32_t i;\n    \n  for(i=0;i<libraryCount;i++) {\n    if(lib==libraryList[i].lib) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nU_INTERNAL char * U_EXPORT2\nuplug_findLibrary(void *lib, UErrorCode *status) {\n  int32_t libEnt;\n  char *ret = NULL;\n  if(U_FAILURE(*status)) {\n    return NULL;\n  }\n  libEnt = searchForLibrary(lib);\n  if(libEnt!=-1) { \n    ret = libraryList[libEnt].name;\n  } else {\n    *status = U_MISSING_RESOURCE_ERROR;\n  }\n  return ret;\n}\n\nU_INTERNAL void * U_EXPORT2\nuplug_openLibrary(const char *libName, UErrorCode *status) {\n  int32_t libEntry = -1;\n  void *lib = NULL;\n    \n  if(U_FAILURE(*status)) return NULL;\n\n  libEntry = searchForLibraryName(libName);\n  if(libEntry == -1) {\n    libEntry = libraryCount++;\n    if(libraryCount >= libraryMax) {\n      /* Ran out of library slots. Statically allocated because we can't depend on allocating memory.. */\n      *status = U_MEMORY_ALLOCATION_ERROR;\n#if UPLUG_TRACE\n      DBG((stderr, \"uplug_openLibrary() - out of library slots (max %d)\\n\", libraryMax));\n#endif\n      return NULL;\n    }\n    /* Some operating systems don't want \n       DL operations from multiple threads. */\n    libraryList[libEntry].lib = uprv_dl_open(libName, status);\n#if UPLUG_TRACE\n    DBG((stderr, \"uplug_openLibrary(%s,%s) libEntry %d, lib %p\\n\", libName, u_errorName(*status), libEntry, lib));\n#endif\n        \n    if(libraryList[libEntry].lib == NULL || U_FAILURE(*status)) {\n      /* cleanup. */\n      libraryList[libEntry].lib = NULL; /* failure with open */\n      libraryList[libEntry].name[0] = 0;\n#if UPLUG_TRACE\n      DBG((stderr, \"uplug_openLibrary(%s,%s) libEntry %d, lib %p\\n\", libName, u_errorName(*status), libEntry, lib));\n#endif\n      /* no need to free - just won't increase the count. */\n      libraryCount--;\n    } else { /* is it still there? */\n      /* link it in */\n      uprv_strncpy(libraryList[libEntry].name,libName,UPLUG_NAME_MAX);\n      libraryList[libEntry].ref=1;\n      lib = libraryList[libEntry].lib;\n    }\n\n  } else {\n    lib = libraryList[libEntry].lib;\n    libraryList[libEntry].ref++;\n  }\n  return lib;\n}\n\nU_INTERNAL void U_EXPORT2\nuplug_closeLibrary(void *lib, UErrorCode *status) {\n  int32_t i;\n    \n#if UPLUG_TRACE\n  DBG((stderr, \"uplug_closeLibrary(%p,%s) list %p\\n\", lib, u_errorName(*status), (void*)libraryList));\n#endif\n  if(U_FAILURE(*status)) return;\n    \n  for(i=0;i<libraryCount;i++) {\n    if(lib==libraryList[i].lib) {\n      if(--(libraryList[i].ref) == 0) {\n        uprv_dl_close(libraryList[i].lib, status);\n        libraryCount = uplug_removeEntryAt(libraryList, libraryCount, sizeof(*libraryList), i);\n      }\n      return;\n    }\n  }\n  *status = U_INTERNAL_PROGRAM_ERROR; /* could not find the entry! */\n}\n\n#endif\n\nstatic UPlugData pluginList[UPLUG_PLUGIN_INITIAL_COUNT];\nstatic int32_t pluginCount = 0;\n\n\n\n  \nstatic int32_t uplug_pluginNumber(UPlugData* d) {\n  UPlugData *pastPlug = &pluginList[pluginCount];\n  if(d<=pluginList) {\n    return 0;\n  } else if(d>=pastPlug) {\n    return pluginCount;\n  } else {\n    return (d-pluginList)/sizeof(pluginList[0]);\n  }\n}\n\n\nU_CAPI UPlugData * U_EXPORT2\nuplug_nextPlug(UPlugData *prior) {\n  if(prior==NULL) {\n    return pluginList;\n  } else {\n    UPlugData *nextPlug = &prior[1];\n    UPlugData *pastPlug = &pluginList[pluginCount];\n    \n    if(nextPlug>=pastPlug) {\n      return NULL;\n    } else {\n      return nextPlug;\n    }\n  }\n}\n\n\n\n/**\n * Call the plugin with some params\n */\nstatic void uplug_callPlug(UPlugData *plug, UPlugReason reason, UErrorCode *status) {\n  UPlugTokenReturn token;\n  if(plug==NULL||U_FAILURE(*status)) {\n    return;\n  }\n  token = (*(plug->entrypoint))(plug, reason, status);\n  if(token!=UPLUG_TOKEN) {\n    *status = U_INTERNAL_PROGRAM_ERROR;\n  }\n}\n\n\nstatic void uplug_unloadPlug(UPlugData *plug, UErrorCode *status) {\n  if(plug->awaitingLoad) {  /* shouldn't happen. Plugin hasn'tbeen loaded yet.*/\n    *status = U_INTERNAL_PROGRAM_ERROR;\n    return; \n  }\n  if(U_SUCCESS(plug->pluginStatus)) {\n    /* Don't unload a plug which has a failing load status - means it didn't actually load. */\n    uplug_callPlug(plug, UPLUG_REASON_UNLOAD, status);\n  }\n}\n\nstatic void uplug_queryPlug(UPlugData *plug, UErrorCode *status) {\n  if(!plug->awaitingLoad || !(plug->level == UPLUG_LEVEL_UNKNOWN) ) {  /* shouldn't happen. Plugin hasn'tbeen loaded yet.*/\n    *status = U_INTERNAL_PROGRAM_ERROR;\n    return; \n  }\n  plug->level = UPLUG_LEVEL_INVALID;\n  uplug_callPlug(plug, UPLUG_REASON_QUERY, status);\n  if(U_SUCCESS(*status)) { \n    if(plug->level == UPLUG_LEVEL_INVALID) {\n      plug->pluginStatus = U_PLUGIN_DIDNT_SET_LEVEL;\n      plug->awaitingLoad = FALSE;\n    }\n  } else {\n    plug->pluginStatus = U_INTERNAL_PROGRAM_ERROR;\n    plug->awaitingLoad = FALSE;\n  }\n}\n\n\nstatic void uplug_loadPlug(UPlugData *plug, UErrorCode *status) {\n  if(U_FAILURE(*status)) {\n    return;\n  }\n  if(!plug->awaitingLoad || (plug->level < UPLUG_LEVEL_LOW) ) {  /* shouldn't happen. Plugin hasn'tbeen loaded yet.*/\n    *status = U_INTERNAL_PROGRAM_ERROR;\n    return;\n  }\n  uplug_callPlug(plug, UPLUG_REASON_LOAD, status);\n  plug->awaitingLoad = FALSE;\n  if(!U_SUCCESS(*status)) {\n    plug->pluginStatus = U_INTERNAL_PROGRAM_ERROR;\n  }\n}\n\nstatic UPlugData *uplug_allocateEmptyPlug(UErrorCode *status)\n{\n  UPlugData *plug = NULL;\n\n  if(U_FAILURE(*status)) {\n    return NULL;\n  }\n\n  if(pluginCount == UPLUG_PLUGIN_INITIAL_COUNT) {\n    *status = U_MEMORY_ALLOCATION_ERROR;\n    return NULL;\n  }\n\n  plug = &pluginList[pluginCount++];\n\n  plug->token = UPLUG_TOKEN;\n  plug->structSize = sizeof(UPlugData);\n  plug->name[0]=0;\n  plug->level = UPLUG_LEVEL_UNKNOWN; /* initialize to null state */\n  plug->awaitingLoad = TRUE;\n  plug->dontUnload = FALSE;\n  plug->pluginStatus = U_ZERO_ERROR;\n  plug->libName[0] = 0;\n  plug->config[0]=0;\n  plug->sym[0]=0;\n  plug->lib=NULL;\n  plug->entrypoint=NULL;\n\n\n  return plug;\n}\n\nstatic UPlugData *uplug_allocatePlug(UPlugEntrypoint *entrypoint, const char *config, void *lib, const char *symName,\n                                     UErrorCode *status) {\n  UPlugData *plug = uplug_allocateEmptyPlug(status);\n  if(U_FAILURE(*status)) {\n    return NULL;\n  }\n\n  if(config!=NULL) {\n    uprv_strncpy(plug->config, config, UPLUG_NAME_MAX);\n  } else {\n    plug->config[0] = 0;\n  }\n    \n  if(symName!=NULL) {\n    uprv_strncpy(plug->sym, symName, UPLUG_NAME_MAX);\n  } else {\n    plug->sym[0] = 0;\n  }\n    \n  plug->entrypoint = entrypoint;\n  plug->lib = lib;\n  uplug_queryPlug(plug, status);\n    \n  return plug;\n}\n\nstatic void uplug_deallocatePlug(UPlugData *plug, UErrorCode *status) {\n  UErrorCode subStatus = U_ZERO_ERROR;\n  if(!plug->dontUnload) {\n#if U_ENABLE_DYLOAD\n    uplug_closeLibrary(plug->lib, &subStatus);\n#endif\n  }\n  plug->lib = NULL;\n  if(U_SUCCESS(*status) && U_FAILURE(subStatus)) {\n    *status = subStatus;\n  }\n  /* shift plugins up and decrement count. */\n  if(U_SUCCESS(*status)) {\n    /* all ok- remove. */\n    pluginCount = uplug_removeEntryAt(pluginList, pluginCount, sizeof(plug[0]), uplug_pluginNumber(plug));\n  } else {\n    /* not ok- leave as a message. */\n    plug->awaitingLoad=FALSE;\n    plug->entrypoint=0;\n    plug->dontUnload=TRUE;\n  }\n}\n\nstatic void uplug_doUnloadPlug(UPlugData *plugToRemove, UErrorCode *status) {\n  if(plugToRemove != NULL) {\n    uplug_unloadPlug(plugToRemove, status);\n    uplug_deallocatePlug(plugToRemove, status);\n  }\n}\n\nU_CAPI void U_EXPORT2\nuplug_removePlug(UPlugData *plug, UErrorCode *status)  {\n  UPlugData *cursor = NULL;\n  UPlugData *plugToRemove = NULL;\n  if(U_FAILURE(*status)) return;\n    \n  for(cursor=pluginList;cursor!=NULL;) {\n    if(cursor==plug) {\n      plugToRemove = plug;\n      cursor=NULL;\n    } else {\n      cursor = uplug_nextPlug(cursor);\n    }\n  }\n    \n  uplug_doUnloadPlug(plugToRemove, status);\n}\n\n\n\n\nU_CAPI void U_EXPORT2 \nuplug_setPlugNoUnload(UPlugData *data, UBool dontUnload)\n{\n  data->dontUnload = dontUnload;\n}\n\n\nU_CAPI void U_EXPORT2\nuplug_setPlugLevel(UPlugData *data, UPlugLevel level) {\n  data->level = level;\n}\n\n\nU_CAPI UPlugLevel U_EXPORT2\nuplug_getPlugLevel(UPlugData *data) {\n  return data->level;\n}\n\n\nU_CAPI void U_EXPORT2\nuplug_setPlugName(UPlugData *data, const char *name) {\n  uprv_strncpy(data->name, name, UPLUG_NAME_MAX);\n}\n\n\nU_CAPI const char * U_EXPORT2\nuplug_getPlugName(UPlugData *data) {\n  return data->name;\n}\n\n\nU_CAPI const char * U_EXPORT2\nuplug_getSymbolName(UPlugData *data) {\n  return data->sym;\n}\n\nU_CAPI const char * U_EXPORT2\nuplug_getLibraryName(UPlugData *data, UErrorCode *status) {\n  if(data->libName[0]) {\n    return data->libName;\n  } else {\n#if U_ENABLE_DYLOAD\n    return uplug_findLibrary(data->lib, status);\n#else\n    return NULL;\n#endif\n  }\n}\n\nU_CAPI void * U_EXPORT2\nuplug_getLibrary(UPlugData *data) {\n  return data->lib;\n}\n\nU_CAPI void * U_EXPORT2\nuplug_getContext(UPlugData *data) {\n  return data->context;\n}\n\n\nU_CAPI void U_EXPORT2\nuplug_setContext(UPlugData *data, void *context) {\n  data->context = context;\n}\n\nU_CAPI const char* U_EXPORT2\nuplug_getConfiguration(UPlugData *data) {\n  return data->config;\n}\n\nU_INTERNAL UPlugData* U_EXPORT2\nuplug_getPlugInternal(int32_t n) { \n  if(n <0 || n >= pluginCount) {\n    return NULL;\n  } else { \n    return &(pluginList[n]);\n  }\n}\n\n\nU_CAPI UErrorCode U_EXPORT2\nuplug_getPlugLoadStatus(UPlugData *plug) {\n  return plug->pluginStatus;\n}\n\n\n\n\n/**\n * Initialize a plugin fron an entrypoint and library - but don't load it.\n */\nstatic UPlugData* uplug_initPlugFromEntrypointAndLibrary(UPlugEntrypoint *entrypoint, const char *config, void *lib, const char *sym,\n                                                         UErrorCode *status) {\n  UPlugData *plug = NULL;\n\n  plug = uplug_allocatePlug(entrypoint, config, lib, sym, status);\n\n  if(U_SUCCESS(*status)) {\n    return plug;\n  } else {\n    uplug_deallocatePlug(plug, status);\n    return NULL;\n  }\n}\n\nU_CAPI UPlugData* U_EXPORT2\nuplug_loadPlugFromEntrypoint(UPlugEntrypoint *entrypoint, const char *config, UErrorCode *status) {\n  UPlugData* plug = uplug_initPlugFromEntrypointAndLibrary(entrypoint, config, NULL, NULL, status);\n  uplug_loadPlug(plug, status);\n  return plug;\n}\n\n#if U_ENABLE_DYLOAD\n\nstatic UPlugData* \nuplug_initErrorPlug(const char *libName, const char *sym, const char *config, const char *nameOrError, UErrorCode loadStatus, UErrorCode *status)\n{\n  UPlugData *plug = uplug_allocateEmptyPlug(status);\n  if(U_FAILURE(*status)) return NULL;\n\n  plug->pluginStatus = loadStatus;\n  plug->awaitingLoad = FALSE; /* Won't load. */\n  plug->dontUnload = TRUE; /* cannot unload. */\n\n  if(sym!=NULL) {\n    uprv_strncpy(plug->sym, sym, UPLUG_NAME_MAX);\n  }\n\n  if(libName!=NULL) {\n    uprv_strncpy(plug->libName, libName, UPLUG_NAME_MAX);\n  }\n\n  if(nameOrError!=NULL) {\n    uprv_strncpy(plug->name, nameOrError, UPLUG_NAME_MAX);\n  }\n\n  if(config!=NULL) {\n    uprv_strncpy(plug->config, config, UPLUG_NAME_MAX);\n  }\n\n  return plug;\n}\n\n/**\n * Fetch a plugin from DLL, and then initialize it from a library- but don't load it.\n */\nstatic UPlugData* \nuplug_initPlugFromLibrary(const char *libName, const char *sym, const char *config, UErrorCode *status) {\n  void *lib = NULL;\n  UPlugData *plug = NULL;\n  if(U_FAILURE(*status)) { return NULL; }\n  lib = uplug_openLibrary(libName, status);\n  if(lib!=NULL && U_SUCCESS(*status)) {\n    UPlugEntrypoint *entrypoint = NULL;\n    entrypoint = (UPlugEntrypoint*)uprv_dlsym_func(lib, sym, status);\n\n    if(entrypoint!=NULL&&U_SUCCESS(*status)) {\n      plug = uplug_initPlugFromEntrypointAndLibrary(entrypoint, config, lib, sym, status);\n      if(plug!=NULL&&U_SUCCESS(*status)) {\n        plug->lib = lib; /* plug takes ownership of library */\n        lib = NULL; /* library is now owned by plugin. */\n      }\n    } else {\n      UErrorCode subStatus = U_ZERO_ERROR;\n      plug = uplug_initErrorPlug(libName,sym,config,\"ERROR: Could not load entrypoint\",(lib==NULL)?U_MISSING_RESOURCE_ERROR:*status,&subStatus);\n    }\n    if(lib!=NULL) { /* still need to close the lib */\n      UErrorCode subStatus = U_ZERO_ERROR;\n      uplug_closeLibrary(lib, &subStatus); /* don't care here */\n    }\n  } else {\n    UErrorCode subStatus = U_ZERO_ERROR;\n    plug = uplug_initErrorPlug(libName,sym,config,\"ERROR: could not load library\",(lib==NULL)?U_MISSING_RESOURCE_ERROR:*status,&subStatus);\n  }\n  return plug;\n}\n\nU_CAPI UPlugData* U_EXPORT2\nuplug_loadPlugFromLibrary(const char *libName, const char *sym, const char *config, UErrorCode *status) { \n  UPlugData *plug = NULL;\n  if(U_FAILURE(*status)) { return NULL; }\n  plug = uplug_initPlugFromLibrary(libName, sym, config, status);\n  uplug_loadPlug(plug, status);\n\n  return plug;\n}\n\n#endif\n\nstatic UPlugLevel gCurrentLevel = UPLUG_LEVEL_LOW;\n\nU_CAPI UPlugLevel U_EXPORT2 uplug_getCurrentLevel() {\n  return gCurrentLevel;\n}\n\nstatic UBool U_CALLCONV uplug_cleanup(void)\n{\n  int32_t i;\n    \n  UPlugData *pluginToRemove;\n  /* cleanup plugs */\n  for(i=0;i<pluginCount;i++) {\n    UErrorCode subStatus = U_ZERO_ERROR;\n    pluginToRemove = &pluginList[i];\n    /* unload and deallocate */\n    uplug_doUnloadPlug(pluginToRemove, &subStatus);\n  }\n  /* close other held libs? */\n  gCurrentLevel = UPLUG_LEVEL_LOW;\n  return TRUE;\n}\n\n#if U_ENABLE_DYLOAD\n\nstatic void uplug_loadWaitingPlugs(UErrorCode *status) {\n  int32_t i;\n  UPlugLevel currentLevel = uplug_getCurrentLevel();\n    \n  if(U_FAILURE(*status)) {\n    return;\n  }\n#if UPLUG_TRACE\n  DBG((stderr,  \"uplug_loadWaitingPlugs() Level: %d\\n\", currentLevel));\n#endif\n  /* pass #1: low level plugs */\n  for(i=0;i<pluginCount;i++) {\n    UErrorCode subStatus = U_ZERO_ERROR;\n    UPlugData *pluginToLoad = &pluginList[i];\n    if(pluginToLoad->awaitingLoad) {\n      if(pluginToLoad->level == UPLUG_LEVEL_LOW) {\n        if(currentLevel > UPLUG_LEVEL_LOW) {\n          pluginToLoad->pluginStatus = U_PLUGIN_TOO_HIGH;\n        } else {\n          UPlugLevel newLevel;\n          uplug_loadPlug(pluginToLoad, &subStatus);\n          newLevel = uplug_getCurrentLevel();\n          if(newLevel > currentLevel) {\n            pluginToLoad->pluginStatus = U_PLUGIN_CHANGED_LEVEL_WARNING;\n            currentLevel = newLevel;\n          }\n        }\n        pluginToLoad->awaitingLoad = FALSE;\n      } \n    }\n  }    \n  for(i=0;i<pluginCount;i++) {\n    UErrorCode subStatus = U_ZERO_ERROR;\n    UPlugData *pluginToLoad = &pluginList[i];\n        \n    if(pluginToLoad->awaitingLoad) {\n      if(pluginToLoad->level == UPLUG_LEVEL_INVALID) { \n        pluginToLoad->pluginStatus = U_PLUGIN_DIDNT_SET_LEVEL;\n      } else if(pluginToLoad->level == UPLUG_LEVEL_UNKNOWN) {\n        pluginToLoad->pluginStatus = U_INTERNAL_PROGRAM_ERROR;\n      } else {\n        uplug_loadPlug(pluginToLoad, &subStatus);\n      }\n      pluginToLoad->awaitingLoad = FALSE;\n    }\n  }\n    \n#if UPLUG_TRACE\n  DBG((stderr,  \" Done Loading Plugs. Level: %d\\n\", (int32_t)uplug_getCurrentLevel()));\n#endif\n}\n\n/* Name of the plugin config file */\nstatic char plugin_file[2048] = \"\";\n#endif\n\nU_INTERNAL const char* U_EXPORT2\nuplug_getPluginFile() {\n#if U_ENABLE_DYLOAD && !UCONFIG_NO_FILE_IO\n  return plugin_file;\n#else\n  return NULL;\n#endif\n}\n\n\n//  uplug_init()  is called first thing from u_init().\n\nU_CAPI void U_EXPORT2\nuplug_init(UErrorCode *status) {\n#if !U_ENABLE_DYLOAD\n  (void)status; /* unused */\n#elif !UCONFIG_NO_FILE_IO\n  CharString plugin_dir;\n  const char *env = getenv(\"ICU_PLUGINS\");\n\n  if(U_FAILURE(*status)) return;\n  if(env != NULL) {\n    plugin_dir.append(env, -1, *status);\n  }\n  if(U_FAILURE(*status)) return;\n\n#if defined(DEFAULT_ICU_PLUGINS) \n  if(plugin_dir.isEmpty()) {\n    plugin_dir.append(DEFAULT_ICU_PLUGINS, -1, *status);\n  }\n#endif\n\n#if UPLUG_TRACE\n  DBG((stderr, \"ICU_PLUGINS=%s\\n\", plugin_dir.data()));\n#endif\n\n  if(!plugin_dir.isEmpty()) {\n    FILE *f;\n        \n    CharString pluginFile;\n#ifdef OS390BATCH\n/* There are potentially a lot of ways to implement a plugin directory on OS390/zOS  */\n/* Keeping in mind that unauthorized file access is logged, monitored, and enforced  */\n/* I've chosen to open a DDNAME if BATCH and leave it alone for (presumably) UNIX    */\n/* System Services.  Alternative techniques might be allocating a member in          */\n/* SYS1.PARMLIB or setting an environment variable \"ICU_PLUGIN_PATH\" (?).  The       */\n/* DDNAME can be connected to a file in the HFS if need be.                          */\n\n    pluginFile.append(\"//DD:ICUPLUG\", -1, *status);        /* JAM 20 Oct 2011 */\n#else\n    pluginFile.append(plugin_dir, *status);\n    pluginFile.append(U_FILE_SEP_STRING, -1, *status);\n    pluginFile.append(\"icuplugins\", -1, *status);\n    pluginFile.append(U_ICU_VERSION_SHORT, -1, *status);\n    pluginFile.append(\".txt\", -1, *status);\n#endif\n\n#if UPLUG_TRACE\n    DBG((stderr, \"status=%s\\n\", u_errorName(*status)));\n#endif\n\n    if(U_FAILURE(*status)) {\n      return;\n    }\n    if((size_t)pluginFile.length() > (sizeof(plugin_file)-1)) {\n      *status = U_BUFFER_OVERFLOW_ERROR;\n#if UPLUG_TRACE\n      DBG((stderr, \"status=%s\\n\", u_errorName(*status)));\n#endif\n      return;\n    }\n    \n    /* plugin_file is not used for processing - it is only used \n       so that uplug_getPluginFile() works (i.e. icuinfo)\n    */\n    uprv_strncpy(plugin_file, pluginFile.data(), sizeof(plugin_file));\n        \n#if UPLUG_TRACE\n    DBG((stderr, \"pluginfile= %s len %d/%d\\n\", plugin_file, (int)strlen(plugin_file), (int)sizeof(plugin_file)));\n#endif\n        \n#ifdef __MVS__\n    if (iscics()) /* 12 Nov 2011 JAM */\n    {\n        f = NULL;\n    }\n    else\n#endif\n    {\n        f = fopen(pluginFile.data(), \"r\");\n    }\n\n    if(f != NULL) {\n      char linebuf[1024];\n      char *p, *libName=NULL, *symName=NULL, *config=NULL;\n      int32_t line = 0;\n            \n            \n      while(fgets(linebuf,1023,f)) {\n        line++;\n\n        if(!*linebuf || *linebuf=='#') {\n          continue;\n        } else {\n          p = linebuf;\n          while(*p&&isspace((int)*p))\n            p++;\n          if(!*p || *p=='#') continue;\n          libName = p;\n          while(*p&&!isspace((int)*p)) {\n            p++;\n          }\n          if(!*p || *p=='#') continue; /* no tab after libname */\n          *p=0; /* end of libname */\n          p++;\n          while(*p&&isspace((int)*p)) {\n            p++;\n          }\n          if(!*p||*p=='#') continue; /* no symname after libname +tab */\n          symName = p;\n          while(*p&&!isspace((int)*p)) {\n            p++;\n          }\n                    \n          if(*p) { /* has config */\n            *p=0;\n            ++p;\n            while(*p&&isspace((int)*p)) {\n              p++;\n            }\n            if(*p) {\n              config = p;\n            }\n          }\n                    \n          /* chop whitespace at the end of the config */\n          if(config!=NULL&&*config!=0) {\n            p = config+strlen(config);\n            while(p>config&&isspace((int)*(--p))) {\n              *p=0;\n            }\n          }\n                \n          /* OK, we're good. */\n          { \n            UErrorCode subStatus = U_ZERO_ERROR;\n            UPlugData *plug = uplug_initPlugFromLibrary(libName, symName, config, &subStatus);\n            if(U_FAILURE(subStatus) && U_SUCCESS(*status)) {\n              *status = subStatus;\n            }\n#if UPLUG_TRACE\n            DBG((stderr, \"PLUGIN libName=[%s], sym=[%s], config=[%s]\\n\", libName, symName, config));\n            DBG((stderr, \" -> %p, %s\\n\", (void*)plug, u_errorName(subStatus)));\n#else\n            (void)plug; /* unused */\n#endif\n          }\n        }\n      }\n      fclose(f);\n    } else {\n#if UPLUG_TRACE\n      DBG((stderr, \"Can't open plugin file %s\\n\", plugin_file));\n#endif\n    }\n  }\n  uplug_loadWaitingPlugs(status);\n#endif /* U_ENABLE_DYLOAD */\n  gCurrentLevel = UPLUG_LEVEL_HIGH;\n  ucln_registerCleanup(UCLN_UPLUG, uplug_cleanup);\n}\n\n#endif\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/extra/icu/source/common/unicode/urename.h": "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/*\n*******************************************************************************\n*   Copyright (C) 2002-2016, International Business Machines\n*   Corporation and others.  All Rights Reserved.\n*******************************************************************************\n*\n*   file name:  urename.h\n*   encoding:   UTF-8\n*   tab size:   8 (not used)\n*   indentation:4\n*\n*   Created by: Perl script tools/genren.pl written by Vladimir Weinstein\n*\n*  Contains data for renaming ICU exports.\n*  Gets included by umachine.h\n*\n*  THIS FILE IS MACHINE-GENERATED, DON'T PLAY WITH IT IF YOU DON'T KNOW WHAT\n*  YOU ARE DOING, OTHERWISE VERY BAD THINGS WILL HAPPEN!\n*/\n\n#ifndef URENAME_H\n#define URENAME_H\n\n/* U_DISABLE_RENAMING can be defined in the following ways:\n *   - when running configure, e.g.\n *        runConfigureICU Linux --disable-renaming\n *   - by changing the default setting of U_DISABLE_RENAMING in uconfig.h\n */\n\n#include \"unicode/uconfig.h\"\n\n#if !U_DISABLE_RENAMING\n\n/* We need the U_ICU_ENTRY_POINT_RENAME definition. There's a default one in unicode/uvernum.h we can use, but we will give\n   the platform a chance to define it first.\n   Normally (if utypes.h or umachine.h was included first) this will not be necessary as it will already be defined.\n */\n\n#ifndef U_ICU_ENTRY_POINT_RENAME\n#include \"unicode/umachine.h\"\n#endif\n\n/* If we still don't have U_ICU_ENTRY_POINT_RENAME use the default. */\n#ifndef U_ICU_ENTRY_POINT_RENAME\n#include \"unicode/uvernum.h\"\n#endif\n\n/* Error out before the following defines cause very strange and unexpected code breakage */\n#ifndef U_ICU_ENTRY_POINT_RENAME\n#error U_ICU_ENTRY_POINT_RENAME is not defined - cannot continue. Consider defining U_DISABLE_RENAMING if renaming should not be used.\n#endif\n\n\n/* C exports renaming data */\n\n#define T_CString_int64ToString U_ICU_ENTRY_POINT_RENAME(T_CString_int64ToString)\n#define T_CString_integerToString U_ICU_ENTRY_POINT_RENAME(T_CString_integerToString)\n#define T_CString_stringToInteger U_ICU_ENTRY_POINT_RENAME(T_CString_stringToInteger)\n#define T_CString_toLowerCase U_ICU_ENTRY_POINT_RENAME(T_CString_toLowerCase)\n#define T_CString_toUpperCase U_ICU_ENTRY_POINT_RENAME(T_CString_toUpperCase)\n#define UCNV_FROM_U_CALLBACK_ESCAPE U_ICU_ENTRY_POINT_RENAME(UCNV_FROM_U_CALLBACK_ESCAPE)\n#define UCNV_FROM_U_CALLBACK_SKIP U_ICU_ENTRY_POINT_RENAME(UCNV_FROM_U_CALLBACK_SKIP)\n#define UCNV_FROM_U_CALLBACK_STOP U_ICU_ENTRY_POINT_RENAME(UCNV_FROM_U_CALLBACK_STOP)\n#define UCNV_FROM_U_CALLBACK_SUBSTITUTE U_ICU_ENTRY_POINT_RENAME(UCNV_FROM_U_CALLBACK_SUBSTITUTE)\n#define UCNV_TO_U_CALLBACK_ESCAPE U_ICU_ENTRY_POINT_RENAME(UCNV_TO_U_CALLBACK_ESCAPE)\n#define UCNV_TO_U_CALLBACK_SKIP U_ICU_ENTRY_POINT_RENAME(UCNV_TO_U_CALLBACK_SKIP)\n#define UCNV_TO_U_CALLBACK_STOP U_ICU_ENTRY_POINT_RENAME(UCNV_TO_U_CALLBACK_STOP)\n#define UCNV_TO_U_CALLBACK_SUBSTITUTE U_ICU_ENTRY_POINT_RENAME(UCNV_TO_U_CALLBACK_SUBSTITUTE)\n#define UDataMemory_createNewInstance U_ICU_ENTRY_POINT_RENAME(UDataMemory_createNewInstance)\n#define UDataMemory_init U_ICU_ENTRY_POINT_RENAME(UDataMemory_init)\n#define UDataMemory_isLoaded U_ICU_ENTRY_POINT_RENAME(UDataMemory_isLoaded)\n#define UDataMemory_normalizeDataPointer U_ICU_ENTRY_POINT_RENAME(UDataMemory_normalizeDataPointer)\n#define UDataMemory_setData U_ICU_ENTRY_POINT_RENAME(UDataMemory_setData)\n#define UDatamemory_assign U_ICU_ENTRY_POINT_RENAME(UDatamemory_assign)\n#define _ASCIIData U_ICU_ENTRY_POINT_RENAME(_ASCIIData)\n#define _Bocu1Data U_ICU_ENTRY_POINT_RENAME(_Bocu1Data)\n#define _CESU8Data U_ICU_ENTRY_POINT_RENAME(_CESU8Data)\n#define _CompoundTextData U_ICU_ENTRY_POINT_RENAME(_CompoundTextData)\n#define _HZData U_ICU_ENTRY_POINT_RENAME(_HZData)\n#define _IMAPData U_ICU_ENTRY_POINT_RENAME(_IMAPData)\n#define _ISCIIData U_ICU_ENTRY_POINT_RENAME(_ISCIIData)\n#define _ISO2022Data U_ICU_ENTRY_POINT_RENAME(_ISO2022Data)\n#define _LMBCSData1 U_ICU_ENTRY_POINT_RENAME(_LMBCSData1)\n#define _LMBCSData11 U_ICU_ENTRY_POINT_RENAME(_LMBCSData11)\n#define _LMBCSData16 U_ICU_ENTRY_POINT_RENAME(_LMBCSData16)\n#define _LMBCSData17 U_ICU_ENTRY_POINT_RENAME(_LMBCSData17)\n#define _LMBCSData18 U_ICU_ENTRY_POINT_RENAME(_LMBCSData18)\n#define _LMBCSData19 U_ICU_ENTRY_POINT_RENAME(_LMBCSData19)\n#define _LMBCSData2 U_ICU_ENTRY_POINT_RENAME(_LMBCSData2)\n#define _LMBCSData3 U_ICU_ENTRY_POINT_RENAME(_LMBCSData3)\n#define _LMBCSData4 U_ICU_ENTRY_POINT_RENAME(_LMBCSData4)\n#define _LMBCSData5 U_ICU_ENTRY_POINT_RENAME(_LMBCSData5)\n#define _LMBCSData6 U_ICU_ENTRY_POINT_RENAME(_LMBCSData6)\n#define _LMBCSData8 U_ICU_ENTRY_POINT_RENAME(_LMBCSData8)\n#define _Latin1Data U_ICU_ENTRY_POINT_RENAME(_Latin1Data)\n#define _MBCSData U_ICU_ENTRY_POINT_RENAME(_MBCSData)\n#define _SCSUData U_ICU_ENTRY_POINT_RENAME(_SCSUData)\n#define _UTF16BEData U_ICU_ENTRY_POINT_RENAME(_UTF16BEData)\n#define _UTF16Data U_ICU_ENTRY_POINT_RENAME(_UTF16Data)\n#define _UTF16LEData U_ICU_ENTRY_POINT_RENAME(_UTF16LEData)\n#define _UTF16v2Data U_ICU_ENTRY_POINT_RENAME(_UTF16v2Data)\n#define _UTF32BEData U_ICU_ENTRY_POINT_RENAME(_UTF32BEData)\n#define _UTF32Data U_ICU_ENTRY_POINT_RENAME(_UTF32Data)\n#define _UTF32LEData U_ICU_ENTRY_POINT_RENAME(_UTF32LEData)\n#define _UTF7Data U_ICU_ENTRY_POINT_RENAME(_UTF7Data)\n#define _UTF8Data U_ICU_ENTRY_POINT_RENAME(_UTF8Data)\n#define allowedHourFormatsCleanup U_ICU_ENTRY_POINT_RENAME(allowedHourFormatsCleanup)\n#define cmemory_cleanup U_ICU_ENTRY_POINT_RENAME(cmemory_cleanup)\n#define dayPeriodRulesCleanup U_ICU_ENTRY_POINT_RENAME(dayPeriodRulesCleanup)\n#define deleteAllowedHourFormats U_ICU_ENTRY_POINT_RENAME(deleteAllowedHourFormats)\n#define gTimeZoneFilesInitOnce U_ICU_ENTRY_POINT_RENAME(gTimeZoneFilesInitOnce)\n#define izrule_clone U_ICU_ENTRY_POINT_RENAME(izrule_clone)\n#define izrule_close U_ICU_ENTRY_POINT_RENAME(izrule_close)\n#define izrule_equals U_ICU_ENTRY_POINT_RENAME(izrule_equals)\n#define izrule_getDSTSavings U_ICU_ENTRY_POINT_RENAME(izrule_getDSTSavings)\n#define izrule_getDynamicClassID U_ICU_ENTRY_POINT_RENAME(izrule_getDynamicClassID)\n#define izrule_getFinalStart U_ICU_ENTRY_POINT_RENAME(izrule_getFinalStart)\n#define izrule_getFirstStart U_ICU_ENTRY_POINT_RENAME(izrule_getFirstStart)\n#define izrule_getName U_ICU_ENTRY_POINT_RENAME(izrule_getName)\n#define izrule_getNextStart U_ICU_ENTRY_POINT_RENAME(izrule_getNextStart)\n#define izrule_getPreviousStart U_ICU_ENTRY_POINT_RENAME(izrule_getPreviousStart)\n#define izrule_getRawOffset U_ICU_ENTRY_POINT_RENAME(izrule_getRawOffset)\n#define izrule_getStaticClassID U_ICU_ENTRY_POINT_RENAME(izrule_getStaticClassID)\n#define izrule_isEquivalentTo U_ICU_ENTRY_POINT_RENAME(izrule_isEquivalentTo)\n#define izrule_open U_ICU_ENTRY_POINT_RENAME(izrule_open)\n#define locale_getKeywords U_ICU_ENTRY_POINT_RENAME(locale_getKeywords)\n#define locale_getKeywordsStart U_ICU_ENTRY_POINT_RENAME(locale_getKeywordsStart)\n#define locale_get_default U_ICU_ENTRY_POINT_RENAME(locale_get_default)\n#define locale_set_default U_ICU_ENTRY_POINT_RENAME(locale_set_default)\n#define pl_addFontRun U_ICU_ENTRY_POINT_RENAME(pl_addFontRun)\n#define pl_addLocaleRun U_ICU_ENTRY_POINT_RENAME(pl_addLocaleRun)\n#define pl_addValueRun U_ICU_ENTRY_POINT_RENAME(pl_addValueRun)\n#define pl_close U_ICU_ENTRY_POINT_RENAME(pl_close)\n#define pl_closeFontRuns U_ICU_ENTRY_POINT_RENAME(pl_closeFontRuns)\n#define pl_closeLine U_ICU_ENTRY_POINT_RENAME(pl_closeLine)\n#define pl_closeLocaleRuns U_ICU_ENTRY_POINT_RENAME(pl_closeLocaleRuns)\n#define pl_closeValueRuns U_ICU_ENTRY_POINT_RENAME(pl_closeValueRuns)\n#define pl_countLineRuns U_ICU_ENTRY_POINT_RENAME(pl_countLineRuns)\n#define pl_create U_ICU_ENTRY_POINT_RENAME(pl_create)\n#define pl_getAscent U_ICU_ENTRY_POINT_RENAME(pl_getAscent)\n#define pl_getDescent U_ICU_ENTRY_POINT_RENAME(pl_getDescent)\n#define pl_getFontRunCount U_ICU_ENTRY_POINT_RENAME(pl_getFontRunCount)\n#define pl_getFontRunFont U_ICU_ENTRY_POINT_RENAME(pl_getFontRunFont)\n#define pl_getFontRunLastLimit U_ICU_ENTRY_POINT_RENAME(pl_getFontRunLastLimit)\n#define pl_getFontRunLimit U_ICU_ENTRY_POINT_RENAME(pl_getFontRunLimit)\n#define pl_getLeading U_ICU_ENTRY_POINT_RENAME(pl_getLeading)\n#define pl_getLineAscent U_ICU_ENTRY_POINT_RENAME(pl_getLineAscent)\n#define pl_getLineDescent U_ICU_ENTRY_POINT_RENAME(pl_getLineDescent)\n#define pl_getLineLeading U_ICU_ENTRY_POINT_RENAME(pl_getLineLeading)\n#define pl_getLineVisualRun U_ICU_ENTRY_POINT_RENAME(pl_getLineVisualRun)\n#define pl_getLineWidth U_ICU_ENTRY_POINT_RENAME(pl_getLineWidth)\n#define pl_getLocaleRunCount U_ICU_ENTRY_POINT_RENAME(pl_getLocaleRunCount)\n#define pl_getLocaleRunLastLimit U_ICU_ENTRY_POINT_RENAME(pl_getLocaleRunLastLimit)\n#define pl_getLocaleRunLimit U_ICU_ENTRY_POINT_RENAME(pl_getLocaleRunLimit)\n#define pl_getLocaleRunLocale U_ICU_ENTRY_POINT_RENAME(pl_getLocaleRunLocale)\n#define pl_getParagraphLevel U_ICU_ENTRY_POINT_RENAME(pl_getParagraphLevel)\n#define pl_getTextDirection U_ICU_ENTRY_POINT_RENAME(pl_getTextDirection)\n#define pl_getValueRunCount U_ICU_ENTRY_POINT_RENAME(pl_getValueRunCount)\n#define pl_getValueRunLastLimit U_ICU_ENTRY_POINT_RENAME(pl_getValueRunLastLimit)\n#define pl_getValueRunLimit U_ICU_ENTRY_POINT_RENAME(pl_getValueRunLimit)\n#define pl_getValueRunValue U_ICU_ENTRY_POINT_RENAME(pl_getValueRunValue)\n#define pl_getVisualRunAscent U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunAscent)\n#define pl_getVisualRunDescent U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunDescent)\n#define pl_getVisualRunDirection U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunDirection)\n#define pl_getVisualRunFont U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunFont)\n#define pl_getVisualRunGlyphCount U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunGlyphCount)\n#define pl_getVisualRunGlyphToCharMap U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunGlyphToCharMap)\n#define pl_getVisualRunGlyphs U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunGlyphs)\n#define pl_getVisualRunLeading U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunLeading)\n#define pl_getVisualRunPositions U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunPositions)\n#define pl_isComplex U_ICU_ENTRY_POINT_RENAME(pl_isComplex)\n#define pl_nextLine U_ICU_ENTRY_POINT_RENAME(pl_nextLine)\n#define pl_openEmptyFontRuns U_ICU_ENTRY_POINT_RENAME(pl_openEmptyFontRuns)\n#define pl_openEmptyLocaleRuns U_ICU_ENTRY_POINT_RENAME(pl_openEmptyLocaleRuns)\n#define pl_openEmptyValueRuns U_ICU_ENTRY_POINT_RENAME(pl_openEmptyValueRuns)\n#define pl_openFontRuns U_ICU_ENTRY_POINT_RENAME(pl_openFontRuns)\n#define pl_openLocaleRuns U_ICU_ENTRY_POINT_RENAME(pl_openLocaleRuns)\n#define pl_openValueRuns U_ICU_ENTRY_POINT_RENAME(pl_openValueRuns)\n#define pl_reflow U_ICU_ENTRY_POINT_RENAME(pl_reflow)\n#define pl_resetFontRuns U_ICU_ENTRY_POINT_RENAME(pl_resetFontRuns)\n#define pl_resetLocaleRuns U_ICU_ENTRY_POINT_RENAME(pl_resetLocaleRuns)\n#define pl_resetValueRuns U_ICU_ENTRY_POINT_RENAME(pl_resetValueRuns)\n#define res_countArrayItems U_ICU_ENTRY_POINT_RENAME(res_countArrayItems)\n#define res_findResource U_ICU_ENTRY_POINT_RENAME(res_findResource)\n#define res_getAlias U_ICU_ENTRY_POINT_RENAME(res_getAlias)\n#define res_getArrayItem U_ICU_ENTRY_POINT_RENAME(res_getArrayItem)\n#define res_getBinary U_ICU_ENTRY_POINT_RENAME(res_getBinary)\n#define res_getIntVector U_ICU_ENTRY_POINT_RENAME(res_getIntVector)\n#define res_getPublicType U_ICU_ENTRY_POINT_RENAME(res_getPublicType)\n#define res_getResource U_ICU_ENTRY_POINT_RENAME(res_getResource)\n#define res_getString U_ICU_ENTRY_POINT_RENAME(res_getString)\n#define res_getTableItemByIndex U_ICU_ENTRY_POINT_RENAME(res_getTableItemByIndex)\n#define res_getTableItemByKey U_ICU_ENTRY_POINT_RENAME(res_getTableItemByKey)\n#define res_load U_ICU_ENTRY_POINT_RENAME(res_load)\n#define res_read U_ICU_ENTRY_POINT_RENAME(res_read)\n#define res_unload U_ICU_ENTRY_POINT_RENAME(res_unload)\n#define u_UCharsToChars U_ICU_ENTRY_POINT_RENAME(u_UCharsToChars)\n#define u_austrcpy U_ICU_ENTRY_POINT_RENAME(u_austrcpy)\n#define u_austrncpy U_ICU_ENTRY_POINT_RENAME(u_austrncpy)\n#define u_caseInsensitivePrefixMatch U_ICU_ENTRY_POINT_RENAME(u_caseInsensitivePrefixMatch)\n#define u_catclose U_ICU_ENTRY_POINT_RENAME(u_catclose)\n#define u_catgets U_ICU_ENTRY_POINT_RENAME(u_catgets)\n#define u_catopen U_ICU_ENTRY_POINT_RENAME(u_catopen)\n#define u_charAge U_ICU_ENTRY_POINT_RENAME(u_charAge)\n#define u_charDigitValue U_ICU_ENTRY_POINT_RENAME(u_charDigitValue)\n#define u_charDirection U_ICU_ENTRY_POINT_RENAME(u_charDirection)\n#define u_charFromName U_ICU_ENTRY_POINT_RENAME(u_charFromName)\n#define u_charMirror U_ICU_ENTRY_POINT_RENAME(u_charMirror)\n#define u_charName U_ICU_ENTRY_POINT_RENAME(u_charName)\n#define u_charType U_ICU_ENTRY_POINT_RENAME(u_charType)\n#define u_charsToUChars U_ICU_ENTRY_POINT_RENAME(u_charsToUChars)\n#define u_cleanup U_ICU_ENTRY_POINT_RENAME(u_cleanup)\n#define u_countChar32 U_ICU_ENTRY_POINT_RENAME(u_countChar32)\n#define u_digit U_ICU_ENTRY_POINT_RENAME(u_digit)\n#define u_enumCharNames U_ICU_ENTRY_POINT_RENAME(u_enumCharNames)\n#define u_enumCharTypes U_ICU_ENTRY_POINT_RENAME(u_enumCharTypes)\n#define u_errorName U_ICU_ENTRY_POINT_RENAME(u_errorName)\n#define u_fadopt U_ICU_ENTRY_POINT_RENAME(u_fadopt)\n#define u_fclose U_ICU_ENTRY_POINT_RENAME(u_fclose)\n#define u_feof U_ICU_ENTRY_POINT_RENAME(u_feof)\n#define u_fflush U_ICU_ENTRY_POINT_RENAME(u_fflush)\n#define u_fgetConverter U_ICU_ENTRY_POINT_RENAME(u_fgetConverter)\n#define u_fgetNumberFormat U_ICU_ENTRY_POINT_RENAME(u_fgetNumberFormat)\n#define u_fgetc U_ICU_ENTRY_POINT_RENAME(u_fgetc)\n#define u_fgetcodepage U_ICU_ENTRY_POINT_RENAME(u_fgetcodepage)\n#define u_fgetcx U_ICU_ENTRY_POINT_RENAME(u_fgetcx)\n#define u_fgetfile U_ICU_ENTRY_POINT_RENAME(u_fgetfile)\n#define u_fgetlocale U_ICU_ENTRY_POINT_RENAME(u_fgetlocale)\n#define u_fgets U_ICU_ENTRY_POINT_RENAME(u_fgets)\n#define u_file_read U_ICU_ENTRY_POINT_RENAME(u_file_read)\n#define u_file_write U_ICU_ENTRY_POINT_RENAME(u_file_write)\n#define u_file_write_flush U_ICU_ENTRY_POINT_RENAME(u_file_write_flush)\n#define u_finit U_ICU_ENTRY_POINT_RENAME(u_finit)\n#define u_flushDefaultConverter U_ICU_ENTRY_POINT_RENAME(u_flushDefaultConverter)\n#define u_foldCase U_ICU_ENTRY_POINT_RENAME(u_foldCase)\n#define u_fopen U_ICU_ENTRY_POINT_RENAME(u_fopen)\n#define u_fopen_u U_ICU_ENTRY_POINT_RENAME(u_fopen_u)\n#define u_forDigit U_ICU_ENTRY_POINT_RENAME(u_forDigit)\n#define u_formatMessage U_ICU_ENTRY_POINT_RENAME(u_formatMessage)\n#define u_formatMessageWithError U_ICU_ENTRY_POINT_RENAME(u_formatMessageWithError)\n#define u_fprintf U_ICU_ENTRY_POINT_RENAME(u_fprintf)\n#define u_fprintf_u U_ICU_ENTRY_POINT_RENAME(u_fprintf_u)\n#define u_fputc U_ICU_ENTRY_POINT_RENAME(u_fputc)\n#define u_fputs U_ICU_ENTRY_POINT_RENAME(u_fputs)\n#define u_frewind U_ICU_ENTRY_POINT_RENAME(u_frewind)\n#define u_fscanf U_ICU_ENTRY_POINT_RENAME(u_fscanf)\n#define u_fscanf_u U_ICU_ENTRY_POINT_RENAME(u_fscanf_u)\n#define u_fsetcodepage U_ICU_ENTRY_POINT_RENAME(u_fsetcodepage)\n#define u_fsetlocale U_ICU_ENTRY_POINT_RENAME(u_fsetlocale)\n#define u_fsettransliterator U_ICU_ENTRY_POINT_RENAME(u_fsettransliterator)\n#define u_fstropen U_ICU_ENTRY_POINT_RENAME(u_fstropen)\n#define u_fungetc U_ICU_ENTRY_POINT_RENAME(u_fungetc)\n#define u_getBidiPairedBracket U_ICU_ENTRY_POINT_RENAME(u_getBidiPairedBracket)\n#define u_getCombiningClass U_ICU_ENTRY_POINT_RENAME(u_getCombiningClass)\n#define u_getDataDirectory U_ICU_ENTRY_POINT_RENAME(u_getDataDirectory)\n#define u_getDataVersion U_ICU_ENTRY_POINT_RENAME(u_getDataVersion)\n#define u_getDefaultConverter U_ICU_ENTRY_POINT_RENAME(u_getDefaultConverter)\n#define u_getFC_NFKC_Closure U_ICU_ENTRY_POINT_RENAME(u_getFC_NFKC_Closure)\n#define u_getISOComment U_ICU_ENTRY_POINT_RENAME(u_getISOComment)\n#define u_getIntPropertyMaxValue U_ICU_ENTRY_POINT_RENAME(u_getIntPropertyMaxValue)\n#define u_getIntPropertyMinValue U_ICU_ENTRY_POINT_RENAME(u_getIntPropertyMinValue)\n#define u_getIntPropertyValue U_ICU_ENTRY_POINT_RENAME(u_getIntPropertyValue)\n#define u_getMainProperties U_ICU_ENTRY_POINT_RENAME(u_getMainProperties)\n#define u_getNumericValue U_ICU_ENTRY_POINT_RENAME(u_getNumericValue)\n#define u_getPropertyEnum U_ICU_ENTRY_POINT_RENAME(u_getPropertyEnum)\n#define u_getPropertyName U_ICU_ENTRY_POINT_RENAME(u_getPropertyName)\n#define u_getPropertyValueEnum U_ICU_ENTRY_POINT_RENAME(u_getPropertyValueEnum)\n#define u_getPropertyValueName U_ICU_ENTRY_POINT_RENAME(u_getPropertyValueName)\n#define u_getTimeZoneFilesDirectory U_ICU_ENTRY_POINT_RENAME(u_getTimeZoneFilesDirectory)\n#define u_getUnicodeProperties U_ICU_ENTRY_POINT_RENAME(u_getUnicodeProperties)\n#define u_getUnicodeVersion U_ICU_ENTRY_POINT_RENAME(u_getUnicodeVersion)\n#define u_getVersion U_ICU_ENTRY_POINT_RENAME(u_getVersion)\n#define u_get_stdout U_ICU_ENTRY_POINT_RENAME(u_get_stdout)\n#define u_hasBinaryProperty U_ICU_ENTRY_POINT_RENAME(u_hasBinaryProperty)\n#define u_init U_ICU_ENTRY_POINT_RENAME(u_init)\n#define u_isIDIgnorable U_ICU_ENTRY_POINT_RENAME(u_isIDIgnorable)\n#define u_isIDPart U_ICU_ENTRY_POINT_RENAME(u_isIDPart)\n#define u_isIDStart U_ICU_ENTRY_POINT_RENAME(u_isIDStart)\n#define u_isISOControl U_ICU_ENTRY_POINT_RENAME(u_isISOControl)\n#define u_isJavaIDPart U_ICU_ENTRY_POINT_RENAME(u_isJavaIDPart)\n#define u_isJavaIDStart U_ICU_ENTRY_POINT_RENAME(u_isJavaIDStart)\n#define u_isJavaSpaceChar U_ICU_ENTRY_POINT_RENAME(u_isJavaSpaceChar)\n#define u_isMirrored U_ICU_ENTRY_POINT_RENAME(u_isMirrored)\n#define u_isUAlphabetic U_ICU_ENTRY_POINT_RENAME(u_isUAlphabetic)\n#define u_isULowercase U_ICU_ENTRY_POINT_RENAME(u_isULowercase)\n#define u_isUUppercase U_ICU_ENTRY_POINT_RENAME(u_isUUppercase)\n#define u_isUWhiteSpace U_ICU_ENTRY_POINT_RENAME(u_isUWhiteSpace)\n#define u_isWhitespace U_ICU_ENTRY_POINT_RENAME(u_isWhitespace)\n#define u_isalnum U_ICU_ENTRY_POINT_RENAME(u_isalnum)\n#define u_isalnumPOSIX U_ICU_ENTRY_POINT_RENAME(u_isalnumPOSIX)\n#define u_isalpha U_ICU_ENTRY_POINT_RENAME(u_isalpha)\n#define u_isbase U_ICU_ENTRY_POINT_RENAME(u_isbase)\n#define u_isblank U_ICU_ENTRY_POINT_RENAME(u_isblank)\n#define u_iscntrl U_ICU_ENTRY_POINT_RENAME(u_iscntrl)\n#define u_isdefined U_ICU_ENTRY_POINT_RENAME(u_isdefined)\n#define u_isdigit U_ICU_ENTRY_POINT_RENAME(u_isdigit)\n#define u_isgraph U_ICU_ENTRY_POINT_RENAME(u_isgraph)\n#define u_isgraphPOSIX U_ICU_ENTRY_POINT_RENAME(u_isgraphPOSIX)\n#define u_islower U_ICU_ENTRY_POINT_RENAME(u_islower)\n#define u_isprint U_ICU_ENTRY_POINT_RENAME(u_isprint)\n#define u_isprintPOSIX U_ICU_ENTRY_POINT_RENAME(u_isprintPOSIX)\n#define u_ispunct U_ICU_ENTRY_POINT_RENAME(u_ispunct)\n#define u_isspace U_ICU_ENTRY_POINT_RENAME(u_isspace)\n#define u_istitle U_ICU_ENTRY_POINT_RENAME(u_istitle)\n#define u_isupper U_ICU_ENTRY_POINT_RENAME(u_isupper)\n#define u_isxdigit U_ICU_ENTRY_POINT_RENAME(u_isxdigit)\n#define u_locbund_close U_ICU_ENTRY_POINT_RENAME(u_locbund_close)\n#define u_locbund_getNumberFormat U_ICU_ENTRY_POINT_RENAME(u_locbund_getNumberFormat)\n#define u_locbund_init U_ICU_ENTRY_POINT_RENAME(u_locbund_init)\n#define u_memcasecmp U_ICU_ENTRY_POINT_RENAME(u_memcasecmp)\n#define u_memchr U_ICU_ENTRY_POINT_RENAME(u_memchr)\n#define u_memchr32 U_ICU_ENTRY_POINT_RENAME(u_memchr32)\n#define u_memcmp U_ICU_ENTRY_POINT_RENAME(u_memcmp)\n#define u_memcmpCodePointOrder U_ICU_ENTRY_POINT_RENAME(u_memcmpCodePointOrder)\n#define u_memcpy U_ICU_ENTRY_POINT_RENAME(u_memcpy)\n#define u_memmove U_ICU_ENTRY_POINT_RENAME(u_memmove)\n#define u_memrchr U_ICU_ENTRY_POINT_RENAME(u_memrchr)\n#define u_memrchr32 U_ICU_ENTRY_POINT_RENAME(u_memrchr32)\n#define u_memset U_ICU_ENTRY_POINT_RENAME(u_memset)\n#define u_parseMessage U_ICU_ENTRY_POINT_RENAME(u_parseMessage)\n#define u_parseMessageWithError U_ICU_ENTRY_POINT_RENAME(u_parseMessageWithError)\n#define u_printf U_ICU_ENTRY_POINT_RENAME(u_printf)\n#define u_printf_parse U_ICU_ENTRY_POINT_RENAME(u_printf_parse)\n#define u_printf_u U_ICU_ENTRY_POINT_RENAME(u_printf_u)\n#define u_releaseDefaultConverter U_ICU_ENTRY_POINT_RENAME(u_releaseDefaultConverter)\n#define u_scanf_parse U_ICU_ENTRY_POINT_RENAME(u_scanf_parse)\n#define u_setAtomicIncDecFunctions U_ICU_ENTRY_POINT_RENAME(u_setAtomicIncDecFunctions)\n#define u_setDataDirectory U_ICU_ENTRY_POINT_RENAME(u_setDataDirectory)\n#define u_setMemoryFunctions U_ICU_ENTRY_POINT_RENAME(u_setMemoryFunctions)\n#define u_setMutexFunctions U_ICU_ENTRY_POINT_RENAME(u_setMutexFunctions)\n#define u_setTimeZoneFilesDirectory U_ICU_ENTRY_POINT_RENAME(u_setTimeZoneFilesDirectory)\n#define u_shapeArabic U_ICU_ENTRY_POINT_RENAME(u_shapeArabic)\n#define u_snprintf U_ICU_ENTRY_POINT_RENAME(u_snprintf)\n#define u_snprintf_u U_ICU_ENTRY_POINT_RENAME(u_snprintf_u)\n#define u_sprintf U_ICU_ENTRY_POINT_RENAME(u_sprintf)\n#define u_sprintf_u U_ICU_ENTRY_POINT_RENAME(u_sprintf_u)\n#define u_sscanf U_ICU_ENTRY_POINT_RENAME(u_sscanf)\n#define u_sscanf_u U_ICU_ENTRY_POINT_RENAME(u_sscanf_u)\n#define u_strCaseCompare U_ICU_ENTRY_POINT_RENAME(u_strCaseCompare)\n#define u_strCompare U_ICU_ENTRY_POINT_RENAME(u_strCompare)\n#define u_strCompareIter U_ICU_ENTRY_POINT_RENAME(u_strCompareIter)\n#define u_strFindFirst U_ICU_ENTRY_POINT_RENAME(u_strFindFirst)\n#define u_strFindLast U_ICU_ENTRY_POINT_RENAME(u_strFindLast)\n#define u_strFoldCase U_ICU_ENTRY_POINT_RENAME(u_strFoldCase)\n#define u_strFromJavaModifiedUTF8WithSub U_ICU_ENTRY_POINT_RENAME(u_strFromJavaModifiedUTF8WithSub)\n#define u_strFromPunycode U_ICU_ENTRY_POINT_RENAME(u_strFromPunycode)\n#define u_strFromUTF32 U_ICU_ENTRY_POINT_RENAME(u_strFromUTF32)\n#define u_strFromUTF32WithSub U_ICU_ENTRY_POINT_RENAME(u_strFromUTF32WithSub)\n#define u_strFromUTF8 U_ICU_ENTRY_POINT_RENAME(u_strFromUTF8)\n#define u_strFromUTF8Lenient U_ICU_ENTRY_POINT_RENAME(u_strFromUTF8Lenient)\n#define u_strFromUTF8WithSub U_ICU_ENTRY_POINT_RENAME(u_strFromUTF8WithSub)\n#define u_strFromWCS U_ICU_ENTRY_POINT_RENAME(u_strFromWCS)\n#define u_strHasMoreChar32Than U_ICU_ENTRY_POINT_RENAME(u_strHasMoreChar32Than)\n#define u_strToJavaModifiedUTF8 U_ICU_ENTRY_POINT_RENAME(u_strToJavaModifiedUTF8)\n#define u_strToLower U_ICU_ENTRY_POINT_RENAME(u_strToLower)\n#define u_strToPunycode U_ICU_ENTRY_POINT_RENAME(u_strToPunycode)\n#define u_strToTitle U_ICU_ENTRY_POINT_RENAME(u_strToTitle)\n#define u_strToUTF32 U_ICU_ENTRY_POINT_RENAME(u_strToUTF32)\n#define u_strToUTF32WithSub U_ICU_ENTRY_POINT_RENAME(u_strToUTF32WithSub)\n#define u_strToUTF8 U_ICU_ENTRY_POINT_RENAME(u_strToUTF8)\n#define u_strToUTF8WithSub U_ICU_ENTRY_POINT_RENAME(u_strToUTF8WithSub)\n#define u_strToUpper U_ICU_ENTRY_POINT_RENAME(u_strToUpper)\n#define u_strToWCS U_ICU_ENTRY_POINT_RENAME(u_strToWCS)\n#define u_strcasecmp U_ICU_ENTRY_POINT_RENAME(u_strcasecmp)\n#define u_strcat U_ICU_ENTRY_POINT_RENAME(u_strcat)\n#define u_strchr U_ICU_ENTRY_POINT_RENAME(u_strchr)\n#define u_strchr32 U_ICU_ENTRY_POINT_RENAME(u_strchr32)\n#define u_strcmp U_ICU_ENTRY_POINT_RENAME(u_strcmp)\n#define u_strcmpCodePointOrder U_ICU_ENTRY_POINT_RENAME(u_strcmpCodePointOrder)\n#define u_strcmpFold U_ICU_ENTRY_POINT_RENAME(u_strcmpFold)\n#define u_strcpy U_ICU_ENTRY_POINT_RENAME(u_strcpy)\n#define u_strcspn U_ICU_ENTRY_POINT_RENAME(u_strcspn)\n#define u_strlen U_ICU_ENTRY_POINT_RENAME(u_strlen)\n#define u_strncasecmp U_ICU_ENTRY_POINT_RENAME(u_strncasecmp)\n#define u_strncat U_ICU_ENTRY_POINT_RENAME(u_strncat)\n#define u_strncmp U_ICU_ENTRY_POINT_RENAME(u_strncmp)\n#define u_strncmpCodePointOrder U_ICU_ENTRY_POINT_RENAME(u_strncmpCodePointOrder)\n#define u_strncpy U_ICU_ENTRY_POINT_RENAME(u_strncpy)\n#define u_strpbrk U_ICU_ENTRY_POINT_RENAME(u_strpbrk)\n#define u_strrchr U_ICU_ENTRY_POINT_RENAME(u_strrchr)\n#define u_strrchr32 U_ICU_ENTRY_POINT_RENAME(u_strrchr32)\n#define u_strrstr U_ICU_ENTRY_POINT_RENAME(u_strrstr)\n#define u_strspn U_ICU_ENTRY_POINT_RENAME(u_strspn)\n#define u_strstr U_ICU_ENTRY_POINT_RENAME(u_strstr)\n#define u_strtok_r U_ICU_ENTRY_POINT_RENAME(u_strtok_r)\n#define u_terminateChars U_ICU_ENTRY_POINT_RENAME(u_terminateChars)\n#define u_terminateUChar32s U_ICU_ENTRY_POINT_RENAME(u_terminateUChar32s)\n#define u_terminateUChars U_ICU_ENTRY_POINT_RENAME(u_terminateUChars)\n#define u_terminateWChars U_ICU_ENTRY_POINT_RENAME(u_terminateWChars)\n#define u_tolower U_ICU_ENTRY_POINT_RENAME(u_tolower)\n#define u_totitle U_ICU_ENTRY_POINT_RENAME(u_totitle)\n#define u_toupper U_ICU_ENTRY_POINT_RENAME(u_toupper)\n#define u_uastrcpy U_ICU_ENTRY_POINT_RENAME(u_uastrcpy)\n#define u_uastrncpy U_ICU_ENTRY_POINT_RENAME(u_uastrncpy)\n#define u_unescape U_ICU_ENTRY_POINT_RENAME(u_unescape)\n#define u_unescapeAt U_ICU_ENTRY_POINT_RENAME(u_unescapeAt)\n#define u_versionFromString U_ICU_ENTRY_POINT_RENAME(u_versionFromString)\n#define u_versionFromUString U_ICU_ENTRY_POINT_RENAME(u_versionFromUString)\n#define u_versionToString U_ICU_ENTRY_POINT_RENAME(u_versionToString)\n#define u_vformatMessage U_ICU_ENTRY_POINT_RENAME(u_vformatMessage)\n#define u_vformatMessageWithError U_ICU_ENTRY_POINT_RENAME(u_vformatMessageWithError)\n#define u_vfprintf U_ICU_ENTRY_POINT_RENAME(u_vfprintf)\n#define u_vfprintf_u U_ICU_ENTRY_POINT_RENAME(u_vfprintf_u)\n#define u_vfscanf U_ICU_ENTRY_POINT_RENAME(u_vfscanf)\n#define u_vfscanf_u U_ICU_ENTRY_POINT_RENAME(u_vfscanf_u)\n#define u_vparseMessage U_ICU_ENTRY_POINT_RENAME(u_vparseMessage)\n#define u_vparseMessageWithError U_ICU_ENTRY_POINT_RENAME(u_vparseMessageWithError)\n#define u_vsnprintf U_ICU_ENTRY_POINT_RENAME(u_vsnprintf)\n#define u_vsnprintf_u U_ICU_ENTRY_POINT_RENAME(u_vsnprintf_u)\n#define u_vsprintf U_ICU_ENTRY_POINT_RENAME(u_vsprintf)\n#define u_vsprintf_u U_ICU_ENTRY_POINT_RENAME(u_vsprintf_u)\n#define u_vsscanf U_ICU_ENTRY_POINT_RENAME(u_vsscanf)\n#define u_vsscanf_u U_ICU_ENTRY_POINT_RENAME(u_vsscanf_u)\n#define u_writeIdenticalLevelRun U_ICU_ENTRY_POINT_RENAME(u_writeIdenticalLevelRun)\n#define ubidi_addPropertyStarts U_ICU_ENTRY_POINT_RENAME(ubidi_addPropertyStarts)\n#define ubidi_close U_ICU_ENTRY_POINT_RENAME(ubidi_close)\n#define ubidi_countParagraphs U_ICU_ENTRY_POINT_RENAME(ubidi_countParagraphs)\n#define ubidi_countRuns U_ICU_ENTRY_POINT_RENAME(ubidi_countRuns)\n#define ubidi_getBaseDirection U_ICU_ENTRY_POINT_RENAME(ubidi_getBaseDirection)\n#define ubidi_getClass U_ICU_ENTRY_POINT_RENAME(ubidi_getClass)\n#define ubidi_getClassCallback U_ICU_ENTRY_POINT_RENAME(ubidi_getClassCallback)\n#define ubidi_getCustomizedClass U_ICU_ENTRY_POINT_RENAME(ubidi_getCustomizedClass)\n#define ubidi_getDirection U_ICU_ENTRY_POINT_RENAME(ubidi_getDirection)\n#define ubidi_getJoiningGroup U_ICU_ENTRY_POINT_RENAME(ubidi_getJoiningGroup)\n#define ubidi_getJoiningType U_ICU_ENTRY_POINT_RENAME(ubidi_getJoiningType)\n#define ubidi_getLength U_ICU_ENTRY_POINT_RENAME(ubidi_getLength)\n#define ubidi_getLevelAt U_ICU_ENTRY_POINT_RENAME(ubidi_getLevelAt)\n#define ubidi_getLevels U_ICU_ENTRY_POINT_RENAME(ubidi_getLevels)\n#define ubidi_getLogicalIndex U_ICU_ENTRY_POINT_RENAME(ubidi_getLogicalIndex)\n#define ubidi_getLogicalMap U_ICU_ENTRY_POINT_RENAME(ubidi_getLogicalMap)\n#define ubidi_getLogicalRun U_ICU_ENTRY_POINT_RENAME(ubidi_getLogicalRun)\n#define ubidi_getMaxValue U_ICU_ENTRY_POINT_RENAME(ubidi_getMaxValue)\n#define ubidi_getMemory U_ICU_ENTRY_POINT_RENAME(ubidi_getMemory)\n#define ubidi_getMirror U_ICU_ENTRY_POINT_RENAME(ubidi_getMirror)\n#define ubidi_getPairedBracket U_ICU_ENTRY_POINT_RENAME(ubidi_getPairedBracket)\n#define ubidi_getPairedBracketType U_ICU_ENTRY_POINT_RENAME(ubidi_getPairedBracketType)\n#define ubidi_getParaLevel U_ICU_ENTRY_POINT_RENAME(ubidi_getParaLevel)\n#define ubidi_getParaLevelAtIndex U_ICU_ENTRY_POINT_RENAME(ubidi_getParaLevelAtIndex)\n#define ubidi_getParagraph U_ICU_ENTRY_POINT_RENAME(ubidi_getParagraph)\n#define ubidi_getParagraphByIndex U_ICU_ENTRY_POINT_RENAME(ubidi_getParagraphByIndex)\n#define ubidi_getProcessedLength U_ICU_ENTRY_POINT_RENAME(ubidi_getProcessedLength)\n#define ubidi_getReorderingMode U_ICU_ENTRY_POINT_RENAME(ubidi_getReorderingMode)\n#define ubidi_getReorderingOptions U_ICU_ENTRY_POINT_RENAME(ubidi_getReorderingOptions)\n#define ubidi_getResultLength U_ICU_ENTRY_POINT_RENAME(ubidi_getResultLength)\n#define ubidi_getRuns U_ICU_ENTRY_POINT_RENAME(ubidi_getRuns)\n#define ubidi_getSingleton U_ICU_ENTRY_POINT_RENAME(ubidi_getSingleton)\n#define ubidi_getText U_ICU_ENTRY_POINT_RENAME(ubidi_getText)\n#define ubidi_getVisualIndex U_ICU_ENTRY_POINT_RENAME(ubidi_getVisualIndex)\n#define ubidi_getVisualMap U_ICU_ENTRY_POINT_RENAME(ubidi_getVisualMap)\n#define ubidi_getVisualRun U_ICU_ENTRY_POINT_RENAME(ubidi_getVisualRun)\n#define ubidi_invertMap U_ICU_ENTRY_POINT_RENAME(ubidi_invertMap)\n#define ubidi_isBidiControl U_ICU_ENTRY_POINT_RENAME(ubidi_isBidiControl)\n#define ubidi_isInverse U_ICU_ENTRY_POINT_RENAME(ubidi_isInverse)\n#define ubidi_isJoinControl U_ICU_ENTRY_POINT_RENAME(ubidi_isJoinControl)\n#define ubidi_isMirrored U_ICU_ENTRY_POINT_RENAME(ubidi_isMirrored)\n#define ubidi_isOrderParagraphsLTR U_ICU_ENTRY_POINT_RENAME(ubidi_isOrderParagraphsLTR)\n#define ubidi_open U_ICU_ENTRY_POINT_RENAME(ubidi_open)\n#define ubidi_openSized U_ICU_ENTRY_POINT_RENAME(ubidi_openSized)\n#define ubidi_orderParagraphsLTR U_ICU_ENTRY_POINT_RENAME(ubidi_orderParagraphsLTR)\n#define ubidi_reorderLogical U_ICU_ENTRY_POINT_RENAME(ubidi_reorderLogical)\n#define ubidi_reorderVisual U_ICU_ENTRY_POINT_RENAME(ubidi_reorderVisual)\n#define ubidi_setClassCallback U_ICU_ENTRY_POINT_RENAME(ubidi_setClassCallback)\n#define ubidi_setContext U_ICU_ENTRY_POINT_RENAME(ubidi_setContext)\n#define ubidi_setInverse U_ICU_ENTRY_POINT_RENAME(ubidi_setInverse)\n#define ubidi_setLine U_ICU_ENTRY_POINT_RENAME(ubidi_setLine)\n#define ubidi_setPara U_ICU_ENTRY_POINT_RENAME(ubidi_setPara)\n#define ubidi_setReorderingMode U_ICU_ENTRY_POINT_RENAME(ubidi_setReorderingMode)\n#define ubidi_setReorderingOptions U_ICU_ENTRY_POINT_RENAME(ubidi_setReorderingOptions)\n#define ubidi_writeReordered U_ICU_ENTRY_POINT_RENAME(ubidi_writeReordered)\n#define ubidi_writeReverse U_ICU_ENTRY_POINT_RENAME(ubidi_writeReverse)\n#define ubiditransform_close U_ICU_ENTRY_POINT_RENAME(ubiditransform_close)\n#define ubiditransform_open U_ICU_ENTRY_POINT_RENAME(ubiditransform_open)\n#define ubiditransform_transform U_ICU_ENTRY_POINT_RENAME(ubiditransform_transform)\n#define ublock_getCode U_ICU_ENTRY_POINT_RENAME(ublock_getCode)\n#define ubrk_close U_ICU_ENTRY_POINT_RENAME(ubrk_close)\n#define ubrk_countAvailable U_ICU_ENTRY_POINT_RENAME(ubrk_countAvailable)\n#define ubrk_current U_ICU_ENTRY_POINT_RENAME(ubrk_current)\n#define ubrk_first U_ICU_ENTRY_POINT_RENAME(ubrk_first)\n#define ubrk_following U_ICU_ENTRY_POINT_RENAME(ubrk_following)\n#define ubrk_getAvailable U_ICU_ENTRY_POINT_RENAME(ubrk_getAvailable)\n#define ubrk_getBinaryRules U_ICU_ENTRY_POINT_RENAME(ubrk_getBinaryRules)\n#define ubrk_getLocaleByType U_ICU_ENTRY_POINT_RENAME(ubrk_getLocaleByType)\n#define ubrk_getRuleStatus U_ICU_ENTRY_POINT_RENAME(ubrk_getRuleStatus)\n#define ubrk_getRuleStatusVec U_ICU_ENTRY_POINT_RENAME(ubrk_getRuleStatusVec)\n#define ubrk_isBoundary U_ICU_ENTRY_POINT_RENAME(ubrk_isBoundary)\n#define ubrk_last U_ICU_ENTRY_POINT_RENAME(ubrk_last)\n#define ubrk_next U_ICU_ENTRY_POINT_RENAME(ubrk_next)\n#define ubrk_open U_ICU_ENTRY_POINT_RENAME(ubrk_open)\n#define ubrk_openBinaryRules U_ICU_ENTRY_POINT_RENAME(ubrk_openBinaryRules)\n#define ubrk_openRules U_ICU_ENTRY_POINT_RENAME(ubrk_openRules)\n#define ubrk_preceding U_ICU_ENTRY_POINT_RENAME(ubrk_preceding)\n#define ubrk_previous U_ICU_ENTRY_POINT_RENAME(ubrk_previous)\n#define ubrk_refreshUText U_ICU_ENTRY_POINT_RENAME(ubrk_refreshUText)\n#define ubrk_safeClone U_ICU_ENTRY_POINT_RENAME(ubrk_safeClone)\n#define ubrk_setText U_ICU_ENTRY_POINT_RENAME(ubrk_setText)\n#define ubrk_setUText U_ICU_ENTRY_POINT_RENAME(ubrk_setUText)\n#define ubrk_swap U_ICU_ENTRY_POINT_RENAME(ubrk_swap)\n#define ucache_compareKeys U_ICU_ENTRY_POINT_RENAME(ucache_compareKeys)\n#define ucache_deleteKey U_ICU_ENTRY_POINT_RENAME(ucache_deleteKey)\n#define ucache_hashKeys U_ICU_ENTRY_POINT_RENAME(ucache_hashKeys)\n#define ucal_add U_ICU_ENTRY_POINT_RENAME(ucal_add)\n#define ucal_clear U_ICU_ENTRY_POINT_RENAME(ucal_clear)\n#define ucal_clearField U_ICU_ENTRY_POINT_RENAME(ucal_clearField)\n#define ucal_clone U_ICU_ENTRY_POINT_RENAME(ucal_clone)\n#define ucal_close U_ICU_ENTRY_POINT_RENAME(ucal_close)\n#define ucal_countAvailable U_ICU_ENTRY_POINT_RENAME(ucal_countAvailable)\n#define ucal_equivalentTo U_ICU_ENTRY_POINT_RENAME(ucal_equivalentTo)\n#define ucal_get U_ICU_ENTRY_POINT_RENAME(ucal_get)\n#define ucal_getAttribute U_ICU_ENTRY_POINT_RENAME(ucal_getAttribute)\n#define ucal_getAvailable U_ICU_ENTRY_POINT_RENAME(ucal_getAvailable)\n#define ucal_getCanonicalTimeZoneID U_ICU_ENTRY_POINT_RENAME(ucal_getCanonicalTimeZoneID)\n#define ucal_getDSTSavings U_ICU_ENTRY_POINT_RENAME(ucal_getDSTSavings)\n#define ucal_getDayOfWeekType U_ICU_ENTRY_POINT_RENAME(ucal_getDayOfWeekType)\n#define ucal_getDefaultTimeZone U_ICU_ENTRY_POINT_RENAME(ucal_getDefaultTimeZone)\n#define ucal_getFieldDifference U_ICU_ENTRY_POINT_RENAME(ucal_getFieldDifference)\n#define ucal_getGregorianChange U_ICU_ENTRY_POINT_RENAME(ucal_getGregorianChange)\n#define ucal_getKeywordValuesForLocale U_ICU_ENTRY_POINT_RENAME(ucal_getKeywordValuesForLocale)\n#define ucal_getLimit U_ICU_ENTRY_POINT_RENAME(ucal_getLimit)\n#define ucal_getLocaleByType U_ICU_ENTRY_POINT_RENAME(ucal_getLocaleByType)\n#define ucal_getMillis U_ICU_ENTRY_POINT_RENAME(ucal_getMillis)\n#define ucal_getNow U_ICU_ENTRY_POINT_RENAME(ucal_getNow)\n#define ucal_getTZDataVersion U_ICU_ENTRY_POINT_RENAME(ucal_getTZDataVersion)\n#define ucal_getTimeZoneDisplayName U_ICU_ENTRY_POINT_RENAME(ucal_getTimeZoneDisplayName)\n#define ucal_getTimeZoneID U_ICU_ENTRY_POINT_RENAME(ucal_getTimeZoneID)\n#define ucal_getTimeZoneIDForWindowsID U_ICU_ENTRY_POINT_RENAME(ucal_getTimeZoneIDForWindowsID)\n#define ucal_getTimeZoneTransitionDate U_ICU_ENTRY_POINT_RENAME(ucal_getTimeZoneTransitionDate)\n#define ucal_getType U_ICU_ENTRY_POINT_RENAME(ucal_getType)\n#define ucal_getWeekendTransition U_ICU_ENTRY_POINT_RENAME(ucal_getWeekendTransition)\n#define ucal_getWindowsTimeZoneID U_ICU_ENTRY_POINT_RENAME(ucal_getWindowsTimeZoneID)\n#define ucal_inDaylightTime U_ICU_ENTRY_POINT_RENAME(ucal_inDaylightTime)\n#define ucal_isSet U_ICU_ENTRY_POINT_RENAME(ucal_isSet)\n#define ucal_isWeekend U_ICU_ENTRY_POINT_RENAME(ucal_isWeekend)\n#define ucal_open U_ICU_ENTRY_POINT_RENAME(ucal_open)\n#define ucal_openCountryTimeZones U_ICU_ENTRY_POINT_RENAME(ucal_openCountryTimeZones)\n#define ucal_openTimeZoneIDEnumeration U_ICU_ENTRY_POINT_RENAME(ucal_openTimeZoneIDEnumeration)\n#define ucal_openTimeZones U_ICU_ENTRY_POINT_RENAME(ucal_openTimeZones)\n#define ucal_roll U_ICU_ENTRY_POINT_RENAME(ucal_roll)\n#define ucal_set U_ICU_ENTRY_POINT_RENAME(ucal_set)\n#define ucal_setAttribute U_ICU_ENTRY_POINT_RENAME(ucal_setAttribute)\n#define ucal_setDate U_ICU_ENTRY_POINT_RENAME(ucal_setDate)\n#define ucal_setDateTime U_ICU_ENTRY_POINT_RENAME(ucal_setDateTime)\n#define ucal_setDefaultTimeZone U_ICU_ENTRY_POINT_RENAME(ucal_setDefaultTimeZone)\n#define ucal_setGregorianChange U_ICU_ENTRY_POINT_RENAME(ucal_setGregorianChange)\n#define ucal_setMillis U_ICU_ENTRY_POINT_RENAME(ucal_setMillis)\n#define ucal_setTimeZone U_ICU_ENTRY_POINT_RENAME(ucal_setTimeZone)\n#define ucase_addCaseClosure U_ICU_ENTRY_POINT_RENAME(ucase_addCaseClosure)\n#define ucase_addPropertyStarts U_ICU_ENTRY_POINT_RENAME(ucase_addPropertyStarts)\n#define ucase_addStringCaseClosure U_ICU_ENTRY_POINT_RENAME(ucase_addStringCaseClosure)\n#define ucase_fold U_ICU_ENTRY_POINT_RENAME(ucase_fold)\n#define ucase_getCaseLocale U_ICU_ENTRY_POINT_RENAME(ucase_getCaseLocale)\n#define ucase_getType U_ICU_ENTRY_POINT_RENAME(ucase_getType)\n#define ucase_getTypeOrIgnorable U_ICU_ENTRY_POINT_RENAME(ucase_getTypeOrIgnorable)\n#define ucase_hasBinaryProperty U_ICU_ENTRY_POINT_RENAME(ucase_hasBinaryProperty)\n#define ucase_isCaseSensitive U_ICU_ENTRY_POINT_RENAME(ucase_isCaseSensitive)\n#define ucase_isSoftDotted U_ICU_ENTRY_POINT_RENAME(ucase_isSoftDotted)\n#define ucase_toFullFolding U_ICU_ENTRY_POINT_RENAME(ucase_toFullFolding)\n#define ucase_toFullLower U_ICU_ENTRY_POINT_RENAME(ucase_toFullLower)\n#define ucase_toFullTitle U_ICU_ENTRY_POINT_RENAME(ucase_toFullTitle)\n#define ucase_toFullUpper U_ICU_ENTRY_POINT_RENAME(ucase_toFullUpper)\n#define ucase_tolower U_ICU_ENTRY_POINT_RENAME(ucase_tolower)\n#define ucase_totitle U_ICU_ENTRY_POINT_RENAME(ucase_totitle)\n#define ucase_toupper U_ICU_ENTRY_POINT_RENAME(ucase_toupper)\n#define ucasemap_close U_ICU_ENTRY_POINT_RENAME(ucasemap_close)\n#define ucasemap_getBreakIterator U_ICU_ENTRY_POINT_RENAME(ucasemap_getBreakIterator)\n#define ucasemap_getLocale U_ICU_ENTRY_POINT_RENAME(ucasemap_getLocale)\n#define ucasemap_getOptions U_ICU_ENTRY_POINT_RENAME(ucasemap_getOptions)\n#define ucasemap_internalUTF8ToTitle U_ICU_ENTRY_POINT_RENAME(ucasemap_internalUTF8ToTitle)\n#define ucasemap_mapUTF8 U_ICU_ENTRY_POINT_RENAME(ucasemap_mapUTF8)\n#define ucasemap_open U_ICU_ENTRY_POINT_RENAME(ucasemap_open)\n#define ucasemap_setBreakIterator U_ICU_ENTRY_POINT_RENAME(ucasemap_setBreakIterator)\n#define ucasemap_setLocale U_ICU_ENTRY_POINT_RENAME(ucasemap_setLocale)\n#define ucasemap_setOptions U_ICU_ENTRY_POINT_RENAME(ucasemap_setOptions)\n#define ucasemap_toTitle U_ICU_ENTRY_POINT_RENAME(ucasemap_toTitle)\n#define ucasemap_utf8FoldCase U_ICU_ENTRY_POINT_RENAME(ucasemap_utf8FoldCase)\n#define ucasemap_utf8ToLower U_ICU_ENTRY_POINT_RENAME(ucasemap_utf8ToLower)\n#define ucasemap_utf8ToTitle U_ICU_ENTRY_POINT_RENAME(ucasemap_utf8ToTitle)\n#define ucasemap_utf8ToUpper U_ICU_ENTRY_POINT_RENAME(ucasemap_utf8ToUpper)\n#define uchar_addPropertyStarts U_ICU_ENTRY_POINT_RENAME(uchar_addPropertyStarts)\n#define uchar_swapNames U_ICU_ENTRY_POINT_RENAME(uchar_swapNames)\n#define ucln_cleanupOne U_ICU_ENTRY_POINT_RENAME(ucln_cleanupOne)\n#define ucln_common_registerCleanup U_ICU_ENTRY_POINT_RENAME(ucln_common_registerCleanup)\n#define ucln_i18n_registerCleanup U_ICU_ENTRY_POINT_RENAME(ucln_i18n_registerCleanup)\n#define ucln_io_registerCleanup U_ICU_ENTRY_POINT_RENAME(ucln_io_registerCleanup)\n#define ucln_lib_cleanup U_ICU_ENTRY_POINT_RENAME(ucln_lib_cleanup)\n#define ucln_registerCleanup U_ICU_ENTRY_POINT_RENAME(ucln_registerCleanup)\n#define ucnv_MBCSFromUChar32 U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSFromUChar32)\n#define ucnv_MBCSFromUnicodeWithOffsets U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSFromUnicodeWithOffsets)\n#define ucnv_MBCSGetFilteredUnicodeSetForUnicode U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSGetFilteredUnicodeSetForUnicode)\n#define ucnv_MBCSGetType U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSGetType)\n#define ucnv_MBCSGetUnicodeSetForUnicode U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSGetUnicodeSetForUnicode)\n#define ucnv_MBCSIsLeadByte U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSIsLeadByte)\n#define ucnv_MBCSSimpleGetNextUChar U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSSimpleGetNextUChar)\n#define ucnv_MBCSToUnicodeWithOffsets U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSToUnicodeWithOffsets)\n#define ucnv_bld_countAvailableConverters U_ICU_ENTRY_POINT_RENAME(ucnv_bld_countAvailableConverters)\n#define ucnv_bld_getAvailableConverter U_ICU_ENTRY_POINT_RENAME(ucnv_bld_getAvailableConverter)\n#define ucnv_canCreateConverter U_ICU_ENTRY_POINT_RENAME(ucnv_canCreateConverter)\n#define ucnv_cbFromUWriteBytes U_ICU_ENTRY_POINT_RENAME(ucnv_cbFromUWriteBytes)\n#define ucnv_cbFromUWriteSub U_ICU_ENTRY_POINT_RENAME(ucnv_cbFromUWriteSub)\n#define ucnv_cbFromUWriteUChars U_ICU_ENTRY_POINT_RENAME(ucnv_cbFromUWriteUChars)\n#define ucnv_cbToUWriteSub U_ICU_ENTRY_POINT_RENAME(ucnv_cbToUWriteSub)\n#define ucnv_cbToUWriteUChars U_ICU_ENTRY_POINT_RENAME(ucnv_cbToUWriteUChars)\n#define ucnv_close U_ICU_ENTRY_POINT_RENAME(ucnv_close)\n#define ucnv_compareNames U_ICU_ENTRY_POINT_RENAME(ucnv_compareNames)\n#define ucnv_convert U_ICU_ENTRY_POINT_RENAME(ucnv_convert)\n#define ucnv_convertEx U_ICU_ENTRY_POINT_RENAME(ucnv_convertEx)\n#define ucnv_countAliases U_ICU_ENTRY_POINT_RENAME(ucnv_countAliases)\n#define ucnv_countAvailable U_ICU_ENTRY_POINT_RENAME(ucnv_countAvailable)\n#define ucnv_countStandards U_ICU_ENTRY_POINT_RENAME(ucnv_countStandards)\n#define ucnv_createAlgorithmicConverter U_ICU_ENTRY_POINT_RENAME(ucnv_createAlgorithmicConverter)\n#define ucnv_createConverter U_ICU_ENTRY_POINT_RENAME(ucnv_createConverter)\n#define ucnv_createConverterFromPackage U_ICU_ENTRY_POINT_RENAME(ucnv_createConverterFromPackage)\n#define ucnv_createConverterFromSharedData U_ICU_ENTRY_POINT_RENAME(ucnv_createConverterFromSharedData)\n#define ucnv_detectUnicodeSignature U_ICU_ENTRY_POINT_RENAME(ucnv_detectUnicodeSignature)\n#define ucnv_extContinueMatchFromU U_ICU_ENTRY_POINT_RENAME(ucnv_extContinueMatchFromU)\n#define ucnv_extContinueMatchToU U_ICU_ENTRY_POINT_RENAME(ucnv_extContinueMatchToU)\n#define ucnv_extGetUnicodeSet U_ICU_ENTRY_POINT_RENAME(ucnv_extGetUnicodeSet)\n#define ucnv_extInitialMatchFromU U_ICU_ENTRY_POINT_RENAME(ucnv_extInitialMatchFromU)\n#define ucnv_extInitialMatchToU U_ICU_ENTRY_POINT_RENAME(ucnv_extInitialMatchToU)\n#define ucnv_extSimpleMatchFromU U_ICU_ENTRY_POINT_RENAME(ucnv_extSimpleMatchFromU)\n#define ucnv_extSimpleMatchToU U_ICU_ENTRY_POINT_RENAME(ucnv_extSimpleMatchToU)\n#define ucnv_fixFileSeparator U_ICU_ENTRY_POINT_RENAME(ucnv_fixFileSeparator)\n#define ucnv_flushCache U_ICU_ENTRY_POINT_RENAME(ucnv_flushCache)\n#define ucnv_fromAlgorithmic U_ICU_ENTRY_POINT_RENAME(ucnv_fromAlgorithmic)\n#define ucnv_fromUChars U_ICU_ENTRY_POINT_RENAME(ucnv_fromUChars)\n#define ucnv_fromUCountPending U_ICU_ENTRY_POINT_RENAME(ucnv_fromUCountPending)\n#define ucnv_fromUWriteBytes U_ICU_ENTRY_POINT_RENAME(ucnv_fromUWriteBytes)\n#define ucnv_fromUnicode U_ICU_ENTRY_POINT_RENAME(ucnv_fromUnicode)\n#define ucnv_fromUnicode_UTF8 U_ICU_ENTRY_POINT_RENAME(ucnv_fromUnicode_UTF8)\n#define ucnv_fromUnicode_UTF8_OFFSETS_LOGIC U_ICU_ENTRY_POINT_RENAME(ucnv_fromUnicode_UTF8_OFFSETS_LOGIC)\n#define ucnv_getAlias U_ICU_ENTRY_POINT_RENAME(ucnv_getAlias)\n#define ucnv_getAliases U_ICU_ENTRY_POINT_RENAME(ucnv_getAliases)\n#define ucnv_getAvailableName U_ICU_ENTRY_POINT_RENAME(ucnv_getAvailableName)\n#define ucnv_getCCSID U_ICU_ENTRY_POINT_RENAME(ucnv_getCCSID)\n#define ucnv_getCanonicalName U_ICU_ENTRY_POINT_RENAME(ucnv_getCanonicalName)\n#define ucnv_getCompleteUnicodeSet U_ICU_ENTRY_POINT_RENAME(ucnv_getCompleteUnicodeSet)\n#define ucnv_getDefaultName U_ICU_ENTRY_POINT_RENAME(ucnv_getDefaultName)\n#define ucnv_getDisplayName U_ICU_ENTRY_POINT_RENAME(ucnv_getDisplayName)\n#define ucnv_getFromUCallBack U_ICU_ENTRY_POINT_RENAME(ucnv_getFromUCallBack)\n#define ucnv_getInvalidChars U_ICU_ENTRY_POINT_RENAME(ucnv_getInvalidChars)\n#define ucnv_getInvalidUChars U_ICU_ENTRY_POINT_RENAME(ucnv_getInvalidUChars)\n#define ucnv_getMaxCharSize U_ICU_ENTRY_POINT_RENAME(ucnv_getMaxCharSize)\n#define ucnv_getMinCharSize U_ICU_ENTRY_POINT_RENAME(ucnv_getMinCharSize)\n#define ucnv_getName U_ICU_ENTRY_POINT_RENAME(ucnv_getName)\n#define ucnv_getNextUChar U_ICU_ENTRY_POINT_RENAME(ucnv_getNextUChar)\n#define ucnv_getNonSurrogateUnicodeSet U_ICU_ENTRY_POINT_RENAME(ucnv_getNonSurrogateUnicodeSet)\n#define ucnv_getPlatform U_ICU_ENTRY_POINT_RENAME(ucnv_getPlatform)\n#define ucnv_getStandard U_ICU_ENTRY_POINT_RENAME(ucnv_getStandard)\n#define ucnv_getStandardName U_ICU_ENTRY_POINT_RENAME(ucnv_getStandardName)\n#define ucnv_getStarters U_ICU_ENTRY_POINT_RENAME(ucnv_getStarters)\n#define ucnv_getSubstChars U_ICU_ENTRY_POINT_RENAME(ucnv_getSubstChars)\n#define ucnv_getToUCallBack U_ICU_ENTRY_POINT_RENAME(ucnv_getToUCallBack)\n#define ucnv_getType U_ICU_ENTRY_POINT_RENAME(ucnv_getType)\n#define ucnv_getUnicodeSet U_ICU_ENTRY_POINT_RENAME(ucnv_getUnicodeSet)\n#define ucnv_incrementRefCount U_ICU_ENTRY_POINT_RENAME(ucnv_incrementRefCount)\n#define ucnv_io_countKnownConverters U_ICU_ENTRY_POINT_RENAME(ucnv_io_countKnownConverters)\n#define ucnv_io_getConverterName U_ICU_ENTRY_POINT_RENAME(ucnv_io_getConverterName)\n#define ucnv_io_stripASCIIForCompare U_ICU_ENTRY_POINT_RENAME(ucnv_io_stripASCIIForCompare)\n#define ucnv_io_stripEBCDICForCompare U_ICU_ENTRY_POINT_RENAME(ucnv_io_stripEBCDICForCompare)\n#define ucnv_isAmbiguous U_ICU_ENTRY_POINT_RENAME(ucnv_isAmbiguous)\n#define ucnv_isFixedWidth U_ICU_ENTRY_POINT_RENAME(ucnv_isFixedWidth)\n#define ucnv_load U_ICU_ENTRY_POINT_RENAME(ucnv_load)\n#define ucnv_loadSharedData U_ICU_ENTRY_POINT_RENAME(ucnv_loadSharedData)\n#define ucnv_open U_ICU_ENTRY_POINT_RENAME(ucnv_open)\n#define ucnv_openAllNames U_ICU_ENTRY_POINT_RENAME(ucnv_openAllNames)\n#define ucnv_openCCSID U_ICU_ENTRY_POINT_RENAME(ucnv_openCCSID)\n#define ucnv_openPackage U_ICU_ENTRY_POINT_RENAME(ucnv_openPackage)\n#define ucnv_openStandardNames U_ICU_ENTRY_POINT_RENAME(ucnv_openStandardNames)\n#define ucnv_openU U_ICU_ENTRY_POINT_RENAME(ucnv_openU)\n#define ucnv_reset U_ICU_ENTRY_POINT_RENAME(ucnv_reset)\n#define ucnv_resetFromUnicode U_ICU_ENTRY_POINT_RENAME(ucnv_resetFromUnicode)\n#define ucnv_resetToUnicode U_ICU_ENTRY_POINT_RENAME(ucnv_resetToUnicode)\n#define ucnv_safeClone U_ICU_ENTRY_POINT_RENAME(ucnv_safeClone)\n#define ucnv_setDefaultName U_ICU_ENTRY_POINT_RENAME(ucnv_setDefaultName)\n#define ucnv_setFallback U_ICU_ENTRY_POINT_RENAME(ucnv_setFallback)\n#define ucnv_setFromUCallBack U_ICU_ENTRY_POINT_RENAME(ucnv_setFromUCallBack)\n#define ucnv_setSubstChars U_ICU_ENTRY_POINT_RENAME(ucnv_setSubstChars)\n#define ucnv_setSubstString U_ICU_ENTRY_POINT_RENAME(ucnv_setSubstString)\n#define ucnv_setToUCallBack U_ICU_ENTRY_POINT_RENAME(ucnv_setToUCallBack)\n#define ucnv_swap U_ICU_ENTRY_POINT_RENAME(ucnv_swap)\n#define ucnv_swapAliases U_ICU_ENTRY_POINT_RENAME(ucnv_swapAliases)\n#define ucnv_toAlgorithmic U_ICU_ENTRY_POINT_RENAME(ucnv_toAlgorithmic)\n#define ucnv_toUChars U_ICU_ENTRY_POINT_RENAME(ucnv_toUChars)\n#define ucnv_toUCountPending U_ICU_ENTRY_POINT_RENAME(ucnv_toUCountPending)\n#define ucnv_toUWriteCodePoint U_ICU_ENTRY_POINT_RENAME(ucnv_toUWriteCodePoint)\n#define ucnv_toUWriteUChars U_ICU_ENTRY_POINT_RENAME(ucnv_toUWriteUChars)\n#define ucnv_toUnicode U_ICU_ENTRY_POINT_RENAME(ucnv_toUnicode)\n#define ucnv_unload U_ICU_ENTRY_POINT_RENAME(ucnv_unload)\n#define ucnv_unloadSharedDataIfReady U_ICU_ENTRY_POINT_RENAME(ucnv_unloadSharedDataIfReady)\n#define ucnv_usesFallback U_ICU_ENTRY_POINT_RENAME(ucnv_usesFallback)\n#define ucnvsel_close U_ICU_ENTRY_POINT_RENAME(ucnvsel_close)\n#define ucnvsel_open U_ICU_ENTRY_POINT_RENAME(ucnvsel_open)\n#define ucnvsel_openFromSerialized U_ICU_ENTRY_POINT_RENAME(ucnvsel_openFromSerialized)\n#define ucnvsel_selectForString U_ICU_ENTRY_POINT_RENAME(ucnvsel_selectForString)\n#define ucnvsel_selectForUTF8 U_ICU_ENTRY_POINT_RENAME(ucnvsel_selectForUTF8)\n#define ucnvsel_serialize U_ICU_ENTRY_POINT_RENAME(ucnvsel_serialize)\n#define ucol_cloneBinary U_ICU_ENTRY_POINT_RENAME(ucol_cloneBinary)\n#define ucol_close U_ICU_ENTRY_POINT_RENAME(ucol_close)\n#define ucol_closeElements U_ICU_ENTRY_POINT_RENAME(ucol_closeElements)\n#define ucol_countAvailable U_ICU_ENTRY_POINT_RENAME(ucol_countAvailable)\n#define ucol_equal U_ICU_ENTRY_POINT_RENAME(ucol_equal)\n#define ucol_equals U_ICU_ENTRY_POINT_RENAME(ucol_equals)\n#define ucol_getAttribute U_ICU_ENTRY_POINT_RENAME(ucol_getAttribute)\n#define ucol_getAvailable U_ICU_ENTRY_POINT_RENAME(ucol_getAvailable)\n#define ucol_getBound U_ICU_ENTRY_POINT_RENAME(ucol_getBound)\n#define ucol_getContractions U_ICU_ENTRY_POINT_RENAME(ucol_getContractions)\n#define ucol_getContractionsAndExpansions U_ICU_ENTRY_POINT_RENAME(ucol_getContractionsAndExpansions)\n#define ucol_getDisplayName U_ICU_ENTRY_POINT_RENAME(ucol_getDisplayName)\n#define ucol_getEquivalentReorderCodes U_ICU_ENTRY_POINT_RENAME(ucol_getEquivalentReorderCodes)\n#define ucol_getFunctionalEquivalent U_ICU_ENTRY_POINT_RENAME(ucol_getFunctionalEquivalent)\n#define ucol_getKeywordValues U_ICU_ENTRY_POINT_RENAME(ucol_getKeywordValues)\n#define ucol_getKeywordValuesForLocale U_ICU_ENTRY_POINT_RENAME(ucol_getKeywordValuesForLocale)\n#define ucol_getKeywords U_ICU_ENTRY_POINT_RENAME(ucol_getKeywords)\n#define ucol_getLocale U_ICU_ENTRY_POINT_RENAME(ucol_getLocale)\n#define ucol_getLocaleByType U_ICU_ENTRY_POINT_RENAME(ucol_getLocaleByType)\n#define ucol_getMaxExpansion U_ICU_ENTRY_POINT_RENAME(ucol_getMaxExpansion)\n#define ucol_getMaxVariable U_ICU_ENTRY_POINT_RENAME(ucol_getMaxVariable)\n#define ucol_getOffset U_ICU_ENTRY_POINT_RENAME(ucol_getOffset)\n#define ucol_getReorderCodes U_ICU_ENTRY_POINT_RENAME(ucol_getReorderCodes)\n#define ucol_getRules U_ICU_ENTRY_POINT_RENAME(ucol_getRules)\n#define ucol_getRulesEx U_ICU_ENTRY_POINT_RENAME(ucol_getRulesEx)\n#define ucol_getShortDefinitionString U_ICU_ENTRY_POINT_RENAME(ucol_getShortDefinitionString)\n#define ucol_getSortKey U_ICU_ENTRY_POINT_RENAME(ucol_getSortKey)\n#define ucol_getStrength U_ICU_ENTRY_POINT_RENAME(ucol_getStrength)\n#define ucol_getTailoredSet U_ICU_ENTRY_POINT_RENAME(ucol_getTailoredSet)\n#define ucol_getUCAVersion U_ICU_ENTRY_POINT_RENAME(ucol_getUCAVersion)\n#define ucol_getUnsafeSet U_ICU_ENTRY_POINT_RENAME(ucol_getUnsafeSet)\n#define ucol_getVariableTop U_ICU_ENTRY_POINT_RENAME(ucol_getVariableTop)\n#define ucol_getVersion U_ICU_ENTRY_POINT_RENAME(ucol_getVersion)\n#define ucol_greater U_ICU_ENTRY_POINT_RENAME(ucol_greater)\n#define ucol_greaterOrEqual U_ICU_ENTRY_POINT_RENAME(ucol_greaterOrEqual)\n#define ucol_keyHashCode U_ICU_ENTRY_POINT_RENAME(ucol_keyHashCode)\n#define ucol_looksLikeCollationBinary U_ICU_ENTRY_POINT_RENAME(ucol_looksLikeCollationBinary)\n#define ucol_mergeSortkeys U_ICU_ENTRY_POINT_RENAME(ucol_mergeSortkeys)\n#define ucol_next U_ICU_ENTRY_POINT_RENAME(ucol_next)\n#define ucol_nextSortKeyPart U_ICU_ENTRY_POINT_RENAME(ucol_nextSortKeyPart)\n#define ucol_normalizeShortDefinitionString U_ICU_ENTRY_POINT_RENAME(ucol_normalizeShortDefinitionString)\n#define ucol_open U_ICU_ENTRY_POINT_RENAME(ucol_open)\n#define ucol_openAvailableLocales U_ICU_ENTRY_POINT_RENAME(ucol_openAvailableLocales)\n#define ucol_openBinary U_ICU_ENTRY_POINT_RENAME(ucol_openBinary)\n#define ucol_openElements U_ICU_ENTRY_POINT_RENAME(ucol_openElements)\n#define ucol_openFromShortString U_ICU_ENTRY_POINT_RENAME(ucol_openFromShortString)\n#define ucol_openRules U_ICU_ENTRY_POINT_RENAME(ucol_openRules)\n#define ucol_prepareShortStringOpen U_ICU_ENTRY_POINT_RENAME(ucol_prepareShortStringOpen)\n#define ucol_previous U_ICU_ENTRY_POINT_RENAME(ucol_previous)\n#define ucol_primaryOrder U_ICU_ENTRY_POINT_RENAME(ucol_primaryOrder)\n#define ucol_reset U_ICU_ENTRY_POINT_RENAME(ucol_reset)\n#define ucol_restoreVariableTop U_ICU_ENTRY_POINT_RENAME(ucol_restoreVariableTop)\n#define ucol_safeClone U_ICU_ENTRY_POINT_RENAME(ucol_safeClone)\n#define ucol_secondaryOrder U_ICU_ENTRY_POINT_RENAME(ucol_secondaryOrder)\n#define ucol_setAttribute U_ICU_ENTRY_POINT_RENAME(ucol_setAttribute)\n#define ucol_setMaxVariable U_ICU_ENTRY_POINT_RENAME(ucol_setMaxVariable)\n#define ucol_setOffset U_ICU_ENTRY_POINT_RENAME(ucol_setOffset)\n#define ucol_setReorderCodes U_ICU_ENTRY_POINT_RENAME(ucol_setReorderCodes)\n#define ucol_setStrength U_ICU_ENTRY_POINT_RENAME(ucol_setStrength)\n#define ucol_setText U_ICU_ENTRY_POINT_RENAME(ucol_setText)\n#define ucol_setVariableTop U_ICU_ENTRY_POINT_RENAME(ucol_setVariableTop)\n#define ucol_strcoll U_ICU_ENTRY_POINT_RENAME(ucol_strcoll)\n#define ucol_strcollIter U_ICU_ENTRY_POINT_RENAME(ucol_strcollIter)\n#define ucol_strcollUTF8 U_ICU_ENTRY_POINT_RENAME(ucol_strcollUTF8)\n#define ucol_swap U_ICU_ENTRY_POINT_RENAME(ucol_swap)\n#define ucol_swapInverseUCA U_ICU_ENTRY_POINT_RENAME(ucol_swapInverseUCA)\n#define ucol_tertiaryOrder U_ICU_ENTRY_POINT_RENAME(ucol_tertiaryOrder)\n#define ucsdet_close U_ICU_ENTRY_POINT_RENAME(ucsdet_close)\n#define ucsdet_detect U_ICU_ENTRY_POINT_RENAME(ucsdet_detect)\n#define ucsdet_detectAll U_ICU_ENTRY_POINT_RENAME(ucsdet_detectAll)\n#define ucsdet_enableInputFilter U_ICU_ENTRY_POINT_RENAME(ucsdet_enableInputFilter)\n#define ucsdet_getAllDetectableCharsets U_ICU_ENTRY_POINT_RENAME(ucsdet_getAllDetectableCharsets)\n#define ucsdet_getConfidence U_ICU_ENTRY_POINT_RENAME(ucsdet_getConfidence)\n#define ucsdet_getDetectableCharsets U_ICU_ENTRY_POINT_RENAME(ucsdet_getDetectableCharsets)\n#define ucsdet_getLanguage U_ICU_ENTRY_POINT_RENAME(ucsdet_getLanguage)\n#define ucsdet_getName U_ICU_ENTRY_POINT_RENAME(ucsdet_getName)\n#define ucsdet_getUChars U_ICU_ENTRY_POINT_RENAME(ucsdet_getUChars)\n#define ucsdet_isInputFilterEnabled U_ICU_ENTRY_POINT_RENAME(ucsdet_isInputFilterEnabled)\n#define ucsdet_open U_ICU_ENTRY_POINT_RENAME(ucsdet_open)\n#define ucsdet_setDeclaredEncoding U_ICU_ENTRY_POINT_RENAME(ucsdet_setDeclaredEncoding)\n#define ucsdet_setDetectableCharset U_ICU_ENTRY_POINT_RENAME(ucsdet_setDetectableCharset)\n#define ucsdet_setText U_ICU_ENTRY_POINT_RENAME(ucsdet_setText)\n#define ucurr_countCurrencies U_ICU_ENTRY_POINT_RENAME(ucurr_countCurrencies)\n#define ucurr_forLocale U_ICU_ENTRY_POINT_RENAME(ucurr_forLocale)\n#define ucurr_forLocaleAndDate U_ICU_ENTRY_POINT_RENAME(ucurr_forLocaleAndDate)\n#define ucurr_getDefaultFractionDigits U_ICU_ENTRY_POINT_RENAME(ucurr_getDefaultFractionDigits)\n#define ucurr_getDefaultFractionDigitsForUsage U_ICU_ENTRY_POINT_RENAME(ucurr_getDefaultFractionDigitsForUsage)\n#define ucurr_getKeywordValuesForLocale U_ICU_ENTRY_POINT_RENAME(ucurr_getKeywordValuesForLocale)\n#define ucurr_getName U_ICU_ENTRY_POINT_RENAME(ucurr_getName)\n#define ucurr_getNumericCode U_ICU_ENTRY_POINT_RENAME(ucurr_getNumericCode)\n#define ucurr_getPluralName U_ICU_ENTRY_POINT_RENAME(ucurr_getPluralName)\n#define ucurr_getRoundingIncrement U_ICU_ENTRY_POINT_RENAME(ucurr_getRoundingIncrement)\n#define ucurr_getRoundingIncrementForUsage U_ICU_ENTRY_POINT_RENAME(ucurr_getRoundingIncrementForUsage)\n#define ucurr_isAvailable U_ICU_ENTRY_POINT_RENAME(ucurr_isAvailable)\n#define ucurr_openISOCurrencies U_ICU_ENTRY_POINT_RENAME(ucurr_openISOCurrencies)\n#define ucurr_register U_ICU_ENTRY_POINT_RENAME(ucurr_register)\n#define ucurr_unregister U_ICU_ENTRY_POINT_RENAME(ucurr_unregister)\n#define udat_adoptNumberFormat U_ICU_ENTRY_POINT_RENAME(udat_adoptNumberFormat)\n#define udat_adoptNumberFormatForFields U_ICU_ENTRY_POINT_RENAME(udat_adoptNumberFormatForFields)\n#define udat_applyPattern U_ICU_ENTRY_POINT_RENAME(udat_applyPattern)\n#define udat_applyPatternRelative U_ICU_ENTRY_POINT_RENAME(udat_applyPatternRelative)\n#define udat_clone U_ICU_ENTRY_POINT_RENAME(udat_clone)\n#define udat_close U_ICU_ENTRY_POINT_RENAME(udat_close)\n#define udat_countAvailable U_ICU_ENTRY_POINT_RENAME(udat_countAvailable)\n#define udat_countSymbols U_ICU_ENTRY_POINT_RENAME(udat_countSymbols)\n#define udat_format U_ICU_ENTRY_POINT_RENAME(udat_format)\n#define udat_formatCalendar U_ICU_ENTRY_POINT_RENAME(udat_formatCalendar)\n#define udat_formatCalendarForFields U_ICU_ENTRY_POINT_RENAME(udat_formatCalendarForFields)\n#define udat_formatForFields U_ICU_ENTRY_POINT_RENAME(udat_formatForFields)\n#define udat_get2DigitYearStart U_ICU_ENTRY_POINT_RENAME(udat_get2DigitYearStart)\n#define udat_getAvailable U_ICU_ENTRY_POINT_RENAME(udat_getAvailable)\n#define udat_getBooleanAttribute U_ICU_ENTRY_POINT_RENAME(udat_getBooleanAttribute)\n#define udat_getCalendar U_ICU_ENTRY_POINT_RENAME(udat_getCalendar)\n#define udat_getContext U_ICU_ENTRY_POINT_RENAME(udat_getContext)\n#define udat_getLocaleByType U_ICU_ENTRY_POINT_RENAME(udat_getLocaleByType)\n#define udat_getNumberFormat U_ICU_ENTRY_POINT_RENAME(udat_getNumberFormat)\n#define udat_getNumberFormatForField U_ICU_ENTRY_POINT_RENAME(udat_getNumberFormatForField)\n#define udat_getSymbols U_ICU_ENTRY_POINT_RENAME(udat_getSymbols)\n#define udat_isLenient U_ICU_ENTRY_POINT_RENAME(udat_isLenient)\n#define udat_open U_ICU_ENTRY_POINT_RENAME(udat_open)\n#define udat_parse U_ICU_ENTRY_POINT_RENAME(udat_parse)\n#define udat_parseCalendar U_ICU_ENTRY_POINT_RENAME(udat_parseCalendar)\n#define udat_registerOpener U_ICU_ENTRY_POINT_RENAME(udat_registerOpener)\n#define udat_set2DigitYearStart U_ICU_ENTRY_POINT_RENAME(udat_set2DigitYearStart)\n#define udat_setBooleanAttribute U_ICU_ENTRY_POINT_RENAME(udat_setBooleanAttribute)\n#define udat_setCalendar U_ICU_ENTRY_POINT_RENAME(udat_setCalendar)\n#define udat_setContext U_ICU_ENTRY_POINT_RENAME(udat_setContext)\n#define udat_setLenient U_ICU_ENTRY_POINT_RENAME(udat_setLenient)\n#define udat_setNumberFormat U_ICU_ENTRY_POINT_RENAME(udat_setNumberFormat)\n#define udat_setSymbols U_ICU_ENTRY_POINT_RENAME(udat_setSymbols)\n#define udat_toCalendarDateField U_ICU_ENTRY_POINT_RENAME(udat_toCalendarDateField)\n#define udat_toPattern U_ICU_ENTRY_POINT_RENAME(udat_toPattern)\n#define udat_toPatternRelativeDate U_ICU_ENTRY_POINT_RENAME(udat_toPatternRelativeDate)\n#define udat_toPatternRelativeTime U_ICU_ENTRY_POINT_RENAME(udat_toPatternRelativeTime)\n#define udat_unregisterOpener U_ICU_ENTRY_POINT_RENAME(udat_unregisterOpener)\n#define udata_checkCommonData U_ICU_ENTRY_POINT_RENAME(udata_checkCommonData)\n#define udata_close U_ICU_ENTRY_POINT_RENAME(udata_close)\n#define udata_closeSwapper U_ICU_ENTRY_POINT_RENAME(udata_closeSwapper)\n#define udata_getHeaderSize U_ICU_ENTRY_POINT_RENAME(udata_getHeaderSize)\n#define udata_getInfo U_ICU_ENTRY_POINT_RENAME(udata_getInfo)\n#define udata_getInfoSize U_ICU_ENTRY_POINT_RENAME(udata_getInfoSize)\n#define udata_getLength U_ICU_ENTRY_POINT_RENAME(udata_getLength)\n#define udata_getMemory U_ICU_ENTRY_POINT_RENAME(udata_getMemory)\n#define udata_getRawMemory U_ICU_ENTRY_POINT_RENAME(udata_getRawMemory)\n#define udata_open U_ICU_ENTRY_POINT_RENAME(udata_open)\n#define udata_openChoice U_ICU_ENTRY_POINT_RENAME(udata_openChoice)\n#define udata_openSwapper U_ICU_ENTRY_POINT_RENAME(udata_openSwapper)\n#define udata_openSwapperForInputData U_ICU_ENTRY_POINT_RENAME(udata_openSwapperForInputData)\n#define udata_printError U_ICU_ENTRY_POINT_RENAME(udata_printError)\n#define udata_readInt16 U_ICU_ENTRY_POINT_RENAME(udata_readInt16)\n#define udata_readInt32 U_ICU_ENTRY_POINT_RENAME(udata_readInt32)\n#define udata_setAppData U_ICU_ENTRY_POINT_RENAME(udata_setAppData)\n#define udata_setCommonData U_ICU_ENTRY_POINT_RENAME(udata_setCommonData)\n#define udata_setFileAccess U_ICU_ENTRY_POINT_RENAME(udata_setFileAccess)\n#define udata_swapDataHeader U_ICU_ENTRY_POINT_RENAME(udata_swapDataHeader)\n#define udata_swapInvStringBlock U_ICU_ENTRY_POINT_RENAME(udata_swapInvStringBlock)\n#define udatpg_addPattern U_ICU_ENTRY_POINT_RENAME(udatpg_addPattern)\n#define udatpg_clone U_ICU_ENTRY_POINT_RENAME(udatpg_clone)\n#define udatpg_close U_ICU_ENTRY_POINT_RENAME(udatpg_close)\n#define udatpg_getAppendItemFormat U_ICU_ENTRY_POINT_RENAME(udatpg_getAppendItemFormat)\n#define udatpg_getAppendItemName U_ICU_ENTRY_POINT_RENAME(udatpg_getAppendItemName)\n#define udatpg_getBaseSkeleton U_ICU_ENTRY_POINT_RENAME(udatpg_getBaseSkeleton)\n#define udatpg_getBestPattern U_ICU_ENTRY_POINT_RENAME(udatpg_getBestPattern)\n#define udatpg_getBestPatternWithOptions U_ICU_ENTRY_POINT_RENAME(udatpg_getBestPatternWithOptions)\n#define udatpg_getDateTimeFormat U_ICU_ENTRY_POINT_RENAME(udatpg_getDateTimeFormat)\n#define udatpg_getDecimal U_ICU_ENTRY_POINT_RENAME(udatpg_getDecimal)\n#define udatpg_getPatternForSkeleton U_ICU_ENTRY_POINT_RENAME(udatpg_getPatternForSkeleton)\n#define udatpg_getSkeleton U_ICU_ENTRY_POINT_RENAME(udatpg_getSkeleton)\n#define udatpg_open U_ICU_ENTRY_POINT_RENAME(udatpg_open)\n#define udatpg_openBaseSkeletons U_ICU_ENTRY_POINT_RENAME(udatpg_openBaseSkeletons)\n#define udatpg_openEmpty U_ICU_ENTRY_POINT_RENAME(udatpg_openEmpty)\n#define udatpg_openSkeletons U_ICU_ENTRY_POINT_RENAME(udatpg_openSkeletons)\n#define udatpg_replaceFieldTypes U_ICU_ENTRY_POINT_RENAME(udatpg_replaceFieldTypes)\n#define udatpg_replaceFieldTypesWithOptions U_ICU_ENTRY_POINT_RENAME(udatpg_replaceFieldTypesWithOptions)\n#define udatpg_setAppendItemFormat U_ICU_ENTRY_POINT_RENAME(udatpg_setAppendItemFormat)\n#define udatpg_setAppendItemName U_ICU_ENTRY_POINT_RENAME(udatpg_setAppendItemName)\n#define udatpg_setDateTimeFormat U_ICU_ENTRY_POINT_RENAME(udatpg_setDateTimeFormat)\n#define udatpg_setDecimal U_ICU_ENTRY_POINT_RENAME(udatpg_setDecimal)\n#define udict_swap U_ICU_ENTRY_POINT_RENAME(udict_swap)\n#define udtitvfmt_close U_ICU_ENTRY_POINT_RENAME(udtitvfmt_close)\n#define udtitvfmt_format U_ICU_ENTRY_POINT_RENAME(udtitvfmt_format)\n#define udtitvfmt_open U_ICU_ENTRY_POINT_RENAME(udtitvfmt_open)\n#define uenum_close U_ICU_ENTRY_POINT_RENAME(uenum_close)\n#define uenum_count U_ICU_ENTRY_POINT_RENAME(uenum_count)\n#define uenum_next U_ICU_ENTRY_POINT_RENAME(uenum_next)\n#define uenum_nextDefault U_ICU_ENTRY_POINT_RENAME(uenum_nextDefault)\n#define uenum_openCharStringsEnumeration U_ICU_ENTRY_POINT_RENAME(uenum_openCharStringsEnumeration)\n#define uenum_openFromStringEnumeration U_ICU_ENTRY_POINT_RENAME(uenum_openFromStringEnumeration)\n#define uenum_openUCharStringsEnumeration U_ICU_ENTRY_POINT_RENAME(uenum_openUCharStringsEnumeration)\n#define uenum_reset U_ICU_ENTRY_POINT_RENAME(uenum_reset)\n#define uenum_unext U_ICU_ENTRY_POINT_RENAME(uenum_unext)\n#define uenum_unextDefault U_ICU_ENTRY_POINT_RENAME(uenum_unextDefault)\n#define ufieldpositer_close U_ICU_ENTRY_POINT_RENAME(ufieldpositer_close)\n#define ufieldpositer_next U_ICU_ENTRY_POINT_RENAME(ufieldpositer_next)\n#define ufieldpositer_open U_ICU_ENTRY_POINT_RENAME(ufieldpositer_open)\n#define ufile_close_translit U_ICU_ENTRY_POINT_RENAME(ufile_close_translit)\n#define ufile_fill_uchar_buffer U_ICU_ENTRY_POINT_RENAME(ufile_fill_uchar_buffer)\n#define ufile_flush_io U_ICU_ENTRY_POINT_RENAME(ufile_flush_io)\n#define ufile_flush_translit U_ICU_ENTRY_POINT_RENAME(ufile_flush_translit)\n#define ufile_getch U_ICU_ENTRY_POINT_RENAME(ufile_getch)\n#define ufile_getch32 U_ICU_ENTRY_POINT_RENAME(ufile_getch32)\n#define ufmt_64tou U_ICU_ENTRY_POINT_RENAME(ufmt_64tou)\n#define ufmt_close U_ICU_ENTRY_POINT_RENAME(ufmt_close)\n#define ufmt_defaultCPToUnicode U_ICU_ENTRY_POINT_RENAME(ufmt_defaultCPToUnicode)\n#define ufmt_digitvalue U_ICU_ENTRY_POINT_RENAME(ufmt_digitvalue)\n#define ufmt_getArrayItemByIndex U_ICU_ENTRY_POINT_RENAME(ufmt_getArrayItemByIndex)\n#define ufmt_getArrayLength U_ICU_ENTRY_POINT_RENAME(ufmt_getArrayLength)\n#define ufmt_getDate U_ICU_ENTRY_POINT_RENAME(ufmt_getDate)\n#define ufmt_getDecNumChars U_ICU_ENTRY_POINT_RENAME(ufmt_getDecNumChars)\n#define ufmt_getDouble U_ICU_ENTRY_POINT_RENAME(ufmt_getDouble)\n#define ufmt_getInt64 U_ICU_ENTRY_POINT_RENAME(ufmt_getInt64)\n#define ufmt_getLong U_ICU_ENTRY_POINT_RENAME(ufmt_getLong)\n#define ufmt_getObject U_ICU_ENTRY_POINT_RENAME(ufmt_getObject)\n#define ufmt_getType U_ICU_ENTRY_POINT_RENAME(ufmt_getType)\n#define ufmt_getUChars U_ICU_ENTRY_POINT_RENAME(ufmt_getUChars)\n#define ufmt_isNumeric U_ICU_ENTRY_POINT_RENAME(ufmt_isNumeric)\n#define ufmt_isdigit U_ICU_ENTRY_POINT_RENAME(ufmt_isdigit)\n#define ufmt_open U_ICU_ENTRY_POINT_RENAME(ufmt_open)\n#define ufmt_ptou U_ICU_ENTRY_POINT_RENAME(ufmt_ptou)\n#define ufmt_uto64 U_ICU_ENTRY_POINT_RENAME(ufmt_uto64)\n#define ufmt_utop U_ICU_ENTRY_POINT_RENAME(ufmt_utop)\n#define ugender_getInstance U_ICU_ENTRY_POINT_RENAME(ugender_getInstance)\n#define ugender_getListGender U_ICU_ENTRY_POINT_RENAME(ugender_getListGender)\n#define uhash_close U_ICU_ENTRY_POINT_RENAME(uhash_close)\n#define uhash_compareCaselessUnicodeString U_ICU_ENTRY_POINT_RENAME(uhash_compareCaselessUnicodeString)\n#define uhash_compareChars U_ICU_ENTRY_POINT_RENAME(uhash_compareChars)\n#define uhash_compareIChars U_ICU_ENTRY_POINT_RENAME(uhash_compareIChars)\n#define uhash_compareLong U_ICU_ENTRY_POINT_RENAME(uhash_compareLong)\n#define uhash_compareScriptSet U_ICU_ENTRY_POINT_RENAME(uhash_compareScriptSet)\n#define uhash_compareUChars U_ICU_ENTRY_POINT_RENAME(uhash_compareUChars)\n#define uhash_compareUnicodeString U_ICU_ENTRY_POINT_RENAME(uhash_compareUnicodeString)\n#define uhash_count U_ICU_ENTRY_POINT_RENAME(uhash_count)\n#define uhash_deleteHashtable U_ICU_ENTRY_POINT_RENAME(uhash_deleteHashtable)\n#define uhash_deleteScriptSet U_ICU_ENTRY_POINT_RENAME(uhash_deleteScriptSet)\n#define uhash_equals U_ICU_ENTRY_POINT_RENAME(uhash_equals)\n#define uhash_equalsScriptSet U_ICU_ENTRY_POINT_RENAME(uhash_equalsScriptSet)\n#define uhash_find U_ICU_ENTRY_POINT_RENAME(uhash_find)\n#define uhash_get U_ICU_ENTRY_POINT_RENAME(uhash_get)\n#define uhash_geti U_ICU_ENTRY_POINT_RENAME(uhash_geti)\n#define uhash_hashCaselessUnicodeString U_ICU_ENTRY_POINT_RENAME(uhash_hashCaselessUnicodeString)\n#define uhash_hashChars U_ICU_ENTRY_POINT_RENAME(uhash_hashChars)\n#define uhash_hashIChars U_ICU_ENTRY_POINT_RENAME(uhash_hashIChars)\n#define uhash_hashLong U_ICU_ENTRY_POINT_RENAME(uhash_hashLong)\n#define uhash_hashScriptSet U_ICU_ENTRY_POINT_RENAME(uhash_hashScriptSet)\n#define uhash_hashUChars U_ICU_ENTRY_POINT_RENAME(uhash_hashUChars)\n#define uhash_hashUnicodeString U_ICU_ENTRY_POINT_RENAME(uhash_hashUnicodeString)\n#define uhash_iget U_ICU_ENTRY_POINT_RENAME(uhash_iget)\n#define uhash_igeti U_ICU_ENTRY_POINT_RENAME(uhash_igeti)\n#define uhash_init U_ICU_ENTRY_POINT_RENAME(uhash_init)\n#define uhash_iput U_ICU_ENTRY_POINT_RENAME(uhash_iput)\n#define uhash_iputi U_ICU_ENTRY_POINT_RENAME(uhash_iputi)\n#define uhash_iremove U_ICU_ENTRY_POINT_RENAME(uhash_iremove)\n#define uhash_iremovei U_ICU_ENTRY_POINT_RENAME(uhash_iremovei)\n#define uhash_nextElement U_ICU_ENTRY_POINT_RENAME(uhash_nextElement)\n#define uhash_open U_ICU_ENTRY_POINT_RENAME(uhash_open)\n#define uhash_openSize U_ICU_ENTRY_POINT_RENAME(uhash_openSize)\n#define uhash_put U_ICU_ENTRY_POINT_RENAME(uhash_put)\n#define uhash_puti U_ICU_ENTRY_POINT_RENAME(uhash_puti)\n#define uhash_remove U_ICU_ENTRY_POINT_RENAME(uhash_remove)\n#define uhash_removeAll U_ICU_ENTRY_POINT_RENAME(uhash_removeAll)\n#define uhash_removeElement U_ICU_ENTRY_POINT_RENAME(uhash_removeElement)\n#define uhash_removei U_ICU_ENTRY_POINT_RENAME(uhash_removei)\n#define uhash_setKeyComparator U_ICU_ENTRY_POINT_RENAME(uhash_setKeyComparator)\n#define uhash_setKeyDeleter U_ICU_ENTRY_POINT_RENAME(uhash_setKeyDeleter)\n#define uhash_setKeyHasher U_ICU_ENTRY_POINT_RENAME(uhash_setKeyHasher)\n#define uhash_setResizePolicy U_ICU_ENTRY_POINT_RENAME(uhash_setResizePolicy)\n#define uhash_setValueComparator U_ICU_ENTRY_POINT_RENAME(uhash_setValueComparator)\n#define uhash_setValueDeleter U_ICU_ENTRY_POINT_RENAME(uhash_setValueDeleter)\n#define uidna_IDNToASCII U_ICU_ENTRY_POINT_RENAME(uidna_IDNToASCII)\n#define uidna_IDNToUnicode U_ICU_ENTRY_POINT_RENAME(uidna_IDNToUnicode)\n#define uidna_close U_ICU_ENTRY_POINT_RENAME(uidna_close)\n#define uidna_compare U_ICU_ENTRY_POINT_RENAME(uidna_compare)\n#define uidna_labelToASCII U_ICU_ENTRY_POINT_RENAME(uidna_labelToASCII)\n#define uidna_labelToASCII_UTF8 U_ICU_ENTRY_POINT_RENAME(uidna_labelToASCII_UTF8)\n#define uidna_labelToUnicode U_ICU_ENTRY_POINT_RENAME(uidna_labelToUnicode)\n#define uidna_labelToUnicodeUTF8 U_ICU_ENTRY_POINT_RENAME(uidna_labelToUnicodeUTF8)\n#define uidna_nameToASCII U_ICU_ENTRY_POINT_RENAME(uidna_nameToASCII)\n#define uidna_nameToASCII_UTF8 U_ICU_ENTRY_POINT_RENAME(uidna_nameToASCII_UTF8)\n#define uidna_nameToUnicode U_ICU_ENTRY_POINT_RENAME(uidna_nameToUnicode)\n#define uidna_nameToUnicodeUTF8 U_ICU_ENTRY_POINT_RENAME(uidna_nameToUnicodeUTF8)\n#define uidna_openUTS46 U_ICU_ENTRY_POINT_RENAME(uidna_openUTS46)\n#define uidna_toASCII U_ICU_ENTRY_POINT_RENAME(uidna_toASCII)\n#define uidna_toUnicode U_ICU_ENTRY_POINT_RENAME(uidna_toUnicode)\n#define uiter_current32 U_ICU_ENTRY_POINT_RENAME(uiter_current32)\n#define uiter_getState U_ICU_ENTRY_POINT_RENAME(uiter_getState)\n#define uiter_next32 U_ICU_ENTRY_POINT_RENAME(uiter_next32)\n#define uiter_previous32 U_ICU_ENTRY_POINT_RENAME(uiter_previous32)\n#define uiter_setCharacterIterator U_ICU_ENTRY_POINT_RENAME(uiter_setCharacterIterator)\n#define uiter_setReplaceable U_ICU_ENTRY_POINT_RENAME(uiter_setReplaceable)\n#define uiter_setState U_ICU_ENTRY_POINT_RENAME(uiter_setState)\n#define uiter_setString U_ICU_ENTRY_POINT_RENAME(uiter_setString)\n#define uiter_setUTF16BE U_ICU_ENTRY_POINT_RENAME(uiter_setUTF16BE)\n#define uiter_setUTF8 U_ICU_ENTRY_POINT_RENAME(uiter_setUTF8)\n#define uldn_close U_ICU_ENTRY_POINT_RENAME(uldn_close)\n#define uldn_getContext U_ICU_ENTRY_POINT_RENAME(uldn_getContext)\n#define uldn_getDialectHandling U_ICU_ENTRY_POINT_RENAME(uldn_getDialectHandling)\n#define uldn_getLocale U_ICU_ENTRY_POINT_RENAME(uldn_getLocale)\n#define uldn_keyDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_keyDisplayName)\n#define uldn_keyValueDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_keyValueDisplayName)\n#define uldn_languageDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_languageDisplayName)\n#define uldn_localeDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_localeDisplayName)\n#define uldn_open U_ICU_ENTRY_POINT_RENAME(uldn_open)\n#define uldn_openForContext U_ICU_ENTRY_POINT_RENAME(uldn_openForContext)\n#define uldn_regionDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_regionDisplayName)\n#define uldn_scriptCodeDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_scriptCodeDisplayName)\n#define uldn_scriptDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_scriptDisplayName)\n#define uldn_variantDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_variantDisplayName)\n#define ulist_addItemBeginList U_ICU_ENTRY_POINT_RENAME(ulist_addItemBeginList)\n#define ulist_addItemEndList U_ICU_ENTRY_POINT_RENAME(ulist_addItemEndList)\n#define ulist_close_keyword_values_iterator U_ICU_ENTRY_POINT_RENAME(ulist_close_keyword_values_iterator)\n#define ulist_containsString U_ICU_ENTRY_POINT_RENAME(ulist_containsString)\n#define ulist_count_keyword_values U_ICU_ENTRY_POINT_RENAME(ulist_count_keyword_values)\n#define ulist_createEmptyList U_ICU_ENTRY_POINT_RENAME(ulist_createEmptyList)\n#define ulist_deleteList U_ICU_ENTRY_POINT_RENAME(ulist_deleteList)\n#define ulist_getListFromEnum U_ICU_ENTRY_POINT_RENAME(ulist_getListFromEnum)\n#define ulist_getListSize U_ICU_ENTRY_POINT_RENAME(ulist_getListSize)\n#define ulist_getNext U_ICU_ENTRY_POINT_RENAME(ulist_getNext)\n#define ulist_next_keyword_value U_ICU_ENTRY_POINT_RENAME(ulist_next_keyword_value)\n#define ulist_removeString U_ICU_ENTRY_POINT_RENAME(ulist_removeString)\n#define ulist_resetList U_ICU_ENTRY_POINT_RENAME(ulist_resetList)\n#define ulist_reset_keyword_values_iterator U_ICU_ENTRY_POINT_RENAME(ulist_reset_keyword_values_iterator)\n#define ulistfmt_close U_ICU_ENTRY_POINT_RENAME(ulistfmt_close)\n#define ulistfmt_format U_ICU_ENTRY_POINT_RENAME(ulistfmt_format)\n#define ulistfmt_open U_ICU_ENTRY_POINT_RENAME(ulistfmt_open)\n#define uloc_acceptLanguage U_ICU_ENTRY_POINT_RENAME(uloc_acceptLanguage)\n#define uloc_acceptLanguageFromHTTP U_ICU_ENTRY_POINT_RENAME(uloc_acceptLanguageFromHTTP)\n#define uloc_addLikelySubtags U_ICU_ENTRY_POINT_RENAME(uloc_addLikelySubtags)\n#define uloc_canonicalize U_ICU_ENTRY_POINT_RENAME(uloc_canonicalize)\n#define uloc_countAvailable U_ICU_ENTRY_POINT_RENAME(uloc_countAvailable)\n#define uloc_forLanguageTag U_ICU_ENTRY_POINT_RENAME(uloc_forLanguageTag)\n#define uloc_getAvailable U_ICU_ENTRY_POINT_RENAME(uloc_getAvailable)\n#define uloc_getBaseName U_ICU_ENTRY_POINT_RENAME(uloc_getBaseName)\n#define uloc_getCharacterOrientation U_ICU_ENTRY_POINT_RENAME(uloc_getCharacterOrientation)\n#define uloc_getCountry U_ICU_ENTRY_POINT_RENAME(uloc_getCountry)\n#define uloc_getCurrentCountryID U_ICU_ENTRY_POINT_RENAME(uloc_getCurrentCountryID)\n#define uloc_getCurrentLanguageID U_ICU_ENTRY_POINT_RENAME(uloc_getCurrentLanguageID)\n#define uloc_getDefault U_ICU_ENTRY_POINT_RENAME(uloc_getDefault)\n#define uloc_getDisplayCountry U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayCountry)\n#define uloc_getDisplayKeyword U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayKeyword)\n#define uloc_getDisplayKeywordValue U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayKeywordValue)\n#define uloc_getDisplayLanguage U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayLanguage)\n#define uloc_getDisplayName U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayName)\n#define uloc_getDisplayScript U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayScript)\n#define uloc_getDisplayScriptInContext U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayScriptInContext)\n#define uloc_getDisplayVariant U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayVariant)\n#define uloc_getISO3Country U_ICU_ENTRY_POINT_RENAME(uloc_getISO3Country)\n#define uloc_getISO3Language U_ICU_ENTRY_POINT_RENAME(uloc_getISO3Language)\n#define uloc_getISOCountries U_ICU_ENTRY_POINT_RENAME(uloc_getISOCountries)\n#define uloc_getISOLanguages U_ICU_ENTRY_POINT_RENAME(uloc_getISOLanguages)\n#define uloc_getKeywordValue U_ICU_ENTRY_POINT_RENAME(uloc_getKeywordValue)\n#define uloc_getLCID U_ICU_ENTRY_POINT_RENAME(uloc_getLCID)\n#define uloc_getLanguage U_ICU_ENTRY_POINT_RENAME(uloc_getLanguage)\n#define uloc_getLineOrientation U_ICU_ENTRY_POINT_RENAME(uloc_getLineOrientation)\n#define uloc_getLocaleForLCID U_ICU_ENTRY_POINT_RENAME(uloc_getLocaleForLCID)\n#define uloc_getName U_ICU_ENTRY_POINT_RENAME(uloc_getName)\n#define uloc_getParent U_ICU_ENTRY_POINT_RENAME(uloc_getParent)\n#define uloc_getScript U_ICU_ENTRY_POINT_RENAME(uloc_getScript)\n#define uloc_getTableStringWithFallback U_ICU_ENTRY_POINT_RENAME(uloc_getTableStringWithFallback)\n#define uloc_getVariant U_ICU_ENTRY_POINT_RENAME(uloc_getVariant)\n#define uloc_isRightToLeft U_ICU_ENTRY_POINT_RENAME(uloc_isRightToLeft)\n#define uloc_minimizeSubtags U_ICU_ENTRY_POINT_RENAME(uloc_minimizeSubtags)\n#define uloc_openKeywordList U_ICU_ENTRY_POINT_RENAME(uloc_openKeywordList)\n#define uloc_openKeywords U_ICU_ENTRY_POINT_RENAME(uloc_openKeywords)\n#define uloc_setDefault U_ICU_ENTRY_POINT_RENAME(uloc_setDefault)\n#define uloc_setKeywordValue U_ICU_ENTRY_POINT_RENAME(uloc_setKeywordValue)\n#define uloc_toLanguageTag U_ICU_ENTRY_POINT_RENAME(uloc_toLanguageTag)\n#define uloc_toLegacyKey U_ICU_ENTRY_POINT_RENAME(uloc_toLegacyKey)\n#define uloc_toLegacyType U_ICU_ENTRY_POINT_RENAME(uloc_toLegacyType)\n#define uloc_toUnicodeLocaleKey U_ICU_ENTRY_POINT_RENAME(uloc_toUnicodeLocaleKey)\n#define uloc_toUnicodeLocaleType U_ICU_ENTRY_POINT_RENAME(uloc_toUnicodeLocaleType)\n#define ulocdata_close U_ICU_ENTRY_POINT_RENAME(ulocdata_close)\n#define ulocdata_getCLDRVersion U_ICU_ENTRY_POINT_RENAME(ulocdata_getCLDRVersion)\n#define ulocdata_getDelimiter U_ICU_ENTRY_POINT_RENAME(ulocdata_getDelimiter)\n#define ulocdata_getExemplarSet U_ICU_ENTRY_POINT_RENAME(ulocdata_getExemplarSet)\n#define ulocdata_getLocaleDisplayPattern U_ICU_ENTRY_POINT_RENAME(ulocdata_getLocaleDisplayPattern)\n#define ulocdata_getLocaleSeparator U_ICU_ENTRY_POINT_RENAME(ulocdata_getLocaleSeparator)\n#define ulocdata_getMeasurementSystem U_ICU_ENTRY_POINT_RENAME(ulocdata_getMeasurementSystem)\n#define ulocdata_getNoSubstitute U_ICU_ENTRY_POINT_RENAME(ulocdata_getNoSubstitute)\n#define ulocdata_getPaperSize U_ICU_ENTRY_POINT_RENAME(ulocdata_getPaperSize)\n#define ulocdata_open U_ICU_ENTRY_POINT_RENAME(ulocdata_open)\n#define ulocdata_setNoSubstitute U_ICU_ENTRY_POINT_RENAME(ulocdata_setNoSubstitute)\n#define ulocimp_getCountry U_ICU_ENTRY_POINT_RENAME(ulocimp_getCountry)\n#define ulocimp_getLanguage U_ICU_ENTRY_POINT_RENAME(ulocimp_getLanguage)\n#define ulocimp_getRegionForSupplementalData U_ICU_ENTRY_POINT_RENAME(ulocimp_getRegionForSupplementalData)\n#define ulocimp_getScript U_ICU_ENTRY_POINT_RENAME(ulocimp_getScript)\n#define ulocimp_toBcpKey U_ICU_ENTRY_POINT_RENAME(ulocimp_toBcpKey)\n#define ulocimp_toBcpType U_ICU_ENTRY_POINT_RENAME(ulocimp_toBcpType)\n#define ulocimp_toLegacyKey U_ICU_ENTRY_POINT_RENAME(ulocimp_toLegacyKey)\n#define ulocimp_toLegacyType U_ICU_ENTRY_POINT_RENAME(ulocimp_toLegacyType)\n#define ultag_isUnicodeLocaleKey U_ICU_ENTRY_POINT_RENAME(ultag_isUnicodeLocaleKey)\n#define ultag_isUnicodeLocaleType U_ICU_ENTRY_POINT_RENAME(ultag_isUnicodeLocaleType)\n#define umsg_applyPattern U_ICU_ENTRY_POINT_RENAME(umsg_applyPattern)\n#define umsg_autoQuoteApostrophe U_ICU_ENTRY_POINT_RENAME(umsg_autoQuoteApostrophe)\n#define umsg_clone U_ICU_ENTRY_POINT_RENAME(umsg_clone)\n#define umsg_close U_ICU_ENTRY_POINT_RENAME(umsg_close)\n#define umsg_format U_ICU_ENTRY_POINT_RENAME(umsg_format)\n#define umsg_getLocale U_ICU_ENTRY_POINT_RENAME(umsg_getLocale)\n#define umsg_open U_ICU_ENTRY_POINT_RENAME(umsg_open)\n#define umsg_parse U_ICU_ENTRY_POINT_RENAME(umsg_parse)\n#define umsg_setLocale U_ICU_ENTRY_POINT_RENAME(umsg_setLocale)\n#define umsg_toPattern U_ICU_ENTRY_POINT_RENAME(umsg_toPattern)\n#define umsg_vformat U_ICU_ENTRY_POINT_RENAME(umsg_vformat)\n#define umsg_vparse U_ICU_ENTRY_POINT_RENAME(umsg_vparse)\n#define umtx_condBroadcast U_ICU_ENTRY_POINT_RENAME(umtx_condBroadcast)\n#define umtx_condSignal U_ICU_ENTRY_POINT_RENAME(umtx_condSignal)\n#define umtx_condWait U_ICU_ENTRY_POINT_RENAME(umtx_condWait)\n#define umtx_lock U_ICU_ENTRY_POINT_RENAME(umtx_lock)\n#define umtx_unlock U_ICU_ENTRY_POINT_RENAME(umtx_unlock)\n#define uniset_getUnicode32Instance U_ICU_ENTRY_POINT_RENAME(uniset_getUnicode32Instance)\n#define unorm2_append U_ICU_ENTRY_POINT_RENAME(unorm2_append)\n#define unorm2_close U_ICU_ENTRY_POINT_RENAME(unorm2_close)\n#define unorm2_composePair U_ICU_ENTRY_POINT_RENAME(unorm2_composePair)\n#define unorm2_getCombiningClass U_ICU_ENTRY_POINT_RENAME(unorm2_getCombiningClass)\n#define unorm2_getDecomposition U_ICU_ENTRY_POINT_RENAME(unorm2_getDecomposition)\n#define unorm2_getInstance U_ICU_ENTRY_POINT_RENAME(unorm2_getInstance)\n#define unorm2_getNFCInstance U_ICU_ENTRY_POINT_RENAME(unorm2_getNFCInstance)\n#define unorm2_getNFDInstance U_ICU_ENTRY_POINT_RENAME(unorm2_getNFDInstance)\n#define unorm2_getNFKCCasefoldInstance U_ICU_ENTRY_POINT_RENAME(unorm2_getNFKCCasefoldInstance)\n#define unorm2_getNFKCInstance U_ICU_ENTRY_POINT_RENAME(unorm2_getNFKCInstance)\n#define unorm2_getNFKDInstance U_ICU_ENTRY_POINT_RENAME(unorm2_getNFKDInstance)\n#define unorm2_getRawDecomposition U_ICU_ENTRY_POINT_RENAME(unorm2_getRawDecomposition)\n#define unorm2_hasBoundaryAfter U_ICU_ENTRY_POINT_RENAME(unorm2_hasBoundaryAfter)\n#define unorm2_hasBoundaryBefore U_ICU_ENTRY_POINT_RENAME(unorm2_hasBoundaryBefore)\n#define unorm2_isInert U_ICU_ENTRY_POINT_RENAME(unorm2_isInert)\n#define unorm2_isNormalized U_ICU_ENTRY_POINT_RENAME(unorm2_isNormalized)\n#define unorm2_normalize U_ICU_ENTRY_POINT_RENAME(unorm2_normalize)\n#define unorm2_normalizeSecondAndAppend U_ICU_ENTRY_POINT_RENAME(unorm2_normalizeSecondAndAppend)\n#define unorm2_openFiltered U_ICU_ENTRY_POINT_RENAME(unorm2_openFiltered)\n#define unorm2_quickCheck U_ICU_ENTRY_POINT_RENAME(unorm2_quickCheck)\n#define unorm2_spanQuickCheckYes U_ICU_ENTRY_POINT_RENAME(unorm2_spanQuickCheckYes)\n#define unorm2_swap U_ICU_ENTRY_POINT_RENAME(unorm2_swap)\n#define unorm_compare U_ICU_ENTRY_POINT_RENAME(unorm_compare)\n#define unorm_concatenate U_ICU_ENTRY_POINT_RENAME(unorm_concatenate)\n#define unorm_getFCD16 U_ICU_ENTRY_POINT_RENAME(unorm_getFCD16)\n#define unorm_getQuickCheck U_ICU_ENTRY_POINT_RENAME(unorm_getQuickCheck)\n#define unorm_isNormalized U_ICU_ENTRY_POINT_RENAME(unorm_isNormalized)\n#define unorm_isNormalizedWithOptions U_ICU_ENTRY_POINT_RENAME(unorm_isNormalizedWithOptions)\n#define unorm_next U_ICU_ENTRY_POINT_RENAME(unorm_next)\n#define unorm_normalize U_ICU_ENTRY_POINT_RENAME(unorm_normalize)\n#define unorm_previous U_ICU_ENTRY_POINT_RENAME(unorm_previous)\n#define unorm_quickCheck U_ICU_ENTRY_POINT_RENAME(unorm_quickCheck)\n#define unorm_quickCheckWithOptions U_ICU_ENTRY_POINT_RENAME(unorm_quickCheckWithOptions)\n#define unum_applyPattern U_ICU_ENTRY_POINT_RENAME(unum_applyPattern)\n#define unum_clone U_ICU_ENTRY_POINT_RENAME(unum_clone)\n#define unum_close U_ICU_ENTRY_POINT_RENAME(unum_close)\n#define unum_countAvailable U_ICU_ENTRY_POINT_RENAME(unum_countAvailable)\n#define unum_format U_ICU_ENTRY_POINT_RENAME(unum_format)\n#define unum_formatDecimal U_ICU_ENTRY_POINT_RENAME(unum_formatDecimal)\n#define unum_formatDouble U_ICU_ENTRY_POINT_RENAME(unum_formatDouble)\n#define unum_formatDoubleCurrency U_ICU_ENTRY_POINT_RENAME(unum_formatDoubleCurrency)\n#define unum_formatDoubleForFields U_ICU_ENTRY_POINT_RENAME(unum_formatDoubleForFields)\n#define unum_formatInt64 U_ICU_ENTRY_POINT_RENAME(unum_formatInt64)\n#define unum_formatUFormattable U_ICU_ENTRY_POINT_RENAME(unum_formatUFormattable)\n#define unum_getAttribute U_ICU_ENTRY_POINT_RENAME(unum_getAttribute)\n#define unum_getAvailable U_ICU_ENTRY_POINT_RENAME(unum_getAvailable)\n#define unum_getContext U_ICU_ENTRY_POINT_RENAME(unum_getContext)\n#define unum_getDoubleAttribute U_ICU_ENTRY_POINT_RENAME(unum_getDoubleAttribute)\n#define unum_getLocaleByType U_ICU_ENTRY_POINT_RENAME(unum_getLocaleByType)\n#define unum_getSymbol U_ICU_ENTRY_POINT_RENAME(unum_getSymbol)\n#define unum_getTextAttribute U_ICU_ENTRY_POINT_RENAME(unum_getTextAttribute)\n#define unum_open U_ICU_ENTRY_POINT_RENAME(unum_open)\n#define unum_parse U_ICU_ENTRY_POINT_RENAME(unum_parse)\n#define unum_parseDecimal U_ICU_ENTRY_POINT_RENAME(unum_parseDecimal)\n#define unum_parseDouble U_ICU_ENTRY_POINT_RENAME(unum_parseDouble)\n#define unum_parseDoubleCurrency U_ICU_ENTRY_POINT_RENAME(unum_parseDoubleCurrency)\n#define unum_parseInt64 U_ICU_ENTRY_POINT_RENAME(unum_parseInt64)\n#define unum_parseToUFormattable U_ICU_ENTRY_POINT_RENAME(unum_parseToUFormattable)\n#define unum_setAttribute U_ICU_ENTRY_POINT_RENAME(unum_setAttribute)\n#define unum_setContext U_ICU_ENTRY_POINT_RENAME(unum_setContext)\n#define unum_setDoubleAttribute U_ICU_ENTRY_POINT_RENAME(unum_setDoubleAttribute)\n#define unum_setSymbol U_ICU_ENTRY_POINT_RENAME(unum_setSymbol)\n#define unum_setTextAttribute U_ICU_ENTRY_POINT_RENAME(unum_setTextAttribute)\n#define unum_toPattern U_ICU_ENTRY_POINT_RENAME(unum_toPattern)\n#define unumsys_close U_ICU_ENTRY_POINT_RENAME(unumsys_close)\n#define unumsys_getDescription U_ICU_ENTRY_POINT_RENAME(unumsys_getDescription)\n#define unumsys_getName U_ICU_ENTRY_POINT_RENAME(unumsys_getName)\n#define unumsys_getRadix U_ICU_ENTRY_POINT_RENAME(unumsys_getRadix)\n#define unumsys_isAlgorithmic U_ICU_ENTRY_POINT_RENAME(unumsys_isAlgorithmic)\n#define unumsys_open U_ICU_ENTRY_POINT_RENAME(unumsys_open)\n#define unumsys_openAvailableNames U_ICU_ENTRY_POINT_RENAME(unumsys_openAvailableNames)\n#define unumsys_openByName U_ICU_ENTRY_POINT_RENAME(unumsys_openByName)\n#define uplrules_close U_ICU_ENTRY_POINT_RENAME(uplrules_close)\n#define uplrules_getKeywords U_ICU_ENTRY_POINT_RENAME(uplrules_getKeywords)\n#define uplrules_open U_ICU_ENTRY_POINT_RENAME(uplrules_open)\n#define uplrules_openForType U_ICU_ENTRY_POINT_RENAME(uplrules_openForType)\n#define uplrules_select U_ICU_ENTRY_POINT_RENAME(uplrules_select)\n#define uplrules_selectWithFormat U_ICU_ENTRY_POINT_RENAME(uplrules_selectWithFormat)\n#define uplug_closeLibrary U_ICU_ENTRY_POINT_RENAME(uplug_closeLibrary)\n#define uplug_findLibrary U_ICU_ENTRY_POINT_RENAME(uplug_findLibrary)\n#define uplug_getConfiguration U_ICU_ENTRY_POINT_RENAME(uplug_getConfiguration)\n#define uplug_getContext U_ICU_ENTRY_POINT_RENAME(uplug_getContext)\n#define uplug_getCurrentLevel U_ICU_ENTRY_POINT_RENAME(uplug_getCurrentLevel)\n#define uplug_getLibrary U_ICU_ENTRY_POINT_RENAME(uplug_getLibrary)\n#define uplug_getLibraryName U_ICU_ENTRY_POINT_RENAME(uplug_getLibraryName)\n#define uplug_getPlugInternal U_ICU_ENTRY_POINT_RENAME(uplug_getPlugInternal)\n#define uplug_getPlugLevel U_ICU_ENTRY_POINT_RENAME(uplug_getPlugLevel)\n#define uplug_getPlugLoadStatus U_ICU_ENTRY_POINT_RENAME(uplug_getPlugLoadStatus)\n#define uplug_getPlugName U_ICU_ENTRY_POINT_RENAME(uplug_getPlugName)\n#define uplug_getPluginFile U_ICU_ENTRY_POINT_RENAME(uplug_getPluginFile)\n#define uplug_getSymbolName U_ICU_ENTRY_POINT_RENAME(uplug_getSymbolName)\n#define uplug_init U_ICU_ENTRY_POINT_RENAME(uplug_init)\n#define uplug_loadPlugFromEntrypoint U_ICU_ENTRY_POINT_RENAME(uplug_loadPlugFromEntrypoint)\n#define uplug_loadPlugFromLibrary U_ICU_ENTRY_POINT_RENAME(uplug_loadPlugFromLibrary)\n#define uplug_nextPlug U_ICU_ENTRY_POINT_RENAME(uplug_nextPlug)\n#define uplug_openLibrary U_ICU_ENTRY_POINT_RENAME(uplug_openLibrary)\n#define uplug_removePlug U_ICU_ENTRY_POINT_RENAME(uplug_removePlug)\n#define uplug_setContext U_ICU_ENTRY_POINT_RENAME(uplug_setContext)\n#define uplug_setPlugLevel U_ICU_ENTRY_POINT_RENAME(uplug_setPlugLevel)\n#define uplug_setPlugName U_ICU_ENTRY_POINT_RENAME(uplug_setPlugName)\n#define uplug_setPlugNoUnload U_ICU_ENTRY_POINT_RENAME(uplug_setPlugNoUnload)\n#define uprops_getSource U_ICU_ENTRY_POINT_RENAME(uprops_getSource)\n#define upropsvec_addPropertyStarts U_ICU_ENTRY_POINT_RENAME(upropsvec_addPropertyStarts)\n#define uprv_aestrncpy U_ICU_ENTRY_POINT_RENAME(uprv_aestrncpy)\n#define uprv_asciiFromEbcdic U_ICU_ENTRY_POINT_RENAME(uprv_asciiFromEbcdic)\n#define uprv_asciitolower U_ICU_ENTRY_POINT_RENAME(uprv_asciitolower)\n#define uprv_calloc U_ICU_ENTRY_POINT_RENAME(uprv_calloc)\n#define uprv_ceil U_ICU_ENTRY_POINT_RENAME(uprv_ceil)\n#define uprv_compareASCIIPropertyNames U_ICU_ENTRY_POINT_RENAME(uprv_compareASCIIPropertyNames)\n#define uprv_compareEBCDICPropertyNames U_ICU_ENTRY_POINT_RENAME(uprv_compareEBCDICPropertyNames)\n#define uprv_compareInvAscii U_ICU_ENTRY_POINT_RENAME(uprv_compareInvAscii)\n#define uprv_compareInvEbcdic U_ICU_ENTRY_POINT_RENAME(uprv_compareInvEbcdic)\n#define uprv_compareInvEbcdicAsAscii U_ICU_ENTRY_POINT_RENAME(uprv_compareInvEbcdicAsAscii)\n#define uprv_convertToLCID U_ICU_ENTRY_POINT_RENAME(uprv_convertToLCID)\n#define uprv_convertToLCIDPlatform U_ICU_ENTRY_POINT_RENAME(uprv_convertToLCIDPlatform)\n#define uprv_convertToPosix U_ICU_ENTRY_POINT_RENAME(uprv_convertToPosix)\n#define uprv_copyAscii U_ICU_ENTRY_POINT_RENAME(uprv_copyAscii)\n#define uprv_copyEbcdic U_ICU_ENTRY_POINT_RENAME(uprv_copyEbcdic)\n#define uprv_decContextClearStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextClearStatus)\n#define uprv_decContextDefault U_ICU_ENTRY_POINT_RENAME(uprv_decContextDefault)\n#define uprv_decContextGetRounding U_ICU_ENTRY_POINT_RENAME(uprv_decContextGetRounding)\n#define uprv_decContextGetStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextGetStatus)\n#define uprv_decContextRestoreStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextRestoreStatus)\n#define uprv_decContextSaveStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextSaveStatus)\n#define uprv_decContextSetRounding U_ICU_ENTRY_POINT_RENAME(uprv_decContextSetRounding)\n#define uprv_decContextSetStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextSetStatus)\n#define uprv_decContextSetStatusFromString U_ICU_ENTRY_POINT_RENAME(uprv_decContextSetStatusFromString)\n#define uprv_decContextSetStatusFromStringQuiet U_ICU_ENTRY_POINT_RENAME(uprv_decContextSetStatusFromStringQuiet)\n#define uprv_decContextSetStatusQuiet U_ICU_ENTRY_POINT_RENAME(uprv_decContextSetStatusQuiet)\n#define uprv_decContextStatusToString U_ICU_ENTRY_POINT_RENAME(uprv_decContextStatusToString)\n#define uprv_decContextTestSavedStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextTestSavedStatus)\n#define uprv_decContextTestStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextTestStatus)\n#define uprv_decContextZeroStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextZeroStatus)\n#define uprv_decNumberAbs U_ICU_ENTRY_POINT_RENAME(uprv_decNumberAbs)\n#define uprv_decNumberAdd U_ICU_ENTRY_POINT_RENAME(uprv_decNumberAdd)\n#define uprv_decNumberAnd U_ICU_ENTRY_POINT_RENAME(uprv_decNumberAnd)\n#define uprv_decNumberClass U_ICU_ENTRY_POINT_RENAME(uprv_decNumberClass)\n#define uprv_decNumberClassToString U_ICU_ENTRY_POINT_RENAME(uprv_decNumberClassToString)\n#define uprv_decNumberCompare U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCompare)\n#define uprv_decNumberCompareSignal U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCompareSignal)\n#define uprv_decNumberCompareTotal U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCompareTotal)\n#define uprv_decNumberCompareTotalMag U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCompareTotalMag)\n#define uprv_decNumberCopy U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCopy)\n#define uprv_decNumberCopyAbs U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCopyAbs)\n#define uprv_decNumberCopyNegate U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCopyNegate)\n#define uprv_decNumberCopySign U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCopySign)\n#define uprv_decNumberDivide U_ICU_ENTRY_POINT_RENAME(uprv_decNumberDivide)\n#define uprv_decNumberDivideInteger U_ICU_ENTRY_POINT_RENAME(uprv_decNumberDivideInteger)\n#define uprv_decNumberExp U_ICU_ENTRY_POINT_RENAME(uprv_decNumberExp)\n#define uprv_decNumberFMA U_ICU_ENTRY_POINT_RENAME(uprv_decNumberFMA)\n#define uprv_decNumberFromInt32 U_ICU_ENTRY_POINT_RENAME(uprv_decNumberFromInt32)\n#define uprv_decNumberFromString U_ICU_ENTRY_POINT_RENAME(uprv_decNumberFromString)\n#define uprv_decNumberFromUInt32 U_ICU_ENTRY_POINT_RENAME(uprv_decNumberFromUInt32)\n#define uprv_decNumberGetBCD U_ICU_ENTRY_POINT_RENAME(uprv_decNumberGetBCD)\n#define uprv_decNumberInvert U_ICU_ENTRY_POINT_RENAME(uprv_decNumberInvert)\n#define uprv_decNumberIsNormal U_ICU_ENTRY_POINT_RENAME(uprv_decNumberIsNormal)\n#define uprv_decNumberIsSubnormal U_ICU_ENTRY_POINT_RENAME(uprv_decNumberIsSubnormal)\n#define uprv_decNumberLn U_ICU_ENTRY_POINT_RENAME(uprv_decNumberLn)\n#define uprv_decNumberLog10 U_ICU_ENTRY_POINT_RENAME(uprv_decNumberLog10)\n#define uprv_decNumberLogB U_ICU_ENTRY_POINT_RENAME(uprv_decNumberLogB)\n#define uprv_decNumberMax U_ICU_ENTRY_POINT_RENAME(uprv_decNumberMax)\n#define uprv_decNumberMaxMag U_ICU_ENTRY_POINT_RENAME(uprv_decNumberMaxMag)\n#define uprv_decNumberMin U_ICU_ENTRY_POINT_RENAME(uprv_decNumberMin)\n#define uprv_decNumberMinMag U_ICU_ENTRY_POINT_RENAME(uprv_decNumberMinMag)\n#define uprv_decNumberMinus U_ICU_ENTRY_POINT_RENAME(uprv_decNumberMinus)\n#define uprv_decNumberMultiply U_ICU_ENTRY_POINT_RENAME(uprv_decNumberMultiply)\n#define uprv_decNumberNextMinus U_ICU_ENTRY_POINT_RENAME(uprv_decNumberNextMinus)\n#define uprv_decNumberNextPlus U_ICU_ENTRY_POINT_RENAME(uprv_decNumberNextPlus)\n#define uprv_decNumberNextToward U_ICU_ENTRY_POINT_RENAME(uprv_decNumberNextToward)\n#define uprv_decNumberNormalize U_ICU_ENTRY_POINT_RENAME(uprv_decNumberNormalize)\n#define uprv_decNumberOr U_ICU_ENTRY_POINT_RENAME(uprv_decNumberOr)\n#define uprv_decNumberPlus U_ICU_ENTRY_POINT_RENAME(uprv_decNumberPlus)\n#define uprv_decNumberPower U_ICU_ENTRY_POINT_RENAME(uprv_decNumberPower)\n#define uprv_decNumberQuantize U_ICU_ENTRY_POINT_RENAME(uprv_decNumberQuantize)\n#define uprv_decNumberReduce U_ICU_ENTRY_POINT_RENAME(uprv_decNumberReduce)\n#define uprv_decNumberRemainder U_ICU_ENTRY_POINT_RENAME(uprv_decNumberRemainder)\n#define uprv_decNumberRemainderNear U_ICU_ENTRY_POINT_RENAME(uprv_decNumberRemainderNear)\n#define uprv_decNumberRescale U_ICU_ENTRY_POINT_RENAME(uprv_decNumberRescale)\n#define uprv_decNumberRotate U_ICU_ENTRY_POINT_RENAME(uprv_decNumberRotate)\n#define uprv_decNumberSameQuantum U_ICU_ENTRY_POINT_RENAME(uprv_decNumberSameQuantum)\n#define uprv_decNumberScaleB U_ICU_ENTRY_POINT_RENAME(uprv_decNumberScaleB)\n#define uprv_decNumberSetBCD U_ICU_ENTRY_POINT_RENAME(uprv_decNumberSetBCD)\n#define uprv_decNumberShift U_ICU_ENTRY_POINT_RENAME(uprv_decNumberShift)\n#define uprv_decNumberSquareRoot U_ICU_ENTRY_POINT_RENAME(uprv_decNumberSquareRoot)\n#define uprv_decNumberSubtract U_ICU_ENTRY_POINT_RENAME(uprv_decNumberSubtract)\n#define uprv_decNumberToEngString U_ICU_ENTRY_POINT_RENAME(uprv_decNumberToEngString)\n#define uprv_decNumberToInt32 U_ICU_ENTRY_POINT_RENAME(uprv_decNumberToInt32)\n#define uprv_decNumberToIntegralExact U_ICU_ENTRY_POINT_RENAME(uprv_decNumberToIntegralExact)\n#define uprv_decNumberToIntegralValue U_ICU_ENTRY_POINT_RENAME(uprv_decNumberToIntegralValue)\n#define uprv_decNumberToString U_ICU_ENTRY_POINT_RENAME(uprv_decNumberToString)\n#define uprv_decNumberToUInt32 U_ICU_ENTRY_POINT_RENAME(uprv_decNumberToUInt32)\n#define uprv_decNumberTrim U_ICU_ENTRY_POINT_RENAME(uprv_decNumberTrim)\n#define uprv_decNumberVersion U_ICU_ENTRY_POINT_RENAME(uprv_decNumberVersion)\n#define uprv_decNumberXor U_ICU_ENTRY_POINT_RENAME(uprv_decNumberXor)\n#define uprv_decNumberZero U_ICU_ENTRY_POINT_RENAME(uprv_decNumberZero)\n#define uprv_deleteConditionalCE32 U_ICU_ENTRY_POINT_RENAME(uprv_deleteConditionalCE32)\n#define uprv_deleteUObject U_ICU_ENTRY_POINT_RENAME(uprv_deleteUObject)\n#define uprv_dl_close U_ICU_ENTRY_POINT_RENAME(uprv_dl_close)\n#define uprv_dl_open U_ICU_ENTRY_POINT_RENAME(uprv_dl_open)\n#define uprv_dlsym_func U_ICU_ENTRY_POINT_RENAME(uprv_dlsym_func)\n#define uprv_eastrncpy U_ICU_ENTRY_POINT_RENAME(uprv_eastrncpy)\n#define uprv_ebcdicFromAscii U_ICU_ENTRY_POINT_RENAME(uprv_ebcdicFromAscii)\n#define uprv_ebcdicToLowercaseAscii U_ICU_ENTRY_POINT_RENAME(uprv_ebcdicToLowercaseAscii)\n#define uprv_ebcdictolower U_ICU_ENTRY_POINT_RENAME(uprv_ebcdictolower)\n#define uprv_fabs U_ICU_ENTRY_POINT_RENAME(uprv_fabs)\n#define uprv_floor U_ICU_ENTRY_POINT_RENAME(uprv_floor)\n#define uprv_fmax U_ICU_ENTRY_POINT_RENAME(uprv_fmax)\n#define uprv_fmin U_ICU_ENTRY_POINT_RENAME(uprv_fmin)\n#define uprv_fmod U_ICU_ENTRY_POINT_RENAME(uprv_fmod)\n#define uprv_free U_ICU_ENTRY_POINT_RENAME(uprv_free)\n#define uprv_getCharNameCharacters U_ICU_ENTRY_POINT_RENAME(uprv_getCharNameCharacters)\n#define uprv_getDefaultCodepage U_ICU_ENTRY_POINT_RENAME(uprv_getDefaultCodepage)\n#define uprv_getDefaultLocaleID U_ICU_ENTRY_POINT_RENAME(uprv_getDefaultLocaleID)\n#define uprv_getInfinity U_ICU_ENTRY_POINT_RENAME(uprv_getInfinity)\n#define uprv_getMaxCharNameLength U_ICU_ENTRY_POINT_RENAME(uprv_getMaxCharNameLength)\n#define uprv_getMaxValues U_ICU_ENTRY_POINT_RENAME(uprv_getMaxValues)\n#define uprv_getNaN U_ICU_ENTRY_POINT_RENAME(uprv_getNaN)\n#define uprv_getRawUTCtime U_ICU_ENTRY_POINT_RENAME(uprv_getRawUTCtime)\n#define uprv_getStaticCurrencyName U_ICU_ENTRY_POINT_RENAME(uprv_getStaticCurrencyName)\n#define uprv_getUTCtime U_ICU_ENTRY_POINT_RENAME(uprv_getUTCtime)\n#define uprv_haveProperties U_ICU_ENTRY_POINT_RENAME(uprv_haveProperties)\n#define uprv_int32Comparator U_ICU_ENTRY_POINT_RENAME(uprv_int32Comparator)\n#define uprv_isASCIILetter U_ICU_ENTRY_POINT_RENAME(uprv_isASCIILetter)\n#define uprv_isInfinite U_ICU_ENTRY_POINT_RENAME(uprv_isInfinite)\n#define uprv_isInvariantString U_ICU_ENTRY_POINT_RENAME(uprv_isInvariantString)\n#define uprv_isInvariantUString U_ICU_ENTRY_POINT_RENAME(uprv_isInvariantUString)\n#define uprv_isNaN U_ICU_ENTRY_POINT_RENAME(uprv_isNaN)\n#define uprv_isNegativeInfinity U_ICU_ENTRY_POINT_RENAME(uprv_isNegativeInfinity)\n#define uprv_isPositiveInfinity U_ICU_ENTRY_POINT_RENAME(uprv_isPositiveInfinity)\n#define uprv_itou U_ICU_ENTRY_POINT_RENAME(uprv_itou)\n#define uprv_log U_ICU_ENTRY_POINT_RENAME(uprv_log)\n#define uprv_malloc U_ICU_ENTRY_POINT_RENAME(uprv_malloc)\n#define uprv_mapFile U_ICU_ENTRY_POINT_RENAME(uprv_mapFile)\n#define uprv_max U_ICU_ENTRY_POINT_RENAME(uprv_max)\n#define uprv_maxMantissa U_ICU_ENTRY_POINT_RENAME(uprv_maxMantissa)\n#define uprv_maximumPtr U_ICU_ENTRY_POINT_RENAME(uprv_maximumPtr)\n#define uprv_min U_ICU_ENTRY_POINT_RENAME(uprv_min)\n#define uprv_modf U_ICU_ENTRY_POINT_RENAME(uprv_modf)\n#define uprv_parseCurrency U_ICU_ENTRY_POINT_RENAME(uprv_parseCurrency)\n#define uprv_pathIsAbsolute U_ICU_ENTRY_POINT_RENAME(uprv_pathIsAbsolute)\n#define uprv_pow U_ICU_ENTRY_POINT_RENAME(uprv_pow)\n#define uprv_pow10 U_ICU_ENTRY_POINT_RENAME(uprv_pow10)\n#define uprv_realloc U_ICU_ENTRY_POINT_RENAME(uprv_realloc)\n#define uprv_round U_ICU_ENTRY_POINT_RENAME(uprv_round)\n#define uprv_sortArray U_ICU_ENTRY_POINT_RENAME(uprv_sortArray)\n#define uprv_stableBinarySearch U_ICU_ENTRY_POINT_RENAME(uprv_stableBinarySearch)\n#define uprv_strCompare U_ICU_ENTRY_POINT_RENAME(uprv_strCompare)\n#define uprv_strdup U_ICU_ENTRY_POINT_RENAME(uprv_strdup)\n#define uprv_stricmp U_ICU_ENTRY_POINT_RENAME(uprv_stricmp)\n#define uprv_strndup U_ICU_ENTRY_POINT_RENAME(uprv_strndup)\n#define uprv_strnicmp U_ICU_ENTRY_POINT_RENAME(uprv_strnicmp)\n#define uprv_syntaxError U_ICU_ENTRY_POINT_RENAME(uprv_syntaxError)\n#define uprv_timezone U_ICU_ENTRY_POINT_RENAME(uprv_timezone)\n#define uprv_toupper U_ICU_ENTRY_POINT_RENAME(uprv_toupper)\n#define uprv_trunc U_ICU_ENTRY_POINT_RENAME(uprv_trunc)\n#define uprv_tzname U_ICU_ENTRY_POINT_RENAME(uprv_tzname)\n#define uprv_tzname_clear_cache U_ICU_ENTRY_POINT_RENAME(uprv_tzname_clear_cache)\n#define uprv_tzset U_ICU_ENTRY_POINT_RENAME(uprv_tzset)\n#define uprv_uint16Comparator U_ICU_ENTRY_POINT_RENAME(uprv_uint16Comparator)\n#define uprv_uint32Comparator U_ICU_ENTRY_POINT_RENAME(uprv_uint32Comparator)\n#define uprv_unmapFile U_ICU_ENTRY_POINT_RENAME(uprv_unmapFile)\n#define upvec_cloneArray U_ICU_ENTRY_POINT_RENAME(upvec_cloneArray)\n#define upvec_close U_ICU_ENTRY_POINT_RENAME(upvec_close)\n#define upvec_compact U_ICU_ENTRY_POINT_RENAME(upvec_compact)\n#define upvec_compactToUTrie2Handler U_ICU_ENTRY_POINT_RENAME(upvec_compactToUTrie2Handler)\n#define upvec_compactToUTrie2WithRowIndexes U_ICU_ENTRY_POINT_RENAME(upvec_compactToUTrie2WithRowIndexes)\n#define upvec_getArray U_ICU_ENTRY_POINT_RENAME(upvec_getArray)\n#define upvec_getRow U_ICU_ENTRY_POINT_RENAME(upvec_getRow)\n#define upvec_getValue U_ICU_ENTRY_POINT_RENAME(upvec_getValue)\n#define upvec_open U_ICU_ENTRY_POINT_RENAME(upvec_open)\n#define upvec_setValue U_ICU_ENTRY_POINT_RENAME(upvec_setValue)\n#define uregex_appendReplacement U_ICU_ENTRY_POINT_RENAME(uregex_appendReplacement)\n#define uregex_appendReplacementUText U_ICU_ENTRY_POINT_RENAME(uregex_appendReplacementUText)\n#define uregex_appendTail U_ICU_ENTRY_POINT_RENAME(uregex_appendTail)\n#define uregex_appendTailUText U_ICU_ENTRY_POINT_RENAME(uregex_appendTailUText)\n#define uregex_clone U_ICU_ENTRY_POINT_RENAME(uregex_clone)\n#define uregex_close U_ICU_ENTRY_POINT_RENAME(uregex_close)\n#define uregex_end U_ICU_ENTRY_POINT_RENAME(uregex_end)\n#define uregex_end64 U_ICU_ENTRY_POINT_RENAME(uregex_end64)\n#define uregex_find U_ICU_ENTRY_POINT_RENAME(uregex_find)\n#define uregex_find64 U_ICU_ENTRY_POINT_RENAME(uregex_find64)\n#define uregex_findNext U_ICU_ENTRY_POINT_RENAME(uregex_findNext)\n#define uregex_flags U_ICU_ENTRY_POINT_RENAME(uregex_flags)\n#define uregex_getFindProgressCallback U_ICU_ENTRY_POINT_RENAME(uregex_getFindProgressCallback)\n#define uregex_getMatchCallback U_ICU_ENTRY_POINT_RENAME(uregex_getMatchCallback)\n#define uregex_getStackLimit U_ICU_ENTRY_POINT_RENAME(uregex_getStackLimit)\n#define uregex_getText U_ICU_ENTRY_POINT_RENAME(uregex_getText)\n#define uregex_getTimeLimit U_ICU_ENTRY_POINT_RENAME(uregex_getTimeLimit)\n#define uregex_getUText U_ICU_ENTRY_POINT_RENAME(uregex_getUText)\n#define uregex_group U_ICU_ENTRY_POINT_RENAME(uregex_group)\n#define uregex_groupCount U_ICU_ENTRY_POINT_RENAME(uregex_groupCount)\n#define uregex_groupNumberFromCName U_ICU_ENTRY_POINT_RENAME(uregex_groupNumberFromCName)\n#define uregex_groupNumberFromName U_ICU_ENTRY_POINT_RENAME(uregex_groupNumberFromName)\n#define uregex_groupUText U_ICU_ENTRY_POINT_RENAME(uregex_groupUText)\n#define uregex_hasAnchoringBounds U_ICU_ENTRY_POINT_RENAME(uregex_hasAnchoringBounds)\n#define uregex_hasTransparentBounds U_ICU_ENTRY_POINT_RENAME(uregex_hasTransparentBounds)\n#define uregex_hitEnd U_ICU_ENTRY_POINT_RENAME(uregex_hitEnd)\n#define uregex_lookingAt U_ICU_ENTRY_POINT_RENAME(uregex_lookingAt)\n#define uregex_lookingAt64 U_ICU_ENTRY_POINT_RENAME(uregex_lookingAt64)\n#define uregex_matches U_ICU_ENTRY_POINT_RENAME(uregex_matches)\n#define uregex_matches64 U_ICU_ENTRY_POINT_RENAME(uregex_matches64)\n#define uregex_open U_ICU_ENTRY_POINT_RENAME(uregex_open)\n#define uregex_openC U_ICU_ENTRY_POINT_RENAME(uregex_openC)\n#define uregex_openUText U_ICU_ENTRY_POINT_RENAME(uregex_openUText)\n#define uregex_pattern U_ICU_ENTRY_POINT_RENAME(uregex_pattern)\n#define uregex_patternUText U_ICU_ENTRY_POINT_RENAME(uregex_patternUText)\n#define uregex_refreshUText U_ICU_ENTRY_POINT_RENAME(uregex_refreshUText)\n#define uregex_regionEnd U_ICU_ENTRY_POINT_RENAME(uregex_regionEnd)\n#define uregex_regionEnd64 U_ICU_ENTRY_POINT_RENAME(uregex_regionEnd64)\n#define uregex_regionStart U_ICU_ENTRY_POINT_RENAME(uregex_regionStart)\n#define uregex_regionStart64 U_ICU_ENTRY_POINT_RENAME(uregex_regionStart64)\n#define uregex_replaceAll U_ICU_ENTRY_POINT_RENAME(uregex_replaceAll)\n#define uregex_replaceAllUText U_ICU_ENTRY_POINT_RENAME(uregex_replaceAllUText)\n#define uregex_replaceFirst U_ICU_ENTRY_POINT_RENAME(uregex_replaceFirst)\n#define uregex_replaceFirstUText U_ICU_ENTRY_POINT_RENAME(uregex_replaceFirstUText)\n#define uregex_requireEnd U_ICU_ENTRY_POINT_RENAME(uregex_requireEnd)\n#define uregex_reset U_ICU_ENTRY_POINT_RENAME(uregex_reset)\n#define uregex_reset64 U_ICU_ENTRY_POINT_RENAME(uregex_reset64)\n#define uregex_setFindProgressCallback U_ICU_ENTRY_POINT_RENAME(uregex_setFindProgressCallback)\n#define uregex_setMatchCallback U_ICU_ENTRY_POINT_RENAME(uregex_setMatchCallback)\n#define uregex_setRegion U_ICU_ENTRY_POINT_RENAME(uregex_setRegion)\n#define uregex_setRegion64 U_ICU_ENTRY_POINT_RENAME(uregex_setRegion64)\n#define uregex_setRegionAndStart U_ICU_ENTRY_POINT_RENAME(uregex_setRegionAndStart)\n#define uregex_setStackLimit U_ICU_ENTRY_POINT_RENAME(uregex_setStackLimit)\n#define uregex_setText U_ICU_ENTRY_POINT_RENAME(uregex_setText)\n#define uregex_setTimeLimit U_ICU_ENTRY_POINT_RENAME(uregex_setTimeLimit)\n#define uregex_setUText U_ICU_ENTRY_POINT_RENAME(uregex_setUText)\n#define uregex_split U_ICU_ENTRY_POINT_RENAME(uregex_split)\n#define uregex_splitUText U_ICU_ENTRY_POINT_RENAME(uregex_splitUText)\n#define uregex_start U_ICU_ENTRY_POINT_RENAME(uregex_start)\n#define uregex_start64 U_ICU_ENTRY_POINT_RENAME(uregex_start64)\n#define uregex_ucstr_unescape_charAt U_ICU_ENTRY_POINT_RENAME(uregex_ucstr_unescape_charAt)\n#define uregex_useAnchoringBounds U_ICU_ENTRY_POINT_RENAME(uregex_useAnchoringBounds)\n#define uregex_useTransparentBounds U_ICU_ENTRY_POINT_RENAME(uregex_useTransparentBounds)\n#define uregex_utext_unescape_charAt U_ICU_ENTRY_POINT_RENAME(uregex_utext_unescape_charAt)\n#define uregion_areEqual U_ICU_ENTRY_POINT_RENAME(uregion_areEqual)\n#define uregion_contains U_ICU_ENTRY_POINT_RENAME(uregion_contains)\n#define uregion_getAvailable U_ICU_ENTRY_POINT_RENAME(uregion_getAvailable)\n#define uregion_getContainedRegions U_ICU_ENTRY_POINT_RENAME(uregion_getContainedRegions)\n#define uregion_getContainedRegionsOfType U_ICU_ENTRY_POINT_RENAME(uregion_getContainedRegionsOfType)\n#define uregion_getContainingRegion U_ICU_ENTRY_POINT_RENAME(uregion_getContainingRegion)\n#define uregion_getContainingRegionOfType U_ICU_ENTRY_POINT_RENAME(uregion_getContainingRegionOfType)\n#define uregion_getNumericCode U_ICU_ENTRY_POINT_RENAME(uregion_getNumericCode)\n#define uregion_getPreferredValues U_ICU_ENTRY_POINT_RENAME(uregion_getPreferredValues)\n#define uregion_getRegionCode U_ICU_ENTRY_POINT_RENAME(uregion_getRegionCode)\n#define uregion_getRegionFromCode U_ICU_ENTRY_POINT_RENAME(uregion_getRegionFromCode)\n#define uregion_getRegionFromNumericCode U_ICU_ENTRY_POINT_RENAME(uregion_getRegionFromNumericCode)\n#define uregion_getType U_ICU_ENTRY_POINT_RENAME(uregion_getType)\n#define ureldatefmt_close U_ICU_ENTRY_POINT_RENAME(ureldatefmt_close)\n#define ureldatefmt_combineDateAndTime U_ICU_ENTRY_POINT_RENAME(ureldatefmt_combineDateAndTime)\n#define ureldatefmt_format U_ICU_ENTRY_POINT_RENAME(ureldatefmt_format)\n#define ureldatefmt_formatNumeric U_ICU_ENTRY_POINT_RENAME(ureldatefmt_formatNumeric)\n#define ureldatefmt_open U_ICU_ENTRY_POINT_RENAME(ureldatefmt_open)\n#define ures_close U_ICU_ENTRY_POINT_RENAME(ures_close)\n#define ures_copyResb U_ICU_ENTRY_POINT_RENAME(ures_copyResb)\n#define ures_countArrayItems U_ICU_ENTRY_POINT_RENAME(ures_countArrayItems)\n#define ures_findResource U_ICU_ENTRY_POINT_RENAME(ures_findResource)\n#define ures_findSubResource U_ICU_ENTRY_POINT_RENAME(ures_findSubResource)\n#define ures_getAllItemsWithFallback U_ICU_ENTRY_POINT_RENAME(ures_getAllItemsWithFallback)\n#define ures_getBinary U_ICU_ENTRY_POINT_RENAME(ures_getBinary)\n#define ures_getByIndex U_ICU_ENTRY_POINT_RENAME(ures_getByIndex)\n#define ures_getByKey U_ICU_ENTRY_POINT_RENAME(ures_getByKey)\n#define ures_getByKeyWithFallback U_ICU_ENTRY_POINT_RENAME(ures_getByKeyWithFallback)\n#define ures_getFunctionalEquivalent U_ICU_ENTRY_POINT_RENAME(ures_getFunctionalEquivalent)\n#define ures_getInt U_ICU_ENTRY_POINT_RENAME(ures_getInt)\n#define ures_getIntVector U_ICU_ENTRY_POINT_RENAME(ures_getIntVector)\n#define ures_getKey U_ICU_ENTRY_POINT_RENAME(ures_getKey)\n#define ures_getKeywordValues U_ICU_ENTRY_POINT_RENAME(ures_getKeywordValues)\n#define ures_getLocale U_ICU_ENTRY_POINT_RENAME(ures_getLocale)\n#define ures_getLocaleByType U_ICU_ENTRY_POINT_RENAME(ures_getLocaleByType)\n#define ures_getLocaleInternal U_ICU_ENTRY_POINT_RENAME(ures_getLocaleInternal)\n#define ures_getName U_ICU_ENTRY_POINT_RENAME(ures_getName)\n#define ures_getNextResource U_ICU_ENTRY_POINT_RENAME(ures_getNextResource)\n#define ures_getNextString U_ICU_ENTRY_POINT_RENAME(ures_getNextString)\n#define ures_getSize U_ICU_ENTRY_POINT_RENAME(ures_getSize)\n#define ures_getString U_ICU_ENTRY_POINT_RENAME(ures_getString)\n#define ures_getStringByIndex U_ICU_ENTRY_POINT_RENAME(ures_getStringByIndex)\n#define ures_getStringByKey U_ICU_ENTRY_POINT_RENAME(ures_getStringByKey)\n#define ures_getStringByKeyWithFallback U_ICU_ENTRY_POINT_RENAME(ures_getStringByKeyWithFallback)\n#define ures_getType U_ICU_ENTRY_POINT_RENAME(ures_getType)\n#define ures_getUInt U_ICU_ENTRY_POINT_RENAME(ures_getUInt)\n#define ures_getUTF8String U_ICU_ENTRY_POINT_RENAME(ures_getUTF8String)\n#define ures_getUTF8StringByIndex U_ICU_ENTRY_POINT_RENAME(ures_getUTF8StringByIndex)\n#define ures_getUTF8StringByKey U_ICU_ENTRY_POINT_RENAME(ures_getUTF8StringByKey)\n#define ures_getVersion U_ICU_ENTRY_POINT_RENAME(ures_getVersion)\n#define ures_getVersionByKey U_ICU_ENTRY_POINT_RENAME(ures_getVersionByKey)\n#define ures_getVersionNumber U_ICU_ENTRY_POINT_RENAME(ures_getVersionNumber)\n#define ures_getVersionNumberInternal U_ICU_ENTRY_POINT_RENAME(ures_getVersionNumberInternal)\n#define ures_hasNext U_ICU_ENTRY_POINT_RENAME(ures_hasNext)\n#define ures_initStackObject U_ICU_ENTRY_POINT_RENAME(ures_initStackObject)\n#define ures_open U_ICU_ENTRY_POINT_RENAME(ures_open)\n#define ures_openAvailableLocales U_ICU_ENTRY_POINT_RENAME(ures_openAvailableLocales)\n#define ures_openDirect U_ICU_ENTRY_POINT_RENAME(ures_openDirect)\n#define ures_openFillIn U_ICU_ENTRY_POINT_RENAME(ures_openFillIn)\n#define ures_openNoDefault U_ICU_ENTRY_POINT_RENAME(ures_openNoDefault)\n#define ures_openU U_ICU_ENTRY_POINT_RENAME(ures_openU)\n#define ures_resetIterator U_ICU_ENTRY_POINT_RENAME(ures_resetIterator)\n#define ures_swap U_ICU_ENTRY_POINT_RENAME(ures_swap)\n#define uscript_breaksBetweenLetters U_ICU_ENTRY_POINT_RENAME(uscript_breaksBetweenLetters)\n#define uscript_closeRun U_ICU_ENTRY_POINT_RENAME(uscript_closeRun)\n#define uscript_getCode U_ICU_ENTRY_POINT_RENAME(uscript_getCode)\n#define uscript_getName U_ICU_ENTRY_POINT_RENAME(uscript_getName)\n#define uscript_getSampleString U_ICU_ENTRY_POINT_RENAME(uscript_getSampleString)\n#define uscript_getSampleUnicodeString U_ICU_ENTRY_POINT_RENAME(uscript_getSampleUnicodeString)\n#define uscript_getScript U_ICU_ENTRY_POINT_RENAME(uscript_getScript)\n#define uscript_getScriptExtensions U_ICU_ENTRY_POINT_RENAME(uscript_getScriptExtensions)\n#define uscript_getShortName U_ICU_ENTRY_POINT_RENAME(uscript_getShortName)\n#define uscript_getUsage U_ICU_ENTRY_POINT_RENAME(uscript_getUsage)\n#define uscript_hasScript U_ICU_ENTRY_POINT_RENAME(uscript_hasScript)\n#define uscript_isCased U_ICU_ENTRY_POINT_RENAME(uscript_isCased)\n#define uscript_isRightToLeft U_ICU_ENTRY_POINT_RENAME(uscript_isRightToLeft)\n#define uscript_nextRun U_ICU_ENTRY_POINT_RENAME(uscript_nextRun)\n#define uscript_openRun U_ICU_ENTRY_POINT_RENAME(uscript_openRun)\n#define uscript_resetRun U_ICU_ENTRY_POINT_RENAME(uscript_resetRun)\n#define uscript_setRunText U_ICU_ENTRY_POINT_RENAME(uscript_setRunText)\n#define usearch_close U_ICU_ENTRY_POINT_RENAME(usearch_close)\n#define usearch_first U_ICU_ENTRY_POINT_RENAME(usearch_first)\n#define usearch_following U_ICU_ENTRY_POINT_RENAME(usearch_following)\n#define usearch_getAttribute U_ICU_ENTRY_POINT_RENAME(usearch_getAttribute)\n#define usearch_getBreakIterator U_ICU_ENTRY_POINT_RENAME(usearch_getBreakIterator)\n#define usearch_getCollator U_ICU_ENTRY_POINT_RENAME(usearch_getCollator)\n#define usearch_getMatchedLength U_ICU_ENTRY_POINT_RENAME(usearch_getMatchedLength)\n#define usearch_getMatchedStart U_ICU_ENTRY_POINT_RENAME(usearch_getMatchedStart)\n#define usearch_getMatchedText U_ICU_ENTRY_POINT_RENAME(usearch_getMatchedText)\n#define usearch_getOffset U_ICU_ENTRY_POINT_RENAME(usearch_getOffset)\n#define usearch_getPattern U_ICU_ENTRY_POINT_RENAME(usearch_getPattern)\n#define usearch_getText U_ICU_ENTRY_POINT_RENAME(usearch_getText)\n#define usearch_handleNextCanonical U_ICU_ENTRY_POINT_RENAME(usearch_handleNextCanonical)\n#define usearch_handleNextExact U_ICU_ENTRY_POINT_RENAME(usearch_handleNextExact)\n#define usearch_handlePreviousCanonical U_ICU_ENTRY_POINT_RENAME(usearch_handlePreviousCanonical)\n#define usearch_handlePreviousExact U_ICU_ENTRY_POINT_RENAME(usearch_handlePreviousExact)\n#define usearch_last U_ICU_ENTRY_POINT_RENAME(usearch_last)\n#define usearch_next U_ICU_ENTRY_POINT_RENAME(usearch_next)\n#define usearch_open U_ICU_ENTRY_POINT_RENAME(usearch_open)\n#define usearch_openFromCollator U_ICU_ENTRY_POINT_RENAME(usearch_openFromCollator)\n#define usearch_preceding U_ICU_ENTRY_POINT_RENAME(usearch_preceding)\n#define usearch_previous U_ICU_ENTRY_POINT_RENAME(usearch_previous)\n#define usearch_reset U_ICU_ENTRY_POINT_RENAME(usearch_reset)\n#define usearch_search U_ICU_ENTRY_POINT_RENAME(usearch_search)\n#define usearch_searchBackwards U_ICU_ENTRY_POINT_RENAME(usearch_searchBackwards)\n#define usearch_setAttribute U_ICU_ENTRY_POINT_RENAME(usearch_setAttribute)\n#define usearch_setBreakIterator U_ICU_ENTRY_POINT_RENAME(usearch_setBreakIterator)\n#define usearch_setCollator U_ICU_ENTRY_POINT_RENAME(usearch_setCollator)\n#define usearch_setOffset U_ICU_ENTRY_POINT_RENAME(usearch_setOffset)\n#define usearch_setPattern U_ICU_ENTRY_POINT_RENAME(usearch_setPattern)\n#define usearch_setText U_ICU_ENTRY_POINT_RENAME(usearch_setText)\n#define uset_add U_ICU_ENTRY_POINT_RENAME(uset_add)\n#define uset_addAll U_ICU_ENTRY_POINT_RENAME(uset_addAll)\n#define uset_addAllCodePoints U_ICU_ENTRY_POINT_RENAME(uset_addAllCodePoints)\n#define uset_addRange U_ICU_ENTRY_POINT_RENAME(uset_addRange)\n#define uset_addString U_ICU_ENTRY_POINT_RENAME(uset_addString)\n#define uset_applyIntPropertyValue U_ICU_ENTRY_POINT_RENAME(uset_applyIntPropertyValue)\n#define uset_applyPattern U_ICU_ENTRY_POINT_RENAME(uset_applyPattern)\n#define uset_applyPropertyAlias U_ICU_ENTRY_POINT_RENAME(uset_applyPropertyAlias)\n#define uset_charAt U_ICU_ENTRY_POINT_RENAME(uset_charAt)\n#define uset_clear U_ICU_ENTRY_POINT_RENAME(uset_clear)\n#define uset_clone U_ICU_ENTRY_POINT_RENAME(uset_clone)\n#define uset_cloneAsThawed U_ICU_ENTRY_POINT_RENAME(uset_cloneAsThawed)\n#define uset_close U_ICU_ENTRY_POINT_RENAME(uset_close)\n#define uset_closeOver U_ICU_ENTRY_POINT_RENAME(uset_closeOver)\n#define uset_compact U_ICU_ENTRY_POINT_RENAME(uset_compact)\n#define uset_complement U_ICU_ENTRY_POINT_RENAME(uset_complement)\n#define uset_complementAll U_ICU_ENTRY_POINT_RENAME(uset_complementAll)\n#define uset_contains U_ICU_ENTRY_POINT_RENAME(uset_contains)\n#define uset_containsAll U_ICU_ENTRY_POINT_RENAME(uset_containsAll)\n#define uset_containsAllCodePoints U_ICU_ENTRY_POINT_RENAME(uset_containsAllCodePoints)\n#define uset_containsNone U_ICU_ENTRY_POINT_RENAME(uset_containsNone)\n#define uset_containsRange U_ICU_ENTRY_POINT_RENAME(uset_containsRange)\n#define uset_containsSome U_ICU_ENTRY_POINT_RENAME(uset_containsSome)\n#define uset_containsString U_ICU_ENTRY_POINT_RENAME(uset_containsString)\n#define uset_equals U_ICU_ENTRY_POINT_RENAME(uset_equals)\n#define uset_freeze U_ICU_ENTRY_POINT_RENAME(uset_freeze)\n#define uset_getItem U_ICU_ENTRY_POINT_RENAME(uset_getItem)\n#define uset_getItemCount U_ICU_ENTRY_POINT_RENAME(uset_getItemCount)\n#define uset_getSerializedRange U_ICU_ENTRY_POINT_RENAME(uset_getSerializedRange)\n#define uset_getSerializedRangeCount U_ICU_ENTRY_POINT_RENAME(uset_getSerializedRangeCount)\n#define uset_getSerializedSet U_ICU_ENTRY_POINT_RENAME(uset_getSerializedSet)\n#define uset_indexOf U_ICU_ENTRY_POINT_RENAME(uset_indexOf)\n#define uset_isEmpty U_ICU_ENTRY_POINT_RENAME(uset_isEmpty)\n#define uset_isFrozen U_ICU_ENTRY_POINT_RENAME(uset_isFrozen)\n#define uset_open U_ICU_ENTRY_POINT_RENAME(uset_open)\n#define uset_openEmpty U_ICU_ENTRY_POINT_RENAME(uset_openEmpty)\n#define uset_openPattern U_ICU_ENTRY_POINT_RENAME(uset_openPattern)\n#define uset_openPatternOptions U_ICU_ENTRY_POINT_RENAME(uset_openPatternOptions)\n#define uset_remove U_ICU_ENTRY_POINT_RENAME(uset_remove)\n#define uset_removeAll U_ICU_ENTRY_POINT_RENAME(uset_removeAll)\n#define uset_removeAllStrings U_ICU_ENTRY_POINT_RENAME(uset_removeAllStrings)\n#define uset_removeRange U_ICU_ENTRY_POINT_RENAME(uset_removeRange)\n#define uset_removeString U_ICU_ENTRY_POINT_RENAME(uset_removeString)\n#define uset_resemblesPattern U_ICU_ENTRY_POINT_RENAME(uset_resemblesPattern)\n#define uset_retain U_ICU_ENTRY_POINT_RENAME(uset_retain)\n#define uset_retainAll U_ICU_ENTRY_POINT_RENAME(uset_retainAll)\n#define uset_serialize U_ICU_ENTRY_POINT_RENAME(uset_serialize)\n#define uset_serializedContains U_ICU_ENTRY_POINT_RENAME(uset_serializedContains)\n#define uset_set U_ICU_ENTRY_POINT_RENAME(uset_set)\n#define uset_setSerializedToOne U_ICU_ENTRY_POINT_RENAME(uset_setSerializedToOne)\n#define uset_size U_ICU_ENTRY_POINT_RENAME(uset_size)\n#define uset_span U_ICU_ENTRY_POINT_RENAME(uset_span)\n#define uset_spanBack U_ICU_ENTRY_POINT_RENAME(uset_spanBack)\n#define uset_spanBackUTF8 U_ICU_ENTRY_POINT_RENAME(uset_spanBackUTF8)\n#define uset_spanUTF8 U_ICU_ENTRY_POINT_RENAME(uset_spanUTF8)\n#define uset_toPattern U_ICU_ENTRY_POINT_RENAME(uset_toPattern)\n#define uspoof_areConfusable U_ICU_ENTRY_POINT_RENAME(uspoof_areConfusable)\n#define uspoof_areConfusableUTF8 U_ICU_ENTRY_POINT_RENAME(uspoof_areConfusableUTF8)\n#define uspoof_areConfusableUnicodeString U_ICU_ENTRY_POINT_RENAME(uspoof_areConfusableUnicodeString)\n#define uspoof_check U_ICU_ENTRY_POINT_RENAME(uspoof_check)\n#define uspoof_check2 U_ICU_ENTRY_POINT_RENAME(uspoof_check2)\n#define uspoof_check2UTF8 U_ICU_ENTRY_POINT_RENAME(uspoof_check2UTF8)\n#define uspoof_check2UnicodeString U_ICU_ENTRY_POINT_RENAME(uspoof_check2UnicodeString)\n#define uspoof_checkUTF8 U_ICU_ENTRY_POINT_RENAME(uspoof_checkUTF8)\n#define uspoof_checkUnicodeString U_ICU_ENTRY_POINT_RENAME(uspoof_checkUnicodeString)\n#define uspoof_clone U_ICU_ENTRY_POINT_RENAME(uspoof_clone)\n#define uspoof_close U_ICU_ENTRY_POINT_RENAME(uspoof_close)\n#define uspoof_closeCheckResult U_ICU_ENTRY_POINT_RENAME(uspoof_closeCheckResult)\n#define uspoof_getAllowedChars U_ICU_ENTRY_POINT_RENAME(uspoof_getAllowedChars)\n#define uspoof_getAllowedLocales U_ICU_ENTRY_POINT_RENAME(uspoof_getAllowedLocales)\n#define uspoof_getAllowedUnicodeSet U_ICU_ENTRY_POINT_RENAME(uspoof_getAllowedUnicodeSet)\n#define uspoof_getCheckResultChecks U_ICU_ENTRY_POINT_RENAME(uspoof_getCheckResultChecks)\n#define uspoof_getCheckResultNumerics U_ICU_ENTRY_POINT_RENAME(uspoof_getCheckResultNumerics)\n#define uspoof_getCheckResultRestrictionLevel U_ICU_ENTRY_POINT_RENAME(uspoof_getCheckResultRestrictionLevel)\n#define uspoof_getChecks U_ICU_ENTRY_POINT_RENAME(uspoof_getChecks)\n#define uspoof_getInclusionSet U_ICU_ENTRY_POINT_RENAME(uspoof_getInclusionSet)\n#define uspoof_getInclusionUnicodeSet U_ICU_ENTRY_POINT_RENAME(uspoof_getInclusionUnicodeSet)\n#define uspoof_getRecommendedSet U_ICU_ENTRY_POINT_RENAME(uspoof_getRecommendedSet)\n#define uspoof_getRecommendedUnicodeSet U_ICU_ENTRY_POINT_RENAME(uspoof_getRecommendedUnicodeSet)\n#define uspoof_getRestrictionLevel U_ICU_ENTRY_POINT_RENAME(uspoof_getRestrictionLevel)\n#define uspoof_getSkeleton U_ICU_ENTRY_POINT_RENAME(uspoof_getSkeleton)\n#define uspoof_getSkeletonUTF8 U_ICU_ENTRY_POINT_RENAME(uspoof_getSkeletonUTF8)\n#define uspoof_getSkeletonUnicodeString U_ICU_ENTRY_POINT_RENAME(uspoof_getSkeletonUnicodeString)\n#define uspoof_internalInitStatics U_ICU_ENTRY_POINT_RENAME(uspoof_internalInitStatics)\n#define uspoof_open U_ICU_ENTRY_POINT_RENAME(uspoof_open)\n#define uspoof_openCheckResult U_ICU_ENTRY_POINT_RENAME(uspoof_openCheckResult)\n#define uspoof_openFromSerialized U_ICU_ENTRY_POINT_RENAME(uspoof_openFromSerialized)\n#define uspoof_openFromSource U_ICU_ENTRY_POINT_RENAME(uspoof_openFromSource)\n#define uspoof_serialize U_ICU_ENTRY_POINT_RENAME(uspoof_serialize)\n#define uspoof_setAllowedChars U_ICU_ENTRY_POINT_RENAME(uspoof_setAllowedChars)\n#define uspoof_setAllowedLocales U_ICU_ENTRY_POINT_RENAME(uspoof_setAllowedLocales)\n#define uspoof_setAllowedUnicodeSet U_ICU_ENTRY_POINT_RENAME(uspoof_setAllowedUnicodeSet)\n#define uspoof_setChecks U_ICU_ENTRY_POINT_RENAME(uspoof_setChecks)\n#define uspoof_setRestrictionLevel U_ICU_ENTRY_POINT_RENAME(uspoof_setRestrictionLevel)\n#define uspoof_swap U_ICU_ENTRY_POINT_RENAME(uspoof_swap)\n#define usprep_close U_ICU_ENTRY_POINT_RENAME(usprep_close)\n#define usprep_open U_ICU_ENTRY_POINT_RENAME(usprep_open)\n#define usprep_openByType U_ICU_ENTRY_POINT_RENAME(usprep_openByType)\n#define usprep_prepare U_ICU_ENTRY_POINT_RENAME(usprep_prepare)\n#define usprep_swap U_ICU_ENTRY_POINT_RENAME(usprep_swap)\n#define ustr_hashCharsN U_ICU_ENTRY_POINT_RENAME(ustr_hashCharsN)\n#define ustr_hashICharsN U_ICU_ENTRY_POINT_RENAME(ustr_hashICharsN)\n#define ustr_hashUCharsN U_ICU_ENTRY_POINT_RENAME(ustr_hashUCharsN)\n#define ustrcase_getCaseLocale U_ICU_ENTRY_POINT_RENAME(ustrcase_getCaseLocale)\n#define ustrcase_internalFold U_ICU_ENTRY_POINT_RENAME(ustrcase_internalFold)\n#define ustrcase_internalToLower U_ICU_ENTRY_POINT_RENAME(ustrcase_internalToLower)\n#define ustrcase_internalToTitle U_ICU_ENTRY_POINT_RENAME(ustrcase_internalToTitle)\n#define ustrcase_internalToUpper U_ICU_ENTRY_POINT_RENAME(ustrcase_internalToUpper)\n#define ustrcase_map U_ICU_ENTRY_POINT_RENAME(ustrcase_map)\n#define ustrcase_mapWithOverlap U_ICU_ENTRY_POINT_RENAME(ustrcase_mapWithOverlap)\n#define utext_char32At U_ICU_ENTRY_POINT_RENAME(utext_char32At)\n#define utext_clone U_ICU_ENTRY_POINT_RENAME(utext_clone)\n#define utext_close U_ICU_ENTRY_POINT_RENAME(utext_close)\n#define utext_copy U_ICU_ENTRY_POINT_RENAME(utext_copy)\n#define utext_current32 U_ICU_ENTRY_POINT_RENAME(utext_current32)\n#define utext_equals U_ICU_ENTRY_POINT_RENAME(utext_equals)\n#define utext_extract U_ICU_ENTRY_POINT_RENAME(utext_extract)\n#define utext_freeze U_ICU_ENTRY_POINT_RENAME(utext_freeze)\n#define utext_getNativeIndex U_ICU_ENTRY_POINT_RENAME(utext_getNativeIndex)\n#define utext_getPreviousNativeIndex U_ICU_ENTRY_POINT_RENAME(utext_getPreviousNativeIndex)\n#define utext_hasMetaData U_ICU_ENTRY_POINT_RENAME(utext_hasMetaData)\n#define utext_isLengthExpensive U_ICU_ENTRY_POINT_RENAME(utext_isLengthExpensive)\n#define utext_isWritable U_ICU_ENTRY_POINT_RENAME(utext_isWritable)\n#define utext_moveIndex32 U_ICU_ENTRY_POINT_RENAME(utext_moveIndex32)\n#define utext_nativeLength U_ICU_ENTRY_POINT_RENAME(utext_nativeLength)\n#define utext_next32 U_ICU_ENTRY_POINT_RENAME(utext_next32)\n#define utext_next32From U_ICU_ENTRY_POINT_RENAME(utext_next32From)\n#define utext_openCharacterIterator U_ICU_ENTRY_POINT_RENAME(utext_openCharacterIterator)\n#define utext_openConstUnicodeString U_ICU_ENTRY_POINT_RENAME(utext_openConstUnicodeString)\n#define utext_openReplaceable U_ICU_ENTRY_POINT_RENAME(utext_openReplaceable)\n#define utext_openUChars U_ICU_ENTRY_POINT_RENAME(utext_openUChars)\n#define utext_openUTF8 U_ICU_ENTRY_POINT_RENAME(utext_openUTF8)\n#define utext_openUnicodeString U_ICU_ENTRY_POINT_RENAME(utext_openUnicodeString)\n#define utext_previous32 U_ICU_ENTRY_POINT_RENAME(utext_previous32)\n#define utext_previous32From U_ICU_ENTRY_POINT_RENAME(utext_previous32From)\n#define utext_replace U_ICU_ENTRY_POINT_RENAME(utext_replace)\n#define utext_setNativeIndex U_ICU_ENTRY_POINT_RENAME(utext_setNativeIndex)\n#define utext_setup U_ICU_ENTRY_POINT_RENAME(utext_setup)\n#define utf8_appendCharSafeBody U_ICU_ENTRY_POINT_RENAME(utf8_appendCharSafeBody)\n#define utf8_back1SafeBody U_ICU_ENTRY_POINT_RENAME(utf8_back1SafeBody)\n#define utf8_countTrailBytes U_ICU_ENTRY_POINT_RENAME(utf8_countTrailBytes)\n#define utf8_nextCharSafeBody U_ICU_ENTRY_POINT_RENAME(utf8_nextCharSafeBody)\n#define utf8_prevCharSafeBody U_ICU_ENTRY_POINT_RENAME(utf8_prevCharSafeBody)\n#define utmscale_fromInt64 U_ICU_ENTRY_POINT_RENAME(utmscale_fromInt64)\n#define utmscale_getTimeScaleValue U_ICU_ENTRY_POINT_RENAME(utmscale_getTimeScaleValue)\n#define utmscale_toInt64 U_ICU_ENTRY_POINT_RENAME(utmscale_toInt64)\n#define utrace_cleanup U_ICU_ENTRY_POINT_RENAME(utrace_cleanup)\n#define utrace_data U_ICU_ENTRY_POINT_RENAME(utrace_data)\n#define utrace_entry U_ICU_ENTRY_POINT_RENAME(utrace_entry)\n#define utrace_exit U_ICU_ENTRY_POINT_RENAME(utrace_exit)\n#define utrace_format U_ICU_ENTRY_POINT_RENAME(utrace_format)\n#define utrace_functionName U_ICU_ENTRY_POINT_RENAME(utrace_functionName)\n#define utrace_getFunctions U_ICU_ENTRY_POINT_RENAME(utrace_getFunctions)\n#define utrace_getLevel U_ICU_ENTRY_POINT_RENAME(utrace_getLevel)\n#define utrace_setFunctions U_ICU_ENTRY_POINT_RENAME(utrace_setFunctions)\n#define utrace_setLevel U_ICU_ENTRY_POINT_RENAME(utrace_setLevel)\n#define utrace_vformat U_ICU_ENTRY_POINT_RENAME(utrace_vformat)\n#define utrans_clone U_ICU_ENTRY_POINT_RENAME(utrans_clone)\n#define utrans_close U_ICU_ENTRY_POINT_RENAME(utrans_close)\n#define utrans_countAvailableIDs U_ICU_ENTRY_POINT_RENAME(utrans_countAvailableIDs)\n#define utrans_getAvailableID U_ICU_ENTRY_POINT_RENAME(utrans_getAvailableID)\n#define utrans_getID U_ICU_ENTRY_POINT_RENAME(utrans_getID)\n#define utrans_getSourceSet U_ICU_ENTRY_POINT_RENAME(utrans_getSourceSet)\n#define utrans_getUnicodeID U_ICU_ENTRY_POINT_RENAME(utrans_getUnicodeID)\n#define utrans_open U_ICU_ENTRY_POINT_RENAME(utrans_open)\n#define utrans_openIDs U_ICU_ENTRY_POINT_RENAME(utrans_openIDs)\n#define utrans_openInverse U_ICU_ENTRY_POINT_RENAME(utrans_openInverse)\n#define utrans_openU U_ICU_ENTRY_POINT_RENAME(utrans_openU)\n#define utrans_register U_ICU_ENTRY_POINT_RENAME(utrans_register)\n#define utrans_rep_caseContextIterator U_ICU_ENTRY_POINT_RENAME(utrans_rep_caseContextIterator)\n#define utrans_setFilter U_ICU_ENTRY_POINT_RENAME(utrans_setFilter)\n#define utrans_stripRules U_ICU_ENTRY_POINT_RENAME(utrans_stripRules)\n#define utrans_toRules U_ICU_ENTRY_POINT_RENAME(utrans_toRules)\n#define utrans_trans U_ICU_ENTRY_POINT_RENAME(utrans_trans)\n#define utrans_transIncremental U_ICU_ENTRY_POINT_RENAME(utrans_transIncremental)\n#define utrans_transIncrementalUChars U_ICU_ENTRY_POINT_RENAME(utrans_transIncrementalUChars)\n#define utrans_transUChars U_ICU_ENTRY_POINT_RENAME(utrans_transUChars)\n#define utrans_transliterator_cleanup U_ICU_ENTRY_POINT_RENAME(utrans_transliterator_cleanup)\n#define utrans_unregister U_ICU_ENTRY_POINT_RENAME(utrans_unregister)\n#define utrans_unregisterID U_ICU_ENTRY_POINT_RENAME(utrans_unregisterID)\n#define utrie2_clone U_ICU_ENTRY_POINT_RENAME(utrie2_clone)\n#define utrie2_cloneAsThawed U_ICU_ENTRY_POINT_RENAME(utrie2_cloneAsThawed)\n#define utrie2_close U_ICU_ENTRY_POINT_RENAME(utrie2_close)\n#define utrie2_enum U_ICU_ENTRY_POINT_RENAME(utrie2_enum)\n#define utrie2_enumForLeadSurrogate U_ICU_ENTRY_POINT_RENAME(utrie2_enumForLeadSurrogate)\n#define utrie2_freeze U_ICU_ENTRY_POINT_RENAME(utrie2_freeze)\n#define utrie2_fromUTrie U_ICU_ENTRY_POINT_RENAME(utrie2_fromUTrie)\n#define utrie2_get32 U_ICU_ENTRY_POINT_RENAME(utrie2_get32)\n#define utrie2_get32FromLeadSurrogateCodeUnit U_ICU_ENTRY_POINT_RENAME(utrie2_get32FromLeadSurrogateCodeUnit)\n#define utrie2_getVersion U_ICU_ENTRY_POINT_RENAME(utrie2_getVersion)\n#define utrie2_internalU8NextIndex U_ICU_ENTRY_POINT_RENAME(utrie2_internalU8NextIndex)\n#define utrie2_internalU8PrevIndex U_ICU_ENTRY_POINT_RENAME(utrie2_internalU8PrevIndex)\n#define utrie2_isFrozen U_ICU_ENTRY_POINT_RENAME(utrie2_isFrozen)\n#define utrie2_open U_ICU_ENTRY_POINT_RENAME(utrie2_open)\n#define utrie2_openDummy U_ICU_ENTRY_POINT_RENAME(utrie2_openDummy)\n#define utrie2_openFromSerialized U_ICU_ENTRY_POINT_RENAME(utrie2_openFromSerialized)\n#define utrie2_serialize U_ICU_ENTRY_POINT_RENAME(utrie2_serialize)\n#define utrie2_set32 U_ICU_ENTRY_POINT_RENAME(utrie2_set32)\n#define utrie2_set32ForLeadSurrogateCodeUnit U_ICU_ENTRY_POINT_RENAME(utrie2_set32ForLeadSurrogateCodeUnit)\n#define utrie2_setRange32 U_ICU_ENTRY_POINT_RENAME(utrie2_setRange32)\n#define utrie2_swap U_ICU_ENTRY_POINT_RENAME(utrie2_swap)\n#define utrie2_swapAnyVersion U_ICU_ENTRY_POINT_RENAME(utrie2_swapAnyVersion)\n#define utrie_clone U_ICU_ENTRY_POINT_RENAME(utrie_clone)\n#define utrie_close U_ICU_ENTRY_POINT_RENAME(utrie_close)\n#define utrie_defaultGetFoldingOffset U_ICU_ENTRY_POINT_RENAME(utrie_defaultGetFoldingOffset)\n#define utrie_enum U_ICU_ENTRY_POINT_RENAME(utrie_enum)\n#define utrie_get32 U_ICU_ENTRY_POINT_RENAME(utrie_get32)\n#define utrie_getData U_ICU_ENTRY_POINT_RENAME(utrie_getData)\n#define utrie_open U_ICU_ENTRY_POINT_RENAME(utrie_open)\n#define utrie_serialize U_ICU_ENTRY_POINT_RENAME(utrie_serialize)\n#define utrie_set32 U_ICU_ENTRY_POINT_RENAME(utrie_set32)\n#define utrie_setRange32 U_ICU_ENTRY_POINT_RENAME(utrie_setRange32)\n#define utrie_swap U_ICU_ENTRY_POINT_RENAME(utrie_swap)\n#define utrie_unserialize U_ICU_ENTRY_POINT_RENAME(utrie_unserialize)\n#define utrie_unserializeDummy U_ICU_ENTRY_POINT_RENAME(utrie_unserializeDummy)\n#define vzone_clone U_ICU_ENTRY_POINT_RENAME(vzone_clone)\n#define vzone_close U_ICU_ENTRY_POINT_RENAME(vzone_close)\n#define vzone_countTransitionRules U_ICU_ENTRY_POINT_RENAME(vzone_countTransitionRules)\n#define vzone_equals U_ICU_ENTRY_POINT_RENAME(vzone_equals)\n#define vzone_getDynamicClassID U_ICU_ENTRY_POINT_RENAME(vzone_getDynamicClassID)\n#define vzone_getLastModified U_ICU_ENTRY_POINT_RENAME(vzone_getLastModified)\n#define vzone_getNextTransition U_ICU_ENTRY_POINT_RENAME(vzone_getNextTransition)\n#define vzone_getOffset U_ICU_ENTRY_POINT_RENAME(vzone_getOffset)\n#define vzone_getOffset2 U_ICU_ENTRY_POINT_RENAME(vzone_getOffset2)\n#define vzone_getOffset3 U_ICU_ENTRY_POINT_RENAME(vzone_getOffset3)\n#define vzone_getPreviousTransition U_ICU_ENTRY_POINT_RENAME(vzone_getPreviousTransition)\n#define vzone_getRawOffset U_ICU_ENTRY_POINT_RENAME(vzone_getRawOffset)\n#define vzone_getStaticClassID U_ICU_ENTRY_POINT_RENAME(vzone_getStaticClassID)\n#define vzone_getTZURL U_ICU_ENTRY_POINT_RENAME(vzone_getTZURL)\n#define vzone_hasSameRules U_ICU_ENTRY_POINT_RENAME(vzone_hasSameRules)\n#define vzone_inDaylightTime U_ICU_ENTRY_POINT_RENAME(vzone_inDaylightTime)\n#define vzone_openData U_ICU_ENTRY_POINT_RENAME(vzone_openData)\n#define vzone_openID U_ICU_ENTRY_POINT_RENAME(vzone_openID)\n#define vzone_setLastModified U_ICU_ENTRY_POINT_RENAME(vzone_setLastModified)\n#define vzone_setRawOffset U_ICU_ENTRY_POINT_RENAME(vzone_setRawOffset)\n#define vzone_setTZURL U_ICU_ENTRY_POINT_RENAME(vzone_setTZURL)\n#define vzone_useDaylightTime U_ICU_ENTRY_POINT_RENAME(vzone_useDaylightTime)\n#define vzone_write U_ICU_ENTRY_POINT_RENAME(vzone_write)\n#define vzone_writeFromStart U_ICU_ENTRY_POINT_RENAME(vzone_writeFromStart)\n#define vzone_writeSimple U_ICU_ENTRY_POINT_RENAME(vzone_writeSimple)\n#define zrule_close U_ICU_ENTRY_POINT_RENAME(zrule_close)\n#define zrule_equals U_ICU_ENTRY_POINT_RENAME(zrule_equals)\n#define zrule_getDSTSavings U_ICU_ENTRY_POINT_RENAME(zrule_getDSTSavings)\n#define zrule_getName U_ICU_ENTRY_POINT_RENAME(zrule_getName)\n#define zrule_getRawOffset U_ICU_ENTRY_POINT_RENAME(zrule_getRawOffset)\n#define zrule_isEquivalentTo U_ICU_ENTRY_POINT_RENAME(zrule_isEquivalentTo)\n#define ztrans_adoptFrom U_ICU_ENTRY_POINT_RENAME(ztrans_adoptFrom)\n#define ztrans_adoptTo U_ICU_ENTRY_POINT_RENAME(ztrans_adoptTo)\n#define ztrans_clone U_ICU_ENTRY_POINT_RENAME(ztrans_clone)\n#define ztrans_close U_ICU_ENTRY_POINT_RENAME(ztrans_close)\n#define ztrans_equals U_ICU_ENTRY_POINT_RENAME(ztrans_equals)\n#define ztrans_getDynamicClassID U_ICU_ENTRY_POINT_RENAME(ztrans_getDynamicClassID)\n#define ztrans_getFrom U_ICU_ENTRY_POINT_RENAME(ztrans_getFrom)\n#define ztrans_getStaticClassID U_ICU_ENTRY_POINT_RENAME(ztrans_getStaticClassID)\n#define ztrans_getTime U_ICU_ENTRY_POINT_RENAME(ztrans_getTime)\n#define ztrans_getTo U_ICU_ENTRY_POINT_RENAME(ztrans_getTo)\n#define ztrans_open U_ICU_ENTRY_POINT_RENAME(ztrans_open)\n#define ztrans_openEmpty U_ICU_ENTRY_POINT_RENAME(ztrans_openEmpty)\n#define ztrans_setFrom U_ICU_ENTRY_POINT_RENAME(ztrans_setFrom)\n#define ztrans_setTime U_ICU_ENTRY_POINT_RENAME(ztrans_setTime)\n#define ztrans_setTo U_ICU_ENTRY_POINT_RENAME(ztrans_setTo)\n\n#endif\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/sql-common/client_plugin.cc": "/* Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License, version 2.0,\n   as published by the Free Software Foundation.\n\n   This program is also distributed with certain software (including\n   but not limited to OpenSSL) that is licensed under separate terms,\n   as designated in a particular file or component or in included license\n   documentation.  The authors of MySQL hereby grant you an additional\n   permission to link the program and your derivative works with the\n   separately licensed software that they have included with MySQL.\n\n   Without limiting anything contained in the foregoing, this file,\n   which is part of C Driver for MySQL (Connector/C), is also subject to the\n   Universal FOSS Exception, version 1.0, a copy of which can be found at\n   http://oss.oracle.com/licenses/universal-foss-exception.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License, version 2.0, for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/**\n  @file\n\n  Support code for the client side (libmysql) plugins\n\n  Client plugins are somewhat different from server plugins, they are simpler.\n\n  They do not need to be installed or in any way explicitly loaded on the\n  client, they are loaded automatically on demand.\n  One client plugin per shared object, soname *must* match the plugin name.\n\n  There is no reference counting and no unloading either.\n*/\n\n#include \"my_config.h\"\n\n#include <mysql/client_plugin.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <sys/types.h>\n\n#include \"errmsg.h\"\n#include \"m_string.h\"\n#include \"my_alloc.h\"\n#include \"my_dbug.h\"\n#include \"my_inttypes.h\"\n#include \"my_io.h\"\n#include \"my_macros.h\"\n#include \"my_psi_config.h\"\n#include \"my_sys.h\"\n#include \"my_thread.h\"\n#include \"mysql.h\"\n#include \"mysql/psi/mysql_memory.h\"\n#include \"mysql/psi/mysql_mutex.h\"\n#include \"mysql/service_mysql_alloc.h\"\n#include \"sql_common.h\"\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#if defined(CLIENT_PROTOCOL_TRACING)\n#include <mysql/plugin_trace.h>\n#endif\n\nPSI_memory_key key_memory_root;\nPSI_memory_key key_memory_load_env_plugins;\n\nPSI_mutex_key key_mutex_LOCK_load_client_plugin;\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_mutex_info all_client_plugin_mutexes[] = {\n    {&key_mutex_LOCK_load_client_plugin, \"LOCK_load_client_plugin\",\n     PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME}};\n\nstatic PSI_memory_info all_client_plugin_memory[] = {\n    {&key_memory_root, \"root\", PSI_FLAG_ONLY_GLOBAL_STAT, 0, PSI_DOCUMENT_ME},\n    {&key_memory_load_env_plugins, \"load_env_plugins\",\n     PSI_FLAG_ONLY_GLOBAL_STAT, 0, PSI_DOCUMENT_ME}};\n\nstatic void init_client_plugin_psi_keys() {\n  const char *category = \"sql\";\n  int count;\n\n  count = array_elements(all_client_plugin_mutexes);\n  mysql_mutex_register(category, all_client_plugin_mutexes, count);\n\n  count = array_elements(all_client_plugin_memory);\n  mysql_memory_register(category, all_client_plugin_memory, count);\n}\n#endif /* HAVE_PSI_INTERFACE */\n\nstruct st_client_plugin_int {\n  struct st_client_plugin_int *next;\n  void *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n};\n\nstatic bool initialized = 0;\nstatic MEM_ROOT mem_root;\n\nstatic const char *plugin_declarations_sym =\n    \"_mysql_client_plugin_declaration_\";\nstatic uint plugin_version[MYSQL_CLIENT_MAX_PLUGINS] = {\n    0, /* these two are taken by Connector/C */\n    0, /* these two are taken by Connector/C */\n    MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION,\n    MYSQL_CLIENT_TRACE_PLUGIN_INTERFACE_VERSION,\n};\n\n/*\n  Loaded plugins are stored in a linked list.\n  The list is append-only, the elements are added to the head (like in a stack).\n  The elements are added under a mutex, but the list can be read and traversed\n  without any mutex because once an element is added to the list, it stays\n  there. The main purpose of a mutex is to prevent two threads from\n  loading the same plugin twice in parallel.\n*/\nstruct st_client_plugin_int *plugin_list[MYSQL_CLIENT_MAX_PLUGINS];\nstatic mysql_mutex_t LOCK_load_client_plugin;\n\nstatic int is_not_initialized(MYSQL *mysql, const char *name) {\n  if (initialized) return 0;\n\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER_CLIENT(CR_AUTH_PLUGIN_CANNOT_LOAD), name,\n                           \"not initialized\");\n  return 1;\n}\n\n/**\n  finds a plugin in the list\n\n  @param name   plugin name to search for\n  @param type   plugin type\n\n  @note this does NOT necessarily need a mutex, take care!\n\n  @retval a pointer to a found plugin or 0\n*/\nstatic struct st_mysql_client_plugin *find_plugin(const char *name, int type) {\n  struct st_client_plugin_int *p;\n\n  DBUG_ASSERT(initialized);\n  DBUG_ASSERT(type >= 0 && type < MYSQL_CLIENT_MAX_PLUGINS);\n  if (type < 0 || type >= MYSQL_CLIENT_MAX_PLUGINS) return 0;\n\n  for (p = plugin_list[type]; p; p = p->next) {\n    if (strcmp(p->plugin->name, name) == 0) return p->plugin;\n  }\n  return NULL;\n}\n\n/**\n  verifies the plugin and adds it to the list\n\n  @param mysql          MYSQL structure (for error reporting)\n  @param plugin         plugin to install\n  @param dlhandle       a handle to the shared object (returned by dlopen)\n                        or 0 if the plugin was not dynamically loaded\n  @param argc           number of arguments in the 'va_list args'\n  @param args           arguments passed to the plugin initialization function\n\n  @retval a pointer to an installed plugin or 0\n*/\nstatic struct st_mysql_client_plugin *do_add_plugin(\n    MYSQL *mysql, struct st_mysql_client_plugin *plugin, void *dlhandle,\n    int argc, va_list args) {\n  const char *errmsg;\n  struct st_client_plugin_int plugin_int, *p;\n  char errbuf[1024];\n\n  DBUG_ASSERT(initialized);\n\n  plugin_int.plugin = plugin;\n  plugin_int.dlhandle = dlhandle;\n\n  if (plugin->type >= MYSQL_CLIENT_MAX_PLUGINS) {\n    errmsg = \"Unknown client plugin type\";\n    goto err1;\n  }\n\n  if (plugin->interface_version < plugin_version[plugin->type] ||\n      (plugin->interface_version >> 8) > (plugin_version[plugin->type] >> 8)) {\n    errmsg = \"Incompatible client plugin interface\";\n    goto err1;\n  }\n\n#if defined(CLIENT_PROTOCOL_TRACING) && !defined(MYSQL_SERVER)\n  /*\n    If we try to load a protocol trace plugin but one is already\n    loaded (global trace_plugin pointer is not NULL) then we ignore\n    the new trace plugin and give error. This is done before the\n    new plugin gets initialized.\n  */\n  if (plugin->type == MYSQL_CLIENT_TRACE_PLUGIN && NULL != trace_plugin) {\n    errmsg = \"Can not load another trace plugin while one is already loaded\";\n    goto err1;\n  }\n#endif\n\n  /* Call the plugin initialization function, if any */\n  if (plugin->init && plugin->init(errbuf, sizeof(errbuf), argc, args)) {\n    errmsg = errbuf;\n    goto err1;\n  }\n\n  p = (struct st_client_plugin_int *)memdup_root(&mem_root, &plugin_int,\n                                                 sizeof(plugin_int));\n\n  if (!p) {\n    errmsg = \"Out of memory\";\n    goto err2;\n  }\n\n  mysql_mutex_assert_owner(&LOCK_load_client_plugin);\n\n  p->next = plugin_list[plugin->type];\n  plugin_list[plugin->type] = p;\n  net_clear_error(&mysql->net);\n\n#if defined(CLIENT_PROTOCOL_TRACING) && !defined(MYSQL_SERVER)\n  /*\n    If loaded plugin is a protocol trace one, then set the global\n    trace_plugin pointer to point at it. When trace_plugin is not NULL,\n    each new connection will be traced using the plugin pointed by it\n    (see MYSQL_TRACE_STAGE() macro in libmysql/mysql_trace.h).\n  */\n  if (plugin->type == MYSQL_CLIENT_TRACE_PLUGIN) {\n    trace_plugin = (struct st_mysql_client_plugin_TRACE *)plugin;\n  }\n#endif\n\n  return plugin;\n\nerr2:\n  if (plugin->deinit) plugin->deinit();\nerr1:\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER_CLIENT(CR_AUTH_PLUGIN_CANNOT_LOAD), plugin->name,\n                           errmsg);\n  if (dlhandle) dlclose(dlhandle);\n  return NULL;\n}\n\nstatic struct st_mysql_client_plugin *add_plugin_noargs(\n    MYSQL *mysql, struct st_mysql_client_plugin *plugin, void *dlhandle,\n    int argc, ...) {\n  struct st_mysql_client_plugin *retval = NULL;\n  va_list ap;\n  va_start(ap, argc);\n  retval = do_add_plugin(mysql, plugin, dlhandle, argc, ap);\n  va_end(ap);\n  return retval;\n}\n\nstatic struct st_mysql_client_plugin *add_plugin_withargs(\n    MYSQL *mysql, struct st_mysql_client_plugin *plugin, void *dlhandle,\n    int argc, va_list args) {\n  return do_add_plugin(mysql, plugin, dlhandle, argc, args);\n}\n\n/**\n  Loads plugins which are specified in the environment variable\n  LIBMYSQL_PLUGINS.\n\n  Multiple plugins must be separated by semicolon. This function doesn't\n  return or log an error.\n\n  The function is be called by mysql_client_plugin_init\n\n  @todo\n  Support extended syntax, passing parameters to plugins, for example\n  LIBMYSQL_PLUGINS=\"plugin1(param1,param2);plugin2;...\"\n  or\n  LIBMYSQL_PLUGINS=\"plugin1=int:param1,str:param2;plugin2;...\"\n*/\nstatic void load_env_plugins(MYSQL *mysql) {\n  char *plugs, *free_env, *s = getenv(\"LIBMYSQL_PLUGINS\");\n  char *enable_cleartext_plugin = getenv(\"LIBMYSQL_ENABLE_CLEARTEXT_PLUGIN\");\n\n  if (enable_cleartext_plugin && strchr(\"1Yy\", enable_cleartext_plugin[0]))\n    libmysql_cleartext_plugin_enabled = 1;\n\n  /* no plugins to load */\n  if (!s) return;\n\n  free_env = plugs = my_strdup(key_memory_load_env_plugins, s, MYF(MY_WME));\n\n  do {\n    if ((s = strchr(plugs, ';'))) *s = '\\0';\n    mysql_load_plugin(mysql, plugs, -1, 0);\n    plugs = s + 1;\n  } while (s);\n\n  my_free(free_env);\n}\n\n/********** extern functions to be used by libmysql *********************/\n\n/**\n  Initializes the client plugin layer.\n\n  This function must be called before any other client plugin function.\n\n  @retval 0    successful\n  @retval != 0 error occured\n*/\nint mysql_client_plugin_init() {\n  MYSQL mysql;\n  struct st_mysql_client_plugin **builtin;\n\n  if (initialized) return 0;\n\n#ifdef HAVE_PSI_INTERFACE\n  init_client_plugin_psi_keys();\n#endif /* HAVE_PSI_INTERFACE */\n\n  memset(&mysql, 0,\n         sizeof(mysql)); /* dummy mysql for set_mysql_extended_error */\n\n  mysql_mutex_init(key_mutex_LOCK_load_client_plugin, &LOCK_load_client_plugin,\n                   MY_MUTEX_INIT_SLOW);\n  init_alloc_root(key_memory_root, &mem_root, 128, 128);\n\n  memset(&plugin_list, 0, sizeof(plugin_list));\n\n  initialized = 1;\n\n  mysql_mutex_lock(&LOCK_load_client_plugin);\n\n  for (builtin = mysql_client_builtins; *builtin; builtin++)\n    add_plugin_noargs(&mysql, *builtin, 0, 0);\n\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n\n  load_env_plugins(&mysql);\n\n  mysql_close_free(&mysql);\n\n  return 0;\n}\n\n/**\n  Deinitializes the client plugin layer.\n\n  Unloades all client plugins and frees any associated resources.\n*/\nvoid mysql_client_plugin_deinit() {\n  int i;\n  struct st_client_plugin_int *p;\n\n  if (!initialized) return;\n\n  for (i = 0; i < MYSQL_CLIENT_MAX_PLUGINS; i++)\n    for (p = plugin_list[i]; p; p = p->next) {\n      if (p->plugin->deinit) p->plugin->deinit();\n      if (p->dlhandle) dlclose(p->dlhandle);\n    }\n\n  memset(&plugin_list, 0, sizeof(plugin_list));\n  initialized = 0;\n  free_root(&mem_root, MYF(0));\n  mysql_mutex_destroy(&LOCK_load_client_plugin);\n}\n\n/************* public facing functions, for client consumption *********/\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *mysql_client_register_plugin(\n    MYSQL *mysql, struct st_mysql_client_plugin *plugin) {\n  if (is_not_initialized(mysql, plugin->name)) return NULL;\n\n  mysql_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (find_plugin(plugin->name, plugin->type)) {\n    set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n                             unknown_sqlstate,\n                             ER_CLIENT(CR_AUTH_PLUGIN_CANNOT_LOAD),\n                             plugin->name, \"it is already loaded\");\n    plugin = NULL;\n  } else\n    plugin = add_plugin_noargs(mysql, plugin, 0, 0);\n\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n  return plugin;\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *mysql_load_plugin_v(MYSQL *mysql,\n                                                   const char *name, int type,\n                                                   int argc, va_list args) {\n  const char *errmsg;\n  char dlpath[FN_REFLEN + 1];\n  void *sym, *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n  const char *plugindir;\n#ifdef _WIN32\n  char win_errormsg[2048];\n#endif\n\n  DBUG_ENTER(\"mysql_load_plugin_v\");\n  DBUG_PRINT(\"entry\", (\"name=%s type=%d int argc=%d\", name, type, argc));\n  if (is_not_initialized(mysql, name)) {\n    DBUG_PRINT(\"leave\", (\"mysql not initialized\"));\n    DBUG_RETURN(NULL);\n  }\n\n  mysql_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (type >= 0 && find_plugin(name, type)) {\n    errmsg = \"it is already loaded\";\n    goto err;\n  }\n\n  if (mysql->options.extension && mysql->options.extension->plugin_dir) {\n    plugindir = mysql->options.extension->plugin_dir;\n  } else {\n    plugindir = getenv(\"LIBMYSQL_PLUGIN_DIR\");\n    if (!plugindir) {\n      plugindir = PLUGINDIR;\n    }\n  }\n\n  /* Compile dll path */\n  strxnmov(dlpath, sizeof(dlpath) - 1, plugindir, \"/\", name, SO_EXT, NullS);\n\n  DBUG_PRINT(\"info\", (\"dlopeninig %s\", dlpath));\n  /* Open new dll handle */\n  if (!(dlhandle = dlopen(dlpath, RTLD_NOW))) {\n#if defined(__APPLE__)\n    /* Apple supports plugins with .so also, so try this as well */\n    strxnmov(dlpath, sizeof(dlpath) - 1, plugindir, \"/\", name, \".so\", NullS);\n    if ((dlhandle = dlopen(dlpath, RTLD_NOW))) goto have_plugin;\n#endif\n\n#ifdef _WIN32\n    /* There should be no win32 calls between failed dlopen() and GetLastError()\n     */\n    if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, GetLastError(), 0,\n                      win_errormsg, 2048, NULL))\n      errmsg = win_errormsg;\n    else\n      errmsg = \"\";\n#else\n    errmsg = dlerror();\n#endif\n    DBUG_PRINT(\"info\", (\"failed to dlopen\"));\n    goto err;\n  }\n\n#if defined(__APPLE__)\nhave_plugin:\n#endif\n  if (!(sym = dlsym(dlhandle, plugin_declarations_sym))) {\n    errmsg = \"not a plugin\";\n    dlclose(dlhandle);\n    goto err;\n  }\n\n  plugin = (struct st_mysql_client_plugin *)sym;\n\n  if (type >= 0 && type != plugin->type) {\n    errmsg = \"type mismatch\";\n    goto err;\n  }\n\n  if (strcmp(name, plugin->name)) {\n    errmsg = \"name mismatch\";\n    goto err;\n  }\n\n  if (type < 0 && find_plugin(name, plugin->type)) {\n    errmsg = \"it is already loaded\";\n    goto err;\n  }\n\n  plugin = add_plugin_withargs(mysql, plugin, dlhandle, argc, args);\n\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n\n  DBUG_PRINT(\"leave\", (\"plugin loaded ok\"));\n  DBUG_RETURN(plugin);\n\nerr:\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n  DBUG_PRINT(\"leave\", (\"plugin load error : %s\", errmsg));\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER_CLIENT(CR_AUTH_PLUGIN_CANNOT_LOAD), name, errmsg);\n  DBUG_RETURN(NULL);\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *mysql_load_plugin(MYSQL *mysql, const char *name,\n                                                 int type, int argc, ...) {\n  struct st_mysql_client_plugin *p;\n  va_list args;\n  va_start(args, argc);\n  p = mysql_load_plugin_v(mysql, name, type, argc, args);\n  va_end(args);\n  return p;\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *mysql_client_find_plugin(MYSQL *mysql,\n                                                        const char *name,\n                                                        int type) {\n  struct st_mysql_client_plugin *p;\n\n  DBUG_ENTER(\"mysql_client_find_plugin\");\n  DBUG_PRINT(\"entry\", (\"name=%s, type=%d\", name, type));\n  if (is_not_initialized(mysql, name)) DBUG_RETURN(NULL);\n\n  if (type < 0 || type >= MYSQL_CLIENT_MAX_PLUGINS) {\n    set_mysql_extended_error(\n        mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n        ER_CLIENT(CR_AUTH_PLUGIN_CANNOT_LOAD), name, \"invalid type\");\n  }\n\n  if ((p = find_plugin(name, type))) {\n    DBUG_PRINT(\"leave\", (\"found %p\", p));\n    DBUG_RETURN(p);\n  }\n\n  /* not found, load it */\n  p = mysql_load_plugin(mysql, name, type, 0);\n  DBUG_PRINT(\"leave\", (\"loaded %p\", p));\n  DBUG_RETURN(p);\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nint mysql_plugin_options(struct st_mysql_client_plugin *plugin,\n                         const char *option, const void *value) {\n  DBUG_ENTER(\"mysql_plugin_options\");\n  /* does the plugin support options call? */\n  if (!plugin || !plugin->options) DBUG_RETURN(1);\n  DBUG_RETURN(plugin->options(option, value));\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/valgrind.supp": "# Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License, version 2.0,\n# as published by the Free Software Foundation.\n#\n# This program is also distributed with certain software (including\n# but not limited to OpenSSL) that is licensed under separate terms,\n# as designated in a particular file or component or in included license\n# documentation.  The authors of MySQL hereby grant you an additional\n# permission to link the program and your derivative works with the\n# separately licensed software that they have included with MySQL.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License, version 2.0, for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n\n#\n# Suppress some common (not fatal) errors in system libraries found by valgrind\n#\n\n#\n# Pthread doesn't free all thread specific memory before program exists\n#\n{\n   pthread allocate_tls memory loss\n   Memcheck:Leak\n   fun:calloc\n   ...\n   fun:_dl_allocate_tls\n   fun:allocate_stack\n   fun:pthread_create*\n}\n\n{\n   pthread allocate_tls memory loss\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_allocate_tls\n   fun:pthread_create*\n\n}\n\n{\n   semi_sync_master_plugin_init\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:tls_get_addr_tail\n}\n\n{\n   GCC never cleans up its TLS block\n   Memcheck:Leak\n   fun:memalign\n   ...\n   fun:tls_get_addr_tail\n}\n\n{\n   pthead_exit memory loss 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n}\n\n{\n   pthread_exit memory loss 2\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 3\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 4\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_check_map_versions\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 5\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n}\n\n{\n   pthread allocate_dtv memory loss\n   Memcheck:Leak\n   fun:calloc\n   fun:allocate_dtv\n   fun:_dl_allocate_tls_storage\n   fun:__GI__dl_allocate_tls\n   fun:pthread_create\n}\n\n{\n   pthread allocate_dtv memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:allocate_dtv\n   fun:_dl_allocate_tls\n   fun:pthread_create*\n}\n\n{\n   pthread memalign memory loss\n   Memcheck:Leak\n   fun:memalign\n   fun:_dl_allocate_tls_storage\n   fun:__GI__dl_allocate_tls\n   fun:pthread_create\n}\n\n{\n   pthread pthread_key_create\n   Memcheck:Leak\n   fun:malloc\n   fun:*\n   fun:*\n   fun:pthread_key_create\n   fun:my_thread_global_init\n}\n\n{\n   pthread strstr uninit\n   Memcheck:Cond\n   fun:strstr\n   obj:/lib/tls/libpthread.so.*\n   obj:/lib/tls/libpthread.so.*\n   fun:call_init\n   fun:_dl_init\n   obj:/lib/ld-*.so\n}\n\n{\n   pthread strstr uninit\n   Memcheck:Cond\n   fun:strstr\n   obj:/lib/tls/libpthread.so.*\n   obj:/lib/tls/libpthread.so.*\n   fun:call_init\n   fun:_dl_init\n   obj:/lib/ld-*.so\n}\n\n{\n   strlen/_dl_init_paths/dl_main/_dl_sysdep_start(Cond)\n   Memcheck:Cond\n   fun:strlen\n   fun:_dl_init_paths\n   fun:dl_main\n   fun:_dl_sysdep_start\n}\n\n{\n   pthread errno\n   Memcheck:Leak\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlsym\n   fun:__errno_location\n}\n\n{\n   pthread errno\n   Memcheck:Leak\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlclose\n}\n\n\n#\n# Warnings in libz becasue it works with aligned memory(?)\n#\n\n{\n   libz tr_flush_block\n   Memcheck:Cond\n   fun:_tr_flush_block\n   fun:deflate_slow\n   fun:deflate\n   fun:do_flush\n   fun:gzclose\n}\n\n{\n   libz tr_flush_block2\n   Memcheck:Cond\n   fun:_tr_flush_block\n   fun:deflate_slow\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz longest_match\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n}\n\n{\n   libz deflate\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz deflate2\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   obj:*/libz.so.*\n   fun:gzflush\n}\n\n{\n   libz deflate3\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   fun:do_flush\n}\n\n{\n  libz deflate4\n  Memcheck:Param\n  write(buf)\n  fun:*\n  fun:my_write\n  fun:do_flush\n  fun:azclose\n}\n\n# Warning from zlib, cf. http://www.zlib.net/zlib_faq.html#faq36\n\n{\n   libz deflate5\n   Memcheck:Cond\n   fun:slide_hash\n   fun:fill_window\n   fun:deflate_fast\n   fun:deflate\n}\n\n#\n# Warning from my_thread_init becasue mysqld dies before kill thread exists\n#\n\n{\n   my_thread_init kill thread memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:my_thread_init\n   fun:kill_server_thread\n}\n\n\n# Red Hat AS 4 32 bit\n{\n   dl_relocate_object\n   Memcheck:Cond\n   fun:_dl_relocate_object\n}\n\n#\n# Warning from my_thread_init becasue mysqld dies before kill thread exists\n#\n\n{\n   my_thread_init kill thread memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:my_thread_init\n   fun:kill_server_thread\n}\n\n#\n# Leaks reported in _dl_* internal functions on Linux amd64 / glibc2.3.2.\n#\n\n{\n   _dl_start invalid write8\n   Memcheck:Addr8\n   fun:_dl_start\n}\n\n{\n   _dl_start invalid write4\n   Memcheck:Addr4\n   fun:_dl_start\n}\n\n{\n   _dl_start/_dl_setup_hash invalid read8\n   Memcheck:Addr8\n   fun:_dl_setup_hash\n   fun:_dl_start\n}\n\n{\n   _dl_sysdep_start invalid write8\n   Memcheck:Addr8\n   fun:_dl_sysdep_start\n}\n\n{\n   _dl_init invalid write8\n   Memcheck:Addr8\n   fun:_dl_init\n}\n\n{\n   _dl_init invalid write4\n   Memcheck:Addr4\n   fun:_dl_init\n}\n\n{\n   _dl_init/_dl_init invalid read8\n   Memcheck:Addr8\n   fun:_dl_debug_initialize\n   fun:_dl_init\n}\n\n{\n   _dl_init/_dl_debug_state invalid read8\n   Memcheck:Addr8\n   fun:_dl_debug_state\n   fun:_dl_init\n}\n\n{\n   init invalid write8\n   Memcheck:Addr8\n   fun:init\n}\n\n{\n   fixup invalid write8\n   Memcheck:Addr8\n   fun:fixup\n}\n\n{\n   fixup/_dl_lookup_versioned_symbol invalid read8\n   Memcheck:Addr8\n   fun:_dl_lookup_versioned_symbol\n   fun:fixup\n}\n\n{\n   _dl_runtime_resolve invalid read8\n   Memcheck:Addr8\n   fun:_dl_runtime_resolve\n}\n\n{\n   __libc_start_main invalid write8\n   Memcheck:Addr8\n   fun:__libc_start_main\n}\n\n{\n   __libc_start_main/__sigjmp_save invalid write4\n   Memcheck:Addr4\n   fun:__sigjmp_save\n   fun:__libc_start_main\n}\n\n#\n# These seem to be libc threading stuff, not related to MySQL code (allocations\n# during pthread_exit()). Googling shows other projects also using these\n# suppressions.\n#\n# Note that these all stem from pthread_exit() deeper in the call stack, but\n# Valgrind only allows the top four calls in the suppressions.\n#\n\n{\n   libc pthread_exit 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   libc pthread_exit 2\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 3\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 4\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_check_map_versions\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 5\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   libc pthread_exit 6\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:openaux\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 7\n   Memcheck:Leak\n   fun:malloc\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n}\n\n{\n   libc pthread_exit 8\n   Memcheck:Leak\n   fun:malloc\n   fun:local_strdup\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n# strdup can be inlined\n{\n   libc pthread_exit 9\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:expand_dynamic_string_token\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n#\n# This is seen internally in the system libraries on 64-bit RHAS3.\n#\n\n{\n   __lll_mutex_unlock_wake uninitialized\n   Memcheck:Param\n   futex(utime)\n   fun:__lll_mutex_unlock_wake\n}\n\n#\n# BUG#19940: NDB sends uninitialized parts of field buffers across the wire.\n# This is \"works as designed\"; the uninitialized part is not used at the\n# other end (but Valgrind cannot see this).\n#\n{\n   bug19940\n   Memcheck:Param\n   socketcall.sendto(msg)\n   fun:send\n   fun:_ZN15TCP_Transporter6doSendEv\n   fun:_ZN19TransporterRegistry11performSendEv\n   fun:_ZN19TransporterRegistry14forceSendCheckEi\n}\n# Warning when printing stack trace (to suppress some not needed warnings)\n#\n\n{\n   vprintf on stacktrace\n   Memcheck:Cond\n   fun:vfprintf\n   fun:uffered_vfprintf\n   fun:vfprintf\n   fun:fprintf\n   fun:print_stacktrace\n}\n\n#\n# Safe warnings, that may happen because of thread scheduling\n#\n\n{\n   dbug initialization by kill_server\n   Memcheck:Leak\n   fun:malloc\n   fun:DbugMalloc\n   fun:code_state\n   fun:_db_enter_\n   fun:kill_server\n}\n\n#\n# Warning caused by small memory leak in threaded dlopen\n#\n\n{\n   dlopen threaded memory leak\n   Memcheck:Leak\n   fun:calloc\n   obj:*/libdl-*.so\n   fun:dlopen*\n}\n\n{\n   dlopen memory leak\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlsym\n}\n#\n# Pthread doesn't free all thread specific memory before program exists\n#\n{\n   pthread allocate_tls memory loss in 2.6.1.\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   fun:_dl_allocate_tls\n   fun:pthread_create*\n}\n\n{\n   buf_buddy_relocate peeking (space,page) in potentially free blocks\n   Memcheck:Addr1\n   fun:buf_buddy_relocate\n}\n\n{\n   Bug 59874 Valgrind warning in InnoDB compression code\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:btr_store_big_rec_extern_fields_func\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:page_zip_compress\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:page_zip_compress_deflate\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   obj:*/libz.so*\n   obj:*/libz.so*\n   fun:deflate\n   fun:page_zip_compress\n   fun:page_zip_reorganize\n   fun:page_cur_insert_rec_zip_reorg\n   fun:page_cur_insert_rec_zip\n   fun:page_cur_tuple_insert\n   fun:btr_cur_optimistic_insert\n   fun:btr_cur_pessimistic_insert\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   obj:*/libz.so*\n   obj:*/libz.so*\n   fun:deflate\n   fun:page_zip_compress\n   fun:page_zip_reorganize\n   fun:page_cur_insert_rec_zip_reorg\n   fun:page_cur_insert_rec_zip\n   fun:page_cur_tuple_insert\n   fun:btr_cur_optimistic_insert\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   obj:*/libz.so*\n   obj:*/libz.so*\n   fun:deflate\n   fun:page_zip_compress\n   fun:page_copy_rec_list_end\n   fun:page_move_rec_list_end\n   fun:btr_page_split_and_insert\n   fun:btr_root_raise_and_insert\n   fun:btr_cur_pessimistic_insert\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   obj:*/libz.so*\n   obj:*/libz.so*\n   fun:deflate\n   fun:page_zip_compress\n   fun:page_cur_insert_rec_zip_reorg\n   fun:page_cur_insert_rec_zip\n   fun:page_cur_tuple_insert\n   fun:btr_cur_optimistic_insert\n   fun:btr_cur_pessimistic_insert\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   Bug 59875 Valgrind warning in buf0buddy.c\n   Memcheck:Addr1\n   fun:mach_read_from_4\n   fun:buf_buddy_relocate\n   fun:buf_buddy_free_low\n   fun:buf_buddy_free\n}\n\n#\n# NDB packfrm vs deflate\n#\n{\n   NDB packfrm case 1\n   Memcheck:Cond\n   fun:deflate_slow\n   fun:deflate\n   fun:compress\n   fun:my_compress_alloc\n   fun:my_compress\n   fun:packfrm\n}\n\n{\n   NDB packfrm case 2\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:compress\n   fun:my_compress_alloc\n   fun:my_compress\n   fun:packfrm\n}\n\n#\n# pfs vs compress\n#\n{\n   pfs vs. compress case 1\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:compress\n   fun:my_compress_alloc\n   fun:my_compress\n}\n\n{\n   pfs vs. compress case 2\n   Memcheck:Cond\n   fun:deflate_slow\n   fun:deflate\n   fun:compress\n   fun:my_compress_alloc\n   fun:my_compress\n}\n\n# Note the wildcard in the (mangled) function signatures of\n# write_keys() and find_all_keys().\n# They both return ha_rows, which is platform dependent.\n#\n# The '...' wildcards are for 'fun:inline_mysql_file_write' which *may*\n# be inlined.\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / one\n   Memcheck:Param\n   write(buf)\n   ...\n   fun:_Z19my_b_flush_io_cacheP8IO_CACHEi\n   fun:_Z11_my_b_writeP8IO_CACHEPKhm\n   fun:_Z*10write_keysP10Sort_paramP13Filesort_infojP8IO_CACHES4_\n   ...\n   fun:_Z8filesortP3THDP8Filesort*\n}\n\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / three\n   Memcheck:Param\n   write(buf)\n   ...\n   fun:_Z19my_b_flush_io_cacheP8IO_CACHEi\n   fun:_Z8filesortP3THDP8Filesort*\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:CRYPTO_malloc\n   fun:sk_new\n   ...\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:engine_cleanup_add_last\n   fun:ENGINE_add\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   fun:engine_cleanup_add_last\n   fun:ENGINE_add\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:ENGINE_new\n}\n\n{\n  OpenSSL still reachable.\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  ...\n  fun:ERR_peek_error\n  fun:vio_ssl_read\n  ...\n}\n\n{\n  OpenSSL still reachable.\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  ...\n  fun:ERR_peek_error\n  ...\n  fun:sslaccept\n  ...\n  fun:server_mpvio_read_packet\n  ...\n}\n\n{\n   Bug#16039908 \"BYTES STILL REACHABLE\" IN VALGRIND TEST ON 5.6/TRUNK\n   Memcheck:Leak\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlclose\n   fun:_ZL15free_plugin_memP12st_plugin_dl\n   fun:_ZL13plugin_dl_delPK16MYSQL_LEX_STRING\n   fun:_ZL10plugin_delP13st_plugin_int\n   fun:_ZL12reap_pluginsv\n   fun:_Z15plugin_shutdownv\n   fun:_Z*8clean_upb*\n}\n\n{\n   main.udf gives similar warning as Bug#16039908\n   Memcheck:Leak\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlclose\n   fun:_Z*udf_deinitv\n   fun:_Z*8clean_upb*\n}\n\n#Suppress warnings from glibc implementation of 'malloc_info'\n{\n   Malloc_info uninitialised value of size 8\n   Memcheck:Value8\n   fun:_itoa_word\n   fun:vfprintf\n   fun:fprintf\n   fun:mi_arena.*\n   fun:malloc_info\n}\n\n{\n   Malloc_info conditional jump depends on uninitialised values\n   Memcheck:Cond\n   ...\n   fun:mi_arena.*\n   fun:malloc_info\n}\n\n#supress warnings from openssl random generator\n\n{\n   OpenSSL conditional jump in ssl3_ctx_ctrl\n   Memcheck:Cond\n   ...\n   fun:ssl3_ctx_ctrl\n   fun:new_VioSSLFd\n}\n\n{\n   OpenSSL uninitialised value of size 8 in new_VioSSLFd\n   Memcheck:Value8\n   fun:BN_num_bits_word\n   fun:BN_num_bits\n   ...\n   fun:new_VioSSLFd\n}\n\n{\n   OpenSSL uninitialised value of size 8 in new_VioSSLFd\n   Memcheck:Value8\n   fun:BN_mod_exp_mont_consttime\n   ...\n   fun:new_VioSSLFd\n}\n\n{\n   OpenSSL PB2 / 1\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:ssl_start\n   fun:_Z8init_sslv\n   fun:_Z11mysqld_mainiPPc\n   fun:main\n}\n\n{\n   OpenSSL PB2 / 2\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:ssl_start\n   fun:_ZL8init_sslv\n   fun:_Z11mysqld_mainiPPc\n   fun:main\n}\n\n\n{\n   OpenSSL libstdc++ version 5 / one\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   obj:/lib/x86_64-linux-gnu/libssl.so.1.0.0\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:ssl_start\n   fun:_ZL8init_sslv\n   fun:_Z11mysqld_mainiPPc\n   fun:main\n}\n\n{\n   OpenSSL libstdc++ version 5 / two\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   obj:/lib/x86_64-linux-gnu/libssl.so.1.0.0\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:ssl_start\n   fun:_ZL8init_sslv\n   fun:_Z11mysqld_mainiPPc\n   fun:main\n}\n\n{\n   OpenSSL libstdc++ version 5 / three\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   obj:/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21\n   fun:call_init.part.0\n   fun:call_init\n   fun:_dl_init\n}\n\n# supress uninitialized because some SSL libraries do random like that\n{\n   OpenSSL conditional jump in generate_user_salt due to randomness\n   Memcheck:Cond\n   fun:generate_user_salt\n   fun:native_password_authenticate\n}\n\n\n# Remove the NUMA ones below when https://github.com/numactl/numactl/issues/3\n# is resolved.\n\n{\n   libnuma fails to free its internally allocated memory 1\n   Memcheck:Leak\n   fun:malloc\n   fun:numa_bitmask_alloc\n}\n\n{\n   libnuma fails to free its internally allocated memory 2\n   Memcheck:Leak\n   fun:calloc\n   fun:numa_bitmask_alloc\n}\n\n{\n   libnuma fails to free its internally allocated memory 3\n   Memcheck:Leak\n   fun:calloc\n   ...\n   fun:numa_node_*_cpu*\n}\n\n{\n   General protobuf globals\n   Memcheck:Leak\n   fun:_Znwm\n   ...\n   fun:_GLOBAL__sub_I_mysqlx*.pb.cc\n   ...\n}\n\n{\n   General protobuf globals\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:_Znwm\n   ...\n   fun:_Z41__static_initialization_and_destruction_0ii\n}\n\n{\n   General protobuf globals\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:_Znwm\n   ...\n   fun:_ZN6Mysqlx23protobuf_mysqlx_2eproto27StaticDescriptorInitializerC1Ev\n}\n\n{\n   mysqlx plugin install\n   Memcheck:Leak\n   fun:*alloc\n   ...\n   fun:_dl_catch_error\n   ...\n   fun:dlopen*\n   ...\n   fun:_ZL13plugin_dl_addPK16MYSQL_LEX_STRINGi*\n   ...\n}\n\n# supress inability to cleanup OpenSSL error contexts in GR\n{\n   OpenSSL GR suppress leak 1\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:ERR_get_state\n   fun:ERR_clear_error\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   fun:_ZN14Trans_delegate13before_commitEP3THDbP8IO_CACHES3_y\n   fun:_ZN13MYSQL_BIN_LOG6commitEP3THDb\n   fun:_Z17trans_commit_stmtP3THD\n}\n\n{\n   OpenSSL GR suppress leak 2\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:ERR_get_state\n   fun:ERR_clear_error\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   fun:_ZN14Trans_delegate13before_commitEP3THDbP8IO_CACHES3_y\n   fun:_ZN13MYSQL_BIN_LOG6commitEP3THDb\n   fun:_Z15ha_commit_transP3THDbb\n}\n\n{\n   OpenSSL GR suppress leak 3\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:CRYPTO_malloc\n   fun:lh_insert\n   fun:int_thread_set_item\n   fun:ERR_get_state\n   fun:ERR_clear_error\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   fun:_ZN14Trans_delegate13before_commitEP3THDbP8IO_CACHES3_y\n}\n\n{\n   OpenSSL GR suppress leak 4\n   Memcheck:Leak\n   match-leak-kinds: all\n   fun:malloc\n   ...\n   fun:CRYPTO_malloc\n   fun:lh_new\n   obj:*\n   obj:*\n   fun:ERR_get_state\n   fun:ERR_put_error\n   fun:PEM_read_bio\n   fun:PEM_X509_INFO_read_bio\n   fun:X509_load_cert_crl_file\n   obj:*\n   fun:X509_STORE_load_locations\n   ...\n}\n\n{\n  OpenSSL still reachable.\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  ...\n  fun:ERR_peek_error\n  fun:vio_ssl_read\n  ...\n}\n\n{\n  OpenSSL still reachable.\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  ...\n  fun:ERR_peek_error\n  ...\n  fun:sslaccept\n  ...\n  fun:server_mpvio_read_packet\n  ...\n}\n\n#\n# Rules to suppress leaks from plugin dependencies\n#\n\n{\n  TPL leak 1\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:BUF_strndup\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 2\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:BUF_strndup\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 3\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  ...\n  fun:CRYPTO_malloc\n  fun:lh_insert\n  fun:int_thread_set_item\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 4\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:sk_new\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 5\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:sk_new\n  fun:SSL_COMP_get_compression_methods\n  fun:SSL_library_init\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 6\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 7\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 8\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  ...\n  fun:CRYPTO_malloc\n  fun:lh_new\n  fun:int_thread_get\n  fun:int_thread_set_item\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 9\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 10\n  Memcheck:Leak\n  match-leak-kinds: definite\n  fun:malloc\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 11\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  ...\n  fun:CRYPTO_malloc\n  fun:ERR_get_state\n  fun:ERR_put_error\n  fun:PEM_read_bio\n  fun:PEM_X509_INFO_read_bio\n  fun:X509_load_cert_crl_file\n  fun:by_file_ctrl\n  fun:X509_STORE_load_locations\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n}\n\n{\n  TPL leak 12\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:BUF_strndup\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 13\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 14\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:sk_new\n  fun:SSL_COMP_get_compression_methods\n  fun:SSL_library_init\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 15\n  Memcheck:Leak\n  match-leak-kinds: all\n  fun:malloc\n  ...\n  fun:CRYPTO_malloc\n  fun:lh_insert\n  obj:*\n  fun:ERR_get_state\n  fun:ERR_put_error\n  fun:PEM_read_bio\n  fun:PEM_X509_INFO_read_bio\n  fun:X509_load_cert_crl_file\n  obj:*\n  fun:X509_STORE_load_locations\n  ...\n}\n\n{\n  TPL leak 16\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:realloc\n  fun:CRYPTO_realloc\n  fun:sk_insert\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 17\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  ...\n  fun:CRYPTO_malloc\n  fun:lh_insert\n  fun:int_thread_set_item\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 18\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  ...\n  fun:CRYPTO_malloc\n  fun:lh_insert\n  fun:int_thread_set_item\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 19\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 20\n  Memcheck:Leak\n  match-leak-kinds: definite\n  fun:malloc\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 21\n  Memcheck:Leak\n  match-leak-kinds: possible\n  fun:malloc\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 22\n  Memcheck:Leak\n  match-leak-kinds: possible\n  fun:malloc\n  ...\n  fun:CRYPTO_malloc\n  fun:lh_new\n  fun:int_thread_get\n  fun:int_thread_set_item\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  fun:ENGINE_load_builtin_engines\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n# Workarounds for\n#\n# Bug#26116237 SYSCALL PARAM PPOLL(SIGMASK) POINTS TO UNADDRESSABLE BYTE\n{\n   RPL workaround 1\n   Memcheck:Param\n   ppoll(sigmask)\n   fun:ppoll\n   fun:vio_io_wait\n}\n\n{\n   RPL workaround 2\n   Memcheck:Param\n   ppoll(sigmask)\n   fun:ppoll\n   fun:_Z11vio_io_waitP3Vio17enum_vio_io_eventi\n}\n\n# Workarounds for\n#\n# Bug#22833138 KEYRING_OKV : MEMORY LEAKS FROM OKV CLIENT LIB\n{\n   Keyring_OKV_workaround_addtoTagObj\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:addtoTagObj\n}\n{\n   Keyring_OKV_workaround_OKIGetKey\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKIGetKey\n}\n{\n   Keyring_OKV_workaround_OKICreateKey\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKICreateKey\n}\n{\n   Keyring_OKV_workaround_okiconn_ssl_send_recv\n   Memcheck:Leak\n   fun:calloc\n   ...\n   fun:OKIConnSendRecvBytes\n   fun:OKIOpsExecuteOp\n}\n{\n   Keyring_OKV_workaround_OKIGetAttributes\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKIGetAttributes\n}\n{\n   Keyring_OKV_workaround_OKIGetAttributes2\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIPostGetUIDTTLV\n   fun:OKIAPIPostProcessing\n   fun:OKIGetAttributes\n}\n{\n   Keyring_OKV_workaround_OKIAddAttribute\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKIAddAttribute\n}\n{\n   Keyring_OKV_workaround_OKIAddAttribute2\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIOpsCreate\n   fun:OKIAddAttribute\n}\n{\n   Keyring_OKV_workaround_OKILocate\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKILocate\n}\n{\n   Keyring_OKV_workaround_OKIActivate\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKIActivate\n}\n{\n   Keyring_OKV_workaround_OKIRegKey\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKIRegKey\n}\n{\n   Keyring_OKV_workaround_OKIRevoke\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKIRevoke\n}\n{\n   Keyring_OKV_workaround_OKIEnvCreate\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIEnvCreate\n}\n{\n   Keyring_OKV_workaround_OKITTLVMoveChildWithTag\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKITTLVMoveChildWithTag\n}\n{\n   Keyring_OKV_workaround_OKIParseUnpackTTLVFromBuffer\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIParseUnpackTTLVFromBuffer\n}\n{\n   Keyring_OKV_workaround_OKITTLVAddChildObject\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKITTLVAddChildObject\n}\n\n# Bug#27209265 Suppress all issues relating to communication with AWS KMS server.\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:CRYPTO_malloc\n   fun:ERR_get_state\n   fun:ERR_put_error\n   fun:PEM_read_bio\n   fun:PEM_X509_INFO_read_bio\n   fun:X509_load_cert_crl_file\n   fun:by_file_ctrl\n   fun:X509_STORE_load_locations\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n}\n\n# Bug #25964438  LDAP: ASAN AND VALGRIND ISSUES\n\n{\n   LDAP_TLS_workaround1\n   Memcheck:Leak\n   fun:calloc\n   ...\n   ...\n   ...\n   ...\n   ...\n   fun:ldap_int_tls_start\n   fun:ldap_start_tls_s\n   fun:*establish_tls*\n   fun:*create*\n}\n{\n   LDAP_TLS_workaround2\n   Memcheck:Leak\n   fun:malloc\n   ...\n   ...\n   ...\n   ...\n   ...\n   fun:ldap_int_tls_start\n   fun:ldap_start_tls_s\n   fun:*establish_tls*\n   fun:*create*\n}\n{\n   LDAP_TLS_workaround3\n   Memcheck:Leak\n   fun:calloc\n   fun:PR_LoadLibraryWithFlags\n   ...\n   ...\n   ...\n   fun:PR_CallOnce\n   ...\n   ...\n   fun:_dl_init\n}\n{\n   LDAP_TLS_workaround4\n   Memcheck:Leak\n   fun:malloc\n   fun:PR_ErrorInstallTable\n   fun:PR_CallOnce\n   ...\n   ...\n   fun:PR_CallOnceWithArg\n   ...\n   fun:NSS_SetDomesticPolicy\n   ...\n   fun:PR_CallOnceWithArg\n   ...\n   ...\n   ...\n   fun:ldap_int_tls_start\n   fun:ldap_start_tls_s\n   fun:*establish_tls*\n}\n{\n   LDAP_TLS_workaround5\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:PR_LoadLibraryWithFlags\n   ...\n   ...\n   ...\n   fun:PR_CallOnce\n   ...\n   ...\n   ...\n   ...\n   fun:_dl_catch_error\n   fun:_dl_open\n   fun:dlopen_doit\n   fun:_dl_catch_error\n   fun:_dlerror_run\n}\n{\n   LDAP_TLS_workaround6\n   Memcheck:Leak\n   fun:malloc\n   fun:ber_memalloc_x\n   fun:ber_strdup_x\n   ...\n   fun:ldap_int_initialize\n   fun:ldap_create\n   fun:ldap_initialize\n   fun:*create*\n}\n{\n   LDAP_TLS_workaround7\n   Memcheck:Leak\n   fun:malloc\n   fun:*dl_close_worker*\n   fun:*dl_close*\n   fun:*dl_catch_error*\n   ...\n   fun:*free_mem*\n   fun:*libc_freeres*\n   fun:*vgnU_freeres*\n   fun:*run_exit_handlers*\n   fun:exit*\n   fun:*mysqld_exit*\n   fun:*mysqld_main*\n   fun:*main*\n}\n{\n   LDAP_TLS_workaround8\n   Memcheck:Leak\n   fun:malloc\n   fun:ber_memalloc_x\n   fun:ber_strdup_x\n   ...\n   fun:ldap_int_initialize\n   fun:ldap_set_option\n   fun:*configure_tls*\n}\n{\n   LDAP_TLS_workaround9\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:PR_ErrorInstallTable\n   ...\n   ...\n   ...\n   ...\n   ...\n   ...  \n   ...\n   ...\n   ...\n   ...\n   ...\n   ...\n   fun:ldap_int_tls_start\n   fun:ldap_start_tls_s\n}\n{\n   SIGSTOP_and_SIGCONT in gr tests\n   Memcheck:Cond\n   fun:signal_hand\n   fun:pfs_spawn_thread\n   fun:start_thread\n   fun:clone\n}\n{\n   Mysqlx: OpenSSL cert file still possible.\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:malloc\n   ...\n   fun:CRYPTO_malloc\n   fun:ERR_get_state\n   fun:ERR_put_error\n   fun:PEM_read_bio\n   fun:PEM_X509_INFO_read_bio\n   fun:X509_load_cert_crl_file\n   fun:*\n   fun:X509_STORE_load_locations\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/components/mysql_server/dynamic_loader_scheme_file.cc": "/* Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License, version 2.0,\nas published by the Free Software Foundation.\n\nThis program is also distributed with certain software (including\nbut not limited to OpenSSL) that is licensed under separate terms,\nas designated in a particular file or component or in included license\ndocumentation.  The authors of MySQL hereby grant you an additional\npermission to link the program and your derivative works with the\nseparately licensed software that they have included with MySQL.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License, version 2.0, for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n#include \"my_config.h\"\n\n#include <mysql/components/service_implementation.h>\n#include <mysql/components/services/dynamic_loader.h>\n#include <mysql/components/services/dynamic_loader_scheme_file.h>\n#include <string.h>\n#include <map>\n#include <string>\n#include <unordered_set>\n\n#include \"dynamic_loader_scheme_file.h\"\n#include \"my_psi_config.h\"\n#include \"mysql/psi/mysql_system.h\"\n#include \"mysql/psi/mysql_thread.h\"\n#include \"rwlock_scoped_lock.h\"\n#include \"scope_guard.h\"\n#include \"server_component.h\"\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\ntypedef std::string my_string;\n\nstatic PSI_rwlock_key key_rwlock_LOCK_dynamic_loader_scheme_file;\n\n/**\n  Initializes file:// scheme for dynamic loader for usage. Initializes\n  RW lock, all other structures should be empty. Shouldn't be called multiple\n  times.\n*/\nvoid mysql_dynamic_loader_scheme_file_imp::init() {\n  mysql_rwlock_init(\n      key_rwlock_LOCK_dynamic_loader_scheme_file,\n      &mysql_dynamic_loader_scheme_file_imp::LOCK_dynamic_loader_scheme_file);\n}\n/**\n  De-initializes RW lock, all other structures doesn't require any action.\n*/\nvoid mysql_dynamic_loader_scheme_file_imp::deinit() {\n  mysql_rwlock_destroy(\n      &mysql_dynamic_loader_scheme_file_imp::LOCK_dynamic_loader_scheme_file);\n}\n\n/**\n  Loads components that are located in executable file specified by URN.\n  We assume that URN starts with file://, but accept any. Will not success\n  when called multiple times on the same file.\n\n  @param urn URN to file to load components from.\n  @param [out] out_data Pointer to pointer to MySQL component data structures\n    to set result components data retrieved from specified file.\n  @return Status of performed operation\n  @retval false success\n  @retval true Failure, may be caused when name does not contain ://, cannot\n    be located, is not proper executable file or does not contain proper\n    initialization function.\n*/\nDEFINE_BOOL_METHOD(mysql_dynamic_loader_scheme_file_imp::load,\n                   (const char *urn, mysql_component_t **out_data)) {\n  try {\n    if (urn == NULL) {\n      return true;\n    }\n\n    my_string urn_string = urn;\n\n    /* Check if library is not already loaded, by comparing URNs. */\n    rwlock_scoped_lock lock(\n        &mysql_dynamic_loader_scheme_file_imp::LOCK_dynamic_loader_scheme_file,\n        true, __FILE__, __LINE__);\n\n    if (object_files_list.find(urn_string) != object_files_list.end()) {\n      return true;\n    }\n\n    /* Omit scheme prefix to get filename. */\n    const char *file = strstr(urn, \"://\");\n    if (file == NULL) {\n      return true;\n    }\n    /* Offset by \"://\" */\n    file += 3;\n    my_string file_name = my_string(file);\n#ifdef _WIN32\n    file_name += \".dll\";\n#else\n    file_name += \".so\";\n#endif\n\n    /* Open library. */\n    void *handle = dlopen(file_name.c_str(), RTLD_NOW);\n    if (handle == NULL) {\n      return true;\n    }\n    auto guard_library = create_scope_guard([&handle]() {\n      /* In case we need to rollback we close the opened library. */\n      dlclose(handle);\n    });\n\n    /* Look for \"list_components\" function. */\n    list_components_func list_func = reinterpret_cast<list_components_func>(\n        dlsym(handle, \"list_components\"));\n    if (list_func == NULL) {\n      return true;\n    }\n\n    /* Check if library is not already loaded, by comparing \"list_components\"\n      function address. */\n    if (library_entry_set.insert(list_func).second == false) {\n      return true;\n    }\n\n    auto guard_library_set = create_scope_guard([&list_func]() {\n      /* In case we need to rollback we remove library handle from set. */\n      library_entry_set.erase(list_func);\n    });\n\n    /* Get components data from library. */\n    *out_data = list_func();\n\n    /* Add library and it's handle to list of loaded libraries. */\n\n    if (object_files_list.emplace(urn_string, handle).second == false) {\n      return true;\n    }\n\n    guard_library.commit();\n    guard_library_set.commit();\n\n    return false;\n  } catch (...) {\n  }\n  return true;\n}\n\n/**\n  Unloads file that was previously loaded. The URN string must be exactly\n  the same as one used during call to load. Although you can call load() on\n  specified URN multiple times, subsequent calls unload() will always fail,\n  and all components from specified file will be invalid after first call to\n  unload().\n\n  @param urn URN to file to unload all components from.\n  @return Status of performed operation\n  @retval false success\n  @retval true failure\n*/\nDEFINE_BOOL_METHOD(mysql_dynamic_loader_scheme_file_imp::unload,\n                   (const char *urn)) {\n  try {\n    /* Find library matching URN specified. */\n    rwlock_scoped_lock lock(\n        &mysql_dynamic_loader_scheme_file_imp::LOCK_dynamic_loader_scheme_file,\n        true, __FILE__, __LINE__);\n\n    my_registry::iterator it = object_files_list.find(my_string(urn));\n    if (it == object_files_list.end()) {\n      return true;\n    }\n\n    /* Delete entry from library entry points list. */\n    list_components_func list_func = reinterpret_cast<list_components_func>(\n        dlsym(it->second, \"list_components\"));\n    library_entry_set.erase(list_func);\n\n#ifdef HAVE_PSI_SYSTEM_INTERFACE\n    PSI_SYSTEM_CALL(unload_plugin)(it->first.c_str());\n#endif\n    /* Close library and delete entry from libraries list. */\n    dlclose(it->second);\n    object_files_list.erase(it);\n    return false;\n  } catch (...) {\n  }\n  return true;\n}\n\n/* static members for mysql_dynamic_loader_scheme_file_imp */\nmysql_dynamic_loader_scheme_file_imp::my_registry\n    mysql_dynamic_loader_scheme_file_imp::object_files_list;\nstd::unordered_set<mysql_dynamic_loader_scheme_file_imp::list_components_func>\n    mysql_dynamic_loader_scheme_file_imp::library_entry_set;\nmysql_rwlock_t\n    mysql_dynamic_loader_scheme_file_imp::LOCK_dynamic_loader_scheme_file;\n\n/* Following code initialize and deinitialize service implementations by\n  managing RW locks and their PSI augmentation. */\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_rwlock_info all_dynamic_loader_scheme_file_rwlocks[] = {\n    {&key_rwlock_LOCK_dynamic_loader_scheme_file,\n     \"LOCK_dynamic_loader_scheme_file\", PSI_FLAG_SINGLETON, 0,\n     PSI_DOCUMENT_ME}};\n\nstatic void init_dynamic_loader_scheme_file_psi_keys(void) {\n  const char *category = \"components\";\n  int count;\n\n  count =\n      static_cast<int>(array_elements(all_dynamic_loader_scheme_file_rwlocks));\n  mysql_rwlock_register(category, all_dynamic_loader_scheme_file_rwlocks,\n                        count);\n}\n#endif\n\nvoid dynamic_loader_scheme_file_init() {\n#ifdef HAVE_PSI_INTERFACE\n  init_dynamic_loader_scheme_file_psi_keys();\n#endif\n  mysql_dynamic_loader_scheme_file_imp::init();\n}\n\nvoid dynamic_loader_scheme_file_deinit() {\n  mysql_dynamic_loader_scheme_file_imp::deinit();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/sql/sql_udf.cc": "/* Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License, version 2.0,\n   as published by the Free Software Foundation.\n\n   This program is also distributed with certain software (including\n   but not limited to OpenSSL) that is licensed under separate terms,\n   as designated in a particular file or component or in included license\n   documentation.  The authors of MySQL hereby grant you an additional\n   permission to link the program and your derivative works with the\n   separately licensed software that they have included with MySQL.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License, version 2.0, for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/* This implements 'user defined functions' */\n\n#include \"sql/sql_udf.h\"\n\n#include \"my_config.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <iterator>\n#include <memory>\n#include <new>\n#include <string>\n#include <unordered_map>\n#include <utility>\n\n#include \"m_ctype.h\"\n#include \"m_string.h\"  // my_stpcpy\n#include \"map_helpers.h\"\n#include \"my_alloc.h\"\n#include \"my_base.h\"\n#include \"my_dbug.h\"\n#include \"my_inttypes.h\"\n#include \"my_io.h\"\n#include \"my_loglevel.h\"\n#include \"my_macros.h\"\n#include \"my_psi_config.h\"\n#include \"my_sharedlib.h\"\n#include \"my_sys.h\"\n#include \"my_thread_local.h\"\n#include \"mysql/components/service_implementation.h\"\n#include \"mysql/components/services/log_builtins.h\"\n#include \"mysql/components/services/log_shared.h\"\n#include \"mysql/components/services/mysql_rwlock_bits.h\"\n#include \"mysql/components/services/psi_memory_bits.h\"\n#include \"mysql/components/services/psi_rwlock_bits.h\"\n#include \"mysql/psi/mysql_memory.h\"\n#include \"mysql/psi/mysql_rwlock.h\"\n#include \"mysql/psi/psi_base.h\"\n#include \"mysql_com.h\"\n#include \"mysqld_error.h\"  // ER_*\n#include \"sql/field.h\"\n#include \"sql/handler.h\"\n#include \"sql/mdl.h\"\n#include \"sql/mysqld.h\"   // opt_allow_suspicious_udfs\n#include \"sql/records.h\"  // READ_RECORD\n#include \"sql/row_iterator.h\"\n#include \"sql/sql_base.h\"   // close_mysql_tables\n#include \"sql/sql_class.h\"  // THD\n#include \"sql/sql_const.h\"\n#include \"sql/sql_parse.h\"   // check_string_char_length\n#include \"sql/sql_plugin.h\"  // check_valid_path\n#include \"sql/sql_table.h\"   // write_bin_log\n#include \"sql/table.h\"       // TABLE_LIST\n#include \"sql/thd_raii.h\"\n#include \"sql/thr_malloc.h\"\n#include \"sql/transaction.h\"  // trans_*\n#include \"thr_lock.h\"\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n/**\n  @page page_ext_udf User Defined Functions\n\n  @todo Document me\n\n  @sa add_udf, udf_hash_delete.\n*/\n\n/**\n  A local flag indicating whether SQL based UDF operations are allowed.\n  Now the UDF structures are always allocated/deallocated due to\n  the component service.\n\n  So this variable does not cover initialization/deinitialization of these.\n  \\ref mem and \\ref THR_LOCK_udf are always initialized, even in\n  --skip-grant-tables mode.\n*/\nstatic bool initialized = 0;\nstatic MEM_ROOT mem;\nstatic collation_unordered_map<std::string, udf_func *> *udf_hash;\nstatic mysql_rwlock_t THR_LOCK_udf;\n\nstatic udf_func *add_udf(LEX_STRING *name, Item_result ret, char *dl,\n                         Item_udftype typ);\nstatic void udf_hash_delete(udf_func *udf);\nstatic void *find_udf_dl(const char *dl);\n\nstatic char *init_syms(udf_func *tmp, char *nm) {\n  char *end;\n\n  if (!((tmp->func = (Udf_func_any)dlsym(tmp->dlhandle, tmp->name.str))))\n    return tmp->name.str;\n\n  end = my_stpcpy(nm, tmp->name.str);\n\n  if (tmp->type == UDFTYPE_AGGREGATE) {\n    (void)my_stpcpy(end, \"_clear\");\n    if (!((tmp->func_clear = (Udf_func_clear)dlsym(tmp->dlhandle, nm))))\n      return nm;\n    (void)my_stpcpy(end, \"_add\");\n    if (!((tmp->func_add = (Udf_func_add)dlsym(tmp->dlhandle, nm)))) return nm;\n  }\n\n  (void)my_stpcpy(end, \"_deinit\");\n  tmp->func_deinit = (Udf_func_deinit)dlsym(tmp->dlhandle, nm);\n\n  (void)my_stpcpy(end, \"_init\");\n  tmp->func_init = (Udf_func_init)dlsym(tmp->dlhandle, nm);\n\n  /*\n    to prevent loading \"udf\" from, e.g. libc.so\n    let's ensure that at least one auxiliary symbol is defined\n  */\n  if (!tmp->func_init && !tmp->func_deinit && tmp->type != UDFTYPE_AGGREGATE) {\n    if (!opt_allow_suspicious_udfs) return nm;\n    LogErr(WARNING_LEVEL, ER_FAILED_TO_FIND_DL_ENTRY, nm);\n  }\n  return 0;\n}\n\nstatic PSI_memory_key key_memory_udf_mem;\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_rwlock_key key_rwlock_THR_LOCK_udf;\n\nstatic PSI_rwlock_info all_udf_rwlocks[] = {{&key_rwlock_THR_LOCK_udf,\n                                             \"THR_LOCK_udf\", PSI_FLAG_SINGLETON,\n                                             0, PSI_DOCUMENT_ME}};\n\nstatic PSI_memory_info all_udf_memory[] = {{&key_memory_udf_mem, \"udf_mem\",\n                                            PSI_FLAG_ONLY_GLOBAL_STAT, 0,\n                                            PSI_DOCUMENT_ME}};\n\nstatic void init_udf_psi_keys(void) {\n  const char *category = \"sql\";\n  int count;\n\n  count = static_cast<int>(array_elements(all_udf_rwlocks));\n  mysql_rwlock_register(category, all_udf_rwlocks, count);\n\n  count = static_cast<int>(array_elements(all_udf_memory));\n  mysql_memory_register(category, all_udf_memory, count);\n}\n#endif\n\n/**\n  Initialize the UDF global structures.\n  This is done as a separate step so that the UDF registration\n  service can work when initalizing plugins, which happens\n  before reading the UDF table.\n*/\nvoid udf_init_globals() {\n  DBUG_ENTER(\"udf_init_globals\");\n  if (initialized) DBUG_VOID_RETURN;\n\n#ifdef HAVE_PSI_INTERFACE\n  init_udf_psi_keys();\n#endif\n\n  mysql_rwlock_init(key_rwlock_THR_LOCK_udf, &THR_LOCK_udf);\n  init_sql_alloc(key_memory_udf_mem, &mem, UDF_ALLOC_BLOCK_SIZE, 0);\n\n  udf_hash = new collation_unordered_map<std::string, udf_func *>(\n      system_charset_info, key_memory_udf_mem);\n  DBUG_VOID_RETURN;\n}\n\n/*\n  Read all predeclared functions from mysql.func and accept all that\n  can be used.\n  The global structures must be initialized first.\n*/\nvoid udf_read_functions_table() {\n  udf_func *tmp;\n  TABLE_LIST tables;\n  READ_RECORD read_record_info;\n  TABLE *table;\n  int error;\n  DBUG_ENTER(\"ufd_read_functions_table\");\n  char db[] = \"mysql\"; /* A subject to casednstr, can't be constant */\n\n  if (initialized) {\n    DBUG_ASSERT(\"wrong init order: reading UDFs from the table twice\");\n    DBUG_VOID_RETURN;\n  }\n\n  initialized = 1;\n\n  THD *new_thd = new (std::nothrow) THD;\n  if (new_thd == nullptr) {\n    LogErr(ERROR_LEVEL, ER_UDF_CANT_ALLOC_FOR_STRUCTURES);\n    free_root(&mem, MYF(0));\n    delete new_thd;\n    DBUG_VOID_RETURN;\n  }\n  new_thd->thread_stack = (char *)&new_thd;\n  new_thd->store_globals();\n  {\n    LEX_CSTRING db_lex_cstr = {STRING_WITH_LEN(db)};\n    new_thd->set_db(db_lex_cstr);\n  }\n\n  tables.init_one_table(db, sizeof(db) - 1, C_STRING_WITH_LEN(\"func\"), \"func\",\n                        TL_READ, MDL_SHARED_READ_ONLY);\n\n  if (open_trans_system_tables_for_read(new_thd, &tables)) {\n    DBUG_PRINT(\"error\", (\"Can't open udf table\"));\n    LogErr(ERROR_LEVEL, ER_UDF_CANT_OPEN_FUNCTION_TABLE);\n    goto end;\n  }\n\n  table = tables.table;\n  if (init_read_record(&read_record_info, new_thd, table, NULL, false,\n                       /*ignore_not_found_rows=*/false))\n    goto end;\n  while (!(error = read_record_info->Read())) {\n    DBUG_PRINT(\"info\", (\"init udf record\"));\n    LEX_STRING name;\n    name.str = get_field(&mem, table->field[0]);\n    name.length = strlen(name.str);\n    char *dl_name = get_field(&mem, table->field[2]);\n    bool new_dl = 0;\n    Item_udftype udftype = UDFTYPE_FUNCTION;\n    if (table->s->fields >= 4)  // New func table\n      udftype = (Item_udftype)table->field[3]->val_int();\n\n    /*\n      Ensure that the .dll doesn't have a path\n      This is done to ensure that only approved dll from the system\n      directories are used (to make this even remotely secure).\n\n      On windows we must check both FN_LIBCHAR and '/'.\n    */\n\n    LEX_CSTRING name_cstr = {name.str, name.length};\n    if (check_valid_path(dl_name, strlen(dl_name)) ||\n        check_string_char_length(name_cstr, \"\", NAME_CHAR_LEN,\n                                 system_charset_info, 1)) {\n      LogErr(ERROR_LEVEL, ER_UDF_INVALID_ROW_IN_FUNCTION_TABLE, name.str);\n      continue;\n    }\n\n    if (!(tmp = add_udf(&name, (Item_result)table->field[1]->val_int(), dl_name,\n                        udftype))) {\n      LogErr(ERROR_LEVEL, ER_UDF_CANT_ALLOC_FOR_FUNCTION, name.str);\n      continue;\n    }\n\n    void *dl = find_udf_dl(tmp->dl);\n    if (dl == NULL) {\n      char dlpath[FN_REFLEN];\n      strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", tmp->dl, NullS);\n      (void)unpack_filename(dlpath, dlpath);\n      if (!(dl = dlopen(dlpath, RTLD_NOW))) {\n        const char *errmsg;\n        int error_number = dlopen_errno;\n        DLERROR_GENERATE(errmsg, error_number);\n\n        // Print warning to log\n        LogErr(ERROR_LEVEL, ER_FAILED_TO_OPEN_SHARED_LIBRARY, tmp->dl,\n               error_number, errmsg);\n        // Keep the udf in the hash so that we can remove it later\n        continue;\n      }\n      new_dl = 1;\n    }\n    tmp->dlhandle = dl;\n    {\n      char buf[NAME_LEN + 16], *missing;\n      if ((missing = init_syms(tmp, buf))) {\n        LogErr(ERROR_LEVEL, ER_FAILED_TO_FIND_DL_ENTRY, missing);\n        udf_hash_delete(tmp);\n        if (new_dl) dlclose(dl);\n      }\n    }\n  }\n  if (error > 0) LogErr(ERROR_LEVEL, ER_UNKNOWN_ERROR_NUMBER, my_errno());\n  read_record_info.iterator.reset();\n  table->m_needs_reopen = true;  // Force close to free memory\n\nend:\n  close_trans_system_tables(new_thd);\n  delete new_thd;\n  DBUG_VOID_RETURN;\n}\n\n/**\n   Deintialize the UDF subsystem.\n\n   This function closes the shared libaries.\n*/\nvoid udf_unload_udfs() {\n  DBUG_ENTER(\"udf_unload_udfs\");\n  if (udf_hash != nullptr) {\n    for (auto it1 = udf_hash->begin(); it1 != udf_hash->end(); ++it1) {\n      udf_func *udf = it1->second;\n      if (udf->dlhandle)  // Not closed before\n      {\n        /* Mark all versions using the same handler as closed */\n        for (auto it2 = std::next(it1); it2 != udf_hash->end(); ++it2) {\n          udf_func *tmp = it2->second;\n          if (udf->dlhandle == tmp->dlhandle)\n            tmp->dlhandle = 0;  // Already closed\n        }\n        dlclose(udf->dlhandle);\n      }\n    }\n  }\n  DBUG_VOID_RETURN;\n}\n\n/**\n   Deintialize the UDF subsystem.\n\n   This function does the following:\n   1. Free the UDF hash.\n   2. Free the memroot allocated.\n   3. Destroy the RW mutex object.\n*/\nvoid udf_deinit_globals() {\n  DBUG_ENTER(\"udf_deinit_globals\");\n  if (udf_hash != nullptr) {\n    delete udf_hash;\n    udf_hash = nullptr;\n  }\n  free_root(&mem, MYF(0));\n  initialized = 0;\n\n  mysql_rwlock_destroy(&THR_LOCK_udf);\n  DBUG_VOID_RETURN;\n}\n\n/**\n   Delete the UDF function from the UDF hash.\n\n   @param udf  Pointer to the UDF function.\n\n   @note The function remove the udf function from the udf\n         hash if it is not in use. If the function is in use,\n         the function name is renamed so that it is not used.\n         The function shall be removed when no threads use it.\n*/\nstatic void udf_hash_delete(udf_func *udf) {\n  DBUG_ENTER(\"udf_hash_delete\");\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n\n  const auto it = udf_hash->find(to_string(udf->name));\n  if (it == udf_hash->end()) {\n    DBUG_ASSERT(false);\n    DBUG_VOID_RETURN;\n  }\n\n  if (!--udf->usage_count) {\n    udf_hash->erase(it);\n    using_udf_functions = !udf_hash->empty();\n  } else {\n    /*\n      The functions is in use ; Rename the functions instead of removing it.\n      The functions will be automaticly removed when the least threads\n      doesn't use it anymore\n    */\n    udf_hash->erase(it);\n    char new_name[32];\n    snprintf(new_name, sizeof(new_name), \"*<%p>\", udf);\n    udf_hash->emplace(new_name, udf);\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_VOID_RETURN;\n}\n\nvoid free_udf(udf_func *udf) {\n  DBUG_ENTER(\"free_udf\");\n\n  if (!initialized) DBUG_VOID_RETURN;\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  if (!--udf->usage_count) {\n    /*\n      We come here when someone has deleted the udf function\n      while another thread still was using the udf\n    */\n    const auto it = udf_hash->find(to_string(udf->name));\n    if (it == udf_hash->end()) {\n      DBUG_ASSERT(false);\n      DBUG_VOID_RETURN;\n    }\n    udf_hash->erase(it);\n    using_udf_functions = !udf_hash->empty();\n    if (udf->dlhandle && !find_udf_dl(udf->dl)) dlclose(udf->dlhandle);\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_VOID_RETURN;\n}\n\n/* This is only called if using_udf_functions != 0 */\n\nudf_func *find_udf(const char *name, size_t length, bool mark_used) {\n  udf_func *udf = 0;\n  DBUG_ENTER(\"find_udf\");\n\n  if (!initialized) DBUG_RETURN(NULL);\n\n  /* TODO: This should be changed to reader locks someday! */\n  if (mark_used)\n    mysql_rwlock_wrlock(&THR_LOCK_udf); /* Called during fix_fields */\n  else\n    mysql_rwlock_rdlock(&THR_LOCK_udf); /* Called during parsing */\n\n  std::string key = length ? std::string(name, length) : std::string(name);\n  const auto it = udf_hash->find(key);\n\n  if (it != udf_hash->end()) {\n    udf = it->second;\n    if (mark_used) udf->usage_count++;\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_RETURN(udf);\n}\n\nstatic void *find_udf_dl(const char *dl) {\n  DBUG_ENTER(\"find_udf_dl\");\n\n  if (!dl) DBUG_RETURN(0);\n  /*\n    Because only the function name is hashed, we have to search trough\n    all rows to find the dl.\n  */\n  for (const auto &key_and_value : *udf_hash) {\n    udf_func *udf = key_and_value.second;\n    if (udf->dl && !strcmp(dl, udf->dl) && udf->dlhandle != NULL)\n      DBUG_RETURN(udf->dlhandle);\n  }\n  DBUG_RETURN(0);\n}\n\n/* Assume that name && dl is already allocated */\n\nstatic udf_func *add_udf(LEX_STRING *name, Item_result ret, char *dl,\n                         Item_udftype type) {\n  if (!name || !dl || !(uint)type || (uint)type > (uint)UDFTYPE_AGGREGATE)\n    return nullptr;\n\n  udf_func *tmp = (udf_func *)alloc_root(&mem, sizeof(udf_func));\n  if (!tmp) return nullptr;\n  memset(tmp, 0, sizeof(*tmp));\n  tmp->name = *name;  // dup !!\n  tmp->dl = dl;\n  tmp->returns = ret;\n  tmp->type = type;\n  tmp->usage_count = 1;\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n\n  udf_hash->emplace(to_string(tmp->name), tmp);\n  using_udf_functions = 1;\n\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  return tmp;\n}\n\n/**\n   Commit or rollback a transaction. Also close tables\n   which it has opened and release metadata locks.\n   Add/Remove from the in-memory hash depending on transaction\n   commit or rollback and the bool flag passed to this function.\n\n   @param thd                 THD context.\n   @param rollback            Rollback transaction if true.\n   @param udf                 Pointer to UDF function.\n   @param insert_udf          Insert UDF in hash if true.\n\n   @retval False - Success.\n   @retval True  - Error.\n*/\n\nstatic bool udf_end_transaction(THD *thd, bool rollback, udf_func *udf,\n                                bool insert_udf) {\n  bool result;\n  bool rollback_transaction = thd->transaction_rollback_request || rollback;\n  udf_func *u_f = nullptr;\n\n  DBUG_ASSERT(stmt_causes_implicit_commit(thd, CF_IMPLICIT_COMMIT_END));\n\n  if (!rollback_transaction && insert_udf) {\n    udf->name.str = strdup_root(&mem, udf->name.str);\n    udf->dl = strdup_root(&mem, udf->dl);\n    // create entry in mysql.func table\n    u_f = add_udf(&udf->name, udf->returns, udf->dl, udf->type);\n    if (u_f != nullptr) {\n      u_f->dlhandle = udf->dlhandle;\n      u_f->func = udf->func;\n      u_f->func_init = udf->func_init;\n      u_f->func_deinit = udf->func_deinit;\n      u_f->func_clear = udf->func_clear;\n      u_f->func_add = udf->func_add;\n    }\n  }\n\n  rollback_transaction = rollback_transaction || (insert_udf && u_f == nullptr);\n\n  /*\n    CREATE/DROP UDF operations must acquire IX Backup Lock in order\n    to be mutually exclusive with LOCK INSTANCE FOR BACKUP.\n  */\n  DBUG_ASSERT(thd->mdl_context.owns_equal_or_stronger_lock(\n      MDL_key::BACKUP_LOCK, \"\", \"\", MDL_INTENTION_EXCLUSIVE));\n\n  /*\n    Rollback the transaction if there is an error or there is a request by the\n    SE (which is unlikely).\n  */\n  if (rollback_transaction) {\n    result = trans_rollback_stmt(thd);\n    result = result || trans_rollback_implicit(thd);\n  } else {\n    result = trans_commit_stmt(thd);\n    result = result || trans_commit_implicit(thd);\n  }\n\n  /*\n    Delete UDF from the hash if\n      * the transaction commit fails for CREATE UDF operation\n      * OR if the transaction is committed successfully for the DROP UDF\n        operation.\n  */\n  if (!rollback_transaction &&\n      ((insert_udf && result) || (!insert_udf && !result)))\n    udf_hash_delete(udf);\n\n  close_thread_tables(thd);\n  thd->mdl_context.release_transactional_locks();\n\n  return result || rollback || (insert_udf && u_f == nullptr);\n}\n\n/**\n  Create a user defined function.\n\n  Atomicity:\n    The operation to create a user defined function is atomic/crash-safe.\n    Changes to the Data-dictionary and writing event to binlog are\n    part of the same transaction. All the changes are done as part\n    of the same transaction or do not have any side effects on the\n    operation failure. UDF hash is in sync with operation state.\n    UDF hash do not contain any stale/incorrect data in case of failure.\n    In case of crash, there won't be any discrepancy between the\n    data-dictionary table and the binary log.\n\n  @param thd                 THD context.\n  @param udf                 Pointer to UDF function.\n\n  @note Like implementations of other DDL/DML in MySQL, this function\n  relies on the caller to close the thread tables. This is done in the\n  end of dispatch_command().\n*/\n\nbool mysql_create_function(THD *thd, udf_func *udf) {\n  bool error = true;\n  void *dl = 0;\n  int new_dl = 0;\n  TABLE *table;\n  TABLE_LIST tables;\n\n  DBUG_ENTER(\"mysql_create_function\");\n\n  if (!initialized) {\n    if (opt_noacl)\n      my_error(ER_CANT_INITIALIZE_UDF, MYF(0), udf->name.str,\n               \"UDFs are unavailable with the --skip-grant-tables option\");\n    else\n      my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    DBUG_RETURN(error);\n  }\n\n  /* must not be dynamically registered */\n  DBUG_ASSERT(udf->dl);\n\n  /*\n    Ensure that the .dll doesn't have a path\n    This is done to ensure that only approved dll from the system\n    directories are used (to make this even remotely secure).\n  */\n  if (check_valid_path(udf->dl, strlen(udf->dl))) {\n    my_error(ER_UDF_NO_PATHS, MYF(0));\n    DBUG_RETURN(error);\n  }\n  LEX_CSTRING udf_name_cstr = {udf->name.str, udf->name.length};\n  if (check_string_char_length(udf_name_cstr, \"\", NAME_CHAR_LEN,\n                               system_charset_info, 1)) {\n    my_error(ER_TOO_LONG_IDENT, MYF(0), udf->name.str);\n    DBUG_RETURN(error);\n  }\n\n  /*\n    Acquire MDL SNRW for TL_WRITE type so that deadlock and\n    timeout errors are avoided from the Storage Engine.\n  */\n  tables.init_one_table(C_STRING_WITH_LEN(\"mysql\"), C_STRING_WITH_LEN(\"func\"),\n                        \"func\", TL_WRITE, MDL_SHARED_NO_READ_WRITE);\n\n  if (open_and_lock_tables(thd, &tables, MYSQL_LOCK_IGNORE_TIMEOUT))\n    DBUG_RETURN(error);\n  table = tables.table;\n  /*\n    Turn off row binlogging of this statement and use statement-based\n    so that all supporting tables are updated for CREATE FUNCTION command.\n  */\n  Save_and_Restore_binlog_format_state binlog_format_state(thd);\n\n  mysql_rwlock_rdlock(&THR_LOCK_udf);\n  if (udf_hash->count(to_string(udf->name)) != 0) {\n    my_error(ER_UDF_EXISTS, MYF(0), udf->name.str);\n    mysql_rwlock_unlock(&THR_LOCK_udf);\n    DBUG_RETURN(error);\n  }\n  dl = find_udf_dl(udf->dl);\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n\n  if (dl == nullptr) {\n    char dlpath[FN_REFLEN];\n    strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", udf->dl, NullS);\n    (void)unpack_filename(dlpath, dlpath);\n\n    if (!(dl = dlopen(dlpath, RTLD_NOW))) {\n      const char *errmsg;\n      int error_number = dlopen_errno;\n      DLERROR_GENERATE(errmsg, error_number);\n\n      DBUG_PRINT(\"error\", (\"dlopen of %s failed, error: %d (%s)\", udf->dl,\n                           error_number, errmsg));\n      my_error(ER_CANT_OPEN_LIBRARY, MYF(0), udf->dl, error_number, errmsg);\n      DBUG_RETURN(error);\n    }\n    new_dl = 1;\n  }\n  udf->dlhandle = dl;\n  {\n    char buf[NAME_LEN + 16], *missing;\n    if ((missing = init_syms(udf, buf))) {\n      my_error(ER_CANT_FIND_DL_ENTRY, MYF(0), missing);\n      if (new_dl) dlclose(dl);\n      DBUG_RETURN(error);\n    }\n  }\n\n  // create entry in mysql.func table\n\n  table->use_all_columns();\n  restore_record(table, s->default_values);  // Default values for fields\n  table->field[0]->store(udf->name.str, udf->name.length, system_charset_info);\n  table->field[1]->store((longlong)udf->returns, true);\n  table->field[2]->store(udf->dl, strlen(udf->dl), system_charset_info);\n  if (table->s->fields >= 4)  // If not old func format\n    table->field[3]->store((longlong)udf->type, true);\n  error = (table->file->ha_write_row(table->record[0]) != 0);\n\n  // Binlog the create function.\n  if (!error)\n    error = (write_bin_log(thd, true, thd->query().str, thd->query().length,\n                           true) != 0);\n\n  error = udf_end_transaction(thd, error, udf, true);\n\n  if (error) {\n    char errbuf[MYSYS_STRERROR_SIZE];\n    my_error(ER_ERROR_ON_WRITE, MYF(0), \"mysql.func\", error,\n             my_strerror(errbuf, sizeof(errbuf), error));\n    if (new_dl) dlclose(dl);\n  }\n  DBUG_RETURN(error);\n}\n\n/**\n  Drop a user defined function.\n\n  Atomicity:\n    The operation to drop a user defined function is atomic/crash-safe.\n    Changes to the Data-dictionary and writing event to binlog are\n    part of the same transaction. All the changes are done as part\n    of the same transaction or do not have any side effects on the\n    operation failure. UDF hash is in sync with operation state.\n    UDF hash do not contain any stale/incorrect data in case of failure.\n    In case of crash, there won't be any discrepancy between the\n    data-dictionary table and the binary log.\n\n  @param thd                 THD context.\n  @param udf_name            Name of the UDF function.\n*/\n\nbool mysql_drop_function(THD *thd, const LEX_STRING *udf_name) {\n  TABLE *table;\n  TABLE_LIST tables;\n  udf_func *udf;\n  bool error = true;\n\n  DBUG_ENTER(\"mysql_drop_function\");\n\n  if (!initialized) {\n    if (opt_noacl)\n      my_error(ER_FUNCTION_NOT_DEFINED, MYF(0), udf_name->str);\n    else\n      my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    DBUG_RETURN(error);\n  }\n\n  tables.init_one_table(C_STRING_WITH_LEN(\"mysql\"), C_STRING_WITH_LEN(\"func\"),\n                        \"func\", TL_WRITE, MDL_SHARED_NO_READ_WRITE);\n\n  if (open_and_lock_tables(thd, &tables, MYSQL_LOCK_IGNORE_TIMEOUT))\n    DBUG_RETURN(error);\n  table = tables.table;\n  /*\n    Turn off row binlogging of this statement and use statement-based\n    so that all supporting tables are updated for DROP FUNCTION command.\n  */\n  Save_and_Restore_binlog_format_state binlog_format_state(thd);\n\n  mysql_rwlock_rdlock(&THR_LOCK_udf);\n  const auto it = udf_hash->find(to_string(*udf_name));\n  if (it == udf_hash->end()) {\n    my_error(ER_FUNCTION_NOT_DEFINED, MYF(0), udf_name->str);\n    mysql_rwlock_unlock(&THR_LOCK_udf);\n    DBUG_RETURN(error);\n  }\n  udf = it->second;\n  if (!udf->dl) {\n    mysql_rwlock_unlock(&THR_LOCK_udf);\n    my_error(ER_UDF_DROP_DYNAMICALLY_REGISTERED, MYF(0));\n    DBUG_RETURN(error);\n  }\n\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n\n  table->use_all_columns();\n  table->field[0]->store(udf->name.str, udf->name.length, &my_charset_bin);\n  if (!table->file->ha_index_read_idx_map(table->record[0], 0,\n                                          table->field[0]->ptr, HA_WHOLE_KEY,\n                                          HA_READ_KEY_EXACT)) {\n    int delete_err;\n    if ((delete_err = table->file->ha_delete_row(table->record[0])))\n      table->file->print_error(delete_err, MYF(0));\n    error = delete_err != 0;\n  }\n\n  /*\n    Binlog the drop function. Keep the table open and locked\n    while binlogging, to avoid binlog inconsistency.\n  */\n  if (!error)\n    error = (write_bin_log(thd, true, thd->query().str, thd->query().length,\n                           true) != 0);\n\n  error = udf_end_transaction(thd, error, udf, false);\n\n  /*\n    Close the handle if this was function that was found during boot or\n    CREATE FUNCTION and it's not in use by any other udf function\n  */\n  if (udf->dlhandle && !find_udf_dl(udf->dl)) dlclose(udf->dlhandle);\n\n  DBUG_RETURN(error);\n}\n\n#include \"sql/udf_registration_imp.h\"\n\nbool mysql_udf_registration_imp::udf_register_inner(udf_func *ufunc) {\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n\n  DBUG_ASSERT(ufunc->dl == NULL);\n  DBUG_ASSERT(ufunc->dlhandle == NULL);\n\n  auto res = udf_hash->emplace(to_string(ufunc->name), ufunc);\n  if (!res.second)\n    ufunc = nullptr;\n  else\n    using_udf_functions = 1;\n\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  return ufunc == nullptr;\n}\n\nudf_func *mysql_udf_registration_imp::alloc_udf(const char *name,\n                                                Item_result return_type,\n                                                Udf_func_any func,\n                                                Udf_func_init init_func,\n                                                Udf_func_deinit deinit_func) {\n  udf_func *ufunc;\n\n  ufunc = (udf_func *)alloc_root(&mem, sizeof(udf_func));\n  if (!ufunc) return NULL;\n  memset(ufunc, 0, sizeof(udf_func));\n  ufunc->name.str = strdup_root(&mem, name);\n  ufunc->name.length = strlen(name);\n  ufunc->func = func;\n  ufunc->func_init = init_func;\n  ufunc->func_deinit = deinit_func;\n  ufunc->returns = return_type;\n  ufunc->usage_count = 1;\n\n  return ufunc;\n}\n\nDEFINE_BOOL_METHOD(mysql_udf_registration_imp::udf_register,\n                   (const char *name, Item_result return_type,\n                    Udf_func_any func, Udf_func_init init_func,\n                    Udf_func_deinit deinit_func)) {\n  udf_func *ufunc;\n\n  if (!func && !init_func && !deinit_func) return true;\n\n  ufunc = alloc_udf(name, return_type, func, init_func, deinit_func);\n  if (!ufunc) return true;\n  ufunc->type = Item_udftype::UDFTYPE_FUNCTION;\n\n  return udf_register_inner(ufunc);\n}\n\nDEFINE_BOOL_METHOD(mysql_udf_registration_imp::udf_register_aggregate,\n                   (const char *name, enum Item_result return_type,\n                    Udf_func_any func, Udf_func_init init_func,\n                    Udf_func_deinit deinit_func, Udf_func_add add_func,\n                    Udf_func_clear clear_func)) {\n  udf_func *ufunc;\n\n  if (!func && !add_func && !clear_func && !init_func && !deinit_func)\n    return true;\n\n  ufunc = alloc_udf(name, return_type, func, init_func, deinit_func);\n  if (!ufunc) return true;\n  ufunc->type = Item_udftype::UDFTYPE_AGGREGATE;\n  ufunc->func_add = add_func;\n  ufunc->func_clear = clear_func;\n\n  return udf_register_inner(ufunc);\n}\n\nDEFINE_BOOL_METHOD(mysql_udf_registration_imp::udf_unregister,\n                   (const char *name, int *was_present)) {\n  udf_func *udf = NULL;\n\n  if (was_present) *was_present = 0;\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  const auto it = udf_hash->find(name);\n  if (it != udf_hash->end()) {\n    if (was_present) *was_present = 1;\n\n    udf = it->second;\n\n    if (!udf->dl && !udf->dlhandle &&  // Not registered via CREATE FUNCTION\n        !--udf->usage_count)           // Not used\n    {\n      udf_hash->erase(it);\n      using_udf_functions = !udf_hash->empty();\n    } else  // error\n      udf = NULL;\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  return udf != NULL ? false : true;\n}\n\nvoid udf_hash_rlock(void) { mysql_rwlock_rdlock(&THR_LOCK_udf); }\n\nvoid udf_hash_unlock(void) { mysql_rwlock_unlock(&THR_LOCK_udf); }\n\nulong udf_hash_size(void) { return udf_hash->size(); }\n\nvoid udf_hash_for_each(udf_hash_for_each_func_t *func, void *arg) {\n  for (auto it : *udf_hash) func(it.second, arg);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/sql/sql_plugin.cc": "/* Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License, version 2.0,\n   as published by the Free Software Foundation.\n\n   This program is also distributed with certain software (including\n   but not limited to OpenSSL) that is licensed under separate terms,\n   as designated in a particular file or component or in included license\n   documentation.  The authors of MySQL hereby grant you an additional\n   permission to link the program and your derivative works with the\n   separately licensed software that they have included with MySQL.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License, version 2.0, for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n#include \"sql/sql_plugin.h\"\n\n#include \"my_config.h\"\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"m_ctype.h\"\n#include \"m_string.h\"\n#include \"map_helpers.h\"\n#include \"mutex_lock.h\"  // MUTEX_LOCK\n#include \"my_alloc.h\"\n#include \"my_base.h\"\n#include \"my_compiler.h\"\n#include \"my_dbug.h\"\n#include \"my_default.h\"  // free_defaults\n#include \"my_getopt.h\"\n#include \"my_inttypes.h\"\n#include \"my_list.h\"\n#include \"my_loglevel.h\"\n#include \"my_macros.h\"\n#include \"my_psi_config.h\"\n#include \"my_sharedlib.h\"\n#include \"my_sys.h\"\n#include \"my_thread_local.h\"\n#include \"mysql/components/services/log_builtins.h\"\n#include \"mysql/components/services/log_shared.h\"\n#include \"mysql/components/services/psi_memory_bits.h\"\n#include \"mysql/components/services/psi_mutex_bits.h\"\n#include \"mysql/components/services/system_variable_source_type.h\"\n#include \"mysql/plugin_audit.h\"\n#include \"mysql/plugin_auth.h\"\n#include \"mysql/plugin_clone.h\"\n#include \"mysql/plugin_group_replication.h\"\n#include \"mysql/plugin_keyring.h\"\n#include \"mysql/plugin_validate_password.h\"\n#include \"mysql/psi/mysql_memory.h\"\n#include \"mysql/psi/mysql_mutex.h\"\n#include \"mysql/psi/mysql_rwlock.h\"\n#include \"mysql/psi/mysql_system.h\"\n#include \"mysql/psi/mysql_thread.h\"\n#include \"mysql/psi/psi_base.h\"\n#include \"mysql/service_mysql_alloc.h\"\n#include \"mysql_com.h\"\n#include \"mysql_version.h\"\n#include \"mysqld_error.h\"\n#include \"prealloced_array.h\"\n#include \"sql/auth/auth_acls.h\"\n#include \"sql/auth/auth_common.h\"  // check_table_access\n#include \"sql/auto_thd.h\"          // Auto_THD\n#include \"sql/current_thd.h\"\n#include \"sql/dd/cache/dictionary_client.h\"  // dd::cache::Dictionary_client\n#include \"sql/dd/dd_schema.h\"                // dd::Schema_MDL_locker\n#include \"sql/dd/info_schema/metadata.h\"  // dd::info_schema::store_dynamic_p...\n#include \"sql/dd/string_type.h\"           // dd::String_type\n#include \"sql/dd_sql_view.h\"              // update_referencing_views_metadata\n#include \"sql/debug_sync.h\"               // DEBUG_SYNC\n#include \"sql/derror.h\"                   // ER_THD\n#include \"sql/field.h\"\n#include \"sql/handler.h\"  // ha_initalize_handlerton\n#include \"sql/key.h\"      // key_copy\n#include \"sql/log.h\"\n#include \"sql/mdl.h\"\n#include \"sql/mysqld.h\"              // files_charset_info\n#include \"sql/persisted_variable.h\"  // Persisted_variables_cache\n#include \"sql/protocol_classic.h\"\n#include \"sql/psi_memory_key.h\"\n#include \"sql/records.h\"  // READ_RECORD\n#include \"sql/row_iterator.h\"\n#include \"sql/set_var.h\"\n#include \"sql/sql_audit.h\"        // mysql_audit_acquire_plugins\n#include \"sql/sql_backup_lock.h\"  // acquire_shared_backup_lock\n#include \"sql/sql_base.h\"         // close_mysql_tables\n#include \"sql/sql_class.h\"        // THD\n#include \"sql/sql_const.h\"\n#include \"sql/sql_error.h\"\n#include \"sql/sql_lex.h\"\n#include \"sql/sql_list.h\"\n#include \"sql/sql_parse.h\"  // check_string_char_length\n#include \"sql/sql_plugin_var.h\"\n#include \"sql/sql_show.h\"  // add_status_vars\n#include \"sql/sql_table.h\"\n#include \"sql/sys_vars_resource_mgr.h\"\n#include \"sql/sys_vars_shared.h\"  // intern_find_sys_var\n#include \"sql/system_variables.h\"\n#include \"sql/table.h\"\n#include \"sql/thd_raii.h\"\n#include \"sql/thr_malloc.h\"\n#include \"sql/transaction.h\"  // trans_rollback_stmt\n#include \"sql_string.h\"\n#include \"template_utils.h\"  // pointer_cast\n#include \"thr_lock.h\"\n#include \"thr_mutex.h\"\n#include \"typelib.h\"\n\n/* clang-format off */\n/**\n  @page page_ext_plugins Plugins\n\n  The Big Picture\n  ----------------\n\n  @startuml\n  actor \"SQL client\" as client\n  box \"MySQL Server\" #LightBlue\n    participant \"Server Code\" as server\n    participant \"Plugin\" as plugin\n  endbox\n\n  == INSTALL PLUGIN ==\n  server -> plugin : initialize\n  activate plugin\n  plugin --> server : initialization done\n\n  == CLIENT SESSION ==\n  loop many\n    client -> server : SQL command\n    server -> server : Add reference for Plugin if absent\n    loop one or many\n      server -> plugin : plugin API call\n      plugin --> server : plugin API call result\n    end\n    server -> server : Optionally release reference for Plugin\n    server --> client : SQL command reply\n  end\n\n  == UNINSTALL PLUGIN ==\n  server -> plugin : deinitialize\n  plugin --> server : deinitialization done\n  deactivate plugin\n  @enduml\n\n  @sa Sql_cmd_install_plugin, Sql_cmd_uninstall_plugin.\n*/\n\n/**\n  @page page_ext_plugin_services Plugin Services\n\n  Adding Plugin Services Into The Big Picture\n  ------------------------------------\n\n  You probably remember the big picture for @ref page_ext_plugins.\n  Below is an extended version of it with plugin services added.\n\n  @startuml\n\n  actor \"SQL client\" as client\n  box \"MySQL Server\" #LightBlue\n    participant \"Server Code\" as server\n    participant \"Plugin\" as plugin\n  endbox\n\n  == INSTALL PLUGIN ==\n  server -> plugin : initialize\n  activate plugin\n\n  loop zero or many\n    plugin -> server : service API call\n    server --> plugin : service API result\n  end\n  plugin --> server : initialization done\n\n  == CLIENT SESSION ==\n  loop many\n    client -> server : SQL command\n    server -> server : Add reference for Plugin if absent\n    loop one or many\n      server -> plugin : plugin API call\n      loop zero or many\n        plugin -> server : service API call\n        server --> plugin : service API result\n      end\n      plugin --> server : plugin API call result\n    end\n    server -> server : Optionally release reference for Plugin\n    server --> client : SQL command reply\n  end\n\n  == UNINSTALL PLUGIN ==\n  server -> plugin : deinitialize\n  loop zero or many\n    plugin -> server : service API call\n    server --> plugin : service API result\n  end\n  plugin --> server : deinitialization done\n  deactivate plugin\n  @enduml\n\n  Understanding and creating plugin services\n  -----------------------------\n\n  - @subpage page_ext_plugin_svc_anathomy\n  - @subpage page_ext_plugin_svc_new_service_howto\n  - @subpage page_ext_plugin_api_goodservices\n\n  @section sect_ext_plugin_svc_reference Plugin Services Reference\n\n   See @ref group_ext_plugin_services\n*/\n\n/**\n  @page page_ext_plugin_svc_anathomy Plugin Service Anathomy\n\n  A \"service\" is a struct of C function pointers.\n\n  It is a tool to expose a pre-exitsing set of server functions to plugins.\n  You need the actual server functions as a starting point.\n\n  The server has all service structs defined and initialized so\n  that the the function pointers point to the actual service implementation\n  functions.\n\n  The server also keeps a global list of the plugin service reference\n  structures called ::list_of_services.\n\n  See ::st_service_ref for details of what a service reference is.\n\n  The server copies of all plugin structures are filled in at compile time\n  with the function pointers of the actual server functions that implement\n  the service functions. References to them are stored into the relevant\n  element of ::list_of_services.\n\n  Each plugin must export pointer symbols for every plugin service that\n  the server knows about.\n\n  The plugin service pointers are initialized with the version of the plugin\n  service that the plugin expects.\n\n  When a dynamic plugin shared object is loaded by ::plugin_dl_add it will\n  iterate over ::list_of_services, find the plugin symbol by name,\n  check the service version stored in that symbol against the one stored into\n  ::st_service_ref and then will replace the version stored in plugin's struct\n  pointer with the actual pointer of the server's copy of the same structure.\n\n  When that is filled in the plugin can use the newly set server structure\n  through its local pointer to call into the service method pointers that point\n  to the server implementaiton functions.\n\n  Once set to the server's structure, the plugin's service pointer value is\n  never reset back to service version.\n\n  The plugin service header also defines a set of convenience macros\n  that replace top level plugin service calls with the corresponding function\n  pointer call, i.e. for service foo:\n\n  ~~~~\n  struct foo_service_st {\n     int (*foo_mtd_1)(int a);\n  }\n\n  struct foo_service_st *foo_service;\n  ~~~~\n\n  a convenience macro is defined for `foo_mtd_1` as follows:\n\n  ~~~~\n  #define foo_mtd_1(a)  foo_service->foo_mtd_1(a)\n  ~~~~\n\n  This trick allows plugin service functions to look as top level function\n  calls inside the plugin code.\n\n  @sa plugin_add, plugin_del, plugin_dl_add, plugin_dl_del, list_of_services,\n    st_service_ref\n*/\n/* clang-format on */\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <algorithm>\n#include <memory>\n#include <new>\n#include <unordered_map>\n#include <utility>\n\n#include \"sql/srv_session.h\"  // Srv_session::check_for_stale_threads()\n\nusing std::max;\nusing std::min;\n\n#define REPORT_TO_LOG 1\n#define REPORT_TO_USER 2\n\n#ifndef DBUG_OFF\nstatic PSI_memory_key key_memory_plugin_ref;\n#endif\n\nstatic PSI_memory_key key_memory_plugin_mem_root;\nstatic PSI_memory_key key_memory_plugin_init_tmp;\nstatic PSI_memory_key key_memory_plugin_int_mem_root;\nstatic PSI_memory_key key_memory_mysql_plugin;\nstatic PSI_memory_key key_memory_mysql_plugin_dl;\nstatic PSI_memory_key key_memory_plugin_bookmark;\n\nextern st_mysql_plugin *mysql_optional_plugins[];\nextern st_mysql_plugin *mysql_mandatory_plugins[];\n\n/**\n  @note The order of the enumeration is critical.\n  @see construct_options\n*/\nconst char *global_plugin_typelib_names[] = {\"OFF\", \"ON\", \"FORCE\",\n                                             \"FORCE_PLUS_PERMANENT\", NULL};\nstatic TYPELIB global_plugin_typelib = {\n    array_elements(global_plugin_typelib_names) - 1, \"\",\n    global_plugin_typelib_names, NULL};\n\nstatic I_List<i_string> opt_plugin_load_list;\nI_List<i_string> *opt_plugin_load_list_ptr = &opt_plugin_load_list;\nstatic I_List<i_string> opt_early_plugin_load_list;\nI_List<i_string> *opt_early_plugin_load_list_ptr = &opt_early_plugin_load_list;\nchar *opt_plugin_dir_ptr;\nchar opt_plugin_dir[FN_REFLEN];\n/*\n  When you ad a new plugin type, add both a string and make sure that the\n  init and deinit array are correctly updated.\n*/\nconst LEX_STRING plugin_type_names[MYSQL_MAX_PLUGIN_TYPE_NUM] = {\n    {C_STRING_WITH_LEN(\"UDF\")},\n    {C_STRING_WITH_LEN(\"STORAGE ENGINE\")},\n    {C_STRING_WITH_LEN(\"FTPARSER\")},\n    {C_STRING_WITH_LEN(\"DAEMON\")},\n    {C_STRING_WITH_LEN(\"INFORMATION SCHEMA\")},\n    {C_STRING_WITH_LEN(\"AUDIT\")},\n    {C_STRING_WITH_LEN(\"REPLICATION\")},\n    {C_STRING_WITH_LEN(\"AUTHENTICATION\")},\n    {C_STRING_WITH_LEN(\"VALIDATE PASSWORD\")},\n    {C_STRING_WITH_LEN(\"GROUP REPLICATION\")},\n    {C_STRING_WITH_LEN(\"KEYRING\")},\n    {C_STRING_WITH_LEN(\"CLONE\")}};\n\nextern int initialize_schema_table(st_plugin_int *plugin);\nextern int finalize_schema_table(st_plugin_int *plugin);\n\n/*\n  The number of elements in both plugin_type_initialize and\n  plugin_type_deinitialize should equal to the number of plugins\n  defined.\n*/\nplugin_type_init plugin_type_initialize[MYSQL_MAX_PLUGIN_TYPE_NUM] = {\n    0,\n    ha_initialize_handlerton,\n    0,\n    0,\n    initialize_schema_table,\n    initialize_audit_plugin,\n    0,\n    0,\n    0};\n\nplugin_type_init plugin_type_deinitialize[MYSQL_MAX_PLUGIN_TYPE_NUM] = {\n    0,\n    ha_finalize_handlerton,\n    0,\n    0,\n    finalize_schema_table,\n    finalize_audit_plugin,\n    0,\n    0,\n    0};\n\nstatic const char *plugin_interface_version_sym =\n    \"_mysql_plugin_interface_version_\";\nstatic const char *sizeof_st_plugin_sym = \"_mysql_sizeof_struct_st_plugin_\";\nstatic const char *plugin_declarations_sym = \"_mysql_plugin_declarations_\";\nstatic int min_plugin_interface_version =\n    MYSQL_PLUGIN_INTERFACE_VERSION & ~0xFF;\n\nstatic void *innodb_callback_data;\n\n/* Note that 'int version' must be the first field of every plugin\n   sub-structure (plugin->info).\n*/\nstatic int min_plugin_info_interface_version[MYSQL_MAX_PLUGIN_TYPE_NUM] = {\n    0x0000,\n    MYSQL_HANDLERTON_INTERFACE_VERSION,\n    MYSQL_FTPARSER_INTERFACE_VERSION,\n    MYSQL_DAEMON_INTERFACE_VERSION,\n    MYSQL_INFORMATION_SCHEMA_INTERFACE_VERSION,\n    MYSQL_AUDIT_INTERFACE_VERSION,\n    MYSQL_REPLICATION_INTERFACE_VERSION,\n    MYSQL_AUTHENTICATION_INTERFACE_VERSION,\n    MYSQL_VALIDATE_PASSWORD_INTERFACE_VERSION,\n    MYSQL_GROUP_REPLICATION_INTERFACE_VERSION,\n    MYSQL_KEYRING_INTERFACE_VERSION,\n    MYSQL_CLONE_INTERFACE_VERSION};\nstatic int cur_plugin_info_interface_version[MYSQL_MAX_PLUGIN_TYPE_NUM] = {\n    0x0000, /* UDF: not implemented */\n    MYSQL_HANDLERTON_INTERFACE_VERSION,\n    MYSQL_FTPARSER_INTERFACE_VERSION,\n    MYSQL_DAEMON_INTERFACE_VERSION,\n    MYSQL_INFORMATION_SCHEMA_INTERFACE_VERSION,\n    MYSQL_AUDIT_INTERFACE_VERSION,\n    MYSQL_REPLICATION_INTERFACE_VERSION,\n    MYSQL_AUTHENTICATION_INTERFACE_VERSION,\n    MYSQL_VALIDATE_PASSWORD_INTERFACE_VERSION,\n    MYSQL_GROUP_REPLICATION_INTERFACE_VERSION,\n    MYSQL_KEYRING_INTERFACE_VERSION,\n    MYSQL_CLONE_INTERFACE_VERSION};\n\n/* support for Services */\n\n#include \"sql/sql_plugin_services.h\"\n\n/*\n  A mutex LOCK_plugin_delete must be acquired before calling plugin_del\n  function.\n*/\nmysql_mutex_t LOCK_plugin_delete;\n\n/**\n  Serializes access to the global plugin memory list.\n\n  LOCK_plugin must be acquired before accessing\n  plugin_dl_array, plugin_array and plugin_hash.\n  We are always manipulating ref count, so a rwlock here is unneccessary.\n  If it must be taken together with the LOCK_system_variables_hash then\n  LOCK_plugin must be taken before LOCK_system_variables_hash.\n*/\nmysql_mutex_t LOCK_plugin;\n/**\n  Serializes the INSTALL and UNINSTALL PLUGIN commands.\n  Must be taken before LOCK_plugin.\n*/\nmysql_mutex_t LOCK_plugin_install;\nstatic Prealloced_array<st_plugin_dl *, 16> *plugin_dl_array;\nstatic Prealloced_array<st_plugin_int *, 16> *plugin_array;\nstatic collation_unordered_map<std::string, st_plugin_int *>\n    *plugin_hash[MYSQL_MAX_PLUGIN_TYPE_NUM] = {nullptr};\nstatic bool reap_needed = false;\nstatic int plugin_array_version = 0;\n\nstatic bool initialized = false;\n\nstatic MEM_ROOT plugin_mem_root;\nstatic uint global_variables_dynamic_size = 0;\nstatic malloc_unordered_map<std::string, st_bookmark *> *bookmark_hash;\n/** Hash for system variables of string type with MEMALLOC flag. */\nstatic malloc_unordered_map<std::string, st_bookmark *>\n    *malloced_string_type_sysvars_bookmark_hash;\n\n/* prototypes */\nstatic void plugin_load(MEM_ROOT *tmp_root, int *argc, char **argv);\nstatic bool plugin_load_list(MEM_ROOT *tmp_root, int *argc, char **argv,\n                             const char *list);\nstatic bool check_if_option_is_deprecated(int optid,\n                                          const struct my_option *opt,\n                                          char *argument);\nstatic int test_plugin_options(MEM_ROOT *, st_plugin_int *, int *, char **);\nstatic bool register_builtin(st_mysql_plugin *, st_plugin_int *,\n                             st_plugin_int **);\nstatic void unlock_variables(struct System_variables *vars);\nstatic void cleanup_variables(THD *thd, struct System_variables *vars);\nstatic void plugin_vars_free_values(sys_var *vars);\nstatic void plugin_var_memalloc_free(struct System_variables *vars);\nstatic void restore_pluginvar_names(sys_var *first);\n#define my_intern_plugin_lock(A, B) intern_plugin_lock(A, B)\n#define my_intern_plugin_lock_ci(A, B) intern_plugin_lock(A, B)\nstatic plugin_ref intern_plugin_lock(LEX *lex, plugin_ref plugin);\nstatic void intern_plugin_unlock(LEX *lex, plugin_ref plugin);\nstatic void reap_plugins(void);\n\nmalloc_unordered_map<std::string, st_bookmark *> *get_bookmark_hash(void) {\n  return bookmark_hash;\n}\n\nstatic void report_error(int where_to, uint error, ...) {\n  va_list args;\n  if (where_to & REPORT_TO_USER) {\n    va_start(args, error);\n    my_printv_error(error, ER_THD(current_thd, error), MYF(0), args);\n    va_end(args);\n  }\n  if (where_to & REPORT_TO_LOG) {\n    longlong ecode = 0;\n    switch (error) {\n      case ER_UDF_NO_PATHS:\n        ecode = ER_NO_PATH_FOR_SHARED_LIBRARY;\n        break;\n      case ER_CANT_OPEN_LIBRARY:\n        ecode = ER_FAILED_TO_OPEN_SHARED_LIBRARY;\n        break;\n      case ER_CANT_FIND_DL_ENTRY:\n        ecode = ER_FAILED_TO_FIND_DL_ENTRY;\n        break;\n      case ER_OUTOFMEMORY:\n        ecode = ER_SERVER_OUTOFMEMORY;\n        break;\n      case ER_UDF_EXISTS:\n        ecode = ER_UDF_ALREADY_EXISTS;\n        break;\n      default:\n        DBUG_ASSERT(false);\n        return;\n    }\n    va_start(args, error);\n    LogEvent().type(LOG_TYPE_ERROR).prio(ERROR_LEVEL).lookupv(ecode, args);\n    va_end(args);\n  }\n}\n\n/**\n   Check if the provided path is valid in the sense that it does cause\n   a relative reference outside the directory.\n\n   @note Currently, this function only check if there are any\n   characters in FN_DIRSEP in the string, but it might change in the\n   future.\n\n   @code\n   check_valid_path(\"../foo.so\") -> true\n   check_valid_path(\"foo.so\") -> false\n   @endcode\n */\nbool check_valid_path(const char *path, size_t len) {\n  size_t prefix = my_strcspn(files_charset_info, path, path + len, FN_DIRSEP,\n                             strlen(FN_DIRSEP));\n  return prefix < len;\n}\n\n/****************************************************************************\n  Plugin support code\n****************************************************************************/\n\nstatic st_plugin_dl *plugin_dl_find(const LEX_STRING *dl) {\n  DBUG_ENTER(\"plugin_dl_find\");\n  for (st_plugin_dl **it = plugin_dl_array->begin();\n       it != plugin_dl_array->end(); ++it) {\n    st_plugin_dl *tmp = *it;\n    if (tmp->ref_count &&\n        !my_strnncoll(files_charset_info, pointer_cast<uchar *>(dl->str),\n                      dl->length, pointer_cast<uchar *>(tmp->dl.str),\n                      tmp->dl.length))\n      DBUG_RETURN(tmp);\n  }\n  DBUG_RETURN(NULL);\n}\n\nstatic st_plugin_dl *plugin_dl_insert_or_reuse(st_plugin_dl *plugin_dl) {\n  DBUG_ENTER(\"plugin_dl_insert_or_reuse\");\n  st_plugin_dl *tmp;\n  for (st_plugin_dl **it = plugin_dl_array->begin();\n       it != plugin_dl_array->end(); ++it) {\n    tmp = *it;\n    if (!tmp->ref_count) {\n      memcpy(tmp, plugin_dl, sizeof(st_plugin_dl));\n      DBUG_RETURN(tmp);\n    }\n  }\n  if (plugin_dl_array->push_back(plugin_dl)) DBUG_RETURN(NULL);\n  tmp = plugin_dl_array->back() = static_cast<st_plugin_dl *>(\n      memdup_root(&plugin_mem_root, plugin_dl, sizeof(st_plugin_dl)));\n  DBUG_RETURN(tmp);\n}\n\nstatic inline void free_plugin_mem(st_plugin_dl *p) {\n  /*\n     The valgrind leak report is done at the end of the program execution.\n     But since the plugins are unloaded from the memory,\n     it is impossible for valgrind to correctly report the leak locations.\n     So leave the shared objects (.DLL/.so) open for the symbols definition.\n   */\n  bool preserve_shared_objects_after_unload = false;\n  DBUG_EXECUTE_IF(\"preserve_shared_objects_after_unload\",\n                  { preserve_shared_objects_after_unload = true; });\n  if (p->handle != nullptr && !preserve_shared_objects_after_unload) {\n#ifdef HAVE_PSI_SYSTEM_INTERFACE\n    PSI_SYSTEM_CALL(unload_plugin)\n    (std::string(p->dl.str, p->dl.length).c_str());\n#endif\n    dlclose(p->handle);\n  }\n  my_free(p->dl.str);\n  if (p->version != MYSQL_PLUGIN_INTERFACE_VERSION) my_free(p->plugins);\n}\n\n/**\n  Loads a dynamic plugin\n\n  Fills in a ::st_plugin_dl structure.\n  Initializes the plugin services pointer inside the plugin.\n  Does not initialize the individual plugins.\n  Must have LOCK_plugin and LOCK_system_variables locked(write).\n  On error releases LOCK_system_variables and LOCK_plugin.\n\n  @arg dl      The path to the plugin binary to load\n  @arg report  a bitmask that's passed down to report_error()\n\n  @return      A plugin reference.\n  @retval      NULL      failed to load the plugin\n*/\nstatic st_plugin_dl *plugin_dl_add(const LEX_STRING *dl, int report) {\n  char dlpath[FN_REFLEN];\n  uint dummy_errors, i;\n  size_t plugin_dir_len, dlpathlen;\n  st_plugin_dl *tmp, plugin_dl;\n  void *sym;\n  DBUG_ENTER(\"plugin_dl_add\");\n  DBUG_PRINT(\"enter\",\n             (\"dl->str: '%s', dl->length: %d\", dl->str, (int)dl->length));\n  plugin_dir_len = strlen(opt_plugin_dir);\n  /*\n    Ensure that the dll doesn't have a path.\n    This is done to ensure that only approved libraries from the\n    plugin directory are used (to make this even remotely secure).\n  */\n  LEX_CSTRING dl_cstr = {dl->str, dl->length};\n  if (check_valid_path(dl->str, dl->length) ||\n      check_string_char_length(dl_cstr, \"\", NAME_CHAR_LEN, system_charset_info,\n                               1) ||\n      plugin_dir_len + dl->length + 1 >= FN_REFLEN) {\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    report_error(report, ER_UDF_NO_PATHS);\n    DBUG_RETURN(NULL);\n  }\n  /* If this dll is already loaded just increase ref_count. */\n  if ((tmp = plugin_dl_find(dl))) {\n    tmp->ref_count++;\n    DBUG_RETURN(tmp);\n  }\n  memset(&plugin_dl, 0, sizeof(plugin_dl));\n  /* Compile dll path */\n  dlpathlen = strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", dl->str,\n                       NullS) -\n              dlpath;\n  (void)unpack_filename(dlpath, dlpath);\n  plugin_dl.ref_count = 1;\n  /* Open new dll handle */\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  if (!(plugin_dl.handle = dlopen(dlpath, RTLD_NOW))) {\n    const char *errmsg;\n    int error_number = dlopen_errno;\n    /*\n      Conforming applications should use a critical section to retrieve\n      the error pointer and buffer...\n    */\n    DLERROR_GENERATE(errmsg, error_number);\n\n    if (!strncmp(\n            dlpath, errmsg,\n            dlpathlen)) {  // if errmsg starts from dlpath, trim this prefix.\n      errmsg += dlpathlen;\n      if (*errmsg == ':') errmsg++;\n      if (*errmsg == ' ') errmsg++;\n    }\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, error_number, errmsg);\n\n    /*\n      \"The messages returned by dlerror() may reside in a static buffer\n       that is overwritten on each call to dlerror().\"\n\n      Some implementations have a static pointer instead, and the memory it\n      points to may be reported as \"still reachable\" by Valgrind.\n      Calling dlerror() once more will free the memory.\n     */\n#if !defined(_WIN32)\n    errmsg = dlerror();\n    DBUG_ASSERT(errmsg == NULL);\n#endif\n    DBUG_RETURN(NULL);\n  }\n  /* Determine interface version */\n  if (!(sym = dlsym(plugin_dl.handle, plugin_interface_version_sym))) {\n    free_plugin_mem(&plugin_dl);\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    report_error(report, ER_CANT_FIND_DL_ENTRY, plugin_interface_version_sym);\n    DBUG_RETURN(NULL);\n  }\n  plugin_dl.version = *(int *)sym;\n  /* Versioning */\n  if (plugin_dl.version < min_plugin_interface_version ||\n      (plugin_dl.version >> 8) > (MYSQL_PLUGIN_INTERFACE_VERSION >> 8)) {\n    free_plugin_mem(&plugin_dl);\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, 0,\n                 \"plugin interface version mismatch\");\n    DBUG_RETURN(NULL);\n  }\n\n  /* link the services in */\n  for (i = 0; i < array_elements(list_of_services); i++) {\n    if ((sym = dlsym(plugin_dl.handle, list_of_services[i].name))) {\n      uint ver = (uint)(intptr) * (void **)sym;\n      if ((*(void **)sym) !=\n              list_of_services[i].service && /* already replaced */\n          (ver > list_of_services[i].version ||\n           (ver >> 8) < (list_of_services[i].version >> 8))) {\n        char buf[MYSQL_ERRMSG_SIZE];\n        snprintf(buf, sizeof(buf), \"service '%s' interface version mismatch\",\n                 list_of_services[i].name);\n        mysql_rwlock_unlock(&LOCK_system_variables_hash);\n        mysql_mutex_unlock(&LOCK_plugin);\n        report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, 0, buf);\n        DBUG_RETURN(NULL);\n      }\n      *(void **)sym = list_of_services[i].service;\n    }\n  }\n\n  /* Find plugin declarations */\n  if (!(sym = dlsym(plugin_dl.handle, plugin_declarations_sym))) {\n    free_plugin_mem(&plugin_dl);\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    report_error(report, ER_CANT_FIND_DL_ENTRY, plugin_declarations_sym);\n    DBUG_RETURN(NULL);\n  }\n\n  if (plugin_dl.version != MYSQL_PLUGIN_INTERFACE_VERSION) {\n    uint sizeof_st_plugin;\n    st_mysql_plugin *old, *cur;\n    char *ptr = (char *)sym;\n\n    if ((sym = dlsym(plugin_dl.handle, sizeof_st_plugin_sym)))\n      sizeof_st_plugin = *(int *)sym;\n    else {\n      /*\n        When the following assert starts failing, we'll have to call\n        report_error(report, ER_CANT_FIND_DL_ENTRY, sizeof_st_plugin_sym);\n      */\n      DBUG_ASSERT(min_plugin_interface_version == 0);\n      sizeof_st_plugin = (int)offsetof(st_mysql_plugin, version);\n    }\n\n    /*\n      What's the purpose of this loop? If the goal is to catch a\n      missing 0 record at the end of a list, it will fail miserably\n      since the compiler is likely to optimize this away. /Matz\n     */\n    for (i = 0; ((st_mysql_plugin *)(ptr + i * sizeof_st_plugin))->info; i++)\n      /* no op */;\n\n    cur = (st_mysql_plugin *)my_malloc(key_memory_mysql_plugin,\n                                       (i + 1) * sizeof(st_mysql_plugin),\n                                       MYF(MY_ZEROFILL | MY_WME));\n    if (!cur) {\n      free_plugin_mem(&plugin_dl);\n      mysql_rwlock_unlock(&LOCK_system_variables_hash);\n      mysql_mutex_unlock(&LOCK_plugin);\n      report_error(report, ER_OUTOFMEMORY,\n                   static_cast<int>(plugin_dl.dl.length));\n      DBUG_RETURN(NULL);\n    }\n    /*\n      All st_plugin fields not initialized in the plugin explicitly, are\n      set to 0. It matches C standard behaviour for struct initializers that\n      have less values than the struct definition.\n    */\n    for (i = 0; (old = (st_mysql_plugin *)(ptr + i * sizeof_st_plugin))->info;\n         i++)\n      memcpy(cur + i, old, min<size_t>(sizeof(cur[i]), sizeof_st_plugin));\n\n    sym = cur;\n  }\n  plugin_dl.plugins = (st_mysql_plugin *)sym;\n\n  /*\n    If report is REPORT_TO_USER, we were called from\n    mysql_install_plugin. Otherwise, we are called\n    indirectly from plugin_register_dynamic_and_init_all().\n   */\n  if (report == REPORT_TO_USER) {\n    st_mysql_plugin *plugin = plugin_dl.plugins;\n    for (; plugin->info; ++plugin)\n      if (plugin->flags & PLUGIN_OPT_NO_INSTALL) {\n        mysql_rwlock_unlock(&LOCK_system_variables_hash);\n        mysql_mutex_unlock(&LOCK_plugin);\n        report_error(report, ER_PLUGIN_NO_INSTALL, plugin->name);\n        free_plugin_mem(&plugin_dl);\n        DBUG_RETURN(NULL);\n      }\n  }\n\n  /* Duplicate and convert dll name */\n  plugin_dl.dl.length = dl->length * files_charset_info->mbmaxlen + 1;\n  if (!(plugin_dl.dl.str = (char *)my_malloc(key_memory_mysql_plugin_dl,\n                                             plugin_dl.dl.length, MYF(0)))) {\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_OUTOFMEMORY, static_cast<int>(plugin_dl.dl.length));\n    DBUG_RETURN(NULL);\n  }\n  plugin_dl.dl.length = copy_and_convert(\n      plugin_dl.dl.str, plugin_dl.dl.length, files_charset_info, dl->str,\n      dl->length, system_charset_info, &dummy_errors);\n  plugin_dl.dl.str[plugin_dl.dl.length] = 0;\n  /* Add this dll to array */\n  if (!(tmp = plugin_dl_insert_or_reuse(&plugin_dl))) {\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_OUTOFMEMORY,\n                 static_cast<int>(sizeof(st_plugin_dl)));\n    DBUG_RETURN(NULL);\n  }\n  DBUG_RETURN(tmp);\n}\n\nstatic void plugin_dl_del(const LEX_STRING *dl) {\n  DBUG_ENTER(\"plugin_dl_del\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  for (st_plugin_dl **it = plugin_dl_array->begin();\n       it != plugin_dl_array->end(); ++it) {\n    st_plugin_dl *tmp = *it;\n    if (tmp->ref_count &&\n        !my_strnncoll(files_charset_info, pointer_cast<uchar *>(dl->str),\n                      dl->length, pointer_cast<uchar *>(tmp->dl.str),\n                      tmp->dl.length)) {\n      /* Do not remove this element, unless no other plugin uses this dll. */\n      if (!--tmp->ref_count) {\n        free_plugin_mem(tmp);\n        memset(tmp, 0, sizeof(st_plugin_dl));\n      }\n      break;\n    }\n  }\n  DBUG_VOID_RETURN;\n}\n\nstatic st_plugin_int *plugin_find_internal(const LEX_CSTRING &name, int type) {\n  uint i;\n  DBUG_ENTER(\"plugin_find_internal\");\n  if (!initialized) DBUG_RETURN(NULL);\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (type == MYSQL_ANY_PLUGIN) {\n    for (i = 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++) {\n      const auto it = plugin_hash[i]->find(to_string(name));\n      if (it != plugin_hash[i]->end()) DBUG_RETURN(it->second);\n    }\n  } else\n    DBUG_RETURN(find_or_nullptr(*plugin_hash[type], to_string(name)));\n  DBUG_RETURN(NULL);\n}\n\nstatic SHOW_COMP_OPTION plugin_status(const LEX_CSTRING &name, int type) {\n  SHOW_COMP_OPTION rc = SHOW_OPTION_NO;\n  st_plugin_int *plugin;\n  DBUG_ENTER(\"plugin_is_ready\");\n  mysql_mutex_lock(&LOCK_plugin);\n  if ((plugin = plugin_find_internal(name, type))) {\n    rc = SHOW_OPTION_DISABLED;\n    if (plugin->state == PLUGIN_IS_READY) rc = SHOW_OPTION_YES;\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\nbool plugin_is_ready(const LEX_CSTRING &name, int type) {\n  bool rc = false;\n  if (plugin_status(name, type) == SHOW_OPTION_YES) rc = true;\n  return rc;\n}\n\nSHOW_COMP_OPTION plugin_status(const char *name, size_t len, int type) {\n  LEX_CSTRING plugin_name = {name, len};\n  return plugin_status(plugin_name, type);\n}\n\nstatic plugin_ref intern_plugin_lock(LEX *lex, plugin_ref rc) {\n  st_plugin_int *pi = plugin_ref_to_int(rc);\n  DBUG_ENTER(\"intern_plugin_lock\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (pi->state & (PLUGIN_IS_READY | PLUGIN_IS_UNINITIALIZED)) {\n    plugin_ref plugin;\n#ifdef DBUG_OFF\n    /* built-in plugins don't need ref counting */\n    if (!pi->plugin_dl) DBUG_RETURN(pi);\n\n    plugin = pi;\n#else\n    /*\n      For debugging, we do an additional malloc which allows the\n      memory manager and/or valgrind to track locked references and\n      double unlocks to aid resolving reference counting problems.\n    */\n    if (!(plugin = (plugin_ref)my_malloc(key_memory_plugin_ref, sizeof(pi),\n                                         MYF(MY_WME))))\n      DBUG_RETURN(NULL);\n\n    *plugin = pi;\n#endif\n    pi->ref_count++;\n    DBUG_PRINT(\"info\", (\"thd: %p, plugin: \\\"%s\\\", ref_count: %d\", current_thd,\n                        pi->name.str, pi->ref_count));\n    if (lex) lex->plugins.push_back(plugin);\n    DBUG_RETURN(plugin);\n  }\n  DBUG_RETURN(NULL);\n}\n\nplugin_ref plugin_lock(THD *thd, plugin_ref *ptr) {\n  LEX *lex = thd ? thd->lex : 0;\n  plugin_ref rc;\n  DBUG_ENTER(\"plugin_lock\");\n  mysql_mutex_lock(&LOCK_plugin);\n  rc = my_intern_plugin_lock_ci(lex, *ptr);\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\nplugin_ref plugin_lock_by_name(THD *thd, const LEX_CSTRING &name, int type) {\n  LEX *lex = thd ? thd->lex : 0;\n  plugin_ref rc = NULL;\n  st_plugin_int *plugin;\n  DBUG_ENTER(\"plugin_lock_by_name\");\n  mysql_mutex_lock(&LOCK_plugin);\n  if ((plugin = plugin_find_internal(name, type)))\n    rc = my_intern_plugin_lock_ci(lex, plugin_int_to_ref(plugin));\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\nstatic st_plugin_int *plugin_insert_or_reuse(st_plugin_int *plugin) {\n  DBUG_ENTER(\"plugin_insert_or_reuse\");\n  st_plugin_int *tmp;\n  for (st_plugin_int **it = plugin_array->begin(); it != plugin_array->end();\n       ++it) {\n    tmp = *it;\n    if (tmp->state == PLUGIN_IS_FREED) {\n      *tmp = std::move(*plugin);\n      DBUG_RETURN(tmp);\n    }\n  }\n  if (plugin_array->push_back(plugin)) DBUG_RETURN(NULL);\n  tmp = plugin_array->back() =\n      new (&plugin_mem_root) st_plugin_int(std::move(*plugin));\n  DBUG_RETURN(tmp);\n}\n\n/**\n  Adds a plugin to the global plugin list.\n\n  Also installs the plugin variables.\n  In case of error releases ::LOCK_system_variables_hash and ::LOCK_plugin\n  and reports the error.\n  @note Requires that a write-lock is held on ::LOCK_plugin and\n  ::LOCK_system_variables_hash\n*/\nstatic bool plugin_add(MEM_ROOT *tmp_root, const LEX_STRING *name,\n                       const LEX_STRING *dl, int *argc, char **argv,\n                       int report) {\n  st_plugin_int tmp;\n  st_mysql_plugin *plugin;\n  DBUG_ENTER(\"plugin_add\");\n  LEX_CSTRING name_cstr = {name->str, name->length};\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  if (plugin_find_internal(name_cstr, MYSQL_ANY_PLUGIN)) {\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    report_error(report, ER_UDF_EXISTS, name->str);\n    DBUG_RETURN(true);\n  }\n  if (!(tmp.plugin_dl = plugin_dl_add(dl, report))) DBUG_RETURN(true);\n  /* Find plugin by name */\n  for (plugin = tmp.plugin_dl->plugins; plugin->info; plugin++) {\n    size_t name_len = strlen(plugin->name);\n    if (plugin->type >= 0 && plugin->type < MYSQL_MAX_PLUGIN_TYPE_NUM &&\n        !my_strnncoll(system_charset_info,\n                      pointer_cast<const uchar *>(name->str), name->length,\n                      pointer_cast<const uchar *>(plugin->name), name_len)) {\n      st_plugin_int *tmp_plugin_ptr;\n      if (*(int *)plugin->info <\n              min_plugin_info_interface_version[plugin->type] ||\n          ((*(int *)plugin->info) >> 8) >\n              (cur_plugin_info_interface_version[plugin->type] >> 8)) {\n        char buf[256], dl_name[FN_REFLEN];\n        strxnmov(buf, sizeof(buf) - 1, \"API version for \",\n                 plugin_type_names[plugin->type].str,\n                 \" plugin is too different\", NullS);\n        /* copy the library name so we can release the mutex */\n        strncpy(dl_name, dl->str, sizeof(dl_name) - 1);\n        dl_name[sizeof(dl_name) - 1] = 0;\n        plugin_dl_del(dl);\n        mysql_rwlock_unlock(&LOCK_system_variables_hash);\n        mysql_mutex_unlock(&LOCK_plugin);\n        report_error(report, ER_CANT_OPEN_LIBRARY, dl_name, 0, buf);\n        DBUG_RETURN(true);\n      }\n      tmp.plugin = plugin;\n      tmp.name.str = (char *)plugin->name;\n      tmp.name.length = name_len;\n      tmp.ref_count = 0;\n      tmp.state = PLUGIN_IS_UNINITIALIZED;\n      tmp.load_option = PLUGIN_ON;\n      if (test_plugin_options(tmp_root, &tmp, argc, argv))\n        tmp.state = PLUGIN_IS_DISABLED;\n\n      if ((tmp_plugin_ptr = plugin_insert_or_reuse(&tmp))) {\n        plugin_array_version++;\n        if (plugin_hash[plugin->type]\n                ->emplace(to_string(tmp_plugin_ptr->name), tmp_plugin_ptr)\n                .second) {\n          init_alloc_root(key_memory_plugin_int_mem_root,\n                          &tmp_plugin_ptr->mem_root, 4096, 4096);\n          DBUG_RETURN(false);\n        }\n        tmp_plugin_ptr->state = PLUGIN_IS_FREED;\n      }\n      mysql_del_sys_var_chain(tmp.system_vars);\n      restore_pluginvar_names(tmp.system_vars);\n      plugin_dl_del(dl);\n      mysql_rwlock_unlock(&LOCK_system_variables_hash);\n      mysql_mutex_unlock(&LOCK_plugin);\n      DBUG_RETURN(true);\n    }\n  }\n  plugin_dl_del(dl);\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  mysql_mutex_unlock(&LOCK_plugin);\n  report_error(report, ER_CANT_FIND_DL_ENTRY, name->str);\n  DBUG_RETURN(true);\n}\n\nstatic void plugin_deinitialize(st_plugin_int *plugin, bool ref_check) {\n  /*\n    we don't want to hold the LOCK_plugin mutex as it may cause\n    deinitialization to deadlock if plugins have worker threads\n    with plugin locks\n  */\n  mysql_mutex_assert_not_owner(&LOCK_plugin);\n\n  if (plugin->plugin->status_vars) {\n    remove_status_vars(plugin->plugin->status_vars);\n  }\n\n  if (plugin_type_deinitialize[plugin->plugin->type]) {\n    if ((*plugin_type_deinitialize[plugin->plugin->type])(plugin)) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_FAILED_DEINITIALIZATION, plugin->name.str,\n             plugin_type_names[plugin->plugin->type].str);\n    }\n  } else if (plugin->plugin->deinit) {\n    DBUG_PRINT(\"info\", (\"Deinitializing plugin: '%s'\", plugin->name.str));\n    if (plugin->plugin->deinit(plugin)) {\n      DBUG_PRINT(\"warning\", (\"Plugin '%s' deinit function returned error.\",\n                             plugin->name.str));\n    }\n  }\n  plugin->state = PLUGIN_IS_UNINITIALIZED;\n\n  Srv_session::check_for_stale_threads(plugin);\n  /*\n    We do the check here because NDB has a worker THD which doesn't\n    exit until NDB is shut down.\n  */\n  if (ref_check && plugin->ref_count)\n    LogErr(ERROR_LEVEL, ER_PLUGIN_HAS_NONZERO_REFCOUNT_AFTER_DEINITIALIZATION,\n           plugin->name.str, plugin->ref_count);\n}\n\n/*\n  Unload a plugin.\n  Note: During valgrind testing, the plugin's shared object (.dll/.so)\n        is not unloaded in order to keep the call stack\n        of the leaked objects.\n*/\nstatic void plugin_del(st_plugin_int *plugin) {\n  DBUG_ENTER(\"plugin_del(plugin)\");\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  mysql_mutex_assert_owner(&LOCK_plugin_delete);\n  /* Free allocated strings before deleting the plugin. */\n  mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n  mysql_del_sys_var_chain(plugin->system_vars);\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  restore_pluginvar_names(plugin->system_vars);\n  plugin_vars_free_values(plugin->system_vars);\n  plugin_hash[plugin->plugin->type]->erase(to_string(plugin->name));\n\n  if (plugin->plugin_dl) plugin_dl_del(&plugin->plugin_dl->dl);\n  plugin->state = PLUGIN_IS_FREED;\n  plugin_array_version++;\n  free_root(&plugin->mem_root, MYF(0));\n  DBUG_VOID_RETURN;\n}\n\nstatic void reap_plugins(void) {\n  st_plugin_int *plugin, **reap, **list;\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!reap_needed) return;\n\n  reap_needed = false;\n  const size_t count = plugin_array->size();\n  reap = (st_plugin_int **)my_alloca(sizeof(plugin) * (count + 1));\n  *(reap++) = NULL;\n\n  for (size_t idx = 0; idx < count; idx++) {\n    plugin = plugin_array->at(idx);\n    if (plugin->state == PLUGIN_IS_DELETED && !plugin->ref_count) {\n      /* change the status flag to prevent reaping by another thread */\n      plugin->state = PLUGIN_IS_DYING;\n      *(reap++) = plugin;\n    }\n  }\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  list = reap;\n  while ((plugin = *(--list))) {\n    if (!opt_initialize)\n      LogErr(INFORMATION_LEVEL, ER_PLUGIN_SHUTTING_DOWN_PLUGIN,\n             plugin->name.str);\n    plugin_deinitialize(plugin, true);\n  }\n\n  mysql_mutex_lock(&LOCK_plugin_delete);\n  mysql_mutex_lock(&LOCK_plugin);\n\n  while ((plugin = *(--reap))) plugin_del(plugin);\n\n  mysql_mutex_unlock(&LOCK_plugin_delete);\n}\n\nstatic void intern_plugin_unlock(LEX *lex, plugin_ref plugin) {\n  st_plugin_int *pi;\n  DBUG_ENTER(\"intern_plugin_unlock\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!plugin) DBUG_VOID_RETURN;\n\n  pi = plugin_ref_to_int(plugin);\n\n#ifdef DBUG_OFF\n  if (!pi->plugin_dl) DBUG_VOID_RETURN;\n#else\n  my_free(plugin);\n#endif\n\n  DBUG_PRINT(\"info\", (\"unlocking plugin, name= %s, ref_count= %d\", pi->name.str,\n                      pi->ref_count));\n  if (lex) {\n    /*\n      Remove one instance of this plugin from the use list.\n      We are searching backwards so that plugins locked last\n      could be unlocked faster - optimizing for LIFO semantics.\n    */\n    plugin_ref *iter = lex->plugins.end() - 1;\n    bool found_it MY_ATTRIBUTE((unused)) = false;\n    for (; iter >= lex->plugins.begin() - 1; --iter) {\n      if (plugin == *iter) {\n        lex->plugins.erase(iter);\n        found_it = true;\n        break;\n      }\n    }\n    DBUG_ASSERT(found_it);\n  }\n\n  DBUG_ASSERT(pi->ref_count);\n  pi->ref_count--;\n\n  if (pi->state == PLUGIN_IS_DELETED && !pi->ref_count) reap_needed = true;\n\n  DBUG_VOID_RETURN;\n}\n\nvoid plugin_unlock(THD *thd, plugin_ref plugin) {\n  LEX *lex = thd ? thd->lex : 0;\n  DBUG_ENTER(\"plugin_unlock\");\n  if (!plugin) DBUG_VOID_RETURN;\n#ifdef DBUG_OFF\n  /* built-in plugins don't need ref counting */\n  if (!plugin_dlib(plugin)) DBUG_VOID_RETURN;\n#endif\n  mysql_mutex_lock(&LOCK_plugin);\n  intern_plugin_unlock(lex, plugin);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_VOID_RETURN;\n}\n\nvoid plugin_unlock_list(THD *thd, plugin_ref *list, size_t count) {\n  LEX *lex = thd ? thd->lex : 0;\n  DBUG_ENTER(\"plugin_unlock_list\");\n  DBUG_ASSERT(list);\n\n  /*\n    In unit tests, LOCK_plugin may be uninitialized, so do not lock it.\n    Besides: there's no point in locking it, if there are no plugins to unlock.\n   */\n  if (count == 0) DBUG_VOID_RETURN;\n\n  mysql_mutex_lock(&LOCK_plugin);\n  while (count--) intern_plugin_unlock(lex, *list++);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_VOID_RETURN;\n}\n\nstatic int plugin_initialize(st_plugin_int *plugin) {\n  int ret = 1;\n  DBUG_ENTER(\"plugin_initialize\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  uint state = plugin->state;\n  DBUG_ASSERT(state == PLUGIN_IS_UNINITIALIZED);\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  DEBUG_SYNC(current_thd, \"in_plugin_initialize\");\n\n  if (plugin_type_initialize[plugin->plugin->type]) {\n    if ((*plugin_type_initialize[plugin->plugin->type])(plugin)) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_REGISTRATION_FAILED, plugin->name.str,\n             plugin_type_names[plugin->plugin->type].str);\n      goto err;\n    }\n\n    /* FIXME: Need better solution to transfer the callback function\n    array to memcached */\n    if (strcmp(plugin->name.str, \"InnoDB\") == 0) {\n      innodb_callback_data = ((handlerton *)plugin->data)->data;\n    }\n  } else if (plugin->plugin->init) {\n    if (strcmp(plugin->name.str, \"daemon_memcached\") == 0) {\n      plugin->data = innodb_callback_data;\n    }\n\n    if (plugin->plugin->init(plugin)) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_INIT_FAILED, plugin->name.str);\n      goto err;\n    }\n  }\n  state = PLUGIN_IS_READY;  // plugin->init() succeeded\n\n  if (plugin->plugin->status_vars) {\n    if (add_status_vars(plugin->plugin->status_vars)) goto err;\n  }\n\n  /*\n    set the plugin attribute of plugin's sys vars so they are pointing\n    to the active plugin\n  */\n  if (plugin->system_vars) {\n    sys_var_pluginvar *var = plugin->system_vars->cast_pluginvar();\n    for (;;) {\n      var->plugin = plugin;\n      if (!var->next) break;\n      var = var->next->cast_pluginvar();\n    }\n  }\n\n  ret = 0;\n\nerr:\n  mysql_mutex_lock(&LOCK_plugin);\n  plugin->state = state;\n\n  DBUG_RETURN(ret);\n}\n\nstatic inline void convert_dash_to_underscore(char *str, size_t len) {\n  for (char *p = str; p <= str + len; p++)\n    if (*p == '-') *p = '_';\n}\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_mutex_key key_LOCK_plugin;\nstatic PSI_mutex_key key_LOCK_plugin_delete;\nstatic PSI_mutex_key key_LOCK_plugin_install;\n\n/* clang-format off */\nstatic PSI_mutex_info all_plugin_mutexes[]=\n{\n  { &key_LOCK_plugin, \"LOCK_plugin\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_plugin_delete, \"LOCK_plugin_delete\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_plugin_install, \"LOCK_plugin_install\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME}\n};\n/* clang-format on */\n\n/* clang-format off */\nstatic PSI_memory_info all_plugin_memory[]=\n{\n#ifndef DBUG_OFF\n  { &key_memory_plugin_ref, \"plugin_ref\", PSI_FLAG_ONLY_GLOBAL_STAT, 0, PSI_DOCUMENT_ME},\n#endif\n  { &key_memory_plugin_mem_root, \"plugin_mem_root\", PSI_FLAG_ONLY_GLOBAL_STAT, 0, PSI_DOCUMENT_ME},\n  { &key_memory_plugin_init_tmp, \"plugin_init_tmp\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_memory_plugin_int_mem_root, \"plugin_int_mem_root\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_memory_mysql_plugin_dl, \"mysql_plugin_dl\", PSI_FLAG_ONLY_GLOBAL_STAT, 0, PSI_DOCUMENT_ME},\n  { &key_memory_mysql_plugin, \"mysql_plugin\", PSI_FLAG_ONLY_GLOBAL_STAT, 0, PSI_DOCUMENT_ME},\n  { &key_memory_plugin_bookmark, \"plugin_bookmark\", PSI_FLAG_ONLY_GLOBAL_STAT, 0, PSI_DOCUMENT_ME}\n};\n/* clang-format on */\n\nstatic void init_plugin_psi_keys(void) {\n  const char *category = \"sql\";\n  int count;\n\n  count = array_elements(all_plugin_mutexes);\n  mysql_mutex_register(category, all_plugin_mutexes, count);\n\n  count = array_elements(all_plugin_memory);\n  mysql_memory_register(category, all_plugin_memory, count);\n}\n#endif /* HAVE_PSI_INTERFACE */\n\n/**\n  Initialize the internals of the plugin system. Allocate required\n  resources, initialize mutex, etc.\n\n  @return Operation outcome, false means no errors\n */\nstatic bool plugin_init_internals() {\n#ifdef HAVE_PSI_INTERFACE\n  init_plugin_psi_keys();\n#endif\n\n  init_alloc_root(key_memory_plugin_mem_root, &plugin_mem_root, 4096, 4096);\n\n  bookmark_hash = new malloc_unordered_map<std::string, st_bookmark *>(\n      key_memory_plugin_bookmark);\n\n  malloced_string_type_sysvars_bookmark_hash =\n      new malloc_unordered_map<std::string, st_bookmark *>(\n          key_memory_plugin_bookmark);\n\n  mysql_mutex_init(key_LOCK_plugin, &LOCK_plugin, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_plugin_delete, &LOCK_plugin_delete,\n                   MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_plugin_install, &LOCK_plugin_install,\n                   MY_MUTEX_INIT_FAST);\n\n  plugin_dl_array = new (std::nothrow)\n      Prealloced_array<st_plugin_dl *, 16>(key_memory_mysql_plugin_dl);\n  plugin_array = new (std::nothrow)\n      Prealloced_array<st_plugin_int *, 16>(key_memory_mysql_plugin);\n  if (plugin_dl_array == NULL || plugin_array == NULL) goto err;\n\n  for (uint i = 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++) {\n    plugin_hash[i] = new collation_unordered_map<std::string, st_plugin_int *>(\n        system_charset_info, key_memory_plugin_mem_root);\n  }\n  return false;\n\nerr:\n  return true;\n}\n\n/**\n  Initialize the plugins. Reap those that fail to initialize.\n\n  @return Operation outcome, false means no errors\n */\nstatic bool plugin_init_initialize_and_reap() {\n  struct st_plugin_int *plugin_ptr;\n  struct st_plugin_int **reap;\n\n  /* Now we initialize all plugins that are not already initialized */\n  mysql_mutex_lock(&LOCK_plugin);\n  reap =\n      (st_plugin_int **)my_alloca((plugin_array->size() + 1) * sizeof(void *));\n  *(reap++) = NULL;\n\n  for (st_plugin_int **it = plugin_array->begin(); it != plugin_array->end();\n       ++it) {\n    plugin_ptr = *it;\n    if (plugin_ptr->state == PLUGIN_IS_UNINITIALIZED) {\n      if (plugin_initialize(plugin_ptr)) {\n        plugin_ptr->state = PLUGIN_IS_DYING;\n        *(reap++) = plugin_ptr;\n      }\n    }\n  }\n\n  /* Check if any plugins have to be reaped */\n  bool reaped_mandatory_plugin = false;\n  while ((plugin_ptr = *(--reap))) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    if (plugin_ptr->load_option == PLUGIN_FORCE ||\n        plugin_ptr->load_option == PLUGIN_FORCE_PLUS_PERMANENT)\n      reaped_mandatory_plugin = true;\n    plugin_deinitialize(plugin_ptr, true);\n    mysql_mutex_lock(&LOCK_plugin_delete);\n    mysql_mutex_lock(&LOCK_plugin);\n    plugin_del(plugin_ptr);\n    mysql_mutex_unlock(&LOCK_plugin_delete);\n  }\n\n  mysql_mutex_unlock(&LOCK_plugin);\n  if (reaped_mandatory_plugin) return true;\n\n  return false;\n}\n\n/**\n   Register and initialize early plugins.\n\n   @param argc  Command line argument counter\n   @param argv  Command line arguments\n   @param flags Flags to control whether dynamic loading\n                and plugin initialization should be skipped\n\n   @return Operation outcome, false if no errors\n*/\nbool plugin_register_early_plugins(int *argc, char **argv, int flags) {\n  bool retval = false;\n  DBUG_ENTER(\"plugin_register_dynamic_and_init_all\");\n\n  /* Don't allow initializing twice */\n  DBUG_ASSERT(!initialized);\n\n  /* Make sure the internals are initialized */\n  if ((retval = plugin_init_internals())) DBUG_RETURN(retval);\n\n  /* Allocate the temporary mem root, will be freed before returning */\n  MEM_ROOT tmp_root;\n  init_alloc_root(key_memory_plugin_init_tmp, &tmp_root, 4096, 4096);\n\n  I_List_iterator<i_string> iter(opt_early_plugin_load_list);\n  i_string *item;\n  while (NULL != (item = iter++))\n    plugin_load_list(&tmp_root, argc, argv, item->ptr);\n\n  /* Temporary mem root not needed anymore, can free it here */\n  free_root(&tmp_root, MYF(0));\n\n  if (!(flags & PLUGIN_INIT_SKIP_INITIALIZATION))\n    retval = plugin_init_initialize_and_reap();\n\n  DBUG_RETURN(retval);\n}\n\n/**\n  Register the builtin plugins. Some of the plugins (MyISAM, CSV and InnoDB)\n  are also initialized.\n\n  @param argc number of arguments, propagated to the plugin\n  @param argv actual arguments, propagated to the plugin\n  @return Operation outcome, false means no errors\n */\nbool plugin_register_builtin_and_init_core_se(int *argc, char **argv) {\n  bool mandatory = true;\n  DBUG_ENTER(\"plugin_register_builtin_and_init_core_se\");\n\n  /* Don't allow initializing twice */\n  DBUG_ASSERT(!initialized);\n\n  /* Allocate the temporary mem root, will be freed before returning */\n  MEM_ROOT tmp_root;\n  init_alloc_root(key_memory_plugin_init_tmp, &tmp_root, 4096, 4096);\n\n  mysql_mutex_lock(&LOCK_plugin);\n  initialized = true;\n\n  /* First we register the builtin mandatory and optional plugins */\n  for (struct st_mysql_plugin **builtins = mysql_mandatory_plugins;\n       *builtins || mandatory; builtins++) {\n    /* Switch to optional plugins when done with the mandatory ones */\n    if (!*builtins) {\n      builtins = mysql_optional_plugins;\n      mandatory = false;\n      if (!*builtins) break;\n    }\n    for (struct st_mysql_plugin *plugin = *builtins; plugin->info; plugin++) {\n      struct st_plugin_int tmp;\n      tmp.plugin = plugin;\n      tmp.name.str = (char *)plugin->name;\n      tmp.name.length = strlen(plugin->name);\n      tmp.state = 0;\n      tmp.load_option = mandatory ? PLUGIN_FORCE : PLUGIN_ON;\n\n      /*\n        If the performance schema is compiled in,\n        treat the storage engine plugin as 'mandatory',\n        to suppress any plugin-level options such as '--performance-schema'.\n        This is specific to the performance schema, and is done on purpose:\n        the server-level option '--performance-schema' controls the overall\n        performance schema initialization, which consists of much more that\n        the underlying storage engine initialization.\n        See mysqld.cc, set_vars.cc.\n        Suppressing ways to interfere directly with the storage engine alone\n        prevents awkward situations where:\n        - the user wants the performance schema functionality, by using\n          '--enable-performance-schema' (the server option),\n        - yet disable explicitly a component needed for the functionality\n          to work, by using '--skip-performance-schema' (the plugin)\n      */\n      if (!my_strcasecmp(&my_charset_latin1, plugin->name,\n                         \"PERFORMANCE_SCHEMA\")) {\n        tmp.load_option = PLUGIN_FORCE;\n      }\n\n      free_root(&tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n      if (test_plugin_options(&tmp_root, &tmp, argc, argv))\n        tmp.state = PLUGIN_IS_DISABLED;\n      else\n        tmp.state = PLUGIN_IS_UNINITIALIZED;\n\n      struct st_plugin_int *plugin_ptr;  // Pointer to registered plugin\n      if (register_builtin(plugin, &tmp, &plugin_ptr)) goto err_unlock;\n\n      /*\n        Only initialize MyISAM, InnoDB and CSV at this stage.\n        Note that when the --help option is supplied, InnoDB is not\n        initialized because the plugin table will not be read anyway,\n        as indicated by the flag set when the plugin_init() function\n        is called.\n      */\n      bool is_myisam =\n          !my_strcasecmp(&my_charset_latin1, plugin->name, \"MyISAM\");\n      bool is_innodb =\n          !my_strcasecmp(&my_charset_latin1, plugin->name, \"InnoDB\");\n      if (!is_myisam && (!is_innodb || opt_help) &&\n          my_strcasecmp(&my_charset_latin1, plugin->name, \"CSV\"))\n        continue;\n\n      if (plugin_ptr->state != PLUGIN_IS_UNINITIALIZED ||\n          plugin_initialize(plugin_ptr))\n        goto err_unlock;\n\n      /*\n        Initialize the global default storage engine so that it may\n        not be null in any child thread.\n      */\n      if (is_myisam) {\n        DBUG_ASSERT(!global_system_variables.table_plugin);\n        DBUG_ASSERT(!global_system_variables.temp_table_plugin);\n        global_system_variables.table_plugin =\n            my_intern_plugin_lock(NULL, plugin_int_to_ref(plugin_ptr));\n        global_system_variables.temp_table_plugin =\n            my_intern_plugin_lock(NULL, plugin_int_to_ref(plugin_ptr));\n        DBUG_ASSERT(plugin_ptr->ref_count == 2);\n      }\n    }\n  }\n\n  /* Should now be set to MyISAM storage engine */\n  DBUG_ASSERT(global_system_variables.table_plugin);\n  DBUG_ASSERT(global_system_variables.temp_table_plugin);\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  free_root(&tmp_root, MYF(0));\n  DBUG_RETURN(false);\n\nerr_unlock:\n  mysql_mutex_unlock(&LOCK_plugin);\n  free_root(&tmp_root, MYF(0));\n  DBUG_RETURN(true);\n}\n\nbool is_builtin_and_core_se_initialized() { return initialized; }\n\n/**\n  Register and initialize the dynamic plugins. Also initialize\n  the remaining builtin plugins that are not initialized\n  already.\n\n  @param argc  Command line argument counter\n  @param argv  Command line arguments\n  @param flags Flags to control whether dynamic loading\n               and plugin initialization should be skipped\n\n  @return Operation outcome, false if no errors\n*/\nbool plugin_register_dynamic_and_init_all(int *argc, char **argv, int flags) {\n  DBUG_ENTER(\"plugin_register_dynamic_and_init_all\");\n\n  /* Make sure the internals are initialized and builtins registered */\n  if (!initialized) DBUG_RETURN(true);\n\n  /* Allocate the temporary mem root, will be freed before returning */\n  MEM_ROOT tmp_root;\n  init_alloc_root(key_memory_plugin_init_tmp, &tmp_root, 4096, 4096);\n\n  /* Register all dynamic plugins */\n  if (!(flags & PLUGIN_INIT_SKIP_DYNAMIC_LOADING)) {\n    I_List_iterator<i_string> iter(opt_plugin_load_list);\n    i_string *item;\n    while (NULL != (item = iter++))\n      plugin_load_list(&tmp_root, argc, argv, item->ptr);\n\n    if (!(flags & PLUGIN_INIT_SKIP_PLUGIN_TABLE))\n      plugin_load(&tmp_root, argc, argv);\n  }\n\n  /* Temporary mem root not needed anymore, can free it here */\n  free_root(&tmp_root, MYF(0));\n\n  Auto_THD fake_session;\n  Disable_autocommit_guard autocommit_guard(fake_session.thd);\n  dd::cache::Dictionary_client::Auto_releaser releaser(\n      fake_session.thd->dd_client());\n  if (!(flags & PLUGIN_INIT_SKIP_INITIALIZATION))\n    if (plugin_init_initialize_and_reap()) {\n      DBUG_RETURN(::end_transaction(fake_session.thd, true));\n    }\n\n  DBUG_RETURN(::end_transaction(fake_session.thd, false));\n}\n\nstatic bool register_builtin(st_mysql_plugin *plugin, st_plugin_int *tmp,\n                             st_plugin_int **ptr) {\n  DBUG_ENTER(\"register_builtin\");\n  tmp->ref_count = 0;\n  tmp->plugin_dl = 0;\n\n  if (plugin_array->push_back(tmp)) DBUG_RETURN(true);\n\n  *ptr = plugin_array->back() =\n      new (&plugin_mem_root) st_plugin_int(std::move(*tmp));\n\n  plugin_hash[plugin->type]->emplace(to_string((*ptr)->name), *ptr);\n\n  DBUG_RETURN(0);\n}\n\n/**\n  Reads the plugins from mysql.plugin and loads them\n\n  Called only by plugin_register_dynamic_and_init_all()\n  a.k.a. the bootstrap sequence.\n\n  @arg tmp_root  memory root to use for plugin_add()\n  @arg argc      number of command line arguments to process\n  @arg argv      array of command line argument to read values from\n  @retval true   failure\n  @retval false  success\n*/\nstatic void plugin_load(MEM_ROOT *tmp_root, int *argc, char **argv) {\n  THD thd;\n  TABLE_LIST tables;\n  TABLE *table;\n  int error;\n  THD *new_thd = &thd;\n  bool result;\n  DBUG_ENTER(\"plugin_load\");\n\n  new_thd->thread_stack = (char *)&tables;\n  new_thd->store_globals();\n  LEX_CSTRING db_lex_cstr = {STRING_WITH_LEN(\"mysql\")};\n  new_thd->set_db(db_lex_cstr);\n  thd.get_protocol_classic()->wipe_net();\n  tables.init_one_table(\"mysql\", 5, \"plugin\", 6, \"plugin\", TL_READ);\n\n  result = open_trans_system_tables_for_read(new_thd, &tables);\n\n  if (result) {\n    DBUG_PRINT(\"error\", (\"Can't open plugin table\"));\n    LogErr(ERROR_LEVEL, ER_PLUGIN_CANT_OPEN_PLUGIN_TABLE);\n    DBUG_VOID_RETURN;\n  }\n  table = tables.table;\n  READ_RECORD read_record_info;\n  if (init_read_record(&read_record_info, new_thd, table, NULL, false,\n                       /*ignore_not_found_rows=*/false)) {\n    close_trans_system_tables(new_thd);\n    DBUG_VOID_RETURN;\n  }\n  table->use_all_columns();\n  /*\n    there're no other threads running yet, so we don't need a mutex.\n    but plugin_add() before is designed to work in multi-threaded\n    environment, and it uses mysql_mutex_assert_owner(), so we lock\n    the mutex here to satisfy the assert\n  */\n  while (!(error = read_record_info->Read())) {\n    DBUG_PRINT(\"info\", (\"init plugin record\"));\n    String str_name, str_dl;\n    get_field(tmp_root, table->field[0], &str_name);\n    get_field(tmp_root, table->field[1], &str_dl);\n\n    LEX_STRING name = {(char *)str_name.ptr(), str_name.length()};\n    LEX_STRING dl = {(char *)str_dl.ptr(), str_dl.length()};\n\n    /*\n      The whole locking sequence is not strictly speaking needed since this\n      is a function that's executed only during server bootstrap, but we do\n      it properly for uniformity of the environment for plugin_add.\n      Note that it must be done for each iteration since, unlike INSTALL PLUGIN\n      the bootstrap process just reports the error and goes on.\n      So to ensure the right sequence of lock and unlock we need to take and\n      release both the wlock and the mutex.\n    */\n    mysql_mutex_lock(&LOCK_plugin);\n    mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n    if (plugin_add(tmp_root, &name, &dl, argc, argv, REPORT_TO_LOG)) {\n      LogErr(WARNING_LEVEL, ER_PLUGIN_CANT_LOAD, str_name.c_ptr(),\n             str_dl.c_ptr());\n    } else {\n      mysql_rwlock_unlock(&LOCK_system_variables_hash);\n      mysql_mutex_unlock(&LOCK_plugin);\n    }\n    free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n  }\n  if (error > 0) {\n    char errbuf[MYSQL_ERRMSG_SIZE];\n    LogErr(ERROR_LEVEL, ER_GET_ERRNO_FROM_STORAGE_ENGINE, my_errno(),\n           my_strerror(errbuf, MYSQL_ERRMSG_SIZE, my_errno()));\n  }\n  read_record_info.iterator.reset();\n  table->m_needs_reopen = true;  // Force close to free memory\n\n  close_trans_system_tables(new_thd);\n\n  DBUG_VOID_RETURN;\n}\n\n/**\n  Load a list of plugins\n\n  Called by plugin_register_early_plugins() and\n  plugin_register_dynamic_and_init_all(), a.k.a. the bootstrap sequence.\n\n  @arg tmp_root  memory root to use for plugin_add()\n  @arg argc      number of command line arguments to process\n  @arg argv      array of command line argument to read values from\n  @arg list      list of plugins to load. Ends with a NULL pointer\n  @retval true   failure\n  @retval false  success\n*/\nstatic bool plugin_load_list(MEM_ROOT *tmp_root, int *argc, char **argv,\n                             const char *list) {\n  char buffer[FN_REFLEN];\n  LEX_STRING name = {buffer, 0}, dl = {NULL, 0}, *str = &name;\n  st_plugin_dl *plugin_dl;\n  st_mysql_plugin *plugin;\n  char *p = buffer;\n  DBUG_ENTER(\"plugin_load_list\");\n  while (list) {\n    if (p == buffer + sizeof(buffer) - 1) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_LOAD_PARAMETER_TOO_LONG);\n      DBUG_RETURN(true);\n    }\n\n    switch ((*(p++) = *(list++))) {\n      case '\\0':\n        list = NULL; /* terminate the loop */\n                     /* fall through */\n      case ';':\n#ifndef _WIN32\n      case ':': /* can't use this as delimiter as it may be drive letter */\n#endif\n        str->str[str->length] = '\\0';\n        if (str == &name)  // load all plugins in named module\n        {\n          if (!name.length) {\n            p--; /* reset pointer */\n            continue;\n          }\n\n          dl = name;\n          /*\n            The whole locking sequence is not strictly speaking needed since\n            this is a function that's executed only during server bootstrap, but\n            we do it properly for uniformity of the environment for plugin_add.\n          */\n          mysql_mutex_lock(&LOCK_plugin);\n          mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n          if ((plugin_dl = plugin_dl_add(&dl, REPORT_TO_LOG))) {\n            for (plugin = plugin_dl->plugins; plugin->info; plugin++) {\n              name.str = (char *)plugin->name;\n              name.length = strlen(name.str);\n\n              free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n              if (plugin_add(tmp_root, &name, &dl, argc, argv, REPORT_TO_LOG))\n                goto error;\n            }\n            plugin_dl_del(&dl);  // reduce ref count\n          } else\n            goto error;\n        } else {\n          free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n          /*\n            The whole locking sequence is not strictly speaking needed since\n            this is a function that's executed only during server bootstrap, but\n            we do it properly for uniformity of the environment for plugin_add.\n          */\n          mysql_mutex_lock(&LOCK_plugin);\n          mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n          if (plugin_add(tmp_root, &name, &dl, argc, argv, REPORT_TO_LOG))\n            goto error;\n        }\n        mysql_rwlock_unlock(&LOCK_system_variables_hash);\n        mysql_mutex_unlock(&LOCK_plugin);\n        name.length = dl.length = 0;\n        dl.str = NULL;\n        name.str = p = buffer;\n        str = &name;\n        continue;\n      case '=':\n      case '#':\n        if (str == &name) {\n          name.str[name.length] = '\\0';\n          str = &dl;\n          str->str = p;\n          continue;\n        }\n        // Fall through.\n      default:\n        str->length++;\n        continue;\n    }\n  }\n  DBUG_RETURN(false);\nerror:\n  LogErr(ERROR_LEVEL, ER_PLUGIN_CANT_LOAD, name.str, dl.str);\n  DBUG_RETURN(true);\n}\n\n/*\n  Shutdown memcached plugin before binlog shuts down\n*/\nvoid memcached_shutdown(void) {\n  if (initialized) {\n    for (st_plugin_int **it = plugin_array->begin(); it != plugin_array->end();\n         ++it) {\n      st_plugin_int *plugin = *it;\n\n      if (plugin->state == PLUGIN_IS_READY &&\n          strcmp(plugin->name.str, \"daemon_memcached\") == 0) {\n        plugin_deinitialize(plugin, true);\n\n        mysql_mutex_lock(&LOCK_plugin_delete);\n        mysql_mutex_lock(&LOCK_plugin);\n        plugin->state = PLUGIN_IS_DYING;\n        plugin_del(plugin);\n        mysql_mutex_unlock(&LOCK_plugin);\n        mysql_mutex_unlock(&LOCK_plugin_delete);\n      }\n    }\n  }\n}\n\n/*\n  Deinitialize and unload all the loaded plugins.\n  Note: During valgrind testing, the shared objects (.dll/.so)\n        are not unloaded in order to keep the call stack\n        of the leaked objects.\n*/\nvoid plugin_shutdown(void) {\n  size_t i;\n  st_plugin_int **plugins, *plugin;\n  st_plugin_dl **dl;\n  bool skip_binlog = true;\n\n  DBUG_ENTER(\"plugin_shutdown\");\n\n  if (initialized) {\n    size_t count = plugin_array->size();\n    mysql_mutex_lock(&LOCK_plugin);\n\n    reap_needed = true;\n\n    /*\n      We want to shut down plugins in a reasonable order, this will\n      become important when we have plugins which depend upon each other.\n      Circular references cannot be reaped so they are forced afterwards.\n      TODO: Have an additional step here to notify all active plugins that\n      shutdown is requested to allow plugins to deinitialize in parallel.\n    */\n    while (reap_needed && (count = plugin_array->size())) {\n      reap_plugins();\n      for (i = 0; i < count; i++) {\n        plugin = plugin_array->at(i);\n\n        if (plugin->state == PLUGIN_IS_READY &&\n            strcmp(plugin->name.str, \"binlog\") == 0 && skip_binlog) {\n          skip_binlog = false;\n\n        } else if (plugin->state == PLUGIN_IS_READY) {\n          plugin->state = PLUGIN_IS_DELETED;\n          reap_needed = true;\n        }\n      }\n      if (!reap_needed) {\n        /*\n          release any plugin references held.\n        */\n        unlock_variables(&global_system_variables);\n        unlock_variables(&max_system_variables);\n      }\n    }\n\n    plugins = (st_plugin_int **)my_alloca(sizeof(void *) * (count + 1));\n\n    /*\n      If we have any plugins which did not die cleanly, we force shutdown\n    */\n    for (i = 0; i < count; i++) {\n      plugins[i] = plugin_array->at(i);\n      /* change the state to ensure no reaping races */\n      if (plugins[i]->state == PLUGIN_IS_DELETED)\n        plugins[i]->state = PLUGIN_IS_DYING;\n    }\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    /*\n      We loop through all plugins and call deinit() if they have one.\n    */\n    for (i = 0; i < count; i++)\n      if (!(plugins[i]->state &\n            (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_FREED | PLUGIN_IS_DISABLED))) {\n        LogErr(WARNING_LEVEL, ER_PLUGIN_FORCING_SHUTDOWN, plugins[i]->name.str);\n        /*\n          We are forcing deinit on plugins so we don't want to do a ref_count\n          check until we have processed all the plugins.\n        */\n        plugin_deinitialize(plugins[i], false);\n      }\n\n    /*\n      It's perfectly safe not to lock LOCK_plugin, LOCK_plugin_delete, as\n      there're no concurrent threads anymore. But some functions called from\n      here use mysql_mutex_assert_owner(), so we lock the mutex to satisfy it\n    */\n    mysql_mutex_lock(&LOCK_plugin_delete);\n    mysql_mutex_lock(&LOCK_plugin);\n\n    /*\n      We defer checking ref_counts until after all plugins are deinitialized\n      as some may have worker threads holding on to plugin references.\n    */\n    for (i = 0; i < count; i++) {\n      if (plugins[i]->ref_count)\n        LogErr(ERROR_LEVEL, ER_PLUGIN_HAS_NONZERO_REFCOUNT_AFTER_SHUTDOWN,\n               plugins[i]->name.str, plugins[i]->ref_count);\n      if (plugins[i]->state & PLUGIN_IS_UNINITIALIZED) plugin_del(plugins[i]);\n    }\n\n    /*\n      Now we can deallocate all memory.\n    */\n\n    cleanup_variables(NULL, &global_system_variables);\n    cleanup_variables(NULL, &max_system_variables);\n    mysql_mutex_unlock(&LOCK_plugin);\n    mysql_mutex_unlock(&LOCK_plugin_delete);\n\n    initialized = false;\n    mysql_mutex_destroy(&LOCK_plugin);\n    mysql_mutex_destroy(&LOCK_plugin_delete);\n    mysql_mutex_destroy(&LOCK_plugin_install);\n  }\n\n  /* Dispose of the memory */\n\n  for (i = 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++) {\n    delete plugin_hash[i];\n    plugin_hash[i] = nullptr;\n  }\n  delete plugin_array;\n  plugin_array = NULL;\n\n  if (plugin_dl_array != NULL) {\n    size_t count = plugin_dl_array->size();\n    dl = (st_plugin_dl **)my_alloca(sizeof(void *) * count);\n    for (i = 0; i < count; i++) dl[i] = plugin_dl_array->at(i);\n    for (i = 0; i < plugin_dl_array->size(); i++) free_plugin_mem(dl[i]);\n    delete plugin_dl_array;\n    plugin_dl_array = NULL;\n  }\n\n  delete bookmark_hash;\n  bookmark_hash = nullptr;\n  delete malloced_string_type_sysvars_bookmark_hash;\n  malloced_string_type_sysvars_bookmark_hash = nullptr;\n  free_root(&plugin_mem_root, MYF(0));\n\n  global_variables_dynamic_size = 0;\n\n  DBUG_VOID_RETURN;\n}\n\n// Helper function to do rollback or commit, depending on error.\nbool end_transaction(THD *thd, bool error) {\n  if (error) {\n    // Rollback the statement before we can rollback the real transaction.\n    trans_rollback_stmt(thd);\n    trans_rollback(thd);\n  } else if (trans_commit_stmt(thd) || trans_commit(thd)) {\n    error = true;\n    trans_rollback(thd);\n  }\n\n  // Close tables regardless of error.\n  close_thread_tables(thd);\n  return error;\n}\n\n/**\n  Initialize one plugin. This function is used to early load one single\n  plugin. This function is used by key migration tool.\n\n   @param[in]   argc  Command line argument counter\n   @param[in]   argv  Command line arguments\n   @param[in]   plugin library file name\n\n   @return Operation status\n     @retval 0 OK\n     @retval 1 ERROR\n*/\nbool plugin_early_load_one(int *argc, char **argv, const char *plugin) {\n  bool retval = false;\n  DBUG_ENTER(\"plugin_early_load_one\");\n\n  /* Make sure the internals are initialized */\n  if (!initialized) {\n    if ((retval = plugin_init_internals()))\n      DBUG_RETURN(retval);\n    else\n      initialized = true;\n  }\n  /* Allocate the temporary mem root, will be freed before returning */\n  MEM_ROOT tmp_root;\n  init_alloc_root(PSI_NOT_INSTRUMENTED, &tmp_root, 4096, 4096);\n\n  plugin_load_list(&tmp_root, argc, argv, plugin);\n\n  /* Temporary mem root not needed anymore, can free it here */\n  free_root(&tmp_root, MYF(0));\n\n  retval = plugin_init_initialize_and_reap();\n\n  DBUG_RETURN(retval);\n}\n\nstatic bool mysql_install_plugin(THD *thd, const LEX_STRING *name,\n                                 const LEX_STRING *dl) {\n  TABLE_LIST tables;\n  TABLE *table;\n  bool error = true;\n  int argc = orig_argc;\n  char **argv = orig_argv;\n  st_plugin_int *tmp = nullptr;\n  LEX_CSTRING name_cstr = {name->str, name->length};\n  bool store_infoschema_metadata = false;\n  dd::Schema_MDL_locker mdl_handler(thd);\n  Persisted_variables_cache *pv = Persisted_variables_cache::get_instance();\n\n  DBUG_ENTER(\"mysql_install_plugin\");\n\n  Disable_autocommit_guard autocommit_guard(thd);\n  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());\n\n  tables.init_one_table(\"mysql\", 5, \"plugin\", 6, \"plugin\", TL_WRITE);\n\n  if (!opt_noacl &&\n      check_table_access(thd, INSERT_ACL, &tables, false, 1, false))\n    DBUG_RETURN(true);\n\n  if (acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))\n    DBUG_RETURN(true);\n\n  /* need to open before acquiring LOCK_plugin or it will deadlock */\n  if (!(table = open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT)))\n    DBUG_RETURN(true);\n\n  /*\n    Pre-acquire audit plugins for events that may potentially occur\n    during [UN]INSTALL PLUGIN.\n\n    When audit event is triggered, audit subsystem acquires interested\n    plugins by walking through plugin list. Evidently plugin list\n    iterator protects plugin list by acquiring LOCK_plugin, see\n    plugin_foreach_with_mask().\n\n    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin\n    rather for a long time.\n\n    When audit event is triggered during [UN]INSTALL PLUGIN, plugin\n    list iterator acquires the same lock (within the same thread)\n    second time.\n\n    This hack should be removed when LOCK_plugin is fixed so it\n    protects only what it supposed to protect.\n    */\n  mysql_audit_acquire_plugins(thd, MYSQL_AUDIT_GENERAL_CLASS,\n                              MYSQL_AUDIT_GENERAL_ALL);\n\n  mysql_mutex_lock(&LOCK_plugin_install);\n  mysql_mutex_lock(&LOCK_plugin);\n  DEBUG_SYNC(thd, \"acquired_LOCK_plugin\");\n  mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n\n  {\n    MEM_ROOT alloc{PSI_NOT_INSTRUMENTED, 512};\n    my_getopt_use_args_separator = true;\n    if (my_load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &argc, &argv,\n                         &alloc, NULL)) {\n      mysql_rwlock_unlock(&LOCK_system_variables_hash);\n      mysql_mutex_unlock(&LOCK_plugin);\n      report_error(REPORT_TO_USER, ER_PLUGIN_IS_NOT_LOADED, name->str);\n      goto err;\n    }\n    my_getopt_use_args_separator = false;\n    /*\n     Append static variables present in mysqld-auto.cnf file for the\n     newly installed plugin to process those options which are specific\n     to this plugin.\n    */\n    if (pv && pv->append_read_only_variables(&argc, &argv, true)) {\n      mysql_rwlock_unlock(&LOCK_system_variables_hash);\n      mysql_mutex_unlock(&LOCK_plugin);\n      report_error(REPORT_TO_USER, ER_PLUGIN_IS_NOT_LOADED, name->str);\n      goto err;\n    }\n    error = plugin_add(thd->mem_root, name, dl, &argc, argv, REPORT_TO_USER);\n  }\n\n  /* LOCK_plugin and LOCK_system_variables_hash already unlocked by plugin_add()\n     if error */\n  if (error) goto err;\n\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  if (!(tmp = plugin_find_internal(name_cstr, MYSQL_ANY_PLUGIN))) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    goto err;\n  }\n\n  error = false;\n  if (tmp->state == PLUGIN_IS_DISABLED) {\n    push_warning_printf(thd, Sql_condition::SL_WARNING, ER_CANT_INITIALIZE_UDF,\n                        ER_THD(thd, ER_CANT_INITIALIZE_UDF), name->str,\n                        \"Plugin is disabled\");\n  }\n\n  // Check if we need to store I_S plugin metadata in DD.\n  store_infoschema_metadata =\n      (tmp->plugin->type == MYSQL_INFORMATION_SCHEMA_PLUGIN &&\n       tmp->state != PLUGIN_IS_DISABLED);\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  // Acquire MDL lock if we are storing metadata in DD.\n  if (store_infoschema_metadata) {\n    if (!mdl_handler.ensure_locked(INFORMATION_SCHEMA_NAME.str)) {\n      MDL_request mdl_request;\n      MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE,\n                       INFORMATION_SCHEMA_NAME.str, tmp->name.str,\n                       MDL_EXCLUSIVE, MDL_TRANSACTION);\n      if (thd->mdl_context.acquire_lock(&mdl_request,\n                                        thd->variables.lock_wait_timeout))\n        error = true;\n    } else\n      error = true;\n\n    if (error) {\n      report_error(REPORT_TO_USER, ER_PLUGIN_INSTALL_ERROR, name->str,\n                   \"error acquiring metadata lock\");\n    }\n  }\n\n  /*\n    We do not replicate the INSTALL PLUGIN statement. Disable binlogging\n    of the insert into the plugin table, so that it is not replicated in\n    row based mode.\n  */\n  if (!error) {\n    Disable_binlog_guard binlog_guard(thd);\n    table->use_all_columns();\n    restore_record(table, s->default_values);\n    table->field[0]->store(name->str, name->length, system_charset_info);\n    table->field[1]->store(dl->str, dl->length, files_charset_info);\n    error = table->file->ha_write_row(table->record[0]);\n    if (error) {\n      const char msg[] = \"got '%s' writing to mysql.plugin\";\n      char buf[MYSQL_ERRMSG_SIZE + sizeof(msg) - 2];\n      char errbuf[MYSQL_ERRMSG_SIZE];\n      my_strerror(errbuf, sizeof(errbuf), error);\n      snprintf(buf, sizeof(buf), msg, errbuf);\n      report_error(REPORT_TO_USER, ER_PLUGIN_INSTALL_ERROR, name->str, buf);\n    } else {\n      mysql_mutex_lock(&LOCK_plugin);\n\n      if (tmp->state != PLUGIN_IS_DISABLED && plugin_initialize(tmp)) {\n        my_error(ER_CANT_INITIALIZE_UDF, MYF(0), name->str,\n                 \"Plugin initialization function failed.\");\n        error = true;\n      }\n\n      /*\n        Store plugin I_S table metadata into DD tables. The\n        tables are closed before the function returns.\n       */\n      error = error || thd->transaction_rollback_request;\n      if (!error && store_infoschema_metadata) {\n        error = dd::info_schema::store_dynamic_plugin_I_S_metadata(thd, tmp);\n        if (error) {\n          report_error(REPORT_TO_USER, ER_PLUGIN_INSTALL_ERROR, name->str,\n                       \"error storing metadata\");\n        }\n      }\n      mysql_mutex_unlock(&LOCK_plugin);\n\n      if (!error && store_infoschema_metadata) {\n        Uncommitted_tables_guard uncommitted_tables(thd);\n        error = update_referencing_views_metadata(\n            thd, INFORMATION_SCHEMA_NAME.str, tmp->name.str, false,\n            &uncommitted_tables);\n        if (error) {\n          report_error(REPORT_TO_USER, ER_PLUGIN_INSTALL_ERROR, name->str,\n                       \"error updating metadata\");\n        }\n      }\n    }\n  }\n\n  if (error) {\n    mysql_mutex_lock(&LOCK_plugin);\n    tmp->state = PLUGIN_IS_DELETED;\n    reap_needed = true;\n    reap_plugins();\n    mysql_mutex_unlock(&LOCK_plugin);\n  }\n\nerr:\n  mysql_mutex_unlock(&LOCK_plugin_install);\n  DBUG_RETURN(end_transaction(thd, error));\n}\n\nstatic bool mysql_uninstall_plugin(THD *thd, const LEX_STRING *name) {\n  TABLE *table;\n  TABLE_LIST tables;\n  st_plugin_int *plugin;\n  LEX_CSTRING name_cstr = {name->str, name->length};\n  bool error = true;\n  int rc = 0;\n  bool remove_IS_metadata_from_dd = false;\n  dd::Schema_MDL_locker mdl_handler(thd);\n  dd::String_type orig_plugin_name;\n\n  DBUG_ENTER(\"mysql_uninstall_plugin\");\n\n  tables.init_one_table(\"mysql\", 5, \"plugin\", 6, \"plugin\", TL_WRITE);\n\n  if (!opt_noacl &&\n      check_table_access(thd, DELETE_ACL, &tables, false, 1, false)) {\n    DBUG_ASSERT(thd->is_error());\n    DBUG_RETURN(true);\n  }\n\n  if (acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))\n    DBUG_RETURN(true);\n\n  Disable_autocommit_guard autocommit_guard(thd);\n  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());\n  /* need to open before acquiring LOCK_plugin or it will deadlock */\n  if (!(table =\n            open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT))) {\n    DBUG_ASSERT(thd->is_error());\n    DBUG_RETURN(true);\n  }\n\n  mysql_mutex_lock(&LOCK_plugin_install);\n  if (!table->key_info) {\n    my_error(ER_MISSING_KEY, MYF(0), table->s->db.str,\n             table->s->table_name.str);\n    goto err;\n  }\n\n  /*\n    Pre-acquire audit plugins for events that may potentially occur\n    during [UN]INSTALL PLUGIN.\n\n    When audit event is triggered, audit subsystem acquires interested\n    plugins by walking through plugin list. Evidently plugin list\n    iterator protects plugin list by acquiring LOCK_plugin, see\n    plugin_foreach_with_mask().\n\n    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin\n    rather for a long time.\n\n    When audit event is triggered during [UN]INSTALL PLUGIN, plugin\n    list iterator acquires the same lock (within the same thread)\n    second time.\n\n    This hack should be removed when LOCK_plugin is fixed so it\n    protects only what it supposed to protect.\n  */\n  mysql_audit_acquire_plugins(thd, MYSQL_AUDIT_GENERAL_CLASS,\n                              MYSQL_AUDIT_GENERAL_ALL);\n\n  mysql_mutex_lock(&LOCK_plugin);\n  if (!(plugin = plugin_find_internal(name_cstr, MYSQL_ANY_PLUGIN)) ||\n      plugin->state & (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_DYING)) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_SP_DOES_NOT_EXIST, MYF(0), \"PLUGIN\", name->str);\n    goto err;\n  }\n  if (!plugin->plugin_dl) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_PLUGIN_DELETE_BUILTIN, MYF(0));\n    goto err;\n  }\n  if (plugin->load_option == PLUGIN_FORCE_PLUS_PERMANENT) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_PLUGIN_IS_PERMANENT, MYF(0), name->str);\n    goto err;\n  }\n  /*\n    Error message for ER_PLUGIN_IS_PERMANENT is not suitable for\n    plugins marked as not dynamically uninstallable, so we have a\n    separate one instead of changing the old one.\n   */\n  if (plugin->plugin->flags & PLUGIN_OPT_NO_UNINSTALL) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_PLUGIN_NO_UNINSTALL, MYF(0), plugin->plugin->name);\n    goto err;\n  }\n\n  /*\n    FIXME: plugin rpl_semi_sync_master, check_uninstall() function.\n  */\n\n  /* Block Uninstallation of semi_sync plugins (Master/Slave)\n     when they are busy\n   */\n  char buff[20];\n  size_t buff_length;\n  /*\n    Master: If there are active semi sync slaves for this Master,\n    then that means it is busy and rpl_semi_sync_master plugin\n    cannot be uninstalled. To check whether the master\n    has any semi sync slaves or not, check Rpl_semi_sync_master_cliens\n    status variable value, if it is not 0, that means it is busy.\n  */\n  if (!strcmp(name->str, \"rpl_semi_sync_master\") &&\n      get_status_var(thd, plugin->plugin->status_vars,\n                     \"Rpl_semi_sync_master_clients\", buff, OPT_DEFAULT,\n                     &buff_length) &&\n      strcmp(buff, \"0\")) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_PLUGIN_CANNOT_BE_UNINSTALLED, MYF(0), name->str,\n             \"Stop any active semisynchronous slaves of this master first.\");\n    goto err;\n  }\n\n  /*\n    FIXME: plugin rpl_semi_sync_slave, check_uninstall() function.\n  */\n\n  /* Slave: If there is semi sync enabled IO thread active on this Slave,\n    then that means plugin is busy and rpl_semi_sync_slave plugin\n    cannot be uninstalled. To check whether semi sync\n    IO thread is active or not, check Rpl_semi_sync_slave_status status\n    variable value, if it is ON, that means it is busy.\n  */\n  if (!strcmp(name->str, \"rpl_semi_sync_slave\") &&\n      get_status_var(thd, plugin->plugin->status_vars,\n                     \"Rpl_semi_sync_slave_status\", buff, OPT_DEFAULT,\n                     &buff_length) &&\n      !strcmp(buff, \"ON\")) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(\n        ER_PLUGIN_CANNOT_BE_UNINSTALLED, MYF(0), name->str,\n        \"Stop any active semisynchronous I/O threads on this slave first.\");\n    goto err;\n  }\n\n  if ((plugin->plugin->check_uninstall) && (plugin->state == PLUGIN_IS_READY)) {\n    int check;\n    /*\n      Prevent other threads to uninstall concurrently this plugin.\n    */\n    plugin->state = PLUGIN_IS_DYING;\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    DEBUG_SYNC(current_thd, \"in_plugin_check_uninstall\");\n\n    /*\n      Check uninstall may perform complex operations,\n      including acquiring MDL locks, which in turn may need LOCK_plugin.\n    */\n    DBUG_PRINT(\"info\", (\"check uninstall plugin: '%s'\", plugin->name.str));\n    check = plugin->plugin->check_uninstall(plugin);\n\n    mysql_mutex_lock(&LOCK_plugin);\n    DBUG_ASSERT(plugin->state == PLUGIN_IS_DYING);\n\n    if (check) {\n      DBUG_PRINT(\"warning\",\n                 (\"Plugin '%s' blocked uninstall.\", plugin->name.str));\n      plugin->state = PLUGIN_IS_READY;\n      mysql_mutex_unlock(&LOCK_plugin);\n      my_error(ER_PLUGIN_CANNOT_BE_UNINSTALLED, MYF(0), name->str,\n               \"Plugin is still in use.\");\n      goto err;\n    }\n  }\n\n  plugin->state = PLUGIN_IS_DELETED;\n  if (plugin->ref_count)\n    push_warning(thd, Sql_condition::SL_WARNING, WARN_PLUGIN_BUSY,\n                 ER_THD(thd, WARN_PLUGIN_BUSY));\n  else\n    reap_needed = true;\n\n  // Check if we need to remove I_S plugin metadata from DD.\n  remove_IS_metadata_from_dd =\n      (plugin->plugin->type == MYSQL_INFORMATION_SCHEMA_PLUGIN &&\n       plugin->load_option != PLUGIN_OFF);\n\n  orig_plugin_name = dd::String_type(plugin->name.str, plugin->name.length);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  uchar user_key[MAX_KEY_LENGTH];\n  table->use_all_columns();\n  table->field[0]->store(name->str, name->length, system_charset_info);\n  key_copy(user_key, table->record[0], table->key_info,\n           table->key_info->key_length);\n\n  if ((rc = table->file->ha_index_read_idx_map(\n           table->record[0], 0, user_key, HA_WHOLE_KEY, HA_READ_KEY_EXACT)) ==\n      0) {\n    /*\n      We do not replicate the UNINSTALL PLUGIN statement. Disable binlogging\n      of the delete from the plugin table, so that it is not replicated in\n      row based mode.\n    */\n    DBUG_ASSERT(!thd->is_error());\n    Disable_binlog_guard binlog_guard(thd);\n    rc = table->file->ha_delete_row(table->record[0]);\n    if (rc) {\n      DBUG_ASSERT(thd->is_error());\n    } else\n      error = false;\n  } else if (rc != HA_ERR_KEY_NOT_FOUND && rc != HA_ERR_END_OF_FILE) {\n    DBUG_ASSERT(thd->is_error());\n  } else\n    error = false;\n\n  if (error) {\n    const char msg[] = \"got '%s' deleting from mysql.plugin\";\n    char buf[MYSQL_ERRMSG_SIZE + sizeof(msg) - 2];\n    char errbuf[MYSQL_ERRMSG_SIZE];\n    my_strerror(errbuf, sizeof(errbuf), error);\n    snprintf(buf, sizeof(buf), msg, errbuf);\n    report_error(REPORT_TO_USER, ER_PLUGIN_UNINSTALL_ERROR, name->str, buf);\n  }\n\n  if (!error && !thd->transaction_rollback_request &&\n      remove_IS_metadata_from_dd) {\n    error = dd::info_schema::remove_I_S_view_metadata(\n        thd,\n        dd::String_type(orig_plugin_name.c_str(), orig_plugin_name.length()));\n    DBUG_ASSERT(!error || thd->is_error());\n\n    if (!error) {\n      Uncommitted_tables_guard uncommitted_tables(thd);\n      error = update_referencing_views_metadata(\n          thd, INFORMATION_SCHEMA_NAME.str, orig_plugin_name.c_str(), false,\n          &uncommitted_tables);\n    }\n\n    if (error) {\n      report_error(REPORT_TO_USER, ER_PLUGIN_UNINSTALL_ERROR, name->str,\n                   \"error updating metadata\");\n    }\n  }\n\nerr:\n  mysql_mutex_unlock(&LOCK_plugin_install);\n  DBUG_RETURN(end_transaction(thd, error || thd->transaction_rollback_request));\n}\n\nbool plugin_foreach_with_mask(THD *thd, plugin_foreach_func **funcs, int type,\n                              uint state_mask, void *arg) {\n  size_t idx, total;\n  st_plugin_int *plugin, **plugins;\n  int version = plugin_array_version;\n  DBUG_ENTER(\"plugin_foreach_with_mask\");\n\n  if (!initialized) DBUG_RETURN(false);\n\n  state_mask = ~state_mask;  // do it only once\n\n  mysql_mutex_lock(&LOCK_plugin);\n  total = type == MYSQL_ANY_PLUGIN ? plugin_array->size()\n                                   : plugin_hash[type]->size();\n  /*\n    Do the alloca out here in case we do have a working alloca:\n        leaving the nested stack frame invalidates alloca allocation.\n  */\n  plugins = (st_plugin_int **)my_alloca(total * sizeof(plugin));\n  if (type == MYSQL_ANY_PLUGIN) {\n    for (idx = 0; idx < total; idx++) {\n      plugin = plugin_array->at(idx);\n      plugins[idx] = !(plugin->state & state_mask) ? plugin : NULL;\n    }\n  } else {\n    collation_unordered_map<std::string, st_plugin_int *> *hash =\n        plugin_hash[type];\n    idx = 0;\n    for (const auto &key_and_value : *hash) {\n      plugin = key_and_value.second;\n      plugins[idx++] = !(plugin->state & state_mask) ? plugin : NULL;\n    }\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  for (; *funcs != NULL; ++funcs) {\n    for (idx = 0; idx < total; idx++) {\n      if (unlikely(version != plugin_array_version)) {\n        mysql_mutex_lock(&LOCK_plugin);\n        for (size_t i = idx; i < total; i++)\n          if (plugins[i] && plugins[i]->state & state_mask) plugins[i] = 0;\n        mysql_mutex_unlock(&LOCK_plugin);\n      }\n      plugin = plugins[idx];\n      /* It will stop iterating on first engine error when \"func\" returns true\n       */\n      if (plugin && (*funcs)(thd, plugin_int_to_ref(plugin), arg)) goto err;\n    }\n  }\n\n  DBUG_RETURN(false);\nerr:\n  DBUG_RETURN(true);\n}\n\nbool plugin_foreach_with_mask(THD *thd, plugin_foreach_func *func, int type,\n                              uint state_mask, void *arg) {\n  plugin_foreach_func *funcs[] = {func, NULL};\n\n  return plugin_foreach_with_mask(thd, funcs, type, state_mask, arg);\n}\n\n/****************************************************************************\n  System Variables support\n****************************************************************************/\n/*\n  This function is not thread safe as the pointer returned at the end of\n  the function is outside mutex.\n*/\n\nvoid lock_plugin_mutex() { mysql_mutex_lock(&LOCK_plugin); }\n\nvoid unlock_plugin_mutex() { mysql_mutex_unlock(&LOCK_plugin); }\n\nsys_var *find_sys_var_ex(THD *thd, const char *str, size_t length,\n                         bool throw_error, bool locked) {\n  sys_var *var;\n  sys_var_pluginvar *pi = NULL;\n  plugin_ref plugin;\n  DBUG_ENTER(\"find_sys_var_ex\");\n\n  if (!locked) mysql_mutex_lock(&LOCK_plugin);\n  mysql_rwlock_rdlock(&LOCK_system_variables_hash);\n  if ((var = intern_find_sys_var(str, length)) &&\n      (pi = var->cast_pluginvar()) && pi->is_plugin) {\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    LEX *lex = thd ? thd->lex : 0;\n    if (!(plugin = my_intern_plugin_lock(lex, plugin_int_to_ref(pi->plugin))))\n      var = NULL; /* failed to lock it, it must be uninstalling */\n    else if (!(plugin_state(plugin) & PLUGIN_IS_READY)) {\n      /* initialization not completed */\n      var = NULL;\n      intern_plugin_unlock(lex, plugin);\n    }\n  } else\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  if (!locked) mysql_mutex_unlock(&LOCK_plugin);\n\n  if (!throw_error && !var)\n    my_error(ER_UNKNOWN_SYSTEM_VARIABLE, MYF(0), (char *)str);\n  DBUG_RETURN(var);\n}\n\nsys_var *find_sys_var(THD *thd, const char *str, size_t length) {\n  return find_sys_var_ex(thd, str, length, false, false);\n}\n\n/*\n  returns a bookmark for thd-local variables, creating if neccessary.\n  returns null for non thd-local variables.\n  Requires that a write lock is obtained on LOCK_system_variables_hash\n*/\nstatic st_bookmark *register_var(const char *plugin, const char *name,\n                                 int flags) {\n  size_t length = strlen(plugin) + strlen(name) + 3, size = 0, offset, new_size;\n  st_bookmark *result;\n  char *varname, *p;\n\n  if (!(flags & PLUGIN_VAR_THDLOCAL)) return NULL;\n\n  switch (flags & PLUGIN_VAR_TYPEMASK) {\n    case PLUGIN_VAR_BOOL:\n      size = sizeof(bool);\n      break;\n    case PLUGIN_VAR_INT:\n      size = sizeof(int);\n      break;\n    case PLUGIN_VAR_LONG:\n    case PLUGIN_VAR_ENUM:\n      size = sizeof(long);\n      break;\n    case PLUGIN_VAR_LONGLONG:\n    case PLUGIN_VAR_SET:\n      size = sizeof(ulonglong);\n      break;\n    case PLUGIN_VAR_STR:\n      size = sizeof(char *);\n      break;\n    case PLUGIN_VAR_DOUBLE:\n      size = sizeof(double);\n      break;\n    default:\n      DBUG_ASSERT(0);\n      return NULL;\n  };\n\n  varname = ((char *)my_alloca(length));\n  strxmov(varname + 1, plugin, \"_\", name, NullS);\n  for (p = varname + 1; *p; p++)\n    if (*p == '-') *p = '_';\n\n  if (!(result = find_bookmark(NULL, varname + 1, flags))) {\n    result = (st_bookmark *)alloc_root(&plugin_mem_root,\n                                       sizeof(st_bookmark) + length - 1);\n    varname[0] = flags & PLUGIN_VAR_TYPEMASK;\n    memcpy(result->key, varname, length);\n    result->name_len = length - 2;\n    result->offset = -1;\n\n    DBUG_ASSERT(size && !(size & (size - 1))); /* must be power of 2 */\n\n    offset = global_system_variables.dynamic_variables_size;\n    offset = (offset + size - 1) & ~(size - 1);\n    result->offset = (int)offset;\n\n    new_size = (offset + size + 63) & ~63;\n\n    if (new_size > global_variables_dynamic_size) {\n      global_system_variables.dynamic_variables_ptr = (char *)my_realloc(\n          key_memory_global_system_variables,\n          global_system_variables.dynamic_variables_ptr, new_size,\n          MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n      max_system_variables.dynamic_variables_ptr = (char *)my_realloc(\n          key_memory_global_system_variables,\n          max_system_variables.dynamic_variables_ptr, new_size,\n          MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n      /*\n        Clear the new variable value space. This is required for string\n        variables. If their value is non-NULL, it must point to a valid\n        string.\n      */\n      memset(global_system_variables.dynamic_variables_ptr +\n                 global_variables_dynamic_size,\n             0, new_size - global_variables_dynamic_size);\n      memset(max_system_variables.dynamic_variables_ptr +\n                 global_variables_dynamic_size,\n             0, new_size - global_variables_dynamic_size);\n      global_variables_dynamic_size = new_size;\n    }\n\n    global_system_variables.dynamic_variables_head = offset;\n    max_system_variables.dynamic_variables_head = offset;\n    global_system_variables.dynamic_variables_size = offset + size;\n    max_system_variables.dynamic_variables_size = offset + size;\n    global_system_variables.dynamic_variables_version++;\n    max_system_variables.dynamic_variables_version++;\n\n    result->version = global_system_variables.dynamic_variables_version;\n\n    /* this should succeed because we have already checked if a dup exists */\n    std::string key(result->key, result->name_len + 1);\n    bookmark_hash->emplace(key, result);\n\n    /*\n      Hashing vars of string type with MEMALLOC flag.\n    */\n    if (((flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR) &&\n        (flags & PLUGIN_VAR_MEMALLOC) &&\n        !malloced_string_type_sysvars_bookmark_hash->emplace(key, result)\n             .second) {\n      fprintf(stderr,\n              \"failed to add placeholder to\"\n              \" hash of malloced string type sysvars\");\n      DBUG_ASSERT(0);\n    }\n  }\n  return result;\n}\n\nstatic void restore_pluginvar_names(sys_var *first) {\n  for (sys_var *var = first; var; var = var->next) {\n    sys_var_pluginvar *pv = var->cast_pluginvar();\n    pv->plugin_var->name = pv->orig_pluginvar_name;\n  }\n}\n\n/**\n  Allocate memory and copy dynamic variables from global system variables\n  to per-thread system variables copy.\n\n  @param thd              thread context\n  @param global_lock      If true LOCK_global_system_variables should be\n                          acquired while copying variables from global\n                          variables copy.\n*/\nvoid alloc_and_copy_thd_dynamic_variables(THD *thd, bool global_lock) {\n  mysql_rwlock_rdlock(&LOCK_system_variables_hash);\n\n  if (global_lock) mysql_mutex_lock(&LOCK_global_system_variables);\n\n  mysql_mutex_assert_owner(&LOCK_global_system_variables);\n\n  /*\n    MAINTAINER:\n    The following assert is wrong on purpose, useful to debug\n    when thd dynamic variables are expanded:\n    DBUG_ASSERT(thd->variables.dynamic_variables_ptr == NULL);\n  */\n\n  thd->variables.dynamic_variables_ptr = (char *)my_realloc(\n      key_memory_THD_variables, thd->variables.dynamic_variables_ptr,\n      global_variables_dynamic_size, MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n\n  /*\n    Debug hook which allows tests to check that this code is not\n    called for InnoDB after connection was created.\n  */\n  DBUG_EXECUTE_IF(\"verify_innodb_thdvars\", DBUG_ASSERT(0););\n\n  memcpy(thd->variables.dynamic_variables_ptr +\n             thd->variables.dynamic_variables_size,\n         global_system_variables.dynamic_variables_ptr +\n             thd->variables.dynamic_variables_size,\n         global_system_variables.dynamic_variables_size -\n             thd->variables.dynamic_variables_size);\n\n  /*\n    Iterate through newly copied vars of string type with MEMALLOC\n    flag and strdup value.\n  */\n  for (const auto &key_and_value :\n       *malloced_string_type_sysvars_bookmark_hash) {\n    sys_var_pluginvar *pi;\n    sys_var *var;\n    int varoff;\n    char **thdvar, **sysvar;\n    st_bookmark *v = key_and_value.second;\n\n    if (v->version <= thd->variables.dynamic_variables_version ||\n        !(var = intern_find_sys_var(v->key + 1, v->name_len)) ||\n        !(pi = var->cast_pluginvar()) ||\n        v->key[0] != (pi->plugin_var->flags & PLUGIN_VAR_TYPEMASK))\n      continue;\n\n    varoff = *(int *)(pi->plugin_var + 1);\n    thdvar = (char **)(thd->variables.dynamic_variables_ptr + varoff);\n    sysvar = (char **)(global_system_variables.dynamic_variables_ptr + varoff);\n    *thdvar = NULL;\n    plugin_var_memalloc_session_update(thd, NULL, thdvar, *sysvar);\n  }\n\n  if (global_lock) mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  thd->variables.dynamic_variables_version =\n      global_system_variables.dynamic_variables_version;\n  thd->variables.dynamic_variables_head =\n      global_system_variables.dynamic_variables_head;\n  thd->variables.dynamic_variables_size =\n      global_system_variables.dynamic_variables_size;\n\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n}\n\n/**\n  For correctness and simplicity's sake, a pointer to a function\n  must be compatible with pointed-to type, that is, the return and\n  parameters types must be the same. Thus, a callback function is\n  defined for each scalar type. The functions are assigned in\n  construct_options to their respective types.\n*/\n\nstatic bool *mysql_sys_var_bool(THD *thd, int offset) {\n  return (bool *)intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic int *mysql_sys_var_int(THD *thd, int offset) {\n  return (int *)intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned int *mysql_sys_var_uint(THD *thd, int offset) {\n  return (unsigned int *)intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned long *mysql_sys_var_ulong(THD *thd, int offset) {\n  return (unsigned long *)intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned long long *mysql_sys_var_ulonglong(THD *thd, int offset) {\n  return (unsigned long long *)intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic char **mysql_sys_var_str(THD *thd, int offset) {\n  return (char **)intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic double *mysql_sys_var_double(THD *thd, int offset) {\n  return (double *)intern_sys_var_ptr(thd, offset, true);\n}\n\nvoid plugin_thdvar_init(THD *thd, bool enable_plugins) {\n  plugin_ref old_table_plugin = thd->variables.table_plugin;\n  plugin_ref old_temp_table_plugin = thd->variables.temp_table_plugin;\n  DBUG_ENTER(\"plugin_thdvar_init\");\n\n  thd->variables.table_plugin = NULL;\n  thd->variables.temp_table_plugin = NULL;\n  cleanup_variables(thd, &thd->variables);\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  thd->variables = global_system_variables;\n  thd->variables.table_plugin = NULL;\n  thd->variables.temp_table_plugin = NULL;\n\n  thd->variables.dynamic_variables_version = 0;\n  thd->variables.dynamic_variables_size = 0;\n  thd->variables.dynamic_variables_ptr = 0;\n\n  if (enable_plugins) {\n    mysql_mutex_lock(&LOCK_plugin);\n    thd->variables.table_plugin =\n        my_intern_plugin_lock(NULL, global_system_variables.table_plugin);\n    intern_plugin_unlock(NULL, old_table_plugin);\n    thd->variables.temp_table_plugin =\n        my_intern_plugin_lock(NULL, global_system_variables.temp_table_plugin);\n    intern_plugin_unlock(NULL, old_temp_table_plugin);\n    mysql_mutex_unlock(&LOCK_plugin);\n  }\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  /* Initialize all Sys_var_charptr variables here. */\n\n  // @@session.session_track_system_variables\n  thd->session_sysvar_res_mgr.init(&thd->variables.track_sysvars_ptr);\n\n  DBUG_VOID_RETURN;\n}\n\n/*\n  Unlocks all system variables which hold a reference\n*/\nstatic void unlock_variables(struct System_variables *vars) {\n  intern_plugin_unlock(NULL, vars->table_plugin);\n  intern_plugin_unlock(NULL, vars->temp_table_plugin);\n  vars->table_plugin = NULL;\n  vars->temp_table_plugin = NULL;\n}\n\n/*\n  Frees memory used by system variables\n\n  Unlike plugin_vars_free_values() it frees all variables of all plugins,\n  it's used on shutdown.\n*/\nstatic void cleanup_variables(THD *thd, struct System_variables *vars) {\n  if (thd) {\n    /* Block the Performance Schema from accessing THD::variables. */\n    mysql_mutex_lock(&thd->LOCK_thd_data);\n\n    plugin_var_memalloc_free(&thd->variables);\n    /* Remove references to session_sysvar_res_mgr memory before freeing it. */\n    thd->variables.track_sysvars_ptr = NULL;\n    thd->session_sysvar_res_mgr.deinit();\n  }\n  DBUG_ASSERT(vars->table_plugin == NULL);\n  DBUG_ASSERT(vars->temp_table_plugin == NULL);\n\n  my_free(vars->dynamic_variables_ptr);\n  vars->dynamic_variables_ptr = NULL;\n  vars->dynamic_variables_size = 0;\n  vars->dynamic_variables_version = 0;\n\n  if (thd) mysql_mutex_unlock(&thd->LOCK_thd_data);\n}\n\nvoid plugin_thdvar_cleanup(THD *thd, bool enable_plugins) {\n  DBUG_ENTER(\"plugin_thdvar_cleanup\");\n\n  if (enable_plugins) {\n    MUTEX_LOCK(plugin_lock, &LOCK_plugin);\n    unlock_variables(&thd->variables);\n    size_t idx;\n    if ((idx = thd->lex->plugins.size())) {\n      plugin_ref *list = thd->lex->plugins.end() - 1;\n      DBUG_PRINT(\"info\", (\"unlocking %u plugins\", static_cast<uint>(idx)));\n      while (list >= thd->lex->plugins.begin())\n        intern_plugin_unlock(thd->lex, *list--);\n    }\n\n    reap_plugins();\n    thd->lex->plugins.clear();\n  }\n  cleanup_variables(thd, &thd->variables);\n\n  DBUG_VOID_RETURN;\n}\n\n/**\n  @brief Free values of thread variables of a plugin.\n\n  This must be called before a plugin is deleted. Otherwise its\n  variables are no longer accessible and the value space is lost. Note\n  that only string values with PLUGIN_VAR_MEMALLOC are allocated and\n  must be freed.\n\n  @param[in]        vars        Chain of system variables of a plugin\n*/\n\nstatic void plugin_vars_free_values(sys_var *vars) {\n  DBUG_ENTER(\"plugin_vars_free_values\");\n\n  for (sys_var *var = vars; var; var = var->next) {\n    sys_var_pluginvar *piv = var->cast_pluginvar();\n    if (piv &&\n        ((piv->plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR) &&\n        (piv->plugin_var->flags & PLUGIN_VAR_MEMALLOC)) {\n      /* Free the string from global_system_variables. */\n      char **valptr = (char **)piv->real_value_ptr(NULL, OPT_GLOBAL);\n      DBUG_PRINT(\"plugin\",\n                 (\"freeing value for: '%s'  addr: %p\", var->name.str, valptr));\n      my_free(*valptr);\n      *valptr = NULL;\n    }\n  }\n  DBUG_VOID_RETURN;\n}\n\n/**\n  Set value for a thread local variable.\n\n  @param[in]     thd   Thread context.\n  @param[in]     var   Plugin variable.\n  @param[in,out] dest  Destination memory pointer.\n  @param[in]     value New value.\n\n  Note: new value should be '\\0'-terminated for string variables.\n\n  Used in plugin.h:THDVAR_SET(thd, name, value) macro.\n*/\n\nvoid plugin_thdvar_safe_update(THD *thd, SYS_VAR *var, char **dest,\n                               const char *value) {\n  DBUG_ASSERT(thd == current_thd);\n\n  if (var->flags & PLUGIN_VAR_THDLOCAL) {\n    if ((var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR &&\n        var->flags & PLUGIN_VAR_MEMALLOC)\n      plugin_var_memalloc_session_update(thd, var, dest, value);\n    else\n      var->update(thd, var, dest, value);\n  }\n}\n\n/**\n  Free all elements allocated by plugin_var_memalloc_session_update().\n\n  @param[in]     vars  system variables structure\n\n  @see plugin_var_memalloc_session_update\n*/\n\nstatic void plugin_var_memalloc_free(struct System_variables *vars) {\n  LIST *next, *root;\n  DBUG_ENTER(\"plugin_var_memalloc_free\");\n  for (root = vars->dynamic_variables_allocs; root; root = next) {\n    next = root->next;\n    my_free(root);\n  }\n  vars->dynamic_variables_allocs = NULL;\n  DBUG_VOID_RETURN;\n}\n\nextern \"C\" bool get_one_plugin_option(int, const struct my_option *, char *);\n\nbool get_one_plugin_option(int, const struct my_option *, char *) { return 0; }\n\n/**\n  Creates a set of my_option objects associated with a specified plugin-\n  handle.\n\n  @param mem_root Memory allocator to be used.\n  @param tmp A pointer to a plugin handle\n  @param[out] options A pointer to a pre-allocated static array\n\n  The set is stored in the pre-allocated static array supplied to the function.\n  The size of the array is calculated as (number_of_plugin_varaibles*2+3). The\n  reason is that each option can have a prefix '--plugin-' in addtion to the\n  shorter form '--&lt;plugin-name&gt;'. There is also space allocated for\n  terminating NULL pointers.\n\n  @return\n    @retval -1 An error occurred\n    @retval 0 Success\n*/\n\nstatic int construct_options(MEM_ROOT *mem_root, st_plugin_int *tmp,\n                             my_option *options) {\n  const char *plugin_name = tmp->plugin->name;\n  const LEX_STRING plugin_dash = {C_STRING_WITH_LEN(\"plugin-\")};\n  size_t plugin_name_len = strlen(plugin_name);\n  size_t optnamelen;\n  const int max_comment_len = 180;\n  char *comment = (char *)alloc_root(mem_root, max_comment_len + 1);\n  char *optname;\n\n  int index = 0, offset = 0;\n  SYS_VAR *opt, **plugin_option;\n  st_bookmark *v;\n\n  /** Used to circumvent the const attribute on my_option::name */\n  char *plugin_name_ptr, *plugin_name_with_prefix_ptr;\n\n  DBUG_ENTER(\"construct_options\");\n\n  plugin_name_ptr = (char *)alloc_root(mem_root, plugin_name_len + 1);\n  strcpy(plugin_name_ptr, plugin_name);\n  my_casedn_str(&my_charset_latin1, plugin_name_ptr);\n  convert_underscore_to_dash(plugin_name_ptr, plugin_name_len);\n  plugin_name_with_prefix_ptr =\n      (char *)alloc_root(mem_root, plugin_name_len + plugin_dash.length + 1);\n  strxmov(plugin_name_with_prefix_ptr, plugin_dash.str, plugin_name_ptr, NullS);\n\n  if (tmp->load_option != PLUGIN_FORCE &&\n      tmp->load_option != PLUGIN_FORCE_PLUS_PERMANENT) {\n    /* support --skip-plugin-foo syntax */\n    options[0].name = plugin_name_ptr;\n    options[1].name = plugin_name_with_prefix_ptr;\n    options[0].id = 0;\n    options[1].id = -1;\n    options[0].var_type = options[1].var_type = GET_ENUM;\n    options[0].arg_type = options[1].arg_type = OPT_ARG;\n    options[0].def_value = options[1].def_value = 1; /* ON */\n    options[0].typelib = options[1].typelib = &global_plugin_typelib;\n\n    strxnmov(comment, max_comment_len, \"Enable or disable \", plugin_name,\n             \" plugin. Possible values are ON, OFF, FORCE (don't start \"\n             \"if the plugin fails to load).\",\n             NullS);\n    options[0].comment = comment;\n    /*\n      Allocate temporary space for the value of the tristate.\n      This option will have a limited lifetime and is not used beyond\n      server initialization.\n      GET_ENUM value is an unsigned long integer.\n    */\n    options[0].value = options[1].value =\n        (uchar **)alloc_root(mem_root, sizeof(ulong));\n    *((ulong *)options[0].value) = (ulong)options[0].def_value;\n\n    options[0].arg_source = options[1].arg_source =\n        (get_opt_arg_source *)alloc_root(mem_root, sizeof(get_opt_arg_source));\n    memset(options[0].arg_source, 0, sizeof(get_opt_arg_source));\n    options[0].arg_source->m_path_name[0] = 0;\n    options[1].arg_source->m_path_name[0] = 0;\n    options[0].arg_source->m_source = options[1].arg_source->m_source =\n        enum_variable_source::COMPILED;\n\n    options += 2;\n  }\n\n  if (!my_strcasecmp(&my_charset_latin1, plugin_name_ptr, \"NDBCLUSTER\")) {\n    plugin_name_ptr = const_cast<char *>(\"ndb\");  // Use legacy \"ndb\" prefix\n    plugin_name_len = 3;\n  }\n\n  /*\n    Two passes as the 2nd pass will take pointer addresses for use\n    by my_getopt and register_var() in the first pass uses realloc\n  */\n\n  for (plugin_option = tmp->plugin->system_vars;\n       plugin_option && *plugin_option; plugin_option++, index++) {\n    opt = *plugin_option;\n    if (!(opt->flags & PLUGIN_VAR_THDLOCAL)) continue;\n    if (!(register_var(plugin_name_ptr, opt->name, opt->flags))) continue;\n    switch (opt->flags & PLUGIN_VAR_TYPEMASK) {\n      case PLUGIN_VAR_BOOL:\n        ((thdvar_bool_t *)opt)->resolve = mysql_sys_var_bool;\n        break;\n      case PLUGIN_VAR_INT:\n        // All PLUGIN_VAR_INT variables are actually uint,\n        // see struct System_variables\n        // Except: plugin variables declared with MYSQL_THDVAR_INT,\n        // which may actually be signed.\n        if (((thdvar_int_t *)opt)->offset == -1 &&\n            !(opt->flags & PLUGIN_VAR_UNSIGNED))\n          ((thdvar_int_t *)opt)->resolve = mysql_sys_var_int;\n        else\n          ((thdvar_uint_t *)opt)->resolve = mysql_sys_var_uint;\n        break;\n      case PLUGIN_VAR_LONG:\n        // All PLUGIN_VAR_LONG variables are actually ulong,\n        // see struct System_variables\n        ((thdvar_ulong_t *)opt)->resolve = mysql_sys_var_ulong;\n        break;\n      case PLUGIN_VAR_LONGLONG:\n        // All PLUGIN_VAR_LONGLONG variables are actually ulonglong,\n        // see struct System_variables\n        ((thdvar_ulonglong_t *)opt)->resolve = mysql_sys_var_ulonglong;\n        break;\n      case PLUGIN_VAR_STR:\n        ((thdvar_str_t *)opt)->resolve = mysql_sys_var_str;\n        break;\n      case PLUGIN_VAR_ENUM:\n        ((thdvar_enum_t *)opt)->resolve = mysql_sys_var_ulong;\n        break;\n      case PLUGIN_VAR_SET:\n        ((thdvar_set_t *)opt)->resolve = mysql_sys_var_ulonglong;\n        break;\n      case PLUGIN_VAR_DOUBLE:\n        ((thdvar_double_t *)opt)->resolve = mysql_sys_var_double;\n        break;\n      default:\n        LogErr(ERROR_LEVEL, ER_PLUGIN_UNKNOWN_VARIABLE_TYPE, opt->flags,\n               plugin_name);\n        DBUG_RETURN(-1);\n    };\n  }\n\n  for (plugin_option = tmp->plugin->system_vars;\n       plugin_option && *plugin_option; plugin_option++, index++) {\n    switch ((opt = *plugin_option)->flags & PLUGIN_VAR_TYPEMASK) {\n      case PLUGIN_VAR_BOOL:\n        if (!opt->check) opt->check = check_func_bool;\n        if (!opt->update) opt->update = update_func_bool;\n        break;\n      case PLUGIN_VAR_INT:\n        if (!opt->check) opt->check = check_func_int;\n        if (!opt->update) opt->update = update_func_int;\n        break;\n      case PLUGIN_VAR_LONG:\n        if (!opt->check) opt->check = check_func_long;\n        if (!opt->update) opt->update = update_func_long;\n        break;\n      case PLUGIN_VAR_LONGLONG:\n        if (!opt->check) opt->check = check_func_longlong;\n        if (!opt->update) opt->update = update_func_longlong;\n        break;\n      case PLUGIN_VAR_STR:\n        if (!opt->check) opt->check = check_func_str;\n        if (!opt->update) {\n          opt->update = update_func_str;\n          if (!(opt->flags & (PLUGIN_VAR_MEMALLOC | PLUGIN_VAR_READONLY))) {\n            opt->flags |= PLUGIN_VAR_READONLY;\n            LogErr(WARNING_LEVEL, ER_PLUGIN_VARIABLE_SET_READ_ONLY, opt->name,\n                   plugin_name);\n          }\n        }\n        break;\n      case PLUGIN_VAR_ENUM:\n        if (!opt->check) opt->check = check_func_enum;\n        if (!opt->update) opt->update = update_func_long;\n        break;\n      case PLUGIN_VAR_SET:\n        if (!opt->check) opt->check = check_func_set;\n        if (!opt->update) opt->update = update_func_longlong;\n        break;\n      case PLUGIN_VAR_DOUBLE:\n        if (!opt->check) opt->check = check_func_double;\n        if (!opt->update) opt->update = update_func_double;\n        break;\n      default:\n        LogErr(ERROR_LEVEL, ER_PLUGIN_UNKNOWN_VARIABLE_TYPE, opt->flags,\n               plugin_name);\n        DBUG_RETURN(-1);\n    }\n\n    if ((opt->flags & (PLUGIN_VAR_NOCMDOPT | PLUGIN_VAR_THDLOCAL)) ==\n        PLUGIN_VAR_NOCMDOPT)\n      continue;\n\n    if (!opt->name) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_VARIABLE_MISSING_NAME, plugin_name);\n      DBUG_RETURN(-1);\n    }\n\n    if (!(opt->flags & PLUGIN_VAR_THDLOCAL)) {\n      optnamelen = strlen(opt->name);\n      optname = (char *)alloc_root(mem_root, plugin_name_len + optnamelen + 2);\n      strxmov(optname, plugin_name_ptr, \"-\", opt->name, NullS);\n      optnamelen = plugin_name_len + optnamelen + 1;\n    } else {\n      /* this should not fail because register_var should create entry */\n      if (!(v = find_bookmark(plugin_name_ptr, opt->name, opt->flags))) {\n        LogErr(ERROR_LEVEL, ER_PLUGIN_VARIABLE_NOT_ALLOCATED_THREAD_LOCAL,\n               opt->name, plugin_name);\n        DBUG_RETURN(-1);\n      }\n\n      *(int *)(opt + 1) = offset = v->offset;\n\n      if (opt->flags & PLUGIN_VAR_NOCMDOPT) continue;\n\n      optname = (char *)memdup_root(mem_root, v->key + 1,\n                                    (optnamelen = v->name_len) + 1);\n    }\n\n    convert_underscore_to_dash(optname, optnamelen);\n\n    options->name = optname;\n    options->comment = opt->comment;\n    options->app_type = opt;\n    options->id = 0;\n\n    plugin_opt_set_limits(options, opt);\n\n    if (opt->flags & PLUGIN_VAR_THDLOCAL)\n      options->value = options->u_max_value =\n          (uchar **)(global_system_variables.dynamic_variables_ptr + offset);\n    else\n      options->value = options->u_max_value = *(uchar ***)(opt + 1);\n\n    char *option_name_ptr;\n    options[1] = options[0];\n    options[1].id = -1;\n    options[1].name = option_name_ptr =\n        (char *)alloc_root(mem_root, plugin_dash.length + optnamelen + 1);\n    options[1].comment = 0; /* Hidden from the help text */\n    strxmov(option_name_ptr, plugin_dash.str, optname, NullS);\n\n    options[0].arg_source = options[1].arg_source =\n        (get_opt_arg_source *)alloc_root(mem_root, sizeof(get_opt_arg_source));\n    memset(options[0].arg_source, 0, sizeof(get_opt_arg_source));\n    options[0].arg_source->m_path_name[0] = 0;\n    options[1].arg_source->m_path_name[0] = 0;\n    options[0].arg_source->m_source = options[1].arg_source->m_source =\n        enum_variable_source::COMPILED;\n\n    options += 2;\n  }\n\n  DBUG_RETURN(0);\n}\n\nstatic my_option *construct_help_options(MEM_ROOT *mem_root, st_plugin_int *p) {\n  SYS_VAR **opt;\n  my_option *opts;\n  uint count = EXTRA_OPTIONS;\n  DBUG_ENTER(\"construct_help_options\");\n\n  for (opt = p->plugin->system_vars; opt && *opt; opt++, count += 2)\n    ;\n\n  if (!(opts = (my_option *)alloc_root(mem_root, sizeof(my_option) * count)))\n    DBUG_RETURN(NULL);\n\n  memset(opts, 0, sizeof(my_option) * count);\n\n  /**\n    some plugin variables (those that don't have PLUGIN_VAR_EXPERIMENTAL flag)\n    have their names prefixed with the plugin name. Restore the names here\n    to get the correct (not double-prefixed) help text.\n    We won't need @@sysvars anymore and don't care about their proper names.\n  */\n  restore_pluginvar_names(p->system_vars);\n\n  if (construct_options(mem_root, p, opts)) DBUG_RETURN(NULL);\n\n  DBUG_RETURN(opts);\n}\n\n/**\n  Check option being used and raise deprecation warning if required.\n\n  @param optid ID of the option that was passed through command line\n  @param opt List of options\n  @param argument unused\n\n  A deprecation warning will be raised if --plugin-xxx type of option\n  is used.\n\n  @return Always returns success as purpose of the function is to raise\n  warning only.\n  @retval 0 Success\n*/\n\nstatic bool check_if_option_is_deprecated(\n    int optid, const struct my_option *opt,\n    char *argument MY_ATTRIBUTE((unused))) {\n  if (optid == -1) {\n    push_deprecated_warn(NULL, opt->name, (opt->name + strlen(\"plugin-\")));\n  }\n  return 0;\n}\n\n/**\n  Create and register system variables supplied from the plugin and\n  assigns initial values from corresponding command line arguments.\n\n  @param tmp_root Temporary scratch space\n  @param[out] tmp Internal plugin structure\n  @param argc Number of command line arguments\n  @param argv Command line argument vector\n\n  The plugin will be updated with a policy on how to handle errors during\n  initialization.\n\n  @note Requires that a write-lock is held on LOCK_system_variables_hash\n\n  @return How initialization of the plugin should be handled.\n    @retval  0 Initialization should proceed.\n    @retval  1 Plugin is disabled.\n    @retval -1 An error has occurred.\n*/\n\nstatic int test_plugin_options(MEM_ROOT *tmp_root, st_plugin_int *tmp,\n                               int *argc, char **argv) {\n  struct sys_var_chain chain = {NULL, NULL};\n  bool disable_plugin;\n  enum_plugin_load_option plugin_load_option = tmp->load_option;\n\n  /*\n    We should use tmp->mem_root here instead of the global plugin_mem_root,\n    but tmp->root is not always properly freed, so it will cause leaks in\n    Valgrind (e.g. the main.validate_password_plugin test).\n  */\n  MEM_ROOT *mem_root = &plugin_mem_root;\n  SYS_VAR **opt;\n  my_option *opts = NULL;\n  LEX_STRING plugin_name;\n  char *varname;\n  int error;\n  sys_var *v MY_ATTRIBUTE((unused));\n  st_bookmark *var;\n  size_t len;\n  uint count = EXTRA_OPTIONS;\n  DBUG_ENTER(\"test_plugin_options\");\n  DBUG_ASSERT(tmp->plugin && tmp->name.str);\n\n  /*\n    The 'federated' and 'ndbcluster' storage engines are always disabled by\n    default.\n  */\n  if (!(my_strcasecmp(&my_charset_latin1, tmp->name.str, \"federated\") &&\n        my_strcasecmp(&my_charset_latin1, tmp->name.str, \"ndbcluster\")))\n    plugin_load_option = PLUGIN_OFF;\n\n  for (opt = tmp->plugin->system_vars; opt && *opt; opt++)\n    count += 2; /* --{plugin}-{optname} and --plugin-{plugin}-{optname} */\n\n  if (count > EXTRA_OPTIONS || (*argc > 1)) {\n    if (!(opts =\n              (my_option *)alloc_root(tmp_root, sizeof(my_option) * count))) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_OOM, tmp->name.str);\n      DBUG_RETURN(-1);\n    }\n    memset(opts, 0, sizeof(my_option) * count);\n\n    if (construct_options(tmp_root, tmp, opts)) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_BAD_OPTIONS, tmp->name.str);\n      DBUG_RETURN(-1);\n    }\n\n    /*\n      We adjust the default value to account for the hardcoded exceptions\n      we have set for the federated and ndbcluster storage engines.\n    */\n    if (tmp->load_option != PLUGIN_FORCE &&\n        tmp->load_option != PLUGIN_FORCE_PLUS_PERMANENT)\n      opts[0].def_value = opts[1].def_value = plugin_load_option;\n\n    error = handle_options(argc, &argv, opts, check_if_option_is_deprecated);\n    (*argc)++; /* add back one for the program name */\n\n    if (error) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_PARSING_OPTIONS_FAILED, tmp->name.str);\n      goto err;\n    }\n    /*\n     Set plugin loading policy from option value. First element in the option\n     list is always the <plugin name> option value.\n    */\n    if (tmp->load_option != PLUGIN_FORCE &&\n        tmp->load_option != PLUGIN_FORCE_PLUS_PERMANENT)\n      plugin_load_option = (enum_plugin_load_option) * (ulong *)opts[0].value;\n  }\n\n  disable_plugin = (plugin_load_option == PLUGIN_OFF);\n  tmp->load_option = plugin_load_option;\n\n  /*\n    If the plugin is disabled it should not be initialized.\n  */\n  if (disable_plugin) {\n    LogErr(INFORMATION_LEVEL, ER_PLUGIN_DISABLED, tmp->name.str);\n    if (opts) my_cleanup_options(opts);\n    DBUG_RETURN(1);\n  }\n\n  if (!my_strcasecmp(&my_charset_latin1, tmp->name.str, \"NDBCLUSTER\")) {\n    plugin_name.str = const_cast<char *>(\"ndb\");  // Use legacy \"ndb\" prefix\n    plugin_name.length = 3;\n  } else\n    plugin_name = tmp->name;\n\n  error = 1;\n  for (opt = tmp->plugin->system_vars; opt && *opt; opt++) {\n    SYS_VAR *o;\n    const my_option **optp = (const my_option **)&opts;\n    if (((o = *opt)->flags & PLUGIN_VAR_NOSYSVAR)) continue;\n    if ((var = find_bookmark(plugin_name.str, o->name, o->flags)))\n      v = new (mem_root) sys_var_pluginvar(&chain, var->key + 1, o);\n    else {\n      len = plugin_name.length + strlen(o->name) + 2;\n      varname = (char *)alloc_root(mem_root, len);\n      strxmov(varname, plugin_name.str, \"-\", o->name, NullS);\n      my_casedn_str(&my_charset_latin1, varname);\n      convert_dash_to_underscore(varname, len - 1);\n      v = new (mem_root) sys_var_pluginvar(&chain, varname, o);\n    }\n    DBUG_ASSERT(v); /* check that an object was actually constructed */\n\n    if (findopt((char *)o->name, strlen(o->name), optp))\n      v->set_arg_source((*optp)->arg_source);\n  } /* end for */\n  if (chain.first) {\n    chain.last->next = NULL;\n    if (mysql_add_sys_var_chain(chain.first)) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_HAS_CONFLICTING_SYSTEM_VARIABLES,\n             tmp->name.str);\n      goto err;\n    }\n    tmp->system_vars = chain.first;\n  }\n\n  /*\n    Once server is started and if there are few persisted plugin variables\n    which needs to be handled, we do it here.\n  */\n  if (mysqld_server_started) {\n    Persisted_variables_cache *pv = Persisted_variables_cache::get_instance();\n    if (pv && pv->set_persist_options(true)) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_CANT_SET_PERSISTENT_OPTIONS, tmp->name.str);\n      goto err;\n    }\n  }\n  DBUG_RETURN(0);\n\nerr:\n  if (opts) my_cleanup_options(opts);\n  DBUG_RETURN(error);\n}\n\n/****************************************************************************\n  Help Verbose text with Plugin System Variables\n****************************************************************************/\n\nvoid add_plugin_options(std::vector<my_option> *options, MEM_ROOT *mem_root) {\n  my_option *opt;\n\n  if (!initialized) return;\n\n  for (st_plugin_int **it = plugin_array->begin(); it != plugin_array->end();\n       ++it) {\n    st_plugin_int *p = *it;\n\n    if (!(opt = construct_help_options(mem_root, p))) continue;\n\n    /* Only options with a non-NULL comment are displayed in help text */\n    for (; opt->name; opt++)\n      if (opt->comment) options->push_back(*opt);\n  }\n}\n\n/**\n  Searches for a correctly loaded plugin of a particular type by name\n\n  @param plugin   the name of the plugin we're looking for\n  @param type     type of the plugin (0-MYSQL_MAX_PLUGIN_TYPE_NUM)\n  @return plugin, or NULL if not found\n*/\nst_plugin_int *plugin_find_by_type(const LEX_CSTRING &plugin, int type) {\n  st_plugin_int *ret;\n  DBUG_ENTER(\"plugin_find_by_type\");\n\n  ret = plugin_find_internal(plugin, type);\n  DBUG_RETURN(ret && ret->state == PLUGIN_IS_READY ? ret : NULL);\n}\n\n/**\n  Locks the plugin strucutres so calls to plugin_find_inner can be issued.\n\n  Must be followed by unlock_plugin_data.\n*/\nint lock_plugin_data() {\n  DBUG_ENTER(\"lock_plugin_data\");\n  DBUG_RETURN(mysql_mutex_lock(&LOCK_plugin));\n}\n\n/**\n  Unlocks the plugin strucutres as locked by lock_plugin_data()\n*/\nint unlock_plugin_data() {\n  DBUG_ENTER(\"unlock_plugin_data\");\n  DBUG_RETURN(mysql_mutex_unlock(&LOCK_plugin));\n}\n\nbool Sql_cmd_install_plugin::execute(THD *thd) {\n  bool st = mysql_install_plugin(thd, &m_comment, &m_ident);\n  if (!st) my_ok(thd);\n  mysql_audit_release(thd);\n  return st;\n}\n\nbool Sql_cmd_uninstall_plugin::execute(THD *thd) {\n  bool st = mysql_uninstall_plugin(thd, &m_comment);\n  if (!st) my_ok(thd);\n  mysql_audit_release(thd);\n  return st;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/src/common/logger/MSG00001.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/src/ndbapi/NdbUtil.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/src/ndbapi/NdbUtil.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/src/kernel/blocks/new-block.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/src/kernel/blocks/dbdict/Slave_AddTable.sfl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/content-header-dropdown-btn.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/right.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-left.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/oracle_logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/settings.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/box-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/icon-gauge.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-left-top.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/content-header-history.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/content-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/start.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/icon-network.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/welcome-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/welcome-title.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/content-header-search-btn.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/icons8-view-50.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-right.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/tab-separator.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/left.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-right-bottom.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-right-top.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/icons.odg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/greenlight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/content-title-o-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/icon_continue_cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/link-item.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/icon_continue_cluster_disabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/last.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/deploy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-left-bottom.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/content-header-enterprise.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/welcome-mysql-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/content-title.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/redlight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/vertical-separator.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/icon-stopwatch.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/yellowlight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-bottom.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/stop.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/anyhost.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/flag.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/icon_new_cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/img/icon-cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/storage/storage_dialog.swf",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/storage/Storage.swf",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/storage/storage_dialog.fla",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/grip_bg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/resizeRtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/pixel.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/splitterToggleH.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/gridcontainer_grip.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/rotator.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/resize.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/splitterToggleV.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/compatGrid.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/enhanced/resources/images/sprite_icons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/tabEnabled_rotated.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/header.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/header_shadow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/tabHover_rotated.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/row_back.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/grid_sort_up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/grid_sort_down.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/td_button_down.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/grid_dx_gradient.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/embed/resources/version.mov",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowTL.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowT.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowTR.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowR.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowBR.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowL.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowB.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowBL.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/rheader.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/zoomouttime.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/parentnode_filled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/save.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/projProgressFilled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/resourceBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/parentnode_bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/collapse.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/zoomin.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/taskProgressFilled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/taskBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/expand.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/rowHighlight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/resourceHeader.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/taskArrow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/load.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/zoomintime.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/ownerBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/arrow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/zoomout.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/taskProgressBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/minus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/progress_filled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/rbg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/menuHighlight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/pm.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/am.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/progress_bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/projProgressBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/right.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/left.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/buttons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/buttons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/left.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/right.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/close_dark.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/drawing/resources/CrazyTruck.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/drawing/resources/images/tool_icons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/drawing/resources/images/tool_sprites.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/smiley.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/previewDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/anchor.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/anchorDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/smileyDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/preview.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/pasteFromWordDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/editorIconsFindReplaceEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/save.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/showBlockNodesDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/editorIconsFindReplaceDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/breadcrumbDown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/insertEntity.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/saveDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/pageBreak.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/blockquoteDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/blockquote.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/showBlockNodes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/spellcheck.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/pageBreakDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/pasteFromWord.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/insertEntityDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/autoSave.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/soria/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/tundra/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/nihilo/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/claro/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/tableIcons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/anchor.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/cellspace.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/uploadImageIcon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/tableIcons_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/cellpad.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/busy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/fieldset.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/address.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/ul.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/dd.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/dt.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/noscript.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/iframe.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/center.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/div.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/ol.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/map.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/blockquote.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/button.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/script.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/p.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/form.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/li.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/hr.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/ins.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/del.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/object.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/table.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/pre.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/soria/collapse.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/soria/sidebar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/soria/expand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/tundra/collapse.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/tundra/sidebar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/tundra/expand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/nihilo/collapse.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/nihilo/sidebar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/nihilo/expand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/claro/collapse.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/claro/expand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonHalf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonCool.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonAngel.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonAngry.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonGrin.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonTongue.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonShy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonNo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonHappy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonLaughing.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonCrying.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonIdea.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonFrown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonSmile.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonOops.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonGoofy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonWink.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonYes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonEyebrow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/sketch/resources/images/icons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/compat/spinwheel-bar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/compat/spinwheel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonDarkBlueMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlueCircleArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGreenCirclePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlueCirclePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonDarkBlueCheck.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedCirclePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonCheckboxOff.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteUpArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleRedCross.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlackCircleCross.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteSearch.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGreenCircleArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleGreenPlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteCheck.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonYellowStar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedCircleMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhitePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlueMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGrayStar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGreenBall.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBluePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlueCircleMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleGreenButton.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleDownArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonDarkBluePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGreenCircleMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedBall.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlueBall.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonOrangeBall.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedCircleArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGrayArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonCheck.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedPlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonCheckboxOn.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleGrayButton.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteDownArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleOrangeButton.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/dijit/compat/calendar-daylabel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/dijit/compat/calendar-month-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/dijit/compat/calendar-year-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-arc-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/togglebutton-chk-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/arrow-button-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/red-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/blue-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/slider-h-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-arc2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/tab-orange-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-default-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/arrow-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-round1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/icon-content-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-arc-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/tab-sel-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/tab-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-round-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/slider-h-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-arc1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-default-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-default-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/slider-handle-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-round2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/gray-arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-round-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/images/thumb-overlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/images/thumb-overlay-large.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/images/thumb-overlay-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/arrow-button-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/slider-h-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/ui-widget-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/images/thumb-overlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/images/thumb-overlay-large.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/images/thumb-overlay-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-arc-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/red-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/blue-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/slider-h-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-arc2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/tab-orange-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-default-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/arrow-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-round1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/icon-content-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-arc-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/tab-sel-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/tab-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-round-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/slider-h-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-arc1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-default-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-default-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/slider-handle-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-round2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/gray-arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-round-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/arrow-button-head.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/images/thumb-overlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/images/thumb-overlay-large.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/images/thumb-overlay-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/arrow-button-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/red-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/blue-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/slider-h-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/ipad-arrow-button-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-default-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/arrow-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/icon-content-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tab-sel-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tab-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/slider-h-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-default-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-default-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/blue-button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tooltip-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/slider-handle-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tooltip-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/ipad-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/gray-arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/red-button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/ipad-arrow-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/edge-categ-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/white-arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/images/thumb-overlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/images/thumb-overlay-large.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/images/thumb-overlay-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/uploader.swf",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/fileuploader.swf",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/soriaFolderSprite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/nihiloFolderSprite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/rating_full.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/tundraFolderSprite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/loading_wheel.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/rating_empty.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/tristatecheckboxStates.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/geo/charting/resources/img/zoomin.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/geo/charting/resources/img/zoomin.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/geo/charting/resources/img/zoomout.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/geo/charting/resources/img/zoomout.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/resources/audio.swf",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/resources/video.swf",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/resources/version.mov",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/progressPositionBk.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/progressLoadedBk.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/player_sprite.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/sliderHandleSprite.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/sliderHandleNorm.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/sliderHandleOver.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/dojoPlayerIcons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/FilePicker/images/soriaFileIcons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/FilePicker/images/nihiloFileIcons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/FilePicker/images/tundraFileIcons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Dialog/images/dialogCloseButton.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Dialog/images/dialogCloseButton.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/pageInactive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/hPrevious.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/hNext.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/pageActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/vNext.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/vPrevious.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Standby/images/loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Portlet/images/icons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Portlet/images/icons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/ColorPicker/images/hue.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/ColorPicker/images/hueHandleA11y.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/ColorPicker/images/pickerPointer.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/ColorPicker/images/underlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/ColorPicker/images/hueHandle.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Loader/icons/loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/editorIconsDisabled_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/loadingAnimation_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActEnabled_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActEnabled8bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActDisabled_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/editorIconsDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/editorIconsEnabled_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/editorIconsEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActEnabled8bit_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/a11y/colors7x10.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/a11y/indeterminate_progress.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/a11y/colors3x4.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/buttonDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeI_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRoundedIconsSmallBl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabLeftChecked.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteDivIcons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderEmptyVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/progressBarAnim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/buttonHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteCheckbox.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorRight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomHoverC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeI.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/buttonEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteTree_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRoundedIconsSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/splitContainerSizerV-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeExpand_loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/titleBarActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabStripeRight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/preciseSliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeI_half_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/accordionItemActive.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderFullVerticalFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteTree.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorUp.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorLeft.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/dndMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabStripe.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRadio.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRoundedIconsSmallBl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/accordionItemActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/splitContainerSizerH-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabStripeBottom.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabRightChecked.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeI_half.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/titleBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomHoverSpriteLR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/validationInputBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomEnabledC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorDown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomEnabledSpriteLR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/preciseSliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomActiveC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteArrows.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/splitContainerSizerH.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorLeft.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabStripeLeft.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteTree.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/preciseSliderThumb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRadio.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/buttonActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderThumb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/splitContainerSizerV.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/dndNoCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/dndCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteCheckbox.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/progressBarEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteDivIcons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/validationInputBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderFullFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteTree_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabContainerSprite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRoundedIconsSmall.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/dndNoMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/progressBarFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorRight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderFullVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/preciseSliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomActiveSpriteLR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim.psd",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/buttonDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/i.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderEmptyVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/buttonHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dijitProgressBarAnim.psd",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorRight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dojoTundraGradientBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/buttonEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabClose.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/comboArrowDown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/folderOpened.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dojoTundraGradientBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/spriteRoundedIconsSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabCloseHover.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/leaf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/smallArrowDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/splitContainerSizerV-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/i_half_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonActiveHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_minus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/preciseSliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/accordionItemActive.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderFullVerticalFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/plusButton.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorUp.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorLeft.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/noX.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_mius.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dndMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/checkmark.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_leaf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/calendarYearLabel.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/accordionItemHover.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_minus_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-4.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabHover.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabClose.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_plus_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-9.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-6.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-5.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/titleBarBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/splitContainerSizerH-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/circleIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/i_half.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/doubleArrowDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/titleBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/validationInputBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabCloseHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorDown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/checkmarkNoBorder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/preciseSliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/popupMenuBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/folderClosed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/spriteArrows.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dijitProgressBarAnim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/splitContainerSizerH.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorLeft.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/smallArrowUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/preciseSliderThumb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/buttonActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/checkmark.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/minusButton.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/splitContainerSizerV.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dndNoCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/checkmarkNoBorder.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dndCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/i_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/no.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonActiveDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/validationInputBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderFullFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/circleIcon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/spriteRoundedIconsSmall.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-7.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_leaf_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dndNoMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorRight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/calendarDayLabel.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/doubleArrowUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/calendarMonthLabel.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderFullVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/preciseSliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/spriteArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/buttonDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeI_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabLeftChecked.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteDivIcons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderEmptyVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/progressBarAnim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/buttonHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteCheckbox.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorRight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabBottomHoverC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeI.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/buttonEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteTree_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteRoundedIconsSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/splitContainerSizerV-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeExpand_loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/titleBarActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabStripeRight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/preciseSliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeI_half_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderFullVerticalFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteTree.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorUp.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorLeft.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/dndMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabStripe.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteRadio.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/accordionItemActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/splitContainerSizerH-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabStripeBottom.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabRightChecked.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeI_half.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/titleBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabBottomHoverSpriteLR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/validationInputBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabBottomEnabledC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorDown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabBottomEnabledSpriteLR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/preciseSliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabBottomActiveC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteArrows.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/splitContainerSizerH.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorLeft.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabStripeLeft.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteTree.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/preciseSliderThumb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteRadio.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/buttonActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderThumb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/splitContainerSizerV.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/dndNoCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/dndCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/no.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteCheckbox.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/progressBarEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteDivIcons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/validationInputBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderFullFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteTree_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabContainerSprite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteRoundedIconsSmall.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/dndNoMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/progressBarFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorRight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderFullVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/preciseSliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabBottomActiveSpriteLR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/accordion.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabClose.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabLeft.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabBottom.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/splitterVerticalHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabTop.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabRight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/splitterHorizontalHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabNested.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/dnd.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/titlebar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/progressBarAnim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/commonHighlight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/tooltip8bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/treeExpand_loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/treeExpandImages8bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/treeExpandImages.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/dialogCloseIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/calendarArrows8bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/checkmarkNoBorder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/tooltip.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/tooltipGradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/calendarArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/loadingAnimation.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/checkmarkNoBorder.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/progressBarEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/menuHighlight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/calendarContainerImages.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/progressBarFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/spriteArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/dialogCloseIcon8bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/commonFormArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/error.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/sliderVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/button_grad_d.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/checkboxRadioButtonStates.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/button.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/sliderHorizontal.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/buttonArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/textBox_back.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/sliderThumbs.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/checkboxAndRadioButtons_IE6.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/shadow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/formHighlight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojo/resources/blank.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojo/resources/images/dndMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojo/resources/images/dndNoCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojo/resources/images/dndCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/dojo/dojo/resources/images/dndNoMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/deploy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/breadcrumb_trail.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/edit_selected_hosts.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/define_parameters.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/mysqld_parameters_overridden.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/hostgrid-collapsed.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/hostgrid-expanded.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/define_cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/welcome.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/add_process.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/mysqld_parameters.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/cookies.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/help_menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/page_buttons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/starting_cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/define_hosts.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/define_processes.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/settings_menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/mcc/frontend/hlp/img/add_host.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/include/ndbapi/NdbScanFilter.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/include/transporter/TransporterCallback.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/test/include/getarg.h",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/storage/ndb/test/run-test/atrt-example.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/strings/decimal.cc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/strings/ctype-czech.cc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/packaging/WiX/AdminBackground.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/packaging/WiX/AdminHeader.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/packaging/WiX/MySQLServer.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/packaging/WiX/mysqlcommandlineshell.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/packaging/WiX/router/AdminBackground.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/packaging/WiX/router/MySQLRouter.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/packaging/WiX/router/AdminHeader.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/extra/zlib/zlib.3.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/wl6219_55.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/wl6219_55.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/initial_v@1o.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/bug37631.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/corrupt-relay-bin.000624",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/wl6219_41.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/binlog_no_fd_event.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/wl6219_41.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/binlog_56_gtid_reserved_word.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/table_encrypted_32.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/t_set.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/old_table-323.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/data57_enum.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/14897.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/loaddata6.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/binlog_truncated_event.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/loaddata7.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/data57.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/tablespace_portable_linux.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/57import.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/bug16266.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/t_gcol_dep.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/tablespace_portable_win.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/bug47205.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/data80011_upgrade_groupby_desc_ci_win.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/bug21542698.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/mylogin-bad-cipher.cnf",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/master-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/data57_upgrade_groupby_desc.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/rpl_cross_version_default_utf8mb4_collation.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/data80011_upgrade_groupby_desc_ci_mac.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/data57_upgrade_trigger_order.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/rpl_atomic_ddl_rollback_view.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/loaddata_incomplete_mb.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/rpl_atomic_ddl_rollback_table.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/rpl_nogtid_encryption_master-bin.000002",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/initial_t@1o.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/bug20444737.sql",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/wl6219_55_innodb.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/corrupt_t1#P#p1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/wl6219_55.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/rpl_atomic_ddl_rollback_full.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/wl6219_41.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/bug33029-slave-relay-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/binlog_savepoint.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/bug27213339-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/binlog_transaction.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/binlog_transaction_with_GTID.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/bug37631.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/corrupt_t1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/table_encrypted_64.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/bug40482-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/41_decimal.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/binlog_truncated_prev_gtid_event.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/data80011_upgrade_groupby_desc_cs.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/binlog_transaction_with_anonymous_GTID.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/data57_upgrade_default_timezone_bug.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/data57_partition.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/bug46565.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6_2.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6_3.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/parts/t1TIMESTAMP.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p1_first_1024.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p2.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/parts/t1_blackhole.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p3.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p2.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p4.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/lob/earth215kb.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/upgrade/data_80011.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/upgrade/data_57022.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/upgrade/data_80013.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/upgrade/data_80012.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/upgrade/data_80012_part.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/upgrade/bugdata_80011.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/std_data/upgrade/data_80011_fts.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/include/ctype_utf8mb4.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/include/subquery_sj.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_undolog_be/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_undolog_be/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_undolog_be/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_undolog_be/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_undolog_be/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_undolog_be/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_undolog_le/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_undolog_le/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_undolog_le/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_undolog_le/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_undolog_le/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_undolog_le/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/bug54613/BACKUP-2.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/packed/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/packed/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/packed/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_basic_backup/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_basic_backup/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_basic_backup/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_basic_backup/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_basic_backup/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_basic_backup/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_fk_backup/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_fk_backup/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_fk_backup/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_fk_backup/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_fk_backup/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_fk_backup/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_large_backup/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_large_backup/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_large_backup/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_large_backup/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_large_backup/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_large_backup/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/hashmap/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_advanced_backup/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_advanced_backup/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_advanced_backup/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_advanced_backup/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_advanced_backup/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_advanced_backup/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/bug17275798/BACKUP-1.21.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/bug17275798/BACKUP-1-0.21.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/backups/bug17275798/BACKUP-1.21.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/r/ndb_grant.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/ndb/t/ndb_grant.later",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/perfschema/r/misc.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/perfschema/r/statement_digest_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/perfschema/t/statement_digest_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb_fts/r/fulltext.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb_fts/t/fulltext.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb_fts/t/fulltext_left_join.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/gcol/r/gcol_bugfixes_latin1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/gcol/t/gcol_bugfixes_latin1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/rpl_nogtid/t/rpl_row_mysqlbinlog.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/rpl/r/rpl_row_jsondiff_error.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/rpl/r/rpl_charset_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/rpl/r/rpl_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/rpl/r/rpl_secondary_engine_load.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/rpl/r/rpl_set_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/rpl/t/rpl_set_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/rpl/t/rpl_charset_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog/std_data/update-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog/std_data/write-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog/std_data/bug32407.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog/std_data/write-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog/std_data/ver_trunk_row_v2.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog/std_data/bug11747887-bin.000003",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog/std_data/ver_5_1_23.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog/std_data/ver_5_1-wl2325_r.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog/std_data/update-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog/std_data/ver_5_1-wl2325_s.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog/r/binlog_table_map_optional_metadata.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog/t/binlog_mysqlbinlog-cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/funcs_1/lib/DataGen_local.pl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/opt_trace/r/charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/opt_trace/t/charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/std_data/jisx0208_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/std_data/jisx0212_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/std_data/jisx0201_sjis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/std_data/jisx0208_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis3.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/std_data/jisx0201_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/std_data/jisx0212_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/std_data/jisx0201_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/include/trim_sjis.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_rtrim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_join_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_create_tbl_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_alter_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_join_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_create_db_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_trim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_join_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_charset_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_create_tbl_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_ps_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_reverse_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_substring_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_insert_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_replace_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_replace_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_trim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_substring_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_charlength_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_subquery_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_reverse_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_select_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_length_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_where_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_subquery_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_create_db_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_convert_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_insert_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_like_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_union_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_convert_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_right_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_trim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_reverse_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_substring_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_subquery_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_update_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_alter_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_enum_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_like_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_replace_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_left_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_update_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_instr_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_alter_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_convert_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_length_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_ps_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_like_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_locate_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_charlength_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_rtrim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_enum_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_right_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_create_db_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_enum_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_lpad_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_charlength_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_left_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_charset_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_rpad_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_left_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_locate_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_charset_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_lpad_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_ltrim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_select_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_rtrim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_select_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_where_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_lpad_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_create_tbl_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_update_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_locate_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_instr_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_where_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_rpad_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_instr_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_insert_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_ltrim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_rpad_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_length_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_right_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/r/jp_ltrim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_rpad_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_ps_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_left_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_alter_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_create_tbl_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_ps_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_charset_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_create_db_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_insert_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_join_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_enum_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_charlength_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_instr_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_update_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_substring_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_subquery_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_reverse_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_locate_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_create_tbl_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_locate_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_create_tbl_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_where_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_insert_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_join_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_union_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_instr_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_substring_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_subquery_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_convert_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_replace_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_like_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_left_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_select_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_enum_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_enum_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_join_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_length_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_insert_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_select_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_length_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_right_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_reverse_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_instr_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_alter_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_convert_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_subquery_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_charlength_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_rtrim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_charset_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_convert_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_ltrim_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_like_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_where_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_lpad_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_create_db_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_lpad_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_rpad_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_like_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_right_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_locate_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_length_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_right_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_select_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_reverse_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_update_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_left_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_rtrim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_charset_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_ltrim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_rpad_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_rtrim_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_ltrim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_trim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_where_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_trim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_replace_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_create_db_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_substring_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_lpad_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_charlength_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_replace_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_alter_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/jp/t/jp_update_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_nogtid/std_data/update-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_nogtid/std_data/write-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_nogtid/std_data/bug32407.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_nogtid/std_data/write-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_nogtid/std_data/ver_trunk_row_v2.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_nogtid/std_data/bug11747887-bin.000003",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_nogtid/std_data/ver_5_1_23.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_nogtid/std_data/ver_5_1-wl2325_r.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_nogtid/std_data/update-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_nogtid/std_data/ver_5_1-wl2325_s.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_nogtid/r/binlog_stm_ctype_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_nogtid/r/binlog_row_ctype_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_nogtid/r/binlog_mysqlbinlog_row_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_nogtid/r/binlog_mysqlbinlog_row_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_nogtid/r/binlog_mysqlbinlog_row.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_index.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_column.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_older_compatibility1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_column.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_older_compatibility1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_index.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_table.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/engines/iuds/r/type_bit_iuds.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/sys_vars/r/collation_database_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/sys_vars/r/character_set_results_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/sys_vars/r/collation_server_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/sys_vars/r/collation_connection_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/sys_vars/r/character_set_connection_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/sys_vars/r/character_set_client_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/sys_vars/t/character_set_results_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/sys_vars/t/character_set_client_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/sys_vars/t/character_set_connection_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/sys_vars/t/collation_database_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/sys_vars/t/collation_server_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/sys_vars/t/collation_connection_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/r/innodb_bug11789106.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/crc32_endianness.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/log_corruption3.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/log_corruption.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/log_corruption0.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/log_corruption4c.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/log_corruption1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/log_corruption2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/log_corruption5.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/log_corruption_1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/log_corruption6.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/log_corruption4a.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/log_corruption6b.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/log_corruption4b.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/log_corruption4d.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/log_corruption4.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/innodb/t/log_corruption7.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_gtid/std_data/update-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_gtid/std_data/write-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_gtid/std_data/bug32407.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_gtid/std_data/write-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_gtid/std_data/ver_trunk_row_v2.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_gtid/std_data/bug11747887-bin.000003",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_gtid/std_data/ver_5_1_23.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_gtid/std_data/ver_5_1-wl2325_r.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_gtid/std_data/update-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_gtid/std_data/ver_5_1-wl2325_s.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_gtid/r/binlog_gtid_mysqlbinlog_row_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_gtid/r/binlog_gtid_mysqlbinlog_row.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/suite/binlog_gtid/r/binlog_gtid_mysqlbinlog_row_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/extra/binlog_tests/ctype_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/extra/rpl_tests/rpl_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_big5.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_ucs.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/partition_hash.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_utf8mb4_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/opt_hints.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_utf8mb4_heap.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/mysql_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/type_set.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/errors.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_collate.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/fulltext.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_utf8mb4.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/component_string_service_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/type_datetime.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/mysqldump.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/sp.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/cast.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_latin1_de.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/csv.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_gb18030_binlog.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/lead_lag.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/date_formats.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ddl_i18n_koi8r.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/binary.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/mysqltest.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ps.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_many.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/func_like.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_latin2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/type_decimal.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_latin1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_utf8mb4_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/log_tables.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_utf8.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_gb18030_encoding_cn.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/union.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_recoding.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/explain.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/parser.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_tis620.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/outfile_loaddata.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_cp1250_ch.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/events_bugs.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ddl_i18n_utf8.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/alter_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/func_uuid.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/type_enum.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/ctype_cp1251.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/show_check_cs.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/show_check_ci.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/events_1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/varbinary.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/r/grant.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/type_set.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_big5.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_latin1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_utf8.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/sp.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/union.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_ucs.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/show_check_cs.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/cast.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/parser.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/func_like.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_gb18030_binlog.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_gb18030_encoding_cn.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/errors.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/events_bugs.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/binary.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/mysql_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_recoding.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/fulltext.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_cp1251.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/temptable_dump.sql.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_latin1_de.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/events_1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/explain.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/opt_hints.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ps.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_collate.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_utf8mb4.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_tis620.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/fulltext_left_join.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ddl_i18n_koi8r.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/mysqltest.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/alter_table.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_many.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_cp1250_ch.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/type_decimal.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/log_tables.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/grant.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ctype_filesystem-master.opt",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/ddl_i18n_utf8.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/mysql-test/t/type_enum.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/sql/MSG00001.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-8.0.14-jtuqrurxgl7g22po6obehihhbzkt4uwv/spack-src/doxygen_resources/logo-mysql-110x55.png"
    ],
    "total_files": 32289
}