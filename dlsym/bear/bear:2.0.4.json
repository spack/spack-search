{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-bear-2.0.4-mf5qxjasfnti3nto5yvgcaomhmwjvhkp/spack-src/libear/ear.c": "/*  Copyright (C) 2012-2015 by L\u00e1szl\u00f3 Nagy\n    This file is part of Bear.\n\n    Bear is a tool to generate compilation database for clang tooling.\n\n    Bear is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Bear is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * This file implements a shared library. This library can be pre-loaded by\n * the dynamic linker of the Operating System (OS). It implements a few function\n * related to process creation. By pre-load this library the executed process\n * uses these functions instead of those from the standard library.\n *\n * The idea here is to inject a logic before call the real methods. The logic is\n * to dump the call into a file. To call the real method this library is doing\n * the job of the dynamic linker.\n *\n * The only input for the log writing is about the destination directory.\n * This is passed as environment variable.\n */\n\n#include \"config.h\"\n\n#include <stddef.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <dlfcn.h>\n\n#if defined HAVE_POSIX_SPAWN || defined HAVE_POSIX_SPAWNP\n#include <spawn.h>\n#endif\n\n#if defined HAVE_NSGETENVIRON\n#include <crt_externs.h>\nstatic char **environ;\n#else\nextern char **environ;\n#endif\n\n\ntypedef char const * bear_env_t[ENV_SIZE];\n\nstatic int bear_capture_env_t(bear_env_t *env);\nstatic void bear_release_env_t(bear_env_t *env);\nstatic char const **bear_update_environment(char *const envp[], bear_env_t *env);\nstatic char const **bear_update_environ(char const **in, char const *key, char const *value);\nstatic void bear_report_call(char const *fun, char const *const argv[]);\nstatic char const **bear_strings_build(char const *arg, va_list *ap);\nstatic char const **bear_strings_copy(char const **const in);\nstatic char const **bear_strings_append(char const **in, char const *e);\nstatic size_t bear_strings_length(char const *const *in);\nstatic void bear_strings_release(char const **);\n\n\nstatic bear_env_t env_names =\n    { ENV_OUTPUT\n    , ENV_PRELOAD\n#ifdef ENV_FLAT\n    , ENV_FLAT\n#endif\n    };\n\nstatic bear_env_t initial_env =\n    { 0\n    , 0\n#ifdef ENV_FLAT\n    , 0\n#endif\n    };\n\nstatic int initialized = 0;\n\nstatic void on_load(void) __attribute__((constructor));\nstatic void on_unload(void) __attribute__((destructor));\n\n\n#define DLSYM(TYPE_, VAR_, SYMBOL_)                                            \\\n    union {                                                                    \\\n        void *from;                                                            \\\n        TYPE_ to;                                                              \\\n    } cast;                                                                    \\\n    if (0 == (cast.from = dlsym(RTLD_NEXT, SYMBOL_))) {                        \\\n        perror(\"bear: dlsym\");                                                 \\\n        exit(EXIT_FAILURE);                                                    \\\n    }                                                                          \\\n    TYPE_ const VAR_ = cast.to;\n\n\n#ifdef HAVE_EXECVE\nstatic int call_execve(const char *path, char *const argv[],\n                       char *const envp[]);\n#endif\n#ifdef HAVE_EXECVP\nstatic int call_execvp(const char *file, char *const argv[]);\n#endif\n#ifdef HAVE_EXECVPE\nstatic int call_execvpe(const char *file, char *const argv[],\n                        char *const envp[]);\n#endif\n#ifdef HAVE_EXECVP2\nstatic int call_execvP(const char *file, const char *search_path,\n                       char *const argv[]);\n#endif\n#ifdef HAVE_POSIX_SPAWN\nstatic int call_posix_spawn(pid_t *restrict pid, const char *restrict path,\n                            const posix_spawn_file_actions_t *file_actions,\n                            const posix_spawnattr_t *restrict attrp,\n                            char *const argv[restrict],\n                            char *const envp[restrict]);\n#endif\n#ifdef HAVE_POSIX_SPAWNP\nstatic int call_posix_spawnp(pid_t *restrict pid, const char *restrict file,\n                             const posix_spawn_file_actions_t *file_actions,\n                             const posix_spawnattr_t *restrict attrp,\n                             char *const argv[restrict],\n                             char *const envp[restrict]);\n#endif\n\n\n/* Initialization method to Captures the relevant environment variables.\n */\n\nstatic void on_load(void) {\n#ifdef HAVE_NSGETENVIRON\n    environ = *_NSGetEnviron();\n#endif\n    if (!initialized)\n        initialized = bear_capture_env_t(&initial_env);\n}\n\nstatic void on_unload(void) {\n    bear_release_env_t(&initial_env);\n    initialized = 0;\n}\n\n\n/* These are the methods we are try to hijack.\n */\n\n#ifdef HAVE_EXECVE\nint execve(const char *path, char *const argv[], char *const envp[]) {\n    bear_report_call(__func__, (char const *const *)argv);\n    return call_execve(path, argv, envp);\n}\n#endif\n\n#ifdef HAVE_EXECV\n#ifndef HAVE_EXECVE\n#error can not implement execv without execve\n#endif\nint execv(const char *path, char *const argv[]) {\n    bear_report_call(__func__, (char const *const *)argv);\n    return call_execve(path, argv, environ);\n}\n#endif\n\n#ifdef HAVE_EXECVPE\nint execvpe(const char *file, char *const argv[], char *const envp[]) {\n    bear_report_call(__func__, (char const *const *)argv);\n    return call_execvpe(file, argv, envp);\n}\n#endif\n\n#ifdef HAVE_EXECVP\nint execvp(const char *file, char *const argv[]) {\n    bear_report_call(__func__, (char const *const *)argv);\n    return call_execvp(file, argv);\n}\n#endif\n\n#ifdef HAVE_EXECVP2\nint execvP(const char *file, const char *search_path, char *const argv[]) {\n    bear_report_call(__func__, (char const *const *)argv);\n    return call_execvP(file, search_path, argv);\n}\n#endif\n\n#ifdef HAVE_EXECL\n#ifndef HAVE_EXECVE\n#error can not implement execl without execve\n#endif\nint execl(const char *path, const char *arg, ...) {\n    va_list args;\n    va_start(args, arg);\n    char const **argv = bear_strings_build(arg, &args);\n    va_end(args);\n\n    bear_report_call(__func__, (char const *const *)argv);\n    int const result = call_execve(path, (char *const *)argv, environ);\n\n    bear_strings_release(argv);\n    return result;\n}\n#endif\n\n#ifdef HAVE_EXECLP\n#ifndef HAVE_EXECVP\n#error can not implement execlp without execvp\n#endif\nint execlp(const char *file, const char *arg, ...) {\n    va_list args;\n    va_start(args, arg);\n    char const **argv = bear_strings_build(arg, &args);\n    va_end(args);\n\n    bear_report_call(__func__, (char const *const *)argv);\n    int const result = call_execvp(file, (char *const *)argv);\n\n    bear_strings_release(argv);\n    return result;\n}\n#endif\n\n#ifdef HAVE_EXECLE\n#ifndef HAVE_EXECVE\n#error can not implement execle without execve\n#endif\n// int execle(const char *path, const char *arg, ..., char * const envp[]);\nint execle(const char *path, const char *arg, ...) {\n    va_list args;\n    va_start(args, arg);\n    char const **argv = bear_strings_build(arg, &args);\n    char const **envp = va_arg(args, char const **);\n    va_end(args);\n\n    bear_report_call(__func__, (char const *const *)argv);\n    int const result =\n        call_execve(path, (char *const *)argv, (char *const *)envp);\n\n    bear_strings_release(argv);\n    return result;\n}\n#endif\n\n#ifdef HAVE_POSIX_SPAWN\nint posix_spawn(pid_t *restrict pid, const char *restrict path,\n                const posix_spawn_file_actions_t *file_actions,\n                const posix_spawnattr_t *restrict attrp,\n                char *const argv[restrict], char *const envp[restrict]) {\n    bear_report_call(__func__, (char const *const *)argv);\n    return call_posix_spawn(pid, path, file_actions, attrp, argv, envp);\n}\n#endif\n\n#ifdef HAVE_POSIX_SPAWNP\nint posix_spawnp(pid_t *restrict pid, const char *restrict file,\n                 const posix_spawn_file_actions_t *file_actions,\n                 const posix_spawnattr_t *restrict attrp,\n                 char *const argv[restrict], char *const envp[restrict]) {\n    bear_report_call(__func__, (char const *const *)argv);\n    return call_posix_spawnp(pid, file, file_actions, attrp, argv, envp);\n}\n#endif\n\n/* These are the methods which forward the call to the standard implementation.\n */\n\n#ifdef HAVE_EXECVE\nstatic int call_execve(const char *path, char *const argv[],\n                       char *const envp[]) {\n    typedef int (*func)(const char *, char *const *, char *const *);\n\n    DLSYM(func, fp, \"execve\");\n\n    char const **const menvp = bear_update_environment(envp, &initial_env);\n    int const result = (*fp)(path, argv, (char *const *)menvp);\n    bear_strings_release(menvp);\n    return result;\n}\n#endif\n\n#ifdef HAVE_EXECVPE\nstatic int call_execvpe(const char *file, char *const argv[],\n                        char *const envp[]) {\n    typedef int (*func)(const char *, char *const *, char *const *);\n\n    DLSYM(func, fp, \"execvpe\");\n\n    char const **const menvp = bear_update_environment(envp, &initial_env);\n    int const result = (*fp)(file, argv, (char *const *)menvp);\n    bear_strings_release(menvp);\n    return result;\n}\n#endif\n\n#ifdef HAVE_EXECVP\nstatic int call_execvp(const char *file, char *const argv[]) {\n    typedef int (*func)(const char *file, char *const argv[]);\n\n    DLSYM(func, fp, \"execvp\");\n\n    char **const original = environ;\n    char const **const modified = bear_update_environment(original, &initial_env);\n    environ = (char **)modified;\n    int const result = (*fp)(file, argv);\n    environ = original;\n    bear_strings_release(modified);\n\n    return result;\n}\n#endif\n\n#ifdef HAVE_EXECVP2\nstatic int call_execvP(const char *file, const char *search_path,\n                       char *const argv[]) {\n    typedef int (*func)(const char *, const char *, char *const *);\n\n    DLSYM(func, fp, \"execvP\");\n\n    char **const original = environ;\n    char const **const modified = bear_update_environment(original, &initial_env);\n    environ = (char **)modified;\n    int const result = (*fp)(file, search_path, argv);\n    environ = original;\n    bear_strings_release(modified);\n\n    return result;\n}\n#endif\n\n#ifdef HAVE_POSIX_SPAWN\nstatic int call_posix_spawn(pid_t *restrict pid, const char *restrict path,\n                            const posix_spawn_file_actions_t *file_actions,\n                            const posix_spawnattr_t *restrict attrp,\n                            char *const argv[restrict],\n                            char *const envp[restrict]) {\n    typedef int (*func)(pid_t *restrict, const char *restrict,\n                        const posix_spawn_file_actions_t *,\n                        const posix_spawnattr_t *restrict,\n                        char *const *restrict, char *const *restrict);\n\n    DLSYM(func, fp, \"posix_spawn\");\n\n    char const **const menvp = bear_update_environment(envp, &initial_env);\n    int const result =\n        (*fp)(pid, path, file_actions, attrp, argv, (char *const *restrict)menvp);\n    bear_strings_release(menvp);\n    return result;\n}\n#endif\n\n#ifdef HAVE_POSIX_SPAWNP\nstatic int call_posix_spawnp(pid_t *restrict pid, const char *restrict file,\n                             const posix_spawn_file_actions_t *file_actions,\n                             const posix_spawnattr_t *restrict attrp,\n                             char *const argv[restrict],\n                             char *const envp[restrict]) {\n    typedef int (*func)(pid_t *restrict, const char *restrict,\n                        const posix_spawn_file_actions_t *,\n                        const posix_spawnattr_t *restrict,\n                        char *const *restrict, char *const *restrict);\n\n    DLSYM(func, fp, \"posix_spawnp\");\n\n    char const **const menvp = bear_update_environment(envp, &initial_env);\n    int const result =\n        (*fp)(pid, file, file_actions, attrp, argv, (char *const *restrict)menvp);\n    bear_strings_release(menvp);\n    return result;\n}\n#endif\n\n/* this method is to write log about the process creation. */\n\nstatic void bear_report_call(char const *fun, char const *const argv[]) {\n    static int const GS = 0x1d;\n    static int const RS = 0x1e;\n    static int const US = 0x1f;\n\n    if (!initialized)\n        return;\n\n    const char *cwd = getcwd(NULL, 0);\n    if (0 == cwd) {\n        perror(\"bear: getcwd\");\n        exit(EXIT_FAILURE);\n    }\n    char const * const out_dir = initial_env[0];\n    size_t const path_max_length = strlen(out_dir) + 32;\n    char filename[path_max_length];\n    if (-1 == snprintf(filename, path_max_length, \"%s/%d.cmd\", out_dir, getpid())) {\n        perror(\"bear: snprintf\");\n        exit(EXIT_FAILURE);\n    }\n    FILE * fd = fopen(filename, \"a+\");\n    if (0 == fd) {\n        perror(\"bear: fopen\");\n        exit(EXIT_FAILURE);\n    }\n    fprintf(fd, \"%d%c\", getpid(), RS);\n    fprintf(fd, \"%d%c\", getppid(), RS);\n    fprintf(fd, \"%s%c\", fun, RS);\n    fprintf(fd, \"%s%c\", cwd, RS);\n    size_t const argc = bear_strings_length(argv);\n    for (size_t it = 0; it < argc; ++it) {\n        fprintf(fd, \"%s%c\", argv[it], US);\n    }\n    fprintf(fd, \"%c\", GS);\n    if (fclose(fd)) {\n        perror(\"bear: fclose\");\n        exit(EXIT_FAILURE);\n    }\n    free((void *)cwd);\n}\n\n/* update environment assure that chilren processes will copy the desired\n * behaviour */\n\nstatic int bear_capture_env_t(bear_env_t *env) {\n    int status = 1;\n    for (size_t it = 0; it < ENV_SIZE; ++it) {\n        char const * const env_value = getenv(env_names[it]);\n        char const * const env_copy = (env_value) ? strdup(env_value) : env_value;\n        (*env)[it] = env_copy;\n        status &= (env_copy) ? 1 : 0;\n    }\n    return status;\n}\n\nstatic void bear_release_env_t(bear_env_t *env) {\n    for (size_t it = 0; it < ENV_SIZE; ++it) {\n        free((void *)(*env)[it]);\n        (*env)[it] = 0;\n    }\n}\n\nstatic char const **bear_update_environment(char *const envp[], bear_env_t *env) {\n    char const **result = bear_strings_copy((char const **)envp);\n    for (size_t it = 0; it < ENV_SIZE && (*env)[it]; ++it)\n        result = bear_update_environ(result, env_names[it], (*env)[it]);\n    return result;\n}\n\nstatic char const **bear_update_environ(char const *envs[], char const *key, char const * const value) {\n    // find the key if it's there\n    size_t const key_length = strlen(key);\n    char const **it = envs;\n    for (; (it) && (*it); ++it) {\n        if ((0 == strncmp(*it, key, key_length)) &&\n            (strlen(*it) > key_length) && ('=' == (*it)[key_length]))\n            break;\n    }\n    // allocate a environment entry\n    size_t const value_length = strlen(value);\n    size_t const env_length = key_length + value_length + 2;\n    char *env = malloc(env_length);\n    if (0 == env) {\n        perror(\"bear: malloc [in env_update]\");\n        exit(EXIT_FAILURE);\n    }\n    if (-1 == snprintf(env, env_length, \"%s=%s\", key, value)) {\n        perror(\"bear: snprintf\");\n        exit(EXIT_FAILURE);\n    }\n    // replace or append the environment entry\n    if (it && *it) {\n        free((void *)*it);\n        *it = env;\n\treturn envs;\n    }\n    return bear_strings_append(envs, env);\n}\n\n/* util methods to deal with string arrays. environment and process arguments\n * are both represented as string arrays. */\n\nstatic char const **bear_strings_build(char const *const arg, va_list *args) {\n    char const **result = 0;\n    size_t size = 0;\n    for (char const *it = arg; it; it = va_arg(*args, char const *)) {\n        result = realloc(result, (size + 1) * sizeof(char const *));\n        if (0 == result) {\n            perror(\"bear: realloc\");\n            exit(EXIT_FAILURE);\n        }\n        char const *copy = strdup(it);\n        if (0 == copy) {\n            perror(\"bear: strdup\");\n            exit(EXIT_FAILURE);\n        }\n        result[size++] = copy;\n    }\n    result = realloc(result, (size + 1) * sizeof(char const *));\n    if (0 == result) {\n        perror(\"bear: realloc\");\n        exit(EXIT_FAILURE);\n    }\n    result[size++] = 0;\n\n    return result;\n}\n\nstatic char const **bear_strings_copy(char const **const in) {\n    size_t const size = bear_strings_length(in);\n\n    char const **const result = malloc((size + 1) * sizeof(char const *));\n    if (0 == result) {\n        perror(\"bear: malloc\");\n        exit(EXIT_FAILURE);\n    }\n\n    char const **out_it = result;\n    for (char const *const *in_it = in; (in_it) && (*in_it);\n         ++in_it, ++out_it) {\n        *out_it = strdup(*in_it);\n        if (0 == *out_it) {\n            perror(\"bear: strdup\");\n            exit(EXIT_FAILURE);\n        }\n    }\n    *out_it = 0;\n    return result;\n}\n\nstatic char const **bear_strings_append(char const **const in,\n                                        char const *const e) {\n    size_t size = bear_strings_length(in);\n    char const **result = realloc(in, (size + 2) * sizeof(char const *));\n    if (0 == result) {\n        perror(\"bear: realloc\");\n        exit(EXIT_FAILURE);\n    }\n    result[size++] = e;\n    result[size++] = 0;\n    return result;\n}\n\nstatic size_t bear_strings_length(char const *const *const in) {\n    size_t result = 0;\n    for (char const *const *it = in; (it) && (*it); ++it)\n        ++result;\n    return result;\n}\n\nstatic void bear_strings_release(char const **in) {\n    for (char const *const *it = in; (it) && (*it); ++it) {\n        free((void *)*it);\n    }\n    free((void *)in);\n}\n"
    },
    "skipped": [],
    "total_files": 41
}