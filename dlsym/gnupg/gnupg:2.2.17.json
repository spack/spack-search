{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/scd/apdu.c": "/* apdu.c - ISO 7816 APDU functions and low level I/O\n * Copyright (C) 2003, 2004, 2008, 2009, 2010,\n *               2011 Free Software Foundation, Inc.\n *\n * This file is part of GnuPG.\n *\n * GnuPG is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * GnuPG is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <https://www.gnu.org/licenses/>.\n */\n\n/* NOTE: This module is also used by other software, thus the use of\n   the macro USE_NPTH is mandatory.  For GnuPG this macro is\n   guaranteed to be defined true. */\n\n#include <config.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <signal.h>\n#ifdef USE_NPTH\n# include <unistd.h>\n# include <fcntl.h>\n# include <npth.h>\n#endif\n\n\n/* If requested include the definitions for the remote APDU protocol\n   code. */\n#ifdef USE_G10CODE_RAPDU\n#include \"rapdu.h\"\n#endif /*USE_G10CODE_RAPDU*/\n\n#if defined(GNUPG_SCD_MAIN_HEADER)\n#include GNUPG_SCD_MAIN_HEADER\n#elif GNUPG_MAJOR_VERSION == 1\n/* This is used with GnuPG version < 1.9.  The code has been source\n   copied from the current GnuPG >= 1.9  and is maintained over\n   there. */\n#include \"../common/options.h\"\n#include \"errors.h\"\n#include \"memory.h\"\n#include \"../common/util.h\"\n#include \"../common/i18n.h\"\n#include \"dynload.h\"\n#include \"cardglue.h\"\n#else /* GNUPG_MAJOR_VERSION != 1 */\n#include \"scdaemon.h\"\n#include \"../common/exechelp.h\"\n#endif /* GNUPG_MAJOR_VERSION != 1 */\n#include \"../common/host2net.h\"\n\n#include \"iso7816.h\"\n#include \"apdu.h\"\n#define CCID_DRIVER_INCLUDE_USB_IDS 1\n#include \"ccid-driver.h\"\n\nstruct dev_list {\n  struct ccid_dev_table *ccid_table;\n  const char *portstr;\n  int idx;\n  int idx_max;\n};\n\n#define MAX_READER 4 /* Number of readers we support concurrently. */\n\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n#define DLSTDCALL __stdcall\n#else\n#define DLSTDCALL\n#endif\n\n#if defined(__APPLE__) || defined(_WIN32) || defined(__CYGWIN__)\ntypedef unsigned int pcsc_dword_t;\n#else\ntypedef unsigned long pcsc_dword_t;\n#endif\n\n/* A structure to collect information pertaining to one reader\n   slot. */\nstruct reader_table_s {\n  int used;            /* True if slot is used. */\n  unsigned short port; /* Port number:  0 = unused, 1 - dev/tty */\n\n  /* Function pointers initialized to the various backends.  */\n  int (*connect_card)(int);\n  int (*disconnect_card)(int);\n  int (*close_reader)(int);\n  int (*reset_reader)(int);\n  int (*get_status_reader)(int, unsigned int *, int);\n  int (*send_apdu_reader)(int,unsigned char *,size_t,\n                          unsigned char *, size_t *, pininfo_t *);\n  int (*check_pinpad)(int, int, pininfo_t *);\n  void (*dump_status_reader)(int);\n  int (*set_progress_cb)(int, gcry_handler_progress_t, void*);\n  int (*set_prompt_cb)(int, void (*) (void *, int), void*);\n  int (*pinpad_verify)(int, int, int, int, int, pininfo_t *);\n  int (*pinpad_modify)(int, int, int, int, int, pininfo_t *);\n\n  struct {\n    ccid_driver_t handle;\n  } ccid;\n  struct {\n    long context;\n    long card;\n    pcsc_dword_t protocol;\n    pcsc_dword_t verify_ioctl;\n    pcsc_dword_t modify_ioctl;\n    int pinmin;\n    int pinmax;\n    pcsc_dword_t current_state;\n  } pcsc;\n#ifdef USE_G10CODE_RAPDU\n  struct {\n    rapdu_t handle;\n  } rapdu;\n#endif /*USE_G10CODE_RAPDU*/\n  char *rdrname;     /* Name of the connected reader or NULL if unknown. */\n  unsigned int is_t0:1;     /* True if we know that we are running T=0. */\n  unsigned int is_spr532:1; /* True if we know that the reader is a SPR532.  */\n  unsigned int pinpad_varlen_supported:1;  /* True if we know that the reader\n                                              supports variable length pinpad\n                                              input.  */\n  unsigned int require_get_status:1;\n  unsigned char atr[33];\n  size_t atrlen;           /* A zero length indicates that the ATR has\n                              not yet been read; i.e. the card is not\n                              ready for use. */\n#ifdef USE_NPTH\n  npth_mutex_t lock;\n#endif\n};\ntypedef struct reader_table_s *reader_table_t;\n\n/* A global table to keep track of active readers. */\nstatic struct reader_table_s reader_table[MAX_READER];\n\n#ifdef USE_NPTH\nstatic npth_mutex_t reader_table_lock;\n#endif\n\n\n/* PC/SC constants and function pointer. */\n#define PCSC_SCOPE_USER      0\n#define PCSC_SCOPE_TERMINAL  1\n#define PCSC_SCOPE_SYSTEM    2\n#define PCSC_SCOPE_GLOBAL    3\n\n#define PCSC_PROTOCOL_T0     1\n#define PCSC_PROTOCOL_T1     2\n#ifdef HAVE_W32_SYSTEM\n# define PCSC_PROTOCOL_RAW   0x00010000  /* The active protocol.  */\n#else\n# define PCSC_PROTOCOL_RAW   4\n#endif\n\n#define PCSC_SHARE_EXCLUSIVE 1\n#define PCSC_SHARE_SHARED    2\n#define PCSC_SHARE_DIRECT    3\n\n#define PCSC_LEAVE_CARD      0\n#define PCSC_RESET_CARD      1\n#define PCSC_UNPOWER_CARD    2\n#define PCSC_EJECT_CARD      3\n\n#ifdef HAVE_W32_SYSTEM\n# define PCSC_UNKNOWN    0x0000  /* The driver is not aware of the status.  */\n# define PCSC_ABSENT     0x0001  /* Card is absent.  */\n# define PCSC_PRESENT    0x0002  /* Card is present.  */\n# define PCSC_SWALLOWED  0x0003  /* Card is present and electrical connected. */\n# define PCSC_POWERED    0x0004  /* Card is powered.  */\n# define PCSC_NEGOTIABLE 0x0005  /* Card is awaiting PTS.  */\n# define PCSC_SPECIFIC   0x0006  /* Card is ready for use.  */\n#else\n# define PCSC_UNKNOWN    0x0001\n# define PCSC_ABSENT     0x0002  /* Card is absent.  */\n# define PCSC_PRESENT    0x0004  /* Card is present.  */\n# define PCSC_SWALLOWED  0x0008  /* Card is present and electrical connected. */\n# define PCSC_POWERED    0x0010  /* Card is powered.  */\n# define PCSC_NEGOTIABLE 0x0020  /* Card is awaiting PTS.  */\n# define PCSC_SPECIFIC   0x0040  /* Card is ready for use.  */\n#endif\n\n#define PCSC_STATE_UNAWARE     0x0000  /* Want status.  */\n#define PCSC_STATE_IGNORE      0x0001  /* Ignore this reader.  */\n#define PCSC_STATE_CHANGED     0x0002  /* State has changed.  */\n#define PCSC_STATE_UNKNOWN     0x0004  /* Reader unknown.  */\n#define PCSC_STATE_UNAVAILABLE 0x0008  /* Status unavailable.  */\n#define PCSC_STATE_EMPTY       0x0010  /* Card removed.  */\n#define PCSC_STATE_PRESENT     0x0020  /* Card inserted.  */\n#define PCSC_STATE_ATRMATCH    0x0040  /* ATR matches card. */\n#define PCSC_STATE_EXCLUSIVE   0x0080  /* Exclusive Mode.  */\n#define PCSC_STATE_INUSE       0x0100  /* Shared mode.  */\n#define PCSC_STATE_MUTE        0x0200  /* Unresponsive card.  */\n#ifdef HAVE_W32_SYSTEM\n# define PCSC_STATE_UNPOWERED  0x0400  /* Card not powerred up.  */\n#endif\n\n/* Some PC/SC error codes.  */\n#define PCSC_E_CANCELLED               0x80100002\n#define PCSC_E_CANT_DISPOSE            0x8010000E\n#define PCSC_E_INSUFFICIENT_BUFFER     0x80100008\n#define PCSC_E_INVALID_ATR             0x80100015\n#define PCSC_E_INVALID_HANDLE          0x80100003\n#define PCSC_E_INVALID_PARAMETER       0x80100004\n#define PCSC_E_INVALID_TARGET          0x80100005\n#define PCSC_E_INVALID_VALUE           0x80100011\n#define PCSC_E_NO_MEMORY               0x80100006\n#define PCSC_E_UNKNOWN_READER          0x80100009\n#define PCSC_E_TIMEOUT                 0x8010000A\n#define PCSC_E_SHARING_VIOLATION       0x8010000B\n#define PCSC_E_NO_SMARTCARD            0x8010000C\n#define PCSC_E_UNKNOWN_CARD            0x8010000D\n#define PCSC_E_PROTO_MISMATCH          0x8010000F\n#define PCSC_E_NOT_READY               0x80100010\n#define PCSC_E_SYSTEM_CANCELLED        0x80100012\n#define PCSC_E_NOT_TRANSACTED          0x80100016\n#define PCSC_E_READER_UNAVAILABLE      0x80100017\n#define PCSC_E_NO_SERVICE              0x8010001D\n#define PCSC_E_SERVICE_STOPPED         0x8010001E\n#define PCSC_W_RESET_CARD              0x80100068\n#define PCSC_W_REMOVED_CARD            0x80100069\n\n/* Fix pcsc-lite ABI incompatibility.  */\n#ifndef SCARD_CTL_CODE\n#ifdef _WIN32\n#include <winioctl.h>\n#define SCARD_CTL_CODE(code) CTL_CODE(FILE_DEVICE_SMARTCARD, (code), \\\n                                      METHOD_BUFFERED, FILE_ANY_ACCESS)\n#else\n#define SCARD_CTL_CODE(code) (0x42000000 + (code))\n#endif\n#endif\n\n#define CM_IOCTL_GET_FEATURE_REQUEST     SCARD_CTL_CODE(3400)\n#define CM_IOCTL_VENDOR_IFD_EXCHANGE     SCARD_CTL_CODE(1)\n#define FEATURE_VERIFY_PIN_DIRECT        0x06\n#define FEATURE_MODIFY_PIN_DIRECT        0x07\n#define FEATURE_GET_TLV_PROPERTIES       0x12\n\n#define PCSCv2_PART10_PROPERTY_bEntryValidationCondition 2\n#define PCSCv2_PART10_PROPERTY_bTimeOut2                 3\n#define PCSCv2_PART10_PROPERTY_bMinPINSize               6\n#define PCSCv2_PART10_PROPERTY_bMaxPINSize               7\n#define PCSCv2_PART10_PROPERTY_wIdVendor                11\n#define PCSCv2_PART10_PROPERTY_wIdProduct               12\n\n\n/* The PC/SC error is defined as a long as per specs.  Due to left\n   shifts bit 31 will get sign extended.  We use this mask to fix\n   it. */\n#define PCSC_ERR_MASK(a)  ((a) & 0xffffffff)\n\n\nstruct pcsc_io_request_s\n{\n  unsigned long protocol;\n  unsigned long pci_len;\n};\n\ntypedef struct pcsc_io_request_s *pcsc_io_request_t;\n\n#ifdef __APPLE__\n#pragma pack(1)\n#endif\n\nstruct pcsc_readerstate_s\n{\n  const char *reader;\n  void *user_data;\n  pcsc_dword_t current_state;\n  pcsc_dword_t event_state;\n  pcsc_dword_t atrlen;\n  unsigned char atr[33];\n};\n\n#ifdef __APPLE__\n#pragma pack()\n#endif\n\ntypedef struct pcsc_readerstate_s *pcsc_readerstate_t;\n\nlong (* DLSTDCALL pcsc_establish_context) (pcsc_dword_t scope,\n                                           const void *reserved1,\n                                           const void *reserved2,\n                                           long *r_context);\nlong (* DLSTDCALL pcsc_release_context) (long context);\nlong (* DLSTDCALL pcsc_list_readers) (long context,\n                                      const char *groups,\n                                      char *readers, pcsc_dword_t*readerslen);\nlong (* DLSTDCALL pcsc_get_status_change) (long context,\n                                           pcsc_dword_t timeout,\n                                           pcsc_readerstate_t readerstates,\n                                           pcsc_dword_t nreaderstates);\nlong (* DLSTDCALL pcsc_connect) (long context,\n                                 const char *reader,\n                                 pcsc_dword_t share_mode,\n                                 pcsc_dword_t preferred_protocols,\n                                 long *r_card,\n                                 pcsc_dword_t *r_active_protocol);\nlong (* DLSTDCALL pcsc_reconnect) (long card,\n                                   pcsc_dword_t share_mode,\n                                   pcsc_dword_t preferred_protocols,\n                                   pcsc_dword_t initialization,\n                                   pcsc_dword_t *r_active_protocol);\nlong (* DLSTDCALL pcsc_disconnect) (long card,\n                                    pcsc_dword_t disposition);\nlong (* DLSTDCALL pcsc_status) (long card,\n                                char *reader, pcsc_dword_t *readerlen,\n                                pcsc_dword_t *r_state,\n                                pcsc_dword_t *r_protocol,\n                                unsigned char *atr, pcsc_dword_t *atrlen);\nlong (* DLSTDCALL pcsc_begin_transaction) (long card);\nlong (* DLSTDCALL pcsc_end_transaction) (long card,\n                                         pcsc_dword_t disposition);\nlong (* DLSTDCALL pcsc_transmit) (long card,\n                                  const pcsc_io_request_t send_pci,\n                                  const unsigned char *send_buffer,\n                                  pcsc_dword_t send_len,\n                                  pcsc_io_request_t recv_pci,\n                                  unsigned char *recv_buffer,\n                                  pcsc_dword_t *recv_len);\nlong (* DLSTDCALL pcsc_set_timeout) (long context,\n                                     pcsc_dword_t timeout);\nlong (* DLSTDCALL pcsc_control) (long card,\n                                 pcsc_dword_t control_code,\n                                 const void *send_buffer,\n                                 pcsc_dword_t send_len,\n                                 void *recv_buffer,\n                                 pcsc_dword_t recv_len,\n                                 pcsc_dword_t *bytes_returned);\n\n\n/*  Prototypes.  */\nstatic int pcsc_vendor_specific_init (int slot);\nstatic int pcsc_get_status (int slot, unsigned int *status, int on_wire);\nstatic int reset_pcsc_reader (int slot);\nstatic int apdu_get_status_internal (int slot, int hang, unsigned int *status,\n                                     int on_wire);\nstatic int check_pcsc_pinpad (int slot, int command, pininfo_t *pininfo);\nstatic int pcsc_pinpad_verify (int slot, int class, int ins, int p0, int p1,\n                               pininfo_t *pininfo);\nstatic int pcsc_pinpad_modify (int slot, int class, int ins, int p0, int p1,\n                               pininfo_t *pininfo);\n\n\n\f\n/*\n      Helper\n */\n\nstatic int\nlock_slot (int slot)\n{\n#ifdef USE_NPTH\n  int err;\n\n  err = npth_mutex_lock (&reader_table[slot].lock);\n  if (err)\n    {\n      log_error (\"failed to acquire apdu lock: %s\\n\", strerror (err));\n      return SW_HOST_LOCKING_FAILED;\n    }\n#endif /*USE_NPTH*/\n  return 0;\n}\n\nstatic int\ntrylock_slot (int slot)\n{\n#ifdef USE_NPTH\n  int err;\n\n  err = npth_mutex_trylock (&reader_table[slot].lock);\n  if (err == EBUSY)\n    return SW_HOST_BUSY;\n  else if (err)\n    {\n      log_error (\"failed to acquire apdu lock: %s\\n\", strerror (err));\n      return SW_HOST_LOCKING_FAILED;\n    }\n#endif /*USE_NPTH*/\n  return 0;\n}\n\nstatic void\nunlock_slot (int slot)\n{\n#ifdef USE_NPTH\n  int err;\n\n  err = npth_mutex_unlock (&reader_table[slot].lock);\n  if (err)\n    log_error (\"failed to release apdu lock: %s\\n\", strerror (errno));\n#endif /*USE_NPTH*/\n}\n\n\n/* Find an unused reader slot for PORTSTR and put it into the reader\n   table.  Return -1 on error or the index into the reader table.\n   Acquire slot's lock on successful return.  Caller needs to unlock it.  */\nstatic int\nnew_reader_slot (void)\n{\n  int i, reader = -1;\n\n  for (i=0; i < MAX_READER; i++)\n    if (!reader_table[i].used)\n      {\n        reader = i;\n        reader_table[reader].used = 1;\n        break;\n      }\n\n  if (reader == -1)\n    {\n      log_error (\"new_reader_slot: out of slots\\n\");\n      return -1;\n    }\n\n  if (lock_slot (reader))\n    {\n      reader_table[reader].used = 0;\n      return -1;\n    }\n\n  reader_table[reader].connect_card = NULL;\n  reader_table[reader].disconnect_card = NULL;\n  reader_table[reader].close_reader = NULL;\n  reader_table[reader].reset_reader = NULL;\n  reader_table[reader].get_status_reader = NULL;\n  reader_table[reader].send_apdu_reader = NULL;\n  reader_table[reader].check_pinpad = check_pcsc_pinpad;\n  reader_table[reader].dump_status_reader = NULL;\n  reader_table[reader].set_progress_cb = NULL;\n  reader_table[reader].set_prompt_cb = NULL;\n  reader_table[reader].pinpad_verify = pcsc_pinpad_verify;\n  reader_table[reader].pinpad_modify = pcsc_pinpad_modify;\n\n  reader_table[reader].is_t0 = 1;\n  reader_table[reader].is_spr532 = 0;\n  reader_table[reader].pinpad_varlen_supported = 0;\n  reader_table[reader].require_get_status = 1;\n  reader_table[reader].pcsc.verify_ioctl = 0;\n  reader_table[reader].pcsc.modify_ioctl = 0;\n  reader_table[reader].pcsc.pinmin = -1;\n  reader_table[reader].pcsc.pinmax = -1;\n  reader_table[reader].pcsc.current_state = PCSC_STATE_UNAWARE;\n\n  return reader;\n}\n\n\nstatic void\ndump_reader_status (int slot)\n{\n  if (!opt.verbose)\n    return;\n\n  if (reader_table[slot].dump_status_reader)\n    reader_table[slot].dump_status_reader (slot);\n\n  if (reader_table[slot].atrlen)\n    {\n      log_info (\"slot %d: ATR=\", slot);\n      log_printhex (\"\", reader_table[slot].atr, reader_table[slot].atrlen);\n    }\n}\n\n\n\nstatic const char *\nhost_sw_string (long err)\n{\n  switch (err)\n    {\n    case 0: return \"okay\";\n    case SW_HOST_OUT_OF_CORE: return \"out of core\";\n    case SW_HOST_INV_VALUE: return \"invalid value\";\n    case SW_HOST_NO_DRIVER: return \"no driver\";\n    case SW_HOST_NOT_SUPPORTED: return \"not supported\";\n    case SW_HOST_LOCKING_FAILED: return \"locking failed\";\n    case SW_HOST_BUSY: return \"busy\";\n    case SW_HOST_NO_CARD: return \"no card\";\n    case SW_HOST_CARD_INACTIVE: return \"card inactive\";\n    case SW_HOST_CARD_IO_ERROR: return \"card I/O error\";\n    case SW_HOST_GENERAL_ERROR: return \"general error\";\n    case SW_HOST_NO_READER: return \"no reader\";\n    case SW_HOST_ABORTED: return \"aborted\";\n    case SW_HOST_NO_PINPAD: return \"no pinpad\";\n    case SW_HOST_ALREADY_CONNECTED: return \"already connected\";\n    case SW_HOST_CANCELLED: return \"cancelled\";\n    default: return \"unknown host status error\";\n    }\n}\n\n\nconst char *\napdu_strerror (int rc)\n{\n  switch (rc)\n    {\n    case SW_EOF_REACHED    : return \"eof reached\";\n    case SW_EEPROM_FAILURE : return \"eeprom failure\";\n    case SW_WRONG_LENGTH   : return \"wrong length\";\n    case SW_CHV_WRONG      : return \"CHV wrong\";\n    case SW_CHV_BLOCKED    : return \"CHV blocked\";\n    case SW_REF_DATA_INV   : return \"referenced data invalidated\";\n    case SW_USE_CONDITIONS : return \"use conditions not satisfied\";\n    case SW_BAD_PARAMETER  : return \"bad parameter\";\n    case SW_NOT_SUPPORTED  : return \"not supported\";\n    case SW_FILE_NOT_FOUND : return \"file not found\";\n    case SW_RECORD_NOT_FOUND:return \"record not found\";\n    case SW_REF_NOT_FOUND  : return \"reference not found\";\n    case SW_NOT_ENOUGH_MEMORY: return \"not enough memory space in the file\";\n    case SW_INCONSISTENT_LC: return \"Lc inconsistent with TLV structure.\";\n    case SW_INCORRECT_P0_P1: return \"incorrect parameters P0,P1\";\n    case SW_BAD_LC         : return \"Lc inconsistent with P0,P1\";\n    case SW_BAD_P0_P1      : return \"bad P0,P1\";\n    case SW_INS_NOT_SUP    : return \"instruction not supported\";\n    case SW_CLA_NOT_SUP    : return \"class not supported\";\n    case SW_SUCCESS        : return \"success\";\n    default:\n      if ((rc & ~0x00ff) == SW_MORE_DATA)\n        return \"more data available\";\n      if ( (rc & 0x10000) )\n        return host_sw_string (rc);\n      return \"unknown status error\";\n    }\n}\n\f\n/*\n       PC/SC Interface\n */\n\nstatic const char *\npcsc_error_string (long err)\n{\n  const char *s;\n\n  if (!err)\n    return \"okay\";\n  if ((err & 0x80100000) != 0x80100000)\n    return \"invalid PC/SC error code\";\n  err &= 0xffff;\n  switch (err)\n    {\n    case 0x0002: s = \"cancelled\"; break;\n    case 0x000e: s = \"can't dispose\"; break;\n    case 0x0008: s = \"insufficient buffer\"; break;\n    case 0x0015: s = \"invalid ATR\"; break;\n    case 0x0003: s = \"invalid handle\"; break;\n    case 0x0004: s = \"invalid parameter\"; break;\n    case 0x0005: s = \"invalid target\"; break;\n    case 0x0011: s = \"invalid value\"; break;\n    case 0x0006: s = \"no memory\"; break;\n    case 0x0013: s = \"comm error\"; break;\n    case 0x0001: s = \"internal error\"; break;\n    case 0x0014: s = \"unknown error\"; break;\n    case 0x0007: s = \"waited too long\"; break;\n    case 0x0009: s = \"unknown reader\"; break;\n    case 0x000a: s = \"timeout\"; break;\n    case 0x000b: s = \"sharing violation\"; break;\n    case 0x000c: s = \"no smartcard\"; break;\n    case 0x000d: s = \"unknown card\"; break;\n    case 0x000f: s = \"proto mismatch\"; break;\n    case 0x0010: s = \"not ready\"; break;\n    case 0x0012: s = \"system cancelled\"; break;\n    case 0x0016: s = \"not transacted\"; break;\n    case 0x0017: s = \"reader unavailable\"; break;\n    case 0x0065: s = \"unsupported card\"; break;\n    case 0x0066: s = \"unresponsive card\"; break;\n    case 0x0067: s = \"unpowered card\"; break;\n    case 0x0068: s = \"reset card\"; break;\n    case 0x0069: s = \"removed card\"; break;\n    case 0x006a: s = \"inserted card\"; break;\n    case 0x001f: s = \"unsupported feature\"; break;\n    case 0x0019: s = \"PCI too small\"; break;\n    case 0x001a: s = \"reader unsupported\"; break;\n    case 0x001b: s = \"duplicate reader\"; break;\n    case 0x001c: s = \"card unsupported\"; break;\n    case 0x001d: s = \"no service\"; break;\n    case 0x001e: s = \"service stopped\"; break;\n    default:     s = \"unknown PC/SC error code\"; break;\n    }\n  return s;\n}\n\n/* Map PC/SC error codes to our special host status words.  */\nstatic int\npcsc_error_to_sw (long ec)\n{\n  int rc;\n\n  switch ( PCSC_ERR_MASK (ec) )\n    {\n    case 0:  rc = 0; break;\n\n    case PCSC_E_CANCELLED:           rc = SW_HOST_CANCELLED; break;\n    case PCSC_E_NO_MEMORY:           rc = SW_HOST_OUT_OF_CORE; break;\n    case PCSC_E_TIMEOUT:             rc = SW_HOST_CARD_IO_ERROR; break;\n    case PCSC_E_NO_SERVICE:\n    case PCSC_E_SERVICE_STOPPED:\n    case PCSC_E_UNKNOWN_READER:      rc = SW_HOST_NO_READER; break;\n    case PCSC_E_SHARING_VIOLATION:   rc = SW_HOST_LOCKING_FAILED; break;\n    case PCSC_E_NO_SMARTCARD:        rc = SW_HOST_NO_CARD; break;\n    case PCSC_W_REMOVED_CARD:        rc = SW_HOST_NO_CARD; break;\n\n    case PCSC_E_INVALID_TARGET:\n    case PCSC_E_INVALID_VALUE:\n    case PCSC_E_INVALID_HANDLE:\n    case PCSC_E_INVALID_PARAMETER:\n    case PCSC_E_INSUFFICIENT_BUFFER: rc = SW_HOST_INV_VALUE; break;\n\n    default:  rc = SW_HOST_GENERAL_ERROR; break;\n    }\n\n  return rc;\n}\n\nstatic void\ndump_pcsc_reader_status (int slot)\n{\n  if (reader_table[slot].pcsc.card)\n    {\n      log_info (\"reader slot %d: active protocol:\", slot);\n      if ((reader_table[slot].pcsc.protocol & PCSC_PROTOCOL_T0))\n        log_printf (\" T0\");\n      else if ((reader_table[slot].pcsc.protocol & PCSC_PROTOCOL_T1))\n        log_printf (\" T1\");\n      else if ((reader_table[slot].pcsc.protocol & PCSC_PROTOCOL_RAW))\n        log_printf (\" raw\");\n      log_printf (\"\\n\");\n    }\n  else\n    log_info (\"reader slot %d: not connected\\n\", slot);\n}\n\n\nstatic int\npcsc_get_status (int slot, unsigned int *status, int on_wire)\n{\n  long err;\n  struct pcsc_readerstate_s rdrstates[1];\n\n  (void)on_wire;\n  memset (rdrstates, 0, sizeof *rdrstates);\n  rdrstates[0].reader = reader_table[slot].rdrname;\n  rdrstates[0].current_state = reader_table[slot].pcsc.current_state;\n  err = pcsc_get_status_change (reader_table[slot].pcsc.context,\n                                0,\n                                rdrstates, 1);\n  if (err == PCSC_E_TIMEOUT)\n    err = 0; /* Timeout is no error here.  */\n  if (err)\n    {\n      log_error (\"pcsc_get_status_change failed: %s (0x%lx)\\n\",\n                 pcsc_error_string (err), err);\n      return pcsc_error_to_sw (err);\n    }\n\n  if ((rdrstates[0].event_state & PCSC_STATE_CHANGED))\n    reader_table[slot].pcsc.current_state =\n      (rdrstates[0].event_state & ~PCSC_STATE_CHANGED);\n\n  if (DBG_CARD_IO)\n    log_debug\n      (\"pcsc_get_status_change: %s%s%s%s%s%s%s%s%s%s\\n\",\n       (rdrstates[0].event_state & PCSC_STATE_IGNORE)? \" ignore\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_CHANGED)? \" changed\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_UNKNOWN)? \" unknown\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_UNAVAILABLE)?\" unavail\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_EMPTY)? \" empty\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_PRESENT)? \" present\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_ATRMATCH)? \" atr\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_EXCLUSIVE)? \" excl\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_INUSE)? \" inuse\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_MUTE)? \" mute\":\"\" );\n\n  *status = 0;\n  if ( (reader_table[slot].pcsc.current_state & PCSC_STATE_PRESENT) )\n    {\n      *status |= APDU_CARD_PRESENT;\n      if ( !(reader_table[slot].pcsc.current_state & PCSC_STATE_MUTE) )\n        *status |= APDU_CARD_ACTIVE;\n    }\n#ifndef HAVE_W32_SYSTEM\n  /* We indicate a useful card if it is not in use by another\n     application.  This is because we only use exclusive access\n     mode.  */\n  if ( (*status & (APDU_CARD_PRESENT|APDU_CARD_ACTIVE))\n       == (APDU_CARD_PRESENT|APDU_CARD_ACTIVE)\n       && !(reader_table[slot].pcsc.current_state & PCSC_STATE_INUSE) )\n    *status |= APDU_CARD_USABLE;\n#else\n  /* Some winscard drivers may set EXCLUSIVE and INUSE at the same\n     time when we are the only user (SCM SCR335) under Windows.  */\n  if ((*status & (APDU_CARD_PRESENT|APDU_CARD_ACTIVE))\n      == (APDU_CARD_PRESENT|APDU_CARD_ACTIVE))\n    *status |= APDU_CARD_USABLE;\n#endif\n\n  if (!on_wire && (rdrstates[0].event_state & PCSC_STATE_CHANGED))\n    /* Event like sleep/resume occurs, which requires RESET.  */\n    return SW_HOST_NO_READER;\n  else\n    return 0;\n}\n\n\n/* Send the APDU of length APDULEN to SLOT and return a maximum of\n   *BUFLEN data in BUFFER, the actual returned size will be stored at\n   BUFLEN.  Returns: A status word. */\nstatic int\npcsc_send_apdu (int slot, unsigned char *apdu, size_t apdulen,\n                unsigned char *buffer, size_t *buflen,\n                pininfo_t *pininfo)\n{\n  long err;\n  struct pcsc_io_request_s send_pci;\n  pcsc_dword_t recv_len;\n\n  (void)pininfo;\n\n  if (!reader_table[slot].atrlen\n      && (err = reset_pcsc_reader (slot)))\n    return err;\n\n  if (DBG_CARD_IO)\n    log_printhex (\"  PCSC_data:\", apdu, apdulen);\n\n  if ((reader_table[slot].pcsc.protocol & PCSC_PROTOCOL_T1))\n      send_pci.protocol = PCSC_PROTOCOL_T1;\n  else\n      send_pci.protocol = PCSC_PROTOCOL_T0;\n  send_pci.pci_len = sizeof send_pci;\n  recv_len = *buflen;\n  err = pcsc_transmit (reader_table[slot].pcsc.card,\n                       &send_pci, apdu, apdulen,\n                       NULL, buffer, &recv_len);\n  *buflen = recv_len;\n  if (err)\n    log_error (\"pcsc_transmit failed: %s (0x%lx)\\n\",\n               pcsc_error_string (err), err);\n\n  /* Handle fatal errors which require shutdown of reader.  */\n  if (err == PCSC_E_NOT_TRANSACTED || err == PCSC_W_RESET_CARD\n      || err == PCSC_W_REMOVED_CARD)\n    {\n      reader_table[slot].pcsc.current_state = PCSC_STATE_UNAWARE;\n      scd_kick_the_loop ();\n    }\n\n  return pcsc_error_to_sw (err);\n}\n\n\n/* Do some control with the value of IOCTL_CODE to the card inserted\n   to SLOT.  Input buffer is specified by CNTLBUF of length LEN.\n   Output buffer is specified by BUFFER of length *BUFLEN, and the\n   actual output size will be stored at BUFLEN.  Returns: A status word.\n   This routine is used for PIN pad input support.  */\nstatic int\ncontrol_pcsc (int slot, pcsc_dword_t ioctl_code,\n              const unsigned char *cntlbuf, size_t len,\n              unsigned char *buffer, pcsc_dword_t *buflen)\n{\n  long err;\n\n  err = pcsc_control (reader_table[slot].pcsc.card, ioctl_code,\n                      cntlbuf, len, buffer, buflen? *buflen:0, buflen);\n  if (err)\n    {\n      log_error (\"pcsc_control failed: %s (0x%lx)\\n\",\n                 pcsc_error_string (err), err);\n      return pcsc_error_to_sw (err);\n    }\n\n  return 0;\n}\n\n\nstatic int\nclose_pcsc_reader (int slot)\n{\n  pcsc_release_context (reader_table[slot].pcsc.context);\n  return 0;\n}\n\n\n/* Connect a PC/SC card.  */\nstatic int\nconnect_pcsc_card (int slot)\n{\n  long err;\n\n  assert (slot >= 0 && slot < MAX_READER);\n\n  if (reader_table[slot].pcsc.card)\n    return SW_HOST_ALREADY_CONNECTED;\n\n  reader_table[slot].atrlen = 0;\n  reader_table[slot].is_t0 = 0;\n\n  err = pcsc_connect (reader_table[slot].pcsc.context,\n                      reader_table[slot].rdrname,\n                      PCSC_SHARE_EXCLUSIVE,\n                      PCSC_PROTOCOL_T0|PCSC_PROTOCOL_T1,\n                      &reader_table[slot].pcsc.card,\n                      &reader_table[slot].pcsc.protocol);\n  if (err)\n    {\n      reader_table[slot].pcsc.card = 0;\n      if (err != PCSC_E_NO_SMARTCARD)\n        log_error (\"pcsc_connect failed: %s (0x%lx)\\n\",\n                   pcsc_error_string (err), err);\n    }\n  else\n    {\n      char reader[250];\n      pcsc_dword_t readerlen, atrlen;\n      pcsc_dword_t card_state, card_protocol;\n\n      pcsc_vendor_specific_init (slot);\n\n      atrlen = DIM (reader_table[0].atr);\n      readerlen = sizeof reader -1 ;\n      err = pcsc_status (reader_table[slot].pcsc.card,\n                         reader, &readerlen,\n                         &card_state, &card_protocol,\n                         reader_table[slot].atr, &atrlen);\n      if (err)\n        log_error (\"pcsc_status failed: %s (0x%lx) %lu\\n\",\n                   pcsc_error_string (err), err, (long unsigned int)readerlen);\n      else\n        {\n          if (atrlen > DIM (reader_table[0].atr))\n            log_bug (\"ATR returned by pcsc_status is too large\\n\");\n          reader_table[slot].atrlen = atrlen;\n          reader_table[slot].is_t0 = !!(card_protocol & PCSC_PROTOCOL_T0);\n        }\n    }\n\n  dump_reader_status (slot);\n  return pcsc_error_to_sw (err);\n}\n\n\nstatic int\ndisconnect_pcsc_card (int slot)\n{\n  long err;\n\n  assert (slot >= 0 && slot < MAX_READER);\n\n  if (!reader_table[slot].pcsc.card)\n    return 0;\n\n  err = pcsc_disconnect (reader_table[slot].pcsc.card, PCSC_LEAVE_CARD);\n  if (err)\n    {\n      log_error (\"pcsc_disconnect failed: %s (0x%lx)\\n\",\n                 pcsc_error_string (err), err);\n      return SW_HOST_CARD_IO_ERROR;\n    }\n  reader_table[slot].pcsc.card = 0;\n  return 0;\n}\n\n\n/* Send an PC/SC reset command and return a status word on error or 0\n   on success. */\nstatic int\nreset_pcsc_reader (int slot)\n{\n  int sw;\n\n  sw = disconnect_pcsc_card (slot);\n  if (!sw)\n    sw = connect_pcsc_card (slot);\n\n  return sw;\n}\n\n\n/* Examine reader specific parameters and initialize.  This is mostly\n   for pinpad input.  Called at opening the connection to the reader.  */\nstatic int\npcsc_vendor_specific_init (int slot)\n{\n  unsigned char buf[256];\n  pcsc_dword_t len;\n  int sw;\n  int vendor = 0;\n  int product = 0;\n  pcsc_dword_t get_tlv_ioctl = (pcsc_dword_t)-1;\n  unsigned char *p;\n\n  len = sizeof (buf);\n  sw = control_pcsc (slot, CM_IOCTL_GET_FEATURE_REQUEST, NULL, 0, buf, &len);\n  if (sw)\n    {\n      log_error (\"pcsc_vendor_specific_init: GET_FEATURE_REQUEST failed: %d\\n\",\n                 sw);\n      return SW_NOT_SUPPORTED;\n    }\n  else\n    {\n      p = buf;\n      while (p < buf + len)\n        {\n          unsigned char code = *p++;\n          int l = *p++;\n          unsigned int v = 0;\n\n          if (l == 1)\n            v = p[0];\n          else if (l == 2)\n            v = buf16_to_uint (p);\n          else if (l == 4)\n            v = buf32_to_uint (p);\n\n          if (code == FEATURE_VERIFY_PIN_DIRECT)\n            reader_table[slot].pcsc.verify_ioctl = v;\n          else if (code == FEATURE_MODIFY_PIN_DIRECT)\n            reader_table[slot].pcsc.modify_ioctl = v;\n          else if (code == FEATURE_GET_TLV_PROPERTIES)\n            get_tlv_ioctl = v;\n\n          if (DBG_CARD_IO)\n            log_debug (\"feature: code=%02X, len=%d, v=%02X\\n\", code, l, v);\n\n          p += l;\n        }\n    }\n\n  if (get_tlv_ioctl == (pcsc_dword_t)-1)\n    {\n      /*\n       * For system which doesn't support GET_TLV_PROPERTIES,\n       * we put some heuristics here.\n       */\n      if (reader_table[slot].rdrname)\n        {\n          if (strstr (reader_table[slot].rdrname, \"SPRx32\"))\n            {\n              reader_table[slot].is_spr532 = 1;\n              reader_table[slot].pinpad_varlen_supported = 1;\n            }\n          else if (strstr (reader_table[slot].rdrname, \"ST-2xxx\"))\n            {\n              reader_table[slot].pcsc.pinmax = 15;\n              reader_table[slot].pinpad_varlen_supported = 1;\n            }\n          else if (strstr (reader_table[slot].rdrname, \"cyberJack\")\n                   || strstr (reader_table[slot].rdrname, \"DIGIPASS\")\n                   || strstr (reader_table[slot].rdrname, \"Gnuk\")\n                   || strstr (reader_table[slot].rdrname, \"KAAN\")\n                   || strstr (reader_table[slot].rdrname, \"Trustica\"))\n            reader_table[slot].pinpad_varlen_supported = 1;\n        }\n\n      return 0;\n    }\n\n  len = sizeof (buf);\n  sw = control_pcsc (slot, get_tlv_ioctl, NULL, 0, buf, &len);\n  if (sw)\n    {\n      log_error (\"pcsc_vendor_specific_init: GET_TLV_IOCTL failed: %d\\n\", sw);\n      return SW_NOT_SUPPORTED;\n    }\n\n  p = buf;\n  while (p < buf + len)\n    {\n      unsigned char tag = *p++;\n      int l = *p++;\n      unsigned int v = 0;\n\n      /* Umm... here is little endian, while the encoding above is big.  */\n      if (l == 1)\n        v = p[0];\n      else if (l == 2)\n        v = (((unsigned int)p[1] << 8) | p[0]);\n      else if (l == 4)\n        v = (((unsigned int)p[3] << 24) | (p[2] << 16) | (p[1] << 8) | p[0]);\n\n      if (tag == PCSCv2_PART10_PROPERTY_bMinPINSize)\n        reader_table[slot].pcsc.pinmin = v;\n      else if (tag == PCSCv2_PART10_PROPERTY_bMaxPINSize)\n        reader_table[slot].pcsc.pinmax = v;\n      else if (tag == PCSCv2_PART10_PROPERTY_wIdVendor)\n        vendor = v;\n      else if (tag == PCSCv2_PART10_PROPERTY_wIdProduct)\n        product = v;\n\n      if (DBG_CARD_IO)\n        log_debug (\"TLV properties: tag=%02X, len=%d, v=%08X\\n\", tag, l, v);\n\n      p += l;\n    }\n\n  if (vendor == VENDOR_VEGA && product == VEGA_ALPHA)\n    {\n      /*\n       * Please read the comment of ccid_vendor_specific_init in\n       * ccid-driver.c.\n       */\n      const unsigned char cmd[] = { '\\xb5', '\\x01', '\\x00', '\\x03', '\\x00' };\n      sw = control_pcsc (slot, CM_IOCTL_VENDOR_IFD_EXCHANGE,\n                         cmd, sizeof (cmd), NULL, 0);\n      if (sw)\n        return SW_NOT_SUPPORTED;\n    }\n  else if (vendor == VENDOR_SCM && product == SCM_SPR532) /* SCM SPR532 */\n    {\n      reader_table[slot].is_spr532 = 1;\n      reader_table[slot].pinpad_varlen_supported = 1;\n    }\n  else if (vendor == 0x046a)\n    {\n      /* Cherry ST-2xxx (product == 0x003e) supports TPDU level\n       * exchange.  Other products which only support short APDU level\n       * exchange only work with shorter keys like RSA 1024.\n       */\n      reader_table[slot].pcsc.pinmax = 15;\n      reader_table[slot].pinpad_varlen_supported = 1;\n    }\n  else if (vendor == 0x0c4b /* Tested with Reiner cyberJack GO */\n           || vendor == 0x1a44 /* Tested with Vasco DIGIPASS 920 */\n           || vendor == 0x234b /* Tested with FSIJ Gnuk Token */\n           || vendor == 0x0d46 /* Tested with KAAN Advanced??? */\n           || (vendor == 0x1fc9 && product == 0x81e6) /* Tested with Trustica Cryptoucan */)\n    reader_table[slot].pinpad_varlen_supported = 1;\n\n  return 0;\n}\n\n\n/* Open the PC/SC reader without using the wrapper.  Returns -1 on\n   error or a slot number for the reader.  */\nstatic int\nopen_pcsc_reader (const char *portstr)\n{\n  long err;\n  int slot;\n  char *list = NULL;\n  char *rdrname = NULL;\n  pcsc_dword_t nreader;\n  char *p;\n\n  slot = new_reader_slot ();\n  if (slot == -1)\n    return -1;\n\n  /* Fixme: Allocating a context for each slot is not required.  One\n     global context should be sufficient.  */\n  err = pcsc_establish_context (PCSC_SCOPE_SYSTEM, NULL, NULL,\n                                &reader_table[slot].pcsc.context);\n  if (err)\n    {\n      log_error (\"pcsc_establish_context failed: %s (0x%lx)\\n\",\n                 pcsc_error_string (err), err);\n      reader_table[slot].used = 0;\n      unlock_slot (slot);\n      return -1;\n    }\n\n  err = pcsc_list_readers (reader_table[slot].pcsc.context,\n                           NULL, NULL, &nreader);\n  if (!err)\n    {\n      list = xtrymalloc (nreader+1); /* Better add 1 for safety reasons. */\n      if (!list)\n        {\n          log_error (\"error allocating memory for reader list\\n\");\n          pcsc_release_context (reader_table[slot].pcsc.context);\n          reader_table[slot].used = 0;\n          unlock_slot (slot);\n          return -1 /*SW_HOST_OUT_OF_CORE*/;\n        }\n      err = pcsc_list_readers (reader_table[slot].pcsc.context,\n                               NULL, list, &nreader);\n    }\n  if (err)\n    {\n      log_error (\"pcsc_list_readers failed: %s (0x%lx)\\n\",\n                 pcsc_error_string (err), err);\n      pcsc_release_context (reader_table[slot].pcsc.context);\n      reader_table[slot].used = 0;\n      xfree (list);\n      unlock_slot (slot);\n      return -1;\n    }\n\n  p = list;\n  while (nreader)\n    {\n      if (!*p && !p[1])\n        break;\n      log_info (\"detected reader '%s'\\n\", p);\n      if (nreader < (strlen (p)+1))\n        {\n          log_error (\"invalid response from pcsc_list_readers\\n\");\n          break;\n        }\n      if (!rdrname && portstr && !strncmp (p, portstr, strlen (portstr)))\n        rdrname = p;\n      nreader -= strlen (p)+1;\n      p += strlen (p) + 1;\n    }\n\n  if (!rdrname)\n    rdrname = list;\n\n  reader_table[slot].rdrname = xtrystrdup (rdrname);\n  if (!reader_table[slot].rdrname)\n    {\n      log_error (\"error allocating memory for reader name\\n\");\n      pcsc_release_context (reader_table[slot].pcsc.context);\n      reader_table[slot].used = 0;\n      unlock_slot (slot);\n      return -1;\n    }\n  xfree (list);\n  list = NULL;\n\n  reader_table[slot].pcsc.card = 0;\n  reader_table[slot].atrlen = 0;\n\n  reader_table[slot].connect_card = connect_pcsc_card;\n  reader_table[slot].disconnect_card = disconnect_pcsc_card;\n  reader_table[slot].close_reader = close_pcsc_reader;\n  reader_table[slot].reset_reader = reset_pcsc_reader;\n  reader_table[slot].get_status_reader = pcsc_get_status;\n  reader_table[slot].send_apdu_reader = pcsc_send_apdu;\n  reader_table[slot].dump_status_reader = dump_pcsc_reader_status;\n\n  dump_reader_status (slot);\n  unlock_slot (slot);\n  return slot;\n}\n\n\n/* Check whether the reader supports the ISO command code COMMAND\n   on the pinpad.  Return 0 on success.  */\nstatic int\ncheck_pcsc_pinpad (int slot, int command, pininfo_t *pininfo)\n{\n  int r;\n\n  if (reader_table[slot].pcsc.pinmin >= 0)\n    pininfo->minlen = reader_table[slot].pcsc.pinmin;\n\n  if (reader_table[slot].pcsc.pinmax >= 0)\n    pininfo->maxlen = reader_table[slot].pcsc.pinmax;\n\n  if (!pininfo->minlen)\n    pininfo->minlen = 1;\n  if (!pininfo->maxlen)\n    pininfo->maxlen = 15;\n\n  if ((command == ISO7816_VERIFY && reader_table[slot].pcsc.verify_ioctl != 0)\n      || (command == ISO7816_CHANGE_REFERENCE_DATA\n          && reader_table[slot].pcsc.modify_ioctl != 0))\n    r = 0;                       /* Success */\n  else\n    r = SW_NOT_SUPPORTED;\n\n  if (DBG_CARD_IO)\n    log_debug (\"check_pcsc_pinpad: command=%02X, r=%d\\n\",\n               (unsigned int)command, r);\n\n  if (reader_table[slot].pinpad_varlen_supported)\n    pininfo->fixedlen = 0;\n\n  return r;\n}\n\n#define PIN_VERIFY_STRUCTURE_SIZE 24\nstatic int\npcsc_pinpad_verify (int slot, int class, int ins, int p0, int p1,\n                    pininfo_t *pininfo)\n{\n  int sw;\n  unsigned char *pin_verify;\n  int len = PIN_VERIFY_STRUCTURE_SIZE + pininfo->fixedlen;\n  /*\n   * The result buffer is only expected to have two-byte result on\n   * return.  However, some implementation uses this buffer for lower\n   * layer too and it assumes that there is enough space for lower\n   * layer communication.  Such an implementation fails for TPDU\n   * readers with \"insufficient buffer\", as it needs header and\n   * trailer.  Six is the number for header + result + trailer (TPDU).\n   */\n  unsigned char result[6];\n  pcsc_dword_t resultlen = 6;\n  int no_lc;\n\n  if (!reader_table[slot].atrlen\n      && (sw = reset_pcsc_reader (slot)))\n    return sw;\n\n  if (pininfo->fixedlen < 0 || pininfo->fixedlen >= 16)\n    return SW_NOT_SUPPORTED;\n\n  pin_verify = xtrymalloc (len);\n  if (!pin_verify)\n    return SW_HOST_OUT_OF_CORE;\n\n  no_lc = (!pininfo->fixedlen && reader_table[slot].is_spr532);\n\n  pin_verify[0] = 0x00; /* bTimeOut */\n  pin_verify[1] = 0x00; /* bTimeOut2 */\n  pin_verify[2] = 0x82; /* bmFormatString: Byte, pos=0, left, ASCII. */\n  pin_verify[3] = pininfo->fixedlen; /* bmPINBlockString */\n  pin_verify[4] = 0x00; /* bmPINLengthFormat */\n  pin_verify[5] = pininfo->maxlen; /* wPINMaxExtraDigit */\n  pin_verify[6] = pininfo->minlen; /* wPINMaxExtraDigit */\n  pin_verify[7] = 0x02; /* bEntryValidationCondition: Validation key pressed */\n  if (pininfo->minlen && pininfo->maxlen && pininfo->minlen == pininfo->maxlen)\n    pin_verify[7] |= 0x01; /* Max size reached.  */\n  pin_verify[8] = 0x01; /* bNumberMessage: One message */\n  pin_verify[9] =  0x09; /* wLangId: 0x0409: US English */\n  pin_verify[10] = 0x04; /* wLangId: 0x0409: US English */\n  pin_verify[11] = 0x00; /* bMsgIndex */\n  pin_verify[12] = 0x00; /* bTeoPrologue[0] */\n  pin_verify[13] = 0x00; /* bTeoPrologue[1] */\n  pin_verify[14] = pininfo->fixedlen + 0x05 - no_lc; /* bTeoPrologue[2] */\n  pin_verify[15] = pininfo->fixedlen + 0x05 - no_lc; /* ulDataLength */\n  pin_verify[16] = 0x00; /* ulDataLength */\n  pin_verify[17] = 0x00; /* ulDataLength */\n  pin_verify[18] = 0x00; /* ulDataLength */\n  pin_verify[19] = class; /* abData[0] */\n  pin_verify[20] = ins; /* abData[1] */\n  pin_verify[21] = p0; /* abData[2] */\n  pin_verify[22] = p1; /* abData[3] */\n  pin_verify[23] = pininfo->fixedlen; /* abData[4] */\n  if (pininfo->fixedlen)\n    memset (&pin_verify[24], 0xff, pininfo->fixedlen);\n  else if (no_lc)\n    len--;\n\n  if (DBG_CARD_IO)\n    log_debug (\"send secure: c=%02X i=%02X p1=%02X p2=%02X len=%d pinmax=%d\\n\",\n               class, ins, p0, p1, len, pininfo->maxlen);\n\n  sw = control_pcsc (slot, reader_table[slot].pcsc.verify_ioctl,\n                     pin_verify, len, result, &resultlen);\n  xfree (pin_verify);\n  if (sw || resultlen < 2)\n    {\n      log_error (\"control_pcsc failed: %d\\n\", sw);\n      return sw? sw: SW_HOST_INCOMPLETE_CARD_RESPONSE;\n    }\n  sw = (result[resultlen-2] << 8) | result[resultlen-1];\n  if (DBG_CARD_IO)\n    log_debug (\" response: sw=%04X  datalen=%d\\n\", sw, (unsigned int)resultlen);\n  return sw;\n}\n\n\n#define PIN_MODIFY_STRUCTURE_SIZE 29\nstatic int\npcsc_pinpad_modify (int slot, int class, int ins, int p0, int p1,\n                    pininfo_t *pininfo)\n{\n  int sw;\n  unsigned char *pin_modify;\n  int len = PIN_MODIFY_STRUCTURE_SIZE + 2 * pininfo->fixedlen;\n  unsigned char result[6];      /* See the comment at pinpad_verify.  */\n  pcsc_dword_t resultlen = 6;\n  int no_lc;\n\n  if (!reader_table[slot].atrlen\n      && (sw = reset_pcsc_reader (slot)))\n    return sw;\n\n  if (pininfo->fixedlen < 0 || pininfo->fixedlen >= 16)\n    return SW_NOT_SUPPORTED;\n\n  pin_modify = xtrymalloc (len);\n  if (!pin_modify)\n    return SW_HOST_OUT_OF_CORE;\n\n  no_lc = (!pininfo->fixedlen && reader_table[slot].is_spr532);\n\n  pin_modify[0] = 0x00; /* bTimeOut */\n  pin_modify[1] = 0x00; /* bTimeOut2 */\n  pin_modify[2] = 0x82; /* bmFormatString: Byte, pos=0, left, ASCII. */\n  pin_modify[3] = pininfo->fixedlen; /* bmPINBlockString */\n  pin_modify[4] = 0x00; /* bmPINLengthFormat */\n  pin_modify[5] = 0x00; /* bInsertionOffsetOld */\n  pin_modify[6] = pininfo->fixedlen; /* bInsertionOffsetNew */\n  pin_modify[7] = pininfo->maxlen; /* wPINMaxExtraDigit */\n  pin_modify[8] = pininfo->minlen; /* wPINMaxExtraDigit */\n  pin_modify[9] = (p0 == 0 ? 0x03 : 0x01);\n                  /* bConfirmPIN\n                   *    0x00: new PIN once\n                   *    0x01: new PIN twice (confirmation)\n                   *    0x02: old PIN and new PIN once\n                   *    0x03: old PIN and new PIN twice (confirmation)\n                   */\n  pin_modify[10] = 0x02; /* bEntryValidationCondition: Validation key pressed */\n  if (pininfo->minlen && pininfo->maxlen && pininfo->minlen == pininfo->maxlen)\n    pin_modify[10] |= 0x01; /* Max size reached.  */\n  pin_modify[11] = 0x03; /* bNumberMessage: Three messages */\n  pin_modify[12] = 0x09; /* wLangId: 0x0409: US English */\n  pin_modify[13] = 0x04; /* wLangId: 0x0409: US English */\n  pin_modify[14] = 0x00; /* bMsgIndex1 */\n  pin_modify[15] = 0x01; /* bMsgIndex2 */\n  pin_modify[16] = 0x02; /* bMsgIndex3 */\n  pin_modify[17] = 0x00; /* bTeoPrologue[0] */\n  pin_modify[18] = 0x00; /* bTeoPrologue[1] */\n  pin_modify[19] = 2 * pininfo->fixedlen + 0x05 - no_lc; /* bTeoPrologue[2] */\n  pin_modify[20] = 2 * pininfo->fixedlen + 0x05 - no_lc; /* ulDataLength */\n  pin_modify[21] = 0x00; /* ulDataLength */\n  pin_modify[22] = 0x00; /* ulDataLength */\n  pin_modify[23] = 0x00; /* ulDataLength */\n  pin_modify[24] = class; /* abData[0] */\n  pin_modify[25] = ins; /* abData[1] */\n  pin_modify[26] = p0; /* abData[2] */\n  pin_modify[27] = p1; /* abData[3] */\n  pin_modify[28] = 2 * pininfo->fixedlen; /* abData[4] */\n  if (pininfo->fixedlen)\n    memset (&pin_modify[29], 0xff, 2 * pininfo->fixedlen);\n  else if (no_lc)\n    len--;\n\n  if (DBG_CARD_IO)\n    log_debug (\"send secure: c=%02X i=%02X p1=%02X p2=%02X len=%d pinmax=%d\\n\",\n               class, ins, p0, p1, len, (int)pininfo->maxlen);\n\n  sw = control_pcsc (slot, reader_table[slot].pcsc.modify_ioctl,\n                     pin_modify, len, result, &resultlen);\n  xfree (pin_modify);\n  if (sw || resultlen < 2)\n    {\n      log_error (\"control_pcsc failed: %d\\n\", sw);\n      return sw? sw : SW_HOST_INCOMPLETE_CARD_RESPONSE;\n    }\n  sw = (result[resultlen-2] << 8) | result[resultlen-1];\n  if (DBG_CARD_IO)\n    log_debug (\" response: sw=%04X  datalen=%d\\n\", sw, (unsigned int)resultlen);\n  return sw;\n}\n\f\n#ifdef HAVE_LIBUSB\n/*\n     Internal CCID driver interface.\n */\n\n\nstatic void\ndump_ccid_reader_status (int slot)\n{\n  log_info (\"reader slot %d: using ccid driver\\n\", slot);\n}\n\nstatic int\nclose_ccid_reader (int slot)\n{\n  ccid_close_reader (reader_table[slot].ccid.handle);\n  return 0;\n}\n\n\nstatic int\nreset_ccid_reader (int slot)\n{\n  int err;\n  reader_table_t slotp = reader_table + slot;\n  unsigned char atr[33];\n  size_t atrlen;\n\n  err = ccid_get_atr (slotp->ccid.handle, atr, sizeof atr, &atrlen);\n  if (err)\n    return err;\n  /* If the reset was successful, update the ATR. */\n  assert (sizeof slotp->atr >= sizeof atr);\n  slotp->atrlen = atrlen;\n  memcpy (slotp->atr, atr, atrlen);\n  dump_reader_status (slot);\n  return 0;\n}\n\n\nstatic int\nset_progress_cb_ccid_reader (int slot, gcry_handler_progress_t cb, void *cb_arg)\n{\n  reader_table_t slotp = reader_table + slot;\n\n  return ccid_set_progress_cb (slotp->ccid.handle, cb, cb_arg);\n}\n\nstatic int\nset_prompt_cb_ccid_reader (int slot, void (*cb) (void *, int ), void *cb_arg)\n{\n  reader_table_t slotp = reader_table + slot;\n\n  return ccid_set_prompt_cb (slotp->ccid.handle, cb, cb_arg);\n}\n\n\nstatic int\nget_status_ccid (int slot, unsigned int *status, int on_wire)\n{\n  int rc;\n  int bits;\n\n  rc = ccid_slot_status (reader_table[slot].ccid.handle, &bits, on_wire);\n  if (rc)\n    return rc;\n\n  if (bits == 0)\n    *status = (APDU_CARD_USABLE|APDU_CARD_PRESENT|APDU_CARD_ACTIVE);\n  else if (bits == 1)\n    *status = APDU_CARD_PRESENT;\n  else\n    *status = 0;\n\n  return 0;\n}\n\n\n/* Actually send the APDU of length APDULEN to SLOT and return a\n   maximum of *BUFLEN data in BUFFER, the actual returned size will be\n   set to BUFLEN.  Returns: Internal CCID driver error code. */\nstatic int\nsend_apdu_ccid (int slot, unsigned char *apdu, size_t apdulen,\n                unsigned char *buffer, size_t *buflen,\n                pininfo_t *pininfo)\n{\n  long err;\n  size_t maxbuflen;\n\n  /* If we don't have an ATR, we need to reset the reader first. */\n  if (!reader_table[slot].atrlen\n      && (err = reset_ccid_reader (slot)))\n    return err;\n\n  if (DBG_CARD_IO)\n    log_printhex (\" raw apdu:\", apdu, apdulen);\n\n  maxbuflen = *buflen;\n  if (pininfo)\n    err = ccid_transceive_secure (reader_table[slot].ccid.handle,\n                                  apdu, apdulen, pininfo,\n                                  buffer, maxbuflen, buflen);\n  else\n    err = ccid_transceive (reader_table[slot].ccid.handle,\n                           apdu, apdulen,\n                           buffer, maxbuflen, buflen);\n  if (err)\n    log_error (\"ccid_transceive failed: (0x%lx)\\n\",\n               err);\n\n  return err;\n}\n\n\n/* Check whether the CCID reader supports the ISO command code COMMAND\n   on the pinpad.  Return 0 on success.  For a description of the pin\n   parameters, see ccid-driver.c */\nstatic int\ncheck_ccid_pinpad (int slot, int command, pininfo_t *pininfo)\n{\n  unsigned char apdu[] = { 0, 0, 0, 0x81 };\n\n  apdu[1] = command;\n  return ccid_transceive_secure (reader_table[slot].ccid.handle, apdu,\n                                 sizeof apdu, pininfo, NULL, 0, NULL);\n}\n\n\nstatic int\nccid_pinpad_operation (int slot, int class, int ins, int p0, int p1,\n                       pininfo_t *pininfo)\n{\n  unsigned char apdu[4];\n  int err, sw;\n  unsigned char result[2];\n  size_t resultlen = 2;\n\n  apdu[0] = class;\n  apdu[1] = ins;\n  apdu[2] = p0;\n  apdu[3] = p1;\n  err = ccid_transceive_secure (reader_table[slot].ccid.handle,\n                                apdu, sizeof apdu, pininfo,\n                                result, 2, &resultlen);\n  if (err)\n    return err;\n\n  if (resultlen < 2)\n    return SW_HOST_INCOMPLETE_CARD_RESPONSE;\n\n  sw = (result[resultlen-2] << 8) | result[resultlen-1];\n  return sw;\n}\n\n\n/* Open the reader and try to read an ATR.  */\nstatic int\nopen_ccid_reader (struct dev_list *dl)\n{\n  int err;\n  int slot;\n  int require_get_status;\n  reader_table_t slotp;\n\n  slot = new_reader_slot ();\n  if (slot == -1)\n    return -1;\n  slotp = reader_table + slot;\n\n  err = ccid_open_reader (dl->portstr, dl->idx, dl->ccid_table,\n                          &slotp->ccid.handle, &slotp->rdrname);\n  if (!err)\n    {\n      err = ccid_get_atr (slotp->ccid.handle,\n                          slotp->atr, sizeof slotp->atr, &slotp->atrlen);\n      if (err)\n        ccid_close_reader (slotp->ccid.handle);\n    }\n\n  if (err)\n    {\n      slotp->used = 0;\n      unlock_slot (slot);\n      return -1;\n    }\n\n  require_get_status = ccid_require_get_status (slotp->ccid.handle);\n\n  reader_table[slot].close_reader = close_ccid_reader;\n  reader_table[slot].reset_reader = reset_ccid_reader;\n  reader_table[slot].get_status_reader = get_status_ccid;\n  reader_table[slot].send_apdu_reader = send_apdu_ccid;\n  reader_table[slot].check_pinpad = check_ccid_pinpad;\n  reader_table[slot].dump_status_reader = dump_ccid_reader_status;\n  reader_table[slot].set_progress_cb = set_progress_cb_ccid_reader;\n  reader_table[slot].set_prompt_cb = set_prompt_cb_ccid_reader;\n  reader_table[slot].pinpad_verify = ccid_pinpad_operation;\n  reader_table[slot].pinpad_modify = ccid_pinpad_operation;\n  /* Our CCID reader code does not support T=0 at all, thus reset the\n     flag.  */\n  reader_table[slot].is_t0 = 0;\n  reader_table[slot].require_get_status = require_get_status;\n\n  dump_reader_status (slot);\n  unlock_slot (slot);\n  return slot;\n}\n#endif /* HAVE_LIBUSB */\n\f\n#ifdef USE_G10CODE_RAPDU\n/*\n     The Remote APDU Interface.\n\n     This uses the Remote APDU protocol to contact a reader.\n\n     The port number is actually an index into the list of ports as\n     returned via the protocol.\n */\n\n\nstatic int\nrapdu_status_to_sw (int status)\n{\n  int rc;\n\n  switch (status)\n    {\n    case RAPDU_STATUS_SUCCESS:  rc = 0; break;\n\n    case RAPDU_STATUS_INVCMD:\n    case RAPDU_STATUS_INVPROT:\n    case RAPDU_STATUS_INVSEQ:\n    case RAPDU_STATUS_INVCOOKIE:\n    case RAPDU_STATUS_INVREADER:  rc = SW_HOST_INV_VALUE;  break;\n\n    case RAPDU_STATUS_TIMEOUT:  rc = SW_HOST_CARD_IO_ERROR; break;\n    case RAPDU_STATUS_CARDIO:   rc = SW_HOST_CARD_IO_ERROR; break;\n    case RAPDU_STATUS_NOCARD:   rc = SW_HOST_NO_CARD; break;\n    case RAPDU_STATUS_CARDCHG:  rc = SW_HOST_NO_CARD; break;\n    case RAPDU_STATUS_BUSY:     rc = SW_HOST_BUSY; break;\n    case RAPDU_STATUS_NEEDRESET: rc = SW_HOST_CARD_INACTIVE; break;\n\n    default: rc = SW_HOST_GENERAL_ERROR; break;\n    }\n\n  return rc;\n}\n\n\n\nstatic int\nclose_rapdu_reader (int slot)\n{\n  rapdu_release (reader_table[slot].rapdu.handle);\n  return 0;\n}\n\n\nstatic int\nreset_rapdu_reader (int slot)\n{\n  int err;\n  reader_table_t slotp;\n  rapdu_msg_t msg = NULL;\n\n  slotp = reader_table + slot;\n\n  err = rapdu_send_cmd (slotp->rapdu.handle, RAPDU_CMD_RESET);\n  if (err)\n    {\n      log_error (\"sending rapdu command RESET failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      rapdu_msg_release (msg);\n      return rapdu_status_to_sw (err);\n    }\n  err = rapdu_read_msg (slotp->rapdu.handle, &msg);\n  if (err)\n    {\n      log_error (\"receiving rapdu message failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      rapdu_msg_release (msg);\n      return rapdu_status_to_sw (err);\n    }\n  if (msg->cmd != RAPDU_STATUS_SUCCESS || !msg->datalen)\n    {\n      int sw = rapdu_status_to_sw (msg->cmd);\n      log_error (\"rapdu command RESET failed: %s\\n\",\n                 rapdu_strerror (msg->cmd));\n      rapdu_msg_release (msg);\n      return sw;\n    }\n  if (msg->datalen > DIM (slotp->atr))\n    {\n      log_error (\"ATR returned by the RAPDU layer is too large\\n\");\n      rapdu_msg_release (msg);\n      return SW_HOST_INV_VALUE;\n    }\n  slotp->atrlen = msg->datalen;\n  memcpy (slotp->atr, msg->data, msg->datalen);\n\n  rapdu_msg_release (msg);\n  return 0;\n}\n\n\nstatic int\nmy_rapdu_get_status (int slot, unsigned int *status, int on_wire)\n{\n  int err;\n  reader_table_t slotp;\n  rapdu_msg_t msg = NULL;\n  int oldslot;\n\n  (void)on_wire;\n  slotp = reader_table + slot;\n\n  oldslot = rapdu_set_reader (slotp->rapdu.handle, slot);\n  err = rapdu_send_cmd (slotp->rapdu.handle, RAPDU_CMD_GET_STATUS);\n  rapdu_set_reader (slotp->rapdu.handle, oldslot);\n  if (err)\n    {\n      log_error (\"sending rapdu command GET_STATUS failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      return rapdu_status_to_sw (err);\n    }\n  err = rapdu_read_msg (slotp->rapdu.handle, &msg);\n  if (err)\n    {\n      log_error (\"receiving rapdu message failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      rapdu_msg_release (msg);\n      return rapdu_status_to_sw (err);\n    }\n  if (msg->cmd != RAPDU_STATUS_SUCCESS || !msg->datalen)\n    {\n      int sw = rapdu_status_to_sw (msg->cmd);\n      log_error (\"rapdu command GET_STATUS failed: %s\\n\",\n                 rapdu_strerror (msg->cmd));\n      rapdu_msg_release (msg);\n      return sw;\n    }\n  *status = msg->data[0];\n\n  rapdu_msg_release (msg);\n  return 0;\n}\n\n\n/* Actually send the APDU of length APDULEN to SLOT and return a\n   maximum of *BUFLEN data in BUFFER, the actual returned size will be\n   set to BUFLEN.  Returns: APDU error code. */\nstatic int\nmy_rapdu_send_apdu (int slot, unsigned char *apdu, size_t apdulen,\n                    unsigned char *buffer, size_t *buflen,\n                    pininfo_t *pininfo)\n{\n  int err;\n  reader_table_t slotp;\n  rapdu_msg_t msg = NULL;\n  size_t maxlen = *buflen;\n\n  slotp = reader_table + slot;\n\n  *buflen = 0;\n  if (DBG_CARD_IO)\n    log_printhex (\"  APDU_data:\", apdu, apdulen);\n\n  if (apdulen < 4)\n    {\n      log_error (\"rapdu_send_apdu: APDU is too short\\n\");\n      return SW_HOST_INV_VALUE;\n    }\n\n  err = rapdu_send_apdu (slotp->rapdu.handle, apdu, apdulen);\n  if (err)\n    {\n      log_error (\"sending rapdu command APDU failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      rapdu_msg_release (msg);\n      return rapdu_status_to_sw (err);\n    }\n  err = rapdu_read_msg (slotp->rapdu.handle, &msg);\n  if (err)\n    {\n      log_error (\"receiving rapdu message failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      rapdu_msg_release (msg);\n      return rapdu_status_to_sw (err);\n    }\n  if (msg->cmd != RAPDU_STATUS_SUCCESS || !msg->datalen)\n    {\n      int sw = rapdu_status_to_sw (msg->cmd);\n      log_error (\"rapdu command APDU failed: %s\\n\",\n                 rapdu_strerror (msg->cmd));\n      rapdu_msg_release (msg);\n      return sw;\n    }\n\n  if (msg->datalen > maxlen)\n    {\n      log_error (\"rapdu response apdu too large\\n\");\n      rapdu_msg_release (msg);\n      return SW_HOST_INV_VALUE;\n    }\n\n  *buflen = msg->datalen;\n  memcpy (buffer, msg->data, msg->datalen);\n\n  rapdu_msg_release (msg);\n  return 0;\n}\n\nstatic int\nopen_rapdu_reader (int portno,\n                   const unsigned char *cookie, size_t length,\n                   int (*readfnc) (void *opaque,\n                                   void *buffer, size_t size),\n                   void *readfnc_value,\n                   int (*writefnc) (void *opaque,\n                                    const void *buffer, size_t size),\n                   void *writefnc_value,\n                   void (*closefnc) (void *opaque),\n                   void *closefnc_value)\n{\n  int err;\n  int slot;\n  reader_table_t slotp;\n  rapdu_msg_t msg = NULL;\n\n  slot = new_reader_slot ();\n  if (slot == -1)\n    return -1;\n  slotp = reader_table + slot;\n\n  slotp->rapdu.handle = rapdu_new ();\n  if (!slotp->rapdu.handle)\n    {\n      slotp->used = 0;\n      unlock_slot (slot);\n      return -1;\n    }\n\n  rapdu_set_reader (slotp->rapdu.handle, portno);\n\n  rapdu_set_iofunc (slotp->rapdu.handle,\n                    readfnc, readfnc_value,\n                    writefnc, writefnc_value,\n                    closefnc, closefnc_value);\n  rapdu_set_cookie (slotp->rapdu.handle, cookie, length);\n\n  /* First try to get the current ATR, but if the card is inactive\n     issue a reset instead.  */\n  err = rapdu_send_cmd (slotp->rapdu.handle, RAPDU_CMD_GET_ATR);\n  if (err == RAPDU_STATUS_NEEDRESET)\n    err = rapdu_send_cmd (slotp->rapdu.handle, RAPDU_CMD_RESET);\n  if (err)\n    {\n      log_info (\"sending rapdu command GET_ATR/RESET failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      goto failure;\n    }\n  err = rapdu_read_msg (slotp->rapdu.handle, &msg);\n  if (err)\n    {\n      log_info (\"receiving rapdu message failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      goto failure;\n    }\n  if (msg->cmd != RAPDU_STATUS_SUCCESS || !msg->datalen)\n    {\n      log_info (\"rapdu command GET ATR failed: %s\\n\",\n                 rapdu_strerror (msg->cmd));\n      goto failure;\n    }\n  if (msg->datalen > DIM (slotp->atr))\n    {\n      log_error (\"ATR returned by the RAPDU layer is too large\\n\");\n      goto failure;\n    }\n  slotp->atrlen = msg->datalen;\n  memcpy (slotp->atr, msg->data, msg->datalen);\n\n  reader_table[slot].close_reader = close_rapdu_reader;\n  reader_table[slot].reset_reader = reset_rapdu_reader;\n  reader_table[slot].get_status_reader = my_rapdu_get_status;\n  reader_table[slot].send_apdu_reader = my_rapdu_send_apdu;\n  reader_table[slot].check_pinpad = NULL;\n  reader_table[slot].dump_status_reader = NULL;\n  reader_table[slot].pinpad_verify = NULL;\n  reader_table[slot].pinpad_modify = NULL;\n\n  dump_reader_status (slot);\n  rapdu_msg_release (msg);\n  unlock_slot (slot);\n  return slot;\n\n failure:\n  rapdu_msg_release (msg);\n  rapdu_release (slotp->rapdu.handle);\n  slotp->used = 0;\n  unlock_slot (slot);\n  return -1;\n}\n\n#endif /*USE_G10CODE_RAPDU*/\n\n\n\f\n/*\n       Driver Access\n */\ngpg_error_t\napdu_dev_list_start (const char *portstr, struct dev_list **l_p)\n{\n  struct dev_list *dl = xtrymalloc (sizeof (struct dev_list));\n\n  *l_p = NULL;\n  if (!dl)\n    return gpg_error_from_syserror ();\n\n  dl->portstr = portstr;\n  dl->idx = 0;\n\n  npth_mutex_lock (&reader_table_lock);\n\n#ifdef HAVE_LIBUSB\n  if (opt.disable_ccid)\n    {\n      dl->ccid_table = NULL;\n      dl->idx_max = 1;\n    }\n  else\n    {\n      gpg_error_t err;\n\n      err = ccid_dev_scan (&dl->idx_max, &dl->ccid_table);\n      if (err)\n        return err;\n\n      if (dl->idx_max == 0)\n        {\n          /* If a CCID reader specification has been given, the user does\n             not want a fallback to other drivers. */\n          if (portstr && strlen (portstr) > 5 && portstr[4] == ':')\n            {\n              if (DBG_READER)\n                log_debug (\"leave: apdu_open_reader => slot=-1 (no ccid)\\n\");\n\n              xfree (dl);\n              npth_mutex_unlock (&reader_table_lock);\n              return gpg_error (GPG_ERR_ENODEV);\n            }\n          else\n            dl->idx_max = 1;\n        }\n    }\n#else\n  dl->ccid_table = NULL;\n  dl->idx_max = 1;\n#endif /* HAVE_LIBUSB */\n\n  *l_p = dl;\n  return 0;\n}\n\nvoid\napdu_dev_list_finish (struct dev_list *dl)\n{\n#ifdef HAVE_LIBUSB\n  if (dl->ccid_table)\n    ccid_dev_scan_finish (dl->ccid_table, dl->idx_max);\n#endif\n  xfree (dl);\n  npth_mutex_unlock (&reader_table_lock);\n}\n\n\n/* Open the reader and return an internal slot number or -1 on\n   error. If PORTSTR is NULL we default to a suitable port (for ctAPI:\n   the first USB reader.  For PC/SC the first listed reader). */\nstatic int\napdu_open_one_reader (const char *portstr)\n{\n  static int pcsc_api_loaded;\n  int slot;\n\n  if (DBG_READER)\n    log_debug (\"enter: apdu_open_reader: portstr=%s\\n\", portstr);\n\n  /* Lets try the PC/SC API */\n  if (!pcsc_api_loaded)\n    {\n      void *handle;\n\n      handle = dlopen (opt.pcsc_driver, RTLD_LAZY);\n      if (!handle)\n        {\n          log_error (\"apdu_open_reader: failed to open driver '%s': %s\\n\",\n                     opt.pcsc_driver, dlerror ());\n          return -1;\n        }\n\n      pcsc_establish_context = dlsym (handle, \"SCardEstablishContext\");\n      pcsc_release_context   = dlsym (handle, \"SCardReleaseContext\");\n      pcsc_list_readers      = dlsym (handle, \"SCardListReaders\");\n#if defined(_WIN32) || defined(__CYGWIN__)\n      if (!pcsc_list_readers)\n        pcsc_list_readers    = dlsym (handle, \"SCardListReadersA\");\n#endif\n      pcsc_get_status_change = dlsym (handle, \"SCardGetStatusChange\");\n#if defined(_WIN32) || defined(__CYGWIN__)\n      if (!pcsc_get_status_change)\n        pcsc_get_status_change = dlsym (handle, \"SCardGetStatusChangeA\");\n#endif\n      pcsc_connect           = dlsym (handle, \"SCardConnect\");\n#if defined(_WIN32) || defined(__CYGWIN__)\n      if (!pcsc_connect)\n        pcsc_connect         = dlsym (handle, \"SCardConnectA\");\n#endif\n      pcsc_reconnect         = dlsym (handle, \"SCardReconnect\");\n#if defined(_WIN32) || defined(__CYGWIN__)\n      if (!pcsc_reconnect)\n        pcsc_reconnect       = dlsym (handle, \"SCardReconnectA\");\n#endif\n      pcsc_disconnect        = dlsym (handle, \"SCardDisconnect\");\n      pcsc_status            = dlsym (handle, \"SCardStatus\");\n#if defined(_WIN32) || defined(__CYGWIN__)\n      if (!pcsc_status)\n        pcsc_status          = dlsym (handle, \"SCardStatusA\");\n#endif\n      pcsc_begin_transaction = dlsym (handle, \"SCardBeginTransaction\");\n      pcsc_end_transaction   = dlsym (handle, \"SCardEndTransaction\");\n      pcsc_transmit          = dlsym (handle, \"SCardTransmit\");\n      pcsc_set_timeout       = dlsym (handle, \"SCardSetTimeout\");\n      pcsc_control           = dlsym (handle, \"SCardControl\");\n\n      if (!pcsc_establish_context\n          || !pcsc_release_context\n          || !pcsc_list_readers\n          || !pcsc_get_status_change\n          || !pcsc_connect\n          || !pcsc_reconnect\n          || !pcsc_disconnect\n          || !pcsc_status\n          || !pcsc_begin_transaction\n          || !pcsc_end_transaction\n          || !pcsc_transmit\n          || !pcsc_control\n          /* || !pcsc_set_timeout */)\n        {\n          /* Note that set_timeout is currently not used and also not\n             available under Windows. */\n          log_error (\"apdu_open_reader: invalid PC/SC driver \"\n                     \"(%d%d%d%d%d%d%d%d%d%d%d%d%d)\\n\",\n                     !!pcsc_establish_context,\n                     !!pcsc_release_context,\n                     !!pcsc_list_readers,\n                     !!pcsc_get_status_change,\n                     !!pcsc_connect,\n                     !!pcsc_reconnect,\n                     !!pcsc_disconnect,\n                     !!pcsc_status,\n                     !!pcsc_begin_transaction,\n                     !!pcsc_end_transaction,\n                     !!pcsc_transmit,\n                     !!pcsc_set_timeout,\n                     !!pcsc_control );\n          dlclose (handle);\n          return -1;\n        }\n      pcsc_api_loaded = 1;\n    }\n\n  slot = open_pcsc_reader (portstr);\n\n  if (DBG_READER)\n    log_debug (\"leave: apdu_open_reader => slot=%d [pc/sc]\\n\", slot);\n  return slot;\n}\n\nint\napdu_open_reader (struct dev_list *dl, int app_empty)\n{\n  int slot;\n\n#ifdef HAVE_LIBUSB\n  if (dl->ccid_table)\n    { /* CCID readers.  */\n      int readerno;\n\n      /* See whether we want to use the reader ID string or a reader\n         number. A readerno of -1 indicates that the reader ID string is\n         to be used. */\n      if (dl->portstr && strchr (dl->portstr, ':'))\n        readerno = -1; /* We want to use the readerid.  */\n      else if (dl->portstr)\n        {\n          readerno = atoi (dl->portstr);\n          if (readerno < 0)\n            {\n              return -1;\n            }\n        }\n      else\n        readerno = 0;  /* Default. */\n\n      if (readerno > 0)\n        { /* Use single, the specific reader.  */\n          if (readerno >= dl->idx_max)\n            return -1;\n\n          dl->idx = readerno;\n          dl->portstr = NULL;\n          slot = open_ccid_reader (dl);\n          dl->idx = dl->idx_max;\n          if (slot >= 0)\n            return slot;\n          else\n            return -1;\n        }\n\n      while (dl->idx < dl->idx_max)\n        {\n          unsigned int bai = ccid_get_BAI (dl->idx, dl->ccid_table);\n\n          if (DBG_READER)\n            log_debug (\"apdu_open_reader: BAI=%x\\n\", bai);\n\n          /* Check identity by BAI against already opened HANDLEs.  */\n          for (slot = 0; slot < MAX_READER; slot++)\n            if (reader_table[slot].used\n                && reader_table[slot].ccid.handle\n                && ccid_compare_BAI (reader_table[slot].ccid.handle, bai))\n              break;\n\n          if (slot == MAX_READER)\n            { /* Found a new device.  */\n              if (DBG_READER)\n                log_debug (\"apdu_open_reader: new device=%x\\n\", bai);\n\n              slot = open_ccid_reader (dl);\n\n              dl->idx++;\n              if (slot >= 0)\n                return slot;\n              else\n                {\n                  /* Skip this reader.  */\n                  log_error (\"ccid open error: skip\\n\");\n                  continue;\n                }\n            }\n          else\n            dl->idx++;\n        }\n\n      /* Not found.  Try one for PC/SC, only when it's the initial scan.  */\n      if (app_empty && dl->idx == dl->idx_max)\n        {\n          dl->idx++;\n          slot = apdu_open_one_reader (dl->portstr);\n        }\n      else\n        slot = -1;\n    }\n  else\n#endif\n    { /* PC/SC readers.  */\n      if (app_empty && dl->idx == 0)\n        {\n          dl->idx++;\n          slot = apdu_open_one_reader (dl->portstr);\n        }\n      else\n        slot = -1;\n    }\n\n  return slot;\n}\n\n\n/* Open an remote reader and return an internal slot number or -1 on\n   error. This function is an alternative to apdu_open_reader and used\n   with remote readers only.  Note that the supplied CLOSEFNC will\n   only be called once and the slot will not be valid afther this.\n\n   If PORTSTR is NULL we default to the first available port.\n*/\nint\napdu_open_remote_reader (const char *portstr,\n                         const unsigned char *cookie, size_t length,\n                         int (*readfnc) (void *opaque,\n                                         void *buffer, size_t size),\n                         void *readfnc_value,\n                         int (*writefnc) (void *opaque,\n                                          const void *buffer, size_t size),\n                         void *writefnc_value,\n                         void (*closefnc) (void *opaque),\n                         void *closefnc_value)\n{\n#ifdef USE_G10CODE_RAPDU\n  return open_rapdu_reader (portstr? atoi (portstr) : 0,\n                            cookie, length,\n                            readfnc, readfnc_value,\n                            writefnc, writefnc_value,\n                            closefnc, closefnc_value);\n#else\n  (void)portstr;\n  (void)cookie;\n  (void)length;\n  (void)readfnc;\n  (void)readfnc_value;\n  (void)writefnc;\n  (void)writefnc_value;\n  (void)closefnc;\n  (void)closefnc_value;\n#ifdef _WIN32\n  errno = ENOENT;\n#else\n  errno = ENOSYS;\n#endif\n  return -1;\n#endif\n}\n\n\nint\napdu_close_reader (int slot)\n{\n  int sw;\n\n  if (DBG_READER)\n    log_debug (\"enter: apdu_close_reader: slot=%d\\n\", slot);\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_close_reader => SW_HOST_NO_DRIVER\\n\");\n      return SW_HOST_NO_DRIVER;\n    }\n  sw = apdu_disconnect (slot);\n  if (sw)\n    {\n      /*\n       * When the reader/token was removed it might come here.\n       * It should go through to call CLOSE_READER even if we got an error.\n       */\n      if (DBG_READER)\n        log_debug (\"apdu_close_reader => 0x%x (apdu_disconnect)\\n\", sw);\n    }\n  if (reader_table[slot].close_reader)\n    {\n      sw = reader_table[slot].close_reader (slot);\n      reader_table[slot].used = 0;\n      if (DBG_READER)\n        log_debug (\"leave: apdu_close_reader => 0x%x (close_reader)\\n\", sw);\n      return sw;\n    }\n  xfree (reader_table[slot].rdrname);\n  reader_table[slot].rdrname = NULL;\n  reader_table[slot].used = 0;\n  if (DBG_READER)\n    log_debug (\"leave: apdu_close_reader => SW_HOST_NOT_SUPPORTED\\n\");\n  return SW_HOST_NOT_SUPPORTED;\n}\n\n\n/* Function suitable for a cleanup function to close all reader.  It\n   should not be used if the reader will be opened again.  The reason\n   for implementing this to properly close USB devices so that they\n   will startup the next time without error. */\nvoid\napdu_prepare_exit (void)\n{\n  static int sentinel;\n  int slot;\n\n  if (!sentinel)\n    {\n      sentinel = 1;\n      npth_mutex_lock (&reader_table_lock);\n      for (slot = 0; slot < MAX_READER; slot++)\n        if (reader_table[slot].used)\n          {\n            apdu_disconnect (slot);\n            if (reader_table[slot].close_reader)\n              reader_table[slot].close_reader (slot);\n            xfree (reader_table[slot].rdrname);\n            reader_table[slot].rdrname = NULL;\n            reader_table[slot].used = 0;\n          }\n      npth_mutex_unlock (&reader_table_lock);\n      sentinel = 0;\n    }\n}\n\n\n/* Enumerate all readers and return information on whether this reader\n   is in use.  The caller should start with SLOT set to 0 and\n   increment it with each call until an error is returned. */\nint\napdu_enum_reader (int slot, int *used)\n{\n  if (slot < 0 || slot >= MAX_READER)\n    return SW_HOST_NO_DRIVER;\n  *used = reader_table[slot].used;\n  return 0;\n}\n\n\n/* Connect a card.  This is used to power up the card and make sure\n   that an ATR is available.  Depending on the reader backend it may\n   return an error for an inactive card or if no card is available.\n   Return -1 on error.  Return 1 if reader requires get_status to\n   watch card removal.  Return 0 if it's a token (always with a card),\n   or it supports INTERRUPT endpoint to watch card removal.\n  */\nint\napdu_connect (int slot)\n{\n  int sw = 0;\n  unsigned int status = 0;\n\n  if (DBG_READER)\n    log_debug (\"enter: apdu_connect: slot=%d\\n\", slot);\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_connect => SW_HOST_NO_DRIVER\\n\");\n      return -1;\n    }\n\n  /* Only if the access method provides a connect function we use it.\n     If not, we expect that the card has been implicitly connected by\n     apdu_open_reader.  */\n  if (reader_table[slot].connect_card)\n    {\n      sw = lock_slot (slot);\n      if (!sw)\n        {\n          sw = reader_table[slot].connect_card (slot);\n          unlock_slot (slot);\n        }\n    }\n\n  /* We need to call apdu_get_status_internal, so that the last-status\n     machinery gets setup properly even if a card is inserted while\n     scdaemon is fired up and apdu_get_status has not yet been called.\n     Without that we would force a reset of the card with the next\n     call to apdu_get_status.  */\n  if (!sw)\n    sw = apdu_get_status_internal (slot, 1, &status, 1);\n\n  if (sw)\n    ;\n  else if (!(status & APDU_CARD_PRESENT))\n    sw = SW_HOST_NO_CARD;\n  else if ((status & APDU_CARD_PRESENT) && !(status & APDU_CARD_ACTIVE))\n    sw = SW_HOST_CARD_INACTIVE;\n\n  if (sw == SW_HOST_CARD_INACTIVE)\n    {\n      /* Try power it up again.  */\n      sw = apdu_reset (slot);\n    }\n\n  if (DBG_READER)\n    log_debug (\"leave: apdu_connect => sw=0x%x\\n\", sw);\n\n  if (sw)\n    return -1;\n\n  return reader_table[slot].require_get_status;\n}\n\n\nint\napdu_disconnect (int slot)\n{\n  int sw;\n\n  if (DBG_READER)\n    log_debug (\"enter: apdu_disconnect: slot=%d\\n\", slot);\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_disconnect => SW_HOST_NO_DRIVER\\n\");\n      return SW_HOST_NO_DRIVER;\n    }\n\n  if (reader_table[slot].disconnect_card)\n    {\n      sw = lock_slot (slot);\n      if (!sw)\n        {\n          sw = reader_table[slot].disconnect_card (slot);\n          unlock_slot (slot);\n        }\n    }\n  else\n    sw = 0;\n\n  if (DBG_READER)\n    log_debug (\"leave: apdu_disconnect => sw=0x%x\\n\", sw);\n  return sw;\n}\n\n\n/* Set the progress callback of SLOT to CB and its args to CB_ARG.  If\n   CB is NULL the progress callback is removed.  */\nint\napdu_set_progress_cb (int slot, gcry_handler_progress_t cb, void *cb_arg)\n{\n  int sw;\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (reader_table[slot].set_progress_cb)\n    {\n      sw = lock_slot (slot);\n      if (!sw)\n        {\n          sw = reader_table[slot].set_progress_cb (slot, cb, cb_arg);\n          unlock_slot (slot);\n        }\n    }\n  else\n    sw = 0;\n  return sw;\n}\n\n\nint\napdu_set_prompt_cb (int slot, void (*cb) (void *, int), void *cb_arg)\n{\n  int sw;\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (reader_table[slot].set_prompt_cb)\n    {\n      sw = lock_slot (slot);\n      if (!sw)\n        {\n          sw = reader_table[slot].set_prompt_cb (slot, cb, cb_arg);\n          unlock_slot (slot);\n        }\n    }\n  else\n    sw = 0;\n  return sw;\n}\n\n\n/* Do a reset for the card in reader at SLOT. */\nint\napdu_reset (int slot)\n{\n  int sw;\n\n  if (DBG_READER)\n    log_debug (\"enter: apdu_reset: slot=%d\\n\", slot);\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_reset => SW_HOST_NO_DRIVER\\n\");\n      return SW_HOST_NO_DRIVER;\n    }\n\n  if ((sw = lock_slot (slot)))\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_reset => sw=0x%x (lock_slot)\\n\", sw);\n      return sw;\n    }\n\n  if (reader_table[slot].reset_reader)\n    sw = reader_table[slot].reset_reader (slot);\n\n  unlock_slot (slot);\n  if (DBG_READER)\n    log_debug (\"leave: apdu_reset => sw=0x%x\\n\", sw);\n  return sw;\n}\n\n\n/* Return the ATR or NULL if none is available.  On success the length\n   of the ATR is stored at ATRLEN.  The caller must free the returned\n   value.  */\nunsigned char *\napdu_get_atr (int slot, size_t *atrlen)\n{\n  unsigned char *buf;\n\n  if (DBG_READER)\n    log_debug (\"enter: apdu_get_atr: slot=%d\\n\", slot);\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_get_atr => NULL (bad slot)\\n\");\n      return NULL;\n    }\n  if (!reader_table[slot].atrlen)\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_get_atr => NULL (no ATR)\\n\");\n      return NULL;\n    }\n\n  buf = xtrymalloc (reader_table[slot].atrlen);\n  if (!buf)\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_get_atr => NULL (out of core)\\n\");\n      return NULL;\n    }\n  memcpy (buf, reader_table[slot].atr, reader_table[slot].atrlen);\n  *atrlen = reader_table[slot].atrlen;\n  if (DBG_READER)\n    log_debug (\"leave: apdu_get_atr => atrlen=%zu\\n\", *atrlen);\n  return buf;\n}\n\n\n\n/* Retrieve the status for SLOT. The function does only wait for the\n   card to become available if HANG is set to true. On success the\n   bits in STATUS will be set to\n\n     APDU_CARD_USABLE  (bit 0) = card present and usable\n     APDU_CARD_PRESENT (bit 1) = card present\n     APDU_CARD_ACTIVE  (bit 2) = card active\n                       (bit 3) = card access locked [not yet implemented]\n\n   For most applications, testing bit 0 is sufficient.\n*/\nstatic int\napdu_get_status_internal (int slot, int hang, unsigned int *status, int on_wire)\n{\n  int sw;\n  unsigned int s = 0;\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if ((sw = hang? lock_slot (slot) : trylock_slot (slot)))\n    return sw;\n\n  if (reader_table[slot].get_status_reader)\n    sw = reader_table[slot].get_status_reader (slot, &s, on_wire);\n\n  unlock_slot (slot);\n\n  if (sw)\n    {\n      if (on_wire)\n        reader_table[slot].atrlen = 0;\n      s = 0;\n    }\n\n  if (status)\n    *status = s;\n  return sw;\n}\n\n\n/* See above for a description.  */\nint\napdu_get_status (int slot, int hang, unsigned int *status)\n{\n  int sw;\n\n  if (DBG_READER)\n    log_debug (\"enter: apdu_get_status: slot=%d hang=%d\\n\", slot, hang);\n  sw = apdu_get_status_internal (slot, hang, status, 0);\n  if (DBG_READER)\n    {\n      if (status)\n        log_debug (\"leave: apdu_get_status => sw=0x%x status=%u\\n\",\n                   sw, *status);\n      else\n        log_debug (\"leave: apdu_get_status => sw=0x%x\\n\", sw);\n    }\n  return sw;\n}\n\n\n/* Check whether the reader supports the ISO command code COMMAND on\n   the pinpad.  Return 0 on success.  For a description of the pin\n   parameters, see ccid-driver.c */\nint\napdu_check_pinpad (int slot, int command, pininfo_t *pininfo)\n{\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (opt.enable_pinpad_varlen)\n    pininfo->fixedlen = 0;\n\n  if (reader_table[slot].check_pinpad)\n    {\n      int sw;\n\n      if ((sw = lock_slot (slot)))\n        return sw;\n\n      sw = reader_table[slot].check_pinpad (slot, command, pininfo);\n      unlock_slot (slot);\n      return sw;\n    }\n  else\n    return SW_HOST_NOT_SUPPORTED;\n}\n\n\nint\napdu_pinpad_verify (int slot, int class, int ins, int p0, int p1,\n                    pininfo_t *pininfo)\n{\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (reader_table[slot].pinpad_verify)\n    {\n      int sw;\n\n      if ((sw = lock_slot (slot)))\n        return sw;\n\n      sw = reader_table[slot].pinpad_verify (slot, class, ins, p0, p1,\n                                             pininfo);\n      unlock_slot (slot);\n      return sw;\n    }\n  else\n    return SW_HOST_NOT_SUPPORTED;\n}\n\n\nint\napdu_pinpad_modify (int slot, int class, int ins, int p0, int p1,\n                    pininfo_t *pininfo)\n{\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (reader_table[slot].pinpad_modify)\n    {\n      int sw;\n\n      if ((sw = lock_slot (slot)))\n        return sw;\n\n      sw = reader_table[slot].pinpad_modify (slot, class, ins, p0, p1,\n                                             pininfo);\n      unlock_slot (slot);\n      return sw;\n    }\n  else\n    return SW_HOST_NOT_SUPPORTED;\n}\n\n\n/* Dispatcher for the actual send_apdu function. Note, that this\n   function should be called in locked state. */\nstatic int\nsend_apdu (int slot, unsigned char *apdu, size_t apdulen,\n           unsigned char *buffer, size_t *buflen, pininfo_t *pininfo)\n{\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (reader_table[slot].send_apdu_reader)\n    return reader_table[slot].send_apdu_reader (slot,\n                                                apdu, apdulen,\n                                                buffer, buflen,\n                                                pininfo);\n  else\n    return SW_HOST_NOT_SUPPORTED;\n}\n\n\n/* Core APDU tranceiver function. Parameters are described at\n   apdu_send_le with the exception of PININFO which indicates pinpad\n   related operations if not NULL.  If EXTENDED_MODE is not 0\n   command chaining or extended length will be used according to these\n   values:\n       n < 0 := Use command chaining with the data part limited to -n\n                in each chunk.  If -1 is used a default value is used.\n      n == 0 := No extended mode or command chaining.\n      n == 1 := Use extended length for input and output without a\n                length limit.\n       n > 1 := Use extended length with up to N bytes.\n\n*/\nstatic int\nsend_le (int slot, int class, int ins, int p0, int p1,\n         int lc, const char *data, int le,\n         unsigned char **retbuf, size_t *retbuflen,\n         pininfo_t *pininfo, int extended_mode)\n{\n#define SHORT_RESULT_BUFFER_SIZE 258\n  /* We allocate 8 extra bytes as a safety margin towards a driver bug.  */\n  unsigned char short_result_buffer[SHORT_RESULT_BUFFER_SIZE+10];\n  unsigned char *result_buffer = NULL;\n  size_t result_buffer_size;\n  unsigned char *result;\n  size_t resultlen;\n  unsigned char short_apdu_buffer[5+256+1];\n  unsigned char *apdu_buffer = NULL;\n  size_t apdu_buffer_size;\n  unsigned char *apdu;\n  size_t apdulen;\n  int sw;\n  long rc; /* We need a long here due to PC/SC. */\n  int did_exact_length_hack = 0;\n  int use_chaining = 0;\n  int use_extended_length = 0;\n  int lc_chunk;\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (DBG_CARD_IO)\n    log_debug (\"send apdu: c=%02X i=%02X p1=%02X p2=%02X lc=%d le=%d em=%d\\n\",\n               class, ins, p0, p1, lc, le, extended_mode);\n\n  if (lc != -1 && (lc > 255 || lc < 0))\n    {\n      /* Data does not fit into an APDU.  What we do now depends on\n         the EXTENDED_MODE parameter.  */\n      if (!extended_mode)\n        return SW_WRONG_LENGTH; /* No way to send such an APDU.  */\n      else if (extended_mode > 0)\n        use_extended_length = 1;\n      else if (extended_mode < 0)\n        {\n          /* Send APDU using chaining mode.  */\n          if (lc > 16384)\n            return SW_WRONG_LENGTH;   /* Sanity check.  */\n          if ((class&0xf0) != 0)\n            return SW_HOST_INV_VALUE; /* Upper 4 bits need to be 0.  */\n          use_chaining = extended_mode == -1? 255 : -extended_mode;\n          use_chaining &= 0xff;\n        }\n      else\n        return SW_HOST_INV_VALUE;\n    }\n  else if (lc == -1 && extended_mode > 0)\n    use_extended_length = 1;\n\n  if (le != -1 && (le > (extended_mode > 0? 255:256) || le < 0))\n    {\n      /* Expected Data does not fit into an APDU.  What we do now\n         depends on the EXTENDED_MODE parameter.  Note that a check\n         for command chaining does not make sense because we are\n         looking at Le.  */\n      if (!extended_mode)\n        return SW_WRONG_LENGTH; /* No way to send such an APDU.  */\n      else if (use_extended_length)\n        ; /* We are already using extended length.  */\n      else if (extended_mode > 0)\n        use_extended_length = 1;\n      else\n        return SW_HOST_INV_VALUE;\n    }\n\n  if ((!data && lc != -1) || (data && lc == -1))\n    return SW_HOST_INV_VALUE;\n\n  if (use_extended_length)\n    {\n      if (reader_table[slot].is_t0)\n        return SW_HOST_NOT_SUPPORTED;\n\n      /* Space for: cls/ins/p1/p2+Z+2_byte_Lc+Lc+2_byte_Le.  */\n      apdu_buffer_size = 4 + 1 + (lc >= 0? (2+lc):0) + 2;\n      apdu_buffer = xtrymalloc (apdu_buffer_size + 10);\n      if (!apdu_buffer)\n        return SW_HOST_OUT_OF_CORE;\n      apdu = apdu_buffer;\n    }\n  else\n    {\n      apdu_buffer_size = sizeof short_apdu_buffer;\n      apdu = short_apdu_buffer;\n    }\n\n  if (use_extended_length && (le > 256 || le < 0))\n    {\n      /* Two more bytes are needed for status bytes.  */\n      result_buffer_size = le < 0? 4096 : (le + 2);\n      result_buffer = xtrymalloc (result_buffer_size);\n      if (!result_buffer)\n        {\n          xfree (apdu_buffer);\n          return SW_HOST_OUT_OF_CORE;\n        }\n      result = result_buffer;\n    }\n  else\n    {\n      result_buffer_size = SHORT_RESULT_BUFFER_SIZE;\n      result = short_result_buffer;\n    }\n#undef SHORT_RESULT_BUFFER_SIZE\n\n  if ((sw = lock_slot (slot)))\n    {\n      xfree (apdu_buffer);\n      xfree (result_buffer);\n      return sw;\n    }\n\n  do\n    {\n      if (use_extended_length)\n        {\n          use_chaining = 0;\n          apdulen = 0;\n          apdu[apdulen++] = class;\n          apdu[apdulen++] = ins;\n          apdu[apdulen++] = p0;\n          apdu[apdulen++] = p1;\n          if (lc > 0)\n            {\n              apdu[apdulen++] = 0;  /* Z byte: Extended length marker.  */\n              apdu[apdulen++] = ((lc >> 8) & 0xff);\n              apdu[apdulen++] = (lc & 0xff);\n              memcpy (apdu+apdulen, data, lc);\n              data += lc;\n              apdulen += lc;\n            }\n          if (le != -1)\n            {\n              if (lc <= 0)\n                apdu[apdulen++] = 0;  /* Z byte: Extended length marker.  */\n              apdu[apdulen++] = ((le >> 8) & 0xff);\n              apdu[apdulen++] = (le & 0xff);\n            }\n        }\n      else\n        {\n          apdulen = 0;\n          apdu[apdulen] = class;\n          if (use_chaining && lc > 255)\n            {\n              apdu[apdulen] |= 0x10;\n              assert (use_chaining < 256);\n              lc_chunk = use_chaining;\n              lc -= use_chaining;\n            }\n          else\n            {\n              use_chaining = 0;\n              lc_chunk = lc;\n            }\n          apdulen++;\n          apdu[apdulen++] = ins;\n          apdu[apdulen++] = p0;\n          apdu[apdulen++] = p1;\n          if (lc_chunk != -1)\n            {\n              apdu[apdulen++] = lc_chunk;\n              memcpy (apdu+apdulen, data, lc_chunk);\n              data += lc_chunk;\n              apdulen += lc_chunk;\n              /* T=0 does not allow the use of Lc together with Le;\n                 thus disable Le in this case.  */\n              if (reader_table[slot].is_t0)\n                le = -1;\n            }\n          if (le != -1 && !use_chaining)\n            apdu[apdulen++] = le; /* Truncation is okay (0 means 256). */\n        }\n\n    exact_length_hack:\n      /* As a safeguard don't pass any garbage to the driver.  */\n      assert (apdulen <= apdu_buffer_size);\n      memset (apdu+apdulen, 0, apdu_buffer_size - apdulen);\n      resultlen = result_buffer_size;\n      rc = send_apdu (slot, apdu, apdulen, result, &resultlen, pininfo);\n      if (rc || resultlen < 2)\n        {\n          log_info (\"apdu_send_simple(%d) failed: %s\\n\",\n                    slot, apdu_strerror (rc));\n          unlock_slot (slot);\n          xfree (apdu_buffer);\n          xfree (result_buffer);\n          return rc? rc : SW_HOST_INCOMPLETE_CARD_RESPONSE;\n        }\n      sw = (result[resultlen-2] << 8) | result[resultlen-1];\n      if (!use_extended_length\n          && !did_exact_length_hack && SW_EXACT_LENGTH_P (sw))\n        {\n          apdu[apdulen-1] = (sw & 0x00ff);\n          did_exact_length_hack = 1;\n          goto exact_length_hack;\n        }\n    }\n  while (use_chaining && sw == SW_SUCCESS);\n\n  if (apdu_buffer)\n    {\n      xfree (apdu_buffer);\n      apdu_buffer = NULL;\n    }\n\n  /* Store away the returned data but strip the statusword. */\n  resultlen -= 2;\n  if (DBG_CARD_IO)\n    {\n      log_debug (\" response: sw=%04X  datalen=%d\\n\",\n                 sw, (unsigned int)resultlen);\n      if ( !retbuf && (sw == SW_SUCCESS || (sw & 0xff00) == SW_MORE_DATA))\n        log_printhex (\"    dump: \", result, resultlen);\n    }\n\n  if (sw == SW_SUCCESS || sw == SW_EOF_REACHED)\n    {\n      if (retbuf)\n        {\n          *retbuf = xtrymalloc (resultlen? resultlen : 1);\n          if (!*retbuf)\n            {\n              unlock_slot (slot);\n              xfree (result_buffer);\n              return SW_HOST_OUT_OF_CORE;\n            }\n          *retbuflen = resultlen;\n          memcpy (*retbuf, result, resultlen);\n        }\n    }\n  else if ((sw & 0xff00) == SW_MORE_DATA)\n    {\n      unsigned char *p = NULL, *tmp;\n      size_t bufsize = 4096;\n\n      /* It is likely that we need to return much more data, so we\n         start off with a large buffer. */\n      if (retbuf)\n        {\n          *retbuf = p = xtrymalloc (bufsize);\n          if (!*retbuf)\n            {\n              unlock_slot (slot);\n              xfree (result_buffer);\n              return SW_HOST_OUT_OF_CORE;\n            }\n          assert (resultlen < bufsize);\n          memcpy (p, result, resultlen);\n          p += resultlen;\n        }\n\n      do\n        {\n          int len = (sw & 0x00ff);\n\n          if (DBG_CARD_IO)\n            log_debug (\"apdu_send_simple(%d): %d more bytes available\\n\",\n                       slot, len);\n          apdu_buffer_size = sizeof short_apdu_buffer;\n          apdu = short_apdu_buffer;\n          apdulen = 0;\n          apdu[apdulen++] = class;\n          apdu[apdulen++] = 0xC0;\n          apdu[apdulen++] = 0;\n          apdu[apdulen++] = 0;\n          apdu[apdulen++] = len;\n          assert (apdulen <= apdu_buffer_size);\n          memset (apdu+apdulen, 0, apdu_buffer_size - apdulen);\n          resultlen = result_buffer_size;\n          rc = send_apdu (slot, apdu, apdulen, result, &resultlen, NULL);\n          if (rc || resultlen < 2)\n            {\n              log_error (\"apdu_send_simple(%d) for get response failed: %s\\n\",\n                         slot, apdu_strerror (rc));\n              unlock_slot (slot);\n              xfree (result_buffer);\n              return rc? rc : SW_HOST_INCOMPLETE_CARD_RESPONSE;\n            }\n          sw = (result[resultlen-2] << 8) | result[resultlen-1];\n          resultlen -= 2;\n          if (DBG_CARD_IO)\n            {\n              log_debug (\"     more: sw=%04X  datalen=%d\\n\",\n                         sw, (unsigned int)resultlen);\n              if (!retbuf && (sw==SW_SUCCESS || (sw&0xff00)==SW_MORE_DATA))\n                log_printhex (\"     dump: \", result, resultlen);\n            }\n\n          if ((sw & 0xff00) == SW_MORE_DATA\n              || sw == SW_SUCCESS\n              || sw == SW_EOF_REACHED )\n            {\n              if (retbuf && resultlen)\n                {\n                  if (p - *retbuf + resultlen > bufsize)\n                    {\n                      bufsize += resultlen > 4096? resultlen: 4096;\n                      tmp = xtryrealloc (*retbuf, bufsize);\n                      if (!tmp)\n                        {\n                          unlock_slot (slot);\n                          xfree (result_buffer);\n                          return SW_HOST_OUT_OF_CORE;\n                        }\n                      p = tmp + (p - *retbuf);\n                      *retbuf = tmp;\n                    }\n                  memcpy (p, result, resultlen);\n                  p += resultlen;\n                }\n            }\n          else\n            log_info (\"apdu_send_simple(%d) \"\n                      \"got unexpected status %04X from get response\\n\",\n                      slot, sw);\n        }\n      while ((sw & 0xff00) == SW_MORE_DATA);\n\n      if (retbuf)\n        {\n          *retbuflen = p - *retbuf;\n          tmp = xtryrealloc (*retbuf, *retbuflen);\n          if (tmp)\n            *retbuf = tmp;\n        }\n    }\n\n  unlock_slot (slot);\n  xfree (result_buffer);\n\n  if (DBG_CARD_IO && retbuf && sw == SW_SUCCESS)\n    log_printhex (\"      dump: \", *retbuf, *retbuflen);\n\n  return sw;\n}\n\n/* Send an APDU to the card in SLOT.  The APDU is created from all\n   given parameters: CLASS, INS, P0, P1, LC, DATA, LE.  A value of -1\n   for LC won't sent this field and the data field; in this case DATA\n   must also be passed as NULL.  If EXTENDED_MODE is not 0 command\n   chaining or extended length will be used; see send_le for details.\n   The return value is the status word or -1 for an invalid SLOT or\n   other non card related error.  If RETBUF is not NULL, it will\n   receive an allocated buffer with the returned data.  The length of\n   that data will be put into *RETBUFLEN.  The caller is responsible\n   for releasing the buffer even in case of errors.  */\nint\napdu_send_le(int slot, int extended_mode,\n             int class, int ins, int p0, int p1,\n             int lc, const char *data, int le,\n             unsigned char **retbuf, size_t *retbuflen)\n{\n  return send_le (slot, class, ins, p0, p1,\n                  lc, data, le,\n                  retbuf, retbuflen,\n                  NULL, extended_mode);\n}\n\n\n/* Send an APDU to the card in SLOT.  The APDU is created from all\n   given parameters: CLASS, INS, P0, P1, LC, DATA.  A value of -1 for\n   LC won't sent this field and the data field; in this case DATA must\n   also be passed as NULL.  If EXTENDED_MODE is not 0 command chaining\n   or extended length will be used; see send_le for details.  The\n   return value is the status word or -1 for an invalid SLOT or other\n   non card related error.  If RETBUF is not NULL, it will receive an\n   allocated buffer with the returned data.  The length of that data\n   will be put into *RETBUFLEN.  The caller is responsible for\n   releasing the buffer even in case of errors.  */\nint\napdu_send (int slot, int extended_mode,\n           int class, int ins, int p0, int p1,\n           int lc, const char *data, unsigned char **retbuf, size_t *retbuflen)\n{\n  return send_le (slot, class, ins, p0, p1, lc, data, 256,\n                  retbuf, retbuflen, NULL, extended_mode);\n}\n\n/* Send an APDU to the card in SLOT.  The APDU is created from all\n   given parameters: CLASS, INS, P0, P1, LC, DATA.  A value of -1 for\n   LC won't sent this field and the data field; in this case DATA must\n   also be passed as NULL.  If EXTENDED_MODE is not 0 command chaining\n   or extended length will be used; see send_le for details.  The\n   return value is the status word or -1 for an invalid SLOT or other\n   non card related error.  No data will be returned.  */\nint\napdu_send_simple (int slot, int extended_mode,\n                  int class, int ins, int p0, int p1,\n                  int lc, const char *data)\n{\n  return send_le (slot, class, ins, p0, p1, lc, data, -1, NULL, NULL, NULL,\n                  extended_mode);\n}\n\n\n/* This is a more generic version of the apdu sending routine.  It\n * takes an already formatted APDU in APDUDATA or length APDUDATALEN\n * and returns with an APDU including the status word.  With\n * HANDLE_MORE set to true this function will handle the MORE DATA\n * status and return all APDUs concatenated with one status word at\n * the end.  If EXTENDED_LENGTH is != 0 extended lengths are allowed\n * with a max. result data length of EXTENDED_LENGTH bytes.  The\n * function does not return a regular status word but 0 on success.\n * If the slot is locked, the function returns immediately with an\n * error.\n *\n * Out of historical reasons the function returns 0 on success and\n * outs the status word at the end of the result to be able to get the\n * status word in the case of a not provided RETBUF, R_SW can be used\n * to store the SW.  But note that R_SW qill only be set if the\n * function returns 0. */\nint\napdu_send_direct (int slot, size_t extended_length,\n                  const unsigned char *apdudata, size_t apdudatalen,\n                  int handle_more, unsigned int *r_sw,\n                  unsigned char **retbuf, size_t *retbuflen)\n{\n#define SHORT_RESULT_BUFFER_SIZE 258\n  unsigned char short_result_buffer[SHORT_RESULT_BUFFER_SIZE+10];\n  unsigned char *result_buffer = NULL;\n  size_t result_buffer_size;\n  unsigned char *result;\n  size_t resultlen;\n  unsigned char short_apdu_buffer[5+256+10];\n  unsigned char *apdu_buffer = NULL;\n  unsigned char *apdu;\n  size_t apdulen;\n  int sw;\n  long rc; /* we need a long here due to PC/SC. */\n  int class;\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (apdudatalen > 65535)\n    return SW_HOST_INV_VALUE;\n\n  if (apdudatalen > sizeof short_apdu_buffer - 5)\n    {\n      apdu_buffer = xtrymalloc (apdudatalen + 5);\n      if (!apdu_buffer)\n        return SW_HOST_OUT_OF_CORE;\n      apdu = apdu_buffer;\n    }\n  else\n    {\n      apdu = short_apdu_buffer;\n    }\n  apdulen = apdudatalen;\n  memcpy (apdu, apdudata, apdudatalen);\n  class = apdulen? *apdu : 0;\n\n  if (extended_length >= 256 && extended_length <= 65536)\n    {\n      result_buffer_size = extended_length;\n      result_buffer = xtrymalloc (result_buffer_size + 10);\n      if (!result_buffer)\n        {\n          xfree (apdu_buffer);\n          return SW_HOST_OUT_OF_CORE;\n        }\n      result = result_buffer;\n    }\n  else\n    {\n      result_buffer_size = SHORT_RESULT_BUFFER_SIZE;\n      result = short_result_buffer;\n    }\n#undef SHORT_RESULT_BUFFER_SIZE\n\n  if ((sw = trylock_slot (slot)))\n    {\n      xfree (apdu_buffer);\n      xfree (result_buffer);\n      return sw;\n    }\n\n  resultlen = result_buffer_size;\n  rc = send_apdu (slot, apdu, apdulen, result, &resultlen, NULL);\n  xfree (apdu_buffer);\n  apdu_buffer = NULL;\n  if (rc || resultlen < 2)\n    {\n      log_error (\"apdu_send_direct(%d) failed: %s\\n\",\n                 slot, apdu_strerror (rc));\n      unlock_slot (slot);\n      xfree (result_buffer);\n      return rc? rc : SW_HOST_INCOMPLETE_CARD_RESPONSE;\n    }\n  sw = (result[resultlen-2] << 8) | result[resultlen-1];\n  /* Store away the returned data but strip the statusword. */\n  resultlen -= 2;\n  if (DBG_CARD_IO)\n    {\n      log_debug (\" response: sw=%04X  datalen=%d\\n\",\n                 sw, (unsigned int)resultlen);\n      if ( !retbuf && (sw == SW_SUCCESS || (sw & 0xff00) == SW_MORE_DATA))\n        log_printhex (\"     dump: \", result, resultlen);\n    }\n\n  if (handle_more && (sw & 0xff00) == SW_MORE_DATA)\n    {\n      unsigned char *p = NULL, *tmp;\n      size_t bufsize = 4096;\n\n      /* It is likely that we need to return much more data, so we\n         start off with a large buffer. */\n      if (retbuf)\n        {\n          *retbuf = p = xtrymalloc (bufsize + 2);\n          if (!*retbuf)\n            {\n              unlock_slot (slot);\n              xfree (result_buffer);\n              return SW_HOST_OUT_OF_CORE;\n            }\n          assert (resultlen < bufsize);\n          memcpy (p, result, resultlen);\n          p += resultlen;\n        }\n\n      do\n        {\n          int len = (sw & 0x00ff);\n\n          if (DBG_CARD_IO)\n            log_debug (\"apdu_send_direct(%d): %d more bytes available\\n\",\n                       slot, len);\n          apdu = short_apdu_buffer;\n          apdulen = 0;\n          apdu[apdulen++] = class;\n          apdu[apdulen++] = 0xC0;\n          apdu[apdulen++] = 0;\n          apdu[apdulen++] = 0;\n          apdu[apdulen++] = len;\n          memset (apdu+apdulen, 0, sizeof (short_apdu_buffer) - apdulen);\n          resultlen = result_buffer_size;\n          rc = send_apdu (slot, apdu, apdulen, result, &resultlen, NULL);\n          if (rc || resultlen < 2)\n            {\n              log_error (\"apdu_send_direct(%d) for get response failed: %s\\n\",\n                         slot, apdu_strerror (rc));\n              unlock_slot (slot);\n              xfree (result_buffer);\n              return rc ? rc : SW_HOST_INCOMPLETE_CARD_RESPONSE;\n            }\n          sw = (result[resultlen-2] << 8) | result[resultlen-1];\n          resultlen -= 2;\n          if (DBG_CARD_IO)\n            {\n              log_debug (\"     more: sw=%04X  datalen=%d\\n\",\n                         sw, (unsigned int)resultlen);\n              if (!retbuf && (sw==SW_SUCCESS || (sw&0xff00)==SW_MORE_DATA))\n                log_printhex (\"     dump: \", result, resultlen);\n            }\n\n          if ((sw & 0xff00) == SW_MORE_DATA\n              || sw == SW_SUCCESS\n              || sw == SW_EOF_REACHED )\n            {\n              if (retbuf && resultlen)\n                {\n                  if (p - *retbuf + resultlen > bufsize)\n                    {\n                      bufsize += resultlen > 4096? resultlen: 4096;\n                      tmp = xtryrealloc (*retbuf, bufsize + 2);\n                      if (!tmp)\n                        {\n                          unlock_slot (slot);\n                          xfree (result_buffer);\n                          return SW_HOST_OUT_OF_CORE;\n                        }\n                      p = tmp + (p - *retbuf);\n                      *retbuf = tmp;\n                    }\n                  memcpy (p, result, resultlen);\n                  p += resultlen;\n                }\n            }\n          else\n            log_info (\"apdu_send_direct(%d) \"\n                      \"got unexpected status %04X from get response\\n\",\n                      slot, sw);\n        }\n      while ((sw & 0xff00) == SW_MORE_DATA);\n\n      if (retbuf)\n        {\n          *retbuflen = p - *retbuf;\n          tmp = xtryrealloc (*retbuf, *retbuflen + 2);\n          if (tmp)\n            *retbuf = tmp;\n        }\n    }\n  else\n    {\n      if (retbuf)\n        {\n          *retbuf = xtrymalloc ((resultlen? resultlen : 1)+2);\n          if (!*retbuf)\n            {\n              unlock_slot (slot);\n              xfree (result_buffer);\n              return SW_HOST_OUT_OF_CORE;\n            }\n          *retbuflen = resultlen;\n          memcpy (*retbuf, result, resultlen);\n        }\n    }\n\n  unlock_slot (slot);\n  xfree (result_buffer);\n\n  /* Append the status word.  Note that we reserved the two extra\n     bytes while allocating the buffer.  */\n  if (retbuf)\n    {\n      (*retbuf)[(*retbuflen)++] = (sw >> 8);\n      (*retbuf)[(*retbuflen)++] = sw;\n    }\n\n  if (r_sw)\n    *r_sw = sw;\n\n  if (DBG_CARD_IO && retbuf)\n    log_printhex (\"      dump: \", *retbuf, *retbuflen);\n\n\n  return 0;\n}\n\n\nconst char *\napdu_get_reader_name (int slot)\n{\n  return reader_table[slot].rdrname;\n}\n\ngpg_error_t\napdu_init (void)\n{\n#ifdef USE_NPTH\n  gpg_error_t err;\n  int i;\n\n  if (npth_mutex_init (&reader_table_lock, NULL))\n    goto leave;\n\n  for (i = 0; i < MAX_READER; i++)\n    if (npth_mutex_init (&reader_table[i].lock, NULL))\n      goto leave;\n\n  /* All done well.  */\n  return 0;\n\n leave:\n  err = gpg_error_from_syserror ();\n  log_error (\"apdu: error initializing mutex: %s\\n\", gpg_strerror (err));\n  return err;\n#endif /*USE_NPTH*/\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/common/iobuf.c": "/* iobuf.c  -  File Handling for OpenPGP.\n * Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004, 2006, 2007, 2008,\n *               2009, 2010, 2011  Free Software Foundation, Inc.\n * Copyright (C) 2015  g10 Code GmbH\n *\n * This file is part of GnuPG.\n *\n * This file is free software; you can redistribute it and/or modify\n * it under the terms of either\n *\n *   - the GNU Lesser General Public License as published by the Free\n *     Software Foundation; either version 3 of the License, or (at\n *     your option) any later version.\n *\n * or\n *\n *   - the GNU General Public License as published by the Free\n *     Software Foundation; either version 2 of the License, or (at\n *     your option) any later version.\n *\n * or both in parallel, as here.\n *\n * This file is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <https://www.gnu.org/licenses/>.\n */\n\n#include <config.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#ifdef HAVE_W32_SYSTEM\n# ifdef HAVE_WINSOCK2_H\n#  include <winsock2.h>\n# endif\n# include <windows.h>\n#endif\n#ifdef __riscos__\n# include <kernel.h>\n# include <swis.h>\n#endif /* __riscos__ */\n\n#include <assuan.h>\n\n#include \"util.h\"\n#include \"sysutils.h\"\n#include \"iobuf.h\"\n\n/*-- Begin configurable part.  --*/\n\n/* The size of the internal buffers.\n   NOTE: If you change this value you MUST also adjust the regression\n   test \"armored_key_8192\" in armor.test! */\n#define IOBUF_BUFFER_SIZE  8192\n\n/* To avoid a potential DoS with compression packets we better limit\n   the number of filters in a chain.  */\n#define MAX_NESTING_FILTER 64\n\n/*-- End configurable part.  --*/\n\n\n#ifdef HAVE_W32_SYSTEM\n# ifdef HAVE_W32CE_SYSTEM\n#  define FD_FOR_STDIN  (es_fileno (es_stdin))\n#  define FD_FOR_STDOUT (es_fileno (es_stdout))\n# else\n#  define FD_FOR_STDIN  (GetStdHandle (STD_INPUT_HANDLE))\n#  define FD_FOR_STDOUT (GetStdHandle (STD_OUTPUT_HANDLE))\n# endif\n#else /*!HAVE_W32_SYSTEM*/\n# define FD_FOR_STDIN  (0)\n# define FD_FOR_STDOUT (1)\n#endif /*!HAVE_W32_SYSTEM*/\n\n\n/* The context used by the file filter.  */\ntypedef struct\n{\n  gnupg_fd_t fp;       /* Open file pointer or handle.  */\n  int keep_open;\n  int no_cache;\n  int eof_seen;\n  int print_only_name; /* Flags indicating that fname is not a real file.  */\n  char fname[1];       /* Name of the file.  */\n} file_filter_ctx_t;\n\n/* The context used by the estream filter.  */\ntypedef struct\n{\n  estream_t fp;        /* Open estream handle.  */\n  int keep_open;\n  int no_cache;\n  int eof_seen;\n  int print_only_name; /* Flags indicating that fname is not a real file.  */\n  char fname[1];       /* Name of the file.  */\n} file_es_filter_ctx_t;\n\n\n/* Object to control the \"close cache\".  */\nstruct close_cache_s\n{\n  struct close_cache_s *next;\n  gnupg_fd_t fp;\n  char fname[1];\n};\ntypedef struct close_cache_s *close_cache_t;\nstatic close_cache_t close_cache;\n\n\n\n#ifdef HAVE_W32_SYSTEM\ntypedef struct\n{\n  int sock;\n  int keep_open;\n  int no_cache;\n  int eof_seen;\n  int print_only_name;\t/* Flag indicating that fname is not a real file.  */\n  char fname[1];\t/* Name of the file */\n\n} sock_filter_ctx_t;\n#endif /*HAVE_W32_SYSTEM*/\n\n/* The first partial length header block must be of size 512 to make\n * it easier (and more efficient) we use a min. block size of 512 for\n * all chunks (but the last one) */\n#define OP_MIN_PARTIAL_CHUNK\t  512\n#define OP_MIN_PARTIAL_CHUNK_2POW 9\n\n/* The context we use for the block filter (used to handle OpenPGP\n   length information header).  */\ntypedef struct\n{\n  int use;\n  size_t size;\n  size_t count;\n  int partial;\t   /* 1 = partial header, 2 in last partial packet.  */\n  char *buffer;\t   /* Used for partial header.  */\n  size_t buflen;   /* Used size of buffer.  */\n  int first_c;\t   /* First character of a partial header (which is > 0).  */\n  int eof;\n}\nblock_filter_ctx_t;\n\n\n/* Local prototypes.  */\nstatic int underflow (iobuf_t a, int clear_pending_eof);\nstatic int underflow_target (iobuf_t a, int clear_pending_eof, size_t target);\nstatic int translate_file_handle (int fd, int for_write);\n\n/* Sends any pending data to the filter's FILTER function.  Note: this\n   works on the filter and not on the whole pipeline.  That is,\n   iobuf_flush doesn't necessarily cause data to be written to any\n   underlying file; it just causes any data buffered at the filter A\n   to be sent to A's filter function.\n\n   If A is a IOBUF_OUTPUT_TEMP filter, then this also enlarges the\n   buffer by IOBUF_BUFFER_SIZE.\n\n   May only be called on an IOBUF_OUTPUT or IOBUF_OUTPUT_TEMP filters.  */\nstatic int filter_flush (iobuf_t a);\n\n\n\f\n/* This is a replacement for strcmp.  Under W32 it does not\n   distinguish between backslash and slash.  */\nstatic int\nfd_cache_strcmp (const char *a, const char *b)\n{\n#ifdef HAVE_DOSISH_SYSTEM\n  for (; *a && *b; a++, b++)\n    {\n      if (*a != *b && !((*a == '/' && *b == '\\\\')\n                        || (*a == '\\\\' && *b == '/')) )\n        break;\n    }\n  return *(const unsigned char *)a - *(const unsigned char *)b;\n#else\n  return strcmp (a, b);\n#endif\n}\n\n/*\n * Invalidate (i.e. close) a cached iobuf\n */\nstatic int\nfd_cache_invalidate (const char *fname)\n{\n  close_cache_t cc;\n  int rc = 0;\n\n  assert (fname);\n  if (DBG_IOBUF)\n    log_debug (\"fd_cache_invalidate (%s)\\n\", fname);\n\n  for (cc = close_cache; cc; cc = cc->next)\n    {\n      if (cc->fp != GNUPG_INVALID_FD && !fd_cache_strcmp (cc->fname, fname))\n\t{\n\t  if (DBG_IOBUF)\n\t    log_debug (\"                did (%s)\\n\", cc->fname);\n#ifdef HAVE_W32_SYSTEM\n\t  if (!CloseHandle (cc->fp))\n            rc = -1;\n#else\n\t  rc = close (cc->fp);\n#endif\n\t  cc->fp = GNUPG_INVALID_FD;\n\t}\n    }\n  return rc;\n}\n\n\n/* Try to sync changes to the disk.  This is to avoid data loss during\n   a system crash in write/close/rename cycle on some file\n   systems.  */\nstatic int\nfd_cache_synchronize (const char *fname)\n{\n  int err = 0;\n\n#ifdef HAVE_FSYNC\n  close_cache_t cc;\n\n  if (DBG_IOBUF)\n    log_debug (\"fd_cache_synchronize (%s)\\n\", fname);\n\n  for (cc=close_cache; cc; cc = cc->next )\n    {\n      if (cc->fp != GNUPG_INVALID_FD && !fd_cache_strcmp (cc->fname, fname))\n\t{\n\t  if (DBG_IOBUF)\n\t    log_debug (\"                 did (%s)\\n\", cc->fname);\n\n\t  err = fsync (cc->fp);\n\t}\n    }\n#else\n  (void)fname;\n#endif /*HAVE_FSYNC*/\n\n  return err;\n}\n\n\nstatic gnupg_fd_t\ndirect_open (const char *fname, const char *mode, int mode700)\n{\n#ifdef HAVE_W32_SYSTEM\n  unsigned long da, cd, sm;\n  HANDLE hfile;\n\n  (void)mode700;\n  /* Note, that we do not handle all mode combinations */\n\n  /* According to the ReactOS source it seems that open() of the\n   * standard MSW32 crt does open the file in shared mode which is\n   * something new for MS applications ;-)\n   */\n  if (strchr (mode, '+'))\n    {\n      if (fd_cache_invalidate (fname))\n        return GNUPG_INVALID_FD;\n      da = GENERIC_READ | GENERIC_WRITE;\n      cd = OPEN_EXISTING;\n      sm = FILE_SHARE_READ | FILE_SHARE_WRITE;\n    }\n  else if (strchr (mode, 'w'))\n    {\n      if (fd_cache_invalidate (fname))\n        return GNUPG_INVALID_FD;\n      da = GENERIC_WRITE;\n      cd = CREATE_ALWAYS;\n      sm = FILE_SHARE_WRITE;\n    }\n  else\n    {\n      da = GENERIC_READ;\n      cd = OPEN_EXISTING;\n      sm = FILE_SHARE_READ;\n    }\n\n#ifdef HAVE_W32CE_SYSTEM\n  {\n    wchar_t *wfname = utf8_to_wchar (fname);\n    if (wfname)\n      {\n        hfile = CreateFile (wfname, da, sm, NULL, cd,\n                            FILE_ATTRIBUTE_NORMAL, NULL);\n        xfree (wfname);\n      }\n    else\n      hfile = INVALID_HANDLE_VALUE;\n  }\n#else\n  hfile = CreateFile (fname, da, sm, NULL, cd, FILE_ATTRIBUTE_NORMAL, NULL);\n#endif\n  return hfile;\n\n#else /*!HAVE_W32_SYSTEM*/\n\n  int oflag;\n  int cflag = S_IRUSR | S_IWUSR;\n\n  if (!mode700)\n    cflag |= S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n\n  /* Note, that we do not handle all mode combinations */\n  if (strchr (mode, '+'))\n    {\n      if (fd_cache_invalidate (fname))\n        return GNUPG_INVALID_FD;\n      oflag = O_RDWR;\n    }\n  else if (strchr (mode, 'w'))\n    {\n      if (fd_cache_invalidate (fname))\n        return GNUPG_INVALID_FD;\n      oflag = O_WRONLY | O_CREAT | O_TRUNC;\n    }\n  else\n    {\n      oflag = O_RDONLY;\n    }\n#ifdef O_BINARY\n  if (strchr (mode, 'b'))\n    oflag |= O_BINARY;\n#endif\n\n#ifdef __riscos__\n  {\n    struct stat buf;\n\n    /* Don't allow iobufs on directories */\n    if (!stat (fname, &buf) && S_ISDIR (buf.st_mode) && !S_ISREG (buf.st_mode))\n      return __set_errno (EISDIR);\n  }\n#endif\n  return open (fname, oflag, cflag);\n\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n\n/*\n * Instead of closing an FD we keep it open and cache it for later reuse\n * Note that this caching strategy only works if the process does not chdir.\n */\nstatic void\nfd_cache_close (const char *fname, gnupg_fd_t fp)\n{\n  close_cache_t cc;\n\n  assert (fp);\n  if (!fname || !*fname)\n    {\n#ifdef HAVE_W32_SYSTEM\n      CloseHandle (fp);\n#else\n      close (fp);\n#endif\n      if (DBG_IOBUF)\n\tlog_debug (\"fd_cache_close (%d) real\\n\", (int)fp);\n      return;\n    }\n  /* try to reuse a slot */\n  for (cc = close_cache; cc; cc = cc->next)\n    {\n      if (cc->fp == GNUPG_INVALID_FD && !fd_cache_strcmp (cc->fname, fname))\n\t{\n\t  cc->fp = fp;\n\t  if (DBG_IOBUF)\n\t    log_debug (\"fd_cache_close (%s) used existing slot\\n\", fname);\n\t  return;\n\t}\n    }\n  /* add a new one */\n  if (DBG_IOBUF)\n    log_debug (\"fd_cache_close (%s) new slot created\\n\", fname);\n  cc = xcalloc (1, sizeof *cc + strlen (fname));\n  strcpy (cc->fname, fname);\n  cc->fp = fp;\n  cc->next = close_cache;\n  close_cache = cc;\n}\n\n/*\n * Do a direct_open on FNAME but first try to reuse one from the fd_cache\n */\nstatic gnupg_fd_t\nfd_cache_open (const char *fname, const char *mode)\n{\n  close_cache_t cc;\n\n  assert (fname);\n  for (cc = close_cache; cc; cc = cc->next)\n    {\n      if (cc->fp != GNUPG_INVALID_FD && !fd_cache_strcmp (cc->fname, fname))\n\t{\n\t  gnupg_fd_t fp = cc->fp;\n\t  cc->fp = GNUPG_INVALID_FD;\n\t  if (DBG_IOBUF)\n\t    log_debug (\"fd_cache_open (%s) using cached fp\\n\", fname);\n#ifdef HAVE_W32_SYSTEM\n\t  if (SetFilePointer (fp, 0, NULL, FILE_BEGIN) == 0xffffffff)\n\t    {\n\t      log_error (\"rewind file failed on handle %p: ec=%d\\n\",\n\t\t\t fp, (int) GetLastError ());\n\t      fp = GNUPG_INVALID_FD;\n\t    }\n#else\n\t  if (lseek (fp, 0, SEEK_SET) == (off_t) - 1)\n\t    {\n\t      log_error (\"can't rewind fd %d: %s\\n\", fp, strerror (errno));\n\t      fp = GNUPG_INVALID_FD;\n\t    }\n#endif\n\t  return fp;\n\t}\n    }\n  if (DBG_IOBUF)\n    log_debug (\"fd_cache_open (%s) not cached\\n\", fname);\n  return direct_open (fname, mode, 0);\n}\n\n\nstatic int\nfile_filter (void *opaque, int control, iobuf_t chain, byte * buf,\n\t     size_t * ret_len)\n{\n  file_filter_ctx_t *a = opaque;\n  gnupg_fd_t f = a->fp;\n  size_t size = *ret_len;\n  size_t nbytes = 0;\n  int rc = 0;\n\n  (void)chain; /* Not used.  */\n\n  if (control == IOBUFCTRL_UNDERFLOW)\n    {\n      assert (size); /* We need a buffer.  */\n      if (a->eof_seen)\n\t{\n\t  rc = -1;\n\t  *ret_len = 0;\n\t}\n      else\n\t{\n#ifdef HAVE_W32_SYSTEM\n\t  unsigned long nread;\n\n\t  nbytes = 0;\n\t  if (!ReadFile (f, buf, size, &nread, NULL))\n\t    {\n\t      int ec = (int) GetLastError ();\n\t      if (ec != ERROR_BROKEN_PIPE)\n\t\t{\n\t\t  rc = gpg_error_from_errno (ec);\n\t\t  log_error (\"%s: read error: ec=%d\\n\", a->fname, ec);\n\t\t}\n\t    }\n\t  else if (!nread)\n\t    {\n\t      a->eof_seen = 1;\n\t      rc = -1;\n\t    }\n\t  else\n\t    {\n\t      nbytes = nread;\n\t    }\n\n#else\n\n\t  int n;\n\n\t  nbytes = 0;\n\t  do\n\t    {\n\t      n = read (f, buf, size);\n\t    }\n\t  while (n == -1 && errno == EINTR);\n\t  if (n == -1)\n\t    {\t\t\t/* error */\n\t      if (errno != EPIPE)\n\t\t{\n\t\t  rc = gpg_error_from_syserror ();\n\t\t  log_error (\"%s: read error: %s\\n\",\n\t\t\t     a->fname, strerror (errno));\n\t\t}\n\t    }\n\t  else if (!n)\n\t    {\t\t\t/* eof */\n\t      a->eof_seen = 1;\n\t      rc = -1;\n\t    }\n\t  else\n\t    {\n\t      nbytes = n;\n\t    }\n#endif\n\t  *ret_len = nbytes;\n\t}\n    }\n  else if (control == IOBUFCTRL_FLUSH)\n    {\n      if (size)\n\t{\n#ifdef HAVE_W32_SYSTEM\n\t  byte *p = buf;\n\t  unsigned long n;\n\n\t  nbytes = size;\n\t  do\n\t    {\n\t      if (size && !WriteFile (f, p, nbytes, &n, NULL))\n\t\t{\n\t\t  int ec = (int) GetLastError ();\n\t\t  rc = gpg_error_from_errno (ec);\n\t\t  log_error (\"%s: write error: ec=%d\\n\", a->fname, ec);\n\t\t  break;\n\t\t}\n\t      p += n;\n\t      nbytes -= n;\n\t    }\n\t  while (nbytes);\n\t  nbytes = p - buf;\n#else\n\t  byte *p = buf;\n\t  int n;\n\n\t  nbytes = size;\n\t  do\n\t    {\n\t      do\n\t\t{\n\t\t  n = write (f, p, nbytes);\n\t\t}\n\t      while (n == -1 && errno == EINTR);\n\t      if (n > 0)\n\t\t{\n\t\t  p += n;\n\t\t  nbytes -= n;\n\t\t}\n\t    }\n\t  while (n != -1 && nbytes);\n\t  if (n == -1)\n\t    {\n\t      rc = gpg_error_from_syserror ();\n\t      log_error (\"%s: write error: %s\\n\", a->fname, strerror (errno));\n\t    }\n\t  nbytes = p - buf;\n#endif\n\t}\n      *ret_len = nbytes;\n    }\n  else if (control == IOBUFCTRL_INIT)\n    {\n      a->eof_seen = 0;\n      a->keep_open = 0;\n      a->no_cache = 0;\n    }\n  else if (control == IOBUFCTRL_DESC)\n    {\n      mem2str (buf, \"file_filter(fd)\", *ret_len);\n    }\n  else if (control == IOBUFCTRL_FREE)\n    {\n      if (f != FD_FOR_STDIN && f != FD_FOR_STDOUT)\n\t{\n\t  if (DBG_IOBUF)\n\t    log_debug (\"%s: close fd/handle %d\\n\", a->fname, FD2INT (f));\n\t  if (!a->keep_open)\n\t    fd_cache_close (a->no_cache ? NULL : a->fname, f);\n\t}\n      xfree (a); /* We can free our context now. */\n    }\n\n  return rc;\n}\n\n\n/* Similar to file_filter but using the estream system.  */\nstatic int\nfile_es_filter (void *opaque, int control, iobuf_t chain, byte * buf,\n                size_t * ret_len)\n{\n  file_es_filter_ctx_t *a = opaque;\n  estream_t f = a->fp;\n  size_t size = *ret_len;\n  size_t nbytes = 0;\n  int rc = 0;\n\n  (void)chain; /* Not used.  */\n\n  if (control == IOBUFCTRL_UNDERFLOW)\n    {\n      assert (size); /* We need a buffer.  */\n      if (a->eof_seen)\n\t{\n\t  rc = -1;\n\t  *ret_len = 0;\n\t}\n      else\n\t{\n          nbytes = 0;\n          rc = es_read (f, buf, size, &nbytes);\n\t  if (rc == -1)\n\t    {\t\t\t/* error */\n              rc = gpg_error_from_syserror ();\n              log_error (\"%s: read error: %s\\n\", a->fname, strerror (errno));\n\t    }\n\t  else if (!nbytes)\n\t    {\t\t\t/* eof */\n\t      a->eof_seen = 1;\n\t      rc = -1;\n\t    }\n\t  *ret_len = nbytes;\n\t}\n    }\n  else if (control == IOBUFCTRL_FLUSH)\n    {\n      if (size)\n\t{\n\t  byte *p = buf;\n\t  size_t nwritten;\n\n\t  nbytes = size;\n\t  do\n\t    {\n              nwritten = 0;\n              if (es_write (f, p, nbytes, &nwritten))\n                {\n                  rc = gpg_error_from_syserror ();\n                  log_error (\"%s: write error: %s\\n\",\n                             a->fname, strerror (errno));\n                  break;\n                }\n              p += nwritten;\n              nbytes -= nwritten;\n\t    }\n\t  while (nbytes);\n\t  nbytes = p - buf;\n\t}\n      *ret_len = nbytes;\n    }\n  else if (control == IOBUFCTRL_INIT)\n    {\n      a->eof_seen = 0;\n      a->no_cache = 0;\n    }\n  else if (control == IOBUFCTRL_DESC)\n    {\n      mem2str (buf, \"estream_filter\", *ret_len);\n    }\n  else if (control == IOBUFCTRL_FREE)\n    {\n      if (f != es_stdin && f != es_stdout)\n\t{\n\t  if (DBG_IOBUF)\n\t    log_debug (\"%s: es_fclose %p\\n\", a->fname, f);\n\t  if (!a->keep_open)\n\t    es_fclose (f);\n\t}\n      f = NULL;\n      xfree (a); /* We can free our context now. */\n    }\n\n  return rc;\n}\n\n\n#ifdef HAVE_W32_SYSTEM\n/* Because network sockets are special objects under Lose32 we have to\n   use a dedicated filter for them. */\nstatic int\nsock_filter (void *opaque, int control, iobuf_t chain, byte * buf,\n\t     size_t * ret_len)\n{\n  sock_filter_ctx_t *a = opaque;\n  size_t size = *ret_len;\n  size_t nbytes = 0;\n  int rc = 0;\n\n  (void)chain;\n\n  if (control == IOBUFCTRL_UNDERFLOW)\n    {\n      assert (size);\t\t/* need a buffer */\n      if (a->eof_seen)\n\t{\n\t  rc = -1;\n\t  *ret_len = 0;\n\t}\n      else\n\t{\n\t  int nread;\n\n\t  nread = recv (a->sock, buf, size, 0);\n\t  if (nread == SOCKET_ERROR)\n\t    {\n\t      int ec = (int) WSAGetLastError ();\n\t      rc = gpg_error_from_errno (ec);\n\t      log_error (\"socket read error: ec=%d\\n\", ec);\n\t    }\n\t  else if (!nread)\n\t    {\n\t      a->eof_seen = 1;\n\t      rc = -1;\n\t    }\n\t  else\n\t    {\n\t      nbytes = nread;\n\t    }\n\t  *ret_len = nbytes;\n\t}\n    }\n  else if (control == IOBUFCTRL_FLUSH)\n    {\n      if (size)\n\t{\n\t  byte *p = buf;\n\t  int n;\n\n\t  nbytes = size;\n\t  do\n\t    {\n\t      n = send (a->sock, p, nbytes, 0);\n\t      if (n == SOCKET_ERROR)\n\t\t{\n\t\t  int ec = (int) WSAGetLastError ();\n\t\t  rc = gpg_error_from_errno (ec);\n\t\t  log_error (\"socket write error: ec=%d\\n\", ec);\n\t\t  break;\n\t\t}\n\t      p += n;\n\t      nbytes -= n;\n\t    }\n\t  while (nbytes);\n\t  nbytes = p - buf;\n\t}\n      *ret_len = nbytes;\n    }\n  else if (control == IOBUFCTRL_INIT)\n    {\n      a->eof_seen = 0;\n      a->keep_open = 0;\n      a->no_cache = 0;\n    }\n  else if (control == IOBUFCTRL_DESC)\n    {\n      mem2str (buf, \"sock_filter\", *ret_len);\n    }\n  else if (control == IOBUFCTRL_FREE)\n    {\n      if (!a->keep_open)\n\tclosesocket (a->sock);\n      xfree (a);\t\t/* we can free our context now */\n    }\n  return rc;\n}\n#endif /*HAVE_W32_SYSTEM*/\n\n/****************\n * This is used to implement the block write mode.\n * Block reading is done on a byte by byte basis in readbyte(),\n * without a filter\n */\nstatic int\nblock_filter (void *opaque, int control, iobuf_t chain, byte * buffer,\n\t      size_t * ret_len)\n{\n  block_filter_ctx_t *a = opaque;\n  char *buf = (char *)buffer;\n  size_t size = *ret_len;\n  int c, needed, rc = 0;\n  char *p;\n\n  if (control == IOBUFCTRL_UNDERFLOW)\n    {\n      size_t n = 0;\n\n      p = buf;\n      assert (size);\t\t/* need a buffer */\n      if (a->eof)\t\t/* don't read any further */\n\trc = -1;\n      while (!rc && size)\n\t{\n\t  if (!a->size)\n\t    {\t\t\t/* get the length bytes */\n\t      if (a->partial == 2)\n\t\t{\n\t\t  a->eof = 1;\n\t\t  if (!n)\n\t\t    rc = -1;\n\t\t  break;\n\t\t}\n\t      else if (a->partial)\n\t\t{\n\t\t  /* These OpenPGP introduced huffman like encoded length\n\t\t   * bytes are really a mess :-( */\n\t\t  if (a->first_c)\n\t\t    {\n\t\t      c = a->first_c;\n\t\t      a->first_c = 0;\n\t\t    }\n\t\t  else if ((c = iobuf_get (chain)) == -1)\n\t\t    {\n\t\t      log_error (\"block_filter: 1st length byte missing\\n\");\n\t\t      rc = GPG_ERR_BAD_DATA;\n\t\t      break;\n\t\t    }\n\t\t  if (c < 192)\n\t\t    {\n\t\t      a->size = c;\n\t\t      a->partial = 2;\n\t\t      if (!a->size)\n\t\t\t{\n\t\t\t  a->eof = 1;\n\t\t\t  if (!n)\n\t\t\t    rc = -1;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  else if (c < 224)\n\t\t    {\n\t\t      a->size = (c - 192) * 256;\n\t\t      if ((c = iobuf_get (chain)) == -1)\n\t\t\t{\n\t\t\t  log_error\n\t\t\t    (\"block_filter: 2nd length byte missing\\n\");\n\t\t\t  rc = GPG_ERR_BAD_DATA;\n\t\t\t  break;\n\t\t\t}\n\t\t      a->size += c + 192;\n\t\t      a->partial = 2;\n\t\t      if (!a->size)\n\t\t\t{\n\t\t\t  a->eof = 1;\n\t\t\t  if (!n)\n\t\t\t    rc = -1;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  else if (c == 255)\n\t\t    {\n\t\t      a->size = iobuf_get_noeof (chain) << 24;\n\t\t      a->size |= iobuf_get_noeof (chain) << 16;\n\t\t      a->size |= iobuf_get_noeof (chain) << 8;\n\t\t      if ((c = iobuf_get (chain)) == -1)\n\t\t\t{\n\t\t\t  log_error (\"block_filter: invalid 4 byte length\\n\");\n\t\t\t  rc = GPG_ERR_BAD_DATA;\n\t\t\t  break;\n\t\t\t}\n\t\t      a->size |= c;\n                      a->partial = 2;\n                      if (!a->size)\n                        {\n                          a->eof = 1;\n                          if (!n)\n                            rc = -1;\n                          break;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    { /* Next partial body length. */\n\t\t      a->size = 1 << (c & 0x1f);\n\t\t    }\n\t\t  /*  log_debug(\"partial: ctx=%p c=%02x size=%u\\n\", a, c, a->size); */\n\t\t}\n\t      else\n\t\tBUG ();\n\t    }\n\n\t  while (!rc && size && a->size)\n\t    {\n\t      needed = size < a->size ? size : a->size;\n\t      c = iobuf_read (chain, p, needed);\n\t      if (c < needed)\n\t\t{\n\t\t  if (c == -1)\n\t\t    c = 0;\n\t\t  log_error\n\t\t    (\"block_filter %p: read error (size=%lu,a->size=%lu)\\n\",\n\t\t     a, (ulong) size + c, (ulong) a->size + c);\n\t\t  rc = GPG_ERR_BAD_DATA;\n\t\t}\n\t      else\n\t\t{\n\t\t  size -= c;\n\t\t  a->size -= c;\n\t\t  p += c;\n\t\t  n += c;\n\t\t}\n\t    }\n\t}\n      *ret_len = n;\n    }\n  else if (control == IOBUFCTRL_FLUSH)\n    {\n      if (a->partial)\n\t{\t\t\t/* the complicated openpgp scheme */\n\t  size_t blen, n, nbytes = size + a->buflen;\n\n\t  assert (a->buflen <= OP_MIN_PARTIAL_CHUNK);\n\t  if (nbytes < OP_MIN_PARTIAL_CHUNK)\n\t    {\n\t      /* not enough to write a partial block out; so we store it */\n\t      if (!a->buffer)\n\t\ta->buffer = xmalloc (OP_MIN_PARTIAL_CHUNK);\n\t      memcpy (a->buffer + a->buflen, buf, size);\n\t      a->buflen += size;\n\t    }\n\t  else\n\t    {\t\t\t/* okay, we can write out something */\n\t      /* do this in a loop to use the most efficient block lengths */\n\t      p = buf;\n\t      do\n\t\t{\n\t\t  /* find the best matching block length - this is limited\n\t\t   * by the size of the internal buffering */\n\t\t  for (blen = OP_MIN_PARTIAL_CHUNK * 2,\n\t\t       c = OP_MIN_PARTIAL_CHUNK_2POW + 1; blen <= nbytes;\n\t\t       blen *= 2, c++)\n\t\t    ;\n\t\t  blen /= 2;\n\t\t  c--;\n\t\t  /* write the partial length header */\n\t\t  assert (c <= 0x1f);\t/*;-) */\n\t\t  c |= 0xe0;\n\t\t  iobuf_put (chain, c);\n\t\t  if ((n = a->buflen))\n\t\t    {\t\t/* write stuff from the buffer */\n\t\t      assert (n == OP_MIN_PARTIAL_CHUNK);\n\t\t      if (iobuf_write (chain, a->buffer, n))\n\t\t\trc = gpg_error_from_syserror ();\n\t\t      a->buflen = 0;\n\t\t      nbytes -= n;\n\t\t    }\n\t\t  if ((n = nbytes) > blen)\n\t\t    n = blen;\n\t\t  if (n && iobuf_write (chain, p, n))\n\t\t    rc = gpg_error_from_syserror ();\n\t\t  p += n;\n\t\t  nbytes -= n;\n\t\t}\n\t      while (!rc && nbytes >= OP_MIN_PARTIAL_CHUNK);\n\t      /* store the rest in the buffer */\n\t      if (!rc && nbytes)\n\t\t{\n\t\t  assert (!a->buflen);\n\t\t  assert (nbytes < OP_MIN_PARTIAL_CHUNK);\n\t\t  if (!a->buffer)\n\t\t    a->buffer = xmalloc (OP_MIN_PARTIAL_CHUNK);\n\t\t  memcpy (a->buffer, p, nbytes);\n\t\t  a->buflen = nbytes;\n\t\t}\n\t    }\n\t}\n      else\n\tBUG ();\n    }\n  else if (control == IOBUFCTRL_INIT)\n    {\n      if (DBG_IOBUF)\n\tlog_debug (\"init block_filter %p\\n\", a);\n      if (a->partial)\n\ta->count = 0;\n      else if (a->use == IOBUF_INPUT)\n\ta->count = a->size = 0;\n      else\n\ta->count = a->size;\t/* force first length bytes */\n      a->eof = 0;\n      a->buffer = NULL;\n      a->buflen = 0;\n    }\n  else if (control == IOBUFCTRL_DESC)\n    {\n      mem2str (buf, \"block_filter\", *ret_len);\n    }\n  else if (control == IOBUFCTRL_FREE)\n    {\n      if (a->use == IOBUF_OUTPUT)\n\t{\t\t\t/* write the end markers */\n\t  if (a->partial)\n\t    {\n\t      u32 len;\n\t      /* write out the remaining bytes without a partial header\n\t       * the length of this header may be 0 - but if it is\n\t       * the first block we are not allowed to use a partial header\n\t       * and frankly we can't do so, because this length must be\n\t       * a power of 2. This is _really_ complicated because we\n\t       * have to check the possible length of a packet prior\n\t       * to it's creation: a chain of filters becomes complicated\n\t       * and we need a lot of code to handle compressed packets etc.\n\t       *   :-(((((((\n\t       */\n\t      /* construct header */\n\t      len = a->buflen;\n\t      /*log_debug(\"partial: remaining length=%u\\n\", len ); */\n\t      if (len < 192)\n\t\trc = iobuf_put (chain, len);\n\t      else if (len < 8384)\n\t\t{\n\t\t  if (!(rc = iobuf_put (chain, ((len - 192) / 256) + 192)))\n\t\t    rc = iobuf_put (chain, ((len - 192) % 256));\n\t\t}\n\t      else\n\t\t{\t\t/* use a 4 byte header */\n\t\t  if (!(rc = iobuf_put (chain, 0xff)))\n\t\t    if (!(rc = iobuf_put (chain, (len >> 24) & 0xff)))\n\t\t      if (!(rc = iobuf_put (chain, (len >> 16) & 0xff)))\n\t\t\tif (!(rc = iobuf_put (chain, (len >> 8) & 0xff)))\n\t\t\t  rc = iobuf_put (chain, len & 0xff);\n\t\t}\n\t      if (!rc && len)\n\t\trc = iobuf_write (chain, a->buffer, len);\n\t      if (rc)\n\t\t{\n\t\t  log_error (\"block_filter: write error: %s\\n\",\n\t\t\t     strerror (errno));\n\t\t  rc = gpg_error_from_syserror ();\n\t\t}\n\t      xfree (a->buffer);\n\t      a->buffer = NULL;\n\t      a->buflen = 0;\n\t    }\n\t  else\n\t    BUG ();\n\t}\n      else if (a->size)\n\t{\n\t  log_error (\"block_filter: pending bytes!\\n\");\n\t}\n      if (DBG_IOBUF)\n\tlog_debug (\"free block_filter %p\\n\", a);\n      xfree (a);\t\t/* we can free our context now */\n    }\n\n  return rc;\n}\n\n#define MAX_IOBUF_DESC 32\n/*\n * Fill the buffer by the description of iobuf A.\n * The buffer size should be MAX_IOBUF_DESC (or larger).\n * Returns BUF as (const char *).\n */\nstatic const char *\niobuf_desc (iobuf_t a, byte *buf)\n{\n  size_t len = MAX_IOBUF_DESC;\n\n  if (! a || ! a->filter)\n    memcpy (buf, \"?\", 2);\n  else\n    a->filter (a->filter_ov, IOBUFCTRL_DESC, NULL, buf, &len);\n\n  return buf;\n}\n\nstatic void\nprint_chain (iobuf_t a)\n{\n  if (!DBG_IOBUF)\n    return;\n  for (; a; a = a->chain)\n    {\n      byte desc[MAX_IOBUF_DESC];\n\n      log_debug (\"iobuf chain: %d.%d '%s' filter_eof=%d start=%d len=%d\\n\",\n\t\t a->no, a->subno, iobuf_desc (a, desc), a->filter_eof,\n\t\t (int) a->d.start, (int) a->d.len);\n    }\n}\n\nint\niobuf_print_chain (iobuf_t a)\n{\n  print_chain (a);\n  return 0;\n}\n\niobuf_t\niobuf_alloc (int use, size_t bufsize)\n{\n  iobuf_t a;\n  static int number = 0;\n\n  assert (use == IOBUF_INPUT || use == IOBUF_INPUT_TEMP\n\t  || use == IOBUF_OUTPUT || use == IOBUF_OUTPUT_TEMP);\n  if (bufsize == 0)\n    {\n      log_bug (\"iobuf_alloc() passed a bufsize of 0!\\n\");\n      bufsize = IOBUF_BUFFER_SIZE;\n    }\n\n  a = xcalloc (1, sizeof *a);\n  a->use = use;\n  a->d.buf = xmalloc (bufsize);\n  a->d.size = bufsize;\n  a->no = ++number;\n  a->subno = 0;\n  a->real_fname = NULL;\n  return a;\n}\n\nint\niobuf_close (iobuf_t a)\n{\n  iobuf_t a_chain;\n  size_t dummy_len = 0;\n  int rc = 0;\n\n  for (; a; a = a_chain)\n    {\n      byte desc[MAX_IOBUF_DESC];\n      int rc2 = 0;\n\n      a_chain = a->chain;\n\n      if (a->use == IOBUF_OUTPUT && (rc = filter_flush (a)))\n\tlog_error (\"filter_flush failed on close: %s\\n\", gpg_strerror (rc));\n\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: close '%s'\\n\",\n\t\t   a->no, a->subno, iobuf_desc (a, desc));\n\n      if (a->filter && (rc2 = a->filter (a->filter_ov, IOBUFCTRL_FREE,\n\t\t\t\t\t a->chain, NULL, &dummy_len)))\n\tlog_error (\"IOBUFCTRL_FREE failed on close: %s\\n\", gpg_strerror (rc));\n      if (! rc && rc2)\n\t/* Whoops!  An error occurred.  Save it in RC if we haven't\n\t   already recorded an error.  */\n\trc = rc2;\n\n      xfree (a->real_fname);\n      if (a->d.buf)\n\t{\n\t  memset (a->d.buf, 0, a->d.size);\t/* erase the buffer */\n\t  xfree (a->d.buf);\n\t}\n      xfree (a);\n    }\n  return rc;\n}\n\nint\niobuf_cancel (iobuf_t a)\n{\n  const char *s;\n  iobuf_t a2;\n  int rc;\n#if defined(HAVE_W32_SYSTEM) || defined(__riscos__)\n  char *remove_name = NULL;\n#endif\n\n  if (a && a->use == IOBUF_OUTPUT)\n    {\n      s = iobuf_get_real_fname (a);\n      if (s && *s)\n\t{\n#if defined(HAVE_W32_SYSTEM) || defined(__riscos__)\n\t  remove_name = xstrdup (s);\n#else\n\t  remove (s);\n#endif\n\t}\n    }\n\n  /* send a cancel message to all filters */\n  for (a2 = a; a2; a2 = a2->chain)\n    {\n      size_t dummy;\n      if (a2->filter)\n\ta2->filter (a2->filter_ov, IOBUFCTRL_CANCEL, a2->chain, NULL, &dummy);\n    }\n\n  rc = iobuf_close (a);\n#if defined(HAVE_W32_SYSTEM) || defined(__riscos__)\n  if (remove_name)\n    {\n      /* Argg, MSDOS does not allow removing open files.  So\n       * we have to do it here */\n#ifdef HAVE_W32CE_SYSTEM\n      wchar_t *wtmp = utf8_to_wchar (remove_name);\n      if (wtmp)\n        DeleteFile (wtmp);\n      xfree (wtmp);\n#else\n      remove (remove_name);\n#endif\n      xfree (remove_name);\n    }\n#endif\n  return rc;\n}\n\n\niobuf_t\niobuf_temp (void)\n{\n  return iobuf_alloc (IOBUF_OUTPUT_TEMP, IOBUF_BUFFER_SIZE);\n}\n\niobuf_t\niobuf_temp_with_content (const char *buffer, size_t length)\n{\n  iobuf_t a;\n  int i;\n\n  a = iobuf_alloc (IOBUF_INPUT_TEMP, length);\n  assert (length == a->d.size);\n  /* memcpy (a->d.buf, buffer, length); */\n  for (i=0; i < length; i++)\n    a->d.buf[i] = buffer[i];\n  a->d.len = length;\n\n  return a;\n}\n\n\nint\niobuf_is_pipe_filename (const char *fname)\n{\n  if (!fname || (*fname=='-' && !fname[1]) )\n    return 1;\n  return check_special_filename (fname, 0, 1) != -1;\n}\n\n\nstatic iobuf_t\ndo_open (const char *fname, int special_filenames,\n\t int use, const char *opentype, int mode700)\n{\n  iobuf_t a;\n  gnupg_fd_t fp;\n  file_filter_ctx_t *fcx;\n  size_t len = 0;\n  int print_only = 0;\n  int fd;\n  byte desc[MAX_IOBUF_DESC];\n\n  assert (use == IOBUF_INPUT || use == IOBUF_OUTPUT);\n\n  if (special_filenames\n      /* NULL or '-'.  */\n      && (!fname || (*fname == '-' && !fname[1])))\n    {\n      if (use == IOBUF_INPUT)\n\t{\n\t  fp = FD_FOR_STDIN;\n\t  fname = \"[stdin]\";\n\t}\n      else\n\t{\n\t  fp = FD_FOR_STDOUT;\n\t  fname = \"[stdout]\";\n\t}\n      print_only = 1;\n    }\n  else if (!fname)\n    return NULL;\n  else if (special_filenames\n           && (fd = check_special_filename (fname, 0, 1)) != -1)\n    return iobuf_fdopen (translate_file_handle (fd, use == IOBUF_INPUT ? 0 : 1),\n\t\t\t opentype);\n  else\n    {\n      if (use == IOBUF_INPUT)\n\tfp = fd_cache_open (fname, opentype);\n      else\n\tfp = direct_open (fname, opentype, mode700);\n      if (fp == GNUPG_INVALID_FD)\n\treturn NULL;\n    }\n\n  a = iobuf_alloc (use, IOBUF_BUFFER_SIZE);\n  fcx = xmalloc (sizeof *fcx + strlen (fname));\n  fcx->fp = fp;\n  fcx->print_only_name = print_only;\n  strcpy (fcx->fname, fname);\n  if (!print_only)\n    a->real_fname = xstrdup (fname);\n  a->filter = file_filter;\n  a->filter_ov = fcx;\n  file_filter (fcx, IOBUFCTRL_INIT, NULL, NULL, &len);\n  if (DBG_IOBUF)\n    log_debug (\"iobuf-%d.%d: open '%s' desc=%s fd=%d\\n\",\n\t       a->no, a->subno, fname, iobuf_desc (a, desc), FD2INT (fcx->fp));\n\n  return a;\n}\n\niobuf_t\niobuf_open (const char *fname)\n{\n  return do_open (fname, 1, IOBUF_INPUT, \"rb\", 0);\n}\n\niobuf_t\niobuf_create (const char *fname, int mode700)\n{\n  return do_open (fname, 1, IOBUF_OUTPUT, \"wb\", mode700);\n}\n\niobuf_t\niobuf_openrw (const char *fname)\n{\n  return do_open (fname, 0, IOBUF_OUTPUT, \"r+b\", 0);\n}\n\n\nstatic iobuf_t\ndo_iobuf_fdopen (int fd, const char *mode, int keep_open)\n{\n  iobuf_t a;\n  gnupg_fd_t fp;\n  file_filter_ctx_t *fcx;\n  size_t len;\n\n  fp = INT2FD (fd);\n\n  a = iobuf_alloc (strchr (mode, 'w') ? IOBUF_OUTPUT : IOBUF_INPUT,\n\t\t   IOBUF_BUFFER_SIZE);\n  fcx = xmalloc (sizeof *fcx + 20);\n  fcx->fp = fp;\n  fcx->print_only_name = 1;\n  fcx->keep_open = keep_open;\n  sprintf (fcx->fname, \"[fd %d]\", fd);\n  a->filter = file_filter;\n  a->filter_ov = fcx;\n  file_filter (fcx, IOBUFCTRL_INIT, NULL, NULL, &len);\n  if (DBG_IOBUF)\n    log_debug (\"iobuf-%d.%d: fdopen%s '%s'\\n\",\n               a->no, a->subno, keep_open? \"_nc\":\"\", fcx->fname);\n  iobuf_ioctl (a, IOBUF_IOCTL_NO_CACHE, 1, NULL);\n  return a;\n}\n\n\niobuf_t\niobuf_fdopen (int fd, const char *mode)\n{\n  return do_iobuf_fdopen (fd, mode, 0);\n}\n\niobuf_t\niobuf_fdopen_nc (int fd, const char *mode)\n{\n  return do_iobuf_fdopen (fd, mode, 1);\n}\n\n\niobuf_t\niobuf_esopen (estream_t estream, const char *mode, int keep_open)\n{\n  iobuf_t a;\n  file_es_filter_ctx_t *fcx;\n  size_t len = 0;\n\n  a = iobuf_alloc (strchr (mode, 'w') ? IOBUF_OUTPUT : IOBUF_INPUT,\n\t\t   IOBUF_BUFFER_SIZE);\n  fcx = xtrymalloc (sizeof *fcx + 30);\n  fcx->fp = estream;\n  fcx->print_only_name = 1;\n  fcx->keep_open = keep_open;\n  sprintf (fcx->fname, \"[fd %p]\", estream);\n  a->filter = file_es_filter;\n  a->filter_ov = fcx;\n  file_es_filter (fcx, IOBUFCTRL_INIT, NULL, NULL, &len);\n  if (DBG_IOBUF)\n    log_debug (\"iobuf-%d.%d: esopen%s '%s'\\n\",\n               a->no, a->subno, keep_open? \"_nc\":\"\", fcx->fname);\n  return a;\n}\n\n\niobuf_t\niobuf_sockopen (int fd, const char *mode)\n{\n  iobuf_t a;\n#ifdef HAVE_W32_SYSTEM\n  sock_filter_ctx_t *scx;\n  size_t len;\n\n  a = iobuf_alloc (strchr (mode, 'w') ? IOBUF_OUTPUT : IOBUF_INPUT,\n\t\t   IOBUF_BUFFER_SIZE);\n  scx = xmalloc (sizeof *scx + 25);\n  scx->sock = fd;\n  scx->print_only_name = 1;\n  sprintf (scx->fname, \"[sock %d]\", fd);\n  a->filter = sock_filter;\n  a->filter_ov = scx;\n  sock_filter (scx, IOBUFCTRL_INIT, NULL, NULL, &len);\n  if (DBG_IOBUF)\n    log_debug (\"iobuf-%d.%d: sockopen '%s'\\n\", a->no, a->subno, scx->fname);\n  iobuf_ioctl (a, IOBUF_IOCTL_NO_CACHE, 1, NULL);\n#else\n  a = iobuf_fdopen (fd, mode);\n#endif\n  return a;\n}\n\nint\niobuf_ioctl (iobuf_t a, iobuf_ioctl_t cmd, int intval, void *ptrval)\n{\n  byte desc[MAX_IOBUF_DESC];\n\n  if (cmd == IOBUF_IOCTL_KEEP_OPEN)\n    {\n      /* Keep system filepointer/descriptor open.  This was used in\n         the past by http.c; this ioctl is not directly used\n         anymore.  */\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: ioctl '%s' keep_open=%d\\n\",\n\t\t   a ? a->no : -1, a ? a->subno : -1, iobuf_desc (a, desc),\n\t\t   intval);\n      for (; a; a = a->chain)\n\tif (!a->chain && a->filter == file_filter)\n\t  {\n\t    file_filter_ctx_t *b = a->filter_ov;\n\t    b->keep_open = intval;\n\t    return 0;\n\t  }\n#ifdef HAVE_W32_SYSTEM\n\telse if (!a->chain && a->filter == sock_filter)\n\t  {\n\t    sock_filter_ctx_t *b = a->filter_ov;\n\t    b->keep_open = intval;\n\t    return 0;\n\t  }\n#endif\n    }\n  else if (cmd == IOBUF_IOCTL_INVALIDATE_CACHE)\n    {\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-*.*: ioctl '%s' invalidate\\n\",\n\t\t   ptrval ? (char *) ptrval : \"?\");\n      if (!a && !intval && ptrval)\n\t{\n\t  if (fd_cache_invalidate (ptrval))\n            return -1;\n\t  return 0;\n\t}\n    }\n  else if (cmd == IOBUF_IOCTL_NO_CACHE)\n    {\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: ioctl '%s' no_cache=%d\\n\",\n\t\t   a ? a->no : -1, a ? a->subno : -1, iobuf_desc (a, desc),\n\t\t   intval);\n      for (; a; a = a->chain)\n\tif (!a->chain && a->filter == file_filter)\n\t  {\n\t    file_filter_ctx_t *b = a->filter_ov;\n\t    b->no_cache = intval;\n\t    return 0;\n\t  }\n#ifdef HAVE_W32_SYSTEM\n\telse if (!a->chain && a->filter == sock_filter)\n\t  {\n\t    sock_filter_ctx_t *b = a->filter_ov;\n\t    b->no_cache = intval;\n\t    return 0;\n\t  }\n#endif\n    }\n  else if (cmd == IOBUF_IOCTL_FSYNC)\n    {\n      /* Do a fsync on the open fd and return any errors to the caller\n         of iobuf_ioctl.  Note that we work on a file name here. */\n      if (DBG_IOBUF)\n        log_debug (\"iobuf-*.*: ioctl '%s' fsync\\n\",\n                   ptrval? (const char*)ptrval:\"<null>\");\n\n      if (!a && !intval && ptrval)\n        {\n          return fd_cache_synchronize (ptrval);\n        }\n    }\n\n\n  return -1;\n}\n\n\n/****************\n * Register an i/o filter.\n */\nint\niobuf_push_filter (iobuf_t a,\n\t\t   int (*f) (void *opaque, int control,\n\t\t\t     iobuf_t chain, byte * buf, size_t * len),\n                   void *ov)\n{\n  return iobuf_push_filter2 (a, f, ov, 0);\n}\n\nint\niobuf_push_filter2 (iobuf_t a,\n\t\t    int (*f) (void *opaque, int control,\n\t\t\t      iobuf_t chain, byte * buf, size_t * len),\n\t\t    void *ov, int rel_ov)\n{\n  iobuf_t b;\n  size_t dummy_len = 0;\n  int rc = 0;\n\n  if (a->use == IOBUF_OUTPUT && (rc = filter_flush (a)))\n    return rc;\n\n  if (a->subno >= MAX_NESTING_FILTER)\n    {\n      log_error (\"i/o filter too deeply nested - corrupted data?\\n\");\n      return GPG_ERR_BAD_DATA;\n    }\n\n  /* We want to create a new filter and put it in front of A.  A\n     simple implementation would do:\n\n       b = iobuf_alloc (...);\n       b->chain = a;\n       return a;\n\n     This is a bit problematic: A is the head of the pipeline and\n     there are potentially many pointers to it.  Requiring the caller\n     to update all of these pointers is a burden.\n\n     An alternative implementation would add a level of indirection.\n     For instance, we could use a pipeline object, which contains a\n     pointer to the first filter in the pipeline.  This is not what we\n     do either.\n\n     Instead, we allocate a new buffer (B) and copy the first filter's\n     state into that and use the initial buffer (A) for the new\n     filter.  One limitation of this approach is that it is not\n     practical to maintain a pointer to a specific filter's state.\n\n     Before:\n\n           A\n           |\n           v 0x100               0x200\n           +----------+          +----------+\n           | filter x |--------->| filter y |---->....\n           +----------+          +----------+\n\n     After:           B\n                      |\n                      v 0x300\n                      +----------+\n           A          | filter x |\n           |          +----------+\n           v 0x100    ^          v 0x200\n           +----------+          +----------+\n           | filter w |          | filter y |---->....\n           +----------+          +----------+\n\n     Note: filter x's address changed from 0x100 to 0x300, but A still\n     points to the head of the pipeline.\n  */\n\n  b = xmalloc (sizeof *b);\n  memcpy (b, a, sizeof *b);\n  /* fixme: it is stupid to keep a copy of the name at every level\n   * but we need the name somewhere because the name known by file_filter\n   * may have been released when we need the name of the file */\n  b->real_fname = a->real_fname ? xstrdup (a->real_fname) : NULL;\n  /* remove the filter stuff from the new stream */\n  a->filter = NULL;\n  a->filter_ov = NULL;\n  a->filter_ov_owner = 0;\n  a->filter_eof = 0;\n  if (a->use == IOBUF_OUTPUT_TEMP)\n    /* A TEMP filter buffers any data sent to it; it does not forward\n       any data down the pipeline.  If we add a new filter to the\n       pipeline, it shouldn't also buffer data.  It should send it\n       downstream to be buffered.  Thus, the correct type for a filter\n       added in front of an IOBUF_OUTPUT_TEMP filter is IOBUF_OUPUT, not\n       IOBUF_OUTPUT_TEMP.  */\n    {\n      a->use = IOBUF_OUTPUT;\n\n      /* When pipeline is written to, the temp buffer's size is\n\t increased accordingly.  We don't need to allocate a 10 MB\n\t buffer for a non-terminal filter.  Just use the default\n\t size.  */\n      a->d.size = IOBUF_BUFFER_SIZE;\n    }\n  else if (a->use == IOBUF_INPUT_TEMP)\n    /* Same idea as above.  */\n    {\n      a->use = IOBUF_INPUT;\n      a->d.size = IOBUF_BUFFER_SIZE;\n    }\n\n  /* The new filter (A) gets a new buffer.\n\n     If the pipeline is an output or temp pipeline, then giving the\n     buffer to the new filter means that data that was written before\n     the filter was pushed gets sent to the filter.  That's clearly\n     wrong.\n\n     If the pipeline is an input pipeline, then giving the buffer to\n     the new filter (A) means that data that has read from (B), but\n     not yet read from the pipeline won't be processed by the new\n     filter (A)!  That's certainly not what we want.  */\n  a->d.buf = xmalloc (a->d.size);\n  a->d.len = 0;\n  a->d.start = 0;\n\n  /* disable nlimit for the new stream */\n  a->ntotal = b->ntotal + b->nbytes;\n  a->nlimit = a->nbytes = 0;\n  a->nofast = 0;\n  /* make a link from the new stream to the original stream */\n  a->chain = b;\n\n  /* setup the function on the new stream */\n  a->filter = f;\n  a->filter_ov = ov;\n  a->filter_ov_owner = rel_ov;\n\n  a->subno = b->subno + 1;\n\n  if (DBG_IOBUF)\n    {\n      byte desc[MAX_IOBUF_DESC];\n      log_debug (\"iobuf-%d.%d: push '%s'\\n\",\n\t\t a->no, a->subno, iobuf_desc (a, desc));\n      print_chain (a);\n    }\n\n  /* now we can initialize the new function if we have one */\n  if (a->filter && (rc = a->filter (a->filter_ov, IOBUFCTRL_INIT, a->chain,\n\t\t\t\t    NULL, &dummy_len)))\n    log_error (\"IOBUFCTRL_INIT failed: %s\\n\", gpg_strerror (rc));\n  return rc;\n}\n\n/****************\n * Remove an i/o filter.\n */\nint\niobuf_pop_filter (iobuf_t a, int (*f) (void *opaque, int control,\n                                       iobuf_t chain, byte * buf, size_t * len),\n                  void *ov)\n{\n  iobuf_t b;\n  size_t dummy_len = 0;\n  int rc = 0;\n  byte desc[MAX_IOBUF_DESC];\n\n  if (DBG_IOBUF)\n    log_debug (\"iobuf-%d.%d: pop '%s'\\n\",\n\t       a->no, a->subno, iobuf_desc (a, desc));\n  if (a->use == IOBUF_INPUT_TEMP || a->use == IOBUF_OUTPUT_TEMP)\n    {\n      /* This should be the last filter in the pipeline.  */\n      assert (! a->chain);\n      return 0;\n    }\n  if (!a->filter)\n    {\t\t\t\t/* this is simple */\n      b = a->chain;\n      assert (b);\n      xfree (a->d.buf);\n      xfree (a->real_fname);\n      memcpy (a, b, sizeof *a);\n      xfree (b);\n      return 0;\n    }\n  for (b = a; b; b = b->chain)\n    if (b->filter == f && (!ov || b->filter_ov == ov))\n      break;\n  if (!b)\n    log_bug (\"iobuf_pop_filter(): filter function not found\\n\");\n\n  /* flush this stream if it is an output stream */\n  if (a->use == IOBUF_OUTPUT && (rc = filter_flush (b)))\n    {\n      log_error (\"filter_flush failed in iobuf_pop_filter: %s\\n\",\n                 gpg_strerror (rc));\n      return rc;\n    }\n  /* and tell the filter to free it self */\n  if (b->filter && (rc = b->filter (b->filter_ov, IOBUFCTRL_FREE, b->chain,\n\t\t\t\t    NULL, &dummy_len)))\n    {\n      log_error (\"IOBUFCTRL_FREE failed: %s\\n\", gpg_strerror (rc));\n      return rc;\n    }\n  if (b->filter_ov && b->filter_ov_owner)\n    {\n      xfree (b->filter_ov);\n      b->filter_ov = NULL;\n    }\n\n\n  /* and see how to remove it */\n  if (a == b && !b->chain)\n    log_bug (\"can't remove the last filter from the chain\\n\");\n  else if (a == b)\n    {\t\t\t\t/* remove the first iobuf from the chain */\n      /* everything from b is copied to a. This is save because\n       * a flush has been done on the to be removed entry\n       */\n      b = a->chain;\n      xfree (a->d.buf);\n      xfree (a->real_fname);\n      memcpy (a, b, sizeof *a);\n      xfree (b);\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: popped filter\\n\", a->no, a->subno);\n    }\n  else if (!b->chain)\n    {\t\t\t\t/* remove the last iobuf from the chain */\n      log_bug (\"Ohh jeee, trying to remove a head filter\\n\");\n    }\n  else\n    {\t\t\t\t/* remove an intermediate iobuf from the chain */\n      log_bug (\"Ohh jeee, trying to remove an intermediate filter\\n\");\n    }\n\n  return rc;\n}\n\n\n/****************\n * read underflow: read at least one byte into the buffer and return\n * the first byte or -1 on EOF.\n */\nstatic int\nunderflow (iobuf_t a, int clear_pending_eof)\n{\n  return underflow_target (a, clear_pending_eof, 1);\n}\n\n\n/****************\n * read underflow: read TARGET bytes into the buffer and return\n * the first byte or -1 on EOF.\n */\nstatic int\nunderflow_target (iobuf_t a, int clear_pending_eof, size_t target)\n{\n  size_t len;\n  int rc;\n\n  if (DBG_IOBUF)\n    log_debug (\"iobuf-%d.%d: underflow: buffer size: %d; still buffered: %d => space for %d bytes\\n\",\n\t       a->no, a->subno,\n\t       (int) a->d.size, (int) (a->d.len - a->d.start),\n\t       (int) (a->d.size - (a->d.len - a->d.start)));\n\n  if (a->use == IOBUF_INPUT_TEMP)\n    /* By definition, there isn't more data to read into the\n       buffer.  */\n    return -1;\n\n  assert (a->use == IOBUF_INPUT);\n\n  /* If there is still some buffered data, then move it to the start\n     of the buffer and try to fill the end of the buffer.  (This is\n     useful if we are called from iobuf_peek().)  */\n  assert (a->d.start <= a->d.len);\n  a->d.len -= a->d.start;\n  memmove (a->d.buf, &a->d.buf[a->d.start], a->d.len);\n  a->d.start = 0;\n\n  if (a->d.len < target && a->filter_eof)\n    /* The last time we tried to read from this filter, we got an EOF.\n       We couldn't return the EOF, because there was buffered data.\n       Since there is no longer any buffered data, return the\n       error.  */\n    {\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: underflow: eof (pending eof)\\n\",\n\t\t   a->no, a->subno);\n      if (! clear_pending_eof)\n\treturn -1;\n\n      if (a->chain)\n\t/* A filter follows this one.  Free this filter.  */\n\t{\n\t  iobuf_t b = a->chain;\n\t  if (DBG_IOBUF)\n\t    log_debug (\"iobuf-%d.%d: filter popped (pending EOF returned)\\n\",\n\t\t       a->no, a->subno);\n\t  xfree (a->d.buf);\n\t  xfree (a->real_fname);\n\t  memcpy (a, b, sizeof *a);\n\t  xfree (b);\n\t  print_chain (a);\n\t}\n      else\n\ta->filter_eof = 0;\t/* for the top level filter */\n      return -1;\t\t/* return one(!) EOF */\n    }\n\n  if (a->d.len == 0 && a->error)\n    /* The last time we tried to read from this filter, we got an\n       error.  We couldn't return the error, because there was\n       buffered data.  Since there is no longer any buffered data,\n       return the error.  */\n    {\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: pending error (%s) returned\\n\",\n\t\t   a->no, a->subno, gpg_strerror (a->error));\n      return -1;\n    }\n\n  if (a->filter && ! a->filter_eof && ! a->error)\n    /* We have a filter function and the last time we tried to read we\n       didn't get an EOF or an error.  Try to fill the buffer.  */\n    {\n      /* Be careful to account for any buffered data.  */\n      len = a->d.size - a->d.len;\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: underflow: A->FILTER (%lu bytes)\\n\",\n\t\t   a->no, a->subno, (ulong) len);\n      if (len == 0)\n\t/* There is no space for more data.  Don't bother calling\n\t   A->FILTER.  */\n\trc = 0;\n      else\n\trc = a->filter (a->filter_ov, IOBUFCTRL_UNDERFLOW, a->chain,\n\t\t\t&a->d.buf[a->d.len], &len);\n      a->d.len += len;\n\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: A->FILTER() returned rc=%d (%s), read %lu bytes\\n\",\n\t\t   a->no, a->subno,\n\t\t   rc, rc == 0 ? \"ok\" : rc == -1 ? \"EOF\" : gpg_strerror (rc),\n\t\t   (ulong) len);\n/*  \t    if( a->no == 1 ) */\n/*                   log_hexdump (\"     data:\", a->d.buf, len); */\n\n      if (rc == -1)\n\t/* EOF.  */\n\t{\n\t  size_t dummy_len = 0;\n\n\t  /* Tell the filter to free itself */\n\t  if ((rc = a->filter (a->filter_ov, IOBUFCTRL_FREE, a->chain,\n\t\t\t       NULL, &dummy_len)))\n\t    log_error (\"IOBUFCTRL_FREE failed: %s\\n\", gpg_strerror (rc));\n\n\t  /* Free everything except for the internal buffer.  */\n\t  if (a->filter_ov && a->filter_ov_owner)\n\t    xfree (a->filter_ov);\n\t  a->filter_ov = NULL;\n\t  a->filter = NULL;\n\t  a->filter_eof = 1;\n\n\t  if (clear_pending_eof && a->d.len == 0 && a->chain)\n\t    /* We don't need to keep this filter around at all:\n\n\t         - we got an EOF\n\t\t - we have no buffered data\n\t\t - a filter follows this one.\n\n\t      Unlink this filter.  */\n\t    {\n\t      iobuf_t b = a->chain;\n\t      if (DBG_IOBUF)\n\t\tlog_debug (\"iobuf-%d.%d: pop in underflow (nothing buffered, got EOF)\\n\",\n\t\t\t   a->no, a->subno);\n\t      xfree (a->d.buf);\n\t      xfree (a->real_fname);\n\t      memcpy (a, b, sizeof *a);\n\t      xfree (b);\n\n\t      print_chain (a);\n\n\t      return -1;\n\t    }\n\t  else if (a->d.len == 0)\n\t    /* We can't unlink this filter (it is the only one in the\n\t       pipeline), but we can immediately return EOF.  */\n\t    return -1;\n\t}\n      else if (rc)\n\t/* Record the error.  */\n\t{\n\t  a->error = rc;\n\n\t  if (a->d.len == 0)\n\t    /* There is no buffered data.  Immediately return EOF.  */\n\t    return -1;\n\t}\n    }\n\n  assert (a->d.start <= a->d.len);\n  if (a->d.start < a->d.len)\n    return a->d.buf[a->d.start++];\n\n  /* EOF.  */\n  return -1;\n}\n\n\nstatic int\nfilter_flush (iobuf_t a)\n{\n  size_t len;\n  int rc;\n\n  if (a->use == IOBUF_OUTPUT_TEMP)\n    {\t\t\t\t/* increase the temp buffer */\n      size_t newsize = a->d.size + IOBUF_BUFFER_SIZE;\n\n      if (DBG_IOBUF)\n\tlog_debug (\"increasing temp iobuf from %lu to %lu\\n\",\n\t\t   (ulong) a->d.size, (ulong) newsize);\n\n      a->d.buf = xrealloc (a->d.buf, newsize);\n      a->d.size = newsize;\n      return 0;\n    }\n  else if (a->use != IOBUF_OUTPUT)\n    log_bug (\"flush on non-output iobuf\\n\");\n  else if (!a->filter)\n    log_bug (\"filter_flush: no filter\\n\");\n  len = a->d.len;\n  rc = a->filter (a->filter_ov, IOBUFCTRL_FLUSH, a->chain, a->d.buf, &len);\n  if (!rc && len != a->d.len)\n    {\n      log_info (\"filter_flush did not write all!\\n\");\n      rc = GPG_ERR_INTERNAL;\n    }\n  else if (rc)\n    a->error = rc;\n  a->d.len = 0;\n\n  return rc;\n}\n\n\nint\niobuf_readbyte (iobuf_t a)\n{\n  int c;\n\n  if (a->use == IOBUF_OUTPUT || a->use == IOBUF_OUTPUT_TEMP)\n    {\n      log_bug (\"iobuf_readbyte called on a non-INPUT pipeline!\\n\");\n      return -1;\n    }\n\n  assert (a->d.start <= a->d.len);\n\n  if (a->nlimit && a->nbytes >= a->nlimit)\n    return -1;\t\t\t/* forced EOF */\n\n  if (a->d.start < a->d.len)\n    {\n      c = a->d.buf[a->d.start++];\n    }\n  else if ((c = underflow (a, 1)) == -1)\n    return -1;\t\t\t/* EOF */\n\n  assert (a->d.start <= a->d.len);\n\n  /* Note: if underflow doesn't return EOF, then it returns the first\n     byte that was read and advances a->d.start appropriately.  */\n\n  a->nbytes++;\n  return c;\n}\n\n\nint\niobuf_read (iobuf_t a, void *buffer, unsigned int buflen)\n{\n  unsigned char *buf = (unsigned char *)buffer;\n  int c, n;\n\n  if (a->use == IOBUF_OUTPUT || a->use == IOBUF_OUTPUT_TEMP)\n    {\n      log_bug (\"iobuf_read called on a non-INPUT pipeline!\\n\");\n      return -1;\n    }\n\n  if (a->nlimit)\n    {\n      /* Handle special cases. */\n      for (n = 0; n < buflen; n++)\n\t{\n\t  if ((c = iobuf_readbyte (a)) == -1)\n\t    {\n\t      if (!n)\n\t\treturn -1;\t/* eof */\n\t      break;\n\t    }\n\n\t  if (buf)\n\t    {\n\t      *buf = c;\n\t      buf++;\n\t    }\n\t}\n      return n;\n    }\n\n  n = 0;\n  do\n    {\n      if (n < buflen && a->d.start < a->d.len)\n\t/* Drain the buffer.  */\n\t{\n\t  unsigned size = a->d.len - a->d.start;\n\t  if (size > buflen - n)\n\t    size = buflen - n;\n\t  if (buf)\n\t    memcpy (buf, a->d.buf + a->d.start, size);\n\t  n += size;\n\t  a->d.start += size;\n\t  if (buf)\n\t    buf += size;\n\t}\n      if (n < buflen)\n\t/* Draining the internal buffer didn't fill BUFFER.  Call\n\t   underflow to read more data into the filter's internal\n\t   buffer.  */\n\t{\n\t  if ((c = underflow (a, 1)) == -1)\n\t    /* EOF.  If we managed to read something, don't return EOF\n\t       now.  */\n\t    {\n\t      a->nbytes += n;\n\t      return n ? n : -1 /*EOF*/;\n\t    }\n\t  if (buf)\n\t    *buf++ = c;\n\t  n++;\n\t}\n    }\n  while (n < buflen);\n  a->nbytes += n;\n  return n;\n}\n\n\n\nint\niobuf_peek (iobuf_t a, byte * buf, unsigned buflen)\n{\n  int n = 0;\n\n  assert (buflen > 0);\n  assert (a->use == IOBUF_INPUT || a->use == IOBUF_INPUT_TEMP);\n\n  if (buflen > a->d.size)\n    /* We can't peek more than we can buffer.  */\n    buflen = a->d.size;\n\n  /* Try to fill the internal buffer with enough data to satisfy the\n     request.  */\n  while (buflen > a->d.len - a->d.start)\n    {\n      if (underflow_target (a, 0, buflen) == -1)\n\t/* EOF.  We can't read any more.  */\n\tbreak;\n\n      /* Underflow consumes the first character (it's the return\n\t value).  unget() it by resetting the \"file position\".  */\n      assert (a->d.start == 1);\n      a->d.start = 0;\n    }\n\n  n = a->d.len - a->d.start;\n  if (n > buflen)\n    n = buflen;\n\n  if (n == 0)\n    /* EOF.  */\n    return -1;\n\n  memcpy (buf, &a->d.buf[a->d.start], n);\n\n  return n;\n}\n\n\n\n\nint\niobuf_writebyte (iobuf_t a, unsigned int c)\n{\n  int rc;\n\n  if (a->use == IOBUF_INPUT || a->use == IOBUF_INPUT_TEMP)\n    {\n      log_bug (\"iobuf_writebyte called on an input pipeline!\\n\");\n      return -1;\n    }\n\n  if (a->d.len == a->d.size)\n    if ((rc=filter_flush (a)))\n      return rc;\n\n  assert (a->d.len < a->d.size);\n  a->d.buf[a->d.len++] = c;\n  return 0;\n}\n\n\nint\niobuf_write (iobuf_t a, const void *buffer, unsigned int buflen)\n{\n  const unsigned char *buf = (const unsigned char *)buffer;\n  int rc;\n\n  if (a->use == IOBUF_INPUT || a->use == IOBUF_INPUT_TEMP)\n    {\n      log_bug (\"iobuf_write called on an input pipeline!\\n\");\n      return -1;\n    }\n\n  do\n    {\n      if (buflen && a->d.len < a->d.size)\n\t{\n\t  unsigned size = a->d.size - a->d.len;\n\t  if (size > buflen)\n\t    size = buflen;\n\t  memcpy (a->d.buf + a->d.len, buf, size);\n\t  buflen -= size;\n\t  buf += size;\n\t  a->d.len += size;\n\t}\n      if (buflen)\n\t{\n\t  rc = filter_flush (a);\n          if (rc)\n\t    return rc;\n\t}\n    }\n  while (buflen);\n  return 0;\n}\n\n\nint\niobuf_writestr (iobuf_t a, const char *buf)\n{\n  if (a->use == IOBUF_INPUT || a->use == IOBUF_INPUT_TEMP)\n    {\n      log_bug (\"iobuf_writestr called on an input pipeline!\\n\");\n      return -1;\n    }\n\n  return iobuf_write (a, buf, strlen (buf));\n}\n\n\n\nint\niobuf_write_temp (iobuf_t dest, iobuf_t source)\n{\n  assert (source->use == IOBUF_OUTPUT || source->use == IOBUF_OUTPUT_TEMP);\n  assert (dest->use == IOBUF_OUTPUT || dest->use == IOBUF_OUTPUT_TEMP);\n\n  iobuf_flush_temp (source);\n  return iobuf_write (dest, source->d.buf, source->d.len);\n}\n\nsize_t\niobuf_temp_to_buffer (iobuf_t a, byte * buffer, size_t buflen)\n{\n  byte desc[MAX_IOBUF_DESC];\n  size_t n;\n\n  while (1)\n    {\n      int rc = filter_flush (a);\n      if (rc)\n\tlog_bug (\"Flushing iobuf %d.%d (%s) from iobuf_temp_to_buffer failed.  Ignoring.\\n\",\n\t\t a->no, a->subno, iobuf_desc (a, desc));\n      if (! a->chain)\n\tbreak;\n      a = a->chain;\n    }\n\n  n = a->d.len;\n  if (n > buflen)\n    n = buflen;\n  memcpy (buffer, a->d.buf, n);\n  return n;\n}\n\n/* Copies the data from the input iobuf SOURCE to the output iobuf\n   DEST until either an error is encountered or EOF is reached.\n   Returns the number of bytes copies.  */\nsize_t\niobuf_copy (iobuf_t dest, iobuf_t source)\n{\n  char *temp;\n  /* Use a 32 KB buffer.  */\n  const size_t temp_size = 32 * 1024;\n\n  size_t nread;\n  size_t nwrote = 0;\n  size_t max_read = 0;\n  int err;\n\n  assert (source->use == IOBUF_INPUT || source->use == IOBUF_INPUT_TEMP);\n  assert (dest->use == IOBUF_OUTPUT || source->use == IOBUF_OUTPUT_TEMP);\n\n  if (iobuf_error (dest))\n    return -1;\n\n  temp = xmalloc (temp_size);\n  while (1)\n    {\n      nread = iobuf_read (source, temp, temp_size);\n      if (nread == -1)\n        /* EOF.  */\n        break;\n\n      if (nread > max_read)\n        max_read = nread;\n\n      err = iobuf_write (dest, temp, nread);\n      if (err)\n        break;\n      nwrote += nread;\n    }\n\n  /* Burn the buffer.  */\n  if (max_read)\n    wipememory (temp, max_read);\n  xfree (temp);\n\n  return nwrote;\n}\n\n\nvoid\niobuf_flush_temp (iobuf_t temp)\n{\n  if (temp->use == IOBUF_INPUT || temp->use == IOBUF_INPUT_TEMP)\n    log_bug (\"iobuf_flush_temp called on an input pipeline!\\n\");\n  while (temp->chain)\n    iobuf_pop_filter (temp, temp->filter, NULL);\n}\n\n\nvoid\niobuf_set_limit (iobuf_t a, off_t nlimit)\n{\n  if (nlimit)\n    a->nofast = 1;\n  else\n    a->nofast = 0;\n  a->nlimit = nlimit;\n  a->ntotal += a->nbytes;\n  a->nbytes = 0;\n}\n\n\n\noff_t\niobuf_get_filelength (iobuf_t a, int *overflow)\n{\n  if (overflow)\n    *overflow = 0;\n\n  /* Hmmm: file_filter may have already been removed */\n  for ( ; a->chain; a = a->chain )\n    ;\n\n  if (a->filter != file_filter)\n    return 0;\n\n  {\n    file_filter_ctx_t *b = a->filter_ov;\n    gnupg_fd_t fp = b->fp;\n\n#if defined(HAVE_W32_SYSTEM)\n    ulong size;\n    static int (* __stdcall get_file_size_ex) (void *handle,\n\t\t\t\t\t       LARGE_INTEGER *r_size);\n    static int get_file_size_ex_initialized;\n\n    if (!get_file_size_ex_initialized)\n      {\n\tvoid *handle;\n\n\thandle = dlopen (\"kernel32.dll\", RTLD_LAZY);\n\tif (handle)\n\t  {\n\t    get_file_size_ex = dlsym (handle, \"GetFileSizeEx\");\n\t    if (!get_file_size_ex)\n\t      dlclose (handle);\n\t  }\n\tget_file_size_ex_initialized = 1;\n      }\n\n    if (get_file_size_ex)\n      {\n\t/* This is a newer system with GetFileSizeEx; we use this\n\t   then because it seem that GetFileSize won't return a\n\t   proper error in case a file is larger than 4GB. */\n\tLARGE_INTEGER exsize;\n\n\tif (get_file_size_ex (fp, &exsize))\n\t  {\n\t    if (!exsize.u.HighPart)\n\t      return exsize.u.LowPart;\n\t    if (overflow)\n\t      *overflow = 1;\n\t    return 0;\n\t  }\n      }\n    else\n      {\n\tif ((size=GetFileSize (fp, NULL)) != 0xffffffff)\n\t  return size;\n      }\n    log_error (\"GetFileSize for handle %p failed: %s\\n\",\n\t       fp, w32_strerror (0));\n#else /*!HAVE_W32_SYSTEM*/\n    {\n      struct stat st;\n\n      if ( !fstat (FD2INT (fp), &st) )\n        return st.st_size;\n      log_error(\"fstat() failed: %s\\n\", strerror(errno) );\n    }\n#endif /*!HAVE_W32_SYSTEM*/\n  }\n\n  return 0;\n}\n\n\nint\niobuf_get_fd (iobuf_t a)\n{\n  for (; a->chain; a = a->chain)\n    ;\n\n  if (a->filter != file_filter)\n    return -1;\n\n  {\n    file_filter_ctx_t *b = a->filter_ov;\n    gnupg_fd_t fp = b->fp;\n\n    return FD2INT (fp);\n  }\n}\n\n\noff_t\niobuf_tell (iobuf_t a)\n{\n  return a->ntotal + a->nbytes;\n}\n\n\n#if !defined(HAVE_FSEEKO) && !defined(fseeko)\n\n#ifdef HAVE_LIMITS_H\n# include <limits.h>\n#endif\n#ifndef LONG_MAX\n# define LONG_MAX ((long) ((unsigned long) -1 >> 1))\n#endif\n#ifndef LONG_MIN\n# define LONG_MIN (-1 - LONG_MAX)\n#endif\n\n/****************\n * A substitute for fseeko, for hosts that don't have it.\n */\nstatic int\nfseeko (FILE * stream, off_t newpos, int whence)\n{\n  while (newpos != (long) newpos)\n    {\n      long pos = newpos < 0 ? LONG_MIN : LONG_MAX;\n      if (fseek (stream, pos, whence) != 0)\n\treturn -1;\n      newpos -= pos;\n      whence = SEEK_CUR;\n    }\n  return fseek (stream, (long) newpos, whence);\n}\n#endif\n\nint\niobuf_seek (iobuf_t a, off_t newpos)\n{\n  file_filter_ctx_t *b = NULL;\n\n  if (a->use == IOBUF_OUTPUT || a->use == IOBUF_INPUT)\n    {\n      /* Find the last filter in the pipeline.  */\n      for (; a->chain; a = a->chain)\n\t;\n\n      if (a->filter != file_filter)\n\treturn -1;\n\n      b = a->filter_ov;\n\n#ifdef HAVE_W32_SYSTEM\n      if (SetFilePointer (b->fp, newpos, NULL, FILE_BEGIN) == 0xffffffff)\n\t{\n\t  log_error (\"SetFilePointer failed on handle %p: ec=%d\\n\",\n\t\t     b->fp, (int) GetLastError ());\n\t  return -1;\n\t}\n#else\n      if (lseek (b->fp, newpos, SEEK_SET) == (off_t) - 1)\n\t{\n\t  log_error (\"can't lseek: %s\\n\", strerror (errno));\n\t  return -1;\n\t}\n#endif\n      /* Discard the buffer it is not a temp stream.  */\n      a->d.len = 0;\n    }\n  a->d.start = 0;\n  a->nbytes = 0;\n  a->nlimit = 0;\n  a->nofast = 0;\n  a->ntotal = newpos;\n  a->error = 0;\n\n  /* It is impossible for A->CHAIN to be non-NULL.  If A is an INPUT\n     or OUTPUT buffer, then we find the last filter, which is defined\n     as A->CHAIN being NULL.  If A is a TEMP filter, then A must be\n     the only filter in the pipe: when iobuf_push_filter adds a filter\n     to the front of a pipeline, it sets the new filter to be an\n     OUTPUT filter if the pipeline is an OUTPUT or TEMP pipeline and\n     to be an INPUT filter if the pipeline is an INPUT pipeline.\n     Thus, only the last filter in a TEMP pipeline can be a */\n\n  /* remove filters, but the last */\n  if (a->chain)\n    log_debug (\"iobuf_pop_filter called in iobuf_seek - please report\\n\");\n  while (a->chain)\n    iobuf_pop_filter (a, a->filter, NULL);\n\n  return 0;\n}\n\n\nconst char *\niobuf_get_real_fname (iobuf_t a)\n{\n  if (a->real_fname)\n    return a->real_fname;\n\n  /* the old solution */\n  for (; a; a = a->chain)\n    if (!a->chain && a->filter == file_filter)\n      {\n\tfile_filter_ctx_t *b = a->filter_ov;\n\treturn b->print_only_name ? NULL : b->fname;\n      }\n\n  return NULL;\n}\n\nconst char *\niobuf_get_fname (iobuf_t a)\n{\n  for (; a; a = a->chain)\n    if (!a->chain && a->filter == file_filter)\n      {\n\tfile_filter_ctx_t *b = a->filter_ov;\n\treturn b->fname;\n      }\n  return NULL;\n}\n\nconst char *\niobuf_get_fname_nonnull (iobuf_t a)\n{\n  const char *fname;\n\n  fname = iobuf_get_fname (a);\n  return fname? fname : \"[?]\";\n}\n\n\n/****************\n * Enable or disable partial body length mode (RFC 4880 4.2.2.4).\n *\n * If LEN is 0, this disables partial block mode by popping the\n * partial body length filter, which must be the most recently\n * added filter.\n *\n * If LEN is non-zero, it pushes a partial body length filter.  If\n * this is a read filter, LEN must be the length byte from the first\n * chunk and A should be position just after this first partial body\n * length header.\n */\nvoid\niobuf_set_partial_body_length_mode (iobuf_t a, size_t len)\n{\n  if (!len)\n    /* Disable partial body length mode.  */\n    {\n      if (a->use == IOBUF_INPUT)\n\tlog_debug (\"iobuf_pop_filter called in set_partial_block_mode\"\n\t\t   \" - please report\\n\");\n\n      log_assert (a->filter == block_filter);\n      iobuf_pop_filter (a, block_filter, NULL);\n    }\n  else\n    /* Enabled partial body length mode.  */\n    {\n      block_filter_ctx_t *ctx = xcalloc (1, sizeof *ctx);\n      ctx->use = a->use;\n      ctx->partial = 1;\n      ctx->size = 0;\n      ctx->first_c = len;\n      iobuf_push_filter (a, block_filter, ctx);\n    }\n}\n\n\n\nunsigned int\niobuf_read_line (iobuf_t a, byte ** addr_of_buffer,\n\t\t unsigned *length_of_buffer, unsigned *max_length)\n{\n  int c;\n  char *buffer = (char *)*addr_of_buffer;\n  unsigned length = *length_of_buffer;\n  unsigned nbytes = 0;\n  unsigned maxlen = *max_length;\n  char *p;\n\n  /* The code assumes that we have space for at least a newline and a\n     NUL character in the buffer.  This requires at least 2 bytes.  We\n     don't complicate the code by handling the stupid corner case, but\n     simply assert that it can't happen.  */\n  assert (!buffer || length >= 2 || maxlen >= 2);\n\n  if (!buffer || length <= 1)\n    /* must allocate a new buffer */\n    {\n      length = 256 <= maxlen ? 256 : maxlen;\n      buffer = xrealloc (buffer, length);\n      *addr_of_buffer = (unsigned char *)buffer;\n      *length_of_buffer = length;\n    }\n\n  p = buffer;\n  while ((c = iobuf_get (a)) != -1)\n    {\n      *p++ = c;\n      nbytes++;\n      if (c == '\\n')\n\tbreak;\n\n      if (nbytes == length - 1)\n\t/* We don't have enough space to add a \\n and a \\0.  Increase\n\t   the buffer size.  */\n\t{\n\t  if (length == maxlen)\n\t    /* We reached the buffer's size limit!  */\n\t    {\n\t      /* Skip the rest of the line.  */\n\t      while (c != '\\n' && (c = iobuf_get (a)) != -1)\n\t\t;\n\n\t      /* p is pointing at the last byte in the buffer.  We\n\t\t always terminate the line with \"\\n\\0\" so overwrite\n\t\t the previous byte with a \\n.  */\n\t      assert (p > buffer);\n\t      p[-1] = '\\n';\n\n\t      /* Indicate truncation.  */\n\t      *max_length = 0;\n\t      break;\n\t    }\n\n\t  length += length < 1024 ? 256 : 1024;\n\t  if (length > maxlen)\n\t    length = maxlen;\n\n\t  buffer = xrealloc (buffer, length);\n\t  *addr_of_buffer = (unsigned char *)buffer;\n\t  *length_of_buffer = length;\n\t  p = buffer + nbytes;\n\t}\n    }\n  /* Add the terminating NUL.  */\n  *p = 0;\n\n  /* Return the number of characters written to the buffer including\n     the newline, but not including the terminating NUL.  */\n  return nbytes;\n}\n\nstatic int\ntranslate_file_handle (int fd, int for_write)\n{\n#if defined(HAVE_W32CE_SYSTEM)\n  /* This is called only with one of the special filenames.  Under\n     W32CE the FD here is not a file descriptor but a rendezvous id,\n     thus we need to finish the pipe first.  */\n  fd = _assuan_w32ce_finish_pipe (fd, for_write);\n#elif defined(HAVE_W32_SYSTEM)\n  {\n    int x;\n\n    (void)for_write;\n\n    if (fd == 0)\n      x = (int) GetStdHandle (STD_INPUT_HANDLE);\n    else if (fd == 1)\n      x = (int) GetStdHandle (STD_OUTPUT_HANDLE);\n    else if (fd == 2)\n      x = (int) GetStdHandle (STD_ERROR_HANDLE);\n    else\n      x = fd;\n\n    if (x == -1)\n      log_debug (\"GetStdHandle(%d) failed: ec=%d\\n\",\n\t\t fd, (int) GetLastError ());\n\n    fd = x;\n  }\n#else\n  (void)for_write;\n#endif\n  return fd;\n}\n\n\nvoid\niobuf_skip_rest (iobuf_t a, unsigned long n, int partial)\n{\n  if ( partial )\n    {\n      for (;;)\n        {\n          if (a->nofast || a->d.start >= a->d.len)\n            {\n              if (iobuf_readbyte (a) == -1)\n                {\n                  break;\n                }\n\t    }\n          else\n            {\n              unsigned long count = a->d.len - a->d.start;\n              a->nbytes += count;\n              a->d.start = a->d.len;\n\t    }\n\t}\n    }\n  else\n    {\n      unsigned long remaining = n;\n      while (remaining > 0)\n        {\n          if (a->nofast || a->d.start >= a->d.len)\n            {\n              if (iobuf_readbyte (a) == -1)\n                {\n                  break;\n\t\t}\n              --remaining;\n\t    }\n          else\n            {\n              unsigned long count = a->d.len - a->d.start;\n              if (count > remaining)\n                {\n                  count = remaining;\n\t\t}\n              a->nbytes += count;\n              a->d.start += count;\n              remaining -= count;\n\t    }\n\t}\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/common/ChangeLog.jnlib": "2011-12-01  Werner Koch  <wk@g10code.com>\n\n\tNB: ChangeLog files are no longer manually maintained.  Starting\n\ton December 1st, 2011 we put change information only in the GIT\n\tcommit log, and generate a top-level ChangeLog file from logs at\n\t\"make dist\".  See doc/HACKING for details.\n\n\t[Update 2015-04-24: README.jnlib has been removed and all\n\t references to JNLIB, except for this file, have been removed.]\n\n2010-03-10  Werner Koch  <wk@g10code.com>\n\n\tSee gnupg/common/ChangeLog for newer changes.\n\n\tJNLIB has been merged into GnuPG's common directory.  README.jnlib\n\tlist the files making up JNLIB.\n\n\t* README: Rename to README.jnlib\n\t* ChangeLog: Rename to ChangeLog.jnlib.\n\t* Makefile.am: Remove.\n\n2010-03-01  Werner Koch  <wk@g10code.com>\n\n\t* t-w32-reg.c: New.\n\n\t* w32-reg.c (read_w32_registry_string)\n\t(write_w32_registry_string): Support W32CE.\n\n2010-02-26  Werner Koch  <wk@g10code.com>\n\n\t* t-timestuff.c: New.\n\n\t* dynload.h (dlopen, dlsym) [W32CE]: Map to wchar_t.\n\n\t* mischelp.c (_jnlib_free): New.\n\t(same_file_p) [W32CE]: Map to wchar_t.\n\n\t* utf8conv.c (set_native_charset) [W32CE]: Do not use\n\tGetConsoleOutputCP.\n\t(wchar_to_utf8, utf8_to_wchar) [W32]: New.\n\n\t* Makefile.am (t_jnlib_ldadd) [W32CE]: Add gpg-error.\n\n\t* t-support.h (getenv) [HAVE_GETENV]: Add getenv stub.\n\t[W32CE]: Include gpg-error.h\n\t* t-support.c (gpg_err_code_from_errno)\n\t(gpg_err_code_from_syserror) [GPG_ERROR_H]: Do not build.\n\n\t* t-stringhelp.c (gethome) [!HAVE_GETPWUID]: Keep result of getenv.\n\n\t* dotlock.c [!HAVE_SIGNAL_H]: Don't include signal.h.\n\t(create_dotlock) [W32CE]: Map filename top wchar_t.\n\n\t* libjnlib-config.h [USE_SIMPLE_GETTEXT]: Include gpg-error.h and\n\tremove w32help.h.\n\t(jnlib_set_errno): New.  Use it everywhere to set ERRNO.\n\t(getenv) [!HAVE_GETENV]: New.\n\t(getpid) [W32E]: New.\n\n\t* stringhelp.c (get_pwdir) [!HAVE_PWD_H]: Mark unused args.\n\t(w32_strerror) [W32CE]: Use a simple implementation.\n\n\t* w32help.h [USE_SIMPLE_GETTEXT]: Remove all definitions; we are\n\tnow using the gpg-error included implementation.\n\t* w32-gettext.c: Remove.\n\n\t* mischelp.c (same_file_p): Fix bug in case the second file can't\n\tbe opened.\n\n2009-10-19  Werner Koch  <wk@g10code.com>\n\n\t* strlist.c (add_to_strlist_try): New.\n\n2009-09-22  Werner Koch  <wk@g10code.com>\n\n\t* dotlock.h (DOTLOCK): Rename to dotlock_t.  Change all users.\n\n2009-08-26  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (do_make_filename): Factor some code out to ..\n\t(get_pwdir): .. new.\n\n2009-08-26  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c [HAVE_PWD_H]: Include pwd.h.\n\t(do_make_filename): New.\n\t(make_filename, make_filename_try): Implement using the new\n\tfunction.\n\t* t-stringhelp.c (test_make_filename_try): New.\n\t* t-support.c (gcry_strdup): Fix.\n\n\t* stringhelp.h (make_filename, make_filename_try): Add sentinel\n\tattribute.\n\n2009-08-25  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c: Include errno.h.\n\t(do_strconcat): New.\n\t(strconcat, xstrconcat): New.\n\t* types.h (GNUPG_GCC_A_SENTINEL): New.\n\t* t-stringhelp.c (test_strconcat, test_xstrconcat): New.\n\t(main): Run them.\n\n2009-07-07  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (make_filename_try): Use jnlib_malloc.\n\n\t* dotlock.c (read_lockfile): Replace jnlib_xmalloc by jnlib_malloc.\n\n2009-06-04  Werner Koch  <wk@g10code.com>\n\n\t* mischelp.h: Include SUN_LEN etc also for W32.\n\n2009-05-19  Werner Koch  <wk@g10code.com>\n\n\t* mischelp.h: Define PF_LOCAL, AF_LOCAL and SUN_LEN if requested.\n\t* logging.c (fun_writer): Use SUN_LEN to fix a Mac OS X freeze.\n\n2009-03-25  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (fun_closer): Never close fd 2.\n\t(set_file_fd): Close logstream early.\n\n2009-02-25  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (get_tid_callback): New.\n\t(do_logv): Use it.\n\t(log_set_get_tid_callback): New.\n\n2009-01-22  Werner Koch  <wk@g10code.com>\n\n\t* t-support.c (gpg_err_code_from_errno)\n\t(gpg_err_code_from_syserror): New.\n\n2008-11-20  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (arg_parse): Fix last change.\n\n2008-11-11  Werner Koch  <wk@g10code.com>\n\n\t* argparse.h: Add a bunch of macros and constants.\n\t* argparse.c: Use the new macros.  Re-indent the code.  Change\n\tlicense back to LGPL 2.1.\n\n2008-11-04  Werner Koch  <wk@g10code.com>\n\n\t* w32-gettext.c: Merged with code from libgpg-error and rewrote\n\tmost parts.\n\n\t* Makefile.am (AM_CFLAGS): Add -DJNLIB_IN_JNLIB.\n\n2008-10-29  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (make_filename): Implement using macros. Factor some\n\tcode out to ..\n\t(change_slashes): New.\n\t(make_filename_try): New.\n\n\t* w32-gettext.c (gettext): Return if no domain is loaded.\n\tReported by Tom Pegios.\n\n2008-10-28  Werner Koch  <wk@g10code.com>\n\n\t* w32-gettext.c (gettext): Try the binary search if the string was\n\tnot found in the hash table.\n\n2008-10-20  Werner Koch  <wk@g10code.com>\n\n\t* w32-afunix.c (_w32_sock_connect): Mark ADDRLEN as unused.\n\n\t* dotlock.c (release_dotlock): Do not mix declaration and code.\n\n\t* stringhelp.c (make_basename): Silent gcc warning about unused arg.\n\t* argparse.c (store_alias): Ditto.\n\t(find_long_option):\n\n2008-10-15  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (do_logv) [W32]: Flush the log stream.\n\n2008-09-29  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (ARGERR_): Use constants for error values.\n\t(optfile_parse): Prettify.  Replace xmalloc and xrealloc by malloc\n\tand realloc.\n\t* libjnlib-config.h (jnlib_strdup, jnlib_realloc): New.\n\n2008-06-26  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (print_sanitized_buffer2): Loose check for control\n\tcharacters to better cope with utf-8.  The range 0x80..0x9f is\n\tnowadays not anymore accidently used for control charaters.\n\n2008-06-13  Werner Koch  <wk@g10code.com>\n\n\t* dotlock.c: Reformat code and implement locking for W32.\n\t(create_dotlock): Use snprintf.\n\n2008-06-11  Werner Koch  <wk@g10code.com>\n\n\t* utf8conv.c: Remove useless variable ACTIVE_CHARSET.  Suggested\n\tby Petr Uzel.\n\n2008-05-26  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (usage): Make sure to print a trailing LF for usage(1).\n\n2008-04-08  Werner Koch  <wk@g10code.com>\n\n\t* w32-gettext.c (gettext_select_utf8): New.\n\t(get_string): Support switching encodings.\n\t(load_domain): Allocate space for DATA_NATIVE.\n\n2008-03-25  Werner Koch  <wk@g10code.com>\n\n\t* w32-gettext.c (_nl_locale_name): New.  Taken from\n\t../common/localename and GNU gettext's localename.c.\n\t(set_gettext_file): Rewritten.\n\t(gettext_localename): New.\n\n2008-03-17  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (my_funopen_hook_size_t): New.\n\t(fun_writer): Use it to cope with fopencookie/funopen differences.\n\t* dotlock.c (read_lockfile): Initialize PID.  Reported by St\u00e9phane\n\tCorth\u00e9sy.\n\n2008-02-22  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (strusage): Set copyright year to 2008.\n\n2007-11-19  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (percent_escape): Factor code out to\n\t(do_percent_escape): .. new.\n\t(try_percent_escape): New.\n\n2007-10-01  Werner Koch  <wk@g10code.com>\n\n\t* w32-afunix.c: Only keep the client related code.\n\t(read_port_and_nonce): New.  Taken from Assuan.\n\t(_w32_sock_connect): Rewritten.\n\n2007-08-29  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (initialize): Make strings translatable and remove\n\textra LF.\n\n2007-08-24  Werner Koch  <wk@g10code.com>\n\n\t* mischelp.c (same_file_p): New.\n\t(libjnlib_dummy_mischelp_func): Remove as we now always have one\n\tfunction.\n\n2007-08-09  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (show_help): Expand the @EMAIL@ macro in the package\n\tbug reporting address.\n\n2007-08-02  Werner Koch  <wk@g10code.com>\n\n\t* t-stringhelp.c (test_compare_filenames): New.\n\n\t* stringhelp.c (compare_filenames) [HAVE_DRIVE_LETTERS]: Fixed\n\tcomparison to take slash and backslash in account.\n\t(make_filename): Avoid mixing / and \\.\n\n2007-07-04  Werner Koch  <wk@g10code.com>\n\n\t* utf8conv.c (load_libiconv): Remove URL from translatble string.\n\n\tSwitched JNLIB from LGPLv2.1 to LGPLv3.\n\n2007-07-01  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (strusage): Use id 10 for the license string;\n\tdefault to GPL3+.  Change long note to version 3 or later.\n\t(show_version): Print the license info.\n\n2007-06-19  Werner Koch  <wk@g10code.com>\n\n\t* Makefile.am: Add support for regression tests.\n\t* t-support.h, t-support.c: New.\n\t* t-stringhelp.c: New.\n\n\t* stringhelp.c (percent_escape): Add arg EXTRA to make it a more\n\tgeneral function.  Changed all callers.\n\n2007-06-18  Werner Koch  <wk@g10code.com>\n\n\t* w32-afunix.c (_w32_sock_bind): Changed to properly detect an\n\talready used socket.\n\n2007-06-18  Marcus Brinkmann  <marcus@g10code.de>\n\n\t* stringhelp.h (percent_escape): New prototype.\n\t* stringhelp.c (percent_escape): New function.\n\n2007-06-11  Werner Koch  <wk@g10code.com>\n\n\t* utf8conv.c (jnlib_iconv_open, jnlib_iconv, jnlib_iconv_close): New.\n\n2007-06-06  Werner Koch  <wk@g10code.com>\n\n\t* w32help.h: New.\n\t* w32-gettext.c: New.  Taken from gnupg 1.4, added ngettext,\n\tchanged to use jnlib malloc functions and put under the LGPL.\n\t* w32-reg.c: New.  Taken from../common/w32reg.c and changed to\n\tLGPL.  Changed API to use the jnlib malloc functions.\n\t* Makefile.am (libjnlib_a_SOURCES) [!W32]: Do not build the w32\n\tspecific modules.\n\n\t* dotlock.c: Include stringhelp.h for stpcpy prototype.\n\n2007-06-04  Werner Koch  <wk@g10code.com>\n\n\t* dynload.h: New.  Taken from ../common and changed to LGPL.\n\n\t* utf8conv.c (load_libiconv): New.  Taken from GnuPG 1.4\n\n2007-05-30  Werner Koch  <wk@g10code.com>\n\n\t* w32-pth.h, w32-pth.c: Remove.\n\n2007-04-25  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (long_opt_strlen): Fixed for utf-8.\n\n2007-03-07  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (strusage): Set copyright year to 2007.\n\n2007-01-25  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (utf8_charcount): New.\n\n2006-11-29  Werner Koch  <wk@g10code.com>\n\n\t* utf8conv.c (set_native_charset) [HAVE_W32_SYSTEM]: Fixed typo in\n\tmacro name.\n\n2006-11-15  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (my_funopen_hook_ret_t): New.\n\t(fun_writer): Use it.\n\n2006-10-19  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (memrchr) [!HAVE_MEMRCHR]: Provide a replacement.\n\n2006-09-27  Werner Koch  <wk@g10code.com>\n\n\t* mischelp.c: New.\n\t(timegm): Copied from gnupg 1.4, changed from GPL to LGPL.  Fixed\n\ta memory leak.\n\n\t* stringhelp.h (isascii): New.\n\n\t* stringhelp.c (strsep): New. Copied from gnupg 1.4.5\n\tutil/strgutil.c.\n\n\t* strlist.h (STRLIST): Removed deprecated typedef.\n\n\t* types.h: Made cpp commands work with old compilers.  Also shows\n\tup nicer with Emacs' font locking.\n\n\t* w32-afunix.c (_w32_sock_connect): Set ERRNO for an invalid port.\n\n        Changed license from GPL to LGPL.  Note that all code has either\n\tbeen written by me, David, employees of g10 Code or taken from\n\tglibc.\n\n\t* libjnlib-config.h, stringhelp.c, stringhelp.h:\n\t* strlist.c, strlist.h,\tutf8conv.c, utf8conv.h:\n\t* argparse.c, argparse.h, logging.c, logging.h:\n\t* dotlock.c, dotlock.h, types.h, mischelp.h:\n        * xmalloc.c, xmalloc.h, w32-pth.c, w32-pth.h:\n\t* w32-afunix.c, w32-afunix.h: Tagged them to be long to jnlib\n\twhich is a part of GnuPG but also used by other projetcs.\n\n2006-09-22  Werner Koch  <wk@g10code.com>\n\n\t* utf8conv.c: Reworked to match the gnupg 1.4.5 code.  This now\n\trequires iconv support but this is reasonable for all modern\n\tsystems.\n\n2006-08-29  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (do_logv): Emit a missing LF for fatal errors.\n\n2006-06-28  Werner Koch  <wk@g10code.com>\n\n\t* dotlock.c (make_dotlock, release_dotlock, read_lockfile)\n\t(maybe_deadlock, destroy_dotlock, create_dotlock): Re-indented.\n\t(create_dotlock): Repalces some log_fatal by log_error as it was\n\tnot intended that they should terminate.  Write the nodename to\n\tthe locking file. Code cleanups.\n\t(read_lockfile): Reworked to read the node name.\n\t(make_dotlock): Test for identical node name and delete lock stale\n\tfile.\n\t(release_dotlock): Likewise.\n\n2006-05-23  Werner Koch  <wk@g10code.com>\n\n\t* libjnlib-config.h (JNLIB_NEED_UTF8CONV): Fixed typo in name.\n\n\t* dotlock.c (release_dotlock): Don't act if we don't have any\n\tlocks at all.\n\t(destroy_dotlock): New.  From 1.4.3.\n\t(dotlock_remove_lockfiles): Make use of destroy function.\n\n2006-05-19  Werner Koch  <wk@g10code.com>\n\n\t* strlist.c (append_to_strlist2): Enabled.\n\n\t* stringhelp.c (print_sanitized_buffer2): New.  Changed the rules\n\tto match the behaviour of print_string2 from gnupg 1.4.3.\n\t(print_sanitized_buffer): Use the new function.\n\t(print_sanitized_string2): New.\n\t(hextobyte): New.  Taken from gpg 1.4.3.\n\n2006-04-28  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (print_sanitized_buffer): Fix bug where the count\n\tgot wrong for the \\xNN representation.\n\t(sanitize_buffer): Fix bug where some control characters lose part\n\tof their \\xNN representation.\n\n2006-04-20  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (make_basename): New arg INPUTPATH for future\n\triscos compatibility.\n\n2006-04-18  Werner Koch  <wk@g10code.com>\n\n\t* libjnlib-config.h (JNLIB_NEED_UTF8CONF): Defined.\n\t* strlist.c (add_to_strlist2) [JNLIB_NEED_UTF8CONV]: Enabled.\n\n2005-06-15  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (sanitize_buffer): Make P a void*.\n\t(ascii_memistr, memistr): Ditto.\n\t(ascii_memcasecmp): Ditto.\n\t* logging.c (writen): Use void * for arg BUFFER.\n\t* stringhelp.c (memistr): Fixed unsigned/signed pointer conflict.\n\t(ascii_memistr): Ditto.\n\t(ascii_memcasemem): Ditto.\n\t* utf8conv.c (utf8_to_native): Ditto.\n\t(utf8_to_native): Ditto.\n\t* argparse.c (show_version): Removed non-required cast.\n\n2005-01-19  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (fun_writer): Don't fallback to stderr. Print to\n\tstderr only if connected to a tty.\n\n2004-12-20  Werner Koch  <wk@g10code.com>\n\n\t* w32-pth.c (do_pth_event_free): The events are hold in a ring\n\tbuffer.  Adjust for that.\n\t(do_pth_event_body): Ditto.\n\t(pth_event_isolate): Ditto.\n\t(do_pth_wait): Ditto.\n\t(_pth_event_count): Renamed to ..\n\t(event_count): .. and adjusted as above.\n\t(pth_init): Define 3 debug levels and change all debug calls to\n\tmake use of them.  This makes the moule now silent.\n\n2004-12-19  Werner Koch  <wk@g10code.com>\n\n\t* w32-pth.c (pth_init): Enable debugging depending on env var.\n\t(pth_self): New.\n\t(pth_mutex_release, pth_mutex_acquire): Implemented directly using\n\tthe W32 API.\n\n2004-12-18  Werner Koch  <wk@g10code.com>\n\n\t* w32-pth.c (pth_init): Reverse return values.  Use TRUE and FALSE\n\tconstants.\n\t(pth_kill, pth_mutex_acquire, pth_attr_set, pth_join, pth_cancel):\n\tDitto.\n\n2004-12-15  Werner Koch  <wk@g10code.com>\n\n\t* logging.c [W32]: Don't include unavailable headers.\n\n2004-12-14  Werner Koch  <wk@g10code.com>\n\n\t* w32-pth.c (_pth_strerror): Renamed to ...\n\t(w32_strerror): .. this. And let callers provide a buffer.\n\t(spawn_helper_thread): Removed HD arg and hardwire the stack size\n\tto 32k.\n\t(do_pth_wait): Removed use of ATTR; not needed for the helper\n\tthreads.\n\t(helper_thread): Renamed to ..\n\t(launch_thread): .. this.  Release handle if not joinable.\n\t(struct pth_priv_hd_s): Renamed to ...\n\t(struct thread_info_s): .. this.  Add member JOINABLE and TH.\n\n2004-12-14  Timo Schulz  <twoaday@g10code.com>\n\n\t* w32-pth.c (pth_kill): Just release the crit section if\n\tpth_init was really called. And set all handles to NULL.\n\t(_pth_strerror): New.\n\t(do_pth_wait): Before we enter the loop we check if there\n\tare too much events in the ring.\n\n2004-12-14  Werner Koch  <wk@g10code.com>\n\n\t* w32-pth.h (pth_event_occured): Removed macro.\n\t* w32-pth.c: Fixed license statement; its under the LGPL.\n\t(enter_pth, leave_pth): Use them to bracket almost all public\n\tfunctions.\n\n2004-12-13  Timo Schulz  <twoaday@g10code.com>\n\n\t* w32-pth.c (enter_pth, leave_pth): New.\n\t(pth_init): Initialize global mutex section.\n\t(pth_kill): Release global mutex section.\n\t(helper_thread): New.\n\t(pth_spawn): Make sure only one thread is running.\n\n2004-12-13  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (w32_strerror) [W32]: New.\n\n\t* w32-pth.c, w32-pth.h: Added real code written by Timo\tSchulz.\n\tNot finished, though.\n\n2004-12-07  Werner Koch  <wk@g10code.com>\n\n\t* w32-pth.c, w32-pth.h: New.\n\n2004-11-26  Werner Koch  <wk@g10code.com>\n\n\t* logging.c [_WIN32]: Don't include socket headers.\n\n2004-11-30  Timo Schulz  <ts@g10code.com>\n\n\t* w32-afunix.c: New. AF_UNIX emulation for W32.\n\t* w32-afunix.h: Likewise.\n\n2004-11-22  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (log_test_fd): Add test on LOGSTREAM.  Reported by\n\tBarry Schwartz.\n\n2004-11-18  Werner Koch  <wk@g10code.com>\n\n\t* logging.c: Explicitly include sys/stat.h for the S_I* constants.\n\n2004-10-21  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (do_logv): Use set_log_stream to setup a default.\n\t(log_set_file): Factored code out to ..\n\t(set_file_fd): .. New function to allow using a file descriptor.\n\t(log_set_fd): Make use of new fucntion.\n\t(fun_writer): Reworked.\n\n2004-08-18  Werner Koch  <wk@g10code.de>\n\n\t* stringhelp.c (print_sanitized_utf8_string): Actually implement\n\tit.\n\n2004-06-21  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (log_set_file): Do not close an old logstream if it\n\tused to be stderr or stdout.\n\n2004-05-05  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (log_set_file): Oops, don't close if LOGSTREAM is NULL.\n\n2004-04-30  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (log_set_file): Make sure the log stream will be\n\tclosed even if the stderr fileno will be assigned to a new socket.\n\n2004-04-16  Werner Koch  <wk@gnupg.org>\n\n\t* logging.h (JNLIB_LOG_WITH_PREFIX): Add constants for the flag\n\tvalues.\n\t* logging.c (log_set_prefix): New flag DETACHED.\n\t(fun_writer): Take care of this flag.\n\t(log_test_fd): New.\n\n2004-02-18  Werner Koch  <wk@gnupg.org>\n\n\t* stringhelp.c (print_sanitized_buffer): Don't care about\n\tnon-ASCII characaters.\n\t(sanitize_buffer): Ditto.\n\n2004-02-12  Werner Koch  <wk@gnupg.org>\n\n\t* Makefile.am: Replaced INCLUDES by AM_CPPFLAGS.\n\n2004-01-05  Werner Koch  <wk@gnupg.org>\n\n\t* argparse.c (strusage): Changed default copyright year to 2004.\n\n2003-12-17  Werner Koch  <wk@gnupg.org>\n\n\t* argparse.c (initialize): Replaced use of non-literal format\n\targs.  Suggested by Florian Weimer.\n\n2003-12-16  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (writen, fun_writer, fun_closer): New.\n\t(log_set_file): Add feature to log to a socket.\n\t(log_set_file, do_logv): Force printing with prefix and pid.\n\n2003-11-13  Werner Koch  <wk@gnupg.org>\n\n\t* strlist.c (strlist_copy): New.\n\n\t* dotlock.c: Define DIRSEP_C et al. if not defined.\n\n2003-11-06  Werner Koch  <wk@gnupg.org>\n\n\t* strlist.h (strlist_t): New. STRLIST is now deprecated.\n\n2003-06-18  Werner Koch  <wk@gnupg.org>\n\n\t* strlist.c (strlist_pop): New.\n\n\t* dotlock.c (dotlock_remove_lockfiles): Prefixed with dotlock_ and\n\tmade global.\n\n2003-06-17  Werner Koch  <wk@gnupg.org>\n\n\t* stringhelp.c (length_sans_trailing_chars)\n\t(length_sans_trailing_ws): New.\n\n\t* logging.c (log_inc_errorcount): New.\n\n\t* stringhelp.c (print_sanitized_utf8_buffer): Implement utf8\n\tconversion.\n\t(sanitize_buffer): New. Based on gnupg 1.3.2 make_printable_string.\n\n\t* dotlock.c: Updated to match the version from 1.3.2\n\t* utf8conv.c: New.  Code taken from strgutil.c of gnupg 1.3.2.\n\t* utf8conv.h: New.\n\n2003-06-16  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (do_logv): Hack to optionally suppress a leading space.\n\n\t* stringhelp.c (ascii_strncasecmp): New.  Taken from gnupg 1.3.\n\t(ascii_memistr): New. Taken from gnupg 1.3\n\n2003-06-13  Werner Koch  <wk@gnupg.org>\n\n\t* mischelp.h (wipememory2,wipememory): New. Taken from GnuPG 1.3.2.\n\n2002-06-04  Werner Koch  <wk@gnupg.org>\n\n\t* stringhelp.c (print_sanitized_utf8_string): New.  No real\n\timplementation for now.\n\t(print_sanitized_utf8_buffer): Ditto.\n\n2002-04-04  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (log_get_prefix): New.\n\n2002-03-15  Werner Koch  <wk@gnupg.org>\n\n\t* argparse.c (optfile_parse): Fixed missing argument handling.\n\n2002-02-25  Werner Koch  <wk@gnupg.org>\n\n\t* stringhelp.c (ascii_memcasemem): New.\n\n2002-02-14  Werner Koch  <wk@gnupg.org>\n\n\t* Makefile.am (INCLUDES): Add cflags for libgcrypt.\n\n2002-02-07  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (log_set_fd): New.\n\n\t* stringhelp.c (print_sanitized_buffer): New.\n\t(print_sanitized_string): New.\n\n2002-01-24  Werner Koch  <wk@gnupg.org>\n\n\t* argparse.c (strusage): Set default copyright notice year to 2002.\n\n\tFixed the copyright notice of this file, as it has always been\n\tpart of GnuPG and therefore belongs to the FSF.\n\n2001-11-01  Marcus Brinkmann  <marcus@g10code.de>\n\n\t* logging.c (log_printf): Do not initialize ARG_PTR with 0, we\n\tdon't know the correct type.  Instead, run va_start and va_end\n\tunconditionally.\n\tReported by Jose Carlos Garcia Sogo <jsogo@debian.org>.\n\n2002-01-19  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (log_get_stream): New.\n\n2001-12-05  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (log_set_prefix): New.\n\t(do_logv): Include prefix and pid only if enabled. Print time only\n\twhen explicitly enabled.\n\t(log_logv): New.\n\t* logging.h: Include log_logv() only when requested.\n\n2001-11-06  Werner Koch  <wk@gnupg.org>\n\n\t* strlist.c, strlist.h: New. Taken from pgnupg/util/strgutil.c\n\n2001-08-30  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (log_printf): Don't pass NULL instead of arg_ptr.\n\n2001-07-19  Werner Koch  <wk@gnupg.org>\n\n\t* stringhelp.c (ascii_memistr,ascii_isupper,ascii_islower,\n\tascii_toupper,ascii_tolower, ascii_strcasecmp, ascii_memcasecmp): New.\n\n2000-07-26 10:02:51  Werner Koch  (wk@habibti.openit.de)\n\n\t* stringhelp.c.: Add stdarg.h\n\t* argparse.h: s/ulong/unsigned long/ although this should be defined\n        by types.h.\n\n2000-06-28 19:40:23  Werner Koch  (wk@habibti.openit.de)\n\n\t* Makefile.am: Replaced second logging.c by .h\n\n2000-05-24 08:58:15  Werner Koch  (wk@habibti.openit.de)\n\n\t* logging.c (log_get_errorcount): New.\n\n2000-05-24 08:44:47  Werner Koch  (wk@habibti.openit.de)\n\n\t* stringhelp.c: Added a few filename related helper functions.\n\n2000-05-11 18:04:43  Werner Koch  (wk@habibti.openit.de)\n\n\t* xmalloc.c (xstrcat2): Replaced stpcpy to quickly address W32\n\tproblems.\n\n2000-05-02 19:43:38  Werner Koch  (wk@habibti.openit.de)\n\n\t* xmalloc.c (xstrcat2): New.\n\nMon Jan 24 13:04:28 CET 2000  Werner Koch  <wk@gnupg.de>\n\n\t* README: New.\n\t* Makefile.am: new.\n\t* argparse.c, argparse.h, logging.c, logging.h:\n\t* mischelp.h, stringhelp.c, stringhelp.h, xmalloc.c:\n\t* xmalloc.h, dotlock.c: Moved from ../util to here.\n\t* dotlock.h: New.\n\t* libjnlib-config.h: New.\n\n\t* logging.c (log_set_file): New.\n\t(log_printf): New.\n\t(do_logv): Add kludge to insert LFs.\n\n\n     ***********************************************************\n     * Please note that JNLIB is maintained as part of GnuPG.  *\n     * You may find it source-copied in other packages.        *\n     ***********************************************************\n\n Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n\t   2010 Free Software Foundation, Inc.\n\n This file is free software; as a special exception the author gives\n unlimited permission to copy and/or distribute it, with or without\n modifications, as long as this notice is preserved.\n\n This file is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY, to the extent permitted by law; without even the\n implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\nLocal Variables:\nbuffer-read-only: t\nEnd:\n",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/common/homedir.c": "/* homedir.c - Setup the home directory.\n * Copyright (C) 2004, 2006, 2007, 2010 Free Software Foundation, Inc.\n * Copyright (C) 2013, 2016 Werner Koch\n *\n * This file is part of GnuPG.\n *\n * This file is free software; you can redistribute it and/or modify\n * it under the terms of either\n *\n *   - the GNU Lesser General Public License as published by the Free\n *     Software Foundation; either version 3 of the License, or (at\n *     your option) any later version.\n *\n * or\n *\n *   - the GNU General Public License as published by the Free\n *     Software Foundation; either version 2 of the License, or (at\n *     your option) any later version.\n *\n * or both in parallel, as here.\n *\n * This file is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <https://www.gnu.org/licenses/>.\n */\n\n#include <config.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#ifdef HAVE_W32_SYSTEM\n#include <winsock2.h>   /* Due to the stupid mingw64 requirement to\n                           include this header before windows.h which\n                           is often implicitly included.  */\n#include <shlobj.h>\n#ifndef CSIDL_APPDATA\n#define CSIDL_APPDATA 0x001a\n#endif\n#ifndef CSIDL_LOCAL_APPDATA\n#define CSIDL_LOCAL_APPDATA 0x001c\n#endif\n#ifndef CSIDL_COMMON_APPDATA\n#define CSIDL_COMMON_APPDATA 0x0023\n#endif\n#ifndef CSIDL_FLAG_CREATE\n#define CSIDL_FLAG_CREATE 0x8000\n#endif\n#endif /*HAVE_W32_SYSTEM*/\n\n#ifdef HAVE_STAT\n#include <sys/stat.h> /* for stat() */\n#endif\n\n\n\n#include \"util.h\"\n#include \"sysutils.h\"\n#include \"zb32.h\"\n\n/* The GnuPG homedir.  This is only accessed by the functions\n * gnupg_homedir and gnupg_set_homedir.  Malloced.  */\nstatic char *the_gnupg_homedir;\n\n/* Flag indicating that home directory is not the default one.  */\nstatic byte non_default_homedir;\n\n\n#ifdef HAVE_W32_SYSTEM\n/* A flag used to indicate that a control file for gpgconf has been\n   detected.  Under Windows the presence of this file indicates a\n   portable installations and triggers several changes:\n\n   - The GNUGHOME directory is fixed relative to installation\n     directory.  All other means to set the home directory are ignore.\n\n   - All registry variables will be ignored.\n\n   This flag is not used on Unix systems.\n */\nstatic byte w32_portable_app;\n#endif /*HAVE_W32_SYSTEM*/\n\n#ifdef HAVE_W32_SYSTEM\n/* This flag is true if this process' binary has been installed under\n   bin and not in the root directory as often used before GnuPG 2.1. */\nstatic byte w32_bin_is_bin;\n#endif /*HAVE_W32_SYSTEM*/\n\n\n#ifdef HAVE_W32_SYSTEM\nstatic const char *w32_rootdir (void);\n#endif\n\n\n\n#ifdef HAVE_W32_SYSTEM\nstatic void\nw32_try_mkdir (const char *dir)\n{\n#ifdef HAVE_W32CE_SYSTEM\n  wchar_t *wdir = utf8_to_wchar (dir);\n  if (wdir)\n    {\n      CreateDirectory (wdir, NULL);\n      xfree (wdir);\n    }\n#else\n  CreateDirectory (dir, NULL);\n#endif\n}\n#endif\n\n\n/* This is a helper function to load a Windows function from either of\n   one DLLs. */\n#ifdef HAVE_W32_SYSTEM\nstatic HRESULT\nw32_shgetfolderpath (HWND a, int b, HANDLE c, DWORD d, LPSTR e)\n{\n  static int initialized;\n  static HRESULT (WINAPI * func)(HWND,int,HANDLE,DWORD,LPSTR);\n\n  if (!initialized)\n    {\n      static char *dllnames[] = { \"shell32.dll\", \"shfolder.dll\", NULL };\n      void *handle;\n      int i;\n\n      initialized = 1;\n\n      for (i=0, handle = NULL; !handle && dllnames[i]; i++)\n        {\n          handle = dlopen (dllnames[i], RTLD_LAZY);\n          if (handle)\n            {\n              func = dlsym (handle, \"SHGetFolderPathA\");\n              if (!func)\n                {\n                  dlclose (handle);\n                  handle = NULL;\n                }\n            }\n        }\n    }\n\n  if (func)\n    return func (a,b,c,d,e);\n  else\n    return -1;\n}\n#endif /*HAVE_W32_SYSTEM*/\n\n\n/* Check whether DIR is the default homedir.  */\nstatic int\nis_gnupg_default_homedir (const char *dir)\n{\n  int result;\n  char *a = make_absfilename (dir, NULL);\n  char *b = make_absfilename (GNUPG_DEFAULT_HOMEDIR, NULL);\n  result = !compare_filenames (a, b);\n  xfree (b);\n  xfree (a);\n  return result;\n}\n\n\n/* Helper to remove trailing slashes from NEWDIR.  Return a new\n * allocated string if that has been done or NULL if there are no\n * slashes to remove.  Also inserts a missing slash after a Windows\n * drive letter.  */\nstatic char *\ncopy_dir_with_fixup (const char *newdir)\n{\n  char *result = NULL;\n  char *p;\n\n  if (!*newdir)\n    return NULL;\n\n#ifdef HAVE_W32_SYSTEM\n  if (newdir[0] && newdir[1] == ':'\n      && !(newdir[2] == '/' || newdir[2] == '\\\\'))\n    {\n      /* Drive letter with missing leading slash.  */\n      p = result = xmalloc (strlen (newdir) + 1 + 1);\n      *p++ = newdir[0];\n      *p++ = newdir[1];\n      *p++ = '\\\\';\n      strcpy (p, newdir+2);\n\n      /* Remove trailing slashes.  */\n      p = result + strlen (result) - 1;\n      while (p > result+2 && (*p == '/' || *p == '\\\\'))\n        *p-- = 0;\n    }\n  else if (newdir[strlen (newdir)-1] == '/'\n           || newdir[strlen (newdir)-1] == '\\\\' )\n    {\n      result = xstrdup (newdir);\n      p = result + strlen (result) - 1;\n      while (p > result\n             && (*p == '/' || *p == '\\\\')\n             && (p-1 > result && p[-1] != ':')) /* We keep \"c:/\". */\n        *p-- = 0;\n    }\n\n#else /*!HAVE_W32_SYSTEM*/\n\n  if (newdir[strlen (newdir)-1] == '/')\n    {\n      result = xstrdup (newdir);\n      p = result + strlen (result) - 1;\n      while (p > result && *p == '/')\n        *p-- = 0;\n    }\n\n#endif /*!HAVE_W32_SYSTEM*/\n\n  return result;\n}\n\n\n/* Get the standard home directory.  In general this function should\n   not be used as it does not consider a registry value (under W32) or\n   the GNUPGHOME environment variable.  It is better to use\n   default_homedir(). */\nconst char *\nstandard_homedir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  static const char *dir;\n\n  if (!dir)\n    {\n      const char *rdir;\n\n      rdir = w32_rootdir ();\n      if (w32_portable_app)\n        {\n          dir = xstrconcat (rdir, DIRSEP_S \"home\", NULL);\n        }\n      else\n        {\n          char path[MAX_PATH];\n\n          /* It might be better to use LOCAL_APPDATA because this is\n             defined as \"non roaming\" and thus more likely to be kept\n             locally.  For private keys this is desired.  However,\n             given that many users copy private keys anyway forth and\n             back, using a system roaming services might be better\n             than to let them do it manually.  A security conscious\n             user will anyway use the registry entry to have better\n             control.  */\n          if (w32_shgetfolderpath (NULL, CSIDL_APPDATA|CSIDL_FLAG_CREATE,\n                                   NULL, 0, path) >= 0)\n            {\n              char *tmp = xmalloc (strlen (path) + 6 +1);\n              strcpy (stpcpy (tmp, path), \"\\\\gnupg\");\n              dir = tmp;\n\n              /* Try to create the directory if it does not yet exists.  */\n              if (access (dir, F_OK))\n                w32_try_mkdir (dir);\n            }\n          else\n            dir = GNUPG_DEFAULT_HOMEDIR;\n        }\n    }\n  return dir;\n#else/*!HAVE_W32_SYSTEM*/\n  return GNUPG_DEFAULT_HOMEDIR;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n/* Set up the default home directory.  The usual --homedir option\n   should be parsed later. */\nconst char *\ndefault_homedir (void)\n{\n  const char *dir;\n\n#ifdef HAVE_W32_SYSTEM\n  /* For a portable application we only use the standard homedir.  */\n  w32_rootdir ();\n  if (w32_portable_app)\n    return standard_homedir ();\n#endif /*HAVE_W32_SYSTEM*/\n\n  dir = getenv (\"GNUPGHOME\");\n#ifdef HAVE_W32_SYSTEM\n  if (!dir || !*dir)\n    {\n      static const char *saved_dir;\n\n      if (!saved_dir)\n        {\n          if (!dir || !*dir)\n            {\n              char *tmp, *p;\n\n              tmp = read_w32_registry_string (NULL,\n                                              GNUPG_REGISTRY_DIR,\n                                              \"HomeDir\");\n              if (tmp && !*tmp)\n                {\n                  xfree (tmp);\n                  tmp = NULL;\n                }\n              if (tmp)\n                {\n                  /* Strip trailing backslashes.  */\n                  p = tmp + strlen (tmp) - 1;\n                  while (p > tmp && *p == '\\\\')\n                    *p-- = 0;\n                  saved_dir = tmp;\n                }\n            }\n\n          if (!saved_dir)\n            saved_dir = standard_homedir ();\n        }\n      dir = saved_dir;\n    }\n#endif /*HAVE_W32_SYSTEM*/\n\n  if (!dir || !*dir)\n    dir = GNUPG_DEFAULT_HOMEDIR;\n  else\n    {\n      char *p;\n\n      p = copy_dir_with_fixup (dir);\n      if (p)\n        dir = p;\n\n      if (!is_gnupg_default_homedir (dir))\n        non_default_homedir = 1;\n    }\n\n  return dir;\n}\n\n\n#ifdef HAVE_W32_SYSTEM\n/* Check whether gpgconf is installed and if so read the gpgconf.ctl\n   file. */\nstatic void\ncheck_portable_app (const char *dir)\n{\n  char *fname;\n\n  fname = xstrconcat (dir, DIRSEP_S \"gpgconf.exe\", NULL);\n  if (!access (fname, F_OK))\n    {\n      strcpy (fname + strlen (fname) - 3, \"ctl\");\n      if (!access (fname, F_OK))\n        {\n          /* gpgconf.ctl file found.  Record this fact.  */\n          w32_portable_app = 1;\n          {\n            unsigned int flags;\n            log_get_prefix (&flags);\n            log_set_prefix (NULL, (flags | GPGRT_LOG_NO_REGISTRY));\n          }\n          /* FIXME: We should read the file to detect special flags\n             and print a warning if we don't understand them  */\n        }\n    }\n  xfree (fname);\n}\n\n\n/* Determine the root directory of the gnupg installation on Windows.  */\nstatic const char *\nw32_rootdir (void)\n{\n  static int got_dir;\n  static char dir[MAX_PATH+5];\n\n  if (!got_dir)\n    {\n      char *p;\n      int rc;\n      wchar_t wdir [MAX_PATH+5];\n\n      rc = GetModuleFileNameW (NULL, wdir, MAX_PATH);\n      if (rc && WideCharToMultiByte (CP_UTF8, 0, wdir, -1, dir, MAX_PATH-4,\n                                     NULL, NULL) < 0)\n        rc = 0;\n      if (!rc)\n        {\n          log_debug (\"GetModuleFileName failed: %s\\n\", w32_strerror (-1));\n          *dir = 0;\n        }\n      got_dir = 1;\n      p = strrchr (dir, DIRSEP_C);\n      if (p)\n        {\n          *p = 0;\n\n          check_portable_app (dir);\n\n          /* If we are installed below \"bin\" we strip that and use\n             the top directory instead.  */\n          p = strrchr (dir, DIRSEP_C);\n          if (p && !strcmp (p+1, \"bin\"))\n            {\n              *p = 0;\n              w32_bin_is_bin = 1;\n            }\n        }\n      if (!p)\n        {\n          log_debug (\"bad filename '%s' returned for this process\\n\", dir);\n          *dir = 0;\n        }\n    }\n\n  if (*dir)\n    return dir;\n  /* Fallback to the hardwired value. */\n  return GNUPG_LIBEXECDIR;\n}\n\nstatic const char *\nw32_commondir (void)\n{\n  static char *dir;\n\n  if (!dir)\n    {\n      const char *rdir;\n      char path[MAX_PATH];\n\n      /* Make sure that w32_rootdir has been called so that we are\n         able to check the portable application flag.  The common dir\n         is the identical to the rootdir.  In that case there is also\n         no need to strdup its value.  */\n      rdir = w32_rootdir ();\n      if (w32_portable_app)\n        return rdir;\n\n      if (w32_shgetfolderpath (NULL, CSIDL_COMMON_APPDATA,\n                               NULL, 0, path) >= 0)\n        {\n          char *tmp = xmalloc (strlen (path) + 4 +1);\n          strcpy (stpcpy (tmp, path), \"\\\\GNU\");\n          dir = tmp;\n          /* No auto create of the directory.  Either the installer or\n             the admin has to create these directories.  */\n        }\n      else\n        {\n          /* Ooops: Not defined - probably an old Windows version.\n             Use the installation directory instead.  */\n          dir = xstrdup (rdir);\n        }\n    }\n\n  return dir;\n}\n#endif /*HAVE_W32_SYSTEM*/\n\n\n/* Change the homedir.  Some care must be taken to set this early\n * enough because previous calls to gnupg_homedir may else return a\n * different string.  */\nvoid\ngnupg_set_homedir (const char *newdir)\n{\n  char *tmp = NULL;\n\n  if (!newdir || !*newdir)\n    newdir = default_homedir ();\n  else\n    {\n      tmp = copy_dir_with_fixup (newdir);\n      if (tmp)\n        newdir = tmp;\n\n      if (!is_gnupg_default_homedir (newdir))\n        non_default_homedir = 1;\n    }\n  xfree (the_gnupg_homedir);\n  the_gnupg_homedir = make_absfilename (newdir, NULL);;\n  xfree (tmp);\n}\n\n\n/* Return the homedir.  The returned string is valid until another\n * gnupg-set-homedir call.  This is always an absolute directory name.\n * The function replaces the former global var opt.homedir.  */\nconst char *\ngnupg_homedir (void)\n{\n  /* If a homedir has not been set, set it to the default.  */\n  if (!the_gnupg_homedir)\n    the_gnupg_homedir = make_absfilename (default_homedir (), NULL);\n  return the_gnupg_homedir;\n}\n\n\n/* Return whether the home dir is the default one.  */\nint\ngnupg_default_homedir_p (void)\n{\n  return !non_default_homedir;\n}\n\n\n/* Return the directory name used by daemons for their current working\n * directory.  */\nconst char *\ngnupg_daemon_rootdir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  static char *name;\n\n  if (!name)\n    {\n      char path[MAX_PATH];\n      size_t n;\n\n      n = GetSystemDirectoryA (path, sizeof path);\n      if (!n || n >= sizeof path)\n        name = xstrdup (\"/\"); /* Error - use the curret top dir instead.  */\n      else\n        name = xstrdup (path);\n    }\n\n  return name;\n\n#else /*!HAVE_W32_SYSTEM*/\n  return \"/\";\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n\n/* Helper for gnupg-socketdir.  This is a global function, so that\n * gpgconf can use it for its --create-socketdir command.  If\n * SKIP_CHECKS is set permission checks etc. are not done.  The\n * function always returns a malloced directory name and stores these\n * bit flags at R_INFO:\n *\n *   1 := Internal error, stat failed, out of core, etc.\n *   2 := No /run/user directory.\n *   4 := Directory not owned by the user, not a directory\n *        or wrong permissions.\n *   8 := Same as 4 but for the subdir.\n *  16 := mkdir failed\n *  32 := Non default homedir; checking subdir.\n *  64 := Subdir does not exist.\n * 128 := Using homedir as fallback.\n */\nchar *\n_gnupg_socketdir_internal (int skip_checks, unsigned *r_info)\n{\n#if defined(HAVE_W32_SYSTEM) || !defined(HAVE_STAT)\n\n  char *name;\n\n  (void)skip_checks;\n  *r_info = 0;\n  name = xstrdup (gnupg_homedir ());\n\n#else /* Unix and stat(2) available. */\n\n  static const char * const bases[] = {\n#ifdef USE_RUN_GNUPG_USER_SOCKET\n    \"/run/gnupg\",\n#endif\n    \"/run\",\n#ifdef USE_RUN_GNUPG_USER_SOCKET\n    \"/var/run/gnupg\",\n#endif\n    \"/var/run\",\n    NULL\n  };\n  int i;\n  struct stat sb;\n  char prefix[19 + 1 + 20 + 6 + 1];\n  const char *s;\n  char *name = NULL;\n\n  *r_info = 0;\n\n  /* First make sure that non_default_homedir can be set.  */\n  gnupg_homedir ();\n\n  /* It has been suggested to first check XDG_RUNTIME_DIR envvar.\n   * However, the specs state that the lifetime of the directory MUST\n   * be bound to the user being logged in.  Now GnuPG may also be run\n   * as a background process with no (desktop) user logged in.  Thus\n   * we better don't do that.  */\n\n  /* Check whether we have a /run/[gnupg/]user dir.  */\n  for (i=0; bases[i]; i++)\n    {\n      snprintf (prefix, sizeof prefix, \"%s/user/%u\",\n                bases[i], (unsigned int)getuid ());\n      if (!stat (prefix, &sb) && S_ISDIR(sb.st_mode))\n        break;\n    }\n  if (!bases[i])\n    {\n      *r_info |= 2; /* No /run/user directory.  */\n      goto leave;\n    }\n\n  if (sb.st_uid != getuid ())\n    {\n      *r_info |= 4; /* Not owned by the user.  */\n      if (!skip_checks)\n        goto leave;\n    }\n\n  if (strlen (prefix) + 7 >= sizeof prefix)\n    {\n      *r_info |= 1; /* Ooops: Buffer too short to append \"/gnupg\".  */\n      goto leave;\n    }\n  strcat (prefix, \"/gnupg\");\n\n  /* Check whether the gnupg sub directory has proper permissions.  */\n  if (stat (prefix, &sb))\n    {\n      if (errno != ENOENT)\n        {\n          *r_info |= 1; /* stat failed.  */\n          goto leave;\n        }\n\n      /* Try to create the directory and check again.  */\n      if (gnupg_mkdir (prefix, \"-rwx\"))\n        {\n          *r_info |= 16; /* mkdir failed.  */\n          goto leave;\n        }\n      if (stat (prefix, &sb))\n        {\n          *r_info |= 1; /* stat failed.  */\n          goto leave;\n        }\n    }\n  /* Check that it is a directory, owned by the user, and only the\n   * user has permissions to use it.  */\n  if (!S_ISDIR(sb.st_mode)\n      || sb.st_uid != getuid ()\n      || (sb.st_mode & (S_IRWXG|S_IRWXO)))\n    {\n      *r_info |= 4; /* Bad permissions or not a directory. */\n      if (!skip_checks)\n        goto leave;\n    }\n\n  /* If a non default homedir is used, we check whether an\n   * corresponding sub directory below the socket dir is available\n   * and use that.  We hash the non default homedir to keep the new\n   * subdir short enough.  */\n  if (non_default_homedir)\n    {\n      char sha1buf[20];\n      char *suffix;\n\n      *r_info |= 32; /* Testing subdir.  */\n      s = gnupg_homedir ();\n      gcry_md_hash_buffer (GCRY_MD_SHA1, sha1buf, s, strlen (s));\n      suffix = zb32_encode (sha1buf, 8*15);\n      if (!suffix)\n        {\n          *r_info |= 1; /* Out of core etc. */\n          goto leave;\n        }\n      name = strconcat (prefix, \"/d.\", suffix, NULL);\n      xfree (suffix);\n      if (!name)\n        {\n          *r_info |= 1; /* Out of core etc. */\n          goto leave;\n        }\n\n      /* Stat that directory and check constraints.\n       * The command\n       *    gpgconf --remove-socketdir\n       * can be used to remove that directory.  */\n      if (stat (name, &sb))\n        {\n          if (errno != ENOENT)\n            *r_info |= 1; /* stat failed. */\n          else if (!skip_checks)\n            {\n              /* Try to create the directory and check again.  */\n              if (gnupg_mkdir (name, \"-rwx\"))\n                *r_info |= 16; /* mkdir failed.  */\n              else if (stat (prefix, &sb))\n                {\n                  if (errno != ENOENT)\n                    *r_info |= 1; /* stat failed. */\n                  else\n                    *r_info |= 64; /* Subdir does not exist.  */\n                }\n              else\n                goto leave; /* Success!  */\n            }\n          else\n            *r_info |= 64; /* Subdir does not exist.  */\n          if (!skip_checks)\n            {\n              xfree (name);\n              name = NULL;\n              goto leave;\n            }\n        }\n      else if (!S_ISDIR(sb.st_mode)\n               || sb.st_uid != getuid ()\n               || (sb.st_mode & (S_IRWXG|S_IRWXO)))\n        {\n          *r_info |= 8; /* Bad permissions or subdir is not a directory.  */\n          if (!skip_checks)\n            {\n              xfree (name);\n              name = NULL;\n              goto leave;\n            }\n        }\n    }\n  else\n    name = xstrdup (prefix);\n\n leave:\n  /* If nothing works fall back to the homedir.  */\n  if (!name)\n    {\n      *r_info |= 128; /* Fallback.  */\n      name = xstrdup (gnupg_homedir ());\n    }\n\n#endif /* Unix */\n\n  return name;\n}\n\n\n/*\n * Return the name of the socket dir.  That is the directory used for\n * the IPC local sockets.  This is an absolute directory name.\n */\nconst char *\ngnupg_socketdir (void)\n{\n  static char *name;\n\n  if (!name)\n    {\n      unsigned int dummy;\n      name = _gnupg_socketdir_internal (0, &dummy);\n    }\n\n  return name;\n}\n\n\n/* Return the name of the sysconfdir.  This is a static string.  This\n   function is required because under Windows we can't simply compile\n   it in.  */\nconst char *\ngnupg_sysconfdir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  static char *name;\n\n  if (!name)\n    {\n      const char *s1, *s2;\n      s1 = w32_commondir ();\n      s2 = DIRSEP_S \"etc\" DIRSEP_S \"gnupg\";\n      name = xmalloc (strlen (s1) + strlen (s2) + 1);\n      strcpy (stpcpy (name, s1), s2);\n    }\n  return name;\n#else /*!HAVE_W32_SYSTEM*/\n  return GNUPG_SYSCONFDIR;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n\nconst char *\ngnupg_bindir (void)\n{\n#if defined (HAVE_W32CE_SYSTEM)\n  static char *name;\n\n  if (!name)\n    name = xstrconcat (w32_rootdir (), DIRSEP_S \"bin\", NULL);\n  return name;\n#elif defined(HAVE_W32_SYSTEM)\n  const char *rdir;\n\n  rdir = w32_rootdir ();\n  if (w32_bin_is_bin)\n    {\n      static char *name;\n\n      if (!name)\n        name = xstrconcat (rdir, DIRSEP_S \"bin\", NULL);\n      return name;\n    }\n  else\n    return rdir;\n#else /*!HAVE_W32_SYSTEM*/\n  return GNUPG_BINDIR;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n\n/* Return the name of the libexec directory.  The name is allocated in\n   a static area on the first use.  This function won't fail. */\nconst char *\ngnupg_libexecdir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  return gnupg_bindir ();\n#else /*!HAVE_W32_SYSTEM*/\n  return GNUPG_LIBEXECDIR;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\nconst char *\ngnupg_libdir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  static char *name;\n\n  if (!name)\n    name = xstrconcat (w32_rootdir (), DIRSEP_S \"lib\" DIRSEP_S \"gnupg\", NULL);\n  return name;\n#else /*!HAVE_W32_SYSTEM*/\n  return GNUPG_LIBDIR;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\nconst char *\ngnupg_datadir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  static char *name;\n\n  if (!name)\n    name = xstrconcat (w32_rootdir (), DIRSEP_S \"share\" DIRSEP_S \"gnupg\", NULL);\n  return name;\n#else /*!HAVE_W32_SYSTEM*/\n  return GNUPG_DATADIR;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n\nconst char *\ngnupg_localedir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  static char *name;\n\n  if (!name)\n    name = xstrconcat (w32_rootdir (), DIRSEP_S \"share\" DIRSEP_S \"locale\",\n                       NULL);\n  return name;\n#else /*!HAVE_W32_SYSTEM*/\n  return LOCALEDIR;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n\n/* Return the name of the cache directory.  The name is allocated in a\n   static area on the first use.  Windows only: If the directory does\n   not exist it is created.  */\nconst char *\ngnupg_cachedir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  static const char *dir;\n\n  if (!dir)\n    {\n      const char *rdir;\n\n      rdir = w32_rootdir ();\n      if (w32_portable_app)\n        {\n          dir = xstrconcat (rdir,\n                            DIRSEP_S, \"var\",\n                            DIRSEP_S, \"cache\",\n                            DIRSEP_S, \"gnupg\", NULL);\n        }\n      else\n        {\n          char path[MAX_PATH];\n          const char *s1[] = { \"GNU\", \"cache\", \"gnupg\", NULL };\n          int s1_len;\n          const char **comp;\n\n          s1_len = 0;\n          for (comp = s1; *comp; comp++)\n            s1_len += 1 + strlen (*comp);\n\n          if (w32_shgetfolderpath (NULL, CSIDL_LOCAL_APPDATA|CSIDL_FLAG_CREATE,\n                                   NULL, 0, path) >= 0)\n            {\n              char *tmp = xmalloc (strlen (path) + s1_len + 1);\n              char *p;\n\n              p = stpcpy (tmp, path);\n              for (comp = s1; *comp; comp++)\n                {\n                  p = stpcpy (p, \"\\\\\");\n                  p = stpcpy (p, *comp);\n\n                  if (access (tmp, F_OK))\n                    w32_try_mkdir (tmp);\n                }\n\n              dir = tmp;\n            }\n          else\n            {\n              dir = \"c:\\\\temp\\\\cache\\\\gnupg\";\n#ifdef HAVE_W32CE_SYSTEM\n              dir += 2;\n              w32_try_mkdir (\"\\\\temp\\\\cache\");\n              w32_try_mkdir (\"\\\\temp\\\\cache\\\\gnupg\");\n#endif\n            }\n        }\n    }\n  return dir;\n#else /*!HAVE_W32_SYSTEM*/\n  return GNUPG_LOCALSTATEDIR \"/cache/\" PACKAGE_NAME;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n\n/* Return the user socket name used by DirMngr.  */\nconst char *\ndirmngr_socket_name (void)\n{\n  static char *name;\n\n  if (!name)\n    name = make_filename (gnupg_socketdir (), DIRMNGR_SOCK_NAME, NULL);\n  return name;\n}\n\n\n/* Return the default pinentry name.  If RESET is true the internal\n   cache is first flushed.  */\nstatic const char *\nget_default_pinentry_name (int reset)\n{\n  static struct {\n    const char *(*rfnc)(void);\n    const char *name;\n  } names[] = {\n    /* The first entry is what we return in case we found no\n       other pinentry.  */\n    { gnupg_bindir, DIRSEP_S \"pinentry\" EXEEXT_S },\n#ifdef HAVE_W32_SYSTEM\n    /* Try Gpg4win directory (with bin and without.) */\n    { w32_rootdir, \"\\\\..\\\\Gpg4win\\\\bin\\\\pinentry.exe\" },\n    { w32_rootdir, \"\\\\..\\\\Gpg4win\\\\pinentry.exe\" },\n    /* Try old Gpgwin directory.  */\n    { w32_rootdir, \"\\\\..\\\\GNU\\\\GnuPG\\\\pinentry.exe\" },\n    /* Try a Pinentry from the common GNU dir.  */\n    { w32_rootdir, \"\\\\..\\\\GNU\\\\bin\\\\pinentry.exe\" },\n#endif\n    /* Last chance is a pinentry-basic (which comes with the\n       GnuPG 2.1 Windows installer).  */\n    { gnupg_bindir, DIRSEP_S \"pinentry-basic\" EXEEXT_S }\n  };\n  static char *name;\n\n  if (reset)\n    {\n      xfree (name);\n      name = NULL;\n    }\n\n  if (!name)\n    {\n      int i;\n\n      for (i=0; i < DIM(names); i++)\n        {\n          char *name2;\n\n          name2 = xstrconcat (names[i].rfnc (), names[i].name, NULL);\n          if (!access (name2, F_OK))\n            {\n              /* Use that pinentry.  */\n              xfree (name);\n              name = name2;\n              break;\n            }\n          if (!i) /* Store the first as fallback return.  */\n            name = name2;\n          else\n            xfree (name2);\n        }\n    }\n\n  return name;\n}\n\n\n/* If set, 'gnupg_module_name' returns modules from that build\n * directory.  */\nstatic char *gnupg_build_directory;\n\n/* For sanity checks.  */\nstatic int gnupg_module_name_called;\n\n\n/* Set NEWDIR as the new build directory.  This will make\n * 'gnupg_module_name' return modules from that build directory.  Must\n * be called before any invocation of 'gnupg_module_name', and must\n * not be called twice.  It can be used by test suites to make sure\n * the components from the build directory are used instead of\n * potentially outdated installed ones.  */\nvoid\ngnupg_set_builddir (const char *newdir)\n{\n  log_assert (! gnupg_module_name_called);\n  log_assert (! gnupg_build_directory);\n  gnupg_build_directory = xtrystrdup (newdir);\n}\n\n\n/* If no build directory has been configured, try to set it from the\n * environment.  We only do this in development builds to avoid\n * increasing the set of influential environment variables and hence\n * the attack surface of production builds.  */\nstatic void\ngnupg_set_builddir_from_env (void)\n{\n#if defined(IS_DEVELOPMENT_VERSION) || defined(ENABLE_GNUPG_BUILDDIR_ENVVAR)\n  if (gnupg_build_directory)\n    return;\n\n  gnupg_build_directory = getenv (\"GNUPG_BUILDDIR\");\n#endif\n}\n\n\n/* Return the file name of a helper tool.  WHICH is one of the\n   GNUPG_MODULE_NAME_foo constants.  */\nconst char *\ngnupg_module_name (int which)\n{\n  gnupg_set_builddir_from_env ();\n  gnupg_module_name_called = 1;\n\n#define X(a,b,c) do {                                                   \\\n    static char *name;                                                  \\\n    if (!name)                                                          \\\n      name = gnupg_build_directory                                      \\\n        ? xstrconcat (gnupg_build_directory,                            \\\n                      DIRSEP_S b DIRSEP_S c EXEEXT_S, NULL)             \\\n        : xstrconcat (gnupg_ ## a (), DIRSEP_S c EXEEXT_S, NULL);       \\\n    return name;                                                        \\\n  } while (0)\n\n  switch (which)\n    {\n    case GNUPG_MODULE_NAME_AGENT:\n#ifdef GNUPG_DEFAULT_AGENT\n      return GNUPG_DEFAULT_AGENT;\n#else\n      X(bindir, \"agent\", \"gpg-agent\");\n#endif\n\n    case GNUPG_MODULE_NAME_PINENTRY:\n#ifdef GNUPG_DEFAULT_PINENTRY\n      return GNUPG_DEFAULT_PINENTRY;  /* (Set by a configure option) */\n#else\n      return get_default_pinentry_name (0);\n#endif\n\n    case GNUPG_MODULE_NAME_SCDAEMON:\n#ifdef GNUPG_DEFAULT_SCDAEMON\n      return GNUPG_DEFAULT_SCDAEMON;\n#else\n      X(libexecdir, \"scd\", \"scdaemon\");\n#endif\n\n    case GNUPG_MODULE_NAME_DIRMNGR:\n#ifdef GNUPG_DEFAULT_DIRMNGR\n      return GNUPG_DEFAULT_DIRMNGR;\n#else\n      X(bindir, \"dirmngr\", DIRMNGR_NAME);\n#endif\n\n    case GNUPG_MODULE_NAME_PROTECT_TOOL:\n#ifdef GNUPG_DEFAULT_PROTECT_TOOL\n      return GNUPG_DEFAULT_PROTECT_TOOL;\n#else\n      X(libexecdir, \"agent\", \"gpg-protect-tool\");\n#endif\n\n    case GNUPG_MODULE_NAME_DIRMNGR_LDAP:\n#ifdef GNUPG_DEFAULT_DIRMNGR_LDAP\n      return GNUPG_DEFAULT_DIRMNGR_LDAP;\n#else\n      X(libexecdir, \"dirmngr\", \"dirmngr_ldap\");\n#endif\n\n    case GNUPG_MODULE_NAME_CHECK_PATTERN:\n      X(libexecdir, \"tools\", \"gpg-check-pattern\");\n\n    case GNUPG_MODULE_NAME_GPGSM:\n      X(bindir, \"sm\", \"gpgsm\");\n\n    case GNUPG_MODULE_NAME_GPG:\n#if USE_GPG2_HACK\n      if (! gnupg_build_directory)\n        X(bindir, \"g10\", GPG_NAME \"2\");\n      else\n#endif\n        X(bindir, \"g10\", GPG_NAME);\n\n    case GNUPG_MODULE_NAME_GPGV:\n#if USE_GPG2_HACK\n      if (! gnupg_build_directory)\n        X(bindir, \"g10\", GPG_NAME \"v2\");\n      else\n#endif\n        X(bindir, \"g10\", GPG_NAME \"v\");\n\n    case GNUPG_MODULE_NAME_CONNECT_AGENT:\n      X(bindir, \"tools\", \"gpg-connect-agent\");\n\n    case GNUPG_MODULE_NAME_GPGCONF:\n      X(bindir, \"tools\", \"gpgconf\");\n\n    default:\n      BUG ();\n    }\n#undef X\n}\n\n\n/* Flush some of the cached module names.  This is for example used by\n   gpg-agent to allow configuring a different pinentry.  */\nvoid\ngnupg_module_name_flush_some (void)\n{\n  (void)get_default_pinentry_name (1);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/common/dynload.h": "/* dynload.h - Wrapper functions for run-time dynamic loading\n *      Copyright (C) 2003, 2010 Free Software Foundation, Inc.\n *\n * This file is part of GnuPG.\n *\n * GnuPG is free software; you can redistribute and/or modify this\n * part of GnuPG under the terms of either\n *\n *   - the GNU Lesser General Public License as published by the Free\n *     Software Foundation; either version 3 of the License, or (at\n *     your option) any later version.\n *\n * or\n *\n *   - the GNU General Public License as published by the Free\n *     Software Foundation; either version 2 of the License, or (at\n *     your option) any later version.\n *\n * or both in parallel, as here.\n *\n * GnuPG is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copies of the GNU General Public License\n * and the GNU Lesser General Public License along with this program;\n * if not, see <https://www.gnu.org/licenses/>.\n */\n\n#ifndef GNUPG_COMMON_DYNLOAD_H\n#define GNUPG_COMMON_DYNLOAD_H\n\n#ifndef __MINGW32__\n# include <dlfcn.h>\n#else\n# include <windows.h>\n# include \"utf8conv.h\"\n# include \"mischelp.h\"\n# define RTLD_LAZY 0\n\nstatic inline void *\ndlopen (const char *name, int flag)\n{\n  void *hd;\n#ifdef HAVE_W32CE_SYSTEM\n  wchar_t *wname = utf8_to_wchar (name);\n  hd = wname? LoadLibrary (wname) : NULL;\n  xfree (wname);\n#else\n  hd = LoadLibrary (name);\n#endif\n  (void)flag;\n  return hd;\n}\n\nstatic inline void *\ndlsym (void *hd, const char *sym)\n{\n  if (hd && sym)\n    {\n#ifdef HAVE_W32CE_SYSTEM\n      wchar_t *wsym = utf8_to_wchar (sym);\n      void *fnc = wsym? GetProcAddress (hd, wsym) : NULL;\n      xfree (wsym);\n#else\n      void *fnc = GetProcAddress (hd, sym);\n#endif\n      if (!fnc)\n        return NULL;\n      return fnc;\n    }\n  return NULL;\n}\n\n\nstatic inline const char *\ndlerror (void)\n{\n  static char buf[32];\n  snprintf (buf, sizeof buf, \"ec=%lu\", GetLastError ());\n  return buf;\n}\n\n\nstatic inline int\ndlclose (void * hd)\n{\n  if (hd)\n    {\n      CloseHandle (hd);\n      return 0;\n    }\n  return -1;\n}\n# endif /*__MINGW32__*/\n#endif /*GNUPG_COMMON_DYNLOAD_H*/\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/common/gnupg.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/samplekeys/68A638998DFABAC510EA645CE34F9686B2EDF7EA.key",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/4gb-packet.asc",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/BE04EB2B-secret.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/1C005AF3-5.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/BE04EB2B-5.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/1C005AF3-2.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/B662E42F.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/1C005AF3-3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/B662E42F-5.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/BE04EB2B-3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/B662E42F-secret.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/BE04EB2B-2.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/B662E42F-4.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/B662E42F-2.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/BE04EB2B-1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/1C005AF3.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/B662E42F-3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/1C005AF3-1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/1C005AF3-secret.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/B662E42F-1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/BE04EB2B-4.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/BE04EB2B.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/conflicting/1C005AF3-4.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-3.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/cross-sigs/EC38277E-2.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-4.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-2.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/cross-sigs/EC38277E-2.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/cross-sigs/EC38277E-3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/cross-sigs/EC38277E-1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-secret.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-2.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-1.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/cross-sigs/EC38277E-secret.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/openpgp/tofu/cross-sigs/EC38277E-1.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/gpgsm/cert_dfn_pca01.der",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/gpgsm/cert_dfn_pca15.der",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/tests/gpgsm/cert_g10code_test1.der",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/fi.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/et.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/ro.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/sv.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/uk.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/ja.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/pt.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/fr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/de.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/id.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/eo.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/hu.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/sk.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/nb.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/cs.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/en@boldquot.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/pl.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/gl.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/en@quot.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/zh_CN.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/el.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/da.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/zh_TW.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/es.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/it.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/ca.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/ru.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/po/tr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/build-aux/speedo/w32/inst.nsi",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/build-aux/speedo/w32/gnupg-logo-164x314.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/build-aux/speedo/w32/gnupg-logo-150x57.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/doc/gnupg-card-architecture.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/doc/gnupg-module-overview.png",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/doc/gnupg-logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/doc/gnupg-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/doc/gnupg-card-architecture.png",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/doc/gnupg-module-overview.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/doc/gnupg-logo-tr.png",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/g10/t-keydb-get-keyblock.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/g10/distsigkey.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/g10/t-stutter-data.asc",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.17-nqczgd52xih2kmcxo7figepsefq54s34/spack-src/g10/t-keydb-keyring.kbx"
    ],
    "total_files": 1018
}