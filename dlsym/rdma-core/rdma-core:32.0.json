{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rdma-core-32.0-lld5dj4lbomjn74h62u554lxb2v6qnhz/spack-src/ibacm/src/acm.c": "/*\n * Copyright (c) 2009-2014 Intel Corporation. All rights reserved.\n * Copyright (c) 2013 Mellanox Technologies LTD. All rights reserved.\n *\n * This software is available to you under the OpenIB.org BSD license\n * below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AWV\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#define _GNU_SOURCE\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <osd.h>\n#include <arpa/inet.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <infiniband/acm.h>\n#include <infiniband/acm_prov.h>\n#include <infiniband/umad.h>\n#include <infiniband/verbs.h>\n#include <infiniband/umad_types.h>\n#include <infiniband/umad_sa.h>\n#include <dlfcn.h>\n#include <search.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <net/if_arp.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <rdma/rdma_netlink.h>\n#include <rdma/ib_user_sa.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <getopt.h>\n#include <systemd/sd-daemon.h>\n#include <ccan/list.h>\n#include <util/util.h>\n#include \"acm_mad.h\"\n#include \"acm_util.h\"\n\n#define NL_MSG_BUF_SIZE 4096\n#define ACM_PROV_NAME_SIZE 64\n#define NL_CLIENT_INDEX 0\n\nstruct acmc_subnet {\n\tstruct list_node       entry;\n\t__be64                 subnet_prefix;\n};\n\nstruct acmc_prov {\n\tstruct acm_provider    *prov;\n\tvoid                   *handle;\n\tstruct list_node       entry;\n\tstruct list_head       subnet_list;\n};\n\nstruct acmc_prov_context {\n\tstruct list_node        entry;\n\tatomic_t                refcnt;\n\tstruct acm_provider     *prov;\n\tvoid                    *context;\n};\n\nstruct acmc_device;\n\nstruct acmc_port {\n\tstruct acmc_device  *dev;\n\tstruct acm_port     port;\n\tstruct acm_provider *prov; /* limit to 1 provider per port for now */\n\tvoid                *prov_port_context;\n\tint\t\t    mad_portid;\n\tint\t\t    mad_agentid;\n\tstruct ib_mad_addr  sa_addr;\n\tstruct list_head    sa_pending;\n\tstruct list_head    sa_wait;\n\tint\t\t    sa_credits;\n\tpthread_mutex_t     lock;\n\tstruct list_head    ep_list;\n\tenum ibv_port_state state;\n\tint                 gid_cnt;\n\tunion ibv_gid       *gid_tbl;\n\tuint16_t            lid;\n\tuint16_t            lid_mask;\n\tint                 sa_pkey_index;\n\tbool\t\t    pending_rereg;\n\tuint16_t            def_acm_pkey;\n};\n\nstruct acmc_device {\n\tstruct acm_device       device;\n\tstruct list_node        entry;\n\tstruct list_head        prov_dev_context_list;\n\tint                     port_cnt;\n\tstruct acmc_port        port[0];\n};\n\nstruct acmc_addr {\n\tstruct acm_address    addr;\n\tvoid                  *prov_addr_context;\n\tchar\t\t      string_buf[ACM_MAX_ADDRESS];\n};\n\nstruct acmc_ep {\n\tstruct acmc_port      *port;\n\tstruct acm_endpoint   endpoint;\n\tvoid                  *prov_ep_context;\n\t/* Although the below two entries are used for dynamic allocations,\n\t * they are accessed by a single thread, so no locking is required.\n\t */\n\tint                   nmbr_ep_addrs;\n\tstruct acmc_addr      *addr_info;\n\tstruct list_node      entry;\n};\n\nstruct acmc_client {\n\tpthread_mutex_t lock;   /* acquire ep lock first */\n\tint      sock;\n\tint      index;\n\tatomic_t refcnt;\n};\n\nunion socket_addr {\n\tstruct sockaddr     sa;\n\tstruct sockaddr_in  sin;\n\tstruct sockaddr_in6 sin6;\n};\n\nstruct acmc_sa_req {\n\tstruct list_node\tentry;\n\tstruct acmc_ep\t\t*ep;\n\tvoid\t\t\t(*resp_handler)(struct acm_sa_mad *);\n\tstruct acm_sa_mad\tmad;\n};\n\nstruct acm_nl_path {\n\tstruct nlattr\t\t\tattr_hdr;\n\tstruct ib_path_rec_data\t\trec;\n};\n\nstruct acm_nl_msg {\n\tstruct nlmsghdr\t\t\t\tnlmsg_header;\n\tunion {\n\t\tuint8_t\t\t\t\tdata[ACM_MSG_DATA_LENGTH];\n\t\tstruct rdma_ls_resolve_header\tresolve_header;\n\t\tstruct nlattr\t\t\tattr[0];\n\t\tstruct acm_nl_path\t\tpath[0];\n\t};\n};\n\nstatic char def_prov_name[ACM_PROV_NAME_SIZE] = \"ibacmp\";\nstatic LIST_HEAD(provider_list);\nstatic struct acmc_prov *def_provider = NULL;\n\nstatic LIST_HEAD(dev_list);\n\nstatic int listen_socket;\nstatic int ip_mon_socket;\nstatic struct acmc_client client_array[FD_SETSIZE - 1];\n\nstatic FILE *flog;\nstatic pthread_mutex_t log_lock;\nstatic __thread char log_data[ACM_MAX_ADDRESS];\nstatic atomic_t counter[ACM_MAX_COUNTER];\n\nstatic struct acmc_device *\nacm_get_device_from_gid(union ibv_gid *sgid, uint8_t *port);\nstatic struct acmc_ep *acm_find_ep(struct acmc_port *port, uint16_t pkey);\nstatic int acm_ep_insert_addr(struct acmc_ep *ep, const char *name, uint8_t *addr,\n\t\t\t      uint8_t addr_type);\nstatic void acm_event_handler(struct acmc_device *dev);\nstatic int acm_nl_send(int sock, struct acm_msg *msg);\n\nstatic struct sa_data {\n\tint\t\ttimeout;\n\tint\t\tretries;\n\tint\t\tdepth;\n\tpthread_t\tthread_id;\n\tstruct pollfd\t*fds;\n\tstruct acmc_port **ports;\n\tint\t\tnfds;\n} sa = { 2000, 2, 1, 0, NULL, NULL, 0};\n\n/*\n * Service options - may be set through ibacm_opts.cfg file.\n */\nstatic const char *acme = IBACM_BIN_PATH \"/ib_acme -A\";\nstatic const char *opts_file = ACM_CONF_DIR \"/\" ACM_OPTS_FILE;\nstatic const char *addr_file = ACM_CONF_DIR \"/\" ACM_ADDR_FILE;\nstatic char log_file[128] = IBACM_LOG_FILE;\nstatic int log_level = 0;\nstatic char lock_file[128] = IBACM_PID_FILE;\nstatic short server_port = 6125;\nstatic int server_mode = IBACM_SERVER_MODE_DEFAULT;\nstatic int acme_plus_kernel_only = IBACM_ACME_PLUS_KERNEL_ONLY_DEFAULT;\nstatic int support_ips_in_addr_cfg = 0;\nstatic char prov_lib_path[256] = IBACM_LIB_PATH;\n\nvoid acm_write(int level, const char *format, ...)\n{\n\tva_list args;\n\tstruct timeval tv;\n\tstruct tm tmtime;\n\tchar buffer[20];\n\n\tif (level > log_level)\n\t\treturn;\n\n\tgettimeofday(&tv, NULL);\n\tlocaltime_r(&tv.tv_sec, &tmtime);\n\tstrftime(buffer, 20, \"%Y-%m-%dT%H:%M:%S\", &tmtime);\n\tva_start(args, format);\n\tpthread_mutex_lock(&log_lock);\n\tfprintf(flog, \"%s.%03u: \", buffer, (unsigned) (tv.tv_usec / 1000));\n\tvfprintf(flog, format, args);\n\tfflush(flog);\n\tpthread_mutex_unlock(&log_lock);\n\tva_end(args);\n}\n\nvoid acm_format_name(int level, char *name, size_t name_size,\n\t\t     uint8_t addr_type, const uint8_t *addr, size_t addr_size)\n{\n\tstruct ibv_path_record *path;\n\n\tif (level > log_level)\n\t\treturn;\n\n\tswitch (addr_type) {\n\tcase ACM_EP_INFO_NAME:\n\t\tmemcpy(name, addr, addr_size);\n\t\tbreak;\n\tcase ACM_EP_INFO_ADDRESS_IP:\n\t\tinet_ntop(AF_INET, addr, name, name_size);\n\t\tbreak;\n\tcase ACM_EP_INFO_ADDRESS_IP6:\n\tcase ACM_ADDRESS_GID:\n\t\tinet_ntop(AF_INET6, addr, name, name_size);\n\t\tbreak;\n\tcase ACM_EP_INFO_PATH:\n\t\tpath = (struct ibv_path_record *) addr;\n\t\tif (path->dlid) {\n\t\t\tsnprintf(name, name_size, \"SLID(%u) DLID(%u)\",\n\t\t\t\tbe16toh(path->slid), be16toh(path->dlid));\n\t\t} else {\n\t\t\tacm_format_name(level, name, name_size, ACM_ADDRESS_GID,\n\t\t\t\t\tpath->dgid.raw, sizeof path->dgid);\n\t\t}\n\t\tbreak;\n\tcase ACM_ADDRESS_LID:\n\t\tsnprintf(name, name_size, \"LID(%u)\", be16toh(*((__be16 *) addr)));\n\t\tbreak;\n\tdefault:\n\t\tstrcpy(name, \"Unknown\");\n\t\tbreak;\n\t}\n}\n\nint ib_any_gid(union ibv_gid *gid)\n{\n\treturn ((gid->global.subnet_prefix | gid->global.interface_id) == 0);\n}\n\nconst char *acm_get_opts_file(void)\n{\n\treturn opts_file;\n}\n\nvoid acm_increment_counter(int type)\n{\n\tif (type >= 0 && type < ACM_MAX_COUNTER)\n\t\tatomic_inc(&counter[type]);\n}\n\nstatic struct acmc_prov_context *\nacm_alloc_prov_context(struct acm_provider *prov)\n{\n\tstruct acmc_prov_context *ctx;\n\n\tctx = calloc(1, sizeof(*ctx));\n\tif (!ctx) {\n\t\tacm_log(0, \"Error: failed to allocate prov context\\n\");\n\t\treturn NULL;\n\t}\n\tatomic_set(&ctx->refcnt, 1);\n\tctx->prov = prov;\n\treturn ctx;\n}\n\nstatic struct acmc_prov_context *\nacm_get_prov_context(struct list_head *list, struct acm_provider *prov)\n{\n\tstruct acmc_prov_context *ctx;\n\n\tlist_for_each(list, ctx, entry) {\n\t\tif (ctx->prov == prov) {\n\t\t\treturn ctx;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct acmc_prov_context *\nacm_acquire_prov_context(struct list_head *list, struct acm_provider *prov)\n{\n\tstruct acmc_prov_context *ctx;\n\n\tctx = acm_get_prov_context(list, prov);\n\tif (!ctx) {\n\t\tctx = acm_alloc_prov_context(prov);\n\t\tif (!ctx) {\n\t\t\tacm_log(0, \"Error -- failed to allocate provider context\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tlist_add_tail(list, &ctx->entry);\n\t} else {\n\t\tatomic_inc(&ctx->refcnt);\n\t}\n\n\treturn ctx;\n}\n\nstatic void\nacm_release_prov_context(struct acmc_prov_context *ctx)\n{\n\tif (atomic_dec(&ctx->refcnt) <= 0) {\n\t\tlist_del(&ctx->entry);\n\t\tfree(ctx);\n\t}\n}\n\nuint8_t acm_gid_index(struct acm_port *port, union ibv_gid *gid)\n{\n\tuint8_t i;\n\tstruct acmc_port *cport;\n\n\tcport = container_of(port, struct acmc_port, port);\n\tfor (i = 0; i < cport->gid_cnt; i++) {\n\t\tif (!memcmp(&cport->gid_tbl[i], gid, sizeof (*gid)))\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nint acm_get_gid(struct acm_port *port, int index, union ibv_gid *gid)\n{\n\tstruct acmc_port *cport;\n\n\tcport = container_of(port, struct acmc_port, port);\n\tif (index >= 0 && index < cport->gid_cnt) {\n\t\t*gid = cport->gid_tbl[index];\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n}\n\nstatic size_t acm_addr_len(uint8_t addr_type)\n{\n\tswitch (addr_type) {\n\tcase ACM_ADDRESS_NAME:\n\t\treturn ACM_MAX_ADDRESS;\n\tcase ACM_ADDRESS_IP:\n\t\treturn sizeof(struct in_addr);\n\tcase ACM_ADDRESS_IP6:\n\t\treturn sizeof(struct in6_addr);\n\tcase ACM_ADDRESS_GID:\n\t\treturn sizeof(union ibv_gid);\n\tcase ACM_ADDRESS_LID:\n\t\treturn sizeof(uint16_t);\n\tdefault:\n\t\tacm_log(2, \"illegal address type %d\\n\", addr_type);\n\t}\n\treturn 0;\n}\n\nstatic int acm_addr_cmp(struct acm_address *acm_addr, uint8_t *addr, uint8_t addr_type)\n{\n\tif (acm_addr->type != addr_type)\n\t\treturn -2;\n\n\tif (acm_addr->type == ACM_ADDRESS_NAME)\n\t\treturn strncasecmp((char *) acm_addr->info.name,\n\t\t\t\t   (char *) addr, acm_addr_len(acm_addr->type));\n\treturn memcmp(acm_addr->info.addr, addr, acm_addr_len(acm_addr->type));\n}\n\nstatic void acm_mark_addr_invalid(struct acmc_ep *ep,\n\t\t\t\t  struct acm_ep_addr_data *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ep->nmbr_ep_addrs; i++) {\n\t\tif (!acm_addr_cmp(&ep->addr_info[i].addr, data->info.addr, data->type)) {\n\t\t\tep->addr_info[i].addr.type = ACM_ADDRESS_INVALID;\n\t\t\tep->port->prov->remove_address(ep->addr_info[i].prov_addr_context);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct acm_address *\nacm_addr_lookup(const struct acm_endpoint *endpoint, uint8_t *addr, uint8_t addr_type)\n{\n\tstruct acmc_ep *ep;\n\tint i;\n\n\tep = container_of(endpoint, struct acmc_ep, endpoint);\n\tfor (i = 0; i < ep->nmbr_ep_addrs; i++)\n\t\tif (!acm_addr_cmp(&ep->addr_info[i].addr, addr, addr_type))\n\t\t\treturn &ep->addr_info[i].addr;\n\n\treturn NULL;\n}\n\n__be64 acm_path_comp_mask(struct ibv_path_record *path)\n{\n\tuint32_t fl_hop;\n\tuint16_t qos_sl;\n\t__be64 comp_mask = 0;\n\n\tacm_log(2, \"\\n\");\n\tif (path->service_id)\n\t\tcomp_mask |= IB_COMP_MASK_PR_SERVICE_ID;\n\tif (!ib_any_gid(&path->dgid))\n\t\tcomp_mask |= IB_COMP_MASK_PR_DGID;\n\tif (!ib_any_gid(&path->sgid))\n\t\tcomp_mask |= IB_COMP_MASK_PR_SGID;\n\tif (path->dlid)\n\t\tcomp_mask |= IB_COMP_MASK_PR_DLID;\n\tif (path->slid)\n\t\tcomp_mask |= IB_COMP_MASK_PR_SLID;\n\n\tfl_hop = be32toh(path->flowlabel_hoplimit);\n\tif (fl_hop >> 8)\n\t\tcomp_mask |= IB_COMP_MASK_PR_FLOW_LABEL;\n\tif (fl_hop & 0xFF)\n\t\tcomp_mask |= IB_COMP_MASK_PR_HOP_LIMIT;\n\n\tif (path->tclass)\n\t\tcomp_mask |= IB_COMP_MASK_PR_TCLASS;\n\tif (path->reversible_numpath & 0x80)\n\t\tcomp_mask |= IB_COMP_MASK_PR_REVERSIBLE;\n\tif (path->pkey)\n\t\tcomp_mask |= IB_COMP_MASK_PR_PKEY;\n\n\tqos_sl = be16toh(path->qosclass_sl);\n\tif (qos_sl >> 4)\n\t\tcomp_mask |= IB_COMP_MASK_PR_QOS_CLASS;\n\tif (qos_sl & 0xF)\n\t\tcomp_mask |= IB_COMP_MASK_PR_SL;\n\n\tif (path->mtu & 0xC0)\n\t\tcomp_mask |= IB_COMP_MASK_PR_MTU_SELECTOR;\n\tif (path->mtu & 0x3F)\n\t\tcomp_mask |= IB_COMP_MASK_PR_MTU;\n\tif (path->rate & 0xC0)\n\t\tcomp_mask |= IB_COMP_MASK_PR_RATE_SELECTOR;\n\tif (path->rate & 0x3F)\n\t\tcomp_mask |= IB_COMP_MASK_PR_RATE;\n\tif (path->packetlifetime & 0xC0)\n\t\tcomp_mask |= IB_COMP_MASK_PR_PACKET_LIFETIME_SELECTOR;\n\tif (path->packetlifetime & 0x3F)\n\t\tcomp_mask |= IB_COMP_MASK_PR_PACKET_LIFETIME;\n\n\treturn comp_mask;\n}\n\nint acm_resolve_response(uint64_t id, struct acm_msg *msg)\n{\n\tstruct acmc_client *client = &client_array[id];\n\tint ret;\n\n\tacm_log(2, \"client %d, status 0x%x\\n\", client->index, msg->hdr.status);\n\n\tif (msg->hdr.status == ACM_STATUS_ENODATA)\n\t\tatomic_inc(&counter[ACM_CNTR_NODATA]);\n\telse if (msg->hdr.status)\n\t\tatomic_inc(&counter[ACM_CNTR_ERROR]);\n\n\tpthread_mutex_lock(&client->lock);\n\tif (client->sock == -1) {\n\t\tacm_log(0, \"ERROR - connection lost\\n\");\n\t\tret = ACM_STATUS_ENOTCONN;\n\t\tgoto release;\n\t}\n\n\tif (id == NL_CLIENT_INDEX)\n\t\tret = acm_nl_send(client->sock, msg);\n\telse\n\t\tret = send(client->sock, (char *) msg, msg->hdr.length, 0);\n\n\tif (ret != msg->hdr.length)\n\t\tacm_log(0, \"ERROR - failed to send response\\n\");\n\telse\n\t\tret = 0;\n\nrelease:\n\tpthread_mutex_unlock(&client->lock);\n\t(void) atomic_dec(&client->refcnt);\n\treturn ret;\n}\n\nstatic int\nacmc_resolve_response(uint64_t id, struct acm_msg *req_msg, uint8_t status)\n{\n\treq_msg->hdr.opcode |= ACM_OP_ACK;\n\treq_msg->hdr.status = status;\n\tif (status != ACM_STATUS_SUCCESS)\n\t\treq_msg->hdr.length = ACM_MSG_HDR_LENGTH;\n\tmemset(req_msg->hdr.data, 0, sizeof(req_msg->hdr.data));\n\n\treturn acm_resolve_response(id, req_msg);\n}\n\nint acm_query_response(uint64_t id, struct acm_msg *msg)\n{\n\tstruct acmc_client *client = &client_array[id];\n\tint ret;\n\n\tacm_log(2, \"status 0x%x\\n\", msg->hdr.status);\n\tpthread_mutex_lock(&client->lock);\n\tif (client->sock == -1) {\n\t\tacm_log(0, \"ERROR - connection lost\\n\");\n\t\tret = ACM_STATUS_ENOTCONN;\n\t\tgoto release;\n\t}\n\n\tret = send(client->sock, (char *) msg, msg->hdr.length, 0);\n\tif (ret != msg->hdr.length)\n\t\tacm_log(0, \"ERROR - failed to send response\\n\");\n\telse\n\t\tret = 0;\n\nrelease:\n\tpthread_mutex_unlock(&client->lock);\n\t(void) atomic_dec(&client->refcnt);\n\treturn ret;\n}\n\nstatic int acmc_query_response(uint64_t id, struct acm_msg *msg, uint8_t status)\n{\n\tacm_log(2, \"status 0x%x\\n\", status);\n\tmsg->hdr.opcode |= ACM_OP_ACK;\n\tmsg->hdr.status = status;\n\treturn acm_query_response(id, msg);\n}\n\nstatic void acm_init_server(void)\n{\n\tFILE *f;\n\tint i;\n\n\tfor (i = 0; i < FD_SETSIZE - 1; i++) {\n\t\tpthread_mutex_init(&client_array[i].lock, NULL);\n\t\tclient_array[i].index = i;\n\t\tclient_array[i].sock = -1;\n\t\tatomic_init(&client_array[i].refcnt);\n\t}\n\n\tif (server_mode != IBACM_SERVER_MODE_UNIX) {\n\t\tf = fopen(IBACM_IBACME_PORT_FILE, \"w\");\n\t\tif (f) {\n\t\t\tfprintf(f, \"%hu\\n\", server_port);\n\t\t\tfclose(f);\n\t\t} else\n\t\t\tacm_log(0,\n\t\t\t\t\"notice - cannot publish ibacm port number\\n\");\n\n\t\tunlink(IBACM_PORT_FILE);\n\t\tif (!acme_plus_kernel_only) {\n\t\t\tif (symlink(IBACM_PORT_BASE, IBACM_PORT_FILE) != 0)\n\t\t\t\tacm_log(0,\n\t\t\t\t\t\"notice - can't create port symlink\\n\");\n\t\t}\n\t} else {\n\t\tunlink(IBACM_IBACME_PORT_FILE);\n\t\tunlink(IBACM_PORT_FILE);\n\t}\n}\n\nstatic int acm_listen(void)\n{\n\tunion {\n\t\tstruct sockaddr any;\n\t\tstruct sockaddr_in inet;\n\t\tstruct sockaddr_un unx;\n\t} addr;\n\tmode_t saved_mask;\n\tint ret, saved_errno;\n\n\tacm_log(2, \"\\n\");\n\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (server_mode == IBACM_SERVER_MODE_UNIX) {\n\t\taddr.any.sa_family = AF_UNIX;\n\t\tBUILD_ASSERT(sizeof(IBACM_IBACME_SERVER_PATH) <=\n\t\t\t     sizeof(addr.unx.sun_path));\n\t\tstrcpy(addr.unx.sun_path, IBACM_IBACME_SERVER_PATH);\n\n\t\tlisten_socket = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\tif (listen_socket < 0) {\n\t\t\tacm_log(0,\n\t\t\t\t\"ERROR - unable to allocate unix socket\\n\");\n\t\t\treturn errno;\n\t\t}\n\n\t\tunlink(addr.unx.sun_path);\n\t\tsaved_mask = umask(0);\n\t\tret = bind(listen_socket, &addr.any, sizeof(addr.unx));\n\t\tsaved_errno = errno;\n\t\tumask(saved_mask);\n\n\t\tif (ret) {\n\t\t\tacm_log(0,\n\t\t\t\t\"ERROR - unable to bind listen socket '%s'\\n\",\n\t\t\t\taddr.unx.sun_path);\n\t\t\treturn saved_errno;\n\t\t}\n\n\t\tunlink(IBACM_SERVER_PATH);\n\t\tif (!acme_plus_kernel_only) {\n\t\t\tif (symlink(IBACM_SERVER_BASE,\n\t\t\t\t    IBACM_SERVER_PATH) != 0) {\n\t\t\t\tsaved_errno = errno;\n\t\t\t\tacm_log(0,\n\t\t\t\t\t\"notice - can't create symlink\\n\");\n\t\t\t\treturn saved_errno;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tunlink(IBACM_IBACME_SERVER_PATH);\n\t\tunlink(IBACM_SERVER_PATH);\n\n\t\tlisten_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\t\tif (listen_socket == -1) {\n\t\t\tacm_log(0,\n\t\t\t\t\"ERROR - unable to allocate TCP socket\\n\");\n\t\t\treturn errno;\n\t\t}\n\n\t\taddr.any.sa_family = AF_INET;\n\t\taddr.inet.sin_port = htobe16(server_port);\n\t\tif (server_mode == IBACM_SERVER_MODE_LOOP)\n\t\t\taddr.inet.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\tret = bind(listen_socket, &addr.any, sizeof(addr.inet));\n\t\tif (ret == -1) {\n\t\t\tacm_log(0, \"ERROR - unable to bind listen socket\\n\");\n\t\t\treturn errno;\n\t\t}\n\t}\n\n\tret = listen(listen_socket, 0);\n\tif (ret == -1) {\n\t\tacm_log(0, \"ERROR - unable to start listen\\n\");\n\t\treturn errno;\n\t}\n\n\tacm_log(2, \"listen active\\n\");\n\treturn 0;\n}\n\n/* Retrieve the listening socket from systemd. */\nstatic int acm_listen_systemd(void)\n{\n\tint fd;\n\n\tint rc = sd_listen_fds(1);\n\tif (rc == -1) {\n\t\tfprintf(stderr, \"sd_listen_fds failed %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (rc > 2) {\n\t\tfprintf(stderr,\n\t\t\t\"sd_listen_fds returned %d fds, expected <= 2\\n\", rc);\n\t\treturn -1;\n\t}\n\n\tfor (fd = SD_LISTEN_FDS_START; fd != SD_LISTEN_FDS_START + rc; fd++) {\n\t\tif (sd_is_socket(fd, AF_NETLINK, SOCK_RAW, 0)) {\n\t\t\t/* ListenNetlink for RDMA_NL_GROUP_LS multicast\n\t\t\t * messages from the kernel\n\t\t\t */\n\t\t\tif (client_array[NL_CLIENT_INDEX].sock != -1) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"sd_listen_fds returned more than one netlink socket\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tclient_array[NL_CLIENT_INDEX].sock = fd;\n\n\t\t\t/* systemd sets NONBLOCK on the netlink socket, while\n\t\t\t * we want blocking send to the kernel.\n\t\t\t */\n\t\t\tif (set_fd_nonblock(fd, false)) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Unable to drop O_NOBLOCK on netlink socket\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (sd_is_socket(SD_LISTEN_FDS_START, AF_UNSPEC,\n\t\t\t\t\tSOCK_STREAM, 1)) {\n\t\t\t/* Socket for user space client communication */\n\t\t\tif (listen_socket != -1) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"sd_listen_fds returned more than one listening socket\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tlisten_socket = fd;\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"sd_listen_fds socket is not a SOCK_STREAM/SOCK_NETLINK listening socket\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void acm_disconnect_client(struct acmc_client *client)\n{\n\tpthread_mutex_lock(&client->lock);\n\tshutdown(client->sock, SHUT_RDWR);\n\tclose(client->sock);\n\tclient->sock = -1;\n\tpthread_mutex_unlock(&client->lock);\n\t(void) atomic_dec(&client->refcnt);\n}\n\nstatic void acm_svr_accept(void)\n{\n\tint s;\n\tint i;\n\n\tacm_log(2, \"\\n\");\n\ts = accept(listen_socket, NULL, NULL);\n\tif (s == -1) {\n\t\tacm_log(0, \"ERROR - failed to accept connection\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < FD_SETSIZE - 1; i++) {\n\t\tif (i == NL_CLIENT_INDEX)\n\t\t\tcontinue;\n\t\tif (!atomic_get(&client_array[i].refcnt))\n\t\t\tbreak;\n\t}\n\n\tif (i == FD_SETSIZE - 1) {\n\t\tacm_log(0, \"ERROR - all connections busy - rejecting\\n\");\n\t\tclose(s);\n\t\treturn;\n\t}\n\n\tclient_array[i].sock = s;\n\tatomic_set(&client_array[i].refcnt, 1);\n\tacm_log(2, \"assigned client %d\\n\", i);\n}\n\nstatic int\nacm_is_path_from_port(struct acmc_port *port, struct ibv_path_record *path)\n{\n\tuint8_t i;\n\n\tif (!ib_any_gid(&path->sgid)) {\n\t\treturn (acm_gid_index(&port->port, &path->sgid) <\n\t\t\tport->gid_cnt);\n\t}\n\n\tif (path->slid) {\n\t\treturn (port->lid == (be16toh(path->slid) & port->lid_mask));\n\t}\n\n\tif (ib_any_gid(&path->dgid)) {\n\t\treturn 1;\n\t}\n\n\tif (acm_gid_index(&port->port, &path->dgid) < port->gid_cnt) {\n\t\treturn 1;\n\t}\n\n\tfor (i = 0; i < port->gid_cnt; i++) {\n\t\tif (port->gid_tbl[i].global.subnet_prefix ==\n\t\t    path->dgid.global.subnet_prefix) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool acm_same_partition(uint16_t pkey_a, uint16_t pkey_b)\n{\n\n\tacm_log(2, \"pkey_a: 0x%04x pkey_b: 0x%04x\\n\", pkey_a, pkey_b);\n\n\treturn ((pkey_a | IB_PKEY_FULL_MEMBER) == (pkey_b | IB_PKEY_FULL_MEMBER));\n}\n\nstatic struct acmc_addr *\nacm_get_port_ep_address(struct acmc_port *port, struct acm_ep_addr_data *data)\n{\n\tstruct acmc_ep *ep;\n\tstruct acm_address *addr;\n\tint i;\n\n\tif (port->state != IBV_PORT_ACTIVE)\n\t\treturn NULL;\n\n\tif (data->type == ACM_EP_INFO_PATH &&\n\t    !acm_is_path_from_port(port, &data->info.path))\n\t\treturn NULL;\n\n\tlist_for_each(&port->ep_list, ep, entry) {\n\t\tif ((data->type == ACM_EP_INFO_PATH) &&\n\t\t    (!data->info.path.pkey ||\n\t\t     acm_same_partition(be16toh(data->info.path.pkey), ep->endpoint.pkey))) {\n\t\t\tfor (i = 0; i < ep->nmbr_ep_addrs; i++) {\n\t\t\t\tif (ep->addr_info[i].addr.type)\n\t\t\t\t\treturn &ep->addr_info[i];\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ((addr = acm_addr_lookup(&ep->endpoint, data->info.addr,\n\t\t\t\t\t    (uint8_t) data->type)))\n\t\t\treturn container_of(addr, struct acmc_addr, addr);\n\t}\n\n\treturn NULL;\n}\n\nstatic struct acmc_addr *acm_get_ep_address(struct acm_ep_addr_data *data)\n{\n\tstruct acmc_device *dev;\n\tstruct acmc_addr *addr;\n\tint i;\n\n\tacm_format_name(2, log_data, sizeof log_data,\n\t\t\tdata->type, data->info.addr, sizeof data->info.addr);\n\tacm_log(2, \"%s\\n\", log_data);\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (i = 0; i < dev->port_cnt; i++) {\n\t\t\taddr = acm_get_port_ep_address(&dev->port[i], data);\n\t\t\tif (addr)\n\t\t\t\treturn addr;\n\t\t}\n\t}\n\n\tacm_format_name(0, log_data, sizeof log_data,\n\t\t\tdata->type, data->info.addr, sizeof data->info.addr);\n\tacm_log(1, \"notice - could not find %s\\n\", log_data);\n\treturn NULL;\n}\n\n/* If port_num is zero, iterate through all ports, otherwise consider\n * only the specific port_num */\nstatic struct acmc_ep *acm_get_ep(int index, uint8_t port_num)\n{\n\tstruct acmc_device *dev;\n\tstruct acmc_ep *ep;\n\tint i, inx = 0;\n\n\tacm_log(2, \"ep index %d\\n\", index);\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (i = 0; i < dev->port_cnt; i++) {\n\t\t\tif (port_num && port_num != (i + 1))\n\t\t\t\tcontinue;\n\t\t\tif (dev->port[i].state != IBV_PORT_ACTIVE)\n\t\t\t\tcontinue;\n\t\t\tlist_for_each(&dev->port[i].ep_list, ep, entry) {\n\t\t\t\tif (index == inx)\n\t\t\t\t\treturn ep;\n\t\t\t\t++inx;\n\t\t\t}\n\t\t}\n\t}\n\n\tacm_log(1, \"notice - could not find ep %d\\n\", index);\n\treturn NULL;\n}\n\nstatic int\nacm_svr_query_path(struct acmc_client *client, struct acm_msg *msg)\n{\n\tstruct acmc_addr *addr;\n\tstruct acmc_ep *ep;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tif (msg->hdr.length != ACM_MSG_HDR_LENGTH + ACM_MSG_EP_LENGTH) {\n\t\tacm_log(0, \"ERROR - invalid length: 0x%x\\n\", msg->hdr.length);\n\t\treturn acmc_query_response(client->index, msg, ACM_STATUS_EINVAL);\n\t}\n\n\taddr = acm_get_ep_address(&msg->resolve_data[0]);\n\tif (!addr) {\n\t\tacm_log(1, \"notice - could not find local end point address\\n\");\n\t\treturn acmc_query_response(client->index, msg, ACM_STATUS_ESRCADDR);\n\t}\n\n\tep = container_of(addr->addr.endpoint, struct acmc_ep, endpoint);\n\treturn ep->port->prov->query(addr->prov_addr_context, msg, client->index);\n}\n\nstatic int acm_svr_select_src(struct acm_ep_addr_data *src, struct acm_ep_addr_data *dst)\n{\n\tunion socket_addr addr;\n\tsocklen_t len;\n\tint ret;\n\tint s;\n\n\tacm_log(2, \"selecting source address\\n\");\n\tmemset(&addr, 0, sizeof addr);\n\tswitch (dst->type) {\n\tcase ACM_EP_INFO_ADDRESS_IP:\n\t\taddr.sin.sin_family = AF_INET;\n\t\tmemcpy(&addr.sin.sin_addr, dst->info.addr, 4);\n\t\tlen = sizeof(struct sockaddr_in);\n\t\tbreak;\n\tcase ACM_EP_INFO_ADDRESS_IP6:\n\t\taddr.sin6.sin6_family = AF_INET6;\n\t\tmemcpy(&addr.sin6.sin6_addr, dst->info.addr, 16);\n\t\tlen = sizeof(struct sockaddr_in6);\n\t\tbreak;\n\tdefault:\n\t\tacm_log(1, \"notice - bad destination type, cannot lookup source\\n\");\n\t\treturn ACM_STATUS_EDESTTYPE;\n\t}\n\n\ts = socket(addr.sa.sa_family, SOCK_DGRAM, IPPROTO_UDP);\n\tif (s == -1) {\n\t\tacm_log(0, \"ERROR - unable to allocate socket\\n\");\n\t\treturn errno;\n\t}\n\n\tret = connect(s, &addr.sa, len);\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - unable to connect socket\\n\");\n\t\tret = errno;\n\t\tgoto out;\n\t}\n\n\tret = getsockname(s, &addr.sa, &len);\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - failed to get socket address\\n\");\n\t\tret = errno;\n\t\tgoto out;\n\t}\n\n\tsrc->type = dst->type;\n\tsrc->flags = ACM_EP_FLAG_SOURCE;\n\tif (dst->type == ACM_EP_INFO_ADDRESS_IP) {\n\t\tmemcpy(&src->info.addr, &addr.sin.sin_addr, 4);\n\t} else {\n\t\tmemcpy(&src->info.addr, &addr.sin6.sin6_addr, 16);\n\t}\nout:\n\tclose(s);\n\treturn ret;\n}\n\n/*\n * Verify the resolve message from the client and return\n * references to the source and destination addresses.\n * The message buffer contains extra address data buffers.  If a\n * source address is not given, reference an empty address buffer,\n * and we'll resolve a source address later.  Record the location of\n * the source and destination addresses in the message header data\n * to avoid further searches.\n */\nstatic uint8_t acm_svr_verify_resolve(struct acm_msg *msg)\n{\n\tint i, cnt, have_dst = 0;\n\n\tif (msg->hdr.length < ACM_MSG_HDR_LENGTH) {\n\t\tacm_log(0, \"ERROR - invalid msg hdr length %d\\n\", msg->hdr.length);\n\t\treturn ACM_STATUS_EINVAL;\n\t}\n\n\tmsg->hdr.src_out = 1;\n\tcnt = (msg->hdr.length - ACM_MSG_HDR_LENGTH) / ACM_MSG_EP_LENGTH;\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (msg->resolve_data[i].flags & ACM_EP_FLAG_SOURCE) {\n\t\t\tif (!msg->hdr.src_out) {\n\t\t\t\tacm_log(0, \"ERROR - multiple sources specified\\n\");\n\t\t\t\treturn ACM_STATUS_ESRCADDR;\n\t\t\t}\n\t\t\tif (!msg->resolve_data[i].type ||\n\t\t\t    (msg->resolve_data[i].type >= ACM_ADDRESS_RESERVED)) {\n\t\t\t\tacm_log(0, \"ERROR - unsupported source address type\\n\");\n\t\t\t\treturn ACM_STATUS_ESRCTYPE;\n\t\t\t}\n\t\t\tmsg->hdr.src_out = 0;\n\t\t\tmsg->hdr.src_index = i;\n\t\t}\n\t\tif (msg->resolve_data[i].flags & ACM_EP_FLAG_DEST) {\n\t\t\tif (have_dst) {\n\t\t\t\tacm_log(0, \"ERROR - multiple destinations specified\\n\");\n\t\t\t\treturn ACM_STATUS_EDESTADDR;\n\t\t\t}\n\t\t\tif (!msg->resolve_data[i].type ||\n\t\t\t    (msg->resolve_data[i].type >= ACM_ADDRESS_RESERVED)) {\n\t\t\t\tacm_log(0, \"ERROR - unsupported destination address type\\n\");\n\t\t\t\treturn ACM_STATUS_EDESTTYPE;\n\t\t\t}\n\t\t\thave_dst = 1;\n\t\t\tmsg->hdr.dst_index = i;\n\t\t}\n\t}\n\n\tif (!have_dst) {\n\t\tacm_log(0, \"ERROR - destination address required\\n\");\n\t\treturn ACM_STATUS_EDESTTYPE;\n\t}\n\n\tif (msg->hdr.src_out) {\n\t\tmsg->hdr.src_index = i;\n\t\tmemset(&msg->resolve_data[i], 0, sizeof(struct acm_ep_addr_data));\n\t}\n\treturn ACM_STATUS_SUCCESS;\n}\n\nstatic int\nacm_svr_resolve_dest(struct acmc_client *client, struct acm_msg *msg)\n{\n\tstruct acmc_addr *addr;\n\tstruct acmc_ep *ep;\n\tstruct acm_ep_addr_data *saddr, *daddr;\n\tuint8_t status;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tstatus = acm_svr_verify_resolve(msg);\n\tif (status) {\n\t\tacm_log(0, \"notice - misformatted or unsupported request\\n\");\n\t\treturn acmc_resolve_response(client->index, msg, status);\n\t}\n\n\tsaddr = &msg->resolve_data[msg->hdr.src_index];\n\tdaddr = &msg->resolve_data[msg->hdr.dst_index];\n\tif (msg->hdr.src_out) {\n\t\tstatus = acm_svr_select_src(saddr, daddr);\n\t\tif (status) {\n\t\t\tacm_log(0, \"notice - unable to select suitable source address\\n\");\n\t\t\treturn acmc_resolve_response(client->index, msg, status);\n\t\t}\n\t}\n\n\tacm_format_name(2, log_data, sizeof log_data,\n\t\t\tsaddr->type, saddr->info.addr, sizeof saddr->info.addr);\n\tacm_log(2, \"src  %s\\n\", log_data);\n\taddr = acm_get_ep_address(saddr);\n\tif (!addr) {\n\t\tacm_log(0, \"notice - unknown local end point address\\n\");\n\t\treturn acmc_resolve_response(client->index, msg, ACM_STATUS_ESRCADDR);\n\t}\n\n\tep = container_of(addr->addr.endpoint, struct acmc_ep, endpoint);\n\treturn ep->port->prov->resolve(addr->prov_addr_context, msg, client->index);\n}\n\n/*\n * The message buffer contains extra address data buffers.  We extract the\n * destination address from the path record into an extra buffer, so we can\n * lookup the destination by either LID or GID.\n */\nstatic int\nacm_svr_resolve_path(struct acmc_client *client, struct acm_msg *msg)\n{\n\tstruct acmc_addr *addr;\n\tstruct acmc_ep *ep;\n\tstruct ibv_path_record *path;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tif (msg->hdr.length < (ACM_MSG_HDR_LENGTH + ACM_MSG_EP_LENGTH)) {\n\t\tacm_log(0, \"notice - invalid msg hdr length %d\\n\", msg->hdr.length);\n\t\treturn acmc_resolve_response(client->index, msg, ACM_STATUS_EINVAL);\n\t}\n\n\tpath = &msg->resolve_data[0].info.path;\n\tif (!path->dlid && ib_any_gid(&path->dgid)) {\n\t\tacm_log(0, \"notice - no destination specified\\n\");\n\t\treturn acmc_resolve_response(client->index, msg,\n\t\t\t\t\t     ACM_STATUS_EDESTADDR);\n\t}\n\n\tacm_format_name(2, log_data, sizeof log_data, ACM_EP_INFO_PATH,\n\t\tmsg->resolve_data[0].info.addr, sizeof *path);\n\tacm_log(2, \"path %s\\n\", log_data);\n\taddr = acm_get_ep_address(&msg->resolve_data[0]);\n\tif (!addr) {\n\t\tacm_log(0, \"notice - unknown local end point address\\n\");\n\t\treturn acmc_resolve_response(client->index, msg,\n\t\t\t\t\t     ACM_STATUS_ESRCADDR);\n\t}\n\n\tep = container_of(addr->addr.endpoint, struct acmc_ep, endpoint);\n\treturn ep->port->prov->resolve(addr->prov_addr_context, msg,\n\t\t\t\t       client->index);\n}\n\nstatic int acm_svr_resolve(struct acmc_client *client, struct acm_msg *msg)\n{\n\t(void) atomic_inc(&client->refcnt);\n\n\tif (msg->resolve_data[0].type == ACM_EP_INFO_PATH) {\n\t\tif (msg->resolve_data[0].flags & ACM_FLAGS_QUERY_SA) {\n\t\t\treturn acm_svr_query_path(client, msg);\n\t\t} else {\n\t\t\treturn acm_svr_resolve_path(client, msg);\n\t\t}\n\t} else {\n\t\treturn acm_svr_resolve_dest(client, msg);\n\t}\n}\n\nstatic int acm_svr_perf_query(struct acmc_client *client, struct acm_msg *msg)\n{\n\tint ret, i;\n\tuint16_t len;\n\tstruct acmc_addr *addr;\n\tstruct acmc_ep *ep = NULL;\n\tint index;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tindex = msg->hdr.src_index;\n\tmsg->hdr.opcode |= ACM_OP_ACK;\n\tmsg->hdr.status = ACM_STATUS_SUCCESS;\n\tmsg->hdr.dst_index = 0;\n\n\tif ((be16toh(msg->hdr.length) < (ACM_MSG_HDR_LENGTH + ACM_MSG_EP_LENGTH)\n\t    && index < 1) ||\n\t    ((be16toh(msg->hdr.length) >= (ACM_MSG_HDR_LENGTH + ACM_MSG_EP_LENGTH)\n\t    && !(msg->resolve_data[0].flags & ACM_EP_FLAG_SOURCE)))) {\n\t\tfor (i = 0; i < ACM_MAX_COUNTER; i++)\n\t\t\tmsg->perf_data[i] = htobe64((uint64_t) atomic_get(&counter[i]));\n\n\t\tmsg->hdr.src_out = ACM_MAX_COUNTER;\n\t\tlen = ACM_MSG_HDR_LENGTH + (ACM_MAX_COUNTER * sizeof(uint64_t));\n\t} else {\n\t\tif (index >= 1) {\n\t\t\tep = acm_get_ep(index - 1, msg->hdr.src_index);\n\t\t} else {\n\t\t\taddr = acm_get_ep_address(&msg->resolve_data[0]);\n\t\t\tif (addr)\n\t\t\t\tep = container_of(addr->addr.endpoint,\n\t\t\t\t\t\t  struct acmc_ep, endpoint);\n\t\t}\n\n\t\tif (ep) {\n\t\t\tep->port->prov->query_perf(ep->prov_ep_context,\n\t\t\t\t\t\t   msg->perf_data, &msg->hdr.src_out);\n\t\t\tlen = ACM_MSG_HDR_LENGTH + (msg->hdr.src_out * sizeof(uint64_t));\n\t\t} else {\n\t\t\tmsg->hdr.status = ACM_STATUS_ESRCADDR;\n\t\t\tlen = ACM_MSG_HDR_LENGTH;\n\t\t}\n\t}\n\tmsg->hdr.length = htobe16(len);\n\n\tret = send(client->sock, (char *) msg, len, 0);\n\tif (ret != len)\n\t\tacm_log(0, \"ERROR - failed to send response\\n\");\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int may_be_realloc(struct acm_msg **msg_ptr,\n\t\t\t  int len,\n\t\t\t  int cnt,\n\t\t\t  int *cur_msg_siz_ptr,\n\t\t\t  int max_msg_siz)\n{\n\n\t/* Check if a new address exceeds the protocol constrained max size */\n\tif (len + (cnt + 1) * ACM_MAX_ADDRESS > max_msg_siz) {\n\t\tacm_log(0, \"ERROR - unable to amend more addresses to acm_msg due to protocol constraints\\n\");\n\t\t\treturn ENOMEM;\n\t}\n\n\t/* Check if a new address exceeds current size of msg */\n\tif (len + (cnt + 1) * ACM_MAX_ADDRESS > *cur_msg_siz_ptr) {\n\t\tconst size_t chunk_size = 16 * ACM_MAX_ADDRESS;\n\t\tstruct acm_msg *new_msg = realloc(*msg_ptr, *cur_msg_siz_ptr + chunk_size);\n\n\t\tif (!new_msg) {\n\t\t\tacm_log(0, \"ERROR - failed to allocate longer acm_msg\\n\");\n\t\t\treturn ENOMEM;\n\t\t}\n\n\t\t*msg_ptr = new_msg;\n\t\t*cur_msg_siz_ptr += chunk_size;\n\t}\n\n\treturn 0;\n}\n\nstatic int acm_svr_ep_query(struct acmc_client *client, struct acm_msg **_msg)\n{\n\tint sts;\n\tint ret, i;\n\tuint16_t len;\n\tstruct acmc_ep *ep;\n\tint index, cnt = 0;\n\tstruct acm_msg *msg = *_msg;\n\tint cur_msg_siz = sizeof(*msg);\n\tint max_msg_siz = USHRT_MAX;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tindex = msg->hdr.src_out;\n\tep = acm_get_ep(index - 1, msg->hdr.src_index);\n\tif (ep) {\n\t\tmsg->hdr.status = ACM_STATUS_SUCCESS;\n\t\tmsg->ep_data[0].dev_guid = ep->port->dev->device.dev_guid;\n\t\tmsg->ep_data[0].port_num = ep->port->port.port_num;\n\t\tmsg->ep_data[0].phys_port_cnt = ep->port->dev->port_cnt;\n\t\tmsg->ep_data[0].pkey = htobe16(ep->endpoint.pkey);\n\t\tstrncpy((char *)msg->ep_data[0].prov_name, ep->port->prov->name,\n\t\t\tACM_MAX_PROV_NAME - 1);\n\t\tmsg->ep_data[0].prov_name[ACM_MAX_PROV_NAME - 1] = '\\0';\n\t\tlen = ACM_MSG_HDR_LENGTH + sizeof(struct acm_ep_config_data);\n\t\tfor (i = 0; i < ep->nmbr_ep_addrs; i++) {\n\t\t\tif (ep->addr_info[i].addr.type != ACM_ADDRESS_INVALID) {\n\t\t\t\tsts = may_be_realloc(_msg, len, cnt, &cur_msg_siz, max_msg_siz);\n\t\t\t\tmsg = *_msg;\n\t\t\t\tif (sts)\n\t\t\t\t\tbreak;\n\t\t\t\tmemcpy(msg->ep_data[0].addrs[cnt++].name,\n\t\t\t\t       ep->addr_info[i].string_buf,\n\t\t\t\t       ACM_MAX_ADDRESS);\n\t\t\t}\n\t\t}\n\t\tmsg->ep_data[0].addr_cnt = htobe16(cnt);\n\t\tlen += cnt * ACM_MAX_ADDRESS;\n\t} else {\n\t\tmsg->hdr.status = ACM_STATUS_EINVAL;\n\t\tlen = ACM_MSG_HDR_LENGTH;\n\t}\n\tmsg->hdr.opcode |= ACM_OP_ACK;\n\tmsg->hdr.src_index = 0;\n\tmsg->hdr.dst_index = 0;\n\tmsg->hdr.length = htobe16(len);\n\n\tret = send(client->sock, (char *) msg, len, 0);\n\tif (ret != len)\n\t\tacm_log(0, \"ERROR - failed to send response\\n\");\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int acm_msg_length(struct acm_msg *msg)\n{\n\treturn (msg->hdr.opcode == ACM_OP_RESOLVE) ?\n\t\tmsg->hdr.length : be16toh(msg->hdr.length);\n}\n\nstatic void acm_svr_receive(struct acmc_client *client)\n{\n\tstruct acm_msg *msg = malloc(sizeof(*msg));\n\tint ret;\n\n\tif (!msg) {\n\t\tacm_log(0, \"ERROR - Unable to alloc acm_msg\\n\");\n\t\tret = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tret = recv(client->sock, (char *)msg, sizeof(*msg), 0);\n\tif (ret <= 0 || ret != acm_msg_length(msg)) {\n\t\tacm_log(2, \"client disconnected\\n\");\n\t\tret = ACM_STATUS_ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tif (msg->hdr.version != ACM_VERSION) {\n\t\tacm_log(0, \"ERROR - unsupported version %d\\n\", msg->hdr.version);\n\t\tgoto out;\n\t}\n\n\tswitch (msg->hdr.opcode & ACM_OP_MASK) {\n\tcase ACM_OP_RESOLVE:\n\t\tatomic_inc(&counter[ACM_CNTR_RESOLVE]);\n\t\tret = acm_svr_resolve(client, msg);\n\t\tbreak;\n\tcase ACM_OP_PERF_QUERY:\n\t\tret = acm_svr_perf_query(client, msg);\n\t\tbreak;\n\tcase ACM_OP_EP_QUERY:\n\t\tret = acm_svr_ep_query(client, &msg);\n\t\tbreak;\n\tdefault:\n\t\tacm_log(0, \"ERROR - unknown opcode 0x%x\\n\", msg->hdr.opcode);\n\t\tbreak;\n\t}\n\nout:\n\tfree(msg);\n\tif (ret)\n\t\tacm_disconnect_client(client);\n}\n\nstatic int acm_nl_to_addr_data(struct acm_ep_addr_data *ad,\n\t\t\t\t  int af_family, uint8_t *addr, size_t addr_len)\n{\n\tif (addr_len > ACM_MAX_ADDRESS)\n\t\treturn EINVAL;\n\n\t/* find the ep associated with this address \"if any\" */\n\tswitch (af_family) {\n\tcase AF_INET:\n\t\tad->type = ACM_ADDRESS_IP;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tad->type = ACM_ADDRESS_IP6;\n\t\tbreak;\n\tdefault:\n\t\treturn EINVAL;\n\t}\n\tmemcpy(&ad->info.addr, addr, addr_len);\n\treturn 0;\n}\n\nstatic void acm_add_ep_ip(char *ifname, struct acm_ep_addr_data *data, char *ip_str)\n{\n\tstruct acmc_ep *ep;\n\tstruct acmc_device *dev;\n\tuint8_t port_num;\n\tuint16_t pkey;\n\tunion ibv_gid sgid;\n\tstruct acmc_addr *addr;\n\n\taddr = acm_get_ep_address(data);\n\tif (addr) {\n\t\tacm_log(1, \"Address '%s' already available\\n\", ip_str);\n\t\treturn;\n\t}\n\n\tif (acm_if_get_sgid(ifname, &sgid))\n\t\treturn;\n\n\tdev = acm_get_device_from_gid(&sgid, &port_num);\n\tif (!dev)\n\t\treturn;\n\n\tif (acm_if_get_pkey(ifname, &pkey))\n\t\treturn;\n\n\tacm_log(0, \" %s\\n\", ip_str);\n\n\tep = acm_find_ep(&dev->port[port_num - 1], pkey);\n\tif (ep) {\n\t\tif (acm_ep_insert_addr(ep, ip_str, data->info.addr,\n\t\t\t\t       data->type))\n\t\t\tacm_log(0, \"Failed to add '%s' to EP\\n\", ip_str);\n\t} else {\n\t\tacm_log(0, \"Failed to add '%s' no EP for pkey\\n\", ip_str);\n\t}\n}\n\nstatic void acm_rm_ep_ip(struct acm_ep_addr_data *data)\n{\n\tstruct acmc_ep *ep;\n\tstruct acmc_addr *addr;\n\n\taddr = acm_get_ep_address(data);\n\tif (addr) {\n\t\tep = container_of(addr->addr.endpoint, struct acmc_ep, endpoint);\n\t\tacm_format_name(0, log_data, sizeof log_data,\n\t\t\t\tdata->type, data->info.addr, sizeof data->info.addr);\n\t\tacm_log(0, \" %s\\n\", log_data);\n\t\tacm_mark_addr_invalid(ep, data);\n\t}\n}\n\nstatic int acm_ipnl_create(void)\n{\n\tstruct sockaddr_nl addr;\n\n\tif ((ip_mon_socket = socket(PF_NETLINK, SOCK_RAW | SOCK_NONBLOCK, NETLINK_ROUTE)) == -1) {\n\t\tacm_log(0, \"Failed to open NETLINK_ROUTE socket\");\n\t\treturn EIO;\n\t}\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.nl_family = AF_NETLINK;\n\taddr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;\n\n\tif (bind(ip_mon_socket, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n\t\tacm_log(0, \"Failed to bind NETLINK_ROUTE socket\");\n\t\treturn EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void acm_ip_iter_cb(char *ifname, union ibv_gid *gid, uint16_t pkey,\n\t\tuint8_t addr_type, uint8_t *addr,\n\t\tchar *ip_str, void *ctx)\n{\n\tint ret = EINVAL;\n\tstruct acmc_device *dev;\n\tstruct acmc_ep *ep;\n\tuint8_t port_num;\n\tchar gid_str[INET6_ADDRSTRLEN];\n\n\tdev = acm_get_device_from_gid(gid, &port_num);\n\tif (dev) {\n\t\tep = acm_find_ep(&dev->port[port_num - 1], pkey);\n\t\tif (ep)\n\t\t\tret = acm_ep_insert_addr(ep, ip_str, addr, addr_type);\n\t}\n\n\tif (ret) {\n\t\tinet_ntop(AF_INET6, gid->raw, gid_str, sizeof(gid_str));\n\t\tacm_log(0, \"Failed to add '%s' (gid %s; pkey 0x%x)\\n\",\n\t\t\tip_str, gid_str, pkey);\n\t}\n}\n\n/* Netlink updates have indicated a failure which means we are no longer in\n * sync.  This should be a rare condition so we handle this with a \"big\n * hammer\" by clearing and re-reading all the system IP's.\n */\nstatic int resync_system_ips(void)\n{\n\tstruct acmc_device *dev;\n\tstruct acmc_port *port;\n\tstruct acmc_ep *ep;\n\tint i, cnt;\n\n\tacm_log(0, \"Resyncing all IP's\\n\");\n\n\t/* mark all IP's invalid */\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (cnt = 0; cnt < dev->port_cnt; cnt++) {\n\t\t\tport = &dev->port[cnt];\n\n\t\t\tlist_for_each(&port->ep_list, ep, entry) {\n\t\t\t\tfor (i = 0; i < ep->nmbr_ep_addrs; i++) {\n\t\t\t\t\tif (ep->addr_info[i].addr.type == ACM_ADDRESS_IP ||\n\t\t\t\t\t    ep->addr_info[i].addr.type == ACM_ADDRESS_IP6)\n\t\t\t\t\t\tep->addr_info[i].addr.type = ACM_ADDRESS_INVALID;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn acm_if_iter_sys(acm_ip_iter_cb, NULL);\n}\n\nstatic void acm_ipnl_handler(void)\n{\n\tint len;\n\tchar buffer[NL_MSG_BUF_SIZE];\n\tstruct nlmsghdr *nlh;\n\tchar ifname[IFNAMSIZ];\n\tchar ip_str[INET6_ADDRSTRLEN];\n\tstruct acm_ep_addr_data ad;\n\n\twhile ((len = recv(ip_mon_socket, buffer, NL_MSG_BUF_SIZE, 0)) > 0) {\n\t\tnlh = (struct nlmsghdr *)buffer;\n\t\twhile ((NLMSG_OK(nlh, len)) && (nlh->nlmsg_type != NLMSG_DONE)) {\n\t\t\tstruct ifaddrmsg *ifa = (struct ifaddrmsg *) NLMSG_DATA(nlh);\n\t\t\tstruct ifinfomsg *ifi = (struct ifinfomsg *) NLMSG_DATA(nlh);\n\t\t\tstruct rtattr *rth = IFA_RTA(ifa);\n\t\t\tint rtl = IFA_PAYLOAD(nlh);\n\n\t\t\tswitch (nlh->nlmsg_type) {\n\t\t\tcase RTM_NEWADDR:\n\t\t\t\tif_indextoname(ifa->ifa_index, ifname);\n\t\t\t\twhile (rtl && RTA_OK(rth, rtl)) {\n\t\t\t\t\tif (rth->rta_type == IFA_LOCAL) {\n\t\t\t\t\t\tacm_log(1, \"New system address available %s : %s\\n\",\n\t\t\t\t\t\t        ifname, inet_ntop(ifa->ifa_family, RTA_DATA(rth),\n\t\t\t\t\t\t\tip_str, sizeof(ip_str)));\n\t\t\t\t\t\tif (!acm_nl_to_addr_data(&ad, ifa->ifa_family,\n\t\t\t\t\t\t\t\t      RTA_DATA(rth),\n\t\t\t\t\t\t\t\t      RTA_PAYLOAD(rth))) {\n\t\t\t\t\t\t\tacm_add_ep_ip(ifname, &ad, ip_str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trth = RTA_NEXT(rth, rtl);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RTM_DELADDR:\n\t\t\t\tif_indextoname(ifa->ifa_index, ifname);\n\t\t\t\twhile (rtl && RTA_OK(rth, rtl)) {\n\t\t\t\t\tif (rth->rta_type == IFA_LOCAL) {\n\t\t\t\t\t\tacm_log(1, \"System address removed %s : %s\\n\",\n\t\t\t\t\t\t        ifname, inet_ntop(ifa->ifa_family, RTA_DATA(rth),\n\t\t\t\t\t\t\tip_str, sizeof(ip_str)));\n\t\t\t\t\t\tif (!acm_nl_to_addr_data(&ad, ifa->ifa_family,\n\t\t\t\t\t\t\t\t      RTA_DATA(rth),\n\t\t\t\t\t\t\t\t      RTA_PAYLOAD(rth))) {\n\t\t\t\t\t\t\tacm_rm_ep_ip(&ad);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trth = RTA_NEXT(rth, rtl);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RTM_NEWLINK:\n\t\t\t\tacm_log(2, \"Link added : %s\\n\",\n\t\t\t\t\tif_indextoname(ifi->ifi_index, ifname));\n\t\t\t\tbreak;\n\t\t\tcase RTM_DELLINK:\n\t\t\t\tacm_log(2, \"Link removed : %s\\n\",\n\t\t\t\t\tif_indextoname(ifi->ifi_index, ifname));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tacm_log(2, \"unknown netlink message\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnlh = NLMSG_NEXT(nlh, len);\n\t\t}\n\t}\n\n\tif (len < 0 && errno == ENOBUFS) {\n\t\tacm_log(0, \"ENOBUFS returned from netlink...\\n\");\n\t\tresync_system_ips();\n\t}\n}\n\nstatic int acm_nl_send(int sock, struct acm_msg *msg)\n{\n\tstruct sockaddr_nl dst_addr;\n\tstruct acm_nl_msg acmnlmsg;\n\tstruct acm_nl_msg *orig;\n\tint ret;\n\tint datalen;\n\n\torig = (struct acm_nl_msg *)(uintptr_t)msg->hdr.tid;\n\n\tmemset(&dst_addr, 0, sizeof(dst_addr));\n\tdst_addr.nl_family = AF_NETLINK;\n\tdst_addr.nl_groups = (1 << (RDMA_NL_GROUP_LS - 1));\n\n\tmemset(&acmnlmsg, 0, sizeof(acmnlmsg));\n\tacmnlmsg.nlmsg_header.nlmsg_len = NLMSG_HDRLEN;\n\tacmnlmsg.nlmsg_header.nlmsg_pid = getpid();\n\tacmnlmsg.nlmsg_header.nlmsg_type = orig->nlmsg_header.nlmsg_type;\n\tacmnlmsg.nlmsg_header.nlmsg_seq = orig->nlmsg_header.nlmsg_seq;\n\n\tif (msg->hdr.status != ACM_STATUS_SUCCESS) {\n\t\tacm_log(2, \"acm status no success = %d\\n\", msg->hdr.status);\n\t\tacmnlmsg.nlmsg_header.nlmsg_flags |= RDMA_NL_LS_F_ERR;\n\t} else {\n\t\tacm_log(2, \"acm status success\\n\");\n\t\tacmnlmsg.nlmsg_header.nlmsg_len +=\n\t\t\tNLA_ALIGN(sizeof(struct acm_nl_path));\n\t\tacmnlmsg.path[0].attr_hdr.nla_type = LS_NLA_TYPE_PATH_RECORD;\n\t\tacmnlmsg.path[0].attr_hdr.nla_len = sizeof(struct acm_nl_path);\n\t\tif (orig->resolve_header.path_use ==\n\t\t    LS_RESOLVE_PATH_USE_UNIDIRECTIONAL)\n\t\t\tacmnlmsg.path[0].rec.flags = IB_PATH_PRIMARY |\n\t\t\t\tIB_PATH_OUTBOUND;\n\t\telse\n\t\t\tacmnlmsg.path[0].rec.flags = IB_PATH_PRIMARY |\n\t\t\t\tIB_PATH_GMP | IB_PATH_BIDIRECTIONAL;\n\t\tmemcpy(acmnlmsg.path[0].rec.path_rec,\n\t\t       &msg->resolve_data[0].info.path,\n\t\t       sizeof(struct ibv_path_record));\n\t}\n\n\tdatalen = NLMSG_ALIGN(acmnlmsg.nlmsg_header.nlmsg_len);\n\tret = sendto(sock, &acmnlmsg, datalen, 0,\n\t\t     (const struct sockaddr *)&dst_addr,\n\t\t     (socklen_t)sizeof(dst_addr));\n\tif (ret != datalen) {\n\t\tacm_log(0, \"ERROR - sendto = %d errno = %d\\n\", ret, errno);\n\t\tret = -1;\n\t} else {\n\t\tret = msg->hdr.length;\n\t}\n\n\tfree(orig);\n\n\treturn ret;\n}\n\n#define NLA_LEN(nla)\t((nla)->nla_len - NLA_HDRLEN)\n#define NLA_DATA(nla)\t((char *)(nla) + NLA_HDRLEN)\n\nstatic int acm_nl_parse_path_attr(struct nlattr *attr,\n\t\t\t\t   struct acm_ep_addr_data *data)\n{\n\tstruct ibv_path_record *path;\n\tuint64_t  *sid;\n\tstruct rdma_nla_ls_gid *gid;\n\tuint8_t *tcl;\n\tuint16_t *pkey;\n\tuint16_t *qos;\n\tuint16_t val;\n\tint ret = 0;\n\n#define IBV_PATH_RECORD_QOS_MASK 0xfff0\n\n\tpath = &data->info.path;\n\tswitch (attr->nla_type & RDMA_NLA_TYPE_MASK) {\n\tcase LS_NLA_TYPE_SERVICE_ID:\n\t\tsid = (uint64_t *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(*sid)) {\n\t\t\tacm_log(2, \"service_id 0x%\" PRIx64 \"\\n\", *sid);\n\t\t\tpath->service_id = htobe64(*sid);\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tcase LS_NLA_TYPE_DGID:\n\t\tgid = (struct rdma_nla_ls_gid *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(gid->gid)) {\n\t\t\tacm_format_name(2, log_data, sizeof(log_data),\n\t\t\t\t\tACM_ADDRESS_GID, gid->gid,\n\t\t\t\t\tsizeof(union ibv_gid));\n\t\t\tacm_log(2, \"path dgid %s\\n\", log_data);\n\t\t\tmemcpy(path->dgid.raw, gid->gid, sizeof(path->dgid));\n\t\t\tdata->flags |= ACM_EP_FLAG_DEST;\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tcase LS_NLA_TYPE_SGID:\n\t\tgid = (struct rdma_nla_ls_gid *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(gid->gid)) {\n\t\t\tacm_format_name(2, log_data, sizeof(log_data),\n\t\t\t\t\tACM_ADDRESS_GID, gid->gid,\n\t\t\t\t\tsizeof(union ibv_gid));\n\t\t\tacm_log(2, \"path sgid %s\\n\", log_data);\n\t\t\tmemcpy(path->sgid.raw, gid->gid, sizeof(path->sgid));\n\t\t\tdata->flags |= ACM_EP_FLAG_SOURCE;\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tcase LS_NLA_TYPE_TCLASS:\n\t\ttcl = (uint8_t *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(*tcl)) {\n\t\t\tacm_log(2, \"tclass 0x%x\\n\", *tcl);\n\t\t\tpath->tclass = *tcl;\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tcase LS_NLA_TYPE_PKEY:\n\t\tpkey = (uint16_t *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(*pkey)) {\n\t\t\tacm_log(2, \"pkey 0x%x\\n\", *pkey);\n\t\t\tpath->pkey = htobe16(*pkey);\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tcase LS_NLA_TYPE_QOS_CLASS:\n\t\tqos = (uint16_t *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(*qos)) {\n\t\t\tacm_log(2, \"qos_class 0x%x\\n\", *qos);\n\t\t\tval = be16toh(path->qosclass_sl);\n\t\t\tval &= ~IBV_PATH_RECORD_QOS_MASK;\n\t\t\tval |= (*qos & IBV_PATH_RECORD_QOS_MASK);\n\t\t\tpath->qosclass_sl = htobe16(val);\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tacm_log(1, \"WARN: unknown attr %x\\n\", attr->nla_type);\n\t\t/* We can not ignore a mandatory attribute */\n\t\tif (attr->nla_type & RDMA_NLA_F_MANDATORY)\n\t\t\tret = -1;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void acm_nl_process_invalid_request(struct acmc_client *client,\n\t\t\t\t\t   struct acm_nl_msg *acmnlmsg)\n{\n\tstruct acm_msg msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.hdr.opcode = ACM_OP_RESOLVE;\n\tmsg.hdr.version = ACM_VERSION;\n\tmsg.hdr.length = ACM_MSG_HDR_LENGTH;\n\tmsg.hdr.status = ACM_STATUS_EINVAL;\n\tmsg.hdr.tid = (uintptr_t) acmnlmsg;\n\n\tacm_nl_send(client->sock, &msg);\n}\n\nstatic void acm_nl_process_resolve(struct acmc_client *client,\n\t\t\t\t   struct acm_nl_msg *acmnlmsg)\n{\n\tstruct acm_msg msg;\n\tstruct nlattr *attr;\n\tint payload_len;\n\tint resolve_hdr_len;\n\tint rem;\n\tint total_attr_len;\n\tint status;\n\tunsigned char *data;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.hdr.opcode = ACM_OP_RESOLVE;\n\tmsg.hdr.version = ACM_VERSION;\n\tmsg.hdr.length = ACM_MSG_HDR_LENGTH + ACM_MSG_EP_LENGTH;\n\tmsg.hdr.status = ACM_STATUS_SUCCESS;\n\tmsg.hdr.tid = (uintptr_t) acmnlmsg;\n\tmsg.resolve_data[0].type = ACM_EP_INFO_PATH;\n\n\t/* We support only one pathrecord */\n\tacm_log(2, \"path use 0x%x\\n\", acmnlmsg->resolve_header.path_use);\n\tif (acmnlmsg->resolve_header.path_use ==\n\t    LS_RESOLVE_PATH_USE_UNIDIRECTIONAL)\n\t\tmsg.resolve_data[0].info.path.reversible_numpath = 1;\n\telse\n\t\tmsg.resolve_data[0].info.path.reversible_numpath =\n\t\t\tIBV_PATH_RECORD_REVERSIBLE | 1;\n\n\tdata = (unsigned char *) &acmnlmsg->nlmsg_header + NLMSG_HDRLEN;\n\tresolve_hdr_len = NLMSG_ALIGN(sizeof(struct rdma_ls_resolve_header));\n\tattr = (struct nlattr *) (data + resolve_hdr_len);\n\tpayload_len = acmnlmsg->nlmsg_header.nlmsg_len - NLMSG_HDRLEN -\n\t\tresolve_hdr_len;\n\trem = payload_len;\n\twhile (1) {\n\t\tif (rem < (int) sizeof(*attr) ||\n\t\t    attr->nla_len < sizeof(*attr) ||\n\t\t    attr->nla_len > rem)\n\t\t\tbreak;\n\n\t\tstatus = acm_nl_parse_path_attr(attr, &msg.resolve_data[0]);\n\t\tif (status) {\n\t\t\tacm_nl_process_invalid_request(client, acmnlmsg);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Next attribute */\n\t\ttotal_attr_len = NLA_ALIGN(attr->nla_len);\n\t\trem -= total_attr_len;\n\t\tattr = (struct nlattr *) ((char *) attr + total_attr_len);\n\t}\n\n\tatomic_inc(&counter[ACM_CNTR_RESOLVE]);\n\tacm_svr_resolve(client, &msg);\n}\n\nstatic int acm_nl_is_valid_resolve_request(struct acm_nl_msg *acmnlmsg)\n{\n\tint payload_len;\n\n\tpayload_len = acmnlmsg->nlmsg_header.nlmsg_len - NLMSG_HDRLEN;\n\tif (payload_len < (sizeof(struct rdma_ls_resolve_header) +\n\t\t\t   sizeof(struct nlattr)))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void acm_nl_receive(struct acmc_client *client)\n{\n\tstruct acm_nl_msg *acmnlmsg;\n\tint datalen = sizeof(*acmnlmsg);\n\tint ret;\n\tuint16_t client_inx, op;\n\n\tacmnlmsg = calloc(1, sizeof(*acmnlmsg));\n\tif (!acmnlmsg) {\n\t\tacm_log(0, \"Out of memory for recving nl msg.\\n\");\n\t\treturn;\n\t}\n\tret = recv(client->sock, acmnlmsg, datalen, 0);\n\tif (!NLMSG_OK(&acmnlmsg->nlmsg_header, ret)) {\n\t\tacm_log(0, \"Netlink receive error: %d.\\n\", ret);\n\t\tgoto rcv_cleanup;\n\t}\n\n\tacm_log(2, \"nlmsg: len %d type 0x%x flags 0x%x seq %d pid %d\\n\",\n\t\tacmnlmsg->nlmsg_header.nlmsg_len,\n\t\tacmnlmsg->nlmsg_header.nlmsg_type,\n\t\tacmnlmsg->nlmsg_header.nlmsg_flags,\n\t\tacmnlmsg->nlmsg_header.nlmsg_seq,\n\t\tacmnlmsg->nlmsg_header.nlmsg_pid);\n\n\t/* Currently we handle only request from the local service client */\n\tclient_inx = RDMA_NL_GET_CLIENT(acmnlmsg->nlmsg_header.nlmsg_type);\n\top = RDMA_NL_GET_OP(acmnlmsg->nlmsg_header.nlmsg_type);\n\tif (client_inx != RDMA_NL_LS) {\n\t\tacm_log_once(0, \"ERROR - Unknown NL client ID (%d)\\n\", client_inx);\n\t\tgoto rcv_cleanup;\n\t}\n\n\tswitch (op) {\n\tcase RDMA_NL_LS_OP_RESOLVE:\n\t\tif (acm_nl_is_valid_resolve_request(acmnlmsg))\n\t\t\tacm_nl_process_resolve(client, acmnlmsg);\n\t\telse\n\t\t\tacm_nl_process_invalid_request(client, acmnlmsg);\n\t\tbreak;\n\tdefault:\n\t\t/* Not supported*/\n\t\tacm_log_once(0, \"WARN - invalid opcode %x\\n\", op);\n\t\tacm_nl_process_invalid_request(client, acmnlmsg);\n\t\tbreak;\n\t}\n\n\treturn;\nrcv_cleanup:\n\tfree(acmnlmsg);\n}\n\nstatic int acm_init_nl(void)\n{\n\tstruct sockaddr_nl src_addr;\n\tint ret;\n\tint nl_rcv_socket;\n\n\tnl_rcv_socket = socket(PF_NETLINK, SOCK_RAW, NETLINK_RDMA);\n\tif (nl_rcv_socket == -1) {\n\t\tacm_log(0, \"ERROR - unable to allocate netlink recv socket\\n\");\n\t\treturn errno;\n\t}\n\n\tmemset(&src_addr, 0, sizeof(src_addr));\n\tsrc_addr.nl_family = AF_NETLINK;\n\tsrc_addr.nl_pid = getpid();\n\tsrc_addr.nl_groups = (1 << (RDMA_NL_GROUP_LS - 1));\n\n\tret = bind(nl_rcv_socket, (struct sockaddr *)&src_addr,\n\t\t   sizeof(src_addr));\n\tif (ret == -1) {\n\t\tacm_log(0, \"ERROR - unable to bind netlink socket\\n\");\n\t\tclose(nl_rcv_socket);\n\t\treturn errno;\n\t}\n\n\t/* init nl client structure */\n\tclient_array[NL_CLIENT_INDEX].sock = nl_rcv_socket;\n\treturn 0;\n}\n\nstatic void acm_server(bool systemd)\n{\n\tfd_set readfds;\n\tint i, n, ret;\n\tstruct acmc_device *dev;\n\n\tacm_log(0, \"started\\n\");\n\tacm_init_server();\n\n\tclient_array[NL_CLIENT_INDEX].sock = -1;\n\tlisten_socket = -1;\n\tif (systemd) {\n\t\tret = acm_listen_systemd();\n\t\tif (ret) {\n\t\t\tacm_log(0, \"ERROR - systemd server listen failed\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (listen_socket == -1) {\n\t\tret = acm_listen();\n\t\tif (ret) {\n\t\t\tacm_log(0, \"ERROR - server listen failed\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (client_array[NL_CLIENT_INDEX].sock == -1) {\n\t\tret = acm_init_nl();\n\t\tif (ret)\n\t\t\tacm_log(1, \"Warn - Netlink init failed\\n\");\n\t}\n\n\tif (systemd)\n\t\tsd_notify(0, \"READY=1\");\n\n\twhile (1) {\n\t\tn = (int) listen_socket;\n\t\tFD_ZERO(&readfds);\n\t\tFD_SET(listen_socket, &readfds);\n\t\tn = max(n, (int) ip_mon_socket);\n\t\tFD_SET(ip_mon_socket, &readfds);\n\n\t\tfor (i = 0; i < FD_SETSIZE - 1; i++) {\n\t\t\tif (client_array[i].sock != -1) {\n\t\t\t\tFD_SET(client_array[i].sock, &readfds);\n\t\t\t\tn = max(n, (int) client_array[i].sock);\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each(&dev_list, dev, entry) {\n\t\t\tFD_SET(dev->device.verbs->async_fd, &readfds);\n\t\t\tn = max(n, (int) dev->device.verbs->async_fd);\n\t\t}\n\n\t\tret = select(n + 1, &readfds, NULL, NULL, NULL);\n\t\tif (ret == -1) {\n\t\t\tacm_log(0, \"ERROR - server select error\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (FD_ISSET(listen_socket, &readfds))\n\t\t\tacm_svr_accept();\n\n\t\tif (FD_ISSET(ip_mon_socket, &readfds))\n\t\t\tacm_ipnl_handler();\n\n\t\tfor (i = 0; i < FD_SETSIZE - 1; i++) {\n\t\t\tif (client_array[i].sock != -1 &&\n\t\t\t\tFD_ISSET(client_array[i].sock, &readfds)) {\n\t\t\t\tacm_log(2, \"receiving from client %d\\n\", i);\n\t\t\t\tif (i == NL_CLIENT_INDEX)\n\t\t\t\t\tacm_nl_receive(&client_array[i]);\n\t\t\t\telse\n\t\t\t\t\tacm_svr_receive(&client_array[i]);\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each(&dev_list, dev, entry) {\n\t\t\tif (FD_ISSET(dev->device.verbs->async_fd, &readfds)) {\n\t\t\t\tacm_log(2, \"handling event from %s\\n\",\n\t\t\t\t\tdev->device.verbs->device->name);\n\t\t\t\tacm_event_handler(dev);\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum ibv_rate acm_get_rate(uint8_t width, uint8_t speed)\n{\n\tswitch (width) {\n\tcase 1: /* 1x */\n\t\tswitch (speed) {\n\t\tcase 1: return IBV_RATE_2_5_GBPS;\n\t\tcase 2: return IBV_RATE_5_GBPS;\n\t\tcase 4: /* fall through */\n\t\tcase 8: return IBV_RATE_10_GBPS;\n\t\tcase 16: return IBV_RATE_14_GBPS;\n\t\tcase 32: return IBV_RATE_25_GBPS;\n\t\tdefault: return IBV_RATE_MAX;\n\t\t}\n\tcase 2: /* 4x */\n\t\tswitch (speed) {\n\t\tcase 1: return IBV_RATE_10_GBPS;\n\t\tcase 2: return IBV_RATE_20_GBPS;\n\t\tcase 4: /* fall through */\n\t\tcase 8: return IBV_RATE_40_GBPS;\n\t\tcase 16: return IBV_RATE_56_GBPS;\n\t\tcase 32: return IBV_RATE_100_GBPS;\n\t\tdefault: return IBV_RATE_MAX;\n\t\t}\n\tcase 4: /* 8x */\n\t\tswitch (speed) {\n\t\tcase 1: return IBV_RATE_20_GBPS;\n\t\tcase 2: return IBV_RATE_40_GBPS;\n\t\tcase 4: /* fall through */\n\t\tcase 8: return IBV_RATE_80_GBPS;\n\t\tcase 16: return IBV_RATE_112_GBPS;\n\t\tcase 32: return IBV_RATE_200_GBPS;\n\t\tdefault: return IBV_RATE_MAX;\n\t\t}\n\tcase 8: /* 12x */\n\t\tswitch (speed) {\n\t\tcase 1: return IBV_RATE_30_GBPS;\n\t\tcase 2: return IBV_RATE_60_GBPS;\n\t\tcase 4: /* fall through */\n\t\tcase 8: return IBV_RATE_120_GBPS;\n\t\tcase 16: return IBV_RATE_168_GBPS;\n\t\tcase 32: return IBV_RATE_300_GBPS;\n\t\tdefault: return IBV_RATE_MAX;\n\t\t}\n\tdefault:\n\t\tacm_log(0, \"ERROR - unknown link width 0x%x\\n\", width);\n\t\treturn IBV_RATE_MAX;\n\t}\n}\n\nenum ibv_mtu acm_convert_mtu(int mtu)\n{\n\tswitch (mtu) {\n\tcase 256:  return IBV_MTU_256;\n\tcase 512:  return IBV_MTU_512;\n\tcase 1024: return IBV_MTU_1024;\n\tcase 2048: return IBV_MTU_2048;\n\tcase 4096: return IBV_MTU_4096;\n\tdefault:   return IBV_MTU_2048;\n\t}\n}\n\nenum ibv_rate acm_convert_rate(int rate)\n{\n\tswitch (rate) {\n\tcase 2:   return IBV_RATE_2_5_GBPS;\n\tcase 5:   return IBV_RATE_5_GBPS;\n\tcase 10:  return IBV_RATE_10_GBPS;\n\tcase 20:  return IBV_RATE_20_GBPS;\n\tcase 30:  return IBV_RATE_30_GBPS;\n\tcase 40:  return IBV_RATE_40_GBPS;\n\tcase 60:  return IBV_RATE_60_GBPS;\n\tcase 80:  return IBV_RATE_80_GBPS;\n\tcase 120: return IBV_RATE_120_GBPS;\n\tcase 14:  return IBV_RATE_14_GBPS;\n\tcase 56:  return IBV_RATE_56_GBPS;\n\tcase 112: return IBV_RATE_112_GBPS;\n\tcase 168: return IBV_RATE_168_GBPS;\n\tcase 25:  return IBV_RATE_25_GBPS;\n\tcase 100: return IBV_RATE_100_GBPS;\n\tcase 200: return IBV_RATE_200_GBPS;\n\tcase 300: return IBV_RATE_300_GBPS;\n\tdefault:  return IBV_RATE_10_GBPS;\n\t}\n}\n\nstatic FILE *acm_open_addr_file(void)\n{\n\tFILE *f;\n\n\tif ((f = fopen(addr_file, \"r\")))\n\t\treturn f;\n\n\tacm_log(0, \"notice - generating %s file\\n\", addr_file);\n\tif (!(f = popen(acme, \"r\"))) {\n\t\tacm_log(0, \"ERROR - cannot generate %s\\n\", addr_file);\n\t\treturn NULL;\n\t}\n\tpclose(f);\n\treturn fopen(addr_file, \"r\");\n}\n\nstatic int\n__acm_ep_insert_addr(struct acmc_ep *ep, const char *name, uint8_t *addr,\n\t\t   uint8_t addr_type)\n{\n\tint i;\n\tint ret;\n\tuint8_t tmp[ACM_MAX_ADDRESS] = {};\n\n\tmemcpy(tmp, addr, acm_addr_len(addr_type));\n\n\tfor (i = 0; (i < ep->nmbr_ep_addrs) &&\n\t\t     (ep->addr_info[i].addr.type != ACM_ADDRESS_INVALID); i++)\n\t\t;\n\tif (i == ep->nmbr_ep_addrs) {\n\t\tstruct acmc_addr *new_info;\n\t\tint j;\n\n\t\tnew_info = realloc(ep->addr_info, (i + 1) * sizeof(*ep->addr_info));\n\t\tif (!new_info) {\n\t\t\tret = ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* id_string needs to point to the reallocated string_buf */\n\t\tfor (j = 0; (j < ep->nmbr_ep_addrs); j++) {\n\t\t\tnew_info[j].addr.id_string = new_info[j].string_buf;\n\t\t}\n\n\t\tep->addr_info = new_info;\n\n\t\t/* Added memory is not initialized */\n\t\tmemset(ep->addr_info + i, 0, sizeof(*ep->addr_info));\n\t\tep->addr_info[i].addr.endpoint = &ep->endpoint;\n\t\tep->addr_info[i].addr.id_string = ep->addr_info[i].string_buf;\n\t\t++ep->nmbr_ep_addrs;\n\t}\n\n\t/* Open the provider endpoint only if at least a name or\n\t   address is found */\n\tif (!ep->prov_ep_context) {\n\t\tret = ep->port->prov->open_endpoint(&ep->endpoint,\n\t\t\t\t\t\t    ep->port->prov_port_context,\n\t\t\t\t\t\t    &ep->prov_ep_context);\n\t\tif (ret) {\n\t\t\tacm_log(0, \"Error: failed to open prov ep\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\tep->addr_info[i].addr.type = addr_type;\n\tif (!check_snprintf(ep->addr_info[i].string_buf,\n\t\t\t    sizeof(ep->addr_info[i].string_buf), \"%s\", name))\n\t\treturn EINVAL;\n\tmemcpy(ep->addr_info[i].addr.info.addr, tmp, ACM_MAX_ADDRESS);\n\tret = ep->port->prov->add_address(&ep->addr_info[i].addr,\n\t\t\t\t\t  ep->prov_ep_context,\n\t\t\t\t\t  &ep->addr_info[i].prov_addr_context);\n\tif (ret) {\n\t\tacm_log(0, \"Error: failed to add addr to provider\\n\");\n\t\tep->addr_info[i].addr.type = ACM_ADDRESS_INVALID;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int\nacm_ep_insert_addr(struct acmc_ep *ep, const char *name, uint8_t *addr,\n\t\t   uint8_t addr_type)\n{\n\tint ret = -1;\n\n\tif (!acm_addr_lookup(&ep->endpoint, addr, addr_type)) {\n\t\tret = __acm_ep_insert_addr(ep, name, addr, addr_type);\n\t}\n\n\treturn ret;\n}\n\nstatic struct acmc_device *\nacm_get_device_from_gid(union ibv_gid *sgid, uint8_t *port)\n{\n\tstruct acmc_device *dev;\n\tint i;\n\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (*port = 1; *port <= dev->port_cnt; (*port)++) {\n\n\t\t\tfor (i = 0; i < dev->port[*port - 1].gid_cnt; i++) {\n\n\t\t\t\tif (!memcmp(sgid->raw,\n\t\t\t\t\t    dev->port[*port - 1].gid_tbl[i].raw,\n\t\t\t\t\t    sizeof(*sgid)))\n\t\t\t\t\treturn dev;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void acm_ep_ip_iter_cb(char *ifname, union ibv_gid *gid, uint16_t pkey,\n\t\tuint8_t addr_type, uint8_t *addr,\n\t\tchar *ip_str, void *ctx)\n{\n\tuint8_t port_num;\n\tstruct acmc_device *dev;\n\tstruct acmc_ep *ep = ctx;\n\n\tdev = acm_get_device_from_gid(gid, &port_num);\n\tif (dev && ep->port->dev == dev\n\t    && ep->port->port.port_num == port_num &&\n\t\t/* pkey retrieved from ipoib has always full mmbr bit set */\n\t\t(ep->endpoint.pkey | IB_PKEY_FULL_MEMBER) == pkey) {\n\t\tif (!acm_ep_insert_addr(ep, ip_str, addr, addr_type)) {\n\t\t\tacm_log(0, \"Added %s %s %d 0x%x from %s\\n\", ip_str,\n\t\t\t\tdev->device.verbs->device->name, port_num, ep->endpoint.pkey,\n\t\t\t\tifname);\n\t\t}\n\t}\n}\n\nstatic int acm_get_system_ips(struct acmc_ep *ep)\n{\n\treturn acm_if_iter_sys(acm_ep_ip_iter_cb, ep);\n}\n\nstatic int acm_assign_ep_names(struct acmc_ep *ep)\n{\n\tFILE *faddr;\n\tchar *dev_name;\n\tchar s[120];\n\tchar dev[32], name[ACM_MAX_ADDRESS], pkey_str[8];\n\tuint16_t pkey;\n\tuint8_t addr[ACM_MAX_ADDRESS], type;\n\tint port;\n\n\tdev_name = ep->port->dev->device.verbs->device->name;\n\tacm_log(1, \"device %s, port %d, pkey 0x%x\\n\",\n\t\tdev_name, ep->port->port.port_num, ep->endpoint.pkey);\n\n\tacm_get_system_ips(ep);\n\n\tif (!(faddr = acm_open_addr_file())) {\n\t\tacm_log(0, \"ERROR - address file not found\\n\");\n\t\tgoto out;\n\t}\n\n\twhile (fgets(s, sizeof s, faddr)) {\n\t\tif (s[0] == '#')\n\t\t\tcontinue;\n\n\t\tif (sscanf(s, \"%46s%31s%d%7s\", name, dev, &port, pkey_str) != 4)\n\t\t\tcontinue;\n\n\t\tacm_log(2, \"%s\", s);\n\t\tif (inet_pton(AF_INET, name, addr) > 0) {\n\t\t\tif (!support_ips_in_addr_cfg) {\n\t\t\t\tacm_log(0, \"ERROR - IP's are not configured to be read from ibacm_addr.cfg\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttype = ACM_ADDRESS_IP;\n\t\t} else if (inet_pton(AF_INET6, name, addr) > 0) {\n\t\t\tif (!support_ips_in_addr_cfg) {\n\t\t\t\tacm_log(0, \"ERROR - IP's are not configured to be read from ibacm_addr.cfg\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttype = ACM_ADDRESS_IP6;\n\t\t} else {\n\t\t\ttype = ACM_ADDRESS_NAME;\n\t\t\tstrncpy((char *)addr, name, sizeof(addr));\n\t\t}\n\n\t\tif (strcasecmp(pkey_str, \"default\")) {\n\t\t\tif (sscanf(pkey_str, \"%hx\", &pkey) != 1) {\n\t\t\t\tacm_log(0, \"ERROR - bad pkey format %s\\n\", pkey_str);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tpkey = ep->port->def_acm_pkey;\n\t\t}\n\n\t\tif (!strcasecmp(dev_name, dev) &&\n\t\t    (ep->port->port.port_num == (uint8_t) port) &&\n\t\t    acm_same_partition(ep->endpoint.pkey, pkey)) {\n\t\t\tacm_log(1, \"assigning %s\\n\", name);\n\t\t\tif (acm_ep_insert_addr(ep, name, addr, type)) {\n\t\t\t\tacm_log(1, \"maximum number of names assigned to EP\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(faddr);\n\nout:\n\treturn (!ep->nmbr_ep_addrs || ep->addr_info[0].addr.type == ACM_ADDRESS_INVALID);\n}\n\nstatic struct acmc_ep *acm_find_ep(struct acmc_port *port, uint16_t pkey)\n{\n\tstruct acmc_ep *ep, *res = NULL;\n\n\tacm_log(2, \"pkey 0x%x\\n\", pkey);\n\n\tlist_for_each(&port->ep_list, ep, entry) {\n\t\tif (acm_same_partition(ep->endpoint.pkey, pkey)) {\n\t\t\tres = ep;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic void acm_ep_down(struct acmc_ep *ep)\n{\n\tint i;\n\n\tacm_log(1, \"%s %d pkey 0x%04x\\n\",\n\t\tep->port->dev->device.verbs->device->name,\n\t\tep->port->port.port_num, ep->endpoint.pkey);\n\n\tfor (i = 0; i < ep->nmbr_ep_addrs; i++) {\n\t\tif (ep->addr_info[i].addr.type &&\n\t\t    ep->addr_info[i].prov_addr_context)\n\t\t\tep->port->prov->remove_address(ep->addr_info[i].\n\t\t\t\t\t\t       prov_addr_context);\n\t}\n\n\tif (ep->prov_ep_context)\n\t\tep->port->prov->close_endpoint(ep->prov_ep_context);\n\n\tfree(ep);\n}\n\nstatic struct acmc_ep *\nacm_alloc_ep(struct acmc_port *port, uint16_t pkey)\n{\n\tstruct acmc_ep *ep;\n\n\tacm_log(1, \"\\n\");\n\tep = calloc(1, sizeof *ep);\n\tif (!ep)\n\t\treturn NULL;\n\n\tep->port = port;\n\tep->endpoint.port = &port->port;\n\tep->endpoint.pkey = pkey;\n\tep->addr_info = NULL;\n\tep->nmbr_ep_addrs = 0;\n\n\treturn ep;\n}\n\nstatic void acm_ep_up(struct acmc_port *port, uint16_t pkey)\n{\n\tstruct acmc_ep *ep;\n\tint ret;\n\n\tacm_log(1, \"\\n\");\n\tif (acm_find_ep(port, pkey)) {\n\t\tacm_log(2, \"endpoint for pkey 0x%x already exists\\n\", pkey);\n\t\treturn;\n\t}\n\n\tacm_log(2, \"creating endpoint for pkey 0x%x\\n\", pkey);\n\tep = acm_alloc_ep(port, pkey);\n\tif (!ep)\n\t\treturn;\n\n\tret = acm_assign_ep_names(ep);\n\tif (ret) {\n\t\tacm_log(1, \"unable to assign EP name for pkey 0x%x\\n\", pkey);\n\t\tgoto ep_close;\n\t}\n\n\tlist_add(&port->ep_list, &ep->entry);\n\treturn;\n\nep_close:\n\tif (ep->prov_ep_context)\n\t\tport->prov->close_endpoint(ep->prov_ep_context);\n\n\tfree(ep);\n}\n\nstatic void acm_assign_provider(struct acmc_port *port)\n{\n\tstruct acmc_prov *prov;\n\tstruct acmc_subnet *subnet;\n\n\tacm_log(2, \"port %s/%d\\n\", port->port.dev->verbs->device->name,\n\t\tport->port.port_num);\n\tlist_for_each(&provider_list, prov, entry) {\n\t\tlist_for_each(&prov->subnet_list, subnet, entry) {\n\t\t\tif (subnet->subnet_prefix ==\n\t\t\t    port->gid_tbl[0].global.subnet_prefix) {\n\t\t\t\tacm_log(2, \"Found provider %s for port %s/%d\\n\",\n\t\t\t\t\tprov->prov->name,\n\t\t\t\t\tport->port.dev->verbs->device->name,\n\t\t\t\t\tport->port.port_num);\n\t\t\t\tport->prov = prov->prov;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If no provider is found, assign the default provider*/\n\tif (!port->prov) {\n\t\tacm_log(2, \"No prov found, assign default prov %s to %s/%d\\n\",\n\t\t\tdef_provider ? def_provider->prov->name: \"NULL\",\n\t\t\tport->port.dev->verbs->device->name,\n\t\t\tport->port.port_num);\n\t\tport->prov = def_provider ? def_provider->prov : NULL;\n\t}\n}\n\nstatic void acm_port_get_gid_tbl(struct acmc_port *port)\n{\n\tunion ibv_gid gid;\n\tint i, j, ret;\n\n\tfor (i = 0;; i++) {\n\t\tret = ibv_query_gid(port->port.dev->verbs, port->port.port_num,\n\t\t\t\t    i, &gid);\n\t\tif (ret || !gid.global.interface_id)\n\t\t\tbreak;\n\t}\n\n\tif (i > 0) {\n\t\tport->gid_tbl = calloc(i, sizeof(union ibv_gid));\n\t\tif (!port->gid_tbl) {\n\t\t\tacm_log(0, \"Error: failed to allocate gid table\\n\");\n\t\t\tport->gid_cnt = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tret = ibv_query_gid(port->port.dev->verbs,\n\t\t\t\t\t    port->port.port_num, j,\n\t\t\t\t\t    &port->gid_tbl[j]);\n\t\t\tif (ret || !port->gid_tbl[j].global.interface_id)\n\t\t\t\tbreak;\n\t\t\tacm_log(2, \"guid %d: 0x%\" PRIx64 \" %\" PRIx64 \"\\n\", j,\n\t\t\t\tbe64toh(port->gid_tbl[j].global.subnet_prefix),\n\t\t\t\tbe64toh(port->gid_tbl[j].global.interface_id));\n\t\t}\n\t\tport->gid_cnt = j;\n\t}\n\tacm_log(2, \"port %d gid_cnt %d\\n\", port->port.port_num,\n\t\tport->gid_cnt);\n}\n\nstatic void acm_port_up(struct acmc_port *port)\n{\n\tstruct ibv_port_attr attr;\n\tuint16_t pkey;\n\t__be16 pkey_be;\n\tint i, ret;\n\tstruct acmc_prov_context *dev_ctx;\n\tint index = -1;\n\tuint16_t first_pkey = 0;\n\n\tacm_log(1, \"%s %d\\n\", port->dev->device.verbs->device->name,\n\t\tport->port.port_num);\n\tret = ibv_query_port(port->dev->device.verbs, port->port.port_num,\n\t\t\t     &attr);\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - unable to get port state\\n\");\n\t\treturn;\n\t}\n\tif (attr.state != IBV_PORT_ACTIVE) {\n\t\tacm_log(1, \"port not active\\n\");\n\t\treturn;\n\t}\n\n\tacm_port_get_gid_tbl(port);\n\tport->lid = attr.lid;\n\tport->lid_mask = 0xffff - ((1 << attr.lmc) - 1);\n\tport->sa_addr.lid = htobe16(attr.sm_lid);\n\tport->sa_addr.sl = attr.sm_sl;\n\tport->state = IBV_PORT_ACTIVE;\n\tacm_assign_provider(port);\n\tif (!port->prov) {\n\t\tacm_log(1, \"no provider assigned to port\\n\");\n\t\treturn;\n\t}\n\tdev_ctx = acm_acquire_prov_context(&port->dev->prov_dev_context_list,\n\t\t\t\t\t   port->prov);\n\tif (!dev_ctx) {\n\t\tacm_log(0, \"Error -- failed to acquire dev context\\n\");\n\t\treturn;\n\t}\n\n\tif (atomic_get(&dev_ctx->refcnt) == 1) {\n\t\tif (port->prov->open_device(&port->dev->device, &dev_ctx->context)) {\n\t\t\tacm_log(0, \"Error -- failed to open the prov device\\n\");\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\tif (port->prov->open_port(&port->port, dev_ctx->context,\n\t\t\t\t  &port->prov_port_context)) {\n\t\tacm_log(0, \"Error -- failed to open the prov port\\n\");\n\t\tgoto err1;\n\t}\n\n\t/* Determine the default pkey for SA access first.\n\t *     Order of preference: 0xffff, 0x7fff\n\t * Use the first pkey as the default pkey for parsing address file.\n\t */\n\tfor (i = 0; i < attr.pkey_tbl_len; i++) {\n\t\tret = ibv_query_pkey(port->dev->device.verbs,\n\t\t\t\t     port->port.port_num, i, &pkey_be);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tpkey = be16toh(pkey_be);\n\t\tif (i == 0)\n\t\t\tfirst_pkey = pkey;\n\t\tif (pkey == 0xffff) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t\telse if (pkey == 0x7fff) {\n\t\t\tindex = i;\n\t\t}\n\t}\n\tport->sa_pkey_index = index < 0 ? 0 : index;\n\tport->def_acm_pkey = first_pkey;\n\n\tfor (i = 0; i < attr.pkey_tbl_len; i++) {\n\t\tret = ibv_query_pkey(port->dev->device.verbs,\n\t\t\t\t     port->port.port_num, i, &pkey_be);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tpkey = be16toh(pkey_be);\n\t\tif (!(pkey & 0x7fff))\n\t\t\tcontinue;\n\n\t\tacm_ep_up(port, pkey);\n\t}\n\treturn;\nerr1:\n\tacm_release_prov_context(dev_ctx);\n}\n\nstatic void acm_shutdown_port(struct acmc_port *port)\n{\n\tstruct acmc_ep *ep;\n\tstruct acmc_prov_context *dev_ctx;\n\n\twhile ((ep = list_pop(&port->ep_list, struct acmc_ep, entry)))\n\t\tacm_ep_down(ep);\n\n\tif (port->prov_port_context) {\n\t\tport->prov->close_port(port->prov_port_context);\n\t\tport->prov_port_context = NULL;\n\t\tdev_ctx = acm_get_prov_context(&port->dev->prov_dev_context_list,\n\t\t\t\t\t       port->prov);\n\t\tif (dev_ctx) {\n\t\t\tif (atomic_get(&dev_ctx->refcnt) == 1)\n\t\t\t\tport->prov->close_device(dev_ctx->context);\n\t\t\tacm_release_prov_context(dev_ctx);\n\t\t}\n\t}\n\tport->prov = NULL;\n\tif (port->gid_tbl) {\n\t\tfree(port->gid_tbl);\n\t\tport->gid_tbl = NULL;\n\t}\n\tport->gid_cnt = 0;\n}\n\nstatic void acm_port_down(struct acmc_port *port)\n{\n\tstruct ibv_port_attr attr;\n\tint ret;\n\n\tacm_log(1, \"%s %d\\n\", port->port.dev->verbs->device->name, port->port.port_num);\n\tret = ibv_query_port(port->port.dev->verbs, port->port.port_num, &attr);\n\tif (!ret && attr.state == IBV_PORT_ACTIVE) {\n\t\tacm_log(1, \"port active\\n\");\n\t\treturn;\n\t}\n\n\tport->state = attr.state;\n\tacm_shutdown_port(port);\n\n\tacm_log(1, \"%s %d is down\\n\", port->dev->device.verbs->device->name,\n\t\tport->port.port_num);\n}\n\nstatic void acm_port_change(struct acmc_port *port)\n{\n\tstruct ibv_port_attr attr;\n\tint ret;\n\n\tacm_log(1, \"%s %d\\n\", port->port.dev->verbs->device->name, port->port.port_num);\n\tret = ibv_query_port(port->port.dev->verbs, port->port.port_num, &attr);\n\tif (ret || attr.state != IBV_PORT_ACTIVE) {\n\t\tacm_log(1, \"port not active: don't care\\n\");\n\t\treturn;\n\t}\n\n\tport->state = attr.state;\n\tacm_shutdown_port(port);\n\tacm_port_up(port);\n}\n\nstatic void acm_event_handler(struct acmc_device *dev)\n{\n\tstruct ibv_async_event event;\n\tint i, ret;\n\n\tret = ibv_get_async_event(dev->device.verbs, &event);\n\tif (ret)\n\t\treturn;\n\n\tacm_log(2, \"processing async event %s for %s\\n\",\n\t\tibv_event_type_str(event.event_type),\n\t\tdev->device.verbs->device->name);\n\ti = event.element.port_num - 1;\n\n\tswitch (event.event_type) {\n\tcase IBV_EVENT_PORT_ACTIVE:\n\t\tif (dev->port[i].state != IBV_PORT_ACTIVE)\n\t\t\tacm_port_up(&dev->port[i]);\n\t\tif (dev->port[i].pending_rereg && dev->port[i].prov_port_context) {\n\t\t\tdev->port[i].prov->handle_event(dev->port[i].prov_port_context,\n\t\t\t\t\t\t\tIBV_EVENT_CLIENT_REREGISTER);\n\t\t\tdev->port[i].pending_rereg = false;\n\t\t\tacm_log(1, \"%s %d delayed reregistration\\n\",\n\t\t\t\tdev->device.verbs->device->name, i + 1);\n\t\t}\n\n\t\tbreak;\n\tcase IBV_EVENT_PORT_ERR:\n\t\tif (dev->port[i].state == IBV_PORT_ACTIVE)\n\t\t\tacm_port_down(&dev->port[i]);\n\t\tbreak;\n\tcase IBV_EVENT_CLIENT_REREGISTER:\n\t\tif ((dev->port[i].state == IBV_PORT_ACTIVE) &&\n\t\t    dev->port[i].prov_port_context) {\n\t\t\tdev->port[i].prov->handle_event(dev->port[i].prov_port_context,\n\t\t\t\t\t\t\tevent.event_type);\n\t\t\tacm_log(1, \"%s %d has reregistered\\n\",\n\t\t\t\tdev->device.verbs->device->name, i + 1);\n\t\t} else {\n\t\t\tacm_log(2, \"%s %d rereg on inactive port, postpone handling\\n\",\n\t\t\t\tdev->device.verbs->device->name, i + 1);\n\t\t\tdev->port[i].pending_rereg = true;\n\t\t}\n\n\t\tbreak;\n\tcase IBV_EVENT_LID_CHANGE:\n\tcase IBV_EVENT_GID_CHANGE:\n\tcase IBV_EVENT_PKEY_CHANGE:\n\t\tacm_port_change(&dev->port[i]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tibv_ack_async_event(&event);\n}\n\nstatic void acm_activate_devices(void)\n{\n\tstruct acmc_device *dev;\n\tint i;\n\n\tacm_log(1, \"\\n\");\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (i = 0; i < dev->port_cnt; i++) {\n\t\t\tacm_port_up(&dev->port[i]);\n\t\t}\n\t}\n}\n\nstatic void\nacm_open_port(struct acmc_port *port, struct acmc_device *dev, uint8_t port_num)\n{\n\tacm_log(1, \"%s %d\\n\", dev->device.verbs->device->name, port_num);\n\tport->dev = dev;\n\tport->port.dev = &dev->device;\n\tport->port.port_num = port_num;\n\tpthread_mutex_init(&port->lock, NULL);\n\tlist_head_init(&port->ep_list);\n\tlist_head_init(&port->sa_pending);\n\tlist_head_init(&port->sa_wait);\n\tport->sa_credits = sa.depth;\n\tport->sa_addr.qpn = htobe32(1);\n\tport->sa_addr.qkey = htobe32(ACM_QKEY);\n\n\tport->mad_portid = umad_open_port(dev->device.verbs->device->name, port_num);\n\tif (port->mad_portid < 0)\n\t\tacm_log(0, \"ERROR - unable to open MAD port\\n\");\n\n\tport->mad_agentid = umad_register(port->mad_portid,\n\t\t\t\t\t  IB_MGMT_CLASS_SA, 1, 1, NULL);\n\tif (port->mad_agentid < 0) {\n\t\tumad_close_port(port->mad_portid);\n\t\tacm_log(0, \"ERROR - unable to register MAD client\\n\");\n\t}\n\n\tport->prov = NULL;\n\tport->state = IBV_PORT_DOWN;\n}\n\nstatic void acm_open_dev(struct ibv_device *ibdev)\n{\n\tstruct acmc_device *dev;\n\tstruct ibv_device_attr attr;\n\tstruct ibv_port_attr port_attr;\n\tstruct ibv_context *verbs;\n\tsize_t size;\n\tint i, ret;\n\tbool has_ib_port = false;\n\n\tacm_log(1, \"%s\\n\", ibdev->name);\n\tverbs = ibv_open_device(ibdev);\n\tif (verbs == NULL) {\n\t\tacm_log(0, \"ERROR - opening device %s\\n\", ibdev->name);\n\t\treturn;\n\t}\n\n\tret = ibv_query_device(verbs, &attr);\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - ibv_query_device (%d) %s\\n\", ret, ibdev->name);\n\t\tgoto err1;\n\t}\n\n\tfor (i = 0; i < attr.phys_port_cnt; i++) {\n\t\tret = ibv_query_port(verbs, i + 1, &port_attr);\n\t\tif (ret) {\n\t\t\tacm_log(0, \"ERROR - ibv_query_port (%s, %d) return (%d)\\n\",\n\t\t\t\tibdev->name, i + 1, ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (port_attr.link_layer == IBV_LINK_LAYER_INFINIBAND) {\n\t\t\tacm_log(1, \"%s port %d is an InfiniBand port\\n\", ibdev->name, i + 1);\n\t\t\thas_ib_port = true;\n\t\t} else {\n\t\t\tacm_log(1, \"%s port %d is not an InfiniBand port\\n\", ibdev->name, i + 1);\n\t\t}\n\t}\n\n\tif (!has_ib_port) {\n\t\tacm_log(1, \"%s does not support InfiniBand.\\n\", ibdev->name);\n\t\tgoto err1;\n\t}\n\n\tsize = sizeof(*dev) + sizeof(struct acmc_port) * attr.phys_port_cnt;\n\tdev = (struct acmc_device *) calloc(1, size);\n\tif (!dev)\n\t\tgoto err1;\n\n\tdev->device.verbs = verbs;\n\tdev->device.dev_guid = ibv_get_device_guid(ibdev);\n\tdev->port_cnt = attr.phys_port_cnt;\n\tlist_head_init(&dev->prov_dev_context_list);\n\n\tfor (i = 0; i < dev->port_cnt; i++) {\n\t\tacm_open_port(&dev->port[i], dev, i + 1);\n\t}\n\n\tlist_add(&dev_list, &dev->entry);\n\n\tacm_log(1, \"%s opened\\n\", ibdev->name);\n\treturn;\n\nerr1:\n\tibv_close_device(verbs);\n}\n\nstatic int acm_open_devices(void)\n{\n\tstruct ibv_device **ibdev;\n\tint dev_cnt;\n\tint i;\n\n\tacm_log(1, \"\\n\");\n\tibdev = ibv_get_device_list(&dev_cnt);\n\tif (!ibdev) {\n\t\tacm_log(0, \"ERROR - unable to get device list\\n\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < dev_cnt; i++)\n\t\tacm_open_dev(ibdev[i]);\n\n\tibv_free_device_list(ibdev);\n\tif (list_empty(&dev_list)) {\n\t\tacm_log(0, \"ERROR - no devices\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void acm_load_prov_config(void)\n{\n\tFILE *fd;\n\tchar s[128];\n\tchar *p, *ptr;\n\tchar prov_name[ACM_PROV_NAME_SIZE];\n\tuint64_t prefix;\n\tstruct acmc_prov *prov;\n\tstruct acmc_subnet *subnet;\n\n\tif (!(fd = fopen(opts_file, \"r\")))\n\t\treturn;\n\n\twhile (fgets(s, sizeof s, fd)) {\n\t\tif (s[0] == '#')\n\t\t\tcontinue;\n\n\t\t/* Ignore blank lines */\n\t\tif (!(p = strtok_r(s, \" \\n\", &ptr)))\n\t\t\tcontinue;\n\n\t\tif (strncasecmp(p, \"provider\", sizeof(\"provider\") - 1))\n\t\t\tcontinue;\n\n\t\tp = strtok_r(NULL, \" \", &ptr);\n\t\tif (!p)\n\t\t\tcontinue;\n\n\t\tstrncpy(prov_name, p, sizeof(prov_name));\n\t\tprov_name[sizeof(prov_name) -1] = '\\0';\n\n\t\tp = strtok_r(NULL, \" \", &ptr);\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tif (!strncasecmp(p, \"default\", sizeof(\"default\") - 1)) {\n\t\t\tstrncpy(def_prov_name, prov_name, sizeof(def_prov_name));\n\t\t\tdef_prov_name[sizeof(def_prov_name) -1] = '\\0';\n\t\t\tacm_log(2, \"default provider: %s\\n\", def_prov_name);\n\t\t\tcontinue;\n\t\t}\n\t\tprefix = strtoull(p, NULL, 0);\n\t\tacm_log(2, \"provider %s subnet_prefix 0x%\" PRIx64 \"\\n\",\n\t\t\tprov_name, prefix);\n\n\t\tlist_for_each(&provider_list, prov, entry) {\n\t\t\tif (!strcasecmp(prov->prov->name, prov_name)) {\n\t\t\t\tsubnet = calloc(1, sizeof (*subnet));\n\t\t\t\tif (!subnet) {\n\t\t\t\t\tacm_log(0, \"Error: out of memory\\n\");\n\t\t\t\t\tfclose(fd);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsubnet->subnet_prefix = htobe64(prefix);\n\t\t\t\tlist_add_tail(&prov->subnet_list,\n\t\t\t\t\t      &subnet->entry);\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fd);\n\n\tlist_for_each(&provider_list, prov, entry) {\n\t\tif (!strcasecmp(prov->prov->name, def_prov_name)) {\n\t\t\tdef_provider = prov;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int acm_string_end_compare(const char *s1, const char *s2)\n{\n\tsize_t s1_len = strlen(s1);\n\tsize_t s2_len = strlen(s2);\n\n\tif (s1_len < s2_len)\n\t\treturn -1;\n\n\treturn strcmp(s1 + s1_len - s2_len, s2);\n}\n\nstatic int acm_open_providers(void)\n{\n\tDIR *shlib_dir;\n\tstruct dirent *dent;\n\tchar file_name[256];\n\tstruct stat buf;\n\tvoid *handle;\n\tstruct acmc_prov *prov;\n\tstruct acm_provider *provider;\n\tuint32_t version;\n\tchar *err_str;\n\tint (*query)(struct acm_provider **, uint32_t *);\n\n\tacm_log(1, \"\\n\");\n\tshlib_dir = opendir(prov_lib_path);\n\tif (!shlib_dir) {\n\t\tacm_log(0, \"ERROR - could not open provider lib dir: %s\\n\",\n\t\t\tprov_lib_path);\n\t\treturn -1;\n\t}\n\n\twhile ((dent = readdir(shlib_dir))) {\n\t\tif (acm_string_end_compare(dent->d_name, \".so\"))\n\t\t\tcontinue;\n\n\t\tif (!check_snprintf(file_name, sizeof(file_name), \"%s/%s\",\n\t\t\t\t    prov_lib_path, dent->d_name))\n\t\t\tcontinue;\n\n\t\tif (lstat(file_name, &buf)) {\n\t\t\tacm_log(0, \"Error - could not stat: %s\\n\", file_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!S_ISREG(buf.st_mode))\n\t\t\tcontinue;\n\n\t\tacm_log(2, \"Loading provider %s...\\n\", file_name);\n\t\tif (!(handle = dlopen(file_name, RTLD_LAZY))) {\n\t\t\tacm_log(0, \"Error - could not load provider %s (%s)\\n\",\n\t\t\t\tfile_name, dlerror());\n\t\t\tcontinue;\n\t\t}\n\n\t\tquery = dlsym(handle, \"provider_query\");\n\t\tif ((err_str = dlerror()) != NULL) {\n\t\t\tacm_log(0, \"Error - provider_query not found in %s (%s)\\n\",\n\t\t\t\tfile_name, err_str);\n\t\t\tdlclose(handle);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (query(&provider, &version)) {\n\t\t\tacm_log(0, \"Error - provider_query failed to %s\\n\", file_name);\n\t\t\tdlclose(handle);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (version != ACM_PROV_VERSION ||\n\t\t    provider->size != sizeof(struct acm_provider)) {\n\t\t\tacm_log(0, \"Error -unmatched provider version 0x%08x (size %zd)\"\n\t\t\t\t\" core 0x%08x (size %zd)\\n\", version, provider->size,\n\t\t\t\tACM_PROV_VERSION, sizeof(struct acm_provider));\n\t\t\tdlclose(handle);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacm_log(1, \"Provider %s (%s) loaded\\n\", provider->name, file_name);\n\n\t\tprov = calloc(1, sizeof(*prov));\n\t\tif (!prov) {\n\t\t\tacm_log(0, \"Error -failed to allocate provider %s\\n\", file_name);\n\t\t\tdlclose(handle);\n\t\t\tcontinue;\n\t\t}\n\n\t\tprov->prov = provider;\n\t\tprov->handle = handle;\n\t\tlist_head_init(&prov->subnet_list);\n\t\tlist_add_tail(&provider_list, &prov->entry);\n\t\tif (!strcasecmp(provider->name, def_prov_name))\n\t\t\tdef_provider = prov;\n\t}\n\n\tclosedir(shlib_dir);\n\tacm_load_prov_config();\n\treturn 0;\n}\n\nstatic void acm_close_providers(void)\n{\n\tstruct acmc_prov *prov;\n\tstruct acmc_subnet *subnet;\n\n\tacm_log(1, \"\\n\");\n\tdef_provider = NULL;\n\n\twhile ((prov = list_pop(&provider_list, struct acmc_prov, entry))) {\n\t\twhile ((subnet = list_pop(&prov->subnet_list,\n\t\t\t\tstruct acmc_subnet, entry)))\n\t\t\tfree(subnet);\n\t\tdlclose(prov->handle);\n\t\tfree(prov);\n\t}\n}\n\nstatic int acmc_init_sa_fds(void)\n{\n\tstruct acmc_device *dev;\n\tint ret, p, i = 0;\n\n\tlist_for_each(&dev_list, dev, entry)\n\t\tsa.nfds += dev->port_cnt;\n\n\tsa.fds = calloc(sa.nfds, sizeof(*sa.fds));\n\tsa.ports = calloc(sa.nfds, sizeof(*sa.ports));\n\tif (!sa.fds || !sa.ports)\n\t\treturn -ENOMEM;\n\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (p = 0; p < dev->port_cnt; p++) {\n\t\t\tsa.fds[i].fd = umad_get_fd(dev->port[p].mad_portid);\n\t\t\tsa.fds[i].events = POLLIN;\n\t\t\tret = set_fd_nonblock(sa.fds[i].fd, true);\n\t\t\tif (ret)\n\t\t\t\tacm_log(0, \"WARNING - umad fd is blocking\\n\");\n\n\t\t\tsa.ports[i++] = &dev->port[p];\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct acm_sa_mad *\nacm_alloc_sa_mad(const struct acm_endpoint *endpoint, void *context,\n\t\t void (*handler)(struct acm_sa_mad *))\n{\n\tstruct acmc_sa_req *req;\n\n\tif (!endpoint) {\n\t\tacm_log(0, \"Error: NULL endpoint\\n\");\n\t\treturn NULL;\n\t}\n\treq = calloc(1, sizeof (*req));\n\tif (!req) {\n\t\tacm_log(0, \"Error: failed to allocate sa request\\n\");\n\t\treturn NULL;\n\t}\n\n\treq->ep = container_of(endpoint, struct acmc_ep, endpoint);\n\treq->mad.context = context;\n\treq->resp_handler = handler;\n\n\tacm_log(2, \"%p\\n\", req);\n\treturn &req->mad;\n}\n\nvoid acm_free_sa_mad(struct acm_sa_mad *mad)\n{\n\tstruct acmc_sa_req *req;\n\treq = container_of(mad, struct acmc_sa_req, mad);\n\tacm_log(2, \"%p\\n\", req);\n\tfree(req);\n}\n\nint acm_send_sa_mad(struct acm_sa_mad *mad)\n{\n\tstruct acmc_port *port;\n\tstruct acmc_sa_req *req;\n\tint ret;\n\n\treq = container_of(mad, struct acmc_sa_req, mad);\n\tacm_log(2, \"%p from %s\\n\", req, req->ep->addr_info[0].addr.id_string);\n\n\tport = req->ep->port;\n\tmad->umad.addr.qpn = port->sa_addr.qpn;\n\tmad->umad.addr.qkey = port->sa_addr.qkey;\n\tmad->umad.addr.lid = port->sa_addr.lid;\n\tmad->umad.addr.sl = port->sa_addr.sl;\n\tmad->umad.addr.pkey_index = req->ep->port->sa_pkey_index;\n\n\tpthread_mutex_lock(&port->lock);\n\tif (port->sa_credits && list_empty(&port->sa_wait)) {\n\t\tret = umad_send(port->mad_portid, port->mad_agentid, &mad->umad,\n\t\t\t\tsizeof mad->sa_mad, sa.timeout, sa.retries);\n\t\tif (!ret) {\n\t\t\tport->sa_credits--;\n\t\t\tlist_add_tail(&port->sa_pending, &req->entry);\n\t\t}\n\t} else {\n\t\tret = 0;\n\t\tlist_add_tail(&port->sa_wait, &req->entry);\n\t}\n\tpthread_mutex_unlock(&port->lock);\n\treturn ret;\n}\n\nstatic void acmc_send_queued_req(struct acmc_port *port)\n{\n\tstruct acmc_sa_req *req;\n\tint ret;\n\n\tpthread_mutex_lock(&port->lock);\n\tif (list_empty(&port->sa_wait) || !port->sa_credits) {\n\t\tpthread_mutex_unlock(&port->lock);\n\t\treturn;\n\t}\n\n\treq = list_pop(&port->sa_wait, struct acmc_sa_req, entry);\n\n\tret = umad_send(port->mad_portid, port->mad_agentid, &req->mad.umad,\n\t\t\tsizeof req->mad.sa_mad, sa.timeout, sa.retries);\n\tif (!ret) {\n\t\tport->sa_credits--;\n\t\tlist_add_tail(&port->sa_pending, &req->entry);\n\t}\n\tpthread_mutex_unlock(&port->lock);\n\n\tif (ret) {\n\t\treq->mad.umad.status = -ret;\n\t\treq->resp_handler(&req->mad);\n\t}\n}\n\nstatic void acmc_recv_mad(struct acmc_port *port)\n{\n\tstruct acmc_sa_req *req;\n\tstruct acm_sa_mad resp;\n\tint ret, len, found;\n\tstruct umad_hdr *hdr;\n\n\tif (!port->prov) {\n\t\tacm_log(1, \"no provider assigned to port\\n\");\n\t\treturn;\n\t}\n\n\tacm_log(2, \"\\n\");\n\tlen = sizeof(resp.sa_mad);\n\tret = umad_recv(port->mad_portid, &resp.umad, &len, 0);\n\tif (ret < 0) {\n\t\tacm_log(1, \"umad_recv error %d\\n\", ret);\n\t\treturn;\n\t}\n\n\thdr = &resp.sa_mad.mad_hdr;\n\tacm_log(2, \"bv %x cls %x cv %x mtd %x st %d tid %\" PRIx64 \"x at %x atm %x\\n\",\n\t\thdr->base_version, hdr->mgmt_class, hdr->class_version,\n\t\thdr->method, hdr->status, be64toh(hdr->tid), hdr->attr_id, hdr->attr_mod);\n\tfound = 0;\n\tpthread_mutex_lock(&port->lock);\n\tlist_for_each(&port->sa_pending, req, entry) {\n\t\t/* The upper 32-bit of the tid is used for agentid in umad */\n\t\tif (req->mad.sa_mad.mad_hdr.tid == (hdr->tid & htobe64(0xFFFFFFFF))) {\n\t\t\tfound = 1;\n\t\t\tlist_del(&req->entry);\n\t\t\tport->sa_credits++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpthread_mutex_unlock(&port->lock);\n\n\tif (found) {\n\t\tmemcpy(&req->mad.umad, &resp.umad, sizeof(resp.umad) + len);\n\t\treq->resp_handler(&req->mad);\n\t}\n}\n\nstatic void *acm_sa_handler(void *context)\n{\n\tint i, ret;\n\n\tacm_log(0, \"started\\n\");\n\tret = acmc_init_sa_fds();\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - failed to init fds\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL)) {\n\t\tacm_log(0, \"Error: failed to set cancel type \\n\");\n\t\treturn NULL;\n\t}\n\n\tif (pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL)) {\n\t\tacm_log(0, \"Error: failed to set cancel state\\n\");\n\t\treturn NULL;\n\t}\n\n\tfor (;;) {\n\t\tpthread_testcancel();\n\t\tret = poll(sa.fds, sa.nfds, -1);\n\t\tif (ret < 0) {\n\t\t\tacm_log(0, \"ERROR - sa poll error: %d\\n\", errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < sa.nfds; i++) {\n\t\t\tif (!sa.fds[i].revents)\n\t\t\t\tcontinue;\n\n\t\t\tif (sa.fds[i].revents & POLLIN) {\n\t\t\t\tacmc_recv_mad(sa.ports[i]);\n\t\t\t\tacmc_send_queued_req(sa.ports[i]);\n\t\t\t}\n\t\t\tsa.fds[i].revents = 0;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void acm_stop_sa_handler(void)\n{\n\tif (pthread_cancel(sa.thread_id)) {\n\t\tacm_log(0, \"Error: failed to cancel sa resp thread \\n\");\n\t\treturn;\n\t}\n\n\tif (pthread_join(sa.thread_id, NULL)) {\n\t\tacm_log(0, \"Error: failed to join sa resp thread\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void acm_set_options(void)\n{\n\tFILE *f;\n\tchar s[120];\n\tchar opt[32], value[256];\n\n\tif (!(f = fopen(opts_file, \"r\")))\n\t\treturn;\n\n\twhile (fgets(s, sizeof s, f)) {\n\t\tif (s[0] == '#')\n\t\t\tcontinue;\n\n\t\tif (sscanf(s, \"%31s%255s\", opt, value) != 2)\n\t\t\tcontinue;\n\n\t\tif (!strcasecmp(\"log_file\", opt))\n\t\t\tstrcpy(log_file, value);\n\t\telse if (!strcasecmp(\"log_level\", opt))\n\t\t\tlog_level = atoi(value);\n\t\telse if (!strcasecmp(\"lock_file\", opt))\n\t\t\tstrcpy(lock_file, value);\n\t\telse if (!strcasecmp(\"server_port\", opt))\n\t\t\tserver_port = (short) atoi(value);\n\t\telse if (!strcasecmp(\"server_mode\", opt)) {\n\t\t\tif (!strcasecmp(value, \"open\"))\n\t\t\t\tserver_mode = IBACM_SERVER_MODE_OPEN;\n\t\t\telse if (!strcasecmp(value, \"loop\"))\n\t\t\t\tserver_mode = IBACM_SERVER_MODE_LOOP;\n\t\t\telse\n\t\t\t\tserver_mode = IBACM_SERVER_MODE_UNIX;\n\t\t} else if (!strcasecmp(\"acme_plus_kernel_only\", opt))\n\t\t\tacme_plus_kernel_only =\n\t\t\t\t!strcasecmp(value, \"true\") ||\n\t\t\t\t!strcasecmp(value, \"yes\") ||\n\t\t\t\tstrtol(value, NULL, 0);\n\t\telse if (!strcasecmp(\"provider_lib_path\", opt))\n\t\t\tstrcpy(prov_lib_path, value);\n\t\telse if (!strcasecmp(\"support_ips_in_addr_cfg\", opt))\n\t\t\tsupport_ips_in_addr_cfg = atoi(value);\n\t\telse if (!strcasecmp(\"timeout\", opt))\n\t\t\tsa.timeout = atoi(value);\n\t\telse if (!strcasecmp(\"retries\", opt))\n\t\t\tsa.retries = atoi(value);\n\t\telse if (!strcasecmp(\"sa_depth\", opt))\n\t\t\tsa.depth = atoi(value);\n\t}\n\n\tfclose(f);\n}\n\nstatic void acm_log_options(void)\n{\n\tstatic const char * const server_mode_names[] = {\n\t\t[IBACM_SERVER_MODE_UNIX] = \"unix\",\n\t\t[IBACM_SERVER_MODE_LOOP] = \"loop\",\n\t\t[IBACM_SERVER_MODE_OPEN] = \"open\",\n\t};\n\n\tacm_log(0, \"log file %s\\n\", log_file);\n\tacm_log(0, \"log level %d\\n\", log_level);\n\tacm_log(0, \"lock file %s\\n\", lock_file);\n\tacm_log(0, \"server_port %d\\n\", server_port);\n\tacm_log(0, \"server_mode %s\\n\", server_mode_names[server_mode]);\n\tacm_log(0, \"acme_plus_kernel_only %s\\n\",\n\t\tacme_plus_kernel_only ? \"yes\" : \"no\");\n\tacm_log(0, \"timeout %d ms\\n\", sa.timeout);\n\tacm_log(0, \"retries %d\\n\", sa.retries);\n\tacm_log(0, \"sa depth %d\\n\", sa.depth);\n\tacm_log(0, \"options file %s\\n\", opts_file);\n\tacm_log(0, \"addr file %s\\n\", addr_file);\n\tacm_log(0, \"provider lib path %s\\n\", prov_lib_path);\n\tacm_log(0, \"support IP's in ibacm_addr.cfg %d\\n\", support_ips_in_addr_cfg);\n}\n\nstatic FILE *acm_open_log(void)\n{\n\tFILE *f;\n\n\tif (!strcasecmp(log_file, \"stdout\"))\n\t\treturn stdout;\n\n\tif (!strcasecmp(log_file, \"stderr\"))\n\t\treturn stderr;\n\n\tif (!(f = fopen(log_file, \"w\")))\n\t\tf = stdout;\n\n\treturn f;\n}\n\nstatic int acm_open_lock_file(void)\n{\n\tint lock_fd;\n\tchar pid[16];\n\n\tlock_fd = open(lock_file, O_RDWR | O_CREAT, 0640);\n\tif (lock_fd < 0)\n\t\treturn lock_fd;\n\n\tif (lockf(lock_fd, F_TLOCK, 0)) {\n\t\tclose(lock_fd);\n\t\treturn -1;\n\t}\n\n\tsnprintf(pid, sizeof pid, \"%d\\n\", getpid());\n\tif (write(lock_fd, pid, strlen(pid)) != strlen(pid)){\n\t\tclose(lock_fd);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void show_usage(char *program)\n{\n\tprintf(\"usage: %s\\n\", program);\n\tprintf(\"   [-D]             - run as a daemon (default)\\n\");\n\tprintf(\"   [-P]             - run as a standard process\\n\");\n\tprintf(\"   [-A addr_file]   - address configuration file\\n\");\n\tprintf(\"                      (default %s/%s)\\n\", ACM_CONF_DIR, ACM_ADDR_FILE);\n\tprintf(\"   [-O option_file] - option configuration file\\n\");\n\tprintf(\"                      (default %s/%s)\\n\", ACM_CONF_DIR, ACM_OPTS_FILE);\n}\n\nint main(int argc, char **argv)\n{\n\tint i, op, as_daemon = 1;\n\tbool systemd = false;\n\n\tstatic const struct option long_opts[] = {\n\t\t{\"systemd\", 0, NULL, 's'},\n\t\t{}\n\t};\n\n\twhile ((op = getopt_long(argc, argv, \"DPA:O:\", long_opts, NULL)) !=\n\t       -1) {\n\t\tswitch (op) {\n\t\tcase 'D':\n\t\t\t/* option no longer required */\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tas_daemon = 0;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\taddr_file = optarg;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\topts_file = optarg;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsystemd = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tshow_usage(argv[0]);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (as_daemon && !systemd) {\n\t\tif (daemon(0, 0))\n\t\t\treturn EXIT_FAILURE;\n\t}\n\n\tacm_set_options();\n\n\t/* usage of systemd implies unix-domain communication */\n\tif (systemd)\n\t\tserver_mode = IBACM_SERVER_MODE_UNIX;\n\n\tif (acm_open_lock_file())\n\t\treturn -1;\n\n\tpthread_mutex_init(&log_lock, NULL);\n\tflog = acm_open_log();\n\n\tacm_log(0, \"Assistant to the InfiniBand Communication Manager\\n\");\n\tacm_log_options();\n\n\tfor (i = 0; i < ACM_MAX_COUNTER; i++)\n\t\tatomic_init(&counter[i]);\n\n\tif (umad_init() != 0) {\n\t\tacm_log(0, \"ERROR - fail to initialize umad\\n\");\n\t\treturn -1;\n\t}\n\n\tif (acm_open_providers()) {\n\t\tacm_log(0, \"ERROR - unable to open any providers\\n\");\n\t\treturn -1;\n\t}\n\n\tif (acm_open_devices()) {\n\t\tacm_log(0, \"ERROR - unable to open any devices\\n\");\n\t\treturn -1;\n\t}\n\n\tacm_log(1, \"creating IP Netlink socket\\n\");\n\tacm_ipnl_create();\n\n\tacm_log(1, \"starting sa response receiving thread\\n\");\n\tif (pthread_create(&sa.thread_id, NULL, acm_sa_handler, NULL)) {\n\t\tacm_log(0, \"Error: failed to create sa resp rcving thread\");\n\t\treturn -1;\n\t}\n\n\tif (acm_init_if_iter_sys()) {\n\t\tacm_log(0, \"Error: unable to initialize acm_if_iter_sys\");\n\t\treturn -1;\n\t}\n\n\tacm_activate_devices();\n\tacm_log(1, \"starting server\\n\");\n\tacm_server(systemd);\n\n\tacm_log(0, \"shutting down\\n\");\n\tif (client_array[NL_CLIENT_INDEX].sock != -1)\n\t\tclose(client_array[NL_CLIENT_INDEX].sock);\n\tacm_close_providers();\n\tacm_stop_sa_handler();\n\tumad_done();\n\tacm_fini_if_iter_sys();\n\tfclose(flog);\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-rdma-core-32.0-lld5dj4lbomjn74h62u554lxb2v6qnhz/spack-src/librdmacm/preload.c": "/*\n * Copyright (c) 2011-2012 Intel Corporation.  All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n#define _GNU_SOURCE\n#include <config.h>\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <sys/sendfile.h>\n#include <stdarg.h>\n#include <dlfcn.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <netinet/tcp.h>\n#include <unistd.h>\n#include <semaphore.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#include <sys/uio.h>\n\n#include <rdma/rdma_cma.h>\n#include <rdma/rdma_verbs.h>\n#include <rdma/rsocket.h>\n#include \"cma.h\"\n#include \"indexer.h\"\n\nstruct socket_calls {\n\tint (*socket)(int domain, int type, int protocol);\n\tint (*bind)(int socket, const struct sockaddr *addr, socklen_t addrlen);\n\tint (*listen)(int socket, int backlog);\n\tint (*accept)(int socket, struct sockaddr *addr, socklen_t *addrlen);\n\tint (*connect)(int socket, const struct sockaddr *addr, socklen_t addrlen);\n\tssize_t (*recv)(int socket, void *buf, size_t len, int flags);\n\tssize_t (*recvfrom)(int socket, void *buf, size_t len, int flags,\n\t\t\t    struct sockaddr *src_addr, socklen_t *addrlen);\n\tssize_t (*recvmsg)(int socket, struct msghdr *msg, int flags);\n\tssize_t (*read)(int socket, void *buf, size_t count);\n\tssize_t (*readv)(int socket, const struct iovec *iov, int iovcnt);\n\tssize_t (*send)(int socket, const void *buf, size_t len, int flags);\n\tssize_t (*sendto)(int socket, const void *buf, size_t len, int flags,\n\t\t\t  const struct sockaddr *dest_addr, socklen_t addrlen);\n\tssize_t (*sendmsg)(int socket, const struct msghdr *msg, int flags);\n\tssize_t (*write)(int socket, const void *buf, size_t count);\n\tssize_t (*writev)(int socket, const struct iovec *iov, int iovcnt);\n\tint (*poll)(struct pollfd *fds, nfds_t nfds, int timeout);\n\tint (*shutdown)(int socket, int how);\n\tint (*close)(int socket);\n\tint (*getpeername)(int socket, struct sockaddr *addr, socklen_t *addrlen);\n\tint (*getsockname)(int socket, struct sockaddr *addr, socklen_t *addrlen);\n\tint (*setsockopt)(int socket, int level, int optname,\n\t\t\t  const void *optval, socklen_t optlen);\n\tint (*getsockopt)(int socket, int level, int optname,\n\t\t\t  void *optval, socklen_t *optlen);\n\tint (*fcntl)(int socket, int cmd, ... /* arg */);\n\tint (*dup2)(int oldfd, int newfd);\n\tssize_t (*sendfile)(int out_fd, int in_fd, off_t *offset, size_t count);\n\tint (*fxstat)(int ver, int fd, struct stat *buf);\n};\n\nstatic struct socket_calls real;\nstatic struct socket_calls rs;\n\nstatic struct index_map idm;\nstatic pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;\n\nstatic int sq_size;\nstatic int rq_size;\nstatic int sq_inline;\nstatic int fork_support;\n\nenum fd_type {\n\tfd_normal,\n\tfd_rsocket\n};\n\nenum fd_fork_state {\n\tfd_ready,\n\tfd_fork,\n\tfd_fork_listen,\n\tfd_fork_active,\n\tfd_fork_passive\n};\n\nstruct fd_info {\n\tenum fd_type type;\n\tenum fd_fork_state state;\n\tint fd;\n\tint dupfd;\n\t_Atomic(int) refcnt;\n};\n\nstruct config_entry {\n\tchar *name;\n\tint domain;\n\tint type;\n\tint protocol;\n};\n\nstatic struct config_entry *config;\nstatic int config_cnt;\n\nstatic void free_config(void)\n{\n\twhile (config_cnt)\n\t\tfree(config[--config_cnt].name);\n\n\tfree(config);\n}\n\n/*\n * Config file format:\n * # Starting '#' indicates comment\n * # wild card values are supported using '*'\n * # domain - *, INET, INET6, IB\n * # type - *, STREAM, DGRAM\n * # protocol - *, TCP, UDP\n * program_name domain type protocol\n */\nstatic void scan_config(void)\n{\n\tstruct config_entry *new_config;\n\tFILE *fp;\n\tchar line[120], prog[64], dom[16], type[16], proto[16];\n\n\tfp = fopen(RS_CONF_DIR \"/preload_config\", \"r\");\n\tif (!fp)\n\t\treturn;\n\n\twhile (fgets(line, sizeof(line), fp)) {\n\t\tif (line[0] == '#')\n\t\t\tcontinue;\n\n\t\tif (sscanf(line, \"%63s%15s%15s%15s\", prog, dom, type, proto) != 4)\n\t\t\tcontinue;\n\n\t\tnew_config = realloc(config, (config_cnt + 1) *\n\t\t\t\t\t     sizeof(struct config_entry));\n\t\tif (!new_config)\n\t\t\tbreak;\n\n\t\tconfig = new_config;\n\t\tmemset(&config[config_cnt], 0, sizeof(struct config_entry));\n\n\t\tif (!strcasecmp(dom, \"INET\") ||\n\t\t    !strcasecmp(dom, \"AF_INET\") ||\n\t\t    !strcasecmp(dom, \"PF_INET\")) {\n\t\t\tconfig[config_cnt].domain = AF_INET;\n\t\t} else if (!strcasecmp(dom, \"INET6\") ||\n\t\t\t   !strcasecmp(dom, \"AF_INET6\") ||\n\t\t\t   !strcasecmp(dom, \"PF_INET6\")) {\n\t\t\tconfig[config_cnt].domain = AF_INET6;\n\t\t} else if (!strcasecmp(dom, \"IB\") ||\n\t\t\t   !strcasecmp(dom, \"AF_IB\") ||\n\t\t\t   !strcasecmp(dom, \"PF_IB\")) {\n\t\t\tconfig[config_cnt].domain = AF_IB;\n\t\t} else if (strcmp(dom, \"*\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcasecmp(type, \"STREAM\") ||\n\t\t    !strcasecmp(type, \"SOCK_STREAM\")) {\n\t\t\tconfig[config_cnt].type = SOCK_STREAM;\n\t\t} else if (!strcasecmp(type, \"DGRAM\") ||\n\t\t\t   !strcasecmp(type, \"SOCK_DGRAM\")) {\n\t\t\tconfig[config_cnt].type = SOCK_DGRAM;\n\t\t} else if (strcmp(type, \"*\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcasecmp(proto, \"TCP\") ||\n\t\t    !strcasecmp(proto, \"IPPROTO_TCP\")) {\n\t\t\tconfig[config_cnt].protocol = IPPROTO_TCP;\n\t\t} else if (!strcasecmp(proto, \"UDP\") ||\n\t\t\t   !strcasecmp(proto, \"IPPROTO_UDP\")) {\n\t\t\tconfig[config_cnt].protocol = IPPROTO_UDP;\n\t\t} else if (strcmp(proto, \"*\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(prog, \"*\")) {\n\t\t    if (!(config[config_cnt].name = strdup(prog)))\n\t\t\t    continue;\n\t\t}\n\n\t\tconfig_cnt++;\n\t}\n\n\tfclose(fp);\n\tif (config_cnt)\n\t\tatexit(free_config);\n}\n\nstatic int intercept_socket(int domain, int type, int protocol)\n{\n\tint i;\n\n\tif (!config_cnt)\n\t\treturn 1;\n\n\tif (!protocol) {\n\t\tif (type == SOCK_STREAM)\n\t\t\tprotocol = IPPROTO_TCP;\n\t\telse if (type == SOCK_DGRAM)\n\t\t\tprotocol = IPPROTO_UDP;\n\t}\n\n\tfor (i = 0; i < config_cnt; i++) {\n\t\tif ((!config[i].name ||\n\t\t     !strncasecmp(config[i].name, program_invocation_short_name,\n\t\t\t\t  strlen(config[i].name))) &&\n\t\t    (!config[i].domain || config[i].domain == domain) &&\n\t\t    (!config[i].type || config[i].type == type) &&\n\t\t    (!config[i].protocol || config[i].protocol == protocol))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int fd_open(void)\n{\n\tstruct fd_info *fdi;\n\tint ret, index;\n\n\tfdi = calloc(1, sizeof(*fdi));\n\tif (!fdi)\n\t\treturn ERR(ENOMEM);\n\n\tindex = open(\"/dev/null\", O_RDONLY);\n\tif (index < 0) {\n\t\tret = index;\n\t\tgoto err1;\n\t}\n\n\tfdi->dupfd = -1;\n\tatomic_store(&fdi->refcnt, 1);\n\tpthread_mutex_lock(&mut);\n\tret = idm_set(&idm, index, fdi);\n\tpthread_mutex_unlock(&mut);\n\tif (ret < 0)\n\t\tgoto err2;\n\n\treturn index;\n\nerr2:\n\treal.close(index);\nerr1:\n\tfree(fdi);\n\treturn ret;\n}\n\nstatic void fd_store(int index, int fd, enum fd_type type, enum fd_fork_state state)\n{\n\tstruct fd_info *fdi;\n\n\tfdi = idm_at(&idm, index);\n\tfdi->fd = fd;\n\tfdi->type = type;\n\tfdi->state = state;\n}\n\nstatic inline enum fd_type fd_get(int index, int *fd)\n{\n\tstruct fd_info *fdi;\n\n\tfdi = idm_lookup(&idm, index);\n\tif (fdi) {\n\t\t*fd = fdi->fd;\n\t\treturn fdi->type;\n\n\t} else {\n\t\t*fd = index;\n\t\treturn fd_normal;\n\t}\n}\n\nstatic inline int fd_getd(int index)\n{\n\tstruct fd_info *fdi;\n\n\tfdi = idm_lookup(&idm, index);\n\treturn fdi ? fdi->fd : index;\n}\n\nstatic inline enum fd_fork_state fd_gets(int index)\n{\n\tstruct fd_info *fdi;\n\n\tfdi = idm_lookup(&idm, index);\n\treturn fdi ? fdi->state : fd_ready;\n}\n\nstatic inline enum fd_type fd_gett(int index)\n{\n\tstruct fd_info *fdi;\n\n\tfdi = idm_lookup(&idm, index);\n\treturn fdi ? fdi->type : fd_normal;\n}\n\nstatic enum fd_type fd_close(int index, int *fd)\n{\n\tstruct fd_info *fdi;\n\tenum fd_type type;\n\n\tfdi = idm_lookup(&idm, index);\n\tif (fdi) {\n\t\tidm_clear(&idm, index);\n\t\t*fd = fdi->fd;\n\t\ttype = fdi->type;\n\t\treal.close(index);\n\t\tfree(fdi);\n\t} else {\n\t\t*fd = index;\n\t\ttype = fd_normal;\n\t}\n\treturn type;\n}\n\nstatic void getenv_options(void)\n{\n\tchar *var;\n\n\tvar = getenv(\"RS_SQ_SIZE\");\n\tif (var)\n\t\tsq_size = atoi(var);\n\n\tvar = getenv(\"RS_RQ_SIZE\");\n\tif (var)\n\t\trq_size = atoi(var);\n\n\tvar = getenv(\"RS_INLINE\");\n\tif (var)\n\t\tsq_inline = atoi(var);\n\n\tvar = getenv(\"RDMAV_FORK_SAFE\");\n\tif (var)\n\t\tfork_support = atoi(var);\n}\n\nstatic void init_preload(void)\n{\n\tstatic int init;\n\n\t/* Quick check without lock */\n\tif (init)\n\t\treturn;\n\n\tpthread_mutex_lock(&mut);\n\tif (init)\n\t\tgoto out;\n\n\treal.socket = dlsym(RTLD_NEXT, \"socket\");\n\treal.bind = dlsym(RTLD_NEXT, \"bind\");\n\treal.listen = dlsym(RTLD_NEXT, \"listen\");\n\treal.accept = dlsym(RTLD_NEXT, \"accept\");\n\treal.connect = dlsym(RTLD_NEXT, \"connect\");\n\treal.recv = dlsym(RTLD_NEXT, \"recv\");\n\treal.recvfrom = dlsym(RTLD_NEXT, \"recvfrom\");\n\treal.recvmsg = dlsym(RTLD_NEXT, \"recvmsg\");\n\treal.read = dlsym(RTLD_NEXT, \"read\");\n\treal.readv = dlsym(RTLD_NEXT, \"readv\");\n\treal.send = dlsym(RTLD_NEXT, \"send\");\n\treal.sendto = dlsym(RTLD_NEXT, \"sendto\");\n\treal.sendmsg = dlsym(RTLD_NEXT, \"sendmsg\");\n\treal.write = dlsym(RTLD_NEXT, \"write\");\n\treal.writev = dlsym(RTLD_NEXT, \"writev\");\n\treal.poll = dlsym(RTLD_NEXT, \"poll\");\n\treal.shutdown = dlsym(RTLD_NEXT, \"shutdown\");\n\treal.close = dlsym(RTLD_NEXT, \"close\");\n\treal.getpeername = dlsym(RTLD_NEXT, \"getpeername\");\n\treal.getsockname = dlsym(RTLD_NEXT, \"getsockname\");\n\treal.setsockopt = dlsym(RTLD_NEXT, \"setsockopt\");\n\treal.getsockopt = dlsym(RTLD_NEXT, \"getsockopt\");\n\treal.fcntl = dlsym(RTLD_NEXT, \"fcntl\");\n\treal.dup2 = dlsym(RTLD_NEXT, \"dup2\");\n\treal.sendfile = dlsym(RTLD_NEXT, \"sendfile\");\n\treal.fxstat = dlsym(RTLD_NEXT, \"__fxstat\");\n\n\trs.socket = dlsym(RTLD_DEFAULT, \"rsocket\");\n\trs.bind = dlsym(RTLD_DEFAULT, \"rbind\");\n\trs.listen = dlsym(RTLD_DEFAULT, \"rlisten\");\n\trs.accept = dlsym(RTLD_DEFAULT, \"raccept\");\n\trs.connect = dlsym(RTLD_DEFAULT, \"rconnect\");\n\trs.recv = dlsym(RTLD_DEFAULT, \"rrecv\");\n\trs.recvfrom = dlsym(RTLD_DEFAULT, \"rrecvfrom\");\n\trs.recvmsg = dlsym(RTLD_DEFAULT, \"rrecvmsg\");\n\trs.read = dlsym(RTLD_DEFAULT, \"rread\");\n\trs.readv = dlsym(RTLD_DEFAULT, \"rreadv\");\n\trs.send = dlsym(RTLD_DEFAULT, \"rsend\");\n\trs.sendto = dlsym(RTLD_DEFAULT, \"rsendto\");\n\trs.sendmsg = dlsym(RTLD_DEFAULT, \"rsendmsg\");\n\trs.write = dlsym(RTLD_DEFAULT, \"rwrite\");\n\trs.writev = dlsym(RTLD_DEFAULT, \"rwritev\");\n\trs.poll = dlsym(RTLD_DEFAULT, \"rpoll\");\n\trs.shutdown = dlsym(RTLD_DEFAULT, \"rshutdown\");\n\trs.close = dlsym(RTLD_DEFAULT, \"rclose\");\n\trs.getpeername = dlsym(RTLD_DEFAULT, \"rgetpeername\");\n\trs.getsockname = dlsym(RTLD_DEFAULT, \"rgetsockname\");\n\trs.setsockopt = dlsym(RTLD_DEFAULT, \"rsetsockopt\");\n\trs.getsockopt = dlsym(RTLD_DEFAULT, \"rgetsockopt\");\n\trs.fcntl = dlsym(RTLD_DEFAULT, \"rfcntl\");\n\n\tgetenv_options();\n\tscan_config();\n\tinit = 1;\nout:\n\tpthread_mutex_unlock(&mut);\n}\n\n/*\n * We currently only handle copying a few common values.\n */\nstatic int copysockopts(int dfd, int sfd, struct socket_calls *dapi,\n\t\t\tstruct socket_calls *sapi)\n{\n\tsocklen_t len;\n\tint param, ret;\n\n\tret = sapi->fcntl(sfd, F_GETFL);\n\tif (ret > 0)\n\t\tret = dapi->fcntl(dfd, F_SETFL, ret);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = sizeof param;\n\tret = sapi->getsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &param, &len);\n\tif (param && !ret)\n\t\tret = dapi->setsockopt(dfd, SOL_SOCKET, SO_REUSEADDR, &param, len);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = sizeof param;\n\tret = sapi->getsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, &param, &len);\n\tif (param && !ret)\n\t\tret = dapi->setsockopt(dfd, IPPROTO_TCP, TCP_NODELAY, &param, len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n/*\n * Convert between an rsocket and a normal socket.\n */\nstatic int transpose_socket(int socket, enum fd_type new_type)\n{\n\tsocklen_t len = 0;\n\tint sfd, dfd, param, ret;\n\tstruct socket_calls *sapi, *dapi;\n\n\tsfd = fd_getd(socket);\n\tif (new_type == fd_rsocket) {\n\t\tdapi = &rs;\n\t\tsapi = &real;\n\t} else {\n\t\tdapi = &real;\n\t\tsapi = &rs;\n\t}\n\n\tret = sapi->getsockname(sfd, NULL, &len);\n\tif (ret)\n\t\treturn ret;\n\n\tparam = (len == sizeof(struct sockaddr_in6)) ? PF_INET6 : PF_INET;\n\tdfd = dapi->socket(param, SOCK_STREAM, 0);\n\tif (dfd < 0)\n\t\treturn dfd;\n\n\tret = copysockopts(dfd, sfd, dapi, sapi);\n\tif (ret)\n\t\tgoto err;\n\n\tfd_store(socket, dfd, new_type, fd_ready);\n\treturn dfd;\n\nerr:\n\tdapi->close(dfd);\n\treturn ret;\n}\n\n/*\n * Use defaults on failure.\n */\nstatic void set_rsocket_options(int rsocket)\n{\n\tif (sq_size)\n\t\trsetsockopt(rsocket, SOL_RDMA, RDMA_SQSIZE, &sq_size, sizeof sq_size);\n\n\tif (rq_size)\n\t\trsetsockopt(rsocket, SOL_RDMA, RDMA_RQSIZE, &rq_size, sizeof rq_size);\n\n\tif (sq_inline)\n\t\trsetsockopt(rsocket, SOL_RDMA, RDMA_INLINE, &sq_inline, sizeof sq_inline);\n}\n\nint socket(int domain, int type, int protocol)\n{\n\tstatic __thread int recursive;\n\tint index, ret;\n\n\tinit_preload();\n\n\tif (recursive || !intercept_socket(domain, type, protocol))\n\t\tgoto real;\n\n\tindex = fd_open();\n\tif (index < 0)\n\t\treturn index;\n\n\tif (fork_support && (domain == PF_INET || domain == PF_INET6) &&\n\t    (type == SOCK_STREAM) && (!protocol || protocol == IPPROTO_TCP)) {\n\t\tret = real.socket(domain, type, protocol);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tfd_store(index, ret, fd_normal, fd_fork);\n\t\treturn index;\n\t}\n\n\trecursive = 1;\n\tret = rsocket(domain, type, protocol);\n\trecursive = 0;\n\tif (ret >= 0) {\n\t\tfd_store(index, ret, fd_rsocket, fd_ready);\n\t\tset_rsocket_options(ret);\n\t\treturn index;\n\t}\n\tfd_close(index, &ret);\nreal:\n\treturn real.socket(domain, type, protocol);\n}\n\nint bind(int socket, const struct sockaddr *addr, socklen_t addrlen)\n{\n\tint fd;\n\treturn (fd_get(socket, &fd) == fd_rsocket) ?\n\t\trbind(fd, addr, addrlen) : real.bind(fd, addr, addrlen);\n}\n\nint listen(int socket, int backlog)\n{\n\tint fd, ret;\n\tif (fd_get(socket, &fd) == fd_rsocket) {\n\t\tret = rlisten(fd, backlog);\n\t} else {\n\t\tret = real.listen(fd, backlog);\n\t\tif (!ret && fd_gets(socket) == fd_fork)\n\t\t\tfd_store(socket, fd, fd_normal, fd_fork_listen);\n\t}\n\treturn ret;\n}\n\nint accept(int socket, struct sockaddr *addr, socklen_t *addrlen)\n{\n\tint fd, index, ret;\n\n\tif (fd_get(socket, &fd) == fd_rsocket) {\n\t\tindex = fd_open();\n\t\tif (index < 0)\n\t\t\treturn index;\n\n\t\tret = raccept(fd, addr, addrlen);\n\t\tif (ret < 0) {\n\t\t\tfd_close(index, &fd);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfd_store(index, ret, fd_rsocket, fd_ready);\n\t\treturn index;\n\t} else if (fd_gets(socket) == fd_fork_listen) {\n\t\tindex = fd_open();\n\t\tif (index < 0)\n\t\t\treturn index;\n\n\t\tret = real.accept(fd, addr, addrlen);\n\t\tif (ret < 0) {\n\t\t\tfd_close(index, &fd);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfd_store(index, ret, fd_normal, fd_fork_passive);\n\t\treturn index;\n\t} else {\n\t\treturn real.accept(fd, addr, addrlen);\n\t}\n}\n\n/*\n * We can't fork RDMA connections and pass them from the parent to the child\n * process.  Instead, we need to establish the RDMA connection after calling\n * fork.  To do this, we delay establishing the RDMA connection until we try\n * to send/receive on the server side.\n */\nstatic void fork_active(int socket)\n{\n\tstruct sockaddr_storage addr;\n\tint sfd, dfd, ret;\n\tsocklen_t len;\n\tuint32_t msg;\n\tlong flags;\n\n\tsfd = fd_getd(socket);\n\n\tflags = real.fcntl(sfd, F_GETFL);\n\treal.fcntl(sfd, F_SETFL, 0);\n\tret = real.recv(sfd, &msg, sizeof msg, MSG_PEEK);\n\treal.fcntl(sfd, F_SETFL, flags);\n\tif ((ret != sizeof msg) || msg)\n\t\tgoto err1;\n\n\tlen = sizeof addr;\n\tret = real.getpeername(sfd, (struct sockaddr *) &addr, &len);\n\tif (ret)\n\t\tgoto err1;\n\n\tdfd = rsocket(addr.ss_family, SOCK_STREAM, 0);\n\tif (dfd < 0)\n\t\tgoto err1;\n\n\tret = rconnect(dfd, (struct sockaddr *) &addr, len);\n\tif (ret)\n\t\tgoto err2;\n\n\tset_rsocket_options(dfd);\n\tcopysockopts(dfd, sfd, &rs, &real);\n\treal.shutdown(sfd, SHUT_RDWR);\n\treal.close(sfd);\n\tfd_store(socket, dfd, fd_rsocket, fd_ready);\n\treturn;\n\nerr2:\n\trclose(dfd);\nerr1:\n\tfd_store(socket, sfd, fd_normal, fd_ready);\n}\n\n/*\n * The server will start listening for the new connection, then send a\n * message to the active side when the listen is ready.  This does leave\n * fork unsupported in the following case: the server is nonblocking and\n * calls select/poll waiting to receive data from the client.\n */\nstatic void fork_passive(int socket)\n{\n\tstruct sockaddr_in6 sin6;\n\tsem_t *sem;\n\tint lfd, sfd, dfd, ret, param;\n\tsocklen_t len;\n\tuint32_t msg;\n\n\tsfd = fd_getd(socket);\n\n\tlen = sizeof sin6;\n\tret = real.getsockname(sfd, (struct sockaddr *) &sin6, &len);\n\tif (ret)\n\t\tgoto out;\n\tsin6.sin6_flowinfo = 0;\n\tsin6.sin6_scope_id = 0;\n\tmemset(&sin6.sin6_addr, 0, sizeof sin6.sin6_addr);\n\n\tsem = sem_open(\"/rsocket_fork\", O_CREAT | O_RDWR,\n\t\t       S_IRWXU | S_IRWXG, 1);\n\tif (sem == SEM_FAILED) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tlfd = rsocket(sin6.sin6_family, SOCK_STREAM, 0);\n\tif (lfd < 0) {\n\t\tret = lfd;\n\t\tgoto sclose;\n\t}\n\n\tparam = 1;\n\trsetsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &param, sizeof param);\n\n\tsem_wait(sem);\n\tret = rbind(lfd, (struct sockaddr *) &sin6, sizeof sin6);\n\tif (ret)\n\t\tgoto lclose;\n\n\tret = rlisten(lfd, 1);\n\tif (ret)\n\t\tgoto lclose;\n\n\tmsg = 0;\n\tlen = real.write(sfd, &msg, sizeof msg);\n\tif (len != sizeof msg)\n\t\tgoto lclose;\n\n\tdfd = raccept(lfd, NULL, NULL);\n\tif (dfd < 0) {\n\t\tret  = dfd;\n\t\tgoto lclose;\n\t}\n\n\tset_rsocket_options(dfd);\n\tcopysockopts(dfd, sfd, &rs, &real);\n\treal.shutdown(sfd, SHUT_RDWR);\n\treal.close(sfd);\n\tfd_store(socket, dfd, fd_rsocket, fd_ready);\n\nlclose:\n\trclose(lfd);\n\tsem_post(sem);\nsclose:\n\tsem_close(sem);\nout:\n\tif (ret)\n\t\tfd_store(socket, sfd, fd_normal, fd_ready);\n}\n\nstatic inline enum fd_type fd_fork_get(int index, int *fd)\n{\n\tstruct fd_info *fdi;\n\n\tfdi = idm_lookup(&idm, index);\n\tif (fdi) {\n\t\tif (fdi->state == fd_fork_passive)\n\t\t\tfork_passive(index);\n\t\telse if (fdi->state == fd_fork_active)\n\t\t\tfork_active(index);\n\t\t*fd = fdi->fd;\n\t\treturn fdi->type;\n\n\t} else {\n\t\t*fd = index;\n\t\treturn fd_normal;\n\t}\n}\n\nint connect(int socket, const struct sockaddr *addr, socklen_t addrlen)\n{\n\tint fd, ret;\n\n\tif (fd_get(socket, &fd) == fd_rsocket) {\n\t\tret = rconnect(fd, addr, addrlen);\n\t\tif (!ret || errno == EINPROGRESS)\n\t\t\treturn ret;\n\n\t\tret = transpose_socket(socket, fd_normal);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\trclose(fd);\n\t\tfd = ret;\n\t} else if (fd_gets(socket) == fd_fork) {\n\t\tfd_store(socket, fd, fd_normal, fd_fork_active);\n\t}\n\n\treturn real.connect(fd, addr, addrlen);\n}\n\nssize_t recv(int socket, void *buf, size_t len, int flags)\n{\n\tint fd;\n\treturn (fd_fork_get(socket, &fd) == fd_rsocket) ?\n\t\trrecv(fd, buf, len, flags) : real.recv(fd, buf, len, flags);\n}\n\nssize_t recvfrom(int socket, void *buf, size_t len, int flags,\n\t\t struct sockaddr *src_addr, socklen_t *addrlen)\n{\n\tint fd;\n\treturn (fd_fork_get(socket, &fd) == fd_rsocket) ?\n\t\trrecvfrom(fd, buf, len, flags, src_addr, addrlen) :\n\t\treal.recvfrom(fd, buf, len, flags, src_addr, addrlen);\n}\n\nssize_t recvmsg(int socket, struct msghdr *msg, int flags)\n{\n\tint fd;\n\treturn (fd_fork_get(socket, &fd) == fd_rsocket) ?\n\t\trrecvmsg(fd, msg, flags) : real.recvmsg(fd, msg, flags);\n}\n\nssize_t read(int socket, void *buf, size_t count)\n{\n\tint fd;\n\tinit_preload();\n\treturn (fd_fork_get(socket, &fd) == fd_rsocket) ?\n\t\trread(fd, buf, count) : real.read(fd, buf, count);\n}\n\nssize_t readv(int socket, const struct iovec *iov, int iovcnt)\n{\n\tint fd;\n\tinit_preload();\n\treturn (fd_fork_get(socket, &fd) == fd_rsocket) ?\n\t\trreadv(fd, iov, iovcnt) : real.readv(fd, iov, iovcnt);\n}\n\nssize_t send(int socket, const void *buf, size_t len, int flags)\n{\n\tint fd;\n\treturn (fd_fork_get(socket, &fd) == fd_rsocket) ?\n\t\trsend(fd, buf, len, flags) : real.send(fd, buf, len, flags);\n}\n\nssize_t sendto(int socket, const void *buf, size_t len, int flags,\n\t\tconst struct sockaddr *dest_addr, socklen_t addrlen)\n{\n\tint fd;\n\treturn (fd_fork_get(socket, &fd) == fd_rsocket) ?\n\t\trsendto(fd, buf, len, flags, dest_addr, addrlen) :\n\t\treal.sendto(fd, buf, len, flags, dest_addr, addrlen);\n}\n\nssize_t sendmsg(int socket, const struct msghdr *msg, int flags)\n{\n\tint fd;\n\treturn (fd_fork_get(socket, &fd) == fd_rsocket) ?\n\t\trsendmsg(fd, msg, flags) : real.sendmsg(fd, msg, flags);\n}\n\nssize_t write(int socket, const void *buf, size_t count)\n{\n\tint fd;\n\tinit_preload();\n\treturn (fd_fork_get(socket, &fd) == fd_rsocket) ?\n\t\trwrite(fd, buf, count) : real.write(fd, buf, count);\n}\n\nssize_t writev(int socket, const struct iovec *iov, int iovcnt)\n{\n\tint fd;\n\tinit_preload();\n\treturn (fd_fork_get(socket, &fd) == fd_rsocket) ?\n\t\trwritev(fd, iov, iovcnt) : real.writev(fd, iov, iovcnt);\n}\n\nstatic struct pollfd *fds_alloc(nfds_t nfds)\n{\n\tstatic __thread struct pollfd *rfds;\n\tstatic __thread nfds_t rnfds;\n\n\tif (nfds > rnfds) {\n\t\tif (rfds)\n\t\t\tfree(rfds);\n\n\t\trfds = malloc(sizeof(*rfds) * nfds);\n\t\trnfds = rfds ? nfds : 0;\n\t}\n\n\treturn rfds;\n}\n\nint poll(struct pollfd *fds, nfds_t nfds, int timeout)\n{\n\tstruct pollfd *rfds;\n\tint i, ret;\n\n\tinit_preload();\n\tfor (i = 0; i < nfds; i++) {\n\t\tif (fd_gett(fds[i].fd) == fd_rsocket)\n\t\t\tgoto use_rpoll;\n\t}\n\n\treturn real.poll(fds, nfds, timeout);\n\nuse_rpoll:\n\trfds = fds_alloc(nfds);\n\tif (!rfds)\n\t\treturn ERR(ENOMEM);\n\n\tfor (i = 0; i < nfds; i++) {\n\t\trfds[i].fd = fd_getd(fds[i].fd);\n\t\trfds[i].events = fds[i].events;\n\t\trfds[i].revents = 0;\n\t}\n\n\tret = rpoll(rfds, nfds, timeout);\n\n\tfor (i = 0; i < nfds; i++)\n\t\tfds[i].revents = rfds[i].revents;\n\n\treturn ret;\n}\n\nstatic void select_to_rpoll(struct pollfd *fds, int *nfds,\n\t\t\t    fd_set *readfds, fd_set *writefds, fd_set *exceptfds)\n{\n\tint fd, events, i = 0;\n\n\tfor (fd = 0; fd < *nfds; fd++) {\n\t\tevents = (readfds && FD_ISSET(fd, readfds)) ? POLLIN : 0;\n\t\tif (writefds && FD_ISSET(fd, writefds))\n\t\t\tevents |= POLLOUT;\n\n\t\tif (events || (exceptfds && FD_ISSET(fd, exceptfds))) {\n\t\t\tfds[i].fd = fd_getd(fd);\n\t\t\tfds[i++].events = events;\n\t\t}\n\t}\n\n\t*nfds = i;\n}\n\nstatic int rpoll_to_select(struct pollfd *fds, int nfds,\n\t\t\t   fd_set *readfds, fd_set *writefds, fd_set *exceptfds)\n{\n\tint fd, rfd, i, cnt = 0;\n\n\tfor (i = 0, fd = 0; i < nfds; fd++) {\n\t\trfd = fd_getd(fd);\n\t\tif (rfd != fds[i].fd)\n\t\t\tcontinue;\n\n\t\tif (readfds && (fds[i].revents & POLLIN)) {\n\t\t\tFD_SET(fd, readfds);\n\t\t\tcnt++;\n\t\t}\n\n\t\tif (writefds && (fds[i].revents & POLLOUT)) {\n\t\t\tFD_SET(fd, writefds);\n\t\t\tcnt++;\n\t\t}\n\n\t\tif (exceptfds && (fds[i].revents & ~(POLLIN | POLLOUT))) {\n\t\t\tFD_SET(fd, exceptfds);\n\t\t\tcnt++;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn cnt;\n}\n\nstatic int rs_convert_timeout(struct timeval *timeout)\n{\n\treturn !timeout ? -1 : timeout->tv_sec * 1000 + timeout->tv_usec / 1000;\n}\n\nint select(int nfds, fd_set *readfds, fd_set *writefds,\n\t   fd_set *exceptfds, struct timeval *timeout)\n{\n\tstruct pollfd *fds;\n\tint ret;\n\n\tfds = fds_alloc(nfds);\n\tif (!fds)\n\t\treturn ERR(ENOMEM);\n\n\tselect_to_rpoll(fds, &nfds, readfds, writefds, exceptfds);\n\tret = rpoll(fds, nfds, rs_convert_timeout(timeout));\n\n\tif (readfds)\n\t\tFD_ZERO(readfds);\n\tif (writefds)\n\t\tFD_ZERO(writefds);\n\tif (exceptfds)\n\t\tFD_ZERO(exceptfds);\n\n\tif (ret > 0)\n\t\tret = rpoll_to_select(fds, nfds, readfds, writefds, exceptfds);\n\n\treturn ret;\n}\n\nint shutdown(int socket, int how)\n{\n\tint fd;\n\treturn (fd_get(socket, &fd) == fd_rsocket) ?\n\t\trshutdown(fd, how) : real.shutdown(fd, how);\n}\n\nint close(int socket)\n{\n\tstruct fd_info *fdi;\n\tint ret;\n\n\tinit_preload();\n\tfdi = idm_lookup(&idm, socket);\n\tif (!fdi)\n\t\treturn real.close(socket);\n\n\tif (fdi->dupfd != -1) {\n\t\tret = close(fdi->dupfd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (atomic_fetch_sub(&fdi->refcnt, 1) != 1)\n\t\treturn 0;\n\n\tidm_clear(&idm, socket);\n\treal.close(socket);\n\tret = (fdi->type == fd_rsocket) ? rclose(fdi->fd) : real.close(fdi->fd);\n\tfree(fdi);\n\treturn ret;\n}\n\nint getpeername(int socket, struct sockaddr *addr, socklen_t *addrlen)\n{\n\tint fd;\n\treturn (fd_get(socket, &fd) == fd_rsocket) ?\n\t\trgetpeername(fd, addr, addrlen) :\n\t\treal.getpeername(fd, addr, addrlen);\n}\n\nint getsockname(int socket, struct sockaddr *addr, socklen_t *addrlen)\n{\n\tint fd;\n\tinit_preload();\n\treturn (fd_get(socket, &fd) == fd_rsocket) ?\n\t\trgetsockname(fd, addr, addrlen) :\n\t\treal.getsockname(fd, addr, addrlen);\n}\n\nint setsockopt(int socket, int level, int optname,\n\t\tconst void *optval, socklen_t optlen)\n{\n\tint fd;\n\treturn (fd_get(socket, &fd) == fd_rsocket) ?\n\t\trsetsockopt(fd, level, optname, optval, optlen) :\n\t\treal.setsockopt(fd, level, optname, optval, optlen);\n}\n\nint getsockopt(int socket, int level, int optname,\n\t\tvoid *optval, socklen_t *optlen)\n{\n\tint fd;\n\treturn (fd_get(socket, &fd) == fd_rsocket) ?\n\t\trgetsockopt(fd, level, optname, optval, optlen) :\n\t\treal.getsockopt(fd, level, optname, optval, optlen);\n}\n\nint fcntl(int socket, int cmd, ... /* arg */)\n{\n\tva_list args;\n\tlong lparam;\n\tvoid *pparam;\n\tint fd, ret;\n\n\tinit_preload();\n\tva_start(args, cmd);\n\tswitch (cmd) {\n\tcase F_GETFD:\n\tcase F_GETFL:\n\tcase F_GETOWN:\n\tcase F_GETSIG:\n\tcase F_GETLEASE:\n\t\tret = (fd_get(socket, &fd) == fd_rsocket) ?\n\t\t\trfcntl(fd, cmd) : real.fcntl(fd, cmd);\n\t\tbreak;\n\tcase F_DUPFD:\n\t/*case F_DUPFD_CLOEXEC:*/\n\tcase F_SETFD:\n\tcase F_SETFL:\n\tcase F_SETOWN:\n\tcase F_SETSIG:\n\tcase F_SETLEASE:\n\tcase F_NOTIFY:\n\t\tlparam = va_arg(args, long);\n\t\tret = (fd_get(socket, &fd) == fd_rsocket) ?\n\t\t\trfcntl(fd, cmd, lparam) : real.fcntl(fd, cmd, lparam);\n\t\tbreak;\n\tdefault:\n\t\tpparam = va_arg(args, void *);\n\t\tret = (fd_get(socket, &fd) == fd_rsocket) ?\n\t\t\trfcntl(fd, cmd, pparam) : real.fcntl(fd, cmd, pparam);\n\t\tbreak;\n\t}\n\tva_end(args);\n\treturn ret;\n}\n\n/*\n * dup2 is not thread safe\n */\nint dup2(int oldfd, int newfd)\n{\n\tstruct fd_info *oldfdi, *newfdi;\n\tint ret;\n\n\tinit_preload();\n\toldfdi = idm_lookup(&idm, oldfd);\n\tif (oldfdi) {\n\t\tif (oldfdi->state == fd_fork_passive)\n\t\t\tfork_passive(oldfd);\n\t\telse if (oldfdi->state == fd_fork_active)\n\t\t\tfork_active(oldfd);\n\t}\n\n\tnewfdi = idm_lookup(&idm, newfd);\n\tif (newfdi) {\n\t\t /* newfd cannot have been dup'ed directly */\n\t\tif (atomic_load(&newfdi->refcnt) > 1)\n\t\t\treturn ERR(EBUSY);\n\t\tclose(newfd);\n\t}\n\n\tret = real.dup2(oldfd, newfd);\n\tif (!oldfdi || ret != newfd)\n\t\treturn ret;\n\n\tnewfdi = calloc(1, sizeof(*newfdi));\n\tif (!newfdi) {\n\t\tclose(newfd);\n\t\treturn ERR(ENOMEM);\n\t}\n\n\tpthread_mutex_lock(&mut);\n\tidm_set(&idm, newfd, newfdi);\n\tpthread_mutex_unlock(&mut);\n\n\tnewfdi->fd = oldfdi->fd;\n\tnewfdi->type = oldfdi->type;\n\tif (oldfdi->dupfd != -1) {\n\t\tnewfdi->dupfd = oldfdi->dupfd;\n\t\toldfdi = idm_lookup(&idm, oldfdi->dupfd);\n\t} else {\n\t\tnewfdi->dupfd = oldfd;\n\t}\n\tatomic_store(&newfdi->refcnt, 1);\n\tatomic_fetch_add(&oldfdi->refcnt, 1);\n\treturn newfd;\n}\n\nssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count)\n{\n\tvoid *file_addr;\n\tint fd;\n\tsize_t ret;\n\n\tif (fd_get(out_fd, &fd) != fd_rsocket)\n\t\treturn real.sendfile(fd, in_fd, offset, count);\n\n\tfile_addr = mmap(NULL, count, PROT_READ, 0, in_fd, offset ? *offset : 0);\n\tif (file_addr == (void *) -1)\n\t\treturn -1;\n\n\tret = rwrite(fd, file_addr, count);\n\tif ((ret > 0) && offset)\n\t\tlseek(in_fd, ret, SEEK_CUR);\n\tmunmap(file_addr, count);\n\treturn ret;\n}\n\nint __fxstat(int ver, int socket, struct stat *buf)\n{\n\tint fd, ret;\n\n\tinit_preload();\n\tif (fd_get(socket, &fd) == fd_rsocket) {\n\t\tret = real.fxstat(ver, socket, buf);\n\t\tif (!ret)\n\t\t\tbuf->st_mode = (buf->st_mode & ~S_IFMT) | S_IFSOCK;\n\t} else {\n\t\tret = real.fxstat(ver, fd, buf);\n\t}\n\treturn ret;\n}\n"
    },
    "skipped": [],
    "total_files": 1016
}