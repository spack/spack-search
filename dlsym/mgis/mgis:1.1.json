{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mgis-1.1-vugw57n2jmqfrh5ullkaq4v5imsbanfb/spack-src/src/LibrariesManager.cxx": "/*!\n * \\file   LibrariesManager.cxx\n * \\brief\n * \\author Thomas Helfer\n * \\date   19/06/2018\n * \\copyright (C) Copyright Thomas Helfer 2018.\n * Use, modification and distribution are subject\n * to one of the following licences:\n * - GNU Lesser General Public License (LGPL), Version 3.0. (See accompanying\n *   file LGPL-3.0.txt)\n * - CECILL-C,  Version 1.0 (See accompanying files\n *   CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt).\n */\n\n#include <cctype>\n#include <cstring>\n#include <iterator>\n#include <algorithm>\n#if !((defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__))\n#include <dlfcn.h>\n#endif /* !((defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)) */\n\n#include \"MGIS/LibrariesManager.hxx\"\n#include \"MGIS/Raise.hxx\"\n\nnamespace mgis {\n\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n  // code retrieved from\n  // http://www.codeproject.com/Tips/479880/GetLastError-as-std-string\n  static std::string getLastWin32Error() {\n    const DWORD error = GetLastError();\n    if (error) {\n      LPVOID lpMsgBuf;\n      DWORD bufLen = FormatMessage(\n          FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |\n              FORMAT_MESSAGE_IGNORE_INSERTS,\n          nullptr, error, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n          (LPTSTR)&lpMsgBuf, 0, nullptr);\n      if (bufLen) {\n        LPCSTR lpMsgStr = (LPTSTR)lpMsgBuf;\n        std::string result(lpMsgStr, lpMsgStr + bufLen);\n        LocalFree(lpMsgBuf);\n        return result;\n      }\n    }\n    return std::string();\n  }\n#endif /*  (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n\n  static std::string getErrorMessage() {\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n    return getLastWin32Error();\n#else\n    const auto e = ::dlerror();\n    if (e != nullptr) {\n      return std::string(e);\n    }\n    return \"\";\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n  }    // end of  getErrorMessage\n\n  static LibrariesManager::libhandler load_library(const std::string &l) {\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n    return ::LoadLibrary(TEXT(l.c_str()));\n#else\n    return ::dlopen(l.c_str(), RTLD_NOW);\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n  }    // end of load_library\n\n  static std::pair<LibrariesManager::libhandler, std::string> try_open(\n      const std::string &l) {\n    auto starts_with = [](const std::string &s1, const char *const s2) {\n      const auto ls2 = std::strlen(s2);\n      return ((s1.size() >= ls2) && (std::equal(s2, s2 + ls2, s1.begin())));\n    };  // end of starts_with\n    auto ends_with = [](const std::string &s1, const char *const s2) {\n      const auto ls2 = std::strlen(s2);\n      if (!(s1.size() >= ls2)) {\n        return false;\n      }\n      return std::equal(s2, s2 + ls2, s1.begin() + (s1.size() - ls2));\n    };  // end of ends_with\n#if (defined(macintosh) || defined(Macintosh) || \\\n     (defined(__APPLE__) && defined(__MACH__)))\n    const char *const ext = \".dylib\";\n#elif (defined(_WIN32) || defined(_WIN64) || defined(__CYGWIN__))\n    const char *const ext = \".dll\";\n#else\n    const char *const ext = \".so\";\n#endif\n    auto ln = l;\n    auto lib = load_library(l);\n#if defined(__CYGWIN__)\n    if ((lib == nullptr) && (!starts_with(l, \"cyg\"))) {\n      ln = \"cyg\" + l;\n      lib = load_library(ln);\n      if (lib == nullptr) {\n        if (!ends_with(l, ext)) {\n          ln = \"cyg\" + l + ext;\n          lib = load_library(ln);\n        }\n      }\n    }\n#endif\n#if !(defined(_WIN32) || defined(_WIN64))\n    if ((lib == nullptr) && (!starts_with(l, \"lib\"))) {\n      ln = \"lib\" + l;\n      lib = load_library(ln);\n      if (lib == nullptr) {\n        if (!ends_with(l, ext)) {\n          ln = \"lib\" + l + ext;\n          lib = load_library(ln);\n        }\n      }\n    }\n#endif\n    if ((lib == nullptr) && (!ends_with(l, ext))) {\n      ln = l + ext;\n      lib = load_library(ln);\n    }\n    // retrieving the initial error message\n    if (lib == nullptr) {\n      ln = l;\n      lib = load_library(ln);\n    }\n    return {lib, ln};\n  }  // end of try_open\n\n  static std::string decomposeVariableName(const std::string &n) {\n    auto throw_if = [](const bool c, const std::string &m) {\n      mgis::raise_if(c, \"mgis::decomposeVariableName: \" + m);\n    };\n    auto p = n.cbegin();\n    auto pe = n.cend();\n    while ((p != pe) && (*p != '[')) {\n      ++p;\n    }\n    if (p == pe) {\n      return n;\n    }\n    auto r = std::string{n.cbegin(), p};\n    ++p;\n    throw_if(p == pe, \"unexpected end of string 'n'\");\n    throw_if(!std::isdigit(*p), \"unexpected a digit 'n'\");\n    r += \"__\";\n    while ((p != pe) && (std::isdigit(*p))) {\n      r.push_back(*p);\n      ++p;\n    }\n    throw_if(p == pe, \"unexpected end of string '\" + n + \"'\");\n    throw_if(*p != ']', \"invalid variable name '\" + n + \"'\");\n    ++p;\n    throw_if(p != pe, \"invalid variable name '\" + n + \"'\");\n    r += \"__\";\n    return r;\n  }  // end of decomposeVariableName\n\n  LibrariesManager &LibrariesManager::get() {\n    static LibrariesManager lm;\n    return lm;\n  }  // end of LibrariesManager::get\n\n  LibrariesManager::LibrariesManager() = default;\n\n  mgis::behaviour::BehaviourFctPtr LibrariesManager::getBehaviour(\n      const std::string &l, const std::string &b, const Hypothesis h) {\n    const auto hn = toString(h);\n    const auto p = this->getSymbolAddress(l, b + \"_\" + hn);\n    if (p == nullptr) {\n      mgis::raise(\n          \"LibrariesManager::getBehaviour: \"\n          \"can't load behaviour '\" +\n          b + \"' in library '\" + l + \"' for hypothesis '\" + hn + \"'\");\n    }\n    return reinterpret_cast<mgis::behaviour::BehaviourFctPtr>(p);\n  }  // end of LibrariesManager::getBehaviour\n\n  std::string LibrariesManager::getTFELVersion(const std::string &l,\n                                               const std::string &n) {\n    const auto p = this->getSymbolAddress(l, n + \"_tfel_version\");\n    if (p == nullptr) {\n      return \"\";\n    }\n    return *(static_cast<const char *const *>(p));\n  }  // end of LibrariesManager::getTFELVersion\n\n  unsigned short LibrariesManager::getMaterialKnowledgeType(\n      const std::string &l, const std::string &b) {\n    return *(this->extract<unsigned short>(l, b + \"_mfront_mkt\"));\n  }  // end of LibrariesManager::getMaterialKnowledgeType\n\n  std::string LibrariesManager::getSource(const std::string &l,\n                                          const std::string &n) {\n    const auto p = this->getSymbolAddress(l, n + \"_src\");\n    if (p == nullptr) {\n      return \"\";\n    }\n    return *(static_cast<const char *const *>(p));\n  }  // end of LibrariesManager::getSource\n\n  std::string LibrariesManager::getInterface(const std::string &l,\n                                             const std::string &n) {\n    const auto p = this->getSymbolAddress(l, n + \"_mfront_interface\");\n    if (p == nullptr) {\n      return \"\";\n    }\n    return *(static_cast<const char *const *>(p));\n  }  // end of LibrariesManager::getInterface\n\n  unsigned short LibrariesManager::getBehaviourType(const std::string &l,\n                                                    const std::string &b) {\n    return *(this->extract<unsigned short>(l, b + \"_BehaviourType\"));\n  }  // end of LibrariesManager::getBehaviourType\n\n  unsigned short LibrariesManager::getBehaviourKinematic(const std::string &l,\n                                                         const std::string &b) {\n    return *(this->extract<unsigned short>(l, b + \"_BehaviourKinematic\"));\n  }  // end of LibrariesManager::getBehaviourKinematic\n\n  unsigned short LibrariesManager::getBehaviourSymmetry(const std::string &l,\n                                                        const std::string &b) {\n    return *(this->extract<unsigned short>(l, b + \"_SymmetryType\"));\n  }  // end of LibrariesManager::getBehaviourSymmetry\n\n  unsigned short LibrariesManager::getElasticStiffnessSymmetry(\n      const std::string &l, const std::string &b) {\n    return *(this->extract<unsigned short>(l, b + \"_ElasticSymmetryType\"));\n  }  // end of LibrariesManager::getElasticStiffnessSymmetry\n\n  bool LibrariesManager::requiresStiffnessTensor(const std::string &l,\n                                                 const std::string &b,\n                                                 const Hypothesis h) {\n    const auto sn = \"_requiresStiffnessTensor\";\n    const auto bv =\n        *(this->extract<unsigned short>(l, b + \"_\" + toString(h) + sn, b + sn));\n    return bv == 1 ? true : false;\n  }  // end of LibrariesManager::requiresStiffnessTensor\n\n  bool LibrariesManager::requiresThermalExpansionCoefficientTensor(\n      const std::string &l, const std::string &b, const Hypothesis h) {\n    const auto sn = \"_requiresThermalExpansionCoefficientTensor\";\n    const auto bv =\n        *(this->extract<unsigned short>(l, b + \"_\" + toString(h) + sn, b + sn));\n    return bv == 1 ? true : false;\n  }  // end of LibrariesManager::requiresThermalExpansionCoefficientTensor\n\n  template <typename T>\n  const T *LibrariesManager::extract(const std::string &l,\n                                     const std::string &n) {\n    const auto p = this->getSymbolAddress(l, n);\n    if (p == nullptr) {\n      raise(\"LibrariesManager::extract: could not load symbol '\" + n + \"'\");\n    }\n    return static_cast<const T *const>(p);\n  }  // end of LibrariesManager::extract\n\n  template <typename T>\n  const T *LibrariesManager::extract(const std::string &l,\n                                     const std::string &n1,\n                                     const std::string &n2) {\n    const auto p = this->getSymbolAddress(l, n1, n2);\n    if (p == nullptr) {\n      raise(\"LibrariesManager::extract: could not load symbol '\" + n1 +\n            \"' nor '\" + n2 + \"'\");\n    }\n    return static_cast<const T *const>(p);\n  }  // end of LibrariesManager::extract\n\n  std::vector<std::string> LibrariesManager::getNames(const std::string &l,\n                                                      const std::string &f,\n                                                      const Hypothesis h,\n                                                      const std::string &n) {\n    std::vector<std::string> vars;\n    const auto hn = toString(h);\n    const auto nb = *(this->extract<unsigned short>(l, f + \"_\" + hn + \"_n\" + n,\n                                                    f + \"_n\" + n));\n    const auto res = this->extract<const char *const>(l, f + \"_\" + hn + '_' + n,\n                                                      f + '_' + n);\n    std::copy(res, res + nb, std::back_inserter(vars));\n    return vars;\n  }  // end of LibrariesManager::getNames\n\n  std::vector<std::string> LibrariesManager::getGradientsNames(\n      const std::string &l, const std::string &b, const Hypothesis h) {\n    return this->getNames(l, b, h, \"Gradients\");\n  }  // end of LibrariesManager::getGradientsNames\n\n  std::vector<int> LibrariesManager::getGradientsTypes(const std::string &l,\n                                                       const std::string &b,\n                                                       const Hypothesis h) {\n    std::vector<int> types;\n    const auto hn = toString(h);\n    const auto nb = *(this->extract<unsigned short>(\n        l, b + \"_\" + hn + \"_nGradients\", b + \"_nGradients\"));\n    const auto res = this->extract<const int>(\n        l, b + \"_\" + hn + \"_GradientsTypes\", b + \"_GradientsTypes\");\n    std::copy(res, res + nb, std::back_inserter(types));\n    return types;\n  }  // end of LibrariesManager::getGradientsTypes\n\n  std::vector<std::string> LibrariesManager::getThermodynamicForcesNames(\n      const std::string &l, const std::string &b, const Hypothesis h) {\n    return this->getNames(l, b, h, \"ThermodynamicForces\");\n  }  // end of LibrariesManager::getThermodynamicForcesNames\n\n  std::vector<int> LibrariesManager::getThermodynamicForcesTypes(\n      const std::string &l, const std::string &b, const Hypothesis h) {\n    std::vector<int> types;\n    const auto hn = toString(h);\n    const auto nb = *(\n        this->extract<unsigned short>(l, b + \"_\" + hn + \"_nThermodynamicForces\",\n                                      b + \"_nThermodynamicForces\"));\n    const auto res =\n        this->extract<const int>(l, b + \"_\" + hn + \"_ThermodynamicForcesTypes\",\n                                 b + \"_ThermodynamicForcesTypes\");\n    std::copy(res, res + nb, std::back_inserter(types));\n    return types;\n  }  // end of LibrariesManager::getThermodynamicForcesTypes\n\n  std::vector<std::pair<std::string, std::string>>\n  LibrariesManager::getTangentOperatorBlocksNames(const std::string &l,\n                                                  const std::string &b,\n                                                  const Hypothesis h) {\n    std::vector<std::pair<std::string, std::string>> blocks;\n    const auto names = this->getNames(l, b, h, \"TangentOperatorBlocks\");\n    const auto s = names.size();\n    mgis::raise_if(\n        s % 2 != 0,\n        \"LibrariesManager::getTangentOperatorBlocksNames: \"\n        \"invalid declaration of the tangent operator blocks is invalid\");\n    for (decltype(names.size()) i = 0; i != s / 2; ++i) {\n      blocks.push_back({names[2 * i], names[2 * i + 1]});\n    }\n    return blocks;\n  }  // end of LibrariesManager::getTangentOperatorBlocksNames\n\n  std::vector<std::string> LibrariesManager::getMaterialPropertiesNames(\n      const std::string &l, const std::string &b, const Hypothesis h) {\n    return this->getNames(l, b, h, \"MaterialProperties\");\n  }  // end of LibrariesManager::getMaterialPropertiesNames\n\n  std::vector<std::string> LibrariesManager::getInternalStateVariablesNames(\n      const std::string &l, const std::string &b, const Hypothesis h) {\n    return this->getNames(l, b, h, \"InternalStateVariables\");\n  }  // end of LibrariesManager::getInternalStateVariablesNames\n\n  std::vector<int> LibrariesManager::getInternalStateVariablesTypes(\n      const std::string &l, const std::string &b, const Hypothesis h) {\n    std::vector<int> types;\n    const auto hn = toString(h);\n    const auto nb = *(this->extract<unsigned short>(\n        l, b + \"_\" + hn + \"_nInternalStateVariables\",\n        b + \"_nInternalStateVariables\"));\n    const auto res = this->extract<const int>(\n        l, b + \"_\" + hn + \"_InternalStateVariablesTypes\",\n        b + \"_InternalStateVariablesTypes\");\n    std::copy(res, res + nb, std::back_inserter(types));\n    return types;\n  }  // end of LibrariesManager::getInternalStateVariablesTypes\n\n  std::vector<std::string> LibrariesManager::getExternalStateVariablesNames(\n      const std::string &l, const std::string &b, const Hypothesis h) {\n    return this->getNames(l, b, h, \"ExternalStateVariables\");\n  }  // end of LibrariesManager::getMaterialPropertiesNames\n\n  bool LibrariesManager::contains(const std::string &l, const std::string &n) {\n    return this->getSymbolAddress(l, n) != nullptr;\n  }  // end of LibrariesManager::contains\n\n  void *LibrariesManager::getSymbolAddress(const std::string &l,\n                                           const std::string &n) {\n    auto lib = this->loadLibrary(l);\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n    return reinterpret_cast<void*>(::GetProcAddress(lib, n.c_str()));\n#else  /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)*/\n    return ::dlsym(lib, n.c_str());\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n  }    // end of getSymbolAddress\n\n  void *LibrariesManager::getSymbolAddress(const std::string &l,\n                                           const std::string &n1,\n                                           const std::string &n2) {\n    const auto p = this->getSymbolAddress(l, n1);\n    if (p == nullptr) {\n      return this->getSymbolAddress(l, n2);\n    }\n    return p;\n  }  // end of getSymbolAddress\n\n  LibrariesManager::libhandler LibrariesManager::loadLibrary(\n      const std::string &l) {\n    auto p = this->libraries.find(l);\n    if (p == this->libraries.end()) {\n      // this library has not been\n      auto r = try_open(l);\n      auto lib = r.first;\n      if (lib == nullptr) {\n        raise(\n            \"LibrariesManager::loadLibrary:\"\n            \" library '\" +\n            l +\n            \"' could not be loaded, \"\n            \"(\" +\n            getErrorMessage() + \")\");\n      }\n      this->libraries.insert({l, lib});\n      return lib;\n    }\n    return p->second;\n  }  // end of LibrariesManager::loadLibrary\n\n  void LibrariesManager::setParameter(const std::string &l,\n                                      const std::string &b,\n                                      const Hypothesis h,\n                                      const std::string &p,\n                                      const double v) {\n    using fct_ptr_type = int (*)(const char *const, const double);\n    const auto hn = toString(h);\n    const auto ptr = getSymbolAddress(l, b + \"_\" + hn + \"_setParameter\",\n                                      b + \"_setParameter\");\n    if (ptr == nullptr) {\n      mgis::raise(\n          \"LibrariesManager::setParameter: \"\n          \"can't get the '\" +\n          b + \"_setParameter' function (\" + getErrorMessage() + \")\");\n    }\n    const auto fct = reinterpret_cast<fct_ptr_type>(ptr);\n    if (!fct(p.c_str(), v)) {\n      mgis::raise(\n          \"LibrariesManager::setParameter: \"\n          \"call to the '\" +\n          b + \"_setParameter' function failed\");\n    }\n  }  // end of LibrariesManager::setParameter\n\n  void LibrariesManager::setParameter(const std::string &l,\n                                      const std::string &b,\n                                      const Hypothesis h,\n                                      const std::string &p,\n                                      const int v) {\n    using fct_ptr_type = int (*)(const char *const, const int);\n    const auto hn = toString(h);\n    const auto ptr = getSymbolAddress(l, b + \"_\" + hn + \"_setIntegerParameter\",\n                                      b + \"_setIntegerParameter\");\n    if (ptr == nullptr) {\n      mgis::raise(\n          \"LibrariesManager::setParameter: \"\n          \"can't get the '\" +\n          b + \"_setParameter' function (\" + getErrorMessage() + \")\");\n    }\n    const auto fct = reinterpret_cast<fct_ptr_type>(ptr);\n    if (!fct(p.c_str(), v)) {\n      mgis::raise(\n          \"LibrariesManager::setParameter: \"\n          \"call to the '\" +\n          b + \"_setParameter' function failed\");\n    }\n  }  // end of LibrariesManager::setParameter\n\n  void LibrariesManager::setParameter(const std::string &l,\n                                      const std::string &b,\n                                      const Hypothesis h,\n                                      const std::string &p,\n                                      const unsigned short v) {\n    using fct_ptr_type = int (*)(const char *const, const unsigned short);\n    const auto hn = toString(h);\n    const auto ptr =\n        getSymbolAddress(l, b + \"_\" + hn + \"_setUnsignedShortParameter\",\n                         b + \"_setUnsignedShortParameter\");\n    if (ptr == nullptr) {\n      mgis::raise(\n          \"LibrariesManager::setParameter: \"\n          \"can't get the '\" +\n          b + \"_setParameter' function (\" + getErrorMessage() + \")\");\n    }\n    const auto fct = reinterpret_cast<fct_ptr_type>(ptr);\n    if (!fct(p.c_str(), v)) {\n      mgis::raise(\n          \"LibrariesManager::setParameter: \"\n          \"call to the '\" +\n          b + \"_setParameter' function failed\");\n    }\n  }  // end of LibrariesManager::setParameter\n\n  std::vector<std::string> LibrariesManager::getParametersNames(\n      const std::string &l, const std::string &b, const Hypothesis h) {\n    return this->getNames(l, b, h, \"Parameters\");\n  }  // end of LibrariesManager::getMaterialPropertiesNames\n\n  std::vector<int> LibrariesManager::getParametersTypes(const std::string &l,\n                                                        const std::string &b,\n                                                        const Hypothesis h) {\n    std::vector<int> types;\n    const auto hn = toString(h);\n    const auto nb = *(this->extract<unsigned short>(\n        l, b + \"_\" + hn + \"_nParameters\", b + \"_nParameters\"));\n    const auto res = this->extract<const int>(\n        l, b + \"_\" + hn + \"_ParametersTypes\", b + \"_ParametersTypes\");\n    std::copy(res, res + nb, std::back_inserter(types));\n    return types;\n  }  // end of LibrariesManager::getInternalVariablesTypes\n\n  double LibrariesManager::getParameterDefaultValue(const std::string &l,\n                                                    const std::string &b,\n                                                    const Hypothesis h,\n                                                    const std::string &p) {\n    const auto pn = decomposeVariableName(p);\n    const auto hn = toString(h);\n    return *(this->extract<double>(\n        l, b + \"_\" + hn + \"_\" + pn + \"_ParameterDefaultValue\",\n        b + \"_\" + pn + \"_ParameterDefaultValue\"));\n  }  // end of LibrariesManager::getParameterDefaultValue\n\n  int LibrariesManager::getIntegerParameterDefaultValue(const std::string &l,\n                                                        const std::string &b,\n                                                        const Hypothesis h,\n                                                        const std::string &p) {\n    const auto pn = decomposeVariableName(p);\n    const auto hn = toString(h);\n    return *(this->extract<int>(\n        l, b + \"_\" + hn + \"_\" + pn + \"_ParameterDefaultValue\",\n        b + \"_\" + pn + \"_ParameterDefaultValue\"));\n  }  // end of LibrariesManager::getIntegerParameterDefaultValue\n\n  unsigned short LibrariesManager::getUnsignedShortParameterDefaultValue(\n      const std::string &l,\n      const std::string &b,\n      const Hypothesis h,\n      const std::string &p) {\n    const auto pn = decomposeVariableName(p);\n    const auto hn = toString(h);\n    return *(this->extract<unsigned short>(\n        l, b + \"_\" + hn + \"_\" + pn + \"_ParameterDefaultValue\",\n        b + \"_\" + pn + \"_ParameterDefaultValue\"));\n  }  // end of LibrariesManager::getUnsignedShortParameterDefaultValue\n\n  bool LibrariesManager::hasBounds(const std::string &l,\n                                   const std::string &b,\n                                   const Hypothesis h,\n                                   const std::string &n) {\n    const auto hn = toString(h);\n    const auto vn = decomposeVariableName(n);\n    const auto n1 = b + \"_\" + hn + \"_\" + vn + \"_LowerBound\";\n    const auto n2 = b + \"_\" + hn + \"_\" + vn + \"_UpperBound\";\n    const auto n3 = b + \"_\" + vn + \"_LowerBound\";\n    const auto n4 = b + \"_\" + vn + \"_UpperBound\";\n    return ((this->contains(l, n1)) || (this->contains(l, n2)) ||\n            (this->contains(l, n3)) || (this->contains(l, n4)));\n  }  // end of LibrariesManager::hasBounds\n\n  bool LibrariesManager::hasLowerBound(const std::string &l,\n                                       const std::string &b,\n                                       const Hypothesis h,\n                                       const std::string &n) {\n    const auto hn = toString(h);\n    const auto vn = decomposeVariableName(n);\n    const auto n1 = b + \"_\" + hn + \"_\" + vn + \"_LowerBound\";\n    const auto n2 = b + \"_\" + vn + \"_LowerBound\";\n    return ((this->contains(l, n1)) || (this->contains(l, n2)));\n  }  // end of LibrariesManager::hasLowerBound\n\n  bool LibrariesManager::hasUpperBound(const std::string &l,\n                                       const std::string &b,\n                                       const Hypothesis h,\n                                       const std::string &n) {\n    const auto hn = toString(h);\n    const auto vn = decomposeVariableName(n);\n    const auto n1 = b + \"_\" + hn + \"_\" + vn + \"_UpperBound\";\n    const auto n2 = b + \"_\" + vn + \"_UpperBound\";\n    return ((this->contains(l, n1)) || (this->contains(l, n2)));\n  }  // end of LibrariesManager::hasUpperBound\n\n  long double LibrariesManager::getLowerBound(const std::string &l,\n                                              const std::string &b,\n                                              const Hypothesis h,\n                                              const std::string &n) {\n    const auto hn = toString(h);\n    const auto vn = decomposeVariableName(n);\n    const auto n1 = b + \"_\" + hn + \"_\" + vn + \"_LowerBound\";\n    const auto n2 = b + \"_\" + vn + \"_LowerBound\";\n    return *(this->extract<long double>(l, n1, n2));\n  }  // end of LibrariesManager::getLowerBound\n\n  long double LibrariesManager::getUpperBound(const std::string &l,\n                                              const std::string &b,\n                                              const Hypothesis h,\n                                              const std::string &n) {\n    const auto hn = toString(h);\n    const auto vn = decomposeVariableName(n);\n    const auto n1 = b + \"_\" + hn + \"_\" + vn + \"_UpperBound\";\n    const auto n2 = b + \"_\" + vn + \"_UpperBound\";\n    return *(this->extract<long double>(l, n1, n2));\n  }  // end of LibrariesManager::getUpperBound\n\n  bool LibrariesManager::hasPhysicalBounds(const std::string &l,\n                                           const std::string &b,\n                                           const Hypothesis h,\n                                           const std::string &n) {\n    const auto hn = toString(h);\n    const auto vn = decomposeVariableName(n);\n    const auto n1 = b + \"_\" + hn + \"_\" + vn + \"_LowerPhysicalBound\";\n    const auto n2 = b + \"_\" + hn + \"_\" + vn + \"_UpperPhysicalBound\";\n    const auto n3 = b + \"_\" + vn + \"_LowerPhysicalBound\";\n    const auto n4 = b + \"_\" + vn + \"_UpperPhysicalBound\";\n    return ((this->contains(l, n1)) || (this->contains(l, n2)) ||\n            (this->contains(l, n3)) || (this->contains(l, n4)));\n  }  // end of LibrariesManager::hasPhysicalBounds\n\n  bool LibrariesManager::hasLowerPhysicalBound(const std::string &l,\n                                               const std::string &b,\n                                               const Hypothesis h,\n                                               const std::string &n) {\n    const auto hn = toString(h);\n    const auto vn = decomposeVariableName(n);\n    const auto n1 = b + \"_\" + hn + \"_\" + vn + \"_LowerPhysicalBound\";\n    const auto n2 = b + \"_\" + vn + \"_LowerPhysicalBound\";\n    return ((this->contains(l, n1)) || (this->contains(l, n2)));\n  }  // end of LibrariesManager::hasLowerPhysicalBound\n\n  bool LibrariesManager::hasUpperPhysicalBound(const std::string &l,\n                                               const std::string &b,\n                                               const Hypothesis h,\n                                               const std::string &n) {\n    const auto hn = toString(h);\n    const auto vn = decomposeVariableName(n);\n    const auto n1 = b + \"_\" + hn + \"_\" + vn + \"_UpperPhysicalBound\";\n    const auto n2 = b + \"_\" + vn + \"_UpperPhysicalBound\";\n    return ((this->contains(l, n1)) || (this->contains(l, n2)));\n  }  // end of LibrariesManager::hasUpperPhysicalBound\n\n  long double LibrariesManager::getLowerPhysicalBound(const std::string &l,\n                                                      const std::string &b,\n                                                      const Hypothesis h,\n                                                      const std::string &n) {\n    const auto hn = toString(h);\n    const auto vn = decomposeVariableName(n);\n    const auto n1 = b + \"_\" + hn + \"_\" + vn + \"_LowerPhysicalBound\";\n    const auto n2 = b + \"_\" + vn + \"_LowerPhysicalBound\";\n    return *(this->extract<long double>(l, n1, n2));\n  }  // end of LibrariesManager::getLowerPhysicalBound\n\n  long double LibrariesManager::getUpperPhysicalBound(const std::string &l,\n                                                      const std::string &b,\n                                                      const Hypothesis h,\n                                                      const std::string &n) {\n    const auto hn = toString(h);\n    const auto vn = decomposeVariableName(n);\n    const auto n1 = b + \"_\" + hn + \"_\" + vn + \"_UpperPhysicalBound\";\n    const auto n2 = b + \"_\" + vn + \"_UpperPhysicalBound\";\n    return *(this->extract<long double>(l, n1, n2));\n  }  // end of LibrariesManager::getUpperPhysicalBound\n\n  LibrariesManager::~LibrariesManager() {\n    for (const auto &l : this->libraries) {\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n      ::FreeLibrary(l.second);\n#else  /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n      ::dlclose(l.second);\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n    }\n  }  // end of LibrariesManager::~LibrariesManager\n\n}  // namespace mgis\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mgis-1.1-vugw57n2jmqfrh5ullkaq4v5imsbanfb/spack-src/docs/papers/joss/img/MFrontInterface.png",
        "/tmp/vanessa/spack-stage/spack-stage-mgis-1.1-vugw57n2jmqfrh5ullkaq4v5imsbanfb/spack-src/docs/papers/joss/img/3dbeam_mfront.png",
        "/tmp/vanessa/spack-stage/spack-stage-mgis-1.1-vugw57n2jmqfrh5ullkaq4v5imsbanfb/spack-src/docs/papers/joss/img/FEniCS.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-mgis-1.1-vugw57n2jmqfrh5ullkaq4v5imsbanfb/spack-src/docs/papers/joss/img/FEniCS.png",
        "/tmp/vanessa/spack-stage/spack-stage-mgis-1.1-vugw57n2jmqfrh5ullkaq4v5imsbanfb/spack-src/docs/papers/joss/img/MCAS_disc_hole_cyclic_show_axes.png"
    ],
    "total_files": 256
}