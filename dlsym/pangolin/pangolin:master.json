{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-pangolin-master-kxuufbav5nfnbfwzts5ahuxu7lpnjks3/spack-src/src/display/device/display_android.cpp": "/* This file is part of the Pangolin Project.\n * http://github.com/stevenlovegrove/Pangolin\n *\n * Copyright (c) 2013 Steven Lovegrove\n *\n * Based largely on android_native_app_glue.c from Android NDK\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <pangolin/factory/factory_registry.h>\n#include <pangolin/gl/glinclude.h>\n#include <pangolin/display/display.h>\n#include <pangolin/display/display_internal.h>\n#include <pangolin/display/device/display_android.h>\n\n#include <poll.h>\n#include <pthread.h>\n#include <sched.h>\n#include <errno.h>\n#include <dlfcn.h>\n\n#include <android/configuration.h>\n#include <android/looper.h>\n#include <android/native_activity.h>\n#include <android/sensor.h>\n#include <android/log.h>\n#include <android/window.h>\n\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <stdexcept>\n\n#include <jni.h>\n\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/resource.h>\n\nnamespace pangolin\n{\n\nextern __thread PangolinGl* context;\n\n/**\n * Shared state for our app.\n */\nstruct engine {\n    android_app* app;\n    ANativeActivity* activity;\n    \n    int has_focus;\n    EGLDisplay display;\n    EGLSurface surface;\n    EGLContext context;\n    int32_t width;\n    int32_t height;\n//    struct saved_state state;\n};\n\n/**\n * Initialize an EGL context for the current display.\n */\nstatic int engine_init_display(struct engine* engine) {\n    // initialize OpenGL ES and EGL\n\n    /*\n     * Here specify the attributes of the desired configuration.\n     * Below, we select an EGLConfig with at least 8 bits per color\n     * component compatible with on-screen windows\n     */\n    const EGLint attribs[] = {\n            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,\n            EGL_BLUE_SIZE, 8,\n            EGL_GREEN_SIZE, 8,\n            EGL_RED_SIZE, 8,\n            EGL_NONE\n    };\n    EGLint w, h, format;\n    EGLint numConfigs;\n    EGLConfig config;\n    EGLSurface surface;\n    EGLContext context;\n\n    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);\n\n    eglInitialize(display, 0, 0);\n\n    /* Here, the application chooses the configuration it desires. In this\n     * sample, we have a very simplified selection process, where we pick\n     * the first EGLConfig that matches our criteria */\n    eglChooseConfig(display, attribs, &config, 1, &numConfigs);\n\n    /* EGL_NATIVE_VISUAL_ID is an attribute of the EGLConfig that is\n     * guaranteed to be accepted by ANativeWindow_setBuffersGeometry().\n     * As soon as we picked a EGLConfig, we can safely reconfigure the\n     * ANativeWindow buffers to match, using EGL_NATIVE_VISUAL_ID. */\n    eglGetConfigAttrib(display, config, EGL_NATIVE_VISUAL_ID, &format);\n\n    ANativeWindow_setBuffersGeometry(engine->app->window, 0, 0, format);\n//    ANativeActivity_setWindowFlags(engine->app->activity, AWINDOW_FLAG_FULLSCREEN, 0 );\n\n    EGLint const attrib_list[] = {\n#ifdef HAVE_GLES_2\n        EGL_CONTEXT_CLIENT_VERSION, 2,\n#endif\n        EGL_NONE\n    };\n\n    surface = eglCreateWindowSurface(display, config, engine->app->window, NULL);\n    context = eglCreateContext(display, config, NULL, attrib_list);\n\n    if (eglMakeCurrent(display, surface, surface, context) == EGL_FALSE) {\n        LOGW(\"Unable to eglMakeCurrent\");\n        return -1;\n    }\n\n    eglQuerySurface(display, surface, EGL_WIDTH, &w);\n    eglQuerySurface(display, surface, EGL_HEIGHT, &h);\n\n    engine->display = display;\n    engine->context = context;\n    engine->surface = surface;\n    engine->width = w;\n    engine->height = h;\n    \n    pangolin::process::Resize(engine->width,engine->height);\n\n    // Initialize GL state.\n    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);\n    glEnable(GL_CULL_FACE);\n    glShadeModel(GL_SMOOTH);\n    glDisable(GL_DEPTH_TEST);\n\n    return 0;\n}\n\n/**\n * Just the current frame in the display.\n */\nstatic void engine_draw_frame(struct engine* engine) {\n    if (engine->display != NULL) {\n    }\n}\n\n/**\n * Tear down the EGL context currently associated with the display.\n */\nstatic void engine_term_display(struct engine* engine) {\n    if (engine->display != EGL_NO_DISPLAY) {\n        eglMakeCurrent(engine->display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\n        if (engine->context != EGL_NO_CONTEXT) {\n            eglDestroyContext(engine->display, engine->context);\n        }\n        if (engine->surface != EGL_NO_SURFACE) {\n            eglDestroySurface(engine->display, engine->surface);\n        }\n        eglTerminate(engine->display);\n    }\n    engine->has_focus = 0;\n    engine->display = EGL_NO_DISPLAY;\n    engine->context = EGL_NO_CONTEXT;\n    engine->surface = EGL_NO_SURFACE;\n}\n\nvoid UnpressAll(float last_x, float last_y)\n{\n    if(context->mouse_state & pangolin::MouseButtonLeft) {\n        pangolin::process::Mouse(0, 1, last_x, last_y);\n    }\n    if(context->mouse_state & pangolin::MouseButtonMiddle) {\n        pangolin::process::Mouse(1, 1, last_x, last_y);\n    }\n    if(context->mouse_state & pangolin::MouseButtonRight) {\n        pangolin::process::Mouse(2, 1, last_x, last_y);\n    }\n    if(context->mouse_state & pangolin::MouseWheelUp) {\n        pangolin::process::Mouse(3, 1, last_x, last_y);\n    }\n    if(context->mouse_state & pangolin::MouseWheelDown) {\n        pangolin::process::Mouse(4, 1, last_x, last_y);\n    }\n    context->mouse_state = 0;\n}\n\nint PangolinKeyFromAndroidKeycode(int32_t keycode, bool shift)\n{\n    if( AKEYCODE_0 <= keycode && keycode <= AKEYCODE_9) {\n        return '0' + (keycode - AKEYCODE_0);\n    }\n    \n    if( AKEYCODE_A <= keycode && keycode <= AKEYCODE_Z) {\n        return (shift ? 'A' : 'a') + (keycode - AKEYCODE_A);\n    }\n    \n    if(shift) {\n        switch (keycode) {\n        case AKEYCODE_GRAVE:     return '~';\n        default:\n            LOGI(\"Unknown keycode (with shift): %d\", keycode);\n            return '?';\n        }\n    }else{\n        switch (keycode) {\n        case AKEYCODE_COMMA:     return ',';\n        case AKEYCODE_PERIOD:    return '.';\n        case AKEYCODE_SPACE:     return ' ';\n        case AKEYCODE_ENTER:     return '\\r';\n        case AKEYCODE_TAB:       return '\\t';\n        case AKEYCODE_DEL:       return '\\b';\n        case AKEYCODE_SLASH:     return '/';\n        case AKEYCODE_BACKSLASH: return '\\\\';\n        case AKEYCODE_SEMICOLON: return ';';\n        case AKEYCODE_APOSTROPHE:return '\\'';\n        case AKEYCODE_MINUS:     return '-';\n        case AKEYCODE_EQUALS:    return '=';\n        case AKEYCODE_PLUS:      return '+';\n        case AKEYCODE_AT:        return '@';\n        case AKEYCODE_GRAVE:     return '`';\n        default:\n            LOGI(\"Unknown keycode: %d\", keycode);\n            return '?';\n        }\n    }\n}\n\n/**\n * Process the next input event.\n */\nstatic int32_t engine_handle_input(struct android_app* app, AInputEvent* event) {\n    struct engine* engine = (struct engine*)app->userData;\n\n    static float last_x = 0;\n    static float last_y = 0;\n\n    const int32_t input_type = AInputEvent_getType(event);\n    \n    if (input_type == AINPUT_EVENT_TYPE_MOTION) {\n        engine->has_focus = 1;        \n        \n\n        const float x = AMotionEvent_getX(event, 0);\n        const float y = AMotionEvent_getY(event, 0);\n        const int32_t actionAndPtr = AMotionEvent_getAction(event);\n        const int32_t action = AMOTION_EVENT_ACTION_MASK & actionAndPtr;\n//        const int32_t ptrindex = (AMOTION_EVENT_ACTION_POINTER_INDEX_MASK & actionAndPtr) >> AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;\n                \n        const size_t num_ptrs = AMotionEvent_getPointerCount(event);\n\n        switch(action)\n        {\n        case AMOTION_EVENT_ACTION_UP:\n        case AMOTION_EVENT_ACTION_POINTER_UP:\n            UnpressAll(last_x, last_y);\n            break;\n        case AMOTION_EVENT_ACTION_DOWN:\n        case AMOTION_EVENT_ACTION_POINTER_DOWN:\n            UnpressAll(last_x, last_y);\n            if(num_ptrs <=2) {\n                const int button = (num_ptrs==1) ? 0 : 2;\n                pangolin::process::Mouse(button, 0, x, y);\n            }\n            break;\n        case AMOTION_EVENT_ACTION_MOVE:\n            if(num_ptrs == 3) {\n                const double dx = x - last_x;\n                const double dy = y - last_y;\n                pangolin::process::Scroll(dx,dy);\n            }else{\n                pangolin::process::MouseMotion(x,y);\n            }\n            break;\n        default:\n            break;\n        }\n\n        last_x = x;\n        last_y = y;\n\n        return 1;\n    }else if(AINPUT_EVENT_TYPE_KEY) {\n        static bool shift = false;\n        \n        const int32_t action = AKeyEvent_getAction(event);\n        const int32_t keycode  = AKeyEvent_getKeyCode(event);\n        \n        if(keycode == AKEYCODE_SHIFT_LEFT) {\n            shift = (action == AKEY_EVENT_ACTION_DOWN);\n            return 1;\n        }\n        \n        unsigned char key = PangolinKeyFromAndroidKeycode(keycode, shift);\n        \n        if(action == AKEY_EVENT_ACTION_DOWN) {\n            pangolin::process::Keyboard(key, last_x, last_y);\n        }else{\n            pangolin::process::KeyboardUp(key, last_x, last_y);\n        }\n    }\n    return 1;\n}\n\n/**\n * Process the next main command.\n */\nstatic void engine_handle_cmd(struct android_app* app, int32_t cmd) {\n    struct engine* engine = (struct engine*)app->userData;\n    switch (cmd) {\n        case APP_CMD_SAVE_STATE:\n//            // The system has asked us to save our current state.  Do so.\n//            engine->app->savedState = malloc(sizeof(struct saved_state));\n//            *((struct saved_state*)engine->app->savedState) = engine->state;\n//            engine->app->savedStateSize = sizeof(struct saved_state);\n            break;\n        case APP_CMD_INIT_WINDOW:\n            // The window is being shown, get it ready.\n            if (engine->app->window != NULL) {\n                engine_init_display(engine);\n                engine_draw_frame(engine);\n            }\n            break;\n        case APP_CMD_TERM_WINDOW:\n            // The window is being hidden or closed, clean it up.\n            engine_term_display(engine);\n            break;\n        case APP_CMD_GAINED_FOCUS:\n            engine->has_focus = 1;            \n            break;\n        case APP_CMD_LOST_FOCUS:\n            engine->has_focus = 0;\n            break;\n    }\n}\n\n}\n\n// Define library entry point.\nextern \"C\" {\n\nJNIEnv* GetEnvAttachThread(JavaVM* vm)\n{\n    JNIEnv* env;\n    switch (vm->GetEnv((void**)&env, JNI_VERSION_1_6)) {\n    case JNI_OK:\n        break;\n    case JNI_EDETACHED:\n        if (vm->AttachCurrentThread(&env, NULL)!=0) {\n            LOGE(\"Could not attach current thread\");\n            throw std::runtime_error(\"Could not attach current thread\");\n        }\n        break;\n    case JNI_EVERSION:\n        LOGE(\"Invalid Java version\");\n        throw std::runtime_error(\"Invalid Java version\");\n    }\n    return env;\n}\n\n// https://groups.google.com/d/msg/android-ndk/Tk3g00wLKhk/TJQucoaE_asJ\nvoid displayKeyboard(android_app* app, bool pShow) {\n    jint lFlags = 0;\n    JNIEnv* env = GetEnvAttachThread(app->activity->vm);\n    if(env) {\n        // Retrieves NativeActivity. \n        jobject lNativeActivity = app->activity->clazz; \n        jclass ClassNativeActivity = env->GetObjectClass(lNativeActivity); \n    \n        // Retrieves Context.INPUT_METHOD_SERVICE. \n        jclass ClassContext = env->FindClass(\"android/content/Context\"); \n        jfieldID FieldINPUT_METHOD_SERVICE = env->GetStaticFieldID(ClassContext, \"INPUT_METHOD_SERVICE\", \"Ljava/lang/String;\"); \n        jobject INPUT_METHOD_SERVICE = env->GetStaticObjectField(ClassContext, FieldINPUT_METHOD_SERVICE); \n    //    jniCheck(INPUT_METHOD_SERVICE); \n    \n        // lInputMethodManager = getSystemService(Context.INPUT_METHOD_SERVICE). \n        jclass ClassInputMethodManager = env->FindClass( \"android/view/inputmethod/InputMethodManager\"); \n        jmethodID MethodGetSystemService = env->GetMethodID( ClassNativeActivity, \"getSystemService\",  \"(Ljava/lang/String;)Ljava/lang/Object;\"); \n        jobject lInputMethodManager = env->CallObjectMethod( lNativeActivity, MethodGetSystemService, INPUT_METHOD_SERVICE); \n    \n        // lDecorView = getWindow().getDecorView(). \n        jmethodID MethodGetWindow = env->GetMethodID( ClassNativeActivity, \"getWindow\",  \"()Landroid/view/Window;\"); \n        jobject lWindow = env->CallObjectMethod(lNativeActivity,  MethodGetWindow); \n        jclass ClassWindow = env->FindClass(  \"android/view/Window\"); \n        jmethodID MethodGetDecorView = env->GetMethodID( ClassWindow, \"getDecorView\", \"()Landroid/view/View;\"); \n        jobject lDecorView = env->CallObjectMethod(lWindow,  MethodGetDecorView); \n    \n        if (pShow) { \n            // Runs lInputMethodManager.showSoftInput(...). \n            jmethodID MethodShowSoftInput = env->GetMethodID( ClassInputMethodManager, \"showSoftInput\", \"(Landroid/view/View;I)Z\"); \n            /*jboolean lResult = */env->CallBooleanMethod( lInputMethodManager, MethodShowSoftInput, lDecorView, lFlags); \n        } else { \n            // Runs lWindow.getViewToken() \n            jclass ClassView = env->FindClass( \"android/view/View\"); \n            jmethodID MethodGetWindowToken = env->GetMethodID( ClassView, \"getWindowToken\", \"()Landroid/os/IBinder;\"); \n            jobject lBinder = env->CallObjectMethod(lDecorView, MethodGetWindowToken); \n    \n            // lInputMethodManager.hideSoftInput(...). \n            jmethodID MethodHideSoftInput = env->GetMethodID( ClassInputMethodManager, \"hideSoftInputFromWindow\", \"(Landroid/os/IBinder;I)Z\"); \n            /*jboolean lRes = */env->CallBooleanMethod( lInputMethodManager, MethodHideSoftInput, lBinder, lFlags); \n        } \n    \n        // Finished with the JVM. \n        app->activity->vm->DetachCurrentThread();\n    }\n}\n\npangolin::engine g_engine;\n\nstatic void free_saved_state(struct android_app* android_app) {\n    pthread_mutex_lock(&android_app->mutex);\n    if (android_app->savedState != NULL) {\n        free(android_app->savedState);\n        android_app->savedState = NULL;\n        android_app->savedStateSize = 0;\n    }\n    pthread_mutex_unlock(&android_app->mutex);\n}\n\nint8_t android_app_read_cmd(struct android_app* android_app) {\n    int8_t cmd;\n    if (read(android_app->msgread, &cmd, sizeof(cmd)) == sizeof(cmd)) {\n        switch (cmd) {\n            case APP_CMD_SAVE_STATE:\n                free_saved_state(android_app);\n                break;\n        }\n        return cmd;\n    } else {\n        LOGE(\"No data on command pipe!\");\n    }\n    return -1;\n}\n\nstatic void print_cur_config(struct android_app* android_app) {\n    char lang[2], country[2];\n    AConfiguration_getLanguage(android_app->config, lang);\n    AConfiguration_getCountry(android_app->config, country);\n\n    LOGV(\"Config: mcc=%d mnc=%d lang=%c%c cnt=%c%c orien=%d touch=%d dens=%d \"\n            \"keys=%d nav=%d keysHid=%d navHid=%d sdk=%d size=%d long=%d \"\n            \"modetype=%d modenight=%d\",\n            AConfiguration_getMcc(android_app->config),\n            AConfiguration_getMnc(android_app->config),\n            lang[0], lang[1], country[0], country[1],\n            AConfiguration_getOrientation(android_app->config),\n            AConfiguration_getTouchscreen(android_app->config),\n            AConfiguration_getDensity(android_app->config),\n            AConfiguration_getKeyboard(android_app->config),\n            AConfiguration_getNavigation(android_app->config),\n            AConfiguration_getKeysHidden(android_app->config),\n            AConfiguration_getNavHidden(android_app->config),\n            AConfiguration_getSdkVersion(android_app->config),\n            AConfiguration_getScreenSize(android_app->config),\n            AConfiguration_getScreenLong(android_app->config),\n            AConfiguration_getUiModeType(android_app->config),\n            AConfiguration_getUiModeNight(android_app->config));\n}\n\nvoid android_app_pre_exec_cmd(struct android_app* android_app, int8_t cmd) {\n    switch (cmd) {\n        case APP_CMD_INPUT_CHANGED:\n            LOGV(\"APP_CMD_INPUT_CHANGED\\n\");\n            pthread_mutex_lock(&android_app->mutex);\n            if (android_app->inputQueue != NULL) {\n                AInputQueue_detachLooper(android_app->inputQueue);\n            }\n            android_app->inputQueue = android_app->pendingInputQueue;\n            if (android_app->inputQueue != NULL) {\n                LOGV(\"Attaching input queue to looper\");\n                AInputQueue_attachLooper(android_app->inputQueue,\n                        android_app->looper, LOOPER_ID_INPUT, NULL,\n                        &android_app->inputPollSource);\n            }\n            pthread_cond_broadcast(&android_app->cond);\n            pthread_mutex_unlock(&android_app->mutex);\n            break;\n\n        case APP_CMD_INIT_WINDOW:\n            LOGV(\"APP_CMD_INIT_WINDOW\\n\");\n            pthread_mutex_lock(&android_app->mutex);\n            android_app->window = android_app->pendingWindow;\n            pthread_cond_broadcast(&android_app->cond);\n            pthread_mutex_unlock(&android_app->mutex);\n            break;\n\n        case APP_CMD_TERM_WINDOW:\n            LOGV(\"APP_CMD_TERM_WINDOW\\n\");\n            pthread_cond_broadcast(&android_app->cond);\n            break;\n\n        case APP_CMD_RESUME:\n        case APP_CMD_START:\n        case APP_CMD_PAUSE:\n        case APP_CMD_STOP:\n            LOGV(\"activityState=%d\\n\", cmd);\n            pthread_mutex_lock(&android_app->mutex);\n            android_app->activityState = cmd;\n            pthread_cond_broadcast(&android_app->cond);\n            pthread_mutex_unlock(&android_app->mutex);\n            break;\n\n        case APP_CMD_CONFIG_CHANGED:\n            LOGV(\"APP_CMD_CONFIG_CHANGED\\n\");\n            AConfiguration_fromAssetManager(android_app->config,\n                    android_app->activity->assetManager);\n            print_cur_config(android_app);\n            break;\n\n        case APP_CMD_DESTROY:\n            LOGV(\"APP_CMD_DESTROY\\n\");\n            android_app->destroyRequested = 1;\n            break;\n    }\n}\n\nvoid android_app_post_exec_cmd(struct android_app* android_app, int8_t cmd) {\n    switch (cmd) {\n        case APP_CMD_TERM_WINDOW:\n            LOGV(\"APP_CMD_TERM_WINDOW\\n\");\n            pthread_mutex_lock(&android_app->mutex);\n            android_app->window = NULL;\n            pthread_cond_broadcast(&android_app->cond);\n            pthread_mutex_unlock(&android_app->mutex);\n            break;\n\n        case APP_CMD_SAVE_STATE:\n            LOGV(\"APP_CMD_SAVE_STATE\\n\");\n            pthread_mutex_lock(&android_app->mutex);\n            android_app->stateSaved = 1;\n            pthread_cond_broadcast(&android_app->cond);\n            pthread_mutex_unlock(&android_app->mutex);\n            break;\n\n        case APP_CMD_RESUME:\n            free_saved_state(android_app);\n            break;\n    }\n}\n\nstatic void android_app_destroy(struct android_app* android_app) {\n    LOGV(\"+android_app_destroy!\");\n    free_saved_state(android_app);\n    pthread_mutex_lock(&android_app->mutex);\n    if (android_app->inputQueue != NULL) {\n        AInputQueue_detachLooper(android_app->inputQueue);\n    }\n    AConfiguration_delete(android_app->config);\n    android_app->destroyed = 1;\n    pthread_cond_broadcast(&android_app->cond);\n    pthread_mutex_unlock(&android_app->mutex);\n    // Can't touch android_app object after this.\n    LOGV(\"-android_app_destroy!\");\n}\n\nstatic void process_input(struct android_app* app, struct android_poll_source* source) {\n    AInputEvent* event = NULL;\n    if (AInputQueue_getEvent(app->inputQueue, &event) >= 0) {\n        \n        // HACK: Override back buttom to show / hide keyboard.\n        int type = AInputEvent_getType(event);\n        if(type == AINPUT_EVENT_TYPE_KEY) {\n            if(AKeyEvent_getAction(event) == AKEY_EVENT_ACTION_DOWN) {\n                static bool keyboard_shown = false;\n                if( AKeyEvent_getKeyCode(event) == AKEYCODE_BACK ) {\n                    displayKeyboard(app,!keyboard_shown);\n                    keyboard_shown = !keyboard_shown;\n                    AInputQueue_finishEvent(app->inputQueue, event, 1);\n                    return;\n                }\n            }\n        }    \n        \n        if (AInputQueue_preDispatchEvent(app->inputQueue, event)) {\n            return;\n        }\n        int32_t handled = 0;\n        if (app->onInputEvent != NULL) handled = app->onInputEvent(app, event);\n        AInputQueue_finishEvent(app->inputQueue, event, handled);\n    } else {\n        LOGE(\"Failure reading next input event: %s\\n\", strerror(errno));\n    }\n}\n\nstatic void process_cmd(struct android_app* app, struct android_poll_source* source) {\n    int8_t cmd = android_app_read_cmd(app);\n    android_app_pre_exec_cmd(app, cmd);\n    if (app->onAppCmd != NULL) app->onAppCmd(app, cmd);\n    android_app_post_exec_cmd(app, cmd);\n}\n\nstatic void* android_app_entry(void* param) {\n    LOGV(\"+android_app_entry\");\n    struct android_app* android_app = (struct android_app*)param;\n\n    android_app->config = AConfiguration_new();\n    AConfiguration_fromAssetManager(android_app->config, android_app->activity->assetManager);\n\n    print_cur_config(android_app);\n\n    android_app->cmdPollSource.id = LOOPER_ID_MAIN;\n    android_app->cmdPollSource.app = android_app;\n    android_app->cmdPollSource.process = process_cmd;\n    android_app->inputPollSource.id = LOOPER_ID_INPUT;\n    android_app->inputPollSource.app = android_app;\n    android_app->inputPollSource.process = process_input;\n\n    ALooper* looper = ALooper_prepare(ALOOPER_PREPARE_ALLOW_NON_CALLBACKS);\n    ALooper_addFd(looper, android_app->msgread, LOOPER_ID_MAIN, ALOOPER_EVENT_INPUT, NULL,\n            &android_app->cmdPollSource);\n    android_app->looper = looper;\n\n    pthread_mutex_lock(&android_app->mutex);\n    android_app->running = 1;\n    pthread_cond_broadcast(&android_app->cond);\n    pthread_mutex_unlock(&android_app->mutex);\n    \n    std::string sargv;\n    \n    // Load command line from ARGV parameter\n    JNIEnv *env = GetEnvAttachThread(android_app->activity->vm);\n    if(env) {\n        jobject me = android_app->activity->clazz;\n        \n        jclass acl = env->GetObjectClass(me); //class pointer of NativeActivity\n        jmethodID giid = env->GetMethodID(acl, \"getIntent\", \"()Landroid/content/Intent;\");\n        jobject intent = env->CallObjectMethod(me, giid); //Got our intent\n        \n        jclass icl = env->GetObjectClass(intent); //class pointer of Intent\n        jmethodID gseid = env->GetMethodID(icl, \"getStringExtra\", \"(Ljava/lang/String;)Ljava/lang/String;\");\n        \n        jstring jsARGV = (jstring)env->CallObjectMethod(intent, gseid, env->NewStringUTF(\"ARGV\"));\n        \n        \n        if(jsARGV) {\n            const char *chARGV = env->GetStringUTFChars(jsARGV, 0);\n            if(chARGV) {\n                sargv = std::string(chARGV);\n                LOGI(\"ARGV: pango %s\", chARGV);\n            }\n            env->ReleaseStringUTFChars(jsARGV, chARGV);    \n        }\n        \n        android_app->activity->vm->DetachCurrentThread();\n    }\n\n    // Set up argv/argc to pass to users main\n    std::vector<std::string> vargv;\n    vargv.push_back(\"pango\");\n    \n    // Parse parameters from ARGV android intent parameter\n    std::istringstream iss(sargv);\n    std::copy(std::istream_iterator<std::string>(iss),\n             std::istream_iterator<std::string>(),\n             std::back_inserter<std::vector<std::string> >(vargv));    \n\n    char* argv[vargv.size()+1];\n    for(size_t ac = 0; ac < vargv.size(); ++ac) {\n        argv[ac] = new char[vargv[ac].size()];\n        strcpy( argv[ac], vargv[ac].c_str() );\n    }\n    argv[vargv.size()] = NULL;\n\n    // Find main symbol\n    void (*main)(int, char**);\n    *(void **) (&main) = dlsym( dlopen(android_app->application_so, RTLD_NOW), \"main\");\n    if (!main) {\n        LOGE( \"undefined symbol main, crap\" );\n        exit(1);\n    }\n    // Call users standard main entry point.\n    (*main)(vargv.size(), argv);\n    \n    // Clean up parameters\n    for(size_t ac = 0; ac < vargv.size(); ++ac) {\n        delete[] argv[ac];\n    }    \n    \n    android_app_destroy(android_app);\n    \n    LOGV(\"-android_app_entry\");\n    \n    return NULL;\n}\n\nstatic void android_app_write_cmd(struct android_app* android_app, int8_t cmd) {\n    if (write(android_app->msgwrite, &cmd, sizeof(cmd)) != sizeof(cmd)) {\n        LOGE(\"Failure writing android_app cmd: %s\\n\", strerror(errno));\n    }\n}\n\nstatic void android_app_set_input(struct android_app* android_app, AInputQueue* inputQueue) {\n    pthread_mutex_lock(&android_app->mutex);\n    android_app->pendingInputQueue = inputQueue;\n    android_app_write_cmd(android_app, APP_CMD_INPUT_CHANGED);\n    while (android_app->inputQueue != android_app->pendingInputQueue) {\n        pthread_cond_wait(&android_app->cond, &android_app->mutex);\n    }\n    pthread_mutex_unlock(&android_app->mutex);\n}\n\nstatic void android_app_set_window(struct android_app* android_app, ANativeWindow* window) {\n    pthread_mutex_lock(&android_app->mutex);\n    if (android_app->pendingWindow != NULL) {\n        android_app_write_cmd(android_app, APP_CMD_TERM_WINDOW);\n    }\n    android_app->pendingWindow = window;\n    if (window != NULL) {\n        android_app_write_cmd(android_app, APP_CMD_INIT_WINDOW);\n    }\n    while (android_app->window != android_app->pendingWindow) {\n        pthread_cond_wait(&android_app->cond, &android_app->mutex);\n    }\n    pthread_mutex_unlock(&android_app->mutex);\n}\n\nstatic void android_app_set_activity_state(struct android_app* android_app, int8_t cmd) {\n    pthread_mutex_lock(&android_app->mutex);\n    android_app_write_cmd(android_app, cmd);\n    while (android_app->activityState != cmd) {\n        pthread_cond_wait(&android_app->cond, &android_app->mutex);\n    }\n    pthread_mutex_unlock(&android_app->mutex);\n}\n\nstatic void android_app_free(struct android_app* android_app) {\n    pthread_mutex_lock(&android_app->mutex);\n    android_app_write_cmd(android_app, APP_CMD_DESTROY);\n    while (!android_app->destroyed) {\n        pthread_cond_wait(&android_app->cond, &android_app->mutex);\n    }\n    pthread_mutex_unlock(&android_app->mutex);\n\n    close(android_app->msgread);\n    close(android_app->msgwrite);\n    pthread_cond_destroy(&android_app->cond);\n    pthread_mutex_destroy(&android_app->mutex);\n    free(android_app);\n}\n\nstatic void onDestroy(ANativeActivity* activity) {\n    LOGV(\"Destroy: %p\\n\", activity);\n    android_app_free((struct android_app*)activity->instance);\n}\n\nstatic void onStart(ANativeActivity* activity) {\n    LOGV(\"Start: %p\\n\", activity);\n    android_app_set_activity_state((struct android_app*)activity->instance, APP_CMD_START);\n}\n\nstatic void onResume(ANativeActivity* activity) {\n    LOGV(\"Resume: %p\\n\", activity);\n    android_app_set_activity_state((struct android_app*)activity->instance, APP_CMD_RESUME);\n}\n\nstatic void* onSaveInstanceState(ANativeActivity* activity, size_t* outLen) {\n    struct android_app* android_app = (struct android_app*)activity->instance;\n    void* savedState = NULL;\n\n    LOGV(\"SaveInstanceState: %p\\n\", activity);\n    pthread_mutex_lock(&android_app->mutex);\n    android_app->stateSaved = 0;\n    android_app_write_cmd(android_app, APP_CMD_SAVE_STATE);\n    while (!android_app->stateSaved) {\n        pthread_cond_wait(&android_app->cond, &android_app->mutex);\n    }\n\n    if (android_app->savedState != NULL) {\n        savedState = android_app->savedState;\n        *outLen = android_app->savedStateSize;\n        android_app->savedState = NULL;\n        android_app->savedStateSize = 0;\n    }\n\n    pthread_mutex_unlock(&android_app->mutex);\n\n    return savedState;\n}\n\nstatic void onPause(ANativeActivity* activity) {\n    LOGV(\"Pause: %p\\n\", activity);\n    android_app_set_activity_state((struct android_app*)activity->instance, APP_CMD_PAUSE);\n}\n\nstatic void onStop(ANativeActivity* activity) {\n    LOGV(\"Stop: %p\\n\", activity);\n    android_app_set_activity_state((struct android_app*)activity->instance, APP_CMD_STOP);\n}\n\nstatic void onConfigurationChanged(ANativeActivity* activity) {\n    struct android_app* android_app = (struct android_app*)activity->instance;\n    LOGV(\"ConfigurationChanged: %p\\n\", activity);\n    android_app_write_cmd(android_app, APP_CMD_CONFIG_CHANGED);\n}\n\nstatic void onLowMemory(ANativeActivity* activity) {\n    struct android_app* android_app = (struct android_app*)activity->instance;\n    LOGV(\"LowMemory: %p\\n\", activity);\n    android_app_write_cmd(android_app, APP_CMD_LOW_MEMORY);\n}\n\nstatic void onWindowFocusChanged(ANativeActivity* activity, int focused) {\n    LOGV(\"WindowFocusChanged: %p -- %d\\n\", activity, focused);\n    android_app_write_cmd((struct android_app*)activity->instance,\n            focused ? APP_CMD_GAINED_FOCUS : APP_CMD_LOST_FOCUS);\n}\n\nstatic void onNativeWindowCreated(ANativeActivity* activity, ANativeWindow* window) {\n    LOGV(\"NativeWindowCreated: %p -- %p\\n\", activity, window);\n    android_app_set_window((struct android_app*)activity->instance, window);\n}\n\nstatic void onNativeWindowDestroyed(ANativeActivity* activity, ANativeWindow* window) {\n    LOGV(\"NativeWindowDestroyed: %p -- %p\\n\", activity, window);\n    android_app_set_window((struct android_app*)activity->instance, NULL);\n}\n\nstatic void onInputQueueCreated(ANativeActivity* activity, AInputQueue* queue) {\n    LOGV(\"InputQueueCreated: %p -- %p\\n\", activity, queue);\n    android_app_set_input((struct android_app*)activity->instance, queue);\n}\n\nstatic void onInputQueueDestroyed(ANativeActivity* activity, AInputQueue* queue) {\n    LOGV(\"InputQueueDestroyed: %p -- %p\\n\", activity, queue);\n    android_app_set_input((struct android_app*)activity->instance, NULL);\n}\n\nstatic void onContentRectChanged(ANativeActivity* activity, const ARect* rect) {\n    LOGV(\"onContentRectChanged: %p -- (%d, %d), (%d, %d)\\n\", activity, rect->left, rect->top, rect->right, rect->bottom);\n}\n\nvoid DeferredNativeActivity_onCreate(\n        ANativeActivity* activity,\n        void* savedState,\n        size_t savedStateSize,\n        const char* load_target\n    )\n{\n    activity->callbacks->onDestroy = onDestroy;\n    activity->callbacks->onStart = onStart;\n    activity->callbacks->onResume = onResume;\n    activity->callbacks->onSaveInstanceState = onSaveInstanceState;\n    activity->callbacks->onPause = onPause;\n    activity->callbacks->onStop = onStop;\n    activity->callbacks->onConfigurationChanged = onConfigurationChanged;\n    activity->callbacks->onLowMemory = onLowMemory;\n    activity->callbacks->onWindowFocusChanged = onWindowFocusChanged;\n    activity->callbacks->onNativeWindowCreated = onNativeWindowCreated;\n    activity->callbacks->onNativeWindowDestroyed = onNativeWindowDestroyed;\n    activity->callbacks->onInputQueueCreated = onInputQueueCreated;\n    activity->callbacks->onInputQueueDestroyed = onInputQueueDestroyed;\n    activity->callbacks->onContentRectChanged = onContentRectChanged;\n\n    // Create threaded android_app\n    android_app* app = (struct android_app*)malloc(sizeof(struct android_app));\n    memset(app, 0, sizeof(struct android_app));\n    app->activity = activity;\n    app->application_so = load_target;\n\n    pthread_mutex_init(&app->mutex, NULL);\n    pthread_cond_init(&app->cond, NULL);\n\n    if (savedState != NULL) {\n        app->savedState = malloc(savedStateSize);\n        app->savedStateSize = savedStateSize;\n        memcpy(app->savedState, savedState, savedStateSize);\n    }\n\n    int msgpipe[2];\n    if (pipe(msgpipe)) {\n        LOGE(\"could not create pipe: %s\", strerror(errno));\n        exit(1);\n    }\n    app->msgread = msgpipe[0];\n    app->msgwrite = msgpipe[1];\n\n    pthread_attr_t attr;\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    pthread_create(&app->thread, &attr, android_app_entry, app);\n\n    // Wait for thread to start.\n    pthread_mutex_lock(&app->mutex);\n    while (!app->running) {\n        pthread_cond_wait(&app->cond, &app->mutex);\n    }\n    pthread_mutex_unlock(&app->mutex);\n\n    activity->instance = app;\n    \n    // Save global variables for use later\n    memset(&g_engine, 0, sizeof(pangolin::engine));\n    app->userData = &g_engine;\n    app->onAppCmd = pangolin::engine_handle_cmd;\n    app->onInputEvent = pangolin::engine_handle_input;\n    g_engine.app = app;\n    g_engine.activity = activity;\n\n//    // Load existing state if it exists\n//    if (app->savedState != NULL) {\n//        // We are starting with a previous saved state; restore from it.\n//        g_engine.state = *(struct pangolin::saved_state*)app->savedState;\n//    }\n}\n}\n\nnamespace pangolin\n{\n\nvoid CreateAndroidWindowAndBind(std::string name)\n{\n    LOGI(\"*****************************************************************\");\n    LOGV(\"+CreateAndroidWindowAndBind\");\n    // Bind and Wait for GL Context\n    pangolin::BindToContext(name);\n    ProcessAndroidEvents();    \n    LOGV(\"-CreateAndroidWindowAndBind\");    \n}\n\nvoid ProcessAndroidEvents()\n{\n    do {\n        // Read all pending events.\n        int ident;\n        int events;\n        struct android_poll_source* source;\n        \n        // If not animating, we will block forever waiting for events.\n        // If animating, we loop until all events are read, then continue\n        // to draw the next frame of animation.\n        while ((ident=ALooper_pollAll(g_engine.has_focus ? 0 : -1, NULL, &events,\n                (void**)&source)) >= 0) {\n    \n            // Process this event.\n            if (source != NULL) {\n                source->process(g_engine.app, source);\n            }\n        \n            // Check if we are exiting.\n            if (g_engine.app->destroyRequested != 0) {\n                engine_term_display(&g_engine);\n                context->quit = true;\n                return;\n            }\n        }\n    } while (g_engine.display == NULL);\n}\n\nvoid FinishAndroidFrame()\n{\n    ProcessAndroidEvents();\n    RenderViews();\n    PostRender();\n    eglSwapBuffers(g_engine.display, g_engine.surface);    \n}\n\n// Implement platform agnostic version\nvoid CreateWindowAndBind(std::string window_title, int /*w*/, int /*h*/, const Params& /*params*/ )\n{\n    CreateAndroidWindowAndBind(window_title);\n\n#ifdef HAVE_GLES_2\n    // Bind default compatibility shader\n    pangolin::glEngine().prog_fixed.Bind();\n#endif\n}\n\n// Implement platform agnostic version\nvoid FinishFrame()\n{\n    FinishAndroidFrame();\n}\n\nvoid SetFullscreen(bool /*fullscreen*/)\n{\n    // Do nothing\n}\n\nvoid PangolinPlatformInit(PangolinGl& /*context*/)\n{\n}\n\nvoid PangolinPlatformDeinit(PangolinGl& /*context*/)\n{\n}\n\nPANGOLIN_REGISTER_FACTORY(AndroidWindow)\n{\n  struct AndroidWindowFactory : public FactoryInterface<WindowInterface> {\n    std::unique_ptr<WindowInterface> Open(const Uri& uri) override {\n        \n      const std::string window_title = uri.Get<std::string>(\"window_title\", \"window\");\n      CreateAndroidWindowAndBind(window_title);\n#ifdef HAVE_GLES_2\n      // Bind default compatibility shader\n      pangolin::glEngine().prog_fixed.Bind();\n#endif\n      return NULL;\n    }\n  };\n\n  auto factory = std::make_shared<AndroidWindowFactory>();\n  FactoryRegistry<WindowInterface>::I().RegisterFactory(factory, 10, \"android\");\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-pangolin-master-kxuufbav5nfnbfwzts5ahuxu7lpnjks3/spack-src/CMakeModules/AndroidUtils.cmake": "if(NOT ANDROID_PACKAGE_NAME)\n  set(ANDROID_PACKAGE_NAME \"com.github.stevenlovegrove.pangolin\")\nendif()\n\nif(NOT ANDROID_DEFERRED_ENTRY_SO)\n  set(ANDROID_DEFERRED_ENTRY_SO \"libpangolin.so\")\nendif()\n\n# Configure build environment to automatically generate APK's instead of executables.\nif(ANDROID AND NOT TARGET apk)\n    # virtual targets which we'll add apks and push actions to.\n    add_custom_target( apk )\n    add_custom_target( push )\n    add_custom_target( run )\n\n    # Reset output directories to be in binary folder (rather than source)\n    set(LIBRARY_OUTPUT_PATH_ROOT ${CMAKE_CURRENT_BINARY_DIR})\n    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${LIBRARY_OUTPUT_PATH_ROOT}/libs/${ANDROID_NDK_ABI_NAME})\n    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${LIBRARY_OUTPUT_PATH_ROOT}/libs/${ANDROID_NDK_ABI_NAME})\n    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${LIBRARY_OUTPUT_PATH_ROOT}/bin/${ANDROID_NDK_ABI_NAME})\n    \n    macro( create_android_manifest_xml filename prog_name package_name activity_name)\n        file( WRITE ${filename}\n\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\n<!-- BEGIN_INCLUDE(manifest) -->\n<manifest xmlns:android=\\\"http://schemas.android.com/apk/res/android\\\"\n        package=\\\"${package_name}.${prog_name}\\\"\n        android:versionCode=\\\"1\\\"\n        android:versionName=\\\"1.0\\\">\n\n    <!-- This is the platform API where NativeActivity was introduced. -->\n    <uses-sdk android:minSdkVersion=\\\"14\\\" />\n    <uses-feature android:glEsVersion=\\\"0x00020000\\\" />\n    <uses-feature android:name=\\\"android.hardware.camera\\\" />\n    <uses-permission android:name=\\\"android.permission.CAMERA\\\"/>\n    <uses-permission android:name=\\\"android.permission.WRITE_EXTERNAL_STORAGE\\\"/>\n    <uses-permission android:name=\\\"android.permission.READ_EXTERNAL_STORAGE\\\"/>\n\n    <!-- This .apk has no Java code itself, so set hasCode to false. -->\n    <application android:label=\\\"${activity_name}\\\" android:hasCode=\\\"false\\\">\n\n        <!-- Our activity is the built-in NativeActivity framework class.\n             This will take care of integrating with our NDK code. -->\n        <activity android:name=\\\"android.app.NativeActivity\\\"\n                android:label=\\\"${activity_name}\\\"\n                android:screenOrientation=\\\"landscape\\\"\n                android:configChanges=\\\"orientation|keyboard|keyboardHidden\\\"\n                android:theme=\\\"@android:style/Theme.NoTitleBar.Fullscreen\\\"\n                >\n            <!-- Tell NativeActivity the name of our .so -->\n            <meta-data android:name=\\\"android.app.lib_name\\\"\n                    android:value=\\\"${prog_name}_start\\\" />\n            <intent-filter>\n                <action android:name=\\\"android.intent.action.MAIN\\\" />\n                <category android:name=\\\"android.intent.category.LAUNCHER\\\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n</manifest> \n<!-- END_INCLUDE(manifest) -->\" )        \n    endmacro()\n\n    macro( create_bootstrap_library prog_name package_name)\n        set(bootstrap_cpp \"${CMAKE_CURRENT_BINARY_DIR}/${prog_name}_start.cpp\" )\n        file( WRITE ${bootstrap_cpp}\n\"#include <android/native_activity.h>\n#include <android/log.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <cstdio>\n\n#define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, \\\"AndroidUtils.cmake\\\", __VA_ARGS__))\n#define LIB_PATH \\\"/data/data/${package_name}.${prog_name}/lib/\\\"\n\nvoid * load_lib(const char * l) {\n    void * handle = dlopen(l, RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) LOGE( \\\"dlopen('%s'): %s\\\", l, strerror(errno) );\n    return handle;\n}\n\nvoid ANativeActivity_onCreate(ANativeActivity * app, void * ud, size_t udsize) {\n    #include \\\"${prog_name}_shared_load.h\\\"\n\n    // Look for standard entrypoint in user lib\n    void (*stdentrypoint)(ANativeActivity*, void*, size_t);\n    *(void **) (&stdentrypoint) = dlsym(load_lib( LIB_PATH \\\"lib${prog_name}.so\\\"), \\\"ANativeActivity_onCreate\\\");\n    if (stdentrypoint) {\n        (*stdentrypoint)(app, ud, udsize);\n    }else{\n        // Look for deferred load entry point\n        void (*exdentrypoint)(ANativeActivity*, void*, size_t, const char*);\n        *(void **) (&exdentrypoint) = dlsym(load_lib( LIB_PATH \\\"lib${prog_name}.so\\\"), \\\"DeferredNativeActivity_onCreate\\\");\n        if (!exdentrypoint) {\n            // Look in specific shared lib\n            *(void **) (&exdentrypoint) = dlsym(load_lib( LIB_PATH \\\"${ANDROID_DEFERRED_ENTRY_SO}\\\"), \\\"DeferredNativeActivity_onCreate\\\");\n        }\n        if(exdentrypoint) {\n            (*exdentrypoint)(app, ud, udsize, LIB_PATH \\\"lib${prog_name}.so\\\" );\n        }else{\n            LOGE( \\\"Unable to find compatible entry point\\\" );\n        }\n    }\n}\" )\n        add_library( \"${prog_name}_start\" SHARED ${bootstrap_cpp} )\n        target_link_libraries( \"${prog_name}_start\" android log )\n        add_dependencies( ${prog_name} \"${prog_name}_start\" )\n    endmacro()\n\n    macro( android_update android_project_name)\n        # Find which android platforms are available.\n        execute_process(\n            COMMAND android list targets -c\n            OUTPUT_VARIABLE android_target_list\n        )\n\n        # Pick first platform from this list.\n        string(REGEX MATCH \"^[^\\n]+\" android_target \"${android_target_list}\" )\n        message(STATUS \"Android Target: ${android_target}\")\n        \n        if( NOT \"${android_target}\" STREQUAL \"\" )        \n            # Generate ant build scripts for making APK\n            execute_process(\n                COMMAND android update project --name ${android_project_name} --path . --target ${android_target} --subprojects\n                WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}\n            )\n        else()\n            message( FATAL_ERROR \"No Android SDK platforms found. Please install an Android platform SDK. On Linux, run 'android'.\" )\n        endif()\n    endmacro()\n\n    # Override add_executable to build android .so instead!\n    macro( add_executable prog_name)\n        set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/libs/${ANDROID_NDK_ABI_NAME})\n        add_library( ${prog_name} SHARED ${ARGN} )\n\n        # Add required link libs for android\n        target_link_libraries(${prog_name} log android )\n\n        # Create manifest required for APK\n        create_android_manifest_xml(\n            \"${CMAKE_CURRENT_BINARY_DIR}/AndroidManifest.xml\" \"${prog_name}\"\n            \"${ANDROID_PACKAGE_NAME}\" \"${prog_name}\"\n        )\n\n        # Create library that will launch this program and load shared libs\n        create_bootstrap_library( ${prog_name} ${ANDROID_PACKAGE_NAME} )\n\n        # Generate ant build system for APK\n        android_update( ${prog_name} )\n\n        # Target to invoke ant build system for APK\n        set( APK_FILE \"${CMAKE_CURRENT_BINARY_DIR}/bin/${prog_name}-debug.apk\" )\n        add_custom_command(\n            OUTPUT ${APK_FILE}\n            COMMAND ant debug\n            DEPENDS ${prog_name}\n            WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}\n        )\n\n        # Target to install on device\n        add_custom_target( ${prog_name}-apk\n            DEPENDS ${APK_FILE}\n        )\n        add_dependencies(apk ${prog_name}-apk)\n\n        # Target to install on device\n        add_custom_target( ${prog_name}-push\n            COMMAND adb install -r ${APK_FILE}\n            DEPENDS ${APK_FILE}\n        )\n        add_dependencies(push ${prog_name}-push)\n\n        # install and run on device\n        add_custom_target( ${prog_name}-run\n            COMMAND adb shell am start -n ${ANDROID_PACKAGE_NAME}.${prog_name}/android.app.NativeActivity\n            DEPENDS ${prog_name}-push\n            WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n        )\n        add_dependencies(run ${prog_name}-run)\n\n        # Flag to package dependent libs\n        set_property(TARGET ${prog_name} APPEND PROPERTY MAKE_APK 1 )        \n\n        # Clear shared library loading header\n        file( WRITE \"${CMAKE_CURRENT_BINARY_DIR}/${prog_name}_shared_load.h\" \"\")\n    endmacro()\n\n    macro( package_with_target prog_name lib_path )\n        # Mark lib_path as dependent of prog_name\n        set_property(TARGET ${prog_name} APPEND PROPERTY IMPORTED_LINK_INTERFACE_LIBRARIES_RELEASE ${lib_path} )\n\n        # If prog_name is to be packaged, add file copy command to package .so's.\n        get_target_property( package_dependent_libs ${prog_name} MAKE_APK )\n        if( package_dependent_libs )\n            get_filename_component(target_filename ${lib_path} NAME)\n            file( APPEND ${depend_file} \"load_lib(LIB_PATH \\\"${target_filename}\\\" );\\n\")\n            add_custom_command(TARGET ${prog_name} POST_BUILD\n                COMMAND ${CMAKE_COMMAND} -E copy_if_different\n                ${lib_path} \"${CMAKE_CURRENT_BINARY_DIR}/libs/${ANDROID_NDK_ABI_NAME}/\"\n            )\n        endif()\n    endmacro()\n\n    macro( add_to_depend_libs prog_name depend_file lib_name )\n        # Recursively Process dependents of lib_name\n        get_target_property(TARGET_LIBS ${lib_name} IMPORTED_LINK_INTERFACE_LIBRARIES_RELEASE)\n        if(NOT TARGET_LIBS)\n            get_target_property(TARGET_LIBS ${lib_name} IMPORTED_LINK_INTERFACE_LIBRARIES_NOCONFIG)\n        endif()\n        if(NOT TARGET_LIBS)\n            get_target_property(TARGET_LIBS ${lib_name} IMPORTED_LINK_INTERFACE_LIBRARIES_DEBUG)\n        endif()\n\n        foreach(SUBLIB ${TARGET_LIBS})\n            if(SUBLIB)\n                add_to_depend_libs( ${prog_name} ${depend_file} ${SUBLIB} )\n            endif()\n        endforeach()\n\n        # Check if lib itself is an external shared library\n        if(\"${lib_name}\" MATCHES \"\\\\.so$\")\n            package_with_target( ${prog_name} ${lib_name} )\n        endif()\n\n        # Check if lib itself is an internal shared library\n        get_target_property(TARGET_LIB ${lib_name} LOCATION)\n        if(\"${TARGET_LIB}\" MATCHES \"\\\\.so$\")\n            package_with_target( ${prog_name} ${TARGET_LIB} )\n        endif()\n    endmacro()\n\n    macro( target_link_libraries prog_name)\n        # _target_link_libraries corresponds to original\n        _target_link_libraries( ${prog_name} ${ARGN} )\n\n        # Recursively process dependencies\n        set(depend_file \"${CMAKE_CURRENT_BINARY_DIR}/${prog_name}_shared_load.h\" )\n        foreach( LIB ${ARGN} )\n            add_to_depend_libs( ${prog_name} ${depend_file} ${LIB} )\n        endforeach()\n    endmacro()\n\nendif()\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-pangolin-master-kxuufbav5nfnbfwzts5ahuxu7lpnjks3/spack-src/src/_embed_/fonts/AnonymousPro.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-pangolin-master-kxuufbav5nfnbfwzts5ahuxu7lpnjks3/spack-src/.git/objects/pack/pack-83d795961deb9758a7e82e6dac3cffec11e0b07d.pack",
        "/tmp/vanessa/spack-stage/spack-stage-pangolin-master-kxuufbav5nfnbfwzts5ahuxu7lpnjks3/spack-src/.git/objects/pack/pack-83d795961deb9758a7e82e6dac3cffec11e0b07d.idx"
    ],
    "total_files": 429
}