{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/libs/core/plugin/include/hpx/plugin/detail/dll_dlopen.hpp": "// Copyright Vladimir Prus 2004.\n// Copyright (c) 2005-2018 Hartmut Kaiser\n//  SPDX-License-Identifier: BSL-1.0\n// Distributed under the Boost Software License, Version 1.0.\n// (See accompanying file LICENSE_1_0.txt\n// or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n#pragma once\n\n#include <hpx/plugin/config.hpp>\n#include <hpx/assert.hpp>\n#include <hpx/modules/errors.hpp>\n#include <hpx/modules/filesystem.hpp>\n\n#include <iostream>\n#include <memory>\n#include <mutex>\n#include <sstream>\n#include <stdexcept>\n#include <string>\n#include <type_traits>\n#include <utility>\n\n#if !defined(__ANDROID__) && !defined(ANDROID) && !defined(__APPLE__)\n#include <link.h>\n#endif\n#if defined(__APPLE__)\n#include <mach-o/dyld.h>\n#endif\n#include <dlfcn.h>\n#include <limits.h>\n\n#if !defined(HPX_HAS_DLOPEN)\n#error                                                                         \\\n    \"This file shouldn't be included directly, use the file hpx/plugin/dll.hpp only.\"\n#endif\n\n#if !defined(_WIN32)\nusing HMODULE = void*;\n#else\nusing HMODULE = struct HINSTANCE__*;\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n#if !defined(RTLD_LOCAL)\n#define RTLD_LOCAL 0    // some systems do not have RTLD_LOCAL\n#endif\n#if !defined(RTLD_DEEPBIND)\n#define RTLD_DEEPBIND 0    // some systems do not have RTLD_DEEPBIND\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n#define MyFreeLibrary(x) dlclose(x)\n#define MyLoadLibrary(x)                                                       \\\n    reinterpret_cast<HMODULE>(dlopen(x, RTLD_GLOBAL | RTLD_LAZY))\n#define MyGetProcAddress(x, y) dlsym(x, y)\n\n///////////////////////////////////////////////////////////////////////////////\nnamespace hpx { namespace util { namespace plugin {\n\n    ///////////////////////////////////////////////////////////////////////////\n    class dll\n    {\n    protected:\n        ///////////////////////////////////////////////////////////////////////\n        static void init_library(HMODULE)\n        {\n#if defined(__AIX__) && defined(__GNUC__)\n            dlerror();    // Clear the error state.\n            typedef void (*init_proc_type)();\n            init_proc_type init_proc =\n                (init_proc_type) MyGetProcAddress(dll_hand, \"_GLOBAL__DI\");\n            if (init_proc)\n                init_proc();\n#endif\n        }\n\n        static void deinit_library(HMODULE)\n        {\n#if defined(__AIX__) && defined(__GNUC__)\n            dlerror();    // Clear the error state.\n            typedef void (*free_proc_type)();\n            free_proc_type free_proc =\n                (free_proc_type) MyGetProcAddress(dll_hand, \"_GLOBAL__DD\");\n            if (free_proc)\n                free_proc();\n#endif\n        }\n\n        ///////////////////////////////////////////////////////////////////////\n        template <typename T>\n        struct free_dll\n        {\n            free_dll(HMODULE h, std::shared_ptr<std::recursive_mutex> mtx)\n              : h_(h)\n              , mtx_(mtx)\n            {\n            }\n\n            void operator()(T)\n            {\n                if (nullptr != h_)\n                {\n                    std::lock_guard<std::recursive_mutex> lock(*mtx_);\n\n                    dll::deinit_library(h_);\n                    dlerror();\n                    MyFreeLibrary(h_);\n                }\n            }\n\n            HMODULE h_;\n            std::shared_ptr<std::recursive_mutex> mtx_;\n        };\n        template <typename T>\n        friend struct free_dll;\n\n    public:\n        dll()\n          : dll_handle(nullptr)\n          , mtx_(mutex_instance())\n        {\n        }\n\n        dll(dll const& rhs)\n          : dll_name(rhs.dll_name)\n          , map_name(rhs.map_name)\n          , dll_handle(nullptr)\n          , mtx_(rhs.mtx_)\n        {\n        }\n\n        dll(std::string const& name)\n          : dll_name(name)\n          , map_name(\"\")\n          , dll_handle(nullptr)\n          , mtx_(mutex_instance())\n        {\n            // map_name defaults to dll base name\n            namespace fs = filesystem;\n\n            fs::path dll_path(dll_name);\n            map_name = fs::basename(dll_path);\n        }\n\n        void load_library(error_code& ec = throws)\n        {\n            LoadLibrary(ec);\n        }\n\n        dll(std::string const& libname, std::string const& mapname)\n          : dll_name(libname)\n          , map_name(mapname)\n          , dll_handle(nullptr)\n          , mtx_(mutex_instance())\n        {\n        }\n\n        dll(dll&& rhs) noexcept\n          : dll_name(std::move(rhs.dll_name))\n          , map_name(std::move(rhs.map_name))\n          , dll_handle(rhs.dll_handle)\n          , mtx_(std::move(rhs.mtx_))\n        {\n            rhs.dll_handle = nullptr;\n        }\n\n        dll& operator=(dll const& rhs)\n        {\n            if (this != &rhs)\n            {\n                //  free any existing dll_handle\n                FreeLibrary();\n\n                //  load the library for this instance of the dll class\n                dll_name = rhs.dll_name;\n                map_name = rhs.map_name;\n                mtx_ = rhs.mtx_;\n                LoadLibrary();\n            }\n            return *this;\n        }\n\n        dll& operator=(dll&& rhs) noexcept\n        {\n            if (&rhs != this)\n            {\n                dll_name = std::move(rhs.dll_name);\n                map_name = std::move(rhs.map_name);\n                dll_handle = rhs.dll_handle;\n                rhs.dll_handle = nullptr;\n                mtx_ = std::move(rhs.mtx_);\n            }\n            return *this;\n        }\n\n        ~dll()\n        {\n            FreeLibrary();\n        }\n\n        std::string const& get_name() const\n        {\n            return dll_name;\n        }\n        std::string const& get_mapname() const\n        {\n            return map_name;\n        }\n\n        template <typename SymbolType, typename Deleter>\n        std::pair<SymbolType, Deleter> get(\n            std::string const& symbol_name, error_code& ec = throws) const\n        {\n            const_cast<dll&>(*this).LoadLibrary(ec);\n            // make sure everything is initialized\n            if (ec)\n                return std::pair<SymbolType, Deleter>();\n\n            std::unique_lock<std::recursive_mutex> lock(*mtx_);\n\n            static_assert(std::is_pointer<SymbolType>::value,\n                \"std::is_pointer<SymbolType>::value\");\n\n            SymbolType address =\n                (SymbolType) MyGetProcAddress(dll_handle, symbol_name.c_str());\n            if (nullptr == address)\n            {\n                std::ostringstream str;\n                str << \"Hpx.Plugin: Unable to locate the exported symbol name '\"\n                    << symbol_name << \"' in the shared library '\" << dll_name\n                    << \"' (dlerror: \" << dlerror() << \")\";\n\n                dlerror();\n\n                lock.unlock();\n\n                // report error\n                HPX_THROWS_IF(\n                    ec, dynamic_link_failure, \"plugin::get\", str.str());\n                return std::pair<SymbolType, Deleter>();\n            }\n\n            // Open the library. Yes, we do it on every access to\n            // a symbol, the LoadLibrary function increases the refcnt of the dll\n            // so in the end the dll class holds one refcnt and so does every\n            // symbol.\n\n            dlerror();    // Clear the error state.\n            HMODULE handle =\n                MyLoadLibrary((dll_name.empty() ? nullptr : dll_name.c_str()));\n            if (!handle)\n            {\n                std::ostringstream str;\n                str << \"Hpx.Plugin: Could not open shared library '\" << dll_name\n                    << \"' (dlerror: \" << dlerror() << \")\";\n\n                lock.unlock();\n\n                // report error\n                HPX_THROWS_IF(ec, filesystem_error, \"plugin::get\", str.str());\n                return std::pair<SymbolType, Deleter>();\n            }\n\n#if !defined(__AIX__)\n            // AIX seems to return different handle values for the second and\n            // any following call\n            HPX_ASSERT(handle == dll_handle);\n#endif\n\n            init_library(handle);    // initialize library\n\n            // Cast to the right type.\n            dlerror();    // Clear the error state.\n\n            return std::make_pair(address, free_dll<SymbolType>(handle, mtx_));\n        }\n\n        void keep_alive(error_code& ec = throws)\n        {\n            LoadLibrary(ec, true);\n        }\n\n    protected:\n        void LoadLibrary(error_code& ec = throws, bool force = false)\n        {\n            if (!dll_handle || force)\n            {\n                std::unique_lock<std::recursive_mutex> lock(*mtx_);\n\n                ::dlerror();    // Clear the error state.\n                dll_handle = MyLoadLibrary(\n                    (dll_name.empty() ? nullptr : dll_name.c_str()));\n                // std::cout << \"open\\n\";\n                if (!dll_handle)\n                {\n                    std::ostringstream str;\n                    str << \"Hpx.Plugin: Could not open shared library '\"\n                        << dll_name << \"' (dlerror: \" << dlerror() << \")\";\n\n                    lock.unlock();\n\n                    HPX_THROWS_IF(\n                        ec, filesystem_error, \"plugin::LoadLibrary\", str.str());\n                    return;\n                }\n\n                init_library(dll_handle);    // initialize library\n            }\n\n            if (&ec != &throws)\n                ec = make_success_code();\n        }\n\n    public:\n        std::string get_directory(error_code& ec = throws) const\n        {\n            // now find the full path of the loaded library\n            using filesystem::path;\n            std::string result;\n\n#if !defined(__ANDROID__) && !defined(ANDROID) && !defined(__APPLE__)\n            char directory[PATH_MAX] = {'\\0'};\n            const_cast<dll&>(*this).LoadLibrary(ec);\n            if (!ec && ::dlinfo(dll_handle, RTLD_DI_ORIGIN, directory) < 0)\n            {\n                std::ostringstream str;\n                str << \"Hpx.Plugin: Could not extract path the shared \"\n                       \"library '\"\n                    << dll_name\n                    << \"' has been loaded from \"\n                       \"(dlerror: \"\n                    << dlerror() << \")\";\n\n                HPX_THROWS_IF(\n                    ec, filesystem_error, \"plugin::get_directory\", str.str());\n            }\n            result = directory;\n            ::dlerror();    // Clear the error state.\n#elif defined(__APPLE__)\n            // SO staticfloat's solution\n            const_cast<dll&>(*this).LoadLibrary(ec);\n            if (ec)\n            {\n                // iterate through all images currently in memory\n                for (size_t i = 0; i < ::_dyld_image_count(); ++i)\n                {\n                    if (const char* image_name = ::_dyld_get_image_name(i))\n                    {\n                        HMODULE probe_handle = ::dlopen(image_name, RTLD_NOW);\n                        ::dlclose(probe_handle);\n\n                        // If the handle is the same as what was passed in\n                        // (modulo mode bits), return this image name\n                        if (((intptr_t) dll_handle & (-4)) ==\n                            ((intptr_t) probe_handle & (-4)))\n                        {\n                            result = path(image_name).parent_path().string();\n                            std::cout << \"found directory: \" << result\n                                      << std::endl;\n                            break;\n                        }\n                    }\n                }\n            }\n            ::dlerror();    // Clear the error state.\n#endif\n            if (&ec != &throws)\n                ec = make_success_code();\n\n            return result;\n        }\n\n    protected:\n        void FreeLibrary()\n        {\n            if (nullptr != dll_handle)\n            {\n                std::lock_guard<std::recursive_mutex> lock(*mtx_);\n\n                deinit_library(dll_handle);\n                dlerror();\n                MyFreeLibrary(dll_handle);\n            }\n        }\n\n        // protect access to dl... functions\n        static std::shared_ptr<std::recursive_mutex> mutex_instance()\n        {\n            static std::shared_ptr<std::recursive_mutex> mutex =\n                std::make_shared<std::recursive_mutex>();\n            return mutex;\n        }\n\n    private:\n        std::string dll_name;\n        std::string map_name;\n        HMODULE dll_handle;\n        std::shared_ptr<std::recursive_mutex> mtx_;\n    };\n\n}}}    // namespace hpx::util::plugin\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/.git/objects/pack/pack-0fa8137549daf600c82e57510063f0b162bf2080.idx",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/.git/objects/pack/pack-0fa8137549daf600c82e57510063f0b162bf2080.pack",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/examples/interpolate1d/sine.h5",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/joss_paper/hpx_architecture.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/1d_stencil_program_flow.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/affinities.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/hpx_the_api.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/vs_targets_install.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/future_schematics.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/HPX_STELLAR.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/cmake_settings1.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/HPX.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/cmake_settings2.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/vs_build_output.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/mbrodowicz.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/akemp.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/aberge.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/syang16.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/sbrandt.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/manderson.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/atrantan.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/dbour27.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/martinhstumpf.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/biddisco.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/blelbach.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/theller.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/anagelberg.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/antbikineev.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/dstark.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/aserio.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/hkaiser.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/vexocide.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/vamatya.png",
        "/tmp/vanessa/spack-stage/spack-stage-hpx-master-fyqzgi25dgnygkrv4ckcwe4cs6q5npdw/spack-src/docs/sphinx/_static/images/emails/msimberg.png"
    ],
    "total_files": 4341
}