{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/ChangeLog.md": "2.5.2\n=====\n\n### Significant changes relative to 2.5.1:\n\n1. Previously, the VirtualGL faker opened a connection to the 3D X server\nwhenever an application called XOpenDisplay().  The faker now waits until the\n3D X server is actually needed before opening the connection.  This prevents\nnon-OpenGL X11 applications from opening unnecessary connections to the 3D X\nserver, which could exhaust the X server's limit of 256 connections if many\nusers are sharing the system.\n\n2. Fixed a regression caused by 2.4.1[6] whereby applications launched with\nVirtualGL on nVidia GPUs would fail to obtain a visual if `VGL_SAMPLES` was\ngreater than 0.  Multisampling cannot be used with Pixmap rendering, and\nbecause nVidia's drivers export different FB configs for `GLX_PBUFFER_BIT` and\n`GLX_PBUFFER_BIT|GLX_PIXMAP_BIT`, it is necessary to specify `GLX_PBUFFER_BIT`\nto obtain an FB config that supports multisampling.\n\n3. Fixed a regression caused by 2.4 beta1[2] whereby 32-bit Linux builds of\nVirtualGL built with recent compilers would sometimes crash when exiting\ncertain 3D applications (reported to be the case with Steam) or behave in other\nunpredictable ways.\n\n4. Fixed an issue whereby VirtualGL, when used with applications that load\nOpenGL functions via dlopen()/dlsym(), would fail to load the \"real\" GLX/OpenGL\nfunctions from libGL if libvglfaker.so was built with GCC 4.6 or later.\n\n5. Fixed various build issues with Clang.\n\n6. The interposed `dlopen()` function in the Linux version of libdlfaker.so\nwill now nullify the `RTLD_DEEPBIND` flag, if an application passes that flag\nto `dlopen()`.  This prevents an issue whereby an application could call\n`dlopen(..., *|RTLD_DEEPBIND)` to load a shared library that uses OpenGL or\nX11, thus causing the \"real\" OpenGL/GLX/X11 functions loaded by that shared\nlibrary to supercede VirtualGL's interposed functions, effectively disabling\nVirtualGL.\n\n7. Fixed an issue whereby VirtualGL would crash with a GLXBadContextState error\nif the 3D application set the render mode to something other than `GL_RENDER`\nprior to calling `glXSwapBuffers()`.\n\n\n2.5.1\n=====\n\n### Significant changes relative to 2.5:\n\n1. VirtualGL will no longer report the presence of the `GLX_EXT_swap_control`,\n`GLX_EXT_texture_from_pixmap`, or `GLX_SGI_swap_control` extensions to\napplications unless the underlying OpenGL library exports the necessary\nfunctions to support those extensions.  This fixes a regression introduced in\nVGL 2.4 that caused WINE to crash when running on a system whose OpenGL\nimplementation lacked the `glXSwapIntervalSGI()` and `glXSwapIntervalEXT()`\nfunctions.  Furthermore, VirtualGL will now report the presence of the\n`GLX_EXT_import_context` and `GLX_NV_swap_group` extensions to applications if\nthe underlying OpenGL library exports the necessary functions to support those\nextensions.\n\n2. Fixed compilation errors when building with GCC v6.\n\n3. vglserver_config is now SELinux-aware and will set up the proper file\ncontexts to allow vglgenkey to run within the GDM startup scripts.  This has\nbeen verified with Red Hat Enterprise Linux and work-alike systems (CentOS,\netc.), but unfortunately the version of GDM that ships in Fedora 22-24 does not\nexecute the GDM startup scripts at all.  At the moment, the only workaround for\nthose recent Fedora releases is to use LightDM.\n\n4. Fixed a deadlock that occurred when exiting ANSYS HFSS 2014.  This fix was\nan extension of 2.3.3[2], necessitated by the fact that MainWin calls X11\nfunctions from the destructor of one of its shared libraries, which is executed\nafter the VGL faker has shut down.  Because VGL 2.5.x enables the XCB\ninterposer by default, we have to ensure that any X11 and XCB functions hand\noff immediately to the underlying libraries after the faker has been shut down,\nbecause even if an X11 function is not interposed by VGL, some of the XCB\nfunctions it calls might be.  This issue was also known to affect ANSYS Maxwell\nand may have affected other applications that use MainWin.\n\n\n2.5\n===\n\n### Significant changes relative to 2.5 beta1:\n\n1. OS X 10.11 \"El Capitan\" no longer allows packages to install files under\n/usr/bin, and this was preventing the VirtualGL binary package for OS X from\ninstalling on that platform.  The symlinks to vglclient and vglconnect that the\nOS X package previously installed under /usr/bin have thus been removed in this\nversion of VirtualGL.  It will therefore be necessary to invoke vglconnect and\nvglclient using the full pathname (/opt/VirtualGL/bin/vglconnect or\n/opt/VirtualGL/bin/vglclient) or to add /opt/VirtualGL/bin to the PATH.\n\n2. Fixed a regression introduced by 2.5 beta1[13] that caused certain system\ncommands (such as uname, hostname, etc.) to crash when running those commands\nusing vglrun on current Arch Linux spins (glibc 2.22, GCC 5.2.)  This possibly\naffected other non-OpenGL, non-X11 applications on other bleeding-edge Linux\ndistributions as well.\n\n3. vglserver_config should now work properly with MDM (MATE Display Manager),\nif its config files are installed in the standard location (/etc/mdm).\n\n4. Fixed a regression introduced in 2.4 that caused vglrun to abort with\n`VGL_ISACTIVE=1: is not an identifier` when running on Solaris 10 (or other\nsystems in which /bin/sh doesn't support `export VAR=value` syntax.)\n\n5. Fixed a regression introduced by 2.5 beta1[3] whereby the VirtualGL faker\nwould segfault on Solaris if the 3D application called one of the GLX/OpenGL\nfunctions that VirtualGL interposes and the underlying OpenGL library (libGL)\ndid not implement that function.\n\n\n2.4.90 (2.5 beta1)\n==================\n\n### Significant changes relative to 2.4.1:\n\n1. librrfaker.so has been renamed to libvglfaker.so.  The \"rr\" designation\ndates from before VirtualGL was called \"VirtualGL\" (i.e. before it became an\nopen source project), and it is no longer relevant.\n\n2. The symlinks that VirtualGL previously installed for Chromium (the\nlong-obsolete parallel rendering package, not the web browser) are no longer\nincluded in this release.\n\n3. The mechanism by which VirtualGL loads \"real\" GLX, OpenGL, X11, and XCB\nfunctions from the respective system libraries has been refactored.  This has\nthe following ramifications:\n\n    - The \"real\" version of an interposed GLX/OpenGL/X11/XCB function will\nnever be loaded until the interposed function is called.\n    - `glXProcAddress[ARB]()` is now used to load all \"real\" GLX/OpenGL\nfunctions from libGL (except for the `glXProcAddress[ARB]()` function itself.)\nThis maintains the fixes implemented in 2.4[9] as well as the previous\nwork-arounds for certain buggy libGL implementations that do not export the\n`glXBindTexImageEXT()` and `glXReleaseTexImageEXT()` functions in the libGL\nsymbol table (the latter was specifically known to be an issue with certain\nversions of the ATI driver under Ubuntu.)\n    - If `-nodl` is passed to vglrun, then libGL will not be loaded into the\napplication process until/unless the application actually calls a GLX/OpenGL\nfunction.\n    - Because XCB functions are now loaded only when needed, the XCB interposer\nis no longer distribution-specific.  Therefore, it is now included in the\nofficial VirtualGL binaries.  Furthermore, since the loading and interposing of\nXCB symbols is now less intrusive, the XCB interposer is enabled by default (it\ncan be disabled with `vglrun -xcb`.)\n    - Reverted 2.1.3[8], since that fallback mechanism is no longer necessary\nwith modern versions of the nVidia driver.  The issue in question can still be\nworked around by explicitly setting `VGL_GLLIB` and `VGL_X11LIB`.\n\n4. Support for color index rendering emulation has been retired in this version\nof VirtualGL.  That feature will continue to be maintained in the 2.4.x branch\non a break/fix basis only.  Even when color index emulation was implemented in\nVGL 10 years ago, the applications that needed it were already extremely rare.\nSince then, color index rendering has been officially obsoleted in the OpenGL\nspec (as of version 3.1 in 2009), and modern Un*x graphics drivers no longer\nsupport it, nor do they generally support PseudoColor X visuals (nVidia still\nsupports these, but only with transparent overlays.)  Since there is generally\nno reasonable way to run color index OpenGL applications without using legacy\nhardware or software, it does not make sense to continue supporting these\napplications in this version of VirtualGL, particularly given that color index\nemulation adds a certain amount of overhead to some OpenGL calls.\n\n5. Added support for DirectColor rendering (DirectColor is similar to\nPseudoColor, except that the colormap indices for red, green, and blue can be\nspecified separately.)  GLXspheres now includes a DirectColor mode, replacing\nits previous color index mode.\n\n6. VirtualGL can now be disabled on a display-by-display basis by specifying a\nlist of X displays to exclude (see the documentation for the `VGL_EXCLUDE`\nenvironment variable.)  This is useful with multi-GPU systems on which a single\napplication may want to access the GPUs directly for parallel rendering\npurposes but use VirtualGL to display the final result.\n\n7. The vglconnect script now accepts an argument of `-e {command}`, which can\nbe used to specify a remote command to run.  This is useful for situations in\nwhich it is necessary to start a remote process non-interactively with\nvglconnect when using the `-s` or `-x` options.\n\n8. The `glXCreateWindow()` function no longer fails when passed the handle of\nan X window that was created in a different process or using XCB.  This\nspecifically fixes issues encountered when attempting to run VLC in VirtualGL,\nbut other applications may have been affected as well.\n\n9. Fixed a typo in /etc/udev/rules.d/99-virtualgl-dri.rules, which is created\nby vglserver_config.  More specifically, the typo caused incorrect group\npermissions to be assigned to the framebuffer device when not using the\nvglusers group.\n\n10. Certain applications (known to be the case with recent versions of Firefox\nwith off-main-thread compositing enabled) would crash with the following error\nwhen running in VirtualGL:\n\n        [VGL] ERROR: in readPixels--\n        [VGL]    XXX: VirtualDrawable instance has not been fully initialized\n\n    This was due to the application creating a GLX Pixmap and then calling\n`XCopyArea()` with the Pixmap prior to performing any OpenGL rendering with it.\nIn these cases, VirtualGL now treats the Pixmap as a 2D Pixmap until the\napplication has performed OpenGL rendering with it.\n\n11. glxinfo has been extended to report whether a particular GLX FB config\nsupports `GLX_BIND_TO_TEXTURE_RGB_EXT` and `GLX_BIND_TO_TEXTURE_RGBA_EXT`, i.e.\nwhether the FB config can be used with `GLX_EXT_texture_from_pixmap`.\n\n12. vglserver_config should now work properly with SDDM, if its scripts are\ninstalled in the standard location (/usr/share/sddm/scripts).\n\n13. Fixed a deadlock that occurred with applications that use MainWin, or any\nother OpenGL applications that load a shared library whose global constructor\ncalls one of the functions VirtualGL interposes.  This was known to affect\nMATLAB and ANSYS DesignModeler v16.1 and later, but it may have affected other\napplications as well.\n\n14. Fixed another deadlock that occurred when running ANSYS DesignModeler v16.1\nand later, or when running VirtualGL in a Parallels Desktop guest, when\nVirtualGL was built with `VGL_FAKEXCB=1` (which is the default.)\n\n15. Fixed a thread safety issue with PBO readback.  The PBO handle and other\nvariables related to PBO readback were being stored in static variables that\nwere shared among all OpenGL windows, contexts, and threads, and this was\nsuspected-- but not yet confirmed-- to have caused a \"Could not set PBO size\"\nerror with MetaPost.  This issue may have affected other multi-threaded\napplications as well.\n\n\n2.4.1\n=====\n\n### Significant changes relative to 2.4:\n\n1. When an application doesn't explicitly specify its visual requirements by\ncalling `glXChooseVisual()`/`glXChooseFBConfig()`, the default GLX framebuffer\nconfig that VirtualGL assigns to it now contains a stencil buffer.  This\neliminates the need to specify `VGL_DEFAULTFBCONFIG=GLX_STENCIL_SIZE,8` with\ncertain applications (previously necessary when running Abaqus v6 and MAGMA5.)\n\n2. VirtualGL will no longer advertise that it supports the\n`GLX_ARB_create_context` and `GLX_ARB_create_context_profile` extensions unless\nthe underlying OpenGL library exports the `glXCreateContextAttribsARB()`\nfunction.\n\n3. Fixed \"Invalid MIT-MAGIC-COOKIE-1\" errors that would prevent VirtualGL from\nworking when vglconnect was used to connect to a VirtualGL server from a client\nrunning Cygwin/X.\n\n4. If a 3D application is rendering to the front buffer and one of the\nend-of-frame trigger functions (`glFlush()`/`glFinish()`/`glXWaitGL()`) is\ncalled, VirtualGL will no longer read back the framebuffer unless the render\nmode is `GL_RENDER`.  Reading back the front buffer when the render mode is\n`GL_SELECT` or `GL_FEEDBACK` is not only unnecessary, but it was known to cause\na GLXBadContextState error with newer nVidia drivers (340.xx and later) in\ncertain cases.\n\n5. Fixed a deadlock that occurred in the multi-threaded rendering test of\nfakerut when it was run with the XCB interposer enabled.  This was due to\nVirtualGL attempting to handle XCB events when Xlib owned the event queue.  It\nis possible that this issue affected or would have affected real-world\napplications as well.\n\n6. Fixed an issue that caused certain 3D applications (observed with\nCAESES/FFW, although others were possibly affected as well) to abort with\n`ERROR: in TempContext-- Could not bind OpenGL context to window (window may\nhave disappeared)`.  When the 3D application called `glXChooseVisual()`,\nVirtualGL was choosing a corresponding FB config with\n`GLX_DRAWABLE_TYPE=GLX_PBUFFER_BIT` (assuming that `VGL_DRAWABLE=pbuffer`,\nwhich is the default.)  This is incorrect, however, because regardless of the\nvalue of `VGL_DRAWABLE`, VirtualGL still uses Pixmaps on the 3D X server to\nrepresent GLX Pixmaps (necessary in order to make `GLX_EXT_texture_from_pixmap`\nwork properly.)  Thus, VGL now chooses an FB config that supports both Pbuffers\nand Pixmaps.  This was generally only a problem with nVidia drivers, because\nthey export different FB configs for `GLX_PBUFFER_BIT` and\n`GLX_PBUFFER_BIT|GLX_PIXMAP_BIT`.\n\n\n2.4\n===\n\n### Significant changes relative to 2.4 beta1:\n\n1. Fixed an issue that prevented recent versions of Google Chrome/Chromium from\nrunning properly in VirtualGL.\n\n2. `VGL_SYNC` now affects `glFlush()`.  Although this does not strictly conform\nto the OpenGL spec (`glFlush()` is supposed to be an asynchronous command), it\nwas necessary in order to make certain features of Cadence Allegro work\nproperly.  Since virtually no applications require `VGL_SYNC`, it is believed\nthat this change is innocuous.\n\n3. Fixed a regression in vglconnect (introduced in VirtualGL 2.3) that\nprevented `vglconnect -x` from working properly if the user did not have access\nto the current directory (vglconnect was erroneously creating a temporary file\nin the current directory instead of in /tmp.)\n\n4. GLXspheres now warns if the specified polygon count would exceed the limit\nof 57600 polygons per sphere imposed by GLU and prints the actual polygon count\nwith this limit taken into account.  Also, a new option (`-n`) has been\nintroduced to increase the sphere count.\n\n5. VirtualGL will now only enable color index rendering emulation if a color\nindex context is current.  This specifically fixes an interaction issue with\nMSC Mentat, which occasionally calls `glIndexi()` when an RGBA context is\ncurrent, but the fix may affect other applications as well.\n\n6. VirtualGL can now interpose enough of the XCB API to make Qt 5 work\nproperly.  Qt 5 does not use XCB to perform 3D rendering (there is no suitable\nXCB replacement for GLX yet), but it does use XCB to detect whether the GLX\nextension is available and to handle the application's event queue(s).  Thus,\nwhen attempting to run Qt 5 applications in VirtualGL, previously the OpenGL\nportion of the window would fail to resize when the window was resized, or the\napplication would complain that OpenGL was not available and fail to start, or\nthe application would fall back to non-OpenGL rendering.\n\n    Currently, enabling XCB support in VirtualGL requires building VirtualGL\nfrom source and adding `-DVGL_FAKEXCB=1` to the CMake command line.  The XCB\ninterposer is also disabled by default at run time.  It must be enabled by\nsetting the `VGL_FAKEXCB` environment variable to `1` or passing `+xcb` to\nvglrun.\n\n7. Fixed a deadlock that occurred when running compiz 0.9.11 (and possibly\nother versions as well) with VirtualGL.  The issue occurred when compiz called\n`XGrabServer()`, followed by `glXCreatePixmap()` and `glXDestroyPixmap()`.  In\nVirtualGL, a GLX pixmap resides on the 3D X server, but the corresponding X11\npixmap resides on the 2D X server.  Thus, VirtualGL has to synchronize pixels\nbetween the two pixmaps in response to certain operations, such as\n`XCopyArea()` and `XGetImage()`, or when the GLX pixmap is destroyed.\nVirtualGL was previously opening a new connection to the 2D X server in order\nto perform this synchronization, and because the 2D X server was grabbed,\ncompiz locked up when VirtualGL called `XCloseDisplay()` on the new display\nconnection.  In fact, however, the new display connection was unnecessary,\nsince the GLX/X11 pixmap synchronization occurs within the 3D rendering thread.\nThus, VirtualGL now simply reuses the same display connection that was passed\nto `glXCreate[GLX]Pixmap()`.\n\n8. NetTest and TCBench for Windows are now supplied in a package called\nVirtualGL-Utils, which can be built from the VirtualGL source.  When the\nVirtualGL Client for Exceed was discontinued, these utilities ceased to have a\nhome, but they are still useful tools to have, irrespective of the thin client\nsolution that is being used.  The Windows build of TCBench was temporarily\nmoved into the Windows TurboVNC Viewer packages, but it proved to be a pain to\nkeep the source code synchronized between the two projects.\n\n    The VirtualGL-Utils package additionally contains a WGL version of\nGLXspheres, which is a useful tool to have when benchmarking Windows virtual\nmachines that are running in a VirtualGL environment.\n\n9. Worked around an issue in recent versions of SPECviewperf and FEMFAT\nvisualizer that caused them to segfault when used with VirtualGL.  Those\napplications apparently use a dynamic loading mechanism for OpenGL extension\nfunctions, and this mechanism defines symbols such as \"glGenBuffers\" at file\nscope.  Any symbol exported by an application will override a symbol of the\nsame name exported by a shared library, so when VirtualGL tried to call\n`glGenBuffers()`, `glBindBuffer()`, etc., it was picking up the symbols from\nthe application, not from libGL (and those symbols from the application were\nnot necessarily defined.)  VirtualGL now obtains the function pointers it needs\nfor PBO readback directly from libGL using `glXProcAddress()`, rather than\nrelying on the dynamic linker to resolve them.  Note that this issue could be\nworked around in previous versions of VirtualGL by setting `VGL_READBACK=sync`.\n\n\n2.3.90 (2.4 beta1)\n==================\n\n### Significant changes relative to 2.3.3:\n\n1. The VirtualGL Client for Exceed has been retired.  It will continue to be\nmaintained in the 2.3.x branch on a break/fix basis only.  Cygwin/X has matured\nto the point that it now provides an adequate solution for using the VirtualGL\nClient on Windows, with the only major limitation being lack of quad-buffered\nstereo support.  That feature alone is insufficient to justify a code base\nthat is basically twice as complex as it otherwise would be.  Furthermore, we\nare now maintaining our own Cygwin repository for the VirtualGL Client, which\nmakes it relatively easy to install on that platform.\n\n    The VirtualGL Client for Exceed reflects VirtualGL's origins as an add-on\ntechnology for existing remote X environments.  These days, most people use\nVirtualGL with some sort of X proxy instead.  There have been no significant\nchanges to vglclient since version 2.2.1, as most of the efforts of The\nVirtualGL Project in recent years have focused on the server-side components\nand TurboVNC.  In the early days of the project, there were performance\nadvantages to the VGL Transport, but that is no longer the case.  In fact,\nTurboVNC will generally do a better and faster job of compressing the image\nstream, since it uses a hybrid compression scheme rather than pure JPEG.\n\n    The native Windows version of TCBench, which previously shipped with the\nVirtualGL Client for Exceed, has been moved into the Windows TurboVNC Viewer\npackage.\n\n2. The VirtualGL source code has been extensively refactored to use more modern\nvariable, class, and method naming conventions, and automated test scripts for\nthe utility libraries and the faker have been added.\n\n3. `glXChooseFBConfig()` now properly handles the `GLX_FBCONFIG_ID` attribute.\nThe improper handling of this attribute was known to cause an error\n(`Could not find GLX 1.3 config from peer info`) when running the LWJGL\n(Lightweight Java Game Library) on AMD GPUs, but it may have affected other\napps as well.\n\n4. The performance of PBO readback on ATI FirePro adapters has been improved\ndramatically (close to an order of magnitude.)\n\n5. vglserver_config will now set DRI device permissions properly on systems\nthat lack an xorg.conf file but have an xorg.conf.d directory.\n\n6. vglserver_config should now work with recent Debian releases.\n\n7. Fixed an issue whereby VirtualGL would not always resize the Pbuffer\ncorresponding to an Xt or Motif OpenGL widget whenever the widget was resized.\n\n8. The Mac packaging system now uses pkgbuild and productbuild rather than\nPackageMaker (which is obsolete and no longer supported.)  This means that\nOS X 10.6 \"Snow Leopard\" or later must be used when packaging VirtualGL,\nalthough the packages produced can be installed on OS X 10.5 \"Leopard\" or\nlater.  OS X 10.4 \"Tiger\" is no longer supported.\n\n9. The \"Uninstall VirtualGL\" app should once again work on OS X 10.5.\n\n10. Fixed an infinite drawing loop that occurred when running Altair HyperBeam\nwith VirtualGL.  Since 2.1.3, VirtualGL has been setting the `WM_DELETE_WINDOW`\nproperty on any OpenGL window so that it (VGL) can be notified if the window\nmanager deletes the window (thus preventing VGL from trying to draw to the\nwindow after it disappears.)  This was originally done within the body of\n`XCreate[Simple]Window()`, but Java did not like us overriding the property for\n2D windows (refer to 2.3.1[9].)  Thus, the setting of `WM_DELETE_WINDOW` was\nmoved into the body of `glXMake[Context]Current()` so that it would affect only\nOpenGL windows.  However, VGL was incorrectly replacing the list of WM\nprotocols rather than simply adding `WM_DELETE_WINDOW` to the existing list.\nVGL was also not checking whether `WM_DELETE_WINDOW` already existed in the\nlist before adding it.  For reasons that are not well understood, this caused\nHyperBeam to get into an infinite loop, because calling `XSetWMProtocols()`\nwithin the body of `glXMakeCurrent()` seemed to cause the application to call\n`glXMakeCurrent()` again.  This issue may have affected other applications as\nwell.\n\n11. Fixed an issue whereby the RPMs generated by VirtualGL's packaging system\n(including the official RPMs for VGL 2.3.2 and 2.3.3) could not be installed on\nlater Fedora releases.\n\n12. Fixed an issue whereby `glXSwapBuffers()` would not work properly unless\nthe drawable passed to that function was current.  This specifically fixes a\nrendering issue with voreen, but it may have affected other apps as well.\n\n13. Fixed an issue that prevented vglgenkey from working properly on Red Hat\nEnterprise Linux 7.\n\n14. Fixed an issue that prevented vglserver_config from working properly on\nUbuntu 14.04.\n\n\n2.3.3\n=====\n\n### Significant changes relative to 2.3.2:\n\n1. VirtualGL will no longer throw an exception if a 3D application calls\ncertain X11 and GLX functions with a NULL argument.  It will instead allow the\nunderlying X11 or GLX library to handle the error.  This specifically works\naround an issue with Fiji.\n\n2. Worked around an issue whereby, when ANSYS Workbench 14.5 was run with\nVirtualGL, subprocesses (such as the geometry editor) launched from within the\nWorkbench environment would not exit properly (and thus would become zombies.)\nThis issue also affected ANSYS HFSS, which would either lock up when exiting or\nprint an error message:\n`terminate called after throwing an instance of 'rrerror'`.\n\n3. Worked around an issue whereby, when using MAGMA5 with VirtualGL, the second\nand subsequent perspectives opened within the application would not always\ndisplay correctly.\n\n4. Added support for the `GLX_EXT_texture_from_pixmap` extension.\n\n5. Added support for the `GLX_EXT_swap_control` and `GLX_SGI_swap_control`\nextensions and a new configuration variable (`VGL_REFRESHRATE`) that can be\nused to control them.  See the User's Guide for more information.\n\n6. Added support for depth=32 visuals and FB configs.\n\n7. Added a new \"window manager\" mode that disables certain features in\nVirtualGL that interfere with 3D window managers such as compiz.  This,\ncombined with [6] and [4] above, should allow compiz to run properly with this\nversion of VirtualGL, provided that the 2D X Server has support for the X\nComposite extension.  See the User's Guide for more information.\n\n8. Fixed a BadDrawable X11 error that occurred when running the Steam client in\nVirtualGL.\n\n9. Improved the accuracy of TCBench and CPUstat.\n\n10. Streamlined VirtualGL's behavior when it is installed from source:\n\n    - vglrun now works regardless of where the faker libraries have been\ninstalled.  The build system hard-codes the value of the `VGL_LIBDIR` CMake\nvariable into a script that vglrun invokes so that it can add this directory to\n`LD_LIBRARY_PATH`.   If the faker libraries are installed into a system library\ndirectory, then packagers can choose to omit the new script, and vglrun will\ncontinue to work as it always has.\n    - Whenever a 64-bit build is installed, glxspheres is now renamed\nglxspheres64, per the convention of the official packages.  This makes it\npossible to install a 32-bit and a 64-bit version of VirtualGL into the same\ndirectory.\n    - If the install prefix is set to the default (/opt/VirtualGL), then the\nbuild system defaults to installing faker libraries from a 32-bit build into\n/opt/VirtualGL/lib32 and faker libraries from a 64-bit build into\n/opt/VirtualGL/lib64.\n    - Similarly, if the install prefix is set to the default (/opt/VirtualGL),\nthen the build system defaults to installing the 32-bit libGL symlink for\nChromium into /opt/VirtualGL/fakelib32 and the 64-bit libGL symlink for\nChromium into /opt/VirtualGL/fakelib64.\n\n11. PBO readback mode is now enabled by default.  Further research has shown\nthat professional-grade GPUs always benefit from PBOs being enabled (quite\ndramatically, in the case of AMD FirePro adapters.)  With consumer-grade AMD\nadapters, PBOs generally do no harm, and with consumer-grade nVidia (GeForce)\nadapters, the results are mixed.  The GeForce drivers will fall back to\nblocking readbacks if the pixel format requested in `glReadPixels()` doesn't\nmatch the pixel format of the Pbuffer, so PBOs will generally be slower in\nthose cases.  Thus, VirtualGL now falls back to synchronous readback mode if it\ndetects that PBOs are not behaving asynchronously.\n\n    Furthermore, `VGL_FORCEALPHA` is no longer enabled by default when PBOs are\nenabled.  This option was introduced because of the GeForce behavior mentioned\nabove, but the option has no effect whatsoever with the professional-grade GPUs\nthat are recommended for use with VirtualGL.  Instead, VGL will now detect\nsituations in which `VGL_FORCEALPHA` might be beneficial and suggest enabling\nor disabling it (if `VGL_VERBOSE=1`.)\n\n12. This version of VirtualGL provides a binary package and full support for\nCygwin64.\n\n\n2.3.2\n=====\n\n### Significant changes relative to 2.3.1:\n\n1. Added new stereo options, including green/magenta and blue/yellow anaglyphic\nas well as three half-resolution passive stereo options that can be used to\ndrive 3D TV's.\n\n2. The 32-bit supplementary package for amd64 Debian systems should now work\nproperly on MultiArch-compatible systems (such as Ubuntu 11 and later.)\n\n3. vglserver_config should now work properly with LightDM.\n\n4. VirtualGL was not advertising that it supported the\n`GLX_ARB_create_context_profile` extension, even though it does.  This has been\nfixed.\n\n5. VirtualGL now uses a separate OpenGL context to perform pixel readback.\nThis fixes several issues, including an error\n(`GL_ARB_pixel_buffer_object extension not available`) when trying to enable\nPBO readback with applications that use a 3.x or later OpenGL core profile, and\nincorrect rendering in JPCSP and other applications that modify certain pixel\nstore parameters (such as `GL_PACK_SWAP_BYTES` or `GL_PACK_ROW_LENGTH`) that\nVirtualGL wasn't properly handling.\n\n6. `VGL_FORCEALPHA=1` now works properly if the 3D application specifies visual\nattributes of `GLX_RED_SIZE`=`GLX_GREEN_SIZE`=`GLX_BLUE_SIZE`=`1`.\n\n7. `glXUseXFont()` has been extended to work with Pbuffers.  Due to an\noversight, VirtualGL would previously abort with an error message if the 3D\napplication attempted to render text to a Pbuffer that it created.\n\n8. Fixed an issue whereby, when displaying to a 2D X server that lacked the\nMIT-SHM extension, the X11 Transport would sometimes fail to resize its\ninternal Pixmap (used for double buffering) whenever the X window was resized.\nThis specifically caused OpendTect to display only a portion of its 3D view\nwhenever it resized its 3D window after a \"Restore\" operation, but the issue\nmay have affected other applications as well.\n\n9. Previously, 3D applications running in VirtualGL could not successfully use\n`XGetImage()` to obtain the rendered 3D pixels from a GLX pixmap.  This has\nbeen fixed.\n\n10. vglrun now automatically sets an environment variable that disables the\nexecution of the VBoxTestOGL program in VirtualBox 4.2 and later.  Since\n`LD_PRELOAD` is not propagated down to VBoxTestOGL whenever VirtualBox launches\nit (because VirtualBox is a setuid-root executable), VBoxTestOGL always fails\nin a VirtualGL environment, which makes VirtualBox believe that the system has\nno 3D support.  With version 4.1.10, VirtualBox began running VBoxTestOGL every\ntime a VM was launched, which effectively prevented VBox from being used with\nVirtualGL unless the user hacked their system by symlinking /bin/true to\n/usr/lib/virtualbox/VBoxTestOGL.\n\n\n2.3.1\n=====\n\n### Significant changes relative to 2.3:\n\n1. Worked around a segfault that occurred when running CoreBreach.\n\n2. VirtualGL now properly handles implicit deletion of windows/subwindows via\n`XCloseDisplay()`, implicit deletion of subwindows via `XDestroyWindow()`, and\nexplicit deletion of subwindows via `XDestroySubwindows()`.  This specifically\naddresses BadDrawable errors that occurred when running certain applications\nin WINE 1.3.34 and later.\n\n3. Fixed a crash in `glXCreateGLXPbufferSGIX()` that occurred when a NULL\nattribute list pointer was passed to it.\n\n4. VirtualGL should now build and run properly on FreeBSD.\n\n5. VirtualGL now works properly with applications that dynamically load libX11.\nThis specifically fixes several issues that occurred when running SDL-based\napplications against a version of libSDL that was configured with\n`--enable-x11-shared`.\n\n6. Changed the Debian package names to lowercase (\"virtualgl\" and\n\"virtualgl32\") to avoid an issue whereby the package was always being\ninstalled, even if the installed version was up to date.\n\n7. vglserver_config now works properly with KDM on RHEL/CentOS 5 systems.\n\n8. Added a new option (`VGL_GLFLUSHTRIGGER`) that, when set to `0`, will cause\nVirtualGL to ignore `glFlush()` commands from the 3D application.  This is\nintended for rare applications that do front buffer rendering and use\n`glFlush()` as an \"intermediate\" synchronization command but then subsequently\ncall `glFinish()` to indicate the end of the frame.\n\n9. Fixed an issue whereby drag & drop operations in certain Java applications\nwould cause VNC servers (any VNC server, not just TurboVNC) to hang whenever\nthe Java application was run using VirtualGL.\n\n\n2.3\n===\n\n### Significant changes relative to 2.3 beta1:\n\n1. Fixed a regression whereby GLXSpheres would ignore the first argument after\n`-fs`.\n\n2. `glXChooseFBConfig()` and `glXChooseFBConfigSGIX()` were erroneously\nreturning an error when a NULL attribute list pointer was passed to them.  They\nnow behave correctly.\n\n3. Fixed a regression whereby VirtualGL would deadlock when using the X11\nTransport with a remote X connection.\n\n4. Fixed a `GL_INVALID_OPERATION` error that would occur after a call to\n`glXSwapBuffers()`, when a context with the OpenGL Core Profile was being used.\n\n5. Fixed an issue whereby VirtualGL, when compiled with GCC 4.6, would abort\nwith `terminate called after throwing an instance of 'rrerror'` whenever a 3D\napplication running in VirtualGL exited.\n\n6. Added a new configuration option (`VGL_DEFAULTFBCONFIG`) that can be used\nto manually specify the rendering attributes of the default FB config that\nVirtualGL uses whenever a 3D application does not specify a desired set of\nvisual attributes (which it would normally do by calling `glXChooseVisual()`.)\nRefer to the User's Guide for more information.\n\n7. Worked around an issue whereby using very large fonts with `glXUseXFont()`\nwould cause Pixmap allocation failures with certain X servers.\n\n\n2.2.90 (2.3 beta1)\n==================\n\n### Significant changes relative to 2.2.1:\n\n1. Re-fixed issue that caused MainWin-based applications to hang.  This was\ninitially fixed in VGL 2.1 final, but it was re-broken by the rewrite of the\nglobal faker configuration routines in VGL 2.2.\n\n2. Overhauled the way in which VirtualGL handles Pixmap rendering, mainly to\nfix interaction issues with Mathematica.\n\n3. Added an option (`VGL_ALLOWINDIRECT`) that, when enabled, will cause\nVirtualGL to honor an application's request to create an indirect OpenGL\ncontext.  Normally VirtualGL forces all contexts to be direct for performance\nreasons, but this causes problems with certain applications (notably\nMathematica 7.)\n\n4. Added two new command-line options to GLXSpheres that allow the window size\nto be changed and the total number of frames to be specified (the application\nwill abort after the total number of frames has been rendered.)\n\n5. VirtualGL will no longer die if `glXGetConfig()` or `glXGetFBConfigAttrib()`\nis passed a NULL argument.\n\n6. Fixed a BadMatch X11 error that occurred when an application attempted to\napply a new OpenGL rendering context to a drawable and the FB config of the new\nOpenGL context differed from that of a context that was previously applied to\nthe same drawable.  This specifically was known to affect D3D applications\nrunning in WINE.\n\n7. CMake-based build and packaging system\n\n8. TCBench now takes 100 samples/second by default instead of 50.\n\n9. Added support for the `GLX_ARB_create_context` extension.\n\n\n2.2.1\n=====\n\n### Significant changes relative to 2.2:\n\n1. A 64-bit version of the VirtualGL Client for Exceed is now fully supported.\n\n2. Fixed a severe readback performance problem that occurred whenever an\napplication set the render mode to `GL_SELECT` and called `glFlush()` while\ndoing front buffer rendering.\n\n3. vglserver\\_config will now work properly whenever vglgenkey is installed in\na directory other than /usr/bin or /opt/VirtualGL/bin, as long as vglgenkey is\ninstalled in the same directory as vglserver_config.\n\n4. vglconnect now allows the user to specify the directory in which VirtualGL\nbinaries are installed on the server, rather than always assuming that they are\ninstalled in /opt/VirtualGL/bin.\n\n5. Fixed issues with vglconnect.bat that occurred when it was installed under\nc:\\Program Files (x86) on 64-bit Windows systems and invoked with the `-x` or\n`-s` options.\n\n6. Clarified the documentation of the `VGL_DISPLAY` option and documented how\nto use VirtualGL with multiple graphics cards.\n\n7. VirtualGL will no longer die if `glXDestroyContext()` is passed a NULL\nargument.\n\n8. Fixed a BadWindow error that would occur whenever a 3D application attempted\nto call `glXSwapIntervalSGI()` (specifically, this was observed when running\nDirect3D applications using WINE 1.3.11 or later.)  The nVidia GLX\nimplementation requires that a window be current (not a Pbuffer) when calling\n`glXSwapIntervalSGI()`, so VirtualGL now interposes that function and makes it\na no-op.\n\n9. Fixed an issue whereby, if a 3D application set\n`GL_(RED|GREEN|BLUE|ALPHA)_SCALE` or `GL_(RED|GREEN|BLUE|ALPHA)_BIAS` to\nnon-default values, the colors would appear wrong when running the application\nin VirtualGL, and the readback performance would be very slow.\n\n10. Fixed an issue whereby 3D applications that requested an overlay visual\nwould fail with BadRequest or other X11 errors if the 2D X server lacked GLX\nsupport (as is the case with TurboVNC.)  This was caused by the fact that\nVirtualGL passes through `glXChooseVisual()` and related calls to the 2D X\nserver if it detects that an overlay visual is being requested.  Now, VirtualGL\nwill first check that the 2D X server supports GLX before passing through those\ncalls.\n\n11. `vglclient -kill` and `vglclient -killall` now work (again) in the Exceed\nclient.\n\n\n2.2\n===\n\n### Significant changes relative to 2.2 beta1:\n\n1. Added an environment variable (`VGL_SPOILLAST`) which, when set to `0`, will\nchange the frame spoiling algorithm used for frames triggered by `glFlush()`\ncalls.  This is necessary to make Ansoft HFSS render properly.\n\n2. Added a compatibility mode to allow NetTest to communicate with older\nversions of itself (from VGL 2.1.x and prior.)\n\n3. Fixed a race condition in vglclient that would frequently cause an\n\"incorrect checksum for freed object\" error when the client was shut down via\nCTRL-C.  This problem was reported only on OS X but could have existed on other\nplatforms as well.\n\n\n2.1.90 (2.2 beta1)\n==================\n\n### Significant changes relative to 2.1.4:\n\n1. Added an option (`VGL_LOGO`) that, when enabled, will cause VirtualGL to\ndisplay a logo in the bottom right-hand corner of the 3D window.  This is meant\nas a debugging tool to allow users to determine whether or not VirtualGL is\nactive.\n\n2. Support for encrypting the VGL Transport with OpenSSL has been removed from\nthe official VirtualGL packages.  It was only a marginally useful feature,\nbecause VirtualGL also has the ability to tunnel the VGL Transport through SSH.\nIt was necessary to maintain our own static OpenSSL libraries on Linux in\norder to provide a version of VirtualGL that was compatible across all Linux\nplatforms, and this required us to keep abreast of the latest OpenSSL security\nfixes, etc.  OpenSSL support can easily be re-added by building VirtualGL from\nsource (see [BUILDING.md](BUILDING.md).)\n\n3. Added a framework for creating generic image transport plugins.  See\n[server/rrtransport.h](server/rrtransport.h) for a description of the API.\n\n4. Removed support for the proprietary Sun Ray plugin, since that plugin is no\nlonger available from Sun.\n\n5. For Linux, Mac/Intel, Solaris/x86, and Windows systems, the default build of\nVirtualGL no longer uses TurboJPEG/IPP (which was based on the proprietary\nIntel Performance Primitives) or Sun mediaLib.  Instead, VirtualGL now uses\nlibjpeg-turbo, a fully open source SIMD-accelerated JPEG codec developed in\nconjunction with the TigerVNC Project (and based on libjpeg/SIMD.)\n\n    As a result of this, it is no longer necessary to install a separate\nTurboJPEG package on Linux systems.\n\n6. Added a universal 32/64-bit VirtualGL Client binary for OS X.  The 32-bit\nfork works on 10.4 \"Tiger\" or later, and the 64-bit fork works on 10.5\n\"Leopard\" or later.\n\n7. Added support for encoding 3D images as I420 YUV and displaying them through\nX Video.  The images can either be displayed directly to the 2D X server or\nsent through the VGL transport for display using vglclient.  See the User's\nGuide for more details.\n\n8. Renamed /etc/modprobe.d/virtualgl to /etc/modprobe.d/virtualgl.conf to\ncomply with the Ubuntu standard.\n\n9. Added an environment variable (`VGL_SAMPLES`) and command-line switch\n(`vglrun -ms`) to force VirtualGL to select a multisampled visual or override\nthe level of multisampling selected by the 3D application.\n\n10. The uninstall script in the Mac binary package should now work on OS X\n10.6.\n\n11. VirtualGL can now use pixel buffer objects (PBO's) to accelerate the\nreadback of the rendered 3D pixels.  This particularly helps when multiple\nusers are sharing the GPU.  See the \"Advanced Configuration\" section of the\nUser's Guide for more information.\n\n12. On Linux systems, this version of VirtualGL works around the interaction\nissues between libdlfaker.so and VirtualBox, thus eliminating the need to\nspecify `CR_SYSTEM_GL_PATH` or to run the VirtualBox application using\n`vglrun -nodl`.\n\n13. This version of VirtualGL provides a binary package, documentation, and\nfull support for Cygwin/X.\n\n14. Fixed an error (`free(): invalid pointer`) that occurred whenever an\napplication called `XCloseDisplay()` and the `VGL_XVENDOR` environment variable\nwas set.\n\n15. VirtualGL should now work properly when used with applications that render\nto framebuffer objects (FBO's.)\n\n16. vglconnect.bat should now work properly on 64-bit Windows systems.\nPreviously, it would fail if it was installed under the \"Program Files (x86)\"\ndirectory.\n\n17. Added a `-gid` option to vglserver_config to allow the group ID of the\nvglusers group to be specified, if that group must be created.\n\n18. TCBench should now work properly on OS X.\n\n\n2.1.4\n=====\n\n### Significant changes relative to 2.1.3:\n\n1. Fixed a regression in vglserver_config that caused a \"binary operator\nexpected\" error when restricting framebuffer device access to the vglusers\ngroup.\n\n2. Fixed an issue in vglserver_config whereby the device permissions were not\nbeing set correctly on SuSE Linux Enterprise Desktop 11.\n\n3. VGL should now properly ignore `GLX_BUFFER_SIZE` if an application attempts\nto specify it when requesting a true color visual.  Specifically, this allows\nthe Second Life SnowGlobe client to run properly in VGL and WINE.\n\n4. vglserver_config should now work even if /sbin and /usr/sbin are not in the\nPATH.\n\n5. The Solaris 10/x86 version of VirtualGL should now work properly with the\nnVidia 18x.xx series drivers.\n\n6. Fixed a memory leak that occurred when running VirtualGL in quad-buffered\nstereo mode.\n\n7. The DRI device permissions in RHEL 5 were being overridden whenever a user\nlogged in, because RHEL 5 uses a file in /etc/security/console.perms.d to\nspecify the default DRI permissions rather than using\n/etc/security/console.perms.  vglserver_config has been modified to handle\nthis.\n\n8. Added an option to vglconnect on Linux/Unix to allow it to use gsissh from\nthe Globus Toolkit instead of the regular ssh program.\n\n\n2.1.3\n=====\n\n### Significant changes relative to 2.1.2:\n\n1. VirtualGL 2.1.2 printed numerous \"Cannot obtain a Pbuffer-enabled 24-bit FB\nconfig ...\" error messages when starting Google Earth.  This has been fixed,\nand the message has been changed to a warning and clarified.  These error\nmessages were printed whenever Google Earth called VirtualGL's interposed\nversion of `glXChooseVisual()` and that function subsequently failed to obtain\nan appropriate visual for performing 3D rendering.  However, this is not\nnecessarily an error, because applications will sometimes call\n`glXChooseVisual()` multiple times until they find a visual with desired\nattributes.\n\n2. Changed the matching criteria in VirtualGL's interposed version of\n`dlopen()`.  In previous versions of VirtualGL, any calls to\n`dlopen(\"*libGL*\", ...)` would be replaced with a call to\n`dlopen(\"librrfaker.so\", ...)`.  This caused problems with VisIt, which has a\nlibrary named \"libGLabelPlot.so\" that was being interposed by mistake.  The\nmatching criteria has been changed such that `dlopen()` only overrides calls to\n`dlopen(\"libGL\\.*\", ...)` or `dlopen(\"*/libGL\\.*\", ...)`.\n\n3. vglserver_config should now work properly with DRI-compatible graphics\ndrivers (including ATI.)\n\n4. VirtualGL's interposed version of `dlopen()` will now modify calls to\n`dlopen(\"libdl*\", ...)` as well as `dlopen(\"libGL*\", ...)`.  This is to work\naround an interaction issue with v180.xx of the nVidia accelerated 3D drivers\nand WINE.\n\n5. Fixed an interaction issue with QT4 in which VirtualGL would not properly\nhandle window resize events under certain circumstances.\n\n6. Moved `dlopen()` back into a separate faker library (libdlfaker.so.)\nlibdlfaker.so is loaded by default, which should maintain the behavior of VGL\n2.1.2.  However, it can be disabled by passing an argument of `-nodl` to\nvglrun.  The latter is necessary to make VirtualBox 2.2.x work with VirtualGL.\n\n7. vglserver_config should now work properly on Ubuntu 9.04 when using gdm or\nkdm.  It should also (mostly) work on Fedora 11 (disabling XTEST does not work\non Fedora 11 when using gdm.)\n\n8. Added fallback logic to VirtualGL's symbol loader, which will now try to\ndirectly load the GLX/OpenGL symbols from libGL.so.1 and the X11 symbols from\nlibX11.so.6 if loading those symbols using `dlsym(RTLD_NEXT, ...)` fails.  This\nis to work around an issue with version 18x.xx of the nVidia Linux Display\nDriver.\n\n9. If an application window was destroyed by the window manager, and the\napplication did not explicitly monitor and handle the `WM_DELETE` protocol\nmessage, then previous versions of VirtualGL would, when using the X11 Image\nTransport, generally abort with an X11 BadDrawable error.  This occurred\nbecause the window was basically being ripped out from underneath VirtualGL's\nblitter thread without warning.  This version of VirtualGL has been modified\nsuch that it monitors `WM_DELETE` messages, so VirtualGL can now bow out\ngracefully if the 3D application window is closed by the window manager but the\napplication does not handle `WM_DELETE`.\n\n10. Worked around an interaction issue with IDL whereby the application was\ncalling `XGetGeometry()` with the same pointer for every argument, and this was\ncausing VirtualGL to lose the width and height data returned from the \"real\"\n`XGetGeometry()` function.  Subsequently, the Pbuffer corresponding to the main\nIDL window would become improperly sized, and the rendering area would not\nappear to update.\n\n11. Added an option (`VGL_TRAPX11`) that will cause VirtualGL to gracefully\ntrap X11 errors, print a warning message when these occur, and allow the\n3D application to continue running.\n\n\n2.1.2\n=====\n\n### Significant changes relative to 2.1.1:\n\n1. Fixed a buffer overrun in TurboJPEG/mediaLib that may have caused problems\non Solaris/x86 VirtualGL servers.\n\n2. Integrated libdlfaker.so into librrfaker.so to eliminate the need for\ninvoking `vglrun -dl`.\n\n3. Developed a proper uninstaller app for the Mac OS X VirtualGL package.\n\n4. Modified `MAXINST` variable in the SUNWvgl Solaris package, to prevent\nmultiple instances of this package from being installed simultaneously.\n\n\n2.1.1\n=====\n\nThis release was historically part of the Sun Shared Visualization v1.1.1\nproduct.\n\n### Significant changes relative to 2.1:\n\n1. Fixed issues that occurred when displaying to the second or subsequent\nscreens on a multi-screen X server.\n\n2. Updated to the wxWindows Library License v3.1.\n\n3. Added an uncompressed YUV encoding option to the Sun Ray plugin.  This\nprovides significantly better performance than DPCM on Sun Ray 1 clients, and\nit provides significantly better image quality in all cases.  YUV encoding will\ngenerally use about 50% more network bandwidth than DPCM, all else being equal.\n\n4. Further optimized the Huffman encoder in the mediaLib implementation of\nTurboJPEG.  This should decrease the CPU usage when running VirtualGL on\nSolaris VirtualGL servers, particularly Solaris/x86 servers running 32-bit\napplications.\n\n5. vglconnect now works properly with Cygwin.\n\n6. Fixed a regression that caused VirtualGL to remove any part of the\n`VGL_XVENDOR` string following the first whitespace.\n\n7. vglserver_config now works properly with OpenSolaris systems.\n\n8. `glXUseXFont()` now works if a Pixmap is the current drawable.\n\n9. vglserver_config now works properly with Debian Linux systems.\n\n10. Fixed a typo in vglconnect that caused it to leave temporary files lying\nabout.\n\n11. Removed the libXm (Motif) dependency in the Solaris/x86 version of\nVirtualGL.  This mainly affected OpenSolaris systems, on which Motif is not\navailable.  The libXm dependency was introduced in VirtualGL 2.0.x, because\nthat version of VirtualGL used libXt (X Intrinsics) to generate its popup\nconfiguration dialog.  Java requires that libXm be loaded ahead of libXt, so it\nwas necessary to explicitly link the VirtualGL faker library with libXm to\nguarantee that the libraries were loaded in the correct order.  Since VirtualGL\n2.1.x and later no longer use libXt, the binding to libXm could be safely\nremoved on x86 systems.  Note, however, that the libXm binding still has to be\nincluded on SPARC systems, because libGL on SPARC depends on libXmu, which\ndepends on libXt.\n\n12. Fixed an issue with GeomView whereby attempting to resize the oldest window\nin a multi-window view would cause the Exceed version of vglclient to crash.\n\n13. When used to configure a Solaris server for GLX mode with open access (all\nusers being able to access the 3D X server, not just members of the vglusers\ngroup), vglserver_config was incorrectly placing xhost commands at the top of\n/etc/dt/config/Xsetup instead of at the bottom.  This could have led to\nproblems, since xhost is not guaranteed to be in the PATH until the bottom of\nthat script.\n\n14. VirtualGL should now build and run cleanly on Ubuntu systems (and possibly\nother Debian derivatives, although only Ubuntu has been tested.)\n\n15. Certain applications call `glFlush()` thousands of times in rapid\nsuccession when rendering to the front buffer, even if no part of the 3D scene\nhas changed.  Without going into the gorey details, this caused the VirtualGL\npipeline to become overloaded in certain cases, particularly on systems with\nfast pixel readback.  On such systems, every one of the `glFlush()` commands\nresulted in VirtualGL drawing or sending a frame, even if the pixels in the\nframe were identical to those in the previous frame.  This resulted in\napplication delays of up to several minutes.  This version of VGL includes a\nmechanism that ensures that no more than 100 `glFlush()` commands per second\nwill actually result in an image being drawn or sent, and thus strings of\nrapid-fire `glFlush()` commands can no longer overload the pipeline.\n\n16. vglserver_config should now work with openSUSE systems.\n\n17. It was discovered that `xhost +LOCAL:` is a better method of enabling 3D X\nserver access to all users of the VirtualGL server.  This method works even if\nTCP connections are disabled in the X server (which is the case on recent\nSolaris and Linux distributions.)  vglserver\\_config has thus been modified to\nuse this method rather than `xhost +localhost`.  Also, since it is no longer\nnecessary to set `DisallowTCP=false` in the GDM configuration file,\nvglserver_config now comments out this line if it exists.\n\n18. Fixed a deadlock that occurred when using the VirtualGL Sun Ray plugin and\nParaView to render multi-context datasets.\n\n19. Fixed an issue with Mac X11 2.1.x on OS X 10.5 \"Leopard\" whereby vglconnect\nwould abort with `Could not open log file.`  X11 2.1.x uses a `DISPLAY`\nenvironment of the form /tmp/launch-*/:0, so it was necessary to remove\neverything up to the last slash before using this variable to build a unique\nvglclient log file path.\n\n20. Included libgefaker.so in the Solaris VirtualGL packages (oops.)\n\n21. Added an interposed version of `XSolarisGetVisualGamma()` on SPARC servers,\nso applications that require gamma-corrected visuals can be fooled into\nthinking that a gamma-corrected visual is available, when in fact VirtualGL's\nsoftware gamma correction mechanism is being used instead.\n\n22. Fixed a bug in the color conversion routines of TurboJPEG/mediaLib that\ncaused the Solaris VirtualGL Client to display incorrect pixels along the\nright-most edge of the window when 2X or 4X subsampling was used.\n\n\n2.1\n===\n\nThis release was historically part of the Sun Shared Visualization v1.1\nproduct.\n\n### Significant changes relative to 2.1 beta1:\n\n1. Windows applications now link statically with OpenSSL, to avoid a dependency\non msvcr71.dll that was introduced in the Win32 OpenSSL 0.9.8e DLLs.\nlibeay32.dll and ssleay32.dll have been removed from the Windows package, since\nthey are no longer needed.\n\n2. Implemented a new interposer library (libgefaker.so) which, when active,\nwill interpose on `getenv()` and return NULL whenever an application queries\nthe value of the `LD_PRELOAD` environment variable (and, on Solaris, the\n`LD_PRELOAD_32` and `LD_PRELOAD_64` environment variables.)  This fools an\napplication into thinking that no preloading is occurring.  This feature is\ncurrently undocumented and is subject to change, but it can be activated in\nthis release by passing an argument of `-ge` to vglrun.\n\n3. Extended `VGL_SYNC` functionality to include `glXSwapBuffers()` as well.\nThis works around a couple of interaction issues between VirtualGL and\nAutoForm.  The User's Guide has been updated to explain this new functionality,\nto include an app recipe for AutoForm, and to include a warning about the\nperformance consequences of using `VGL_SYNC` on a remote X connection.\n\n4. Included a short paragraph in the Chromium section of the User's Guide\nthat explains how to use VirtualGL on the render nodes to redirect 3D rendering\nfrom a window to a Pbuffer.\n\n5. Documented the patch revision necessary to make Exceed 2008 work properly\nwith VirtualGL.  Removed dire warnings.\n\n6. Added full-screen rendering mode to GLXspheres.\n\n7. Fixed a regression (uninitialized variable) introduced by 2.1 beta1[7].\n\n8. Fixed a logic error that caused vglclient to fail when using OpenGL drawing\nand talking to a legacy (VGL 2.0 or earlier) server.\n\n9. Fixed a regression that would cause VGL to deadlock when the user closed the\n3D application window while using the X11 Image Transport.\n\n10. Fixed an issue whereby vglserver_config would fail to detect the presence\nof GLP because nm was not in the default PATH.\n\n11. When running VirtualGL on Enterprise Linux 5 using the 100 series nVidia\ndrivers, a normal exit from a 3D application will result in\n`glXChannelRectSyncSGIX()` being called after the VirtualGL hashes have already\nbeen destructed.  `glXChannelRectSyncSGIX()` calls `XFree()` (an interposed\nfunction), and under certain circumstances, the interposed version of `XFree()`\nwas trying (and failing) to access one of the previously destructed VirtualGL\nhashes.  This has been fixed.\n\n12. `vglclient -kill` now works properly on Solaris systems.\n\n13. Fixed a timing snafu in-- and raised the run priority of-- the Windows\nversion of TCBench.  This improves the accuracy of TCBench on Windows in\nhigh-client-CPU-usage scenarios.\n\n14. Fixed an issue in the interactive mode of GLXSpheres whereby it would use\n100% of the CPU when sitting idle.  Added an option to GLXSpheres to adjust the\npolygon count of the scene.\n\n15. Added app recipes for ANSYS and Cedega to the User's Guide.  Added notes\ndescribing the ANSYS and Pro/E duplicate `glFlush()` issue and workarounds.\n\n16. Changed the default value for `VGL_NPROCS` to `1` (the performance study\nindicates that there is no longer any measurable advantage to multi-threaded\ncompression on modern hardware with VGL 2.1.)\n\n17. Added a `-bench` option to nettest to allow it to measure actual usage on a\ngiven Solaris or Linux network device.  This was necessitated by accuracy\nissues with other open source network monitoring solutions.\n\n18. Changed the way global hash tables are allocated in VGL, in order to fix an\ninteraction issue with applications that are built with MainWin.\n\n19. `vglclient -kill` now works properly on Mac systems.\n\n20. The VirtualGL Configuration dialog now pops up properly when Caps Lock is\nactive.\n\n21. If a previously destroyed GLX context is passed as an argument to\n`glXMake[Context]Current()`, the function now returns False instead of throwing\na fatal exception.  This was necessary to make a couple of different commercial\napplications work properly.\n\n22. There was some inconsistency regarding the interface for enabling lossless\ncompression in the Sun Ray Image Transport.  The User's Guide listed the\ninterface as `VGL_COMPRESS=srrgb`, whereas the output of vglrun listed the\ninterface as `-c srlossless`.  VirtualGL 2.1rc only responded to the latter.\nThis version of VirtualGL now responds to both interfaces, but\n`VGL_COMPRESS=srrgb` is the correct and documented interface.  Any errant\nreferences to \"srlossless\" have been changed.\n\n\n2.1 beta1\n=========\n\n### Significant changes relative to 2.0.1:\n\n1. The VirtualGL Configuration dialog is now implemented using FLTK instead of\nX Intrinsics.  The dialog is also now handled by a separate process\n(vglconfig), to avoid application interaction issues.  VirtualGL and vglconfig\ncommunicate changes to the configuration through shared memory.\n\n    Note that this renders both the `VGL_GUI_XTTHREADINIT` configuration option\nand the corresponding application recipe for VisConcept unnecessary, and thus\nboth have been removed.\n\n2. Added two new scripts (vglconnect and vgllogin) to automate the process of\nconnecting to a VirtualGL server and using the VGL Image Transport (formerly\n\"Direct Mode.\")  vglconnect wraps both vglclient and ssh.  Through the use of\ncommand-line arguments, vglconnect can be configured to forward either the X11\ntraffic or the 3D image traffic (or none or both) over the SSH connection.\nvglconnect invokes vgllogin on the server, which configures the server\nenvironment with the proper `VGL_CLIENT` and `VGL_PORT` values so that, once\nconnected, no further action is required other than to launch a 3D application\nwith vglrun.  See the User's Guide for more information.\n\n3. vglclient includes many changes to support vglconnect.  Rather than listen\njust on ports 4242 and 4243, the default behavior of vglclient is now to find a\nfree listening port in the range of 4200-4299 (it tries 4242 and 4243 first,\nto maintain backward compatibility.)  vglclient records its listening port in\nan X property that is later read by the VGL faker.  This feature allows more\nthan one instance of vglclient to run on the same machine.  The client can also\ndetach completely from the console and run as a background daemon, exiting only\nwhen the X server resets or when vglclient is explicitly killed.\n\n    Previous versions of VirtualGL required one instance of vglclient to talk\nto all X displays on the client machine, but this created problems in\nmulti-user environments.  Thus, VirtualGL 2.1 runs a separate instance of\nvglclient for each unique X display.  This eliminates the need (as well as the\nability) to run vglclient as a root daemon or as a Windows service, and thus\nthose features have been removed.\n\n    Since vglclient is intended to be launched from vglconnect, Start Menu\nlinks to the VirtualGL Client are no longer included in the Windows package.\n\n    See the User's Guide for more information about the changes to vglclient.\n\n4. The Windows VirtualGL package now includes an optimized version of PuTTY\n0.60, which is used by the Windows version of vglconnect.  When tunneling the\n3D image stream, this version of PuTTY provides significantly better\nperformance than the stock version of PuTTY 0.60.\n\n5. Added a new script (vglserver_config) to automate the process of configuring\nthe VirtualGL server's X display (the 3D X server) to allow connections from\nVirtualGL.  This script can also be used to configure GLP, for machines that\nsupport it.  See the User's Guide for more information.\n\n6. The VirtualGL Unix packages now include a benchmark called \"GLXSpheres\",\nwhich is an open source look-alike of the old nVidia SphereMark demo.  This\nprogram is meant to provide an alternative to GLXGears, since the images\ngenerated by the latter program contain too much solid color to be a good test\nof VirtualGL's image pipeline.  GLXSpheres also includes modes that can be used\nto test VirtualGL's support of advanced OpenGL features, such as stereo,\noverlays, and color index rendering.\n\n7. VirtualGL now works properly with multi-process OpenGL applications that use\none process to handle X events and another process to handle 3D rendering.  In\nparticular, this eliminates window resize issues with Abaqus/CAE and with the\nChromium readback SPU.\n\n8. Added an additional subsampling option to enable grayscale JPEG encoding.\nThis provides additional bandwidth savings over and above chrominance\nsubsampling, since grayscale throws away all chrominance components.  It is\npotentially useful when working with applications that already render grayscale\nimages (medical imaging, etc.)\n\n9. VirtualGL can now encode images as uncompressed RGB and send those\nuncompressed images through the VGL Image Transport.  This has two benefits:\n\n     - It eliminates the need to use the X11 Image Transport (AKA \"Raw Mode\")\nover a network, and\n     - It provides the ability to send lossless stereo image pairs to a\nstereo-enabled client.\n\n    A gigabit or faster network is recommended when using RGB encoding.\n\n10. Anaglyphic stereo support.  When VirtualGL detects that an application has\nrendered something in stereo, its default behavior is to try using quad-\nbuffered stereo.  However, if the client or the image transport do not support\nquad-buffered stereo, then VirtualGL will fall back to using anaglyphic\n(red/cyan) stereo.  This provides a quick & dirty way to visualize stereo data\non clients that do not support \"real\" stereo rendering.\n\n    VirtualGL 2.1 can also be configured to send only the left eye or right eye\nimages from a stereo application.\n\n11. Changed the way VirtualGL spoils frames.  Previous versions would throw out\nany new frames if the queue was already busy compressing or sending a previous\nframe.  In this release, VirtualGL instead throws out any undisplayed frames in\nthe queue and promotes every new frame to the head of the queue.  This\nensures that the last frame in a rendering sequence will always be displayed.\n\n12. Better integration with the Sun Ray plugin.  In particular, many of the Sun\nRay plugin's configuration options can now be configured through the VirtualGL\nConfiguration dialog.\n\n13. The Mac client is now fully documented.\n\n14. Included mediaLib Huffman encoding optimizations contributed by Sun.  This\nboosts the performance of VirtualGL on Solaris systems by as much as 30%.\\\nThis, in combination with mediaLib 2.5, should allow the Solaris/x86 version of\nVirtualGL to perform as well as the Linux version, all else being equal.\n\n15. Lighting did not work properly for color index applications in prior\nversions of VGL.  This has been fixed.\n\n16. Fixed an interaction issue with the 100 series nVidia drivers, whereby\napplications that requested a single-buffered RGB visual would sometimes fail\nto obtain it through VirtualGL.  The newer nVidia drivers don't always return\nan RGB 8/8/8 framebuffer config as the first in the list, so it was necessary\nfor VirtualGL to specify `GLX_RED_SIZE`, `GLX_GREEN_SIZE`, and `GLX_BLUE_SIZE`\nwhen obtaining a framebuffer config on the VirtualGL server's X display.\n\n17. Interframe comparison now works properly with stereo image pairs, and\ninterframe comparison can now be disabled by using the `VGL_INTERFRAME` option.\n\n\n2.0.1\n=====\n\nThis release was historically part of the Sun Shared Visualization v1.0.1\nproduct.\n\n### Significant changes relative to 2.0:\n\n1. The Linux and Solaris versions of VirtualGL are now statically linked with\nOpenSSL.  This fixes an issue whereby a 3D application that uses OpenSSL could\noverride VirtualGL's SSL bindings, thus causing VirtualGL to crash if SSL was\nenabled (`VGL_SSL=1` or `vglrun +s`) and if the application's version of\nOpenSSL was incompatible with VirtualGL's.\n\n    This, combined with [5] below, has the added benefit of allowing a single\nVirtualGL RPM to be used across multiple Linux platforms.  It is no longer\nnecessary to use a separate RPM for different versions of Enterprise Linux,\nSuSE, etc.\n\n2. librrfaker.so and libturbojpeg.so are now being linked with map files (AKA\n\"anonymous version scripts\" on Linux.)  This is mainly a preventative measure,\nbecause it hides any non-global symbols in the shared objects, thus preventing\nthose symbols from accidentally interposing on a symbol in an application or in\nanother shared object.  However, this was also necessary to prevent [1] from\ncausing the opposite problem from the one it was intended to fix (without [2],\nVirtualGL could interpose on an application's SSL bindings rather than vice\nversa.)\n\n    Linux users will need to upgrade to TurboJPEG 1.04.2 (or later) to get this\nfix.  For other platforms, the fix is included in the VGL 2.0.1 packages.\n\n3. librr.so, rr.h, and the rrglxgears.c sample application have been removed\nfrom the distribution packages.  These demonstrated a strawman API for creating\na VGL movie player.  The API was somewhat ill-conceived and broken, and it\nneeds to be revisited.\n\n4. VirtualGL's custom version of glxinfo is now included in the distribution\npackages, under /opt/SUNWvgl/bin or /opt/VirtualGL/bin.  This version of\nglxinfo supports GLP on SPARC servers and also has the ability to query GLX FB\nConfigs as well as X visuals.\n\n5. VGL now uses direct linking to link against libCrun on Solaris and static\nlinking to link against libstdc++ on Linux.  This is to prevent a problem\nsimilar to [1], in which an application that overrides the default C++ `new`\nand `delete` operators could force VGL to use its custom `new` and `delete`\noperators rather than the default operators provided in libCrun/libstdc++.\nSpecifically, this addresses an issue whereby Pro/E would spuriously crash on\nmulti-processor Solaris/SPARC machines.\n\n    libstdc++ is statically linked on Linux because Linux has no equivalent of\nDirect linking, but static linking against libstdc++ has the added benefit of\nallowing one VirtualGL RPM to be used across multiple Linux platforms.\n\n6. Eliminated the use of the X DOUBLE-BUFFER extension in Raw Mode and replaced\nit instead with X Pixmap drawing.  Previously, VGL would try to use the MIT-SHM\nextension to draw images in Raw Mode, then it would fall back to using the X\nDOUBLE-BUFFER extension if MIT-SHM was not available or could not be used (such\nas on a remote X connection), then it would fall back to single-buffered\ndrawing if DOUBLE-BUFFER could not be used.  However, the DOUBLE-BUFFER\nextension crashes on some Sun Ray configurations (specifically Xinerama\nconfigurations), so VGL 2.0 disabled the use of DOUBLE-BUFFER on all Sun Ray\nconfigurations to work around this issue.  [6] replaces that hack with a more\nsolid fix that ensures that Raw Mode is always double-buffered, even if the X\nDOUBLE-BUFFER extension is not available or is not working.  Pixmap drawing\nhas the same performance as DOUBLE-BUFFER.\n\n    This generally only affects cases in which Raw Mode is used to transmit\nimages over a network.  When Raw Mode is used to transmit images to an X server\non the same machine, it is almost always able to use the MIT-SHM X extension.\n\n7. Numerous doc changes, including:\n\n     - Restructuring the User's Guide to create a more clear delineation\nbetween what needs to be done on the server and what needs to be done on the\nclient.\n     - (Re-)added instructions for how to use VGL with a direct X11 connection,\nsince it has become apparent that that configuration is necessary in some\ncases.\n     - Changed procedure for doing Direct Mode SSH tunneling.  The previous\nprocedure would not have worked if multiple users were trying to tunnel Direct\nMode from the same server.  The new procedure requires running a program (see\n[8] below) that prints out an available TCP port, and using that port on the\nserver end of the SSH tunnel.\n     - Added app recipe for ANSA 12.1.0.\n     - Added procedures for using VGL with TurboVNC and for using TurboVNC in\ngeneral.\n     - Added information for using VGL with GLP (which, unbelievably, was never\nreally included in the User's Guide.  Major oversight on our part.)\n\n8. Modified the nettest program such that it finds a free TCP port number and\nprints out the port number to the console when you pass an argument of\n`-findport` to the program.\n\n9. Fixed `glXGetProcAddressARB()` and `glXGetProcAddress()` on SPARC platforms.\nDue to an erroneous `#ifdef` statement, these interposed functions were not\ngetting compiled into VirtualGL when VirtualGL was built with Sun OpenGL on\nSPARC platforms.\n\n    This, combined with [16], allows Java 2D apps running in VirtualGL on SPARC\nplatforms to successfully use the OpenGL pipeline to perform Java 2D rendering.\n\n10. Sun OpenGL 120812-15 (and later) now includes a `SwapBuffers()` command for\nGLP, which VirtualGL will now use if available.  Some applications that use\nfront buffer drawing (Pro/E and UGS/NX v4, specifically) did not work properly\nwith VirtualGL 2.0 in GLP mode, because the back buffer in the double-buffered\nPbuffer was not being swapped.\n\n11. Some applications call `XListExtensions()` rather than `XQueryExtension()`\nto probe for the existence of the GLX extension.  Such applications, when\ndisplaying to VNC or another X server that lacks the GLX extension, would fail.\n VirtualGL now interposes on `XListExtensions()` and makes sure that the GLX\nextension is always reported as present.  This fixes a specific issue with\nUGS/NX v4 whereby NX, if run with VirtualGL and TurboVNC, would refuse to use\nOpenGL to perform its 3D rendering.\n\n12. VGL will now print a warning if the GLX context it obtains on the server's\ndisplay is indirect.  This will occur on Solaris if the framebuffer device\npermissions do not allow read/write access for the current user.\n\n13. Normally, if X11 drawing is the default in the VGL client (which is the\ncase on non-SPARC systems, on SPARC systems with 2D framebuffers, or on any\nsystem if vglclient is invoked with the `-x` argument), then the VGL client\nwill only use OpenGL for drawing stereo frames.  This fixes a bug whereby the\nVGL client would not switch back to X11 drawing (if X11 drawing was the\ndefault) after the app ceased rendering in stereo.\n\n14. You can now specify a listen port number of 0 to make the VGL client pick\nan available port.  This is of only marginal use at the moment, since there is\nno way to make the server automatically connect to that port, but we got this\nfor free as a result of [8].\n\n15. Fixed an issue that was causing the multi-threaded tests in rrfakerut to\ncrash some of the nVidia 7xxx series drivers.  rrfakerut should now run cleanly\non the 7xxx series, but the multi-threaded tests still cause the 8xxx series\ndrivers to crash & burn, and they cause the 9xxx series drivers to generate\nincorrect pixels.  Further investigation is needed.\n\n16. Fixed two issues that were preventing Java 2D on Solaris/SPARC from\nproperly detecting that OpenGL is available:\n\n    - `glXChooseFBConfig()` now ignores the `GLX_VISUAL_ID` attribute.  That\nattribute doesn't really have any meaning in VGL, and passing it through to the\nserver's X display was causing Java 2D apps to fail.\n    - `glXGetFBConfigAttrib(..., GLX_DRAWABLE_TYPE, ...)` now always returns\n`GLX_PIXMAP_BIT|GLX_PBUFFER_BIT|GLX_WINDOW_BIT`, so that Java 2D apps will\nproperly detect that window rendering is available in VirtualGL.\n\n17. vglrun will now print usage information if you fail to provide an\napplication command to run.\n\n18. Upgraded the OpenSSL DLL included with the Windows VirtualGL client to\nOpenSSL 0.9.8d (previously 0.9.8c.)\n\n19. VirtualGL now buffers the output from the profiler class so that the\nprofiling output from multiple compression threads doesn't intermingle when\nredirected to a log file.\n\n20. If the `DISPLAY` environment variable is unset on the VirtualGL server,\nvglrun will now set it automatically to `{ssh_client}:0.0` (where\n`{ssh_client}` = the IP address of the SSH client.)  If `DISPLAY` is set to\n`localhost:{n}.0` or `{server_hostname}:{n}.0`, VGL assumes that SSH X11\nforwarding is in use and sets `VGL_CLIENT={ssh_client}:0.0` instead (without\nmodifying `DISPLAY`.)  vglrun prints a warning that it is doing this.  You must\nstill explicitly set `VGL_CLIENT` or `DISPLAY` if you are doing something\nexotic, such as tunneling VGL's client/server connection through SSH or\ndisplaying to an X server with a display number other than 0.  But this fix\nshould eliminate the need to set `VGL_CLIENT` and `DISPLAY` in most cases.\nNote that the Sun Ray plugin also reads the `VGL_CLIENT` environment variable,\nso if you are connecting to the VirtualGL server from a Sun Ray server using\nSSH X11 forwarding, this eliminates the need to explicitly set `VGL_CLIENT` in\nthat case as well.\n\n21. Implemented the \"spoil last frame\" algorithm in the Sun Ray plugin whenever\nVGL reads back/compresses/sends the framebuffer in response to a `glFlush()`.\nThis fixes issues with slow model regeneration and zoom operations in Pro/E\nwhen using the Sun Ray plugin.\n\n    Normally, the Sun Ray plugin uses the \"spoil first frame\" algorithm, which\ncauses the frames in the queue to be discarded whenever a new frame is\nreceived.  However, this algorithm requires that the framebuffer be read back\nevery time a frame is rendered, even if that frame is ultimately going to be\nspoiled.  This causes problems with applications (Pro/E, specifically) that\ncall `glFlush()` frequently when doing front buffer drawing.  Each of these\n`glFlush()` calls triggers a framebuffer readback in VirtualGL, which can cause\nsignificant interaction delays in the application.  The \"spoil last frame\"\nalgorithm discards the newest frame if the queue is currently busy, so when\nthis algorithm is used, most of the duplicate frames triggered by the repeated\n`glFlush()` events are discarded with no framebuffer readback (and thus very\nlittle overhead.)\n\n    This fix does not affect Direct Mode and Raw Mode, since those modes\nalready use the \"spoil last frame\" algorithm in all cases.\n\n22. Added an option (`VGL_INTERFRAME`), which, when set to `0`, will disable\ninterframe image comparison in Direct Mode.  This was necessary to work around\nan interaction issue between VGL and Pro/E Wildfire v3 that led to slow\nperformance when zooming in or out on the Pro/E model.\n\n23. Added an option (`VGL_LOG`), which can be used to redirect the console\noutput from the VGL faker to a file instead of stderr.\n\n24. The mediaLib implementation of TurboJPEG and the mediaLib-accelerated gamma\ncorrection code have been modified slightly, to avoid calls to mediaLib\nfunctions that wrap `memalign()` and `free()`.  This works around an\ninteraction issue with Pro/E v3 (and potentially with other applications that\nuse their own custom memory allocators.)\n\n\n2.0\n===\n\nThis release was historically part of the Sun Shared Visualization v1.0\nproduct.\n\n### Significant changes relative to 2.0 beta3:\n\n1. Included libturbojpeg.dylib in Mac package (so that installing the TurboJPEG\npackage is no longer necessary unless you want to rebuild VGL from source.)\n\n2. Included TCBench and NetTest in the Mac package.\n\n3. Added an internal gamma correction system.  This was a last-minute feature\naddition to address the fact that there was no way to gamma-correct\napplications that were remotely displayed to non-SPARC clients.  SPARC users\nare accustomed to OpenGL applications being gamma-corrected by default, so\nVirtualGL now mimics this behavior whenever it is running on a SPARC server,\neven if the client machine is not a SPARC machine.\n\n    The behavior of the `VGL_GAMMA` environment variable has changed as\nfollows:\n\n     - `VGL_GAMMA=1` (or `vglrun +g`):\n\n        Enable gamma correction using the best available method.  If displaying\nto a SPARC X server that has gamma-corrected visuals, try to use those\ngamma-corrected visuals.  Otherwise, enable VGL's internal gamma correction\nsystem with a gamma correction factor of 2.22.\n\n        This is the default when running applications on SPARC VirtualGL\nservers.\n\n     - `VGL_GAMMA=0` (or `vglrun -g`):\n\n        Do not use gamma-corrected visuals (even if available on the X server),\nand do not use VGL's internal gamma correction system.\n\n        This is the default when running applications on non-SPARC VirtualGL\nservers.\n\n     - `VGL_GAMMA={f}` (or `vglrun -gamma {f}`):\n\n        Do not use gamma-corrected visuals (even if available on the client),\nbut enable VGL's internal gamma correction system with a gamma correction\nfactor of {f}.\n\n    Enabling the internal gamma correction system increases CPU usage by a few\npercent, but this has not been shown to affect the overall performance of VGL\nby a measurable amount.\n\n    See the \"VGL_GAMMA\" entry in Chapter 18 of the User's Guide for more info.\n\n4. Increased the size of the TurboJPEG compression holding buffer to account\nfor rare cases in which compressing very-high-frequency image tiles\n(specifically parts of the 3D Studio MAX Viewperf test) with high quality\nlevels (specifically Q99 or above) would produce JPEG images that are larger\nthan the uncompressed input.\n\n    Linux users will need to upgrade to TurboJPEG 1.04 (or later) to get this\nfix.  For other platforms, the fix is included in the VGL 2.0 packages.\n\n5. Minor documentation changes, including a change to the recommended OpenGL\npatches for SPARC VGL servers and an application recipe for SDRC I-DEAS Master\nSeries.\n\n6. Check for exceptions in the `new` operator to prevent VGL from dying\nungracefully in out-of-memory situations.\n\n7. Fixed a bug in the multi-threaded compression code whereby it would use too\nmuch memory to hold the image tiles for the second and subsequent compression\nthreads.  This led to memory exhaustion if the tile size was set to a low value\n(such as 16x16 or 32x32.)\n\n\n2.0 beta3\n=========\n\n### Significant changes relative to 2.0 beta2:\n\n1. Solaris packages now include the OpenSSL shared libraries (libssl and\nlibcrypto), thus eliminating the need to install Blastwave OpenSSL on Solaris 9\nand prior.\n\n2. Packages now include a convenience script (vglgenkey) that will generate an\nxauth key for the server's X display.  This provides a more secure way of\ngranting access to the server's X display than using `xhost +localhost`.\n\n3. Built and packaged the VirtualGL client for Mac OS/X (Intel only.)  This\npackage is currently undocumented and includes only the VGL client (no server\ncomponents), but its usage should be self-explanatory for those familiar with\nVGL on other platforms (it should work very similarly to the Linux version.)\n\n4. Normally, when running in Raw Mode, VirtualGL will try to use the MIT-SHM X\nextension to draw images.  If MIT-SHM is not available or doesn't work (which\nwould be the case if the X connection is remote), then VGL will try to use the\nX DOUBLE-BUFFER extension.  Failing that, it will fall back to single-buffered\ndrawing.  In a Sun Ray environment, the X DOUBLE-BUFFER extension is unstable\nwhen Xinerama is used.  DOUBLE-BUFFER doesn't really double-buffer in a Sun Ray\nenvironment anyhow, so this release of VirtualGL disables the use of\nDOUBLE-BUFFER if it detects that it is running in a Sun Ray environment.\n\n5. Reformatted User's Guide using [Deplate](http://deplate.sourceforge.net).\nNumerous other doc changes as well.\n\n6. Extended VGL to support the full GLX 1.4 spec (this involved simply creating\na function stub for `glXGetProcAddress()`, but it was necessary to make J2D\nwork under Java 6.)\n\n7. Changed the key sequence for the popup configuration dialog (again) to\nCTRL-SHIFT-F9 to avoid a conflict with Solaris Common Desktop Environment.\n\n8. VGL no longer tries to switch to Direct Mode automatically whenever a stereo\nframe is rendered.  Instead, if running in Raw Mode, it warns that stereo\ndoesn't work in Raw Mode and proceeds to send only the left eye buffer.\n\n\n2.0 beta2\n=========\n\n### Significant changes relative to 2.0 beta1:\n\n1. Added a `-dl` option to vglrun, which inserts a new libdlfaker.so interposer\nahead of VirtualGL in the link order.  libdlfaker.so intercepts `dlopen()`\ncalls from an application and, if the application is trying to use `dlopen()`\nto open libGL, librrfaker.so (VirtualGL) is opened instead.  This allows\nVirtualGL to be used seamlessly with applications that do not dynamically link\nagainst libGL and do not provide any sort of override mechanism.  See the\nUser's Guide for a list of known applications that require the `-dl` option.\n\n2. Bug fixed:  Lazy loading of OpenSSL on Solaris now works properly, so\nOpenSSL doesn't have to be installed unless VirtualGL is being used in SSL\nmode.\n\n3. Added \"application recipes\" section to User's Guide.\n\n4. Tweaked FBX library to improve performance of VGL when used with NX and\nFreeNX.\n\n5. Bug fixed:  TurboJPEG for Solaris did not properly handle 4:2:0\ndecompression if no pixel format conversion was required.\n\n6. Bug fixed:  Minor (and somewhat esoteric) visual matching bug in GLP mode\n\n7. Bug fixed:  In GLX mode, VGL did not properly handle FB configs that had no\nassociated X Visual type.\n\n8. Stereo now works on Solaris/SPARC servers using kfb framebuffers in both GLP\nand GLX modes.  Sun OpenGL patch 120812-12 (or later) and KFB driver patch\n120928-10 (or later) are required.\n\n9. Bug fixed:  In GLX mode, some of the \"real\" GLX functions that VirtualGL\ncalls on the server will in turn call `glXGetClientString()`,\n`glXQueryExtensions()`, etc. to list extensions available on the server's X\ndisplay.  VirtualGL interposes on these functions and returns its own extension\nstrings rather than the \"real\" strings from the server's X display, and this\ncaused problems under certain circumstances.  These interposed functions will\nnow detect whether they are being called from within another GLX function and\nwill return the \"real\" extension strings for the server's X display if so.\n\n10. Generally friendlier error messages\n\n11. Bug fixed:  Destroying an overlay window would cause VGL to seg fault.\n\n12. Changed configuration dialog popup key sequence to CTRL-SHIFT-F12 to avoid\nconflict with KDE.\n\n13. Added `VGL_GUI_XTHREADINIT` environment variable to optionally disable\nVGL's use of `XtToolkitThreadInitialize()`.  Rarely, a multi-threaded Motif\napplication relies on its own locking mechanisms and will deadlock if Motif's\nbuilt-in application and process locks are enabled.  Thus far, the only known\napplication that this affects is VisConcept.  Set `VGL_GUI_XTHREADINIT` to `0`\nto prevent VisConcept from deadlocking when the VGL config dialog is activated.\n\n14. VirtualGL will no longer allow a non-TrueColor stereo visual to be\nselected, because such visuals won't work with the VGL client.  Color index\n(PseudoColor) rendering requires Raw Mode, but stereo requires Direct Mode, so\nVirtualGL cannot transmit PseudoColor images in stereo.\n\n15. VirtualGL will now automatically select Raw Mode if it detects that it is\nrunning on a \"local\" display (i.e. \":{n}.0\", \"unix:{n}.0\", etc., but not\n\"localhost:{n}.0\".)  This allows users of X proxies such as Sun Ray, TurboVNC,\nNX, etc. to run VirtualGL without having to pass an argument of `-c 0` to\nvglrun.  \"localhost:{n}.0\" is not considered a \"local\" display, and neither is\n\"{server_hostname}:{n}.0\", because display connections tunneled through SSH\nwill have a display name that takes on one of those forms.\n\n16. The VirtualGL client for Solaris/SPARC will now automatically detect if it\nis running on a framebuffer that uses software OpenGL and will default to using\nX11 drawing in that case.  Otherwise, if hardware-accelerated OpenGL is\navailable, then the VGL client for Solaris/SPARC will try to use OpenGL as the\ndefault drawing method.  This improves performance on the XVR-100 and similar\nframebuffers as well as working around a bug in the OGL implementation on\nXVR-100 (see CR 6408535.)  Non-SPARC clients still use X11 drawing by default,\nexcept when drawing stereo frames.\n\n17. Worked around some issues in Sun OpenGL that manifested themselves in\ninstability of the SPARC VirtualGL client when drawing large numbers of\nsimultaneous frames from different servers.\n\n18. Expanded N1 GridEngine hooks in vglrun so that the `VGL_CLIENT`,\n`VGL_COMPRESS`, `VGL_PORT`, `VGL_SSL`, `VGL_GLLIB`, and `VGL_X11LIB`\nenvironment variables will be automatically passed to vglrun by N1GE.  All\nother variables must be explicitly passed by using the `-v` option to qsub.\n\n19. Bug fixed:  Lazy loading of OpenGL now works properly on Solaris clients,\nso vglclient can be run on machines that don't have OpenGL installed.\n\n20. For some reason, popping up the VGL configuration dialog when running Java\napps caused VGL's Xt resource string to be ignored, which would cause the\nwidgets to be displayed incorrectly.  Thus, VirtualGL now explicitly specifies\nthe resources when creating each widget and doesn't rely on the use of a\nresource string.\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/common/rr.h": "/* Copyright (C)2004 Landmark Graphics Corporation\n * Copyright (C)2005-2007 Sun Microsystems, Inc.\n * Copyright (C)2009-2013, 2015-2016 D. R. Commander\n *\n * This library is free software and may be redistributed and/or modified under\n * the terms of the wxWindows Library License, Version 3.1 or (at your option)\n * any later version.  The full license is in the LICENSE.txt file included\n * with this distribution.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * wxWindows Library License for more details.\n */\n\n#ifndef __RR_H\n#define __RR_H\n\n#define RR_MAJOR_VERSION 2\n#define RR_MINOR_VERSION 1\n\n// Argh!\n#if !defined(__SUNPRO_CC) && !defined(__SUNPRO_C)\n#pragma pack(1)\n#endif\n\n/* Header contained in all image structures */\ntypedef struct _rrframeheader\n{\n  unsigned int size;       /* If this frame is compressed, the size (in bytes)\n                              of the compressed image that represents it */\n  unsigned int winid;      /* The ID of the window on the client into which\n                              this frame should be drawn (usually this is the\n                              X11 Window handle) */\n  unsigned short framew;   /* The width of the entire frame (in pixels) */\n  unsigned short frameh;   /* The height of the entire frame (in pixels) */\n  unsigned short width;    /* The width of this tile (in pixels) */\n  unsigned short height;   /* The height of this tile (in pixels) */\n  unsigned short x;        /* The X offset of this tile within the frame */\n  unsigned short y;        /* The Y offset of this tile within the frame */\n  unsigned char qual;      /* Quality used when compressing the image (1-100) */\n  unsigned char subsamp;   /* Chrominance subsampling used when compressing\n                              the image. (1=4:4:4, 2=4:2:2, 4=4:2:0) */\n  unsigned char flags;     /* See enum below */\n  unsigned char compress;  /* Compression algorithm (see enum below) */\n  unsigned short dpynum;   /* Display number on the client machine that\n                              contains the window into which this frame will be\n                              drawn */\n} rrframeheader;\n#define sizeof_rrframeheader 26\n\ntypedef struct _rrversion\n{\n  char id[3];\n  unsigned char major;\n  unsigned char minor;\n} rrversion;\n#define sizeof_rrversion 5\n\n// Header from version 1 of the VirtualGL protocol (used to communicate with\n// older clients\ntypedef struct _rrframeheader_v1\n{\n  unsigned int size;       /* If this frame is compressed, the size (in bytes)\n                              of the compressed image that represents it */\n  unsigned int winid;      /* The ID of the window on the client into which\n                              this frame should be drawn (usually this is the\n                              X11 Window handle) */\n  unsigned short framew;   /* The width of the entire frame (in pixels) */\n  unsigned short frameh;   /* The height of the entire frame (in pixels) */\n  unsigned short width;    /* The width of this tile (in pixels) */\n  unsigned short height;   /* The height of this tile (in pixels) */\n  unsigned short x;        /* The X offset of this tile within the frame */\n  unsigned short y;        /* The Y offset of this tile within the frame */\n  unsigned char qual;      /* Quality used when compressing the image (1-100) */\n  unsigned char subsamp;   /* Chrominance subsampling used when compressing\n                              the image. (1=4:4:4, 2=4:2:2, 4=4:2:0) */\n  unsigned char flags;     /* See enum below */\n  unsigned char dpynum;    /* Display number on the client machine that\n                              contains the window into which this frame will be\n                              drawn */\n} rrframeheader_v1;\n#define sizeof_rrframeheader_v1 24\n\n/* Header flags */\nenum {\n  RR_EOF=1, /* this tile is an End-of-Frame marker and contains no real\n               image data */\n  RR_LEFT,  /* this tile goes to the left buffer of a stereo frame */\n  RR_RIGHT  /* this tile goes to the right buffer of a stereo frame */\n};\n\n/* Transport types */\n#define RR_TRANSPORTOPT 3\nenum rrtrans {RRTRANS_X11=0, RRTRANS_VGL, RRTRANS_XV};\n\n/* Compression types */\n#define RR_COMPRESSOPT  5\nenum rrcomp {RRCOMP_PROXY=0, RRCOMP_JPEG, RRCOMP_RGB, RRCOMP_XV, RRCOMP_YUV};\n\n/* Readback types */\n#define RR_READBACKOPT  3\nenum rrread {RRREAD_NONE=0, RRREAD_SYNC, RRREAD_PBO};\n\nstatic const enum rrtrans _Trans[RR_COMPRESSOPT]=\n{\n  RRTRANS_X11, RRTRANS_VGL, RRTRANS_VGL, RRTRANS_XV, RRTRANS_VGL\n};\n\nstatic const int _Minsubsamp[RR_COMPRESSOPT]=\n{\n  -1, 0, -1, 4, 4\n};\n\nstatic const int _Defsubsamp[RR_COMPRESSOPT]=\n{\n  1, 1, 1, 4, 4\n};\n\nstatic const int _Maxsubsamp[RR_COMPRESSOPT]=\n{\n  -1, 4, -1, 4, 4\n};\n\n/* Stereo options */\n#define RR_STEREOOPT    9\nenum rrstereo {RRSTEREO_LEYE=0, RRSTEREO_REYE, RRSTEREO_QUADBUF,\n               RRSTEREO_REDCYAN, RRSTEREO_GREENMAGENTA, RRSTEREO_BLUEYELLOW,\n               RRSTEREO_INTERLEAVED, RRSTEREO_TOPBOTTOM, RRSTEREO_SIDEBYSIDE};\n\n/* 3D drawable options */\n#define RR_DRAWABLEOPT  2\nenum rrdrawable {RRDRAWABLE_PBUFFER=0, RRDRAWABLE_PIXMAP};\n\n/* Other */\n#define RR_DEFAULTPORT        4242\n#ifdef USESSL\n#define RR_DEFAULTSSLPORT     4243\n#else\n#define RR_DEFAULTSSLPORT     RR_DEFAULTPORT\n#endif\n#define RR_DEFAULTTILESIZE    256\n\n/* Maximum CPUs that be can be used for parallel image compression */\n/* (the algorithms don't scale beyond 3) */\n#define MAXPROCS 4\n\n#define MAXSTR 256\n\n/* Faker configuration */\ntypedef struct _FakerConfig\n{\n  char allowindirect;\n  char autotest;\n  char client[MAXSTR];\n  int compress;\n  char config[MAXSTR];\n  char defaultfbconfig[MAXSTR];\n  char dlsymloader;\n  char drawable;\n  double flushdelay;\n  int forcealpha;\n  double fps;\n  double gamma;\n  unsigned char gamma_lut[256];\n  unsigned short gamma_lut16[65536];\n  char glflushtrigger;\n  char gllib[MAXSTR];\n  char glxvendor[MAXSTR];\n  char gui;\n  unsigned int guikey;\n  char guikeyseq[MAXSTR];\n  unsigned int guimod;\n  char interframe;\n  char localdpystring[MAXSTR];\n  char log[MAXSTR];\n  char logo;\n  int np;\n  int port;\n  char probeglx;\n  int qual;\n  char readback;\n  double refreshrate;\n  int samples;\n  char spoil;\n  char spoillast;\n  char ssl;\n  int stereo;\n  int subsamp;\n  char sync;\n  int tilesize;\n  char trace;\n  int transpixel;\n  char transport[MAXSTR];\n  char transvalid[RR_TRANSPORTOPT];\n  char trapx11;\n  char vendor[MAXSTR];\n  char verbose;\n  char wm;\n  char x11lib[MAXSTR];\n  char fakeXCB;\n  char xcblib[MAXSTR];\n  char xcbglxlib[MAXSTR];\n  char xcbkeysymslib[MAXSTR];\n  char xcbx11lib[MAXSTR];\n  char excludeddpys[MAXSTR];\n} FakerConfig;\n\n#if !defined(__SUNPRO_CC) && !defined(__SUNPRO_C)\n#pragma pack()\n#endif\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/server/gefaker.c": "/* Copyright (C)2007 Sun Microsystems, Inc.\n *\n * This library is free software and may be redistributed and/or modified under\n * the terms of the wxWindows Library License, Version 3.1 or (at your option)\n * any later version.  The full license is in the LICENSE.txt file included\n * with this distribution.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * wxWindows Library License for more details.\n */\n\n#include <dlfcn.h>\n#include <pthread.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n\nstatic pthread_mutex_t globalmutex=PTHREAD_MUTEX_INITIALIZER;\n\ntypedef\tchar* (*_getenvType)(const char *);\nstatic _getenvType __getenv=NULL;\n\n\nstatic void __loadsymbol(void)\n{\n\tconst char *err=NULL;\n\tpthread_mutex_lock(&globalmutex);\n\tif(__getenv) {pthread_mutex_unlock(&globalmutex);  return;}\n\tdlerror();  /* Clear error state */\n\t__getenv=(_getenvType)dlsym(RTLD_NEXT, \"getenv\");\n\terr=dlerror();\n\tif(err) fprintf(stderr, \"[gefaker] %s\\n\", err);\n\telse if(!__getenv) fprintf(stderr, \"[gefaker] Could not load symbol.\\n\");\n\tpthread_mutex_unlock(&globalmutex);\n}\n\n\nchar *getenv(const char *name)\n{\n\tchar *env=NULL;  int verbose=0;\n\t__loadsymbol();\n\tif(!__getenv) return NULL;\n\tif((env=__getenv(\"VGL_VERBOSE\"))!=NULL && strlen(env)>0\n\t\t&& !strncmp(env, \"1\", 1)) verbose=1;\n\tif(name && (!strcmp(name, \"LD_PRELOAD\")\n\t#ifdef sun\n\t\t|| !strcmp(name, \"LD_PRELOAD_32\") || !strcmp(name, \"LD_PRELOAD_64\")\n\t#endif\n\t))\n\t{\n\t\tif(verbose)\n\t\t\tfprintf(stderr, \"[VGL] NOTICE: Fooling application into thinking that LD_PRELOAD is unset\\n\");\n\t\treturn NULL;\n\t}\n\telse return __getenv(name);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/server/TransPlugin.cpp": "/* Copyright (C)2009-2011, 2014 D. R. Commander\n *\n * This library is free software and may be redistributed and/or modified under\n * the terms of the wxWindows Library License, Version 3.1 or (at your option)\n * any later version.  The full license is in the LICENSE.txt file included\n * with this distribution.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * wxWindows Library License for more details.\n */\n\n#include \"TransPlugin.h\"\n#include \"fakerconfig.h\"\n#include <dlfcn.h>\n#include <string.h>\n#include \"Error.h\"\n\nusing namespace vglutil;\nusing namespace vglserver;\n\n\n#undef _throw\n#define _throw(m) throw(Error(\"transport plugin\", m, -1))\n\n\nstatic void *loadsym(void *dllhnd, const char *symbol)\n{\n\tvoid *sym=NULL;  const char *err=NULL;\n\tsym=dlsym(dllhnd, (char *)symbol);\n\tif(!sym)\n\t{\n\t\terr=dlerror();\n\t\tif(err) _throw(err);\n\t\telse _throw(\"Could not load symbol\");\n\t}\n\treturn sym;\n}\n\n\nTransPlugin::TransPlugin(Display *dpy, Window win, char *name)\n{\n\tif(!name || strlen(name)<1) _throw(\"Transport name is empty or NULL!\");\n\tconst char *err=NULL;\n\tCriticalSection::SafeLock l(mutex);\n\tdlerror();  // Clear error state\n\tchar filename[MAXSTR];\n\tsnprintf(filename, MAXSTR-1, \"libvgltrans_%s.so\", name);\n\tdllhnd=dlopen(filename, RTLD_NOW);\n\tif(!dllhnd)\n\t{\n\t\terr=dlerror();\n\t\tif(err) _throw(err);\n\t\telse _throw(\"Could not open transport plugin\");\n\t}\n\t_RRTransInit=(_RRTransInitType)loadsym(dllhnd, \"RRTransInit\");\n\t_RRTransConnect=(_RRTransConnectType)loadsym(dllhnd, \"RRTransConnect\");\n\t_RRTransGetFrame=(_RRTransGetFrameType)loadsym(dllhnd, \"RRTransGetFrame\");\n\t_RRTransReady=(_RRTransReadyType)loadsym(dllhnd, \"RRTransReady\");\n\t_RRTransSynchronize=(_RRTransSynchronizeType)loadsym(dllhnd, \"RRTransSynchronize\");\n\t_RRTransSendFrame=(_RRTransSendFrameType)loadsym(dllhnd, \"RRTransSendFrame\");\n\t_RRTransDestroy=(_RRTransDestroyType)loadsym(dllhnd, \"RRTransDestroy\");\n\t_RRTransGetError=(_RRTransGetErrorType)loadsym(dllhnd, \"RRTransGetError\");\n\tif(!(handle=_RRTransInit(dpy, win, &fconfig))) _throw(_RRTransGetError());\n}\n\n\nTransPlugin::~TransPlugin(void)\n{\n\tCriticalSection::SafeLock l(mutex);\n\tdestroy();\n\tif(dllhnd) dlclose(dllhnd);\n}\n\n\nvoid TransPlugin::connect(char *receiverName, int port)\n{\n\tCriticalSection::SafeLock l(mutex);\n\tint ret=_RRTransConnect(handle, receiverName, port);\n\tif(ret<0) _throw(_RRTransGetError());\n}\n\n\nvoid TransPlugin::destroy(void)\n{\n\tCriticalSection::SafeLock l(mutex);\n\tint ret=_RRTransDestroy(handle);\n\tif(ret<0) _throw(_RRTransGetError());\n}\n\n\nint TransPlugin::ready(void)\n{\n\tCriticalSection::SafeLock l(mutex);\n\tint ret=_RRTransReady(handle);\n\tif(ret<0) _throw(_RRTransGetError());\n\treturn ret;\n}\n\n\nvoid TransPlugin::synchronize(void)\n{\n\tCriticalSection::SafeLock l(mutex);\n\tint ret=_RRTransSynchronize(handle);\n\tif(ret<0) _throw(_RRTransGetError());\n}\n\n\nRRFrame *TransPlugin::getFrame(int width, int height, int format, bool stereo)\n{\n\tCriticalSection::SafeLock l(mutex);\n\tRRFrame *ret=_RRTransGetFrame(handle, width, height, format, stereo);\n\tif(!ret) _throw(_RRTransGetError());\n\treturn ret;\n}\n\n\nvoid TransPlugin::sendFrame(RRFrame *frame, bool sync)\n{\n\tCriticalSection::SafeLock l(mutex);\n\tint ret=_RRTransSendFrame(handle, frame, sync);\n\tif(ret<0) _throw(_RRTransGetError());\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/server/faker.cpp": "/* Copyright (C)2004 Landmark Graphics Corporation\n * Copyright (C)2005, 2006 Sun Microsystems, Inc.\n * Copyright (C)2009, 2011, 2013-2016 D. R. Commander\n *\n * This library is free software and may be redistributed and/or modified under\n * the terms of the wxWindows Library License, Version 3.1 or (at your option)\n * any later version.  The full license is in the LICENSE.txt file included\n * with this distribution.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * wxWindows Library License for more details.\n */\n\n#include <unistd.h>\n#include \"Mutex.h\"\n#include \"ConfigHash.h\"\n#include \"ContextHash.h\"\n#include \"DisplayHash.h\"\n#include \"GLXDrawableHash.h\"\n#include \"GlobalCriticalSection.h\"\n#include \"PixmapHash.h\"\n#include \"ReverseConfigHash.h\"\n#include \"VisualHash.h\"\n#include \"WindowHash.h\"\n#include \"fakerconfig.h\"\n#include \"threadlocal.h\"\n#include <dlfcn.h>\n\n\nusing namespace vglutil;\nusing namespace vglserver;\n\n\nnamespace vglfaker\n{\n\nDisplay *dpy3D=NULL;\nbool deadYet=false;\nVGL_THREAD_LOCAL(TraceLevel, long, 0)\nVGL_THREAD_LOCAL(FakerLevel, long, 0)\nVGL_THREAD_LOCAL(ExcludeCurrent, bool, false)\n\n\nstatic void cleanup(void)\n{\n\tif(PixmapHash::isAlloc()) pmhash.kill();\n\tif(VisualHash::isAlloc()) vishash.kill();\n\tif(ConfigHash::isAlloc()) cfghash.kill();\n\tif(ReverseConfigHash::isAlloc()) rcfghash.kill();\n\tif(ContextHash::isAlloc()) ctxhash.kill();\n\tif(GLXDrawableHash::isAlloc()) glxdhash.kill();\n\tif(WindowHash::isAlloc()) winhash.kill();\n\tif(DisplayHash::isAlloc()) dpyhash.kill();\n\tunloadSymbols();\n}\n\n\nvoid safeExit(int retcode)\n{\n\tbool shutdown;\n\n\tglobalMutex.lock(false);\n\tshutdown=deadYet;\n\tif(!deadYet)\n\t{\n\t\tdeadYet=true;\n\t\tcleanup();\n\t\tfconfig_deleteinstance();\n\t}\n\tglobalMutex.unlock(false);\n\tif(!shutdown) exit(retcode);\n\telse pthread_exit(0);\n}\n\n\nclass GlobalCleanup\n{\n\tpublic:\n\n\t\t~GlobalCleanup()\n\t\t{\n\t\t\tvglfaker::GlobalCriticalSection *gcs=\n\t\t\t\tvglfaker::GlobalCriticalSection::getInstance(false);\n\t\t\tif(gcs) gcs->lock(false);\n\t\t\tfconfig_deleteinstance();\n\t\t\tdeadYet=true;\n\t\t\tif(gcs) gcs->unlock(false);\n\t\t}\n};\nGlobalCleanup globalCleanup;\n\n\n// Used when VGL_TRAPX11=1\n\nint xhandler(Display *dpy, XErrorEvent *xe)\n{\n\tchar temps[256];\n\n\ttemps[0]=0;\n\tXGetErrorText(dpy, xe->error_code, temps, 255);\n\tvglout.PRINT(\"[VGL] WARNING: X11 error trapped\\n[VGL]    Error:  %s\\n[VGL]    XID:    0x%.8x\\n\",\n\t\ttemps, xe->resourceid);\n\treturn 0;\n}\n\n\n// Called from XOpenDisplay(), unless a GLX function is called first\n\nvoid init(void)\n{\n\tstatic int init=0;\n\n\tif(init) return;\n\tGlobalCriticalSection::SafeLock l(globalMutex);\n\tif(init) return;\n\tinit=1;\n\n\tfconfig_reloadenv();\n\tif(strlen(fconfig.log)>0) vglout.logTo(fconfig.log);\n\n\tif(fconfig.verbose)\n\t\tvglout.println(\"[VGL] %s v%s %d-bit (Build %s)\",\n\t\t\t__APPNAME, __VERSION, (int)sizeof(size_t)*8, __BUILD);\n\n\tif(getenv(\"VGL_DEBUG\"))\n\t{\n\t\tvglout.print(\"[VGL] Attach debugger to process %d ...\\n\", getpid());\n\t\tfgetc(stdin);\n\t}\n\tif(fconfig.trapx11) XSetErrorHandler(xhandler);\n}\n\n\nDisplay *init3D(void)\n{\n\tinit();\n\n\tif(!dpy3D)\n\t{\n\t\tGlobalCriticalSection::SafeLock l(globalMutex);\n\t\tif(!dpy3D)\n\t\t{\n\t\t\tif(fconfig.verbose)\n\t\t\t\tvglout.println(\"[VGL] Opening connection to 3D X server %s\",\n\t\t\t\t\tstrlen(fconfig.localdpystring)>0? fconfig.localdpystring:\"(default)\");\n\t\t\tif((dpy3D=_XOpenDisplay(fconfig.localdpystring))==NULL)\n\t\t\t{\n\t\t\t\tvglout.print(\"[VGL] ERROR: Could not open display %s.\\n\",\n\t\t\t\t\tfconfig.localdpystring);\n\t\t\t\tsafeExit(1);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dpy3D;\n}\n\n\nbool excludeDisplay(char *name)\n{\n\tfconfig_reloadenv();\n\n\tchar *dpyList=strdup(fconfig.excludeddpys);\n\tchar *excluded=strtok(dpyList, \" \\t,\");\n\twhile(excluded)\n\t{\n\t\tif(!strcasecmp(name, excluded))\n\t\t{\n\t\t\tfree(dpyList);  return true;\n\t\t}\n\t\texcluded=strtok(NULL, \" \\t,\");\n\t}\n\tfree(dpyList);\n\treturn false;\n}\n\n}  // namespace\n\n\nextern \"C\" {\n\n// This is the \"real\" version of dlopen(), which is called by the interposed\n// version of dlopen() in libdlfaker.  Can't recall why this is here and not\n// in dlfaker, but it seems like there was a good reason.\n\nvoid *_vgl_dlopen(const char *file, int mode)\n{\n\tif(!__dlopen)\n\t{\n\t\tvglfaker::GlobalCriticalSection::SafeLock l(globalMutex);\n\t\tif(!__dlopen)\n\t\t{\n\t\t\tdlerror();  // Clear error state\n\t\t\t__dlopen=(_dlopenType)dlsym(RTLD_NEXT, \"dlopen\");\n\t\t\tchar *err=dlerror();\n\t\t\tif(!__dlopen)\n\t\t\t{\n\t\t\t\tvglout.print(\"[VGL] ERROR: Could not load function \\\"dlopen\\\"\\n\");\n\t\t\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);\n\t\t\t\tvglfaker::safeExit(1);\n\t\t\t}\n\t\t}\n\t}\n\treturn __dlopen(file, mode);\n}\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/server/dlfakerut.c": "/* Copyright (C)2006 Sun Microsystems, Inc.\n * Copyright (C)2009, 2014-2015, 2017 D. R. Commander\n *\n * This library is free software and may be redistributed and/or modified under\n * the terms of the wxWindows Library License, Version 3.1 or (at your option)\n * any later version.  The full license is in the LICENSE.txt file included\n * with this distribution.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * wxWindows Library License for more details.\n */\n\n#include <GL/glx.h>\n#include <X11/Xlib.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n\n#define _throw(m) { fprintf(stderr, \"ERROR: %s\\n\", m);  goto bailout; }\n\n\ntypedef XVisualInfo* (*_glXChooseVisualType)(Display *, int, int *);\n_glXChooseVisualType _glXChooseVisual=NULL;\n\ntypedef GLXContext (*_glXCreateContextType)(Display *, XVisualInfo *,\n\tGLXContext, Bool);\n_glXCreateContextType _glXCreateContext=NULL;\n\ntypedef GLXContext (*_glXDestroyContextType)(Display *, GLXContext);\n_glXDestroyContextType _glXDestroyContext=NULL;\n\ntypedef void (*(*_glXGetProcAddressARBType)(const GLubyte*))(void);\n_glXGetProcAddressARBType _glXGetProcAddressARB=NULL;\n\ntypedef Bool (*_glXMakeCurrentType)(Display *, GLXDrawable, GLXContext);\n_glXMakeCurrentType _glXMakeCurrent=NULL;\n\ntypedef void (*_glXSwapBuffersType)(Display *, GLXDrawable);\n_glXSwapBuffersType _glXSwapBuffers=NULL;\n\ntypedef void (*_glClearType)(GLbitfield);\n_glClearType _glClear=NULL;\n\ntypedef void (*_glClearColorType)(GLclampf, GLclampf, GLclampf, GLclampf);\n_glClearColorType _glClearColor=NULL;\n\nvoid *gldllhnd=NULL;\n\n#define LSYM(s)  \\\n\tdlerror();  \\\n\t_##s=(_##s##Type)dlsym(gldllhnd, #s);  \\\n\terr=dlerror();  \\\n\tif(err) _throw(err)  \\\n\telse if(!_##s) _throw(\"Could not load symbol \"#s)\n\nvoid loadSymbols1(char *prefix)\n{\n\tconst char *err=NULL;\n\tif(prefix)\n\t{\n\t\tchar temps[256];\n\t\tsnprintf(temps, 255, \"%s/libGL.so\", prefix);\n\t\tgldllhnd=dlopen(temps, RTLD_NOW);\n\t}\n\telse gldllhnd=dlopen(\"libGL.so\", RTLD_NOW);\n\terr=dlerror();\n\tif(err) _throw(err)\n\telse if(!gldllhnd) _throw(\"Could not open libGL\")\n\n\tLSYM(glXChooseVisual);\n\tLSYM(glXCreateContext);\n\tLSYM(glXDestroyContext);\n\tLSYM(glXMakeCurrent);\n\tLSYM(glXSwapBuffers);\n\tLSYM(glClear);\n\tLSYM(glClearColor);\n\treturn;\n\n\tbailout:\n\texit(1);\n}\n\nvoid unloadSymbols1(void)\n{\n\tif(gldllhnd) dlclose(gldllhnd);\n}\n\n\n#define LSYM2(s)  \\\n\t_##s=(_##s##Type)_glXGetProcAddressARB((const GLubyte *)#s);  \\\n\tif(!_##s) _throw(\"Could not load symbol \"#s)\n\nvoid loadSymbols2(void)\n{\n\tconst char *err=NULL;\n\n\tLSYM(glXGetProcAddressARB);\n\tLSYM2(glXChooseVisual);\n\tLSYM2(glXCreateContext);\n\tLSYM2(glXDestroyContext);\n\tLSYM2(glXMakeCurrent);\n\tLSYM2(glXSwapBuffers);\n\tLSYM2(glClear);\n\tLSYM2(glClearColor);\n\treturn;\n\n\tbailout:\n\texit(1);\n}\n\n\n/* Test whether libvglfaker's version of dlopen() is discriminating enough.\n   This will fail on VGL 2.1.2 and prior */\n\ntypedef void (*_myTestFunctionType)(void);\n_myTestFunctionType _myTestFunction=NULL;\n\nvoid nameMatchTest(void)\n{\n\tconst char *err=NULL;\n\n\tfprintf(stderr, \"dlopen() name matching test:\\n\");\n\tgldllhnd=dlopen(\"libGLdlfakerut.so\", RTLD_NOW);\n\terr=dlerror();\n\tif(err) _throw(err)\n\telse if(!gldllhnd) _throw(\"Could not open libGLdlfakerut\")\n\n\tLSYM(myTestFunction);\n\t_myTestFunction();\n\tdlclose(gldllhnd);\n\tgldllhnd=NULL;\n\treturn;\n\n\tbailout:\n\texit(1);\n}\n\n\n#include \"dlfakerut-test.c\"\n\n\n#ifdef RTLD_DEEPBIND\n/* Test whether libdlfaker.so properly circumvents RTLD_DEEPBIND */\n\ntypedef void (*_testType)(const char *);\n_testType _test=NULL;\n\nvoid deepBindTest(void)\n{\n\tconst char *err=NULL;\n\n\tgldllhnd=dlopen(\"libdeepbindtest.so\", RTLD_NOW|RTLD_DEEPBIND);\n\terr=dlerror();\n\tif(err) _throw(err)\n\telse if(!gldllhnd) _throw(\"Could not open libdlfakerut\")\n\n\tLSYM(test);\n\t_test(\"RTLD_DEEPBIND test\");\n\tdlclose(gldllhnd);\n\tgldllhnd=NULL;\n\treturn;\n\n\tbailout:\n\texit(1);\n}\n#endif\n\n\nint main(int argc, char **argv)\n{\n\tchar *env, *prefix=NULL;\n\n\tif(argc>2 && !strcasecmp(argv[1], \"--prefix\"))\n\t{\n\t\tprefix=argv[2];\n\t\tfprintf(stderr, \"prefix = %s\\n\", prefix);\n\t}\n\n\tif(putenv((char *)\"VGL_AUTOTEST=1\")==-1\n\t\t|| putenv((char *)\"VGL_SPOIL=0\")==-1)\n\t\t_throw(\"putenv() failed!\\n\");\n\n\tenv=getenv(\"LD_PRELOAD\");\n\tfprintf(stderr, \"LD_PRELOAD = %s\\n\", env? env:\"(NULL)\");\n\t#ifdef sun\n\tenv=getenv(\"LD_PRELOAD_32\");\n\tfprintf(stderr, \"LD_PRELOAD_32 = %s\\n\", env? env:\"(NULL)\");\n\tenv=getenv(\"LD_PRELOAD_64\");\n\tfprintf(stderr, \"LD_PRELOAD_64 = %s\\n\", env? env:\"(NULL)\");\n\t#endif\n\n\tfprintf(stderr, \"\\n\");\n\tnameMatchTest();\n\n\tloadSymbols1(prefix);\n\ttest(\"dlopen() test\");\n\n\tloadSymbols2();\n\ttest(\"glXGetProcAddressARB() test\");\n\n\tunloadSymbols1();\n\n\t#ifdef RTLD_DEEPBIND\n\tdeepBindTest();\n\t#endif\n\n\tbailout:\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/server/fakerconfig.cpp": "/* Copyright (C)2009-2016 D. R. Commander\n *\n * This library is free software and may be redistributed and/or modified under\n * the terms of the wxWindows Library License, Version 3.1 or (at your option)\n * any later version.  The full license is in the LICENSE.txt file included\n * with this distribution.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * wxWindows Library License for more details.\n */\n\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"Error.h\"\n#include \"Log.h\"\n#include \"Mutex.h\"\n#include \"fakerconfig.h\"\n#include <stdio.h>\n#include <X11/keysym.h>\n#if FCONFIG_USESHM==1\n#include <sys/shm.h>\n#include <sys/ipc.h>\n#include <sys/types.h>\n#endif\n#include \"vglutil.h\"\n#include <X11/Xatom.h>\n#ifdef USEXV\n#include <X11/extensions/Xv.h>\n#include <X11/extensions/Xvlib.h>\n#endif\n\nusing namespace vglutil;\n\n\n#define DEFQUAL 95\n\nstatic FakerConfig fconfig_env;\nstatic bool fconfig_envset=false;\n\n#if FCONFIG_USESHM==1\nstatic int fconfig_shmid=-1;\nint fconfig_getshmid(void) { return fconfig_shmid; }\n#endif\nstatic FakerConfig *fc=NULL;\n\n\n/* This is a hack necessary to defer the initialization of the recursive mutex\n   so MainWin will not interfere with it */\n\nclass DeferredCS : CriticalSection\n{\n\tpublic:\n\t\tDeferredCS() : isInit(false) {}\n\n\t\tDeferredCS *init(void)\n\t\t{\n\t\t\tif(!isInit)\n\t\t\t{\n\t\t\t\tisInit=true;\n\t\t\t\tpthread_mutexattr_t ma;\n\t\t\t\tpthread_mutexattr_init(&ma);\n\t\t\t\tpthread_mutexattr_settype(&ma, PTHREAD_MUTEX_RECURSIVE);\n\t\t\t\tpthread_mutex_init(&mutex, &ma);\n\t\t\t\tpthread_mutexattr_destroy(&ma);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\tprivate:\n\n\t\tbool isInit;\n};\n\nstatic DeferredCS fconfig_mutex;\n#define fcmutex ((CriticalSection &)(*fconfig_mutex.init()))\n\n\nstatic void fconfig_init(void);\n\n\nFakerConfig *fconfig_instance(void)\n{\n\tif(fc==NULL)\n\t{\n\t\tCriticalSection::SafeLock l(fcmutex);\n\t\tif(fc==NULL)\n\t\t{\n\t\t\t#if FCONFIG_USESHM==1\n\n\t\t\tvoid *addr=NULL;\n\t\t\tif((fconfig_shmid=shmget(IPC_PRIVATE, sizeof(FakerConfig),\n\t\t\t\tIPC_CREAT|0600))==-1)\n\t\t\t\t_throwunix();\n\t\t\tif((addr=shmat(fconfig_shmid, 0, 0))==(void *)-1) _throwunix();\n\t\t\tif(!addr)\n\t\t\t\t_throw(\"Could not attach to config structure in shared memory\");\n\t\t\t#ifdef linux\n\t\t\tshmctl(fconfig_shmid, IPC_RMID, 0);\n\t\t\t#endif\n\t\t\tchar *env=NULL;\n\t\t\tif((env=getenv(\"VGL_VERBOSE\"))!=NULL && strlen(env)>0\n\t\t\t\t&& !strncmp(env, \"1\", 1))\n\t\t\t\tvglout.println(\"[VGL] Shared memory segment ID for vglconfig: %d\",\n\t\t\t\t\tfconfig_shmid);\n\t\t\tfc=(FakerConfig *)addr;\n\n\t\t\t#else\n\n\t\t\tfc=new FakerConfig;\n\t\t\tif(!fc) _throw(\"Could not allocate config structure\");\n\n\t\t\t#endif\n\n\t\t\tfconfig_init();\n\t\t}\n\t}\n\treturn fc;\n}\n\n\nvoid fconfig_deleteinstance(void)\n{\n\tif(fc!=NULL)\n\t{\n\t\tCriticalSection::SafeLock l(fcmutex, false);\n\t\tif(fc!=NULL)\n\t\t{\n\t\t\t#if FCONFIG_USESHM==1\n\n\t\t\tshmdt((char *)fc);\n\t\t\tif(fconfig_shmid!=-1)\n\t\t\t{\n\t\t\t\tint ret=shmctl(fconfig_shmid, IPC_RMID, 0);\n\t\t\t\tchar *env=NULL;\n\t\t\t\tif((env=getenv(\"VGL_VERBOSE\"))!=NULL && strlen(env)>0\n\t\t\t\t\t&& !strncmp(env, \"1\", 1) && ret!=-1)\n\t\t\t\t\tvglout.println(\"[VGL] Removed shared memory segment %d\",\n\t\t\t\t\t\tfconfig_shmid);\n\t\t\t}\n\n\t\t\t#else\n\n\t\t\tdelete fc;\n\n\t\t\t#endif\n\n\t\t\tfc=NULL;\n\t\t}\n\t}\n}\n\n\nstatic void fconfig_init(void)\n{\n\tCriticalSection::SafeLock l(fcmutex);\n\tmemset(&fconfig, 0, sizeof(FakerConfig));\n\tmemset(&fconfig_env, 0, sizeof(FakerConfig));\n\tfconfig.compress=-1;\n\tstrncpy(fconfig.config, VGLCONFIG_PATH, MAXSTR);\n\t#if sun\n\tfconfig.dlsymloader=true;\n\t#endif\n\t#ifdef FAKEXCB\n\tfconfig.fakeXCB=1;\n\t#endif\n\tfconfig.forcealpha=0;\n\tfconfig_setgamma(fconfig, 1.0);\n\tfconfig.glflushtrigger=1;\n\tfconfig.gui=1;\n\tfconfig.guikey=XK_F9;\n\tfconfig.guimod=ShiftMask|ControlMask;\n\tfconfig.interframe=1;\n\tstrncpy(fconfig.localdpystring, \":0\", MAXSTR);\n\tfconfig.np=1;\n\tfconfig.port=-1;\n\tfconfig.probeglx=1;\n\tfconfig.qual=DEFQUAL;\n\tfconfig.readback=RRREAD_PBO;\n\tfconfig.refreshrate=60.0;\n\tfconfig.samples=-1;\n\tfconfig.spoil=1;\n\tfconfig.spoillast=1;\n\tfconfig.stereo=RRSTEREO_QUADBUF;\n\tfconfig.subsamp=-1;\n\tfconfig.tilesize=RR_DEFAULTTILESIZE;\n\tfconfig.transpixel=-1;\n\tfconfig_reloadenv();\n}\n\n\nstatic void fconfig_buildlut(FakerConfig &fc)\n{\n\tif(fc.gamma!=0.0 && fc.gamma!=1.0 && fc.gamma!=-1.0)\n\t{\n\t\tfor(int i=0; i<256; i++)\n\t\t{\n\t\t\tdouble g=fc.gamma>0.0? 1.0/fc.gamma : -fc.gamma;\n\t\t\tfc.gamma_lut[i]=(unsigned char)(255.*pow((double)i/255., g)+0.5);\n\t\t}\n\t\tfor(int i=0; i<65536; i++)\n\t\t{\n\t\t\tdouble g=fc.gamma>0.0? 1.0/fc.gamma : -fc.gamma;\n\t\t\tfc.gamma_lut16[i]=\n\t\t\t\t(unsigned short)(255.*pow((double)(i/256)/255., g)+0.5)<<8;\n\t\t\tfc.gamma_lut16[i]|=\n\t\t\t\t(unsigned short)(255.*pow((double)(i%256)/255., g)+0.5);\n\t\t}\n\t}\n}\n\n\n#define fetchenv_str(envvar, s) {  \\\n\tif((env=getenv(envvar))!=NULL && strlen(env)>0  \\\n\t\t&& (!fconfig_envset || strncmp(env, fconfig_env.s, MAXSTR-1))) {  \\\n\t\tstrncpy(fconfig.s, env, MAXSTR-1);  \\\n\t\tstrncpy(fconfig_env.s, env, MAXSTR-1);  \\\n\t}  \\\n}\n\n#define fetchenv_bool(envvar, b) {  \\\n\tif((env=getenv(envvar))!=NULL && strlen(env)>0) {  \\\n\t\tif(!strncmp(env, \"1\", 1) && (!fconfig_envset || fconfig_env.b!=1))  \\\n\t\t\tfconfig.b=fconfig_env.b=1;  \\\n\t\telse if(!strncmp(env, \"0\", 1) && (!fconfig_envset || fconfig_env.b!=0))  \\\n\t\t\tfconfig.b=fconfig_env.b=0;  \\\n\t}  \\\n}\n\n#define fetchenv_int(envvar, i, min, max) {  \\\n\tif((env=getenv(envvar))!=NULL && strlen(env)>0) {  \\\n\t\tchar *t=NULL;  int itemp=strtol(env, &t, 10);  \\\n\t\tif(t && t!=env && itemp>=min && itemp<=max  \\\n\t\t\t&& (!fconfig_envset || itemp!=fconfig_env.i))  \\\n\t\t\tfconfig.i=fconfig_env.i=itemp;  \\\n\t}  \\\n}\n\n#define fetchenv_dbl(envvar, d, min, max) {  \\\n\tchar *temp=NULL;  \\\n\tif((temp=getenv(envvar))!=NULL && strlen(temp)>0) {  \\\n\t\tchar *t=NULL;  double dtemp=strtod(temp, &t);  \\\n\t\tif(t && t!=temp && dtemp>=min && dtemp<=max  \\\n\t\t\t&& (!fconfig_envset || dtemp!=fconfig_env.d))  \\\n\t\t\tfconfig.d=fconfig_env.d=dtemp;  \\\n\t}  \\\n}\n\n\nvoid fconfig_setgamma(FakerConfig &fc, double gamma)\n{\n\tfc.gamma=gamma;\n\tfconfig_buildlut(fc);\n}\n\n\nvoid fconfig_reloadenv(void)\n{\n\tchar *env;\n\n\tCriticalSection::SafeLock l(fcmutex);\n\n\tfetchenv_bool(\"VGL_ALLOWINDIRECT\", allowindirect);\n\tfetchenv_bool(\"VGL_AUTOTEST\", autotest);\n\tfetchenv_str(\"VGL_CLIENT\", client);\n\tif((env=getenv(\"VGL_SUBSAMP\"))!=NULL && strlen(env)>0)\n\t{\n\t\tint subsamp=-1;\n\t\tif(!strnicmp(env, \"G\", 1)) subsamp=0;\n\t\telse\n\t\t{\n\t\t\tchar *t=NULL;  int itemp=strtol(env, &t, 10);\n\t\t\tif(t && t!=env)\n\t\t\t{\n\t\t\t\tswitch(itemp)\n\t\t\t\t{\n\t\t\t\t\tcase 0:                              subsamp=0;  break;\n\t\t\t\t\tcase 444: case 11: case 1:           subsamp=1;  break;\n\t\t\t\t\tcase 422: case 21: case 2:           subsamp=2;  break;\n\t\t\t\t\tcase 411: case 420: case 22: case 4: subsamp=4;  break;\n\t\t\t\t\tcase 410: case 42: case 8:           subsamp=8;  break;\n\t\t\t\t\tcase 44:  case 16:                   subsamp=16;  break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(subsamp>=0 && (!fconfig_envset || fconfig_env.subsamp!=subsamp))\n\t\t\tfconfig.subsamp=fconfig_env.subsamp=subsamp;\n\t}\n\tfetchenv_str(\"VGL_TRANSPORT\", transport);\n\tif((env=getenv(\"VGL_COMPRESS\"))!=NULL && strlen(env)>0)\n\t{\n\t\tchar *t=NULL;  int itemp=strtol(env, &t, 10);\n\t\tint compress=-1;\n\t\tif(t && t!=env && itemp>=0\n\t\t\t&& (itemp<RR_COMPRESSOPT || strlen(fconfig.transport)>0))\n\t\t\tcompress=itemp;\n\t\telse if(!strnicmp(env, \"p\", 1)) compress=RRCOMP_PROXY;\n\t\telse if(!strnicmp(env, \"j\", 1)) compress=RRCOMP_JPEG;\n\t\telse if(!strnicmp(env, \"r\", 1)) compress=RRCOMP_RGB;\n\t\telse if(!strnicmp(env, \"x\", 1)) compress=RRCOMP_XV;\n\t\telse if(!strnicmp(env, \"y\", 1)) compress=RRCOMP_YUV;\n\t\tif(compress>=0 && (!fconfig_envset || fconfig_env.compress!=compress))\n\t\t{\n\t\t\tfconfig_setcompress(fconfig, compress);\n\t\t\tfconfig_env.compress=compress;\n\t\t}\n\t}\n\tfetchenv_str(\"VGL_CONFIG\", config);\n\tfetchenv_str(\"VGL_DEFAULTFBCONFIG\", defaultfbconfig);\n\tif((env=getenv(\"VGL_DISPLAY\"))!=NULL && strlen(env)>0)\n\t{\n\t\tif(!fconfig_envset || strncmp(env, fconfig_env.localdpystring, MAXSTR-1))\n\t\t{\n\t\t\tstrncpy(fconfig.localdpystring, env, MAXSTR-1);\n\t\t\tstrncpy(fconfig_env.localdpystring, env, MAXSTR-1);\n\t\t}\n\t}\n\tfetchenv_bool(\"VGL_DLSYM\", dlsymloader);\n\tif((env=getenv(\"VGL_DRAWABLE\"))!=NULL && strlen(env)>0)\n\t{\n\t\tint drawable=-1;\n\t\tif(!strnicmp(env, \"PB\", 2)) drawable=RRDRAWABLE_PBUFFER;\n\t\telse if(!strnicmp(env, \"PI\", 2)) drawable=RRDRAWABLE_PIXMAP;\n\t\telse\n\t\t{\n\t\t\tchar *t=NULL;  int itemp=strtol(env, &t, 10);\n\t\t\tif(t && t!=env && itemp>=0 && itemp<RR_DRAWABLEOPT) drawable=itemp;\n\t\t}\n\t\tif(drawable>=0 && (!fconfig_envset || fconfig_env.drawable!=drawable))\n\t\t\tfconfig.drawable=fconfig_env.drawable=drawable;\n\t}\n\tfetchenv_str(\"VGL_EXCLUDE\", excludeddpys);\n\t#ifdef FAKEXCB\n\tfetchenv_bool(\"VGL_FAKEXCB\", fakeXCB);\n\t#endif\n\tfetchenv_bool(\"VGL_FORCEALPHA\", forcealpha);\n\tfetchenv_dbl(\"VGL_FPS\", fps, 0.0, 1000000.0);\n\tif((env=getenv(\"VGL_GAMMA\"))!=NULL && strlen(env)>0)\n\t{\n\t\tif(!strcmp(env, \"1\"))\n\t\t{\n\t\t\tif(!fconfig_envset || fconfig_env.gamma!=2.22)\n\t\t\t{\n\t\t\t\tfconfig_env.gamma=2.22;\n\t\t\t\tfconfig_setgamma(fconfig, 2.22);\n\t\t\t}\n\t\t}\n\t\telse if(!strcmp(env, \"0\"))\n\t\t{\n\t\t\tif(!fconfig_envset || fconfig_env.gamma!=1.0)\n\t\t\t{\n\t\t\t\tfconfig_env.gamma=1.0;\n\t\t\t\tfconfig_setgamma(fconfig, 1.0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar *t=NULL;  double dtemp=strtod(env, &t);\n\t\t\tif(t && t!=env\n\t\t\t\t&& (!fconfig_envset || fconfig_env.gamma!=dtemp))\n\t\t\t{\n\t\t\t\tfconfig_env.gamma=dtemp;\n\t\t\t\tfconfig_setgamma(fconfig, dtemp);\n\t\t\t}\n\t\t}\n\t}\n\tfetchenv_bool(\"VGL_GLFLUSHTRIGGER\", glflushtrigger);\n\tfetchenv_str(\"VGL_GLLIB\", gllib);\n\tfetchenv_str(\"VGL_GLXVENDOR\", glxvendor);\n\tfetchenv_str(\"VGL_GUI\", guikeyseq);\n\tif(strlen(fconfig.guikeyseq)>0)\n\t{\n\t\tif(!stricmp(fconfig.guikeyseq, \"none\")) fconfig.gui=false;\n\t\telse\n\t\t{\n\t\t\tunsigned int mod=0, key=0;\n\t\t\tfor(unsigned int i=0; i<strlen(fconfig.guikeyseq); i++)\n\t\t\t\tfconfig.guikeyseq[i]=tolower(fconfig.guikeyseq[i]);\n\t\t\tif(strstr(fconfig.guikeyseq, \"ctrl\")) mod|=ControlMask;\n\t\t\tif(strstr(fconfig.guikeyseq, \"alt\")) mod|=Mod1Mask;\n\t\t\tif(strstr(fconfig.guikeyseq, \"shift\")) mod|=ShiftMask;\n\t\t\tif(strstr(fconfig.guikeyseq, \"f10\")) key=XK_F10;\n\t\t\telse if(strstr(fconfig.guikeyseq, \"f11\")) key=XK_F11;\n\t\t\telse if(strstr(fconfig.guikeyseq, \"f12\")) key=XK_F12;\n\t\t\telse if(strstr(fconfig.guikeyseq, \"f1\")) key=XK_F1;\n\t\t\telse if(strstr(fconfig.guikeyseq, \"f2\")) key=XK_F2;\n\t\t\telse if(strstr(fconfig.guikeyseq, \"f3\")) key=XK_F3;\n\t\t\telse if(strstr(fconfig.guikeyseq, \"f4\")) key=XK_F4;\n\t\t\telse if(strstr(fconfig.guikeyseq, \"f5\")) key=XK_F5;\n\t\t\telse if(strstr(fconfig.guikeyseq, \"f6\")) key=XK_F6;\n\t\t\telse if(strstr(fconfig.guikeyseq, \"f7\")) key=XK_F7;\n\t\t\telse if(strstr(fconfig.guikeyseq, \"f8\")) key=XK_F8;\n\t\t\telse if(strstr(fconfig.guikeyseq, \"f9\")) key=XK_F9;\n\t\t\tif(key) fconfig.guikey=key;  fconfig.guimod=mod;\n\t\t\tfconfig.gui=true;\n\t\t}\n\t}\n\tfetchenv_bool(\"VGL_INTERFRAME\", interframe);\n\tfetchenv_str(\"VGL_LOG\", log);\n\tfetchenv_bool(\"VGL_LOGO\", logo);\n\tfetchenv_int(\"VGL_NPROCS\", np, 1, min(numprocs(), MAXPROCS));\n\tfetchenv_int(\"VGL_PORT\", port, 0, 65535);\n\tfetchenv_bool(\"VGL_PROBEGLX\", probeglx);\n\tfetchenv_int(\"VGL_QUAL\", qual, 1, 100);\n\tif((env=getenv(\"VGL_READBACK\"))!=NULL && strlen(env)>0)\n\t{\n\t\tint readback=-1;\n\t\tif(!strnicmp(env, \"N\", 1)) readback=RRREAD_NONE;\n\t\telse if(!strnicmp(env, \"P\", 1)) readback=RRREAD_PBO;\n\t\telse if(!strnicmp(env, \"S\", 1)) readback=RRREAD_SYNC;\n\t\telse\n\t\t{\n\t\t\tchar *t=NULL;  int itemp=strtol(env, &t, 10);\n\t\t\tif(t && t!=env && itemp>=0 && itemp<RR_READBACKOPT) readback=itemp;\n\t\t}\n\t\tif(readback>=0 && (!fconfig_envset || fconfig_env.readback!=readback))\n\t\t\tfconfig.readback=fconfig_env.readback=readback;\n\t}\n\tfetchenv_dbl(\"VGL_REFRESHRATE\", refreshrate, 0.0, 1000000.0);\n\tfetchenv_int(\"VGL_SAMPLES\", samples, 0, 64);\n\tfetchenv_bool(\"VGL_SPOIL\", spoil);\n\tfetchenv_bool(\"VGL_SPOILLAST\", spoillast);\n\tfetchenv_bool(\"VGL_SSL\", ssl);\n\t{\n\t\tif((env=getenv(\"VGL_STEREO\"))!=NULL && strlen(env)>0)\n\t\t{\n\t\t\tint stereo=-1;\n\t\t\tif(!strnicmp(env, \"L\", 1)) stereo=RRSTEREO_LEYE;\n\t\t\telse if(!strnicmp(env, \"RC\", 2)) stereo=RRSTEREO_REDCYAN;\n\t\t\telse if(!strnicmp(env, \"R\", 1)) stereo=RRSTEREO_REYE;\n\t\t\telse if(!strnicmp(env, \"Q\", 1)) stereo=RRSTEREO_QUADBUF;\n\t\t\telse if(!strnicmp(env, \"GM\", 2)) stereo=RRSTEREO_GREENMAGENTA;\n\t\t\telse if(!strnicmp(env, \"BY\", 2)) stereo=RRSTEREO_BLUEYELLOW;\n\t\t\telse if(!strnicmp(env, \"I\", 2)) stereo=RRSTEREO_INTERLEAVED;\n\t\t\telse if(!strnicmp(env, \"TB\", 2)) stereo=RRSTEREO_TOPBOTTOM;\n\t\t\telse if(!strnicmp(env, \"SS\", 2)) stereo=RRSTEREO_SIDEBYSIDE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar *t=NULL;  int itemp=strtol(env, &t, 10);\n\t\t\t\tif(t && t!=env && itemp>=0 && itemp<RR_STEREOOPT) stereo=itemp;\n\t\t\t}\n\t\t\tif(stereo>=0 && (!fconfig_envset || fconfig_env.stereo!=stereo))\n\t\t\t\tfconfig.stereo=fconfig_env.stereo=stereo;\n\t\t}\n\t}\n\tfetchenv_bool(\"VGL_SYNC\", sync);\n\tfetchenv_int(\"VGL_TILESIZE\", tilesize, 8, 1024);\n\tfetchenv_bool(\"VGL_TRACE\", trace);\n\tfetchenv_int(\"VGL_TRANSPIXEL\", transpixel, 0, 255);\n\tfetchenv_bool(\"VGL_TRAPX11\", trapx11);\n\tfetchenv_str(\"VGL_XVENDOR\", vendor);\n\tfetchenv_bool(\"VGL_VERBOSE\", verbose);\n\tfetchenv_bool(\"VGL_WM\", wm);\n\tfetchenv_str(\"VGL_X11LIB\", x11lib);\n\t#ifdef FAKEXCB\n\tfetchenv_str(\"VGL_XCBLIB\", xcblib);\n\tfetchenv_str(\"VGL_XCBGLXLIB\", xcbglxlib);\n\tfetchenv_str(\"VGL_XCBKEYSYMSLIB\", xcbkeysymslib);\n\tfetchenv_str(\"VGL_XCBX11LIB\", xcbkeysymslib);\n\t#endif\n\n\tif(strlen(fconfig.transport)>0)\n\t{\n\t\tif(fconfig.compress<0) fconfig.compress=0;\n\t\tif(fconfig.subsamp<0) fconfig.subsamp=1;\n\t}\n\n\tfconfig_envset=true;\n}\n\n\nvoid fconfig_setdefaultsfromdpy(Display *dpy)\n{\n\tCriticalSection::SafeLock l(fcmutex);\n\n\tif(fconfig.compress<0)\n\t{\n\t\tbool useSunRay=false;\n\t\tAtom atom=None;\n\t\tif((atom=XInternAtom(dpy, \"_SUN_SUNRAY_SESSION\", True))!=None)\n\t\t\tuseSunRay=true;\n\t\tconst char *dstr=DisplayString(dpy);\n\t\tif((strlen(dstr) && dstr[0]==':') || (strlen(dstr)>5\n\t\t\t&& !strnicmp(dstr, \"unix\", 4)))\n\t\t{\n\t\t\tif(useSunRay) fconfig_setcompress(fconfig, RRCOMP_XV);\n\t\t\telse fconfig_setcompress(fconfig, RRCOMP_PROXY);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(useSunRay) fconfig_setcompress(fconfig, RRCOMP_YUV);\n\t\t\telse fconfig_setcompress(fconfig, RRCOMP_JPEG);\n\t\t}\n\t}\n\n\tif(fconfig.port<0)\n\t{\n\t\tfconfig.port=fconfig.ssl? RR_DEFAULTSSLPORT:RR_DEFAULTPORT;\n\t\tAtom atom=None;  unsigned long n=0, bytesLeft=0;\n\t\tint actualFormat=0;  Atom actualType=None;\n\t\tunsigned char *prop=NULL;\n\t\tif((atom=XInternAtom(dpy,\n\t\t\tfconfig.ssl? \"_VGLCLIENT_SSLPORT\":\"_VGLCLIENT_PORT\", True))!=None)\n\t\t{\n\t\t\tif(XGetWindowProperty(dpy, RootWindow(dpy, DefaultScreen(dpy)), atom,\n\t\t\t\t0, 1, False, XA_INTEGER, &actualType, &actualFormat, &n,\n\t\t\t\t&bytesLeft, &prop)==Success && n>=1 && actualFormat==16\n\t\t\t\t&& actualType==XA_INTEGER && prop)\n\t\t\t\tfconfig.port=*(unsigned short *)prop;\n\t\t\tif(prop) XFree(prop);\n\t\t}\n\t}\n\n\t#ifdef USEXV\n\n\tint k, port, nformats, dummy1, dummy2, dummy3;\n\tunsigned int i, j, nadaptors=0;\n\tXvAdaptorInfo *ai=NULL;\n\tXvImageFormatValues *ifv=NULL;\n\n\tif(XQueryExtension(dpy, \"XVideo\", &dummy1, &dummy2, &dummy3)\n\t\t&& XvQueryAdaptors(dpy, DefaultRootWindow(dpy), &nadaptors,\n\t\t&ai)==Success && nadaptors>=1 && ai)\n\t{\n\t\tport=-1;\n\t\tfor(i=0; i<nadaptors; i++)\n\t\t{\n\t\t\tfor(j=ai[i].base_id; j<ai[i].base_id+ai[i].num_ports; j++)\n\t\t\t{\n\t\t\t\tnformats=0;\n\t\t\t\tifv=XvListImageFormats(dpy, j, &nformats);\n\t\t\t\tif(ifv && nformats>0)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0; k<nformats; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ifv[k].id==0x30323449)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tXFree(ifv);  port=j;\n\t\t\t\t\t\t\tgoto found;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXFree(ifv);\n\t\t\t}\n\t\t}\n\t\tfound:\n\t\tXvFreeAdaptorInfo(ai);  ai=NULL;\n\t\tif(port!=-1) fconfig.transvalid[RRTRANS_XV]=1;\n\t}\n\n\t#endif\n}\n\n\nvoid fconfig_setcompress(FakerConfig &fc, int i)\n{\n\tif(i<0 || (i>=RR_COMPRESSOPT && strlen(fc.transport)==0)) return;\n\tCriticalSection::SafeLock l(fcmutex);\n\n\tbool is=(fc.compress>=0);\n\tfc.compress=i;\n\tif(strlen(fc.transport)>0) return;\n\tif(!is) fc.transvalid[_Trans[fc.compress]]=fc.transvalid[RRTRANS_X11]=1;\n\tif(fc.subsamp<0) fc.subsamp=_Defsubsamp[fc.compress];\n\tif(strlen(fc.transport)==0 && _Minsubsamp[fc.compress]>=0\n\t\t&& _Maxsubsamp[fc.compress]>=0)\n\t{\n\t\tif(fc.subsamp<_Minsubsamp[fc.compress]\n\t\t\t|| fc.subsamp>_Maxsubsamp[fc.compress])\n\t\t\tfc.subsamp=_Defsubsamp[fc.compress];\n\t}\n}\n\n\n#define prconfint(i) vglout.println(#i\"  =  %d\", (int)fc.i)\n#define prconfstr(s)  \\\n\tvglout.println(#s\"  =  \\\"%s\\\"\", strlen(fc.s)>0? fc.s:\"{Empty}\")\n#define prconfdbl(d) vglout.println(#d\"  =  %f\", fc.d)\n\nvoid fconfig_print(FakerConfig &fc)\n{\n\tprconfint(allowindirect);\n\tprconfstr(client);\n\tprconfint(compress);\n\tprconfstr(config);\n\tprconfstr(defaultfbconfig);\n\tprconfint(dlsymloader);\n\tprconfint(drawable);\n\tprconfstr(excludeddpys);\n\tprconfdbl(fps);\n\tprconfdbl(flushdelay);\n\tprconfint(forcealpha);\n\tprconfdbl(gamma);\n\tprconfint(glflushtrigger);\n\tprconfstr(gllib);\n\tprconfstr(glxvendor);\n\tprconfint(gui);\n\tprconfint(guikey);\n\tprconfstr(guikeyseq);\n\tprconfint(guimod);\n\tprconfint(interframe);\n\tprconfstr(localdpystring);\n\tprconfstr(log);\n\tprconfint(logo);\n\tprconfint(np);\n\tprconfint(port);\n\tprconfint(qual);\n\tprconfint(readback);\n\tprconfint(samples);\n\tprconfint(spoil);\n\tprconfint(spoillast);\n\tprconfint(ssl);\n\tprconfint(stereo);\n\tprconfint(subsamp);\n\tprconfint(sync);\n\tprconfint(tilesize);\n\tprconfint(trace);\n\tprconfint(transpixel);\n\tprconfint(transvalid[RRTRANS_X11]);\n\tprconfint(transvalid[RRTRANS_VGL]);\n\tprconfint(transvalid[RRTRANS_XV]);\n\tprconfint(trapx11);\n\tprconfstr(vendor);\n\tprconfint(verbose);\n\tprconfint(wm);\n\tprconfstr(x11lib);\n\t#ifdef FAKEXCB\n\tprconfstr(xcblib);\n\tprconfstr(xcbglxlib);\n\tprconfstr(xcbkeysymslib);\n\tprconfstr(xcbx11lib);\n\t#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/server/fakerut.cpp": "/* Copyright (C)2004 Landmark Graphics Corporation\n * Copyright (C)2005, 2006 Sun Microsystems, Inc.\n * Copyright (C)2010-2015, 2017 D. R. Commander\n *\n * This library is free software and may be redistributed and/or modified under\n * the terms of the wxWindows Library License, Version 3.1 or (at your option)\n * any later version.  The full license is in the LICENSE.txt file included\n * with this distribution.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * wxWindows Library License for more details.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#define GLX_GLXEXT_PROTOTYPES\n#define GL_GLEXT_PROTOTYPES\n#include \"glx.h\"\n#include <GL/glu.h>\n#include <X11/Xlib.h>\n#include <X11/keysym.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include \"Error.h\"\n#include \"Thread.h\"\n#include \"glext-vgl.h\"\n\nusing namespace vglutil;\n\n#ifndef GLX_RGBA_BIT\n#define GLX_RGBA_BIT 0x00000001\n#endif\n#ifndef GLX_RGBA_TYPE\n#define GLX_RGBA_TYPE 0x8014\n#endif\n#ifndef GLX_LARGEST_PBUFFER\n#define GLX_LARGEST_PBUFFER 0x801C\n#endif\n#ifndef GLX_PBUFFER_WIDTH\n#define GLX_PBUFFER_WIDTH 0x8041\n#endif\n#ifndef GLX_PBUFFER_HEIGHT\n#define GLX_PBUFFER_HEIGHT 0x8040\n#endif\n#ifndef GLX_WIDTH\n#define GLX_WIDTH 0x801D\n#endif\n#ifndef GLX_HEIGHT\n#define GLX_HEIGHT 0x801E\n#endif\n\n\n#define CLEAR_BUFFER(buffer, r, g, b, a) {  \\\n\tif(buffer>0) glDrawBuffer(buffer);  \\\n\tglClearColor(r, g, b, a);  \\\n\tglClear(GL_COLOR_BUFFER_BIT);  \\\n}\n\n\n#if 0\nvoid clickToContinue(Display *dpy)\n{\n\tXEvent e;\n\tprintf(\"Click mouse in window to continue ...\\n\");\n\twhile(1)\n\t{\n\t\tif(XNextEvent(dpy, &e)) break;\n\t\tif(e.type==ButtonPress) break;\n\t}\n}\n#endif\n\n// Same as _throw but without the line number\n#define _error(m) throw(Error(__FUNCTION__, m, 0))\n\n#define _prerror1(m, a1) {  \\\n\tchar temps[256];  \\\n\tsnprintf(temps, 255, m, a1);  \\\n\tthrow(Error(__FUNCTION__, temps, 0));  \\\n}\n\n#define _prerror2(m, a1, a2) {  \\\n\tchar temps[256];  \\\n\tsnprintf(temps, 255, m, a1, a2);  \\\n\tthrow(Error(__FUNCTION__, temps, 0));  \\\n}\n\n#define _prerror3(m, a1, a2, a3) {  \\\n\tchar temps[256];  \\\n\tsnprintf(temps, 255, m, a1, a2, a3);  \\\n\tthrow(Error(__FUNCTION__, temps, 0));  \\\n}\n\n#define _prerror5(m, a1, a2, a3, a4, a5) {  \\\n\tchar temps[256];  \\\n\tsnprintf(temps, 255, m, a1, a2, a3, a4, a5);  \\\n\tthrow(Error(__FUNCTION__, temps, 0));  \\\n}\n\n\nunsigned int checkBufferColor(void)\n{\n\tint i, viewport[4], ps=3;  unsigned int ret=0;\n\tunsigned char *buf=NULL;\n\n\ttry\n\t{\n\t\tviewport[0]=viewport[1]=viewport[2]=viewport[3]=0;\n\t\tglGetIntegerv(GL_VIEWPORT, viewport);\n\t\tif(viewport[2]<1 || viewport[3]<1) _throw(\"Invalid viewport dimensions\");\n\n\t\tif((buf=(unsigned char *)malloc(viewport[2]*viewport[3]*ps))==NULL)\n\t\t\t_throw(\"Could not allocate buffer\");\n\t\tmemset(buf, 128, viewport[2]*viewport[3]*ps);\n\n\t\tglPixelStorei(GL_PACK_ALIGNMENT, 1);\n\t\tglReadPixels(0, 0, viewport[2], viewport[3], GL_RGB, GL_UNSIGNED_BYTE,\n\t\t\tbuf);\n\t\tfor(i=3; i<viewport[2]*viewport[3]*ps; i+=ps)\n\t\t{\n\t\t\tif(buf[i]!=buf[0] || buf[i+1]!=buf[1] || buf[i+2]!=buf[2])\n\t\t\t\t_throw(\"Bogus data read back\");\n\t\t}\n\t\tret=buf[0] | (buf[1]<<8) | (buf[2]<<16);\n\t\tfree(buf);\n\t\treturn ret;\n\t}\n\tcatch(...)\n\t{\n\t\tif(buf) free(buf);\n\t\tthrow;\n\t}\n\treturn 0;\n}\n\n\nvoid checkWindowColor(Window win, unsigned int color, bool right=false)\n{\n\tchar *env=NULL, temps[80];  int fakerColor;\n\n\tif(right)\n\t\tsnprintf(temps, 79, \"__VGL_AUTOTESTRCLR%x\", (unsigned int)win);\n\telse\n\t\tsnprintf(temps, 79, \"__VGL_AUTOTESTCLR%x\", (unsigned int)win);\n\tif((env=getenv(temps))==NULL)\n\t\t_error(\"Can't communicate w/ faker\");\n\tif((fakerColor=atoi(env))<0 || fakerColor>0xffffff)\n\t\t_error(\"Bogus data read back\");\n\tif((unsigned int)fakerColor!=color)\n\t{\n\t\tif(right)\n\t\t\t_prerror2(\"R.buf is 0x%.6x, should be 0x%.6x\", fakerColor, color)\n\t\telse\n\t\t\t_prerror2(\"Color is 0x%.6x, should be 0x%.6x\", fakerColor, color)\n\t}\n}\n\n\nvoid checkFrame(Window win, int desiredReadbacks, int &lastFrame)\n{\n\tchar *env=NULL, temps[80];  int frame;\n\n\tsnprintf(temps, 79, \"__VGL_AUTOTESTFRAME%x\", (unsigned int)win);\n\tif((env=getenv(temps))==NULL || (frame=atoi(env))<1)\n\t\t_error(\"Can't communicate w/ faker\");\n\tif(frame-lastFrame!=desiredReadbacks && desiredReadbacks>=0)\n\t\t_prerror3(\"Expected %d readback%s, not %d\", desiredReadbacks,\n\t\t\tdesiredReadbacks==1? \"\":\"s\", frame-lastFrame);\n\tlastFrame=frame;\n}\n\n\nvoid checkCurrent(Display *dpy, GLXDrawable draw, GLXDrawable read,\n\tGLXContext ctx)\n{\n\tif(glXGetCurrentDisplay()!=dpy)\n\t\t_throw(\"glXGetCurrentDisplay() returned incorrect value\");\n\tif(glXGetCurrentDrawable()!=draw)\n\t\t_throw(\"glXGetCurrentDrawable() returned incorrect value\");\n\tif(glXGetCurrentReadDrawable()!=read)\n\t\t_throw(\"glXGetCurrentReadDrawable() returned incorrect value\");\n\tif(glXGetCurrentContext()!=ctx)\n\t\t_throw(\"glXGetCurrentContext() returned incorrect value\");\n}\n\n\nvoid checkReadbackState(int oldReadBuf, Display *dpy, GLXDrawable draw,\n\tGLXDrawable read, GLXContext ctx)\n{\n\tif(glXGetCurrentDisplay()!=dpy)\n\t\t_error(\"Current display changed\");\n\tif(glXGetCurrentDrawable()!=draw || glXGetCurrentReadDrawable()!=read)\n\t\t_error(\"Current drawable changed\");\n\tif(glXGetCurrentContext()!=ctx)\n\t\t_error(\"Context changed\");\n\tint readBuf=-1;\n\tglGetIntegerv(GL_READ_BUFFER, &readBuf);\n\tif(readBuf!=oldReadBuf)\n\t\t_error(\"Read buffer changed\");\n}\n\n\n// Check whether double buffering works properly\nbool doubleBufferTest(void)\n{\n\tunsigned int bgColor=0, fgColor=0;\n\tint oldReadBuf=GL_BACK, oldDrawBuf=GL_BACK;\n\n\tglGetIntegerv(GL_READ_BUFFER, &oldReadBuf);\n\tglGetIntegerv(GL_DRAW_BUFFER, &oldDrawBuf);\n\tCLEAR_BUFFER(GL_FRONT_AND_BACK, 0., 0., 0., 0.);\n\tCLEAR_BUFFER(GL_BACK, 1., 1., 1., 0.);\n\tCLEAR_BUFFER(GL_FRONT, 1., 0., 1., 0.);\n\tglReadBuffer(GL_BACK);\n\tbgColor=checkBufferColor();\n\tglReadBuffer(GL_FRONT);\n\tfgColor=checkBufferColor();\n\tglReadBuffer(oldReadBuf);\n\tglDrawBuffer(oldDrawBuf);\n\tif(bgColor==0xffffff && fgColor==0xff00ff) return true;\n\treturn false;\n}\n\n\n// Check whether stereo works properly\nbool stereoTest(void)\n{\n\tunsigned int rightColor=0, leftColor=0;\n\tint oldReadBuf=GL_BACK, oldDrawBuf=GL_BACK;\n\n\tglGetIntegerv(GL_READ_BUFFER, &oldReadBuf);\n\tglGetIntegerv(GL_DRAW_BUFFER, &oldDrawBuf);\n\tCLEAR_BUFFER(GL_FRONT_AND_BACK, 0., 0., 0., 0.);\n\tCLEAR_BUFFER(GL_RIGHT, 1., 1., 1., 0.);\n\tCLEAR_BUFFER(GL_LEFT, 1., 0., 1., 0.);\n\tglReadBuffer(GL_RIGHT);\n\trightColor=checkBufferColor();\n\tglReadBuffer(GL_LEFT);\n\tleftColor=checkBufferColor();\n\tglReadBuffer(oldReadBuf);\n\tglDrawBuffer(oldDrawBuf);\n\tif(rightColor==0xffffff && leftColor==0xff00ff) return true;\n\treturn false;\n}\n\n\ntypedef struct\n{\n\tGLfloat r, g, b;\n\tunsigned int bits;\n} Color;\n\n#define NC 6\nstatic Color colors[NC]=\n{\n\t{ 1., 0., 0., 0x0000ff },\n\t{ 0., 1., 0., 0x00ff00 },\n\t{ 0., 0., 1., 0xff0000 },\n\t{ 0., 1., 1., 0xffff00 },\n\t{ 1., 0., 1., 0xff00ff },\n\t{ 1., 1., 0., 0x00ffff }\n};\n\nclass TestColor\n{\n\tpublic:\n\n\t\tTestColor(int index_) : index(index_%NC)\n\t\t{\n\t\t}\n\n\t\tGLfloat& r(int offset=0) { return colors[(index+offset+NC)%NC].r; }\n\t\tGLfloat& g(int offset=0) { return colors[(index+offset+NC)%NC].g; }\n\t\tGLfloat& b(int offset=0) { return colors[(index+offset+NC)%NC].b; }\n\t\tvoid next(void) { index=(index+1)%NC; }\n\n\t\tunsigned int& bits(int offset=0)\n\t\t{\n\t\t\treturn colors[(index+offset+NC)%NC].bits;\n\t\t}\n\n\t\tvoid clear(int buffer)\n\t\t{\n\t\t\tCLEAR_BUFFER(buffer, r(), g(), b(), 0.)\n\t\t\tnext();\n\t\t}\n\n\tprivate:\n\n\t\tint index;\n};\n\n\n// This tests the faker's readback heuristics\nint readbackTest(bool stereo)\n{\n\tTestColor clr(0), sclr(3);\n\tDisplay *dpy=NULL;  Window win0=0, win1=0;\n\tint dpyw, dpyh, lastFrame0=0, lastFrame1=0, retval=1;\n\tint glxattrib[]={ GLX_DOUBLEBUFFER, GLX_RGBA, GLX_RED_SIZE, 8,\n\t\tGLX_GREEN_SIZE, 8, GLX_BLUE_SIZE, 8, None, None };\n\tint glxattrib13[]={ GLX_DOUBLEBUFFER, 1, GLX_RENDER_TYPE, GLX_RGBA_BIT,\n\t\tGLX_DRAWABLE_TYPE, GLX_WINDOW_BIT, GLX_RED_SIZE, 8, GLX_GREEN_SIZE, 8,\n\t\tGLX_BLUE_SIZE, 8, None, None, None };\n\tXVisualInfo *vis0=NULL, *vis1=NULL;  GLXFBConfig config=0, *configs=NULL;\n\tint n=0;\n\tGLXContext ctx0=0, ctx1=0;\n\tXSetWindowAttributes swa;\n\n\tif(stereo)\n\t{\n\t\tglxattrib[8]=glxattrib13[12]=GLX_STEREO;\n\t\tglxattrib13[13]=1;\n\t}\n\n\tprintf(\"Readback heuristics test \");\n\tif(stereo) printf(\"(Stereo RGB)\\n\\n\");\n\telse printf(\"(Mono RGB)\\n\\n\");\n\n\ttry\n\t{\n\t\tif(!(dpy=XOpenDisplay(0)))  _throw(\"Could not open display\");\n\t\tdpyw=DisplayWidth(dpy, DefaultScreen(dpy));\n\t\tdpyh=DisplayHeight(dpy, DefaultScreen(dpy));\n\n\t\tif((vis0=glXChooseVisual(dpy, DefaultScreen(dpy), glxattrib))==NULL)\n\t\t\t_throw(\"Could not find a suitable visual\");\n\t\tif((configs=glXChooseFBConfig(dpy, DefaultScreen(dpy), glxattrib13, &n))\n\t\t\t==NULL || n==0)\n\t\t\t_throw(\"Could not find a suitable FB config\");\n\t\tconfig=configs[0];\n\t\tXFree(configs);  configs=NULL;\n\n\t\tWindow root=RootWindow(dpy, DefaultScreen(dpy));\n\t\tswa.colormap=XCreateColormap(dpy, root, vis0->visual, AllocNone);\n\t\tswa.border_pixel=0;\n\t\tswa.event_mask=0;\n\t\tif((win0=XCreateWindow(dpy, root, 0, 0, dpyw/2, dpyh/2, 0, vis0->depth,\n\t\t\tInputOutput, vis0->visual, CWBorderPixel|CWColormap|CWEventMask,\n\t\t\t&swa))==0)\n\t\t\t_throw(\"Could not create window\");\n\t\tif(!(vis1=glXGetVisualFromFBConfig(dpy, config)))\n\t\t\t_throw(\"glXGetVisualFromFBConfig()\");\n\t\tswa.colormap=XCreateColormap(dpy, root, vis1->visual, AllocNone);\n\t\tif((win1=XCreateWindow(dpy, root, dpyw/2, 0, dpyw/2, dpyh/2, 0,\n\t\t\tvis1->depth, InputOutput, vis1->visual,\n\t\t\tCWBorderPixel|CWColormap|CWEventMask, &swa))==0)\n\t\t\t_throw(\"Could not create window\");\n\t\tXFree(vis1);  vis1=NULL;\n\n\t\tif((ctx0=glXCreateContext(dpy, vis0, 0, True))==NULL)\n\t\t\t_throw(\"Could not establish GLX context\");\n\t\tXFree(vis0);  vis0=NULL;\n\t\tif((ctx1=glXCreateNewContext(dpy, config, GLX_RGBA_TYPE, NULL, True))\n\t\t\t==NULL)\n\t\t\t_throw(\"Could not establish GLX context\");\n\n\t\tif(!glXMakeCurrent(dpy, win1, ctx0))\n\t\t\t_throw(\"Could not make context current\");\n\t\tcheckCurrent(dpy, win1, win1, ctx0);\n\t\tif(stereo && !stereoTest())\n\t\t{\n\t\t\t_throw(\"Stereo is not available or is not properly implemented\");\n\t\t}\n\t\tif(!doubleBufferTest())\n\t\t\t_throw(\"Double buffering appears to be broken\");\n\t\tglReadBuffer(GL_BACK);\n\n\t\tif(!glXMakeContextCurrent(dpy, win1, win0, ctx1))\n\t\t\t_throw(\"Could not make context current\");\n\t\tcheckCurrent(dpy, win1, win0, ctx1);\n\n\t\tXMapWindow(dpy, win0);\n\t\tXMapWindow(dpy, win1);\n\n\t\t// Faker should readback back buffer on a call to glXSwapBuffers()\n\t\ttry\n\t\t{\n\t\t\tprintf(\"glXSwapBuffers() [b]:          \");\n\t\t\tclr.clear(GL_BACK);  if(stereo) sclr.clear(GL_BACK_RIGHT);\n\t\t\tclr.clear(GL_FRONT);  if(stereo) sclr.clear(GL_FRONT_RIGHT);\n\t\t\tglReadBuffer(GL_FRONT);\n\t\t\t// Intentionally leave a pending GL error (VirtualGL should clear the\n\t\t\t// error state prior to readback)\n\t\t\tchar pixel[4];\n\t\t\tglReadPixels(0, 0, 1, 1, 0, GL_BYTE, pixel);\n\t\t\tglXSwapBuffers(dpy, win1);\n\t\t\tcheckReadbackState(GL_FRONT, dpy, win1, win0, ctx1);\n\t\t\tcheckFrame(win1, 1, lastFrame1);\n\t\t\tcheckWindowColor(win1, clr.bits(-2));\n\t\t\tif(stereo)\n\t\t\t\tcheckWindowColor(win1, sclr.bits(-2), true);\n\t\t\t// Make sure that glXSwapBuffers() actually swapped\n\t\t\tglDrawBuffer(GL_FRONT);\n\t\t\tglFinish();\n\t\t\tcheckReadbackState(GL_FRONT, dpy, win1, win0, ctx1);\n\t\t\tcheckFrame(win1, 1, lastFrame1);\n\t\t\tif(!stereo)\n\t\t\t{\n\t\t\t\t// NOTE: This doesn't work with stereo on nVidia hardware for some\n\t\t\t\t// reason.  One would expect that, after the call to glXSwapBuffers(),\n\t\t\t\t// GL_FRONT_LEFT would contain the contents of GL_BACK_LEFT,\n\t\t\t\t// GL_FRONT_RIGHT would contain the contents of GL_BACK_RIGHT,\n\t\t\t\t// and GL_BACK_* would be undefined, but what actually happens is that\n\t\t\t\t// the front buffers get swapped to the back buffers and the front\n\t\t\t\t// buffers become undefined.  This occurs irrespective of the presence\n\t\t\t\t// of VirtualGL, so it is believed to be a bug in nVidia's drivers.\n\t\t\t\tcheckWindowColor(win1, clr.bits(-2));\n\t\t\t\tif(stereo)\n\t\t\t\t\tcheckWindowColor(win1, sclr.bits(-2), true);\n\t\t\t}\n\t\t\t// Swapping buffers while the render mode != GL_RENDER will cause\n\t\t\t// VirtualGL < 2.5.2 to throw a GLXBadContextState error\n\t\t\tglRenderMode(GL_FEEDBACK);\n\t\t\tglXSwapBuffers(dpy, win1);\n\t\t\tglRenderMode(GL_RENDER);\n\t\t\tcheckReadbackState(GL_FRONT, dpy, win1, win0, ctx1);\n\t\t\tcheckFrame(win1, 0, lastFrame1);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\t// Faker should readback front buffer on glFlush(), glFinish(), and\n\t\t// glXWaitGL()\n\t\ttry\n\t\t{\n\t\t\tprintf(\"glFlush() [f]:                 \");\n\t\t\tclr.clear(GL_FRONT);  if(stereo) sclr.clear(GL_FRONT_RIGHT);\n\t\t\tclr.clear(GL_BACK);  if(stereo) sclr.clear(GL_BACK_RIGHT);\n\t\t\tglReadBuffer(GL_BACK);\n\t\t\tglFlush();  glFlush();\n\t\t\tcheckFrame(win1, 1, lastFrame1);\n\t\t\tglDrawBuffer(GL_FRONT);\n\t\t\tglRenderMode(GL_SELECT);  glFlush();\n\t\t\tglRenderMode(GL_FEEDBACK);  glFlush();\n\t\t\tglRenderMode(GL_RENDER);  glFlush();\n\t\t\tcheckReadbackState(GL_BACK, dpy, win1, win0, ctx1);\n\t\t\tcheckFrame(win1, 1, lastFrame1);\n\t\t\tcheckWindowColor(win1, clr.bits(-2));\n\t\t\tif(stereo)\n\t\t\t\tcheckWindowColor(win1, sclr.bits(-2), true);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"glFinish() [f]:                \");\n\t\t\tclr.clear(GL_FRONT);  if(stereo) sclr.clear(GL_FRONT_RIGHT);\n\t\t\tclr.clear(GL_BACK);  if(stereo) sclr.clear(GL_BACK_RIGHT);\n\t\t\tglReadBuffer(GL_BACK);\n\t\t\tglFinish();  glFinish();\n\t\t\tcheckFrame(win1, 1, lastFrame1);\n\t\t\tglDrawBuffer(GL_FRONT);  glFinish();\n\t\t\tcheckReadbackState(GL_BACK, dpy, win1, win0, ctx1);\n\t\t\tcheckFrame(win1, 1, lastFrame1);\n\t\t\tcheckWindowColor(win1, clr.bits(-2));\n\t\t\tif(stereo)\n\t\t\t\tcheckWindowColor(win1, sclr.bits(-2), true);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"glXWaitGL() [f]:               \");\n\t\t\tclr.clear(GL_FRONT);  if(stereo) sclr.clear(GL_FRONT_RIGHT);\n\t\t\tclr.clear(GL_BACK);  if(stereo) sclr.clear(GL_BACK_RIGHT);\n\t\t\tglReadBuffer(GL_BACK);\n\t\t\tglXWaitGL();  glXWaitGL();\n\t\t\tcheckFrame(win1, 1, lastFrame1);\n\t\t\tglDrawBuffer(GL_FRONT);  glXWaitGL();\n\t\t\tcheckReadbackState(GL_BACK, dpy, win1, win0, ctx1);\n\t\t\tcheckFrame(win1, 1, lastFrame1);\n\t\t\tcheckWindowColor(win1, clr.bits(-2));\n\t\t\tif(stereo)\n\t\t\t\tcheckWindowColor(win1, sclr.bits(-2), true);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"glPopAttrib() [f]:             \");\n\t\t\tglDrawBuffer(GL_BACK);  glFinish();\n\t\t\tcheckFrame(win1, 1, lastFrame1);\n\t\t\tglPushAttrib(GL_COLOR_BUFFER_BIT);\n\t\t\tclr.clear(GL_FRONT);  if(stereo) sclr.clear(GL_FRONT_RIGHT);\n\t\t\tglPopAttrib();  // Back buffer should now be current again & dirty flag\n\t\t\t                // should be set\n\t\t\tclr.clear(GL_BACK);  if(stereo) sclr.clear(GL_BACK_RIGHT);\n\t\t\tglReadBuffer(GL_BACK);\n\t\t\tglFinish();  glFinish();\n\t\t\tcheckReadbackState(GL_BACK, dpy, win1, win0, ctx1);\n\t\t\tcheckFrame(win1, 1, lastFrame1);\n\t\t\tcheckWindowColor(win1, clr.bits(-2));\n\t\t\tif(stereo)\n\t\t\t\tcheckWindowColor(win1, sclr.bits(-2), true);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"glXMakeCurrent() [f]:          \");\n\t\t\tclr.clear(GL_FRONT);  if(stereo) sclr.clear(GL_FRONT_RIGHT);\n\t\t\tclr.clear(GL_BACK);  if(stereo) sclr.clear(GL_BACK_RIGHT);\n\t\t\tglXMakeCurrent(dpy, win1, ctx0);  // readback should occur\n\t\t\tglXMakeCurrent(dpy, win0, ctx0);  // No readback should occur\n\t\t\tglDrawBuffer(GL_FRONT);\n\t\t\tglXMakeCurrent(dpy, win0, ctx0);  // No readback should occur\n\t\t\tcheckReadbackState(GL_BACK, dpy, win0, win0, ctx0);\n\t\t\tcheckFrame(win1, 1, lastFrame1);\n\t\t\tcheckWindowColor(win1, clr.bits(-2));\n\t\t\tif(stereo)\n\t\t\t\tcheckWindowColor(win1, sclr.bits(-2), true);\n\t\t\t// Now try swapping one window when another is current (this will fail\n\t\t\t// with VGL 2.3.3 and earlier)\n\t\t\tglXSwapBuffers(dpy, win1);\n\t\t\tcheckFrame(win1, 1, lastFrame1);\n\t\t\tif(!stereo) // Also due to the nVidia bug\n\t\t\t\tcheckWindowColor(win1, clr.bits(-1));\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"glXMakeContextCurrent() [f]:   \");\n\t\t\tclr.clear(GL_FRONT);  if(stereo) sclr.clear(GL_FRONT_RIGHT);\n\t\t\tclr.clear(GL_BACK);  if(stereo) sclr.clear(GL_BACK_RIGHT);\n\t\t\tglXMakeContextCurrent(dpy, win0, win0, ctx1); // No readback should occur\n\t\t\tglXMakeContextCurrent(dpy, win1, win0, ctx1); // readback should occur\n\t\t\tglDrawBuffer(GL_FRONT);\n\t\t\tglXMakeContextCurrent(dpy, win1, win0, ctx1); // No readback should occur\n\t\t\tcheckReadbackState(GL_BACK, dpy, win1, win0, ctx1);\n\t\t\tcheckFrame(win0, 1, lastFrame0);\n\t\t\tcheckWindowColor(win0, clr.bits(-2));\n\t\t\tif(stereo)\n\t\t\t\tcheckWindowColor(win0, sclr.bits(-2), true);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\t// Test for proper handling of GL_FRONT_AND_BACK\n\t\ttry\n\t\t{\n\t\t\tprintf(\"glXSwapBuffers() [f&b]:        \");\n\t\t\tclr.clear(GL_FRONT_AND_BACK);  if(stereo) sclr.clear(GL_RIGHT);\n\t\t\tglReadBuffer(GL_FRONT);\n\t\t\tglXSwapBuffers(dpy, win1);\n\t\t\tcheckReadbackState(GL_FRONT, dpy, win1, win0, ctx1);\n\t\t\tcheckFrame(win1, 1, lastFrame1);\n\t\t\tcheckWindowColor(win1, clr.bits(-1));\n\t\t\tif(stereo) checkWindowColor(win1, sclr.bits(-1), true);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"glFlush() [f&b]:               \");\n\t\t\tclr.clear(GL_FRONT_AND_BACK);  if(stereo) sclr.clear(GL_RIGHT);\n\t\t\tglReadBuffer(GL_BACK);\n\t\t\tglFlush();  glFlush();\n\t\t\tcheckReadbackState(GL_BACK, dpy, win1, win0, ctx1);\n\t\t\tcheckFrame(win1, 2, lastFrame1);\n\t\t\tcheckWindowColor(win1, clr.bits(-1));\n\t\t\tif(stereo) checkWindowColor(win1, sclr.bits(-1), true);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"glFinish() [f&b]:              \");\n\t\t\tclr.clear(GL_FRONT_AND_BACK);  if(stereo) sclr.clear(GL_RIGHT);\n\t\t\tglReadBuffer(GL_BACK);\n\t\t\tglFinish();  glFinish();\n\t\t\tcheckReadbackState(GL_BACK, dpy, win1, win0, ctx1);\n\t\t\tcheckFrame(win1, 2, lastFrame1);\n\t\t\tcheckWindowColor(win1, clr.bits(-1));\n\t\t\tif(stereo) checkWindowColor(win1, sclr.bits(-1), true);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"glXWaitGL() [f&b]:             \");\n\t\t\tclr.clear(GL_FRONT_AND_BACK);  if(stereo) sclr.clear(GL_RIGHT);\n\t\t\tglReadBuffer(GL_BACK);\n\t\t\tglXWaitGL();  glXWaitGL();\n\t\t\tcheckReadbackState(GL_BACK, dpy, win1, win0, ctx1);\n\t\t\tcheckFrame(win1, 2, lastFrame1);\n\t\t\tcheckWindowColor(win1, clr.bits(-1));\n\t\t\tif(stereo) checkWindowColor(win1, sclr.bits(-1), true);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"glXMakeCurrent() [f&b]:        \");\n\t\t\tclr.clear(GL_FRONT_AND_BACK);  if(stereo) sclr.clear(GL_RIGHT);\n\t\t\tglXMakeCurrent(dpy, win0, ctx0);  // readback should occur\n\t\t\tglDrawBuffer(GL_FRONT);\n\t\t\tglXMakeCurrent(dpy, win0, ctx0);  // No readback should occur\n\t\t\tcheckReadbackState(GL_BACK, dpy, win0, win0, ctx0);\n\t\t\tcheckFrame(win1, 1, lastFrame1);\n\t\t\tcheckWindowColor(win1, clr.bits(-1));\n\t\t\tif(stereo) checkWindowColor(win1, sclr.bits(-1), true);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"glXMakeContextCurrent() [f&b]: \");\n\t\t\tclr.clear(GL_FRONT_AND_BACK);  if(stereo) sclr.clear(GL_RIGHT);\n\t\t\tglXMakeContextCurrent(dpy, win0, win0, ctx1); // No readback should occur\n\t\t\tglXMakeContextCurrent(dpy, win1, win0, ctx1); // readback should occur\n\t\t\tglDrawBuffer(GL_FRONT);\n\t\t\tglXMakeContextCurrent(dpy, win1, win0, ctx1); // No readback should occur\n\t\t\tcheckReadbackState(GL_BACK, dpy, win1, win0, ctx1);\n\t\t\tcheckFrame(win0, 1, lastFrame0);\n\t\t\tcheckWindowColor(win0, clr.bits(-1));\n\t\t\tif(stereo) checkWindowColor(win0, sclr.bits(-1), true);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\t}\n\tcatch(Error &e)\n\t{\n\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t}\n\tif(ctx0 && dpy)\n\t{\n\t\tglXMakeCurrent(dpy, 0, 0);  glXDestroyContext(dpy, ctx0);  ctx0=0;\n\t}\n\tif(ctx1 && dpy)\n\t{\n\t\tglXMakeCurrent(dpy, 0, 0);  glXDestroyContext(dpy, ctx1);  ctx1=0;\n\t}\n\tif(win0) { XDestroyWindow(dpy, win0);  win0=0; }\n\tif(win1) { XDestroyWindow(dpy, win1);  win1=0; }\n\tif(vis0) { XFree(vis0);  vis0=NULL; }\n\tif(vis1) { XFree(vis1);  vis1=NULL; }\n\tif(configs) { XFree(configs);  configs=NULL; }\n\tif(dpy) { XCloseDisplay(dpy);  dpy=NULL; }\n\treturn retval;\n}\n\n\n// This tests the faker's ability to handle the 2000 Flushes issue\nint flushTest(void)\n{\n\tTestColor clr(0);\n\tDisplay *dpy=NULL;  Window win=0;\n\tint dpyw, dpyh, lastFrame=0, retval=1;\n\tint glxattrib[]={ GLX_DOUBLEBUFFER, GLX_RGBA, GLX_RED_SIZE, 8,\n\t\tGLX_GREEN_SIZE, 8, GLX_BLUE_SIZE, 8, None };\n\tXVisualInfo *vis=NULL;\n\tGLXContext ctx=0;\n\tXSetWindowAttributes swa;\n\n\tputenv((char *)\"VGL_SPOIL=1\");\n\tprintf(\"10000 flushes test:\\n\");\n\n\ttry\n\t{\n\t\tif(!(dpy=XOpenDisplay(0)))  _throw(\"Could not open display\");\n\t\tdpyw=DisplayWidth(dpy, DefaultScreen(dpy));\n\t\tdpyh=DisplayHeight(dpy, DefaultScreen(dpy));\n\n\t\tif((vis=glXChooseVisual(dpy, DefaultScreen(dpy), glxattrib))==NULL)\n\t\t\t_throw(\"Could not find a suitable visual\");\n\n\t\tWindow root=RootWindow(dpy, DefaultScreen(dpy));\n\t\tswa.colormap=XCreateColormap(dpy, root, vis->visual, AllocNone);\n\t\tswa.border_pixel=0;\n\t\tswa.event_mask=0;\n\t\tif((win=XCreateWindow(dpy, root, 0, 0, dpyw/2, dpyh/2, 0, vis->depth,\n\t\t\tInputOutput, vis->visual, CWBorderPixel|CWColormap|CWEventMask,\n\t\t\t&swa))==0)\n\t\t\t_throw(\"Could not create window\");\n\n\t\tif((ctx=glXCreateContext(dpy, vis, 0, True))==NULL)\n\t\t\t_throw(\"Could not establish GLX context\");\n\t\tXFree(vis);  vis=NULL;\n\t\tif(!glXMakeCurrent(dpy, win, ctx))\n\t\t\t_throw(\"Could not make context current\");\n\t\tcheckCurrent(dpy, win, win, ctx);\n\t\tif(!doubleBufferTest())\n\t\t\t_throw(\"This test requires double buffering, which appears to be broken.\");\n\t\tglReadBuffer(GL_FRONT);\n\t\tXMapWindow(dpy, win);\n\n\t\tclr.clear(GL_BACK);\n\t\tclr.clear(GL_FRONT);\n\t\tfor(int i=0; i<10000; i++)\n\t\t{\n\t\t\tprintf(\"%.4d\\b\\b\\b\\b\", i);  glFlush();\n\t\t}\n\t\tcheckFrame(win, -1, lastFrame);\n\t\tprintf(\"Read back %d of 10000 frames\\n\", lastFrame);\n\t\tcheckReadbackState(GL_FRONT, dpy, win, win, ctx);\n\t\tcheckWindowColor(win, clr.bits(-1), 0);\n\t\tprintf(\"SUCCESS\\n\");\n\t}\n\tcatch(Error &e)\n\t{\n\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t}\n\tfflush(stdout);\n\tputenv((char *)\"VGL_SPOIL=0\");\n\n\tif(ctx && dpy)\n\t{\n\t\tglXMakeCurrent(dpy, 0, 0);  glXDestroyContext(dpy, ctx);  ctx=0;\n\t}\n\tif(win) { XDestroyWindow(dpy, win);  win=0; }\n\tif(vis) { XFree(vis);  vis=NULL; }\n\tif(dpy) { XCloseDisplay(dpy);  dpy=NULL; }\n\treturn retval;\n}\n\n\nint cfgid(Display *dpy, GLXFBConfig config);\n\n\n#define GET_CFG_ATTRIB(config, attrib, ctemp) {  \\\n\tctemp=-10;  \\\n\tglXGetFBConfigAttrib(dpy, config, attrib, &ctemp);  \\\n\tif(ctemp==-10) _error(#attrib\" cfg attrib not supported\");  \\\n}\n\n#define GET_VIS_ATTRIB(vis, attrib, vtemp) {  \\\n\tvtemp=-20;  \\\n\tglXGetConfig(dpy, vis, attrib, &vtemp);  \\\n\tif(vtemp==-20) _error(#attrib\" vis attrib not supported\");  \\\n}\n\n#define COMPARE_ATTRIB(config, vis, attrib, ctemp) {  \\\n\tGET_CFG_ATTRIB(config, attrib, ctemp);  \\\n\tGET_VIS_ATTRIB(vis, attrib, vtemp);  \\\n\tif(ctemp!=vtemp)  \\\n\t\t_prerror5(\"%s=%d in C%.2x & %d in V%.2x\", #attrib, ctemp,  \\\n\t\t\tcfgid(dpy, config), vtemp, vis? (unsigned int)vis->visualid:0);  \\\n}\n\n\nvoid configVsVisual(Display *dpy, GLXFBConfig config, XVisualInfo *vis)\n{\n\tint ctemp, vtemp, r, g, b, bs;\n\tif(!dpy) _error(\"Invalid display handle\");\n\tif(!config) _error(\"Invalid FB config\");\n\tif(!vis) _error(\"Invalid visual pointer\");\n\tGET_CFG_ATTRIB(config, GLX_VISUAL_ID, ctemp);\n\tif(ctemp!=(int)vis->visualid)\n\t\t_error(\"Visual ID mismatch\");\n\tGET_CFG_ATTRIB(config, GLX_RENDER_TYPE, ctemp);\n\tGET_VIS_ATTRIB(vis, GLX_RGBA, vtemp);\n\tif((ctemp&GLX_RGBA_BIT)!=0 && vtemp!=1)\n\t\t_error(\"GLX_RGBA mismatch w/ X visual\");\n\tCOMPARE_ATTRIB(config, vis, GLX_BUFFER_SIZE, bs);\n\tCOMPARE_ATTRIB(config, vis, GLX_LEVEL, ctemp);\n\tCOMPARE_ATTRIB(config, vis, GLX_DOUBLEBUFFER, ctemp);\n\tCOMPARE_ATTRIB(config, vis, GLX_STEREO, ctemp);\n\tCOMPARE_ATTRIB(config, vis, GLX_AUX_BUFFERS, ctemp);\n\tCOMPARE_ATTRIB(config, vis, GLX_RED_SIZE, r);\n\tCOMPARE_ATTRIB(config, vis, GLX_GREEN_SIZE, g);\n\tCOMPARE_ATTRIB(config, vis, GLX_BLUE_SIZE, b);\n\tCOMPARE_ATTRIB(config, vis, GLX_ALPHA_SIZE, ctemp);\n\tCOMPARE_ATTRIB(config, vis, GLX_DEPTH_SIZE, ctemp);\n\tCOMPARE_ATTRIB(config, vis, GLX_STENCIL_SIZE, ctemp);\n\tCOMPARE_ATTRIB(config, vis, GLX_ACCUM_RED_SIZE, ctemp);\n\tCOMPARE_ATTRIB(config, vis, GLX_ACCUM_GREEN_SIZE, ctemp);\n\tCOMPARE_ATTRIB(config, vis, GLX_ACCUM_BLUE_SIZE, ctemp);\n\tCOMPARE_ATTRIB(config, vis, GLX_ACCUM_ALPHA_SIZE, ctemp);\n\t#ifdef GLX_SAMPLE_BUFFERS_ARB\n\tCOMPARE_ATTRIB(config, vis, GLX_SAMPLE_BUFFERS_ARB, ctemp);\n\t#endif\n\t#ifdef GLX_SAMPLES_ARB\n\tCOMPARE_ATTRIB(config, vis, GLX_SAMPLES_ARB, ctemp);\n\t#endif\n\t#ifdef GLX_X_VISUAL_TYPE_EXT\n\tCOMPARE_ATTRIB(config, vis, GLX_X_VISUAL_TYPE_EXT, ctemp);\n\t#endif\n\t#ifdef GLX_TRANSPARENT_TYPE_EXT\n\tCOMPARE_ATTRIB(config, vis, GLX_TRANSPARENT_TYPE_EXT, ctemp);\n\t#endif\n\t#ifdef GLX_TRANSPARENT_INDEX_VALUE_EXT\n\tCOMPARE_ATTRIB(config, vis, GLX_TRANSPARENT_INDEX_VALUE_EXT, ctemp);\n\t#endif\n\t#ifdef GLX_TRANSPARENT_RED_VALUE_EXT\n\tCOMPARE_ATTRIB(config, vis, GLX_TRANSPARENT_RED_VALUE_EXT, ctemp);\n\t#endif\n\t#ifdef GLX_TRANSPARENT_GREEN_VALUE_EXT\n\tCOMPARE_ATTRIB(config, vis, GLX_TRANSPARENT_GREEN_VALUE_EXT, ctemp);\n\t#endif\n\t#ifdef GLX_TRANSPARENT_BLUE_VALUE_EXT\n\tCOMPARE_ATTRIB(config, vis, GLX_TRANSPARENT_BLUE_VALUE_EXT, ctemp);\n\t#endif\n\t#ifdef GLX_TRANSPARENT_ALPHA_VALUE_EXT\n\tCOMPARE_ATTRIB(config, vis, GLX_TRANSPARENT_ALPHA_VALUE_EXT, ctemp);\n\t#endif\n\t#ifdef GLX_VIDEO_RESIZE_SUN\n\tCOMPARE_ATTRIB(config, vis, GLX_VIDEO_RESIZE_SUN, ctemp);\n\t#endif\n\t#ifdef GLX_VIDEO_REFRESH_TIME_SUN\n\tCOMPARE_ATTRIB(config, vis, GLX_VIDEO_REFRESH_TIME_SUN, ctemp);\n\t#endif\n\t#ifdef GLX_GAMMA_VALUE_SUN\n\tCOMPARE_ATTRIB(config, vis, GLX_GAMMA_VALUE_SUN, ctemp);\n\t#endif\n}\n\n\nint cfgid(Display *dpy, GLXFBConfig config)\n{\n\tint temp=0;\n\tif(!config) _error(\"config==NULL in cfgid()\");\n\tif(!dpy) _error(\"display==NULL in cfgid()\");\n\tGET_CFG_ATTRIB(config, GLX_FBCONFIG_ID, temp);\n\treturn temp;\n}\n\n\nvoid queryContextTest(Display *dpy, XVisualInfo *vis, GLXFBConfig config)\n{\n\tGLXContext ctx=0;  int fbcid, temp;\n\ttry\n\t{\n\t\tint visual_caveat;\n\t\tGET_CFG_ATTRIB(config, GLX_CONFIG_CAVEAT, visual_caveat);\n\t\tif(visual_caveat==GLX_NON_CONFORMANT_CONFIG) return;\n\t\tfbcid=cfgid(dpy, config);\n\n\t\tif(!(ctx=glXCreateNewContext(dpy, config, GLX_RGBA_TYPE, NULL, True)))\n\t\t\t_error(\"glXCreateNewContext\");\n\t\ttemp=-20;\n\t\tglXQueryContext(dpy, ctx, GLX_FBCONFIG_ID, &temp);\n\t\tif(temp!=fbcid) _error(\"glXQueryContext FB cfg ID\");\n\t\tglXDestroyContext(dpy, ctx);  ctx=0;\n\n\t\tif(!(ctx=glXCreateContext(dpy, vis, NULL, True)))\n\t\t\t_error(\"glXCreateNewContext\");\n\t\ttemp=-20;\n\t\tglXQueryContext(dpy, ctx, GLX_FBCONFIG_ID, &temp);\n\t\tif(temp!=fbcid) _error(\"glXQueryContext FB cfg ID\");\n\t\ttemp=-20;\n\t\tglXQueryContext(dpy, ctx, GLX_RENDER_TYPE, &temp);\n\t\tif(temp!=GLX_RGBA_TYPE) _error(\"glXQueryContext render type\");\n\t\tglXDestroyContext(dpy, ctx);  ctx=0;\n\t}\n\tcatch(...)\n\t{\n\t\tif(ctx) { glXDestroyContext(dpy, ctx);  ctx=0; }\n\t\tthrow;\n\t}\n}\n\n\nGLXFBConfig getFBConfigFromVisual(Display *dpy, XVisualInfo *vis)\n{\n\tGLXContext ctx=0;  int temp, fbcid=0, n=0;\n\tGLXFBConfig *configs=NULL, config=0;\n\ttry\n\t{\n\t\tif(!(ctx=glXCreateContext(dpy, vis, NULL, True)))\n\t\t\t_error(\"glXCreateNewContext\");\n\t\tglXQueryContext(dpy, ctx, GLX_FBCONFIG_ID, &fbcid);\n\t\tglXDestroyContext(dpy, ctx);  ctx=0;\n\t\tif(!(configs=glXGetFBConfigs(dpy, DefaultScreen(dpy), &n)) || n==0)\n\t\t\t_error(\"Cannot map visual to FB config\");\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\ttemp=cfgid(dpy, configs[i]);\n\t\t\tif(temp==fbcid) { config=configs[i];  break; }\n\t\t}\n\t\tXFree(configs);  configs=NULL;\n\t\tif(!config) _error(\"Cannot map visual to FB config\");\n\t\treturn config;\n\t}\n\tcatch(...)\n\t{\n\t\tif(ctx) { glXDestroyContext(dpy, ctx);  ctx=0; }\n\t\tif(configs) { XFree(configs);  configs=NULL; }\n\t\tthrow;\n\t}\n\treturn 0;\n}\n\n\n// This tests the faker's client/server visual matching heuristics\nint visTest(void)\n{\n\tDisplay *dpy=NULL;\n\tXVisualInfo **visuals=NULL, *vis0=NULL, vtemp;\n\tGLXFBConfig config=0, *configs=NULL;  int n=0, i, retval=1;\n\n\tprintf(\"Visual matching heuristics test\\n\\n\");\n\n\ttry\n\t{\n\t\tif(!(dpy=XOpenDisplay(0))) _throw(\"Could not open display\");\n\n\t\t// This will fail with VGL 2.2.x and earlier\n\t\tif(!(configs=glXChooseFBConfig(dpy, DefaultScreen(dpy), NULL, &n))\n\t\t\t|| n==0)\n\t\t\t_throw(\"No FB configs found\");\n\t\tXFree(configs);  configs=NULL;\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"RGBA:   \");\n\n\t\t\t// Iterate through RGBA attributes\n\t\t\tint rgbattrib[]={ GLX_RED_SIZE, 8, GLX_GREEN_SIZE, 8, GLX_BLUE_SIZE, 8,\n\t\t\t\tGLX_ALPHA_SIZE, 0, GLX_DEPTH_SIZE, 0, GLX_AUX_BUFFERS, 0,\n\t\t\t\tGLX_STENCIL_SIZE, 0, GLX_ACCUM_RED_SIZE, 0, GLX_ACCUM_GREEN_SIZE, 0,\n\t\t\t\tGLX_ACCUM_BLUE_SIZE, 0, GLX_ACCUM_ALPHA_SIZE, 0,\n\t\t\t\tGLX_SAMPLE_BUFFERS, 0, GLX_SAMPLES, 1, GLX_RGBA, None, None, None };\n\t\t\tint rgbattrib13[]={ GLX_DOUBLEBUFFER, 1, GLX_STEREO, 1,\n\t\t\t\tGLX_RED_SIZE, 8, GLX_GREEN_SIZE, 8, GLX_BLUE_SIZE, 8,\n\t\t\t\tGLX_ALPHA_SIZE, 0, GLX_DEPTH_SIZE, 0, GLX_AUX_BUFFERS, 0,\n\t\t\t\tGLX_STENCIL_SIZE, 0, GLX_ACCUM_RED_SIZE, 0, GLX_ACCUM_GREEN_SIZE, 0,\n\t\t\t\tGLX_ACCUM_BLUE_SIZE, 0, GLX_ACCUM_ALPHA_SIZE, 0,\n\t\t\t\tGLX_SAMPLE_BUFFERS, 0, GLX_SAMPLES, 1, None };\n\n\t\t\tfor(int db=0; db<=1; db++)\n\t\t\t{\n\t\t\t\trgbattrib13[1]=db;\n\t\t\t\trgbattrib[27]=db? GLX_DOUBLEBUFFER:0;\n\t\t\t\tfor(int stereo=0; stereo<=1; stereo++)\n\t\t\t\t{\n\t\t\t\t\trgbattrib13[3]=stereo;\n\t\t\t\t\trgbattrib[db? 28:27]=stereo? GLX_STEREO:0;\n\t\t\t\t\tfor(int alpha=0; alpha<=1; alpha++)\n\t\t\t\t\t{\n\t\t\t\t\t\trgbattrib13[11]=rgbattrib[7]=alpha;\n\t\t\t\t\t\tfor(int depth=0; depth<=1; depth++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trgbattrib13[13]=rgbattrib[9]=depth;\n\t\t\t\t\t\t\tfor(int aux=0; aux<=1; aux++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trgbattrib13[15]=rgbattrib[11]=aux;\n\t\t\t\t\t\t\t\tfor(int stencil=0; stencil<=1; stencil++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\trgbattrib13[17]=rgbattrib[13]=stencil;\n\t\t\t\t\t\t\t\t\tfor(int accum=0; accum<=1; accum++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\trgbattrib13[19]=rgbattrib13[21]=rgbattrib13[23]=accum;\n\t\t\t\t\t\t\t\t\t\trgbattrib[15]=rgbattrib[17]=rgbattrib[19]=accum;\n\t\t\t\t\t\t\t\t\t\tif(alpha) { rgbattrib13[25]=rgbattrib[21]=accum; }\n\t\t\t\t\t\t\t\t\t\tfor(int samples=0; samples<=16;\n\t\t\t\t\t\t\t\t\t\t\tsamples==0? samples=1:samples*=2)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\trgbattrib13[29]=rgbattrib[25]=samples;\n\t\t\t\t\t\t\t\t\t\t\trgbattrib13[27]=rgbattrib[23]=samples? 1:0;\n\n\t\t\t\t\t\t\t\t\t\t\tif((!(configs=glXChooseFBConfig(dpy,\n\t\t\t\t\t\t\t\t\t\t\t\tDefaultScreen(dpy), rgbattrib13, &n)) || n==0)\n\t\t\t\t\t\t\t\t\t\t\t\t&& !stereo && !samples && !aux && !accum)\n\t\t\t\t\t\t\t\t\t\t\t\t_throw(\"No FB configs found\");\n\t\t\t\t\t\t\t\t\t\t\tif(!(vis0=glXChooseVisual(dpy, DefaultScreen(dpy),\n\t\t\t\t\t\t\t\t\t\t\t\trgbattrib)) && !stereo && !samples && !aux && !accum)\n\t\t\t\t\t\t\t\t\t\t\t\t_throw(\"Could not find visual\");\n\t\t\t\t\t\t\t\t\t\t\tif(vis0 && configs)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tconfigVsVisual(dpy, configs[0], vis0);\n\t\t\t\t\t\t\t\t\t\t\t\tXFree(vis0);  XFree(configs);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"SUCCESS!\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\tprintf(\"\\n\");\n\t\tif(!(configs=glXGetFBConfigs(dpy, DefaultScreen(dpy), &n)) || n==0)\n\t\t\t_throw(\"No FB configs found\");\n\n\t\tint fbcid=0;\n\t\tif(!(visuals=(XVisualInfo **)malloc(sizeof(XVisualInfo *)*n)))\n\t\t\t_throw(\"Memory allocation error\");\n\t\tmemset(visuals, 0, sizeof(XVisualInfo *)*n);\n\n\t\tfor(i=0; i<n; i++)\n\t\t{\n\t\t\tif(!configs[i]) continue;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tint renderType;\n\t\t\t\tfbcid=cfgid(dpy, configs[i]);\n\t\t\t\tGET_CFG_ATTRIB(configs[i], GLX_RENDER_TYPE, renderType);\n\t\t\t\tif((renderType&GLX_RGBA_BIT)==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(!(visuals[i]=glXGetVisualFromFBConfig(dpy, configs[i])))\n\t\t\t\t{\n\t\t\t\t\tprintf(\"CFG 0x%.2x:  \", fbcid);\n\t\t\t\t\t_error(\"No matching X visual for CFG\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Error &e)\n\t\t\t{\n\t\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(i=0; i<n; i++)\n\t\t{\n\t\t\tXVisualInfo *vis1=NULL;\n\t\t\tif(!configs[i]) continue;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tint renderType;\n\t\t\t\tfbcid=cfgid(dpy, configs[i]);\n\t\t\t\tGET_CFG_ATTRIB(configs[i], GLX_RENDER_TYPE, renderType);\n\t\t\t\tif((renderType&GLX_RGBA_BIT)==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tprintf(\"CFG 0x%.2x:  \", fbcid);\n\t\t\t\tif(!(vis1=glXGetVisualFromFBConfig(dpy, configs[i])))\n\t\t\t\t\t_error(\"No matching X visual for CFG\");\n\n\t\t\t\tconfigVsVisual(dpy, configs[i], visuals[i]);\n\t\t\t\tconfigVsVisual(dpy, configs[i], vis1);\n\t\t\t\tqueryContextTest(dpy, visuals[i], configs[i]);\n\t\t\t\tqueryContextTest(dpy, vis1, configs[i]);\n\n\t\t\t\tconfig=getFBConfigFromVisual(dpy, visuals[i]);\n\t\t\t\tif(!config || cfgid(dpy, config)!=fbcid)\n\t\t\t\t\t_error(\"getFBConfigFromVisual\");\n\t\t\t\tconfig=getFBConfigFromVisual(dpy, vis1);\n\t\t\t\tif(!config || cfgid(dpy, config)!=fbcid)\n\t\t\t\t\t_error(\"getFBConfigFromVisual\");\n\n\t\t\t\tprintf(\"SUCCESS!\\n\");\n\t\t\t}\n\t\t\tcatch(Error &e)\n\t\t\t{\n\t\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t\t}\n\t\t\tif(vis1) { XFree(vis1);  vis1=NULL; }\n\t\t}\n\n\t\tXFree(configs);  configs=NULL;\n\t\tfor(i=0; i<n; i++) { if(visuals[i]) XFree(visuals[i]); }\n\t\tfree(visuals);  visuals=NULL;  n=0;\n\t\tfflush(stdout);\n\n\t\tif(!(vis0=XGetVisualInfo(dpy, VisualNoMask, &vtemp, &n)) || n==0)\n\t\t\t_throw(\"No X Visuals found\");\n\t\tprintf(\"\\n\");\n\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tXVisualInfo *vis2=NULL;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tint level=0;\n\t\t\t\tglXGetConfig(dpy, &vis0[i], GLX_LEVEL, &level);\n\t\t\t\tif(level) continue;\n\t\t\t\tprintf(\"Vis 0x%.2x:  \", (int)vis0[i].visualid);\n\t\t\t\tif(!(config=getFBConfigFromVisual(dpy, &vis0[i])))\n\t\t\t\t\t_error(\"No matching CFG for X Visual\");\n\t\t\t\tconfigVsVisual(dpy, config, &vis0[i]);\n\t\t\t\tvis2=glXGetVisualFromFBConfig(dpy, config);\n\t\t\t\tconfigVsVisual(dpy, config, vis2);\n\n\t\t\t\tprintf(\"SUCCESS!\\n\");\n\t\t\t}\n\t\t\tcatch(Error &e)\n\t\t\t{\n\t\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t\t}\n\t\t\tif(vis2) { XFree(vis2);  vis2=NULL; }\n\t\t}\n\t}\n\tcatch(Error &e)\n\t{\n\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t}\n\tfflush(stdout);\n\n\tif(visuals && n)\n\t{\n\t\tfor(i=0; i<n; i++) { if(visuals[i]) XFree(visuals[i]); }\n\t\tfree(visuals);  visuals=NULL;\n\t}\n\tif(vis0) { XFree(vis0);  vis0=NULL; }\n\tif(configs) { XFree(configs);  configs=NULL; }\n\tif(dpy) { XCloseDisplay(dpy);  dpy=NULL; }\n\treturn retval;\n}\n\n\n#define NTHREADS 30\nbool deadYet=false;\n\nclass TestThread : public Runnable\n{\n\tpublic:\n\n\t\tTestThread(int myRank_, Display *dpy_, Window win_, GLXContext ctx_)\n\t\t\t: myRank(myRank_), dpy(dpy_), win(win_), ctx(ctx_), doResize(false)\n\t\t{\n\t\t}\n\n\t\tvoid run(void)\n\t\t{\n\t\t\tint clr=myRank%NC, lastFrame=0;\n\t\t\tif(!(glXMakeCurrent(dpy, win, ctx)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\twhile(!deadYet)\n\t\t\t{\n\t\t\t\tif(doResize)\n\t\t\t\t{\n\t\t\t\t\tglViewport(0, 0, width, height);\n\t\t\t\t\tdoResize=false;\n\t\t\t\t}\n\t\t\t\tglClearColor(colors[clr].r, colors[clr].g, colors[clr].b, 0.);\n\t\t\t\tglClear(GL_COLOR_BUFFER_BIT);\n\t\t\t\tglReadBuffer(GL_FRONT);\n\t\t\t\tglXSwapBuffers(dpy, win);\n\t\t\t\tcheckReadbackState(GL_FRONT, dpy, win, win, ctx);\n\t\t\t\tcheckFrame(win, 1, lastFrame);\n\t\t\t\tcheckWindowColor(win, colors[clr].bits, false);\n\t\t\t\tclr=(clr+1)%NC;\n\t\t\t}\n\t\t}\n\n\t\tvoid resize(int width_, int height_)\n\t\t{\n\t\t\twidth=width_;  height=height_;\n\t\t\tdoResize=true;\n\t\t}\n\n\tprivate:\n\n\t\tint myRank;\n\t\tDisplay *dpy;\n\t\tWindow win;\n\t\tGLXContext ctx;\n\t\tbool doResize;\n\t\tint width, height;\n};\n\n\nint multiThreadTest(int nThreads)\n{\n\tint glxattrib[]={ GLX_DOUBLEBUFFER, GLX_RGBA, GLX_RED_SIZE, 8,\n\t\tGLX_GREEN_SIZE, 8, GLX_BLUE_SIZE, 8, None };\n\tXVisualInfo *vis=NULL;\n\tDisplay *dpy=NULL;  Window windows[NTHREADS];\n\tGLXContext contexts[NTHREADS];\n\tTestThread *testThreads[NTHREADS];  Thread *threads[NTHREADS];\n\tXSetWindowAttributes swa;\n\tint i, retval=1;\n\n\tif(nThreads==0) return 1;\n\tfor(i=0; i<nThreads; i++)\n\t{\n\t\twindows[i]=0;  contexts[i]=0;  testThreads[i]=NULL;  threads[i]=NULL;\n\t}\n\n\tprintf(\"Multi-threaded rendering test\\n\\n\");\n\n\ttry\n\t{\n\t\tif(!(dpy=XOpenDisplay(0))) _throw(\"Could not open display\");\n\n\t\tif((vis=glXChooseVisual(dpy, DefaultScreen(dpy), glxattrib))==NULL)\n\t\t\t_throw(\"Could not find a suitable visual\");\n\t\tWindow root=RootWindow(dpy, DefaultScreen(dpy));\n\t\tswa.colormap=XCreateColormap(dpy, root, vis->visual, AllocNone);\n\t\tswa.border_pixel=0;\n\t\tswa.event_mask=StructureNotifyMask|ExposureMask;\n\t\tfor(i=0; i<nThreads; i++)\n\t\t{\n\t\t\tint winX=(i%10)*100, winY=(i/10)*120;\n\t\t\tif((windows[i]=XCreateWindow(dpy, root, winX, winY, 100, 100, 0,\n\t\t\t\tvis->depth, InputOutput, vis->visual,\n\t\t\t\tCWBorderPixel|CWColormap|CWEventMask, &swa))==0)\n\t\t\t\t_throw(\"Could not create window\");\n\t\t\tXMapWindow(dpy, windows[i]);\n\t\t\tif(!(contexts[i]=glXCreateContext(dpy, vis, NULL, True)))\n\t\t\t\t_throw(\"Could not establish GLX context\");\n\t\t\tXMoveResizeWindow(dpy, windows[i], winX, winY, 100, 100);\n\t\t}\n\t\tXSync(dpy, False);\n\t\tXFree(vis);  vis=NULL;\n\n\t\tfor(i=0; i<nThreads; i++)\n\t\t{\n\t\t\ttestThreads[i]=new TestThread(i, dpy, windows[i], contexts[i]);\n\t\t\tthreads[i]=new Thread(testThreads[i]);\n\t\t\tif(!testThreads[i] || !threads[i])\n\t\t\t\t_prerror1(\"Could not create thread %d\", i);\n\t\t\tthreads[i]->start();\n\t\t}\n\t\tprintf(\"Phase 1\\n\");\n\t\tfor(i=0; i<nThreads; i++)\n\t\t{\n\t\t\tint winX=(i%10)*100, winY=i/10*120;\n\t\t\tXMoveResizeWindow(dpy, windows[i], winX, winY, 200, 200);\n\t\t\ttestThreads[i]->resize(200, 200);\n\t\t\tif(i<5) usleep(0);\n\t\t\tXResizeWindow(dpy, windows[i], 100, 100);\n\t\t\ttestThreads[i]->resize(100, 100);\n\t\t}\n\t\tXSync(dpy, False);\n\t\tfflush(stdout);\n\n\t\tprintf(\"Phase 2\\n\");\n\t\tfor(i=0; i<nThreads; i++)\n\t\t{\n\t\t\tXWindowChanges xwc;\n\t\t\txwc.width=xwc.height=200;\n\t\t\tXConfigureWindow(dpy, windows[i], CWWidth|CWHeight, &xwc);\n\t\t\ttestThreads[i]->resize(200, 200);\n\t\t}\n\t\tXSync(dpy, False);\n\t\tfflush(stdout);\n\n\t\tprintf(\"Phase 3\\n\");\n\t\tfor(i=0; i<nThreads; i++)\n\t\t{\n\t\t\tXResizeWindow(dpy, windows[i], 100, 100);\n\t\t\ttestThreads[i]->resize(100, 100);\n\t\t}\n\t\tXSync(dpy, False);\n\t\tdeadYet=true;\n\t\tfor(i=0; i<nThreads; i++) threads[i]->stop();\n\t\tfor(i=0; i<nThreads; i++)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthreads[i]->checkError();\n\t\t\t}\n\t\t\tcatch(Error &e)\n\t\t\t{\n\t\t\t\tprintf(\"Thread %d failed! (%s)\\n\", i, e.getMessage());  retval=0;\n\t\t\t}\n\t\t}\n\t\tif(retval==1) printf(\"SUCCESS!\\n\");\n\t}\n\tcatch(Error &e)\n\t{\n\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t}\n\tfflush(stdout);\n\n\tfor(i=0; i<nThreads; i++)\n\t{\n\t\tif(threads[i]) { delete threads[i];  threads[i]=NULL; }\n\t}\n\tfor(i=0; i<nThreads; i++)\n\t{\n\t\tif(testThreads[i]) { delete testThreads[i];  testThreads[i]=NULL; }\n\t}\n\tif(vis) { XFree(vis);  vis=NULL; }\n\tfor(i=0; i<nThreads; i++)\n\t{\n\t\tif(dpy && contexts[i])\n\t\t{\n\t\t\tglXMakeCurrent(dpy, 0, 0);  glXDestroyContext(dpy, contexts[i]);\n\t\t\tcontexts[i]=0;\n\t\t}\n\t}\n\tfor(i=0; i<nThreads; i++)\n\t{\n\t\tif(dpy && windows[i]) { XDestroyWindow(dpy, windows[i]);  windows[i]=0; }\n\t}\n\tif(dpy) { XCloseDisplay(dpy);  dpy=NULL; }\n\treturn retval;\n}\n\n\n#define COMPARE_DRAW_ATTRIB(dpy, draw, value, attrib) {  \\\n\tif(value>=0) {  \\\n\t\tunsigned int temp=0xffffffff;  \\\n\t\tglXQueryDrawable(dpy, draw, attrib, &temp);  \\\n\t\tif(temp==0xffffffff)  \\\n\t\t\t_throw(#attrib\" attribute not supported\");  \\\n\t\tif(temp!=(unsigned int)value)  \\\n\t\t\t_prerror3(\"%s=%d (should be %d)\", #attrib, temp, value);  \\\n\t}  \\\n}\n\nvoid checkDrawable(Display *dpy, GLXDrawable draw, int width, int height,\n\tint preservedContents, int largestPbuffer, int fbcid)\n{\n\tif(!dpy || !draw) _throw(\"Invalid argument to checkdrawable()\");\n\tCOMPARE_DRAW_ATTRIB(dpy, draw, width, GLX_WIDTH);\n\tCOMPARE_DRAW_ATTRIB(dpy, draw, height, GLX_HEIGHT);\n\tCOMPARE_DRAW_ATTRIB(dpy, draw, preservedContents, GLX_PRESERVED_CONTENTS);\n\tCOMPARE_DRAW_ATTRIB(dpy, draw, largestPbuffer, GLX_LARGEST_PBUFFER);\n\tCOMPARE_DRAW_ATTRIB(dpy, draw, fbcid, GLX_FBCONFIG_ID);\n}\n\n#define VERIFY_BUF_COLOR(buf, colorShouldBe, tag) {  \\\n\tif(buf>0) glReadBuffer(buf);  \\\n\tunsigned int color=checkBufferColor();  \\\n\tif(color!=(colorShouldBe))  \\\n\t\t_prerror2(tag\" is 0x%.6x, should be 0x%.6x\", color, (colorShouldBe));  \\\n}\n\n// Test off-screen rendering\nint offScreenTest(void)\n{\n\tDisplay *dpy=NULL;  Window win=0;  Pixmap pm0=0, pm1=0, pm2=0;\n\tGLXPixmap glxpm0=0, glxpm1=0;  GLXPbuffer pb=0;  GLXWindow glxwin=0;\n\tint dpyw, dpyh, lastFrame=0, retval=1;\n\tint glxattrib[]={ GLX_DOUBLEBUFFER, 1, GLX_RENDER_TYPE, GLX_RGBA_BIT,\n\t\tGLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT|GLX_PBUFFER_BIT|GLX_WINDOW_BIT,\n\t\tGLX_RED_SIZE, 8, GLX_GREEN_SIZE, 8, GLX_BLUE_SIZE, 8, None };\n\tXVisualInfo *vis=NULL;  GLXFBConfig config=0, *configs=NULL;  int n=0;\n\tGLXContext ctx=0;\n\tXSetWindowAttributes swa;\n\tXFontStruct *fontInfo=NULL;  int minChar, maxChar;\n\tint fontListBase=0;\n\tGLuint fbo=0, rbo=0;\n\tTestColor clr(0);\n\n\tprintf(\"Off-screen rendering test\\n\\n\");\n\n\ttry\n\t{\n\t\tif(!(dpy=XOpenDisplay(0)))  _throw(\"Could not open display\");\n\t\tdpyw=DisplayWidth(dpy, DefaultScreen(dpy));\n\t\tdpyh=DisplayHeight(dpy, DefaultScreen(dpy));\n\n\t\tif(!(fontInfo=XLoadQueryFont(dpy, \"fixed\")))\n\t\t\t_throw(\"Could not load X font\");\n\t\tminChar=fontInfo->min_char_or_byte2;\n\t\tmaxChar=fontInfo->max_char_or_byte2;\n\t\tfontListBase=glGenLists(maxChar+1);\n\n\t\tif((configs=glXChooseFBConfigSGIX(dpy, DefaultScreen(dpy), glxattrib, &n))\n\t\t\t==NULL || n==0) _throw(\"Could not find a suitable FB config\");\n\t\tconfig=configs[0];\n\t\tint fbcid=cfgid(dpy, config);\n\t\tXFree(configs);  configs=NULL;\n\t\tif((vis=glXGetVisualFromFBConfigSGIX(dpy, config))==NULL)\n\t\t\t_throw(\"Could not find matching visual for FB config\");\n\n\t\tWindow root=RootWindow(dpy, DefaultScreen(dpy));\n\t\tswa.colormap=XCreateColormap(dpy, root, vis->visual, AllocNone);\n\t\tswa.border_pixel=0;\n\t\tswa.background_pixel=0;\n\t\tswa.event_mask = 0;\n\t\tif((win=XCreateWindow(dpy, root, 0, 0, dpyw/2, dpyh/2, 0, vis->depth,\n\t\t\tInputOutput, vis->visual, CWBorderPixel|CWColormap|CWEventMask,\n\t\t\t&swa))==0)\n\t\t\t_throw(\"Could not create window\");\n\t\tXMapWindow(dpy, win);\n\t\tif((glxwin=glXCreateWindow(dpy, config, win, NULL))==0)\n\t\t\t_throw(\"Could not create GLX window\");\n\t\tcheckDrawable(dpy, glxwin, dpyw/2, dpyh/2, -1, -1, fbcid);\n\n\t\tif((pm0=XCreatePixmap(dpy, win, dpyw/2, dpyh/2, vis->depth))==0\n\t\t\t|| (pm1=XCreatePixmap(dpy, win, dpyw/2, dpyh/2, vis->depth))==0\n\t\t\t|| (pm2=XCreatePixmap(dpy, win, dpyw/2, dpyh/2, vis->depth))==0)\n\t\t\t_throw(\"Could not create pixmap\");\n\t\tif((glxpm0=glXCreateGLXPixmap(dpy, vis, pm0))==0\n\t\t\t|| (glxpm1=glXCreatePixmap(dpy, config, pm1, NULL))==0)\n\t\t\t_throw(\"Could not create GLX pixmap\");\n\t\tcheckDrawable(dpy, glxpm0, dpyw/2, dpyh/2, -1, -1, fbcid);\n\t\tcheckDrawable(dpy, glxpm1, dpyw/2, dpyh/2, -1, -1, fbcid);\n\n\t\tint pbattribs[]={ GLX_PBUFFER_WIDTH, dpyw/2, GLX_PBUFFER_HEIGHT, dpyh/2,\n\t\t\tGLX_PRESERVED_CONTENTS, True, GLX_LARGEST_PBUFFER, False, None };\n\t\tif((pb=glXCreatePbuffer(dpy, config, pbattribs))==0)\n\t\t\t_throw(\"Could not create Pbuffer\");\n\t\tcheckDrawable(dpy, pb, dpyw/2, dpyh/2, 1, 0, fbcid);\n\t\tunsigned int tempw=0, temph=0;\n\t\ttypedef int (*_glXQueryGLXPbufferSGIXType)(Display *, GLXPbufferSGIX, int,\n\t\t\tunsigned int *);\n\t\t_glXQueryGLXPbufferSGIXType __glXQueryGLXPbufferSGIX=\n\t\t\t(_glXQueryGLXPbufferSGIXType)glXGetProcAddress(\n\t\t\t\t(const GLubyte *)\"glXQueryGLXPbufferSGIX\");\n\t\tif(__glXQueryGLXPbufferSGIX)\n\t\t{\n\t\t\tprintf(\"GLX_SGIX_pbuffer appears to work.\\n\");\n\t\t\t__glXQueryGLXPbufferSGIX(dpy, pb, GLX_WIDTH_SGIX, &tempw);\n\t\t\t__glXQueryGLXPbufferSGIX(dpy, pb, GLX_HEIGHT_SGIX, &temph);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"GLX_SGIX_pbuffer doesn't appear to work.\\n\");\n\t\t\tglXQueryDrawable(dpy, pb, GLX_WIDTH, &tempw);\n\t\t\tglXQueryDrawable(dpy, pb, GLX_HEIGHT, &temph);\n\t\t}\n\n\t\tif(tempw!=(unsigned int)dpyw/2 || temph!=(unsigned int)dpyh/2)\n\t\t\t_throw(\"Could not query context\");\n\n\t\tif(!(ctx=glXCreateContextWithConfigSGIX(dpy, config, GLX_RGBA_TYPE, NULL,\n\t\t\tTrue)))\n\t\t\t_throw(\"Could not create context\");\n\n\t\tif(!glXMakeContextCurrent(dpy, glxwin, glxwin, ctx))\n\t\t\t_throw(\"Could not make context current\");\n\t\tcheckCurrent(dpy, glxwin, glxwin, ctx);\n\t\tif(!doubleBufferTest())\n\t\t\t_throw(\"Double buffering appears to be broken\");\n\n\t\tif(!glXMakeContextCurrent(dpy, pb, pb, ctx))\n\t\t\t_throw(\"Could not make context current\");\n\t\tcheckCurrent(dpy, pb, pb, ctx);\n\t\tif(!doubleBufferTest())\n\t\t\t_throw(\"Double-buffered off-screen rendering not available\");\n\t\tcheckFrame(win, -1, lastFrame);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"Pbuffer->Window:                \");\n\t\t\tif(!(glXMakeContextCurrent(dpy, pb, pb, ctx)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tcheckCurrent(dpy, pb, pb, ctx);\n\t\t\tclr.clear(GL_BACK);\n\t\t\tclr.clear(GL_FRONT);\n\t\t\tVERIFY_BUF_COLOR(GL_BACK, clr.bits(-2), \"PB\");\n\t\t\tif(!(glXMakeContextCurrent(dpy, glxwin, pb, ctx)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tcheckCurrent(dpy, glxwin, pb, ctx);\n\t\t\tglReadBuffer(GL_BACK);  glDrawBuffer(GL_BACK);\n\t\t\tglCopyPixels(0, 0, dpyw/2, dpyh/2, GL_COLOR);\n\t\t\tglReadBuffer(GL_FRONT);\n\t\t\tglXSwapBuffers(dpy, glxwin);\n\t\t\tcheckFrame(win, 1, lastFrame);\n\t\t\tcheckReadbackState(GL_FRONT, dpy, glxwin, pb, ctx);\n\t\t\tcheckWindowColor(win, clr.bits(-2), false);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"Window->Pbuffer:                \");\n\t\t\tif(!(glXMakeContextCurrent(dpy, glxwin, glxwin, ctx)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tglXUseXFont(fontInfo->fid, minChar, maxChar-minChar+1,\n\t\t\t\tfontListBase+minChar);\n\t\t\tcheckCurrent(dpy, glxwin, glxwin, ctx);\n\t\t\tclr.clear(GL_BACK);\n\t\t\tclr.clear(GL_FRONT);\n\t\t\tVERIFY_BUF_COLOR(GL_BACK, clr.bits(-2), \"Win\");\n\t\t\tif(!(glXMakeContextCurrent(dpy, pb, glxwin, ctx)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tglXUseXFont(fontInfo->fid, minChar, maxChar-minChar+1,\n\t\t\t\tfontListBase+minChar);\n\t\t\tcheckCurrent(dpy, pb, glxwin, ctx);\n\t\t\tcheckFrame(win, 1, lastFrame);\n\t\t\tglReadBuffer(GL_BACK);  glDrawBuffer(GL_BACK);\n\t\t\tglCopyPixels(0, 0, dpyw/2, dpyh/2, GL_COLOR);\n\t\t\tglXSwapBuffers(dpy, pb);\n\t\t\tVERIFY_BUF_COLOR(GL_BACK, clr.bits(-2), \"PB\");\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"FBO->Window:                    \");\n\t\t\tif(!(glXMakeContextCurrent(dpy, glxwin, glxwin, ctx)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tcheckCurrent(dpy, glxwin, glxwin, ctx);\n\t\t\tclr.clear(GL_BACK);\n\t\t\tclr.clear(GL_FRONT);\n\t\t\tVERIFY_BUF_COLOR(GL_BACK, clr.bits(-2), \"Win\");\n\t\t\tif(!(glXMakeContextCurrent(dpy, glxwin, glxwin, ctx)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tcheckCurrent(dpy, glxwin, glxwin, ctx);\n\t\t\tglDrawBuffer(GL_BACK);\n\t\t\tglGenFramebuffersEXT(1, &fbo);\n\t\t\tglGenRenderbuffersEXT(1, &rbo);\n\t\t\tglBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rbo);\n\t\t\tglRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_RGBA, dpyw/2, dpyh/2);\n\t\t\tglBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo);\n\t\t\tglFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT,\n\t\t\t\tGL_COLOR_ATTACHMENT0_EXT, GL_RENDERBUFFER_EXT, rbo);\n\t\t\tclr.clear(0);\n\t\t\tVERIFY_BUF_COLOR(0, clr.bits(-1), \"FBO\");\n\t\t\tglBindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, 0);\n\t\t\tglFramebufferRenderbufferEXT(GL_DRAW_FRAMEBUFFER_EXT,\n\t\t\t\tGL_COLOR_ATTACHMENT0_EXT, GL_RENDERBUFFER_EXT, 0);\n\t\t\tglDrawBuffer(GL_BACK);\n\t\t\tglXSwapBuffers(dpy, glxwin);\n\t\t\tcheckFrame(win, 1, lastFrame);\n\t\t\tcheckReadbackState(GL_COLOR_ATTACHMENT0_EXT, dpy, glxwin, glxwin, ctx);\n\t\t\tcheckWindowColor(win, clr.bits(-3), false);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\t\tglFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\t\t\tGL_RENDERBUFFER_EXT, 0);\n\t\tglBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0);\n\t\tif(rbo) { glDeleteRenderbuffersEXT(1, &rbo);  rbo=0; }\n\t\tglBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);\n\t\tif(fbo) { glDeleteFramebuffersEXT(1, &fbo);  fbo=0; }\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"GLX Pixmap->Window:             \");\n\t\t\tif(!(glXMakeContextCurrent(dpy, glxpm0, glxpm0, ctx)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tglXUseXFont(fontInfo->fid, minChar, maxChar-minChar+1,\n\t\t\t\tfontListBase+minChar);\n\t\t\tcheckCurrent(dpy, glxpm0, glxpm0, ctx);\n\t\t\tclr.clear(GL_FRONT);\n\t\t\tVERIFY_BUF_COLOR(GL_FRONT, clr.bits(-1), \"PM0\");\n\t\t\tglDrawBuffer(GL_BACK);  glReadBuffer(GL_BACK);\n\t\t\tXCopyArea(dpy, pm0, win, DefaultGC(dpy, DefaultScreen(dpy)), 0, 0,\n\t\t\t\tdpyw/2, dpyh/2, 0, 0);\n\t\t\tcheckReadbackState(GL_BACK, dpy, glxpm0, glxpm0, ctx);\n\t\t\tint temp=-1;  glGetIntegerv(GL_DRAW_BUFFER, &temp);\n\t\t\tif(temp!=GL_BACK) _error(\"Draw buffer changed\");\n\t\t\tcheckFrame(win, 1, lastFrame);\n\t\t\tcheckWindowColor(win, clr.bits(-1), false);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"Window->GLX Pixmap:             \");\n\t\t\tif(!(glXMakeContextCurrent(dpy, glxwin, glxwin, ctx)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tglXUseXFont(fontInfo->fid, minChar, maxChar-minChar+1,\n\t\t\t\tfontListBase+minChar);\n\t\t\tcheckCurrent(dpy, glxwin, glxwin, ctx);\n\t\t\tclr.clear(GL_FRONT);\n\t\t\tclr.clear(GL_BACK);\n\t\t\tVERIFY_BUF_COLOR(GL_FRONT, clr.bits(-2), \"Win\");\n\t\t\tif(!(glXMakeContextCurrent(dpy, glxpm1, glxpm1, ctx)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tcheckCurrent(dpy, glxpm1, glxpm1, ctx);\n\t\t\tcheckFrame(win, 1, lastFrame);\n\t\t\tglDrawBuffer(GL_BACK);  glReadBuffer(GL_BACK);\n\t\t\tXCopyArea(dpy, win, pm1, DefaultGC(dpy, DefaultScreen(dpy)), 0, 0,\n\t\t\t\tdpyw/2, dpyh/2, 0, 0);\n\t\t\tcheckReadbackState(GL_BACK, dpy, glxpm1, glxpm1, ctx);\n\t\t\tint temp=-1;  glGetIntegerv(GL_DRAW_BUFFER, &temp);\n\t\t\tif(temp!=GL_BACK) _error(\"Draw buffer changed\");\n\t\t\tcheckFrame(win, 0, lastFrame);\n\t\t\tVERIFY_BUF_COLOR(GL_BACK, clr.bits(-2), \"PM1\");\n\t\t\tVERIFY_BUF_COLOR(GL_FRONT, clr.bits(-2), \"PM1\");\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"GLX Pixmap->GLX Pixmap:         \");\n\t\t\tif(!(glXMakeContextCurrent(dpy, glxpm0, glxpm0, ctx)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tglXUseXFont(fontInfo->fid, minChar, maxChar-minChar+1,\n\t\t\t\tfontListBase+minChar);\n\t\t\tcheckCurrent(dpy, glxpm0, glxpm0, ctx);\n\t\t\tclr.clear(GL_FRONT);\n\t\t\tVERIFY_BUF_COLOR(GL_FRONT, clr.bits(-1), \"PM0\");\n\t\t\tif(!(glXMakeContextCurrent(dpy, glxpm1, glxpm1, ctx)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tcheckCurrent(dpy, glxpm1, glxpm1, ctx);\n\t\t\tglDrawBuffer(GL_BACK);  glReadBuffer(GL_BACK);\n\t\t\tXCopyArea(dpy, pm0, pm1, DefaultGC(dpy, DefaultScreen(dpy)), 0, 0,\n\t\t\t\tdpyw/2, dpyh/2, 0, 0);\n\t\t\tcheckReadbackState(GL_BACK, dpy, glxpm1, glxpm1, ctx);\n\t\t\tint temp=-1;  glGetIntegerv(GL_DRAW_BUFFER, &temp);\n\t\t\tif(temp!=GL_BACK) _error(\"Draw buffer changed\");\n\t\t\tVERIFY_BUF_COLOR(GL_BACK, clr.bits(-1), \"PM1\");\n\t\t\tVERIFY_BUF_COLOR(GL_FRONT, clr.bits(-1), \"PM1\");\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\tprintf(\"GLX Pixmap->2D Pixmap:          \");\n\t\t\tlastFrame=0;\n\t\t\tif(!(glXMakeContextCurrent(dpy, glxpm0, glxpm0, ctx)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tcheckCurrent(dpy, glxpm0, glxpm0, ctx);\n\n\t\t\tclr.clear(GL_FRONT);\n\t\t\tVERIFY_BUF_COLOR(GL_FRONT, clr.bits(-1), \"PM0\");\n\t\t\tglDrawBuffer(GL_BACK);  glReadBuffer(GL_BACK);\n\t\t\tXCopyArea(dpy, pm0, pm2, DefaultGC(dpy, DefaultScreen(dpy)), 0, 0,\n\t\t\t\tdpyw/2, dpyh/2, 0, 0);\n\t\t\tcheckReadbackState(GL_BACK, dpy, glxpm0, glxpm0, ctx);\n\t\t\tint temp=-1;  glGetIntegerv(GL_DRAW_BUFFER, &temp);\n\t\t\tif(temp!=GL_BACK) _error(\"Draw buffer changed\");\n\t\t\tcheckFrame(pm0, 1, lastFrame);\n\t\t\tcheckWindowColor(pm0, clr.bits(-1), false);\n\n\t\t\tclr.clear(GL_FRONT);\n\t\t\tclr.clear(GL_BACK);\n\t\t\tVERIFY_BUF_COLOR(GL_FRONT, clr.bits(-2), \"PM0\");\n\t\t\tglDrawBuffer(GL_BACK);  glReadBuffer(GL_BACK);\n\t\t\tXImage *xi=XGetImage(dpy, pm0, 0, 0, dpyw/2, dpyh/2, AllPlanes, ZPixmap);\n\t\t\tif(xi) XDestroyImage(xi);\n\t\t\tcheckReadbackState(GL_BACK, dpy, glxpm0, glxpm0, ctx);\n\t\t\ttemp=-1;  glGetIntegerv(GL_DRAW_BUFFER, &temp);\n\t\t\tif(temp!=GL_BACK) _error(\"Draw buffer changed\");\n\t\t\tcheckFrame(pm0, 1, lastFrame);\n\t\t\tcheckWindowColor(pm0, clr.bits(-2), false);\n\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t\ttry\n\t\t{\n\t\t\t// Same as above, but with a deleted GLX pixmap\n\t\t\tprintf(\"Deleted GLX Pixmap->2D Pixmap:  \");\n\t\t\tif(!(glXMakeContextCurrent(dpy, glxpm0, glxpm0, ctx)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tcheckCurrent(dpy, glxpm0, glxpm0, ctx);\n\t\t\tclr.clear(GL_FRONT);\n\t\t\tVERIFY_BUF_COLOR(GL_FRONT, clr.bits(-1), \"PM0\");\n\t\t\tglDrawBuffer(GL_BACK);  glReadBuffer(GL_BACK);\n\t\t\tif(!glXMakeContextCurrent(dpy, 0, 0, 0))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tglXDestroyPixmap(dpy, glxpm0);  glxpm0=0;\n\t\t\tXCopyArea(dpy, pm0, pm2, DefaultGC(dpy, DefaultScreen(dpy)), 0, 0,\n\t\t\t\tdpyw/2, dpyh/2, 0, 0);\n\t\t\tcheckFrame(pm0, 1, lastFrame);\n\t\t\tcheckWindowColor(pm0, clr.bits(-1), false);\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\n\t}\n\tcatch(Error &e)\n\t{\n\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t}\n\tglFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\t\tGL_RENDERBUFFER_EXT, 0);\n\tglBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0);\n\tif(rbo) { glDeleteRenderbuffersEXT(1, &rbo);  rbo=0; }\n\tglBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);\n\tif(fbo) { glDeleteFramebuffersEXT(1, &fbo);  fbo=0; }\n\tif(ctx && dpy)\n\t{\n\t\tglXMakeContextCurrent(dpy, 0, 0, 0);  glXDestroyContext(dpy, ctx);  ctx=0;\n\t}\n\tif(pb && dpy) { glXDestroyPbuffer(dpy, pb);  pb=0; }\n\tif(glxpm1 && dpy) { glXDestroyGLXPixmap(dpy, glxpm1);  glxpm1=0; }\n\tif(glxpm0 && dpy) { glXDestroyGLXPixmap(dpy, glxpm0);  glxpm0=0; }\n\tif(pm2 && dpy) { XFreePixmap(dpy, pm2);  pm2=0; }\n\tif(pm1 && dpy) { XFreePixmap(dpy, pm1);  pm1=0; }\n\tif(pm0 && dpy) { XFreePixmap(dpy, pm0);  pm0=0; }\n\tif(glxwin && dpy) { glXDestroyWindow(dpy, glxwin);  glxwin=0; }\n\tif(win && dpy) { XDestroyWindow(dpy, win);  win=0; }\n\tif(vis) { XFree(vis);  vis=NULL; }\n\tif(configs) { XFree(configs);  configs=NULL; }\n\tif(dpy) { XCloseDisplay(dpy);  dpy=NULL; }\n\treturn retval;\n}\n\n\n// Test whether glXMakeCurrent() can handle mismatches between the FB config\n// of the context and the off-screen drawable\n\nint contextMismatchTest(void)\n{\n\tDisplay *dpy=NULL;  Window win=0;\n\tint dpyw, dpyh, retval=1;\n\tint glxattrib1[]={ GLX_DOUBLEBUFFER, 1, GLX_RENDER_TYPE, GLX_RGBA_BIT,\n\t\tGLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT|GLX_PBUFFER_BIT|GLX_WINDOW_BIT,\n\t\tGLX_RED_SIZE, 8, GLX_GREEN_SIZE, 8, GLX_BLUE_SIZE, 8, None };\n\tint glxattrib2[]={ GLX_DOUBLEBUFFER, 0, GLX_RENDER_TYPE, GLX_RGBA_BIT,\n\t\tGLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT|GLX_PBUFFER_BIT|GLX_WINDOW_BIT,\n\t\tGLX_RED_SIZE, 8, GLX_GREEN_SIZE, 8, GLX_BLUE_SIZE, 8, GLX_ALPHA_SIZE, 8,\n\t\tNone };\n\tXVisualInfo *vis=NULL;\n\tGLXFBConfig config1=0, config2=0, *configs=NULL;  int n=0;\n\tGLXContext ctx1=0, ctx2=0;\n\tXSetWindowAttributes swa;\n\n\tprintf(\"Context FB config mismatch test:\\n\\n\");\n\n\ttry\n\t{\n\t\tif(!(dpy=XOpenDisplay(0)))  _throw(\"Could not open display\");\n\t\tdpyw=DisplayWidth(dpy, DefaultScreen(dpy));\n\t\tdpyh=DisplayHeight(dpy, DefaultScreen(dpy));\n\n\t\tif((configs=glXChooseFBConfig(dpy, DefaultScreen(dpy), glxattrib1,\n\t\t\t&n))==NULL || n==0)\n\t\t\t_throw(\"Could not find a suitable FB config\");\n\t\tconfig1=configs[0];\n\t\tif(!(vis=glXGetVisualFromFBConfig(dpy, config1)))\n\t\t\t_throw(\"glXGetVisualFromFBConfig()\");\n\t\tXFree(configs);  configs=NULL;\n\n\t\tif((configs=glXChooseFBConfig(dpy, DefaultScreen(dpy), glxattrib2,\n\t\t\t&n))==NULL || n==0)\n\t\t\t_throw(\"Could not find a suitable FB config\");\n\t\tconfig2=configs[0];\n\t\tXFree(configs);  configs=NULL;\n\n\t\tWindow root=RootWindow(dpy, DefaultScreen(dpy));\n\t\tswa.colormap=XCreateColormap(dpy, root, vis->visual, AllocNone);\n\t\tswa.border_pixel=0;\n\t\tswa.background_pixel=0;\n\t\tswa.event_mask = 0;\n\t\tif((win=XCreateWindow(dpy, root, 0, 0, dpyw/2, dpyh/2, 0, vis->depth,\n\t\t\tInputOutput, vis->visual, CWBorderPixel|CWColormap|CWEventMask,\n\t\t\t&swa))==0)\n\t\t\t_throw(\"Could not create window\");\n\t\tXMapWindow(dpy, win);\n\n\t\ttry\n\t\t{\n\t\t\tif(!(ctx1=glXCreateNewContext(dpy, config1, GLX_RGBA_TYPE, NULL, True)))\n\t\t\t\t_throw(\"Could not create context\");\n\t\t\tif(!(ctx2=glXCreateNewContext(dpy, config2, GLX_RGBA_TYPE, NULL, True)))\n\t\t\t\t_throw(\"Could not create context\");\n\n\t\t\tif(!(glXMakeCurrent(dpy, win, ctx1)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tif(!(glXMakeCurrent(dpy, win, ctx2)))\n\t\t\t\t_error(\"Could not make context current\");\n\n\t\t\tif(!(glXMakeContextCurrent(dpy, win, win, ctx1)))\n\t\t\t\t_error(\"Could not make context current\");\n\t\t\tif(!(glXMakeContextCurrent(dpy, win, win, ctx2)))\n\t\t\t\t_error(\"Could not make context current\");\n\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\t}\n\tcatch(Error &e)\n\t{\n\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t}\n\tif(ctx1 && dpy)\n\t{\n\t\tglXMakeContextCurrent(dpy, 0, 0, 0);  glXDestroyContext(dpy, ctx1);\n\t\tctx1=0;\n\t}\n\tif(ctx2 && dpy)\n\t{\n\t\tglXMakeContextCurrent(dpy, 0, 0, 0);  glXDestroyContext(dpy, ctx2);\n\t\tctx2=0;\n\t}\n\tif(win && dpy) { XDestroyWindow(dpy, win);  win=0; }\n\tif(vis) { XFree(vis);  vis=NULL; }\n\tif(configs) { XFree(configs);  configs=NULL; }\n\tif(dpy) { XCloseDisplay(dpy);  dpy=NULL; }\n\treturn retval;\n}\n\n\n// Test whether VirtualGL properly handles explicit and implicit destruction of\n// subwindows\n\nint subWinTest(void)\n{\n\tDisplay *dpy=NULL;  Window win=0, win1=0, win2=0;\n\tTestColor clr(0);\n\tint dpyw, dpyh, retval=1, lastFrame=0;\n\tint glxattrib[]={ GLX_DOUBLEBUFFER, GLX_RGBA, GLX_RED_SIZE, 8,\n\t\tGLX_GREEN_SIZE, 8, GLX_BLUE_SIZE, 8, None };\n\tXVisualInfo *vis=NULL;\n\tGLXContext ctx=0;\n\tXSetWindowAttributes swa;\n\n\tprintf(\"Subwindow destruction test:\\n\\n\");\n\n\ttry\n\t{\n\t\ttry\n\t\t{\n\t\t\tfor(int i=0; i<20; i++)\n\t\t\t{\n\t\t\t\tif(!dpy && !(dpy=XOpenDisplay(0)))\n\t\t\t\t\t_throw(\"Could not open display\");\n\t\t\t\tdpyw=DisplayWidth(dpy, DefaultScreen(dpy));\n\t\t\t\tdpyh=DisplayHeight(dpy, DefaultScreen(dpy));\n\n\t\t\t\tif((vis=glXChooseVisual(dpy, DefaultScreen(dpy),\n\t\t\t\t\tglxattrib))==NULL)\n\t\t\t\t\t_throw(\"Could not find a suitable visual\");\n\n\t\t\t\tWindow root=RootWindow(dpy, DefaultScreen(dpy));\n\t\t\t\tswa.colormap=XCreateColormap(dpy, root, vis->visual, AllocNone);\n\t\t\t\tswa.border_pixel=0;\n\t\t\t\tswa.background_pixel=0;\n\t\t\t\tswa.event_mask = 0;\n\t\t\t\tif(!win && (win=XCreateWindow(dpy, root, 0, 0, dpyw/2, dpyh/2, 0,\n\t\t\t\t\tvis->depth, InputOutput, vis->visual,\n\t\t\t\t\tCWBorderPixel|CWColormap|CWEventMask, &swa))==0)\n\t\t\t\t\t_throw(\"Could not create window\");\n\t\t\t\tif((win1=XCreateWindow(dpy, win, 0, 0, dpyw/2, dpyh/2, 0, vis->depth,\n\t\t\t\t\tInputOutput, vis->visual, CWBorderPixel|CWColormap|CWEventMask,\n\t\t\t\t\t&swa))==0)\n\t\t\t\t\t_throw(\"Could not create subwindow\");\n\t\t\t\tif((win2=XCreateWindow(dpy, win1, 0, 0, dpyw/2, dpyh/2, 0, vis->depth,\n\t\t\t\t\tInputOutput, vis->visual, CWBorderPixel|CWColormap|CWEventMask,\n\t\t\t\t\t&swa))==0)\n\t\t\t\t\t_throw(\"Could not create subwindow\");\n\t\t\t\tXMapSubwindows(dpy, win);\n\t\t\t\tXMapWindow(dpy, win);\n\n\t\t\t\tlastFrame=0;\n\t\t\t\tif(!(ctx=glXCreateContext(dpy, vis, NULL, True)))\n\t\t\t\t\t_throw(\"Could not create context\");\n\t\t\t\tXFree(vis);  vis=NULL;\n\t\t\t\tif(!(glXMakeCurrent(dpy, win2, ctx)))\n\t\t\t\t\t_error(\"Could not make context current\");\n\t\t\t\tclr.clear(GL_BACK);\n\t\t\t\tglXSwapBuffers(dpy, win2);\n\t\t\t\tcheckFrame(win2, 1, lastFrame);\n\t\t\t\tcheckWindowColor(win2, clr.bits(-1), false);\n\t\t\t\tglXMakeCurrent(dpy, 0, 0);\n\t\t\t\tglXDestroyContext(dpy, ctx);  ctx=0;\n\n\t\t\t\tif(i%3==0) { XCloseDisplay(dpy);  dpy=NULL;  win=0; }\n\t\t\t\telse if(i%3==1) { XDestroyWindow(dpy, win);  win=0; }\n\t\t\t\telse XDestroySubwindows(dpy, win);\n\t\t\t}\n\t\t\tprintf(\"SUCCESS\\n\");\n\t\t}\n\t\tcatch(Error &e)\n\t\t{\n\t\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t\t}\n\t\tfflush(stdout);\n\t}\n\tcatch(Error &e)\n\t{\n\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t}\n\tif(ctx && dpy)\n\t{\n\t\tglXMakeCurrent(dpy, 0, 0);  glXDestroyContext(dpy, ctx);  ctx=0;\n\t}\n\tif(win && dpy) { XDestroyWindow(dpy, win);  win=0; }\n\tif(vis) { XFree(vis);  vis=NULL; }\n\tif(dpy) { XCloseDisplay(dpy);  dpy=NULL; }\n\treturn retval;\n}\n\n\nint extensionQueryTest(void)\n{\n\tDisplay *dpy=NULL;  int retval=1;\n\tint dummy1=-1, dummy2=-1, dummy3=-1;\n\n\tprintf(\"Extension query test:\\n\\n\");\n\n\ttry\n\t{\n\t\tint major=-1, minor=-1;\n\t\tif((dpy=XOpenDisplay(0))==NULL)\n\t\t\t_throw(\"Could not open display\");\n\t\tif(!XQueryExtension(dpy, \"GLX\", &dummy1, &dummy2, &dummy3)\n\t\t\t|| dummy1<0 || dummy2<0 || dummy3<0)\n\t\t\t_throw(\"GLX Extension not reported as present\");\n\t\tchar *vendor=XServerVendor(dpy);\n\t\tif(!vendor || strcmp(vendor, \"Spacely Sprockets, Inc.\"))\n\t\t\t_throw(\"XServerVendor()\");\n\t\tglXQueryVersion(dpy, &major, &minor);\n\t\tprintf(\"glXQueryVersion():  %d.%d\\n\", major, minor);\n\t\tprintf(\"glXGetClientString():\\n\");\n\t\tprintf(\"  Version=%s\\n\", glXGetClientString(dpy, GLX_VERSION));\n\t\tprintf(\"  Vendor=%s\\n\", glXGetClientString(dpy, GLX_VENDOR));\n\t\tprintf(\"  Extensions=%s\\n\", glXGetClientString(dpy, GLX_EXTENSIONS));\n\t\tprintf(\"glXQueryServerString():\\n\");\n\t\tprintf(\"  Version=%s\\n\",\n\t\t\tglXQueryServerString(dpy, DefaultScreen(dpy), GLX_VERSION));\n\t\tprintf(\"  Vendor=%s\\n\",\n\t\t\tglXQueryServerString(dpy, DefaultScreen(dpy), GLX_VENDOR));\n\t\tprintf(\"  Extensions=%s\\n\",\n\t\t\tglXQueryServerString(dpy, DefaultScreen(dpy), GLX_EXTENSIONS));\n\t\tif(major<1 || minor<3)\n\t\t\t_throw(\"glXQueryVersion() reports version < 1.3\");\n\t\tprintf(\"glXQueryExtensionsString():\\n%s\\n\",\n\t\t\tglXQueryExtensionsString(dpy, DefaultScreen(dpy)));\n\t\tprintf(\"SUCCESS!\\n\");\n\t}\n\tcatch(Error &e)\n\t{\n\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t}\n\tfflush(stdout);\n\tif(dpy) { XCloseDisplay(dpy);  dpy=NULL; }\n\treturn retval;\n}\n\n\n#define TEST_PROC_SYM(f)  \\\n\tif((sym=(void *)glXGetProcAddressARB((const GLubyte *)#f))==NULL)  \\\n\t\t_throw(\"glXGetProcAddressARB(\\\"\"#f\"\\\") returned NULL\");  \\\n\telse if(sym!=(void *)f)  \\\n\t\t_throw(\"glXGetProcAddressARB(\\\"\"#f\"\\\")!=\"#f);\n\nint procAddrTest(void)\n{\n\tint retval=1;  void *sym=NULL;\n\n\tprintf(\"glXGetProcAddress test:\\n\\n\");\n\n\ttry\n\t{\n\t\tTEST_PROC_SYM(glXChooseVisual)\n\t\tTEST_PROC_SYM(glXCreateContext)\n\t\tTEST_PROC_SYM(glXMakeCurrent)\n\t\tTEST_PROC_SYM(glXChooseFBConfig)\n\t\tTEST_PROC_SYM(glXCreateNewContext)\n\t\tTEST_PROC_SYM(glXMakeContextCurrent)\n\t\tprintf(\"SUCCESS!\\n\");\n\t}\n\tcatch(Error &e)\n\t{\n\t\tprintf(\"Failed! (%s)\\n\", e.getMessage());  retval=0;\n\t}\n\tfflush(stdout);\n\treturn retval;\n}\n\n\nint main(int argc, char **argv)\n{\n\tint ret=0;  int nThreads=NTHREADS;  bool doStereo=true;\n\n\tif(putenv((char *)\"VGL_AUTOTEST=1\")==-1\n\t\t|| putenv((char *)\"VGL_SPOIL=0\")==-1\n\t\t|| putenv((char *)\"VGL_XVENDOR=Spacely Sprockets, Inc.\")==-1)\n\t{\n\t\tprintf(\"putenv() failed!\\n\");  return -1;\n\t}\n\n\tif(argc>1) for(int i=1; i<argc; i++)\n\t{\n\t\tif(!strcasecmp(argv[i], \"-n\") && i<argc-1)\n\t\t{\n\t\t\tint temp=atoi(argv[++i]);\n\t\t\tif(temp>=0 && temp<=NTHREADS) nThreads=temp;\n\t\t}\n\t\tif(!strcasecmp(argv[i], \"-nostereo\")) doStereo=false;\n\t}\n\n\t// Intentionally leave a pending dlerror()\n\tdlsym(RTLD_NEXT, \"ifThisSymbolExistsI'llEatMyHat\");\n\tdlsym(RTLD_NEXT, \"ifThisSymbolExistsI'llEatMyHat2\");\n\n\tif(!XInitThreads())\n\t\t_throw(\"XInitThreads() failed\");\n\tif(!extensionQueryTest()) ret=-1;\n\tprintf(\"\\n\");\n\tif(!procAddrTest()) ret=-1;\n\tprintf(\"\\n\");\n\tif(!readbackTest(false)) ret=-1;\n\tprintf(\"\\n\");\n\tif(doStereo)\n\t{\n\t\tif(!readbackTest(true)) ret=-1;\n\t\tprintf(\"\\n\");\n\t}\n\tif(!contextMismatchTest()) ret=-1;\n\tprintf(\"\\n\");\n\tif(!flushTest()) ret=-1;\n\tprintf(\"\\n\");\n\tif(!visTest()) ret=-1;\n\tprintf(\"\\n\");\n\tif(!multiThreadTest(nThreads)) ret=-1;\n\tprintf(\"\\n\");\n\tif(!offScreenTest()) ret=-1;\n\tprintf(\"\\n\");\n\tif(!subWinTest()) ret=-1;\n\tprintf(\"\\n\");\n\n\treturn ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/server/dlfaker.c": "/* Copyright (C)2006 Sun Microsystems, Inc.\n * Copyright (C)2009, 2012, 2015, 2017 D. R. Commander\n *\n * This library is free software and may be redistributed and/or modified under\n * the terms of the wxWindows Library License, Version 3.1 or (at your option)\n * any later version.  The full license is in the LICENSE.txt file included\n * with this distribution.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * wxWindows Library License for more details.\n */\n\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include \"vendor.h\"\n\n\nextern void *_vgl_dlopen(const char *, int);\n\n\n/* If an application uses dlopen()/dlsym() to load functions from libGL or\n   libX11, this bypasses the LD_PRELOAD mechanism.  Thus, VirtualGL has to\n   intercept dlopen() and return a handle to itself rather than a handle to\n   libGL or libX11.\n\n   NOTE: If the application tries to use dlopen() to obtain a handle to libdl,\n   we similarly replace the handle with a handle to libdlfaker.  This works\n   around an interaction issue between 180.xx of the nVidia drivers and WINE.\n*/\n\nvoid *dlopen(const char *filename, int flag)\n{\n\tchar *env=NULL, *env2=NULL;  const char *envname=\"FAKERLIB32\";\n\tint verbose=0, trace=0;\n\tvoid *retval=NULL;\n\n\tif(sizeof(long)==8) envname=\"FAKERLIB\";\n\tif((env2=getenv(\"VGL_VERBOSE\"))!=NULL && strlen(env2)>0\n\t\t&& !strncmp(env2, \"1\", 1)) verbose=1;\n\tif((env2=getenv(\"VGL_TRACE\"))!=NULL && strlen(env2)>0\n\t\t&& !strncmp(env2, \"1\", 1)) trace=1;\n\n\tif(trace)\n\t{\n\t\tfprintf(stderr, \"[VGL] dlopen (filename=%s flag=%d\",\n\t\t\tfilename? filename:\"NULL\", flag);\n\t}\n\n\t#ifdef RTLD_DEEPBIND\n\tflag&=(~RTLD_DEEPBIND);\n\t#endif\n\n\tif((env=getenv(envname))==NULL || strlen(env)<1)\n\t\tenv=\"lib\"VGL_FAKER_NAME\".so\";\n\tif(filename &&\n\t\t(!strncmp(filename, \"libGL.\", 6) || strstr(filename, \"/libGL.\")\n\t\t\t|| !strncmp(filename, \"libX11.\", 7) || strstr(filename, \"/libX11.\")\n\t\t\t|| (flag&RTLD_LAZY\n\t\t\t\t\t&& (!strncmp(filename, \"libopengl.\", 10)\n\t\t\t\t\t\t\t|| strstr(filename, \"/libopengl.\")))))\n\t{\n\t\tif(verbose)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"[VGL] NOTICE: Replacing dlopen(\\\"%s\\\") with dlopen(\\\"%s\\\")\\n\",\n\t\t\t\tfilename? filename:\"NULL\", env? env:\"NULL\");\n\t\tretval=_vgl_dlopen(env, flag);\n\t}\n\telse if(filename && (!strncmp(filename, \"libdl.\", 6)\n\t\t|| strstr(filename, \"/libdl.\")))\n\t{\n\t\tif(verbose)\n\t\t\tfprintf(stderr, \"[VGL] NOTICE: Replacing dlopen(\\\"%s\\\") with dlopen(\\\"lib\"VGL_DLFAKER_NAME\".so\\\")\\n\",\n\t\t\t\tfilename? filename:\"NULL\");\n\t\tretval=_vgl_dlopen(\"lib\"VGL_DLFAKER_NAME\".so\", flag);\n\t}\n\telse retval=_vgl_dlopen(filename, flag);\n\n\tif(!retval && filename && !strncmp(filename, \"VBoxOGL\", 7))\n\t{\n\t\tchar temps[256];\n\t\tsnprintf(temps, 255, \"/usr/lib/virtualbox/%s\", filename);\n\t\tif(verbose)\n\t\t{\n\t\t\tfprintf(stderr, \"[VGL] NOTICE: dlopen(\\\"%s\\\") failed.\\n\", filename);\n\t\t\tfprintf(stderr, \"[VGL]    Trying dlopen(\\\"%s\\\")\\n\", temps);\n\t\t}\n\t\tretval=_vgl_dlopen(temps, flag);\n\t}\n\n\tif(trace)\n\t{\n\t\tfprintf(stderr, \" retval=0x%.8lx)\\n\", (long)retval);\n\t}\n\n\treturn retval;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/server/faker-sym.cpp": "/* Copyright (C)2004 Landmark Graphics Corporation\n * Copyright (C)2005, 2006 Sun Microsystems, Inc.\n * Copyright (C)2009, 2011, 2013-2016 D. R. Commander\n *\n * This library is free software and may be redistributed and/or modified under\n * the terms of the wxWindows Library License, Version 3.1 or (at your option)\n * any later version.  The full license is in the LICENSE.txt file included\n * with this distribution.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * wxWindows Library License for more details.\n */\n\n#define __LOCALSYM__\n#include \"faker-sym.h\"\n#include <dlfcn.h>\n#include <string.h>\n#include \"fakerconfig.h\"\n\n\nstatic void *gldllhnd=NULL;\nstatic void *loadGLSymbol(const char *, bool);\nstatic void *x11dllhnd=NULL;\nstatic void *loadX11Symbol(const char *, bool);\n#ifdef FAKEXCB\nstatic void *xcbdllhnd=NULL;\nstatic void *loadXCBSymbol(const char *, bool);\nstatic void *xcbglxdllhnd=NULL;\nstatic void *loadXCBGLXSymbol(const char *, bool);\nstatic void *xcbkeysymsdllhnd=NULL;\nstatic void *loadXCBKeysymsSymbol(const char *, bool);\nstatic void *xcbx11dllhnd=NULL;\nstatic void *loadXCBX11Symbol(const char *, bool);\n#endif\n\n\n// Attempt to load the glXGetProcAddress[ARB]() function.  This also checks\n// whether dlsym() is returning our interposed version of\n// glXGetProcAddress[ARB]() instead of the \"real\" function from libGL.  If so,\n// then it's probably because another DSO in the process is interposing dlsym()\n// (I'm looking at you, Steam.)\n#define FIND_GLXGETPROCADDRESS(f) {  \\\n\t__glXGetProcAddress=(_##f##Type)dlsym(gldllhnd, #f);  \\\n\tif(__glXGetProcAddress==f) {  \\\n\t\tvglout.print(\"[VGL] ERROR: VirtualGL attempted to load the real \" #f \" function\\n\");  \\\n\t\tvglout.print(\"[VGL]   and got the fake one instead.  Something is terribly wrong.  Aborting\\n\");  \\\n\t\tvglout.print(\"[VGL]   before chaos ensues.\\n\");  \\\n\t\tvglfaker::safeExit(1);  \\\n\t}  \\\n}\n\n\nnamespace vglfaker\n{\n\nvoid *loadSymbol(const char *name, bool optional)\n{\n\tif(!name)\n\t{\n\t\tvglout.print(\"[VGL] ERROR: Invalid argument in loadSymbol()\\n\");\n\t\tsafeExit(1);\n\t}\n\tif(!strncmp(name, \"gl\", 2))\n\t\treturn loadGLSymbol(name, optional);\n\t#ifdef FAKEXCB\n\telse if(!strcmp(name, \"XGetXCBConnection\")\n\t\t|| !strcmp(name, \"XSetEventQueueOwner\"))\n\t\treturn loadXCBX11Symbol(name, optional);\n\t#endif\n\telse if(!strncmp(name, \"X\", 1))\n\t\treturn loadX11Symbol(name, optional);\n\t#ifdef FAKEXCB\n\telse if(!strncmp(name, \"xcb_glx\", 7))\n\t\treturn loadXCBGLXSymbol(name, optional);\n\telse if(!strncmp(name, \"xcb_key\", 7))\n\t\treturn loadXCBKeysymsSymbol(name, optional);\n\telse if(!strncmp(name, \"xcb_\", 4))\n\t\treturn loadXCBSymbol(name, optional);\n\t#endif\n\telse\n\t{\n\t\tvglout.print(\"[VGL] ERROR: don't know how to load symbol \\\"%s\\\"\\n\", name);\n\t\treturn NULL;\n\t}\n}\n\n} // namespace\n\n\nstatic void *loadGLSymbol(const char *name, bool optional)\n{\n\tchar *err=NULL;\n\n\tif(!__glXGetProcAddress)\n\t{\n\t\tif(strlen(fconfig.gllib)>0)\n\t\t{\n\t\t\tdlerror();  // Clear error state\n\t\t\tvoid *dllhnd=_vgl_dlopen(fconfig.gllib, RTLD_LAZY);\n\t\t\terr=dlerror();\n\t\t\tif(!dllhnd)\n\t\t\t{\n\t\t\t\tvglout.print(\"[VGL] ERROR: Could not open %s\\n\", fconfig.gllib);\n\t\t\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgldllhnd=dllhnd;\n\t\t}\n\t\telse gldllhnd=RTLD_NEXT;\n\n\t\tdlerror();  // Clear error state\n\t\tFIND_GLXGETPROCADDRESS(glXGetProcAddress)\n\t\tif(!__glXGetProcAddress)\n\t\t\tFIND_GLXGETPROCADDRESS(glXGetProcAddressARB)\n\t\terr=dlerror();\n\n\t\tif(!__glXGetProcAddress)\n\t\t{\n\t\t\tvglout.print(\"[VGL] ERROR: Could not load GLX/OpenGL functions\");\n\t\t\tif(strlen(fconfig.gllib)>0)\n\t\t\t\tvglout.print(\" from %s\", fconfig.gllib);\n\t\t\tvglout.print(\"\\n\");\n\t\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tvoid *sym=NULL;\n\tif(!strcmp(name, \"glXGetProcAddress\") ||\n\t\t!strcmp(name, \"glXGetProcAddressARB\"))\n\t\tsym=(void *)__glXGetProcAddress;\n\telse\n\t{\n\t\t// For whatever reason, on Solaris, if a function doesn't exist in libGL,\n\t\t// glXGetProcAddress() will return the address of VGL's interposed\n\t\t// version, which causes an infinite loop until the program blows its stack\n\t\t// and segfaults.  Thus, we use the old reliable dlsym() method by default.\n\t\t// On Linux and FreeBSD, we use glXGetProcAddress[ARB]() by default, to\n\t\t// work around issues with certain drivers, but because Steam's\n\t\t// gameoverlayrenderer.so interposer causes a similar problem to the\n\t\t// aforementioned issue on Solaris, we allow the GL symbol loading method\n\t\t// to be controlled at run time using an environment variable (VGL_DLSYM).\n\t\tif(fconfig.dlsymloader)\n\t\t{\n\t\t\tdlerror();  // Clear error state\n\t\t\tsym=dlsym(gldllhnd, (char *)name);\n\t\t\terr=dlerror();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsym=(void *)__glXGetProcAddress((const GLubyte *)name);\n\t\t}\n\t}\n\n\tif(!sym && (fconfig.verbose || !optional))\n \t{\n\t \tvglout.print(\"[VGL] %s: Could not load function \\\"%s\\\"\",\n\t\t \toptional? \"WARNING\":\"ERROR\", name);\n\t\tif(strlen(fconfig.gllib)>0)\n\t\t\tvglout.print(\" from %s\", fconfig.gllib);\n\t\tvglout.print(\"\\n\");\n\t}\n\treturn sym;\n}\n\n\nstatic void *loadX11Symbol(const char *name, bool optional)\n{\n\tchar *err=NULL;\n\n\tif(!x11dllhnd)\n\t{\n\t\tif(strlen(fconfig.x11lib)>0)\n\t\t{\n\t\t\tdlerror();  // Clear error state\n\t\t\tvoid *dllhnd=_vgl_dlopen(fconfig.x11lib, RTLD_LAZY);\n\t\t\terr=dlerror();\n\t\t\tif(!dllhnd)\n\t\t\t{\n\t\t\t\tvglout.print(\"[VGL] ERROR: Could not open %s\\n\", fconfig.x11lib);\n\t\t\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tx11dllhnd=dllhnd;\n\t\t}\n\t\telse x11dllhnd=RTLD_NEXT;\n\t}\n\n\tdlerror();  // Clear error state\n\tvoid *sym=dlsym(x11dllhnd, (char *)name);\n\terr=dlerror();\n\n\tif(!sym && (fconfig.verbose || !optional))\n\t{\n\t\tvglout.print(\"[VGL] %s: Could not load function \\\"%s\\\"\",\n\t\t\toptional? \"WARNING\":\"ERROR\", name);\n\t\tif(strlen(fconfig.x11lib)>0)\n\t\t\tvglout.print(\" from %s\", fconfig.x11lib);\n\t\tvglout.print(\"\\n\");\n\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);\n\t}\n\treturn sym;\n}\n\n\n#ifdef FAKEXCB\n\n#define LOAD_XCB_SYMBOL(ID, id, libid, minrev, maxrev)  \\\nstatic void *load##ID##Symbol(const char *name, bool optional)  \\\n{  \\\n\tchar *err=NULL;  \\\n  \\\n\tif(!id##dllhnd)  \\\n\t{  \\\n\t\tif(strlen(fconfig.id##lib)>0)  \\\n\t\t{  \\\n\t\t\tdlerror();  \\\n\t\t\tvoid *dllhnd=_vgl_dlopen(fconfig.id##lib, RTLD_LAZY);  \\\n\t\t\terr=dlerror();  \\\n\t\t\tif(!dllhnd)  \\\n\t\t\t{  \\\n\t\t\t\tif(fconfig.verbose || !optional)  \\\n\t\t\t\t{  \\\n\t\t\t\t\tvglout.print(\"[VGL] %s: Could not open %s\\n\",  \\\n\t\t\t\t\t\toptional? \"WARNING\":\"ERROR\", fconfig.id##lib);  \\\n\t\t\t\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);  \\\n\t\t\t\t}  \\\n\t\t\t\treturn NULL;  \\\n\t\t\t}  \\\n\t\t\tid##dllhnd=dllhnd;  \\\n\t\t}  \\\n\t\telse  \\\n\t\t{  \\\n\t\t\tvoid *dllhnd=NULL;  \\\n\t\t\tfor(int i=minrev; i<=maxrev; i++)  \\\n\t\t\t{  \\\n\t\t\t\tchar libName[MAXSTR];  \\\n\t\t\t\tsnprintf(libName, MAXSTR, \"lib%s.so.%d\", #libid, i);  \\\n\t\t\t\tdlerror();  \\\n\t\t\t\tdllhnd=_vgl_dlopen(libName, RTLD_LAZY);  \\\n\t\t\t\terr=dlerror();  \\\n\t\t\t\tif(dllhnd) break;  \\\n\t\t\t}  \\\n\t\t\tif(!dllhnd)  \\\n\t\t\t{  \\\n\t\t\t\tif(fconfig.verbose || !optional)  \\\n\t\t\t\t{  \\\n\t\t\t\t\tvglout.print(\"[VGL] %s: Could not open lib%s\\n\",  \\\n\t\t\t\t\t\toptional? \"WARNING\":\"ERROR\", #libid);  \\\n\t\t\t\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);  \\\n\t\t\t\t}  \\\n\t\t\t\treturn NULL;  \\\n\t\t\t}  \\\n\t\t\tid##dllhnd=dllhnd;  \\\n\t\t}  \\\n\t}  \\\n  \\\n\tdlerror();  \\\n\tvoid *sym=dlsym(id##dllhnd, (char *)name);  \\\n\terr=dlerror();  \\\n  \\\n\tif(!sym && (fconfig.verbose || !optional))  \\\n\t{  \\\n\t\tvglout.print(\"[VGL] %s: Could not load symbol \\\"%s\\\"\",  \\\n\t\t\toptional? \"WARNING\":\"ERROR\", name);  \\\n\t\tif(strlen(fconfig.id##lib)>0)  \\\n\t\t\tvglout.print(\" from %s\", fconfig.id##lib);  \\\n\t\tvglout.print(\"\\n\");  \\\n\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);  \\\n\t}  \\\n\treturn sym;  \\\n}\n\nLOAD_XCB_SYMBOL(XCB, xcb, xcb, 1, 1)\nLOAD_XCB_SYMBOL(XCBGLX, xcbglx, xcb-glx, 0, 0);\nLOAD_XCB_SYMBOL(XCBKeysyms, xcbkeysyms, xcb-keysyms, 0, 1)\nLOAD_XCB_SYMBOL(XCBX11, xcbx11, X11-xcb, 1, 1)\n\n#endif\n\n\nnamespace vglfaker {\n\nvoid unloadSymbols(void)\n{\n\tif(gldllhnd && gldllhnd!=RTLD_NEXT) dlclose(gldllhnd);\n\tif(x11dllhnd && x11dllhnd!=RTLD_NEXT) dlclose(x11dllhnd);\n\t#ifdef FAKEXCB\n\tif(xcbdllhnd) dlclose(xcbdllhnd);\n\tif(xcbglxdllhnd) dlclose(xcbglxdllhnd);\n\tif(xcbkeysymsdllhnd) dlclose(xcbkeysymsdllhnd);\n\tif(xcbx11dllhnd) dlclose(xcbx11dllhnd);\n\t#endif\n}\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/server/CMakeLists.txt": "###############################################################################\n# SERVER\n###############################################################################\n\nset(VGL_DEFAULTSYSTEMFLTK 0)\noption(VGL_SYSTEMFLTK\n\t\"Link against a system-supplied version of FLTK instead of the in-tree version.\"\n\t${VGL_DEFAULTSYSTEMFLTK})\nif(VGL_SYSTEMFLTK)\n\tfind_package(FLTK)\nelse()\n\tmessage(STATUS \"Using in-tree version of FLTK\")\n\tadd_subdirectory(fltk)\n\tset(FLTK_INCLUDE_DIR fltk)\n\tset(FLTK_BASE_LIBRARY fltk_static)\nendif()\n\nconfigure_file(fakerconfig.h.in fakerconfig.h)\nconfigure_file(vendor.h.in vendor.h)\n\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR}\n\t../common)\n\nset(FBXFAKERLIB fbx-faker)\nif(VGL_USEXV)\n\tset(FBXFAKERLIB ${FBXFAKERLIB};fbxv)\nendif()\n\noption(VGL_FAKEXCB \"Interpose enough of the XCB API to make Qt 5 work\" ON)\nif(VGL_FAKEXCB)\n\tadd_definitions(-DFAKEXCB)\n\tset(FAKER_XCB_SOURCES faker-xcb.cpp XCBConnHash.cpp)\n\tset(VGL_DEFAULTSYSTEMXCB 0)\n\toption(VGL_SYSTEMXCB\n\t\t\"Compile against system-supplied versions of the XCB headers instead of the in-tree versions.\"\n\t\t\t${VGL_DEFAULTSYSTEMXCB})\n\tif(VGL_SYSTEMXCB)\n\t\tadd_definitions(-DSYSXCBHEADERS)\n\tendif()\nendif()\n\nget_directory_property(DEFS_PROP COMPILE_DEFINITIONS)\nforeach(def ${DEFS_PROP})\n\tset(DEFINES ${DEFINES};-D${def})\nendforeach()\nadd_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/faker-mapfile\n\tCOMMAND ${CMAKE_C_COMPILER} ${DEFINES} -E\n\t\t${CMAKE_CURRENT_SOURCE_DIR}/faker-mapfile.c\n\t\t> ${CMAKE_CURRENT_BINARY_DIR}/faker-mapfile\n\tDEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/faker-mapfile.c)\n\nset(FAKER_SOURCES\n\tConfigHash.cpp\n\tContextHash.cpp\n\tDisplayHash.cpp\n\tfaker.cpp\n\tfaker-gl.cpp\n\tfaker-glx.cpp\n\tfaker-sym.cpp\n\tfaker-x11.cpp\n\t${FAKER_XCB_SOURCES}\n\tfakerconfig.cpp\n\tGlobalCriticalSection.cpp\n\tGLXDrawableHash.cpp\n\tglxvisual.cpp\n\tPixmapHash.cpp\n\tReverseConfigHash.cpp\n\tTransPlugin.cpp\n\tVirtualDrawable.cpp\n\tVirtualPixmap.cpp\n\tVirtualWin.cpp\n\tVisualHash.cpp\n\tWindowHash.cpp\n\tX11Trans.cpp\n\tvglconfigLauncher.cpp\n\tVGLTrans.cpp)\nif(VGL_USEXV)\n\tset(FAKER_SOURCES ${FAKER_SOURCES};XVTrans.cpp)\nendif()\n\nforeach(fakerlib ${VGL_FAKER_NAME} ${VGL_FAKER_NAME}-nodl)\n\tadd_library(${fakerlib} SHARED ${FAKER_SOURCES})\n\tif(${fakerlib} STREQUAL ${VGL_FAKER_NAME} AND\n\t\tCMAKE_SYSTEM_NAME MATCHES \"Linux\")\n\t\t# GCC 4.6 and later on Linux apparently passes --as-needed to the linker,\n\t\t# and since libvglfaker.so loads OpenGL/GLX functions indirectly (with\n\t\t# dlopen()/dlsym()), --as-needed prevents the linker from adding a\n\t\t# DT_NEEDED tag for libGL to libvglfaker.so.  Without the following fix,\n\t\t# when attempting to vglrun applications that themselves indirectly load\n\t\t# OpenGL functions, libGL would not be loaded into the process, and VGL's\n\t\t# calls to dlsym(RTLD_NEXT, ...) would fail.\n\t\tset(NOASNEEDED \"-Wl,--no-as-needed\")\n\tendif()\n\tif(MAPFLAG)\n\t\tset_source_files_properties(faker-sym.cpp PROPERTIES\n\t\t\tOBJECT_DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/faker-mapfile)\n\t\tset_target_properties(${fakerlib} PROPERTIES\n\t\t\tLINK_FLAGS \"${MINUSZ}defs ${MAPFLAG}${CMAKE_CURRENT_BINARY_DIR}/faker-mapfile ${NOASNEEDED}\")\n\telse()\n\t\tset_target_properties(${fakerlib} PROPERTIES LINK_FLAGS \"${MINUSZ}defs ${NOASNEEDED}\")\n\tendif()\n\ttarget_link_libraries(${fakerlib} vglcommon ${FBXFAKERLIB} vglsocket m\n\t\t${LIBDL})\n\tif(${fakerlib} STREQUAL ${VGL_FAKER_NAME})\n\t\ttarget_link_libraries(${fakerlib} ${OPENGL_gl_LIBRARY})\n\tendif()\n\tif(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\" AND GNUCXX)\n\t\t# For some reason, on SunOS/GCC CMake tries to use the C compiler to link\n\t\t# C++ shared libs.  Grrr...  (NOTE: This was fixed in CMake v3.4, so we\n\t\t# can remove this if we ever require a version later than that.)\n\t\ttarget_link_libraries(${fakerlib} stdc++)\n\tendif()\n\tinstall(TARGETS ${fakerlib} DESTINATION ${CMAKE_INSTALL_LIBDIR})\nendforeach()\n\nadd_library(${VGL_DLFAKER_NAME} SHARED dlfaker.c)\ntarget_link_libraries(${VGL_DLFAKER_NAME} ${LIBDL})\ninstall(TARGETS ${VGL_DLFAKER_NAME} DESTINATION ${CMAKE_INSTALL_LIBDIR})\n\nadd_library(${VGL_GEFAKER_NAME} SHARED gefaker.c)\nset_target_properties(${VGL_GEFAKER_NAME} PROPERTIES LINK_FLAGS \"${MINUSZ}defs\")\ntarget_link_libraries(${VGL_GEFAKER_NAME} ${LIBDL})\ninstall(TARGETS ${VGL_GEFAKER_NAME} DESTINATION ${CMAKE_INSTALL_LIBDIR})\n\nset(HEADERS ../common/rr.h rrtransport.h)\ninstall(FILES ${HEADERS} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\ninclude_directories(${FLTK_INCLUDE_DIR})\nadd_executable(vglconfig vglconfig.cpp fakerconfig.cpp)\ntarget_link_libraries(vglconfig ${X11_X11_LIB} ${FLTK_BASE_LIBRARY} vglutil)\nif(VGL_USEXV)\n\ttarget_link_libraries(vglconfig ${X11_Xv_LIB})\nendif()\ninstall(TARGETS vglconfig DESTINATION ${CMAKE_INSTALL_BINDIR})\n\ninstall(PROGRAMS vglgenkey vgllogin vglserver_config DESTINATION\n\t${CMAKE_INSTALL_BINDIR})\n\nconfigure_file(vglrun.in ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/vglrun @ONLY)\nexecute_process(COMMAND chmod +x vglrun\n\tWORKING_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})\ninstall(PROGRAMS ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/vglrun\n\tDESTINATION ${CMAKE_INSTALL_BINDIR})\nconfigure_file(vglrun.vars.in\n\t${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/.vglrun.vars${BITS} @ONLY)\nexecute_process(COMMAND chmod +x .vglrun.vars${BITS}\n\tWORKING_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})\ninstall(PROGRAMS ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/.vglrun.vars${BITS}\n\tDESTINATION ${CMAKE_INSTALL_BINDIR})\n\n\n###############################################################################\n# UNIT TESTS\n###############################################################################\n\nadd_executable(x11transut x11transut.cpp fakerconfig.cpp X11Trans.cpp)\ntarget_link_libraries(x11transut vglcommon ${FBXLIB} ${TJPEG_LIBRARY})\n\nadd_executable(vgltransut vgltransut.cpp VGLTrans.cpp\n\tfakerconfig.cpp)\ntarget_link_libraries(vgltransut vglcommon ${FBXLIB} vglsocket\n\t${TJPEG_LIBRARY})\n\nadd_executable(dlfakerut dlfakerut.c)\ntarget_link_libraries(dlfakerut ${X11_X11_LIB} ${LIBDL})\n\nadd_library(GLdlfakerut SHARED libGLdlfakerut.c)\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n\tadd_library(deepbindtest SHARED libdeepbindtest.c)\n\ttarget_link_libraries(deepbindtest ${X11_X11_LIB} ${OPENGL_gl_LIBRARY})\n\tset_target_properties(deepbindtest PROPERTIES LINK_FLAGS \"${MINUSZ}defs\")\nendif()\n\nadd_executable(fakerut fakerut.cpp fakerut-supplement.c)\ntarget_link_libraries(fakerut \"${MINUSZ}now ${OPENGL_gl_LIBRARY}\"\n\t${OPENGL_glu_LIBRARY} \"${MINUSZ}now ${X11_X11_LIB}\" ${LIBDL} vglutil)\n\nadd_library(vgltrans_test SHARED testplugin.cpp VGLTrans.cpp)\nif(VGL_USESSL AND CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n\t# Work around this issue:\n\t# http://rt.openssl.org/Ticket/Display.html?user=guest&pass=guest&id=1521\n\tset_target_properties(vgltrans_test PROPERTIES LINK_FLAGS \"-Wl,-Bsymbolic\")\nendif()\ntarget_link_libraries(vgltrans_test vglcommon ${FBXFAKERLIB} ${TJPEG_LIBRARY}\n\tvglsocket)\nif(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\" AND GNUCXX)\n\ttarget_link_libraries(vgltrans_test stdc++)\nendif()\n\nadd_library(vgltrans_test2 SHARED testplugin2.cpp X11Trans.cpp)\ntarget_link_libraries(vgltrans_test2 vglcommon ${FBXFAKERLIB} ${TJPEG_LIBRARY})\nif(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\" AND GNUCXX)\n\ttarget_link_libraries(vgltrans_test2 stdc++)\nendif()\n\nconfigure_file(servertest.in ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/servertest)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/server/fltk/FL/mac.r",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/doc/444.gif",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/doc/vgltransportservernetwork.odg",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/doc/sshtunnel.png",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/doc/vgltransport.png",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/doc/configdialog.gif",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/doc/411.gif",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/doc/x11transport.odg",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/doc/somerights20.png",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/doc/vgltransport.odg",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/doc/x11transport.png",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/doc/422.gif",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-zslclne4p7glh5wuzz7ytm6cummuefyk/spack-src/doc/vgltransportservernetwork.png"
    ],
    "total_files": 497
}