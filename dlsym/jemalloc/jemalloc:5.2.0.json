{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-jemalloc-5.2.0-gqn3zrvt7mtn3szbgv2rwmc4lnriytmn/spack-src/configure.ac": "dnl Process this file with autoconf to produce a configure script.\nAC_PREREQ(2.68)\nAC_INIT([Makefile.in])\n\nAC_CONFIG_AUX_DIR([build-aux])\n\ndnl ============================================================================\ndnl Custom macro definitions.\n\ndnl JE_CONCAT_VVV(r, a, b)\ndnl\ndnl Set $r to the concatenation of $a and $b, with a space separating them iff\ndnl both $a and $b are non-empty.\nAC_DEFUN([JE_CONCAT_VVV],\nif test \"x[$]{$2}\" = \"x\" -o \"x[$]{$3}\" = \"x\" ; then\n  $1=\"[$]{$2}[$]{$3}\"\nelse\n  $1=\"[$]{$2} [$]{$3}\"\nfi\n)\n\ndnl JE_APPEND_VS(a, b)\ndnl\ndnl Set $a to the concatenation of $a and b, with a space separating them iff\ndnl both $a and b are non-empty.\nAC_DEFUN([JE_APPEND_VS],\n  T_APPEND_V=$2\n  JE_CONCAT_VVV($1, $1, T_APPEND_V)\n)\n\nCONFIGURE_CFLAGS=\nSPECIFIED_CFLAGS=\"${CFLAGS}\"\ndnl JE_CFLAGS_ADD(cflag)\ndnl\ndnl CFLAGS is the concatenation of CONFIGURE_CFLAGS and SPECIFIED_CFLAGS\ndnl (ignoring EXTRA_CFLAGS, which does not impact configure tests.  This macro\ndnl appends to CONFIGURE_CFLAGS and regenerates CFLAGS.\nAC_DEFUN([JE_CFLAGS_ADD],\n[\nAC_MSG_CHECKING([whether compiler supports $1])\nT_CONFIGURE_CFLAGS=\"${CONFIGURE_CFLAGS}\"\nJE_APPEND_VS(CONFIGURE_CFLAGS, $1)\nJE_CONCAT_VVV(CFLAGS, CONFIGURE_CFLAGS, SPECIFIED_CFLAGS)\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n[[\n]], [[\n    return 0;\n]])],\n              [je_cv_cflags_added=$1]\n              AC_MSG_RESULT([yes]),\n              [je_cv_cflags_added=]\n              AC_MSG_RESULT([no])\n              [CONFIGURE_CFLAGS=\"${T_CONFIGURE_CFLAGS}\"]\n)\nJE_CONCAT_VVV(CFLAGS, CONFIGURE_CFLAGS, SPECIFIED_CFLAGS)\n])\n\ndnl JE_CFLAGS_SAVE()\ndnl JE_CFLAGS_RESTORE()\ndnl\ndnl Save/restore CFLAGS.  Nesting is not supported.\nAC_DEFUN([JE_CFLAGS_SAVE],\nSAVED_CONFIGURE_CFLAGS=\"${CONFIGURE_CFLAGS}\"\n)\nAC_DEFUN([JE_CFLAGS_RESTORE],\nCONFIGURE_CFLAGS=\"${SAVED_CONFIGURE_CFLAGS}\"\nJE_CONCAT_VVV(CFLAGS, CONFIGURE_CFLAGS, SPECIFIED_CFLAGS)\n)\n\nCONFIGURE_CXXFLAGS=\nSPECIFIED_CXXFLAGS=\"${CXXFLAGS}\"\ndnl JE_CXXFLAGS_ADD(cxxflag)\nAC_DEFUN([JE_CXXFLAGS_ADD],\n[\nAC_MSG_CHECKING([whether compiler supports $1])\nT_CONFIGURE_CXXFLAGS=\"${CONFIGURE_CXXFLAGS}\"\nJE_APPEND_VS(CONFIGURE_CXXFLAGS, $1)\nJE_CONCAT_VVV(CXXFLAGS, CONFIGURE_CXXFLAGS, SPECIFIED_CXXFLAGS)\nAC_LANG_PUSH([C++])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n[[\n]], [[\n    return 0;\n]])],\n              [je_cv_cxxflags_added=$1]\n              AC_MSG_RESULT([yes]),\n              [je_cv_cxxflags_added=]\n              AC_MSG_RESULT([no])\n              [CONFIGURE_CXXFLAGS=\"${T_CONFIGURE_CXXFLAGS}\"]\n)\nAC_LANG_POP([C++])\nJE_CONCAT_VVV(CXXFLAGS, CONFIGURE_CXXFLAGS, SPECIFIED_CXXFLAGS)\n])\n\ndnl JE_COMPILABLE(label, hcode, mcode, rvar)\ndnl\ndnl Use AC_LINK_IFELSE() rather than AC_COMPILE_IFELSE() so that linker errors\ndnl cause failure.\nAC_DEFUN([JE_COMPILABLE],\n[\nAC_CACHE_CHECK([whether $1 is compilable],\n               [$4],\n               [AC_LINK_IFELSE([AC_LANG_PROGRAM([$2],\n                                                [$3])],\n                               [$4=yes],\n                               [$4=no])])\n])\n\ndnl ============================================================================\n\nCONFIG=`echo ${ac_configure_args} | sed -e 's#'\"'\"'\\([^ ]*\\)'\"'\"'#\\1#g'`\nAC_SUBST([CONFIG])\n\ndnl Library revision.\nrev=2\nAC_SUBST([rev])\n\nsrcroot=$srcdir\nif test \"x${srcroot}\" = \"x.\" ; then\n  srcroot=\"\"\nelse\n  srcroot=\"${srcroot}/\"\nfi\nAC_SUBST([srcroot])\nabs_srcroot=\"`cd \\\"${srcdir}\\\"; pwd`/\"\nAC_SUBST([abs_srcroot])\n\nobjroot=\"\"\nAC_SUBST([objroot])\nabs_objroot=\"`pwd`/\"\nAC_SUBST([abs_objroot])\n\ndnl Munge install path variables.\nif test \"x$prefix\" = \"xNONE\" ; then\n  prefix=\"/usr/local\"\nfi\nif test \"x$exec_prefix\" = \"xNONE\" ; then\n  exec_prefix=$prefix\nfi\nPREFIX=$prefix\nAC_SUBST([PREFIX])\nBINDIR=`eval echo $bindir`\nBINDIR=`eval echo $BINDIR`\nAC_SUBST([BINDIR])\nINCLUDEDIR=`eval echo $includedir`\nINCLUDEDIR=`eval echo $INCLUDEDIR`\nAC_SUBST([INCLUDEDIR])\nLIBDIR=`eval echo $libdir`\nLIBDIR=`eval echo $LIBDIR`\nAC_SUBST([LIBDIR])\nDATADIR=`eval echo $datadir`\nDATADIR=`eval echo $DATADIR`\nAC_SUBST([DATADIR])\nMANDIR=`eval echo $mandir`\nMANDIR=`eval echo $MANDIR`\nAC_SUBST([MANDIR])\n\ndnl Support for building documentation.\nAC_PATH_PROG([XSLTPROC], [xsltproc], [false], [$PATH])\nif test -d \"/usr/share/xml/docbook/stylesheet/docbook-xsl\" ; then\n  DEFAULT_XSLROOT=\"/usr/share/xml/docbook/stylesheet/docbook-xsl\"\nelif test -d \"/usr/share/sgml/docbook/xsl-stylesheets\" ; then\n  DEFAULT_XSLROOT=\"/usr/share/sgml/docbook/xsl-stylesheets\"\nelse\n  dnl Documentation building will fail if this default gets used.\n  DEFAULT_XSLROOT=\"\"\nfi\nAC_ARG_WITH([xslroot],\n  [AS_HELP_STRING([--with-xslroot=<path>], [XSL stylesheet root path])], [\nif test \"x$with_xslroot\" = \"xno\" ; then\n  XSLROOT=\"${DEFAULT_XSLROOT}\"\nelse\n  XSLROOT=\"${with_xslroot}\"\nfi\n],\n  XSLROOT=\"${DEFAULT_XSLROOT}\"\n)\nif test \"x$XSLTPROC\" = \"xfalse\" ; then\n  XSLROOT=\"\"\nfi\nAC_SUBST([XSLROOT])\n\ndnl If CFLAGS isn't defined, set CFLAGS to something reasonable.  Otherwise,\ndnl just prevent autoconf from molesting CFLAGS.\nCFLAGS=$CFLAGS\nAC_PROG_CC\n\nif test \"x$GCC\" != \"xyes\" ; then\n  AC_CACHE_CHECK([whether compiler is MSVC],\n                 [je_cv_msvc],\n                 [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],\n                                                     [\n#ifndef _MSC_VER\n  int fail[-1];\n#endif\n])],\n                               [je_cv_msvc=yes],\n                               [je_cv_msvc=no])])\nfi\n\ndnl check if a cray prgenv wrapper compiler is being used\nje_cv_cray_prgenv_wrapper=\"\"\nif test \"x${PE_ENV}\" != \"x\" ; then\n  case \"${CC}\" in\n    CC|cc)\n\tje_cv_cray_prgenv_wrapper=\"yes\"\n\t;;\n    *)\n       ;;\n  esac\nfi\n\nAC_CACHE_CHECK([whether compiler is cray],\n              [je_cv_cray],\n              [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],\n                                                  [\n#ifndef _CRAYC\n  int fail[-1];\n#endif\n])],\n                            [je_cv_cray=yes],\n                            [je_cv_cray=no])])\n\nif test \"x${je_cv_cray}\" = \"xyes\" ; then\n  AC_CACHE_CHECK([whether cray compiler version is 8.4],\n                [je_cv_cray_84],\n                [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],\n                                                      [\n#if !(_RELEASE_MAJOR == 8 && _RELEASE_MINOR == 4)\n  int fail[-1];\n#endif\n])],\n                              [je_cv_cray_84=yes],\n                              [je_cv_cray_84=no])])\nfi\n\nif test \"x$GCC\" = \"xyes\" ; then\n  JE_CFLAGS_ADD([-std=gnu11])\n  if test \"x$je_cv_cflags_added\" = \"x-std=gnu11\" ; then\n    AC_DEFINE_UNQUOTED([JEMALLOC_HAS_RESTRICT])\n  else\n    JE_CFLAGS_ADD([-std=gnu99])\n    if test \"x$je_cv_cflags_added\" = \"x-std=gnu99\" ; then\n      AC_DEFINE_UNQUOTED([JEMALLOC_HAS_RESTRICT])\n    fi\n  fi\n  JE_CFLAGS_ADD([-Wall])\n  JE_CFLAGS_ADD([-Wextra])\n  JE_CFLAGS_ADD([-Wshorten-64-to-32])\n  JE_CFLAGS_ADD([-Wsign-compare])\n  JE_CFLAGS_ADD([-Wundef])\n  JE_CFLAGS_ADD([-Wno-format-zero-length])\n  JE_CFLAGS_ADD([-pipe])\n  JE_CFLAGS_ADD([-g3])\nelif test \"x$je_cv_msvc\" = \"xyes\" ; then\n  CC=\"$CC -nologo\"\n  JE_CFLAGS_ADD([-Zi])\n  JE_CFLAGS_ADD([-MT])\n  JE_CFLAGS_ADD([-W3])\n  JE_CFLAGS_ADD([-FS])\n  JE_APPEND_VS(CPPFLAGS, -I${srcdir}/include/msvc_compat)\nfi\nif test \"x$je_cv_cray\" = \"xyes\" ; then\n  dnl cray compiler 8.4 has an inlining bug\n  if test \"x$je_cv_cray_84\" = \"xyes\" ; then\n    JE_CFLAGS_ADD([-hipa2])\n    JE_CFLAGS_ADD([-hnognu])\n  fi\n  dnl ignore unreachable code warning\n  JE_CFLAGS_ADD([-hnomessage=128])\n  dnl ignore redefinition of \"malloc\", \"free\", etc warning\n  JE_CFLAGS_ADD([-hnomessage=1357])\nfi\nAC_SUBST([CONFIGURE_CFLAGS])\nAC_SUBST([SPECIFIED_CFLAGS])\nAC_SUBST([EXTRA_CFLAGS])\nAC_PROG_CPP\n\nAC_ARG_ENABLE([cxx],\n  [AS_HELP_STRING([--disable-cxx], [Disable C++ integration])],\nif test \"x$enable_cxx\" = \"xno\" ; then\n  enable_cxx=\"0\"\nelse\n  enable_cxx=\"1\"\nfi\n,\nenable_cxx=\"1\"\n)\nif test \"x$enable_cxx\" = \"x1\" ; then\n  dnl Require at least c++14, which is the first version to support sized\n  dnl deallocation.  C++ support is not compiled otherwise.\n  m4_include([m4/ax_cxx_compile_stdcxx.m4])\n  AX_CXX_COMPILE_STDCXX([14], [noext], [optional])\n  if test \"x${HAVE_CXX14}\" = \"x1\" ; then\n    JE_CXXFLAGS_ADD([-Wall])\n    JE_CXXFLAGS_ADD([-Wextra])\n    JE_CXXFLAGS_ADD([-g3])\n\n    SAVED_LIBS=\"${LIBS}\"\n    JE_APPEND_VS(LIBS, -lstdc++)\n    JE_COMPILABLE([libstdc++ linkage], [\n#include <stdlib.h>\n], [[\n\tint *arr = (int *)malloc(sizeof(int) * 42);\n\tif (arr == NULL)\n\t\treturn 1;\n]], [je_cv_libstdcxx])\n    if test \"x${je_cv_libstdcxx}\" = \"xno\" ; then\n      LIBS=\"${SAVED_LIBS}\"\n    fi\n  else\n    enable_cxx=\"0\"\n  fi\nfi\nAC_SUBST([enable_cxx])\nAC_SUBST([CONFIGURE_CXXFLAGS])\nAC_SUBST([SPECIFIED_CXXFLAGS])\nAC_SUBST([EXTRA_CXXFLAGS])\n\nAC_C_BIGENDIAN([ac_cv_big_endian=1], [ac_cv_big_endian=0])\nif test \"x${ac_cv_big_endian}\" = \"x1\" ; then\n  AC_DEFINE_UNQUOTED([JEMALLOC_BIG_ENDIAN], [ ])\nfi\n\nif test \"x${je_cv_msvc}\" = \"xyes\" -a \"x${ac_cv_header_inttypes_h}\" = \"xno\"; then\n  JE_APPEND_VS(CPPFLAGS, -I${srcdir}/include/msvc_compat/C99)\nfi\n\nif test \"x${je_cv_msvc}\" = \"xyes\" ; then\n  LG_SIZEOF_PTR=LG_SIZEOF_PTR_WIN\n  AC_MSG_RESULT([Using a predefined value for sizeof(void *): 4 for 32-bit, 8 for 64-bit])\nelse\n  AC_CHECK_SIZEOF([void *])\n  if test \"x${ac_cv_sizeof_void_p}\" = \"x8\" ; then\n    LG_SIZEOF_PTR=3\n  elif test \"x${ac_cv_sizeof_void_p}\" = \"x4\" ; then\n    LG_SIZEOF_PTR=2\n  else\n    AC_MSG_ERROR([Unsupported pointer size: ${ac_cv_sizeof_void_p}])\n  fi\nfi\nAC_DEFINE_UNQUOTED([LG_SIZEOF_PTR], [$LG_SIZEOF_PTR])\n\nAC_CHECK_SIZEOF([int])\nif test \"x${ac_cv_sizeof_int}\" = \"x8\" ; then\n  LG_SIZEOF_INT=3\nelif test \"x${ac_cv_sizeof_int}\" = \"x4\" ; then\n  LG_SIZEOF_INT=2\nelse\n  AC_MSG_ERROR([Unsupported int size: ${ac_cv_sizeof_int}])\nfi\nAC_DEFINE_UNQUOTED([LG_SIZEOF_INT], [$LG_SIZEOF_INT])\n\nAC_CHECK_SIZEOF([long])\nif test \"x${ac_cv_sizeof_long}\" = \"x8\" ; then\n  LG_SIZEOF_LONG=3\nelif test \"x${ac_cv_sizeof_long}\" = \"x4\" ; then\n  LG_SIZEOF_LONG=2\nelse\n  AC_MSG_ERROR([Unsupported long size: ${ac_cv_sizeof_long}])\nfi\nAC_DEFINE_UNQUOTED([LG_SIZEOF_LONG], [$LG_SIZEOF_LONG])\n\nAC_CHECK_SIZEOF([long long])\nif test \"x${ac_cv_sizeof_long_long}\" = \"x8\" ; then\n  LG_SIZEOF_LONG_LONG=3\nelif test \"x${ac_cv_sizeof_long_long}\" = \"x4\" ; then\n  LG_SIZEOF_LONG_LONG=2\nelse\n  AC_MSG_ERROR([Unsupported long long size: ${ac_cv_sizeof_long_long}])\nfi\nAC_DEFINE_UNQUOTED([LG_SIZEOF_LONG_LONG], [$LG_SIZEOF_LONG_LONG])\n\nAC_CHECK_SIZEOF([intmax_t])\nif test \"x${ac_cv_sizeof_intmax_t}\" = \"x16\" ; then\n  LG_SIZEOF_INTMAX_T=4\nelif test \"x${ac_cv_sizeof_intmax_t}\" = \"x8\" ; then\n  LG_SIZEOF_INTMAX_T=3\nelif test \"x${ac_cv_sizeof_intmax_t}\" = \"x4\" ; then\n  LG_SIZEOF_INTMAX_T=2\nelse\n  AC_MSG_ERROR([Unsupported intmax_t size: ${ac_cv_sizeof_intmax_t}])\nfi\nAC_DEFINE_UNQUOTED([LG_SIZEOF_INTMAX_T], [$LG_SIZEOF_INTMAX_T])\n\nAC_CANONICAL_HOST\ndnl CPU-specific settings.\nCPU_SPINWAIT=\"\"\ncase \"${host_cpu}\" in\n  i686|x86_64)\n\tHAVE_CPU_SPINWAIT=1\n\tif test \"x${je_cv_msvc}\" = \"xyes\" ; then\n\t    AC_CACHE_VAL([je_cv_pause_msvc],\n\t      [JE_COMPILABLE([pause instruction MSVC], [],\n\t\t\t\t\t[[_mm_pause(); return 0;]],\n\t\t\t\t\t[je_cv_pause_msvc])])\n\t    if test \"x${je_cv_pause_msvc}\" = \"xyes\" ; then\n\t\tCPU_SPINWAIT='_mm_pause()'\n\t    fi\n\telse\n\t    AC_CACHE_VAL([je_cv_pause],\n\t      [JE_COMPILABLE([pause instruction], [],\n\t\t\t\t\t[[__asm__ volatile(\"pause\"); return 0;]],\n\t\t\t\t\t[je_cv_pause])])\n\t    if test \"x${je_cv_pause}\" = \"xyes\" ; then\n\t\tCPU_SPINWAIT='__asm__ volatile(\"pause\")'\n\t    fi\n\tfi\n\t;;\n  *)\n\tHAVE_CPU_SPINWAIT=0\n\t;;\nesac\nAC_DEFINE_UNQUOTED([HAVE_CPU_SPINWAIT], [$HAVE_CPU_SPINWAIT])\nAC_DEFINE_UNQUOTED([CPU_SPINWAIT], [$CPU_SPINWAIT])\n\nAC_ARG_WITH([lg_vaddr],\n  [AS_HELP_STRING([--with-lg-vaddr=<lg-vaddr>], [Number of significant virtual address bits])],\n  [LG_VADDR=\"$with_lg_vaddr\"], [LG_VADDR=\"detect\"])\n\ncase \"${host_cpu}\" in\n  aarch64)\n    if test \"x$LG_VADDR\" = \"xdetect\"; then\n      AC_MSG_CHECKING([number of significant virtual address bits])\n      if test \"x${LG_SIZEOF_PTR}\" = \"x2\" ; then\n        #aarch64 ILP32\n        LG_VADDR=32\n      else\n        #aarch64 LP64\n        LG_VADDR=48\n      fi\n      AC_MSG_RESULT([$LG_VADDR])\n    fi\n    ;;\n  x86_64)\n    if test \"x$LG_VADDR\" = \"xdetect\"; then\n      AC_CACHE_CHECK([number of significant virtual address bits],\n                     [je_cv_lg_vaddr],\n                     AC_RUN_IFELSE([AC_LANG_PROGRAM(\n[[\n#include <stdio.h>\n#ifdef _WIN32\n#include <limits.h>\n#include <intrin.h>\ntypedef unsigned __int32 uint32_t;\n#else\n#include <stdint.h>\n#endif\n]], [[\n\tuint32_t r[[4]];\n\tuint32_t eax_in = 0x80000008U;\n#ifdef _WIN32\n\t__cpuid((int *)r, (int)eax_in);\n#else\n\tasm volatile (\"cpuid\"\n\t    : \"=a\" (r[[0]]), \"=b\" (r[[1]]), \"=c\" (r[[2]]), \"=d\" (r[[3]])\n\t    : \"a\" (eax_in), \"c\" (0)\n\t);\n#endif\n\tuint32_t eax_out = r[[0]];\n\tuint32_t vaddr = ((eax_out & 0x0000ff00U) >> 8);\n\tFILE *f = fopen(\"conftest.out\", \"w\");\n\tif (f == NULL) {\n\t\treturn 1;\n\t}\n\tif (vaddr > (sizeof(void *) << 3)) {\n\t\tvaddr = sizeof(void *) << 3;\n\t}\n\tfprintf(f, \"%u\", vaddr);\n\tfclose(f);\n\treturn 0;\n]])],\n                   [je_cv_lg_vaddr=`cat conftest.out`],\n                   [je_cv_lg_vaddr=error],\n                   [je_cv_lg_vaddr=57]))\n      if test \"x${je_cv_lg_vaddr}\" != \"x\" ; then\n        LG_VADDR=\"${je_cv_lg_vaddr}\"\n      fi\n      if test \"x${LG_VADDR}\" != \"xerror\" ; then\n        AC_DEFINE_UNQUOTED([LG_VADDR], [$LG_VADDR])\n      else\n        AC_MSG_ERROR([cannot determine number of significant virtual address bits])\n      fi\n    fi\n    ;;\n  *)\n    if test \"x$LG_VADDR\" = \"xdetect\"; then\n      AC_MSG_CHECKING([number of significant virtual address bits])\n      if test \"x${LG_SIZEOF_PTR}\" = \"x3\" ; then\n        LG_VADDR=64\n      elif test \"x${LG_SIZEOF_PTR}\" = \"x2\" ; then\n        LG_VADDR=32\n      elif test \"x${LG_SIZEOF_PTR}\" = \"xLG_SIZEOF_PTR_WIN\" ; then\n        LG_VADDR=\"(1U << (LG_SIZEOF_PTR_WIN+3))\"\n      else\n        AC_MSG_ERROR([Unsupported lg(pointer size): ${LG_SIZEOF_PTR}])\n      fi\n      AC_MSG_RESULT([$LG_VADDR])\n    fi\n    ;;\nesac\nAC_DEFINE_UNQUOTED([LG_VADDR], [$LG_VADDR])\n\nLD_PRELOAD_VAR=\"LD_PRELOAD\"\nso=\"so\"\nimportlib=\"${so}\"\no=\"$ac_objext\"\na=\"a\"\nexe=\"$ac_exeext\"\nlibprefix=\"lib\"\nlink_whole_archive=\"0\"\nDSO_LDFLAGS='-shared -Wl,-soname,$(@F)'\nRPATH='-Wl,-rpath,$(1)'\nSOREV=\"${so}.${rev}\"\nPIC_CFLAGS='-fPIC -DPIC'\nCTARGET='-o $@'\nLDTARGET='-o $@'\nTEST_LD_MODE=\nEXTRA_LDFLAGS=\nARFLAGS='crus'\nAROUT=' $@'\nCC_MM=1\n\nif test \"x$je_cv_cray_prgenv_wrapper\" = \"xyes\" ; then\n  TEST_LD_MODE='-dynamic'\nfi\n\nif test \"x${je_cv_cray}\" = \"xyes\" ; then\n  CC_MM=\nfi\n\nAN_MAKEVAR([AR], [AC_PROG_AR])\nAN_PROGRAM([ar], [AC_PROG_AR])\nAC_DEFUN([AC_PROG_AR], [AC_CHECK_TOOL(AR, ar, :)])\nAC_PROG_AR\n\nAN_MAKEVAR([NM], [AC_PROG_NM])\nAN_PROGRAM([nm], [AC_PROG_NM])\nAC_DEFUN([AC_PROG_NM], [AC_CHECK_TOOL(NM, nm, :)])\nAC_PROG_NM\n\nAC_PROG_AWK\n\ndnl ============================================================================\ndnl jemalloc version.\ndnl\n\nAC_ARG_WITH([version],\n  [AS_HELP_STRING([--with-version=<major>.<minor>.<bugfix>-<nrev>-g<gid>],\n   [Version string])],\n  [\n    echo \"${with_version}\" | grep ['^[0-9]\\+\\.[0-9]\\+\\.[0-9]\\+-[0-9]\\+-g[0-9a-f]\\+$'] 2>&1 1>/dev/null\n    if test $? -eq 0 ; then\n      echo \"$with_version\" > \"${objroot}VERSION\"\n    else\n      echo \"${with_version}\" | grep ['^VERSION$'] 2>&1 1>/dev/null\n      if test $? -ne 0 ; then\n        AC_MSG_ERROR([${with_version} does not match <major>.<minor>.<bugfix>-<nrev>-g<gid> or VERSION])\n      fi\n    fi\n  ], [\n    dnl Set VERSION if source directory is inside a git repository.\n    if test \"x`test ! \\\"${srcroot}\\\" && cd \\\"${srcroot}\\\"; git rev-parse --is-inside-work-tree 2>/dev/null`\" = \"xtrue\" ; then\n      dnl Pattern globs aren't powerful enough to match both single- and\n      dnl double-digit version numbers, so iterate over patterns to support up\n      dnl to version 99.99.99 without any accidental matches.\n      for pattern in ['[0-9].[0-9].[0-9]' '[0-9].[0-9].[0-9][0-9]' \\\n                     '[0-9].[0-9][0-9].[0-9]' '[0-9].[0-9][0-9].[0-9][0-9]' \\\n                     '[0-9][0-9].[0-9].[0-9]' '[0-9][0-9].[0-9].[0-9][0-9]' \\\n                     '[0-9][0-9].[0-9][0-9].[0-9]' \\\n                     '[0-9][0-9].[0-9][0-9].[0-9][0-9]']; do\n        (test ! \"${srcroot}\" && cd \"${srcroot}\"; git describe --long --abbrev=40 --match=\"${pattern}\") > \"${objroot}VERSION.tmp\" 2>/dev/null\n        if test $? -eq 0 ; then\n          mv \"${objroot}VERSION.tmp\" \"${objroot}VERSION\"\n          break\n        fi\n      done\n    fi\n    rm -f \"${objroot}VERSION.tmp\"\n  ])\n\nif test ! -e \"${objroot}VERSION\" ; then\n  if test ! -e \"${srcroot}VERSION\" ; then\n    AC_MSG_RESULT(\n      [Missing VERSION file, and unable to generate it; creating bogus VERSION])\n    echo \"0.0.0-0-g0000000000000000000000000000000000000000\" > \"${objroot}VERSION\"\n  else\n    cp ${srcroot}VERSION ${objroot}VERSION\n  fi\nfi\njemalloc_version=`cat \"${objroot}VERSION\"`\njemalloc_version_major=`echo ${jemalloc_version} | tr \".g-\" \" \" | awk '{print [$]1}'`\njemalloc_version_minor=`echo ${jemalloc_version} | tr \".g-\" \" \" | awk '{print [$]2}'`\njemalloc_version_bugfix=`echo ${jemalloc_version} | tr \".g-\" \" \" | awk '{print [$]3}'`\njemalloc_version_nrev=`echo ${jemalloc_version} | tr \".g-\" \" \" | awk '{print [$]4}'`\njemalloc_version_gid=`echo ${jemalloc_version} | tr \".g-\" \" \" | awk '{print [$]5}'`\nAC_SUBST([jemalloc_version])\nAC_SUBST([jemalloc_version_major])\nAC_SUBST([jemalloc_version_minor])\nAC_SUBST([jemalloc_version_bugfix])\nAC_SUBST([jemalloc_version_nrev])\nAC_SUBST([jemalloc_version_gid])\n\ndnl Platform-specific settings.  abi and RPATH can probably be determined\ndnl programmatically, but doing so is error-prone, which makes it generally\ndnl not worth the trouble.\ndnl\ndnl Define cpp macros in CPPFLAGS, rather than doing AC_DEFINE(macro), since the\ndnl definitions need to be seen before any headers are included, which is a pain\ndnl to make happen otherwise.\ndefault_retain=\"0\"\nmaps_coalesce=\"1\"\nDUMP_SYMS=\"${NM} -a\"\nSYM_PREFIX=\"\"\ncase \"${host}\" in\n  *-*-darwin* | *-*-ios*)\n\tabi=\"macho\"\n\tRPATH=\"\"\n\tLD_PRELOAD_VAR=\"DYLD_INSERT_LIBRARIES\"\n\tso=\"dylib\"\n\timportlib=\"${so}\"\n\tforce_tls=\"0\"\n\tDSO_LDFLAGS='-shared -Wl,-install_name,$(LIBDIR)/$(@F)'\n\tSOREV=\"${rev}.${so}\"\n\tsbrk_deprecated=\"1\"\n\tSYM_PREFIX=\"_\"\n\t;;\n  *-*-freebsd*)\n\tabi=\"elf\"\n\tAC_DEFINE([JEMALLOC_SYSCTL_VM_OVERCOMMIT], [ ])\n\tforce_lazy_lock=\"1\"\n\t;;\n  *-*-dragonfly*)\n\tabi=\"elf\"\n\t;;\n  *-*-openbsd*)\n\tabi=\"elf\"\n\tforce_tls=\"0\"\n\t;;\n  *-*-bitrig*)\n\tabi=\"elf\"\n\t;;\n  *-*-linux-android)\n\tdnl syscall(2) and secure_getenv(3) are exposed by _GNU_SOURCE.\n\tJE_APPEND_VS(CPPFLAGS, -D_GNU_SOURCE)\n\tabi=\"elf\"\n\tAC_DEFINE([JEMALLOC_PURGE_MADVISE_DONTNEED_ZEROS], [ ])\n\tAC_DEFINE([JEMALLOC_HAS_ALLOCA_H])\n\tAC_DEFINE([JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY], [ ])\n\tAC_DEFINE([JEMALLOC_THREADED_INIT], [ ])\n\tAC_DEFINE([JEMALLOC_C11_ATOMICS])\n\tforce_tls=\"0\"\n\tif test \"${LG_SIZEOF_PTR}\" = \"3\"; then\n\t  default_retain=\"1\"\n\tfi\n\t;;\n  *-*-linux*)\n\tdnl syscall(2) and secure_getenv(3) are exposed by _GNU_SOURCE.\n\tJE_APPEND_VS(CPPFLAGS, -D_GNU_SOURCE)\n\tabi=\"elf\"\n\tAC_DEFINE([JEMALLOC_PURGE_MADVISE_DONTNEED_ZEROS], [ ])\n\tAC_DEFINE([JEMALLOC_HAS_ALLOCA_H])\n\tAC_DEFINE([JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY], [ ])\n\tAC_DEFINE([JEMALLOC_THREADED_INIT], [ ])\n\tAC_DEFINE([JEMALLOC_USE_CXX_THROW], [ ])\n\tif test \"${LG_SIZEOF_PTR}\" = \"3\"; then\n\t  default_retain=\"1\"\n\tfi\n\t;;\n  *-*-kfreebsd*)\n\tdnl syscall(2) and secure_getenv(3) are exposed by _GNU_SOURCE.\n\tJE_APPEND_VS(CPPFLAGS, -D_GNU_SOURCE)\n\tabi=\"elf\"\n\tAC_DEFINE([JEMALLOC_HAS_ALLOCA_H])\n\tAC_DEFINE([JEMALLOC_SYSCTL_VM_OVERCOMMIT], [ ])\n\tAC_DEFINE([JEMALLOC_THREADED_INIT], [ ])\n\tAC_DEFINE([JEMALLOC_USE_CXX_THROW], [ ])\n\t;;\n  *-*-netbsd*)\n\tAC_MSG_CHECKING([ABI])\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n[[#ifdef __ELF__\n/* ELF */\n#else\n#error aout\n#endif\n]])],\n                          [abi=\"elf\"],\n                          [abi=\"aout\"])\n\tAC_MSG_RESULT([$abi])\n\t;;\n  *-*-solaris2*)\n\tabi=\"elf\"\n\tRPATH='-Wl,-R,$(1)'\n\tdnl Solaris needs this for sigwait().\n\tJE_APPEND_VS(CPPFLAGS, -D_POSIX_PTHREAD_SEMANTICS)\n\tJE_APPEND_VS(LIBS, -lposix4 -lsocket -lnsl)\n\t;;\n  *-ibm-aix*)\n\tif test \"${LG_SIZEOF_PTR}\" = \"3\"; then\n\t  dnl 64bit AIX\n\t  LD_PRELOAD_VAR=\"LDR_PRELOAD64\"\n\telse\n\t  dnl 32bit AIX\n\t  LD_PRELOAD_VAR=\"LDR_PRELOAD\"\n\tfi\n\tabi=\"xcoff\"\n\t;;\n  *-*-mingw* | *-*-cygwin*)\n\tabi=\"pecoff\"\n\tforce_tls=\"0\"\n\tmaps_coalesce=\"0\"\n\tRPATH=\"\"\n\tso=\"dll\"\n\tif test \"x$je_cv_msvc\" = \"xyes\" ; then\n\t  importlib=\"lib\"\n\t  DSO_LDFLAGS=\"-LD\"\n\t  EXTRA_LDFLAGS=\"-link -DEBUG\"\n\t  CTARGET='-Fo$@'\n\t  LDTARGET='-Fe$@'\n\t  AR='lib'\n\t  ARFLAGS='-nologo -out:'\n\t  AROUT='$@'\n\t  CC_MM=\n        else\n\t  importlib=\"${so}\"\n\t  DSO_LDFLAGS=\"-shared\"\n\t  link_whole_archive=\"1\"\n\tfi\n\tcase \"${host}\" in\n\t  *-*-cygwin*)\n\t    DUMP_SYMS=\"dumpbin /SYMBOLS\"\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\ta=\"lib\"\n\tlibprefix=\"\"\n\tSOREV=\"${so}\"\n\tPIC_CFLAGS=\"\"\n\t;;\n  *)\n\tAC_MSG_RESULT([Unsupported operating system: ${host}])\n\tabi=\"elf\"\n\t;;\nesac\n\nJEMALLOC_USABLE_SIZE_CONST=const\nAC_CHECK_HEADERS([malloc.h], [\n  AC_MSG_CHECKING([whether malloc_usable_size definition can use const argument])\n  AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n    [#include <malloc.h>\n     #include <stddef.h>\n    size_t malloc_usable_size(const void *ptr);\n    ],\n    [])],[\n                AC_MSG_RESULT([yes])\n         ],[\n                JEMALLOC_USABLE_SIZE_CONST=\n                AC_MSG_RESULT([no])\n         ])\n])\nAC_DEFINE_UNQUOTED([JEMALLOC_USABLE_SIZE_CONST], [$JEMALLOC_USABLE_SIZE_CONST])\nAC_SUBST([abi])\nAC_SUBST([RPATH])\nAC_SUBST([LD_PRELOAD_VAR])\nAC_SUBST([so])\nAC_SUBST([importlib])\nAC_SUBST([o])\nAC_SUBST([a])\nAC_SUBST([exe])\nAC_SUBST([libprefix])\nAC_SUBST([link_whole_archive])\nAC_SUBST([DSO_LDFLAGS])\nAC_SUBST([EXTRA_LDFLAGS])\nAC_SUBST([SOREV])\nAC_SUBST([PIC_CFLAGS])\nAC_SUBST([CTARGET])\nAC_SUBST([LDTARGET])\nAC_SUBST([TEST_LD_MODE])\nAC_SUBST([MKLIB])\nAC_SUBST([ARFLAGS])\nAC_SUBST([AROUT])\nAC_SUBST([DUMP_SYMS])\nAC_SUBST([CC_MM])\n\ndnl Determine whether libm must be linked to use e.g. log(3).\nAC_SEARCH_LIBS([log], [m], , [AC_MSG_ERROR([Missing math functions])])\nif test \"x$ac_cv_search_log\" != \"xnone required\" ; then\n  LM=\"$ac_cv_search_log\"\nelse\n  LM=\nfi\nAC_SUBST(LM)\n\nJE_COMPILABLE([__attribute__ syntax],\n              [static __attribute__((unused)) void foo(void){}],\n              [],\n              [je_cv_attribute])\nif test \"x${je_cv_attribute}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_ATTR], [ ])\n  if test \"x${GCC}\" = \"xyes\" -a \"x${abi}\" = \"xelf\"; then\n    JE_CFLAGS_ADD([-fvisibility=hidden])\n    JE_CXXFLAGS_ADD([-fvisibility=hidden])\n  fi\nfi\ndnl Check for tls_model attribute support (clang 3.0 still lacks support).\nJE_CFLAGS_SAVE()\nJE_CFLAGS_ADD([-Werror])\nJE_CFLAGS_ADD([-herror_on_warning])\nJE_COMPILABLE([tls_model attribute], [],\n              [static __thread int\n               __attribute__((tls_model(\"initial-exec\"), unused)) foo;\n               foo = 0;],\n              [je_cv_tls_model])\nJE_CFLAGS_RESTORE()\ndnl (Setting of JEMALLOC_TLS_MODEL is done later, after we've checked for\ndnl --disable-initial-exec-tls)\n\ndnl Check for alloc_size attribute support.\nJE_CFLAGS_SAVE()\nJE_CFLAGS_ADD([-Werror])\nJE_CFLAGS_ADD([-herror_on_warning])\nJE_COMPILABLE([alloc_size attribute], [#include <stdlib.h>],\n              [void *foo(size_t size) __attribute__((alloc_size(1)));],\n              [je_cv_alloc_size])\nJE_CFLAGS_RESTORE()\nif test \"x${je_cv_alloc_size}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_ATTR_ALLOC_SIZE], [ ])\nfi\ndnl Check for format(gnu_printf, ...) attribute support.\nJE_CFLAGS_SAVE()\nJE_CFLAGS_ADD([-Werror])\nJE_CFLAGS_ADD([-herror_on_warning])\nJE_COMPILABLE([format(gnu_printf, ...) attribute], [#include <stdlib.h>],\n              [void *foo(const char *format, ...) __attribute__((format(gnu_printf, 1, 2)));],\n              [je_cv_format_gnu_printf])\nJE_CFLAGS_RESTORE()\nif test \"x${je_cv_format_gnu_printf}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF], [ ])\nfi\ndnl Check for format(printf, ...) attribute support.\nJE_CFLAGS_SAVE()\nJE_CFLAGS_ADD([-Werror])\nJE_CFLAGS_ADD([-herror_on_warning])\nJE_COMPILABLE([format(printf, ...) attribute], [#include <stdlib.h>],\n              [void *foo(const char *format, ...) __attribute__((format(printf, 1, 2)));],\n              [je_cv_format_printf])\nJE_CFLAGS_RESTORE()\nif test \"x${je_cv_format_printf}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_ATTR_FORMAT_PRINTF], [ ])\nfi\n\ndnl Support optional additions to rpath.\nAC_ARG_WITH([rpath],\n  [AS_HELP_STRING([--with-rpath=<rpath>], [Colon-separated rpath (ELF systems only)])],\nif test \"x$with_rpath\" = \"xno\" ; then\n  RPATH_EXTRA=\nelse\n  RPATH_EXTRA=\"`echo $with_rpath | tr \\\":\\\" \\\" \\\"`\"\nfi,\n  RPATH_EXTRA=\n)\nAC_SUBST([RPATH_EXTRA])\n\ndnl Disable rules that do automatic regeneration of configure output by default.\nAC_ARG_ENABLE([autogen],\n  [AS_HELP_STRING([--enable-autogen], [Automatically regenerate configure output])],\nif test \"x$enable_autogen\" = \"xno\" ; then\n  enable_autogen=\"0\"\nelse\n  enable_autogen=\"1\"\nfi\n,\nenable_autogen=\"0\"\n)\nAC_SUBST([enable_autogen])\n\nAC_PROG_INSTALL\nAC_PROG_RANLIB\nAC_PATH_PROG([LD], [ld], [false], [$PATH])\nAC_PATH_PROG([AUTOCONF], [autoconf], [false], [$PATH])\n\ndnl Enable shared libs\nAC_ARG_ENABLE([shared],\n  [AS_HELP_STRING([--enable-shared], [Build shared libaries])],\nif test \"x$enable_shared\" = \"xno\" ; then\n  enable_shared=\"0\"\nelse\n  enable_shared=\"1\"\nfi\n,\nenable_shared=\"1\"\n)\nAC_SUBST([enable_shared])\n\ndnl Enable static libs\nAC_ARG_ENABLE([static],\n  [AS_HELP_STRING([--enable-static], [Build static libaries])],\nif test \"x$enable_static\" = \"xno\" ; then\n  enable_static=\"0\"\nelse\n  enable_static=\"1\"\nfi\n,\nenable_static=\"1\"\n)\nAC_SUBST([enable_static])\n\nif test \"$enable_shared$enable_static\" = \"00\" ; then\n  AC_MSG_ERROR([Please enable one of shared or static builds])\nfi\n\ndnl Perform no name mangling by default.\nAC_ARG_WITH([mangling],\n  [AS_HELP_STRING([--with-mangling=<map>], [Mangle symbols in <map>])],\n  [mangling_map=\"$with_mangling\"], [mangling_map=\"\"])\n\ndnl Do not prefix public APIs by default.\nAC_ARG_WITH([jemalloc_prefix],\n  [AS_HELP_STRING([--with-jemalloc-prefix=<prefix>], [Prefix to prepend to all public APIs])],\n  [JEMALLOC_PREFIX=\"$with_jemalloc_prefix\"],\n  [if test \"x$abi\" != \"xmacho\" -a \"x$abi\" != \"xpecoff\"; then\n  JEMALLOC_PREFIX=\"\"\nelse\n  JEMALLOC_PREFIX=\"je_\"\nfi]\n)\nif test \"x$JEMALLOC_PREFIX\" = \"x\" ; then\n  AC_DEFINE([JEMALLOC_IS_MALLOC])\nelse\n  JEMALLOC_CPREFIX=`echo ${JEMALLOC_PREFIX} | tr \"a-z\" \"A-Z\"`\n  AC_DEFINE_UNQUOTED([JEMALLOC_PREFIX], [\"$JEMALLOC_PREFIX\"])\n  AC_DEFINE_UNQUOTED([JEMALLOC_CPREFIX], [\"$JEMALLOC_CPREFIX\"])\nfi\nAC_SUBST([JEMALLOC_PREFIX])\nAC_SUBST([JEMALLOC_CPREFIX])\n\nAC_ARG_WITH([export],\n  [AS_HELP_STRING([--without-export], [disable exporting jemalloc public APIs])],\n  [if test \"x$with_export\" = \"xno\"; then\n  AC_DEFINE([JEMALLOC_EXPORT],[])\nfi]\n)\n\npublic_syms=\"aligned_alloc calloc dallocx free mallctl mallctlbymib mallctlnametomib malloc malloc_conf malloc_message malloc_stats_print malloc_usable_size mallocx smallocx_${jemalloc_version_gid} nallocx posix_memalign rallocx realloc sallocx sdallocx xallocx\"\ndnl Check for additional platform-specific public API functions.\nAC_CHECK_FUNC([memalign],\n\t      [AC_DEFINE([JEMALLOC_OVERRIDE_MEMALIGN], [ ])\n\t       public_syms=\"${public_syms} memalign\"])\nAC_CHECK_FUNC([valloc],\n\t      [AC_DEFINE([JEMALLOC_OVERRIDE_VALLOC], [ ])\n\t       public_syms=\"${public_syms} valloc\"])\n\ndnl Check for allocator-related functions that should be wrapped.\nwrap_syms=\nif test \"x${JEMALLOC_PREFIX}\" = \"x\" ; then\n  AC_CHECK_FUNC([__libc_calloc],\n\t\t[AC_DEFINE([JEMALLOC_OVERRIDE___LIBC_CALLOC], [ ])\n\t\t wrap_syms=\"${wrap_syms} __libc_calloc\"])\n  AC_CHECK_FUNC([__libc_free],\n\t\t[AC_DEFINE([JEMALLOC_OVERRIDE___LIBC_FREE], [ ])\n\t\t wrap_syms=\"${wrap_syms} __libc_free\"])\n  AC_CHECK_FUNC([__libc_malloc],\n\t\t[AC_DEFINE([JEMALLOC_OVERRIDE___LIBC_MALLOC], [ ])\n\t\t wrap_syms=\"${wrap_syms} __libc_malloc\"])\n  AC_CHECK_FUNC([__libc_memalign],\n\t\t[AC_DEFINE([JEMALLOC_OVERRIDE___LIBC_MEMALIGN], [ ])\n\t\t wrap_syms=\"${wrap_syms} __libc_memalign\"])\n  AC_CHECK_FUNC([__libc_realloc],\n\t\t[AC_DEFINE([JEMALLOC_OVERRIDE___LIBC_REALLOC], [ ])\n\t\t wrap_syms=\"${wrap_syms} __libc_realloc\"])\n  AC_CHECK_FUNC([__libc_valloc],\n\t\t[AC_DEFINE([JEMALLOC_OVERRIDE___LIBC_VALLOC], [ ])\n\t\t wrap_syms=\"${wrap_syms} __libc_valloc\"])\n  AC_CHECK_FUNC([__posix_memalign],\n\t\t[AC_DEFINE([JEMALLOC_OVERRIDE___POSIX_MEMALIGN], [ ])\n\t\t wrap_syms=\"${wrap_syms} __posix_memalign\"])\nfi\n\ncase \"${host}\" in\n  *-*-mingw* | *-*-cygwin*)\n    wrap_syms=\"${wrap_syms} tls_callback\"\n    ;;\n  *)\n    ;;\nesac\n\ndnl Mangle library-private APIs.\nAC_ARG_WITH([private_namespace],\n  [AS_HELP_STRING([--with-private-namespace=<prefix>], [Prefix to prepend to all library-private APIs])],\n  [JEMALLOC_PRIVATE_NAMESPACE=\"${with_private_namespace}je_\"],\n  [JEMALLOC_PRIVATE_NAMESPACE=\"je_\"]\n)\nAC_DEFINE_UNQUOTED([JEMALLOC_PRIVATE_NAMESPACE], [$JEMALLOC_PRIVATE_NAMESPACE])\nprivate_namespace=\"$JEMALLOC_PRIVATE_NAMESPACE\"\nAC_SUBST([private_namespace])\n\ndnl Do not add suffix to installed files by default.\nAC_ARG_WITH([install_suffix],\n  [AS_HELP_STRING([--with-install-suffix=<suffix>], [Suffix to append to all installed files])],\n  [INSTALL_SUFFIX=\"$with_install_suffix\"],\n  [INSTALL_SUFFIX=]\n)\ninstall_suffix=\"$INSTALL_SUFFIX\"\nAC_SUBST([install_suffix])\n\ndnl Specify default malloc_conf.\nAC_ARG_WITH([malloc_conf],\n  [AS_HELP_STRING([--with-malloc-conf=<malloc_conf>], [config.malloc_conf options string])],\n  [JEMALLOC_CONFIG_MALLOC_CONF=\"$with_malloc_conf\"],\n  [JEMALLOC_CONFIG_MALLOC_CONF=\"\"]\n)\nconfig_malloc_conf=\"$JEMALLOC_CONFIG_MALLOC_CONF\"\nAC_DEFINE_UNQUOTED([JEMALLOC_CONFIG_MALLOC_CONF], [\"$config_malloc_conf\"])\n\ndnl Substitute @je_@ in jemalloc_protos.h.in, primarily to make generation of\ndnl jemalloc_protos_jet.h easy.\nje_=\"je_\"\nAC_SUBST([je_])\n\ncfgoutputs_in=\"Makefile.in\"\ncfgoutputs_in=\"${cfgoutputs_in} jemalloc.pc.in\"\ncfgoutputs_in=\"${cfgoutputs_in} doc/html.xsl.in\"\ncfgoutputs_in=\"${cfgoutputs_in} doc/manpages.xsl.in\"\ncfgoutputs_in=\"${cfgoutputs_in} doc/jemalloc.xml.in\"\ncfgoutputs_in=\"${cfgoutputs_in} include/jemalloc/jemalloc_macros.h.in\"\ncfgoutputs_in=\"${cfgoutputs_in} include/jemalloc/jemalloc_protos.h.in\"\ncfgoutputs_in=\"${cfgoutputs_in} include/jemalloc/jemalloc_typedefs.h.in\"\ncfgoutputs_in=\"${cfgoutputs_in} include/jemalloc/internal/jemalloc_preamble.h.in\"\ncfgoutputs_in=\"${cfgoutputs_in} test/test.sh.in\"\ncfgoutputs_in=\"${cfgoutputs_in} test/include/test/jemalloc_test.h.in\"\n\ncfgoutputs_out=\"Makefile\"\ncfgoutputs_out=\"${cfgoutputs_out} jemalloc.pc\"\ncfgoutputs_out=\"${cfgoutputs_out} doc/html.xsl\"\ncfgoutputs_out=\"${cfgoutputs_out} doc/manpages.xsl\"\ncfgoutputs_out=\"${cfgoutputs_out} doc/jemalloc.xml\"\ncfgoutputs_out=\"${cfgoutputs_out} include/jemalloc/jemalloc_macros.h\"\ncfgoutputs_out=\"${cfgoutputs_out} include/jemalloc/jemalloc_protos.h\"\ncfgoutputs_out=\"${cfgoutputs_out} include/jemalloc/jemalloc_typedefs.h\"\ncfgoutputs_out=\"${cfgoutputs_out} include/jemalloc/internal/jemalloc_preamble.h\"\ncfgoutputs_out=\"${cfgoutputs_out} test/test.sh\"\ncfgoutputs_out=\"${cfgoutputs_out} test/include/test/jemalloc_test.h\"\n\ncfgoutputs_tup=\"Makefile\"\ncfgoutputs_tup=\"${cfgoutputs_tup} jemalloc.pc:jemalloc.pc.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} doc/html.xsl:doc/html.xsl.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} doc/manpages.xsl:doc/manpages.xsl.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} doc/jemalloc.xml:doc/jemalloc.xml.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} include/jemalloc/jemalloc_macros.h:include/jemalloc/jemalloc_macros.h.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} include/jemalloc/jemalloc_protos.h:include/jemalloc/jemalloc_protos.h.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} include/jemalloc/jemalloc_typedefs.h:include/jemalloc/jemalloc_typedefs.h.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} include/jemalloc/internal/jemalloc_preamble.h\"\ncfgoutputs_tup=\"${cfgoutputs_tup} test/test.sh:test/test.sh.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} test/include/test/jemalloc_test.h:test/include/test/jemalloc_test.h.in\"\n\ncfghdrs_in=\"include/jemalloc/jemalloc_defs.h.in\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/jemalloc_internal_defs.h.in\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/private_symbols.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/private_namespace.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/public_namespace.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/public_unnamespace.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/jemalloc_rename.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/jemalloc_mangle.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/jemalloc.sh\"\ncfghdrs_in=\"${cfghdrs_in} test/include/test/jemalloc_test_defs.h.in\"\n\ncfghdrs_out=\"include/jemalloc/jemalloc_defs.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/jemalloc${install_suffix}.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/private_symbols.awk\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/private_symbols_jet.awk\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/public_symbols.txt\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/public_namespace.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/public_unnamespace.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/jemalloc_protos_jet.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/jemalloc_rename.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/jemalloc_mangle.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/jemalloc_mangle_jet.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/jemalloc_internal_defs.h\"\ncfghdrs_out=\"${cfghdrs_out} test/include/test/jemalloc_test_defs.h\"\n\ncfghdrs_tup=\"include/jemalloc/jemalloc_defs.h:include/jemalloc/jemalloc_defs.h.in\"\ncfghdrs_tup=\"${cfghdrs_tup} include/jemalloc/internal/jemalloc_internal_defs.h:include/jemalloc/internal/jemalloc_internal_defs.h.in\"\ncfghdrs_tup=\"${cfghdrs_tup} test/include/test/jemalloc_test_defs.h:test/include/test/jemalloc_test_defs.h.in\"\n\ndnl ============================================================================\ndnl jemalloc build options.\ndnl\n\ndnl Do not compile with debugging by default.\nAC_ARG_ENABLE([debug],\n  [AS_HELP_STRING([--enable-debug],\n                  [Build debugging code])],\n[if test \"x$enable_debug\" = \"xno\" ; then\n  enable_debug=\"0\"\nelse\n  enable_debug=\"1\"\nfi\n],\n[enable_debug=\"0\"]\n)\nif test \"x$enable_debug\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_DEBUG], [ ])\nfi\nif test \"x$enable_debug\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_DEBUG], [ ])\nfi\nAC_SUBST([enable_debug])\n\ndnl Only optimize if not debugging.\nif test \"x$enable_debug\" = \"x0\" ; then\n  if test \"x$GCC\" = \"xyes\" ; then\n    JE_CFLAGS_ADD([-O3])\n    JE_CXXFLAGS_ADD([-O3])\n    JE_CFLAGS_ADD([-funroll-loops])\n  elif test \"x$je_cv_msvc\" = \"xyes\" ; then\n    JE_CFLAGS_ADD([-O2])\n    JE_CXXFLAGS_ADD([-O2])\n  else\n    JE_CFLAGS_ADD([-O])\n    JE_CXXFLAGS_ADD([-O])\n  fi\nfi\n\ndnl Enable statistics calculation by default.\nAC_ARG_ENABLE([stats],\n  [AS_HELP_STRING([--disable-stats],\n                  [Disable statistics calculation/reporting])],\n[if test \"x$enable_stats\" = \"xno\" ; then\n  enable_stats=\"0\"\nelse\n  enable_stats=\"1\"\nfi\n],\n[enable_stats=\"1\"]\n)\nif test \"x$enable_stats\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_STATS], [ ])\nfi\nAC_SUBST([enable_stats])\n\ndnl Do not enable smallocx by default.\nAC_ARG_ENABLE([experimental_smallocx],\n  [AS_HELP_STRING([--enable-experimental-smallocx], [Enable experimental smallocx API])],\n[if test \"x$enable_experimental_smallocx\" = \"xno\" ; then\nenable_experimental_smallocx=\"0\"\nelse\nenable_experimental_smallocx=\"1\"\nfi\n],\n[enable_experimental_smallocx=\"0\"]\n)\nif test \"x$enable_experimental_smallocx\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_EXPERIMENTAL_SMALLOCX_API])\nfi\nAC_SUBST([enable_experimental_smallocx])\n\ndnl Do not enable profiling by default.\nAC_ARG_ENABLE([prof],\n  [AS_HELP_STRING([--enable-prof], [Enable allocation profiling])],\n[if test \"x$enable_prof\" = \"xno\" ; then\n  enable_prof=\"0\"\nelse\n  enable_prof=\"1\"\nfi\n],\n[enable_prof=\"0\"]\n)\nif test \"x$enable_prof\" = \"x1\" ; then\n  backtrace_method=\"\"\nelse\n  backtrace_method=\"N/A\"\nfi\n\nAC_ARG_ENABLE([prof-libunwind],\n  [AS_HELP_STRING([--enable-prof-libunwind], [Use libunwind for backtracing])],\n[if test \"x$enable_prof_libunwind\" = \"xno\" ; then\n  enable_prof_libunwind=\"0\"\nelse\n  enable_prof_libunwind=\"1\"\nfi\n],\n[enable_prof_libunwind=\"0\"]\n)\nAC_ARG_WITH([static_libunwind],\n  [AS_HELP_STRING([--with-static-libunwind=<libunwind.a>],\n  [Path to static libunwind library; use rather than dynamically linking])],\nif test \"x$with_static_libunwind\" = \"xno\" ; then\n  LUNWIND=\"-lunwind\"\nelse\n  if test ! -f \"$with_static_libunwind\" ; then\n    AC_MSG_ERROR([Static libunwind not found: $with_static_libunwind])\n  fi\n  LUNWIND=\"$with_static_libunwind\"\nfi,\n  LUNWIND=\"-lunwind\"\n)\nif test \"x$backtrace_method\" = \"x\" -a \"x$enable_prof_libunwind\" = \"x1\" ; then\n  AC_CHECK_HEADERS([libunwind.h], , [enable_prof_libunwind=\"0\"])\n  if test \"x$LUNWIND\" = \"x-lunwind\" ; then\n    AC_CHECK_LIB([unwind], [unw_backtrace], [JE_APPEND_VS(LIBS, $LUNWIND)],\n                 [enable_prof_libunwind=\"0\"])\n  else\n    JE_APPEND_VS(LIBS, $LUNWIND)\n  fi\n  if test \"x${enable_prof_libunwind}\" = \"x1\" ; then\n    backtrace_method=\"libunwind\"\n    AC_DEFINE([JEMALLOC_PROF_LIBUNWIND], [ ])\n  fi\nfi\n\nAC_ARG_ENABLE([prof-libgcc],\n  [AS_HELP_STRING([--disable-prof-libgcc],\n  [Do not use libgcc for backtracing])],\n[if test \"x$enable_prof_libgcc\" = \"xno\" ; then\n  enable_prof_libgcc=\"0\"\nelse\n  enable_prof_libgcc=\"1\"\nfi\n],\n[enable_prof_libgcc=\"1\"]\n)\nif test \"x$backtrace_method\" = \"x\" -a \"x$enable_prof_libgcc\" = \"x1\" \\\n     -a \"x$GCC\" = \"xyes\" ; then\n  AC_CHECK_HEADERS([unwind.h], , [enable_prof_libgcc=\"0\"])\n  if test \"x${enable_prof_libgcc}\" = \"x1\" ; then\n    AC_CHECK_LIB([gcc], [_Unwind_Backtrace], [JE_APPEND_VS(LIBS, -lgcc)], [enable_prof_libgcc=\"0\"])\n  fi\n  if test \"x${enable_prof_libgcc}\" = \"x1\" ; then\n    backtrace_method=\"libgcc\"\n    AC_DEFINE([JEMALLOC_PROF_LIBGCC], [ ])\n  fi\nelse\n  enable_prof_libgcc=\"0\"\nfi\n\nAC_ARG_ENABLE([prof-gcc],\n  [AS_HELP_STRING([--disable-prof-gcc],\n  [Do not use gcc intrinsics for backtracing])],\n[if test \"x$enable_prof_gcc\" = \"xno\" ; then\n  enable_prof_gcc=\"0\"\nelse\n  enable_prof_gcc=\"1\"\nfi\n],\n[enable_prof_gcc=\"1\"]\n)\nif test \"x$backtrace_method\" = \"x\" -a \"x$enable_prof_gcc\" = \"x1\" \\\n     -a \"x$GCC\" = \"xyes\" ; then\n  JE_CFLAGS_ADD([-fno-omit-frame-pointer])\n  backtrace_method=\"gcc intrinsics\"\n  AC_DEFINE([JEMALLOC_PROF_GCC], [ ])\nelse\n  enable_prof_gcc=\"0\"\nfi\n\nif test \"x$backtrace_method\" = \"x\" ; then\n  backtrace_method=\"none (disabling profiling)\"\n  enable_prof=\"0\"\nfi\nAC_MSG_CHECKING([configured backtracing method])\nAC_MSG_RESULT([$backtrace_method])\nif test \"x$enable_prof\" = \"x1\" ; then\n  dnl Heap profiling uses the log(3) function.\n  JE_APPEND_VS(LIBS, $LM)\n\n  AC_DEFINE([JEMALLOC_PROF], [ ])\nfi\nAC_SUBST([enable_prof])\n\ndnl Indicate whether adjacent virtual memory mappings automatically coalesce\ndnl (and fragment on demand).\nif test \"x${maps_coalesce}\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_MAPS_COALESCE], [ ])\nfi\n\ndnl Indicate whether to retain memory (rather than using munmap()) by default.\nif test \"x$default_retain\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_RETAIN], [ ])\nfi\n\ndnl Enable allocation from DSS if supported by the OS.\nhave_dss=\"1\"\ndnl Check whether the BSD/SUSv1 sbrk() exists.  If not, disable DSS support.\nAC_CHECK_FUNC([sbrk], [have_sbrk=\"1\"], [have_sbrk=\"0\"])\nif test \"x$have_sbrk\" = \"x1\" ; then\n  if test \"x$sbrk_deprecated\" = \"x1\" ; then\n    AC_MSG_RESULT([Disabling dss allocation because sbrk is deprecated])\n    have_dss=\"0\"\n  fi\nelse\n  have_dss=\"0\"\nfi\n\nif test \"x$have_dss\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_DSS], [ ])\nfi\n\ndnl Support the junk/zero filling option by default.\nAC_ARG_ENABLE([fill],\n  [AS_HELP_STRING([--disable-fill], [Disable support for junk/zero filling])],\n[if test \"x$enable_fill\" = \"xno\" ; then\n  enable_fill=\"0\"\nelse\n  enable_fill=\"1\"\nfi\n],\n[enable_fill=\"1\"]\n)\nif test \"x$enable_fill\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_FILL], [ ])\nfi\nAC_SUBST([enable_fill])\n\ndnl Disable utrace(2)-based tracing by default.\nAC_ARG_ENABLE([utrace],\n  [AS_HELP_STRING([--enable-utrace], [Enable utrace(2)-based tracing])],\n[if test \"x$enable_utrace\" = \"xno\" ; then\n  enable_utrace=\"0\"\nelse\n  enable_utrace=\"1\"\nfi\n],\n[enable_utrace=\"0\"]\n)\nJE_COMPILABLE([utrace(2)], [\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/time.h>\n#include <sys/uio.h>\n#include <sys/ktrace.h>\n], [\n\tutrace((void *)0, 0);\n], [je_cv_utrace])\nif test \"x${je_cv_utrace}\" = \"xno\" ; then\n  enable_utrace=\"0\"\nfi\nif test \"x$enable_utrace\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_UTRACE], [ ])\nfi\nAC_SUBST([enable_utrace])\n\ndnl Do not support the xmalloc option by default.\nAC_ARG_ENABLE([xmalloc],\n  [AS_HELP_STRING([--enable-xmalloc], [Support xmalloc option])],\n[if test \"x$enable_xmalloc\" = \"xno\" ; then\n  enable_xmalloc=\"0\"\nelse\n  enable_xmalloc=\"1\"\nfi\n],\n[enable_xmalloc=\"0\"]\n)\nif test \"x$enable_xmalloc\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_XMALLOC], [ ])\nfi\nAC_SUBST([enable_xmalloc])\n\ndnl Support cache-oblivious allocation alignment by default.\nAC_ARG_ENABLE([cache-oblivious],\n  [AS_HELP_STRING([--disable-cache-oblivious],\n                  [Disable support for cache-oblivious allocation alignment])],\n[if test \"x$enable_cache_oblivious\" = \"xno\" ; then\n  enable_cache_oblivious=\"0\"\nelse\n  enable_cache_oblivious=\"1\"\nfi\n],\n[enable_cache_oblivious=\"1\"]\n)\nif test \"x$enable_cache_oblivious\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_CACHE_OBLIVIOUS], [ ])\nfi\nAC_SUBST([enable_cache_oblivious])\n\ndnl Do not log by default.\nAC_ARG_ENABLE([log],\n  [AS_HELP_STRING([--enable-log], [Support debug logging])],\n[if test \"x$enable_log\" = \"xno\" ; then\n  enable_log=\"0\"\nelse\n  enable_log=\"1\"\nfi\n],\n[enable_log=\"0\"]\n)\nif test \"x$enable_log\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_LOG], [ ])\nfi\nAC_SUBST([enable_log])\n\ndnl Do not use readlinkat by default\nAC_ARG_ENABLE([readlinkat],\n  [AS_HELP_STRING([--enable-readlinkat], [Use readlinkat over readlink])],\n[if test \"x$enable_readlinkat\" = \"xno\" ; then\n  enable_readlinkat=\"0\"\nelse\n  enable_readlinkat=\"1\"\nfi\n],\n[enable_readlinkat=\"0\"]\n)\nif test \"x$enable_readlinkat\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_READLINKAT], [ ])\nfi\nAC_SUBST([enable_readlinkat])\n\ndnl Avoid the extra size checking by default\nAC_ARG_ENABLE([extra-size-check],\n  [AS_HELP_STRING([--enable-extra-size-check],\n  [Perform additonal size related sanity checks])],\n[if test \"x$enable_extra_size_check\" = \"xno\" ; then\n  enable_extra_size_check=\"0\"\nelse\n  enable_extra_size_check=\"1\"\nfi\n],\n[enable_extra_size_check=\"0\"]\n)\nif test \"x$enable_extra_size_check\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_EXTRA_SIZE_CHECK], [ ])\nfi\nAC_SUBST([enable_extra_size_check])\n\nJE_COMPILABLE([a program using __builtin_unreachable], [\nvoid foo (void) {\n  __builtin_unreachable();\n}\n], [\n\t{\n\t\tfoo();\n\t}\n], [je_cv_gcc_builtin_unreachable])\nif test \"x${je_cv_gcc_builtin_unreachable}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_INTERNAL_UNREACHABLE], [__builtin_unreachable])\nelse\n  AC_DEFINE([JEMALLOC_INTERNAL_UNREACHABLE], [abort])\nfi\n\ndnl ============================================================================\ndnl Check for  __builtin_ffsl(), then ffsl(3), and fail if neither are found.\ndnl One of those two functions should (theoretically) exist on all platforms\ndnl that jemalloc currently has a chance of functioning on without modification.\ndnl We additionally assume ffs[ll]() or __builtin_ffs[ll]() are defined if\ndnl ffsl() or __builtin_ffsl() are defined, respectively.\nJE_COMPILABLE([a program using __builtin_ffsl], [\n#include <stdio.h>\n#include <strings.h>\n#include <string.h>\n], [\n\t{\n\t\tint rv = __builtin_ffsl(0x08);\n\t\tprintf(\"%d\\n\", rv);\n\t}\n], [je_cv_gcc_builtin_ffsl])\nif test \"x${je_cv_gcc_builtin_ffsl}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_INTERNAL_FFSLL], [__builtin_ffsll])\n  AC_DEFINE([JEMALLOC_INTERNAL_FFSL], [__builtin_ffsl])\n  AC_DEFINE([JEMALLOC_INTERNAL_FFS], [__builtin_ffs])\nelse\n  JE_COMPILABLE([a program using ffsl], [\n  #include <stdio.h>\n  #include <strings.h>\n  #include <string.h>\n  ], [\n\t{\n\t\tint rv = ffsl(0x08);\n\t\tprintf(\"%d\\n\", rv);\n\t}\n  ], [je_cv_function_ffsl])\n  if test \"x${je_cv_function_ffsl}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_INTERNAL_FFSLL], [ffsll])\n    AC_DEFINE([JEMALLOC_INTERNAL_FFSL], [ffsl])\n    AC_DEFINE([JEMALLOC_INTERNAL_FFS], [ffs])\n  else\n    AC_MSG_ERROR([Cannot build without ffsl(3) or __builtin_ffsl()])\n  fi\nfi\n\nJE_COMPILABLE([a program using __builtin_popcountl], [\n#include <stdio.h>\n#include <strings.h>\n#include <string.h>\n], [\n\t{\n\t\tint rv = __builtin_popcountl(0x08);\n\t\tprintf(\"%d\\n\", rv);\n\t}\n], [je_cv_gcc_builtin_popcountl])\nif test \"x${je_cv_gcc_builtin_popcountl}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_INTERNAL_POPCOUNT], [__builtin_popcount])\n  AC_DEFINE([JEMALLOC_INTERNAL_POPCOUNTL], [__builtin_popcountl])\nfi\n\nAC_ARG_WITH([lg_quantum],\n  [AS_HELP_STRING([--with-lg-quantum=<lg-quantum>],\n   [Base 2 log of minimum allocation alignment])],\n  [LG_QUANTA=\"$with_lg_quantum\"],\n  [LG_QUANTA=\"3 4\"])\nif test \"x$with_lg_quantum\" != \"x\" ; then\n  AC_DEFINE_UNQUOTED([LG_QUANTUM], [$with_lg_quantum])\nfi\n\nAC_ARG_WITH([lg_page],\n  [AS_HELP_STRING([--with-lg-page=<lg-page>], [Base 2 log of system page size])],\n  [LG_PAGE=\"$with_lg_page\"], [LG_PAGE=\"detect\"])\nif test \"x$LG_PAGE\" = \"xdetect\"; then\n  AC_CACHE_CHECK([LG_PAGE],\n               [je_cv_lg_page],\n               AC_RUN_IFELSE([AC_LANG_PROGRAM(\n[[\n#include <strings.h>\n#ifdef _WIN32\n#include <windows.h>\n#else\n#include <unistd.h>\n#endif\n#include <stdio.h>\n]],\n[[\n    int result;\n    FILE *f;\n\n#ifdef _WIN32\n    SYSTEM_INFO si;\n    GetSystemInfo(&si);\n    result = si.dwPageSize;\n#else\n    result = sysconf(_SC_PAGESIZE);\n#endif\n    if (result == -1) {\n\treturn 1;\n    }\n    result = JEMALLOC_INTERNAL_FFSL(result) - 1;\n\n    f = fopen(\"conftest.out\", \"w\");\n    if (f == NULL) {\n\treturn 1;\n    }\n    fprintf(f, \"%d\", result);\n    fclose(f);\n\n    return 0;\n]])],\n                             [je_cv_lg_page=`cat conftest.out`],\n                             [je_cv_lg_page=undefined],\n                             [je_cv_lg_page=12]))\nfi\nif test \"x${je_cv_lg_page}\" != \"x\" ; then\n  LG_PAGE=\"${je_cv_lg_page}\"\nfi\nif test \"x${LG_PAGE}\" != \"xundefined\" ; then\n   AC_DEFINE_UNQUOTED([LG_PAGE], [$LG_PAGE])\nelse\n   AC_MSG_ERROR([cannot determine value for LG_PAGE])\nfi\n\nAC_ARG_WITH([lg_hugepage],\n  [AS_HELP_STRING([--with-lg-hugepage=<lg-hugepage>],\n   [Base 2 log of system huge page size])],\n  [je_cv_lg_hugepage=\"${with_lg_hugepage}\"],\n  [je_cv_lg_hugepage=\"\"])\nif test \"x${je_cv_lg_hugepage}\" = \"x\" ; then\n  dnl Look in /proc/meminfo (Linux-specific) for information on the default huge\n  dnl page size, if any.  The relevant line looks like:\n  dnl\n  dnl   Hugepagesize:       2048 kB\n  if test -e \"/proc/meminfo\" ; then\n    hpsk=[`cat /proc/meminfo 2>/dev/null | \\\n          grep -e '^Hugepagesize:[[:space:]]\\+[0-9]\\+[[:space:]]kB$' | \\\n          awk '{print $2}'`]\n    if test \"x${hpsk}\" != \"x\" ; then\n      je_cv_lg_hugepage=10\n      while test \"${hpsk}\" -gt 1 ; do\n        hpsk=\"$((hpsk / 2))\"\n        je_cv_lg_hugepage=\"$((je_cv_lg_hugepage + 1))\"\n      done\n    fi\n  fi\n\n  dnl Set default if unable to automatically configure.\n  if test \"x${je_cv_lg_hugepage}\" = \"x\" ; then\n    je_cv_lg_hugepage=21\n  fi\nfi\nif test \"x${LG_PAGE}\" != \"xundefined\" -a \\\n        \"${je_cv_lg_hugepage}\" -lt \"${LG_PAGE}\" ; then\n  AC_MSG_ERROR([Huge page size (2^${je_cv_lg_hugepage}) must be at least page size (2^${LG_PAGE})])\nfi\nAC_DEFINE_UNQUOTED([LG_HUGEPAGE], [${je_cv_lg_hugepage}])\n\ndnl ============================================================================\ndnl Enable libdl by default.\nAC_ARG_ENABLE([libdl],\n  [AS_HELP_STRING([--disable-libdl],\n  [Do not use libdl])],\n[if test \"x$enable_libdl\" = \"xno\" ; then\n  enable_libdl=\"0\"\nelse\n  enable_libdl=\"1\"\nfi\n],\n[enable_libdl=\"1\"]\n)\nAC_SUBST([libdl])\n\ndnl ============================================================================\ndnl Configure pthreads.\n\nif test \"x$abi\" != \"xpecoff\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_PTHREAD], [ ])\n  AC_CHECK_HEADERS([pthread.h], , [AC_MSG_ERROR([pthread.h is missing])])\n  dnl Some systems may embed pthreads functionality in libc; check for libpthread\n  dnl first, but try libc too before failing.\n  AC_CHECK_LIB([pthread], [pthread_create], [JE_APPEND_VS(LIBS, -pthread)],\n               [AC_SEARCH_LIBS([pthread_create], , ,\n                               AC_MSG_ERROR([libpthread is missing]))])\n  wrap_syms=\"${wrap_syms} pthread_create\"\n  have_pthread=\"1\"\n\ndnl Check if we have dlsym support.\n  if test \"x$enable_libdl\" = \"x1\" ; then\n    have_dlsym=\"1\"\n    AC_CHECK_HEADERS([dlfcn.h],\n      AC_CHECK_FUNC([dlsym], [],\n        [AC_CHECK_LIB([dl], [dlsym], [LIBS=\"$LIBS -ldl\"], [have_dlsym=\"0\"])]),\n      [have_dlsym=\"0\"])\n    if test \"x$have_dlsym\" = \"x1\" ; then\n      AC_DEFINE([JEMALLOC_HAVE_DLSYM], [ ])\n    fi\n  else\n    have_dlsym=\"0\"\n  fi\n\n  JE_COMPILABLE([pthread_atfork(3)], [\n#include <pthread.h>\n], [\n  pthread_atfork((void *)0, (void *)0, (void *)0);\n], [je_cv_pthread_atfork])\n  if test \"x${je_cv_pthread_atfork}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_HAVE_PTHREAD_ATFORK], [ ])\n  fi\n  dnl Check if pthread_setname_np is available with the expected API.\n  JE_COMPILABLE([pthread_setname_np(3)], [\n#include <pthread.h>\n], [\n  pthread_setname_np(pthread_self(), \"setname_test\");\n], [je_cv_pthread_setname_np])\n  if test \"x${je_cv_pthread_setname_np}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_HAVE_PTHREAD_SETNAME_NP], [ ])\n  fi\nfi\n\nJE_APPEND_VS(CPPFLAGS, -D_REENTRANT)\n\ndnl Check whether clock_gettime(2) is in libc or librt.\nAC_SEARCH_LIBS([clock_gettime], [rt])\n\ndnl Cray wrapper compiler often adds `-lrt` when using `-static`. Check with\ndnl `-dynamic` as well in case a user tries to dynamically link in jemalloc\nif test \"x$je_cv_cray_prgenv_wrapper\" = \"xyes\" ; then\n  if test \"$ac_cv_search_clock_gettime\" != \"-lrt\"; then\n    JE_CFLAGS_SAVE()\n\n    unset ac_cv_search_clock_gettime\n    JE_CFLAGS_ADD([-dynamic])\n    AC_SEARCH_LIBS([clock_gettime], [rt])\n\n    JE_CFLAGS_RESTORE()\n  fi\nfi\n\ndnl check for CLOCK_MONOTONIC_COARSE (Linux-specific).\nJE_COMPILABLE([clock_gettime(CLOCK_MONOTONIC_COARSE, ...)], [\n#include <time.h>\n], [\n\tstruct timespec ts;\n\n\tclock_gettime(CLOCK_MONOTONIC_COARSE, &ts);\n], [je_cv_clock_monotonic_coarse])\nif test \"x${je_cv_clock_monotonic_coarse}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE])\nfi\n\ndnl check for CLOCK_MONOTONIC.\nJE_COMPILABLE([clock_gettime(CLOCK_MONOTONIC, ...)], [\n#include <unistd.h>\n#include <time.h>\n], [\n\tstruct timespec ts;\n\n\tclock_gettime(CLOCK_MONOTONIC, &ts);\n#if !defined(_POSIX_MONOTONIC_CLOCK) || _POSIX_MONOTONIC_CLOCK < 0\n#  error _POSIX_MONOTONIC_CLOCK missing/invalid\n#endif\n], [je_cv_clock_monotonic])\nif test \"x${je_cv_clock_monotonic}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_CLOCK_MONOTONIC])\nfi\n\ndnl Check for mach_absolute_time().\nJE_COMPILABLE([mach_absolute_time()], [\n#include <mach/mach_time.h>\n], [\n\tmach_absolute_time();\n], [je_cv_mach_absolute_time])\nif test \"x${je_cv_mach_absolute_time}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_MACH_ABSOLUTE_TIME])\nfi\n\ndnl Use syscall(2) (if available) by default.\nAC_ARG_ENABLE([syscall],\n  [AS_HELP_STRING([--disable-syscall], [Disable use of syscall(2)])],\n[if test \"x$enable_syscall\" = \"xno\" ; then\n  enable_syscall=\"0\"\nelse\n  enable_syscall=\"1\"\nfi\n],\n[enable_syscall=\"1\"]\n)\nif test \"x$enable_syscall\" = \"x1\" ; then\n  dnl Check if syscall(2) is usable.  Treat warnings as errors, so that e.g. OS\n  dnl X 10.12's deprecation warning prevents use.\n  JE_CFLAGS_SAVE()\n  JE_CFLAGS_ADD([-Werror])\n  JE_COMPILABLE([syscall(2)], [\n#include <sys/syscall.h>\n#include <unistd.h>\n], [\n\tsyscall(SYS_write, 2, \"hello\", 5);\n],\n                [je_cv_syscall])\n  JE_CFLAGS_RESTORE()\n  if test \"x$je_cv_syscall\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_USE_SYSCALL], [ ])\n  fi\nfi\n\ndnl Check if the GNU-specific secure_getenv function exists.\nAC_CHECK_FUNC([secure_getenv],\n              [have_secure_getenv=\"1\"],\n              [have_secure_getenv=\"0\"]\n             )\nif test \"x$have_secure_getenv\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_SECURE_GETENV], [ ])\nfi\n\ndnl Check if the GNU-specific sched_getcpu function exists.\nAC_CHECK_FUNC([sched_getcpu],\n              [have_sched_getcpu=\"1\"],\n              [have_sched_getcpu=\"0\"]\n             )\nif test \"x$have_sched_getcpu\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_SCHED_GETCPU], [ ])\nfi\n\ndnl Check if the GNU-specific sched_setaffinity function exists.\nAC_CHECK_FUNC([sched_setaffinity],\n              [have_sched_setaffinity=\"1\"],\n              [have_sched_setaffinity=\"0\"]\n             )\nif test \"x$have_sched_setaffinity\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_SCHED_SETAFFINITY], [ ])\nfi\n\ndnl Check if the Solaris/BSD issetugid function exists.\nAC_CHECK_FUNC([issetugid],\n              [have_issetugid=\"1\"],\n              [have_issetugid=\"0\"]\n             )\nif test \"x$have_issetugid\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_ISSETUGID], [ ])\nfi\n\ndnl Check whether the BSD-specific _malloc_thread_cleanup() exists.  If so, use\ndnl it rather than pthreads TSD cleanup functions to support cleanup during\ndnl thread exit, in order to avoid pthreads library recursion during\ndnl bootstrapping.\nAC_CHECK_FUNC([_malloc_thread_cleanup],\n              [have__malloc_thread_cleanup=\"1\"],\n              [have__malloc_thread_cleanup=\"0\"]\n             )\nif test \"x$have__malloc_thread_cleanup\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_MALLOC_THREAD_CLEANUP], [ ])\n  wrap_syms=\"${wrap_syms} _malloc_thread_cleanup\"\n  force_tls=\"1\"\nfi\n\ndnl Check whether the BSD-specific _pthread_mutex_init_calloc_cb() exists.  If\ndnl so, mutex initialization causes allocation, and we need to implement this\ndnl callback function in order to prevent recursive allocation.\nAC_CHECK_FUNC([_pthread_mutex_init_calloc_cb],\n              [have__pthread_mutex_init_calloc_cb=\"1\"],\n              [have__pthread_mutex_init_calloc_cb=\"0\"]\n             )\nif test \"x$have__pthread_mutex_init_calloc_cb\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_MUTEX_INIT_CB])\n  wrap_syms=\"${wrap_syms} _malloc_prefork _malloc_postfork\"\nfi\n\ndnl Disable lazy locking by default.\nAC_ARG_ENABLE([lazy_lock],\n  [AS_HELP_STRING([--enable-lazy-lock],\n  [Enable lazy locking (only lock when multi-threaded)])],\n[if test \"x$enable_lazy_lock\" = \"xno\" ; then\n  enable_lazy_lock=\"0\"\nelse\n  enable_lazy_lock=\"1\"\nfi\n],\n[enable_lazy_lock=\"\"]\n)\nif test \"x${enable_lazy_lock}\" = \"x\" ; then\n  if test \"x${force_lazy_lock}\" = \"x1\" ; then\n    AC_MSG_RESULT([Forcing lazy-lock to avoid allocator/threading bootstrap issues])\n    enable_lazy_lock=\"1\"\n  else\n    enable_lazy_lock=\"0\"\n  fi\nfi\nif test \"x${enable_lazy_lock}\" = \"x1\" -a \"x${abi}\" = \"xpecoff\" ; then\n  AC_MSG_RESULT([Forcing no lazy-lock because thread creation monitoring is unimplemented])\n  enable_lazy_lock=\"0\"\nfi\nif test \"x$enable_lazy_lock\" = \"x1\" ; then\n  if test \"x$have_dlsym\" = \"x1\" ; then\n    AC_DEFINE([JEMALLOC_LAZY_LOCK], [ ])\n  else\n    AC_MSG_ERROR([Missing dlsym support: lazy-lock cannot be enabled.])\n  fi\nfi\nAC_SUBST([enable_lazy_lock])\n\ndnl Automatically configure TLS.\nif test \"x${force_tls}\" = \"x1\" ; then\n  enable_tls=\"1\"\nelif test \"x${force_tls}\" = \"x0\" ; then\n  enable_tls=\"0\"\nelse\n  enable_tls=\"1\"\nfi\nif test \"x${enable_tls}\" = \"x1\" ; then\nAC_MSG_CHECKING([for TLS])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n[[\n    __thread int x;\n]], [[\n    x = 42;\n\n    return 0;\n]])],\n              AC_MSG_RESULT([yes]),\n              AC_MSG_RESULT([no])\n              enable_tls=\"0\")\nelse\n  enable_tls=\"0\"\nfi\nAC_SUBST([enable_tls])\nif test \"x${enable_tls}\" = \"x1\" ; then\n  AC_DEFINE_UNQUOTED([JEMALLOC_TLS], [ ])\nfi\n\ndnl ============================================================================\ndnl Check for C11 atomics.\n\nJE_COMPILABLE([C11 atomics], [\n#include <stdint.h>\n#if (__STDC_VERSION__ >= 201112L) && !defined(__STDC_NO_ATOMICS__)\n#include <stdatomic.h>\n#else\n#error Atomics not available\n#endif\n], [\n    uint64_t *p = (uint64_t *)0;\n    uint64_t x = 1;\n    volatile atomic_uint_least64_t *a = (volatile atomic_uint_least64_t *)p;\n    uint64_t r = atomic_fetch_add(a, x) + x;\n    return r == 0;\n], [je_cv_c11_atomics])\nif test \"x${je_cv_c11_atomics}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_C11_ATOMICS])\nfi\n\ndnl ============================================================================\ndnl Check for GCC-style __atomic atomics.\n\nJE_COMPILABLE([GCC __atomic atomics], [\n], [\n    int x = 0;\n    int val = 1;\n    int y = __atomic_fetch_add(&x, val, __ATOMIC_RELAXED);\n    int after_add = x;\n    return after_add == 1;\n], [je_cv_gcc_atomic_atomics])\nif test \"x${je_cv_gcc_atomic_atomics}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_GCC_ATOMIC_ATOMICS])\n\n  dnl check for 8-bit atomic support\n  JE_COMPILABLE([GCC 8-bit __atomic atomics], [\n  ], [\n      unsigned char x = 0;\n      int val = 1;\n      int y = __atomic_fetch_add(&x, val, __ATOMIC_RELAXED);\n      int after_add = (int)x;\n      return after_add == 1;\n  ], [je_cv_gcc_u8_atomic_atomics])\n  if test \"x${je_cv_gcc_u8_atomic_atomics}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_GCC_U8_ATOMIC_ATOMICS])\n  fi\nfi\n\ndnl ============================================================================\ndnl Check for GCC-style __sync atomics.\n\nJE_COMPILABLE([GCC __sync atomics], [\n], [\n    int x = 0;\n    int before_add = __sync_fetch_and_add(&x, 1);\n    int after_add = x;\n    return (before_add == 0) && (after_add == 1);\n], [je_cv_gcc_sync_atomics])\nif test \"x${je_cv_gcc_sync_atomics}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_GCC_SYNC_ATOMICS])\n\n  dnl check for 8-bit atomic support\n  JE_COMPILABLE([GCC 8-bit __sync atomics], [\n  ], [\n      unsigned char x = 0;\n      int before_add = __sync_fetch_and_add(&x, 1);\n      int after_add = (int)x;\n      return (before_add == 0) && (after_add == 1);\n  ], [je_cv_gcc_u8_sync_atomics])\n  if test \"x${je_cv_gcc_u8_sync_atomics}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_GCC_U8_SYNC_ATOMICS])\n  fi\nfi\n\ndnl ============================================================================\ndnl Check for atomic(3) operations as provided on Darwin.\ndnl We need this not for the atomic operations (which are provided above), but\ndnl rather for the OS_unfair_lock type it exposes.\n\nJE_COMPILABLE([Darwin OSAtomic*()], [\n#include <libkern/OSAtomic.h>\n#include <inttypes.h>\n], [\n\t{\n\t\tint32_t x32 = 0;\n\t\tvolatile int32_t *x32p = &x32;\n\t\tOSAtomicAdd32(1, x32p);\n\t}\n\t{\n\t\tint64_t x64 = 0;\n\t\tvolatile int64_t *x64p = &x64;\n\t\tOSAtomicAdd64(1, x64p);\n\t}\n], [je_cv_osatomic])\nif test \"x${je_cv_osatomic}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_OSATOMIC], [ ])\nfi\n\ndnl ============================================================================\ndnl Check for madvise(2).\n\nJE_COMPILABLE([madvise(2)], [\n#include <sys/mman.h>\n], [\n\tmadvise((void *)0, 0, 0);\n], [je_cv_madvise])\nif test \"x${je_cv_madvise}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_MADVISE], [ ])\n\n  dnl Check for madvise(..., MADV_FREE).\n  JE_COMPILABLE([madvise(..., MADV_FREE)], [\n#include <sys/mman.h>\n], [\n\tmadvise((void *)0, 0, MADV_FREE);\n], [je_cv_madv_free])\n  if test \"x${je_cv_madv_free}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])\n  elif test \"x${je_cv_madvise}\" = \"xyes\" ; then\n    case \"${host_cpu}\" in i686|x86_64)\n        case \"${host}\" in *-*-linux*)\n            AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])\n            AC_DEFINE([JEMALLOC_DEFINE_MADVISE_FREE], [ ])\n\t    ;;\n        esac\n        ;;\n    esac\n  fi\n\n  dnl Check for madvise(..., MADV_DONTNEED).\n  JE_COMPILABLE([madvise(..., MADV_DONTNEED)], [\n#include <sys/mman.h>\n], [\n\tmadvise((void *)0, 0, MADV_DONTNEED);\n], [je_cv_madv_dontneed])\n  if test \"x${je_cv_madv_dontneed}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_PURGE_MADVISE_DONTNEED], [ ])\n  fi\n\n  dnl Check for madvise(..., MADV_DO[NT]DUMP).\n  JE_COMPILABLE([madvise(..., MADV_DO[[NT]]DUMP)], [\n#include <sys/mman.h>\n], [\n\tmadvise((void *)0, 0, MADV_DONTDUMP);\n\tmadvise((void *)0, 0, MADV_DODUMP);\n], [je_cv_madv_dontdump])\n  if test \"x${je_cv_madv_dontdump}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_MADVISE_DONTDUMP], [ ])\n  fi\n\n  dnl Check for madvise(..., MADV_[NO]HUGEPAGE).\n  JE_COMPILABLE([madvise(..., MADV_[[NO]]HUGEPAGE)], [\n#include <sys/mman.h>\n], [\n\tmadvise((void *)0, 0, MADV_HUGEPAGE);\n\tmadvise((void *)0, 0, MADV_NOHUGEPAGE);\n], [je_cv_thp])\ncase \"${host_cpu}\" in\n  arm*)\n    ;;\n  *)\n  if test \"x${je_cv_thp}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_HAVE_MADVISE_HUGE], [ ])\n  fi\n  ;;\nesac\nfi\n\ndnl ============================================================================\ndnl Check for __builtin_clz() and __builtin_clzl().\n\nAC_CACHE_CHECK([for __builtin_clz],\n               [je_cv_builtin_clz],\n               [AC_LINK_IFELSE([AC_LANG_PROGRAM([],\n                                                [\n                                                {\n                                                        unsigned x = 0;\n                                                        int y = __builtin_clz(x);\n                                                }\n                                                {\n                                                        unsigned long x = 0;\n                                                        int y = __builtin_clzl(x);\n                                                }\n                                                ])],\n                               [je_cv_builtin_clz=yes],\n                               [je_cv_builtin_clz=no])])\n\nif test \"x${je_cv_builtin_clz}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_BUILTIN_CLZ], [ ])\nfi\n\ndnl ============================================================================\ndnl Check for os_unfair_lock operations as provided on Darwin.\n\nJE_COMPILABLE([Darwin os_unfair_lock_*()], [\n#include <os/lock.h>\n#include <AvailabilityMacros.h>\n], [\n\t#if MAC_OS_X_VERSION_MIN_REQUIRED < 101200\n\t#error \"os_unfair_lock is not supported\"\n\t#else\n\tos_unfair_lock lock = OS_UNFAIR_LOCK_INIT;\n\tos_unfair_lock_lock(&lock);\n\tos_unfair_lock_unlock(&lock);\n\t#endif\n], [je_cv_os_unfair_lock])\nif test \"x${je_cv_os_unfair_lock}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_OS_UNFAIR_LOCK], [ ])\nfi\n\ndnl ============================================================================\ndnl Darwin-related configuration.\n\nAC_ARG_ENABLE([zone-allocator],\n  [AS_HELP_STRING([--disable-zone-allocator],\n                  [Disable zone allocator for Darwin])],\n[if test \"x$enable_zone_allocator\" = \"xno\" ; then\n  enable_zone_allocator=\"0\"\nelse\n  enable_zone_allocator=\"1\"\nfi\n],\n[if test \"x${abi}\" = \"xmacho\"; then\n  enable_zone_allocator=\"1\"\nfi\n]\n)\nAC_SUBST([enable_zone_allocator])\n\nif test \"x${enable_zone_allocator}\" = \"x1\" ; then\n  if test \"x${abi}\" != \"xmacho\"; then\n    AC_MSG_ERROR([--enable-zone-allocator is only supported on Darwin])\n  fi\n  AC_DEFINE([JEMALLOC_ZONE], [ ])\nfi\n\ndnl ============================================================================\ndnl Use initial-exec TLS by default.\nAC_ARG_ENABLE([initial-exec-tls],\n  [AS_HELP_STRING([--disable-initial-exec-tls],\n                  [Disable the initial-exec tls model])],\n[if test \"x$enable_initial_exec_tls\" = \"xno\" ; then\n  enable_initial_exec_tls=\"0\"\nelse\n  enable_initial_exec_tls=\"1\"\nfi\n],\n[enable_initial_exec_tls=\"1\"]\n)\nAC_SUBST([enable_initial_exec_tls])\n\nif test \"x${je_cv_tls_model}\" = \"xyes\" -a \\\n       \"x${enable_initial_exec_tls}\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_TLS_MODEL],\n            [__attribute__((tls_model(\"initial-exec\")))])\nelse\n  AC_DEFINE([JEMALLOC_TLS_MODEL], [ ])\nfi\n\ndnl ============================================================================\ndnl Enable background threads if possible.\n\nif test \"x${have_pthread}\" = \"x1\" -a \"x${je_cv_os_unfair_lock}\" != \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_BACKGROUND_THREAD])\nfi\n\ndnl ============================================================================\ndnl Check for glibc malloc hooks\n\nJE_COMPILABLE([glibc malloc hook], [\n#include <stddef.h>\n\nextern void (* __free_hook)(void *ptr);\nextern void *(* __malloc_hook)(size_t size);\nextern void *(* __realloc_hook)(void *ptr, size_t size);\n], [\n  void *ptr = 0L;\n  if (__malloc_hook) ptr = __malloc_hook(1);\n  if (__realloc_hook) ptr = __realloc_hook(ptr, 2);\n  if (__free_hook && ptr) __free_hook(ptr);\n], [je_cv_glibc_malloc_hook])\nif test \"x${je_cv_glibc_malloc_hook}\" = \"xyes\" ; then\n  if test \"x${JEMALLOC_PREFIX}\" = \"x\" ; then\n    AC_DEFINE([JEMALLOC_GLIBC_MALLOC_HOOK], [ ])\n    wrap_syms=\"${wrap_syms} __free_hook __malloc_hook __realloc_hook\"\n  fi\nfi\n\nJE_COMPILABLE([glibc memalign hook], [\n#include <stddef.h>\n\nextern void *(* __memalign_hook)(size_t alignment, size_t size);\n], [\n  void *ptr = 0L;\n  if (__memalign_hook) ptr = __memalign_hook(16, 7);\n], [je_cv_glibc_memalign_hook])\nif test \"x${je_cv_glibc_memalign_hook}\" = \"xyes\" ; then\n  if test \"x${JEMALLOC_PREFIX}\" = \"x\" ; then\n    AC_DEFINE([JEMALLOC_GLIBC_MEMALIGN_HOOK], [ ])\n    wrap_syms=\"${wrap_syms} __memalign_hook\"\n  fi\nfi\n\nJE_COMPILABLE([pthreads adaptive mutexes], [\n#include <pthread.h>\n], [\n  pthread_mutexattr_t attr;\n  pthread_mutexattr_init(&attr);\n  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ADAPTIVE_NP);\n  pthread_mutexattr_destroy(&attr);\n], [je_cv_pthread_mutex_adaptive_np])\nif test \"x${je_cv_pthread_mutex_adaptive_np}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP], [ ])\nfi\n\nJE_CFLAGS_SAVE()\nJE_CFLAGS_ADD([-D_GNU_SOURCE])\nJE_CFLAGS_ADD([-Werror])\nJE_CFLAGS_ADD([-herror_on_warning])\nJE_COMPILABLE([strerror_r returns char with gnu source], [\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n], [\n  char *buffer = (char *) malloc(100);\n  char *error = strerror_r(EINVAL, buffer, 100);\n  printf(\"%s\\n\", error);\n], [je_cv_strerror_r_returns_char_with_gnu_source])\nJE_CFLAGS_RESTORE()\nif test \"x${je_cv_strerror_r_returns_char_with_gnu_source}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_STRERROR_R_RETURNS_CHAR_WITH_GNU_SOURCE], [ ])\nfi\n\ndnl ============================================================================\ndnl Check for typedefs, structures, and compiler characteristics.\nAC_HEADER_STDBOOL\n\ndnl ============================================================================\ndnl Define commands that generate output files.\n\nAC_CONFIG_COMMANDS([include/jemalloc/internal/public_symbols.txt], [\n  f=\"${objroot}include/jemalloc/internal/public_symbols.txt\"\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  cp /dev/null \"${f}\"\n  for nm in `echo ${mangling_map} |tr ',' ' '` ; do\n    n=`echo ${nm} |tr ':' ' ' |awk '{print $[]1}'`\n    m=`echo ${nm} |tr ':' ' ' |awk '{print $[]2}'`\n    echo \"${n}:${m}\" >> \"${f}\"\n    dnl Remove name from public_syms so that it isn't redefined later.\n    public_syms=`for sym in ${public_syms}; do echo \"${sym}\"; done |grep -v \"^${n}\\$\" |tr '\\n' ' '`\n  done\n  for sym in ${public_syms} ; do\n    n=\"${sym}\"\n    m=\"${JEMALLOC_PREFIX}${sym}\"\n    echo \"${n}:${m}\" >> \"${f}\"\n  done\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n  mangling_map=\"${mangling_map}\"\n  public_syms=\"${public_syms}\"\n  JEMALLOC_PREFIX=\"${JEMALLOC_PREFIX}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/internal/private_symbols.awk], [\n  f=\"${objroot}include/jemalloc/internal/private_symbols.awk\"\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  export_syms=`for sym in ${public_syms}; do echo \"${JEMALLOC_PREFIX}${sym}\"; done; for sym in ${wrap_syms}; do echo \"${sym}\"; done;`\n  \"${srcdir}/include/jemalloc/internal/private_symbols.sh\" \"${SYM_PREFIX}\" ${export_syms} > \"${objroot}include/jemalloc/internal/private_symbols.awk\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n  public_syms=\"${public_syms}\"\n  wrap_syms=\"${wrap_syms}\"\n  SYM_PREFIX=\"${SYM_PREFIX}\"\n  JEMALLOC_PREFIX=\"${JEMALLOC_PREFIX}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/internal/private_symbols_jet.awk], [\n  f=\"${objroot}include/jemalloc/internal/private_symbols_jet.awk\"\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  export_syms=`for sym in ${public_syms}; do echo \"jet_${sym}\"; done; for sym in ${wrap_syms}; do echo \"${sym}\"; done;`\n  \"${srcdir}/include/jemalloc/internal/private_symbols.sh\" \"${SYM_PREFIX}\" ${export_syms} > \"${objroot}include/jemalloc/internal/private_symbols_jet.awk\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n  public_syms=\"${public_syms}\"\n  wrap_syms=\"${wrap_syms}\"\n  SYM_PREFIX=\"${SYM_PREFIX}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/internal/public_namespace.h], [\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  \"${srcdir}/include/jemalloc/internal/public_namespace.sh\" \"${objroot}include/jemalloc/internal/public_symbols.txt\" > \"${objroot}include/jemalloc/internal/public_namespace.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/internal/public_unnamespace.h], [\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  \"${srcdir}/include/jemalloc/internal/public_unnamespace.sh\" \"${objroot}include/jemalloc/internal/public_symbols.txt\" > \"${objroot}include/jemalloc/internal/public_unnamespace.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/jemalloc_protos_jet.h], [\n  mkdir -p \"${objroot}include/jemalloc\"\n  cat \"${srcdir}/include/jemalloc/jemalloc_protos.h.in\" | sed -e 's/@je_@/jet_/g' > \"${objroot}include/jemalloc/jemalloc_protos_jet.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/jemalloc_rename.h], [\n  mkdir -p \"${objroot}include/jemalloc\"\n  \"${srcdir}/include/jemalloc/jemalloc_rename.sh\" \"${objroot}include/jemalloc/internal/public_symbols.txt\" > \"${objroot}include/jemalloc/jemalloc_rename.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/jemalloc_mangle.h], [\n  mkdir -p \"${objroot}include/jemalloc\"\n  \"${srcdir}/include/jemalloc/jemalloc_mangle.sh\" \"${objroot}include/jemalloc/internal/public_symbols.txt\" je_ > \"${objroot}include/jemalloc/jemalloc_mangle.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/jemalloc_mangle_jet.h], [\n  mkdir -p \"${objroot}include/jemalloc\"\n  \"${srcdir}/include/jemalloc/jemalloc_mangle.sh\" \"${objroot}include/jemalloc/internal/public_symbols.txt\" jet_ > \"${objroot}include/jemalloc/jemalloc_mangle_jet.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/jemalloc.h], [\n  mkdir -p \"${objroot}include/jemalloc\"\n  \"${srcdir}/include/jemalloc/jemalloc.sh\" \"${objroot}\" > \"${objroot}include/jemalloc/jemalloc${install_suffix}.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n  install_suffix=\"${install_suffix}\"\n])\n\ndnl Process .in files.\nAC_SUBST([cfghdrs_in])\nAC_SUBST([cfghdrs_out])\nAC_CONFIG_HEADERS([$cfghdrs_tup])\n\ndnl ============================================================================\ndnl Generate outputs.\n\nAC_CONFIG_FILES([$cfgoutputs_tup config.stamp bin/jemalloc-config bin/jemalloc.sh bin/jeprof])\nAC_SUBST([cfgoutputs_in])\nAC_SUBST([cfgoutputs_out])\nAC_OUTPUT\n\ndnl ============================================================================\ndnl Print out the results of configuration.\nAC_MSG_RESULT([===============================================================================])\nAC_MSG_RESULT([jemalloc version   : ${jemalloc_version}])\nAC_MSG_RESULT([library revision   : ${rev}])\nAC_MSG_RESULT([])\nAC_MSG_RESULT([CONFIG             : ${CONFIG}])\nAC_MSG_RESULT([CC                 : ${CC}])\nAC_MSG_RESULT([CONFIGURE_CFLAGS   : ${CONFIGURE_CFLAGS}])\nAC_MSG_RESULT([SPECIFIED_CFLAGS   : ${SPECIFIED_CFLAGS}])\nAC_MSG_RESULT([EXTRA_CFLAGS       : ${EXTRA_CFLAGS}])\nAC_MSG_RESULT([CPPFLAGS           : ${CPPFLAGS}])\nAC_MSG_RESULT([CXX                : ${CXX}])\nAC_MSG_RESULT([CONFIGURE_CXXFLAGS : ${CONFIGURE_CXXFLAGS}])\nAC_MSG_RESULT([SPECIFIED_CXXFLAGS : ${SPECIFIED_CXXFLAGS}])\nAC_MSG_RESULT([EXTRA_CXXFLAGS     : ${EXTRA_CXXFLAGS}])\nAC_MSG_RESULT([LDFLAGS            : ${LDFLAGS}])\nAC_MSG_RESULT([EXTRA_LDFLAGS      : ${EXTRA_LDFLAGS}])\nAC_MSG_RESULT([DSO_LDFLAGS        : ${DSO_LDFLAGS}])\nAC_MSG_RESULT([LIBS               : ${LIBS}])\nAC_MSG_RESULT([RPATH_EXTRA        : ${RPATH_EXTRA}])\nAC_MSG_RESULT([])\nAC_MSG_RESULT([XSLTPROC           : ${XSLTPROC}])\nAC_MSG_RESULT([XSLROOT            : ${XSLROOT}])\nAC_MSG_RESULT([])\nAC_MSG_RESULT([PREFIX             : ${PREFIX}])\nAC_MSG_RESULT([BINDIR             : ${BINDIR}])\nAC_MSG_RESULT([DATADIR            : ${DATADIR}])\nAC_MSG_RESULT([INCLUDEDIR         : ${INCLUDEDIR}])\nAC_MSG_RESULT([LIBDIR             : ${LIBDIR}])\nAC_MSG_RESULT([MANDIR             : ${MANDIR}])\nAC_MSG_RESULT([])\nAC_MSG_RESULT([srcroot            : ${srcroot}])\nAC_MSG_RESULT([abs_srcroot        : ${abs_srcroot}])\nAC_MSG_RESULT([objroot            : ${objroot}])\nAC_MSG_RESULT([abs_objroot        : ${abs_objroot}])\nAC_MSG_RESULT([])\nAC_MSG_RESULT([JEMALLOC_PREFIX    : ${JEMALLOC_PREFIX}])\nAC_MSG_RESULT([JEMALLOC_PRIVATE_NAMESPACE])\nAC_MSG_RESULT([                   : ${JEMALLOC_PRIVATE_NAMESPACE}])\nAC_MSG_RESULT([install_suffix     : ${install_suffix}])\nAC_MSG_RESULT([malloc_conf        : ${config_malloc_conf}])\nAC_MSG_RESULT([shared libs        : ${enable_shared}])\nAC_MSG_RESULT([static libs        : ${enable_static}])\nAC_MSG_RESULT([autogen            : ${enable_autogen}])\nAC_MSG_RESULT([debug              : ${enable_debug}])\nAC_MSG_RESULT([stats              : ${enable_stats}])\nAC_MSG_RESULT([experimetal_smallocx : ${enable_experimental_smallocx}])\nAC_MSG_RESULT([prof               : ${enable_prof}])\nAC_MSG_RESULT([prof-libunwind     : ${enable_prof_libunwind}])\nAC_MSG_RESULT([prof-libgcc        : ${enable_prof_libgcc}])\nAC_MSG_RESULT([prof-gcc           : ${enable_prof_gcc}])\nAC_MSG_RESULT([fill               : ${enable_fill}])\nAC_MSG_RESULT([utrace             : ${enable_utrace}])\nAC_MSG_RESULT([xmalloc            : ${enable_xmalloc}])\nAC_MSG_RESULT([log                : ${enable_log}])\nAC_MSG_RESULT([lazy_lock          : ${enable_lazy_lock}])\nAC_MSG_RESULT([cache-oblivious    : ${enable_cache_oblivious}])\nAC_MSG_RESULT([cxx                : ${enable_cxx}])\nAC_MSG_RESULT([===============================================================================])\n",
        "/tmp/vanessa/spack-stage/spack-stage-jemalloc-5.2.0-gqn3zrvt7mtn3szbgv2rwmc4lnriytmn/spack-src/INSTALL.md": "Building and installing a packaged release of jemalloc can be as simple as\ntyping the following while in the root directory of the source tree:\n\n    ./configure\n    make\n    make install\n\nIf building from unpackaged developer sources, the simplest command sequence\nthat might work is:\n\n    ./autogen.sh\n    make dist\n    make\n    make install\n\nNote that documentation is not built by the default target because doing so\nwould create a dependency on xsltproc in packaged releases, hence the\nrequirement to either run 'make dist' or avoid installing docs via the various\ninstall_* targets documented below.\n\n\n## Advanced configuration\n\nThe 'configure' script supports numerous options that allow control of which\nfunctionality is enabled, where jemalloc is installed, etc.  Optionally, pass\nany of the following arguments (not a definitive list) to 'configure':\n\n* `--help`\n\n    Print a definitive list of options.\n\n* `--prefix=<install-root-dir>`\n\n    Set the base directory in which to install.  For example:\n\n        ./configure --prefix=/usr/local\n\n    will cause files to be installed into /usr/local/include, /usr/local/lib,\n    and /usr/local/man.\n\n* `--with-version=(<major>.<minor>.<bugfix>-<nrev>-g<gid>|VERSION)`\n\n    The VERSION file is mandatory for successful configuration, and the\n    following steps are taken to assure its presence:\n    1) If --with-version=<major>.<minor>.<bugfix>-<nrev>-g<gid> is specified,\n       generate VERSION using the specified value.\n    2) If --with-version is not specified in either form and the source\n       directory is inside a git repository, try to generate VERSION via 'git\n       describe' invocations that pattern-match release tags.\n    3) If VERSION is missing, generate it with a bogus version:\n       0.0.0-0-g0000000000000000000000000000000000000000\n\n    Note that --with-version=VERSION bypasses (1) and (2), which simplifies\n    VERSION configuration when embedding a jemalloc release into another\n    project's git repository.\n\n* `--with-rpath=<colon-separated-rpath>`\n\n    Embed one or more library paths, so that libjemalloc can find the libraries\n    it is linked to.  This works only on ELF-based systems.\n\n* `--with-mangling=<map>`\n\n    Mangle public symbols specified in <map> which is a comma-separated list of\n    name:mangled pairs.\n\n    For example, to use ld's --wrap option as an alternative method for\n    overriding libc's malloc implementation, specify something like:\n\n      --with-mangling=malloc:__wrap_malloc,free:__wrap_free[...]\n\n    Note that mangling happens prior to application of the prefix specified by\n    --with-jemalloc-prefix, and mangled symbols are then ignored when applying\n    the prefix.\n\n* `--with-jemalloc-prefix=<prefix>`\n\n    Prefix all public APIs with <prefix>.  For example, if <prefix> is\n    \"prefix_\", API changes like the following occur:\n\n      malloc()         --> prefix_malloc()\n      malloc_conf      --> prefix_malloc_conf\n      /etc/malloc.conf --> /etc/prefix_malloc.conf\n      MALLOC_CONF      --> PREFIX_MALLOC_CONF\n\n    This makes it possible to use jemalloc at the same time as the system\n    allocator, or even to use multiple copies of jemalloc simultaneously.\n\n    By default, the prefix is \"\", except on OS X, where it is \"je_\".  On OS X,\n    jemalloc overlays the default malloc zone, but makes no attempt to actually\n    replace the \"malloc\", \"calloc\", etc. symbols.\n\n* `--without-export`\n\n    Don't export public APIs.  This can be useful when building jemalloc as a\n    static library, or to avoid exporting public APIs when using the zone\n    allocator on OSX.\n\n* `--with-private-namespace=<prefix>`\n\n    Prefix all library-private APIs with <prefix>je_.  For shared libraries,\n    symbol visibility mechanisms prevent these symbols from being exported, but\n    for static libraries, naming collisions are a real possibility.  By\n    default, <prefix> is empty, which results in a symbol prefix of je_ .\n\n* `--with-install-suffix=<suffix>`\n\n    Append <suffix> to the base name of all installed files, such that multiple\n    versions of jemalloc can coexist in the same installation directory.  For\n    example, libjemalloc.so.0 becomes libjemalloc<suffix>.so.0.\n\n* `--with-malloc-conf=<malloc_conf>`\n\n    Embed `<malloc_conf>` as a run-time options string that is processed prior to\n    the malloc_conf global variable, the /etc/malloc.conf symlink, and the\n    MALLOC_CONF environment variable.  For example, to change the default decay\n    time to 30 seconds:\n\n      --with-malloc-conf=decay_ms:30000\n\n* `--enable-debug`\n\n    Enable assertions and validation code.  This incurs a substantial\n    performance hit, but is very useful during application development.\n\n* `--disable-stats`\n\n    Disable statistics gathering functionality.  See the \"opt.stats_print\"\n    option documentation for usage details.\n\n* `--enable-prof`\n\n    Enable heap profiling and leak detection functionality.  See the \"opt.prof\"\n    option documentation for usage details.  When enabled, there are several\n    approaches to backtracing, and the configure script chooses the first one\n    in the following list that appears to function correctly:\n\n    + libunwind      (requires --enable-prof-libunwind)\n    + libgcc         (unless --disable-prof-libgcc)\n    + gcc intrinsics (unless --disable-prof-gcc)\n\n* `--enable-prof-libunwind`\n\n    Use the libunwind library (http://www.nongnu.org/libunwind/) for stack\n    backtracing.\n\n* `--disable-prof-libgcc`\n\n    Disable the use of libgcc's backtracing functionality.\n\n* `--disable-prof-gcc`\n\n    Disable the use of gcc intrinsics for backtracing.\n\n* `--with-static-libunwind=<libunwind.a>`\n\n    Statically link against the specified libunwind.a rather than dynamically\n    linking with -lunwind.\n\n* `--disable-fill`\n\n    Disable support for junk/zero filling of memory.  See the \"opt.junk\" and\n    \"opt.zero\" option documentation for usage details.\n\n* `--disable-zone-allocator`\n\n    Disable zone allocator for Darwin.  This means jemalloc won't be hooked as\n    the default allocator on OSX/iOS.\n\n* `--enable-utrace`\n\n    Enable utrace(2)-based allocation tracing.  This feature is not broadly\n    portable (FreeBSD has it, but Linux and OS X do not).\n\n* `--enable-xmalloc`\n\n    Enable support for optional immediate termination due to out-of-memory\n    errors, as is commonly implemented by \"xmalloc\" wrapper function for malloc.\n    See the \"opt.xmalloc\" option documentation for usage details.\n\n* `--enable-lazy-lock`\n\n    Enable code that wraps pthread_create() to detect when an application\n    switches from single-threaded to multi-threaded mode, so that it can avoid\n    mutex locking/unlocking operations while in single-threaded mode.  In\n    practice, this feature usually has little impact on performance unless\n    thread-specific caching is disabled.\n\n* `--disable-cache-oblivious`\n\n    Disable cache-oblivious large allocation alignment for large allocation\n    requests with no alignment constraints.  If this feature is disabled, all\n    large allocations are page-aligned as an implementation artifact, which can\n    severely harm CPU cache utilization.  However, the cache-oblivious layout\n    comes at the cost of one extra page per large allocation, which in the\n    most extreme case increases physical memory usage for the 16 KiB size class\n    to 20 KiB.\n\n* `--disable-syscall`\n\n    Disable use of syscall(2) rather than {open,read,write,close}(2).  This is\n    intended as a workaround for systems that place security limitations on\n    syscall(2).\n\n* `--disable-cxx`\n\n    Disable C++ integration.  This will cause new and delete operator\n    implementations to be omitted.\n\n* `--with-xslroot=<path>`\n\n    Specify where to find DocBook XSL stylesheets when building the\n    documentation.\n\n* `--with-lg-page=<lg-page>`\n\n    Specify the base 2 log of the allocator page size, which must in turn be at\n    least as large as the system page size.  By default the configure script\n    determines the host's page size and sets the allocator page size equal to\n    the system page size, so this option need not be specified unless the\n    system page size may change between configuration and execution, e.g. when\n    cross compiling.\n\n* `--with-lg-hugepage=<lg-hugepage>`\n\n    Specify the base 2 log of the system huge page size.  This option is useful\n    when cross compiling, or when overriding the default for systems that do\n    not explicitly support huge pages.\n\n* `--with-lg-quantum=<lg-quantum>`\n\n    Specify the base 2 log of the minimum allocation alignment.  jemalloc needs\n    to know the minimum alignment that meets the following C standard\n    requirement (quoted from the April 12, 2011 draft of the C11 standard):\n\n    >  The pointer returned if the allocation succeeds is suitably aligned so\n      that it may be assigned to a pointer to any type of object with a\n      fundamental alignment requirement and then used to access such an object\n      or an array of such objects in the space allocated [...]\n\n    This setting is architecture-specific, and although jemalloc includes known\n    safe values for the most commonly used modern architectures, there is a\n    wrinkle related to GNU libc (glibc) that may impact your choice of\n    <lg-quantum>.  On most modern architectures, this mandates 16-byte\n    alignment (<lg-quantum>=4), but the glibc developers chose not to meet this\n    requirement for performance reasons.  An old discussion can be found at\n    <https://sourceware.org/bugzilla/show_bug.cgi?id=206> .  Unlike glibc,\n    jemalloc does follow the C standard by default (caveat: jemalloc\n    technically cheats for size classes smaller than the quantum), but the fact\n    that Linux systems already work around this allocator noncompliance means\n    that it is generally safe in practice to let jemalloc's minimum alignment\n    follow glibc's lead.  If you specify `--with-lg-quantum=3` during\n    configuration, jemalloc will provide additional size classes that are not\n    16-byte-aligned (24, 40, and 56).\n\n* `--with-lg-vaddr=<lg-vaddr>`\n\n    Specify the number of significant virtual address bits.  By default, the\n    configure script attempts to detect virtual address size on those platforms\n    where it knows how, and picks a default otherwise.  This option may be\n    useful when cross-compiling.\n\n* `--disable-initial-exec-tls`\n\n    Disable the initial-exec TLS model for jemalloc's internal thread-local\n    storage (on those platforms that support explicit settings).  This can allow\n    jemalloc to be dynamically loaded after program startup (e.g. using dlopen).\n    Note that in this case, there will be two malloc implementations operating\n    in the same process, which will almost certainly result in confusing runtime\n    crashes if pointers leak from one implementation to the other.\n\n* `--disable-libdl`\n\n    Disable the usage of libdl, namely dlsym(3) which is required by the lazy\n    lock option.  This can allow building static binaries.\n\nThe following environment variables (not a definitive list) impact configure's\nbehavior:\n\n* `CFLAGS=\"?\"`\n* `CXXFLAGS=\"?\"`\n\n    Pass these flags to the C/C++ compiler.  Any flags set by the configure\n    script are prepended, which means explicitly set flags generally take\n    precedence.  Take care when specifying flags such as -Werror, because\n    configure tests may be affected in undesirable ways.\n\n* `EXTRA_CFLAGS=\"?\"`\n* `EXTRA_CXXFLAGS=\"?\"`\n\n    Append these flags to CFLAGS/CXXFLAGS, without passing them to the\n    compiler(s) during configuration.  This makes it possible to add flags such\n    as -Werror, while allowing the configure script to determine what other\n    flags are appropriate for the specified configuration.\n\n* `CPPFLAGS=\"?\"`\n\n    Pass these flags to the C preprocessor.  Note that CFLAGS is not passed to\n    'cpp' when 'configure' is looking for include files, so you must use\n    CPPFLAGS instead if you need to help 'configure' find header files.\n\n* `LD_LIBRARY_PATH=\"?\"`\n\n    'ld' uses this colon-separated list to find libraries.\n\n* `LDFLAGS=\"?\"`\n\n    Pass these flags when linking.\n\n* `PATH=\"?\"`\n\n    'configure' uses this to find programs.\n\nIn some cases it may be necessary to work around configuration results that do\nnot match reality.  For example, Linux 4.5 added support for the MADV_FREE flag\nto madvise(2), which can cause problems if building on a host with MADV_FREE\nsupport and deploying to a target without.  To work around this, use a cache\nfile to override the relevant configuration variable defined in configure.ac,\ne.g.:\n\n    echo \"je_cv_madv_free=no\" > config.cache && ./configure -C\n\n\n## Advanced compilation\n\nTo build only parts of jemalloc, use the following targets:\n\n    build_lib_shared\n    build_lib_static\n    build_lib\n    build_doc_html\n    build_doc_man\n    build_doc\n\nTo install only parts of jemalloc, use the following targets:\n\n    install_bin\n    install_include\n    install_lib_shared\n    install_lib_static\n    install_lib_pc\n    install_lib\n    install_doc_html\n    install_doc_man\n    install_doc\n\nTo clean up build results to varying degrees, use the following make targets:\n\n    clean\n    distclean\n    relclean\n\n\n## Advanced installation\n\nOptionally, define make variables when invoking make, including (not\nexclusively):\n\n* `INCLUDEDIR=\"?\"`\n\n    Use this as the installation prefix for header files.\n\n* `LIBDIR=\"?\"`\n\n    Use this as the installation prefix for libraries.\n\n* `MANDIR=\"?\"`\n\n    Use this as the installation prefix for man pages.\n\n* `DESTDIR=\"?\"`\n\n    Prepend DESTDIR to INCLUDEDIR, LIBDIR, DATADIR, and MANDIR.  This is useful\n    when installing to a different path than was specified via --prefix.\n\n* `CC=\"?\"`\n\n    Use this to invoke the C compiler.\n\n* `CFLAGS=\"?\"`\n\n    Pass these flags to the compiler.\n\n* `CPPFLAGS=\"?\"`\n\n    Pass these flags to the C preprocessor.\n\n* `LDFLAGS=\"?\"`\n\n    Pass these flags when linking.\n\n* `PATH=\"?\"`\n\n    Use this to search for programs used during configuration and building.\n\n\n## Development\n\nIf you intend to make non-trivial changes to jemalloc, use the 'autogen.sh'\nscript rather than 'configure'.  This re-generates 'configure', enables\nconfiguration dependency rules, and enables re-generation of automatically\ngenerated source files.\n\nThe build system supports using an object directory separate from the source\ntree.  For example, you can create an 'obj' directory, and from within that\ndirectory, issue configuration and build commands:\n\n    autoconf\n    mkdir obj\n    cd obj\n    ../configure --enable-autogen\n    make\n\n\n## Documentation\n\nThe manual page is generated in both html and roff formats.  Any web browser\ncan be used to view the html manual.  The roff manual page can be formatted\nprior to installation via the following command:\n\n    nroff -man -t doc/jemalloc.3\n",
        "/tmp/vanessa/spack-stage/spack-stage-jemalloc-5.2.0-gqn3zrvt7mtn3szbgv2rwmc4lnriytmn/spack-src/src/background_thread.c": "#define JEMALLOC_BACKGROUND_THREAD_C_\n#include \"jemalloc/internal/jemalloc_preamble.h\"\n#include \"jemalloc/internal/jemalloc_internal_includes.h\"\n\n#include \"jemalloc/internal/assert.h\"\n\nJEMALLOC_DIAGNOSTIC_DISABLE_SPURIOUS\n\n/******************************************************************************/\n/* Data. */\n\n/* This option should be opt-in only. */\n#define BACKGROUND_THREAD_DEFAULT false\n/* Read-only after initialization. */\nbool opt_background_thread = BACKGROUND_THREAD_DEFAULT;\nsize_t opt_max_background_threads = MAX_BACKGROUND_THREAD_LIMIT + 1;\n\n/* Used for thread creation, termination and stats. */\nmalloc_mutex_t background_thread_lock;\n/* Indicates global state.  Atomic because decay reads this w/o locking. */\natomic_b_t background_thread_enabled_state;\nsize_t n_background_threads;\nsize_t max_background_threads;\n/* Thread info per-index. */\nbackground_thread_info_t *background_thread_info;\n\n/******************************************************************************/\n\n#ifdef JEMALLOC_PTHREAD_CREATE_WRAPPER\n\nstatic int (*pthread_create_fptr)(pthread_t *__restrict, const pthread_attr_t *,\n    void *(*)(void *), void *__restrict);\n\nstatic void\npthread_create_wrapper_init(void) {\n#ifdef JEMALLOC_LAZY_LOCK\n\tif (!isthreaded) {\n\t\tisthreaded = true;\n\t}\n#endif\n}\n\nint\npthread_create_wrapper(pthread_t *__restrict thread, const pthread_attr_t *attr,\n    void *(*start_routine)(void *), void *__restrict arg) {\n\tpthread_create_wrapper_init();\n\n\treturn pthread_create_fptr(thread, attr, start_routine, arg);\n}\n#endif /* JEMALLOC_PTHREAD_CREATE_WRAPPER */\n\n#ifndef JEMALLOC_BACKGROUND_THREAD\n#define NOT_REACHED { not_reached(); }\nbool background_thread_create(tsd_t *tsd, unsigned arena_ind) NOT_REACHED\nbool background_threads_enable(tsd_t *tsd) NOT_REACHED\nbool background_threads_disable(tsd_t *tsd) NOT_REACHED\nvoid background_thread_interval_check(tsdn_t *tsdn, arena_t *arena,\n    arena_decay_t *decay, size_t npages_new) NOT_REACHED\nvoid background_thread_prefork0(tsdn_t *tsdn) NOT_REACHED\nvoid background_thread_prefork1(tsdn_t *tsdn) NOT_REACHED\nvoid background_thread_postfork_parent(tsdn_t *tsdn) NOT_REACHED\nvoid background_thread_postfork_child(tsdn_t *tsdn) NOT_REACHED\nbool background_thread_stats_read(tsdn_t *tsdn,\n    background_thread_stats_t *stats) NOT_REACHED\nvoid background_thread_ctl_init(tsdn_t *tsdn) NOT_REACHED\n#undef NOT_REACHED\n#else\n\nstatic bool background_thread_enabled_at_fork;\n\nstatic void\nbackground_thread_info_init(tsdn_t *tsdn, background_thread_info_t *info) {\n\tbackground_thread_wakeup_time_set(tsdn, info, 0);\n\tinfo->npages_to_purge_new = 0;\n\tif (config_stats) {\n\t\tinfo->tot_n_runs = 0;\n\t\tnstime_init(&info->tot_sleep_time, 0);\n\t}\n}\n\nstatic inline bool\nset_current_thread_affinity(int cpu) {\n#if defined(JEMALLOC_HAVE_SCHED_SETAFFINITY)\n\tcpu_set_t cpuset;\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(cpu, &cpuset);\n\tint ret = sched_setaffinity(0, sizeof(cpu_set_t), &cpuset);\n\n\treturn (ret != 0);\n#else\n\treturn false;\n#endif\n}\n\n/* Threshold for determining when to wake up the background thread. */\n#define BACKGROUND_THREAD_NPAGES_THRESHOLD UINT64_C(1024)\n#define BILLION UINT64_C(1000000000)\n/* Minimal sleep interval 100 ms. */\n#define BACKGROUND_THREAD_MIN_INTERVAL_NS (BILLION / 10)\n\nstatic inline size_t\ndecay_npurge_after_interval(arena_decay_t *decay, size_t interval) {\n\tsize_t i;\n\tuint64_t sum = 0;\n\tfor (i = 0; i < interval; i++) {\n\t\tsum += decay->backlog[i] * h_steps[i];\n\t}\n\tfor (; i < SMOOTHSTEP_NSTEPS; i++) {\n\t\tsum += decay->backlog[i] * (h_steps[i] - h_steps[i - interval]);\n\t}\n\n\treturn (size_t)(sum >> SMOOTHSTEP_BFP);\n}\n\nstatic uint64_t\narena_decay_compute_purge_interval_impl(tsdn_t *tsdn, arena_decay_t *decay,\n    extents_t *extents) {\n\tif (malloc_mutex_trylock(tsdn, &decay->mtx)) {\n\t\t/* Use minimal interval if decay is contended. */\n\t\treturn BACKGROUND_THREAD_MIN_INTERVAL_NS;\n\t}\n\n\tuint64_t interval;\n\tssize_t decay_time = atomic_load_zd(&decay->time_ms, ATOMIC_RELAXED);\n\tif (decay_time <= 0) {\n\t\t/* Purging is eagerly done or disabled currently. */\n\t\tinterval = BACKGROUND_THREAD_INDEFINITE_SLEEP;\n\t\tgoto label_done;\n\t}\n\n\tuint64_t decay_interval_ns = nstime_ns(&decay->interval);\n\tassert(decay_interval_ns > 0);\n\tsize_t npages = extents_npages_get(extents);\n\tif (npages == 0) {\n\t\tunsigned i;\n\t\tfor (i = 0; i < SMOOTHSTEP_NSTEPS; i++) {\n\t\t\tif (decay->backlog[i] > 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == SMOOTHSTEP_NSTEPS) {\n\t\t\t/* No dirty pages recorded.  Sleep indefinitely. */\n\t\t\tinterval = BACKGROUND_THREAD_INDEFINITE_SLEEP;\n\t\t\tgoto label_done;\n\t\t}\n\t}\n\tif (npages <= BACKGROUND_THREAD_NPAGES_THRESHOLD) {\n\t\t/* Use max interval. */\n\t\tinterval = decay_interval_ns * SMOOTHSTEP_NSTEPS;\n\t\tgoto label_done;\n\t}\n\n\tsize_t lb = BACKGROUND_THREAD_MIN_INTERVAL_NS / decay_interval_ns;\n\tsize_t ub = SMOOTHSTEP_NSTEPS;\n\t/* Minimal 2 intervals to ensure reaching next epoch deadline. */\n\tlb = (lb < 2) ? 2 : lb;\n\tif ((decay_interval_ns * ub <= BACKGROUND_THREAD_MIN_INTERVAL_NS) ||\n\t    (lb + 2 > ub)) {\n\t\tinterval = BACKGROUND_THREAD_MIN_INTERVAL_NS;\n\t\tgoto label_done;\n\t}\n\n\tassert(lb + 2 <= ub);\n\tsize_t npurge_lb, npurge_ub;\n\tnpurge_lb = decay_npurge_after_interval(decay, lb);\n\tif (npurge_lb > BACKGROUND_THREAD_NPAGES_THRESHOLD) {\n\t\tinterval = decay_interval_ns * lb;\n\t\tgoto label_done;\n\t}\n\tnpurge_ub = decay_npurge_after_interval(decay, ub);\n\tif (npurge_ub < BACKGROUND_THREAD_NPAGES_THRESHOLD) {\n\t\tinterval = decay_interval_ns * ub;\n\t\tgoto label_done;\n\t}\n\n\tunsigned n_search = 0;\n\tsize_t target, npurge;\n\twhile ((npurge_lb + BACKGROUND_THREAD_NPAGES_THRESHOLD < npurge_ub)\n\t    && (lb + 2 < ub)) {\n\t\ttarget = (lb + ub) / 2;\n\t\tnpurge = decay_npurge_after_interval(decay, target);\n\t\tif (npurge > BACKGROUND_THREAD_NPAGES_THRESHOLD) {\n\t\t\tub = target;\n\t\t\tnpurge_ub = npurge;\n\t\t} else {\n\t\t\tlb = target;\n\t\t\tnpurge_lb = npurge;\n\t\t}\n\t\tassert(n_search++ < lg_floor(SMOOTHSTEP_NSTEPS) + 1);\n\t}\n\tinterval = decay_interval_ns * (ub + lb) / 2;\nlabel_done:\n\tinterval = (interval < BACKGROUND_THREAD_MIN_INTERVAL_NS) ?\n\t    BACKGROUND_THREAD_MIN_INTERVAL_NS : interval;\n\tmalloc_mutex_unlock(tsdn, &decay->mtx);\n\n\treturn interval;\n}\n\n/* Compute purge interval for background threads. */\nstatic uint64_t\narena_decay_compute_purge_interval(tsdn_t *tsdn, arena_t *arena) {\n\tuint64_t i1, i2;\n\ti1 = arena_decay_compute_purge_interval_impl(tsdn, &arena->decay_dirty,\n\t    &arena->extents_dirty);\n\tif (i1 == BACKGROUND_THREAD_MIN_INTERVAL_NS) {\n\t\treturn i1;\n\t}\n\ti2 = arena_decay_compute_purge_interval_impl(tsdn, &arena->decay_muzzy,\n\t    &arena->extents_muzzy);\n\n\treturn i1 < i2 ? i1 : i2;\n}\n\nstatic void\nbackground_thread_sleep(tsdn_t *tsdn, background_thread_info_t *info,\n    uint64_t interval) {\n\tif (config_stats) {\n\t\tinfo->tot_n_runs++;\n\t}\n\tinfo->npages_to_purge_new = 0;\n\n\tstruct timeval tv;\n\t/* Specific clock required by timedwait. */\n\tgettimeofday(&tv, NULL);\n\tnstime_t before_sleep;\n\tnstime_init2(&before_sleep, tv.tv_sec, tv.tv_usec * 1000);\n\n\tint ret;\n\tif (interval == BACKGROUND_THREAD_INDEFINITE_SLEEP) {\n\t\tassert(background_thread_indefinite_sleep(info));\n\t\tret = pthread_cond_wait(&info->cond, &info->mtx.lock);\n\t\tassert(ret == 0);\n\t} else {\n\t\tassert(interval >= BACKGROUND_THREAD_MIN_INTERVAL_NS &&\n\t\t    interval <= BACKGROUND_THREAD_INDEFINITE_SLEEP);\n\t\t/* We need malloc clock (can be different from tv). */\n\t\tnstime_t next_wakeup;\n\t\tnstime_init(&next_wakeup, 0);\n\t\tnstime_update(&next_wakeup);\n\t\tnstime_iadd(&next_wakeup, interval);\n\t\tassert(nstime_ns(&next_wakeup) <\n\t\t    BACKGROUND_THREAD_INDEFINITE_SLEEP);\n\t\tbackground_thread_wakeup_time_set(tsdn, info,\n\t\t    nstime_ns(&next_wakeup));\n\n\t\tnstime_t ts_wakeup;\n\t\tnstime_copy(&ts_wakeup, &before_sleep);\n\t\tnstime_iadd(&ts_wakeup, interval);\n\t\tstruct timespec ts;\n\t\tts.tv_sec = (size_t)nstime_sec(&ts_wakeup);\n\t\tts.tv_nsec = (size_t)nstime_nsec(&ts_wakeup);\n\n\t\tassert(!background_thread_indefinite_sleep(info));\n\t\tret = pthread_cond_timedwait(&info->cond, &info->mtx.lock, &ts);\n\t\tassert(ret == ETIMEDOUT || ret == 0);\n\t\tbackground_thread_wakeup_time_set(tsdn, info,\n\t\t    BACKGROUND_THREAD_INDEFINITE_SLEEP);\n\t}\n\tif (config_stats) {\n\t\tgettimeofday(&tv, NULL);\n\t\tnstime_t after_sleep;\n\t\tnstime_init2(&after_sleep, tv.tv_sec, tv.tv_usec * 1000);\n\t\tif (nstime_compare(&after_sleep, &before_sleep) > 0) {\n\t\t\tnstime_subtract(&after_sleep, &before_sleep);\n\t\t\tnstime_add(&info->tot_sleep_time, &after_sleep);\n\t\t}\n\t}\n}\n\nstatic bool\nbackground_thread_pause_check(tsdn_t *tsdn, background_thread_info_t *info) {\n\tif (unlikely(info->state == background_thread_paused)) {\n\t\tmalloc_mutex_unlock(tsdn, &info->mtx);\n\t\t/* Wait on global lock to update status. */\n\t\tmalloc_mutex_lock(tsdn, &background_thread_lock);\n\t\tmalloc_mutex_unlock(tsdn, &background_thread_lock);\n\t\tmalloc_mutex_lock(tsdn, &info->mtx);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline void\nbackground_work_sleep_once(tsdn_t *tsdn, background_thread_info_t *info, unsigned ind) {\n\tuint64_t min_interval = BACKGROUND_THREAD_INDEFINITE_SLEEP;\n\tunsigned narenas = narenas_total_get();\n\n\tfor (unsigned i = ind; i < narenas; i += max_background_threads) {\n\t\tarena_t *arena = arena_get(tsdn, i, false);\n\t\tif (!arena) {\n\t\t\tcontinue;\n\t\t}\n\t\tarena_decay(tsdn, arena, true, false);\n\t\tif (min_interval == BACKGROUND_THREAD_MIN_INTERVAL_NS) {\n\t\t\t/* Min interval will be used. */\n\t\t\tcontinue;\n\t\t}\n\t\tuint64_t interval = arena_decay_compute_purge_interval(tsdn,\n\t\t    arena);\n\t\tassert(interval >= BACKGROUND_THREAD_MIN_INTERVAL_NS);\n\t\tif (min_interval > interval) {\n\t\t\tmin_interval = interval;\n\t\t}\n\t}\n\tbackground_thread_sleep(tsdn, info, min_interval);\n}\n\nstatic bool\nbackground_threads_disable_single(tsd_t *tsd, background_thread_info_t *info) {\n\tif (info == &background_thread_info[0]) {\n\t\tmalloc_mutex_assert_owner(tsd_tsdn(tsd),\n\t\t    &background_thread_lock);\n\t} else {\n\t\tmalloc_mutex_assert_not_owner(tsd_tsdn(tsd),\n\t\t    &background_thread_lock);\n\t}\n\n\tpre_reentrancy(tsd, NULL);\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\tbool has_thread;\n\tassert(info->state != background_thread_paused);\n\tif (info->state == background_thread_started) {\n\t\thas_thread = true;\n\t\tinfo->state = background_thread_stopped;\n\t\tpthread_cond_signal(&info->cond);\n\t} else {\n\t\thas_thread = false;\n\t}\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n\n\tif (!has_thread) {\n\t\tpost_reentrancy(tsd);\n\t\treturn false;\n\t}\n\tvoid *ret;\n\tif (pthread_join(info->thread, &ret)) {\n\t\tpost_reentrancy(tsd);\n\t\treturn true;\n\t}\n\tassert(ret == NULL);\n\tn_background_threads--;\n\tpost_reentrancy(tsd);\n\n\treturn false;\n}\n\nstatic void *background_thread_entry(void *ind_arg);\n\nstatic int\nbackground_thread_create_signals_masked(pthread_t *thread,\n    const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg) {\n\t/*\n\t * Mask signals during thread creation so that the thread inherits\n\t * an empty signal set.\n\t */\n\tsigset_t set;\n\tsigfillset(&set);\n\tsigset_t oldset;\n\tint mask_err = pthread_sigmask(SIG_SETMASK, &set, &oldset);\n\tif (mask_err != 0) {\n\t\treturn mask_err;\n\t}\n\tint create_err = pthread_create_wrapper(thread, attr, start_routine,\n\t    arg);\n\t/*\n\t * Restore the signal mask.  Failure to restore the signal mask here\n\t * changes program behavior.\n\t */\n\tint restore_err = pthread_sigmask(SIG_SETMASK, &oldset, NULL);\n\tif (restore_err != 0) {\n\t\tmalloc_printf(\"<jemalloc>: background thread creation \"\n\t\t    \"failed (%d), and signal mask restoration failed \"\n\t\t    \"(%d)\\n\", create_err, restore_err);\n\t\tif (opt_abort) {\n\t\t\tabort();\n\t\t}\n\t}\n\treturn create_err;\n}\n\nstatic bool\ncheck_background_thread_creation(tsd_t *tsd, unsigned *n_created,\n    bool *created_threads) {\n\tbool ret = false;\n\tif (likely(*n_created == n_background_threads)) {\n\t\treturn ret;\n\t}\n\n\ttsdn_t *tsdn = tsd_tsdn(tsd);\n\tmalloc_mutex_unlock(tsdn, &background_thread_info[0].mtx);\n\tfor (unsigned i = 1; i < max_background_threads; i++) {\n\t\tif (created_threads[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tbackground_thread_info_t *info = &background_thread_info[i];\n\t\tmalloc_mutex_lock(tsdn, &info->mtx);\n\t\t/*\n\t\t * In case of the background_thread_paused state because of\n\t\t * arena reset, delay the creation.\n\t\t */\n\t\tbool create = (info->state == background_thread_started);\n\t\tmalloc_mutex_unlock(tsdn, &info->mtx);\n\t\tif (!create) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpre_reentrancy(tsd, NULL);\n\t\tint err = background_thread_create_signals_masked(&info->thread,\n\t\t    NULL, background_thread_entry, (void *)(uintptr_t)i);\n\t\tpost_reentrancy(tsd);\n\n\t\tif (err == 0) {\n\t\t\t(*n_created)++;\n\t\t\tcreated_threads[i] = true;\n\t\t} else {\n\t\t\tmalloc_printf(\"<jemalloc>: background thread \"\n\t\t\t    \"creation failed (%d)\\n\", err);\n\t\t\tif (opt_abort) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t}\n\t\t/* Return to restart the loop since we unlocked. */\n\t\tret = true;\n\t\tbreak;\n\t}\n\tmalloc_mutex_lock(tsdn, &background_thread_info[0].mtx);\n\n\treturn ret;\n}\n\nstatic void\nbackground_thread0_work(tsd_t *tsd) {\n\t/* Thread0 is also responsible for launching / terminating threads. */\n\tVARIABLE_ARRAY(bool, created_threads, max_background_threads);\n\tunsigned i;\n\tfor (i = 1; i < max_background_threads; i++) {\n\t\tcreated_threads[i] = false;\n\t}\n\t/* Start working, and create more threads when asked. */\n\tunsigned n_created = 1;\n\twhile (background_thread_info[0].state != background_thread_stopped) {\n\t\tif (background_thread_pause_check(tsd_tsdn(tsd),\n\t\t    &background_thread_info[0])) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (check_background_thread_creation(tsd, &n_created,\n\t\t    (bool *)&created_threads)) {\n\t\t\tcontinue;\n\t\t}\n\t\tbackground_work_sleep_once(tsd_tsdn(tsd),\n\t\t    &background_thread_info[0], 0);\n\t}\n\n\t/*\n\t * Shut down other threads at exit.  Note that the ctl thread is holding\n\t * the global background_thread mutex (and is waiting) for us.\n\t */\n\tassert(!background_thread_enabled());\n\tfor (i = 1; i < max_background_threads; i++) {\n\t\tbackground_thread_info_t *info = &background_thread_info[i];\n\t\tassert(info->state != background_thread_paused);\n\t\tif (created_threads[i]) {\n\t\t\tbackground_threads_disable_single(tsd, info);\n\t\t} else {\n\t\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\t\t\tif (info->state != background_thread_stopped) {\n\t\t\t\t/* The thread was not created. */\n\t\t\t\tassert(info->state ==\n\t\t\t\t    background_thread_started);\n\t\t\t\tn_background_threads--;\n\t\t\t\tinfo->state = background_thread_stopped;\n\t\t\t}\n\t\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n\t\t}\n\t}\n\tbackground_thread_info[0].state = background_thread_stopped;\n\tassert(n_background_threads == 1);\n}\n\nstatic void\nbackground_work(tsd_t *tsd, unsigned ind) {\n\tbackground_thread_info_t *info = &background_thread_info[ind];\n\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\tbackground_thread_wakeup_time_set(tsd_tsdn(tsd), info,\n\t    BACKGROUND_THREAD_INDEFINITE_SLEEP);\n\tif (ind == 0) {\n\t\tbackground_thread0_work(tsd);\n\t} else {\n\t\twhile (info->state != background_thread_stopped) {\n\t\t\tif (background_thread_pause_check(tsd_tsdn(tsd),\n\t\t\t    info)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbackground_work_sleep_once(tsd_tsdn(tsd), info, ind);\n\t\t}\n\t}\n\tassert(info->state == background_thread_stopped);\n\tbackground_thread_wakeup_time_set(tsd_tsdn(tsd), info, 0);\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n}\n\nstatic void *\nbackground_thread_entry(void *ind_arg) {\n\tunsigned thread_ind = (unsigned)(uintptr_t)ind_arg;\n\tassert(thread_ind < max_background_threads);\n#ifdef JEMALLOC_HAVE_PTHREAD_SETNAME_NP\n\tpthread_setname_np(pthread_self(), \"jemalloc_bg_thd\");\n#elif defined(__FreeBSD__)\n\tpthread_set_name_np(pthread_self(), \"jemalloc_bg_thd\");\n#endif\n\tif (opt_percpu_arena != percpu_arena_disabled) {\n\t\tset_current_thread_affinity((int)thread_ind);\n\t}\n\t/*\n\t * Start periodic background work.  We use internal tsd which avoids\n\t * side effects, for example triggering new arena creation (which in\n\t * turn triggers another background thread creation).\n\t */\n\tbackground_work(tsd_internal_fetch(), thread_ind);\n\tassert(pthread_equal(pthread_self(),\n\t    background_thread_info[thread_ind].thread));\n\n\treturn NULL;\n}\n\nstatic void\nbackground_thread_init(tsd_t *tsd, background_thread_info_t *info) {\n\tmalloc_mutex_assert_owner(tsd_tsdn(tsd), &background_thread_lock);\n\tinfo->state = background_thread_started;\n\tbackground_thread_info_init(tsd_tsdn(tsd), info);\n\tn_background_threads++;\n}\n\nstatic bool\nbackground_thread_create_locked(tsd_t *tsd, unsigned arena_ind) {\n\tassert(have_background_thread);\n\tmalloc_mutex_assert_owner(tsd_tsdn(tsd), &background_thread_lock);\n\n\t/* We create at most NCPUs threads. */\n\tsize_t thread_ind = arena_ind % max_background_threads;\n\tbackground_thread_info_t *info = &background_thread_info[thread_ind];\n\n\tbool need_new_thread;\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\tneed_new_thread = background_thread_enabled() &&\n\t    (info->state == background_thread_stopped);\n\tif (need_new_thread) {\n\t\tbackground_thread_init(tsd, info);\n\t}\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n\tif (!need_new_thread) {\n\t\treturn false;\n\t}\n\tif (arena_ind != 0) {\n\t\t/* Threads are created asynchronously by Thread 0. */\n\t\tbackground_thread_info_t *t0 = &background_thread_info[0];\n\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &t0->mtx);\n\t\tassert(t0->state == background_thread_started);\n\t\tpthread_cond_signal(&t0->cond);\n\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &t0->mtx);\n\n\t\treturn false;\n\t}\n\n\tpre_reentrancy(tsd, NULL);\n\t/*\n\t * To avoid complications (besides reentrancy), create internal\n\t * background threads with the underlying pthread_create.\n\t */\n\tint err = background_thread_create_signals_masked(&info->thread, NULL,\n\t    background_thread_entry, (void *)thread_ind);\n\tpost_reentrancy(tsd);\n\n\tif (err != 0) {\n\t\tmalloc_printf(\"<jemalloc>: arena 0 background thread creation \"\n\t\t    \"failed (%d)\\n\", err);\n\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\t\tinfo->state = background_thread_stopped;\n\t\tn_background_threads--;\n\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/* Create a new background thread if needed. */\nbool\nbackground_thread_create(tsd_t *tsd, unsigned arena_ind) {\n\tassert(have_background_thread);\n\n\tbool ret;\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &background_thread_lock);\n\tret = background_thread_create_locked(tsd, arena_ind);\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &background_thread_lock);\n\n\treturn ret;\n}\n\nbool\nbackground_threads_enable(tsd_t *tsd) {\n\tassert(n_background_threads == 0);\n\tassert(background_thread_enabled());\n\tmalloc_mutex_assert_owner(tsd_tsdn(tsd), &background_thread_lock);\n\n\tVARIABLE_ARRAY(bool, marked, max_background_threads);\n\tunsigned i, nmarked;\n\tfor (i = 0; i < max_background_threads; i++) {\n\t\tmarked[i] = false;\n\t}\n\tnmarked = 0;\n\t/* Thread 0 is required and created at the end. */\n\tmarked[0] = true;\n\t/* Mark the threads we need to create for thread 0. */\n\tunsigned n = narenas_total_get();\n\tfor (i = 1; i < n; i++) {\n\t\tif (marked[i % max_background_threads] ||\n\t\t    arena_get(tsd_tsdn(tsd), i, false) == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tbackground_thread_info_t *info = &background_thread_info[\n\t\t    i % max_background_threads];\n\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\t\tassert(info->state == background_thread_stopped);\n\t\tbackground_thread_init(tsd, info);\n\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n\t\tmarked[i % max_background_threads] = true;\n\t\tif (++nmarked == max_background_threads) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn background_thread_create_locked(tsd, 0);\n}\n\nbool\nbackground_threads_disable(tsd_t *tsd) {\n\tassert(!background_thread_enabled());\n\tmalloc_mutex_assert_owner(tsd_tsdn(tsd), &background_thread_lock);\n\n\t/* Thread 0 will be responsible for terminating other threads. */\n\tif (background_threads_disable_single(tsd,\n\t    &background_thread_info[0])) {\n\t\treturn true;\n\t}\n\tassert(n_background_threads == 0);\n\n\treturn false;\n}\n\n/* Check if we need to signal the background thread early. */\nvoid\nbackground_thread_interval_check(tsdn_t *tsdn, arena_t *arena,\n    arena_decay_t *decay, size_t npages_new) {\n\tbackground_thread_info_t *info = arena_background_thread_info_get(\n\t    arena);\n\tif (malloc_mutex_trylock(tsdn, &info->mtx)) {\n\t\t/*\n\t\t * Background thread may hold the mutex for a long period of\n\t\t * time.  We'd like to avoid the variance on application\n\t\t * threads.  So keep this non-blocking, and leave the work to a\n\t\t * future epoch.\n\t\t */\n\t\treturn;\n\t}\n\n\tif (info->state != background_thread_started) {\n\t\tgoto label_done;\n\t}\n\tif (malloc_mutex_trylock(tsdn, &decay->mtx)) {\n\t\tgoto label_done;\n\t}\n\n\tssize_t decay_time = atomic_load_zd(&decay->time_ms, ATOMIC_RELAXED);\n\tif (decay_time <= 0) {\n\t\t/* Purging is eagerly done or disabled currently. */\n\t\tgoto label_done_unlock2;\n\t}\n\tuint64_t decay_interval_ns = nstime_ns(&decay->interval);\n\tassert(decay_interval_ns > 0);\n\n\tnstime_t diff;\n\tnstime_init(&diff, background_thread_wakeup_time_get(info));\n\tif (nstime_compare(&diff, &decay->epoch) <= 0) {\n\t\tgoto label_done_unlock2;\n\t}\n\tnstime_subtract(&diff, &decay->epoch);\n\tif (nstime_ns(&diff) < BACKGROUND_THREAD_MIN_INTERVAL_NS) {\n\t\tgoto label_done_unlock2;\n\t}\n\n\tif (npages_new > 0) {\n\t\tsize_t n_epoch = (size_t)(nstime_ns(&diff) / decay_interval_ns);\n\t\t/*\n\t\t * Compute how many new pages we would need to purge by the next\n\t\t * wakeup, which is used to determine if we should signal the\n\t\t * background thread.\n\t\t */\n\t\tuint64_t npurge_new;\n\t\tif (n_epoch >= SMOOTHSTEP_NSTEPS) {\n\t\t\tnpurge_new = npages_new;\n\t\t} else {\n\t\t\tuint64_t h_steps_max = h_steps[SMOOTHSTEP_NSTEPS - 1];\n\t\t\tassert(h_steps_max >=\n\t\t\t    h_steps[SMOOTHSTEP_NSTEPS - 1 - n_epoch]);\n\t\t\tnpurge_new = npages_new * (h_steps_max -\n\t\t\t    h_steps[SMOOTHSTEP_NSTEPS - 1 - n_epoch]);\n\t\t\tnpurge_new >>= SMOOTHSTEP_BFP;\n\t\t}\n\t\tinfo->npages_to_purge_new += npurge_new;\n\t}\n\n\tbool should_signal;\n\tif (info->npages_to_purge_new > BACKGROUND_THREAD_NPAGES_THRESHOLD) {\n\t\tshould_signal = true;\n\t} else if (unlikely(background_thread_indefinite_sleep(info)) &&\n\t    (extents_npages_get(&arena->extents_dirty) > 0 ||\n\t    extents_npages_get(&arena->extents_muzzy) > 0 ||\n\t    info->npages_to_purge_new > 0)) {\n\t\tshould_signal = true;\n\t} else {\n\t\tshould_signal = false;\n\t}\n\n\tif (should_signal) {\n\t\tinfo->npages_to_purge_new = 0;\n\t\tpthread_cond_signal(&info->cond);\n\t}\nlabel_done_unlock2:\n\tmalloc_mutex_unlock(tsdn, &decay->mtx);\nlabel_done:\n\tmalloc_mutex_unlock(tsdn, &info->mtx);\n}\n\nvoid\nbackground_thread_prefork0(tsdn_t *tsdn) {\n\tmalloc_mutex_prefork(tsdn, &background_thread_lock);\n\tbackground_thread_enabled_at_fork = background_thread_enabled();\n}\n\nvoid\nbackground_thread_prefork1(tsdn_t *tsdn) {\n\tfor (unsigned i = 0; i < max_background_threads; i++) {\n\t\tmalloc_mutex_prefork(tsdn, &background_thread_info[i].mtx);\n\t}\n}\n\nvoid\nbackground_thread_postfork_parent(tsdn_t *tsdn) {\n\tfor (unsigned i = 0; i < max_background_threads; i++) {\n\t\tmalloc_mutex_postfork_parent(tsdn,\n\t\t    &background_thread_info[i].mtx);\n\t}\n\tmalloc_mutex_postfork_parent(tsdn, &background_thread_lock);\n}\n\nvoid\nbackground_thread_postfork_child(tsdn_t *tsdn) {\n\tfor (unsigned i = 0; i < max_background_threads; i++) {\n\t\tmalloc_mutex_postfork_child(tsdn,\n\t\t    &background_thread_info[i].mtx);\n\t}\n\tmalloc_mutex_postfork_child(tsdn, &background_thread_lock);\n\tif (!background_thread_enabled_at_fork) {\n\t\treturn;\n\t}\n\n\t/* Clear background_thread state (reset to disabled for child). */\n\tmalloc_mutex_lock(tsdn, &background_thread_lock);\n\tn_background_threads = 0;\n\tbackground_thread_enabled_set(tsdn, false);\n\tfor (unsigned i = 0; i < max_background_threads; i++) {\n\t\tbackground_thread_info_t *info = &background_thread_info[i];\n\t\tmalloc_mutex_lock(tsdn, &info->mtx);\n\t\tinfo->state = background_thread_stopped;\n\t\tint ret = pthread_cond_init(&info->cond, NULL);\n\t\tassert(ret == 0);\n\t\tbackground_thread_info_init(tsdn, info);\n\t\tmalloc_mutex_unlock(tsdn, &info->mtx);\n\t}\n\tmalloc_mutex_unlock(tsdn, &background_thread_lock);\n}\n\nbool\nbackground_thread_stats_read(tsdn_t *tsdn, background_thread_stats_t *stats) {\n\tassert(config_stats);\n\tmalloc_mutex_lock(tsdn, &background_thread_lock);\n\tif (!background_thread_enabled()) {\n\t\tmalloc_mutex_unlock(tsdn, &background_thread_lock);\n\t\treturn true;\n\t}\n\n\tstats->num_threads = n_background_threads;\n\tuint64_t num_runs = 0;\n\tnstime_init(&stats->run_interval, 0);\n\tfor (unsigned i = 0; i < max_background_threads; i++) {\n\t\tbackground_thread_info_t *info = &background_thread_info[i];\n\t\tmalloc_mutex_lock(tsdn, &info->mtx);\n\t\tif (info->state != background_thread_stopped) {\n\t\t\tnum_runs += info->tot_n_runs;\n\t\t\tnstime_add(&stats->run_interval, &info->tot_sleep_time);\n\t\t}\n\t\tmalloc_mutex_unlock(tsdn, &info->mtx);\n\t}\n\tstats->num_runs = num_runs;\n\tif (num_runs > 0) {\n\t\tnstime_idivide(&stats->run_interval, num_runs);\n\t}\n\tmalloc_mutex_unlock(tsdn, &background_thread_lock);\n\n\treturn false;\n}\n\n#undef BACKGROUND_THREAD_NPAGES_THRESHOLD\n#undef BILLION\n#undef BACKGROUND_THREAD_MIN_INTERVAL_NS\n\n#ifdef JEMALLOC_HAVE_DLSYM\n#include <dlfcn.h>\n#endif\n\nstatic bool\npthread_create_fptr_init(void) {\n\tif (pthread_create_fptr != NULL) {\n\t\treturn false;\n\t}\n\t/*\n\t * Try the next symbol first, because 1) when use lazy_lock we have a\n\t * wrapper for pthread_create; and 2) application may define its own\n\t * wrapper as well (and can call malloc within the wrapper).\n\t */\n#ifdef JEMALLOC_HAVE_DLSYM\n\tpthread_create_fptr = dlsym(RTLD_NEXT, \"pthread_create\");\n#else\n\tpthread_create_fptr = NULL;\n#endif\n\tif (pthread_create_fptr == NULL) {\n\t\tif (config_lazy_lock) {\n\t\t\tmalloc_write(\"<jemalloc>: Error in dlsym(RTLD_NEXT, \"\n\t\t\t    \"\\\"pthread_create\\\")\\n\");\n\t\t\tabort();\n\t\t} else {\n\t\t\t/* Fall back to the default symbol. */\n\t\t\tpthread_create_fptr = pthread_create;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/*\n * When lazy lock is enabled, we need to make sure setting isthreaded before\n * taking any background_thread locks.  This is called early in ctl (instead of\n * wait for the pthread_create calls to trigger) because the mutex is required\n * before creating background threads.\n */\nvoid\nbackground_thread_ctl_init(tsdn_t *tsdn) {\n\tmalloc_mutex_assert_not_owner(tsdn, &background_thread_lock);\n#ifdef JEMALLOC_PTHREAD_CREATE_WRAPPER\n\tpthread_create_fptr_init();\n\tpthread_create_wrapper_init();\n#endif\n}\n\n#endif /* defined(JEMALLOC_BACKGROUND_THREAD) */\n\nbool\nbackground_thread_boot0(void) {\n\tif (!have_background_thread && opt_background_thread) {\n\t\tmalloc_printf(\"<jemalloc>: option background_thread currently \"\n\t\t    \"supports pthread only\\n\");\n\t\treturn true;\n\t}\n#ifdef JEMALLOC_PTHREAD_CREATE_WRAPPER\n\tif ((config_lazy_lock || opt_background_thread) &&\n\t    pthread_create_fptr_init()) {\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nbool\nbackground_thread_boot1(tsdn_t *tsdn) {\n#ifdef JEMALLOC_BACKGROUND_THREAD\n\tassert(have_background_thread);\n\tassert(narenas_total_get() > 0);\n\n\tif (opt_max_background_threads > MAX_BACKGROUND_THREAD_LIMIT) {\n\t\topt_max_background_threads = DEFAULT_NUM_BACKGROUND_THREAD;\n\t}\n\tmax_background_threads = opt_max_background_threads;\n\n\tbackground_thread_enabled_set(tsdn, opt_background_thread);\n\tif (malloc_mutex_init(&background_thread_lock,\n\t    \"background_thread_global\",\n\t    WITNESS_RANK_BACKGROUND_THREAD_GLOBAL,\n\t    malloc_mutex_rank_exclusive)) {\n\t\treturn true;\n\t}\n\n\tbackground_thread_info = (background_thread_info_t *)base_alloc(tsdn,\n\t    b0get(), opt_max_background_threads *\n\t    sizeof(background_thread_info_t), CACHELINE);\n\tif (background_thread_info == NULL) {\n\t\treturn true;\n\t}\n\n\tfor (unsigned i = 0; i < max_background_threads; i++) {\n\t\tbackground_thread_info_t *info = &background_thread_info[i];\n\t\t/* Thread mutex is rank_inclusive because of thread0. */\n\t\tif (malloc_mutex_init(&info->mtx, \"background_thread\",\n\t\t    WITNESS_RANK_BACKGROUND_THREAD,\n\t\t    malloc_mutex_address_ordered)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (pthread_cond_init(&info->cond, NULL)) {\n\t\t\treturn true;\n\t\t}\n\t\tmalloc_mutex_lock(tsdn, &info->mtx);\n\t\tinfo->state = background_thread_stopped;\n\t\tbackground_thread_info_init(tsdn, info);\n\t\tmalloc_mutex_unlock(tsdn, &info->mtx);\n\t}\n#endif\n\n\treturn false;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-jemalloc-5.2.0-gqn3zrvt7mtn3szbgv2rwmc4lnriytmn/spack-src/include/jemalloc/internal/jemalloc_internal_defs.h.in": "#ifndef JEMALLOC_INTERNAL_DEFS_H_\n#define JEMALLOC_INTERNAL_DEFS_H_\n/*\n * If JEMALLOC_PREFIX is defined via --with-jemalloc-prefix, it will cause all\n * public APIs to be prefixed.  This makes it possible, with some care, to use\n * multiple allocators simultaneously.\n */\n#undef JEMALLOC_PREFIX\n#undef JEMALLOC_CPREFIX\n\n/*\n * Define overrides for non-standard allocator-related functions if they are\n * present on the system.\n */\n#undef JEMALLOC_OVERRIDE___LIBC_CALLOC\n#undef JEMALLOC_OVERRIDE___LIBC_FREE\n#undef JEMALLOC_OVERRIDE___LIBC_MALLOC\n#undef JEMALLOC_OVERRIDE___LIBC_MEMALIGN\n#undef JEMALLOC_OVERRIDE___LIBC_REALLOC\n#undef JEMALLOC_OVERRIDE___LIBC_VALLOC\n#undef JEMALLOC_OVERRIDE___POSIX_MEMALIGN\n\n/*\n * JEMALLOC_PRIVATE_NAMESPACE is used as a prefix for all library-private APIs.\n * For shared libraries, symbol visibility mechanisms prevent these symbols\n * from being exported, but for static libraries, naming collisions are a real\n * possibility.\n */\n#undef JEMALLOC_PRIVATE_NAMESPACE\n\n/*\n * Hyper-threaded CPUs may need a special instruction inside spin loops in\n * order to yield to another virtual CPU.\n */\n#undef CPU_SPINWAIT\n/* 1 if CPU_SPINWAIT is defined, 0 otherwise. */\n#undef HAVE_CPU_SPINWAIT\n\n/*\n * Number of significant bits in virtual addresses.  This may be less than the\n * total number of bits in a pointer, e.g. on x64, for which the uppermost 16\n * bits are the same as bit 47.\n */\n#undef LG_VADDR\n\n/* Defined if C11 atomics are available. */\n#undef JEMALLOC_C11_ATOMICS\n\n/* Defined if GCC __atomic atomics are available. */\n#undef JEMALLOC_GCC_ATOMIC_ATOMICS\n/* and the 8-bit variant support. */\n#undef JEMALLOC_GCC_U8_ATOMIC_ATOMICS\n\n/* Defined if GCC __sync atomics are available. */\n#undef JEMALLOC_GCC_SYNC_ATOMICS\n/* and the 8-bit variant support. */\n#undef JEMALLOC_GCC_U8_SYNC_ATOMICS\n\n/*\n * Defined if __builtin_clz() and __builtin_clzl() are available.\n */\n#undef JEMALLOC_HAVE_BUILTIN_CLZ\n\n/*\n * Defined if os_unfair_lock_*() functions are available, as provided by Darwin.\n */\n#undef JEMALLOC_OS_UNFAIR_LOCK\n\n/* Defined if syscall(2) is usable. */\n#undef JEMALLOC_USE_SYSCALL\n\n/*\n * Defined if secure_getenv(3) is available.\n */\n#undef JEMALLOC_HAVE_SECURE_GETENV\n\n/*\n * Defined if issetugid(2) is available.\n */\n#undef JEMALLOC_HAVE_ISSETUGID\n\n/* Defined if pthread_atfork(3) is available. */\n#undef JEMALLOC_HAVE_PTHREAD_ATFORK\n\n/* Defined if pthread_setname_np(3) is available. */\n#undef JEMALLOC_HAVE_PTHREAD_SETNAME_NP\n\n/*\n * Defined if clock_gettime(CLOCK_MONOTONIC_COARSE, ...) is available.\n */\n#undef JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE\n\n/*\n * Defined if clock_gettime(CLOCK_MONOTONIC, ...) is available.\n */\n#undef JEMALLOC_HAVE_CLOCK_MONOTONIC\n\n/*\n * Defined if mach_absolute_time() is available.\n */\n#undef JEMALLOC_HAVE_MACH_ABSOLUTE_TIME\n\n/*\n * Defined if _malloc_thread_cleanup() exists.  At least in the case of\n * FreeBSD, pthread_key_create() allocates, which if used during malloc\n * bootstrapping will cause recursion into the pthreads library.  Therefore, if\n * _malloc_thread_cleanup() exists, use it as the basis for thread cleanup in\n * malloc_tsd.\n */\n#undef JEMALLOC_MALLOC_THREAD_CLEANUP\n\n/*\n * Defined if threaded initialization is known to be safe on this platform.\n * Among other things, it must be possible to initialize a mutex without\n * triggering allocation in order for threaded allocation to be safe.\n */\n#undef JEMALLOC_THREADED_INIT\n\n/*\n * Defined if the pthreads implementation defines\n * _pthread_mutex_init_calloc_cb(), in which case the function is used in order\n * to avoid recursive allocation during mutex initialization.\n */\n#undef JEMALLOC_MUTEX_INIT_CB\n\n/* Non-empty if the tls_model attribute is supported. */\n#undef JEMALLOC_TLS_MODEL\n\n/*\n * JEMALLOC_DEBUG enables assertions and other sanity checks, and disables\n * inline functions.\n */\n#undef JEMALLOC_DEBUG\n\n/* JEMALLOC_STATS enables statistics calculation. */\n#undef JEMALLOC_STATS\n\n/* JEMALLOC_EXPERIMENTAL_SMALLOCX_API enables experimental smallocx API. */\n#undef JEMALLOC_EXPERIMENTAL_SMALLOCX_API\n\n/* JEMALLOC_PROF enables allocation profiling. */\n#undef JEMALLOC_PROF\n\n/* Use libunwind for profile backtracing if defined. */\n#undef JEMALLOC_PROF_LIBUNWIND\n\n/* Use libgcc for profile backtracing if defined. */\n#undef JEMALLOC_PROF_LIBGCC\n\n/* Use gcc intrinsics for profile backtracing if defined. */\n#undef JEMALLOC_PROF_GCC\n\n/*\n * JEMALLOC_DSS enables use of sbrk(2) to allocate extents from the data storage\n * segment (DSS).\n */\n#undef JEMALLOC_DSS\n\n/* Support memory filling (junk/zero). */\n#undef JEMALLOC_FILL\n\n/* Support utrace(2)-based tracing. */\n#undef JEMALLOC_UTRACE\n\n/* Support optional abort() on OOM. */\n#undef JEMALLOC_XMALLOC\n\n/* Support lazy locking (avoid locking unless a second thread is launched). */\n#undef JEMALLOC_LAZY_LOCK\n\n/*\n * Minimum allocation alignment is 2^LG_QUANTUM bytes (ignoring tiny size\n * classes).\n */\n#undef LG_QUANTUM\n\n/* One page is 2^LG_PAGE bytes. */\n#undef LG_PAGE\n\n/*\n * One huge page is 2^LG_HUGEPAGE bytes.  Note that this is defined even if the\n * system does not explicitly support huge pages; system calls that require\n * explicit huge page support are separately configured.\n */\n#undef LG_HUGEPAGE\n\n/*\n * If defined, adjacent virtual memory mappings with identical attributes\n * automatically coalesce, and they fragment when changes are made to subranges.\n * This is the normal order of things for mmap()/munmap(), but on Windows\n * VirtualAlloc()/VirtualFree() operations must be precisely matched, i.e.\n * mappings do *not* coalesce/fragment.\n */\n#undef JEMALLOC_MAPS_COALESCE\n\n/*\n * If defined, retain memory for later reuse by default rather than using e.g.\n * munmap() to unmap freed extents.  This is enabled on 64-bit Linux because\n * common sequences of mmap()/munmap() calls will cause virtual memory map\n * holes.\n */\n#undef JEMALLOC_RETAIN\n\n/* TLS is used to map arenas and magazine caches to threads. */\n#undef JEMALLOC_TLS\n\n/*\n * Used to mark unreachable code to quiet \"end of non-void\" compiler warnings.\n * Don't use this directly; instead use unreachable() from util.h\n */\n#undef JEMALLOC_INTERNAL_UNREACHABLE\n\n/*\n * ffs*() functions to use for bitmapping.  Don't use these directly; instead,\n * use ffs_*() from util.h.\n */\n#undef JEMALLOC_INTERNAL_FFSLL\n#undef JEMALLOC_INTERNAL_FFSL\n#undef JEMALLOC_INTERNAL_FFS\n\n/*\n * popcount*() functions to use for bitmapping.\n */\n#undef JEMALLOC_INTERNAL_POPCOUNTL\n#undef JEMALLOC_INTERNAL_POPCOUNT\n\n/*\n * If defined, explicitly attempt to more uniformly distribute large allocation\n * pointer alignments across all cache indices.\n */\n#undef JEMALLOC_CACHE_OBLIVIOUS\n\n/*\n * If defined, enable logging facilities.  We make this a configure option to\n * avoid taking extra branches everywhere.\n */\n#undef JEMALLOC_LOG\n\n/*\n * If defined, use readlinkat() (instead of readlink()) to follow\n * /etc/malloc_conf.\n */\n#undef JEMALLOC_READLINKAT\n\n/*\n * Darwin (OS X) uses zones to work around Mach-O symbol override shortcomings.\n */\n#undef JEMALLOC_ZONE\n\n/*\n * Methods for determining whether the OS overcommits.\n * JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY: Linux's\n *                                         /proc/sys/vm.overcommit_memory file.\n * JEMALLOC_SYSCTL_VM_OVERCOMMIT: FreeBSD's vm.overcommit sysctl.\n */\n#undef JEMALLOC_SYSCTL_VM_OVERCOMMIT\n#undef JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY\n\n/* Defined if madvise(2) is available. */\n#undef JEMALLOC_HAVE_MADVISE\n\n/*\n * Defined if transparent huge pages are supported via the MADV_[NO]HUGEPAGE\n * arguments to madvise(2).\n */\n#undef JEMALLOC_HAVE_MADVISE_HUGE\n\n/*\n * Methods for purging unused pages differ between operating systems.\n *\n *   madvise(..., MADV_FREE) : This marks pages as being unused, such that they\n *                             will be discarded rather than swapped out.\n *   madvise(..., MADV_DONTNEED) : If JEMALLOC_PURGE_MADVISE_DONTNEED_ZEROS is\n *                                 defined, this immediately discards pages,\n *                                 such that new pages will be demand-zeroed if\n *                                 the address region is later touched;\n *                                 otherwise this behaves similarly to\n *                                 MADV_FREE, though typically with higher\n *                                 system overhead.\n */\n#undef JEMALLOC_PURGE_MADVISE_FREE\n#undef JEMALLOC_PURGE_MADVISE_DONTNEED\n#undef JEMALLOC_PURGE_MADVISE_DONTNEED_ZEROS\n\n/* Defined if madvise(2) is available but MADV_FREE is not (x86 Linux only). */\n#undef JEMALLOC_DEFINE_MADVISE_FREE\n\n/*\n * Defined if MADV_DO[NT]DUMP is supported as an argument to madvise.\n */\n#undef JEMALLOC_MADVISE_DONTDUMP\n\n/*\n * Defined if transparent huge pages (THPs) are supported via the\n * MADV_[NO]HUGEPAGE arguments to madvise(2), and THP support is enabled.\n */\n#undef JEMALLOC_THP\n\n/* Define if operating system has alloca.h header. */\n#undef JEMALLOC_HAS_ALLOCA_H\n\n/* C99 restrict keyword supported. */\n#undef JEMALLOC_HAS_RESTRICT\n\n/* For use by hash code. */\n#undef JEMALLOC_BIG_ENDIAN\n\n/* sizeof(int) == 2^LG_SIZEOF_INT. */\n#undef LG_SIZEOF_INT\n\n/* sizeof(long) == 2^LG_SIZEOF_LONG. */\n#undef LG_SIZEOF_LONG\n\n/* sizeof(long long) == 2^LG_SIZEOF_LONG_LONG. */\n#undef LG_SIZEOF_LONG_LONG\n\n/* sizeof(intmax_t) == 2^LG_SIZEOF_INTMAX_T. */\n#undef LG_SIZEOF_INTMAX_T\n\n/* glibc malloc hooks (__malloc_hook, __realloc_hook, __free_hook). */\n#undef JEMALLOC_GLIBC_MALLOC_HOOK\n\n/* glibc memalign hook. */\n#undef JEMALLOC_GLIBC_MEMALIGN_HOOK\n\n/* pthread support */\n#undef JEMALLOC_HAVE_PTHREAD\n\n/* dlsym() support */\n#undef JEMALLOC_HAVE_DLSYM\n\n/* Adaptive mutex support in pthreads. */\n#undef JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP\n\n/* GNU specific sched_getcpu support */\n#undef JEMALLOC_HAVE_SCHED_GETCPU\n\n/* GNU specific sched_setaffinity support */\n#undef JEMALLOC_HAVE_SCHED_SETAFFINITY\n\n/*\n * If defined, all the features necessary for background threads are present.\n */\n#undef JEMALLOC_BACKGROUND_THREAD\n\n/*\n * If defined, jemalloc symbols are not exported (doesn't work when\n * JEMALLOC_PREFIX is not defined).\n */\n#undef JEMALLOC_EXPORT\n\n/* config.malloc_conf options string. */\n#undef JEMALLOC_CONFIG_MALLOC_CONF\n\n/* If defined, jemalloc takes the malloc/free/etc. symbol names. */\n#undef JEMALLOC_IS_MALLOC\n\n/*\n * Defined if strerror_r returns char * if _GNU_SOURCE is defined.\n */\n#undef JEMALLOC_STRERROR_R_RETURNS_CHAR_WITH_GNU_SOURCE\n\n/* Performs additional size-matching sanity checks when defined. */\n#undef JEMALLOC_EXTRA_SIZE_CHECK\n\n#endif /* JEMALLOC_INTERNAL_DEFS_H_ */\n"
    },
    "skipped": [],
    "total_files": 315
}