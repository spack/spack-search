{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-dimemas-5.4.1-7qidutrmnfvs35qaje63pj42443shndz/spack-src/Simulator/model/communic.c": "/*****************************************************************************\\\n *                        ANALYSIS PERFORMANCE TOOLS                         *\n *                                  Dimemas                                  *\n *       Simulation tool for the parametric analysis of the behaviour of     *\n *       message-passing applications on a configurable parallel platform    *\n *                                                                           *\n *****************************************************************************\n *     ___     This library is free software; you can redistribute it and/or *\n *    /  __         modify it under the terms of the GNU LGPL as published   *\n *   /  /  _____    by the Free Software Foundation; either version 2.1      *\n *  /  /  /     \\   of the License, or (at your option) any later version.   *\n * (  (  ( B S C )                                                           *\n *  \\  \\  \\_____/   This library is distributed in hope that it will be      *\n *   \\  \\__         useful but WITHOUT ANY WARRANTY; without even the        *\n *    \\___          implied warranty of MERCHANTABILITY or FITNESS FOR A     *\n *                  PARTICULAR PURPOSE. See the GNU LGPL for more details.   *\n *                                                                           *\n * You should have received a copy of the GNU Lesser General Public License  *\n * along with this library; if not, write to the Free Software Foundation,   *\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA          *\n * The GNU LEsser General Public License is contained in the file COPYING.   *\n *                                 ---------                                 *\n *   Barcelona Supercomputing Center - Centro Nacional de Supercomputacion   *\n \\*****************************************************************************/\n\n#include <define.h>\n#include <types.h>\n#include <assert.h>\n#include <dlfcn.h>\n#include <subr.h>\n#include <float.h>\n#include <math.h>\n\n#include <communic.h>\n#include <eee_configuration.h>\n#include <eee_communic.h>\n\n\n#include <events.h>\n#include <simulator.h>\n#include <sched_vars.h>\n#include <node.h>\n#include <paraver.h>\n#include <random.h>\n#include <cpu.h>\n#include <links.h>\n#include <schedule.h>\n#include <memory.h>\n#include <cp.h>\n#include <configuration.h>\n#include <deadlock_analysis.h>\n#include <EventEncoding.h>\n#include <read.h>\n\n#include <extern.h>\n#ifdef USE_EQUEUE\n#include <listE.h>\n#else\n#include <list.h>\n#endif\n\n#ifdef VENUS_ENABLED\n#include <venusclient.h>\n#endif\n\n#define PERIODIC_TRAFFIC 10e9\n\n// For venus, 10e9 is too much\n#ifdef VENUS_ENABLED\n#define VENUS_PERIODIC_TRAFFIC 1e9\n#endif\n\n\n/******************************************************************************\n * Global variables                                                           *\n *****************************************************************************/\n\nt_boolean DATA_COPY_enabled;      /* True if data copy latency is enabled */\nint       DATA_COPY_message_size; /* Maximun message size to compute data copy\n                                   * latency */\n\nt_boolean RTT_enabled; /* True if Round Trip Time is enabled */\nt_nano   RTT_time;    /* Round Trip Time for messages greater than eager */\n\n/*\n * To compute the traffic on external network\n */\ndouble suma_missatges_xarxa_externa      = 0.0;\ndouble increment_missatges_xarxa_externa = 0.0;\n\n/*\n * To check the external traffic computation\n */\ndouble param_external_net_alfa    = 0.1;              /* Ha de ser < 1 */\ndouble param_external_net_periode = 86400000000.0;   /* En microsegons */\ndouble param_external_net_beta    = 0.0; /* Coeficients que determinen */\ndouble param_external_net_gamma   = 1.0; /* la influencia dels traffics*/\n\n/******************************************************************************\n * External communications library management\n *****************************************************************************/\n\nt_boolean external_comm_library_loaded = FALSE;\nvoid     *external_comm_library = NULL;\n\nint (* external_get_communication_type) (int sender_nodeid,\n        int receiver_nodeid,\n        int sender_taskid,\n        int receiver_taskid,\n        int mess_tag,\n        int mess_size);\n\nt_nano (* get_startup_value) (int sender_nodeid,\n        int receiver_nodeid,\n        int sender_taskid,\n        int receiver_taskid,\n        int mess_tag,\n        int mess_size);\n\nt_nano (* get_bandwidth_value) (int sender_nodeid,\n        int receiver_nodeid,\n        int sender_taskid,\n        int receiver_taskid,\n        int mess_tag,\n        int mess_size);\n\nint (* external_get_global_op_type) (int comm_id,\n        int global_op_id,\n        int bytes_send,\n        int bytes_recv);\n\nvoid (* external_compute_global_operation_time) (int     comm_id,\n        int     global_op_id,\n        int     bytes_send,\n        int     bytes_recv,\n        t_nano *latency_time,\n        t_nano *op_time);\n\n/******************************************************************************\n * MACROS per accounting del temps esperant busos                             *\n *****************************************************************************/\n#include \"task.h\"\n\n/* FEC: Macro per assignar l'inici del temps d'un thread bloquejat esperant\n * un bus */\n#define START_BUS_WAIT_TIME(thread) \\\n{ \\\n    struct t_account *account; \\\n    /* double aux; */ \\\n    account = current_account(thread); \\\n    ASS_ALL_TIMER ((account->initial_wait_bus_time), current_time); \\\n    /* \\\n       TIMER_TO_FLOAT(current_time,aux); \\\n       fprintf(stderr,\"\\nS'activa temps wait bus P%d, T%d, t%d instant: %f\\n\", \\\n       IDENTIFIERS (thread), aux); \\\n       */ \\\n}\n\n\n/* FEC: Macro per acumular el temps d'un thread bloquejat esperant un bus */\n#define ACCUMULATE_BUS_WAIT_TIME(thread) \\\n{ \\\n    dimemas_timer tmp_timer; \\\n    struct t_account *account; \\\n    /*    double aux, aux2, aux3;*/ \\\n    account = current_account(thread); \\\n    FLOAT_TO_TIMER(0,tmp_timer); \\\n    if (!EQ_TIMER((account->initial_wait_bus_time),tmp_timer)) \\\n    { \\\n        SUB_TIMER(current_time, (account->initial_wait_bus_time), tmp_timer); \\\n        ADD_TIMER (tmp_timer, (account->block_due_buses),(account->block_due_buses)); \\\n        /* \\\n           TIMER_TO_FLOAT(tmp_timer,aux); \\\n           TIMER_TO_FLOAT(current_time,aux2); \\\n           TIMER_TO_FLOAT((account->initial_wait_bus_time),aux3); \\\n           fprintf(stderr,\"\\n%f: Accumula P%d, T%d, t%d - %f = bus wait time: %f\\n\", \\\n           aux2,IDENTIFIERS (thread), aux3, aux); \\\n           */ \\\n        FLOAT_TO_TIMER(0,(account->initial_wait_bus_time)); \\\n    } \\\n}\n\n/******************************************************************************\n * CAP\u00c7ALERES DE LES FUNCIONS INTERNES                                        *\n *****************************************************************************/\n\nstatic t_nano bw_ns_per_byte (t_nano bandw);\n\nstatic void periodic_external_network_traffic_init (void);\n\nstatic void global_op_get_all_buses (struct t_thread *thread);\n\nstatic void global_op_get_all_out_links (struct t_thread *thread);\n\nstatic void global_op_get_all_in_links (struct t_thread *thread);\n\n/* void\n   close_global_communication(struct t_thread *thread); */\n\nstatic void start_global_op (struct t_thread *thread, int kind);\n\nstatic void free_global_communication_resources (struct t_thread *thread);\n\nstatic void close_global_communication (struct t_thread *thread);\nstatic void close_global_nonblock_communication(struct t_thread *thread);\n\nstatic int get_communication_type (struct t_task  *task,\n        struct t_task  *task_partner,\n        int             mess_tag,\n        int             mess_size,\n        struct t_dedicated_connection **connection);\n\nstatic int from_rank_to_taskid (struct t_communicator *comm, int root_rank);\n\nstatic t_bandwidth recompute_accelerator_bandwidth \t(struct t_thread *thread);\n\nstatic void COM_TIMER_OUT_free_accelerator_resources (struct t_thread *thread);\n\n// struct t_queue Global_op;\n\n/*\n   static t_nano compute_startup (struct t_thread               *thread,\n   int                            kind,\n   struct t_node                 *node,\n   struct t_dedicated_connection *connection);\n   */\n\nt_nano compute_startup (struct t_thread                 *thread,\n        int                              send_taskid,\n        int                              recv_taskid,\n        struct t_node                   *send_node,\n        struct t_node                   *recv_node,\n        int                              mess_tag,\n        int                              mess_size,\n        int                              kind,\n        struct t_dedicated_connection   *connection);\n\nstatic t_nano compute_copy_latency (struct t_thread *thread,\n        struct t_node   *node,\n        int              mess_size,\n        int\t\t\t\t\t\t\t mess_type);\n\nstatic dimemas_timer get_logical_receive(struct t_thread *thread,\n        struct t_queue  *irecv_not_queue,\n        int              ori,\n        int              ori_thread,\n        int              mess_tag,\n        long long int    mess_size,\n        int              communic_id,\n        dimemas_timer    stored_logical_recv);\n\n/*\n * Accelerator synchronization defines / private variables / private methods\n */\n#if 0\n#define ACCELERATOR_SYNC_ALL_THREADS -1\nstatic struct t_thread* ACCELERATOR_SYNC_host_thread;\nstatic struct t_queue   ACCELERATOR_SYNC_device_threads;\nint                     ACCELERATOR_SYNC_required_threads;\nint                     ACCELERATOR_SYNC_required_threads_count;\n#endif\n\nstatic void ACCELERATOR_check_sync_status(struct t_thread* thread,\n        t_boolean        host);\n\nstatic void calcula_temps_maxim_intra_nodes (struct t_machine      *machine,\n        struct t_communicator *communicator,\n        struct t_global_op_information *glop_info,\n        int bytes_send,   /* Number of bytes send */\n        int bytes_recvd,  /* Number of bytes received */\n        t_nano *max_tnode_in,\n        t_nano *max_lnode_in,\n        t_nano *max_tnode_out,\n        t_nano *max_lnode_out);\n\nint cmpfunc(const void *a, const void *b);\n\n/*****************************************************************************\n * Initialization/Finalization of the communications module\n ****************************************************************************/\n\nvoid COMMUNIC_Init (\n        const char * parameter_tracefile, \n        float end_analysis_tpercent)\n{\n    struct t_machine *machine;\n    size_t machines_it;\n    char *external_comm_library_name, *dlsym_error;\n\n\n    if (debug & D_COMM)\n    {\n        printf (\"-> COMMUNICATIONS initialization\\n\");\n    }\n\n    for (machines_it = 0; machines_it < Simulator.number_machines; machines_it++)\n    {\n        machine = &Machines[machines_it];\n\n        machine->network.utilization = 0;\n        machine->network.total_time_in_queue = 0;\n        ASS_ALL_TIMER (machine->network.last_actualization, current_time);\n        machine->network.curr_on_network = 0;\n        machine->communication.policy = COMMUNIC_FIFO;\n    }\n\n    if (with_deadlock_analysis)\n    {\n        struct t_Ptask * Ptask  = (struct t_Ptask *) head_queue (&Ptask_queue);\n        DEADLOCK_init_deadlock_analysis(/*Machines[0].number_of_nodes*/ \n                Ptask->tasks_count,\n                parameter_tracefile, end_analysis_tpercent);\n    }\n\n    CONFIGURATION_Load_Communications_Configuration();\n\n    /* S'inicialitza el calcul del traffic de la xarxa externa */\n    periodic_external_network_traffic_init();\n\n    /* Initialization of the possible external library */\n    if ((external_comm_library_name = getenv(\"DIMEMAS_EXTERNAL_COMM_LIBRARY\")) != NULL)\n    {\n        external_comm_library = dlopen(external_comm_library_name, RTLD_LAZY);\n\n        if (!external_comm_library)\n        {\n            warning(\"-> WARN: Unable to open external communication library %s %s\\n\",\n                    external_comm_library_name,\n                    dlerror());\n        }\n        else\n        { \n            external_get_communication_type = dlsym(\n                    external_comm_library, \n                    \"external_get_communication_type\");\n            if ((dlsym_error = dlerror()) != NULL)\n            {\n                warning(\"-> WARN: Unable to load function \\\"external_get_communication_type\\\"\"\\\n                        \" from library \\\"%s\\\": %s\\n\",\n                        external_comm_library_name,\n                        dlsym_error);\n                return;\n            }\n\n            get_startup_value = dlsym(external_comm_library, \"get_startup_value\");\n            if ((dlsym_error = dlerror()) != NULL)\n            {\n                warning(\"-> WARN: Unable to load function \\\"get_startup_value\\\" from library\"\\\n                        \" \\\"%s\\\": %s\\n\",\n                        external_comm_library_name,\n                        dlsym_error);\n                return;\n            }\n\n            get_bandwidth_value = dlsym(external_comm_library, \"get_bandwidth_value\");\n            if ((dlsym_error = dlerror()) != NULL)\n            {\n                warning(\"-> WARN: Unable to load function \\\"get_bandwidth_value\\\" from library\"\\\n                        \" \\\"%s\\\": %s\\n\",\n                        external_comm_library_name,\n                        dlsym_error);\n                return;\n            }\n\n            external_get_global_op_type = dlsym(external_comm_library, \"external_get_global_op_type\");\n            if ((dlsym_error = dlerror()) != NULL)\n            {\n                warning(\"-> WARN: Unable to load function \\\"external_get_global_op_type\\\" from\"\\\n                        \" library \\\"%s\\\": %s\\n\",\n                        external_comm_library_name,\n                        dlsym_error);\n                return;\n            }\n\n            external_compute_global_operation_time = dlsym(\n                    external_comm_library, \n                    \"external_compute_global_operation_time\");\n            if ((dlsym_error = dlerror()) != NULL)\n            {\n                warning(\"-> WARN: Unable to load function \\\"external_compute_global_\"\\\n                        \"operation_time\\\" from library \\\"%s\\\": %s\\n\",\n                        external_comm_library_name,\n                        dlsym_error);\n                return;\n            }\n\n            external_comm_library_loaded = TRUE;\n            printf (\"-> External communications modelling library loaded\\n\");\n        }\n    }\n}\n\nvoid COMMUNIC_End()\n{\n\n    struct t_Ptask  *Ptask;\n    struct t_task   *task;\n    struct t_thread *thread;\n    struct t_node   *node;\n    struct t_cpu    *cpu;\n    struct t_send   *mess_source;\n    struct t_action *action;\n    struct t_recv   *mess;\n    struct t_communicator *communicator;\n    struct t_global_op_definition * glop;\n\n    t_boolean pending_comm_msg_shown = FALSE;\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\": COMMUNIC_end called\\n\");\n    }\n\n    /* PENDING LINKS INFORMATION */\n\n    int node_id;\n    for (node_id = 0; node_id < SIMULATOR_get_number_of_nodes(); ++node_id)\n    {\n        struct t_node *node = &nodes[node_id];\n        if (count_queue (& (node->th_for_in) ) != 0)\n        {\n            if (debug & D_LINKS)\n            {\n                PRINT_TIMER (current_time);\n                printf (\n                        \": COMMUNIC_end Warning! %d threads waiting in link on node %d\\n\",\n                        count_queue (& (node->th_for_in) ),\n                        node->nodeid\n                       );\n            }\n            for (thread  = (struct t_thread *) head_queue (& (node->th_for_in) );\n                    thread != TH_NIL;\n                    thread  = (struct t_thread *) next_queue (& (node->th_for_in) ) )\n            {\n                PARAVER_Wait (0,\n                        IDENTIFIERS (thread),\n                        thread->last_paraver,\n                        current_time,\n                        PRV_WAITING_MESG_ST);\n\n                new_cp_node (thread, CP_BLOCK);\n            }\n        }\n        if (count_queue (& (node->th_for_out) ) != 0)\n        {\n            if (debug & D_LINKS)\n            {\n                PRINT_TIMER (current_time);\n                printf (\n                        \": COMMUNIC_end %d threads waiting out link on node %d\\n\",\n                        count_queue (& (node->th_for_out) ),\n                        node->nodeid\n                       );\n            }\n            for (thread  = (struct t_thread *) head_queue (& (node->th_for_out) );\n                    thread != TH_NIL;\n                    thread  = (struct t_thread *) next_queue (& (node->th_for_out) ) )\n            {\n                PARAVER_Wait (0,\n                        IDENTIFIERS (thread),\n                        thread->last_paraver, current_time,\n                        PRV_WAITING_MESG_ST);\n\n                new_cp_node (thread, CP_BLOCK);\n            }\n        }\n    }\n\n    /* PENDING COMMUNICATIONS INFORMATION */\n\n    for(Ptask  = (struct t_Ptask *) head_queue (&Ptask_queue);\n            Ptask != P_NIL;\n            Ptask  = (struct t_Ptask *) next_queue (&Ptask_queue))\n    {\n        for (communicator  = (struct t_communicator *)head_queue(&Ptask->Communicator);\n                communicator != (struct t_communicator *)0;\n                communicator  = (struct t_communicator *)next_queue(&Ptask->Communicator))\n        {\n            if (communicator->in_flight_op == TRUE)\n            {\n                size_t involved_tasks = 0;\n\n                warning(\": COMMUNIC_end: Application finished with a pending global operation\\n\");\n\n                for(thread  = (struct t_thread *)head_queue(&communicator->threads);\n                        thread != (struct t_thread *)0;\n                        thread  = (struct t_thread *)next_queue(&communicator->threads))\n                {\n                    glop = (struct t_global_op_definition *)\n                        query_prio_queue (&Global_op,\n                                (t_priority)thread->action->desc.global_op.glop_id);\n\n                    involved_tasks++;\n                }\n\n                warning(\": * %d tasks involved\\n\", involved_tasks);\n            }\n        }\n\n        size_t i;\n        for(i = 0; i < Ptask->tasks_count; i++)\n        {\n            task = &(Ptask->tasks[i]);\n\n            if (count_queue (&(task->recv)) != 0)\n            {\n                printf(\"MACHINE:%d NODE:%d\\n\", \n                        task->node->machine->id,\n                        task->node->nodeid);\n                warning (\": COMMUNIC_end: Task %02d ends with %d threads waiting to recv a message:\\n\",\n                        task->taskid,\n                        count_queue (&(task->recv)));\n\n                for(thread  = (struct t_thread *) head_queue (&(task->recv));\n                        thread != TH_NIL;\n                        thread  = (struct t_thread *) next_queue (&(task->recv)))\n                {\n                    printf (\"          * Thread %02d <-\",\n                            thread->threadid);\n                    action = thread->action;\n                    mess = &(action->desc.recv);\n\n                    printf (\"          * Sender: T%02d  t%02d, Destination T%02d  t%02d\"\\\n                            \" Tag: %02d CommId: %02d Size: %lld\\n\",\n                            mess->ori,\n                            mess->ori_thread,\n                            thread->task->taskid,\n                            thread->threadid,\n                            mess->mess_tag,\n                            mess->communic_id,\n                            mess->mess_size);\n\n                    /* Avoid the generation if this last IDLE state in 'backaground'\n                     * threads*/\n                    if (thread->original_thread)\n                    {\n                        node = get_node_of_thread (thread);\n                        cpu  = get_cpu_of_thread (thread);\n                        PARAVER_Idle(0,\n                                IDENTIFIERS (thread),\n                                thread->last_paraver,\n                                current_time);\n                    }\n                }\n            }\n\n            if (count_queue (&(task->send)) != 0)\n            {\n                printf(\"MACHINE:%d NODE:%d\\n\", \n                        task->node->machine->id,\n                        task->node->nodeid);\n                warning (\": COMMUNIC_end: Task %02d ends with %d message(s) pending to send:\\n\",\n                        task->taskid,\n                        count_queue (&(task->send)));\n\n                for(thread  = (struct t_thread *) head_queue (&(task->send));\n                        thread != TH_NIL;\n                        thread  = (struct t_thread *) next_queue (&(task->send)))\n                {\n                    /* Avoid the generation if this last IDLE state in 'backaground'\n                     * threads*/\n                    if (thread->original_thread)\n                    {\n                        node = get_node_of_thread (thread);\n                        cpu = get_cpu_of_thread (thread);\n                        PARAVER_Idle(0,\n                                IDENTIFIERS (thread),\n                                thread->last_paraver,\n                                current_time);\n                    }\n\n                    printf (\"          * Thread %02d ->\",\n                            thread->threadid);\n                    action = thread->action;\n                    // Vladimir: it has to be action->desc.send\n                    mess_source = &(action->desc.send);\n                    // mess_source = &(action->desc.recv);\n\n                    printf (\" Dest-: T%02d Tag: %02d CommId: %02d Size: %lld\\n\",\n                            mess_source->dest,\n                            mess_source->mess_tag,\n                            mess_source->communic_id,\n                            mess_source->mess_size);\n\n                }\n            }\n\n            if (count_queue (&(task->mess_recv)) != 0)\n            {\n                printf(\"MACHINE:%d NODE:%d\\n\", \n                        task->node->machine->id,\n                        task->node->nodeid);\n                warning (\": COMMUNIC_end: Task %02d ends with %d message(s) in reception queue:\\n\",\n                        task->taskid,\n                        count_queue (&(task->mess_recv)));\n\n                for(thread  = (struct t_thread *) head_queue (&(task->mess_recv));\n                        thread != TH_NIL;\n                        thread  = (struct t_thread *) next_queue (&(task->mess_recv)))\n                {\n                    action = thread->action;\n                    mess_source = &(action->desc.send);\n                    printf (\"          -> Sender: T%02d t%02d  destT%02d  destt%02d\"\\\n                            \" Tag: %02d CommId: %d Size: %lld\\n\",\n                            thread->task->taskid,\n                            thread->threadid,\n                            mess_source->dest,\n                            mess_source->dest_thread,\n                            mess_source->mess_tag,\n                            mess_source->communic_id,\n                            mess_source->mess_size);\n                }\n            }\n        }\n    }\n}\n\n/******************************************************************************\n * FUNCI\u00d3 'compute_startup'                                                   *\n *****************************************************************************/\nt_nano compute_startup (\n        struct t_thread *thread,\n        int send_taskid,\n        int recv_taskid,\n        struct t_node *send_node,\n        struct t_node *recv_node,\n        int mess_tag,\n        int mess_size,\n        int kind,\n        struct t_dedicated_connection *connection)\n{\n    t_nano startup = (t_nano) 0;\n\n    switch (kind)\n    {\n        case MEMORY_COMMUNICATION_TYPE:\n            startup  = send_node->local_startup;\n            startup += RANDOM_GenerateRandom (&randomness.memory_latency);\n            break;\n        case INTERNAL_NETWORK_COM_TYPE:\n            startup  = send_node->remote_startup;\n            startup += RANDOM_GenerateRandom (&randomness.network_latency);\n            break;\n        case EXTERNAL_NETWORK_COM_TYPE:\n            startup  = send_node->external_net_startup;\n            startup += RANDOM_GenerateRandom (\n                    &randomness.external_network_latency);\n            break;\n        case DEDICATED_CONNECTION_COM_TYPE:\n            /* Es un missatge entre dues maquines diferents per una connexio\n             * dedicada. */\n            if (connection == NULL)\n            {\n                panic (\"Error computing startup (P%02 T%02d t%02d) : void\"\\\n                        \" connection \\n\",\n                        IDENTIFIERS (thread));\n            }\n            startup = connection->startup;\n            break;\n        case EXTERNAL_MODEL_COM_TYPE:\n            /* This message will use an external modelling */\n            if (external_comm_library_loaded == FALSE)\n            {\n                panic(\"Error computing startup through the external\"\\\n                        \" library (not loaded)\\n\");\n            }\n            startup = get_startup_value(send_node->nodeid,\n                    recv_node->nodeid,\n                    send_taskid,\n                    recv_taskid,\n                    mess_tag,\n                    mess_size);\n            break;\n\n        case ACCELERATOR_COM_TYPE:\n            /*\tEs un missatge local al node, per\u00f2 entre CPU i GPU\t*/\n            if (!send_node->accelerator)\n            {\n                panic(\"Error computing accelerator comm startup \\\n                        through a non-accelerator node\\n\");\n            }\n\n            /* \n             * Differenciated memory transfers latency and configuration\n             * /launch/sync latency \n             */\n\n            if (CUDAEventEncoding_Is_CUDATransferBlock(\n                        thread->acc_in_block_event)\n                    && mess_size == 0)\n                startup = send_node->acc.startup;\n\n            else if (CUDAEventEncoding_Is_CUDATransferBlock(\n                        thread->acc_in_block_event)\n                    || OCLEventEncoding_Is_OCLTransferBlock(\n                        thread->acc_in_block_event))\n                startup = send_node->acc.memory_startup;\n\n            else\n                startup = send_node->acc.startup;\n            startup += (dimemas_timer) RANDOM_GenerateRandom(\n                    &randomness.acc_memory_latency);\n\n            break;\n\n        case NON_BLOCKING_GLOBAL_OP_COM_TYPE:\n            {\n            struct t_action* action = thread->action;\n            struct t_Ptask* Ptask = thread->task->Ptask;\n            int comm_id = action->desc.global_op.comm_id;\n            struct t_communicator* comm = locate_communicator (\n                    &Ptask->Communicator, comm_id);\n\n            t_nano inter_machine_lat = 0;\n            t_nano inter_node_lat = 0;\n            t_nano intra_node_lat = 0;\n\n            struct t_node* node=get_node_of_thread (thread);\n            struct t_machine* machine=node->machine;\n\n            // If not all of them are in the same machine, calculate the latency for\n            // the inter-machine communications.\n            //       \n            if (comm->same_machine == FALSE)\n            {\n                inter_machine_lat = node->external_net_startup;\n            }\n\n            // If not all of them are in the same node, calculate the latency for \n            // inter-node communications.\n            //\n            if (comm->same_node == FALSE)\n            {\n                inter_node_lat = node->remote_startup;\n            }\n\n            // If some tasks are sharing nodes, calculate the latency for\n            // intra-node communications.\n            //\n            if (comm->sharing_node == TRUE)\n            {\n                intra_node_lat = node->local_startup;\n            }\n\n            // Now, get the maximum latency time and return it!\n            //\n            t_nano max = 0;\n            if (inter_machine_lat > max) max = inter_machine_lat;\n            if (inter_node_lat > max) max = inter_node_lat;\n            if (intra_node_lat > max) max = intra_node_lat;\n\n            startup = max;\n            break;\n            }\n        default:\n            panic (\"Error computing startup (P%02 T%02d t%02d): unknown comm type %d\\n\",\n                    IDENTIFIERS (thread),\n                    kind);\n            break;\n    }\n\n    /* If the startup is smaller than the minimum granularity, we consider it 0,\n       to avoid possible overlapped states in Paraver generation\n       */\n    if (startup < 1)\n    {\n        startup = 0;\n    }\n\n    return (startup);\n}\n\n/******************************************************************************\n * FUNCI\u00d3 'compute_copy_time'                                                 *\n *****************************************************************************/\nt_nano compute_copy_latency (struct t_thread *thread,\n        struct t_node   *node,\n        int              mess_size,\n        int\t\t\t\t\t\t\t mess_type)\n{\n    t_nano bw;\n    t_nano copy_latency = (t_nano) 0;\n\n    // just to avoid warning for not used parameter\n    assert (thread != NULL);\n\n    if (node == NULL)\n    {\n        panic (\"Error computing copy latency: void node descriptor\\n\");\n    }\n\n    if (mess_type == ACCELERATOR_COM_TYPE)\n    {\n        if (!node->accelerator)\n        {\n            panic(\"Communication is ACCELERATOR_TYPE in a non-accelerator node\");\n        }\n        bw = bw_ns_per_byte(node->acc.bandwidth);\n    }\n    else\n    {\n        bw = bw_ns_per_byte(node->bandwidth);\n    }\n\n    copy_latency = (dimemas_timer)bw * mess_size;\n    return (copy_latency);\n}\n\nstatic dimemas_timer get_logical_receive(struct t_thread *thread,\n        struct t_queue  *irecv_not_queue,\n        int              ori,\n        int              ori_thread,\n        int              mess_tag,\n        long long int    mess_size,\n        int              communic_id,\n        dimemas_timer    stored_logical_recv)\n{\n    /* Check if the partner IRecv to detect the actual 'logical_receive'\n     * time */\n    dimemas_timer  result;\n    struct t_recv* irecv_not;\n\n    if (wait_logical_recv)\n    {\n        result = stored_logical_recv;\n    }\n    else\n    {\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": \\t\\tP%02d T%02d (t%02d) Looking for a possible IRecv notification \\n\",\n                    IDENTIFIERS (thread));\n            PRINT_TIMER(current_time);\n            printf (\n                    \": \\t\\tLookup Sender: T%02d (t%02d) Tag: %d Size: %lld Comm.Id: %d\\n\",\n                    ori,\n                    ori_thread,\n                    mess_tag,\n                    mess_size,\n                    communic_id);\n        }\n\n        for (irecv_not  = (struct t_recv*) head_queue(irecv_not_queue);\n                irecv_not != NULL;\n                irecv_not  = (struct t_recv*) next_queue(irecv_not_queue))\n        {\n            if (debug & D_COMM)\n            {\n                PRINT_TIMER (current_time);\n                printf (\n                        \": \\t\\t\\tCurrent: Sender: T%02d (t%02d) Tag: %d Size: %lld Comm.Id: %d\",\n                        irecv_not->ori,\n                        irecv_not->ori_thread,\n                        irecv_not->mess_tag,\n                        irecv_not->mess_size,\n                        irecv_not->communic_id);\n            }\n\n            if ( ((irecv_not->ori         == ori)        || (irecv_not->ori        == -1)) &&\n                    ((irecv_not->ori_thread  == ori_thread) || (irecv_not->ori_thread == -1)) &&\n                    ( irecv_not->mess_tag    == mess_tag)                                     &&\n                    ( irecv_not->communic_id == communic_id))\n            {\n                if (debug & D_COMM)\n                {\n                    printf(\" <- Found!\\n\");\n                }\n                break;\n            }\n            else\n            {\n                if (debug & D_COMM)\n                {\n                    printf(\"\\n\");\n                }\n            }\n        }\n\n        if (irecv_not != NULL)\n        {\n            if (debug & D_COMM)\n            {\n                PRINT_TIMER (current_time);\n                printf (\n                        \": \\t\\tP%02d T%02d (t%02d) IRecv notification Comm.Id: %d restored. LOGICAL RECEIVE = \",\n                        IDENTIFIERS (thread),\n                        communic_id);\n                PRINT_TIMER(irecv_not->logical_recv);\n                printf(\"\\n\");\n            }\n\n            result = irecv_not->logical_recv;\n\n            extract_from_queue(irecv_not_queue, (char*) irecv_not);\n            free(irecv_not);\n        }\n        else\n        {\n            result = stored_logical_recv;\n        }\n    }\n\n    return result;\n}\n\n/******************************************************************************\n * FUNCI\u00d3 'recompute_memory_bandwidth'                                        *\n *****************************************************************************/\nstatic t_nano recompute_memory_bandwidth (struct t_thread *thread)\n{\n    t_nano         bandw;\n    t_nano         ratio;\n    struct t_node *node;\n\n    node = get_node_of_thread (thread);\n\n    bandw  = (t_nano) node->bandwidth;\n    bandw += RANDOM_GenerateRandom (&randomness.memory_bandwidth);\n\n    // printf(\"Recompute_memory_bandwidth bandw+random = %f\\n\", bandw);\n\n    if (bandw != 0)\n    {\n        bandw = bw_ns_per_byte(bandw);\n    }\n\n    if (node->cur_memory_messages <= node->max_memory_messages)\n    {\n        ratio = 1.0;\n    }\n    else\n    {\n        ratio = ( (t_nano) node->max_memory_messages) /\n            ( (t_nano) node->cur_memory_messages);\n    }\n\n    if (ratio != 0)\n    {\n        bandw = bandw / ratio;\n    }\n    else\n    {\n        panic (\"bandw = 0 !\\n\");\n    }\n\n    /*\n       printf(\"Recompute_memory_bandwidth node->bandwidth = %f bandw = %f ratio = %f\\n\",\n       bw_ns_per_byte(node->bandwidth),\n       bandw,\n       ratio);\n       */\n    return bandw;\n}\n\n\n/******************************************************************************\n * FUNCI\u00d3 'recompute_internal_network_bandwidth'                                                *\n *****************************************************************************/\nstatic t_nano recompute_internal_network_bandwidth (struct t_thread *thread)\n{\n    t_nano bandw;\n    t_nano ratio;\n    //   t_nano interm;\n    //   struct t_thread *pending;\n    //   dimemas_timer tmp_timer;\n    //   dimemas_timer inter;\n    //   int pending_bytes;\n    //   struct t_bus_utilization *bus_utilization;\n    struct t_node    *node;\n    struct t_machine *machine;\n\n    node = get_node_of_thread (thread);\n    machine = node->machine;\n\n    bandw = (t_nano) machine->communication.remote_bandwidth;\n    bandw += RANDOM_GenerateRandom (&randomness.network_bandwidth);\n\n    if (bandw != 0)\n    {\n        bandw = (t_nano) ( (t_nano) (1e9) / (1 << 20) / bandw);\n    }\n\n    if (machine->network.curr_on_network <= machine->communication.num_messages_on_network)\n    {\n        ratio = 1.0;\n    }\n    else\n    {\n        ratio = ( (t_nano) machine->communication.num_messages_on_network) /\n            ( (t_nano) machine->network.curr_on_network);\n    }\n\n    if (ratio != 0)\n    {\n        bandw = bandw / ratio;\n    }\n    else\n    {\n        panic (\"bandw = 0 !\\n\");\n    }\n\n    /* Aixo dona problemes perque crec que recalcula temps d'events\n     * COM_TIMER_OUT_RESOURCES en lloc de COM_TIMER_OUT.\n     * De totes maneres, com que tal com esta el ratio sempre sera 1 era com\n     * si ja no s'esigues fent perque quedava sempre igual.\n\n     for (bus_utilization =\n     (struct t_bus_utilization *)\n     head_queue(&machine->network.threads_on_network);\n     bus_utilization != BU_NIL;\n     bus_utilization =\n     (struct t_bus_utilization *)\n     next_queue(&machine->network.threads_on_network)\n     )\n     {\n     if (bus_utilization->sender != thread)\n     {\n     pending = bus_utilization->sender;\n     EVENT_extract_timer (M_COM, pending, &tmp_timer);\n     SUB_TIMER (current_time, pending->last_comm.ti, inter);\n     TIMER_TO_FLOAT (inter, interm);\n     pending_bytes =\n     pending->last_comm.bytes - (interm/pending->last_comm.bandwidth);\n\n     pending->last_comm.bandwidth = bandw;\n     pending->last_comm.bytes = pending_bytes;\n     ASS_ALL_TIMER (pending->last_comm.ti, current_time);\n\n     interm = pending_bytes*bandw;\n     FLOAT_TO_TIMER (interm, tmp_timer);\n     ADD_TIMER (current_time, tmp_timer, tmp_timer);\n     pending->event =\n     EVENT_timer (tmp_timer, NOT_DAEMON, M_COM, pending, COM_TIMER_OUT);\n     }\n     }\n     *******************************************************************************/\n    return (bandw);\n}\n\n/******************************************************************************\n * PROCEDURE 'periodic_external_network_traffic_init'                         *\n *****************************************************************************/\n/*\n * Aquesta funcio inicialitza el calcul del traffic de la xarxa externa\n */\nvoid periodic_external_network_traffic_init()\n{\n\n    dimemas_timer tmp_timer;\n\n    suma_missatges_xarxa_externa      = 0.0;\n    increment_missatges_xarxa_externa = 0.0;\n\n    /* Es prepara la primera execucio de la rutina que cal executar periodicament\n     * per recalcular el traffic de la xarxa externa no produit per l'aplicacio\n     * que s'esta simulant. */\n#ifdef VENUS_ENABLED\n    if (VC_is_enabled() ) {\n        ADD_TIMER (VENUS_PERIODIC_TRAFFIC, current_time, tmp_timer); /* grodrigu: 10e6 is too much when interfaced with Venus */\n    }\n    else {\n        ADD_TIMER (PERIODIC_TRAFFIC, current_time, tmp_timer); /* grodrigu: 10e6 is too much when interfaced with Venus */\n    }\n#else\n    ADD_TIMER (PERIODIC_TRAFFIC, current_time, tmp_timer);\n#endif\n\n    EVENT_timer (tmp_timer, NOT_DAEMON, M_COM, NULL, COM_EXT_NET_TRAFFIC_TIMER);\n}\n\n/******************************************************************************\n * PROCEDURE 'recompute_external_network_traffic'                             *\n *****************************************************************************/\n/*\n * Aquesta funcio s'hauria de cridar cada vegada que s'envia un missatge nou a\n * traves de la xarxa externa.\n */\nvoid recompute_external_network_traffic (int mess_size)\n{\n    increment_missatges_xarxa_externa += mess_size;\n}\n\n/******************************************************************************\n * PROCEDURE 'recompute_external_network_traffic'                             *\n *****************************************************************************/\n/*\n * Aquesta funcio s'hauria d'executar periodicament. En principi cada 10 segons.\n */\nvoid periodic_recompute_external_network_traffic()\n{\n\n    dimemas_timer tmp_timer;\n\n    double periodic_traffic_interval = PERIODIC_TRAFFIC;\n#ifdef VENUS_ENABLED\n    if (VC_is_enabled()) {\n        periodic_traffic_interval = VENUS_PERIODIC_TRAFFIC;\n    }\n#endif\n\n    suma_missatges_xarxa_externa =\n        suma_missatges_xarxa_externa * param_external_net_alfa +\n        (increment_missatges_xarxa_externa / (periodic_traffic_interval) ) *\n        (1 - param_external_net_alfa);\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": COMMUNIC\\tPeriodic external network recompute - Tn=%.4f Inc=%.4f\\n\",\n                suma_missatges_xarxa_externa,\n                increment_missatges_xarxa_externa\n               );\n    }\n\n    increment_missatges_xarxa_externa = 0;\n\n    /*\n       PRINT_TIMER (current_time);\n       printf(\": S'ha recalculat el traffic de la xarxa externa\\n\");\n       */\n\n    /* Es prepara la seguen execucio d'aquesta rutina */\n#ifdef USE_EQUEUE\n#ifdef VENUS_ENABLED\n    if ( (top_Eevent (&Event_queue) != E_NIL) || (VC_is_enabled() && (top_Eevent (&Interactive_event_queue) != E_NIL) ) ) /* grodrigu: venus! */\n#else\n        if (top_Eevent (&Event_queue) != E_NIL)\n#endif\n#else\n#ifdef VENUS_ENABLED\n            if ( (top_event (&Event_queue) != E_NIL) || (VC_is_enabled() && (top_event (&Interactive_event_queue) != E_NIL) ) ) /* grodrigu: venus! */\n#else\n                if (top_event (&Event_queue) != E_NIL)\n#endif\n#endif\n                {\n                    /* Si queden events es que cal seguir simulant, per tant, es pot encuar\n                       aquest event. Si no en quedessin no el podriem encuar perque es\n                       seguiria simulant sense que hi hagues cap altre event que aquests. */\n#ifdef VENUS_ENABLED\n                    if (VC_is_enabled() ) {\n                        ADD_TIMER (VENUS_PERIODIC_TRAFFIC, current_time, tmp_timer); /* grodrigu: 10e6 is too much when interfaced with Venus */\n                    }\n                    else {\n                        ADD_TIMER (PERIODIC_TRAFFIC, current_time, tmp_timer); /* grodrigu: 10e6 is too much when interfaced with Venus */\n                    }\n#else\n                    ADD_TIMER (PERIODIC_TRAFFIC, current_time, tmp_timer);\n#endif\n\n                    EVENT_timer (tmp_timer, NOT_DAEMON, M_COM, NULL, COM_EXT_NET_TRAFFIC_TIMER);\n                }\n}\n\n\n/******************************************************************************\n * FUNCI\u00d3 'external_network_general_traffic'                                  *\n *****************************************************************************/\n/*\n * La funcio que defineix el comportament del traffic de la xarxa externa\n * independentment de la nostra aplicaci\u00f3 hauria de ser definida per l'usuari.\n */\ndouble external_network_general_traffic (dimemas_timer temps)\n{\n    double traffic;\n\n    // fprintf (stderr, \"\\nFunction disabled (external_network_general_traffic) because of compilation problem - Vladimir,14-07-2009!\\n\\n\");\n\n    // exit (EXIT_FAILURE);\n    // return 0;\n\n    /* traffic = (sin(aux * 2 * M_PI) + 1) / 2; /* Aqui traffic esta entre 0 i 1\n    /* Aquesta funcio ha de retornar un numero entre 0 i\n    l'ample de banda maxim de la xarxa externa.\n    traffic = traffic *\n    (Simulator.wan.bandwidth * (1 << 20) / (t_nano) (1e9));\n\n    // to avoid warning for unused parameter\n    // temps = temps;\n\n    //\n    //\n    //   /* Per fer alguna cosa hi poso aixo: */\n    //   double aux;\n    //   /* Per tenir un periode d'un dia */\n    //   unsigned long long temp1 = (unsigned long long) temps;\n    //   long temp2               = (long) param_external_net_periode;\n    //   double temp3 =  (double)(temp1 % (temp2 + 1));\n    //   aux = ((temp3) / param_external_net_periode);\n    //\n    // //  aux = ((double)(temp1 %\n    // //            (temp2 + 1)) / param_external_net_periode);\n    //\n    // //  aux = ((double)((unsigned long long) temps %\n    // //        ((long) param_external_net_periode + 1)) / param_external_net_periode);\n    //\n    //   traffic = (sin(aux * 2 * M_PI) + 1) / 2; /* Aqui traffic esta entre 0 i 1 */\n    //   /* Aquesta funcio ha de retornar un numero entre 0 i\n    //      l'ample de banda maxim de la xarxa externa. */\n    //   traffic = traffic *\n    //             (Simulator.wan.bandwidth * (1 << 20) / (t_nano) (1e9));\n    //\n    //   if (debug&D_COMM)\n    //   {\n    //     PRINT_TIMER (current_time);\n    //     printf (\n    //       \": COMMUNIC\\tExternal Network Traffic = %.4f\\n\",\n    //       traffic\n    //     );\n    //   }\n    //  return(traffic);\n\n    return 0;\n\n}\n\n/******************************************************************************\n * FUNCI\u00d3 'external_network_application_traffic'                              *\n *****************************************************************************/\n/*\n * Retorna el valor del n\u00famero de missatges a la xarxa externa\n */\n    double\nexternal_network_application_traffic()\n{\n    /* Hauria de retornar un numero a partir de suma_missatges_xarxa_externa. */\n    return (suma_missatges_xarxa_externa);\n}\n\n/******************************************************************************\n * FUNCI\u00d3 'external_network_bandwidth_ratio'                                  *\n *****************************************************************************/\n/*\n * Retorna el valor del ratio de l'ample de banda en funci\u00f3 del tr\u00e0fic\n * existent, i la modelitzaci\u00f3 del mateix\n */\ndouble external_network_bandwidth_ratio (double traffic)\n{\n    double ratio;\n\n    /* El parametre traffic pot ser mes gran que l'ample de banda\n       maxim de la xarxa externa. */\n\n    switch (Simulator.wan.traffic_function)\n    {\n        case EXP: /* Comportament Exponencial */\n            /*ratio=pow(M_E, (-5*traffic/Simulator.wan.max_traffic_value));*/\n            if (Simulator.wan.max_traffic_value != 0)\n            {\n                ratio = exp (-5 * traffic / Simulator.wan.max_traffic_value);\n            }\n            else\n            {\n                ratio = 1;\n            }\n            break;\n        case LOG: /* Comportament logaritmic */\n            if (Simulator.wan.max_traffic_value != 0)\n            {\n                ratio = log10 (10 - (10 * traffic / Simulator.wan.max_traffic_value) );\n            }\n            else\n            {\n                ratio = 1;\n            }\n            break;\n        case LINEAL: /* Comportament linial */\n            if ( (Simulator.wan.max_traffic_value != 0) && (traffic != 0) )\n            {\n                if (traffic < Simulator.wan.max_traffic_value)\n                {\n                    ratio = (Simulator.wan.max_traffic_value - traffic) /\n                        Simulator.wan.max_traffic_value;\n                }\n                else\n                {\n                    ratio = 0;\n                }\n            }\n            else\n            {\n                ratio = 1;\n            }\n            break;\n        case CONST: /* Comportament constant */\n            ratio = 1;\n            break;\n        default:\n            ratio = 1;\n            break;\n    }\n\n    /* Aquesta funcio ha de retornar un numero entre 0 i 1 */\n    return ratio;\n}\n\n\n/**\n * Adapts the available accelerator or memory bandwidth (smaller one)\n * considering the concurrent messages\n *\n * Accelerator bandwidth can be PCI-e bandwidth\n * \\param thread Thread that requires the bandwidth re-evaluation\n *\n * \\return\n */\nt_bandwidth recompute_accelerator_bandwidth (struct t_thread *thread)\n{\n    t_bandwidth bandw;\n    struct t_node *node;\n    double ratio;\n\n    node = get_node_of_thread (thread);\n    assert(node->accelerator);\n\n    bandw = node->acc.bandwidth;\n    bandw += RANDOM_GenerateRandom (&randomness.acc_memory_bandwith);\n\n    if (bandw != 0)\n    {\n        bandw = bw_ns_per_byte(bandw);\n    }\n\n    if (node->acc.cur_messages <= node->acc.max_messages)\n    {\n        ratio = 1.0;\n    }\n    else\n    {\n        ratio = ( (dimemas_timer) node->acc.max_messages) /\n            ( (dimemas_timer) node->acc.cur_messages);\n    }\n\n    if (ratio != 0)\n    {\n        bandw = bandw / ratio;\n    }\n    else\n    {\n        panic (\"bandw = 0 !\\n\");\n    }\n\n    return bandw;\n}\n\n\n/******************************************************************************\n * FUNCI\u00d3 'bw_ns_per_byte'                                           *\n *****************************************************************************/\n/*\n * Aquesta funci\u00f3 passa de Mbytes a bytes, de segons a microsegons i calcula la\n * inversa. Aixi nomes cal multiplicar per la mida del missatge per obtenir el\n * temps estimat de transferencia. El resultat sera microsegons/byte.\n */\nstatic t_nano bw_ns_per_byte (t_nano bandw)\n{\n    t_nano bandw_ms_per_byte = 0;\n\n    if (bandw != 0)\n    {\n        bandw_ms_per_byte = (t_nano) ( (t_nano) (1e9) / (1 << 20) / bandw);\n    }\n\n    return bandw_ms_per_byte;\n}\n\n/******************************************************************************\n * FUNCI\u00d3 'recompute_external_network_bandwidth'                              *\n *****************************************************************************/\n    static t_nano\nrecompute_external_network_bandwidth (struct t_thread *thread)\n{\n    t_nano bandw;\n    t_nano bandw_ms_per_byte;\n    t_nano ratio;\n\n    double traffic, traffic_indep, traffic_aplic;\n\n    //to avoid warning about the unused parameter\n    assert (thread);\n\n    /* El primer que cal fer es calcular el traffic per poder indexar la funcio\n     * que ens determinara el coeficient de l'ample de banda maxim que cal agafar\n     * (el ratio). */\n\n    /* Es calcula el traffic de la xarxa externa independent de nosaltres */\n    traffic_indep = external_network_general_traffic (current_time);\n\n    /* S'obte el traffic que hi ha a la xarxa per culpa de la propia\n       aplicacio que estem simulant */\n    traffic_aplic = external_network_application_traffic();\n\n    /* Es calcula el traffic total */\n    traffic = param_external_net_gamma * traffic_indep +\n        param_external_net_beta  * traffic_aplic;\n\n    /* Es calcula el ratio en funcio del traffic */\n    ratio = external_network_bandwidth_ratio (traffic);\n\n    /* S'obte l'ample de banda maxim */\n    bandw = (t_nano) Simulator.wan.bandwidth;\n\n    bandw += RANDOM_GenerateRandom (&randomness.external_network_bandwidth);\n\n    /* Es calcula l'ample de banda final */\n    if (ratio != 0)\n    {\n        bandw = bandw * ratio;\n    }\n    else\n    {\n        panic (\"External network ratio equals 0\\n\");\n    }\n\n    bandw_ms_per_byte = bw_ns_per_byte (bandw);\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": COMMUNIC\\tNew External Network Bandwidth = %.4f\\n\",\n                bandw_ms_per_byte\n               );\n    }\n\n    /* Aqui es recalcularien els temps estimats de totes les transferencies que\n     * s'estiguessin fent per la xarxa externa en aquest instant. Pero aixo esta\n     * desactivat perque no es vol aplicar. Nomes es vol fer que es calculi el\n     * temps estimat una vegada, al comenc,ar la comunicacio.\n     * Si es volgues recalcular aixo tambe caldria descomentar del\n     * 'really_send_external_network' on es guarden les utilitzacions de bus i del\n     * 'COMMUNIC_external_network_COM_TIMER_OUT' descomentar on s'alliberen els\n     * busos. */\n\n    return (bandw);\n}\n\n/******************************************************************************\n * FUNCI\u00d3 'locate_receiver'                                                   *\n *****************************************************************************/\n/*\n * Find a receiver thread in queue asking for mess_tag\n */\nstatic struct t_thread* locate_receiver_real_MPI_transfer (\n        struct t_queue *threads,\n        int taskid_ori,\n        int threadid_ori,\n        int dest_threadid,\n        int mess_tag,\n        int communic_id\n        )\n{\n    struct t_thread *thread;\n    struct t_action *action;\n    struct t_recv  *mess;\n\n    assert (dest_threadid == -1);\n\n    for (thread  = (struct t_thread *) head_queue (threads);\n            thread != TH_NIL;\n            thread  = (struct t_thread *) next_queue (threads))\n    {\n        action = thread->action;\n        mess   = &(action->desc.recv);\n\n        assert (mess->ori_thread == -1); // rod: True for SS?\n\n        if (((thread->threadid == dest_threadid) || (dest_threadid == -1)) &&\n                (mess->mess_tag == mess_tag) &&\n                (mess->communic_id == communic_id) &&\n                ((mess->ori == taskid_ori) || (mess->ori == -1) ) &&\n                ((mess->ori_thread == threadid_ori) || (mess->ori_thread == -1))\n           )\n        {\n            return (thread);\n        }\n    }\n    return (TH_NIL);\n}\n\nstatic struct t_thread* locate_receiver_dependencies_synchronization (\n        struct t_queue *threads,\n        int taskid_ori,\n        int threadid_ori,\n        int dest_threadid,\n        int mess_tag,\n        int communic_id)\n{\n    struct t_thread *thread;\n    struct t_action *action;\n    struct t_recv  *mess;\n\n    assert (dest_threadid != -1);\n    for (thread  = (struct t_thread *) head_queue (threads);\n            thread != TH_NIL;\n            thread  = (struct t_thread *) next_queue (threads))\n    {\n        action = thread->action;\n        mess   = & (action->desc.recv);\n        assert (mess->ori_thread != -1);\n\n        if (((thread->threadid == dest_threadid) || (dest_threadid == -1)) &&\n                (mess->mess_tag == mess_tag) &&\n                (mess->communic_id == communic_id) &&\n                ((mess->ori == taskid_ori) || (mess->ori == -1)) &&\n                ((mess->ori_thread == threadid_ori) || (mess->ori_thread == -1))\n           )\n        {\n            return (thread);\n        }\n    }\n    return (TH_NIL);\n}\n\n/******************************************************************************\n * PROCEDURE 'message_received'                                               *\n *****************************************************************************/\nstatic void message_received (struct t_thread *thread)\n{\n    struct t_node    *node, *node_partner;\n    struct t_task    *task, *task_partner;\n    struct t_thread  *thread_partner;\n    struct t_action  *action;\n    struct t_send    *mess;\n    struct t_thread  *partner;\n    struct t_account *account;\n    dimemas_timer     tmp_timer, actual_logical_recv;\n    struct t_recv    *mess_recv;\n    struct t_cpu     *cpu_partner, *cpu;\n\n    node   = get_node_of_thread (thread);\n    task   = thread->task;\n    action = thread->action;\n    mess   = & (action->desc.send);\n\n    task_partner = locate_task (task->Ptask, mess->dest);\n    node_partner = get_node_of_task (task_partner);\n\n    thread->physical_recv = current_time;\n\n    if (mess->dest_thread == -1)\n    {\n        /* real MPI transfer - we look for it at the level of tasks  */\n        partner = locate_receiver_real_MPI_transfer (&(task_partner->recv),\n                task->taskid,\n                thread->threadid,\n                mess->dest_thread,\n                mess->mess_tag,\n                mess->communic_id);\n    }\n    else\n    {\n        /* low level transfer - we look for it at the level of threads  */\n        thread_partner = locate_thread_of_task (task_partner, mess->dest_thread);\n\n        assert(thread_partner != TH_NIL);\n        partner = locate_receiver_dependencies_synchronization (& (thread_partner->recv),\n                task->taskid,\n                thread->threadid,\n                mess->dest_thread,\n                mess->mess_tag,\n                mess->communic_id);\n    }\n\n    if (partner == TH_NIL)\n    {\n        if (extra_assert)\n        {\n            size_t i;\n\n            for (i = 0; i < task_partner->threads_count; i++)\n            {\n                partner = task_partner->threads[i];\n\n                if (is_thread_running(partner) && partner->doing_busy_wait)\n                {\n                    panic (\"does this happen at all - espera activa ???? I BELIEVE NOT\\n\");\n                    action    = partner->action;\n                    mess_recv = & (action->desc.recv);\n\n                    assert (partner->task->taskid == mess->dest);\n                    assert (mess->dest > 0);\n                    if (((partner->threadid == mess->dest_thread) || (mess->dest_thread == -1)) &&\n                            (mess_recv->mess_tag == mess->mess_tag) &&\n                            (mess_recv->communic_id == mess->communic_id) &&\n                            ((mess_recv->ori == task->taskid) || (mess_recv->ori == -1)) &&\n                            ((mess_recv->ori_thread == thread->threadid) || (mess_recv->ori_thread == -1)))\n                    {\n                        partner->doing_busy_wait    = FALSE;\n                        cpu_partner                 = get_cpu_of_thread (partner);\n                        cpu_partner->current_thread = TH_NIL;\n\n                        EVENT_extract_timer (M_SCH, partner, &tmp_timer);\n\n                        PARAVER_Busy_Wait (cpu_partner->unique_number,\n                                IDENTIFIERS (partner),\n                                partner->last_paraver,\n                                current_time);\n\n                        partner->last_paraver = current_time;\n                        if (debug & D_COMM)\n                        {\n                            PRINT_TIMER (current_time);\n                            printf (\": COMMUNIC_send\\t M%02d P%02d T%02d (t%02d)\"\\\n                                    \"-> T%02d Busy Wait\\n\",\n                                        thread->task->node->machine->id,\n                                        IDENTIFIERS (thread),\n                                        mess->dest);\n                        }\n\n                        account = current_account (partner);\n                        account->n_bytes_recv += mess->mess_size;\n                        cpu = get_cpu_of_thread (thread);\n\n                        /**\n                         * Look for a possible IRecv notification!\n                         */\n                        actual_logical_recv = get_logical_receive(thread,\n                                &(task_partner->irecvs_executed),\n                                mess_recv->ori,\n                                mess_recv->ori_thread,\n                                mess_recv->mess_tag,\n                                mess_recv->mess_size,\n                                mess_recv->communic_id,\n                                partner->logical_recv);\n\n                        if (debug & D_PRV)\n                        {\n                            PRINT_TIMER(current_time);\n                            printf(\": COMMUNIC_send\\tP%02d T%02d (t%02d) Printing communication with Comm.Id: %d\\n\",\n                                    IDENTIFIERS(thread),\n                                    mess->communic_id);\n                        }\n\n                        PARAVER_P2P_Comm (cpu->unique_number,\n                                IDENTIFIERS (thread),\n                                thread->logical_send,\n                                thread->physical_send,\n                                cpu_partner->unique_number,\n                                IDENTIFIERS (partner),\n                                actual_logical_recv,\n                                thread->physical_recv,\n                                mess->mess_size,\n                                mess->mess_tag);\n\n                        partner->last_paraver = current_time;\n                        action = partner->action;\n                        partner->action = action->next;\n                        READ_free_action(action);\n\n                        if (more_actions (partner) )\n                        {\n                            partner->loose_cpu = FALSE;\n                            SCHEDULER_thread_to_ready (partner);\n                            SCHEDULER_general (SCH_NEW_JOB, partner);\n                        }\n                        /* FEC: No es pot borrar el thread aqui perque encara es necessitara\n                         * quan es retorni a la crida d'on venim. Nomes es marca com a pendent\n                         * d'eliminar i ja s'esborrara mes tard. */\n                        thread->marked_for_deletion = 1;\n                        return;\n                    }\n                }\n            }\n        }\n        /* El thread corresponent encara no esta a punt per rebre el missatge.\n         * El que cal fer es encuar el thread a la cua de missatges rebuts de\n         * la task corresponent. */\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\": COMMUNIC_send\\tP%02d T%02d (t%02d) -> T%02d Tag(%d) Receiver Not Ready\\n\",\n                    IDENTIFIERS (thread),\n                    mess->dest,\n                    mess->mess_tag);\n        }\n        if (mess->dest_thread == -1)\n        {\n            /* this is a real MPI transfer */\n            inFIFO_queue (& (task_partner->mess_recv), (char *) thread);\n        }\n        else\n        {\n            /* this is a dependency synchronization  */\n            assert (thread_partner != TH_NIL);\n            inFIFO_queue (& (thread_partner->mess_recv), (char *) thread);\n        }\n    }\n    else\n    {\n        /* El thread corresponent esta bloquejat esperant a rebre. Per tant,\n         * s'haura de desbloquejar. */\n\n        account = current_account (partner);\n        account->n_bytes_recv += mess->mess_size;\n        SUB_TIMER (current_time, partner->start_wait_for_message, tmp_timer);\n        ADD_TIMER (\n                account->time_waiting_for_message,\n                tmp_timer,\n                account->time_waiting_for_message\n                );\n\n        if (mess->dest_thread == -1)\n        {\n            /* this is a real MPI transfer - it was at the queue inside task */\n            extract_from_queue (& (task_partner->recv), (char *) partner);\n        }\n        else\n        {\n            /* this is a dependency - it was at the queue inside thread */\n            assert (thread_partner != TH_NIL);\n            extract_from_queue (& (thread_partner->recv), (char *) partner);\n        }\n\n        if (!thread->host && !thread->kernel)\n        {\n            PARAVER_Wait (0,\n                    IDENTIFIERS (partner),\n                    partner->last_paraver,\n                    current_time,\n                    PRV_WAITING_MESG_ST);\n        }\n\n        new_cp_node (partner, CP_BLOCK);\n        new_cp_relation (partner, thread);\n        cpu = get_cpu_of_thread (thread);\n        cpu_partner = get_cpu_of_thread (partner);\n\n        struct t_thread *host_th, *kernel_th;\n\n        if (thread->host)\n        {\n            if (!thread->original_thread)\n                host_th = thread->twin_thread;\n            else\n                host_th = thread;\n            kernel_th = partner;\n        }\n        else if (partner->host)\n        {\n            if (!partner->original_thread)\n                host_th = partner->twin_thread;\n            else\n                host_th = partner;\n            kernel_th = thread;\n        }\n\n        /**\n         * Look for a possible IRecv notification!\n         */\n        actual_logical_recv = get_logical_receive(thread,\n                &(partner->task->irecvs_executed),\n                thread->task->taskid,\n                thread->threadid,\n                mess->mess_tag,\n                mess->mess_size,\n                mess->communic_id,\n                partner->logical_recv);\n\n        if (debug & D_PRV)\n        {\n            PRINT_TIMER(current_time);\n            printf(\": COMMUNIC_send\\tP%02d T%02d (t%02d) Printing communication with Comm.Id: %d\\n\",\n                    IDENTIFIERS(thread),\n                    mess->communic_id);\n        }\n\n        //When host continues doing other things, the original thread is in other\n        //blocks. After a NDRangeKernel, usually in MemRead, so transf_comm = 1\n        //And because comm_id == 0, comm is sometimes not painted in NDRangeKernel\n        //To solve it, use the thread and not host_th, because can be a copy\n        //And copy state (acc_in_block_event) must be correct\n        int transf_comm =\n            CUDAEventEncoding_Is_CUDATransferBlock(thread->acc_in_block_event) ||\n            OCLEventEncoding_Is_OCLTransferBlock(thread->acc_in_block_event);\n        /* If it's a sync_comm in a CUDAMem_Cpy block in the host, is ignored */\n        int sync_comm =\tmess->communic_id == 0;\n        int cuda_comm = CUDAEventEncoding_Is_CUDAComm(mess->mess_tag);\n        int ocl_comm = OCLEventEncoding_Is_OCLComm(mess->mess_tag);\n\n        /* Paraver P2P communication has to be thrown */\n        int paraver_comm = !(sync_comm && cuda_comm && transf_comm)\n            && !(ocl_comm && sync_comm && transf_comm);\n\n        /* Partner communication loads next action */\n        int partner_next_action = !(partner->host && transf_comm && cuda_comm)\n            || ocl_comm;\n\n        /* Host will compute a startup after the communication */\n        int host_startup = !ocl_comm && (cuda_comm && transf_comm && !sync_comm);\n\n        if (paraver_comm)\n        {\n            PARAVER_P2P_Comm (cpu->unique_number,\n                    IDENTIFIERS (thread),\n                    thread->logical_send,\n                    thread->physical_send,\n                    cpu_partner->unique_number,\n                    IDENTIFIERS (partner),\n                    actual_logical_recv,\n                    thread->physical_recv,\n                    mess->mess_size,\n                    mess->mess_tag );\n            partner->last_paraver = current_time;\n        }\n\n        if (partner_next_action)\n        {\n            action          = partner->action;\n            partner->action = action->next;\n            READ_free_action(action);\n            if (more_actions (partner) )\n            {\n                partner->loose_cpu = TRUE;\n                SCHEDULER_thread_to_ready (partner);\n                SCHEDULER_general (SCH_NEW_JOB, partner);\n            }\n        }\n\n        /* FEC: No es pot borrar el thread aqui perque encara es necessitara\n           quan es retorni a la crida d'on venim. Nomes es marca com a\n           pendent d'eliminar i ja s'esborrara mes tard. */\n        if (!thread->original_thread)\n            thread->marked_for_deletion = 1;\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC_send\\tP%02d T%02d (t%02d) -> T%02d (t%02d) Tag(%d) CommID(%d) Receiver Unlocked\\n\",\n                    IDENTIFIERS (thread),\n                    mess->dest,\n                    mess->dest_thread,\n                    mess->mess_tag,\n                    mess->communic_id\n                   );\n        }\n\n        if (host_startup)\n            //If it's not a synchronization communication\n        {\n            dimemas_timer startup =\n                compute_startup (host_th,\n                        host_th->task->taskid,  /* Sender */\n                        kernel_th->task->taskid,  /* Receiver */\n                        node,\n                        node,\n                        0,\n                        0,\n                        ACCELERATOR_COM_TYPE,\n                        NULL);\n\n            if (startup != (dimemas_timer) 0)\n            {\n                host_th->loose_cpu     = FALSE;\n                //host_th->doing_startup = TRUE;\n                host_th->doing_acc_comm = TRUE;\n\n                account = current_account (host_th);\n                FLOAT_TO_TIMER (startup, tmp_timer);\n                ADD_TIMER (account->latency_time, tmp_timer, account->latency_time);\n                SUB_TIMER (account->cpu_time, tmp_timer, account->cpu_time);\n\n                dimemas_timer tmp_timer2;\n                FLOAT_TO_TIMER(current_time, tmp_timer2);\n                ADD_TIMER(tmp_timer2, tmp_timer, tmp_timer2);\n\n                host_th->event = (struct t_event*) EVENT_timer (tmp_timer2, NOT_DAEMON, M_COM, host_th, COM_TIMER_OUT);\n\n                if (debug & D_COMM)\n                {\n                    PRINT_TIMER (current_time);\n                    printf (\": COMMUNIC_SEND\\tP%02d T%02d (t%02d) Initiate end startup (%f)\\n\",\n                            IDENTIFIERS (host_th),\n                            (double) startup / 1e9);\n                }\n            }\n        }\n    }\n}\n\n/******************************************************************************\n * FUNCTION  'is_message_awaiting'                                            *\n *****************************************************************************/\nstatic t_boolean is_message_awaiting_real_MPI_transfer (struct t_task   *task,\n        struct t_recv   *mess,\n        struct t_thread *thread)\n{\n    struct t_thread  *thread_source;\n    struct t_task    *task_source;\n    struct t_action  *action;\n    struct t_send    *mess_source;\n    struct t_account *account;\n    struct t_node    *s_node, *r_node;\n    struct t_cpu     *cpu, *cpu_source;\n    t_boolean         result = FALSE, found;\n\n    assert (mess->ori_thread == -1);\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": COMMUNIC_wait/recv\\tP%02d T%02d (t%02d) <- T%02d Tag(%02d)\"\\\n                \" Size: %lld, Comm.Id: %d\\n\",\n                IDENTIFIERS (thread),\n                mess->ori,\n                mess->mess_tag,\n                mess->mess_size,\n                mess->communic_id);\n        PRINT_TIMER (current_time);\n        printf(\": COMMUNIC_wait/recv\\t**\"\\\n                \" Inspecting received messaged queue **\\n\");\n    }\n\n    found = FALSE;\n    for (thread_source = (struct t_thread *) head_queue (& (task->mess_recv) );\n            thread_source != TH_NIL && !found;\n            thread_source = (struct t_thread *) next_queue (& (task->mess_recv) ))\n    {\n        task_source = thread_source->task;\n        action      = thread_source->action;\n        mess_source = & (action->desc.send);\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": \\t\\t\\t-> Message Sender: T%02d Tag(%02d)\"\\\n                    \" Size: %lld, Comm.Id: %d\\n\",\n                    task_source->taskid,\n                    mess_source->mess_tag,\n                    mess_source->mess_size,\n                    mess_source->communic_id\n                   );\n        }\n\n        assert (mess_source->dest_thread == -1);\n        assert (mess_source->dest == thread->task->taskid);\n        if (((thread_source->threadid  == mess->ori_thread) || (mess->ori_thread == -1)) &&\n                ((task_source->taskid == mess->ori) || (mess->ori == -1)) &&\n                (mess->mess_tag == mess_source->mess_tag) &&\n                (mess->communic_id == mess_source->communic_id) &&\n                ((mess_source->dest_thread == thread->threadid) || (mess_source->dest_thread == -1)))\n        {\n            dimemas_timer actual_logical_recv;\n            account = current_account (thread);\n            account->n_bytes_recv += mess_source->mess_size;\n            extract_from_queue (&(task->mess_recv), (char *) thread_source);\n            r_node = get_node_of_thread (thread);\n            s_node = get_node_of_thread (thread_source);\n\n            SCHEDULER_info (COMMUNICATION_INFO,\n                    SCH_INFO_RECV_HIT,\n                    thread_source,\n                    thread);\n\n            cpu        = get_cpu_of_thread (thread);\n            cpu_source = get_cpu_of_thread (thread_source);\n\n            actual_logical_recv = get_logical_receive(thread,\n                    &(task->irecvs_executed),\n                    mess->ori,\n                    mess->ori_thread,\n                    mess->mess_tag,\n                    mess->mess_size,\n                    mess->communic_id,\n                    thread->logical_recv);\n\n            if (debug & D_PRV)\n            {\n                PRINT_TIMER(current_time);\n                printf(\": COMMUNIC_wait/recv\\tP%02d T%02d (t%02d) Printing communication with Comm.Id: %d\\n\",\n                        IDENTIFIERS(thread),\n                        mess_source->communic_id);\n            }\n\n            PARAVER_P2P_Comm (cpu_source->unique_number,\n                    IDENTIFIERS (thread_source),\n                    thread_source->logical_send,\n                    thread_source->physical_send,\n                    cpu->unique_number,\n                    IDENTIFIERS (thread),\n                    actual_logical_recv,\n                    thread_source->physical_recv, // The physical recv. is only annotated in the sender\n                    mess_source->mess_size,\n                    mess_source->mess_tag);\n\n            /* In order to guarantee the cyclic simulation, we have to\n               generate a special event to warn the 'prv2dim' translator the\n               communication match (the PHYSICAL_RECV side appears in the\n               middle of a computation burst) */\n\n            new_cp_relation (thread, thread_source);\n            thread->last_paraver = current_time;\n\n            delete_duplicate_thread (thread_source);\n\n            result = TRUE;\n            found  = TRUE;\n        }\n    }\n\n    if (!found)\n    {\n        /***************************************************/\n        /* Say, the asynchronous message was not received! */\n\n    }\n\n    task_source   = locate_task (task->Ptask, mess->ori);\n    /*\n     * JGG (2012/01/16): first thread\n     thread_source = (struct t_thread *) head_queue (&(task_source->threads));\n     */\n    thread_source = task_source->threads[0];\n\n    SCHEDULER_info (COMMUNICATION_INFO,\n            SCH_INFO_RECV_MISS,\n            thread_source,\n            thread);\n\n    return result;\n}\n\nstatic t_boolean is_message_awaiting_dependency_synchronization (\n        struct t_task   *task,\n        struct t_recv   *mess,\n        struct t_thread *thread\n        )\n{\n    struct t_thread  *thread_source;\n    struct t_task    *task_source;\n    struct t_action  *action;\n    struct t_send    *mess_source;\n    struct t_account *account;\n    struct t_node    *s_node, *r_node;\n    struct t_cpu     *cpu, *cpu_partner;\n    t_boolean         result = FALSE, found;\n\n    assert (mess->ori_thread != -1);\n    assert (mess->ori == task->taskid);\n\n    for ( thread_source = (struct t_thread *) head_queue (& (thread->mess_recv) ),\n            found = FALSE;\n            thread_source != TH_NIL && !found;\n            thread_source = (struct t_thread *) next_queue (& (thread->mess_recv) ) )\n    {\n        task_source = thread_source->task;\n        action      = thread_source->action;\n        mess_source = & (action->desc.send);\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC_wait/recv\\tP%02d T%02d (t%02d) <- T%02d Tag(%02d)  Size: %lld, Comm.Id: %d -  this is only matching - looking for the correct message\\n\",\n                    IDENTIFIERS (thread),\n                    task_source->taskid,\n                    mess_source->mess_tag,\n                    mess_source->mess_size,\n                    mess_source->communic_id\n                   );\n        }\n\n        assert (mess_source->dest_thread != -1);\n        assert (mess_source->dest == task->taskid);\n\n        if (((thread_source->threadid == mess->ori_thread) || (mess->ori_thread == -1)) &&\n                ((task_source->taskid == mess->ori) || (mess->ori == -1)) &&\n                (mess->mess_tag == mess_source->mess_tag) &&\n                (mess->communic_id == mess_source->communic_id) &&\n                ((mess_source->dest_thread == thread->threadid) || (mess_source->dest_thread == -1)))\n        {\n            dimemas_timer actual_logical_recv;\n            account = current_account (thread);\n            account->n_bytes_recv += mess_source->mess_size;\n            extract_from_queue (& (thread->mess_recv), (char *) thread_source);\n            s_node = get_node_of_thread (thread_source);\n            r_node = get_node_of_thread (thread);\n\n            SCHEDULER_info (\n                    COMMUNICATION_INFO,\n                    SCH_INFO_RECV_HIT,\n                    thread_source, thread\n                    );\n            cpu         = get_cpu_of_thread (thread_source);\n            cpu_partner = get_cpu_of_thread (thread);\n\n            actual_logical_recv = get_logical_receive(thread,\n                    &(thread->irecvs_executed),\n                    mess->ori,\n                    mess->ori_thread,\n                    mess->mess_tag,\n                    mess->mess_size,\n                    mess->communic_id,\n                    thread->logical_recv);\n\n            if (debug & D_PRV)\n            {\n                PRINT_TIMER(current_time);\n                printf(\": COMMUNIC_wait/recv\\tP%02d T%02d (t%02d) Printing communication with Comm.Id: %d\\n\",\n                        IDENTIFIERS(thread),\n                        mess->communic_id);\n            }\n\n            PARAVER_P2P_Comm ( cpu->unique_number,\n                    IDENTIFIERS (thread_source),\n                    thread_source->logical_send,\n                    thread_source->physical_send,\n                    cpu_partner->unique_number,\n                    IDENTIFIERS (thread),\n                    actual_logical_recv,\n                    thread_source->physical_recv,\n                    mess_source->mess_size,\n                    mess_source->mess_tag);\n\n            new_cp_relation (thread, thread_source);\n            thread->last_paraver = current_time;\n\n            delete_duplicate_thread (thread_source);\n\n            result = TRUE;\n            found  = TRUE;\n        }\n        /* else\n           printf(\"messages NOT matching\\n\");*/\n    }\n\n    task_source   = locate_task (task->Ptask, mess->ori);\n\n    /* JGG (2012/01/16): first thread\n       thread_source = (struct t_thread *) head_queue (&(task_source->threads));\n       */\n    thread_source = task_source->threads[0];\n    SCHEDULER_info (COMMUNICATION_INFO,\n            SCH_INFO_RECV_MISS,\n            thread_source,\n            thread);\n\n    return result;\n}\n\n/******************************************************************************\n * PROCEDURE 'Start_communication_if_partner_ready_for_rendez_vous'           *\n *****************************************************************************/\n\nstatic void Start_communication_if_partner_ready_for_rendez_vous_real_MPI_transfer (\n        struct t_thread *thread,\n        struct t_recv *mess)\n{\n    register struct t_thread *sender;\n    register struct t_task *task_sender;\n    struct t_send *mess_sender;\n    register struct t_action *action;\n    struct t_thread *copy_thread;\n    struct t_Ptask *Ptask;\n    int trobat;\n\n    assert (mess->ori_thread == -1);\n\n    if (mess->ori != -1)\n    {\n        task_sender = locate_task (thread->task->Ptask, mess->ori);\n        if (task_sender == T_NIL)\n        {\n            panic (\"Unable to locate task %d in Ptask %d\\n\",\n                    mess->ori,\n                    thread->task->Ptask->Ptaskid);\n        }\n        for (sender = (struct t_thread *) head_queue (& (task_sender->send) );\n                sender != TH_NIL;\n                sender = (struct t_thread *) next_queue (& (task_sender->send) ) )\n        {\n            action = sender->action;\n            mess_sender = & (action->desc.send);\n            assert (mess_sender->dest_thread == -1);\n            assert (sender->task->taskid == mess->ori);\n            assert (mess->ori >= 0);\n            assert (mess_sender->dest >= 0); \n\n            if (((sender->threadid == mess->ori_thread) || (mess->ori_thread == -1))\n                    && (mess_sender->mess_tag == mess->mess_tag)\n                    && (mess_sender->communic_id == mess->communic_id)\n                    && ((mess_sender->dest == thread->task->taskid) || (mess_sender->dest == -1))\n                    && ((mess_sender->dest_thread == thread->threadid) || (mess_sender->dest_thread == -1)))\n            {\n                break;\n            }\n        }\n    }\n    else \n    {\n        size_t tasks_it;\n        Ptask  = thread->task->Ptask;\n        trobat = FALSE;\n\n        for (tasks_it = 0; tasks_it < Ptask->tasks_count; tasks_it++)\n        {\n            task_sender = & (Ptask->tasks[tasks_it]);\n\n            for (sender = (struct t_thread *) head_queue (& (task_sender->send) );\n                    sender != TH_NIL && trobat == FALSE;\n                    sender = (struct t_thread *) next_queue (& (task_sender->send) ) )\n            {\n                action = sender->action;\n                mess_sender = & (action->desc.send);\n                assert (mess_sender->dest_thread == -1);\n                if (\n                        ( (sender->threadid         == mess->ori_thread)     || (mess->ori_thread == -1) )\n                        && ( (sender->task->taskid     == mess->ori)             || (mess->ori        == -1) )\n                        && (mess_sender->mess_tag    == mess->mess_tag)\n                        && (mess_sender->communic_id == mess->communic_id)\n                        && ( (mess_sender->dest        == thread->task->taskid) || (mess_sender->dest == -1) )\n                        && ( (mess_sender->dest_thread == thread->threadid)     || (mess_sender->dest_thread == -1) )\n                   )\n                {\n                    trobat = TRUE;\n                }\n            }\n        }\n    } \n\n    if (sender == TH_NIL)\n    {\n        return;\n    }\n\n    extract_from_queue (& (task_sender->send), (char *) sender);\n\n    if (sender->original_thread)\n    {\n        PARAVER_Wait ( 0,\n                IDENTIFIERS (sender),\n                sender->last_paraver,\n                current_time,\n                PRV_WAITING_MESG_ST );\n\n        sender->last_paraver = current_time;\n        copy_thread          = duplicate_thread (sender);\n    }\n    else\n    {\n        copy_thread = sender;\n    }\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\": RENDEZ VOUS\\tP%02d T%02d (t%02d) <- P%02d T%02d (t%02d)\\n\",\n                IDENTIFIERS (thread),\n                IDENTIFIERS (copy_thread));\n    }\n\n    ASS_ALL_TIMER (copy_thread->initial_communication_time, current_time);\n    copy_thread->last_paraver = current_time;\n    /* !!! */\n\n    really_send (copy_thread);\n\n    /* En cas que el thread sigui una copia no hi haura mes accions */\n    if (sender->original_thread)\n    {\n        action = sender->action;\n        sender->action = action->next;\n        READ_free_action(action);\n        if (more_actions (sender) )\n        {\n            sender->loose_cpu = FALSE;\n            SCHEDULER_thread_to_ready (sender);\n        }\n    }\n}\n\nstatic void Start_communication_if_partner_ready_for_rendez_vous_dependency_synchronization (\n        struct t_thread *thread,\n        struct t_recv *mess\n        )\n{\n    register struct t_thread *sender, *thread_sender;\n    struct t_send *mess_sender;\n    register struct t_action *action;\n    struct t_thread *copy_thread;\n\n    assert (mess->ori_thread != -1);\n    assert (mess->ori == thread->task->taskid);\n\n\n\n    thread_sender = locate_thread_of_task (thread->task, mess->ori_thread);\n    if (thread_sender == (struct t_thread*) T_NIL)\n    {\n        panic (\n                \"Unable to locate task %d in Ptask %d\\n\",\n                mess->ori,\n                thread->task->Ptask->Ptaskid\n              );\n    }\n\n    for (sender = (struct t_thread *) head_queue (& (thread_sender->send) );\n            sender != TH_NIL;\n            sender = (struct t_thread *) next_queue (& (thread_sender->send) ) )\n    {\n        action = sender->action;\n        mess_sender = & (action->desc.send);\n        assert (mess_sender->dest == mess->ori);\n        assert (sender->task->taskid == mess->ori);\n\n        if (\n                ( (sender->threadid         == mess->ori_thread)     || (mess->ori_thread == -1) )\n                //       &&((sender->task->taskid     == mess->ori)             || (mess->ori        == -1))\n                && (mess_sender->mess_tag    == mess->mess_tag)\n                && (mess_sender->communic_id == mess->communic_id)\n                //       &&((mess_sender->dest        == thread->task->taskid) || (mess_sender->dest == -1))\n                && ( (mess_sender->dest_thread == thread->threadid)     || (mess_sender->dest_thread == -1) )\n           )\n        {\n            break;\n        }\n    }\n\n\n    if (sender == TH_NIL)\n    {\n        /* Unable to locate a message pending of being send. Do nothing */\n        return;\n    }\n\n    assert (count_queue (& (thread_sender->send) ) > 0);\n    extract_from_queue (& (thread_sender->send), (char *) sender);\n\n    if (sender->original_thread &&\n            (CUDAEventEncoding_Is_CUDATransferBlock(sender->acc_in_block_event) ||\n             OCLEventEncoding_Is_OCLTransferBlock(thread->acc_in_block_event)))\n    {\n        sender->acc_sndr_sync = TRUE;\n    }\n\n    /*  Si el thread \u00e9s una copia \u00e9s que s'est\u00e0 fent el rendez vous en\n        un altre thread, per tant, no s'ha de generar res a la tra\u00e7a. */\n    if (sender->original_thread && (!sender->host && !sender->kernel))\n    {\n        PARAVER_Wait (\n                0,\n                IDENTIFIERS (sender),\n                sender->last_paraver,\n                current_time,\n                PRV_WAITING_MESG_ST\n                );\n        sender->last_paraver = current_time;\n    }\n\n    if (sender->original_thread && !sender->acc_sndr_sync)\n    {\n        copy_thread = duplicate_thread (sender);\n    }\n    else\n    {\t/* Accelerator case or not more actions on thread to do (duplicated) */\n        copy_thread = sender;\n    }\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": RENDEZ VOUS\\tP%02d T%02d (t%02d) <- P%02d T%02d (t%02d)\\n\",\n                IDENTIFIERS (thread),\n                IDENTIFIERS (copy_thread)\n               );\n    }\n\n    ASS_ALL_TIMER (copy_thread->initial_communication_time, current_time);\n    copy_thread->last_paraver = current_time;\n    /* !!! */\n\n    really_send (copy_thread);\n\n    /* En cas que el thread sigui una copia no hi haura mes accions */\n    /* En cas que sigui un sender en OCL o CUDA s'ha d'esperar a realitzar\n     * m\u00e9s accions a que arribi la comm al receiver per sincronisme.\n     */\n    if (!sender->acc_sndr_sync && sender->original_thread)\n    {\n        action = sender->action;\n        sender->action = action->next;\n        READ_free_action(action);\n        if (more_actions (sender) )\n        {\n            sender->loose_cpu = FALSE;\n            SCHEDULER_thread_to_ready (sender);\n        }\n    }\n}\n\n/******************************************************************************\n * FUNCTION 'COMMUNIC_memory_COM_TIMER_OUT'                                   *\n *****************************************************************************/\nstruct t_thread* COMMUNIC_memory_COM_TIMER_OUT (struct t_thread *thread)\n{\n    /* FEC: Es treu aixo per separar l'alliberaci\u00f3 dels recursos utilitzats ******\n\n       register struct t_thread *wait_thread;\n       register struct t_bus_utilization *bus_utilization;\n       struct t_node *node;\n       struct t_machine *machine;\n       int aux;\n     *****************************************************************************/\n    struct t_thread *copy_thread;\n\n\n    if (thread->original_thread)\n    {\n        copy_thread = duplicate_thread (thread);\n    }\n    /* FEC: Jo crec que actualment mai no es dona aquest cas. Aixo nomes passaria\n     * si els send realment siguesin sincrons durant la transferencia del missatge\n     * i no simplement rendez vous. Es a dir, si estiguessin implementats els\n     * casos RD_SYNC i NORD_SYNC. En aquest cas, jo crec que al final d'aquesta\n     * funcio caldria posar el thread->local_link i el thread->partner_link a\n     * L_NIL. Actualment no cal perque com que sempre es treballa amb una copia\n     * del thread, s'acaba destruint. Es a dir, actualment el thread original mai\n     * no te cap link assignat. */\n    else\n    {\n        copy_thread = thread;\n    }\n\n    switch (thread->action->action)\n    {\n        case SEND:\n            message_received (copy_thread);\n            break;\n        case MPI_OS:\n            os_completed (copy_thread);\n            break;\n    }\n\n    return (copy_thread);\n}\n\n\n/******************************************************************************\n * FUNCTION 'COMMUNIC_internal_network_COM_TIMER_OUT'                         *\n *****************************************************************************/\nstruct t_thread* COMMUNIC_internal_network_COM_TIMER_OUT (struct t_thread *thread)\n{\n    /* FEC: Es treu aixo per separar l'alliberaci\u00f3 dels recursos utilitzats ******\n\n       register struct t_thread *wait_thread;\n       register struct t_bus_utilization *bus_utilization;\n       struct t_node *node;\n       struct t_machine *machine;\n       int aux;\n     *****************************************************************************/\n    struct t_thread *copy_thread;\n\n\n    if (thread->original_thread)\n    {\n        copy_thread = duplicate_thread (thread);\n    }\n    /* FEC: Jo crec que actualment mai no es dona aquest cas. Aixo nomes passaria\n     * si els send realment siguesin sincrons durant la transferencia del missatge\n     * i no simplement rendez vous. Es a dir, si estiguessin implementats els\n     * casos RD_SYNC i NORD_SYNC. En aquest cas, jo crec que al final d'aquesta\n     * funcio caldria posar el thread->local_link i el thread->partner_link a\n     * L_NIL. Actualment no cal perque com que sempre es treballa amb una copia\n     * del thread, s'acaba destruint. Es a dir, actualment el thread original mai\n     * no te cap link assignat. */\n    else\n    {\n        copy_thread = thread;\n    }\n\n    switch (thread->action->action)\n    {\n        case SEND:\n            message_received (copy_thread);\n#ifdef VENUS_ENABLED\n            if (VC_is_enabled() ) {\n                venusmsgs_in_flight--;\n            }\n#endif\n            break;\n        case MPI_OS:\n            os_completed (copy_thread);\n            break;\n    }\n\n    return (copy_thread);\n}\n\n/******************************************************************************\n * FUNCTION 'COMMUNIC_external_network_COM_TIMER_OUT'                         *\n *****************************************************************************/\n/*\n * Aqui s'allibrerarien els busos reservats per poder recalcular els temps\n * estimats de totes les transferencies que s'estiguessin fent per la xarxa\n * externa quan comenc,a o acaba una transferencia. Pero aixo esta desactivat\n * perque no es vol aplicar. Nomes es vol fer que es calculi el temps estimat\n * una vegada, al comenc,ar la comunicacio. Si es volgues recalcular aixo tambe\n * caldria descomentar del really_send_external_network on es guarden les\n * utilitzacions de bus i del recompute_external_network_bandwidth el recalcul\n * de temps.\n */\nstruct t_thread* COMMUNIC_external_network_COM_TIMER_OUT (struct t_thread *thread)\n{\n    struct t_thread *copy_thread;\n\n    /* FEC: Es treu aixo per separar l'alliberaci\u00f3 dels recursos utilitzats\t******\n\n       register struct t_bus_utilization *bus_utilization;\n\n       for (\n       bus_utilization  = (struct t_bus_utilization *)\n       head_queue(&Simulator.wan.threads_on_network);\n       bus_utilization !=BU_NIL;\n       bus_utilization  = (struct t_bus_utilization *)\n       next_queue(&Simulator.wan.threads_on_network)\n       )\n       {\n       if (bus_utilization->sender == thread)\n       {\n       break;\n       }\n       }\n\n       if (bus_utilization == BU_NIL)\n       {\n       panic (\"Unable to locate in external network bus utilization queue\\n\");\n       }\n\n       extract_from_queue (\n       &Simulator.wan.threads_on_network,\n       (char *)bus_utilization\n       );\n       free ( bus_utilization);\n\n       if (debug&D_COMM)\n       {\n       PRINT_TIMER (current_time);\n       printf (\n       \": COMMUNIC\\tP%02d T%02d (t%02d) free local machine link\\n\",\n       IDENTIFIERS (thread)\n       );\n       }\n\n       free_machine_link (thread->local_link, thread);\n     *****************************************************************************/\n\n    if (thread->original_thread)\n    {\n        copy_thread = duplicate_thread (thread);\n    }\n    /* FEC: Jo crec que actualment mai no es dona aquest cas. Aixo nomes\n     * passaria si els send realment siguesin sincrons durant la transferencia\n     * del missatge i no simplement rendez vous. Es a dir, si estiguessin\n     * implementats els casos RD_SYNC i NORD_SYNC.\n     * En aquest cas, jo crec que al final d'aquesta funcio caldria posar el\n     * thread->local_link i el thread->partner_link a L_NIL. Actualment no\n     * cal perque com que sempre es treballa amb una copia del thread, s'acaba\n     * destruint. Es a dir, actualment el thread original mai no te cap link\n     * assignat. */\n    else\n    {\n        copy_thread = thread;\n    }\n\n    /* FEC: Es treu aixo per separar l'alliberaci\u00f3 dels recursos utilitzats ******\n\n       free_machine_link (thread->partner_link, thread);\n\n       if (debug&D_COMM)\n       {\n       PRINT_TIMER (current_time);\n       printf (\n       \": COMMUNIC\\tP%02d T%02d (t%02d) Free Remote Machine Link\\n\",\n       IDENTIFIERS (thread)\n       );\n       }\n\n     *****************************************************************************/\n\n    switch (thread->action->action)\n    {\n        case SEND:\n            message_received (copy_thread);\n            break;\n        case MPI_OS:\n            os_completed (copy_thread);\n            break;\n    }\n\n    /* FEC: Es treu aixo per separar l'alliberaci\u00f3 dels recursos utilitzats ******\n\n       recompute_external_network_bandwidth(thread);\n\n     *****************************************************************************/\n\n    /* Caldria mirar aqui alguna cosa per activar algun thread? */\n\n    return (copy_thread);\n}\n\n\n\n/******************************************************************************\n * FUNCTION 'COMMUNIC_dedicated_connection_COM_TIMER_OUT'                     *\n *****************************************************************************/\nstruct t_thread* COMMUNIC_dedicated_connection_COM_TIMER_OUT (struct t_thread *thread)\n{\n    struct t_thread *copy_thread;\n\n    /* FEC: Es treu aixo per separar l'alliberaci\u00f3 dels recursos utilitzats ******\n\n       free_connection_link (thread->local_link, thread);\n\n       if (debug&D_COMM)\n       {\n       PRINT_TIMER (current_time);\n       printf (\n       \": COMMUNIC\\tP%02d T%02d (t%02d) Free Local Connection Link\\n\",\n       IDENTIFIERS (thread)\n       );\n       }\n     *****************************************************************************/\n\n    if (thread->original_thread)\n    {\n        copy_thread = duplicate_thread (thread);\n    }\n    /* FEC: Jo crec que actualment mai no es dona aquest cas. Aixo nomes\n     * passaria si els send realment siguesin sincrons durant la transferencia\n     * del missatge i no simplement rendez vous. Es a dir, si estiguessin\n     * implementats els casos RD_SYNC i NORD_SYNC.\n     * En aquest cas, jo crec que al final d'aquesta funcio caldria posar el\n     * thread->local_link i el thread->partner_link a L_NIL. Actualment no\n     * cal perque com que sempre es treballa amb una copia del thread, s'acaba\n     * destruint. Es a dir, actualment el thread original mai no te cap link\n     * assignat. */\n    else\n    {\n        copy_thread = thread;\n    }\n\n    /* FEC: Es treu aixo per separar l'alliberaci\u00f3 dels recursos utilitzats ******\n\n       free_connection_link (thread->partner_link, thread);\n\n       if (debug&D_COMM)\n       {\n       PRINT_TIMER (current_time);\n       printf (\n       \": COMMUNIC\\tP%02d T%02d (t%02d) Free Remote Connection Link\\n\",\n       IDENTIFIERS (thread)\n       );\n       }\n     *****************************************************************************/\n\n    switch (thread->action->action)\n    {\n        case SEND:\n            message_received (copy_thread);\n            break;\n        case MPI_OS:\n            os_completed (copy_thread);\n            break;\n    }\n\n    /* Caldria mirar aqui alguna cosa per activar algun thread? */\n\n    return (copy_thread);\n}\n\n\n/******************************************************************************\n * PROCEDURE 'COMMUNIC_COM_TIMER_OUT'                                         *\n *****************************************************************************/\nvoid COMMUNIC_COM_TIMER_OUT (struct t_thread *thread)\n{\n    struct t_action *action;\n    struct t_thread *copy_thread;\n\n    if (thread->original_thread && !thread->doing_acc_comm)\n    {\n        copy_thread = duplicate_thread (thread);\n    }\n    /* FEC: Jo crec que actualment mai no es d\u00f3na aquest cas. Aixo nomes passaria\n     * si els send realment siguesin sincrons durant la COMMUNIC_tx del missatge\n     * i no simplement rendez vous. Es a dir, si estiguessin implementats els\n     * casos RD_SYNC i NORD_SYNC. En aquest cas, jo crec que al final d'aquesta\n     * funcio caldria posar el thread->local_link i el thread->partner_link a\n     * L_NIL. Actualment no cal perque com que sempre es treballa amb una copia\n     * del thread, s'acaba destruint. Es a dir, actualment el thread original mai\n     * no te cap link assignat. */\n    else\n    {\n        copy_thread = thread;\n    }\n\n    switch (thread->action->action)\n    {\n        case SEND:\n            if (thread->doing_acc_comm)\n            {\n                thread->doing_acc_comm = FALSE;\n                break;\n            }\n            message_received (copy_thread);\n            break;\n        case MPI_OS:\n            os_completed (copy_thread);\n            break;\n        case GLOBAL_OP:\n\n        case RECV:\n            if (thread->doing_acc_comm)\n            {\n                thread->doing_acc_comm = FALSE;\n            }\n            break;\n        default:\n            break;\n    }\n\n    if ( (thread->acc_sndr_sync && !thread->doing_acc_comm) ||\n            (thread->original_thread && !thread->doing_acc_comm) )\n    {\n        thread->acc_sndr_sync\t= FALSE;\n        action         \t\t\t\t= thread->action;\n        thread->action\t= action->next;\n        READ_free_action(action);\n\n        if (more_actions (thread) )\n        {\n            thread->loose_cpu = FALSE;\n            SCHEDULER_thread_to_ready (thread);\n        }\n    }\n\n    else if (!thread->original_thread)\n    {\n        /* FEC: Com que al P2P_message_received no es pot eliminar el thread, si cal,\n         * s'ha de fer aqui. */\n        if (thread->marked_for_deletion)\n        {\n            delete_duplicate_thread (thread);\n        }\n    }\n}\n\n/******************************************************************************\n * PROCEDURE 'COMMUNIC_mem_resources_COM_TIMER_OUT'                           *\n *****************************************************************************/\n\nstatic void COMMUNIC_mem_resources_COM_TIMER_OUT (struct t_thread *thread)\n{\n    register struct t_thread          *wait_thread;\n    register struct t_bus_utilization *bus_utilization;\n    struct t_node                     *node;\n    struct t_machine                  *machine;\n\n    int aux;\n\n    node    = get_node_of_thread (thread);\n    machine = node->machine;\n\n    if (node->max_memory_messages != 0)\n    {\n        for (\n                bus_utilization  = (struct t_bus_utilization *)\n                head_queue (&node->threads_in_memory);\n                bus_utilization != BU_NIL;\n                bus_utilization  = (struct t_bus_utilization *)\n                next_queue (&node->threads_in_memory)\n            )\n        {\n            if (bus_utilization->sender == thread) break;\n        }\n\n        if (bus_utilization == BU_NIL)\n        {\n            abort();\n            panic (\"Unable to locate in memory bus utilization queue\\n\");\n        }\n\n        extract_from_queue (&node->threads_in_memory, (char*) bus_utilization);\n\n        free (bus_utilization);\n    }\n\n    if (thread->local_link != L_NIL)\n    {\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC\\tP%02d T%02d (t%02d) Free memory writing permissions (OUT)\\n\",\n                    IDENTIFIERS (thread)\n                   );\n        }\n\n        LINKS_free_mem_link(thread->local_link, thread);\n    }\n\n    if (thread->partner_link != L_NIL)\n    {\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\": COMMUNIC\\tP%02d T%02d (t%02d) Free memory writing permissions (IN)\\n\",\n                    IDENTIFIERS (thread) );\n        }\n\n        LINKS_free_mem_link(thread->partner_link, thread);\n    }\n\n    if (node->cur_memory_messages > 0)\n    {\n        node->cur_memory_messages--;\n    }\n\n    recompute_memory_bandwidth (thread);\n\n    if ( (node->max_memory_messages != 0) && (count_queue (&node->wait_for_mem_bus) > 0)\n       )\n    {\n        wait_thread = (struct t_thread *) head_queue (&node->wait_for_mem_bus);\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC\\tP%02d T%02d (t%02d) Obtain Bus\\n\",\n                    IDENTIFIERS (wait_thread)\n                   );\n        }\n\n        //    printf(\"\\nResources are freed and now I should take the network for the pending transfer P%d, T%d t%d  action == %d\\n\\n\", IDENTIFIERS (wait_thread), wait_thread->action->action);\n\n        switch (wait_thread->action->action)\n        {\n            case SEND:\n            case WAIT_FOR_SEND:\n                /* FEC: S'acumula el temps que ha estat esperant busos */\n                ACCUMULATE_BUS_WAIT_TIME (wait_thread);\n\n                extract_from_queue (&node->wait_for_mem_bus, (char *) wait_thread);\n                //        printf(\"\\nAGAIN THE REALLY_SEND FOR THE WAIT_THREAD   P%d, T%d t%d\\n\\n\", IDENTIFIERS (wait_thread));\n                really_send (wait_thread);\n                break;\n\n            case MPI_OS:\n                /* FEC: S'acumula el temps que ha estat esperant busos */\n                ACCUMULATE_BUS_WAIT_TIME (wait_thread);\n\n                extract_from_queue (&node->wait_for_mem_bus, (char *) wait_thread);\n                really_RMA (wait_thread);\n                break;\n            case GLOBAL_OP:\n                /* aux sempre hauria de ser 1 */\n                aux = node->max_memory_messages - node->cur_memory_messages;\n                wait_thread->number_buses += aux;\n                node->cur_memory_messages += aux;\n\n                if (wait_thread->number_buses == node->max_memory_messages)\n                {\n                    /* FEC: S'acumula el temps que ha estat esperant busos */\n                    ACCUMULATE_BUS_WAIT_TIME (wait_thread);\n\n                    extract_from_queue (&node->wait_for_mem_bus, (char *) wait_thread);\n                    global_op_get_all_buses (wait_thread);\n                }\n                break;\n        }\n    }\n\n    return;\n}\n\n\n/******************************************************************************\n * PROCEDURE 'COMMUNIC_internal_resources_COM_TIMER_OUT'                      *\n *****************************************************************************/\n/*\n * Alliberaci\u00f3 dels recursos d'una comunicaci\u00f3 punt a punt\n */\nstatic void COMMUNIC_internal_resources_COM_TIMER_OUT (struct t_thread *thread)\n{\n    register struct t_thread          *wait_thread;\n    register struct t_bus_utilization *bus_utilization;\n    struct t_node                     *node;\n    struct t_machine                  *machine;\n\n    int aux;\n\n    node    = get_node_of_thread (thread);\n    machine = node->machine;\n\n    if (machine->communication.num_messages_on_network)\n    {\n        for (\n                bus_utilization  = (struct t_bus_utilization *)\n                head_queue (&machine->network.threads_on_network);\n                bus_utilization != BU_NIL;\n                bus_utilization  = (struct t_bus_utilization *)\n                next_queue (&machine->network.threads_on_network)\n            )\n        {\n            if (bus_utilization->sender == thread) break;\n        }\n\n        if (bus_utilization == BU_NIL)\n        {\n            panic (\"Unable to locate in bus utilization queue\\n\");\n        }\n\n        extract_from_queue (\n                &machine->network.threads_on_network,\n                (char *) bus_utilization\n                );\n\n        free (bus_utilization);\n    }\n\n    if (thread->local_link != L_NIL)\n    {\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC\\tP%02d T%02d (t%02d) Free Local Link\\n\",\n                    IDENTIFIERS (thread)\n                   );\n        }\n\n        LINKS_free_network_link(thread->local_link, thread);\n    }\n\n    if (thread->partner_link != L_NIL)\n    {\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\": COMMUNIC\\tP%02d T%02d (t%02d) Free Remote Link\\n\",\n                    IDENTIFIERS (thread) );\n        }\n\n        LINKS_free_network_link(thread->partner_link, thread);\n    }\n\n    if (machine->network.curr_on_network > 0)\n    {\n        machine->network.curr_on_network--;\n    }\n\n    recompute_internal_network_bandwidth (thread);\n\n    if ( (machine->communication.num_messages_on_network) &&\n            (count_queue (&machine->network.queue) > 0)\n       )\n    {\n        wait_thread = (struct t_thread *) head_queue (&machine->network.queue);\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC\\tP%02d T%02d (t%02d) Obtain Bus\\n\",\n                    IDENTIFIERS (wait_thread)\n                   );\n        }\n\n        //    printf(\"\\nResources are freed and now I should take the network for the pending transfer P%d, T%d t%d  action == %d\\n\\n\", IDENTIFIERS (wait_thread), wait_thread->action->action);\n\n        switch (wait_thread->action->action)\n        {\n            case SEND:\n            case WAIT_FOR_SEND:\n                /* FEC: S'acumula el temps que ha estat esperant busos */\n                ACCUMULATE_BUS_WAIT_TIME (wait_thread);\n\n                extract_from_queue (&machine->network.queue, (char *) wait_thread);\n                //        printf(\"\\nAGAIN THE REALLY_SEND FOR THE WAIT_THREAD   P%d, T%d t%d\\n\\n\", IDENTIFIERS (wait_thread));\n                really_send (wait_thread);\n                break;\n\n            case MPI_OS:\n                /* FEC: S'acumula el temps que ha estat esperant busos */\n                ACCUMULATE_BUS_WAIT_TIME (wait_thread);\n\n                extract_from_queue (&machine->network.queue, (char *) wait_thread);\n                really_RMA (wait_thread);\n                break;\n            case GLOBAL_OP:\n                /* aux sempre hauria de ser 1 */\n                aux = machine->communication.num_messages_on_network -\n                    machine->network.curr_on_network;\n                wait_thread->number_buses += aux;\n                machine->network.curr_on_network += aux;\n\n                if (wait_thread->number_buses ==\n                        machine->communication.num_messages_on_network\n                   )\n                {\n                    /* FEC: S'acumula el temps que ha estat esperant busos */\n                    ACCUMULATE_BUS_WAIT_TIME (wait_thread);\n\n                    extract_from_queue (&machine->network.queue, (char *) wait_thread);\n                    global_op_get_all_buses (wait_thread);\n                }\n                break;\n        }\n    }\n    return;\n}\n\n/******************************************************************************\n * PROCEDURE 'COMMUNIC_internal_resources_COM_TIMER_OUT'                      *\n *****************************************************************************/\nstatic void COMMUNIC_external_resources_COM_TIMER_OUT (struct t_thread *thread)\n{\n    /* Aqui s'allibrerarien els busos reservats per poder recalcular els\n     * temps estimats de totes les transferencies que s'estiguessin fent\n     * per la xarxa externa quan comenc,a o acaba una transferencia. Pero\n     * aixo esta desactivat perque no es vol aplicar. Nomes es vol fer que\n     * es calculi el temps estimat una vegada, al comenc,ar la comunicacio.\n     * Si es volgues recalcular aixo tambe caldria descomentar del\n     * really_send_external_network on es guarden les utilitzacions de bus\n     * i del recompute_external_network_bandwidth el recalcul de temps.\n\n     register struct t_bus_utilization *bus_utilization;\n\n     for (\n     bus_utilization  = (struct t_bus_utilization *)\n     head_queue(&Simulator.wan.threads_on_network);\n     bus_utilization != BU_NIL;\n     bus_utilization  = (struct t_bus_utilization *)\n     next_queue(&Simulator.wan.threads_on_network)\n     )\n     {\n     if (bus_utilization->sender==thread) break;\n     }\n     if (bus_utilization==BU_NIL)\n     {\n     panic (\"Unable to locate in external network bus utilization queue\\n\");\n     }\n\n     extract_from_queue (\n     &Simulator.wan.threads_on_network,\n     (char *)bus_utilization\n     );\n     free (bus_utilization);\n     *****************************************************************************/\n\n    LINKS_free_wan_link(thread->local_link, thread);\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": COMMUNIC\\tP%02d T%02d (t%02d) Free Local Machine Link\\n\",\n                IDENTIFIERS (thread)\n               );\n    }\n\n    LINKS_free_wan_link(thread->partner_link, thread);\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": COMMUNIC\\tP%02d T%02d (t%02d) Free Remote Machine Link\\n\",\n                IDENTIFIERS (thread)\n               );\n    }\n\n    recompute_external_network_bandwidth (thread);\n}\n\n/******************************************************************************\n * PROCEDURE 'COMMUNIC_dedicated_resources_COM_TIMER_OUT'                     *\n *****************************************************************************/\nstatic void COMMUNIC_dedicated_resources_COM_TIMER_OUT (struct t_thread *thread)\n{\n    LINKS_free_dedicated_connection_link(thread->local_link, thread);\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": COMMUNIC\\tP%02d T%02d (t%02d) Free Local Connection Link\\n\",\n                IDENTIFIERS (thread)\n               );\n    }\n\n    LINKS_free_dedicated_connection_link(thread->partner_link, thread);\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": COMMUNIC\\tP%02d T%02d (t%02d) Free Remote Connection Link\\n\",\n                IDENTIFIERS (thread)\n               );\n    }\n}\n\n/**\n * Frees the accelerator resources used by the calling thread\n *\n * \\param thread The thread that with the resources to be freed\n */\nstatic void COM_TIMER_OUT_free_accelerator_resources (struct t_thread *thread)\n{\n\n    struct t_node \t*node;\n    register struct t_bus_utilization *bus_utilization;\n    struct t_thread\t*wait_thread;\n    int aux;\n\n    node = get_node_of_thread (thread);\n    assert(node->accelerator);\n\n    if (node->acc.max_messages != 0)\n    {\n        for (bus_utilization  = (struct t_bus_utilization *)\n                head_queue (&node->acc.threads_in_link);\n                bus_utilization != BU_NIL;\n                bus_utilization  = (struct t_bus_utilization *)\n                next_queue (&node->acc.threads_in_link))\n        {\n            if (bus_utilization->sender == thread) break;\n        }\n\n        if (bus_utilization == BU_NIL)\n        {\n            panic (\"Unable to locate in bus utilization queue\\n\");\n        }\n\n        extract_from_queue (&node->acc.threads_in_link, (char*) bus_utilization);\n\n        free (bus_utilization);\n    }\n\n    thread->accelerator_link = L_NIL;\n\n    if (thread->local_link != L_NIL && thread->partner_link != L_NIL)\n    {\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC\\tP%02d T%02d (t%02d) Free accelerator \"\\\n                    \" writing permissions (OUT)\\n\",\n                    IDENTIFIERS (thread)\n                   );\n        }\n\n        LINKS_free_acc_link(thread->local_link, thread);\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC\\tP%02d T%02d (t%02d) Free accelerator \" \\\n                    \"writing permissions (IN)\\n\",\n                    IDENTIFIERS (thread) );\n        }\n\n        LINKS_free_acc_link(thread->partner_link, thread);\n    }\n\n    if (node->acc.cur_messages > 0)\n    {\n        node->acc.cur_messages--;\n    }\n\n    recompute_accelerator_bandwidth(thread);\n\n    if ((node->acc.max_messages != 0) && count_queue (&node->acc.wait_for_link) > 0)\n    {\n        wait_thread = (struct t_thread *) head_queue (&node->acc.wait_for_link);\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC\\tP%02d T%02d (t%02d) Obtain Bus\\n\",\n                    IDENTIFIERS (wait_thread)\n                   );\n        }\n\n        switch (wait_thread->action->action)\n        {\n            case SEND:\n            case WAIT_FOR_SEND:\n                /* FEC: S'acumula el temps que ha estat esperant busos */\n                ACCUMULATE_BUS_WAIT_TIME (wait_thread);\n\n                extract_from_queue (&node->acc.wait_for_link, (char *) wait_thread);\n                //        printf(\"\\nAGAIN THE REALLY_SEND FOR THE WAIT_THREAD   P%d, T%d t%d\\n\\n\", IDENTIFIERS (wait_thread));\n                really_send (wait_thread);\n                break;\n\n                /*case MPI_OS:\n                /* FEC: S'acumula el temps que ha estat esperant busos */\n                /*COMMUNIC_accumulate_bus_wait_time (wait_thread);\n\n                  extract_from_queue (&node->wait_for_acc_link, (char *) wait_thread);\n                  really_RMA (wait_thread);\n                  break;*/\n            case GLOBAL_OP:\n                /* aux sempre hauria de ser 1 */\n                aux = node->acc.max_messages - node->acc.cur_messages;\n                wait_thread->number_buses += aux;\n                node->acc.cur_messages += aux;\n\n                if (wait_thread->number_buses == node->acc.max_messages)\n                {\n                    /* FEC: S'acumula el temps que ha estat esperant busos */\n                    ACCUMULATE_BUS_WAIT_TIME (wait_thread);\n\n                    extract_from_queue (&node->acc.wait_for_link, (char *) wait_thread);\n                    global_op_get_all_buses (wait_thread);\n                }\n                break;\n        }\n    }\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": COMMUNIC\\tP%02d T%02d (t%02d) Free Accelerator Link\\n\",\n                IDENTIFIERS (thread)\n               );\n    }\n\n    return;\n}\n\n/******************************************************************************\n * PROCEDURE 'COMMUNIC_resources_COM_TIMER_OUT'                               *\n *****************************************************************************/\nvoid COMMUNIC_resources_COM_TIMER_OUT (struct t_thread *thread)\n{\n    if ((thread->partner_link == L_NIL) && (thread->local_link == L_NIL) && thread->accelerator_link != L_NIL)\n    {\n        COM_TIMER_OUT_free_accelerator_resources (thread);\n        return;\n    }\n\n    if ( (thread->partner_link == L_NIL) && (thread->local_link == L_NIL) )\n    {\n        /* It is a self-message! */\n        COMMUNIC_mem_resources_COM_TIMER_OUT (thread);\n        return;\n    }\n\n    /* Si estem aqui es que es una comunicacio entre nodes o entre maquines */\n    /* Per saber el tipus de comunicacio nomes cal que mirem el tipus de\n       qualsevol dels dos links: */\n    switch (thread->local_link->kind)\n    {\n        case MEM_LINK:\n            COMMUNIC_mem_resources_COM_TIMER_OUT (thread);\n            break;\n\n        case NODE_LINK:\n            COMMUNIC_internal_resources_COM_TIMER_OUT (thread);\n            break;\n\n        case MACHINE_LINK:\n            COMMUNIC_external_resources_COM_TIMER_OUT (thread);\n            break;\n\n        case CONNECTION_LINK:\n            COMMUNIC_dedicated_resources_COM_TIMER_OUT (thread);\n            break;\n\n        case ACCELERATOR_LINK:\n            COM_TIMER_OUT_free_accelerator_resources (thread);\n            break;\n\n        default:\n            panic (\"Unknown link type!\\n\");\n    }\n    /***** FEC: Fi alliberaci\u00f3 dels recursos d'una comunicaci\u00f3 punt a punt ******/\n}\n\nvoid COMMUNIC_general (int value, struct t_thread *thread)\n{\n    switch (value)\n    {\n        case RMA_TIMER_OUT:\n        case COM_TIMER_OUT:\n            COMMUNIC_COM_TIMER_OUT (thread);\n            break;\n\n        case COM_TIMER_OUT_RESOURCES_MEM:\n            COMMUNIC_mem_resources_COM_TIMER_OUT(thread);\n            break;\n        case COM_TIMER_OUT_RESOURCES_NET:\n            COMMUNIC_internal_resources_COM_TIMER_OUT(thread);\n            break;\n        case COM_TIMER_OUT_RESOURCES_WAN:\n            COMMUNIC_external_resources_COM_TIMER_OUT(thread);\n            break;\n        case COM_TIMER_OUT_RESOURCES_DED:\n            //COMMUNIC_dedicated_connection_COM_TIMER_OUT(thread);\n            COMMUNIC_dedicated_resources_COM_TIMER_OUT(thread);\n            break;\n        case COM_TIMER_OUT_RESOURCES_ACC:\n            COM_TIMER_OUT_free_accelerator_resources (thread);\n            break;\n\n            /*\n               case COM_TIMER_OUT_RESOURCES:\n            /* L'operaci\u00f3 punt a punt encara no s'ha acabat, per\u00f2 ja es poden\n            alliberar els recursos que t\u00e9 reservats. *\n            COMMUNIC_resources_COM_TIMER_OUT (thread);\n            break;\n            */\n        case COM_TIMER_GROUP_RESOURCES:\n            /* L'operaci\u00f3 col.lectiva encara no s'ha acabat, per\u00f2 ja es poden\n               alliberar els recursos que t\u00e9 reservats. */\n            free_global_communication_resources (thread);\n            break;\n\n        case COM_TIMER_GROUP:\n            /* The global operation is completed, restart blocked threads */\n            if (thread->action->desc.global_op.synch_type == GLOBAL_OP_ASYN)\n            {\n                close_global_nonblock_communication(thread);\n            }\n            else\n            {\n                close_global_communication (thread);\n            }\n            break;\n\n        case COM_EXT_NET_TRAFFIC_TIMER:\n            periodic_recompute_external_network_traffic();\n            break;\n        default:\n            panic (\"Incorrect command %d to routine COMMUNIC_general\\n\", value);\n    }\n}\n\n\n/******************************************************************************\n * PROCEDURE 'COMMUNIC_recv_reached                                           *\n * \u00daLTIMA MODIFICACI\u00d3N: 29/10/2004 (Juan Gonz\u00e1lez Garc\u00eda)                     *\n *****************************************************************************/\n/* Serveix per indicar que s'ha arribat a un recv/Irecv. Cal comprovar si\n * s'havia arribat al send corresponent i actuar en consequencia. Si es troba\n * que s'ha fet un Send SINCRON corresponent a aquest Irecv, es retorna 1 per\n * indicar que cal desbloquejar el send immediatament. En cas contrari es\n * retorna 0.\n */\nint COMMUNIC_recv_reached_real_MPI_transfer (struct t_thread *thread,\n        struct t_recv   *mess)\n{\n    struct t_task   *task, *source_task;\n    struct t_thread *partner_send;\n    struct t_action *action;\n    struct t_send   *mess_send;\n    struct t_thread *copia_thread;\n    int              res   = 0;\n\n    assert (mess->ori_thread == -1);\n    task = thread->task;\n    for (\n            partner_send  = (struct t_thread *) head_queue (& (task->send_without_recv) );\n            partner_send != TH_NIL;\n            partner_send  = (struct t_thread *) next_queue (& (task->send_without_recv) )\n        )\n    {\n        source_task = partner_send->task;\n        action      = partner_send->action;\n        mess_send   = &(action->desc.send);\n\n        assert (mess_send->dest_thread == -1);\n        assert (mess_send->dest == thread->task->taskid);\n        /* JGG (2012/01/18): now, internal structures are indexed from 0 to n-1\n           assert(mess_send->dest > 0); */\n        if ( ( (partner_send->threadid     == mess->ori_thread)     || (mess->ori_thread == -1) )  &&\n                ( (partner_send->task->taskid == mess->ori)            || (mess->ori == -1) )         &&\n                (mess_send->mess_tag        == mess->mess_tag)                                     &&\n                (mess_send->communic_id     == mess->communic_id)                                  &&\n                /*    ((mess_send->dest            == thread->task->taskid) || (mess_send->dest == -1))   &&   */\n                ( (mess_send->dest_thread     == thread->threadid)     || (mess_send->dest_thread == -1) ) )\n        {\n            /* Ja s'havia arribat al send corresponent */\n            break;\n        }\n    }\n\n    if (partner_send != TH_NIL)\n    {\n        /* Cal comprovar si el Send corresponent era realment sincron o no */\n        if (mess_send->rendez_vous)\n        {\n            /* Caldra retornar que s'ha trobat un Send corresponent que era SINCRON,\n             * per tant, caldra desbloquejar aquest send abans d'arribar al wait. */\n            res = 1;\n        }\n        /* Ja s'havia arribat al send corresponent, per tant, cal treure'l de la\n         * cua de sends sense el recv que li correspon */\n        extract_from_queue (& (task->send_without_recv), (char *) partner_send);\n        /* Cal carregar-se aquest thread perque nomes era una copia per informar\n         * que s'havia arribat a aquest send */\n        delete_duplicate_thread (partner_send);\n    }\n    else\n    {\n        /* S'ha arribat a un recv o Irecv sense que s'hagi arribat al send que li\n         * correspon. Per tant, cal encuar una copia d'aquest thread a la cua\n         * recv_without_send perque quan s'arribi al send corresponent, aquest\n         * pugui saber que ja s'havia arribat aqui. */\n        copia_thread = duplicate_thread (thread);\n        inFIFO_queue (& (task->recv_without_send), (char *) copia_thread);\n    }\n\n    /* Es retorna si s'ha trobat el Send corresponent o no */\n    return res;\n}\n\n\nint COMMUNIC_recv_reached_dependency_synchronization (struct t_thread *thread,\n        struct t_recv   *mess)\n{\n    struct t_task   *task, *source_task;\n    struct t_thread *partner_send;\n    struct t_action *action;\n    struct t_send   *mess_send;\n    struct t_thread *copia_thread;\n    int              res   = 0;\n\n    assert (mess->ori_thread != -1);\n    task = thread->task;\n    assert (mess->ori == task->taskid);\n    for (\n            partner_send = (struct t_thread *) head_queue (& (thread->send_without_recv) );\n            partner_send != TH_NIL;\n            partner_send = (struct t_thread *) next_queue (& (thread->send_without_recv) )\n        )\n    {\n        source_task = partner_send->task;\n        action      = partner_send->action;\n        mess_send   = & (action->desc.send);\n        assert (mess_send->dest            == thread->task->taskid);\n        assert (mess_send->dest_thread != -1);\n        if ( ( (partner_send->threadid     == mess->ori_thread)     || (mess->ori_thread == -1) )  &&\n                ( (partner_send->task->taskid == mess->ori)            || (mess->ori == -1) )         &&\n                (mess_send->mess_tag        == mess->mess_tag)                                     &&\n                (mess_send->communic_id     == mess->communic_id)                                  &&\n                /*    ((mess_send->dest            == thread->task->taskid) || (mess_send->dest == -1))   &&   */\n                ( (mess_send->dest_thread     == thread->threadid)     || (mess_send->dest_thread == -1) ) )\n        {\n            /* Ja s'havia arribat al send corresponent */\n            break;\n        }\n    }\n\n    if (partner_send != TH_NIL)\n    {\n        /* Cal comprovar si el Send corresponent era realment sincron o no */\n        if (mess_send->rendez_vous)\n        {\n            /* Caldra retornar que s'ha trobat un Send corresponent que era SINCRON,\n             * per tant, caldra desbloquejar aquest send abans d'arribar al wait. */\n            res = 1;\n        }\n        /* Ja s'havia arribat al send corresponent, per tant, cal treure'l de la\n         * cua de sends sense el recv que li correspon */\n        extract_from_queue (& (thread->send_without_recv), (char *) partner_send);\n        /* Cal carregar-se aquest thread perque nomes era una copia per informar\n         * que s'havia arribat a aquest send */\n        delete_duplicate_thread (partner_send);\n    }\n    else\n    {\n        /* S'ha arribat a un recv o Irecv sense que s'hagi arribat al send que li\n         * correspon. Per tant, cal encuar una copia d'aquest thread a la cua\n         * recv_without_send perque quan s'arribi al send corresponent, aquest\n         * pugui saber que ja s'havia arribat aqui. */\n        copia_thread = duplicate_thread (thread);\n        inFIFO_queue (& (thread->recv_without_send), (char *) copia_thread);\n    }\n\n    /* Es retorna si s'ha trobat el Send corresponent o no */\n    return res;\n}\n\n\nint COMMUNIC_debug_the_senders_list (struct t_thread *thread)\n{\n    struct t_task   *task;\n    struct t_thread *partner_send;\n    int              res   = 0;\n\n    task = thread->task;\n    panic (\"I believe this is never happening, COMMUNIC_debug_the_senders_list\\n\");\n    for (\n            partner_send = (struct t_thread *) head_queue (& (task->send) );\n            partner_send != TH_NIL;\n            partner_send = (struct t_thread *) next_queue (& (task->send) )\n        )\n    {\n        printf (\"checking one entry of the sends list in DEBUG_THE_SENDERS_LIST\\n\");\n\n        register struct t_account *account;\n\n\n        account = current_account (partner_send);\n        printf (\"Thread without IDENTITY P%d T%02d t%d is original %d address account first  %p and last %p\\n\",\n                IDENTIFIERS (partner_send), \n                partner_send->original_thread, \n                (partner_send->account).first, (partner_send->account).last);\n        printf (\"was is able to locate node in promote_to_original %d for P%d T%d t%d\\n\",\n                account->nodeid, IDENTIFIERS (partner_send) );\n\n        struct t_node *node = &nodes[account->nodeid];\n        printf (\"yes it was able NODE %d  IDENTITY  for P%d T%d t%d\\n\",\n                account->nodeid, IDENTIFIERS (partner_send) );\n\n    }\n\n    printf (\"FINISHED DEBUG_THE_SENDERS_LIST\\n\");\n    /* Es retorna si s'ha trobat el Send corresponent o no */\n    return res;\n}\n\n\n/***************************************************************\n ** COMMUNIC_send_reached\n ************************\n ** Serveix per indicar que s'ha arribat a un send. Cal\n ** comprovar si s'havia arribat al recv/Irecv corresponent i\n ** actuar en consequencia.\n ** Si es troba que s'ha fet un Irecv corresponent a aquest send,\n ** es retorna 1 per indicar que el send podra comenc,ar\n ** immediatament. En cas contrari es retorna 0.\n ***************************************************************/\nint COMMUNIC_send_reached_real_MPI_transfer (struct t_thread *thread, struct t_send *mess)\n{\n    struct t_task   *task, *dest_task;\n    struct t_thread *partner_recv;\n    struct t_action *action;\n    struct t_recv   *mess_recv;\n    struct t_thread *copia_thread;\n    int res = 0;\n\n    assert (mess->dest_thread == -1);\n    task = thread->task;\n\n    dest_task = locate_task (task->Ptask, mess->dest);\n    for (partner_recv = (struct t_thread *) head_queue (& (dest_task->recv_without_send) );\n            partner_recv != TH_NIL;\n            partner_recv = (struct t_thread *) next_queue (& (dest_task->recv_without_send) ) )\n    {\n        action = partner_recv->action;\n        mess_recv = & (action->desc.recv);\n\n        assert (partner_recv->task->taskid == mess->dest);\n        assert (mess->dest_thread == -1);\n        if ( \n                ((partner_recv->threadid == mess->dest_thread) || (mess->dest_thread == -1))\n                && (mess->mess_tag == mess_recv->mess_tag) \n                && (mess->communic_id == mess_recv->communic_id) \n                && ((mess_recv->ori == thread->task->taskid) || (mess_recv->ori == -1))\n                && ((mess_recv->ori_thread == thread->threadid) || (mess_recv->ori_thread == -1)) \n           )\n        {\n            /* Ja s'havia arribat al recv corresponent */\n            break;\n        }\n    }\n\n    if (partner_recv != TH_NIL)\n    {\n        if (action->action == IRECV)\n        {\n            /* Caldra retornar que s'ha trobat un Irecv corresponent i, per tant,\n             * aquest thread no s'haura d'esperar encara que sigui sincron i el\n             * seu partner no hagi arribat al wait. */\n            res = 1;\n        }\n        /* Ja s'havia arribat al recv/Irecv corresponent, per tant, cal treure'l de la\n         * cua de recv sense el send que li correspon */\n        extract_from_queue (& (dest_task->recv_without_send), (char *) partner_recv);\n        /* Cal carregar-se aquest thread perque nomes era una copia per informar\n         * que s'havia arribat a aquest recv/Irecv */\n        delete_duplicate_thread (partner_recv);\n    }\n    else\n    {\n        /* S'ha arribat a un send sense que s'hagi arribat al recv/Irecv que li\n         * correspon. Per tant, cal encuar una copia d'aquest thread a la cua\n         * send_without_recv perque quan s'arribi al recv/Irecv corresponent, aquest\n         * pugui saber que ja s'havia arribat aqui. */\n        copia_thread = duplicate_thread (thread);\n        inFIFO_queue (& (dest_task->send_without_recv), (char *) copia_thread);\n    }\n\n    /* Es retorna indicant si s'ha trobat un Irecv associat a aquest send o no */\n    return res;\n}\n\n\nint COMMUNIC_send_reached_dependency_synchronization (struct t_thread *thread, struct t_send *mess)\n{\n    struct t_task   *task, *dest_task;\n    struct t_thread *partner_recv, *dest_thread;\n    struct t_action *action;\n    struct t_recv   *mess_recv;\n    struct t_thread *copia_thread;\n    int res = 0;\n\n    assert (mess->dest_thread != -1);\n\n    task = thread->task;\n    dest_task = locate_task (task->Ptask, mess->dest);\n    dest_thread = locate_thread_of_task (dest_task, mess->dest_thread);\n    for (partner_recv = (struct t_thread *) head_queue (& (dest_thread->recv_without_send) );\n            partner_recv != TH_NIL;\n            partner_recv = (struct t_thread *) next_queue (& (dest_thread->recv_without_send) ) )\n    {\n        action = partner_recv->action;\n        mess_recv = & (action->desc.recv);\n        assert (partner_recv->task->taskid == mess->dest);\n        assert (mess->dest_thread != -1);\n        if  ( \n                ((partner_recv->threadid == mess->dest_thread) || (mess->dest_thread == -1) ) \n                && (mess->mess_tag == mess_recv->mess_tag) \n                && (mess->communic_id == mess_recv->communic_id) \n                && ((mess_recv->ori == thread->task->taskid) || (mess_recv->ori == -1) )\n                && ((mess_recv->ori_thread == thread->threadid) || (mess_recv->ori_thread == -1))\n            )\n        {\n            /* Ja s'havia arribat al recv corresponent */\n            break;\n        }\n    }\n\n    if (partner_recv != TH_NIL)\n    {\n        if (action->action == IRECV)\n        {\n            /* Caldra retornar que s'ha trobat un Irecv corresponent i, per tant,\n             * aquest thread no s'haura d'esperar encara que sigui sincron i el\n             * seu partner no hagi arribat al wait. */\n            res = 1;\n        }\n        /* Ja s'havia arribat al recv/Irecv corresponent, per tant, cal treure'l de la\n         * cua de recv sense el send que li correspon */\n        extract_from_queue (& (dest_thread->recv_without_send), (char *) partner_recv);\n        /* Cal carregar-se aquest thread perque nomes era una copia per informar\n         * que s'havia arribat a aquest recv/Irecv */\n        delete_duplicate_thread (partner_recv);\n    }\n    else\n    {\n        /* S'ha arribat a un send sense que s'hagi arribat al recv/Irecv que li\n         * correspon. Per tant, cal encuar una copia d'aquest thread a la cua\n         * send_without_recv perque quan s'arribi al recv/Irecv corresponent, aquest\n         * pugui saber que ja s'havia arribat aqui. */\n        copia_thread = duplicate_thread (thread);\n        inFIFO_queue (& (dest_thread->send_without_recv), (char *) copia_thread);\n    }\n\n    /* Es retorna indicant si s'ha trobat un Irecv associat a aquest send o no */\n    return res;\n}\n\n/******************************************************************************\n * PROCEDURE 'COMMUNIC_send'                                                  *\n * \u00daLTIMA MODIFICACI\u00d3N: 28/10/2004 (Juan Gonz\u00e1lez Garc\u00eda)                     *\n ******************************************************************************\n *\n * Inicia el tratamiento de una operaci\u00f3n MPI_Send. En primer lugar asegura que\n * se cumple el tiempo de 'startup'. Posteriormente, en funci\u00f3n de cada tipo de\n * 'send' (Send o ISend, con o sin Rendezvous), inicia o no la reserva de\n * recursos, llamando a 'really_send'.\n */\n\nvoid COMMUNIC_send (struct t_thread *thread)\n{\n    struct t_action  *action;\n    struct t_send    *mess;         /* Message */\n    struct t_task    *task,         /* Sender task */\n                     *task_partner; /* Receiver task */\n    struct t_thread  *thread_partner;\n    int               comm_kind;\n    struct t_thread  *copy_thread;\n    struct t_thread  *partner;\n    struct t_account *account;\n    t_nano           startup, copy_latency, roundtriptime;\n    dimemas_timer     tmp_timer;\n    struct t_node    *node_s,      /* Sender node */\n                     *node_r;       /* Receiver node */\n    int               hi_ha_irecv;  /* Indica si s'ha arribat a un Irecv que\n                                     * permet continuar el send encara que sigui\n                                     *  sincron */\n    int               kind;         /* Communication type */\n    struct t_dedicated_connection *connection;\n\n    action = thread->action;\n    if (action->action != SEND)\n    {\n        panic (\"Calling COMMUNIC_send and action is not Send (%d)\\n\",\n                action->action);\n    }\n\n    mess = & (action->desc.send);\n\n    /* DEBUG */\n    if (debug&D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\":----calling COMMUNIC_send \\\n                P%02d T%02d (t%02d) -> T%02d Tag(%d) Size: %lld  Comm.Id: %d \\n\",\n                IDENTIFIERS (thread),\n                mess->dest,\n                mess->mess_tag,\n                mess->mess_size,\n                mess->communic_id);\n    }\n\n    task = thread->task;\n    task_partner = locate_task (task->Ptask, mess->dest);\n    if (task_partner == T_NIL)\n    {\n        panic (\"P%02d T%02d (t%02d) trying to send message to inexistent T%d\\n\",\n                IDENTIFIERS (thread),\n                mess->dest);\n    }\n\n\n    if (mess->dest_thread == -1)\n    {\n        /* real MPI transfer - we look for it at the level of tasks  */\n        thread_partner = TH_NIL;\n    }\n    else\n    {\n        /* real MPI transfer - we look for it at the level of threads  */\n        thread_partner = locate_thread_of_task (task_partner, mess->dest_thread /* thid */);\n    }\n\n\n    node_s = get_node_of_task (task);\n    node_r = get_node_of_task (task_partner);\n\n    /* S'obte el tipus de communicaci\u00f3 */\n    kind = get_communication_type (task,\n            task_partner,\n            mess->mess_tag,\n            mess->mess_size,\n            &connection);\n\n    if ( kind == INTERNAL_NETWORK_COM_TYPE \n            && external_comm_library_loaded == TRUE)\n    {\n        /* JGG (28/10/2004): if the communication occurs between nodes and\n           the external library is loaded, we check which model is going to be\n           used, a regular Dimemas model or an external model defined in the library\n           (EXTERNAL_MODEL_COM_TYPE).*/\n\n        kind = external_get_communication_type(node_s->nodeid,\n                node_r->nodeid,\n                task->taskid,\n                task_partner->taskid,\n                mess->mess_tag,\n                mess->mess_size);\n    }\n\n    mess->comm_type = kind;\n\n    /**************************************************************************************\n     *\n     *                     Karthikeyan: EEE CODE for 3 Level Network\n     *\n     ***************************************************************************************/\n\n    if(eee_enabled){\n        if(EEE_DEBUG)\n        {\n            PRINT_TIMER(current_time);\n            printf(\"::Message at COMMUNIC_send function--\\n\");\n        }\n        //TODO REMOVE THIS PRINTF!\n        //printf(\"------------------MESSINFLIGHT:T:%d,N_S:%d,N_R:%d\\n\"\n        //                                                      ,thread->messages_in_flight\n        //                                                      ,node_s->messages_in_flight\n        //                                                      ,node_r->messages_in_flight);\n        if (thread->eee_done_reset_var == TRUE) {\n            if(EEE_DEBUG) {\n                PRINT_TIMER(current_time);\n                printf(\"::EEE_SEND Finished! Resetting Variables!\");\n            }\n            thread->doing_startup = FALSE;\n            thread->startup_done = FALSE;\n            thread->loose_cpu = FALSE;\n            thread->link_transmit_done = FALSE;\n            thread->nw_switch_done = TRUE;\n            thread->eee_done_reset_var = FALSE;\n        }\n\n        if (thread->eee_send_done == FALSE) {\n\n            if(EEE_DEBUG) {PRINT_TIMER(current_time); printf(\"::At EEE Network Code\\n\");}\n\n            t_nano eee_nw_delay;\n            eee_nw_delay = eee_network(thread);\n\n            if(EEE_DEBUG) {\n                PRINT_TIMER(current_time);\n                printf(\"::Delay Returned:%f\\n\",(double)eee_nw_delay);\n            }\n\n            if (thread->eee_send_done == TRUE) {\n                if(EEE_DEBUG) {\n                    PRINT_TIMER(current_time);\n                    printf(\"::Last Transmit - Activing reset variables after send!\\n\\n\");\n                }\n                thread->eee_done_reset_var = TRUE;\n                if(EEE_DEBUG) {\n                    PRINT_TIMER(current_time);\n                    printf(\"::Event Added to Scheduler with delay::%f\\n\"\n                            ,(double)eee_nw_delay);\n                }\n                SCHEDULER_thread_to_ready_return (M_COM, thread, eee_nw_delay, 0);\n                return;\n\n            } else {\n\n                thread->doing_startup = TRUE;\n                thread->startup_done = FALSE;\n                thread->loose_cpu = FALSE;\n                if(EEE_DEBUG) {\n                    PRINT_TIMER(current_time);\n                    printf(\"::Event Added to Scheduler with delay::%f\\n\"\n                            ,(double)eee_nw_delay);\n                }\n                SCHEDULER_thread_to_ready_return (M_COM, thread, eee_nw_delay, 0);\n                return;\n            }\n\n            if(EEE_DEBUG) {\n                PRINT_TIMER(current_time);\n                printf(\"::Leaving EEE Network Code\\n\");\n            }\n        }\n    }\n    /**************************************************************************************\n     *                     Karthikeyan: End of EEE code\n     ***************************************************************************************/\n\n    /* Compute startup duration and re-schedule thread if needed */\n    if (thread->startup_done == FALSE)\n    {\n        // startup = compute_startup (thread, kind, node_s, connection);\n        startup = compute_startup (thread,\n                thread->task->taskid,  /* Sender */\n                task_partner->taskid,  /* Receiver */\n                node_s,\n                node_r,\n                mess->mess_tag,\n                mess->mess_size,\n                kind,\n                connection);\n\n        if (OCLEventEncoding_Is_OCLKernelRunning(thread->acc_in_block_event) \n                && thread->kernel)\n        {\n            struct t_cpu *cpu = get_cpu_of_thread(thread);\n            PARAVER_Event (cpu->unique_number,\n                    IDENTIFIERS (thread),\n                    current_time,\n                    thread->acc_in_block_event.type,\n                    0);\n        }\n\n        if (startup != (t_nano) 0)\n        {\n            thread->logical_send = current_time;\n\n            thread->loose_cpu     = FALSE;\n            thread->doing_startup = TRUE;\n\n            if (CUDAEventEncoding_Is_CUDAComm(mess->mess_tag) ||\n                    OCLEventEncoding_Is_OCLComm(mess->mess_tag))\n                thread->doing_acc_comm = TRUE;\n\n            account = current_account (thread);\n            FLOAT_TO_TIMER (startup, tmp_timer);\n            ADD_TIMER (account->latency_time, tmp_timer, account->latency_time);\n            SUB_TIMER (account->cpu_time, tmp_timer, account->cpu_time);\n\n            SCHEDULER_thread_to_ready_return (M_COM, thread, startup, 0);\n\n            if (debug & D_COMM)\n            {\n                PRINT_TIMER (current_time);\n                printf (\": COMMUNIC_send\\tP%02d T%02d (t%02d) Initiate startup (%f)\\n\",\n                        IDENTIFIERS (thread),\n                        (double) startup / 1e9);\n            }\n            return;\n        }\n        else /* (startup == (t_nano) 0) */\n        {\n            thread->startup_done = TRUE;\n            thread->logical_send = current_time;\n        }\n    } /* thread->startup_done == TRUE */\n\n    /* Copy latency operations */\n    if (DATA_COPY_enabled && mess->mess_size <= DATA_COPY_message_size)\n    {\n        if (thread->copy_done == FALSE)\n        {\n            copy_latency = compute_copy_latency (thread, \n                    node_s, \n                    mess->mess_size, \n                    mess->comm_type);\n\n            if (copy_latency != (t_nano) 0)\n            {\n                thread->loose_cpu     = FALSE;\n                thread->doing_copy    = TRUE;\n\n                account = current_account (thread);\n                FLOAT_TO_TIMER (copy_latency, tmp_timer);\n                ADD_TIMER (account->latency_time, tmp_timer, account->latency_time);\n                SUB_TIMER (account->cpu_time, tmp_timer, account->cpu_time);\n\n                SCHEDULER_thread_to_ready_return (M_COM, thread, copy_latency, 0);\n\n                if (debug & D_COMM)\n                {\n                    PRINT_TIMER (current_time);\n                    printf (\n                            \": COMMUNIC_send\\tP%02d T%02d (t%02d) Initiate copy latency (%f)\\n\",\n                            IDENTIFIERS (thread),\n                            (double) copy_latency / 1e9);\n                }\n                return;\n            }\n            else\n            {\n                thread->copy_done = TRUE;\n            }\n        }\n    }\n\n    /* Round Trip Time for sends */\n    if (RTT_enabled && mess->rendez_vous && (kind == INTERNAL_NETWORK_COM_TYPE) )\n    {\n        if (thread->roundtrip_done == FALSE)\n        {\n            roundtriptime = RTT_time / 2.0;\n\n            if (RTT_time != (t_nano) 0)\n            {\n                thread->loose_cpu       = FALSE;\n                thread->doing_roundtrip = TRUE;\n\n                account = current_account (thread);\n                FLOAT_TO_TIMER (roundtriptime, tmp_timer);\n                ADD_TIMER (account->latency_time, tmp_timer, account->latency_time);\n                SUB_TIMER (account->cpu_time, tmp_timer, account->cpu_time);\n\n                SCHEDULER_thread_to_ready_return (M_COM, thread, roundtriptime, 0);\n\n                if (debug & D_COMM)\n                {\n                    PRINT_TIMER (current_time);\n                    printf (\n                            \": COMMUNIC_send\\tP%02d T%02d (t%02d) Initiate round trip time(%f)\\n\",\n                            IDENTIFIERS (thread),\n                            (double) roundtriptime / 1e9);\n                }\n                return;\n            }\n            else\n            {\n                thread->roundtrip_done = TRUE;\n            }\n        }\n    }\n    /* Startup, Copy and RTT checks reset */\n    thread->startup_done   = FALSE;\n    thread->copy_done      = FALSE;\n    thread->roundtrip_done = FALSE;\n    // Karthikeyan EEE Code - Resetting variables\n    thread->eee_send_done = FALSE;\n    // Karthikeyan EEE Code END\n\n    if (with_deadlock_analysis)\n    {\n        if (DEADLOCK_new_communic_event(thread))\n            return;\n    }\n\n    account = current_account (thread);\n    account->n_sends++;\n\n    account->n_bytes_send += mess->mess_size;\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": COMMUNIC_send\\tP%02d T%02d (t%02d) -> T%02d t%d Tag: %d Comm.Id: %d Size: %lldb\\n\",\n                IDENTIFIERS (thread),\n                action->desc.send.dest,\n                action->desc.send.dest_thread,\n                mess->mess_tag,\n                mess->communic_id,\n                action->desc.send.mess_size\n               );\n    }\n\n    /* FEC: S'avisa que s'ha arribat a aquest send i es comprova si s'ha arribat\n     * a un Irecv que permeti continuar a aquest send encara que sigui sincron. */\n\n    if (mess->dest_thread == -1)\n    {\n        /* this is a real MPI transfer */\n        hi_ha_irecv = COMMUNIC_send_reached_real_MPI_transfer (thread, mess);\n    }\n    else\n    {\n        /* this is a dependency synchronization */\n        hi_ha_irecv = COMMUNIC_send_reached_dependency_synchronization (thread, mess);\n    }\n\n#ifdef VENUS_ENABLED\n    if (VC_is_enabled() && (kind == INTERNAL_NETWORK_COM_TYPE) ) {\n        double dtime;\n        TIMER_TO_FLOAT (current_time, dtime);\n        if (mess->rendez_vous)\n        {\n            VC_command_rdvz_send (dtime,\n                    node_s->nodeid,\n                    node_r->nodeid,\n                    mess->mess_tag,\n                    mess->mess_size,\n                    task->Ptask->Ptaskid,\n                    task_partner->Ptask->Ptaskid);\n        }\n    }\n#endif\n\n\n    if (mess->dest_thread == -1)\n    {\n        /* real MPI transfer\n           look for it at task->recv   */\n        partner = locate_receiver_real_MPI_transfer (&(task_partner->recv),\n                task->taskid,\n                thread->threadid,\n                mess->dest_thread,\n                mess->mess_tag,\n                mess->communic_id);\n    }\n    else\n    {\n        /* real MPI transfer\n           look for it at thread->recv   */\n        assert (thread_partner != TH_NIL);\n        partner = locate_receiver_dependencies_synchronization ( &(thread_partner->recv),\n                task->taskid,\n                thread->threadid,\n                mess->dest_thread,\n                mess->mess_tag,\n                mess->communic_id);\n    }\n\n\n    //TODO - think about this - what is what?????\n    //   if (partner != TH_NIL)\n    //      assert(hi_ha_irecv);\n\n\n    if (partner != TH_NIL)\n    {\n        SCHEDULER_info (COMMUNICATION_INFO, SCH_INFO_SEND, thread, TH_NIL);\n    }\n\n    comm_kind = (mess->immediate << 1) + mess->rendez_vous;\n\n    // printf(\"Communication kind = %d\\n\", comm_kind);\n\n    switch (comm_kind)\n    {\n        /* Con RD estamos en un Send */\n        case RD_SYNC:\n        case RD_ASYNC:\n            {\n                if ( (!hi_ha_irecv) && (partner == TH_NIL) )\n                {\n                    if (mess->immediate)\n                    {\n                        /* El Rendez vous s'ha de fer en \"background\". Cal utilitzar\n                         * una copia del thread */\n                        copy_thread = duplicate_thread (thread);\n                        if (mess->dest_thread == -1)\n                        {\n                            /* this is for a real MPI transfer */\n                            inFIFO_queue (& (task->send), (char *) copy_thread);\n                        }\n                        else\n                        {\n                            /* this is for a dependency synchronization */\n                            inFIFO_queue (& (thread->send), (char *) copy_thread);\n                        }\n\n                        /* El thread original pot continuar */\n                        action = thread->action;\n                        thread->action = action->next;\n                        READ_free_action(action);\n                        if (more_actions (thread))\n                        {\n                            thread->loose_cpu = FALSE;\n                            SCHEDULER_thread_to_ready (thread);\n                        }\n                    } /* Send, con Rendezvous */\n                    else\n                    {\n                        /* El thread s'ha de bloquejar per esperar el Irecv/recv */\n                        if (mess->dest_thread == -1)\n                        {\n                            /* this is for a real MPI transfer */\n                            inFIFO_queue (& (task->send), (char *) thread);\n                        }\n                        else\n                        {\n                            /* this is for a dependency synchronization */\n                            inFIFO_queue (& (thread->send), (char *) thread);\n                        }\n                    }\n                }\n                else /* hi_ha_irecv || partner != TH_NIL */\n                {\n                    if (thread->original_thread &&\n                            (CUDAEventEncoding_Is_CUDATransferBlock(thread->acc_in_block_event) ||\n                             OCLEventEncoding_Is_OCLTransferBlock(thread->acc_in_block_event)))\n                    {\n                        thread->acc_sndr_sync = TRUE;\n                        copy_thread = thread;\n                    }\n                    else {\n                        copy_thread = duplicate_thread (thread);\n                        copy_thread->initial_communication_time = current_time;\n                        copy_thread->last_paraver               = current_time;\n                    }\n\n                    /* !!! */\n                    really_send (copy_thread);\n\n                    if (!thread->acc_sndr_sync)\n                    {\n                        action = thread->action;\n                        thread->action = action->next;\n                        READ_free_action(action);\n                        if (more_actions (thread) )\n                        {\n                            thread->loose_cpu = FALSE;\n                            SCHEDULER_thread_to_ready (thread);\n                        }\n                    }\n                }\n                break;\n            }\n        case NORD_SYNC:\n            /* De momento solo el tipo  de comunicacion NORD_ASYNC */\n        case NORD_ASYNC:\n            {\n                copy_thread = duplicate_thread (thread);\n                ASS_ALL_TIMER (copy_thread->initial_communication_time, current_time);\n                copy_thread->last_paraver = current_time;\n                /* !!!! */\n                really_send (copy_thread);\n\n                action = thread->action;\n                thread->action = action->next;\n                READ_free_action(action);\n                if (more_actions (thread) )\n                {\n                    thread->loose_cpu = FALSE;\n                    SCHEDULER_thread_to_ready (thread);\n                }\n                break;\n            }\n        default:\n            panic (\"Impossible send type %d\\n\", comm_kind);\n            break;\n    } /* switch */\n}\n\n/******************************************************************************\n * PROCEDURE 'COMMUNIC_recv'                                                  *\n * \u00daLTIMA MODIFICACI\u00d3N: 29/10/2004 (Juan Gonz\u00e1lez Garc\u00eda)                     *\n *****************************************************************************/\n\nvoid COMMUNIC_recv (struct t_thread *thread)\n{\n    struct t_action  *action;\n    struct t_recv    *mess;\n    struct t_task    *task, *task_source;\n    struct t_account *account;\n    dimemas_timer     tmp_timer;\n    struct t_node    *node_s, *node_r;\n    t_nano           startup, copy_latency;\n    int               kind;\n    struct t_dedicated_connection *connection;\n\n\n    action = thread->action;\n    if (action->action != RECV)\n    {\n        panic (\"Calling COMMUNIC_recv and action is not receive (%d)\\n\",\n                action->action);\n    }\n\n    mess = & (action->desc.recv);\n\n\n    /* DEBUG */\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \":----calling COMMUNIC_recv   P%02d T%02d (t%02d) <- T%02d (t%02d) Tag: %d Comm.Id: %d size: %lld\\n\",\n                IDENTIFIERS (thread),\n                action->desc.recv.ori,\n                action->desc.recv.ori_thread,\n                mess->mess_tag,\n                mess->communic_id,\n                action->desc.recv.mess_size);\n    }\n\n    task = thread->task;\n\n    node_r = get_node_of_thread (thread); //origin thread\n    node_s = get_node_for_task_by_name (thread->task->Ptask, mess->ori); //7 thread\n\n    task_source = locate_task (task->Ptask, mess->ori);\n\n    /* S'obte el tipus de communicaci\u00f3 */\n    kind = get_communication_type (task_source,\n            task,\n            mess->mess_tag,\n            mess->mess_size,\n            &connection);\n\n    if (kind == INTERNAL_NETWORK_COM_TYPE &&\n            external_comm_library_loaded == TRUE)\n    {\n        /* JGG (28/10/2004): if the communication occurs between nodes and\n           the external library is loaded, we check which model is going to be\n           used, a regular Dimemas model or an external model defined in the library\n           (EXTERNAL_MODEL_COM_TYPE).*/\n        kind = external_get_communication_type(node_s->nodeid,\n                node_r->nodeid,\n                mess->ori,\n                task->taskid,\n                mess->mess_tag,\n                mess->mess_size);\n    }\n\n    mess->comm_type = kind;\n\n    if (thread->startup_done == FALSE)\n    { /* Compute startup duration and re-schedule thread if needed */\n        // startup = compute_startup (thread, kind, node_s, connection);\n        startup = compute_startup (thread,\n                mess->ori,            /* Sender */\n                thread->task->taskid, /* Receiver */\n                node_s,\n                node_r,\n                mess->mess_tag,\n                mess->mess_size,\n                kind,\n                connection);\n        /*if (mess->communic_id == 0 &&\n          CUDAEventEncoding_Is_CUDATransferBlock(thread->acc_in_block_event))\n          startup = (dimemas_timer) 0;*/\n\n        if (startup > (t_nano) 0)\n        {\n\n            thread->logical_recv = current_time;\n\n            thread->loose_cpu     = FALSE;\n            thread->doing_startup = TRUE;\n\n            if (CUDAEventEncoding_Is_CUDAComm(mess->mess_tag) ||\n                    OCLEventEncoding_Is_OCLComm(mess->mess_tag))\n                thread->doing_acc_comm = TRUE;\n\n            account = current_account (thread);\n            FLOAT_TO_TIMER (startup, tmp_timer);\n            ADD_TIMER (account->latency_time, tmp_timer, account->latency_time);\n            SUB_TIMER (account->cpu_time, tmp_timer, account->cpu_time);\n\n            SCHEDULER_thread_to_ready_return (M_COM, thread, startup, 0);\n\n            if (debug & D_COMM)\n            {\n                PRINT_TIMER (current_time);\n                printf (\": COMMUNIC_recv\\tP%02d T%02d (t%02d) Initiate startup (%f)\\n\",\n                        IDENTIFIERS (thread),\n                        (double) startup / 1e9);\n            }\n\n            return;\n        }\n        else if (startup == (t_nano) 0)\n        {\n            thread->logical_recv = current_time;\n            thread->startup_done = TRUE;\n        }\n    }\n    /* Startup has finished */\n\n    /* Copy latency operations */\n    if (DATA_COPY_enabled && mess->mess_size <= DATA_COPY_message_size)\n    {\n        if (thread->copy_done == FALSE)\n        {\n            copy_latency = compute_copy_latency (thread, node_s, mess->mess_size, mess->comm_type);\n\n            if (copy_latency != (t_nano) 0)\n            {\n                thread->loose_cpu     = FALSE;\n                thread->doing_copy    = TRUE;\n\n                account = current_account (thread);\n                FLOAT_TO_TIMER (copy_latency, tmp_timer);\n                ADD_TIMER (account->latency_time, tmp_timer, account->latency_time);\n                SUB_TIMER (account->cpu_time, tmp_timer, account->cpu_time);\n\n                SCHEDULER_thread_to_ready_return (M_COM, thread, copy_latency, 0);\n\n                if (debug & D_COMM)\n                {\n                    PRINT_TIMER (current_time);\n                    printf (\n                            \": COMMUNIC_recv\\tP%02d T%02d (t%02d) Initiate copy latency (%f)\\n\",\n                            IDENTIFIERS (thread),\n                            (double) copy_latency / 1e9);\n                }\n                return;\n            }\n            else\n            {\n                thread->copy_done = TRUE;\n            }\n        }\n    }\n\n    /* Startup and Copy checks reset */\n    thread->startup_done = FALSE;\n    thread->copy_done    = FALSE;\n\n    if (with_deadlock_analysis)\n    {\n        if (DEADLOCK_new_communic_event(thread))\n            return;\n    }\n\n    account = current_account (thread);\n    account->n_recvs++;\n\n    /* FEC: S'avisa que s'ha arribat a aquest recv */\n    /* JGG: No se tiene en cuenta el tipo de send ?\u00bf?\u00bf */\n    if (mess->ori_thread == -1) \n    {\n        /* this is a real MPI transfer */\n        COMMUNIC_recv_reached_real_MPI_transfer (thread, mess);\n    } \n    else \n    {\n        /* this is a dependency synchronization */\n        COMMUNIC_recv_reached_dependency_synchronization (thread, mess);\n    }\n    t_boolean Is_message_awaiting;\n    if (mess->ori_thread == -1)\n    {\n        Is_message_awaiting = is_message_awaiting_real_MPI_transfer (task, mess, thread);\n    }\n    else\n        Is_message_awaiting = is_message_awaiting_dependency_synchronization (task, mess, thread);\n    if (Is_message_awaiting)                      /* 'is_message_awaiting'      */\n    { /* desencola a los que esperan*/\n        account->n_recvs_on_processor++;\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC_recv_reached\\tP%02d T%02d (t%02d) <- T%02d t%d Tag: %d Comm.Id: %d size: %lld (Local Message)\\n\",\n                    IDENTIFIERS (thread),\n                    action->desc.recv.ori,\n                    action->desc.recv.ori_thread,\n                    mess->mess_tag,\n                    mess->communic_id,\n                    action->desc.recv.mess_size);\n        }\n\n        thread->action = action->next;\n        READ_free_action(action);\n        if (more_actions (thread) )\n        {\n            thread->loose_cpu = FALSE;\n            SCHEDULER_thread_to_ready (thread);\n        }\n    }\n    else /* !is_message_awaiting(...) */\n    {\n        if (mess->ori_thread == -1) {\n            /* this is for a real MPI transfer */\n            Start_communication_if_partner_ready_for_rendez_vous_real_MPI_transfer (thread, mess);\n        } else {\n            /* this is for a dependency synchronization */\n            Start_communication_if_partner_ready_for_rendez_vous_dependency_synchronization (thread, mess);\n        }\n\n        if (node_r->machine->scheduler.busywait_before_block)\n        {\n            SCHEDULER_thread_to_busy_wait (thread);\n        }\n        else\n        {\n            account->n_recvs_must_wait++;\n            thread->start_wait_for_message = current_time;\n            if (debug & D_COMM)\n            {\n                PRINT_TIMER (current_time);\n                printf (\n                        \": COMMUNIC_recv\\tP%02d T%02d (t%02d) <- T%02d t%d Tag: %d Comm.Id: %d  Size1: %lld  Size2: %lld (Waiting)\\n\",\n                        IDENTIFIERS (thread),\n                        action->desc.recv.ori,\n                        action->desc.recv.ori_thread,\n                        mess->mess_tag,\n                        mess->communic_id,\n                        action->desc.recv.mess_size,\n                        mess->mess_size\n                       );\n            }\n\n            if (mess->ori_thread == -1) {\n                /* this is a regular MPI transfer\n                   put it on the recv list of the task */\n                inFIFO_queue (& (task->recv), (char *) thread);\n            }\n            else {\n                /* this is a dependency synchronization\n                   put it on the recv list of the thread  */\n                inFIFO_queue (& (thread->recv), (char *) thread);\n            }\n        }\n    }\n}\n/******************************************************************************\n * PROCEDURE 'COMMUNIC_Irecv'                                                 *\n * \u00daLTIMA MODIFICACI\u00d3N: 02/11/2004 (Juan Gonz\u00e1lez Garc\u00eda)                     *\n ******************************************************************************\n *\n * Es el tractament que cal aplicar a un Irecv. Consisteix en aplicar el startup\n * i despres mirar si hi ha algun send bloqejat esperant aquest Irecv. Si es\n * aixi es desbloqueja. Tant en un cas com en l'altre cal informar que s'ha\n * arribat a un Irecv.\n */\n\nvoid COMMUNIC_Irecv (struct t_thread *thread)\n{\n    struct t_action  *action;\n    struct t_recv    *mess;\n    struct t_task    *task;\n    struct t_recv    *irecv_notification;\n#ifdef STARTUP_ALS_IRECV\n    struct t_task    *task_source;\n    struct t_account *account;\n    dimemas_timer     tmp_timer;\n    struct t_node    *node, *node_s, *node_r;\n    t_nano           startup;\n    int               kind;\n    struct t_dedicated_connection *connection;\n#endif\n    int               hi_ha_send_sync; /* Indica si s'ha arribat a un Send SINCRON\n                                          que caldra desbloqejar. */\n    action = thread->action;\n    if (action->action != IRECV)\n    {\n        panic (\n                \"Calling COMMUNIC_Irecv and action is not Ireceive (%d)\\n\",\n                action->action\n              );\n    }\n\n    mess = & (action->desc.recv);\n\n    /* DEBUG */\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\":-----calling COMMUNIC_Irecv   P%02d T%02d (t%02d)  <- T%02d (t%02d)  Tag: %d  Comm.Id: %d  Size: %lld \\n\",\n                IDENTIFIERS (thread),\n                action->desc.recv.ori,\n                action->desc.recv.ori_thread,\n                mess->mess_tag,\n                mess->communic_id,\n                action->desc.recv.mess_size);\n    }\n\n#ifdef STARTUP_ALS_IRECV /*****************************************************/\n\n    task   = thread->task;\n    node_r = get_node_of_thread (thread);\n    node_s = get_node_for_task_by_name (thread->task->Ptask, mess->ori);\n\n    task_source = locate_task (task->Ptask, mess->ori);\n    /* S'obte el tipus de communicaci\u00f3 */\n    kind = get_communication_type (task_source,\n            task,\n            mess->mess_tag,\n            mess->mess_size,\n            &connection);\n\n    if (kind == EXTERNAL_NETWORK_COM_TYPE &&\n            external_comm_library_loaded == TRUE)\n    {\n        /* JGG (28/10/2004): if the communication occurs between nodes and\n           the external library is loaded, we check which model is going to be\n           used, a regular Dimemas model or an external model defined in the library\n           (EXTERNAL_MODEL_COM_TYPE).*/\n        kind = external_get_communication_type(node_s->nodeid,\n                node_r->nodeid,\n                mess->ori,\n                task->taskid,\n                mess->mess_tag,\n                mess->mess_size);\n    }\n\n    mess->comm_type = kind;\n\n    if (thread->startup_done == FALSE)\n    { /* Compute startup duration and re-schedule thread if needed */\n        // startup = compute_startup (thread, kind, node_s, connection);\n\n        startup = compute_startup (thread,\n                mess->ori,            /* Sender */\n                thread->task->taskid, /* Receiver */\n                node_s,\n                node_r,\n                mess->mess_tag,\n                mess->mess_size,\n                kind,\n                connection);\n\n        if (startup > (t_nano) 0) /* Change != with > */\n        { /* Positive startup time. Thread must be re-scheduled */\n            if (!wait_logical_recv)\n            {\n                thread->logical_recv = current_time;\n            }\n\n            thread->loose_cpu     = FALSE;\n            thread->doing_startup = TRUE;\n\n            account = current_account (thread);\n            FLOAT_TO_TIMER (startup, tmp_timer);\n            ADD_TIMER (account->latency_time, tmp_timer, account->latency_time);\n            SUB_TIMER (account->cpu_time, tmp_timer, account->cpu_time);\n\n            SCHEDULER_thread_to_ready_return (M_COM, thread, startup, 0);\n\n            if (debug & D_COMM)\n            {\n                PRINT_TIMER (current_time);\n                printf (\": COMMUNIC_Irecv\\tP%02d T%02d (t%02d) Initiate startup (%f)\\n\",\n                        IDENTIFIERS (thread),\n                        (double) startup / 1e9);\n            }\n\n            return;\n        }\n        else if (startup == (t_nano) 0)\n        {\n            if (!wait_logical_recv)\n            {\n                thread->logical_recv = current_time;\n            }\n            thread->startup_done = TRUE;\n        }\n    }\n\n\n    /* Copy latency operations */\n    if (DATA_COPY_enabled && mess->mess_size <= DATA_COPY_message_size)\n    {\n        if (thread->copy_done == FALSE)\n        {\n\n            dimemas_timer copy_latency = compute_copy_latency (thread, node_s, mess->mess_size, mess->comm_type);\n\n            if (copy_latency != (t_nano) 0)\n            {\n                thread->loose_cpu     = FALSE;\n                thread->doing_copy    = TRUE;\n\n                account = current_account (thread);\n                FLOAT_TO_TIMER (copy_latency, tmp_timer);\n                ADD_TIMER (account->latency_time, tmp_timer, account->latency_time);\n                SUB_TIMER (account->cpu_time, tmp_timer, account->cpu_time);\n\n                SCHEDULER_thread_to_ready_return (M_COM, thread, copy_latency, 0);\n\n                if (debug & D_COMM)\n                {\n                    PRINT_TIMER (current_time);\n                    printf (\n                            \": COMMUNIC_Irecv\\tP%02d T%02d (t%02d) Initiate copy latency (%f)\\n\",\n                            IDENTIFIERS (thread),\n                            (double) copy_latency / 1e9,\n                            mess->mess_size);\n                }\n                return;\n            }\n            else\n            {\n                thread->copy_done = TRUE;\n            }\n        }\n    }\n\n\n    thread->startup_done = FALSE;\n    thread->copy_done    = FALSE;\n\n    account = current_account (thread);\n#endif /* ! STARTUP_ALS_IRECV */\n\n    // #else\n\n    /*\n       if (!wait_logical_recv)\n       {\n       thread->logical_recv = current_time;\n       }\n       */\n\n\n    // #endif /* STARTUP_ALS_IRECV ***************************************************/\n\n    if (with_deadlock_analysis)\n    {\n        if (DEADLOCK_new_communic_event(thread))\n            return;\n    }\n\n    if (!wait_logical_recv)\n    {\n        irecv_notification = (struct t_recv*) malloc(sizeof(struct t_recv));\n        memcpy(irecv_notification, mess, sizeof(struct t_recv));\n        irecv_notification->logical_recv = current_time;\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC_Irecv\\tP%02d T%02d (t%02d) IRecv notification Comm.Id: %d saved\\n\",\n                    IDENTIFIERS (thread),\n                    mess->communic_id);\n        }\n    }\n\n    /* FEC: S'avisa que s'ha arribat a aquest Irecv i s'obte si\n     * cal desbloqejar un send o no. */\n    if (mess->ori_thread == -1)\n    {\n        /* this is a real MPI transfer */\n        hi_ha_send_sync = COMMUNIC_recv_reached_real_MPI_transfer (thread, mess);\n\n        if (!wait_logical_recv)\n        {\n            inFIFO_queue(&(thread->task->irecvs_executed), (char*) irecv_notification);\n        }\n    }\n    else\n    {\n        /* this is a dependency synchronization */\n        hi_ha_send_sync = COMMUNIC_recv_reached_dependency_synchronization (thread, mess);\n\n        if (!wait_logical_recv)\n        {\n            inFIFO_queue(&(thread->irecvs_executed), (char*) irecv_notification);\n        }\n    }\n\n    if (hi_ha_send_sync)\n    {\n        /* Per poder executar aixo cal haver comprovat que el send que correspon\n         * a aquest Irecv es realment sincron, perque si no es aixi, pot ser que\n         * el Irecv ja hagi rebut el missatge a traves d'un send asincron i,\n         * per tant, estariem desbloquejant el send corresponent a algun Irecv\n         * futur. */\n        if (mess->ori_thread == -1)\n        {\n            /* this is for a real MPI transfer */\n            Start_communication_if_partner_ready_for_rendez_vous_real_MPI_transfer (thread, mess);\n        }\n        else\n        {\n            /* this is for a dependency synchronization */\n            Start_communication_if_partner_ready_for_rendez_vous_dependency_synchronization (thread, mess);\n        }\n    }\n\n    thread->action = action->next;\n    READ_free_action(action);\n    if (more_actions (thread) )\n    {\n        thread->loose_cpu = FALSE;\n        SCHEDULER_thread_to_ready (thread);\n    }\n}\n\n\n/******************************************************************************\n * PROCEDURE 'COMMUNIC_wait'                                                  *\n * \u00daLTIMA MODIFICACI\u00d3N: 04/11/2004 (Juan Gonz\u00e1lez Garc\u00eda)                     *\n ******************************************************************************\n *\n * Es el tractament que cal aplicar a un Wait. Consisteix en\n * esperar fins que s'hagi rebut el missatge.\n */\nvoid COMMUNIC_wait (struct t_thread *thread)\n{\n    struct t_action               *action;\n    struct t_recv                 *mess;\n    struct t_task                 *task, *task_source;\n    struct t_account              *account;\n    dimemas_timer                  tmp_timer;\n    struct t_node                 *node_r, *node_s;\n    t_nano                        startup, copy_latency;\n    int                            kind;\n    struct t_dedicated_connection *connection;\n\n\n    action = thread->action;\n    if (action->action != WAIT)\n    {\n        panic (\"Calling COMMUNIC_wait and action is not Wait (%d)\\n\",\n                action->action);\n    }\n    mess    = & (action->desc.recv);\n\n\n    /* DEBUG */\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \":----calling COMMUNIC_wait   P%02d T%02d (t%02d) <- T%02d t%d Tag: %d Comm.Id: %d size: %lld\\n\",\n                IDENTIFIERS (thread),\n                action->desc.recv.ori,\n                action->desc.recv.ori_thread,\n                mess->mess_tag,\n                mess->communic_id,\n                action->desc.recv.mess_size);\n    }\n\n    task   = thread->task;\n    node_r = get_node_of_thread (thread);\n    node_s = get_node_for_task_by_name (thread->task->Ptask, mess->ori);\n\n    task_source = locate_task (task->Ptask, mess->ori);\n    /* S'obte el tipus de communicaci\u00f3 */\n    kind = get_communication_type (task_source,\n            task,\n            mess->mess_tag,\n            mess->mess_size,\n            &connection);\n\n    if (kind == EXTERNAL_NETWORK_COM_TYPE &&\n            external_comm_library_loaded == TRUE)\n    {\n        /* JGG (28/10/2004): if the communication occurs between nodes and\n           the external library is loaded, we check which model is going to be\n           used, a regular Dimemas model or an external model defined in the library\n           (EXTERNAL_MODEL_COM_TYPE).*/\n        kind = external_get_communication_type(node_s->nodeid,\n                node_r->nodeid,\n                mess->ori,\n                task->taskid,\n                mess->mess_tag,\n                mess->mess_size);\n    }\n\n    mess->comm_type = kind;\n\n    if (thread->startup_done == FALSE)\n    {\n        // startup = compute_startup (thread, kind, node_s, connection);\n        startup = compute_startup (thread,\n                mess->ori,            /* Sender */\n                thread->task->taskid, /* Receiver */\n                node_s,\n                node_r,\n                mess->mess_tag,\n                mess->mess_size,\n                kind,\n                connection);\n\n        if (startup != (t_nano) 0)\n        {\n            if (debug & D_COMM)\n            {\n                PRINT_TIMER (current_time);\n                printf (\": COMMUNIC_wait\\tP%02d T%02d (t%02d) Initiate startup (%f)\\n\",\n                        IDENTIFIERS (thread),\n                        (double) startup / 1e9);\n            }\n            thread->loose_cpu     = FALSE;\n            thread->doing_startup = TRUE;\n\n            account = current_account (thread);\n            FLOAT_TO_TIMER (startup, tmp_timer);\n            ADD_TIMER (account->latency_time, tmp_timer, account->latency_time);\n            SUB_TIMER (account->cpu_time, tmp_timer, account->cpu_time);\n\n            SCHEDULER_thread_to_ready_return (M_COM, thread, startup, 0);\n            return;\n        }\n        else\n        {\n            thread->startup_done = TRUE;\n        }\n    }\n    else\n    {\n    }\n\n    /* Copy latency operations */\n    if (DATA_COPY_enabled && mess->mess_size <= DATA_COPY_message_size)\n    {\n        if (thread->copy_done == FALSE)\n        {\n            copy_latency = compute_copy_latency (thread, node_s, mess->mess_size, mess->comm_type);\n\n            if (copy_latency != (t_nano) 0)\n            {\n                thread->loose_cpu     = FALSE;\n                thread->doing_copy    = TRUE;\n\n                account = current_account (thread);\n                FLOAT_TO_TIMER (copy_latency, tmp_timer);\n                ADD_TIMER (account->latency_time, tmp_timer, account->latency_time);\n                SUB_TIMER (account->cpu_time, tmp_timer, account->cpu_time);\n\n                SCHEDULER_thread_to_ready_return (M_COM, thread, copy_latency, 0);\n\n                if (debug & D_COMM)\n                {\n                    PRINT_TIMER (current_time);\n                    printf (\": COMMUNIC_wait\\tP%02d T%02d (t%02d) Initiate copy latency (%f)\\n\",\n                            IDENTIFIERS (thread),\n                            (double) copy_latency / 1e9);\n                }\n                return;\n            }\n        }\n    }\n\n    /* Startup and Copy checks reset */\n    thread->startup_done = FALSE;\n    thread->copy_done    = FALSE;\n\n    if (with_deadlock_analysis)\n    {\n        if (DEADLOCK_new_communic_event(thread))\n            return;\n    }\n\n    account = current_account (thread);\n    account->n_recvs++;\n    account = current_account (thread);\n\n    if (wait_logical_recv)\n    {\n        thread->logical_recv = current_time;\n    }\n\n    t_boolean Is_message_awaiting;\n\n    if (mess->ori_thread == -1)\n    {\n        Is_message_awaiting = is_message_awaiting_real_MPI_transfer (\n                task, mess, thread);\n    }\n    else\n    {\n        Is_message_awaiting = is_message_awaiting_dependency_synchronization (\n                task, mess, thread);\n    }\n\n    if (Is_message_awaiting)                      /* 'is_message_awaiting'      */\n    {\n        /* El mensaje ya se ha recibido. 'is_message_awaiting' ya se encarga de\n         * desencolar los elementos en consecuencia, por lo que el 'wait' ya se\n         * considera finalizado */\n\n        account->n_recvs_on_processor++;\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC_wait/recv\\tP%02d T%02d (t%02d) <- T%02d t%d Tag: %d Comm.Id: %d (Local message)\\n\",\n                    IDENTIFIERS (thread),\n                    action->desc.recv.ori,\n                    action->desc.recv.ori_thread,\n                    mess->mess_tag,\n                    mess->communic_id\n                   );\n        }\n\n        thread->action = action->next;\n        READ_free_action(action);\n        if (more_actions (thread) )\n        {\n            thread->loose_cpu = FALSE;\n            SCHEDULER_thread_to_ready (thread);\n        }\n    }\n    else\n    {\n        /* Start_communication_if_partner_ready_for_rendez_vous assumes\n         * thread is receiver, so locate receiver task */\n        if (mess->ori_thread == -1)\n        {\n            /* this is for a real MPI transfer */\n            Start_communication_if_partner_ready_for_rendez_vous_real_MPI_transfer (thread, mess);\n        }\n        else\n        {\n            /* this is for a dependency synchronization */\n            Start_communication_if_partner_ready_for_rendez_vous_dependency_synchronization (thread, mess);\n        }\n\n        if (node_r->machine->scheduler.busywait_before_block)\n        {\n            SCHEDULER_thread_to_busy_wait (thread);\n        }\n        else\n        {\n            account->n_recvs_must_wait++;\n            thread->start_wait_for_message = current_time;\n            if (debug & D_COMM)\n            {\n                PRINT_TIMER (current_time);\n                printf (\n                        \": COMMUNIC_wait/recv\\tP%02d T%02d (t%02d) <- T%02d t%d Tag: %d Comm.Id: %d (Waiting)\\n\",\n                        IDENTIFIERS (thread),\n                        action->desc.recv.ori,\n                        action->desc.recv.ori_thread,\n                        mess->mess_tag,\n                        mess->communic_id\n                       );\n            }\n\n            if (mess->ori_thread == -1) {\n                /* this is a regular MPI transfer\n                   put it on the recv list of the task */\n                inFIFO_queue (& (task->recv), (char *) thread);\n            }\n            else {\n                /* this is a dependency synchronization\n                   put it on the recv list of the thread  */\n                inFIFO_queue (& (thread->recv), (char *) thread);\n            }\n        }\n    }\n}\n\nvoid COMMUNIC_block_after_busy_wait (struct t_thread *thread)\n{\n    struct t_task    *task;\n    struct t_account *account;\n    struct t_action  *action;\n    struct t_recv    *mess;\n\n    task = thread->task;\n    action = thread->action;\n    mess = & (action->desc.recv);\n    account = current_account (thread);\n    account->n_recvs_must_wait++;\n    thread->start_wait_for_message = current_time;\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": COMMUNIC_recv/wait P%02d T%02d (t%02d) <- T%02d Tag(%d) Block after Busy Wait\\n\",\n                IDENTIFIERS (thread),\n                mess->ori,\n                mess->mess_tag\n               );\n    }\n\n    if (mess->ori_thread == -1) {\n        /* this is a regular MPI transfer\n           put it on the recv list of the task */\n        inFIFO_queue (& (task->recv), (char *) thread);\n    }\n    else {\n        /* this is a dependency synchronization\n           put it on the recv list of the thread  */\n        inFIFO_queue (& (thread->recv), (char *) thread);\n    }\n}\n\nint get_global_op_id_by_name (char *name)\n{\n    struct t_global_op_definition * glop;\n\n    for (glop = (struct t_global_op_definition *) head_queue (&Global_op);\n            glop != (struct t_global_op_definition *) 0;\n            glop = (struct t_global_op_definition *) next_queue (&Global_op) )\n    {\n        if (strcmp (glop->name, name) == 0)\n            return (glop->identificator);\n    }\n    return (-1);\n}\n\nvoid add_global_ops (void)\n{\n    int i;\n\n    for (i = 0; i < GLOBAL_OPS_COUNT; i++)\n    {\n        new_global_op (i, Global_Ops_Labels[i]);\n    }\n}\n\nstatic void inicialitza_info_nova_globalop (int                            model,\n        struct t_global_op_definition *glop,\n        struct t_queue                *cua)\n{\n    struct t_global_op_information *glop_info;\n\n    switch (model) /* Aixo \u00e9s absurd */\n    {\n        case GOP_MODEL_0:\n        case GOP_MODEL_CTE:\n        case GOP_MODEL_LIN:\n        case GOP_MODEL_LOG:\n            break;\n        default:\n            panic (\"Unexpected Global operation model\\n\");\n            break;\n    }\n\n    glop_info = (struct t_global_op_information *)\n        query_prio_queue (cua,\n                (t_priority) glop->identificator);\n\n    if (glop_info != (struct t_global_op_information *) 0)\n    { /* Aixo no hauria de passar mai! */\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": WARNING ('inicialitza_info_nova_globalop'): Global operation %s (%d) already exists\\n\",\n                    glop->name,\n                    glop->identificator\n                   );\n        }\n    }\n\n    glop_info = (struct t_global_op_information *)\n        malloc (sizeof (struct t_global_op_information) );\n\n    glop_info->identificator = glop->identificator;\n    glop_info->FIN_model     = model;\n    glop_info->FIN_size      = GOP_SIZE_CURR;\n    glop_info->FOUT_model    = model;\n    glop_info->FOUT_size     = GOP_SIZE_CURR;\n\n    insert_queue (cua, (char *) glop_info, (t_priority) glop->identificator);\n}\n\nvoid new_global_op (int         identificator,\n        const char *name)\n{\n    struct t_global_op_definition  *glop;\n    struct t_machine  *machine;\n    size_t             machines_it;\n\n    /* Es guarda la definicio d'aquesta operaci\u00f3 col.lectiva */\n    glop = (struct t_global_op_definition *)\n        query_prio_queue (&Global_op, (t_priority) identificator);\n\n    if (glop != GOPD_NIL)\n    {\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": WARNING ('new_global_op'): Global operation %s (%d) already exists\\n\",\n                    glop->name,\n                    glop->identificator\n                   );\n        }\n    }\n\n    glop = (struct t_global_op_definition *)\n        malloc (sizeof (struct t_global_op_definition) );\n\n    glop->name          = strdup (name);\n    glop->identificator = identificator;\n\n    insert_queue (&Global_op, (char *) glop, (t_priority) identificator);\n\n    /* S'hauria de guardar informaci\u00f3 d'aquesta operaci\u00f3 per cada m\u00e0quina */\n    /* JGG (2012/01/17): new ways to navigate through machines\n       for (machine  = (struct t_machine *) head_queue(&Machine_queue);\n       machine != MA_NIL;\n       machine  = (struct t_machine *) next_queue(&Machine_queue))\n       {\n       */\n    for (machines_it = 0; machines_it < Simulator.number_machines; machines_it++)\n    {\n        machine = &Machines[machines_it];\n\n        inicialitza_info_nova_globalop (machine->communication.global_op_model,\n                glop,\n                &machine->communication.global_ops_info);\n    }\n\n    /* Es fa el mateix per la xarxa externa */\n    inicialitza_info_nova_globalop (Simulator.wan.global_op_model,\n            glop,\n            &Simulator.wan.global_ops_info);\n}\n\n/*\n * Transfer message time function\n */\n/*t_nano */\nvoid transferencia (long long int                  size,\n        int                            communication_type,\n        struct t_thread               *thread,\n        struct t_dedicated_connection *connection,\n        t_nano                        *temps_total,\n        t_nano                        *temps_recursos)\n{\n    struct t_node    *node, *node_partner;\n    struct t_machine *machine;\n    struct t_task    *task, *task_partner;\n    t_nano           bandw, temps, t_recursos;\n\n    node    = get_node_of_thread (thread);\n    machine = node->machine;\n    task_partner = locate_task (thread->task->Ptask,\n            thread->action->desc.send.dest);\n\n    switch (communication_type)\n    {\n        case MEMORY_COMMUNICATION_TYPE:  /* Es un missatge local al node */\n            if (node->bandwidth == (t_nano) 0)\n            {\n                temps      = 0;\n                t_recursos = 0;\n            }\n            else\n            {\n                /* Transmission time with available bandwidth (including bus contention) */\n                bandw = recompute_memory_bandwidth(thread);\n                thread->last_comm.bandwidth = bandw;\n                thread->last_comm.bytes     = size;\n                ASS_ALL_TIMER (thread->last_comm.ti, current_time);\n                temps = (bandw * size);\n\n                /* Transmission time with full bandwidth (actual resource usage) */\n                bandw = bw_ns_per_byte(node->bandwidth);\n                t_recursos = (bandw * size);\n            }\n            break;\n\n        case INTERNAL_NETWORK_COM_TYPE:\n            if (machine->communication.remote_bandwidth == (t_nano) 0)\n            {\n                temps      = 0;\n                t_recursos = 0;\n            }\n            else\n            {\n                bandw = recompute_internal_network_bandwidth (thread);\n                thread->last_comm.bandwidth = bandw;\n                thread->last_comm.bytes    = size;\n                ASS_ALL_TIMER (thread->last_comm.ti, current_time);\n                temps = (bandw * size);\n                /* Es calcula el temps d'utilitzaci\u00f3 dels recursos amb l'ample\n                   de banda maxim possible */\n                bandw = (t_nano) machine->communication.remote_bandwidth;\n\n                if (bandw != 0)\n                {\n                    bandw = bw_ns_per_byte (bandw);\n                }\n\n                t_recursos = (bandw * size);\n            }\n            break;\n\n        case EXTERNAL_NETWORK_COM_TYPE:\n            if (Simulator.wan.bandwidth == (t_nano) 0)\n            {\n                temps      = 0;\n                t_recursos = 0;\n            }\n            else\n            {\n                recompute_external_network_traffic (size);\n                bandw = recompute_external_network_bandwidth (thread);\n                /* Aqui es passa de Mbytes/sec a microsegons/byte. */\n                bandw = bw_ns_per_byte (bandw);\n                thread->last_comm.bandwidth = bandw;\n                thread->last_comm.bytes    = size;\n                ASS_ALL_TIMER (thread->last_comm.ti, current_time);\n                temps = (bandw * size);\n\n                node_partner = get_node_of_task (task_partner);\n\n                temps +=\n                    Simulator.wan.flight_times[node->machine->id][node_partner->machine->id];\n\n                /* Es calcula el temps d'utilitzaci\u00f3 dels recursos amb l'ample\n                   de banda maxim possible */\n                bandw = (t_nano) Simulator.wan.bandwidth;\n                if (bandw != 0)\n                {\n                    bandw = bw_ns_per_byte (bandw);\n                }\n                t_recursos = (bandw * size);\n            }\n            break;\n\n        case DEDICATED_CONNECTION_COM_TYPE:\n            /* En aquest cas el parametre connection no pot ser NULL */\n            if (connection->bandwidth == (t_nano) 0)\n            {\n                temps      = 0;\n                t_recursos = 0;\n            }\n            else\n            {\n                /* Se suposa que els \"busos\" de la connexio no seran mai compartits\n                   i, per tant, no caldra mai recalcular l'ample de banda */\n                bandw = bw_ns_per_byte (connection->bandwidth);\n                thread->last_comm.bandwidth = bandw;\n                thread->last_comm.bytes = size;\n                ASS_ALL_TIMER (thread->last_comm.ti, current_time);\n                temps = (bandw * size);\n                /* Falta sumar-hi el flight time*/\n                temps += connection->flight_time;\n                /* Es calcula el temps d'utilitzaci\u00f3 dels recursos */\n                t_recursos = (bandw * size);\n            }\n            break;\n\n        case EXTERNAL_MODEL_COM_TYPE:\n            /* Logica para c\u00e1lcular el tiempo de ocupaci\u00f3n de la red NO Dimemas */\n            if (external_comm_library_loaded == FALSE)\n            {\n                panic(\"Computing transfer time through external model not defined\\n\");\n            }\n\n            node_partner = get_node_of_task (task_partner);\n\n            bandw = get_bandwidth_value(node->nodeid,\n                    node_partner->nodeid,\n                    thread->task->taskid,\n                    task_partner->taskid,\n                    thread->action->desc.send.mess_tag,\n                    size);\n\n            if (bandw != 0)\n            {\n                bandw = bw_ns_per_byte (bandw);\n            }\n            temps = (bandw * size);\n            t_recursos = (bandw * size);\n            break;\n\n        case ACCELERATOR_COM_TYPE:  /* Es un missatge local al node entre CPU i GPU */\n            assert(node->accelerator);\n            if (node->acc.bandwidth == (t_bandwidth) 0)\n            {\n                temps   = 0;\n                t_recursos = 0;\n            }\n            else\n            {\n                /* Transmission time with available bandwidth (including bus contention) */\n                bandw = recompute_accelerator_bandwidth(thread);\n                thread->last_comm.bandwidth = bandw;\n                thread->last_comm.bytes     = size;\n                thread->last_comm.ti        = current_time;\n\n                temps = (bandw * size);\n\n                /* Transmission time with full bandwidth (actual resource usage) */\n                /* Selects the appropriate bandwidth\t*/\n                bandw = bw_ns_per_byte(node->acc.bandwidth);\n\n                t_recursos = (bandw * size);\n            }\n            break;\n        default:\n            panic (\"Unknown communication type!\\n\");\n            break;\n    }\n\n    if (temps_total != NULL)\n    {\n        *temps_total = temps;\n    }\n\n    /* Si es volia calcular el temps d'ocupacio dels recursos, tambe s'ha\n       de retornar. */\n    if (temps_recursos != NULL)\n    {\n        *temps_recursos = t_recursos;\n    }\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf\n            (\n             \": TRANSFERENCIA\\tP%02d T%02d (t%02d) -> T%d Size: %lldb Time: %.9f Rsrc_Time: %.9f\\n\",\n             IDENTIFIERS (thread),\n             task_partner->taskid,\n             size,\n             temps / 1e9,\n             t_recursos / 1e9\n            );\n    }\n\n    /* Es retorna el temps necessari estimat per fer la transferencia */\n    /* return(temps); */\n}\n\n\n\n#define COMPROVA_CONDICIO_MIDA_CONNEXIO(c_size,c_cond, m_size) \\\n    ( \\\n      (c_cond==0)? (m_size < c_size) : /* < */\\\n      ((c_cond==1)? (m_size == c_size) : /* = */\\\n       (m_size > c_size))   /* > */\\\n       )\n\nint connection_can_be_used (struct t_dedicated_connection *connection,\n        int mess_tag,\n        int mess_size)\n{\n    int i;\n    int res, res_size1, res_size2;\n\n    /* Es comprova si el tag donat pot utilitzar la connexio dedicada */\n    for (i = 0; i < connection->number_of_tags; i++)\n    {\n        if (connection->tags[i] == mess_tag) break;\n    }\n\n    if (i == connection->number_of_tags) /* El tag no es permes */\n        return (0);\n\n    /* Es comprova si la mida del missatge esta dins del marge permes */\n    res_size1 = COMPROVA_CONDICIO_MIDA_CONNEXIO (connection->first_message_size,\n            connection->first_size_condition,\n            mess_size);\n    res_size2 = COMPROVA_CONDICIO_MIDA_CONNEXIO (connection->second_message_size,\n            connection->second_size_condition,\n            mess_size);\n\n    res = ( (connection->operation == 0) ? (res_size1 && res_size2) : /* AND */\n            (res_size1 || res_size2) ); /* OR */\n\n    /*\n       printf(\"Connexio %d tag %d mida %d: res1 %d res2 %d res %d\\n\",\n       connection->id, mess_tag, mess_size, res_size1, res_size2, res);\n       */\n    return (res);\n}\n\n\nint get_communication_type (struct t_task *task,\n        struct t_task *task_partner,\n        int mess_tag,\n        int mess_size,\n        struct t_dedicated_connection **connection)\n{\n    int result_type;\n    struct t_node  *node, *node_partner;\n    struct t_machine *s_machine, *d_machine;\n    struct t_dedicated_connection *d_con;\n\n    node         = get_node_of_task (task);\n    node_partner = get_node_of_task (task_partner);\n\n    if (node == node_partner && (mess_tag == CUDA_TAG || mess_tag == OCL_TAG))\n    { /* Es un missatge local entre CPU i GPU */\n        if (!node->accelerator || !task->accelerator)\n        {\n            panic(\"Error in accelerator communication type in a non-accelerator task (check configuration file)\");\n        }\n        result_type = ACCELERATOR_COM_TYPE;\n    }\n\n    else if (node == node_partner)\n    {\n        /* Es un missatge local al node */\n        result_type = MEMORY_COMMUNICATION_TYPE;\n    }\n    else if (node->machine == node_partner->machine)\n    {\n        /* Es un missatge de la xarxa interna a la maquina */\n        result_type = INTERNAL_NETWORK_COM_TYPE;\n    }\n    else\n    {\n        /* Es un missatge entre dues maquines diferents */\n        /* Cal mirar si s'utilitza la xarxa externa o una connexio dedicada */\n        s_machine = node->machine;\n        d_machine = node_partner->machine;\n        for (\n                d_con = (struct t_dedicated_connection *)\n                head_queue (& (s_machine->dedicated_connections.connections) );\n                d_con != DC_NIL;\n                d_con = (struct t_dedicated_connection *)\n                next_queue (& (s_machine->dedicated_connections.connections) ) )\n        {\n            if (\n                    ( (d_con->source_id == s_machine->id) &&\n                      (d_con->destination_id == d_machine->id) ) || /* Sentit normal */\n                    ( (d_con->source_id == d_machine->id) &&\n                      (d_con->destination_id == s_machine->id) ) ) /* Sentit invers */\n            {\n                /* La connexio es entre les dues maquines correctes. Nomes\n                   cal mirar si es pot utilitzar per aquest missatge concret. */\n                if (connection_can_be_used (d_con, mess_tag, mess_size) )\n                    break;\n            }\n        }\n        if (d_con != DC_NIL)\n        {\n            /* Hem d'utilitzar una connexio dedicada, que s'ha de retornar\n               al parametre connection a no ser que sigui NULL */\n            if (connection != NULL)\n            {\n                *connection = d_con;\n            }\n            result_type = DEDICATED_CONNECTION_COM_TYPE;\n        }\n        else /* Hem d'utilitzar la xarxa externa */\n        {\n            result_type = EXTERNAL_NETWORK_COM_TYPE;\n        }\n    }\n    return result_type;\n}\n\nvoid really_send_memory_message (struct t_thread *thread)\n{\n    struct t_node            *node;\n    struct t_machine         *machine;\n    struct t_task            *task, *task_partner;\n    struct t_action          *action;\n    struct t_account         *account;\n    struct t_send            *mess;\n    struct t_bus_utilization *bus_utilization;\n\n    t_nano                    ti, t_recursos;\n    dimemas_timer             tmp_timer, tmp_timer2;\n\n    node    = get_node_of_thread (thread);\n    machine = node->machine;\n    task    = thread->task;\n    action  = thread->action;\n    mess    = & (action->desc.send);\n\n    task_partner = locate_task (task->Ptask, mess->dest);\n\n    if (LINKS_get_mem_links(thread, task, task_partner) )\n    {\n        if (node->max_memory_messages != 0)\n        {\n            if (machine->communication.policy == COMMUNIC_FIFO)\n            {\n                if (node->cur_memory_messages >= node->max_memory_messages)\n                {\n                    if (debug & D_COMM)\n                    {\n                        PRINT_TIMER (current_time);\n                        printf (\": COMMUNIC_send\\tP%02d T%02d (t%02d) Blocked (Waiting intra-node)\\n\",\n                                IDENTIFIERS (thread));\n                    }\n                    inFIFO_queue (&node->wait_for_mem_bus, (char *) thread);\n                    /* FEC: Comenc,a el temps que el thread passa esperant un bus */\n                    START_BUS_WAIT_TIME (thread);\n                    /**************************************************************/\n\n                    return;\n                }\n\n                if (debug & D_COMM)\n                {\n                    PRINT_TIMER (current_time);\n                    printf (\": COMMUNIC_send\\tP%02d T%02d (t%02d) Obtains bus\\n\",\n                            IDENTIFIERS (thread) );\n                    // printf (\"\\n\\nNow I should proceed to transfering the message\\n\");\n                }\n            }\n            node->cur_memory_messages++;\n            bus_utilization = (struct t_bus_utilization *)\n                malloc (sizeof (struct t_bus_utilization) );\n            bus_utilization->sender = thread;\n            ASS_ALL_TIMER (bus_utilization->initial_time, current_time);\n            inFIFO_queue (&node->threads_in_memory, (char*) bus_utilization);\n        }\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC_send\\tP%02d T%02d (t%02d) -> T%02d Tag(%d) SEND (MEMORY)\\n\",\n                    IDENTIFIERS (thread),\n                    mess->dest,\n                    mess->mess_tag\n                   );\n        }\n\n        account = current_account (thread);\n        SUB_TIMER (current_time, thread->initial_communication_time, tmp_timer);\n        ADD_TIMER (tmp_timer,\n                account->block_due_resources, account->block_due_resources);\n        thread->physical_send = current_time;\n        thread->last_paraver  = current_time;\n        /* ti = transferencia(mess->mess_size, comm_type, thread,NULL, &t_recursos); */\n        transferencia (mess->mess_size,\n                MEMORY_COMMUNICATION_TYPE,\n                thread,\n                NULL,\n                &ti,\n                &t_recursos);\n\n        if (t_recursos > ti)\n        {\n            /* DEBUG */\n            printf (\"Memory communication. Resources time = %f - Transfer Time = %f\\n\",\n                    t_recursos,\n                    ti);\n\n            panic (\"resources > transmission time!\\n\");\n\n        }\n        /* Abans de programar la fi de la comunicacio, es programa la fi de la\n         * utilitzaci\u00f3 dels recursos reservats. */\n        FLOAT_TO_TIMER (t_recursos, tmp_timer);\n        ADD_TIMER (current_time, tmp_timer, tmp_timer);\n\n        /* tmp_timer has the time for COM_TIMER_OUT_RESOURCES */\n        /* Es programa el final de la comunicaci\u00f3 punt a punt. */\n        FLOAT_TO_TIMER (ti, tmp_timer2);\n        ADD_TIMER (current_time, tmp_timer2, tmp_timer2);\n\n        EVENT_timer (tmp_timer, NOT_DAEMON, M_COM, thread, COM_TIMER_OUT_RESOURCES_MEM);\n        thread->event = EVENT_timer (tmp_timer2, NOT_DAEMON, M_COM, thread, COM_TIMER_OUT);\n\n    }\n}\n\nvoid really_send_internal_network(struct t_thread *thread)\n{\n    struct t_node            *node, *node_partner;\n    struct t_task            *task, *task_partner;\n    struct t_action          *action;\n    struct t_account         *account;\n    struct t_send            *mess;\n    struct t_bus_utilization *bus_utilization;\n    struct t_machine         *machine;\n    t_nano                   ti, t_recursos;\n    dimemas_timer             tmp_timer, tmp_timer2;\n    int                       comm_type;\n\n    node   = get_node_of_thread (thread);\n    task   = thread->task;\n    action = thread->action;\n    mess   = & (action->desc.send);\n\n    task_partner = locate_task (task->Ptask, mess->dest);\n    node_partner = get_node_of_task (task_partner);\n\n    /* Tots dos nodes son de la mateixa maquina */\n    machine = node->machine;\n\n    if (LINKS_get_network_links(thread, node, node_partner) )\n    {\n\n        /* JGG (05/11/2004): El 'comm_type' lo cogemos del mensaje, es m\u00e1s r\u00e1pido\n           comm_type =\n           (node == node_partner ? MEMORY_COMMUNICATION_TYPE : INTERNAL_NETWORK_COM_TYPE);\n           */\n\n        if (machine->communication.num_messages_on_network != 0)\n        {\n            if (machine->communication.policy == COMMUNIC_FIFO)\n            {\n                if (machine->network.curr_on_network >= machine->communication.num_messages_on_network)\n                {\n                    if (debug & D_COMM)\n                    {\n                        PRINT_TIMER (current_time);\n                        printf (\n                                \": COMMUNIC_send\\tP%02d T%02d (t%02d) Blocked (Bus Waiting)\\n\",\n                                IDENTIFIERS (thread)\n                               );\n                    }\n                    inFIFO_queue (&machine->network.queue, (char *) thread);\n                    /* FEC: Comenc,a el temps que el thread passa esperant un bus */\n                    START_BUS_WAIT_TIME (thread);\n                    /**************************************************************/\n\n                    return;\n                }\n\n                if (debug & D_COMM)\n                {\n                    PRINT_TIMER (current_time);\n                    printf (\": COMMUNIC_send\\tP%02d T%02d (t%02d) Obtains bus\\n\",\n                            IDENTIFIERS (thread) );\n                    // printf (\"\\n\\nNow I should proceed to transfering the message\\n\");\n                }\n            }\n            machine->network.curr_on_network++;\n            bus_utilization = (struct t_bus_utilization*)\n                malloc (sizeof (struct t_bus_utilization) );\n            bus_utilization->sender = thread;\n            ASS_ALL_TIMER (bus_utilization->initial_time, current_time);\n            inFIFO_queue (&machine->network.threads_on_network, (char*) bus_utilization\n                    );\n        }\n\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC_send\\tP%02d T%02d (t%02d) -> T%02d Tag(%d) SEND (INTERNAL)\\n\",\n                    IDENTIFIERS (thread),\n                    mess->dest,\n                    mess->mess_tag\n                   );\n        }\n\n        //    printf(\"\\n\\n Now I will call the actual sending of the message\\n\");\n\n        account = current_account (thread);\n        SUB_TIMER (current_time, thread->initial_communication_time, tmp_timer);\n        ADD_TIMER (tmp_timer,\n                account->block_due_resources, account->block_due_resources);\n        thread->physical_send = current_time;\n        thread->last_paraver = current_time;\n        /* ti = transferencia(mess->mess_size, comm_type, thread,NULL, &t_recursos); */\n        transferencia (mess->mess_size,\n                INTERNAL_NETWORK_COM_TYPE,\n                thread,\n                NULL,\n                &ti,\n                &t_recursos);\n\n        if (t_recursos > ti)\n        {\n            /* DEBUG\n               printf (\"Internal Network. Resources time = %f - Transfer Time = %f\\n\",\n               t_recursos,\n               ti);\n               */\n\n            panic (\"resources > transmission time!\\n\");\n\n        }\n        /* Abans de programar la fi de la comunicacio, es programa la fi de la\n         * utilitzaci\u00f3 dels recursos reservats. */\n        FLOAT_TO_TIMER (t_recursos, tmp_timer);\n        ADD_TIMER (current_time, tmp_timer, tmp_timer);\n\n        /* GRH (25/06/2008) RTT modification for rendez-vous protocol */\n        /* Round Trip Time for receives - recvs*/\n        if (RTT_enabled && mess->rendez_vous && (comm_type == INTERNAL_NETWORK_COM_TYPE) )\n        {\n            struct t_thread          *partner;\n            t_nano                  roundtriptime;\n            dimemas_timer            rtt_timer;\n\n            if (thread->roundtrip_done == FALSE)\n            {\n                roundtriptime = RTT_time / 2.0;\n                if (RTT_time != (t_nano) 0) {\n                    account = current_account (thread);\n                    FLOAT_TO_TIMER (roundtriptime, rtt_timer);\n                    ADD_TIMER (account->latency_time, rtt_timer, account->latency_time);\n\n                    ti += roundtriptime;\n                    thread->physical_send += roundtriptime;\n                }\n            }\n            /* partner must also so roundtrip time\n               partner = locate_receiver (&(task_partner->recv),\n               task->taskid,\n               mess->mess_tag,\n               mess->communic_id);\n               if (partner != TH_NIL) { } */\n        }\n\n        /* tmp_timer has the time for COM_TIMER_OUT_RESOURCES */\n        /* Es programa el final de la comunicaci\u00f3 punt a punt. */\n        FLOAT_TO_TIMER (ti, tmp_timer2);\n        ADD_TIMER (current_time, tmp_timer2, tmp_timer2);\n\n#ifdef VENUS_ENABLED\n        if ( (!VC_is_enabled() ) || (mess->comm_type != INTERNAL_NETWORK_COM_TYPE) ) {\n            EVENT_timer (tmp_timer, NOT_DAEMON, M_COM, thread, COM_TIMER_OUT_RESOURCES_NET);\n            thread->event =\n                EVENT_timer (tmp_timer2, NOT_DAEMON, M_COM, thread, COM_TIMER_OUT);\n        }\n        else\n        {\n            double dtime;\n            struct t_event *out_resources_ev;\n\n            out_resources_ev = EVENT_venus_timer (tmp_timer, NOT_DAEMON, M_COM, thread, COM_TIMER_OUT_RESOURCES_NET);\n            thread->event =\n                EVENT_venus_timer (tmp_timer2, NOT_DAEMON, M_COM, thread, COM_TIMER_OUT);\n\n            TIMER_TO_FLOAT (current_time, dtime);\n            dtime = thread->physical_send;\n            if (mess->rendez_vous)\n            {\n                VC_command_rdvz_ready (dtime, node->nodeid, node_partner->nodeid, mess->mess_tag, mess->mess_size, thread->event, out_resources_ev, task->Ptask->Ptaskid, task_partner->Ptask->Ptaskid);\n            }\n            else\n            {\n                VC_command_send (dtime, node->nodeid, node_partner->nodeid, mess->mess_tag, mess->mess_size, thread->event, out_resources_ev, task->Ptask->Ptaskid, task_partner->Ptask->Ptaskid);\n            }\n        }\n#else\n        //      printf(\"\\n\\n And to put the event stating when the communication finishes\\n\");\n        EVENT_timer (tmp_timer, NOT_DAEMON, M_COM, thread, COM_TIMER_OUT_RESOURCES_NET);\n        thread->event =\n            EVENT_timer (tmp_timer2, NOT_DAEMON, M_COM, thread, COM_TIMER_OUT);\n#endif\n    }\n}\n\nvoid really_send_external_network (struct t_thread *thread)\n{\n    struct t_node    *node, *node_partner;\n    struct t_task    *task, *task_partner;\n    struct t_action  *action;\n    struct t_account *account;\n    struct t_send    *mess;\n    t_nano           ti, t_recursos;\n    dimemas_timer     tmp_timer;\n\n    /* Si es descomenta el codi que reserva busos, tambe cal descomentar aixo:\n       struct t_bus_utilization *bus_utilization; */\n\n    node = get_node_of_thread (thread);\n    task = thread->task;\n    action = thread->action;\n    mess = & (action->desc.send);\n\n    task_partner = locate_task (task->Ptask, mess->dest);\n    node_partner = get_node_of_task (task_partner);\n\n    if (LINKS_get_wan_links(thread, node->machine, node_partner->machine) )\n    {\n        /* Aqui es guardaria l'utilitzacio del bus per despres poder recalcular els\n         * temps estimats de totes les transferencies que s'estiguessin fent per la\n         * xarxa externa quan es comen\u00e7a o s'acaba una transferencia; tot i que en\n         * realitat la xarxa externa no te busos. Pero aixo esta desactivat perque no\n         * es vol aplicar. Nomes es vol fer que es calculi el temps estimat una\n         * vegada, al comen\u00e7ar la comunicacio. Si es volgues recalcular aixo tambe\n         * caldria descomentar del recompute_external_network_bandwidth la part\n         * corresponent i del COMMUNIC_external_network_COM_TIMER_OUT descomentar\n         * on s'alliberen els busos. */\n        /*\n           bus_utilization =\n           (struct t_bus_utilization *) malloc(sizeof(struct t_bus_utilization));\n           bus_utilization->sender = thread;\n           ASS_ALL_TIMER (bus_utilization->initial_time, current_time);\n           inFIFO_queue (\n           &Simulator.wan.threads_on_network,\n           (char *)bus_utilization\n           );\n           */\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC_send\\tP%02d T%02d (t%02d) -> T%02d Tag(%d) SEND (EXTERNAL) message\\n\",\n                    IDENTIFIERS (thread),\n                    mess->dest,\n                    mess->mess_tag\n                   );\n        }\n        account = current_account (thread);\n        SUB_TIMER (current_time, thread->initial_communication_time, tmp_timer);\n        ADD_TIMER (\n                tmp_timer,\n                account->block_due_resources,\n                account->block_due_resources\n                );\n        thread->physical_send = current_time;\n        thread->last_paraver  = current_time;\n        /* ti = transferencia(\n           mess->mess_size,\n           EXTERNAL_NETWORK_COM_TYPE,\n           thread,\n           NULL,\n           &t_recursos\n           ); */\n\n        transferencia (\n                mess->mess_size,\n                EXTERNAL_NETWORK_COM_TYPE,\n                thread,\n                NULL,\n                &ti,\n                &t_recursos\n                );\n\n        if (t_recursos > ti)\n        {\n            /* DEBUG */\n            printf (\"Resources time = %.20f - Transfer Time = %.20f\\n\",\n                    t_recursos,\n                    ti);\n\n            panic (\"resources > transmission time!\\n\");\n        }\n        /* Abans de programar la fi de la comunicacio, es programa la fi de la\n           utilitzaci\u00f3 dels recursos reservats. Per\u00f2, de moment, ho deixo al\n           mateix instant de temps. */\n        FLOAT_TO_TIMER (t_recursos, tmp_timer);\n        ADD_TIMER (current_time, tmp_timer, tmp_timer);\n\n        EVENT_timer (tmp_timer, NOT_DAEMON, M_COM, thread, COM_TIMER_OUT_RESOURCES_WAN);\n        /* Es programa el final de la comunicaci\u00f3 punt a punt. */\n        FLOAT_TO_TIMER (ti, tmp_timer);\n        ADD_TIMER (current_time, tmp_timer, tmp_timer);\n        thread->event =\n            EVENT_timer (tmp_timer, NOT_DAEMON, M_COM, thread, COM_TIMER_OUT);\n    } /* endif (get_machine_links(...)) */\n}\n\nvoid really_send_dedicated_connection (struct t_thread               *thread,\n        struct t_dedicated_connection *connection)\n{\n    struct t_action  *action;\n    struct t_account *account;\n    struct t_send    *mess;\n    t_nano           ti, t_recursos;\n    dimemas_timer     tmp_timer;\n\n    action = thread->action;\n    mess   = & (action->desc.send);\n\n    if (LINKS_get_dedicated_connection_links(thread, connection) )\n    {\n        account = current_account (thread);\n        SUB_TIMER (current_time, thread->initial_communication_time, tmp_timer);\n        ADD_TIMER (\n                tmp_timer,\n                account->block_due_resources,\n                account->block_due_resources\n                );\n        thread->physical_send = current_time;\n        thread->last_paraver = current_time;\n\n        transferencia(\n           mess->mess_size,\n           DEDICATED_CONNECTION_COM_TYPE,\n           thread,\n           connection,\n           &ti,\n           &t_recursos);\n\n        if (t_recursos > ti)\n        {\n            /* DEBUG */\n            printf (\"Resources time = %.20f - Transfer Time = %.20f\\n\",\n                    t_recursos,\n                    ti);\n\n            panic (\"resources > transmission time!\\n\");\n        }\n\n        /* Abans de programar la fi de la comunicacio, es programa la fi de la\n           utilitzaci\u00f3 dels recursos reservats. Per\u00f2, de moment, ho deixo al\n           mateix instant de temps. */\n        FLOAT_TO_TIMER (t_recursos, tmp_timer);\n        ADD_TIMER (current_time, tmp_timer, tmp_timer);\n        EVENT_timer (tmp_timer,\n                NOT_DAEMON,\n                M_COM, thread,\n                COM_TIMER_OUT_RESOURCES_DED);\n\n        /* Es programa el final de la comunicaci\u00f3 punt a punt. */\n        FLOAT_TO_TIMER (ti, tmp_timer);\n        ADD_TIMER (current_time, tmp_timer, tmp_timer);\n        thread->event = EVENT_timer (\n                            tmp_timer,\n                            NOT_DAEMON,\n                            M_COM,\n                            thread,\n                            COM_TIMER_OUT);\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\": COMMUNIC\\tP%02d T%02d (t%02d) -> T%02d Tag(%d) SEND\"\\\n                    \"(DEDICATED) message\\n\",IDENTIFIERS (thread),mess->dest,\n                    mess->mess_tag);\n        }\n    }\n}\n\nvoid really_send_external_model_comm_type (struct t_thread *thread)\n{\n    struct t_action  *action;\n    struct t_account *account;\n    struct t_send    *mess;\n    t_nano            ti, t_recursos;\n    dimemas_timer     tmp_timer;\n\n    action = thread->action;\n    mess   = &(action->desc.send);\n\n    account = current_account(thread);\n    SUB_TIMER(current_time, thread->initial_communication_time, tmp_timer);\n    ADD_TIMER (\n            tmp_timer,\n            account->block_due_resources,\n            account->block_due_resources\n            );\n    thread->physical_send = current_time;\n    thread->last_paraver = current_time;\n\n    transferencia(mess->mess_size,\n            EXTERNAL_MODEL_COM_TYPE,\n            thread,\n            NULL,\n            &ti,\n            &t_recursos);\n\n    if (t_recursos>ti)\n    {\n        panic(\"resources > transmission time!\\n\");\n    }\n\n\n    FLOAT_TO_TIMER (t_recursos, tmp_timer);\n    ADD_TIMER (current_time, tmp_timer, tmp_timer);\n    EVENT_timer (\n            tmp_timer,\n            NOT_DAEMON,\n            M_COM, thread,\n            COM_TIMER_OUT_RESOURCES_EXT_MODEL\n            );\n    /* Es programa el final de la comunicaci\u00f3 punt a punt. */\n    FLOAT_TO_TIMER (ti, tmp_timer);\n    ADD_TIMER (current_time, tmp_timer, tmp_timer);\n    thread->event =\n        EVENT_timer (tmp_timer, NOT_DAEMON, M_COM, thread, COM_TIMER_OUT);\n\n    if (debug&D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": COMMUNIC_send P%02d T%02d (t%02d) -> T%d Tag(%d) SEND (OTHER) message\\n\",\n                IDENTIFIERS (thread),\n                mess->dest,\n                mess->mess_tag\n               );\n    }\n}\n\nvoid really_send_acc_message (struct t_thread\t*thread)\n{\n    struct t_node            *node;\n    struct t_machine         *machine;\n    struct t_task            *task, *task_partner;\n    struct t_action          *action;\n    struct t_account         *account;\n    struct t_send            *mess;\n    struct t_bus_utilization *bus_utilization;\n    struct t_link\t\t\t\t\t\t *link;\n\n    dimemas_timer             ti, t_recursos;\n    dimemas_timer             tmp_timer, tmp_timer2;\n\n    node    = get_node_of_thread (thread);\n    assert(node->accelerator);\n\n    machine = node->machine;\n    task    = thread->task;\n    action  = thread->action;\n    mess    = & (action->desc.send);\n\n    task_partner = locate_task (task->Ptask, mess->dest);\n\n    if (LINKS_get_acc_links(thread, task, task_partner) )\n    {\n        if (node->acc.max_messages != 0)\n        {\n            if (machine->communication.policy == COMMUNIC_FIFO)\n            {\n                if (node->acc.cur_messages >= node->acc.max_messages)\n                {\n                    if (debug & D_COMM)\n                    {\n                        PRINT_TIMER (current_time);\n                        printf (\": COMMUNIC_send\\tP%02d T%02d (t%02d) Blocked (Waiting acc node)\\n\",\n                                IDENTIFIERS (thread));\n                    }\n                    inFIFO_queue (&node->acc.wait_for_link, (char *) thread);\n                    /* FEC: Comenc,a el temps que el thread passa esperant un bus */\n                    START_BUS_WAIT_TIME (thread);\n                    /**************************************************************/\n                    return;\n                }\n\n                if (debug & D_COMM)\n                {\n                    PRINT_TIMER (current_time);\n                    printf (\": COMMUNIC_send\\tP%02d T%02d (t%02d) Obtains bus\\n\",\n                            IDENTIFIERS (thread) );\n                }\n            }\n            node->acc.cur_messages++;\n            bus_utilization = (struct t_bus_utilization *)\n                malloc (sizeof (struct t_bus_utilization) );\n            bus_utilization->sender       = thread;\n            bus_utilization->initial_time = current_time;\n            inFIFO_queue (&node->acc.threads_in_link, (char*) bus_utilization);\n\n            link = malloc(sizeof(struct t_link));\n            link->info.task = task;\n            link->info.node = node;\n            link->thread\t\t= thread;\n            link->assigned_on = current_time;\n            link->type\t\t\t\t= ACCELERATOR_LINK;\n            thread->accelerator_link = link;\n        }\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": COMMUNIC_send\\tP%02d T%02d (t%02d) -> T%02d Tag(%d) SEND (ACCELERATOR)\\n\",\n                    IDENTIFIERS (thread),\n                    mess->dest,\n                    mess->mess_tag\n                   );\n        }\n\n        account = current_account (thread);\n        SUB_TIMER (current_time, thread->initial_communication_time, tmp_timer);\n        ADD_TIMER (tmp_timer,\n                account->block_due_resources, account->block_due_resources);\n        thread->physical_send = current_time;\n        thread->last_paraver  = current_time;\n\n        transferencia(mess->mess_size,\n                ACCELERATOR_COM_TYPE,\n                thread,\n                NULL,\n                &ti,\n                &t_recursos);\n\n        if (t_recursos > ti)\n        {\n            /* DEBUG */\n            printf (\"Accelerator communication. Resources time = %f - Transfer Time = %f\\n\",\n                    t_recursos,\n                    ti);\n\n            panic (\"resources > transmission time!\\n\");\n\n        }\n        /* Abans de programar la fi de la comunicacio, es programa la fi de la\n         * utilitzaci\u00f3 dels recursos reservats. */\n        FLOAT_TO_TIMER (t_recursos, tmp_timer);\n        ADD_TIMER (current_time, tmp_timer, tmp_timer);\n\n        /* tmp_timer has the time for COM_TIMER_OUT_RESOURCES */\n        /* Es programa el final de la comunicaci\u00f3 punt a punt. */\n        FLOAT_TO_TIMER (ti, tmp_timer2);\n        ADD_TIMER (current_time, tmp_timer2, tmp_timer2);\n\n        EVENT_timer (tmp_timer, NOT_DAEMON, M_COM, thread, COM_TIMER_OUT_RESOURCES_ACC);\n        thread->event = (struct t_event*) EVENT_timer (tmp_timer2, NOT_DAEMON, M_COM, thread, COM_TIMER_OUT);\n    }\n}\n\nvoid really_send (struct t_thread *thread)\n{\n    struct t_task   *task,\n                    *task_partner;\n    struct t_action *action;\n    struct t_send   *mess;\n    int              kind, kind2;\n    struct t_dedicated_connection *connection;\n\n    task = thread->task;\n    action = thread->action;\n    mess = & (action->desc.send);\n\n    task_partner = locate_task (task->Ptask, mess->dest);\n    if (task_partner == T_NIL)\n    {\n        panic (\"Task partner not found!\\n\");\n    }\n\n    get_communication_type (task, task_partner, mess->mess_tag,\n            mess->mess_size, &connection);\n\n    kind = mess->comm_type;\n\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": COMMUNIC_send\\tP%02d T%02d (t%02d) -> T%02d Tag: %d Type: %d (Really Send)\\n\",\n                IDENTIFIERS (thread),\n                mess->dest,\n                mess->mess_tag,\n                mess->comm_type);\n    }\n\n\n    // switch (kind2)\n    switch (kind)\n    {\n        case MEMORY_COMMUNICATION_TYPE:\n            really_send_memory_message(thread);\n            break;\n        case INTERNAL_NETWORK_COM_TYPE:\n            really_send_internal_network(thread);\n            break;\n        case EXTERNAL_NETWORK_COM_TYPE:\n            really_send_external_network (thread);\n            break;\n        case DEDICATED_CONNECTION_COM_TYPE:\n            //really_send_external_network (thread);\n            really_send_dedicated_connection (thread, connection);\n            break;\n        case EXTERNAL_MODEL_COM_TYPE:\n            really_send_external_model_comm_type(thread);\n            break;\n        case ACCELERATOR_COM_TYPE:\n            really_send_acc_message(thread);\n            break;\n        default:\n            panic (\"Incorrect communication type! kind = %d, kind2 %d\", kind, kind2);\n            break;\n    } /* end switch */\n    return;\n}\n\n    struct t_communicator*\nlocate_communicator (struct t_queue *communicator_queue, int commid)\n{\n    register struct t_communicator *communicator;\n\n    for (communicator  = (struct t_communicator *) head_queue (communicator_queue);\n            communicator != (struct t_communicator *) 0;\n            communicator  = (struct t_communicator *) next_queue (communicator_queue) )\n    {\n        if (communicator->communicator_id == commid)\n        {\n            break;\n        }\n    }\n    return (communicator);\n}\n\nstatic int provide_log (int n)\n{\n    int i;\n\n    for (i = 0; i < n; i++)\n    {\n        if ( (1 << i) >= n)\n        {\n            return (i);\n        }\n    }\n\n    return (0);\n}\n\nstatic int compute_contention_stage (int ntasks, int num_busos)\n{\n    int i;\n    int j;\n    int loga;\n    int parallel_comm;\n    int total = 0;\n\n    loga = provide_log (ntasks);\n\n    /* If unlimited number of buses, contention is number of stages */\n    if (num_busos == 0)\n    {\n        return (loga);\n    }\n\n    for (i = 0; i < loga; i++)\n    {\n        parallel_comm = 0;\n        for (j = (1 << i) - 1; j < ntasks - 1; j = j + (1 << (i + 1) ) )\n        {\n#ifdef DEBUG\n            if (j + (1 << i) < ntasks)\n            {\n                printf (\"From %d to %d\\n\", j + 1, j + (1 << i) + 1);\n            }\n            else\n            {\n                printf (\"From %d to %d\\n\", j + 1, ntasks);\n            }\n#endif /* DEBUG */\n            parallel_comm ++;\n        }\n\n        if (parallel_comm % num_busos == 0)\n        {\n            total = total + parallel_comm / num_busos;\n        }\n        else\n        {\n            total = total + 1 + parallel_comm / num_busos;\n        }\n#ifdef DEBUG\n        printf (\"Stage %d parallel communications %d\\n\", i + 1, parallel_comm);\n#endif /* DEBUG */\n    }\n\n    printf(\"Contention stages = %d\\n\", total);\n\n    return (total);\n}\n\n\n/**************************************************************************\n ** Ara aquesta funcio nomes reserva tot el que cal a la maquina\n ** corresponent al thread donat (si es pot i es la primera vegada que es\n ** crida. Sino suposa que ja s'han reservat tots els busos). I, si era\n ** l'ultim thread que quedava, crida a la funcio corresponent a l'inici\n ** de l'operacio col.lectiva.\n **************************************************************************/\nvoid global_op_get_all_buses (struct t_thread *thread)\n{\n    struct t_Ptask                *Ptask;\n    struct t_communicator         *communicator;\n    struct t_global_op_definition *glop;\n    struct t_bus_utilization      *bus_utilization;\n    struct t_action               *action;\n    int                            i, comm_id, glop_id;\n    struct t_node                 *node;\n    struct t_machine              *machine;\n    int                           nb_glob_index;\n\n    nb_glob_index = thread->nb_glob_index;\n    node    = get_node_of_thread (thread);\n    machine = node->machine;\n\n    if ( (machine->communication.num_messages_on_network) \n            && (thread->number_buses == 0))\n    {\n        if (machine->network.curr_on_network != 0)\n        {\n            thread->number_buses =\n                machine->communication.num_messages_on_network -\n                machine->network.curr_on_network;\n\n            machine->network.curr_on_network =\n                machine->communication.num_messages_on_network;\n\n            inFIFO_queue (&machine->network.queue, (char *) thread);\n\n            /* FEC: Comenc,a el temps que el thread passa esperant busos */\n            START_BUS_WAIT_TIME (thread);\n            /*************************************************************/\n\n            return;\n        }\n    }\n\n    Ptask = thread->task->Ptask;\n    action = thread->action;\n    comm_id = action->desc.global_op.comm_id;\n    communicator = locate_communicator (&Ptask->Communicator, comm_id);\n\n    if (communicator == COM_NIL )\n    {\n        panic (\n                \"Communication get_buses trough an invalid \\\n                communicator %d to P%02d T%02d (t%02d)\\n\",\n                comm_id,\n                IDENTIFIERS (thread)\n              );\n    }\n\n    glop_id = action->desc.global_op.glop_id;\n    glop    = (struct t_global_op_definition *)\n        query_prio_queue (&Global_op, (t_priority) glop_id);\n\n    if (glop == (struct t_global_op_definition *) 0 )\n    {\n        panic (\n                \"Global operation %d undefined to P%02d T%02d (t%02d)\\n\",\n                glop_id,\n                IDENTIFIERS (thread)\n              );\n    }\n\n    machine->network.curr_on_network =\n        machine->communication.num_messages_on_network;\n\n    bus_utilization =\n        (struct t_bus_utilization *) malloc (sizeof (struct t_bus_utilization) );\n\n    bus_utilization->sender = thread;\n    ASS_ALL_TIMER (bus_utilization->initial_time, current_time);\n    for (i = 0; i < machine->communication.num_messages_on_network; i++)\n    {\n        inFIFO_queue (&machine->network.threads_on_network, (char*) bus_utilization);\n    }\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": GLOBAL_operation P%02d T%02d (t%02d) Gets machine %d buses to do '%s'\\n\",\n                IDENTIFIERS (thread),\n                machine->id,\n                glop->name\n               );\n    }\n    struct t_queue* comm_machine_threads;\n    if (thread->action->desc.global_op.synch_type == GLOBAL_OP_ASYN)\n    {\n\n        comm_machine_threads = (struct t_queue *) query_prio_queue(&communicator->nonblock_global_op_machine_threads, nb_glob_index);\n        //comm_machine_threads=&communicator->nonblock_global_op_machine_threads[nb_glob_index];\n    }\n    else\n    {\n        comm_machine_threads=&communicator->machines_threads;\n    }\n\n    /* Si cal obtenir links de la xarxa externa, cal fer-ho aqui */\n    if (count_queue (comm_machine_threads) > 1)\n    {\n        /* Com que hi ha mes d'una maquina cal obtenir els links cap a la\n         * xarxa externa (tant el d'entrada com el de sortida). */\n\n        /* Primer s'obtenen tots els de sortida. Quan es tenen tots s'intenten\n         * aconseguir els d'entrada. S'ha de fer aix\u00ed per evitar deadlocks.\n         * NO HI PODEN HAVER LINKS HALF-DUPLEX!!!!\n         * Per poder-ne tenir caldria fer el que es fa nom\u00e9s pels full duplex i,\n         * entre les dues fases (quan ja es tenen tots els out, pero no ens in),\n         * caldria agafar sequencialment per ordre de machine_id tots els\n         * links half duplex. Despres (o potser paral.lelament) s'hauria de fer\n         * l'altra fase (obtenir els in links de les full-duplex). */\n\n        if (LINKS_get_single_wan_link(thread, machine, OUT_LINK) )\n        {\n            /* S'han pogut obtenir el link de sortida a la xarxa externa */\n            /* A partir d'aqui aixo s'ha de fer en una funcio diferent perque\n             * no es torni a fer la reserva dels busos anterior. */\n            global_op_get_all_out_links (thread);\n        }\n        /* Si no s'han pogut obtenir s'haura bloquejat el thread i si s'han\n         * pogut obtenir ja s'haura fet el que cal. En qualsevol cas, ja es\n         * pot retornar. */\n        return;\n    }\n    else /* Si no calen els links, ja es pot passar al seguent pas */\n    {\n        global_op_get_all_out_links (thread);\n    }\n}\n\n\n/**************************************************************************\n ** Reserva els links necessaris i despres crida a global_op_get_all_links.\n **************************************************************************/\nvoid global_op_reserva_links (struct t_thread *thread)\n{\n    struct t_node *node;\n    struct t_machine *machine;\n    struct t_Ptask *Ptask;\n    struct t_communicator *communicator;\n    struct t_action *action;\n    int comm_id;\n    int nb_glob_index;\n\n    node = get_node_of_thread (thread);\n    machine = node->machine;\n    nb_glob_index = thread->nb_glob_index;\n\n    Ptask        = thread->task->Ptask;\n    action       = thread->action;\n    comm_id      = action->desc.global_op.comm_id;\n    communicator = locate_communicator (&Ptask->Communicator, comm_id);\n\n    if (communicator == (struct t_communicator *) 0)\n    {\n        panic (\"Global op get links trough an invalid communicator %d to P%02d T%02d (t%02d)\\n\",\n                comm_id, IDENTIFIERS (thread) );\n    }\n\n    struct t_queue* comm_machine_threads;\n    if (thread->action->desc.global_op.synch_type == GLOBAL_OP_ASYN)\n    {\n        comm_machine_threads = (struct t_queue *) query_prio_queue(&communicator->nonblock_global_op_machine_threads, \n                nb_glob_index);\n        //comm_machine_threads=&communicator->nonblock_global_op_machine_threads[thread->n_nonblock_glob_in_flight];\n    }\n    else\n    {\n        comm_machine_threads=&communicator->machines_threads;\n    }\n\n    /* Cal saber si s'estan reservant els links d'entrada o de sortida */\n    if (count_queue (comm_machine_threads) !=\n            count_queue (&communicator->m_threads_with_links) )\n    {\n        /* Encara falten algunes maquines per tenir tots els out_links */\n        if (LINKS_get_single_wan_link(thread, machine, OUT_LINK) )\n        {\n            /* S'han pogut obtenir els links de sortida a la xarxa externa*/\n            global_op_get_all_out_links (thread);\n        }\n    }\n    else\n    {\n        /* Ja es tenen tots els links de sortida, es busquen els d'entrada */\n        if (LINKS_get_single_wan_link(thread, machine, IN_LINK) )\n        {\n            /* S'han pogut obtenir els links d'entrada de la xarxa externa*/\n            global_op_get_all_in_links (thread);\n        }\n    }\n\n}\n\n\n\n/**************************************************************************\n ** Aquesta funcio suposa que ja s'han reservat tots els links de sortida\n ** de la maquina corresponent, cap a la xarxa externa. I, si era l'ultim\n ** thread que quedava, crida a la funcio corresponent a l'inici de la\n ** fase de reserva dels links d'entrada de la xarxa externa.\n **************************************************************************/\nstatic void global_op_get_all_out_links (struct t_thread *thread)\n{\n    struct t_Ptask                *Ptask;\n    struct t_communicator         *communicator;\n    struct t_global_op_definition *glop;\n    struct t_thread               *others;\n    struct t_action               *action;\n    struct t_node                 *node;\n    struct t_machine              *machine;\n    int                            comm_id, glop_id;\n    int                            synch_type;\n    int                            nb_glob_index;\n\n    Ptask        = thread->task->Ptask;\n    action       = thread->action;\n    comm_id      = action->desc.global_op.comm_id;\n    synch_type   = action->desc.global_op.synch_type;\n    communicator = locate_communicator (&Ptask->Communicator, comm_id);\n    nb_glob_index= thread->nb_glob_index; \n\n    struct t_queue* comm_machine_threads;\n    struct t_queue* m_threads_with_links;\n    if (synch_type == GLOBAL_OP_ASYN)\n    {\n\n        m_threads_with_links = (struct t_queue *) query_prio_queue(&communicator->nonblock_m_threads_with_links, nb_glob_index);\n        comm_machine_threads = (struct t_queue *) query_prio_queue(&communicator->nonblock_global_op_machine_threads, nb_glob_index);\n        //m_threads_with_links=&communicator->nonblock_m_threads_with_links[nb_glob_index];   \n        //comm_machine_threads=&communicator->nonblock_global_op_machine_threads[nb_glob_index];\n    }\n    else\n    {\n        m_threads_with_links=&communicator->m_threads_with_links;\n        comm_machine_threads=&communicator->machines_threads;\n    }\n\n    if (communicator == COM_NIL)\n    {\n        panic (\"Communication get_links trough an invalid communicator %d to P%02d T%02d (t%02d)\\n\",\n                comm_id,\n                IDENTIFIERS (thread) );\n    }\n\n    glop_id = action->desc.global_op.glop_id;\n    glop = (struct t_global_op_definition *)\n        query_prio_queue (&Global_op, (t_priority) glop_id);\n\n    if (glop == GOPD_NIL)\n    {\n        panic (\"Global operation %d undefined to P%02d T%02d (t%02d)\\n\",\n                glop_id,\n                IDENTIFIERS (thread) );\n    }\n\n    /* Si cal obtenir mes links de la xarxa externa, cal fer-ho aqui */\n    if (count_queue (comm_machine_threads) > 1)\n    {\n        /* D'aquesta maquina ja es disposa del link de sortida i dels busos,\n           per tant, s'ha d'indicar aixo i, si era l'ultima, ja es pot\n           comenc,ar la seguent fase. En cas contrari,\n           s'ha d'encuar aquest thread i seguir esperant. */\n\n        /* S'afegeix el thread a la cua d'aquest communicador de threads que ja\n           tenen el link de sortida reservat. */\n        inFIFO_queue (m_threads_with_links, (char *) thread);\n\n        /* Es mira si ja es tenen tots */\n        if (count_queue (m_threads_with_links) !=\n                count_queue (comm_machine_threads))\n        {\n            /* Encara falten alguns threads per acabar d'obtenir tots els\n               links de sortida. */\n            return;\n        }\n\n        /* Ja es pot comenc,ar a la fase de reserva de links d'entrada */\n        for (others  = (struct t_thread *) head_queue (comm_machine_threads);\n                others != TH_NIL;\n                others  = (struct t_thread *) next_queue (comm_machine_threads) )\n        {\n            /* Aquest thread reserva els recursos necessaris que falten de la\n               seva maquina */\n            node    = get_node_of_thread (others);\n            machine = node->machine;\n\n            if (LINKS_get_single_wan_link(others, machine, IN_LINK) )\n            {\n                /* S'han pogut obtenir els links d'entrada de la xarxa externa*/\n                global_op_get_all_in_links (others);\n            }\n        }\n        /* Si no s'han pogut obtenir s'haura bloquejat el thread i si s'han\n           pogut obtenir ja s'haura fet el que cal. En qualsevol cas, ja es\n           pot retornar. */\n        return;\n\n    }\n    else /* Si no calen els links, ja es pot passar al seguent pas */\n    {\n        global_op_get_all_in_links (thread);\n    }\n}\n\n\n/**************************************************************************\n ** Aquesta funcio suposa que ja s'han reservat tots els links de la\n ** maquina corresponent, cap a la xarxa externa. I, si era l'ultim thread\n ** que quedava, crida a la funcio corresponent a l'inici de l'operacio\n ** col.lectiva.\n **************************************************************************/\nstatic void global_op_get_all_in_links (struct t_thread *thread)\n{\n    struct t_Ptask                *Ptask;\n    struct t_communicator         *communicator;\n    struct t_global_op_definition *glop;\n    struct t_thread               *others;\n    struct t_action               *action;\n    int                            comm_id, glop_id, root_task;\n    int                            synch_type = thread->action->desc.global_op.synch_type;\n    int                            nb_glob_index;\n\n    Ptask        = thread->task->Ptask;\n    action       = thread->action;\n    comm_id      = action->desc.global_op.comm_id;\n    communicator = locate_communicator (&Ptask->Communicator, comm_id);\n    nb_glob_index= thread->nb_glob_index;\n\n    if (communicator == COM_NIL)\n    {\n        panic (\n                \"Communication get_links trough an invalid communicator %d to P%02d T%02d (t%02d)\\n\",\n                comm_id,\n                IDENTIFIERS (thread)\n              );\n    }\n\n    glop_id = action->desc.global_op.glop_id;\n    glop    = (struct t_global_op_definition *)\n        query_prio_queue (&Global_op, (t_priority) glop_id);\n\n    if (glop == GOPD_NIL)\n    {\n        panic (\"Global operation %d undefined to P%02d T%02d (t%02d)\\n\",\n                glop_id,\n                IDENTIFIERS (thread) );\n    }\n\n    /* D'aquesta maquina ja es disposa de tot el que es necessita, per tant,\n       si era l'ultima, ja es pot comenc,ar la col.lectiva. En cas contrari,\n       s'ha d'encuar aquest thread i seguir esperant. */\n\n    // Deciding which queue we have to take\n    struct t_queue *threads_queue;\n    struct t_queue *m_threads_with_links;\n    if (synch_type == GLOBAL_OP_ASYN)\n    { \n        m_threads_with_links = (struct t_queue *) query_prio_queue(&communicator->nonblock_m_threads_with_links, nb_glob_index);\n        threads_queue = (struct t_queue*) query_prio_queue(&communicator->nonblock_global_op_threads, nb_glob_index);\n        //m_threads_with_links = &communicator->nonblock_m_threads_with_links[nb_glob_index];\n        //threads_queue = &communicator->nonblock_global_op_threads[nb_glob_index];\n    }\n    else\n    {\n        m_threads_with_links = &communicator->m_threads_with_links;\n        threads_queue = &communicator->threads;\n    }\n\n    /* S'afegeix el thread a la cua de threads del communicador */\n    inFIFO_queue (threads_queue, (char *) thread);\n\n    if (count_queue(threads_queue) != communicator->size)\n    {\n        /* Encara falten alguns threads per acabar d'obtenir tot el que\n           es necessita. */\n        return;\n    }\n\n    /* Ja es pot comenc,ar a realitzar l'operacio col.lectiva */\n\n    /* Es buida la cua m_threads_with_links perque ja no es necessita */\n    for (others  = (struct t_thread *) outFIFO_queue (m_threads_with_links);\n            others != TH_NIL;\n            others  = (struct t_thread *) outFIFO_queue (m_threads_with_links) );\n\n    /* JGG (07/07/2010): New way to manage root thread */\n    if (synch_type == GLOBAL_OP_ASYN )\n    {\n        others = (struct t_thread *) query_prio_queue(&communicator->nonblock_current_root, nb_glob_index);\n        //others = communicator->nonblock_current_root[nb_glob_index];\n    }\n    else\n    {\n        others = communicator->current_root;\n    }\n\n    //others = communicator->current_root;\n\n    /* NO ES TREU el thread de root de la cua. Els tracto tots igual! */\n\n    /* S'inicia l'operacio col.lectiva !! */\n    start_global_op (others, DIMEMAS_GLOBAL_OP_MODEL);\n}\n\n\n/**************************************************************************\n ** Aquesta funcio calcula els temps estimats de latenica i temps total\n ** per una etapa d'una operacio col.lectiva.\n **************************************************************************/\nvoid calcula_fan (t_nano bandw,     /* MB/s */\n        int num_partners, /* End-points of the current stage */\n        int num_busos,    /* Numero de busos disponibles */\n        int tipus_de_fan, /* 0 = IN / 1 = OUT */\n        int model,        /* 0, CONSTANT, LINEAL, LOGARITHMIC */\n        int size_type,    /* MIN, MAX, average, 2*MAX, send+recv */\n        int bytes_send,   /* Number of bytes send */\n        int bytes_recvd,  /* Number of bytes received */\n        t_nano startup,\n        t_nano *temps,\n        t_nano *latencia)\n{\n    int   mess_size;\n    float factor;\n\n    /* From MB/sec to ns/byte. */\n    bandw = bw_ns_per_byte (bandw);\n\n    /* Computation of global communication model */\n    switch (size_type)\n    {\n        case GOP_SIZE_CURR:\n            if (tipus_de_fan == FAN_IN)\n            {\n                mess_size = bytes_send;\n            }\n            else if (tipus_de_fan == FAN_OUT)\n            {\n                mess_size = bytes_recvd;\n            }\n            break;\n        case GOP_SIZE_MIN:\n            mess_size = MIN (bytes_send, bytes_recvd);\n            break;\n        case GOP_SIZE_MAX:\n            mess_size = MAX (bytes_send, bytes_recvd);\n            break;\n        case GOP_SIZE_MEAN:\n            mess_size = (bytes_send + bytes_recvd) / 2;\n            break;\n        case GOP_SIZE_2MAX:\n            mess_size = 2 * MAX (bytes_send, bytes_recvd);\n            break;\n        case GOP_SIZE_SIR:\n            mess_size = (bytes_send + bytes_recvd);\n            break;\n        default:\n            panic (\"Invalid size FIN/OUT %d for global operation\\n\", size_type);\n            exit (EXIT_FAILURE);\n            break;\n    }\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER(current_time);\n        printf(\": FAN_CALCULATION Message size used %d\\n\", mess_size);\n        PRINT_TIMER(current_time);\n        printf(\": FAN_CALCULATION startup %.9lf bandw %lf\\n\", startup, bandw);\n    }\n\n    switch (model)\n    {\n        case GOP_MODEL_0:\n            *temps    = 0;\n            *latencia = 0;\n\n            if (debug & D_COMM)\n            {\n                PRINT_TIMER(current_time);\n                printf(\": FAN_CALCULATION Model 0\\n\");\n            }\n\n            break;\n        case GOP_MODEL_CTE:\n            factor    = 1.0;\n            *temps    = startup + mess_size * bandw;\n            *latencia = startup;\n\n            if (debug & D_COMM)\n            {\n                PRINT_TIMER(current_time);\n                printf(\": FAN_CALCULATION CT Model\\n\");\n            }\n\n            break;\n        case GOP_MODEL_LIN:\n            factor    = (t_nano) num_partners - 1;\n            *temps    = (startup + mess_size * bandw) * factor;\n            *latencia = startup * factor;\n\n            if (debug & D_COMM)\n            {\n                PRINT_TIMER(current_time);\n                printf(\": FAN_CALCULATION LIN Model\\n\");\n            }\n\n            break;\n        case GOP_MODEL_LOG:\n            factor    = compute_contention_stage (num_partners, num_busos);\n            *temps    = (startup + mess_size * bandw) * factor;\n            *latencia = startup * factor;\n\n            if (debug & D_COMM)\n            {\n                PRINT_TIMER(current_time);\n                printf(\": FAN_CALCULATION LOG Model. Factor %d\\n\", factor);\n            }\n\n            break;\n\n        default:\n            panic (\"Invalid model FIN/OUT %d for global operation\\n\", model);\n            exit (EXIT_FAILURE);\n    }\n}\n\n\n\n/**************************************************************************\n ** Es calculen els temps dins de cada node de la maquina i\n ** s'agafen els maxims.\n **************************************************************************/\nstatic void calcula_temps_maxim_intra_nodes (struct t_machine      *machine,\n        struct t_communicator *communicator,\n        struct t_global_op_information *glop_info,\n        int bytes_send,   /* Number of bytes send */\n        int bytes_recvd,  /* Number of bytes received */\n        t_nano *max_tnode_in,\n        t_nano *max_lnode_in,\n        t_nano *max_tnode_out,\n        t_nano *max_lnode_out)\n{\n    struct t_node  *node;\n    int*    nodeid;\n    t_nano tauxn_in, lauxn_in, tauxn_out, lauxn_out;\n    int num_cpus;\n    double suma_aux, suma_maxim;\n\n    /* S'inicialitzen els maxims */\n    *max_tnode_in = *max_lnode_in = *max_tnode_out = *max_lnode_out = 0;\n    suma_maxim = 0;\n\n    for ( nodeid  = (int*) head_queue(&communicator->nodes_per_machine[machine->id]);\n            nodeid != NULL;\n            nodeid  = (int*) next_queue(&communicator->nodes_per_machine[machine->id]))\n    {\n        /* Nomes s'agafen els nodes d'aquesta maquina.\n           if (node->machine != machine) continue;\n           */\n        node = get_node_by_id(*nodeid);\n\n        int *tasks_per_node = (int*) query_prio_queue(&communicator->tasks_per_node,\n                (t_priority) *nodeid);\n\n        /* Cal calcular els temps dins d'aquest node */\n        calcula_fan (node->bandwidth,\n                // num_tasks,\n                (*tasks_per_node),\n                0, /* Infinits busos */\n                FAN_IN,\n                glop_info->FIN_model,\n                glop_info->FIN_size,\n                bytes_send,\n                bytes_recvd,\n                node->local_startup,\n                &tauxn_in,\n                &lauxn_in);\n\n        calcula_fan (node->bandwidth,\n                // num_tasks,\n                (*tasks_per_node),\n                0, /* Infinits busos */\n                FAN_OUT,\n                glop_info->FOUT_model,\n                glop_info->FOUT_size,\n                bytes_send,\n                bytes_recvd,\n                node->local_startup,\n                &tauxn_out,\n                &lauxn_out);\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": Machine %d Node: %d: tfin_int=%.9f lfin_int=%.9f tfout_int=%.9f lfout_int=%.9f\\n\",\n                    machine->id,\n                    (*nodeid),\n                    tauxn_in/1e9,\n                    lauxn_in/1e9,\n                    tauxn_out/1e9,\n                    lauxn_out/1e9\n                   );\n        }\n\n        /* S'agafen els del node amb la suma mes gran */\n        suma_aux = (double) (tauxn_in + lauxn_in + tauxn_out + lauxn_out);\n        if (suma_aux > suma_maxim)\n        {\n            /* S'agafa aquest node com a node de temps maxim d'aquesta maquina */\n            suma_maxim     = suma_aux;\n            *max_tnode_in  = tauxn_in;\n            *max_lnode_in  = lauxn_in;\n            *max_tnode_out = tauxn_out;\n            *max_lnode_out = lauxn_out;\n        }\n\n\n    }\n\n    /* Es retornen els temps del node de temps total maxim */\n}\n\n\n/**************************************************************************\n ** Es calcula el flight time maxims d'entrada i el maxim de sortida\n ** del thread donat.\n **************************************************************************/\nstatic void calcula_maxim_flight_times (struct t_thread *thread,\n        struct t_communicator *communicator,\n        t_nano *maxflight_in,\n        t_nano *maxflight_out)\n{\n    t_nano max_flight_in, max_flight_out;\n    struct t_node  *node;\n    struct t_machine *machine;\n    int index_origen;\n    struct t_thread *others;\n    double flight_time_in, flight_time_out;\n\n    int nb_glob_index= thread->nb_glob_index;\n\n    node         = get_node_of_thread (thread);\n    machine      = node->machine;\n    index_origen = machine->id;\n\n    max_flight_in  = 0;\n    max_flight_out = 0;\n\n    struct t_queue* comm_machine_threads;\n    if (thread->action->desc.global_op.synch_type == GLOBAL_OP_ASYN)\n    {\n        comm_machine_threads = (struct t_queue *) query_prio_queue(&communicator->nonblock_global_op_machine_threads, nb_glob_index);\n        //comm_machine_threads=&communicator->nonblock_global_op_machine_threads[nb_glob_index];\n    }\n    else\n    {\n        comm_machine_threads=&communicator->machines_threads;\n    }\n\n    /* Es calcula el temps de cada maquina */\n    for (others = (struct t_thread *) head_queue (comm_machine_threads);\n            others != (struct t_thread *) 0;\n            others = (struct t_thread *) next_queue (comm_machine_threads) )\n    {\n        /* No te sentit calcular el flight time a si mateixa */\n        if (others == thread) continue;\n\n        /* S'obte el node i la maquina corresponent al thread */\n        node    = get_node_of_thread (others);\n        machine = node->machine;\n\n        /* S'agafen els flight times */\n        flight_time_in  =\n            Simulator.wan.flight_times[machine->id][index_origen];\n        flight_time_out =\n            Simulator.wan.flight_times[index_origen][machine->id];\n\n        /* S'agafen els maxims */\n        if (flight_time_in > max_flight_in)\n        {\n            max_flight_in = flight_time_in;\n        }\n        if (flight_time_out > max_flight_out)\n        {\n            max_flight_out = flight_time_out;\n        }\n    }\n\n    /* Es retornen els maxims */\n    *maxflight_in  = max_flight_in;\n    *maxflight_out = max_flight_out;\n}\n\n/**************************************************************************\n ** Aquesta funcio calcula els temps estimats per realitzar l'operaci\u00f3\n ** col.lectiva.\n **************************************************************************/\nvoid calcula_temps_operacio_global (struct t_thread *thread,\n        dimemas_timer   *temps_latencia,\n        dimemas_timer   *temps_recursos,\n        dimemas_timer   *temps_final)\n{\n    struct t_Ptask                 *Ptask;\n    struct t_communicator          *communicator;\n    struct t_global_op_definition  *glop;\n    struct t_thread                *others;\n    struct t_action                *action;\n    struct t_node                  *node;\n    struct t_machine               *machine;\n    struct t_global_op_information *glop_info;\n    int                             comm_id, glop_id, num_maquines, num_tasks;\n    int                             nodes_involved;\n\n    int nb_glob_index= thread->nb_glob_index;\n    t_nano tfin_node, lfin_node, tfout_node, lfout_node;\n    t_nano tfin_int,  lfin_int,  tfout_int,  lfout_int;\n    t_nano tfin_ext,  lfin_ext,  tfout_ext,  lfout_ext;\n    t_nano taux_in, laux_in, taux_out, laux_out;\n    t_nano tauxn_in, lauxn_in, tauxn_out, lauxn_out;\n\n    t_nano flightin_ext, flightout_ext;\n    t_nano temps, latencia, t_recursos; /* Temps totals */\n\n    t_nano bandw_externa;\n    double  suma_aux, suma_maxim;\n\n    Ptask        = thread->task->Ptask;\n    action       = thread->action;\n    comm_id      = action->desc.global_op.comm_id;\n    communicator = locate_communicator (&Ptask->Communicator, comm_id);\n\n    if (communicator == COM_NIL)\n    {\n        panic (\"Communication get_buses trough an invalid communicator %d to P%02d T%02d (t%02d)\\n\",\n                comm_id, IDENTIFIERS (thread) );\n    }\n\n    glop_id = action->desc.global_op.glop_id;\n    glop    = (struct t_global_op_definition *)\n        query_prio_queue (&Global_op, (t_priority) glop_id);\n\n    if (glop == GOPD_NIL)\n    {\n        panic (\n                \"Global operation %d undefined to P%02d T%02d (t%02d)\\n\",\n                glop_id,\n                IDENTIFIERS (thread)\n              );\n    }\n\n    /* Communicator size */\n    num_tasks = communicator->size;\n\n    /* S'inicialitzen els temps */\n    tfin_node    = lfin_node = tfout_node = lfout_node = 0;\n    taux_in      = laux_in   = taux_out   = laux_out   = 0;\n    tfin_int     = lfin_int  = tfout_int  = lfout_int  = 0;\n    tauxn_in     = lauxn_in  = tauxn_out  = lauxn_out  = 0;\n    tfin_ext     = lfin_ext  = tfout_ext  = lfout_ext  = 0;\n\n    flightin_ext = flightout_ext = 0;\n    suma_maxim   = 0;\n\n    struct t_queue* comm_machine_threads;\n    if (thread->action->desc.global_op.synch_type == GLOBAL_OP_ASYN)\n    {\n        comm_machine_threads = (struct t_queue *) query_prio_queue(&communicator->nonblock_global_op_machine_threads, nb_glob_index);\n        //comm_machine_threads=&communicator->nonblock_global_op_machine_threads[nb_glob_index];\n    }\n    else\n    {\n        comm_machine_threads=&communicator->machines_threads;\n    }\n\n    /* For each machine used we compute the inter-node communication time and\n       the intra-node communication time */\n    for (others  = (struct t_thread*) head_queue (comm_machine_threads);\n            others != TH_NIL;\n            others  = (struct t_thread*) next_queue (comm_machine_threads) )\n    {\n        /* S'obte el node i la maquina corresponent al thread */\n        node    = get_node_of_thread (others);\n        machine = node->machine;\n\n        /* S'obte la informacio de les operacions col.lectives dins\n           d'aquesta maquina. */\n        glop_info = (struct t_global_op_information *)\n            query_prio_queue (&machine->communication.global_ops_info,\n                    (t_priority) glop_id);\n\n        if (glop_info == (struct t_global_op_information *) 0)\n        {\n            panic (\n                    \"Global operation %d undefined to P%02d T%02d (t%02d)\\n\",\n                    glop_id,\n                    IDENTIFIERS (others)\n                  );\n        }\n\n        /* Inter-node communication times */\n        if (machine->number_of_nodes > 1)\n        {\n            // printf(\"machine->number_of_nodes = %d\\n\", machine->number_of_nodes);\n\n            if (count_queue(&communicator->nodes_per_machine[machine->id]) > 0)\n            {\n                calcula_fan (machine->communication.remote_bandwidth,\n                        count_queue(&communicator->nodes_per_machine[machine->id]),\n                        machine->communication.num_messages_on_network,\n                        FAN_IN,\n                        glop_info->FIN_model,\n                        glop_info->FIN_size,\n                        action->desc.global_op.bytes_send,\n                        action->desc.global_op.bytes_recvd,\n                        node->remote_startup,\n                        &taux_in,\n                        &laux_in);\n\n                calcula_fan (machine->communication.remote_bandwidth,\n                        count_queue(&communicator->nodes_per_machine[machine->id]),\n                        machine->communication.num_messages_on_network,\n                        FAN_OUT,\n                        glop_info->FOUT_model,\n                        glop_info->FOUT_size,\n                        action->desc.global_op.bytes_send,\n                        action->desc.global_op.bytes_recvd,\n                        node->remote_startup,\n                        &taux_out,\n                        &laux_out);\n\n                if (debug & D_COMM)\n                {\n                    PRINT_TIMER (current_time);\n                    printf (\n                            \": Machine %d (inter-nodes): tfin=%.9f lfin=%.9f tfout=%.9f lfout=%.9f\\n\",\n                            machine->id,\n                            taux_in/1e9,\n                            laux_in/1e9,\n                            taux_out/1e9,\n                            laux_out/1e9\n                           );\n\n                }\n            }\n        }\n\n        /* Intra-nodes communication times */\n        calcula_temps_maxim_intra_nodes (machine,\n                communicator,\n                glop_info,\n                action->desc.global_op.bytes_send,\n                action->desc.global_op.bytes_recvd,\n                &tauxn_in,\n                &lauxn_in,\n                &tauxn_out,\n                &lauxn_out);\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": Machine %d (intra nodes): tfin=%.9f lfin=%.9f tfout=%.9f lfout=%.9f\\n\",\n                    machine->id,\n                    tauxn_in/1e9,\n                    lauxn_in/1e9,\n                    tauxn_out/1e9,\n                    lauxn_out/1e9\n                   );\n        }\n\n        /* Es calcula la suma total de temps entre nodes d'aquesta maquina\n           mes els temps del node d'aquesta maquina de mes durada */\n        suma_aux  = (double) (taux_in + laux_in + taux_out + laux_out);\n        suma_aux += (double) (tauxn_in + lauxn_in + tauxn_out + lauxn_out);\n\n        /* S'agafen els temps corresponents a la maquina de mes temps total */\n        if (suma_aux > suma_maxim)\n        {\n            /* S'agafen tots els temps d'aquesta maquina */\n            suma_maxim = suma_aux;\n\n            tfin_node  = tauxn_in;\n            lfin_node  = lauxn_in;\n            tfout_node = tauxn_out;\n            lfout_node = lauxn_out;\n\n            tfin_int  = taux_in;\n            lfin_int  = laux_in;\n            tfout_int = taux_out;\n            lfout_int = laux_out;\n        }\n\n        /* De moment s'ha decidit agafar el temps maxim de totes les maquines */\n        /*    if (taux_in > tfin_int) tfin_int=taux_in;\n              if (laux_in > lfin_int) lfin_int=laux_in;\n              if (taux_out > tfout_int) tfout_int=taux_out;\n              if (laux_out > lfout_int) lfout_int=laux_out;\n\n              if (debug & D_COMM)\n              {\n              PRINT_TIMER (current_time);\n              printf (\n              \": Machine %d (Maximum):     tfin=%.9f lfin=%.9f tfout=%.9f lfout=%.9f\\n\",\n              machine->id,\n              taux_in/1e9,\n              laux_in/1e9,\n              taux_out/1e9,\n              laux_out/1e9\n              );\n              }\n              */\n    }\n\n\n    /* Cal contar el temps a la xarxa externa */\n    num_maquines = count_queue (comm_machine_threads);\n    if (num_maquines > 1)\n    {\n\n        /* S'obte la informacio de les operacions col.lectives a la\n           xarxa externa. */\n        glop_info = (struct t_global_op_information *)\n            query_prio_queue (\n                    &Simulator.wan.global_ops_info,\n                    (t_priority) glop_id\n                    );\n\n        if (glop_info == (struct t_global_op_information *) 0)\n        {\n            panic (\n                    \"Global operation %d undefined to P%02d T%02d (t%02d)\\n\",\n                    glop_id,\n                    IDENTIFIERS (thread)\n                  );\n        }\n\n        /* Aqui hi ha d'haver el recompute_external_netwrok_bandewidth */\n        if (Simulator.wan.bandwidth != 0)\n        {\n            /*recompute_external_network_traffic(size???); */\n            bandw_externa = recompute_external_network_bandwidth (thread);\n        }\n        else\n        {\n            bandw_externa = (t_nano) 0;\n        }\n\n        /* Es calculen els temps */\n        calcula_fan ( bandw_externa,\n                num_tasks,\n                0, /* Infinits busos */\n                FAN_IN,\n                glop_info->FIN_model, glop_info->FIN_size,\n                action->desc.global_op.bytes_send,\n                action->desc.global_op.bytes_recvd,\n                node->external_net_startup,\n                &tfin_ext,\n                &lfin_ext);\n\n        calcula_fan (bandw_externa,\n                num_tasks,\n                0, /* Infinits busos */\n                FAN_OUT, /* FAN OUT */\n                glop_info->FOUT_model, glop_info->FOUT_size,\n                action->desc.global_op.bytes_send,\n                action->desc.global_op.bytes_recvd,\n                node->external_net_startup,\n                &tfout_ext,\n                &lfout_ext);\n\n        /* Es calculen els flight times */\n        calcula_maxim_flight_times (thread,\n                communicator,\n                &flightin_ext,\n                &flightout_ext);\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": External net: tfin_ext=%.9f lfin_ext=%.9f tfout_ext=%.9f lfout_ext=%.9f\\n\",\n                    tfin_ext/1e9,\n                    lfin_ext/1e9,\n                    tfout_ext/1e9,\n                    lfout_ext/1e9\n                   );\n\n            PRINT_TIMER (current_time);\n            printf (\n                    \": Num maquines %d startup xarxa externa %.9f\\n\",\n                    num_maquines,\n                    node->external_net_startup/1e9\n                   );\n        }\n    }\n\n    /* S'acumulen els temps de totes les fases */\n    temps    =\n        tfin_node + tfout_node + tfin_int + tfout_int + tfin_ext + tfout_ext;\n\n    latencia =\n        lfin_node + lfout_node + lfin_int + lfout_int + lfin_ext + lfout_ext;\n\n    /* S'agafa el temps amb els recursos ocupats */\n    t_recursos = temps;\n\n    /* Es sumen els flight times al temps final */\n    temps += (flightin_ext + flightout_ext);\n\n    /* Es retornen els temps estimats de durada de l'operacio col.lectiva */\n    FLOAT_TO_TIMER (temps, *temps_final);\n    FLOAT_TO_TIMER (latencia, *temps_latencia);\n    FLOAT_TO_TIMER (t_recursos, *temps_recursos);\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\": GLOBAL_operation Total time=\");\n        PRINT_TIMER (*temps_final);\n        printf (\" ( Resources=\");\n        PRINT_TIMER (*temps_recursos);\n        printf (\" Startup=\");\n        PRINT_TIMER (*temps_latencia);\n        printf (\" ) \\n\");\n    }\n}\n\n/**************************************************************************\n ** Aquesta funcio no reserva res. Dona per suposat que ja s'ha reservat\n ** tot el que calia. Simplement engega l'operacio col.lectiva.\n **************************************************************************/\nstatic void start_global_op (struct t_thread *thread, int kind)\n{\n    struct t_Ptask *Ptask;\n    struct t_communicator *communicator;\n    struct t_global_op_definition * glop;\n    struct t_thread *others;\n    struct t_action *action;\n    int comm_id, glop_id;\n    dimemas_timer tmp_timer;\n    dimemas_timer tmp_timer2;\n    struct t_cpu *cpu;\n    dimemas_timer temps_latencia, temps_recursos, temps_final, temps_operacio;\n\n    Ptask        = thread->task->Ptask;\n    action       = thread->action;\n    comm_id      = action->desc.global_op.comm_id;\n    communicator = locate_communicator (&Ptask->Communicator, comm_id);\n\n    if (communicator == COM_NIL)\n    {\n        panic (\n                \"Communication get_buses trough an invalid communicator %d to P%02d T%02d (t%02d)\\n\",\n                comm_id,\n                IDENTIFIERS (thread)\n              );\n    }\n\n    glop_id = action->desc.global_op.glop_id;\n    glop    = (struct t_global_op_definition *)\n        query_prio_queue (&Global_op, (t_priority) glop_id);\n\n    if (glop == GOPD_NIL)\n    {\n        panic (\n                \"Global operation %d undefined to P%02d T%02d (t%02d)\\n\",\n                glop_id,\n                IDENTIFIERS (thread)\n              );\n    }\n\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": GLOBAL_operation P%02d T%02d (t%02d) (Root Task) Unlocks '%s'\\n\",\n                IDENTIFIERS (thread),\n                glop->name\n               );\n    }\n\n    /* Calcula els temps estimats per realitzar l'operaci\u00f3 col.lectiva */\n    /* JGG (09/11/2004): En funci\u00f3n al tipo de la operaci\u00f3n, se calcula interna\n     * o externamente */\n    switch (kind)\n    {\n        case DIMEMAS_GLOBAL_OP_MODEL:\n            calcula_temps_operacio_global (thread,\n                    &temps_latencia,\n                    &temps_recursos,\n                    &temps_final);\n\n            /* Es programa l'event de final de la reserva dels recursos */\n            ADD_TIMER (current_time, temps_recursos, tmp_timer);\n            EVENT_timer (\n                    tmp_timer,\n                    NOT_DAEMON,\n                    M_COM,\n                    thread,\n                    COM_TIMER_GROUP_RESOURCES\n                    );\n            break;\n\n        case EXTERNAL_GLOBAL_OP_MODEL:\n            if (external_comm_library_loaded == FALSE)\n            {\n                panic (\"Executing global operation through external model library not loaded\\n\");\n            }\n\n            external_compute_global_operation_time(comm_id,\n                    glop_id,\n                    action->desc.global_op.bytes_send,\n                    action->desc.global_op.bytes_recvd,\n                    (t_nano*) &temps_latencia,\n                    (t_nano*) &temps_operacio);\n\n            temps_final = temps_latencia + temps_operacio;\n\n            if (debug&D_COMM)\n            {\n                PRINT_TIMER (current_time);\n                printf (\n                        \": GLOBAL_operation P%02d T%02d (t%02d) '%s' USING EXTERNAL GLOBAL OPERATIONS MODEL\\n\",\n                        IDENTIFIERS (thread),\n                        glop->name\n                       );\n            }\n\n            /* JGG: There is no need to free the resources, because we use an external\n             * model */\n            break;\n\n    }\n\n\n\n    /* Es programa l'event de final de l'operacio col.lectiva */\n    ADD_TIMER (current_time, temps_final, tmp_timer);\n\n    EVENT_timer (\n            tmp_timer,\n            NOT_DAEMON,\n            M_COM,\n            thread,\n            COM_TIMER_GROUP\n            );\n\n    // In this case we do not want to generate any state in the trace\n    //\n    if (thread->action->desc.global_op.synch_type == GLOBAL_OP_ASYN)\n        return;\n\n    /* Per cada thread del comunicador, es guarden les estadistiques i es\n     * genera el que cal a la trac,a */\n    for (others  = (struct t_thread *) head_queue (&communicator->threads);\n            others != TH_NIL;\n            others  = (struct t_thread *) next_queue (&communicator->threads) )\n    {\n        ASS_ALL_TIMER (others->collective_timers.with_resources, current_time);\n\n        PARAVER_Wait (\n                0,\n                IDENTIFIERS (others),\n                others->last_paraver,\n                current_time,\n                PRV_BLOCKED_ST\n                //PRV_BLOCKING_SEND_ST\n                );\n\n        others->last_paraver = current_time;\n\n        if (temps_latencia != 0)\n        {\n            ADD_TIMER (current_time, temps_latencia, tmp_timer2);\n            cpu = get_cpu_of_thread (others);\n            PARAVER_Startup (cpu->unique_number,\n                    IDENTIFIERS (others),\n                    current_time,\n                    tmp_timer2);\n            others->last_paraver = tmp_timer2;\n        }\n    }\n}\n\n\n/**************************************************************************\n ** Allibera tots els recursos reservat per fer l'operaci\u00f3 col.lectiva,\n ** per\u00f2 no desbloqueja els threads perqu\u00e8 l'operaci\u00f3 encara no ha acabat.\n **************************************************************************/\nstatic void free_global_communication_resources (struct t_thread *thread)\n{\n\n    struct t_action               *action;\n    struct t_bus_utilization      *bus_utilization;\n    struct t_thread               *others, *wait_thread;\n    struct t_communicator         *communicator;\n    struct t_Ptask                *Ptask;\n    struct t_global_op_definition *glop;\n    struct t_node                 *node;\n    struct t_machine              *machine;\n    int comm_id, glop_id, i, aux, num_elements, num_maquines;\n\n    int nb_glob_index= thread->nb_glob_index;\n\n    Ptask        = thread->task->Ptask;\n    action       = thread->action;\n    comm_id      = action->desc.global_op.comm_id;\n    communicator = locate_communicator (&Ptask->Communicator, comm_id);\n\n    if (communicator == COM_NIL)\n    {\n        panic (\n                \"Communication free trough an invalid communicator %d to P%02d T%02d (t%02d)\\n\",\n                comm_id,\n                IDENTIFIERS (thread)\n              );\n    }\n\n    glop_id = action->desc.global_op.glop_id;\n    glop    = (struct t_global_op_definition *)\n        query_prio_queue (&Global_op, (t_priority) glop_id);\n\n    if (glop  ==  GOPD_NIL)\n    {\n        panic (\n                \"Global operation %d undefined to P%02d T%02d (t%02d)\\n\",\n                glop_id,\n                IDENTIFIERS (thread)\n              );\n    }\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": GLOBAL_operation P%02d T%02d (t%02d) Free resources used in '%s'\\n\",\n                IDENTIFIERS (thread),\n                glop->name\n               );\n    }\n    struct t_queue* comm_machine_threads;\n    if (thread->action->desc.global_op.synch_type == GLOBAL_OP_ASYN)\n    {\n        comm_machine_threads = (struct t_queue *) query_prio_queue(&communicator->nonblock_global_op_machine_threads, nb_glob_index);\n        //comm_machine_threads=&communicator->nonblock_global_op_machine_threads[nb_glob_index];\n    }\n    else\n    {\n        comm_machine_threads=&communicator->machines_threads;\n    }\n\n    /* Mirem el numero de maquines implicades abans de comenc,ar a\n       desencuar threads. */\n    num_maquines = count_queue (comm_machine_threads);\n\n    /* Per cada maquina utilitzada s'alliberen tots els recursos reservats i\n     * es treu el thread de la cua de maquines utilitzades per tal que la\n     * cua ja quedi buida per la propera vegada. */\n    /*  for (others = (struct t_thread *)head_queue(&communicator->machines_threads);\n        others != TH_NIL;\n        others = (struct t_thread *)next_queue(&communicator->machines_threads))\n        */\n    for (\n            others  = (struct t_thread *) outFIFO_queue (comm_machine_threads);\n            others != TH_NIL;\n            others  = (struct t_thread *) outFIFO_queue (comm_machine_threads)\n        )\n    {\n        /* S'obte la maquina corresponent al thread */\n        node    = get_node_of_thread (others);\n        machine = node->machine;\n\n        /* S'alliberen els busos */\n        others->number_buses             = 0;\n        machine->network.curr_on_network = 0;\n\n        for (i = 0; i < machine->communication.num_messages_on_network; i++)\n        {\n            bus_utilization = (struct t_bus_utilization *)\n                outFIFO_queue (&machine->network.threads_on_network);\n        }\n        /* Nomes s'ha reservat memoria una vegada i, per tant, nomes s'ha\n           d'alliberar una vegada. */\n        if (i > 0)\n        {\n            free (bus_utilization);\n        }\n\n        /* Si hi havia m\u00e9s d'una m\u00e0quina, aqui cal alliberar els links\n           de la xarxa externa d'aquesta maquina. */\n        if (num_maquines > 1)\n        {\n            LINKS_free_wan_link(others->local_link, others);\n            LINKS_free_wan_link(others->partner_link, others);\n            /* En aquest cas cal posar explicitament els links a L_NIL perque\n               en les operacions col.lectives no es treballa amb copies dels\n               threads, sino amb els threads originals. */\n            others->local_link = L_NIL;\n            others->partner_link = L_NIL;\n        }\n\n\n        /* Intent d'alliberar els threads (No d'aquesta col.lectiva) que podien\n           estar bloquejats esperant a que hi hagui busos lliures en aquesta\n           maquina */\n        if (count_queue (&machine->network.queue) > 0)\n        {\n            num_elements = count_queue (&machine->network.queue);\n            for (\n                    i = 0;\n                    ( (i < num_elements) &&\n                      (machine->network.curr_on_network < machine->communication.num_messages_on_network) );\n                    i++\n                )\n            {\n                wait_thread = (struct t_thread *) head_queue (&machine->network.queue);\n\n                if (debug & D_COMM)\n                {\n                    PRINT_TIMER (current_time);\n                    printf (\n                            \": GLOBAL_operation P%02d T%02d (t%02d) goes unlock and obtain bus\\n\",\n                            IDENTIFIERS (wait_thread)\n                           );\n                }\n                action = wait_thread->action;\n                switch (action->action)\n                {\n                    case SEND:\n                        /* FEC: S'acumula el temps que ha estat esperant busos */\n                        ACCUMULATE_BUS_WAIT_TIME (wait_thread);\n                        /*******************************************************/\n                        extract_from_queue (&machine->network.queue, (char *) wait_thread);\n                        really_send (wait_thread);\n                        break;\n\n                    case MPI_OS:\n                        /* FEC: S'acumula el temps que ha estat esperant busos */\n                        ACCUMULATE_BUS_WAIT_TIME (wait_thread);\n                        /*******************************************************/\n                        extract_from_queue (&machine->network.queue, (char *) wait_thread);\n                        really_RMA (wait_thread);\n                        break;\n\n                    case GLOBAL_OP:\n                        aux = machine->communication.num_messages_on_network -\n                            machine->network.curr_on_network;\n                        wait_thread->number_buses += aux;\n                        machine->network.curr_on_network += aux;\n                        if (wait_thread->number_buses == machine->communication.num_messages_on_network)\n                        {\n                            /* FEC: S'acumula el temps que ha estat esperant busos */\n                            ACCUMULATE_BUS_WAIT_TIME (wait_thread);\n                            /*******************************************************/\n                            extract_from_queue (&machine->network.queue, (char *) wait_thread);\n                            global_op_get_all_buses (wait_thread);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    /* Ja s'han alliberat tots els recursos reservats, per\u00f2 encara NO s'han\n       de desbloquejar els threads d'aquesta operaci\u00f3 col.lectiva perqu\u00e8\n       l'operaci\u00f3 encara no ha acabat. */\n}\n\n\nstatic void close_global_nonblock_communication(struct t_thread *thread)\n{\n    struct t_action               *action;\n    struct t_thread               *others;\n    struct t_communicator         *communicator;\n    struct t_Ptask                *Ptask;\n    struct t_global_op_definition *glop;\n    struct t_node                 *node;\n    struct t_account              *account;\n    struct t_cpu                  *cpu;\n    dimemas_timer                  tmp_timer;\n    int comm_id, glop_id;\n    int  machines;\n    int *tasks_per_node;\n    int nb_glob_index;\n\n    Ptask        = thread->task->Ptask;\n    action       = thread->action;\n    comm_id      = action->desc.global_op.comm_id;\n    communicator = locate_communicator (&Ptask->Communicator, comm_id);\n\n    if (communicator == COM_NIL)\n    {\n        panic (\"Communication close trough an invalid communicator %d to P%02d T%02d (t%02d)\\n\",\n                comm_id,\n                IDENTIFIERS (thread) );\n    }\n\n    nb_glob_index = thread->nb_glob_index;\n\n    struct t_thread* current_root = (struct t_thread*)query_prio_queue(\n            &communicator->nonblock_current_root, nb_glob_index);\n    extract_from_queue(&communicator->nonblock_current_root, (void *) current_root);\n    //communicator->nonblock_current_root[nb_glob_index] = TH_NIL;\n    //communicator->in_flight_op = FALSE; // TODO: It is set ??\n\n    /* Clean communicator queues */\n    for (machines = 0; machines < Simulator.number_machines; machines++)\n    {\n        int *nodeid;\n\n        for (nodeid  = (int*) outFIFO_queue (&communicator->nodes_per_machine[machines]);\n                nodeid != NULL;\n                nodeid  = (int*) outFIFO_queue (&communicator->nodes_per_machine[machines]))\n        {\n            free(nodeid);\n        }\n    }\n\n    for (tasks_per_node  = (int*) outFIFO_queue(&communicator->tasks_per_node);\n            tasks_per_node != NULL;\n            tasks_per_node  =(int*) outFIFO_queue(&communicator->tasks_per_node))\n    {\n        free(tasks_per_node);\n    }\n\n    glop_id = action->desc.global_op.glop_id;\n    glop    = (struct t_global_op_definition *)\n        query_prio_queue (&Global_op, (t_priority) glop_id);\n\n    if (glop == GOPD_NIL)\n    {\n        panic (\"Global operation %d undefined to P%02d T%02d (t%02d)\\n\",\n                glop_id,\n                IDENTIFIERS (thread) );\n    }\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\": non-block GLOBAL_operation P%02d T%02d (t%02d) ends '%s'\\n\",\n                IDENTIFIERS (thread),\n                glop->name);\n    }\n\n    // For sure, all ranks involved in the global operation must be arrive.\n    struct t_queue* nb_glob_threads = (struct t_queue*) query_prio_queue(&communicator->nonblock_global_op_threads, nb_glob_index);\n    assert (nb_glob_threads->count == communicator->size);\n\n    /* Unblock all threads involved in communication */\n    for (others  = (struct t_thread *) outFIFO_queue (nb_glob_threads);\n            others != TH_NIL;\n            others  = (struct t_thread *) outFIFO_queue (nb_glob_threads) )\n    {\n\n        assert (others->original_thread == FALSE);\n        struct t_thread* parent_thread = others->twin_thread;\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\": non-block GLOBAL_operation P%02d T%02d (t%02d) ends '%s'\\n\",\n                    IDENTIFIERS (others),\n                    glop->name);\n        }\n\n        node = get_node_of_thread (others);\n        new_cp_node (others, CP_BLOCK);\n        new_cp_relation (others, thread);\n        action = others->action;\n        account = current_account (others);\n\n        ASS_ALL_TIMER (others->collective_timers.conclude_communication,current_time);\n\n        SUB_TIMER (others->collective_timers.with_resources,\n                others->collective_timers.arrive_to_collective,\n                tmp_timer);\n\n        ADD_TIMER (account->block_due_group_operations,\n                tmp_timer,\n                account->block_due_group_operations);\n\n        SUB_TIMER (others->collective_timers.conclude_communication,\n                others->collective_timers.with_resources,\n                tmp_timer);\n\n        ADD_TIMER (account->group_operations_time,\n                tmp_timer,\n                account->group_operations_time);\n\n        // If the MPI_Wait for the non-block GLOP has already arrived then the\n        // action is done. If not, set the flag for the future\n        //\n        int nb_index = others->nb_glob_index;\n        if (parent_thread->n_nonblock_glob_waiting > 0)\n        {\n            delete_duplicate_thread(others);\n            parent_thread->n_nonblock_glob_waiting -= 1;\n\n            action = parent_thread->action;\n            parent_thread->action = action->next;\n            READ_free_action(action);\n\n            if (more_actions (parent_thread) )\n            {\n                parent_thread->loose_cpu = TRUE;\n                SCHEDULER_thread_to_ready (parent_thread);\n                reload_done = TRUE;\n            }\n        }\n        else\n        {\n            parent_thread->n_nonblock_glob_done += 1;\n            inFIFO_queue(&parent_thread->nonblock_glop_done_threads, \n                    (char *)others);\n        }\n\n        parent_thread->n_nonblock_glob_in_flight -= 1;\n\n        //printf(\"%f ENDING (%d:%d) : done=%d waiting=%d flight=%d\\n\", \n        //              current_time,\n        //              parent_thread->task->taskid,\n        //              nb_index,\n        //              parent_thread->n_nonblock_glob_done,\n        //              parent_thread->n_nonblock_glob_waiting,\n        //              parent_thread->n_nonblock_glob_in_flight);\n\n    }\n    extract_from_queue(\n            &communicator->nonblock_global_op_threads, (char *)nb_glob_threads);\n\n}\n\n\n/**************************************************************************\n ** Desbloqueja tot els threads de l'operaci\u00f3 col.lectiva. No allibera\n ** els recursos utilitzats, perqu\u00e8 ja s'ha d'haver fet a la rutina\n ** free_global_communication_resources.\n **************************************************************************/\nstatic void close_global_communication (struct t_thread *thread)\n{\n    struct t_action               *action;\n    struct t_thread               *others;\n    struct t_communicator         *communicator;\n    struct t_Ptask                *Ptask;\n    struct t_global_op_definition *glop;\n    struct t_node                 *node;\n    struct t_account              *account;\n    struct t_cpu                  *cpu;\n    dimemas_timer                  tmp_timer;\n    int comm_id, glop_id;\n    int  machines;\n    int *tasks_per_node;\n\n    Ptask        = thread->task->Ptask;\n    action       = thread->action;\n    comm_id      = action->desc.global_op.comm_id;\n    communicator = locate_communicator (&Ptask->Communicator, comm_id);\n\n    if (communicator == COM_NIL)\n    {\n        panic (\"Communication close trough an invalid communicator %d to P%02d T%02d (t%02d)\\n\",\n                comm_id,\n                IDENTIFIERS (thread) );\n    }\n\n    communicator->current_root = TH_NIL;\n    communicator->in_flight_op = FALSE;\n\n    /* Clean communicator queues */\n    for (machines = 0; machines < Simulator.number_machines; machines++)\n    {\n        int *nodeid;\n\n        for (nodeid  = (int*) outFIFO_queue (&communicator->nodes_per_machine[machines]);\n                nodeid != NULL;\n                nodeid  = (int*) outFIFO_queue (&communicator->nodes_per_machine[machines]))\n        {\n            free(nodeid);\n        }\n\n    }\n\n    for (tasks_per_node  = (int*) outFIFO_queue(&communicator->tasks_per_node);\n            tasks_per_node != NULL;\n            tasks_per_node  =(int*) outFIFO_queue(&communicator->tasks_per_node))\n    {\n        free(tasks_per_node);\n    }\n\n    glop_id = action->desc.global_op.glop_id;\n    glop    = (struct t_global_op_definition *)\n        query_prio_queue (&Global_op, (t_priority) glop_id);\n\n    if (glop == GOPD_NIL)\n    {\n        panic (\"Global operation %d undefined to P%02d T%02d (t%02d)\\n\",\n                glop_id,\n                IDENTIFIERS (thread) );\n    }\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        printf (\": GLOBAL_operation P%02d T%02d (t%02d) ends '%s'\\n\",\n                IDENTIFIERS (thread),\n                glop->name);\n    }\n\n    /*\n     * TODO: Borrar\n     */\n    /*\n       printf(\"######### %d ##########\\n\", count_queue(&communicator->threads));\n\n       struct t_item *ev_it = communicator->threads.first;\n\n       while (ev_it != NULL)\n       {\n       struct t_thread *th = (struct t_thread*)ev_it->content;\n\n       if (th == NULL) break;\n\n       printf(\"TASK ID: %d\\n\", th->task->taskid);\n       ev_it = ev_it->next;\n       }\n       */\n\n    /* Unblock all threads involved in communication */\n    for (others  = (struct t_thread *) outFIFO_queue (&communicator->threads);\n            others != TH_NIL;\n            others  = (struct t_thread *) outFIFO_queue (&communicator->threads) )\n    {\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\": GLOBAL_operation P%02d T%02d (t%02d) ends '%s'\\n\",\n                    IDENTIFIERS (others),\n                    glop->name);\n        }\n\n        node = get_node_of_thread (others);\n        new_cp_node (others, CP_BLOCK);\n        new_cp_relation (others, thread);\n\n        PARAVER_Wait (0,\n                IDENTIFIERS (others),\n                others->last_paraver,\n                current_time,\n                PRV_GLOBAL_OP_ST);\n\n        ASS_ALL_TIMER (others->collective_timers.conclude_communication,\n                current_time);\n\n        action = others->action;\n\n        account = current_account (others);\n\n        SUB_TIMER (others->collective_timers.with_resources,\n                others->collective_timers.arrive_to_collective,\n                tmp_timer);\n\n        ADD_TIMER (account->block_due_group_operations,\n                tmp_timer,\n                account->block_due_group_operations);\n\n        SUB_TIMER (others->collective_timers.conclude_communication,\n                others->collective_timers.with_resources,\n                tmp_timer);\n\n        ADD_TIMER (account->group_operations_time,\n                tmp_timer,\n                account->group_operations_time);\n\n        others->last_paraver = current_time;\n        cpu                  = get_cpu_of_thread (others);\n\n        /* JGG (2014/12/18): What is this event????\n           PARAVER_Event (cpu->unique_number,\n           IDENTIFIERS (others),\n           current_time,\n           PARAVER_GROUP_FREE,\n           glop_id);\n           */\n\n\n        action         = others->action;\n        others->action = action->next;\n        READ_free_action(action);\n\n        if (more_actions (others) )\n        {\n            others->loose_cpu = TRUE;\n            SCHEDULER_thread_to_ready (others);\n            reload_done       = TRUE;\n        }\n    }\n}\n\nstatic t_boolean thread_in_communicator (struct t_communicator *comm,\n        struct t_thread       *thread)\n{\n    int  i;\n\n    /*\n       for (\n       taskid  = (int *) head_queue (&comm->global_ranks);\n       taskid != (int *) 0;\n       taskid  = (int *) next_queue (&comm->global_ranks)\n       )\n       */\n    for (i = 0; i < comm->size; i++)\n    {\n        // if (*taskid == (thread->task->taskid) )\n        if ( thread->task->taskid == comm->global_ranks[i] )\n        {\n            return (TRUE);\n        }\n    }\n    return (FALSE);\n}\n\nint from_rank_to_taskid (struct t_communicator *comm, int root_rank)\n{\n    int *root_task;\n    int  i;\n\n    /* TEST: Root_Rank is the Root Task ID\n       root_task = (int *)head_queue(&comm->global_ranks);\n\n       i = 0;\n       while (i != root_rank)\n       {\n       root_task = (int *)next_queue(&comm->global_ranks);\n       if (root_task==(int *)0)\n       {\n       panic(\n       \"Unable to localte root rank %d in communicator %d\\n\",\n       root_rank,\n       comm->communicator_id\n       );\n       }\n       i++;\n       }\n       return (*root_task);\n       */\n    return root_rank;\n}\n\nvoid GLOBAL_wait_operation(struct t_thread *thread)\n{\n    struct t_action               *action;\n    struct t_recv                 *mess;\n    struct t_task                 *task, *task_source;\n    struct t_account              *account;\n    dimemas_timer                  tmp_timer;\n    struct t_node                 *node_r, *node_s;\n    t_nano                        startup, copy_latency;\n    int                            kind;\n    struct t_dedicated_connection *connection;\n\n    action = thread->action;\n    task   = thread->task;\n\n    if (thread->startup_done == FALSE)\n    {\n        startup = compute_startup (\n                thread, thread->task->taskid,0,NULL,NULL,0,0,\n                NON_BLOCKING_GLOBAL_OP_COM_TYPE,NULL);\n\n        if (startup != (t_nano) 0)\n        {\n            if (debug & D_COMM)\n            {\n                PRINT_TIMER (current_time);\n                printf (\": GLOBAL_wait \\tP%02d T%02d (t%02d) Initiate startup (%f)\\n\",\n                        IDENTIFIERS (thread),\n                        (double) startup / 1e9);\n            }\n            thread->loose_cpu     = FALSE;\n            thread->doing_startup = TRUE;\n\n            account = current_account (thread);\n            FLOAT_TO_TIMER (startup, tmp_timer);\n            ADD_TIMER (account->latency_time, tmp_timer, account->latency_time);\n            SUB_TIMER (account->cpu_time, tmp_timer, account->cpu_time);\n\n            SCHEDULER_thread_to_ready_return (M_COM, thread, startup, 0);\n            return;\n        }\n        else\n        {\n            thread->startup_done = TRUE;\n        }\n    }\n\n    /* Startup and Copy checks reset */\n    thread->startup_done = FALSE;\n    thread->copy_done    = FALSE;\n\n\n    account = current_account (thread);\n    account = current_account (thread);\n\n    // There is some non-block glop still executing\n    if (thread->n_nonblock_glob_done == 0)\n    {\n        thread->n_nonblock_glob_waiting += 1;\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\": non-block GLOBAL_wait waiting \\tP%02d T%02d (t%02d)\\n\",\n                    IDENTIFIERS (thread));\n        }\n    }\n    else\n    {\n        // Some non-block glop is done\n\n        thread->n_nonblock_glob_done -= 1;\n\n        struct t_thread * copy_thread = (struct t_thread*)outFIFO_queue(\n                &thread->nonblock_glop_done_threads);\n        delete_duplicate_thread(copy_thread);\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\n                    \": non-block GLOBAL_wait done \\tP%02d T%02d (t%02d)\\n\",\n                    IDENTIFIERS (thread));\n        }\n\n        // Then we must continue with this rank execution\n        //\n        thread->action = action->next;\n        READ_free_action(action);\n        if (more_actions (thread) )\n        {\n            thread->loose_cpu = FALSE;\n            SCHEDULER_thread_to_ready (thread);\n        }\n    }\n}\n\nvoid GLOBAL_operation (struct t_thread *thread,\n        int glop_id,\n        int comm_id,\n        int root_rank,\n        int root_thid,\n        int bytes_send,\n        int bytes_recv,\n        int synch_type)\n{\n    struct t_Ptask                *Ptask;\n    struct t_communicator         *communicator;\n    struct t_global_op_definition *glop;\n    struct t_thread               *others, *root_th;\n    struct t_account              *account;\n    struct t_cpu                  *cpu;\n    struct t_node                 *node_usat;\n    struct t_machine              *maquina_usada;\n\n    dimemas_timer                  tmp_timer;\n    struct t_queue                *nodes_per_machine;\n    int                           *tasks_per_node;\n\n    int root_task;\n    int i, kind;\n\n    int nb_glob_index;\n\n    if (with_deadlock_analysis)\n    {\n        if (DEADLOCK_new_communic_event(thread))\n            return;\n    }\n\n    /* not very clever mostly to eliminate warnings */\n    assert (root_thid >= 0);\n    assert (bytes_send >= 0);\n    assert (bytes_recv >= 0);\n\n    account = current_account (thread);\n    account->n_group_operations++;\n\n    Ptask = thread->task->Ptask;\n    communicator = locate_communicator (&Ptask->Communicator, comm_id);\n    if (communicator == COM_NIL)\n    {\n        panic (\"Communication start trough an invalid \\\n                communicator %d to P%02d T%02d (t%02d)\\n\",\n                comm_id,\n                IDENTIFIERS (thread) );\n    }\n\n    if (thread_in_communicator (communicator, thread) == FALSE)\n    {\n        panic (\"Thread P%02d T%02d (t%02d) not valid for communicator %d\\n\",\n                IDENTIFIERS (thread),\n                comm_id);\n    }\n\n    glop = (struct t_global_op_definition *)\n        query_prio_queue (&Global_op, (t_priority) glop_id);\n\n    if (glop == GOPD_NIL)\n    {\n        panic (\"Global operation faild on line 8696 communic %d undefined to P%02d T%02d (t%02d)\\n\",\n                glop_id,\n                IDENTIFIERS (thread) );\n    }\n\n    if (debug & D_COMM & synch_type != GLOBAL_OP_ASYN)\n    {\n        PRINT_TIMER (current_time);\n        printf (\n                \": GLOBAL_operation P%02d T%02d (t%02d) Starting %s (Root = %d)\\n\",\n                IDENTIFIERS (thread),\n                glop->name,\n                root_rank\n               );\n    }\n\n    // Pay the startup\n    //\n    if (synch_type == GLOBAL_OP_ASYN)\n    {\n        if (thread->startup_done == FALSE)\n        {\n            \n            int startup = compute_startup (thread,thread->task->taskid,0,\n                    NULL,NULL,0,0,NON_BLOCKING_GLOBAL_OP_COM_TYPE,NULL);\n\n            if (startup != (t_nano) 0)\n            {\n                thread->loose_cpu     = FALSE;\n                thread->doing_startup = TRUE;\n\n                account = current_account (thread);\n                FLOAT_TO_TIMER (startup, tmp_timer);\n                ADD_TIMER (account->latency_time, tmp_timer, account->latency_time);\n                SUB_TIMER (account->cpu_time, tmp_timer, account->cpu_time);\n\n                SCHEDULER_thread_to_ready_return (M_COM, thread, tmp_timer, 0);\n\n                if (debug & D_COMM)\n                {\n                    PRINT_TIMER (current_time);\n                    printf (\": non-block GLOBAL_operation \\tP%02d T%02d (t%02d) Initiate startup (%f)\\n\",\n                            IDENTIFIERS (thread),\n                            (double) startup / 1e9);\n                }\n                return;\n            }\n            else /* (startup == (t_nano) 0) */\n            {\n                thread->startup_done = TRUE;\n            }\n        }\n\n        // Like this because if latency is 0 we want to perform this piece \n        // of code anyway\n        if (thread->startup_done == TRUE)\n        {\n\n            thread->startup_done=FALSE;\n            // If startup done, then create a copy of thread for the non-blocking\n            // collective, and schedule the original for continuing with the\n            // simulation\n            //\n            struct t_thread *copy_thread;\n            copy_thread = duplicate_thread(thread);\n\n            // Reschedule the original thread\n            struct t_action * action;\n            thread->last_paraver = current_time;\n            action = thread->action;\n            thread->action = action->next;\n            READ_free_action(action);\n\n            if (more_actions (thread) )\n            {\n                thread->loose_cpu = FALSE;\n                //SCHEDULER_thread_to_ready (thread);\n                SCHEDULER_general (SCH_TIMER_OUT, thread);\n            }\n\n            // One more non-block glop in flight\n            thread->n_nonblock_glob_in_flight += 1;\n            copy_thread->nb_glob_index = thread->nb_glob_index_master;\n            thread->nb_glob_index_master++;\n\n            // It will be the index for the nonblock-glop structures\n            nb_glob_index = copy_thread->nb_glob_index;\n\n            // Create the structures for the new non-block global operation\n            struct t_queue* new_global_op_threads = malloc(sizeof(struct t_queue));\n            struct t_queue* new_global_op_machine_threads = malloc(sizeof(struct t_queue));\n            struct t_queue* new_nonblock_m_threads_with_links = malloc(sizeof(struct t_queue));\n\n            create_queue(new_global_op_threads);\n            create_queue(new_global_op_machine_threads);\n            create_queue(new_nonblock_m_threads_with_links);\n\n            insert_queue(&communicator->nonblock_global_op_threads, \n                    (char *)new_global_op_threads, nb_glob_index);\n            insert_queue(&communicator->nonblock_global_op_machine_threads, \n                    (char *)new_global_op_machine_threads, nb_glob_index);\n            insert_queue(&communicator->nonblock_m_threads_with_links, \n                    (char *)new_nonblock_m_threads_with_links, nb_glob_index);\n\n            //communicator->nonblock_current_root;\n            // Manage the glop with the copy_thread\n            thread=copy_thread;\n\n            if (debug & D_COMM)\n            {\n                PRINT_TIMER (current_time);\n                printf (\": non-block GLOBAL_operation \\tP%02d T%02d (t%02d) startup done.\\n\",\n                        IDENTIFIERS (thread));\n            }\n        }\n    }\n\n    if (synch_type != GLOBAL_OP_ASYN)\n    {\n        if (communicator->in_flight_op != TRUE)\n        {\n            communicator->in_flight_op = TRUE;\n        }\n    }\n\n    // Update the number of used nodes per machine and tasks per node\n    //\n    node_usat = get_node_of_thread (thread);\n    maquina_usada = node_usat->machine;\n\n    nodes_per_machine = (struct t_queue*)query_prio_queue(\n            &communicator->nodes_per_machine[maquina_usada->id],\n            (t_priority) node_usat->nodeid);\n\n    if (nodes_per_machine == QU_NIL)\n    {\n        int* new_node = (int*) malloc(sizeof(int));\n        (*new_node) = node_usat->nodeid;\n\n        insert_queue(&communicator->nodes_per_machine[maquina_usada->id],\n                (char*) new_node,\n                (t_priority) node_usat->nodeid);\n    }\n\n    tasks_per_node = (int*) query_prio_queue(&communicator->tasks_per_node,\n            (t_priority) node_usat->nodeid);\n    if (tasks_per_node == NULL)\n    {\n        int* new_tasks_per_node = (int*) malloc(sizeof(int));\n\n        (*new_tasks_per_node) = 1;\n        insert_queue(&communicator->tasks_per_node,\n                (char*) new_tasks_per_node,\n                (t_priority) node_usat->nodeid);\n    }\n    else\n    {\n        (*tasks_per_node) += 1;\n    }\n\n\n    /* JGG (07/07/2010): New way to choose the root */\n    if (root_rank == 1)\n    {\n        if (synch_type == GLOBAL_OP_ASYN )\n        {\n            insert_queue(&communicator->nonblock_current_root, \n                    (char*)thread, nb_glob_index);\n            //communicator->nonblock_current_root[nb_glob_index] = thread;\n        }\n        else\n        {\n            communicator->current_root = thread;\n        }\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\": GLOBAL_operation P%02d T%02d (t%02d) is the root\\n\",\n                    IDENTIFIERS (thread) );\n        }\n    }\n\n    ASS_ALL_TIMER (thread->collective_timers.arrive_to_collective, current_time);\n\n    ////////////////////////////////////////////////\n    ////////////////// SYNCH PART //////////////////\n    ////////////////////////////////////////////////\n\n    // Deciding which queue we have to take\n    //\n    struct t_queue *threads_queue;\n    if (synch_type == GLOBAL_OP_ASYN)\n    {\n        threads_queue = (struct t_queue*) query_prio_queue(&communicator->nonblock_global_op_threads, nb_glob_index);\n        //threads_queue = &communicator->nonblock_global_op_threads[nb_glob_index];\n    }\n    else\n    {\n        threads_queue = &communicator->threads;\n    }\n\n    // This is not the last thread arriving to the communication point,\n    // simply block\n    //\n    if ( communicator->size != count_queue (threads_queue) + 1)\n    {\n        cpu = get_cpu_of_thread (thread);\n        if (synch_type != GLOBAL_OP_ASYN)\n            thread->last_paraver = current_time; // TODO: Check if okay when non-block\n\n        inFIFO_queue (threads_queue, (char *) thread);\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            if (synch_type == GLOBAL_OP_ASYN)\n                printf (\n                        \": non-block GLOBAL_operation (%d)  P%02d T%02d (t%02d) Blocked on '%s' (Comm.%d: %dw / %dT)\\n\",\n                        synch_type,\n                        IDENTIFIERS (thread),\n                        glop->name,\n                        comm_id,\n                        count_queue (threads_queue),\n                        communicator->size\n                       );\n            else\n                printf (\n                        \": GLOBAL_operation (%d)  P%02d T%02d (t%02d) Blocked on '%s' (Comm.%d: %dw / %dT)\\n\",\n                        synch_type,\n                        IDENTIFIERS (thread),\n                        glop->name,\n                        comm_id,\n                        count_queue (threads_queue),\n                        communicator->size\n                       );\n        }\n\n        return;\n    }\n\n\n    if (debug & D_COMM)\n    {\n        PRINT_TIMER (current_time);\n        if (synch_type == GLOBAL_OP_ASYN)\n            printf (\n                    \": non-block GLOBAL_operation  P%02d T%02d (t%02d) Initiate '%s' (Comm.%d: %dT)\\n\",\n                    IDENTIFIERS (thread),\n                    glop->name,\n                    comm_id,\n                    communicator->size\n                   );\n\n        else\n            printf (\n                    \": GLOBAL_operation  P%02d T%02d (t%02d) Initiate '%s' (Comm.%d: %dT)\\n\",\n                    IDENTIFIERS (thread),\n                    glop->name,\n                    comm_id,\n                    communicator->size\n                   );\n    }\n\n    cpu = get_cpu_of_thread (thread);\n\n    thread->number_buses = 0;\n    thread->last_paraver = current_time;\n\n    ASS_ALL_TIMER (thread->collective_timers.sync_time, current_time);\n\n    for (others  = (struct t_thread*) head_queue (threads_queue);\n            others != TH_NIL;\n            others  = (struct t_thread*) next_queue (threads_queue) )\n    {\n        ASS_ALL_TIMER (others->collective_timers.sync_time, current_time);\n        if (synch_type == GLOBAL_OP_SYNC )\n        {\n            PARAVER_Wait (0,\n                    IDENTIFIERS (others),\n                    others->last_paraver,\n                    current_time,\n                    PRV_BLOCKED_ST\n                    //PRV_BLOCKING_SEND_ST\n                    );\n\n            others->last_paraver = current_time;\n        }\n    }\n\n    /////////////////////////////////////\n    ////////// CONTENTION PART //////////\n    /////////////////////////////////////\n\n\n    // Insert current thread to the communicator list\n    //\n    inFIFO_queue (threads_queue, (char*) thread);\n\n    // Search the root task\n    //\n\n    // Decide which current root we take\n    struct t_thread* current_root;\n\n    if (synch_type == GLOBAL_OP_ASYN )\n    {\n        current_root = (struct t_thread *) query_prio_queue(&communicator->nonblock_current_root, nb_glob_index);\n    }\n    else\n    {\n        current_root = communicator->current_root;\n    }\n\n    if (current_root == TH_NIL)\n    {\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            if (synch_type == GLOBAL_OP_ASYN)\n                printf (\": non-block GLOBAL_operation (%d)  P%02d T%02d (t%02d) Root-less operation. \\\n                        Current thread will be the root\\n\",\n                        IDENTIFIERS (thread));\n            else\n                printf (\": GLOBAL_operation (%d)  P%02d T%02d (t%02d) Root-less operation. \\\n                        Current thread will be the root\\n\",\n                        IDENTIFIERS (thread));   \n        }\n\n        if (synch_type == GLOBAL_OP_ASYN)\n        {\n            insert_queue(&communicator->nonblock_current_root, (void *) thread, nb_glob_index);\n        }\n        else\n        {\n            communicator->current_root = thread;\n        }\n        current_root = thread;\n        root_th = thread;\n        others  = thread;\n    }\n    else\n    {\n        root_th = current_root;\n        others  = current_root;\n    }\n\n    if (external_comm_library_loaded == TRUE)\n    {\n        /* JGG (08/11/2004): Check 'external_get_global_op_type' to decide if\n           its simulation will follow an external model */\n        kind = external_get_global_op_type (root_th->action->desc.global_op.comm_id,\n                root_th->action->desc.global_op.glop_id,\n                root_th->action->desc.global_op.bytes_send,\n                root_th->action->desc.global_op.bytes_recvd);\n\n        if (kind == EXTERNAL_GLOBAL_OP_MODEL)\n        {\n            /* Aqu\u00ed hay que iniciar el tratamiento del caso de una operaci\u00f3n global\n             * que sigue un modelo externo */\n            /* SE DEBER\u00cdA LLAMAR A UNA MODIFICACI\u00d3N SOBRE EL 'start_global_op' PARA\n             * EVITAR EL TIEMPO DE RESERVA DE RECURSOS */\n            start_global_op(root_th, EXTERNAL_GLOBAL_OP_MODEL);\n            return;\n        }\n    }\n    /*\n     * extract_from_queue (&communicator->threads, (char*)others);\n     * global_op_get_all_buses (others);\n     *\n     * En lloc de fer aixo (que root reservi tots el busos), a partir d'ara\n     * s'agafara un thread de cada maquina implicada per tal que agafi els\n     * busos de la seva maquina. De totes maneres, root sera l'encarregat\n     * d'agafar els de la seva maquina (tot i que no crec que calgui).\n     */\n\n    // S'obte la maquina corresponent al thread de root\n    //\n    node_usat     = get_node_of_thread (others);\n    maquina_usada = node_usat->machine;\n\n    // S'afegeix root a la llista de maquines utilitzades\n    //\n    struct t_queue* comm_machine_threads;\n    if (synch_type == GLOBAL_OP_ASYN)\n    {\n\n        comm_machine_threads = (struct t_queue *) query_prio_queue(&communicator->nonblock_global_op_machine_threads, nb_glob_index);\n        //comm_machine_threads=&communicator->nonblock_global_op_machine_threads[nb_glob_index];\n    }\n    else\n    {\n        comm_machine_threads=&communicator->machines_threads;\n    }\n\n    insert_queue (comm_machine_threads,(char*) others,\n            (t_priority) maquina_usada->id);\n\n    // Es treu de la llista de threads per poder detectar quan esta tot reservat\n    //\n    extract_from_queue (threads_queue, (char *) others);\n\n    // Es fa el mateix amb el primer thread trobat de cada nova maquina\n    //\n    others = (struct t_thread*) head_queue (threads_queue);\n\n    for (i = 0; i < (communicator->size - 1); i++)\n    {\n        node_usat = get_node_of_thread (others);\n        maquina_usada = node_usat->machine;\n\n        if( query_prio_queue (comm_machine_threads,\n                    (t_priority) maquina_usada->id) == A_NIL)\n        {\n            // Es una maquina nova, s'afegeix el thread a la llista de \n            // maquines utilitzades\n            insert_queue (comm_machine_threads, (char *) others,\n                    maquina_usada->id);\n\n            // Es treu de la llista de threads per poder detectar quan esta \n            // tot reservat\n            extract_from_queue (threads_queue, (char *) others);\n        }\n        others = (struct t_thread*) next_queue (threads_queue);\n\n        if ( (others == NULL) && (i < (communicator->size - 2) ) )\n        {\n            /* En aquest cas es deu haver extret el primer element de la llista,\n             * pero encara hauria de quedar algun thread. Per tant, agafo el\n             * primer que queda. */\n            others = (struct t_thread*) head_queue (threads_queue);\n        }\n    }\n\n    // Un thread de cada maquina reserva els recursos\n    //\n    for (others  = (struct t_thread*) head_queue (comm_machine_threads);\n            others != TH_NIL;\n            others  = (struct t_thread*) next_queue (comm_machine_threads))\n    {\n        /* Aquest thread reserva els recursos necessaris de la seva maquina */\n        /* Aixo no es podia anar fent directament al bucle anterior perque\n         * primer cal haver tret tots els threads que reserven busos, de la\n         * cua \"communicator->threads\" perque sino no es pot detectar\n         * correctament quan s'han reservat els recursos de totes les\n         * maquines. */\n        global_op_get_all_buses (others);\n    }   \n\n    /* Aqui se suposa que ja haura intentat reservar tot el que cal i si\n     * ho ha pogut fer, ja haura comenc,at la col.lectiva.  */\n}\n\nvoid COMMUNIC_reset_deadlock()\n{\n    DEADLOCK_reset();\n}\n\n\n/*\n * It supposes that any root task will synchronize with threads\n * of other tasks.\n */\nvoid ACCELERATOR_synchronization(struct t_thread* thread, int comm_id)\n{\n    int              task_id, thread_id;\n    struct t_task   *task;\n\n    thread_id = thread->threadid;\n    task      = thread->task;\n    task_id   = task->taskid;\n\n    if (thread->host)\n    { /* It is the host thread */\n        if (task->HostSync != TH_NIL && !thread->blckd_in_global_op)\n        {\n            die(\"Simultaneous accelerator synchronizations on a single host\");\n        }\n        else if (!thread->blckd_in_global_op)\n        {\n            task->HostSync = thread;\n            if (comm_id != -1)\n            {\t/* Synchronize with a single stream\t*/\n                task->KernelByComm = -1 * (comm_id + 2);\n            }\n            else\n            {\t/* In global op no single stream synchronization indicated\t*/\n                task->KernelByComm = -1;\n            }\n            thread->blckd_in_global_op = TRUE;\n        }\n\n        ACCELERATOR_check_sync_status(thread, TRUE);\n    }\n\n    else if (thread->kernel)\n    { /* It is an accelerator thread */\n        if (task->KernelSync != TH_NIL && !thread->blckd_in_global_op)\n        {\n            die(\"More than one accelerator thread during synchronization:\"\\\n                    \"P%02d T%02d (t%02d)\", IDENTIFIERS(thread));\n        }\n        else if (task->HostSync != TH_NIL)\n        {\t/* Host has arrived yet, blocked\t*/\n            if (task->KernelByComm != -1 && task->KernelByComm != thread_id)\n            {\n                die(\"In accelerator synchronization host was waiting another thread:\"\\\n                        \"P%02d T%02d (t%02d)\", IDENTIFIERS(thread));\n            }\n        }\n\n        /* Just in case thread_id is not last thread in task */\n        task->KernelSync = thread;\n        thread->blckd_in_global_op = TRUE;\n\n        ACCELERATOR_check_sync_status(thread, FALSE);\n    }\n    else\n    {\n        die(\"A non-accelerator thread is doing and accelerator synchronization:\"\\\n                \"P%02d T%02d (t%02d)\", IDENTIFIERS(thread));\n    }\n}\n\nvoid ACCELERATOR_check_sync_status(struct t_thread* thread,\n        t_boolean        host)\n{\n    struct t_thread *host_th = NULL, *kernel_th = NULL;\n    struct t_action *action;\n    struct t_task   *task = thread->task;\n    dimemas_timer tmp_timer, tmp_timer2;\n\n    dimemas_timer startup;\n    struct t_node *node;\n    struct t_dedicated_connection *connection;\n    struct t_account *account;\n    struct t_cpu *cpu;\n\n    if ( task->HostSync == TH_NIL || task->KernelSync == TH_NIL\t)\n    {\t/*\tOr kernel or host has not arrived yet, blocked\t*/\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\": ACCELERATOR_synchronization P%02d T%02d (t%02d) Blocked\",\n                    IDENTIFIERS (thread));\n\n            if (host)\n            {\n                printf (\" (HOST)\\n\");\n            }\n            else\n            {\n                printf (\" (DEVICE)\\n\");\n            }\n        }\n    }\n    else\n    {\t//Both threads ready for sync\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\": ACCELERATOR_synchronization P%02d T%02d (t%02d) Unlocks\\n\",\n                    IDENTIFIERS (thread));\n        }\n        if (host)\n        {\t/* get Kernel thread blocked */\n            kernel_th = task->KernelSync;\n            host_th = thread;\n        }\n        else\n        {\t/* get host thread blocked */\n            host_th = task->HostSync;\n            kernel_th = thread;\n        }\n\n        node = get_node_of_task (task);\n\n        if (!node->accelerator || !task->accelerator)\n        {\n            panic(\"Error in accelerator communication type in a non-accelerator task\"\\\n                    \"(check configuration file)\");\n        }\n\n        if (host_th->startup_done == FALSE)\n        {\n            startup = compute_startup (\n                    host_th,\n                    host_th->task->taskid,  /* Sender */\n                    kernel_th->task->taskid,  /* Receiver */\n                    node,\n                    node,\n                    0,\n                    0,\n                    ACCELERATOR_COM_TYPE,\n                    NULL);\n\n            if (startup != (dimemas_timer) 0)\n            {\n                host_th->loose_cpu     = FALSE;\n                host_th->doing_startup = TRUE;\n                host_th->doing_acc_comm = TRUE;\n\n                account = current_account (host_th);\n                FLOAT_TO_TIMER (startup, tmp_timer);\n                ADD_TIMER (account->latency_time, tmp_timer, account->latency_time);\n                SUB_TIMER (account->cpu_time, tmp_timer, account->cpu_time);\n\n                SCHEDULER_thread_to_ready_return (M_COM, host_th, startup, 0);\n\n                if (debug & D_COMM)\n                {\n                    PRINT_TIMER (current_time);\n                    printf (\": COMMUNIC_COLLECTIVE\\tP%02d T%02d (t%02d) Initiate startup (%f)\\n\",\n                            IDENTIFIERS (host_th),\n                            (double) startup / 1e9);\n                }\n                return;\n            }\n        }\n\n        if (kernel_th->startup_done == FALSE)\n        {\n            if (kernel_th->acc_recv_sync)\n            {\n                cpu = get_cpu_of_thread(kernel_th);\n\n                PARAVER_Not_Created(cpu->unique_number,\n                        IDENTIFIERS(kernel_th),\n                        kernel_th->acc_in_block_event.paraver_time,\n                        current_time);\n                kernel_th->last_paraver = current_time;\n\n                PARAVER_Event (cpu->unique_number,\n                        IDENTIFIERS (kernel_th),\n                        current_time,\n                        kernel_th->acc_in_block_event.type,\n                        kernel_th->acc_in_block_event.value);\n                kernel_th->acc_in_block_event.paraver_time = current_time;\n                kernel_th->acc_recv_sync = FALSE;\n            }\n\n            startup = compute_startup (kernel_th,\n                    kernel_th->task->taskid,  /* Sender */\n                    host_th->task->taskid,  /* Receiver */\n                    node,\n                    node,\n                    0,\n                    0,\n                    ACCELERATOR_COM_TYPE,\n                    NULL);\n\n            if (OCLEventEncoding_Is_OCLSyncBlock(host_th->acc_in_block_event))\n                startup = 0;\n\n            if (startup != (dimemas_timer) 0)\n            {\n                kernel_th->loose_cpu     = FALSE;\n                kernel_th->doing_startup = TRUE;\n                kernel_th->doing_acc_comm = TRUE;\n\n                account = current_account (kernel_th);\n                FLOAT_TO_TIMER (startup, tmp_timer);\n                ADD_TIMER (account->latency_time, tmp_timer, account->latency_time);\n                SUB_TIMER (account->cpu_time, tmp_timer, account->cpu_time);\n\n                SCHEDULER_thread_to_ready_return (M_COM, kernel_th, startup, 0);\n\n                if (debug & D_COMM)\n                {\n                    PRINT_TIMER (current_time);\n                    printf (\": COMMUNIC_COLLECTIVE\\tP%02d T%02d (t%02d) Initiate startup (%f)\\n\",\n                            IDENTIFIERS (kernel_th),\n                            (double) startup / 1e9);\n                }\n                return;\n            }\n        }\n\n        //Startup reset\n        host_th->startup_done = FALSE;\n        kernel_th->startup_done = FALSE;\n\n        action = kernel_th->action;\n        kernel_th->action = action->next;\n        READ_free_action(action);\n\n        if (more_actions (kernel_th) )\n        {\n            kernel_th->loose_cpu = TRUE;\n            SCHEDULER_thread_to_ready (kernel_th);\n            reload_done          = TRUE;\n        }\n\n        //end latency on host\n        startup = compute_startup (\n                host_th,\n                host_th->task->taskid,  /* Sender */\n                kernel_th->task->taskid,  /* Receiver */\n                node,\n                node,\n                0,\n                0,\n                ACCELERATOR_COM_TYPE,\n                NULL);\n\n        if (OCLEventEncoding_Is_OCLSyncBlock(host_th->acc_in_block_event))\n            startup = 0;\n\n        host_th->loose_cpu     = FALSE;\n        //host_th->doing_startup = TRUE;\n        host_th->doing_acc_comm = TRUE;\n\n        account = current_account (host_th);\n        FLOAT_TO_TIMER (startup, tmp_timer);\n        ADD_TIMER (account->latency_time, tmp_timer, account->latency_time);\n        SUB_TIMER (account->cpu_time, tmp_timer, account->cpu_time);\n\n        FLOAT_TO_TIMER (current_time, tmp_timer2);\n        ADD_TIMER (startup, tmp_timer2, tmp_timer2);\n\n        host_th->event = (struct t_event*) EVENT_timer (tmp_timer2, NOT_DAEMON, M_COM, host_th, COM_TIMER_OUT);\n\n        if (debug & D_COMM)\n        {\n            PRINT_TIMER (current_time);\n            printf (\": COMMUNIC_COLLECTIVE\\tP%02d T%02d (t%02d) Initiate final startup (%f)\\n\",\n                    IDENTIFIERS (host_th),\n                    (double) startup / 1e9);\n        }\n\n        task->HostSync \t\t\t= TH_NIL;\n        task->KernelSync \t\t= TH_NIL;\n        task->KernelByComm\t= -1;\n        host_th->blckd_in_global_op = FALSE;\n        kernel_th->blckd_in_global_op = FALSE;\n\n    }\n}\n\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-dimemas-5.4.1-7qidutrmnfvs35qaje63pj42443shndz/spack-src/common_utilities/Dimemas2Prv.h",
        "/tmp/vanessa/spack-stage/spack-stage-dimemas-5.4.1-7qidutrmnfvs35qaje63pj42443shndz/spack-src/GUI/dimemas-gui-5.3.4.jar",
        "/tmp/vanessa/spack-stage/spack-stage-dimemas-5.4.1-7qidutrmnfvs35qaje63pj42443shndz/spack-src/GUI/.anjuta_sym_db.db",
        "/tmp/vanessa/spack-stage/spack-stage-dimemas-5.4.1-7qidutrmnfvs35qaje63pj42443shndz/spack-src/GUI/src/resources/dimemas_icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-dimemas-5.4.1-7qidutrmnfvs35qaje63pj42443shndz/spack-src/GUI/src/resources/bsc_logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dimemas-5.4.1-7qidutrmnfvs35qaje63pj42443shndz/spack-src/GUI/lib/commons-io-2.4.jar",
        "/tmp/vanessa/spack-stage/spack-stage-dimemas-5.4.1-7qidutrmnfvs35qaje63pj42443shndz/spack-src/Simulator/model/.communic.c.swo"
    ],
    "total_files": 244
}