{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/HDF5/src/itkhdf5/src/H5PLpkg.h": "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Copyright by The HDF Group.                                               *\n * Copyright by the Board of Trustees of the University of Illinois.         *\n * All rights reserved.                                                      *\n *                                                                           *\n * This file is part of HDF5.  The full HDF5 copyright notice, including     *\n * terms governing use, modification, and redistribution, is contained in    *\n * the COPYING file, which can be found at the root of the source code       *\n * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *\n * If you do not have access to either file, you may request a copy from     *\n * help@hdfgroup.org.                                                        *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/*\n * Purpose: This file contains declarations which are visible only within\n *          the H5PL package.  Source files outside the H5PL package should\n *          include H5PLprivate.h instead.\n */\n\n#if !(defined H5PL_FRIEND || defined H5PL_MODULE)\n#error \"Do not include this file outside the H5PL package!\"\n#endif\n\n#ifndef _H5PLpkg_H\n#define _H5PLpkg_H\n\n/* Include private header file */\n#include \"H5PLprivate.h\"          /* Filter functions                */\n\n/* Other private headers needed by this file */\n\n/**************************/\n/* Package Private Macros */\n/**************************/\n\n/* Whether to pre-load pathnames for plugin libraries */\n#define H5PL_DEFAULT_PATH       H5_DEFAULT_PLUGINDIR\n\n\n/****************************/\n/* Macros for supporting    */\n/* both Windows and POSIX   */\n/****************************/\n\n/*******************/\n/* Windows support */\n/*******************/\n/*\n * SPECIAL WINDOWS NOTE\n *\n * Some of the Win32 API functions expand to fooA or fooW depending on\n * whether UNICODE or _UNICODE are defined. You MUST explicitly use\n * the A version of the functions to force char * behavior until we\n * work out a scheme for proper Windows Unicode support.\n *\n * If you do not do this, people will be unable to incorporate our\n * source code into their own CMake builds if they define UNICODE.\n */\n#ifdef H5_HAVE_WIN32_API\n\n    /* The path separator on this platform */\n#   define H5PL_PATH_SEPARATOR      \";\"\n\n    /* Handle for dynamic library */\n#   define H5PL_HANDLE HINSTANCE\n\n    /* Get a handle to a plugin library.  Windows: TEXT macro handles Unicode strings */\n#   define H5PL_OPEN_DLIB(S) LoadLibraryExA(S, NULL, LOAD_WITH_ALTERED_SEARCH_PATH)\n\n    /* Get the address of a symbol in dynamic library */\n#   define H5PL_GET_LIB_FUNC(H,N) GetProcAddress(H,N)\n\n    /* Close dynamic library */\n#   define H5PL_CLOSE_LIB(H) FreeLibrary(H)\n\n    /* Clear error - nothing to do */\n#   define H5PL_CLR_ERROR\n\n    /* maximum size for expanding env vars */\n#   define H5PL_EXPAND_BUFFER_SIZE 32767\n\n    typedef const void *(__cdecl *H5PL_get_plugin_info_t)(void);\n\n#else /* H5_HAVE_WIN32_API */\n\n    /*****************/\n    /* POSIX support */\n    /*****************/\n\n    /* The path separator on this platform */\n#   define H5PL_PATH_SEPARATOR     \":\"\n\n    /* Handle for dynamic library */\n#   define H5PL_HANDLE void *\n\n    /* Get a handle to a plugin library.  Windows: TEXT macro handles Unicode strings */\n#   define H5PL_OPEN_DLIB(S) dlopen(S, RTLD_LAZY)\n\n    /* Get the address of a symbol in dynamic library */\n#   define H5PL_GET_LIB_FUNC(H,N) dlsym(H,N)\n\n    /* Close dynamic library */\n#   define H5PL_CLOSE_LIB(H) dlclose(H)\n\n    /* Clear error */\n#   define H5PL_CLR_ERROR HERROR(H5E_PLUGIN, H5E_CANTGET, \"can't dlopen:%s\", dlerror())\n\n    typedef const void *(*H5PL_get_plugin_info_t)(void);\n#endif /* H5_HAVE_WIN32_API */\n\n\n/****************************/\n/* Package Private Typedefs */\n/****************************/\n\n/* Data used to search for plugins */\ntypedef struct H5PL_search_params_t {\n    H5PL_type_t         type;\n    H5PL_key_t          key;\n} H5PL_search_params_t;\n\n\n/*****************************/\n/* Package Private Variables */\n/*****************************/\n\n\n/******************************/\n/* Package Private Prototypes */\n/******************************/\n\n/* Accessors to global variables and flags */\nH5_DLL herr_t H5PL__get_plugin_control_mask(unsigned int *mask /*out*/);\nH5_DLL herr_t H5PL__set_plugin_control_mask(unsigned int mask);\n\n/* Plugin search and manipulation */\nH5_DLL herr_t H5PL__open(const char *libname, H5PL_type_t type, H5PL_key_t key, hbool_t *success /*out*/, const void **plugin_info /*out*/);\nH5_DLL herr_t H5PL__close(H5PL_HANDLE handle);\n\n/* Plugin cache calls */\nH5_DLL herr_t H5PL__create_plugin_cache(void);\nH5_DLL herr_t H5PL__close_plugin_cache(hbool_t *already_closed /*out*/);\nH5_DLL herr_t H5PL__add_plugin(H5PL_type_t type, H5PL_key_t key, H5PL_HANDLE handle);\nH5_DLL herr_t H5PL__find_plugin_in_cache(const H5PL_search_params_t *search_params, hbool_t *found /*out*/, const void **plugin_info /*out*/);\n\n/* Plugin search path calls */\nH5_DLL herr_t H5PL__create_path_table(void);\nH5_DLL herr_t H5PL__close_path_table(void);\nH5_DLL unsigned H5PL__get_num_paths(void);\nH5_DLL herr_t H5PL__append_path(const char *path);\nH5_DLL herr_t H5PL__prepend_path(const char *path);\nH5_DLL herr_t H5PL__replace_path(const char *path, unsigned int index);\nH5_DLL herr_t H5PL__insert_path(const char *path, unsigned int index);\nH5_DLL herr_t H5PL__remove_path(unsigned int index);\nH5_DLL const char *H5PL__get_path(unsigned int index);\nH5_DLL herr_t H5PL__find_plugin_in_path_table(const H5PL_search_params_t *search_params, hbool_t *found /*out*/, const void **plugin_info /*out*/);\n\n#endif /* _H5PLpkg_H */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/HDF5/src/itkhdf5/src/H5PLint.c": "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Copyright by The HDF Group.                                               *\n * All rights reserved.                                                      *\n *                                                                           *\n * This file is part of HDF5. The full HDF5 copyright notice, including      *\n * terms governing use, modification, and redistribution, is contained in    *\n * the COPYING file, which can be found at the root of the source code       *\n * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *\n * If you do not have access to either file, you may request a copy from     *\n * help@hdfgroup.org.                                                        *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/*\n * Purpose: Internal routines for managing plugins.\n *\n */\n\n\n/****************/\n/* Module Setup */\n/****************/\n\n#include \"H5PLmodule.h\"          /* This source code file is part of the H5PL module */\n\n\n/***********/\n/* Headers */\n/***********/\n#include \"H5private.h\"      /* Generic Functions            */\n#include \"H5Eprivate.h\"     /* Error handling               */\n#include \"H5MMprivate.h\"    /* Memory management            */\n#include \"H5PLpkg.h\"        /* Plugin                       */\n#include \"H5Zprivate.h\"     /* Filter pipeline              */\n\n\n/****************/\n/* Local Macros */\n/****************/\n\n\n/******************/\n/* Local Typedefs */\n/******************/\n\n\n/********************/\n/* Local Prototypes */\n/********************/\n\n\n/*********************/\n/* Package Variables */\n/*********************/\n\n/* Package initialization variable */\nhbool_t H5_PKG_INIT_VAR = FALSE;\n\n\n/*****************************/\n/* Library Private Variables */\n/*****************************/\n\n\n/*******************/\n/* Local Variables */\n/*******************/\n\n/* Bitmask that controls whether classes of plugins\n * (e.g.: filters, VOL drivers) can be loaded.\n */\nstatic unsigned int     H5PL_plugin_control_mask_g = H5PL_ALL_PLUGIN;\n\n/* This flag will be set to FALSE if the HDF5_PLUGIN_PRELOAD\n * environment variable was set to H5PL_NO_PLUGIN at\n * package initialization.\n */\nstatic hbool_t          H5PL_allow_plugins_g = TRUE;\n\n\n\f\n/*-------------------------------------------------------------------------\n * Function:    H5PL__get_plugin_control_mask\n *\n * Purpose:     Gets the internal plugin control mask value.\n *\n * Return:      SUCCEED/FAIL\n *\n *-------------------------------------------------------------------------\n */\nherr_t\nH5PL__get_plugin_control_mask(unsigned int *mask /*out*/)\n{\n    herr_t      ret_value = SUCCEED;    /* Return value */\n\n    FUNC_ENTER_PACKAGE_NOERR\n\n    /* Check args - Just assert on package functions */\n    HDassert(mask);\n\n    /* Return the mask */\n    *mask = H5PL_plugin_control_mask_g;\n\n    FUNC_LEAVE_NOAPI(ret_value)\n\n} /* end H5PL__get_plugin_control_mask() */\n\n\f\n/*-------------------------------------------------------------------------\n * Function:    H5PL__set_plugin_control_mask\n *\n * Purpose:     Sets the internal plugin control mask value.\n *\n * Return:      SUCCEED/FAIL\n *\n *-------------------------------------------------------------------------\n */\nherr_t\nH5PL__set_plugin_control_mask(unsigned int mask)\n{\n    herr_t      ret_value = SUCCEED;    /* Return value */\n\n    FUNC_ENTER_PACKAGE_NOERR\n\n    /* Only allow setting this if plugins have not been disabled.\n     * XXX: Note that we don't consider this an error, but instead\n     *      silently ignore it. We may want to consider this behavior\n     *      more carefully.\n     */\n    if (H5PL_allow_plugins_g)\n        H5PL_plugin_control_mask_g = mask;\n\n    FUNC_LEAVE_NOAPI(ret_value)\n\n} /* end H5PL__set_plugin_control_mask() */\n\n\f\n/*-------------------------------------------------------------------------\n * Function:    H5PL__init_package\n *\n * Purpose:     Initialize any package-specific data and call any init\n *              routines for the package.\n *\n * Return:      SUCCEED/FAIL\n *\n *-------------------------------------------------------------------------\n */\nherr_t\nH5PL__init_package(void)\n{\n    char        *env_var = NULL;\n    herr_t      ret_value = SUCCEED;\n\n    FUNC_ENTER_PACKAGE\n\n    /* Check the environment variable to determine if the user wants\n     * to ignore plugins. The special symbol H5PL_NO_PLUGIN (defined in\n     * H5PLpublic.h) means we don't want to load plugins.\n     */\n    if (NULL != (env_var = HDgetenv(\"HDF5_PLUGIN_PRELOAD\")))\n        if (!HDstrcmp(env_var, H5PL_NO_PLUGIN)) {\n            H5PL_plugin_control_mask_g = 0;\n            H5PL_allow_plugins_g = FALSE;\n        }\n\n    /* Create the table of previously-loaded plugins */\n    if (H5PL__create_plugin_cache() < 0)\n        HGOTO_ERROR(H5E_PLUGIN, H5E_CANTINIT, FAIL, \"can't create plugin cache\")\n\n    /* Create the table of search paths for dynamic libraries */\n    if (H5PL__create_path_table() < 0)\n        HGOTO_ERROR(H5E_PLUGIN, H5E_CANTINIT, FAIL, \"can't create plugin search path table\")\n\ndone:\n    FUNC_LEAVE_NOAPI(ret_value)\n} /* end H5PL__init_package() */\n\n\f\n/*-------------------------------------------------------------------------\n * Function:    H5PL_term_package\n *\n * Purpose:     Terminate the H5PL interface: release all memory, reset all\n *              global variables to initial values. This only happens if all\n *              types have been destroyed from other interfaces.\n *\n * Return:      Success:    Positive if any action was taken that might\n *                          affect some other interface; zero otherwise\n *              Failure:    Negative\n *\n *-------------------------------------------------------------------------\n */\nint\nH5PL_term_package(void)\n{\n    hbool_t already_closed = FALSE;\n    int     ret_value = 0;\n\n    FUNC_ENTER_NOAPI_NOINIT\n\n    if (H5_PKG_INIT_VAR) {\n\n        /* Close the plugin cache.\n         * We need to bump the return value if we did any real work here.\n         */\n        if (H5PL__close_plugin_cache(&already_closed) < 0)\n            HGOTO_ERROR(H5E_PLUGIN, H5E_CANTFREE, (-1), \"problem closing plugin cache\")\n        if (!already_closed)\n            ret_value++;\n\n        /* Close the search path table and free the paths */\n        if (H5PL__close_path_table() < 0)\n            HGOTO_ERROR(H5E_PLUGIN, H5E_CANTFREE, (-1), \"problem closing search path table\")\n\n        /* Mark the interface as uninitialized */\n        if (0 == ret_value)\n            H5_PKG_INIT_VAR = FALSE;\n    } /* end if */\n\ndone:\n    FUNC_LEAVE_NOAPI(ret_value)\n} /* end H5PL_term_package() */\n\n\f\n/*-------------------------------------------------------------------------\n * Function:    H5PL_load\n *\n * Purpose:     Given the plugin type and identifier, this function searches\n *              for and, if found, loads a dynamic plugin library.\n *\n *              The function searches first in the cached plugins and then\n *              in the paths listed in the path table.\n *\n * Return:      Success:    A pointer to the plugin info\n *              Failure:    NULL\n *\n *-------------------------------------------------------------------------\n */\nconst void *\nH5PL_load(H5PL_type_t type, H5PL_key_t key)\n{\n    H5PL_search_params_t    search_params;          /* Plugin search parameters     */\n    hbool_t                 found = FALSE;          /* Whether the plugin was found */\n    const void             *plugin_info = NULL;     /* Information from the plugin  */\n    const void             *ret_value = NULL;\n\n    FUNC_ENTER_NOAPI(NULL)\n\n    /* Check if plugins can be loaded for this plugin type */\n    switch (type) {\n        case H5PL_TYPE_FILTER:\n            if ((H5PL_plugin_control_mask_g & H5PL_FILTER_PLUGIN) == 0)\n                HGOTO_ERROR(H5E_PLUGIN, H5E_CANTLOAD, NULL, \"filter plugins disabled\")\n            break;\n        case H5PL_TYPE_ERROR:\n        case H5PL_TYPE_NONE:\n        default:\n            HGOTO_ERROR(H5E_PLUGIN, H5E_CANTLOAD, NULL, \"Invalid plugin type specified\")\n    }\n\n    /* Set up the search parameters */\n    search_params.type = type;\n    search_params.key.id = key.id;\n\n    /* Search in the table of already loaded plugin libraries */\n    if(H5PL__find_plugin_in_cache(&search_params, &found, &plugin_info) < 0)\n        HGOTO_ERROR(H5E_PLUGIN, H5E_CANTGET, NULL, \"search in plugin cache  failed\")\n\n    /* If not found, try iterating through the path table to find an appropriate plugin */\n    if (!found)\n        if (H5PL__find_plugin_in_path_table(&search_params, &found, &plugin_info) < 0)\n            HGOTO_ERROR(H5E_PLUGIN, H5E_CANTGET, NULL, \"search in path table failed\")\n\n    /* Set the return value we found the plugin */\n    if (found)\n        ret_value = plugin_info;\n\ndone:\n    FUNC_LEAVE_NOAPI(ret_value)\n} /* end H5PL_load() */\n\n\f\n/*-------------------------------------------------------------------------\n * Function:    H5PL__open\n *\n * Purpose:     Opens a plugin.\n *\n *              The success parameter will be set to TRUE and the plugin_info\n *              parameter will be filled in on success. Otherwise, they\n *              will be FALSE and NULL, respectively.\n *\n * Return:      SUCCEED/FAIL\n *\n *-------------------------------------------------------------------------\n */\n/* NOTE: We turn off -Wpedantic in gcc to quiet a warning about converting\n *       object pointers to function pointers, which is undefined in ANSI C.\n *       This is basically unavoidable due to the nature of dlsym() and *is*\n *       defined in POSIX, so it's fine.\n *\n *       This pragma only needs to surround the assignment of the\n *       get_plugin_info function pointer, but early (4.4.7, at least) gcc\n *       only allows diagnostic pragmas to be toggled outside of functions.\n */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpedantic\"\nherr_t\nH5PL__open(const char *path, H5PL_type_t type, H5PL_key_t key, hbool_t *success, const void **plugin_info)\n{\n    H5PL_HANDLE             handle = NULL;\n    H5PL_get_plugin_info_t  get_plugin_info = NULL;\n    herr_t                  ret_value = SUCCEED;\n\n    FUNC_ENTER_PACKAGE\n\n    /* Check args - Just assert on package functions */\n    HDassert(path);\n    HDassert(success);\n    HDassert(plugin_info);\n\n    /* Initialize out parameters */\n    *success = FALSE;\n    *plugin_info = NULL;\n\n    /* There are different reasons why a library can't be open, e.g. wrong architecture.\n     * If we can't open the library, just return.\n     */\n    if (NULL == (handle = H5PL_OPEN_DLIB(path))) {\n        H5PL_CLR_ERROR; /* clear error */\n        HGOTO_DONE(SUCCEED)\n    }\n\n    /* Return a handle for the function H5PLget_plugin_info in the dynamic library.\n     * The plugin library is suppose to define this function.\n     */\n    if (NULL == (get_plugin_info = (H5PL_get_plugin_info_t)H5PL_GET_LIB_FUNC(handle, \"H5PLget_plugin_info\")))\n        HGOTO_DONE(SUCCEED)\n\n    /* Get the plugin information */\n    switch (type) {\n        case H5PL_TYPE_FILTER:\n        {\n            const H5Z_class2_t *filter_info;\n\n            /* Get the plugin info */\n            if (NULL == (filter_info = (const H5Z_class2_t *)(*get_plugin_info)()))\n                HGOTO_ERROR(H5E_PLUGIN, H5E_CANTGET, FAIL, \"can't get filter info from plugin\")\n\n            /* If the filter IDs match, we're done. Set the output parameters. */\n            if (filter_info->id == key.id) {\n                *plugin_info = (const void *)filter_info;\n                *success = TRUE;\n            }\n\n            break;\n        }\n        case H5PL_TYPE_ERROR:\n        case H5PL_TYPE_NONE:\n        default:\n            HGOTO_ERROR(H5E_PLUGIN, H5E_CANTGET, FAIL, \"Invalid plugin type specified\")\n    } /* end switch */\n\n    /* If we found the correct plugin, store it in the cache */\n    if (*success)\n        if (H5PL__add_plugin(type, key, handle))\n            HGOTO_ERROR(H5E_PLUGIN, H5E_CANTINSERT, FAIL, \"unable to add new plugin to plugin cache\")\n\ndone:\n    if (!(*success) && handle)\n        if (H5PL__close(handle) < 0)\n            HDONE_ERROR(H5E_PLUGIN, H5E_CLOSEERROR, FAIL, \"can't close dynamic library\")\n\n    FUNC_LEAVE_NOAPI(ret_value)\n} /* end H5PL__open() */\n#pragma GCC diagnostic pop\n\n\f\n/*-------------------------------------------------------------------------\n * Function:    H5PL__close\n *\n * Purpose:     Closes the handle for dynamic library\n *\n * Return:      SUCCEED/FAIL\n *\n *-------------------------------------------------------------------------\n */\nherr_t\nH5PL__close(H5PL_HANDLE handle)\n{\n    FUNC_ENTER_PACKAGE_NOERR\n\n    H5PL_CLOSE_LIB(handle);\n\n    FUNC_LEAVE_NOAPI(SUCCEED)\n} /* end H5PL__close() */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/KWSys/src/KWSys/DynamicLoader.cxx": "/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying\n   file Copyright.txt or https://cmake.org/licensing#kwsys for details.  */\n#if defined(_WIN32)\n#  define NOMINMAX // hide min,max to not conflict with <limits>\n#endif\n\n#include \"kwsysPrivate.h\"\n#include KWSYS_HEADER(DynamicLoader.hxx)\n\n#include KWSYS_HEADER(Configure.hxx)\n#include KWSYS_HEADER(Encoding.hxx)\n\n// Work-around CMake dependency scanning limitation.  This must\n// duplicate the above list of headers.\n#if 0\n#  include \"Configure.hxx.in\"\n#  include \"DynamicLoader.hxx.in\"\n#endif\n\n// This file actually contains several different implementations:\n// * NOOP for environments without dynamic libs\n// * HP machines which uses shl_load\n// * Mac OS X 10.2.x and earlier which uses NSLinkModule\n// * Windows which uses LoadLibrary\n// * BeOS / Haiku\n// * FreeMiNT for Atari\n// * Default implementation for *NIX systems (including Mac OS X 10.3 and\n//   later) which use dlopen\n//\n// Each part of the ifdef contains a complete implementation for\n// the static methods of DynamicLoader.\n\n#define CHECK_OPEN_FLAGS(var, supported, ret)                                 \\\n  do {                                                                        \\\n    /* Check for unknown flags. */                                            \\\n    if ((var & AllOpenFlags) != var) {                                        \\\n      return ret;                                                             \\\n    }                                                                         \\\n                                                                              \\\n    /* Check for unsupported flags. */                                        \\\n    if ((var & (supported)) != var) {                                         \\\n      return ret;                                                             \\\n    }                                                                         \\\n  } while (0)\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  return DynamicLoader::OpenLibrary(libname, 0);\n}\n}\n\n#if !KWSYS_SUPPORTS_SHARED_LIBS\n// Implementation for environments without dynamic libs\n#  include <string.h> // for strerror()\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname, int flags)\n{\n  return 0;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    return 0;\n  }\n\n  return 1;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  return 0;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return \"General error\";\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__hpux)\n// Implementation for HPUX machines\n#  include <dl.h>\n#  include <errno.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname, int flags)\n{\n  CHECK_OPEN_FLAGS(flags, 0, 0);\n\n  return shl_load(libname.c_str(), BIND_DEFERRED | DYNAMIC_PATH, 0L);\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    return 0;\n  }\n  return !shl_unload(lib);\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  void* addr;\n  int status;\n\n  /* TYPE_PROCEDURE Look for a function or procedure. (This used to be default)\n   * TYPE_DATA      Look for a symbol in the data segment (for example,\n   * variables).\n   * TYPE_UNDEFINED Look for any symbol.\n   */\n  status = shl_findsym(&lib, sym.c_str(), TYPE_UNDEFINED, &addr);\n  void* result = (status < 0) ? (void*)0 : addr;\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\nconst char* DynamicLoader::LastError()\n{\n  // TODO: Need implementation with errno/strerror\n  /* If successful, shl_findsym returns an integer (int) value zero. If\n   * shl_findsym cannot find sym, it returns -1 and sets errno to zero.\n   * If any other errors occur, shl_findsym returns -1 and sets errno to one\n   * of these values (defined in <errno.h>):\n   * ENOEXEC\n   * A format error was detected in the specified library.\n   * ENOSYM\n   * A symbol on which sym depends could not be found.\n   * EINVAL\n   * The specified handle is invalid.\n   */\n\n  if (errno == ENOEXEC || errno == ENOSYM || errno == EINVAL) {\n    return strerror(errno);\n  }\n  // else\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__APPLE__) && (MAC_OS_X_VERSION_MAX_ALLOWED < 1030)\n// Implementation for Mac OS X 10.2.x and earlier\n#  include <mach-o/dyld.h>\n#  include <string.h> // for strlen\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname, int flags)\n{\n  CHECK_OPEN_FLAGS(flags, 0, 0);\n\n  NSObjectFileImageReturnCode rc;\n  NSObjectFileImage image = 0;\n\n  rc = NSCreateObjectFileImageFromFile(libname.c_str(), &image);\n  // rc == NSObjectFileImageInappropriateFile when trying to load a dylib file\n  if (rc != NSObjectFileImageSuccess) {\n    return 0;\n  }\n  NSModule handle = NSLinkModule(image, libname.c_str(),\n                                 NSLINKMODULE_OPTION_BINDNOW |\n                                   NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n  NSDestroyObjectFileImage(image);\n  return handle;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  // NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED\n  // With  this  option  the memory for the module is not deallocated\n  // allowing pointers into the module to still be valid.\n  // You should use this option instead if your code experience some problems\n  // reported against Panther 10.3.9 (fixed in Tiger 10.4.2 and up)\n  bool success = NSUnLinkModule(lib, NSUNLINKMODULE_OPTION_NONE);\n  return success;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  void* result = 0;\n  // Need to prepend symbols with '_' on Apple-gcc compilers\n  std::string rsym = '_' + sym;\n\n  NSSymbol symbol = NSLookupSymbolInModule(lib, rsym.c_str());\n  if (symbol) {\n    result = NSAddressOfSymbol(symbol);\n  }\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n// Implementation for Windows win32 code but not cygwin\n#  include <windows.h>\n\n#  include <stdio.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname, int flags)\n{\n  CHECK_OPEN_FLAGS(flags, SearchBesideLibrary, nullptr);\n\n  DWORD llFlags = 0;\n  if (flags & SearchBesideLibrary) {\n    llFlags |= LOAD_WITH_ALTERED_SEARCH_PATH;\n  }\n\n  return LoadLibraryExW(Encoding::ToWindowsExtendedPath(libname).c_str(),\n                        nullptr, llFlags);\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  return (int)FreeLibrary(lib);\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // TODO: The calling convention affects the name of the symbol.  We\n  // should have a tool to help get the symbol with the desired\n  // calling convention.  Currently we assume cdecl.\n  //\n  // Borland:\n  //   __cdecl    = \"_func\" (default)\n  //   __fastcall = \"@_func\"\n  //   __stdcall  = \"func\"\n  //\n  // Watcom:\n  //   __cdecl    = \"_func\"\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //   __watcall  = \"func_\" (default)\n  //\n  // MSVC:\n  //   __cdecl    = \"func\" (default)\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //\n  // Note that the \"@X\" part of the name above is the total size (in\n  // bytes) of the arguments on the stack.\n  void* result;\n#  if defined(__BORLANDC__) || defined(__WATCOMC__)\n  // Need to prepend symbols with '_'\n  std::string ssym = '_' + sym;\n  const char* rsym = ssym.c_str();\n#  else\n  const char* rsym = sym.c_str();\n#  endif\n  result = (void*)GetProcAddress(lib, rsym);\n// Hack to cast pointer-to-data to pointer-to-function.\n#  ifdef __WATCOMC__\n  return *(DynamicLoader::SymbolPointer*)(&result);\n#  else\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n#  endif\n}\n\n#  define DYNLOAD_ERROR_BUFFER_SIZE 1024\n\nconst char* DynamicLoader::LastError()\n{\n  wchar_t lpMsgBuf[DYNLOAD_ERROR_BUFFER_SIZE + 1];\n\n  DWORD error = GetLastError();\n  DWORD length = FormatMessageW(\n    FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, error,\n    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language\n    lpMsgBuf, DYNLOAD_ERROR_BUFFER_SIZE, nullptr);\n\n  static char str[DYNLOAD_ERROR_BUFFER_SIZE + 1];\n\n  if (length < 1) {\n    /* FormatMessage failed.  Use a default message.  */\n    _snprintf(str, DYNLOAD_ERROR_BUFFER_SIZE,\n              \"DynamicLoader encountered error 0x%X.  \"\n              \"FormatMessage failed with error 0x%X\",\n              error, GetLastError());\n    return str;\n  }\n\n  if (!WideCharToMultiByte(CP_UTF8, 0, lpMsgBuf, -1, str,\n                           DYNLOAD_ERROR_BUFFER_SIZE, nullptr, nullptr)) {\n    /* WideCharToMultiByte failed.  Use a default message.  */\n    _snprintf(str, DYNLOAD_ERROR_BUFFER_SIZE,\n              \"DynamicLoader encountered error 0x%X.  \"\n              \"WideCharToMultiByte failed with error 0x%X\",\n              error, GetLastError());\n  }\n\n  return str;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__BEOS__)\n// Implementation for BeOS / Haiku\n#  include <string.h> // for strerror()\n\n#  include <be/kernel/image.h>\n#  include <be/support/Errors.h>\n\nnamespace KWSYS_NAMESPACE {\n\nstatic image_id last_dynamic_err = B_OK;\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname, int flags)\n{\n  CHECK_OPEN_FLAGS(flags, 0, 0);\n\n  // image_id's are integers, errors are negative. Add one just in case we\n  //  get a valid image_id of zero (is that even possible?).\n  image_id rc = load_add_on(libname.c_str());\n  if (rc < 0) {\n    last_dynamic_err = rc;\n    return 0;\n  }\n\n  return rc + 1;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    last_dynamic_err = B_BAD_VALUE;\n    return 0;\n  } else {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    status_t rc = unload_add_on(lib - 1);\n    if (rc != B_OK) {\n      last_dynamic_err = rc;\n      return 0;\n    }\n  }\n\n  return 1;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n\n  result.psym = nullptr;\n\n  if (!lib) {\n    last_dynamic_err = B_BAD_VALUE;\n  } else {\n    // !!! FIXME: BeOS can do function-only lookups...does this ever\n    // !!! FIXME:  actually _want_ a data symbol lookup, or was this union\n    // !!! FIXME:  a leftover of dlsym()? (s/ANY/TEXT for functions only).\n    status_t rc =\n      get_image_symbol(lib - 1, sym.c_str(), B_SYMBOL_TYPE_ANY, &result.pvoid);\n    if (rc != B_OK) {\n      last_dynamic_err = rc;\n      result.psym = nullptr;\n    }\n  }\n  return result.psym;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  const char* retval = strerror(last_dynamic_err);\n  last_dynamic_err = B_OK;\n  return retval;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__MINT__)\n// Implementation for FreeMiNT on Atari\n#  define _GNU_SOURCE /* for program_invocation_name */\n#  include <dld.h>\n#  include <errno.h>\n#  include <malloc.h>\n#  include <string.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname, int flags)\n{\n  CHECK_OPEN_FLAGS(flags, 0, nullptr);\n\n  char* name = (char*)calloc(1, libname.size() + 1);\n  dld_init(program_invocation_name);\n  strncpy(name, libname.c_str(), libname.size());\n  dld_link(libname.c_str());\n  return (void*)name;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  dld_unlink_by_file((char*)lib, 0);\n  free(lib);\n  return 0;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dld_get_symbol(sym.c_str());\n  return result.psym;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return dld_strerror(dld_errno);\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#else\n// Default implementation for *NIX systems (including Mac OS X 10.3 and\n// later) which use dlopen\n#  include <dlfcn.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname, int flags)\n{\n  CHECK_OPEN_FLAGS(flags, 0, nullptr);\n\n  return dlopen(libname.c_str(), RTLD_LAZY);\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (lib) {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    return !dlclose(lib);\n  }\n  // else\n  return 0;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dlsym(lib, sym.c_str());\n  return result.psym;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return dlerror();\n}\n\n} // namespace KWSYS_NAMESPACE\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Testing/Data/Input/012345.002.050.README",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Wrapping/Generators/Ruby/module_ext.i.in",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Wrapping/Generators/Java/Tests/argparser.jar",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/GitCheatSheet.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/itkBanner.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/FaceBoundaryCalculator.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/CoolColormapFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/SpringColormapFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/itkBannerSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/itkLogoSmallTransparentBackground.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/SummerColormapFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/itkLogoSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/ITKLogo_64px.ico",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/Threading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/Streaming.gif",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/PadImageFilter.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/WrapPadImageFilter.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/WinterColormapFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/ITKLogo_32px.ico",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/itkLogoMedium.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/itkLogoMediumTransparentBackground.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/GreyColormapFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/AutumnColormapFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/MirrorPadImageFilter.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/itkLogoTransparentBackground.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/GreenColormapFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/itkLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/HotColormapFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/OverUnderColormapFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/HSVColormapFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/CopperColormapFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/JetColormapFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/BinShrinkGrid.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/RedColormapFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Documentation/Art/BlueColormapFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/itkBrainSliceComplexPhase.mha",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySliceBorder20.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/HoughTransformTwoLines.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySliceBorder20.raw",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/FatMRISlice.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/FFTcenteredDC.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySliceShifted13x17yDirectionPlus30.zraw",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainT1Slice.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySliceRotated10.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySlice.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/VisibleWomanHeadSlice.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/KmeansTest_T1KmeansPrelimSegmentation.nii.gz",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/HoughTransformTwoCircles.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainT1SliceBorder20.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/FFTCosinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/WatershedSegmentation.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/CorpusCallosumMode1.mha",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySliceBSplined10.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/FivePoints.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySliceBorder20Mask.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/itkBrainSliceComplex.mha",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/Circle.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/Point.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySliceR10X13Y17.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/CorpusCallosumMode0.mha",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySliceShifted13x17yDirectionPlus30.raw",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/CorpusCallosumMode2.mha",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySlice256x256.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/CorpusCallosumMeanShape.mha",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainMidSagittalSlice.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/DiagonalLines.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/ResampleImageFilterInput2x3b.raw",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensity3Slices.raw",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySliceBorder20.zraw",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/RatLungSlice2.raw",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BayesianClassifierInitializerMemberships.raw",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/KmeansTest_T1UCharRaw.nii.gz",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/KmeansTest_T1RawSkullStrip.nii.gz",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/VentricleModel.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/itkBrainSliceComplexMagnitude.mha",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySliceR10X13Y17S12.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySliceShifted13x17y.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySliceShifted13x17y.raw",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/FivePointsDilated.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BinaryImage.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySliceBorder20DirectionPlus30.raw",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/RatLungSlice1.raw",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/VisibleWomanEyeSlice.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainT1SliceBorder20DirectionPlus30.zraw",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/ResampleImageFilterInput2x3.raw",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainT1SliceBorder20DirectionPlus30.raw",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/CircleSpikes.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/FFTcorneredDC.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Examples/Data/BrainProtonDensitySlice2x3.png",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/OpenJPEG/src/README-ITK.txt",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/OpenJPEG/src/openjpeg/event.h",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/OpenJPEG/src/openjpeg/image.c",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/OpenJPEG/src/openjpeg/openjpeg.c",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/OpenJPEG/src/openjpeg/event.c",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/OpenJPEG/src/openjpeg/opj_includes.h",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/OpenJPEG/src/openjpeg/image.h",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/OpenJPEG/src/openjpeg/j2k_lib.h",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/OpenJPEG/src/openjpeg/jp2.c",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/OpenJPEG/src/openjpeg/j2k_lib.c",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/GDCM/src/gdcm/Source/DataDictionary/06_03_list.txt",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/GDCM/src/gdcm/Source/DataDictionary/README.txt",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/GDCM/src/gdcm/Source/DataDictionary/dicomhdr.html",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/VNL/src/vxl/core/vnl/io/tests/golden_test_vnl_io.bvl",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/amoeba_algorithm.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/HDF5/src/itkhdf5/config/cmake_ext_mod/hdf.ico",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/HDF5/src/itkhdf5/config/cmake_ext_mod/hdf.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/HDF5/src/itkhdf5/config/cmake_ext_mod/hdf.icns",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/HDF5/src/itkhdf5/c++/src/header.html",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/HDF5/src/itkhdf5/c++/src/header_files/image002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/HDF5/src/itkhdf5/c++/src/header_files/help.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/HDF5/src/itkhdf5/c++/src/header_files/hdf_logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/HDF5/src/itkhdf5/c++/src/header_files/image001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-itk-5.1.1-rbk2yfbe7hvh5gd3atoeeiwlsfzukgiu/spack-src/Modules/ThirdParty/KWSys/src/KWSys/testSystemTools.bin"
    ],
    "total_files": 15831
}