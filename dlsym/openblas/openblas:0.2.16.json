{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openblas-0.2.16-diympm7blbkxtdj7getxxzypfgehhzx6/spack-src/utest/ctest.h": "/* Copyright 2011-2016 Bas van den Berg\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef CTEST_H\n#define CTEST_H\n\n#if defined _WIN32 || defined __CYGWIN__\n#ifndef WIN32\n#define WIN32\n#endif\n#endif\n\n#ifndef WIN32\n#define WEAK __attribute__ ((weak))\n#else\n#define WEAK\n#endif\n\n#include <inttypes.h> /* intmax_t, uintmax_t, PRI* */\n#include <stddef.h> /* size_t */\n\ntypedef void (*SetupFunc)(void*);\ntypedef void (*TearDownFunc)(void*);\ntypedef void (*RunWithDataFunc)(void*);\n\nstruct ctest {\n    const char* ssname;  // suite name\n    const char* ttname;  // test name\n    void (*run)();\n    int skip;\n\n    void* data;\n    SetupFunc setup;\n    TearDownFunc teardown;\n\n    struct ctest *next;\n\n    unsigned int magic;\n};\n\n#define __FNAME(sname, tname) __ctest_##sname##_##tname##_run\n#define __TNAME(sname, tname) __ctest_##sname##_##tname\n#define __PNAME(sname, tname) __ctest_##sname##_##tname##_pointer\n\n#ifdef __APPLE__\n#define __CTEST_APPLE\n#endif\n\n#ifdef __MINGW32__\n#undef CTEST_SEGFAULT\n#endif\n\n#if defined(_WIN32) && defined(_MSC_VER)\n#define __CTEST_MSVC\n#endif\n\n//config for MSVC compiler\n#ifdef __CTEST_MSVC\n\n#define __CTEST_NO_TIME\n#define CTEST_NO_COLORS\n\n#ifndef CTEST_ADD_TESTS_MANUALLY\n#pragma section(\".ctest$a\")\n#pragma section(\".ctest$u\")\n#pragma section(\".ctest$z\")\n#endif\n\n//clear this flag for msvc\n#ifdef CTEST_SEGFAULT\n#undef CTEST_SEGFAULT\n#endif\n\n#if _MSC_VER < 1900\n#define snprintf _snprintf_s\n#endif\n\n#ifndef __cplusplus\n#define inline __inline\n#endif\n#endif\n\n#ifdef CTEST_NO_JMP\n#define __CTEST_NO_JMP\n#endif\n\n#define __CTEST_MAGIC (0xdeadbeef)\n\n#ifdef CTEST_ADD_TESTS_MANUALLY\n# define __Test_Section\n#else\n#ifdef __CTEST_APPLE\n#define __Test_Section __attribute__ ((used, section (\"__DATA, .ctest\")))\n#elif defined (__CTEST_MSVC)\n#define __Test_Section __declspec( allocate(\".ctest$u\"))\n#else\n#define __Test_Section __attribute__ ((used, section (\".ctest\")))\n#endif\n#endif\n\n#ifndef __CTEST_MSVC\n#define __CTEST_STRUCT(sname, tname, _skip, __data, __setup, __teardown) \\\n    static struct ctest __TNAME(sname, tname)  = { \\\n        .ssname=#sname, \\\n        .ttname=#tname, \\\n        .run = __FNAME(sname, tname), \\\n        .skip = _skip, \\\n        .data = __data, \\\n        .setup = (SetupFunc)__setup,\t\t\t\t\t\\\n        .teardown = (TearDownFunc)__teardown,\t\t\t\t\\\n        .next =  NULL, \\\n        .magic = __CTEST_MAGIC}; \\\n    static void * __PNAME(sname, tname)[2] __Test_Section = {(void*)& __TNAME(sname,tname), (void*)__CTEST_MAGIC};\n#else\n//for msvc\n#define __CTEST_STRUCT(sname, tname, _skip, __data, __setup, __teardown) \\\n    static struct ctest __TNAME(sname, tname) = { \\\n         #sname, \\\n\t #tname, \\\n\t __FNAME(sname, tname), \\\n\t _skip, \\\n\t __data, \\\n\t (SetupFunc)__setup, \\\n         (TearDownFunc)__teardown, \\\n\t NULL, \\\n         __CTEST_MAGIC}; \\\n    __Test_Section static void * __PNAME(sname, tname)[2]= {(void*)& __TNAME(sname,tname), (void *)__CTEST_MAGIC}; \n#endif\n\n#define CTEST_DATA(sname) struct sname##_data\n\n#define CTEST_SETUP(sname) \\\n    void WEAK sname##_setup(struct sname##_data* data)\n\n#define CTEST_TEARDOWN(sname) \\\n    void WEAK sname##_teardown(struct sname##_data* data)\n\n#define __CTEST_INTERNAL(sname, tname, _skip) \\\n    void __FNAME(sname, tname)(); \\\n    __CTEST_STRUCT(sname, tname, _skip, NULL, NULL, NULL) \\\n    void __FNAME(sname, tname)()\n\n#ifdef __CTEST_APPLE\n#define SETUP_FNAME(sname) NULL\n#define TEARDOWN_FNAME(sname) NULL\n#else\n#define SETUP_FNAME(sname) sname##_setup\n#define TEARDOWN_FNAME(sname) sname##_teardown\n#endif\n\n#define __CTEST2_INTERNAL(sname, tname, _skip) \\\n    static struct sname##_data  __ctest_##sname##_data; \\\n    CTEST_SETUP(sname); \\\n    CTEST_TEARDOWN(sname); \\\n    void __FNAME(sname, tname)(struct sname##_data* data); \\\n    __CTEST_STRUCT(sname, tname, _skip, &__ctest_##sname##_data, SETUP_FNAME(sname), TEARDOWN_FNAME(sname)) \\\n    void __FNAME(sname, tname)(struct sname##_data* data)\n\n\nvoid CTEST_LOG(const char* fmt, ...);\nvoid CTEST_ERR(const char* fmt, ...);  // doesn't return\n\n#define CTEST(sname, tname) __CTEST_INTERNAL(sname, tname, 0)\n#define CTEST_SKIP(sname, tname) __CTEST_INTERNAL(sname, tname, 1)\n\n#define CTEST2(sname, tname) __CTEST2_INTERNAL(sname, tname, 0)\n#define CTEST2_SKIP(sname, tname) __CTEST2_INTERNAL(sname, tname, 1)\n\n\n#ifdef CTEST_ADD_TESTS_MANUALLY\n\nvoid __ctest_addTest(struct ctest *);\n\n#define CTEST_ADD(sname, tname) do { \\\n    extern struct ctest __TNAME(sname, tname); \\\n    __ctest_addTest(&__TNAME(sname, tname)); \\\n} while (0)\n\n#define CTEST_ADD2(sname, tname) do { \\\n    extern struct ctest __TNAME(sname, tname); \\\n    __ctest_addTest(&__TNAME(sname, tname)); \\\n} while (0)\n\n#endif // CTEST_ADD_TESTS_MANUALLY\n\nvoid assert_str(const char* exp, const char* real, const char* caller, int line);\n#define ASSERT_STR(exp, real) assert_str(exp, real, __FILE__, __LINE__)\n\nvoid assert_data(const unsigned char* exp, size_t expsize,\n                 const unsigned char* real, size_t realsize,\n                 const char* caller, int line);\n#define ASSERT_DATA(exp, expsize, real, realsize) \\\n    assert_data(exp, expsize, real, realsize, __FILE__, __LINE__)\n\nvoid assert_equal(intmax_t exp, intmax_t real, const char* caller, int line);\n#define ASSERT_EQUAL(exp, real) assert_equal(exp, real, __FILE__, __LINE__)\n\nvoid assert_equal_u(uintmax_t exp, uintmax_t real, const char* caller, int line);\n#define ASSERT_EQUAL_U(exp, real) assert_equal_u(exp, real, __FILE__, __LINE__)\n\nvoid assert_not_equal(intmax_t exp, intmax_t real, const char* caller, int line);\n#define ASSERT_NOT_EQUAL(exp, real) assert_not_equal(exp, real, __FILE__, __LINE__)\n\nvoid assert_not_equal_u(uintmax_t exp, uintmax_t real, const char* caller, int line);\n#define ASSERT_NOT_EQUAL_U(exp, real) assert_not_equal_u(exp, real, __FILE__, __LINE__)\n\nvoid assert_interval(intmax_t exp1, intmax_t exp2, intmax_t real, const char* caller, int line);\n#define ASSERT_INTERVAL(exp1, exp2, real) assert_interval(exp1, exp2, real, __FILE__, __LINE__)\n\nvoid assert_null(void* real, const char* caller, int line);\n#define ASSERT_NULL(real) assert_null((void*)real, __FILE__, __LINE__)\n\nvoid assert_not_null(const void* real, const char* caller, int line);\n#define ASSERT_NOT_NULL(real) assert_not_null(real, __FILE__, __LINE__)\n\nvoid assert_true(int real, const char* caller, int line);\n#define ASSERT_TRUE(real) assert_true(real, __FILE__, __LINE__)\n\nvoid assert_false(int real, const char* caller, int line);\n#define ASSERT_FALSE(real) assert_false(real, __FILE__, __LINE__)\n\nvoid assert_fail(const char* caller, int line);\n#define ASSERT_FAIL() assert_fail(__FILE__, __LINE__)\n\n/* If longjmp() is not available, integer flag will be used instead of jmp_buf.\n *\n * __CTEST_SETJMP() will clear the flag and return zero, and __CTEST_LONGJMP()\n * will set the flag to its argument. __CTEST_ERROR_CODE() will return that flag.\n *\n * If longjmp() is available, jmp_buf will be used as usual and __CTEST_ERROR_CODE()\n * will always return zero.\n *\n * You can check both __CTEST_SETJMP() and __CTEST_ERROR_CODE() return value\n * to detect error in a portable way.\n */\n#ifdef __CTEST_NO_JMP\n# define __CTEST_JMPBUF                 int\n# define __CTEST_ERROR_CODE(_var)       (_var)\n# define __CTEST_SETJMP(_var)           (_var = 0)\n# define __CTEST_LONGJMP(_var, _err)    (_var = _err)\n#else // !__CTEST_NO_JMP\n# define __CTEST_JMPBUF                 jmp_buf\n# define __CTEST_ERROR_CODE(_var)       (0)\n# define __CTEST_SETJMP(_var)           setjmp(_var)\n# define __CTEST_LONGJMP(_var, _err)    longjmp(_var, _err)\n#endif // __CTEST_NO_JMP\n\nvoid assert_dbl_near(double exp, double real, double tol, const char* caller, int line);\n#define ASSERT_DBL_NEAR(exp, real) assert_dbl_near(exp, real, 1e-4, __FILE__, __LINE__)\n#define ASSERT_DBL_NEAR_TOL(exp, real, tol) assert_dbl_near(exp, real, tol, __FILE__, __LINE__)\n\nvoid assert_dbl_far(double exp, double real, double tol, const char* caller, int line);\n#define ASSERT_DBL_FAR(exp, real) assert_dbl_far(exp, real, 1e-4, __FILE__, __LINE__)\n#define ASSERT_DBL_FAR_TOL(exp, real, tol) assert_dbl_far(exp, real, tol, __FILE__, __LINE__)\n\n#ifdef CTEST_MAIN\n\n#ifndef __CTEST_NO_JMP\n#include <setjmp.h>\n#endif\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n\n#ifndef __CTEST_NO_TIME\n#include <sys/time.h>\n#endif\n#include <stdint.h>\n\n#ifdef __CTEST_MSVC\n#include <io.h>\n#else\n#include <unistd.h>\n#endif\n\n#include <stdlib.h>\n\n#ifdef __CTEST_APPLE\n#include <dlfcn.h>\n#endif\n\nstatic size_t ctest_errorsize;\nstatic char* ctest_errormsg;\n#define MSG_SIZE 4096\nstatic char ctest_errorbuffer[MSG_SIZE];\nstatic __CTEST_JMPBUF ctest_err;\nstatic int color_output = 1;\nstatic const char* suite_name;\nstatic const char* test_name;\n\ntypedef int (*filter_func)(struct ctest*);\n\n#define ANSI_BLACK    \"\\033[0;30m\"\n#define ANSI_RED      \"\\033[0;31m\"\n#define ANSI_GREEN    \"\\033[0;32m\"\n#define ANSI_YELLOW   \"\\033[0;33m\"\n#define ANSI_BLUE     \"\\033[0;34m\"\n#define ANSI_MAGENTA  \"\\033[0;35m\"\n#define ANSI_CYAN     \"\\033[0;36m\"\n#define ANSI_GREY     \"\\033[0;37m\"\n#define ANSI_DARKGREY \"\\033[01;30m\"\n#define ANSI_BRED     \"\\033[01;31m\"\n#define ANSI_BGREEN   \"\\033[01;32m\"\n#define ANSI_BYELLOW  \"\\033[01;33m\"\n#define ANSI_BBLUE    \"\\033[01;34m\"\n#define ANSI_BMAGENTA \"\\033[01;35m\"\n#define ANSI_BCYAN    \"\\033[01;36m\"\n#define ANSI_WHITE    \"\\033[01;37m\"\n#define ANSI_NORMAL   \"\\033[0m\"\n\n#ifdef __CTEST_MSVC\n#ifndef CTEST_ADD_TESTS_MANUALLY\n__declspec(allocate(\".ctest$a\")) struct ctest * ctest_win_begin;\n__declspec(allocate(\".ctest$z\")) struct ctest * ctest_win_end;\n#endif\n#endif\n\nstatic CTEST(suite, test) { }\n\n#define __CTEST_POINTER_NEXT(_test) (struct ctest **)((struct ctest **)(_test) + 2)\n#define __CTEST_POINTER_PREV(_test) (struct ctest **)((struct ctest **)(_test) - 2)\n\n/* First element of test list.\n */\nstatic struct ctest * * __ctest_head_p = (struct ctest **)__PNAME(suite, test);\n\n#ifdef CTEST_ADD_TESTS_MANUALLY\n\n/* Last element of test list.\n */\nstatic struct ctest *__ctest_tail = &__TNAME(suite, test);\n\n/* Add test to linked list manually.\n */\nvoid __ctest_addTest(struct ctest *test)\n{\n    __ctest_tail->next = test;\n    __ctest_tail = test;\n}\n#else // !CTEST_ADD_TESTS_MANUALLY\n\n#ifndef __CTEST_MSVC\n/* Add all tests to linked list automatically.\n */\nstatic void __ctest_linkTests()\n{\n    struct ctest ** test;\n    struct ctest ** ctest_begin = (struct ctest **)__PNAME(suite, test);\n    struct ctest ** ctest_end = (struct ctest **)__PNAME(suite, test);\n\n    // find begin and end of section by comparing magics\n    while (1) {\n        struct ctest** t = __CTEST_POINTER_PREV(ctest_begin);\n\tif (t[0] == NULL) break;\n        if (t[1] != (struct ctest*)__CTEST_MAGIC) break;\n        ctest_begin = t;\n    }\n    while (1) {\n        struct ctest** t = __CTEST_POINTER_NEXT(ctest_end);\n       \tif (t[0] == NULL) break;\n        if (t[1] != (struct ctest*)__CTEST_MAGIC) break;\n        ctest_end = t;\n    }\n    ctest_end = __CTEST_POINTER_NEXT(ctest_end); // end after last one\n\n    for (test = ctest_begin; test != ctest_end; test = __CTEST_POINTER_NEXT(test)) {\n        struct ctest ** next_p = __CTEST_POINTER_NEXT(test);\n\tstruct ctest * next;\n        if (next_p == ctest_end)\n            next = NULL;\n\telse\n\t    next = next_p[0];\n\n        (*test)->next = next;\n    }\n\n    __ctest_head_p = ctest_begin;\n}\n#else //for msvc\nstatic void __ctest_linkTests()\n{\n    struct ctest ** ctest_start = __ctest_head_p;\n    struct ctest ** test;\n    struct ctest * cur=ctest_start[0];\n\n    for(test=&ctest_win_begin; test!=&ctest_win_end; test++){\n      //check\n      if(test[1] == (struct ctest*)__CTEST_MAGIC){\n\t//skip the start\n\tif((test[0]) == ctest_start[0]) continue;\n\t\n\tcur->next = test[0];\n\tcur=cur->next;\n\tcur->next=NULL;\n      }\n    }\n}\n#endif\n#endif\n\ninline static void vprint_errormsg(const char* const fmt, va_list ap) {\n\t// (v)snprintf returns the number that would have been written\n    const int ret = vsnprintf(ctest_errormsg, ctest_errorsize, fmt, ap);\n    if (ret < 0) {\n\t\tctest_errormsg[0] = 0x00;\n    } else {\n    \tconst size_t size = (size_t) ret;\n    \tconst size_t s = (ctest_errorsize <= size ? size -ctest_errorsize : size);\n    \t// ctest_errorsize may overflow at this point\n\t\tctest_errorsize -= s;\n\t\tctest_errormsg += s;\n    }\n}\n\ninline static void print_errormsg(const char* const fmt, ...) {\n    va_list argp;\n    va_start(argp, fmt);\n    vprint_errormsg(fmt, argp);\n    va_end(argp);\n}\n\nstatic void msg_start(const char* color, const char* title) {\n    if (color_output) {\n    \tprint_errormsg(\"%s\", color);\n    }\n    print_errormsg(\"  %s: \", title);\n}\n\nstatic void msg_end() {\n    if (color_output) {\n    \tprint_errormsg(ANSI_NORMAL);\n    }\n    print_errormsg(\"\\n\");\n}\n\nvoid CTEST_LOG(const char* fmt, ...)\n{\n    va_list argp;\n    msg_start(ANSI_BLUE, \"LOG\");\n\n    va_start(argp, fmt);\n    vprint_errormsg(fmt, argp);\n    va_end(argp);\n\n    msg_end();\n}\n\nvoid CTEST_ERR(const char* fmt, ...)\n{\n    va_list argp;\n    msg_start(ANSI_YELLOW, \"ERR\");\n\n    va_start(argp, fmt);\n    vprint_errormsg(fmt, argp);\n    va_end(argp);\n\n    msg_end();\n    __CTEST_LONGJMP(ctest_err, 1);\n}\n\nvoid assert_str(const char* exp, const char*  real, const char* caller, int line) {\n    if ((exp == NULL && real != NULL) ||\n        (exp != NULL && real == NULL) ||\n        (exp && real && strcmp(exp, real) != 0)) {\n        CTEST_ERR(\"%s:%d  expected '%s', got '%s'\", caller, line, exp, real);\n    }\n}\n\nvoid assert_data(const unsigned char* exp, size_t expsize,\n                 const unsigned char* real, size_t realsize,\n                 const char* caller, int line) {\n    size_t i;\n    if (expsize != realsize) {\n        CTEST_ERR(\"%s:%d  expected %\" PRIuMAX \" bytes, got %\" PRIuMAX, caller, line, (uintmax_t) expsize, (uintmax_t) realsize);\n    }\n    for (i=0; i<expsize; i++) {\n        if (exp[i] != real[i]) {\n            CTEST_ERR(\"%s:%d expected 0x%02x at offset %\" PRIuMAX \" got 0x%02x\",\n                caller, line, exp[i], (uintmax_t) i, real[i]);\n        }\n    }\n}\n\nvoid assert_equal(intmax_t exp, intmax_t real, const char* caller, int line) {\n    if (exp != real) {\n        CTEST_ERR(\"%s:%d  expected %\" PRIdMAX \", got %\" PRIdMAX, caller, line, exp, real);\n    }\n}\n\nvoid assert_equal_u(uintmax_t exp, uintmax_t real, const char* caller, int line) {\n    if (exp != real) {\n        CTEST_ERR(\"%s:%d  expected %\" PRIuMAX \", got %\" PRIuMAX, caller, line, exp, real);\n    }\n}\n\nvoid assert_not_equal(intmax_t exp, intmax_t real, const char* caller, int line) {\n    if ((exp) == (real)) {\n        CTEST_ERR(\"%s:%d  should not be %\" PRIdMAX, caller, line, real);\n    }\n}\n\nvoid assert_not_equal_u(uintmax_t exp, uintmax_t real, const char* caller, int line) {\n    if ((exp) == (real)) {\n        CTEST_ERR(\"%s:%d  should not be %\" PRIuMAX, caller, line, real);\n    }\n}\n\nvoid assert_interval(intmax_t exp1, intmax_t exp2, intmax_t real, const char* caller, int line) {\n    if (real < exp1 || real > exp2) {\n        CTEST_ERR(\"%s:%d  expected %\" PRIdMAX \"-%\" PRIdMAX \", got %\" PRIdMAX, caller, line, exp1, exp2, real);\n    }\n}\n\nvoid assert_dbl_near(double exp, double real, double tol, const char* caller, int line) {\n    double diff = exp - real;\n    double absdiff = diff;\n    /* avoid using fabs and linking with a math lib */\n    if(diff < 0) {\n      absdiff *= -1;\n    }\n    if (absdiff > tol) {\n        CTEST_ERR(\"%s:%d  expected %0.3e, got %0.3e (diff %0.3e, tol %0.3e)\", caller, line, exp, real, diff, tol);\n    }\n}\n\nvoid assert_dbl_far(double exp, double real, double tol, const char* caller, int line) {\n    double diff = exp - real;\n    double absdiff = diff;\n    /* avoid using fabs and linking with a math lib */\n    if(diff < 0) {\n      absdiff *= -1;\n    }\n    if (absdiff <= tol) {\n        CTEST_ERR(\"%s:%d  expected %0.3e, got %0.3e (diff %0.3e, tol %0.3e)\", caller, line, exp, real, diff, tol);\n    }\n}\n\nvoid assert_null(void* real, const char* caller, int line) {\n    if ((real) != NULL) {\n        CTEST_ERR(\"%s:%d  should be NULL\", caller, line);\n    }\n}\n\nvoid assert_not_null(const void* real, const char* caller, int line) {\n    if (real == NULL) {\n        CTEST_ERR(\"%s:%d  should not be NULL\", caller, line);\n    }\n}\n\nvoid assert_true(int real, const char* caller, int line) {\n    if ((real) == 0) {\n        CTEST_ERR(\"%s:%d  should be true\", caller, line);\n    }\n}\n\nvoid assert_false(int real, const char* caller, int line) {\n    if ((real) != 0) {\n        CTEST_ERR(\"%s:%d  should be false\", caller, line);\n    }\n}\n\nvoid assert_fail(const char* caller, int line) {\n    CTEST_ERR(\"%s:%d  shouldn't come here\", caller, line);\n}\n\n\nstatic int suite_all(struct ctest* t) {\n    (void) t; // fix unused parameter warning\n    return 1;\n}\n\nstatic int suite_filter(struct ctest* t) {\n    return strncmp(suite_name, t->ssname, strlen(suite_name)) == 0;\n}\n\nstatic int suite_test_filter(struct ctest* t) {\n  int suit_match, test_match;\n  suit_match=(strncmp(suite_name, t->ssname, strlen(suite_name)) == 0);\n  test_match=(strncmp(test_name, t->ttname, strlen(test_name)) == 0);\n  return (suit_match & test_match);\n}\n\n\n#ifndef __CTEST_NO_TIME\nstatic uint64_t getCurrentTime() {\n    struct timeval now;\n    gettimeofday(&now, NULL);\n    uint64_t now64 = (uint64_t) now.tv_sec;\n    now64 *= 1000000;\n    now64 += ((uint64_t) now.tv_usec);\n    return now64;\n}\n#endif\n\nstatic void color_print(const char* color, const char* text) {\n    if (color_output)\n        printf(\"%s%s\"ANSI_NORMAL\"\\n\", color, text);\n    else\n        printf(\"%s\\n\", text);\n}\n\n#ifdef __CTEST_APPLE\nstatic void *find_symbol(struct ctest *test, const char *fname)\n{\n    size_t len = strlen(test->ssname) + 1 + strlen(fname);\n    char *symbol_name = (char *) malloc(len + 1);\n    memset(symbol_name, 0, len + 1);\n    snprintf(symbol_name, len + 1, \"%s_%s\", test->ssname, fname);\n\n    //fprintf(stderr, \">>>> dlsym: loading %s\\n\", symbol_name);\n    void *symbol = dlsym(RTLD_DEFAULT, symbol_name);\n    if (!symbol) {\n        //fprintf(stderr, \">>>> ERROR: %s\\n\", dlerror());\n    }\n    // returns NULL on error\n\n    free(symbol_name);\n    return symbol;\n}\n#endif\n\n#ifdef CTEST_SEGFAULT\n#include <signal.h>\nstatic void sighandler(int signum)\n{\n    char msg[128];\n    sprintf(msg, \"[SIGNAL %d: %s]\", signum, sys_siglist[signum]);\n    color_print(ANSI_BRED, msg);\n    fflush(stdout);\n\n    /* \"Unregister\" the signal handler and send the signal back to the process\n     * so it can terminate as expected */\n    signal(signum, SIG_DFL);\n    kill(getpid(), signum);\n}\n#endif\n\nint ctest_main(int argc, const char *argv[])\n{\n    static int total = 0;\n    static int num_ok = 0;\n    static int num_fail = 0;\n    static int num_skip = 0;\n    static int index = 1;\n    static filter_func filter = suite_all;\n\n    const char* color = (num_fail) ? ANSI_BRED : ANSI_GREEN;\n    char results[80];\n    static struct ctest* test;\n\n#ifdef CTEST_SEGFAULT\n    signal(SIGSEGV, sighandler);\n#endif\n\n    if (argc == 2) {\n        suite_name = argv[1];\n        filter = suite_filter;\n    }else if (argc == 3) {\n        suite_name = argv[1];\n\ttest_name = argv[2];\n        filter = suite_test_filter;\n    }\n\n#ifdef CTEST_NO_COLORS\n    color_output = 0;\n#else\n    color_output = isatty(1);\n#endif\n\n#ifndef __CTEST_NO_TIME\n    uint64_t t1 = getCurrentTime();\n#endif\n\n#ifndef CTEST_ADD_TESTS_MANUALLY\n    __ctest_linkTests();\n#endif\n\n\n    for (test = *(__ctest_head_p); test != NULL; test=test->next) {\n        if (test == &__ctest_suite_test) continue;\n        if (filter(test)) total++;\n    }\n\n    for (test = *(__ctest_head_p); test != NULL; test=test->next) {\n        if (test == &__ctest_suite_test) continue;\n        if (filter(test)) {\n            ctest_errorbuffer[0] = 0;\n            ctest_errorsize = MSG_SIZE-1;\n            ctest_errormsg = ctest_errorbuffer;\n            printf(\"TEST %d/%d %s:%s \", index, total, test->ssname, test->ttname);\n            fflush(stdout);\n            if (test->skip) {\n                color_print(ANSI_BYELLOW, \"[SKIPPED]\");\n                num_skip++;\n            } else {\n                int result = __CTEST_SETJMP(ctest_err);\n                if (result == 0) {\n#ifdef __CTEST_APPLE\n                    if (!test->setup) {\n                        test->setup = (SetupFunc) find_symbol(test, \"setup\");\n                    }\n                    if (!test->teardown) {\n                        test->teardown = (TearDownFunc) find_symbol(test, \"teardown\");\n                    }\n#endif\n\n                    if (test->setup) test->setup(test->data);\n                    if (test->data)\n                      ((RunWithDataFunc)test->run)(test->data);\n                    else\n                        test->run();\n                    if (test->teardown) test->teardown(test->data);\n                    // if we got here it's ok\n#ifdef CTEST_COLOR_OK\n                    color_print(ANSI_BGREEN, \"[OK]\");\n#else\n                    printf(\"[OK]\\n\");\n#endif\n                    num_ok++;\n                } else {\n                    color_print(ANSI_BRED, \"[FAIL]\");\n                    num_fail++;\n                }\n                if (ctest_errorsize != MSG_SIZE-1) printf(\"%s\", ctest_errorbuffer);\n            }\n            index++;\n        }\n    }\n#ifndef __CTEST_NO_TIME\n    uint64_t t2 = getCurrentTime();\n#endif\n\n#ifndef __CTEST_NO_TIME\n    sprintf(results, \"RESULTS: %d tests (%d ok, %d failed, %d skipped) ran in %\"PRIu64\" ms\", total, num_ok, num_fail, num_skip, (t2 - t1)/1000);\n#else\n    sprintf(results, \"RESULTS: %d tests (%d ok, %d failed, %d skipped)\", total, num_ok, num_fail, num_skip);\n#endif\n    color_print(color, results);\n    return num_fail;\n}\n\n#endif\n\n#endif\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openblas-0.2.16-diympm7blbkxtdj7getxxzypfgehhzx6/spack-src/lapack-netlib/DOCS/lapack.png",
        "/tmp/vanessa/spack-stage/spack-stage-openblas-0.2.16-diympm7blbkxtdj7getxxzypfgehhzx6/spack-src/lapack-netlib/DOCS/lapacke.pdf"
    ],
    "total_files": 7957
}