{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-nccl-1.3.4-1-s7nthcgreiaf27muyv5sq4p3led22ubv/spack-src/src/libwrap.cu": "/*************************************************************************\n * Copyright (c) 2015-2016, NVIDIA CORPORATION. All rights reserved.\n *\n * See LICENSE.txt for license information\n ************************************************************************/\n\n#include \"libwrap.h\"\n#include <dlfcn.h>\n#include \"core.h\"\n\nint symbolsLoaded = 0;\n\nstatic nvmlReturn_t (*nvmlInternalInit)(void);\nstatic nvmlReturn_t (*nvmlInternalShutdown)(void);\nstatic nvmlReturn_t (*nvmlInternalDeviceGetHandleByPciBusId)(const char* pciBusId, nvmlDevice_t* device);\nstatic nvmlReturn_t (*nvmlInternalDeviceGetIndex)(nvmlDevice_t device, unsigned* index);\nstatic nvmlReturn_t (*nvmlInternalDeviceSetCpuAffinity)(nvmlDevice_t device);\nstatic nvmlReturn_t (*nvmlInternalDeviceClearCpuAffinity)(nvmlDevice_t device);\nstatic const char* (*nvmlInternalErrorString)(nvmlReturn_t r);\n\nncclResult_t wrapSymbols(void) {\n\n  if (symbolsLoaded)\n    return ncclSuccess;\n\n  static void* nvmlhandle = NULL;\n  void* tmp;\n  void** cast;\n\n  nvmlhandle=dlopen(\"libnvidia-ml.so\", RTLD_NOW);\n  if (!nvmlhandle) {\n    nvmlhandle=dlopen(\"libnvidia-ml.so.1\", RTLD_NOW);\n    if (!nvmlhandle) {\n      WARN(\"Failed to open libnvidia-ml.so[.1]\");\n      goto teardown;\n    }\n  }\n\n  #define LOAD_SYM(handle, symbol, funcptr) do {         \\\n    cast = (void**)&funcptr;                             \\\n    tmp = dlsym(handle, symbol);                         \\\n    if (tmp == NULL) {                                   \\\n      WARN(\"dlsym failed on %s - %s\", symbol, dlerror());\\\n      goto teardown;                                     \\\n    }                                                    \\\n    *cast = tmp;                                         \\\n  } while (0)\n\n  LOAD_SYM(nvmlhandle, \"nvmlInit\", nvmlInternalInit);\n  LOAD_SYM(nvmlhandle, \"nvmlShutdown\", nvmlInternalShutdown);\n  LOAD_SYM(nvmlhandle, \"nvmlDeviceGetHandleByPciBusId\", nvmlInternalDeviceGetHandleByPciBusId);\n  LOAD_SYM(nvmlhandle, \"nvmlDeviceGetIndex\", nvmlInternalDeviceGetIndex);\n  LOAD_SYM(nvmlhandle, \"nvmlDeviceSetCpuAffinity\", nvmlInternalDeviceSetCpuAffinity);\n  LOAD_SYM(nvmlhandle, \"nvmlDeviceClearCpuAffinity\", nvmlInternalDeviceClearCpuAffinity);\n  LOAD_SYM(nvmlhandle, \"nvmlErrorString\", nvmlInternalErrorString);\n\n  symbolsLoaded = 1;\n  return ncclSuccess;\n\n  teardown:\n  nvmlInternalInit = NULL;\n  nvmlInternalShutdown = NULL;\n  nvmlInternalDeviceGetHandleByPciBusId = NULL;\n  nvmlInternalDeviceGetIndex = NULL;\n  nvmlInternalDeviceSetCpuAffinity = NULL;\n  nvmlInternalDeviceClearCpuAffinity = NULL;\n\n  if (nvmlhandle != NULL) dlclose(nvmlhandle);\n  return ncclSystemError;\n}\n\n\nncclResult_t wrapNvmlInit(void) {\n  if (nvmlInternalInit == NULL) {\n    WARN(\"lib wrapper not initialized.\");\n    return ncclLibWrapperNotSet;\n  }\n  nvmlReturn_t ret = nvmlInternalInit();\n  if (ret != NVML_SUCCESS) {\n    WARN(\"nvmlInit() failed: %s\",\n      nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n\nncclResult_t wrapNvmlShutdown(void) {\n  if (nvmlInternalShutdown == NULL) {\n    WARN(\"lib wrapper not initialized.\");\n    return ncclLibWrapperNotSet;\n  }\n  nvmlReturn_t ret = nvmlInternalShutdown();\n  if (ret != NVML_SUCCESS) {\n    WARN(\"nvmlShutdown() failed: %s \",\n      nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n\nncclResult_t wrapNvmlDeviceGetHandleByPciBusId(const char* pciBusId, nvmlDevice_t* device) {\n  if (nvmlInternalDeviceGetHandleByPciBusId == NULL) {\n    WARN(\"lib wrapper not initialized.\");\n    return ncclLibWrapperNotSet;\n  }\n  nvmlReturn_t ret = nvmlInternalDeviceGetHandleByPciBusId(pciBusId, device);\n  if (ret != NVML_SUCCESS) {\n    WARN(\"nvmlDeviceGetHandleByPciBusId() failed: %s \",\n      nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n\nncclResult_t wrapNvmlDeviceGetIndex(nvmlDevice_t device, unsigned* index) {\n  if (nvmlInternalDeviceGetIndex == NULL) {\n    WARN(\"lib wrapper not initialized.\");\n    return ncclLibWrapperNotSet;\n  }\n  nvmlReturn_t ret = nvmlInternalDeviceGetIndex(device, index);\n  if (ret != NVML_SUCCESS) {\n    WARN(\"nvmlDeviceGetIndex() failed: %s \",\n      nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n\nncclResult_t wrapNvmlDeviceSetCpuAffinity(nvmlDevice_t device) {\n  if (nvmlInternalDeviceSetCpuAffinity == NULL) {\n    WARN(\"lib wrapper not initialized.\");\n    return ncclLibWrapperNotSet;\n  }\n  nvmlReturn_t ret = nvmlInternalDeviceSetCpuAffinity(device);\n  if (ret != NVML_SUCCESS) {\n    WARN(\"nvmlDeviceSetCpuAffinity() failed: %s \",\n      nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n\nncclResult_t wrapNvmlDeviceClearCpuAffinity(nvmlDevice_t device) {\n  if (nvmlInternalInit == NULL) {\n    WARN(\"lib wrapper not initialized.\");\n    return ncclLibWrapperNotSet;\n  }\n  nvmlReturn_t ret = nvmlInternalDeviceClearCpuAffinity(device);\n  if (ret != NVML_SUCCESS) {\n    WARN(\"nvmlDeviceClearCpuAffinity() failed: %s \",\n      nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n"
    },
    "skipped": [],
    "total_files": 51
}