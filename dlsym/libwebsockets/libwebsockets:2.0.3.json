{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.0.3-zwvd2lwbxecx6zyzxz5n37hdkwpxnf5h/spack-src/lib/libuv.c": "/*\n * libwebsockets - small server side websockets and web server implementation\n *\n * Copyright (C) 2010-2016 Andy Green <andy@warmcat.com>\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation:\n *  version 2.1 of the License.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n *  MA  02110-1301  USA\n */\n\n#include \"private-libwebsockets.h\"\n\nvoid\nlws_feature_status_libuv(struct lws_context_creation_info *info)\n{\n\tif (lws_check_opt(info->options, LWS_SERVER_OPTION_LIBUV))\n\t\tlwsl_notice(\"libuv support compiled in and enabled\\n\");\n\telse\n\t\tlwsl_notice(\"libuv support compiled in but disabled\\n\");\n}\n\nstatic void\nlws_uv_idle(uv_idle_t *handle\n#if UV_VERSION_MAJOR == 0\n\t\t, int status\n#endif\n)\n{\n\tstruct lws_context_per_thread *pt = lws_container_of(handle,\n\t\t\t\t\tstruct lws_context_per_thread, uv_idle);\n\n\tlwsl_debug(\"%s\\n\", __func__);\n\n\t/*\n\t * is there anybody with pending stuff that needs service forcing?\n\t */\n\tif (!lws_service_adjust_timeout(pt->context, 1, pt->tid)) {\n\t\t/* -1 timeout means just do forced service */\n\t\tlws_plat_service_tsi(pt->context, -1, pt->tid);\n\t\t/* still somebody left who wants forced service? */\n\t\tif (!lws_service_adjust_timeout(pt->context, 1, pt->tid))\n\t\t\t/* yes... come back again later */\n\t\t\tlwsl_debug(\"%s: done again\\n\", __func__);\n\t\t\treturn;\n\t}\n\n\t/* there is nobody who needs service forcing, shut down idle */\n\tuv_idle_stop(handle);\n\n\tlwsl_debug(\"%s: done stop\\n\", __func__);\n}\n\nstatic void\nlws_io_cb(uv_poll_t *watcher, int status, int revents)\n{\n\tstruct lws_io_watcher *lws_io = lws_container_of(watcher,\n\t\t\t\t\tstruct lws_io_watcher, uv_watcher);\n\tstruct lws *wsi = lws_container_of(lws_io, struct lws, w_read);\n\tstruct lws_context *context = lws_io->context;\n\tstruct lws_pollfd eventfd;\n\n#if defined(WIN32) || defined(_WIN32)\n\teventfd.fd = watcher->socket;\n#else\n\teventfd.fd = watcher->io_watcher.fd;\n#endif\n\teventfd.events = 0;\n\teventfd.revents = 0;\n\n\tif (status < 0) {\n\t\t/* at this point status will be an UV error, like UV_EBADF,\n\t\twe treat all errors as LWS_POLLHUP */\n\n\t\t/* you might want to return; instead of servicing the fd in some cases */\n\t\tif (status == UV_EAGAIN)\n\t\t\treturn;\n\n\t\teventfd.events |= LWS_POLLHUP;\n\t\teventfd.revents |= LWS_POLLHUP;\n\t} else {\n\t\tif (revents & UV_READABLE) {\n\t\t\teventfd.events |= LWS_POLLIN;\n\t\t\teventfd.revents |= LWS_POLLIN;\n\t\t}\n\t\tif (revents & UV_WRITABLE) {\n\t\t\teventfd.events |= LWS_POLLOUT;\n\t\t\teventfd.revents |= LWS_POLLOUT;\n\t\t}\n\t}\n\tlws_service_fd(context, &eventfd);\n\n\tuv_idle_start(&context->pt[(int)wsi->tsi].uv_idle, lws_uv_idle);\n}\n\nLWS_VISIBLE void\nlws_uv_sigint_cb(uv_signal_t *watcher, int signum)\n{\n\tlwsl_err(\"internal signal handler caught signal %d\\n\", signum);\n\tlws_libuv_stop(watcher->data);\n}\n\nLWS_VISIBLE int\nlws_uv_sigint_cfg(struct lws_context *context, int use_uv_sigint,\n\t\t  uv_signal_cb cb)\n{\n\tcontext->use_ev_sigint = use_uv_sigint;\n\tif (cb)\n\t\tcontext->lws_uv_sigint_cb = cb;\n\telse\n\t\tcontext->lws_uv_sigint_cb = &lws_uv_sigint_cb;\n\n\treturn 0;\n}\n\nstatic void\nlws_uv_timeout_cb(uv_timer_t *timer\n#if UV_VERSION_MAJOR == 0\n\t\t, int status\n#endif\n)\n{\n\tstruct lws_context_per_thread *pt = lws_container_of(timer,\n\t\t\tstruct lws_context_per_thread, uv_timeout_watcher);\n\n\tif (pt->context->requested_kill)\n\t\treturn;\n\n\tlwsl_debug(\"%s\\n\", __func__);\n\n\tlws_service_fd_tsi(pt->context, NULL, pt->tid);\n}\n\nstatic const int sigs[] = { SIGINT, SIGTERM, SIGSEGV, SIGFPE };\n\nLWS_VISIBLE int\nlws_uv_initloop(struct lws_context *context, uv_loop_t *loop, int tsi)\n{\n\tstruct lws_context_per_thread *pt = &context->pt[tsi];\n\tstruct lws_vhost *vh = context->vhost_list;\n\tint status = 0, n;\n\n\tif (!loop) {\n\t\tloop = lws_malloc(sizeof(*loop));\n\t\tif (!loop) {\n\t\t\tlwsl_err(\"OOM\\n\");\n\t\t\treturn -1;\n\t\t}\n#if UV_VERSION_MAJOR > 0\n\t\tuv_loop_init(loop);\n#else\n\t\tlwsl_err(\"This libuv is too old to work...\\n\");\n\t\treturn 1;\n#endif\n\t\tpt->ev_loop_foreign = 0;\n\t} else {\n\t\tlwsl_notice(\" Using foreign event loop...\\n\");\n\t\tpt->ev_loop_foreign = 1;\n\t}\n\n\tpt->io_loop_uv = loop;\n\tuv_idle_init(loop, &pt->uv_idle);\n\n\tif (pt->context->use_ev_sigint) {\n\t\tassert(ARRAY_SIZE(sigs) <= ARRAY_SIZE(pt->signals));\n\t\tfor (n = 0; n < ARRAY_SIZE(sigs); n++) {\n\t\t\tuv_signal_init(loop, &pt->signals[n]);\n\t\t\tpt->signals[n].data = pt->context;\n\t\t\tuv_signal_start(&pt->signals[n],\n\t\t\t\t\tcontext->lws_uv_sigint_cb, sigs[n]);\n\t\t}\n\t}\n\n\t/*\n\t * Initialize the accept wsi read watcher with all the listening sockets\n\t * and register a callback for read operations\n\t *\n\t * We have to do it here because the uv loop(s) are not\n\t * initialized until after context creation.\n\t */\n\twhile (vh) {\n\t\tif (vh->lserv_wsi) {\n\t\t\tvh->lserv_wsi->w_read.context = context;\n\t\t\tn = uv_poll_init_socket(pt->io_loop_uv,\n\t\t\t\t\t\t&vh->lserv_wsi->w_read.uv_watcher,\n\t\t\t\t\t\tvh->lserv_wsi->sock);\n\t\t\tif (n) {\n\t\t\t\tlwsl_err(\"uv_poll_init failed %d, sockfd=%p\\n\",\n\t\t\t\t\tn, (void *)(long)vh->lserv_wsi->sock);\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tlws_libuv_io(vh->lserv_wsi, LWS_EV_START | LWS_EV_READ);\n\t\t}\n\t\tvh = vh->vhost_next;\n\t}\n\n\tuv_timer_init(pt->io_loop_uv, &pt->uv_timeout_watcher);\n\tuv_timer_start(&pt->uv_timeout_watcher, lws_uv_timeout_cb, 10, 1000);\n\n\treturn status;\n}\n\nstatic void lws_uv_close_cb(uv_handle_t *handle)\n{\n\t//lwsl_err(\"%s: handle %p\\n\", __func__, handle);\n}\n\nstatic void lws_uv_walk_cb(uv_handle_t *handle, void *arg)\n{\n\tuv_close(handle, lws_uv_close_cb);\n}\n\nvoid\nlws_libuv_destroyloop(struct lws_context *context, int tsi)\n{\n\tstruct lws_context_per_thread *pt = &context->pt[tsi];\n\tint m, budget = 100;\n\n\tif (!lws_check_opt(context->options, LWS_SERVER_OPTION_LIBUV))\n\t\treturn;\n\n\tif (!pt->io_loop_uv)\n\t\treturn;\n\n\tif (context->use_ev_sigint) {\n\t\tuv_signal_stop(&pt->w_sigint.uv_watcher);\n\n\t\tfor (m = 0; m < ARRAY_SIZE(sigs); m++) {\n\t\t\tuv_signal_stop(&pt->signals[m]);\n\t\t\tuv_close((uv_handle_t *)&pt->signals[m], lws_uv_close_cb);\n\t\t}\n\t}\n\n\tuv_timer_stop(&pt->uv_timeout_watcher);\n\tuv_close((uv_handle_t *)&pt->uv_timeout_watcher, lws_uv_close_cb);\n\n\tuv_idle_stop(&pt->uv_idle);\n\tuv_close((uv_handle_t *)&pt->uv_idle, lws_uv_close_cb);\n\n\twhile (budget-- && uv_run(pt->io_loop_uv, UV_RUN_NOWAIT))\n\t\t;\n\n\tif (pt->ev_loop_foreign)\n\t\treturn;\n\n\tuv_stop(pt->io_loop_uv);\n\n\tuv_walk(pt->io_loop_uv, lws_uv_walk_cb, NULL);\n\n\twhile (uv_run(pt->io_loop_uv, UV_RUN_NOWAIT))\n\t\t;\n#if UV_VERSION_MAJOR > 0\n\tm = uv_loop_close(pt->io_loop_uv);\n\tif (m == UV_EBUSY)\n\t\tlwsl_err(\"%s: uv_loop_close: UV_EBUSY\\n\", __func__);\n#endif\n\tlws_free(pt->io_loop_uv);\n}\n\nvoid\nlws_libuv_accept(struct lws *wsi, int accept_fd)\n{\n\tstruct lws_context *context = lws_get_context(wsi);\n\tstruct lws_context_per_thread *pt = &context->pt[(int)wsi->tsi];\n\n\tif (!LWS_LIBUV_ENABLED(context))\n\t\treturn;\n\n\tlwsl_debug(\"%s: new wsi %p\\n\", __func__, wsi);\n\n\twsi->w_read.context = context;\n\n\tuv_poll_init_socket(pt->io_loop_uv, &wsi->w_read.uv_watcher, accept_fd);\n}\n\nvoid\nlws_libuv_io(struct lws *wsi, int flags)\n{\n\tstruct lws_context *context = lws_get_context(wsi);\n\tstruct lws_context_per_thread *pt = &wsi->context->pt[(int)wsi->tsi];\n#if defined(WIN32) || defined(_WIN32)\n\tint current_events = wsi->w_read.uv_watcher.events &\n\t\t\t     (UV_READABLE | UV_WRITABLE);\n#else\n\tint current_events = wsi->w_read.uv_watcher.io_watcher.pevents &\n\t\t\t     (UV_READABLE | UV_WRITABLE);\n#endif\n\tstruct lws_io_watcher *w = &wsi->w_read;\n\n\tif (!LWS_LIBUV_ENABLED(context))\n\t\treturn;\n\n\t// lwsl_notice(\"%s: wsi: %p, flags:0x%x\\n\", __func__, wsi, flags);\n\n\tif (!pt->io_loop_uv) {\n\t\tlwsl_info(\"%s: no io loop yet\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!((flags & (LWS_EV_START | LWS_EV_STOP)) &&\n\t      (flags & (LWS_EV_READ | LWS_EV_WRITE)))) {\n\t\tlwsl_err(\"%s: assert: flags %d\", __func__, flags);\n\t\tassert(0);\n\t}\n\n\tif (flags & LWS_EV_START) {\n\t\tif (flags & LWS_EV_WRITE)\n\t\t\tcurrent_events |= UV_WRITABLE;\n\n\t\tif (flags & LWS_EV_READ)\n\t\t\tcurrent_events |= UV_READABLE;\n\n\t\tuv_poll_start(&w->uv_watcher, current_events, lws_io_cb);\n\t} else {\n\t\tif (flags & LWS_EV_WRITE)\n\t\t\tcurrent_events &= ~UV_WRITABLE;\n\n\t\tif (flags & LWS_EV_READ)\n\t\t\tcurrent_events &= ~UV_READABLE;\n\n\t\tif (!(current_events & (UV_READABLE | UV_WRITABLE)))\n\t\t\tuv_poll_stop(&w->uv_watcher);\n\t\telse\n\t\t\tuv_poll_start(&w->uv_watcher, current_events,\n\t\t\t\t      lws_io_cb);\n\t}\n}\n\nint\nlws_libuv_init_fd_table(struct lws_context *context)\n{\n\tint n;\n\n\tif (!LWS_LIBUV_ENABLED(context))\n\t\treturn 0;\n\n\tfor (n = 0; n < context->count_threads; n++)\n\t\tcontext->pt[n].w_sigint.context = context;\n\n\treturn 1;\n}\n\nLWS_VISIBLE void\nlws_libuv_run(const struct lws_context *context, int tsi)\n{\n\tif (context->pt[tsi].io_loop_uv && LWS_LIBUV_ENABLED(context))\n\t\tuv_run(context->pt[tsi].io_loop_uv, 0);\n}\n\nstatic void\nlws_libuv_kill(const struct lws_context *context)\n{\n\tint n;\n\n\tfor (n = 0; n < context->count_threads; n++)\n\t\tif (context->pt[n].io_loop_uv &&\n\t\t    LWS_LIBUV_ENABLED(context) &&\n\t\t    !context->pt[n].ev_loop_foreign)\n\t\t\tuv_stop(context->pt[n].io_loop_uv);\n}\n\n/*\n * This does not actually stop the event loop.  The reason is we have to pass\n * libuv handle closures through its event loop.  So this tries to close all\n * wsi, and set a flag; when all the wsi closures are finalized then we\n * actually stop the libuv event loops.\n */\n\nLWS_VISIBLE void\nlws_libuv_stop(struct lws_context *context)\n{\n\tstruct lws_context_per_thread *pt;\n\tint n, m;\n\n\tif (context->requested_kill)\n\t\treturn;\n\n\tcontext->requested_kill = 1;\n\n\tm = context->count_threads;\n\tcontext->being_destroyed = 1;\n\n\twhile (m--) {\n\t\tpt = &context->pt[m];\n\n\t\tfor (n = 0; (unsigned int)n < context->pt[m].fds_count; n++) {\n\t\t\tstruct lws *wsi = wsi_from_fd(context, pt->fds[n].fd);\n\n\t\t\tif (!wsi)\n\t\t\t\tcontinue;\n\t\t\tlws_close_free_wsi(wsi,\n\t\t\t\tLWS_CLOSE_STATUS_NOSTATUS_CONTEXT_DESTROY\n\t\t\t\t/* no protocol close */);\n\t\t\tn--;\n\t\t}\n\t}\n\n\tlwsl_info(\"%s: feels everything closed\\n\", __func__);\n\tif (context->count_wsi_allocated == 0)\n\t\tlws_libuv_kill(context);\n}\n\nLWS_VISIBLE uv_loop_t *\nlws_uv_getloop(struct lws_context *context, int tsi)\n{\n\tif (context->pt[tsi].io_loop_uv && LWS_LIBUV_ENABLED(context))\n\t\treturn context->pt[tsi].io_loop_uv;\n\n\treturn NULL;\n}\n\nstatic void\nlws_libuv_closewsi(uv_handle_t* handle)\n{\n\tstruct lws *n = NULL, *wsi = (struct lws *)(((char *)handle) -\n\t\t\t  (char *)(&n->w_read.uv_watcher));\n\tstruct lws_context *context = lws_get_context(wsi);\n\n\tlws_close_free_wsi_final(wsi);\n\n\tif (context->requested_kill && context->count_wsi_allocated == 0)\n\t\tlws_libuv_kill(context);\n}\n\nvoid\nlws_libuv_closehandle(struct lws *wsi)\n{\n\tstruct lws_context *context = lws_get_context(wsi);\n\n\t/* required to defer actual deletion until libuv has processed it */\n\n\tuv_close((uv_handle_t*)&wsi->w_read.uv_watcher, lws_libuv_closewsi);\n\n\tif (context->requested_kill && context->count_wsi_allocated == 0)\n\t\tlws_libuv_kill(context);\n}\n\n#if defined(LWS_WITH_PLUGINS) && (UV_VERSION_MAJOR > 0)\n\nLWS_VISIBLE int\nlws_plat_plugins_init(struct lws_context * context, const char * const *d)\n{\n\tstruct lws_plugin_capability lcaps;\n\tstruct lws_plugin *plugin;\n\tlws_plugin_init_func initfunc;\n\tint m, ret = 0;\n\tvoid *v;\n\tuv_dirent_t dent;\n\tuv_fs_t req;\n\tchar path[256];\n\tuv_loop_t loop;\n\tuv_lib_t lib;\n\n\tlib.errmsg = NULL;\n\tlib.handle = NULL;\n\n\tuv_loop_init(&loop);\n\n\tlwsl_notice(\"  Plugins:\\n\");\n\n\twhile (d && *d) {\n\n\t\tlwsl_notice(\"  Scanning %s\\n\", *d);\n\t\tm =uv_fs_scandir(&loop, &req, *d, 0, NULL);\n\t\tif (m < 1) {\n\t\t\tlwsl_err(\"Scandir on %s failed\\n\", *d);\n\t\t\treturn 1;\n\t\t}\n\n\t\twhile (uv_fs_scandir_next(&req, &dent) != UV_EOF) {\n\t\t\tif (strlen(dent.name) < 7)\n\t\t\t\tcontinue;\n\n\t\t\tlwsl_notice(\"   %s\\n\", dent.name);\n\n\t\t\tlws_snprintf(path, sizeof(path) - 1, \"%s/%s\", *d, dent.name);\n\t\t\tif (uv_dlopen(path, &lib)) {\n\t\t\t\tuv_dlerror(&lib);\n\t\t\t\tlwsl_err(\"Error loading DSO: %s\\n\", lib.errmsg);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t/* we could open it, can we get his init function? */\n\t\t\tm = lws_snprintf(path, sizeof(path) - 1, \"init_%s\",\n\t\t\t\t     dent.name + 3 /* snip lib... */);\n\t\t\tpath[m - 3] = '\\0'; /* snip the .so */\n\t\t\tif (uv_dlsym(&lib, path, &v)) {\n\t\t\t\tuv_dlerror(&lib);\n\t\t\t\tlwsl_err(\"Failed to get init on %s: %s\",\n\t\t\t\t\t\tdent.name, lib.errmsg);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tinitfunc = (lws_plugin_init_func)v;\n\t\t\tlcaps.api_magic = LWS_PLUGIN_API_MAGIC;\n\t\t\tm = initfunc(context, &lcaps);\n\t\t\tif (m) {\n\t\t\t\tlwsl_err(\"Initializing %s failed %d\\n\", dent.name, m);\n\t\t\t\tgoto skip;\n\t\t\t}\n\n\t\t\tplugin = lws_malloc(sizeof(*plugin));\n\t\t\tif (!plugin) {\n\t\t\t\tlwsl_err(\"OOM\\n\");\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tplugin->list = context->plugin_list;\n\t\t\tcontext->plugin_list = plugin;\n\t\t\tstrncpy(plugin->name, dent.name, sizeof(plugin->name) - 1);\n\t\t\tplugin->name[sizeof(plugin->name) - 1] = '\\0';\n\t\t\tplugin->lib = lib;\n\t\t\tplugin->caps = lcaps;\n\t\t\tcontext->plugin_protocol_count += lcaps.count_protocols;\n\t\t\tcontext->plugin_extension_count += lcaps.count_extensions;\n\n\t\t\tcontinue;\n\nskip:\n\t\t\tuv_dlclose(&lib);\n\t\t}\nbail:\n\t\tuv_fs_req_cleanup(&req);\n\t\td++;\n\t}\n\n\tuv_loop_close(&loop);\n\n\treturn ret;\n\n}\n\nLWS_VISIBLE int\nlws_plat_plugins_destroy(struct lws_context * context)\n{\n\tstruct lws_plugin *plugin = context->plugin_list, *p;\n\tlws_plugin_destroy_func func;\n\tchar path[256];\n\tvoid *v;\n\tint m;\n\n\tif (!plugin)\n\t\treturn 0;\n\n\t// lwsl_notice(\"%s\\n\", __func__);\n\n\twhile (plugin) {\n\t\tp = plugin;\n\t\tm = lws_snprintf(path, sizeof(path) - 1, \"destroy_%s\", plugin->name + 3);\n\t\tpath[m - 3] = '\\0';\n\n\t\tif (uv_dlsym(&plugin->lib, path, &v)) {\n\t\t\tuv_dlerror(&plugin->lib);\n\t\t\tlwsl_err(\"Failed to get init on %s: %s\",\n\t\t\t\t\tplugin->name, plugin->lib.errmsg);\n\t\t} else {\n\t\t\tfunc = (lws_plugin_destroy_func)v;\n\t\t\tm = func(context);\n\t\t\tif (m)\n\t\t\t\tlwsl_err(\"Destroying %s failed %d\\n\",\n\t\t\t\t\t\tplugin->name, m);\n\t\t}\n\n\t\tuv_dlclose(&p->lib);\n\t\tplugin = p->list;\n\t\tp->list = NULL;\n\t\tfree(p);\n\t}\n\n\tcontext->plugin_list = NULL;\n\n\treturn 0;\n}\n\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.0.3-zwvd2lwbxecx6zyzxz5n37hdkwpxnf5h/spack-src/lib/lws-plat-unix.c": "#include \"private-libwebsockets.h\"\n\n#include <pwd.h>\n#include <grp.h>\n\n#include <dlfcn.h>\n#include <dirent.h>\n\n\n/*\n * included from libwebsockets.c for unix builds\n */\n\nunsigned long long time_in_microseconds(void)\n{\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn ((unsigned long long)tv.tv_sec * 1000000LL) + tv.tv_usec;\n}\n\nLWS_VISIBLE int\nlws_get_random(struct lws_context *context, void *buf, int len)\n{\n\treturn read(context->fd_random, (char *)buf, len);\n}\n\nLWS_VISIBLE int\nlws_send_pipe_choked(struct lws *wsi)\n{\n\tstruct lws_pollfd fds;\n\n\t/* treat the fact we got a truncated send pending as if we're choked */\n\tif (wsi->trunc_len)\n\t\treturn 1;\n\n\tfds.fd = wsi->sock;\n\tfds.events = POLLOUT;\n\tfds.revents = 0;\n\n\tif (poll(&fds, 1, 0) != 1)\n\t\treturn 1;\n\n\tif ((fds.revents & POLLOUT) == 0)\n\t\treturn 1;\n\n\t/* okay to send another packet without blocking */\n\n\treturn 0;\n}\n\nLWS_VISIBLE int\nlws_poll_listen_fd(struct lws_pollfd *fd)\n{\n\treturn poll(fd, 1, 0);\n}\n\n/**\n * lws_cancel_service_pt() - Cancel servicing of pending socket activity\n *\t\t\t\ton one thread\n * @wsi:\tCancel service on the thread this wsi is serviced by\n *\n *\tThis function let a call to lws_service() waiting for a timeout\n *\timmediately return.\n */\nLWS_VISIBLE void\nlws_cancel_service_pt(struct lws *wsi)\n{\n\tstruct lws_context_per_thread *pt = &wsi->context->pt[(int)wsi->tsi];\n\tchar buf = 0;\n\n\tif (write(pt->dummy_pipe_fds[1], &buf, sizeof(buf)) != 1)\n\t\tlwsl_err(\"Cannot write to dummy pipe\");\n}\n\n/**\n * lws_cancel_service() - Cancel ALL servicing of pending socket activity\n * @context:\tWebsocket context\n *\n *\tThis function let a call to lws_service() waiting for a timeout\n *\timmediately return.\n */\nLWS_VISIBLE void\nlws_cancel_service(struct lws_context *context)\n{\n\tstruct lws_context_per_thread *pt = &context->pt[0];\n\tchar buf = 0, m = context->count_threads;\n\n\twhile (m--) {\n\t\tif (write(pt->dummy_pipe_fds[1], &buf, sizeof(buf)) != 1)\n\t\t\tlwsl_err(\"Cannot write to dummy pipe\");\n\t\tpt++;\n\t}\n}\n\nLWS_VISIBLE void lwsl_emit_syslog(int level, const char *line)\n{\n\tint syslog_level = LOG_DEBUG;\n\n\tswitch (level) {\n\tcase LLL_ERR:\n\t\tsyslog_level = LOG_ERR;\n\t\tbreak;\n\tcase LLL_WARN:\n\t\tsyslog_level = LOG_WARNING;\n\t\tbreak;\n\tcase LLL_NOTICE:\n\t\tsyslog_level = LOG_NOTICE;\n\t\tbreak;\n\tcase LLL_INFO:\n\t\tsyslog_level = LOG_INFO;\n\t\tbreak;\n\t}\n\tsyslog(syslog_level, \"%s\", line);\n}\n\nLWS_VISIBLE int\nlws_plat_service_tsi(struct lws_context *context, int timeout_ms, int tsi)\n{\n\tstruct lws_context_per_thread *pt = &context->pt[tsi];\n\tint n = -1, m, c;\n\tchar buf;\n\n\t/* stay dead once we are dead */\n\n\tif (!context || !context->vhost_list)\n\t\treturn 1;\n\n\tif (timeout_ms < 0)\n\t\tgoto faked_service;\n\n\tlws_libev_run(context, tsi);\n\tlws_libuv_run(context, tsi);\n\n\tif (!context->service_tid_detected) {\n\t\tstruct lws _lws;\n\n\t\tmemset(&_lws, 0, sizeof(_lws));\n\t\t_lws.context = context;\n\n\t\tcontext->service_tid_detected =\n\t\t\tcontext->vhost_list->protocols[0].callback(\n\t\t\t&_lws, LWS_CALLBACK_GET_THREAD_ID, NULL, NULL, 0);\n\t}\n\tcontext->service_tid = context->service_tid_detected;\n\n\ttimeout_ms = lws_service_adjust_timeout(context, timeout_ms, tsi);\n\n\tn = poll(pt->fds, pt->fds_count, timeout_ms);\n\n#ifdef LWS_OPENSSL_SUPPORT\n\tif (!pt->rx_draining_ext_list &&\n\t    !lws_ssl_anybody_has_buffered_read_tsi(context, tsi) && !n) {\n#else\n\tif (!pt->rx_draining_ext_list && !n) /* poll timeout */ {\n#endif\n\t\tlws_service_fd_tsi(context, NULL, tsi);\n\t\treturn 0;\n\t}\n\nfaked_service:\n\tm = lws_service_flag_pending(context, tsi);\n\tif (m)\n\t\tc = -1; /* unknown limit */\n\telse\n\t\tif (n < 0) {\n\t\t\tif (LWS_ERRNO != LWS_EINTR)\n\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\tc = n;\n\n\t/* any socket with events to service? */\n\tfor (n = 0; n < pt->fds_count && c; n++) {\n\t\tif (!pt->fds[n].revents)\n\t\t\tcontinue;\n\n\t\tc--;\n\n\t\tif (pt->fds[n].fd == pt->dummy_pipe_fds[0]) {\n\t\t\tif (read(pt->fds[n].fd, &buf, 1) != 1)\n\t\t\t\tlwsl_err(\"Cannot read from dummy pipe.\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tm = lws_service_fd_tsi(context, &pt->fds[n], tsi);\n\t\tif (m < 0)\n\t\t\treturn -1;\n\t\t/* if something closed, retry this slot */\n\t\tif (m)\n\t\t\tn--;\n\t}\n\n\treturn 0;\n}\n\nLWS_VISIBLE int\nlws_plat_service(struct lws_context *context, int timeout_ms)\n{\n\treturn lws_plat_service_tsi(context, timeout_ms, 0);\n}\n\nLWS_VISIBLE int\nlws_plat_set_socket_options(struct lws_vhost *vhost, int fd)\n{\n\tint optval = 1;\n\tsocklen_t optlen = sizeof(optval);\n\n#if defined(__APPLE__) || \\\n    defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || \\\n    defined(__NetBSD__) || \\\n    defined(__OpenBSD__)\n\tstruct protoent *tcp_proto;\n#endif\n\n\tif (vhost->ka_time) {\n\t\t/* enable keepalive on this socket */\n\t\toptval = 1;\n\t\tif (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE,\n\t\t\t       (const void *)&optval, optlen) < 0)\n\t\t\treturn 1;\n\n#if defined(__APPLE__) || \\\n    defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || \\\n    defined(__NetBSD__) || \\\n        defined(__CYGWIN__) || defined(__OpenBSD__)\n\n\t\t/*\n\t\t * didn't find a way to set these per-socket, need to\n\t\t * tune kernel systemwide values\n\t\t */\n#else\n\t\t/* set the keepalive conditions we want on it too */\n\t\toptval = vhost->ka_time;\n\t\tif (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE,\n\t\t\t       (const void *)&optval, optlen) < 0)\n\t\t\treturn 1;\n\n\t\toptval = vhost->ka_interval;\n\t\tif (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL,\n\t\t\t       (const void *)&optval, optlen) < 0)\n\t\t\treturn 1;\n\n\t\toptval = vhost->ka_probes;\n\t\tif (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT,\n\t\t\t       (const void *)&optval, optlen) < 0)\n\t\t\treturn 1;\n#endif\n\t}\n\n\t/* Disable Nagle */\n\toptval = 1;\n#if !defined(__APPLE__) && \\\n    !defined(__FreeBSD__) && !defined(__FreeBSD_kernel__) && \\\n    !defined(__NetBSD__) && \\\n    !defined(__OpenBSD__)\n\tif (setsockopt(fd, SOL_TCP, TCP_NODELAY, (const void *)&optval, optlen) < 0)\n\t\treturn 1;\n#else\n\ttcp_proto = getprotobyname(\"TCP\");\n\tif (setsockopt(fd, tcp_proto->p_proto, TCP_NODELAY, &optval, optlen) < 0)\n\t\treturn 1;\n#endif\n\n\t/* We are nonblocking... */\n\tif (fcntl(fd, F_SETFL, O_NONBLOCK) < 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nLWS_VISIBLE void\nlws_plat_drop_app_privileges(struct lws_context_creation_info *info)\n{\n\tif (info->gid != -1)\n\t\tif (setgid(info->gid))\n\t\t\tlwsl_warn(\"setgid: %s\\n\", strerror(LWS_ERRNO));\n\n\tif (info->uid != -1) {\n\t\tstruct passwd *p = getpwuid(info->uid);\n\n\t\tif (p) {\n\t\t\tinitgroups(p->pw_name, info->gid);\n\t\t\tif (setuid(info->uid))\n\t\t\t\tlwsl_warn(\"setuid: %s\\n\", strerror(LWS_ERRNO));\n\t\t\telse\n\t\t\t\tlwsl_notice(\"Set privs to user '%s'\\n\", p->pw_name);\n\t\t} else\n\t\t\tlwsl_warn(\"getpwuid: unable to find uid %d\", info->uid);\n\t}\n}\n\n#ifdef LWS_WITH_PLUGINS\n\n#if defined(LWS_USE_LIBUV) && UV_VERSION_MAJOR > 0\n\n/* libuv.c implements these in a cross-platform way */\n\n#else\n\nstatic int filter(const struct dirent *ent)\n{\n\tif (!strcmp(ent->d_name, \".\") || !strcmp(ent->d_name, \"..\"))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nLWS_VISIBLE int\nlws_plat_plugins_init(struct lws_context * context, const char * const *d)\n{\n\tstruct lws_plugin_capability lcaps;\n\tstruct lws_plugin *plugin;\n\tlws_plugin_init_func initfunc;\n\tstruct dirent **namelist;\n\tint n, i, m, ret = 0;\n\tchar path[256];\n\tvoid *l;\n\n\tlwsl_notice(\"  Plugins:\\n\");\n\n\twhile (d && *d) {\n\t\tn = scandir(*d, &namelist, filter, alphasort);\n\t\tif (n < 0) {\n\t\t\tlwsl_err(\"Scandir on %s failed\\n\", *d);\n\t\t\treturn 1;\n\t\t}\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (strlen(namelist[i]->d_name) < 7)\n\t\t\t\tgoto inval;\n\n\t\t\tlwsl_notice(\"   %s\\n\", namelist[i]->d_name);\n\n\t\t\tlws_snprintf(path, sizeof(path) - 1, \"%s/%s\", *d,\n\t\t\t\t namelist[i]->d_name);\n\t\t\tl = dlopen(path, RTLD_NOW);\n\t\t\tif (!l) {\n\t\t\t\tlwsl_err(\"Error loading DSO: %s\\n\", dlerror());\n\t\t\t\twhile (i++ < n)\n\t\t\t\t\tfree(namelist[i]);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t/* we could open it, can we get his init function? */\n\t\t\tm = lws_snprintf(path, sizeof(path) - 1, \"init_%s\",\n\t\t\t\t     namelist[i]->d_name + 3 /* snip lib... */);\n\t\t\tpath[m - 3] = '\\0'; /* snip the .so */\n\t\t\tinitfunc = dlsym(l, path);\n\t\t\tif (!initfunc) {\n\t\t\t\tlwsl_err(\"Failed to get init on %s: %s\",\n\t\t\t\t\t\tnamelist[i]->d_name, dlerror());\n\t\t\t\tdlclose(l);\n\t\t\t}\n\t\t\tlcaps.api_magic = LWS_PLUGIN_API_MAGIC;\n\t\t\tm = initfunc(context, &lcaps);\n\t\t\tif (m) {\n\t\t\t\tlwsl_err(\"Initializing %s failed %d\\n\",\n\t\t\t\t\tnamelist[i]->d_name, m);\n\t\t\t\tdlclose(l);\n\t\t\t\tgoto skip;\n\t\t\t}\n\n\t\t\tplugin = lws_malloc(sizeof(*plugin));\n\t\t\tif (!plugin) {\n\t\t\t\tlwsl_err(\"OOM\\n\");\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tplugin->list = context->plugin_list;\n\t\t\tcontext->plugin_list = plugin;\n\t\t\tstrncpy(plugin->name, namelist[i]->d_name, sizeof(plugin->name) - 1);\n\t\t\tplugin->name[sizeof(plugin->name) - 1] = '\\0';\n\t\t\tplugin->l = l;\n\t\t\tplugin->caps = lcaps;\n\t\t\tcontext->plugin_protocol_count += lcaps.count_protocols;\n\t\t\tcontext->plugin_extension_count += lcaps.count_extensions;\n\n\t\t\tfree(namelist[i]);\n\t\t\tcontinue;\n\n\tskip:\n\t\t\tdlclose(l);\n\tinval:\n\t\t\tfree(namelist[i]);\n\t\t}\n\t\tfree(namelist);\n\t\td++;\n\t}\n\nbail:\n\tfree(namelist);\n\n\treturn ret;\n}\n\nLWS_VISIBLE int\nlws_plat_plugins_destroy(struct lws_context * context)\n{\n\tstruct lws_plugin *plugin = context->plugin_list, *p;\n\tlws_plugin_destroy_func func;\n\tchar path[256];\n\tint m;\n\n\tif (!plugin)\n\t\treturn 0;\n\n\tlwsl_notice(\"%s\\n\", __func__);\n\n\twhile (plugin) {\n\t\tp = plugin;\n\t\tm = lws_snprintf(path, sizeof(path) - 1, \"destroy_%s\", plugin->name + 3);\n\t\tpath[m - 3] = '\\0';\n\t\tfunc = dlsym(plugin->l, path);\n\t\tif (!func) {\n\t\t\tlwsl_err(\"Failed to get destroy on %s: %s\",\n\t\t\t\t\tplugin->name, dlerror());\n\t\t\tgoto next;\n\t\t}\n\t\tm = func(context);\n\t\tif (m)\n\t\t\tlwsl_err(\"Initializing %s failed %d\\n\",\n\t\t\t\tplugin->name, m);\nnext:\n\t\tdlclose(p->l);\n\t\tplugin = p->list;\n\t\tp->list = NULL;\n\t\tfree(p);\n\t}\n\n\tcontext->plugin_list = NULL;\n\n\treturn 0;\n}\n\n#endif\n#endif\n\n\n#if 0\nstatic void\nsigabrt_handler(int x)\n{\n\tprintf(\"%s\\n\", __func__);\n\t//*(char *)0 = 0;\n}\n#endif\n\nLWS_VISIBLE int\nlws_plat_context_early_init(void)\n{\n\tsignal(SIGPIPE, SIG_IGN);\n\n//\tsignal(SIGABRT, sigabrt_handler);\n\n\treturn 0;\n}\n\nLWS_VISIBLE void\nlws_plat_context_early_destroy(struct lws_context *context)\n{\n}\n\nLWS_VISIBLE void\nlws_plat_context_late_destroy(struct lws_context *context)\n{\n\tstruct lws_context_per_thread *pt = &context->pt[0];\n\tint m = context->count_threads;\n\n#ifdef LWS_WITH_PLUGINS\n\tif (context->plugin_list)\n\t\tlws_plat_plugins_destroy(context);\n#endif\n\n\tif (context->lws_lookup)\n\t\tlws_free(context->lws_lookup);\n\n\twhile (m--) {\n\t\tclose(pt->dummy_pipe_fds[0]);\n\t\tclose(pt->dummy_pipe_fds[1]);\n\t\tpt++;\n\t}\n\tclose(context->fd_random);\n}\n\n/* cast a struct sockaddr_in6 * into addr for ipv6 */\n\nLWS_VISIBLE int\nlws_interface_to_sa(int ipv6, const char *ifname, struct sockaddr_in *addr,\n\t\t    size_t addrlen)\n{\n\tint rc = -1;\n\n\tstruct ifaddrs *ifr;\n\tstruct ifaddrs *ifc;\n#ifdef LWS_USE_IPV6\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n#endif\n\n\tgetifaddrs(&ifr);\n\tfor (ifc = ifr; ifc != NULL && rc; ifc = ifc->ifa_next) {\n\t\tif (!ifc->ifa_addr)\n\t\t\tcontinue;\n\n\t\tlwsl_info(\" interface %s vs %s\\n\", ifc->ifa_name, ifname);\n\n\t\tif (strcmp(ifc->ifa_name, ifname))\n\t\t\tcontinue;\n\n\t\tswitch (ifc->ifa_addr->sa_family) {\n\t\tcase AF_INET:\n#ifdef LWS_USE_IPV6\n\t\t\tif (ipv6) {\n\t\t\t\t/* map IPv4 to IPv6 */\n\t\t\t\tbzero((char *)&addr6->sin6_addr,\n\t\t\t\t\t\tsizeof(struct in6_addr));\n\t\t\t\taddr6->sin6_addr.s6_addr[10] = 0xff;\n\t\t\t\taddr6->sin6_addr.s6_addr[11] = 0xff;\n\t\t\t\tmemcpy(&addr6->sin6_addr.s6_addr[12],\n\t\t\t\t\t&((struct sockaddr_in *)ifc->ifa_addr)->sin_addr,\n\t\t\t\t\t\t\tsizeof(struct in_addr));\n\t\t\t} else\n#endif\n\t\t\t\tmemcpy(addr,\n\t\t\t\t\t(struct sockaddr_in *)ifc->ifa_addr,\n\t\t\t\t\t\t    sizeof(struct sockaddr_in));\n\t\t\tbreak;\n#ifdef LWS_USE_IPV6\n\t\tcase AF_INET6:\n\t\t\tmemcpy(&addr6->sin6_addr,\n\t\t\t  &((struct sockaddr_in6 *)ifc->ifa_addr)->sin6_addr,\n\t\t\t\t\t\t       sizeof(struct in6_addr));\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\trc = 0;\n\t}\n\n\tfreeifaddrs(ifr);\n\n\tif (rc == -1) {\n\t\t/* check if bind to IP adddress */\n#ifdef LWS_USE_IPV6\n\t\tif (inet_pton(AF_INET6, ifname, &addr6->sin6_addr) == 1)\n\t\t\trc = 0;\n\t\telse\n#endif\n\t\tif (inet_pton(AF_INET, ifname, &addr->sin_addr) == 1)\n\t\t\trc = 0;\n\t}\n\n\treturn rc;\n}\n\nLWS_VISIBLE void\nlws_plat_insert_socket_into_fds(struct lws_context *context, struct lws *wsi)\n{\n\tstruct lws_context_per_thread *pt = &context->pt[(int)wsi->tsi];\n\n\tlws_libev_io(wsi, LWS_EV_START | LWS_EV_READ);\n\tlws_libuv_io(wsi, LWS_EV_START | LWS_EV_READ);\n\n\tpt->fds[pt->fds_count++].revents = 0;\n}\n\nLWS_VISIBLE void\nlws_plat_delete_socket_from_fds(struct lws_context *context,\n\t\t\t\t\t\tstruct lws *wsi, int m)\n{\n\tstruct lws_context_per_thread *pt = &context->pt[(int)wsi->tsi];\n\n\tlws_libev_io(wsi, LWS_EV_STOP | LWS_EV_READ | LWS_EV_WRITE);\n\tlws_libuv_io(wsi, LWS_EV_STOP | LWS_EV_READ | LWS_EV_WRITE);\n\n\tpt->fds_count--;\n}\n\nLWS_VISIBLE void\nlws_plat_service_periodic(struct lws_context *context)\n{\n\t/* if our parent went down, don't linger around */\n\tif (context->started_with_parent &&\n\t    kill(context->started_with_parent, 0) < 0)\n\t\tkill(getpid(), SIGTERM);\n}\n\nLWS_VISIBLE int\nlws_plat_change_pollfd(struct lws_context *context,\n\t\t      struct lws *wsi, struct lws_pollfd *pfd)\n{\n\treturn 0;\n}\n\nLWS_VISIBLE const char *\nlws_plat_inet_ntop(int af, const void *src, char *dst, int cnt)\n{\n\treturn inet_ntop(af, src, dst, cnt);\n}\n\nstatic lws_filefd_type\n_lws_plat_file_open(struct lws *wsi, const char *filename,\n\t\t    unsigned long *filelen, int flags)\n{\n\tstruct stat stat_buf;\n\tint ret = open(filename, flags, 0664);\n\n\tif (ret < 0)\n\t\treturn LWS_INVALID_FILE;\n\n\tif (fstat(ret, &stat_buf) < 0) {\n\t\tclose(ret);\n\t\treturn LWS_INVALID_FILE;\n\t}\n\t*filelen = stat_buf.st_size;\n\treturn ret;\n}\n\nstatic int\n_lws_plat_file_close(struct lws *wsi, lws_filefd_type fd)\n{\n\treturn close(fd);\n}\n\nunsigned long\n_lws_plat_file_seek_cur(struct lws *wsi, lws_filefd_type fd, long offset)\n{\n\treturn lseek(fd, offset, SEEK_CUR);\n}\n\nstatic int\n_lws_plat_file_read(struct lws *wsi, lws_filefd_type fd, unsigned long *amount,\n\t\t    unsigned char *buf, unsigned long len)\n{\n\tlong n;\n\n\tn = read((int)fd, buf, len);\n\tif (n == -1) {\n\t\t*amount = 0;\n\t\treturn -1;\n\t}\n\n\t*amount = n;\n\n\treturn 0;\n}\n\nstatic int\n_lws_plat_file_write(struct lws *wsi, lws_filefd_type fd, unsigned long *amount,\n\t\t     unsigned char *buf, unsigned long len)\n{\n\tlong n;\n\n\tn = write((int)fd, buf, len);\n\tif (n == -1) {\n\t\t*amount = 0;\n\t\treturn -1;\n\t}\n\n\t*amount = n;\n\n\treturn 0;\n}\n\n\nLWS_VISIBLE int\nlws_plat_init(struct lws_context *context,\n\t      struct lws_context_creation_info *info)\n{\n\tstruct lws_context_per_thread *pt = &context->pt[0];\n\tint n = context->count_threads, fd;\n\n\t/* master context has the global fd lookup array */\n\tcontext->lws_lookup = lws_zalloc(sizeof(struct lws *) *\n\t\t\t\t\t context->max_fds);\n\tif (context->lws_lookup == NULL) {\n\t\tlwsl_err(\"OOM on lws_lookup array for %d connections\\n\",\n\t\t\t context->max_fds);\n\t\treturn 1;\n\t}\n\n\tlwsl_notice(\" mem: platform fd map: %5u bytes\\n\",\n\t\t    sizeof(struct lws *) * context->max_fds);\n\tfd = open(SYSTEM_RANDOM_FILEPATH, O_RDONLY);\n\n\tcontext->fd_random = fd;\n\tif (context->fd_random < 0) {\n\t\tlwsl_err(\"Unable to open random device %s %d\\n\",\n\t\t\t SYSTEM_RANDOM_FILEPATH, context->fd_random);\n\t\treturn 1;\n\t}\n\n\tif (!lws_libev_init_fd_table(context) &&\n\t    !lws_libuv_init_fd_table(context)) {\n\t\t/* otherwise libev handled it instead */\n\n\t\twhile (n--) {\n\t\t\tif (pipe(pt->dummy_pipe_fds)) {\n\t\t\t\tlwsl_err(\"Unable to create pipe\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t/* use the read end of pipe as first item */\n\t\t\tpt->fds[0].fd = pt->dummy_pipe_fds[0];\n\t\t\tpt->fds[0].events = LWS_POLLIN;\n\t\t\tpt->fds[0].revents = 0;\n\t\t\tpt->fds_count = 1;\n\t\t\tpt++;\n\t\t}\n\t}\n\n\tcontext->fops.open\t= _lws_plat_file_open;\n\tcontext->fops.close\t= _lws_plat_file_close;\n\tcontext->fops.seek_cur\t= _lws_plat_file_seek_cur;\n\tcontext->fops.read\t= _lws_plat_file_read;\n\tcontext->fops.write\t= _lws_plat_file_write;\n\n#ifdef LWS_WITH_PLUGINS\n\tif (info->plugin_dirs)\n\t\tlws_plat_plugins_init(context, info->plugin_dirs);\n#endif\n\n\treturn 0;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.0.3-zwvd2lwbxecx6zyzxz5n37hdkwpxnf5h/spack-src/plugins/lwsws-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.0.3-zwvd2lwbxecx6zyzxz5n37hdkwpxnf5h/spack-src/test-server/leaf.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.0.3-zwvd2lwbxecx6zyzxz5n37hdkwpxnf5h/spack-src/test-server/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.0.3-zwvd2lwbxecx6zyzxz5n37hdkwpxnf5h/spack-src/test-server/libwebsockets.org-logo.png"
    ],
    "total_files": 149
}