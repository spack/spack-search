{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-occa-1.0.0-alpha.5-ojbjrhgcq2p75xjsepixsqmrvedt6ikx/spack-src/src/modes/serial/kernel.cpp": "/* The MIT License (MIT)\n *\n * Copyright (c) 2014-2018 David Medina and Tim Warburton\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\n#include \"occa/modes/serial/kernel.hpp\"\n#include \"occa/tools/env.hpp\"\n#include \"occa/tools/io.hpp\"\n#include \"occa/base.hpp\"\n\nnamespace occa {\n  namespace serial {\n    kernel::kernel(const occa::properties &properties_) :\n      occa::kernel_v(properties_) {\n      dlHandle = NULL;\n      handle   = NULL;\n    }\n\n    kernel::~kernel() {}\n\n    void kernel::build(const std::string &filename,\n                       const std::string &kernelName,\n                       const hash_t hash,\n                       const occa::properties &props) {\n\n      name = kernelName;\n      properties += props;\n\n      const bool isLaunchKernel = props.has(\"defines/OCCA_LAUNCH_KERNEL\");\n      const bool verbose = properties.get(\"verbose\", false);\n\n      const std::string sourceFile = (isLaunchKernel\n                                      ? getLaunchSourceFilename(filename, hash)\n                                      : getSourceFilename(filename, hash));\n      const std::string binaryFile = (isLaunchKernel\n                                      ? getLaunchBinaryFilename(filename, hash)\n                                      : getBinaryFilename(filename, hash));\n      const std::string sourceBasename = (isLaunchKernel\n                                          ? kc::launchSourceFile\n                                          : kc::sourceFile);\n      bool foundBinary = true;\n\n      const std::string hashTag = \"serial-kernel\";\n      if (!io::haveHash(hash, hashTag)) {\n        io::waitForHash(hash, hashTag);\n      } else if (sys::fileExists(binaryFile)) {\n        io::releaseHash(hash, hashTag);\n      } else {\n        foundBinary = false;\n      }\n\n      if (foundBinary) {\n        if (verbose) {\n          std::cout << \"Found cached binary of [\" << io::shortname(filename) << \"] in [\" << io::shortname(binaryFile) << \"]\\n\";\n        }\n        return buildFromBinary(binaryFile, kernelName, props);\n      }\n\n      std::string kernelDefines;\n      if (properties.has(\"occa/kernel/defines\")) {\n        kernelDefines = properties[\"occa/kernel/defines\"].string();\n      } else {\n        kernelDefines = io::cacheFile(env::OCCA_DIR + \"/include/occa/modes/serial/kernelDefines.hpp\",\n                                      \"serialKernelDefines.hpp\");\n      }\n\n      std::stringstream ss, command;\n      ss << \"#include \\\"\" << kernelDefines << \"\\\"\\n\"\n         << assembleHeader(properties) << '\\n'\n         << \"#if defined(OCCA_IN_KERNEL) && !OCCA_IN_KERNEL\\n\"\n         << \"using namespace occa;\\n\"\n         << \"#endif\\n\";\n\n      const std::string cachedSourceFile = io::cacheFile(filename,\n                                                         sourceBasename,\n                                                         hash,\n                                                         ss.str(),\n                                                         properties[\"footer\"].string());\n\n      const std::string &compilerEnvScript = properties[\"compilerEnvScript\"].string();\n      if (compilerEnvScript.size()) {\n        command << compilerEnvScript << \" && \";\n      }\n\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      command << properties[\"compiler\"].string()\n              << ' '    << properties[\"compilerFlags\"].string()\n              << ' '    << cachedSourceFile\n              << \" -o \" << binaryFile\n              << \" -I\"  << env::OCCA_DIR << \"include\"\n              << \" -L\"  << env::OCCA_DIR << \"lib -locca\"\n              << std::endl;\n#else\n#  if (OCCA_DEBUG_ENABLED)\n      const std::string occaLib = env::OCCA_DIR + \"lib/libocca_d.lib \";\n#  else\n      const std::string occaLib = env::OCCA_DIR + \"lib/libocca.lib \";\n#  endif\n\n      command << properties[\"compiler\"]\n              << \" /D MC_CL_EXE\"\n              << \" /D OCCA_OS=OCCA_WINDOWS_OS\"\n              << \" /EHsc\"\n              << \" /wd4244 /wd4800 /wd4804 /wd4018\"\n              << ' '       << properties[\"compilerFlags\"]\n              << \" /I\"     << env::OCCA_DIR << \"/include\"\n              << ' '       << sourceFile\n              << \" /link \" << occaLib\n              << \" /OUT:\"  << binaryFile\n              << std::endl;\n#endif\n\n      const std::string &sCommand = command.str();\n\n      if (verbose) {\n        std::cout << \"Compiling [\" << kernelName << \"]\\n\" << sCommand << \"\\n\";\n      }\n\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      const int compileError = system(sCommand.c_str());\n#else\n      const int compileError = system((\"\\\"\" +  sCommand + \"\\\"\").c_str());\n#endif\n\n      if (compileError) {\n        io::releaseHash(hash, hashTag);\n        OCCA_ERROR(\"Compilation error\", compileError);\n      }\n\n      dlHandle = sys::dlopen(binaryFile, hash, hashTag);\n      handle   = sys::dlsym(dlHandle, kernelName, hash, hashTag);\n\n      io::releaseHash(hash, hashTag);\n    }\n\n    void kernel::buildFromBinary(const std::string &filename,\n                                 const std::string &kernelName,\n                                 const occa::properties &props) {\n\n      name = kernelName;\n      properties += props;\n\n      dlHandle = sys::dlopen(filename);\n      handle   = sys::dlsym(dlHandle, kernelName);\n    }\n\n    int kernel::maxDims() const {\n      return 3;\n    }\n\n    dim kernel::maxOuterDims() const {\n      return dim(-1,-1,-1);\n    }\n\n    dim kernel::maxInnerDims() const {\n      return dim(-1,-1,-1);\n    }\n\n    void kernel::runFromArguments(const int kArgc, const kernelArg *kArgs) const {\n      int argc = 0;\n      kernelInfoArg_t info;\n\n      if (properties.get(\"OKL\", true)) {\n        info.outerDim0 = outer.x; info.innerDim0 = inner.x;\n        info.outerDim1 = outer.y; info.innerDim1 = inner.y;\n        info.outerDim2 = outer.z; info.innerDim2 = inner.z;\n\n        info.innerId0 = info.innerId1 = info.innerId2 = 0;\n        vArgs[argc++] = &info;\n      }\n\n      for (int i = 0; i < kArgc; ++i) {\n        const int argCount = (int) kArgs[i].args.size();\n        if (argCount) {\n          const kernelArgData *kArgs_i = &(kArgs[i].args[0]);\n          for (int j = 0; j < argCount; ++j) {\n            vArgs[argc++] = kArgs_i[j].ptr();\n          }\n        }\n      }\n\n      sys::runFunction(handle, argc, vArgs);\n    }\n\n    void kernel::free() {\n      if (dlHandle) {\n        sys::dlclose(dlHandle);\n        dlHandle = NULL;\n      }\n    }\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-occa-1.0.0-alpha.5-ojbjrhgcq2p75xjsepixsqmrvedt6ikx/spack-src/src/tools/sys.cpp": "/* The MIT License (MIT)\n *\n * Copyright (c) 2014-2018 David Medina and Tim Warburton\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\n#include \"occa/defines.hpp\"\n\n#if   (OCCA_OS & OCCA_LINUX_OS)\n#  include <ctime>\n#  include <cxxabi.h>\n#  include <dlfcn.h>\n#  include <errno.h>\n#  include <execinfo.h>\n#  include <sys/time.h>\n#  include <sys/syscall.h>\n#  include <sys/sysctl.h>\n#  include <sys/sysinfo.h>\n#  include <pthread.h>\n#  include <unistd.h>\n#elif (OCCA_OS & OCCA_OSX_OS)\n#  include <ctime>\n#  include <cxxabi.h>\n#  include <dlfcn.h>\n#  include <execinfo.h>\n#  include <mach/mach_host.h>\n#  include <sys/syscall.h>\n#  include <sys/sysctl.h>\n#  include <unistd.h>\n#  ifdef __clang__\n#    include <CoreServices/CoreServices.h>\n#    include <mach/mach_time.h>\n#  else\n#    include <mach/clock.h>\n#    include <mach/mach.h>\n#  endif\n#else\n#  ifndef NOMINMAX\n#    define NOMINMAX // Clear min/max macros\n#  endif\n#  include <windows.h>\n#endif\n\n#include <iomanip>\n#include <sstream>\n\n#include <sys/types.h>\n#include <fcntl.h>\n\n#include \"occa/base.hpp\"\n#include \"occa/tools/env.hpp\"\n#include \"occa/tools/hash.hpp\"\n#include \"occa/tools/io.hpp\"\n#include \"occa/tools/lex.hpp\"\n#include \"occa/tools/misc.hpp\"\n#include \"occa/tools/string.hpp\"\n#include \"occa/tools/sys.hpp\"\n#include \"occa/parser/tools.hpp\"\n\nnamespace occa {\n  namespace flags {\n    const int checkCacheDir = (1 << 0);\n  }\n\n  namespace sys {\n    //---[ System Info ]----------------\n    double currentTime() {\n#if (OCCA_OS & OCCA_LINUX_OS)\n      timespec ct;\n      clock_gettime(CLOCK_MONOTONIC, &ct);\n\n      return (double) (ct.tv_sec + (1.0e-9 * ct.tv_nsec));\n#elif (OCCA_OS == OCCA_OSX_OS)\n#  ifdef __clang__\n      uint64_t ct;\n      ct = mach_absolute_time();\n\n      const Nanoseconds ct2 = AbsoluteToNanoseconds(*(AbsoluteTime *) &ct);\n\n      return ((double) 1.0e-9) * ((double) ( *((uint64_t*) &ct2) ));\n#  else\n      clock_serv_t cclock;\n      host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &cclock);\n\n      mach_timespec_t ct;\n      clock_get_time(cclock, &ct);\n\n      mach_port_deallocate(mach_task_self(), cclock);\n\n      return (double) (ct.tv_sec + (1.0e-9 * ct.tv_nsec));\n#  endif\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      static LARGE_INTEGER freq;\n      static bool haveFreq = false;\n\n      if (!haveFreq) {\n        QueryPerformanceFrequency(&freq);\n        haveFreq=true;\n      }\n\n      LARGE_INTEGER ct;\n\n      QueryPerformanceCounter(&ct);\n\n      return ((double) (ct.QuadPart)) / ((double) (freq.QuadPart));\n#endif\n    }\n\n    std::string date() {\n      ::time_t time_ = ::time(0);\n      struct ::tm &timeInfo = *(::localtime(&time_));\n      const int year  = timeInfo.tm_year + 1900;\n      const int month = timeInfo.tm_mon + 1;\n      const int day   = timeInfo.tm_mday;\n      const int hour  = timeInfo.tm_hour;\n      const int min   = timeInfo.tm_min;\n      const int sec   = timeInfo.tm_sec;\n\n      std::stringstream ss;\n      ss << year << '/';\n      if (month < 10) ss << '0';\n      ss << month << '/';\n      if (day   < 10) ss << '0';\n      ss << day << ' ';\n      if (hour  < 10) ss << '0';\n      ss << hour << ':';\n      if (min   < 10) ss << '0';\n      ss << min << ':';\n      if (sec   < 10) ss << '0';\n      ss << sec;\n      return ss.str();\n    }\n\n    std::string humanDate() {\n      ::time_t time_ = ::time(0);\n      struct ::tm &timeInfo = *(::localtime(&time_));\n      const int year  = timeInfo.tm_year + 1900;\n      const int month = timeInfo.tm_mon + 1;\n      const int day   = timeInfo.tm_mday;\n      const int hour  = timeInfo.tm_hour;\n      const int min   = timeInfo.tm_min;\n\n      std::stringstream ss;\n\n      switch (month) {\n      case 1 : ss << \"Jan\"; break;\n      case 2 : ss << \"Feb\"; break;\n      case 3 : ss << \"Mar\"; break;\n      case 4 : ss << \"Apr\"; break;\n      case 5 : ss << \"May\"; break;\n      case 6 : ss << \"Jun\"; break;\n      case 7 : ss << \"Jul\"; break;\n      case 8 : ss << \"Aug\"; break;\n      case 9 : ss << \"Sep\"; break;\n      case 10: ss << \"Oct\"; break;\n      case 11: ss << \"Nov\"; break;\n      case 12: ss << \"Dec\"; break;\n      }\n\n      ss << ' ' << day << ' ' << year << ' ';\n      if (hour < 10) ss << '0';\n      ss << hour << ':';\n      if (min  < 10) ss << '0';\n      ss << min;\n\n      return ss.str();\n    }\n    //==================================\n\n    //---[ System Calls ]---------------\n    int call(const std::string &cmdline) {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      FILE *fp = popen(cmdline.c_str(), \"r\");\n      return pclose(fp);\n#else\n      FILE *fp = _popen(cmdline.c_str(), \"r\");\n      return _pclose(fp);\n#endif\n    }\n\n    int call(const std::string &cmdline, std::string &output) {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      FILE *fp = popen(cmdline.c_str(), \"r\");\n#else\n      FILE *fp = _popen(cmdline.c_str(), \"r\");\n#endif\n\n      size_t lineBytes = 512;\n      char lineBuffer[512];\n\n      while (fgets(lineBuffer, lineBytes, fp)) {\n        output += lineBuffer;\n      }\n\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      return pclose(fp);\n#else\n      return _pclose(fp);\n#endif\n    }\n\n    std::string expandEnvVariables(const std::string &str) {\n      const char *c = str.c_str();\n      const char *c0 = c;\n      std::string expstr;\n\n      while (*c != '\\0') {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n        if ((*c == '$') && ((c0 < c) || (*(c - 1) != '\\\\'))) {\n          if (*(c + 1) == '{') {\n            const char *cStart = c + 2;\n            skipTo(c, '}');\n\n            if (*c == '\\0')\n              return expstr;\n\n            expstr += env::var(std::string(cStart, c - cStart));\n          } else {\n            const char *cStart = c + 1;\n            skipTo(c, '/');\n            expstr += env::var(std::string(cStart, c - cStart));\n          }\n        }\n#else\n        if (*c == '%') {\n          const char *cStart = (++c);\n          skipTo(c, '%');\n          expstr += env::var(std::string(cStart, c - cStart));\n        }\n#endif\n        else {\n          expstr += *c;\n        }\n        ++c;\n      }\n\n      return expstr;\n    }\n\n    void rmdir(const std::string &dir) {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      ::rmdir(dir.c_str());\n#else\n      ::_rmdir(dir.c_str());\n#endif\n    }\n\n    int mkdir(const std::string &dir) {\n      errno = 0;\n\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      return ::mkdir(dir.c_str(), 0755);\n#else\n      return ::_mkdir(dir.c_str());\n#endif\n    }\n\n    void mkpath(const std::string &dir) {\n      strVector path = split(io::filename(dir), '/');\n\n      const int dirCount = (int) path.size();\n      std::string sPath;\n      int makeFrom = -1;\n\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      const int firstDir = 0;\n      if (dirCount == 0)\n        return;\n      sPath += '/';\n#else\n      const int firstDir = 1;\n      if (dirCount <= 1)\n        return;\n      sPath += path[0];\n      sPath += '/';\n#endif\n\n      for (int d = firstDir; d < dirCount; ++d) {\n        sPath += path[d];\n        if (!dirExists(sPath)) {\n          makeFrom = d;\n          break;\n        }\n        sPath += '/';\n      }\n\n      if (0 < makeFrom) {\n        sys::mkdir(sPath);\n\n        for (int d = (makeFrom + 1); d < dirCount; ++d) {\n          sPath += '/';\n          sPath += path[d];\n\n          sys::mkdir(sPath);\n        }\n      }\n    }\n\n    bool dirExists(const std::string &dir_) {\n      std::string dir = expandEnvVariables(dir_);\n      strip(dir);\n\n      struct stat statInfo;\n      return ((stat(dir.c_str(), &statInfo) == 0) &&\n              S_ISDIR(statInfo.st_mode));\n    }\n\n    bool fileExists(const std::string &filename_,\n                    const int flags) {\n\n      std::string filename = expandEnvVariables(filename_);\n      strip(filename);\n\n      if (flags & flags::checkCacheDir)\n        return fileExists(io::filename(filename));\n\n      struct stat statInfo;\n\n      return (stat(filename.c_str(), &statInfo) == 0);\n    }\n\n    int getPID() {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      return getpid();\n#else\n      return GetCurrentProcessId();\n#endif\n    }\n\n    int getTID() {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      return syscall(SYS_gettid);\n#else\n      return GetCurrentThreadId();\n#endif\n    }\n\n    void pinToCore(const int core) {\n      const int coreCount = getCoreCount();\n      OCCA_ERROR(\"Core to pin (\" << core << \") is not in range: [0, \"\n                 << coreCount << \"]\",\n                 (0 <= core) && (core < coreCount));\n#if (OCCA_OS == OCCA_LINUX_OS)\n      cpu_set_t cpuSet;\n      CPU_ZERO(&cpuSet);\n      CPU_SET(core, &cpuSet);\n      syscall(__NR_sched_setaffinity, getTID(), sizeof(cpu_set_t), &cpuSet);\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      SetThreadAffinityMask(GetCurrentThread(), 1 << core);\n#endif\n    }\n    //==================================\n\n    //---[ Processor Info ]-------------\n    std::string getFieldFrom(const std::string &command,\n                             const std::string &field) {\n#if (OCCA_OS & LINUX)\n      std::string shellToolsFile = io::filename(\"occa://occa/scripts/shellTools.sh\");\n\n      if (!sys::fileExists(shellToolsFile)) {\n        sys::mkpath(dirname(shellToolsFile));\n\n        std::ofstream fs2;\n        fs2.open(shellToolsFile.c_str());\n\n        fs2 << getCachedScript(\"shellTools.sh\");\n\n        fs2.close();\n      }\n\n      std::stringstream ss;\n\n      ss << \"echo \\\"(. \" << shellToolsFile << \"; \" << command << \" '\" << field << \"')\\\" | bash\";\n\n      std::string sCommand = ss.str();\n\n      FILE *fp;\n      fp = popen(sCommand.c_str(), \"r\");\n\n      const int bufferSize = 4096;\n      char *buffer = new char[bufferSize];\n\n      ignoreResult( fread(buffer, sizeof(char), bufferSize, fp) );\n\n      pclose(fp);\n\n      int end;\n\n      for (end = 0; end < bufferSize; ++end) {\n        if (buffer[end] == '\\n')\n          break;\n      }\n\n      std::string ret(buffer, end);\n\n      delete [] buffer;\n\n      return ret;\n#else\n      return \"\";\n#endif\n    }\n\n    std::string getProcessorName() {\n#if   (OCCA_OS & OCCA_LINUX_OS)\n      return getFieldFrom(\"getCPUINFOField\", \"model name\");\n#elif (OCCA_OS == OCCA_OSX_OS)\n      size_t bufferSize = 100;\n      char buffer[100];\n\n      sysctlbyname(\"machdep.cpu.brand_string\",\n                   &buffer, &bufferSize,\n                   NULL, 0);\n\n      return std::string(buffer);\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      char buffer[MAX_COMPUTERNAME_LENGTH + 1];\n      int bytes;\n\n      GetComputerName((LPSTR) buffer, (LPDWORD) &bytes);\n\n      return std::string(buffer, bytes);\n#endif\n    }\n\n    int getCoreCount() {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      return sysconf(_SC_NPROCESSORS_ONLN);\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      SYSTEM_INFO sysinfo;\n      GetSystemInfo(&sysinfo);\n      return sysinfo.dwNumberOfProcessors;\n#endif\n    }\n\n    int getProcessorFrequency() {\n#if   (OCCA_OS & OCCA_LINUX_OS)\n      std::stringstream ss;\n      int freq;\n\n      ss << getFieldFrom(\"getCPUINFOField\", \"cpu MHz\");\n\n      ss >> freq;\n\n      return freq;\n#elif (OCCA_OS == OCCA_OSX_OS)\n      uint64_t frequency = 0;\n      size_t size = sizeof(frequency);\n\n      int error = sysctlbyname(\"hw.cpufrequency\", &frequency, &size, NULL, 0);\n\n      OCCA_ERROR(\"Error getting CPU Frequency.\\n\",\n                 error != ENOMEM);\n\n      return frequency/1.0e6;\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      LARGE_INTEGER performanceFrequency;\n      QueryPerformanceFrequency(&performanceFrequency);\n\n      return (int) (((double) performanceFrequency.QuadPart) / 1000.0);\n#endif\n    }\n\n    std::string getProcessorCacheSize(int level) {\n#if   (OCCA_OS & OCCA_LINUX_OS)\n      std::stringstream field;\n\n      field << 'L' << level;\n\n      if (level == 1)\n        field << 'd';\n\n      field << \" cache\";\n\n      return getFieldFrom(\"getLSCPUField\", field.str());\n#elif (OCCA_OS == OCCA_OSX_OS)\n      std::stringstream ss;\n      ss << \"hw.l\" << level;\n\n      if (level == 1)\n        ss << 'd';\n\n      ss << \"cachesize\";\n\n      std::string field = ss.str();\n\n      uint64_t cache = 0;\n      size_t size = sizeof(cache);\n\n      int error = sysctlbyname(field.c_str(), &cache, &size, NULL, 0);\n\n      OCCA_ERROR(\"Error getting L\" << level << \" Cache Size.\\n\",\n                 error != ENOMEM);\n\n      return stringifyBytes(cache);\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      std::stringstream ss;\n      DWORD cache = 0;\n      int bytes = 0;\n\n      PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer = NULL;\n\n      GetLogicalProcessorInformation(buffer, (LPDWORD) &bytes);\n\n      OCCA_ERROR(\"[GetLogicalProcessorInformation] Failed\",\n                 (GetLastError() == ERROR_INSUFFICIENT_BUFFER));\n\n      buffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION) sys::malloc(bytes);\n\n      bool passed = GetLogicalProcessorInformation(buffer, (LPDWORD) &bytes);\n\n      OCCA_ERROR(\"[GetLogicalProcessorInformation] Failed\",\n                 passed);\n\n      PSYSTEM_LOGICAL_PROCESSOR_INFORMATION pos = buffer;\n      int off = 0;\n      int sk = sizeof(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION);\n\n      while ((off + sk) <= bytes) {\n        switch(pos->Relationship) {\n        case RelationCache:{\n          CACHE_DESCRIPTOR info = pos->Cache;\n\n          if (info.Level == level) {\n            cache = info.Size;\n            break;\n          }\n        }\n        }\n        ++pos;\n        off += sk;\n      }\n\n      sys::free(buffer);\n\n      return stringifyBytes(cache);\n#endif\n    }\n\n    udim_t installedRAM() {\n#if   (OCCA_OS & OCCA_LINUX_OS)\n      struct sysinfo info;\n\n      const int error = sysinfo(&info);\n\n      if (error != 0)\n        return 0;\n\n      return info.totalram;\n#elif (OCCA_OS == OCCA_OSX_OS)\n      int64_t ram;\n\n      int mib[2]   = {CTL_HW, HW_MEMSIZE};\n      size_t bytes = sizeof(ram);\n\n      sysctl(mib, 2, &ram, &bytes, NULL, 0);\n\n      return ram;\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      return 0;\n#endif\n    }\n\n    udim_t availableRAM() {\n#if   (OCCA_OS & OCCA_LINUX_OS)\n      struct sysinfo info;\n\n      const int error = sysinfo(&info);\n\n      if (error != 0)\n        return 0;\n\n      return info.freeram;\n#elif (OCCA_OS == OCCA_OSX_OS)\n      mach_msg_type_number_t infoCount = HOST_VM_INFO_COUNT;\n      mach_port_t hostPort = mach_host_self();\n\n      vm_statistics_data_t hostInfo;\n      kern_return_t status;\n      vm_size_t pageSize;\n\n      status = host_page_size(hostPort, &pageSize);\n\n      if (status != KERN_SUCCESS)\n        return 0;\n\n      status = host_statistics(hostPort,\n                               HOST_VM_INFO,\n                               (host_info_t) &hostInfo,\n                               &infoCount);\n\n      if (status != KERN_SUCCESS)\n        return 0;\n\n      return (hostInfo.free_count * pageSize);\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      return 0;\n#endif\n    }\n\n    int compilerVendor(const std::string &compiler) {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      const std::string safeCompiler = io::removeSlashes(compiler);\n      int vendor_ = sys::vendor::notFound;\n      std::stringstream ss;\n\n      const std::string compilerVendorTest = env::OCCA_DIR + \"/scripts/compilerVendorTest.cpp\";\n      hash_t hash = occa::hashFile(compilerVendorTest);\n      hash ^= occa::hash(vendor_);\n      hash ^= occa::hash(compiler);\n\n      const std::string srcFilename = io::cacheFile(compilerVendorTest, \"compilerVendorTest.cpp\", hash);\n      const std::string hashDir = io::dirname(srcFilename);\n      const std::string binaryFilename   = hashDir + \"binary\";\n      const std::string outFilename      = hashDir + \"output\";\n      const std::string buildLogFilename = hashDir + \"build.log\";\n\n      const std::string hashTag = \"compiler\";\n      if (!io::haveHash(hash, hashTag)) {\n        io::waitForHash(hash, hashTag);\n      } else {\n        if (!sys::fileExists(outFilename)) {\n          ss << compiler\n             << ' '    << srcFilename\n             << \" -o \" << binaryFilename\n             << \" > \" << buildLogFilename << \" 2>&1\";\n          const std::string compileLine = ss.str();\n\n          ignoreResult( system(compileLine.c_str()) );\n\n          OCCA_ERROR(\"Could not compile compilerVendorTest.cpp with following command:\\n\" << compileLine,\n                     sys::fileExists(binaryFilename));\n\n          int exitStatus = system(binaryFilename.c_str());\n          int vendorBit  = WEXITSTATUS(exitStatus);\n\n          if (vendorBit < sys::vendor::b_max) {\n            vendor_ = (1 << vendorBit);\n          }\n\n          ss.str(\"\");\n          ss << vendor_;\n\n          io::write(outFilename, ss.str());\n          io::releaseHash(hash, hashTag);\n\n          return vendor_;\n        }\n        io::releaseHash(hash, hashTag);\n      }\n\n      ss << io::read(outFilename);\n      ss >> vendor_;\n\n      return vendor_;\n\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n#  if OCCA_USING_VS\n      return sys::vendor::VisualStudio;\n#  endif\n\n      if (compiler.find(\"cl.exe\") != std::string::npos) {\n        return sys::vendor::VisualStudio;\n      }\n#endif\n    }\n\n    std::string compilerSharedBinaryFlags(const std::string &compiler) {\n      return compilerSharedBinaryFlags( sys::compilerVendor(compiler) );\n    }\n\n    std::string compilerSharedBinaryFlags(const int vendor_) {\n      if (vendor_ & (sys::vendor::GNU   |\n                     sys::vendor::LLVM  |\n                     sys::vendor::Intel |\n                     sys::vendor::PGI   |\n                     sys::vendor::Cray  |\n                     sys::vendor::Pathscale)) {\n        return \"-x c++ -fPIC -shared\";\n      } else if (vendor_ & sys::vendor::IBM) {\n        return \"-x c++ -qpic -shared\";\n      } else if (vendor_ & sys::vendor::HP) {\n        return \"+z -b\";\n      } else if (vendor_ & sys::vendor::VisualStudio) {\n#if OCCA_DEBUG_ENABLED\n        return \"/TP /LD /MDd\";\n#else\n        return \"/TP /LD /MD\";\n#endif\n      }\n      OCCA_FORCE_ERROR(\"Could not find compiler flags for creating a shared object\");\n      return \"\";\n    }\n\n    void addSharedBinaryFlagsTo(const std::string &compiler, std::string &flags) {\n      addSharedBinaryFlagsTo(sys::compilerVendor(compiler), flags);\n    }\n\n    void addSharedBinaryFlagsTo(const int vendor_, std::string &flags) {\n      std::string sFlags = sys::compilerSharedBinaryFlags(vendor_);\n\n      if (flags.size() == 0) {\n        flags = sFlags;\n      }\n      if (flags.find(sFlags) == std::string::npos) {\n        flags = (sFlags + \" \" + flags);\n      }\n    }\n\n    //---[ Dynamic Methods ]------------\n    void* malloc(udim_t bytes) {\n      void* ptr;\n\n#if   (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      ignoreResult( posix_memalign(&ptr, env::OCCA_MEM_BYTE_ALIGN, bytes) );\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      ptr = ::malloc(bytes);\n#endif\n\n      return ptr;\n    }\n\n    void free(void *ptr) {\n      ::free(ptr);\n    }\n\n    void* dlopen(const std::string &filename,\n                 const hash_t &hash,\n                 const std::string &hashTag) {\n\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      void *dlHandle = ::dlopen(filename.c_str(), RTLD_NOW);\n\n      if ((dlHandle == NULL) && hash.initialized) {\n        io::releaseHash(hash, hashTag);\n\n        OCCA_ERROR(\"Error loading binary [\" << io::shortname(filename) << \"] with dlopen\",\n                   false);\n      }\n#else\n      void *dlHandle = LoadLibraryA(filename.c_str());\n\n      if ((dlHandle == NULL) && hash.initialized) {\n        io::releaseHash(hash, hashTag);\n\n        OCCA_ERROR(\"Error loading dll [\" << io::shortname(filename) << \"] (WIN32 error: \" << GetLastError() << \")\",\n                   dlHandle != NULL);\n      }\n#endif\n\n      return dlHandle;\n    }\n\n    handleFunction_t dlsym(void *dlHandle,\n                           const std::string &functionName,\n                           const hash_t &hash,\n                           const std::string &hashTag) {\n\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      void *sym = ::dlsym(dlHandle, functionName.c_str());\n\n      char *dlError;\n\n      if (((dlError = dlerror()) != NULL) && hash.initialized) {\n        io::releaseHash(hash, hashTag);\n\n        OCCA_ERROR(\"Error loading symbol from binary with dlsym (DL Error: \" << dlError << \")\",\n                   false);\n      }\n#else\n      void *sym = GetProcAddress((HMODULE) dlHandle, functionName.c_str());\n\n      if ((sym == NULL) && hash.initialized) {\n\n        OCCA_ERROR(\"Error loading symbol from binary with GetProcAddress\",\n                   false);\n      }\n#endif\n\n      handleFunction_t sym2;\n\n      ::memcpy(&sym2, &sym, sizeof(sym));\n\n      return sym2;\n    }\n\n    void dlclose(void *dlHandle) {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      ::dlclose(dlHandle);\n#else\n      FreeLibrary((HMODULE) (dlHandle));\n#endif\n    }\n\n    void runFunction(handleFunction_t f, const int argc, void **args) {\n#include \"operators/runFunctionFromArguments.cpp\"\n    }\n\n    void printStacktrace(const int frameStart, const std::string indent) {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n      static const int maxFrames = 1024;\n      static void *frames[maxFrames];\n\n      const int frameCount = ::backtrace(frames, maxFrames);\n      char **symbols = ::backtrace_symbols(frames, frameCount);\n\n      const int digits = toString(frameCount - frameStart).size();\n\n      for (int i = frameStart; i < frameCount; ++i) {\n        const std::string localFrame = toString(frameCount - i);\n        std::cout << indent\n                  << localFrame << std::string(digits - localFrame.size() + 1, ' ')\n                  << prettyStackSymbol(frames[i], symbols[i]) << '\\n';\n      }\n      ::free(symbols);\n#endif\n    }\n\n    std::string prettyStackSymbol(void *frame, const char *symbol) {\n      static size_t maxChars = 1024;\n      static char prettyBuffer[1024];\n      std::stringstream ss;\n\n#if (OCCA_OS == OCCA_OSX_OS)\n      const char *c = symbol;\n      // Skip stack depth\n      lex::skipBetweenWhitespaces(c);\n      // Get origin\n      const char *originStart = c;\n      lex::skipToWhitespace(c);\n      std::string origin(originStart, (c - originStart));\n      // Skip address\n      lex::skipBetweenWhitespaces(c);\n      // Get function name\n      const char *functionStart = c;\n      lex::skipToWhitespace(c);\n      std::string function(functionStart, (c - functionStart));\n      // Skip the +\n      lex::skipBetweenWhitespaces(c);\n      // Get address offset\n      const char *offsetStart = c;\n      lex::skipToWhitespace(c);\n      std::string offset(offsetStart, (c - offsetStart));\n\n      int status;\n      const char *prettyFunction = abi::__cxa_demangle(function.c_str(),\n                                                       prettyBuffer,\n                                                       &maxChars,\n                                                       &status);\n\n      ss << std::left << std::setw(20) << origin\n         << std::left << std::setw(50) << (status ? function : prettyFunction);\n      return ss.str();\n#elif (OCCA_OS == OCCA_LINUX_OS)\n      std::string function;\n\n      Dl_info frameInfo;\n      int status = dladdr(frame, &frameInfo);\n      const char *dl_name = frameInfo.dli_sname;\n\n      if (status && dl_name) {\n        const char *prettyFunction = abi::__cxa_demangle(dl_name,\n                                                         prettyBuffer,\n                                                         &maxChars,\n                                                         &status);\n        if (!status) {\n          function = std::string(prettyFunction);\n        }\n      }\n      if (function.size() == 0) {\n        const char *c = symbol;\n        // Get function name\n        lex::skipWhitespace(c);\n        const char *functionStart = c;\n        lex::skipToWhitespace(c);\n        function = std::string(functionStart, (c - functionStart));\n      }\n      return function;\n#else\n      return std::string(c);\n#endif\n    }\n  }\n\n  void _message(const std::string &title,\n                const bool exitInFailure,\n                const std::string &filename,\n                const std::string &function,\n                const int line,\n                const std::string &message) {\n\n    std::string header = \"---[ \" + title + \" ]\";\n    header += std::string(60 - header.size(), '-');\n\n    std::cerr << '\\n'\n              << header << '\\n'\n              << \"    File     : \" << filename << '\\n'\n              << \"    Function : \" << function << '\\n'\n              << \"    Line     : \" << line     << '\\n';\n    if (message.size()) {\n      std::cerr << \"    Message  : \" << message << '\\n';\n    }\n    std::cerr << \"    Stack    :\\n\";\n    sys::printStacktrace(3, \"      \");\n    std::cerr << std::string(60, '=') << '\\n';\n\n    if (exitInFailure) {\n      throw 1;\n    }\n  }\n\n  void warn(const std::string &filename,\n            const std::string &function,\n            const int line,\n            const std::string &message) {\n    _message(\"Warning\", false,\n             filename, function, line, message);\n  }\n\n  void error(const std::string &filename,\n             const std::string &function,\n             const int line,\n             const std::string &message) {\n    _message(\"Error\", true,\n             filename, function, line, message);\n  }\n\n  void printNote(std::ostream &out,\n                 const std::string &message) {\n    out << blue(\"Note\") << \": \" << message << '\\n';\n  }\n\n  void printWarning(std::ostream &out,\n                    const std::string &message) {\n    out << yellow(\"Warning\") << \": \" << message << '\\n';\n  }\n\n  void printError(std::ostream &out,\n                  const std::string &message) {\n    out << red(\"Error\") << \": \" << message << '\\n';\n  }\n\n  mutex::mutex() {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n    int error = pthread_mutex_init(&mutexHandle, NULL);\n\n    OCCA_ERROR(\"Error initializing mutex\",\n               error == 0);\n#else\n    mutexHandle = CreateMutex(NULL, FALSE, NULL);\n#endif\n  }\n\n  void mutex::free() {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n    int error = pthread_mutex_destroy(&mutexHandle);\n\n    OCCA_ERROR(\"Error freeing mutex\",\n               error == 0);\n#else\n    CloseHandle(mutexHandle);\n#endif\n  }\n\n  void mutex::lock() {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n    pthread_mutex_lock(&mutexHandle);\n#else\n    WaitForSingleObject(mutexHandle, INFINITE);\n#endif\n  }\n\n  void mutex::unlock() {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n    pthread_mutex_unlock(&mutexHandle);\n#else\n    ReleaseMutex(mutexHandle);\n#endif\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-occa-1.0.0-alpha.5-ojbjrhgcq2p75xjsepixsqmrvedt6ikx/spack-src/include/occa/tools/sys.hpp": "/* The MIT License (MIT)\n *\n * Copyright (c) 2014-2018 David Medina and Tim Warburton\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\n#ifndef OCCA_TOOLS_SYS_HEADER\n#define OCCA_TOOLS_SYS_HEADER\n\n#include <iostream>\n#include <sstream>\n\n#include \"occa/defines.hpp\"\n#include \"occa/types.hpp\"\n#include \"occa/tools/hash.hpp\"\n\nnamespace occa {\n  typedef void (*handleFunction_t)(...);\n\n  namespace flags {\n    extern const int checkCacheDir;\n  }\n\n  namespace sys {\n    namespace vendor {\n      static const int notFound = 0;\n\n      static const int b_GNU          = 0;\n      static const int b_LLVM         = 1;\n      static const int b_Intel        = 2;\n      static const int b_Pathscale    = 3;\n      static const int b_IBM          = 4;\n      static const int b_PGI          = 5;\n      static const int b_HP           = 6;\n      static const int b_VisualStudio = 7;\n      static const int b_Cray         = 8;\n      static const int b_max          = 9;\n\n      static const int GNU          = (1 << b_GNU);          // gcc    , g++\n      static const int LLVM         = (1 << b_LLVM);         // clang  , clang++\n      static const int Intel        = (1 << b_Intel);        // icc    , icpc\n      static const int Pathscale    = (1 << b_Pathscale);    // pathCC\n      static const int IBM          = (1 << b_IBM);          // xlc    , xlc++\n      static const int PGI          = (1 << b_PGI);          // pgcc   , pgc++\n      static const int HP           = (1 << b_HP);           // aCC\n      static const int VisualStudio = (1 << b_VisualStudio); // cl.exe\n      static const int Cray         = (1 << b_Cray);         // cc     , CC\n    }\n\n    //---[ System Info ]----------------\n    double currentTime();\n    std::string date();\n    std::string humanDate();\n    //==================================\n\n    //---[ System Calls ]---------------\n    int call(const std::string &cmdline);\n    int call(const std::string &cmdline, std::string &output);\n\n    std::string expandEnvVariables(const std::string &str);\n\n    void rmdir(const std::string &dir);\n    int mkdir(const std::string &dir);\n    void mkpath(const std::string &dir);\n\n    bool dirExists(const std::string &dir_);\n    bool fileExists(const std::string &filename_,\n                    const int flags = 0);\n\n    int getPID();\n    int getTID();\n    void pinToCore(const int core);\n    //==================================\n\n    //---[ Processor Info ]-------------\n    std::string getFieldFrom(const std::string &command,\n                             const std::string &field);\n\n    std::string getProcessorName();\n    int getCoreCount();\n    int getProcessorFrequency();\n    std::string getProcessorCacheSize(int level);\n    udim_t installedRAM();\n    udim_t availableRAM();\n\n    int compilerVendor(const std::string &compiler);\n\n    std::string compilerSharedBinaryFlags(const std::string &compiler);\n    std::string compilerSharedBinaryFlags(const int vendor_);\n\n    void addSharedBinaryFlagsTo(const std::string &compiler, std::string &flags);\n    void addSharedBinaryFlagsTo(const int vendor_, std::string &flags);\n    //==================================\n\n    //---[ Dynamic Methods ]------------\n    void* malloc(udim_t bytes);\n    void free(void *ptr);\n\n    void* dlopen(const std::string &filename,\n                 const hash_t &hash = hash_t(),\n                 const std::string &hashTag = \"\");\n\n    handleFunction_t dlsym(void *dlHandle,\n                           const std::string &functionName,\n                           const hash_t &hash = hash_t(),\n                           const std::string &hashTag = \"\");\n\n    void dlclose(void *dlHandle);\n\n    void runFunction(handleFunction_t f, const int argc, void **args);\n\n    void printStacktrace(const int frameStart = 0, const std::string indent = \"\");\n    std::string prettyStackSymbol(void *frame, const char *symbol);\n    //==================================\n  }\n\n  void _message(const std::string &title,\n                const bool exitInFailure,\n                const std::string &filename,\n                const std::string &function,\n                const int line,\n                const std::string &message);\n\n  void warn(const std::string &filename,\n            const std::string &function,\n            const int line,\n            const std::string &message);\n\n  void error(const std::string &filename,\n             const std::string &function,\n             const int line,\n             const std::string &message);\n\n  void printNote(std::ostream &out,\n                 const std::string &message);\n\n  inline void printNote(const std::string &message) {\n    printNote(std::cerr, message);\n  }\n\n  void printWarning(std::ostream &out,\n                    const std::string &message);\n\n  inline void printWarning(const std::string &message) {\n    printWarning(std::cerr, message);\n  }\n\n  void printError(std::ostream &out,\n                  const std::string &message);\n\n  inline void printError(const std::string &message) {\n    printError(std::cerr, message);\n  }\n\n  class mutex {\n  public:\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_OSX_OS))\n    pthread_mutex_t mutexHandle;\n#else\n    HANDLE mutexHandle;\n#endif\n\n    mutex();\n    void free();\n\n    void lock();\n    void unlock();\n  };\n}\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-occa-1.0.0-alpha.5-ojbjrhgcq2p75xjsepixsqmrvedt6ikx/spack-src/.git/objects/pack/pack-ec7745093ae1a99183d537d99151251cdd3e5b09.idx",
        "/tmp/vanessa/spack-stage/spack-stage-occa-1.0.0-alpha.5-ojbjrhgcq2p75xjsepixsqmrvedt6ikx/spack-src/.git/objects/pack/pack-ec7745093ae1a99183d537d99151251cdd3e5b09.pack"
    ],
    "total_files": 312
}