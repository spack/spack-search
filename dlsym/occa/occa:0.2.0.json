{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-occa-0.2.0-5nxq5eiljk2xvfw3jwwnnapbb2n6t4ub/spack-src/src/OpenMP.cpp": "#include \"occa/defines.hpp\"\n\n#if OCCA_OPENMP_ENABLED\n\n#include \"occa/Serial.hpp\"\n#include \"occa/OpenMP.hpp\"\n\n#include <omp.h>\n\nnamespace occa {\n  //---[ Helper Functions ]-----------\n  namespace omp {\n    std::string notSupported = \"N/A\";\n\n    std::string baseCompilerFlag(const int vendor_){\n      if(vendor_ & (cpu::vendor::GNU |\n                    cpu::vendor::LLVM)){\n\n        return \"-fopenmp\";\n      }\n      else if(vendor_ & (cpu::vendor::Intel |\n                         cpu::vendor::Pathscale)){\n\n        return \"-openmp\";\n      }\n      else if(vendor_ & cpu::vendor::IBM){\n        return \"-qsmp\";\n      }\n      else if(vendor_ & cpu::vendor::PGI){\n        return \"-mp\";\n      }\n      else if(vendor_ & cpu::vendor::HP){\n        return \"+Oopenmp\";\n      }\n      else if(vendor_ & cpu::vendor::VisualStudio){\n        return \"/openmp\";\n      }\n      else if(vendor_ & cpu::vendor::Cray){\n        return \"\";\n      }\n\n      return omp::notSupported;\n    }\n\n    std::string compilerFlag(const int vendor_,\n                             const std::string &compiler){\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n      std::stringstream ss;\n      std::string flag = omp::notSupported;\n\n      const std::string safeCompiler = removeSlashes(compiler);\n      const std::string &hash = safeCompiler;\n\n      const std::string testFilename   = sys::getFilename(\"[occa]/testing/ompTest.cpp\");\n      const std::string binaryFilename = sys::getFilename(\"[occa]/testing/omp_\" + safeCompiler);\n      const std::string infoFilename   = sys::getFilename(\"[occa]/testing/ompInfo_\" + safeCompiler);\n\n      cacheFile(testFilename,\n                readFile(env::OCCA_DIR + \"/scripts/ompTest.cpp\"),\n                \"ompTest\");\n\n      if(!haveHash(hash)){\n        waitForHash(hash);\n      } else {\n        if(!sys::fileExists(infoFilename)){\n          flag = baseCompilerFlag(vendor_);\n          ss << compiler\n             << ' '\n             << flag\n             << ' '\n             << testFilename\n             << \" -o \"\n             << binaryFilename\n             << \" > /dev/null 2>&1\";\n\n          const int compileError = system(ss.str().c_str());\n\n          if(compileError)\n            flag = omp::notSupported;\n\n          writeToFile(infoFilename, flag);\n          releaseHash(hash);\n\n          return flag;\n        }\n        releaseHash(hash);\n      }\n\n      ss << readFile(infoFilename);\n      ss >> flag;\n\n      return flag;\n#elif (OCCA_OS == WINDOWS_OS)\n      return \"/openmp\"; // VS Compilers support OpenMP\n#endif\n    }\n  }\n  //==================================\n\n\n  //---[ Kernel ]---------------------\n  template <>\n  kernel_t<OpenMP>::kernel_t(){\n    strMode = \"OpenMP\";\n    name = \"\";\n    sourceFilename = \"\";\n    binaryFilename = \"\";\n\n    data    = NULL;\n    dHandle = NULL;\n\n    dims  = 1;\n    inner = occa::dim(1,1,1);\n    outer = occa::dim(1,1,1);\n  }\n\n  template <>\n  kernel_t<OpenMP>::kernel_t(const kernel_t<OpenMP> &k){\n    *this = k;\n  }\n\n  template <>\n  kernel_t<OpenMP>& kernel_t<OpenMP>::operator = (const kernel_t<OpenMP> &k){\n    data    = k.data;\n    dHandle = k.dHandle;\n\n    metaInfo = k.metaInfo;\n\n    dims  = k.dims;\n    inner = k.inner;\n    outer = k.outer;\n\n    nestedKernels = k.nestedKernels;\n\n    return *this;\n  }\n\n  template <>\n  kernel_t<OpenMP>::~kernel_t(){}\n\n  template <>\n  void* kernel_t<OpenMP>::getKernelHandle(){\n    OCCA_EXTRACT_DATA(OpenMP, Kernel);\n\n    void *ret;\n\n    ::memcpy(&ret, &data_.handle, sizeof(void*));\n\n    return ret;\n  }\n\n  template <>\n  void* kernel_t<OpenMP>::getProgramHandle(){\n    OCCA_EXTRACT_DATA(OpenMP, Kernel);\n\n    return data_.dlHandle;\n  }\n\n  template <>\n  std::string kernel_t<OpenMP>::fixBinaryName(const std::string &filename){\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    return filename;\n#else\n    return (filename + \".dll\");\n#endif\n  }\n\n  template <>\n  kernel_t<OpenMP>* kernel_t<OpenMP>::buildFromSource(const std::string &filename,\n                                                      const std::string &functionName,\n                                                      const kernelInfo &info_){\n\n    name = functionName;\n\n    kernelInfo info = info_;\n\n    dHandle->addOccaHeadersToInfo(info);\n\n    const std::string hash = getFileContentHash(filename,\n                                                dHandle->getInfoSalt(info));\n\n    const std::string hashDir    = hashDirFor(filename, hash);\n    sourceFilename = hashDir + kc::sourceFile;\n    binaryFilename = hashDir + fixBinaryName(kc::binaryFile);\n    bool foundBinary = true;\n\n    if (!haveHash(hash, 0))\n      waitForHash(hash, 0);\n    else if (sys::fileExists(binaryFilename))\n      releaseHash(hash, 0);\n    else\n      foundBinary = false;\n\n    if (foundBinary) {\n      if(verboseCompilation_f)\n        std::cout << \"Found cached binary of [\" << compressFilename(filename) << \"] in [\" << compressFilename(binaryFilename) << \"]\\n\";\n\n      return buildFromBinary(binaryFilename, functionName);\n    }\n\n    data = new OpenMPKernelData_t;\n\n    createSourceFileFrom(filename, hashDir, info);\n\n    std::stringstream command;\n\n    if(dHandle->compilerEnvScript.size())\n      command << dHandle->compilerEnvScript << \" && \";\n\n    //---[ Check if compiler flag is added ]------\n    OpenMPDeviceData_t &dData_ = *((OpenMPDeviceData_t*) dHandle->data);\n\n    const std::string ompFlag = dData_.OpenMPFlag;\n\n    if((dHandle->compilerFlags.find(ompFlag) == std::string::npos) &&\n       (            info.flags.find(ompFlag) == std::string::npos)){\n\n      info.flags += ' ';\n      info.flags += ompFlag;\n    }\n    //============================================\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    command << dHandle->compiler\n            << ' '    << dHandle->compilerFlags\n            << ' '    << info.flags\n            << ' '    << sourceFilename\n            << \" -o \" << binaryFilename\n            << \" -I\"  << env::OCCA_DIR << \"/include\"\n            << \" -L\"  << env::OCCA_DIR << \"/lib -locca\"\n            << std::endl;\n#else\n#  if (OCCA_DEBUG_ENABLED)\n    std::string occaLib = env::OCCA_DIR + \"\\\\lib\\\\libocca_d.lib \";\n#  else\n    std::string occaLib = env::OCCA_DIR + \"\\\\lib\\\\libocca.lib \";\n#  endif\n\n    std::string ptLib   = env::OCCA_DIR + \"\\\\lib\\\\pthreadVC2.lib \";\n\n    command << dHandle->compiler\n            << \" /D MC_CL_EXE\"\n            << ' '    << dHandle->compilerFlags\n            << ' '    << info.flags\n            << \" /I\"  << env::OCCA_DIR << \"\\\\include\"\n            << ' '    << sourceFilename\n            << \" /link \" << occaLib << ptLib << \" /OUT:\" << binaryFilename\n            << std::endl;\n#endif\n\n    const std::string &sCommand = command.str();\n\n    if(verboseCompilation_f)\n      std::cout << \"Compiling [\" << functionName << \"]\\n\" << sCommand << \"\\n\";\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    const int compileError = system(sCommand.c_str());\n#else\n    const int compileError = system((\"\\\"\" +  sCommand + \"\\\"\").c_str());\n#endif\n\n    if(compileError){\n      releaseHash(hash, 0);\n      OCCA_CHECK(false, \"Compilation error\");\n    }\n\n    OCCA_EXTRACT_DATA(OpenMP, Kernel);\n\n    data_.dlHandle = cpu::dlopen(binaryFilename, hash);\n    data_.handle   = cpu::dlsym(data_.dlHandle, functionName, hash);\n\n    releaseHash(hash, 0);\n\n    return this;\n  }\n\n  template <>\n  kernel_t<OpenMP>* kernel_t<OpenMP>::buildFromBinary(const std::string &filename,\n                                                      const std::string &functionName){\n\n    name = functionName;\n    binaryFilename = filename;\n\n    data = new OpenMPKernelData_t;\n\n    OCCA_EXTRACT_DATA(OpenMP, Kernel);\n\n    data_.dlHandle = cpu::dlopen(filename);\n    data_.handle   = cpu::dlsym(data_.dlHandle, functionName);\n\n    return this;\n  }\n\n  template <>\n  kernel_t<OpenMP>* kernel_t<OpenMP>::loadFromLibrary(const char *cache,\n                                                      const std::string &functionName){\n    return buildFromBinary(cache, functionName);\n  }\n\n  template <>\n  uintptr_t kernel_t<OpenMP>::maximumInnerDimSize(){\n    return ((uintptr_t) -1);\n  }\n\n  // [-] Missing\n  template <>\n  int kernel_t<OpenMP>::preferredDimSize(){\n    preferredDimSize_ = OCCA_SIMD_WIDTH;\n    return OCCA_SIMD_WIDTH;\n  }\n\n\n  template <>\n  void kernel_t<OpenMP>::runFromArguments(const int kArgc, const kernelArg *kArgs){\n    OpenMPKernelData_t &data_ = *((OpenMPKernelData_t*) data);\n    handleFunction_t tmpKernel = (handleFunction_t) data_.handle;\n    int occaKernelArgs[6];\n\n    occaKernelArgs[0] = outer.z; occaKernelArgs[3] = inner.z;\n    occaKernelArgs[1] = outer.y; occaKernelArgs[4] = inner.y;\n    occaKernelArgs[2] = outer.x; occaKernelArgs[5] = inner.x;\n\n    int argc = 0;\n    for(int i = 0; i < kArgc; ++i){\n      for(int j = 0; j < kArgs[i].argc; ++j){\n        data_.vArgs[argc++] = kArgs[i].args[j].ptr();\n      }\n    }\n\n    int occaInnerId0 = 0, occaInnerId1 = 0, occaInnerId2 = 0;\n\n    cpu::runFunction(tmpKernel,\n                     occaKernelArgs,\n                     occaInnerId0, occaInnerId1, occaInnerId2,\n                     argc, data_.vArgs);\n  }\n\n  template <>\n  void kernel_t<OpenMP>::free(){\n    OCCA_EXTRACT_DATA(OpenMP, Kernel);\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    dlclose(data_.dlHandle);\n#else\n    FreeLibrary((HMODULE) (data_.dlHandle));\n#endif\n  }\n  //==================================\n\n\n  //---[ Memory ]---------------------\n  template <>\n  memory_t<OpenMP>::memory_t(){\n    strMode = \"OpenMP\";\n\n    memInfo = memFlag::none;\n\n    handle    = NULL;\n    mappedPtr = NULL;\n    uvaPtr    = NULL;\n\n    dHandle = NULL;\n    size    = 0;\n\n    textureInfo.arg = NULL;\n    textureInfo.dim = 1;\n    textureInfo.w = textureInfo.h = textureInfo.d = 0;\n  }\n\n  template <>\n  memory_t<OpenMP>::memory_t(const memory_t<OpenMP> &m){\n    *this = m;\n  }\n\n  template <>\n  memory_t<OpenMP>& memory_t<OpenMP>::operator = (const memory_t<OpenMP> &m){\n    memInfo = m.memInfo;\n\n    handle    = m.handle;\n    mappedPtr = m.mappedPtr;\n    uvaPtr    = m.uvaPtr;\n\n    dHandle = m.dHandle;\n    size    = m.size;\n\n    textureInfo.arg  = m.textureInfo.arg;\n    textureInfo.dim  = m.textureInfo.dim;\n\n    textureInfo.w = m.textureInfo.w;\n    textureInfo.h = m.textureInfo.h;\n    textureInfo.d = m.textureInfo.d;\n\n    if(isATexture())\n      handle = &textureInfo;\n\n    return *this;\n  }\n\n  template <>\n  memory_t<OpenMP>::~memory_t(){}\n\n  template <>\n  void* memory_t<OpenMP>::getMemoryHandle(){\n    return handle;\n  }\n\n  template <>\n  void* memory_t<OpenMP>::getTextureHandle(){\n    return textureInfo.arg;\n  }\n\n  template <>\n  void memory_t<OpenMP>::copyFrom(const void *src,\n                                  const uintptr_t bytes,\n                                  const uintptr_t offset){\n    dHandle->finish();\n\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + offset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << offset << \" , \" << (offset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (isATexture() ? textureInfo.arg : handle)) + offset;\n    const void *srcPtr = src;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<OpenMP>::copyFrom(const memory_v *src,\n                                  const uintptr_t bytes,\n                                  const uintptr_t destOffset,\n                                  const uintptr_t srcOffset){\n    dHandle->finish();\n\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + destOffset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << destOffset << \" , \" << (destOffset + bytes_) << \" ]\");\n\n    OCCA_CHECK((bytes_ + srcOffset) <= src->size,\n               \"Source has size [\" << src->size << \"],\"\n               << \"trying to access [ \" << srcOffset << \" , \" << (srcOffset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (isATexture()      ? textureInfo.arg      : handle))      + destOffset;\n    const void *srcPtr = ((char*) (src->isATexture() ? src->textureInfo.arg : src->handle)) + srcOffset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<OpenMP>::copyTo(void *dest,\n                                const uintptr_t bytes,\n                                const uintptr_t offset){\n    dHandle->finish();\n\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + offset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << offset << \" , \" << (offset + bytes_) << \" ]\");\n\n    void *destPtr      = dest;\n    const void *srcPtr = ((char*) (isATexture() ? textureInfo.arg : handle)) + offset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<OpenMP>::copyTo(memory_v *dest,\n                                const uintptr_t bytes,\n                                const uintptr_t destOffset,\n                                const uintptr_t srcOffset){\n    dHandle->finish();\n\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + srcOffset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << srcOffset << \" , \" << (srcOffset + bytes_) << \" ]\");\n\n    OCCA_CHECK((bytes_ + destOffset) <= dest->size,\n               \"Destination has size [\" << dest->size << \"],\"\n               << \"trying to access [ \" << destOffset << \" , \" << (destOffset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (dest->isATexture() ? dest->textureInfo.arg : dest->handle)) + destOffset;\n    const void *srcPtr = ((char*) (isATexture() ? textureInfo.arg : handle))       + srcOffset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<OpenMP>::asyncCopyFrom(const void *src,\n                                       const uintptr_t bytes,\n                                       const uintptr_t offset){\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + offset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << offset << \" , \" << (offset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (isATexture() ? textureInfo.arg : handle)) + offset;\n    const void *srcPtr = src;\n\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<OpenMP>::asyncCopyFrom(const memory_v *src,\n                                       const uintptr_t bytes,\n                                       const uintptr_t destOffset,\n                                       const uintptr_t srcOffset){\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + destOffset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << destOffset << \" , \" << (destOffset + bytes_) << \" ]\");\n\n    OCCA_CHECK((bytes_ + srcOffset) <= src->size,\n               \"Source has size [\" << src->size << \"],\"\n               << \"trying to access [ \" << srcOffset << \" , \" << (srcOffset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (isATexture()      ? textureInfo.arg      : handle))      + destOffset;\n    const void *srcPtr = ((char*) (src->isATexture() ? src->textureInfo.arg : src->handle)) + srcOffset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<OpenMP>::asyncCopyTo(void *dest,\n                                     const uintptr_t bytes,\n                                     const uintptr_t offset){\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + offset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << offset << \" , \" << (offset + bytes_) << \" ]\");\n\n    void *destPtr      = dest;\n    const void *srcPtr = ((char*) (isATexture() ? textureInfo.arg : handle)) + offset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<OpenMP>::asyncCopyTo(memory_v *dest,\n                                     const uintptr_t bytes,\n                                     const uintptr_t destOffset,\n                                     const uintptr_t srcOffset){\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + srcOffset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << srcOffset << \" , \" << (srcOffset + bytes_) << \" ]\");\n\n    OCCA_CHECK((bytes_ + destOffset) <= dest->size,\n               \"Destination has size [\" << dest->size << \"],\"\n               << \"trying to access [ \" << destOffset << \" , \" << (destOffset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (dest->isATexture() ? dest->textureInfo.arg : dest->handle)) + destOffset;\n    const void *srcPtr = ((char*) (isATexture() ? textureInfo.arg : handle))       + srcOffset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<OpenMP>::mappedFree(){\n    cpu::free(handle);\n    handle    = NULL;\n    mappedPtr = NULL;\n\n    size = 0;\n  }\n\n  template <>\n  void memory_t<OpenMP>::mappedDetach(){\n    handle    = NULL;\n    mappedPtr = NULL;\n\n    size = 0;\n  }\n\n  template <>\n  void memory_t<OpenMP>::free(){\n    if(isATexture()){\n      cpu::free(textureInfo.arg);\n      textureInfo.arg = NULL;\n    }\n    else{\n      cpu::free(handle);\n      handle = NULL;\n    }\n\n    size = 0;\n  }\n\n  template <>\n  void memory_t<OpenMP>::detach(){\n    if(isATexture()){\n      cpu::free(textureInfo.arg);\n      textureInfo.arg = NULL;\n    }\n    else{\n      handle = NULL;\n    }\n\n    size = 0;\n  }\n  //==================================\n\n\n  //---[ Device ]---------------------\n  template <>\n  device_t<OpenMP>::device_t(){\n    strMode = \"OpenMP\";\n\n    data = NULL;\n\n    uvaEnabled_ = false;\n\n    bytesAllocated = 0;\n\n    getEnvironmentVariables();\n\n    cpu::addSharedBinaryFlagsTo(compiler, compilerFlags);\n  }\n\n  template <>\n  device_t<OpenMP>::device_t(const device_t<OpenMP> &d){\n    *this = d;\n  }\n\n  template <>\n  device_t<OpenMP>& device_t<OpenMP>::operator = (const device_t<OpenMP> &d){\n    modelID_ = d.modelID_;\n    id_      = d.id_;\n\n    data = d.data;\n\n    uvaEnabled_    = d.uvaEnabled_;\n    uvaMap         = d.uvaMap;\n    uvaDirtyMemory = d.uvaDirtyMemory;\n\n    compiler      = d.compiler;\n    compilerFlags = d.compilerFlags;\n\n    bytesAllocated = d.bytesAllocated;\n\n    return *this;\n  }\n\n  template <>\n  void* device_t<OpenMP>::getContextHandle(){\n    return NULL;\n  }\n\n  template <>\n  void device_t<OpenMP>::setup(argInfoMap &aim){\n    properties = aim;\n\n    // Generate an OpenMP library dependency (so it doesn't crash when dlclose())\n    omp_get_num_threads();\n\n    data = new OpenMPDeviceData_t;\n\n    OCCA_EXTRACT_DATA(OpenMP, Device);\n\n    data_.vendor         = cpu::compilerVendor(compiler);\n    data_.OpenMPFlag     = omp::compilerFlag(data_.vendor, compiler);\n    data_.supportsOpenMP = (data_.OpenMPFlag != omp::notSupported);\n\n    cpu::addSharedBinaryFlagsTo(data_.vendor, compilerFlags);\n  }\n\n  template <>\n  void device_t<OpenMP>::addOccaHeadersToInfo(kernelInfo &info_){\n    info_.mode = OpenMP;\n  }\n\n  template <>\n  std::string device_t<OpenMP>::getInfoSalt(const kernelInfo &info_){\n    std::stringstream salt;\n\n    salt << \"OpenMP\"\n         << info_.salt()\n         << parserVersion\n         << compilerEnvScript\n         << compiler\n         << compilerFlags;\n\n    return salt.str();\n  }\n\n  template <>\n  deviceIdentifier device_t<OpenMP>::getIdentifier() const {\n    deviceIdentifier dID;\n\n    dID.mode_ = OpenMP;\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    const bool debugEnabled = (compilerFlags.find(\"-g\") != std::string::npos);\n#else\n    const bool debugEnabled = (compilerFlags.find(\"/Od\") != std::string::npos);\n#endif\n\n    dID.flagMap[\"compiler\"]     = compiler;\n    dID.flagMap[\"debugEnabled\"] = (debugEnabled ? \"true\" : \"false\");\n\n    for(int i = 0; i <= 3; ++i){\n      std::string flag = \"-O\";\n      flag += '0' + i;\n\n      if(compilerFlags.find(flag) != std::string::npos){\n        dID.flagMap[\"optimization\"] = '0' + i;\n        break;\n      }\n\n      if(i == 3)\n        dID.flagMap[\"optimization\"] = \"None\";\n    }\n\n    return dID;\n  }\n\n  template <>\n  void device_t<OpenMP>::getEnvironmentVariables(){\n    char *c_compiler = getenv(\"OCCA_CXX\");\n\n    if(c_compiler != NULL){\n      compiler = std::string(c_compiler);\n    }\n    else{\n      c_compiler = getenv(\"CXX\");\n\n      if(c_compiler != NULL){\n        compiler = std::string(c_compiler);\n      }\n      else{\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n        compiler = \"g++\";\n#else\n        compiler = \"cl.exe\";\n#endif\n      }\n    }\n\n    char *c_compilerFlags = getenv(\"OCCA_CXXFLAGS\");\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    if(c_compilerFlags != NULL)\n      compilerFlags = std::string(c_compilerFlags);\n    else{\n#  if OCCA_DEBUG_ENABLED\n      compilerFlags = \"-g\";\n#  else\n      compilerFlags = \"\";\n#  endif\n    }\n#else\n#  if OCCA_DEBUG_ENABLED\n    compilerFlags = \" /Od /openmp\";\n#  else\n    compilerFlags = \" /O2 /openmp\";\n#  endif\n\n    std::string byteness;\n\n    if(sizeof(void*) == 4)\n      byteness = \"x86 \";\n    else if(sizeof(void*) == 8)\n      byteness = \"amd64\";\n    else\n      OCCA_CHECK(false, \"sizeof(void*) is not equal to 4 or 8\");\n\n#  if      (OCCA_VS_VERSION == 1800)\n    char *visualStudioTools = getenv(\"VS120COMNTOOLS\");   // MSVC++ 12.0 - Visual Studio 2013\n#  elif    (OCCA_VS_VERSION == 1700)\n    char *visualStudioTools = getenv(\"VS110COMNTOOLS\");   // MSVC++ 11.0 - Visual Studio 2012\n#  else // (OCCA_VS_VERSION == 1600)\n    char *visualStudioTools = getenv(\"VS100COMNTOOLS\");   // MSVC++ 10.0 - Visual Studio 2010\n#  endif\n\n    if(visualStudioTools != NULL){\n      setCompilerEnvScript(\"\\\"\" + std::string(visualStudioTools) + \"..\\\\..\\\\VC\\\\vcvarsall.bat\\\" \" + byteness);\n    }\n    else{\n      std::cout << \"WARNING: Visual Studio environment variable not found -> compiler environment (vcvarsall.bat) maybe not correctly setup.\" << std::endl;\n    }\n#endif\n  }\n\n  template <>\n  void device_t<OpenMP>::appendAvailableDevices(std::vector<device> &dList){\n    device d;\n    d.setup(\"OpenMP\", 0, 0);\n\n    dList.push_back(d);\n  }\n\n  template <>\n  void device_t<OpenMP>::setCompiler(const std::string &compiler_){\n    compiler = compiler_;\n\n    OCCA_EXTRACT_DATA(OpenMP, Device);\n\n    data_.vendor         = cpu::compilerVendor(compiler);\n    data_.OpenMPFlag     = omp::compilerFlag(data_.vendor, compiler);\n    data_.supportsOpenMP = (data_.OpenMPFlag != omp::notSupported);\n\n    cpu::addSharedBinaryFlagsTo(data_.vendor, compilerFlags);\n  }\n\n  template <>\n  void device_t<OpenMP>::setCompilerEnvScript(const std::string &compilerEnvScript_){\n    compilerEnvScript = compilerEnvScript_;\n  }\n\n  template <>\n  void device_t<OpenMP>::setCompilerFlags(const std::string &compilerFlags_){\n    OCCA_EXTRACT_DATA(OpenMP, Device);\n\n    compilerFlags = compilerFlags_;\n\n    cpu::addSharedBinaryFlagsTo(data_.vendor, compilerFlags);\n  }\n\n  template <>\n  void device_t<OpenMP>::flush(){}\n\n  template <>\n  void device_t<OpenMP>::finish(){}\n\n  template <>\n  bool device_t<OpenMP>::fakesUva(){\n    return false;\n  }\n\n  template <>\n  void device_t<OpenMP>::waitFor(streamTag tag){}\n\n  template <>\n  stream_t device_t<OpenMP>::createStream(){\n    return NULL;\n  }\n\n  template <>\n  void device_t<OpenMP>::freeStream(stream_t s){}\n\n  template <>\n  stream_t device_t<OpenMP>::wrapStream(void *handle_){\n    return NULL;\n  }\n\n  template <>\n  streamTag device_t<OpenMP>::tagStream(){\n    streamTag ret;\n\n    ret.tagTime = currentTime();\n\n    return ret;\n  }\n\n  template <>\n  double device_t<OpenMP>::timeBetween(const streamTag &startTag, const streamTag &endTag){\n    return (endTag.tagTime - startTag.tagTime);\n  }\n\n  template <>\n  std::string device_t<OpenMP>::fixBinaryName(const std::string &filename){\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    return filename;\n#else\n    return (filename + \".dll\");\n#endif\n  }\n\n  template <>\n  kernel_v* device_t<OpenMP>::buildKernelFromSource(const std::string &filename,\n                                                    const std::string &functionName,\n                                                    const kernelInfo &info_){\n    OCCA_EXTRACT_DATA(OpenMP, Device);\n\n    kernel_v *k;\n\n    if(data_.supportsOpenMP){\n      k = new kernel_t<OpenMP>;\n    }\n    else{\n      std::cout << \"Compiler [\" << compiler << \"] does not support OpenMP, defaulting to [Serial] mode\\n\";\n      k = new kernel_t<Serial>;\n    }\n\n    k->dHandle = this;\n\n    k->buildFromSource(filename, functionName, info_);\n\n    return k;\n  }\n\n  template <>\n  kernel_v* device_t<OpenMP>::buildKernelFromBinary(const std::string &filename,\n                                                    const std::string &functionName){\n    OCCA_EXTRACT_DATA(OpenMP, Device);\n\n    kernel_v *k;\n\n    if(data_.supportsOpenMP){\n      k = new kernel_t<OpenMP>;\n    }\n    else{\n      std::cout << \"Compiler [\" << compiler << \"] does not support OpenMP, defaulting to [Serial] mode\\n\";\n      k = new kernel_t<Serial>;\n    }\n\n    k->dHandle = this;\n\n    k->buildFromBinary(filename, functionName);\n\n    return k;\n  }\n\n  template <>\n  void device_t<OpenMP>::cacheKernelInLibrary(const std::string &filename,\n                                              const std::string &functionName,\n                                              const kernelInfo &info_){\n#if 0\n    //---[ Creating shared library ]----\n    kernel tmpK = occa::device(this).buildKernelFromSource(filename, functionName, info_);\n    tmpK.free();\n\n    kernelInfo info = info_;\n\n    addOccaHeadersToInfo(info);\n\n    std::string cachedBinary = getCachedName(filename, getInfoSalt(info));\n\n#if (OCCA_OS == WINDOWS_OS)\n    // Windows requires .dll extension\n    cachedBinary = cachedBinary + \".dll\";\n#endif\n    //==================================\n\n    library::infoID_t infoID;\n\n    infoID.modelID    = modelID_;\n    infoID.kernelName = functionName;\n\n    library::infoHeader_t &header = library::headerMap[infoID];\n\n    header.fileID = -1;\n    header.mode   = OpenMP;\n\n    const std::string flatDevID = getIdentifier().flattenFlagMap();\n\n    header.flagsOffset = library::addToScratchPad(flatDevID);\n    header.flagsBytes  = flatDevID.size();\n\n    header.contentOffset = library::addToScratchPad(cachedBinary);\n    header.contentBytes  = cachedBinary.size();\n\n    header.kernelNameOffset = library::addToScratchPad(functionName);\n    header.kernelNameBytes  = functionName.size();\n#endif\n  }\n\n  template <>\n  kernel_v* device_t<OpenMP>::loadKernelFromLibrary(const char *cache,\n                                                    const std::string &functionName){\n#if 0\n    kernel_v *k = new kernel_t<OpenMP>;\n    k->dHandle = this;\n    k->loadFromLibrary(cache, functionName);\n    return k;\n#endif\n    return NULL;\n  }\n\n  template <>\n  memory_v* device_t<OpenMP>::wrapMemory(void *handle_,\n                                         const uintptr_t bytes){\n    memory_v *mem = new memory_t<OpenMP>;\n\n    mem->dHandle = this;\n    mem->size    = bytes;\n    mem->handle  = handle_;\n\n    mem->memInfo |= memFlag::isAWrapper;\n\n    return mem;\n  }\n\n  template <>\n  memory_v* device_t<OpenMP>::wrapTexture(void *handle_,\n                                          const int dim, const occa::dim &dims,\n                                          occa::formatType type, const int permissions){\n    memory_v *mem = new memory_t<OpenMP>;\n\n    mem->dHandle = this;\n    mem->size    = ((dim == 1) ? dims.x : (dims.x * dims.y)) * type.bytes();\n\n    mem->memInfo |= (memFlag::isATexture |\n                     memFlag::isAWrapper);\n\n    mem->textureInfo.dim  = dim;\n\n    mem->textureInfo.w = dims.x;\n    mem->textureInfo.h = dims.y;\n    mem->textureInfo.d = dims.z;\n\n    mem->textureInfo.arg = handle_;\n\n    mem->handle = &(mem->textureInfo);\n\n    return mem;\n  }\n\n  template <>\n  memory_v* device_t<OpenMP>::malloc(const uintptr_t bytes,\n                                     void *src){\n    memory_v *mem = new memory_t<OpenMP>;\n\n    mem->dHandle = this;\n    mem->size    = bytes;\n\n    mem->handle = cpu::malloc(bytes);\n\n    if(src != NULL)\n      ::memcpy(mem->handle, src, bytes);\n\n    return mem;\n  }\n\n  template <>\n  memory_v* device_t<OpenMP>::textureAlloc(const int dim, const occa::dim &dims,\n                                           void *src,\n                                           occa::formatType type, const int permissions){\n    memory_v *mem = new memory_t<OpenMP>;\n\n    mem->dHandle = this;\n    mem->size    = ((dim == 1) ? dims.x : (dims.x * dims.y)) * type.bytes();\n\n    mem->memInfo |= memFlag::isATexture;\n\n    mem->textureInfo.dim  = dim;\n\n    mem->textureInfo.w = dims.x;\n    mem->textureInfo.h = dims.y;\n    mem->textureInfo.d = dims.z;\n\n    mem->handle = cpu::malloc(mem->size);\n\n    ::memcpy(mem->textureInfo.arg, src, mem->size);\n\n    mem->handle = &(mem->textureInfo);\n\n    return mem;\n  }\n\n  template <>\n  memory_v* device_t<OpenMP>::mappedAlloc(const uintptr_t bytes,\n                                          void *src){\n    memory_v *mem = malloc(bytes, src);\n\n    mem->mappedPtr = mem->handle;\n\n    return mem;\n  }\n\n  template <>\n  uintptr_t device_t<OpenMP>::memorySize(){\n    return cpu::installedRAM();\n  }\n\n  template <>\n  void device_t<OpenMP>::free(){}\n\n  template <>\n  int device_t<OpenMP>::simdWidth(){\n    simdWidth_ = OCCA_SIMD_WIDTH;\n    return OCCA_SIMD_WIDTH;\n  }\n  //==================================\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-occa-0.2.0-5nxq5eiljk2xvfw3jwwnnapbb2n6t4ub/spack-src/src/Serial.cpp": "#include \"occa/Serial.hpp\"\n\n#include <fstream>\n\n#include <strings.h>\n\nnamespace occa {\n  //---[ Helper Functions ]-----------\n  namespace cpu {\n    std::string getFieldFrom(const std::string &command,\n                             const std::string &field){\n#if (OCCA_OS & LINUX_OS)\n      std::string shellToolsFile = sys::getFilename(\"[occa]/scripts/shellTools.sh\");\n\n      if(!sys::fileExists(shellToolsFile)){\n\t// TODO: enable this when getCachedScript() is defined!!!\n#if 0\n        sys::mkpath(getFileDirectory(shellToolsFile));\n\n        std::ofstream fs2;\n        fs2.open(shellToolsFile.c_str());\n\n        fs2 << getCachedScript(\"shellTools.sh\");\n\n        fs2.close();\n#else\n\treturn \"\";\n#endif\n      }\n\n      std::stringstream ss;\n\n      ss << \"echo \\\"(. \" << shellToolsFile << \"; \" << command << \" '\" << field << \"')\\\" | bash\";\n\n      std::string sCommand = ss.str();\n\n      FILE *fp;\n      fp = popen(sCommand.c_str(), \"r\");\n\n      const int bufferSize = 4096;\n      char *buffer = new char[bufferSize];\n\n      ignoreResult( fread(buffer, sizeof(char), bufferSize, fp) );\n\n      pclose(fp);\n\n      int end;\n\n      for(end = 0; end < bufferSize; ++end){\n        if(buffer[end] == '\\n')\n          break;\n      }\n\n      std::string ret(buffer, end);\n\n      delete [] buffer;\n\n      return ret;\n#else\n      return \"\";\n#endif\n    }\n\n    std::string getField(const std::string &shell_cmd,\n\t\t\t const std::string &field,\n\t\t\t bool ignoreCase,\n\t\t\t char delimiter){\n      // popen(), fgets(). strncasecmp() and isspace() are\n      // all available on Linux, BSD/OSX, CygWin and MinGW,\n      // assuming we're not compiling __STRICT_ANSI__\n#if (OCCA_OS & (LINUX_OS | WINUX_OS | OSX_OS))\n      FILE *fp;\n      fp = popen(shell_cmd.c_str(), \"r\");\n\n      const int bufferSize = 4096;\n      char *buffer = new char[bufferSize];\n\n      int field_len = field.size();\n\n      const char *field_str = field.c_str();\n      char *ptr;\n      char *str;\n\n      std::string ret = \"\";\n\n      while(fgets(buffer,bufferSize,fp)) {\n\t// find line that matches \"^[WS}*field[WS]*:\"\n\tstr = buffer;\n\twhile(*str && isspace(*str)) {\n\t  ++str;\n\t}\n\tif (!*str) {\n\t  continue;\n\t}\n\tif (ignoreCase ?\n\t    strncasecmp(str,field_str,field_len) :\n\t    strncmp(str,field_str,field_len)) {\n\t  continue;\n\t}\n\tptr = str + field_len;\n\twhile(*ptr && isspace(*ptr)) {\n\t  ++ptr;\n\t}\n\tif (*ptr != delimiter) {\n\t  continue;\n\t}\n\n\t// line found, now get value after clipping surrounding\n\t// whitespace, per \"[WS]*value[WS]*$\"\n\t++ptr;\n\twhile(*ptr && isspace(*ptr)) {\n\t  ++ptr;\n\t}\n\tstr = ptr;\n\t// clip trailing whitespace\n\tif (*str) {\n\t  while(*ptr) {\n\t    ++ptr;\n\t  }\n\t  --ptr;  // now points to last char in string\n\t  while(ptr != str  &&  isspace(*ptr)) {\n\t    *ptr-- = '\\0';\n\t  }\n\t}\n\n\t// done\n\tret = str;\n\tbreak;\n      }\n\n      pclose(fp);\n\n      delete [] buffer;\n\n      return ret;\n#else\n      return \"\";\n#endif\n    }\n\n    std::string getCPUINFOField(const std::string &field,\n\t\t\t\tbool ignoreCase){\n#if (OCCA_OS & LINUX_OS)\n      return getField(\"cat /proc/cpuinfo\", field, ignoreCase, ':');\n#else\n      return \"\";\n#endif\n    }\n\n    std::string getProcessorName(){\n#if   (OCCA_OS & LINUX_OS)\n//    return getFieldFrom(\"getCPUINFOField\", \"model name\");\n      return getCPUINFOField(\"model name\");\n#elif (OCCA_OS == OSX_OS)\n      size_t bufferSize = 100;\n      char buffer[100];\n\n      sysctlbyname(\"machdep.cpu.brand_string\",\n                   &buffer, &bufferSize,\n                   NULL, 0);\n\n      return std::string(buffer);\n#elif (OCCA_OS == WINDOWS_OS)\n      char buffer[MAX_COMPUTERNAME_LENGTH + 1];\n      int bytes;\n\n      GetComputerName((LPSTR) buffer, (LPDWORD) &bytes);\n\n      return std::string(buffer, bytes);\n#endif\n    }\n\n    int getCoreCount(){\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n      return sysconf(_SC_NPROCESSORS_ONLN);\n#elif (OCCA_OS == WINDOWS_OS)\n      SYSTEM_INFO sysinfo;\n      GetSystemInfo(&sysinfo);\n      return sysinfo.dwNumberOfProcessors;\n#endif\n    }\n\n    int getProcessorFrequency(){\n#if   (OCCA_OS & LINUX_OS)\n      std::stringstream ss;\n      int freq;\n\n//    ss << getFieldFrom(\"getCPUINFOField\", \"cpu MHz\");\n      ss << getCPUINFOField(\"cpu MHz\");\n\n      ss >> freq;\n\n      return freq;\n#elif (OCCA_OS == OSX_OS)\n      uint64_t frequency = 0;\n      size_t size = sizeof(frequency);\n\n      int error = sysctlbyname(\"hw.cpufrequency\", &frequency, &size, NULL, 0);\n\n      OCCA_CHECK(error != ENOMEM,\n                 \"Error getting CPU Frequency.\\n\");\n\n      return frequency/1.0e6;\n#elif (OCCA_OS == WINDOWS_OS)\n      LARGE_INTEGER performanceFrequency;\n      QueryPerformanceFrequency(&performanceFrequency);\n\n      return (int) (((double) performanceFrequency.QuadPart) / 1000.0);\n#endif\n    }\n\n    std::string getProcessorCacheSize(int level){\n#if   (OCCA_OS & LINUX_OS)\n      std::stringstream field;\n\n      field << 'L' << level;\n\n      if(level == 1)\n        field << 'd';\n\n      field << \" cache\";\n\n//    return getFieldFrom(\"getLSCPUField\", field.str());\n      return getField(\"lscpu\", field.str(), false, ':');\n#elif (OCCA_OS == OSX_OS)\n      std::stringstream ss;\n      ss << \"hw.l\" << level;\n\n      if(level == 1)\n        ss << 'd';\n\n      ss << \"cachesize\";\n\n      std::string field = ss.str();\n\n      uint64_t cache = 0;\n      size_t size = sizeof(cache);\n\n      int error = sysctlbyname(field.c_str(), &cache, &size, NULL, 0);\n\n      OCCA_CHECK(error != ENOMEM,\n                 \"Error getting L\" << level << \" Cache Size.\\n\");\n\n      return stringifyBytes(cache);\n#elif (OCCA_OS == WINDOWS_OS)\n      std::stringstream ss;\n      DWORD cache = 0;\n      int bytes = 0;\n\n      PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer = NULL;\n\n      GetLogicalProcessorInformation(buffer, (LPDWORD) &bytes);\n\n      OCCA_CHECK((GetLastError() == ERROR_INSUFFICIENT_BUFFER),\n                 \"[GetLogicalProcessorInformation] Failed\");\n\n      buffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION) cpu::malloc(bytes);\n\n      bool passed = GetLogicalProcessorInformation(buffer, (LPDWORD) &bytes);\n\n      OCCA_CHECK(passed,\n                 \"[GetLogicalProcessorInformation] Failed\");\n\n      PSYSTEM_LOGICAL_PROCESSOR_INFORMATION pos = buffer;\n      int off = 0;\n      int sk = sizeof(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION);\n\n      while ((off + sk) <= bytes) {\n        switch(pos->Relationship){\n        case RelationCache:{\n          CACHE_DESCRIPTOR info = pos->Cache;\n\n          if (info.Level == level) {\n            cache = info.Size;\n            break;\n          }\n        }\n        }\n        ++pos;\n        off += sk;\n      }\n\n      cpu::free(buffer);\n\n      return stringifyBytes(cache);\n#endif\n    }\n\n    uintptr_t installedRAM(){\n#if   (OCCA_OS & LINUX_OS)\n      struct sysinfo info;\n\n      const int error = sysinfo(&info);\n\n      if(error != 0)\n        return 0;\n\n      return info.totalram;\n#elif (OCCA_OS == OSX_OS)\n      int64_t ram;\n\n      int mib[2]   = {CTL_HW, HW_MEMSIZE};\n      size_t bytes = sizeof(ram);\n\n      sysctl(mib, 2, &ram, &bytes, NULL, 0);\n\n      return ram;\n#elif (OCCA_OS == WINDOWS_OS)\n      return 0;\n#endif\n    }\n\n    uintptr_t availableRAM(){\n#if   (OCCA_OS & LINUX_OS)\n      struct sysinfo info;\n\n      const int error = sysinfo(&info);\n\n      if(error != 0)\n        return 0;\n\n      return info.freeram;\n#elif (OCCA_OS == OSX_OS)\n      mach_msg_type_number_t infoCount = HOST_VM_INFO_COUNT;\n      mach_port_t hostPort = mach_host_self();\n\n      vm_statistics_data_t hostInfo;\n      kern_return_t status;\n      vm_size_t pageSize;\n\n      status = host_page_size(hostPort, &pageSize);\n\n      if(status != KERN_SUCCESS)\n        return 0;\n\n      status = host_statistics(hostPort,\n                               HOST_VM_INFO,\n                               (host_info_t) &hostInfo,\n                               &infoCount);\n\n      if(status != KERN_SUCCESS)\n        return 0;\n\n      return (hostInfo.free_count * pageSize);\n#elif (OCCA_OS == WINDOWS_OS)\n      return 0;\n#endif\n    }\n\n    std::string getDeviceListInfo(){\n      std::stringstream ss, ssFreq;\n\n      ss << getCoreCount();\n\n      uintptr_t ram      = installedRAM();\n      std::string ramStr = stringifyBytes(ram);\n\n      const int freq = getProcessorFrequency();\n\n      if(freq < 1000)\n        ssFreq << freq << \" MHz\";\n      else\n        ssFreq << (freq/1000.0) << \" GHz\";\n\n      std::string l1 = getProcessorCacheSize(1);\n      std::string l2 = getProcessorCacheSize(2);\n      std::string l3 = getProcessorCacheSize(3);\n\n      size_t maxSize = ((l1.size() < l2.size()) ? l2.size() : l1.size());\n      maxSize        = ((maxSize   < l3.size()) ? l3.size() : maxSize  );\n\n      if(maxSize){\n        l1 = std::string(maxSize - l1.size(), ' ') + l1;\n        l2 = std::string(maxSize - l2.size(), ' ') + l2;\n        l3 = std::string(maxSize - l3.size(), ' ') + l3;\n      }\n\n      std::string tab[2];\n      tab[0] = \"   CPU Info   \";\n      tab[1] = \"              \";\n\n      std::string processorName  = getProcessorName();\n      std::string clockFrequency = ssFreq.str();\n      std::string coreCount      = ss.str();\n\n      ss.str(\"\");\n\n      // [P]rinted [S]omething\n      bool ps = false;\n\n      // << \"==============o=======================o==========================================\\n\";\n      if(processorName.size())\n        ss << tab[ps]  << \"|  Processor Name       | \" << processorName                   << '\\n'; ps = true;\n      if(coreCount.size())\n        ss << tab[ps]  << \"|  Cores                | \" << coreCount                       << '\\n'; ps = true;\n      if(ramStr.size())\n        ss << tab[ps]  << \"|  Memory (RAM)         | \" << ramStr                          << '\\n'; ps = true;\n      if(clockFrequency.size())\n        ss << tab[ps]  << \"|  Clock Frequency      | \" << clockFrequency                  << '\\n'; ps = true;\n      ss   << tab[ps]  << \"|  SIMD Instruction Set | \" << OCCA_VECTOR_SET                 << '\\n'\n           << tab[ps]  << \"|  SIMD Width           | \" << (32*OCCA_SIMD_WIDTH) << \" bits\" << '\\n'; ps = true;\n      if(l1.size())\n        ss << tab[ps]  << \"|  L1 Cache Size (d)    | \" << l1                              << '\\n'; ps = true;\n      if(l2.size())\n        ss << tab[ps]  << \"|  L2 Cache Size        | \" << l2                              << '\\n'; ps = true;\n      if(l3.size())\n        ss << tab[ps]  << \"|  L3 Cache Size        | \" << l3                              << '\\n';\n      // << \"==============o=======================o==========================================\\n\";\n\n      return ss.str();\n    }\n\n    int compilerVendor(const std::string &compiler){\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n      std::stringstream ss;\n      int vendor_ = cpu::vendor::notFound;\n\n      const std::string safeCompiler = removeSlashes(compiler);\n      const std::string &hash = safeCompiler;\n\n      const std::string testFilename   = sys::getFilename(\"[occa]/testing/compilerVendorTest.cpp\");\n      const std::string binaryFilename = sys::getFilename(\"[occa]/testing/compilerVendor_\" + safeCompiler);\n      const std::string infoFilename   = sys::getFilename(\"[occa]/testing/compilerVendorInfo_\" + safeCompiler);\n\n      cacheFile(testFilename,\n                readFile(env::OCCA_DIR + \"/scripts/compilerVendorTest.cpp\"),\n                \"compilerVendorTest\");\n\n      if(!haveHash(hash)){\n        waitForHash(hash);\n      } else {\n        if(!sys::fileExists(infoFilename)){\n          ss << compiler\n             << ' '\n             << testFilename\n             << \" -o \"\n             << binaryFilename\n             << \" > /dev/null 2>&1\";\n\n          const int compileError = system(ss.str().c_str());\n\n          if(!compileError){\n            int exitStatus = system(binaryFilename.c_str());\n            int vendorBit  = WEXITSTATUS(exitStatus);\n\n            if(vendorBit < cpu::vendor::b_max)\n              vendor_ = (1 << vendorBit);\n          }\n\n          ss.str(\"\");\n          ss << vendor_;\n\n          writeToFile(infoFilename, ss.str());\n          releaseHash(hash);\n\n          return vendor_;\n        }\n        releaseHash(hash);\n      }\n\n      ss << readFile(infoFilename);\n      ss >> vendor_;\n\n      return vendor_;\n\n#elif (OCCA_OS == WINDOWS_OS)\n#  if OCCA_USING_VS\n      return cpu::vendor::VisualStudio;\n#  endif\n\n      if(compiler.find(\"cl.exe\") != std::string::npos){\n        return cpu::vendor::VisualStudio;\n      }\n#endif\n    }\n\n    std::string compilerSharedBinaryFlags(const std::string &compiler){\n      return compilerSharedBinaryFlags( cpu::compilerVendor(compiler) );\n    }\n\n    std::string compilerSharedBinaryFlags(const int vendor_){\n      if(vendor_ & (cpu::vendor::GNU   |\n                    cpu::vendor::LLVM  |\n                    cpu::vendor::Intel |\n                    cpu::vendor::IBM   |\n                    cpu::vendor::PGI   |\n                    cpu::vendor::Cray  |\n                    cpu::vendor::Pathscale)){\n\n        return \"-x c++ -fPIC -shared\"; // [-] -x c++ for now\n      }\n      else if(vendor_ & cpu::vendor::HP){\n        return \"+z -b\";\n      }\n      else if(vendor_ & cpu::vendor::VisualStudio){\n#if OCCA_DEBUG_ENABLED\n        return \"/TP /LD /MDd\";\n#else\n        return \"/TP /LD /MD\";\n#endif\n      }\n\n      return \"\";\n    }\n\n    void addSharedBinaryFlagsTo(const std::string &compiler, std::string &flags){\n      addSharedBinaryFlagsTo(cpu::compilerVendor(compiler), flags);\n    }\n\n    void addSharedBinaryFlagsTo(const int vendor_, std::string &flags){\n      std::string sFlags = cpu::compilerSharedBinaryFlags(vendor_);\n\n      if(flags.size() == 0)\n        flags = sFlags;\n\n      if(flags.find(sFlags) == std::string::npos)\n        flags = (sFlags + \" \" + flags);\n    }\n\n    void* malloc(uintptr_t bytes){\n      void* ptr;\n\n#if   (OCCA_OS & (LINUX_OS | OSX_OS))\n      ignoreResult( posix_memalign(&ptr, env::OCCA_MEM_BYTE_ALIGN, bytes) );\n#elif (OCCA_OS == WINDOWS_OS)\n      ptr = ::malloc(bytes);\n#endif\n\n      return ptr;\n    }\n\n    void free(void *ptr){\n      ::free(ptr);\n    }\n\n    void* dlopen(const std::string &filename,\n                 const std::string &hash){\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n      void *dlHandle = ::dlopen(filename.c_str(), RTLD_NOW);\n\n      if((dlHandle == NULL) && (0 < hash.size())){\n        releaseHash(hash, 0);\n\n        OCCA_CHECK(false,\n                   \"Error loading binary [\" << compressFilename(filename) << \"] with dlopen\");\n      }\n#else\n      void *dlHandle = LoadLibraryA(filename.c_str());\n\n      if((dlHandle == NULL) && (0 < hash.size())){\n        releaseHash(hash, 0);\n\n        OCCA_CHECK(dlHandle != NULL,\n                   \"Error loading dll [\" << compressFilename(filename) << \"] (WIN32 error: \" << GetLastError() << \")\");\n      }\n#endif\n\n      return dlHandle;\n    }\n\n    handleFunction_t dlsym(void *dlHandle,\n                           const std::string &functionName,\n                           const std::string &hash){\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n      void *sym = ::dlsym(dlHandle, functionName.c_str());\n\n      char *dlError;\n\n      if(((dlError = dlerror()) != NULL) && (0 < hash.size())){\n        releaseHash(hash, 0);\n\n        OCCA_CHECK(false,\n                   \"Error loading symbol from binary with dlsym (DL Error: \" << dlError << \")\");\n      }\n#else\n      void *sym = GetProcAddress((HMODULE) dlHandle, functionName.c_str());\n\n      if((sym == NULL) && (0 < hash.size())){\n\n        OCCA_CHECK(false,\n                   \"Error loading symbol from binary with GetProcAddress\");\n      }\n#endif\n\n      handleFunction_t sym2;\n\n      ::memcpy(&sym2, &sym, sizeof(sym));\n\n      return sym2;\n    }\n\n    void runFunction(handleFunction_t f,\n                     const int *occaKernelInfoArgs,\n                     int occaInnerId0, int occaInnerId1, int occaInnerId2,\n                     int argc, void **args){\n\n#include \"operators/runFunctionFromArguments.cpp\"\n    }\n  }\n  //==================================\n\n\n  //---[ Kernel ]---------------------\n  template <>\n  kernel_t<Serial>::kernel_t(){\n    strMode = \"Serial\";\n    name = \"\";\n    sourceFilename = \"\";\n    binaryFilename = \"\";\n\n    data    = NULL;\n    dHandle = NULL;\n\n    dims  = 1;\n    inner = occa::dim(1,1,1);\n    outer = occa::dim(1,1,1);\n  }\n\n  template <>\n  kernel_t<Serial>::kernel_t(const kernel_t<Serial> &k){\n    *this = k;\n  }\n\n  template <>\n  kernel_t<Serial>& kernel_t<Serial>::operator = (const kernel_t<Serial> &k){\n    data    = k.data;\n    dHandle = k.dHandle;\n\n    metaInfo = k.metaInfo;\n\n    dims  = k.dims;\n    inner = k.inner;\n    outer = k.outer;\n\n    nestedKernels = k.nestedKernels;\n\n    return *this;\n  }\n\n  template <>\n  kernel_t<Serial>::~kernel_t(){}\n\n  template <>\n  void* kernel_t<Serial>::getKernelHandle(){\n    OCCA_EXTRACT_DATA(Serial, Kernel);\n\n    void *ret;\n\n    ::memcpy(&ret, &data_.handle, sizeof(void*));\n\n    return ret;\n  }\n\n  template <>\n  void* kernel_t<Serial>::getProgramHandle(){\n    OCCA_EXTRACT_DATA(Serial, Kernel);\n\n    return data_.dlHandle;\n  }\n\n  template <>\n  std::string kernel_t<Serial>::fixBinaryName(const std::string &filename){\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    return filename;\n#else\n    return (filename + \".dll\");\n#endif\n  }\n\n  template <>\n  kernel_t<Serial>* kernel_t<Serial>::buildFromSource(const std::string &filename,\n                                                      const std::string &functionName,\n                                                      const kernelInfo &info_){\n\n    name = functionName;\n\n    kernelInfo info = info_;\n\n    dHandle->addOccaHeadersToInfo(info);\n\n    const std::string hash = getFileContentHash(filename,\n                                                dHandle->getInfoSalt(info));\n\n    const std::string hashDir    = hashDirFor(filename, hash);\n    sourceFilename = hashDir + kc::sourceFile;\n    binaryFilename = hashDir + fixBinaryName(kc::binaryFile);\n    bool foundBinary = true;\n\n    if (!haveHash(hash, 0))\n      waitForHash(hash, 0);\n    else if (sys::fileExists(binaryFilename))\n      releaseHash(hash, 0);\n    else\n      foundBinary = false;\n\n    if (foundBinary) {\n      if(verboseCompilation_f)\n        std::cout << \"Found cached binary of [\" << compressFilename(filename) << \"] in [\" << compressFilename(binaryFilename) << \"]\\n\";\n\n      return buildFromBinary(binaryFilename, functionName);\n    }\n\n    data = new SerialKernelData_t;\n\n    createSourceFileFrom(filename, hashDir, info);\n\n    std::stringstream command;\n\n    if(dHandle->compilerEnvScript.size())\n      command << dHandle->compilerEnvScript << \" && \";\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    command << dHandle->compiler\n            << ' '    << dHandle->compilerFlags\n            << ' '    << info.flags\n            << ' '    << sourceFilename\n            << \" -o \" << binaryFilename\n            << \" -I\"  << env::OCCA_DIR << \"/include\"\n            << \" -L\"  << env::OCCA_DIR << \"/lib -locca\"\n            << std::endl;\n#else\n#  if (OCCA_DEBUG_ENABLED)\n    const std::string occaLib = env::OCCA_DIR + \"/lib/libocca_d.lib \";\n#  else\n    const std::string occaLib = env::OCCA_DIR + \"/lib/libocca.lib \";\n#  endif\n\n#  if OCCA_CUDA_ENABLED\n    const std::string cupath = getenv(\"CUDA_PATH\");\n    const std::string cuInc  = cupath + \"\\\\include\";\n    const std::string cuLib  = cupath + \"\\\\lib\\\\x64\\\\cuda.lib \";\n#  endif\n#  if OCCA_OPENCL_ENABLED\n    const std::string clpath = getenv(\"OPENCL_PATH\");\n    const std::string clLib  = cpath + \"\\\\lib\\\\x64\\\\OpenCL.lib \";\n#  endif\n\n    command << dHandle->compiler\n            << \" /D MC_CL_EXE\"\n            << \" /D OCCA_OS=WINDOWS_OS\"\n            << \" /EHsc\"\n            << \" /wd4244 /wd4800 /wd4804 /wd4018\"\n            << ' '    << dHandle->compilerFlags\n            << ' '    << info.flags\n            << \" /I\"  << env::OCCA_DIR << \"/include\"\n#  if OCCA_CUDA_ENABLED\n            << \" /I\"  << cuInc\n#  endif\n#  if OCCA_OPENCL_ENABLED\n            << \" /I\"  << clInc\n#  endif\n            << ' '    << sourceFilename\n            << \" /link \" << occaLib\n#  if OCCA_CUDA_ENABLED\n            << \" /link\"  << cuLib\n#  endif\n#  if OCCA_OPENCL_ENABLED\n            << \" /link\"  << clLib\n#  endif\n            << \" /OUT:\" << binaryFilename\n            << std::endl;\n#endif\n\n    const std::string &sCommand = command.str();\n\n    if(verboseCompilation_f)\n      std::cout << \"Compiling [\" << functionName << \"]\\n\" << sCommand << \"\\n\";\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    const int compileError = system(sCommand.c_str());\n#else\n    const int compileError = system((\"\\\"\" +  sCommand + \"\\\"\").c_str());\n#endif\n\n    if(compileError){\n      releaseHash(hash, 0);\n      OCCA_CHECK(false, \"Compilation error\");\n    }\n\n    OCCA_EXTRACT_DATA(Serial, Kernel);\n\n    data_.dlHandle = cpu::dlopen(binaryFilename, hash);\n    data_.handle   = cpu::dlsym(data_.dlHandle, functionName, hash);\n\n    releaseHash(hash, 0);\n\n    return this;\n  }\n\n  template <>\n  kernel_t<Serial>* kernel_t<Serial>::buildFromBinary(const std::string &filename,\n                                                      const std::string &functionName){\n\n    name = functionName;\n    binaryFilename = filename;\n\n    data = new SerialKernelData_t;\n\n    OCCA_EXTRACT_DATA(Serial, Kernel);\n\n    data_.dlHandle = cpu::dlopen(filename);\n    data_.handle   = cpu::dlsym(data_.dlHandle, functionName);\n\n    return this;\n  }\n\n  template <>\n  kernel_t<Serial>* kernel_t<Serial>::loadFromLibrary(const char *cache,\n                                                      const std::string &functionName){\n    name = functionName;\n\n    return buildFromBinary(cache, functionName);\n  }\n\n  template <>\n  uintptr_t kernel_t<Serial>::maximumInnerDimSize(){\n    return ((uintptr_t) -1);\n  }\n\n  // [-] Missing\n  template <>\n  int kernel_t<Serial>::preferredDimSize(){\n    preferredDimSize_ = OCCA_SIMD_WIDTH;\n    return OCCA_SIMD_WIDTH;\n  }\n\n  template <>\n  void kernel_t<Serial>::runFromArguments(const int kArgc, const kernelArg *kArgs){\n    SerialKernelData_t &data_ = *((SerialKernelData_t*) data);\n    handleFunction_t tmpKernel = (handleFunction_t) data_.handle;\n    int occaKernelArgs[6];\n\n    occaKernelArgs[0] = outer.z; occaKernelArgs[3] = inner.z;\n    occaKernelArgs[1] = outer.y; occaKernelArgs[4] = inner.y;\n    occaKernelArgs[2] = outer.x; occaKernelArgs[5] = inner.x;\n\n    int argc = 0;\n    for(int i = 0; i < kArgc; ++i){\n      for(int j = 0; j < kArgs[i].argc; ++j){\n        data_.vArgs[argc++] = kArgs[i].args[j].ptr();\n      }\n    }\n\n    int occaInnerId0 = 0, occaInnerId1 = 0, occaInnerId2 = 0;\n\n    cpu::runFunction(tmpKernel,\n                     occaKernelArgs,\n                     occaInnerId0, occaInnerId1, occaInnerId2,\n                     argc, data_.vArgs);\n  }\n\n  template <>\n  void kernel_t<Serial>::free(){\n    OCCA_EXTRACT_DATA(Serial, Kernel);\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    dlclose(data_.dlHandle);\n#else\n    FreeLibrary((HMODULE) (data_.dlHandle));\n#endif\n  }\n  //==================================\n\n\n  //---[ Memory ]---------------------\n  template <>\n  memory_t<Serial>::memory_t(){\n    strMode = \"Serial\";\n\n    memInfo = memFlag::none;\n\n    handle    = NULL;\n    mappedPtr = NULL;\n    uvaPtr    = NULL;\n\n    dHandle = NULL;\n    size    = 0;\n\n    textureInfo.arg = NULL;\n    textureInfo.dim = 1;\n    textureInfo.w = textureInfo.h = textureInfo.d = 0;\n  }\n\n  template <>\n  memory_t<Serial>::memory_t(const memory_t<Serial> &m){\n    *this = m;\n  }\n\n  template <>\n  memory_t<Serial>& memory_t<Serial>::operator = (const memory_t<Serial> &m){\n    memInfo = m.memInfo;\n\n    handle    = m.handle;\n    mappedPtr = m.mappedPtr;\n    uvaPtr    = m.uvaPtr;\n\n    dHandle = m.dHandle;\n    size    = m.size;\n\n    textureInfo.arg  = m.textureInfo.arg;\n    textureInfo.dim  = m.textureInfo.dim;\n\n    textureInfo.w = m.textureInfo.w;\n    textureInfo.h = m.textureInfo.h;\n    textureInfo.d = m.textureInfo.d;\n\n    if(isATexture())\n      handle = &textureInfo;\n\n    return *this;\n  }\n\n  template <>\n  memory_t<Serial>::~memory_t(){}\n\n  template <>\n  void* memory_t<Serial>::getMemoryHandle(){\n    return handle;\n  }\n\n  template <>\n  void* memory_t<Serial>::getTextureHandle(){\n    return textureInfo.arg;\n  }\n\n  template <>\n  void memory_t<Serial>::copyFrom(const void *src,\n                                  const uintptr_t bytes,\n                                  const uintptr_t offset){\n    dHandle->finish();\n\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + offset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << offset << \" , \" << (offset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (isATexture() ? textureInfo.arg : handle)) + offset;\n    const void *srcPtr = src;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Serial>::copyFrom(const memory_v *src,\n                                  const uintptr_t bytes,\n                                  const uintptr_t destOffset,\n                                  const uintptr_t srcOffset){\n    dHandle->finish();\n\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + destOffset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << destOffset << \" , \" << (destOffset + bytes_) << \" ]\");\n\n    OCCA_CHECK((bytes_ + srcOffset) <= src->size,\n               \"Source has size [\" << src->size << \"],\"\n               << \"trying to access [ \" << srcOffset << \" , \" << (srcOffset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (isATexture()      ? textureInfo.arg      : handle))      + destOffset;\n    const void *srcPtr = ((char*) (src->isATexture() ? src->textureInfo.arg : src->handle)) + srcOffset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Serial>::copyTo(void *dest,\n                                const uintptr_t bytes,\n                                const uintptr_t offset){\n    dHandle->finish();\n\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + offset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << offset << \" , \" << (offset + bytes_) << \" ]\");\n\n    void *destPtr      = dest;\n    const void *srcPtr = ((char*) (isATexture() ? textureInfo.arg : handle)) + offset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Serial>::copyTo(memory_v *dest,\n                                const uintptr_t bytes,\n                                const uintptr_t destOffset,\n                                const uintptr_t srcOffset){\n    dHandle->finish();\n\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + srcOffset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << srcOffset << \" , \" << (srcOffset + bytes_) << \" ]\");\n\n    OCCA_CHECK((bytes_ + destOffset) <= dest->size,\n               \"Destination has size [\" << dest->size << \"],\"\n               << \"trying to access [ \" << destOffset << \" , \" << (destOffset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (dest->isATexture() ? dest->textureInfo.arg : dest->handle)) + destOffset;\n    const void *srcPtr = ((char*) (isATexture()       ? textureInfo.arg       : handle))       + srcOffset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Serial>::asyncCopyFrom(const void *src,\n                                       const uintptr_t bytes,\n                                       const uintptr_t offset){\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + offset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << offset << \" , \" << (offset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (isATexture() ? textureInfo.arg : handle)) + offset;\n    const void *srcPtr = src;\n\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Serial>::asyncCopyFrom(const memory_v *src,\n                                       const uintptr_t bytes,\n                                       const uintptr_t destOffset,\n                                       const uintptr_t srcOffset){\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + destOffset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << destOffset << \" , \" << (destOffset + bytes_) << \" ]\");\n\n    OCCA_CHECK((bytes_ + srcOffset) <= src->size,\n               \"Source has size [\" << src->size << \"],\"\n               << \"trying to access [ \" << srcOffset << \" , \" << (srcOffset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (isATexture()      ? textureInfo.arg      : handle))         + destOffset;\n    const void *srcPtr = ((char*) (src->isATexture() ? src->textureInfo.arg : src->handle)) + srcOffset;;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Serial>::asyncCopyTo(void *dest,\n                                     const uintptr_t bytes,\n                                     const uintptr_t offset){\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + offset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << offset << \" , \" << (offset + bytes_) << \" ]\");\n\n    void *destPtr      = dest;\n    const void *srcPtr = ((char*) (isATexture() ? textureInfo.arg : handle)) + offset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Serial>::asyncCopyTo(memory_v *dest,\n                                     const uintptr_t bytes,\n                                     const uintptr_t destOffset,\n                                     const uintptr_t srcOffset){\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + srcOffset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << srcOffset << \" , \" << (srcOffset + bytes_) << \" ]\");\n\n    OCCA_CHECK((bytes_ + destOffset) <= dest->size,\n               \"Destination has size [\" << dest->size << \"],\"\n               << \"trying to access [ \" << destOffset << \" , \" << (destOffset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (dest->isATexture() ? dest->textureInfo.arg : dest->handle)) + destOffset;\n    const void *srcPtr = ((char*) (isATexture()       ? textureInfo.arg       : handle))       + srcOffset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Serial>::mappedFree(){\n    cpu::free(handle);\n    handle    = NULL;\n    mappedPtr = NULL;\n\n    size = 0;\n  }\n\n  template <>\n  void memory_t<Serial>::mappedDetach(){\n    handle    = NULL;\n    mappedPtr = NULL;\n\n    size = 0;\n  }\n\n  template <>\n  void memory_t<Serial>::free(){\n    if(isATexture()){\n      cpu::free(textureInfo.arg);\n      textureInfo.arg = NULL;\n    }\n    else{\n      cpu::free(handle);\n      handle = NULL;\n    }\n\n    size = 0;\n  }\n\n  template <>\n  void memory_t<Serial>::detach(){\n    if(isATexture()){\n      textureInfo.arg = NULL;\n    }\n    else{\n      handle = NULL;\n    }\n\n    size = 0;\n  }\n  //==================================\n\n\n  //---[ Device ]---------------------\n  template <>\n  device_t<Serial>::device_t(){\n    strMode = \"Serial\";\n\n    data = NULL;\n    uvaEnabled_ = false;\n    bytesAllocated = 0;\n\n    getEnvironmentVariables();\n\n    cpu::addSharedBinaryFlagsTo(compiler, compilerFlags);\n  }\n\n  template <>\n  device_t<Serial>::device_t(const device_t<Serial> &d){\n    *this = d;\n  }\n\n  template <>\n  device_t<Serial>& device_t<Serial>::operator = (const device_t<Serial> &d){\n    modelID_ = d.modelID_;\n    id_      = d.id_;\n\n    data = d.data;\n\n    uvaEnabled_    = d.uvaEnabled_;\n    uvaMap         = d.uvaMap;\n    uvaDirtyMemory = d.uvaDirtyMemory;\n\n    compiler      = d.compiler;\n    compilerFlags = d.compilerFlags;\n\n    bytesAllocated = d.bytesAllocated;\n\n    return *this;\n  }\n\n  template <>\n  void* device_t<Serial>::getContextHandle(){\n    return NULL;\n  }\n\n  template <>\n  void device_t<Serial>::setup(argInfoMap &aim){\n    properties = aim;\n\n    data = new SerialDeviceData_t;\n\n    OCCA_EXTRACT_DATA(Serial, Device);\n\n    data_.vendor = cpu::compilerVendor(compiler);\n\n    cpu::addSharedBinaryFlagsTo(data_.vendor, compilerFlags);\n  }\n\n  template <>\n  void device_t<Serial>::addOccaHeadersToInfo(kernelInfo &info_){\n    info_.mode = Serial;\n  }\n\n  template <>\n  std::string device_t<Serial>::getInfoSalt(const kernelInfo &info_){\n    std::stringstream salt;\n\n    salt << \"Serial\"\n         << info_.salt()\n         << parserVersion\n         << compilerEnvScript\n         << compiler\n         << compilerFlags;\n\n    return salt.str();\n  }\n\n  template <>\n  deviceIdentifier device_t<Serial>::getIdentifier() const {\n    deviceIdentifier dID;\n\n    dID.mode_ = Serial;\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    const bool debugEnabled = (compilerFlags.find(\"-g\") != std::string::npos);\n#else\n    const bool debugEnabled = (compilerFlags.find(\"/Od\") != std::string::npos);\n#endif\n\n    dID.flagMap[\"compiler\"]     = compiler;\n    dID.flagMap[\"debugEnabled\"] = (debugEnabled ? \"true\" : \"false\");\n\n    for(int i = 0; i <= 3; ++i){\n      std::string flag = \"-O\";\n      flag += '0' + i;\n\n      if(compilerFlags.find(flag) != std::string::npos){\n        dID.flagMap[\"optimization\"] = '0' + i;\n        break;\n      }\n\n      if(i == 3)\n        dID.flagMap[\"optimization\"] = \"None\";\n    }\n\n    return dID;\n  }\n\n  template <>\n  void device_t<Serial>::getEnvironmentVariables(){\n    char *c_compiler = getenv(\"OCCA_CXX\");\n\n    if(c_compiler != NULL){\n      compiler = std::string(c_compiler);\n    }\n    else{\n      c_compiler = getenv(\"CXX\");\n\n      if(c_compiler != NULL){\n        compiler = std::string(c_compiler);\n      }\n      else{\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n        compiler = \"g++\";\n#else\n        compiler = \"cl.exe\";\n#endif\n      }\n    }\n\n    char *c_compilerFlags = getenv(\"OCCA_CXXFLAGS\");\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    if(c_compilerFlags != NULL)\n      compilerFlags = std::string(c_compilerFlags);\n    else{\n#  if OCCA_DEBUG_ENABLED\n      compilerFlags = \"-g\";\n#  else\n      compilerFlags = \"\";\n#  endif\n    }\n#else\n#  if OCCA_DEBUG_ENABLED\n    compilerFlags = \" /Od\";\n#  else\n    compilerFlags = \" /O2\";\n#  endif\n\n    std::string byteness;\n\n    if(sizeof(void*) == 4)\n      byteness = \"x86 \";\n    else if(sizeof(void*) == 8)\n      byteness = \"amd64\";\n    else\n      OCCA_CHECK(false, \"sizeof(void*) is not equal to 4 or 8\");\n\n#  if      (OCCA_VS_VERSION == 1800)\n    char *visualStudioTools = getenv(\"VS120COMNTOOLS\");   // MSVC++ 12.0 - Visual Studio 2013\n#  elif    (OCCA_VS_VERSION == 1700)\n    char *visualStudioTools = getenv(\"VS110COMNTOOLS\");   // MSVC++ 11.0 - Visual Studio 2012\n#  else // (OCCA_VS_VERSION == 1600)\n    char *visualStudioTools = getenv(\"VS100COMNTOOLS\");   // MSVC++ 10.0 - Visual Studio 2010\n#  endif\n\n    if(visualStudioTools != NULL){\n      setCompilerEnvScript(\"\\\"\" + std::string(visualStudioTools) + \"..\\\\..\\\\VC\\\\vcvarsall.bat\\\" \" + byteness);\n    }\n    else{\n      std::cout << \"WARNING: Visual Studio environment variable not found -> compiler environment (vcvarsall.bat) maybe not correctly setup.\" << std::endl;\n    }\n#endif\n  }\n\n  template <>\n  void device_t<Serial>::appendAvailableDevices(std::vector<device> &dList){\n    device d;\n    d.setup(\"Serial\", 0, 0);\n\n    dList.push_back(d);\n  }\n\n  template <>\n  void device_t<Serial>::setCompiler(const std::string &compiler_){\n    compiler = compiler_;\n\n    OCCA_EXTRACT_DATA(Serial, Device);\n\n    data_.vendor = cpu::compilerVendor(compiler);\n\n    cpu::addSharedBinaryFlagsTo(data_.vendor, compilerFlags);\n  }\n\n  template <>\n  void device_t<Serial>::setCompilerEnvScript(const std::string &compilerEnvScript_){\n    compilerEnvScript = compilerEnvScript_;\n  }\n\n  template <>\n  void device_t<Serial>::setCompilerFlags(const std::string &compilerFlags_){\n    OCCA_EXTRACT_DATA(Serial, Device);\n\n    compilerFlags = compilerFlags_;\n\n    cpu::addSharedBinaryFlagsTo(data_.vendor, compilerFlags);\n  }\n\n  template <>\n  void device_t<Serial>::flush(){}\n\n  template <>\n  void device_t<Serial>::finish(){}\n\n  template <>\n  bool device_t<Serial>::fakesUva(){\n    return false;\n  }\n\n  template <>\n  void device_t<Serial>::waitFor(streamTag tag){}\n\n  template <>\n  stream_t device_t<Serial>::createStream(){\n    return NULL;\n  }\n\n  template <>\n  void device_t<Serial>::freeStream(stream_t s){}\n\n  template <>\n  stream_t device_t<Serial>::wrapStream(void *handle_){\n    return NULL;\n  }\n\n  template <>\n  streamTag device_t<Serial>::tagStream(){\n    streamTag ret;\n\n    ret.tagTime = currentTime();\n\n    return ret;\n  }\n\n  template <>\n  double device_t<Serial>::timeBetween(const streamTag &startTag, const streamTag &endTag){\n    return (endTag.tagTime - startTag.tagTime);\n  }\n\n  template <>\n  std::string device_t<Serial>::fixBinaryName(const std::string &filename){\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    return filename;\n#else\n    return (filename + \".dll\");\n#endif\n  }\n\n  template <>\n  kernel_v* device_t<Serial>::buildKernelFromSource(const std::string &filename,\n                                                    const std::string &functionName,\n                                                    const kernelInfo &info_){\n    kernel_v *k = new kernel_t<Serial>;\n    k->dHandle = this;\n\n    k->buildFromSource(filename, functionName, info_);\n\n    return k;\n  }\n\n  template <>\n  kernel_v* device_t<Serial>::buildKernelFromBinary(const std::string &filename,\n                                                    const std::string &functionName){\n    kernel_v *k = new kernel_t<Serial>;\n    k->dHandle = this;\n    k->buildFromBinary(filename, functionName);\n    return k;\n  }\n\n  template <>\n  void device_t<Serial>::cacheKernelInLibrary(const std::string &filename,\n                                              const std::string &functionName,\n                                              const kernelInfo &info_){\n#if 0\n    //---[ Creating shared library ]----\n    kernel tmpK = occa::device(this).buildKernelFromSource(filename, functionName, info_);\n    tmpK.free();\n\n    kernelInfo info = info_;\n\n    addOccaHeadersToInfo(info);\n\n    std::string cachedBinary = getCachedName(filename, getInfoSalt(info));\n\n#if (OCCA_OS & WINDOWS_OS)\n    // Windows requires .dll extension\n    cachedBinary = cachedBinary + \".dll\";\n#endif\n    //==================================\n\n    library::infoID_t infoID;\n\n    infoID.modelID    = modelID_;\n    infoID.kernelName = functionName;\n\n    library::infoHeader_t &header = library::headerMap[infoID];\n\n    header.fileID = -1;\n    header.mode   = Serial;\n\n    const std::string flatDevID = getIdentifier().flattenFlagMap();\n\n    header.flagsOffset = library::addToScratchPad(flatDevID);\n    header.flagsBytes  = flatDevID.size();\n\n    header.contentOffset = library::addToScratchPad(cachedBinary);\n    header.contentBytes  = cachedBinary.size();\n\n    header.kernelNameOffset = library::addToScratchPad(functionName);\n    header.kernelNameBytes  = functionName.size();\n#endif\n  }\n\n  template <>\n  kernel_v* device_t<Serial>::loadKernelFromLibrary(const char *cache,\n                                                    const std::string &functionName){\n#if 0\n    kernel_v *k = new kernel_t<Serial>;\n    k->dHandle = this;\n    k->loadFromLibrary(cache, functionName);\n    return k;\n#endif\n    return NULL;\n  }\n\n  template <>\n  memory_v* device_t<Serial>::wrapMemory(void *handle_,\n                                         const uintptr_t bytes){\n    memory_v *mem = new memory_t<Serial>;\n\n    mem->dHandle = this;\n    mem->size    = bytes;\n    mem->handle  = handle_;\n\n    mem->memInfo |= memFlag::isAWrapper;\n\n    return mem;\n  }\n\n  template <>\n  memory_v* device_t<Serial>::wrapTexture(void *handle_,\n                                          const int dim, const occa::dim &dims,\n                                          occa::formatType type, const int permissions){\n    memory_v *mem = new memory_t<Serial>;\n\n    mem->dHandle = this;\n    mem->size    = ((dim == 1) ? dims.x : (dims.x * dims.y)) * type.bytes();\n\n    mem->memInfo |= (memFlag::isATexture |\n                     memFlag::isAWrapper);\n\n    mem->textureInfo.dim  = dim;\n\n    mem->textureInfo.w = dims.x;\n    mem->textureInfo.h = dims.y;\n    mem->textureInfo.d = dims.z;\n\n    mem->textureInfo.arg = handle_;\n\n    mem->handle = &(mem->textureInfo);\n\n    return mem;\n  }\n\n  template <>\n  memory_v* device_t<Serial>::malloc(const uintptr_t bytes,\n                                     void *src){\n    memory_v *mem = new memory_t<Serial>;\n\n    mem->dHandle = this;\n    mem->size    = bytes;\n\n    mem->handle = cpu::malloc(bytes);\n\n    if(src != NULL)\n      ::memcpy(mem->handle, src, bytes);\n\n    return mem;\n  }\n\n  template <>\n  memory_v* device_t<Serial>::textureAlloc(const int dim, const occa::dim &dims,\n                                           void *src,\n                                           occa::formatType type, const int permissions){\n    memory_v *mem = new memory_t<Serial>;\n\n    mem->dHandle = this;\n    mem->size    = ((dim == 1) ? dims.x : (dims.x * dims.y)) * type.bytes();\n\n    mem->memInfo |= memFlag::isATexture;\n\n    mem->textureInfo.dim  = dim;\n\n    mem->textureInfo.w = dims.x;\n    mem->textureInfo.h = dims.y;\n    mem->textureInfo.d = dims.z;\n\n    mem->handle = cpu::malloc(mem->size);\n\n    ::memcpy(mem->textureInfo.arg, src, mem->size);\n\n    mem->handle = &(mem->textureInfo);\n\n    return mem;\n  }\n\n  template <>\n  memory_v* device_t<Serial>::mappedAlloc(const uintptr_t bytes,\n                                          void *src){\n    memory_v *mem = malloc(bytes, src);\n\n    mem->mappedPtr = mem->handle;\n\n    return mem;\n  }\n\n  template <>\n  uintptr_t device_t<Serial>::memorySize(){\n    return cpu::installedRAM();\n  }\n\n  template <>\n  void device_t<Serial>::free(){\n    if(data){\n      delete (SerialDeviceData_t*) data;\n      data = NULL;\n    }\n  }\n\n  template <>\n  int device_t<Serial>::simdWidth(){\n    simdWidth_ = OCCA_SIMD_WIDTH;\n    return OCCA_SIMD_WIDTH;\n  }\n  //==================================\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-occa-0.2.0-5nxq5eiljk2xvfw3jwwnnapbb2n6t4ub/spack-src/src/Pthreads.cpp": "#include \"occa/Serial.hpp\"\n#include \"occa/Pthreads.hpp\"\n\nnamespace occa {\n  //---[ Helper Functions ]-------------\n  namespace pthreads {\n    void* limbo(void *args){\n      PthreadWorkerData_t &data = *((PthreadWorkerData_t*) args);\n\n      // Thread affinity\n#if (OCCA_OS == LINUX_OS) // Not WINUX\n      cpu_set_t cpuHandle;\n      CPU_ZERO(&cpuHandle);\n      CPU_SET(data.pinnedCore, &cpuHandle);\n#else\n      // NBN: affinity on hyperthreaded multi-socket systems?\n      if(data.rank == 0)\n        fprintf(stderr, \"[Pthreads] Affinity not guaranteed in this OS\\n\");\n      // BOOL SetProcessAffinityMask(HANDLE hProcess,DWORD_PTR dwProcessAffinityMask);\n#endif\n\n      while(true){\n        // Fence local data (incase of out-of-socket updates)\n        if( *(data.pendingJobs) ){\n          data.kernelMutex->lock();\n          PthreadKernelInfo_t &pkInfo = *(data.pKernelInfo->front());\n          data.pKernelInfo->pop();\n          data.kernelMutex->unlock();\n\n          run(pkInfo);\n\n          //---[ Barrier ]----------------\n          data.pendingJobsMutex->lock();\n          --( *(data.pendingJobs) );\n          data.pendingJobsMutex->unlock();\n\n          while((*data.pendingJobs) % data.count){}\n          //==============================\n        }\n      }\n\n      return NULL;\n    }\n\n    void run(PthreadKernelInfo_t &pkInfo){\n      handleFunction_t tmpKernel = (handleFunction_t) pkInfo.kernelHandle;\n\n      int dp           = pkInfo.dims - 1;\n      occa::dim &outer = pkInfo.outer;\n      occa::dim &inner = pkInfo.inner;\n\n      occa::dim start(0,0,0), end(outer);\n\n      int loops     = (outer[dp] / pkInfo.count);\n      int coolRanks = (outer[dp] - loops*pkInfo.count);\n\n      if(pkInfo.rank < coolRanks){\n        start[dp] = (pkInfo.rank)*(loops + 1);\n        end[dp]   = start[dp] + (loops + 1);\n      }\n      else{\n        start[dp] = pkInfo.rank*loops + coolRanks;\n        end[dp]   = start[dp] + loops;\n      }\n\n      int occaKernelArgs[12];\n\n      occaKernelArgs[0]  = outer.z; occaKernelArgs[3]  = inner.z;\n      occaKernelArgs[1]  = outer.y; occaKernelArgs[4]  = inner.y;\n      occaKernelArgs[2]  = outer.x; occaKernelArgs[5]  = inner.x;\n\n      occaKernelArgs[6]  = start.z; occaKernelArgs[7]  = end.z;\n      occaKernelArgs[8]  = start.y; occaKernelArgs[9]  = end.y;\n      occaKernelArgs[10] = start.x; occaKernelArgs[11] = end.x;\n\n      int occaInnerId0 = 0, occaInnerId1 = 0, occaInnerId2 = 0;\n\n      cpu::runFunction(tmpKernel,\n                       occaKernelArgs,\n                       occaInnerId0, occaInnerId1, occaInnerId2,\n                       pkInfo.argc, pkInfo.args);\n\n      delete [] pkInfo.args;\n      delete &pkInfo;\n    }\n  }\n  //==================================\n\n  //---[ Kernel ]---------------------\n  template <>\n  kernel_t<Pthreads>::kernel_t(){\n    strMode = \"Pthreads\";\n    name = \"\";\n    sourceFilename = \"\";\n    binaryFilename = \"\";\n\n    data    = NULL;\n    dHandle = NULL;\n\n    dims  = 1;\n    inner = occa::dim(1,1,1);\n    outer = occa::dim(1,1,1);\n  }\n\n  template <>\n  kernel_t<Pthreads>::kernel_t(const kernel_t<Pthreads> &k){\n    *this = k;\n  }\n\n  template <>\n  kernel_t<Pthreads>& kernel_t<Pthreads>::operator = (const kernel_t<Pthreads> &k){\n    data    = k.data;\n    dHandle = k.dHandle;\n\n    metaInfo = k.metaInfo;\n\n    dims  = k.dims;\n    inner = k.inner;\n    outer = k.outer;\n\n    nestedKernels = k.nestedKernels;\n\n    return *this;\n  }\n\n  template <>\n  kernel_t<Pthreads>::~kernel_t(){}\n\n  template <>\n  void* kernel_t<Pthreads>::getKernelHandle(){\n    OCCA_EXTRACT_DATA(Pthreads, Kernel);\n\n    void *ret;\n\n    ::memcpy(&ret, &data_.handle, sizeof(void*));\n\n    return ret;\n  }\n\n  template <>\n  void* kernel_t<Pthreads>::getProgramHandle(){\n    OCCA_EXTRACT_DATA(Pthreads, Kernel);\n\n    return data_.dlHandle;\n  }\n\n  template <>\n  std::string kernel_t<Pthreads>::fixBinaryName(const std::string &filename){\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    return filename;\n#else\n    return (filename + \".dll\");\n#endif\n  }\n\n  template <>\n  kernel_t<Pthreads>* kernel_t<Pthreads>::buildFromSource(const std::string &filename,\n                                                          const std::string &functionName,\n                                                          const kernelInfo &info_){\n\n    name = functionName;\n\n    kernelInfo info = info_;\n\n    dHandle->addOccaHeadersToInfo(info);\n\n    const std::string hash = getFileContentHash(filename,\n                                                dHandle->getInfoSalt(info));\n\n    const std::string hashDir    = hashDirFor(filename, hash);\n    sourceFilename = hashDir + kc::sourceFile;\n    binaryFilename = hashDir + fixBinaryName(kc::binaryFile);\n    bool foundBinary = true;\n\n    if (!haveHash(hash, 0))\n      waitForHash(hash, 0);\n    else if (sys::fileExists(binaryFilename))\n      releaseHash(hash, 0);\n    else\n      foundBinary = false;\n\n    if (foundBinary) {\n      if(verboseCompilation_f)\n        std::cout << \"Found cached binary of [\" << compressFilename(filename) << \"] in [\" << compressFilename(binaryFilename) << \"]\\n\";\n\n      return buildFromBinary(binaryFilename, functionName);\n    }\n\n    data = new PthreadsKernelData_t;\n\n    createSourceFileFrom(filename, hashDir, info);\n\n    std::stringstream command;\n\n    if(dHandle->compilerEnvScript.size())\n      command << dHandle->compilerEnvScript << \" && \";\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    command << dHandle->compiler\n            << ' '    << dHandle->compilerFlags\n            << ' '    << info.flags\n            << ' '    << sourceFilename\n            << \" -o \" << binaryFilename\n            << \" -I\"  << env::OCCA_DIR << \"/include\"\n            << \" -L\"  << env::OCCA_DIR << \"/lib -locca\"\n            << std::endl;\n#else\n#  if (OCCA_DEBUG_ENABLED)\n    std::string occaLib = env::OCCA_DIR + \"\\\\lib\\\\libocca_d.lib \";\n#  else\n    std::string occaLib = env::OCCA_DIR + \"\\\\lib\\\\libocca.lib \";\n#  endif\n    std::string ptLib   = env::OCCA_DIR + \"\\\\lib\\\\pthreadVC2.lib \";\n\n    command << dHandle->compiler\n            << \" /D MC_CL_EXE\"\n            << ' '    << dHandle->compilerFlags\n            << ' '    << info.flags\n            << \" /I\"  << env::OCCA_DIR << \"\\\\include\"\n            << ' '    << sourceFilename\n            << \" /link \" << occaLib << ptLib << \" /OUT:\" << binaryFilename\n            << std::endl;\n#endif\n\n    const std::string &sCommand = command.str();\n\n    if(verboseCompilation_f)\n      std::cout << \"Compiling [\" << functionName << \"]\\n\" << sCommand << \"\\n\";\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    const int compileError = system(sCommand.c_str());\n#else\n    const int compileError = system((\"\\\"\" +  sCommand + \"\\\"\").c_str());\n#endif\n\n    if(compileError){\n      releaseHash(hash, 0);\n      OCCA_CHECK(false, \"Compilation error\");\n    }\n\n    OCCA_EXTRACT_DATA(Pthreads, Kernel);\n\n    data_.dlHandle = cpu::dlopen(binaryFilename, hash);\n    data_.handle   = cpu::dlsym(data_.dlHandle, functionName, hash);\n\n    PthreadsDeviceData_t &dData = *((PthreadsDeviceData_t*) ((device_t<Pthreads>*) dHandle)->data);\n\n    data_.pThreadCount = dData.pThreadCount;\n\n    data_.pendingJobs = &(dData.pendingJobs);\n\n    for(int p = 0; p < 50; ++p)\n      data_.pKernelInfo[p] = &(dData.pKernelInfo[p]);\n\n    data_.pendingJobsMutex = &(dData.pendingJobsMutex);\n    data_.kernelMutex      = &(dData.kernelMutex);\n\n    releaseHash(hash, 0);\n\n    return this;\n  }\n\n  template <>\n  kernel_t<Pthreads>* kernel_t<Pthreads>::buildFromBinary(const std::string &filename,\n                                                          const std::string &functionName){\n\n    name = functionName;\n    binaryFilename = filename;\n\n    data = new PthreadsKernelData_t;\n\n    OCCA_EXTRACT_DATA(Pthreads, Kernel);\n\n    data_.dlHandle = cpu::dlopen(filename);\n    data_.handle   = cpu::dlsym(data_.dlHandle, functionName);\n\n    PthreadsDeviceData_t &dData = *((PthreadsDeviceData_t*) ((device_t<Pthreads>*) dHandle)->data);\n\n    data_.pThreadCount = dData.pThreadCount;\n\n    data_.pendingJobs = &(dData.pendingJobs);\n\n    for(int p = 0; p < 50; ++p)\n      data_.pKernelInfo[p] = &(dData.pKernelInfo[p]);\n\n    data_.pendingJobsMutex = &(dData.pendingJobsMutex);\n    data_.kernelMutex      = &(dData.kernelMutex);\n\n    return this;\n  }\n\n  template <>\n  kernel_t<Pthreads>* kernel_t<Pthreads>::loadFromLibrary(const char *cache,\n                                                          const std::string &functionName){\n    return buildFromBinary(cache, functionName);\n  }\n\n  template <>\n  uintptr_t kernel_t<Pthreads>::maximumInnerDimSize(){\n    return ((uintptr_t) -1);\n  }\n\n  // [-] Missing\n  template <>\n  int kernel_t<Pthreads>::preferredDimSize(){\n    preferredDimSize_ = OCCA_SIMD_WIDTH;\n    return OCCA_SIMD_WIDTH;\n  }\n\n  template <>\n  void kernel_t<Pthreads>::runFromArguments(const int kArgc, const kernelArg *kArgs){\n    OCCA_EXTRACT_DATA(Pthreads, Kernel);\n\n    const int pThreadCount = data_.pThreadCount;\n\n    for(int p = 0; p < pThreadCount; ++p){\n      // Allocated individually since each thread frees their\n      //   own custom arg\n      PthreadKernelInfo_t &pArgs = *(new PthreadKernelInfo_t);\n\n      pArgs.rank  = p;\n      pArgs.count = pThreadCount;\n\n      pArgs.kernelHandle = data_.handle;\n\n      pArgs.dims  = dims;\n      pArgs.inner = inner;\n      pArgs.outer = outer;\n\n      int argc = 0;\n      pArgs.argc = kernelArg::argumentCount(kArgc, kArgs);\n      pArgs.args = new void*[pArgs.argc];\n      for(int i = 0; i < pArgs.argc; ++i){\n        for(int j = 0; j < kArgs[i].argc; ++j){\n          pArgs.args[argc++] = kArgs[i].args[j].ptr();\n        }\n      }\n\n      data_.kernelMutex->lock();\n      data_.pKernelInfo[p]->push(&pArgs);\n      data_.kernelMutex->unlock();\n    }\n\n    data_.pendingJobsMutex->lock();\n    *(data_.pendingJobs) += data_.pThreadCount;\n    data_.pendingJobsMutex->unlock();\n  }\n\n  template <>\n  void kernel_t<Pthreads>::free(){\n    // [-] Fix later\n    OCCA_EXTRACT_DATA(Pthreads, Kernel);\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    dlclose(data_.dlHandle);\n#else\n    FreeLibrary((HMODULE) (data_.dlHandle));\n#endif\n  }\n  //==================================\n\n\n  //---[ Memory ]---------------------\n  template <>\n  memory_t<Pthreads>::memory_t(){\n    strMode = \"Pthreads\";\n\n    memInfo = memFlag::none;\n\n    handle    = NULL;\n    mappedPtr = NULL;\n    uvaPtr    = NULL;\n\n    dHandle = NULL;\n    size    = 0;\n\n    textureInfo.arg = NULL;\n    textureInfo.dim = 1;\n    textureInfo.w = textureInfo.h = textureInfo.d = 0;\n  }\n\n  template <>\n  memory_t<Pthreads>::memory_t(const memory_t<Pthreads> &m){\n    *this = m;\n  }\n\n  template <>\n  memory_t<Pthreads>& memory_t<Pthreads>::operator = (const memory_t<Pthreads> &m){\n    memInfo = m.memInfo;\n\n    handle    = m.handle;\n    mappedPtr = m.mappedPtr;\n    uvaPtr    = m.uvaPtr;\n\n    dHandle = m.dHandle;\n    size    = m.size;\n\n    textureInfo.arg  = m.textureInfo.arg;\n    textureInfo.dim  = m.textureInfo.dim;\n\n    textureInfo.w = m.textureInfo.w;\n    textureInfo.h = m.textureInfo.h;\n    textureInfo.d = m.textureInfo.d;\n\n    if(isATexture())\n      handle = &textureInfo;\n\n    return *this;\n  }\n\n  template <>\n  memory_t<Pthreads>::~memory_t(){}\n\n  template <>\n  void* memory_t<Pthreads>::getMemoryHandle(){\n    return handle;\n  }\n\n  template <>\n  void* memory_t<Pthreads>::getTextureHandle(){\n    return textureInfo.arg;\n  }\n\n  template <>\n  void memory_t<Pthreads>::copyFrom(const void *src,\n                                  const uintptr_t bytes,\n                                  const uintptr_t offset){\n    dHandle->finish();\n\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + offset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << offset << \" , \" << (offset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (isATexture() ? textureInfo.arg : handle)) + offset;\n    const void *srcPtr = src;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Pthreads>::copyFrom(const memory_v *src,\n                                  const uintptr_t bytes,\n                                  const uintptr_t destOffset,\n                                  const uintptr_t srcOffset){\n    dHandle->finish();\n\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + destOffset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << destOffset << \" , \" << (destOffset + bytes_) << \" ]\");\n\n    OCCA_CHECK((bytes_ + srcOffset) <= src->size,\n               \"Source has size [\" << src->size << \"],\"\n               << \"trying to access [ \" << srcOffset << \" , \" << (srcOffset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (isATexture()      ? textureInfo.arg      : handle))      + destOffset;\n    const void *srcPtr = ((char*) (src->isATexture() ? src->textureInfo.arg : src->handle)) + srcOffset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Pthreads>::copyTo(void *dest,\n                                const uintptr_t bytes,\n                                const uintptr_t offset){\n    dHandle->finish();\n\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + offset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << offset << \" , \" << (offset + bytes_) << \" ]\");\n\n    void *destPtr      = dest;\n    const void *srcPtr = ((char*) (isATexture() ? textureInfo.arg : handle)) + offset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Pthreads>::copyTo(memory_v *dest,\n                                const uintptr_t bytes,\n                                const uintptr_t destOffset,\n                                const uintptr_t srcOffset){\n    dHandle->finish();\n\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + srcOffset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << srcOffset << \" , \" << (srcOffset + bytes_) << \" ]\");\n\n    OCCA_CHECK((bytes_ + destOffset) <= dest->size,\n               \"Destination has size [\" << dest->size << \"],\"\n               << \"trying to access [ \" << destOffset << \" , \" << (destOffset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (dest->isATexture() ? dest->textureInfo.arg : dest->handle)) + destOffset;\n    const void *srcPtr = ((char*) (isATexture() ? textureInfo.arg : handle))       + srcOffset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Pthreads>::asyncCopyFrom(const void *src,\n                                       const uintptr_t bytes,\n                                       const uintptr_t offset){\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + offset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << offset << \" , \" << (offset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (isATexture() ? textureInfo.arg : handle)) + offset;\n    const void *srcPtr = src;\n\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Pthreads>::asyncCopyFrom(const memory_v *src,\n                                       const uintptr_t bytes,\n                                       const uintptr_t destOffset,\n                                       const uintptr_t srcOffset){\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + destOffset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << destOffset << \" , \" << (destOffset + bytes_) << \" ]\");\n\n    OCCA_CHECK((bytes_ + srcOffset) <= src->size,\n               \"Source has size [\" << src->size << \"],\"\n               << \"trying to access [ \" << srcOffset << \" , \" << (srcOffset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (isATexture()      ? textureInfo.arg      : handle))      + destOffset;\n    const void *srcPtr = ((char*) (src->isATexture() ? src->textureInfo.arg : src->handle)) + srcOffset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Pthreads>::asyncCopyTo(void *dest,\n                                     const uintptr_t bytes,\n                                     const uintptr_t offset){\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + offset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << offset << \" , \" << (offset + bytes_) << \" ]\");\n\n    void *destPtr      = dest;\n    const void *srcPtr = ((char*) (isATexture() ? textureInfo.arg : handle)) + offset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Pthreads>::asyncCopyTo(memory_v *dest,\n                                     const uintptr_t bytes,\n                                     const uintptr_t destOffset,\n                                     const uintptr_t srcOffset){\n    const uintptr_t bytes_ = (bytes == 0) ? size : bytes;\n\n    OCCA_CHECK((bytes_ + srcOffset) <= size,\n               \"Memory has size [\" << size << \"],\"\n               << \"trying to access [ \" << srcOffset << \" , \" << (srcOffset + bytes_) << \" ]\");\n\n    OCCA_CHECK((bytes_ + destOffset) <= dest->size,\n               \"Destination has size [\" << dest->size << \"],\"\n               << \"trying to access [ \" << destOffset << \" , \" << (destOffset + bytes_) << \" ]\");\n\n    void *destPtr      = ((char*) (dest->isATexture() ? dest->textureInfo.arg : dest->handle)) + destOffset;\n    const void *srcPtr = ((char*) (isATexture() ? textureInfo.arg : handle))       + srcOffset;\n\n    ::memcpy(destPtr, srcPtr, bytes_);\n  }\n\n  template <>\n  void memory_t<Pthreads>::mappedFree(){\n    cpu::free(handle);\n    handle    = NULL;\n    mappedPtr = NULL;\n\n    size = 0;\n  }\n\n  template <>\n  void memory_t<Pthreads>::mappedDetach(){\n    handle    = NULL;\n    mappedPtr = NULL;\n\n    size = 0;\n  }\n\n  template <>\n  void memory_t<Pthreads>::free(){\n    if(isATexture()){\n      cpu::free(textureInfo.arg);\n      textureInfo.arg = NULL;\n    }\n    else{\n      cpu::free(handle);\n      handle = NULL;\n    }\n\n    size = 0;\n  }\n\n  template <>\n  void memory_t<Pthreads>::detach(){\n    if(isATexture()){\n      textureInfo.arg = NULL;\n    }\n    else{\n      handle = NULL;\n    }\n\n    size = 0;\n  }\n  //==================================\n\n\n  //---[ Device ]---------------------\n  template <>\n  device_t<Pthreads>::device_t(){\n    strMode = \"Pthreads\";\n\n    data = NULL;\n\n    uvaEnabled_ = false;\n\n    bytesAllocated = 0;\n\n    getEnvironmentVariables();\n\n    cpu::addSharedBinaryFlagsTo(compiler, compilerFlags);\n  }\n\n  template <>\n  device_t<Pthreads>::device_t(const device_t<Pthreads> &d){\n    *this = d;\n  }\n\n  template <>\n  device_t<Pthreads>& device_t<Pthreads>::operator = (const device_t<Pthreads> &d){\n    modelID_ = d.modelID_;\n    id_      = d.id_;\n\n    data = d.data;\n\n    uvaEnabled_    = d.uvaEnabled_;\n    uvaMap         = d.uvaMap;\n    uvaDirtyMemory = d.uvaDirtyMemory;\n\n    compiler      = d.compiler;\n    compilerFlags = d.compilerFlags;\n\n    bytesAllocated = d.bytesAllocated;\n\n    return *this;\n  }\n\n  template <>\n  void* device_t<Pthreads>::getContextHandle(){\n    return NULL;\n  }\n\n  template <>\n  void device_t<Pthreads>::setup(argInfoMap &aim){\n    properties = aim;\n\n    data = new PthreadsDeviceData_t;\n\n    OCCA_EXTRACT_DATA(Pthreads, Device);\n\n    data_.vendor = cpu::compilerVendor(compiler);\n\n    cpu::addSharedBinaryFlagsTo(data_.vendor, compilerFlags);\n\n    data_.pendingJobs = 0;\n\n    data_.coreCount = cpu::getCoreCount();\n\n    std::vector<int> pinnedCores;\n\n    if(!aim.has(\"threadCount\"))\n      data_.pThreadCount = 1;\n    else\n      data_.pThreadCount = aim.iGet(\"threadCount\");\n\n    if(!aim.has(\"schedule\") ||\n       (aim.get(\"schedule\") == \"compact\")){\n\n      data_.schedule = occa::compact;\n    }\n    else{\n      data_.schedule = occa::scatter;\n    }\n\n    if(aim.has(\"pinnedCores\")){\n      aim.iGets(\"pinnedCores\", pinnedCores);\n\n      if(pinnedCores.size() != (size_t) data_.pThreadCount){\n        std::cout << \"[Pthreads]: Mismatch between thread count and pinned cores\\n\"\n                  << \"            Defaulting to [\"\n                  << ((data_.schedule == occa::compact) ?\n                      \"compact\" : \"scatter\")\n                  << \"] scheduling\\n\"\n                  << \"  Thread Count: \" << data_.pThreadCount << '\\n'\n                  << \"  Pinned Cores: [\";\n\n        if(pinnedCores.size()){\n          std::cout << pinnedCores[0];\n\n          for(size_t i = 1; i < pinnedCores.size(); ++i)\n            std::cout << \", \" << pinnedCores[i];\n        }\n\n        std::cout << \"]\\n\";\n\n        pinnedCores.clear();\n      }\n      else{\n        for(size_t i = 0; i < pinnedCores.size(); ++i)\n          if(pinnedCores[i] < 0){\n            const int newPC = (((pinnedCores[i] % data_.coreCount)\n                                + pinnedCores[i]) % data_.coreCount);\n\n            std::cout << \"Trying to pin thread on core [\"\n                      << pinnedCores[i] << \"], changing it to [\"\n                      << newPC << \"]\\n\";\n\n            pinnedCores[i] = newPC;\n          }\n          else if(data_.coreCount <= pinnedCores[i]){\n            const int newPC = (pinnedCores[i] % data_.coreCount);\n\n            std::cout << \"Trying to pin thread on core [\"\n                      << pinnedCores[i] << \"], changing it to [\"\n                      << newPC << \"]\\n\";\n\n            pinnedCores[i] = newPC;\n          }\n\n        data_.schedule = occa::manual;\n      }\n    }\n\n    for(int p = 0; p < data_.pThreadCount; ++p){\n      PthreadWorkerData_t *args = new PthreadWorkerData_t;\n\n      args->rank  = p;\n      args->count = data_.pThreadCount;\n\n      // [-] Need to know number of sockets\n      if(data_.schedule & occa::compact)\n        args->pinnedCore = (p % data_.coreCount);\n      else if(data_.schedule & occa::scatter)\n        args->pinnedCore = (p % data_.coreCount);\n      else // Manual\n        args->pinnedCore = pinnedCores[p];\n\n      args->pendingJobs = &(data_.pendingJobs);\n\n      args->pendingJobsMutex = &(data_.pendingJobsMutex);\n      args->kernelMutex      = &(data_.kernelMutex);\n\n      args->pKernelInfo = &(data_.pKernelInfo[p]);\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n      pthread_create(&data_.tid[p], NULL, pthreads::limbo, args);\n#else\n      CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) pthreads::limbo, args, 0, &data_.tid[p]);\n#endif\n    }\n  }\n\n  template <>\n  void device_t<Pthreads>::addOccaHeadersToInfo(kernelInfo &info_){\n    info_.mode = Pthreads;\n  }\n\n  template <>\n  std::string device_t<Pthreads>::getInfoSalt(const kernelInfo &info_){\n    std::stringstream salt;\n\n    salt << \"Pthreads\"\n         << info_.salt()\n         << parserVersion\n         << compilerEnvScript\n         << compiler\n         << compilerFlags;\n\n    return salt.str();\n  }\n\n  template <>\n  deviceIdentifier device_t<Pthreads>::getIdentifier() const {\n    deviceIdentifier dID;\n\n    dID.mode_ = Pthreads;\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    const bool debugEnabled = (compilerFlags.find(\"-g\") != std::string::npos);\n#else\n    const bool debugEnabled = (compilerFlags.find(\"/Od\") != std::string::npos);\n#endif\n\n    dID.flagMap[\"compiler\"]     = compiler;\n    dID.flagMap[\"debugEnabled\"] = (debugEnabled ? \"true\" : \"false\");\n\n    for(int i = 0; i <= 3; ++i){\n      std::string flag = \"-O\";\n      flag += '0' + i;\n\n      if(compilerFlags.find(flag) != std::string::npos){\n        dID.flagMap[\"optimization\"] = '0' + i;\n        break;\n      }\n\n      if(i == 3)\n        dID.flagMap[\"optimization\"] = \"None\";\n    }\n\n    return dID;\n  }\n\n  template <>\n  void device_t<Pthreads>::getEnvironmentVariables(){\n    char *c_compiler = getenv(\"OCCA_CXX\");\n\n    if(c_compiler != NULL){\n      compiler = std::string(c_compiler);\n    }\n    else{\n      c_compiler = getenv(\"CXX\");\n\n      if(c_compiler != NULL){\n        compiler = std::string(c_compiler);\n      }\n      else{\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n        compiler = \"g++\";\n#else\n        compiler = \"cl.exe\";\n#endif\n      }\n    }\n\n    char *c_compilerFlags = getenv(\"OCCA_CXXFLAGS\");\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    if(c_compilerFlags != NULL)\n      compilerFlags = std::string(c_compilerFlags);\n    else{\n#  if OCCA_DEBUG_ENABLED\n      compilerFlags = \"-g\";\n#  else\n      compilerFlags = \"\";\n#  endif\n    }\n#else\n#  if OCCA_DEBUG_ENABLED\n    compilerFlags = \" /Od\";\n#  else\n    compilerFlags = \" /O2\";\n#  endif\n\n    std::string byteness;\n\n    if(sizeof(void*) == 4)\n      byteness = \"x86 \";\n    else if(sizeof(void*) == 8)\n      byteness = \"amd64\";\n    else\n      OCCA_CHECK(false, \"sizeof(void*) is not equal to 4 or 8\");\n\n#  if      (OCCA_VS_VERSION == 1800)\n    char *visualStudioTools = getenv(\"VS120COMNTOOLS\");   // MSVC++ 12.0 - Visual Studio 2013\n#  elif    (OCCA_VS_VERSION == 1700)\n    char *visualStudioTools = getenv(\"VS110COMNTOOLS\");   // MSVC++ 11.0 - Visual Studio 2012\n#  else // (OCCA_VS_VERSION == 1600)\n    char *visualStudioTools = getenv(\"VS100COMNTOOLS\");   // MSVC++ 10.0 - Visual Studio 2010\n#  endif\n\n    if(visualStudioTools != NULL){\n      setCompilerEnvScript(\"\\\"\" + std::string(visualStudioTools) + \"..\\\\..\\\\VC\\\\vcvarsall.bat\\\" \" + byteness);\n    }\n    else{\n      std::cout << \"WARNING: Visual Studio environment variable not found -> compiler environment (vcvarsall.bat) maybe not correctly setup.\" << std::endl;\n    }\n#endif\n  }\n\n  template <>\n  void device_t<Pthreads>::appendAvailableDevices(std::vector<device> &dList){\n    device d;\n\n    d.setup(\"Pthreads\", cpu::getCoreCount(), occa::compact);\n\n    dList.push_back(d);\n  }\n\n  template <>\n  void device_t<Pthreads>::setCompiler(const std::string &compiler_){\n    compiler = compiler_;\n\n    OCCA_EXTRACT_DATA(Pthreads, Device);\n\n    data_.vendor = cpu::compilerVendor(compiler);\n\n    cpu::addSharedBinaryFlagsTo(data_.vendor, compilerFlags);\n  }\n\n  template <>\n  void device_t<Pthreads>::setCompilerEnvScript(const std::string &compilerEnvScript_){\n    compilerEnvScript = compilerEnvScript_;\n  }\n\n  template <>\n  void device_t<Pthreads>::setCompilerFlags(const std::string &compilerFlags_){\n    OCCA_EXTRACT_DATA(Pthreads, Device);\n\n    compilerFlags = compilerFlags_;\n\n    cpu::addSharedBinaryFlagsTo(data_.vendor, compilerFlags);\n  }\n\n  template <>\n  void device_t<Pthreads>::flush(){}\n\n  template <>\n  void device_t<Pthreads>::finish(){\n    OCCA_EXTRACT_DATA(Pthreads, Device);\n\n    // Fence local data (incase of out-of-socket updates)\n    while(data_.pendingJobs){}\n  }\n\n  template <>\n  bool device_t<Pthreads>::fakesUva(){\n    return false;\n  }\n\n  template <>\n  void device_t<Pthreads>::waitFor(streamTag tag){\n    finish(); // [-] Not done\n  }\n\n  template <>\n  stream_t device_t<Pthreads>::createStream(){\n    return NULL;\n  }\n\n  template <>\n  void device_t<Pthreads>::freeStream(stream_t s){}\n\n  template <>\n  stream_t device_t<Pthreads>::wrapStream(void *handle_){\n    return NULL;\n  }\n\n  template <>\n  streamTag device_t<Pthreads>::tagStream(){\n    streamTag ret;\n\n    ret.tagTime = currentTime();\n\n    return ret;\n  }\n\n  template <>\n  double device_t<Pthreads>::timeBetween(const streamTag &startTag, const streamTag &endTag){\n    return (endTag.tagTime - startTag.tagTime);\n  }\n\n  template <>\n  std::string device_t<Pthreads>::fixBinaryName(const std::string &filename){\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n    return filename;\n#else\n    return (filename + \".dll\");\n#endif\n  }\n\n  template <>\n  kernel_v* device_t<Pthreads>::buildKernelFromSource(const std::string &filename,\n                                                      const std::string &functionName,\n                                                      const kernelInfo &info_){\n    kernel_v *k = new kernel_t<Pthreads>;\n    k->dHandle  = this;\n\n    k->buildFromSource(filename, functionName, info_);\n\n    return k;\n  }\n\n  template <>\n  kernel_v* device_t<Pthreads>::buildKernelFromBinary(const std::string &filename,\n                                                      const std::string &functionName){\n    kernel_v *k = new kernel_t<Pthreads>;\n    k->dHandle  = this;\n    k->buildFromBinary(filename, functionName);\n    return k;\n  }\n\n  template <>\n  void device_t<Pthreads>::cacheKernelInLibrary(const std::string &filename,\n                                                const std::string &functionName,\n                                                const kernelInfo &info_){\n#if 0\n    //---[ Creating shared library ]----\n    kernel tmpK = occa::device(this).buildKernelFromSource(filename, functionName, info_);\n    tmpK.free();\n\n    kernelInfo info = info_;\n\n    addOccaHeadersToInfo(info);\n\n    std::string cachedBinary = getCachedName(filename, getInfoSalt(info));\n\n#if (OCCA_OS & WINDOWS_OS)\n    // Windows requires .dll extension\n    cachedBinary = cachedBinary + \".dll\";\n#endif\n    //==================================\n\n    library::infoID_t infoID;\n\n    infoID.modelID    = modelID_;\n    infoID.kernelName = functionName;\n\n    library::infoHeader_t &header = library::headerMap[infoID];\n\n    header.fileID = -1;\n    header.mode   = Pthreads;\n\n    const std::string flatDevID = getIdentifier().flattenFlagMap();\n\n    header.flagsOffset = library::addToScratchPad(flatDevID);\n    header.flagsBytes  = flatDevID.size();\n\n    header.contentOffset = library::addToScratchPad(cachedBinary);\n    header.contentBytes  = cachedBinary.size();\n\n    header.kernelNameOffset = library::addToScratchPad(functionName);\n    header.kernelNameBytes  = functionName.size();\n#endif\n  }\n\n  template <>\n  kernel_v* device_t<Pthreads>::loadKernelFromLibrary(const char *cache,\n                                                      const std::string &functionName){\n    kernel_v *k = new kernel_t<Pthreads>;\n    k->dHandle  = this;\n    k->loadFromLibrary(cache, functionName);\n    return k;\n  }\n\n  template <>\n  memory_v* device_t<Pthreads>::wrapMemory(void *handle_,\n                                           const uintptr_t bytes){\n    memory_v *mem = new memory_t<Pthreads>;\n\n    mem->dHandle = this;\n    mem->size    = bytes;\n    mem->handle  = handle_;\n\n    mem->memInfo |= memFlag::isAWrapper;\n\n    return mem;\n  }\n\n  template <>\n  memory_v* device_t<Pthreads>::wrapTexture(void *handle_,\n                                            const int dim, const occa::dim &dims,\n                                            occa::formatType type, const int permissions){\n    memory_v *mem = new memory_t<Pthreads>;\n\n    mem->dHandle = this;\n    mem->size    = ((dim == 1) ? dims.x : (dims.x * dims.y)) * type.bytes();\n\n    mem->memInfo |= (memFlag::isATexture |\n                     memFlag::isAWrapper);\n\n    mem->textureInfo.dim  = dim;\n\n    mem->textureInfo.w = dims.x;\n    mem->textureInfo.h = dims.y;\n    mem->textureInfo.d = dims.z;\n\n    mem->textureInfo.arg = handle_;\n\n    mem->handle = &(mem->textureInfo);\n\n    return mem;\n  }\n\n  template <>\n  memory_v* device_t<Pthreads>::malloc(const uintptr_t bytes,\n                                       void *src){\n    memory_v *mem = new memory_t<Pthreads>;\n\n    mem->dHandle = this;\n    mem->size    = bytes;\n\n    mem->handle = cpu::malloc(bytes);\n\n    if(src != NULL)\n      ::memcpy(mem->handle, src, bytes);\n\n    return mem;\n  }\n\n  template <>\n  memory_v* device_t<Pthreads>::textureAlloc(const int dim, const occa::dim &dims,\n                                             void *src,\n                                             occa::formatType type, const int permissions){\n    memory_v *mem = new memory_t<Pthreads>;\n\n    mem->dHandle = this;\n    mem->size    = ((dim == 1) ? dims.x : (dims.x * dims.y)) * type.bytes();\n\n    mem->memInfo |= memFlag::isATexture;\n\n    mem->textureInfo.dim  = dim;\n\n    mem->textureInfo.w = dims.x;\n    mem->textureInfo.h = dims.y;\n    mem->textureInfo.d = dims.z;\n\n    mem->handle = cpu::malloc(mem->size);\n\n    ::memcpy(mem->handle, src, mem->size);\n\n    mem->textureInfo.arg = mem->handle;\n    mem->handle = &(mem->textureInfo);\n\n    return mem;\n  }\n\n  template <>\n  memory_v* device_t<Pthreads>::mappedAlloc(const uintptr_t bytes,\n                                            void *src){\n    memory_v *mem = malloc(bytes, src);\n\n    mem->mappedPtr = mem->handle;\n\n    return mem;\n  }\n\n  template <>\n  uintptr_t device_t<Pthreads>::memorySize(){\n    return cpu::installedRAM();\n  }\n\n  template <>\n  void device_t<Pthreads>::free(){\n    finish();\n\n    OCCA_EXTRACT_DATA(Pthreads, Device);\n\n    data_.pendingJobsMutex.free();\n    data_.kernelMutex.free();\n\n    delete (PthreadsDeviceData_t*) data;\n  }\n\n  template <>\n  int device_t<Pthreads>::simdWidth(){\n    simdWidth_ = OCCA_SIMD_WIDTH;\n    return OCCA_SIMD_WIDTH;\n  }\n  //==================================\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-occa-0.2.0-5nxq5eiljk2xvfw3jwwnnapbb2n6t4ub/spack-src/include/occa/Serial.hpp": "#ifndef OCCA_SERIAL_HEADER\n#define OCCA_SERIAL_HEADER\n\n#if (OCCA_OS & (LINUX_OS | OSX_OS))\n#  if   (OCCA_OS == LINUX_OS)\n#    include <sys/sysinfo.h>\n#  elif (OCCA_OS == OSX_OS)\n#    include <mach/mach.h>\n#    include <mach/mach_host.h>\n#  endif\n#  if (OCCA_OS != WINUX_OS)\n#    include <sys/sysctl.h>\n#  endif\n#  include <sys/wait.h>\n#  include <dlfcn.h>\n#else\n#  include <windows.h>\n#endif\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n\n#include \"occa/base.hpp\"\n#include \"occa/library.hpp\"\n\nnamespace occa {\n  //---[ Data Structs ]---------------\n  struct SerialKernelData_t {\n    void *dlHandle;\n    handleFunction_t handle;\n\n    void *vArgs[2*OCCA_MAX_ARGS];\n  };\n\n  struct SerialDeviceData_t {\n    int vendor;\n  };\n  //==================================\n\n\n  //---[ Helper Functions ]-----------\n  namespace cpu {\n    namespace vendor {\n      static const int notFound     = 0;\n\n      static const int b_GNU          = 0;\n      static const int b_LLVM         = 1;\n      static const int b_Intel        = 2;\n      static const int b_Pathscale    = 3;\n      static const int b_IBM          = 4;\n      static const int b_PGI          = 5;\n      static const int b_HP           = 6;\n      static const int b_VisualStudio = 7;\n      static const int b_Cray         = 8;\n      static const int b_max          = 9;\n\n      static const int GNU          = (1 << b_GNU);          // gcc    , g++\n      static const int LLVM         = (1 << b_LLVM);         // clang  , clang++\n      static const int Intel        = (1 << b_Intel);        // icc    , icpc\n      static const int Pathscale    = (1 << b_Pathscale);    // pathCC\n      static const int IBM          = (1 << b_IBM);          // xlc    , xlc++\n      static const int PGI          = (1 << b_PGI);          // pgcc   , pgc++\n      static const int HP           = (1 << b_HP);           // aCC\n      static const int VisualStudio = (1 << b_VisualStudio); // cl.exe\n      static const int Cray         = (1 << b_Cray);         // cc     , CC\n    }\n\n    std::string getFieldFrom(const std::string &command,\n                             const std::string &field);\n\n    ///\n    /// Filter output lines from a shell command to extract\n    /// a field/property value (string). Any whitespace\n    /// surrounding the value is clipped. The first match\n    /// is returned (the filter scan terminates).\n    ///\n    /// The returned string is the <value> in this line-match\n    /// pattern:\n    ///\n    ///    ^[WS]*<field>[WS]*<delim>[WS]*<value>[WS]*$\n    ///\n    ///\n    /// If no match is found, the empty string \"\" is returned.\n    ///\n    std::string getField(const std::string &shell_cmd,\n\t\t\t const std::string &field,\n\t\t\t bool ignoreCase = false,\n\t\t\t char delimiter = ':');\n\n    ///\n    /// Get value for CPU info field.\n    ///\n    /// This is essentially only valid for Linux, which\n    /// has /proc/cpuinfo.\n    ///\n    std::string getCPUINFOField(const std::string &field,\n\t\t\t\tbool ignoreCase = false);\n\n    std::string getProcessorName();\n    int getCoreCount();\n    int getProcessorFrequency();\n    std::string getProcessorCacheSize(int level);\n    uintptr_t installedRAM();\n    uintptr_t availableRAM();\n\n    std::string getDeviceListInfo();\n\n    int compilerVendor(const std::string &compiler);\n\n    std::string compilerSharedBinaryFlags(const std::string &compiler);\n    std::string compilerSharedBinaryFlags(const int vendor_);\n\n    void addSharedBinaryFlagsTo(const std::string &compiler, std::string &flags);\n    void addSharedBinaryFlagsTo(const int vendor_, std::string &flags);\n\n    void* malloc(uintptr_t bytes);\n    void free(void *ptr);\n\n    void* dlopen(const std::string &filename,\n                 const std::string &hash = \"\");\n\n    handleFunction_t dlsym(void *dlHandle,\n                           const std::string &functionName,\n                           const std::string &hash = \"\");\n\n    void runFunction(handleFunction_t f,\n                     const int *occaKernelInfoArgs,\n                     int occaInnerId0, int occaInnerId1, int occaInnerId2,\n                     int argc, void **args);\n  }\n  //==================================\n\n\n  //---[ Kernel ]---------------------\n  template <>\n  kernel_t<Serial>::kernel_t();\n\n  template <>\n  kernel_t<Serial>::kernel_t(const kernel_t &k);\n\n  template <>\n  kernel_t<Serial>& kernel_t<Serial>::operator = (const kernel_t<Serial> &k);\n\n  template <>\n  kernel_t<Serial>::kernel_t(const kernel_t<Serial> &k);\n\n  template <>\n  void* kernel_t<Serial>::getKernelHandle();\n\n  template <>\n  void* kernel_t<Serial>::getProgramHandle();\n\n  template <>\n  std::string kernel_t<Serial>::fixBinaryName(const std::string &filename);\n\n  template <>\n  kernel_t<Serial>* kernel_t<Serial>::buildFromSource(const std::string &filename,\n                                                      const std::string &functionName,\n                                                      const kernelInfo &info_);\n\n  template <>\n  kernel_t<Serial>* kernel_t<Serial>::buildFromBinary(const std::string &filename,\n                                                      const std::string &functionName);\n\n  template <>\n  kernel_t<Serial>* kernel_t<Serial>::loadFromLibrary(const char *cache,\n                                                      const std::string &functionName);\n\n  template <>\n  uintptr_t kernel_t<Serial>::maximumInnerDimSize();\n\n  template <>\n  int kernel_t<Serial>::preferredDimSize();\n\n  template <>\n  void kernel_t<Serial>::runFromArguments(const int kArgc, const kernelArg *kArgs);\n\n  template <>\n  void kernel_t<Serial>::free();\n  //==================================\n\n\n  //---[ Memory ]---------------------\n  template <>\n  memory_t<Serial>::memory_t();\n\n  template <>\n  memory_t<Serial>::memory_t(const memory_t &m);\n\n  template <>\n  memory_t<Serial>& memory_t<Serial>::operator = (const memory_t &m);\n\n  template <>\n  void* memory_t<Serial>::getMemoryHandle();\n\n  template <>\n  void* memory_t<Serial>::getTextureHandle();\n\n  template <>\n  void memory_t<Serial>::copyFrom(const void *src,\n                                  const uintptr_t bytes,\n                                  const uintptr_t offset);\n\n  template <>\n  void memory_t<Serial>::copyFrom(const memory_v *src,\n                                  const uintptr_t bytes,\n                                  const uintptr_t destOffset,\n                                  const uintptr_t srcOffset);\n\n  template <>\n  void memory_t<Serial>::copyTo(void *dest,\n                                const uintptr_t bytes,\n                                const uintptr_t destOffset);\n\n  template <>\n  void memory_t<Serial>::copyTo(memory_v *dest,\n                                const uintptr_t bytes,\n                                const uintptr_t srcOffset,\n                                const uintptr_t offset);\n\n  template <>\n  void memory_t<Serial>::asyncCopyFrom(const void *src,\n                                       const uintptr_t bytes,\n                                       const uintptr_t destOffset);\n\n  template <>\n  void memory_t<Serial>::asyncCopyFrom(const memory_v *src,\n                                       const uintptr_t bytes,\n                                       const uintptr_t srcOffset,\n                                       const uintptr_t offset);\n\n  template <>\n  void memory_t<Serial>::asyncCopyTo(void *dest,\n                                     const uintptr_t bytes,\n                                     const uintptr_t offset);\n\n  template <>\n  void memory_t<Serial>::asyncCopyTo(memory_v *dest,\n                                     const uintptr_t bytes,\n                                     const uintptr_t destOffset,\n                                     const uintptr_t srcOffset);\n\n  template <>\n  void memory_t<Serial>::mappedFree();\n\n  template <>\n  void memory_t<Serial>::mappedDetach();\n\n  template <>\n  void memory_t<Serial>::free();\n\n  template <>\n  void memory_t<Serial>::detach();\n  //==================================\n\n\n  //---[ Device ]---------------------\n  template <>\n  device_t<Serial>::device_t();\n\n  template <>\n  device_t<Serial>::device_t(const device_t<Serial> &k);\n\n  template <>\n  device_t<Serial>& device_t<Serial>::operator = (const device_t<Serial> &k);\n\n  template <>\n  void* device_t<Serial>::getContextHandle();\n\n  template <>\n  void device_t<Serial>::setup(argInfoMap &aim);\n\n  template <>\n  void device_t<Serial>::addOccaHeadersToInfo(kernelInfo &info_);\n\n  template <>\n  std::string device_t<Serial>::getInfoSalt(const kernelInfo &info_);\n\n  template <>\n  deviceIdentifier device_t<Serial>::getIdentifier() const;\n\n  template <>\n  void device_t<Serial>::getEnvironmentVariables();\n\n  template <>\n  void device_t<Serial>::appendAvailableDevices(std::vector<device> &dList);\n\n  template <>\n  void device_t<Serial>::setCompiler(const std::string &compiler_);\n\n  template <>\n  void device_t<Serial>::setCompilerEnvScript(const std::string &compilerEnvScript_);\n\n  template <>\n  void device_t<Serial>::setCompilerFlags(const std::string &compilerFlags_);\n\n  template <>\n  void device_t<Serial>::flush();\n\n  template <>\n  void device_t<Serial>::finish();\n\n  template <>\n  void device_t<Serial>::waitFor(streamTag tag);\n\n  template <>\n  stream_t device_t<Serial>::createStream();\n\n  template <>\n  void device_t<Serial>::freeStream(stream_t s);\n\n  template <>\n  stream_t device_t<Serial>::wrapStream(void *handle_);\n\n  template <>\n  streamTag device_t<Serial>::tagStream();\n\n  template <>\n  double device_t<Serial>::timeBetween(const streamTag &startTag, const streamTag &endTag);\n\n  template <>\n  std::string device_t<Serial>::fixBinaryName(const std::string &filename);\n\n  template <>\n  kernel_v* device_t<Serial>::buildKernelFromSource(const std::string &filename,\n                                                    const std::string &functionName,\n                                                    const kernelInfo &info_);\n\n  template <>\n  kernel_v* device_t<Serial>::buildKernelFromBinary(const std::string &filename,\n                                                    const std::string &functionName);\n\n  template <>\n  void device_t<Serial>::cacheKernelInLibrary(const std::string &filename,\n                                              const std::string &functionName,\n                                              const kernelInfo &info_);\n\n  template <>\n  kernel_v* device_t<Serial>::loadKernelFromLibrary(const char *cache,\n                                                    const std::string &functionName);\n\n  template <>\n  memory_v* device_t<Serial>::wrapMemory(void *handle_,\n                                         const uintptr_t bytes);\n\n  template <>\n  memory_v* device_t<Serial>::wrapTexture(void *handle_,\n                                          const int dim, const occa::dim &dims,\n                                          occa::formatType type, const int permissions);\n\n  template <>\n  memory_v* device_t<Serial>::malloc(const uintptr_t bytes,\n                                     void *src);\n\n  template <>\n  memory_v* device_t<Serial>::textureAlloc(const int dim, const occa::dim &dims,\n                                           void *src,\n                                           occa::formatType type, const int permissions);\n\n  template <>\n  memory_v* device_t<Serial>::mappedAlloc(const uintptr_t bytes,\n                                          void *src);\n\n  template <>\n  uintptr_t device_t<Serial>::memorySize();\n\n  template <>\n  void device_t<Serial>::free();\n\n  template <>\n  int device_t<Serial>::simdWidth();\n  //==================================\n}\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-occa-0.2.0-5nxq5eiljk2xvfw3jwwnnapbb2n6t4ub/spack-src/.git/objects/pack/pack-81831707eb6dc58884738ff159f7c698a7f9e2e7.pack",
        "/tmp/vanessa/spack-stage/spack-stage-occa-0.2.0-5nxq5eiljk2xvfw3jwwnnapbb2n6t4ub/spack-src/.git/objects/pack/pack-81831707eb6dc58884738ff159f7c698a7f9e2e7.idx"
    ],
    "total_files": 257
}