{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-occa-1.0.9-kgipn6yy3lz4cxp6mkdqbimmvby2zsct/spack-src/src/modes/serial/device.cpp": "#include <occa/core/base.hpp>\n#include <occa/tools/env.hpp>\n#include <occa/io.hpp>\n#include <occa/tools/sys.hpp>\n#include <occa/modes/serial/device.hpp>\n#include <occa/modes/serial/kernel.hpp>\n#include <occa/modes/serial/memory.hpp>\n#include <occa/modes/serial/stream.hpp>\n#include <occa/modes/serial/streamTag.hpp>\n#include <occa/lang/modes/serial.hpp>\n\nnamespace occa {\n  namespace serial {\n    device::device(const occa::properties &properties_) :\n      occa::modeDevice_t(properties_) {\n\n      int vendor;\n      std::string compiler, compilerFlags, compilerEnvScript;\n\n      if (properties.get<std::string>(\"kernel/compiler\").size()) {\n        compiler = (std::string) properties[\"kernel/compiler\"];\n      } else if (env::var(\"OCCA_CXX\").size()) {\n        compiler = env::var(\"OCCA_CXX\");\n      } else if (env::var(\"CXX\").size()) {\n        compiler = env::var(\"CXX\");\n      } else {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n        compiler = \"g++\";\n#else\n        compiler = \"cl.exe\";\n#endif\n      }\n\n      vendor = sys::compilerVendor(compiler);\n\n      if (properties.get<std::string>(\"kernel/compiler_flags\").size()) {\n        compilerFlags = (std::string) properties[\"kernel/compiler_flags\"];\n      } else if (env::var(\"OCCA_CXXFLAGS\").size()) {\n        compilerFlags = env::var(\"OCCA_CXXFLAGS\");\n      } else if (env::var(\"CXXFLAGS\").size()) {\n        compilerFlags = env::var(\"CXXFLAGS\");\n      } else {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n        compilerFlags = \"-O3\";\n#else\n        compilerFlags = \" /Ox\";\n#endif\n      }\n\n      if (properties.get<std::string>(\"kernel/compiler_env_script\").size()) {\n        compilerEnvScript = (std::string) properties[\"kernel/compiler_env_script\"];\n      } else {\n#if (OCCA_OS == OCCA_WINDOWS_OS)\n        std::string byteness;\n\n        if (sizeof(void*) == 4) {\n          byteness = \"x86 \";\n        } else if (sizeof(void*) == 8) {\n          byteness = \"amd64\";\n        } else {\n          OCCA_FORCE_ERROR(\"sizeof(void*) is not equal to 4 or 8\");\n        }\n#  if   (OCCA_VS_VERSION == 1800)\n        // MSVC++ 12.0 - Visual Studio 2013\n        char *visualStudioTools = getenv(\"VS120COMNTOOLS\");\n#  elif (OCCA_VS_VERSION == 1700)\n        // MSVC++ 11.0 - Visual Studio 2012\n        char *visualStudioTools = getenv(\"VS110COMNTOOLS\");\n#  else (OCCA_VS_VERSION < 1700)\n        // MSVC++ 10.0 - Visual Studio 2010\n        char *visualStudioTools = getenv(\"VS100COMNTOOLS\");\n#  endif\n\n        if (visualStudioTools) {\n          compilerEnvScript = \"\\\"\" + std::string(visualStudioTools) + \"..\\\\..\\\\VC\\\\vcvarsall.bat\\\" \" + byteness;\n        } else {\n          io::stdout << \"WARNING: Visual Studio environment variable not found -> compiler environment (vcvarsall.bat) maybe not correctly setup.\" << std::endl;\n        }\n#endif\n      }\n\n      properties[\"kernel/vendor\"] = vendor;\n      sys::addSharedBinaryFlagsTo(vendor, compilerFlags);\n\n      properties[\"kernel/compiler\"] = compiler;\n      properties[\"kernel/compiler_flags\"] = compilerFlags;\n      properties[\"kernel/compiler_env_script\"] = compilerEnvScript;\n    }\n\n    device::~device() {}\n\n    void device::finish() const {}\n\n    bool device::hasSeparateMemorySpace() const {\n      return false;\n    }\n\n    hash_t device::hash() const {\n      if (!hash_.initialized) {\n        hash_ = occa::hash(\"host\");\n      }\n      return hash_;\n    }\n\n    hash_t device::kernelHash(const occa::properties &props) const {\n      return (\n        occa::hash(props[\"vendor\"])\n        ^ props[\"compiler\"]\n        ^ props[\"compiler_flags\"]\n        ^ props[\"compiler_env_script\"]\n      );\n    }\n\n    //---[ Stream ]---------------------\n    modeStream_t* device::createStream(const occa::properties &props) {\n      return new stream(this, props);\n    }\n\n    occa::streamTag device::tagStream() {\n      return new occa::serial::streamTag(this, sys::currentTime());\n    }\n\n    void device::waitFor(occa::streamTag tag) {}\n\n    double device::timeBetween(const occa::streamTag &startTag,\n                               const occa::streamTag &endTag) {\n      occa::serial::streamTag *srStartTag = (\n        dynamic_cast<occa::serial::streamTag*>(startTag.getModeStreamTag())\n      );\n      occa::serial::streamTag *srEndTag = (\n        dynamic_cast<occa::serial::streamTag*>(endTag.getModeStreamTag())\n      );\n\n      return (srEndTag->time - srStartTag->time);\n    }\n    //==================================\n\n    //---[ Kernel ]---------------------\n    bool device::parseFile(const std::string &filename,\n                           const std::string &outputFile,\n                           const occa::properties &kernelProps,\n                           lang::kernelMetadataMap &metadata) {\n      lang::okl::serialParser parser(kernelProps);\n      parser.parseFile(filename);\n\n      // Verify if parsing succeeded\n      if (!parser.succeeded()) {\n        OCCA_ERROR(\"Unable to transform OKL kernel\",\n                   kernelProps.get(\"silent\", false));\n        return false;\n      }\n\n      if (!io::isFile(outputFile)) {\n        hash_t hash = occa::hash(outputFile);\n        io::lock_t lock(hash, \"serial-parser\");\n        if (lock.isMine()) {\n          parser.writeToFile(outputFile);\n        }\n      }\n\n      parser.setMetadata(metadata);\n\n      return true;\n    }\n\n    modeKernel_t* device::buildKernel(const std::string &filename,\n                                      const std::string &kernelName,\n                                      const hash_t kernelHash,\n                                      const occa::properties &kernelProps) {\n      return buildKernel(filename, kernelName, kernelHash, kernelProps, false);\n    }\n\n    modeKernel_t* device::buildLauncherKernel(const std::string &filename,\n                                              const std::string &kernelName,\n                                              const hash_t kernelHash) {\n      occa::properties kernelProps = properties[\"kernel\"];\n      kernelProps[\"okl\"] = false;\n      return buildKernel(filename, kernelName, kernelHash, kernelProps, true);\n    }\n\n    modeKernel_t* device::buildKernel(const std::string &filename,\n                                      const std::string &kernelName,\n                                      const hash_t kernelHash,\n                                      const occa::properties &kernelProps,\n                                      const bool isLauncherKernel) {\n      const std::string hashDir = io::hashDir(filename, kernelHash);\n\n      const std::string &kcBinaryFile = (\n        isLauncherKernel\n        ? kc::launcherBinaryFile\n        : kc::binaryFile\n      );\n      std::string binaryFilename = hashDir + kcBinaryFile;\n\n      // Check if binary exists and is finished\n      bool foundBinary = (\n        io::cachedFileIsComplete(hashDir, kc::binaryFile)\n        && io::isFile(binaryFilename)\n      );\n\n      io::lock_t lock;\n      if (!foundBinary) {\n        lock = io::lock_t(kernelHash, \"serial-kernel\");\n        foundBinary = !lock.isMine();\n      }\n\n      const bool verbose = kernelProps.get(\"verbose\", false);\n      if (foundBinary) {\n        if (verbose) {\n          io::stdout << \"Loading cached [\"\n                     << kernelName\n                     << \"] from [\"\n                     << io::shortname(filename)\n                     << \"] in [\" << io::shortname(binaryFilename) << \"]\\n\";\n        }\n        modeKernel_t *k = buildKernelFromBinary(binaryFilename,\n                                                kernelName,\n                                                kernelProps);\n        if (k) {\n          k->sourceFilename = filename;\n        }\n        return k;\n      }\n\n      // Cache raw origin\n      std::string sourceFilename = (\n        io::cacheFile(filename,\n                      kc::rawSourceFile,\n                      kernelHash,\n                      assembleKernelHeader(kernelProps))\n      );\n\n      lang::kernelMetadataMap metadata;\n      if (kernelProps.get(\"okl\", true)) {\n        const std::string outputFile = hashDir + kc::sourceFile;\n        bool valid = parseFile(sourceFilename,\n                               outputFile,\n                               kernelProps,\n                               metadata);\n        if (!valid) {\n          return NULL;\n        }\n        sourceFilename = outputFile;\n\n        writeKernelBuildFile(hashDir + kc::buildFile,\n                             kernelHash,\n                             kernelProps,\n                             metadata);\n      }\n\n      std::stringstream command;\n      std::string compilerEnvScript = kernelProps[\"compiler_env_script\"];\n      if (compilerEnvScript.size()) {\n        command << compilerEnvScript << \" && \";\n      }\n\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      command << (std::string) kernelProps[\"compiler\"]\n              << ' '    << (std::string) kernelProps[\"compiler_flags\"]\n              << ' '    << sourceFilename\n              << \" -o \" << binaryFilename\n              << \" -I\"  << env::OCCA_DIR << \"include\"\n              << \" -L\"  << env::OCCA_DIR << \"lib -locca\"\n              << std::endl;\n#else\n      command << kernelProps[\"compiler\"]\n              << \" /D MC_CL_EXE\"\n              << \" /D OCCA_OS=OCCA_WINDOWS_OS\"\n              << \" /EHsc\"\n              << \" /wd4244 /wd4800 /wd4804 /wd4018\"\n              << ' '       << kernelProps[\"compiler_flags\"]\n              << \" /I\"     << env::OCCA_DIR << \"include\"\n              << ' '       << sourceFilename\n              << \" /link \" << env::OCCA_DIR << \"lib/libocca.lib\",\n              << \" /OUT:\"  << binaryFilename\n              << std::endl;\n#endif\n\n      const std::string &sCommand = command.str();\n\n      if (verbose) {\n        io::stdout << \"Compiling [\" << kernelName << \"]\\n\" << sCommand << \"\\n\";\n      }\n\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      const int compileError = system(sCommand.c_str());\n#else\n      const int compileError = system((\"\\\"\" +  sCommand + \"\\\"\").c_str());\n#endif\n\n      lock.release();\n      if (compileError) {\n        OCCA_FORCE_ERROR(\"Error compiling [\" << kernelName << \"],\"\n                         \" Command: [\" << sCommand << ']');\n      }\n\n      modeKernel_t *k = buildKernelFromBinary(binaryFilename,\n                                              kernelName,\n                                              kernelProps,\n                                              metadata[kernelName]);\n      if (k) {\n        io::markCachedFileComplete(hashDir, kcBinaryFile);\n        k->sourceFilename = filename;\n      }\n      return k;\n    }\n\n    modeKernel_t* device::buildKernelFromBinary(const std::string &filename,\n                                                const std::string &kernelName,\n                                                const occa::properties &kernelProps) {\n      std::string buildFile = io::dirname(filename);\n      buildFile += kc::buildFile;\n\n      lang::kernelMetadata metadata;\n      if (io::isFile(buildFile)) {\n        lang::kernelMetadataMap metadataMap = lang::getBuildFileMetadata(buildFile);\n        metadata = metadataMap[kernelName];\n      }\n\n      return buildKernelFromBinary(filename,\n                                   kernelName,\n                                   kernelProps,\n                                   metadata);\n    }\n\n    modeKernel_t* device::buildKernelFromBinary(const std::string &filename,\n                                                const std::string &kernelName,\n                                                const occa::properties &kernelProps,\n                                                lang::kernelMetadata &metadata) {\n      kernel &k = *(new kernel(this,\n                               kernelName,\n                               filename,\n                               kernelProps));\n\n      k.binaryFilename = filename;\n      k.metadata = metadata;\n\n      k.dlHandle = sys::dlopen(filename);\n      k.function = sys::dlsym(k.dlHandle, kernelName);\n\n      return &k;\n    }\n    //==================================\n\n    //---[ Memory ]-------------------\n    modeMemory_t* device::malloc(const udim_t bytes,\n                                 const void *src,\n                                 const occa::properties &props) {\n      memory *mem = new memory(this, bytes, props);\n\n      mem->ptr = (char*) sys::malloc(bytes);\n      if (src) {\n        ::memcpy(mem->ptr, src, bytes);\n      }\n\n      return mem;\n    }\n\n    udim_t device::memorySize() const {\n      return sys::installedRAM();\n    }\n    //==================================\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-occa-1.0.9-kgipn6yy3lz4cxp6mkdqbimmvby2zsct/spack-src/src/tools/sys.cpp": "#include <occa/defines.hpp>\n\n#include <fstream>\n\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n#  include <ctime>\n#  include <cxxabi.h>\n#  include <dlfcn.h>\n#  include <execinfo.h>\n#  include <pthread.h>\n#  include <signal.h>\n#  include <stdio.h>\n#  include <sys/types.h>\n#  include <sys/stat.h>\n#  include <sys/syscall.h>\n#  include <sys/sysctl.h>\n#  include <sys/time.h>\n#  include <unistd.h>\n#  if (OCCA_OS & OCCA_LINUX_OS)\n#    include <errno.h>\n#    include <sys/sysinfo.h>\n#  else // OCCA_MACOS_OS\n#    include <mach/mach_host.h>\n#    ifdef __clang__\n#      include <CoreServices/CoreServices.h>\n#      include <mach/mach_time.h>\n#    else\n#      include <mach/clock.h>\n#      include <mach/mach.h>\n#    endif\n#  endif\n#else // OCCA_WINDOWS_OS\n#  include <windows.h>\n#endif\n\n#include <iomanip>\n#include <sstream>\n\n#include <sys/types.h>\n#include <fcntl.h>\n\n#include <occa/core/base.hpp>\n#include <occa/io.hpp>\n#include <occa/tools/env.hpp>\n#include <occa/tools/hash.hpp>\n#include <occa/tools/exception.hpp>\n#include <occa/tools/lex.hpp>\n#include <occa/tools/misc.hpp>\n#include <occa/tools/string.hpp>\n#include <occa/tools/sys.hpp>\n\nnamespace occa {\n  namespace sys {\n    //---[ System Info ]----------------\n    double currentTime() {\n#if (OCCA_OS & OCCA_LINUX_OS)\n      timespec ct;\n      clock_gettime(CLOCK_MONOTONIC, &ct);\n\n      return (double) (ct.tv_sec + (1.0e-9 * ct.tv_nsec));\n#elif (OCCA_OS == OCCA_MACOS_OS)\n#  ifdef __clang__\n      uint64_t ct;\n      ct = mach_absolute_time();\n\n      const Nanoseconds ct2 = AbsoluteToNanoseconds(*(AbsoluteTime *) &ct);\n\n      return ((double) 1.0e-9) * ((double) ( *((uint64_t*) &ct2) ));\n#  else\n      clock_serv_t cclock;\n      host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &cclock);\n\n      mach_timespec_t ct;\n      clock_get_time(cclock, &ct);\n\n      mach_port_deallocate(mach_task_self(), cclock);\n\n      return (double) (ct.tv_sec + (1.0e-9 * ct.tv_nsec));\n#  endif\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      static LARGE_INTEGER freq;\n      static bool haveFreq = false;\n\n      if (!haveFreq) {\n        QueryPerformanceFrequency(&freq);\n        haveFreq=true;\n      }\n\n      LARGE_INTEGER ct;\n\n      QueryPerformanceCounter(&ct);\n\n      return ((double) (ct.QuadPart)) / ((double) (freq.QuadPart));\n#endif\n    }\n\n    std::string date() {\n      ::time_t time_ = ::time(0);\n      struct ::tm &timeInfo = *(::localtime(&time_));\n      const int year  = timeInfo.tm_year + 1900;\n      const int month = timeInfo.tm_mon + 1;\n      const int day   = timeInfo.tm_mday;\n      const int hour  = timeInfo.tm_hour;\n      const int min   = timeInfo.tm_min;\n      const int sec   = timeInfo.tm_sec;\n\n      std::stringstream ss;\n      ss << year << '/';\n      if (month < 10) ss << '0';\n      ss << month << '/';\n      if (day   < 10) ss << '0';\n      ss << day << ' ';\n      if (hour  < 10) ss << '0';\n      ss << hour << ':';\n      if (min   < 10) ss << '0';\n      ss << min << ':';\n      if (sec   < 10) ss << '0';\n      ss << sec;\n      return ss.str();\n    }\n\n    std::string humanDate() {\n      ::time_t time_ = ::time(0);\n      struct ::tm &timeInfo = *(::localtime(&time_));\n      const int year  = timeInfo.tm_year + 1900;\n      const int month = timeInfo.tm_mon + 1;\n      const int day   = timeInfo.tm_mday;\n      const int hour  = timeInfo.tm_hour;\n      const int min   = timeInfo.tm_min;\n\n      std::stringstream ss;\n\n      switch (month) {\n      case 1 : ss << \"Jan\"; break;\n      case 2 : ss << \"Feb\"; break;\n      case 3 : ss << \"Mar\"; break;\n      case 4 : ss << \"Apr\"; break;\n      case 5 : ss << \"May\"; break;\n      case 6 : ss << \"Jun\"; break;\n      case 7 : ss << \"Jul\"; break;\n      case 8 : ss << \"Aug\"; break;\n      case 9 : ss << \"Sep\"; break;\n      case 10: ss << \"Oct\"; break;\n      case 11: ss << \"Nov\"; break;\n      case 12: ss << \"Dec\"; break;\n      }\n\n      ss << ' ' << day << ' ' << year << ' ';\n      if (hour < 10) ss << '0';\n      ss << hour << ':';\n      if (min  < 10) ss << '0';\n      ss << min;\n\n      return ss.str();\n    }\n    //==================================\n\n    //---[ System Calls ]---------------\n    int call(const std::string &cmdline) {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      FILE *fp = popen(cmdline.c_str(), \"r\");\n      return pclose(fp);\n#else\n      FILE *fp = _popen(cmdline.c_str(), \"r\");\n      return _pclose(fp);\n#endif\n    }\n\n    int call(const std::string &cmdline, std::string &output) {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      FILE *fp = popen(cmdline.c_str(), \"r\");\n#else\n      FILE *fp = _popen(cmdline.c_str(), \"r\");\n#endif\n\n      size_t lineBytes = 512;\n      char lineBuffer[512];\n\n      while (fgets(lineBuffer, lineBytes, fp)) {\n        output += lineBuffer;\n      }\n\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      return pclose(fp);\n#else\n      return _pclose(fp);\n#endif\n    }\n\n    std::string expandEnvVariables(const std::string &str) {\n      const char *c = str.c_str();\n      const char *c0 = c;\n      std::string expstr;\n\n      while (*c != '\\0') {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n        if ((*c == '$') && ((c0 < c) || (*(c - 1) != '\\\\'))) {\n          if (*(c + 1) == '{') {\n            const char *cStart = c + 2;\n            lex::skipTo(c, '}');\n\n            if (*c == '\\0') {\n              return expstr;\n            }\n            expstr += env::var(std::string(cStart, c - cStart));\n          } else {\n            const char *cStart = c + 1;\n            lex::skipTo(c, '/');\n            expstr += env::var(std::string(cStart, c - cStart));\n            if (*c) {\n              expstr += '/';\n            }\n          }\n        }\n#else\n        if (*c == '%') {\n          const char *cStart = (++c);\n          lex::skipTo(c, '%');\n          expstr += env::var(std::string(cStart, c - cStart));\n        }\n#endif\n        else {\n          expstr += *c;\n        }\n        if (*c) {\n          ++c;\n        }\n      }\n\n      return expstr;\n    }\n\n    void rmdir(const std::string &dir,\n               const bool recursive) {\n      if (recursive) {\n        // Remove files\n        strVector files = io::files(dir);\n        const int fileCount = (int) files.size();\n        for (int i = 0; i < fileCount; ++i) {\n          ::remove(files[i].c_str());\n        }\n        // Remove directories\n        strVector directories = io::directories(dir);\n        const int dirCount = (int) directories.size();\n        for (int i = 0; i < dirCount; ++i) {\n          rmdir(directories[i], true);\n        }\n      }\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      ::rmdir(dir.c_str());\n#else\n      ::_rmdir(dir.c_str());\n#endif\n    }\n\n    void rmrf(const std::string &filename) {\n      if (io::isFile(filename)) {\n        ::remove(filename.c_str());\n        return;\n      }\n\n      // Make sure we're not deleting /\n      if (settings().get(\"options/safe-rmrf\", true)) {\n        OCCA_ERROR(\"For safety, not deleting [\" << filename << \"].\"\n                   \" To disable this error, set 'options/safe-rmrf' settings to false\",\n                   isSafeToRmrf(filename));\n      }\n      rmdir(filename, true);\n    }\n\n    bool isSafeToRmrf(const std::string &filename) {\n      const std::string expFilename = io::filename(filename);\n      int depth = 0;\n\n      strVector path = split(expFilename, '/', '\\0');\n      const int pathSize = (int) path.size();\n      for (int i = 0; i < pathSize; ++i) {\n        const std::string &dir = path[i];\n        if (!dir.size() ||\n            (dir == \".\")) {\n          continue;\n        }\n        if (dir == \"..\") {\n          depth -= (depth > 0);\n        } else {\n          ++depth;\n        }\n      }\n\n      return depth > 2;\n    }\n\n    int mkdir(const std::string &dir) {\n      errno = 0;\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      return ::mkdir(dir.c_str(), 0755);\n#else\n      return ::_mkdir(dir.c_str());\n#endif\n    }\n\n    void mkpath(const std::string &dir) {\n      strVector path = split(io::filename(dir), '/', '\\0');\n\n      const int dirCount = (int) path.size();\n      std::string sPath;\n      int makeFrom = -1;\n\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      const int firstDir = 0;\n      if (dirCount == 0)\n        return;\n      sPath += '/';\n#else\n      const int firstDir = 1;\n      if (dirCount <= 1)\n        return;\n      sPath += path[0];\n      sPath += '/';\n#endif\n\n      for (int d = firstDir; d < dirCount; ++d) {\n        sPath += path[d];\n        if (!io::isDir(sPath)) {\n          makeFrom = d;\n          break;\n        }\n        sPath += '/';\n      }\n\n      if (0 < makeFrom) {\n        sys::mkdir(sPath);\n\n        for (int d = (makeFrom + 1); d < dirCount; ++d) {\n          sPath += '/';\n          sPath += path[d];\n\n          sys::mkdir(sPath);\n        }\n      }\n    }\n\n    bool pidExists(const int pid) {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      return !::kill(pid, 0);\n#else\n      HANDLE hProc = OpenProcess(SYNCHRONIZE, FALSE, pid);\n      if (!hProc) {\n        return false; // Process has closed\n      }\n      DWORD ret = WaitForSingleObject(hProc, 0);\n      CloseHandle(hProc);\n      return (ret != WAIT_TIMEOUT);\n#endif\n    }\n\n    int getPID() {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      return getpid();\n#else\n      return GetCurrentProcessId();\n#endif\n    }\n\n    int getTID() {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      return syscall(SYS_gettid);\n#else\n      return GetCurrentThreadId();\n#endif\n    }\n\n    void pinToCore(const int core) {\n      const int coreCount = getCoreCount();\n#if OCCA_UNSAFE\n    ignoreResult(coreCount);\n#endif\n      OCCA_ERROR(\"Core to pin (\" << core << \") is not in range: [0, \"\n                 << coreCount << \"]\",\n                 (0 <= core) && (core < coreCount));\n#if (OCCA_OS == OCCA_LINUX_OS)\n      cpu_set_t cpuSet;\n      CPU_ZERO(&cpuSet);\n      CPU_SET(core, &cpuSet);\n      syscall(__NR_sched_setaffinity, getTID(), sizeof(cpu_set_t), &cpuSet);\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      SetThreadAffinityMask(GetCurrentThread(), ((uint64_t) 1) << core);\n#endif\n    }\n    //==================================\n\n    //---[ Processor Info ]-------------\n    std::string getFieldFrom(const std::string &command,\n                             const std::string &field) {\n#if (OCCA_OS & OCCA_LINUX_OS)\n      std::string shellToolsFile = env::OCCA_DIR + \"include/occa/scripts/shellTools.sh\";\n\n      std::stringstream ss;\n\n      ss << \"echo \\\"(. \" << shellToolsFile << \"; \" << command << \" '\" << field << \"')\\\" | bash\";\n\n      std::string sCommand = ss.str();\n\n      FILE *fp;\n      fp = popen(sCommand.c_str(), \"r\");\n\n      const int bufferSize = 4096;\n      char *buffer = new char[bufferSize];\n\n      ignoreResult( fread(buffer, sizeof(char), bufferSize, fp) );\n\n      pclose(fp);\n\n      int end;\n\n      for (end = 0; end < bufferSize; ++end) {\n        if (buffer[end] == '\\n')\n          break;\n      }\n\n      std::string ret(buffer, end);\n\n      delete [] buffer;\n\n      return ret;\n#else\n      return \"\";\n#endif\n    }\n\n    std::string getProcessorName() {\n#if   (OCCA_OS & OCCA_LINUX_OS)\n      return getFieldFrom(\"getCPUINFOField\", \"model name\");\n#elif (OCCA_OS == OCCA_MACOS_OS)\n      size_t bufferSize = 100;\n      char buffer[100];\n\n      sysctlbyname(\"machdep.cpu.brand_string\",\n                   &buffer, &bufferSize,\n                   NULL, 0);\n\n      return std::string(buffer);\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      char buffer[MAX_COMPUTERNAME_LENGTH + 1];\n      int bytes;\n\n      GetComputerName((LPTSTR) buffer, (LPDWORD) &bytes);\n\n      return std::string(buffer, bytes);\n#endif\n    }\n\n    int getCoreCount() {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      return sysconf(_SC_NPROCESSORS_ONLN);\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      SYSTEM_INFO sysinfo;\n      GetSystemInfo(&sysinfo);\n      return sysinfo.dwNumberOfProcessors;\n#endif\n    }\n\n    int getProcessorFrequency() {\n#if   (OCCA_OS & OCCA_LINUX_OS)\n      std::stringstream ss;\n      float freq = 0;\n\n      ss << getFieldFrom(\"getLSCPUField\", \"cpu.*mhz\");\n      ss >> freq;\n\n      return (int) freq;\n#elif (OCCA_OS == OCCA_MACOS_OS)\n      uint64_t frequency = 0;\n      size_t size = sizeof(frequency);\n\n      int error = sysctlbyname(\"hw.cpufrequency\", &frequency, &size, NULL, 0);\n#if OCCA_UNSAFE\n    ignoreResult(error);\n#endif\n\n      OCCA_ERROR(\"Error getting CPU Frequency.\\n\",\n                 error != ENOMEM);\n\n      return frequency / 1.0e6;\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      LARGE_INTEGER performanceFrequency;\n      QueryPerformanceFrequency(&performanceFrequency);\n\n      return (int) (((double) performanceFrequency.QuadPart) / 1000.0);\n#endif\n    }\n\n    std::string getProcessorCacheSize(int level) {\n#if   (OCCA_OS & OCCA_LINUX_OS)\n      std::stringstream field;\n\n      field << 'L' << level;\n\n      if (level == 1)\n        field << 'd';\n\n      field << \" cache\";\n\n      return getFieldFrom(\"getLSCPUField\", field.str());\n#elif (OCCA_OS == OCCA_MACOS_OS)\n      std::stringstream ss;\n      ss << \"hw.l\" << level;\n\n      if (level == 1)\n        ss << 'd';\n\n      ss << \"cachesize\";\n\n      std::string field = ss.str();\n\n      uint64_t cache = 0;\n      size_t size = sizeof(cache);\n\n      int error = sysctlbyname(field.c_str(), &cache, &size, NULL, 0);\n#if OCCA_UNSAFE\n    ignoreResult(error);\n#endif\n\n      OCCA_ERROR(\"Error getting L\" << level << \" Cache Size.\\n\",\n                 error != ENOMEM);\n\n      return stringifyBytes(cache);\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      std::stringstream ss;\n      DWORD cache = 0;\n      int bytes = 0;\n\n      PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer = NULL;\n\n      GetLogicalProcessorInformation(buffer, (LPDWORD) &bytes);\n\n      OCCA_ERROR(\"[GetLogicalProcessorInformation] Failed\",\n                 (GetLastError() == ERROR_INSUFFICIENT_BUFFER));\n\n      buffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION) sys::malloc(bytes);\n\n      bool passed = GetLogicalProcessorInformation(buffer, (LPDWORD) &bytes);\n\n      OCCA_ERROR(\"[GetLogicalProcessorInformation] Failed\",\n                 passed);\n\n      PSYSTEM_LOGICAL_PROCESSOR_INFORMATION pos = buffer;\n      int off = 0;\n      int sk = sizeof(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION);\n\n      while ((off + sk) <= bytes) {\n        if (pos->Relationship == RelationCache) {\n          CACHE_DESCRIPTOR info = pos->Cache;\n          if (info.Level == level) {\n            cache = info.Size;\n            break;\n          }\n        }\n        ++pos;\n        off += sk;\n      }\n\n      sys::free(buffer);\n\n      return stringifyBytes(cache);\n#endif\n    }\n\n    udim_t installedRAM() {\n#if   (OCCA_OS & OCCA_LINUX_OS)\n      struct sysinfo info;\n\n      const int error = sysinfo(&info);\n\n      if (error != 0) {\n        return 0;\n      }\n\n      return info.totalram;\n#elif (OCCA_OS == OCCA_MACOS_OS)\n      int64_t ram;\n\n      int mib[2]   = {CTL_HW, HW_MEMSIZE};\n      size_t bytes = sizeof(ram);\n\n      sysctl(mib, 2, &ram, &bytes, NULL, 0);\n\n      return ram;\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      return 0;\n#endif\n    }\n\n    udim_t availableRAM() {\n#if   (OCCA_OS & OCCA_LINUX_OS)\n      struct sysinfo info;\n\n      const int error = sysinfo(&info);\n\n      if (error != 0) {\n        return 0;\n      }\n\n      return info.freeram;\n#elif (OCCA_OS == OCCA_MACOS_OS)\n      mach_msg_type_number_t infoCount = HOST_VM_INFO_COUNT;\n      mach_port_t hostPort = mach_host_self();\n\n      vm_statistics_data_t hostInfo;\n      kern_return_t status;\n      vm_size_t pageSize;\n\n      status = host_page_size(hostPort, &pageSize);\n\n      if (status != KERN_SUCCESS)\n        return 0;\n\n      status = host_statistics(hostPort,\n                               HOST_VM_INFO,\n                               (host_info_t) &hostInfo,\n                               &infoCount);\n\n      if (status != KERN_SUCCESS)\n        return 0;\n\n      return (hostInfo.free_count * pageSize);\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      return 0;\n#endif\n    }\n\n    int compilerVendor(const std::string &compiler) {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      const std::string safeCompiler = io::slashToSnake(compiler);\n      int vendor_ = sys::vendor::notFound;\n      std::stringstream ss;\n\n      const std::string compilerVendorTest = env::OCCA_DIR + \"include/occa/scripts/tests/compiler.cpp\";\n      hash_t hash = occa::hashFile(compilerVendorTest);\n      hash ^= occa::hash(compiler);\n\n      const std::string srcFilename = io::cacheFile(compilerVendorTest,\n                                                    \"compilerVendorTest.cpp\",\n                                                    hash);\n      const std::string &hashDir = io::dirname(srcFilename);\n      const std::string binaryFilename   = hashDir + \"binary\";\n      const std::string outFilename      = hashDir + \"output\";\n      const std::string buildLogFilename = hashDir + \"build.log\";\n\n      io::lock_t lock(hash, \"compiler\");\n      if (lock.isMine()\n          && !io::isFile(outFilename)) {\n        ss << compiler\n           << ' '    << srcFilename\n           << \" -o \" << binaryFilename\n           << \" > \" << buildLogFilename << \" 2>&1\";\n        const std::string compileLine = ss.str();\n\n        ignoreResult( system(compileLine.c_str()) );\n\n        OCCA_ERROR(\"Could not compile compilerVendorTest.cpp with following command:\\n\" << compileLine,\n                   io::isFile(binaryFilename));\n\n        int exitStatus = system(binaryFilename.c_str());\n        int vendorBit  = WEXITSTATUS(exitStatus);\n\n        if (vendorBit < sys::vendor::b_max) {\n          vendor_ = (1 << vendorBit);\n        }\n\n        ss.str(\"\");\n        ss << vendor_;\n\n        io::write(outFilename, ss.str());\n\n        return vendor_;\n      }\n\n      ss << io::read(outFilename);\n      ss >> vendor_;\n\n      return vendor_;\n\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n#  if OCCA_USING_VS\n      return sys::vendor::VisualStudio;\n#  endif\n\n      if (compiler.find(\"cl.exe\") != std::string::npos) {\n        return sys::vendor::VisualStudio;\n      }\n#endif\n    }\n\n    std::string compilerSharedBinaryFlags(const std::string &compiler) {\n      return compilerSharedBinaryFlags( sys::compilerVendor(compiler) );\n    }\n\n    std::string compilerSharedBinaryFlags(const int vendor_) {\n      if (vendor_ & (sys::vendor::GNU   |\n                     sys::vendor::LLVM  |\n                     sys::vendor::Intel |\n                     sys::vendor::PGI   |\n                     sys::vendor::Cray  |\n                     sys::vendor::Pathscale)) {\n        return \"-x c++ -fPIC -shared\";\n      } else if (vendor_ & sys::vendor::IBM) {\n        return \"-x c++ -qpic -shared\";\n      } else if (vendor_ & sys::vendor::HP) {\n        return \"+z -b\";\n      } else if (vendor_ & sys::vendor::VisualStudio) {\n        return \"/TP /LD /MD\"; // Note: Use /MDd for debug mode\n      }\n      OCCA_FORCE_ERROR(\"Could not find compiler flags for creating a shared object\");\n      return \"\";\n    }\n\n    void addSharedBinaryFlagsTo(const std::string &compiler, std::string &flags) {\n      addSharedBinaryFlagsTo(sys::compilerVendor(compiler), flags);\n    }\n\n    void addSharedBinaryFlagsTo(const int vendor_, std::string &flags) {\n      std::string sFlags = sys::compilerSharedBinaryFlags(vendor_);\n\n      if (flags.size() == 0) {\n        flags = sFlags;\n      }\n      if (flags.find(sFlags) == std::string::npos) {\n        flags = (sFlags + \" \" + flags);\n      }\n    }\n\n    //---[ Dynamic Methods ]------------\n    void* malloc(udim_t bytes) {\n      void* ptr;\n\n#if   (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      ignoreResult( posix_memalign(&ptr, env::OCCA_MEM_BYTE_ALIGN, bytes) );\n#elif (OCCA_OS == OCCA_WINDOWS_OS)\n      ptr = ::malloc(bytes);\n#endif\n\n      return ptr;\n    }\n\n    void free(void *ptr) {\n      ::free(ptr);\n    }\n\n    void* dlopen(const std::string &filename,\n                 const io::lock_t &lock) {\n\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      void *dlHandle = ::dlopen(filename.c_str(), RTLD_NOW);\n\n      if (dlHandle == NULL) {\n        lock.release();\n        char *error = dlerror();\n        if (error) {\n          OCCA_FORCE_ERROR(\"Error loading binary [\" << io::shortname(filename) << \"] with dlopen: \" << error);\n        } else {\n          OCCA_FORCE_ERROR(\"Error loading binary [\" << io::shortname(filename) << \"] with dlopen\");\n        }\n      }\n#else\n      void *dlHandle = LoadLibraryA(filename.c_str());\n\n      if (dlHandle == NULL) {\n        lock.release();\n        OCCA_ERROR(\"Error loading .dll [\" << io::shortname(filename) << \"]: \" << GetLastError(),\n                   dlHandle != NULL);\n      }\n#endif\n\n      return dlHandle;\n    }\n\n    functionPtr_t dlsym(void *dlHandle,\n                        const std::string &functionName,\n                        const io::lock_t &lock) {\n      OCCA_ERROR(\"dl handle is NULL\",\n                 dlHandle);\n\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      void *sym = ::dlsym(dlHandle, functionName.c_str());\n\n      if (!sym) {\n        lock.release();\n        char *error = dlerror();\n        if (error) {\n          OCCA_FORCE_ERROR(\"Error loading symbol [\" << functionName << \"] from binary with dlsym: \" << error << \"\");\n        } else {\n          OCCA_FORCE_ERROR(\"Error loading symbol [\" << functionName << \"] from binary with dlsym\");\n        }\n      }\n#else\n      void *sym = GetProcAddress((HMODULE) dlHandle, functionName.c_str());\n\n      if (sym == NULL) {\n        lock.release();\n        OCCA_FORCE_ERROR(\"Error loading symbol [\" << functionName << \"] from binary with GetProcAddress\");\n      }\n#endif\n\n      functionPtr_t sym2;\n      ::memcpy(&sym2, &sym, sizeof(sym));\n      return sym2;\n    }\n\n    void dlclose(void *dlHandle) {\n      if (!dlHandle) {\n        return;\n      }\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      ::dlclose(dlHandle);\n#else\n      FreeLibrary((HMODULE) (dlHandle));\n#endif\n    }\n\n    void runFunction(functionPtr_t f, const int argc, void **args) {\n#include \"runFunction.cpp\"\n    }\n\n    std::string stacktrace(const int frameStart,\n                           const std::string indent) {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n      static const int maxFrames = 1024;\n      static void *frames[maxFrames];\n\n      const int frameCount = ::backtrace(frames, maxFrames);\n      char **symbols = ::backtrace_symbols(frames, frameCount);\n\n      const int digits = toString(frameCount - frameStart).size();\n\n      std::stringstream ss;\n      for (int i = frameStart; i < frameCount; ++i) {\n        const std::string localFrame = toString(frameCount - i);\n        ss << indent\n           << std::string(digits - localFrame.size(), ' ')\n           << localFrame\n           << ' '\n           << prettyStackSymbol(frames[i], symbols[i]) << '\\n';\n      }\n      ::free(symbols);\n\n      return ss.str();\n#endif\n    }\n\n    std::string prettyStackSymbol(void *frame, const char *symbol) {\n#if (OCCA_OS == OCCA_MACOS_OS)\n      std::stringstream ss;\n      const char *c = symbol;\n\n      // Skip stack depth\n      lex::skipWhitespace(c);\n      lex::skipToWhitespace(c);\n      lex::skipWhitespace(c);\n\n      // Get origin\n      const char *originStart = c;\n      lex::skipToWhitespace(c);\n      std::string origin(originStart, (c - originStart));\n\n      // Skip address\n      lex::skipWhitespace(c);\n      lex::skipToWhitespace(c);\n      lex::skipWhitespace(c);\n\n      // Get function name\n      const char *functionStart = c;\n      lex::skipToWhitespace(c);\n      std::string function(functionStart, (c - functionStart));\n\n      // Skip the +\n      lex::skipWhitespace(c);\n      lex::skipToWhitespace(c);\n      lex::skipWhitespace(c);\n\n      // Get address offset\n      const char *offsetStart = c;\n      lex::skipToWhitespace(c);\n      std::string offset(offsetStart, (c - offsetStart));\n\n      int status;\n      const char *prettyFunction = abi::__cxa_demangle(function.c_str(),\n                                                       NULL,\n                                                       NULL,\n                                                       &status);\n\n      ss << std::left << std::setw(20) << origin\n         << std::left << std::setw(50) << (status ? function : prettyFunction);\n\n      ::free((void*) prettyFunction);\n\n      return ss.str();\n#elif (OCCA_OS == OCCA_LINUX_OS)\n      std::stringstream ss;\n      std::string function;\n\n      Dl_info frameInfo;\n      int status = dladdr(frame, &frameInfo);\n      const char *dl_name = frameInfo.dli_sname;\n\n      if (status && dl_name) {\n        const char *prettyFunction = abi::__cxa_demangle(dl_name,\n                                                         NULL,\n                                                         NULL,\n                                                         &status);\n\n        if (!status) {\n          function = std::string(prettyFunction);\n        }\n        ::free((void*) prettyFunction);\n      }\n      if (function.size() == 0) {\n        const char *c = symbol;\n        // Get function name\n        lex::skipWhitespace(c);\n        const char *functionStart = c;\n        lex::skipToWhitespace(c);\n        function = std::string(functionStart, (c - functionStart));\n      }\n      return function;\n#else\n      return std::string(symbol);\n#endif\n    }\n  }\n\n  void _message(const std::string &header,\n                const bool exitInFailure,\n                const std::string &filename,\n                const std::string &function,\n                const int line,\n                const std::string &message) {\n\n    exception exp(header,\n                  filename,\n                  function,\n                  line,\n                  message);\n\n    if (exitInFailure) {\n      throw exp;\n    }\n    io::stderr << exp;\n  }\n\n  void warn(const std::string &filename,\n            const std::string &function,\n            const int line,\n            const std::string &message) {\n    _message(\"Warning\", false,\n             filename, function, line, message);\n  }\n\n  void error(const std::string &filename,\n             const std::string &function,\n             const int line,\n             const std::string &message) {\n    _message(\"Error\", true,\n             filename, function, line, message);\n  }\n\n  void printWarning(io::output &out,\n                    const std::string &message,\n                    const std::string &code) {\n    if (code.size()) {\n      out << yellow(\"Warning \" + code);\n    } else {\n      out << yellow(\"Warning\");\n    }\n    out << \": \" << message << '\\n';\n  }\n\n  void printError(io::output &out,\n                  const std::string &message,\n                  const std::string &code) {\n    if (code.size()) {\n      out << red(\"Error \" + code);\n    } else {\n      out << red(\"Error\");\n    }\n    out << \": \" << message << '\\n';\n  }\n\n  mutex::mutex() {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n    int error = pthread_mutex_init(&mutexHandle, NULL);\n#if OCCA_UNSAFE\n    ignoreResult(error);\n#endif\n\n    OCCA_ERROR(\"Error initializing mutex\",\n               error == 0);\n#else\n    mutexHandle = CreateMutex(NULL, FALSE, NULL);\n#endif\n  }\n\n  void mutex::free() {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n    int error = pthread_mutex_destroy(&mutexHandle);\n#if OCCA_UNSAFE\n    ignoreResult(error);\n#endif\n\n    OCCA_ERROR(\"Error freeing mutex\",\n               error == 0);\n#else\n    CloseHandle(mutexHandle);\n#endif\n  }\n\n  void mutex::lock() {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n    pthread_mutex_lock(&mutexHandle);\n#else\n    WaitForSingleObject(mutexHandle, INFINITE);\n#endif\n  }\n\n  void mutex::unlock() {\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n    pthread_mutex_unlock(&mutexHandle);\n#else\n    ReleaseMutex(mutexHandle);\n#endif\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-occa-1.0.9-kgipn6yy3lz4cxp6mkdqbimmvby2zsct/spack-src/include/occa/tools/sys.hpp": "#ifndef OCCA_TOOLS_SYS_HEADER\n#define OCCA_TOOLS_SYS_HEADER\n\n#include <iostream>\n#include <sstream>\n\n#include <occa/defines.hpp>\n#include <occa/types.hpp>\n#include <occa/io/lock.hpp>\n#include <occa/io/output.hpp>\n#include <occa/tools/hash.hpp>\n\nnamespace occa {\n  typedef void (*functionPtr_t)(...);\n\n  namespace sys {\n    namespace vendor {\n      static const int notFound = 0;\n\n      static const int b_GNU          = 0;\n      static const int b_LLVM         = 1;\n      static const int b_Intel        = 2;\n      static const int b_Pathscale    = 3;\n      static const int b_IBM          = 4;\n      static const int b_PGI          = 5;\n      static const int b_HP           = 6;\n      static const int b_VisualStudio = 7;\n      static const int b_Cray         = 8;\n      static const int b_max          = 9;\n\n      static const int GNU          = (1 << b_GNU);          // gcc    , g++\n      static const int LLVM         = (1 << b_LLVM);         // clang  , clang++\n      static const int Intel        = (1 << b_Intel);        // icc    , icpc\n      static const int Pathscale    = (1 << b_Pathscale);    // pathCC\n      static const int IBM          = (1 << b_IBM);          // xlc    , xlc++\n      static const int PGI          = (1 << b_PGI);          // pgcc   , pgc++\n      static const int HP           = (1 << b_HP);           // aCC\n      static const int VisualStudio = (1 << b_VisualStudio); // cl.exe\n      static const int Cray         = (1 << b_Cray);         // cc     , CC\n    }\n\n    //---[ System Info ]----------------\n    double currentTime();\n    std::string date();\n    std::string humanDate();\n    //==================================\n\n    //---[ System Calls ]---------------\n    int call(const std::string &cmdline);\n    int call(const std::string &cmdline, std::string &output);\n\n    std::string expandEnvVariables(const std::string &str);\n\n    void rmdir(const std::string &dir,\n               const bool recursive = false);\n    void rmrf(const std::string &filename);\n    bool isSafeToRmrf(const std::string &filename);\n\n    int mkdir(const std::string &dir);\n    void mkpath(const std::string &dir);\n\n    bool pidExists(const int pid);\n\n    int getPID();\n    int getTID();\n    void pinToCore(const int core);\n    //==================================\n\n    //---[ Processor Info ]-------------\n    std::string getFieldFrom(const std::string &command,\n                             const std::string &field);\n\n    std::string getProcessorName();\n    int getCoreCount();\n    int getProcessorFrequency();\n    std::string getProcessorCacheSize(int level);\n    udim_t installedRAM();\n    udim_t availableRAM();\n\n    int compilerVendor(const std::string &compiler);\n\n    std::string compilerSharedBinaryFlags(const std::string &compiler);\n    std::string compilerSharedBinaryFlags(const int vendor_);\n\n    void addSharedBinaryFlagsTo(const std::string &compiler, std::string &flags);\n    void addSharedBinaryFlagsTo(const int vendor_, std::string &flags);\n    //==================================\n\n    //---[ Dynamic Methods ]------------\n    void* malloc(udim_t bytes);\n    void free(void *ptr);\n\n    void* dlopen(const std::string &filename,\n                 const io::lock_t &lock = io::lock_t());\n\n    functionPtr_t dlsym(void *dlHandle,\n                        const std::string &functionName,\n                        const io::lock_t &lock = io::lock_t());\n\n    void dlclose(void *dlHandle);\n\n    void runFunction(functionPtr_t f, const int argc, void **args);\n\n    std::string stacktrace(const int frameStart = 0,\n                           const std::string indent = \"\");\n\n    std::string prettyStackSymbol(void *frame, const char *symbol);\n    //==================================\n  }\n\n  void _message(const std::string &header,\n                const bool exitInFailure,\n                const std::string &filename,\n                const std::string &function,\n                const int line,\n                const std::string &message);\n\n  void warn(const std::string &filename,\n            const std::string &function,\n            const int line,\n            const std::string &message);\n\n  void error(const std::string &filename,\n             const std::string &function,\n             const int line,\n             const std::string &message);\n\n  void printWarning(io::output &out,\n                    const std::string &message,\n                    const std::string &code = \"\");\n\n  inline void printWarning(const std::string &message,\n                           const std::string &code = \"\") {\n    printWarning(io::stderr, message, code);\n  }\n\n  void printError(io::output &out,\n                  const std::string &message,\n                  const std::string &code = \"\");\n\n  inline void printError(const std::string &message,\n                         const std::string &code = \"\") {\n    printError(io::stderr, message, code);\n  }\n\n  class mutex {\n  public:\n#if (OCCA_OS & (OCCA_LINUX_OS | OCCA_MACOS_OS))\n    pthread_mutex_t mutexHandle;\n#else\n    void *mutexHandle;\n#endif\n\n    mutex();\n    void free();\n\n    void lock();\n    void unlock();\n  };\n}\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-occa-1.0.9-kgipn6yy3lz4cxp6mkdqbimmvby2zsct/spack-src/.git/objects/pack/pack-498dc8563abb60150606ed49bae3e9c87d12757b.idx",
        "/tmp/vanessa/spack-stage/spack-stage-occa-1.0.9-kgipn6yy3lz4cxp6mkdqbimmvby2zsct/spack-src/.git/objects/pack/pack-498dc8563abb60150606ed49bae3e9c87d12757b.pack"
    ],
    "total_files": 604
}