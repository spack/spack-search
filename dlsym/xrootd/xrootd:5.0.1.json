{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.1-763joqbwdzpxoqbjduijsdegace4ajve/spack-src/src/XrdSys/XrdSysPlugin.cc": "/******************************************************************************/\n/*                                                                            */\n/*                       X r d S y s P l u g i n . c c                        */\n/*                                                                            */\n/* (c) 2005 by the Board of Trustees of the Leland Stanford, Jr., University  */\n/*                            All Rights Reserved                             */\n/*   Produced by Andrew Hanushevsky for Stanford University under contract    */\n/*              DE-AC02-76-SFO0515 with the Department of Energy              */\n/*                                                                            */\n/* This file is part of the XRootD software suite.                            */\n/*                                                                            */\n/* XRootD is free software: you can redistribute it and/or modify it under    */\n/* the terms of the GNU Lesser General Public License as published by the     */\n/* Free Software Foundation, either version 3 of the License, or (at your     */\n/* option) any later version.                                                 */\n/*                                                                            */\n/* XRootD is distributed in the hope that it will be useful, but WITHOUT      */\n/* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or      */\n/* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public       */\n/* License for more details.                                                  */\n/*                                                                            */\n/* You should have received a copy of the GNU Lesser General Public License   */\n/* along with XRootD in a file called COPYING.LESSER (LGPL license) and file  */\n/* COPYING (GPL license).  If not, see <http://www.gnu.org/licenses/>.        */\n/*                                                                            */\n/* The copyright holder's institutional names and contributor's names may not */\n/* be used to endorse or promote products derived from this software without  */\n/* specific prior written permission of the institution or contributor.       */\n/******************************************************************************/\n\n// Bypass Solaris ELF madness\n//\n#ifdef __solaris__\n#include <sys/isa_defs.h>\n#if defined(_ILP32) && (_FILE_OFFSET_BITS != 32)\n#undef  _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 32\n#undef  _LARGEFILE_SOURCE\n#endif\n#endif\n\n#ifndef WIN32\n#include <dlfcn.h>\n#if !defined(__APPLE__) && !defined(__CYGWIN__)\n#include <link.h>\n#endif\n#include <stdio.h>\n#include <strings.h>\n#include <sys/types.h>\n#include <errno.h>\n#else\n#include \"XrdSys/XrdWin32.hh\"\n#endif\n  \n#include \"XrdSys/XrdSysError.hh\"\n#include \"XrdSys/XrdSysHeaders.hh\"\n#include \"XrdSys/XrdSysPlatform.hh\"\n#include \"XrdSys/XrdSysPlugin.hh\"\n#include \"XrdVersion.hh\"\n#include \"XrdVersionPlugin.hh\"\n \n/******************************************************************************/\n/*                        S t a t i c   M e m b e r s                         */\n/******************************************************************************/\n\nstruct XrdSysPlugin::PLlist *XrdSysPlugin::plList = 0;\n\n/******************************************************************************/\n/*                            D e s t r u c t o r                             */\n/******************************************************************************/\n  \nXrdSysPlugin::~XrdSysPlugin()\n{\n   if (libHandle) dlclose(libHandle);\n   if (libPath)   free(libPath);\n}\n\n/******************************************************************************/\n/* Private:                   b a d V e r s i o n                             */\n/******************************************************************************/\n  \nXrdSysPlugin::cvResult XrdSysPlugin::badVersion(XrdVersionInfo &urInfo,\n                                                char mmv, int majv, int minv)\n{\n   const char *path;\n   char buff1[512], buff2[128];\n\n   if (minv > 99) minv = 99;\n   snprintf(buff1, sizeof(buff1), \"version %s is incompatible with %s \"\n                                  \"(must be %c= %d.%d.x)\",\n                                   myInfo->vStr, urInfo.vStr, mmv, majv, minv);\n\n   path = msgSuffix(\" in \", buff2, sizeof(buff2));\n\n   Inform(buff1, buff2, path, 0, 0, 1);\n\n   return cvBad;\n}\n  \n/******************************************************************************/\n/* Private:                   c h k V e r s i o n                             */\n/******************************************************************************/\n  \nXrdSysPlugin::cvResult XrdSysPlugin::chkVersion(XrdVersionInfo &urInfo,\n                                                const char     *pname,\n                                                void           *lHandle)\n{\n   static XrdVersionPlugin vInfo[] = {XrdVERSIONPLUGINRULES};\n   static XrdVersionPlugin vNote[] = {XrdVERSIONPLUGINMAXIMS};\n   XrdVersionPlugin *vinP;\n   char buff[1024], vName[256];\n   void *vP;\n   int  i, n=0, pMajor, vMajor, pMinor, vMinor;\n\n// If no version information supplied, skip version check\n//\n   if (!myInfo) return cvNone;\n\n// Check if we need to check the version here\n//\n   i = 0;\n   while(vInfo[i].pName && strcmp(vInfo[i].pName, pname)) i++;\n\n// If we didn't find it in the rules table then try to match the maxims\n//\n   if (!vInfo[i].pName)\n      {i = 0; n = strlen(pname);\n       while(vNote[i].pName)\n            {if ((vNote[i].vPfxLen + vNote[i].vSfxLen <= n)\n             &&  !strncmp(vNote[i].pName, pname, vNote[i].vPfxLen)\n             &&  !strncmp(vNote[i].pName+vNote[i].vPfxLen,\n                   pname + n - vNote[i].vSfxLen, vNote[i].vSfxLen)) break;\n             i++;\n            }\n             vinP = &vNote[i];\n      } else vinP = &vInfo[i];\n\n   if (!(vinP->pName)) return cvNone;\n   if ( vinP->vProcess == XrdVERSIONPLUGIN_DoNotChk) return cvDirty;\n\n// Construct the version entry point\n//\n   if (!n) n = strlen(pname);\n   if (n+sizeof(XrdVERSIONINFOSFX) > sizeof(vName))\n      return libMsg(\"Unable to generate version name for\", \"%s in \", pname);\n   strcpy(vName, pname); strcpy(vName+n, XrdVERSIONINFOSFX);\n\n// Find the version number\n//\n   if (!(vP = dlsym(lHandle, vName)))\n      {if (vinP->vProcess != XrdVERSIONPLUGIN_Required) return cvMissing;\n       return libMsg(dlerror(),\" required version information for %s in \",pname);\n      }\n\n// Extract the version number from the plugin and do a quick check. We use\n// memcpy to avoid instances where the symbol is wrongly defined. Make sure\n// the version string ends with a null by copying one less byte than need be.\n// The caller provided a struct that is gauranteed to end with nulls.\n//\n   memcpy(static_cast<void*>( &urInfo ), vP, sizeof(XrdVersionInfo)-1);\n\n// If version numbers are identical then we are done\n//\n   if (myInfo->vNum == urInfo.vNum)\n      if (myInfo->vNum != XrdVNUMUNK\n      ||  !strcmp(myInfo->vStr + (myInfo->vOpt & 0x0f)+1,\n                  urInfo. vStr + (urInfo. vOpt & 0x0f)+1)) return cvClean;\n\n// If the caller or plugin is unreleased, just issue a warning.\n//\n   if (myInfo->vNum == XrdVNUMUNK || urInfo.vNum == XrdVNUMUNK)\n      {if (eDest)\n          {char mBuff[128];\n           snprintf(buff, sizeof(buff), \"%s%s is using %s%s version\",\n                   (myInfo->vNum == XrdVNUMUNK ? \"unreleased \":\"\"),myInfo->vStr,\n                   (urInfo.vNum  == XrdVNUMUNK ? \"unreleased \":\"\"),urInfo.vStr);\n           msgSuffix(\" in \", mBuff, sizeof(mBuff));\n           Inform(buff, mBuff, libPath);\n          }\n       return cvDirty;\n      }\n\n// Extract version numbers\n//\n   vMajor = XrdMajorVNUM(myInfo->vNum);\n   vMinor = XrdMinorVNUM(myInfo->vNum);\n   pMajor = XrdMajorVNUM(urInfo. vNum);\n   pMinor = XrdMinorVNUM(urInfo. vNum);\n\n// The major version must always be compatible\n//\n   if ((vinP->vMajLow >= 0 && pMajor <  vinP->vMajLow)\n   ||  (vinP->vMajLow <  0 && pMajor != vMajor))\n      return badVersion(urInfo, '>', vinP->vMajLow, vinP->vMinLow);\n\n// The major version may not be greater than our versin\n//\n   if (pMajor > vMajor) return badVersion(urInfo, '<', vMajor, vMinor);\n\n// If we do not need to check minor versions then we are done\n//\n   if (vinP->vMinLow > 99) return cvClean;\n\n// In no case can the plug-in mnor version be greater than our version\n//\n   if (pMajor == vMajor && pMinor > vMinor)\n      return badVersion(urInfo, '<', vMajor, vMinor);\n\n// Verify compatible minor versions\n//\n   if ((vinP->vMinLow >= 0 && pMinor >= vinP->vMinLow)\n   ||  (vinP->vMinLow <  0 && pMinor == vMinor)) return cvClean;\n\n// Incompatible versions\n//\n   return badVersion(urInfo, '>', vinP->vMajLow, vinP->vMinLow);\n}\n\n/******************************************************************************/\n/* Private:                      D L F l a g s                                */\n/******************************************************************************/\n  \nint XrdSysPlugin::DLflags()\n{\n#if    defined(__APPLE__)\n       return RTLD_FIRST;\n#elif  defined(__linux__)\n       return RTLD_NOW;\n#else\n       return RTLD_NOW;\n#endif\n}\n\n/******************************************************************************/\n/* Private:                         F i n d                                   */\n/******************************************************************************/\n  \nvoid *XrdSysPlugin::Find(const char *libpath)\n{\n   struct PLlist *plP = plList;\n\n// Find the library in the preload list\n//\n   while(plP && strcmp(libpath, plP->libPath)) plP = plP->next;\n\n// Return result\n//\n  return (plP ? plP->libHandle : 0);\n}\n\n/******************************************************************************/\n/*                            g e t L i b r a r y                             */\n/******************************************************************************/\n  \nvoid *XrdSysPlugin::getLibrary(bool allMsgs, bool global)\n{\n   void *myHandle;\n   int   flags;\n\n// Check if we should use the preload list\n//\n   if (!(myHandle = libHandle) && plList) myHandle = Find(libPath);\n\n// If already open, return the handle\n//\n   if (myHandle) return myHandle;\n\n// If no path is given then we want to just search the executable. This is easy\n// for some platforms and more difficult for others. So, we do the best we can.\n//\n   if (libPath) flags = DLflags();\n      else {    flags = RTLD_NOW;\n#ifndef WIN32\n                flags|= global ? RTLD_GLOBAL : RTLD_LOCAL;\n#else\n            if (global && eDest) eDest->Emsg(\"getPlugin\",\n               \"request for global symbols unsupported under Windows - ignored\");\n#endif\n      }\n\n// Try to open this library or the executable image\n//\n   if ((myHandle = dlopen(libPath, flags))) libHandle = myHandle;\n      else {const char *eTxt = dlerror();\n            if (strcasestr(eTxt, \"no such file\")) errno = ENOENT;\n               else errno = ENOEXEC;\n            if (allMsgs || errno != ENOENT) libMsg(eTxt, \" loading \");\n           }\n\n// All done\n//\n   return myHandle;\n}\n\n/******************************************************************************/\n/*                             g e t P l u g i n                              */\n/******************************************************************************/\n\nvoid *XrdSysPlugin::getPlugin(const char *pname, int optional)\n{\n   return getPlugin(pname, optional, false);\n}\n\nvoid *XrdSysPlugin::getPlugin(const char *pname, int optional, bool global)\n{\n   XrdVERSIONINFODEF(urInfo, unknown, XrdVNUMUNK, \"\");\n   void *ep, *myHandle;\n   cvResult cvRC;\n\n// Open whatever it is we need to open\n//\n   if (!(myHandle = getLibrary(optional < 2, global))) return 0;\n\n// Get the symbol. In the environment we have defined, null values are not\n// allowed and we will issue an error.\n//\n   if (!(ep = dlsym(myHandle, pname)))\n      {if (optional < 2) libMsg(dlerror(), \" symbol %s in \", pname);\n       return 0;\n      }\n\n// Check if we need to verify version compatability\n//\n   if ((cvRC = chkVersion(urInfo, pname, myHandle)) == cvBad) return 0;\n\n// Print the loaded version unless message is suppressed or not needed\n//\n   if (libPath && optional < 2 && msgCnt\n   &&  (cvRC == cvClean || cvRC == cvMissing))\n      {char buff[128];\n       msgSuffix(\" from \", buff, sizeof(buff));\n       msgCnt--;\n            if (cvRC == cvClean)\n               {const char *wTxt=(urInfo.vNum == XrdVNUMUNK ? \"unreleased \":0);\n                Inform(\"loaded \", wTxt, urInfo.vStr, buff, libPath);\n               }\n       else if (cvRC == cvMissing)\n               {Inform(\"loaded unversioned \", pname, buff, libPath);}\n      }\n\n// All done\n//\n   return ep;\n}\n\n/******************************************************************************/\n/* Private:                       I n f o r m                                 */\n/******************************************************************************/\n\nvoid XrdSysPlugin::Inform(const char *txt1, const char *txt2, const char *txt3,\n                          const char *txt4, const char *txt5, int noHush)\n{\n   const char *eTxt[] = {\"Plugin \",txt1, txt2, txt3, txt4, txt5, 0};\n   char *bP;\n   int n, i, bL;\n\n// Check if we should hush this messages (largely for client-side usage)\n//\n   if (!noHush && getenv(\"XRDPIHUSH\")) return;\n\n// If we have a messaging object, use that\n//\n   if (eDest)\n      {char buff[2048];\n       i = 1; bP = buff; bL = sizeof(buff);\n       while(bL > 1 && eTxt[i])\n            {n = snprintf(bP, bL, \"%s\", eTxt[i]);\n             bP += n; bL -= n; i++;\n            }\n       eDest->Say(\"Plugin \", buff);\n       return;\n      }\n\n// If we have a buffer, set message in the buffer\n//\n   if ((bP = eBuff))\n      {i = 0; bL = eBLen;\n       while(bL > 1 && eTxt[i])\n            {n = snprintf(bP, bL, \"%s\", eTxt[i]);\n             bP += n; bL -= n; i++;\n            }\n      }\n}\n  \n/******************************************************************************/\n/* Private:                       l i b M s g                                 */\n/******************************************************************************/\n  \nXrdSysPlugin::cvResult XrdSysPlugin::libMsg(const char *txt1, const char *txt2,\n                                            const char *mSym)\n{\n   static const char fndg[] = \"Finding\";\n   static const int  flen   = sizeof(\"Finding\");\n   const char *path;\n   char mBuff[512], nBuff[512];\n\n// Check if this is a lookup or open issue. Trim message for the common case.\n//\n        if (mSym)\n           {if (!txt1 || strstr(txt1, \"undefined\"))\n               {txt1 = \"Unable to find\";\n                snprintf(nBuff, sizeof(nBuff), txt2, mSym);\n               } else {\n                strcpy(nBuff, fndg);\n                snprintf(nBuff+flen-1,sizeof(nBuff)-flen,txt2,mSym);\n               }\n            txt2 = nBuff;\n           }\n   else if (!txt1) txt1 = \"Unknown system error!\";\n   else if (strstr(txt1, \"No such file\")) txt1 = \"No such file or directory\";\n   else txt2 = \" \";\n\n// Spit out the message\n//\n   path = msgSuffix(txt2, mBuff, sizeof(mBuff));\n   Inform(txt1, mBuff, path, 0, 0, 1);\n   return cvBad;\n}\n\n/******************************************************************************/\n/* Private:                    m s g S u f f i x                              */\n/******************************************************************************/\n\nconst char *XrdSysPlugin::msgSuffix(const char *Word, char *buff, int bsz)\n{\n   if (libPath) snprintf(buff, bsz,\"%s%s \", Word, libName);\n      else      snprintf(buff, bsz,\"%sexecutable image\", Word);\n   return (libPath ? libPath : \"\");\n}\n  \n/******************************************************************************/\n/*                               P r e l o a d                                */\n/******************************************************************************/\n  \nbool XrdSysPlugin::Preload(const char *path,  char *ebuff, int eblen)\n{\n   struct PLlist *plP;\n   void *myHandle;\n\n// First see if this is already in the preload list\n//\n   if (Find(path)) return true;\n\n// Try to open the library\n//\n   if (!(myHandle = dlopen(path, DLflags())))\n      {if (ebuff && eblen > 0)\n          {const char *dlMsg = dlerror();\n           snprintf(ebuff, eblen, \"Plugin unable to load %s; %s\", path,\n                                  (dlMsg ? dlMsg : \"unknown system error\"));\n          }\n       return false;\n      }\n\n// Add the library handle\n//\n   plP = new PLlist;\n   plP->libHandle = myHandle;\n   plP->libPath   = strdup(path);\n   plP->next      = plList;\n   plList         = plP;\n\n// All done\n//\n   return true;\n}\n\n/******************************************************************************/\n/*                                V e r C m p                                 */\n/******************************************************************************/\n  \nbool XrdSysPlugin::VerCmp(XrdVersionInfo &vInfo1,\n                          XrdVersionInfo &vInfo2, bool noMsg)\n{\n   const char *mTxt;\n   char v1buff[128], v2buff[128];\n   int unRel;\n\n// Do a quick return if the version need not be checked or are equal\n//\n   if (vInfo1.vNum <= 0 || vInfo1.vNum == vInfo2.vNum) return true;\n\n// As it works out, many times two modules wind up in different shared\n// libraries. For consistency we require that both major.minor version be the\n// same unless either is unreleased (i.e. test). Issue warning if need be.\n//\n   mTxt = (vInfo1.vNum == XrdVNUMUNK ? \"unreleased \" : \"\");\n   sprintf(v1buff, \" %sversion %s\", mTxt, vInfo1.vStr);\n   unRel  = *mTxt;\n\n   mTxt = (vInfo2.vNum == XrdVNUMUNK ? \"unreleased \" : \"\");\n   sprintf(v2buff, \" %sversion %s\", mTxt, vInfo2.vStr);\n   unRel |= *mTxt;\n\n   if (unRel || vInfo1.vNum/100 == vInfo2.vNum/100) mTxt = \"\";\n      else mTxt = \" which is incompatible!\";\n\n   if (!noMsg)\n      cerr <<\"Plugin: \" <<v1buff <<\" is using \" <<v2buff <<mTxt <<endl;\n\n   return (*mTxt == 0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.1-763joqbwdzpxoqbjduijsdegace4ajve/spack-src/src/XrdPosix/XrdPosixLinkage.cc": "/******************************************************************************/\n/*                                                                            */\n/*                    X r d P o s i x L i n k a g e . c c                     */\n/*                                                                            */\n/* (c) 2005 by the Board of Trustees of the Leland Stanford, Jr., University  */\n/*                            All Rights Reserved                             */\n/*   Produced by Andrew Hanushevsky for Stanford University under contract    */\n/*              DE-AC02-76-SFO0515 with the Department of Energy              */\n/*                                                                            */\n/* This file is part of the XRootD software suite.                            */\n/*                                                                            */\n/* XRootD is free software: you can redistribute it and/or modify it under    */\n/* the terms of the GNU Lesser General Public License as published by the     */\n/* Free Software Foundation, either version 3 of the License, or (at your     */\n/* option) any later version.                                                 */\n/*                                                                            */\n/* XRootD is distributed in the hope that it will be useful, but WITHOUT      */\n/* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or      */\n/* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public       */\n/* License for more details.                                                  */\n/*                                                                            */\n/* You should have received a copy of the GNU Lesser General Public License   */\n/* along with XRootD in a file called COPYING.LESSER (LGPL license) and file  */\n/* COPYING (GPL license).  If not, see <http://www.gnu.org/licenses/>.        */\n/*                                                                            */\n/* The copyright holder's institutional names and contributor's names may not */\n/* be used to endorse or promote products derived from this software without  */\n/* specific prior written permission of the institution or contributor.       */\n/******************************************************************************/\n\n// Bypass Solaris ELF madness\n//\n#ifdef __solaris__\n#include <sys/isa_defs.h>\n#if defined(_ILP32) && (_FILE_OFFSET_BITS != 32)\n#undef  _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 32\n#undef  _LARGEFILE_SOURCE\n#endif\n#endif\n\n#include <dlfcn.h>\n#if !defined(__APPLE__) && !defined(__CYGWIN__)\n#include <link.h>\n#endif\n\n#include <errno.h>\n\n#include \"XrdSys/XrdSysHeaders.hh\"\n#include \"XrdPosix/XrdPosixLinkage.hh\"\n \n/******************************************************************************/\n/*                   G l o b a l   D e c l a r a t i o n s                    */\n/******************************************************************************/\n  \nXrdPosixLinkage Xunix;\n \n/******************************************************************************/\n/*                          M a c r o   L o a d e r                           */\n/******************************************************************************/\n  \n#define LOOKUP_UNIX(symb) symb = (Retv_ ## symb (*)(Args_ ## symb)) \\\n                                 dlsym(RTLD_NEXT, Symb_ ## symb); \\\n                          if (!symb) {symb = Xrd_U_ ## symb; \\\n                                      Missing(Symb_ ## symb);}\n \n/******************************************************************************/\n/*          U n r e s o l v e d   R e f e r e n c e   L i n k a g e           */\n/******************************************************************************/\n\n      Retv_Access      Xrd_U_Access(Args_Access)\n                         {return (Retv_Access)Xunix.Load_Error(\"access\");}\n      Retv_Acl         Xrd_U_Acl(Args_Acl)\n                         {return (Retv_Acl)Xunix.Load_Error(\"acl\");}\n      Retv_Chdir       Xrd_U_Chdir(Args_Chdir) \n                         {return (Retv_Chdir)Xunix.Load_Error(\"chdir\");}\n      Retv_Close       Xrd_U_Close(Args_Close) \n                         {return (Retv_Close)Xunix.Load_Error(\"close\");}\n      Retv_Closedir    Xrd_U_Closedir(Args_Closedir) \n                         {return (Retv_Closedir)Xunix.Load_Error(\"closedir\");}\n      Retv_Fclose      Xrd_U_Fclose(Args_Fclose)\n                         {return (Retv_Fclose)Xunix.Load_Error(\"fclose\");}\n      Retv_Fcntl       Xrd_U_Fcntl(Args_Fcntl) \n                         {Xunix.Load_Error(\"fcntl\"); return (Retv_Fcntl)0;}\n      Retv_Fcntl64     Xrd_U_Fcntl64(Args_Fcntl64)\n                         {Xunix.Load_Error(\"fcntl\"); return (Retv_Fcntl64)0;}\n      Retv_Fdatasync   Xrd_U_Fdatasync(Args_Fdatasync)\n                         {return (Retv_Fdatasync)Xunix.Load_Error(\"fdatasync\");}\n      Retv_Fflush      Xrd_U_Fflush(Args_Fflush)\n                         {return (Retv_Fflush)Xunix.Load_Error(\"fflush\");}\n      Retv_Fopen       Xrd_U_Fopen(Args_Fopen) \n                         {Xunix.Load_Error(\"fopen\"); return (Retv_Fopen)0;}\n      Retv_Fopen64     Xrd_U_Fopen64(Args_Fopen64)\n                         {Xunix.Load_Error(\"fopen\"); return (Retv_Fopen64)0;}\n      Retv_Fread       Xrd_U_Fread(Args_Fread)\n                         {return (Retv_Fread)Xunix.Load_Error(\"fread\");}\n      Retv_Fseek       Xrd_U_Fseek(Args_Fseek)\n                         {return (Retv_Fseek)Xunix.Load_Error(\"fseek\");}\n      Retv_Fseeko      Xrd_U_Fseeko(Args_Fseeko)\n                         {return (Retv_Fseeko)Xunix.Load_Error(\"fseeko\");}\n      Retv_Fseeko64    Xrd_U_Fseeko64(Args_Fseeko64)\n                         {return (Retv_Fseeko64)Xunix.Load_Error(\"fseeko64\");}\n      Retv_Fstat       Xrd_U_Fstat(Args_Fstat) \n                         {return (Retv_Fstat)Xunix.Load_Error(\"fstat\");}\n      Retv_Fstat64     Xrd_U_Fstat64(Args_Fstat64)\n                         {return (Retv_Fstat64)Xunix.Load_Error(\"fstat64\");}\n      Retv_Fsync       Xrd_U_Fsync(Args_Fsync) \n                         {return (Retv_Fsync)Xunix.Load_Error(\"fsync\");}\n      Retv_Ftell       Xrd_U_Ftell(Args_Ftell)\n                         {return (Retv_Ftell)Xunix.Load_Error(\"ftell\");}\n      Retv_Ftello      Xrd_U_Ftello(Args_Ftello)\n                         {return (Retv_Ftello)Xunix.Load_Error(\"ftello\");}\n      Retv_Ftello64    Xrd_U_Ftello64(Args_Ftello64)\n                         {return (Retv_Ftello64)Xunix.Load_Error(\"ftello64\");}\n      Retv_Ftruncate   Xrd_U_Ftruncate(Args_Ftruncate)\n                         {return (Retv_Ftruncate)Xunix.Load_Error(\"ftruncate\");}\n      Retv_Ftruncate64 Xrd_U_Ftruncate64(Args_Ftruncate64)\n                         {return (Retv_Ftruncate64)Xunix.Load_Error(\"ftruncate64\");}\n      Retv_Fwrite      Xrd_U_Fwrite(Args_Fwrite)\n                         {return (Retv_Fwrite)Xunix.Load_Error(\"fwrite\");}\n      Retv_Fgetxattr   Xrd_U_Fgetxattr(Args_Fgetxattr)\n                         {return (Retv_Fgetxattr)Xunix.Load_Error(\"fgetxattr\");}\n      Retv_Getxattr    Xrd_U_Getxattr(Args_Getxattr)\n                         {return (Retv_Getxattr)Xunix.Load_Error(\"getxattr\");}\n      Retv_Lgetxattr   Xrd_U_Lgetxattr(Args_Lgetxattr)\n                         {return (Retv_Lgetxattr)Xunix.Load_Error(\"lgetxattr\");}\n      Retv_Lseek       Xrd_U_Lseek(Args_Lseek) \n                         {return (Retv_Lseek)Xunix.Load_Error(\"lseek\");}\n      Retv_Lseek64     Xrd_U_Lseek64(Args_Lseek64)\n                         {return (Retv_Lseek64)Xunix.Load_Error(\"lseek\");}\n      Retv_Lstat       Xrd_U_Lstat(Args_Lstat)\n                         {return (Retv_Lstat)Xunix.Load_Error(\"lstat\");}\n      Retv_Lstat64     Xrd_U_Lstat64(Args_Lstat64)\n                         {return (Retv_Lstat64)Xunix.Load_Error(\"lstat\");}\n      Retv_Mkdir       Xrd_U_Mkdir(Args_Mkdir) \n                         {return (Retv_Mkdir)Xunix.Load_Error(\"mkdir\");}\n      Retv_Open        Xrd_U_Open(Args_Open) \n                         {return (Retv_Open)Xunix.Load_Error(\"open\");}\n      Retv_Open64      Xrd_U_Open64(Args_Open64)\n                         {return (Retv_Open64)Xunix.Load_Error(\"open\");}\n      Retv_Opendir     Xrd_U_Opendir(Args_Opendir) \n                         {Xunix.Load_Error(\"opendir\"); return (Retv_Opendir)0;}\n      Retv_Pathconf    Xrd_U_Pathconf(Args_Pathconf)\n                         {return (Retv_Pathconf)Xunix.Load_Error(\"pathconf\");}\n      Retv_Pread       Xrd_U_Pread(Args_Pread)\n                         {return (Retv_Pread)Xunix.Load_Error(\"pread\");}\n      Retv_Pread64     Xrd_U_Pread64(Args_Pread64)\n                         {return (Retv_Pread64)Xunix.Load_Error(\"pread\");}\n      Retv_Pwrite      Xrd_U_Pwrite(Args_Pwrite) \n                         {return (Retv_Pwrite)Xunix.Load_Error(\"pwrite\");}\n      Retv_Pwrite64    Xrd_U_Pwrite64(Args_Pwrite64)\n                         {return (Retv_Pwrite64)Xunix.Load_Error(\"pwrite\");}\n      Retv_Read        Xrd_U_Read(Args_Read) \n                         {return (Retv_Read)Xunix.Load_Error(\"read\");}\n      Retv_Readv       Xrd_U_Readv(Args_Readv) \n                         {return (Retv_Readv)Xunix.Load_Error(\"readv\");}\n      Retv_Readdir     Xrd_U_Readdir(Args_Readdir) \n                         {Xunix.Load_Error(\"readdir\"); return (Retv_Readdir)0;}\n      Retv_Readdir64   Xrd_U_Readdir64(Args_Readdir64)\n                         {Xunix.Load_Error(\"readdir64\");return (Retv_Readdir64)0;}\n      Retv_Readdir_r   Xrd_U_Readdir_r(Args_Readdir_r) \n                         {return (Retv_Readdir_r)Xunix.Load_Error(\"readdir_r\", ELIBACC);}\n      Retv_Readdir64_r Xrd_U_Readdir64_r(Args_Readdir64_r)\n                         {return (Retv_Readdir64_r)Xunix.Load_Error(\"readdir64_r\", ELIBACC);}\n      Retv_Rename      Xrd_U_Rename(Args_Rename)\n                         {return (Retv_Rename)Xunix.Load_Error(\"rename\");}\n      Retv_Rewinddir   Xrd_U_Rewinddir(Args_Rewinddir) \n                         {       Xunix.Load_Error(\"rewinddir\"); abort();}\n      Retv_Rmdir       Xrd_U_Rmdir(Args_Rmdir) \n                         {return (Retv_Rmdir)Xunix.Load_Error(\"rmdir\");}\n      Retv_Seekdir     Xrd_U_Seekdir(Args_Seekdir) \n                         {       Xunix.Load_Error(\"seekdir\"); abort();}\n      Retv_Stat        Xrd_U_Stat(Args_Stat) \n                         {return (Retv_Stat)Xunix.Load_Error(\"stat\");}\n      Retv_Stat64      Xrd_U_Stat64(Args_Stat64)\n                         {return (Retv_Stat64)Xunix.Load_Error(\"stat\");}\n      Retv_Statfs      Xrd_U_Statfs(Args_Statfs)\n                         {return (Retv_Statfs)Xunix.Load_Error(\"statfs\");}\n      Retv_Statfs64    Xrd_U_Statfs64(Args_Statfs64)\n                         {return (Retv_Statfs64)Xunix.Load_Error(\"statfs64\");}\n      Retv_Statvfs     Xrd_U_Statvfs(Args_Statvfs)\n                         {return (Retv_Statvfs)Xunix.Load_Error(\"statvfs\");}\n      Retv_Statvfs64   Xrd_U_Statvfs64(Args_Statvfs64)\n                         {return (Retv_Statvfs64)Xunix.Load_Error(\"statvfs64\");}\n      Retv_Telldir     Xrd_U_Telldir(Args_Telldir) \n                         {return (Retv_Telldir)Xunix.Load_Error(\"telldir\");}\n      Retv_Truncate    Xrd_U_Truncate(Args_Truncate)\n                         {return (Retv_Truncate)Xunix.Load_Error(\"truncate\");}\n      Retv_Truncate64  Xrd_U_Truncate64(Args_Truncate64)\n                         {return (Retv_Truncate64)Xunix.Load_Error(\"truncate64\");}\n      Retv_Unlink      Xrd_U_Unlink(Args_Unlink) \n                         {return (Retv_Unlink)Xunix.Load_Error(\"unlink\");}\n      Retv_Write       Xrd_U_Write(Args_Write) \n                         {return (Retv_Write)Xunix.Load_Error(\"write\");}\n      Retv_Writev      Xrd_U_Writev(Args_Writev) \n                         {return (Retv_Writev)Xunix.Load_Error(\"writev\");}\n  \n/******************************************************************************/\n/*           X r d P o s i x L i n k a g e   C o n s t r u c t o r            */\n/******************************************************************************/\n  \nint XrdPosixLinkage::Resolve()\n{\n  LOOKUP_UNIX(Access)\n  LOOKUP_UNIX(Acl)\n  LOOKUP_UNIX(Chdir)\n  LOOKUP_UNIX(Close)\n  LOOKUP_UNIX(Closedir)\n  LOOKUP_UNIX(Fclose)\n  LOOKUP_UNIX(Fcntl)\n  LOOKUP_UNIX(Fcntl64)\n  LOOKUP_UNIX(Fdatasync)\n  LOOKUP_UNIX(Fflush)\n  LOOKUP_UNIX(Fopen)\n  LOOKUP_UNIX(Fopen64)\n  LOOKUP_UNIX(Fread)\n  LOOKUP_UNIX(Fseek)\n  LOOKUP_UNIX(Fseeko)\n  LOOKUP_UNIX(Fseeko64)\n  LOOKUP_UNIX(Fstat)\n  LOOKUP_UNIX(Fstat64)\n  LOOKUP_UNIX(Fsync)\n  LOOKUP_UNIX(Ftell)\n  LOOKUP_UNIX(Ftello)\n  LOOKUP_UNIX(Ftello64)\n  LOOKUP_UNIX(Ftruncate)\n  LOOKUP_UNIX(Ftruncate64)\n  LOOKUP_UNIX(Fwrite)\n  LOOKUP_UNIX(Fgetxattr)\n  LOOKUP_UNIX(Getxattr)\n  LOOKUP_UNIX(Lgetxattr)\n  LOOKUP_UNIX(Lseek)\n  LOOKUP_UNIX(Lseek64)\n  LOOKUP_UNIX(Lstat)\n  LOOKUP_UNIX(Lstat64)\n  LOOKUP_UNIX(Fsync)\n  LOOKUP_UNIX(Mkdir)\n  LOOKUP_UNIX(Open)\n  LOOKUP_UNIX(Open64)\n  LOOKUP_UNIX(Opendir)\n  LOOKUP_UNIX(Pathconf)\n  LOOKUP_UNIX(Pread)\n  LOOKUP_UNIX(Pread64)\n  LOOKUP_UNIX(Pwrite)\n  LOOKUP_UNIX(Pwrite64)\n  LOOKUP_UNIX(Read)\n  LOOKUP_UNIX(Readv)\n  LOOKUP_UNIX(Readdir)\n  LOOKUP_UNIX(Readdir64)\n  LOOKUP_UNIX(Readdir_r)\n  LOOKUP_UNIX(Readdir64_r)\n  LOOKUP_UNIX(Rename)\n  LOOKUP_UNIX(Rewinddir)\n  LOOKUP_UNIX(Rmdir)\n  LOOKUP_UNIX(Seekdir)\n  LOOKUP_UNIX(Stat)\n  LOOKUP_UNIX(Stat64)\n  LOOKUP_UNIX(Statfs)\n  LOOKUP_UNIX(Statfs64)\n  LOOKUP_UNIX(Statvfs)\n  LOOKUP_UNIX(Statvfs64)\n  LOOKUP_UNIX(Telldir)\n  LOOKUP_UNIX(Truncate)\n  LOOKUP_UNIX(Truncate64)\n  LOOKUP_UNIX(Unlink)\n  LOOKUP_UNIX(Write)\n  LOOKUP_UNIX(Writev)\n  if (getenv(\"XRDPOSIX_REPORT\")) Missing(0);\n  return 1;\n}\n\n/******************************************************************************/\n/*           X r d P o s i x L i n k a g e : : L o a d _ E r r o r            */\n/******************************************************************************/\n  \nint XrdPosixLinkage::Load_Error(const char *epname, int retv)\n{\n    if (*Write != &Xrd_U_Write && *Writev != &Xrd_U_Writev)\n       cerr << \"PosixPreload: Unable to resolve Unix '\" <<epname <<\"()'\" <<endl;\n    errno = ELIBACC;\n    return retv;\n}\n\n/******************************************************************************/\n/*                               M i s s i n g                                */\n/******************************************************************************/\n  \nvoid XrdPosixLinkage::Missing(const char *epname)\n{\n   struct Missing\n         {struct Missing *Next;\n          const char     *What;\n\n                          Missing(Missing *Prev, const char *That)\n                                 : Next(Prev), What(That) {}\n                         ~Missing() {}\n         };\n\n   static Missing *epList = 0;\n\n   if (epname) epList = new Missing(epList, epname);\n      else {Missing *np = epList;\n            while(np) cerr << \"PosixPreload: Unable to resolve Unix '\" \n                           <<np->What <<\"()'\" <<endl;\n            np = np->Next;\n           }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.1-763joqbwdzpxoqbjduijsdegace4ajve/spack-src/src/XrdMacaroons/XrdMacaroons.cc": "\n#include <stdexcept>\n#include <dlfcn.h>\n\n#include \"XrdMacaroonsHandler.hh\"\n#include \"XrdMacaroonsAuthz.hh\"\n\n#include \"XrdOuc/XrdOucEnv.hh\"\n#include \"XrdOuc/XrdOucString.hh\"\n#include \"XrdOuc/XrdOucPinPath.hh\"\n#include \"XrdOuc/XrdOucEnv.hh\"\n#include \"XrdSys/XrdSysError.hh\"\n#include \"XrdSys/XrdSysLogger.hh\"\n#include \"XrdHttp/XrdHttpExtHandler.hh\"\n#include \"XrdAcc/XrdAccAuthorize.hh\"\n#include \"XrdVersion.hh\"\n\nXrdVERSIONINFO(XrdAccAuthorizeObject, XrdMacaroons);\nXrdVERSIONINFO(XrdAccAuthorizeObjAdd, XrdMacaroons);\nXrdVERSIONINFO(XrdHttpGetExtHandler,  XrdMacaroons);\n\n// Trick to access compiled version and directly call for the default object\n// is taken from xrootd-scitokens.\nstatic XrdVERSIONINFODEF(compiledVer, XrdAccTest, XrdVNUMBER, XrdVERSION);\nextern XrdAccAuthorize *XrdAccDefaultAuthorizeObject(XrdSysLogger   *lp,\n                                                     const char     *cfn,\n                                                     const char     *parm,\n                                                     XrdVersionInfo &myVer);\n\n\nextern \"C\" {\n\nXrdAccAuthorize *XrdAccAuthorizeObjAdd(XrdSysLogger *log,\n                                       const char   *config,\n                                       const char   *params,\n                                       XrdOucEnv    * /*not used*/,\n                                       XrdAccAuthorize * chain_authz)\n{\n    try\n    {\n        return new Macaroons::Authz(log, config, chain_authz);\n    }\n    catch (std::runtime_error &e)\n    {\n        XrdSysError err(log, \"macaroons\");\n        err.Emsg(\"Config\", \"Configuration of Macaroon authorization handler failed\", e.what());\n        return NULL;\n    }\n}\n\nXrdAccAuthorize *XrdAccAuthorizeObject(XrdSysLogger *log,\n                                       const char   *config,\n                                       const char   *parms)\n{\n    XrdAccAuthorize *chain_authz;\n\n    if (parms && parms[0]) {\n        XrdOucString parms_str(parms);\n        XrdOucString chained_lib;\n        XrdSysError *err = new XrdSysError(log, \"authlib\");\n        int from = parms_str.tokenize(chained_lib, 0, ' ');\n        const char *chained_parms = NULL;\n        err->Emsg(\"Config\", \"Will chain library\", chained_lib.c_str());\n        if (from > 0)\n        {\n            parms_str.erasefromstart(from);\n            if (parms_str.length())\n            {\n                err->Emsg(\"Config\", \"Will chain parameters\", parms_str.c_str());\n                chained_parms = parms_str.c_str();\n            }\n        }\n        char resolvePath[2048];\n        bool usedAltPath{true};\n        if (!XrdOucPinPath(chained_lib.c_str(), usedAltPath, resolvePath, 2048)) {\n            err->Emsg(\"Config\", \"Failed to locate appropriately versioned chained auth library:\", parms);\n            delete err;\n            return NULL;\n        }\n        void *handle_base = dlopen(resolvePath, RTLD_LOCAL|RTLD_NOW);\n        if (handle_base == NULL) {\n            err->Emsg(\"Config\", \"Failed to base plugin \", resolvePath, dlerror());\n            delete err;\n            return NULL;\n        }\n\n        XrdAccAuthorize *(*ep)(XrdSysLogger *, const char *, const char *);\n        ep = (XrdAccAuthorize *(*)(XrdSysLogger *, const char *, const char *))\n             (dlsym(handle_base, \"XrdAccAuthorizeObject\"));\n        if (!ep)\n        {\n            err->Emsg(\"Config\", \"Unable to chain second authlib after macaroons\", parms);\n            delete err;\n            return NULL;\n        }\n        chain_authz = (*ep)(log, config, chained_parms);\n    }\n    else\n    {\n        chain_authz = XrdAccDefaultAuthorizeObject(log, config, parms, compiledVer);\n    }\n    try\n    {\n        return new Macaroons::Authz(log, config, chain_authz);\n    }\n    catch (std::runtime_error &e)\n    {\n        XrdSysError err(log, \"macaroons\");\n        err.Emsg(\"Config\", \"Configuration of Macaroon authorization handler failed\", e.what());\n        return NULL;\n    }\n}\n\n\nXrdHttpExtHandler *XrdHttpGetExtHandler(\n    XrdSysError *log, const char * config,\n    const char * parms, XrdOucEnv *env)\n{\n    void *authz_raw = env->GetPtr(\"XrdAccAuthorize*\");\n    XrdAccAuthorize *def_authz = static_cast<XrdAccAuthorize *>(authz_raw);\n\n    log->Emsg(\"Initialize\", \"Creating new Macaroon handler object\");\n    try\n    {\n        return new Macaroons::Handler(log, config, env, def_authz);\n    }\n    catch (std::runtime_error &e)\n    {\n        log->Emsg(\"Config\", \"Generation of Macaroon handler failed\", e.what());\n        return NULL;\n    }\n}\n\n\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.1-763joqbwdzpxoqbjduijsdegace4ajve/spack-src/src/XrdHttp/static/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.1-763joqbwdzpxoqbjduijsdegace4ajve/spack-src/src/XrdOss/XrdOssApi.cc",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.1-763joqbwdzpxoqbjduijsdegace4ajve/spack-src/src/XrdOfs/XrdOfsConfigPI.cc",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.1-763joqbwdzpxoqbjduijsdegace4ajve/spack-src/bindings/python/docs/source/.static/img/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.1-763joqbwdzpxoqbjduijsdegace4ajve/spack-src/bindings/python/docs/source/.static/img/xrootd-200x68.png"
    ],
    "total_files": 1416
}