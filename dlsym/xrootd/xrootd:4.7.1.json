{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-4.7.1-6ztgtlw45oyfa6oy2puynzeyzwvbkxxf/spack-src/src/XrdApps/XrdCpy.cc": "/******************************************************************************/\n/*                                                                            */\n/*                             X r d C p y . c c                              */\n/*                                                                            */\n/* (c) 2012 by the Board of Trustees of the Leland Stanford, Jr., University  */\n/*                            All Rights Reserved                             */\n/* Author: Fabrizio Furano (INFN Padova, 2004)                                */\n/*            Modified by Andrew Hanushevsky (2012) under contract            */\n/*              DE-AC02-76-SFO0515 with the Department of Energy              */\n/*                                                                            */\n/* This file is part of the XRootD software suite.                            */\n/*                                                                            */\n/* XRootD is free software: you can redistribute it and/or modify it under    */\n/* the terms of the GNU Lesser General Public License as published by the     */\n/* Free Software Foundation, either version 3 of the License, or (at your     */\n/* option) any later version.                                                 */\n/*                                                                            */\n/* XRootD is distributed in the hope that it will be useful, but WITHOUT      */\n/* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or      */\n/* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public       */\n/* License for more details.                                                  */\n/*                                                                            */\n/* You should have received a copy of the GNU Lesser General Public License   */\n/* along with XRootD in a file called COPYING.LESSER (LGPL license) and file  */\n/* COPYING (GPL license).  If not, see <http://www.gnu.org/licenses/>.        */\n/*                                                                            */\n/* The copyright holder's institutional names and contributor's names may not */\n/* be used to endorse or promote products derived from this software without  */\n/* specific prior written permission of the institution or contributor.       */\n/* Author: Fabrizio Furano (INFN Padova, 2004)                                */\n/*            Modified by Andrew Hanushevsky (2012) under contract            */\n/*              DE-AC02-76-SFO0515 with the Department of Energy              */\n/******************************************************************************/\n  \n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// A cp-like command line tool for xrootd environments                  //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n#include \"XrdClient/XrdClientUrlInfo.hh\"\n#include \"XrdClient/XrdClientReadCache.hh\"\n#include \"XrdSys/XrdSysPthread.hh\"\n#include \"XrdClient/XrdClient.hh\"\n#include \"XrdClient/XrdCpMthrQueue.hh\"\n#include \"XrdClient/XrdClientConn.hh\"\n#include \"XrdClient/XrdClientDebug.hh\"\n#include \"XrdClient/XrdCpWorkLst.hh\"\n#include \"XrdClient/XrdClientEnv.hh\"\n#include \"XrdSys/XrdSysPlatform.hh\"\n\n#include \"XrdClient/XrdClientAbsMonIntf.hh\"\n#include \"XrdClient/XrdcpXtremeRead.hh\"\n\n#include \"XrdCks/XrdCks.hh\"\n#include \"XrdCks/XrdCksCalc.hh\"\n#include \"XrdCks/XrdCksData.hh\"\n\n#include \"XrdApps/XrdCpConfig.hh\"\n#include \"XrdApps/XrdCpFile.hh\"\n\n#include \"XrdOuc/XrdOucTokenizer.hh\"\n#include \"XrdOuc/XrdOucTPC.hh\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sstream>\n#ifndef WIN32\n#include <sys/time.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#endif\n#include <stdarg.h>\n#include <stdio.h>\n#include <sstream>\n\n#ifdef HAVE_LIBZ\n#include <zlib.h>\n#endif\n\n/******************************************************************************/\n/*                  G l o b a l   C o n f i g u r a t i o n                   */\n/******************************************************************************/\n  \nnamespace XrdCopy\n{\nXrdCpConfig  Config(\"xrdcp\");\nXrdCksData   srcCksum, dstCksum;\nXrdCksCalc  *csObj;\nXrdClient   *tpcSrc;\nchar         tpcKey[32];\nlong long    tpcFileSize;\npthread_t    tpcTID;\nint          tpcPB;\nint          isSrv;\nint          isTPC;\nint          getCks;\nint          lenCks;\nint          prtCks;\nint          setCks;\nint          verCks;\nint          xeqCks;\nint          lclCks;\nstatic const int rwMode = kXR_ur | kXR_uw | kXR_gw | kXR_gr | kXR_or;\n}\n\nusing namespace XrdCopy;\n\n#define EMSG(x) {if (isSrv) cout <<Config.Pgm <<\": \" <<x <<endl;\\\n                    else    cerr <<Config.Pgm <<\": \" <<x <<endl;}\n\nextern \"C\" {\n/////////////////////////////////////////////////////////////////////\n// function + macro to allow formatted print via cout,cerr\n/////////////////////////////////////////////////////////////////////\n void cout_print(const char *format, ...)\n {\n    char cout_buff[4096];\n    va_list args;\n    va_start(args, format);\n    vsprintf(cout_buff, format,  args);\n    va_end(args);\n    cout << cout_buff;\n }\n\n   void cerr_print(const char *format, ...)\n   {\n      char cerr_buff[4096];\n      va_list args;\n      va_start(args, format);\n      vsprintf(cerr_buff, format,  args);\n      va_end(args);\n      cerr <<cerr_buff;\n   }\n\n#define COUT(s) do {\t\t\t\t\\\n      cout_print s;\t\t\t\t\\\n   } while (0)\n\n#define CERR(s) do {\t\t\t\t\\\n      cerr_print s;\t\t\t\t\\\n   } while (0)\n\n}\n//////////////////////////////////////////////////////////////////////\n\n\nstruct XrdCpInfo {\n   XrdClient                    *XrdCli;\n   int                          localfile;\n   long long                    len, bread, bwritten;\n   XrdCpMthrQueue               queue;\n   XrdClientAbsMonIntf          *mon;\n\n   XrdCpInfo() : XrdCli(0),localfile(0),len(0),bread(0),bwritten(0),mon(0) {}\n} cpnfo;\n\n#define XRDCP_BLOCKSIZE          (8*1024*1024)\n#define XRDCP_XRDRASIZE          (30*XRDCP_BLOCKSIZE)\n#define XRDCP_VERSION            \"(C) 2004-2011 by the XRootD collaboration. Version: \" XrdVSTRING\n\n///////////////////////////////////////////////////////////////////////\n// Coming from parameters on the cmd line\n\nbool summary=false;            // print summary\nbool progbar=true;             // print progbar\nbool Verbose=true;             // be verbose\n\nXrdOucString monlibname = \"libXrdCpMonitorClient.so\"; // Default name for the ext monitoring lib\n\n// Default open flags for opening a file (xrd)\nkXR_unt16 xrd_wr_flags=kXR_async | kXR_mkpath | kXR_open_updt | kXR_new;\n\n// Flags for open() to force overwriting or not. Default is not.\n#define LOC_WR_FLAGS_FORCE ( O_CREAT | O_WRONLY | O_TRUNC | O_BINARY );\n#define LOC_WR_FLAGS       ( O_CREAT | O_WRONLY | O_EXCL | O_BINARY );\nint loc_wr_flags = LOC_WR_FLAGS;\n\nbool recurse = false;\n\nbool doXtremeCp = false;\nXrdOucString XtremeCpRdr;\n\n///////////////////////\n\n// To compute throughput etc\nstruct timeval abs_start_time;\nstruct timeval abs_stop_time;\nstruct timezone tz;\n\n/******************************************************************************/\n/*                         p r i n t _ s u m m a r y                          */\n/******************************************************************************/\n  \nvoid print_summary(const char* src, const char* dst, unsigned long long bytesread)\n{\n   gettimeofday (&abs_stop_time, &tz);\n   float abs_time=((float)((abs_stop_time.tv_sec- abs_start_time.tv_sec)*1000 +\n                           (abs_stop_time.tv_usec-abs_start_time.tv_usec)/1000));\n\n\n   XrdOucString xsrc(src);\n   XrdOucString xdst(dst);\n   xsrc.erase(xsrc.rfind('?'));\n   xdst.erase(xdst.rfind('?'));\n\n   COUT((\"[xrdcp] #################################################################\\n\"));\n   COUT((\"[xrdcp] # Source Name              : %s\\n\",xsrc.c_str()));\n   COUT((\"[xrdcp] # Destination Name         : %s\\n\",xdst.c_str()));\n   COUT((\"[xrdcp] # Data Copied [bytes]      : %lld\\n\",bytesread));\n   COUT((\"[xrdcp] # Realtime [s]             : %f\\n\",abs_time/1000.0));\n   if (abs_time > 0) {\n      COUT((\"[xrdcp] # Eff.Copy. Rate[MB/s]     : %f\\n\",bytesread/abs_time/1000.0));\n   }\n   if (xeqCks)\n      {static const int Bsz = 64;\n       char Buff[Bsz];\n       dstCksum.Get(Buff,Bsz);\n       COUT((\"[xrdcp] # %8s                 : %s\\n\", dstCksum.Name, Buff));\n      }\n   COUT((\"[xrdcp] #################################################################\\n\"));\n}\n\n/******************************************************************************/\n/*                         p r i n t _ p r o g b a r                          */\n/******************************************************************************/\n  \nvoid print_progbar(unsigned long long bytesread, unsigned long long size) {\n   CERR((\"[xrootd] Total %.02f MB\\t|\",(float)size/1024/1024));\n   for (int l=0; l< 20;l++) {\n      if (l< ( (int)(20.0*bytesread/size)))\n\t CERR((\"=\"));\n      if (l==( (int)(20.0*bytesread/size)))\n\t CERR((\">\"));\n      if (l> ( (int)(20.0*bytesread/size)))\n\t CERR((\".\"));\n   }\n  \n   float abs_time=((float)((abs_stop_time.tv_sec - abs_start_time.tv_sec) *1000 +\n\t\t\t   (abs_stop_time.tv_usec - abs_start_time.tv_usec) / 1000));\n   CERR((\"| %.02f %% [%.01f MB/s]\\r\",100.0*bytesread/size,bytesread/abs_time/1000.0));\n}\n\n/******************************************************************************/\n/*                          p r i n t _ c h k s u m                           */\n/******************************************************************************/\n  \nvoid print_chksum(const char* src, unsigned long long bytesread)\n{\n   const char *csName;\n   char Buff[64];\n   int csLen;\n   XrdOucString xsrc(src);\n   xsrc.erase(xsrc.rfind('?'));\n\n   if (lclCks && csObj)\n      {const void *csVal  = csObj->Final();\n       csName = csObj->Type(csLen);\n       srcCksum.Set(csVal, csLen);\n       srcCksum.Get(Buff, sizeof(Buff));\n      } else {\n       dstCksum.Get(Buff, sizeof(Buff));\n       csName = dstCksum.Name;\n      }\n   cout <<csName <<\": \" <<Buff <<' ' <<xsrc <<' ' <<bytesread <<endl;\n}\n\n/******************************************************************************/\n/*                             d o P r o g B a r                              */\n/******************************************************************************/\n\nvoid *doProgBar(void *Parm)\n{\n   XrdClientUrlInfo *dUrl = (XrdClientUrlInfo *)Parm;\n   XrdClientAdmin Adm(dUrl->GetUrl().c_str());\n   const char *fName = dUrl->File.c_str();\n   long long fSize;\n   long id, flags, mtime;\n\n// Prevent cancelation as the admin client can't handle that\n//\n   pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, 0);\n   pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 0);\n\n// Open a path to the destination\n//\n   if (!Adm.Connect()) return 0;\n\n// Print the progress bar until we are canceled\n//\n   while(Adm.Stat(fName, id, fSize, flags, mtime))\n        {gettimeofday(&abs_stop_time,&tz);\n         print_progbar(fSize, tpcFileSize);\n         pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, 0);\n         pthread_testcancel();\n         sleep(3);\n         pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 0);\n        }\n\n// All done\n//\n   return 0;\n}\n  \n/******************************************************************************/\n/*                           u n d o P r o g B a r                            */\n/******************************************************************************/\n\nvoid undoProgBar(int isOK)\n{\n   void *thret;\n\n   if (tpcPB)\n      {tpcPB = 0;\n       pthread_cancel(tpcTID);\n       pthread_join(tpcTID, &thret);\t\n       if (isOK)\n        {gettimeofday(&abs_stop_time,&tz);\n         print_progbar(tpcFileSize, tpcFileSize);\n        }\n       cerr <<endl;\n      }\n}\n\n/******************************************************************************/\n/*                               c p F a t a l                                */\n/******************************************************************************/\n  \nint cpFatal(const char *Act, XrdClient *cSrc, XrdClient *cDst, const char *hn=0)\n{\n   XrdClient *cObj;\n   const char *Msg;\n\n   if (tpcPB) undoProgBar(0);\n\n   if (cSrc) {cObj = cSrc; Msg = \"Copy from \";}\n      else   {cObj = cDst; Msg = \"Copy to \";}\n\n   if (!hn) hn = cObj->GetCurrentUrl().Host.c_str();\n\n   EMSG(Msg <<hn <<\" failed on \" <<Act <<\"!\");\n   EMSG(ServerError(cObj));\n   return -1;\n}\n  \n/******************************************************************************/\n/*                              g e t F N a m e                               */\n/******************************************************************************/\n  \nconst char *getFName(const char *Url)\n{\n   static char fBuff[2048];\n   const char *Qmark = index(Url, '?');\n\n   if (!Qmark) return Url;\n\n   int n = (Qmark - Url);\n   if (n >= (int)sizeof(fBuff)) n = sizeof(fBuff)-1;\n   strncpy(fBuff, Url, n);\n   fBuff[n] = 0;\n   return fBuff;\n}\n\n/******************************************************************************/\n/*                      R e a d e r T h r e a d _ x r d                       */\n/******************************************************************************/\n\n// The body of a thread which reads from the global\n//  XrdClient and keeps the queue filled\n//____________________________________________________________________________\nvoid *ReaderThread_xrd(void *)\n{\n\n   Info(XrdClientDebug::kHIDEBUG,\n\t\"ReaderThread_xrd\",\n\t\"Reader Thread starting.\");\n   \n   pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, 0);\n   pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 0);\n\n\n   void *buf;\n   long long offs = 0;\n   int nr = 1;\n   long long bread = 0, len = 0;\n   long blksize;\n\n   len = cpnfo.len;\n\n   while ((nr > 0) && (offs < len)) {\n      buf = malloc(XRDCP_BLOCKSIZE);\n      if (!buf) {\n   EMSG(\"Copy failed; out of memory.\");\n   _exit(13);\n      }\n\n      \n      blksize = xrdmin(XRDCP_BLOCKSIZE, len-offs);\n\n      if ( (nr = cpnfo.XrdCli->Read(buf, offs, blksize)) ) {\n         cpnfo.queue.PutBuffer(buf, offs, nr);\n         cpnfo.XrdCli->RemoveDataFromCache(offs, offs+nr-1, false);\n\t bread += nr;\n\t offs += nr;\n      }\n\n      pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, 0);\n      pthread_testcancel();\n      pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 0);\n   }\n\n   cpnfo.bread = bread;\n\n   // This ends the transmission... bye bye\n   cpnfo.queue.PutBuffer(0, 0, 0);\n\n   return 0;\n}\n\n/******************************************************************************/\n/*               R e a d e r T h r e a d _ x r d _ x t r e m e                */\n/******************************************************************************/\n  \n// The body of a thread which reads from the global\n//  XrdClient and keeps the queue filled\n// This is the thread for extreme reads, in this case we may have multiple of these\n// threads, reading the same file from different server endpoints\n//____________________________________________________________________________\nstruct xtreme_threadnfo {\n   XrdXtRdFile *xtrdhandler;\n\n   // The client used by this thread\n   XrdClient *cli;\n\n   // A unique integer identifying the client instance\n   int clientidx;\n\n   // The block from which to start prefetching/reading\n   int startfromblk;\n\n   // Max convenient number of outstanding blks\n   int maxoutstanding;\n}; \nvoid *ReaderThread_xrd_xtreme(void *parm)\n{\n\n   Info(XrdClientDebug::kHIDEBUG,\n\t\"ReaderThread_xrd_xtreme\",\n\t\"Reader Thread starting.\");\n   \n   pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, 0);\n   pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 0);\n\n   void *buf;\n\n   int nr = 1;\n   int noutstanding = 0;\n\n\n   // Which block to read\n   XrdXtRdBlkInfo *blknfo = 0;\n   xtreme_threadnfo *thrnfo = (xtreme_threadnfo *)parm;\n\n   // Block to prefetch\n   int lastprefetched = thrnfo->startfromblk;\n   int lastread = lastprefetched;\n\n   thrnfo->cli->Open(0, 0, true);\n\n   thrnfo->cli->SetCacheParameters(XRDCP_BLOCKSIZE*4*thrnfo->maxoutstanding*2, 0, XrdClientReadCache::kRmBlk_FIFO);\n   if (thrnfo->cli->IsOpen_wait())\n   while (nr > 0) {\n\n      // Keep always some blocks outstanding from the point of view of this reader\n      while (noutstanding < thrnfo->maxoutstanding) {\n         int lp;\n         lp = thrnfo->xtrdhandler->GetBlkToPrefetch(lastprefetched, thrnfo->clientidx, blknfo);\n         if (lp >= 0) {\n            //cout << \"cli: \" << thrnfo->clientidx << \" prefetch: \" << lp << \" offs: \" << blknfo->offs << \" len: \" << blknfo->len << endl;\n            if ( thrnfo->cli->Read_Async(blknfo->offs, blknfo->len) == kOK ) {  \n               lastprefetched = lp;\n               noutstanding++;\n            }\n            else break;\n         }\n         else break;\n      }\n\n      int lr = thrnfo->xtrdhandler->GetBlkToRead(lastread, thrnfo->clientidx, blknfo);\n      if (lr >= 0) {\n\n         buf = malloc(blknfo->len);\n         if (!buf) {\n            EMSG(\"Copy failed; out of memory.\");\n            _exit(13);\n         }\n\n         //cout << \"cli: \" << thrnfo->clientidx << \"     read: \" << lr << \" offs: \" << blknfo->offs << \" len: \" << blknfo->len << endl;\n\n         // It is very important that the search for a blk to read starts from the first block upwards\n         nr = thrnfo->cli->Read(buf, blknfo->offs, blknfo->len);\n         if ( nr >= 0 ) {\n            lastread = lr;\n            noutstanding--;\n\n            // If this block was stolen by somebody else then this client has to be penalized\n            // If this client stole the blk to some other client, then this client has to be rewarded\n            int reward = thrnfo->xtrdhandler->MarkBlkAsRead(lr);\n            if (reward >= 0) \n               // Enqueue the block only if it was not already read\n               cpnfo.queue.PutBuffer(buf, blknfo->offs, nr);\n\n            if (reward > 0) {\n               thrnfo->maxoutstanding++;\n               thrnfo->maxoutstanding = xrdmin(20, thrnfo->maxoutstanding);\n               thrnfo->cli->SetCacheParameters(XRDCP_BLOCKSIZE*4*thrnfo->maxoutstanding*2, 0, XrdClientReadCache::kRmBlk_FIFO);\n            }\n            if (reward < 0) {\n               thrnfo->maxoutstanding--;\n               free(buf);\n            }\n\n            if (thrnfo->maxoutstanding <= 0) {\n               sleep(1);\n               thrnfo->maxoutstanding = 1;\n            }\n\n         }\n\n         // It is very important that the search for a blk to read starts from the first block upwards\n         thrnfo->cli->RemoveDataFromCache(blknfo->offs, blknfo->offs+blknfo->len-1, false);\n      }\n      else {\n\n         if (thrnfo->xtrdhandler->AllDone()) break;\n         pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, 0);\n         sleep(1);\n      }\n\n\n      pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, 0);\n      pthread_testcancel();\n      pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 0);\n   }\n\n   // We get here if there are no more blocks to read or to steal from other readers\n   // This ends the transmission... bye bye\n   cpnfo.queue.PutBuffer(0, 0, 0);\n\n   return 0;\n}\n\n/******************************************************************************/\n/*                      R e a d e r T h r e a d _ l o c                       */\n/******************************************************************************/\n\n// The body of a thread which reads from the global filehandle\n//  and keeps the queue filled\n//____________________________________________________________________________\nvoid *ReaderThread_loc(void *) {\n\n   Info(XrdClientDebug::kHIDEBUG,\n\t\"ReaderThread_loc\",\n\t\"Reader Thread starting.\");\n\n   pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, 0);\n   pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, 0);\n\n   void *buf;\n   long long offs = 0;\n   int nr = 1;\n   long long bread = 0;\n\n   while (nr > 0) {\n      buf = malloc(XRDCP_BLOCKSIZE);\n      if (!buf) {\n         EMSG(\"Copy failed; out of memory.\");\n         _exit(13);\n      }\n\n      //------------------------------------------------------------------------\n      // If this read fails it means that either the program logic is\n      // flawed, or there was a low level hardware failure. In either case\n      // continuing may cause more harm than good.\n      //------------------------------------------------------------------------\n      nr = read( cpnfo.localfile, buf, XRDCP_BLOCKSIZE );\n      if( nr < 0 )\n      {\n        EMSG(strerror( errno ) <<\" reading local file.\");\n        _exit(17);\n      }\n      if( nr > 0)\n      {\n        cpnfo.queue.PutBuffer(buf, offs, nr);\n        bread += nr;\n        offs += nr;\n      }\n   }\n\n   cpnfo.bread = bread;\n\n   // This ends the transmission... bye bye\n   cpnfo.queue.PutBuffer(0, 0, 0);\n\n   return 0;\n}\n\n/******************************************************************************/\n/*                    C r e a t e D e s t P a t h _ l o c                     */\n/******************************************************************************/\n\nint CreateDestPath_loc(XrdOucString path, bool isdir) {\n   // We need the path name without the file\n   if (!isdir) {\n      int pos = path.rfind('/');\n\n      if (pos != STR_NPOS)\n\t path.erase(pos);\n      else path = \"\";\n\n\n   }\n\n   if (path != \"\")\n      return ( MAKEDIR(\n\t\t     path.c_str(),\n\t\t     S_IRUSR | S_IWUSR | S_IXUSR |\n\t\t     S_IRGRP | S_IWGRP | S_IXGRP |\n\t\t     S_IROTH | S_IXOTH)\n\t       );\n   else\n      return 0;\n\n}\n\n/******************************************************************************/\n/*                              g e t C k s u m                               */\n/******************************************************************************/\n  \nint getCksum(XrdCksData &cksData, const char *Path)\n{\n   const char *Lfn;\n   char *csResp, *tP;\n\n// Point to absolute path\n//                    0123456\n   if (!strcmp(Path, \"root://\")) Lfn = Path + 7;\n      else Lfn = Path + 8;\n   if ((Lfn = index(Lfn, '/'))) Lfn++;\n      else Lfn = Path;\n\n// Get the checksum from the server\n//\n   XrdClientAdmin Adm(Path);\n   if (!(Adm.Connect()) || !(Adm.GetChecksum((kXR_char *)Lfn,(kXR_char **)&csResp)))\n      {EMSG(\"Unable to obtain checksum for '\"<< getFName(Path) <<\"'.\");\n       EMSG(Adm.LastServerError()->errmsg);\n       return 0;\n      }\n\n// Get checksum name and make sure it matches\n//\n   XrdOucTokenizer csData(csResp);\n   csData.GetLine();\n   if ((tP = csData.GetToken()) && strcmp(tP, Config.CksData.Name))\n      {EMSG(\"Only \" <<tP <<\" checksums supported by \"\n            <<Adm.GetCurrentUrl().Host.c_str());\n       free(csResp);\n       return 0;\n      }\n\n// Get the token value\n//\n   if (tP && (tP = csData.GetToken()) && !cksData.Set(tP, strlen(tP))) tP = 0;\n\n// Check that all went well\n//\n   if (!tP) EMSG(\"Invalid checksum returned for '\" <<getFName(Path) <<\"'.\");\n\n// Return result\n//\n   free(csResp);\n   return (tP ? 1 : 0);\n}\n\n/******************************************************************************/\n/*                                v a l T P C                                 */\n/******************************************************************************/\n  \nint valTPC(XrdClient *cObj, int isDest)\n{\n   kXR_char qArg[4];\n   kXR_char respBuff[128];\n\n// Ask the sever if it supports tpc\n//\n   strcpy((char *)qArg, \"tpc\");\n   if (cObj->Query(kXR_Qconfig, qArg, respBuff, sizeof(respBuff))\n   &&  isdigit(*respBuff) && atoi((const char *)respBuff) > 0) return 1;\n\n// Nope, we don't support this\n//\n   EMSG(\"Host \" <<cObj->GetCurrentUrl().Host.c_str()\n        <<\" does not support third party copies.\");\n\n// If we are the destination, unlink any partially created file\n//\n   if (isDest)\n      {XrdClientAdmin Adm(cObj->GetCurrentUrl().GetUrl().c_str());\n       if (Adm.Connect()) Adm.Rm(cObj->GetCurrentUrl().File.c_str());\n       // cerr <<cObj->GetCurrentUrl().GetUrl().c_str() <<endl;\n       // cerr <<cObj->GetCurrentUrl().File.c_str() <<endl;\n      }\n\n   return 0;\n}\n\n/******************************************************************************/\n/*                            g e n D e s t C g i                             */\n/******************************************************************************/\n  \nchar *genDestCgi(XrdClient *xrdsrc, const char *src)\n{\n   union {long long intP;\n          int  intV[2];\n         } iKey;\n   XrdClientStatInfo stat;\n   XrdOucString dCGI;\n   int myKey[3];\n   const char *Path, *cksVal, *cgiP;\n   char *qP, aszBuff[128], lfnBuff[1032], cgiBuff[2048];\n\n// Make sure that the source supports 3rd party copy\n//\n   if (!valTPC(xrdsrc, 0)) return 0;\n\n// Extract out the source lfn\n//\n   Path = src + (*src == 'x' ? 8 : 7);\n   if (!(Path = index(Path, '/')))\n      {EMSG(\"Unable to extract lfn from '\" <<getFName(src) <<\"'.\"); return 0;}\n   strncpy(lfnBuff, Path+1, sizeof(lfnBuff));\n   lfnBuff[sizeof(lfnBuff)-1] = 0;\n   if ((qP = index(lfnBuff, '?'))) *qP = 0;\n\n// Generate a key\n//\n   gettimeofday(&abs_start_time,&tz);\n   myKey[0] = abs_start_time.tv_usec;\n   myKey[1] = getpid() | (getppid() << 16);\n   iKey.intP = (long long) &myKey[0];\n   myKey[2] = iKey.intV[0] ^ iKey.intV[1];\n   sprintf(tpcKey, \"%08x%08x%08x\", myKey[0], myKey[1], myKey[2]);\n\n// Check if we should add checksum information\n//\n   cksVal = (verCks ? Config.CksVal : 0);\n\n// Generate the cgi for the destination\n//\n   std::ostringstream o; o << xrdsrc->GetCurrentUrl().Host.c_str() << \":\";\n   o << xrdsrc->GetCurrentUrl().Port;\n   cgiP = XrdOucTPC::cgiC2Dst(tpcKey, o.str().c_str(),\n                              lfnBuff, cksVal, cgiBuff, sizeof(cgiBuff));\n   if (*cgiP == '!')\n      {EMSG(\"Unable to setup destination url. \" <<cgiP+1); return 0;}\n\n// Start the url with the size hint\n//\n   xrdsrc->Stat(&stat);\n   tpcFileSize = static_cast<long long>(stat.size);\n   sprintf(aszBuff, \"?oss.asize=%lld&\", tpcFileSize);\n   dCGI = aszBuff;\n\n// Add all other information\n//\n   if (Config.dstOpq) {dCGI += Config.dstOpq; dCGI += '&';}\n   dCGI += cgiBuff;\n// cerr <<\"Dest url: \" <<dCGI.c_str() <<endl;\n\n// All done\n//\n   return strdup(dCGI.c_str());\n}\n\n/******************************************************************************/\n/*                          d o C p _ x r d 3 x r d                           */\n/******************************************************************************/\n  \nint doCp_xrd3xrd(XrdClient *xrddest, const char *src, const char *dst)\n{\n   struct sdHelper\n         {XrdClient *Src;\n                     sdHelper() : Src(0) {}\n                    ~sdHelper() {if (Src) delete Src;}\n         } Client;\n   XrdClientUrlInfo dUrl;\n   XrdOucString sUrl(tpcSrc->GetCurrentUrl().GetUrl().c_str());\n   XrdOucString *rCGI, dstUrl;\n   int xTTL = -1;\n   const char *cgiP;\n   char cgiBuff[1024];\n\n// Append any redirection cgi information to our source spec\n//\n   rCGI = &(tpcSrc->GetClientConn()->fRedirCGI);\n   if (rCGI->length() > 0)\n      {if (sUrl.find(\"?\") == STR_NPOS) sUrl += '?';\n          else sUrl += '&';\n       sUrl += *rCGI;\n      }\n\n//cerr <<\"tpc: bfr src=\" <<src <<endl;\n//cerr <<\"tpc: bfr dst=\" <<dst <<endl;\n//cerr <<\"tpc: bfr scl=\" <<tpcSrc->GetCurrentUrl().GetUrl().c_str() <<endl;\n//cerr <<\"tpc: bfr dcl=\" <<xrddest->GetCurrentUrl().GetUrl().c_str() <<endl;\n\n// Verify that the destination supports 3rd party stuff\n//\n   if (!valTPC(xrddest, 1)) return 8;\n\n// Generate source cgi string\n//\n   cgiP = XrdOucTPC::cgiC2Src(tpcKey, xrddest->GetCurrentUrl().Host.c_str(),\n                              xTTL, cgiBuff, sizeof(cgiBuff));\n   if (*cgiP == '!')\n      {EMSG(\"Unable to setup source url. \" <<cgiP+1); return 8;}\n\n// Add the cgi string to the source\n//\n   if (sUrl.find(\"?\") == STR_NPOS) sUrl += '?';\n      else sUrl += '&';\n   sUrl += cgiBuff;\n//cerr <<\"tpc: aft scl=\" <<sUrl.c_str()<<endl;\n//cerr <<\"tpc: aft dcl=\" <<xrddest->GetCurrentUrl().GetUrl().c_str() <<endl;\n\n// Open the source\n//\n   Client.Src = new XrdClient(sUrl.c_str());\n   const char *hName = Client.Src->GetCurrentUrl().Host.c_str();\n   if ((!Client.Src->Open(0, kXR_async) ||\n      (Client.Src->LastServerResp()->status != kXR_ok)))\n      return cpFatal(\"open\", Client.Src, 0, hName);\n   \n// Start the progress bar if so wanted\n//\n   tpcPB = !Config.Want(XrdCpConfig::DoNoPbar);\n   if (tpcPB)\n//    {dUrl = xrddest->GetCurrentUrl();\n//cerr <<\"tpc: pbr dcl=\" <<dst<<endl;\n      {dstUrl = dst; dUrl = dstUrl;\n       tpcPB = !XrdSysThread::Run(&tpcTID, doProgBar, (void *)&dUrl,\n                                  XRDSYSTHREAD_HOLD);\n      }\n\n// Now do a sync operation on the destination\n//\n   if (!xrddest->Sync()) return cpFatal(\"rendezvous\", 0, xrddest);\n\n// One more sync will start the copy\n//\n   gettimeofday(&abs_start_time,&tz);\n   if (!xrddest->Sync()) return cpFatal(\"sync\", 0, xrddest);\n\n// Stop the progress bar\n//\n   if (tpcPB) undoProgBar(1);\n\n// Close the file\n//\n   if(!xrddest->Close()) return cpFatal(\"close\", 0, xrddest);\n\n// Do checksum processing\n//\n   if (xeqCks && prtCks)\n      {if (!getCksum(dstCksum, dst)) {EMSG(\"Unable to print checksum!\")}\n          else print_chksum(src, tpcFileSize);\n       if (summary) print_summary(src, dst, tpcFileSize);\n      }\n\n// All done\n//\n   return 0;\n}\n\n/******************************************************************************/\n/*                          d o C p _ x r d 2 x r d                           */\n/******************************************************************************/\n  \nint doCp_xrd2xrd(XrdClient **xrddest, const char *src, const char *dst) {\n   // ----------- xrd to xrd affair\n   pthread_t myTID;\n   XrdClientVector<pthread_t> myTIDVec;\n\n   void *thret;\n   XrdClientStatInfo stat;\n   int retvalue = 0;\n\n// If we need to verify checksums then we will need to get the checksum\n// from the source unless a specific checksum has been specified.\n//\n   if (lclCks) csObj = Config.CksObj;\n      else if (verCks && getCks && !getCksum(srcCksum, src)) return -ENOTSUP;\n\n   gettimeofday(&abs_start_time,&tz);\n\n   // Open the input file (xrdc)\n   // If Xrdcli is non-null, the correct src file has already been opened\n   if (!cpnfo.XrdCli)\n      {cpnfo.XrdCli = new XrdClient(src);\n       const char *hName = cpnfo.XrdCli->GetCurrentUrl().Host.c_str();\n       if ( ( !cpnfo.XrdCli->Open(0, kXR_async) ||\n          (cpnfo.XrdCli->LastServerResp()->status != kXR_ok) ) )\n          {cpFatal(\"open\", cpnfo.XrdCli, 0, hName);\n           delete cpnfo.XrdCli;\n           cpnfo.XrdCli = 0;\n           return 1;\n          }\n      }\n   \n   cpnfo.XrdCli->Stat(&stat);\n   cpnfo.len = stat.size;\n   \n   XrdOucString dest = AddSizeHint( dst, stat.size );\n\n   // if xrddest if nonzero, then the file is already opened for writing\n   if (!*xrddest) {\n      *xrddest = new XrdClient(dest.c_str());\n       const char *hName = (*xrddest)->GetCurrentUrl().Host.c_str();\n      \n      if (!PedanticOpen4Write(*xrddest, rwMode, xrd_wr_flags))\n         {cpFatal(\"open\", 0, *xrddest, hName);\n          delete cpnfo.XrdCli;\n          delete *xrddest;\n          *xrddest = 0;\n          cpnfo.XrdCli = 0;\n          return -1;\n         }\n      \n   }\n   \n   // If the Extreme Copy flag is set, we try to find more sources for this file\n   // Each source gets assigned to a different reader thread\n   XrdClientVector<XrdClient *> xtremeclients;\n   XrdXtRdFile *xrdxtrdfile = 0;\n   \n   if (doXtremeCp) \n      XrdXtRdFile::GetListOfSources(cpnfo.XrdCli, XtremeCpRdr,\n                                    xtremeclients, Config.nSrcs);\n   \n   // Start reader on xrdc\n   if (doXtremeCp && (xtremeclients.GetSize() > 1)) {\n      \n      // Beware... with the extreme copy the normal read ahead mechanism\n      // makes no sense at all.\n      //EnvPutInt(NAME_REMUSEDCACHEBLKS, 1);\n      xrdxtrdfile = new XrdXtRdFile(XRDCP_BLOCKSIZE*4, cpnfo.len);\n      \n      for (int iii = 0; iii < xtremeclients.GetSize(); iii++) {\n         xtreme_threadnfo *nfo = new(xtreme_threadnfo);\n         nfo->xtrdhandler = xrdxtrdfile;\n         nfo->cli = xtremeclients[iii];\n         nfo->clientidx = xrdxtrdfile->GimmeANewClientIdx();\n         nfo->startfromblk = iii*xrdxtrdfile->GetNBlks() / xtremeclients.GetSize();\n         nfo->maxoutstanding = xrdmin( 5, xrdxtrdfile->GetNBlks() / xtremeclients.GetSize() );\n         if (nfo->maxoutstanding < 1) nfo->maxoutstanding = 1;\n\n         XrdSysThread::Run(&myTID, ReaderThread_xrd_xtreme, \n                           (void *)nfo, XRDSYSTHREAD_HOLD);\n         myTIDVec.Push_back(myTID);\n      }\n      \n   }\n   else {\n      XrdSysThread::Run(&myTID,ReaderThread_xrd,(void *)&cpnfo,XRDSYSTHREAD_HOLD);\n      myTIDVec.Push_back(myTID);\n   }\n   \n   int len = 1;\n   void *buf;\n   long long offs = 0;\n   long long bytesread=0;\n   long long size = cpnfo.len;\n   bool draining = false;\n   \n   // Loop to write until ended or timeout err\n   while (1) {\n      \n      if (xrdxtrdfile && xrdxtrdfile->AllDone()) draining = true;\n      if (draining && !cpnfo.queue.GetLength()) break;\n\n      if ( cpnfo.queue.GetBuffer(&buf, offs, len) ) {\n\n         if (len && buf) {\n\n            bytesread+=len;\n            if (progbar) {\n               gettimeofday(&abs_stop_time,&tz);\n               print_progbar(bytesread,size);\n            }\n\n            if (csObj) csObj->Update((const char *)buf,len);\n\n            if (!(*xrddest)->Write(buf, offs, len)) {\n               cpFatal(\"write\", 0, *xrddest);\n               retvalue = 11;\n               break;\n            }\n\n            if (cpnfo.mon)\n               cpnfo.mon->PutProgressInfo(bytesread, cpnfo.len, (float)bytesread / cpnfo.len * 100.0);\n\n            free(buf);\n\n         }\n         else\n            if (!xrdxtrdfile && ( ((buf == 0) && (len == 0)) || (bytesread >= size))) {\n               if (buf) free(buf);\n               break;\n            }\n\n      }\n      else {\n         EMSG(\"Critical read timeout. Unable to read data from the source.\");\n         retvalue = 17;\n         break;\n      }\n\n      buf = 0;\n   }\n\n   if (cpnfo.mon)\n      cpnfo.mon->PutProgressInfo(bytesread, cpnfo.len, (float)bytesread / cpnfo.len * 100.0, 1);\n\n   if(progbar) {\n      cout << endl;\n   }\n\n   if (cpnfo.len != bytesread) {\n      EMSG(\"File length mismatch. Read:\" << bytesread << \" Length:\" << cpnfo.len);\n      retvalue = 13;\n   }\n      \n      for (int i = 0; i < myTIDVec.GetSize(); i++) {\n         pthread_cancel(myTIDVec[i]);\n         pthread_join(myTIDVec[i], &thret);\t \n      }\n\n      delete cpnfo.XrdCli;\n      cpnfo.XrdCli = 0;\n\n   if(!(*xrddest)->Close()) return cpFatal(\"close\", 0, *xrddest);\n\n   delete *xrddest;\n   *xrddest = 0;\n\n   if (!retvalue && xeqCks)\n      {if (!getCksum(dstCksum, dst)) retvalue = -ENOTSUP;\n          else if (verCks && srcCksum != dstCksum)\n                  {EMSG(getFName(dst) <<' ' <<srcCksum.Name <<\" is incorrect!\");\n                   retvalue = -1;\n                  }\n      }\n   if (!retvalue)\n      {if (prtCks) print_chksum(src, bytesread);\n       if (summary) print_summary(src, dst, bytesread);\n      }\n   return retvalue;\n}\n\n/******************************************************************************/\n/*                          d o C p _ x r d 2 l o c                           */\n/******************************************************************************/\n\nint doCp_xrd2loc(const char *src, const char *dst) {\n   // ----------- xrd to loc affair\n   pthread_t myTID;\n   XrdClientVector<pthread_t> myTIDVec;\n\n   void *thret;\n   XrdClientStatInfo stat;\n   int f;\n   int retvalue = 0;\n\n// If we need to verify checksums then we will need to get the checksum\n// from the source unless a specific checksum has been specified.\n//\n   if (xeqCks && getCks && !getCksum(srcCksum, src)) return -ENOTSUP;\n\n   gettimeofday(&abs_start_time,&tz);\n\n   // Open the input file (xrdc)\n   // If Xrdcli is non-null, the correct src file has already been opened\n   if (!cpnfo.XrdCli)\n      {cpnfo.XrdCli = new XrdClient(src);\n       const char *hName = cpnfo.XrdCli->GetCurrentUrl().Host.c_str();\n       if ( ( !cpnfo.XrdCli->Open(0, kXR_async) ||\n          (cpnfo.XrdCli->LastServerResp()->status != kXR_ok) ) )\n          {cpFatal(\"open\", cpnfo.XrdCli, 0, hName);\n           delete cpnfo.XrdCli;\n           cpnfo.XrdCli = 0;\n           return 1;\n          }\n      }\n\n   // Open the output file (loc)\n   cpnfo.XrdCli->Stat(&stat);\n   cpnfo.len = stat.size;\n\n   if (strcmp(dst, \"-\"))\n      // Copy to local fs\n      //unlink(dst);\n     {f = open(getFName(dst), loc_wr_flags,\n          S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);\n      if (f < 0)\n         {EMSG(strerror(errno) <<\" creating '\" <<getFName(dst) <<\"'.\");\n          cpnfo.XrdCli->Close();\n          delete cpnfo.XrdCli;\n          cpnfo.XrdCli = 0;\n          return -1;\n         }\n      if (verCks || lclCks) csObj = Config.CksObj;\n     } else {\n      f = STDOUT_FILENO;  // Copy to stdout\n     }\n\n   // If the Extreme Copy flag is set, we try to find more sources for this file\n   // Each source gets assigned to a different reader thread\n   XrdClientVector<XrdClient *> xtremeclients;\n   XrdXtRdFile *xrdxtrdfile = 0;\n\n   if (doXtremeCp) \n      XrdXtRdFile::GetListOfSources(cpnfo.XrdCli, XtremeCpRdr,\n                                    xtremeclients, Config.nSrcs);\n\n   // Start reader on xrdc\n   if (doXtremeCp && (xtremeclients.GetSize() > 1)) {\n\n      // Beware... with the extreme copy the normal read ahead mechanism\n      // makes no sense at all.\n\n      xrdxtrdfile = new XrdXtRdFile(XRDCP_BLOCKSIZE*4, cpnfo.len);\n\n      for (int iii = 0; iii < xtremeclients.GetSize(); iii++) {\n         xtreme_threadnfo *nfo = new(xtreme_threadnfo);\n         nfo->xtrdhandler = xrdxtrdfile;\n         nfo->cli = xtremeclients[iii];\n         nfo->clientidx = xrdxtrdfile->GimmeANewClientIdx();\n         nfo->startfromblk = iii*xrdxtrdfile->GetNBlks() / xtremeclients.GetSize();\n         nfo->maxoutstanding = xrdmax(xrdmin( 3, xrdxtrdfile->GetNBlks() / xtremeclients.GetSize() ), 1);\n\n         XrdSysThread::Run(&myTID, ReaderThread_xrd_xtreme, \n                           (void *)nfo, XRDSYSTHREAD_HOLD);\n         myTIDVec.Push_back(myTID);\n      }\n\n   }\n   else {\n      doXtremeCp = false;\n      XrdSysThread::Run(&myTID,ReaderThread_xrd,(void *)&cpnfo,XRDSYSTHREAD_HOLD);\n      myTIDVec.Push_back(myTID);\n   }\n\n   int len = 1;\n   void *buf;\n   long long bytesread=0, offs = 0;\n   long long size = cpnfo.len;\n   bool draining = false;\n\n   // Loop to write until ended or timeout err\n   while (1) {\n\n      if (xrdxtrdfile && xrdxtrdfile->AllDone()) draining = true;\n      if (draining && !cpnfo.queue.GetLength()) break;\n\n      if ( cpnfo.queue.GetBuffer(&buf, offs, len) ) {\n\n\t if (len && buf) {\n\n\t    bytesread+=len;\n\t    if (progbar) {\n\t       gettimeofday(&abs_stop_time,&tz);\n\t       print_progbar(bytesread,size);\n\t    }\n\n     if (csObj) csObj->Update((const char *)buf,len);\n\n\t    if (doXtremeCp && (f != STDOUT_FILENO) && lseek(f, offs, SEEK_SET) < 0) {\n\t       EMSG(strerror(errno) <<\" while seeking in '\" << getFName(dst) <<\"'.\");\n\t       retvalue = 10;\n\t       break;\n\t    }\n\t    if (write(f, buf, len) <= 0) {\n\t       EMSG(strerror(errno) <<\" writing to '\" << getFName(dst) <<\"'.\");\n\t       retvalue = 10;\n\t       break;\n\t    }\n\n\t    if (cpnfo.mon)\n\t      cpnfo.mon->PutProgressInfo(bytesread, cpnfo.len, (float)bytesread / cpnfo.len * 100.0);\n\n\t    free(buf);\n\n\t }\n         else\n            if (!xrdxtrdfile && ( ((buf == 0) && (len == 0)) || (bytesread >= size)) ) {\n               if (buf) free(buf);\n               break;\n            }\n\n\n      }\n      else {\n\t EMSG(\"Critical read timeout. Unable to read data from the source.\");\n\t retvalue = 17;\n\t break;\n      }\n\t \n      buf = 0;\n\n   }\n\n   if (cpnfo.mon)\n     cpnfo.mon->PutProgressInfo(bytesread, cpnfo.len, (float)bytesread / cpnfo.len * 100.0, 1);\n\n   if(progbar) {\n      cout << endl;\n   }\n\n   if (cpnfo.len != bytesread)\n      {cpFatal(\"read\", cpnfo.XrdCli, 0);\n       retvalue = 13;\n      }\n\n   if (close(f))\n      {EMSG(strerror(errno) <<\" closing '\" <<getFName(dst) <<\"'.\");\n       retvalue = -1;\n      }\n\n      for (int i = 0; i < myTIDVec.GetSize(); i++) {\n         pthread_cancel(myTIDVec[i]);\n         pthread_join(myTIDVec[i], &thret);\t \n      }\n      delete cpnfo.XrdCli;\n      cpnfo.XrdCli = 0;\n\n   if (!retvalue && xeqCks)\n      {if (!csObj) retvalue = Config.CksMan->Calc(dst, dstCksum, setCks);\n          else {char *csVal = csObj->Final();\n                if (!dstCksum.Set((const void *)csVal, Config.CksLen))\n                   retvalue = -EINVAL;\n               }\n       if (retvalue)\n          {retvalue = (retvalue < 0 ? -retvalue : retvalue);\n           EMSG(strerror(retvalue) <<\" calculating \"\n                <<dstCksum.Name << \" checksum for \" << getFName(dst));\n          } else if (verCks && srcCksum != dstCksum)\n                    {EMSG(getFName(dst) <<' ' <<srcCksum.Name\n                          <<\" checksum is incorrect!\");\n                     retvalue = -1;\n                    }\n      }\n\n   if (!retvalue)\n      {if (prtCks)  print_chksum(src, bytesread);\n       if (summary) print_summary(src, dst, bytesread);\n      }\n\n   return retvalue;\n}\n\n/******************************************************************************/\n/*                          d o C p _ l o c 2 x r d                           */\n/******************************************************************************/\n\nint doCp_loc2xrd(XrdClient **xrddest, const char *src, const char * dst) {\n// ----------- loc to xrd affair\n   pthread_t myTID;\n   void * thret;\n   int retvalue = 0;\n   struct stat stat;\n\n   gettimeofday(&abs_start_time,&tz);\n\n   // Open the input file (loc)\n   cpnfo.localfile = open(src, O_RDONLY | O_BINARY);   \n   if (cpnfo.localfile < 0)\n      {EMSG(strerror(errno) << \" opening '\" << getFName(src) <<\"'.\");\n       cpnfo.localfile = 0;\n       return -1;\n      }\n\n   if (fstat(cpnfo.localfile, &stat))\n      {EMSG(strerror(errno) << \" stating '\" << getFName(src) <<\"'.\");\n       cpnfo.localfile = 0;\n       return -1;\n      }\n\n   XrdOucString dest = AddSizeHint( dst, stat.st_size );\n\n   // if xrddest if nonzero, then the file is already opened for writing\n   if (!*xrddest)\n      {*xrddest = new XrdClient(dest.c_str());\n       const char *hName = (*xrddest)->GetCurrentUrl().Host.c_str();\n       if (!PedanticOpen4Write(*xrddest, rwMode, xrd_wr_flags) )\n          {cpFatal(\"open\", 0 , *xrddest, hName);\n           close(cpnfo.localfile);\n           delete *xrddest;\n           *xrddest = 0;\n           cpnfo.localfile = 0;\n           return -1;\n          }\n      }\n      \n   // Start reader on loc\n   XrdSysThread::Run(&myTID,ReaderThread_loc,(void *)&cpnfo,XRDSYSTHREAD_HOLD);\n\n   int len = 1;\n   void *buf;\n   long long offs = 0;\n   unsigned long long bytesread=0;\n   unsigned long long size = stat.st_size;\n   int blkcnt = 0;\n\n// If we need to verify checksums then we will need to get the checksum\n// from the source unless a specific checksum has been specified.\n//\n   if ((xeqCks && verCks && getCks) || lclCks) csObj = Config.CksObj;\n\n   // Loop to write until ended or timeout err\n   while(len > 0)\n        {if ( cpnfo.queue.GetBuffer(&buf, offs, len) )\n            {if (len && buf)\n                {bytesread+=len;\n                 if (progbar)\n                    {gettimeofday(&abs_stop_time,&tz);\n                     print_progbar(bytesread,size);\n                    }\n                 if (csObj) csObj->Update((const char *)buf,len);\n                 if ( !(*xrddest)->Write(buf, offs, len) )\n                    {cpFatal(\"write\", 0 , *xrddest);\n                     retvalue = 12;\n                     break;\n                    }\n                 if (cpnfo.mon)\n                    cpnfo.mon->PutProgressInfo(bytesread, cpnfo.len, (float)bytesread / cpnfo.len * 100.0);\n                 free(buf);\n                } else {\n                 // If we get len == 0 then we have to stop\n                 if (buf) free(buf);\n                 break;\n                }\n            } else {\n             EMSG(\"Critical read timeout. Unable to read data from the source.\");\n             retvalue = 17;\n             break;\n            }\n         buf = 0; blkcnt++;\n        }\n\n   if (cpnfo.mon)\n     cpnfo.mon->PutProgressInfo(bytesread, cpnfo.len, (float)bytesread / cpnfo.len * 100.0, 1);\n\n   if(progbar) cout << endl;\n\n   if (size != bytesread) retvalue = 13;\n\n   pthread_cancel(myTID);\n   pthread_join(myTID, &thret);\n\n   if(!(*xrddest)->Close()) return cpFatal(\"close\", 0, *xrddest);\n\n   delete *xrddest;\n   *xrddest = 0;\n\n   close(cpnfo.localfile);\n   cpnfo.localfile = 0;\n\n   if (!retvalue && xeqCks)\n      {if (!getCksum(dstCksum, dst)) retvalue = -ENOTSUP;\n       if (csObj)\n          {char *csVal = csObj->Final();\n           if (!srcCksum.Set((const void *)csVal, Config.CksLen))\n              retvalue = -EINVAL;\n          }\n       if (retvalue)\n          {retvalue = (retvalue < 0 ? -retvalue : retvalue);\n           EMSG(strerror(retvalue) <<\" calculating \"\n                <<dstCksum.Name << \" checksum for \" <<getFName(dst));\n          } else if (verCks && srcCksum != dstCksum)\n                    {EMSG(getFName(dst) <<' ' <<srcCksum.Name\n                          <<\" checksum is incorrect!\");\n                     retvalue = -1;\n                    }\n      }\n\n   if (!retvalue)\n      {if (prtCks)  print_chksum(src, bytesread);\n       if (summary) print_summary(src, dst, bytesread);\n      }\n\n   return retvalue;\n}\n\n/******************************************************************************/\n/*                                  d o C p                                   */\n/******************************************************************************/\n  \nint doCp(XrdOucString &src, XrdOucString &dest, XrdClient *xrddest)\n{\n   int rmtSrc = (src.beginswith(\"root://\"))  || (src.beginswith(\"xroot://\"));\n   int rmtDst = (dest.beginswith(\"root://\")) || (dest.beginswith(\"xroot://\"));\n\n// Provide some debugging\n//\n   Info(XrdClientDebug::kUSERDEBUG, \"main\", src << \" --> \" << dest);\n      \n// Preprocess cksum calculation desires\n//\n   if (xeqCks)\n      {srcCksum = Config.CksData;\n       dstCksum = Config.CksData;\n       if (Config.CksObj) Config.CksObj->Init();\n      }\n   csObj = 0;\n\n// Handle when source is xrootd\n//\n   if (rmtSrc)\n      {if (Config.srcOpq) {src += \"?\"; src += Config.srcOpq;}\n       if (rmtDst)\n          {XrdOucString d = dest;\n           if (Config.dstOpq) {d += \"?\"; d += Config.dstOpq;}\n           if (isTPC) return doCp_xrd3xrd( xrddest, src.c_str(), d.c_str());\n              else    return doCp_xrd2xrd(&xrddest, src.c_str(), d.c_str());\n          }\n       return doCp_xrd2loc(src.c_str(), dest.c_str());\n      }\n\n// Handle when source is the local filesystem\n//\n   if (rmtDst)\n      {XrdOucString d = dest;\n       if (Config.dstOpq) {d += \"?\"; d += Config.dstOpq;}\n       return doCp_loc2xrd(&xrddest, src.c_str(), d.c_str());\n      }\n\n// We should never get here\n//\n   EMSG(\"Better to use cp for this copy.\");\n   return 2;\n}\n\n/******************************************************************************/\n/*                                  m a i n                                   */\n/******************************************************************************/\n  \nint main(int argc, char**argv)\n{\n   const char *Opaque;\n   char *hName, *srcpath = 0, *destpath = 0;\n\n// Preset globals\n//\n   tpcPB = 0;\n\n#ifdef WIN32\n   WORD wVersionRequested;\n   WSADATA wsaData;\n   int err;\n   wVersionRequested = MAKEWORD( 2, 2 );\n   err = WSAStartup( wVersionRequested, &wsaData );\n#endif\n\n// Invoke config; it it returns then all went well.\n//\n   Config.Config(argc, argv, XrdCpConfig::opt1Src|XrdCpConfig::optNoStdIn\n                            |XrdCpConfig::optNoXtnd|XrdCpConfig::optNoLclCp);\n\n// Turn off any blab from the client\n//\n   DebugSetLevel(-1);\n\n// We want this tool to be able to copy from/to everywhere\n// Note that the side effect of these calls here is to initialize the\n// XrdClient environment.\n// This is crucial if we want to later override its default values\n//\n   EnvPutString( NAME_REDIRDOMAINALLOW_RE, \"*\" );\n   EnvPutString( NAME_CONNECTDOMAINALLOW_RE, \"*\" );\n   EnvPutString( NAME_REDIRDOMAINDENY_RE, \"\" );\n   EnvPutString( NAME_CONNECTDOMAINDENY_RE, \"\" );\n\n   EnvPutInt( NAME_READAHEADSIZE, XRDCP_XRDRASIZE);\n   EnvPutInt( NAME_READCACHESIZE, 2*XRDCP_XRDRASIZE );\n   EnvPutInt( NAME_READCACHEBLKREMPOLICY, XrdClientReadCache::kRmBlk_LeastOffs );\n   EnvPutInt( NAME_PURGEWRITTENBLOCKS, 1 );\n\n   EnvPutInt( NAME_DEBUG, -1);\n\n// Extract out config information and set global vars (that's how it was done)\n//\n   if ((Verbose = Config.Verbose))          summary = true;\n   if (Config.Want(XrdCpConfig::DoSilent )) summary = progbar = false;\n   if (Config.Want(XrdCpConfig::DoNoPbar )) progbar = false;\n   if (Config.Want(XrdCpConfig::DoRecurse)) recurse = true;\n   if (Config.Want(XrdCpConfig::DoCoerce )) xrd_wr_flags |=  kXR_force;\n   if (Config.Want(XrdCpConfig::DoPosc   )) xrd_wr_flags |=  kXR_posc;\n   if (Config.Want(XrdCpConfig::DoForce  )\n   ||  Config.Want(XrdCpConfig::DoServer ))\n      {xrd_wr_flags &= ~kXR_new;\n       xrd_wr_flags |=  kXR_delete;\n       loc_wr_flags = LOC_WR_FLAGS_FORCE; // Flags for the local fs\n      }\n   if (Config.Want(XrdCpConfig::DoRetry  ) && Config.Retry >= 0)\n      {EnvPutInt(NAME_CONNECTTIMEOUT , 60);\n       EnvPutInt(NAME_FIRSTCONNECTMAXCNT, Config.Retry);\n      }\n\n   if (Config.strDefs)\n      {XrdCpConfig::defVar *dvP = Config.strDefs;\n       do {EnvPutString(dvP->vName, dvP->strVal);}\n          while((dvP = dvP->Next));\n      }\n\n   if (Config.intDefs)\n      {XrdCpConfig::defVar *dvP = Config.intDefs;\n       do {EnvPutInt(dvP->vName, dvP->intVal);}\n          while((dvP = dvP->Next));\n      }\n\n   if (Config.Want(XrdCpConfig::DoProxy  ))\n      {EnvPutString(NAME_SOCKS4HOST, Config.pHost);\n       EnvPutInt(NAME_SOCKS4PORT, Config.pPort);\n      }\n\n   if (Config.Dlvl > 0) EnvPutInt( NAME_DEBUG, Config.Dlvl);\n\n   if (Config.Want(XrdCpConfig::DoStreams))\n      EnvPutInt(NAME_MULTISTREAMCNT, Config.nStrm);\n\n   isTPC = (Config.Want(XrdCpConfig::DoTpc) ? 1 : 0);\n\n   destpath = Config.dstFile->Path;\n   srcpath  = Config.srcFile->Path;\n\n// Do some debugging\n//\n   DebugSetLevel(EnvGetLong(NAME_DEBUG));\n   Info(XrdClientDebug::kUSERDEBUG, \"main\", XRDCP_VERSION);\n\n// Prehandle extreme copy\n//\n   if (Config.Want(XrdCpConfig::DoSources) && Config.nSrcs > 1)\n      {doXtremeCp = true;\n       XtremeCpRdr = srcpath;\n       if (Verbose) EMSG(\"Extreme Copy enabled.\");\n      }\n\n// Establish checksum processing\n//\n   setCks = 0;\n   lclCks = Config.Want(XrdCpConfig::DoCksrc);\n   xeqCks = Config.Want(XrdCpConfig::DoCksum);\n   prtCks =(xeqCks || lclCks) &&  Config.Want(XrdCpConfig::DoCkprt);\n   getCks = xeqCks && (Config.CksData.Length == 0);\n   verCks = xeqCks && !prtCks;\n\n// Force certain defaults when in server mode\n//\n   if (Config.Want(XrdCpConfig::DoServer))\n      {summary = progbar = false;\n       setCks = true;\n       isSrv  = true;\n      } else {\n       isSrv = false;\n //    if (dup2(STDOUT_FILENO, STDERR_FILENO)) cerr <<\"??? \" <<errno <<endl;\n      }\n\n// Extract source host if present\n//\n   if (strncmp(srcpath, \"root://\", 7) || strncmp(srcpath, \"xroot://\", 8) )\n      {XrdClientUrlInfo sUrl(srcpath);\n       hName = (sUrl.IsValid() ? strdup(sUrl.Host.c_str()) : 0);\n      } else hName = 0;\n\n// Prepare to generate a copy list\n//\n   XrdCpWorkLst *wklst = new XrdCpWorkLst();\n   XrdOucString src, dest;\n   XrdClient *xrddest = 0;\n   cpnfo.XrdCli = 0;\n  \n// Generate the sources\n//\n   if (wklst->SetSrc(&cpnfo.XrdCli, srcpath, Config.srcOpq, recurse, 1))\n      {cpFatal(\"open\", cpnfo.XrdCli, 0, hName);\n       exit(1);\n      }\n\n// Generate destination opaque data now\n//\n   if (!isTPC) Opaque = Config.dstOpq;\n      else {if (!(Opaque = genDestCgi(cpnfo.XrdCli, srcpath))) exit(4);\n            tpcSrc = cpnfo.XrdCli;\n           }\n\n// Extract source host if present\n//\n   if (hName) free(hName);\n   if (strncmp(destpath, \"root://\", 7) || strncmp(destpath, \"xroot://\", 8) )\n      {XrdClientUrlInfo dUrl(destpath);\n       hName = (dUrl.IsValid() ? strdup(dUrl.Host.c_str()) : 0);\n      } else hName = 0;\n\n// Verify the correctness of the destination\n//\n   if (wklst->SetDest(&xrddest, destpath, Opaque, xrd_wr_flags, 1))\n      {cpFatal(\"open\", 0, xrddest, hName);\n       exit(1);\n      }\n   if (hName) {free(hName); hName = 0;}\n\n      // Initialize monitoring client, if a plugin is present\n      cpnfo.mon = 0;\n#ifndef WIN32\n      void *monhandle = dlopen (monlibname.c_str(), RTLD_LAZY);\n\n      if (monhandle) {\n\tXrdClientMonIntfHook monlibhook = (XrdClientMonIntfHook)dlsym(monhandle, \"XrdClientgetMonIntf\");\n\n\tconst char *err = 0;\n\tif ((err = dlerror())) {\n   EMSG(err <<\" loading library \" << monhandle);\n\t  dlclose(monhandle);\n\t  monhandle = 0;\n\t}\n\telse\t\n\t  cpnfo.mon = (XrdClientAbsMonIntf *)monlibhook(src.c_str(), dest.c_str());\n      }\n#endif\n      \n      if (cpnfo.mon) {\n\n\tchar *name=0, *ver=0, *rem=0;\n\tif (!cpnfo.mon->GetMonLibInfo(&name, &ver, &rem)) {\n\t  Info(XrdClientDebug::kUSERDEBUG,\n\t       \"main\", \"Monitoring client plugin found. Name:'\" << name <<\n\t       \"' Ver:'\" << ver << \"' Remarks:'\" << rem << \"'\");\n\t}\n\telse {\n\t  delete cpnfo.mon;\n\t  cpnfo.mon = 0;\n\t}\n\n      }\n\n#ifndef WIN32\n      if (!cpnfo.mon && monhandle) {\n\tdlclose(monhandle);\n\tmonhandle = 0;\n      }\n#endif\n\n// From here, we will have:\n// the knowledge if the dest is a dir name or file name\n// an open instance of xrdclient if it's a file\n//\n   int retval = 0;\n   while(!retval && wklst->GetCpJob(src, dest))\n        {if (cpnfo.mon)\n            {cpnfo.mon->Init(src.c_str(), dest.c_str(), (DebugLevel() > 0) );\n             cpnfo.mon->PutProgressInfo(0, cpnfo.len, 0, 1);\n            }\n         retval = doCp(src, dest, xrddest);\n         if (cpnfo.mon) cpnfo.mon->DeInit();\n        }\n\n// Delete the monitor object\n//\n   delete cpnfo.mon;\n   cpnfo.mon = 0;\n#ifndef WIN32\n   if (monhandle) dlclose(monhandle);\n   monhandle = 0;\n#endif\n\n// All done\n//\n   if (retval < 0) retval = -retval;\n   _exit(retval);\n   return retval;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-4.7.1-6ztgtlw45oyfa6oy2puynzeyzwvbkxxf/spack-src/src/XrdSys/XrdSysPlugin.cc": "/******************************************************************************/\n/*                                                                            */\n/*                       X r d S y s P l u g i n . c c                        */\n/*                                                                            */\n/* (c) 2005 by the Board of Trustees of the Leland Stanford, Jr., University  */\n/*                            All Rights Reserved                             */\n/*   Produced by Andrew Hanushevsky for Stanford University under contract    */\n/*              DE-AC02-76-SFO0515 with the Department of Energy              */\n/*                                                                            */\n/* This file is part of the XRootD software suite.                            */\n/*                                                                            */\n/* XRootD is free software: you can redistribute it and/or modify it under    */\n/* the terms of the GNU Lesser General Public License as published by the     */\n/* Free Software Foundation, either version 3 of the License, or (at your     */\n/* option) any later version.                                                 */\n/*                                                                            */\n/* XRootD is distributed in the hope that it will be useful, but WITHOUT      */\n/* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or      */\n/* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public       */\n/* License for more details.                                                  */\n/*                                                                            */\n/* You should have received a copy of the GNU Lesser General Public License   */\n/* along with XRootD in a file called COPYING.LESSER (LGPL license) and file  */\n/* COPYING (GPL license).  If not, see <http://www.gnu.org/licenses/>.        */\n/*                                                                            */\n/* The copyright holder's institutional names and contributor's names may not */\n/* be used to endorse or promote products derived from this software without  */\n/* specific prior written permission of the institution or contributor.       */\n/******************************************************************************/\n\n// Bypass Solaris ELF madness\n//\n#ifdef __solaris__\n#include <sys/isa_defs.h>\n#if defined(_ILP32) && (_FILE_OFFSET_BITS != 32)\n#undef  _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 32\n#undef  _LARGEFILE_SOURCE\n#endif\n#endif\n\n#ifndef WIN32\n#include <dlfcn.h>\n#if !defined(__APPLE__) && !defined(__CYGWIN__)\n#include <link.h>\n#endif\n#include <stdio.h>\n#include <strings.h>\n#include <sys/types.h>\n#include <errno.h>\n#else\n#include \"XrdSys/XrdWin32.hh\"\n#endif\n  \n#include \"XrdSys/XrdSysError.hh\"\n#include \"XrdSys/XrdSysHeaders.hh\"\n#include \"XrdSys/XrdSysPlugin.hh\"\n#include \"XrdVersion.hh\"\n#include \"XrdVersionPlugin.hh\"\n \n/******************************************************************************/\n/*                        S t a t i c   M e m b e r s                         */\n/******************************************************************************/\n\nstruct XrdSysPlugin::PLlist *XrdSysPlugin::plList = 0;\n\n/******************************************************************************/\n/*                            D e s t r u c t o r                             */\n/******************************************************************************/\n  \nXrdSysPlugin::~XrdSysPlugin()\n{\n   if (libHandle) dlclose(libHandle);\n   if (libPath)   free(libPath);\n}\n\n/******************************************************************************/\n/* Private:                   b a d V e r s i o n                             */\n/******************************************************************************/\n  \nXrdSysPlugin::cvResult XrdSysPlugin::badVersion(XrdVersionInfo &urInfo,\n                                                char mmv, int majv, int minv)\n{\n   const char *path;\n   char buff1[512], buff2[128];\n\n   if (minv > 99) minv = 99;\n   snprintf(buff1, sizeof(buff1), \"version %s is incompatible with %s \"\n                                  \"(must be %c= %d.%d.x)\",\n                                   myInfo->vStr, urInfo.vStr, mmv, majv, minv);\n\n   path = msgSuffix(\" in \", buff2, sizeof(buff2));\n\n   Inform(buff1, buff2, path, 0, 0, 1);\n\n   return cvBad;\n}\n  \n/******************************************************************************/\n/* Private:                   c h k V e r s i o n                             */\n/******************************************************************************/\n  \nXrdSysPlugin::cvResult XrdSysPlugin::chkVersion(XrdVersionInfo &urInfo,\n                                                const char     *pname,\n                                                void           *lHandle)\n{\n   static XrdVersionPlugin vInfo[] = {XrdVERSIONPLUGINRULES};\n   static XrdVersionPlugin vNote[] = {XrdVERSIONPLUGINMAXIMS};\n   XrdVersionPlugin *vinP;\n   char buff[1024], vName[256];\n   void *vP;\n   int  i, n=0, pMajor, vMajor, pMinor, vMinor;\n\n// If no version information supplied, skip version check\n//\n   if (!myInfo) return cvNone;\n\n// Check if we need to check the version here\n//\n   i = 0;\n   while(vInfo[i].pName && strcmp(vInfo[i].pName, pname)) i++;\n\n// If we didn't find it in the rules table then try to match the maxims\n//\n   if (!vInfo[i].pName)\n      {i = 0; n = strlen(pname);\n       while(vNote[i].pName)\n            {if ((vNote[i].vPfxLen + vNote[i].vSfxLen <= n)\n             &&  !strncmp(vNote[i].pName, pname, vNote[i].vPfxLen)\n             &&  !strncmp(vNote[i].pName+vNote[i].vPfxLen,\n                   pname + n - vNote[i].vSfxLen, vNote[i].vSfxLen)) break;\n             i++;\n            }\n             vinP = &vNote[i];\n      } else vinP = &vInfo[i];\n\n   if (!(vinP->pName)) return cvNone;\n   if ( vinP->vProcess == XrdVERSIONPLUGIN_DoNotChk) return cvDirty;\n\n// Construct the version entry point\n//\n   if (!n) n = strlen(pname);\n   if (n+sizeof(XrdVERSIONINFOSFX) > sizeof(vName))\n      return libMsg(\"Unable to generate version name for\", \"%s in \", pname);\n   strcpy(vName, pname); strcpy(vName+n, XrdVERSIONINFOSFX);\n\n// Find the version number\n//\n   if (!(vP = dlsym(lHandle, vName)))\n      {if (vinP->vProcess != XrdVERSIONPLUGIN_Required) return cvMissing;\n       return libMsg(dlerror(),\" required version information for %s in \",pname);\n      }\n\n// Extract the version number from the plugin and do a quick check. We use\n// memcpy to avoid instances where the symbol is wrongly defined. Make sure\n// the version string ends with a null by copying one less byte than need be.\n// The caller provided a struct that is gauranteed to end with nulls.\n//\n   memcpy(&urInfo, vP, sizeof(XrdVersionInfo)-1);\n\n// If version numbers are identical then we are done\n//\n   if (myInfo->vNum == urInfo.vNum)\n      if (myInfo->vNum != XrdVNUMUNK\n      ||  !strcmp(myInfo->vStr + (myInfo->vOpt & 0x0f)+1,\n                  urInfo. vStr + (urInfo. vOpt & 0x0f)+1)) return cvClean;\n\n// If the caller or plugin is unreleased, just issue a warning.\n//\n   if (myInfo->vNum == XrdVNUMUNK || urInfo.vNum == XrdVNUMUNK)\n      {if (eDest)\n          {char mBuff[128];\n           sprintf(buff, \"%s%s is using %s%s version\",\n                   (myInfo->vNum == XrdVNUMUNK ? \"unreleased \":\"\"),myInfo->vStr,\n                   (urInfo.vNum  == XrdVNUMUNK ? \"unreleased \":\"\"),urInfo.vStr);\n           msgSuffix(\" in \", mBuff, sizeof(mBuff));\n           Inform(buff, mBuff, libPath);\n          }\n       return cvDirty;\n      }\n\n// Extract version numbers\n//\n   vMajor = XrdMajorVNUM(myInfo->vNum);\n   vMinor = XrdMinorVNUM(myInfo->vNum);\n   pMajor = XrdMajorVNUM(urInfo. vNum);\n   pMinor = XrdMinorVNUM(urInfo. vNum);\n\n// The major version must always be compatible\n//\n   if ((vinP->vMajLow >= 0 && pMajor <  vinP->vMajLow)\n   ||  (vinP->vMajLow <  0 && pMajor != vMajor))\n      return badVersion(urInfo, '>', vinP->vMajLow, vinP->vMinLow);\n\n// The major version may not be greater than our versin\n//\n   if (pMajor > vMajor) return badVersion(urInfo, '<', vMajor, vMinor);\n\n// If we do not need to check minor versions then we are done\n//\n   if (vinP->vMinLow > 99) return cvClean;\n\n// In no case can the plug-in mnor version be greater than our version\n//\n   if (pMajor == vMajor && pMinor > vMinor)\n      return badVersion(urInfo, '<', vMajor, vMinor);\n\n// Verify compatible minor versions\n//\n   if ((vinP->vMinLow >= 0 && pMinor >= vinP->vMinLow)\n   ||  (vinP->vMinLow <  0 && pMinor == vMinor)) return cvClean;\n\n// Incompatible versions\n//\n   return badVersion(urInfo, '>', vinP->vMajLow, vinP->vMinLow);\n}\n\n/******************************************************************************/\n/* Private:                      D L F l a g s                                */\n/******************************************************************************/\n  \nint XrdSysPlugin::DLflags()\n{\n#if    defined(__APPLE__)\n       return RTLD_FIRST;\n#elif  defined(__linux__)\n       return RTLD_NOW;\n#else\n       return RTLD_NOW;\n#endif\n}\n\n/******************************************************************************/\n/* Private:                         F i n d                                   */\n/******************************************************************************/\n  \nvoid *XrdSysPlugin::Find(const char *libpath)\n{\n   struct PLlist *plP = plList;\n\n// Find the library in the preload list\n//\n   while(plP && strcmp(libpath, plP->libPath)) plP = plP->next;\n\n// Return result\n//\n  return (plP ? plP->libHandle : 0);\n}\n\n/******************************************************************************/\n/*                             g e t P l u g i n                              */\n/******************************************************************************/\n\nvoid *XrdSysPlugin::getPlugin(const char *pname, int optional)\n{\n   return getPlugin(pname, optional, false);\n}\n\nvoid *XrdSysPlugin::getPlugin(const char *pname, int optional, bool global)\n{\n   XrdVERSIONINFODEF(urInfo, unknown, XrdVNUMUNK, \"\");\n   void *ep, *myHandle;\n   cvResult cvRC;\n   int flags;\n\n// If no path is given then we want to just search the executable. This is easy\n// for some platforms and more difficult for others. So, we do the best we can.\n//\n   if (libPath) flags = DLflags();\n      else {    flags = RTLD_NOW;\n#ifndef WIN32\n                flags|= global ? RTLD_GLOBAL : RTLD_LOCAL;\n#else\n            if (global && eDest) eDest->Emsg(\"getPlugin\",\n               \"request for global symbols unsupported under Windows - ignored\");\n#endif\n      }\n\n// Check if we should use the preload list\n//\n   if (!(myHandle = libHandle) && plList) myHandle = Find(libPath);\n\n// Open whatever it is we need to open\n//\n   if (!myHandle)\n      {if ((myHandle = dlopen(libPath, flags))) libHandle = myHandle;\n          else {if (optional < 2) libMsg(dlerror(), \" loading \"); return 0;}\n      }\n\n// Get the symbol. In the environment we have defined, null values are not\n// allowed and we will issue an error.\n//\n   if (!(ep = dlsym(myHandle, pname)))\n      {if (optional < 2) libMsg(dlerror(), \" plugin %s in \", pname);\n       return 0;\n      }\n\n// Check if we need to verify version compatability\n//\n   if ((cvRC = chkVersion(urInfo, pname, myHandle)) == cvBad) return 0;\n\n// Print the loaded version unless message is suppressed or not needed\n//\n   if (libPath && optional < 2 && msgCnt\n   &&  (cvRC == cvClean || cvRC == cvMissing))\n      {char buff[128];\n       msgSuffix(\" from \", buff, sizeof(buff));\n       msgCnt--;\n            if (cvRC == cvClean)\n               {const char *wTxt=(urInfo.vNum == XrdVNUMUNK ? \"unreleased \":0);\n                Inform(\"loaded \", wTxt, urInfo.vStr, buff, libPath);\n               }\n       else if (cvRC == cvMissing)\n               {Inform(\"loaded unversioned \", pname, buff, libPath);}\n      }\n\n// All done\n//\n   return ep;\n}\n\n/******************************************************************************/\n/* Private:                       I n f o r m                                 */\n/******************************************************************************/\n\nvoid XrdSysPlugin::Inform(const char *txt1, const char *txt2, const char *txt3,\n                          const char *txt4, const char *txt5, int noHush)\n{\n   const char *eTxt[] = {\"Plugin \",txt1, txt2, txt3, txt4, txt5, 0};\n   char *bP;\n   int n, i, bL;\n\n// Check if we should hush this messages (largely for client-side usage)\n//\n   if (!noHush && getenv(\"XRDPIHUSH\")) return;\n\n// If we have a messaging object, use that\n//\n   if (eDest)\n      {char buff[2048];\n       i = 1; bP = buff; bL = sizeof(buff);\n       while(bL > 1 && eTxt[i])\n            {n = snprintf(bP, bL, \"%s\", eTxt[i]);\n             bP += n; bL -= n; i++;\n            }\n       eDest->Say(\"Plugin \", buff);\n       return;\n      }\n\n// If we have a buffer, set message in the buffer\n//\n   if ((bP = eBuff))\n      {i = 0; bL = eBLen;\n       while(bL > 1 && eTxt[i])\n            {n = snprintf(bP, bL, \"%s\", eTxt[i]);\n             bP += n; bL -= n; i++;\n            }\n      }\n}\n  \n/******************************************************************************/\n/* Private:                       l i b M s g                                 */\n/******************************************************************************/\n  \nXrdSysPlugin::cvResult XrdSysPlugin::libMsg(const char *txt1, const char *txt2,\n                                            const char *mSym)\n{\n   static const char fndg[] = \"Finding\";\n   static const int  flen   = sizeof(\"Finding\");\n   const char *path;\n   char mBuff[512], nBuff[512];\n\n// Check if this is a lookup or open issue. Trim message for the common case.\n//\n        if (mSym)\n           {if (!txt1 || strstr(txt1, \"undefined\"))\n               {txt1 = \"Unable to find \";\n                snprintf(nBuff, sizeof(nBuff), txt2, mSym);\n               } else {\n                strcpy(nBuff, fndg);\n                snprintf(nBuff+flen-1,sizeof(nBuff)-flen,txt2,mSym);\n               }\n            txt2 = nBuff;\n           }\n   else if (!txt1) txt1 = \"Unknown system error!\";\n   else if (strstr(txt1, \"No such file\")) txt1 = \"No such file or directory\";\n   else txt2 = \" \";\n\n// Spit out the message\n//\n   path = msgSuffix(txt2, mBuff, sizeof(mBuff));\n   Inform(txt1, mBuff, path, 0, 0, 1);\n   return cvBad;\n}\n\n/******************************************************************************/\n/* Private:                    m s g S u f f i x                              */\n/******************************************************************************/\n\nconst char *XrdSysPlugin::msgSuffix(const char *Word, char *buff, int bsz)\n{\n   if (libPath) snprintf(buff, bsz,\"%s%s \", Word, libName);\n      else      snprintf(buff, bsz,\"%sexecutable image\", Word);\n   return (libPath ? libPath : \"\");\n}\n  \n/******************************************************************************/\n/*                               P r e l o a d                                */\n/******************************************************************************/\n  \nbool XrdSysPlugin::Preload(const char *path,  char *ebuff, int eblen)\n{\n   struct PLlist *plP;\n   void *myHandle;\n\n// First see if this is already in the preload list\n//\n   if (Find(path)) return true;\n\n// Try to open the library\n//\n   if (!(myHandle = dlopen(path, DLflags())))\n      {if (ebuff && eblen > 0)\n          {const char *dlMsg = dlerror();\n           snprintf(ebuff, eblen, \"Plugin unable to load %s; %s\", path,\n                                  (dlMsg ? dlMsg : \"unknown system error\"));\n          }\n       return false;\n      }\n\n// Add the library handle\n//\n   plP = new PLlist;\n   plP->libHandle = myHandle;\n   plP->libPath   = strdup(path);\n   plP->next      = plList;\n   plList         = plP;\n\n// All done\n//\n   return true;\n}\n\n/******************************************************************************/\n/*                                V e r C m p                                 */\n/******************************************************************************/\n  \nbool XrdSysPlugin::VerCmp(XrdVersionInfo &vInfo1,\n                          XrdVersionInfo &vInfo2, bool noMsg)\n{\n   const char *mTxt;\n   char v1buff[128], v2buff[128];\n   int unRel;\n\n// Do a quick return if the version need not be checked or are equal\n//\n   if (vInfo1.vNum <= 0 || vInfo1.vNum == vInfo2.vNum) return true;\n\n// As it works out, many times two modules wind up in different shared\n// libraries. For consistency we require that both major.minor version be the\n// same unless either is unreleased (i.e. test). Issue warning if need be.\n//\n   mTxt = (vInfo1.vNum == XrdVNUMUNK ? \"unreleased \" : \"\");\n   sprintf(v1buff, \" %sversion %s\", mTxt, vInfo1.vStr);\n   unRel  = *mTxt;\n\n   mTxt = (vInfo2.vNum == XrdVNUMUNK ? \"unreleased \" : \"\");\n   sprintf(v2buff, \" %sversion %s\", mTxt, vInfo2.vStr);\n   unRel |= *mTxt;\n\n   if (unRel || vInfo1.vNum/100 == vInfo2.vNum/100) mTxt = \"\";\n      else mTxt = \" which is incompatible!\";\n\n   if (!noMsg)\n      cerr <<\"Plugin: \" <<v1buff <<\" is using \" <<v2buff <<mTxt <<endl;\n\n   return (*mTxt == 0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-4.7.1-6ztgtlw45oyfa6oy2puynzeyzwvbkxxf/spack-src/src/XrdPosix/XrdPosixLinkage.cc": "/******************************************************************************/\n/*                                                                            */\n/*                    X r d P o s i x L i n k a g e . c c                     */\n/*                                                                            */\n/* (c) 2005 by the Board of Trustees of the Leland Stanford, Jr., University  */\n/*                            All Rights Reserved                             */\n/*   Produced by Andrew Hanushevsky for Stanford University under contract    */\n/*              DE-AC02-76-SFO0515 with the Department of Energy              */\n/*                                                                            */\n/* This file is part of the XRootD software suite.                            */\n/*                                                                            */\n/* XRootD is free software: you can redistribute it and/or modify it under    */\n/* the terms of the GNU Lesser General Public License as published by the     */\n/* Free Software Foundation, either version 3 of the License, or (at your     */\n/* option) any later version.                                                 */\n/*                                                                            */\n/* XRootD is distributed in the hope that it will be useful, but WITHOUT      */\n/* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or      */\n/* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public       */\n/* License for more details.                                                  */\n/*                                                                            */\n/* You should have received a copy of the GNU Lesser General Public License   */\n/* along with XRootD in a file called COPYING.LESSER (LGPL license) and file  */\n/* COPYING (GPL license).  If not, see <http://www.gnu.org/licenses/>.        */\n/*                                                                            */\n/* The copyright holder's institutional names and contributor's names may not */\n/* be used to endorse or promote products derived from this software without  */\n/* specific prior written permission of the institution or contributor.       */\n/******************************************************************************/\n\n// Bypass Solaris ELF madness\n//\n#ifdef __solaris__\n#include <sys/isa_defs.h>\n#if defined(_ILP32) && (_FILE_OFFSET_BITS != 32)\n#undef  _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 32\n#undef  _LARGEFILE_SOURCE\n#endif\n#endif\n\n#include <dlfcn.h>\n#if !defined(__APPLE__) && !defined(__CYGWIN__)\n#include <link.h>\n#endif\n\n#include <errno.h>\n\n#include \"XrdSys/XrdSysHeaders.hh\"\n#include \"XrdPosix/XrdPosixLinkage.hh\"\n \n/******************************************************************************/\n/*                   G l o b a l   D e c l a r a t i o n s                    */\n/******************************************************************************/\n  \nXrdPosixLinkage Xunix;\n \n/******************************************************************************/\n/*                          M a c r o   L o a d e r                           */\n/******************************************************************************/\n  \n#define LOOKUP_UNIX(symb) symb = (Retv_ ## symb (*)(Args_ ## symb)) \\\n                                 dlsym(RTLD_NEXT, Symb_ ## symb); \\\n                          if (!symb) {symb = Xrd_U_ ## symb; \\\n                                      Missing(Symb_ ## symb);}\n \n/******************************************************************************/\n/*          U n r e s o l v e d   R e f e r e n c e   L i n k a g e           */\n/******************************************************************************/\n\n      Retv_Access      Xrd_U_Access(Args_Access)\n                         {return (Retv_Access)Xunix.Load_Error(\"access\");}\n      Retv_Acl         Xrd_U_Acl(Args_Acl)\n                         {return (Retv_Acl)Xunix.Load_Error(\"acl\");}\n      Retv_Chdir       Xrd_U_Chdir(Args_Chdir) \n                         {return (Retv_Chdir)Xunix.Load_Error(\"chdir\");}\n      Retv_Close       Xrd_U_Close(Args_Close) \n                         {return (Retv_Close)Xunix.Load_Error(\"close\");}\n      Retv_Closedir    Xrd_U_Closedir(Args_Closedir) \n                         {return (Retv_Closedir)Xunix.Load_Error(\"closedir\");}\n      Retv_Fclose      Xrd_U_Fclose(Args_Fclose)\n                         {return (Retv_Fclose)Xunix.Load_Error(\"fclose\");}\n      Retv_Fcntl       Xrd_U_Fcntl(Args_Fcntl) \n                         {Xunix.Load_Error(\"fcntl\"); return (Retv_Fcntl)0;}\n      Retv_Fcntl64     Xrd_U_Fcntl64(Args_Fcntl64)\n                         {Xunix.Load_Error(\"fcntl\"); return (Retv_Fcntl64)0;}\n      Retv_Fdatasync   Xrd_U_Fdatasync(Args_Fdatasync)\n                         {return (Retv_Fdatasync)Xunix.Load_Error(\"fdatasync\");}\n      Retv_Fflush      Xrd_U_Fflush(Args_Fflush)\n                         {return (Retv_Fflush)Xunix.Load_Error(\"fflush\");}\n      Retv_Fopen       Xrd_U_Fopen(Args_Fopen) \n                         {Xunix.Load_Error(\"fopen\"); return (Retv_Fopen)0;}\n      Retv_Fopen64     Xrd_U_Fopen64(Args_Fopen64)\n                         {Xunix.Load_Error(\"fopen\"); return (Retv_Fopen64)0;}\n      Retv_Fread       Xrd_U_Fread(Args_Fread)\n                         {return (Retv_Fread)Xunix.Load_Error(\"fread\");}\n      Retv_Fseek       Xrd_U_Fseek(Args_Fseek)\n                         {return (Retv_Fseek)Xunix.Load_Error(\"fseek\");}\n      Retv_Fseeko      Xrd_U_Fseeko(Args_Fseeko)\n                         {return (Retv_Fseeko)Xunix.Load_Error(\"fseeko\");}\n      Retv_Fseeko64    Xrd_U_Fseeko64(Args_Fseeko64)\n                         {return (Retv_Fseeko64)Xunix.Load_Error(\"fseeko64\");}\n      Retv_Fstat       Xrd_U_Fstat(Args_Fstat) \n                         {return (Retv_Fstat)Xunix.Load_Error(\"fstat\");}\n      Retv_Fstat64     Xrd_U_Fstat64(Args_Fstat64)\n                         {return (Retv_Fstat64)Xunix.Load_Error(\"fstat64\");}\n      Retv_Fsync       Xrd_U_Fsync(Args_Fsync) \n                         {return (Retv_Fsync)Xunix.Load_Error(\"fsync\");}\n      Retv_Ftell       Xrd_U_Ftell(Args_Ftell)\n                         {return (Retv_Ftell)Xunix.Load_Error(\"ftell\");}\n      Retv_Ftello      Xrd_U_Ftello(Args_Ftello)\n                         {return (Retv_Ftello)Xunix.Load_Error(\"ftello\");}\n      Retv_Ftello64    Xrd_U_Ftello64(Args_Ftello64)\n                         {return (Retv_Ftello64)Xunix.Load_Error(\"ftello64\");}\n      Retv_Ftruncate   Xrd_U_Ftruncate(Args_Ftruncate)\n                         {return (Retv_Ftruncate)Xunix.Load_Error(\"ftruncate\");}\n      Retv_Ftruncate64 Xrd_U_Ftruncate64(Args_Ftruncate64)\n                         {return (Retv_Ftruncate64)Xunix.Load_Error(\"ftruncate64\");}\n      Retv_Fwrite      Xrd_U_Fwrite(Args_Fwrite)\n                         {return (Retv_Fwrite)Xunix.Load_Error(\"fwrite\");}\n      Retv_Fgetxattr   Xrd_U_Fgetxattr(Args_Fgetxattr)\n                         {return (Retv_Fgetxattr)Xunix.Load_Error(\"fgetxattr\");}\n      Retv_Getxattr    Xrd_U_Getxattr(Args_Getxattr)\n                         {return (Retv_Getxattr)Xunix.Load_Error(\"getxattr\");}\n      Retv_Lgetxattr   Xrd_U_Lgetxattr(Args_Lgetxattr)\n                         {return (Retv_Lgetxattr)Xunix.Load_Error(\"lgetxattr\");}\n      Retv_Lseek       Xrd_U_Lseek(Args_Lseek) \n                         {return (Retv_Lseek)Xunix.Load_Error(\"lseek\");}\n      Retv_Lseek64     Xrd_U_Lseek64(Args_Lseek64)\n                         {return (Retv_Lseek64)Xunix.Load_Error(\"lseek\");}\n      Retv_Lstat       Xrd_U_Lstat(Args_Lstat)\n                         {return (Retv_Lstat)Xunix.Load_Error(\"lstat\");}\n      Retv_Lstat64     Xrd_U_Lstat64(Args_Lstat64)\n                         {return (Retv_Lstat64)Xunix.Load_Error(\"lstat\");}\n      Retv_Mkdir       Xrd_U_Mkdir(Args_Mkdir) \n                         {return (Retv_Mkdir)Xunix.Load_Error(\"mkdir\");}\n      Retv_Open        Xrd_U_Open(Args_Open) \n                         {return (Retv_Open)Xunix.Load_Error(\"open\");}\n      Retv_Open64      Xrd_U_Open64(Args_Open64)\n                         {return (Retv_Open64)Xunix.Load_Error(\"open\");}\n      Retv_Opendir     Xrd_U_Opendir(Args_Opendir) \n                         {Xunix.Load_Error(\"opendir\"); return (Retv_Opendir)0;}\n      Retv_Pathconf    Xrd_U_Pathconf(Args_Pathconf)\n                         {return (Retv_Pathconf)Xunix.Load_Error(\"pathconf\");}\n      Retv_Pread       Xrd_U_Pread(Args_Pread)\n                         {return (Retv_Pread)Xunix.Load_Error(\"pread\");}\n      Retv_Pread64     Xrd_U_Pread64(Args_Pread64)\n                         {return (Retv_Pread64)Xunix.Load_Error(\"pread\");}\n      Retv_Pwrite      Xrd_U_Pwrite(Args_Pwrite) \n                         {return (Retv_Pwrite)Xunix.Load_Error(\"pwrite\");}\n      Retv_Pwrite64    Xrd_U_Pwrite64(Args_Pwrite64)\n                         {return (Retv_Pwrite64)Xunix.Load_Error(\"pwrite\");}\n      Retv_Read        Xrd_U_Read(Args_Read) \n                         {return (Retv_Read)Xunix.Load_Error(\"read\");}\n      Retv_Readv       Xrd_U_Readv(Args_Readv) \n                         {return (Retv_Readv)Xunix.Load_Error(\"readv\");}\n      Retv_Readdir     Xrd_U_Readdir(Args_Readdir) \n                         {Xunix.Load_Error(\"readdir\"); return (Retv_Readdir)0;}\n      Retv_Readdir64   Xrd_U_Readdir64(Args_Readdir64)\n                         {Xunix.Load_Error(\"readdir64\");return (Retv_Readdir64)0;}\n      Retv_Readdir_r   Xrd_U_Readdir_r(Args_Readdir_r) \n                         {return (Retv_Readdir_r)Xunix.Load_Error(\"readdir_r\", ELIBACC);}\n      Retv_Readdir64_r Xrd_U_Readdir64_r(Args_Readdir64_r)\n                         {return (Retv_Readdir64_r)Xunix.Load_Error(\"readdir64_r\", ELIBACC);}\n      Retv_Rename      Xrd_U_Rename(Args_Rename)\n                         {return (Retv_Rename)Xunix.Load_Error(\"rename\");}\n      Retv_Rewinddir   Xrd_U_Rewinddir(Args_Rewinddir) \n                         {       Xunix.Load_Error(\"rewinddir\"); abort();}\n      Retv_Rmdir       Xrd_U_Rmdir(Args_Rmdir) \n                         {return (Retv_Rmdir)Xunix.Load_Error(\"rmdir\");}\n      Retv_Seekdir     Xrd_U_Seekdir(Args_Seekdir) \n                         {       Xunix.Load_Error(\"seekdir\"); abort();}\n      Retv_Stat        Xrd_U_Stat(Args_Stat) \n                         {return (Retv_Stat)Xunix.Load_Error(\"stat\");}\n      Retv_Stat64      Xrd_U_Stat64(Args_Stat64)\n                         {return (Retv_Stat64)Xunix.Load_Error(\"stat\");}\n      Retv_Statfs      Xrd_U_Statfs(Args_Statfs)\n                         {return (Retv_Statfs)Xunix.Load_Error(\"statfs\");}\n      Retv_Statfs64    Xrd_U_Statfs64(Args_Statfs64)\n                         {return (Retv_Statfs64)Xunix.Load_Error(\"statfs64\");}\n      Retv_Statvfs     Xrd_U_Statvfs(Args_Statvfs)\n                         {return (Retv_Statvfs)Xunix.Load_Error(\"statvfs\");}\n      Retv_Statvfs64   Xrd_U_Statvfs64(Args_Statvfs64)\n                         {return (Retv_Statvfs64)Xunix.Load_Error(\"statvfs64\");}\n      Retv_Telldir     Xrd_U_Telldir(Args_Telldir) \n                         {return (Retv_Telldir)Xunix.Load_Error(\"telldir\");}\n      Retv_Truncate    Xrd_U_Truncate(Args_Truncate)\n                         {return (Retv_Truncate)Xunix.Load_Error(\"truncate\");}\n      Retv_Truncate64  Xrd_U_Truncate64(Args_Truncate64)\n                         {return (Retv_Truncate64)Xunix.Load_Error(\"truncate64\");}\n      Retv_Unlink      Xrd_U_Unlink(Args_Unlink) \n                         {return (Retv_Unlink)Xunix.Load_Error(\"unlink\");}\n      Retv_Write       Xrd_U_Write(Args_Write) \n                         {return (Retv_Write)Xunix.Load_Error(\"write\");}\n      Retv_Writev      Xrd_U_Writev(Args_Writev) \n                         {return (Retv_Writev)Xunix.Load_Error(\"writev\");}\n  \n/******************************************************************************/\n/*           X r d P o s i x L i n k a g e   C o n s t r u c t o r            */\n/******************************************************************************/\n  \nint XrdPosixLinkage::Resolve()\n{\n  LOOKUP_UNIX(Access)\n  LOOKUP_UNIX(Acl)\n  LOOKUP_UNIX(Chdir)\n  LOOKUP_UNIX(Close)\n  LOOKUP_UNIX(Closedir)\n  LOOKUP_UNIX(Fclose)\n  LOOKUP_UNIX(Fcntl)\n  LOOKUP_UNIX(Fcntl64)\n  LOOKUP_UNIX(Fdatasync)\n  LOOKUP_UNIX(Fflush)\n  LOOKUP_UNIX(Fopen)\n  LOOKUP_UNIX(Fopen64)\n  LOOKUP_UNIX(Fread)\n  LOOKUP_UNIX(Fseek)\n  LOOKUP_UNIX(Fseeko)\n  LOOKUP_UNIX(Fseeko64)\n  LOOKUP_UNIX(Fstat)\n  LOOKUP_UNIX(Fstat64)\n  LOOKUP_UNIX(Fsync)\n  LOOKUP_UNIX(Ftell)\n  LOOKUP_UNIX(Ftello)\n  LOOKUP_UNIX(Ftello64)\n  LOOKUP_UNIX(Ftruncate)\n  LOOKUP_UNIX(Ftruncate64)\n  LOOKUP_UNIX(Fwrite)\n  LOOKUP_UNIX(Fgetxattr)\n  LOOKUP_UNIX(Getxattr)\n  LOOKUP_UNIX(Lgetxattr)\n  LOOKUP_UNIX(Lseek)\n  LOOKUP_UNIX(Lseek64)\n  LOOKUP_UNIX(Lstat)\n  LOOKUP_UNIX(Lstat64)\n  LOOKUP_UNIX(Fsync)\n  LOOKUP_UNIX(Mkdir)\n  LOOKUP_UNIX(Open)\n  LOOKUP_UNIX(Open64)\n  LOOKUP_UNIX(Opendir)\n  LOOKUP_UNIX(Pathconf)\n  LOOKUP_UNIX(Pread)\n  LOOKUP_UNIX(Pread64)\n  LOOKUP_UNIX(Pwrite)\n  LOOKUP_UNIX(Pwrite64)\n  LOOKUP_UNIX(Read)\n  LOOKUP_UNIX(Readv)\n  LOOKUP_UNIX(Readdir)\n  LOOKUP_UNIX(Readdir64)\n  LOOKUP_UNIX(Readdir_r)\n  LOOKUP_UNIX(Readdir64_r)\n  LOOKUP_UNIX(Rename)\n  LOOKUP_UNIX(Rewinddir)\n  LOOKUP_UNIX(Rmdir)\n  LOOKUP_UNIX(Seekdir)\n  LOOKUP_UNIX(Stat)\n  LOOKUP_UNIX(Stat64)\n  LOOKUP_UNIX(Statfs)\n  LOOKUP_UNIX(Statfs64)\n  LOOKUP_UNIX(Statvfs)\n  LOOKUP_UNIX(Statvfs64)\n  LOOKUP_UNIX(Telldir)\n  LOOKUP_UNIX(Truncate)\n  LOOKUP_UNIX(Truncate64)\n  LOOKUP_UNIX(Unlink)\n  LOOKUP_UNIX(Write)\n  LOOKUP_UNIX(Writev)\n  if (getenv(\"XRDPOSIX_REPORT\")) Missing(0);\n  return 1;\n}\n\n/******************************************************************************/\n/*           X r d P o s i x L i n k a g e : : L o a d _ E r r o r            */\n/******************************************************************************/\n  \nint XrdPosixLinkage::Load_Error(const char *epname, int retv)\n{\n    if (*Write != &Xrd_U_Write && *Writev != &Xrd_U_Writev)\n       cerr << \"PosixPreload: Unable to resolve Unix '\" <<epname <<\"()'\" <<endl;\n    errno = ELIBACC;\n    return retv;\n}\n\n/******************************************************************************/\n/*                               M i s s i n g                                */\n/******************************************************************************/\n  \nvoid XrdPosixLinkage::Missing(const char *epname)\n{\n   struct Missing\n         {struct Missing *Next;\n          const char     *What;\n\n                          Missing(Missing *Prev, const char *That)\n                                 : Next(Prev), What(That) {}\n                         ~Missing() {}\n         };\n\n   static Missing *epList = 0;\n\n   if (epname) epList = new Missing(epList, epname);\n      else {Missing *np = epList;\n            while(np) cerr << \"PosixPreload: Unable to resolve Unix '\" \n                           <<epname <<\"()'\" <<endl;\n            np = np->Next;\n           }\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-4.7.1-6ztgtlw45oyfa6oy2puynzeyzwvbkxxf/spack-src/src/XrdHttp/static/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-4.7.1-6ztgtlw45oyfa6oy2puynzeyzwvbkxxf/spack-src/bindings/python/docs/source/.static/img/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-4.7.1-6ztgtlw45oyfa6oy2puynzeyzwvbkxxf/spack-src/bindings/python/docs/source/.static/img/xrootd-200x68.png"
    ],
    "total_files": 1253
}