{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/common/libpmemcommon.vcxproj.filters": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup>\n    <Filter Include=\"Source Files\">\n      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>\n      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>\n    </Filter>\n    <Filter Include=\"Header Files\">\n      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>\n      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>\n    </Filter>\n  </ItemGroup>\n  <ItemGroup>\n    <ClCompile Include=\"bad_blocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"set_badblocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"file.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"file_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"mmap.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"mmap_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"pool_hdr.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"set.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"uuid.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"uuid_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"shutdown_state.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"os_deep_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"ctl.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"ctl_cow.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"ctl_prefault.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"ctl_fallocate.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"ctl_sds.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\config.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\badblocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\badblocks_none.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\source.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\source_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils_other.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\auto_flush_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\usc_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"rand.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"ctl.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"ctl_global.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"set_badblocks.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"dlsym.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"file.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"mmap.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"badblocks.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"os_deep.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"pmemcommon.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"pool_hdr.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"set.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"sys_util.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"uuid.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\config.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\pmem2_utils.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\auto_flush.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\auto_flush_windows.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n  </ItemGroup>\n</Project>",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/common/dlsym.h": "// SPDX-License-Identifier: BSD-3-Clause\n/* Copyright 2016-2017, Intel Corporation */\n\n/*\n * dlsym.h -- dynamic linking utilities with library-specific implementation\n */\n\n#ifndef PMDK_DLSYM_H\n#define PMDK_DLSYM_H 1\n\n#include \"out.h\"\n\n#if defined(USE_LIBDL) && !defined(_WIN32)\n\n#include <dlfcn.h>\n\n/*\n * util_dlopen -- calls real dlopen()\n */\nstatic inline void *\nutil_dlopen(const char *filename)\n{\n\tLOG(3, \"filename %s\", filename);\n\n\treturn dlopen(filename, RTLD_NOW);\n}\n\n/*\n * util_dlerror -- calls real dlerror()\n */\nstatic inline char *\nutil_dlerror(void)\n{\n\treturn dlerror();\n}\n\n/*\n * util_dlsym -- calls real dlsym()\n */\nstatic inline void *\nutil_dlsym(void *handle, const char *symbol)\n{\n\tLOG(3, \"handle %p symbol %s\", handle, symbol);\n\n\treturn dlsym(handle, symbol);\n}\n\n/*\n * util_dlclose -- calls real dlclose()\n */\nstatic inline int\nutil_dlclose(void *handle)\n{\n\tLOG(3, \"handle %p\", handle);\n\n\treturn dlclose(handle);\n}\n\n#else /* empty functions */\n\n/*\n * util_dlopen -- empty function\n */\nstatic inline void *\nutil_dlopen(const char *filename)\n{\n\terrno = ENOSYS;\n\treturn NULL;\n}\n\n/*\n * util_dlerror -- empty function\n */\nstatic inline char *\nutil_dlerror(void)\n{\n\terrno = ENOSYS;\n\treturn NULL;\n}\n\n/*\n * util_dlsym -- empty function\n */\nstatic inline void *\nutil_dlsym(void *handle, const char *symbol)\n{\n\terrno = ENOSYS;\n\treturn NULL;\n}\n\n/*\n * util_dlclose -- empty function\n */\nstatic inline int\nutil_dlclose(void *handle)\n{\n\terrno = ENOSYS;\n\treturn 0;\n}\n\n#endif\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/common/set.c": "// SPDX-License-Identifier: BSD-3-Clause\n/* Copyright 2015-2020, Intel Corporation */\n/*\n * Copyright (c) 2016, Microsoft Corporation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in\n *       the documentation and/or other materials provided with the\n *       distribution.\n *\n *     * Neither the name of the copyright holder nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * set.c -- pool set utilities\n */\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <endian.h>\n#include <errno.h>\n#include <stddef.h>\n#include <time.h>\n#include <ctype.h>\n#include <linux/limits.h>\n#include <sys/mman.h>\n\n#include \"libpmem.h\"\n#include \"librpmem.h\"\n#include \"set.h\"\n#include \"file.h\"\n#include \"os.h\"\n#include \"mmap.h\"\n#include \"util.h\"\n#include \"out.h\"\n#include \"dlsym.h\"\n#include \"valgrind_internal.h\"\n#include \"sys_util.h\"\n#include \"util_pmem.h\"\n#include \"fs.h\"\n#include \"os_deep.h\"\n#include \"set_badblocks.h\"\n\n#define LIBRARY_REMOTE \"librpmem.so.1\"\n#define SIZE_AUTODETECT_STR \"AUTO\"\n\n#define PMEM_EXT \".pmem\"\n#define PMEM_EXT_LEN sizeof(PMEM_EXT)\n#define PMEM_FILE_PADDING 6\n#define PMEM_FILE_NAME_MAX_LEN 20\n#define PMEM_FILE_MAX_LEN (PMEM_FILE_NAME_MAX_LEN + PMEM_FILE_PADDING)\n\nstatic RPMEMpool *(*Rpmem_create)(const char *target, const char *pool_set_name,\n\t\t\tvoid *pool_addr, size_t pool_size, unsigned *nlanes,\n\t\t\tconst struct rpmem_pool_attr *rpmem_attr);\nstatic RPMEMpool *(*Rpmem_open)(const char *target, const char *pool_set_name,\n\t\t\tvoid *pool_addr, size_t pool_size, unsigned *nlanes,\n\t\t\tstruct rpmem_pool_attr *rpmem_attr);\nint (*Rpmem_close)(RPMEMpool *rpp);\nint (*Rpmem_persist)(RPMEMpool *rpp, size_t offset, size_t length,\n\t\t\tunsigned lane, unsigned flags);\nint (*Rpmem_deep_persist)(RPMEMpool *rpp, size_t offset, size_t length,\n\t\t\tunsigned lane);\nint (*Rpmem_read)(RPMEMpool *rpp, void *buff, size_t offset,\n\t\tsize_t length, unsigned lane);\nint (*Rpmem_remove)(const char *target, const char *pool_set_name, int flags);\nint (*Rpmem_set_attr)(RPMEMpool *rpp, const struct rpmem_pool_attr *rattr);\n\nstatic int Remote_replication_available;\nstatic os_mutex_t Remote_lock;\nstatic void *Rpmem_handle_remote;\n\nint Prefault_at_open = 0;\nint Prefault_at_create = 0;\nint SDS_at_create = POOL_FEAT_INCOMPAT_DEFAULT & POOL_E_FEAT_SDS ? 1 : 0;\nint Fallocate_at_create = 1;\nint COW_at_open = 0;\n\n/* list of pool set option names and flags */\nstatic const struct pool_set_option Options[] = {\n\t{ \"SINGLEHDR\", OPTION_SINGLEHDR },\n#ifndef _WIN32\n\t{ \"NOHDRS\", OPTION_NOHDRS },\n#endif\n\t{ NULL, OPTION_UNKNOWN }\n};\n\n/*\n * util_remote_init -- initialize remote replication\n */\nvoid\nutil_remote_init(void)\n{\n\tLOG(3, NULL);\n\n\t/* XXX Is duplicate initialization really okay? */\n\tif (!Remote_replication_available) {\n\t\tutil_mutex_init(&Remote_lock);\n\t\tRemote_replication_available = 1;\n\t}\n}\n\n/*\n * util_remote_fini -- finalize remote replication\n */\nvoid\nutil_remote_fini(void)\n{\n\tLOG(3, NULL);\n\n\tutil_remote_unload();\n\n\t/* XXX Okay to be here if not initialized? */\n\tif (Remote_replication_available) {\n\t\tRemote_replication_available = 0;\n\t\tutil_mutex_destroy(&Remote_lock);\n\t}\n}\n\n/*\n * util_dl_check_error -- check libdl error\n */\nstatic int\nutil_dl_check_error(void *handle, const char *func)\n{\n\tLOG(15, \"handle %p func %s\", handle, func);\n\n\tif (handle == NULL) {\n\t\tchar *errstr = util_dlerror();\n\t\tif (errstr)\n\t\t\tERR(\"%s(): %s\", func, errstr);\n\t\terrno = ELIBACC;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * util_remote_unload_core -- (internal) unload remote library (core function)\n */\nstatic void\nutil_remote_unload_core(void)\n{\n\tif (Rpmem_handle_remote != NULL) {\n\t\tutil_dlclose(Rpmem_handle_remote);\n\t\tRpmem_handle_remote = NULL;\n\t}\n\tRpmem_create = NULL;\n\tRpmem_open = NULL;\n\tRpmem_close = NULL;\n\tRpmem_persist = NULL;\n\tRpmem_deep_persist = NULL;\n\tRpmem_read = NULL;\n\tRpmem_remove = NULL;\n\tRpmem_set_attr = NULL;\n}\n\n/*\n * util_remote_unload -- unload remote library\n */\nvoid\nutil_remote_unload(void)\n{\n\tLOG(3, NULL);\n\n\tif (!Remote_replication_available)\n\t\treturn;\n\n\tutil_mutex_lock(&Remote_lock);\n\n\tutil_remote_unload_core();\n\n\tutil_mutex_unlock(&Remote_lock);\n}\n\n/*\n * util_remote_load -- load remote library\n */\nint\nutil_remote_load(void)\n{\n\tLOG(3, NULL);\n\n\tif (!Remote_replication_available) {\n\t\tERR(\"remote replication is not available\");\n\t\treturn -1;\n\t}\n\n\tCHECK_FUNC_COMPATIBLE(rpmem_create, *Rpmem_create);\n\tCHECK_FUNC_COMPATIBLE(rpmem_open, *Rpmem_open);\n\tCHECK_FUNC_COMPATIBLE(rpmem_close, *Rpmem_close);\n\tCHECK_FUNC_COMPATIBLE(rpmem_persist, *Rpmem_persist);\n\tCHECK_FUNC_COMPATIBLE(rpmem_deep_persist, *Rpmem_deep_persist);\n\tCHECK_FUNC_COMPATIBLE(rpmem_read, *Rpmem_read);\n\tCHECK_FUNC_COMPATIBLE(rpmem_remove, *Rpmem_remove);\n\n\tutil_mutex_lock(&Remote_lock);\n\n\tif (Rpmem_handle_remote)\n\t\tgoto end;\n\n\tRpmem_handle_remote = util_dlopen(LIBRARY_REMOTE);\n\tif (util_dl_check_error(Rpmem_handle_remote, \"dlopen\")) {\n\t\tERR(\"the pool set requires a remote replica, \"\n\t\t    \"but the '%s' library cannot be loaded\",\n\t\t    LIBRARY_REMOTE);\n\t\tgoto err;\n\t}\n\n\tRpmem_create = util_dlsym(Rpmem_handle_remote, \"rpmem_create\");\n\tif (util_dl_check_error(Rpmem_create, \"dlsym\")) {\n\t\tERR(\"symbol 'rpmem_create' not found\");\n\t\tgoto err;\n\t}\n\n\tRpmem_open = util_dlsym(Rpmem_handle_remote, \"rpmem_open\");\n\tif (util_dl_check_error(Rpmem_open, \"dlsym\")) {\n\t\tERR(\"symbol 'rpmem_open' not found\");\n\t\tgoto err;\n\t}\n\n\tRpmem_close = util_dlsym(Rpmem_handle_remote, \"rpmem_close\");\n\tif (util_dl_check_error(Rpmem_close, \"dlsym\")) {\n\t\tERR(\"symbol 'rpmem_close' not found\");\n\t\tgoto err;\n\t}\n\n\tRpmem_persist = util_dlsym(Rpmem_handle_remote, \"rpmem_persist\");\n\tif (util_dl_check_error(Rpmem_persist, \"dlsym\")) {\n\t\tERR(\"symbol 'rpmem_persist' not found\");\n\t\tgoto err;\n\t}\n\n\tRpmem_deep_persist = util_dlsym(Rpmem_handle_remote,\n\t\t\t\"rpmem_deep_persist\");\n\tif (util_dl_check_error(Rpmem_deep_persist, \"dlsym\")) {\n\t\tERR(\"symbol 'rpmem_deep_persist' not found\");\n\t\tgoto err;\n\t}\n\n\tRpmem_read = util_dlsym(Rpmem_handle_remote, \"rpmem_read\");\n\tif (util_dl_check_error(Rpmem_read, \"dlsym\")) {\n\t\tERR(\"symbol 'rpmem_read' not found\");\n\t\tgoto err;\n\t}\n\n\tRpmem_remove = util_dlsym(Rpmem_handle_remote, \"rpmem_remove\");\n\tif (util_dl_check_error(Rpmem_remove, \"dlsym\")) {\n\t\tERR(\"symbol 'rpmem_remove' not found\");\n\t\tgoto err;\n\t}\n\n\tRpmem_set_attr = util_dlsym(Rpmem_handle_remote, \"rpmem_set_attr\");\n\tif (util_dl_check_error(Rpmem_set_attr, \"dlsym\")) {\n\t\tERR(\"symbol 'rpmem_set_attr' not found\");\n\t\tgoto err;\n\t}\n\nend:\n\tutil_mutex_unlock(&Remote_lock);\n\treturn 0;\n\nerr:\n\tLOG(4, \"error clean up\");\n\tutil_remote_unload_core();\n\tutil_mutex_unlock(&Remote_lock);\n\treturn -1;\n}\n\n/* reserve space for size, path and some whitespace and/or comment */\n\nenum parser_codes {\n\tPARSER_CONTINUE = 0,\n\tPARSER_PMEMPOOLSET,\n\tPARSER_REPLICA,\n\tPARSER_INVALID_TOKEN,\n\tPARSER_REMOTE_REPLICA_EXPECTED,\n\tPARSER_WRONG_SIZE,\n\tPARSER_CANNOT_READ_SIZE,\n\tPARSER_ABSOLUTE_PATH_EXPECTED,\n\tPARSER_RELATIVE_PATH_EXPECTED,\n\tPARSER_SET_NO_PARTS,\n\tPARSER_REP_NO_PARTS,\n\tPARSER_REMOTE_REP_UNEXPECTED_PARTS,\n\tPARSER_SIZE_MISMATCH,\n\tPARSER_OUT_OF_MEMORY,\n\tPARSER_OPTION_UNKNOWN,\n\tPARSER_OPTION_EXPECTED,\n\tPARSER_FORMAT_OK,\n\tPARSER_MAX_CODE\n};\n\nstatic const char *parser_errstr[PARSER_MAX_CODE] = {\n\t\"\", /* parsing */\n\t\"the first line must be exactly 'PMEMPOOLSET'\",\n\t\"exactly 'REPLICA' expected\",\n\t\"invalid token found in the current line\",\n\t\"address of remote node and descriptor of remote pool set expected\",\n\t\"incorrect format of size\",\n\t\"cannot determine size of a part\",\n\t\"incorrect path (must be an absolute one)\",\n\t\"incorrect descriptor (must be a relative path)\",\n\t\"no pool set parts\",\n\t\"no replica parts\",\n\t\"unexpected parts for remote replica\",\n\t\"sizes of pool set and replica mismatch\",\n\t\"allocating memory failed\",\n\t\"unknown option\",\n\t\"missing option name\",\n\t\"\" /* format correct */\n};\n\n/*\n * util_replica_force_page_allocation - (internal) forces page allocation for\n * replica\n */\nstatic void\nutil_replica_force_page_allocation(struct pool_replica *rep)\n{\n\tvolatile char *cur_addr = rep->part[0].addr;\n\tchar *addr_end = (char *)cur_addr + rep->resvsize;\n\tfor (; cur_addr < addr_end; cur_addr += Pagesize) {\n\t\t*cur_addr = *cur_addr;\n\t\tVALGRIND_SET_CLEAN(cur_addr, 1);\n\t}\n}\n\n/*\n * util_map_hdr -- map a header of a pool set\n */\nint\nutil_map_hdr(struct pool_set_part *part, int flags, int rdonly)\n{\n\tLOG(3, \"part %p flags %d\", part, flags);\n\n\tCOMPILE_ERROR_ON(POOL_HDR_SIZE == 0);\n\tASSERTeq(POOL_HDR_SIZE % Pagesize, 0);\n\n\t/*\n\t * Workaround for Device DAX not allowing to map a portion\n\t * of the device if offset/length are not aligned to the internal\n\t * device alignment (page size).  I.e. if the device alignment\n\t * is 2M, we cannot map the 4K header, but need to align the mapping\n\t * length to 2M.\n\t *\n\t * According to mmap(2), system should automatically align mapping\n\t * length to be a multiple of the underlying page size, but it's\n\t * not true for Device DAX.\n\t */\n\tsize_t hdrsize = part->alignment > POOL_HDR_SIZE\n\t\t\t? part->alignment : POOL_HDR_SIZE;\n\n\tvoid *addr = NULL;\n\n#if VG_MEMCHECK_ENABLED\n\tif (On_valgrind) {\n\t\t/* this is required only for Device DAX & memcheck */\n\t\taddr = util_map_hint(hdrsize, hdrsize);\n\t\tif (addr == MAP_FAILED) {\n\t\t\tLOG(1, \"cannot find a contiguous region of given size\");\n\t\t\t/* there's nothing we can do */\n\t\t\treturn -1;\n\t\t}\n\t}\n#endif\n\n\tint prot = rdonly ? PROT_READ : PROT_READ|PROT_WRITE;\n\tvoid *hdrp = util_map_sync(addr, hdrsize, prot, flags,\n\t\t\tpart->fd, 0, &part->hdr_map_sync);\n\tif (hdrp == MAP_FAILED) {\n\t\tERR(\"!mmap: %s\", part->path);\n\t\treturn -1;\n\t}\n\n\tpart->hdrsize = hdrsize;\n\tpart->hdr = hdrp;\n\n\tVALGRIND_REGISTER_PMEM_MAPPING(part->hdr, part->hdrsize);\n\tVALGRIND_REGISTER_PMEM_FILE(part->fd, part->hdr, part->hdrsize, 0);\n\n\treturn 0;\n}\n\n/*\n * util_unmap_hdr -- unmap pool set part header\n */\nvoid\nutil_unmap_hdr(struct pool_set_part *part)\n{\n\tif (part->hdr == NULL || part->hdrsize == 0)\n\t\treturn;\n\n\tLOG(4, \"munmap: addr %p size %zu\", part->hdr, part->hdrsize);\n\tVALGRIND_REMOVE_PMEM_MAPPING(part->hdr, part->hdrsize);\n\tif (munmap(part->hdr, part->hdrsize) != 0)\n\t\t/* this means there's a bug on the caller side */\n\t\tFATAL(\"!munmap: %s\", part->path);\n\tpart->hdr = NULL;\n\tpart->hdrsize = 0;\n}\n\n/*\n * util_map_part -- map a part of a pool set\n */\nint\nutil_map_part(struct pool_set_part *part, void *addr, size_t size,\n\tsize_t offset, int flags, int rdonly)\n{\n\tLOG(3, \"part %p addr %p size %zu offset %zu flags %d\",\n\t\tpart, addr, size, offset, flags);\n\n\tASSERTeq((uintptr_t)addr % Mmap_align, 0);\n\tASSERTeq(offset % Mmap_align, 0);\n\tASSERTeq(size % Mmap_align, 0);\n\tASSERT(((os_off_t)offset) >= 0);\n\tASSERTeq(offset % part->alignment, 0);\n\tASSERT(offset < part->filesize);\n\n\tif (!size)\n\t\tsize = (part->filesize - offset) & ~(part->alignment - 1);\n\telse\n\t\tsize = roundup(size, part->alignment);\n\n\tint prot = rdonly ? PROT_READ : PROT_READ | PROT_WRITE;\n\tvoid *addrp = util_map_sync(addr, size, prot, flags, part->fd,\n\t\t\t(os_off_t)offset, &part->map_sync);\n\tif (addrp == MAP_FAILED) {\n\t\tERR(\"!mmap: %s\", part->path);\n\t\treturn -1;\n\t}\n\n\tif (addr != NULL && (flags & MAP_FIXED) && addrp != addr) {\n\t\tERR(\"unable to map at requested address %p\", addr);\n\t\tmunmap(addrp, size);\n\t\treturn -1;\n\t}\n\n\tpart->addr = addrp;\n\tpart->size = size;\n\n\tVALGRIND_REGISTER_PMEM_MAPPING(part->addr, part->size);\n\tVALGRIND_REGISTER_PMEM_FILE(part->fd, part->addr, part->size, offset);\n\n\treturn 0;\n}\n\n/*\n * util_unmap_part -- unmap a part of a pool set\n */\nint\nutil_unmap_part(struct pool_set_part *part)\n{\n\tLOG(3, \"part %p\", part);\n\n\tif (part->addr != NULL && part->size != 0) {\n\t\tLOG(4, \"munmap: addr %p size %zu\", part->addr, part->size);\n\t\tVALGRIND_REMOVE_PMEM_MAPPING(part->addr, part->size);\n\t\tif (munmap(part->addr, part->size) != 0) {\n\t\t\tERR(\"!munmap: %s\", part->path);\n\t\t}\n\n\t\tpart->addr = NULL;\n\t\tpart->size = 0;\n\t}\n\n\treturn 0;\n}\n\n/*\n * util_unmap_parts -- unmap parts from start_index to the end_index\n */\nint\nutil_unmap_parts(struct pool_replica *rep, unsigned start_index,\n\tunsigned end_index)\n{\n\tLOG(3, \"rep: %p, start_index: %u, end_index: %u\", rep, start_index,\n\t\tend_index);\n\n\tfor (unsigned p = start_index; p <= end_index; p++)\n\t\tutil_unmap_part(&rep->part[p]);\n\n\treturn 0;\n}\n\n/*\n * util_poolset_free -- free pool set info\n */\nvoid\nutil_poolset_free(struct pool_set *set)\n{\n\tLOG(3, \"set %p\", set);\n\n\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\tstruct pool_replica *rep = set->replica[r];\n\t\tif (rep->remote == NULL) {\n\t\t\t/* only local replicas have paths */\n\t\t\tfor (unsigned p = 0; p < rep->nallocated; p++) {\n\t\t\t\tFree((void *)(rep->part[p].path));\n\t\t\t}\n\t\t} else {\n\t\t\t/* remote replica */\n\t\t\tASSERTeq(rep->nparts, 1);\n\t\t\tFree(rep->remote->node_addr);\n\t\t\tFree(rep->remote->pool_desc);\n\t\t\tFree(rep->remote);\n\t\t}\n\t\tstruct pool_set_directory *d;\n\t\tVEC_FOREACH_BY_PTR(d, &rep->directory) {\n\t\t\tFree((void *)d->path);\n\t\t}\n\t\tVEC_DELETE(&rep->directory);\n\t\tFree(set->replica[r]);\n\t}\n\tFree(set->path);\n\tFree(set);\n}\n\n/*\n * util_poolset_open -- open all replicas from a poolset\n */\nint\nutil_poolset_open(struct pool_set *set)\n{\n\tfor (unsigned r = 0; r < set->nreplicas; ++r) {\n\t\tif (util_replica_open(set, r, MAP_SHARED)) {\n\t\t\tLOG(2, \"replica open failed: replica %u\", r);\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * util_replica_close_local -- close local replica, optionally delete the\n *                             replica's parts\n */\nint\nutil_replica_close_local(struct pool_replica *rep, unsigned repn,\n\t\tenum del_parts_mode del)\n{\n\tfor (unsigned p = 0; p < rep->nparts; p++) {\n\t\tif (rep->part[p].fd != -1)\n\t\t\t(void) os_close(rep->part[p].fd);\n\n\t\tif ((del == DELETE_CREATED_PARTS && rep->part[p].created) ||\n\t\t\t\tdel == DELETE_ALL_PARTS) {\n\t\t\tLOG(4, \"unlink %s\", rep->part[p].path);\n\t\t\tint olderrno = errno;\n\t\t\tif (util_unlink(rep->part[p].path) && errno != ENOENT) {\n\t\t\t\tERR(\"!unlink %s failed (part %u, replica %u)\",\n\t\t\t\t\t\trep->part[p].path, p, repn);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\terrno = olderrno;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * util_replica_close_remote -- close remote replica, optionally delete the\n *                              replica\n */\nint\nutil_replica_close_remote(struct pool_replica *rep, unsigned repn,\n\t\tenum del_parts_mode del)\n{\n\tif (!rep->remote)\n\t\treturn 0;\n\n\tif (rep->remote->rpp) {\n\t\tLOG(4, \"closing remote replica #%u\", repn);\n\t\tRpmem_close(rep->remote->rpp);\n\t\trep->remote->rpp = NULL;\n\t}\n\n\tif ((del == DELETE_CREATED_PARTS && rep->part[0].created) ||\n\t\t\tdel == DELETE_ALL_PARTS) {\n\t\tLOG(4, \"removing remote replica #%u\", repn);\n\t\tint ret = Rpmem_remove(rep->remote->node_addr,\n\t\t\trep->remote->pool_desc, 0);\n\t\tif (ret) {\n\t\t\tLOG(1, \"!removing remote replica #%u failed\", repn);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * util_poolset_close -- unmap and close all the parts of the pool set,\n *                       optionally delete parts\n */\nvoid\nutil_poolset_close(struct pool_set *set, enum del_parts_mode del)\n{\n\tLOG(3, \"set %p del %d\", set, del);\n\n\tint oerrno = errno;\n\n\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\tutil_replica_close(set, r);\n\n\t\tstruct pool_replica *rep = set->replica[r];\n\t\tif (!rep->remote)\n\t\t\t(void) util_replica_close_local(rep, r, del);\n\t\telse\n\t\t\t(void) util_replica_close_remote(rep, r, del);\n\t}\n\n\t/*\n\t * XXX On FreeBSD, mmap()ing a file does not increment the flock()\n\t *     reference count, so we had to keep the files open until now.\n\t */\n#ifdef __FreeBSD__\n\tutil_poolset_fdclose_always(set);\n#endif\n\tutil_poolset_free(set);\n\n\terrno = oerrno;\n}\n\n/*\n * util_poolset_chmod -- change mode for all created files related to pool set\n */\nint\nutil_poolset_chmod(struct pool_set *set, mode_t mode)\n{\n\tLOG(3, \"set %p mode %o\", set, mode);\n\n\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\tstruct pool_replica *rep = set->replica[r];\n\n\t\t/* skip remote replicas */\n\t\tif (rep->remote != NULL)\n\t\t\tcontinue;\n\n\t\tfor (unsigned p = 0; p < rep->nparts; p++) {\n\t\t\tstruct pool_set_part *part = &rep->part[p];\n\n\t\t\t/* skip not created or closed parts */\n\t\t\tif (!part->created || part->fd == -1)\n\t\t\t\tcontinue;\n\n\t\t\tos_stat_t stbuf;\n\t\t\tif (os_fstat(part->fd, &stbuf) != 0) {\n\t\t\t\tERR(\"!fstat %d %s\", part->fd, part->path);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (stbuf.st_mode & ~(unsigned)S_IFMT) {\n\t\t\t\tLOG(1, \"file permissions changed during pool \"\n\t\t\t\t\t\"initialization, file: %s (%o)\",\n\t\t\t\t\tpart->path,\n\t\t\t\t\tstbuf.st_mode & ~(unsigned)S_IFMT);\n\t\t\t}\n\n\t\t\tif (os_chmod(part->path, mode)) {\n\t\t\t\tERR(\"!chmod %u/%u/%s\", r, p, part->path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * util_poolset_fdclose_always -- close file descriptors related to pool set\n */\nvoid\nutil_poolset_fdclose_always(struct pool_set *set)\n{\n\tLOG(3, \"set %p\", set);\n\n\tfor (unsigned r = 0; r < set->nreplicas; r++)\n\t\tutil_replica_fdclose(set->replica[r]);\n}\n\n/*\n * util_poolset_fdclose -- close pool set file descriptors if not FreeBSD\n *\n * XXX On FreeBSD, mmap()ing a file does not increment the flock()\n *\treference count, so we need to keep the files open.\n */\nvoid\nutil_poolset_fdclose(struct pool_set *set)\n{\n#ifdef __FreeBSD__\n\tLOG(3, \"set %p: holding open\", set);\n#else\n\tutil_poolset_fdclose_always(set);\n#endif\n}\n\n/*\n * util_autodetect_size -- (internal) retrieves size of an existing file\n */\nstatic ssize_t\nutil_autodetect_size(const char *path)\n{\n\tenum file_type type = util_file_get_type(path);\n\tif (type < 0)\n\t\treturn -1;\n\n\tif (type == TYPE_NORMAL) {\n\t\tERR(\"size autodetection is supported only for device dax\");\n\t\treturn -1;\n\t}\n\n\treturn util_file_get_size(path);\n}\n\n/*\n * parser_read_line -- (internal) read line and validate size and path\n *                      from a pool set file\n */\nstatic enum parser_codes\nparser_read_line(char *line, size_t *size, char **path)\n{\n\tint ret;\n\tchar *size_str;\n\tchar *path_str;\n\tchar *rest_str;\n\tchar *saveptr = NULL; /* must be NULL initialized on Windows */\n\n\tsize_str = strtok_r(line, \" \\t\", &saveptr);\n\tpath_str = strtok_r(NULL, \" \\t\", &saveptr);\n\trest_str = strtok_r(NULL, \" \\t\", &saveptr);\n\n\tif (!size_str || !path_str || rest_str)\n\t\treturn PARSER_INVALID_TOKEN;\n\n\tLOG(10, \"size '%s' path '%s'\", size_str, path_str);\n\n\t/*\n\t * A format of the size is checked in detail. As regards the path,\n\t * it is checked only if the read path is an absolute path.\n\t * The rest should be checked during creating/opening the file.\n\t */\n\n\t/* check if the read path is an absolute path */\n\tif (!util_is_absolute_path(path_str))\n\t\treturn PARSER_ABSOLUTE_PATH_EXPECTED;\n\n\t*path = Strdup(path_str);\n\tif (!(*path)) {\n\t\tERR(\"!Strdup\");\n\t\treturn PARSER_OUT_OF_MEMORY;\n\t}\n\n\tif (strcmp(SIZE_AUTODETECT_STR, size_str) == 0) {\n\t\t/*\n\t\t * XXX: this should be done after the parsing completes, but\n\t\t * currently this operation is performed in simply too many\n\t\t * places in the code to move this someplace else.\n\t\t */\n\t\tssize_t s = util_autodetect_size(path_str);\n\t\tif (s < 0) {\n\t\t\tFree(*path);\n\t\t\t*path = NULL;\n\t\t\treturn PARSER_CANNOT_READ_SIZE;\n\t\t}\n\n\t\t*size = (size_t)s;\n\n\t\treturn PARSER_CONTINUE;\n\t}\n\n\tret = util_parse_size(size_str, size);\n\tif (ret != 0 || *size == 0) {\n\t\tFree(*path);\n\t\t*path = NULL;\n\t\treturn PARSER_WRONG_SIZE;\n\t}\n\n\treturn PARSER_CONTINUE;\n}\n\n/*\n * parser_read_replica -- (internal) read line and validate remote replica\n *                        from a pool set file\n */\nstatic enum parser_codes\nparser_read_replica(char *line, char **node_addr, char **pool_desc)\n{\n\tchar *addr_str;\n\tchar *desc_str;\n\tchar *rest_str;\n\tchar *saveptr = NULL; /* must be NULL initialized on Windows */\n\n\taddr_str = strtok_r(line, \" \\t\", &saveptr);\n\tdesc_str = strtok_r(NULL, \" \\t\", &saveptr);\n\trest_str = strtok_r(NULL, \" \\t\", &saveptr);\n\n\tif (!addr_str || !desc_str)\n\t\treturn PARSER_REMOTE_REPLICA_EXPECTED;\n\n\tif (rest_str)\n\t\treturn PARSER_INVALID_TOKEN;\n\n\tLOG(10, \"node address '%s' pool set descriptor '%s'\",\n\t\taddr_str, desc_str);\n\n\t/* check if the descriptor is a relative path */\n\tif (util_is_absolute_path(desc_str))\n\t\treturn PARSER_RELATIVE_PATH_EXPECTED;\n\n\t*node_addr = Strdup(addr_str);\n\t*pool_desc = Strdup(desc_str);\n\n\tif (!(*node_addr) || !(*pool_desc)) {\n\t\tERR(\"!Strdup\");\n\t\tif (*node_addr)\n\t\t\tFree(*node_addr);\n\t\tif (*pool_desc)\n\t\t\tFree(*pool_desc);\n\t\treturn PARSER_OUT_OF_MEMORY;\n\t}\n\n\treturn PARSER_CONTINUE;\n}\n\n/*\n * parser_read_options -- (internal) read line and validate options\n */\nstatic enum parser_codes\nparser_read_options(char *line, unsigned *options)\n{\n\tLOG(3, \"line '%s'\", line);\n\n\tint opt_cnt = 0;\n\tchar *saveptr = NULL; /* must be NULL initialized on Windows */\n\n\tchar *opt_str = strtok_r(line, \" \\t\", &saveptr);\n\twhile (opt_str != NULL) {\n\t\tLOG(4, \"option '%s'\", opt_str);\n\n\t\tint i = 0;\n\t\twhile (Options[i].name && strcmp(opt_str, Options[i].name) != 0)\n\t\t\ti++;\n\n\t\tif (Options[i].name == NULL) {\n\t\t\tLOG(4, \"unknown option '%s'\", opt_str);\n\t\t\treturn PARSER_OPTION_UNKNOWN;\n\t\t}\n\n\t\tif (*options & Options[i].flag)\n\t\t\tLOG(4, \"duplicated option '%s'\", opt_str);\n\n\t\t*options |= Options[i].flag;\n\n\t\topt_cnt++;\n\t\topt_str = strtok_r(NULL, \" \\t\", &saveptr);\n\t}\n\n\tif (opt_cnt == 0)\n\t\treturn PARSER_OPTION_EXPECTED;\n\n\treturn PARSER_CONTINUE;\n}\n\n/*\n * util_replica_reserve -- reserves part slots capacity in a replica\n */\nstatic int\nutil_replica_reserve(struct pool_replica **repp, unsigned n)\n{\n\tLOG(3, \"replica %p n %u\", *repp, n);\n\n\tstruct pool_replica *rep = *repp;\n\tif (rep->nallocated >= n)\n\t\treturn 0;\n\n\trep = Realloc(rep, sizeof(struct pool_replica) +\n\t\t(n) * sizeof(struct pool_set_part));\n\tif (rep == NULL) {\n\t\tERR(\"!Realloc\");\n\t\treturn -1;\n\t}\n\n\tsize_t nsize = sizeof(struct pool_set_part) * (n - rep->nallocated);\n\tmemset(rep->part + rep->nallocated, 0, nsize);\n\n\trep->nallocated = n;\n\t*repp = rep;\n\n\treturn 0;\n}\n\n/*\n * util_replica_add_part_by_idx -- (internal) allocates, initializes and adds a\n *\tpart structure at the provided location in the replica info\n */\nstatic int\nutil_replica_add_part_by_idx(struct pool_replica **repp,\n\tconst char *path, size_t filesize, unsigned p)\n{\n\tLOG(3, \"replica %p path %s filesize %zu\", *repp, path, filesize);\n\n\tif (util_replica_reserve(repp, p + 1) != 0)\n\t\treturn -1;\n\n\tstruct pool_replica *rep = *repp;\n\tASSERTne(rep, NULL);\n\n\tint is_dev_dax = 0;\n\n\tif (path != NULL) {\n\t\tenum file_type type = util_file_get_type(path);\n\t\tif (type == OTHER_ERROR)\n\t\t\treturn -1;\n\n\t\tis_dev_dax = type == TYPE_DEVDAX;\n\t}\n\n\trep->part[p].path = path;\n\trep->part[p].filesize = filesize;\n\trep->part[p].fd = -1;\n\trep->part[p].is_dev_dax = is_dev_dax;\n\trep->part[p].created = 0;\n\trep->part[p].hdr = NULL;\n\trep->part[p].addr = NULL;\n\trep->part[p].remote_hdr = NULL;\n\trep->part[p].has_bad_blocks = 0;\n\n\tif (is_dev_dax)\n\t\trep->part[p].alignment = util_file_device_dax_alignment(path);\n\telse\n\t\trep->part[p].alignment = Mmap_align;\n\n\tASSERTne(rep->part[p].alignment, 0);\n\n\trep->nparts += 1;\n\n\treturn 0;\n}\n\n/*\n * util_replica_add_part -- adds a next part in replica info\n */\nstatic int\nutil_replica_add_part(struct pool_replica **repp,\n\tconst char *path, size_t filesize)\n{\n\tLOG(3, \"replica %p path \\\"%s\\\" filesize %zu\", *repp, path, filesize);\n\n\treturn util_replica_add_part_by_idx(repp, path,\n\t\tfilesize, (*repp)->nparts);\n}\n\n/*\n * util_parse_add_part -- (internal) add a new part file to the replica info\n */\nstatic int\nutil_parse_add_part(struct pool_set *set, const char *path, size_t filesize)\n{\n\tLOG(3, \"set %p path %s filesize %zu\", set, path, filesize);\n\n\tASSERTne(set, NULL);\n\n\tif (set->directory_based) {\n\t\tERR(\"cannot mix directories and files in a set\");\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\treturn util_replica_add_part(&set->replica[set->nreplicas - 1],\n\t\tpath, filesize);\n}\n\n/*\n * util_parse_add_directory --\n *\t(internal) add a new directory to the replica info\n */\nstatic int\nutil_parse_add_directory(struct pool_set *set, const char *path,\n\tsize_t filesize)\n{\n\tLOG(3, \"set %p path %s filesize %zu\", set, path, filesize);\n\n\tASSERTne(set, NULL);\n\n\tstruct pool_replica *rep = set->replica[set->nreplicas - 1];\n\tASSERTne(rep, NULL);\n\n\tif (set->directory_based == 0) {\n\t\tif (rep->nparts > 0 || set->nreplicas > 1) {\n\t\t\tERR(\"cannot mix directories and files in a set\");\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tset->directory_based = 1;\n\t}\n\n\tchar *rpath = util_part_realpath(path);\n\tif (rpath == NULL) {\n\t\tERR(\"cannot resolve realpath of new directory\");\n\t\treturn -1;\n\t}\n\n\tfor (unsigned i = 0; i < set->nreplicas; ++i) {\n\t\tstruct pool_replica *r = set->replica[i];\n\t\tstruct pool_set_directory *dir;\n\t\tchar *dpath = NULL;\n\t\tVEC_FOREACH_BY_PTR(dir, &r->directory) {\n\t\t\tdpath = util_part_realpath(dir->path);\n\t\t\tASSERTne(dpath, NULL); /* must have been resolved */\n\t\t\tif (strcmp(rpath, dpath) == 0) {\n\t\t\t\tERR(\"cannot use the same directory twice\");\n\t\t\t\terrno = EEXIST;\n\t\t\t\tfree(dpath);\n\t\t\t\tfree(rpath);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfree(dpath);\n\t\t}\n\t}\n\tfree(rpath);\n\n\tstruct pool_set_directory d;\n\td.path = path;\n\td.resvsize = filesize;\n\n\tif (VEC_PUSH_BACK(&rep->directory, d) != 0)\n\t\treturn -1;\n\n\trep->resvsize += filesize;\n\n\treturn 0;\n}\n\n/*\n * util_parse_add_element --\n *\t(internal) add a new element to the replica info\n */\nstatic int\nutil_parse_add_element(struct pool_set *set, const char *path, size_t filesize)\n{\n\tLOG(3, \"set %p path %s filesize %zu\", set, path, filesize);\n\n\tos_stat_t stat;\n\n\tint olderrno = errno;\n\n\tif (os_stat(path, &stat) == 0 && S_ISDIR(stat.st_mode))\n\t\treturn util_parse_add_directory(set, path, filesize);\n\n\terrno = olderrno;\n\n\treturn util_parse_add_part(set, path, filesize);\n}\n\n/*\n * util_parse_add_replica -- (internal) add a new replica to the pool set info\n */\nstatic int\nutil_parse_add_replica(struct pool_set **setp)\n{\n\tLOG(3, \"setp %p\", setp);\n\n\tASSERTne(setp, NULL);\n\n\tstruct pool_set *set = *setp;\n\tASSERTne(set, NULL);\n\n\tset = Realloc(set, sizeof(struct pool_set) +\n\t\t\t(set->nreplicas + 1) * sizeof(struct pool_replica *));\n\tif (set == NULL) {\n\t\tERR(\"!Realloc\");\n\t\treturn -1;\n\t}\n\t*setp = set;\n\n\tstruct pool_replica *rep;\n\trep = Zalloc(sizeof(struct pool_replica));\n\tif (rep == NULL) {\n\t\tERR(\"!Zalloc\");\n\t\treturn -1;\n\t}\n\n\tVEC_INIT(&rep->directory);\n\n\tunsigned r = set->nreplicas++;\n\n\tset->replica[r] = rep;\n\n\treturn 0;\n}\n\n/*\n * util_replica_check_map_sync -- (internal) check MAP_SYNC restrictions\n */\nstatic int\nutil_replica_check_map_sync(struct pool_set *set, unsigned repidx,\n\tint check_hdr)\n{\n\tLOG(3, \"set %p repidx %u\", set, repidx);\n\n\tstruct pool_replica *rep = set->replica[repidx];\n\n\tint map_sync = rep->part[0].map_sync;\n\n\tfor (unsigned p = 1; p < rep->nparts; p++) {\n\t\tif (map_sync != rep->part[p].map_sync) {\n\t\t\tERR(\"replica #%u part %u %smapped with MAP_SYNC\",\n\t\t\t\trepidx, p, rep->part[p].map_sync ? \"\" : \"not\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (check_hdr) {\n\t\tfor (unsigned p = 0; p < rep->nhdrs; p++) {\n\t\t\tif (map_sync != rep->part[p].hdr_map_sync) {\n\t\t\t\tERR(\"replica #%u part %u header %smapped \"\n\t\t\t\t\t\"with MAP_SYNC\", repidx, p,\n\t\t\t\t\trep->part[p].hdr_map_sync ?\n\t\t\t\t\t\"\" : \"not\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * util_poolset_check_devdax -- (internal) check Device DAX restrictions\n */\nstatic int\nutil_poolset_check_devdax(struct pool_set *set)\n{\n\tLOG(3, \"set %p\", set);\n\n\tif (set->directory_based)\n\t\treturn 0;\n\n\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\tstruct pool_replica *rep = set->replica[r];\n\t\tint is_dev_dax = rep->part[0].is_dev_dax;\n\n\t\tfor (unsigned p = 0; p < rep->nparts; p++) {\n\t\t\tif (rep->part[p].is_dev_dax != is_dev_dax) {\n\t\t\t\tERR(\n\t\t\t\t\t\"either all the parts must be Device DAX or none\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (is_dev_dax && rep->nparts > 1 &&\n\t\t\t\t\t(set->options & (OPTION_SINGLEHDR |\n\t\t\t\t\tOPTION_NOHDRS)) == 0 &&\n\t\t\t    util_file_device_dax_alignment(rep->part[p].path)\n\t\t\t\t\t!= Pagesize) {\n\t\t\t\tERR(\n\t\t\t\t\t\"Multiple DAX devices with alignment other than 4KB. Use the SINGLEHDR poolset option.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * util_poolset_check_options -- (internal) check if poolset options are\n *                               admissible\n */\nstatic int\nutil_poolset_check_options(struct pool_set *set)\n{\n\tLOG(3, \"set %p\", set);\n\tif ((set->options & OPTION_SINGLEHDR) &&\n\t\t\t(set->options & OPTION_NOHDRS)) {\n\t\tERR(\n\t\t\"both SINGLEHDR and NOHDR poolset options used at the same time\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * util_poolset_set_size -- (internal) calculate pool size\n */\nstatic void\nutil_poolset_set_size(struct pool_set *set)\n{\n\tLOG(3, \"set %p\", set);\n\n\tset->poolsize = SIZE_MAX;\n\tset->resvsize = SIZE_MAX;\n\n\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\tstruct pool_replica *rep = set->replica[r];\n\n\t\tif (set->options & OPTION_SINGLEHDR)\n\t\t\trep->nhdrs = 1;\n\t\telse if (set->options & OPTION_NOHDRS)\n\t\t\trep->nhdrs = 0;\n\t\telse\n\t\t\trep->nhdrs = rep->nparts;\n\n\t\trep->repsize = 0;\n\t\tfor (unsigned p = 0; p < rep->nparts; p++) {\n\t\t\trep->repsize +=\n\t\t\t\t(rep->part[p].filesize & ~(Mmap_align - 1));\n\t\t}\n\t\tif (rep->nhdrs > 0)\n\t\t\trep->repsize -= (rep->nhdrs - 1) * Mmap_align;\n\n\t\tif (rep->resvsize == 0)\n\t\t\trep->resvsize = rep->repsize;\n\n\t\t/*\n\t\t * Calculate pool size - choose the smallest replica size.\n\t\t * Ignore remote replicas.\n\t\t */\n\t\tif (rep->remote == NULL && rep->repsize < set->poolsize)\n\t\t\tset->poolsize = rep->repsize;\n\t\tif (rep->remote == NULL && rep->resvsize < set->resvsize)\n\t\t\tset->resvsize = rep->resvsize;\n\t}\n\n\tLOG(3, \"pool size set to %zu\", set->poolsize);\n}\n\n/*\n * util_parse_add_remote_replica -- (internal) add a new remote replica\n *                                  to the pool set info\n */\nstatic int\nutil_parse_add_remote_replica(struct pool_set **setp, char *node_addr,\n\t\t\t\tchar *pool_desc)\n{\n\tLOG(3, \"setp %p node_addr %s pool_desc %s\", setp, node_addr, pool_desc);\n\n\tASSERTne(setp, NULL);\n\tASSERTne(node_addr, NULL);\n\tASSERTne(pool_desc, NULL);\n\n\tint ret = util_parse_add_replica(setp);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/*\n\t * A remote replica has one fake part of size equal twice pool header\n\t * size for storing pool header and pool descriptor.\n\t */\n\tret = util_parse_add_part(*setp, NULL, 2 * POOL_HDR_SIZE);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tstruct pool_set *set = *setp;\n\tstruct pool_replica *rep = set->replica[set->nreplicas - 1];\n\tASSERTne(rep, NULL);\n\n\trep->remote = Zalloc(sizeof(struct remote_replica));\n\tif (rep->remote == NULL) {\n\t\tERR(\"!Malloc\");\n\t\treturn -1;\n\t}\n\trep->remote->node_addr = node_addr;\n\trep->remote->pool_desc = pool_desc;\n\tset->remote = 1;\n\n\treturn 0;\n}\n\n/*\n * util_part_idx_by_file_name -- (internal) retrieves the part index from a\n *\tname of the file that is an element of a directory poolset\n */\nstatic long\nutil_part_idx_by_file_name(const char *filename)\n{\n\tLOG(3, \"filename \\\"%s\\\"\", filename);\n\n\tint olderrno = errno;\n\terrno = 0;\n\tlong part_idx = strtol(filename, NULL, 10);\n\tif (errno != 0)\n\t\treturn -1;\n\n\terrno = olderrno;\n\n\treturn part_idx;\n}\n\n/*\n * util_poolset_directory_load -- (internal) loads and initializes all\n *\texisting parts in a single directory\n */\nstatic int\nutil_poolset_directory_load(struct pool_replica **repp, const char *directory)\n{\n\tLOG(3, \"rep %p dir \\\"%s\\\"\", *repp, directory);\n\n\tstruct fs *f = fs_new(directory);\n\tif (f == NULL) {\n\t\tERR(\"!fs_new: \\\"%s\\\"\", directory);\n\t\treturn -1;\n\t}\n\n\tint nparts = 0;\n\tchar *path = NULL;\n\n\tstruct fs_entry *entry;\n\twhile ((entry = fs_read(f)) != NULL) {\n\t\tif (entry->level != 1)\n\t\t\tcontinue;\n\t\tif (entry->type != FS_ENTRY_FILE)\n\t\t\tcontinue;\n\t\tif (entry->namelen < PMEM_EXT_LEN)\n\t\t\tcontinue;\n\t\tconst char *ext = entry->path + entry->pathlen -\n\t\t\tPMEM_EXT_LEN + 1;\n\t\tif (strcmp(PMEM_EXT, ext) != 0)\n\t\t\tcontinue;\n\n\t\tlong part_idx = util_part_idx_by_file_name(entry->name);\n\t\tif (part_idx < 0)\n\t\t\tcontinue;\n\n\t\tssize_t size = util_file_get_size(entry->path);\n\t\tif (size < 0) {\n\t\t\tLOG(2,\n\t\t\t\"cannot read size of file (%s) in a poolset directory\",\n\t\t\tentry->path);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif ((path = Strdup(entry->path)) == NULL) {\n\t\t\tERR(\"!Strdup\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (util_replica_add_part_by_idx(repp, path,\n\t\t\t\t(size_t)size, (unsigned)part_idx) != 0) {\n\t\t\tERR(\"unable to load part %s\", entry->path);\n\t\t\tgoto err;\n\t\t}\n\t\tnparts++;\n\t}\n\n\tfs_delete(f);\n\treturn nparts;\n\nerr:\n\tfs_delete(f);\n\treturn -1;\n}\n\n/*\n * util_poolset_directories_load -- (internal) loads and initializes all\n *\texisting parts in the poolset directories\n */\nstatic int\nutil_poolset_directories_load(struct pool_set *set)\n{\n\tLOG(3, \"set %p\", set);\n\n\tif (!set->directory_based)\n\t\treturn 0;\n\n\tunsigned next_part_id = 0;\n\tunsigned max_parts_rep = 0;\n\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\tnext_part_id = 0;\n\n\t\tstruct pool_set_directory *d;\n\t\tint nparts = 0;\n\t\tint prev_nparts = 0;\n\t\tVEC_FOREACH_BY_PTR(d, &set->replica[r]->directory) {\n\t\t\tprev_nparts = nparts;\n\t\t\tnparts = util_poolset_directory_load(&set->replica[r],\n\t\t\t\td->path);\n\t\t\tif (nparts < 0) {\n\t\t\t\tERR(\"failed to load parts from directory %s\",\n\t\t\t\t\td->path);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_part_id += (unsigned)nparts;\n\n\t\t\t/* always try to evenly spread files across dirs */\n\t\t\tif (r == 0 && prev_nparts > nparts)\n\t\t\t\tset->next_directory_id++;\n\t\t}\n\n\t\tif (next_part_id > set->replica[max_parts_rep]->nparts)\n\t\t\tmax_parts_rep = r;\n\n\t\tif (r == 0)\n\t\t\tset->next_id = next_part_id;\n\t}\n\n\t/*\n\t * In order to maintain the same semantics of poolset parsing for\n\t * regular poolsets and directory poolsets, we need to speculatively\n\t * recreate the information regarding any missing parts in replicas.\n\t */\n\tstruct pool_replica *rep;\n\tstruct pool_replica *mrep = set->replica[max_parts_rep];\n\n\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\tif (set->replica[r]->nparts == mrep->nparts)\n\t\t\tcontinue;\n\n\t\tif (VEC_SIZE(&set->replica[r]->directory) == 0) {\n\t\t\terrno = ENOENT;\n\t\t\tERR(\"!no directories in replica\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (util_replica_reserve(&set->replica[r], mrep->nparts) != 0)\n\t\t\treturn -1;\n\n\t\trep = set->replica[r];\n\n\t\tstruct pool_set_directory *d = VEC_GET(&rep->directory, 0);\n\n\t\tfor (unsigned pidx = 0; pidx < rep->nallocated; ++pidx) {\n\t\t\tstruct pool_set_part *p = &rep->part[pidx];\n\t\t\t*p = mrep->part[pidx];\n\n\t\t\tsize_t path_len = strlen(d->path) + PMEM_FILE_MAX_LEN;\n\t\t\tif ((p->path = Malloc(path_len)) == NULL) {\n\t\t\t\tERR(\"!Malloc\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tsnprintf((char *)p->path, path_len,\n\t\t\t\t\t\"%s\" OS_DIR_SEP_STR \"%0*u%s\",\n\t\t\t\t\td->path, PMEM_FILE_PADDING,\n\t\t\t\t\tpidx, PMEM_EXT);\n\t\t}\n\t\trep->nparts = mrep->nparts;\n\t}\n\n\treturn 0;\n}\n\n/*\n * util_poolset_parse -- parse pool set config file\n *\n * Returns 0 if the file is a valid poolset config file,\n * and -1 in case of any error.\n *\n * XXX: use memory mapped file\n */\nint\nutil_poolset_parse(struct pool_set **setp, const char *path, int fd)\n{\n\tLOG(3, \"setp %p path %s fd %d\", setp, path, fd);\n\n\tstruct pool_set *set = NULL;\n\tenum parser_codes result;\n\tchar *line;\n\tchar *ppath;\n\tchar *pool_desc;\n\tchar *node_addr;\n\tchar *cp;\n\tsize_t psize;\n\tFILE *fs;\n\tint oerrno;\n\n\tif (os_lseek(fd, 0, SEEK_SET) != 0) {\n\t\tERR(\"!lseek %d\", fd);\n\t\treturn -1;\n\t}\n\n\tfd = dup(fd);\n\tif (fd < 0) {\n\t\tERR(\"!dup\");\n\t\treturn -1;\n\t}\n\n\t/* associate a stream with the file descriptor */\n\tif ((fs = os_fdopen(fd, \"r\")) == NULL) {\n\t\tERR(\"!fdopen %d\", fd);\n\t\tos_close(fd);\n\t\treturn -1;\n\t}\n\n\tunsigned nlines = 0;\n\tunsigned nparts = 0; /* number of parts in current replica */\n\n\t/* read the first line */\n\tline = util_readline(fs);\n\tif (line == NULL) {\n\t\tERR(\"!Reading poolset file\");\n\t\tgoto err;\n\t}\n\tnlines++;\n\n\tset = Zalloc(sizeof(struct pool_set));\n\tif (set == NULL) {\n\t\tERR(\"!Malloc for pool set\");\n\t\tgoto err;\n\t}\n\n\tset->path = Strdup(path);\n\tif (set->path == NULL)  {\n\t\tERR(\"!Strdup\");\n\t\tgoto err;\n\t}\n\n\t/* check also if the last character is '\\n' */\n\tif (strncmp(line, POOLSET_HDR_SIG, POOLSET_HDR_SIG_LEN) == 0 &&\n\t    line[POOLSET_HDR_SIG_LEN] == '\\n') {\n\t\t/* 'PMEMPOOLSET' signature detected */\n\t\tLOG(10, \"PMEMPOOLSET\");\n\n\t\tint ret = util_parse_add_replica(&set);\n\t\tif (ret != 0)\n\t\t\tgoto err;\n\n\t\tnparts = 0;\n\t\tresult = PARSER_CONTINUE;\n\t} else {\n\t\tresult = PARSER_PMEMPOOLSET;\n\t}\n\n\twhile (result == PARSER_CONTINUE) {\n\t\tFree(line);\n\t\t/* read next line */\n\t\tline = util_readline(fs);\n\t\tnlines++;\n\n\t\tif (line) {\n\t\t\t/* chop off newline and comments */\n\t\t\tif ((cp = strchr(line, '\\n')) != NULL)\n\t\t\t\t*cp = '\\0';\n\t\t\tif (cp != line && (cp = strchr(line, '#')) != NULL)\n\t\t\t\t*cp = '\\0';\n\n\t\t\t/* skip comments and blank lines */\n\t\t\tif (cp == line)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!line) {\n\t\t\tif (nparts >= 1) {\n\t\t\t\tresult = PARSER_FORMAT_OK;\n\t\t\t} else {\n\t\t\t\tif (set->nreplicas == 1)\n\t\t\t\t\tresult = PARSER_SET_NO_PARTS;\n\t\t\t\telse\n\t\t\t\t\tresult = PARSER_REP_NO_PARTS;\n\t\t\t}\n\t\t} else if (strncmp(line, POOLSET_OPTION_SIG,\n\t\t\t\t\tPOOLSET_OPTION_SIG_LEN) == 0) {\n\t\t\tresult = parser_read_options(\n\t\t\t\t\tline + POOLSET_OPTION_SIG_LEN,\n\t\t\t\t\t&set->options);\n\t\t\tif (result == PARSER_CONTINUE) {\n\t\t\t\tLOG(10, \"OPTIONS: %x\", set->options);\n\t\t\t}\n\t\t} else if (strncmp(line, POOLSET_REPLICA_SIG,\n\t\t\t\t\tPOOLSET_REPLICA_SIG_LEN) == 0) {\n\t\t\tif (line[POOLSET_REPLICA_SIG_LEN] != '\\0') {\n\t\t\t\t/* something more than 'REPLICA' */\n\t\t\t\tchar c = line[POOLSET_REPLICA_SIG_LEN];\n\t\t\t\tif (!isblank((unsigned char)c)) {\n\t\t\t\t\tresult = PARSER_REPLICA;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* check if it is a remote replica */\n\t\t\t\tresult = parser_read_replica(\n\t\t\t\t\t\tline + POOLSET_REPLICA_SIG_LEN,\n\t\t\t\t\t\t&node_addr, &pool_desc);\n\t\t\t\tif (result == PARSER_CONTINUE) {\n\t\t\t\t\t/* remote REPLICA */\n\t\t\t\t\tLOG(10, \"REMOTE REPLICA \"\n\t\t\t\t\t\t\"node address '%s' \"\n\t\t\t\t\t\t\"pool set descriptor '%s'\",\n\t\t\t\t\t\tnode_addr, pool_desc);\n\t\t\t\t\tif (util_parse_add_remote_replica(&set,\n\t\t\t\t\t\t\tnode_addr, pool_desc))\n\t\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t} else if (nparts >= 1) {\n\t\t\t\t/* 'REPLICA' signature detected */\n\t\t\t\tLOG(10, \"REPLICA\");\n\n\t\t\t\tint ret = util_parse_add_replica(&set);\n\t\t\t\tif (ret != 0)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tnparts = 0;\n\t\t\t\tresult = PARSER_CONTINUE;\n\t\t\t} else {\n\t\t\t\tif (set->nreplicas == 1)\n\t\t\t\t\tresult = PARSER_SET_NO_PARTS;\n\t\t\t\telse\n\t\t\t\t\tresult = PARSER_REP_NO_PARTS;\n\t\t\t}\n\t\t} else {\n\t\t\t/* there could be no parts for remote replicas */\n\t\t\tif (set->replica[set->nreplicas - 1]->remote) {\n\t\t\t\tresult = PARSER_REMOTE_REP_UNEXPECTED_PARTS;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* read size and path */\n\t\t\tresult = parser_read_line(line, &psize, &ppath);\n\t\t\tif (result == PARSER_CONTINUE) {\n\t\t\t\t/* add a new pool's part to the list */\n\t\t\t\tint ret = util_parse_add_element(set,\n\t\t\t\t\tppath, psize);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tFree(ppath);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tnparts++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (result != PARSER_FORMAT_OK) {\n\t\tERR(\"%s [%s:%d]\", path, parser_errstr[result], nlines);\n\t\tswitch (result) {\n\t\tcase PARSER_CANNOT_READ_SIZE:\n\t\tcase PARSER_OUT_OF_MEMORY:\n\t\t\t/* do not overwrite errno */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrno = EINVAL;\n\t\t}\n\t\tgoto err;\n\t}\n\n\tif (util_poolset_check_devdax(set) != 0) {\n\t\terrno = EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (util_poolset_directories_load(set) != 0) {\n\t\tERR(\"cannot load part files from directories\");\n\t\tgoto err;\n\t}\n\n\tLOG(4, \"set file format correct (%s)\", path);\n\t(void) os_fclose(fs);\n\tFree(line);\n\tutil_poolset_check_options(set);\n\tutil_poolset_set_size(set);\n\t*setp = set;\n\treturn 0;\n\nerr:\n\toerrno = errno;\n\tFree(line);\n\t(void) os_fclose(fs);\n\tif (set)\n\t\tutil_poolset_free(set);\n\terrno = oerrno;\n\treturn -1;\n}\n\n/*\n * util_poolset_single -- (internal) create a one-part pool set\n *\n * On success returns a pointer to a newly allocated and initialized\n * pool set structure.  Otherwise, NULL is returned.\n */\nstatic struct pool_set *\nutil_poolset_single(const char *path, size_t filesize, int create,\n\tint ignore_sds)\n{\n\tLOG(3, \"path %s filesize %zu create %d\",\n\t\t\tpath, filesize, create);\n\n\tenum file_type type = util_file_get_type(path);\n\tif (type == OTHER_ERROR)\n\t\treturn NULL;\n\n\tstruct pool_set *set;\n\tset = Zalloc(sizeof(struct pool_set) +\n\t\t\tsizeof(struct pool_replica *));\n\tif (set == NULL) {\n\t\tERR(\"!Malloc for pool set\");\n\t\treturn NULL;\n\t}\n\n\tset->path = Strdup(path);\n\tif (set->path == NULL)  {\n\t\tERR(\"!Strdup\");\n\t\tFree(set);\n\t\treturn NULL;\n\t}\n\n\tstruct pool_replica *rep;\n\trep = Zalloc(sizeof(struct pool_replica) +\n\t\t\tsizeof(struct pool_set_part));\n\tif (rep == NULL) {\n\t\tERR(\"!Malloc for pool set replica\");\n\t\tFree(set->path);\n\t\tFree(set);\n\t\treturn NULL;\n\t}\n\n\tVEC_INIT(&rep->directory);\n\n\tset->replica[0] = rep;\n\n\trep->part[0].filesize = filesize;\n\trep->part[0].path = Strdup(path);\n\trep->part[0].fd = -1;\t/* will be filled out by util_poolset_file() */\n\trep->part[0].is_dev_dax = type == TYPE_DEVDAX;\n\trep->part[0].created = create;\n\trep->part[0].hdr = NULL;\n\trep->part[0].addr = NULL;\n\trep->part[0].has_bad_blocks = 0;\n\n\tif (rep->part[0].is_dev_dax)\n\t\trep->part[0].alignment = util_file_device_dax_alignment(path);\n\telse\n\t\trep->part[0].alignment = Mmap_align;\n\n\tASSERTne(rep->part[0].alignment, 0);\n\n\trep->nallocated = 1;\n\trep->nparts = 1;\n\trep->nhdrs = 1;\n\n\t/* it does not have a remote replica */\n\trep->remote = NULL;\n\tset->remote = 0;\n\n\t/* round down to the nearest mapping alignment boundary */\n\trep->repsize = rep->part[0].filesize & ~(rep->part[0].alignment - 1);\n\trep->resvsize = rep->repsize;\n\n\tset->poolsize = rep->repsize;\n\tset->resvsize = rep->resvsize;\n\n\tset->nreplicas = 1;\n\tset->ignore_sds = ignore_sds || (set->options & OPTION_NOHDRS);\n\n\treturn set;\n}\n\n/*\n * util_part_open -- open or create a single part file\n */\nint\nutil_part_open(struct pool_set_part *part, size_t minsize, int create_part)\n{\n\tLOG(3, \"part %p minsize %zu create %d\", part, minsize, create_part);\n\n\tint exists = util_file_exists(part->path);\n\tif (exists < 0)\n\t\treturn -1;\n\n\tint create_file = create_part;\n\n\tif (exists)\n\t\tcreate_file = 0;\n\n\tpart->created = 0;\n\tif (create_file) {\n\t\tpart->fd = util_file_create(part->path, part->filesize,\n\t\t\t\tminsize);\n\t\tif (part->fd == -1) {\n\t\t\tLOG(2, \"failed to create file: %s\", part->path);\n\t\t\treturn -1;\n\t\t}\n\t\tpart->created = 1;\n\t} else {\n\t\tsize_t size = 0;\n\t\tint flags = O_RDWR;\n\t\tpart->fd = util_file_open(part->path, &size, minsize, flags);\n\t\tif (part->fd == -1) {\n\t\t\tLOG(2, \"failed to open file: %s\", part->path);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Fallocate_at_create && create_part && !part->is_dev_dax) {\n\t\t\tint ret = os_posix_fallocate(part->fd, 0,\n\t\t\t\t\t(os_off_t)size);\n\t\t\tif (ret != 0) {\n\t\t\t\terrno = ret;\n\t\t\t\tERR(\"!posix_fallocate \\\"%s\\\", %zu\", part->path,\n\t\t\t\t\tsize);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/* check if filesize matches */\n\t\tif (part->filesize != size) {\n\t\t\tERR(\"file size does not match config: %s, %zu != %zu\",\n\t\t\t\tpart->path, size, part->filesize);\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * util_part_fdclose -- close part file\n */\nvoid\nutil_part_fdclose(struct pool_set_part *part)\n{\n\tLOG(3, \"part %p\", part);\n\n\tif (part->fd != -1) {\n\t\t(void) os_close(part->fd);\n\t\tpart->fd = -1;\n\t}\n}\n\n/*\n * util_set_rpmem_attr -- (internal) overwrite existing pool attributes\n *\n * does not set uuid, next_part_uuid, prev_part_uuid\n */\nstatic void\nutil_set_rpmem_attr(struct pool_hdr *hdrp, const struct rpmem_pool_attr *rattr)\n{\n\tLOG(5, \"hdrp %p rattr %p\", hdrp, rattr);\n\tmemcpy(hdrp->signature, rattr->signature, POOL_HDR_SIG_LEN);\n\thdrp->major = rattr->major;\n\thdrp->features.compat = rattr->compat_features;\n\thdrp->features.incompat = rattr->incompat_features;\n\thdrp->features.ro_compat = rattr->ro_compat_features;\n\tmemcpy(hdrp->poolset_uuid, rattr->poolset_uuid, POOL_HDR_UUID_LEN);\n\tmemcpy(hdrp->next_repl_uuid, rattr->next_uuid, POOL_HDR_UUID_LEN);\n\tmemcpy(hdrp->prev_repl_uuid, rattr->prev_uuid, POOL_HDR_UUID_LEN);\n\tmemcpy(&hdrp->arch_flags, rattr->user_flags, sizeof(struct arch_flags));\n}\n\n/*\n * util_get_rpmem_attr -- (internal) get attributes for remote replica header\n */\nstatic void\nutil_get_rpmem_attr(struct rpmem_pool_attr *rattr, const struct pool_hdr *hdrp)\n{\n\tLOG(5, \"rpmem_attr %p hdrp %p\", rattr, hdrp);\n\tASSERTne(rattr, NULL);\n\tmemcpy(rattr->signature, hdrp->signature, POOL_HDR_SIG_LEN);\n\trattr->major = hdrp->major;\n\trattr->compat_features = hdrp->features.compat;\n\trattr->incompat_features = hdrp->features.incompat;\n\trattr->ro_compat_features = hdrp->features.ro_compat;\n\tmemcpy(rattr->poolset_uuid, hdrp->poolset_uuid, POOL_HDR_UUID_LEN);\n\tmemcpy(rattr->uuid, hdrp->uuid, POOL_HDR_UUID_LEN);\n\tmemcpy(rattr->next_uuid, hdrp->next_repl_uuid, POOL_HDR_UUID_LEN);\n\tmemcpy(rattr->prev_uuid, hdrp->prev_repl_uuid, POOL_HDR_UUID_LEN);\n\tmemcpy(rattr->user_flags, &hdrp->arch_flags, sizeof(struct arch_flags));\n}\n\n/*\n * util_remote_store_attr -- (internal) store attributes read from remote\n *                           replica in the local volatile pool header\n */\nstatic void\nutil_remote_store_attr(struct pool_hdr *hdrp,\n\t\tconst struct rpmem_pool_attr *rattr)\n{\n\tLOG(4, \"hdrp %p rpmem_attr %p\", hdrp, rattr);\n\n\tutil_set_rpmem_attr(hdrp, rattr);\n\tmemcpy(hdrp->uuid, rattr->uuid, POOL_HDR_UUID_LEN);\n\tmemcpy(hdrp->next_part_uuid, rattr->uuid, POOL_HDR_UUID_LEN);\n\tmemcpy(hdrp->prev_part_uuid, rattr->uuid, POOL_HDR_UUID_LEN);\n}\n\n/*\n * util_update_remote_header --  update attributes of a remote replica;\n *                               the remote replica must be open\n */\nint\nutil_update_remote_header(struct pool_set *set, unsigned repn)\n{\n\tLOG(3, \"set %p, repn %u\", set, repn);\n\n\tASSERTne(REP(set, repn)->remote, NULL);\n\tASSERTne(REP(set, repn)->remote->rpp, NULL);\n\n\tstruct pool_replica *rep = REP(set, repn);\n\tstruct pool_hdr *hdr = HDR(rep, 0);\n\n\t/* get attributes from the local pool header */\n\tstruct rpmem_pool_attr attributes;\n\tutil_get_rpmem_attr(&attributes, hdr);\n\n\t/* push the attributes to the remote replica */\n\tRPMEMpool *rpp = rep->remote->rpp;\n\tint ret = Rpmem_set_attr(rpp, &attributes);\n\tif (ret) {\n\t\tERR(\"!Rpmem_set_attr\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * util_pool_close_remote -- close a remote replica\n */\nint\nutil_pool_close_remote(RPMEMpool *rpp)\n{\n\tLOG(3, \"rpp %p\", rpp);\n\n\treturn Rpmem_close(rpp);\n}\n\n/*\n * util_poolset_remote_open -- open or create a remote replica\n */\nint\nutil_poolset_remote_open(struct pool_replica *rep, unsigned repidx,\n\t\t\tsize_t minsize, int create, void *pool_addr,\n\t\t\tsize_t pool_size, unsigned *nlanes)\n{\n\tLOG(3, \"rep %p repidx %u minsize %zu create %d \"\n\t\t\"pool_addr %p pool_size %zu nlanes %p\",\n\t\trep, repidx, minsize, create,\n\t\tpool_addr, pool_size, nlanes);\n\n\tASSERTne(nlanes, NULL);\n\n\tif (!Rpmem_handle_remote) {\n\t\treturn -1;\n\t}\n\n\tunsigned remote_nlanes = *nlanes;\n\n\tif (create) {\n\t\tstruct rpmem_pool_attr rpmem_attr_create;\n\t\tutil_get_rpmem_attr(&rpmem_attr_create, rep->part[0].hdr);\n\n\t\trep->remote->rpp = Rpmem_create(rep->remote->node_addr,\n\t\t\t\t\t\trep->remote->pool_desc,\n\t\t\t\t\t\tpool_addr,\n\t\t\t\t\t\tpool_size,\n\t\t\t\t\t\t&remote_nlanes,\n\t\t\t\t\t\t&rpmem_attr_create);\n\t\tif (rep->remote->rpp == NULL) {\n\t\t\tERR(\"creating remote replica #%u failed\", repidx);\n\t\t\treturn -1;\n\t\t}\n\t\trep->part[0].created = 1;\n\t} else { /* open */\n\t\tstruct rpmem_pool_attr rpmem_attr_open;\n\n\t\trep->remote->rpp = Rpmem_open(rep->remote->node_addr,\n\t\t\t\t\t\trep->remote->pool_desc,\n\t\t\t\t\t\tpool_addr,\n\t\t\t\t\t\tpool_size,\n\t\t\t\t\t\t&remote_nlanes,\n\t\t\t\t\t\t&rpmem_attr_open);\n\t\tif (rep->remote->rpp == NULL) {\n\t\t\tERR(\"opening remote replica #%u failed\", repidx);\n\t\t\treturn -1;\n\t\t}\n\n\t\tutil_remote_store_attr(rep->part[0].hdr, &rpmem_attr_open);\n\t}\n\n\tif (remote_nlanes < *nlanes)\n\t\t*nlanes = remote_nlanes;\n\n\treturn 0;\n}\n\n/*\n * util_poolset_files_local -- (internal) open or create all the local\n *                              part files of a pool set and replica sets\n */\nstatic int\nutil_poolset_files_local(struct pool_set *set, size_t minpartsize, int create)\n{\n\tLOG(3, \"set %p minpartsize %zu create %d\", set, minpartsize, create);\n\n\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\tstruct pool_replica *rep = set->replica[r];\n\t\tif (!rep->remote) {\n\t\t\tfor (unsigned p = 0; p < rep->nparts; p++) {\n\t\t\t\tif (util_part_open(&rep->part[p], minpartsize,\n\t\t\t\t\t\tcreate))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * util_poolset_remote_replica_open -- open remote replica\n */\nint\nutil_poolset_remote_replica_open(struct pool_set *set, unsigned repidx,\n\tsize_t minsize, int create, unsigned *nlanes)\n{\n#ifndef _WIN32\n\t/*\n\t * This is a workaround for an issue with using device dax with\n\t * libibverbs. To handle fork() function calls correctly libfabric use\n\t * ibv_fork_init(3) which makes all registered memory being madvised\n\t * with MADV_DONTFORK flag. In libpmemobj the remote replication is\n\t * performed without pool header (first 4k). In such case the address\n\t * passed to madvise(2) is aligned to 4k, but device dax can require\n\t * different alignment (default is 2MB). This workaround madvises the\n\t * entire memory region before registering it by fi_mr_reg(3).\n\t *\n\t * The librpmem client requires fork() support to work correctly.\n\t */\n\tif (set->replica[0]->part[0].is_dev_dax) {\n\t\tint ret = os_madvise(set->replica[0]->part[0].addr,\n\t\t\t\tset->replica[0]->part[0].filesize,\n\t\t\t\tMADV_DONTFORK);\n\t\tif (ret) {\n\t\t\tERR(\"!madvise\");\n\t\t\treturn ret;\n\t\t}\n\t}\n#endif\n\n\tvoid *pool_addr = (void *)((uintptr_t)set->replica[0]->part[0].addr);\n\n\treturn util_poolset_remote_open(set->replica[repidx], repidx, minsize,\n\t\t\tcreate, pool_addr, set->poolsize, nlanes);\n}\n\n/*\n * util_poolset_files_remote -- (internal) open or create all the remote\n *                              part files of a pool set and replica sets\n */\nstatic int\nutil_poolset_files_remote(struct pool_set *set, size_t minsize,\n\t\t\t\tunsigned *nlanes, int create)\n{\n\tLOG(3, \"set %p minsize %zu nlanes %p create %d\",\n\t\tset, minsize, nlanes, create);\n\n\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\tstruct pool_replica *rep = set->replica[r];\n\t\tif (rep->remote) {\n\t\t\tif (util_poolset_remote_replica_open(set, r,\n\t\t\t\tminsize, create, nlanes))\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * util_poolset_read -- read memory pool set file\n *\n * On success returns 0 and a pointer to a newly allocated structure\n * containing the info of all the parts of the pool set and replicas.\n */\nint\nutil_poolset_read(struct pool_set **setp, const char *path)\n{\n\tLOG(3, \"setp %p path %s\", setp, path);\n\n\tint oerrno;\n\tint ret = 0;\n\tint fd;\n\n\tif ((fd = os_open(path, O_RDONLY)) < 0) {\n\t\tERR(\"!open: path \\\"%s\\\"\", path);\n\t\treturn -1;\n\t}\n\n\tret = util_poolset_parse(setp, path, fd);\n\n\toerrno = errno;\n\t(void) os_close(fd);\n\terrno = oerrno;\n\treturn ret;\n}\n\n/*\n * util_poolset_create_set -- create a new pool set structure\n *\n * On success returns 0 and a pointer to a newly allocated structure\n * containing the info of all the parts of the pool set and replicas.\n */\nint\nutil_poolset_create_set(struct pool_set **setp, const char *path,\n\tsize_t poolsize, size_t minsize, int ignore_sds)\n{\n\tLOG(3, \"setp %p path %s poolsize %zu minsize %zu\",\n\t\tsetp, path, poolsize, minsize);\n\n\tint oerrno;\n\tint ret = 0;\n\tint fd;\n\tsize_t size = 0;\n\n\tenum file_type type = util_file_get_type(path);\n\tif (type == OTHER_ERROR)\n\t\treturn -1;\n\n\tif (poolsize != 0) {\n\t\tif (type == TYPE_DEVDAX) {\n\t\t\tERR(\"size must be zero for device dax\");\n\t\t\treturn -1;\n\t\t}\n\t\t*setp = util_poolset_single(path, poolsize, 1, ignore_sds);\n\t\tif (*setp == NULL)\n\t\t\treturn -1;\n\n\t\treturn 0;\n\t}\n\n\t/* do not check minsize */\n\tif ((fd = util_file_open(path, &size, 0, O_RDONLY)) == -1)\n\t\treturn -1;\n\n\tchar signature[POOLSET_HDR_SIG_LEN];\n\tif (type == TYPE_NORMAL) {\n\t\t/*\n\t\t * read returns ssize_t, but we know it will return value\n\t\t * between -1 and POOLSET_HDR_SIG_LEN (11), so we can safely\n\t\t * cast it to int\n\t\t */\n\t\tret = (int)read(fd, signature, POOLSET_HDR_SIG_LEN);\n\t\tif (ret < 0) {\n\t\t\tERR(\"!read %d\", fd);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (type == TYPE_DEVDAX || ret < POOLSET_HDR_SIG_LEN ||\n\t    strncmp(signature, POOLSET_HDR_SIG, POOLSET_HDR_SIG_LEN)) {\n\t\tLOG(4, \"not a pool set header\");\n\t\t(void) os_close(fd);\n\n\t\tif (size < minsize) {\n\t\t\tERR(\"file is not a poolset file and its size (%zu)\"\n\t\t\t\t\" is smaller than %zu\", size, minsize);\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\t*setp = util_poolset_single(path, size, 0, ignore_sds);\n\t\tif (*setp == NULL)\n\t\t\treturn -1;\n\n\t\treturn 0;\n\t}\n\n\tret = util_poolset_parse(setp, path, fd);\n\tif (ret)\n\t\tgoto err;\n\n\t(*setp)->ignore_sds = ignore_sds || ((*setp)->options & OPTION_NOHDRS);\n#ifdef _WIN32\n\t/* remote replication is not supported on Windows */\n\tif ((*setp)->remote) {\n\t\tutil_poolset_free(*setp);\n\t\tERR(\"remote replication is not supported on Windows\");\n\t\terrno = ENOTSUP;\n\t\tret = -1;\n\t\tgoto err;\n\t}\n#endif /* _WIN32 */\n\nerr:\n\toerrno = errno;\n\t(void) os_close(fd);\n\terrno = oerrno;\n\treturn ret;\n}\n\n/*\n * util_poolset_check_header_options -- (internal) check if poolset options\n *                                      match given flags\n */\nstatic int\nutil_poolset_check_header_options(struct pool_set *set, uint32_t incompat)\n{\n\tLOG(3, \"set %p, incompat %#x\", set, incompat);\n\n\tif (((set->options & OPTION_SINGLEHDR) == 0) !=\n\t\t\t((incompat & POOL_FEAT_SINGLEHDR) == 0)) {\n\t\tERR(\n\t\t\t\"poolset file options (%u) do not match incompat feature flags (%#x)\",\n\t\t\tset->options, incompat);\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * util_header_create -- create header of a single pool set file\n */\nint\nutil_header_create(struct pool_set *set, unsigned repidx, unsigned partidx,\n\tconst struct pool_attr *attr, int overwrite)\n{\n\tLOG(3, \"set %p repidx %u partidx %u attr %p overwrite %d\", set, repidx,\n\t\tpartidx, attr, overwrite);\n\n\tASSERTne(attr, NULL);\n\n\tstruct pool_replica *rep = set->replica[repidx];\n\n\t/* opaque info lives at the beginning of mapped memory pool */\n\tstruct pool_hdr *hdrp = rep->part[partidx].hdr;\n\n\t/* check if the pool header is all zeros */\n\tif (!util_is_zeroed(hdrp, sizeof(*hdrp)) && !overwrite) {\n\t\tERR(\"Non-empty file detected\");\n\t\terrno = EEXIST;\n\t\treturn -1;\n\t}\n\n\t/* create pool's header */\n\tutil_pool_attr2hdr(hdrp, attr);\n\n\tif (set->options & OPTION_SINGLEHDR)\n\t\thdrp->features.incompat |= POOL_FEAT_SINGLEHDR;\n\n\tmemcpy(hdrp->poolset_uuid, set->uuid, POOL_HDR_UUID_LEN);\n\tmemcpy(hdrp->uuid, PART(rep, partidx)->uuid, POOL_HDR_UUID_LEN);\n\n\t/* link parts */\n\tif (set->options & OPTION_SINGLEHDR) {\n\t\t/* next/prev part point to part #0 */\n\t\tASSERTeq(partidx, 0);\n\t\tmemcpy(hdrp->prev_part_uuid, PART(rep, 0)->uuid,\n\t\t\t\t\t\t\tPOOL_HDR_UUID_LEN);\n\t\tmemcpy(hdrp->next_part_uuid, PART(rep, 0)->uuid,\n\t\t\t\t\t\t\tPOOL_HDR_UUID_LEN);\n\t} else {\n\t\tmemcpy(hdrp->prev_part_uuid, PARTP(rep, partidx)->uuid,\n\t\t\t\t\t\t\tPOOL_HDR_UUID_LEN);\n\t\tmemcpy(hdrp->next_part_uuid, PARTN(rep, partidx)->uuid,\n\t\t\t\t\t\t\tPOOL_HDR_UUID_LEN);\n\t}\n\n\t/* link replicas */\n\tif (!util_is_zeroed(attr->prev_repl_uuid, POOL_HDR_UUID_LEN)) {\n\t\tmemcpy(hdrp->prev_repl_uuid, attr->prev_repl_uuid,\n\t\t\t\tPOOL_HDR_UUID_LEN);\n\t} else {\n\t\tmemcpy(hdrp->prev_repl_uuid, PART(REPP(set, repidx), 0)->uuid,\n\t\t\tPOOL_HDR_UUID_LEN);\n\t}\n\tif (!util_is_zeroed(attr->next_repl_uuid, POOL_HDR_UUID_LEN)) {\n\t\tmemcpy(hdrp->next_repl_uuid, attr->next_repl_uuid,\n\t\t\t\tPOOL_HDR_UUID_LEN);\n\t} else {\n\t\tmemcpy(hdrp->next_repl_uuid, PART(REPN(set, repidx), 0)->uuid,\n\t\t\tPOOL_HDR_UUID_LEN);\n\t}\n\n\tif (!rep->remote) {\n\t\tos_stat_t stbuf;\n\n\t\tif (os_fstat(rep->part[partidx].fd, &stbuf) != 0) {\n\t\t\tERR(\"!fstat\");\n\t\t\treturn -1;\n\t\t}\n\t\tASSERT(stbuf.st_ctime);\n\t\thdrp->crtime = (uint64_t)stbuf.st_ctime;\n\t}\n\n\tint arch_is_zeroed = util_is_zeroed(attr->arch_flags,\n\t\t\tPOOL_HDR_ARCH_LEN);\n\tif (arch_is_zeroed)\n\t\tutil_get_arch_flags(&hdrp->arch_flags);\n\n\tutil_convert2le_hdr(hdrp);\n\n\tif (!arch_is_zeroed) {\n\t\tmemcpy(&hdrp->arch_flags, attr->arch_flags, POOL_HDR_ARCH_LEN);\n\t}\n\n\tif (!set->ignore_sds && partidx == 0 && !rep->remote) {\n\t\tshutdown_state_init(&hdrp->sds, rep);\n\t\tfor (unsigned p = 0; p < rep->nparts; p++) {\n\t\t\tif (shutdown_state_add_part(&hdrp->sds,\n\t\t\t\t\tPART(rep, p)->fd, rep))\n\t\t\t\treturn -1;\n\t\t}\n\t\tshutdown_state_set_dirty(&hdrp->sds, rep);\n\t}\n\n\tutil_checksum(hdrp, sizeof(*hdrp), &hdrp->checksum,\n\t\t1, POOL_HDR_CSUM_END_OFF(hdrp));\n\n\t/* store pool's header */\n\tutil_persist_auto(rep->is_pmem, hdrp, sizeof(*hdrp));\n\n\treturn 0;\n}\n\n/*\n * util_header_check -- (internal) validate header of a single pool set file\n */\nstatic int\nutil_header_check(struct pool_set *set, unsigned repidx, unsigned partidx,\n\tconst struct pool_attr *attr)\n{\n\tLOG(3, \"set %p repidx %u partidx %u attr %p\", set, repidx, partidx,\n\t\t\tattr);\n\n\tASSERTne(attr, NULL);\n\n\tstruct pool_replica *rep = set->replica[repidx];\n\n\t/* opaque info lives at the beginning of mapped memory pool */\n\tstruct pool_hdr *hdrp = rep->part[partidx].hdr;\n\tstruct pool_hdr hdr;\n\n\tmemcpy(&hdr, hdrp, sizeof(hdr));\n\n\t/* local copy of a remote header does not need to be converted */\n\tif (rep->remote == NULL)\n\t\tutil_convert2h_hdr_nocheck(&hdr);\n\n\t/* to be valid, a header must have a major version of at least 1 */\n\tif (hdr.major == 0) {\n\t\tERR(\"invalid major version (0)\");\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* check signature */\n\tif (memcmp(hdr.signature, attr->signature, POOL_HDR_SIG_LEN)) {\n\t\tERR(\"wrong pool type: \\\"%.8s\\\"\", hdr.signature);\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* check format version number */\n\tif (hdr.major != attr->major) {\n\t\tERR(\"pool version %d (library expects %d)\", hdr.major,\n\t\t\t\tattr->major);\n\t\tif (hdr.major < attr->major)\n\t\t\tERR(\n\t\t\t\t\"Please run the pmdk-convert utility to upgrade the pool.\");\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\trep->part[partidx].rdonly = 0;\n\n\tint retval = util_feature_check(&hdr, attr->features);\n\tif (retval < 0)\n\t\treturn -1;\n\n\tif (retval == 0)\n\t\trep->part[partidx].rdonly = 1;\n\n\tif (rep->remote == NULL) {\n\t\t/*\n\t\t * and to be valid, the fields must checksum correctly\n\t\t *\n\t\t * NOTE: checksum validation is performed after format version\n\t\t * and feature check, because if POOL_FEAT_CKSUM_2K flag is set,\n\t\t * we want to report it as incompatible feature, rather than\n\t\t * invalid checksum.\n\t\t */\n\t\tif (!util_checksum(&hdr, sizeof(hdr), &hdr.checksum,\n\t\t\t\t0, POOL_HDR_CSUM_END_OFF(&hdr))) {\n\t\t\tERR(\"invalid checksum of pool header\");\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tLOG(3, \"valid header, signature \\\"%.8s\\\"\", hdr.signature);\n\t}\n\n\tif (util_check_arch_flags(&hdr.arch_flags)) {\n\t\tERR(\"wrong architecture flags\");\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* check pool set UUID */\n\tif (memcmp(HDR(REP(set, 0), 0)->poolset_uuid, hdr.poolset_uuid,\n\t\t\t\t\t\tPOOL_HDR_UUID_LEN)) {\n\t\tERR(\"wrong pool set UUID\");\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* check pool set linkage */\n\tif (memcmp(HDRP(rep, partidx)->uuid, hdr.prev_part_uuid,\n\t\t\t\t\t\tPOOL_HDR_UUID_LEN) ||\n\t    memcmp(HDRN(rep, partidx)->uuid, hdr.next_part_uuid,\n\t\t\t\t\t\tPOOL_HDR_UUID_LEN)) {\n\t\tERR(\"wrong part UUID\");\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* check format version */\n\tif (HDR(rep, 0)->major != hdrp->major) {\n\t\tERR(\"incompatible pool format\");\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* check compatibility features */\n\tif (HDR(rep, 0)->features.compat != hdrp->features.compat ||\n\t    HDR(rep, 0)->features.incompat != hdrp->features.incompat ||\n\t    HDR(rep, 0)->features.ro_compat != hdrp->features.ro_compat) {\n\t\tERR(\"incompatible feature flags\");\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* check poolset options */\n\tif (util_poolset_check_header_options(set,\n\t\t\tHDR(rep, 0)->features.incompat))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/*\n * util_header_check_remote -- (internal) validate header of a remote\n *                             pool set file\n */\nstatic int\nutil_header_check_remote(struct pool_set *set, unsigned partidx)\n{\n\tLOG(3, \"set %p partidx %u \", set, partidx);\n\n\t/* there is only one replica in remote poolset */\n\tstruct pool_replica *rep = set->replica[0];\n\t/* opaque info lives at the beginning of mapped memory pool */\n\tstruct pool_hdr *hdrp = rep->part[partidx].hdr;\n\tstruct pool_hdr hdr;\n\n\tif (util_is_zeroed(hdrp, sizeof(*hdrp))) {\n\t\tERR(\"pool header zeroed\");\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tmemcpy(&hdr, hdrp, sizeof(hdr));\n\n\tutil_convert2h_hdr_nocheck(&hdr);\n\n\t/* valid header found */\n\tif (memcmp(HDR(rep, 0)->signature, hdrp->signature, POOL_HDR_SIG_LEN)) {\n\t\tERR(\"pool signature mismatch in part %d\", partidx);\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* check format version */\n\tif (HDR(rep, 0)->major != hdrp->major) {\n\t\tERR(\"pool version mismatch in part %d\", partidx);\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* check compatibility features */\n\tif (HDR(rep, 0)->features.compat != hdrp->features.compat) {\n\t\tERR(\"'may have' compatibility flags mismatch in part %d\",\n\t\t\t\t\t\t\t\tpartidx);\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif (HDR(rep, 0)->features.incompat != hdrp->features.incompat) {\n\t\tERR(\"'must support' compatibility flags mismatch in part %d\",\n\t\t\t\t\t\t\t\tpartidx);\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif (HDR(rep, 0)->features.ro_compat != hdrp->features.ro_compat) {\n\t\tERR(\"'force read-only' compatibility flags mismatch in part %d\",\n\t\t\t\t\t\t\t\tpartidx);\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/*\n\t * and to be valid, the fields must checksum correctly\n\t *\n\t * NOTE: checksum validation is performed after format version and\n\t * feature check, because if POOL_FEAT_CKSUM_2K flag is set,\n\t * we want to report it as incompatible feature, rather than invalid\n\t * checksum.\n\t */\n\tif (!util_checksum(&hdr, sizeof(hdr), &hdr.checksum,\n\t\t\t0, POOL_HDR_CSUM_END_OFF(&hdr))) {\n\t\tERR(\"invalid checksum of pool header\");\n\t\treturn -1;\n\t}\n\n\tLOG(3, \"valid header, signature \\\"%.8s\\\"\", hdr.signature);\n\n\t/* check pool set UUID */\n\tif (memcmp(HDR(rep, 0)->poolset_uuid, hdrp->poolset_uuid,\n\t\t\t\t\t\t\tPOOL_HDR_UUID_LEN)) {\n\t\tERR(\"wrong pool set UUID in part %d\", partidx);\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* check previous replica UUID */\n\tif (memcmp(HDR(rep, 0)->prev_repl_uuid, hdrp->prev_repl_uuid,\n\t\t\t\t\t\t\tPOOL_HDR_UUID_LEN)) {\n\t\tERR(\"wrong previous replica UUID in part %d\", partidx);\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* check next replica UUID */\n\tif (memcmp(HDR(rep, 0)->next_repl_uuid, hdrp->next_repl_uuid,\n\t\t\t\t\t\tPOOL_HDR_UUID_LEN)) {\n\t\tERR(\"wrong next replica UUID in part %d\", partidx);\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (memcmp(&HDR(rep, 0)->arch_flags, &hdrp->arch_flags,\n\t\t\t\t\t\tsizeof(hdrp->arch_flags))) {\n\t\tERR(\"wrong architecture flags\");\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* check pool set linkage */\n\tif (memcmp(HDRP(rep, partidx)->uuid, hdrp->prev_part_uuid,\n\t\t\t\t\t\t\tPOOL_HDR_UUID_LEN) ||\n\t    memcmp(HDRN(rep, partidx)->uuid, hdrp->next_part_uuid,\n\t\t\t\t\t\t\tPOOL_HDR_UUID_LEN)) {\n\t\tERR(\"wrong part UUID in part %d\", partidx);\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* read shutdown state toggle from header */\n\tset->ignore_sds |= IGNORE_SDS(HDR(rep, 0));\n\n\tif (!set->ignore_sds && partidx == 0) {\n\t\tstruct shutdown_state sds;\n\t\tshutdown_state_init(&sds, NULL);\n\t\tfor (unsigned p = 0; p < rep->nparts; p++) {\n\t\t\tif (shutdown_state_add_part(&sds,\n\t\t\t\t\tPART(rep, p)->fd, NULL))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (shutdown_state_check(&sds, &hdrp->sds, rep)) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tshutdown_state_set_dirty(&hdrp->sds, rep);\n\t}\n\n\trep->part[partidx].rdonly = 0;\n\n\treturn 0;\n}\n\n/*\n * util_replica_set_is_pmem -- sets per-replica is_pmem flag\n *\n * The replica is PMEM if:\n * - all parts are on device dax, or\n * - all parts are mapped with MAP_SYNC.\n *\n * It's enough to check only first part because it's already verified\n * that either all or none parts are device dax or mapped with MAP_SYNC.\n */\nstatic inline void\nutil_replica_set_is_pmem(struct pool_replica *rep)\n{\n\trep->is_pmem = rep->part[0].is_dev_dax || rep->part[0].map_sync ||\n\t\tpmem_is_pmem(rep->part[0].addr, rep->resvsize);\n}\n\n/*\n * util_replica_map_local -- (internal) map memory pool for local replica\n */\nstatic int\nutil_replica_map_local(struct pool_set *set, unsigned repidx, int flags)\n{\n\tLOG(3, \"set %p repidx %u flags %d\", set, repidx, flags);\n\n\t/*\n\t * XXX: Like we reserve space for all parts in this replica when we map\n\t * the first part, we need to reserve the space for all replicas\n\t * upfront.  It is not necessary that the replicas are contiguous but\n\t * that way we would not fragment the memory much.  I think we should\n\t * leave this to MM, but let's have a note as per our collective minds.\n\t */\n\n#ifndef _WIN32\n\tint remaining_retries = 0;\n#else\n\tint remaining_retries = 10;\n#endif\n\tint retry_for_contiguous_addr;\n\tsize_t mapsize;\n\t/* header size for all headers but the first one */\n\tsize_t hdrsize = (set->options & (OPTION_SINGLEHDR | OPTION_NOHDRS)) ?\n\t\t\t0 : Mmap_align;\n\tvoid *addr;\n\tstruct pool_replica *rep = set->replica[repidx];\n\n\tASSERTeq(rep->remote, NULL);\n\tASSERTne(rep->part, NULL);\n\n\tdo {\n\t\tretry_for_contiguous_addr = 0;\n\t\tmapsize = rep->part[0].filesize & ~(Mmap_align - 1);\n\n\t\t/* determine a hint address for mmap() */\n\t\taddr = util_map_hint(rep->resvsize, 0);\n\t\tif (addr == MAP_FAILED) {\n\t\t\tLOG(1, \"cannot find a contiguous region of given size\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* map the first part and reserve space for remaining parts */\n\t\tif (util_map_part(&rep->part[0], addr, rep->resvsize, 0,\n\t\t\t\tflags, 0) != 0) {\n\t\t\tLOG(2, \"pool mapping failed - replica #%u part #0\",\n\t\t\t\trepidx);\n\t\t\treturn -1;\n\t\t}\n\n\t\tVALGRIND_REGISTER_PMEM_MAPPING(rep->part[0].addr,\n\t\t\t\trep->part[0].size);\n\t\tVALGRIND_REGISTER_PMEM_FILE(rep->part[0].fd,\n\t\t\t\trep->part[0].addr, rep->part[0].size, 0);\n\n\t\tset->zeroed &= rep->part[0].created;\n\n\t\taddr = (char *)rep->part[0].addr + mapsize;\n\n\t\t/*\n\t\t * map the remaining parts of the usable pool space\n\t\t * (aligned to memory mapping granularity)\n\t\t */\n\t\tfor (unsigned p = 1; p < rep->nparts; p++) {\n\t\t\t/* map data part */\n\t\t\tif (util_map_part(&rep->part[p], addr, 0, hdrsize,\n\t\t\t\t\tflags | MAP_FIXED, 0) != 0) {\n\t\t\t\t/*\n\t\t\t\t * if we can't map the part at the address we\n\t\t\t\t * asked for, unmap all the parts that are\n\t\t\t\t * mapped and remap at a different address.\n\t\t\t\t */\n\t\t\t\tif ((errno == EINVAL) &&\n\t\t\t\t    (remaining_retries > 0)) {\n\t\t\t\t\tLOG(2, \"usable space mapping failed - \"\n\t\t\t\t\t\t\"part #%d - retrying\", p);\n\t\t\t\t\tretry_for_contiguous_addr = 1;\n\t\t\t\t\tremaining_retries--;\n\n\t\t\t\t\tutil_unmap_parts(rep, 0, p - 1);\n\n\t\t\t\t\t/* release rest of the VA reserved */\n\t\t\t\t\tASSERTne(addr, NULL);\n\t\t\t\t\tASSERTne(addr, MAP_FAILED);\n\t\t\t\t\tmunmap(addr, rep->resvsize - mapsize);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tLOG(2, \"usable space mapping failed - part #%d\",\n\t\t\t\t\tp);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tVALGRIND_REGISTER_PMEM_FILE(rep->part[p].fd,\n\t\t\t\trep->part[p].addr, rep->part[p].size,\n\t\t\t\thdrsize);\n\n\t\t\tmapsize += rep->part[p].size;\n\t\t\tset->zeroed &= rep->part[p].created;\n\t\t\taddr = (char *)addr + rep->part[p].size;\n\t\t}\n\t} while (retry_for_contiguous_addr);\n\n\t/*\n\t * Initially part[0].size is the size of address space\n\t * reservation for all parts from given replica. After\n\t * mapping that space we need to overwrite part[0].size\n\t * with its actual size to be consistent - size for each\n\t * part should be the actual mapping size of this part\n\t * only - it simplifies future calculations.\n\t */\n\trep->part[0].size = rep->part[0].filesize & ~(Mmap_align - 1);\n\n\tif (util_replica_check_map_sync(set, repidx, 0))\n\t\tgoto err;\n\n\tutil_replica_set_is_pmem(rep);\n\n\tif (Prefault_at_create)\n\t\tutil_replica_force_page_allocation(rep);\n\n\tASSERTeq(mapsize, rep->repsize);\n\n\tLOG(3, \"replica #%u addr %p\", repidx, rep->part[0].addr);\n\n\treturn 0;\n\nerr:\n\tLOG(4, \"error clean up\");\n\tint oerrno = errno;\n\tif (mapsize < rep->repsize) {\n\t\tASSERTne(rep->part[0].addr, NULL);\n\t\tASSERTne(rep->part[0].addr, MAP_FAILED);\n\t\tmunmap(rep->part[0].addr, rep->resvsize - mapsize);\n\t}\n\tfor (unsigned p = 0; p < rep->nparts; p++) {\n\t\tutil_unmap_part(&rep->part[p]);\n\t}\n\terrno = oerrno;\n\treturn -1;\n}\n\n/*\n * util_replica_init_headers_local -- (internal) initialize pool headers\n */\nstatic int\nutil_replica_init_headers_local(struct pool_set *set, unsigned repidx,\n\tint flags, const struct pool_attr *attr)\n{\n\tLOG(3, \"set %p repidx %u flags %d attr %p\", set, repidx, flags, attr);\n\n\tstruct pool_replica *rep = set->replica[repidx];\n\n\t/* map all headers - don't care about the address */\n\tfor (unsigned p = 0; p < rep->nhdrs; p++) {\n\t\tif (util_map_hdr(&rep->part[p], flags, 0) != 0) {\n\t\t\tLOG(2, \"header mapping failed - part #%d\", p);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t/* create headers, set UUID's */\n\tfor (unsigned p = 0; p < rep->nhdrs; p++) {\n\t\tif (util_header_create(set, repidx, p, attr, 0) != 0) {\n\t\t\tLOG(2, \"header creation failed - part #%d\", p);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t/* unmap all headers */\n\tfor (unsigned p = 0; p < rep->nhdrs; p++)\n\t\tutil_unmap_hdr(&rep->part[p]);\n\n\treturn 0;\n\nerr:\n\tLOG(4, \"error clean up\");\n\tint oerrno = errno;\n\tfor (unsigned p = 0; p < rep->nhdrs; p++) {\n\t\tutil_unmap_hdr(&rep->part[p]);\n\t}\n\terrno = oerrno;\n\treturn -1;\n}\n\n/*\n * util_replica_create_local -- (internal) create a new memory pool for local\n * replica\n */\nstatic int\nutil_replica_create_local(struct pool_set *set, unsigned repidx, int flags,\n\tconst struct pool_attr *attr)\n{\n\tLOG(3, \"set %p repidx %u flags %d attr %p\", set, repidx, flags, attr);\n\n\t/*\n\t * the first replica has to be mapped prior to remote ones so if\n\t * a replica is already mapped skip mapping creation\n\t */\n\tif (PART(REP(set, repidx), 0)->addr == NULL) {\n\t\tif (util_replica_map_local(set, repidx, flags) != 0) {\n\t\t\tLOG(2, \"replica #%u map failed\", repidx);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (attr == NULL)\n\t\treturn 0;\n\n\tif (util_replica_init_headers_local(set, repidx, flags, attr) != 0) {\n\t\tLOG(2, \"replica #%u headers initialization failed\", repidx);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * util_replica_create_remote -- (internal) create a new memory pool\n *                               for remote replica\n */\nstatic int\nutil_replica_create_remote(struct pool_set *set, unsigned repidx, int flags,\n\tconst struct pool_attr *attr)\n{\n\tLOG(3, \"set %p repidx %u flags %d attr %p\", set, repidx, flags, attr);\n\n\tstruct pool_replica *rep = set->replica[repidx];\n\n\tASSERTne(rep->remote, NULL);\n\tASSERTne(rep->part, NULL);\n\tASSERTeq(rep->nparts, 1);\n\tASSERTeq(rep->nhdrs, 1);\n\tASSERTne(attr, NULL);\n\n\tstruct pool_set_part *part = rep->part;\n\n\t/*\n\t * A remote replica has one fake part of size equal twice pool header\n\t * size for storing pool header and pool descriptor.\n\t */\n\tpart->size = rep->repsize;\n\tASSERT(IS_PAGE_ALIGNED(part->size));\n\tpart->remote_hdr = Zalloc(part->size + Pagesize);\n\tif (!part->remote_hdr) {\n\t\tERR(\"!Zalloc\");\n\t\treturn -1;\n\t}\n\n\tpart->hdr = PAGE_ALIGN_UP(part->remote_hdr);\n\tpart->addr = PAGE_ALIGN_UP(part->remote_hdr);\n\tpart->hdrsize = POOL_HDR_SIZE;\n\n\t/* create header, set UUID's */\n\tif (util_header_create(set, repidx, 0, attr, 0) != 0) {\n\t\tLOG(2, \"header creation failed - part #0\");\n\t\tFree(part->remote_hdr);\n\t\treturn -1;\n\t}\n\n\tLOG(3, \"replica #%u addr %p\", repidx, rep->part[0].addr);\n\n\treturn 0;\n}\n\n/*\n * util_replica_close -- close a memory pool replica\n *\n * This function unmaps all mapped memory regions.\n */\nint\nutil_replica_close(struct pool_set *set, unsigned repidx)\n{\n\tLOG(3, \"set %p repidx %u\", set, repidx);\n\tstruct pool_replica *rep = set->replica[repidx];\n\n\tif (rep->remote == NULL) {\n\t\tstruct pool_set_part *part = PART(rep, 0);\n\t\tif (!set->ignore_sds && part->addr != NULL &&\n\t\t\t\tpart->size != 0) {\n\t\t\tstruct pool_hdr *hdr = part->addr;\n\t\t\tRANGE_RW(hdr, sizeof(*hdr), part->is_dev_dax);\n\t\t\t/*\n\t\t\t * deep drain will call msync on one page in each\n\t\t\t * part in replica to trigger WPQ flush.\n\t\t\t * This pages may have been marked as\n\t\t\t * undefined/inaccessible, but msyncing such memory\n\t\t\t * is not a bug, so as a workaround temporarily\n\t\t\t * disable error reporting.\n\t\t\t */\n\t\t\tVALGRIND_DO_DISABLE_ERROR_REPORTING;\n\t\t\tutil_replica_deep_drain(part->addr, rep->repsize,\n\t\t\t\tset, repidx);\n\t\t\tVALGRIND_DO_ENABLE_ERROR_REPORTING;\n\t\t\tshutdown_state_clear_dirty(&hdr->sds, rep);\n\t\t}\n\t\tfor (unsigned p = 0; p < rep->nhdrs; p++)\n\t\t\tutil_unmap_hdr(&rep->part[p]);\n\n\t\trep->part[0].size = rep->resvsize;\n\t\tutil_unmap_part(&rep->part[0]);\n\t} else {\n\t\tLOG(4, \"freeing volatile header of remote replica #%u\", repidx);\n\t\tFree(rep->part[0].remote_hdr);\n\t\trep->part[0].remote_hdr = NULL;\n\t\trep->part[0].hdr = NULL;\n\t\trep->part[0].hdrsize = 0;\n\t\trep->part[0].addr = NULL;\n\t\trep->part[0].size = 0;\n\t}\n\n\treturn 0;\n}\n\n/*\n * util_poolset_append_new_part -- (internal) creates a new part in each replica\n *\tof the poolset\n */\nstatic int\nutil_poolset_append_new_part(struct pool_set *set, size_t size)\n{\n\tLOG(3, \"set %p size %zu\", set, size);\n\n\tif (!set->directory_based)\n\t\treturn -1;\n\n\tstruct pool_set_directory *d;\n\tsize_t directory_id;\n\tchar *path;\n\tsize_t path_len;\n\n\tunsigned r;\n\tfor (r = 0; r < set->nreplicas; ++r) {\n\t\tstruct pool_replica *rep = set->replica[r];\n\n\t\tdirectory_id = set->next_directory_id %\n\t\t\tVEC_SIZE(&rep->directory);\n\t\td = VEC_GET(&rep->directory, directory_id);\n\n\t\tpath_len = strlen(d->path) + PMEM_FILE_MAX_LEN;\n\t\tif ((path = Malloc(path_len)) == NULL) {\n\t\t\tERR(\"!Malloc\");\n\t\t\tgoto err_part_init;\n\t\t}\n\n\t\tsnprintf(path, path_len, \"%s\" OS_DIR_SEP_STR \"%0*u%s\",\n\t\t\td->path, PMEM_FILE_PADDING, set->next_id, PMEM_EXT);\n\n\t\tif (util_replica_add_part(&set->replica[r], path, size) != 0)\n\t\t\tFATAL(\"cannot add a new part to the replica info\");\n\t}\n\n\tset->next_directory_id += 1;\n\tset->next_id += 1;\n\n\tutil_poolset_set_size(set);\n\n\treturn 0;\n\nerr_part_init:\n\t/* for each replica 0..r-1 remove the last part */\n\tfor (unsigned rn = 0; rn < r; ++rn) {\n\t\tstruct pool_replica *rep = set->replica[rn];\n\t\tunsigned pidx = rep->nparts - 1;\n\t\tFree((void *)(rep->part[pidx].path));\n\t\trep->part[pidx].path = NULL;\n\t\trep->nparts--;\n\t}\n\n\treturn -1;\n}\n\n/*\n * util_pool_extend -- extends the poolset by the provided size\n */\nvoid *\nutil_pool_extend(struct pool_set *set, size_t *size, size_t minpartsize)\n{\n\tLOG(3, \"set %p size %zu minpartsize %zu\", set, *size, minpartsize);\n\n\tif (*size == 0) {\n\t\tERR(\"cannot extend pool by 0 bytes\");\n\t\treturn NULL;\n\t}\n\n\tif ((set->options & OPTION_SINGLEHDR) == 0) {\n\t\tERR(\n\t\t\"extending the pool by appending parts with headers is not supported!\");\n\t\treturn NULL;\n\t}\n\n\tif (set->poolsize + *size > set->resvsize) {\n\t\t*size = set->resvsize - set->poolsize;\n\t\tif (*size < minpartsize) {\n\t\t\tERR(\"exceeded reservation size\");\n\t\t\treturn NULL;\n\t\t}\n\t\tLOG(4, \"extend size adjusted to not exceed reservation size\");\n\t}\n\n\tsize_t old_poolsize = set->poolsize;\n\n\tif (util_poolset_append_new_part(set, *size) != 0) {\n\t\tERR(\"unable to append a new part to the pool\");\n\t\treturn NULL;\n\t}\n\n\tsize_t hdrsize = (set->options & OPTION_SINGLEHDR) ? 0 : Mmap_align;\n\tvoid *addr = NULL;\n\tvoid *addr_base = NULL;\n\n\tunsigned r;\n\tfor (r = 0; r < set->nreplicas; r++) {\n\t\tstruct pool_replica *rep = set->replica[r];\n\t\tunsigned pidx = rep->nparts - 1;\n\t\tstruct pool_set_part *p = &rep->part[pidx];\n\n\t\tif (util_part_open(p, 0, 1 /* create */) != 0) {\n\t\t\tERR(\"cannot open the new part\");\n\t\t\tgoto err;\n\t\t}\n\n\t\taddr = (char *)rep->part[0].addr + old_poolsize;\n\t\tif (addr_base == NULL)\n\t\t\taddr_base = addr;\n\n\t\tif (util_map_part(p, addr, 0, hdrsize,\n\t\t\t\tMAP_SHARED | MAP_FIXED, 0) != 0) {\n\t\t\tERR(\"cannot map the new part\");\n\t\t\tgoto err;\n\t\t}\n\n\t\t/*\n\t\t * new part must be mapped the same way as all the rest\n\t\t * within a replica\n\t\t */\n\t\tif (p->map_sync != rep->part[0].map_sync) {\n\t\t\tif (p->map_sync)\n\t\t\t\tERR(\"new part cannot be mapped with MAP_SYNC\");\n\t\t\telse\n\t\t\t\tERR(\"new part mapped with MAP_SYNC\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t/* XXX: mode should be the same as for pmemxxx_create() */\n\tif (util_poolset_chmod(set, S_IWUSR | S_IRUSR))\n\t\tgoto err;\n\n\tutil_poolset_fdclose(set);\n\n\treturn addr_base;\n\nerr:\n\tfor (unsigned rn = 0; rn <= r; ++rn) {\n\t\tstruct pool_replica *rep = set->replica[r];\n\t\tunsigned pidx = rep->nparts - 1;\n\t\tstruct pool_set_part *p = &rep->part[pidx];\n\t\trep->nparts--;\n\n\t\tif (p->fd != 0)\n\t\t\t(void) os_close(p->fd);\n\t\tif (p->created)\n\t\t\tos_unlink(p->path);\n\t\tFree((void *)p->path);\n\t\tp->path = NULL;\n\t}\n\tutil_poolset_set_size(set);\n\n\treturn NULL;\n}\n\n/*\n * util_print_bad_files_cb -- (internal) callback printing names of pool files\n *                            containing bad blocks\n */\nstatic int\nutil_print_bad_files_cb(struct part_file *pf, void *arg)\n{\n\tif (!pf->is_remote && pf->part && pf->part->has_bad_blocks)\n\t\tERR(\"file contains bad blocks -- '%s'\", pf->part->path);\n\n\treturn 0;\n}\n\n/*\n * util_pool_create_uuids -- create a new memory pool (set or a single file)\n *                           with given uuids\n *\n * On success returns 0 and a pointer to a newly allocated structure\n * containing the info of all the parts of the pool set and replicas.\n */\nint\nutil_pool_create_uuids(struct pool_set **setp, const char *path,\n\tsize_t poolsize, size_t minsize, size_t minpartsize,\n\tconst struct pool_attr *attr, unsigned *nlanes, int can_have_rep,\n\tint remote)\n{\n\tLOG(3, \"setp %p path %s poolsize %zu minsize %zu minpartsize %zu \"\n\t\t\"pattr %p nlanes %p can_have_rep %i remote %i\", setp, path,\n\t\tpoolsize, minsize, minpartsize, attr, nlanes, can_have_rep,\n\t\tremote);\n\n\t/* attributes cannot be NULL for local replicas */\n\tASSERT(remote || attr != NULL);\n\n\tint flags = MAP_SHARED;\n\tint oerrno;\n\n\tint exists = util_file_exists(path);\n\tif (exists < 0)\n\t\treturn -1;\n\n\t/* check if file exists */\n\tif (poolsize > 0 && exists) {\n\t\tERR(\"file %s already exists\", path);\n\t\terrno = EEXIST;\n\t\treturn -1;\n\t}\n\n\tint ret = util_poolset_create_set(setp, path, poolsize, minsize,\n\t\t\tIGNORE_SDS(attr));\n\tif (ret < 0) {\n\t\tLOG(2, \"cannot create pool set -- '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tstruct pool_set *set = *setp;\n\n\tASSERT(set->nreplicas > 0);\n\n\tif (!remote && (set->options & OPTION_NOHDRS)) {\n\t\tERR(\n\t\t\t\"the NOHDRS poolset option is not supported for local poolsets\");\n\t\terrno = EINVAL;\n\t\tgoto err_poolset_free;\n\t}\n\n\tif ((attr == NULL) != ((set->options & OPTION_NOHDRS) != 0)) {\n\t\tERR(\n\t\t\t\"pool attributes are not supported for poolsets without headers (with the NOHDRS option)\");\n\t\terrno = EINVAL;\n\t\tgoto err_poolset_free;\n\t}\n\n\tif (set->directory_based && ((set->options & OPTION_SINGLEHDR) == 0)) {\n\t\tERR(\n\t\t\t\"directory based pools are not supported for poolsets with headers (without SINGLEHDR option)\");\n\t\terrno = EINVAL;\n\t\tgoto err_poolset_free;\n\t}\n\n\tif (set->resvsize < minsize) {\n\t\tERR(\"reservation pool size %zu smaller than %zu\",\n\t\t\tset->resvsize, minsize);\n\t\terrno = EINVAL;\n\t\tgoto err_poolset_free;\n\t}\n\n\tif (set->directory_based && set->poolsize == 0 &&\n\t\t\tutil_poolset_append_new_part(set, minsize) != 0) {\n\t\tERR(\"cannot create a new part in provided directories\");\n\t\tgoto err_poolset_free;\n\t}\n\n\tif (attr != NULL &&\n\t    (attr->features.compat & POOL_FEAT_CHECK_BAD_BLOCKS)) {\n\t\tint bbs = badblocks_check_poolset(set, 1 /* create */);\n\t\tif (bbs < 0) {\n\t\t\tLOG(1,\n\t\t\t\t\"failed to check pool set for bad blocks -- '%s'\",\n\t\t\t\tpath);\n\t\t\tgoto err_poolset_free;\n\t\t}\n\n\t\tif (bbs > 0) {\n\t\t\tutil_poolset_foreach_part_struct(set,\n\t\t\t\t\t\t\tutil_print_bad_files_cb,\n\t\t\t\t\t\t\tNULL);\n\t\t\tERR(\n\t\t\t\t\"pool set contains bad blocks and cannot be created, run 'pmempool create --clear-bad-blocks' utility to clear bad blocks and create a pool\");\n\t\t\terrno = EIO;\n\t\t\tgoto err_poolset_free;\n\t\t}\n\t}\n\n\tif (set->poolsize < minsize) {\n\t\tERR(\"net pool size %zu smaller than %zu\",\n\t\t\tset->poolsize, minsize);\n\t\terrno = EINVAL;\n\t\tgoto err_poolset_free;\n\t}\n\n\tif (remote) {\n\t\t/* it is a remote replica - it cannot have replicas */\n\t\tif (set->nreplicas > 1) {\n\t\t\tLOG(2, \"remote pool set cannot have replicas\");\n\t\t\terrno = EINVAL;\n\t\t\tgoto err_poolset_free;\n\t\t}\n\n\t\t/* check if poolset options match remote pool attributes */\n\t\tif (attr != NULL &&\n\t\t\t\t((set->options & OPTION_SINGLEHDR) == 0) !=\n\t\t\t\t((attr->features.incompat &\n\t\t\t\t\t\tPOOL_FEAT_SINGLEHDR) == 0)) {\n\t\t\tERR(\n\t\t\t\t\"pool incompat feature flags and remote poolset options do not match\");\n\t\t\terrno = EINVAL;\n\t\t\tgoto err_poolset_free;\n\t\t}\n\t}\n\n\tif (!can_have_rep && set->nreplicas > 1) {\n\t\tERR(\"replication not supported\");\n\t\terrno = ENOTSUP;\n\t\tgoto err_poolset_free;\n\t}\n\n\tif (set->remote && util_remote_load()) {\n\t\tERR(\n\t\t\t\"the pool set requires a remote replica, but the '%s' library cannot be loaded\",\n\t\t\tLIBRARY_REMOTE);\n\t\tgoto err_poolset_free;\n\t}\n\n\tset->zeroed = 1;\n\n\tif (attr != NULL) {\n\t\tif (!util_is_zeroed(attr->poolset_uuid, POOL_HDR_UUID_LEN)) {\n\t\t\tmemcpy(set->uuid, attr->poolset_uuid,\n\t\t\t\t\tPOOL_HDR_UUID_LEN);\n\t\t} else {\n\t\t\t/* generate pool set UUID */\n\t\t\tret = util_uuid_generate(set->uuid);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG(2, \"cannot generate pool set UUID\");\n\t\t\t\tgoto err_poolset;\n\t\t\t}\n\t\t}\n\n\t\t/* generate UUID's for all the parts */\n\t\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\t\tstruct pool_replica *rep = set->replica[r];\n\t\t\tfor (unsigned i = 0; i < rep->nhdrs; i++) {\n\t\t\t\tret = util_uuid_generate(rep->part[i].uuid);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG(2,\n\t\t\t\t\t\"cannot generate pool set part UUID\");\n\t\t\t\t\tgoto err_poolset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* overwrite UUID of the first part if given */\n\t\tif (!util_is_zeroed(attr->first_part_uuid, POOL_HDR_UUID_LEN)) {\n\t\t\tmemcpy(set->replica[0]->part[0].uuid,\n\t\t\t\tattr->first_part_uuid, POOL_HDR_UUID_LEN);\n\t\t}\n\t}\n\n\tret = util_poolset_files_local(set, minpartsize, 1);\n\tif (ret != 0)\n\t\tgoto err_poolset;\n\n\t/* map first local replica - it has to exist prior to remote ones */\n\tret = util_replica_map_local(set, 0, flags);\n\tif (ret != 0)\n\t\tgoto err_poolset;\n\n\t/* prepare remote replicas first */\n\tif (set->remote) {\n\t\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\t\tif (REP(set, r)->remote == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (util_replica_create_remote(set, r, flags, attr) !=\n\t\t\t\t\t0) {\n\t\t\t\tLOG(2, \"replica #%u creation failed\", r);\n\t\t\t\tgoto err_create;\n\t\t\t}\n\t\t}\n\n\t\tret = util_poolset_files_remote(set, minsize, nlanes,\n\t\t\t\t1 /* create */);\n\t\tif (ret != 0)\n\t\t\tgoto err_create;\n\t}\n\n\t/* prepare local replicas */\n\tif (remote) {\n\t\tif (util_replica_create_local(set, 0, flags, attr) != 0) {\n\t\t\tLOG(2, \"replica #0 creation failed\");\n\t\t\tgoto err_create;\n\t\t}\n\t} else {\n\t\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\t\tif (REP(set, r)->remote != NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (util_replica_create_local(set, r, flags, attr) !=\n\t\t\t\t\t0) {\n\t\t\t\tLOG(2, \"replica #%u creation failed\", r);\n\t\t\t\tgoto err_create;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_create:\n\toerrno = errno;\n\tfor (unsigned r = 0; r < set->nreplicas; r++)\n\t\tutil_replica_close(set, r);\n\terrno = oerrno;\nerr_poolset:\n\toerrno = errno;\n\tutil_poolset_close(set, DELETE_CREATED_PARTS);\n\terrno = oerrno;\n\treturn -1;\n\nerr_poolset_free:\n\toerrno = errno;\n\tutil_poolset_free(set);\n\terrno = oerrno;\n\treturn -1;\n}\n\n/*\n * util_pool_create -- create a new memory pool (set or a single file)\n *\n * On success returns 0 and a pointer to a newly allocated structure\n * containing the info of all the parts of the pool set and replicas.\n */\nint\nutil_pool_create(struct pool_set **setp, const char *path, size_t poolsize,\n\tsize_t minsize, size_t minpartsize, const struct pool_attr *attr,\n\tunsigned *nlanes, int can_have_rep)\n{\n\tLOG(3, \"setp %p path %s poolsize %zu minsize %zu minpartsize %zu \"\n\t\t\"attr %p nlanes %p can_have_rep %i\", setp, path, poolsize,\n\t\tminsize, minpartsize, attr, nlanes, can_have_rep);\n\n\treturn util_pool_create_uuids(setp, path, poolsize, minsize,\n\t\t\tminpartsize, attr, nlanes, can_have_rep, POOL_LOCAL);\n}\n\n/*\n * util_replica_open_local -- (internal) open a memory pool local replica\n */\nstatic int\nutil_replica_open_local(struct pool_set *set, unsigned repidx, int flags)\n{\n\tLOG(3, \"set %p repidx %u flags %d\", set, repidx, flags);\n\n\tint remaining_retries = 10;\n\tint retry_for_contiguous_addr;\n\tsize_t mapsize;\n\tsize_t hdrsize = (set->options & (OPTION_SINGLEHDR | OPTION_NOHDRS)) ?\n\t\t\t0 : Mmap_align;\n\tstruct pool_replica *rep = set->replica[repidx];\n\tvoid *addr = NULL;\n\n\tdo {\n\t\tretry_for_contiguous_addr = 0;\n\n\t\t/* determine a hint address for mmap() if not specified */\n\t\tif (addr == NULL)\n\t\t\taddr = util_map_hint(rep->resvsize, 0);\n\t\tif (addr == MAP_FAILED) {\n\t\t\tLOG(1, \"cannot find a contiguous region of given size\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmapsize = rep->part[0].filesize & ~(Mmap_align - 1);\n\n\t\t/* map the first part and reserve space for remaining parts */\n\t\tif (util_map_part(&rep->part[0], addr, rep->resvsize, 0,\n\t\t\t\tflags, 0) != 0) {\n\t\t\tLOG(2, \"pool mapping failed - replica #%u part #0\",\n\t\t\t\trepidx);\n\t\t\treturn -1;\n\t\t}\n\n\t\tVALGRIND_REGISTER_PMEM_MAPPING(rep->part[0].addr,\n\t\t\trep->resvsize);\n\t\tVALGRIND_REGISTER_PMEM_FILE(rep->part[0].fd,\n\t\t\trep->part[0].addr, rep->resvsize, 0);\n\n\t\t/* map all headers - don't care about the address */\n\t\tfor (unsigned p = 0; p < rep->nhdrs; p++) {\n\t\t\tif (util_map_hdr(&rep->part[p], flags, 0) != 0) {\n\t\t\t\tLOG(2, \"header mapping failed - part #%d\", p);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\taddr = (char *)rep->part[0].addr + mapsize;\n\n\t\t/*\n\t\t * map the remaining parts of the usable pool space\n\t\t * (aligned to memory mapping granularity)\n\t\t */\n\t\tfor (unsigned p = 1; p < rep->nparts; p++) {\n\t\t\tstruct pool_set_part *part = &rep->part[p];\n\t\t\tsize_t targetsize = mapsize +\n\t\t\t\tALIGN_DOWN(part->filesize - hdrsize,\n\t\t\t\tpart->alignment);\n\t\t\tif (targetsize > rep->resvsize) {\n\t\t\t\tERR(\n\t\t\t\t\t\"pool mapping failed - address space reservation too small\");\n\t\t\t\terrno = EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t/* map data part */\n\t\t\tif (util_map_part(part, addr, 0, hdrsize,\n\t\t\t\t\tflags | MAP_FIXED, 0) != 0) {\n\t\t\t\t/*\n\t\t\t\t * if we can't map the part at the address we\n\t\t\t\t * asked for, unmap all the parts that are\n\t\t\t\t * mapped and remap at a different address.\n\t\t\t\t */\n\t\t\t\tif ((errno == EINVAL) &&\n\t\t\t\t    (remaining_retries > 0)) {\n\t\t\t\t\tLOG(2, \"usable space mapping failed - \"\n\t\t\t\t\t\t\"part #%d - retrying\", p);\n\t\t\t\t\tretry_for_contiguous_addr = 1;\n\t\t\t\t\tremaining_retries--;\n\n\t\t\t\t\tutil_unmap_parts(rep, 0, p - 1);\n\n\t\t\t\t\t/* release rest of the VA reserved */\n\t\t\t\t\tmunmap(rep->part[0].addr,\n\t\t\t\t\t\trep->resvsize);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tLOG(2, \"usable space mapping failed - part #%d\",\n\t\t\t\t\tp);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tVALGRIND_REGISTER_PMEM_FILE(part->fd,\n\t\t\t\tpart->addr, part->size, hdrsize);\n\n\t\t\tmapsize += part->size;\n\t\t\taddr = (char *)addr + part->size;\n\t\t}\n\t} while (retry_for_contiguous_addr);\n\n\t/*\n\t * Initially part[0].size is the size of address space\n\t * reservation for all parts from given replica. After\n\t * mapping that space we need to overwrite part[0].size\n\t * with its actual size to be consistent - size for each\n\t * part should be the actual mapping size of this part\n\t * only - it simplifies future calculations.\n\t */\n\trep->part[0].size = rep->part[0].filesize & ~(Mmap_align - 1);\n\n\tif (util_replica_check_map_sync(set, repidx, 1))\n\t\tgoto err;\n\n\tutil_replica_set_is_pmem(rep);\n\n\tif (Prefault_at_open)\n\t\tutil_replica_force_page_allocation(rep);\n\n\tASSERTeq(mapsize, rep->repsize);\n\n\t/* calculate pool size - choose the smallest replica size */\n\tif (rep->repsize < set->poolsize)\n\t\tset->poolsize = rep->repsize;\n\n\tLOG(3, \"replica addr %p\", rep->part[0].addr);\n\n\treturn 0;\nerr:\n\tLOG(4, \"error clean up\");\n\tint oerrno = errno;\n\tif (mapsize < rep->repsize) {\n\t\tASSERTne(rep->part[0].addr, NULL);\n\t\tASSERTne(rep->part[0].addr, MAP_FAILED);\n\t\tmunmap(rep->part[0].addr, rep->resvsize - mapsize);\n\t}\n\tfor (unsigned p = 0; p < rep->nhdrs; p++)\n\t\tutil_unmap_hdr(&rep->part[p]);\n\tfor (unsigned p = 0; p < rep->nparts; p++)\n\t\tutil_unmap_part(&rep->part[p]);\n\terrno = oerrno;\n\treturn -1;\n}\n\n/*\n * util_replica_open_remote -- open a memory pool for remote replica\n */\nint\nutil_replica_open_remote(struct pool_set *set, unsigned repidx, int flags)\n{\n\tLOG(3, \"set %p repidx %u flags %d\", set, repidx, flags);\n\n\tstruct pool_replica *rep = set->replica[repidx];\n\n\tASSERTne(rep->remote, NULL);\n\tASSERTne(rep->part, NULL);\n\tASSERTeq(rep->nparts, 1);\n\tASSERTeq(rep->nhdrs, 1);\n\n\tstruct pool_set_part *part = rep->part;\n\n\tpart->size = rep->repsize;\n\tASSERT(IS_PAGE_ALIGNED(part->size));\n\tpart->remote_hdr = Zalloc(part->size + Pagesize);\n\tif (!part->remote_hdr) {\n\t\tERR(\"!Zalloc\");\n\t\treturn -1;\n\t}\n\n\tpart->hdr = PAGE_ALIGN_UP(part->remote_hdr);\n\tpart->addr = PAGE_ALIGN_UP(part->remote_hdr);\n\tpart->hdrsize = POOL_HDR_SIZE;\n\n\tLOG(3, \"replica #%u addr %p\", repidx, rep->part[0].addr);\n\n\treturn 0;\n}\n\n/*\n * util_replica_open -- open a memory pool replica\n */\nint\nutil_replica_open(struct pool_set *set, unsigned repidx, int flags)\n{\n\tLOG(3, \"set %p repidx %u flags %d\", set, repidx, flags);\n\n\tif (set->replica[repidx]->remote)\n\t\treturn util_replica_open_remote(set, repidx, flags);\n\n\treturn util_replica_open_local(set, repidx, flags);\n}\n\n/*\n * util_replica_set_attr -- overwrite existing replica attributes\n */\nint\nutil_replica_set_attr(struct pool_replica *rep,\n\t\tconst struct rpmem_pool_attr *rattr)\n{\n\tLOG(3, \"rep %p, rattr %p\", rep, rattr);\n\tASSERT(rattr != NULL || rep->nhdrs == 0);\n\n\tif (rattr != NULL && rep->nhdrs == 0) {\n\t\tERR(\n\t\t\"cannot set pool attributes for a replica without headers (with the NOHDRS option)\");\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tint flags = MAP_SHARED;\n\n\t/* map all headers - don't care about the address */\n\tfor (unsigned p = 0; p < rep->nparts; p++) {\n\t\tif (util_map_hdr(&rep->part[p], flags, 0) != 0) {\n\t\t\tLOG(2, \"header mapping failed - part #%d\", p);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tfor (unsigned p = 0; p < rep->nhdrs; p++) {\n\t\tASSERTne(rattr, NULL);\n\n\t\tstruct pool_hdr *hdrp = HDR(rep, p);\n\t\tASSERTne(hdrp, NULL);\n\t\tutil_convert2h_hdr_nocheck(hdrp);\n\n\t\tutil_set_rpmem_attr(hdrp, rattr);\n\n\t\tif (hdrp == HDR(rep, 0))\n\t\t\tmemcpy(hdrp->uuid, rattr->uuid, POOL_HDR_UUID_LEN);\n\t\tif (hdrp == HDRP(rep, 0))\n\t\t\tmemcpy(hdrp->next_part_uuid, rattr->uuid,\n\t\t\t\t\tPOOL_HDR_UUID_LEN);\n\t\tif (hdrp == HDRN(rep, 0))\n\t\t\tmemcpy(hdrp->prev_part_uuid, rattr->uuid,\n\t\t\t\t\tPOOL_HDR_UUID_LEN);\n\n\t\tutil_convert2le_hdr(hdrp);\n\n\t\tutil_checksum(hdrp, sizeof(*hdrp), &hdrp->checksum,\n\t\t\t1, POOL_HDR_CSUM_END_OFF(hdrp));\n\n\t\t/* store pool's header */\n\t\tutil_persist_auto(rep->is_pmem, hdrp, sizeof(*hdrp));\n\t}\n\n\t/* unmap all headers */\n\tfor (unsigned p = 0; p < rep->nhdrs; p++)\n\t\tutil_unmap_hdr(&rep->part[p]);\n\n\treturn 0;\nerr:\n\tfor (unsigned p = 0; p < rep->nhdrs; p++) {\n\t\tutil_unmap_hdr(&rep->part[p]);\n\t}\n\treturn -1;\n}\n\n/*\n * util_get_attr_from_header -- get pool attributes from a pool header\n */\nvoid\nutil_pool_hdr2attr(struct pool_attr *attr, struct pool_hdr *hdr)\n{\n\tLOG(3, \"attr %p, hdr %p\", attr, hdr);\n\tASSERTne(attr, NULL);\n\tASSERTne(hdr, NULL);\n\tmemset(attr, 0, sizeof(*attr));\n\tmemcpy(attr->signature, hdr->signature, POOL_HDR_SIG_LEN);\n\tattr->major = hdr->major;\n\tattr->features.compat = hdr->features.compat;\n\tattr->features.incompat = hdr->features.incompat;\n\tattr->features.ro_compat = hdr->features.ro_compat;\n\tmemcpy(attr->poolset_uuid, hdr->poolset_uuid, POOL_HDR_UUID_LEN);\n}\n\n/*\n * util_copy_attr_to_header -- copy pool attributes into pool header\n */\nvoid\nutil_pool_attr2hdr(struct pool_hdr *hdr, const struct pool_attr *attr)\n{\n\tLOG(3, \"hdr %p, attr %p\", hdr, attr);\n\tASSERTne(hdr, NULL);\n\tASSERTne(attr, NULL);\n\tmemcpy(hdr->signature, attr->signature, POOL_HDR_SIG_LEN);\n\thdr->major = attr->major;\n\thdr->features.compat = attr->features.compat;\n\thdr->features.incompat = attr->features.incompat;\n\thdr->features.ro_compat = attr->features.ro_compat;\n}\n\n/*\n * util_unmap_all_hdrs -- unmap all pool set headers\n */\nstatic void\nutil_unmap_all_hdrs(struct pool_set *set)\n{\n\tLOG(3, \"set %p\", set);\n\n\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\tstruct pool_replica *rep = set->replica[r];\n\t\tif (rep->remote == NULL) {\n\t\t\tfor (unsigned p = 0; p < rep->nhdrs; p++)\n\t\t\t\tutil_unmap_hdr(&rep->part[p]);\n\t\t} else {\n\t\t\t/*\n\t\t\t * hdr & hdrsize were set only for util_header_check(),\n\t\t\t * they will not be used any more. The memory will be\n\t\t\t * freed by util_replica_close()\n\t\t\t */\n\t\t\trep->part[0].hdr = NULL;\n\t\t\trep->part[0].hdrsize = 0;\n\t\t}\n\t}\n}\n\n/*\n * util_replica_check -- check headers, check UUID's, check replicas linkage\n */\nstatic int\nutil_replica_check(struct pool_set *set, const struct pool_attr *attr)\n{\n\tLOG(3, \"set %p attr %p\", set, attr);\n\n\t/* read shutdown state toggle from header */\n\tset->ignore_sds |= IGNORE_SDS(HDR(REP(set, 0), 0));\n\n\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\tstruct pool_replica *rep = set->replica[r];\n\t\tfor (unsigned p = 0; p < rep->nhdrs; p++) {\n\t\t\tif (util_header_check(set, r, p, attr) != 0) {\n\t\t\t\tLOG(2, \"header check failed - part #%d\", p);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tset->rdonly |= rep->part[p].rdonly;\n\t\t}\n\n\t\tif (memcmp(HDR(REPP(set, r), 0)->uuid,\n\t\t\t\t\tHDR(REP(set, r), 0)->prev_repl_uuid,\n\t\t\t\t\tPOOL_HDR_UUID_LEN) ||\n\t\t    memcmp(HDR(REPN(set, r), 0)->uuid,\n\t\t\t\t\tHDR(REP(set, r), 0)->next_repl_uuid,\n\t\t\t\t\tPOOL_HDR_UUID_LEN)) {\n\t\t\tERR(\"wrong replica UUID\");\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!set->ignore_sds && !rep->remote && rep->nhdrs) {\n\t\t\tstruct shutdown_state sds;\n\t\t\tshutdown_state_init(&sds, NULL);\n\t\t\tfor (unsigned p = 0; p < rep->nparts; p++) {\n\t\t\t\tif (shutdown_state_add_part(&sds,\n\t\t\t\t\t\tPART(rep, p)->fd, NULL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tASSERTne(rep->nhdrs, 0);\n\t\t\tASSERTne(rep->nparts, 0);\n\t\t\tif (shutdown_state_check(&sds, &HDR(rep, 0)->sds,\n\t\t\t\t\trep)) {\n\t\t\t\tLOG(2, \"ADR failure detected\");\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tshutdown_state_set_dirty(&HDR(rep, 0)->sds,\n\t\t\t\trep);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * util_pool_has_device_dax -- (internal) check if poolset has any device dax\n */\nint\nutil_pool_has_device_dax(struct pool_set *set)\n{\n\tfor (unsigned r = 0; r < set->nreplicas; ++r) {\n\t\tstruct pool_replica *rep = REP(set, r);\n\t\t/* either all the parts must be Device DAX or none */\n\t\tif (PART(rep, 0)->is_dev_dax)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * util_pool_open_nocheck -- open a memory pool (set or a single file)\n *\n * This function opens a pool set without checking the header values.\n */\nint\nutil_pool_open_nocheck(struct pool_set *set, unsigned flags)\n{\n\tLOG(3, \"set %p flags 0x%x\", set, flags);\n\n\tint cow = flags & POOL_OPEN_COW;\n\n\tif (cow && util_pool_has_device_dax(set)) {\n\t\tERR(\"device dax cannot be mapped privately\");\n\t\terrno = ENOTSUP;\n\t\treturn -1;\n\t}\n\n\tint mmap_flags = cow ? MAP_PRIVATE|MAP_NORESERVE : MAP_SHARED;\n\tint oerrno;\n\n\tASSERTne(set, NULL);\n\tASSERT(set->nreplicas > 0);\n\n\tif (flags & POOL_OPEN_CHECK_BAD_BLOCKS) {\n\t\t/* check if any bad block recovery file exists */\n\t\tint bfe = badblocks_recovery_file_exists(set);\n\t\tif (bfe > 0) {\n\t\t\tERR(\n\t\t\t\t\"error: a bad block recovery file exists, run 'pmempool sync --bad-blocks' utility to try to recover the pool\");\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tif (bfe < 0) {\n\t\t\tLOG(1,\n\t\t\t\t\"an error occurred when checking whether recovery file exists.\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tint bbs = badblocks_check_poolset(set, 0 /* not create */);\n\t\tif (bbs < 0) {\n\t\t\tLOG(1, \"failed to check pool set for bad blocks\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (bbs > 0) {\n\t\t\tif (flags & POOL_OPEN_IGNORE_BAD_BLOCKS) {\n\t\t\t\tLOG(1,\n\t\t\t\t\t\"WARNING: pool set contains bad blocks, ignoring\");\n\t\t\t} else {\n\t\t\t\tERR(\n\t\t\t\t\t\"pool set contains bad blocks and cannot be opened, run 'pmempool sync --bad-blocks' utility to try to recover the pool\");\n\t\t\t\terrno = EIO;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (set->remote && util_remote_load()) {\n\t\tERR(\"the pool set requires a remote replica, \"\n\t\t\t\"but the '%s' library cannot be loaded\",\n\t\t\tLIBRARY_REMOTE);\n\t\treturn -1;\n\t}\n\n\tint ret = util_poolset_files_local(set, 0 /* minpartsize */, 0);\n\tif (ret != 0)\n\t\tgoto err_poolset;\n\n\tset->rdonly = 0;\n\n\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\tif (util_replica_open(set, r, mmap_flags) != 0) {\n\t\t\tLOG(2, \"replica #%u open failed\", r);\n\t\t\tgoto err_replica;\n\t\t}\n\t}\n\n\tif (set->remote) {\n\t\tret = util_poolset_files_remote(set, 0, NULL, 0);\n\t\tif (ret != 0)\n\t\t\tgoto err_replica;\n\t}\n\n\tutil_unmap_all_hdrs(set);\n\n\treturn 0;\n\nerr_replica:\n\tLOG(4, \"error clean up\");\n\toerrno = errno;\n\tfor (unsigned r = 0; r < set->nreplicas; r++)\n\t\tutil_replica_close(set, r);\n\terrno = oerrno;\nerr_poolset:\n\toerrno = errno;\n\tutil_poolset_close(set, DO_NOT_DELETE_PARTS);\n\terrno = oerrno;\n\treturn -1;\n}\n\n/*\n * util_read_compat_features -- (internal) read compat features from the header\n */\nstatic int\nutil_read_compat_features(struct pool_set *set, uint32_t *compat_features)\n{\n\tLOG(3, \"set %p pcompat_features %p\", set, compat_features);\n\n\t*compat_features = 0;\n\n\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\tstruct pool_replica *rep = set->replica[r];\n\n\t\tif (rep->remote)\n\t\t\tcontinue;\n\n\t\tfor (unsigned p = 0; p < rep->nparts; p++) {\n\t\t\tstruct pool_set_part *part = &rep->part[p];\n\n\t\t\tif (util_part_open(part, 0, 0 /* create */)) {\n\t\t\t\tLOG(1, \"!cannot open the part -- \\\"%s\\\"\",\n\t\t\t\t\tpart->path);\n\t\t\t\t/* try to open the next part */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (util_map_hdr(part, MAP_SHARED, 0) != 0) {\n\t\t\t\tLOG(1, \"header mapping failed -- \\\"%s\\\"\",\n\t\t\t\t\tpart->path);\n\t\t\t\tutil_part_fdclose(part);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tstruct pool_hdr *hdrp = part->hdr;\n\t\t\t*compat_features = hdrp->features.compat;\n\n\t\t\tutil_unmap_hdr(part);\n\t\t\tutil_part_fdclose(part);\n\n\t\t\t/* exit on the first successfully opened part */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * unlink_remote_replicas -- removes remote replicas from poolset\n *\n * It is necessary when COW flag is set because remote replicas\n * cannot be mapped privately\n */\nstatic int\nunlink_remote_replicas(struct pool_set *set)\n{\n\tunsigned i = 0;\n\twhile (i < set->nreplicas) {\n\t\tif (set->replica[i]->remote == NULL) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tutil_replica_close(set, i);\n\t\tint ret = util_replica_close_remote(set->replica[i], i,\n\t\t\t\tDO_NOT_DELETE_PARTS);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\tsize_t size = sizeof(set->replica[i]) *\n\t\t\t(set->nreplicas - i - 1);\n\t\tmemmove(&set->replica[i], &set->replica[i + 1], size);\n\t\tset->nreplicas--;\n\t}\n\n\tset->remote = 0;\n\treturn 0;\n}\n\n/*\n * util_pool_open -- open a memory pool (set or a single file)\n *\n * This routine does all the work, but takes a rdonly flag so internal\n * calls can map a read-only pool if required.\n */\nint\nutil_pool_open(struct pool_set **setp, const char *path, size_t minpartsize,\n\tconst struct pool_attr *attr, unsigned *nlanes, void *addr,\n\tunsigned flags)\n{\n\tLOG(3, \"setp %p path %s minpartsize %zu attr %p nlanes %p \"\n\t\t\"addr %p flags 0x%x \", setp, path, minpartsize, attr, nlanes,\n\t\taddr, flags);\n\n\tint cow = flags & POOL_OPEN_COW;\n\tint mmap_flags = cow ? MAP_PRIVATE|MAP_NORESERVE : MAP_SHARED;\n\tint oerrno;\n\n\t/* do not check minsize */\n\tint ret = util_poolset_create_set(setp, path, 0, 0,\n\t\t\t\t\t\tflags & POOL_OPEN_IGNORE_SDS);\n\tif (ret < 0) {\n\t\tLOG(2, \"cannot open pool set -- '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((*setp)->replica[0]->nparts == 0) {\n\t\terrno = ENOENT;\n\t\tERR(\"!no parts in replicas\");\n\t\tgoto err_poolset_free;\n\t}\n\n\tif (cow && (*setp)->replica[0]->part[0].is_dev_dax) {\n\t\tERR(\"device dax cannot be mapped privately\");\n\t\terrno = ENOTSUP;\n\t\tgoto err_poolset_free;\n\t}\n\n\tstruct pool_set *set = *setp;\n\n\tASSERT(set->nreplicas > 0);\n\n\tuint32_t compat_features;\n\n\tif (util_read_compat_features(set, &compat_features)) {\n\t\tLOG(1, \"reading compat features failed\");\n\t\tgoto err_poolset_free;\n\t}\n\n\tif (compat_features & POOL_FEAT_CHECK_BAD_BLOCKS) {\n\t\t/* check if any bad block recovery file exists */\n\t\tint bfe = badblocks_recovery_file_exists(set);\n\t\tif (bfe > 0) {\n\t\t\tERR(\n\t\t\t\t\"error: a bad block recovery file exists, run 'pmempool sync --bad-blocks' utility to try to recover the pool\");\n\t\t\terrno = EINVAL;\n\t\t\tgoto err_poolset_free;\n\t\t}\n\n\t\tif (bfe < 0) {\n\t\t\tLOG(1,\n\t\t\t\t\"an error occurred when checking whether recovery file exists.\");\n\t\t\tgoto err_poolset_free;\n\t\t}\n\n\t\tint bbs = badblocks_check_poolset(set, 0 /* not create */);\n\t\tif (bbs < 0) {\n\t\t\tLOG(1,\n\t\t\t\t\"failed to check pool set for bad blocks -- '%s'\",\n\t\t\t\tpath);\n\t\t\tgoto err_poolset_free;\n\t\t}\n\n\t\tif (bbs > 0) {\n\t\t\tif (flags & POOL_OPEN_IGNORE_BAD_BLOCKS) {\n\t\t\t\tLOG(1,\n\t\t\t\t\t\"WARNING: pool set contains bad blocks, ignoring -- '%s'\",\n\t\t\t\t\tpath);\n\t\t\t} else {\n\t\t\t\tERR(\n\t\t\t\t\t\"pool set contains bad blocks and cannot be opened, run 'pmempool sync --bad-blocks' utility to try to recover the pool -- '%s'\",\n\t\t\t\t\tpath);\n\t\t\t\terrno = EIO;\n\t\t\t\tgoto err_poolset_free;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (set->remote && util_remote_load()) {\n\t\tERR(\n\t\t\t\"the pool set requires a remote replica, but the '%s' library cannot be loaded\",\n\t\t\tLIBRARY_REMOTE);\n\t\tgoto err_poolset_free;\n\t}\n\n\tret = util_poolset_files_local(set, minpartsize, 0);\n\tif (ret != 0)\n\t\tgoto err_poolset;\n\n\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\tif (util_replica_open(set, r, mmap_flags) != 0) {\n\t\t\tLOG(2, \"replica #%u open failed\", r);\n\t\t\tgoto err_replica;\n\t\t}\n\t}\n\n\tif (set->remote) {\n\t\t/* do not check minsize */\n\t\tret = util_poolset_files_remote(set, 0, nlanes, 0);\n\t\tif (ret != 0)\n\t\t\tgoto err_replica;\n\t}\n\n\t/* check headers, check UUID's, check replicas linkage */\n\tif (attr != NULL && util_replica_check(set, attr))\n\t\tgoto err_replica;\n\n\t/* unmap all headers */\n\tutil_unmap_all_hdrs(set);\n\n\t/* remove all remote replicas from poolset when cow */\n\tif (cow && set->remote) {\n\t\tret = unlink_remote_replicas(set);\n\t\tif (ret != 0)\n\t\t\tgoto err_replica;\n\t}\n\n\treturn 0;\n\nerr_replica:\n\tLOG(4, \"error clean up\");\n\toerrno = errno;\n\tfor (unsigned r = 0; r < set->nreplicas; r++)\n\t\tutil_replica_close(set, r);\n\terrno = oerrno;\nerr_poolset:\n\toerrno = errno;\n\tutil_poolset_close(set, DO_NOT_DELETE_PARTS);\n\terrno = oerrno;\n\treturn -1;\n\nerr_poolset_free:\n\toerrno = errno;\n\tutil_poolset_free(*setp);\n\terrno = oerrno;\n\treturn -1;\n}\n\n/*\n * util_pool_open_remote -- open a remote pool set file\n *\n * This routine does all the work, but takes a rdonly flag so internal\n * calls can map a read-only pool if required.\n */\nint\nutil_pool_open_remote(struct pool_set **setp, const char *path, int cow,\n\tsize_t minpartsize, struct rpmem_pool_attr *rattr)\n{\n\tLOG(3, \"setp %p path %s cow %d minpartsize %zu rattr %p\",\n\t\tsetp, path, cow, minpartsize, rattr);\n\n\tint flags = cow ? MAP_PRIVATE|MAP_NORESERVE : MAP_SHARED;\n\tint oerrno;\n\n\t/* do not check minsize */\n\tint ret = util_poolset_create_set(setp, path, 0, 0, 0);\n\tif (ret < 0) {\n\t\tLOG(2, \"cannot open pool set -- '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif (cow && (*setp)->replica[0]->part[0].is_dev_dax) {\n\t\tERR(\"device dax cannot be mapped privately\");\n\t\terrno = ENOTSUP;\n\t\treturn -1;\n\t}\n\n\tstruct pool_set *set = *setp;\n\n\tif (set->nreplicas > 1) {\n\t\tLOG(2, \"remote pool set cannot have replicas\");\n\t\tgoto err_poolset;\n\t}\n\n\tuint32_t compat_features;\n\n\tif (util_read_compat_features(set, &compat_features)) {\n\t\tLOG(1, \"reading compat features failed\");\n\t\tgoto err_poolset;\n\t}\n\n\tif (compat_features & POOL_FEAT_CHECK_BAD_BLOCKS) {\n\t\t/* check if there are any bad blocks */\n\t\tint bbs = badblocks_check_poolset(set, 0 /* not create */);\n\t\tif (bbs < 0) {\n\t\t\tLOG(1,\n\t\t\t\t\"failed to check the remote replica for bad blocks -- '%s'\",\n\t\t\t\tpath);\n\t\t\tgoto err_poolset;\n\t\t}\n\n\t\tif (bbs > 0) {\n\t\t\tERR(\n\t\t\t\t\"remote replica contains bad blocks and cannot be opened, run 'pmempool sync --bad-blocks' utility to recreate it -- '%s'\",\n\t\t\t\tpath);\n\t\t\terrno = EIO;\n\t\t\tgoto err_poolset;\n\t\t}\n\t}\n\n\tret = util_poolset_files_local(set, minpartsize, 0);\n\tif (ret != 0)\n\t\tgoto err_poolset;\n\n\tif (util_replica_open(set, 0, flags) != 0) {\n\t\tLOG(2, \"replica open failed\");\n\t\tgoto err_replica;\n\t}\n\n\tstruct pool_replica *rep = set->replica[0];\n\n\tset->rdonly |= rep->part[0].rdonly;\n\n\t/* check headers, check UUID's, check replicas linkage */\n\tfor (unsigned p = 0; p < rep->nhdrs; p++) {\n\t\tif (util_header_check_remote(set, p) != 0) {\n\t\t\tLOG(2, \"header check failed - part #%d\", p);\n\t\t\tgoto err_replica;\n\t\t}\n\t\tset->rdonly |= rep->part[p].rdonly;\n\t}\n\n\tif (rep->nhdrs > 0) {\n\t\t/* header exists, copy pool attributes */\n\t\tstruct pool_hdr *hdr = rep->part[0].hdr;\n\t\tutil_get_rpmem_attr(rattr, hdr);\n\t} else {\n\t\t/* header does not exist, zero pool attributes */\n\t\tmemset(rattr, 0, sizeof(*rattr));\n\t}\n\n\t/* unmap all headers */\n\tfor (unsigned p = 0; p < rep->nhdrs; p++)\n\t\tutil_unmap_hdr(&rep->part[p]);\n\n\treturn 0;\n\nerr_replica:\n\tLOG(4, \"error clean up\");\n\toerrno = errno;\n\tutil_replica_close(set, 0);\n\terrno = oerrno;\nerr_poolset:\n\toerrno = errno;\n\tutil_poolset_close(set, DO_NOT_DELETE_PARTS);\n\terrno = oerrno;\n\treturn -1;\n}\n\n/*\n * util_is_poolset_file -- check if specified file is a poolset file\n *\n * Return value:\n * -1 - error\n *  0 - not a poolset\n *  1 - is a poolset\n */\nint\nutil_is_poolset_file(const char *path)\n{\n\tenum file_type type = util_file_get_type(path);\n\tif (type < 0)\n\t\treturn -1;\n\n\tif (type == TYPE_DEVDAX)\n\t\treturn 0;\n\n\tint fd = util_file_open(path, NULL, 0, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tint ret = 0;\n\tssize_t sret;\n\tchar signature[POOLSET_HDR_SIG_LEN];\n\tsize_t rd = 0;\n\tdo {\n\t\tsret = util_read(fd, &signature[rd], sizeof(signature) - rd);\n\t\tif (sret > 0)\n\t\t\trd += (size_t)sret;\n\t} while (sret > 0);\n\tif (sret < 0) {\n\t\tERR(\"!read\");\n\t\tret = -1;\n\t\tgoto out;\n\t} else if (rd != sizeof(signature)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (memcmp(signature, POOLSET_HDR_SIG, POOLSET_HDR_SIG_LEN) == 0)\n\t\tret = 1;\nout:\n\tos_close(fd);\n\treturn ret;\n}\n/*\n * util_poolset_foreach_part_struct -- walk through all poolset file parts\n *                                  of the given set\n *\n * Stops processing if callback returns non-zero value.\n * The value returned by callback is returned to the caller.\n */\nint\nutil_poolset_foreach_part_struct(struct pool_set *set,\n\tint (*callback)(struct part_file *pf, void *arg), void *arg)\n{\n\tLOG(3, \"set %p callback %p arg %p\", set, callback, arg);\n\n\tASSERTne(callback, NULL);\n\n\tint ret;\n\n\tfor (unsigned r = 0; r < set->nreplicas; r++) {\n\t\tstruct part_file cbdata;\n\t\tif (set->replica[r]->remote) {\n\t\t\tcbdata.is_remote = 1;\n\t\t\tcbdata.remote = set->replica[r]->remote;\n\t\t\tcbdata.part = NULL;\n\t\t\tret = (*callback)(&cbdata, arg);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tcbdata.is_remote = 0;\n\t\t\tcbdata.remote = NULL;\n\t\t\tfor (unsigned p = 0; p < set->replica[r]->nparts; p++) {\n\t\t\t\tcbdata.part = &set->replica[r]->part[p];\n\t\t\t\tret = (*callback)(&cbdata, arg);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * util_poolset_foreach_part -- walk through all poolset file parts\n *\n * Stops processing if callback returns non-zero value.\n * The value returned by callback is returned to the caller.\n *\n * Return value:\n *  0 - all part files have been processed\n * -1 - parsing poolset file error\n */\nint\nutil_poolset_foreach_part(const char *path,\n\tint (*callback)(struct part_file *pf, void *arg), void *arg)\n{\n\tLOG(3, \"path %s callback %p arg %p\", path, callback, arg);\n\n\tASSERTne(callback, NULL);\n\n\tint fd = os_open(path, O_RDONLY);\n\tif (fd < 0) {\n\t\tERR(\"!open: path \\\"%s\\\"\", path);\n\t\treturn -1;\n\t}\n\n\tstruct pool_set *set;\n\tint ret = util_poolset_parse(&set, path, fd);\n\tif (ret) {\n\t\tERR(\"util_poolset_parse failed -- '%s'\", path);\n\t\tret = -1;\n\t\tgoto err_close;\n\t}\n\n\tret = util_poolset_foreach_part_struct(set, callback, arg);\n\n\t/*\n\t * Make sure callback does not return -1,\n\t * because this value is reserved for parsing\n\t * error.\n\t */\n\tASSERTne(ret, -1);\n\tutil_poolset_free(set);\n\nerr_close:\n\tos_close(fd);\n\treturn ret;\n}\n\n/*\n * util_poolset_size -- get size of poolset, returns 0 on error\n */\nsize_t\nutil_poolset_size(const char *path)\n{\n\tint fd = os_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\tsize_t size = 0;\n\tstruct pool_set *set;\n\tif (util_poolset_parse(&set, path, fd))\n\t\tgoto err_close;\n\n\tsize = set->poolsize;\n\n\tutil_poolset_free(set);\nerr_close:\n\tos_close(fd);\n\treturn size;\n}\n\n/*\n * util_replica_fdclose -- close all parts of given replica\n */\nvoid\nutil_replica_fdclose(struct pool_replica *rep)\n{\n\tfor (unsigned p = 0; p < rep->nparts; p++) {\n\t\tstruct pool_set_part *part = &rep->part[p];\n\t\tutil_part_fdclose(part);\n\t}\n}\n\n/*\n * util_replica_deep_common -- performs common calculations\n * on all parts from replica to define intersection ranges\n * for final flushing operations that take place in\n * os_part_deep_common function.\n */\nint\nutil_replica_deep_common(const void *addr, size_t len, struct pool_set *set,\n\t\t\t\tunsigned replica_id, int flush)\n{\n\tLOG(3, \"addr %p len %zu set %p replica_id %u flush %d\",\n\t\taddr, len, set, replica_id, flush);\n\n\tstruct pool_replica *rep = set->replica[replica_id];\n\tuintptr_t rep_start = (uintptr_t)rep->part[0].addr;\n\tuintptr_t rep_end = rep_start + rep->repsize;\n\tuintptr_t start = (uintptr_t)addr;\n\tuintptr_t end = start + len;\n\n\tASSERT(start >= rep_start);\n\tASSERT(end <= rep_end);\n\n\tfor (unsigned p = 0; p < rep->nparts; p++) {\n\t\tstruct pool_set_part *part = &rep->part[p];\n\t\tuintptr_t part_start = (uintptr_t)part->addr;\n\t\tuintptr_t part_end = part_start + part->size;\n\t\t/* init intersection start and end addresses */\n\t\tuintptr_t range_start = start;\n\t\tuintptr_t range_end = end;\n\n\t\tif (part_start > end || part_end < start)\n\t\t\tcontinue;\n\t\t/* recalculate intersection addresses */\n\t\tif (part_start > start)\n\t\t\trange_start = part_start;\n\t\tif (part_end < end)\n\t\t\trange_end = part_end;\n\t\tsize_t range_len = range_end - range_start;\n\n\t\tLOG(15, \"perform deep flushing for replica %u \"\n\t\t\t\"part %p, addr %p, len %lu\",\n\t\t\treplica_id, part, (void *)range_start, range_len);\n\t\tif (os_part_deep_common(rep, p, (void *)range_start,\n\t\t\t\trange_len, flush)) {\n\t\t\tLOG(1, \"os_part_deep_common(%p, %p, %lu)\",\n\t\t\t\tpart, (void *)range_start, range_len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * util_replica_deep_persist -- wrapper for util_replica_deep_common\n * Calling the target precedes initialization of function that\n * partly defines way of deep replica flushing.\n */\nint\nutil_replica_deep_persist(const void *addr, size_t len, struct pool_set *set,\n\t\t\t\tunsigned replica_id)\n{\n\tLOG(3, \"addr %p len %zu set %p replica_id %u\",\n\t\taddr, len, set, replica_id);\n\n\tint flush = 1;\n\treturn util_replica_deep_common(addr, len, set, replica_id, flush);\n}\n\n/*\n * util_replica_deep_drain -- wrapper for util_replica_deep_common\n * Calling the target precedes initialization of function that\n * partly defines way of deep replica flushing.\n */\nint\nutil_replica_deep_drain(const void *addr, size_t len, struct pool_set *set,\n\t\t\t\tunsigned replica_id)\n{\n\tLOG(3, \"addr %p len %zu set %p replica_id %u\",\n\t\taddr, len, set, replica_id);\n\n\tint flush = 0;\n\treturn util_replica_deep_common(addr, len, set, replica_id, flush);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/common/libpmemcommon.vcxproj": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" ToolsVersion=\"14.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup Label=\"ProjectConfigurations\">\n    <ProjectConfiguration Include=\"Debug|x64\">\n      <Configuration>Debug</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Release|x64\">\n      <Configuration>Release</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n  </ItemGroup>\n  <ItemGroup>\n    <ClCompile Include=\"..\\libpmem2\\auto_flush_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\usc_windows.c\" />\n    <ClCompile Include=\"bad_blocks.c\" />\n    <ClCompile Include=\"set_badblocks.c\" />\n    <ClCompile Include=\"ctl.c\" />\n    <ClCompile Include=\"ctl_cow.c\" />\n    <ClCompile Include=\"ctl_prefault.c\" />\n    <ClCompile Include=\"ctl_sds.c\" />\n    <ClCompile Include=\"ctl_fallocate.c\" />\n    <ClCompile Include=\"file.c\" />\n    <ClCompile Include=\"file_windows.c\" />\n    <ClCompile Include=\"mmap.c\" />\n    <ClCompile Include=\"mmap_windows.c\" />\n    <ClCompile Include=\"os_deep_windows.c\" />\n    <ClCompile Include=\"pool_hdr.c\" />\n    <ClCompile Include=\"rand.c\" />\n    <ClCompile Include=\"set.c\" />\n    <ClCompile Include=\"shutdown_state.c\" />\n    <ClCompile Include=\"uuid.c\" />\n    <ClCompile Include=\"uuid_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\config.c\" />\n    <ClCompile Include=\"..\\libpmem2\\badblocks.c\" />\n    <ClCompile Include=\"..\\libpmem2\\badblocks_none.c\" />\n    <ClCompile Include=\"..\\libpmem2\\source.c\" />\n    <ClCompile Include=\"..\\libpmem2\\source_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils.c\" />\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils_other.c\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"..\\libpmem2\\auto_flush.h\" />\n    <ClInclude Include=\"..\\libpmem2\\auto_flush_windows.h\" />\n    <ClInclude Include=\"ctl.h\" />\n    <ClInclude Include=\"ctl_global.h\" />\n    <ClInclude Include=\"badblocks.h\" />\n    <ClInclude Include=\"set_badblocks.h\" />\n    <ClInclude Include=\"dlsym.h\" />\n    <ClInclude Include=\"file.h\" />\n    <ClInclude Include=\"mmap.h\" />\n    <ClInclude Include=\"os_deep.h\" />\n    <ClInclude Include=\"pmemcommon.h\" />\n    <ClInclude Include=\"pool_hdr.h\" />\n    <ClInclude Include=\"set.h\" />\n    <ClInclude Include=\"sys_util.h\" />\n    <ClInclude Include=\"uuid.h\" />\n    <ClInclude Include=\"..\\libpmem2\\config.h\" />\n    <ClInclude Include=\"..\\libpmem2\\pmem2_utils.h\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ProjectReference Include=\"..\\core\\libpmemcore.vcxproj\">\n      <Project>{2fa3155b-6f26-4d15-ac03-9d82d48dbc42}</Project>\n    </ProjectReference>\n  </ItemGroup>\n  <PropertyGroup Label=\"Globals\">\n    <ProjectGuid>{492BAA3D-0D5D-478E-9765-500463AE69AA}</ProjectGuid>\n    <Keyword>Win32Proj</Keyword>\n    <RootNamespace>libpmemcommon</RootNamespace>\n    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n    <ConfigurationType>StaticLibrary</ConfigurationType>\n    <UseDebugLibraries>true</UseDebugLibraries>\n    <PlatformToolset>v140</PlatformToolset>\n    <CharacterSet>NotSet</CharacterSet>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n    <ConfigurationType>StaticLibrary</ConfigurationType>\n    <UseDebugLibraries>true</UseDebugLibraries>\n    <PlatformToolset>v140</PlatformToolset>\n    <CharacterSet>NotSet</CharacterSet>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n  <ImportGroup Label=\"ExtensionSettings\">\n  </ImportGroup>\n  <ImportGroup Label=\"Shared\">\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <PropertyGroup Label=\"UserMacros\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <LinkIncremental>true</LinkIncremental>\n    <TargetExt>.lib</TargetExt>\n    <IncludePath>$(SolutionDir)\\include;$(SolutionDir)\\windows\\include;$(VC_IncludePath);$(WindowsSDK_IncludePath);.;</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <LinkIncremental>true</LinkIncremental>\n    <TargetExt>.lib</TargetExt>\n    <IncludePath>$(SolutionDir)\\include;$(SolutionDir)\\windows\\include;$(VC_IncludePath);$(WindowsSDK_IncludePath);.;</IncludePath>\n  </PropertyGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <ClCompile>\n      <PrecompiledHeader>NotUsing</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <PreprocessorDefinitions>PMDK_UTF8_API;NTDDI_VERSION=NTDDI_WIN10_RS1;_DEBUG;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <ForcedIncludeFiles>platform.h</ForcedIncludeFiles>\n      <CompileAs>CompileAsC</CompileAs>\n      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>\n      <ExceptionHandling>false</ExceptionHandling>\n      <TreatWarningAsError>true</TreatWarningAsError>\n      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(VcpkgRoot)include;$(SolutionDir)\\core</AdditionalIncludeDirectories>\n    </ClCompile>\n    <Link>\n      <SubSystem>Console</SubSystem>\n      <GenerateDebugInformation>true</GenerateDebugInformation>\n    </Link>\n    <Lib>\n      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>\n      <TreatLibWarningAsErrors>true</TreatLibWarningAsErrors>\n    </Lib>\n    <PreBuildEvent>\n      <Command>\n      </Command>\n    </PreBuildEvent>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <ClCompile>\n      <PrecompiledHeader>NotUsing</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <PreprocessorDefinitions>PMDK_UTF8_API;NTDDI_VERSION=NTDDI_WIN10_RS1;_DEBUG;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <ForcedIncludeFiles>platform.h</ForcedIncludeFiles>\n      <CompileAs>CompileAsC</CompileAs>\n      <Optimization>MaxSpeed</Optimization>\n      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>\n      <BasicRuntimeChecks>Default</BasicRuntimeChecks>\n      <ExceptionHandling>false</ExceptionHandling>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <TreatWarningAsError>true</TreatWarningAsError>\n      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(VcpkgRoot)include;$(SolutionDir)\\core</AdditionalIncludeDirectories>\n    </ClCompile>\n    <Link>\n      <SubSystem>Console</SubSystem>\n      <GenerateDebugInformation>true</GenerateDebugInformation>\n    </Link>\n    <Lib>\n      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>\n      <TreatLibWarningAsErrors>true</TreatLibWarningAsErrors>\n    </Lib>\n    <PreBuildEvent>\n      <Command>\n      </Command>\n    </PreBuildEvent>\n  </ItemDefinitionGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n  <ImportGroup Label=\"ExtensionTargets\">\n  </ImportGroup>\n</Project>",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/libpmempool/libpmempool.vcxproj": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" ToolsVersion=\"14.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup Label=\"ProjectConfigurations\">\n    <ProjectConfiguration Include=\"Debug|x64\">\n      <Configuration>Debug</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Release|x64\">\n      <Configuration>Release</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"..\\core\\alloc.h\" />\n    <ClInclude Include=\"..\\common\\dlsym.h\" />\n    <ClInclude Include=\"..\\core\\fault_injection.h\" />\n    <ClInclude Include=\"..\\common\\file.h\" />\n    <ClInclude Include=\"..\\core\\fs.h\" />\n    <ClInclude Include=\"..\\common\\mmap.h\" />\n    <ClInclude Include=\"..\\core\\os.h\" />\n    <ClInclude Include=\"..\\common\\os_deep.h\" />\n    <ClInclude Include=\"..\\core\\out.h\" />\n    <ClInclude Include=\"..\\common\\pmemcommon.h\" />\n    <ClInclude Include=\"..\\common\\pool_hdr.h\" />\n    <ClInclude Include=\"..\\common\\set.h\" />\n    <ClInclude Include=\"..\\common\\sys_util.h\" />\n    <ClInclude Include=\"..\\core\\util.h\" />\n    <ClInclude Include=\"..\\common\\uuid.h\" />\n    <ClInclude Include=\"..\\common\\valgrind_internal.h\" />\n    <ClInclude Include=\"..\\include\\libpmempool.h\" />\n    <ClInclude Include=\"..\\libpmem2\\auto_flush.h\" />\n    <ClInclude Include=\"..\\libpmem2\\auto_flush_windows.h\" />\n    <ClInclude Include=\"..\\libpmem2\\badblocks.h\" />\n    <ClInclude Include=\"..\\libpmemblk\\btt.h\" />\n    <ClInclude Include=\"check.h\" />\n    <ClInclude Include=\"check_util.h\" />\n    <ClInclude Include=\"pmempool.h\" />\n    <ClInclude Include=\"pool.h\" />\n    <ClInclude Include=\"replica.h\" />\n    <ClInclude Include=\"..\\libpmem2\\config.h\" />\n    <ClInclude Include=\"..\\libpmem2\\pmem2_utils.h\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ClCompile Include=\"..\\core\\alloc.c\" />\n    <ClCompile Include=\"..\\common\\set_badblocks.c\" />\n    <ClCompile Include=\"..\\common\\file.c\" />\n    <ClCompile Include=\"..\\common\\file_windows.c\" />\n    <ClCompile Include=\"..\\common\\mmap.c\" />\n    <ClCompile Include=\"..\\common\\mmap_windows.c\" />\n    <ClCompile Include=\"..\\core\\fs_windows.c\" />\n    <ClCompile Include=\"..\\common\\bad_blocks.c\" />\n    <ClCompile Include=\"..\\common\\os_deep_windows.c\" />\n    <ClCompile Include=\"..\\core\\os_thread_windows.c\" />\n    <ClCompile Include=\"..\\core\\os_windows.c\" />\n    <ClCompile Include=\"..\\core\\out.c\" />\n    <ClCompile Include=\"..\\common\\pool_hdr.c\" />\n    <ClCompile Include=\"..\\common\\set.c\" />\n    <ClCompile Include=\"..\\common\\shutdown_state.c\" />\n    <ClCompile Include=\"..\\core\\util.c\" />\n    <ClCompile Include=\"..\\core\\util_windows.c\" />\n    <ClCompile Include=\"..\\common\\uuid.c\" />\n    <ClCompile Include=\"..\\common\\uuid_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\auto_flush_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\badblocks.c\" />\n    <ClCompile Include=\"..\\libpmem2\\badblocks_none.c\" />\n    <ClCompile Include=\"..\\libpmem2\\usc_windows.c\" />\n    <ClCompile Include=\"..\\libpmemblk\\btt.c\" />\n    <ClCompile Include=\"check.c\" />\n    <ClCompile Include=\"check_bad_blocks.c\" />\n    <ClCompile Include=\"check_backup.c\" />\n    <ClCompile Include=\"check_blk.c\" />\n    <ClCompile Include=\"check_btt_info.c\" />\n    <ClCompile Include=\"check_btt_map_flog.c\" />\n    <ClCompile Include=\"check_log.c\" />\n    <ClCompile Include=\"check_pool_hdr.c\" />\n    <ClCompile Include=\"check_sds.c\" />\n    <ClCompile Include=\"check_util.c\" />\n    <ClCompile Include=\"check_write.c\" />\n    <ClCompile Include=\"feature.c\" />\n    <ClCompile Include=\"libpmempool.c\" />\n    <ClCompile Include=\"libpmempool_main.c\" />\n    <ClCompile Include=\"pool.c\" />\n    <ClCompile Include=\"replica.c\" />\n    <ClCompile Include=\"rm.c\" />\n    <ClCompile Include=\"sync.c\" />\n    <ClCompile Include=\"transform.c\" />\n    <ClCompile Include=\"..\\libpmem2\\config.c\" />\n    <ClCompile Include=\"..\\libpmem2\\source.c\" />\n    <ClCompile Include=\"..\\libpmem2\\source_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils.c\" />\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils_other.c\" />\n  </ItemGroup>\n  <ItemGroup>\n    <None Include=\"libpmempool.def\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ProjectReference Include=\"..\\libpmemblk\\libpmemblk.vcxproj\">\n      <Project>{f7c6c6b6-4142-4c82-8699-4a9d8183181b}</Project>\n    </ProjectReference>\n    <ProjectReference Include=\"..\\libpmemlog\\libpmemlog.vcxproj\">\n      <Project>{0b1818eb-bdc8-4865-964f-db8bf05cfd86}</Project>\n    </ProjectReference>\n    <ProjectReference Include=\"..\\libpmemobj\\libpmemobj.vcxproj\">\n      <Project>{1baa1617-93ae-4196-8a1a-bd492fb18aef}</Project>\n    </ProjectReference>\n    <ProjectReference Include=\"..\\libpmem\\libpmem.vcxproj\">\n      <Project>{9e9e3d25-2139-4a5d-9200-18148ddead45}</Project>\n    </ProjectReference>\n    <ProjectReference Include=\"..\\windows\\srcversion\\srcversion.vcxproj\">\n      <Project>{901f04db-e1a5-4a41-8b81-9d31c19acd59}</Project>\n    </ProjectReference>\n  </ItemGroup>\n  <ItemGroup>\n    <ResourceCompile Include=\"libpmempool.rc\" />\n  </ItemGroup>\n  <PropertyGroup Label=\"Globals\">\n    <ProjectGuid>{CF9A0883-6334-44C7-AC29-349468C78E27}</ProjectGuid>\n    <Keyword>DynamicLibrary</Keyword>\n    <ProjectName>libpmempool</ProjectName>\n    <RootNamespace>libpmempool</RootNamespace>\n    <DefaultLanguage>en-US</DefaultLanguage>\n    <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>\n    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>\n    <WindowsTargetPlatformMinVersion>10.0.10240.0</WindowsTargetPlatformMinVersion>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\n    <UseDebugLibraries>true</UseDebugLibraries>\n    <PlatformToolset>v140</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\n    <UseDebugLibraries>false</UseDebugLibraries>\n    <WholeProgramOptimization>false</WholeProgramOptimization>\n    <PlatformToolset>v140</PlatformToolset>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n    <Import Project=\"..\\windows\\libs_debug.props\" />\n  </ImportGroup>\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n    <Import Project=\"..\\windows\\libs_release.props\" />\n  </ImportGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" />\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <ClCompile>\n      <AdditionalIncludeDirectories>$(SolutionDir)\\libpmemobj;$(SolutionDir)\\libpmemblk;$(SolutionDir)\\libpmemlog;$(SolutionDir)\\libpmem2;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ClCompile>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <ClCompile>\n      <AdditionalIncludeDirectories>$(SolutionDir)\\libpmemobj;$(SolutionDir)\\libpmemblk;$(SolutionDir)\\libpmemlog;$(SolutionDir)\\libpmem2;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ClCompile>\n  </ItemDefinitionGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n  <ImportGroup Label=\"ExtensionTargets\">\n  </ImportGroup>\n</Project>",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/libpmempool/libpmempool.vcxproj.filters": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup>\n    <ClCompile Include=\"..\\libpmemblk\\btt.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"check.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"check_bad_blocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"check_backup.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"check_btt_info.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"check_btt_map_flog.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"check_pool_hdr.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"check_sds.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"check_util.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"check_write.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\file.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\file_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"libpmempool.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"libpmempool_main.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\mmap.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\mmap_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\fs_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\out.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"pool.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\os_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\pool_hdr.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"sync.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\set.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"rm.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"replica.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\uuid.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\util_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\util.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"transform.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\uuid_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\os_thread_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"check_blk.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"check_log.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"feature.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\shutdown_state.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\os_deep_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\set_badblocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\bad_blocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\alloc.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\auto_flush_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\config.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\badblocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\badblocks_none.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\source.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\source_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils_other.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\usc_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"..\\common\\mmap.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\out.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\pmemcommon.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"pmempool.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"pool.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\pool_hdr.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"replica.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\set.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"check.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"check_util.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\dlsym.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\file.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\sys_util.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\util.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\uuid.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\valgrind_internal.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmempool.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmemblk\\btt.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\fs.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\os.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\os_deep.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\alloc.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\fault_injection.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\auto_flush.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\auto_flush_windows.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\config.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\badblocks.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\pmem2_utils.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n  </ItemGroup>\n  <ItemGroup>\n    <Filter Include=\"Source Files\">\n      <UniqueIdentifier>{cd079c79-5441-413e-b2ba-99fed2b0b779}</UniqueIdentifier>\n    </Filter>\n    <Filter Include=\"Header Files\">\n      <UniqueIdentifier>{9ad93d4f-a9d1-4e38-94a1-77e36acc268f}</UniqueIdentifier>\n    </Filter>\n  </ItemGroup>\n  <ItemGroup>\n    <None Include=\"libpmempool.def\">\n      <Filter>Source Files</Filter>\n    </None>\n  </ItemGroup>\n  <ItemGroup>\n    <ResourceCompile Include=\"libpmempool.rc\">\n      <Filter>Source Files</Filter>\n    </ResourceCompile>\n  </ItemGroup>\n</Project>",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/libpmemblk/libpmemblk.vcxproj": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" ToolsVersion=\"14.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup Label=\"ProjectConfigurations\">\n    <ProjectConfiguration Include=\"Debug|x64\">\n      <Configuration>Debug</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Release|x64\">\n      <Configuration>Release</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n  </ItemGroup>\n  <ItemGroup>\n    <ClCompile Include=\"..\\..\\src\\libpmemblk\\blk.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemblk\\btt.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemblk\\libpmemblk.c\" />\n    <ClCompile Include=\"..\\core\\alloc.c\" />\n    <ClCompile Include=\"..\\common\\set_badblocks.c\" />\n    <ClCompile Include=\"..\\common\\ctl.c\" />\n    <ClCompile Include=\"..\\common\\ctl_cow.c\" />\n    <ClCompile Include=\"..\\common\\ctl_prefault.c\" />\n    <ClCompile Include=\"..\\common\\ctl_sds.c\" />\n    <ClCompile Include=\"..\\common\\ctl_fallocate.c\" />\n    <ClCompile Include=\"..\\common\\file.c\" />\n    <ClCompile Include=\"..\\common\\file_windows.c\" />\n    <ClCompile Include=\"..\\common\\mmap.c\" />\n    <ClCompile Include=\"..\\common\\mmap_windows.c\" />\n    <ClCompile Include=\"..\\core\\fs_windows.c\" />\n    <ClCompile Include=\"..\\common\\bad_blocks.c\" />\n    <ClCompile Include=\"..\\common\\os_deep_windows.c\" />\n    <ClCompile Include=\"..\\core\\os_thread_windows.c\" />\n    <ClCompile Include=\"..\\core\\os_windows.c\" />\n    <ClCompile Include=\"..\\core\\out.c\" />\n    <ClCompile Include=\"..\\common\\pool_hdr.c\" />\n    <ClCompile Include=\"..\\common\\set.c\" />\n    <ClCompile Include=\"..\\common\\shutdown_state.c\" />\n    <ClCompile Include=\"..\\core\\util.c\" />\n    <ClCompile Include=\"..\\core\\util_windows.c\" />\n    <ClCompile Include=\"..\\common\\uuid.c\" />\n    <ClCompile Include=\"..\\common\\uuid_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\auto_flush_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\usc_windows.c\" />\n    <ClCompile Include=\"libpmemblk_main.c\" />\n    <ClCompile Include=\"..\\libpmem2\\config.c\" />\n    <ClCompile Include=\"..\\libpmem2\\badblocks.c\" />\n    <ClCompile Include=\"..\\libpmem2\\badblocks_none.c\" />\n    <ClCompile Include=\"..\\libpmem2\\source.c\" />\n    <ClCompile Include=\"..\\libpmem2\\source_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils.c\" />\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils_other.c\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"..\\..\\src\\core\\out.h\" />\n    <ClInclude Include=\"..\\..\\src\\core\\util.h\" />\n    <ClInclude Include=\"..\\..\\src\\common\\valgrind_internal.h\" />\n    <ClInclude Include=\"..\\..\\src\\include\\libpmemblk.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemblk\\blk.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemblk\\btt.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemblk\\btt_layout.h\" />\n    <ClInclude Include=\"..\\core\\alloc.h\" />\n    <ClInclude Include=\"..\\common\\ctl.h\" />\n    <ClInclude Include=\"..\\common\\ctl_global.h\" />\n    <ClInclude Include=\"..\\common\\dlsym.h\" />\n    <ClInclude Include=\"..\\core\\fault_injection.h\" />\n    <ClInclude Include=\"..\\common\\file.h\" />\n    <ClInclude Include=\"..\\core\\fs.h\" />\n    <ClInclude Include=\"..\\common\\mmap.h\" />\n    <ClInclude Include=\"..\\core\\os.h\" />\n    <ClInclude Include=\"..\\common\\os_deep.h\" />\n    <ClInclude Include=\"..\\core\\os_thread.h\" />\n    <ClInclude Include=\"..\\common\\pmemcommon.h\" />\n    <ClInclude Include=\"..\\common\\pool_hdr.h\" />\n    <ClInclude Include=\"..\\common\\set.h\" />\n    <ClInclude Include=\"..\\common\\sys_util.h\" />\n    <ClInclude Include=\"..\\common\\uuid.h\" />\n    <ClInclude Include=\"..\\libpmem2\\auto_flush.h\" />\n    <ClInclude Include=\"..\\libpmem2\\auto_flush_windows.h\" />\n    <ClInclude Include=\"..\\libpmem2\\config.h\" />\n    <ClInclude Include=\"..\\libpmem2\\pmem2_utils.h\" />\n  </ItemGroup>\n  <ItemGroup>\n    <None Include=\"libpmemblk.def\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ProjectReference Include=\"..\\libpmem\\libpmem.vcxproj\">\n      <Project>{9e9e3d25-2139-4a5d-9200-18148ddead45}</Project>\n    </ProjectReference>\n    <ProjectReference Include=\"..\\windows\\srcversion\\srcversion.vcxproj\">\n      <Project>{901f04db-e1a5-4a41-8b81-9d31c19acd59}</Project>\n    </ProjectReference>\n  </ItemGroup>\n  <ItemGroup>\n    <ResourceCompile Include=\"libpmemblk.rc\" />\n  </ItemGroup>\n  <PropertyGroup Label=\"Globals\">\n    <ProjectGuid>{f7c6c6b6-4142-4c82-8699-4a9d8183181b}</ProjectGuid>\n    <Keyword>DynamicLibrary</Keyword>\n    <ProjectName>libpmemblk</ProjectName>\n    <RootNamespace>libpmemblk</RootNamespace>\n    <DefaultLanguage>en-US</DefaultLanguage>\n    <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>\n    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>\n    <WindowsTargetPlatformMinVersion>10.0.10240.0</WindowsTargetPlatformMinVersion>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\n    <UseDebugLibraries>true</UseDebugLibraries>\n    <PlatformToolset>v140</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\n    <UseDebugLibraries>false</UseDebugLibraries>\n    <WholeProgramOptimization>false</WholeProgramOptimization>\n    <PlatformToolset>v140</PlatformToolset>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n    <Import Project=\"..\\windows\\libs_debug.props\" />\n  </ImportGroup>\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n    <Import Project=\"..\\windows\\libs_release.props\" />\n  </ImportGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" />\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" />\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" />\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n  <ImportGroup Label=\"ExtensionTargets\">\n  </ImportGroup>\n</Project>",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/libpmemblk/libpmemblk.vcxproj.filters": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"14.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup>\n    <Filter Include=\"Header Files\">\n      <UniqueIdentifier>{5f4b56cf-a674-4f35-abfa-d867d9d91f68}</UniqueIdentifier>\n    </Filter>\n    <Filter Include=\"Source Files\">\n      <UniqueIdentifier>{dee0ff57-9af8-485a-888b-0087d6e11cf8}</UniqueIdentifier>\n    </Filter>\n  </ItemGroup>\n  <ItemGroup>\n    <ClCompile Include=\"..\\..\\src\\libpmemblk\\blk.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemblk\\btt.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemblk\\libpmemblk.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"libpmemblk_main.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\uuid_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\uuid.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\util_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\util.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\set.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\pool_hdr.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\out.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\mmap_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\fs_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\mmap.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\file_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\file.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\os_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\os_thread_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\shutdown_state.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\os_deep_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\set_badblocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\bad_blocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ctl.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ctl_prefault.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ctl_fallocate.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ctl_sds.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\alloc.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ctl_cow.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\auto_flush_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\config.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\badblocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\badblocks_none.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\source.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\source_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils_other.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\usc_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"..\\..\\src\\include\\libpmemblk.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemblk\\blk.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemblk\\btt.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemblk\\btt_layout.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\core\\out.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\core\\util.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\common\\valgrind_internal.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\uuid.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\sys_util.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\set.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\pool_hdr.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\pmemcommon.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\mmap.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\file.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\dlsym.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\fs.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\os.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\os_thread.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\os_deep.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\ctl_global.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\ctl.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\alloc.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\fault_injection.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\auto_flush.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\auto_flush_windows.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\config.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\pmem2_utils.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n  </ItemGroup>\n  <ItemGroup>\n    <None Include=\"libpmemblk.def\">\n      <Filter>Source Files</Filter>\n    </None>\n  </ItemGroup>\n  <ItemGroup>\n    <ResourceCompile Include=\"libpmemblk.rc\">\n      <Filter>Source Files</Filter>\n    </ResourceCompile>\n  </ItemGroup>\n</Project>",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/libpmem/libpmem.vcxproj.filters": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"14.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup>\n    <Filter Include=\"Header Files\">\n      <UniqueIdentifier>{16473205-8f12-4d4c-b1e9-e14ea3013e70}</UniqueIdentifier>\n      <Extensions>h</Extensions>\n    </Filter>\n    <Filter Include=\"Source Files\">\n      <UniqueIdentifier>{17275273-f923-45ff-9b7e-b2ea76561168}</UniqueIdentifier>\n      <Extensions>c;def</Extensions>\n    </Filter>\n  </ItemGroup>\n  <ItemGroup>\n    <ClCompile Include=\"..\\..\\src\\libpmem\\libpmem.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem\\libpmem_main.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmem\\pmem.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\cpu.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\init.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\windows\\win_mmap.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"pmem_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\file.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\file_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\mmap.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\mmap_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\fs_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\out.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\pool_hdr.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\util.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\util_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\uuid_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\os_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\os_thread_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\os_deep_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memcpy\\memcpy_nt_sse2.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memcpy\\memcpy_nt_avx.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memcpy\\memcpy_t_sse2.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memcpy\\memcpy_t_avx.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memset\\memset_nt_sse2.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memset\\memset_nt_avx.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memset\\memset_t_sse2.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memset\\memset_t_avx.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\memops_generic.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\alloc.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\config.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\badblocks_none.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\source.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\source_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils_other.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\auto_flush_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"..\\..\\src\\core\\out.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmem\\pmem.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\core\\util.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\common\\valgrind_internal.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\include\\libpmem.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\file.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\windows\\include\\win_mmap.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\dlsym.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\mmap.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\pool_hdr.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\set.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\sys_util.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\uuid.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\fs.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\os.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\os_deep.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\os_thread.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\memcpy\\memcpy_avx512f.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\memset\\memset_avx512f.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\memset\\memset_avx.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\memset\\memset_sse2.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\memcpy\\memcpy_avx.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\memcpy\\memcpy_sse2.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\avx.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\flush.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\memcpy_memset.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\alloc.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\fault_injection.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\config.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\pmem2_utils.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\auto_flush.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\auto_flush_windows.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\pmem2_arch.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\cpu.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\source.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n  </ItemGroup>\n  <ItemGroup>\n    <None Include=\"libpmem.def\">\n      <Filter>Source Files</Filter>\n    </None>\n  </ItemGroup>\n  <ItemGroup>\n    <ResourceCompile Include=\"libpmem.rc\">\n      <Filter>Source Files</Filter>\n    </ResourceCompile>\n  </ItemGroup>\n</Project>",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/libpmem/libpmem.vcxproj": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" ToolsVersion=\"14.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup Label=\"ProjectConfigurations\">\n    <ProjectConfiguration Include=\"Debug|x64\">\n      <Configuration>Debug</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Release|x64\">\n      <Configuration>Release</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n  </ItemGroup>\n  <ItemGroup>\n    <ClCompile Include=\"..\\..\\src\\libpmem\\libpmem.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmem\\pmem.c\" />\n    <ClCompile Include=\"..\\core\\alloc.c\" />\n    <ClCompile Include=\"..\\common\\file.c\" />\n    <ClCompile Include=\"..\\common\\file_windows.c\" />\n    <ClCompile Include=\"..\\common\\mmap.c\" />\n    <ClCompile Include=\"..\\common\\mmap_windows.c\" />\n    <ClCompile Include=\"..\\core\\fs_windows.c\" />\n    <ClCompile Include=\"..\\common\\os_deep_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\badblocks_none.c\" />\n    <ClCompile Include=\"..\\core\\os_thread_windows.c\" />\n    <ClCompile Include=\"..\\core\\os_windows.c\" />\n    <ClCompile Include=\"..\\core\\out.c\" />\n    <ClCompile Include=\"..\\common\\pool_hdr.c\" />\n    <ClCompile Include=\"..\\core\\util.c\" />\n    <ClCompile Include=\"..\\core\\util_windows.c\" />\n    <ClCompile Include=\"..\\common\\uuid_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\auto_flush_windows.c\" />\n    <ClCompile Include=\"..\\libpmem\\libpmem_main.c\" />\n    <ClCompile Include=\"..\\windows\\win_mmap.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\cpu.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\init.c\" />\n    <ClCompile Include=\"pmem_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\memops_generic.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memcpy\\memcpy_nt_sse2.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memcpy\\memcpy_nt_avx.c\">\n      <EnableEnhancedInstructionSet Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">AdvancedVectorExtensions</EnableEnhancedInstructionSet>\n      <EnableEnhancedInstructionSet Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">AdvancedVectorExtensions</EnableEnhancedInstructionSet>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memcpy\\memcpy_t_sse2.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memcpy\\memcpy_t_avx.c\">\n      <EnableEnhancedInstructionSet Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">AdvancedVectorExtensions</EnableEnhancedInstructionSet>\n      <EnableEnhancedInstructionSet Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">AdvancedVectorExtensions</EnableEnhancedInstructionSet>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memset\\memset_nt_sse2.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memset\\memset_nt_avx.c\">\n      <EnableEnhancedInstructionSet Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">AdvancedVectorExtensions</EnableEnhancedInstructionSet>\n      <EnableEnhancedInstructionSet Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">AdvancedVectorExtensions</EnableEnhancedInstructionSet>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memset\\memset_t_sse2.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmem2\\x86_64\\memset\\memset_t_avx.c\">\n      <EnableEnhancedInstructionSet Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">AdvancedVectorExtensions</EnableEnhancedInstructionSet>\n      <EnableEnhancedInstructionSet Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">AdvancedVectorExtensions</EnableEnhancedInstructionSet>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\config.c\" />\n    <ClCompile Include=\"..\\libpmem2\\source.c\" />\n    <ClCompile Include=\"..\\libpmem2\\source_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils.c\" />\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils_other.c\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"..\\..\\src\\core\\out.h\" />\n    <ClInclude Include=\"..\\..\\src\\core\\util.h\" />\n    <ClInclude Include=\"..\\..\\src\\common\\valgrind_internal.h\" />\n    <ClInclude Include=\"..\\..\\src\\include\\libpmem.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmem\\pmem.h\" />\n    <ClInclude Include=\"..\\core\\alloc.h\" />\n    <ClInclude Include=\"..\\common\\dlsym.h\" />\n    <ClInclude Include=\"..\\core\\fault_injection.h\" />\n    <ClInclude Include=\"..\\common\\file.h\" />\n    <ClInclude Include=\"..\\core\\fs.h\" />\n    <ClInclude Include=\"..\\common\\mmap.h\" />\n    <ClInclude Include=\"..\\core\\os.h\" />\n    <ClInclude Include=\"..\\common\\os_deep.h\" />\n    <ClInclude Include=\"..\\core\\os_thread.h\" />\n    <ClInclude Include=\"..\\common\\pool_hdr.h\" />\n    <ClInclude Include=\"..\\common\\set.h\" />\n    <ClInclude Include=\"..\\common\\sys_util.h\" />\n    <ClInclude Include=\"..\\common\\uuid.h\" />\n    <ClInclude Include=\"..\\libpmem2\\auto_flush.h\" />\n    <ClInclude Include=\"..\\libpmem2\\auto_flush_windows.h\" />\n    <ClInclude Include=\"..\\libpmem2\\pmem2_arch.h\" />\n    <ClInclude Include=\"..\\windows\\include\\win_mmap.h\" />\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\cpu.h\" />\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\avx.h\" />\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\flush.h\" />\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\memcpy\\memcpy_avx.h\" />\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\memcpy\\memcpy_avx512f.h\" />\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\memcpy\\memcpy_sse2.h\" />\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\memcpy_memset.h\" />\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\memset\\memset_avx.h\" />\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\memset\\memset_avx512f.h\" />\n    <ClInclude Include=\"..\\libpmem2\\x86_64\\memset\\memset_sse2.h\" />\n    <ClInclude Include=\"..\\libpmem2\\config.h\" />\n    <ClInclude Include=\"..\\libpmem2\\source.h\" />\n    <ClInclude Include=\"..\\libpmem2\\pmem2_utils.h\" />\n  </ItemGroup>\n  <ItemGroup>\n    <None Include=\"libpmem.def\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ProjectReference Include=\"..\\windows\\srcversion\\srcversion.vcxproj\">\n      <Project>{901f04db-e1a5-4a41-8b81-9d31c19acd59}</Project>\n    </ProjectReference>\n  </ItemGroup>\n  <ItemGroup>\n    <ResourceCompile Include=\"libpmem.rc\" />\n  </ItemGroup>\n  <PropertyGroup Label=\"Globals\">\n    <ProjectGuid>{9e9e3d25-2139-4a5d-9200-18148ddead45}</ProjectGuid>\n    <Keyword>DynamicLibrary</Keyword>\n    <ProjectName>libpmem</ProjectName>\n    <RootNamespace>libpmem</RootNamespace>\n    <DefaultLanguage>en-US</DefaultLanguage>\n    <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>\n    <WindowsTargetPlatformMinVersion>10.0.10240.0</WindowsTargetPlatformMinVersion>\n    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\n    <UseDebugLibraries>true</UseDebugLibraries>\n    <PlatformToolset>v140</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\n    <UseDebugLibraries>false</UseDebugLibraries>\n    <WholeProgramOptimization>false</WholeProgramOptimization>\n    <PlatformToolset>v140</PlatformToolset>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n    <Import Project=\"..\\windows\\libs_debug.props\" />\n  </ImportGroup>\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n    <Import Project=\"..\\windows\\libs_release.props\" />\n  </ImportGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);..\\..\\src\\libpmem2\\x86_64\\</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);..\\..\\src\\libpmem2\\x86_64\\</IncludePath>\n  </PropertyGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <ClCompile>\n      <AdditionalIncludeDirectories>$(SolutionDir)libpmem2;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ClCompile>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <ClCompile>\n      <AdditionalIncludeDirectories>$(SolutionDir)libpmem2;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ClCompile>\n  </ItemDefinitionGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n  <ImportGroup Label=\"ExtensionTargets\">\n  </ImportGroup>\n</Project>",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/test/pmem_map_file/mocks_posix.c": "// SPDX-License-Identifier: BSD-3-Clause\n/* Copyright 2015-2018, Intel Corporation */\n\n/*\n * mocks_posix.c -- mocked functions used in pmem_map_file.c (Posix-specific)\n */\n\n#define _GNU_SOURCE\n#include \"unittest.h\"\n#include <dlfcn.h>\n\n#define MAX_LEN (4 * 1024 * 1024)\n\n/*\n * posix_fallocate -- interpose on libc posix_fallocate()\n */\nint\nposix_fallocate(int fd, os_off_t offset, off_t len)\n{\n\tUT_OUT(\"posix_fallocate: off %ju len %ju\", offset, len);\n\n\tstatic int (*posix_fallocate_ptr)(int fd, os_off_t offset, off_t len);\n\n\tif (posix_fallocate_ptr == NULL)\n\t\tposix_fallocate_ptr = dlsym(RTLD_NEXT, \"posix_fallocate\");\n\n\tif (len > MAX_LEN)\n\t\treturn ENOSPC;\n\n\treturn (*posix_fallocate_ptr)(fd, offset, len);\n}\n\n/*\n * ftruncate -- interpose on libc ftruncate()\n */\nint\nftruncate(int fd, os_off_t len)\n{\n\tUT_OUT(\"ftruncate: len %ju\", len);\n\n\tstatic int (*ftruncate_ptr)(int fd, os_off_t len);\n\n\tif (ftruncate_ptr == NULL)\n\t\tftruncate_ptr = dlsym(RTLD_NEXT, \"ftruncate\");\n\n\tif (len > MAX_LEN) {\n\t\terrno = ENOSPC;\n\t\treturn -1;\n\t}\n\n\treturn (*ftruncate_ptr)(fd, len);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/libpmemlog/libpmemlog.vcxproj.filters": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup>\n    <ClCompile Include=\"..\\..\\src\\libpmemlog\\libpmemlog.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"libpmemlog_main.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemlog\\log.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\uuid_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\uuid.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\util_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\util.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\set.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\pool_hdr.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\out.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\mmap_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\fs_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\mmap.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\file_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\file.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\os_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\os_thread_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\shutdown_state.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\os_deep_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\set_badblocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\bad_blocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ctl.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ctl_prefault.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ctl_sds.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\alloc.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ctl_fallocate.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ctl_cow.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\auto_flush_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\config.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\badblocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\badblocks_none.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\source.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\source_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils_other.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\usc_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"..\\..\\src\\include\\libpmemlog.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\core\\util.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\core\\out.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemlog\\log.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\common\\valgrind_internal.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\uuid.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\sys_util.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\set.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\pool_hdr.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\pmemcommon.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\mmap.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\file.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\dlsym.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\fs.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\os.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\os_thread.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\os_deep.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\ctl.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\ctl_global.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\alloc.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\fault_injection.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\auto_flush.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\auto_flush_windows.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\config.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\pmem2_utils.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n  </ItemGroup>\n  <ItemGroup>\n    <Filter Include=\"Source Files\">\n      <UniqueIdentifier>{49cfa2b4-cfcb-4c02-928a-c04d1cceffb8}</UniqueIdentifier>\n    </Filter>\n    <Filter Include=\"Header Files\">\n      <UniqueIdentifier>{ac09c2fe-a24b-4a86-8763-d4e06d996ef3}</UniqueIdentifier>\n    </Filter>\n  </ItemGroup>\n  <ItemGroup>\n    <None Include=\"libpmemlog.def\">\n      <Filter>Source Files</Filter>\n    </None>\n  </ItemGroup>\n  <ItemGroup>\n    <ResourceCompile Include=\"libpmemlog.rc\">\n      <Filter>Source Files</Filter>\n    </ResourceCompile>\n  </ItemGroup>\n</Project>",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/libpmemlog/libpmemlog.vcxproj": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" ToolsVersion=\"14.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup Label=\"ProjectConfigurations\">\n    <ProjectConfiguration Include=\"Debug|x64\">\n      <Configuration>Debug</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Release|x64\">\n      <Configuration>Release</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n  </ItemGroup>\n  <ItemGroup>\n    <ClCompile Include=\"..\\..\\src\\libpmemlog\\log.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemlog\\libpmemlog.c\" />\n    <ClCompile Include=\"..\\core\\alloc.c\" />\n    <ClCompile Include=\"..\\common\\set_badblocks.c\" />\n    <ClCompile Include=\"..\\common\\ctl.c\" />\n    <ClCompile Include=\"..\\common\\ctl_cow.c\" />\n    <ClCompile Include=\"..\\common\\ctl_prefault.c\" />\n    <ClCompile Include=\"..\\common\\ctl_sds.c\" />\n    <ClCompile Include=\"..\\common\\ctl_fallocate.c\" />\n    <ClCompile Include=\"..\\common\\file.c\" />\n    <ClCompile Include=\"..\\common\\file_windows.c\" />\n    <ClCompile Include=\"..\\common\\mmap.c\" />\n    <ClCompile Include=\"..\\common\\mmap_windows.c\" />\n    <ClCompile Include=\"..\\core\\fs_windows.c\" />\n    <ClCompile Include=\"..\\common\\bad_blocks.c\" />\n    <ClCompile Include=\"..\\common\\os_deep_windows.c\" />\n    <ClCompile Include=\"..\\core\\os_thread_windows.c\" />\n    <ClCompile Include=\"..\\core\\os_windows.c\" />\n    <ClCompile Include=\"..\\core\\out.c\" />\n    <ClCompile Include=\"..\\common\\pool_hdr.c\" />\n    <ClCompile Include=\"..\\common\\set.c\" />\n    <ClCompile Include=\"..\\common\\shutdown_state.c\" />\n    <ClCompile Include=\"..\\core\\util.c\" />\n    <ClCompile Include=\"..\\core\\util_windows.c\" />\n    <ClCompile Include=\"..\\common\\uuid.c\" />\n    <ClCompile Include=\"..\\common\\uuid_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\auto_flush_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\badblocks.c\" />\n    <ClCompile Include=\"..\\libpmem2\\badblocks_none.c\" />\n    <ClCompile Include=\"..\\libpmem2\\usc_windows.c\" />\n    <ClCompile Include=\"libpmemlog_main.c\" />\n    <ClCompile Include=\"..\\libpmem2\\config.c\" />\n    <ClCompile Include=\"..\\libpmem2\\source.c\" />\n    <ClCompile Include=\"..\\libpmem2\\source_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils.c\" />\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils_other.c\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"..\\..\\src\\core\\out.h\" />\n    <ClInclude Include=\"..\\..\\src\\core\\util.h\" />\n    <ClInclude Include=\"..\\..\\src\\common\\valgrind_internal.h\" />\n    <ClInclude Include=\"..\\..\\src\\include\\libpmemlog.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemlog\\log.h\" />\n    <ClInclude Include=\"..\\core\\alloc.h\" />\n    <ClInclude Include=\"..\\common\\ctl.h\" />\n    <ClInclude Include=\"..\\common\\ctl_global.h\" />\n    <ClInclude Include=\"..\\common\\dlsym.h\" />\n    <ClInclude Include=\"..\\core\\fault_injection.h\" />\n    <ClInclude Include=\"..\\common\\file.h\" />\n    <ClInclude Include=\"..\\core\\fs.h\" />\n    <ClInclude Include=\"..\\common\\mmap.h\" />\n    <ClInclude Include=\"..\\core\\os.h\" />\n    <ClInclude Include=\"..\\common\\os_deep.h\" />\n    <ClInclude Include=\"..\\core\\os_thread.h\" />\n    <ClInclude Include=\"..\\common\\pmemcommon.h\" />\n    <ClInclude Include=\"..\\common\\pool_hdr.h\" />\n    <ClInclude Include=\"..\\common\\set.h\" />\n    <ClInclude Include=\"..\\common\\sys_util.h\" />\n    <ClInclude Include=\"..\\common\\uuid.h\" />\n    <ClInclude Include=\"..\\libpmem2\\auto_flush.h\" />\n    <ClInclude Include=\"..\\libpmem2\\auto_flush_windows.h\" />\n    <ClInclude Include=\"..\\libpmem2\\config.h\" />\n    <ClInclude Include=\"..\\libpmem2\\pmem2_utils.h\" />\n  </ItemGroup>\n  <ItemGroup>\n    <None Include=\"libpmemlog.def\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ProjectReference Include=\"..\\libpmem\\libpmem.vcxproj\">\n      <Project>{9e9e3d25-2139-4a5d-9200-18148ddead45}</Project>\n    </ProjectReference>\n    <ProjectReference Include=\"..\\windows\\srcversion\\srcversion.vcxproj\">\n      <Project>{901f04db-e1a5-4a41-8b81-9d31c19acd59}</Project>\n    </ProjectReference>\n  </ItemGroup>\n  <ItemGroup>\n    <ResourceCompile Include=\"libpmemlog.rc\" />\n  </ItemGroup>\n  <PropertyGroup Label=\"Globals\">\n    <ProjectGuid>{0B1818EB-BDC8-4865-964F-DB8BF05CFD86}</ProjectGuid>\n    <Keyword>DynamicLibrary</Keyword>\n    <ProjectName>libpmemlog</ProjectName>\n    <RootNamespace>libpmemlog</RootNamespace>\n    <DefaultLanguage>en-US</DefaultLanguage>\n    <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>\n    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>\n    <WindowsTargetPlatformMinVersion>10.0.10240.0</WindowsTargetPlatformMinVersion>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\n    <UseDebugLibraries>true</UseDebugLibraries>\n    <PlatformToolset>v140</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\n    <UseDebugLibraries>false</UseDebugLibraries>\n    <WholeProgramOptimization>false</WholeProgramOptimization>\n    <PlatformToolset>v140</PlatformToolset>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n    <Import Project=\"..\\windows\\libs_debug.props\" />\n  </ImportGroup>\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n    <Import Project=\"..\\windows\\libs_release.props\" />\n  </ImportGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" />\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" />\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" />\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n  <ImportGroup Label=\"ExtensionTargets\">\n  </ImportGroup>\n</Project>",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/libpmemobj/libpmemobj.vcxproj.filters": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup>\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\bucket.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\critnib.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\ctl_debug.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\heap.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\lane.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\libpmemobj.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\list.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\memops.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\obj.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\palloc.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\pmalloc.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\ulog.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\sync.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\tx.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\set_badblocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\bad_blocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ctl.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\file.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\file_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\fs_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\mmap.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\mmap_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\os_deep_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\os_thread_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\os_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\out.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\pool_hdr.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\set.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\shutdown_state.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\util.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\util_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\uuid.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\uuid_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"alloc_class.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"container_ravl.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"container_seglists.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"libpmemobj_main.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"memblock.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"recycler.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"stats.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ctl_prefault.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ctl_sds.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\core\\alloc.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ctl_fallocate.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ctl_cow.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\config.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\badblocks.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\badblocks_none.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\source.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\source_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils_other.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\auto_flush_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\common\\ravl.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"..\\libpmem2\\usc_windows.c\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"..\\..\\src\\core\\out.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\core\\util.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\common\\valgrind_internal.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\include\\libpmemobj.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\bucket.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\critnib.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\ctl_debug.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\heap.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\heap_layout.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\lane.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\list.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\memops.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\obj.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\palloc.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\pmalloc.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\pmemops.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\redo.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\ctl.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\ctl_global.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\dlsym.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\file.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\fs.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\mmap.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\os.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\os_deep.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\os_thread.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\pmemcommon.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\pool_hdr.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\queue.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\set.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\sys_util.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\uuid.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmemobj\\action.h\">\n      <Filter>Header Files\\libpmemobj</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmemobj\\action_base.h\">\n      <Filter>Header Files\\libpmemobj</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmemobj\\atomic.h\">\n      <Filter>Header Files\\libpmemobj</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmemobj\\atomic_base.h\">\n      <Filter>Header Files\\libpmemobj</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmemobj\\base.h\">\n      <Filter>Header Files\\libpmemobj</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmemobj\\iterator.h\">\n      <Filter>Header Files\\libpmemobj</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmemobj\\iterator_base.h\">\n      <Filter>Header Files\\libpmemobj</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmemobj\\lists_atomic.h\">\n      <Filter>Header Files\\libpmemobj</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmemobj\\lists_atomic_base.h\">\n      <Filter>Header Files\\libpmemobj</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmemobj\\pool.h\">\n      <Filter>Header Files\\libpmemobj</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmemobj\\pool_base.h\">\n      <Filter>Header Files\\libpmemobj</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmemobj\\thread.h\">\n      <Filter>Header Files\\libpmemobj</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmemobj\\tx.h\">\n      <Filter>Header Files\\libpmemobj</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmemobj\\tx_base.h\">\n      <Filter>Header Files\\libpmemobj</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\include\\libpmemobj\\types.h\">\n      <Filter>Header Files\\libpmemobj</Filter>\n    </ClInclude>\n    <ClInclude Include=\"alloc_class.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"container.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"container_ravl.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"container_seglists.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"memblock.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"recycler.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"stats.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"sync.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"tx.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\alloc.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\core\\fault_injection.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\config.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\pmem2_utils.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\auto_flush.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\libpmem2\\auto_flush_windows.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"..\\common\\ravl.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n  </ItemGroup>\n  <ItemGroup>\n    <Filter Include=\"Header Files\">\n      <UniqueIdentifier>{73806be6-053a-4dfd-92de-956b0480b5d9}</UniqueIdentifier>\n      <Extensions>h</Extensions>\n    </Filter>\n    <Filter Include=\"Source Files\">\n      <UniqueIdentifier>{60288a68-9214-4faa-b5c4-bf33b1020120}</UniqueIdentifier>\n      <Extensions>c;def</Extensions>\n    </Filter>\n    <Filter Include=\"Header Files\\libpmemobj\">\n      <UniqueIdentifier>{ab47d7d2-14e7-4ab2-af19-e7cf10e43fbf}</UniqueIdentifier>\n    </Filter>\n  </ItemGroup>\n  <ItemGroup>\n    <None Include=\"libpmemobj.def\">\n      <Filter>Source Files</Filter>\n    </None>\n  </ItemGroup>\n  <ItemGroup>\n    <ResourceCompile Include=\"libpmemobj.rc\">\n      <Filter>Source Files</Filter>\n    </ResourceCompile>\n  </ItemGroup>\n</Project>",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/libpmemobj/libpmemobj.vcxproj": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" ToolsVersion=\"14.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup Label=\"ProjectConfigurations\">\n    <ProjectConfiguration Include=\"Debug|x64\">\n      <Configuration>Debug</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Release|x64\">\n      <Configuration>Release</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n  </ItemGroup>\n  <ItemGroup>\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\bucket.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\critnib.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\ctl_debug.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\heap.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\lane.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\libpmemobj.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\list.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\memops.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\obj.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\palloc.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\pmalloc.c\" />\n    <ClCompile Include=\"..\\common\\ravl.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\ulog.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\sync.c\" />\n    <ClCompile Include=\"..\\..\\src\\libpmemobj\\tx.c\" />\n    <ClCompile Include=\"..\\core\\alloc.c\" />\n    <ClCompile Include=\"..\\common\\set_badblocks.c\" />\n    <ClCompile Include=\"..\\common\\bad_blocks.c\" />\n    <ClCompile Include=\"..\\common\\ctl.c\" />\n    <ClCompile Include=\"..\\common\\ctl_cow.c\" />\n    <ClCompile Include=\"..\\common\\ctl_prefault.c\" />\n    <ClCompile Include=\"..\\common\\ctl_sds.c\" />\n    <ClCompile Include=\"..\\common\\ctl_fallocate.c\" />\n    <ClCompile Include=\"..\\common\\file.c\" />\n    <ClCompile Include=\"..\\common\\file_windows.c\" />\n    <ClCompile Include=\"..\\core\\fs_windows.c\" />\n    <ClCompile Include=\"..\\common\\mmap.c\" />\n    <ClCompile Include=\"..\\common\\mmap_windows.c\" />\n    <ClCompile Include=\"..\\common\\os_deep_windows.c\" />\n    <ClCompile Include=\"..\\core\\os_thread_windows.c\" />\n    <ClCompile Include=\"..\\core\\os_windows.c\" />\n    <ClCompile Include=\"..\\core\\out.c\" />\n    <ClCompile Include=\"..\\common\\pool_hdr.c\" />\n    <ClCompile Include=\"..\\common\\set.c\" />\n    <ClCompile Include=\"..\\common\\shutdown_state.c\" />\n    <ClCompile Include=\"..\\core\\util.c\" />\n    <ClCompile Include=\"..\\core\\util_windows.c\" />\n    <ClCompile Include=\"..\\common\\uuid.c\" />\n    <ClCompile Include=\"..\\common\\uuid_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\auto_flush_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\badblocks.c\" />\n    <ClCompile Include=\"..\\libpmem2\\badblocks_none.c\" />\n    <ClCompile Include=\"..\\libpmem2\\usc_windows.c\" />\n    <ClCompile Include=\"alloc_class.c\" />\n    <ClCompile Include=\"container_ravl.c\" />\n    <ClCompile Include=\"container_seglists.c\" />\n    <ClCompile Include=\"libpmemobj_main.c\" />\n    <ClCompile Include=\"memblock.c\" />\n    <ClCompile Include=\"recycler.c\" />\n    <ClCompile Include=\"stats.c\" />\n    <ClCompile Include=\"..\\libpmem2\\config.c\" />\n    <ClCompile Include=\"..\\libpmem2\\source.c\" />\n    <ClCompile Include=\"..\\libpmem2\\source_windows.c\" />\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils.c\" />\n    <ClCompile Include=\"..\\libpmem2\\pmem2_utils_other.c\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"..\\..\\src\\core\\out.h\" />\n    <ClInclude Include=\"..\\..\\src\\core\\util.h\" />\n    <ClInclude Include=\"..\\..\\src\\common\\valgrind_internal.h\" />\n    <ClInclude Include=\"..\\..\\src\\include\\libpmemobj.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\bucket.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\critnib.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\ctl_debug.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\heap.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\heap_layout.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\lane.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\list.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\memops.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\obj.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\palloc.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\pmalloc.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\pmemops.h\" />\n    <ClInclude Include=\"..\\..\\src\\libpmemobj\\redo.h\" />\n    <ClInclude Include=\"..\\common\\ravl.h\" />\n    <ClInclude Include=\"..\\core\\alloc.h\" />\n    <ClInclude Include=\"..\\common\\ctl.h\" />\n    <ClInclude Include=\"..\\common\\ctl_global.h\" />\n    <ClInclude Include=\"..\\common\\dlsym.h\" />\n    <ClInclude Include=\"..\\core\\fault_injection.h\" />\n    <ClInclude Include=\"..\\common\\file.h\" />\n    <ClInclude Include=\"..\\core\\fs.h\" />\n    <ClInclude Include=\"..\\common\\mmap.h\" />\n    <ClInclude Include=\"..\\core\\os.h\" />\n    <ClInclude Include=\"..\\common\\os_deep.h\" />\n    <ClInclude Include=\"..\\core\\os_thread.h\" />\n    <ClInclude Include=\"..\\common\\pmemcommon.h\" />\n    <ClInclude Include=\"..\\common\\pool_hdr.h\" />\n    <ClInclude Include=\"..\\common\\queue.h\" />\n    <ClInclude Include=\"..\\common\\set.h\" />\n    <ClInclude Include=\"..\\common\\sys_util.h\" />\n    <ClInclude Include=\"..\\common\\uuid.h\" />\n    <ClInclude Include=\"..\\include\\libpmemobj\\action.h\" />\n    <ClInclude Include=\"..\\include\\libpmemobj\\action_base.h\" />\n    <ClInclude Include=\"..\\include\\libpmemobj\\atomic.h\" />\n    <ClInclude Include=\"..\\include\\libpmemobj\\atomic_base.h\" />\n    <ClInclude Include=\"..\\include\\libpmemobj\\base.h\" />\n    <ClInclude Include=\"..\\include\\libpmemobj\\iterator.h\" />\n    <ClInclude Include=\"..\\include\\libpmemobj\\iterator_base.h\" />\n    <ClInclude Include=\"..\\include\\libpmemobj\\lists_atomic.h\" />\n    <ClInclude Include=\"..\\include\\libpmemobj\\lists_atomic_base.h\" />\n    <ClInclude Include=\"..\\include\\libpmemobj\\pool.h\" />\n    <ClInclude Include=\"..\\include\\libpmemobj\\pool_base.h\" />\n    <ClInclude Include=\"..\\include\\libpmemobj\\thread.h\" />\n    <ClInclude Include=\"..\\include\\libpmemobj\\tx.h\" />\n    <ClInclude Include=\"..\\include\\libpmemobj\\tx_base.h\" />\n    <ClInclude Include=\"..\\include\\libpmemobj\\types.h\" />\n    <ClInclude Include=\"..\\libpmem2\\auto_flush.h\" />\n    <ClInclude Include=\"..\\libpmem2\\auto_flush_windows.h\" />\n    <ClInclude Include=\"alloc_class.h\" />\n    <ClInclude Include=\"container.h\" />\n    <ClInclude Include=\"container_ravl.h\" />\n    <ClInclude Include=\"container_seglists.h\" />\n    <ClInclude Include=\"memblock.h\" />\n    <ClInclude Include=\"recycler.h\" />\n    <ClInclude Include=\"stats.h\" />\n    <ClInclude Include=\"sync.h\" />\n    <ClInclude Include=\"tx.h\" />\n    <ClInclude Include=\"..\\libpmem2\\config.h\" />\n    <ClInclude Include=\"..\\libpmem2\\pmem2_utils.h\" />\n  </ItemGroup>\n  <ItemGroup>\n    <None Include=\"libpmemobj.def\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ProjectReference Include=\"..\\libpmem\\libpmem.vcxproj\">\n      <Project>{9e9e3d25-2139-4a5d-9200-18148ddead45}</Project>\n    </ProjectReference>\n    <ProjectReference Include=\"..\\windows\\srcversion\\srcversion.vcxproj\">\n      <Project>{901f04db-e1a5-4a41-8b81-9d31c19acd59}</Project>\n    </ProjectReference>\n  </ItemGroup>\n  <ItemGroup>\n    <ResourceCompile Include=\"libpmemobj.rc\" />\n  </ItemGroup>\n  <PropertyGroup Label=\"Globals\">\n    <ProjectGuid>{1BAA1617-93AE-4196-8A1A-BD492FB18AEF}</ProjectGuid>\n    <Keyword>DynamicLibrary</Keyword>\n    <ProjectName>libpmemobj</ProjectName>\n    <RootNamespace>libpmemobj</RootNamespace>\n    <DefaultLanguage>en-US</DefaultLanguage>\n    <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>\n    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>\n    <WindowsTargetPlatformMinVersion>10.0.10240.0</WindowsTargetPlatformMinVersion>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\n    <UseDebugLibraries>true</UseDebugLibraries>\n    <PlatformToolset>v140</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\n    <UseDebugLibraries>false</UseDebugLibraries>\n    <WholeProgramOptimization>false</WholeProgramOptimization>\n    <PlatformToolset>v140</PlatformToolset>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n    <Import Project=\"..\\windows\\libs_debug.props\" />\n  </ImportGroup>\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n    <Import Project=\"..\\windows\\libs_release.props\" />\n  </ImportGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" />\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" />\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" />\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n  <ImportGroup Label=\"ExtensionTargets\">\n  </ImportGroup>\n</Project>"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/test/util_poolset/grep5w.log.match",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/test/util_poolset/grep4w.log.match",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/test/util_poolset/grep6w.log.match",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/src/tools/pmempool/pmempool.rc",
        "/tmp/vanessa/spack-stage/spack-stage-pmdk-1.9-nctaxmxje3xyerp3lq4tykeibxkuhjnw/spack-src/res/PMDK.ico"
    ],
    "total_files": 3941
}