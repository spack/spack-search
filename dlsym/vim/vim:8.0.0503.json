{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/os_unix.c": "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\t      OS/2 port by Paul Slootman\n *\t      VMS merge by Zoltan Arpadffy\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * os_unix.c -- code for all flavors of Unix (BSD, SYSV, SVR4, POSIX, ...)\n *\t     Also for OS/2, using the excellent EMX package!!!\n *\t     Also for BeOS and Atari MiNT.\n *\n * A lot of this file was originally written by Juergen Weigert and later\n * changed beyond recognition.\n */\n\n/*\n * Some systems have a prototype for select() that has (int *) instead of\n * (fd_set *), which is wrong. This define removes that prototype. We define\n * our own prototype below.\n * Don't use it for the Mac, it causes a warning for precompiled headers.\n * TODO: use a configure check for precompiled headers?\n */\n#if !defined(__APPLE__) && !defined(__TANDEM)\n# define select select_declared_wrong\n#endif\n\n#include \"vim.h\"\n\n#ifdef FEAT_MZSCHEME\n# include \"if_mzsch.h\"\n#endif\n\n#include \"os_unixx.h\"\t    /* unix includes for os_unix.c only */\n\n#ifdef USE_XSMP\n# include <X11/SM/SMlib.h>\n#endif\n\n#ifdef HAVE_SELINUX\n# include <selinux/selinux.h>\nstatic int selinux_enabled = -1;\n#endif\n\n#ifdef HAVE_SMACK\n# include <attr/xattr.h>\n# include <linux/xattr.h>\n# ifndef SMACK_LABEL_LEN\n#  define SMACK_LABEL_LEN 1024\n# endif\n#endif\n\n/*\n * Use this prototype for select, some include files have a wrong prototype\n */\n#ifndef __TANDEM\n# undef select\n# ifdef __BEOS__\n#  define select\tbeos_select\n# endif\n#endif\n\n#ifdef __CYGWIN__\n# ifndef WIN32\n#  include <cygwin/version.h>\n#  include <sys/cygwin.h>\t/* for cygwin_conv_to_posix_path() and/or\n\t\t\t\t * for cygwin_conv_path() */\n#  ifdef FEAT_CYGWIN_WIN32_CLIPBOARD\n#   define WIN32_LEAN_AND_MEAN\n#   include <windows.h>\n#   include \"winclip.pro\"\n#  endif\n# endif\n#endif\n\n#if defined(HAVE_SELECT)\nextern int   select(int, fd_set *, fd_set *, fd_set *, struct timeval *);\n#endif\n\n#ifdef FEAT_MOUSE_GPM\n# include <gpm.h>\n/* <linux/keyboard.h> contains defines conflicting with \"keymap.h\",\n * I just copied relevant defines here. A cleaner solution would be to put gpm\n * code into separate file and include there linux/keyboard.h\n */\n/* #include <linux/keyboard.h> */\n# define KG_SHIFT\t0\n# define KG_CTRL\t2\n# define KG_ALT\t\t3\n# define KG_ALTGR\t1\n# define KG_SHIFTL\t4\n# define KG_SHIFTR\t5\n# define KG_CTRLL\t6\n# define KG_CTRLR\t7\n# define KG_CAPSSHIFT\t8\n\nstatic void gpm_close(void);\nstatic int gpm_open(void);\nstatic int mch_gpm_process(void);\n#endif\n\n#ifdef FEAT_SYSMOUSE\n# include <sys/consio.h>\n# include <sys/fbio.h>\n\nstatic int sysmouse_open(void);\nstatic void sysmouse_close(void);\nstatic RETSIGTYPE sig_sysmouse SIGPROTOARG;\n#endif\n\n/*\n * end of autoconf section. To be extended...\n */\n\n/* Are the following #ifdefs still required? And why? Is that for X11? */\n\n#if defined(ESIX) || defined(M_UNIX) && !defined(SCO)\n# ifdef SIGWINCH\n#  undef SIGWINCH\n# endif\n# ifdef TIOCGWINSZ\n#  undef TIOCGWINSZ\n# endif\n#endif\n\n#if defined(SIGWINDOW) && !defined(SIGWINCH)\t/* hpux 9.01 has it */\n# define SIGWINCH SIGWINDOW\n#endif\n\n#ifdef FEAT_X11\n# include <X11/Xlib.h>\n# include <X11/Xutil.h>\n# include <X11/Xatom.h>\n# ifdef FEAT_XCLIPBOARD\n#  include <X11/Intrinsic.h>\n#  include <X11/Shell.h>\n#  include <X11/StringDefs.h>\nstatic Widget\txterm_Shell = (Widget)0;\nstatic void clip_update(void);\nstatic void xterm_update(void);\n# endif\n\n# if defined(FEAT_XCLIPBOARD) || defined(FEAT_TITLE)\nWindow\t    x11_window = 0;\n# endif\nDisplay\t    *x11_display = NULL;\n\n# ifdef FEAT_TITLE\nstatic int  get_x11_windis(void);\nstatic void set_x11_title(char_u *);\nstatic void set_x11_icon(char_u *);\n# endif\n#endif\n\n#ifdef FEAT_TITLE\nstatic int get_x11_title(int);\nstatic int get_x11_icon(int);\n\nstatic char_u\t*oldtitle = NULL;\nstatic int\tdid_set_title = FALSE;\nstatic char_u\t*oldicon = NULL;\nstatic int\tdid_set_icon = FALSE;\n#endif\n\nstatic void may_core_dump(void);\n\n#ifdef HAVE_UNION_WAIT\ntypedef union wait waitstatus;\n#else\ntypedef int waitstatus;\n#endif\nstatic pid_t wait4pid(pid_t, waitstatus *);\n\nstatic int  WaitForChar(long msec, int *interrupted);\nstatic int  WaitForCharOrMouse(long msec, int *interrupted);\n#if defined(__BEOS__) || defined(VMS)\nint  RealWaitForChar(int, long, int *, int *interrupted);\n#else\nstatic int  RealWaitForChar(int, long, int *, int *interrupted);\n#endif\n\n#ifdef FEAT_XCLIPBOARD\nstatic int do_xterm_trace(void);\n# define XT_TRACE_DELAY\t50\t/* delay for xterm tracing */\n#endif\n\nstatic void handle_resize(void);\n\n#if defined(SIGWINCH)\nstatic RETSIGTYPE sig_winch SIGPROTOARG;\n#endif\n#if defined(SIGINT)\nstatic RETSIGTYPE catch_sigint SIGPROTOARG;\n#endif\n#if defined(SIGPWR)\nstatic RETSIGTYPE catch_sigpwr SIGPROTOARG;\n#endif\n#if defined(SIGALRM) && defined(FEAT_X11) \\\n\t&& defined(FEAT_TITLE) && !defined(FEAT_GUI_GTK)\n# define SET_SIG_ALARM\nstatic RETSIGTYPE sig_alarm SIGPROTOARG;\n/* volatile because it is used in signal handler sig_alarm(). */\nstatic volatile int sig_alarm_called;\n#endif\nstatic RETSIGTYPE deathtrap SIGPROTOARG;\n\nstatic void catch_int_signal(void);\nstatic void set_signals(void);\nstatic void catch_signals(RETSIGTYPE (*func_deadly)(), RETSIGTYPE (*func_other)());\n#ifdef HAVE_SIGPROCMASK\n# define SIGSET_DECL(set)\tsigset_t set;\n# define BLOCK_SIGNALS(set)\tblock_signals(set)\n# define UNBLOCK_SIGNALS(set)\tunblock_signals(set)\n#else\n# define SIGSET_DECL(set)\n# define BLOCK_SIGNALS(set)\tdo { /**/ } while (0)\n# define UNBLOCK_SIGNALS(set)\tdo { /**/ } while (0)\n#endif\nstatic int  have_wildcard(int, char_u **);\nstatic int  have_dollars(int, char_u **);\n\nstatic int save_patterns(int num_pat, char_u **pat, int *num_file, char_u ***file);\n\n#ifndef SIG_ERR\n# define SIG_ERR\t((RETSIGTYPE (*)())-1)\n#endif\n\n/* volatile because it is used in signal handler sig_winch(). */\nstatic volatile int do_resize = FALSE;\nstatic char_u\t*extra_shell_arg = NULL;\nstatic int\tshow_shell_mess = TRUE;\n/* volatile because it is used in signal handler deathtrap(). */\nstatic volatile int deadly_signal = 0;\t    /* The signal we caught */\n/* volatile because it is used in signal handler deathtrap(). */\nstatic volatile int in_mch_delay = FALSE;    /* sleeping in mch_delay() */\n\n#if defined(FEAT_JOB_CHANNEL) && !defined(USE_SYSTEM)\nstatic int dont_check_job_ended = 0;\n#endif\n\nstatic int curr_tmode = TMODE_COOK;\t/* contains current terminal mode */\n\n#ifdef USE_XSMP\ntypedef struct\n{\n    SmcConn smcconn;\t    /* The SM connection ID */\n    IceConn iceconn;\t    /* The ICE connection ID */\n    char *clientid;\t    /* The client ID for the current smc session */\n    Bool save_yourself;     /* If we're in the middle of a save_yourself */\n    Bool shutdown;\t    /* If we're in shutdown mode */\n} xsmp_config_T;\n\nstatic xsmp_config_T xsmp;\n#endif\n\n#ifdef SYS_SIGLIST_DECLARED\n/*\n * I have seen\n *  extern char *_sys_siglist[NSIG];\n * on Irix, Linux, NetBSD and Solaris. It contains a nice list of strings\n * that describe the signals. That is nearly what we want here.  But\n * autoconf does only check for sys_siglist (without the underscore), I\n * do not want to change everything today.... jw.\n * This is why AC_DECL_SYS_SIGLIST is commented out in configure.ac.\n */\n#endif\n\nstatic struct signalinfo\n{\n    int\t    sig;\t/* Signal number, eg. SIGSEGV etc */\n    char    *name;\t/* Signal name (not char_u!). */\n    char    deadly;\t/* Catch as a deadly signal? */\n} signal_info[] =\n{\n#ifdef SIGHUP\n    {SIGHUP,\t    \"HUP\",\tTRUE},\n#endif\n#ifdef SIGQUIT\n    {SIGQUIT,\t    \"QUIT\",\tTRUE},\n#endif\n#ifdef SIGILL\n    {SIGILL,\t    \"ILL\",\tTRUE},\n#endif\n#ifdef SIGTRAP\n    {SIGTRAP,\t    \"TRAP\",\tTRUE},\n#endif\n#ifdef SIGABRT\n    {SIGABRT,\t    \"ABRT\",\tTRUE},\n#endif\n#ifdef SIGEMT\n    {SIGEMT,\t    \"EMT\",\tTRUE},\n#endif\n#ifdef SIGFPE\n    {SIGFPE,\t    \"FPE\",\tTRUE},\n#endif\n#ifdef SIGBUS\n    {SIGBUS,\t    \"BUS\",\tTRUE},\n#endif\n#if defined(SIGSEGV) && !defined(FEAT_MZSCHEME)\n    /* MzScheme uses SEGV in its garbage collector */\n    {SIGSEGV,\t    \"SEGV\",\tTRUE},\n#endif\n#ifdef SIGSYS\n    {SIGSYS,\t    \"SYS\",\tTRUE},\n#endif\n#ifdef SIGALRM\n    {SIGALRM,\t    \"ALRM\",\tFALSE},\t/* Perl's alarm() can trigger it */\n#endif\n#ifdef SIGTERM\n    {SIGTERM,\t    \"TERM\",\tTRUE},\n#endif\n#if defined(SIGVTALRM) && !defined(FEAT_RUBY)\n    {SIGVTALRM,\t    \"VTALRM\",\tTRUE},\n#endif\n#if defined(SIGPROF) && !defined(FEAT_MZSCHEME) && !defined(WE_ARE_PROFILING)\n    /* MzScheme uses SIGPROF for its own needs; On Linux with profiling\n     * this makes Vim exit.  WE_ARE_PROFILING is defined in Makefile.  */\n    {SIGPROF,\t    \"PROF\",\tTRUE},\n#endif\n#ifdef SIGXCPU\n    {SIGXCPU,\t    \"XCPU\",\tTRUE},\n#endif\n#ifdef SIGXFSZ\n    {SIGXFSZ,\t    \"XFSZ\",\tTRUE},\n#endif\n#ifdef SIGUSR1\n    {SIGUSR1,\t    \"USR1\",\tTRUE},\n#endif\n#if defined(SIGUSR2) && !defined(FEAT_SYSMOUSE)\n    /* Used for sysmouse handling */\n    {SIGUSR2,\t    \"USR2\",\tTRUE},\n#endif\n#ifdef SIGINT\n    {SIGINT,\t    \"INT\",\tFALSE},\n#endif\n#ifdef SIGWINCH\n    {SIGWINCH,\t    \"WINCH\",\tFALSE},\n#endif\n#ifdef SIGTSTP\n    {SIGTSTP,\t    \"TSTP\",\tFALSE},\n#endif\n#ifdef SIGPIPE\n    {SIGPIPE,\t    \"PIPE\",\tFALSE},\n#endif\n    {-1,\t    \"Unknown!\", FALSE}\n};\n\n    int\nmch_chdir(char *path)\n{\n    if (p_verbose >= 5)\n    {\n\tverbose_enter();\n\tsmsg((char_u *)\"chdir(%s)\", path);\n\tverbose_leave();\n    }\n# ifdef VMS\n    return chdir(vms_fixfilename(path));\n# else\n    return chdir(path);\n# endif\n}\n\n/*\n * Write s[len] to the screen.\n */\n    void\nmch_write(char_u *s, int len)\n{\n    ignored = (int)write(1, (char *)s, len);\n    if (p_wd)\t\t/* Unix is too fast, slow down a bit more */\n\tRealWaitForChar(read_cmd_fd, p_wd, NULL, NULL);\n}\n\n/*\n * mch_inchar(): low level input function.\n * Get a characters from the keyboard.\n * Return the number of characters that are available.\n * If wtime == 0 do not wait for characters.\n * If wtime == n wait a short time for characters.\n * If wtime == -1 wait forever for characters.\n */\n    int\nmch_inchar(\n    char_u\t*buf,\n    int\t\tmaxlen,\n    long\twtime,\t    /* don't use \"time\", MIPS cannot handle it */\n    int\t\ttb_change_cnt)\n{\n    int\t\tlen;\n    int\t\tinterrupted = FALSE;\n    int\t\tdid_start_blocking = FALSE;\n    long\twait_time;\n    long\telapsed_time = 0;\n#ifdef ELAPSED_FUNC\n    ELAPSED_TYPE start_tv;\n\n    ELAPSED_INIT(start_tv);\n#endif\n\n    /* repeat until we got a character or waited long enough */\n    for (;;)\n    {\n\t/* Check if window changed size while we were busy, perhaps the \":set\n\t * columns=99\" command was used. */\n\twhile (do_resize)\n\t    handle_resize();\n\n#ifdef MESSAGE_QUEUE\n\tparse_queued_messages();\n#endif\n\tif (wtime < 0 && did_start_blocking)\n\t    /* blocking and already waited for p_ut */\n\t    wait_time = -1;\n\telse\n\t{\n\t    if (wtime >= 0)\n\t\twait_time = wtime;\n\t    else\n\t\t/* going to block after p_ut */\n\t\twait_time = p_ut;\n#ifdef ELAPSED_FUNC\n\t    elapsed_time = ELAPSED_FUNC(start_tv);\n#endif\n\t    wait_time -= elapsed_time;\n\t    if (wait_time < 0)\n\t    {\n\t\tif (wtime >= 0)\n\t\t    /* no character available within \"wtime\" */\n\t\t    return 0;\n\n\t\tif (wtime < 0)\n\t\t{\n\t\t    /* no character available within 'updatetime' */\n\t\t    did_start_blocking = TRUE;\n#ifdef FEAT_AUTOCMD\n\t\t    if (trigger_cursorhold() && maxlen >= 3\n\t\t\t\t\t    && !typebuf_changed(tb_change_cnt))\n\t\t    {\n\t\t\tbuf[0] = K_SPECIAL;\n\t\t\tbuf[1] = KS_EXTRA;\n\t\t\tbuf[2] = (int)KE_CURSORHOLD;\n\t\t\treturn 3;\n\t\t    }\n#endif\n\t\t    /*\n\t\t     * If there is no character available within 'updatetime'\n\t\t     * seconds flush all the swap files to disk.\n\t\t     * Also done when interrupted by SIGWINCH.\n\t\t     */\n\t\t    before_blocking();\n\t\t    continue;\n\t\t}\n\t    }\n\t}\n\n#ifdef FEAT_JOB_CHANNEL\n\t/* Checking if a job ended requires polling.  Do this every 100 msec. */\n\tif (has_pending_job() && (wait_time < 0 || wait_time > 100L))\n\t    wait_time = 100L;\n\t/* If there is readahead then parse_queued_messages() timed out and we\n\t * should call it again soon. */\n\tif ((wait_time < 0 || wait_time > 100L) && channel_any_readahead())\n\t    wait_time = 10L;\n#endif\n#ifdef FEAT_BEVAL\n\tif (p_beval && wait_time > 100L)\n\t    /* The 'balloonexpr' may indirectly invoke a callback while waiting\n\t     * for a character, need to check often. */\n\t    wait_time = 100L;\n#endif\n\n\t/*\n\t * We want to be interrupted by the winch signal\n\t * or by an event on the monitored file descriptors.\n\t */\n\tif (WaitForChar(wait_time, &interrupted))\n\t{\n\t    /* If input was put directly in typeahead buffer bail out here. */\n\t    if (typebuf_changed(tb_change_cnt))\n\t\treturn 0;\n\n\t    /*\n\t     * For some terminals we only get one character at a time.\n\t     * We want the get all available characters, so we could keep on\n\t     * trying until none is available\n\t     * For some other terminals this is quite slow, that's why we don't\n\t     * do it.\n\t     */\n\t    len = read_from_input_buf(buf, (long)maxlen);\n\t    if (len > 0)\n\t\treturn len;\n\t    continue;\n\t}\n\n\t/* no character available */\n#if !(defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H))\n\t/* estimate the elapsed time */\n\telapsed_time += wait_time;\n#endif\n\n\tif (do_resize\t    /* interrupted by SIGWINCH signal */\n#ifdef FEAT_CLIENTSERVER\n\t\t|| server_waiting()\n#endif\n#ifdef MESSAGE_QUEUE\n\t\t|| interrupted\n#endif\n\t\t|| wait_time > 0\n\t\t|| !did_start_blocking)\n\t    continue;\n\n\t/* no character available or interrupted */\n\tbreak;\n    }\n    return 0;\n}\n\n    static void\nhandle_resize(void)\n{\n    do_resize = FALSE;\n    shell_resized();\n}\n\n/*\n * Return non-zero if a character is available.\n */\n    int\nmch_char_avail(void)\n{\n    return WaitForChar(0L, NULL);\n}\n\n#if defined(HAVE_TOTAL_MEM) || defined(PROTO)\n# ifdef HAVE_SYS_RESOURCE_H\n#  include <sys/resource.h>\n# endif\n# if defined(HAVE_SYS_SYSCTL_H) && defined(HAVE_SYSCTL)\n#  include <sys/sysctl.h>\n# endif\n# if defined(HAVE_SYS_SYSINFO_H) && defined(HAVE_SYSINFO)\n#  include <sys/sysinfo.h>\n# endif\n\n/*\n * Return total amount of memory available in Kbyte.\n * Doesn't change when memory has been allocated.\n */\n    long_u\nmch_total_mem(int special UNUSED)\n{\n    long_u\tmem = 0;\n    long_u\tshiftright = 10;  /* how much to shift \"mem\" right for Kbyte */\n\n# ifdef HAVE_SYSCTL\n    int\t\tmib[2], physmem;\n    size_t\tlen;\n\n    /* BSD way of getting the amount of RAM available. */\n    mib[0] = CTL_HW;\n    mib[1] = HW_USERMEM;\n    len = sizeof(physmem);\n    if (sysctl(mib, 2, &physmem, &len, NULL, 0) == 0)\n\tmem = (long_u)physmem;\n# endif\n\n# if defined(HAVE_SYS_SYSINFO_H) && defined(HAVE_SYSINFO)\n    if (mem == 0)\n    {\n\tstruct sysinfo sinfo;\n\n\t/* Linux way of getting amount of RAM available */\n\tif (sysinfo(&sinfo) == 0)\n\t{\n#  ifdef HAVE_SYSINFO_MEM_UNIT\n\t    /* avoid overflow as much as possible */\n\t    while (shiftright > 0 && (sinfo.mem_unit & 1) == 0)\n\t    {\n\t\tsinfo.mem_unit = sinfo.mem_unit >> 1;\n\t\t--shiftright;\n\t    }\n\t    mem = sinfo.totalram * sinfo.mem_unit;\n#  else\n\t    mem = sinfo.totalram;\n#  endif\n\t}\n    }\n# endif\n\n# ifdef HAVE_SYSCONF\n    if (mem == 0)\n    {\n\tlong\t    pagesize, pagecount;\n\n\t/* Solaris way of getting amount of RAM available */\n\tpagesize = sysconf(_SC_PAGESIZE);\n\tpagecount = sysconf(_SC_PHYS_PAGES);\n\tif (pagesize > 0 && pagecount > 0)\n\t{\n\t    /* avoid overflow as much as possible */\n\t    while (shiftright > 0 && (pagesize & 1) == 0)\n\t    {\n\t\tpagesize = (long_u)pagesize >> 1;\n\t\t--shiftright;\n\t    }\n\t    mem = (long_u)pagesize * pagecount;\n\t}\n    }\n# endif\n\n    /* Return the minimum of the physical memory and the user limit, because\n     * using more than the user limit may cause Vim to be terminated. */\n# if defined(HAVE_SYS_RESOURCE_H) && defined(HAVE_GETRLIMIT)\n    {\n\tstruct rlimit\trlp;\n\n\tif (getrlimit(RLIMIT_DATA, &rlp) == 0\n\t\t&& rlp.rlim_cur < ((rlim_t)1 << (sizeof(long_u) * 8 - 1))\n#  ifdef RLIM_INFINITY\n\t\t&& rlp.rlim_cur != RLIM_INFINITY\n#  endif\n\t\t&& ((long_u)rlp.rlim_cur >> 10) < (mem >> shiftright)\n\t   )\n\t{\n\t    mem = (long_u)rlp.rlim_cur;\n\t    shiftright = 10;\n\t}\n    }\n# endif\n\n    if (mem > 0)\n\treturn mem >> shiftright;\n    return (long_u)0x1fffff;\n}\n#endif\n\n    void\nmch_delay(long msec, int ignoreinput)\n{\n    int\t\told_tmode;\n#ifdef FEAT_MZSCHEME\n    long\ttotal = msec; /* remember original value */\n#endif\n\n    if (ignoreinput)\n    {\n\t/* Go to cooked mode without echo, to allow SIGINT interrupting us\n\t * here.  But we don't want QUIT to kill us (CTRL-\\ used in a\n\t * shell may produce SIGQUIT). */\n\tin_mch_delay = TRUE;\n\told_tmode = curr_tmode;\n\tif (curr_tmode == TMODE_RAW)\n\t    settmode(TMODE_SLEEP);\n\n\t/*\n\t * Everybody sleeps in a different way...\n\t * Prefer nanosleep(), some versions of usleep() can only sleep up to\n\t * one second.\n\t */\n#ifdef FEAT_MZSCHEME\n\tdo\n\t{\n\t    /* if total is large enough, wait by portions in p_mzq */\n\t    if (total > p_mzq)\n\t\tmsec = p_mzq;\n\t    else\n\t\tmsec = total;\n\t    total -= msec;\n#endif\n#ifdef HAVE_NANOSLEEP\n\t{\n\t    struct timespec ts;\n\n\t    ts.tv_sec = msec / 1000;\n\t    ts.tv_nsec = (msec % 1000) * 1000000;\n\t    (void)nanosleep(&ts, NULL);\n\t}\n#else\n# ifdef HAVE_USLEEP\n\twhile (msec >= 1000)\n\t{\n\t    usleep((unsigned int)(999 * 1000));\n\t    msec -= 999;\n\t}\n\tusleep((unsigned int)(msec * 1000));\n# else\n#  ifndef HAVE_SELECT\n\tpoll(NULL, 0, (int)msec);\n#  else\n\t{\n\t    struct timeval tv;\n\n\t    tv.tv_sec = msec / 1000;\n\t    tv.tv_usec = (msec % 1000) * 1000;\n\t    /*\n\t     * NOTE: Solaris 2.6 has a bug that makes select() hang here.  Get\n\t     * a patch from Sun to fix this.  Reported by Gunnar Pedersen.\n\t     */\n\t    select(0, NULL, NULL, NULL, &tv);\n\t}\n#  endif /* HAVE_SELECT */\n# endif /* HAVE_NANOSLEEP */\n#endif /* HAVE_USLEEP */\n#ifdef FEAT_MZSCHEME\n\t}\n\twhile (total > 0);\n#endif\n\n\tsettmode(old_tmode);\n\tin_mch_delay = FALSE;\n    }\n    else\n\tWaitForChar(msec, NULL);\n}\n\n#if defined(HAVE_STACK_LIMIT) \\\n\t|| (!defined(HAVE_SIGALTSTACK) && defined(HAVE_SIGSTACK))\n# define HAVE_CHECK_STACK_GROWTH\n/*\n * Support for checking for an almost-out-of-stack-space situation.\n */\n\n/*\n * Return a pointer to an item on the stack.  Used to find out if the stack\n * grows up or down.\n */\nstatic void check_stack_growth(char *p);\nstatic int stack_grows_downwards;\n\n/*\n * Find out if the stack grows upwards or downwards.\n * \"p\" points to a variable on the stack of the caller.\n */\n    static void\ncheck_stack_growth(char *p)\n{\n    int\t\ti;\n\n    stack_grows_downwards = (p > (char *)&i);\n}\n#endif\n\n#if defined(HAVE_STACK_LIMIT) || defined(PROTO)\nstatic char *stack_limit = NULL;\n\n#if defined(_THREAD_SAFE) && defined(HAVE_PTHREAD_NP_H)\n# include <pthread.h>\n# include <pthread_np.h>\n#endif\n\n/*\n * Find out until how var the stack can grow without getting into trouble.\n * Called when starting up and when switching to the signal stack in\n * deathtrap().\n */\n    static void\nget_stack_limit(void)\n{\n    struct rlimit\trlp;\n    int\t\t\ti;\n    long\t\tlim;\n\n    /* Set the stack limit to 15/16 of the allowable size.  Skip this when the\n     * limit doesn't fit in a long (rlim_cur might be \"long long\"). */\n    if (getrlimit(RLIMIT_STACK, &rlp) == 0\n\t    && rlp.rlim_cur < ((rlim_t)1 << (sizeof(long_u) * 8 - 1))\n#  ifdef RLIM_INFINITY\n\t    && rlp.rlim_cur != RLIM_INFINITY\n#  endif\n       )\n    {\n\tlim = (long)rlp.rlim_cur;\n#if defined(_THREAD_SAFE) && defined(HAVE_PTHREAD_NP_H)\n\t{\n\t    pthread_attr_t  attr;\n\t    size_t\t    size;\n\n\t    /* On FreeBSD the initial thread always has a fixed stack size, no\n\t     * matter what the limits are set to.  Normally it's 1 Mbyte. */\n\t    pthread_attr_init(&attr);\n\t    if (pthread_attr_get_np(pthread_self(), &attr) == 0)\n\t    {\n\t\tpthread_attr_getstacksize(&attr, &size);\n\t\tif (lim > (long)size)\n\t\t    lim = (long)size;\n\t    }\n\t    pthread_attr_destroy(&attr);\n\t}\n#endif\n\tif (stack_grows_downwards)\n\t{\n\t    stack_limit = (char *)((long)&i - (lim / 16L * 15L));\n\t    if (stack_limit >= (char *)&i)\n\t\t/* overflow, set to 1/16 of current stack position */\n\t\tstack_limit = (char *)((long)&i / 16L);\n\t}\n\telse\n\t{\n\t    stack_limit = (char *)((long)&i + (lim / 16L * 15L));\n\t    if (stack_limit <= (char *)&i)\n\t\tstack_limit = NULL;\t/* overflow */\n\t}\n    }\n}\n\n/*\n * Return FAIL when running out of stack space.\n * \"p\" must point to any variable local to the caller that's on the stack.\n */\n    int\nmch_stackcheck(char *p)\n{\n    if (stack_limit != NULL)\n    {\n\tif (stack_grows_downwards)\n\t{\n\t    if (p < stack_limit)\n\t\treturn FAIL;\n\t}\n\telse if (p > stack_limit)\n\t    return FAIL;\n    }\n    return OK;\n}\n#endif\n\n#if defined(HAVE_SIGALTSTACK) || defined(HAVE_SIGSTACK)\n/*\n * Support for using the signal stack.\n * This helps when we run out of stack space, which causes a SIGSEGV.  The\n * signal handler then must run on another stack, since the normal stack is\n * completely full.\n */\n\n#if defined(HAVE_AVAILABILITYMACROS_H)\n# include <AvailabilityMacros.h>\n#endif\n\n#ifndef SIGSTKSZ\n# define SIGSTKSZ 8000    /* just a guess of how much stack is needed... */\n#endif\n\n# ifdef HAVE_SIGALTSTACK\nstatic stack_t sigstk;\t\t\t/* for sigaltstack() */\n# else\nstatic struct sigstack sigstk;\t\t/* for sigstack() */\n# endif\n\nstatic void init_signal_stack(void);\nstatic char *signal_stack;\n\n    static void\ninit_signal_stack(void)\n{\n    if (signal_stack != NULL)\n    {\n# ifdef HAVE_SIGALTSTACK\n#  if defined(__APPLE__) && (!defined(MAC_OS_X_VERSION_MAX_ALLOWED) \\\n\t\t|| MAC_OS_X_VERSION_MAX_ALLOWED <= 1040)\n\t/* missing prototype.  Adding it to osdef?.h.in doesn't work, because\n\t * \"struct sigaltstack\" needs to be declared. */\n\textern int sigaltstack(const struct sigaltstack *ss, struct sigaltstack *oss);\n#  endif\n\n#  ifdef HAVE_SS_BASE\n\tsigstk.ss_base = signal_stack;\n#  else\n\tsigstk.ss_sp = signal_stack;\n#  endif\n\tsigstk.ss_size = SIGSTKSZ;\n\tsigstk.ss_flags = 0;\n\t(void)sigaltstack(&sigstk, NULL);\n# else\n\tsigstk.ss_sp = signal_stack;\n\tif (stack_grows_downwards)\n\t    sigstk.ss_sp += SIGSTKSZ - 1;\n\tsigstk.ss_onstack = 0;\n\t(void)sigstack(&sigstk, NULL);\n# endif\n    }\n}\n#endif\n\n/*\n * We need correct prototypes for a signal function, otherwise mean compilers\n * will barf when the second argument to signal() is ``wrong''.\n * Let me try it with a few tricky defines from my own osdef.h\t(jw).\n */\n#if defined(SIGWINCH)\n    static RETSIGTYPE\nsig_winch SIGDEFARG(sigarg)\n{\n    /* this is not required on all systems, but it doesn't hurt anybody */\n    signal(SIGWINCH, (RETSIGTYPE (*)())sig_winch);\n    do_resize = TRUE;\n    SIGRETURN;\n}\n#endif\n\n#if defined(SIGINT)\n    static RETSIGTYPE\ncatch_sigint SIGDEFARG(sigarg)\n{\n    /* this is not required on all systems, but it doesn't hurt anybody */\n    signal(SIGINT, (RETSIGTYPE (*)())catch_sigint);\n    got_int = TRUE;\n    SIGRETURN;\n}\n#endif\n\n#if defined(SIGPWR)\n    static RETSIGTYPE\ncatch_sigpwr SIGDEFARG(sigarg)\n{\n    /* this is not required on all systems, but it doesn't hurt anybody */\n    signal(SIGPWR, (RETSIGTYPE (*)())catch_sigpwr);\n    /*\n     * I'm not sure we get the SIGPWR signal when the system is really going\n     * down or when the batteries are almost empty.  Just preserve the swap\n     * files and don't exit, that can't do any harm.\n     */\n    ml_sync_all(FALSE, FALSE);\n    SIGRETURN;\n}\n#endif\n\n#ifdef SET_SIG_ALARM\n/*\n * signal function for alarm().\n */\n    static RETSIGTYPE\nsig_alarm SIGDEFARG(sigarg)\n{\n    /* doesn't do anything, just to break a system call */\n    sig_alarm_called = TRUE;\n    SIGRETURN;\n}\n#endif\n\n#if (defined(HAVE_SETJMP_H) \\\n\t&& ((defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)) \\\n\t    || defined(FEAT_LIBCALL))) \\\n    || defined(PROTO)\n/*\n * A simplistic version of setjmp() that only allows one level of using.\n * Don't call twice before calling mch_endjmp()!.\n * Usage:\n *\tmch_startjmp();\n *\tif (SETJMP(lc_jump_env) != 0)\n *\t{\n *\t    mch_didjmp();\n *\t    EMSG(\"crash!\");\n *\t}\n *\telse\n *\t{\n *\t    do_the_work;\n *\t    mch_endjmp();\n *\t}\n * Note: Can't move SETJMP() here, because a function calling setjmp() must\n * not return before the saved environment is used.\n * Returns OK for normal return, FAIL when the protected code caused a\n * problem and LONGJMP() was used.\n */\n    void\nmch_startjmp(void)\n{\n#ifdef SIGHASARG\n    lc_signal = 0;\n#endif\n    lc_active = TRUE;\n}\n\n    void\nmch_endjmp(void)\n{\n    lc_active = FALSE;\n}\n\n    void\nmch_didjmp(void)\n{\n# if defined(HAVE_SIGALTSTACK) || defined(HAVE_SIGSTACK)\n    /* On FreeBSD the signal stack has to be reset after using siglongjmp(),\n     * otherwise catching the signal only works once. */\n    init_signal_stack();\n# endif\n}\n#endif\n\n/*\n * This function handles deadly signals.\n * It tries to preserve any swap files and exit properly.\n * (partly from Elvis).\n * NOTE: Avoid unsafe functions, such as allocating memory, they can result in\n * a deadlock.\n */\n    static RETSIGTYPE\ndeathtrap SIGDEFARG(sigarg)\n{\n    static int\tentered = 0;\t    /* count the number of times we got here.\n\t\t\t\t       Note: when memory has been corrupted\n\t\t\t\t       this may get an arbitrary value! */\n#ifdef SIGHASARG\n    int\t\ti;\n#endif\n\n#if defined(HAVE_SETJMP_H)\n    /*\n     * Catch a crash in protected code.\n     * Restores the environment saved in lc_jump_env, which looks like\n     * SETJMP() returns 1.\n     */\n    if (lc_active)\n    {\n# if defined(SIGHASARG)\n\tlc_signal = sigarg;\n# endif\n\tlc_active = FALSE;\t/* don't jump again */\n\tLONGJMP(lc_jump_env, 1);\n\t/* NOTREACHED */\n    }\n#endif\n\n#ifdef SIGHASARG\n# ifdef SIGQUIT\n    /* While in mch_delay() we go to cooked mode to allow a CTRL-C to\n     * interrupt us.  But in cooked mode we may also get SIGQUIT, e.g., when\n     * pressing CTRL-\\, but we don't want Vim to exit then. */\n    if (in_mch_delay && sigarg == SIGQUIT)\n\tSIGRETURN;\n# endif\n\n    /* When SIGHUP, SIGQUIT, etc. are blocked: postpone the effect and return\n     * here.  This avoids that a non-reentrant function is interrupted, e.g.,\n     * free().  Calling free() again may then cause a crash. */\n    if (entered == 0\n\t    && (0\n# ifdef SIGHUP\n\t\t|| sigarg == SIGHUP\n# endif\n# ifdef SIGQUIT\n\t\t|| sigarg == SIGQUIT\n# endif\n# ifdef SIGTERM\n\t\t|| sigarg == SIGTERM\n# endif\n# ifdef SIGPWR\n\t\t|| sigarg == SIGPWR\n# endif\n# ifdef SIGUSR1\n\t\t|| sigarg == SIGUSR1\n# endif\n# ifdef SIGUSR2\n\t\t|| sigarg == SIGUSR2\n# endif\n\t\t)\n\t    && !vim_handle_signal(sigarg))\n\tSIGRETURN;\n#endif\n\n    /* Remember how often we have been called. */\n    ++entered;\n\n#ifdef FEAT_AUTOCMD\n    /* Executing autocommands is likely to use more stack space than we have\n     * available in the signal stack. */\n    block_autocmds();\n#endif\n\n#ifdef FEAT_EVAL\n    /* Set the v:dying variable. */\n    set_vim_var_nr(VV_DYING, (long)entered);\n#endif\n\n#ifdef HAVE_STACK_LIMIT\n    /* Since we are now using the signal stack, need to reset the stack\n     * limit.  Otherwise using a regexp will fail. */\n    get_stack_limit();\n#endif\n\n#if 0\n    /* This is for opening gdb the moment Vim crashes.\n     * You need to manually adjust the file name and Vim executable name.\n     * Suggested by SungHyun Nam. */\n    {\n# define VI_GDB_FILE \"/tmp/vimgdb\"\n# define VIM_NAME \"/usr/bin/vim\"\n\tFILE *fp = fopen(VI_GDB_FILE, \"w\");\n\tif (fp)\n\t{\n\t    fprintf(fp,\n\t\t    \"file %s\\n\"\n\t\t    \"attach %d\\n\"\n\t\t    \"set height 1000\\n\"\n\t\t    \"bt full\\n\"\n\t\t    , VIM_NAME, getpid());\n\t    fclose(fp);\n\t    system(\"xterm -e gdb -x \"VI_GDB_FILE);\n\t    unlink(VI_GDB_FILE);\n\t}\n    }\n#endif\n\n#ifdef SIGHASARG\n    /* try to find the name of this signal */\n    for (i = 0; signal_info[i].sig != -1; i++)\n\tif (sigarg == signal_info[i].sig)\n\t    break;\n    deadly_signal = sigarg;\n#endif\n\n    full_screen = FALSE;\t/* don't write message to the GUI, it might be\n\t\t\t\t * part of the problem... */\n    /*\n     * If something goes wrong after entering here, we may get here again.\n     * When this happens, give a message and try to exit nicely (resetting the\n     * terminal mode, etc.)\n     * When this happens twice, just exit, don't even try to give a message,\n     * stack may be corrupt or something weird.\n     * When this still happens again (or memory was corrupted in such a way\n     * that \"entered\" was clobbered) use _exit(), don't try freeing resources.\n     */\n    if (entered >= 3)\n    {\n\treset_signals();\t/* don't catch any signals anymore */\n\tmay_core_dump();\n\tif (entered >= 4)\n\t    _exit(8);\n\texit(7);\n    }\n    if (entered == 2)\n    {\n\t/* No translation, it may call malloc(). */\n\tOUT_STR(\"Vim: Double signal, exiting\\n\");\n\tout_flush();\n\tgetout(1);\n    }\n\n    /* No translation, it may call malloc(). */\n#ifdef SIGHASARG\n    sprintf((char *)IObuff, \"Vim: Caught deadly signal %s\\n\",\n\t\t\t\t\t\t\t signal_info[i].name);\n#else\n    sprintf((char *)IObuff, \"Vim: Caught deadly signal\\n\");\n#endif\n\n    /* Preserve files and exit.  This sets the really_exiting flag to prevent\n     * calling free(). */\n    preserve_exit();\n\n    /* NOTREACHED */\n\n#ifdef NBDEBUG\n    reset_signals();\n    may_core_dump();\n    abort();\n#endif\n\n    SIGRETURN;\n}\n\n#if defined(_REENTRANT) && defined(SIGCONT)\n/*\n * On Solaris with multi-threading, suspending might not work immediately.\n * Catch the SIGCONT signal, which will be used as an indication whether the\n * suspending has been done or not.\n *\n * On Linux, signal is not always handled immediately either.\n * See https://bugs.launchpad.net/bugs/291373\n *\n * volatile because it is used in signal handler sigcont_handler().\n */\nstatic volatile int sigcont_received;\nstatic RETSIGTYPE sigcont_handler SIGPROTOARG;\n\n/*\n * signal handler for SIGCONT\n */\n    static RETSIGTYPE\nsigcont_handler SIGDEFARG(sigarg)\n{\n    sigcont_received = TRUE;\n    SIGRETURN;\n}\n#endif\n\n# if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)\nstatic void loose_clipboard(void);\n# ifdef USE_SYSTEM\nstatic void save_clipboard(void);\nstatic void restore_clipboard(void);\n\nstatic void *clip_star_save = NULL;\nstatic void *clip_plus_save = NULL;\n# endif\n\n/*\n * Called when Vim is going to sleep or execute a shell command.\n * We can't respond to requests for the X selections.  Lose them, otherwise\n * other applications will hang.  But first copy the text to cut buffer 0.\n */\n    static void\nloose_clipboard(void)\n{\n    if (clip_star.owned || clip_plus.owned)\n    {\n\tx11_export_final_selection();\n\tif (clip_star.owned)\n\t    clip_lose_selection(&clip_star);\n\tif (clip_plus.owned)\n\t    clip_lose_selection(&clip_plus);\n\tif (x11_display != NULL)\n\t    XFlush(x11_display);\n    }\n}\n\n# ifdef USE_SYSTEM\n/*\n * Save clipboard text to restore later.\n */\n    static void\nsave_clipboard(void)\n{\n    if (clip_star.owned)\n\tclip_star_save = get_register('*', TRUE);\n    if (clip_plus.owned)\n\tclip_plus_save = get_register('+', TRUE);\n}\n\n/*\n * Restore clipboard text if no one own the X selection.\n */\n    static void\nrestore_clipboard(void)\n{\n    if (clip_star_save != NULL)\n    {\n\tif (!clip_gen_owner_exists(&clip_star))\n\t    put_register('*', clip_star_save);\n\telse\n\t    free_register(clip_star_save);\n\tclip_star_save = NULL;\n    }\n    if (clip_plus_save != NULL)\n    {\n\tif (!clip_gen_owner_exists(&clip_plus))\n\t    put_register('+', clip_plus_save);\n\telse\n\t    free_register(clip_plus_save);\n\tclip_plus_save = NULL;\n    }\n}\n# endif\n#endif\n\n/*\n * If the machine has job control, use it to suspend the program,\n * otherwise fake it by starting a new shell.\n */\n    void\nmch_suspend(void)\n{\n    /* BeOS does have SIGTSTP, but it doesn't work. */\n#if defined(SIGTSTP) && !defined(__BEOS__)\n    out_flush();\t    /* needed to make cursor visible on some systems */\n    settmode(TMODE_COOK);\n    out_flush();\t    /* needed to disable mouse on some systems */\n\n# if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)\n    loose_clipboard();\n# endif\n\n# if defined(_REENTRANT) && defined(SIGCONT)\n    sigcont_received = FALSE;\n# endif\n    kill(0, SIGTSTP);\t    /* send ourselves a STOP signal */\n# if defined(_REENTRANT) && defined(SIGCONT)\n    /*\n     * Wait for the SIGCONT signal to be handled. It generally happens\n     * immediately, but somehow not all the time. Do not call pause()\n     * because there would be race condition which would hang Vim if\n     * signal happened in between the test of sigcont_received and the\n     * call to pause(). If signal is not yet received, call sleep(0)\n     * to just yield CPU. Signal should then be received. If somehow\n     * it's still not received, sleep 1, 2, 3 ms. Don't bother waiting\n     * further if signal is not received after 1+2+3+4 ms (not expected\n     * to happen).\n     */\n    {\n\tlong wait_time;\n\tfor (wait_time = 0; !sigcont_received && wait_time <= 3L; wait_time++)\n\t    /* Loop is not entered most of the time */\n\t    mch_delay(wait_time, FALSE);\n    }\n# endif\n\n# ifdef FEAT_TITLE\n    /*\n     * Set oldtitle to NULL, so the current title is obtained again.\n     */\n    vim_free(oldtitle);\n    oldtitle = NULL;\n# endif\n    settmode(TMODE_RAW);\n    need_check_timestamps = TRUE;\n    did_check_timestamps = FALSE;\n#else\n    suspend_shell();\n#endif\n}\n\n    void\nmch_init(void)\n{\n    Columns = 80;\n    Rows = 24;\n\n    out_flush();\n    set_signals();\n\n#ifdef MACOS_CONVERT\n    mac_conv_init();\n#endif\n#ifdef FEAT_CYGWIN_WIN32_CLIPBOARD\n    win_clip_init();\n#endif\n}\n\n    static void\nset_signals(void)\n{\n#if defined(SIGWINCH)\n    /*\n     * WINDOW CHANGE signal is handled with sig_winch().\n     */\n    signal(SIGWINCH, (RETSIGTYPE (*)())sig_winch);\n#endif\n\n    /*\n     * We want the STOP signal to work, to make mch_suspend() work.\n     * For \"rvim\" the STOP signal is ignored.\n     */\n#ifdef SIGTSTP\n    signal(SIGTSTP, restricted ? SIG_IGN : SIG_DFL);\n#endif\n#if defined(_REENTRANT) && defined(SIGCONT)\n    signal(SIGCONT, sigcont_handler);\n#endif\n\n    /*\n     * We want to ignore breaking of PIPEs.\n     */\n#ifdef SIGPIPE\n    signal(SIGPIPE, SIG_IGN);\n#endif\n\n#ifdef SIGINT\n    catch_int_signal();\n#endif\n\n    /*\n     * Ignore alarm signals (Perl's alarm() generates it).\n     */\n#ifdef SIGALRM\n    signal(SIGALRM, SIG_IGN);\n#endif\n\n    /*\n     * Catch SIGPWR (power failure?) to preserve the swap files, so that no\n     * work will be lost.\n     */\n#ifdef SIGPWR\n    signal(SIGPWR, (RETSIGTYPE (*)())catch_sigpwr);\n#endif\n\n    /*\n     * Arrange for other signals to gracefully shutdown Vim.\n     */\n    catch_signals(deathtrap, SIG_ERR);\n\n#if defined(FEAT_GUI) && defined(SIGHUP)\n    /*\n     * When the GUI is running, ignore the hangup signal.\n     */\n    if (gui.in_use)\n\tsignal(SIGHUP, SIG_IGN);\n#endif\n}\n\n#if defined(SIGINT) || defined(PROTO)\n/*\n * Catch CTRL-C (only works while in Cooked mode).\n */\n    static void\ncatch_int_signal(void)\n{\n    signal(SIGINT, (RETSIGTYPE (*)())catch_sigint);\n}\n#endif\n\n    void\nreset_signals(void)\n{\n    catch_signals(SIG_DFL, SIG_DFL);\n#if defined(_REENTRANT) && defined(SIGCONT)\n    /* SIGCONT isn't in the list, because its default action is ignore */\n    signal(SIGCONT, SIG_DFL);\n#endif\n}\n\n    static void\ncatch_signals(\n    RETSIGTYPE (*func_deadly)(),\n    RETSIGTYPE (*func_other)())\n{\n    int\t    i;\n\n    for (i = 0; signal_info[i].sig != -1; i++)\n\tif (signal_info[i].deadly)\n\t{\n#if defined(HAVE_SIGALTSTACK) && defined(HAVE_SIGACTION)\n\t    struct sigaction sa;\n\n\t    /* Setup to use the alternate stack for the signal function. */\n\t    sa.sa_handler = func_deadly;\n\t    sigemptyset(&sa.sa_mask);\n# if defined(__linux__) && defined(_REENTRANT)\n\t    /* On Linux, with glibc compiled for kernel 2.2, there is a bug in\n\t     * thread handling in combination with using the alternate stack:\n\t     * pthread library functions try to use the stack pointer to\n\t     * identify the current thread, causing a SEGV signal, which\n\t     * recursively calls deathtrap() and hangs. */\n\t    sa.sa_flags = 0;\n# else\n\t    sa.sa_flags = SA_ONSTACK;\n# endif\n\t    sigaction(signal_info[i].sig, &sa, NULL);\n#else\n# if defined(HAVE_SIGALTSTACK) && defined(HAVE_SIGVEC)\n\t    struct sigvec sv;\n\n\t    /* Setup to use the alternate stack for the signal function. */\n\t    sv.sv_handler = func_deadly;\n\t    sv.sv_mask = 0;\n\t    sv.sv_flags = SV_ONSTACK;\n\t    sigvec(signal_info[i].sig, &sv, NULL);\n# else\n\t    signal(signal_info[i].sig, func_deadly);\n# endif\n#endif\n\t}\n\telse if (func_other != SIG_ERR)\n\t    signal(signal_info[i].sig, func_other);\n}\n\n#ifdef HAVE_SIGPROCMASK\n    static void\nblock_signals(sigset_t *set)\n{\n    sigset_t\tnewset;\n    int\t\ti;\n\n    sigemptyset(&newset);\n\n    for (i = 0; signal_info[i].sig != -1; i++)\n\tsigaddset(&newset, signal_info[i].sig);\n\n# if defined(_REENTRANT) && defined(SIGCONT)\n    /* SIGCONT isn't in the list, because its default action is ignore */\n    sigaddset(&newset, SIGCONT);\n# endif\n\n    sigprocmask(SIG_BLOCK, &newset, set);\n}\n\n    static void\nunblock_signals(sigset_t *set)\n{\n    sigprocmask(SIG_SETMASK, set, NULL);\n}\n#endif\n\n/*\n * Handling of SIGHUP, SIGQUIT and SIGTERM:\n * \"when\" == a signal:       when busy, postpone and return FALSE, otherwise\n *\t\t\t     return TRUE\n * \"when\" == SIGNAL_BLOCK:   Going to be busy, block signals\n * \"when\" == SIGNAL_UNBLOCK: Going to wait, unblock signals, use postponed\n *\t\t\t     signal\n * Returns TRUE when Vim should exit.\n */\n    int\nvim_handle_signal(int sig)\n{\n    static int got_signal = 0;\n    static int blocked = TRUE;\n\n    switch (sig)\n    {\n\tcase SIGNAL_BLOCK:   blocked = TRUE;\n\t\t\t     break;\n\n\tcase SIGNAL_UNBLOCK: blocked = FALSE;\n\t\t\t     if (got_signal != 0)\n\t\t\t     {\n\t\t\t\t kill(getpid(), got_signal);\n\t\t\t\t got_signal = 0;\n\t\t\t     }\n\t\t\t     break;\n\n\tdefault:\t     if (!blocked)\n\t\t\t\t return TRUE;\t/* exit! */\n\t\t\t     got_signal = sig;\n#ifdef SIGPWR\n\t\t\t     if (sig != SIGPWR)\n#endif\n\t\t\t\t got_int = TRUE;    /* break any loops */\n\t\t\t     break;\n    }\n    return FALSE;\n}\n\n/*\n * Check_win checks whether we have an interactive stdout.\n */\n    int\nmch_check_win(int argc UNUSED, char **argv UNUSED)\n{\n    if (isatty(1))\n\treturn OK;\n    return FAIL;\n}\n\n/*\n * Return TRUE if the input comes from a terminal, FALSE otherwise.\n */\n    int\nmch_input_isatty(void)\n{\n    if (isatty(read_cmd_fd))\n\treturn TRUE;\n    return FALSE;\n}\n\n#ifdef FEAT_X11\n\n# if defined(ELAPSED_TIMEVAL) \\\n\t&& (defined(FEAT_XCLIPBOARD) || defined(FEAT_TITLE))\n\n/*\n * Give a message about the elapsed time for opening the X window.\n */\n    static void\nxopen_message(long elapsed_msec)\n{\n    smsg((char_u *)_(\"Opening the X display took %ld msec\"), elapsed_msec);\n}\n# endif\n#endif\n\n#if defined(FEAT_X11) && (defined(FEAT_TITLE) || defined(FEAT_XCLIPBOARD))\n/*\n * A few functions shared by X11 title and clipboard code.\n */\nstatic int x_error_handler(Display *dpy, XErrorEvent *error_event);\nstatic int x_error_check(Display *dpy, XErrorEvent *error_event);\nstatic int x_connect_to_server(void);\nstatic int test_x11_window(Display *dpy);\n\nstatic int\tgot_x_error = FALSE;\n\n/*\n * X Error handler, otherwise X just exits!  (very rude) -- webb\n */\n    static int\nx_error_handler(Display *dpy, XErrorEvent *error_event)\n{\n    XGetErrorText(dpy, error_event->error_code, (char *)IObuff, IOSIZE);\n    STRCAT(IObuff, _(\"\\nVim: Got X error\\n\"));\n\n    /* We cannot print a message and continue, because no X calls are allowed\n     * here (causes my system to hang).  Silently continuing might be an\n     * alternative... */\n    preserve_exit();\t\t    /* preserve files and exit */\n\n    return 0;\t\t/* NOTREACHED */\n}\n\n/*\n * Another X Error handler, just used to check for errors.\n */\n    static int\nx_error_check(Display *dpy UNUSED, XErrorEvent *error_event UNUSED)\n{\n    got_x_error = TRUE;\n    return 0;\n}\n\n#if defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)\n# if defined(HAVE_SETJMP_H)\n/*\n * An X IO Error handler, used to catch error while opening the display.\n */\nstatic int x_IOerror_check(Display *dpy);\n\n    static int\nx_IOerror_check(Display *dpy UNUSED)\n{\n    /* This function should not return, it causes exit().  Longjump instead. */\n    LONGJMP(lc_jump_env, 1);\n#  if defined(VMS) || defined(__CYGWIN__) || defined(__CYGWIN32__)\n    return 0;  /* avoid the compiler complains about missing return value */\n#  endif\n}\n# endif\n\n/*\n * An X IO Error handler, used to catch terminal errors.\n */\nstatic int x_IOerror_handler(Display *dpy);\nstatic void may_restore_clipboard(void);\nstatic int xterm_dpy_was_reset = FALSE;\n\n    static int\nx_IOerror_handler(Display *dpy UNUSED)\n{\n    xterm_dpy = NULL;\n    xterm_dpy_was_reset = TRUE;\n    x11_window = 0;\n    x11_display = NULL;\n    xterm_Shell = (Widget)0;\n\n    /* This function should not return, it causes exit().  Longjump instead. */\n    LONGJMP(x_jump_env, 1);\n# if defined(VMS) || defined(__CYGWIN__) || defined(__CYGWIN32__)\n    return 0;  /* avoid the compiler complains about missing return value */\n# endif\n}\n\n/*\n * If the X11 connection was lost try to restore it.\n * Helps when the X11 server was stopped and restarted while Vim was inactive\n * (e.g. through tmux).\n */\n    static void\nmay_restore_clipboard(void)\n{\n    if (xterm_dpy_was_reset)\n    {\n\txterm_dpy_was_reset = FALSE;\n\n# ifndef LESSTIF_VERSION\n\t/* This has been reported to avoid Vim getting stuck. */\n\tif (app_context != (XtAppContext)NULL)\n\t{\n\t    XtDestroyApplicationContext(app_context);\n\t    app_context = (XtAppContext)NULL;\n\t    x11_display = NULL; /* freed by XtDestroyApplicationContext() */\n\t}\n# endif\n\n\tsetup_term_clip();\n\tget_x11_title(FALSE);\n    }\n}\n#endif\n\n/*\n * Return TRUE when connection to the X server is desired.\n */\n    static int\nx_connect_to_server(void)\n{\n#if defined(FEAT_CLIENTSERVER)\n    if (x_force_connect)\n\treturn TRUE;\n#endif\n    if (x_no_connect)\n\treturn FALSE;\n\n    /* Check for a match with \"exclude:\" from 'clipboard'. */\n    if (clip_exclude_prog != NULL)\n    {\n\tif (vim_regexec_prog(&clip_exclude_prog, FALSE, T_NAME, (colnr_T)0))\n\t    return FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Test if \"dpy\" and x11_window are valid by getting the window title.\n * I don't actually want it yet, so there may be a simpler call to use, but\n * this will cause the error handler x_error_check() to be called if anything\n * is wrong, such as the window pointer being invalid (as can happen when the\n * user changes his DISPLAY, but not his WINDOWID) -- webb\n */\n    static int\ntest_x11_window(Display *dpy)\n{\n    int\t\t\t(*old_handler)();\n    XTextProperty\ttext_prop;\n\n    old_handler = XSetErrorHandler(x_error_check);\n    got_x_error = FALSE;\n    if (XGetWMName(dpy, x11_window, &text_prop))\n\tXFree((void *)text_prop.value);\n    XSync(dpy, False);\n    (void)XSetErrorHandler(old_handler);\n\n    if (p_verbose > 0 && got_x_error)\n\tverb_msg((char_u *)_(\"Testing the X display failed\"));\n\n    return (got_x_error ? FAIL : OK);\n}\n#endif\n\n#ifdef FEAT_TITLE\n\n#ifdef FEAT_X11\n\nstatic int get_x11_thing(int get_title, int test_only);\n\n/*\n * try to get x11 window and display\n *\n * return FAIL for failure, OK otherwise\n */\n    static int\nget_x11_windis(void)\n{\n    char\t    *winid;\n    static int\t    result = -1;\n#define XD_NONE\t 0\t/* x11_display not set here */\n#define XD_HERE\t 1\t/* x11_display opened here */\n#define XD_GUI\t 2\t/* x11_display used from gui.dpy */\n#define XD_XTERM 3\t/* x11_display used from xterm_dpy */\n    static int\t    x11_display_from = XD_NONE;\n    static int\t    did_set_error_handler = FALSE;\n\n    if (!did_set_error_handler)\n    {\n\t/* X just exits if it finds an error otherwise! */\n\t(void)XSetErrorHandler(x_error_handler);\n\tdid_set_error_handler = TRUE;\n    }\n\n#if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK)\n    if (gui.in_use)\n    {\n\t/*\n\t * If the X11 display was opened here before, for the window where Vim\n\t * was started, close that one now to avoid a memory leak.\n\t */\n\tif (x11_display_from == XD_HERE && x11_display != NULL)\n\t{\n\t    XCloseDisplay(x11_display);\n\t    x11_display_from = XD_NONE;\n\t}\n\tif (gui_get_x11_windis(&x11_window, &x11_display) == OK)\n\t{\n\t    x11_display_from = XD_GUI;\n\t    return OK;\n\t}\n\tx11_display = NULL;\n\treturn FAIL;\n    }\n    else if (x11_display_from == XD_GUI)\n    {\n\t/* GUI must have stopped somehow, clear x11_display */\n\tx11_window = 0;\n\tx11_display = NULL;\n\tx11_display_from = XD_NONE;\n    }\n#endif\n\n    /* When started with the \"-X\" argument, don't try connecting. */\n    if (!x_connect_to_server())\n\treturn FAIL;\n\n    /*\n     * If WINDOWID not set, should try another method to find out\n     * what the current window number is. The only code I know for\n     * this is very complicated.\n     * We assume that zero is invalid for WINDOWID.\n     */\n    if (x11_window == 0 && (winid = getenv(\"WINDOWID\")) != NULL)\n\tx11_window = (Window)atol(winid);\n\n#ifdef FEAT_XCLIPBOARD\n    if (xterm_dpy != NULL && x11_window != 0)\n    {\n\t/* We may have checked it already, but Gnome terminal can move us to\n\t * another window, so we need to check every time. */\n\tif (x11_display_from != XD_XTERM)\n\t{\n\t    /*\n\t     * If the X11 display was opened here before, for the window where\n\t     * Vim was started, close that one now to avoid a memory leak.\n\t     */\n\t    if (x11_display_from == XD_HERE && x11_display != NULL)\n\t\tXCloseDisplay(x11_display);\n\t    x11_display = xterm_dpy;\n\t    x11_display_from = XD_XTERM;\n\t}\n\tif (test_x11_window(x11_display) == FAIL)\n\t{\n\t    /* probably bad $WINDOWID */\n\t    x11_window = 0;\n\t    x11_display = NULL;\n\t    x11_display_from = XD_NONE;\n\t    return FAIL;\n\t}\n\treturn OK;\n    }\n#endif\n\n    if (x11_window == 0 || x11_display == NULL)\n\tresult = -1;\n\n    if (result != -1)\t    /* Have already been here and set this */\n\treturn result;\t    /* Don't do all these X calls again */\n\n    if (x11_window != 0 && x11_display == NULL)\n    {\n#ifdef SET_SIG_ALARM\n\tRETSIGTYPE (*sig_save)();\n#endif\n#if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)\n\tstruct timeval  start_tv;\n\n\tif (p_verbose > 0)\n\t    gettimeofday(&start_tv, NULL);\n#endif\n\n#ifdef SET_SIG_ALARM\n\t/*\n\t * Opening the Display may hang if the DISPLAY setting is wrong, or\n\t * the network connection is bad.  Set an alarm timer to get out.\n\t */\n\tsig_alarm_called = FALSE;\n\tsig_save = (RETSIGTYPE (*)())signal(SIGALRM,\n\t\t\t\t\t\t (RETSIGTYPE (*)())sig_alarm);\n\talarm(2);\n#endif\n\tx11_display = XOpenDisplay(NULL);\n\n#ifdef SET_SIG_ALARM\n\talarm(0);\n\tsignal(SIGALRM, (RETSIGTYPE (*)())sig_save);\n\tif (p_verbose > 0 && sig_alarm_called)\n\t    verb_msg((char_u *)_(\"Opening the X display timed out\"));\n#endif\n\tif (x11_display != NULL)\n\t{\n# ifdef ELAPSED_FUNC\n\t    if (p_verbose > 0)\n\t    {\n\t\tverbose_enter();\n\t\txopen_message(ELAPSED_FUNC(start_tv));\n\t\tverbose_leave();\n\t    }\n# endif\n\t    if (test_x11_window(x11_display) == FAIL)\n\t    {\n\t\t/* Maybe window id is bad */\n\t\tx11_window = 0;\n\t\tXCloseDisplay(x11_display);\n\t\tx11_display = NULL;\n\t    }\n\t    else\n\t\tx11_display_from = XD_HERE;\n\t}\n    }\n    if (x11_window == 0 || x11_display == NULL)\n\treturn (result = FAIL);\n\n# ifdef FEAT_EVAL\n    set_vim_var_nr(VV_WINDOWID, (long)x11_window);\n# endif\n\n    return (result = OK);\n}\n\n/*\n * Determine original x11 Window Title\n */\n    static int\nget_x11_title(int test_only)\n{\n    return get_x11_thing(TRUE, test_only);\n}\n\n/*\n * Determine original x11 Window icon\n */\n    static int\nget_x11_icon(int test_only)\n{\n    int\t\tretval = FALSE;\n\n    retval = get_x11_thing(FALSE, test_only);\n\n    /* could not get old icon, use terminal name */\n    if (oldicon == NULL && !test_only)\n    {\n\tif (STRNCMP(T_NAME, \"builtin_\", 8) == 0)\n\t    oldicon = vim_strsave(T_NAME + 8);\n\telse\n\t    oldicon = vim_strsave(T_NAME);\n    }\n\n    return retval;\n}\n\n    static int\nget_x11_thing(\n    int\t\tget_title,\t/* get title string */\n    int\t\ttest_only)\n{\n    XTextProperty\ttext_prop;\n    int\t\t\tretval = FALSE;\n    Status\t\tstatus;\n\n    if (get_x11_windis() == OK)\n    {\n\t/* Get window/icon name if any */\n\tif (get_title)\n\t    status = XGetWMName(x11_display, x11_window, &text_prop);\n\telse\n\t    status = XGetWMIconName(x11_display, x11_window, &text_prop);\n\n\t/*\n\t * If terminal is xterm, then x11_window may be a child window of the\n\t * outer xterm window that actually contains the window/icon name, so\n\t * keep traversing up the tree until a window with a title/icon is\n\t * found.\n\t */\n\t/* Previously this was only done for xterm and alikes.  I don't see a\n\t * reason why it would fail for other terminal emulators.\n\t * if (term_is_xterm) */\n\t{\n\t    Window\t    root;\n\t    Window\t    parent;\n\t    Window\t    win = x11_window;\n\t    Window\t   *children;\n\t    unsigned int    num_children;\n\n\t    while (!status || text_prop.value == NULL)\n\t    {\n\t\tif (!XQueryTree(x11_display, win, &root, &parent, &children,\n\t\t\t\t\t\t\t       &num_children))\n\t\t    break;\n\t\tif (children)\n\t\t    XFree((void *)children);\n\t\tif (parent == root || parent == 0)\n\t\t    break;\n\n\t\twin = parent;\n\t\tif (get_title)\n\t\t    status = XGetWMName(x11_display, win, &text_prop);\n\t\telse\n\t\t    status = XGetWMIconName(x11_display, win, &text_prop);\n\t    }\n\t}\n\tif (status && text_prop.value != NULL)\n\t{\n\t    retval = TRUE;\n\t    if (!test_only)\n\t    {\n#if defined(FEAT_XFONTSET) || defined(FEAT_MBYTE)\n\t\tif (text_prop.encoding == XA_STRING\n# ifdef FEAT_MBYTE\n\t\t\t&& !has_mbyte\n# endif\n\t\t\t)\n\t\t{\n#endif\n\t\t    if (get_title)\n\t\t\toldtitle = vim_strsave((char_u *)text_prop.value);\n\t\t    else\n\t\t\toldicon = vim_strsave((char_u *)text_prop.value);\n#if defined(FEAT_XFONTSET) || defined(FEAT_MBYTE)\n\t\t}\n\t\telse\n\t\t{\n\t\t    char    **cl;\n\t\t    Status  transform_status;\n\t\t    int\t    n = 0;\n\n\t\t    transform_status = XmbTextPropertyToTextList(x11_display,\n\t\t\t\t\t\t\t\t &text_prop,\n\t\t\t\t\t\t\t\t &cl, &n);\n\t\t    if (transform_status >= Success && n > 0 && cl[0])\n\t\t    {\n\t\t\tif (get_title)\n\t\t\t    oldtitle = vim_strsave((char_u *) cl[0]);\n\t\t\telse\n\t\t\t    oldicon = vim_strsave((char_u *) cl[0]);\n\t\t\tXFreeStringList(cl);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (get_title)\n\t\t\t    oldtitle = vim_strsave((char_u *)text_prop.value);\n\t\t\telse\n\t\t\t    oldicon = vim_strsave((char_u *)text_prop.value);\n\t\t    }\n\t\t}\n#endif\n\t    }\n\t    XFree((void *)text_prop.value);\n\t}\n    }\n    return retval;\n}\n\n/* Xutf8 functions are not avaialble on older systems. Note that on some\n * systems X_HAVE_UTF8_STRING may be defined in a header file but\n * Xutf8SetWMProperties() is not in the X11 library.  Configure checks for\n * that and defines HAVE_XUTF8SETWMPROPERTIES. */\n#if defined(X_HAVE_UTF8_STRING) && defined(FEAT_MBYTE)\n# if X_HAVE_UTF8_STRING && HAVE_XUTF8SETWMPROPERTIES\n#  define USE_UTF8_STRING\n# endif\n#endif\n\n/*\n * Set x11 Window Title\n *\n * get_x11_windis() must be called before this and have returned OK\n */\n    static void\nset_x11_title(char_u *title)\n{\n\t/* XmbSetWMProperties() and Xutf8SetWMProperties() should use a STRING\n\t * when possible, COMPOUND_TEXT otherwise.  COMPOUND_TEXT isn't\n\t * supported everywhere and STRING doesn't work for multi-byte titles.\n\t */\n#ifdef USE_UTF8_STRING\n    if (enc_utf8)\n\tXutf8SetWMProperties(x11_display, x11_window, (const char *)title,\n\t\t\t\t\t     NULL, NULL, 0, NULL, NULL, NULL);\n    else\n#endif\n    {\n#if XtSpecificationRelease >= 4\n# ifdef FEAT_XFONTSET\n\tXmbSetWMProperties(x11_display, x11_window, (const char *)title,\n\t\t\t\t\t     NULL, NULL, 0, NULL, NULL, NULL);\n# else\n\tXTextProperty\ttext_prop;\n\tchar\t\t*c_title = (char *)title;\n\n\t/* directly from example 3-18 \"basicwin\" of Xlib Programming Manual */\n\t(void)XStringListToTextProperty(&c_title, 1, &text_prop);\n\tXSetWMProperties(x11_display, x11_window, &text_prop,\n\t\t\t\t\t     NULL, NULL, 0, NULL, NULL, NULL);\n# endif\n#else\n\tXStoreName(x11_display, x11_window, (char *)title);\n#endif\n    }\n    XFlush(x11_display);\n}\n\n/*\n * Set x11 Window icon\n *\n * get_x11_windis() must be called before this and have returned OK\n */\n    static void\nset_x11_icon(char_u *icon)\n{\n    /* See above for comments about using X*SetWMProperties(). */\n#ifdef USE_UTF8_STRING\n    if (enc_utf8)\n\tXutf8SetWMProperties(x11_display, x11_window, NULL, (const char *)icon,\n\t\t\t\t\t\t   NULL, 0, NULL, NULL, NULL);\n    else\n#endif\n    {\n#if XtSpecificationRelease >= 4\n# ifdef FEAT_XFONTSET\n\tXmbSetWMProperties(x11_display, x11_window, NULL, (const char *)icon,\n\t\t\t\t\t\t   NULL, 0, NULL, NULL, NULL);\n# else\n\tXTextProperty\ttext_prop;\n\tchar\t\t*c_icon = (char *)icon;\n\n\t(void)XStringListToTextProperty(&c_icon, 1, &text_prop);\n\tXSetWMProperties(x11_display, x11_window, NULL, &text_prop,\n\t\t\t\t\t\t   NULL, 0, NULL, NULL, NULL);\n# endif\n#else\n\tXSetIconName(x11_display, x11_window, (char *)icon);\n#endif\n    }\n    XFlush(x11_display);\n}\n\n#else  /* FEAT_X11 */\n\n    static int\nget_x11_title(int test_only UNUSED)\n{\n    return FALSE;\n}\n\n    static int\nget_x11_icon(int test_only)\n{\n    if (!test_only)\n    {\n\tif (STRNCMP(T_NAME, \"builtin_\", 8) == 0)\n\t    oldicon = vim_strsave(T_NAME + 8);\n\telse\n\t    oldicon = vim_strsave(T_NAME);\n    }\n    return FALSE;\n}\n\n#endif /* FEAT_X11 */\n\n    int\nmch_can_restore_title(void)\n{\n    return get_x11_title(TRUE);\n}\n\n    int\nmch_can_restore_icon(void)\n{\n    return get_x11_icon(TRUE);\n}\n\n/*\n * Set the window title and icon.\n */\n    void\nmch_settitle(char_u *title, char_u *icon)\n{\n    int\t\ttype = 0;\n    static int\trecursive = 0;\n\n    if (T_NAME == NULL)\t    /* no terminal name (yet) */\n\treturn;\n    if (title == NULL && icon == NULL)\t    /* nothing to do */\n\treturn;\n\n    /* When one of the X11 functions causes a deadly signal, we get here again\n     * recursively.  Avoid hanging then (something is probably locked). */\n    if (recursive)\n\treturn;\n    ++recursive;\n\n    /*\n     * if the window ID and the display is known, we may use X11 calls\n     */\n#ifdef FEAT_X11\n    if (get_x11_windis() == OK)\n\ttype = 1;\n#else\n# if defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_GTK)\n    if (gui.in_use)\n\ttype = 1;\n# endif\n#endif\n\n    /*\n     * Note: if \"t_ts\" is set, title is set with escape sequence rather\n     *\t     than x11 calls, because the x11 calls don't always work\n     */\n    if ((type || *T_TS != NUL) && title != NULL)\n    {\n\tif (oldtitle == NULL\n#ifdef FEAT_GUI\n\t\t&& !gui.in_use\n#endif\n\t\t)\t\t/* first call but not in GUI, save title */\n\t    (void)get_x11_title(FALSE);\n\n\tif (*T_TS != NUL)\t\t/* it's OK if t_fs is empty */\n\t    term_settitle(title);\n#ifdef FEAT_X11\n\telse\n# ifdef FEAT_GUI_GTK\n\tif (!gui.in_use)\t\t/* don't do this if GTK+ is running */\n# endif\n\t    set_x11_title(title);\t\t/* x11 */\n#endif\n#if defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC)\n\telse\n\t    gui_mch_settitle(title, icon);\n#endif\n\tdid_set_title = TRUE;\n    }\n\n    if ((type || *T_CIS != NUL) && icon != NULL)\n    {\n\tif (oldicon == NULL\n#ifdef FEAT_GUI\n\t\t&& !gui.in_use\n#endif\n\t\t)\t\t/* first call, save icon */\n\t    get_x11_icon(FALSE);\n\n\tif (*T_CIS != NUL)\n\t{\n\t    out_str(T_CIS);\t\t\t/* set icon start */\n\t    out_str_nf(icon);\n\t    out_str(T_CIE);\t\t\t/* set icon end */\n\t    out_flush();\n\t}\n#ifdef FEAT_X11\n\telse\n# ifdef FEAT_GUI_GTK\n\tif (!gui.in_use)\t\t/* don't do this if GTK+ is running */\n# endif\n\t    set_x11_icon(icon);\t\t\t/* x11 */\n#endif\n\tdid_set_icon = TRUE;\n    }\n    --recursive;\n}\n\n/*\n * Restore the window/icon title.\n * \"which\" is one of:\n *  1  only restore title\n *  2  only restore icon\n *  3  restore title and icon\n */\n    void\nmch_restore_title(int which)\n{\n    /* only restore the title or icon when it has been set */\n    mch_settitle(((which & 1) && did_set_title) ?\n\t\t\t(oldtitle ? oldtitle : p_titleold) : NULL,\n\t\t\t      ((which & 2) && did_set_icon) ? oldicon : NULL);\n}\n\n#endif /* FEAT_TITLE */\n\n/*\n * Return TRUE if \"name\" looks like some xterm name.\n * Seiichi Sato mentioned that \"mlterm\" works like xterm.\n */\n    int\nvim_is_xterm(char_u *name)\n{\n    if (name == NULL)\n\treturn FALSE;\n    return (STRNICMP(name, \"xterm\", 5) == 0\n\t\t|| STRNICMP(name, \"nxterm\", 6) == 0\n\t\t|| STRNICMP(name, \"kterm\", 5) == 0\n\t\t|| STRNICMP(name, \"mlterm\", 6) == 0\n\t\t|| STRNICMP(name, \"rxvt\", 4) == 0\n\t\t|| STRCMP(name, \"builtin_xterm\") == 0);\n}\n\n#if defined(FEAT_MOUSE_XTERM) || defined(PROTO)\n/*\n * Return TRUE if \"name\" appears to be that of a terminal\n * known to support the xterm-style mouse protocol.\n * Relies on term_is_xterm having been set to its correct value.\n */\n    int\nuse_xterm_like_mouse(char_u *name)\n{\n    return (name != NULL\n\t    && (term_is_xterm\n\t\t|| STRNICMP(name, \"screen\", 6) == 0\n\t\t|| STRNICMP(name, \"tmux\", 4) == 0\n\t\t|| STRICMP(name, \"st\") == 0\n\t\t|| STRNICMP(name, \"st-\", 3) == 0\n\t\t|| STRNICMP(name, \"stterm\", 6) == 0));\n}\n#endif\n\n#if defined(FEAT_MOUSE_TTY) || defined(PROTO)\n/*\n * Return non-zero when using an xterm mouse, according to 'ttymouse'.\n * Return 1 for \"xterm\".\n * Return 2 for \"xterm2\".\n * Return 3 for \"urxvt\".\n * Return 4 for \"sgr\".\n */\n    int\nuse_xterm_mouse(void)\n{\n    if (ttym_flags == TTYM_SGR)\n\treturn 4;\n    if (ttym_flags == TTYM_URXVT)\n\treturn 3;\n    if (ttym_flags == TTYM_XTERM2)\n\treturn 2;\n    if (ttym_flags == TTYM_XTERM)\n\treturn 1;\n    return 0;\n}\n#endif\n\n    int\nvim_is_iris(char_u *name)\n{\n    if (name == NULL)\n\treturn FALSE;\n    return (STRNICMP(name, \"iris-ansi\", 9) == 0\n\t    || STRCMP(name, \"builtin_iris-ansi\") == 0);\n}\n\n    int\nvim_is_vt300(char_u *name)\n{\n    if (name == NULL)\n\treturn FALSE;\t       /* actually all ANSI comp. terminals should be here  */\n    /* catch VT100 - VT5xx */\n    return ((STRNICMP(name, \"vt\", 2) == 0\n\t\t&& vim_strchr((char_u *)\"12345\", name[2]) != NULL)\n\t    || STRCMP(name, \"builtin_vt320\") == 0);\n}\n\n/*\n * Return TRUE if \"name\" is a terminal for which 'ttyfast' should be set.\n * This should include all windowed terminal emulators.\n */\n    int\nvim_is_fastterm(char_u *name)\n{\n    if (name == NULL)\n\treturn FALSE;\n    if (vim_is_xterm(name) || vim_is_vt300(name) || vim_is_iris(name))\n\treturn TRUE;\n    return (   STRNICMP(name, \"hpterm\", 6) == 0\n\t    || STRNICMP(name, \"sun-cmd\", 7) == 0\n\t    || STRNICMP(name, \"screen\", 6) == 0\n\t    || STRNICMP(name, \"tmux\", 4) == 0\n\t    || STRNICMP(name, \"dtterm\", 6) == 0);\n}\n\n/*\n * Insert user name in s[len].\n * Return OK if a name found.\n */\n    int\nmch_get_user_name(char_u *s, int len)\n{\n#ifdef VMS\n    vim_strncpy(s, (char_u *)cuserid(NULL), len - 1);\n    return OK;\n#else\n    return mch_get_uname(getuid(), s, len);\n#endif\n}\n\n/*\n * Insert user name for \"uid\" in s[len].\n * Return OK if a name found.\n */\n    int\nmch_get_uname(uid_t uid, char_u *s, int len)\n{\n#if defined(HAVE_PWD_H) && defined(HAVE_GETPWUID)\n    struct passwd   *pw;\n\n    if ((pw = getpwuid(uid)) != NULL\n\t    && pw->pw_name != NULL && *(pw->pw_name) != NUL)\n    {\n\tvim_strncpy(s, (char_u *)pw->pw_name, len - 1);\n\treturn OK;\n    }\n#endif\n    sprintf((char *)s, \"%d\", (int)uid);\t    /* assumes s is long enough */\n    return FAIL;\t\t\t    /* a number is not a name */\n}\n\n/*\n * Insert host name is s[len].\n */\n\n#ifdef HAVE_SYS_UTSNAME_H\n    void\nmch_get_host_name(char_u *s, int len)\n{\n    struct utsname vutsname;\n\n    if (uname(&vutsname) < 0)\n\t*s = NUL;\n    else\n\tvim_strncpy(s, (char_u *)vutsname.nodename, len - 1);\n}\n#else /* HAVE_SYS_UTSNAME_H */\n\n# ifdef HAVE_SYS_SYSTEMINFO_H\n#  define gethostname(nam, len) sysinfo(SI_HOSTNAME, nam, len)\n# endif\n\n    void\nmch_get_host_name(char_u *s, int len)\n{\n# ifdef VAXC\n    vaxc$gethostname((char *)s, len);\n# else\n    gethostname((char *)s, len);\n# endif\n    s[len - 1] = NUL;\t/* make sure it's terminated */\n}\n#endif /* HAVE_SYS_UTSNAME_H */\n\n/*\n * return process ID\n */\n    long\nmch_get_pid(void)\n{\n    return (long)getpid();\n}\n\n#if !defined(HAVE_STRERROR) && defined(USE_GETCWD)\nstatic char *strerror(int);\n\n    static char *\nstrerror(int err)\n{\n    extern int\t    sys_nerr;\n    extern char\t    *sys_errlist[];\n    static char\t    er[20];\n\n    if (err > 0 && err < sys_nerr)\n\treturn (sys_errlist[err]);\n    sprintf(er, \"Error %d\", err);\n    return er;\n}\n#endif\n\n/*\n * Get name of current directory into buffer 'buf' of length 'len' bytes.\n * Return OK for success, FAIL for failure.\n */\n    int\nmch_dirname(char_u *buf, int len)\n{\n#if defined(USE_GETCWD)\n    if (getcwd((char *)buf, len) == NULL)\n    {\n\tSTRCPY(buf, strerror(errno));\n\treturn FAIL;\n    }\n    return OK;\n#else\n    return (getwd((char *)buf) != NULL ? OK : FAIL);\n#endif\n}\n\n/*\n * Get absolute file name into \"buf[len]\".\n *\n * return FAIL for failure, OK for success\n */\n    int\nmch_FullName(\n    char_u\t*fname,\n    char_u\t*buf,\n    int\t\tlen,\n    int\t\tforce)\t\t/* also expand when already absolute path */\n{\n    int\t\tl;\n#ifdef HAVE_FCHDIR\n    int\t\tfd = -1;\n    static int\tdont_fchdir = FALSE;\t/* TRUE when fchdir() doesn't work */\n#endif\n    char_u\tolddir[MAXPATHL];\n    char_u\t*p;\n    int\t\tretval = OK;\n#ifdef __CYGWIN__\n    char_u\tposix_fname[MAXPATHL];\t/* Cygwin docs mention MAX_PATH, but\n\t\t\t\t\t   it's not always defined */\n#endif\n\n#ifdef VMS\n    fname = vms_fixfilename(fname);\n#endif\n\n#ifdef __CYGWIN__\n    /*\n     * This helps for when \"/etc/hosts\" is a symlink to \"c:/something/hosts\".\n     */\n# if CYGWIN_VERSION_DLL_MAJOR >= 1007\n    /* Use CCP_RELATIVE to avoid that it sometimes returns a path that ends in\n     * a forward slash. */\n    cygwin_conv_path(CCP_WIN_A_TO_POSIX | CCP_RELATIVE,\n\t\t     fname, posix_fname, MAXPATHL);\n# else\n    cygwin_conv_to_posix_path(fname, posix_fname);\n# endif\n    fname = posix_fname;\n#endif\n\n    /* Expand it if forced or not an absolute path.\n     * Do not do it for \"/file\", the result is always \"/\". */\n    if ((force || !mch_isFullName(fname))\n\t    && ((p = vim_strrchr(fname, '/')) == NULL || p != fname))\n    {\n\t/*\n\t * If the file name has a path, change to that directory for a moment,\n\t * and then do the getwd() (and get back to where we were).\n\t * This will get the correct path name with \"../\" things.\n\t */\n\tif (p != NULL)\n\t{\n#ifdef HAVE_FCHDIR\n\t    /*\n\t     * Use fchdir() if possible, it's said to be faster and more\n\t     * reliable.  But on SunOS 4 it might not work.  Check this by\n\t     * doing a fchdir() right now.\n\t     */\n\t    if (!dont_fchdir)\n\t    {\n\t\tfd = open(\".\", O_RDONLY | O_EXTRA, 0);\n\t\tif (fd >= 0 && fchdir(fd) < 0)\n\t\t{\n\t\t    close(fd);\n\t\t    fd = -1;\n\t\t    dont_fchdir = TRUE;\t    /* don't try again */\n\t\t}\n\t    }\n#endif\n\n\t    /* Only change directory when we are sure we can return to where\n\t     * we are now.  After doing \"su\" chdir(\".\") might not work. */\n\t    if (\n#ifdef HAVE_FCHDIR\n\t\tfd < 0 &&\n#endif\n\t\t\t(mch_dirname(olddir, MAXPATHL) == FAIL\n\t\t\t\t\t   || mch_chdir((char *)olddir) != 0))\n\t    {\n\t\tp = NULL;\t/* can't get current dir: don't chdir */\n\t\tretval = FAIL;\n\t    }\n\t    else\n\t    {\n\t\t/* The directory is copied into buf[], to be able to remove\n\t\t * the file name without changing it (could be a string in\n\t\t * read-only memory) */\n\t\tif (p - fname >= len)\n\t\t    retval = FAIL;\n\t\telse\n\t\t{\n\t\t    vim_strncpy(buf, fname, p - fname);\n\t\t    if (mch_chdir((char *)buf))\n\t\t\tretval = FAIL;\n\t\t    else\n\t\t\tfname = p + 1;\n\t\t    *buf = NUL;\n\t\t}\n\t    }\n\t}\n\tif (mch_dirname(buf, len) == FAIL)\n\t{\n\t    retval = FAIL;\n\t    *buf = NUL;\n\t}\n\tif (p != NULL)\n\t{\n#ifdef HAVE_FCHDIR\n\t    if (fd >= 0)\n\t    {\n\t\tif (p_verbose >= 5)\n\t\t{\n\t\t    verbose_enter();\n\t\t    MSG(\"fchdir() to previous dir\");\n\t\t    verbose_leave();\n\t\t}\n\t\tl = fchdir(fd);\n\t\tclose(fd);\n\t    }\n\t    else\n#endif\n\t\tl = mch_chdir((char *)olddir);\n\t    if (l != 0)\n\t\tEMSG(_(e_prev_dir));\n\t}\n\n\tl = STRLEN(buf);\n\tif (l >= len - 1)\n\t    retval = FAIL; /* no space for trailing \"/\" */\n#ifndef VMS\n\telse if (l > 0 && buf[l - 1] != '/' && *fname != NUL\n\t\t\t\t\t\t   && STRCMP(fname, \".\") != 0)\n\t    STRCAT(buf, \"/\");\n#endif\n    }\n\n    /* Catch file names which are too long. */\n    if (retval == FAIL || (int)(STRLEN(buf) + STRLEN(fname)) >= len)\n\treturn FAIL;\n\n    /* Do not append \".\", \"/dir/.\" is equal to \"/dir\". */\n    if (STRCMP(fname, \".\") != 0)\n\tSTRCAT(buf, fname);\n\n    return OK;\n}\n\n/*\n * Return TRUE if \"fname\" does not depend on the current directory.\n */\n    int\nmch_isFullName(char_u *fname)\n{\n#ifdef VMS\n    return ( fname[0] == '/'\t       || fname[0] == '.'\t    ||\n\t     strchr((char *)fname,':') || strchr((char *)fname,'\"') ||\n\t    (strchr((char *)fname,'[') && strchr((char *)fname,']'))||\n\t    (strchr((char *)fname,'<') && strchr((char *)fname,'>'))   );\n#else\n    return (*fname == '/' || *fname == '~');\n#endif\n}\n\n#if defined(USE_FNAME_CASE) || defined(PROTO)\n/*\n * Set the case of the file name, if it already exists.  This will cause the\n * file name to remain exactly the same.\n * Only required for file systems where case is ignored and preserved.\n */\n    void\nfname_case(\n    char_u\t*name,\n    int\t\tlen UNUSED)  /* buffer size, only used when name gets longer */\n{\n    struct stat st;\n    char_u\t*slash, *tail;\n    DIR\t\t*dirp;\n    struct dirent *dp;\n\n    if (mch_lstat((char *)name, &st) >= 0)\n    {\n\t/* Open the directory where the file is located. */\n\tslash = vim_strrchr(name, '/');\n\tif (slash == NULL)\n\t{\n\t    dirp = opendir(\".\");\n\t    tail = name;\n\t}\n\telse\n\t{\n\t    *slash = NUL;\n\t    dirp = opendir((char *)name);\n\t    *slash = '/';\n\t    tail = slash + 1;\n\t}\n\n\tif (dirp != NULL)\n\t{\n\t    while ((dp = readdir(dirp)) != NULL)\n\t    {\n\t\t/* Only accept names that differ in case and are the same byte\n\t\t * length. TODO: accept different length name. */\n\t\tif (STRICMP(tail, dp->d_name) == 0\n\t\t\t&& STRLEN(tail) == STRLEN(dp->d_name))\n\t\t{\n\t\t    char_u\tnewname[MAXPATHL + 1];\n\t\t    struct stat st2;\n\n\t\t    /* Verify the inode is equal. */\n\t\t    vim_strncpy(newname, name, MAXPATHL);\n\t\t    vim_strncpy(newname + (tail - name), (char_u *)dp->d_name,\n\t\t\t\t\t\t    MAXPATHL - (tail - name));\n\t\t    if (mch_lstat((char *)newname, &st2) >= 0\n\t\t\t    && st.st_ino == st2.st_ino\n\t\t\t    && st.st_dev == st2.st_dev)\n\t\t    {\n\t\t\tSTRCPY(tail, dp->d_name);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    closedir(dirp);\n\t}\n    }\n}\n#endif\n\n/*\n * Get file permissions for 'name'.\n * Returns -1 when it doesn't exist.\n */\n    long\nmch_getperm(char_u *name)\n{\n    struct stat statb;\n\n    /* Keep the #ifdef outside of stat(), it may be a macro. */\n#ifdef VMS\n    if (stat((char *)vms_fixfilename(name), &statb))\n#else\n    if (stat((char *)name, &statb))\n#endif\n\treturn -1;\n#ifdef __INTERIX\n    /* The top bit makes the value negative, which means the file doesn't\n     * exist.  Remove the bit, we don't use it. */\n    return statb.st_mode & ~S_ADDACE;\n#else\n    return statb.st_mode;\n#endif\n}\n\n/*\n * set file permission for 'name' to 'perm'\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nmch_setperm(char_u *name, long perm)\n{\n    return (chmod((char *)\n#ifdef VMS\n\t\t    vms_fixfilename(name),\n#else\n\t\t    name,\n#endif\n\t\t    (mode_t)perm) == 0 ? OK : FAIL);\n}\n\n#if defined(HAVE_ACL) || defined(PROTO)\n# ifdef HAVE_SYS_ACL_H\n#  include <sys/acl.h>\n# endif\n# ifdef HAVE_SYS_ACCESS_H\n#  include <sys/access.h>\n# endif\n\n# ifdef HAVE_SOLARIS_ACL\ntypedef struct vim_acl_solaris_T {\n    int acl_cnt;\n    aclent_t *acl_entry;\n} vim_acl_solaris_T;\n# endif\n\n#if defined(HAVE_SELINUX) || defined(PROTO)\n/*\n * Copy security info from \"from_file\" to \"to_file\".\n */\n    void\nmch_copy_sec(char_u *from_file, char_u *to_file)\n{\n    if (from_file == NULL)\n\treturn;\n\n    if (selinux_enabled == -1)\n\tselinux_enabled = is_selinux_enabled();\n\n    if (selinux_enabled > 0)\n    {\n\tsecurity_context_t from_context = NULL;\n\tsecurity_context_t to_context = NULL;\n\n\tif (getfilecon((char *)from_file, &from_context) < 0)\n\t{\n\t    /* If the filesystem doesn't support extended attributes,\n\t       the original had no special security context and the\n\t       target cannot have one either.  */\n\t    if (errno == EOPNOTSUPP)\n\t\treturn;\n\n\t    MSG_PUTS(_(\"\\nCould not get security context for \"));\n\t    msg_outtrans(from_file);\n\t    msg_putchar('\\n');\n\t    return;\n\t}\n\tif (getfilecon((char *)to_file, &to_context) < 0)\n\t{\n\t    MSG_PUTS(_(\"\\nCould not get security context for \"));\n\t    msg_outtrans(to_file);\n\t    msg_putchar('\\n');\n\t    freecon (from_context);\n\t    return ;\n\t}\n\tif (strcmp(from_context, to_context) != 0)\n\t{\n\t    if (setfilecon((char *)to_file, from_context) < 0)\n\t    {\n\t\tMSG_PUTS(_(\"\\nCould not set security context for \"));\n\t\tmsg_outtrans(to_file);\n\t\tmsg_putchar('\\n');\n\t    }\n\t}\n\tfreecon(to_context);\n\tfreecon(from_context);\n    }\n}\n#endif /* HAVE_SELINUX */\n\n#if defined(HAVE_SMACK) && !defined(PROTO)\n/*\n * Copy security info from \"from_file\" to \"to_file\".\n */\n    void\nmch_copy_sec(char_u *from_file, char_u *to_file)\n{\n    static const char * const smack_copied_attributes[] =\n\t{\n\t    XATTR_NAME_SMACK,\n\t    XATTR_NAME_SMACKEXEC,\n\t    XATTR_NAME_SMACKMMAP\n\t};\n\n    char\tbuffer[SMACK_LABEL_LEN];\n    const char\t*name;\n    int\t\tindex;\n    int\t\tret;\n    ssize_t\tsize;\n\n    if (from_file == NULL)\n\treturn;\n\n    for (index = 0 ; index < (int)(sizeof(smack_copied_attributes)\n\t\t\t      / sizeof(smack_copied_attributes)[0]) ; index++)\n    {\n\t/* get the name of the attribute to copy */\n\tname = smack_copied_attributes[index];\n\n\t/* get the value of the attribute in buffer */\n\tsize = getxattr((char*)from_file, name, buffer, sizeof(buffer));\n\tif (size >= 0)\n\t{\n\t    /* copy the attribute value of buffer */\n\t    ret = setxattr((char*)to_file, name, buffer, (size_t)size, 0);\n\t    if (ret < 0)\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t_(\"Could not set security context %s for %s\"),\n\t\t\tname, to_file);\n\t\tmsg_outtrans(IObuff);\n\t\tmsg_putchar('\\n');\n\t    }\n\t}\n\telse\n\t{\n\t    /* what reason of not having the attribute value? */\n\t    switch (errno)\n\t    {\n\t\tcase ENOTSUP:\n\t\t    /* extended attributes aren't supported or enabled */\n\t\t    /* should a message be echoed? not sure... */\n\t\t    return; /* leave because it isn't usefull to continue */\n\n\t\tcase ERANGE:\n\t\tdefault:\n\t\t    /* no enough size OR unexpected error */\n\t\t     vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t    _(\"Could not get security context %s for %s. Removing it!\"),\n\t\t\t    name, from_file);\n\t\t    msg_puts(IObuff);\n\t\t    msg_putchar('\\n');\n\t\t    /* FALLTHROUGH to remove the attribute */\n\n\t\tcase ENODATA:\n\t\t    /* no attribute of this name */\n\t\t    ret = removexattr((char*)to_file, name);\n\t\t    /* Silently ignore errors, apparently this happens when\n\t\t     * smack is not actually being used. */\n\t\t    break;\n\t    }\n\t}\n    }\n}\n#endif /* HAVE_SMACK */\n\n/*\n * Return a pointer to the ACL of file \"fname\" in allocated memory.\n * Return NULL if the ACL is not available for whatever reason.\n */\n    vim_acl_T\nmch_get_acl(char_u *fname UNUSED)\n{\n    vim_acl_T\tret = NULL;\n#ifdef HAVE_POSIX_ACL\n    ret = (vim_acl_T)acl_get_file((char *)fname, ACL_TYPE_ACCESS);\n#else\n#ifdef HAVE_SOLARIS_ZFS_ACL\n    acl_t *aclent;\n\n    if (acl_get((char *)fname, 0, &aclent) < 0)\n\treturn NULL;\n    ret = (vim_acl_T)aclent;\n#else\n#ifdef HAVE_SOLARIS_ACL\n    vim_acl_solaris_T   *aclent;\n\n    aclent = malloc(sizeof(vim_acl_solaris_T));\n    if ((aclent->acl_cnt = acl((char *)fname, GETACLCNT, 0, NULL)) < 0)\n    {\n\tfree(aclent);\n\treturn NULL;\n    }\n    aclent->acl_entry = malloc(aclent->acl_cnt * sizeof(aclent_t));\n    if (acl((char *)fname, GETACL, aclent->acl_cnt, aclent->acl_entry) < 0)\n    {\n\tfree(aclent->acl_entry);\n\tfree(aclent);\n\treturn NULL;\n    }\n    ret = (vim_acl_T)aclent;\n#else\n#if defined(HAVE_AIX_ACL)\n    int\t\taclsize;\n    struct acl *aclent;\n\n    aclsize = sizeof(struct acl);\n    aclent = malloc(aclsize);\n    if (statacl((char *)fname, STX_NORMAL, aclent, aclsize) < 0)\n    {\n\tif (errno == ENOSPC)\n\t{\n\t    aclsize = aclent->acl_len;\n\t    aclent = realloc(aclent, aclsize);\n\t    if (statacl((char *)fname, STX_NORMAL, aclent, aclsize) < 0)\n\t    {\n\t\tfree(aclent);\n\t\treturn NULL;\n\t    }\n\t}\n\telse\n\t{\n\t    free(aclent);\n\t    return NULL;\n\t}\n    }\n    ret = (vim_acl_T)aclent;\n#endif /* HAVE_AIX_ACL */\n#endif /* HAVE_SOLARIS_ACL */\n#endif /* HAVE_SOLARIS_ZFS_ACL */\n#endif /* HAVE_POSIX_ACL */\n    return ret;\n}\n\n/*\n * Set the ACL of file \"fname\" to \"acl\" (unless it's NULL).\n */\n    void\nmch_set_acl(char_u *fname UNUSED, vim_acl_T aclent)\n{\n    if (aclent == NULL)\n\treturn;\n#ifdef HAVE_POSIX_ACL\n    acl_set_file((char *)fname, ACL_TYPE_ACCESS, (acl_t)aclent);\n#else\n#ifdef HAVE_SOLARIS_ZFS_ACL\n    acl_set((char *)fname, (acl_t *)aclent);\n#else\n#ifdef HAVE_SOLARIS_ACL\n    acl((char *)fname, SETACL, ((vim_acl_solaris_T *)aclent)->acl_cnt,\n\t    ((vim_acl_solaris_T *)aclent)->acl_entry);\n#else\n#ifdef HAVE_AIX_ACL\n    chacl((char *)fname, aclent, ((struct acl *)aclent)->acl_len);\n#endif /* HAVE_AIX_ACL */\n#endif /* HAVE_SOLARIS_ACL */\n#endif /* HAVE_SOLARIS_ZFS_ACL */\n#endif /* HAVE_POSIX_ACL */\n}\n\n    void\nmch_free_acl(vim_acl_T aclent)\n{\n    if (aclent == NULL)\n\treturn;\n#ifdef HAVE_POSIX_ACL\n    acl_free((acl_t)aclent);\n#else\n#ifdef HAVE_SOLARIS_ZFS_ACL\n    acl_free((acl_t *)aclent);\n#else\n#ifdef HAVE_SOLARIS_ACL\n    free(((vim_acl_solaris_T *)aclent)->acl_entry);\n    free(aclent);\n#else\n#ifdef HAVE_AIX_ACL\n    free(aclent);\n#endif /* HAVE_AIX_ACL */\n#endif /* HAVE_SOLARIS_ACL */\n#endif /* HAVE_SOLARIS_ZFS_ACL */\n#endif /* HAVE_POSIX_ACL */\n}\n#endif\n\n/*\n * Set hidden flag for \"name\".\n */\n    void\nmch_hide(char_u *name UNUSED)\n{\n    /* can't hide a file */\n}\n\n/*\n * return TRUE if \"name\" is a directory or a symlink to a directory\n * return FALSE if \"name\" is not a directory\n * return FALSE for error\n */\n    int\nmch_isdir(char_u *name)\n{\n    struct stat statb;\n\n    if (*name == NUL)\t    /* Some stat()s don't flag \"\" as an error. */\n\treturn FALSE;\n    if (stat((char *)name, &statb))\n\treturn FALSE;\n#ifdef _POSIX_SOURCE\n    return (S_ISDIR(statb.st_mode) ? TRUE : FALSE);\n#else\n    return ((statb.st_mode & S_IFMT) == S_IFDIR ? TRUE : FALSE);\n#endif\n}\n\n/*\n * return TRUE if \"name\" is a directory, NOT a symlink to a directory\n * return FALSE if \"name\" is not a directory\n * return FALSE for error\n */\n    int\nmch_isrealdir(char_u *name)\n{\n    struct stat statb;\n\n    if (*name == NUL)\t    /* Some stat()s don't flag \"\" as an error. */\n\treturn FALSE;\n    if (mch_lstat((char *)name, &statb))\n\treturn FALSE;\n#ifdef _POSIX_SOURCE\n    return (S_ISDIR(statb.st_mode) ? TRUE : FALSE);\n#else\n    return ((statb.st_mode & S_IFMT) == S_IFDIR ? TRUE : FALSE);\n#endif\n}\n\nstatic int executable_file(char_u *name);\n\n/*\n * Return 1 if \"name\" is an executable file, 0 if not or it doesn't exist.\n */\n    static int\nexecutable_file(char_u *name)\n{\n    struct stat\tst;\n\n    if (stat((char *)name, &st))\n\treturn 0;\n#ifdef VMS\n    /* Like on Unix system file can have executable rights but not necessarily\n     * be an executable, but on Unix is not a default for an ordianry file to\n     * have an executable flag - on VMS it is in most cases.\n     * Therefore, this check does not have any sense - let keep us to the\n     * conventions instead:\n     * *.COM and *.EXE files are the executables - the rest are not. This is\n     * not ideal but better then it was.\n     */\n    int vms_executable = 0;\n    if (S_ISREG(st.st_mode) && mch_access((char *)name, X_OK) == 0)\n    {\n\tif (strstr(vms_tolower((char*)name),\".exe\") != NULL\n\t\t|| strstr(vms_tolower((char*)name),\".com\")!= NULL)\n\t    vms_executable = 1;\n    }\n    return vms_executable;\n#else\n    return S_ISREG(st.st_mode) && mch_access((char *)name, X_OK) == 0;\n#endif\n}\n\n/*\n * Return TRUE if \"name\" can be found in $PATH and executed, FALSE if not.\n * If \"use_path\" is FALSE only check if \"name\" is executable.\n * Return -1 if unknown.\n */\n    int\nmch_can_exe(char_u *name, char_u **path, int use_path)\n{\n    char_u\t*buf;\n    char_u\t*p, *e;\n    int\t\tretval;\n\n    /* When \"use_path\" is false and if it's an absolute or relative path don't\n     * need to use $PATH. */\n    if (!use_path || mch_isFullName(name) || (name[0] == '.'\n\t\t   && (name[1] == '/' || (name[1] == '.' && name[2] == '/'))))\n    {\n\t/* There must be a path separator, files in the current directory\n\t * can't be executed. */\n\tif (gettail(name) != name && executable_file(name))\n\t{\n\t    if (path != NULL)\n\t    {\n\t\tif (name[0] != '/')\n\t\t    *path = FullName_save(name, TRUE);\n\t\telse\n\t\t    *path = vim_strsave(name);\n\t    }\n\t    return TRUE;\n\t}\n\treturn FALSE;\n    }\n\n    p = (char_u *)getenv(\"PATH\");\n    if (p == NULL || *p == NUL)\n\treturn -1;\n    buf = alloc((unsigned)(STRLEN(name) + STRLEN(p) + 2));\n    if (buf == NULL)\n\treturn -1;\n\n    /*\n     * Walk through all entries in $PATH to check if \"name\" exists there and\n     * is an executable file.\n     */\n    for (;;)\n    {\n\te = (char_u *)strchr((char *)p, ':');\n\tif (e == NULL)\n\t    e = p + STRLEN(p);\n\tif (e - p <= 1)\t\t/* empty entry means current dir */\n\t    STRCPY(buf, \"./\");\n\telse\n\t{\n\t    vim_strncpy(buf, p, e - p);\n\t    add_pathsep(buf);\n\t}\n\tSTRCAT(buf, name);\n\tretval = executable_file(buf);\n\tif (retval == 1)\n\t{\n\t    if (path != NULL)\n\t    {\n\t\tif (buf[0] != '/')\n\t\t    *path = FullName_save(buf, TRUE);\n\t\telse\n\t\t    *path = vim_strsave(buf);\n\t    }\n\t    break;\n\t}\n\n\tif (*e != ':')\n\t    break;\n\tp = e + 1;\n    }\n\n    vim_free(buf);\n    return retval;\n}\n\n/*\n * Check what \"name\" is:\n * NODE_NORMAL: file or directory (or doesn't exist)\n * NODE_WRITABLE: writable device, socket, fifo, etc.\n * NODE_OTHER: non-writable things\n */\n    int\nmch_nodetype(char_u *name)\n{\n    struct stat\tst;\n\n    if (stat((char *)name, &st))\n\treturn NODE_NORMAL;\n    if (S_ISREG(st.st_mode) || S_ISDIR(st.st_mode))\n\treturn NODE_NORMAL;\n    if (S_ISBLK(st.st_mode))\t/* block device isn't writable */\n\treturn NODE_OTHER;\n    /* Everything else is writable? */\n    return NODE_WRITABLE;\n}\n\n    void\nmch_early_init(void)\n{\n#ifdef HAVE_CHECK_STACK_GROWTH\n    int\t\t\ti;\n\n    check_stack_growth((char *)&i);\n\n# ifdef HAVE_STACK_LIMIT\n    get_stack_limit();\n# endif\n\n#endif\n\n    /*\n     * Setup an alternative stack for signals.  Helps to catch signals when\n     * running out of stack space.\n     * Use of sigaltstack() is preferred, it's more portable.\n     * Ignore any errors.\n     */\n#if defined(HAVE_SIGALTSTACK) || defined(HAVE_SIGSTACK)\n    signal_stack = (char *)alloc(SIGSTKSZ);\n    init_signal_stack();\n#endif\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nmch_free_mem(void)\n{\n# if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)\n    if (clip_star.owned)\n\tclip_lose_selection(&clip_star);\n    if (clip_plus.owned)\n\tclip_lose_selection(&clip_plus);\n# endif\n# if defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)\n    if (xterm_Shell != (Widget)0)\n\tXtDestroyWidget(xterm_Shell);\n#  ifndef LESSTIF_VERSION\n    /* Lesstif crashes here, lose some memory */\n    if (xterm_dpy != NULL)\n\tXtCloseDisplay(xterm_dpy);\n    if (app_context != (XtAppContext)NULL)\n    {\n\tXtDestroyApplicationContext(app_context);\n#   ifdef FEAT_X11\n\tx11_display = NULL; /* freed by XtDestroyApplicationContext() */\n#   endif\n    }\n#  endif\n# endif\n# if defined(FEAT_X11)\n    if (x11_display != NULL\n#  ifdef FEAT_XCLIPBOARD\n\t    && x11_display != xterm_dpy\n#  endif\n\t    )\n\tXCloseDisplay(x11_display);\n# endif\n# if defined(HAVE_SIGALTSTACK) || defined(HAVE_SIGSTACK)\n    vim_free(signal_stack);\n    signal_stack = NULL;\n# endif\n# ifdef FEAT_TITLE\n    vim_free(oldtitle);\n    vim_free(oldicon);\n# endif\n}\n#endif\n\nstatic void exit_scroll(void);\n\n/*\n * Output a newline when exiting.\n * Make sure the newline goes to the same stream as the text.\n */\n    static void\nexit_scroll(void)\n{\n    if (silent_mode)\n\treturn;\n    if (newline_on_exit || msg_didout)\n    {\n\tif (msg_use_printf())\n\t{\n\t    if (info_message)\n\t\tmch_msg(\"\\n\");\n\t    else\n\t\tmch_errmsg(\"\\r\\n\");\n\t}\n\telse\n\t    out_char('\\n');\n    }\n    else\n    {\n\trestore_cterm_colors();\t\t/* get original colors back */\n\tmsg_clr_eos_force();\t\t/* clear the rest of the display */\n\twindgoto((int)Rows - 1, 0);\t/* may have moved the cursor */\n    }\n}\n\n    void\nmch_exit(int r)\n{\n    exiting = TRUE;\n\n#if defined(FEAT_X11) && defined(FEAT_CLIPBOARD)\n    x11_export_final_selection();\n#endif\n\n#ifdef FEAT_GUI\n    if (!gui.in_use)\n#endif\n    {\n\tsettmode(TMODE_COOK);\n#ifdef FEAT_TITLE\n\tmch_restore_title(3);\t/* restore xterm title and icon name */\n#endif\n\t/*\n\t * When t_ti is not empty but it doesn't cause swapping terminal\n\t * pages, need to output a newline when msg_didout is set.  But when\n\t * t_ti does swap pages it should not go to the shell page.  Do this\n\t * before stoptermcap().\n\t */\n\tif (swapping_screen() && !newline_on_exit)\n\t    exit_scroll();\n\n\t/* Stop termcap: May need to check for T_CRV response, which\n\t * requires RAW mode. */\n\tstoptermcap();\n\n\t/*\n\t * A newline is only required after a message in the alternate screen.\n\t * This is set to TRUE by wait_return().\n\t */\n\tif (!swapping_screen() || newline_on_exit)\n\t    exit_scroll();\n\n\t/* Cursor may have been switched off without calling starttermcap()\n\t * when doing \"vim -u vimrc\" and vimrc contains \":q\". */\n\tif (full_screen)\n\t    cursor_on();\n    }\n    out_flush();\n    ml_close_all(TRUE);\t\t/* remove all memfiles */\n    may_core_dump();\n#ifdef FEAT_GUI\n    if (gui.in_use)\n\tgui_exit(r);\n#endif\n\n#ifdef MACOS_CONVERT\n    mac_conv_cleanup();\n#endif\n\n#ifdef __QNX__\n    /* A core dump won't be created if the signal handler\n     * doesn't return, so we can't call exit() */\n    if (deadly_signal != 0)\n\treturn;\n#endif\n\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_send_disconnect();\n#endif\n\n#ifdef EXITFREE\n    free_all_mem();\n#endif\n\n    exit(r);\n}\n\n    static void\nmay_core_dump(void)\n{\n    if (deadly_signal != 0)\n    {\n\tsignal(deadly_signal, SIG_DFL);\n\tkill(getpid(), deadly_signal);\t/* Die using the signal we caught */\n    }\n}\n\n#ifndef VMS\n\n    void\nmch_settmode(int tmode)\n{\n    static int first = TRUE;\n\n    /* Why is NeXT excluded here (and not in os_unixx.h)? */\n#if defined(ECHOE) && defined(ICANON) && (defined(HAVE_TERMIO_H) || defined(HAVE_TERMIOS_H)) && !defined(__NeXT__)\n    /*\n     * for \"new\" tty systems\n     */\n# ifdef HAVE_TERMIOS_H\n    static struct termios told;\n\t   struct termios tnew;\n# else\n    static struct termio told;\n\t   struct termio tnew;\n# endif\n\n    if (first)\n    {\n\tfirst = FALSE;\n# if defined(HAVE_TERMIOS_H)\n\ttcgetattr(read_cmd_fd, &told);\n# else\n\tioctl(read_cmd_fd, TCGETA, &told);\n# endif\n    }\n\n    tnew = told;\n    if (tmode == TMODE_RAW)\n    {\n\t/*\n\t * ~ICRNL enables typing ^V^M\n\t */\n\ttnew.c_iflag &= ~ICRNL;\n\ttnew.c_lflag &= ~(ICANON | ECHO | ISIG | ECHOE\n# if defined(IEXTEN) && !defined(__MINT__)\n\t\t    | IEXTEN\t    /* IEXTEN enables typing ^V on SOLARIS */\n\t\t\t\t    /* but it breaks function keys on MINT */\n# endif\n\t\t\t\t);\n# ifdef ONLCR\t    /* don't map NL -> CR NL, we do it ourselves */\n\ttnew.c_oflag &= ~ONLCR;\n# endif\n\ttnew.c_cc[VMIN] = 1;\t\t/* return after 1 char */\n\ttnew.c_cc[VTIME] = 0;\t\t/* don't wait */\n    }\n    else if (tmode == TMODE_SLEEP)\n    {\n\t/* Also reset ICANON here, otherwise on Solaris select() won't see\n\t * typeahead characters. */\n\ttnew.c_lflag &= ~(ICANON | ECHO);\n\ttnew.c_cc[VMIN] = 1;\t\t/* return after 1 char */\n\ttnew.c_cc[VTIME] = 0;\t\t/* don't wait */\n    }\n\n# if defined(HAVE_TERMIOS_H)\n    {\n\tint\tn = 10;\n\n\t/* A signal may cause tcsetattr() to fail (e.g., SIGCONT).  Retry a\n\t * few times. */\n\twhile (tcsetattr(read_cmd_fd, TCSANOW, &tnew) == -1\n\t\t\t\t\t\t   && errno == EINTR && n > 0)\n\t    --n;\n    }\n# else\n    ioctl(read_cmd_fd, TCSETA, &tnew);\n# endif\n\n#else\n\n    /*\n     * for \"old\" tty systems\n     */\n# ifndef TIOCSETN\n#  define TIOCSETN TIOCSETP\t/* for hpux 9.0 */\n# endif\n    static struct sgttyb ttybold;\n\t   struct sgttyb ttybnew;\n\n    if (first)\n    {\n\tfirst = FALSE;\n\tioctl(read_cmd_fd, TIOCGETP, &ttybold);\n    }\n\n    ttybnew = ttybold;\n    if (tmode == TMODE_RAW)\n    {\n\tttybnew.sg_flags &= ~(CRMOD | ECHO);\n\tttybnew.sg_flags |= RAW;\n    }\n    else if (tmode == TMODE_SLEEP)\n\tttybnew.sg_flags &= ~(ECHO);\n    ioctl(read_cmd_fd, TIOCSETN, &ttybnew);\n#endif\n    curr_tmode = tmode;\n}\n\n/*\n * Try to get the code for \"t_kb\" from the stty setting\n *\n * Even if termcap claims a backspace key, the user's setting *should*\n * prevail.  stty knows more about reality than termcap does, and if\n * somebody's usual erase key is DEL (which, for most BSD users, it will\n * be), they're going to get really annoyed if their erase key starts\n * doing forward deletes for no reason. (Eric Fischer)\n */\n    void\nget_stty(void)\n{\n    char_u  buf[2];\n    char_u  *p;\n\n    /* Why is NeXT excluded here (and not in os_unixx.h)? */\n#if defined(ECHOE) && defined(ICANON) && (defined(HAVE_TERMIO_H) || defined(HAVE_TERMIOS_H)) && !defined(__NeXT__)\n    /* for \"new\" tty systems */\n# ifdef HAVE_TERMIOS_H\n    struct termios keys;\n# else\n    struct termio keys;\n# endif\n\n# if defined(HAVE_TERMIOS_H)\n    if (tcgetattr(read_cmd_fd, &keys) != -1)\n# else\n    if (ioctl(read_cmd_fd, TCGETA, &keys) != -1)\n# endif\n    {\n\tbuf[0] = keys.c_cc[VERASE];\n\tintr_char = keys.c_cc[VINTR];\n#else\n    /* for \"old\" tty systems */\n    struct sgttyb keys;\n\n    if (ioctl(read_cmd_fd, TIOCGETP, &keys) != -1)\n    {\n\tbuf[0] = keys.sg_erase;\n\tintr_char = keys.sg_kill;\n#endif\n\tbuf[1] = NUL;\n\tadd_termcode((char_u *)\"kb\", buf, FALSE);\n\n\t/*\n\t * If <BS> and <DEL> are now the same, redefine <DEL>.\n\t */\n\tp = find_termcode((char_u *)\"kD\");\n\tif (p != NULL && p[0] == buf[0] && p[1] == buf[1])\n\t    do_fixdel(NULL);\n    }\n#if 0\n    }\t    /* to keep cindent happy */\n#endif\n}\n\n#endif /* VMS  */\n\n#if defined(FEAT_MOUSE_TTY) || defined(PROTO)\n/*\n * Set mouse clicks on or off.\n */\n    void\nmch_setmouse(int on)\n{\n    static int\tison = FALSE;\n    int\t\txterm_mouse_vers;\n\n    if (on == ison)\t/* return quickly if nothing to do */\n\treturn;\n\n    xterm_mouse_vers = use_xterm_mouse();\n\n# ifdef FEAT_MOUSE_URXVT\n    if (ttym_flags == TTYM_URXVT)\n    {\n\tout_str_nf((char_u *)\n\t\t   (on\n\t\t   ? IF_EB(\"\\033[?1015h\", ESC_STR \"[?1015h\")\n\t\t   : IF_EB(\"\\033[?1015l\", ESC_STR \"[?1015l\")));\n\tison = on;\n    }\n# endif\n\n# ifdef FEAT_MOUSE_SGR\n    if (ttym_flags == TTYM_SGR)\n    {\n\tout_str_nf((char_u *)\n\t\t   (on\n\t\t   ? IF_EB(\"\\033[?1006h\", ESC_STR \"[?1006h\")\n\t\t   : IF_EB(\"\\033[?1006l\", ESC_STR \"[?1006l\")));\n\tison = on;\n    }\n# endif\n\n    if (xterm_mouse_vers > 0)\n    {\n\tif (on)\t/* enable mouse events, use mouse tracking if available */\n\t    out_str_nf((char_u *)\n\t\t       (xterm_mouse_vers > 1\n\t\t\t? IF_EB(\"\\033[?1002h\", ESC_STR \"[?1002h\")\n\t\t\t: IF_EB(\"\\033[?1000h\", ESC_STR \"[?1000h\")));\n\telse\t/* disable mouse events, could probably always send the same */\n\t    out_str_nf((char_u *)\n\t\t       (xterm_mouse_vers > 1\n\t\t\t? IF_EB(\"\\033[?1002l\", ESC_STR \"[?1002l\")\n\t\t\t: IF_EB(\"\\033[?1000l\", ESC_STR \"[?1000l\")));\n\tison = on;\n    }\n\n# ifdef FEAT_MOUSE_DEC\n    else if (ttym_flags == TTYM_DEC)\n    {\n\tif (on)\t/* enable mouse events */\n\t    out_str_nf((char_u *)\"\\033[1;2'z\\033[1;3'{\");\n\telse\t/* disable mouse events */\n\t    out_str_nf((char_u *)\"\\033['z\");\n\tison = on;\n    }\n# endif\n\n# ifdef FEAT_MOUSE_GPM\n    else\n    {\n\tif (on)\n\t{\n\t    if (gpm_open())\n\t\tison = TRUE;\n\t}\n\telse\n\t{\n\t    gpm_close();\n\t    ison = FALSE;\n\t}\n    }\n# endif\n\n# ifdef FEAT_SYSMOUSE\n    else\n    {\n\tif (on)\n\t{\n\t    if (sysmouse_open() == OK)\n\t\tison = TRUE;\n\t}\n\telse\n\t{\n\t    sysmouse_close();\n\t    ison = FALSE;\n\t}\n    }\n# endif\n\n# ifdef FEAT_MOUSE_JSB\n    else\n    {\n\tif (on)\n\t{\n\t    /* D - Enable Mouse up/down messages\n\t     * L - Enable Left Button Reporting\n\t     * M - Enable Middle Button Reporting\n\t     * R - Enable Right Button Reporting\n\t     * K - Enable SHIFT and CTRL key Reporting\n\t     * + - Enable Advanced messaging of mouse moves and up/down messages\n\t     * Q - Quiet No Ack\n\t     * # - Numeric value of mouse pointer required\n\t     *\t  0 = Multiview 2000 cursor, used as standard\n\t     *\t  1 = Windows Arrow\n\t     *\t  2 = Windows I Beam\n\t     *\t  3 = Windows Hour Glass\n\t     *\t  4 = Windows Cross Hair\n\t     *\t  5 = Windows UP Arrow\n\t     */\n#  ifdef JSBTERM_MOUSE_NONADVANCED\n\t    /* Disables full feedback of pointer movements */\n\t    out_str_nf((char_u *)IF_EB(\"\\033[0~ZwLMRK1Q\\033\\\\\",\n\t\t\t\t\t ESC_STR \"[0~ZwLMRK1Q\" ESC_STR \"\\\\\"));\n#  else\n\t    out_str_nf((char_u *)IF_EB(\"\\033[0~ZwLMRK+1Q\\033\\\\\",\n\t\t\t\t\tESC_STR \"[0~ZwLMRK+1Q\" ESC_STR \"\\\\\"));\n#  endif\n\t    ison = TRUE;\n\t}\n\telse\n\t{\n\t    out_str_nf((char_u *)IF_EB(\"\\033[0~ZwQ\\033\\\\\",\n\t\t\t\t\t      ESC_STR \"[0~ZwQ\" ESC_STR \"\\\\\"));\n\t    ison = FALSE;\n\t}\n    }\n# endif\n# ifdef FEAT_MOUSE_PTERM\n    else\n    {\n\t/* 1 = button press, 6 = release, 7 = drag, 1h...9l = right button */\n\tif (on)\n\t    out_str_nf(\"\\033[>1h\\033[>6h\\033[>7h\\033[>1h\\033[>9l\");\n\telse\n\t    out_str_nf(\"\\033[>1l\\033[>6l\\033[>7l\\033[>1l\\033[>9h\");\n\tison = on;\n    }\n# endif\n}\n\n/*\n * Set the mouse termcode, depending on the 'term' and 'ttymouse' options.\n */\n    void\ncheck_mouse_termcode(void)\n{\n# ifdef FEAT_MOUSE_XTERM\n    if (use_xterm_mouse()\n# ifdef FEAT_MOUSE_URXVT\n\t    && use_xterm_mouse() != 3\n# endif\n#  ifdef FEAT_GUI\n\t    && !gui.in_use\n#  endif\n\t    )\n    {\n\tset_mouse_termcode(KS_MOUSE, (char_u *)(term_is_8bit(T_NAME)\n\t\t    ? IF_EB(\"\\233M\", CSI_STR \"M\")\n\t\t    : IF_EB(\"\\033[M\", ESC_STR \"[M\")));\n\tif (*p_mouse != NUL)\n\t{\n\t    /* force mouse off and maybe on to send possibly new mouse\n\t     * activation sequence to the xterm, with(out) drag tracing. */\n\t    mch_setmouse(FALSE);\n\t    setmouse();\n\t}\n    }\n    else\n\tdel_mouse_termcode(KS_MOUSE);\n# endif\n\n# ifdef FEAT_MOUSE_GPM\n    if (!use_xterm_mouse()\n#  ifdef FEAT_GUI\n\t    && !gui.in_use\n#  endif\n\t    )\n\tset_mouse_termcode(KS_MOUSE, (char_u *)IF_EB(\"\\033MG\", ESC_STR \"MG\"));\n# endif\n\n# ifdef FEAT_SYSMOUSE\n    if (!use_xterm_mouse()\n#  ifdef FEAT_GUI\n\t    && !gui.in_use\n#  endif\n\t    )\n\tset_mouse_termcode(KS_MOUSE, (char_u *)IF_EB(\"\\033MS\", ESC_STR \"MS\"));\n# endif\n\n# ifdef FEAT_MOUSE_JSB\n    /* Conflicts with xterm mouse: \"\\033[\" and \"\\033[M\" ??? */\n    if (!use_xterm_mouse()\n#  ifdef FEAT_GUI\n\t    && !gui.in_use\n#  endif\n\t    )\n\tset_mouse_termcode(KS_JSBTERM_MOUSE,\n\t\t\t       (char_u *)IF_EB(\"\\033[0~zw\", ESC_STR \"[0~zw\"));\n    else\n\tdel_mouse_termcode(KS_JSBTERM_MOUSE);\n# endif\n\n# ifdef FEAT_MOUSE_NET\n    /* There is no conflict, but one may type \"ESC }\" from Insert mode.  Don't\n     * define it in the GUI or when using an xterm. */\n    if (!use_xterm_mouse()\n#  ifdef FEAT_GUI\n\t    && !gui.in_use\n#  endif\n\t    )\n\tset_mouse_termcode(KS_NETTERM_MOUSE,\n\t\t\t\t       (char_u *)IF_EB(\"\\033}\", ESC_STR \"}\"));\n    else\n\tdel_mouse_termcode(KS_NETTERM_MOUSE);\n# endif\n\n# ifdef FEAT_MOUSE_DEC\n    /* Conflicts with xterm mouse: \"\\033[\" and \"\\033[M\" */\n    if (!use_xterm_mouse()\n#  ifdef FEAT_GUI\n\t    && !gui.in_use\n#  endif\n\t    )\n\tset_mouse_termcode(KS_DEC_MOUSE, (char_u *)(term_is_8bit(T_NAME)\n\t\t     ? IF_EB(\"\\233\", CSI_STR) : IF_EB(\"\\033[\", ESC_STR \"[\")));\n    else\n\tdel_mouse_termcode(KS_DEC_MOUSE);\n# endif\n# ifdef FEAT_MOUSE_PTERM\n    /* same conflict as the dec mouse */\n    if (!use_xterm_mouse()\n#  ifdef FEAT_GUI\n\t    && !gui.in_use\n#  endif\n\t    )\n\tset_mouse_termcode(KS_PTERM_MOUSE,\n\t\t\t\t      (char_u *) IF_EB(\"\\033[\", ESC_STR \"[\"));\n    else\n\tdel_mouse_termcode(KS_PTERM_MOUSE);\n# endif\n# ifdef FEAT_MOUSE_URXVT\n    /* same conflict as the dec mouse */\n    if (use_xterm_mouse() == 3\n#  ifdef FEAT_GUI\n\t    && !gui.in_use\n#  endif\n\t    )\n    {\n\tset_mouse_termcode(KS_URXVT_MOUSE, (char_u *)(term_is_8bit(T_NAME)\n\t\t    ? IF_EB(\"\\233\", CSI_STR)\n\t\t    : IF_EB(\"\\033[\", ESC_STR \"[\")));\n\n\tif (*p_mouse != NUL)\n\t{\n\t    mch_setmouse(FALSE);\n\t    setmouse();\n\t}\n    }\n    else\n\tdel_mouse_termcode(KS_URXVT_MOUSE);\n# endif\n# ifdef FEAT_MOUSE_SGR\n    /* There is no conflict with xterm mouse */\n    if (use_xterm_mouse() == 4\n#  ifdef FEAT_GUI\n\t    && !gui.in_use\n#  endif\n\t    )\n    {\n\tset_mouse_termcode(KS_SGR_MOUSE, (char_u *)(term_is_8bit(T_NAME)\n\t\t    ? IF_EB(\"\\233<\", CSI_STR \"<\")\n\t\t    : IF_EB(\"\\033[<\", ESC_STR \"[<\")));\n\n\tif (*p_mouse != NUL)\n\t{\n\t    mch_setmouse(FALSE);\n\t    setmouse();\n\t}\n    }\n    else\n\tdel_mouse_termcode(KS_SGR_MOUSE);\n# endif\n}\n#endif\n\n/*\n * set screen mode, always fails.\n */\n    int\nmch_screenmode(char_u *arg UNUSED)\n{\n    EMSG(_(e_screenmode));\n    return FAIL;\n}\n\n#ifndef VMS\n\n/*\n * Try to get the current window size:\n * 1. with an ioctl(), most accurate method\n * 2. from the environment variables LINES and COLUMNS\n * 3. from the termcap\n * 4. keep using the old values\n * Return OK when size could be determined, FAIL otherwise.\n */\n    int\nmch_get_shellsize(void)\n{\n    long\trows = 0;\n    long\tcolumns = 0;\n    char_u\t*p;\n\n    /*\n     * 1. try using an ioctl. It is the most accurate method.\n     *\n     * Try using TIOCGWINSZ first, some systems that have it also define\n     * TIOCGSIZE but don't have a struct ttysize.\n     */\n# ifdef TIOCGWINSZ\n    {\n\tstruct winsize\tws;\n\tint fd = 1;\n\n\t/* When stdout is not a tty, use stdin for the ioctl(). */\n\tif (!isatty(fd) && isatty(read_cmd_fd))\n\t    fd = read_cmd_fd;\n\tif (ioctl(fd, TIOCGWINSZ, &ws) == 0)\n\t{\n\t    columns = ws.ws_col;\n\t    rows = ws.ws_row;\n\t}\n    }\n# else /* TIOCGWINSZ */\n#  ifdef TIOCGSIZE\n    {\n\tstruct ttysize\tts;\n\tint fd = 1;\n\n\t/* When stdout is not a tty, use stdin for the ioctl(). */\n\tif (!isatty(fd) && isatty(read_cmd_fd))\n\t    fd = read_cmd_fd;\n\tif (ioctl(fd, TIOCGSIZE, &ts) == 0)\n\t{\n\t    columns = ts.ts_cols;\n\t    rows = ts.ts_lines;\n\t}\n    }\n#  endif /* TIOCGSIZE */\n# endif /* TIOCGWINSZ */\n\n    /*\n     * 2. get size from environment\n     *    When being POSIX compliant ('|' flag in 'cpoptions') this overrules\n     *    the ioctl() values!\n     */\n    if (columns == 0 || rows == 0 || vim_strchr(p_cpo, CPO_TSIZE) != NULL)\n    {\n\tif ((p = (char_u *)getenv(\"LINES\")))\n\t    rows = atoi((char *)p);\n\tif ((p = (char_u *)getenv(\"COLUMNS\")))\n\t    columns = atoi((char *)p);\n    }\n\n#ifdef HAVE_TGETENT\n    /*\n     * 3. try reading \"co\" and \"li\" entries from termcap\n     */\n    if (columns == 0 || rows == 0)\n\tgetlinecol(&columns, &rows);\n#endif\n\n    /*\n     * 4. If everything fails, use the old values\n     */\n    if (columns <= 0 || rows <= 0)\n\treturn FAIL;\n\n    Rows = rows;\n    Columns = columns;\n    limit_screen_size();\n    return OK;\n}\n\n/*\n * Try to set the window size to Rows and Columns.\n */\n    void\nmch_set_shellsize(void)\n{\n    if (*T_CWS)\n    {\n\t/*\n\t * NOTE: if you get an error here that term_set_winsize() is\n\t * undefined, check the output of configure.  It could probably not\n\t * find a ncurses, termcap or termlib library.\n\t */\n\tterm_set_winsize((int)Rows, (int)Columns);\n\tout_flush();\n\tscreen_start();\t\t\t/* don't know where cursor is now */\n    }\n}\n\n#endif /* VMS */\n\n/*\n * Rows and/or Columns has changed.\n */\n    void\nmch_new_shellsize(void)\n{\n    /* Nothing to do. */\n}\n\n/*\n * Wait for process \"child\" to end.\n * Return \"child\" if it exited properly, <= 0 on error.\n */\n    static pid_t\nwait4pid(pid_t child, waitstatus *status)\n{\n    pid_t wait_pid = 0;\n    long delay_msec = 1;\n\n    while (wait_pid != child)\n    {\n\t/* When compiled with Python threads are probably used, in which case\n\t * wait() sometimes hangs for no obvious reason.  Use waitpid()\n\t * instead and loop (like the GUI). Also needed for other interfaces,\n\t * they might call system(). */\n# ifdef __NeXT__\n\twait_pid = wait4(child, status, WNOHANG, (struct rusage *)0);\n# else\n\twait_pid = waitpid(child, status, WNOHANG);\n# endif\n\tif (wait_pid == 0)\n\t{\n\t    /* Wait for 1 to 10 msec before trying again. */\n\t    mch_delay(delay_msec, TRUE);\n\t    if (++delay_msec > 10)\n\t\tdelay_msec = 10;\n\t    continue;\n\t}\n\tif (wait_pid <= 0\n# ifdef ECHILD\n\t\t&& errno == ECHILD\n# endif\n\t   )\n\t    break;\n    }\n    return wait_pid;\n}\n\n#if defined(FEAT_JOB_CHANNEL) || !defined(USE_SYSTEM) || defined(PROTO)\n/*\n * Parse \"cmd\" and put the white-separated parts in \"argv\".\n * \"argv\" is an allocated array with \"argc\" entries.\n * Returns FAIL when out of memory.\n */\n    int\nmch_parse_cmd(char_u *cmd, int use_shcf, char ***argv, int *argc)\n{\n    int\t\ti;\n    char_u\t*p;\n    int\t\tinquote;\n\n    /*\n     * Do this loop twice:\n     * 1: find number of arguments\n     * 2: separate them and build argv[]\n     */\n    for (i = 0; i < 2; ++i)\n    {\n\tp = skipwhite(cmd);\n\tinquote = FALSE;\n\t*argc = 0;\n\tfor (;;)\n\t{\n\t    if (i == 1)\n\t\t(*argv)[*argc] = (char *)p;\n\t    ++*argc;\n\t    while (*p != NUL && (inquote || (*p != ' ' && *p != TAB)))\n\t    {\n\t\tif (*p == '\"')\n\t\t    inquote = !inquote;\n\t\t++p;\n\t    }\n\t    if (*p == NUL)\n\t\tbreak;\n\t    if (i == 1)\n\t\t*p++ = NUL;\n\t    p = skipwhite(p);\n\t}\n\tif (*argv == NULL)\n\t{\n\t    if (use_shcf)\n\t    {\n\t\t/* Account for possible multiple args in p_shcf. */\n\t\tp = p_shcf;\n\t\tfor (;;)\n\t\t{\n\t\t    p = skiptowhite(p);\n\t\t    if (*p == NUL)\n\t\t\tbreak;\n\t\t    ++*argc;\n\t\t    p = skipwhite(p);\n\t\t}\n\t    }\n\n\t    *argv = (char **)alloc((unsigned)((*argc + 4) * sizeof(char *)));\n\t    if (*argv == NULL)\t    /* out of memory */\n\t\treturn FAIL;\n\t}\n    }\n    return OK;\n}\n#endif\n\n#if !defined(USE_SYSTEM) || defined(FEAT_JOB_CHANNEL)\n    static void\nset_child_environment(void)\n{\n# ifdef HAVE_SETENV\n    char\tenvbuf[50];\n# else\n    static char\tenvbuf_Rows[20];\n    static char\tenvbuf_Columns[20];\n# endif\n\n    /* Simulate to have a dumb terminal (for now) */\n# ifdef HAVE_SETENV\n    setenv(\"TERM\", \"dumb\", 1);\n    sprintf((char *)envbuf, \"%ld\", Rows);\n    setenv(\"ROWS\", (char *)envbuf, 1);\n    sprintf((char *)envbuf, \"%ld\", Rows);\n    setenv(\"LINES\", (char *)envbuf, 1);\n    sprintf((char *)envbuf, \"%ld\", Columns);\n    setenv(\"COLUMNS\", (char *)envbuf, 1);\n# else\n    /*\n     * Putenv does not copy the string, it has to remain valid.\n     * Use a static array to avoid losing allocated memory.\n     */\n    putenv(\"TERM=dumb\");\n    sprintf(envbuf_Rows, \"ROWS=%ld\", Rows);\n    putenv(envbuf_Rows);\n    sprintf(envbuf_Rows, \"LINES=%ld\", Rows);\n    putenv(envbuf_Rows);\n    sprintf(envbuf_Columns, \"COLUMNS=%ld\", Columns);\n    putenv(envbuf_Columns);\n# endif\n}\n#endif\n\n    int\nmch_call_shell(\n    char_u\t*cmd,\n    int\t\toptions)\t/* SHELL_*, see vim.h */\n{\n#ifdef VMS\n    char\t*ifn = NULL;\n    char\t*ofn = NULL;\n#endif\n    int\t\ttmode = cur_tmode;\n#ifdef USE_SYSTEM\t/* use system() to start the shell: simple but slow */\n    char_u\t*newcmd;\t/* only needed for unix */\n    int\t\tx;\n\n    out_flush();\n\n    if (options & SHELL_COOKED)\n\tsettmode(TMODE_COOK);\t    /* set to normal mode */\n\n# if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)\n    save_clipboard();\n    loose_clipboard();\n# endif\n\n    if (cmd == NULL)\n\tx = system((char *)p_sh);\n    else\n    {\n# ifdef VMS\n\tif (ofn = strchr((char *)cmd, '>'))\n\t    *ofn++ = '\\0';\n\tif (ifn = strchr((char *)cmd, '<'))\n\t{\n\t    char *p;\n\n\t    *ifn++ = '\\0';\n\t    p = strchr(ifn,' '); /* chop off any trailing spaces */\n\t    if (p)\n\t\t*p = '\\0';\n\t}\n\tif (ofn)\n\t    x = vms_sys((char *)cmd, ofn, ifn);\n\telse\n\t    x = system((char *)cmd);\n# else\n\tnewcmd = lalloc(STRLEN(p_sh)\n\t\t+ (extra_shell_arg == NULL ? 0 : STRLEN(extra_shell_arg))\n\t\t+ STRLEN(p_shcf) + STRLEN(cmd) + 4, TRUE);\n\tif (newcmd == NULL)\n\t    x = 0;\n\telse\n\t{\n\t    sprintf((char *)newcmd, \"%s %s %s %s\", p_sh,\n\t\t    extra_shell_arg == NULL ? \"\" : (char *)extra_shell_arg,\n\t\t    (char *)p_shcf,\n\t\t    (char *)cmd);\n\t    x = system((char *)newcmd);\n\t    vim_free(newcmd);\n\t}\n# endif\n    }\n# ifdef VMS\n    x = vms_sys_status(x);\n# endif\n    if (emsg_silent)\n\t;\n    else if (x == 127)\n\tMSG_PUTS(_(\"\\nCannot execute shell sh\\n\"));\n    else if (x && !(options & SHELL_SILENT))\n    {\n\tMSG_PUTS(_(\"\\nshell returned \"));\n\tmsg_outnum((long)x);\n\tmsg_putchar('\\n');\n    }\n\n    if (tmode == TMODE_RAW)\n\tsettmode(TMODE_RAW);\t/* set to raw mode */\n# ifdef FEAT_TITLE\n    resettitle();\n# endif\n# if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)\n    restore_clipboard();\n# endif\n    return x;\n\n#else /* USE_SYSTEM */\t    /* don't use system(), use fork()/exec() */\n\n# define EXEC_FAILED 122    /* Exit code when shell didn't execute.  Don't use\n\t\t\t       127, some shells use that already */\n\n    char_u\t*newcmd;\n    pid_t\tpid;\n    pid_t\twpid = 0;\n    pid_t\twait_pid = 0;\n# ifdef HAVE_UNION_WAIT\n    union wait\tstatus;\n# else\n    int\t\tstatus = -1;\n# endif\n    int\t\tretval = -1;\n    char\t**argv = NULL;\n    int\t\targc;\n    char_u\t*p_shcf_copy = NULL;\n    int\t\ti;\n    char_u\t*p;\n    int\t\tpty_master_fd = -1;\t    /* for pty's */\n# ifdef FEAT_GUI\n    int\t\tpty_slave_fd = -1;\n    char\t*tty_name;\n# endif\n    int\t\tfd_toshell[2];\t\t/* for pipes */\n    int\t\tfd_fromshell[2];\n    int\t\tpipe_error = FALSE;\n    int\t\tdid_settmode = FALSE;\t/* settmode(TMODE_RAW) called */\n\n    newcmd = vim_strsave(p_sh);\n    if (newcmd == NULL)\t\t/* out of memory */\n\tgoto error;\n\n    out_flush();\n    if (options & SHELL_COOKED)\n\tsettmode(TMODE_COOK);\t\t/* set to normal mode */\n\n    if (mch_parse_cmd(newcmd, TRUE, &argv, &argc) == FAIL)\n\tgoto error;\n\n    if (cmd != NULL)\n    {\n\tchar_u\t*s;\n\n\tif (extra_shell_arg != NULL)\n\t    argv[argc++] = (char *)extra_shell_arg;\n\n\t/* Break 'shellcmdflag' into white separated parts.  This doesn't\n\t * handle quoted strings, they are very unlikely to appear. */\n\tp_shcf_copy = alloc((unsigned)STRLEN(p_shcf) + 1);\n\tif (p_shcf_copy == NULL)    /* out of memory */\n\t    goto error;\n\ts = p_shcf_copy;\n\tp = p_shcf;\n\twhile (*p != NUL)\n\t{\n\t    argv[argc++] = (char *)s;\n\t    while (*p && *p != ' ' && *p != TAB)\n\t\t*s++ = *p++;\n\t    *s++ = NUL;\n\t    p = skipwhite(p);\n\t}\n\n\targv[argc++] = (char *)cmd;\n    }\n    argv[argc] = NULL;\n\n    /*\n     * For the GUI, when writing the output into the buffer and when reading\n     * input from the buffer: Try using a pseudo-tty to get the stdin/stdout\n     * of the executed command into the Vim window.  Or use a pipe.\n     */\n    if ((options & (SHELL_READ|SHELL_WRITE))\n# ifdef FEAT_GUI\n\t    || (gui.in_use && show_shell_mess)\n# endif\n\t\t    )\n    {\n# ifdef FEAT_GUI\n\t/*\n\t * Try to open a master pty.\n\t * If this works, open the slave pty.\n\t * If the slave can't be opened, close the master pty.\n\t */\n\tif (p_guipty && !(options & (SHELL_READ|SHELL_WRITE)))\n\t{\n\t    pty_master_fd = OpenPTY(&tty_name);\t    /* open pty */\n\t    if (pty_master_fd >= 0)\n\t    {\n\t\t/* Leaving out O_NOCTTY may lead to waitpid() always returning\n\t\t * 0 on Mac OS X 10.7 thereby causing freezes. Let's assume\n\t\t * adding O_NOCTTY always works when defined. */\n#ifdef O_NOCTTY\n\t\tpty_slave_fd = open(tty_name, O_RDWR | O_NOCTTY | O_EXTRA, 0);\n#else\n\t\tpty_slave_fd = open(tty_name, O_RDWR | O_EXTRA, 0);\n#endif\n\t\tif (pty_slave_fd < 0)\n\t\t{\n\t\t    close(pty_master_fd);\n\t\t    pty_master_fd = -1;\n\t\t}\n\t    }\n\t}\n\t/*\n\t * If not opening a pty or it didn't work, try using pipes.\n\t */\n\tif (pty_master_fd < 0)\n# endif\n\t{\n\t    pipe_error = (pipe(fd_toshell) < 0);\n\t    if (!pipe_error)\t\t\t    /* pipe create OK */\n\t    {\n\t\tpipe_error = (pipe(fd_fromshell) < 0);\n\t\tif (pipe_error)\t\t\t    /* pipe create failed */\n\t\t{\n\t\t    close(fd_toshell[0]);\n\t\t    close(fd_toshell[1]);\n\t\t}\n\t    }\n\t    if (pipe_error)\n\t    {\n\t\tMSG_PUTS(_(\"\\nCannot create pipes\\n\"));\n\t\tout_flush();\n\t    }\n\t}\n    }\n\n    if (!pipe_error)\t\t\t/* pty or pipe opened or not used */\n    {\n\tSIGSET_DECL(curset)\n\n# ifdef __BEOS__\n\tbeos_cleanup_read_thread();\n# endif\n\n\tBLOCK_SIGNALS(&curset);\n\tpid = fork();\t/* maybe we should use vfork() */\n\tif (pid == -1)\n\t{\n\t    UNBLOCK_SIGNALS(&curset);\n\n\t    MSG_PUTS(_(\"\\nCannot fork\\n\"));\n\t    if ((options & (SHELL_READ|SHELL_WRITE))\n# ifdef FEAT_GUI\n\t\t|| (gui.in_use && show_shell_mess)\n# endif\n\t\t    )\n\t    {\n# ifdef FEAT_GUI\n\t\tif (pty_master_fd >= 0)\t\t/* close the pseudo tty */\n\t\t{\n\t\t    close(pty_master_fd);\n\t\t    close(pty_slave_fd);\n\t\t}\n\t\telse\t\t\t\t/* close the pipes */\n# endif\n\t\t{\n\t\t    close(fd_toshell[0]);\n\t\t    close(fd_toshell[1]);\n\t\t    close(fd_fromshell[0]);\n\t\t    close(fd_fromshell[1]);\n\t\t}\n\t    }\n\t}\n\telse if (pid == 0)\t/* child */\n\t{\n\t    reset_signals();\t\t/* handle signals normally */\n\t    UNBLOCK_SIGNALS(&curset);\n\n\t    if (!show_shell_mess || (options & SHELL_EXPAND))\n\t    {\n\t\tint fd;\n\n\t\t/*\n\t\t * Don't want to show any message from the shell.  Can't just\n\t\t * close stdout and stderr though, because some systems will\n\t\t * break if you try to write to them after that, so we must\n\t\t * use dup() to replace them with something else -- webb\n\t\t * Connect stdin to /dev/null too, so \":n `cat`\" doesn't hang,\n\t\t * waiting for input.\n\t\t */\n\t\tfd = open(\"/dev/null\", O_RDWR | O_EXTRA, 0);\n\t\tfclose(stdin);\n\t\tfclose(stdout);\n\t\tfclose(stderr);\n\n\t\t/*\n\t\t * If any of these open()'s and dup()'s fail, we just continue\n\t\t * anyway.  It's not fatal, and on most systems it will make\n\t\t * no difference at all.  On a few it will cause the execvp()\n\t\t * to exit with a non-zero status even when the completion\n\t\t * could be done, which is nothing too serious.  If the open()\n\t\t * or dup() failed we'd just do the same thing ourselves\n\t\t * anyway -- webb\n\t\t */\n\t\tif (fd >= 0)\n\t\t{\n\t\t    ignored = dup(fd); /* To replace stdin  (fd 0) */\n\t\t    ignored = dup(fd); /* To replace stdout (fd 1) */\n\t\t    ignored = dup(fd); /* To replace stderr (fd 2) */\n\n\t\t    /* Don't need this now that we've duplicated it */\n\t\t    close(fd);\n\t\t}\n\t    }\n\t    else if ((options & (SHELL_READ|SHELL_WRITE))\n# ifdef FEAT_GUI\n\t\t    || gui.in_use\n# endif\n\t\t    )\n\t    {\n\n# ifdef HAVE_SETSID\n\t\t/* Create our own process group, so that the child and all its\n\t\t * children can be kill()ed.  Don't do this when using pipes,\n\t\t * because stdin is not a tty, we would lose /dev/tty. */\n\t\tif (p_stmp)\n\t\t{\n\t\t    (void)setsid();\n#  if defined(SIGHUP)\n\t\t    /* When doing \"!xterm&\" and 'shell' is bash: the shell\n\t\t     * will exit and send SIGHUP to all processes in its\n\t\t     * group, killing the just started process.  Ignore SIGHUP\n\t\t     * to avoid that. (suggested by Simon Schubert)\n\t\t     */\n\t\t    signal(SIGHUP, SIG_IGN);\n#  endif\n\t\t}\n# endif\n# ifdef FEAT_GUI\n\t\tif (pty_slave_fd >= 0)\n\t\t{\n\t\t    /* push stream discipline modules */\n\t\t    if (options & SHELL_COOKED)\n\t\t\tSetupSlavePTY(pty_slave_fd);\n#  ifdef TIOCSCTTY\n\t\t    /* Try to become controlling tty (probably doesn't work,\n\t\t     * unless run by root) */\n\t\t    ioctl(pty_slave_fd, TIOCSCTTY, (char *)NULL);\n#  endif\n\t\t}\n# endif\n\t\tset_child_environment();\n\n\t\t/*\n\t\t * stderr is only redirected when using the GUI, so that a\n\t\t * program like gpg can still access the terminal to get a\n\t\t * passphrase using stderr.\n\t\t */\n# ifdef FEAT_GUI\n\t\tif (pty_master_fd >= 0)\n\t\t{\n\t\t    close(pty_master_fd);   /* close master side of pty */\n\n\t\t    /* set up stdin/stdout/stderr for the child */\n\t\t    close(0);\n\t\t    ignored = dup(pty_slave_fd);\n\t\t    close(1);\n\t\t    ignored = dup(pty_slave_fd);\n\t\t    if (gui.in_use)\n\t\t    {\n\t\t\tclose(2);\n\t\t\tignored = dup(pty_slave_fd);\n\t\t    }\n\n\t\t    close(pty_slave_fd);    /* has been dupped, close it now */\n\t\t}\n\t\telse\n# endif\n\t\t{\n\t\t    /* set up stdin for the child */\n\t\t    close(fd_toshell[1]);\n\t\t    close(0);\n\t\t    ignored = dup(fd_toshell[0]);\n\t\t    close(fd_toshell[0]);\n\n\t\t    /* set up stdout for the child */\n\t\t    close(fd_fromshell[0]);\n\t\t    close(1);\n\t\t    ignored = dup(fd_fromshell[1]);\n\t\t    close(fd_fromshell[1]);\n\n# ifdef FEAT_GUI\n\t\t    if (gui.in_use)\n\t\t    {\n\t\t\t/* set up stderr for the child */\n\t\t\tclose(2);\n\t\t\tignored = dup(1);\n\t\t    }\n# endif\n\t\t}\n\t    }\n\n\t    /*\n\t     * There is no type cast for the argv, because the type may be\n\t     * different on different machines. This may cause a warning\n\t     * message with strict compilers, don't worry about it.\n\t     * Call _exit() instead of exit() to avoid closing the connection\n\t     * to the X server (esp. with GTK, which uses atexit()).\n\t     */\n\t    execvp(argv[0], argv);\n\t    _exit(EXEC_FAILED);\t    /* exec failed, return failure code */\n\t}\n\telse\t\t\t/* parent */\n\t{\n\t    /*\n\t     * While child is running, ignore terminating signals.\n\t     * Do catch CTRL-C, so that \"got_int\" is set.\n\t     */\n\t    catch_signals(SIG_IGN, SIG_ERR);\n\t    catch_int_signal();\n\t    UNBLOCK_SIGNALS(&curset);\n# ifdef FEAT_JOB_CHANNEL\n\t    ++dont_check_job_ended;\n# endif\n\t    /*\n\t     * For the GUI we redirect stdin, stdout and stderr to our window.\n\t     * This is also used to pipe stdin/stdout to/from the external\n\t     * command.\n\t     */\n\t    if ((options & (SHELL_READ|SHELL_WRITE))\n# ifdef FEAT_GUI\n\t\t    || (gui.in_use && show_shell_mess)\n# endif\n\t       )\n\t    {\n# define BUFLEN 100\t\t/* length for buffer, pseudo tty limit is 128 */\n\t\tchar_u\t    buffer[BUFLEN + 1];\n# ifdef FEAT_MBYTE\n\t\tint\t    buffer_off = 0;\t/* valid bytes in buffer[] */\n# endif\n\t\tchar_u\t    ta_buf[BUFLEN + 1];\t/* TypeAHead */\n\t\tint\t    ta_len = 0;\t\t/* valid bytes in ta_buf[] */\n\t\tint\t    len;\n\t\tint\t    p_more_save;\n\t\tint\t    old_State;\n\t\tint\t    c;\n\t\tint\t    toshell_fd;\n\t\tint\t    fromshell_fd;\n\t\tgarray_T    ga;\n\t\tint\t    noread_cnt;\n# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)\n\t\tstruct timeval  start_tv;\n# endif\n\n# ifdef FEAT_GUI\n\t\tif (pty_master_fd >= 0)\n\t\t{\n\t\t    fromshell_fd = pty_master_fd;\n\t\t    toshell_fd = dup(pty_master_fd);\n\t\t}\n\t\telse\n# endif\n\t\t{\n\t\t    close(fd_toshell[0]);\n\t\t    close(fd_fromshell[1]);\n\t\t    toshell_fd = fd_toshell[1];\n\t\t    fromshell_fd = fd_fromshell[0];\n\t\t}\n\n\t\t/*\n\t\t * Write to the child if there are typed characters.\n\t\t * Read from the child if there are characters available.\n\t\t *   Repeat the reading a few times if more characters are\n\t\t *   available. Need to check for typed keys now and then, but\n\t\t *   not too often (delays when no chars are available).\n\t\t * This loop is quit if no characters can be read from the pty\n\t\t * (WaitForChar detected special condition), or there are no\n\t\t * characters available and the child has exited.\n\t\t * Only check if the child has exited when there is no more\n\t\t * output. The child may exit before all the output has\n\t\t * been printed.\n\t\t *\n\t\t * Currently this busy loops!\n\t\t * This can probably dead-lock when the write blocks!\n\t\t */\n\t\tp_more_save = p_more;\n\t\tp_more = FALSE;\n\t\told_State = State;\n\t\tState = EXTERNCMD;\t/* don't redraw at window resize */\n\n\t\tif ((options & SHELL_WRITE) && toshell_fd >= 0)\n\t\t{\n\t\t    /* Fork a process that will write the lines to the\n\t\t     * external program. */\n\t\t    if ((wpid = fork()) == -1)\n\t\t    {\n\t\t\tMSG_PUTS(_(\"\\nCannot fork\\n\"));\n\t\t    }\n\t\t    else if (wpid == 0) /* child */\n\t\t    {\n\t\t\tlinenr_T    lnum = curbuf->b_op_start.lnum;\n\t\t\tint\t    written = 0;\n\t\t\tchar_u\t    *lp = ml_get(lnum);\n\t\t\tsize_t\t    l;\n\n\t\t\tclose(fromshell_fd);\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t    l = STRLEN(lp + written);\n\t\t\t    if (l == 0)\n\t\t\t\tlen = 0;\n\t\t\t    else if (lp[written] == NL)\n\t\t\t\t/* NL -> NUL translation */\n\t\t\t\tlen = write(toshell_fd, \"\", (size_t)1);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tchar_u\t*s = vim_strchr(lp + written, NL);\n\n\t\t\t\tlen = write(toshell_fd, (char *)lp + written,\n\t\t\t\t\t   s == NULL ? l\n\t\t\t\t\t      : (size_t)(s - (lp + written)));\n\t\t\t    }\n\t\t\t    if (len == (int)l)\n\t\t\t    {\n\t\t\t\t/* Finished a line, add a NL, unless this line\n\t\t\t\t * should not have one. */\n\t\t\t\tif (lnum != curbuf->b_op_end.lnum\n\t\t\t\t\t|| (!curbuf->b_p_bin\n\t\t\t\t\t    && curbuf->b_p_fixeol)\n\t\t\t\t\t|| (lnum != curbuf->b_no_eol_lnum\n\t\t\t\t\t    && (lnum !=\n\t\t\t\t\t\t    curbuf->b_ml.ml_line_count\n\t\t\t\t\t\t    || curbuf->b_p_eol)))\n\t\t\t\t    ignored = write(toshell_fd, \"\\n\",\n\t\t\t\t\t\t\t\t   (size_t)1);\n\t\t\t\t++lnum;\n\t\t\t\tif (lnum > curbuf->b_op_end.lnum)\n\t\t\t\t{\n\t\t\t\t    /* finished all the lines, close pipe */\n\t\t\t\t    close(toshell_fd);\n\t\t\t\t    toshell_fd = -1;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\tlp = ml_get(lnum);\n\t\t\t\twritten = 0;\n\t\t\t    }\n\t\t\t    else if (len > 0)\n\t\t\t\twritten += len;\n\t\t\t}\n\t\t\t_exit(0);\n\t\t    }\n\t\t    else /* parent */\n\t\t    {\n\t\t\tclose(toshell_fd);\n\t\t\ttoshell_fd = -1;\n\t\t    }\n\t\t}\n\n\t\tif (options & SHELL_READ)\n\t\t    ga_init2(&ga, 1, BUFLEN);\n\n\t\tnoread_cnt = 0;\n# ifdef ELAPSED_FUNC\n\t\tELAPSED_INIT(start_tv);\n# endif\n\t\tfor (;;)\n\t\t{\n\t\t    /*\n\t\t     * Check if keys have been typed, write them to the child\n\t\t     * if there are any.\n\t\t     * Don't do this if we are expanding wild cards (would eat\n\t\t     * typeahead).\n\t\t     * Don't do this when filtering and terminal is in cooked\n\t\t     * mode, the shell command will handle the I/O.  Avoids\n\t\t     * that a typed password is echoed for ssh or gpg command.\n\t\t     * Don't get characters when the child has already\n\t\t     * finished (wait_pid == 0).\n\t\t     * Don't read characters unless we didn't get output for a\n\t\t     * while (noread_cnt > 4), avoids that \":r !ls\" eats\n\t\t     * typeahead.\n\t\t     */\n\t\t    len = 0;\n\t\t    if (!(options & SHELL_EXPAND)\n\t\t\t    && ((options &\n\t\t\t\t\t (SHELL_READ|SHELL_WRITE|SHELL_COOKED))\n\t\t\t\t      != (SHELL_READ|SHELL_WRITE|SHELL_COOKED)\n# ifdef FEAT_GUI\n\t\t\t\t\t\t    || gui.in_use\n# endif\n\t\t\t\t\t\t    )\n\t\t\t    && wait_pid == 0\n\t\t\t    && (ta_len > 0 || noread_cnt > 4))\n\t\t    {\n\t\t      if (ta_len == 0)\n\t\t      {\n\t\t\t  /* Get extra characters when we don't have any.\n\t\t\t   * Reset the counter and timer. */\n\t\t\t  noread_cnt = 0;\n# ifdef ELAPSED_FUNC\n\t\t\t  ELAPSED_INIT(start_tv);\n# endif\n\t\t\t  len = ui_inchar(ta_buf, BUFLEN, 10L, 0);\n\t\t      }\n\t\t      if (ta_len > 0 || len > 0)\n\t\t      {\n\t\t\t/*\n\t\t\t * For pipes:\n\t\t\t * Check for CTRL-C: send interrupt signal to child.\n\t\t\t * Check for CTRL-D: EOF, close pipe to child.\n\t\t\t */\n\t\t\tif (len == 1 && (pty_master_fd < 0 || cmd != NULL))\n\t\t\t{\n# ifdef SIGINT\n\t\t\t    /*\n\t\t\t     * Send SIGINT to the child's group or all\n\t\t\t     * processes in our group.\n\t\t\t     */\n\t\t\t    if (ta_buf[ta_len] == Ctrl_C\n\t\t\t\t\t       || ta_buf[ta_len] == intr_char)\n\t\t\t    {\n#  ifdef HAVE_SETSID\n\t\t\t\tkill(-pid, SIGINT);\n#  else\n\t\t\t\tkill(0, SIGINT);\n#  endif\n\t\t\t\tif (wpid > 0)\n\t\t\t\t    kill(wpid, SIGINT);\n\t\t\t    }\n# endif\n\t\t\t    if (pty_master_fd < 0 && toshell_fd >= 0\n\t\t\t\t\t       && ta_buf[ta_len] == Ctrl_D)\n\t\t\t    {\n\t\t\t\tclose(toshell_fd);\n\t\t\t\ttoshell_fd = -1;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t/* replace K_BS by <BS> and K_DEL by <DEL> */\n\t\t\tfor (i = ta_len; i < ta_len + len; ++i)\n\t\t\t{\n\t\t\t    if (ta_buf[i] == CSI && len - i > 2)\n\t\t\t    {\n\t\t\t\tc = TERMCAP2KEY(ta_buf[i + 1], ta_buf[i + 2]);\n\t\t\t\tif (c == K_DEL || c == K_KDEL || c == K_BS)\n\t\t\t\t{\n\t\t\t\t    mch_memmove(ta_buf + i + 1, ta_buf + i + 3,\n\t\t\t\t\t\t       (size_t)(len - i - 2));\n\t\t\t\t    if (c == K_DEL || c == K_KDEL)\n\t\t\t\t\tta_buf[i] = DEL;\n\t\t\t\t    else\n\t\t\t\t\tta_buf[i] = Ctrl_H;\n\t\t\t\t    len -= 2;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else if (ta_buf[i] == '\\r')\n\t\t\t\tta_buf[i] = '\\n';\n# ifdef FEAT_MBYTE\n\t\t\t    if (has_mbyte)\n\t\t\t\ti += (*mb_ptr2len_len)(ta_buf + i,\n\t\t\t\t\t\t\tta_len + len - i) - 1;\n# endif\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * For pipes: echo the typed characters.\n\t\t\t * For a pty this does not seem to work.\n\t\t\t */\n\t\t\tif (pty_master_fd < 0)\n\t\t\t{\n\t\t\t    for (i = ta_len; i < ta_len + len; ++i)\n\t\t\t    {\n\t\t\t\tif (ta_buf[i] == '\\n' || ta_buf[i] == '\\b')\n\t\t\t\t    msg_putchar(ta_buf[i]);\n# ifdef FEAT_MBYTE\n\t\t\t\telse if (has_mbyte)\n\t\t\t\t{\n\t\t\t\t    int l = (*mb_ptr2len)(ta_buf + i);\n\n\t\t\t\t    msg_outtrans_len(ta_buf + i, l);\n\t\t\t\t    i += l - 1;\n\t\t\t\t}\n# endif\n\t\t\t\telse\n\t\t\t\t    msg_outtrans_len(ta_buf + i, 1);\n\t\t\t    }\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    out_flush();\n\t\t\t}\n\n\t\t\tta_len += len;\n\n\t\t\t/*\n\t\t\t * Write the characters to the child, unless EOF has\n\t\t\t * been typed for pipes.  Write one character at a\n\t\t\t * time, to avoid losing too much typeahead.\n\t\t\t * When writing buffer lines, drop the typed\n\t\t\t * characters (only check for CTRL-C).\n\t\t\t */\n\t\t\tif (options & SHELL_WRITE)\n\t\t\t    ta_len = 0;\n\t\t\telse if (toshell_fd >= 0)\n\t\t\t{\n\t\t\t    len = write(toshell_fd, (char *)ta_buf, (size_t)1);\n\t\t\t    if (len > 0)\n\t\t\t    {\n\t\t\t\tta_len -= len;\n\t\t\t\tmch_memmove(ta_buf, ta_buf + len, ta_len);\n\t\t\t    }\n\t\t\t}\n\t\t      }\n\t\t    }\n\n\t\t    if (got_int)\n\t\t    {\n\t\t\t/* CTRL-C sends a signal to the child, we ignore it\n\t\t\t * ourselves */\n#  ifdef HAVE_SETSID\n\t\t\tkill(-pid, SIGINT);\n#  else\n\t\t\tkill(0, SIGINT);\n#  endif\n\t\t\tif (wpid > 0)\n\t\t\t    kill(wpid, SIGINT);\n\t\t\tgot_int = FALSE;\n\t\t    }\n\n\t\t    /*\n\t\t     * Check if the child has any characters to be printed.\n\t\t     * Read them and write them to our window.\tRepeat this as\n\t\t     * long as there is something to do, avoid the 10ms wait\n\t\t     * for mch_inchar(), or sending typeahead characters to\n\t\t     * the external process.\n\t\t     * TODO: This should handle escape sequences, compatible\n\t\t     * to some terminal (vt52?).\n\t\t     */\n\t\t    ++noread_cnt;\n\t\t    while (RealWaitForChar(fromshell_fd, 10L, NULL, NULL))\n\t\t    {\n\t\t\tlen = read_eintr(fromshell_fd, buffer\n# ifdef FEAT_MBYTE\n\t\t\t\t+ buffer_off, (size_t)(BUFLEN - buffer_off)\n# else\n\t\t\t\t, (size_t)BUFLEN\n# endif\n\t\t\t\t);\n\t\t\tif (len <= 0)\t\t    /* end of file or error */\n\t\t\t    goto finished;\n\n\t\t\tnoread_cnt = 0;\n\t\t\tif (options & SHELL_READ)\n\t\t\t{\n\t\t\t    /* Do NUL -> NL translation, append NL separated\n\t\t\t     * lines to the current buffer. */\n\t\t\t    for (i = 0; i < len; ++i)\n\t\t\t    {\n\t\t\t\tif (buffer[i] == NL)\n\t\t\t\t    append_ga_line(&ga);\n\t\t\t\telse if (buffer[i] == NUL)\n\t\t\t\t    ga_append(&ga, NL);\n\t\t\t\telse\n\t\t\t\t    ga_append(&ga, buffer[i]);\n\t\t\t    }\n\t\t\t}\n# ifdef FEAT_MBYTE\n\t\t\telse if (has_mbyte)\n\t\t\t{\n\t\t\t    int\t\tl;\n\n\t\t\t    len += buffer_off;\n\t\t\t    buffer[len] = NUL;\n\n\t\t\t    /* Check if the last character in buffer[] is\n\t\t\t     * incomplete, keep these bytes for the next\n\t\t\t     * round. */\n\t\t\t    for (p = buffer; p < buffer + len; p += l)\n\t\t\t    {\n\t\t\t\tl = MB_CPTR2LEN(p);\n\t\t\t\tif (l == 0)\n\t\t\t\t    l = 1;  /* NUL byte? */\n\t\t\t\telse if (MB_BYTE2LEN(*p) != l)\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    if (p == buffer)\t/* no complete character */\n\t\t\t    {\n\t\t\t\t/* avoid getting stuck at an illegal byte */\n\t\t\t\tif (len >= 12)\n\t\t\t\t    ++p;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    buffer_off = len;\n\t\t\t\t    continue;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    c = *p;\n\t\t\t    *p = NUL;\n\t\t\t    msg_puts(buffer);\n\t\t\t    if (p < buffer + len)\n\t\t\t    {\n\t\t\t\t*p = c;\n\t\t\t\tbuffer_off = (buffer + len) - p;\n\t\t\t\tmch_memmove(buffer, p, buffer_off);\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t    buffer_off = 0;\n\t\t\t}\n# endif /* FEAT_MBYTE */\n\t\t\telse\n\t\t\t{\n\t\t\t    buffer[len] = NUL;\n\t\t\t    msg_puts(buffer);\n\t\t\t}\n\n\t\t\twindgoto(msg_row, msg_col);\n\t\t\tcursor_on();\n\t\t\tout_flush();\n\t\t\tif (got_int)\n\t\t\t    break;\n\n# ifdef ELAPSED_FUNC\n\t\t\tif (wait_pid == 0)\n\t\t\t{\n\t\t\t    long\tmsec = ELAPSED_FUNC(start_tv);\n\n\t\t\t    /* Avoid that we keep looping here without\n\t\t\t     * checking for a CTRL-C for a long time.  Don't\n\t\t\t     * break out too often to avoid losing typeahead. */\n\t\t\t    if (msec > 2000)\n\t\t\t    {\n\t\t\t\tnoread_cnt = 5;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n# endif\n\t\t    }\n\n\t\t    /* If we already detected the child has finished, continue\n\t\t     * reading output for a short while.  Some text may be\n\t\t     * buffered. */\n\t\t    if (wait_pid == pid)\n\t\t    {\n\t\t\tif (noread_cnt < 5)\n\t\t\t    continue;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    /*\n\t\t     * Check if the child still exists, before checking for\n\t\t     * typed characters (otherwise we would lose typeahead).\n\t\t     */\n# ifdef __NeXT__\n\t\t    wait_pid = wait4(pid, &status, WNOHANG, (struct rusage *)0);\n# else\n\t\t    wait_pid = waitpid(pid, &status, WNOHANG);\n# endif\n\t\t    if ((wait_pid == (pid_t)-1 && errno == ECHILD)\n\t\t\t    || (wait_pid == pid && WIFEXITED(status)))\n\t\t    {\n\t\t\t/* Don't break the loop yet, try reading more\n\t\t\t * characters from \"fromshell_fd\" first.  When using\n\t\t\t * pipes there might still be something to read and\n\t\t\t * then we'll break the loop at the \"break\" above. */\n\t\t\twait_pid = pid;\n\t\t    }\n\t\t    else\n\t\t\twait_pid = 0;\n\n# if defined(FEAT_XCLIPBOARD) && defined(FEAT_X11)\n\t\t    /* Handle any X events, e.g. serving the clipboard. */\n\t\t    clip_update();\n# endif\n\t\t}\nfinished:\n\t\tp_more = p_more_save;\n\t\tif (options & SHELL_READ)\n\t\t{\n\t\t    if (ga.ga_len > 0)\n\t\t    {\n\t\t\tappend_ga_line(&ga);\n\t\t\t/* remember that the NL was missing */\n\t\t\tcurbuf->b_no_eol_lnum = curwin->w_cursor.lnum;\n\t\t    }\n\t\t    else\n\t\t\tcurbuf->b_no_eol_lnum = 0;\n\t\t    ga_clear(&ga);\n\t\t}\n\n\t\t/*\n\t\t * Give all typeahead that wasn't used back to ui_inchar().\n\t\t */\n\t\tif (ta_len)\n\t\t    ui_inchar_undo(ta_buf, ta_len);\n\t\tState = old_State;\n\t\tif (toshell_fd >= 0)\n\t\t    close(toshell_fd);\n\t\tclose(fromshell_fd);\n\t    }\n# if defined(FEAT_XCLIPBOARD) && defined(FEAT_X11)\n\t    else\n\t    {\n\t\tlong delay_msec = 1;\n\n\t\t/*\n\t\t * Similar to the loop above, but only handle X events, no\n\t\t * I/O.\n\t\t */\n\t\tfor (;;)\n\t\t{\n\t\t    if (got_int)\n\t\t    {\n\t\t\t/* CTRL-C sends a signal to the child, we ignore it\n\t\t\t * ourselves */\n#  ifdef HAVE_SETSID\n\t\t\tkill(-pid, SIGINT);\n#  else\n\t\t\tkill(0, SIGINT);\n#  endif\n\t\t\tgot_int = FALSE;\n\t\t    }\n# ifdef __NeXT__\n\t\t    wait_pid = wait4(pid, &status, WNOHANG, (struct rusage *)0);\n# else\n\t\t    wait_pid = waitpid(pid, &status, WNOHANG);\n# endif\n\t\t    if ((wait_pid == (pid_t)-1 && errno == ECHILD)\n\t\t\t    || (wait_pid == pid && WIFEXITED(status)))\n\t\t    {\n\t\t\twait_pid = pid;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    /* Handle any X events, e.g. serving the clipboard. */\n\t\t    clip_update();\n\n\t\t    /* Wait for 1 to 10 msec. 1 is faster but gives the child\n\t\t     * less time. */\n\t\t    mch_delay(delay_msec, TRUE);\n\t\t    if (++delay_msec > 10)\n\t\t\tdelay_msec = 10;\n\t\t}\n\t    }\n# endif\n\n\t    /*\n\t     * Wait until our child has exited.\n\t     * Ignore wait() returning pids of other children and returning\n\t     * because of some signal like SIGWINCH.\n\t     * Don't wait if wait_pid was already set above, indicating the\n\t     * child already exited.\n\t     */\n\t    if (wait_pid != pid)\n\t\twait_pid = wait4pid(pid, &status);\n\n# ifdef FEAT_GUI\n\t    /* Close slave side of pty.  Only do this after the child has\n\t     * exited, otherwise the child may hang when it tries to write on\n\t     * the pty. */\n\t    if (pty_master_fd >= 0)\n\t\tclose(pty_slave_fd);\n# endif\n\n\t    /* Make sure the child that writes to the external program is\n\t     * dead. */\n\t    if (wpid > 0)\n\t    {\n\t\tkill(wpid, SIGKILL);\n\t\twait4pid(wpid, NULL);\n\t    }\n\n# ifdef FEAT_JOB_CHANNEL\n\t    --dont_check_job_ended;\n# endif\n\n\t    /*\n\t     * Set to raw mode right now, otherwise a CTRL-C after\n\t     * catch_signals() will kill Vim.\n\t     */\n\t    if (tmode == TMODE_RAW)\n\t\tsettmode(TMODE_RAW);\n\t    did_settmode = TRUE;\n\t    set_signals();\n\n\t    if (WIFEXITED(status))\n\t    {\n\t\t/* LINTED avoid \"bitwise operation on signed value\" */\n\t\tretval = WEXITSTATUS(status);\n\t\tif (retval != 0 && !emsg_silent)\n\t\t{\n\t\t    if (retval == EXEC_FAILED)\n\t\t    {\n\t\t\tMSG_PUTS(_(\"\\nCannot execute shell \"));\n\t\t\tmsg_outtrans(p_sh);\n\t\t\tmsg_putchar('\\n');\n\t\t    }\n\t\t    else if (!(options & SHELL_SILENT))\n\t\t    {\n\t\t\tMSG_PUTS(_(\"\\nshell returned \"));\n\t\t\tmsg_outnum((long)retval);\n\t\t\tmsg_putchar('\\n');\n\t\t    }\n\t\t}\n\t    }\n\t    else\n\t\tMSG_PUTS(_(\"\\nCommand terminated\\n\"));\n\t}\n    }\n    vim_free(argv);\n    vim_free(p_shcf_copy);\n\nerror:\n    if (!did_settmode)\n\tif (tmode == TMODE_RAW)\n\t    settmode(TMODE_RAW);\t/* set to raw mode */\n# ifdef FEAT_TITLE\n    resettitle();\n# endif\n    vim_free(newcmd);\n\n    return retval;\n\n#endif /* USE_SYSTEM */\n}\n\n#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n    void\nmch_start_job(char **argv, job_T *job, jobopt_T *options UNUSED)\n{\n    pid_t\tpid;\n    int\t\tfd_in[2];\t/* for stdin */\n    int\t\tfd_out[2];\t/* for stdout */\n    int\t\tfd_err[2];\t/* for stderr */\n    channel_T\t*channel = NULL;\n    int\t\tuse_null_for_in = options->jo_io[PART_IN] == JIO_NULL;\n    int\t\tuse_null_for_out = options->jo_io[PART_OUT] == JIO_NULL;\n    int\t\tuse_null_for_err = options->jo_io[PART_ERR] == JIO_NULL;\n    int\t\tuse_file_for_in = options->jo_io[PART_IN] == JIO_FILE;\n    int\t\tuse_file_for_out = options->jo_io[PART_OUT] == JIO_FILE;\n    int\t\tuse_file_for_err = options->jo_io[PART_ERR] == JIO_FILE;\n    int\t\tuse_out_for_err = options->jo_io[PART_ERR] == JIO_OUT;\n    SIGSET_DECL(curset)\n\n    if (use_out_for_err && use_null_for_out)\n\tuse_null_for_err = TRUE;\n\n    /* default is to fail */\n    job->jv_status = JOB_FAILED;\n    fd_in[0] = -1;\n    fd_in[1] = -1;\n    fd_out[0] = -1;\n    fd_out[1] = -1;\n    fd_err[0] = -1;\n    fd_err[1] = -1;\n\n    /* TODO: without the channel feature connect the child to /dev/null? */\n    /* Open pipes for stdin, stdout, stderr. */\n    if (use_file_for_in)\n    {\n\tchar_u *fname = options->jo_io_name[PART_IN];\n\n\tfd_in[0] = mch_open((char *)fname, O_RDONLY, 0);\n\tif (fd_in[0] < 0)\n\t{\n\t    EMSG2(_(e_notopen), fname);\n\t    goto failed;\n\t}\n    }\n    else if (!use_null_for_in && pipe(fd_in) < 0)\n\tgoto failed;\n\n    if (use_file_for_out)\n    {\n\tchar_u *fname = options->jo_io_name[PART_OUT];\n\n\tfd_out[1] = mch_open((char *)fname, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\tif (fd_out[1] < 0)\n\t{\n\t    EMSG2(_(e_notopen), fname);\n\t    goto failed;\n\t}\n    }\n    else if (!use_null_for_out && pipe(fd_out) < 0)\n\tgoto failed;\n\n    if (use_file_for_err)\n    {\n\tchar_u *fname = options->jo_io_name[PART_ERR];\n\n\tfd_err[1] = mch_open((char *)fname, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n\tif (fd_err[1] < 0)\n\t{\n\t    EMSG2(_(e_notopen), fname);\n\t    goto failed;\n\t}\n    }\n    else if (!use_out_for_err && !use_null_for_err && pipe(fd_err) < 0)\n\tgoto failed;\n\n    if (!use_null_for_in || !use_null_for_out || !use_null_for_err)\n    {\n\tif (options->jo_set & JO_CHANNEL)\n\t{\n\t    channel = options->jo_channel;\n\t    if (channel != NULL)\n\t\t++channel->ch_refcount;\n\t}\n\telse\n\t    channel = add_channel();\n\tif (channel == NULL)\n\t    goto failed;\n    }\n\n    BLOCK_SIGNALS(&curset);\n    pid = fork();\t/* maybe we should use vfork() */\n    if (pid == -1)\n    {\n\t/* failed to fork */\n\tUNBLOCK_SIGNALS(&curset);\n\tgoto failed;\n    }\n    if (pid == 0)\n    {\n\tint\tnull_fd = -1;\n\tint\tstderr_works = TRUE;\n\n\t/* child */\n\treset_signals();\t\t/* handle signals normally */\n\tUNBLOCK_SIGNALS(&curset);\n\n# ifdef HAVE_SETSID\n\t/* Create our own process group, so that the child and all its\n\t * children can be kill()ed.  Don't do this when using pipes,\n\t * because stdin is not a tty, we would lose /dev/tty. */\n\t(void)setsid();\n# endif\n\n\tset_child_environment();\n\n\tif (use_null_for_in || use_null_for_out || use_null_for_err)\n\t    null_fd = open(\"/dev/null\", O_RDWR | O_EXTRA, 0);\n\n\t/* set up stdin for the child */\n\tif (use_null_for_in && null_fd >= 0)\n\t{\n\t    close(0);\n\t    ignored = dup(null_fd);\n\t}\n\telse\n\t{\n\t    if (!use_file_for_in)\n\t\tclose(fd_in[1]);\n\t    close(0);\n\t    ignored = dup(fd_in[0]);\n\t    close(fd_in[0]);\n\t}\n\n\t/* set up stderr for the child */\n\tif (use_null_for_err && null_fd >= 0)\n\t{\n\t    close(2);\n\t    ignored = dup(null_fd);\n\t    stderr_works = FALSE;\n\t}\n\telse if (use_out_for_err)\n\t{\n\t    close(2);\n\t    ignored = dup(fd_out[1]);\n\t}\n\telse\n\t{\n\t    if (!use_file_for_err)\n\t\tclose(fd_err[0]);\n\t    close(2);\n\t    ignored = dup(fd_err[1]);\n\t    close(fd_err[1]);\n\t}\n\n\t/* set up stdout for the child */\n\tif (use_null_for_out && null_fd >= 0)\n\t{\n\t    close(1);\n\t    ignored = dup(null_fd);\n\t}\n\telse\n\t{\n\t    if (!use_file_for_out)\n\t\tclose(fd_out[0]);\n\t    close(1);\n\t    ignored = dup(fd_out[1]);\n\t    close(fd_out[1]);\n\t}\n\n\tif (null_fd >= 0)\n\t    close(null_fd);\n\n\t/* See above for type of argv. */\n\texecvp(argv[0], argv);\n\n\tif (stderr_works)\n\t    perror(\"executing job failed\");\n#ifdef EXITFREE\n\t/* calling free_all_mem() here causes problems. Ignore valgrind\n\t * reporting possibly leaked memory. */\n#endif\n\t_exit(EXEC_FAILED);\t    /* exec failed, return failure code */\n    }\n\n    /* parent */\n    UNBLOCK_SIGNALS(&curset);\n\n    job->jv_pid = pid;\n    job->jv_status = JOB_STARTED;\n    job->jv_channel = channel;  /* ch_refcount was set above */\n\n    /* child stdin, stdout and stderr */\n    if (!use_file_for_in && fd_in[0] >= 0)\n\tclose(fd_in[0]);\n    if (!use_file_for_out && fd_out[1] >= 0)\n\tclose(fd_out[1]);\n    if (!use_out_for_err && !use_file_for_err && fd_err[1] >= 0)\n\tclose(fd_err[1]);\n    if (channel != NULL)\n    {\n\tchannel_set_pipes(channel,\n\t\t      use_file_for_in || use_null_for_in\n\t\t\t\t\t\t      ? INVALID_FD : fd_in[1],\n\t\t      use_file_for_out || use_null_for_out\n\t\t\t\t\t\t     ? INVALID_FD : fd_out[0],\n\t\t      use_out_for_err || use_file_for_err || use_null_for_err\n\t\t\t\t\t\t    ? INVALID_FD : fd_err[0]);\n\tchannel_set_job(channel, job, options);\n    }\n\n    /* success! */\n    return;\n\nfailed:\n    channel_unref(channel);\n    if (fd_in[0] >= 0)\n\tclose(fd_in[0]);\n    if (fd_in[1] >= 0)\n\tclose(fd_in[1]);\n    if (fd_out[0] >= 0)\n\tclose(fd_out[0]);\n    if (fd_out[1] >= 0)\n\tclose(fd_out[1]);\n    if (fd_err[0] >= 0)\n\tclose(fd_err[0]);\n    if (fd_err[1] >= 0)\n\tclose(fd_err[1]);\n}\n\n    char *\nmch_job_status(job_T *job)\n{\n# ifdef HAVE_UNION_WAIT\n    union wait\tstatus;\n# else\n    int\t\tstatus = -1;\n# endif\n    pid_t\twait_pid = 0;\n\n# ifdef __NeXT__\n    wait_pid = wait4(job->jv_pid, &status, WNOHANG, (struct rusage *)0);\n# else\n    wait_pid = waitpid(job->jv_pid, &status, WNOHANG);\n# endif\n    if (wait_pid == -1)\n    {\n\t/* process must have exited */\n\tgoto return_dead;\n    }\n    if (wait_pid == 0)\n\treturn \"run\";\n    if (WIFEXITED(status))\n    {\n\t/* LINTED avoid \"bitwise operation on signed value\" */\n\tjob->jv_exitval = WEXITSTATUS(status);\n\tgoto return_dead;\n    }\n    if (WIFSIGNALED(status))\n    {\n\tjob->jv_exitval = -1;\n\tgoto return_dead;\n    }\n    return \"run\";\n\nreturn_dead:\n    if (job->jv_status < JOB_ENDED)\n    {\n\tch_log(job->jv_channel, \"Job ended\");\n\tjob->jv_status = JOB_ENDED;\n    }\n    return \"dead\";\n}\n\n    job_T *\nmch_detect_ended_job(job_T *job_list)\n{\n# ifdef HAVE_UNION_WAIT\n    union wait\tstatus;\n# else\n    int\t\tstatus = -1;\n# endif\n    pid_t\twait_pid = 0;\n    job_T\t*job;\n\n# ifndef USE_SYSTEM\n    /* Do not do this when waiting for a shell command to finish, we would get\n     * the exit value here (and discard it), the exit value obtained there\n     * would then be wrong.  */\n    if (dont_check_job_ended > 0)\n\treturn NULL;\n# endif\n\n# ifdef __NeXT__\n    wait_pid = wait4(-1, &status, WNOHANG, (struct rusage *)0);\n# else\n    wait_pid = waitpid(-1, &status, WNOHANG);\n# endif\n    if (wait_pid <= 0)\n\t/* no process ended */\n\treturn NULL;\n    for (job = job_list; job != NULL; job = job->jv_next)\n    {\n\tif (job->jv_pid == wait_pid)\n\t{\n\t    if (WIFEXITED(status))\n\t\t/* LINTED avoid \"bitwise operation on signed value\" */\n\t\tjob->jv_exitval = WEXITSTATUS(status);\n\t    else if (WIFSIGNALED(status))\n\t\tjob->jv_exitval = -1;\n\t    if (job->jv_status < JOB_ENDED)\n\t    {\n\t\tch_log(job->jv_channel, \"Job ended\");\n\t\tjob->jv_status = JOB_ENDED;\n\t    }\n\t    return job;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Send a (deadly) signal to \"job\".\n * Return FAIL if \"how\" is not a valid name.\n */\n    int\nmch_stop_job(job_T *job, char_u *how)\n{\n    int\t    sig = -1;\n    pid_t   job_pid;\n\n    if (*how == NUL || STRCMP(how, \"term\") == 0)\n\tsig = SIGTERM;\n    else if (STRCMP(how, \"hup\") == 0)\n\tsig = SIGHUP;\n    else if (STRCMP(how, \"quit\") == 0)\n\tsig = SIGQUIT;\n    else if (STRCMP(how, \"int\") == 0)\n\tsig = SIGINT;\n    else if (STRCMP(how, \"kill\") == 0)\n\tsig = SIGKILL;\n    else if (isdigit(*how))\n\tsig = atoi((char *)how);\n    else\n\treturn FAIL;\n\n    /* TODO: have an option to only kill the process, not the group? */\n    job_pid = job->jv_pid;\n#ifdef HAVE_GETPGID\n    if (job_pid == getpgid(job_pid))\n\tjob_pid = -job_pid;\n#endif\n\n    kill(job_pid, sig);\n\n    return OK;\n}\n\n/*\n * Clear the data related to \"job\".\n */\n    void\nmch_clear_job(job_T *job)\n{\n    /* call waitpid because child process may become zombie */\n# ifdef __NeXT__\n    (void)wait4(job->jv_pid, NULL, WNOHANG, (struct rusage *)0);\n# else\n    (void)waitpid(job->jv_pid, NULL, WNOHANG);\n# endif\n}\n#endif\n\n/*\n * Check for CTRL-C typed by reading all available characters.\n * In cooked mode we should get SIGINT, no need to check.\n */\n    void\nmch_breakcheck(int force)\n{\n    if ((curr_tmode == TMODE_RAW || force)\n\t\t\t       && RealWaitForChar(read_cmd_fd, 0L, NULL, NULL))\n\tfill_input_buf(FALSE);\n}\n\n/*\n * Wait \"msec\" msec until a character is available from the mouse, keyboard,\n * from inbuf[].\n * \"msec\" == -1 will block forever.\n * Invokes timer callbacks when needed.\n * \"interrupted\" (if not NULL) is set to TRUE when no character is available\n * but something else needs to be done.\n * Returns TRUE when a character is available.\n * When a GUI is being used, this will never get called -- webb\n */\n    static int\nWaitForChar(long msec, int *interrupted)\n{\n#ifdef FEAT_TIMERS\n    long    due_time;\n    long    remaining = msec;\n    int\t    tb_change_cnt = typebuf.tb_change_cnt;\n\n    /* When waiting very briefly don't trigger timers. */\n    if (msec >= 0 && msec < 10L)\n\treturn WaitForCharOrMouse(msec, NULL);\n\n    while (msec < 0 || remaining > 0)\n    {\n\t/* Trigger timers and then get the time in msec until the next one is\n\t * due.  Wait up to that time. */\n\tdue_time = check_due_timer();\n\tif (typebuf.tb_change_cnt != tb_change_cnt)\n\t{\n\t    /* timer may have used feedkeys() */\n\t    return FALSE;\n\t}\n\tif (due_time <= 0 || (msec > 0 && due_time > remaining))\n\t    due_time = remaining;\n\tif (WaitForCharOrMouse(due_time, interrupted))\n\t    return TRUE;\n\tif (interrupted != NULL && *interrupted)\n\t    /* Nothing available, but need to return so that side effects get\n\t     * handled, such as handling a message on a channel. */\n\t    return FALSE;\n\tif (msec > 0)\n\t    remaining -= due_time;\n    }\n    return FALSE;\n#else\n    return WaitForCharOrMouse(msec, interrupted);\n#endif\n}\n\n/*\n * Wait \"msec\" msec until a character is available from the mouse or keyboard\n * or from inbuf[].\n * \"msec\" == -1 will block forever.\n * \"interrupted\" (if not NULL) is set to TRUE when no character is available\n * but something else needs to be done.\n * When a GUI is being used, this will never get called -- webb\n */\n    static int\nWaitForCharOrMouse(long msec, int *interrupted)\n{\n#ifdef FEAT_MOUSE_GPM\n    int\t\tgpm_process_wanted;\n#endif\n#ifdef FEAT_XCLIPBOARD\n    int\t\trest;\n#endif\n    int\t\tavail;\n\n    if (input_available())\t    /* something in inbuf[] */\n\treturn 1;\n\n#if defined(FEAT_MOUSE_DEC)\n    /* May need to query the mouse position. */\n    if (WantQueryMouse)\n    {\n\tWantQueryMouse = FALSE;\n\tmch_write((char_u *)IF_EB(\"\\033[1'|\", ESC_STR \"[1'|\"), 5);\n    }\n#endif\n\n    /*\n     * For FEAT_MOUSE_GPM and FEAT_XCLIPBOARD we loop here to process mouse\n     * events.  This is a bit complicated, because they might both be defined.\n     */\n#if defined(FEAT_MOUSE_GPM) || defined(FEAT_XCLIPBOARD)\n# ifdef FEAT_XCLIPBOARD\n    rest = 0;\n    if (do_xterm_trace())\n\trest = msec;\n# endif\n    do\n    {\n# ifdef FEAT_XCLIPBOARD\n\tif (rest != 0)\n\t{\n\t    msec = XT_TRACE_DELAY;\n\t    if (rest >= 0 && rest < XT_TRACE_DELAY)\n\t\tmsec = rest;\n\t    if (rest >= 0)\n\t\trest -= msec;\n\t}\n# endif\n# ifdef FEAT_MOUSE_GPM\n\tgpm_process_wanted = 0;\n\tavail = RealWaitForChar(read_cmd_fd, msec,\n\t\t\t\t\t     &gpm_process_wanted, interrupted);\n# else\n\tavail = RealWaitForChar(read_cmd_fd, msec, NULL, interrupted);\n# endif\n\tif (!avail)\n\t{\n\t    if (input_available())\n\t\treturn 1;\n# ifdef FEAT_XCLIPBOARD\n\t    if (rest == 0 || !do_xterm_trace())\n# endif\n\t\tbreak;\n\t}\n    }\n    while (FALSE\n# ifdef FEAT_MOUSE_GPM\n\t   || (gpm_process_wanted && mch_gpm_process() == 0)\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t   || (!avail && rest != 0)\n# endif\n\t  )\n\t;\n\n#else\n    avail = RealWaitForChar(read_cmd_fd, msec, NULL, interrupted);\n#endif\n    return avail;\n}\n\n#ifndef VMS\n/*\n * Wait \"msec\" msec until a character is available from file descriptor \"fd\".\n * \"msec\" == 0 will check for characters once.\n * \"msec\" == -1 will block until a character is available.\n * When a GUI is being used, this will not be used for input -- webb\n * Or when a Linux GPM mouse event is waiting.\n * Or when a clientserver message is on the queue.\n * \"interrupted\" (if not NULL) is set to TRUE when no character is available\n * but something else needs to be done.\n */\n#if defined(__BEOS__)\n    int\n#else\n    static int\n#endif\nRealWaitForChar(int fd, long msec, int *check_for_gpm UNUSED, int *interrupted)\n{\n    int\t\tret;\n    int\t\tresult;\n#if defined(FEAT_XCLIPBOARD) || defined(USE_XSMP) || defined(FEAT_MZSCHEME)\n    static int\tbusy = FALSE;\n\n    /* May retry getting characters after an event was handled. */\n# define MAY_LOOP\n\n# ifdef ELAPSED_FUNC\n    /* Remember at what time we started, so that we know how much longer we\n     * should wait after being interrupted. */\n    long\t    start_msec = msec;\n    ELAPSED_TYPE  start_tv;\n\n    if (msec > 0)\n\tELAPSED_INIT(start_tv);\n# endif\n\n    /* Handle being called recursively.  This may happen for the session\n     * manager stuff, it may save the file, which does a breakcheck. */\n    if (busy)\n\treturn 0;\n#endif\n\n#ifdef MAY_LOOP\n    for (;;)\n#endif\n    {\n#ifdef MAY_LOOP\n\tint\t\tfinished = TRUE; /* default is to 'loop' just once */\n# ifdef FEAT_MZSCHEME\n\tint\t\tmzquantum_used = FALSE;\n# endif\n#endif\n#ifndef HAVE_SELECT\n\t\t\t/* each channel may use in, out and err */\n\tstruct pollfd   fds[6 + 3 * MAX_OPEN_CHANNELS];\n\tint\t\tnfd;\n# ifdef FEAT_XCLIPBOARD\n\tint\t\txterm_idx = -1;\n# endif\n# ifdef FEAT_MOUSE_GPM\n\tint\t\tgpm_idx = -1;\n# endif\n# ifdef USE_XSMP\n\tint\t\txsmp_idx = -1;\n# endif\n\tint\t\ttowait = (int)msec;\n\n# ifdef FEAT_MZSCHEME\n\tmzvim_check_threads();\n\tif (mzthreads_allowed() && p_mzq > 0 && (msec < 0 || msec > p_mzq))\n\t{\n\t    towait = (int)p_mzq;    /* don't wait longer than 'mzquantum' */\n\t    mzquantum_used = TRUE;\n\t}\n# endif\n\tfds[0].fd = fd;\n\tfds[0].events = POLLIN;\n\tnfd = 1;\n\n# ifdef FEAT_XCLIPBOARD\n\tmay_restore_clipboard();\n\tif (xterm_Shell != (Widget)0)\n\t{\n\t    xterm_idx = nfd;\n\t    fds[nfd].fd = ConnectionNumber(xterm_dpy);\n\t    fds[nfd].events = POLLIN;\n\t    nfd++;\n\t}\n# endif\n# ifdef FEAT_MOUSE_GPM\n\tif (check_for_gpm != NULL && gpm_flag && gpm_fd >= 0)\n\t{\n\t    gpm_idx = nfd;\n\t    fds[nfd].fd = gpm_fd;\n\t    fds[nfd].events = POLLIN;\n\t    nfd++;\n\t}\n# endif\n# ifdef USE_XSMP\n\tif (xsmp_icefd != -1)\n\t{\n\t    xsmp_idx = nfd;\n\t    fds[nfd].fd = xsmp_icefd;\n\t    fds[nfd].events = POLLIN;\n\t    nfd++;\n\t}\n# endif\n#ifdef FEAT_JOB_CHANNEL\n\tnfd = channel_poll_setup(nfd, &fds);\n#endif\n\tif (interrupted != NULL)\n\t    *interrupted = FALSE;\n\n\tret = poll(fds, nfd, towait);\n\n\tresult = ret > 0 && (fds[0].revents & POLLIN);\n\tif (result == 0 && interrupted != NULL && ret > 0)\n\t    *interrupted = TRUE;\n\n# ifdef FEAT_MZSCHEME\n\tif (ret == 0 && mzquantum_used)\n\t    /* MzThreads scheduling is required and timeout occurred */\n\t    finished = FALSE;\n# endif\n\n# ifdef FEAT_XCLIPBOARD\n\tif (xterm_Shell != (Widget)0 && (fds[xterm_idx].revents & POLLIN))\n\t{\n\t    xterm_update();      /* Maybe we should hand out clipboard */\n\t    if (--ret == 0 && !input_available())\n\t\t/* Try again */\n\t\tfinished = FALSE;\n\t}\n# endif\n# ifdef FEAT_MOUSE_GPM\n\tif (gpm_idx >= 0 && (fds[gpm_idx].revents & POLLIN))\n\t{\n\t    *check_for_gpm = 1;\n\t}\n# endif\n# ifdef USE_XSMP\n\tif (xsmp_idx >= 0 && (fds[xsmp_idx].revents & (POLLIN | POLLHUP)))\n\t{\n\t    if (fds[xsmp_idx].revents & POLLIN)\n\t    {\n\t\tbusy = TRUE;\n\t\txsmp_handle_requests();\n\t\tbusy = FALSE;\n\t    }\n\t    else if (fds[xsmp_idx].revents & POLLHUP)\n\t    {\n\t\tif (p_verbose > 0)\n\t\t    verb_msg((char_u *)_(\"XSMP lost ICE connection\"));\n\t\txsmp_close();\n\t    }\n\t    if (--ret == 0)\n\t\tfinished = FALSE;\t/* Try again */\n\t}\n# endif\n#ifdef FEAT_JOB_CHANNEL\n\tif (ret > 0)\n\t    ret = channel_poll_check(ret, &fds);\n#endif\n\n#else /* HAVE_SELECT */\n\n\tstruct timeval  tv;\n\tstruct timeval\t*tvp;\n\tfd_set\t\trfds, wfds, efds;\n\tint\t\tmaxfd;\n\tlong\t\ttowait = msec;\n\n# ifdef FEAT_MZSCHEME\n\tmzvim_check_threads();\n\tif (mzthreads_allowed() && p_mzq > 0 && (msec < 0 || msec > p_mzq))\n\t{\n\t    towait = p_mzq;\t/* don't wait longer than 'mzquantum' */\n\t    mzquantum_used = TRUE;\n\t}\n# endif\n\n\tif (towait >= 0)\n\t{\n\t    tv.tv_sec = towait / 1000;\n\t    tv.tv_usec = (towait % 1000) * (1000000/1000);\n\t    tvp = &tv;\n\t}\n\telse\n\t    tvp = NULL;\n\n\t/*\n\t * Select on ready for reading and exceptional condition (end of file).\n\t */\nselect_eintr:\n\tFD_ZERO(&rfds);\n\tFD_ZERO(&wfds);\n\tFD_ZERO(&efds);\n\tFD_SET(fd, &rfds);\n# if !defined(__QNX__) && !defined(__CYGWIN32__)\n\t/* For QNX select() always returns 1 if this is set.  Why? */\n\tFD_SET(fd, &efds);\n# endif\n\tmaxfd = fd;\n\n# ifdef FEAT_XCLIPBOARD\n\tmay_restore_clipboard();\n\tif (xterm_Shell != (Widget)0)\n\t{\n\t    FD_SET(ConnectionNumber(xterm_dpy), &rfds);\n\t    if (maxfd < ConnectionNumber(xterm_dpy))\n\t\tmaxfd = ConnectionNumber(xterm_dpy);\n\n\t    /* An event may have already been read but not handled.  In\n\t     * particulary, XFlush may cause this. */\n\t    xterm_update();\n\t}\n# endif\n# ifdef FEAT_MOUSE_GPM\n\tif (check_for_gpm != NULL && gpm_flag && gpm_fd >= 0)\n\t{\n\t    FD_SET(gpm_fd, &rfds);\n\t    FD_SET(gpm_fd, &efds);\n\t    if (maxfd < gpm_fd)\n\t\tmaxfd = gpm_fd;\n\t}\n# endif\n# ifdef USE_XSMP\n\tif (xsmp_icefd != -1)\n\t{\n\t    FD_SET(xsmp_icefd, &rfds);\n\t    FD_SET(xsmp_icefd, &efds);\n\t    if (maxfd < xsmp_icefd)\n\t\tmaxfd = xsmp_icefd;\n\t}\n# endif\n# ifdef FEAT_JOB_CHANNEL\n\tmaxfd = channel_select_setup(maxfd, &rfds, &wfds);\n# endif\n\tif (interrupted != NULL)\n\t    *interrupted = FALSE;\n\n\tret = select(maxfd + 1, &rfds, &wfds, &efds, tvp);\n\tresult = ret > 0 && FD_ISSET(fd, &rfds);\n\tif (result)\n\t    --ret;\n\telse if (interrupted != NULL && ret > 0)\n\t    *interrupted = TRUE;\n\n# ifdef EINTR\n\tif (ret == -1 && errno == EINTR)\n\t{\n\t    /* Check whether window has been resized, EINTR may be caused by\n\t     * SIGWINCH. */\n\t    if (do_resize)\n\t\thandle_resize();\n\n\t    /* Interrupted by a signal, need to try again.  We ignore msec\n\t     * here, because we do want to check even after a timeout if\n\t     * characters are available.  Needed for reading output of an\n\t     * external command after the process has finished. */\n\t    goto select_eintr;\n\t}\n# endif\n# ifdef __TANDEM\n\tif (ret == -1 && errno == ENOTSUP)\n\t{\n\t    FD_ZERO(&rfds);\n\t    FD_ZERO(&efds);\n\t    ret = 0;\n\t}\n# endif\n# ifdef FEAT_MZSCHEME\n\tif (ret == 0 && mzquantum_used)\n\t    /* loop if MzThreads must be scheduled and timeout occurred */\n\t    finished = FALSE;\n# endif\n\n# ifdef FEAT_XCLIPBOARD\n\tif (ret > 0 && xterm_Shell != (Widget)0\n\t\t&& FD_ISSET(ConnectionNumber(xterm_dpy), &rfds))\n\t{\n\t    xterm_update();\t      /* Maybe we should hand out clipboard */\n\t    /* continue looping when we only got the X event and the input\n\t     * buffer is empty */\n\t    if (--ret == 0 && !input_available())\n\t    {\n\t\t/* Try again */\n\t\tfinished = FALSE;\n\t    }\n\t}\n# endif\n# ifdef FEAT_MOUSE_GPM\n\tif (ret > 0 && gpm_flag && check_for_gpm != NULL && gpm_fd >= 0)\n\t{\n\t    if (FD_ISSET(gpm_fd, &efds))\n\t\tgpm_close();\n\t    else if (FD_ISSET(gpm_fd, &rfds))\n\t\t*check_for_gpm = 1;\n\t}\n# endif\n# ifdef USE_XSMP\n\tif (ret > 0 && xsmp_icefd != -1)\n\t{\n\t    if (FD_ISSET(xsmp_icefd, &efds))\n\t    {\n\t\tif (p_verbose > 0)\n\t\t    verb_msg((char_u *)_(\"XSMP lost ICE connection\"));\n\t\txsmp_close();\n\t\tif (--ret == 0)\n\t\t    finished = FALSE;   /* keep going if event was only one */\n\t    }\n\t    else if (FD_ISSET(xsmp_icefd, &rfds))\n\t    {\n\t\tbusy = TRUE;\n\t\txsmp_handle_requests();\n\t\tbusy = FALSE;\n\t\tif (--ret == 0)\n\t\t    finished = FALSE;   /* keep going if event was only one */\n\t    }\n\t}\n# endif\n#ifdef FEAT_JOB_CHANNEL\n\tif (ret > 0)\n\t    ret = channel_select_check(ret, &rfds, &wfds);\n#endif\n\n#endif /* HAVE_SELECT */\n\n#ifdef MAY_LOOP\n\tif (finished || msec == 0)\n\t    break;\n\n# ifdef FEAT_CLIENTSERVER\n\tif (server_waiting())\n\t    break;\n# endif\n\n\t/* We're going to loop around again, find out for how long */\n\tif (msec > 0)\n\t{\n# ifdef ELAPSED_FUNC\n\t    /* Compute remaining wait time. */\n\t    msec = start_msec - ELAPSED_FUNC(start_tv);\n# else\n\t    /* Guess we got interrupted halfway. */\n\t    msec = msec / 2;\n# endif\n\t    if (msec <= 0)\n\t\tbreak;\t/* waited long enough */\n\t}\n#endif\n    }\n\n    return result;\n}\n\n#ifndef NO_EXPANDPATH\n/*\n * Expand a path into all matching files and/or directories.  Handles \"*\",\n * \"?\", \"[a-z]\", \"**\", etc.\n * \"path\" has backslashes before chars that are not to be expanded.\n * Returns the number of matches found.\n */\n    int\nmch_expandpath(\n    garray_T\t*gap,\n    char_u\t*path,\n    int\t\tflags)\t\t/* EW_* flags */\n{\n    return unix_expandpath(gap, path, 0, flags, FALSE);\n}\n#endif\n\n/*\n * mch_expand_wildcards() - this code does wild-card pattern matching using\n * the shell\n *\n * return OK for success, FAIL for error (you may lose some memory) and put\n * an error message in *file.\n *\n * num_pat is number of input patterns\n * pat is array of pointers to input patterns\n * num_file is pointer to number of matched file names\n * file is pointer to array of pointers to matched file names\n */\n\n#ifndef SEEK_SET\n# define SEEK_SET 0\n#endif\n#ifndef SEEK_END\n# define SEEK_END 2\n#endif\n\n#define SHELL_SPECIAL (char_u *)\"\\t \\\"&'$;<>()\\\\|\"\n\n    int\nmch_expand_wildcards(\n    int\t\t   num_pat,\n    char_u\t **pat,\n    int\t\t  *num_file,\n    char_u\t***file,\n    int\t\t   flags)\t/* EW_* flags */\n{\n    int\t\ti;\n    size_t\tlen;\n    char_u\t*p;\n    int\t\tdir;\n\n    /*\n     * This is the non-OS/2 implementation (really Unix).\n     */\n    int\t\tj;\n    char_u\t*tempname;\n    char_u\t*command;\n    FILE\t*fd;\n    char_u\t*buffer;\n#define STYLE_ECHO\t0\t/* use \"echo\", the default */\n#define STYLE_GLOB\t1\t/* use \"glob\", for csh */\n#define STYLE_VIMGLOB\t2\t/* use \"vimglob\", for Posix sh */\n#define STYLE_PRINT\t3\t/* use \"print -N\", for zsh */\n#define STYLE_BT\t4\t/* `cmd` expansion, execute the pattern\n\t\t\t\t * directly */\n    int\t\tshell_style = STYLE_ECHO;\n    int\t\tcheck_spaces;\n    static int\tdid_find_nul = FALSE;\n    int\t\tampersent = FALSE;\n\t\t/* vimglob() function to define for Posix shell */\n    static char *sh_vimglob_func = \"vimglob() { while [ $# -ge 1 ]; do echo \\\"$1\\\"; shift; done }; vimglob >\";\n\n    *num_file = 0;\t/* default: no files found */\n    *file = NULL;\n\n    /*\n     * If there are no wildcards, just copy the names to allocated memory.\n     * Saves a lot of time, because we don't have to start a new shell.\n     */\n    if (!have_wildcard(num_pat, pat))\n\treturn save_patterns(num_pat, pat, num_file, file);\n\n# ifdef HAVE_SANDBOX\n    /* Don't allow any shell command in the sandbox. */\n    if (sandbox != 0 && check_secure())\n\treturn FAIL;\n# endif\n\n    /*\n     * Don't allow the use of backticks in secure and restricted mode.\n     */\n    if (secure || restricted)\n\tfor (i = 0; i < num_pat; ++i)\n\t    if (vim_strchr(pat[i], '`') != NULL\n\t\t    && (check_restricted() || check_secure()))\n\t\treturn FAIL;\n\n    /*\n     * get a name for the temp file\n     */\n    if ((tempname = vim_tempname('o', FALSE)) == NULL)\n    {\n\tEMSG(_(e_notmp));\n\treturn FAIL;\n    }\n\n    /*\n     * Let the shell expand the patterns and write the result into the temp\n     * file.\n     * STYLE_BT:\tNL separated\n     *\t    If expanding `cmd` execute it directly.\n     * STYLE_GLOB:\tNUL separated\n     *\t    If we use *csh, \"glob\" will work better than \"echo\".\n     * STYLE_PRINT:\tNL or NUL separated\n     *\t    If we use *zsh, \"print -N\" will work better than \"glob\".\n     * STYLE_VIMGLOB:\tNL separated\n     *\t    If we use *sh*, we define \"vimglob()\".\n     * STYLE_ECHO:\tspace separated.\n     *\t    A shell we don't know, stay safe and use \"echo\".\n     */\n    if (num_pat == 1 && *pat[0] == '`'\n\t    && (len = STRLEN(pat[0])) > 2\n\t    && *(pat[0] + len - 1) == '`')\n\tshell_style = STYLE_BT;\n    else if ((len = STRLEN(p_sh)) >= 3)\n    {\n\tif (STRCMP(p_sh + len - 3, \"csh\") == 0)\n\t    shell_style = STYLE_GLOB;\n\telse if (STRCMP(p_sh + len - 3, \"zsh\") == 0)\n\t    shell_style = STYLE_PRINT;\n    }\n    if (shell_style == STYLE_ECHO && strstr((char *)gettail(p_sh),\n\t\t\t\t\t\t\t\t\"sh\") != NULL)\n\tshell_style = STYLE_VIMGLOB;\n\n    /* Compute the length of the command.  We need 2 extra bytes: for the\n     * optional '&' and for the NUL.\n     * Worst case: \"unset nonomatch; print -N >\" plus two is 29 */\n    len = STRLEN(tempname) + 29;\n    if (shell_style == STYLE_VIMGLOB)\n\tlen += STRLEN(sh_vimglob_func);\n\n    for (i = 0; i < num_pat; ++i)\n    {\n\t/* Count the length of the patterns in the same way as they are put in\n\t * \"command\" below. */\n#ifdef USE_SYSTEM\n\tlen += STRLEN(pat[i]) + 3;\t/* add space and two quotes */\n#else\n\t++len;\t\t\t\t/* add space */\n\tfor (j = 0; pat[i][j] != NUL; ++j)\n\t{\n\t    if (vim_strchr(SHELL_SPECIAL, pat[i][j]) != NULL)\n\t\t++len;\t\t/* may add a backslash */\n\t    ++len;\n\t}\n#endif\n    }\n    command = alloc(len);\n    if (command == NULL)\n    {\n\t/* out of memory */\n\tvim_free(tempname);\n\treturn FAIL;\n    }\n\n    /*\n     * Build the shell command:\n     * - Set $nonomatch depending on EW_NOTFOUND (hopefully the shell\n     *\t recognizes this).\n     * - Add the shell command to print the expanded names.\n     * - Add the temp file name.\n     * - Add the file name patterns.\n     */\n    if (shell_style == STYLE_BT)\n    {\n\t/* change `command; command& ` to (command; command ) */\n\tSTRCPY(command, \"(\");\n\tSTRCAT(command, pat[0] + 1);\t\t/* exclude first backtick */\n\tp = command + STRLEN(command) - 1;\n\t*p-- = ')';\t\t\t\t/* remove last backtick */\n\twhile (p > command && VIM_ISWHITE(*p))\n\t    --p;\n\tif (*p == '&')\t\t\t\t/* remove trailing '&' */\n\t{\n\t    ampersent = TRUE;\n\t    *p = ' ';\n\t}\n\tSTRCAT(command, \">\");\n    }\n    else\n    {\n\tif (flags & EW_NOTFOUND)\n\t    STRCPY(command, \"set nonomatch; \");\n\telse\n\t    STRCPY(command, \"unset nonomatch; \");\n\tif (shell_style == STYLE_GLOB)\n\t    STRCAT(command, \"glob >\");\n\telse if (shell_style == STYLE_PRINT)\n\t    STRCAT(command, \"print -N >\");\n\telse if (shell_style == STYLE_VIMGLOB)\n\t    STRCAT(command, sh_vimglob_func);\n\telse\n\t    STRCAT(command, \"echo >\");\n    }\n\n    STRCAT(command, tempname);\n\n    if (shell_style != STYLE_BT)\n\tfor (i = 0; i < num_pat; ++i)\n\t{\n\t    /* When using system() always add extra quotes, because the shell\n\t     * is started twice.  Otherwise put a backslash before special\n\t     * characters, except inside ``. */\n#ifdef USE_SYSTEM\n\t    STRCAT(command, \" \\\"\");\n\t    STRCAT(command, pat[i]);\n\t    STRCAT(command, \"\\\"\");\n#else\n\t    int intick = FALSE;\n\n\t    p = command + STRLEN(command);\n\t    *p++ = ' ';\n\t    for (j = 0; pat[i][j] != NUL; ++j)\n\t    {\n\t\tif (pat[i][j] == '`')\n\t\t    intick = !intick;\n\t\telse if (pat[i][j] == '\\\\' && pat[i][j + 1] != NUL)\n\t\t{\n\t\t    /* Remove a backslash, take char literally.  But keep\n\t\t     * backslash inside backticks, before a special character\n\t\t     * and before a backtick. */\n\t\t    if (intick\n\t\t\t  || vim_strchr(SHELL_SPECIAL, pat[i][j + 1]) != NULL\n\t\t\t  || pat[i][j + 1] == '`')\n\t\t\t*p++ = '\\\\';\n\t\t    ++j;\n\t\t}\n\t\telse if (!intick\n\t\t\t && ((flags & EW_KEEPDOLLAR) == 0 || pat[i][j] != '$')\n\t\t\t      && vim_strchr(SHELL_SPECIAL, pat[i][j]) != NULL)\n\t\t    /* Put a backslash before a special character, but not\n\t\t     * when inside ``. And not for $var when EW_KEEPDOLLAR is\n\t\t     * set. */\n\t\t    *p++ = '\\\\';\n\n\t\t/* Copy one character. */\n\t\t*p++ = pat[i][j];\n\t    }\n\t    *p = NUL;\n#endif\n\t}\n    if (flags & EW_SILENT)\n\tshow_shell_mess = FALSE;\n    if (ampersent)\n\tSTRCAT(command, \"&\");\t\t/* put the '&' after the redirection */\n\n    /*\n     * Using zsh -G: If a pattern has no matches, it is just deleted from\n     * the argument list, otherwise zsh gives an error message and doesn't\n     * expand any other pattern.\n     */\n    if (shell_style == STYLE_PRINT)\n\textra_shell_arg = (char_u *)\"-G\";   /* Use zsh NULL_GLOB option */\n\n    /*\n     * If we use -f then shell variables set in .cshrc won't get expanded.\n     * vi can do it, so we will too, but it is only necessary if there is a \"$\"\n     * in one of the patterns, otherwise we can still use the fast option.\n     */\n    else if (shell_style == STYLE_GLOB && !have_dollars(num_pat, pat))\n\textra_shell_arg = (char_u *)\"-f\";\t/* Use csh fast option */\n\n    /*\n     * execute the shell command\n     */\n    i = call_shell(command, SHELL_EXPAND | SHELL_SILENT);\n\n    /* When running in the background, give it some time to create the temp\n     * file, but don't wait for it to finish. */\n    if (ampersent)\n\tmch_delay(10L, TRUE);\n\n    extra_shell_arg = NULL;\t\t/* cleanup */\n    show_shell_mess = TRUE;\n    vim_free(command);\n\n    if (i != 0)\t\t\t\t/* mch_call_shell() failed */\n    {\n\tmch_remove(tempname);\n\tvim_free(tempname);\n\t/*\n\t * With interactive completion, the error message is not printed.\n\t * However with USE_SYSTEM, I don't know how to turn off error messages\n\t * from the shell, so screen may still get messed up -- webb.\n\t */\n#ifndef USE_SYSTEM\n\tif (!(flags & EW_SILENT))\n#endif\n\t{\n\t    redraw_later_clear();\t/* probably messed up screen */\n\t    msg_putchar('\\n');\t\t/* clear bottom line quickly */\n\t    cmdline_row = Rows - 1;\t/* continue on last line */\n#ifdef USE_SYSTEM\n\t    if (!(flags & EW_SILENT))\n#endif\n\t    {\n\t\tMSG(_(e_wildexpand));\n\t\tmsg_start();\t\t/* don't overwrite this message */\n\t    }\n\t}\n\t/* If a `cmd` expansion failed, don't list `cmd` as a match, even when\n\t * EW_NOTFOUND is given */\n\tif (shell_style == STYLE_BT)\n\t    return FAIL;\n\tgoto notfound;\n    }\n\n    /*\n     * read the names from the file into memory\n     */\n    fd = fopen((char *)tempname, READBIN);\n    if (fd == NULL)\n    {\n\t/* Something went wrong, perhaps a file name with a special char. */\n\tif (!(flags & EW_SILENT))\n\t{\n\t    MSG(_(e_wildexpand));\n\t    msg_start();\t\t/* don't overwrite this message */\n\t}\n\tvim_free(tempname);\n\tgoto notfound;\n    }\n    fseek(fd, 0L, SEEK_END);\n    len = ftell(fd);\t\t\t/* get size of temp file */\n    fseek(fd, 0L, SEEK_SET);\n    buffer = alloc(len + 1);\n    if (buffer == NULL)\n    {\n\t/* out of memory */\n\tmch_remove(tempname);\n\tvim_free(tempname);\n\tfclose(fd);\n\treturn FAIL;\n    }\n    i = fread((char *)buffer, 1, len, fd);\n    fclose(fd);\n    mch_remove(tempname);\n    if (i != (int)len)\n    {\n\t/* unexpected read error */\n\tEMSG2(_(e_notread), tempname);\n\tvim_free(tempname);\n\tvim_free(buffer);\n\treturn FAIL;\n    }\n    vim_free(tempname);\n\n# if defined(__CYGWIN__) || defined(__CYGWIN32__)\n    /* Translate <CR><NL> into <NL>.  Caution, buffer may contain NUL. */\n    p = buffer;\n    for (i = 0; i < (int)len; ++i)\n\tif (!(buffer[i] == CAR && buffer[i + 1] == NL))\n\t    *p++ = buffer[i];\n    len = p - buffer;\n# endif\n\n\n    /* file names are separated with Space */\n    if (shell_style == STYLE_ECHO)\n    {\n\tbuffer[len] = '\\n';\t\t/* make sure the buffer ends in NL */\n\tp = buffer;\n\tfor (i = 0; *p != '\\n'; ++i)\t/* count number of entries */\n\t{\n\t    while (*p != ' ' && *p != '\\n')\n\t\t++p;\n\t    p = skipwhite(p);\t\t/* skip to next entry */\n\t}\n    }\n    /* file names are separated with NL */\n    else if (shell_style == STYLE_BT || shell_style == STYLE_VIMGLOB)\n    {\n\tbuffer[len] = NUL;\t\t/* make sure the buffer ends in NUL */\n\tp = buffer;\n\tfor (i = 0; *p != NUL; ++i)\t/* count number of entries */\n\t{\n\t    while (*p != '\\n' && *p != NUL)\n\t\t++p;\n\t    if (*p != NUL)\n\t\t++p;\n\t    p = skipwhite(p);\t\t/* skip leading white space */\n\t}\n    }\n    /* file names are separated with NUL */\n    else\n    {\n\t/*\n\t * Some versions of zsh use spaces instead of NULs to separate\n\t * results.  Only do this when there is no NUL before the end of the\n\t * buffer, otherwise we would never be able to use file names with\n\t * embedded spaces when zsh does use NULs.\n\t * When we found a NUL once, we know zsh is OK, set did_find_nul and\n\t * don't check for spaces again.\n\t */\n\tcheck_spaces = FALSE;\n\tif (shell_style == STYLE_PRINT && !did_find_nul)\n\t{\n\t    /* If there is a NUL, set did_find_nul, else set check_spaces */\n\t    buffer[len] = NUL;\n\t    if (len && (int)STRLEN(buffer) < (int)len)\n\t\tdid_find_nul = TRUE;\n\t    else\n\t\tcheck_spaces = TRUE;\n\t}\n\n\t/*\n\t * Make sure the buffer ends with a NUL.  For STYLE_PRINT there\n\t * already is one, for STYLE_GLOB it needs to be added.\n\t */\n\tif (len && buffer[len - 1] == NUL)\n\t    --len;\n\telse\n\t    buffer[len] = NUL;\n\ti = 0;\n\tfor (p = buffer; p < buffer + len; ++p)\n\t    if (*p == NUL || (*p == ' ' && check_spaces))   /* count entry */\n\t    {\n\t\t++i;\n\t\t*p = NUL;\n\t    }\n\tif (len)\n\t    ++i;\t\t\t/* count last entry */\n    }\n    if (i == 0)\n    {\n\t/*\n\t * Can happen when using /bin/sh and typing \":e $NO_SUCH_VAR^I\".\n\t * /bin/sh will happily expand it to nothing rather than returning an\n\t * error; and hey, it's good to check anyway -- webb.\n\t */\n\tvim_free(buffer);\n\tgoto notfound;\n    }\n    *num_file = i;\n    *file = (char_u **)alloc(sizeof(char_u *) * i);\n    if (*file == NULL)\n    {\n\t/* out of memory */\n\tvim_free(buffer);\n\treturn FAIL;\n    }\n\n    /*\n     * Isolate the individual file names.\n     */\n    p = buffer;\n    for (i = 0; i < *num_file; ++i)\n    {\n\t(*file)[i] = p;\n\t/* Space or NL separates */\n\tif (shell_style == STYLE_ECHO || shell_style == STYLE_BT\n\t\t\t\t\t      || shell_style == STYLE_VIMGLOB)\n\t{\n\t    while (!(shell_style == STYLE_ECHO && *p == ' ')\n\t\t\t\t\t\t   && *p != '\\n' && *p != NUL)\n\t\t++p;\n\t    if (p == buffer + len)\t\t/* last entry */\n\t\t*p = NUL;\n\t    else\n\t    {\n\t\t*p++ = NUL;\n\t\tp = skipwhite(p);\t\t/* skip to next entry */\n\t    }\n\t}\n\telse\t\t/* NUL separates */\n\t{\n\t    while (*p && p < buffer + len)\t/* skip entry */\n\t\t++p;\n\t    ++p;\t\t\t\t/* skip NUL */\n\t}\n    }\n\n    /*\n     * Move the file names to allocated memory.\n     */\n    for (j = 0, i = 0; i < *num_file; ++i)\n    {\n\t/* Require the files to exist.\tHelps when using /bin/sh */\n\tif (!(flags & EW_NOTFOUND) && mch_getperm((*file)[i]) < 0)\n\t    continue;\n\n\t/* check if this entry should be included */\n\tdir = (mch_isdir((*file)[i]));\n\tif ((dir && !(flags & EW_DIR)) || (!dir && !(flags & EW_FILE)))\n\t    continue;\n\n\t/* Skip files that are not executable if we check for that. */\n\tif (!dir && (flags & EW_EXEC)\n\t\t    && !mch_can_exe((*file)[i], NULL, !(flags & EW_SHELLCMD)))\n\t    continue;\n\n\tp = alloc((unsigned)(STRLEN((*file)[i]) + 1 + dir));\n\tif (p)\n\t{\n\t    STRCPY(p, (*file)[i]);\n\t    if (dir)\n\t\tadd_pathsep(p);\t    /* add '/' to a directory name */\n\t    (*file)[j++] = p;\n\t}\n    }\n    vim_free(buffer);\n    *num_file = j;\n\n    if (*num_file == 0)\t    /* rejected all entries */\n    {\n\tvim_free(*file);\n\t*file = NULL;\n\tgoto notfound;\n    }\n\n    return OK;\n\nnotfound:\n    if (flags & EW_NOTFOUND)\n\treturn save_patterns(num_pat, pat, num_file, file);\n    return FAIL;\n}\n\n#endif /* VMS */\n\n    static int\nsave_patterns(\n    int\t\tnum_pat,\n    char_u\t**pat,\n    int\t\t*num_file,\n    char_u\t***file)\n{\n    int\t\ti;\n    char_u\t*s;\n\n    *file = (char_u **)alloc(num_pat * sizeof(char_u *));\n    if (*file == NULL)\n\treturn FAIL;\n    for (i = 0; i < num_pat; i++)\n    {\n\ts = vim_strsave(pat[i]);\n\tif (s != NULL)\n\t    /* Be compatible with expand_filename(): halve the number of\n\t     * backslashes. */\n\t    backslash_halve(s);\n\t(*file)[i] = s;\n    }\n    *num_file = num_pat;\n    return OK;\n}\n\n/*\n * Return TRUE if the string \"p\" contains a wildcard that mch_expandpath() can\n * expand.\n */\n    int\nmch_has_exp_wildcard(char_u *p)\n{\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t    ++p;\n\telse\n\t    if (vim_strchr((char_u *)\n#ifdef VMS\n\t\t\t\t    \"*?%\"\n#else\n\t\t\t\t    \"*?[{'\"\n#endif\n\t\t\t\t\t\t, *p) != NULL)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if the string \"p\" contains a wildcard.\n * Don't recognize '~' at the end as a wildcard.\n */\n    int\nmch_has_wildcard(char_u *p)\n{\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t    ++p;\n\telse\n\t    if (vim_strchr((char_u *)\n#ifdef VMS\n\t\t\t\t    \"*?%$\"\n#else\n\t\t\t\t    \"*?[{`'$\"\n#endif\n\t\t\t\t\t\t, *p) != NULL\n\t\t|| (*p == '~' && p[1] != NUL))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n    static int\nhave_wildcard(int num, char_u **file)\n{\n    int\t    i;\n\n    for (i = 0; i < num; i++)\n\tif (mch_has_wildcard(file[i]))\n\t    return 1;\n    return 0;\n}\n\n    static int\nhave_dollars(int num, char_u **file)\n{\n    int\t    i;\n\n    for (i = 0; i < num; i++)\n\tif (vim_strchr(file[i], '$') != NULL)\n\t    return TRUE;\n    return FALSE;\n}\n\n#if !defined(HAVE_RENAME) || defined(PROTO)\n/*\n * Scaled-down version of rename(), which is missing in Xenix.\n * This version can only move regular files and will fail if the\n * destination exists.\n */\n    int\nmch_rename(const char *src, const char *dest)\n{\n    struct stat\t    st;\n\n    if (stat(dest, &st) >= 0)\t    /* fail if destination exists */\n\treturn -1;\n    if (link(src, dest) != 0)\t    /* link file to new name */\n\treturn -1;\n    if (mch_remove(src) == 0)\t    /* delete link to old name */\n\treturn 0;\n    return -1;\n}\n#endif /* !HAVE_RENAME */\n\n#ifdef FEAT_MOUSE_GPM\n/*\n * Initializes connection with gpm (if it isn't already opened)\n * Return 1 if succeeded (or connection already opened), 0 if failed\n */\n    static int\ngpm_open(void)\n{\n    static Gpm_Connect gpm_connect; /* Must it be kept till closing ? */\n\n    if (!gpm_flag)\n    {\n\tgpm_connect.eventMask = (GPM_UP | GPM_DRAG | GPM_DOWN);\n\tgpm_connect.defaultMask = ~GPM_HARD;\n\t/* Default handling for mouse move*/\n\tgpm_connect.minMod = 0; /* Handle any modifier keys */\n\tgpm_connect.maxMod = 0xffff;\n\tif (Gpm_Open(&gpm_connect, 0) > 0)\n\t{\n\t    /* gpm library tries to handling TSTP causes\n\t     * problems. Anyways, we close connection to Gpm whenever\n\t     * we are going to suspend or starting an external process\n\t     * so we shouldn't  have problem with this\n\t     */\n# ifdef SIGTSTP\n\t    signal(SIGTSTP, restricted ? SIG_IGN : SIG_DFL);\n# endif\n\t    return 1; /* succeed */\n\t}\n\tif (gpm_fd == -2)\n\t    Gpm_Close(); /* We don't want to talk to xterm via gpm */\n\treturn 0;\n    }\n    return 1; /* already open */\n}\n\n/*\n * Closes connection to gpm\n */\n    static void\ngpm_close(void)\n{\n    if (gpm_flag && gpm_fd >= 0) /* if Open */\n\tGpm_Close();\n}\n\n/* Reads gpm event and adds special keys to input buf. Returns length of\n * generated key sequence.\n * This function is styled after gui_send_mouse_event().\n */\n    static int\nmch_gpm_process(void)\n{\n    int\t\t\tbutton;\n    static Gpm_Event\tgpm_event;\n    char_u\t\tstring[6];\n    int_u\t\tvim_modifiers;\n    int\t\t\trow,col;\n    unsigned char\tbuttons_mask;\n    unsigned char\tgpm_modifiers;\n    static unsigned char old_buttons = 0;\n\n    Gpm_GetEvent(&gpm_event);\n\n#ifdef FEAT_GUI\n    /* Don't put events in the input queue now. */\n    if (hold_gui_events)\n\treturn 0;\n#endif\n\n    row = gpm_event.y - 1;\n    col = gpm_event.x - 1;\n\n    string[0] = ESC; /* Our termcode */\n    string[1] = 'M';\n    string[2] = 'G';\n    switch (GPM_BARE_EVENTS(gpm_event.type))\n    {\n\tcase GPM_DRAG:\n\t    string[3] = MOUSE_DRAG;\n\t    break;\n\tcase GPM_DOWN:\n\t    buttons_mask = gpm_event.buttons & ~old_buttons;\n\t    old_buttons = gpm_event.buttons;\n\t    switch (buttons_mask)\n\t    {\n\t\tcase GPM_B_LEFT:\n\t\t    button = MOUSE_LEFT;\n\t\t    break;\n\t\tcase GPM_B_MIDDLE:\n\t\t    button = MOUSE_MIDDLE;\n\t\t    break;\n\t\tcase GPM_B_RIGHT:\n\t\t    button = MOUSE_RIGHT;\n\t\t    break;\n\t\tdefault:\n\t\t    return 0;\n\t\t    /*Don't know what to do. Can more than one button be\n\t\t     * reported in one event? */\n\t    }\n\t    string[3] = (char_u)(button | 0x20);\n\t    SET_NUM_MOUSE_CLICKS(string[3], gpm_event.clicks + 1);\n\t    break;\n\tcase GPM_UP:\n\t    string[3] = MOUSE_RELEASE;\n\t    old_buttons &= ~gpm_event.buttons;\n\t    break;\n\tdefault:\n\t    return 0;\n    }\n    /*This code is based on gui_x11_mouse_cb in gui_x11.c */\n    gpm_modifiers = gpm_event.modifiers;\n    vim_modifiers = 0x0;\n    /* I ignore capslock stats. Aren't we all just hate capslock mixing with\n     * Vim commands ? Besides, gpm_event.modifiers is unsigned char, and\n     * K_CAPSSHIFT is defined 8, so it probably isn't even reported\n     */\n    if (gpm_modifiers & ((1 << KG_SHIFT) | (1 << KG_SHIFTR) | (1 << KG_SHIFTL)))\n\tvim_modifiers |= MOUSE_SHIFT;\n\n    if (gpm_modifiers & ((1 << KG_CTRL) | (1 << KG_CTRLR) | (1 << KG_CTRLL)))\n\tvim_modifiers |= MOUSE_CTRL;\n    if (gpm_modifiers & ((1 << KG_ALT) | (1 << KG_ALTGR)))\n\tvim_modifiers |= MOUSE_ALT;\n    string[3] |= vim_modifiers;\n    string[4] = (char_u)(col + ' ' + 1);\n    string[5] = (char_u)(row + ' ' + 1);\n    add_to_input_buf(string, 6);\n    return 6;\n}\n#endif /* FEAT_MOUSE_GPM */\n\n#ifdef FEAT_SYSMOUSE\n/*\n * Initialize connection with sysmouse.\n * Let virtual console inform us with SIGUSR2 for pending sysmouse\n * output, any sysmouse output than will be processed via sig_sysmouse().\n * Return OK if succeeded, FAIL if failed.\n */\n    static int\nsysmouse_open(void)\n{\n    struct mouse_info   mouse;\n\n    mouse.operation = MOUSE_MODE;\n    mouse.u.mode.mode = 0;\n    mouse.u.mode.signal = SIGUSR2;\n    if (ioctl(1, CONS_MOUSECTL, &mouse) != -1)\n    {\n\tsignal(SIGUSR2, (RETSIGTYPE (*)())sig_sysmouse);\n\tmouse.operation = MOUSE_SHOW;\n\tioctl(1, CONS_MOUSECTL, &mouse);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Stop processing SIGUSR2 signals, and also make sure that\n * virtual console do not send us any sysmouse related signal.\n */\n    static void\nsysmouse_close(void)\n{\n    struct mouse_info\tmouse;\n\n    signal(SIGUSR2, restricted ? SIG_IGN : SIG_DFL);\n    mouse.operation = MOUSE_MODE;\n    mouse.u.mode.mode = 0;\n    mouse.u.mode.signal = 0;\n    ioctl(1, CONS_MOUSECTL, &mouse);\n}\n\n/*\n * Gets info from sysmouse and adds special keys to input buf.\n */\n    static RETSIGTYPE\nsig_sysmouse SIGDEFARG(sigarg)\n{\n    struct mouse_info\tmouse;\n    struct video_info\tvideo;\n    char_u\t\tstring[6];\n    int\t\t\trow, col;\n    int\t\t\tbutton;\n    int\t\t\tbuttons;\n    static int\t\toldbuttons = 0;\n\n#ifdef FEAT_GUI\n    /* Don't put events in the input queue now. */\n    if (hold_gui_events)\n\treturn;\n#endif\n\n    mouse.operation = MOUSE_GETINFO;\n    if (ioctl(1, FBIO_GETMODE, &video.vi_mode) != -1\n\t    && ioctl(1, FBIO_MODEINFO, &video) != -1\n\t    && ioctl(1, CONS_MOUSECTL, &mouse) != -1\n\t    && video.vi_cheight > 0 && video.vi_cwidth > 0)\n    {\n\trow = mouse.u.data.y / video.vi_cheight;\n\tcol = mouse.u.data.x / video.vi_cwidth;\n\tbuttons = mouse.u.data.buttons;\n\tstring[0] = ESC; /* Our termcode */\n\tstring[1] = 'M';\n\tstring[2] = 'S';\n\tif (oldbuttons == buttons && buttons != 0)\n\t{\n\t    button = MOUSE_DRAG;\n\t}\n\telse\n\t{\n\t    switch (buttons)\n\t    {\n\t\tcase 0:\n\t\t    button = MOUSE_RELEASE;\n\t\t    break;\n\t\tcase 1:\n\t\t    button = MOUSE_LEFT;\n\t\t    break;\n\t\tcase 2:\n\t\t    button = MOUSE_MIDDLE;\n\t\t    break;\n\t\tcase 4:\n\t\t    button = MOUSE_RIGHT;\n\t\t    break;\n\t\tdefault:\n\t\t    return;\n\t    }\n\t    oldbuttons = buttons;\n\t}\n\tstring[3] = (char_u)(button);\n\tstring[4] = (char_u)(col + ' ' + 1);\n\tstring[5] = (char_u)(row + ' ' + 1);\n\tadd_to_input_buf(string, 6);\n    }\n    return;\n}\n#endif /* FEAT_SYSMOUSE */\n\n#if defined(FEAT_LIBCALL) || defined(PROTO)\ntypedef char_u * (*STRPROCSTR)(char_u *);\ntypedef char_u * (*INTPROCSTR)(int);\ntypedef int (*STRPROCINT)(char_u *);\ntypedef int (*INTPROCINT)(int);\n\n/*\n * Call a DLL routine which takes either a string or int param\n * and returns an allocated string.\n */\n    int\nmch_libcall(\n    char_u\t*libname,\n    char_u\t*funcname,\n    char_u\t*argstring,\t/* NULL when using a argint */\n    int\t\targint,\n    char_u\t**string_result,/* NULL when using number_result */\n    int\t\t*number_result)\n{\n# if defined(USE_DLOPEN)\n    void\t*hinstLib;\n    char\t*dlerr = NULL;\n# else\n    shl_t\thinstLib;\n# endif\n    STRPROCSTR\tProcAdd;\n    INTPROCSTR\tProcAddI;\n    char_u\t*retval_str = NULL;\n    int\t\tretval_int = 0;\n    int\t\tsuccess = FALSE;\n\n    /*\n     * Get a handle to the DLL module.\n     */\n# if defined(USE_DLOPEN)\n    /* First clear any error, it's not cleared by the dlopen() call. */\n    (void)dlerror();\n\n    hinstLib = dlopen((char *)libname, RTLD_LAZY\n#  ifdef RTLD_LOCAL\n\t    | RTLD_LOCAL\n#  endif\n\t    );\n    if (hinstLib == NULL)\n    {\n\t/* \"dlerr\" must be used before dlclose() */\n\tdlerr = (char *)dlerror();\n\tif (dlerr != NULL)\n\t    EMSG2(_(\"dlerror = \\\"%s\\\"\"), dlerr);\n    }\n# else\n    hinstLib = shl_load((const char*)libname, BIND_IMMEDIATE|BIND_VERBOSE, 0L);\n# endif\n\n    /* If the handle is valid, try to get the function address. */\n    if (hinstLib != NULL)\n    {\n# ifdef HAVE_SETJMP_H\n\t/*\n\t * Catch a crash when calling the library function.  For example when\n\t * using a number where a string pointer is expected.\n\t */\n\tmch_startjmp();\n\tif (SETJMP(lc_jump_env) != 0)\n\t{\n\t    success = FALSE;\n#  if defined(USE_DLOPEN)\n\t    dlerr = NULL;\n#  endif\n\t    mch_didjmp();\n\t}\n\telse\n# endif\n\t{\n\t    retval_str = NULL;\n\t    retval_int = 0;\n\n\t    if (argstring != NULL)\n\t    {\n# if defined(USE_DLOPEN)\n\t\t*(void **)(&ProcAdd) = dlsym(hinstLib, (const char *)funcname);\n\t\tdlerr = (char *)dlerror();\n# else\n\t\tif (shl_findsym(&hinstLib, (const char *)funcname,\n\t\t\t\t\tTYPE_PROCEDURE, (void *)&ProcAdd) < 0)\n\t\t    ProcAdd = NULL;\n# endif\n\t\tif ((success = (ProcAdd != NULL\n# if defined(USE_DLOPEN)\n\t\t\t    && dlerr == NULL\n# endif\n\t\t\t    )))\n\t\t{\n\t\t    if (string_result == NULL)\n\t\t\tretval_int = ((STRPROCINT)ProcAdd)(argstring);\n\t\t    else\n\t\t\tretval_str = (ProcAdd)(argstring);\n\t\t}\n\t    }\n\t    else\n\t    {\n# if defined(USE_DLOPEN)\n\t\t*(void **)(&ProcAddI) = dlsym(hinstLib, (const char *)funcname);\n\t\tdlerr = (char *)dlerror();\n# else\n\t\tif (shl_findsym(&hinstLib, (const char *)funcname,\n\t\t\t\t       TYPE_PROCEDURE, (void *)&ProcAddI) < 0)\n\t\t    ProcAddI = NULL;\n# endif\n\t\tif ((success = (ProcAddI != NULL\n# if defined(USE_DLOPEN)\n\t\t\t    && dlerr == NULL\n# endif\n\t\t\t    )))\n\t\t{\n\t\t    if (string_result == NULL)\n\t\t\tretval_int = ((INTPROCINT)ProcAddI)(argint);\n\t\t    else\n\t\t\tretval_str = (ProcAddI)(argint);\n\t\t}\n\t    }\n\n\t    /* Save the string before we free the library. */\n\t    /* Assume that a \"1\" or \"-1\" result is an illegal pointer. */\n\t    if (string_result == NULL)\n\t\t*number_result = retval_int;\n\t    else if (retval_str != NULL\n\t\t    && retval_str != (char_u *)1\n\t\t    && retval_str != (char_u *)-1)\n\t\t*string_result = vim_strsave(retval_str);\n\t}\n\n# ifdef HAVE_SETJMP_H\n\tmch_endjmp();\n#  ifdef SIGHASARG\n\tif (lc_signal != 0)\n\t{\n\t    int i;\n\n\t    /* try to find the name of this signal */\n\t    for (i = 0; signal_info[i].sig != -1; i++)\n\t\tif (lc_signal == signal_info[i].sig)\n\t\t    break;\n\t    EMSG2(\"E368: got SIG%s in libcall()\", signal_info[i].name);\n\t}\n#  endif\n# endif\n\n# if defined(USE_DLOPEN)\n\t/* \"dlerr\" must be used before dlclose() */\n\tif (dlerr != NULL)\n\t    EMSG2(_(\"dlerror = \\\"%s\\\"\"), dlerr);\n\n\t/* Free the DLL module. */\n\t(void)dlclose(hinstLib);\n# else\n\t(void)shl_unload(hinstLib);\n# endif\n    }\n\n    if (!success)\n    {\n\tEMSG2(_(e_libcall), funcname);\n\treturn FAIL;\n    }\n\n    return OK;\n}\n#endif\n\n#if (defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)) || defined(PROTO)\nstatic int\txterm_trace = -1;\t/* default: disabled */\nstatic int\txterm_button;\n\n/*\n * Setup a dummy window for X selections in a terminal.\n */\n    void\nsetup_term_clip(void)\n{\n    int\t\tz = 0;\n    char\t*strp = \"\";\n    Widget\tAppShell;\n\n    if (!x_connect_to_server())\n\treturn;\n\n    open_app_context();\n    if (app_context != NULL && xterm_Shell == (Widget)0)\n    {\n\tint (*oldhandler)();\n#if defined(HAVE_SETJMP_H)\n\tint (*oldIOhandler)();\n#endif\n# ifdef ELAPSED_FUNC\n\tELAPSED_TYPE  start_tv;\n\n\tif (p_verbose > 0)\n\t    ELAPSED_INIT(start_tv);\n# endif\n\n\t/* Ignore X errors while opening the display */\n\toldhandler = XSetErrorHandler(x_error_check);\n\n#if defined(HAVE_SETJMP_H)\n\t/* Ignore X IO errors while opening the display */\n\toldIOhandler = XSetIOErrorHandler(x_IOerror_check);\n\tmch_startjmp();\n\tif (SETJMP(lc_jump_env) != 0)\n\t{\n\t    mch_didjmp();\n\t    xterm_dpy = NULL;\n\t}\n\telse\n#endif\n\t{\n\t    xterm_dpy = XtOpenDisplay(app_context, xterm_display,\n\t\t    \"vim_xterm\", \"Vim_xterm\", NULL, 0, &z, &strp);\n#if defined(HAVE_SETJMP_H)\n\t    mch_endjmp();\n#endif\n\t}\n\n#if defined(HAVE_SETJMP_H)\n\t/* Now handle X IO errors normally. */\n\t(void)XSetIOErrorHandler(oldIOhandler);\n#endif\n\t/* Now handle X errors normally. */\n\t(void)XSetErrorHandler(oldhandler);\n\n\tif (xterm_dpy == NULL)\n\t{\n\t    if (p_verbose > 0)\n\t\tverb_msg((char_u *)_(\"Opening the X display failed\"));\n\t    return;\n\t}\n\n\t/* Catch terminating error of the X server connection. */\n\t(void)XSetIOErrorHandler(x_IOerror_handler);\n\n# ifdef ELAPSED_FUNC\n\tif (p_verbose > 0)\n\t{\n\t    verbose_enter();\n\t    xopen_message(ELAPSED_FUNC(start_tv));\n\t    verbose_leave();\n\t}\n# endif\n\n\t/* Create a Shell to make converters work. */\n\tAppShell = XtVaAppCreateShell(\"vim_xterm\", \"Vim_xterm\",\n\t\tapplicationShellWidgetClass, xterm_dpy,\n\t\tNULL);\n\tif (AppShell == (Widget)0)\n\t    return;\n\txterm_Shell = XtVaCreatePopupShell(\"VIM\",\n\t\ttopLevelShellWidgetClass, AppShell,\n\t\tXtNmappedWhenManaged, 0,\n\t\tXtNwidth, 1,\n\t\tXtNheight, 1,\n\t\tNULL);\n\tif (xterm_Shell == (Widget)0)\n\t    return;\n\n\tx11_setup_atoms(xterm_dpy);\n\tx11_setup_selection(xterm_Shell);\n\tif (x11_display == NULL)\n\t    x11_display = xterm_dpy;\n\n\tXtRealizeWidget(xterm_Shell);\n\tXSync(xterm_dpy, False);\n\txterm_update();\n    }\n    if (xterm_Shell != (Widget)0)\n    {\n\tclip_init(TRUE);\n\tif (x11_window == 0 && (strp = getenv(\"WINDOWID\")) != NULL)\n\t    x11_window = (Window)atol(strp);\n\t/* Check if $WINDOWID is valid. */\n\tif (test_x11_window(xterm_dpy) == FAIL)\n\t    x11_window = 0;\n\tif (x11_window != 0)\n\t    xterm_trace = 0;\n    }\n}\n\n    void\nstart_xterm_trace(int button)\n{\n    if (x11_window == 0 || xterm_trace < 0 || xterm_Shell == (Widget)0)\n\treturn;\n    xterm_trace = 1;\n    xterm_button = button;\n    do_xterm_trace();\n}\n\n\n    void\nstop_xterm_trace(void)\n{\n    if (xterm_trace < 0)\n\treturn;\n    xterm_trace = 0;\n}\n\n/*\n * Query the xterm pointer and generate mouse termcodes if necessary\n * return TRUE if dragging is active, else FALSE\n */\n    static int\ndo_xterm_trace(void)\n{\n    Window\t\troot, child;\n    int\t\t\troot_x, root_y;\n    int\t\t\twin_x, win_y;\n    int\t\t\trow, col;\n    int_u\t\tmask_return;\n    char_u\t\tbuf[50];\n    char_u\t\t*strp;\n    long\t\tgot_hints;\n    static char_u\t*mouse_code;\n    static char_u\tmouse_name[2] = {KS_MOUSE, KE_FILLER};\n    static int\t\tprev_row = 0, prev_col = 0;\n    static XSizeHints\txterm_hints;\n\n    if (xterm_trace <= 0)\n\treturn FALSE;\n\n    if (xterm_trace == 1)\n    {\n\t/* Get the hints just before tracking starts.  The font size might\n\t * have changed recently. */\n\tif (!XGetWMNormalHints(xterm_dpy, x11_window, &xterm_hints, &got_hints)\n\t\t|| !(got_hints & PResizeInc)\n\t\t|| xterm_hints.width_inc <= 1\n\t\t|| xterm_hints.height_inc <= 1)\n\t{\n\t    xterm_trace = -1;  /* Not enough data -- disable tracing */\n\t    return FALSE;\n\t}\n\n\t/* Rely on the same mouse code for the duration of this */\n\tmouse_code = find_termcode(mouse_name);\n\tprev_row = mouse_row;\n\tprev_col = mouse_col;\n\txterm_trace = 2;\n\n\t/* Find the offset of the chars, there might be a scrollbar on the\n\t * left of the window and/or a menu on the top (eterm etc.) */\n\tXQueryPointer(xterm_dpy, x11_window, &root, &child, &root_x, &root_y,\n\t\t      &win_x, &win_y, &mask_return);\n\txterm_hints.y = win_y - (xterm_hints.height_inc * mouse_row)\n\t\t\t      - (xterm_hints.height_inc / 2);\n\tif (xterm_hints.y <= xterm_hints.height_inc / 2)\n\t    xterm_hints.y = 2;\n\txterm_hints.x = win_x - (xterm_hints.width_inc * mouse_col)\n\t\t\t      - (xterm_hints.width_inc / 2);\n\tif (xterm_hints.x <= xterm_hints.width_inc / 2)\n\t    xterm_hints.x = 2;\n\treturn TRUE;\n    }\n    if (mouse_code == NULL || STRLEN(mouse_code) > 45)\n    {\n\txterm_trace = 0;\n\treturn FALSE;\n    }\n\n    XQueryPointer(xterm_dpy, x11_window, &root, &child, &root_x, &root_y,\n\t\t  &win_x, &win_y, &mask_return);\n\n    row = check_row((win_y - xterm_hints.y) / xterm_hints.height_inc);\n    col = check_col((win_x - xterm_hints.x) / xterm_hints.width_inc);\n    if (row == prev_row && col == prev_col)\n\treturn TRUE;\n\n    STRCPY(buf, mouse_code);\n    strp = buf + STRLEN(buf);\n    *strp++ = (xterm_button | MOUSE_DRAG) & ~0x20;\n    *strp++ = (char_u)(col + ' ' + 1);\n    *strp++ = (char_u)(row + ' ' + 1);\n    *strp = 0;\n    add_to_input_buf(buf, STRLEN(buf));\n\n    prev_row = row;\n    prev_col = col;\n    return TRUE;\n}\n\n# if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Destroy the display, window and app_context.  Required for GTK.\n */\n    void\nclear_xterm_clip(void)\n{\n    if (xterm_Shell != (Widget)0)\n    {\n\tXtDestroyWidget(xterm_Shell);\n\txterm_Shell = (Widget)0;\n    }\n    if (xterm_dpy != NULL)\n    {\n#  if 0\n\t/* Lesstif and Solaris crash here, lose some memory */\n\tXtCloseDisplay(xterm_dpy);\n#  endif\n\tif (x11_display == xterm_dpy)\n\t    x11_display = NULL;\n\txterm_dpy = NULL;\n    }\n#  if 0\n    if (app_context != (XtAppContext)NULL)\n    {\n\t/* Lesstif and Solaris crash here, lose some memory */\n\tXtDestroyApplicationContext(app_context);\n\tapp_context = (XtAppContext)NULL;\n    }\n#  endif\n}\n# endif\n\n/*\n * Catch up with GUI or X events.\n */\n    static void\nclip_update(void)\n{\n# ifdef FEAT_GUI\n    if (gui.in_use)\n\tgui_mch_update();\n    else\n# endif\n    if (xterm_Shell != (Widget)0)\n\txterm_update();\n}\n\n/*\n * Catch up with any queued X events.  This may put keyboard input into the\n * input buffer, call resize call-backs, trigger timers etc.  If there is\n * nothing in the X event queue (& no timers pending), then we return\n * immediately.\n */\n    static void\nxterm_update(void)\n{\n    XEvent event;\n\n    for (;;)\n    {\n\tXtInputMask mask = XtAppPending(app_context);\n\n\tif (mask == 0 || vim_is_input_buf_full())\n\t    break;\n\n\tif (mask & XtIMXEvent)\n\t{\n\t    /* There is an event to process. */\n\t    XtAppNextEvent(app_context, &event);\n#ifdef FEAT_CLIENTSERVER\n\t    {\n\t\tXPropertyEvent *e = (XPropertyEvent *)&event;\n\n\t\tif (e->type == PropertyNotify && e->window == commWindow\n\t\t   && e->atom == commProperty && e->state == PropertyNewValue)\n\t\t    serverEventProc(xterm_dpy, &event, 0);\n\t    }\n#endif\n\t    XtDispatchEvent(&event);\n\t}\n\telse\n\t{\n\t    /* There is something else than an event to process. */\n\t    XtAppProcessEvent(app_context, mask);\n\t}\n    }\n}\n\n    int\nclip_xterm_own_selection(VimClipboard *cbd)\n{\n    if (xterm_Shell != (Widget)0)\n\treturn clip_x11_own_selection(xterm_Shell, cbd);\n    return FAIL;\n}\n\n    void\nclip_xterm_lose_selection(VimClipboard *cbd)\n{\n    if (xterm_Shell != (Widget)0)\n\tclip_x11_lose_selection(xterm_Shell, cbd);\n}\n\n    void\nclip_xterm_request_selection(VimClipboard *cbd)\n{\n    if (xterm_Shell != (Widget)0)\n\tclip_x11_request_selection(xterm_Shell, xterm_dpy, cbd);\n}\n\n    void\nclip_xterm_set_selection(VimClipboard *cbd)\n{\n    clip_x11_set_selection(cbd);\n}\n#endif\n\n\n#if defined(USE_XSMP) || defined(PROTO)\n/*\n * Code for X Session Management Protocol.\n */\nstatic void xsmp_handle_save_yourself(SmcConn smc_conn, SmPointer client_data, int save_type, Bool shutdown, int interact_style, Bool fast);\nstatic void xsmp_die(SmcConn smc_conn, SmPointer client_data);\nstatic void xsmp_save_complete(SmcConn smc_conn, SmPointer client_data);\nstatic void xsmp_shutdown_cancelled(SmcConn smc_conn, SmPointer\tclient_data);\nstatic void xsmp_ice_connection(IceConn iceConn, IcePointer clientData, Bool opening, IcePointer *watchData);\n\n\n# if defined(FEAT_GUI) && defined(USE_XSMP_INTERACT)\nstatic void xsmp_handle_interaction(SmcConn smc_conn, SmPointer client_data);\n\n/*\n * This is our chance to ask the user if they want to save,\n * or abort the logout\n */\n    static void\nxsmp_handle_interaction(SmcConn smc_conn, SmPointer client_data UNUSED)\n{\n    cmdmod_T\tsave_cmdmod;\n    int\t\tcancel_shutdown = False;\n\n    save_cmdmod = cmdmod;\n    cmdmod.confirm = TRUE;\n    if (check_changed_any(FALSE, FALSE))\n\t/* Mustn't logout */\n\tcancel_shutdown = True;\n    cmdmod = save_cmdmod;\n    setcursor();\t\t/* position cursor */\n    out_flush();\n\n    /* Done interaction */\n    SmcInteractDone(smc_conn, cancel_shutdown);\n\n    /* Finish off\n     * Only end save-yourself here if we're not cancelling shutdown;\n     * we'll get a cancelled callback later in which we'll end it.\n     * Hopefully get around glitchy SMs (like GNOME-1)\n     */\n    if (!cancel_shutdown)\n    {\n\txsmp.save_yourself = False;\n\tSmcSaveYourselfDone(smc_conn, True);\n    }\n}\n# endif\n\n/*\n * Callback that starts save-yourself.\n */\n    static void\nxsmp_handle_save_yourself(\n    SmcConn\tsmc_conn,\n    SmPointer\tclient_data UNUSED,\n    int\t\tsave_type UNUSED,\n    Bool\tshutdown,\n    int\t\tinteract_style UNUSED,\n    Bool\tfast UNUSED)\n{\n    /* Handle already being in saveyourself */\n    if (xsmp.save_yourself)\n\tSmcSaveYourselfDone(smc_conn, True);\n    xsmp.save_yourself = True;\n    xsmp.shutdown = shutdown;\n\n    /* First up, preserve all files */\n    out_flush();\n    ml_sync_all(FALSE, FALSE);\t/* preserve all swap files */\n\n    if (p_verbose > 0)\n\tverb_msg((char_u *)_(\"XSMP handling save-yourself request\"));\n\n# if defined(FEAT_GUI) && defined(USE_XSMP_INTERACT)\n    /* Now see if we can ask about unsaved files */\n    if (shutdown && !fast && gui.in_use)\n\t/* Need to interact with user, but need SM's permission */\n\tSmcInteractRequest(smc_conn, SmDialogError,\n\t\t\t\t\txsmp_handle_interaction, client_data);\n    else\n# endif\n    {\n\t/* Can stop the cycle here */\n\tSmcSaveYourselfDone(smc_conn, True);\n\txsmp.save_yourself = False;\n    }\n}\n\n\n/*\n * Callback to warn us of imminent death.\n */\n    static void\nxsmp_die(SmcConn smc_conn UNUSED, SmPointer client_data UNUSED)\n{\n    xsmp_close();\n\n    /* quit quickly leaving swapfiles for modified buffers behind */\n    getout_preserve_modified(0);\n}\n\n\n/*\n * Callback to tell us that save-yourself has completed.\n */\n    static void\nxsmp_save_complete(\n    SmcConn\tsmc_conn UNUSED,\n    SmPointer\tclient_data UNUSED)\n{\n    xsmp.save_yourself = False;\n}\n\n\n/*\n * Callback to tell us that an instigated shutdown was cancelled\n * (maybe even by us)\n */\n    static void\nxsmp_shutdown_cancelled(\n    SmcConn\tsmc_conn,\n    SmPointer\tclient_data UNUSED)\n{\n    if (xsmp.save_yourself)\n\tSmcSaveYourselfDone(smc_conn, True);\n    xsmp.save_yourself = False;\n    xsmp.shutdown = False;\n}\n\n\n/*\n * Callback to tell us that a new ICE connection has been established.\n */\n    static void\nxsmp_ice_connection(\n    IceConn\ticeConn,\n    IcePointer\tclientData UNUSED,\n    Bool\topening,\n    IcePointer\t*watchData UNUSED)\n{\n    /* Intercept creation of ICE connection fd */\n    if (opening)\n    {\n\txsmp_icefd = IceConnectionNumber(iceConn);\n\tIceRemoveConnectionWatch(xsmp_ice_connection, NULL);\n    }\n}\n\n\n/* Handle any ICE processing that's required; return FAIL if SM lost */\n    int\nxsmp_handle_requests(void)\n{\n    Bool rep;\n\n    if (IceProcessMessages(xsmp.iceconn, NULL, &rep)\n\t\t\t\t\t\t == IceProcessMessagesIOError)\n    {\n\t/* Lost ICE */\n\tif (p_verbose > 0)\n\t    verb_msg((char_u *)_(\"XSMP lost ICE connection\"));\n\txsmp_close();\n\treturn FAIL;\n    }\n    else\n\treturn OK;\n}\n\nstatic int dummy;\n\n/* Set up X Session Management Protocol */\n    void\nxsmp_init(void)\n{\n    char\t\terrorstring[80];\n    SmcCallbacks\tsmcallbacks;\n#if 0\n    SmPropValue\t\tsmname;\n    SmProp\t\tsmnameprop;\n    SmProp\t\t*smprops[1];\n#endif\n\n    if (p_verbose > 0)\n\tverb_msg((char_u *)_(\"XSMP opening connection\"));\n\n    xsmp.save_yourself = xsmp.shutdown = False;\n\n    /* Set up SM callbacks - must have all, even if they're not used */\n    smcallbacks.save_yourself.callback = xsmp_handle_save_yourself;\n    smcallbacks.save_yourself.client_data = NULL;\n    smcallbacks.die.callback = xsmp_die;\n    smcallbacks.die.client_data = NULL;\n    smcallbacks.save_complete.callback = xsmp_save_complete;\n    smcallbacks.save_complete.client_data = NULL;\n    smcallbacks.shutdown_cancelled.callback = xsmp_shutdown_cancelled;\n    smcallbacks.shutdown_cancelled.client_data = NULL;\n\n    /* Set up a watch on ICE connection creations.  The \"dummy\" argument is\n     * apparently required for FreeBSD (we get a BUS error when using NULL). */\n    if (IceAddConnectionWatch(xsmp_ice_connection, &dummy) == 0)\n    {\n\tif (p_verbose > 0)\n\t    verb_msg((char_u *)_(\"XSMP ICE connection watch failed\"));\n\treturn;\n    }\n\n    /* Create an SM connection */\n    xsmp.smcconn = SmcOpenConnection(\n\t    NULL,\n\t    NULL,\n\t    SmProtoMajor,\n\t    SmProtoMinor,\n\t    SmcSaveYourselfProcMask | SmcDieProcMask\n\t\t     | SmcSaveCompleteProcMask | SmcShutdownCancelledProcMask,\n\t    &smcallbacks,\n\t    NULL,\n\t    &xsmp.clientid,\n\t    sizeof(errorstring),\n\t    errorstring);\n    if (xsmp.smcconn == NULL)\n    {\n\tchar errorreport[132];\n\n\tif (p_verbose > 0)\n\t{\n\t    vim_snprintf(errorreport, sizeof(errorreport),\n\t\t\t _(\"XSMP SmcOpenConnection failed: %s\"), errorstring);\n\t    verb_msg((char_u *)errorreport);\n\t}\n\treturn;\n    }\n    xsmp.iceconn = SmcGetIceConnection(xsmp.smcconn);\n\n#if 0\n    /* ID ourselves */\n    smname.value = \"vim\";\n    smname.length = 3;\n    smnameprop.name = \"SmProgram\";\n    smnameprop.type = \"SmARRAY8\";\n    smnameprop.num_vals = 1;\n    smnameprop.vals = &smname;\n\n    smprops[0] = &smnameprop;\n    SmcSetProperties(xsmp.smcconn, 1, smprops);\n#endif\n}\n\n\n/* Shut down XSMP comms. */\n    void\nxsmp_close(void)\n{\n    if (xsmp_icefd != -1)\n    {\n\tSmcCloseConnection(xsmp.smcconn, 0, NULL);\n\tif (xsmp.clientid != NULL)\n\t    free(xsmp.clientid);\n\txsmp.clientid = NULL;\n\txsmp_icefd = -1;\n    }\n}\n#endif /* USE_XSMP */\n\n\n#ifdef EBCDIC\n/* Translate character to its CTRL- value */\nchar CtrlTable[] =\n{\n/* 00 - 5E */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n/* ^ */ 0x1E,\n/* - */ 0x1F,\n/* 61 - 6C */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n/* _ */ 0x1F,\n/* 6E - 80 */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n/* a */ 0x01,\n/* b */ 0x02,\n/* c */ 0x03,\n/* d */ 0x37,\n/* e */ 0x2D,\n/* f */ 0x2E,\n/* g */ 0x2F,\n/* h */ 0x16,\n/* i */ 0x05,\n/* 8A - 90 */\n\t0, 0, 0, 0, 0, 0, 0,\n/* j */ 0x15,\n/* k */ 0x0B,\n/* l */ 0x0C,\n/* m */ 0x0D,\n/* n */ 0x0E,\n/* o */ 0x0F,\n/* p */ 0x10,\n/* q */ 0x11,\n/* r */ 0x12,\n/* 9A - A1 */\n\t0, 0, 0, 0, 0, 0, 0, 0,\n/* s */ 0x13,\n/* t */ 0x3C,\n/* u */ 0x3D,\n/* v */ 0x32,\n/* w */ 0x26,\n/* x */ 0x18,\n/* y */ 0x19,\n/* z */ 0x3F,\n/* AA - AC */\n\t0, 0, 0,\n/* [ */ 0x27,\n/* AE - BC */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n/* ] */ 0x1D,\n/* BE - C0 */ 0, 0, 0,\n/* A */ 0x01,\n/* B */ 0x02,\n/* C */ 0x03,\n/* D */ 0x37,\n/* E */ 0x2D,\n/* F */ 0x2E,\n/* G */ 0x2F,\n/* H */ 0x16,\n/* I */ 0x05,\n/* CA - D0 */ 0, 0, 0, 0, 0, 0, 0,\n/* J */ 0x15,\n/* K */ 0x0B,\n/* L */ 0x0C,\n/* M */ 0x0D,\n/* N */ 0x0E,\n/* O */ 0x0F,\n/* P */ 0x10,\n/* Q */ 0x11,\n/* R */ 0x12,\n/* DA - DF */ 0, 0, 0, 0, 0, 0,\n/* \\ */ 0x1C,\n/* E1 */ 0,\n/* S */ 0x13,\n/* T */ 0x3C,\n/* U */ 0x3D,\n/* V */ 0x32,\n/* W */ 0x26,\n/* X */ 0x18,\n/* Y */ 0x19,\n/* Z */ 0x3F,\n/* EA - FF*/ 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nchar MetaCharTable[]=\n{/*   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F */\n      0,  0,  0,  0,'\\\\', 0,'F',  0,'W','M','N',  0,  0,  0,  0,  0,\n      0,  0,  0,  0,']',  0,  0,'G',  0,  0,'R','O',  0,  0,  0,  0,\n    '@','A','B','C','D','E',  0,  0,'H','I','J','K','L',  0,  0,  0,\n    'P','Q',  0,'S','T','U','V',  0,'X','Y','Z','[',  0,  0,'^',  0\n};\n\n\n/* TODO: Use characters NOT numbers!!! */\nchar CtrlCharTable[]=\n{/*   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F */\n    124,193,194,195,  0,201,  0,  0,  0,  0,  0,210,211,212,213,214,\n    215,216,217,226,  0,209,200,  0,231,232,  0,  0,224,189, 95,109,\n      0,  0,  0,  0,  0,  0,230,173,  0,  0,  0,  0,  0,197,198,199,\n      0,  0,229,  0,  0,  0,  0,196,  0,  0,  0,  0,227,228,  0,233,\n};\n\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/config.h.in": "/*\n * config.h.in.  Originally generated automatically from configure.ac by\n * autoheader and manually changed after that.\n */\n\n/* Define if we have EBCDIC code */\n#undef EBCDIC\n\n/* Define unless no X support found */\n#undef HAVE_X11\n\n/* Define when terminfo support found */\n#undef TERMINFO\n\n/* Define when termcap.h contains ospeed */\n#undef HAVE_OSPEED\n\n/* Define when ospeed can be extern */\n#undef OSPEED_EXTERN\n\n/* Define when termcap.h contains UP, BC and PC */\n#undef HAVE_UP_BC_PC\n\n/* Define when UP, BC and PC can be extern */\n#undef UP_BC_PC_EXTERN\n\n/* Define when termcap.h defines outfuntype */\n#undef HAVE_OUTFUNTYPE\n\n/* Define when __DATE__ \" \" __TIME__ can be used */\n#undef HAVE_DATE_TIME\n\n/* Define when __attribute__((unused)) can be used */\n#undef HAVE_ATTRIBUTE_UNUSED\n\n/* defined always when using configure */\n#undef UNIX\n\n/* Defined to the size of an int */\n#undef VIM_SIZEOF_INT\n\n/* Defined to the size of a long */\n#undef VIM_SIZEOF_LONG\n\n/* Defined to the size of off_t */\n#undef SIZEOF_OFF_T\n\n/* Defined to the size of time_t */\n#undef SIZEOF_TIME_T\n\n/* Define when wchar_t is only 2 bytes. */\n#undef SMALL_WCHAR_T\n\n/*\n * If we cannot trust one of the following from the libraries, we use our\n * own safe but probably slower vim_memmove().\n */\n#undef USEBCOPY\n#undef USEMEMMOVE\n#undef USEMEMCPY\n\n/* Define when \"man -s 2\" is to be used */\n#undef USEMAN_S\n\n/* Define to empty if the keyword does not work.  */\n#undef const\n\n/* Define to empty if the keyword does not work.  */\n#undef volatile\n\n/* Define to `int' if <sys/types.h> doesn't define.  */\n#undef mode_t\n\n/* Define to `long' if <sys/types.h> doesn't define.  */\n#undef off_t\n\n/* Define to `long' if <sys/types.h> doesn't define.  */\n#undef pid_t\n\n/* Define to `unsigned' if <sys/types.h> doesn't define.  */\n#undef size_t\n\n/* Define to `int' if <sys/types.h> doesn't define.  */\n#undef uid_t\n\n/* Define to `unsigned int' or other type that is 32 bit.  */\n#undef uint32_t\n\n/* Define to `int' if <sys/types.h> doesn't define.  */\n#undef gid_t\n\n/* Define to `long' if <sys/types.h> doesn't define.  */\n#undef ino_t\n\n/* Define to `unsigned' if <sys/types.h> doesn't define.  */\n#undef dev_t\n\n/* Define on big-endian machines */\n#undef WORDS_BIGENDIAN\n\n/* Define to `unsigned long' if <sys/types.h> doesn't define.  */\n#undef rlim_t\n\n/* Define to `struct sigaltstack' if <signal.h> doesn't define.  */\n#undef stack_t\n\n/* Define if stack_t has the ss_base field. */\n#undef HAVE_SS_BASE\n\n/* Define if you can safely include both <sys/time.h> and <time.h>.  */\n#undef TIME_WITH_SYS_TIME\n\n/* Define if you can safely include both <sys/time.h> and <sys/select.h>.  */\n#undef SYS_SELECT_WITH_SYS_TIME\n\n/* Define if you have /dev/ptc */\n#undef HAVE_DEV_PTC\n\n/* Define if you have Sys4 ptys */\n#undef HAVE_SVR4_PTYS\n\n/* Define to range of pty names to try */\n#undef PTYRANGE0\n#undef PTYRANGE1\n\n/* Define mode for pty */\n#undef PTYMODE\n\n/* Define group for pty */\n#undef PTYGROUP\n\n/* Define as the return type of signal handlers (int or void).  */\n#undef RETSIGTYPE\n\n/* Define as the command at the end of signal handlers (\"\" or \"return 0;\").  */\n#undef SIGRETURN\n\n/* Define if struct sigcontext is present */\n#undef HAVE_SIGCONTEXT\n\n/* Define if touuper/tolower only work on lower/upercase characters */\n#undef BROKEN_TOUPPER\n\n/* Define if stat() ignores a trailing slash */\n#undef STAT_IGNORES_SLASH\n\n/* Define if tgetstr() has a second argument that is (char *) */\n#undef TGETSTR_CHAR_P\n\n/* Define if tgetent() returns zero for an error */\n#undef TGETENT_ZERO_ERR\n\n/* Define if the getcwd() function should not be used.  */\n#undef BAD_GETCWD\n\n/* Define if you the function: */\n#undef HAVE_FCHDIR\n#undef HAVE_FCHOWN\n#undef HAVE_FSEEKO\n#undef HAVE_FSYNC\n#undef HAVE_FLOAT_FUNCS\n#undef HAVE_GETCWD\n#undef HAVE_GETPGID\n#undef HAVE_GETPSEUDOTTY\n#undef HAVE_GETPWENT\n#undef HAVE_GETPWNAM\n#undef HAVE_GETPWUID\n#undef HAVE_GETRLIMIT\n#undef HAVE_GETTIMEOFDAY\n#undef HAVE_GETWD\n#undef HAVE_ICONV\n#undef HAVE_LSTAT\n#undef HAVE_MEMSET\n#undef HAVE_MKDTEMP\n#undef HAVE_NANOSLEEP\n#undef HAVE_NL_LANGINFO_CODESET\n#undef HAVE_OPENDIR\n#undef HAVE_PUTENV\n#undef HAVE_QSORT\n#undef HAVE_READLINK\n#undef HAVE_RENAME\n#undef HAVE_SELECT\n#undef HAVE_SELINUX\n#undef HAVE_SETENV\n#undef HAVE_SETPGID\n#undef HAVE_SETSID\n#undef HAVE_SIGACTION\n#undef HAVE_SIGALTSTACK\n#undef HAVE_SIGSET\n#undef HAVE_SIGSETJMP\n#undef HAVE_SIGSTACK\n#undef HAVE_SIGPROCMASK\n#undef HAVE_SIGVEC\n#undef HAVE_SMACK\n#undef HAVE_STRCASECMP\n#undef HAVE_STRERROR\n#undef HAVE_STRFTIME\n#undef HAVE_STRICMP\n#undef HAVE_STRNCASECMP\n#undef HAVE_STRNICMP\n#undef HAVE_STRPBRK\n#undef HAVE_STRTOL\n#undef HAVE_ST_BLKSIZE\n#undef HAVE_SYSCONF\n#undef HAVE_SYSCTL\n#undef HAVE_SYSINFO\n#undef HAVE_SYSINFO_MEM_UNIT\n#undef HAVE_TGETENT\n#undef HAVE_TOWLOWER\n#undef HAVE_TOWUPPER\n#undef HAVE_ISWUPPER\n#undef HAVE_USLEEP\n#undef HAVE_UTIME\n#undef HAVE_BIND_TEXTDOMAIN_CODESET\n\n/* Define, if needed, for accessing large files. */\n#undef _LARGE_FILES\n#undef _FILE_OFFSET_BITS\n#undef _LARGEFILE_SOURCE\n\n/* Define if you do not have utime(), but do have the utimes() function. */\n#undef HAVE_UTIMES\n\n/* Define if you have the header file: */\n#undef HAVE_DIRENT_H\n#undef HAVE_ERRNO_H\n#undef HAVE_FCNTL_H\n#undef HAVE_FRAME_H\n#undef HAVE_ICONV_H\n#undef HAVE_INTTYPES_H\n#undef HAVE_LANGINFO_H\n#undef HAVE_LIBC_H\n#undef HAVE_LIBGEN_H\n#undef HAVE_LIBINTL_H\n#undef HAVE_LOCALE_H\n#undef HAVE_MATH_H\n#undef HAVE_NDIR_H\n#undef HAVE_POLL_H\n#undef HAVE_PTHREAD_NP_H\n#undef HAVE_PWD_H\n#undef HAVE_SETJMP_H\n#undef HAVE_SGTTY_H\n#undef HAVE_STDINT_H\n#undef HAVE_STRINGS_H\n#undef HAVE_STROPTS_H\n#undef HAVE_SYS_ACCESS_H\n#undef HAVE_SYS_ACL_H\n#undef HAVE_SYS_DIR_H\n#undef HAVE_SYS_IOCTL_H\n#undef HAVE_SYS_NDIR_H\n#undef HAVE_SYS_PARAM_H\n#undef HAVE_SYS_POLL_H\n#undef HAVE_SYS_PTEM_H\n#undef HAVE_SYS_RESOURCE_H\n#undef HAVE_SYS_SELECT_H\n#undef HAVE_SYS_STATFS_H\n#undef HAVE_SYS_STREAM_H\n#undef HAVE_SYS_SYSCTL_H\n#undef HAVE_SYS_SYSINFO_H\n#undef HAVE_SYS_SYSTEMINFO_H\n#undef HAVE_SYS_TIME_H\n#undef HAVE_SYS_TYPES_H\n#undef HAVE_SYS_UTSNAME_H\n#undef HAVE_TERMCAP_H\n#undef HAVE_TERMIOS_H\n#undef HAVE_TERMIO_H\n#undef HAVE_WCHAR_H\n#undef HAVE_WCTYPE_H\n#undef HAVE_UNISTD_H\n#undef HAVE_UTIL_DEBUG_H\n#undef HAVE_UTIL_MSGI18N_H\n#undef HAVE_UTIME_H\n#undef HAVE_X11_SUNKEYSYM_H\n#undef HAVE_XM_XM_H\n#undef HAVE_XM_XPMP_H\n#undef HAVE_XM_TRAITP_H\n#undef HAVE_XM_MANAGER_H\n#undef HAVE_XM_UNHIGHLIGHTT_H\n#undef HAVE_XM_JOINSIDET_H\n#undef HAVE_XM_NOTEBOOK_H\n#undef HAVE_X11_XPM_H\n#undef HAVE_X11_XMU_EDITRES_H\n#undef HAVE_X11_SM_SMLIB_H\n\n/* Define to the type of the XpmAttributes type. */\n#undef XPMATTRIBUTES_TYPE\n\n/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */\n#undef HAVE_SYS_WAIT_H\n\n/* Define if you have a <sys/wait.h> that is not POSIX.1 compatible. */\n#undef HAVE_UNION_WAIT\n\n/* This is currently unused in vim: */\n/* Define if you have the ANSI C header files. */\n/* #undef STDC_HEADERS */\n\n/* instead, we check a few STDC things ourselves */\n#undef HAVE_STDLIB_H\n#undef HAVE_STRING_H\n\n/* Define if strings.h cannot be included when strings.h already is */\n#undef NO_STRINGS_WITH_STRING_H\n\n/* Define if you want tiny features. */\n#undef FEAT_TINY\n\n/* Define if you want small features. */\n#undef FEAT_SMALL\n\n/* Define if you want normal features. */\n#undef FEAT_NORMAL\n\n/* Define if you want big features. */\n#undef FEAT_BIG\n\n/* Define if you want huge features. */\n#undef FEAT_HUGE\n\n/* Define if you want to include the Lua interpreter. */\n#undef FEAT_LUA\n\n/* Define for linking via dlopen() or LoadLibrary() */\n#undef DYNAMIC_LUA\n\n/* Define if you want to include the MzScheme interpreter. */\n#undef FEAT_MZSCHEME\n\n/* Define if you want to include the Perl interpreter. */\n#undef FEAT_PERL\n\n/* Define for linking via dlopen() or LoadLibrary() */\n#undef DYNAMIC_PERL\n\n/* Define if you want to include the Python interpreter. */\n#undef FEAT_PYTHON\n\n/* Define if you want to include the Python3 interpreter. */\n#undef FEAT_PYTHON3\n\n/* Define for linking via dlopen() or LoadLibrary() */\n#undef DYNAMIC_PYTHON\n\n/* Define for linking via dlopen() or LoadLibrary() */\n#undef DYNAMIC_PYTHON3\n\n/* Define if dynamic python does not require RTLD_GLOBAL */\n#undef PY_NO_RTLD_GLOBAL\n\n/* Define if dynamic python3 does not require RTLD_GLOBAL */\n#undef PY3_NO_RTLD_GLOBAL\n\n/* Define if you want to include the Ruby interpreter. */\n#undef FEAT_RUBY\n\n/* Define for linking via dlopen() or LoadLibrary() */\n#undef DYNAMIC_RUBY\n\n/* Define if you want to include the Tcl interpreter. */\n#undef FEAT_TCL\n\n/* Define for linking via dlopen() or LoadLibrary() */\n#undef DYNAMIC_TCL\n\n/* Define if you want to add support for ACL */\n#undef HAVE_POSIX_ACL\n#undef HAVE_SOLARIS_ZFS_ACL\n#undef HAVE_SOLARIS_ACL\n#undef HAVE_AIX_ACL\n\n/* Define if pango_shape_full() is available. */\n#undef HAVE_PANGO_SHAPE_FULL\n\n/* Define if you want to add support of GPM (Linux console mouse daemon) */\n#undef HAVE_GPM\n\n/* Define if you want to add support of sysmouse (*BSD console mouse) */\n#undef HAVE_SYSMOUSE\n\n/* Define if you want to include the Cscope interface. */\n#undef FEAT_CSCOPE\n\n/* Define if you want to include multibyte support. */\n#undef FEAT_MBYTE\n\n/* Define if you want to include fontset support. */\n#undef FEAT_XFONTSET\n\n/* Define if you want to include XIM support. */\n#undef FEAT_XIM\n\n/* Define if you want to include Hangul input support. */\n#undef FEAT_HANGULIN\n\n/* Define if you use GTK and want GNOME support. */\n#undef FEAT_GUI_GNOME\n\n/* Define if you use KDE and want KDE Toolbar support. */\n#undef FEAT_KDETOOLBAR\n\n/* Define if GTK+ multihead support is available (requires GTK+ >= 2.1.1). */\n#undef HAVE_GTK_MULTIHEAD\n\n/* Define if your X has own locale library */\n#undef X_LOCALE\n\n/* Define if we have dlfcn.h. */\n#undef HAVE_DLFCN_H\n\n/* Define if there is a working gettext(). */\n#undef HAVE_GETTEXT\n\n/* Define if _nl_msg_cat_cntr is present. */\n#undef HAVE_NL_MSG_CAT_CNTR\n\n/* Define if we have dlopen() */\n#undef HAVE_DLOPEN\n\n/* Define if we have dlsym() */\n#undef HAVE_DLSYM\n\n/* Define if we have dl.h. */\n#undef HAVE_DL_H\n\n/* Define if we have shl_load() */\n#undef HAVE_SHL_LOAD\n\n/* Define if you want to include Sun Visual Workshop support. */\n#undef FEAT_SUN_WORKSHOP\n\n/* Define if you want to include NetBeans integration. */\n#undef FEAT_NETBEANS_INTG\n\n/* Define if you want to include process communication. */\n#undef FEAT_JOB_CHANNEL\n\n/* Define default global runtime path */\n#undef RUNTIME_GLOBAL\n\n/* Define name of who modified a released Vim */\n#undef MODIFIED_BY\n\n/* Define if you want XSMP interaction as well as vanilla swapfile safety */\n#undef USE_XSMP_INTERACT\n\n/* Define if fcntl()'s F_SETFD command knows about FD_CLOEXEC */\n#undef HAVE_FD_CLOEXEC\n\n/* Define if /proc/self/exe or similar can be read */\n#undef PROC_EXE_LINK\n\n/* Define if you want Cygwin to use the WIN32 clipboard, not compatible with X11*/\n#undef FEAT_CYGWIN_WIN32_CLIPBOARD\n\n/* Define if we have AvailabilityMacros.h on Mac OS X */\n#undef HAVE_AVAILABILITYMACROS_H\n\n/* Define if Xutf8SetWMProperties() is in an X library. */\n#undef HAVE_XUTF8SETWMPROPERTIES\n\n/* Define if GResource is used to load icons */\n#undef USE_GRESOURCE\n\n/* Define if GTK+ GUI is to be linked against GTK+ 3 */\n#undef USE_GTK3\n\n/* Define if we have isinf() */\n#undef HAVE_ISINF\n\n/* Define if we have isnan() */\n#undef HAVE_ISNAN\n\n/* Define to inline symbol or empty */\n#undef inline\n",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/configure.ac": "dnl configure.ac: autoconf script for Vim\n\ndnl Process this file with autoconf 2.12 or 2.13 to produce \"configure\".\ndnl Should also work with autoconf 2.54 and later.\n\nAC_INIT(vim.h)\nAC_CONFIG_HEADER(auto/config.h:config.h.in)\n\ndnl Being able to run configure means the system is Unix (compatible).\nAC_DEFINE(UNIX)\nAC_PROG_MAKE_SET\n\ndnl Checks for programs.\nAC_PROG_CC\tdnl required by almost everything\nAC_PROG_CPP\tdnl required by header file checks\nAC_PROGRAM_EGREP dnl required by AC_EGREP_CPP\nAC_PROG_FGREP\tdnl finds working grep -F\nAC_ISC_POSIX\tdnl required by AC_C_CROSS\nAC_PROG_AWK\tdnl required for \"make html\" in ../doc\n\ndnl Don't strip if we don't have it\nAC_CHECK_PROG(STRIP, strip, strip, :)\n\ndnl Check for extension of executables\nAC_EXEEXT\n\ndnl Check for standard headers.  We don't use this in Vim but other stuff\ndnl in autoconf needs it, where it uses STDC_HEADERS.\nAC_HEADER_STDC\nAC_HEADER_SYS_WAIT\n\ndnl Check for the flag that fails if stuff are missing.\n\nAC_MSG_CHECKING(--enable-fail-if-missing argument)\nAC_ARG_ENABLE(fail_if_missing,\n\t[  --enable-fail-if-missing    Fail if dependencies on additional features\n     specified on the command line are missing.], \n\t[fail_if_missing=\"yes\"],\n\t[fail_if_missing=\"no\"])\nAC_MSG_RESULT($fail_if_missing)\n\ndnl Set default value for CFLAGS if none is defined or it's empty\nif test -z \"$CFLAGS\"; then\n  CFLAGS=\"-O\"\n  test \"$GCC\" = yes && CFLAGS=\"-O2 -fno-strength-reduce -Wall\"\nfi\nif test \"$GCC\" = yes; then\n  dnl method that should work for nearly all versions\n  gccversion=`$CC -dumpversion`\n  if test \"x$gccversion\" = \"x\"; then\n    dnl old method; fall-back for when -dumpversion doesn't work\n    gccversion=`$CC --version | sed -e '2,$d' -e 's/darwin.//' -e 's/^[[^0-9]]*\\([[0-9]]\\.[[0-9.]]*\\).*$/\\1/g'`\n  fi\n  dnl version 4.0.1 was reported to cause trouble on Macintosh by Marcin Dalecki\n  if test \"$gccversion\" = \"3.0.1\" -o \"$gccversion\" = \"3.0.2\" -o \"$gccversion\" = \"4.0.1\"; then\n    echo 'GCC [[34]].0.[[12]] has a bug in the optimizer, disabling \"-O#\"'\n    CFLAGS=`echo \"$CFLAGS\" | sed 's/-O[[23456789]]/-O/'`\n  else\n    if test \"$gccversion\" = \"3.1\" -o \"$gccversion\" = \"3.2\" -o \"$gccversion\" = \"3.2.1\" && `echo \"$CFLAGS\" | grep -v fno-strength-reduce >/dev/null`; then\n      echo 'GCC 3.1 and 3.2 have a bug in the optimizer, adding \"-fno-strength-reduce\"'\n      CFLAGS=\"$CFLAGS -fno-strength-reduce\"\n    fi\n  fi\nfi\n\ndnl clang-500.2.75 or around has abandoned -f[no-]strength-reduce and issues a\ndnl warning when that flag is passed to.  Accordingly, adjust CFLAGS based on\ndnl the version number of the clang in use.\ndnl Note that this does not work to get the version of clang 3.1 or 3.2.\nAC_MSG_CHECKING(for clang version)\nCLANG_VERSION_STRING=`$CC --version 2>/dev/null | sed  -n -e 's/^.*clang[[^0-9]]*\\([[0-9]][[0-9]]*\\.[[0-9]][[0-9]]*\\.[[0-9]][[0-9]]*\\).*$/\\1/p'`\nif test x\"$CLANG_VERSION_STRING\" != x\"\" ; then\n  CLANG_MAJOR=`echo \"$CLANG_VERSION_STRING\" | sed -n -e 's/\\([[0-9]][[0-9]]*\\)\\.[[0-9]][[0-9]]*\\.[[0-9]][[0-9]]*/\\1/p'`\n  CLANG_MINOR=`echo \"$CLANG_VERSION_STRING\" | sed -n -e 's/[[0-9]][[0-9]]*\\.\\([[0-9]][[0-9]]*\\)\\.[[0-9]][[0-9]]*/\\1/p'`\n  CLANG_REVISION=`echo \"$CLANG_VERSION_STRING\" | sed -n -e 's/[[0-9]][[0-9]]*\\.[[0-9]][[0-9]]*\\.\\([[0-9]][[0-9]]*\\)/\\1/p'`\n  CLANG_VERSION=`expr $CLANG_MAJOR '*' 1000000 '+' $CLANG_MINOR '*' 1000 '+' $CLANG_REVISION`\n  AC_MSG_RESULT($CLANG_VERSION)\n  dnl If you find the same issue with versions earlier than 500.2.75,\n  dnl change the constant 500002075 below appropriately.  To get the\n  dnl integer corresponding to a version number, refer to the\n  dnl definition of CLANG_VERSION above.\n  AC_MSG_CHECKING(if clang supports -fno-strength-reduce)\n  if test \"$CLANG_VERSION\" -ge 500002075 ; then\n    AC_MSG_RESULT(no)\n    CFLAGS=`echo \"$CFLAGS\" | sed -e 's/-fno-strength-reduce/ /'`\n  else\n    AC_MSG_RESULT(yes)\n  fi\nelse\n  AC_MSG_RESULT(N/A)\nfi\n\ndnl If configure thinks we are cross compiling, there might be something\ndnl wrong with the CC or CFLAGS settings, give a useful warning message\nCROSS_COMPILING=\nif test \"$cross_compiling\" = yes; then\n  AC_MSG_RESULT([cannot compile a simple program; if not cross compiling check CC and CFLAGS])\n  CROSS_COMPILING=1\nfi\nAC_SUBST(CROSS_COMPILING)\n\ndnl gcc-cpp has the wonderful -MM option to produce nicer dependencies.\ndnl But gcc 3.1 changed the meaning!  See near the end.\ntest \"$GCC\" = yes && CPP_MM=M; AC_SUBST(CPP_MM)\n\nif test -f ./toolcheck; then\n  AC_CHECKING(for buggy tools)\n  sh ./toolcheck 1>&AC_FD_MSG\nfi\n\nOS_EXTRA_SRC=\"\"; OS_EXTRA_OBJ=\"\"\n\ndnl Check for BeOS, which needs an extra source file\nAC_MSG_CHECKING(for BeOS)\ncase `uname` in\n    BeOS)\tOS_EXTRA_SRC=os_beos.c; OS_EXTRA_OBJ=objects/os_beos.o\n\t\tBEOS=yes; AC_MSG_RESULT(yes);;\n    *)\t\tBEOS=no; AC_MSG_RESULT(no);;\nesac\n\ndnl If QNX is found, assume we don't want to use Xphoton\ndnl unless it was specifically asked for (--with-x)\nAC_MSG_CHECKING(for QNX)\ncase `uname` in\n    QNX)\tOS_EXTRA_SRC=os_qnx.c; OS_EXTRA_OBJ=objects/os_qnx.o\n\t\ttest -z \"$with_x\" && with_x=no\n\t\tQNX=yes; AC_MSG_RESULT(yes);;\n    *)\t\tQNX=no; AC_MSG_RESULT(no);;\nesac\n\ndnl Check for Darwin and MacOS X\ndnl We do a check for MacOS X in the very beginning because there\ndnl are a lot of other things we need to change besides GUI stuff\nAC_MSG_CHECKING([for Darwin (Mac OS X)])\nif test \"`(uname) 2>/dev/null`\" = Darwin; then\n  AC_MSG_RESULT(yes)\n\n  AC_MSG_CHECKING(--disable-darwin argument)\n  AC_ARG_ENABLE(darwin,\n\t  [  --disable-darwin        Disable Darwin (Mac OS X) support.],\n\t  , [enable_darwin=\"yes\"])\n  if test \"$enable_darwin\" = \"yes\"; then\n    AC_MSG_RESULT(no)\n    AC_MSG_CHECKING(if Darwin files are there)\n    if test -f os_macosx.m; then\n      AC_MSG_RESULT(yes)\n    else\n      AC_MSG_RESULT([no, Darwin support disabled])\n      enable_darwin=no\n    fi\n  else\n    AC_MSG_RESULT([yes, Darwin support excluded])\n  fi\n\n  AC_MSG_CHECKING(--with-mac-arch argument)\n  AC_ARG_WITH(mac-arch, [  --with-mac-arch=ARCH    current, intel, ppc or both],\n\tMACARCH=\"$withval\"; AC_MSG_RESULT($MACARCH),\n\tMACARCH=\"current\"; AC_MSG_RESULT(defaulting to $MACARCH))\n\n  AC_MSG_CHECKING(--with-developer-dir argument)\n  AC_ARG_WITH(developer-dir, [  --with-developer-dir=PATH    use PATH as location for Xcode developer tools],\n\tDEVELOPER_DIR=\"$withval\"; AC_MSG_RESULT($DEVELOPER_DIR),\n        AC_MSG_RESULT(not present))\n  \n  if test \"x$DEVELOPER_DIR\" = \"x\"; then\n    AC_PATH_PROG(XCODE_SELECT, xcode-select)\n    if test \"x$XCODE_SELECT\" != \"x\"; then\n      AC_MSG_CHECKING(for developer dir using xcode-select)\n      DEVELOPER_DIR=`$XCODE_SELECT -print-path`\n      AC_MSG_RESULT([$DEVELOPER_DIR])\n    else\n      DEVELOPER_DIR=/Developer\n    fi\n  fi\n\n  if test \"x$MACARCH\" = \"xboth\"; then\n    AC_MSG_CHECKING(for 10.4 universal SDK)\n    dnl There is a terrible inconsistency (but we appear to get away with it):\n    dnl $CFLAGS uses the 10.4u SDK library for the headers, while $CPPFLAGS\n    dnl doesn't, because \"gcc -E\" doesn't grok it.  That means the configure\n    dnl tests using the preprocessor are actually done with the wrong header\n    dnl files. $LDFLAGS is set at the end, because configure uses it together\n    dnl with $CFLAGS and we can only have one -sysroot argument.\n    save_cppflags=\"$CPPFLAGS\"\n    save_cflags=\"$CFLAGS\"\n    save_ldflags=\"$LDFLAGS\"\n    CFLAGS=\"$CFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc\"\n    AC_TRY_LINK([ ], [ ],\n\tAC_MSG_RESULT(found, will make universal binary),\n\n\tAC_MSG_RESULT(not found)\n\tCFLAGS=\"$save_cflags\"\n\tAC_MSG_CHECKING(if Intel architecture is supported)\n\tCPPFLAGS=\"$CPPFLAGS -arch i386\"\n\tLDFLAGS=\"$save_ldflags -arch i386\"\n\tAC_TRY_LINK([ ], [ ],\n\t    AC_MSG_RESULT(yes); MACARCH=\"intel\",\n\t    AC_MSG_RESULT(no, using PowerPC)\n\t\tMACARCH=\"ppc\"\n\t\tCPPFLAGS=\"$save_cppflags -arch ppc\"\n\t\tLDFLAGS=\"$save_ldflags -arch ppc\"))\n  elif test \"x$MACARCH\" = \"xintel\"; then\n    CPPFLAGS=\"$CPPFLAGS -arch intel\"\n    LDFLAGS=\"$LDFLAGS -arch intel\"\n  elif test \"x$MACARCH\" = \"xppc\"; then\n    CPPFLAGS=\"$CPPFLAGS -arch ppc\"\n    LDFLAGS=\"$LDFLAGS -arch ppc\"\n  fi\n\n  if test \"$enable_darwin\" = \"yes\"; then\n    MACOSX=yes\n    OS_EXTRA_SRC=\"os_macosx.m os_mac_conv.c\";\n    OS_EXTRA_OBJ=\"objects/os_macosx.o objects/os_mac_conv.o\"\n    dnl TODO: use -arch i386 on Intel machines\n    dnl Removed -no-cpp-precomp, only for very old compilers.\n    CPPFLAGS=\"$CPPFLAGS -DMACOS_X_UNIX\"\n\n    dnl If Carbon is found, assume we don't want X11\n    dnl unless it was specifically asked for (--with-x)\n    dnl or Motif, Athena or GTK GUI is used.\n    AC_CHECK_HEADER(Carbon/Carbon.h, CARBON=yes)\n    if test \"x$CARBON\" = \"xyes\"; then\n      if test -z \"$with_x\" -a \"X$enable_gui\" != Xmotif -a \"X$enable_gui\" != Xathena -a \"X$enable_gui\" != Xgtk2 -a \"X$enable_gui\" != Xgtk3; then\n\twith_x=no\n      fi\n    fi\n  fi\n\n  dnl Avoid a bug with -O2 with gcc 4.0.1.  Symptom: malloc() reports double\n  dnl free.  This happens in expand_filename(), because the optimizer swaps\n  dnl two blocks of code, both using \"repl\", that can't be swapped.\n  if test \"$MACARCH\" = \"intel\" -o \"$MACARCH\" = \"both\"; then\n    CFLAGS=`echo \"$CFLAGS\" | sed 's/-O[[23456789]]/-Oz/'`\n  fi\n\nelse\n  AC_MSG_RESULT(no)\nfi\n\ndnl Mac OS X 10.9+ no longer include AvailabilityMacros.h in Carbon\ndnl so we need to include it to have access to version macros.\nAC_CHECK_HEADERS(AvailabilityMacros.h)\n\nAC_SUBST(OS_EXTRA_SRC)\nAC_SUBST(OS_EXTRA_OBJ)\n\ndnl Add /usr/local/lib to $LDFLAGS and /usr/local/include to CFLAGS.\ndnl Only when the directory exists and it wasn't there yet.\ndnl For gcc don't do this when it is already in the default search path.\ndnl Skip all of this when cross-compiling.\nif test \"$cross_compiling\" = no; then\n  AC_MSG_CHECKING(--with-local-dir argument)\n  have_local_include=''\n  have_local_lib=''\n  AC_ARG_WITH([local-dir], [  --with-local-dir=PATH   search PATH instead of /usr/local for local libraries.\n  --without-local-dir     do not search /usr/local for local libraries.], [\n    local_dir=\"$withval\"\n    case \"$withval\" in\n    */*) ;;\n    no)\n      # avoid adding local dir to LDFLAGS and CPPFLAGS\n      have_local_include=yes\n      have_local_lib=yes\n      ;;\n    *) AC_MSG_ERROR(must pass path argument to --with-local-dir) ;;\n    esac\n\tAC_MSG_RESULT($local_dir)\n  ], [\n    local_dir=/usr/local\n    AC_MSG_RESULT(Defaulting to $local_dir)\n  ])\n  if test \"$GCC\" = yes -a \"$local_dir\" != no; then\n    echo 'void f(){}' > conftest.c\n    dnl Removed -no-cpp-precomp, only needed for OS X 10.2 (Ben Fowler)\n    have_local_include=`${CC-cc} -c -v conftest.c 2>&1 | grep \"${local_dir}/include\"`\n    have_local_lib=`${CC-cc} -c -v conftest.c 2>&1 | grep \"${local_dir}/lib\"`\n    rm -f conftest.c conftest.o\n  fi\n  if test -z \"$have_local_lib\" -a -d \"${local_dir}/lib\"; then\n    tt=`echo \"$LDFLAGS\" | sed -e \"s+-L${local_dir}/lib ++g\" -e \"s+-L${local_dir}/lib$++g\"`\n    if test \"$tt\" = \"$LDFLAGS\"; then\n      LDFLAGS=\"$LDFLAGS -L${local_dir}/lib\"\n    fi\n  fi\n  if test -z \"$have_local_include\" -a -d \"${local_dir}/include\"; then\n    tt=`echo \"$CPPFLAGS\" | sed -e \"s+-I${local_dir}/include ++g\" -e \"s+-I${local_dir}/include$++g\"`\n    if test \"$tt\" = \"$CPPFLAGS\"; then\n      CPPFLAGS=\"$CPPFLAGS -I${local_dir}/include\"\n    fi\n  fi\nfi\n\nAC_MSG_CHECKING(--with-vim-name argument)\nAC_ARG_WITH(vim-name, [  --with-vim-name=NAME    what to call the Vim executable],\n\tVIMNAME=\"$withval\"; AC_MSG_RESULT($VIMNAME),\n\tVIMNAME=\"vim\"; AC_MSG_RESULT(Defaulting to $VIMNAME))\nAC_SUBST(VIMNAME)\nAC_MSG_CHECKING(--with-ex-name argument)\nAC_ARG_WITH(ex-name, [  --with-ex-name=NAME     what to call the Ex executable],\n\tEXNAME=\"$withval\"; AC_MSG_RESULT($EXNAME),\n\tEXNAME=\"ex\"; AC_MSG_RESULT(Defaulting to ex))\nAC_SUBST(EXNAME)\nAC_MSG_CHECKING(--with-view-name argument)\nAC_ARG_WITH(view-name, [  --with-view-name=NAME   what to call the View executable],\n\tVIEWNAME=\"$withval\"; AC_MSG_RESULT($VIEWNAME),\n\tVIEWNAME=\"view\"; AC_MSG_RESULT(Defaulting to view))\nAC_SUBST(VIEWNAME)\n\nAC_MSG_CHECKING(--with-global-runtime argument)\nAC_ARG_WITH(global-runtime, [  --with-global-runtime=DIR    global runtime directory in 'runtimepath'],\n\tAC_MSG_RESULT($withval); AC_DEFINE_UNQUOTED(RUNTIME_GLOBAL, \"$withval\"),\n\tAC_MSG_RESULT(no))\n\nAC_MSG_CHECKING(--with-modified-by argument)\nAC_ARG_WITH(modified-by, [  --with-modified-by=NAME       name of who modified a release version],\n\tAC_MSG_RESULT($withval); AC_DEFINE_UNQUOTED(MODIFIED_BY, \"$withval\"),\n\tAC_MSG_RESULT(no))\n\ndnl Check for EBCDIC stolen from the LYNX port to z/OS Unix\nAC_MSG_CHECKING(if character set is EBCDIC)\nAC_TRY_COMPILE([ ],\n[ /* TryCompile function for CharSet.\n   Treat any failure as ASCII for compatibility with existing art.\n   Use compile-time rather than run-time tests for cross-compiler\n   tolerance.  */\n#if '0'!=240\nmake an error \"Character set is not EBCDIC\"\n#endif ],\n[ # TryCompile action if true\ncf_cv_ebcdic=yes ],\n[ # TryCompile action if false\ncf_cv_ebcdic=no])\n# end of TryCompile ])\n# end of CacheVal CvEbcdic\nAC_MSG_RESULT($cf_cv_ebcdic)\ncase \"$cf_cv_ebcdic\" in  #(vi\n    yes)\tAC_DEFINE(EBCDIC)\n\t\tline_break='\"\\\\n\"'\n\t\t;;\n    *)\t\tline_break='\"\\\\012\"';;\nesac\nAC_SUBST(line_break)\n\nif test \"$cf_cv_ebcdic\" = \"yes\"; then\ndnl If we have EBCDIC we most likely have z/OS Unix, let's test it!\nAC_MSG_CHECKING(for z/OS Unix)\ncase `uname` in\n    OS/390)\tzOSUnix=\"yes\";\n\t\tdnl If using cc the environment variable _CC_CCMODE must be\n\t\tdnl set to \"1\", so that some compiler extensions are enabled.\n\t\tdnl If using c89 the environment variable is named _CC_C89MODE.\n\t\tdnl Note: compile with c89 never tested.\n\t\tif test \"$CC\" = \"cc\"; then\n\t\t  ccm=\"$_CC_CCMODE\"\n\t\t  ccn=\"CC\"\n\t\telse\n\t\t  if test \"$CC\" = \"c89\"; then\n\t\t    ccm=\"$_CC_C89MODE\"\n\t\t    ccn=\"C89\"\n\t\t  else\n\t\t    ccm=1\n\t\t  fi\n\t\tfi\n\t\tif test \"$ccm\" != \"1\"; then\n\t\t  echo \"\"\n\t\t  echo \"------------------------------------------\"\n\t\t  echo \" On z/OS Unix, the environment variable\"\n\t\t  echo \" _CC_${ccn}MODE must be set to \\\"1\\\"!\"\n\t\t  echo \" Do:\"\n\t\t  echo \"    export _CC_${ccn}MODE=1\"\n\t\t  echo \" and then call configure again.\"\n\t\t  echo \"------------------------------------------\"\n\t\t  exit 1\n\t\tfi\n\t\t# Set CFLAGS for configure process.\n\t\t# This will be reset later for config.mk.\n\t\t# Use haltonmsg to force error for missing H files.\n\t\tCFLAGS=\"$CFLAGS -D_ALL_SOURCE -Wc,float(ieee),haltonmsg(3296)\";\n\t\tLDFLAGS=\"$LDFLAGS -Wl,EDIT=NO\"\n\t\tAC_MSG_RESULT(yes)\n\t\t;;\n    *)\t\tzOSUnix=\"no\";\n\t\tAC_MSG_RESULT(no)\n\t\t;;\nesac\nfi\n\ndnl Set QUOTESED. Needs additional backslashes on zOS\nif test \"$zOSUnix\" = \"yes\"; then\n    QUOTESED=\"sed -e 's/[[\\\\\\\\\\\"]]/\\\\\\\\\\\\\\\\&/g' -e 's/\\\\\\\\\\\\\\\\\\\"/\\\"/' -e 's/\\\\\\\\\\\\\\\\\\\";\\$\\$/\\\";/'\"\nelse\n    QUOTESED=\"sed -e 's/[[\\\\\\\\\\\"]]/\\\\\\\\&/g' -e 's/\\\\\\\\\\\"/\\\"/' -e 's/\\\\\\\\\\\";\\$\\$/\\\";/'\"\nfi\nAC_SUBST(QUOTESED)\n\n\ndnl Link with -lsmack for Smack stuff; if not found\nAC_MSG_CHECKING(--disable-smack argument)\nAC_ARG_ENABLE(smack,\n\t[  --disable-smack\t  Do not check for Smack support.],\n\t, enable_smack=\"yes\")\nif test \"$enable_smack\" = \"yes\"; then\n  AC_MSG_RESULT(no)\n  AC_CHECK_HEADER([linux/xattr.h], true, enable_smack=\"no\")\nelse\n  AC_MSG_RESULT(yes)\nfi\nif test \"$enable_smack\" = \"yes\"; then\n  AC_CHECK_HEADER([attr/xattr.h], true, enable_smack=\"no\")\nfi\nif test \"$enable_smack\" = \"yes\"; then\n  AC_MSG_CHECKING(for XATTR_NAME_SMACKEXEC in linux/xattr.h)\n  AC_EGREP_CPP(XATTR_NAME_SMACKEXEC, [#include <linux/xattr.h>],\n\t       AC_MSG_RESULT(yes),\n\t       AC_MSG_RESULT(no); enable_smack=\"no\")\nfi\nif test \"$enable_smack\" = \"yes\"; then\n  AC_CHECK_LIB(attr, setxattr,\n\t  [LIBS=\"$LIBS -lattr\"\n\t   found_smack=\"yes\"\n\t   AC_DEFINE(HAVE_SMACK)])\nfi\n\ndnl When smack was found don't search for SELinux\nif test \"x$found_smack\" = \"x\"; then\n  dnl Link with -lselinux for SELinux stuff; if not found\n  AC_MSG_CHECKING(--disable-selinux argument)\n  AC_ARG_ENABLE(selinux,\n\t  [  --disable-selinux\t  Do not check for SELinux support.],\n\t  , enable_selinux=\"yes\")\n  if test \"$enable_selinux\" = \"yes\"; then\n    AC_MSG_RESULT(no)\n    AC_CHECK_LIB(selinux, is_selinux_enabled,\n\t    [LIBS=\"$LIBS -lselinux\"\n\t     AC_DEFINE(HAVE_SELINUX)])\n  else\n     AC_MSG_RESULT(yes)\n  fi\nfi\n\ndnl Check user requested features.\n\nAC_MSG_CHECKING(--with-features argument)\nAC_ARG_WITH(features, [  --with-features=TYPE    tiny, small, normal, big or huge (default: huge)],\n\tfeatures=\"$withval\"; AC_MSG_RESULT($features),\n\tfeatures=\"huge\"; AC_MSG_RESULT(Defaulting to huge))\n\ndovimdiff=\"\"\ndogvimdiff=\"\"\ncase \"$features\" in\n  tiny)\t\tAC_DEFINE(FEAT_TINY) ;;\n  small)\tAC_DEFINE(FEAT_SMALL) ;;\n  normal)\tAC_DEFINE(FEAT_NORMAL) dovimdiff=\"installvimdiff\";\n\t\t\tdogvimdiff=\"installgvimdiff\" ;;\n  big)\t\tAC_DEFINE(FEAT_BIG) dovimdiff=\"installvimdiff\";\n\t\t\tdogvimdiff=\"installgvimdiff\" ;;\n  huge)\t\tAC_DEFINE(FEAT_HUGE) dovimdiff=\"installvimdiff\";\n\t\t\tdogvimdiff=\"installgvimdiff\" ;;\n  *)\t\tAC_MSG_RESULT([Sorry, $features is not supported]) ;;\nesac\n\nAC_SUBST(dovimdiff)\nAC_SUBST(dogvimdiff)\n\nAC_MSG_CHECKING(--with-compiledby argument)\nAC_ARG_WITH(compiledby, [  --with-compiledby=NAME  name to show in :version message],\n\tcompiledby=\"$withval\"; AC_MSG_RESULT($withval),\n\tcompiledby=\"\"; AC_MSG_RESULT(no))\nAC_SUBST(compiledby)\n\nAC_MSG_CHECKING(--disable-xsmp argument)\nAC_ARG_ENABLE(xsmp,\n\t[  --disable-xsmp          Disable XSMP session management],\n\t, enable_xsmp=\"yes\")\n\nif test \"$enable_xsmp\" = \"yes\"; then\n  AC_MSG_RESULT(no)\n  AC_MSG_CHECKING(--disable-xsmp-interact argument)\n  AC_ARG_ENABLE(xsmp-interact,\n\t  [  --disable-xsmp-interact Disable XSMP interaction],\n\t  , enable_xsmp_interact=\"yes\")\n  if test \"$enable_xsmp_interact\" = \"yes\"; then\n    AC_MSG_RESULT(no)\n    AC_DEFINE(USE_XSMP_INTERACT)\n  else\n    AC_MSG_RESULT(yes)\n  fi\nelse\n  AC_MSG_RESULT(yes)\nfi\n\ndnl Check for Lua feature.\nAC_MSG_CHECKING(--enable-luainterp argument)\nAC_ARG_ENABLE(luainterp,\n\t[  --enable-luainterp[=OPTS]     Include Lua interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,\n\t[enable_luainterp=\"no\"])\nAC_MSG_RESULT($enable_luainterp)\n\nif test \"$enable_luainterp\" = \"yes\" -o \"$enable_luainterp\" = \"dynamic\"; then\n  if test \"x$features\" = \"xtiny\" -o \"x$features\" = \"xsmall\"; then\n    AC_MSG_ERROR([cannot use Lua with tiny or small features])\n  fi\n\n  dnl -- find the lua executable\n  AC_SUBST(vi_cv_path_lua)\n\n  AC_MSG_CHECKING(--with-lua-prefix argument)\n  AC_ARG_WITH(lua_prefix,\n\t[  --with-lua-prefix=PFX   Prefix where Lua is installed.],\n\twith_lua_prefix=\"$withval\"; AC_MSG_RESULT($with_lua_prefix),\n\twith_lua_prefix=\"\";AC_MSG_RESULT(no))\n\n  if test \"X$with_lua_prefix\" != \"X\"; then\n       vi_cv_path_lua_pfx=\"$with_lua_prefix\"\n  else\n    AC_MSG_CHECKING(LUA_PREFIX environment var)\n    if test \"X$LUA_PREFIX\" != \"X\"; then\n\tAC_MSG_RESULT(\"$LUA_PREFIX\")\n\tvi_cv_path_lua_pfx=\"$LUA_PREFIX\"\n    else\n\tAC_MSG_RESULT([not set, default to /usr])\n\tvi_cv_path_lua_pfx=\"/usr\"\n    fi\n  fi\n\n  AC_MSG_CHECKING(--with-luajit)\n  AC_ARG_WITH(luajit,\n\t[  --with-luajit           Link with LuaJIT instead of Lua.],\n\t[vi_cv_with_luajit=\"$withval\"],\n\t[vi_cv_with_luajit=\"no\"])\n  AC_MSG_RESULT($vi_cv_with_luajit)\n\n  LUA_INC=\n  if test \"X$vi_cv_path_lua_pfx\" != \"X\"; then\n    if test \"x$vi_cv_with_luajit\" != \"xno\"; then\n      dnl -- try to find LuaJIT executable\n      AC_PATH_PROG(vi_cv_path_luajit, luajit)\n      if test \"X$vi_cv_path_luajit\" != \"X\"; then\n\tdnl -- find LuaJIT version\n\tAC_CACHE_CHECK(LuaJIT version, vi_cv_version_luajit,\n\t[ vi_cv_version_luajit=`${vi_cv_path_luajit} -v 2>&1 | sed 's/LuaJIT \\([[0-9.]]*\\)\\.[[0-9]]\\(-[[a-z0-9]]*\\)* .*/\\1/'` ])\n\tAC_CACHE_CHECK(Lua version of LuaJIT, vi_cv_version_lua_luajit,\n\t[ vi_cv_version_lua_luajit=`${vi_cv_path_luajit} -e \"print(_VERSION)\" | sed 's/.* //'` ])\n\tvi_cv_path_lua=\"$vi_cv_path_luajit\"\n\tvi_cv_version_lua=\"$vi_cv_version_lua_luajit\"\n      fi\n    else\n      dnl -- try to find Lua executable\n      AC_PATH_PROG(vi_cv_path_plain_lua, lua)\n      if test \"X$vi_cv_path_plain_lua\" != \"X\"; then\n\tdnl -- find Lua version\n\tAC_CACHE_CHECK(Lua version, vi_cv_version_plain_lua,\n\t[ vi_cv_version_plain_lua=`${vi_cv_path_plain_lua} -e \"print(_VERSION)\" | sed 's/.* //'` ])\n      fi\n      vi_cv_path_lua=\"$vi_cv_path_plain_lua\"\n      vi_cv_version_lua=\"$vi_cv_version_plain_lua\"\n    fi\n    if test \"x$vi_cv_with_luajit\" != \"xno\" && test \"X$vi_cv_version_luajit\" != \"X\"; then\n      AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include/luajit-$vi_cv_version_luajit)\n      if test -f \"$vi_cv_path_lua_pfx/include/luajit-$vi_cv_version_luajit/lua.h\"; then\n\tAC_MSG_RESULT(yes)\n\tLUA_INC=/luajit-$vi_cv_version_luajit\n      fi\n    fi\n    if test \"X$LUA_INC\" = \"X\"; then\n      AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include)\n      if test -f \"$vi_cv_path_lua_pfx/include/lua.h\"; then\n\tAC_MSG_RESULT(yes)\n      else\n\tAC_MSG_RESULT(no)\n\tAC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include/lua$vi_cv_version_lua)\n\tif test -f \"$vi_cv_path_lua_pfx/include/lua$vi_cv_version_lua/lua.h\"; then\n\t  AC_MSG_RESULT(yes)\n\t  LUA_INC=/lua$vi_cv_version_lua\n\telse\n\t  AC_MSG_RESULT(no)\n\t  vi_cv_path_lua_pfx=\n\tfi\n      fi\n    fi\n  fi\n\n  if test \"X$vi_cv_path_lua_pfx\" != \"X\"; then\n    if test \"x$vi_cv_with_luajit\" != \"xno\"; then\n      multiarch=`dpkg-architecture -qDEB_HOST_MULTIARCH 2> /dev/null`\n      if test \"X$multiarch\" != \"X\"; then\n\tlib_multiarch=\"lib/${multiarch}\"\n      else\n\tlib_multiarch=\"lib\"\n      fi\n      if test \"X$vi_cv_version_lua\" = \"X\"; then\n\tLUA_LIBS=\"-L${vi_cv_path_lua_pfx}/${lib_multiarch} -lluajit\"\n      else\n\tLUA_LIBS=\"-L${vi_cv_path_lua_pfx}/${lib_multiarch} -lluajit-$vi_cv_version_lua\"\n      fi\n    else\n      if test \"X$LUA_INC\" != \"X\"; then\n\tdnl Test alternate location using version\n\tLUA_LIBS=\"-L${vi_cv_path_lua_pfx}/lib -llua$vi_cv_version_lua\"\n      else\n\tLUA_LIBS=\"-L${vi_cv_path_lua_pfx}/lib -llua\"\n      fi\n    fi\n    if test \"$enable_luainterp\" = \"dynamic\"; then\n      lua_ok=\"yes\"\n    else\n      AC_MSG_CHECKING([if link with ${LUA_LIBS} is sane])\n      libs_save=$LIBS\n      LIBS=\"$LIBS $LUA_LIBS\"\n      AC_TRY_LINK(,[ ],\n\tAC_MSG_RESULT(yes); lua_ok=\"yes\",\n\tAC_MSG_RESULT(no); lua_ok=\"no\"; LUA_LIBS=\"\")\n      LIBS=$libs_save\n    fi\n    if test \"x$lua_ok\" = \"xyes\"; then\n      LUA_CFLAGS=\"-I${vi_cv_path_lua_pfx}/include${LUA_INC}\"\n      LUA_SRC=\"if_lua.c\"\n      LUA_OBJ=\"objects/if_lua.o\"\n      LUA_PRO=\"if_lua.pro\"\n      AC_DEFINE(FEAT_LUA)\n    fi\n    if test \"$enable_luainterp\" = \"dynamic\"; then\n      if test \"x$vi_cv_with_luajit\" != \"xno\"; then\n\tluajit=\"jit\"\n      fi\n      if test -f \"${vi_cv_path_lua_pfx}/bin/cyglua-${vi_cv_version_lua}.dll\"; then\n\tvi_cv_dll_name_lua=\"cyglua-${vi_cv_version_lua}.dll\"\n      else\n\tif test \"x$MACOSX\" = \"xyes\"; then\n\t  ext=\"dylib\"\n\t  indexes=\"\"\n\telse\n\t  ext=\"so\"\n\t  indexes=\".0 .1 .2 .3 .4 .5 .6 .7 .8 .9\"\n\t  multiarch=`dpkg-architecture -qDEB_HOST_MULTIARCH 2> /dev/null`\n\t  if test \"X$multiarch\" != \"X\"; then\n\t    lib_multiarch=\"lib/${multiarch}\"\n\t  fi\n\tfi\n\tdnl Determine the sover for the current version, but fallback to\n\tdnl liblua${vi_cv_version_lua}.so if no sover-versioned file is found.\n\tAC_MSG_CHECKING(if liblua${luajit}*.${ext}* can be found in $vi_cv_path_lua_pfx)\n\tfor subdir in \"${lib_multiarch}\" lib64 lib; do\n\t  if test -z \"$subdir\"; then\n\t    continue\n\t  fi\n\t  for sover in \"${vi_cv_version_lua}.${ext}\" \"-${vi_cv_version_lua}.${ext}\" \\\n\t    \".${vi_cv_version_lua}.${ext}\" \".${ext}.${vi_cv_version_lua}\"; do\n\t    for i in $indexes \"\"; do\n\t      if test -f \"${vi_cv_path_lua_pfx}/${subdir}/liblua${luajit}${sover}$i\"; then\n\t\tsover2=\"$i\"\n\t\tbreak 3\n\t      fi\n\t    done\n\t  done\n\t  sover=\"\"\n\tdone\n\tif test \"X$sover\" = \"X\"; then\n\t  AC_MSG_RESULT(no)\n\t  lua_ok=\"no\"\n\t  vi_cv_dll_name_lua=\"liblua${luajit}.${ext}\"\n\telse\n\t  AC_MSG_RESULT(yes)\n\t  lua_ok=\"yes\"\n\t  vi_cv_dll_name_lua=\"liblua${luajit}${sover}$sover2\"\n\tfi\n      fi\n      AC_DEFINE(DYNAMIC_LUA)\n      LUA_LIBS=\"\"\n      LUA_CFLAGS=\"-DDYNAMIC_LUA_DLL=\\\\\\\"${vi_cv_dll_name_lua}\\\\\\\" $LUA_CFLAGS\"\n    fi\n    if test \"X$LUA_CFLAGS$LUA_LIBS\" != \"X\" && \\\n       test \"x$MACOSX\" = \"xyes\" && test \"x$vi_cv_with_luajit\" != \"xno\" && \\\n       test \"`(uname -m) 2>/dev/null`\" = \"x86_64\"; then\n      dnl OSX/x64 requires these flags. See http://luajit.org/install.html\n      LUA_LIBS=\"-pagezero_size 10000 -image_base 100000000 $LUA_LIBS\"\n    fi\n  fi\n  if test \"$fail_if_missing\" = \"yes\" -a \"$lua_ok\" != \"yes\"; then\n    AC_MSG_ERROR([could not configure lua])\n  fi\n  AC_SUBST(LUA_SRC)\n  AC_SUBST(LUA_OBJ)\n  AC_SUBST(LUA_PRO)\n  AC_SUBST(LUA_LIBS)\n  AC_SUBST(LUA_CFLAGS)\nfi\n\n\ndnl Check for MzScheme feature.\nAC_MSG_CHECKING(--enable-mzschemeinterp argument)\nAC_ARG_ENABLE(mzschemeinterp,\n\t[  --enable-mzschemeinterp   Include MzScheme interpreter.], ,\n\t[enable_mzschemeinterp=\"no\"])\nAC_MSG_RESULT($enable_mzschemeinterp)\n\nif test \"$enable_mzschemeinterp\" = \"yes\"; then\n  dnl -- find the mzscheme executable\n  AC_SUBST(vi_cv_path_mzscheme)\n\n  AC_MSG_CHECKING(--with-plthome argument)\n  AC_ARG_WITH(plthome,\n\t[  --with-plthome=PLTHOME   Use PLTHOME.],\n\twith_plthome=\"$withval\"; AC_MSG_RESULT($with_plthome),\n\twith_plthome=\"\";AC_MSG_RESULT(\"no\"))\n\n  if test \"X$with_plthome\" != \"X\"; then\n       vi_cv_path_mzscheme_pfx=\"$with_plthome\"\n       vi_cv_path_mzscheme=\"${vi_cv_path_mzscheme_pfx}/bin/mzscheme\"\n  else\n    AC_MSG_CHECKING(PLTHOME environment var)\n    if test \"X$PLTHOME\" != \"X\"; then\n\tAC_MSG_RESULT(\"$PLTHOME\")\n\tvi_cv_path_mzscheme_pfx=\"$PLTHOME\"\n\tvi_cv_path_mzscheme=\"${vi_cv_path_mzscheme_pfx}/bin/mzscheme\"\n    else\n\tAC_MSG_RESULT(not set)\n\tdnl -- try to find MzScheme executable\n\tAC_PATH_PROG(vi_cv_path_mzscheme, mzscheme)\n\n\tdnl resolve symbolic link, the executable is often elsewhere and there\n\tdnl are no links for the include files.\n\tif test \"X$vi_cv_path_mzscheme\" != \"X\"; then\n\t  lsout=`ls -l $vi_cv_path_mzscheme`\n\t  if echo \"$lsout\" | grep -e '->' >/dev/null 2>/dev/null; then\n\t    vi_cv_path_mzscheme=`echo \"$lsout\" | sed 's/.*-> \\(.*\\)/\\1/'`\n\t  fi\n\tfi\n\n\tif test \"X$vi_cv_path_mzscheme\" != \"X\"; then\n\t    dnl -- find where MzScheme thinks it was installed\n\t    AC_CACHE_CHECK(MzScheme install prefix,vi_cv_path_mzscheme_pfx,\n\t    dnl different versions of MzScheme differ in command line processing\n\t    dnl use universal approach\n\t    echo \"(display (simplify-path\t\t\\\n\t       (build-path (call-with-values\t\\\n\t\t(lambda () (split-path (find-system-path (quote exec-file)))) \\\n\t\t(lambda (base name must-be-dir?) base)) (quote up))))\" > mzdirs.scm\n\t    dnl Remove a trailing slash\n\t    [ vi_cv_path_mzscheme_pfx=`${vi_cv_path_mzscheme} -r mzdirs.scm | \\\n\t\tsed -e 's+/$++'` ])\n\t    rm -f mzdirs.scm\n\tfi\n    fi\n  fi\n\n  if test \"X$vi_cv_path_mzscheme_pfx\" != \"X\"; then\n    AC_MSG_CHECKING(for racket include directory)\n    SCHEME_INC=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-include-dir))) (when (path? p) (display p)))'`\n    if test \"X$SCHEME_INC\" != \"X\"; then\n      AC_MSG_RESULT(${SCHEME_INC})\n    else\n      AC_MSG_RESULT(not found)\n      AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include)\n      if test -f \"$vi_cv_path_mzscheme_pfx/include/scheme.h\"; then\n\tSCHEME_INC=${vi_cv_path_mzscheme_pfx}/include\n\tAC_MSG_RESULT(yes)\n      else\n\tAC_MSG_RESULT(no)\n\tAC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt)\n\tif test -f \"$vi_cv_path_mzscheme_pfx/include/plt/scheme.h\"; then\n\t  AC_MSG_RESULT(yes)\n\t  SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt\n\telse\n\t  AC_MSG_RESULT(no)\n\t  AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/racket)\n\t  if test -f \"$vi_cv_path_mzscheme_pfx/include/racket/scheme.h\"; then\n\t    AC_MSG_RESULT(yes)\n\t    SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/racket\n\t  else\n\t    AC_MSG_RESULT(no)\n\t    AC_MSG_CHECKING(if scheme.h can be found in /usr/include/plt/)\n\t    if test -f /usr/include/plt/scheme.h; then\n\t      AC_MSG_RESULT(yes)\n\t      SCHEME_INC=/usr/include/plt\n\t    else\n\t      AC_MSG_RESULT(no)\n\t      AC_MSG_CHECKING(if scheme.h can be found in /usr/include/racket/)\n\t      if test -f /usr/include/racket/scheme.h; then\n\t\tAC_MSG_RESULT(yes)\n\t\tSCHEME_INC=/usr/include/racket\n\t      else\n\t\tAC_MSG_RESULT(no)\n\t\tvi_cv_path_mzscheme_pfx=\n\t      fi\n\t    fi\n\t  fi\n\tfi\n      fi\n    fi\n  fi\n\n  if test \"X$vi_cv_path_mzscheme_pfx\" != \"X\"; then\n\n    AC_MSG_CHECKING(for racket lib directory)\n    SCHEME_LIB=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-lib-dir))) (when (path? p) (display p)))'`\n    if test \"X$SCHEME_LIB\" != \"X\"; then\n      AC_MSG_RESULT(${SCHEME_LIB})\n    else\n      AC_MSG_RESULT(not found)\n    fi\n\n    for path in \"${vi_cv_path_mzscheme_pfx}/lib\" \"${SCHEME_LIB}\"; do\n      if test \"X$path\" != \"X\"; then\n\tif test \"x$MACOSX\" = \"xyes\"; then\n\t  MZSCHEME_LIBS=\"-framework Racket\"\n\t  MZSCHEME_CFLAGS=\"-DMZ_PRECISE_GC\"\n\telif test -f \"${path}/libmzscheme3m.a\"; then\n\t  MZSCHEME_LIBS=\"${path}/libmzscheme3m.a\"\n\t  MZSCHEME_CFLAGS=\"-DMZ_PRECISE_GC\"\n\telif test -f \"${path}/libracket3m.a\"; then\n\t  MZSCHEME_LIBS=\"${path}/libracket3m.a\"\n\t  MZSCHEME_CFLAGS=\"-DMZ_PRECISE_GC\"\n\telif test -f \"${path}/libracket.a\"; then\n\t  MZSCHEME_LIBS=\"${path}/libracket.a ${path}/libmzgc.a\"\n\telif test -f \"${path}/libmzscheme.a\"; then\n\t  MZSCHEME_LIBS=\"${path}/libmzscheme.a ${path}/libmzgc.a\"\n\telse\n\t  dnl Using shared objects\n\t  if test -f \"${path}/libmzscheme3m.so\"; then\n\t    MZSCHEME_LIBS=\"-L${path} -lmzscheme3m\"\n\t    MZSCHEME_CFLAGS=\"-DMZ_PRECISE_GC\"\n\t  elif test -f \"${path}/libracket3m.so\"; then\n\t    MZSCHEME_LIBS=\"-L${path} -lracket3m\"\n\t    MZSCHEME_CFLAGS=\"-DMZ_PRECISE_GC\"\n\t  elif test -f \"${path}/libracket.so\"; then\n\t    MZSCHEME_LIBS=\"-L${path} -lracket -lmzgc\"\n\t  else\n\t    dnl try next until last\n\t    if test \"$path\" != \"$SCHEME_LIB\"; then\n\t      continue\n\t    fi\n\t    MZSCHEME_LIBS=\"-L${path} -lmzscheme -lmzgc\"\n\t  fi\n\t  if test \"$GCC\" = yes; then\n\t    dnl Make Vim remember the path to the library.  For when it's not in\n\t    dnl $LD_LIBRARY_PATH.\n\t    MZSCHEME_LIBS=\"${MZSCHEME_LIBS} -Wl,-rpath -Wl,${path}\"\n\t  elif test \"`(uname) 2>/dev/null`\" = SunOS &&\n\t\t\t\t   uname -r | grep '^5' >/dev/null; then\n\t    MZSCHEME_LIBS=\"${MZSCHEME_LIBS} -R ${path}\"\n\t  fi\n\tfi\n      fi\n      if test \"X$MZSCHEME_LIBS\" != \"X\"; then\n\tbreak\n      fi\n    done\n\n    AC_MSG_CHECKING([if racket requires -pthread])\n    if test \"X$SCHEME_LIB\" != \"X\" && $FGREP -e -pthread \"$SCHEME_LIB/buildinfo\" >/dev/null ; then\n      AC_MSG_RESULT(yes)\n      MZSCHEME_LIBS=\"${MZSCHEME_LIBS} -pthread\"\n      MZSCHEME_CFLAGS=\"${MZSCHEME_CFLAGS} -pthread\"\n    else\n      AC_MSG_RESULT(no)\n    fi\n\n    AC_MSG_CHECKING(for racket config directory)\n    SCHEME_CONFIGDIR=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-config-dir))) (when (path? p) (display p)))'`\n    if test \"X$SCHEME_CONFIGDIR\" != \"X\"; then\n      MZSCHEME_CFLAGS=\"${MZSCHEME_CFLAGS} -DMZSCHEME_CONFIGDIR='\\\"${SCHEME_CONFIGDIR}\\\"'\"\n      AC_MSG_RESULT(${SCHEME_CONFIGDIR})\n    else\n      AC_MSG_RESULT(not found)\n    fi\n\n    AC_MSG_CHECKING(for racket collects directory)\n    SCHEME_COLLECTS=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-collects-dir))) (when (path? p) (let-values (((base _1 _2) (split-path p))) (display base))))'`\n    if test \"X$SCHEME_COLLECTS\" = \"X\"; then\n      if test -d \"$vi_cv_path_mzscheme_pfx/lib/plt/collects\"; then\n\tSCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/lib/plt/\n      else\n\tif test -d \"$vi_cv_path_mzscheme_pfx/lib/racket/collects\"; then\n\t  SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/lib/racket/\n\telse\n\t  if test -d \"$vi_cv_path_mzscheme_pfx/share/racket/collects\"; then\n\t    SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/share/racket/\n\t  else\n\t    if test -d \"$vi_cv_path_mzscheme_pfx/collects\"; then\n\t      SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/\n\t    fi\n\t  fi\n\tfi\n      fi\n    fi\n    if test \"X$SCHEME_COLLECTS\" != \"X\" ; then\n      AC_MSG_RESULT(${SCHEME_COLLECTS})\n    else\n      AC_MSG_RESULT(not found)\n    fi\n\n    AC_MSG_CHECKING(for mzscheme_base.c)\n    if test -f \"${SCHEME_COLLECTS}collects/scheme/base.ss\" ; then\n      MZSCHEME_EXTRA=\"mzscheme_base.c\"\n      MZSCHEME_MZC=\"${vi_cv_path_mzscheme_pfx}/bin/mzc\"\n      MZSCHEME_MOD=\"++lib scheme/base\"\n    else\n      if test -f \"${SCHEME_COLLECTS}collects/scheme/base.rkt\" ; then\n\tMZSCHEME_EXTRA=\"mzscheme_base.c\"\n\tMZSCHEME_MZC=\"${vi_cv_path_mzscheme_pfx}/bin/mzc\"\n\tMZSCHEME_MOD=\"++lib scheme/base\"\n      else\n\tif test -f \"${SCHEME_COLLECTS}collects/racket/base.rkt\" ; then\n\t  MZSCHEME_EXTRA=\"mzscheme_base.c\"\n\t  MZSCHEME_MZC=\"${vi_cv_path_mzscheme_pfx}/bin/raco ctool\"\n\t  MZSCHEME_MOD=\"\"\n\tfi\n      fi\n    fi\n    if test \"X$MZSCHEME_EXTRA\" != \"X\" ; then\n      dnl need to generate bytecode for MzScheme base\n      MZSCHEME_CFLAGS=\"${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE\"\n      AC_MSG_RESULT(needed)\n    else\n      AC_MSG_RESULT(not needed)\n    fi\n\n    dnl On Ubuntu this fixes \"undefined reference to symbol 'ffi_type_void'\".\n    AC_CHECK_LIB(ffi, ffi_type_void, [MZSCHEME_LIBS=\"$MZSCHEME_LIBS -lffi\"])\n\n    MZSCHEME_CFLAGS=\"${MZSCHEME_CFLAGS} -I${SCHEME_INC} \\\n      -DMZSCHEME_COLLECTS='\\\"${SCHEME_COLLECTS}collects\\\"'\"\n\n    dnl Test that we can compile a simple program with these CFLAGS and LIBS.\n    AC_MSG_CHECKING([if compile and link flags for MzScheme are sane])\n    cflags_save=$CFLAGS\n    libs_save=$LIBS\n    CFLAGS=\"$CFLAGS $MZSCHEME_CFLAGS\"\n    LIBS=\"$LIBS $MZSCHEME_LIBS\"\n    AC_TRY_LINK(,[ ],\n\t   AC_MSG_RESULT(yes); mzs_ok=yes,\n\t   AC_MSG_RESULT(no: MZSCHEME DISABLED); mzs_ok=no)\n    CFLAGS=$cflags_save\n    LIBS=$libs_save\n    if test $mzs_ok = yes; then\n      MZSCHEME_SRC=\"if_mzsch.c\"\n      MZSCHEME_OBJ=\"objects/if_mzsch.o\"\n      MZSCHEME_PRO=\"if_mzsch.pro\"\n      AC_DEFINE(FEAT_MZSCHEME)\n    else\n      MZSCHEME_CFLAGS=\n      MZSCHEME_LIBS=\n      MZSCHEME_EXTRA=\n      MZSCHEME_MZC=\n    fi\n  fi\n  AC_SUBST(MZSCHEME_SRC)\n  AC_SUBST(MZSCHEME_OBJ)\n  AC_SUBST(MZSCHEME_PRO)\n  AC_SUBST(MZSCHEME_LIBS)\n  AC_SUBST(MZSCHEME_CFLAGS)\n  AC_SUBST(MZSCHEME_EXTRA)\n  AC_SUBST(MZSCHEME_MZC)\nfi\n\n\nAC_MSG_CHECKING(--enable-perlinterp argument)\nAC_ARG_ENABLE(perlinterp,\n\t[  --enable-perlinterp[=OPTS]     Include Perl interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,\n\t[enable_perlinterp=\"no\"])\nAC_MSG_RESULT($enable_perlinterp)\nif test \"$enable_perlinterp\" = \"yes\" -o \"$enable_perlinterp\" = \"dynamic\"; then\n  if test \"x$features\" = \"xtiny\" -o \"x$features\" = \"xsmall\"; then\n    AC_MSG_ERROR([cannot use Perl with tiny or small features])\n  fi\n  AC_SUBST(vi_cv_path_perl)\n  AC_PATH_PROG(vi_cv_path_perl, perl)\n  if test \"X$vi_cv_path_perl\" != \"X\"; then\n    AC_MSG_CHECKING(Perl version)\n    if $vi_cv_path_perl -e 'require 5.003_01' >/dev/null 2>/dev/null; then\n     eval `$vi_cv_path_perl -V:usethreads`\n     eval `$vi_cv_path_perl -V:libperl`\n     if test \"X$usethreads\" = \"XUNKNOWN\" -o \"X$usethreads\" = \"Xundef\"; then\n       badthreads=no\n     else\n       if $vi_cv_path_perl -e 'require 5.6.0' >/dev/null 2>/dev/null; then\n\t eval `$vi_cv_path_perl -V:use5005threads`\n\t if test \"X$use5005threads\" = \"XUNKNOWN\" -o \"X$use5005threads\" = \"Xundef\"; then\n\t   badthreads=no\n\t else\n\t   badthreads=yes\n\t   AC_MSG_RESULT(>>> Perl > 5.6 with 5.5 threads cannot be used <<<)\n\t fi\n       else\n\t badthreads=yes\n\t AC_MSG_RESULT(>>> Perl 5.5 with threads cannot be used <<<)\n       fi\n     fi\n     if test $badthreads = no; then\n      AC_MSG_RESULT(OK)\n      eval `$vi_cv_path_perl -V:shrpenv`\n      if test \"X$shrpenv\" = \"XUNKNOWN\"; then # pre 5.003_04\n\tshrpenv=\"\"\n      fi\n      vi_cv_perllib=`$vi_cv_path_perl -MConfig -e 'print $Config{privlibexp}'`\n      AC_SUBST(vi_cv_perllib)\n      vi_cv_perl_extutils=unknown_perl_extutils_path\n      for extutils_rel_path in ExtUtils vendor_perl/ExtUtils; do\n\txsubpp_path=\"$vi_cv_perllib/$extutils_rel_path/xsubpp\"\n\tif test -f \"$xsubpp_path\"; then\n\t  vi_cv_perl_xsubpp=\"$xsubpp_path\"\n\tfi\n      done\n      AC_SUBST(vi_cv_perl_xsubpp)\n      dnl Remove \"-fno-something\", it breaks using cproto.\n      dnl Remove \"-fdebug-prefix-map\", it isn't supported by clang.\n      perlcppflags=`$vi_cv_path_perl -Mlib=$srcdir -MExtUtils::Embed \\\n\t      -e 'ccflags;perl_inc;print\"\\n\"' | sed -e 's/-fno[[^ ]]*//' \\\n\t\t\t-e 's/-fdebug-prefix-map[[^ ]]*//g'`\n      dnl Remove \"-lc\", it breaks on FreeBSD when using \"-pthread\".\n      perllibs=`cd $srcdir; $vi_cv_path_perl -MExtUtils::Embed -e 'ldopts' | \\\n\t\tsed -e '/Warning/d' -e '/Note (probably harmless)/d' \\\n\t\t\t-e 's/-bE:perl.exp//' -e 's/-lc //'`\n      dnl Don't add perl lib to $LIBS: if it's not in LD_LIBRARY_PATH\n      dnl a test in configure may fail because of that.\n      perlldflags=`cd $srcdir; $vi_cv_path_perl -MExtUtils::Embed \\\n\t\t-e 'ccdlflags' | sed -e 's/-bE:perl.exp//'`\n\n      dnl check that compiling a simple program still works with the flags\n      dnl added for Perl.\n      AC_MSG_CHECKING([if compile and link flags for Perl are sane])\n      cflags_save=$CFLAGS\n      libs_save=$LIBS\n      ldflags_save=$LDFLAGS\n      CFLAGS=\"$CFLAGS $perlcppflags\"\n      LIBS=\"$LIBS $perllibs\"\n      perlldflags=`echo \"$perlldflags\" | sed -e 's/^ *//g'`\n      LDFLAGS=\"$perlldflags $LDFLAGS\"\n      AC_TRY_LINK(,[ ],\n\t     AC_MSG_RESULT(yes); perl_ok=yes,\n\t     AC_MSG_RESULT(no: PERL DISABLED); perl_ok=no)\n      CFLAGS=$cflags_save\n      LIBS=$libs_save\n      LDFLAGS=$ldflags_save\n      if test $perl_ok = yes; then\n\tif test \"X$perlcppflags\" != \"X\"; then\n\t  dnl remove -pipe and -Wxxx, it confuses cproto\n\t  PERL_CFLAGS=`echo \"$perlcppflags\" | sed -e 's/-pipe //' -e 's/-W[[^ ]]*//'`\n\tfi\n\tif test \"X$perlldflags\" != \"X\"; then\n\t  if test \"X`echo \\\"$LDFLAGS\\\" | $FGREP -e \\\"$perlldflags\\\"`\" = \"X\"; then\n\t    LDFLAGS=\"$perlldflags $LDFLAGS\"\n\t  fi\n\tfi\n\tPERL_LIBS=$perllibs\n\tPERL_SRC=\"auto/if_perl.c if_perlsfio.c\"\n\tPERL_OBJ=\"objects/if_perl.o objects/if_perlsfio.o\"\n\tPERL_PRO=\"if_perl.pro if_perlsfio.pro\"\n\tAC_DEFINE(FEAT_PERL)\n      fi\n     fi\n    else\n      AC_MSG_RESULT(>>> too old; need Perl version 5.003_01 or later <<<)\n    fi\n  fi\n\n  if test \"x$MACOSX\" = \"xyes\"; then\n    dnl Mac OS X 10.2 or later\n    dir=/System/Library/Perl\n    darwindir=$dir/darwin\n    if test -d $darwindir; then\n      PERL=/usr/bin/perl\n    else\n      dnl Mac OS X 10.3\n      dir=/System/Library/Perl/5.8.1\n      darwindir=$dir/darwin-thread-multi-2level\n      if test -d $darwindir; then\n\tPERL=/usr/bin/perl\n      fi\n    fi\n    if test -n \"$PERL\"; then\n      PERL_DIR=\"$dir\"\n      PERL_CFLAGS=\"-DFEAT_PERL -I$darwindir/CORE\"\n      PERL_OBJ=\"objects/if_perl.o objects/if_perlsfio.o $darwindir/auto/DynaLoader/DynaLoader.a\"\n      PERL_LIBS=\"-L$darwindir/CORE -lperl\"\n    fi\n    dnl Perl on Mac OS X 10.5 adds \"-arch\" flags but these should only\n    dnl be included if requested by passing --with-mac-arch to\n    dnl configure, so strip these flags first (if present)\n    PERL_LIBS=`echo \"$PERL_LIBS\" | sed -e 's/-arch\\ ppc//' -e 's/-arch\\ i386//' -e 's/-arch\\ x86_64//'`\n    PERL_CFLAGS=`echo \"$PERL_CFLAGS\" | sed -e 's/-arch\\ ppc//' -e 's/-arch\\ i386//' -e 's/-arch\\ x86_64//'`\n  fi\n  if test \"$enable_perlinterp\" = \"dynamic\"; then\n    if test \"$perl_ok\" = \"yes\" -a \"X$libperl\" != \"X\"; then\n      AC_DEFINE(DYNAMIC_PERL)\n      PERL_CFLAGS=\"-DDYNAMIC_PERL_DLL=\\\\\\\"$libperl\\\\\\\" $PERL_CFLAGS\"\n    fi\n  fi\n\n  if test \"$fail_if_missing\" = \"yes\" -a \"$perl_ok\" != \"yes\"; then\n    AC_MSG_ERROR([could not configure perl])\n  fi\nfi\nAC_SUBST(shrpenv)\nAC_SUBST(PERL_SRC)\nAC_SUBST(PERL_OBJ)\nAC_SUBST(PERL_PRO)\nAC_SUBST(PERL_CFLAGS)\nAC_SUBST(PERL_LIBS)\n\nAC_MSG_CHECKING(--enable-pythoninterp argument)\nAC_ARG_ENABLE(pythoninterp,\n\t[  --enable-pythoninterp[=OPTS]   Include Python interpreter. [default=no] [OPTS=no/yes/dynamic]], ,\n\t[enable_pythoninterp=\"no\"])\nAC_MSG_RESULT($enable_pythoninterp)\nif test \"$enable_pythoninterp\" = \"yes\" -o \"$enable_pythoninterp\" = \"dynamic\"; then\n  if test \"x$features\" = \"xtiny\" -o \"x$features\" = \"xsmall\"; then\n    AC_MSG_ERROR([cannot use Python with tiny or small features])\n  fi\n\n  dnl -- find the python executable\n  AC_PATH_PROGS(vi_cv_path_python, python2 python)\n  if test \"X$vi_cv_path_python\" != \"X\"; then\n\n    dnl -- get its version number\n    AC_CACHE_CHECK(Python version,vi_cv_var_python_version,\n    [[vi_cv_var_python_version=`\n\t    ${vi_cv_path_python} -c 'import sys; print sys.version[:3]'`\n    ]])\n\n    dnl -- it must be at least version 2.3\n    AC_MSG_CHECKING(Python is 2.3 or better)\n    if ${vi_cv_path_python} -c \\\n\t\"import sys; sys.exit(${vi_cv_var_python_version} < 2.3)\"\n    then\n      AC_MSG_RESULT(yep)\n\n      dnl -- find where python thinks it was installed\n      AC_CACHE_CHECK(Python's install prefix,vi_cv_path_python_pfx,\n      [ vi_cv_path_python_pfx=`\n\t    ${vi_cv_path_python} -c \\\n\t\t\"import sys; print sys.prefix\"` ])\n\n      dnl -- and where it thinks it runs\n      AC_CACHE_CHECK(Python's execution prefix,vi_cv_path_python_epfx,\n      [ vi_cv_path_python_epfx=`\n\t    ${vi_cv_path_python} -c \\\n\t\t\"import sys; print sys.exec_prefix\"` ])\n\n      dnl -- python's internal library path\n\n      AC_CACHE_VAL(vi_cv_path_pythonpath,\n      [ vi_cv_path_pythonpath=`\n\t    unset PYTHONPATH;\n\t    ${vi_cv_path_python} -c \\\n\t\t\"import sys, string; print string.join(sys.path,':')\"` ])\n\n      dnl -- where the Python implementation library archives are\n\n      AC_ARG_WITH(python-config-dir,\n\t[  --with-python-config-dir=PATH  Python's config directory],\n\t[ vi_cv_path_python_conf=\"${withval}\" ] )\n\n      AC_CACHE_CHECK(Python's configuration directory,vi_cv_path_python_conf,\n      [\n\tvi_cv_path_python_conf=\n\td=`${vi_cv_path_python} -c \"import distutils.sysconfig; print distutils.sysconfig.get_config_var('LIBPL')\"`\n\tif test -d \"$d\" && test -f \"$d/config.c\"; then\n\t  vi_cv_path_python_conf=\"$d\"\n\telse\n\t  for path in \"${vi_cv_path_python_pfx}\" \"${vi_cv_path_python_epfx}\"; do\n\t    for subdir in lib64 lib share; do\n\t      d=\"${path}/${subdir}/python${vi_cv_var_python_version}/config\"\n\t      if test -d \"$d\" && test -f \"$d/config.c\"; then\n\t\tvi_cv_path_python_conf=\"$d\"\n\t      fi\n\t    done\n\t  done\n\tfi\n      ])\n\n      PYTHON_CONFDIR=\"${vi_cv_path_python_conf}\"\n\n      if test \"X$PYTHON_CONFDIR\" = \"X\"; then\n\tAC_MSG_RESULT([can't find it!])\n      else\n\n\tdnl -- we need to examine Python's config/Makefile too\n\tdnl    see what the interpreter is built from\n\tAC_CACHE_VAL(vi_cv_path_python_plibs,\n\t[\n\t    pwd=`pwd`\n\t    tmp_mkf=\"$pwd/config-PyMake$$\"\n\t    cat -- \"${PYTHON_CONFDIR}/Makefile\" - <<'eof' >\"${tmp_mkf}\"\n__:\n\t@echo \"python_BASEMODLIBS='$(BASEMODLIBS)'\"\n\t@echo \"python_LIBS='$(LIBS)'\"\n\t@echo \"python_SYSLIBS='$(SYSLIBS)'\"\n\t@echo \"python_LINKFORSHARED='$(LINKFORSHARED)'\"\n\t@echo \"python_DLLLIBRARY='$(DLLLIBRARY)'\"\n\t@echo \"python_INSTSONAME='$(INSTSONAME)'\"\n\t@echo \"python_PYTHONFRAMEWORK='$(PYTHONFRAMEWORK)'\"\n\t@echo \"python_PYTHONFRAMEWORKPREFIX='$(PYTHONFRAMEWORKPREFIX)'\"\n\t@echo \"python_PYTHONFRAMEWORKINSTALLDIR='$(PYTHONFRAMEWORKINSTALLDIR)'\"\neof\n\t    dnl -- delete the lines from make about Entering/Leaving directory\n\t    eval \"`cd ${PYTHON_CONFDIR} && make -f \"${tmp_mkf}\" __ | sed '/ directory /d'`\"\n\t    rm -f -- \"${tmp_mkf}\"\n\t    if test \"x$MACOSX\" = \"xyes\" && test -n \"${python_PYTHONFRAMEWORK}\" && ${vi_cv_path_python} -c \\\n\t\t\"import sys; sys.exit(${vi_cv_var_python_version} < 2.3)\"; then\n\t      vi_cv_path_python_plibs=\"-framework Python\"\n\t      if test \"x${vi_cv_path_python}\" != \"x/usr/bin/python\" && test -n \"${python_PYTHONFRAMEWORKPREFIX}\"; then\n\t\t  vi_cv_path_python_plibs=\"-F${python_PYTHONFRAMEWORKPREFIX} -framework Python\"\n\t      fi\n\t    else\n\t      if test \"${vi_cv_var_python_version}\" = \"1.4\"; then\n\t\t  vi_cv_path_python_plibs=\"${PYTHON_CONFDIR}/libModules.a ${PYTHON_CONFDIR}/libPython.a ${PYTHON_CONFDIR}/libObjects.a ${PYTHON_CONFDIR}/libParser.a\"\n\t      else\n\t\t  vi_cv_path_python_plibs=\"-L${PYTHON_CONFDIR} -lpython${vi_cv_var_python_version}\"\n\t      fi\n\t      dnl -- Check if the path contained in python_LINKFORSHARED is\n\t      dnl    usable for vim build. If not, make and try other\n\t      dnl    candidates.\n\t      if test -n \"${python_LINKFORSHARED}\" && test -n \"${python_PYTHONFRAMEWORKPREFIX}\"; then\n\t        python_link_symbol=`echo ${python_LINKFORSHARED} | sed 's/\\([[^ \\t]][[^ \\t]]*[[ \\t]][[ \\t]]*[[^ \\t]][[^ \\t]]*\\)[[ \\t]].*/\\1/'`\n\t\tpython_link_path=`echo ${python_LINKFORSHARED} |   sed 's/\\([[^ \\t]][[^ \\t]]*[[ \\t]][[ \\t]]*[[^ \\t]][[^ \\t]]*\\)[[ \\t]][[ \\t]]*\\(.*\\)/\\2/'`\n\t        if test -n \"${python_link_path}\" && ! test -x \"${python_link_path}\"; then\n\t          dnl -- The path looks relative. Guess the absolute one using\n\t\t  dnl    the prefix and try that.\n\t          python_link_path=\"${python_PYTHONFRAMEWORKPREFIX}/${python_link_path}\"\n\t\t  if test -n \"${python_link_path}\" && ! test -x \"${python_link_path}\"; then\n\t\t    dnl -- A last resort.\n\t\t    python_link_path=\"${python_PYTHONFRAMEWORKINSTALLDIR}/Versions/${vi_cv_var_python_version}/${python_PYTHONFRAMEWORK}\"\n\t            dnl -- No check is done. The last word is left to the\n\t            dnl    \"sanity\" test on link flags that follows shortly.\n\t\t  fi\n\t          python_LINKFORSHARED=\"${python_link_symbol} ${python_link_path}\"\n\t        fi\n\t      fi\n\t      vi_cv_path_python_plibs=\"${vi_cv_path_python_plibs} ${python_BASEMODLIBS} ${python_LIBS} ${python_SYSLIBS} ${python_LINKFORSHARED}\"\n\t      dnl remove -ltermcap, it can conflict with an earlier -lncurses\n\t      vi_cv_path_python_plibs=`echo $vi_cv_path_python_plibs | sed s/-ltermcap//`\n\t    fi\n\t])\n\tAC_CACHE_CHECK(Python's dll name,vi_cv_dll_name_python,\n\t[\n\t  if test \"X$python_DLLLIBRARY\" != \"X\"; then\n\t    vi_cv_dll_name_python=\"$python_DLLLIBRARY\"\n\t  else\n\t    vi_cv_dll_name_python=\"$python_INSTSONAME\"\n\t  fi\n\t])\n\n\tPYTHON_LIBS=\"${vi_cv_path_python_plibs}\"\n\tif test \"${vi_cv_path_python_pfx}\" = \"${vi_cv_path_python_epfx}\"; then\n\t  PYTHON_CFLAGS=\"-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME='\\\"${vi_cv_path_python_pfx}\\\"'\"\n\telse\n\t  PYTHON_CFLAGS=\"-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -I${vi_cv_path_python_epfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME='\\\"${vi_cv_path_python_pfx}\\\"'\"\n\tfi\n\tPYTHON_SRC=\"if_python.c\"\n\tPYTHON_OBJ=\"objects/if_python.o\"\n\tif test \"${vi_cv_var_python_version}\" = \"1.4\"; then\n\t   PYTHON_OBJ=\"$PYTHON_OBJ objects/py_getpath.o\"\n\tfi\n    PYTHON_GETPATH_CFLAGS=\"-DPYTHONPATH='\\\"${vi_cv_path_pythonpath}\\\"' -DPREFIX='\\\"${vi_cv_path_python_pfx}\\\"' -DEXEC_PREFIX='\\\"${vi_cv_path_python_epfx}\\\"'\"\n\n\tdnl On FreeBSD linking with \"-pthread\" is required to use threads.\n\tdnl _THREAD_SAFE must be used for compiling then.\n\tdnl The \"-pthread\" is added to $LIBS, so that the following check for\n\tdnl sigaltstack() will look in libc_r (it's there in libc!).\n\tdnl Otherwise, when using GCC, try adding -pthread to $CFLAGS.  GCC\n\tdnl will then define target-specific defines, e.g., -D_REENTRANT.\n\tdnl Don't do this for Mac OSX, -pthread will generate a warning.\n\tAC_MSG_CHECKING([if -pthread should be used])\n\tthreadsafe_flag=\n\tthread_lib=\n\tdnl if test \"x$MACOSX\" != \"xyes\"; then\n        if test \"`(uname) 2>/dev/null`\" != Darwin; then\n\t  test \"$GCC\" = yes && threadsafe_flag=\"-pthread\"\n\t  if test \"`(uname) 2>/dev/null`\" = FreeBSD; then\n\t    threadsafe_flag=\"-D_THREAD_SAFE\"\n\t    thread_lib=\"-pthread\"\n\t  fi\n\t  if test \"`(uname) 2>/dev/null`\" = SunOS; then\n\t    threadsafe_flag=\"-pthreads\"\n\t  fi\n\tfi\n\tlibs_save_old=$LIBS\n\tif test -n \"$threadsafe_flag\"; then\n\t  cflags_save=$CFLAGS\n\t  CFLAGS=\"$CFLAGS $threadsafe_flag\"\n\t  LIBS=\"$LIBS $thread_lib\"\n\t  AC_TRY_LINK(,[ ],\n\t     AC_MSG_RESULT(yes); PYTHON_CFLAGS=\"$PYTHON_CFLAGS $threadsafe_flag\",\n\t     AC_MSG_RESULT(no); LIBS=$libs_save_old\n\t     )\n\t  CFLAGS=$cflags_save\n\telse\n\t  AC_MSG_RESULT(no)\n\tfi\n\n\tdnl Check that compiling a simple program still works with the flags\n\tdnl added for Python.\n\tAC_MSG_CHECKING([if compile and link flags for Python are sane])\n\tcflags_save=$CFLAGS\n\tlibs_save=$LIBS\n\tCFLAGS=\"$CFLAGS $PYTHON_CFLAGS\"\n\tLIBS=\"$LIBS $PYTHON_LIBS\"\n\tAC_TRY_LINK(,[ ],\n\t       AC_MSG_RESULT(yes); python_ok=yes,\n\t       AC_MSG_RESULT(no: PYTHON DISABLED); python_ok=no)\n\tCFLAGS=$cflags_save\n\tLIBS=$libs_save\n\tif test $python_ok = yes; then\n\t  AC_DEFINE(FEAT_PYTHON)\n\telse\n\t  LIBS=$libs_save_old\n\t  PYTHON_SRC=\n\t  PYTHON_OBJ=\n\t  PYTHON_LIBS=\n\t  PYTHON_CFLAGS=\n\tfi\n      fi\n    else\n      AC_MSG_RESULT(too old)\n    fi\n  fi\n\n  if test \"$fail_if_missing\" = \"yes\" -a \"$python_ok\" != \"yes\"; then\n    AC_MSG_ERROR([could not configure python])\n  fi\nfi\n\nAC_SUBST(PYTHON_CONFDIR)\nAC_SUBST(PYTHON_LIBS)\nAC_SUBST(PYTHON_GETPATH_CFLAGS)\nAC_SUBST(PYTHON_CFLAGS)\nAC_SUBST(PYTHON_SRC)\nAC_SUBST(PYTHON_OBJ)\n\n\nAC_MSG_CHECKING(--enable-python3interp argument)\nAC_ARG_ENABLE(python3interp,\n\t[  --enable-python3interp[=OPTS]   Include Python3 interpreter. [default=no] [OPTS=no/yes/dynamic]], ,\n\t[enable_python3interp=\"no\"])\nAC_MSG_RESULT($enable_python3interp)\nif test \"$enable_python3interp\" = \"yes\" -o \"$enable_python3interp\" = \"dynamic\"; then\n  if test \"x$features\" = \"xtiny\" -o \"x$features\" = \"xsmall\"; then\n    AC_MSG_ERROR([cannot use Python with tiny or small features])\n  fi\n\n  dnl -- find the python3 executable\n  AC_PATH_PROGS(vi_cv_path_python3, python3 python)\n  if test \"X$vi_cv_path_python3\" != \"X\"; then\n\n    dnl -- get its version number\n    AC_CACHE_CHECK(Python version,vi_cv_var_python3_version,\n    [[vi_cv_var_python3_version=`\n          ${vi_cv_path_python3} -c 'import sys; print(sys.version[:3])'`\n    ]])\n\n    dnl -- it must be at least version 3\n    AC_MSG_CHECKING(Python is 3.0 or better)\n    if ${vi_cv_path_python3} -c \\\n      \"import sys; sys.exit(${vi_cv_var_python3_version} < 3.0)\"\n    then\n      AC_MSG_RESULT(yep)\n\n      dnl -- get abiflags for python 3.2 or higher (PEP 3149)\n      AC_CACHE_CHECK(Python's abiflags,vi_cv_var_python3_abiflags,\n      [\n       vi_cv_var_python3_abiflags=\n       if ${vi_cv_path_python3} -c \\\n           \"import sys; sys.exit(${vi_cv_var_python3_version} < 3.2)\"\n       then\n         vi_cv_var_python3_abiflags=`${vi_cv_path_python3} -c \\    \n           \"import sys; print(sys.abiflags)\"`\n       fi ])\n  \n      dnl -- find where python3 thinks it was installed\n      AC_CACHE_CHECK(Python's install prefix,vi_cv_path_python3_pfx,\n      [ vi_cv_path_python3_pfx=`\n       ${vi_cv_path_python3} -c \\\n       \"import sys; print(sys.prefix)\"` ])\n  \n      dnl -- and where it thinks it runs\n      AC_CACHE_CHECK(Python's execution prefix,vi_cv_path_python3_epfx,\n      [ vi_cv_path_python3_epfx=`\n       ${vi_cv_path_python3} -c \\\n       \"import sys; print(sys.exec_prefix)\"` ])\n  \n      dnl -- python3's internal library path\n  \n      AC_CACHE_VAL(vi_cv_path_python3path,\n      [ vi_cv_path_python3path=`\n       unset PYTHONPATH;\n       ${vi_cv_path_python3} -c \\\n       \"import sys, string; print(':'.join(sys.path))\"` ])\n  \n      dnl -- where the Python implementation library archives are\n  \n      AC_ARG_WITH(python3-config-dir,\n       [  --with-python3-config-dir=PATH  Python's config directory],\n       [ vi_cv_path_python3_conf=\"${withval}\" ] )\n  \n      AC_CACHE_CHECK(Python's configuration directory,vi_cv_path_python3_conf,\n      [\n       vi_cv_path_python3_conf=\n       config_dir=\"config-${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}\"\n       d=`${vi_cv_path_python3} -c \"import distutils.sysconfig; print(distutils.sysconfig.get_config_var('LIBPL'))\"`\n       if test -d \"$d\" && test -f \"$d/config.c\"; then\n         vi_cv_path_python3_conf=\"$d\"\n       else\n         for path in \"${vi_cv_path_python3_pfx}\" \"${vi_cv_path_python3_epfx}\"; do\n\t   for subdir in lib64 lib share; do\n\t     d=\"${path}/${subdir}/python${vi_cv_var_python3_version}/${config_dir}\"\n\t     if test -d \"$d\" && test -f \"$d/config.c\"; then\n\t       vi_cv_path_python3_conf=\"$d\"\n\t     fi\n\t   done\n         done\n       fi\n      ])\n  \n      PYTHON3_CONFDIR=\"${vi_cv_path_python3_conf}\"\n  \n      if test \"X$PYTHON3_CONFDIR\" = \"X\"; then\n        AC_MSG_RESULT([can't find it!])\n      else\n  \n        dnl -- we need to examine Python's config/Makefile too\n        dnl    see what the interpreter is built from\n        AC_CACHE_VAL(vi_cv_path_python3_plibs,\n        [\n            pwd=`pwd`\n            tmp_mkf=\"$pwd/config-PyMake$$\"\n            cat -- \"${PYTHON3_CONFDIR}/Makefile\" - <<'eof' >\"${tmp_mkf}\"\n__:\n\t@echo \"python3_BASEMODLIBS='$(BASEMODLIBS)'\"\n\t@echo \"python3_LIBS='$(LIBS)'\"\n\t@echo \"python3_SYSLIBS='$(SYSLIBS)'\"\n\t@echo \"python3_DLLLIBRARY='$(DLLLIBRARY)'\"\n\t@echo \"python3_INSTSONAME='$(INSTSONAME)'\"\neof\n\t    dnl -- delete the lines from make about Entering/Leaving directory\n\t    eval \"`cd ${PYTHON3_CONFDIR} && make -f \"${tmp_mkf}\" __ | sed '/ directory /d'`\"\n\t    rm -f -- \"${tmp_mkf}\"\n\t    vi_cv_path_python3_plibs=\"-L${PYTHON3_CONFDIR} -lpython${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}\"\n\t    vi_cv_path_python3_plibs=\"${vi_cv_path_python3_plibs} ${python3_BASEMODLIBS} ${python3_LIBS} ${python3_SYSLIBS}\"\n\t    dnl remove -ltermcap, it can conflict with an earlier -lncurses\n\t    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-ltermcap//`\n\t    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-lffi//`\n\t])\n\tAC_CACHE_CHECK(Python3's dll name,vi_cv_dll_name_python3,\n\t[\n\t  if test \"X$python3_DLLLIBRARY\" != \"X\"; then\n\t    vi_cv_dll_name_python3=\"$python3_DLLLIBRARY\"\n\t  else\n\t    vi_cv_dll_name_python3=\"$python3_INSTSONAME\"\n\t  fi\n\t])\n\n        PYTHON3_LIBS=\"${vi_cv_path_python3_plibs}\"\n        if test \"${vi_cv_path_python3_pfx}\" = \"${vi_cv_path_python3_epfx}\"; then\n          PYTHON3_CFLAGS=\"-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -DPYTHON3_HOME='L\\\"${vi_cv_path_python3_pfx}\\\"'\"\n        else\n          PYTHON3_CFLAGS=\"-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -I${vi_cv_path_python3_epfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -DPYTHON3_HOME='L\\\"${vi_cv_path_python3_pfx}\\\"'\"\n        fi\n        PYTHON3_SRC=\"if_python3.c\"\n        PYTHON3_OBJ=\"objects/if_python3.o\"\n  \n        dnl On FreeBSD linking with \"-pthread\" is required to use threads.\n        dnl _THREAD_SAFE must be used for compiling then.\n        dnl The \"-pthread\" is added to $LIBS, so that the following check for\n        dnl sigaltstack() will look in libc_r (it's there in libc!).\n        dnl Otherwise, when using GCC, try adding -pthread to $CFLAGS.  GCC\n        dnl will then define target-specific defines, e.g., -D_REENTRANT.\n        dnl Don't do this for Mac OSX, -pthread will generate a warning.\n        AC_MSG_CHECKING([if -pthread should be used])\n        threadsafe_flag=\n        thread_lib=\n        dnl if test \"x$MACOSX\" != \"xyes\"; then\n        if test \"`(uname) 2>/dev/null`\" != Darwin; then\n          test \"$GCC\" = yes && threadsafe_flag=\"-pthread\"\n          if test \"`(uname) 2>/dev/null`\" = FreeBSD; then\n            threadsafe_flag=\"-D_THREAD_SAFE\"\n            thread_lib=\"-pthread\"\n          fi\n          if test \"`(uname) 2>/dev/null`\" = SunOS; then\n            threadsafe_flag=\"-pthreads\"\n          fi\n        fi\n        libs_save_old=$LIBS\n        if test -n \"$threadsafe_flag\"; then\n          cflags_save=$CFLAGS\n          CFLAGS=\"$CFLAGS $threadsafe_flag\"\n          LIBS=\"$LIBS $thread_lib\"\n          AC_TRY_LINK(,[ ],\n             AC_MSG_RESULT(yes); PYTHON3_CFLAGS=\"$PYTHON3_CFLAGS $threadsafe_flag\",\n             AC_MSG_RESULT(no); LIBS=$libs_save_old\n             )\n          CFLAGS=$cflags_save\n        else\n          AC_MSG_RESULT(no)\n        fi\n  \n        dnl check that compiling a simple program still works with the flags\n        dnl added for Python.\n        AC_MSG_CHECKING([if compile and link flags for Python 3 are sane])\n        cflags_save=$CFLAGS\n        libs_save=$LIBS\n        CFLAGS=\"$CFLAGS $PYTHON3_CFLAGS\"\n        LIBS=\"$LIBS $PYTHON3_LIBS\"\n        AC_TRY_LINK(,[ ],\n               AC_MSG_RESULT(yes); python3_ok=yes,\n               AC_MSG_RESULT(no: PYTHON3 DISABLED); python3_ok=no)\n        CFLAGS=$cflags_save\n        LIBS=$libs_save\n        if test \"$python3_ok\" = yes; then\n          AC_DEFINE(FEAT_PYTHON3)\n        else\n          LIBS=$libs_save_old\n          PYTHON3_SRC=\n          PYTHON3_OBJ=\n          PYTHON3_LIBS=\n          PYTHON3_CFLAGS=\n        fi\n      fi\n    else\n      AC_MSG_RESULT(too old)\n    fi\n  fi\n  if test \"$fail_if_missing\" = \"yes\" -a \"$python3_ok\" != \"yes\"; then\n    AC_MSG_ERROR([could not configure python3])\n  fi\nfi\n\nAC_SUBST(PYTHON3_CONFDIR)\nAC_SUBST(PYTHON3_LIBS)\nAC_SUBST(PYTHON3_CFLAGS)\nAC_SUBST(PYTHON3_SRC)\nAC_SUBST(PYTHON3_OBJ)\n\ndnl if python2.x and python3.x are enabled one can only link in code\ndnl with dlopen(), dlsym(), dlclose() \nif test \"$python_ok\" = yes && test \"$python3_ok\" = yes; then\n  AC_DEFINE(DYNAMIC_PYTHON)\n  AC_DEFINE(DYNAMIC_PYTHON3)\n  AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python)\n  cflags_save=$CFLAGS\n  CFLAGS=\"$CFLAGS $PYTHON_CFLAGS\"\n  libs_save=$LIBS\n  dnl -ldl must go first to make this work on Archlinux (Roland Puntaier)\n  LIBS=\"-ldl $LIBS\"\n  AC_RUN_IFELSE([AC_LANG_SOURCE([\n    #include <dlfcn.h>\n    /* If this program fails, then RTLD_GLOBAL is needed.\n     * RTLD_GLOBAL will be used and then it is not possible to\n     * have both python versions enabled in the same vim instance.\n     * Only the first python version used will be switched on.\n     */\n\n    int no_rtl_global_needed_for(char *python_instsoname, char *prefix)\n    {\n      int needed = 0;\n      void* pylib = dlopen(python_instsoname, RTLD_LAZY|RTLD_LOCAL);\n      if (pylib != 0)\n      {\n          void (*pfx)(char *home) = dlsym(pylib, \"Py_SetPythonHome\");\n          void (*init)(void) = dlsym(pylib, \"Py_Initialize\");\n          int (*simple)(char*) = dlsym(pylib, \"PyRun_SimpleString\");\n          void (*final)(void) = dlsym(pylib, \"Py_Finalize\");\n          (*pfx)(prefix);\n          (*init)();\n          needed = (*simple)(\"import termios\") == -1;\n          (*final)();\n          dlclose(pylib);\n      }\n      return !needed;\n    }\n\n    int main(int argc, char** argv)\n    {\n      int not_needed = 0;\n      if (no_rtl_global_needed_for(\"${vi_cv_dll_name_python}\", \"${vi_cv_path_python_pfx}\"))\n            not_needed = 1;\n      return !not_needed;\n    }])],\n    [AC_MSG_RESULT(yes);AC_DEFINE(PY_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])\n\n  CFLAGS=$cflags_save\n  LIBS=$libs_save\n\n  AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python3)\n  cflags_save=$CFLAGS\n  CFLAGS=\"$CFLAGS $PYTHON3_CFLAGS\"\n  libs_save=$LIBS\n  dnl -ldl must go first to make this work on Archlinux (Roland Puntaier)\n  LIBS=\"-ldl $LIBS\"\n  AC_RUN_IFELSE([AC_LANG_SOURCE([\n    #include <dlfcn.h>\n    #include <wchar.h>\n    /* If this program fails, then RTLD_GLOBAL is needed.\n     * RTLD_GLOBAL will be used and then it is not possible to\n     * have both python versions enabled in the same vim instance.\n     * Only the first python version used will be switched on.\n     */\n\n    int no_rtl_global_needed_for(char *python_instsoname, wchar_t *prefix)\n    {\n      int needed = 0;\n      void* pylib = dlopen(python_instsoname, RTLD_LAZY|RTLD_LOCAL);\n      if (pylib != 0)\n      {\n          void (*pfx)(wchar_t *home) = dlsym(pylib, \"Py_SetPythonHome\");\n          void (*init)(void) = dlsym(pylib, \"Py_Initialize\");\n          int (*simple)(char*) = dlsym(pylib, \"PyRun_SimpleString\");\n          void (*final)(void) = dlsym(pylib, \"Py_Finalize\");\n          (*pfx)(prefix);\n          (*init)();\n          needed = (*simple)(\"import termios\") == -1;\n          (*final)();\n          dlclose(pylib);\n      }\n      return !needed;\n    }\n\n    int main(int argc, char** argv)\n    {\n      int not_needed = 0;\n      if (no_rtl_global_needed_for(\"${vi_cv_dll_name_python3}\", L\"${vi_cv_path_python3_pfx}\"))\n            not_needed = 1;\n      return !not_needed;\n    }])],\n    [AC_MSG_RESULT(yes);AC_DEFINE(PY3_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])\n\n  CFLAGS=$cflags_save\n  LIBS=$libs_save\n\n  PYTHON_SRC=\"if_python.c\"\n  PYTHON_OBJ=\"objects/if_python.o\"\n  PYTHON_CFLAGS=\"$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\\\\\"${vi_cv_dll_name_python}\\\\\\\"\"\n  PYTHON_LIBS=\n  PYTHON3_SRC=\"if_python3.c\"\n  PYTHON3_OBJ=\"objects/if_python3.o\"\n  PYTHON3_CFLAGS=\"$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\\\\\"${vi_cv_dll_name_python3}\\\\\\\"\"\n  PYTHON3_LIBS=\nelif test \"$python_ok\" = yes && test \"$enable_pythoninterp\" = \"dynamic\"; then\n  AC_DEFINE(DYNAMIC_PYTHON)\n  PYTHON_SRC=\"if_python.c\"\n  PYTHON_OBJ=\"objects/if_python.o\"\n  PYTHON_CFLAGS=\"$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\\\\\"${vi_cv_dll_name_python}\\\\\\\"\"\n  PYTHON_LIBS=\nelif test \"$python_ok\" = yes; then\n  dnl Check that adding -fPIE works.  It may be needed when using a static\n  dnl Python library.\n  AC_MSG_CHECKING([if -fPIE can be added for Python])\n  cflags_save=$CFLAGS\n  libs_save=$LIBS\n  CFLAGS=\"$CFLAGS $PYTHON_CFLAGS -fPIE\"\n  LIBS=\"$LIBS $PYTHON_LIBS\"\n  AC_TRY_LINK(,[ ],\n\t AC_MSG_RESULT(yes); fpie_ok=yes,\n\t AC_MSG_RESULT(no); fpie_ok=no)\n  CFLAGS=$cflags_save\n  LIBS=$libs_save\n  if test $fpie_ok = yes; then\n    PYTHON_CFLAGS=\"$PYTHON_CFLAGS -fPIE\"\n  fi\nelif test \"$python3_ok\" = yes && test \"$enable_python3interp\" = \"dynamic\"; then\n  AC_DEFINE(DYNAMIC_PYTHON3)\n  PYTHON3_SRC=\"if_python3.c\"\n  PYTHON3_OBJ=\"objects/if_python3.o\"\n  PYTHON3_CFLAGS=\"$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\\\\\"${vi_cv_dll_name_python3}\\\\\\\"\"\n  PYTHON3_LIBS=\nelif test \"$python3_ok\" = yes; then\n  dnl Check that adding -fPIE works.  It may be needed when using a static\n  dnl Python library.\n  AC_MSG_CHECKING([if -fPIE can be added for Python3])\n  cflags_save=$CFLAGS\n  libs_save=$LIBS\n  CFLAGS=\"$CFLAGS $PYTHON3_CFLAGS -fPIE\"\n  LIBS=\"$LIBS $PYTHON3_LIBS\"\n  AC_TRY_LINK(,[ ],\n\t AC_MSG_RESULT(yes); fpie_ok=yes,\n\t AC_MSG_RESULT(no); fpie_ok=no)\n  CFLAGS=$cflags_save\n  LIBS=$libs_save\n  if test $fpie_ok = yes; then\n    PYTHON3_CFLAGS=\"$PYTHON3_CFLAGS -fPIE\"\n  fi\nfi\n\nAC_MSG_CHECKING(--enable-tclinterp argument)\nAC_ARG_ENABLE(tclinterp,\n\t[  --enable-tclinterp[=OPTS]      Include Tcl interpreter. [default=no] [OPTS=no/yes/dynamic]], ,\n\t[enable_tclinterp=\"no\"])\nAC_MSG_RESULT($enable_tclinterp)\n\nif test \"$enable_tclinterp\" = \"yes\" -o \"$enable_tclinterp\" = \"dynamic\"; then\n\n  dnl on FreeBSD tclsh is a silly script, look for tclsh8.[5420]\n  AC_MSG_CHECKING(--with-tclsh argument)\n  AC_ARG_WITH(tclsh, [  --with-tclsh=PATH       which tclsh to use (default: tclsh8.0)],\n\ttclsh_name=\"$withval\"; AC_MSG_RESULT($tclsh_name),\n\ttclsh_name=\"tclsh8.5\"; AC_MSG_RESULT(no))\n  AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)\n  AC_SUBST(vi_cv_path_tcl)\n\n  dnl when no specific version specified, also try 8.4, 8.2 and 8.0\n  if test \"X$vi_cv_path_tcl\" = \"X\" -a $tclsh_name = \"tclsh8.5\"; then\n    tclsh_name=\"tclsh8.4\"\n    AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)\n  fi\n  if test \"X$vi_cv_path_tcl\" = \"X\" -a $tclsh_name = \"tclsh8.4\"; then\n    tclsh_name=\"tclsh8.2\"\n    AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)\n  fi\n  if test \"X$vi_cv_path_tcl\" = \"X\" -a $tclsh_name = \"tclsh8.2\"; then\n    tclsh_name=\"tclsh8.0\"\n    AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)\n  fi\n  dnl still didn't find it, try without version number\n  if test \"X$vi_cv_path_tcl\" = \"X\"; then\n    tclsh_name=\"tclsh\"\n    AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)\n  fi\n  if test \"X$vi_cv_path_tcl\" != \"X\"; then\n    AC_MSG_CHECKING(Tcl version)\n    if echo 'exit [[expr [info tclversion] < 8.0]]' | \"$vi_cv_path_tcl\" - ; then\n      tclver=`echo 'puts [[info tclversion]]' | $vi_cv_path_tcl -`\n      AC_MSG_RESULT($tclver - OK);\n      tclloc=`echo 'set l [[info library]];set i [[string last lib $l]];incr i -2;puts [[string range $l 0 $i]]' | $vi_cv_path_tcl -`\n      tcldll=`echo 'puts libtcl[[info tclversion]][[info sharedlibextension]]' | $vi_cv_path_tcl -`\n\n      AC_MSG_CHECKING(for location of Tcl include)\n      if test \"x$MACOSX\" != \"xyes\"; then\n\ttclinc=\"$tclloc/include $tclloc/include/tcl $tclloc/include/tcl$tclver /usr/local/include /usr/local/include/tcl$tclver /usr/include /usr/include/tcl$tclver\"\n      else\n\tdnl For Mac OS X 10.3, use the OS-provided framework location\n\ttclinc=\"/System/Library/Frameworks/Tcl.framework/Headers\"\n      fi\n      TCL_INC=\n      for try in $tclinc; do\n\tif test -f \"$try/tcl.h\"; then\n\t  AC_MSG_RESULT($try/tcl.h)\n\t  TCL_INC=$try\n\t  break\n\tfi\n      done\n      if test -z \"$TCL_INC\"; then\n\tAC_MSG_RESULT(<not found>)\n\tSKIP_TCL=YES\n      fi\n      if test -z \"$SKIP_TCL\"; then\n\tAC_MSG_CHECKING(for location of tclConfig.sh script)\n\tif test \"x$MACOSX\" != \"xyes\"; then\n\t  tclcnf=`echo $tclinc | sed s/include/lib/g`\n\t  tclcnf=\"$tclcnf `echo $tclinc | sed s/include/lib64/g`\"\n\telse\n\t  dnl For Mac OS X 10.3, use the OS-provided framework location\n\t  tclcnf=\"/System/Library/Frameworks/Tcl.framework\"\n\tfi\n\tfor try in $tclcnf; do\n\t  if test -f \"$try/tclConfig.sh\"; then\n\t    AC_MSG_RESULT($try/tclConfig.sh)\n\t    . \"$try/tclConfig.sh\"\n\t    dnl use eval, because tcl 8.2 includes ${TCL_DBGX}\n\t    if test \"$enable_tclinterp\" = \"dynamic\"; then\n\t      TCL_LIBS=`eval echo \"$TCL_STUB_LIB_SPEC $TCL_LIBS\"`\n\t    else\n\t      TCL_LIBS=`eval echo \"$TCL_LIB_SPEC $TCL_LIBS\"`\n\t    fi\n\t    dnl Use $TCL_DEFS for -D_THREAD_SAFE et al.  But only use the\n\t    dnl \"-D_ABC\" items.  Watch out for -DFOO=long\\ long.\n\t    TCL_DEFS=`echo $TCL_DEFS | sed -e 's/\\\\\\\\ /\\\\\\\\X/g' | tr ' ' '\\012' | sed -e '/^[[^-]]/d' -e '/^-[[^D]]/d' -e '/-D[[^_]]/d' -e 's/-D_/ -D_/' | tr '\\012' ' ' | sed -e 's/\\\\\\\\X/\\\\\\\\ /g'`\n\t    break\n\t  fi\n\tdone\n\tif test -z \"$TCL_LIBS\"; then\n\t  AC_MSG_RESULT(<not found>)\n\t  AC_MSG_CHECKING(for Tcl library by myself)\n\t  tcllib=`echo $tclinc | sed s/include/lib/g`\n\t  tcllib=\"$tcllib `echo $tclinc | sed s/include/lib64/g`\"\n\t  for ext in .so .a ; do\n\t    for ver in \"\" $tclver ; do\n\t      for try in $tcllib ; do\n\t\ttrylib=tcl$ver$ext\n\t\tif test -f \"$try/lib$trylib\" ; then\n\t\t  AC_MSG_RESULT($try/lib$trylib)\n\t\t  TCL_LIBS=\"-L\\\"$try\\\" -ltcl$ver -ldl -lm\"\n\t\t  if test \"`(uname) 2>/dev/null`\" = SunOS &&\n\t\t\t\t\t uname -r | grep '^5' >/dev/null; then\n\t\t    TCL_LIBS=\"$TCL_LIBS -R $try\"\n\t\t  fi\n\t\t  break 3\n\t\tfi\n\t      done\n\t    done\n\t  done\n\t  if test -z \"$TCL_LIBS\"; then\n\t    AC_MSG_RESULT(<not found>)\n\t    SKIP_TCL=YES\n\t  fi\n\tfi\n\tif test -z \"$SKIP_TCL\"; then\n\t  AC_DEFINE(FEAT_TCL)\n\t  TCL_SRC=if_tcl.c\n\t  TCL_OBJ=objects/if_tcl.o\n\t  TCL_PRO=if_tcl.pro\n\t  TCL_CFLAGS=\"-I$TCL_INC $TCL_DEFS\"\n\tfi\n      fi\n    else\n      AC_MSG_RESULT(too old; need Tcl version 8.0 or later)\n    fi\n  fi\n  if test \"$enable_tclinterp\" = \"dynamic\"; then\n    if test \"X$TCL_SRC\" != \"X\" -a \"X$tcldll\" != \"X\"; then\n      AC_DEFINE(DYNAMIC_TCL)\n      TCL_CFLAGS=\"-DDYNAMIC_TCL_DLL=\\\\\\\"$tcldll\\\\\\\" -DDYNAMIC_TCL_VER=\\\\\\\"$tclver\\\\\\\" $TCL_CFLAGS\"\n    fi\n  fi\n  if test \"$fail_if_missing\" = \"yes\" -a -z \"$TCL_SRC\"; then\n    AC_MSG_ERROR([could not configure Tcl])\n  fi\nfi\nAC_SUBST(TCL_SRC)\nAC_SUBST(TCL_OBJ)\nAC_SUBST(TCL_PRO)\nAC_SUBST(TCL_CFLAGS)\nAC_SUBST(TCL_LIBS)\n\nAC_MSG_CHECKING(--enable-rubyinterp argument)\nAC_ARG_ENABLE(rubyinterp,\n\t[  --enable-rubyinterp[=OPTS]     Include Ruby interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,\n\t[enable_rubyinterp=\"no\"])\nAC_MSG_RESULT($enable_rubyinterp)\nif test \"$enable_rubyinterp\" = \"yes\" -o \"$enable_rubyinterp\" = \"dynamic\"; then\n  if test \"x$features\" = \"xtiny\" -o \"x$features\" = \"xsmall\"; then\n    AC_MSG_ERROR([cannot use Ruby with tiny or small features])\n  fi\n\n  AC_MSG_CHECKING(--with-ruby-command argument)\n  AC_SUBST(vi_cv_path_ruby)\n  AC_ARG_WITH(ruby-command, [  --with-ruby-command=RUBY  name of the Ruby command (default: ruby)],\n\tRUBY_CMD=\"$withval\"; vi_cv_path_ruby=\"$withval\"; AC_MSG_RESULT($RUBY_CMD),\n\tRUBY_CMD=\"ruby\"; AC_MSG_RESULT(defaulting to $RUBY_CMD))\n  AC_PATH_PROG(vi_cv_path_ruby, $RUBY_CMD)\n  if test \"X$vi_cv_path_ruby\" != \"X\"; then\n    AC_MSG_CHECKING(Ruby version)\n    if $vi_cv_path_ruby -e '(VERSION rescue RUBY_VERSION) >= \"1.6.0\" or exit 1' >/dev/null 2>/dev/null; then\n      AC_MSG_RESULT(OK)\n      AC_MSG_CHECKING(Ruby rbconfig)\n      ruby_rbconfig=\"RbConfig\"\n      if ! $vi_cv_path_ruby -r rbconfig -e 'RbConfig' >/dev/null 2>/dev/null; then\n\truby_rbconfig=\"Config\"\n      fi\n      AC_MSG_RESULT($ruby_rbconfig)\n      AC_MSG_CHECKING(Ruby header files)\n      rubyhdrdir=`$vi_cv_path_ruby -r mkmf -e \"print $ruby_rbconfig::CONFIG[['rubyhdrdir']] || $ruby_rbconfig::CONFIG[['archdir']] || \\\\$hdrdir\" 2>/dev/null`\n      if test \"X$rubyhdrdir\" != \"X\"; then\n\tAC_MSG_RESULT($rubyhdrdir)\n\tRUBY_CFLAGS=\"-I$rubyhdrdir\"\n        rubyarchdir=`$vi_cv_path_ruby -r rbconfig -e \"print ($ruby_rbconfig::CONFIG.has_key? 'rubyarchhdrdir') ? $ruby_rbconfig::CONFIG[['rubyarchhdrdir']] : '$rubyhdrdir/'+$ruby_rbconfig::CONFIG[['arch']]\"`\n        if test -d \"$rubyarchdir\"; then\n          RUBY_CFLAGS=\"$RUBY_CFLAGS -I$rubyarchdir\"\n        fi\n        rubyversion=`$vi_cv_path_ruby -r rbconfig -e \"print $ruby_rbconfig::CONFIG[['ruby_version']].gsub(/\\./, '')[[0,2]]\"`\n\tif test \"X$rubyversion\" = \"X\"; then\n\t  rubyversion=`$vi_cv_path_ruby -e \"print ((VERSION rescue RUBY_VERSION)).gsub(/\\./, '')[[0,2]]\"`\n\tfi\n        RUBY_CFLAGS=\"$RUBY_CFLAGS -DRUBY_VERSION=$rubyversion\"\n\trubylibs=`$vi_cv_path_ruby -r rbconfig -e \"print $ruby_rbconfig::CONFIG[['LIBS']]\"`\n\tif test \"X$rubylibs\" != \"X\"; then\n\t  RUBY_LIBS=\"$rubylibs\"\n\tfi\n\tlibrubyarg=`$vi_cv_path_ruby -r rbconfig -e \"print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['LIBRUBYARG']])\"`\n\tlibrubya=`$vi_cv_path_ruby -r rbconfig -e \"print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['LIBRUBY_A']])\"`\n\trubylibdir=`$vi_cv_path_ruby -r rbconfig -e \"print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['libdir']])\"`\n\tif test -f \"$rubylibdir/$librubya\"; then\n\t  librubyarg=\"$librubyarg\"\n\t  RUBY_LIBS=\"$RUBY_LIBS -L$rubylibdir\"\n\telif test \"$librubyarg\" = \"libruby.a\"; then\n\t  dnl required on Mac OS 10.3 where libruby.a doesn't exist\n\t  librubyarg=\"-lruby\"\n\t  RUBY_LIBS=\"$RUBY_LIBS -L$rubylibdir\"\n\tfi\n\n\tif test \"X$librubyarg\" != \"X\"; then\n\t  RUBY_LIBS=\"$librubyarg $RUBY_LIBS\"\n\tfi\n\trubyldflags=`$vi_cv_path_ruby -r rbconfig -e \"print $ruby_rbconfig::CONFIG[['LDFLAGS']]\"`\n\tif test \"X$rubyldflags\" != \"X\"; then\n\t  dnl Ruby on Mac OS X 10.5 adds \"-arch\" flags but these should only\n\t  dnl be included if requested by passing --with-mac-arch to\n\t  dnl configure, so strip these flags first (if present)\n\t  rubyldflags=`echo \"$rubyldflags\" | sed -e 's/-arch\\ ppc//' -e 's/-arch\\ i386//' -e 's/-arch\\ x86_64//'`\n\t  if test \"X$rubyldflags\" != \"X\"; then\n\t    if test \"X`echo \\\"$LDFLAGS\\\" | $FGREP -e \\\"$rubyldflags\\\"`\" = \"X\"; then\n\t      LDFLAGS=\"$rubyldflags $LDFLAGS\"\n\t    fi\n\t  fi\n\tfi\n\tRUBY_SRC=\"if_ruby.c\"\n\tRUBY_OBJ=\"objects/if_ruby.o\"\n\tRUBY_PRO=\"if_ruby.pro\"\n\tAC_DEFINE(FEAT_RUBY)\n\tif test \"$enable_rubyinterp\" = \"dynamic\"; then\n\t  libruby=`$vi_cv_path_ruby -r rbconfig -e \"puts $ruby_rbconfig::CONFIG[['LIBRUBY_SO']]\"`\n\t  AC_DEFINE(DYNAMIC_RUBY)\n\t  RUBY_CFLAGS=\"-DDYNAMIC_RUBY_DLL=\\\\\\\"$libruby\\\\\\\" -DDYNAMIC_RUBY_VER=$rubyversion $RUBY_CFLAGS\"\n\t  RUBY_LIBS=\n\tfi\n      else\n\tAC_MSG_RESULT(not found; disabling Ruby)\n      fi\n    else\n      AC_MSG_RESULT(too old; need Ruby version 1.6.0 or later)\n    fi\n  fi\n\n  if test \"$fail_if_missing\" = \"yes\" -a -z \"$RUBY_OBJ\"; then\n    AC_MSG_ERROR([could not configure Ruby])\n  fi\nfi\nAC_SUBST(RUBY_SRC)\nAC_SUBST(RUBY_OBJ)\nAC_SUBST(RUBY_PRO)\nAC_SUBST(RUBY_CFLAGS)\nAC_SUBST(RUBY_LIBS)\n\nAC_MSG_CHECKING(--enable-cscope argument)\nAC_ARG_ENABLE(cscope,\n\t[  --enable-cscope         Include cscope interface.], ,\n\t[enable_cscope=\"no\"])\nAC_MSG_RESULT($enable_cscope)\nif test \"$enable_cscope\" = \"yes\"; then\n  AC_DEFINE(FEAT_CSCOPE)\nfi\n\nAC_MSG_CHECKING(--enable-workshop argument)\nAC_ARG_ENABLE(workshop,\n\t[  --enable-workshop       Include Sun Visual Workshop support.], ,\n\t[enable_workshop=\"no\"])\nAC_MSG_RESULT($enable_workshop)\nif test \"$enable_workshop\" = \"yes\"; then\n  AC_DEFINE(FEAT_SUN_WORKSHOP)\n  WORKSHOP_SRC=\"workshop.c integration.c\"\n  AC_SUBST(WORKSHOP_SRC)\n  WORKSHOP_OBJ=\"objects/workshop.o objects/integration.o\"\n  AC_SUBST(WORKSHOP_OBJ)\n  if test \"${enable_gui-xxx}\" = xxx; then\n    enable_gui=motif\n  fi\nfi\n\nAC_MSG_CHECKING(--disable-netbeans argument)\nAC_ARG_ENABLE(netbeans,\n\t[  --disable-netbeans      Disable NetBeans integration support.],\n\t, [enable_netbeans=\"yes\"])\nif test \"$enable_netbeans\" = \"yes\"; then\n  if test \"x$features\" = \"xtiny\" -o \"x$features\" = \"xsmall\"; then\n    AC_MSG_RESULT([cannot use NetBeans with tiny or small features])\n    enable_netbeans=\"no\"\n  else\n    AC_MSG_RESULT(no)\n  fi\nelse\n  AC_MSG_RESULT(yes)\nfi\n\nAC_MSG_CHECKING(--disable-channel argument)\nAC_ARG_ENABLE(channel,\n\t[  --disable-channel      Disable process communication support.],\n\t, [enable_channel=\"yes\"])\nif test \"$enable_channel\" = \"yes\"; then\n  if test \"x$features\" = \"xtiny\" -o \"x$features\" = \"xsmall\"; then\n    AC_MSG_RESULT([cannot use channels with tiny or small features])\n    enable_channel=\"no\"\n  else\n    AC_MSG_RESULT(no)\n  fi\nelse\n  if test \"$enable_netbeans\" = \"yes\"; then\n    AC_MSG_RESULT([yes, netbeans also disabled])\n    enable_netbeans=\"no\"\n  else\n    AC_MSG_RESULT(yes)\n  fi\nfi\n\nif test \"$enable_channel\" = \"yes\"; then\n  dnl On Solaris we need the socket and nsl library.\n  AC_CHECK_LIB(socket, socket)\n  AC_CHECK_LIB(nsl, gethostbyname)\n  AC_MSG_CHECKING(whether compiling with process communication is possible)\n  AC_TRY_LINK([\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n\t/* Check bitfields */\n\tstruct nbbuf {\n\tunsigned int  initDone:1;\n\tunsigned short signmaplen;\n\t};\n\t    ], [\n\t\t/* Check creating a socket. */\n\t\tstruct sockaddr_in server;\n\t\t(void)socket(AF_INET, SOCK_STREAM, 0);\n\t\t(void)htons(100);\n\t\t(void)gethostbyname(\"microsoft.com\");\n\t\tif (errno == ECONNREFUSED)\n\t\t  (void)connect(1, (struct sockaddr *)&server, sizeof(server));\n\t    ],\n\tAC_MSG_RESULT(yes),\n\tAC_MSG_RESULT(no); enable_netbeans=\"no\"; enable_channel=\"no\")\nfi\nif test \"$enable_netbeans\" = \"yes\"; then\n  AC_DEFINE(FEAT_NETBEANS_INTG)\n  NETBEANS_SRC=\"netbeans.c\"\n  AC_SUBST(NETBEANS_SRC)\n  NETBEANS_OBJ=\"objects/netbeans.o\"\n  AC_SUBST(NETBEANS_OBJ)\nfi\nif test \"$enable_channel\" = \"yes\"; then\n  AC_DEFINE(FEAT_JOB_CHANNEL)\n  CHANNEL_SRC=\"channel.c\"\n  AC_SUBST(CHANNEL_SRC)\n  CHANNEL_OBJ=\"objects/channel.o\"\n  AC_SUBST(CHANNEL_OBJ)\nfi\n\nAC_MSG_CHECKING(--enable-multibyte argument)\nAC_ARG_ENABLE(multibyte,\n\t[  --enable-multibyte      Include multibyte editing support.], ,\n\t[enable_multibyte=\"no\"])\nAC_MSG_RESULT($enable_multibyte)\nif test \"$enable_multibyte\" = \"yes\"; then\n  AC_DEFINE(FEAT_MBYTE)\nfi\n\nAC_MSG_CHECKING(--enable-hangulinput argument)\nAC_ARG_ENABLE(hangulinput,\n\t[  --enable-hangulinput    Include Hangul input support.], ,\n\t[enable_hangulinput=\"no\"])\nAC_MSG_RESULT($enable_hangulinput)\n\nAC_MSG_CHECKING(--enable-xim argument)\nAC_ARG_ENABLE(xim,\n\t[  --enable-xim            Include XIM input support.],\n\tAC_MSG_RESULT($enable_xim),\n\t[enable_xim=\"auto\"; AC_MSG_RESULT(defaulting to auto)])\n\nAC_MSG_CHECKING(--enable-fontset argument)\nAC_ARG_ENABLE(fontset,\n\t[  --enable-fontset        Include X fontset output support.], ,\n\t[enable_fontset=\"no\"])\nAC_MSG_RESULT($enable_fontset)\ndnl defining FEAT_XFONTSET is delayed, so that it can be disabled for no GUI\n\ntest -z \"$with_x\" && with_x=yes\ntest \"${enable_gui-yes}\" != no -a \"x$MACOSX\" != \"xyes\" -a \"x$QNX\" != \"xyes\" && with_x=yes\nif test \"$with_x\" = no; then\n  AC_MSG_RESULT(defaulting to: don't HAVE_X11)\nelse\n  dnl Do this check early, so that its failure can override user requests.\n\n  AC_PATH_PROG(xmkmfpath, xmkmf)\n\n  AC_PATH_XTRA\n\n  dnl On z/OS Unix the X libraries are DLLs. To use them the code must\n  dnl be compiled with a special option.\n  dnl Also add SM, ICE and Xmu to X_EXTRA_LIBS.\n  if test \"$zOSUnix\" = \"yes\"; then\n    CFLAGS=\"$CFLAGS -W c,dll\"\n    LDFLAGS=\"$LDFLAGS -W l,dll\"\n    X_EXTRA_LIBS=\"$X_EXTRA_LIBS -lSM -lICE -lXmu\"\n  fi\n\n  dnl On my HPUX system the X include dir is found, but the lib dir not.\n  dnl This is a desparate try to fix this.\n\n  if test -d \"$x_includes\" && test ! -d \"$x_libraries\"; then\n    x_libraries=`echo \"$x_includes\" | sed s/include/lib/`\n    AC_MSG_RESULT(Corrected X libraries to $x_libraries)\n    X_LIBS=\"$X_LIBS -L$x_libraries\"\n    if test \"`(uname) 2>/dev/null`\" = SunOS &&\n\t\t\t\t\t uname -r | grep '^5' >/dev/null; then\n      X_LIBS=\"$X_LIBS -R $x_libraries\"\n    fi\n  fi\n\n  if test -d \"$x_libraries\" && test ! -d \"$x_includes\"; then\n    x_includes=`echo \"$x_libraries\" | sed s/lib/include/`\n    AC_MSG_RESULT(Corrected X includes to $x_includes)\n    X_CFLAGS=\"$X_CFLAGS -I$x_includes\"\n  fi\n\n  dnl Remove \"-I/usr/include \" from X_CFLAGS, should not be needed.\n  X_CFLAGS=\"`echo $X_CFLAGS\\  | sed 's%-I/usr/include %%'`\"\n  dnl Remove \"-L/usr/lib \" from X_LIBS, should not be needed.\n  X_LIBS=\"`echo $X_LIBS\\  | sed 's%-L/usr/lib %%'`\"\n  dnl Same for \"-R/usr/lib \".\n  X_LIBS=\"`echo $X_LIBS\\  | sed -e 's%-R/usr/lib %%' -e 's%-R /usr/lib %%'`\"\n\n\n  dnl Check if the X11 header files are correctly installed. On some systems\n  dnl Xlib.h includes files that don't exist.  On some systems X11/Intrinsic.h\n  dnl is missing.\n  AC_MSG_CHECKING(if X11 header files can be found)\n  cflags_save=$CFLAGS\n  CFLAGS=\"$CFLAGS $X_CFLAGS\"\n  AC_TRY_COMPILE([#include <X11/Xlib.h>\n#include <X11/Intrinsic.h>], ,\n\tAC_MSG_RESULT(yes),\n\tAC_MSG_RESULT(no); no_x=yes)\n  CFLAGS=$cflags_save\n\n  if test \"${no_x-no}\" = yes; then\n    with_x=no\n  else\n    AC_DEFINE(HAVE_X11)\n    X_LIB=\"-lXt -lX11\";\n    AC_SUBST(X_LIB)\n\n    ac_save_LDFLAGS=\"$LDFLAGS\"\n    LDFLAGS=\"-L$x_libraries $LDFLAGS\"\n\n    dnl Check for -lXdmcp (needed on SunOS 4.1.4)\n    dnl For HP-UX 10.20 it must be before -lSM -lICE\n    AC_CHECK_LIB(Xdmcp, _XdmcpAuthDoIt, [X_EXTRA_LIBS=\"$X_EXTRA_LIBS -lXdmcp\"],,\n\t\t[-lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS -lXdmcp])\n\n    dnl Some systems need -lnsl -lsocket when testing for ICE.\n    dnl The check above doesn't do this, try here (again).  Also needed to get\n    dnl them after Xdmcp.  link.sh will remove them when not needed.\n    dnl Check for other function than above to avoid the cached value\n    AC_CHECK_LIB(ICE, IceOpenConnection,\n\t\t  [X_EXTRA_LIBS=\"$X_EXTRA_LIBS -lSM -lICE\"],, [$X_EXTRA_LIBS])\n\n    dnl Check for -lXpm (needed for some versions of Motif)\n    LDFLAGS=\"$X_LIBS $ac_save_LDFLAGS\"\n    AC_CHECK_LIB(Xpm, XpmCreatePixmapFromData, [X_PRE_LIBS=\"$X_PRE_LIBS -lXpm\"],,\n\t\t[-lXt $X_PRE_LIBS -lXpm -lX11 $X_EXTRA_LIBS])\n\n    dnl Check that the X11 header files don't use implicit declarations\n    AC_MSG_CHECKING(if X11 header files implicitly declare return values)\n    cflags_save=$CFLAGS\n    dnl -Werror is GCC only, others like Solaris Studio might not like it\n    if test \"$GCC\" = yes; then\n      CFLAGS=\"$CFLAGS $X_CFLAGS -Werror\"\n    else\n      CFLAGS=\"$CFLAGS $X_CFLAGS\"\n    fi\n    AC_TRY_COMPILE([#include <X11/Xlib.h>], ,\n\tAC_MSG_RESULT(no),\n\tCFLAGS=\"$CFLAGS -Wno-implicit-int\"\n\tAC_TRY_COMPILE([#include <X11/Xlib.h>], ,\n\t    AC_MSG_RESULT(yes); cflags_save=\"$cflags_save -Wno-implicit-int\",\n\t    AC_MSG_RESULT(test failed)\n\t)\n    )\n    CFLAGS=$cflags_save\n\n    LDFLAGS=\"$ac_save_LDFLAGS\"\n\n    AC_MSG_CHECKING(size of wchar_t is 2 bytes)\n    AC_CACHE_VAL(ac_cv_small_wchar_t,\n\t[AC_TRY_RUN([\n#include <X11/Xlib.h>\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\n\t\tmain()\n\t\t{\n\t\t  if (sizeof(wchar_t) <= 2)\n\t\t    exit(1);\n\t\t  exit(0);\n\t\t}],\n\t\tac_cv_small_wchar_t=\"no\",\n\t\tac_cv_small_wchar_t=\"yes\",\n\t\tAC_MSG_ERROR(failed to compile test program))])\n    AC_MSG_RESULT($ac_cv_small_wchar_t)\n    if test \"x$ac_cv_small_wchar_t\" = \"xyes\" ; then\n      AC_DEFINE(SMALL_WCHAR_T)\n    fi\n\n  fi\nfi\n\ntest \"x$with_x\" = xno -a \"x$MACOSX\" != \"xyes\" -a \"x$QNX\" != \"xyes\" && enable_gui=no\n\nAC_MSG_CHECKING(--enable-gui argument)\nAC_ARG_ENABLE(gui,\n [  --enable-gui[=OPTS]     X11 GUI [default=auto] [OPTS=auto/no/gtk2/gnome2/gtk3/motif/athena/neXtaw/photon/carbon]], , enable_gui=\"auto\")\n\ndnl Canonicalize the --enable-gui= argument so that it can be easily compared.\ndnl Do not use character classes for portability with old tools.\nenable_gui_canon=`echo \"_$enable_gui\" | \\\n\tsed 's/[[ _+-]]//g;y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`\n\ndnl Skip everything by default.\nSKIP_GTK2=YES\nSKIP_GTK3=YES\nSKIP_GNOME=YES\nSKIP_MOTIF=YES\nSKIP_ATHENA=YES\nSKIP_NEXTAW=YES\nSKIP_PHOTON=YES\nSKIP_CARBON=YES\nGUITYPE=NONE\n\nif test \"x$QNX\" = \"xyes\" -a \"x$with_x\" = \"xno\" ; then\n  SKIP_PHOTON=\n  case \"$enable_gui_canon\" in\n    no)\t\tAC_MSG_RESULT(no GUI support)\n\t\tSKIP_PHOTON=YES ;;\n    yes|\"\")\tAC_MSG_RESULT(yes - automatic GUI support) ;;\n    auto)\tAC_MSG_RESULT(auto - automatic GUI support) ;;\n    photon)\tAC_MSG_RESULT(Photon GUI support) ;;\n    *)\t\tAC_MSG_RESULT([Sorry, $enable_gui GUI is not supported])\n\t\tSKIP_PHOTON=YES ;;\n  esac\n\nelif test \"x$MACOSX\" = \"xyes\" -a \"x$with_x\" = \"xno\" ; then\n  SKIP_CARBON=\n  case \"$enable_gui_canon\" in\n    no)\t\tAC_MSG_RESULT(no GUI support)\n\t\tSKIP_CARBON=YES ;;\n    yes|\"\")\tAC_MSG_RESULT(yes - automatic GUI support) ;;\n    auto)\tAC_MSG_RESULT(auto - Carbon GUI is outdated - disable GUI support)\n\t\tSKIP_CARBON=YES ;;\n    carbon)\tAC_MSG_RESULT(Carbon GUI support) ;;\n    *)\t\tAC_MSG_RESULT([Sorry, $enable_gui GUI is not supported])\n\t\tSKIP_CARBON=YES ;;\n  esac\n\nelse\n\n  case \"$enable_gui_canon\" in\n    no|none)\tAC_MSG_RESULT(no GUI support) ;;\n    yes|\"\"|auto)\tAC_MSG_RESULT(yes/auto - automatic GUI support)\n\t\tSKIP_GTK2=\n\t\tSKIP_GNOME=\n\t\tSKIP_MOTIF=\n\t\tSKIP_ATHENA=\n\t\tSKIP_NEXTAW=\n\t\tSKIP_CARBON=;;\n    gtk2)\tAC_MSG_RESULT(GTK+ 2.x GUI support)\n\t\tSKIP_GTK2=;;\n    gnome2)\tAC_MSG_RESULT(GNOME 2.x GUI support)\n\t\tSKIP_GNOME=\n\t\tSKIP_GTK2=;;\n    gtk3)\tAC_MSG_RESULT(GTK+ 3.x GUI support)\n\t\tSKIP_GTK3=;;\n    motif)\tAC_MSG_RESULT(Motif GUI support)\n\t\tSKIP_MOTIF=;;\n    athena)\tAC_MSG_RESULT(Athena GUI support)\n\t\tSKIP_ATHENA=;;\n    nextaw)\tAC_MSG_RESULT(neXtaw GUI support)\n\t\tSKIP_NEXTAW=;;\n    *)\t\tAC_MSG_RESULT([Sorry, $enable_gui GUI is not supported]) ;;\n  esac\n\nfi\n\nif test \"x$SKIP_GTK2\" != \"xYES\" -a \"$enable_gui_canon\" != \"gtk2\" \\\n\t\t\t\t-a \"$enable_gui_canon\" != \"gnome2\"; then\n  AC_MSG_CHECKING(whether or not to look for GTK+ 2)\n  AC_ARG_ENABLE(gtk2-check,\n\t[  --enable-gtk2-check     If auto-select GUI, check for GTK+ 2 [default=yes]],\n\t, enable_gtk2_check=\"yes\")\n  AC_MSG_RESULT($enable_gtk2_check)\n  if test \"x$enable_gtk2_check\" = \"xno\"; then\n    SKIP_GTK2=YES\n    SKIP_GNOME=YES\n  fi\nfi\n\nif test \"x$SKIP_GNOME\" != \"xYES\" -a \"$enable_gui_canon\" != \"gnome2\"; then\n  AC_MSG_CHECKING(whether or not to look for GNOME)\n  AC_ARG_ENABLE(gnome-check,\n\t[  --enable-gnome-check    If GTK GUI, check for GNOME [default=no]],\n\t, enable_gnome_check=\"no\")\n  AC_MSG_RESULT($enable_gnome_check)\n  if test \"x$enable_gnome_check\" = \"xno\"; then\n    SKIP_GNOME=YES\n  fi\nfi\n\nif test \"x$SKIP_GTK3\" != \"xYES\" -a \"$enable_gui_canon\" != \"gtk3\"; then\n  AC_MSG_CHECKING(whether or not to look for GTK+ 3)\n  AC_ARG_ENABLE(gtk3-check,\n\t[  --enable-gtk3-check     If auto-select GUI, check for GTK+ 3 [default=yes]],\n\t, enable_gtk3_check=\"yes\")\n  AC_MSG_RESULT($enable_gtk3_check)\n  if test \"x$enable_gtk3_check\" = \"xno\"; then\n    SKIP_GTK3=YES\n  fi\nfi\n\nif test \"x$SKIP_MOTIF\" != \"xYES\" -a \"$enable_gui_canon\" != \"motif\"; then\n  AC_MSG_CHECKING(whether or not to look for Motif)\n  AC_ARG_ENABLE(motif-check,\n\t[  --enable-motif-check    If auto-select GUI, check for Motif [default=yes]],\n\t, enable_motif_check=\"yes\")\n  AC_MSG_RESULT($enable_motif_check)\n  if test \"x$enable_motif_check\" = \"xno\"; then\n    SKIP_MOTIF=YES\n  fi\nfi\n\nif test \"x$SKIP_ATHENA\" != \"xYES\" -a \"$enable_gui_canon\" != \"athena\"; then\n  AC_MSG_CHECKING(whether or not to look for Athena)\n  AC_ARG_ENABLE(athena-check,\n\t[  --enable-athena-check   If auto-select GUI, check for Athena [default=yes]],\n\t, enable_athena_check=\"yes\")\n  AC_MSG_RESULT($enable_athena_check)\n  if test \"x$enable_athena_check\" = \"xno\"; then\n    SKIP_ATHENA=YES\n  fi\nfi\n\nif test \"x$SKIP_NEXTAW\" != \"xYES\" -a \"$enable_gui_canon\" != \"nextaw\"; then\n  AC_MSG_CHECKING(whether or not to look for neXtaw)\n  AC_ARG_ENABLE(nextaw-check,\n\t[  --enable-nextaw-check   If auto-select GUI, check for neXtaw [default=yes]],\n\t, enable_nextaw_check=\"yes\")\n  AC_MSG_RESULT($enable_nextaw_check);\n  if test \"x$enable_nextaw_check\" = \"xno\"; then\n    SKIP_NEXTAW=YES\n  fi\nfi\n\nif test \"x$SKIP_CARBON\" != \"xYES\" -a \"$enable_gui_canon\" != \"carbon\"; then\n  AC_MSG_CHECKING(whether or not to look for Carbon)\n  AC_ARG_ENABLE(carbon-check,\n\t[  --enable-carbon-check   If auto-select GUI, check for Carbon [default=yes]],\n\t, enable_carbon_check=\"yes\")\n  AC_MSG_RESULT($enable_carbon_check);\n  if test \"x$enable_carbon_check\" = \"xno\"; then\n    SKIP_CARBON=YES\n  fi\nfi\n\n\nif test \"x$MACOSX\" = \"xyes\" -a -z \"$SKIP_CARBON\" -a \"x$CARBON\" = \"xyes\"; then\n  AC_MSG_CHECKING(for Carbon GUI)\n  dnl already did the check, just give the message\n  AC_MSG_RESULT(yes);\n  GUITYPE=CARBONGUI\n  if test \"$VIMNAME\" = \"vim\"; then\n    VIMNAME=Vim\n  fi\n\n  if test \"x$MACARCH\" = \"xboth\"; then\n    CPPFLAGS=\"$CPPFLAGS -I$DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk/Developer/Headers/FlatCarbon\"\n  else\n    CPPFLAGS=\"$CPPFLAGS -I$DEVELOPER_DIR/Headers/FlatCarbon\"\n  fi\n\n  dnl Default install directory is not /usr/local\n  if test x$prefix = xNONE; then\n    prefix=/Applications\n  fi\n\n  dnl Sorry for the hard coded default\n  datadir='${prefix}/Vim.app/Contents/Resources'\n\n  dnl skip everything else\n  SKIP_GTK2=YES;\n  SKIP_GNOME=YES;\n  SKIP_MOTIF=YES;\n  SKIP_ATHENA=YES;\n  SKIP_NEXTAW=YES;\n  SKIP_PHOTON=YES;\n  SKIP_CARBON=YES\nfi\n\ndnl define an autoconf function to check for a specified version of GTK, and\ndnl try to compile/link a GTK program.\ndnl\ndnl AM_PATH_GTK([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])\ndnl Test for GTK, and define GTK_CFLAGS, GTK_LIBDIR and GTK_LIBS\ndnl\nAC_DEFUN(AM_PATH_GTK,\n[\n  if test \"X$GTK_CONFIG\" != \"Xno\" -o \"X$PKG_CONFIG\" != \"Xno\"; then\n  {\n    no_gtk=\"\"\n    if (test \"X$SKIP_GTK2\" != \"XYES\" -a \"X$PKG_CONFIG\" != \"Xno\") \\\n\t  && $PKG_CONFIG --exists gtk+-2.0; then\n    {\n      min_gtk_version=ifelse([$1], ,2.2.0,$1)\n      AC_MSG_CHECKING(for GTK - version >= $min_gtk_version)\n      dnl We should be using PKG_CHECK_MODULES() instead of this hack.\n      dnl But I guess the dependency on pkgconfig.m4 is not wanted or\n      dnl something like that.\n      GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-2.0`\n      GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-2.0`\n      GTK_LIBS=`$PKG_CONFIG --libs gtk+-2.0`\n      gtk_major_version=`$PKG_CONFIG --modversion gtk+-2.0 | \\\n\t     sed 's/\\([[0-9]]*\\)\\.\\([[0-9]]*\\)\\.\\([[0-9]]*\\)/\\1/'`\n      gtk_minor_version=`$PKG_CONFIG --modversion gtk+-2.0 | \\\n\t     sed 's/\\([[0-9]]*\\)\\.\\([[0-9]]*\\)\\.\\([[0-9]]*\\)/\\2/'`\n      gtk_micro_version=`$PKG_CONFIG --modversion gtk+-2.0 | \\\n\t     sed 's/\\([[0-9]]*\\)\\.\\([[0-9]]*\\)\\.\\([[0-9]]*\\)/\\3/'`\n    }\n    elif (test \"X$SKIP_GTK3\" != \"XYES\" -a \"X$PKG_CONFIG\" != \"Xno\") \\\n\t  && $PKG_CONFIG --exists gtk+-3.0; then\n    {\n      min_gtk_version=ifelse([$1], ,3.0.0,$1)\n      AC_MSG_CHECKING(for GTK - version >= $min_gtk_version)\n\n      GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-3.0`\n      GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-3.0`\n      GTK_LIBS=`$PKG_CONFIG --libs gtk+-3.0`\n      gtk_major_version=`$PKG_CONFIG --modversion gtk+-3.0 | \\\n\t     sed 's/\\([[0-9]]*\\)\\.\\([[0-9]]*\\)\\.\\([[0-9]]*\\)/\\1/'`\n      gtk_minor_version=`$PKG_CONFIG --modversion gtk+-3.0 | \\\n\t     sed 's/\\([[0-9]]*\\)\\.\\([[0-9]]*\\)\\.\\([[0-9]]*\\)/\\2/'`\n      gtk_micro_version=`$PKG_CONFIG --modversion gtk+-3.0 | \\\n\t     sed 's/\\([[0-9]]*\\)\\.\\([[0-9]]*\\)\\.\\([[0-9]]*\\)/\\3/'`\n    }\n    else\n      no_gtk=yes\n    fi\n\n    if test \"x$enable_gtktest\" = \"xyes\" -a \"x$no_gtk\" = \"x\"; then\n    {\n      ac_save_CFLAGS=\"$CFLAGS\"\n      ac_save_LIBS=\"$LIBS\"\n      CFLAGS=\"$CFLAGS $GTK_CFLAGS\"\n      LIBS=\"$LIBS $GTK_LIBS\"\n\n      dnl\n      dnl Now check if the installed GTK is sufficiently new.\n      dnl\n      rm -f conf.gtktest\n      AC_TRY_RUN([\n#include <gtk/gtk.h>\n#include <stdio.h>\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\n\nint\nmain ()\n{\nint major, minor, micro;\nchar *tmp_version;\n\nsystem (\"touch conf.gtktest\");\n\n/* HP/UX 9 (%@#!) writes to sscanf strings */\ntmp_version = g_strdup(\"$min_gtk_version\");\nif (sscanf(tmp_version, \"%d.%d.%d\", &major, &minor, &micro) != 3) {\n   printf(\"%s, bad version string\\n\", \"$min_gtk_version\");\n   exit(1);\n }\n\nif ((gtk_major_version > major) ||\n    ((gtk_major_version == major) && (gtk_minor_version > minor)) ||\n    ((gtk_major_version == major) && (gtk_minor_version == minor) &&\n\t\t\t\t     (gtk_micro_version >= micro)))\n{\n    return 0;\n}\nreturn 1;\n}\n],, no_gtk=yes,[echo $ac_n \"cross compiling; assumed OK... $ac_c\"])\n      CFLAGS=\"$ac_save_CFLAGS\"\n      LIBS=\"$ac_save_LIBS\"\n    }\n    fi\n    if test \"x$no_gtk\" = x ; then\n      if test \"x$enable_gtktest\" = \"xyes\"; then\n\tAC_MSG_RESULT(yes; found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version)\n      else\n\tAC_MSG_RESULT(found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version)\n      fi\n      ifelse([$2], , :, [$2])\n    else\n    {\n      AC_MSG_RESULT(no)\n      GTK_CFLAGS=\"\"\n      GTK_LIBS=\"\"\n      ifelse([$3], , :, [$3])\n    }\n    fi\n  }\n  else\n    GTK_CFLAGS=\"\"\n    GTK_LIBS=\"\"\n    ifelse([$3], , :, [$3])\n  fi\n  AC_SUBST(GTK_CFLAGS)\n  AC_SUBST(GTK_LIBS)\n  rm -f conf.gtktest\n])\n\ndnl ---------------------------------------------------------------------------\ndnl gnome\ndnl ---------------------------------------------------------------------------\nAC_DEFUN([GNOME_INIT_HOOK],\n[\n  AC_SUBST(GNOME_LIBS)\n  AC_SUBST(GNOME_LIBDIR)\n  AC_SUBST(GNOME_INCLUDEDIR)\n\n  AC_ARG_WITH(gnome-includes,\n    [  --with-gnome-includes=DIR Specify location of GNOME headers],\n    [CFLAGS=\"$CFLAGS -I$withval\"]\n  )\n\n  AC_ARG_WITH(gnome-libs,\n    [  --with-gnome-libs=DIR   Specify location of GNOME libs],\n    [LDFLAGS=\"$LDFLAGS -L$withval\" gnome_prefix=$withval]\n  )\n\n  AC_ARG_WITH(gnome,\n    [  --with-gnome            Specify prefix for GNOME files],\n    if test x$withval = xyes; then\n      want_gnome=yes\n      ifelse([$1], [], :, [$1])\n    else\n      if test \"x$withval\" = xno; then\n\twant_gnome=no\n      else\n\twant_gnome=yes\n\tLDFLAGS=\"$LDFLAGS -L$withval/lib\"\n\tCFLAGS=\"$CFLAGS -I$withval/include\"\n\tgnome_prefix=$withval/lib\n      fi\n    fi,\n    want_gnome=yes)\n\n  if test \"x$want_gnome\" = xyes; then\n  {\n    AC_MSG_CHECKING(for libgnomeui-2.0)\n    if $PKG_CONFIG --exists libgnomeui-2.0; then\n      AC_MSG_RESULT(yes)\n      GNOME_LIBS=`$PKG_CONFIG --libs-only-l libgnomeui-2.0`\n      GNOME_LIBDIR=`$PKG_CONFIG --libs-only-L libgnomeui-2.0`\n      GNOME_INCLUDEDIR=`$PKG_CONFIG --cflags libgnomeui-2.0`\n\n      dnl On FreeBSD we need -pthread but pkg-config doesn't include it.\n      dnl This might not be the right way but it works for me...\n      AC_MSG_CHECKING(for FreeBSD)\n      if test \"`(uname) 2>/dev/null`\" = FreeBSD; then\n\tAC_MSG_RESULT(yes, adding -pthread)\n\tGNOME_INCLUDEDIR=\"$GNOME_INCLUDEDIR -D_THREAD_SAFE\"\n\tGNOME_LIBS=\"$GNOME_LIBS -pthread\"\n      else\n\tAC_MSG_RESULT(no)\n      fi\n      $1\n    else\n      AC_MSG_RESULT(not found)\n      if test \"x$2\" = xfail; then\n\tAC_MSG_ERROR(Could not find libgnomeui-2.0 via pkg-config)\n      fi\n    fi\n  }\n  fi\n])\n\nAC_DEFUN([GNOME_INIT],[\n\tGNOME_INIT_HOOK([],fail)\n])\n\n\ndnl ---------------------------------------------------------------------------\ndnl Check for GTK2.  If it fails, then continue on for Motif as before...\ndnl ---------------------------------------------------------------------------\nif test -z \"$SKIP_GTK2\"; then\n\n  AC_MSG_CHECKING(--disable-gtktest argument)\n  AC_ARG_ENABLE(gtktest, [  --disable-gtktest       Do not try to compile and run a test GTK program],\n\t, enable_gtktest=yes)\n  if test \"x$enable_gtktest\" = \"xyes\" ; then\n    AC_MSG_RESULT(gtk test enabled)\n  else\n    AC_MSG_RESULT(gtk test disabled)\n  fi\n\n  if test \"X$PKG_CONFIG\" = \"X\"; then\n    AC_PATH_PROG(PKG_CONFIG, pkg-config, no)\n  fi\n\n  if test \"x$PKG_CONFIG\" != \"xno\"; then\n    dnl First try finding version 2.2.0 or later.  The 2.0.x series has\n    dnl problems (bold fonts, --remote doesn't work).\n    AM_PATH_GTK(2.2.0,\n\t\t[GUI_LIB_LOC=\"$GTK_LIBDIR\"\n\t\t GTK_LIBNAME=\"$GTK_LIBS\"\n\t\tGUI_INC_LOC=\"$GTK_CFLAGS\"], )\n    if test \"x$GTK_CFLAGS\" != \"x\"; then\n      SKIP_GTK3=YES\n      SKIP_ATHENA=YES\n      SKIP_NEXTAW=YES\n      SKIP_MOTIF=YES\n      GUITYPE=GTK\n      AC_SUBST(GTK_LIBNAME)\n    fi\n  fi\n  if test \"x$GUITYPE\" = \"xGTK\"; then\n    if test \"$gtk_minor_version\" = 1 -a \"0$gtk_micro_version\" -ge 1 \\\n\t|| test \"0$gtk_minor_version\" -ge 2; then\n      AC_DEFINE(HAVE_GTK_MULTIHEAD)\n    fi\n    dnl\n    dnl if GTK exists, then check for GNOME.\n    dnl\n    if test -z \"$SKIP_GNOME\"; then\n    {\n      GNOME_INIT_HOOK([have_gnome=yes])\n      if test \"x$have_gnome\" = xyes ; then\n\tAC_DEFINE(FEAT_GUI_GNOME)\n\tGUI_INC_LOC=\"$GUI_INC_LOC $GNOME_INCLUDEDIR\"\n\tGTK_LIBNAME=\"$GTK_LIBNAME $GNOME_LIBDIR $GNOME_LIBS\"\n      fi\n    }\n    fi\n  fi\nfi\n\n\ndnl ---------------------------------------------------------------------------\ndnl Check for GTK3.\ndnl ---------------------------------------------------------------------------\nif test -z \"$SKIP_GTK3\"; then\n\n  AC_MSG_CHECKING(--disable-gtktest argument)\n  AC_ARG_ENABLE(gtktest, [  --disable-gtktest       Do not try to compile and run a test GTK program],\n\t, enable_gtktest=yes)\n  if test \"x$enable_gtktest\" = \"xyes\" ; then\n    AC_MSG_RESULT(gtk test enabled)\n  else\n    AC_MSG_RESULT(gtk test disabled)\n  fi\n\n  if test \"X$PKG_CONFIG\" = \"X\"; then\n    AC_PATH_PROG(PKG_CONFIG, pkg-config, no)\n  fi\n\n  if test \"x$PKG_CONFIG\" != \"xno\"; then\n    AM_PATH_GTK(3.0.0,\n\t\t[GUI_LIB_LOC=\"$GTK_LIBDIR\"\n\t\t GTK_LIBNAME=\"$GTK_LIBS\"\n\t\tGUI_INC_LOC=\"$GTK_CFLAGS\"], )\n    if test \"x$GTK_CFLAGS\" != \"x\"; then\n      SKIP_GTK2=YES\n      SKIP_GNOME=YES\n      SKIP_ATHENA=YES\n      SKIP_NEXTAW=YES\n      SKIP_MOTIF=YES\n      GUITYPE=GTK\n      AC_SUBST(GTK_LIBNAME)\n      AC_DEFINE(HAVE_GTK_MULTIHEAD)\n      AC_DEFINE(USE_GTK3)\n    fi\n  fi\nfi\n\ndnl Check the version of Gdk-Pixbuf.  If the version is 2.31 or later and\ndnl glib-compile-resources is found in PATH, use GResource.\nif test \"x$GUITYPE\" = \"xGTK\"; then\n  AC_MSG_CHECKING([version of Gdk-Pixbuf])\n  gdk_pixbuf_version=`$PKG_CONFIG --modversion gdk-pixbuf-2.0`\n  if test \"x$gdk_pixbuf_version\" != x ; then\n    gdk_pixbuf_version_minor=`echo $gdk_pixbuf_version | \\\n      sed -e 's/[[0-9]][[0-9]]*\\.\\([[0-9]][[0-9]]*\\)\\.[[0-9]][[0-9]]*/\\1/'`\n    if test \"x$gdk_pixbuf_version_minor\" != x -a \\\n\t$gdk_pixbuf_version_minor -ge 31 ; then\n      AC_MSG_RESULT([OK.])\n      AC_PATH_PROG(GLIB_COMPILE_RESOURCES,[glib-compile-resources],no)\n      AC_MSG_CHECKING([glib-compile-resources])\n      if test \"x$GLIB_COMPILE_RESOURCES\" = xno ; then\n\tGLIB_COMPILE_RESOURCES=\"\"\n\tAC_MSG_RESULT([cannot be found in PATH.])\n      else\n\tAC_MSG_RESULT([usable.])\n\tAC_DEFINE(USE_GRESOURCE)\n\tGRESOURCE_SRC=\"auto/gui_gtk_gresources.c\"\n\tGRESOURCE_OBJ=\"objects/gui_gtk_gresources.o\"\n      fi\n    else\n      AC_MSG_RESULT([not usable.])\n    fi\n  else\n    AC_MSG_RESULT([cannot obtain from pkg_config.])\n  fi\n\n  AC_MSG_CHECKING([--disable-icon-cache-update argument])\n  AC_ARG_ENABLE(icon_cache_update,\n          [  --disable-icon-cache-update        update disabled],\n          [],\n          [enable_icon_cache_update=\"yes\"])\n  if test \"$enable_icon_cache_update\" = \"yes\"; then\n    AC_MSG_RESULT([not set])\n    AC_PATH_PROG(GTK_UPDATE_ICON_CACHE,[gtk-update-icon-cache],no)\n    if test \"x$GTK_UPDATE_ICON_CACHE\" = \"xno\" ; then\n      AC_MSG_RESULT([not found in PATH.])\n    fi\n  else\n    AC_MSG_RESULT([update disabled])\n  fi\n\n  AC_MSG_CHECKING([--disable-desktop-database-update argument])\n  AC_ARG_ENABLE(desktop_database_update,\n          [  --disable-desktop-database-update  update disabled],\n          [],\n          [enable_desktop_database_update=\"yes\"])\n  if test \"$enable_desktop_database_update\" = \"yes\"; then\n    AC_MSG_RESULT([not set])\n    AC_PATH_PROG(UPDATE_DESKTOP_DATABASE,[update-desktop-database],no)\n    if test \"x$UPDATE_DESKTOP_DATABASE\" = \"xno\" ; then\n      AC_MSG_RESULT([not found in PATH.])\n    fi\n  else\n    AC_MSG_RESULT([update disabled])\n  fi\nfi\nAC_SUBST(GLIB_COMPILE_RESOURCES)\nAC_SUBST(GRESOURCE_SRC)\nAC_SUBST(GRESOURCE_OBJ)\nAC_SUBST(GTK_UPDATE_ICON_CACHE)\nAC_SUBST(UPDATE_DESKTOP_DATABASE)\n\ndnl Check for Motif include files location.\ndnl The LAST one found is used, this makes the highest version to be used,\ndnl e.g. when Motif1.2 and Motif2.0 are both present.\n\nif test -z \"$SKIP_MOTIF\"; then\n  gui_XXX=\"/usr/XXX/Motif* /usr/Motif*/XXX /usr/XXX /usr/shlib /usr/X11*/XXX /usr/XXX/X11* /usr/dt/XXX /local/Motif*/XXX /local/XXX/Motif* /usr/local/Motif*/XXX /usr/local/XXX/Motif* /usr/local/XXX /usr/local/X11*/XXX /usr/local/LessTif/Motif*/XXX $MOTIFHOME/XXX\"\n  dnl Remove \"-I\" from before $GUI_INC_LOC if it's there\n  GUI_INC_LOC=\"`echo $GUI_INC_LOC|sed 's%-I%%g'`\"\n\n  AC_MSG_CHECKING(for location of Motif GUI includes)\n  gui_includes=\"`echo $x_includes|sed 's%/[^/][^/]*$%%'` `echo \"$gui_XXX\" | sed s/XXX/include/g` $GUI_INC_LOC\"\n  GUI_INC_LOC=\n  for try in $gui_includes; do\n    if test -f \"$try/Xm/Xm.h\"; then\n      GUI_INC_LOC=$try\n    fi\n  done\n  if test -n \"$GUI_INC_LOC\"; then\n    if test \"$GUI_INC_LOC\" = /usr/include; then\n      GUI_INC_LOC=\n      AC_MSG_RESULT(in default path)\n    else\n      AC_MSG_RESULT($GUI_INC_LOC)\n    fi\n  else\n    AC_MSG_RESULT(<not found>)\n    SKIP_MOTIF=YES\n  fi\nfi\n\ndnl Check for Motif library files location.  In the same order as the include\ndnl files, to avoid a mixup if several versions are present\n\nif test -z \"$SKIP_MOTIF\"; then\n  AC_MSG_CHECKING(--with-motif-lib argument)\n  AC_ARG_WITH(motif-lib,\n  [  --with-motif-lib=STRING   Library for Motif ],\n  [ MOTIF_LIBNAME=\"${withval}\" ] )\n\n  if test -n \"$MOTIF_LIBNAME\"; then\n    AC_MSG_RESULT($MOTIF_LIBNAME)\n    GUI_LIB_LOC=\n  else\n    AC_MSG_RESULT(no)\n\n    dnl Remove \"-L\" from before $GUI_LIB_LOC if it's there\n    GUI_LIB_LOC=\"`echo $GUI_LIB_LOC|sed 's%-L%%g'`\"\n\n    dnl Ubuntu has libXm.so in /usr/lib/i386-linux-gnu and elsewhere.  The\n    dnl linker will figure out which one to use, we only check if one exists.\n    AC_MSG_CHECKING(for location of Motif GUI libs)\n    gui_libs=\"`echo $x_libraries|sed 's%/[^/][^/]*$%%'` `echo \"$gui_XXX\" | sed s/XXX/lib/g` /usr/lib/i386-linux-gnu /usr/lib/x86_64-linux-gnu `echo \"$GUI_INC_LOC\" | sed s/include/lib/` $GUI_LIB_LOC\"\n    GUI_LIB_LOC=\n    for try in $gui_libs; do\n      for libtry in \"$try\"/libXm.a \"$try\"/libXm.so* \"$try\"/libXm.sl \"$try\"/libXm.dylib; do\n\tif test -f \"$libtry\"; then\n\t  GUI_LIB_LOC=$try\n\tfi\n      done\n    done\n    if test -n \"$GUI_LIB_LOC\"; then\n      dnl Remove /usr/lib, it causes trouble on some systems\n      if test \"$GUI_LIB_LOC\" = /usr/lib \\\n\t   -o \"$GUI_LIB_LOC\" = /usr/lib/i386-linux-gnu \\\n\t   -o \"$GUI_LIB_LOC\" = /usr/lib/x86_64-linux-gnu; then\n\tGUI_LIB_LOC=\n\tAC_MSG_RESULT(in default path)\n      else\n\tif test -n \"$GUI_LIB_LOC\"; then\n\t  AC_MSG_RESULT($GUI_LIB_LOC)\n\t  if test \"`(uname) 2>/dev/null`\" = SunOS &&\n\t\t\t\t\t uname -r | grep '^5' >/dev/null; then\n\t    GUI_LIB_LOC=\"$GUI_LIB_LOC -R $GUI_LIB_LOC\"\n\t  fi\n\tfi\n      fi\n      MOTIF_LIBNAME=-lXm\n    else\n      AC_MSG_RESULT(<not found>)\n      SKIP_MOTIF=YES\n    fi\n  fi\nfi\n\nif test -z \"$SKIP_MOTIF\"; then\n  SKIP_ATHENA=YES\n  SKIP_NEXTAW=YES\n  GUITYPE=MOTIF\n  AC_SUBST(MOTIF_LIBNAME)\nfi\n\ndnl Check if the Athena files can be found\n\nGUI_X_LIBS=\n\nif test -z \"$SKIP_ATHENA\"; then\n  AC_MSG_CHECKING(if Athena header files can be found)\n  cflags_save=$CFLAGS\n  CFLAGS=\"$CFLAGS $X_CFLAGS\"\n  AC_TRY_COMPILE([\n#include <X11/Intrinsic.h>\n#include <X11/Xaw/Paned.h>], ,\n\tAC_MSG_RESULT(yes),\n\tAC_MSG_RESULT(no); SKIP_ATHENA=YES )\n  CFLAGS=$cflags_save\nfi\n\nif test -z \"$SKIP_ATHENA\"; then\n  GUITYPE=ATHENA\nfi\n\nif test -z \"$SKIP_NEXTAW\"; then\n  AC_MSG_CHECKING(if neXtaw header files can be found)\n  cflags_save=$CFLAGS\n  CFLAGS=\"$CFLAGS $X_CFLAGS\"\n  AC_TRY_COMPILE([\n#include <X11/Intrinsic.h>\n#include <X11/neXtaw/Paned.h>], ,\n\tAC_MSG_RESULT(yes),\n\tAC_MSG_RESULT(no); SKIP_NEXTAW=YES )\n  CFLAGS=$cflags_save\nfi\n\nif test -z \"$SKIP_NEXTAW\"; then\n  GUITYPE=NEXTAW\nfi\n\nif test -z \"$SKIP_ATHENA\" -o -z \"$SKIP_NEXTAW\" -o -z \"$SKIP_MOTIF\"; then\n  dnl Prepend -I and -L to $GUI_INC_LOC and $GUI_LIB_LOC if not empty\n  dnl Avoid adding it when it twice\n  if test -n \"$GUI_INC_LOC\"; then\n    GUI_INC_LOC=-I\"`echo $GUI_INC_LOC|sed 's%-I%%'`\"\n  fi\n  if test -n \"$GUI_LIB_LOC\"; then\n    GUI_LIB_LOC=-L\"`echo $GUI_LIB_LOC|sed 's%-L%%'`\"\n  fi\n\n  dnl Check for -lXext and then for -lXmu\n  ldflags_save=$LDFLAGS\n  LDFLAGS=\"$X_LIBS $LDFLAGS\"\n  AC_CHECK_LIB(Xext, XShapeQueryExtension, [GUI_X_LIBS=\"-lXext\"],,\n\t\t[-lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])\n  dnl For Solaris we need -lw and -ldl before linking with -lXmu works.\n  AC_CHECK_LIB(w, wslen, [X_EXTRA_LIBS=\"$X_EXTRA_LIBS -lw\"],,\n\t\t[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])\n  AC_CHECK_LIB(dl, dlsym, [X_EXTRA_LIBS=\"$X_EXTRA_LIBS -ldl\"],,\n\t\t[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])\n  AC_CHECK_LIB(Xmu, XmuCreateStippledPixmap, [GUI_X_LIBS=\"-lXmu $GUI_X_LIBS\"],,\n\t\t[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])\n  if test -z \"$SKIP_MOTIF\"; then\n    AC_CHECK_LIB(Xp, XpEndJob, [GUI_X_LIBS=\"-lXp $GUI_X_LIBS\"],,\n\t\t[$GUI_X_LIBS -lXm -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])\n  fi\n  LDFLAGS=$ldflags_save\n\n  dnl Execute xmkmf to figure out if -DNARROWPROTO is needed.\n  AC_MSG_CHECKING(for extra X11 defines)\n  NARROW_PROTO=\n  rm -fr conftestdir\n  if mkdir conftestdir; then\n    cd conftestdir\n    cat > Imakefile <<'EOF'\nacfindx:\n\t@echo 'NARROW_PROTO=\"${PROTO_DEFINES}\"'\nEOF\n    if (xmkmf) >/dev/null 2>/dev/null && test -f Makefile; then\n      eval `${MAKE-make} acfindx 2>/dev/null | grep -v make`\n    fi\n    cd ..\n    rm -fr conftestdir\n  fi\n  if test -z \"$NARROW_PROTO\"; then\n    AC_MSG_RESULT(no)\n  else\n    AC_MSG_RESULT($NARROW_PROTO)\n  fi\n  AC_SUBST(NARROW_PROTO)\nfi\n\ndnl Look for XSMP support - but don't necessarily restrict it to X11 GUIs\ndnl use the X11 include path\nif test \"$enable_xsmp\" = \"yes\"; then\n  cppflags_save=$CPPFLAGS\n  CPPFLAGS=\"$CPPFLAGS $X_CFLAGS\"\n  AC_CHECK_HEADERS(X11/SM/SMlib.h)\n  CPPFLAGS=$cppflags_save\nfi\n\n\nif test -z \"$SKIP_ATHENA\" -o -z \"$SKIP_NEXTAW\" -o -z \"$SKIP_MOTIF\" -o -z \"$SKIP_GTK2\" -o -z \"$SKIP_GTK3\"; then\n  dnl Check for X11/xpm.h and X11/Sunkeysym.h with the GUI include path\n  cppflags_save=$CPPFLAGS\n  CPPFLAGS=\"$CPPFLAGS $X_CFLAGS\"\n  AC_CHECK_HEADERS(X11/xpm.h X11/Sunkeysym.h)\n\n  dnl automatically disable XIM when XIMtext isn't in X11/Xlib.h\n  if test ! \"$enable_xim\" = \"no\"; then\n    AC_MSG_CHECKING(for XIMText in X11/Xlib.h)\n    AC_EGREP_CPP(XIMText, [#include <X11/Xlib.h>],\n\t\t  AC_MSG_RESULT(yes),\n\t\t  AC_MSG_RESULT(no; xim has been disabled); enable_xim=\"no\")\n  fi\n  CPPFLAGS=$cppflags_save\n\n  dnl automatically enable XIM when hangul input isn't enabled\n  if test \"$enable_xim\" = \"auto\" -a \"$enable_hangulinput\" != \"yes\" \\\n\t\t-a \"x$GUITYPE\" != \"xNONE\" ; then\n    AC_MSG_RESULT(X GUI selected; xim has been enabled)\n    enable_xim=\"yes\"\n  fi\nfi\n\nif test -z \"$SKIP_ATHENA\" -o -z \"$SKIP_NEXTAW\" -o -z \"$SKIP_MOTIF\"; then\n  cppflags_save=$CPPFLAGS\n  CPPFLAGS=\"$CPPFLAGS $X_CFLAGS\"\ndnl Xmu/Editres.h may exist but can only be used after including Intrinsic.h\n  AC_MSG_CHECKING([for X11/Xmu/Editres.h])\n  AC_TRY_COMPILE([\n#include <X11/Intrinsic.h>\n#include <X11/Xmu/Editres.h>],\n\t\t      [int i; i = 0;],\n\t      AC_MSG_RESULT(yes)\n\t\t      AC_DEFINE(HAVE_X11_XMU_EDITRES_H),\n\t      AC_MSG_RESULT(no))\n  CPPFLAGS=$cppflags_save\nfi\n\ndnl Only use the Xm directory when compiling Motif, don't use it for Athena\nif test -z \"$SKIP_MOTIF\"; then\n  cppflags_save=$CPPFLAGS\n  CPPFLAGS=\"$CPPFLAGS $X_CFLAGS\"\n  if test \"$zOSUnix\" = \"yes\"; then\n\txmheader=\"Xm/Xm.h\"\n  else\n\txmheader=\"Xm/Xm.h Xm/XpmP.h Xm/JoinSideT.h Xm/TraitP.h Xm/Manager.h\n\t   Xm/UnhighlightT.h Xm/Notebook.h\"  \n  fi    \n  AC_CHECK_HEADERS($xmheader)\n\n  if test \"x$ac_cv_header_Xm_XpmP_h\" = \"xyes\"; then\n    dnl Solaris uses XpmAttributes_21, very annoying.\n    AC_MSG_CHECKING([for XpmAttributes_21 in Xm/XpmP.h])\n    AC_TRY_COMPILE([#include <Xm/XpmP.h>], [XpmAttributes_21 attr;],\n\tAC_MSG_RESULT(yes); AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes_21),\n\tAC_MSG_RESULT(no); AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes)\n\t)\n  else\n    AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes)\n  fi\n  CPPFLAGS=$cppflags_save\nfi\n\nif test \"x$GUITYPE\" = \"xNONE\" -a \"$enable_xim\" = \"yes\"; then\n  AC_MSG_RESULT(no GUI selected; xim has been disabled)\n  enable_xim=\"no\"\nfi\nif test \"x$GUITYPE\" = \"xNONE\" -a \"$enable_fontset\" = \"yes\"; then\n  AC_MSG_RESULT(no GUI selected; fontset has been disabled)\n  enable_fontset=\"no\"\nfi\nif test \"x$GUITYPE:$enable_fontset\" = \"xGTK:yes\"; then\n  AC_MSG_RESULT(GTK+ 2 GUI selected; fontset has been disabled)\n  enable_fontset=\"no\"\nfi\n\nif test -z \"$SKIP_PHOTON\"; then\n  GUITYPE=PHOTONGUI\nfi\n\nAC_SUBST(GUI_INC_LOC)\nAC_SUBST(GUI_LIB_LOC)\nAC_SUBST(GUITYPE)\nAC_SUBST(GUI_X_LIBS)\n\nif test \"$enable_workshop\" = \"yes\" -a -n \"$SKIP_MOTIF\"; then\n  AC_MSG_ERROR([cannot use workshop without Motif])\nfi\n\ndnl defining FEAT_XIM and FEAT_XFONTSET is delayed, so that they can be disabled\nif test \"$enable_xim\" = \"yes\"; then\n  AC_DEFINE(FEAT_XIM)\nfi\nif test \"$enable_fontset\" = \"yes\"; then\n  AC_DEFINE(FEAT_XFONTSET)\nfi\n\n\ndnl ---------------------------------------------------------------------------\ndnl end of GUI-checking\ndnl ---------------------------------------------------------------------------\n\nAC_MSG_CHECKING([for /proc link to executable])\nif test -L \"/proc/self/exe\"; then\n  dnl Linux\n  AC_MSG_RESULT([/proc/self/exe])\n  AC_DEFINE(PROC_EXE_LINK, \"/proc/self/exe\")\nelif test -L \"/proc/self/path/a.out\"; then\n  dnl Solaris\n  AC_MSG_RESULT([/proc/self/path/a.out])\n  AC_DEFINE(PROC_EXE_LINK, \"/proc/self/path/a.out\")\nelif test -L \"/proc/curproc/file\"; then\n  dnl FreeBSD\n  AC_MSG_RESULT([/proc/curproc/file])\n  AC_DEFINE(PROC_EXE_LINK, \"/proc/curproc/file\")\nelse\n  AC_MSG_RESULT(no)\nfi\n\ndnl Check for Cygwin, which needs an extra source file if not using X11\nAC_MSG_CHECKING(for CYGWIN or MSYS environment)\ncase `uname` in\n    CYGWIN*|MSYS*)    CYGWIN=yes; AC_MSG_RESULT(yes)\n                AC_MSG_CHECKING(for CYGWIN clipboard support)\n                if test \"x$with_x\" = \"xno\" ; then\n                  OS_EXTRA_SRC=winclip.c; OS_EXTRA_OBJ=objects/winclip.o\n                  AC_MSG_RESULT(yes)\n                  AC_DEFINE(FEAT_CYGWIN_WIN32_CLIPBOARD)\n                else\n                  AC_MSG_RESULT(no - using X11)\n                fi ;;\n\n    *)          CYGWIN=no; AC_MSG_RESULT(no);;\nesac\n\ndnl Only really enable hangul input when GUI and XFONTSET are available\nif test \"$enable_hangulinput\" = \"yes\"; then\n  if test \"x$GUITYPE\" = \"xNONE\"; then\n    AC_MSG_RESULT(no GUI selected; hangul input has been disabled)\n    enable_hangulinput=no\n  else\n    AC_DEFINE(FEAT_HANGULIN)\n    HANGULIN_SRC=hangulin.c\n    AC_SUBST(HANGULIN_SRC)\n    HANGULIN_OBJ=objects/hangulin.o\n    AC_SUBST(HANGULIN_OBJ)\n  fi\nfi\n\ndnl Checks for libraries and include files.\n\nAC_CACHE_CHECK([whether toupper is broken], [vim_cv_toupper_broken],\n  [\n    AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include \"confdefs.h\"\n#include <ctype.h>\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\nmain() { exit(toupper('A') == 'A' && tolower('z') == 'z'); }\n  ]])],[\n    vim_cv_toupper_broken=yes\n  ],[\n    vim_cv_toupper_broken=no\n  ],[\n    AC_MSG_ERROR(cross-compiling: please set 'vim_cv_toupper_broken')\n  ])])\n\nif test \"x$vim_cv_toupper_broken\" = \"xyes\" ; then\n  AC_DEFINE(BROKEN_TOUPPER)\nfi\n\nAC_MSG_CHECKING(whether __DATE__ and __TIME__ work)\nAC_TRY_COMPILE([#include <stdio.h>], [printf(\"(\" __DATE__ \" \" __TIME__ \")\");],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_DATE_TIME),\n\tAC_MSG_RESULT(no))\n\nAC_MSG_CHECKING(whether __attribute__((unused)) is allowed)\nAC_TRY_COMPILE([#include <stdio.h>], [int x __attribute__((unused));],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_ATTRIBUTE_UNUSED),\n\tAC_MSG_RESULT(no))\n\ndnl Checks for header files.\nAC_CHECK_HEADER(elf.h, HAS_ELF=1)\ndnl AC_CHECK_HEADER(dwarf.h, SVR4=1)\nif test \"$HAS_ELF\" = 1; then\n  AC_CHECK_LIB(elf, main)\nfi\n\nAC_HEADER_DIRENT\n\ndnl If sys/wait.h is not found it might still exist but not be POSIX\ndnl compliant. In that case we define HAVE_UNION_WAIT (for NeXT)\nif test $ac_cv_header_sys_wait_h = no; then\n  AC_MSG_CHECKING([for sys/wait.h that defines union wait])\n  AC_TRY_COMPILE([#include <sys/wait.h>],\n\t\t\t[union wait xx, yy; xx = yy],\n\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_SYS_WAIT_H)\n\t\t\tAC_DEFINE(HAVE_UNION_WAIT),\n\t\tAC_MSG_RESULT(no))\nfi\n\nAC_CHECK_HEADERS(stdint.h stdlib.h string.h \\\n\tsys/select.h sys/utsname.h termcap.h fcntl.h \\\n\tsgtty.h sys/ioctl.h sys/time.h sys/types.h \\\n\ttermio.h iconv.h inttypes.h langinfo.h math.h \\\n\tunistd.h stropts.h errno.h sys/resource.h \\\n\tsys/systeminfo.h locale.h sys/stream.h termios.h \\\n\tlibc.h sys/statfs.h poll.h sys/poll.h pwd.h \\\n\tutime.h sys/param.h libintl.h libgen.h \\\n\tutil/debug.h util/msg18n.h frame.h sys/acl.h \\\n\tsys/access.h sys/sysinfo.h wchar.h wctype.h)\n\ndnl sys/ptem.h depends on sys/stream.h on Solaris\nAC_CHECK_HEADERS(sys/ptem.h, [], [],\n[#if defined HAVE_SYS_STREAM_H\n#  include <sys/stream.h>\n#endif])\n\ndnl sys/sysctl.h depends on sys/param.h on OpenBSD\nAC_CHECK_HEADERS(sys/sysctl.h, [], [],\n[#if defined HAVE_SYS_PARAM_H\n#  include <sys/param.h>\n#endif])\n\n\ndnl pthread_np.h may exist but can only be used after including pthread.h\nAC_MSG_CHECKING([for pthread_np.h])\nAC_TRY_COMPILE([\n#include <pthread.h>\n#include <pthread_np.h>],\n\t\t      [int i; i = 0;],\n\t      AC_MSG_RESULT(yes)\n\t\t      AC_DEFINE(HAVE_PTHREAD_NP_H),\n\t      AC_MSG_RESULT(no))\n\nAC_CHECK_HEADERS(strings.h)\nif test \"x$MACOSX\" = \"xyes\"; then\n  dnl The strings.h file on OS/X contains a warning and nothing useful.\n  AC_DEFINE(NO_STRINGS_WITH_STRING_H)\nelse\n\ndnl Check if strings.h and string.h can both be included when defined.\nAC_MSG_CHECKING([if strings.h can be included after string.h])\ncppflags_save=$CPPFLAGS\nCPPFLAGS=\"$CPPFLAGS $X_CFLAGS\"\nAC_TRY_COMPILE([\n#if defined(_AIX) && !defined(_AIX51) && !defined(_NO_PROTO)\n# define _NO_PROTO\t/* like in os_unix.h, causes conflict for AIX (Winn) */\n\t\t\t/* but don't do it on AIX 5.1 (Uribarri) */\n#endif\n#ifdef HAVE_XM_XM_H\n# include <Xm/Xm.h>\t/* This breaks it for HP-UX 11 (Squassabia) */\n#endif\n#ifdef HAVE_STRING_H\n# include <string.h>\n#endif\n#if defined(HAVE_STRINGS_H)\n# include <strings.h>\n#endif\n\t\t], [int i; i = 0;],\n\t\tAC_MSG_RESULT(yes),\n\t\tAC_DEFINE(NO_STRINGS_WITH_STRING_H)\n\t\tAC_MSG_RESULT(no))\nCPPFLAGS=$cppflags_save\nfi\n\ndnl Checks for typedefs, structures, and compiler characteristics.\nAC_PROG_GCC_TRADITIONAL\nAC_C_CONST\nAC_C_VOLATILE\nAC_TYPE_MODE_T\nAC_TYPE_OFF_T\nAC_TYPE_PID_T\nAC_TYPE_SIZE_T\nAC_TYPE_UID_T\nAC_TYPE_UINT32_T\n\nAC_HEADER_TIME\nAC_CHECK_TYPE(ino_t, long)\nAC_CHECK_TYPE(dev_t, unsigned)\nAC_C_BIGENDIAN(,,,)\nAC_C_INLINE\n\nAC_MSG_CHECKING(for rlim_t)\nif eval \"test \\\"`echo '$''{'ac_cv_type_rlim_t'+set}'`\\\" = set\"; then\n  AC_MSG_RESULT([(cached) $ac_cv_type_rlim_t])\nelse\n  AC_EGREP_CPP(dnl\nchangequote(<<,>>)dnl\n<<(^|[^a-zA-Z_0-9])rlim_t[^a-zA-Z_0-9]>>dnl\nchangequote([,]),\n  [\n#include <sys/types.h>\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\n#ifdef HAVE_SYS_RESOURCE_H\n# include <sys/resource.h>\n#endif\n\t  ], ac_cv_type_rlim_t=yes, ac_cv_type_rlim_t=no)\n\t  AC_MSG_RESULT($ac_cv_type_rlim_t)\nfi\nif test $ac_cv_type_rlim_t = no; then\n  cat >> confdefs.h <<\\EOF\n#define rlim_t unsigned long\nEOF\nfi\n\nAC_MSG_CHECKING(for stack_t)\nif eval \"test \\\"`echo '$''{'ac_cv_type_stack_t'+set}'`\\\" = set\"; then\n  AC_MSG_RESULT([(cached) $ac_cv_type_stack_t])\nelse\n  AC_EGREP_CPP(stack_t,\n  [\n#include <sys/types.h>\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\n#include <signal.h>\n\t  ], ac_cv_type_stack_t=yes, ac_cv_type_stack_t=no)\n\t  AC_MSG_RESULT($ac_cv_type_stack_t)\nfi\nif test $ac_cv_type_stack_t = no; then\n  cat >> confdefs.h <<\\EOF\n#define stack_t struct sigaltstack\nEOF\nfi\n\ndnl BSDI uses ss_base while others use ss_sp for the stack pointer.\nAC_MSG_CHECKING(whether stack_t has an ss_base field)\nAC_TRY_COMPILE([\n#include <sys/types.h>\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\n#include <signal.h>\n#include \"confdefs.h\"\n\t\t\t], [stack_t sigstk; sigstk.ss_base = 0; ],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_SS_BASE),\n\tAC_MSG_RESULT(no))\n\nolibs=\"$LIBS\"\nAC_MSG_CHECKING(--with-tlib argument)\nAC_ARG_WITH(tlib, [  --with-tlib=library     terminal library to be used ],)\nif test -n \"$with_tlib\"; then\n  AC_MSG_RESULT($with_tlib)\n  LIBS=\"$LIBS -l$with_tlib\"\n  AC_MSG_CHECKING(for linking with $with_tlib library)\n  AC_TRY_LINK([], [], AC_MSG_RESULT(OK), AC_MSG_ERROR(FAILED))\n  dnl Need to check for tgetent() below.\n  olibs=\"$LIBS\"\nelse\n  AC_MSG_RESULT([empty: automatic terminal library selection])\n  dnl  On HP-UX 10.10 termcap or termlib should be used instead of\n  dnl  curses, because curses is much slower.\n  dnl  Newer versions of ncurses are preferred over anything, except\n  dnl  when tinfo has been split off, it contains all we need.\n  dnl  Older versions of ncurses have bugs, get a new one!\n  dnl  Digital Unix (OSF1) should use curses (Ronald Schild).\n  dnl  On SCO Openserver should prefer termlib (Roger Cornelius).\n  case \"`uname -s 2>/dev/null`\" in\n\tOSF1|SCO_SV)\ttlibs=\"tinfo ncurses curses termlib termcap\";;\n\t*)\ttlibs=\"tinfo ncurses termlib termcap curses\";;\n  esac\n  for libname in $tlibs; do\n    AC_CHECK_LIB(${libname}, tgetent,,)\n    if test \"x$olibs\" != \"x$LIBS\"; then\n      dnl It's possible that a library is found but it doesn't work\n      dnl e.g., shared library that cannot be found\n      dnl compile and run a test program to be sure\n      AC_TRY_RUN([\n#ifdef HAVE_TERMCAP_H\n# include <termcap.h>\n#endif\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\nmain() {char *s; s=(char *)tgoto(\"%p1%d\", 0, 1); exit(0); }],\n\t\t\t  res=\"OK\", res=\"FAIL\", res=\"FAIL\")\n      if test \"$res\" = \"OK\"; then\n\tbreak\n      fi\n      AC_MSG_RESULT($libname library is not usable)\n      LIBS=\"$olibs\"\n    fi\n  done\n  if test \"x$olibs\" = \"x$LIBS\"; then\n    AC_MSG_RESULT(no terminal library found)\n  fi\nfi\n\nif test \"x$olibs\" = \"x$LIBS\"; then\n  AC_MSG_CHECKING([for tgetent()])\n  AC_TRY_LINK([],\n      [char s[10000]; int res = tgetent(s, \"thisterminaldoesnotexist\");],\n\tAC_MSG_RESULT(yes),\n\tAC_MSG_ERROR([NOT FOUND!\n      You need to install a terminal library; for example ncurses.\n      Or specify the name of the library with --with-tlib.]))\nfi\n\nAC_CACHE_CHECK([whether we talk terminfo], [vim_cv_terminfo],\n  [\n    AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include \"confdefs.h\"\n#ifdef HAVE_TERMCAP_H\n# include <termcap.h>\n#endif\n#ifdef HAVE_STRING_H\n# include <string.h>\n#endif\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\nmain()\n{char *s; s=(char *)tgoto(\"%p1%d\", 0, 1); exit(!strcmp(s==0 ? \"\" : s, \"1\")); }\n    ]])],[\n      vim_cv_terminfo=no\n    ],[\n      vim_cv_terminfo=yes\n    ],[\n      AC_MSG_ERROR(cross-compiling: please set 'vim_cv_terminfo')\n    ])\n  ])\n\nif test \"x$vim_cv_terminfo\" = \"xyes\" ; then\n  AC_DEFINE(TERMINFO)\nfi\n\nif test \"x$olibs\" != \"x$LIBS\"; then\n  AC_CACHE_CHECK([what tgetent() returns for an unknown terminal], [vim_cv_tgent],\n    [\n      AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include \"confdefs.h\"\n#ifdef HAVE_TERMCAP_H\n# include <termcap.h>\n#endif\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\nmain()\n{char s[10000]; int res = tgetent(s, \"thisterminaldoesnotexist\"); exit(res != 0); }\n      ]])],[\n\tvim_cv_tgent=zero\n      ],[\n\tvim_cv_tgent=non-zero\n      ],[\n\tAC_MSG_ERROR(failed to compile test program.)\n      ])\n    ])\n  \n  if test \"x$vim_cv_tgent\" = \"xzero\" ; then\n    AC_DEFINE(TGETENT_ZERO_ERR, 0)\n  fi\nfi\n\nAC_MSG_CHECKING(whether termcap.h contains ospeed)\nAC_TRY_LINK([\n#ifdef HAVE_TERMCAP_H\n# include <termcap.h>\n#endif\n\t\t\t], [ospeed = 20000],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_OSPEED),\n\t[AC_MSG_RESULT(no)\n\tAC_MSG_CHECKING(whether ospeed can be extern)\n\tAC_TRY_LINK([\n#ifdef HAVE_TERMCAP_H\n# include <termcap.h>\n#endif\nextern short ospeed;\n\t\t\t], [ospeed = 20000],\n\t\tAC_MSG_RESULT(yes); AC_DEFINE(OSPEED_EXTERN),\n\t\tAC_MSG_RESULT(no))]\n\t)\n\nAC_MSG_CHECKING([whether termcap.h contains UP, BC and PC])\nAC_TRY_LINK([\n#ifdef HAVE_TERMCAP_H\n# include <termcap.h>\n#endif\n\t\t\t], [if (UP == 0 && BC == 0) PC = 1],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_UP_BC_PC),\n\t[AC_MSG_RESULT(no)\n\tAC_MSG_CHECKING([whether UP, BC and PC can be extern])\n\tAC_TRY_LINK([\n#ifdef HAVE_TERMCAP_H\n# include <termcap.h>\n#endif\nextern char *UP, *BC, PC;\n\t\t\t], [if (UP == 0 && BC == 0) PC = 1],\n\t\tAC_MSG_RESULT(yes); AC_DEFINE(UP_BC_PC_EXTERN),\n\t\tAC_MSG_RESULT(no))]\n\t)\n\nAC_MSG_CHECKING(whether tputs() uses outfuntype)\nAC_TRY_COMPILE([\n#ifdef HAVE_TERMCAP_H\n# include <termcap.h>\n#endif\n\t\t\t], [extern int xx(); tputs(\"test\", 1, (outfuntype)xx)],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_OUTFUNTYPE),\n\tAC_MSG_RESULT(no))\n\ndnl On some SCO machines sys/select redefines struct timeval\nAC_MSG_CHECKING([whether sys/select.h and sys/time.h may both be included])\nAC_TRY_COMPILE([\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/select.h>], ,\n\t  AC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(SYS_SELECT_WITH_SYS_TIME),\n\t  AC_MSG_RESULT(no))\n\ndnl AC_DECL_SYS_SIGLIST\n\ndnl Checks for pty.c (copied from screen) ==========================\nAC_MSG_CHECKING(for /dev/ptc)\nif test -r /dev/ptc; then\n  AC_DEFINE(HAVE_DEV_PTC)\n  AC_MSG_RESULT(yes)\nelse\n  AC_MSG_RESULT(no)\nfi\n\nAC_MSG_CHECKING(for SVR4 ptys)\nif test -c /dev/ptmx ; then\n  AC_TRY_LINK([], [ptsname(0);grantpt(0);unlockpt(0);],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_SVR4_PTYS),\n\tAC_MSG_RESULT(no))\nelse\n  AC_MSG_RESULT(no)\nfi\n\nAC_MSG_CHECKING(for ptyranges)\nif test -d /dev/ptym ; then\n  pdir='/dev/ptym'\nelse\n  pdir='/dev'\nfi\ndnl SCO uses ptyp%d\nAC_EGREP_CPP(yes,\n[#ifdef M_UNIX\n   yes;\n#endif\n\t], ptys=`echo /dev/ptyp??`, ptys=`echo $pdir/pty??`)\ndnl if test -c /dev/ptyp19; then\ndnl ptys=`echo /dev/ptyp??`\ndnl else\ndnl ptys=`echo $pdir/pty??`\ndnl fi\nif test \"$ptys\" != \"$pdir/pty??\" ; then\n  p0=`echo $ptys | tr ' ' '\\012' | sed -e 's/^.*\\(.\\).$/\\1/g' | sort -u | tr -d '\\012'`\n  p1=`echo $ptys | tr ' ' '\\012' | sed -e 's/^.*\\(.\\)$/\\1/g'  | sort -u | tr -d '\\012'`\n  AC_DEFINE_UNQUOTED(PTYRANGE0,\"$p0\")\n  AC_DEFINE_UNQUOTED(PTYRANGE1,\"$p1\")\n  AC_MSG_RESULT([$p0 / $p1])\nelse\n  AC_MSG_RESULT([don't know])\nfi\n\ndnl    ****  pty mode/group handling ****\ndnl\ndnl support provided by Luke Mewburn <lm@rmit.edu.au>, 931222\nrm -f conftest_grp\nAC_CACHE_CHECK([default tty permissions/group], [vim_cv_tty_group],\n  [\n    AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include \"confdefs.h\"\n#include <sys/types.h>\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <sys/stat.h>\n#include <stdio.h>\nmain()\n{\n  struct stat sb;\n  char *x,*ttyname();\n  int om, m;\n  FILE *fp;\n\n  if (!(x = ttyname(0))) exit(1);\n  if (stat(x, &sb)) exit(1);\n  om = sb.st_mode;\n  if (om & 002) exit(0);\n  m = system(\"mesg y\");\n  if (m == -1 || m == 127) exit(1);\n  if (stat(x, &sb)) exit(1);\n  m = sb.st_mode;\n  if (chmod(x, om)) exit(1);\n  if (m & 002) exit(0);\n  if (sb.st_gid == getgid()) exit(1);\n  if (!(fp=fopen(\"conftest_grp\", \"w\")))\n    exit(1);\n  fprintf(fp, \"%d\\n\", sb.st_gid);\n  fclose(fp);\n  exit(0);\n}\n    ]])],[\n      if test -f conftest_grp; then\n\tvim_cv_tty_group=`cat conftest_grp`\n\tif test \"x$vim_cv_tty_mode\" = \"x\" ; then\n\t  vim_cv_tty_mode=0620\n\tfi\n\tAC_MSG_RESULT([pty mode: $vim_cv_tty_mode, group: $vim_cv_tty_group])\n      else\n\tvim_cv_tty_group=world\n\tAC_MSG_RESULT([ptys are world accessible])\n      fi\n    ],[\n      vim_cv_tty_group=world\n      AC_MSG_RESULT([can't determine - assume ptys are world accessible])\n    ],[\n      AC_MSG_ERROR(cross-compiling: please set 'vim_cv_tty_group' and 'vim_cv_tty_mode')\n    ])\n  ])\nrm -f conftest_grp\n\nif test \"x$vim_cv_tty_group\" != \"xworld\" ; then\n  AC_DEFINE_UNQUOTED(PTYGROUP,$vim_cv_tty_group)\n  if test \"x$vim_cv_tty_mode\" = \"x\" ; then\n    AC_MSG_ERROR([It seems you're cross compiling and have 'vim_cv_tty_group' set, please also set the environment variable 'vim_cv_tty_mode' to the correct mode (probably 0620)])\n  else\n    AC_DEFINE(PTYMODE, 0620)\n  fi\nfi\n\ndnl Checks for library functions. ===================================\n\nAC_TYPE_SIGNAL\n\ndnl find out what to use at the end of a signal function\nif test $ac_cv_type_signal = void; then\n  AC_DEFINE(SIGRETURN, [return])\nelse\n  AC_DEFINE(SIGRETURN, [return 0])\nfi\n\ndnl check if struct sigcontext is defined (used for SGI only)\nAC_MSG_CHECKING(for struct sigcontext)\nAC_TRY_COMPILE([\n#include <signal.h>\ntest_sig()\n{\n    struct sigcontext *scont;\n    scont = (struct sigcontext *)0;\n    return 1;\n} ], ,\n\t  AC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_SIGCONTEXT),\n\t  AC_MSG_RESULT(no))\n\ndnl tricky stuff: try to find out if getcwd() is implemented with\ndnl system(\"sh -c pwd\")\nAC_CACHE_CHECK([getcwd implementation is broken], [vim_cv_getcwd_broken],\n  [\n    AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include \"confdefs.h\"\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\nchar *dagger[] = { \"IFS=pwd\", 0 };\nmain()\n{\n  char buffer[500];\n  extern char **environ;\n  environ = dagger;\n  return getcwd(buffer, 500) ? 0 : 1;\n}\n    ]])],[\n      vim_cv_getcwd_broken=no\n    ],[\n      vim_cv_getcwd_broken=yes\n    ],[\n      AC_MSG_ERROR(cross-compiling: please set 'vim_cv_getcwd_broken')\n    ])\n  ])\n\nif test \"x$vim_cv_getcwd_broken\" = \"xyes\" ; then\n  AC_DEFINE(BAD_GETCWD)\nfi\n\ndnl Check for functions in one big call, to reduce the size of configure.\ndnl Can only be used for functions that do not require any include.\nAC_CHECK_FUNCS(fchdir fchown fsync getcwd getpseudotty \\\n\tgetpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat \\\n\tmemset mkdtemp nanosleep opendir putenv qsort readlink select setenv \\\n\tgetpgid setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \\\n\tsigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \\\n\tstrnicmp strpbrk strtol tgetent towlower towupper iswupper \\\n\tusleep utime utimes)\nAC_FUNC_FSEEKO\n\ndnl define _LARGE_FILES, _FILE_OFFSET_BITS and _LARGEFILE_SOURCE when\ndnl appropriate, so that off_t is 64 bits when needed.\nAC_SYS_LARGEFILE\n\ndnl fstatfs() can take 2 to 4 arguments, try to use st_blksize if possible\nAC_MSG_CHECKING(for st_blksize)\nAC_TRY_COMPILE(\n[#include <sys/types.h>\n#include <sys/stat.h>],\n[\tstruct stat st;\n\tint n;\n\n\tstat(\"/\", &st);\n\tn = (int)st.st_blksize;],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_ST_BLKSIZE),\n\tAC_MSG_RESULT(no))\n\nAC_CACHE_CHECK([whether stat() ignores a trailing slash], [vim_cv_stat_ignores_slash],\n  [\n    AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include \"confdefs.h\"\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\n#include <sys/types.h>\n#include <sys/stat.h>\nmain() {struct stat st;  exit(stat(\"configure/\", &st) != 0); }\n    ]])],[\n      vim_cv_stat_ignores_slash=yes\n    ],[\n      vim_cv_stat_ignores_slash=no\n    ],[\n      AC_MSG_ERROR(cross-compiling: please set 'vim_cv_stat_ignores_slash')\n    ])\n  ])\n\nif test \"x$vim_cv_stat_ignores_slash\" = \"xyes\" ; then\n  AC_DEFINE(STAT_IGNORES_SLASH)\nfi\n  \ndnl Link with iconv for charset translation, if not found without library.\ndnl check for iconv() requires including iconv.h\ndnl Add \"-liconv\" when possible; Solaris has iconv but use GNU iconv when it\ndnl has been installed.\nAC_MSG_CHECKING(for iconv_open())\nsave_LIBS=\"$LIBS\"\nLIBS=\"$LIBS -liconv\"\nAC_TRY_LINK([\n#ifdef HAVE_ICONV_H\n# include <iconv.h>\n#endif\n    ], [iconv_open(\"fr\", \"to\");],\n    AC_MSG_RESULT(yes; with -liconv); AC_DEFINE(HAVE_ICONV),\n    LIBS=\"$save_LIBS\"\n    AC_TRY_LINK([\n#ifdef HAVE_ICONV_H\n# include <iconv.h>\n#endif\n\t], [iconv_open(\"fr\", \"to\");],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_ICONV),\n\tAC_MSG_RESULT(no)))\n\n\nAC_MSG_CHECKING(for nl_langinfo(CODESET))\nAC_TRY_LINK([\n#ifdef HAVE_LANGINFO_H\n# include <langinfo.h>\n#endif\n], [char *cs = nl_langinfo(CODESET);],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_NL_LANGINFO_CODESET),\n\tAC_MSG_RESULT(no))\n\ndnl Need various functions for floating point support.  Only enable\ndnl floating point when they are all present.\nAC_CHECK_LIB(m, strtod)\nAC_MSG_CHECKING([for strtod() and other floating point functions])\nAC_TRY_LINK([\n#ifdef HAVE_MATH_H\n# include <math.h>\n#endif\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\n], [char *s; double d;\n    d = strtod(\"1.1\", &s);\n    d = fabs(1.11);\n    d = ceil(1.11);\n    d = floor(1.11);\n    d = log10(1.11);\n    d = pow(1.11, 2.22);\n    d = sqrt(1.11);\n    d = sin(1.11);\n    d = cos(1.11);\n    d = atan(1.11);\n    ],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_FLOAT_FUNCS),\n\tAC_MSG_RESULT(no))\n\ndnl isinf() and isnan() need to include header files and may need -lm.\nAC_MSG_CHECKING([for isinf()])\nAC_TRY_LINK([\n#ifdef HAVE_MATH_H\n# include <math.h>\n#endif\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\n], [int r = isinf(1.11); ],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_ISINF),\n\tAC_MSG_RESULT(no))\n\nAC_MSG_CHECKING([for isnan()])\nAC_TRY_LINK([\n#ifdef HAVE_MATH_H\n# include <math.h>\n#endif\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\n], [int r = isnan(1.11); ],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_ISNAN),\n\tAC_MSG_RESULT(no))\n\ndnl Link with -lposix1e for ACL stuff; if not found, try -lacl for SGI\ndnl when -lacl works, also try to use -lattr (required for Debian).\ndnl On Solaris, use the acl_get/set functions in libsec, if present.\nAC_MSG_CHECKING(--disable-acl argument)\nAC_ARG_ENABLE(acl,\n\t[  --disable-acl           Don't check for ACL support.],\n\t, [enable_acl=\"yes\"])\nif test \"$enable_acl\" = \"yes\"; then\nAC_MSG_RESULT(no)\nAC_CHECK_LIB(posix1e, acl_get_file, [LIBS=\"$LIBS -lposix1e\"],\n\tAC_CHECK_LIB(acl, acl_get_file, [LIBS=\"$LIBS -lacl\"\n\t\t  AC_CHECK_LIB(attr, fgetxattr, LIBS=\"$LIBS -lattr\",,)],,),)\n\nAC_MSG_CHECKING(for POSIX ACL support)\nAC_TRY_LINK([\n#include <sys/types.h>\n#ifdef HAVE_SYS_ACL_H\n# include <sys/acl.h>\n#endif\nacl_t acl;], [acl = acl_get_file(\"foo\", ACL_TYPE_ACCESS);\n\tacl_set_file(\"foo\", ACL_TYPE_ACCESS, acl);\n\tacl_free(acl);],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_POSIX_ACL),\n\tAC_MSG_RESULT(no))\n\nAC_CHECK_LIB(sec, acl_get, [LIBS=\"$LIBS -lsec\"; AC_DEFINE(HAVE_SOLARIS_ZFS_ACL)],\nAC_MSG_CHECKING(for Solaris ACL support)\nAC_TRY_LINK([\n#ifdef HAVE_SYS_ACL_H\n# include <sys/acl.h>\n#endif], [acl(\"foo\", GETACLCNT, 0, NULL);\n\t],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_SOLARIS_ACL),\n\tAC_MSG_RESULT(no)))\n\nAC_MSG_CHECKING(for AIX ACL support)\nAC_TRY_LINK([\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\n#ifdef HAVE_SYS_ACL_H\n# include <sys/acl.h>\n#endif\n#ifdef HAVE_SYS_ACCESS_H\n# include <sys/access.h>\n#endif\n#define _ALL_SOURCE\n\n#include <sys/stat.h>\n\nint aclsize;\nstruct acl *aclent;], [aclsize = sizeof(struct acl);\n\taclent = (void *)malloc(aclsize);\n\tstatacl(\"foo\", STX_NORMAL, aclent, aclsize);\n\t],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_AIX_ACL),\n\tAC_MSG_RESULT(no))\nelse\n  AC_MSG_RESULT(yes)\nfi\n\nif test \"x$GTK_CFLAGS\" != \"x\"; then\n  dnl pango_shape_full() is new, fall back to pango_shape().\n  AC_MSG_CHECKING(for pango_shape_full)\n  ac_save_CFLAGS=\"$CFLAGS\"\n  ac_save_LIBS=\"$LIBS\"\n  CFLAGS=\"$CFLAGS $GTK_CFLAGS\"\n  LIBS=\"$LIBS $GTK_LIBS\"\n  AC_TRY_LINK(\n  [#include <gtk/gtk.h>],\n  [ pango_shape_full(NULL, 0, NULL, 0, NULL, NULL); ],\n\t  AC_MSG_RESULT(yes); AC_DEFINE(HAVE_PANGO_SHAPE_FULL),\n\t  AC_MSG_RESULT(no))\n  CFLAGS=\"$ac_save_CFLAGS\"\n  LIBS=\"$ac_save_LIBS\"\nfi\n\nAC_MSG_CHECKING(--disable-gpm argument)\nAC_ARG_ENABLE(gpm,\n\t[  --disable-gpm           Don't use gpm (Linux mouse daemon).], ,\n\t[enable_gpm=\"yes\"])\n\nif test \"$enable_gpm\" = \"yes\"; then\n  AC_MSG_RESULT(no)\n  dnl Checking if gpm support can be compiled\n  AC_CACHE_CHECK([for gpm], vi_cv_have_gpm,\n\t[olibs=\"$LIBS\" ; LIBS=\"-lgpm\"]\n\tAC_TRY_LINK(\n\t    [#include <gpm.h>\n\t    #include <linux/keyboard.h>],\n\t    [Gpm_GetLibVersion(NULL);],\n\t    dnl Configure defines HAVE_GPM, if it is defined feature.h defines\n\t    dnl FEAT_MOUSE_GPM if mouse support is included\n\t    [vi_cv_have_gpm=yes],\n\t    [vi_cv_have_gpm=no])\n\t[LIBS=\"$olibs\"]\n    )\n  if test $vi_cv_have_gpm = yes; then\n    LIBS=\"$LIBS -lgpm\"\n    AC_DEFINE(HAVE_GPM)\n  fi\nelse\n  AC_MSG_RESULT(yes)\nfi\n\nAC_MSG_CHECKING(--disable-sysmouse argument)\nAC_ARG_ENABLE(sysmouse,\n\t[  --disable-sysmouse    Don't use sysmouse (mouse in *BSD console).], ,\n\t[enable_sysmouse=\"yes\"])\n\nif test \"$enable_sysmouse\" = \"yes\"; then\n  AC_MSG_RESULT(no)\n  dnl Checking if sysmouse support can be compiled\n  dnl Configure defines HAVE_SYSMOUSE, if it is defined feature.h\n  dnl defines FEAT_SYSMOUSE if mouse support is included\n  AC_CACHE_CHECK([for sysmouse], vi_cv_have_sysmouse,\n\tAC_TRY_LINK(\n\t    [#include <sys/consio.h>\n\t     #include <signal.h>\n\t     #include <sys/fbio.h>],\n\t    [struct mouse_info   mouse;\n\t     mouse.operation = MOUSE_MODE;\n\t     mouse.operation = MOUSE_SHOW;\n\t     mouse.u.mode.mode = 0;\n\t     mouse.u.mode.signal = SIGUSR2;],\n\t    [vi_cv_have_sysmouse=yes],\n\t    [vi_cv_have_sysmouse=no])\n    )\n  if test $vi_cv_have_sysmouse = yes; then\n    AC_DEFINE(HAVE_SYSMOUSE)\n  fi\nelse\n  AC_MSG_RESULT(yes)\nfi\n\ndnl make sure the FD_CLOEXEC flag for fcntl()'s F_SETFD command is known\nAC_MSG_CHECKING(for FD_CLOEXEC)\nAC_TRY_COMPILE(\n[#if HAVE_FCNTL_H\n# include <fcntl.h>\n#endif],\n[\tint flag = FD_CLOEXEC;],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_FD_CLOEXEC),\n\tAC_MSG_RESULT(not usable))\n\ndnl rename needs to be checked separately to work on Nextstep with cc\nAC_MSG_CHECKING(for rename)\nAC_TRY_LINK([#include <stdio.h>], [rename(\"this\", \"that\")],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_RENAME),\n\tAC_MSG_RESULT(no))\n\ndnl sysctl() may exist but not the arguments we use\nAC_MSG_CHECKING(for sysctl)\nAC_TRY_COMPILE(\n[#include <sys/types.h>\n#include <sys/sysctl.h>],\n[\tint mib[2], r;\n\tsize_t len;\n\n\tmib[0] = CTL_HW;\n\tmib[1] = HW_USERMEM;\n\tlen = sizeof(r);\n\t(void)sysctl(mib, 2, &r, &len, (void *)0, (size_t)0);\n\t],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSCTL),\n\tAC_MSG_RESULT(not usable))\n\ndnl sysinfo() may exist but not be Linux compatible\nAC_MSG_CHECKING(for sysinfo)\nAC_TRY_COMPILE(\n[#include <sys/types.h>\n#include <sys/sysinfo.h>],\n[\tstruct sysinfo sinfo;\n\tint t;\n\n\t(void)sysinfo(&sinfo);\n\tt = sinfo.totalram;\n\t],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSINFO),\n\tAC_MSG_RESULT(not usable))\n\ndnl struct sysinfo may have the mem_unit field or not\nAC_MSG_CHECKING(for sysinfo.mem_unit)\nAC_TRY_COMPILE(\n[#include <sys/types.h>\n#include <sys/sysinfo.h>],\n[\tstruct sysinfo sinfo;\n\tsinfo.mem_unit = 1;\n\t],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSINFO_MEM_UNIT),\n\tAC_MSG_RESULT(no))\n\ndnl sysconf() may exist but not support what we want to use\nAC_MSG_CHECKING(for sysconf)\nAC_TRY_COMPILE(\n[#include <unistd.h>],\n[\t(void)sysconf(_SC_PAGESIZE);\n\t(void)sysconf(_SC_PHYS_PAGES);\n\t],\n\tAC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSCONF),\n\tAC_MSG_RESULT(not usable))\n\nAC_CHECK_SIZEOF([int])\nAC_CHECK_SIZEOF([long])\nAC_CHECK_SIZEOF([time_t])\nAC_CHECK_SIZEOF([off_t])\n\ndnl Use different names to avoid clashing with other header files.\nAC_DEFINE_UNQUOTED(VIM_SIZEOF_INT, [$ac_cv_sizeof_int])\nAC_DEFINE_UNQUOTED(VIM_SIZEOF_LONG, [$ac_cv_sizeof_long])\n\ndnl Make sure that uint32_t is really 32 bits unsigned.\nAC_MSG_CHECKING([uint32_t is 32 bits])\nAC_TRY_RUN([\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#ifdef HAVE_INTTYPES_H\n# include <inttypes.h>\n#endif\nmain() {\n  uint32_t nr1 = (uint32_t)-1;\n  uint32_t nr2 = (uint32_t)0xffffffffUL;\n  if (sizeof(uint32_t) != 4 || nr1 != 0xffffffffUL || nr2 + 1 != 0) exit(1);\n  exit(0);\n}],\nAC_MSG_RESULT(ok),\nAC_MSG_ERROR([WRONG!  uint32_t not defined correctly.]),\nAC_MSG_WARN([cannot check uint32_t when cross-compiling.]))\n\ndnl Check for memmove() before bcopy(), makes memmove() be used when both are\ndnl present, fixes problem with incompatibility between Solaris 2.4 and 2.5.\n\n[bcopy_test_prog='\n#include \"confdefs.h\"\n#ifdef HAVE_STRING_H\n# include <string.h>\n#endif\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#endif\nmain() {\n  char buf[10];\n  strcpy(buf, \"abcdefghi\");\n  mch_memmove(buf, buf + 2, 3);\n  if (strncmp(buf, \"ababcf\", 6))\n    exit(1);\n  strcpy(buf, \"abcdefghi\");\n  mch_memmove(buf + 2, buf, 3);\n  if (strncmp(buf, \"cdedef\", 6))\n    exit(1);\n  exit(0); /* libc version works properly.  */\n}']\n\nAC_CACHE_CHECK([whether memmove handles overlaps],[vim_cv_memmove_handles_overlap],\n  [\n    AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_memmove(s,d,l) memmove(d,s,l) $bcopy_test_prog]])],\n      [\n\tvim_cv_memmove_handles_overlap=yes\n      ],[\n\tvim_cv_memmove_handles_overlap=no\n      ],[\n\tAC_MSG_ERROR(cross-compiling: please set 'vim_cv_memmove_handles_overlap')\n      ])\n  ])\n\nif test \"x$vim_cv_memmove_handles_overlap\" = \"xyes\" ; then\n  AC_DEFINE(USEMEMMOVE)\nelse\n  AC_CACHE_CHECK([whether bcopy handles overlaps],[vim_cv_bcopy_handles_overlap],\n    [\n      AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_bcopy(s,d,l) bcopy(d,s,l) $bcopy_test_prog]])],\n      [\n\tvim_cv_bcopy_handles_overlap=yes\n      ],[\n\tvim_cv_bcopy_handles_overlap=no\n      ],[\n\tAC_MSG_ERROR(cross-compiling: please set 'vim_cv_bcopy_handles_overlap')\n      ])\n    ])\n\n  if test \"x$vim_cv_bcopy_handles_overlap\" = \"xyes\" ; then\n    AC_DEFINE(USEBCOPY)\n  else\n    AC_CACHE_CHECK([whether memcpy handles overlaps],[vim_cv_memcpy_handles_overlap],\n      [\n\tAC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_memcpy(s,d,l) memcpy(d,s,l) $bcopy_test_prog]])],\n\t  [\n\t    vim_cv_memcpy_handles_overlap=yes\n\t  ],[\n\t    vim_cv_memcpy_handles_overlap=no\n\t  ],[\n\t    AC_MSG_ERROR(cross-compiling: please set 'vim_cv_memcpy_handles_overlap')\n\t  ])\n      ])\n\n    if test \"x$vim_cv_memcpy_handles_overlap\" = \"xyes\" ; then\n      AC_DEFINE(USEMEMCPY)\n    fi\n  fi\nfi\n\n\ndnl Check for multibyte locale functions\ndnl Find out if _Xsetlocale() is supported by libX11.\ndnl Check if X_LOCALE should be defined.\nif test \"x$with_x\" = \"xyes\"; then\n  cflags_save=$CFLAGS\n  libs_save=$LIBS\n  LIBS=\"$LIBS $X_LIBS $GUI_LIB_LOC $GUI_X_LIBS $X_PRE_LIBS $X_LIB $X_EXTRA_LIBS\"\n  CFLAGS=\"$CFLAGS $X_CFLAGS\"\n\n  AC_MSG_CHECKING(whether X_LOCALE needed)\n  AC_TRY_COMPILE([#include <X11/Xlocale.h>],,\n      AC_TRY_LINK_FUNC([_Xsetlocale], [AC_MSG_RESULT(yes)\n\t      AC_DEFINE(X_LOCALE)], AC_MSG_RESULT(no)),\n      AC_MSG_RESULT(no))\n\n  AC_MSG_CHECKING(whether Xutf8SetWMProperties() can be used)\n  AC_TRY_LINK_FUNC([Xutf8SetWMProperties], [AC_MSG_RESULT(yes)\n\t      AC_DEFINE(HAVE_XUTF8SETWMPROPERTIES)], AC_MSG_RESULT(no))\n\n  CFLAGS=$cflags_save\n  LIBS=$libs_save\nfi\n\ndnl Link with xpg4, it is said to make Korean locale working\nAC_CHECK_LIB(xpg4, _xpg4_setrunelocale, [LIBS=\"$LIBS -lxpg4\"],,)\n\ndnl Check how we can run ctags.  Default to \"ctags\" when nothing works.\ndnl Use --version to detect Exuberant ctags (preferred)\ndnl       Add --fields=+S to get function signatures for omni completion.\ndnl -t for typedefs (many ctags have this)\ndnl -s for static functions (Elvis ctags only?)\ndnl -v for variables. Dangerous, most ctags take this for 'vgrind style'.\ndnl -i+m to test for older Exuberant ctags\nAC_MSG_CHECKING(how to create tags)\ntest -f tags && mv tags tags.save\nif (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then\n  TAGPRG=\"ctags -I INIT+ --fields=+S\"\nelif (eval exctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then\n  TAGPRG=\"exctags -I INIT+ --fields=+S\"\nelif (eval exuberant-ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then\n  TAGPRG=\"exuberant-ctags -I INIT+ --fields=+S\"\nelse\n  TAGPRG=\"ctags\"\n  (eval etags\t   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG=\"etags\"\n  (eval etags -c   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG=\"etags -c\"\n  (eval ctags\t   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG=\"ctags\"\n  (eval ctags -t   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG=\"ctags -t\"\n  (eval ctags -ts  /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG=\"ctags -ts\"\n  (eval ctags -tvs /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG=\"ctags -tvs\"\n  (eval ctags -i+m /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG=\"ctags -i+m\"\nfi\ntest -f tags.save && mv tags.save tags\nAC_MSG_RESULT($TAGPRG) AC_SUBST(TAGPRG)\n\ndnl Check how we can run man with a section number\nAC_MSG_CHECKING(how to run man with a section nr)\nMANDEF=\"man\"\n(eval MANPAGER=cat PAGER=cat man -s 2 read) < /dev/null > /dev/null 2>&AC_FD_CC && MANDEF=\"man -s\"\nAC_MSG_RESULT($MANDEF)\nif test \"$MANDEF\" = \"man -s\"; then\n  AC_DEFINE(USEMAN_S)\nfi\n\ndnl Check if gettext() is working and if it needs -lintl\ndnl We take care to base this on an empty LIBS: on some systems libelf would be\ndnl in LIBS and implicitly take along libintl. The final LIBS would then not\ndnl contain libintl, and the link step would fail due to -Wl,--as-needed.\nAC_MSG_CHECKING(--disable-nls argument)\nAC_ARG_ENABLE(nls,\n\t[  --disable-nls           Don't support NLS (gettext()).], ,\n\t[enable_nls=\"yes\"])\n\nif test \"$enable_nls\" = \"yes\"; then\n  AC_MSG_RESULT(no)\n\n  INSTALL_LANGS=install-languages\n  AC_SUBST(INSTALL_LANGS)\n  INSTALL_TOOL_LANGS=install-tool-languages\n  AC_SUBST(INSTALL_TOOL_LANGS)\n\n  AC_CHECK_PROG(MSGFMT, msgfmt, msgfmt, )\n  AC_MSG_CHECKING([for NLS])\n  if test -f po/Makefile; then\n    have_gettext=\"no\"\n    if test -n \"$MSGFMT\"; then\n      olibs=$LIBS\n      LIBS=\"\"\n      AC_TRY_LINK(\n\t[#include <libintl.h>],\n\t[gettext(\"Test\");],\n\tAC_MSG_RESULT([gettext() works]); have_gettext=\"yes\"; LIBS=$olibs,\n\t  LIBS=\"-lintl\"\n\t  AC_TRY_LINK(\n\t      [#include <libintl.h>],\n\t      [gettext(\"Test\");],\n\t      AC_MSG_RESULT([gettext() works with -lintl]); have_gettext=\"yes\";\n\t      LIBS=\"$olibs -lintl\",\n\t      AC_MSG_RESULT([gettext() doesn't work]);\n\t      LIBS=$olibs))\n    else\n      AC_MSG_RESULT([msgfmt not found - disabled]);\n    fi\n    if test $have_gettext = \"yes\" -a \"x$features\" != \"xtiny\" -a \"x$features\" != \"xsmall\"; then\n      AC_DEFINE(HAVE_GETTEXT)\n      MAKEMO=yes\n      AC_SUBST(MAKEMO)\n      dnl this was added in GNU gettext 0.10.36\n      AC_CHECK_FUNCS(bind_textdomain_codeset)\n      dnl _nl_msg_cat_cntr is required for GNU gettext\n      AC_MSG_CHECKING([for _nl_msg_cat_cntr])\n      AC_TRY_LINK(\n\t\t[#include <libintl.h>\n\t\textern int _nl_msg_cat_cntr;],\n\t\t[++_nl_msg_cat_cntr;],\n\t\tAC_MSG_RESULT([yes]); AC_DEFINE(HAVE_NL_MSG_CAT_CNTR),\n\t\tAC_MSG_RESULT([no]))\n    fi\n  else\n    AC_MSG_RESULT([no \"po/Makefile\" - disabled]);\n  fi\nelse\n  AC_MSG_RESULT(yes)\nfi\n\ndnl Check for dynamic linking loader\nAC_CHECK_HEADER(dlfcn.h, DLL=dlfcn.h, [AC_CHECK_HEADER(dl.h, DLL=dl.h)])\nif test x${DLL} = xdlfcn.h; then\n  AC_DEFINE(HAVE_DLFCN_H, 1, [ Define if we have dlfcn.h. ])\n  AC_MSG_CHECKING([for dlopen()])\n  AC_TRY_LINK(,[\n\t\textern void* dlopen();\n\t\tdlopen();\n      ],\n      AC_MSG_RESULT(yes);\n\t      AC_DEFINE(HAVE_DLOPEN, 1, [ Define if we have dlopen() ]),\n      AC_MSG_RESULT(no);\n\t      AC_MSG_CHECKING([for dlopen() in -ldl])\n\t      olibs=$LIBS\n\t      LIBS=\"$LIBS -ldl\"\n\t      AC_TRY_LINK(,[\n\t\t\t\textern void* dlopen();\n\t\t\t\tdlopen();\n\t\t ],\n\t\t AC_MSG_RESULT(yes);\n\t\t\t  AC_DEFINE(HAVE_DLOPEN, 1, [ Define if we have dlopen() ]),\n\t\t AC_MSG_RESULT(no);\n\t\t\t  LIBS=$olibs))\n  dnl ReliantUNIX has dlopen() in libc but everything else in libdl\n  dnl ick :-)\n  AC_MSG_CHECKING([for dlsym()])\n  AC_TRY_LINK(,[\n\t\textern void* dlsym();\n\t\tdlsym();\n      ],\n      AC_MSG_RESULT(yes);\n\t      AC_DEFINE(HAVE_DLSYM, 1, [ Define if we have dlsym() ]),\n      AC_MSG_RESULT(no);\n\t      AC_MSG_CHECKING([for dlsym() in -ldl])\n\t      olibs=$LIBS\n\t      LIBS=\"$LIBS -ldl\"\n\t      AC_TRY_LINK(,[\n\t\t\t\textern void* dlsym();\n\t\t\t\tdlsym();\n\t\t ],\n\t\t AC_MSG_RESULT(yes);\n\t\t\t  AC_DEFINE(HAVE_DLSYM, 1, [ Define if we have dlsym() ]),\n\t\t AC_MSG_RESULT(no);\n\t\t\t  LIBS=$olibs))\nelif test x${DLL} = xdl.h; then\n  AC_DEFINE(HAVE_DL_H, 1, [ Define if we have dl.h. ])\n  AC_MSG_CHECKING([for shl_load()])\n  AC_TRY_LINK(,[\n\t\textern void* shl_load();\n\t\tshl_load();\n     ],\n     AC_MSG_RESULT(yes);\n\t  AC_DEFINE(HAVE_SHL_LOAD, 1, [ Define if we have shl_load() ]),\n     AC_MSG_RESULT(no);\n\t  AC_MSG_CHECKING([for shl_load() in -ldld])\n\t  olibs=$LIBS\n\t  LIBS=\"$LIBS -ldld\"\n\t  AC_TRY_LINK(,[\n\t\t\textern void* shl_load();\n\t\t\tshl_load();\n\t     ],\n\t     AC_MSG_RESULT(yes);\n\t\t  AC_DEFINE(HAVE_SHL_LOAD, 1, [ Define if we have shl_load() ]),\n\t     AC_MSG_RESULT(no);\n\t\t  LIBS=$olibs))\nfi\nAC_CHECK_HEADERS(setjmp.h)\n\nif test \"x$MACOSX\" = \"xyes\" -a -n \"$PERL\"; then\n  dnl -ldl must come after DynaLoader.a\n  if echo $LIBS | grep -e '-ldl' >/dev/null; then\n    LIBS=`echo $LIBS | sed s/-ldl//`\n    PERL_LIBS=\"$PERL_LIBS -ldl\"\n  fi\nfi\n\nif test \"x$MACOSX\" = \"xyes\"; then\n  AC_MSG_CHECKING(whether we need -framework Cocoa)\n  dnl Cocoa is needed with FEAT_CLIPBOARD or FEAT_MBYTE (the former is\n  dnl disabled during tiny build)\n  if test \"x$features\" != \"xtiny\" || test \"x$enable_multibyte\" = \"xyes\"; then\n    LIBS=$\"$LIBS -framework Cocoa\"\n    AC_MSG_RESULT(yes)\n  else\n    AC_MSG_RESULT(no)\n  fi\n  dnl As mentioned above, tiny build implies os_macosx.m isn't needed.  \n  dnl Exclude it from OS_EXTRA_SRC so that linker won't complain about\n  dnl missing Objective-C symbols.\n  if test \"x$features\" = \"xtiny\"; then\n    OS_EXTRA_SRC=`echo \"$OS_EXTRA_SRC\" | sed -e 's+os_macosx.m++'`\n    OS_EXTRA_OBJ=`echo \"$OS_EXTRA_OBJ\" | sed -e 's+objects/os_macosx.o++'`\n  fi\nfi\nif test \"x$MACARCH\" = \"xboth\" && test \"x$GUITYPE\" = \"xCARBONGUI\"; then\n  LDFLAGS=\"$LDFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc\"\nfi\n\ndnl gcc 3.1 changed the meaning of -MM.  The only solution appears to be to\ndnl use \"-isystem\" instead of \"-I\" for all non-Vim include dirs.\ndnl But only when making dependencies, cproto and lint don't take \"-isystem\".\ndnl Mac gcc returns \"powerpc-apple-darwin8-gcc-4.0.1 (GCC)...\", need to allow\ndnl the number before the version number.\nDEPEND_CFLAGS_FILTER=\nif test \"$GCC\" = yes; then\n  AC_MSG_CHECKING(for GCC 3 or later)\n  gccmajor=`echo \"$gccversion\" | sed -e 's/^\\([[1-9]]\\)\\..*$/\\1/g'`\n  if test \"$gccmajor\" -gt \"2\"; then\n    DEPEND_CFLAGS_FILTER=\"| sed 's+-I */+-isystem /+g'\"\n    AC_MSG_RESULT(yes)\n  else\n    AC_MSG_RESULT(no)\n  fi\n  dnl -D_FORTIFY_SOURCE=2 crashes Vim on strcpy(buf, \"000\") when buf is\n  dnl declared as char x[1] but actually longer.  Introduced in gcc 4.0.\n  dnl Also remove duplicate _FORTIFY_SOURCE arguments.\n  dnl And undefine it first to avoid a warning.\n  AC_MSG_CHECKING(whether we need -D_FORTIFY_SOURCE=1)\n  if test \"$gccmajor\" -gt \"3\"; then\n    CFLAGS=`echo \"$CFLAGS\" | sed -e 's/ *-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/ *-D_FORTIFY_SOURCE=.//g' -e 's/ *-U_FORTIFY_SOURCE//g' -e 's/$/ -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1/'`\n    AC_MSG_RESULT(yes)\n  else\n    AC_MSG_RESULT(no)\n  fi\nfi\nAC_SUBST(DEPEND_CFLAGS_FILTER)\n\ndnl link.sh tries to avoid overlinking in a hackish way.\ndnl At least GNU ld supports --as-needed which provides the same functionality\ndnl at linker level. Let's use it.\nAC_MSG_CHECKING(linker --as-needed support)\nLINK_AS_NEEDED=\n# Check if linker supports --as-needed and --no-as-needed options\nif $CC -Wl,--help 2>/dev/null | grep as-needed > /dev/null; then\n  LDFLAGS=`echo \"$LDFLAGS\" | sed -e 's/ *-Wl,--as-needed//g' | sed -e 's/$/ -Wl,--as-needed/'`\n  LINK_AS_NEEDED=yes\nfi\nif test \"$LINK_AS_NEEDED\" = yes; then\n  AC_MSG_RESULT(yes)\nelse\n  AC_MSG_RESULT(no)\nfi\nAC_SUBST(LINK_AS_NEEDED)\n\n# IBM z/OS reset CFLAGS for config.mk\nif test \"$zOSUnix\" = \"yes\"; then\n\tCFLAGS=\"-D_ALL_SOURCE -Wc,float\\(ieee\\),dll\"\nfi\n\ndnl write output files\nAC_OUTPUT(auto/config.mk:config.mk.in)\n\ndnl vim: set sw=2 tw=78 fo+=l:\n",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/feature.h": "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n */\n/*\n * feature.h: Defines for optional code and preferences\n *\n * Edit this file to include/exclude parts of Vim, before compiling.\n * The only other file that may be edited is Makefile, it contains machine\n * specific options.\n *\n * To include specific options, change the \"#if*\" and \"#endif\" into comments,\n * or uncomment the \"#define\".\n * To exclude specific options, change the \"#define\" into a comment.\n */\n\n/*\n * When adding a new feature:\n * - Add a #define below.\n * - Add a message in the table above ex_version().\n * - Add a string to f_has().\n * - Add a feature to \":help feature-list\" in doc/eval.txt.\n * - Add feature to \":help +feature-list\" in doc/various.txt.\n * - Add comment for the documentation of commands that use the feature.\n */\n\n/*\n * Basic choices:\n * ==============\n *\n * +tiny\t\talmost no features enabled, not even multiple windows\n * +small\t\tfew features enabled, as basic as possible\n * +normal\t\tA default selection of features enabled\n * +big\t\t\tmany features enabled, as rich as possible.\n * +huge\t\tall possible features enabled.\n *\n * When +small is used, +tiny is also included.  +normal implies +small, etc.\n */\n\n/*\n * Uncomment one of these to override the default.  For unix use a configure\n * argument, see Makefile.\n */\n#if !defined(FEAT_TINY) && !defined(FEAT_SMALL) && !defined(FEAT_NORMAL) \\\n\t&& !defined(FEAT_BIG) && !defined(FEAT_HUGE)\n/* #define FEAT_TINY */\n/* #define FEAT_SMALL */\n/* #define FEAT_NORMAL */\n/* #define FEAT_BIG */\n/* #define FEAT_HUGE */\n#endif\n\n/*\n * For Unix, Mac and Win32 use +huge by default.  These days CPUs are fast and\n * Memory is cheap.\n * Use +big for older systems: Other MS-Windows and VMS.\n * Otherwise use +normal\n */\n#if !defined(FEAT_TINY) && !defined(FEAT_SMALL) && !defined(FEAT_NORMAL) \\\n\t&& !defined(FEAT_BIG) && !defined(FEAT_HUGE)\n# if defined(UNIX) || defined(WIN3264) || defined(MACOS)\n#  define FEAT_HUGE\n# else\n#  if defined(MSWIN) || defined(VMS) || defined(MACOS) || defined(AMIGA)\n#   define FEAT_BIG\n#  else\n#   define FEAT_NORMAL\n#  endif\n# endif\n#endif\n\n/*\n * Each feature implies including the \"smaller\" ones.\n */\n#ifdef FEAT_HUGE\n# define FEAT_BIG\n#endif\n#ifdef FEAT_BIG\n# define FEAT_NORMAL\n#endif\n#ifdef FEAT_NORMAL\n# define FEAT_SMALL\n#endif\n#ifdef FEAT_SMALL\n# define FEAT_TINY\n#endif\n\n/*\n * Optional code (see \":help +feature-list\")\n * =============\n */\n\n/*\n * +windows\t\tMultiple windows.  Without this there is no help\n *\t\t\twindow and no status lines.\n * +vertsplit\t\tVertically split windows.\n */\n#ifdef FEAT_SMALL\n# define FEAT_WINDOWS\n#endif\n\n/*\n * +listcmds\t\tVim commands for the buffer list and the argument\n *\t\t\tlist.  Without this there is no \":buffer\" \":bnext\",\n *\t\t\t\":bdel\", \":argdelete\", etc.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_LISTCMDS\n#endif\n\n/*\n * +cmdhist\t\tCommand line history.\n */\n#ifdef FEAT_SMALL\n# define FEAT_CMDHIST\n#endif\n\n/*\n * Message history is fixed at 200 message, 20 for the tiny version.\n */\n#ifdef FEAT_SMALL\n# define MAX_MSG_HIST_LEN 200\n#else\n# define MAX_MSG_HIST_LEN 20\n#endif\n\n/*\n * +jumplist\t\tJumplist, CTRL-O and CTRL-I commands.\n */\n#ifdef FEAT_SMALL\n# define FEAT_JUMPLIST\n#endif\n\n/* the cmdline-window requires FEAT_WINDOWS and FEAT_CMDHIST */\n#if defined(FEAT_WINDOWS) && defined(FEAT_CMDHIST)\n# define FEAT_CMDWIN\n#endif\n\n/*\n * +folding\t\tFold lines.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_FOLDING\n#endif\n\n/*\n * +digraphs\t\tDigraphs.\n *\t\t\tIn insert mode and on the command line you will be\n *\t\t\table to use digraphs. The CTRL-K command will work.\n *\t\t\tDefine OLD_DIGRAPHS to get digraphs compatible with\n *\t\t\tVim 5.x.  The new ones are from RFC 1345.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_DIGRAPHS\n/* #define OLD_DIGRAPHS */\n#endif\n\n/*\n * +langmap\t\t'langmap' option.  Only useful when you put your\n *\t\t\tkeyboard in a special language mode, e.g. for typing\n *\t\t\tgreek.\n */\n#ifdef FEAT_BIG\n# define FEAT_LANGMAP\n#endif\n\n/*\n * +keymap\t\t'keymap' option.  Allows you to map typed keys in\n *\t\t\tInsert mode for a special language.\n */\n#ifdef FEAT_BIG\n# define FEAT_KEYMAP\n#endif\n\n/*\n * +localmap\t\tMappings and abbreviations local to a buffer.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_LOCALMAP\n#endif\n\n/*\n * +insert_expand\tCTRL-N/CTRL-P/CTRL-X in insert mode. Takes about\n *\t\t\t4Kbyte of code.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_INS_EXPAND\n#endif\n\n/*\n * +cmdline_compl\tcompletion of mappings/abbreviations in cmdline mode.\n *\t\t\tTakes a few Kbyte of code.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_CMDL_COMPL\n#endif\n\n#ifdef FEAT_NORMAL\n# define VIM_BACKTICK\t\t/* internal backtick expansion */\n#endif\n\n/*\n * +visual\t\tVisual mode - now always included.\n * +visualextra\t\tExtra features for Visual mode (mostly block operators).\n */\n#ifdef FEAT_NORMAL\n# define FEAT_VISUALEXTRA\n#endif\n\n/*\n * +virtualedit\t\t'virtualedit' option and its implementation\n */\n#ifdef FEAT_NORMAL\n# define FEAT_VIRTUALEDIT\n#endif\n\n/*\n * +vreplace\t\t\"gR\" and \"gr\" commands.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_VREPLACE\n#endif\n\n/*\n * +cmdline_info\t'showcmd' and 'ruler' options.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_CMDL_INFO\n#endif\n\n/*\n * +linebreak\t\t'showbreak', 'breakat'  and 'linebreak' options.\n *\t\t\tAlso 'numberwidth'.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_LINEBREAK\n#endif\n\n/*\n * +extra_search\t'hlsearch' and 'incsearch' options.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_SEARCH_EXTRA\n#endif\n\n/*\n * +quickfix\t\tQuickfix commands.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_QUICKFIX\n#endif\n\n/*\n * +file_in_path\t\"gf\" and \"<cfile>\" commands.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_SEARCHPATH\n#endif\n\n/*\n * +find_in_path\t\"[I\" \":isearch\" \"^W^I\", \":checkpath\", etc.\n */\n#ifdef FEAT_NORMAL\n# ifdef FEAT_SEARCHPATH\t/* FEAT_SEARCHPATH is required */\n#  define FEAT_FIND_ID\n# endif\n#endif\n\n/*\n * +path_extra\t\tup/downwards searching in 'path' and 'tags'.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_PATH_EXTRA\n#endif\n\n/*\n * +rightleft\t\tRight-to-left editing/typing support.\n *\n * Disabled for EBCDIC as it requires multibyte.\n */\n#if defined(FEAT_BIG) && !defined(EBCDIC)\n# define FEAT_RIGHTLEFT\n#endif\n\n/*\n * +farsi\t\tFarsi (Persian language) Keymap support.\n *\t\t\tRequires FEAT_RIGHTLEFT.\n *\n * Disabled for EBCDIC as it requires multibyte.\n */\n#if defined(FEAT_BIG) && !defined(EBCDIC)\n# define FEAT_FKMAP\n#endif\n#ifdef FEAT_FKMAP\n# ifndef FEAT_RIGHTLEFT\n#   define FEAT_RIGHTLEFT\n# endif\n#endif\n\n/*\n * +arabic\t\tArabic keymap and shaping support.\n *\t\t\tRequires FEAT_RIGHTLEFT and FEAT_MBYTE.\n *\n * Disabled for EBCDIC as it requires multibyte.\n */\n#if defined(FEAT_BIG) && VIM_SIZEOF_INT >= 4 && !defined(EBCDIC)\n# define FEAT_ARABIC\n#endif\n#ifdef FEAT_ARABIC\n# ifndef FEAT_RIGHTLEFT\n#   define FEAT_RIGHTLEFT\n# endif\n#endif\n\n/*\n * +emacs_tags\t\tWhen FEAT_EMACS_TAGS defined: Include support for\n *\t\t\temacs style TAGS file.\n */\n#ifdef FEAT_BIG\n# define FEAT_EMACS_TAGS\n#endif\n\n/*\n * +tag_binary\t\tCan use a binary search for the tags file.\n *\n * Disabled for EBCDIC:\n * On z/OS Unix we have the problem that /bin/sort sorts ASCII instead of\n * EBCDIC.  With this binary search doesn't work, as VIM expects a tag file\n * sorted by character values.  I'm not sure how to fix this. Should we really\n * do a EBCDIC to ASCII conversion for this??\n */\n#if !defined(EBCDIC)\n# define FEAT_TAG_BINS\n#endif\n\n/*\n * +tag_old_static\tOld style static tags: \"file:tag  file  ..\".  Slows\n *\t\t\tdown tag searching a bit.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_TAG_OLDSTATIC\n#endif\n\n/*\n * +tag_any_white\tAllow any white space to separate the fields in a tags\n *\t\t\tfile.  When not defined, only a TAB is allowed.\n */\n/* #define FEAT_TAG_ANYWHITE */\n\n/*\n * +cscope\t\tUnix only: Cscope support.\n */\n#if defined(UNIX) && defined(FEAT_BIG) && !defined(FEAT_CSCOPE) && !defined(MACOS_X)\n# define FEAT_CSCOPE\n#endif\n\n/*\n * +eval\t\tBuilt-in script language and expression evaluation,\n *\t\t\t\":let\", \":if\", etc.\n * +float\t\tFloating point variables.\n * +num64\t\t64-bit Number.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_EVAL\n# if defined(HAVE_FLOAT_FUNCS) || defined(WIN3264) || defined(MACOS)\n#  define FEAT_FLOAT\n# endif\n# if defined(HAVE_STDINT_H) || defined(WIN3264) || (VIM_SIZEOF_LONG >= 8)\n#  define FEAT_NUM64\n# endif\n#endif\n\n/*\n * +profile\t\tProfiling for functions and scripts.\n */\n#if defined(FEAT_HUGE) \\\n\t&& defined(FEAT_EVAL) \\\n\t&& ((defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)) \\\n\t\t|| defined(WIN3264))\n# define FEAT_PROFILE\n#endif\n\n/*\n * +reltime\t\treltime() function\n */\n#if defined(FEAT_NORMAL) \\\n\t&& defined(FEAT_EVAL) \\\n\t&& ((defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)) \\\n\t\t|| defined(WIN3264))\n# define FEAT_RELTIME\n#endif\n\n/*\n * +timers\t\ttimer_start()\n */\n#if defined(FEAT_RELTIME) && (defined(UNIX) || defined(WIN32))\n# define FEAT_TIMERS\n#endif\n\n/*\n * +textobjects\t\tText objects: \"vaw\", \"das\", etc.\n */\n#if defined(FEAT_NORMAL) && defined(FEAT_EVAL)\n# define FEAT_TEXTOBJ\n#endif\n\n/*\n *\t\t\tInsert mode completion with 'completefunc'.\n */\n#if defined(FEAT_INS_EXPAND) && defined(FEAT_EVAL)\n# define FEAT_COMPL_FUNC\n#endif\n\n/*\n * +user_commands\tAllow the user to define his own commands.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_USR_CMDS\n#endif\n\n/*\n * +printer\t\t\":hardcopy\" command\n * +postscript\t\tPrinting uses PostScript file output.\n */\n#if defined(FEAT_NORMAL) && (defined(MSWIN) || defined(FEAT_EVAL)) \\\n\t&& !defined(AMIGA)\n# define FEAT_PRINTER\n#endif\n#if defined(FEAT_PRINTER) && ((defined(MSWIN) && defined(MSWINPS)) \\\n\t|| (!defined(MSWIN) && defined(FEAT_EVAL)))\n# define FEAT_POSTSCRIPT\n#endif\n\n/*\n * +modify_fname\tmodifiers for file name.  E.g., \"%:p:h\".\n */\n#ifdef FEAT_NORMAL\n# define FEAT_MODIFY_FNAME\n#endif\n\n/*\n * +autocmd\t\t\":autocmd\" command\n */\n#ifdef FEAT_NORMAL\n# define FEAT_AUTOCMD\n#endif\n\n/*\n * +diff\t\tDisplaying diffs in a nice way.\n *\t\t\tRequires +windows and +autocmd.\n */\n#if defined(FEAT_NORMAL) && defined(FEAT_WINDOWS) && defined(FEAT_AUTOCMD)\n# define FEAT_DIFF\n#endif\n\n/*\n * +title\t\t'title' and 'icon' options\n * +statusline\t\t'statusline', 'rulerformat' and special format of\n *\t\t\t'titlestring' and 'iconstring' options.\n * +byte_offset\t\t'%o' in 'statusline' and builtin functions line2byte()\n *\t\t\tand byte2line().\n *\t\t\tNote: Required for Macintosh.\n */\n#if defined(FEAT_NORMAL)\n# define FEAT_TITLE\n#endif\n\n#ifdef FEAT_NORMAL\n# define FEAT_STL_OPT\n# ifndef FEAT_CMDL_INFO\n#  define FEAT_CMDL_INFO\t/* 'ruler' is required for 'statusline' */\n# endif\n#endif\n\n#ifdef FEAT_NORMAL\n# define FEAT_BYTEOFF\n#endif\n\n/*\n * +wildignore\t\t'wildignore' and 'backupskip' options\n *\t\t\tNeeded for Unix to make \"crontab -e\" work.\n */\n#if defined(FEAT_NORMAL) || defined(UNIX)\n# define FEAT_WILDIGN\n#endif\n\n/*\n * +wildmenu\t\t'wildmenu' option\n */\n#if defined(FEAT_NORMAL) && defined(FEAT_WINDOWS)\n# define FEAT_WILDMENU\n#endif\n\n/*\n * +viminfo\t\treading/writing the viminfo file. Takes about 8Kbyte\n *\t\t\tof code.\n * VIMINFO_FILE\t\tLocation of user .viminfo file (should start with $).\n * VIMINFO_FILE2\tLocation of alternate user .viminfo file.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_VIMINFO\n/* #define VIMINFO_FILE\t\"$HOME/foo/.viminfo\" */\n/* #define VIMINFO_FILE2 \"~/bar/.viminfo\" */\n#endif\n\n/*\n * +syntax\t\tsyntax highlighting.  When using this, it's a good\n *\t\t\tidea to have +autocmd and +eval too.\n */\n#if defined(FEAT_NORMAL) || defined(PROTO)\n# define FEAT_SYN_HL\n#endif\n\n/*\n * +conceal\t\t'conceal' option.  Needs syntax highlighting\n *\t\t\tas this is how the concealed text is defined.\n */\n#if defined(FEAT_BIG) && defined(FEAT_SYN_HL)\n# define FEAT_CONCEAL\n#endif\n\n/*\n * +spell\t\tspell checking\n *\n * Disabled for EBCDIC: * Doesn't work (SIGSEGV).\n */\n#if (defined(FEAT_NORMAL) || defined(PROTO)) && !defined(EBCDIC)\n# define FEAT_SPELL\n#endif\n\n/*\n * +builtin_terms\tChoose one out of the following four:\n *\n * NO_BUILTIN_TCAPS\tDo not include any builtin termcap entries (used only\n *\t\t\twith HAVE_TGETENT defined).\n *\n * (nothing)\t\tMachine specific termcap entries will be included.\n *\n * SOME_BUILTIN_TCAPS\tInclude most useful builtin termcap entries (used only\n *\t\t\twith NO_BUILTIN_TCAPS not defined).\n *\t\t\tThis is the default.\n *\n * ALL_BUILTIN_TCAPS\tInclude all builtin termcap entries\n *\t\t\t(used only with NO_BUILTIN_TCAPS not defined).\n */\n#ifdef HAVE_TGETENT\n/* #define NO_BUILTIN_TCAPS */\n#endif\n\n#if !defined(NO_BUILTIN_TCAPS)\n# ifdef FEAT_BIG\n#  define ALL_BUILTIN_TCAPS\n# else\n#  define SOME_BUILTIN_TCAPS\t\t/* default */\n# endif\n#endif\n\n/*\n * +lispindent\t\tlisp indenting (From Eric Fischer).\n * +cindent\t\tC code indenting (From Eric Fischer).\n * +smartindent\t\tsmart C code indenting when the 'si' option is set.\n *\n * These two need to be defined when making prototypes.\n */\n#if defined(FEAT_NORMAL) || defined(PROTO)\n# define FEAT_LISP\n#endif\n\n#if defined(FEAT_NORMAL) || defined(PROTO)\n# define FEAT_CINDENT\n#endif\n\n#ifdef FEAT_NORMAL\n# define FEAT_SMARTINDENT\n#endif\n\n/*\n * +comments\t\t'comments' option.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_COMMENTS\n#endif\n\n/*\n * +cryptv\t\tEncryption (by Mohsin Ahmed <mosh@sasi.com>).\n */\n#if defined(FEAT_NORMAL) && !defined(FEAT_CRYPT) || defined(PROTO)\n# define FEAT_CRYPT\n#endif\n\n/*\n * +mksession\t\t\":mksession\" command.\n *\t\t\tRequires +windows and +vertsplit.\n */\n#if defined(FEAT_NORMAL) && defined(FEAT_WINDOWS)\n# define FEAT_SESSION\n#endif\n\n/*\n * +multi_lang\t\tMulti language support. \":menutrans\", \":language\", etc.\n * +gettext\t\tMessage translations (requires +multi_lang)\n *\t\t\t(only when \"lang\" archive unpacked)\n */\n#ifdef FEAT_NORMAL\n# define FEAT_MULTI_LANG\n#endif\n#if defined(HAVE_GETTEXT) && defined(FEAT_MULTI_LANG) \\\n\t&& (defined(HAVE_LOCALE_H) || defined(X_LOCALE))\n# define FEAT_GETTEXT\n#endif\n\n/*\n * +multi_byte\t\tGeneric multi-byte character handling.  Doesn't work\n *\t\t\twith 16 bit ints.  Required for GTK+ 2.\n *\n * Disabled for EBCDIC:\n * Multibyte support doesn't work on z/OS Unix currently.\n */\n#if (defined(FEAT_NORMAL) || defined(FEAT_GUI_GTK) || defined(FEAT_ARABIC)) \\\n\t&& !defined(FEAT_MBYTE) && VIM_SIZEOF_INT >= 4 && !defined(EBCDIC)\n# define FEAT_MBYTE\n#endif\n\n/* Define this if you want to use 16 bit Unicode only, reduces memory used for\n * the screen structures. */\n/* #define UNICODE16 */\n\n/*\n * +multi_byte_ime\tWin32 IME input method.  Requires +multi_byte.\n *\t\t\tOnly for far-east Windows, so IME can be used to input\n *\t\t\tchars.  Not tested much!\n */\n#if defined(FEAT_GUI_W32) && !defined(FEAT_MBYTE_IME)\n/* #define FEAT_MBYTE_IME */\n# endif\n\n#if defined(FEAT_MBYTE_IME) && !defined(FEAT_MBYTE)\n# define FEAT_MBYTE\n#endif\n\n#if defined(FEAT_MBYTE) && VIM_SIZEOF_INT < 4 && !defined(PROTO)\n\tError: Can only handle multi-byte feature with 32 bit int or larger\n#endif\n\n/* Use iconv() when it's available. */\n#if defined(FEAT_MBYTE) && ((defined(HAVE_ICONV_H) && defined(HAVE_ICONV)) \\\n\t\t|| defined(DYNAMIC_ICONV))\n# define USE_ICONV\n#endif\n\n/*\n * +xim\t\t\tX Input Method.  For entering special languages like\n *\t\t\tchinese and Japanese.\n * +hangul_input\tInternal Hangul input method.  Must be included\n *\t\t\tthrough configure: \"--enable-hangulin\"\n * Both are for Unix and VMS only.\n */\n#ifndef FEAT_XIM\n/* #define FEAT_XIM */\n#endif\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n# define USE_XIM 1\t\t/* needed for GTK include files */\n#endif\n\n#ifdef FEAT_HANGULIN\n# define HANGUL_DEFAULT_KEYBOARD 2\t/* 2 or 3 bulsik keyboard */\n# define ESC_CHG_TO_ENG_MODE\t\t/* if defined, when ESC pressed,\n\t\t\t\t\t * turn to english mode\n\t\t\t\t\t */\n# if defined(FEAT_XIM) && !defined(LINT)\n\tError: You should select only ONE of XIM and HANGUL INPUT\n# endif\n#endif\n#if defined(FEAT_HANGULIN) || defined(FEAT_XIM)\n/* # define X_LOCALE */\t\t\t/* for OS with incomplete locale\n\t\t\t\t\t   support, like old linux versions. */\n#endif\n\n/*\n * +xfontset\t\tX fontset support.  For outputting wide characters.\n */\n#ifndef FEAT_XFONTSET\n# if defined(FEAT_MBYTE) && defined(HAVE_X11) && !defined(FEAT_GUI_GTK)\n#  define FEAT_XFONTSET\n# else\n/* #  define FEAT_XFONTSET */\n# endif\n#endif\n\n/*\n * +libcall\t\tlibcall() function\n */\n/* Using dlopen() also requires dlsym() to be available. */\n#if defined(HAVE_DLOPEN) && defined(HAVE_DLSYM)\n# define USE_DLOPEN\n#endif\n#if defined(FEAT_EVAL) && (defined(WIN3264) || ((defined(UNIX) || defined(VMS)) \\\n\t&& (defined(USE_DLOPEN) || defined(HAVE_SHL_LOAD))))\n# define FEAT_LIBCALL\n#endif\n\n/*\n * +scrollbind\t\tsynchronization of split windows\n */\n#if defined(FEAT_NORMAL) && defined(FEAT_WINDOWS)\n# define FEAT_SCROLLBIND\n#endif\n\n/*\n * +cursorbind\t\tsynchronization of split windows\n */\n#if defined(FEAT_NORMAL) && defined(FEAT_WINDOWS)\n# define FEAT_CURSORBIND\n#endif\n\n/*\n * +menu\t\t\":menu\" command\n */\n#ifdef FEAT_NORMAL\n# define FEAT_MENU\n# ifdef FEAT_GUI_W32\n#  define FEAT_TEAROFF\n# endif\n#endif\n\n/* There are two ways to use XPM. */\n#if (defined(HAVE_XM_XPMP_H) && defined(FEAT_GUI_MOTIF)) \\\n\t\t|| defined(HAVE_X11_XPM_H)\n# define HAVE_XPM 1\n#endif\n\n/*\n * +toolbar\t\tInclude code for a toolbar (for the Win32 GUI, GTK\n *\t\t\talways has it).  But only if menus are enabled.\n */\n#if defined(FEAT_NORMAL) && defined(FEAT_MENU) \\\n\t&& (defined(FEAT_GUI_GTK) \\\n\t\t|| defined(FEAT_GUI_MSWIN) \\\n\t\t|| ((defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)) \\\n\t\t\t&& defined(HAVE_XPM)) \\\n\t\t|| defined(FEAT_GUI_PHOTON))\n# define FEAT_TOOLBAR\n#endif\n\n\n#if defined(FEAT_TOOLBAR) && !defined(FEAT_MENU)\n# define FEAT_MENU\n#endif\n\n/*\n * GUI tabline\n */\n#if defined(FEAT_WINDOWS) && defined(FEAT_NORMAL) \\\n    && (defined(FEAT_GUI_GTK) \\\n\t|| (defined(FEAT_GUI_MOTIF) && defined(HAVE_XM_NOTEBOOK_H)) \\\n\t|| defined(FEAT_GUI_MAC) \\\n\t|| (defined(FEAT_GUI_MSWIN) \\\n\t    && (!defined(_MSC_VER) || _MSC_VER > 1020)))\n# define FEAT_GUI_TABLINE\n#endif\n\n/*\n * +browse\t\t\":browse\" command.\n *\t\t\tor just the \":browse\" command modifier\n */\n#if defined(FEAT_NORMAL)\n# define FEAT_BROWSE_CMD\n# if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC)\n#  define FEAT_BROWSE\n# endif\n#endif\n\n/*\n * On some systems, when we compile with the GUI, we always use it.  On Mac\n * there is no terminal version, and on Windows we can't figure out how to\n * fork one off with :gui.\n */\n#if defined(FEAT_GUI_MSWIN) || (defined(FEAT_GUI_MAC) && !defined(MACOS_X_UNIX))\n# define ALWAYS_USE_GUI\n#endif\n\n/*\n * +dialog_gui\t\tUse GUI dialog.\n * +dialog_con\t\tMay use Console dialog.\n *\t\t\tWhen none of these defined there is no dialog support.\n */\n#ifdef FEAT_NORMAL\n# if ((defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MOTIF)) \\\n\t\t&& defined(HAVE_X11_XPM_H)) \\\n\t|| defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_GUI_PHOTON) \\\n\t|| defined(FEAT_GUI_MSWIN) \\\n\t|| defined(FEAT_GUI_MAC)\n#  define FEAT_CON_DIALOG\n#  define FEAT_GUI_DIALOG\n# else\n#  define FEAT_CON_DIALOG\n# endif\n#endif\n#if !defined(FEAT_GUI_DIALOG) && (defined(FEAT_GUI_MOTIF) \\\n\t|| defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_GUI_W32))\n/* need a dialog to show error messages when starting from the desktop */\n# define FEAT_GUI_DIALOG\n#endif\n#if defined(FEAT_GUI_DIALOG) && \\\n\t(defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA) \\\n\t || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_MSWIN) \\\n\t || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC))\n# define FEAT_GUI_TEXTDIALOG\n# ifndef ALWAYS_USE_GUI\n#  define FEAT_CON_DIALOG\n# endif\n#endif\n\n/*\n * +termguicolors\t'termguicolors' option.\n */\n#if (defined(FEAT_BIG) && defined(FEAT_SYN_HL)) && !defined(ALWAYS_USE_GUI)\n# define FEAT_TERMGUICOLORS\n#endif\n\n/* Mac specific thing: Codewarrior interface. */\n#ifdef FEAT_GUI_MAC\n# define FEAT_CW_EDITOR\n#endif\n\n/*\n * Preferences:\n * ============\n */\n\n/*\n * +writebackup\t\t'writebackup' is default on:\n *\t\t\tUse a backup file while overwriting a file.  But it's\n *\t\t\tdeleted again when 'backup' is not set.  Changing this\n *\t\t\tis strongly discouraged: You can lose all your\n *\t\t\tchanges when the computer crashes while writing the\n *\t\t\tfile.\n *\t\t\tVMS note: It does work on VMS as well, but because of\n *\t\t\tversion handling it does not have any purpose.\n *\t\t\tOverwrite will write to the new version.\n */\n#ifndef VMS\n# define FEAT_WRITEBACKUP\n#endif\n\n/*\n * +xterm_save\t\tThe t_ti and t_te entries for the builtin xterm will\n *\t\t\tbe set to save the screen when starting Vim and\n *\t\t\trestoring it when exiting.\n */\n/* #define FEAT_XTERM_SAVE */\n\n/*\n * DEBUG\t\tOutput a lot of debugging garbage.\n */\n/* #define DEBUG */\n\n/*\n * STARTUPTIME\t\tTime the startup process.  Writes a file with\n *\t\t\ttimestamps.\n */\n#if defined(FEAT_NORMAL) \\\n\t&& ((defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)) \\\n\t\t|| defined(WIN3264))\n# define STARTUPTIME 1\n#endif\n\n/*\n * MEM_PROFILE\t\tDebugging of memory allocation and freeing.\n */\n/* #define MEM_PROFILE */\n\n/*\n * VIMRC_FILE\t\tName of the .vimrc file in current dir.\n */\n/* #define VIMRC_FILE\t\".vimrc\" */\n\n/*\n * EXRC_FILE\t\tName of the .exrc file in current dir.\n */\n/* #define EXRC_FILE\t\".exrc\" */\n\n/*\n * GVIMRC_FILE\t\tName of the .gvimrc file in current dir.\n */\n/* #define GVIMRC_FILE\t\".gvimrc\" */\n\n/*\n * SESSION_FILE\t\tName of the default \":mksession\" file.\n */\n#define SESSION_FILE\t\"Session.vim\"\n\n/*\n * USR_VIMRC_FILE\tName of the user .vimrc file.\n * USR_VIMRC_FILE2\tName of alternate user .vimrc file.\n * USR_VIMRC_FILE3\tName of alternate user .vimrc file.\n */\n/* #define USR_VIMRC_FILE\t\"~/foo/.vimrc\" */\n/* #define USR_VIMRC_FILE2\t\"~/bar/.vimrc\" */\n/* #define USR_VIMRC_FILE3\t\"$VIM/.vimrc\" */\n\n/*\n * VIM_DEFAULTS_FILE\tName of the defaults.vim script file\n */\n/* #define VIM_DEFAULTS_FILE\t\"$VIMRUNTIME/defaults.vim\" */\n\n/*\n * EVIM_FILE\t\tName of the evim.vim script file\n */\n/* #define EVIM_FILE\t\t\"$VIMRUNTIME/evim.vim\" */\n\n/*\n * USR_EXRC_FILE\tName of the user .exrc file.\n * USR_EXRC_FILE2\tName of the alternate user .exrc file.\n */\n/* #define USR_EXRC_FILE\t\"~/foo/.exrc\" */\n/* #define USR_EXRC_FILE2\t\"~/bar/.exrc\" */\n\n/*\n * USR_GVIMRC_FILE\tName of the user .gvimrc file.\n * USR_GVIMRC_FILE2\tName of the alternate user .gvimrc file.\n */\n/* #define USR_GVIMRC_FILE\t\"~/foo/.gvimrc\" */\n/* #define USR_GVIMRC_FILE2\t\"~/bar/.gvimrc\" */\n/* #define USR_GVIMRC_FILE3\t\"$VIM/.gvimrc\" */\n\n/*\n * SYS_VIMRC_FILE\tName of the system-wide .vimrc file.\n */\n/* #define SYS_VIMRC_FILE\t\"/etc/vimrc\" */\n\n/*\n * SYS_GVIMRC_FILE\tName of the system-wide .gvimrc file.\n */\n/* #define SYS_GVIMRC_FILE\t\"/etc/gvimrc\" */\n\n/*\n * DFLT_HELPFILE\tName of the help file.\n */\n/* # define DFLT_HELPFILE\t\"$VIMRUNTIME/doc/help.txt.gz\" */\n\n/*\n * File names for:\n * FILETYPE_FILE\tswitch on file type detection\n * FTPLUGIN_FILE\tswitch on loading filetype plugin files\n * INDENT_FILE\t\tswitch on loading indent files\n * FTOFF_FILE\t\tswitch off file type detection\n * FTPLUGOF_FILE\tswitch off loading settings files\n * INDOFF_FILE\t\tswitch off loading indent files\n */\n/* # define FILETYPE_FILE\t\"filetype.vim\" */\n/* # define FTPLUGIN_FILE\t\"ftplugin.vim\" */\n/* # define INDENT_FILE\t\t\"indent.vim\" */\n/* # define FTOFF_FILE\t\t\"ftoff.vim\" */\n/* # define FTPLUGOF_FILE\t\"ftplugof.vim\" */\n/* # define INDOFF_FILE\t\t\"indoff.vim\" */\n\n/*\n * SYS_MENU_FILE\tName of the default menu.vim file.\n */\n/* # define SYS_MENU_FILE\t\"$VIMRUNTIME/menu.vim\" */\n\n/*\n * SYS_OPTWIN_FILE\tName of the default optwin.vim file.\n */\n#ifndef SYS_OPTWIN_FILE\n# define SYS_OPTWIN_FILE\t\"$VIMRUNTIME/optwin.vim\"\n#endif\n\n/*\n * SYNTAX_FNAME\t\tName of a syntax file, where %s is the syntax name.\n */\n/* #define SYNTAX_FNAME\t\"/foo/%s.vim\" */\n\n/*\n * RUNTIME_DIRNAME\tGeneric name for the directory of the runtime files.\n */\n#ifndef RUNTIME_DIRNAME\n# define RUNTIME_DIRNAME \"runtime\"\n#endif\n\n/*\n * RUNTIME_GLOBAL\tDirectory name for global Vim runtime directory.\n *\t\t\tDon't define this if the preprocessor can't handle\n *\t\t\tstring concatenation.\n *\t\t\tAlso set by \"--with-global-runtime\" configure argument.\n */\n/* #define RUNTIME_GLOBAL \"/etc/vim\" */\n\n/*\n * MODIFIED_BY\t\tName of who modified Vim.  Required when distributing\n *\t\t\ta modified version of Vim.\n *\t\t\tAlso from the \"--with-modified-by\" configure argument.\n */\n/* #define MODIFIED_BY \"John Doe\" */\n\n/*\n * Machine dependent:\n * ==================\n */\n\n/*\n * +fork\t\tUnix only: fork() support (detected by configure)\n * +system\t\tUse system() instead of fork/exec for starting a\n *\t\t\tshell.  Doesn't work for the GUI!\n */\n/* #define USE_SYSTEM */\n\n/*\n * +X11\t\t\tUnix only.  Include code for xterm title saving and X\n *\t\t\tclipboard.  Only works if HAVE_X11 is also defined.\n */\n#if (defined(FEAT_NORMAL) || defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA))\n# define WANT_X11\n#endif\n\n/*\n * XSMP - X11 Session Management Protocol\n * It may be preferred to disable this if the GUI supports it (e.g.,\n * GNOME/KDE) and implement save-yourself etc. through that, but it may also\n * be cleaner to have all SM-aware vims do the same thing (libSM does not\n * depend upon X11).\n * If your GUI wants to support SM itself, change this ifdef.\n * I'm assuming that any X11 implementation will cope with this for now.\n */\n#if defined(HAVE_X11) && defined(WANT_X11) && defined(HAVE_X11_SM_SMLIB_H)\n# define USE_XSMP\n#endif\n#if defined(USE_XSMP_INTERACT) && !defined(USE_XSMP)\n# undef USE_XSMP_INTERACT\n#endif\n\n/*\n * +mouse_xterm\t\tUnix only: Include code for xterm mouse handling.\n * +mouse_dec\t\tidem, for Dec mouse handling.\n * +mouse_jsbterm\tidem, for Jsbterm mouse handling.\n * +mouse_netterm\tidem, for Netterm mouse handling.\n * (none)\t\tMS-DOS mouse support.\n * +mouse_gpm\t\tUnix only: Include code for Linux console mouse\n *\t\t\thandling.\n * +mouse_pterm\t\tPTerm mouse support for QNX\n * +mouse_sgr\t\tUnix only: Include code for for SGR-styled mouse.\n * +mouse_sysmouse\tUnix only: Include code for FreeBSD and DragonFly\n *\t\t\tconsole mouse handling.\n * +mouse_urxvt\t\tUnix only: Include code for for urxvt mosue handling.\n * +mouse\t\tAny mouse support (any of the above enabled).\n */\n/* OS/2 and Amiga console have no mouse support */\n#if !defined(AMIGA)\n# ifdef FEAT_NORMAL\n#  define FEAT_MOUSE_XTERM\n# endif\n# ifdef FEAT_BIG\n#  define FEAT_MOUSE_NET\n# endif\n# ifdef FEAT_BIG\n#  define FEAT_MOUSE_DEC\n# endif\n# ifdef FEAT_BIG\n#  define FEAT_MOUSE_URXVT\n# endif\n# ifdef FEAT_BIG\n#  define FEAT_MOUSE_SGR\n# endif\n# if defined(FEAT_NORMAL) && defined(WIN3264)\n#  define DOS_MOUSE\n# endif\n# if defined(FEAT_NORMAL) && defined(__QNX__)\n#  define FEAT_MOUSE_PTERM\n# endif\n#endif\n\n/*\n * Note: Only one of the following may be defined:\n * FEAT_MOUSE_GPM\n * FEAT_SYSMOUSE\n * FEAT_MOUSE_JSB\n * FEAT_MOUSE_PTERM\n */\n#if defined(FEAT_NORMAL) && defined(HAVE_GPM)\n# define FEAT_MOUSE_GPM\n#endif\n\n#if defined(FEAT_NORMAL) && defined(HAVE_SYSMOUSE)\n# define FEAT_SYSMOUSE\n#endif\n\n/* urxvt is a small variation of mouse_xterm, and shares its code */\n#if defined(FEAT_MOUSE_URXVT) && !defined(FEAT_MOUSE_XTERM)\n# define FEAT_MOUSE_XTERM\n#endif\n\n/* sgr is a small variation of mouse_xterm, and shares its code */\n#if defined(FEAT_MOUSE_SGR) && !defined(FEAT_MOUSE_XTERM)\n# define FEAT_MOUSE_XTERM\n#endif\n\n/* Define FEAT_MOUSE when any of the above is defined or FEAT_GUI. */\n#if !defined(FEAT_MOUSE_TTY) \\\n\t&& (defined(FEAT_MOUSE_XTERM) \\\n\t    || defined(FEAT_MOUSE_NET) \\\n\t    || defined(FEAT_MOUSE_DEC) \\\n\t    || defined(DOS_MOUSE) \\\n\t    || defined(FEAT_MOUSE_GPM) \\\n\t    || defined(FEAT_MOUSE_JSB) \\\n\t    || defined(FEAT_MOUSE_PTERM) \\\n\t    || defined(FEAT_SYSMOUSE) \\\n\t    || defined(FEAT_MOUSE_URXVT) \\\n\t    || defined(FEAT_MOUSE_SGR))\n# define FEAT_MOUSE_TTY\t\t/* include non-GUI mouse support */\n#endif\n#if !defined(FEAT_MOUSE) && (defined(FEAT_MOUSE_TTY) || defined(FEAT_GUI))\n# define FEAT_MOUSE\t\t/* include generic mouse support */\n#endif\n\n/*\n * +clipboard\t\tClipboard support.  Always used for the GUI.\n * +xterm_clipboard\tUnix only: Include code for handling the clipboard\n *\t\t\tin an xterm like in the GUI.\n */\n\n#ifdef FEAT_CYGWIN_WIN32_CLIPBOARD\n# define FEAT_CLIPBOARD\n#endif\n\n#ifdef FEAT_GUI\n# ifndef FEAT_CLIPBOARD\n#  define FEAT_CLIPBOARD\n# endif\n#endif\n\n#if defined(FEAT_NORMAL) \\\n\t&& (defined(UNIX) || defined(VMS)) \\\n\t&& defined(WANT_X11) && defined(HAVE_X11)\n# define FEAT_XCLIPBOARD\n# ifndef FEAT_CLIPBOARD\n#  define FEAT_CLIPBOARD\n# endif\n#endif\n\n/*\n * +dnd\t\tDrag'n'drop support.  Always used for the GTK+ GUI.\n */\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_GUI_GTK)\n# define FEAT_DND\n#endif\n\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_SMALL)\n# define MSWIN_FIND_REPLACE\t/* include code for find/replace dialog */\n# define MSWIN_FR_BUFSIZE 256\n#endif\n\n#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_MOTIF) \\\n\t|| defined(MSWIN_FIND_REPLACE)\n# define FIND_REPLACE_DIALOG 1\n#endif\n\n/*\n * +clientserver\tRemote control via the remote_send() function\n *\t\t\tand the --remote argument\n */\n#if (defined(WIN32) || defined(FEAT_XCLIPBOARD)) && defined(FEAT_EVAL)\n# define FEAT_CLIENTSERVER\n#endif\n\n/*\n * +termresponse\tsend t_RV to obtain terminal response.  Used for xterm\n *\t\t\tto check if mouse dragging can be used and if term\n *\t\t\tcodes can be obtained.\n */\n#if (defined(FEAT_NORMAL) || defined(FEAT_MOUSE)) && defined(HAVE_TGETENT)\n# define FEAT_TERMRESPONSE\n#endif\n\n/*\n * cursor shape\t\tAdjust the shape of the cursor to the mode.\n * mouse shape\t\tAdjust the shape of the mouse pointer to the mode.\n */\n#ifdef FEAT_NORMAL\n/* MS-DOS console and Win32 console can change cursor shape */\n# if defined(WIN3264) && !defined(FEAT_GUI_W32)\n#  define MCH_CURSOR_SHAPE\n# endif\n# if defined(FEAT_GUI_W32) || defined(FEAT_GUI_MOTIF) \\\n\t|| defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_GUI_PHOTON)\n#  define FEAT_MOUSESHAPE\n# endif\n#endif\n\n/* GUI and some consoles can change the shape of the cursor.  The code is also\n * needed for the 'mouseshape' and 'concealcursor' options. */\n#if defined(FEAT_GUI) \\\n\t    || defined(MCH_CURSOR_SHAPE) \\\n\t    || defined(FEAT_MOUSESHAPE) \\\n\t    || defined(FEAT_CONCEAL) \\\n\t    || (defined(UNIX) && defined(FEAT_NORMAL))\n# define CURSOR_SHAPE\n#endif\n\n#if defined(FEAT_MZSCHEME) && (defined(FEAT_GUI_W32) || defined(FEAT_GUI_GTK)    \\\n\t|| defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)\t\\\n\t|| defined(FEAT_GUI_MAC))\n# define MZSCHEME_GUI_THREADS\n#endif\n\n/*\n * +ARP\t\t\tAmiga only. Use arp.library, DOS 2.0 is not required.\n */\n#if !defined(NO_ARP) && !defined(__amigaos4__)\n# define FEAT_ARP\n#endif\n\n/*\n * +GUI_Athena\t\tTo compile Vim with or without the GUI (gvim) you have\n * +GUI_Motif\t\tto edit the Makefile.\n */\n\n/*\n * +ole\t\t\tWin32 OLE automation: Use Makefile.ovc.\n */\n\n/*\n * These features can only be included by using a configure argument.  See the\n * Makefile for a line to uncomment.\n * +lua\t\t\tLua interface: \"--enable-luainterp\"\n * +mzscheme\t\tMzScheme interface: \"--enable-mzscheme\"\n * +perl\t\tPerl interface: \"--enable-perlinterp\"\n * +python\t\tPython interface: \"--enable-pythoninterp\"\n * +tcl\t\t\tTCL interface: \"--enable-tclinterp\"\n * +sun_workshop\tSun Workshop integration\n * +netbeans_intg\tNetbeans integration\n * +channel\t\tInter process communication\n */\n\n/*\n * These features are automatically detected:\n * +terminfo\n * +tgetent\n */\n\n/*\n * The Sun Workshop features currently only work with Motif.\n */\n#if !defined(FEAT_GUI_MOTIF) && defined(FEAT_SUN_WORKSHOP)\n# undef FEAT_SUN_WORKSHOP\n#endif\n\n/*\n * The Netbeans feature requires +listcmds and +eval.\n */\n#if (!defined(FEAT_LISTCMDS) || !defined(FEAT_EVAL)) \\\n\t&& defined(FEAT_NETBEANS_INTG)\n# undef FEAT_NETBEANS_INTG\n#endif\n\n/*\n * The +channel feature requires +eval.\n */\n#if !defined(FEAT_EVAL) && defined(FEAT_JOB_CHANNEL)\n# undef FEAT_JOB_CHANNEL\n#endif\n\n/*\n * +signs\t\tAllow signs to be displayed to the left of text lines.\n *\t\t\tAdds the \":sign\" command.\n */\n#if defined(FEAT_BIG) || defined(FEAT_SUN_WORKSHOP) \\\n\t    || defined(FEAT_NETBEANS_INTG)\n# define FEAT_SIGNS\n# if ((defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)) \\\n\t\t&& defined(HAVE_X11_XPM_H)) \\\n\t|| defined(FEAT_GUI_GTK) \\\n\t|| (defined(WIN32) && defined(FEAT_GUI))\n#  define FEAT_SIGN_ICONS\n# endif\n#endif\n\n/*\n * +balloon_eval\tAllow balloon expression evaluation. Used with a\n *\t\t\tdebugger and for tooltips.\n *\t\t\tOnly for GUIs where it was implemented.\n */\n#if (defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA) \\\n\t|| defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32)) \\\n\t&& (   ((defined(FEAT_TOOLBAR) || defined(FEAT_GUI_TABLINE)) \\\n\t\t&& !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_W32)) \\\n\t    || defined(FEAT_SUN_WORKSHOP) \\\n\t    || defined(FEAT_NETBEANS_INTG) || defined(FEAT_EVAL))\n# define FEAT_BEVAL\n# if !defined(FEAT_XFONTSET) && !defined(FEAT_GUI_GTK) \\\n\t&& !defined(FEAT_GUI_W32)\n#  define FEAT_XFONTSET\n# endif\n#endif\n\n#if defined(FEAT_BEVAL) && (defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA))\n# define FEAT_BEVAL_TIP\t\t/* balloon eval used for toolbar tooltip */\n#endif\n\n/* both Motif and Athena are X11 and share some code */\n#if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)\n# define FEAT_GUI_X11\n#endif\n\n#if defined(FEAT_SUN_WORKSHOP) || defined(FEAT_NETBEANS_INTG)\n/*\n * The following features are (currently) only used by Sun Visual WorkShop 6\n * and NetBeans. These features could be used with other integrations with\n * debuggers so I've used separate feature defines.\n */\n# if !defined(FEAT_MENU)\n#  define FEAT_MENU\n# endif\n#endif\n\n#if defined(FEAT_SUN_WORKSHOP)\n/*\n *\t\t\tUse an alternative method of X input for a secondary\n *\t\t\tcommand input.\n */\n# define ALT_X_INPUT\n\n/*\n * +footer\t\tMotif only: Add a message area at the bottom of the\n *\t\t\tmain window area.\n */\n# define FEAT_FOOTER\n\n#endif\n\n/*\n * +autochdir\t\t'autochdir' option.\n */\n#if defined(FEAT_SUN_WORKSHOP) || defined(FEAT_NETBEANS_INTG) \\\n\t    || defined(FEAT_BIG)\n# define FEAT_AUTOCHDIR\n#endif\n\n/*\n * +persistent_undo\t'undofile', 'undodir' options, :wundo and :rundo, and\n * implementation.\n */\n#ifdef FEAT_NORMAL\n# define FEAT_PERSISTENT_UNDO\n#endif\n\n/*\n * +filterpipe\n */\n#if (defined(UNIX) && !defined(USE_SYSTEM)) \\\n\t    || (defined(WIN3264) && defined(FEAT_GUI_W32))\n# define FEAT_FILTERPIPE\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/if_python.c": "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * Python extensions by Paul Moore.\n * Changes for Unix by David Leonard.\n *\n * This consists of four parts:\n * 1. Python interpreter main program\n * 2. Python output stream: writes output via [e]msg().\n * 3. Implementation of the Vim module for Python\n * 4. Utility functions for handling the interface between Vim and Python.\n */\n\n#include \"vim.h\"\n\n#include <limits.h>\n\n/* uncomment this if used with the debug version of python.\n * Checked on 2.7.4. */\n/* #define Py_DEBUG */\n/* Note: most of time you can add -DPy_DEBUG to CFLAGS in place of uncommenting\n */\n/* uncomment this if used with the debug version of python, but without its\n * allocator */\n/* #define Py_DEBUG_NO_PYMALLOC */\n\n/* Python.h defines _POSIX_THREADS itself (if needed) */\n#ifdef _POSIX_THREADS\n# undef _POSIX_THREADS\n#endif\n\n#if defined(_WIN32) && defined(HAVE_FCNTL_H)\n# undef HAVE_FCNTL_H\n#endif\n\n#ifdef _DEBUG\n# undef _DEBUG\n#endif\n\n#ifdef HAVE_STRFTIME\n# undef HAVE_STRFTIME\n#endif\n#ifdef HAVE_STRING_H\n# undef HAVE_STRING_H\n#endif\n#ifdef HAVE_PUTENV\n# undef HAVE_PUTENV\n#endif\n#ifdef HAVE_STDARG_H\n# undef HAVE_STDARG_H\t/* Python's config.h defines it as well. */\n#endif\n#ifdef _POSIX_C_SOURCE\n# undef _POSIX_C_SOURCE\t/* pyconfig.h defines it as well. */\n#endif\n#ifdef _XOPEN_SOURCE\n# undef _XOPEN_SOURCE\t/* pyconfig.h defines it as well. */\n#endif\n\n#define PY_SSIZE_T_CLEAN\n\n#include <Python.h>\n\n#if !defined(PY_VERSION_HEX) || PY_VERSION_HEX < 0x02050000\n# undef PY_SSIZE_T_CLEAN\n#endif\n\n#if defined(MACOS) && !defined(MACOS_X_UNIX)\n# include \"macglue.h\"\n# include <CodeFragments.h>\n#endif\n#undef main /* Defined in python.h - aargh */\n#undef HAVE_FCNTL_H /* Clash with os_win32.h */\n\n#define PyBytes_FromString      PyString_FromString\n#define PyBytes_Check           PyString_Check\n#define PyBytes_AsStringAndSize PyString_AsStringAndSize\n\n#if !defined(FEAT_PYTHON) && defined(PROTO)\n/* Use this to be able to generate prototypes without python being used. */\n# define PyObject Py_ssize_t\n# define PyThreadState Py_ssize_t\n# define PyTypeObject Py_ssize_t\nstruct PyMethodDef { Py_ssize_t a; };\n# define PySequenceMethods Py_ssize_t\n#endif\n\n#if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000\n# define PY_USE_CAPSULE\n#endif\n\n#if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02050000\n# define PyInt Py_ssize_t\n# define PyInquiry lenfunc\n# define PyIntArgFunc ssizeargfunc\n# define PyIntIntArgFunc ssizessizeargfunc\n# define PyIntObjArgProc ssizeobjargproc\n# define PyIntIntObjArgProc ssizessizeobjargproc\n# define Py_ssize_t_fmt \"n\"\n#else\n# define PyInt int\n# define lenfunc inquiry\n# define PyInquiry inquiry\n# define PyIntArgFunc intargfunc\n# define PyIntIntArgFunc intintargfunc\n# define PyIntObjArgProc intobjargproc\n# define PyIntIntObjArgProc intintobjargproc\n# define Py_ssize_t_fmt \"i\"\n#endif\n#define Py_bytes_fmt \"s\"\n\n/* Parser flags */\n#define single_input\t256\n#define file_input\t257\n#define eval_input\t258\n\n#if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x020300F0\n  /* Python 2.3: can invoke \":python\" recursively. */\n# define PY_CAN_RECURSE\n#endif\n\n# if defined(DYNAMIC_PYTHON) || defined(PROTO)\n#  ifndef DYNAMIC_PYTHON\n#   define HINSTANCE long_u\t\t/* for generating prototypes */\n#  endif\n\n# ifndef WIN3264\n#  include <dlfcn.h>\n#  define FARPROC void*\n#  define HINSTANCE void*\n#  if defined(PY_NO_RTLD_GLOBAL) && defined(PY3_NO_RTLD_GLOBAL)\n#   define load_dll(n) dlopen((n), RTLD_LAZY)\n#  else\n#   define load_dll(n) dlopen((n), RTLD_LAZY|RTLD_GLOBAL)\n#  endif\n#  define close_dll dlclose\n#  define symbol_from_dll dlsym\n# else\n#  define load_dll vimLoadLib\n#  define close_dll FreeLibrary\n#  define symbol_from_dll GetProcAddress\n# endif\n\n/* This makes if_python.c compile without warnings against Python 2.5\n * on Win32 and Win64. */\n# undef PyRun_SimpleString\n# undef PyRun_String\n# undef PyArg_Parse\n# undef PyArg_ParseTuple\n# undef Py_BuildValue\n# undef Py_InitModule4\n# undef Py_InitModule4_64\n# undef PyObject_CallMethod\n# undef PyObject_CallFunction\n\n/*\n * Wrapper defines\n */\n# define PyArg_Parse dll_PyArg_Parse\n# define PyArg_ParseTuple dll_PyArg_ParseTuple\n# define PyMem_Free dll_PyMem_Free\n# define PyMem_Malloc dll_PyMem_Malloc\n# define PyDict_SetItemString dll_PyDict_SetItemString\n# define PyErr_BadArgument dll_PyErr_BadArgument\n# define PyErr_NewException dll_PyErr_NewException\n# define PyErr_Clear dll_PyErr_Clear\n# define PyErr_Format dll_PyErr_Format\n# define PyErr_PrintEx dll_PyErr_PrintEx\n# define PyErr_NoMemory dll_PyErr_NoMemory\n# define PyErr_Occurred dll_PyErr_Occurred\n# define PyErr_SetNone dll_PyErr_SetNone\n# define PyErr_SetString dll_PyErr_SetString\n# define PyErr_SetObject dll_PyErr_SetObject\n# define PyErr_ExceptionMatches dll_PyErr_ExceptionMatches\n# define PyEval_InitThreads dll_PyEval_InitThreads\n# define PyEval_RestoreThread dll_PyEval_RestoreThread\n# define PyEval_SaveThread dll_PyEval_SaveThread\n# ifdef PY_CAN_RECURSE\n#  define PyGILState_Ensure dll_PyGILState_Ensure\n#  define PyGILState_Release dll_PyGILState_Release\n# endif\n# define PyInt_AsLong dll_PyInt_AsLong\n# define PyInt_FromLong dll_PyInt_FromLong\n# define PyLong_AsLong dll_PyLong_AsLong\n# define PyLong_FromLong dll_PyLong_FromLong\n# define PyBool_Type (*dll_PyBool_Type)\n# define PyInt_Type (*dll_PyInt_Type)\n# define PyLong_Type (*dll_PyLong_Type)\n# define PyList_GetItem dll_PyList_GetItem\n# define PyList_Append dll_PyList_Append\n# define PyList_Insert dll_PyList_Insert\n# define PyList_New dll_PyList_New\n# define PyList_SetItem dll_PyList_SetItem\n# define PyList_Size dll_PyList_Size\n# define PyList_Type (*dll_PyList_Type)\n# define PySequence_Check dll_PySequence_Check\n# define PySequence_Size dll_PySequence_Size\n# define PySequence_GetItem dll_PySequence_GetItem\n# define PySequence_Fast dll_PySequence_Fast\n# define PyTuple_Size dll_PyTuple_Size\n# define PyTuple_GetItem dll_PyTuple_GetItem\n# define PyTuple_Type (*dll_PyTuple_Type)\n# define PySlice_GetIndicesEx dll_PySlice_GetIndicesEx\n# define PyImport_ImportModule dll_PyImport_ImportModule\n# define PyDict_New dll_PyDict_New\n# define PyDict_GetItemString dll_PyDict_GetItemString\n# define PyDict_Next dll_PyDict_Next\n# define PyDict_Type (*dll_PyDict_Type)\n# ifdef PyMapping_Keys\n#  define PY_NO_MAPPING_KEYS\n# else\n#  define PyMapping_Keys dll_PyMapping_Keys\n# endif\n# define PyObject_GetItem dll_PyObject_GetItem\n# define PyObject_CallMethod dll_PyObject_CallMethod\n# define PyMapping_Check dll_PyMapping_Check\n# define PyIter_Next dll_PyIter_Next\n# define PyModule_GetDict dll_PyModule_GetDict\n# define PyModule_AddObject dll_PyModule_AddObject\n# define PyRun_SimpleString dll_PyRun_SimpleString\n# define PyRun_String dll_PyRun_String\n# define PyObject_GetAttrString dll_PyObject_GetAttrString\n# define PyObject_HasAttrString dll_PyObject_HasAttrString\n# define PyObject_SetAttrString dll_PyObject_SetAttrString\n# define PyObject_CallFunctionObjArgs dll_PyObject_CallFunctionObjArgs\n# define PyObject_CallFunction dll_PyObject_CallFunction\n# define PyObject_Call dll_PyObject_Call\n# define PyObject_Repr dll_PyObject_Repr\n# define PyString_AsString dll_PyString_AsString\n# define PyString_AsStringAndSize dll_PyString_AsStringAndSize\n# define PyString_FromString dll_PyString_FromString\n# define PyString_FromFormat dll_PyString_FromFormat\n# define PyString_FromStringAndSize dll_PyString_FromStringAndSize\n# define PyString_Size dll_PyString_Size\n# define PyString_Type (*dll_PyString_Type)\n# define PyUnicode_Type (*dll_PyUnicode_Type)\n# undef PyUnicode_AsEncodedString\n# define PyUnicode_AsEncodedString py_PyUnicode_AsEncodedString\n# define PyFloat_AsDouble dll_PyFloat_AsDouble\n# define PyFloat_FromDouble dll_PyFloat_FromDouble\n# define PyFloat_Type (*dll_PyFloat_Type)\n# define PyNumber_Check dll_PyNumber_Check\n# define PyNumber_Long dll_PyNumber_Long\n# define PyImport_AddModule (*dll_PyImport_AddModule)\n# define PySys_SetObject dll_PySys_SetObject\n# define PySys_GetObject dll_PySys_GetObject\n# define PySys_SetArgv dll_PySys_SetArgv\n# define PyType_Type (*dll_PyType_Type)\n# define PySlice_Type (*dll_PySlice_Type)\n# define PyType_Ready (*dll_PyType_Ready)\n# define PyType_GenericAlloc dll_PyType_GenericAlloc\n# define Py_BuildValue dll_Py_BuildValue\n# define Py_FindMethod dll_Py_FindMethod\n# define Py_InitModule4 dll_Py_InitModule4\n# define Py_SetPythonHome dll_Py_SetPythonHome\n# define Py_Initialize dll_Py_Initialize\n# define Py_Finalize dll_Py_Finalize\n# define Py_IsInitialized dll_Py_IsInitialized\n# define _PyObject_New dll__PyObject_New\n# define _PyObject_GC_New dll__PyObject_GC_New\n# ifdef PyObject_GC_Del\n#  define Py_underscore_GC\n#  define _PyObject_GC_Del dll__PyObject_GC_Del\n#  define _PyObject_GC_UnTrack dll__PyObject_GC_UnTrack\n# else\n#  define PyObject_GC_Del dll_PyObject_GC_Del\n#  define PyObject_GC_UnTrack dll_PyObject_GC_UnTrack\n# endif\n# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000\n#  define _PyObject_NextNotImplemented (*dll__PyObject_NextNotImplemented)\n# endif\n# define _Py_NoneStruct (*dll__Py_NoneStruct)\n# define _Py_ZeroStruct (*dll__Py_ZeroStruct)\n# define _Py_TrueStruct (*dll__Py_TrueStruct)\n# define PyObject_Init dll__PyObject_Init\n# define PyObject_GetIter dll_PyObject_GetIter\n# define PyObject_IsTrue dll_PyObject_IsTrue\n# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02020000\n#  define PyType_IsSubtype dll_PyType_IsSubtype\n#  ifdef Py_DEBUG\n#   define _Py_NegativeRefcount dll__Py_NegativeRefcount\n#   define _Py_RefTotal (*dll__Py_RefTotal)\n#   define _Py_Dealloc dll__Py_Dealloc\n#  endif\n# endif\n# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02030000\n#  if defined(Py_DEBUG) && !defined(Py_DEBUG_NO_PYMALLOC)\n#   define _PyObject_DebugMalloc dll__PyObject_DebugMalloc\n#   define _PyObject_DebugFree dll__PyObject_DebugFree\n#  else\n#   define PyObject_Malloc dll_PyObject_Malloc\n#   define PyObject_Free dll_PyObject_Free\n#  endif\n# endif\n# ifdef PY_USE_CAPSULE\n#  define PyCapsule_New dll_PyCapsule_New\n#  define PyCapsule_GetPointer dll_PyCapsule_GetPointer\n# else\n#  define PyCObject_FromVoidPtr dll_PyCObject_FromVoidPtr\n#  define PyCObject_AsVoidPtr dll_PyCObject_AsVoidPtr\n# endif\n# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000\n#  define Py_NoSiteFlag (*dll_Py_NoSiteFlag)\n# endif\n\n/*\n * Pointers for dynamic link\n */\nstatic int(*dll_PyArg_Parse)(PyObject *, char *, ...);\nstatic int(*dll_PyArg_ParseTuple)(PyObject *, char *, ...);\nstatic int(*dll_PyMem_Free)(void *);\nstatic void* (*dll_PyMem_Malloc)(size_t);\nstatic int(*dll_PyDict_SetItemString)(PyObject *dp, char *key, PyObject *item);\nstatic int(*dll_PyErr_BadArgument)(void);\nstatic PyObject *(*dll_PyErr_NewException)(char *, PyObject *, PyObject *);\nstatic void(*dll_PyErr_Clear)(void);\nstatic PyObject*(*dll_PyErr_Format)(PyObject *, const char *, ...);\nstatic void(*dll_PyErr_PrintEx)(int);\nstatic PyObject*(*dll_PyErr_NoMemory)(void);\nstatic PyObject*(*dll_PyErr_Occurred)(void);\nstatic void(*dll_PyErr_SetNone)(PyObject *);\nstatic void(*dll_PyErr_SetString)(PyObject *, const char *);\nstatic void(*dll_PyErr_SetObject)(PyObject *, PyObject *);\nstatic int(*dll_PyErr_ExceptionMatches)(PyObject *);\nstatic void(*dll_PyEval_InitThreads)(void);\nstatic void(*dll_PyEval_RestoreThread)(PyThreadState *);\nstatic PyThreadState*(*dll_PyEval_SaveThread)(void);\n# ifdef PY_CAN_RECURSE\nstatic PyGILState_STATE\t(*dll_PyGILState_Ensure)(void);\nstatic void (*dll_PyGILState_Release)(PyGILState_STATE);\n# endif\nstatic long(*dll_PyInt_AsLong)(PyObject *);\nstatic PyObject*(*dll_PyInt_FromLong)(long);\nstatic long(*dll_PyLong_AsLong)(PyObject *);\nstatic PyObject*(*dll_PyLong_FromLong)(long);\nstatic PyTypeObject* dll_PyBool_Type;\nstatic PyTypeObject* dll_PyInt_Type;\nstatic PyTypeObject* dll_PyLong_Type;\nstatic PyObject*(*dll_PyList_GetItem)(PyObject *, PyInt);\nstatic int(*dll_PyList_Append)(PyObject *, PyObject *);\nstatic int(*dll_PyList_Insert)(PyObject *, PyInt, PyObject *);\nstatic PyObject*(*dll_PyList_New)(PyInt size);\nstatic int(*dll_PyList_SetItem)(PyObject *, PyInt, PyObject *);\nstatic PyInt(*dll_PyList_Size)(PyObject *);\nstatic PyTypeObject* dll_PyList_Type;\nstatic int (*dll_PySequence_Check)(PyObject *);\nstatic PyInt(*dll_PySequence_Size)(PyObject *);\nstatic PyObject*(*dll_PySequence_GetItem)(PyObject *, PyInt);\nstatic PyObject*(*dll_PySequence_Fast)(PyObject *, const char *);\nstatic PyInt(*dll_PyTuple_Size)(PyObject *);\nstatic PyObject*(*dll_PyTuple_GetItem)(PyObject *, PyInt);\nstatic PyTypeObject* dll_PyTuple_Type;\nstatic int (*dll_PySlice_GetIndicesEx)(PySliceObject *r, PyInt length,\n\t\t     PyInt *start, PyInt *stop, PyInt *step,\n\t\t     PyInt *slicelen);\nstatic PyObject*(*dll_PyImport_ImportModule)(const char *);\nstatic PyObject*(*dll_PyDict_New)(void);\nstatic PyObject*(*dll_PyDict_GetItemString)(PyObject *, const char *);\nstatic int (*dll_PyDict_Next)(PyObject *, PyInt *, PyObject **, PyObject **);\nstatic PyTypeObject* dll_PyDict_Type;\n# ifndef PY_NO_MAPPING_KEYS\nstatic PyObject* (*dll_PyMapping_Keys)(PyObject *);\n# endif\nstatic PyObject* (*dll_PyObject_GetItem)(PyObject *, PyObject *);\nstatic PyObject* (*dll_PyObject_CallMethod)(PyObject *, char *, PyObject *);\nstatic int (*dll_PyMapping_Check)(PyObject *);\nstatic PyObject* (*dll_PyIter_Next)(PyObject *);\nstatic PyObject*(*dll_PyModule_GetDict)(PyObject *);\nstatic int(*dll_PyModule_AddObject)(PyObject *, const char *, PyObject *);\nstatic int(*dll_PyRun_SimpleString)(char *);\nstatic PyObject *(*dll_PyRun_String)(char *, int, PyObject *, PyObject *);\nstatic PyObject* (*dll_PyObject_GetAttrString)(PyObject *, const char *);\nstatic int (*dll_PyObject_HasAttrString)(PyObject *, const char *);\nstatic int (*dll_PyObject_SetAttrString)(PyObject *, const char *, PyObject *);\nstatic PyObject* (*dll_PyObject_CallFunctionObjArgs)(PyObject *, ...);\nstatic PyObject* (*dll_PyObject_CallFunction)(PyObject *, char *, ...);\nstatic PyObject* (*dll_PyObject_Call)(PyObject *, PyObject *, PyObject *);\nstatic PyObject* (*dll_PyObject_Repr)(PyObject *);\nstatic char*(*dll_PyString_AsString)(PyObject *);\nstatic int(*dll_PyString_AsStringAndSize)(PyObject *, char **, PyInt *);\nstatic PyObject*(*dll_PyString_FromString)(const char *);\nstatic PyObject*(*dll_PyString_FromFormat)(const char *, ...);\nstatic PyObject*(*dll_PyString_FromStringAndSize)(const char *, PyInt);\nstatic PyInt(*dll_PyString_Size)(PyObject *);\nstatic PyTypeObject* dll_PyString_Type;\nstatic PyTypeObject* dll_PyUnicode_Type;\nstatic PyObject *(*py_PyUnicode_AsEncodedString)(PyObject *, char *, char *);\nstatic double(*dll_PyFloat_AsDouble)(PyObject *);\nstatic PyObject*(*dll_PyFloat_FromDouble)(double);\nstatic PyTypeObject* dll_PyFloat_Type;\nstatic int(*dll_PyNumber_Check)(PyObject *);\nstatic PyObject*(*dll_PyNumber_Long)(PyObject *);\nstatic int(*dll_PySys_SetObject)(char *, PyObject *);\nstatic PyObject *(*dll_PySys_GetObject)(char *);\nstatic int(*dll_PySys_SetArgv)(int, char **);\nstatic PyTypeObject* dll_PyType_Type;\nstatic PyTypeObject* dll_PySlice_Type;\nstatic int (*dll_PyType_Ready)(PyTypeObject *type);\nstatic PyObject* (*dll_PyType_GenericAlloc)(PyTypeObject *type, PyInt nitems);\nstatic PyObject*(*dll_Py_BuildValue)(char *, ...);\nstatic PyObject*(*dll_Py_FindMethod)(struct PyMethodDef[], PyObject *, char *);\nstatic PyObject*(*dll_Py_InitModule4)(char *, struct PyMethodDef *, char *, PyObject *, int);\nstatic PyObject*(*dll_PyImport_AddModule)(char *);\nstatic void(*dll_Py_SetPythonHome)(char *home);\nstatic void(*dll_Py_Initialize)(void);\nstatic void(*dll_Py_Finalize)(void);\nstatic int(*dll_Py_IsInitialized)(void);\nstatic PyObject*(*dll__PyObject_New)(PyTypeObject *, PyObject *);\nstatic PyObject*(*dll__PyObject_GC_New)(PyTypeObject *);\n# ifdef Py_underscore_GC\nstatic void(*dll__PyObject_GC_Del)(void *);\nstatic void(*dll__PyObject_GC_UnTrack)(void *);\n# else\nstatic void(*dll_PyObject_GC_Del)(void *);\nstatic void(*dll_PyObject_GC_UnTrack)(void *);\n# endif\nstatic PyObject*(*dll__PyObject_Init)(PyObject *, PyTypeObject *);\nstatic PyObject* (*dll_PyObject_GetIter)(PyObject *);\nstatic int (*dll_PyObject_IsTrue)(PyObject *);\n# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000\nstatic iternextfunc dll__PyObject_NextNotImplemented;\n# endif\nstatic PyObject* dll__Py_NoneStruct;\nstatic PyObject* _Py_ZeroStruct;\nstatic PyObject* dll__Py_TrueStruct;\n# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02020000\nstatic int (*dll_PyType_IsSubtype)(PyTypeObject *, PyTypeObject *);\n#  ifdef Py_DEBUG\nstatic void (*dll__Py_NegativeRefcount)(const char *fname, int lineno, PyObject *op);\nstatic PyInt* dll__Py_RefTotal;\nstatic void (*dll__Py_Dealloc)(PyObject *obj);\n#  endif\n# endif\n# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02030000\n#  if defined(Py_DEBUG) && !defined(Py_DEBUG_NO_PYMALLOC)\nstatic void (*dll__PyObject_DebugFree)(void*);\nstatic void* (*dll__PyObject_DebugMalloc)(size_t);\n#  else\nstatic void* (*dll_PyObject_Malloc)(size_t);\nstatic void (*dll_PyObject_Free)(void*);\n#  endif\n# endif\n# ifdef PY_USE_CAPSULE\nstatic PyObject* (*dll_PyCapsule_New)(void *, char *, PyCapsule_Destructor);\nstatic void* (*dll_PyCapsule_GetPointer)(PyObject *, char *);\n# else\nstatic PyObject* (*dll_PyCObject_FromVoidPtr)(void *cobj, void (*destr)(void *));\nstatic void* (*dll_PyCObject_AsVoidPtr)(PyObject *);\n# endif\n# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000\nstatic int* dll_Py_NoSiteFlag;\n# endif\n\nstatic HINSTANCE hinstPython = 0; /* Instance of python.dll */\n\n/* Imported exception objects */\nstatic PyObject *imp_PyExc_AttributeError;\nstatic PyObject *imp_PyExc_IndexError;\nstatic PyObject *imp_PyExc_KeyError;\nstatic PyObject *imp_PyExc_KeyboardInterrupt;\nstatic PyObject *imp_PyExc_TypeError;\nstatic PyObject *imp_PyExc_ValueError;\nstatic PyObject *imp_PyExc_SystemExit;\nstatic PyObject *imp_PyExc_RuntimeError;\nstatic PyObject *imp_PyExc_ImportError;\nstatic PyObject *imp_PyExc_OverflowError;\n\n# define PyExc_AttributeError imp_PyExc_AttributeError\n# define PyExc_IndexError imp_PyExc_IndexError\n# define PyExc_KeyError imp_PyExc_KeyError\n# define PyExc_KeyboardInterrupt imp_PyExc_KeyboardInterrupt\n# define PyExc_TypeError imp_PyExc_TypeError\n# define PyExc_ValueError imp_PyExc_ValueError\n# define PyExc_SystemExit imp_PyExc_SystemExit\n# define PyExc_RuntimeError imp_PyExc_RuntimeError\n# define PyExc_ImportError imp_PyExc_ImportError\n# define PyExc_OverflowError imp_PyExc_OverflowError\n\n/*\n * Table of name to function pointer of python.\n */\n# define PYTHON_PROC FARPROC\nstatic struct\n{\n    char *name;\n    PYTHON_PROC *ptr;\n} python_funcname_table[] =\n{\n#ifndef PY_SSIZE_T_CLEAN\n    {\"PyArg_Parse\", (PYTHON_PROC*)&dll_PyArg_Parse},\n    {\"PyArg_ParseTuple\", (PYTHON_PROC*)&dll_PyArg_ParseTuple},\n    {\"Py_BuildValue\", (PYTHON_PROC*)&dll_Py_BuildValue},\n#else\n    {\"_PyArg_Parse_SizeT\", (PYTHON_PROC*)&dll_PyArg_Parse},\n    {\"_PyArg_ParseTuple_SizeT\", (PYTHON_PROC*)&dll_PyArg_ParseTuple},\n    {\"_Py_BuildValue_SizeT\", (PYTHON_PROC*)&dll_Py_BuildValue},\n#endif\n    {\"PyMem_Free\", (PYTHON_PROC*)&dll_PyMem_Free},\n    {\"PyMem_Malloc\", (PYTHON_PROC*)&dll_PyMem_Malloc},\n    {\"PyDict_SetItemString\", (PYTHON_PROC*)&dll_PyDict_SetItemString},\n    {\"PyErr_BadArgument\", (PYTHON_PROC*)&dll_PyErr_BadArgument},\n    {\"PyErr_NewException\", (PYTHON_PROC*)&dll_PyErr_NewException},\n    {\"PyErr_Clear\", (PYTHON_PROC*)&dll_PyErr_Clear},\n    {\"PyErr_Format\", (PYTHON_PROC*)&dll_PyErr_Format},\n    {\"PyErr_PrintEx\", (PYTHON_PROC*)&dll_PyErr_PrintEx},\n    {\"PyErr_NoMemory\", (PYTHON_PROC*)&dll_PyErr_NoMemory},\n    {\"PyErr_Occurred\", (PYTHON_PROC*)&dll_PyErr_Occurred},\n    {\"PyErr_SetNone\", (PYTHON_PROC*)&dll_PyErr_SetNone},\n    {\"PyErr_SetString\", (PYTHON_PROC*)&dll_PyErr_SetString},\n    {\"PyErr_SetObject\", (PYTHON_PROC*)&dll_PyErr_SetObject},\n    {\"PyErr_ExceptionMatches\", (PYTHON_PROC*)&dll_PyErr_ExceptionMatches},\n    {\"PyEval_InitThreads\", (PYTHON_PROC*)&dll_PyEval_InitThreads},\n    {\"PyEval_RestoreThread\", (PYTHON_PROC*)&dll_PyEval_RestoreThread},\n    {\"PyEval_SaveThread\", (PYTHON_PROC*)&dll_PyEval_SaveThread},\n# ifdef PY_CAN_RECURSE\n    {\"PyGILState_Ensure\", (PYTHON_PROC*)&dll_PyGILState_Ensure},\n    {\"PyGILState_Release\", (PYTHON_PROC*)&dll_PyGILState_Release},\n# endif\n    {\"PyInt_AsLong\", (PYTHON_PROC*)&dll_PyInt_AsLong},\n    {\"PyInt_FromLong\", (PYTHON_PROC*)&dll_PyInt_FromLong},\n    {\"PyLong_AsLong\", (PYTHON_PROC*)&dll_PyLong_AsLong},\n    {\"PyLong_FromLong\", (PYTHON_PROC*)&dll_PyLong_FromLong},\n    {\"PyBool_Type\", (PYTHON_PROC*)&dll_PyBool_Type},\n    {\"PyInt_Type\", (PYTHON_PROC*)&dll_PyInt_Type},\n    {\"PyLong_Type\", (PYTHON_PROC*)&dll_PyLong_Type},\n    {\"PyList_GetItem\", (PYTHON_PROC*)&dll_PyList_GetItem},\n    {\"PyList_Append\", (PYTHON_PROC*)&dll_PyList_Append},\n    {\"PyList_Insert\", (PYTHON_PROC*)&dll_PyList_Insert},\n    {\"PyList_New\", (PYTHON_PROC*)&dll_PyList_New},\n    {\"PyList_SetItem\", (PYTHON_PROC*)&dll_PyList_SetItem},\n    {\"PyList_Size\", (PYTHON_PROC*)&dll_PyList_Size},\n    {\"PyList_Type\", (PYTHON_PROC*)&dll_PyList_Type},\n    {\"PySequence_Size\", (PYTHON_PROC*)&dll_PySequence_Size},\n    {\"PySequence_Check\", (PYTHON_PROC*)&dll_PySequence_Check},\n    {\"PySequence_GetItem\", (PYTHON_PROC*)&dll_PySequence_GetItem},\n    {\"PySequence_Fast\", (PYTHON_PROC*)&dll_PySequence_Fast},\n    {\"PyTuple_GetItem\", (PYTHON_PROC*)&dll_PyTuple_GetItem},\n    {\"PyTuple_Size\", (PYTHON_PROC*)&dll_PyTuple_Size},\n    {\"PyTuple_Type\", (PYTHON_PROC*)&dll_PyTuple_Type},\n    {\"PySlice_GetIndicesEx\", (PYTHON_PROC*)&dll_PySlice_GetIndicesEx},\n    {\"PyImport_ImportModule\", (PYTHON_PROC*)&dll_PyImport_ImportModule},\n    {\"PyDict_GetItemString\", (PYTHON_PROC*)&dll_PyDict_GetItemString},\n    {\"PyDict_Next\", (PYTHON_PROC*)&dll_PyDict_Next},\n    {\"PyDict_New\", (PYTHON_PROC*)&dll_PyDict_New},\n    {\"PyDict_Type\", (PYTHON_PROC*)&dll_PyDict_Type},\n# ifndef PY_NO_MAPPING_KEYS\n    {\"PyMapping_Keys\", (PYTHON_PROC*)&dll_PyMapping_Keys},\n# endif\n    {\"PyObject_GetItem\", (PYTHON_PROC*)&dll_PyObject_GetItem},\n    {\"PyObject_CallMethod\", (PYTHON_PROC*)&dll_PyObject_CallMethod},\n    {\"PyMapping_Check\", (PYTHON_PROC*)&dll_PyMapping_Check},\n    {\"PyIter_Next\", (PYTHON_PROC*)&dll_PyIter_Next},\n    {\"PyModule_GetDict\", (PYTHON_PROC*)&dll_PyModule_GetDict},\n    {\"PyModule_AddObject\", (PYTHON_PROC*)&dll_PyModule_AddObject},\n    {\"PyRun_SimpleString\", (PYTHON_PROC*)&dll_PyRun_SimpleString},\n    {\"PyRun_String\", (PYTHON_PROC*)&dll_PyRun_String},\n    {\"PyObject_GetAttrString\", (PYTHON_PROC*)&dll_PyObject_GetAttrString},\n    {\"PyObject_HasAttrString\", (PYTHON_PROC*)&dll_PyObject_HasAttrString},\n    {\"PyObject_SetAttrString\", (PYTHON_PROC*)&dll_PyObject_SetAttrString},\n    {\"PyObject_CallFunctionObjArgs\", (PYTHON_PROC*)&dll_PyObject_CallFunctionObjArgs},\n    {\"PyObject_CallFunction\", (PYTHON_PROC*)&dll_PyObject_CallFunction},\n    {\"PyObject_Call\", (PYTHON_PROC*)&dll_PyObject_Call},\n    {\"PyObject_Repr\", (PYTHON_PROC*)&dll_PyObject_Repr},\n    {\"PyString_AsString\", (PYTHON_PROC*)&dll_PyString_AsString},\n    {\"PyString_AsStringAndSize\", (PYTHON_PROC*)&dll_PyString_AsStringAndSize},\n    {\"PyString_FromString\", (PYTHON_PROC*)&dll_PyString_FromString},\n    {\"PyString_FromFormat\", (PYTHON_PROC*)&dll_PyString_FromFormat},\n    {\"PyString_FromStringAndSize\", (PYTHON_PROC*)&dll_PyString_FromStringAndSize},\n    {\"PyString_Size\", (PYTHON_PROC*)&dll_PyString_Size},\n    {\"PyString_Type\", (PYTHON_PROC*)&dll_PyString_Type},\n    {\"PyUnicode_Type\", (PYTHON_PROC*)&dll_PyUnicode_Type},\n    {\"PyFloat_Type\", (PYTHON_PROC*)&dll_PyFloat_Type},\n    {\"PyFloat_AsDouble\", (PYTHON_PROC*)&dll_PyFloat_AsDouble},\n    {\"PyFloat_FromDouble\", (PYTHON_PROC*)&dll_PyFloat_FromDouble},\n    {\"PyImport_AddModule\", (PYTHON_PROC*)&dll_PyImport_AddModule},\n    {\"PyNumber_Check\", (PYTHON_PROC*)&dll_PyNumber_Check},\n    {\"PyNumber_Long\", (PYTHON_PROC*)&dll_PyNumber_Long},\n    {\"PySys_SetObject\", (PYTHON_PROC*)&dll_PySys_SetObject},\n    {\"PySys_GetObject\", (PYTHON_PROC*)&dll_PySys_GetObject},\n    {\"PySys_SetArgv\", (PYTHON_PROC*)&dll_PySys_SetArgv},\n    {\"PyType_Type\", (PYTHON_PROC*)&dll_PyType_Type},\n    {\"PySlice_Type\", (PYTHON_PROC*)&dll_PySlice_Type},\n    {\"PyType_Ready\", (PYTHON_PROC*)&dll_PyType_Ready},\n    {\"PyType_GenericAlloc\", (PYTHON_PROC*)&dll_PyType_GenericAlloc},\n    {\"Py_FindMethod\", (PYTHON_PROC*)&dll_Py_FindMethod},\n    {\"Py_SetPythonHome\", (PYTHON_PROC*)&dll_Py_SetPythonHome},\n    {\"Py_Initialize\", (PYTHON_PROC*)&dll_Py_Initialize},\n    {\"Py_Finalize\", (PYTHON_PROC*)&dll_Py_Finalize},\n    {\"Py_IsInitialized\", (PYTHON_PROC*)&dll_Py_IsInitialized},\n    {\"_PyObject_New\", (PYTHON_PROC*)&dll__PyObject_New},\n    {\"_PyObject_GC_New\", (PYTHON_PROC*)&dll__PyObject_GC_New},\n# ifdef Py_underscore_GC\n    {\"_PyObject_GC_Del\", (PYTHON_PROC*)&dll__PyObject_GC_Del},\n    {\"_PyObject_GC_UnTrack\", (PYTHON_PROC*)&dll__PyObject_GC_UnTrack},\n# else\n    {\"PyObject_GC_Del\", (PYTHON_PROC*)&dll_PyObject_GC_Del},\n    {\"PyObject_GC_UnTrack\", (PYTHON_PROC*)&dll_PyObject_GC_UnTrack},\n# endif\n    {\"PyObject_Init\", (PYTHON_PROC*)&dll__PyObject_Init},\n    {\"PyObject_GetIter\", (PYTHON_PROC*)&dll_PyObject_GetIter},\n    {\"PyObject_IsTrue\", (PYTHON_PROC*)&dll_PyObject_IsTrue},\n# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000\n    {\"_PyObject_NextNotImplemented\", (PYTHON_PROC*)&dll__PyObject_NextNotImplemented},\n# endif\n    {\"_Py_NoneStruct\", (PYTHON_PROC*)&dll__Py_NoneStruct},\n    {\"_Py_ZeroStruct\", (PYTHON_PROC*)&dll__Py_ZeroStruct},\n    {\"_Py_TrueStruct\", (PYTHON_PROC*)&dll__Py_TrueStruct},\n# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02020000\n#  ifdef Py_DEBUG\n    {\"_Py_NegativeRefcount\", (PYTHON_PROC*)&dll__Py_NegativeRefcount},\n    {\"_Py_RefTotal\", (PYTHON_PROC*)&dll__Py_RefTotal},\n    {\"_Py_Dealloc\", (PYTHON_PROC*)&dll__Py_Dealloc},\n#  endif\n    {\"PyType_IsSubtype\", (PYTHON_PROC*)&dll_PyType_IsSubtype},\n# endif\n# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02030000\n#  if defined(Py_DEBUG) && !defined(Py_DEBUG_NO_PYMALLOC)\n    {\"_PyObject_DebugFree\", (PYTHON_PROC*)&dll__PyObject_DebugFree},\n    {\"_PyObject_DebugMalloc\", (PYTHON_PROC*)&dll__PyObject_DebugMalloc},\n#  else\n    {\"PyObject_Malloc\", (PYTHON_PROC*)&dll_PyObject_Malloc},\n    {\"PyObject_Free\", (PYTHON_PROC*)&dll_PyObject_Free},\n#  endif\n# endif\n# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02050000 \\\n\t&& SIZEOF_SIZE_T != VIM_SIZEOF_INT\n#  ifdef Py_DEBUG\n    {\"Py_InitModule4TraceRefs_64\", (PYTHON_PROC*)&dll_Py_InitModule4},\n#  else\n    {\"Py_InitModule4_64\", (PYTHON_PROC*)&dll_Py_InitModule4},\n#  endif\n# else\n#  ifdef Py_DEBUG\n    {\"Py_InitModule4TraceRefs\", (PYTHON_PROC*)&dll_Py_InitModule4},\n#  else\n    {\"Py_InitModule4\", (PYTHON_PROC*)&dll_Py_InitModule4},\n#  endif\n# endif\n# ifdef PY_USE_CAPSULE\n    {\"PyCapsule_New\", (PYTHON_PROC*)&dll_PyCapsule_New},\n    {\"PyCapsule_GetPointer\", (PYTHON_PROC*)&dll_PyCapsule_GetPointer},\n# else\n    {\"PyCObject_FromVoidPtr\", (PYTHON_PROC*)&dll_PyCObject_FromVoidPtr},\n    {\"PyCObject_AsVoidPtr\", (PYTHON_PROC*)&dll_PyCObject_AsVoidPtr},\n# endif\n# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000\n    {\"Py_NoSiteFlag\", (PYTHON_PROC*)&dll_Py_NoSiteFlag},\n# endif\n    {\"\", NULL},\n};\n\n/*\n * Free python.dll\n */\n    static void\nend_dynamic_python(void)\n{\n    if (hinstPython)\n    {\n\tclose_dll(hinstPython);\n\thinstPython = 0;\n    }\n}\n\n/*\n * Load library and get all pointers.\n * Parameter 'libname' provides name of DLL.\n * Return OK or FAIL.\n */\n    static int\npython_runtime_link_init(char *libname, int verbose)\n{\n    int i;\n    void *ucs_as_encoded_string;\n\n#if !(defined(PY_NO_RTLD_GLOBAL) && defined(PY3_NO_RTLD_GLOBAL)) && defined(UNIX) && defined(FEAT_PYTHON3)\n    /* Can't have Python and Python3 loaded at the same time.\n     * It cause a crash, because RTLD_GLOBAL is needed for\n     * standard C extension libraries of one or both python versions. */\n    if (python3_loaded())\n    {\n\tif (verbose)\n\t    EMSG(_(\"E836: This Vim cannot execute :python after using :py3\"));\n\treturn FAIL;\n    }\n#endif\n\n    if (hinstPython)\n\treturn OK;\n    hinstPython = load_dll(libname);\n    if (!hinstPython)\n    {\n\tif (verbose)\n\t    EMSG2(_(e_loadlib), libname);\n\treturn FAIL;\n    }\n\n    for (i = 0; python_funcname_table[i].ptr; ++i)\n    {\n\tif ((*python_funcname_table[i].ptr = symbol_from_dll(hinstPython,\n\t\t\tpython_funcname_table[i].name)) == NULL)\n\t{\n\t    close_dll(hinstPython);\n\t    hinstPython = 0;\n\t    if (verbose)\n\t\tEMSG2(_(e_loadfunc), python_funcname_table[i].name);\n\t    return FAIL;\n\t}\n    }\n\n    /* Load unicode functions separately as only the ucs2 or the ucs4 functions\n     * will be present in the library. */\n    ucs_as_encoded_string = symbol_from_dll(hinstPython,\n\t\t\t\t\t     \"PyUnicodeUCS2_AsEncodedString\");\n    if (ucs_as_encoded_string == NULL)\n\tucs_as_encoded_string = symbol_from_dll(hinstPython,\n\t\t\t\t\t     \"PyUnicodeUCS4_AsEncodedString\");\n    if (ucs_as_encoded_string != NULL)\n\tpy_PyUnicode_AsEncodedString = ucs_as_encoded_string;\n    else\n    {\n\tclose_dll(hinstPython);\n\thinstPython = 0;\n\tif (verbose)\n\t    EMSG2(_(e_loadfunc), \"PyUnicode_UCSX_*\");\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * If python is enabled (there is installed python on Windows system) return\n * TRUE, else FALSE.\n */\n    int\npython_enabled(int verbose)\n{\n    return python_runtime_link_init((char *)p_pydll, verbose) == OK;\n}\n\n/*\n * Load the standard Python exceptions - don't import the symbols from the\n * DLL, as this can cause errors (importing data symbols is not reliable).\n */\n    static void\nget_exceptions(void)\n{\n    PyObject *exmod = PyImport_ImportModule(\"exceptions\");\n    PyObject *exdict = PyModule_GetDict(exmod);\n    imp_PyExc_AttributeError = PyDict_GetItemString(exdict, \"AttributeError\");\n    imp_PyExc_IndexError = PyDict_GetItemString(exdict, \"IndexError\");\n    imp_PyExc_KeyError = PyDict_GetItemString(exdict, \"KeyError\");\n    imp_PyExc_KeyboardInterrupt = PyDict_GetItemString(exdict, \"KeyboardInterrupt\");\n    imp_PyExc_TypeError = PyDict_GetItemString(exdict, \"TypeError\");\n    imp_PyExc_ValueError = PyDict_GetItemString(exdict, \"ValueError\");\n    imp_PyExc_SystemExit = PyDict_GetItemString(exdict, \"SystemExit\");\n    imp_PyExc_RuntimeError = PyDict_GetItemString(exdict, \"RuntimeError\");\n    imp_PyExc_ImportError = PyDict_GetItemString(exdict, \"ImportError\");\n    imp_PyExc_OverflowError = PyDict_GetItemString(exdict, \"OverflowError\");\n    Py_XINCREF(imp_PyExc_AttributeError);\n    Py_XINCREF(imp_PyExc_IndexError);\n    Py_XINCREF(imp_PyExc_KeyError);\n    Py_XINCREF(imp_PyExc_KeyboardInterrupt);\n    Py_XINCREF(imp_PyExc_TypeError);\n    Py_XINCREF(imp_PyExc_ValueError);\n    Py_XINCREF(imp_PyExc_SystemExit);\n    Py_XINCREF(imp_PyExc_RuntimeError);\n    Py_XINCREF(imp_PyExc_ImportError);\n    Py_XINCREF(imp_PyExc_OverflowError);\n    Py_XDECREF(exmod);\n}\n#endif /* DYNAMIC_PYTHON */\n\nstatic int initialised = 0;\n#define PYINITIALISED initialised\n\n#define DESTRUCTOR_FINISH(self) self->ob_type->tp_free((PyObject*)self);\n\n#define WIN_PYTHON_REF(win) win->w_python_ref\n#define BUF_PYTHON_REF(buf) buf->b_python_ref\n#define TAB_PYTHON_REF(tab) tab->tp_python_ref\n\nstatic PyObject *OutputGetattr(PyObject *, char *);\nstatic PyObject *BufferGetattr(PyObject *, char *);\nstatic PyObject *WindowGetattr(PyObject *, char *);\nstatic PyObject *TabPageGetattr(PyObject *, char *);\nstatic PyObject *RangeGetattr(PyObject *, char *);\nstatic PyObject *DictionaryGetattr(PyObject *, char*);\nstatic PyObject *ListGetattr(PyObject *, char *);\nstatic PyObject *FunctionGetattr(PyObject *, char *);\n\n#ifndef Py_VISIT\n# define Py_VISIT(obj) visit(obj, arg)\n#endif\n#ifndef Py_CLEAR\n# define Py_CLEAR(obj) \\\n    { \\\n\tPy_XDECREF(obj); \\\n\tobj = NULL; \\\n    }\n#endif\n\n#if defined(HAVE_LOCALE_H) || defined(X_LOCALE)\n    static void *\npy_memsave(void *p, size_t len)\n{\n    void\t*r;\n\n    if (!(r = PyMem_Malloc(len)))\n\treturn NULL;\n    mch_memmove(r, p, len);\n    return r;\n}\n\n# define PY_STRSAVE(s) ((char_u *) py_memsave(s, STRLEN(s) + 1))\n#endif\n\ntypedef PySliceObject PySliceObject_T;\n\n/*\n * Include the code shared with if_python3.c\n */\n#include \"if_py_both.h\"\n\n\n/******************************************************\n * Internal function prototypes.\n */\n\nstatic int PythonMod_Init(void);\n\n\n/******************************************************\n * 1. Python interpreter main program.\n */\n\n#if PYTHON_API_VERSION < 1007 /* Python 1.4 */\ntypedef PyObject PyThreadState;\n#endif\n\n#ifndef PY_CAN_RECURSE\nstatic PyThreadState *saved_python_thread = NULL;\n\n/*\n * Suspend a thread of the Python interpreter, other threads are allowed to\n * run.\n */\n    static void\nPython_SaveThread(void)\n{\n    saved_python_thread = PyEval_SaveThread();\n}\n\n/*\n * Restore a thread of the Python interpreter, waits for other threads to\n * block.\n */\n    static void\nPython_RestoreThread(void)\n{\n    PyEval_RestoreThread(saved_python_thread);\n    saved_python_thread = NULL;\n}\n#endif\n\n    void\npython_end(void)\n{\n    static int recurse = 0;\n\n    /* If a crash occurs while doing this, don't try again. */\n    if (recurse != 0)\n\treturn;\n\n    ++recurse;\n\n#ifdef DYNAMIC_PYTHON\n    if (hinstPython && Py_IsInitialized())\n    {\n# ifdef PY_CAN_RECURSE\n\tPyGILState_Ensure();\n# else\n\tPython_RestoreThread();\t    /* enter python */\n# endif\n\tPy_Finalize();\n    }\n    end_dynamic_python();\n#else\n    if (Py_IsInitialized())\n    {\n# ifdef PY_CAN_RECURSE\n\tPyGILState_Ensure();\n# else\n\tPython_RestoreThread();\t    /* enter python */\n# endif\n\tPy_Finalize();\n    }\n#endif\n\n    --recurse;\n}\n\n#if (defined(DYNAMIC_PYTHON) && defined(FEAT_PYTHON3)) || defined(PROTO)\n    int\npython_loaded(void)\n{\n    return (hinstPython != 0);\n}\n#endif\n\n    static int\nPython_Init(void)\n{\n    if (!initialised)\n    {\n#if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000\n\tPyObject *site;\n#endif\n\n#ifdef DYNAMIC_PYTHON\n\tif (!python_enabled(TRUE))\n\t{\n\t    EMSG(_(\"E263: Sorry, this command is disabled, the Python library could not be loaded.\"));\n\t    goto fail;\n\t}\n#endif\n\n#ifdef PYTHON_HOME\n# ifdef DYNAMIC_PYTHON\n\tif (mch_getenv((char_u *)\"PYTHONHOME\") == NULL)\n# endif\n\t    Py_SetPythonHome(PYTHON_HOME);\n#endif\n\n\tinit_structs();\n\n#if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000\n\t/* Disable implicit 'import site', because it may cause Vim to exit\n\t * when it can't be found. */\n\tPy_NoSiteFlag++;\n#endif\n\n#if !defined(MACOS) || defined(MACOS_X_UNIX)\n\tPy_Initialize();\n#else\n\tPyMac_Initialize();\n#endif\n\n#if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000\n\t/* 'import site' explicitly. */\n\tsite = PyImport_ImportModule(\"site\");\n\tif (site == NULL)\n\t{\n\t    EMSG(_(\"E887: Sorry, this command is disabled, the Python's site module could not be loaded.\"));\n\t    goto fail;\n\t}\n\tPy_DECREF(site);\n#endif\n\n\t/* Initialise threads, and below save the state using\n\t * PyEval_SaveThread.  Without the call to PyEval_SaveThread, thread\n\t * specific state (such as the system trace hook), will be lost\n\t * between invocations of Python code. */\n\tPyEval_InitThreads();\n#ifdef DYNAMIC_PYTHON\n\tget_exceptions();\n#endif\n\n\tif (PythonIO_Init_io())\n\t    goto fail;\n\n\tif (PythonMod_Init())\n\t    goto fail;\n\n\tglobals = PyModule_GetDict(PyImport_AddModule(\"__main__\"));\n\n\t/* Remove the element from sys.path that was added because of our\n\t * argv[0] value in PythonMod_Init().  Previously we used an empty\n\t * string, but depending on the OS we then get an empty entry or\n\t * the current directory in sys.path. */\n\tPyRun_SimpleString(\"import sys; sys.path = filter(lambda x: x != '/must>not&exist', sys.path)\");\n\n\t/* lock is created and acquired in PyEval_InitThreads() and thread\n\t * state is created in Py_Initialize()\n\t * there _PyGILState_NoteThreadState() also sets gilcounter to 1\n\t * (python must have threads enabled!)\n\t * so the following does both: unlock GIL and save thread state in TLS\n\t * without deleting thread state\n\t */\n#ifndef PY_CAN_RECURSE\n\tsaved_python_thread =\n#endif\n\t    PyEval_SaveThread();\n\n\tinitialised = 1;\n    }\n\n    return 0;\n\nfail:\n    /* We call PythonIO_Flush() here to print any Python errors.\n     * This is OK, as it is possible to call this function even\n     * if PythonIO_Init_io() has not completed successfully (it will\n     * not do anything in this case).\n     */\n    PythonIO_Flush();\n    return -1;\n}\n\n/*\n * External interface\n */\n    static void\nDoPyCommand(const char *cmd, rangeinitializer init_range, runner run, void *arg)\n{\n#ifndef PY_CAN_RECURSE\n    static int\t\trecursive = 0;\n#endif\n#if defined(MACOS) && !defined(MACOS_X_UNIX)\n    GrafPtr\t\toldPort;\n#endif\n#if defined(HAVE_LOCALE_H) || defined(X_LOCALE)\n    char\t\t*saved_locale;\n#endif\n#ifdef PY_CAN_RECURSE\n    PyGILState_STATE\tpygilstate;\n#endif\n\n#ifndef PY_CAN_RECURSE\n    if (recursive)\n    {\n\tEMSG(_(\"E659: Cannot invoke Python recursively\"));\n\treturn;\n    }\n    ++recursive;\n#endif\n\n#if defined(MACOS) && !defined(MACOS_X_UNIX)\n    GetPort(&oldPort);\n    /* Check if the Python library is available */\n    if ((Ptr)PyMac_Initialize == (Ptr)kUnresolvedCFragSymbolAddress)\n\tgoto theend;\n#endif\n    if (Python_Init())\n\tgoto theend;\n\n    init_range(arg);\n\n    Python_Release_Vim();\t    /* leave vim */\n\n#if defined(HAVE_LOCALE_H) || defined(X_LOCALE)\n    /* Python only works properly when the LC_NUMERIC locale is \"C\". */\n    saved_locale = setlocale(LC_NUMERIC, NULL);\n    if (saved_locale == NULL || STRCMP(saved_locale, \"C\") == 0)\n\tsaved_locale = NULL;\n    else\n    {\n\t/* Need to make a copy, value may change when setting new locale. */\n\tsaved_locale = (char *) PY_STRSAVE(saved_locale);\n\t(void)setlocale(LC_NUMERIC, \"C\");\n    }\n#endif\n\n#ifdef PY_CAN_RECURSE\n    pygilstate = PyGILState_Ensure();\n#else\n    Python_RestoreThread();\t    /* enter python */\n#endif\n\n    run((char *) cmd, arg\n#ifdef PY_CAN_RECURSE\n\t    , &pygilstate\n#endif\n\t    );\n\n#ifdef PY_CAN_RECURSE\n    PyGILState_Release(pygilstate);\n#else\n    Python_SaveThread();\t    /* leave python */\n#endif\n\n#if defined(HAVE_LOCALE_H) || defined(X_LOCALE)\n    if (saved_locale != NULL)\n    {\n\t(void)setlocale(LC_NUMERIC, saved_locale);\n\tPyMem_Free(saved_locale);\n    }\n#endif\n\n    Python_Lock_Vim();\t\t    /* enter vim */\n    PythonIO_Flush();\n#if defined(MACOS) && !defined(MACOS_X_UNIX)\n    SetPort(oldPort);\n#endif\n\ntheend:\n#ifndef PY_CAN_RECURSE\n    --recursive;\n#endif\n    return;\n}\n\n/*\n * \":python\"\n */\n    void\nex_python(exarg_T *eap)\n{\n    char_u *script;\n\n    if (p_pyx == 0)\n\tp_pyx = 2;\n\n    script = script_get(eap, eap->arg);\n    if (!eap->skip)\n    {\n\tDoPyCommand(script == NULL ? (char *) eap->arg : (char *) script,\n\t\t(rangeinitializer) init_range_cmd,\n\t\t(runner) run_cmd,\n\t\t(void *) eap);\n    }\n    vim_free(script);\n}\n\n#define BUFFER_SIZE 1024\n\n/*\n * \":pyfile\"\n */\n    void\nex_pyfile(exarg_T *eap)\n{\n    static char buffer[BUFFER_SIZE];\n    const char *file = (char *)eap->arg;\n    char *p;\n\n    if (p_pyx == 0)\n\tp_pyx = 2;\n\n    /* Have to do it like this. PyRun_SimpleFile requires you to pass a\n     * stdio file pointer, but Vim and the Python DLL are compiled with\n     * different options under Windows, meaning that stdio pointers aren't\n     * compatible between the two. Yuk.\n     *\n     * Put the string \"execfile('file')\" into buffer. But, we need to\n     * escape any backslashes or single quotes in the file name, so that\n     * Python won't mangle the file name.\n     */\n    strcpy(buffer, \"execfile('\");\n    p = buffer + 10; /* size of \"execfile('\" */\n\n    while (*file && p < buffer + (BUFFER_SIZE - 3))\n    {\n\tif (*file == '\\\\' || *file == '\\'')\n\t    *p++ = '\\\\';\n\t*p++ = *file++;\n    }\n\n    /* If we didn't finish the file name, we hit a buffer overflow */\n    if (*file != '\\0')\n\treturn;\n\n    /* Put in the terminating \"')\" and a null */\n    *p++ = '\\'';\n    *p++ = ')';\n    *p++ = '\\0';\n\n    /* Execute the file */\n    DoPyCommand(buffer,\n\t    (rangeinitializer) init_range_cmd,\n\t    (runner) run_cmd,\n\t    (void *) eap);\n}\n\n    void\nex_pydo(exarg_T *eap)\n{\n    if (p_pyx == 0)\n\tp_pyx = 2;\n\n    DoPyCommand((char *)eap->arg,\n\t    (rangeinitializer) init_range_cmd,\n\t    (runner)run_do,\n\t    (void *)eap);\n}\n\n/******************************************************\n * 2. Python output stream: writes output via [e]msg().\n */\n\n/* Implementation functions\n */\n\n    static PyObject *\nOutputGetattr(PyObject *self, char *name)\n{\n    if (strcmp(name, \"softspace\") == 0)\n\treturn PyInt_FromLong(((OutputObject *)(self))->softspace);\n    else if (strcmp(name, \"__members__\") == 0)\n\treturn ObjectDir(NULL, OutputAttrs);\n    else if (strcmp(name, \"errors\") == 0)\n\treturn PyString_FromString(\"strict\");\n    else if (strcmp(name, \"encoding\") == 0)\n\treturn PyString_FromString(ENC_OPT);\n    return Py_FindMethod(OutputMethods, self, name);\n}\n\n/******************************************************\n * 3. Implementation of the Vim module for Python\n */\n\n/* Window type - Implementation functions\n * --------------------------------------\n */\n\n#define WindowType_Check(obj) ((obj)->ob_type == &WindowType)\n\n/* Buffer type - Implementation functions\n * --------------------------------------\n */\n\n#define BufferType_Check(obj) ((obj)->ob_type == &BufferType)\n\nstatic PyInt BufferAssItem(PyObject *, PyInt, PyObject *);\nstatic PyInt BufferAssSlice(PyObject *, PyInt, PyInt, PyObject *);\n\n/* Line range type - Implementation functions\n * --------------------------------------\n */\n\n#define RangeType_Check(obj) ((obj)->ob_type == &RangeType)\n\nstatic PyInt RangeAssItem(PyObject *, PyInt, PyObject *);\nstatic PyInt RangeAssSlice(PyObject *, PyInt, PyInt, PyObject *);\n\n/* Current objects type - Implementation functions\n * -----------------------------------------------\n */\n\nstatic PySequenceMethods BufferAsSeq = {\n    (PyInquiry)\t\tBufferLength,\t    /* sq_length,    len(x)   */\n    (binaryfunc)\t0,\t\t    /* BufferConcat, sq_concat, x+y */\n    (PyIntArgFunc)\t0,\t\t    /* BufferRepeat, sq_repeat, x*n */\n    (PyIntArgFunc)\tBufferItem,\t    /* sq_item,      x[i]     */\n    (PyIntIntArgFunc)\tBufferSlice,\t    /* sq_slice,     x[i:j]   */\n    (PyIntObjArgProc)\tBufferAssItem,\t    /* sq_ass_item,  x[i]=v   */\n    (PyIntIntObjArgProc) BufferAssSlice,    /* sq_ass_slice, x[i:j]=v */\n    (objobjproc)\t0,\n    (binaryfunc)\t0,\n    0,\n};\n\n/* Buffer object - Implementation\n */\n\n    static PyObject *\nBufferGetattr(PyObject *self, char *name)\n{\n    PyObject *r;\n\n    if ((r = BufferAttrValid((BufferObject *)(self), name)))\n\treturn r;\n\n    if (CheckBuffer((BufferObject *)(self)))\n\treturn NULL;\n\n    r = BufferAttr((BufferObject *)(self), name);\n    if (r || PyErr_Occurred())\n\treturn r;\n    else\n\treturn Py_FindMethod(BufferMethods, self, name);\n}\n\n/******************/\n\n    static PyInt\nBufferAssItem(PyObject *self, PyInt n, PyObject *val)\n{\n    return RBAsItem((BufferObject *)(self), n, val, 1, -1, NULL);\n}\n\n    static PyInt\nBufferAssSlice(PyObject *self, PyInt lo, PyInt hi, PyObject *val)\n{\n    return RBAsSlice((BufferObject *)(self), lo, hi, val, 1, -1, NULL);\n}\n\nstatic PySequenceMethods RangeAsSeq = {\n    (PyInquiry)\t\tRangeLength,\t      /* sq_length,    len(x)   */\n    (binaryfunc)\t0, /* RangeConcat, */ /* sq_concat,    x+y      */\n    (PyIntArgFunc)\t0, /* RangeRepeat, */ /* sq_repeat,    x*n      */\n    (PyIntArgFunc)\tRangeItem,\t      /* sq_item,      x[i]     */\n    (PyIntIntArgFunc)\tRangeSlice,\t      /* sq_slice,     x[i:j]   */\n    (PyIntObjArgProc)\tRangeAssItem,\t      /* sq_ass_item,  x[i]=v   */\n    (PyIntIntObjArgProc) RangeAssSlice,\t      /* sq_ass_slice, x[i:j]=v */\n    (objobjproc)\t0,\n#if PY_MAJOR_VERSION >= 2\n    (binaryfunc)\t0,\n    0,\n#endif\n};\n\n/* Line range object - Implementation\n */\n\n    static PyObject *\nRangeGetattr(PyObject *self, char *name)\n{\n    if (strcmp(name, \"start\") == 0)\n\treturn Py_BuildValue(Py_ssize_t_fmt, ((RangeObject *)(self))->start - 1);\n    else if (strcmp(name, \"end\") == 0)\n\treturn Py_BuildValue(Py_ssize_t_fmt, ((RangeObject *)(self))->end - 1);\n    else if (strcmp(name, \"__members__\") == 0)\n\treturn ObjectDir(NULL, RangeAttrs);\n    else\n\treturn Py_FindMethod(RangeMethods, self, name);\n}\n\n/****************/\n\n    static PyInt\nRangeAssItem(PyObject *self, PyInt n, PyObject *val)\n{\n    return RBAsItem(((RangeObject *)(self))->buf, n, val,\n\t\t     ((RangeObject *)(self))->start,\n\t\t     ((RangeObject *)(self))->end,\n\t\t     &((RangeObject *)(self))->end);\n}\n\n    static PyInt\nRangeAssSlice(PyObject *self, PyInt lo, PyInt hi, PyObject *val)\n{\n    return RBAsSlice(((RangeObject *)(self))->buf, lo, hi, val,\n\t\t      ((RangeObject *)(self))->start,\n\t\t      ((RangeObject *)(self))->end,\n\t\t      &((RangeObject *)(self))->end);\n}\n\n/* TabPage object - Implementation\n */\n\n    static PyObject *\nTabPageGetattr(PyObject *self, char *name)\n{\n    PyObject *r;\n\n    if ((r = TabPageAttrValid((TabPageObject *)(self), name)))\n\treturn r;\n\n    if (CheckTabPage((TabPageObject *)(self)))\n\treturn NULL;\n\n    r = TabPageAttr((TabPageObject *)(self), name);\n    if (r || PyErr_Occurred())\n\treturn r;\n    else\n\treturn Py_FindMethod(TabPageMethods, self, name);\n}\n\n/* Window object - Implementation\n */\n\n    static PyObject *\nWindowGetattr(PyObject *self, char *name)\n{\n    PyObject *r;\n\n    if ((r = WindowAttrValid((WindowObject *)(self), name)))\n\treturn r;\n\n    if (CheckWindow((WindowObject *)(self)))\n\treturn NULL;\n\n    r = WindowAttr((WindowObject *)(self), name);\n    if (r || PyErr_Occurred())\n\treturn r;\n    else\n\treturn Py_FindMethod(WindowMethods, self, name);\n}\n\n/* Tab page list object - Definitions\n */\n\nstatic PySequenceMethods TabListAsSeq = {\n    (PyInquiry)\t\tTabListLength,\t    /* sq_length,    len(x)   */\n    (binaryfunc)\t0,\t\t    /* sq_concat,    x+y      */\n    (PyIntArgFunc)\t0,\t\t    /* sq_repeat,    x*n      */\n    (PyIntArgFunc)\tTabListItem,\t    /* sq_item,      x[i]     */\n    (PyIntIntArgFunc)\t0,\t\t    /* sq_slice,     x[i:j]   */\n    (PyIntObjArgProc)\t0,\t\t    /* sq_ass_item,  x[i]=v   */\n    (PyIntIntObjArgProc) 0,\t\t    /* sq_ass_slice, x[i:j]=v */\n    (objobjproc)\t0,\n#if PY_MAJOR_VERSION >= 2\n    (binaryfunc)\t0,\n    0,\n#endif\n};\n\n/* Window list object - Definitions\n */\n\nstatic PySequenceMethods WinListAsSeq = {\n    (PyInquiry)\t\tWinListLength,\t    /* sq_length,    len(x)   */\n    (binaryfunc)\t0,\t\t    /* sq_concat,    x+y      */\n    (PyIntArgFunc)\t0,\t\t    /* sq_repeat,    x*n      */\n    (PyIntArgFunc)\tWinListItem,\t    /* sq_item,      x[i]     */\n    (PyIntIntArgFunc)\t0,\t\t    /* sq_slice,     x[i:j]   */\n    (PyIntObjArgProc)\t0,\t\t    /* sq_ass_item,  x[i]=v   */\n    (PyIntIntObjArgProc) 0,\t\t    /* sq_ass_slice, x[i:j]=v */\n    (objobjproc)\t0,\n#if PY_MAJOR_VERSION >= 2\n    (binaryfunc)\t0,\n    0,\n#endif\n};\n\n/* External interface\n */\n\n    void\npython_buffer_free(buf_T *buf)\n{\n    if (BUF_PYTHON_REF(buf) != NULL)\n    {\n\tBufferObject *bp = BUF_PYTHON_REF(buf);\n\tbp->buf = INVALID_BUFFER_VALUE;\n\tBUF_PYTHON_REF(buf) = NULL;\n    }\n}\n\n#if defined(FEAT_WINDOWS) || defined(PROTO)\n    void\npython_window_free(win_T *win)\n{\n    if (WIN_PYTHON_REF(win) != NULL)\n    {\n\tWindowObject *wp = WIN_PYTHON_REF(win);\n\twp->win = INVALID_WINDOW_VALUE;\n\tWIN_PYTHON_REF(win) = NULL;\n    }\n}\n\n    void\npython_tabpage_free(tabpage_T *tab)\n{\n    if (TAB_PYTHON_REF(tab) != NULL)\n    {\n\tTabPageObject *tp = TAB_PYTHON_REF(tab);\n\ttp->tab = INVALID_TABPAGE_VALUE;\n\tTAB_PYTHON_REF(tab) = NULL;\n    }\n}\n#endif\n\n    static int\nPythonMod_Init(void)\n{\n    /* The special value is removed from sys.path in Python_Init(). */\n    static char\t*(argv[2]) = {\"/must>not&exist/foo\", NULL};\n\n    if (init_types())\n\treturn -1;\n\n    /* Set sys.argv[] to avoid a crash in warn(). */\n    PySys_SetArgv(1, argv);\n\n    vim_module = Py_InitModule4(\"vim\", VimMethods, (char *)NULL,\n\t\t\t\t(PyObject *)NULL, PYTHON_API_VERSION);\n\n    if (populate_module(vim_module))\n\treturn -1;\n\n    if (init_sys_path())\n\treturn -1;\n\n    return 0;\n}\n\n/*************************************************************************\n * 4. Utility functions for handling the interface between Vim and Python.\n */\n\n/* Convert a Vim line into a Python string.\n * All internal newlines are replaced by null characters.\n *\n * On errors, the Python exception data is set, and NULL is returned.\n */\n    static PyObject *\nLineToString(const char *str)\n{\n    PyObject *result;\n    PyInt len = strlen(str);\n    char *p;\n\n    /* Allocate an Python string object, with uninitialised contents. We\n     * must do it this way, so that we can modify the string in place\n     * later. See the Python source, Objects/stringobject.c for details.\n     */\n    result = PyString_FromStringAndSize(NULL, len);\n    if (result == NULL)\n\treturn NULL;\n\n    p = PyString_AsString(result);\n\n    while (*str)\n    {\n\tif (*str == '\\n')\n\t    *p = '\\0';\n\telse\n\t    *p = *str;\n\n\t++p;\n\t++str;\n    }\n\n    return result;\n}\n\n    static PyObject *\nDictionaryGetattr(PyObject *self, char *name)\n{\n    DictionaryObject\t*this = ((DictionaryObject *) (self));\n\n    if (strcmp(name, \"locked\") == 0)\n\treturn PyInt_FromLong(this->dict->dv_lock);\n    else if (strcmp(name, \"scope\") == 0)\n\treturn PyInt_FromLong(this->dict->dv_scope);\n    else if (strcmp(name, \"__members__\") == 0)\n\treturn ObjectDir(NULL, DictionaryAttrs);\n\n    return Py_FindMethod(DictionaryMethods, self, name);\n}\n\n    static PyObject *\nListGetattr(PyObject *self, char *name)\n{\n    if (strcmp(name, \"locked\") == 0)\n\treturn PyInt_FromLong(((ListObject *)(self))->list->lv_lock);\n    else if (strcmp(name, \"__members__\") == 0)\n\treturn ObjectDir(NULL, ListAttrs);\n\n    return Py_FindMethod(ListMethods, self, name);\n}\n\n    static PyObject *\nFunctionGetattr(PyObject *self, char *name)\n{\n    PyObject\t*r;\n\n    r = FunctionAttr((FunctionObject *)(self), name);\n\n    if (r || PyErr_Occurred())\n\treturn r;\n    else\n\treturn Py_FindMethod(FunctionMethods, self, name);\n}\n\n    void\ndo_pyeval (char_u *str, typval_T *rettv)\n{\n    DoPyCommand((char *) str,\n\t    (rangeinitializer) init_range_eval,\n\t    (runner) run_eval,\n\t    (void *) rettv);\n    switch(rettv->v_type)\n    {\n\tcase VAR_DICT: ++rettv->vval.v_dict->dv_refcount; break;\n\tcase VAR_LIST: ++rettv->vval.v_list->lv_refcount; break;\n\tcase VAR_FUNC: func_ref(rettv->vval.v_string);    break;\n\tcase VAR_PARTIAL: ++rettv->vval.v_partial->pt_refcount; break;\n\tcase VAR_UNKNOWN:\n\t    rettv->v_type = VAR_NUMBER;\n\t    rettv->vval.v_number = 0;\n\t    break;\n\tcase VAR_NUMBER:\n\tcase VAR_STRING:\n\tcase VAR_FLOAT:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\t    break;\n    }\n}\n\n/* Don't generate a prototype for the next function, it generates an error on\n * newer Python versions. */\n#if PYTHON_API_VERSION < 1007 /* Python 1.4 */ && !defined(PROTO)\n\n    char *\nPy_GetProgramName(void)\n{\n    return \"vim\";\n}\n#endif /* Python 1.4 */\n\n    int\nset_ref_in_python (int copyID)\n{\n    return set_ref_in_py(copyID);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/if_perl.xs": "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n */\n/*\n * if_perl.xs: Main code for Perl interface support.\n *\t\tMostly written by Sven Verdoolaege.\n */\n\n#define _memory_h\t/* avoid memset redeclaration */\n#define IN_PERL_FILE\t/* don't include if_perl.pro from proto.h */\n\n/*\n * Currently 32-bit version of ActivePerl is built with VC6 (or MinGW since\n * ActivePerl 5.18).\n * (http://community.activestate.com/faq/windows-compilers-perl-modules)\n * It means that time_t should be 32-bit. However the default size of\n * time_t is 64-bit since VC8. So we have to define _USE_32BIT_TIME_T.\n */\n#if defined(WIN32) && !defined(_WIN64)\n# define _USE_32BIT_TIME_T\n#endif\n\n/*\n * Prevent including winsock.h.  perl.h tries to detect whether winsock.h is\n * already included before including winsock2.h, because winsock2.h isn't\n * compatible with winsock.h.  However the detection doesn't work with some\n * versions of MinGW.  If WIN32_LEAN_AND_MEAN is defined, windows.h will not\n * include winsock.h.\n */\n#ifdef WIN32\n# define WIN32_LEAN_AND_MEAN\n#endif\n\n#include \"vim.h\"\n\n/* Work around for perl-5.18.\n * Don't include \"perl\\lib\\CORE\\inline.h\" for now,\n * include it after Perl_sv_free2 is defined. */\n#ifdef DYNAMIC_PERL\n# define PERL_NO_INLINE_FUNCTIONS\n#endif\n\n/* Work around for using MSVC and ActivePerl 5.18. */\n#ifdef _MSC_VER\n# define __inline__ __inline\n#endif\n\n#ifdef __GNUC__\n# pragma GCC diagnostic push\n# pragma GCC diagnostic ignored \"-Wunused-variable\"\n#endif\n\n#include <EXTERN.h>\n#include <perl.h>\n#include <XSUB.h>\n#if defined(PERLIO_LAYERS) && !defined(USE_SFIO)\n# include <perliol.h>\n#endif\n\n/* Workaround for perl < 5.8.7 */\n#ifndef PERLIO_FUNCS_DECL\n# ifdef PERLIO_FUNCS_CONST\n#  define PERLIO_FUNCS_DECL(funcs) const PerlIO_funcs funcs\n#  define PERLIO_FUNCS_CAST(funcs) (PerlIO_funcs*)(funcs)\n# else\n#  define PERLIO_FUNCS_DECL(funcs) PerlIO_funcs funcs\n#  define PERLIO_FUNCS_CAST(funcs) (funcs)\n# endif\n#endif\n#ifndef SvREFCNT_inc_void_NN\n# define SvREFCNT_inc_void_NN SvREFCNT_inc\n#endif\n\n/*\n * Work around clashes between Perl and Vim namespace.\tproto.h doesn't\n * include if_perl.pro and perlsfio.pro when IN_PERL_FILE is defined, because\n * we need the CV typedef.  proto.h can't be moved to after including\n * if_perl.h, because we get all sorts of name clashes then.\n */\n#ifndef PROTO\n# ifndef __MINGW32__\n#  include \"proto/if_perl.pro\"\n#  include \"proto/if_perlsfio.pro\"\n# endif\n#endif\n\n/* Perl compatibility stuff. This should ensure compatibility with older\n * versions of Perl.\n */\n\n#ifndef PERL_VERSION\n# include <patchlevel.h>\n# define PERL_REVISION   5\n# define PERL_VERSION    PATCHLEVEL\n# define PERL_SUBVERSION SUBVERSION\n#endif\n\n/*\n * Quoting Jan Dubois of Active State:\n *    ActivePerl build 822 still identifies itself as 5.8.8 but already\n *    contains many of the changes from the upcoming Perl 5.8.9 release.\n *\n * The changes include addition of two symbols (Perl_sv_2iv_flags,\n * Perl_newXS_flags) not present in earlier releases.\n *\n * Jan Dubois suggested the following guarding scheme.\n *\n * Active State defined ACTIVEPERL_VERSION as a string in versions before\n * 5.8.8; and so the comparison to 822 below needs to be guarded.\n */\n#if (PERL_REVISION == 5) && (PERL_VERSION == 8) && (PERL_SUBVERSION >= 8)\n# if (ACTIVEPERL_VERSION >= 822) || (PERL_SUBVERSION >= 9)\n#  define PERL589_OR_LATER\n# endif\n#endif\n#if (PERL_REVISION == 5) && (PERL_VERSION >= 9)\n# define PERL589_OR_LATER\n#endif\n\n#if (PERL_REVISION == 5) && ((PERL_VERSION > 10) || \\\n    (PERL_VERSION == 10) && (PERL_SUBVERSION >= 1))\n# define PERL5101_OR_LATER\n#endif\n\n#ifndef pTHX\n# define pTHX void\n# define pTHX_\n#endif\n\n#ifndef EXTERN_C\n# define EXTERN_C\n#endif\n\n/* Compatibility hacks over */\n\nstatic PerlInterpreter *perl_interp = NULL;\nstatic void xs_init(pTHX);\nstatic void VIM_init(void);\nEXTERN_C void boot_DynaLoader(pTHX_ CV*);\n\n/*\n * For dynamic linked perl.\n */\n#if defined(DYNAMIC_PERL) || defined(PROTO)\n\n# ifndef DYNAMIC_PERL /* just generating prototypes */\n#  ifdef WIN3264\ntypedef int HANDLE;\n#  endif\ntypedef int XSINIT_t;\ntypedef int XSUBADDR_t;\n# endif\n# ifndef USE_ITHREADS\ntypedef int perl_key;\n# endif\n\n# ifndef WIN3264\n#  include <dlfcn.h>\n#  define HANDLE void*\n#  define PERL_PROC void*\n#  define load_dll(n) dlopen((n), RTLD_LAZY|RTLD_GLOBAL)\n#  define symbol_from_dll dlsym\n#  define close_dll dlclose\n# else\n#  define PERL_PROC FARPROC\n#  define load_dll vimLoadLib\n#  define symbol_from_dll GetProcAddress\n#  define close_dll FreeLibrary\n# endif\n/*\n * Wrapper defines\n */\n# define perl_alloc dll_perl_alloc\n# define perl_construct dll_perl_construct\n# define perl_parse dll_perl_parse\n# define perl_run dll_perl_run\n# define perl_destruct dll_perl_destruct\n# define perl_free dll_perl_free\n# define Perl_get_context dll_Perl_get_context\n# define Perl_croak dll_Perl_croak\n# ifdef PERL5101_OR_LATER\n#  define Perl_croak_xs_usage dll_Perl_croak_xs_usage\n# endif\n# ifndef PROTO\n#  define Perl_croak_nocontext dll_Perl_croak_nocontext\n#  define Perl_call_argv dll_Perl_call_argv\n#  define Perl_call_pv dll_Perl_call_pv\n#  define Perl_eval_sv dll_Perl_eval_sv\n#  define Perl_get_sv dll_Perl_get_sv\n#  define Perl_eval_pv dll_Perl_eval_pv\n#  define Perl_call_method dll_Perl_call_method\n# endif\n# define Perl_dowantarray dll_Perl_dowantarray\n# define Perl_free_tmps dll_Perl_free_tmps\n# define Perl_gv_stashpv dll_Perl_gv_stashpv\n# define Perl_markstack_grow dll_Perl_markstack_grow\n# define Perl_mg_find dll_Perl_mg_find\n# define Perl_newXS dll_Perl_newXS\n# define Perl_newSV dll_Perl_newSV\n# define Perl_newSViv dll_Perl_newSViv\n# define Perl_newSVpv dll_Perl_newSVpv\n# define Perl_pop_scope dll_Perl_pop_scope\n# define Perl_push_scope dll_Perl_push_scope\n# define Perl_save_int dll_Perl_save_int\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 20)\n#  define Perl_save_strlen dll_Perl_save_strlen\n# endif\n# define Perl_stack_grow dll_Perl_stack_grow\n# define Perl_set_context dll_Perl_set_context\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 14)\n#  define Perl_sv_2bool_flags dll_Perl_sv_2bool_flags\n#  if (PERL_REVISION == 5) && (PERL_VERSION < 22)\n#   define Perl_xs_apiversion_bootcheck dll_Perl_xs_apiversion_bootcheck\n#  endif\n# else\n#  define Perl_sv_2bool dll_Perl_sv_2bool\n# endif\n# define Perl_sv_2iv dll_Perl_sv_2iv\n# define Perl_sv_2mortal dll_Perl_sv_2mortal\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 8)\n#  define Perl_sv_2pv_flags dll_Perl_sv_2pv_flags\n#  define Perl_sv_2pv_nolen dll_Perl_sv_2pv_nolen\n# else\n#  define Perl_sv_2pv dll_Perl_sv_2pv\n# endif\n# define Perl_sv_bless dll_Perl_sv_bless\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 8)\n#  define Perl_sv_catpvn_flags dll_Perl_sv_catpvn_flags\n# else\n#  define Perl_sv_catpvn dll_Perl_sv_catpvn\n# endif\n# ifdef PERL589_OR_LATER\n#  define Perl_sv_2iv_flags dll_Perl_sv_2iv_flags\n#  define Perl_newXS_flags dll_Perl_newXS_flags\n# endif\n# define Perl_sv_free dll_Perl_sv_free\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 10)\n#  define Perl_sv_free2 dll_Perl_sv_free2\n# endif\n# define Perl_sv_isa dll_Perl_sv_isa\n# define Perl_sv_magic dll_Perl_sv_magic\n# define Perl_sv_setiv dll_Perl_sv_setiv\n# define Perl_sv_setpv dll_Perl_sv_setpv\n# define Perl_sv_setpvn dll_Perl_sv_setpvn\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 8)\n#  define Perl_sv_setsv_flags dll_Perl_sv_setsv_flags\n# else\n#  define Perl_sv_setsv dll_Perl_sv_setsv\n# endif\n# define Perl_sv_upgrade dll_Perl_sv_upgrade\n# define Perl_Tstack_sp_ptr dll_Perl_Tstack_sp_ptr\n# define Perl_Top_ptr dll_Perl_Top_ptr\n# define Perl_Tstack_base_ptr dll_Perl_Tstack_base_ptr\n# define Perl_Tstack_max_ptr dll_Perl_Tstack_max_ptr\n# define Perl_Ttmps_ix_ptr dll_Perl_Ttmps_ix_ptr\n# define Perl_Ttmps_floor_ptr dll_Perl_Ttmps_floor_ptr\n# define Perl_Tmarkstack_ptr_ptr dll_Perl_Tmarkstack_ptr_ptr\n# define Perl_Tmarkstack_max_ptr dll_Perl_Tmarkstack_max_ptr\n# define Perl_TSv_ptr dll_Perl_TSv_ptr\n# define Perl_TXpv_ptr dll_Perl_TXpv_ptr\n# define Perl_Tna_ptr dll_Perl_Tna_ptr\n# define Perl_Idefgv_ptr dll_Perl_Idefgv_ptr\n# define Perl_Ierrgv_ptr dll_Perl_Ierrgv_ptr\n# define Perl_Isv_yes_ptr dll_Perl_Isv_yes_ptr\n# define boot_DynaLoader dll_boot_DynaLoader\n# define Perl_Gthr_key_ptr dll_Perl_Gthr_key_ptr\n\n# define Perl_sys_init dll_Perl_sys_init\n# define Perl_sys_term dll_Perl_sys_term\n# define Perl_ISv_ptr dll_Perl_ISv_ptr\n# define Perl_Istack_max_ptr dll_Perl_Istack_max_ptr\n# define Perl_Istack_base_ptr dll_Perl_Istack_base_ptr\n# define Perl_Itmps_ix_ptr dll_Perl_Itmps_ix_ptr\n# define Perl_Itmps_floor_ptr dll_Perl_Itmps_floor_ptr\n# define Perl_IXpv_ptr dll_Perl_IXpv_ptr\n# define Perl_Ina_ptr dll_Perl_Ina_ptr\n# define Perl_Imarkstack_ptr_ptr dll_Perl_Imarkstack_ptr_ptr\n# define Perl_Imarkstack_max_ptr dll_Perl_Imarkstack_max_ptr\n# define Perl_Istack_sp_ptr dll_Perl_Istack_sp_ptr\n# define Perl_Iop_ptr dll_Perl_Iop_ptr\n# define Perl_call_list dll_Perl_call_list\n# define Perl_Iscopestack_ix_ptr dll_Perl_Iscopestack_ix_ptr\n# define Perl_Iunitcheckav_ptr dll_Perl_Iunitcheckav_ptr\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 22)\n#  define Perl_xs_handshake dll_Perl_xs_handshake\n#  define Perl_xs_boot_epilog dll_Perl_xs_boot_epilog\n# endif\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 14)\n#  ifdef USE_ITHREADS\n#   define PL_thr_key *dll_PL_thr_key\n#  endif\n# endif\n# define Perl_hv_iternext_flags dll_Perl_hv_iternext_flags\n# define Perl_hv_iterinit dll_Perl_hv_iterinit\n# define Perl_hv_iterkey dll_Perl_hv_iterkey\n# define Perl_hv_iterval dll_Perl_hv_iterval\n# define Perl_av_fetch dll_Perl_av_fetch\n# define Perl_av_len dll_Perl_av_len\n# define Perl_sv_2nv_flags dll_Perl_sv_2nv_flags\n# if defined(PERLIO_LAYERS) && !defined(USE_SFIO)\n#  define PerlIOBase_pushed dll_PerlIOBase_pushed\n#  define PerlIO_define_layer dll_PerlIO_define_layer\n# endif\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 24)\n#  define Perl_savetmps dll_Perl_savetmps\n# endif\n\n/*\n * Declare HANDLE for perl.dll and function pointers.\n */\nstatic HANDLE hPerlLib = NULL;\n\nstatic PerlInterpreter* (*perl_alloc)();\nstatic void (*perl_construct)(PerlInterpreter*);\nstatic void (*perl_destruct)(PerlInterpreter*);\nstatic void (*perl_free)(PerlInterpreter*);\nstatic int (*perl_run)(PerlInterpreter*);\nstatic int (*perl_parse)(PerlInterpreter*, XSINIT_t, int, char**, char**);\nstatic void* (*Perl_get_context)(void);\nstatic void (*Perl_croak)(pTHX_ const char*, ...) __attribute__noreturn__;\n# ifdef PERL5101_OR_LATER\n/* Perl-5.18 has a different Perl_croak_xs_usage signature. */\n#  if (PERL_REVISION == 5) && (PERL_VERSION >= 18)\nstatic void (*Perl_croak_xs_usage)(const CV *const, const char *const params)\n\t\t\t\t\t\t    __attribute__noreturn__;\n#  else\nstatic void (*Perl_croak_xs_usage)(pTHX_ const CV *const, const char *const params)\n\t\t\t\t\t\t    __attribute__noreturn__;\n#  endif\n# endif\nstatic void (*Perl_croak_nocontext)(const char*, ...) __attribute__noreturn__;\nstatic I32 (*Perl_dowantarray)(pTHX);\nstatic void (*Perl_free_tmps)(pTHX);\nstatic HV* (*Perl_gv_stashpv)(pTHX_ const char*, I32);\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 22)\nstatic I32* (*Perl_markstack_grow)(pTHX);\n# else\nstatic void (*Perl_markstack_grow)(pTHX);\n# endif\nstatic MAGIC* (*Perl_mg_find)(pTHX_ SV*, int);\nstatic CV* (*Perl_newXS)(pTHX_ char*, XSUBADDR_t, char*);\nstatic SV* (*Perl_newSV)(pTHX_ STRLEN);\nstatic SV* (*Perl_newSViv)(pTHX_ IV);\nstatic SV* (*Perl_newSVpv)(pTHX_ const char*, STRLEN);\nstatic I32 (*Perl_call_argv)(pTHX_ const char*, I32, char**);\nstatic I32 (*Perl_call_pv)(pTHX_ const char*, I32);\nstatic I32 (*Perl_eval_sv)(pTHX_ SV*, I32);\nstatic SV* (*Perl_get_sv)(pTHX_ const char*, I32);\nstatic SV* (*Perl_eval_pv)(pTHX_ const char*, I32);\nstatic SV* (*Perl_call_method)(pTHX_ const char*, I32);\nstatic void (*Perl_pop_scope)(pTHX);\nstatic void (*Perl_push_scope)(pTHX);\nstatic void (*Perl_save_int)(pTHX_ int*);\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 20)\nstatic void (*Perl_save_strlen)(pTHX_ STRLEN* ptr);\n# endif\nstatic SV** (*Perl_stack_grow)(pTHX_ SV**, SV**p, int);\nstatic SV** (*Perl_set_context)(void*);\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 14)\nstatic bool (*Perl_sv_2bool_flags)(pTHX_ SV*, I32);\n#  if (PERL_REVISION == 5) && (PERL_VERSION < 22)\nstatic void (*Perl_xs_apiversion_bootcheck)(pTHX_ SV *module, const char *api_p, STRLEN api_len);\n#  endif\n# else\nstatic bool (*Perl_sv_2bool)(pTHX_ SV*);\n# endif\nstatic IV (*Perl_sv_2iv)(pTHX_ SV*);\nstatic SV* (*Perl_sv_2mortal)(pTHX_ SV*);\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 8)\nstatic char* (*Perl_sv_2pv_flags)(pTHX_ SV*, STRLEN*, I32);\nstatic char* (*Perl_sv_2pv_nolen)(pTHX_ SV*);\n# else\nstatic char* (*Perl_sv_2pv)(pTHX_ SV*, STRLEN*);\n# endif\nstatic SV* (*Perl_sv_bless)(pTHX_ SV*, HV*);\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 8)\nstatic void (*Perl_sv_catpvn_flags)(pTHX_ SV* , const char*, STRLEN, I32);\n# else\nstatic void (*Perl_sv_catpvn)(pTHX_ SV*, const char*, STRLEN);\n# endif\n# ifdef PERL589_OR_LATER\nstatic IV (*Perl_sv_2iv_flags)(pTHX_ SV* sv, I32 flags);\nstatic CV * (*Perl_newXS_flags)(pTHX_ const char *name, XSUBADDR_t subaddr, const char *const filename, const char *const proto, U32 flags);\n# endif\nstatic void (*Perl_sv_free)(pTHX_ SV*);\nstatic int (*Perl_sv_isa)(pTHX_ SV*, const char*);\nstatic void (*Perl_sv_magic)(pTHX_ SV*, SV*, int, const char*, I32);\nstatic void (*Perl_sv_setiv)(pTHX_ SV*, IV);\nstatic void (*Perl_sv_setpv)(pTHX_ SV*, const char*);\nstatic void (*Perl_sv_setpvn)(pTHX_ SV*, const char*, STRLEN);\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 8)\nstatic void (*Perl_sv_setsv_flags)(pTHX_ SV*, SV*, I32);\n# else\nstatic void (*Perl_sv_setsv)(pTHX_ SV*, SV*);\n# endif\nstatic bool (*Perl_sv_upgrade)(pTHX_ SV*, U32);\n# if (PERL_REVISION == 5) && (PERL_VERSION < 10)\nstatic SV*** (*Perl_Tstack_sp_ptr)(register PerlInterpreter*);\nstatic OP** (*Perl_Top_ptr)(register PerlInterpreter*);\nstatic SV*** (*Perl_Tstack_base_ptr)(register PerlInterpreter*);\nstatic SV*** (*Perl_Tstack_max_ptr)(register PerlInterpreter*);\nstatic I32* (*Perl_Ttmps_ix_ptr)(register PerlInterpreter*);\nstatic I32* (*Perl_Ttmps_floor_ptr)(register PerlInterpreter*);\nstatic I32** (*Perl_Tmarkstack_ptr_ptr)(register PerlInterpreter*);\nstatic I32** (*Perl_Tmarkstack_max_ptr)(register PerlInterpreter*);\nstatic SV** (*Perl_TSv_ptr)(register PerlInterpreter*);\nstatic XPV** (*Perl_TXpv_ptr)(register PerlInterpreter*);\nstatic STRLEN* (*Perl_Tna_ptr)(register PerlInterpreter*);\n# else\n/* Perl-5.18 has a different Perl_sv_free2 signature. */\n#  if (PERL_REVISION == 5) && (PERL_VERSION >= 18)\nstatic void (*Perl_sv_free2)(pTHX_ SV*, const U32);\n#  else\nstatic void (*Perl_sv_free2)(pTHX_ SV*);\n#  endif\nstatic void (*Perl_sys_init)(int* argc, char*** argv);\nstatic void (*Perl_sys_term)(void);\nstatic void (*Perl_call_list)(pTHX_ I32, AV*);\n#  if (PERL_REVISION == 5) && (PERL_VERSION >= 14)\n#  else\nstatic SV** (*Perl_ISv_ptr)(register PerlInterpreter*);\nstatic SV*** (*Perl_Istack_max_ptr)(register PerlInterpreter*);\nstatic SV*** (*Perl_Istack_base_ptr)(register PerlInterpreter*);\nstatic XPV** (*Perl_IXpv_ptr)(register PerlInterpreter*);\nstatic I32* (*Perl_Itmps_ix_ptr)(register PerlInterpreter*);\nstatic I32* (*Perl_Itmps_floor_ptr)(register PerlInterpreter*);\nstatic STRLEN* (*Perl_Ina_ptr)(register PerlInterpreter*);\nstatic I32** (*Perl_Imarkstack_ptr_ptr)(register PerlInterpreter*);\nstatic I32** (*Perl_Imarkstack_max_ptr)(register PerlInterpreter*);\nstatic SV*** (*Perl_Istack_sp_ptr)(register PerlInterpreter*);\nstatic OP** (*Perl_Iop_ptr)(register PerlInterpreter*);\nstatic I32* (*Perl_Iscopestack_ix_ptr)(register PerlInterpreter*);\nstatic AV** (*Perl_Iunitcheckav_ptr)(register PerlInterpreter*);\n#  endif\n# endif\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 22)\nstatic I32 (*Perl_xs_handshake)(const U32, void *, const char *, ...);\nstatic void (*Perl_xs_boot_epilog)(pTHX_ const U32);\n# endif\n\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 14)\n#  ifdef USE_ITHREADS\nstatic perl_key* dll_PL_thr_key;\n#  endif\n# else\nstatic GV** (*Perl_Idefgv_ptr)(register PerlInterpreter*);\nstatic GV** (*Perl_Ierrgv_ptr)(register PerlInterpreter*);\nstatic SV* (*Perl_Isv_yes_ptr)(register PerlInterpreter*);\nstatic perl_key* (*Perl_Gthr_key_ptr)_((pTHX));\n# endif\nstatic void (*boot_DynaLoader)_((pTHX_ CV*));\nstatic HE * (*Perl_hv_iternext_flags)(pTHX_ HV *, I32);\nstatic I32 (*Perl_hv_iterinit)(pTHX_ HV *);\nstatic char * (*Perl_hv_iterkey)(pTHX_ HE *, I32 *);\nstatic SV * (*Perl_hv_iterval)(pTHX_ HV *, HE *);\nstatic SV** (*Perl_av_fetch)(pTHX_ AV *, SSize_t, I32);\nstatic SSize_t (*Perl_av_len)(pTHX_ AV *);\nstatic NV (*Perl_sv_2nv_flags)(pTHX_ SV *const, const I32);\n# if defined(PERLIO_LAYERS) && !defined(USE_SFIO)\nstatic IV (*PerlIOBase_pushed)(pTHX_ PerlIO *, const char *, SV *, PerlIO_funcs *);\nstatic void (*PerlIO_define_layer)(pTHX_ PerlIO_funcs *);\n# endif\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 24)\nstatic void (*Perl_savetmps)(pTHX);\n# endif\n\n/*\n * Table of name to function pointer of perl.\n */\nstatic struct {\n    char* name;\n    PERL_PROC* ptr;\n} perl_funcname_table[] = {\n    {\"perl_alloc\", (PERL_PROC*)&perl_alloc},\n    {\"perl_construct\", (PERL_PROC*)&perl_construct},\n    {\"perl_destruct\", (PERL_PROC*)&perl_destruct},\n    {\"perl_free\", (PERL_PROC*)&perl_free},\n    {\"perl_run\", (PERL_PROC*)&perl_run},\n    {\"perl_parse\", (PERL_PROC*)&perl_parse},\n    {\"Perl_get_context\", (PERL_PROC*)&Perl_get_context},\n    {\"Perl_croak\", (PERL_PROC*)&Perl_croak},\n# ifdef PERL5101_OR_LATER\n    {\"Perl_croak_xs_usage\", (PERL_PROC*)&Perl_croak_xs_usage},\n# endif\n# ifdef PERL_IMPLICIT_CONTEXT\n    {\"Perl_croak_nocontext\", (PERL_PROC*)&Perl_croak_nocontext},\n# endif\n    {\"Perl_dowantarray\", (PERL_PROC*)&Perl_dowantarray},\n    {\"Perl_free_tmps\", (PERL_PROC*)&Perl_free_tmps},\n    {\"Perl_gv_stashpv\", (PERL_PROC*)&Perl_gv_stashpv},\n    {\"Perl_markstack_grow\", (PERL_PROC*)&Perl_markstack_grow},\n    {\"Perl_mg_find\", (PERL_PROC*)&Perl_mg_find},\n    {\"Perl_newXS\", (PERL_PROC*)&Perl_newXS},\n    {\"Perl_newSV\", (PERL_PROC*)&Perl_newSV},\n    {\"Perl_newSViv\", (PERL_PROC*)&Perl_newSViv},\n    {\"Perl_newSVpv\", (PERL_PROC*)&Perl_newSVpv},\n    {\"Perl_call_argv\", (PERL_PROC*)&Perl_call_argv},\n    {\"Perl_call_pv\", (PERL_PROC*)&Perl_call_pv},\n    {\"Perl_eval_sv\", (PERL_PROC*)&Perl_eval_sv},\n    {\"Perl_get_sv\", (PERL_PROC*)&Perl_get_sv},\n    {\"Perl_eval_pv\", (PERL_PROC*)&Perl_eval_pv},\n    {\"Perl_call_method\", (PERL_PROC*)&Perl_call_method},\n    {\"Perl_pop_scope\", (PERL_PROC*)&Perl_pop_scope},\n    {\"Perl_push_scope\", (PERL_PROC*)&Perl_push_scope},\n    {\"Perl_save_int\", (PERL_PROC*)&Perl_save_int},\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 20)\n    {\"Perl_save_strlen\", (PERL_PROC*)&Perl_save_strlen},\n# endif\n    {\"Perl_stack_grow\", (PERL_PROC*)&Perl_stack_grow},\n    {\"Perl_set_context\", (PERL_PROC*)&Perl_set_context},\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 14)\n    {\"Perl_sv_2bool_flags\", (PERL_PROC*)&Perl_sv_2bool_flags},\n#  if (PERL_REVISION == 5) && (PERL_VERSION < 22)\n    {\"Perl_xs_apiversion_bootcheck\",(PERL_PROC*)&Perl_xs_apiversion_bootcheck},\n#  endif\n# else\n    {\"Perl_sv_2bool\", (PERL_PROC*)&Perl_sv_2bool},\n# endif\n    {\"Perl_sv_2iv\", (PERL_PROC*)&Perl_sv_2iv},\n    {\"Perl_sv_2mortal\", (PERL_PROC*)&Perl_sv_2mortal},\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 8)\n    {\"Perl_sv_2pv_flags\", (PERL_PROC*)&Perl_sv_2pv_flags},\n    {\"Perl_sv_2pv_nolen\", (PERL_PROC*)&Perl_sv_2pv_nolen},\n# else\n    {\"Perl_sv_2pv\", (PERL_PROC*)&Perl_sv_2pv},\n# endif\n# ifdef PERL589_OR_LATER\n    {\"Perl_sv_2iv_flags\", (PERL_PROC*)&Perl_sv_2iv_flags},\n    {\"Perl_newXS_flags\", (PERL_PROC*)&Perl_newXS_flags},\n# endif\n    {\"Perl_sv_bless\", (PERL_PROC*)&Perl_sv_bless},\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 8)\n    {\"Perl_sv_catpvn_flags\", (PERL_PROC*)&Perl_sv_catpvn_flags},\n# else\n    {\"Perl_sv_catpvn\", (PERL_PROC*)&Perl_sv_catpvn},\n# endif\n    {\"Perl_sv_free\", (PERL_PROC*)&Perl_sv_free},\n    {\"Perl_sv_isa\", (PERL_PROC*)&Perl_sv_isa},\n    {\"Perl_sv_magic\", (PERL_PROC*)&Perl_sv_magic},\n    {\"Perl_sv_setiv\", (PERL_PROC*)&Perl_sv_setiv},\n    {\"Perl_sv_setpv\", (PERL_PROC*)&Perl_sv_setpv},\n    {\"Perl_sv_setpvn\", (PERL_PROC*)&Perl_sv_setpvn},\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 8)\n    {\"Perl_sv_setsv_flags\", (PERL_PROC*)&Perl_sv_setsv_flags},\n# else\n    {\"Perl_sv_setsv\", (PERL_PROC*)&Perl_sv_setsv},\n# endif\n    {\"Perl_sv_upgrade\", (PERL_PROC*)&Perl_sv_upgrade},\n# if (PERL_REVISION == 5) && (PERL_VERSION < 10)\n    {\"Perl_Tstack_sp_ptr\", (PERL_PROC*)&Perl_Tstack_sp_ptr},\n    {\"Perl_Top_ptr\", (PERL_PROC*)&Perl_Top_ptr},\n    {\"Perl_Tstack_base_ptr\", (PERL_PROC*)&Perl_Tstack_base_ptr},\n    {\"Perl_Tstack_max_ptr\", (PERL_PROC*)&Perl_Tstack_max_ptr},\n    {\"Perl_Ttmps_ix_ptr\", (PERL_PROC*)&Perl_Ttmps_ix_ptr},\n    {\"Perl_Ttmps_floor_ptr\", (PERL_PROC*)&Perl_Ttmps_floor_ptr},\n    {\"Perl_Tmarkstack_ptr_ptr\", (PERL_PROC*)&Perl_Tmarkstack_ptr_ptr},\n    {\"Perl_Tmarkstack_max_ptr\", (PERL_PROC*)&Perl_Tmarkstack_max_ptr},\n    {\"Perl_TSv_ptr\", (PERL_PROC*)&Perl_TSv_ptr},\n    {\"Perl_TXpv_ptr\", (PERL_PROC*)&Perl_TXpv_ptr},\n    {\"Perl_Tna_ptr\", (PERL_PROC*)&Perl_Tna_ptr},\n# else\n    {\"Perl_sv_free2\", (PERL_PROC*)&Perl_sv_free2},\n    {\"Perl_sys_init\", (PERL_PROC*)&Perl_sys_init},\n    {\"Perl_sys_term\", (PERL_PROC*)&Perl_sys_term},\n    {\"Perl_call_list\", (PERL_PROC*)&Perl_call_list},\n#  if (PERL_REVISION == 5) && (PERL_VERSION >= 14)\n#  else\n    {\"Perl_ISv_ptr\", (PERL_PROC*)&Perl_ISv_ptr},\n    {\"Perl_Istack_max_ptr\", (PERL_PROC*)&Perl_Istack_max_ptr},\n    {\"Perl_Istack_base_ptr\", (PERL_PROC*)&Perl_Istack_base_ptr},\n    {\"Perl_IXpv_ptr\", (PERL_PROC*)&Perl_IXpv_ptr},\n    {\"Perl_Itmps_ix_ptr\", (PERL_PROC*)&Perl_Itmps_ix_ptr},\n    {\"Perl_Itmps_floor_ptr\", (PERL_PROC*)&Perl_Itmps_floor_ptr},\n    {\"Perl_Ina_ptr\", (PERL_PROC*)&Perl_Ina_ptr},\n    {\"Perl_Imarkstack_ptr_ptr\", (PERL_PROC*)&Perl_Imarkstack_ptr_ptr},\n    {\"Perl_Imarkstack_max_ptr\", (PERL_PROC*)&Perl_Imarkstack_max_ptr},\n    {\"Perl_Istack_sp_ptr\", (PERL_PROC*)&Perl_Istack_sp_ptr},\n    {\"Perl_Iop_ptr\", (PERL_PROC*)&Perl_Iop_ptr},\n    {\"Perl_Iscopestack_ix_ptr\", (PERL_PROC*)&Perl_Iscopestack_ix_ptr},\n    {\"Perl_Iunitcheckav_ptr\", (PERL_PROC*)&Perl_Iunitcheckav_ptr},\n#  endif\n# endif\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 22)\n    {\"Perl_xs_handshake\", (PERL_PROC*)&Perl_xs_handshake},\n    {\"Perl_xs_boot_epilog\", (PERL_PROC*)&Perl_xs_boot_epilog},\n# endif\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 14)\n#  ifdef USE_ITHREADS\n    {\"PL_thr_key\", (PERL_PROC*)&dll_PL_thr_key},\n#  endif\n# else\n    {\"Perl_Idefgv_ptr\", (PERL_PROC*)&Perl_Idefgv_ptr},\n    {\"Perl_Ierrgv_ptr\", (PERL_PROC*)&Perl_Ierrgv_ptr},\n    {\"Perl_Isv_yes_ptr\", (PERL_PROC*)&Perl_Isv_yes_ptr},\n    {\"Perl_Gthr_key_ptr\", (PERL_PROC*)&Perl_Gthr_key_ptr},\n# endif\n    {\"boot_DynaLoader\", (PERL_PROC*)&boot_DynaLoader},\n    {\"Perl_hv_iternext_flags\", (PERL_PROC*)&Perl_hv_iternext_flags},\n    {\"Perl_hv_iterinit\", (PERL_PROC*)&Perl_hv_iterinit},\n    {\"Perl_hv_iterkey\", (PERL_PROC*)&Perl_hv_iterkey},\n    {\"Perl_hv_iterval\", (PERL_PROC*)&Perl_hv_iterval},\n    {\"Perl_av_fetch\", (PERL_PROC*)&Perl_av_fetch},\n    {\"Perl_av_len\", (PERL_PROC*)&Perl_av_len},\n    {\"Perl_sv_2nv_flags\", (PERL_PROC*)&Perl_sv_2nv_flags},\n# if defined(PERLIO_LAYERS) && !defined(USE_SFIO)\n    {\"PerlIOBase_pushed\", (PERL_PROC*)&PerlIOBase_pushed},\n    {\"PerlIO_define_layer\", (PERL_PROC*)&PerlIO_define_layer},\n# endif\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 24)\n    {\"Perl_savetmps\", (PERL_PROC*)&Perl_savetmps},\n# endif\n    {\"\", NULL},\n};\n\n/* Work around for perl-5.18.\n * For now, only the definitions of S_SvREFCNT_dec are needed in\n * \"perl\\lib\\CORE\\inline.h\". */\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 18)\nstatic void\nS_SvREFCNT_dec(pTHX_ SV *sv)\n{\n    if (LIKELY(sv != NULL)) {\n\tU32 rc = SvREFCNT(sv);\n\tif (LIKELY(rc > 1))\n\t    SvREFCNT(sv) = rc - 1;\n\telse\n\t    Perl_sv_free2(aTHX_ sv, rc);\n    }\n}\n# endif\n\n/*\n * Make all runtime-links of perl.\n *\n * 1. Get module handle using dlopen() or vimLoadLib().\n * 2. Get pointer to perl function by GetProcAddress.\n * 3. Repeat 2, until get all functions will be used.\n *\n * Parameter 'libname' provides name of DLL.\n * Return OK or FAIL.\n */\n    static int\nperl_runtime_link_init(char *libname, int verbose)\n{\n    int i;\n\n    if (hPerlLib != NULL)\n\treturn OK;\n    if ((hPerlLib = load_dll(libname)) == NULL)\n    {\n\tif (verbose)\n\t    EMSG2(_(\"E370: Could not load library %s\"), libname);\n\treturn FAIL;\n    }\n    for (i = 0; perl_funcname_table[i].ptr; ++i)\n    {\n\tif (!(*perl_funcname_table[i].ptr = symbol_from_dll(hPerlLib,\n\t\t\tperl_funcname_table[i].name)))\n\t{\n\t    close_dll(hPerlLib);\n\t    hPerlLib = NULL;\n\t    if (verbose)\n\t\tEMSG2(_(e_loadfunc), perl_funcname_table[i].name);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * If runtime-link-perl(DLL) was loaded successfully, return TRUE.\n * There were no DLL loaded, return FALSE.\n */\n    int\nperl_enabled(int verbose)\n{\n    return perl_runtime_link_init((char *)p_perldll, verbose) == OK;\n}\n#endif /* DYNAMIC_PERL */\n\n#if defined(PERLIO_LAYERS) && !defined(USE_SFIO)\nstatic void vim_IOLayer_init(void);\n#endif\n\n/*\n * perl_init(): initialize perl interpreter\n * We have to call perl_parse to initialize some structures,\n * there's nothing to actually parse.\n */\n    static void\nperl_init(void)\n{\n    char *bootargs[] = { \"VI\", NULL };\n    int argc = 3;\n    static char *argv[] = { \"\", \"-e\", \"\" };\n\n#if (PERL_REVISION == 5) && (PERL_VERSION >= 10)\n    Perl_sys_init(&argc, (char***)&argv);\n#endif\n    perl_interp = perl_alloc();\n    perl_construct(perl_interp);\n    perl_parse(perl_interp, xs_init, argc, argv, 0);\n    perl_call_argv(\"VIM::bootstrap\", (long)G_DISCARD, bootargs);\n    VIM_init();\n#ifdef USE_SFIO\n    sfdisc(PerlIO_stdout(), sfdcnewvim());\n    sfdisc(PerlIO_stderr(), sfdcnewvim());\n    sfsetbuf(PerlIO_stdout(), NULL, 0);\n    sfsetbuf(PerlIO_stderr(), NULL, 0);\n#elif defined(PERLIO_LAYERS)\n    vim_IOLayer_init();\n#endif\n}\n\n/*\n * perl_end(): clean up after ourselves\n */\n    void\nperl_end(void)\n{\n    if (perl_interp)\n    {\n\tperl_run(perl_interp);\n\tperl_destruct(perl_interp);\n\tperl_free(perl_interp);\n\tperl_interp = NULL;\n#if (PERL_REVISION == 5) && (PERL_VERSION >= 10)\n\tPerl_sys_term();\n#endif\n    }\n#ifdef DYNAMIC_PERL\n    if (hPerlLib)\n    {\n\tclose_dll(hPerlLib);\n\thPerlLib = NULL;\n    }\n#endif\n}\n\n/*\n * msg_split(): send a message to the message handling routines\n * split at '\\n' first though.\n */\n    void\nmsg_split(\n    char_u\t*s,\n    int\t\tattr)\t/* highlighting attributes */\n{\n    char *next;\n    char *token = (char *)s;\n\n    while ((next = strchr(token, '\\n')) && !got_int)\n    {\n\t*next++ = '\\0';\t\t\t/* replace \\n with \\0 */\n\tmsg_attr((char_u *)token, attr);\n\ttoken = next;\n    }\n    if (*token && !got_int)\n\tmsg_attr((char_u *)token, attr);\n}\n\n#ifndef FEAT_EVAL\n/*\n * This stub is needed because an \"#ifdef FEAT_EVAL\" around Eval() doesn't\n * work properly.\n */\n    char_u *\neval_to_string(\n    char_u\t*arg UNUSED,\n    char_u\t**nextcmd UNUSED,\n    int\t\tdolist UNUSED)\n{\n    return NULL;\n}\n#endif\n\n/*\n * Create a new reference to an SV pointing to the SCR structure\n * The b_perl_private/w_perl_private part of the SCR structure points to the\n * SV, so there can only be one such SV for a particular SCR structure.  When\n * the last reference has gone (DESTROY is called),\n * b_perl_private/w_perl_private is reset; When the screen goes away before\n * all references are gone, the value of the SV is reset;\n * any subsequent use of any of those reference will produce\n * a warning. (see typemap)\n */\n\n    static SV *\nnewWINrv(SV *rv, win_T *ptr)\n{\n    sv_upgrade(rv, SVt_RV);\n    if (ptr->w_perl_private == NULL)\n    {\n\tptr->w_perl_private = newSV(0);\n\tsv_setiv(ptr->w_perl_private, PTR2IV(ptr));\n    }\n    else\n\tSvREFCNT_inc_void_NN(ptr->w_perl_private);\n    SvRV(rv) = ptr->w_perl_private;\n    SvROK_on(rv);\n    return sv_bless(rv, gv_stashpv(\"VIWIN\", TRUE));\n}\n\n    static SV *\nnewBUFrv(SV *rv, buf_T *ptr)\n{\n    sv_upgrade(rv, SVt_RV);\n    if (ptr->b_perl_private == NULL)\n    {\n\tptr->b_perl_private = newSV(0);\n\tsv_setiv(ptr->b_perl_private, PTR2IV(ptr));\n    }\n    else\n\tSvREFCNT_inc_void_NN(ptr->b_perl_private);\n    SvRV(rv) = ptr->b_perl_private;\n    SvROK_on(rv);\n    return sv_bless(rv, gv_stashpv(\"VIBUF\", TRUE));\n}\n\n/*\n * perl_win_free\n *\tRemove all references to the window to be destroyed\n */\n    void\nperl_win_free(win_T *wp)\n{\n    if (wp->w_perl_private)\n\tsv_setiv((SV *)wp->w_perl_private, 0);\n    return;\n}\n\n    void\nperl_buf_free(buf_T *bp)\n{\n    if (bp->b_perl_private)\n\tsv_setiv((SV *)bp->b_perl_private, 0);\n    return;\n}\n\n#ifndef PROTO\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 8)\nI32 cur_val(pTHX_ IV iv, SV *sv);\n# else\nI32 cur_val(IV iv, SV *sv);\n# endif\n\n/*\n * Handler for the magic variables $main::curwin and $main::curbuf.\n * The handler is put into the magic vtbl for these variables.\n * (This is effectively a C-level equivalent of a tied variable).\n * There is no \"set\" function as the variables are read-only.\n */\n# if (PERL_REVISION == 5) && (PERL_VERSION >= 8)\nI32 cur_val(pTHX_ IV iv, SV *sv)\n# else\nI32 cur_val(IV iv, SV *sv)\n# endif\n{\n    SV *rv;\n    if (iv == 0)\n\trv = newWINrv(newSV(0), curwin);\n    else\n\trv = newBUFrv(newSV(0), curbuf);\n    sv_setsv(sv, rv);\n    SvREFCNT_dec(SvRV(rv));\n    return 0;\n}\n#endif /* !PROTO */\n\nstruct ufuncs cw_funcs = { cur_val, 0, 0 };\nstruct ufuncs cb_funcs = { cur_val, 0, 1 };\n\n/*\n * VIM_init(): Vim-specific initialisation.\n * Make the magical main::curwin and main::curbuf variables\n */\n    static void\nVIM_init(void)\n{\n    static char cw[] = \"main::curwin\";\n    static char cb[] = \"main::curbuf\";\n    SV *sv;\n\n    sv = perl_get_sv(cw, TRUE);\n    sv_magic(sv, NULL, 'U', (char *)&cw_funcs, sizeof(cw_funcs));\n    SvREADONLY_on(sv);\n\n    sv = perl_get_sv(cb, TRUE);\n    sv_magic(sv, NULL, 'U', (char *)&cb_funcs, sizeof(cb_funcs));\n    SvREADONLY_on(sv);\n\n    /*\n     * Setup the Safe compartment.\n     * It shouldn't be a fatal error if the Safe module is missing.\n     * XXX: Only shares the 'Msg' routine (which has to be called\n     * like 'Msg(...)').\n     */\n    (void)perl_eval_pv( \"if ( eval( 'require Safe' ) ) { $VIM::safe = Safe->new(); $VIM::safe->share_from( 'VIM', ['Msg'] ); }\", G_DISCARD | G_VOID );\n\n}\n\n#ifdef DYNAMIC_PERL\nstatic char *e_noperl = N_(\"Sorry, this command is disabled: the Perl library could not be loaded.\");\n#endif\n\n/*\n * \":perl\"\n */\n    void\nex_perl(exarg_T *eap)\n{\n    char\t*err;\n    char\t*script;\n    STRLEN\tlength;\n    SV\t\t*sv;\n#ifdef HAVE_SANDBOX\n    SV\t\t*safe;\n#endif\n\n    script = (char *)script_get(eap, eap->arg);\n    if (eap->skip)\n    {\n\tvim_free(script);\n\treturn;\n    }\n\n    if (perl_interp == NULL)\n    {\n#ifdef DYNAMIC_PERL\n\tif (!perl_enabled(TRUE))\n\t{\n\t    EMSG(_(e_noperl));\n\t    vim_free(script);\n\t    return;\n\t}\n#endif\n\tperl_init();\n    }\n\n    {\n    dSP;\n    ENTER;\n    SAVETMPS;\n\n    if (script == NULL)\n\tsv = newSVpv((char *)eap->arg, 0);\n    else\n    {\n\tsv = newSVpv(script, 0);\n\tvim_free(script);\n    }\n\n#ifdef HAVE_SANDBOX\n    if (sandbox)\n    {\n\tsafe = perl_get_sv(\"VIM::safe\", FALSE);\n# ifndef MAKE_TEST  /* avoid a warning for unreachable code */\n\tif (safe == NULL || !SvTRUE(safe))\n\t    EMSG(_(\"E299: Perl evaluation forbidden in sandbox without the Safe module\"));\n\telse\n# endif\n\t{\n\t    PUSHMARK(SP);\n\t    XPUSHs(safe);\n\t    XPUSHs(sv);\n\t    PUTBACK;\n\t    perl_call_method(\"reval\", G_DISCARD);\n\t}\n    }\n    else\n#endif\n\tperl_eval_sv(sv, G_DISCARD | G_NOARGS);\n\n    SvREFCNT_dec(sv);\n\n    err = SvPV(GvSV(PL_errgv), length);\n\n    FREETMPS;\n    LEAVE;\n\n    if (!length)\n\treturn;\n\n    msg_split((char_u *)err, highlight_attr[HLF_E]);\n    return;\n    }\n}\n\n    static int\nreplace_line(linenr_T *line, linenr_T *end)\n{\n    char *str;\n\n    if (SvOK(GvSV(PL_defgv)))\n    {\n\tstr = SvPV(GvSV(PL_defgv), PL_na);\n\tml_replace(*line, (char_u *)str, 1);\n\tchanged_bytes(*line, 0);\n    }\n    else\n    {\n\tml_delete(*line, FALSE);\n\tdeleted_lines_mark(*line, 1L);\n\t--(*end);\n\t--(*line);\n    }\n    return OK;\n}\n\nstatic struct ref_map_S {\n    void *vim_ref;\n    SV   *perl_ref;\n    struct ref_map_S *next;\n} *ref_map = NULL;\n\n    static void\nref_map_free(void)\n{\n    struct ref_map_S *tofree;\n    struct ref_map_S *refs = ref_map;\n\n    while (refs) {\n\ttofree = refs;\n\trefs = refs->next;\n\tvim_free(tofree);\n    }\n    ref_map = NULL;\n}\n\n    static struct ref_map_S *\nref_map_find_SV(SV *const sv)\n{\n    struct ref_map_S *refs = ref_map;\n    int count = 350;\n\n    while (refs) {\n\tif (refs->perl_ref == sv)\n\t    break;\n\trefs = refs->next;\n\tcount--;\n    }\n\n    if (!refs && count > 0) {\n\trefs = (struct ref_map_S *)alloc(sizeof(struct ref_map_S));\n\tif (!refs)\n\t    return NULL;\n\trefs->perl_ref = sv;\n\trefs->vim_ref = NULL;\n\trefs->next = ref_map;\n\tref_map = refs;\n    }\n\n    return refs;\n}\n\n    static int\nperl_to_vim(SV *sv, typval_T *rettv)\n{\n    if (SvROK(sv))\n\tsv = SvRV(sv);\n\n    switch (SvTYPE(sv)) {\n\tcase SVt_NULL:\n\t    break;\n\tcase SVt_NV:\t/* float */\n#ifdef FEAT_FLOAT\n\t    rettv->v_type\t= VAR_FLOAT;\n\t    rettv->vval.v_float = SvNV(sv);\n\t    break;\n#endif\n\tcase SVt_IV:\t/* integer */\n\t    if (!SvROK(sv)) { /* references should be string */\n\t\trettv->vval.v_number = SvIV(sv);\n\t\tbreak;\n\t    }\n\tcase SVt_PV:\t/* string */\n\t{\n\t    size_t  len\t\t= 0;\n\t    char *  str_from\t= SvPV(sv, len);\n\t    char_u *str_to\t= (char_u*)alloc(\n\t\t\t\t      (unsigned)(sizeof(char_u) * (len + 1)));\n\n\t    if (str_to) {\n\t\tstr_to[len] = '\\0';\n\n\t\twhile (len--) {\n\t\t    if (str_from[len] == '\\0')\n\t\t\tstr_to[len] = '\\n';\n\t\t    else\n\t\t\tstr_to[len] = str_from[len];\n\t\t}\n\t    }\n\n\t    rettv->v_type\t    = VAR_STRING;\n\t    rettv->vval.v_string    = str_to;\n\t    break;\n\t}\n\tcase SVt_PVAV:\t/* list */\n\t{\n\t    SSize_t\t\tsize;\n\t    listitem_T *\titem;\n\t    SV **\t\titem2;\n\t    list_T *\t\tlist;\n\t    struct ref_map_S *\trefs;\n\n\t    if ((refs = ref_map_find_SV(sv)) == NULL)\n\t\treturn FAIL;\n\n\t    if (refs->vim_ref)\n\t\tlist = (list_T *) refs->vim_ref;\n\t    else\n\t    {\n\t\tif ((list = list_alloc()) == NULL)\n\t\t    return FAIL;\n\t\trefs->vim_ref = list;\n\n\t\tfor (size = av_len((AV*)sv); size >= 0; size--)\n\t\t{\n\t\t    if ((item = listitem_alloc()) == NULL)\n\t\t\tbreak;\n\n\t\t    item->li_tv.v_type\t\t= VAR_NUMBER;\n\t\t    item->li_tv.v_lock\t\t= 0;\n\t\t    item->li_tv.vval.v_number\t= 0;\n\t\t    list_insert(list, item, list->lv_first);\n\n\t\t    item2 = av_fetch((AV *)sv, size, 0);\n\n\t\t    if (item2 == NULL || *item2 == NULL ||\n\t\t\t\t    perl_to_vim(*item2, &item->li_tv) == FAIL)\n\t\t\tbreak;\n\t\t}\n\t    }\n\n\t    list->lv_refcount++;\n\t    rettv->v_type\t= VAR_LIST;\n\t    rettv->vval.v_list\t= list;\n\t    break;\n\t}\n\tcase SVt_PVHV:\t/* dictionary */\n\t{\n\t    HE *\t\tentry;\n\t    I32\t\t\tkey_len;\n\t    char *\t\tkey;\n\t    dictitem_T *\titem;\n\t    SV *\t\titem2;\n\t    dict_T *\t\tdict;\n\t    struct ref_map_S *\trefs;\n\n\t    if ((refs = ref_map_find_SV(sv)) == NULL)\n\t\treturn FAIL;\n\n\t    if (refs->vim_ref)\n\t\tdict = (dict_T *) refs->vim_ref;\n\t    else\n\t    {\n\n\t\tif ((dict = dict_alloc()) == NULL)\n\t\t    return FAIL;\n\t\trefs->vim_ref = dict;\n\n\t\thv_iterinit((HV *)sv);\n\n\t\tfor (entry = hv_iternext((HV *)sv); entry; entry = hv_iternext((HV *)sv))\n\t\t{\n\t\t    key_len = 0;\n\t\t    key = hv_iterkey(entry, &key_len);\n\n\t\t    if (!key || !key_len || strlen(key) < (size_t)key_len) {\n\t\t\tEMSG2(\"Malformed key Dictionary '%s'\", key && *key ? key : \"(empty)\");\n\t\t\tbreak;\n\t\t    }\n\n\t\t    if ((item = dictitem_alloc((char_u *)key)) == NULL)\n\t\t\tbreak;\n\n\t\t    item->di_tv.v_type\t\t= VAR_NUMBER;\n\t\t    item->di_tv.v_lock\t\t= 0;\n\t\t    item->di_tv.vval.v_number\t= 0;\n\n\t\t    if (dict_add(dict, item) == FAIL) {\n\t\t\tdictitem_free(item);\n\t\t\tbreak;\n\t\t    }\n\t\t    item2 = hv_iterval((HV *)sv, entry);\n\t\t    if (item2 == NULL || perl_to_vim(item2, &item->di_tv) == FAIL)\n\t\t\tbreak;\n\t\t}\n\t    }\n\n\t    dict->dv_refcount++;\n\t    rettv->v_type\t= VAR_DICT;\n\t    rettv->vval.v_dict\t= dict;\n\t    break;\n\t}\n\tdefault:\t/* not convertible */\n\t{\n\t    char *val\t    = SvPV_nolen(sv);\n\t    rettv->v_type   = VAR_STRING;\n\t    rettv->vval.v_string = val ? vim_strsave((char_u *)val) : NULL;\n\t    break;\n\t}\n    }\n    return OK;\n}\n\n/*\n * \"perleval()\"\n */\n    void\ndo_perleval(char_u *str, typval_T *rettv)\n{\n    char\t*err = NULL;\n    STRLEN\terr_len = 0;\n    SV\t\t*sv = NULL;\n#ifdef HAVE_SANDBOX\n    SV\t\t*safe;\n#endif\n\n    if (perl_interp == NULL)\n    {\n#ifdef DYNAMIC_PERL\n\tif (!perl_enabled(TRUE))\n\t{\n\t    EMSG(_(e_noperl));\n\t    return;\n\t}\n#endif\n\tperl_init();\n    }\n\n    {\n\tdSP;\n\tENTER;\n\tSAVETMPS;\n\n#ifdef HAVE_SANDBOX\n\tif (sandbox)\n\t{\n\t    safe = get_sv(\"VIM::safe\", FALSE);\n# ifndef MAKE_TEST  /* avoid a warning for unreachable code */\n\t    if (safe == NULL || !SvTRUE(safe))\n\t\tEMSG(_(\"E299: Perl evaluation forbidden in sandbox without the Safe module\"));\n\t    else\n# endif\n\t    {\n\t\tsv = newSVpv((char *)str, 0);\n\t\tPUSHMARK(SP);\n\t\tXPUSHs(safe);\n\t\tXPUSHs(sv);\n\t\tPUTBACK;\n\t\tcall_method(\"reval\", G_SCALAR);\n\t\tSPAGAIN;\n\t\tSvREFCNT_dec(sv);\n\t\tsv = POPs;\n\t    }\n\t}\n\telse\n#endif /* HAVE_SANDBOX */\n\t    sv = eval_pv((char *)str, 0);\n\n\tif (sv) {\n\t    perl_to_vim(sv, rettv);\n\t    ref_map_free();\n\t    err = SvPV(GvSV(PL_errgv), err_len);\n\t}\n\tPUTBACK;\n\tFREETMPS;\n\tLEAVE;\n    }\n    if (err_len)\n\tmsg_split((char_u *)err, highlight_attr[HLF_E]);\n}\n\n/*\n * \":perldo\".\n */\n    void\nex_perldo(exarg_T *eap)\n{\n    STRLEN\tlength;\n    SV\t\t*sv;\n    char\t*str;\n    linenr_T\ti;\n    buf_T\t*was_curbuf = curbuf;\n\n    if (BUFEMPTY())\n\treturn;\n\n    if (perl_interp == NULL)\n    {\n#ifdef DYNAMIC_PERL\n\tif (!perl_enabled(TRUE))\n\t{\n\t    EMSG(_(e_noperl));\n\t    return;\n\t}\n#endif\n\tperl_init();\n    }\n    {\n    dSP;\n    length = strlen((char *)eap->arg);\n    sv = newSV(length + sizeof(\"sub VIM::perldo {\") - 1 + 1);\n    sv_setpvn(sv, \"sub VIM::perldo {\", sizeof(\"sub VIM::perldo {\") - 1);\n    sv_catpvn(sv, (char *)eap->arg, length);\n    sv_catpvn(sv, \"}\", 1);\n    perl_eval_sv(sv, G_DISCARD | G_NOARGS);\n    SvREFCNT_dec(sv);\n    str = SvPV(GvSV(PL_errgv), length);\n    if (length)\n\tgoto err;\n\n    if (u_save(eap->line1 - 1, eap->line2 + 1) != OK)\n\treturn;\n\n    ENTER;\n    SAVETMPS;\n    for (i = eap->line1; i <= eap->line2; i++)\n    {\n\t/* Check the line number, the command my have deleted lines. */\n\tif (i > curbuf->b_ml.ml_line_count)\n\t    break;\n\tsv_setpv(GvSV(PL_defgv), (char *)ml_get(i));\n\tPUSHMARK(sp);\n\tperl_call_pv(\"VIM::perldo\", G_SCALAR | G_EVAL);\n\tstr = SvPV(GvSV(PL_errgv), length);\n\tif (length || curbuf != was_curbuf)\n\t    break;\n\tSPAGAIN;\n\tif (SvTRUEx(POPs))\n\t{\n\t    if (replace_line(&i, &eap->line2) != OK)\n\t    {\n\t\tPUTBACK;\n\t\tbreak;\n\t    }\n\t}\n\tPUTBACK;\n    }\n    FREETMPS;\n    LEAVE;\n    check_cursor();\n    update_screen(NOT_VALID);\n    if (!length)\n\treturn;\n\nerr:\n    msg_split((char_u *)str, highlight_attr[HLF_E]);\n    return;\n    }\n}\n\n#if defined(PERLIO_LAYERS) && !defined(USE_SFIO)\ntypedef struct {\n    struct _PerlIO base;\n    int attr;\n} PerlIOVim;\n\n    static IV\nPerlIOVim_pushed(pTHX_ PerlIO *f, const char *mode,\n\t\t SV *arg, PerlIO_funcs *tab)\n{\n    PerlIOVim *s = PerlIOSelf(f, PerlIOVim);\n    s->attr = 0;\n    if (arg && SvPOK(arg)) {\n\tint id = syn_name2id((char_u *)SvPV_nolen(arg));\n\tif (id != 0)\n\t    s->attr = syn_id2attr(id);\n    }\n    return PerlIOBase_pushed(aTHX_ f, mode, (SV *)NULL, tab);\n}\n\n    static SSize_t\nPerlIOVim_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)\n{\n    char_u *str;\n    PerlIOVim * s = PerlIOSelf(f, PerlIOVim);\n\n    str = vim_strnsave((char_u *)vbuf, (int)count);\n    if (str == NULL)\n\treturn 0;\n    msg_split((char_u *)str, s->attr);\n    vim_free(str);\n\n    return (SSize_t)count;\n}\n\nstatic PERLIO_FUNCS_DECL(PerlIO_Vim) = {\n    sizeof(PerlIO_funcs),\n    \"Vim\",\n    sizeof(PerlIOVim),\n    PERLIO_K_DUMMY,\t/* flags */\n    PerlIOVim_pushed,\n    NULL,\t\t/* popped */\n    NULL,\t\t/* open */\n    NULL,\t\t/* binmode */\n    NULL,\t\t/* arg */\n    NULL,\t\t/* fileno */\n    NULL,\t\t/* dup */\n    NULL,\t\t/* read */\n    NULL,\t\t/* unread */\n    PerlIOVim_write,\n    NULL,\t\t/* seek */\n    NULL,\t\t/* tell */\n    NULL,\t\t/* close */\n    NULL,\t\t/* flush */\n    NULL,\t\t/* fill */\n    NULL,\t\t/* eof */\n    NULL,\t\t/* error */\n    NULL,\t\t/* clearerr */\n    NULL,\t\t/* setlinebuf */\n    NULL,\t\t/* get_base */\n    NULL,\t\t/* get_bufsiz */\n    NULL,\t\t/* get_ptr */\n    NULL,\t\t/* get_cnt */\n    NULL\t\t/* set_ptrcnt */\n};\n\n/* Use Vim routine for print operator */\n    static void\nvim_IOLayer_init(void)\n{\n    PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_Vim));\n    (void)eval_pv(   \"binmode(STDOUT, ':Vim')\"\n                \"  && binmode(STDERR, ':Vim(ErrorMsg)');\", 0);\n}\n#endif /* PERLIO_LAYERS && !USE_SFIO */\n\n#ifndef FEAT_WINDOWS\n    int\nwin_valid(win_T *w)\n{\n    return TRUE;\n}\n    int\nwin_count(void)\n{\n    return 1;\n}\n    win_T *\nwin_find_nr(int n)\n{\n    return curwin;\n}\n#endif\n\nXS(boot_VIM);\n\n    static void\nxs_init(pTHX)\n{\n    char *file = __FILE__;\n\n    /* DynaLoader is a special case */\n    newXS(\"DynaLoader::boot_DynaLoader\", boot_DynaLoader, file);\n    newXS(\"VIM::bootstrap\", boot_VIM, file);\n}\n\ntypedef win_T *\tVIWIN;\ntypedef buf_T *\tVIBUF;\n\nMODULE = VIM\t    PACKAGE = VIM\n\nvoid\nMsg(text, hl=NULL)\n    char\t*text;\n    char\t*hl;\n\n    PREINIT:\n    int\t\tattr;\n    int\t\tid;\n\n    PPCODE:\n    if (text != NULL)\n    {\n\tattr = 0;\n\tif (hl != NULL)\n\t{\n\t    id = syn_name2id((char_u *)hl);\n\t    if (id != 0)\n\t\tattr = syn_id2attr(id);\n\t}\n\tmsg_split((char_u *)text, attr);\n    }\n\nvoid\nSetOption(line)\n    char *line;\n\n    PPCODE:\n    if (line != NULL)\n\tdo_set((char_u *)line, 0);\n    update_screen(NOT_VALID);\n\nvoid\nDoCommand(line)\n    char *line;\n\n    PPCODE:\n    if (line != NULL)\n\tdo_cmdline_cmd((char_u *)line);\n\nvoid\nEval(str)\n    char *str;\n\n    PREINIT:\n\tchar_u *value;\n    PPCODE:\n\tvalue = eval_to_string((char_u *)str, (char_u **)0, TRUE);\n\tif (value == NULL)\n\t{\n\t    XPUSHs(sv_2mortal(newSViv(0)));\n\t    XPUSHs(sv_2mortal(newSVpv(\"\", 0)));\n\t}\n\telse\n\t{\n\t    XPUSHs(sv_2mortal(newSViv(1)));\n\t    XPUSHs(sv_2mortal(newSVpv((char *)value, 0)));\n\t    vim_free(value);\n\t}\n\nvoid\nBuffers(...)\n\n    PREINIT:\n    buf_T *vimbuf;\n    int i, b;\n\n    PPCODE:\n    if (items == 0)\n    {\n\tif (GIMME == G_SCALAR)\n\t{\n\t    i = 0;\n\t    FOR_ALL_BUFFERS(vimbuf)\n\t\t++i;\n\n\t    XPUSHs(sv_2mortal(newSViv(i)));\n\t}\n\telse\n\t{\n\t    FOR_ALL_BUFFERS(vimbuf)\n\t\tXPUSHs(newBUFrv(newSV(0), vimbuf));\n\t}\n    }\n    else\n    {\n\tfor (i = 0; i < items; i++)\n\t{\n\t    SV *sv = ST(i);\n\t    if (SvIOK(sv))\n\t\tb = (int) SvIV(ST(i));\n\t    else\n\t    {\n\t\tchar_u *pat;\n\t\tSTRLEN len;\n\n\t\tpat = (char_u *)SvPV(sv, len);\n\t\t++emsg_off;\n\t\tb = buflist_findpat(pat, pat+len, FALSE, FALSE, FALSE);\n\t\t--emsg_off;\n\t    }\n\n\t    if (b >= 0)\n\t    {\n\t\tvimbuf = buflist_findnr(b);\n\t\tif (vimbuf)\n\t\t    XPUSHs(newBUFrv(newSV(0), vimbuf));\n\t    }\n\t}\n    }\n\nvoid\nWindows(...)\n\n    PREINIT:\n    win_T   *vimwin;\n    int\t    i, w;\n\n    PPCODE:\n    if (items == 0)\n    {\n\tif (GIMME == G_SCALAR)\n\t    XPUSHs(sv_2mortal(newSViv(win_count())));\n\telse\n\t{\n\t    FOR_ALL_WINDOWS(vimwin)\n\t\tXPUSHs(newWINrv(newSV(0), vimwin));\n\t}\n    }\n    else\n    {\n\tfor (i = 0; i < items; i++)\n\t{\n\t    w = (int) SvIV(ST(i));\n\t    vimwin = win_find_nr(w);\n\t    if (vimwin)\n\t\tXPUSHs(newWINrv(newSV(0), vimwin));\n\t}\n    }\n\nMODULE = VIM\t    PACKAGE = VIWIN\n\nvoid\nDESTROY(win)\n    VIWIN win\n\n    CODE:\n    if (win_valid(win))\n\twin->w_perl_private = 0;\n\nSV *\nBuffer(win)\n    VIWIN win\n\n    CODE:\n    if (!win_valid(win))\n\twin = curwin;\n    RETVAL = newBUFrv(newSV(0), win->w_buffer);\n    OUTPUT:\n    RETVAL\n\nvoid\nSetHeight(win, height)\n    VIWIN win\n    int height;\n\n    PREINIT:\n    win_T *savewin;\n\n    PPCODE:\n    if (!win_valid(win))\n\twin = curwin;\n    savewin = curwin;\n    curwin = win;\n    win_setheight(height);\n    curwin = savewin;\n\nvoid\nCursor(win, ...)\n    VIWIN win\n\n    PPCODE:\n    if (items == 1)\n    {\n      EXTEND(sp, 2);\n      if (!win_valid(win))\n\t  win = curwin;\n      PUSHs(sv_2mortal(newSViv(win->w_cursor.lnum)));\n      PUSHs(sv_2mortal(newSViv(win->w_cursor.col)));\n    }\n    else if (items == 3)\n    {\n      int lnum, col;\n\n      if (!win_valid(win))\n\t  win = curwin;\n      lnum = (int) SvIV(ST(1));\n      col = (int) SvIV(ST(2));\n      win->w_cursor.lnum = lnum;\n      win->w_cursor.col = col;\n      check_cursor();\t\t    /* put cursor on an existing line */\n      update_screen(NOT_VALID);\n    }\n\nMODULE = VIM\t    PACKAGE = VIBUF\n\nvoid\nDESTROY(vimbuf)\n    VIBUF vimbuf;\n\n    CODE:\n    if (buf_valid(vimbuf))\n\tvimbuf->b_perl_private = 0;\n\nvoid\nName(vimbuf)\n    VIBUF vimbuf;\n\n    PPCODE:\n    if (!buf_valid(vimbuf))\n\tvimbuf = curbuf;\n    /* No file name returns an empty string */\n    if (vimbuf->b_fname == NULL)\n\tXPUSHs(sv_2mortal(newSVpv(\"\", 0)));\n    else\n\tXPUSHs(sv_2mortal(newSVpv((char *)vimbuf->b_fname, 0)));\n\nvoid\nNumber(vimbuf)\n    VIBUF vimbuf;\n\n    PPCODE:\n    if (!buf_valid(vimbuf))\n\tvimbuf = curbuf;\n    XPUSHs(sv_2mortal(newSViv(vimbuf->b_fnum)));\n\nvoid\nCount(vimbuf)\n    VIBUF vimbuf;\n\n    PPCODE:\n    if (!buf_valid(vimbuf))\n\tvimbuf = curbuf;\n    XPUSHs(sv_2mortal(newSViv(vimbuf->b_ml.ml_line_count)));\n\nvoid\nGet(vimbuf, ...)\n    VIBUF vimbuf;\n\n    PREINIT:\n    char_u *line;\n    int i;\n    long lnum;\n    PPCODE:\n    if (buf_valid(vimbuf))\n    {\n\tfor (i = 1; i < items; i++)\n\t{\n\t    lnum = (long) SvIV(ST(i));\n\t    if (lnum > 0 && lnum <= vimbuf->b_ml.ml_line_count)\n\t    {\n\t\tline = ml_get_buf(vimbuf, lnum, FALSE);\n\t\tXPUSHs(sv_2mortal(newSVpv((char *)line, 0)));\n\t    }\n\t}\n    }\n\nvoid\nSet(vimbuf, ...)\n    VIBUF vimbuf;\n\n    PREINIT:\n    int i;\n    long lnum;\n    char *line;\n    PPCODE:\n    if (buf_valid(vimbuf))\n    {\n\tif (items < 3)\n\t    croak(\"Usage: VIBUF::Set(vimbuf, lnum, @lines)\");\n\n\tlnum = (long) SvIV(ST(1));\n\tfor(i = 2; i < items; i++, lnum++)\n\t{\n\t    line = SvPV(ST(i),PL_na);\n\t    if (lnum > 0 && lnum <= vimbuf->b_ml.ml_line_count && line != NULL)\n\t    {\n\t\taco_save_T\taco;\n\n\t\t/* set curwin/curbuf for \"vimbuf\" and save some things */\n\t\taucmd_prepbuf(&aco, vimbuf);\n\n\t\tif (u_savesub(lnum) == OK)\n\t\t{\n\t\t    ml_replace(lnum, (char_u *)line, TRUE);\n\t\t    changed_bytes(lnum, 0);\n\t\t}\n\n\t\t/* restore curwin/curbuf and a few other things */\n\t\taucmd_restbuf(&aco);\n\t\t/* Careful: autocommands may have made \"vimbuf\" invalid! */\n\t    }\n\t}\n    }\n\nvoid\nDelete(vimbuf, ...)\n    VIBUF vimbuf;\n\n    PREINIT:\n    long i, lnum = 0, count = 0;\n    PPCODE:\n    if (buf_valid(vimbuf))\n    {\n\tif (items == 2)\n\t{\n\t    lnum = (long) SvIV(ST(1));\n\t    count = 1;\n\t}\n\telse if (items == 3)\n\t{\n\t    lnum = (long) SvIV(ST(1));\n\t    count = (long) 1 + SvIV(ST(2)) - lnum;\n\t    if (count == 0)\n\t\tcount = 1;\n\t    if (count < 0)\n\t    {\n\t\tlnum -= count;\n\t\tcount = -count;\n\t    }\n\t}\n\tif (items >= 2)\n\t{\n\t    for (i = 0; i < count; i++)\n\t    {\n\t\tif (lnum > 0 && lnum <= vimbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    aco_save_T\taco;\n\n\t\t    /* set curwin/curbuf for \"vimbuf\" and save some things */\n\t\t    aucmd_prepbuf(&aco, vimbuf);\n\n\t\t    if (u_savedel(lnum, 1) == OK)\n\t\t    {\n\t\t\tml_delete(lnum, 0);\n\t\t\tcheck_cursor();\n\t\t\tdeleted_lines_mark(lnum, 1L);\n\t\t    }\n\n\t\t    /* restore curwin/curbuf and a few other things */\n\t\t    aucmd_restbuf(&aco);\n\t\t    /* Careful: autocommands may have made \"vimbuf\" invalid! */\n\n\t\t    update_curbuf(VALID);\n\t\t}\n\t    }\n\t}\n    }\n\nvoid\nAppend(vimbuf, ...)\n    VIBUF vimbuf;\n\n    PREINIT:\n    int\t\ti;\n    long\tlnum;\n    char\t*line;\n    PPCODE:\n    if (buf_valid(vimbuf))\n    {\n\tif (items < 3)\n\t    croak(\"Usage: VIBUF::Append(vimbuf, lnum, @lines)\");\n\n\tlnum = (long) SvIV(ST(1));\n\tfor (i = 2; i < items; i++, lnum++)\n\t{\n\t    line = SvPV(ST(i),PL_na);\n\t    if (lnum >= 0 && lnum <= vimbuf->b_ml.ml_line_count && line != NULL)\n\t    {\n\t\taco_save_T\taco;\n\n\t\t/* set curwin/curbuf for \"vimbuf\" and save some things */\n\t\taucmd_prepbuf(&aco, vimbuf);\n\n\t\tif (u_inssub(lnum + 1) == OK)\n\t\t{\n\t\t    ml_append(lnum, (char_u *)line, (colnr_T)0, FALSE);\n\t\t    appended_lines_mark(lnum, 1L);\n\t\t}\n\n\t\t/* restore curwin/curbuf and a few other things */\n\t\taucmd_restbuf(&aco);\n\t\t/* Careful: autocommands may have made \"vimbuf\" invalid! */\n\n\t\tupdate_curbuf(VALID);\n\t    }\n\t}\n    }\n\n#ifdef __GNUC__\n# pragma GCC diagnostic pop\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/if_tcl.c": "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * Tcl extensions by Ingo Wilken <Ingo.Wilken@informatik.uni-oldenburg.de>\n * Last modification: Wed May 10 21:28:44 CEST 2000\n * Requires Tcl 8.0 or higher.\n *\n *  Variables:\n *  ::vim::current(buffer)\t# Name of buffer command for current buffer.\n *  ::vim::current(window)\t# Name of window command for current window.\n *  ::vim::range(start)\t\t# Start of current range (line number).\n *  ::vim::range(end)\t\t# End of current range (line number).\n *  ::vim::lbase\t\t# Start of line/column numbers (1 or 0).\n *\n *  Commands:\n *  ::vim::command {cmd}\t# Execute ex command {cmd}.\n *  ::vim::option {opt} [val]\t# Get/Set option {opt}.\n *  ::vim::expr {expr}\t\t# Evaluate {expr} using vim's evaluator.\n *  ::vim::beep\t\t\t# Guess.\n *\n *  set buf [::vim::buffer {n}]\t# Create Tcl command for buffer N.\n *  set bl [::vim::buffer list] # Get list of Tcl commands of all buffers.\n *  ::vim::buffer exists {n}\t# True if buffer {n} exists.\n *\n *  set wl [::vim::window list] # Get list of Tcl commands of all windows.\n *\n *  set n [$win height]\t\t# Report window height.\n *  $win height {n}\t\t# Set window height to {n}.\n *  array set pos [$win cursor] # Get cursor position.\n *  $win cursor {row} {col}\t# Set cursor position.\n *  $win cursor pos\t\t# Set cursor position from array var \"pos\"\n *  $win delcmd {cmd}\t\t# Register callback command for closed window.\n *  $win option {opt} [val]\t# Get/Set vim option in context of $win.\n *  $win command {cmd}\t\t# Execute ex command in context of $win.\n *  $win expr {expr}\t\t# Evaluate vim expression in context of $win.\n *  set buf [$win buffer]\t# Create Tcl command for window's buffer.\n *\n *  $buf name\t\t\t# Reports file name in buffer.\n *  $buf number\t\t\t# Reports buffer number.\n *  set l [$buf get {n}]\t# Get buffer line {n} as a string.\n *  set L [$buf get {n} {m}]\t# Get lines {n} through {m} as a list.\n *  $buf count\t\t\t# Reports number of lines in buffer.\n *  $buf last\t\t\t# Reports number of last line in buffer.\n *  $buf delete {n}\t\t# Delete line {n}.\n *  $buf delete {n} {m}\t\t# Delete lines {n} through {m}.\n *  $buf set {n} {l}\t\t# Set line {n} to string {l}.\n *  $buf set {n} {m} {L}\t# Set lines {n} through {m} from list {L}.\n *\t\t\t\t# Delete/inserts lines as appropriate.\n *  $buf option {opt} [val]\t# Get/Set vim option in context of $buf.\n *  $buf command {cmd}\t\t# Execute ex command in context of $buf\n *  $buf expr {cmd}\t\t# Evaluate vim expression in context of $buf.\n *  array set pos [$buf mark {m}]   # Get position of mark.\n *  $buf append {n} {str}\t# Append string {str} to buffer,after line {n}.\n *  $buf insert {n} {str}\t# Insert string {str} in buffer as line {n}.\n *  $buf delcmd {cmd}\t\t# Register callback command for deleted buffer.\n *  set wl [$buf windows]\t# Get list of Tcl commands for all windows of\n *\t\t\t\t# this buffer.\nTODO:\n *  ::vim::buffer new\t\t#   create new buffer + Tcl command\n */\n\n#include \"vim.h\"\n#undef EXTERN\t\t\t/* tcl.h defines it too */\n\n#ifdef DYNAMIC_TCL\n# define USE_TCL_STUBS /* use tcl's stubs mechanism */\n#endif\n\n#include <tcl.h>\n#include <string.h>\n\ntypedef struct\n{\n    Tcl_Interp *interp;\n    int exitvalue;\n    int range_start, range_end;\n    int lbase;\n    char *curbuf, *curwin;\n} tcl_info;\n\nstatic tcl_info tclinfo = { NULL, 0, 0, 0, 0, NULL, NULL };\n\n#define VAR_RANGE1\t\"::vim::range(start)\"\n#define VAR_RANGE2\t\"::vim::range(begin)\"\n#define VAR_RANGE3\t\"::vim::range(end)\"\n#define VAR_CURBUF\t\"::vim::current(buffer)\"\n#define VAR_CURWIN\t\"::vim::current(window)\"\n#define VAR_LBASE\t\"::vim::lbase\"\n#define VAR_CURLINE\t\"line\"\n#define VAR_CURLNUM\t\"lnum\"\n#define VARNAME_SIZE\t64\n\n#define row2tcl(x)  ((x) - (tclinfo.lbase==0))\n#define row2vim(x)  ((x) + (tclinfo.lbase==0))\n#define col2tcl(x)  ((x) + (tclinfo.lbase!=0))\n#define col2vim(x)  ((x) - (tclinfo.lbase!=0))\n\n\n#define VIMOUT\t((ClientData)1)\n#define VIMERR\t((ClientData)2)\n\n/* This appears to be new in Tcl 8.4. */\n#ifndef CONST84\n# define CONST84\n#endif\n\n/*\n *  List of Tcl interpreters who reference a vim window or buffer.\n *  Each buffer and window has it's own list in the w_tcl_ref or b_tcl_ref\n *  struct member.  We need this because Tcl can create sub-interpreters with\n *  the \"interp\" command, and each interpreter can reference all windows and\n *  buffers.\n */\nstruct ref\n{\n    struct ref\t*next;\n\n    Tcl_Interp\t*interp;\n    Tcl_Command cmd;\t    /* Tcl command that represents this object */\n    Tcl_Obj\t*delcmd;    /* Tcl command to call when object is being del. */\n    void\t*vimobj;    /* Vim window or buffer (win_T* or buf_T*) */\n};\nstatic char * tclgetbuffer _ANSI_ARGS_((Tcl_Interp *interp, buf_T *buf));\nstatic char * tclgetwindow _ANSI_ARGS_((Tcl_Interp *interp, win_T *win));\nstatic int tclsetdelcmd _ANSI_ARGS_((Tcl_Interp *interp, struct ref *reflist, void *vimobj, Tcl_Obj *delcmd));\nstatic int tclgetlinenum _ANSI_ARGS_ ((Tcl_Interp *interp, Tcl_Obj *obj, int *valueP, buf_T *buf));\nstatic win_T *tclfindwin _ANSI_ARGS_ ((buf_T *buf));\nstatic int tcldoexcommand _ANSI_ARGS_ ((Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], int objn));\nstatic int tclsetoption _ANSI_ARGS_ ((Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], int objn));\nstatic int tclvimexpr _ANSI_ARGS_ ((Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], int objn));\nstatic void tcldelthisinterp _ANSI_ARGS_ ((void));\n\nstatic int vimerror _ANSI_ARGS_((Tcl_Interp *interp));\nstatic void tclmsg _ANSI_ARGS_((char *text));\nstatic void tclerrmsg _ANSI_ARGS_((char *text));\nstatic void tclupdatevars _ANSI_ARGS_((void));\n\nstatic struct ref refsdeleted;\t/* dummy object for deleted ref list */\n\n/*****************************************************************************\n * TCL interface manager\n ****************************************************************************/\n\n#if defined(DYNAMIC_TCL) || defined(PROTO)\n# ifndef DYNAMIC_TCL_DLL\n#  define DYNAMIC_TCL_DLL \"tcl83.dll\"\n# endif\n# ifndef DYNAMIC_TCL_VER\n#  define DYNAMIC_TCL_VER \"8.3\"\n# endif\n\n# ifndef  DYNAMIC_TCL /* Just generating prototypes */\ntypedef int HANDLE;\n# endif\n\n# ifndef WIN3264\n#  include <dlfcn.h>\n#  define HANDLE void*\n#  define TCL_PROC void*\n#  define load_dll(n) dlopen((n), RTLD_LAZY|RTLD_GLOBAL)\n#  define symbol_from_dll dlsym\n#  define close_dll dlclose\n# else\n#  define TCL_PROC FARPROC\n#  define load_dll vimLoadLib\n#  define symbol_from_dll GetProcAddress\n#  define close_dll FreeLibrary\n# endif\n\n/*\n * Declare HANDLE for tcl.dll and function pointers.\n */\nstatic HANDLE hTclLib = NULL;\nTcl_Interp* (*dll_Tcl_CreateInterp)();\nvoid (*dll_Tcl_FindExecutable)(const void *);\n\n/*\n * Table of name to function pointer of tcl.\n */\nstatic struct {\n    char* name;\n    TCL_PROC* ptr;\n} tcl_funcname_table[] = {\n    {\"Tcl_CreateInterp\", (TCL_PROC*)&dll_Tcl_CreateInterp},\n    {\"Tcl_FindExecutable\", (TCL_PROC*)&dll_Tcl_FindExecutable},\n    {NULL, NULL},\n};\n\n/*\n * Make all runtime-links of tcl.\n *\n * 1. Get module handle using LoadLibraryEx.\n * 2. Get pointer to tcl function by GetProcAddress.\n * 3. Repeat 2, until get all functions will be used.\n *\n * Parameter 'libname' provides name of DLL.\n * Return OK or FAIL.\n */\n    static int\ntcl_runtime_link_init(char *libname, int verbose)\n{\n    int i;\n\n    if (hTclLib)\n\treturn OK;\n    if (!(hTclLib = load_dll(libname)))\n    {\n\tif (verbose)\n\t    EMSG2(_(e_loadlib), libname);\n\treturn FAIL;\n    }\n    for (i = 0; tcl_funcname_table[i].ptr; ++i)\n    {\n\tif (!(*tcl_funcname_table[i].ptr = symbol_from_dll(hTclLib,\n\t\t\ttcl_funcname_table[i].name)))\n\t{\n\t    close_dll(hTclLib);\n\t    hTclLib = NULL;\n\t    if (verbose)\n\t\tEMSG2(_(e_loadfunc), tcl_funcname_table[i].name);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n#endif /* defined(DYNAMIC_TCL) || defined(PROTO) */\n\n#ifdef DYNAMIC_TCL\nstatic char *find_executable_arg = NULL;\n#endif\n\n    void\nvim_tcl_init(char *arg)\n{\n#ifndef DYNAMIC_TCL\n    Tcl_FindExecutable(arg);\n#else\n    find_executable_arg = arg;\n#endif\n}\n\n#if defined(DYNAMIC_TCL) || defined(PROTO)\n\nstatic int stubs_initialized = FALSE;\n\n/*\n * Return TRUE if the TCL interface can be used.\n */\n    int\ntcl_enabled(int verbose)\n{\n    if (!stubs_initialized && find_executable_arg != NULL\n\t    && tcl_runtime_link_init((char *)p_tcldll, verbose) == OK)\n    {\n\tTcl_Interp *interp;\n\n\tdll_Tcl_FindExecutable(find_executable_arg);\n\n\tif ((interp = dll_Tcl_CreateInterp()) != NULL)\n\t{\n\t    if (Tcl_InitStubs(interp, DYNAMIC_TCL_VER, 0))\n\t    {\n\t\tTcl_DeleteInterp(interp);\n\t\tstubs_initialized = TRUE;\n\t    }\n\t    /* FIXME: When Tcl_InitStubs() was failed, how delete interp? */\n\t}\n    }\n    return stubs_initialized;\n}\n#endif\n\n    void\ntcl_end(void)\n{\n#ifdef DYNAMIC_TCL\n    if (hTclLib)\n    {\n\tclose_dll(hTclLib);\n\thTclLib = NULL;\n    }\n#endif\n}\n\n/****************************************************************************\n  Tcl commands\n ****************************************************************************/\n\n/*\n * Replace standard \"exit\" command.\n *\n * Delete the Tcl interpreter; a new one will be created with the next\n * :tcl command). The exit code is saved (and retrieved in tclexit()).\n * Since Tcl's exit is never expected to return and this replacement\n * does, then (except for a trivial case) additional Tcl commands will\n * be run. Since the interpreter is now marked as deleted, an error\n * will be returned -- typically \"attempt to call eval in deleted\n * interpreter\". Hopefully, at this point, checks for TCL_ERROR take\n * place and control percolates back up to Vim -- but with this new error\n * string in the interpreter's result value. Therefore it would be\n * useless for this routine to return the exit code via Tcl_SetResult().\n */\n    static int\nexitcmd(\n    ClientData dummy UNUSED,\n    Tcl_Interp *interp,\n    int objc,\n    Tcl_Obj *CONST objv[])\n{\n    int value = 0;\n\n    switch (objc)\n    {\n\tcase 2:\n\t    if (Tcl_GetIntFromObj(interp, objv[1], &value) != TCL_OK)\n\t\tbreak;\n\t    /* FALLTHROUGH */\n\tcase 1:\n\t    tclinfo.exitvalue = value;\n\n\t    Tcl_DeleteInterp(interp);\n\t    break;\n\tdefault:\n\t    Tcl_WrongNumArgs(interp, 1, objv, \"?returnCode?\");\n    }\n    return TCL_ERROR;\n}\n\n/*\n *  \"::vim::beep\" - what Vi[m] does best :-)\n */\n    static int\nbeepcmd(\n    ClientData dummy UNUSED,\n    Tcl_Interp *interp,\n    int objc,\n    Tcl_Obj *CONST objv[])\n{\n    if (objc != 1)\n    {\n\tTcl_WrongNumArgs(interp, 1, objv, NULL);\n\treturn TCL_ERROR;\n    }\n    vim_beep(BO_LANG);\n    return TCL_OK;\n}\n\n/*\n *  \"::vim::buffer list\" - create a list of buffer commands.\n *  \"::vim::buffer {N}\" - create buffer command for buffer N.\n *  \"::vim::buffer exists {N}\" - test if buffer N exists.\n *  \"::vim::buffer new\" - create a new buffer (not implemented)\n */\n    static int\nbuffercmd(\n    ClientData dummy UNUSED,\n    Tcl_Interp *interp,\n    int objc,\n    Tcl_Obj *CONST objv[])\n{\n    char\t*name;\n    buf_T\t*buf;\n    Tcl_Obj\t*resobj;\n    int\t\terr, n, idx;\n    enum {BCMD_EXISTS, BCMD_LIST};\n    static CONST84 char *bcmdoptions[] =\n    {\n\t\"exists\", \"list\", (char *)0\n    };\n\n    if (objc < 2)\n    {\n\tTcl_WrongNumArgs(interp, 1, objv, \"option\");\n\treturn TCL_ERROR;\n    }\n    err = Tcl_GetIntFromObj(interp, objv[1], &n);\n    if (err == TCL_OK)\n    {\n\tif (objc != 2)\n\t{\n\t    Tcl_WrongNumArgs(interp, 1, objv, \"bufNumber\");\n\t    return TCL_ERROR;\n\t}\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    if (buf->b_fnum == n)\n\t    {\n\t\tname = tclgetbuffer(interp, buf);\n\t\tif (name == NULL)\n\t\t    return TCL_ERROR;\n\t\tTcl_SetResult(interp, name, TCL_VOLATILE);\n\t\treturn TCL_OK;\n\t    }\n\t}\n\tTcl_SetResult(interp, _(\"invalid buffer number\"), TCL_STATIC);\n\treturn TCL_ERROR;\n    }\n    Tcl_ResetResult(interp); /* clear error from Tcl_GetIntFromObj */\n\n    err = Tcl_GetIndexFromObj(interp, objv[1], bcmdoptions, \"option\", 0, &idx);\n    if (err != TCL_OK)\n\treturn err;\n    switch (idx)\n    {\n\tcase BCMD_LIST:\n\t    if (objc != 2)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 2, objv, \"\");\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tname = tclgetbuffer(interp, buf);\n\t\tif (name == NULL)\n\t\t{\n\t\t    err = TCL_ERROR;\n\t\t    break;\n\t\t}\n\t\tTcl_AppendElement(interp, name);\n\t    }\n\t    break;\n\n\tcase BCMD_EXISTS:\n\t    if (objc != 3)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 2, objv, \"bufNumber\");\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    err = Tcl_GetIntFromObj(interp, objv[2], &n);\n\t    if (err == TCL_OK)\n\t    {\n\t\tbuf = buflist_findnr(n);\n\t\tresobj = Tcl_NewIntObj(buf != NULL);\n\t\tTcl_SetObjResult(interp, resobj);\n\t    }\n\t    break;\n\n\tdefault:\n\t    Tcl_SetResult(interp, _(\"not implemented yet\"), TCL_STATIC);\n\t    err = TCL_ERROR;\n    }\n    return err;\n}\n\n/*\n * \"::vim::window list\" - create list of window commands.\n */\n    static int\nwindowcmd(\n    ClientData\tdummy UNUSED,\n    Tcl_Interp\t*interp,\n    int\t\tobjc,\n    Tcl_Obj\t*CONST objv[])\n{\n    char\t*what, *string;\n    win_T\t*win;\n\n    if (objc != 2)\n    {\n\tTcl_WrongNumArgs(interp, 1, objv, \"option\");\n\treturn TCL_ERROR;\n    }\n    what = Tcl_GetStringFromObj(objv[1], NULL);\n    if (strcmp(what, \"list\") == 0)\n    {\n\tFOR_ALL_WINDOWS(win)\n\t{\n\t    string = tclgetwindow(interp, win);\n\t    if (string == NULL)\n\t\treturn TCL_ERROR;\n\t    Tcl_AppendElement(interp, string);\n\t}\n\treturn TCL_OK;\n    }\n    Tcl_SetResult(interp, _(\"unknown option\"), TCL_STATIC);\n    return TCL_ERROR;\n}\n\n/*\n * flags for bufselfcmd and winselfcmd to indicate outstanding actions.\n */\n#define FL_UPDATE_SCREEN\t(1<<0)\n#define FL_UPDATE_CURBUF\t(1<<1)\n#define FL_ADJUST_CURSOR\t(1<<2)\n\n/*\n * This function implements the buffer commands.\n */\n    static int\nbufselfcmd(\n    ClientData\tref,\n    Tcl_Interp\t*interp,\n    int\t\tobjc,\n    Tcl_Obj\t*CONST objv[])\n{\n    int\t\topt, err, idx, flags;\n    int\t\tval1, val2, n, i;\n    buf_T\t*buf, *savebuf;\n    win_T\t*win, *savewin;\n    Tcl_Obj\t*resobj;\n    pos_T\t*pos;\n    char\t*line;\n\n    enum\n    {\n\tBUF_APPEND, BUF_COMMAND, BUF_COUNT, BUF_DELCMD, BUF_DELETE, BUF_EXPR,\n\tBUF_GET, BUF_INSERT, BUF_LAST, BUF_MARK, BUF_NAME, BUF_NUMBER,\n\tBUF_OPTION, BUF_SET, BUF_WINDOWS\n    };\n    static CONST84 char *bufoptions[] =\n    {\n\t\"append\", \"command\", \"count\", \"delcmd\", \"delete\", \"expr\",\n\t\"get\", \"insert\", \"last\", \"mark\", \"name\", \"number\",\n\t\"option\", \"set\", \"windows\", (char *)0\n    };\n\n    if (objc < 2)\n    {\n\tTcl_WrongNumArgs(interp, 1, objv, \"option ?arg ...?\");\n\treturn TCL_ERROR;\n    }\n\n    err = Tcl_GetIndexFromObj(interp, objv[1], bufoptions, \"option\", 0, &idx);\n    if (err != TCL_OK)\n\treturn err;\n\n    buf = (buf_T *)((struct ref *)ref)->vimobj;\n    savebuf = curbuf;  curbuf = buf;\n    savewin = curwin;  curwin = tclfindwin(buf);\n    flags = 0;\n    opt = 0;\n\n    switch (idx)\n    {\n\tcase BUF_COMMAND:\n\t    err = tcldoexcommand(interp, objc, objv, 2);\n\t    flags |= FL_UPDATE_SCREEN;\n\t    break;\n\n\tcase BUF_OPTION:\n\t    err = tclsetoption(interp, objc, objv, 2);\n\t    flags |= FL_UPDATE_SCREEN;\n\t    break;\n\n\tcase BUF_EXPR:\n\t    err = tclvimexpr(interp, objc, objv, 2);\n\t    break;\n\n\tcase BUF_NAME:\n\t    /*\n\t     *\tGet filename of buffer.\n\t     */\n\t    if (objc != 2)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 2, objv, NULL);\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    if (buf->b_ffname)\n\t\tTcl_SetResult(interp, (char *)buf->b_ffname, TCL_VOLATILE);\n\t    else\n\t\tTcl_SetResult(interp, \"\", TCL_STATIC);\n\t    break;\n\n\tcase BUF_LAST:\n\t    /*\n\t     * Get line number of last line.\n\t     */\n\t    opt = 1;\n\t    /* fallthrough */\n\tcase BUF_COUNT:\n\t    /*\n\t     * Get number of lines in buffer.\n\t     */\n\t    if (objc != 2)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 2, objv, NULL);\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    val1 = (int)buf->b_ml.ml_line_count;\n\t    if (opt)\n\t\tval1 = row2tcl(val1);\n\n\t    resobj = Tcl_NewIntObj(val1);\n\t    Tcl_SetObjResult(interp, resobj);\n\t    break;\n\n\tcase BUF_NUMBER:\n\t    /*\n\t     * Get buffer's number.\n\t     */\n\t    if (objc != 2)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 2, objv, NULL);\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    resobj = Tcl_NewIntObj((int)buf->b_fnum);\n\t    Tcl_SetObjResult(interp, resobj);\n\t    break;\n\n\tcase BUF_GET:\n\t    if (objc != 3 && objc != 4)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 2, objv, \"lineNumber ?lineNumber?\");\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    err = tclgetlinenum(interp, objv[2], &val1, buf);\n\t    if (err != TCL_OK)\n\t\tbreak;\n\t    if (objc == 4)\n\t    {\n\t\terr = tclgetlinenum(interp, objv[3], &val2, buf);\n\t\tif (err != TCL_OK)\n\t\t    break;\n\t\tif (val1 > val2)\n\t\t{\n\t\t    n = val1; val1 = val2; val2 = n;\n\t\t}\n\t\tTcl_ResetResult(interp);\n\n\t\tfor (n = val1; n <= val2 && err == TCL_OK; n++)\n\t\t{\n\t\t    line = (char *)ml_get_buf(buf, (linenr_T)n, FALSE);\n\t\t    if (line)\n\t\t\tTcl_AppendElement(interp, line);\n\t\t    else\n\t\t\terr = TCL_ERROR;\n\t\t}\n\t    }\n\t    else {  /* objc == 3 */\n\t\tline = (char *)ml_get_buf(buf, (linenr_T)val1, FALSE);\n\t\tTcl_SetResult(interp, line, TCL_VOLATILE);\n\t    }\n\t    break;\n\n\tcase BUF_SET:\n\t    if (objc != 4 && objc != 5)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 3, objv, \"lineNumber ?lineNumber? stringOrList\");\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    err = tclgetlinenum(interp, objv[2], &val1, buf);\n\t    if (err != TCL_OK)\n\t\treturn TCL_ERROR;\n\t    if (objc == 4)\n\t    {\n\t\t/*\n\t\t *  Replace one line with a string.\n\t\t *\t$buf set {n} {string}\n\t\t */\n\t\tline = Tcl_GetStringFromObj(objv[3], NULL);\n\t\tif (u_savesub((linenr_T)val1) != OK)\n\t\t{\n\t\t    Tcl_SetResult(interp, _(\"cannot save undo information\"), TCL_STATIC);\n\t\t    err = TCL_ERROR;\n\t\t}\n\t\telse\n\t\tif (ml_replace((linenr_T)val1, (char_u *)line, TRUE) != OK)\n\t\t{\n\t\t    Tcl_SetResult(interp, _(\"cannot replace line\"), TCL_STATIC);\n\t\t    err = TCL_ERROR;\n\t\t}\n\t\telse\n\t\t{\n\t\t    changed_bytes((linenr_T)val1, 0);\n\t\t    flags |= FL_UPDATE_CURBUF;\n\t\t}\n\t\tbreak;\n\t    }\n\t    else\n\t    {\n\t\t/*\n\t\t * Replace several lines with the elements of a Tcl list.\n\t\t *\t$buf set {n} {m} {list}\n\t\t * If the list contains more than {m}-{n}+1 elements, they\n\t\t * are * inserted after line {m}.  If the list contains fewer\n\t\t * elements, * the lines from {n}+length({list}) through {m}\n\t\t * are deleted.\n\t\t */\n\t\tint\t    lc;\n\t\tTcl_Obj\t    **lv;\n\n\t\terr = tclgetlinenum(interp, objv[3], &val2, buf);\n\t\tif (err != TCL_OK)\n\t\t    break;\n\t\terr = Tcl_ListObjGetElements(interp, objv[4], &lc, &lv);\n\t\tif (err != TCL_OK)\n\t\t    break;\n\t\tif (val1 > val2)\n\t\t{\n\t\t    n = val1;\n\t\t    val1 = val2;\n\t\t    val2 = n;\n\t\t}\n\n\t\tn = val1;\n\t\tif (u_save((linenr_T)(val1 - 1), (linenr_T)(val2 + 1)) != OK)\n\t\t{\n\t\t    Tcl_SetResult(interp, _(\"cannot save undo information\"),\n\t\t\t\t\t\t\t\t  TCL_STATIC);\n\t\t    err = TCL_ERROR;\n\t\t    break;\n\t\t}\n\t\tflags |= FL_UPDATE_CURBUF;\n\n\t\tfor (i = 0; i < lc && n <= val2; i++)\n\t\t{\n\t\t    line = Tcl_GetStringFromObj(lv[i], NULL);\n\t\t    if (ml_replace((linenr_T)n, (char_u *)line, TRUE) != OK)\n\t\t\tgoto setListError;\n\t\t    ++n;\n\t\t}\n\t\tif (i < lc)\n\t\t{\n\t\t    /* append lines */\n\t\t    do\n\t\t    {\n\t\t\tline = Tcl_GetStringFromObj(lv[i], NULL);\n\t\t\tif (ml_append((linenr_T)(n - 1),\n\t\t\t\t\t      (char_u *)line, 0, FALSE) != OK)\n\t\t\t    goto setListError;\n\t\t\t++n;\n\t\t\t++i;\n\t\t    } while (i < lc);\n\t\t}\n\t\telse if (n <= val2)\n\t\t{\n\t\t    /* did not replace all lines, delete */\n\t\t    i = n;\n\t\t    do\n\t\t    {\n\t\t\tif (ml_delete((linenr_T)i, FALSE) != OK)\n\t\t\t    goto setListError;\n\t\t\t++n;\n\t\t    } while (n <= val2);\n\t\t}\n\t\tlc -= val2 - val1 + 1;\t/* number of lines to be replaced */\n\t\tmark_adjust((linenr_T)val1, (linenr_T)val2, (long)MAXLNUM,\n\t\t\t\t\t\t\t\t    (long)lc);\n\t\tchanged_lines((linenr_T)val1, 0, (linenr_T)val2 + 1, (long)lc);\n\t\tbreak;\n    setListError:\n\t\tu_undo(1);  /* ??? */\n\t\tTcl_SetResult(interp, _(\"cannot set line(s)\"), TCL_STATIC);\n\t\terr = TCL_ERROR;\n\t    }\n\t    break;\n\n\tcase BUF_DELETE:\n\t    if (objc != 3  &&  objc != 4)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 3, objv, \"lineNumber ?lineNumber?\");\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    err = tclgetlinenum(interp, objv[2], &val1, buf);\n\t    if (err != TCL_OK)\n\t\tbreak;\n\t    val2 = val1;\n\t    if (objc == 4)\n\t    {\n\t\terr = tclgetlinenum(interp, objv[3], &val2, buf);\n\t\tif (err != TCL_OK)\n\t\t    return err;\n\t\tif (val1 > val2)\n\t\t{\n\t\t    i = val1; val1 = val2; val2 = i;\n\t\t}\n\t    }\n\t    n = val2 - val1 + 1;\n\t    if (u_savedel((linenr_T)val1, (long)n) != OK)\n\t    {\n\t\tTcl_SetResult(interp, _(\"cannot save undo information\"),\n\t\t\t\t\t\t\t\t  TCL_STATIC);\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    for (i = 0; i < n; i++)\n\t    {\n\t\tml_delete((linenr_T)val1, FALSE);\n\t\terr = vimerror(interp);\n\t\tif (err != TCL_OK)\n\t\t    break;\n\t    }\n\t    if (i > 0)\n\t\tdeleted_lines_mark((linenr_T)val1, (long)i);\n\t    flags |= FL_ADJUST_CURSOR|FL_UPDATE_SCREEN;\n\t    break;\n\n\tcase BUF_MARK:\n\t    if (objc != 3)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 2, objv, \"markName\");\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    line = Tcl_GetStringFromObj(objv[2], NULL);\n\n\t    pos = NULL;\n\t    if (line[0] != '\\0'  &&  line[1] == '\\0')\n\t    {\n\t\tpos = getmark(line[0], FALSE);\n\t    }\n\t    if (pos == NULL)\n\t    {\n\t\tTcl_SetResult(interp, _(\"invalid mark name\"), TCL_STATIC);\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    err = vimerror(interp);\n\t    if (err != TCL_OK)\n\t\tbreak;\n\t    if (pos->lnum <= 0)\n\t    {\n\t\tTcl_SetResult(interp, _(\"mark not set\"), TCL_STATIC);\n\t\terr = TCL_ERROR;\n\t    }\n\t    else\n\t    {\n\t\tchar rbuf[64];\n\n\t\tsprintf(rbuf, _(\"row %d column %d\"),\n\t\t\t     (int)row2tcl(pos->lnum), (int)col2tcl(pos->col));\n\t\tTcl_SetResult(interp, rbuf, TCL_VOLATILE);\n\t    }\n\t    break;\n\n\tcase BUF_INSERT:\n\t    opt = 1;\n\t    /* fallthrough */\n\tcase BUF_APPEND:\n\t    if (objc != 4)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 2, objv, \"lineNum text\");\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    err = tclgetlinenum(interp, objv[2], &val1, buf);\n\t    if (err != TCL_OK)\n\t\tbreak;\n\t    if (opt)\n\t\t--val1;\n\t    if (u_save((linenr_T)val1, (linenr_T)(val1+1)) != OK)\n\t    {\n\t\tTcl_SetResult(interp, _(\"cannot save undo information\"),\n\t\t\t\t\t\t\t\t  TCL_STATIC);\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\n\t    line = Tcl_GetStringFromObj(objv[3], NULL);\n\t    if (ml_append((linenr_T)val1, (char_u *)line, 0, FALSE) != OK)\n\t    {\n\t\tTcl_SetResult(interp, _(\"cannot insert/append line\"),\n\t\t\t\t\t\t\t\t  TCL_STATIC);\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    appended_lines_mark((linenr_T)val1, 1L);\n\t    flags |= FL_UPDATE_SCREEN;\n\t    break;\n\n\tcase BUF_WINDOWS:\n\t    /*\n\t     * Return list of window commands.\n\t     */\n\t    if (objc != 2)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 2, objv, NULL);\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    Tcl_ResetResult(interp);\n\t    FOR_ALL_WINDOWS(win)\n\t    {\n\t\tif (win->w_buffer == buf)\n\t\t{\n\t\t    line = tclgetwindow(interp, win);\n\t\t    if (line != NULL)\n\t\t\tTcl_AppendElement(interp, line);\n\t\t    else\n\t\t    {\n\t\t\terr = TCL_ERROR;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase BUF_DELCMD:\n\t    /*\n\t     * Register deletion callback.\n\t     * TODO: Should be able to register multiple callbacks\n\t     */\n\t    if (objc != 3)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 2, objv, \"command\");\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    err = tclsetdelcmd(interp, buf->b_tcl_ref, (void *)buf, objv[2]);\n\t    break;\n\n\tdefault:\n\t    Tcl_SetResult(interp, _(\"not implemented yet\"), TCL_STATIC);\n\t    err = TCL_ERROR;\n    }\n\n    if (flags & FL_UPDATE_CURBUF)\n\tredraw_curbuf_later(NOT_VALID);\n    curbuf = savebuf;\n    curwin = savewin;\n    if (flags & FL_ADJUST_CURSOR)\n\tcheck_cursor();\n    if (flags & (FL_UPDATE_SCREEN | FL_UPDATE_CURBUF))\n\tupdate_screen(NOT_VALID);\n\n    return err;\n}\n\n/*\n * This function implements the window commands.\n */\n    static int\nwinselfcmd(\n    ClientData\tref,\n    Tcl_Interp\t*interp,\n    int\t\tobjc,\n    Tcl_Obj\t*CONST objv[])\n{\n    int\t\terr, idx, flags;\n    int\t\tval1, val2;\n    Tcl_Obj\t*resobj;\n    win_T\t*savewin, *win;\n    buf_T\t*savebuf;\n    char\t*str;\n\n    enum\n    {\n\tWIN_BUFFER, WIN_COMMAND, WIN_CURSOR, WIN_DELCMD, WIN_EXPR,\n\tWIN_HEIGHT, WIN_OPTION\n    };\n    static CONST84 char *winoptions[] =\n    {\n\t\"buffer\", \"command\", \"cursor\", \"delcmd\", \"expr\",\n\t\"height\", \"option\", (char *)0\n    };\n\n    if (objc < 2)\n    {\n\tTcl_WrongNumArgs(interp, 1, objv, \"option ?arg ...?\");\n\treturn TCL_ERROR;\n    }\n\n    err = Tcl_GetIndexFromObj(interp, objv[1], winoptions, \"option\", 0,  &idx);\n    if (err != TCL_OK)\n\treturn TCL_ERROR;\n\n    win = (win_T *)((struct ref *)ref)->vimobj;\n    savewin = curwin;  curwin = win;\n    savebuf = curbuf;  curbuf = win->w_buffer;\n    flags = 0;\n\n    switch (idx)\n    {\n\tcase WIN_OPTION:\n\t    err = tclsetoption(interp, objc, objv, 2);\n\t    flags |= FL_UPDATE_SCREEN;\n\t    break;\n\n\tcase WIN_COMMAND:\n\t    err = tcldoexcommand(interp, objc, objv, 2);\n\t    flags |= FL_UPDATE_SCREEN;\n\t    break;\n\n\tcase WIN_EXPR:\n\t    err = tclvimexpr(interp, objc, objv, 2);\n\t    break;\n\n\tcase WIN_HEIGHT:\n\t    if (objc == 3)\n\t    {\n\t\terr = Tcl_GetIntFromObj(interp, objv[2], &val1);\n\t\tif (err != TCL_OK)\n\t\t    break;\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(val1);\n\t\terr = vimerror(interp);\n\t\tif (err != TCL_OK)\n\t\t    break;\n\t    }\n\t    else\n\t    if (objc != 2)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 2, objv, \"?value?\");\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\n\t    resobj = Tcl_NewIntObj((int)(win->w_height));\n\t    Tcl_SetObjResult(interp, resobj);\n\t    break;\n\n\tcase WIN_BUFFER:\n\t    if (objc != 2)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 2, objv, NULL);\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    str = tclgetbuffer(interp, win->w_buffer);\n\t    if (str)\n\t\tTcl_SetResult(interp, str, TCL_VOLATILE);\n\t    else\n\t\terr = TCL_ERROR;\n\t    break;\n\n\tcase WIN_DELCMD:\n\t    if (objc != 3)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 2, objv, \"command\");\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    err = tclsetdelcmd(interp, win->w_tcl_ref, (void *)win, objv[2]);\n\t    break;\n\n\tcase WIN_CURSOR:\n\t    if (objc > 4)\n\t    {\n\t\tTcl_WrongNumArgs(interp, 2, objv, \"?arg1 ?arg2??\");\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    if (objc == 2)\n\t    {\n\t\tchar buf[64];\n\n\t\tsprintf(buf, _(\"row %d column %d\"), (int)row2tcl(win->w_cursor.lnum), (int)col2tcl(win->w_cursor.col));\n\t\tTcl_SetResult(interp, buf, TCL_VOLATILE);\n\t\tbreak;\n\t    }\n\t    else if (objc == 3)\n\t    {\n\t\tTcl_Obj *part, *var;\n\n\t\tpart = Tcl_NewStringObj(\"row\", -1);\n\t\tvar = Tcl_ObjGetVar2(interp, objv[2], part, TCL_LEAVE_ERR_MSG);\n\t\tif (var == NULL)\n\t\t{\n\t\t    err = TCL_ERROR;\n\t\t    break;\n\t\t}\n\t\terr = tclgetlinenum(interp, var, &val1, win->w_buffer);\n\t\tif (err != TCL_OK)\n\t\t    break;\n\t\tpart = Tcl_NewStringObj(\"column\", -1);\n\t\tvar = Tcl_ObjGetVar2(interp, objv[2], part, TCL_LEAVE_ERR_MSG);\n\t\tif (var == NULL)\n\t\t{\n\t\t    err = TCL_ERROR;\n\t\t    break;\n\t\t}\n\t\terr = Tcl_GetIntFromObj(interp, var, &val2);\n\t\tif (err != TCL_OK)\n\t\t    break;\n\t    }\n\t    else {  /* objc == 4 */\n\t\terr = tclgetlinenum(interp, objv[2], &val1, win->w_buffer);\n\t\tif (err != TCL_OK)\n\t\t    break;\n\t\terr = Tcl_GetIntFromObj(interp, objv[3], &val2);\n\t\tif (err != TCL_OK)\n\t\t    break;\n\t    }\n\t    /* TODO: should check column */\n\t    win->w_cursor.lnum = val1;\n\t    win->w_cursor.col = col2vim(val2);\n\t    flags |= FL_UPDATE_SCREEN;\n\t    break;\n\n\tdefault:\n\t    Tcl_SetResult(interp, _(\"not implemented yet\"), TCL_STATIC);\n\t    break;\n    }\n\n    curwin = savewin;\n    curbuf = savebuf;\n    if (flags & FL_UPDATE_SCREEN)\n\tupdate_screen(NOT_VALID);\n\n    return err;\n}\n\n\n    static int\ncommandcmd(\n    ClientData\tdummy UNUSED,\n    Tcl_Interp\t*interp,\n    int\t\tobjc,\n    Tcl_Obj\t*CONST objv[])\n{\n    int\t\terr;\n\n    err = tcldoexcommand(interp, objc, objv, 1);\n    update_screen(VALID);\n    return err;\n}\n\n    static int\noptioncmd(\n    ClientData\tdummy UNUSED,\n    Tcl_Interp\t*interp,\n    int\t\tobjc,\n    Tcl_Obj\t*CONST objv[])\n{\n    int\t\terr;\n\n    err = tclsetoption(interp, objc, objv, 1);\n    update_screen(VALID);\n    return err;\n}\n\n    static int\nexprcmd(\n    ClientData\tdummy UNUSED,\n    Tcl_Interp\t*interp,\n    int\t\tobjc,\n    Tcl_Obj\t*CONST objv[])\n{\n    return tclvimexpr(interp, objc, objv, 1);\n}\n\n/****************************************************************************\n  Support functions for Tcl commands\n ****************************************************************************/\n\n/*\n * Get a line number from 'obj' and convert it to vim's range.\n */\n    static int\ntclgetlinenum(\n    Tcl_Interp\t*interp,\n    Tcl_Obj\t*obj,\n    int\t\t*valueP,\n    buf_T\t*buf)\n{\n    int err, i;\n\n    enum { LN_BEGIN, LN_BOTTOM, LN_END, LN_FIRST, LN_LAST, LN_START, LN_TOP };\n\n    static CONST84 char *keyw[] =\n    {\n\t\"begin\", \"bottom\", \"end\", \"first\", \"last\", \"start\", \"top\", (char *)0\n    };\n\n    err = Tcl_GetIndexFromObj(interp, obj, keyw, \"\", 0, &i);\n    if (err == TCL_OK)\n    {\n\tswitch (i)\n\t{\n\t    case LN_BEGIN:\n\t    case LN_FIRST:\n\t    case LN_START:\n\t    case LN_TOP:\n\t\t*valueP = 1;\n\t\tbreak;\n\t    case LN_BOTTOM:\n\t    case LN_END:\n\t    case LN_LAST:\n\t\t*valueP = buf->b_ml.ml_line_count;\n\t\tbreak;\n\t}\n\treturn TCL_OK;\n    }\n    Tcl_ResetResult(interp);\n\n    err = Tcl_GetIntFromObj(interp, obj, &i);\n    if (err != TCL_OK)\n\treturn err;\n    i = row2vim(i);\n    if (i < 1  ||  i > buf->b_ml.ml_line_count)\n    {\n\tTcl_SetResult(interp, _(\"line number out of range\"), TCL_STATIC);\n\treturn TCL_ERROR;\n    }\n    *valueP = i;\n    return TCL_OK;\n}\n\n/*\n * Find the first window in the window list that displays the buffer.\n */\n    static win_T *\ntclfindwin(buf_T *buf)\n{\n    win_T *win;\n\n    FOR_ALL_WINDOWS(win)\n    {\n\tif (win->w_buffer == buf)\n\t    return win;\n    }\n    return curwin;  /* keep current window context */\n}\n\n/*\n * Do-it-all function for \"::vim::command\", \"$buf command\" and \"$win command\".\n */\n    static int\ntcldoexcommand(\n    Tcl_Interp\t*interp,\n    int\t\tobjc,\n    Tcl_Obj\t*CONST objv[],\n    int\t\tobjn)\n{\n    tcl_info\tsaveinfo;\n    int\t\terr, flag, nobjs;\n    char\t*arg;\n\n    nobjs = objc - objn;\n    if (nobjs < 1 || nobjs > 2)\n    {\n\tTcl_WrongNumArgs(interp, objn, objv, \"?-quiet? exCommand\");\n\treturn TCL_ERROR;\n    }\n\n    flag = 0;\n    if (nobjs == 2)\n    {\n\targ = Tcl_GetStringFromObj(objv[objn], NULL);\n\tif (strcmp(arg, \"-quiet\") == 0)\n\t    flag = 1;\n\telse\n\t{\n\t    Tcl_ResetResult(interp);\n\t    Tcl_AppendResult(interp, _(\"unknown flag: \"), arg, (char *)0);\n\t    return TCL_ERROR;\n\t}\n\t++objn;\n    }\n\n    memcpy(&saveinfo, &tclinfo, sizeof(tcl_info));\n    tclinfo.interp = NULL;\n    tclinfo.curwin = NULL;\n    tclinfo.curbuf = NULL;\n\n    arg = Tcl_GetStringFromObj(objv[objn], NULL);\n    if (flag)\n\t++emsg_off;\n    do_cmdline_cmd((char_u *)arg);\n    if (flag)\n\t--emsg_off;\n    err = vimerror(interp);\n\n    /* If the ex command created a new Tcl interpreter, remove it */\n    if (tclinfo.interp)\n\ttcldelthisinterp();\n    memcpy(&tclinfo, &saveinfo, sizeof(tcl_info));\n    tclupdatevars();\n\n    return err;\n}\n\n/*\n * Do-it-all function for \"::vim::option\", \"$buf option\" and \"$win option\".\n */\n    static int\ntclsetoption(\n    Tcl_Interp\t*interp,\n    int\t\tobjc,\n    Tcl_Obj\t*CONST objv[],\n    int\t\tobjn)\n{\n    int\t\terr, nobjs, idx;\n    char_u\t*option;\n    int\t\tisnum;\n    long\tlval;\n    char_u\t*sval;\n    Tcl_Obj\t*resobj;\n\n    enum { OPT_OFF, OPT_ON, OPT_TOGGLE };\n    static CONST84 char *optkw[] = { \"off\", \"on\", \"toggle\", (char *)0 };\n\n    nobjs = objc - objn;\n    if (nobjs != 1 && nobjs != 2)\n    {\n\tTcl_WrongNumArgs(interp, objn, objv, \"vimOption ?value?\");\n\treturn TCL_ERROR;\n    }\n\n    option = (char_u *)Tcl_GetStringFromObj(objv[objn], NULL);\n    ++objn;\n    isnum = get_option_value(option, &lval, &sval, 0);\n    err = TCL_OK;\n    switch (isnum)\n    {\n\tcase 0:\n\t    Tcl_SetResult(interp, (char *)sval, TCL_VOLATILE);\n\t    vim_free(sval);\n\t    break;\n\tcase 1:\n\t    resobj = Tcl_NewLongObj(lval);\n\t    Tcl_SetObjResult(interp, resobj);\n\t    break;\n\tdefault:\n\t    Tcl_SetResult(interp, _(\"unknown vimOption\"), TCL_STATIC);\n\t    return TCL_ERROR;\n    }\n    if (nobjs == 2)\n    {\n\tif (isnum)\n\t{\n\t    sval = NULL;    /* avoid compiler warning */\n\t    err = Tcl_GetIndexFromObj(interp, objv[objn], optkw, \"\", 0, &idx);\n\t    if (err != TCL_OK)\n\t    {\n\t\tTcl_ResetResult(interp);\n\t\terr = Tcl_GetLongFromObj(interp, objv[objn], &lval);\n\t    }\n\t    else\n\t    switch (idx)\n\t    {\n\t\tcase OPT_ON:\n\t\t    lval = 1;\n\t\t    break;\n\t\tcase OPT_OFF:\n\t\t    lval = 0;\n\t\t    break;\n\t\tcase OPT_TOGGLE:\n\t\t    lval = !lval;\n\t\t    break;\n\t    }\n\t}\n\telse\n\t    sval = (char_u *)Tcl_GetStringFromObj(objv[objn], NULL);\n\tif (err == TCL_OK)\n\t{\n\t    set_option_value(option, lval, sval, OPT_LOCAL);\n\t    err = vimerror(interp);\n\t}\n    }\n    return err;\n}\n\n/*\n * Do-it-all function for \"::vim::expr\", \"$buf expr\" and \"$win expr\".\n */\n    static int\ntclvimexpr(\n    Tcl_Interp\t*interp,\n    int\t\tobjc,\n    Tcl_Obj\t*CONST objv[],\n    int\t\tobjn)\n{\n#ifdef FEAT_EVAL\n    char\t*expr, *str;\n#endif\n    int\t\terr;\n\n    if (objc - objn != 1)\n    {\n\tTcl_WrongNumArgs(interp, objn, objv, \"vimExpr\");\n\treturn TCL_ERROR;\n    }\n\n#ifdef FEAT_EVAL\n    expr = Tcl_GetStringFromObj(objv[objn], NULL);\n    str = (char *)eval_to_string((char_u *)expr, NULL, TRUE);\n    if (str == NULL)\n\tTcl_SetResult(interp, _(\"invalid expression\"), TCL_STATIC);\n    else\n\tTcl_SetResult(interp, str, TCL_VOLATILE);\n    err = vimerror(interp);\n#else\n    Tcl_SetResult(interp, _(\"expressions disabled at compile time\"), TCL_STATIC);\n    err = TCL_ERROR;\n#endif\n\n    return err;\n}\n\n/*\n * Check for internal vim errors.\n */\n    static int\nvimerror(Tcl_Interp *interp)\n{\n    if (got_int)\n    {\n\tTcl_SetResult(interp, _(\"keyboard interrupt\"), TCL_STATIC);\n\treturn TCL_ERROR;\n    }\n    else if (did_emsg)\n    {\n\tTcl_SetResult(interp, _(\"vim error\"), TCL_STATIC);\n\treturn TCL_ERROR;\n    }\n    return TCL_OK;\n}\n\n/*\n * Functions that handle the reference lists:\n *   delref() - callback for Tcl's DeleteCommand\n *   tclgetref() - find/create Tcl command for a win_T* or buf_T* object\n *   tclgetwindow() - window frontend for tclgetref()\n *   tclgetbuffer() - buffer frontend for tclgetref()\n *   tclsetdelcmd() - add Tcl callback command to a vim object\n */\n    static void\ndelref(ClientData cref)\n{\n    struct ref *ref = (struct ref *)cref;\n\n    if (ref->delcmd)\n    {\n\tTcl_DecrRefCount(ref->delcmd);\n\tref->delcmd = NULL;\n    }\n    ref->interp = NULL;\n}\n\n    static char *\ntclgetref(\n    Tcl_Interp\t*interp,\n    void\t**refstartP,\t/* ptr to w_tcl_ref/b_tcl-ref member of\n\t\t\t\t   win_T/buf_T struct */\n    char\t*prefix,\t/* \"win\" or \"buf\" */\n    void\t*vimobj,\t/* win_T* or buf_T* */\n    Tcl_ObjCmdProc *proc)\t/* winselfcmd or bufselfcmd */\n{\n    struct ref *ref, *unused = NULL;\n    static char name[VARNAME_SIZE];\n    Tcl_Command cmd;\n\n    ref = (struct ref *)(*refstartP);\n    if (ref == &refsdeleted)\n    {\n\tTcl_SetResult(interp, _(\"cannot create buffer/window command: object is being deleted\"), TCL_STATIC);\n\treturn NULL;\n    }\n\n    while (ref != NULL)\n    {\n\tif (ref->interp == interp)\n\t    break;\n\tif (ref->interp == NULL)\n\t    unused = ref;\n\tref = ref->next;\n    }\n\n    if (ref)\n\tvim_snprintf(name, sizeof(name), \"::vim::%s\",\n\t\t\t\t\tTcl_GetCommandName(interp, ref->cmd));\n    else\n    {\n\tif (unused)\n\t    ref = unused;\n\telse\n\t{\n\t    ref = (struct ref *)Tcl_Alloc(sizeof(struct ref));\n\t    ref->interp = NULL;\n\t    ref->next = (struct ref *)(*refstartP);\n\t    (*refstartP) = (void *)ref;\n\t}\n\n\t/* This might break on some exotic systems... */\n\tvim_snprintf(name, sizeof(name), \"::vim::%s_%lx\",\n\t\t\t\t\t       prefix, (unsigned long)vimobj);\n\tcmd = Tcl_CreateObjCommand(interp, name, proc,\n\t    (ClientData)ref, (Tcl_CmdDeleteProc *)delref);\n\tif (!cmd)\n\t    return NULL;\n\n\tref->interp = interp;\n\tref->cmd = cmd;\n\tref->delcmd = NULL;\n\tref->vimobj = vimobj;\n    }\n    return name;\n}\n\n    static char *\ntclgetwindow(Tcl_Interp *interp, win_T *win)\n{\n    return tclgetref(interp, &(win->w_tcl_ref), \"win\", (void *)win, winselfcmd);\n}\n\n    static char *\ntclgetbuffer(Tcl_Interp *interp, buf_T *buf)\n{\n    return tclgetref(interp, &(buf->b_tcl_ref), \"buf\", (void *)buf, bufselfcmd);\n}\n\n    static int\ntclsetdelcmd(\n    Tcl_Interp\t*interp,\n    struct ref\t*reflist,\n    void\t*vimobj,\n    Tcl_Obj\t*delcmd)\n{\n    if (reflist == &refsdeleted)\n    {\n\tTcl_SetResult(interp, _(\"cannot register callback command: buffer/window is already being deleted\"), TCL_STATIC);\n\treturn TCL_ERROR;\n    }\n\n    while (reflist != NULL)\n    {\n\tif (reflist->interp == interp && reflist->vimobj == vimobj)\n\t{\n\t    if (reflist->delcmd)\n\t    {\n\t\tTcl_DecrRefCount(reflist->delcmd);\n\t    }\n\t    Tcl_IncrRefCount(delcmd);\n\t    reflist->delcmd = delcmd;\n\t    return TCL_OK;\n\t}\n\treflist = reflist->next;\n    }\n    /* This should never happen.  Famous last word? */\n    EMSG(_(\"E280: TCL FATAL ERROR: reflist corrupt!? Please report this to vim-dev@vim.org\"));\n    Tcl_SetResult(interp, _(\"cannot register callback command: buffer/window reference not found\"), TCL_STATIC);\n    return TCL_ERROR;\n}\n\n\n/*******************************************\n    I/O Channel\n********************************************/\n\n    static int\ntcl_channel_close(ClientData instance, Tcl_Interp *interp UNUSED)\n{\n    int\t\terr = 0;\n\n    /* currently does nothing */\n\n    if (instance != VIMOUT && instance != VIMERR)\n    {\n\tTcl_SetErrno(EBADF);\n\terr = EBADF;\n    }\n    return err;\n}\n\n    static int\ntcl_channel_input(\n    ClientData\tinstance UNUSED,\n    char\t*buf UNUSED,\n    int\t\tbufsiz UNUSED,\n    int\t\t*errptr)\n{\n\n    /* input is currently not supported */\n\n    Tcl_SetErrno(EINVAL);\n    if (errptr)\n\t*errptr = EINVAL;\n    return -1;\n}\n\n    static int\ntcl_channel_output(\n    ClientData\tinstance,\n    const char\t*buf,\n    int\t\tbufsiz,\n    int\t\t*errptr)\n{\n    char_u\t*str;\n    int\t\tresult;\n\n    /* The buffer is not guaranteed to be 0-terminated, and we don't if\n     * there is enough room to add a '\\0'.  So we have to create a copy\n     * of the buffer...\n     */\n    str = vim_strnsave((char_u *)buf, bufsiz);\n    if (!str)\n    {\n\tTcl_SetErrno(ENOMEM);\n\tif (errptr)\n\t    *errptr = ENOMEM;\n\treturn -1;\n    }\n\n    result = bufsiz;\n    if (instance == VIMOUT)\n\ttclmsg((char *)str);\n    else\n    if (instance == VIMERR)\n\ttclerrmsg((char *)str);\n    else\n    {\n\tTcl_SetErrno(EBADF);\n\tif (errptr)\n\t    *errptr = EBADF;\n\tresult = -1;\n    }\n    vim_free(str);\n    return result;\n}\n\n    static void\ntcl_channel_watch(ClientData instance UNUSED, int mask UNUSED)\n{\n    Tcl_SetErrno(EINVAL);\n}\n\n    static int\ntcl_channel_gethandle(\n    ClientData\tinstance UNUSED,\n    int\t\tdirection UNUSED,\n    ClientData\t*handleptr UNUSED)\n{\n    Tcl_SetErrno(EINVAL);\n    return EINVAL;\n}\n\n\nstatic Tcl_ChannelType tcl_channel_type =\n{\n    \"vimmessage\",\t/* typeName */\n    TCL_CHANNEL_VERSION_2, /* version */\n    tcl_channel_close,\t/* closeProc */\n    tcl_channel_input,\t/* inputProc */\n    tcl_channel_output,\t/* outputProc */\n    NULL,\t\t/* seekProc */\n    NULL,\t\t/* setOptionProc */\n    NULL,\t\t/* getOptionProc */\n    tcl_channel_watch,\t/* watchProc */\n    tcl_channel_gethandle, /* getHandleProc */\n    NULL,\t\t/* close2Proc */\n    NULL,\t\t/* blockModeProc */\n#ifdef TCL_CHANNEL_VERSION_2\n    NULL,\t\t/* flushProc */\n    NULL,\t\t/* handlerProc */\n#endif\n/* The following should not be necessary since TCL_CHANNEL_VERSION_2 was\n * set above */\n#ifdef TCL_CHANNEL_VERSION_3\n    NULL,\t\t/* wideSeekProc */\n#endif\n#ifdef TCL_CHANNEL_VERSION_4\n    NULL,\t\t/* threadActionProc */\n#endif\n#ifdef TCL_CHANNEL_VERSION_5\n    NULL\t\t/* truncateProc */\n#endif\n};\n\n/**********************************\n  Interface to vim\n **********************************/\n\n    static void\ntclupdatevars(void)\n{\n    char varname[VARNAME_SIZE];\t/* must be writeable */\n    char *name;\n\n    strcpy(varname, VAR_RANGE1);\n    Tcl_UpdateLinkedVar(tclinfo.interp, varname);\n    strcpy(varname, VAR_RANGE2);\n    Tcl_UpdateLinkedVar(tclinfo.interp, varname);\n    strcpy(varname, VAR_RANGE3);\n    Tcl_UpdateLinkedVar(tclinfo.interp, varname);\n\n    strcpy(varname, VAR_LBASE);\n    Tcl_UpdateLinkedVar(tclinfo.interp, varname);\n\n    name = tclgetbuffer(tclinfo.interp, curbuf);\n    strcpy(tclinfo.curbuf, name);\n    strcpy(varname, VAR_CURBUF);\n    Tcl_UpdateLinkedVar(tclinfo.interp, varname);\n\n    name = tclgetwindow(tclinfo.interp, curwin);\n    strcpy(tclinfo.curwin, name);\n    strcpy(varname, VAR_CURWIN);\n    Tcl_UpdateLinkedVar(tclinfo.interp, varname);\n}\n\n\n    static int\ntclinit(exarg_T *eap)\n{\n    char varname[VARNAME_SIZE];\t/* Tcl_LinkVar requires writeable varname */\n    char *name;\n\n#ifdef DYNAMIC_TCL\n    if (!tcl_enabled(TRUE))\n    {\n\tEMSG(_(\"E571: Sorry, this command is disabled: the Tcl library could not be loaded.\"));\n\treturn FAIL;\n    }\n#endif\n\n    if (!tclinfo.interp)\n    {\n\tTcl_Interp *interp;\n\tstatic Tcl_Channel ch1, ch2;\n\n\t/* Create replacement channels for stdout and stderr; this has to be\n\t * done each time an interpreter is created since the channels are closed\n\t * when the interpreter is deleted */\n\tch1 = Tcl_CreateChannel(&tcl_channel_type, \"vimout\", VIMOUT, TCL_WRITABLE);\n\tch2 = Tcl_CreateChannel(&tcl_channel_type, \"vimerr\", VIMERR, TCL_WRITABLE);\n\tTcl_SetStdChannel(ch1, TCL_STDOUT);\n\tTcl_SetStdChannel(ch2, TCL_STDERR);\n\n\tinterp = Tcl_CreateInterp();\n\tTcl_Preserve(interp);\n\tif (Tcl_Init(interp) == TCL_ERROR)\n\t{\n\t    Tcl_Release(interp);\n\t    Tcl_DeleteInterp(interp);\n\t    return FAIL;\n\t}\n#if 0\n\t/* VIM sure is interactive */\n\tTcl_SetVar(interp, \"tcl_interactive\", \"1\", TCL_GLOBAL_ONLY);\n#endif\n\n\tTcl_SetChannelOption(interp, ch1, \"-buffering\", \"line\");\n#ifdef WIN3264\n\tTcl_SetChannelOption(interp, ch1, \"-translation\", \"lf\");\n#endif\n\tTcl_SetChannelOption(interp, ch2, \"-buffering\", \"line\");\n#ifdef WIN3264\n\tTcl_SetChannelOption(interp, ch2, \"-translation\", \"lf\");\n#endif\n\n\t/* replace standard Tcl exit command */\n\tTcl_DeleteCommand(interp, \"exit\");\n\tTcl_CreateObjCommand(interp, \"exit\", exitcmd,\n\t    (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);\n\n\t/* new commands, in ::vim namespace */\n\tTcl_CreateObjCommand(interp, \"::vim::buffer\", buffercmd,\n\t    (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);\n\tTcl_CreateObjCommand(interp, \"::vim::window\", windowcmd,\n\t   (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);\n\tTcl_CreateObjCommand(interp, \"::vim::command\", commandcmd,\n\t   (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);\n\tTcl_CreateObjCommand(interp, \"::vim::beep\", beepcmd,\n\t   (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);\n\tTcl_CreateObjCommand(interp, \"::vim::option\", optioncmd,\n\t   (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);\n\tTcl_CreateObjCommand(interp, \"::vim::expr\", exprcmd,\n\t   (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);\n\n\t/* \"lbase\" variable */\n\ttclinfo.lbase = 1;\n\tstrcpy(varname, VAR_LBASE);\n\tTcl_LinkVar(interp, varname, (char *)&tclinfo.lbase, TCL_LINK_INT);\n\n\t/* \"range\" variable */\n\ttclinfo.range_start = eap->line1;\n\tstrcpy(varname, VAR_RANGE1);\n\tTcl_LinkVar(interp, varname, (char *)&tclinfo.range_start, TCL_LINK_INT|TCL_LINK_READ_ONLY);\n\tstrcpy(varname, VAR_RANGE2);\n\tTcl_LinkVar(interp, varname, (char *)&tclinfo.range_start, TCL_LINK_INT|TCL_LINK_READ_ONLY);\n\ttclinfo.range_end   = eap->line2;\n\tstrcpy(varname, VAR_RANGE3);\n\tTcl_LinkVar(interp, varname, (char *)&tclinfo.range_end, TCL_LINK_INT|TCL_LINK_READ_ONLY);\n\n\t/* \"current\" variable */\n\ttclinfo.curbuf = Tcl_Alloc(VARNAME_SIZE);\n\ttclinfo.curwin = Tcl_Alloc(VARNAME_SIZE);\n\tname = tclgetbuffer(interp, curbuf);\n\tstrcpy(tclinfo.curbuf, name);\n\tstrcpy(varname, VAR_CURBUF);\n\tTcl_LinkVar(interp, varname, (char *)&tclinfo.curbuf, TCL_LINK_STRING|TCL_LINK_READ_ONLY);\n\tname = tclgetwindow(interp, curwin);\n\tstrcpy(tclinfo.curwin, name);\n\tstrcpy(varname, VAR_CURWIN);\n\tTcl_LinkVar(interp, varname, (char *)&tclinfo.curwin, TCL_LINK_STRING|TCL_LINK_READ_ONLY);\n\n\ttclinfo.interp = interp;\n    }\n    else\n    {\n\t/* Interpreter already exists, just update variables */\n\ttclinfo.range_start = row2tcl(eap->line1);\n\ttclinfo.range_end = row2tcl(eap->line2);\n\ttclupdatevars();\n    }\n\n    tclinfo.exitvalue = 0;\n    return OK;\n}\n\n    static void\ntclerrmsg(char *text)\n{\n    char *next;\n\n    while ((next=strchr(text, '\\n')))\n    {\n\t*next++ = '\\0';\n\tEMSG(text);\n\ttext = next;\n    }\n    if (*text)\n\tEMSG(text);\n}\n\n    static void\ntclmsg(char *text)\n{\n    char *next;\n\n    while ((next=strchr(text, '\\n')))\n    {\n\t*next++ = '\\0';\n\tMSG(text);\n\ttext = next;\n    }\n    if (*text)\n\tMSG(text);\n}\n\n    static void\ntcldelthisinterp(void)\n{\n    if (!Tcl_InterpDeleted(tclinfo.interp))\n\tTcl_DeleteInterp(tclinfo.interp);\n    Tcl_Release(tclinfo.interp);\n    /* The interpreter is now gets deleted.  All registered commands (esp.\n     * window and buffer commands) are deleted, triggering their deletion\n     * callback, which deletes all refs pointing to this interpreter.\n     * We could garbage-collect the unused ref structs in all windows and\n     * buffers, but unless the user creates hundreds of sub-interpreters\n     * all referring to lots of windows and buffers, this is hardly worth\n     * the effort.  Unused refs are recycled by other interpreters, and\n     * all refs are free'd when the window/buffer gets closed by vim.\n     */\n\n    tclinfo.interp = NULL;\n    Tcl_Free(tclinfo.curbuf);\n    Tcl_Free(tclinfo.curwin);\n    tclinfo.curbuf = tclinfo.curwin = NULL;\n}\n\n    static int\ntclexit(int error)\n{\n    int newerr = OK;\n\n    if (Tcl_InterpDeleted(tclinfo.interp)     /* True if we intercepted Tcl's exit command */\n#if (TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION >= 5) || TCL_MAJOR_VERSION > 8\n\t|| Tcl_LimitExceeded(tclinfo.interp)  /* True if the interpreter cannot continue */\n#endif\n\t)\n    {\n\tchar buf[50];\n\n\tsprintf(buf, _(\"E572: exit code %d\"), tclinfo.exitvalue);\n\ttclerrmsg(buf);\n\tif (tclinfo.exitvalue == 0)\n\t{\n\t    did_emsg = 0;\n\t    newerr = OK;\n\t}\n\telse\n\t    newerr = FAIL;\n\n\ttcldelthisinterp();\n    }\n    else\n    {\n\tchar *result;\n\n\tresult = (char *)Tcl_GetStringResult(tclinfo.interp);\n\tif (error == TCL_OK)\n\t{\n\t    tclmsg(result);\n\t    newerr = OK;\n\t}\n\telse\n\t{\n\t    tclerrmsg(result);\n\t    newerr = FAIL;\n\t}\n    }\n\n    return newerr;\n}\n\n/*\n * \":tcl\"\n */\n    void\nex_tcl(exarg_T *eap)\n{\n    char_u\t*script;\n    int\t\terr;\n\n    script = script_get(eap, eap->arg);\n    if (!eap->skip)\n    {\n\terr = tclinit(eap);\n\tif (err == OK)\n\t{\n\t    Tcl_AllowExceptions(tclinfo.interp);\n\t    if (script == NULL)\n\t\terr = Tcl_Eval(tclinfo.interp, (char *)eap->arg);\n\t    else\n\t\terr = Tcl_Eval(tclinfo.interp, (char *)script);\n\t    err = tclexit(err);\n\t}\n    }\n    vim_free(script);\n}\n\n/*\n * \":tclfile\"\n */\n    void\nex_tclfile(exarg_T *eap)\n{\n    char *file = (char *)eap->arg;\n    int err;\n\n    err = tclinit(eap);\n    if (err == OK)\n    {\n\tTcl_AllowExceptions(tclinfo.interp);\n\terr = Tcl_EvalFile(tclinfo.interp, file);\n\terr = tclexit(err);\n    }\n}\n\n/*\n * \":tcldo\"\n */\n    void\nex_tcldo(exarg_T *eap)\n{\n    char\t*script, *line;\n    int\t\terr, rs, re, lnum;\n    char\tvar_lnum[VARNAME_SIZE]; /* must be writeable memory */\n    char\tvar_line[VARNAME_SIZE];\n    linenr_T\tfirst_line = 0;\n    linenr_T\tlast_line = 0;\n    buf_T\t*was_curbuf = curbuf;\n\n    rs = eap->line1;\n    re = eap->line2;\n    script = (char *)eap->arg;\n    strcpy(var_lnum, VAR_CURLNUM);\n    strcpy(var_line, VAR_CURLINE);\n\n    err = tclinit(eap);\n    if (err != OK)\n\treturn;\n\n    lnum = row2tcl(rs);\n    Tcl_LinkVar(tclinfo.interp, var_lnum, (char *)&lnum, TCL_LINK_INT|TCL_LINK_READ_ONLY);\n    err = TCL_OK;\n    if (u_save((linenr_T)(rs-1), (linenr_T)(re+1)) != OK)\n    {\n\tTcl_SetResult(tclinfo.interp, _(\"cannot save undo information\"), TCL_STATIC);\n\terr = TCL_ERROR;\n    }\n    while (err == TCL_OK  &&  rs <= re)\n    {\n\tif ((linenr_T)rs > curbuf->b_ml.ml_line_count)\n\t    break;\n\tline = (char *)ml_get_buf(curbuf, (linenr_T)rs, FALSE);\n\tif (!line)\n\t{\n\t    Tcl_SetResult(tclinfo.interp, _(\"cannot get line\"), TCL_STATIC);\n\t    err = TCL_ERROR;\n\t    break;\n\t}\n\tTcl_SetVar(tclinfo.interp, var_line, line, 0);\n\tTcl_AllowExceptions(tclinfo.interp);\n\terr = Tcl_Eval(tclinfo.interp, script);\n\tif (err != TCL_OK\n\t    || Tcl_InterpDeleted(tclinfo.interp)\n#if (TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION >= 5) || TCL_MAJOR_VERSION > 8\n\t    || Tcl_LimitExceeded(tclinfo.interp)\n#endif\n\t    || curbuf != was_curbuf)\n\t    break;\n\tline = (char *)Tcl_GetVar(tclinfo.interp, var_line, 0);\n\tif (line)\n\t{\n\t    if (ml_replace((linenr_T)rs, (char_u *)line, TRUE) != OK)\n\t    {\n\t\tTcl_SetResult(tclinfo.interp, _(\"cannot replace line\"), TCL_STATIC);\n\t\terr = TCL_ERROR;\n\t\tbreak;\n\t    }\n\t    if (first_line == 0)\n\t\tfirst_line = rs;\n\t    last_line = rs;\n\t}\n\t++rs;\n\t++lnum;\n\tTcl_UpdateLinkedVar(tclinfo.interp, var_lnum);\n    }\n    if (first_line)\n\tchanged_lines(first_line, 0, last_line + 1, (long)0);\n\n    Tcl_UnsetVar(tclinfo.interp, var_line, 0);\n    Tcl_UnlinkVar(tclinfo.interp, var_lnum);\n    if (err == TCL_OK)\n\tTcl_ResetResult(tclinfo.interp);\n\n    (void)tclexit(err);\n}\n\n    static void\ntcldelallrefs(struct ref *ref)\n{\n    struct ref\t*next;\n    int\t\terr;\n    char\t*result;\n\n#ifdef DYNAMIC_TCL\n    /* TODO: this code currently crashes Vim on exit */\n    if (exiting)\n\treturn;\n#endif\n\n    while (ref != NULL)\n    {\n\tnext = ref->next;\n\tif (ref->interp)\n\t{\n\t    if (ref->delcmd)\n\t    {\n\t\terr = Tcl_GlobalEvalObj(ref->interp, ref->delcmd);\n\t\tif (err != TCL_OK)\n\t\t{\n\t\t    result = (char *)Tcl_GetStringResult(ref->interp);\n\t\t    if (result)\n\t\t\ttclerrmsg(result);\n\t\t}\n\t\tTcl_DecrRefCount(ref->delcmd);\n\t\tref->delcmd = NULL;\n\t    }\n\t    Tcl_DeleteCommandFromToken(ref->interp, ref->cmd);\n\t}\n\tTcl_Free((char *)ref);\n\tref = next;\n    }\n}\n\n    void\ntcl_buffer_free(buf_T *buf)\n{\n    struct ref *reflist;\n\n#ifdef DYNAMIC_TCL\n    if (!stubs_initialized)\t/* Not using Tcl, nothing to do. */\n\treturn;\n#endif\n\n    reflist = (struct ref *)(buf->b_tcl_ref);\n    if (reflist != &refsdeleted)\n    {\n\tbuf->b_tcl_ref = (void *)&refsdeleted;\n\ttcldelallrefs(reflist);\n\tbuf->b_tcl_ref = NULL;\n    }\n}\n\n#if defined(FEAT_WINDOWS) || defined(PROTO)\n    void\ntcl_window_free(win_T *win)\n{\n    struct ref *reflist;\n\n#ifdef DYNAMIC_TCL\n    if (!stubs_initialized)\t/* Not using Tcl, nothing to do. */\n\treturn;\n#endif\n\n    reflist = (struct ref*)(win->w_tcl_ref);\n    if (reflist != &refsdeleted)\n    {\n\twin->w_tcl_ref = (void *)&refsdeleted;\n\ttcldelallrefs(reflist);\n\twin->w_tcl_ref = NULL;\n    }\n}\n#endif\n\n/* The End */\n",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/if_ruby.c": "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Ruby interface by Shugo Maeda\n *   with improvements by SegPhault (Ryan Paul)\n *   with improvements by Jon Maken\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#ifdef HAVE_CONFIG_H\n# include \"auto/config.h\"\n#endif\n\n#include <stdio.h>\n#include <string.h>\n\n#ifdef _WIN32\n# if !defined(DYNAMIC_RUBY_VER) || (DYNAMIC_RUBY_VER < 18)\n#   define NT\n# endif\n# ifndef DYNAMIC_RUBY\n#  define IMPORT /* For static dll usage __declspec(dllimport) */\n#  define RUBYEXTERN __declspec(dllimport)\n# endif\n#endif\n#ifndef RUBYEXTERN\n# define RUBYEXTERN extern\n#endif\n\n#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 24\n# define USE_RUBY_INTEGER\n#endif\n\n#ifdef DYNAMIC_RUBY\n/*\n * This is tricky.  In ruby.h there is (inline) function rb_class_of()\n * definition.  This function use these variables.  But we want function to\n * use dll_* variables.\n */\n# define rb_cFalseClass\t\t(*dll_rb_cFalseClass)\n# define rb_cFixnum\t\t(*dll_rb_cFixnum)\n# if defined(USE_RUBY_INTEGER)\n#  define rb_cInteger\t\t(*dll_rb_cInteger)\n# endif\n# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 20\n#  define rb_cFloat\t\t(*dll_rb_cFloat)\n# endif\n# define rb_cNilClass\t\t(*dll_rb_cNilClass)\n# define rb_cSymbol\t\t(*dll_rb_cSymbol)\n# define rb_cTrueClass\t\t(*dll_rb_cTrueClass)\n# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18\n/*\n * On ver 1.8, all Ruby functions are exported with \"__declspec(dllimport)\"\n * in ruby.h.  But it causes trouble for these variables, because it is\n * defined in this file.  When defined this RUBY_EXPORT it modified to\n * \"extern\" and be able to avoid this problem.\n */\n#  define RUBY_EXPORT\n# endif\n\n#if !(defined(WIN32) || defined(_WIN64))\n# include <dlfcn.h>\n# define HINSTANCE void*\n# define RUBY_PROC void*\n# define load_dll(n) dlopen((n), RTLD_LAZY|RTLD_GLOBAL)\n# define symbol_from_dll dlsym\n# define close_dll dlclose\n#else\n# define RUBY_PROC FARPROC\n# define load_dll vimLoadLib\n# define symbol_from_dll GetProcAddress\n# define close_dll FreeLibrary\n#endif\n\n#endif  /* ifdef DYNAMIC_RUBY */\n\n/* suggested by Ariya Mizutani */\n#if (_MSC_VER == 1200)\n# undef _WIN32_WINNT\n#endif\n\n#if (defined(RUBY_VERSION) && RUBY_VERSION >= 19) \\\n    || (defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19)\n# define RUBY19_OR_LATER 1\n#endif\n\n#if (defined(RUBY_VERSION) && RUBY_VERSION >= 20) \\\n    || (defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 20)\n# define RUBY20_OR_LATER 1\n#endif\n\n#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19\n/* Ruby 1.9 defines a number of static functions which use rb_num2long and\n * rb_int2big */\n# define rb_num2long rb_num2long_stub\n# define rb_int2big rb_int2big_stub\n#endif\n\n#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19 \\\n\t&& VIM_SIZEOF_INT < VIM_SIZEOF_LONG\n/* Ruby 1.9 defines a number of static functions which use rb_fix2int and\n * rb_num2int if VIM_SIZEOF_INT < VIM_SIZEOF_LONG (64bit) */\n# define rb_fix2int rb_fix2int_stub\n# define rb_num2int rb_num2int_stub\n#endif\n\n#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER == 21\n/* Ruby 2.1 adds new GC called RGenGC and RARRAY_PTR uses\n * rb_gc_writebarrier_unprotect_promoted if USE_RGENGC  */\n# define rb_gc_writebarrier_unprotect_promoted rb_gc_writebarrier_unprotect_promoted_stub\n#endif\n#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 22\n# define rb_gc_writebarrier_unprotect rb_gc_writebarrier_unprotect_stub\n#endif\n\n#include <ruby.h>\n#ifdef RUBY19_OR_LATER\n# include <ruby/encoding.h>\n#endif\n\n#undef off_t\t/* ruby defines off_t as _int64, Mingw uses long */\n#undef EXTERN\n#undef _\n\n/* T_DATA defined both by Ruby and Mac header files, hack around it... */\n#if defined(MACOS_X_UNIX) || defined(macintosh)\n# define __OPENTRANSPORT__\n# define __OPENTRANSPORTPROTOCOL__\n# define __OPENTRANSPORTPROVIDERS__\n#endif\n\n/*\n * The TypedData_XXX macro family can be used since Ruby 1.9.2 but\n * rb_data_type_t changed in 1.9.3, therefore require at least 2.0.\n * The old Data_XXX macro family was deprecated on Ruby 2.2.\n * Use TypedData_XXX if available.\n */\n#if defined(TypedData_Wrap_Struct) && defined(RUBY20_OR_LATER)\n# define USE_TYPEDDATA\t1\n#endif\n\n/*\n * Backward compatibility for Ruby 1.8 and earlier.\n * Ruby 1.9 does not provide STR2CSTR, instead StringValuePtr is provided.\n * Ruby 1.9 does not provide RXXX(s)->len and RXXX(s)->ptr, instead\n * RXXX_LEN(s) and RXXX_PTR(s) are provided.\n */\n#ifndef StringValuePtr\n# define StringValuePtr(s) STR2CSTR(s)\n#endif\n#ifndef RARRAY_LEN\n# define RARRAY_LEN(s) RARRAY(s)->len\n#endif\n#ifndef RARRAY_PTR\n# define RARRAY_PTR(s) RARRAY(s)->ptr\n#endif\n#ifndef RSTRING_LEN\n# define RSTRING_LEN(s) RSTRING(s)->len\n#endif\n#ifndef RSTRING_PTR\n# define RSTRING_PTR(s) RSTRING(s)->ptr\n#endif\n\n#ifdef HAVE_DUP\n# undef HAVE_DUP\n#endif\n\n#include \"vim.h\"\n#include \"version.h\"\n\n#if defined(PROTO) && !defined(FEAT_RUBY)\n/* Define these to be able to generate the function prototypes. */\n# define VALUE int\n# define RUBY_DATA_FUNC int\n#endif\n\nstatic int ruby_initialized = 0;\nstatic void *ruby_stack_start;\nstatic VALUE objtbl;\n\nstatic VALUE mVIM;\nstatic VALUE cBuffer;\nstatic VALUE cVimWindow;\nstatic VALUE eDeletedBufferError;\nstatic VALUE eDeletedWindowError;\n\nstatic int ensure_ruby_initialized(void);\nstatic void error_print(int);\nstatic void ruby_io_init(void);\nstatic void ruby_vim_init(void);\n\n#if defined(RUBY19_OR_LATER) || defined(RUBY_INIT_STACK)\n# if defined(__ia64) && !defined(ruby_init_stack)\n#  define ruby_init_stack(addr) ruby_init_stack((addr), rb_ia64_bsp())\n# endif\n#endif\n\n#if defined(DYNAMIC_RUBY) || defined(PROTO)\n# if defined(PROTO) && !defined(HINSTANCE)\n#  define HINSTANCE int\t\t/* for generating prototypes */\n# endif\n\n/*\n * Wrapper defines\n */\n# define rb_assoc_new\t\t\tdll_rb_assoc_new\n# define rb_cObject\t\t\t(*dll_rb_cObject)\n# define rb_check_type\t\t\tdll_rb_check_type\n# ifdef USE_TYPEDDATA\n#  define rb_check_typeddata\t\tdll_rb_check_typeddata\n# endif\n# define rb_class_path\t\t\tdll_rb_class_path\n# ifdef USE_TYPEDDATA\n#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 23\n#   define rb_data_typed_object_wrap\tdll_rb_data_typed_object_wrap\n#  else\n#   define rb_data_typed_object_alloc\tdll_rb_data_typed_object_alloc\n#  endif\n# else\n#  define rb_data_object_alloc\t\tdll_rb_data_object_alloc\n# endif\n# define rb_define_class_under\t\tdll_rb_define_class_under\n# define rb_define_const\t\t\tdll_rb_define_const\n# define rb_define_global_function\tdll_rb_define_global_function\n# define rb_define_method\t\tdll_rb_define_method\n# define rb_define_module\t\tdll_rb_define_module\n# define rb_define_module_function\tdll_rb_define_module_function\n# define rb_define_singleton_method\tdll_rb_define_singleton_method\n# define rb_define_virtual_variable\tdll_rb_define_virtual_variable\n# define rb_stdout\t\t\t(*dll_rb_stdout)\n# define rb_eArgError\t\t\t(*dll_rb_eArgError)\n# define rb_eIndexError\t\t\t(*dll_rb_eIndexError)\n# define rb_eRuntimeError\t\t(*dll_rb_eRuntimeError)\n# define rb_eStandardError\t\t(*dll_rb_eStandardError)\n# define rb_eval_string_protect\t\tdll_rb_eval_string_protect\n# define rb_global_variable\t\tdll_rb_global_variable\n# define rb_hash_aset\t\t\tdll_rb_hash_aset\n# define rb_hash_new\t\t\tdll_rb_hash_new\n# define rb_inspect\t\t\tdll_rb_inspect\n# define rb_int2inum\t\t\tdll_rb_int2inum\n# if VIM_SIZEOF_INT < VIM_SIZEOF_LONG /* 64 bits only */\n#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER <= 18\n#   define rb_fix2int\t\t\tdll_rb_fix2int\n#   define rb_num2int\t\t\tdll_rb_num2int\n#  endif\n#  define rb_num2uint\t\t\tdll_rb_num2uint\n# endif\n# define rb_lastline_get\t\t\tdll_rb_lastline_get\n# define rb_lastline_set\t\t\tdll_rb_lastline_set\n# define rb_load_protect\t\t\tdll_rb_load_protect\n# ifndef RUBY19_OR_LATER\n#  define rb_num2long\t\t\tdll_rb_num2long\n# endif\n# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER <= 19\n#  define rb_num2ulong\t\t\tdll_rb_num2ulong\n# endif\n# define rb_obj_alloc\t\t\tdll_rb_obj_alloc\n# define rb_obj_as_string\t\tdll_rb_obj_as_string\n# define rb_obj_id\t\t\tdll_rb_obj_id\n# define rb_raise\t\t\tdll_rb_raise\n# define rb_str_cat\t\t\tdll_rb_str_cat\n# define rb_str_concat\t\t\tdll_rb_str_concat\n# undef rb_str_new\n# define rb_str_new\t\t\tdll_rb_str_new\n# ifdef rb_str_new2\n/* Ruby may #define rb_str_new2 to use rb_str_new_cstr. */\n#  define need_rb_str_new_cstr 1\n/* Ruby's headers #define rb_str_new_cstr to make use of GCC's\n * __builtin_constant_p extension. */\n#  undef rb_str_new_cstr\n#  define rb_str_new_cstr\t\tdll_rb_str_new_cstr\n# else\n#  define rb_str_new2\t\t\tdll_rb_str_new2\n# endif\n# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18\n#  define rb_string_value\t\tdll_rb_string_value\n#  define rb_string_value_ptr\t\tdll_rb_string_value_ptr\n#  define rb_float_new\t\t\tdll_rb_float_new\n#  define rb_ary_new\t\t\tdll_rb_ary_new\n#  define rb_ary_push\t\t\tdll_rb_ary_push\n#  if defined(RUBY19_OR_LATER) || defined(RUBY_INIT_STACK)\n#   ifdef __ia64\n#    define rb_ia64_bsp\t\t\tdll_rb_ia64_bsp\n#    undef ruby_init_stack\n#    define ruby_init_stack(addr)\tdll_ruby_init_stack((addr), rb_ia64_bsp())\n#   else\n#    define ruby_init_stack\t\tdll_ruby_init_stack\n#   endif\n#  endif\n# else\n#  define rb_str2cstr\t\t\tdll_rb_str2cstr\n# endif\n# ifdef RUBY19_OR_LATER\n#  define rb_errinfo\t\t\tdll_rb_errinfo\n# else\n#  define ruby_errinfo\t\t\t(*dll_ruby_errinfo)\n# endif\n# define ruby_init\t\t\tdll_ruby_init\n# define ruby_init_loadpath\t\tdll_ruby_init_loadpath\n# ifdef WIN3264\n#  define NtInitialize\t\t\tdll_NtInitialize\n#  define ruby_sysinit\t\t\tdll_ruby_sysinit\n#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18\n#   define rb_w32_snprintf\t\tdll_rb_w32_snprintf\n#  endif\n# endif\n\n# ifdef RUBY19_OR_LATER\n#  define ruby_script\t\t\tdll_ruby_script\n#  define rb_enc_find_index\t\tdll_rb_enc_find_index\n#  define rb_enc_find\t\t\tdll_rb_enc_find\n#  undef rb_enc_str_new\n#  define rb_enc_str_new\t\tdll_rb_enc_str_new\n#  define rb_sprintf\t\t\tdll_rb_sprintf\n#  define rb_require\t\t\tdll_rb_require\n#  define ruby_options\t\t\tdll_ruby_options\n# endif\n\n/*\n * Pointers for dynamic link\n */\nstatic VALUE (*dll_rb_assoc_new) (VALUE, VALUE);\nVALUE *dll_rb_cFalseClass;\nVALUE *dll_rb_cFixnum;\n# if defined(USE_RUBY_INTEGER)\nVALUE *dll_rb_cInteger;\n# endif\n# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 20\nVALUE *dll_rb_cFloat;\n# endif\nVALUE *dll_rb_cNilClass;\nstatic VALUE *dll_rb_cObject;\nVALUE *dll_rb_cSymbol;\nVALUE *dll_rb_cTrueClass;\nstatic void (*dll_rb_check_type) (VALUE,int);\n# ifdef USE_TYPEDDATA\nstatic void *(*dll_rb_check_typeddata) (VALUE,const rb_data_type_t *);\n# endif\nstatic VALUE (*dll_rb_class_path) (VALUE);\n# ifdef USE_TYPEDDATA\n#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 23\nstatic VALUE (*dll_rb_data_typed_object_wrap) (VALUE, void*, const rb_data_type_t *);\n#  else\nstatic VALUE (*dll_rb_data_typed_object_alloc) (VALUE, void*, const rb_data_type_t *);\n#  endif\n# else\nstatic VALUE (*dll_rb_data_object_alloc) (VALUE, void*, RUBY_DATA_FUNC, RUBY_DATA_FUNC);\n# endif\nstatic VALUE (*dll_rb_define_class_under) (VALUE, const char*, VALUE);\nstatic void (*dll_rb_define_const) (VALUE,const char*,VALUE);\nstatic void (*dll_rb_define_global_function) (const char*,VALUE(*)(),int);\nstatic void (*dll_rb_define_method) (VALUE,const char*,VALUE(*)(),int);\nstatic VALUE (*dll_rb_define_module) (const char*);\nstatic void (*dll_rb_define_module_function) (VALUE,const char*,VALUE(*)(),int);\nstatic void (*dll_rb_define_singleton_method) (VALUE,const char*,VALUE(*)(),int);\nstatic void (*dll_rb_define_virtual_variable) (const char*,VALUE(*)(),void(*)());\nstatic VALUE *dll_rb_stdout;\nstatic VALUE *dll_rb_eArgError;\nstatic VALUE *dll_rb_eIndexError;\nstatic VALUE *dll_rb_eRuntimeError;\nstatic VALUE *dll_rb_eStandardError;\nstatic VALUE (*dll_rb_eval_string_protect) (const char*, int*);\nstatic void (*dll_rb_global_variable) (VALUE*);\nstatic VALUE (*dll_rb_hash_aset) (VALUE, VALUE, VALUE);\nstatic VALUE (*dll_rb_hash_new) (void);\nstatic VALUE (*dll_rb_inspect) (VALUE);\nstatic VALUE (*dll_rb_int2inum) (long);\n# if VIM_SIZEOF_INT < VIM_SIZEOF_LONG /* 64 bits only */\nstatic long (*dll_rb_fix2int) (VALUE);\nstatic long (*dll_rb_num2int) (VALUE);\nstatic unsigned long (*dll_rb_num2uint) (VALUE);\n# endif\nstatic VALUE (*dll_rb_lastline_get) (void);\nstatic void (*dll_rb_lastline_set) (VALUE);\nstatic void (*dll_rb_load_protect) (VALUE, int, int*);\nstatic long (*dll_rb_num2long) (VALUE);\nstatic unsigned long (*dll_rb_num2ulong) (VALUE);\nstatic VALUE (*dll_rb_obj_alloc) (VALUE);\nstatic VALUE (*dll_rb_obj_as_string) (VALUE);\nstatic VALUE (*dll_rb_obj_id) (VALUE);\nstatic void (*dll_rb_raise) (VALUE, const char*, ...);\n# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18\nstatic VALUE (*dll_rb_string_value) (volatile VALUE*);\n# else\nstatic char *(*dll_rb_str2cstr) (VALUE,int*);\n# endif\nstatic VALUE (*dll_rb_str_cat) (VALUE, const char*, long);\nstatic VALUE (*dll_rb_str_concat) (VALUE, VALUE);\nstatic VALUE (*dll_rb_str_new) (const char*, long);\n# ifdef need_rb_str_new_cstr\n/* Ruby may #define rb_str_new2 to use rb_str_new_cstr. */\nstatic VALUE (*dll_rb_str_new_cstr) (const char*);\n# else\nstatic VALUE (*dll_rb_str_new2) (const char*);\n# endif\n# ifdef RUBY19_OR_LATER\nstatic VALUE (*dll_rb_errinfo) (void);\n# else\nstatic VALUE *dll_ruby_errinfo;\n# endif\nstatic void (*dll_ruby_init) (void);\nstatic void (*dll_ruby_init_loadpath) (void);\n# ifdef WIN3264\nstatic void (*dll_NtInitialize) (int*, char***);\nstatic void (*dll_ruby_sysinit) (int*, char***);\n#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18\nstatic int (*dll_rb_w32_snprintf)(char*, size_t, const char*, ...);\n#  endif\n# endif\n# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18\nstatic char * (*dll_rb_string_value_ptr) (volatile VALUE*);\nstatic VALUE (*dll_rb_float_new) (double);\nstatic VALUE (*dll_rb_ary_new) (void);\nstatic VALUE (*dll_rb_ary_push) (VALUE, VALUE);\n#  if defined(RUBY19_OR_LATER) || defined(RUBY_INIT_STACK)\n#   ifdef __ia64\nstatic void * (*dll_rb_ia64_bsp) (void);\nstatic void (*dll_ruby_init_stack)(VALUE*, void*);\n#   else\nstatic void (*dll_ruby_init_stack)(VALUE*);\n#   endif\n#  endif\n# endif\n# ifdef RUBY19_OR_LATER\nstatic VALUE (*dll_rb_int2big)(SIGNED_VALUE);\n# endif\n\n# ifdef RUBY19_OR_LATER\nstatic void (*dll_ruby_script) (const char*);\nstatic int (*dll_rb_enc_find_index) (const char*);\nstatic rb_encoding* (*dll_rb_enc_find) (const char*);\nstatic VALUE (*dll_rb_enc_str_new) (const char*, long, rb_encoding*);\nstatic VALUE (*dll_rb_sprintf) (const char*, ...);\nstatic VALUE (*dll_rb_require) (const char*);\nstatic void* (*ruby_options)(int, char**);\n# endif\n\n# if defined(USE_RGENGC) && USE_RGENGC\n#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER == 21\nstatic void (*dll_rb_gc_writebarrier_unprotect_promoted)(VALUE);\n#  else\nstatic void (*dll_rb_gc_writebarrier_unprotect)(VALUE obj);\n#  endif\n# endif\n\n# if defined(RUBY19_OR_LATER) && !defined(PROTO)\n#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 22\nlong rb_num2long_stub(VALUE x)\n#  else\nSIGNED_VALUE rb_num2long_stub(VALUE x)\n#  endif\n{\n    return dll_rb_num2long(x);\n}\nVALUE rb_int2big_stub(SIGNED_VALUE x)\n{\n    return dll_rb_int2big(x);\n}\n#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19 \\\n\t&& VIM_SIZEOF_INT < VIM_SIZEOF_LONG\nlong rb_fix2int_stub(VALUE x)\n{\n    return dll_rb_fix2int(x);\n}\nlong rb_num2int_stub(VALUE x)\n{\n    return dll_rb_num2int(x);\n}\n#  endif\n#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 20\nVALUE\nrb_float_new_in_heap(double d)\n{\n    return dll_rb_float_new(d);\n}\n#   if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 22\nunsigned long rb_num2ulong(VALUE x)\n#   else\nVALUE rb_num2ulong(VALUE x)\n#   endif\n{\n    return (long)RSHIFT((SIGNED_VALUE)(x),1);\n}\n#  endif\n# endif\n\n   /* Do not generate a prototype here, VALUE isn't always defined. */\n# if defined(USE_RGENGC) && USE_RGENGC && !defined(PROTO)\n#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER == 21\nvoid rb_gc_writebarrier_unprotect_promoted_stub(VALUE obj)\n{\n    dll_rb_gc_writebarrier_unprotect_promoted(obj);\n}\n#  else\nvoid rb_gc_writebarrier_unprotect_stub(VALUE obj)\n{\n    dll_rb_gc_writebarrier_unprotect(obj);\n}\n#  endif\n# endif\n\nstatic HINSTANCE hinstRuby = NULL; /* Instance of ruby.dll */\n\n/*\n * Table of name to function pointer of ruby.\n */\nstatic struct\n{\n    char *name;\n    RUBY_PROC *ptr;\n} ruby_funcname_table[] =\n{\n    {\"rb_assoc_new\", (RUBY_PROC*)&dll_rb_assoc_new},\n    {\"rb_cFalseClass\", (RUBY_PROC*)&dll_rb_cFalseClass},\n# if defined(USE_RUBY_INTEGER)\n    {\"rb_cInteger\", (RUBY_PROC*)&dll_rb_cInteger},\n# else\n    {\"rb_cFixnum\", (RUBY_PROC*)&dll_rb_cFixnum},\n# endif\n# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 20\n    {\"rb_cFloat\", (RUBY_PROC*)&dll_rb_cFloat},\n# endif\n    {\"rb_cNilClass\", (RUBY_PROC*)&dll_rb_cNilClass},\n    {\"rb_cObject\", (RUBY_PROC*)&dll_rb_cObject},\n    {\"rb_cSymbol\", (RUBY_PROC*)&dll_rb_cSymbol},\n    {\"rb_cTrueClass\", (RUBY_PROC*)&dll_rb_cTrueClass},\n    {\"rb_check_type\", (RUBY_PROC*)&dll_rb_check_type},\n# ifdef USE_TYPEDDATA\n    {\"rb_check_typeddata\", (RUBY_PROC*)&dll_rb_check_typeddata},\n# endif\n    {\"rb_class_path\", (RUBY_PROC*)&dll_rb_class_path},\n# ifdef USE_TYPEDDATA\n#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 23\n    {\"rb_data_typed_object_wrap\", (RUBY_PROC*)&dll_rb_data_typed_object_wrap},\n#  else\n    {\"rb_data_typed_object_alloc\", (RUBY_PROC*)&dll_rb_data_typed_object_alloc},\n#  endif\n# else\n    {\"rb_data_object_alloc\", (RUBY_PROC*)&dll_rb_data_object_alloc},\n# endif\n    {\"rb_define_class_under\", (RUBY_PROC*)&dll_rb_define_class_under},\n    {\"rb_define_const\", (RUBY_PROC*)&dll_rb_define_const},\n    {\"rb_define_global_function\", (RUBY_PROC*)&dll_rb_define_global_function},\n    {\"rb_define_method\", (RUBY_PROC*)&dll_rb_define_method},\n    {\"rb_define_module\", (RUBY_PROC*)&dll_rb_define_module},\n    {\"rb_define_module_function\", (RUBY_PROC*)&dll_rb_define_module_function},\n    {\"rb_define_singleton_method\", (RUBY_PROC*)&dll_rb_define_singleton_method},\n    {\"rb_define_virtual_variable\", (RUBY_PROC*)&dll_rb_define_virtual_variable},\n    {\"rb_stdout\", (RUBY_PROC*)&dll_rb_stdout},\n    {\"rb_eArgError\", (RUBY_PROC*)&dll_rb_eArgError},\n    {\"rb_eIndexError\", (RUBY_PROC*)&dll_rb_eIndexError},\n    {\"rb_eRuntimeError\", (RUBY_PROC*)&dll_rb_eRuntimeError},\n    {\"rb_eStandardError\", (RUBY_PROC*)&dll_rb_eStandardError},\n    {\"rb_eval_string_protect\", (RUBY_PROC*)&dll_rb_eval_string_protect},\n    {\"rb_global_variable\", (RUBY_PROC*)&dll_rb_global_variable},\n    {\"rb_hash_aset\", (RUBY_PROC*)&dll_rb_hash_aset},\n    {\"rb_hash_new\", (RUBY_PROC*)&dll_rb_hash_new},\n    {\"rb_inspect\", (RUBY_PROC*)&dll_rb_inspect},\n    {\"rb_int2inum\", (RUBY_PROC*)&dll_rb_int2inum},\n# if VIM_SIZEOF_INT < VIM_SIZEOF_LONG /* 64 bits only */\n    {\"rb_fix2int\", (RUBY_PROC*)&dll_rb_fix2int},\n    {\"rb_num2int\", (RUBY_PROC*)&dll_rb_num2int},\n    {\"rb_num2uint\", (RUBY_PROC*)&dll_rb_num2uint},\n# endif\n    {\"rb_lastline_get\", (RUBY_PROC*)&dll_rb_lastline_get},\n    {\"rb_lastline_set\", (RUBY_PROC*)&dll_rb_lastline_set},\n    {\"rb_load_protect\", (RUBY_PROC*)&dll_rb_load_protect},\n    {\"rb_num2long\", (RUBY_PROC*)&dll_rb_num2long},\n    {\"rb_num2ulong\", (RUBY_PROC*)&dll_rb_num2ulong},\n    {\"rb_obj_alloc\", (RUBY_PROC*)&dll_rb_obj_alloc},\n    {\"rb_obj_as_string\", (RUBY_PROC*)&dll_rb_obj_as_string},\n    {\"rb_obj_id\", (RUBY_PROC*)&dll_rb_obj_id},\n    {\"rb_raise\", (RUBY_PROC*)&dll_rb_raise},\n# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18\n    {\"rb_string_value\", (RUBY_PROC*)&dll_rb_string_value},\n# else\n    {\"rb_str2cstr\", (RUBY_PROC*)&dll_rb_str2cstr},\n# endif\n    {\"rb_str_cat\", (RUBY_PROC*)&dll_rb_str_cat},\n    {\"rb_str_concat\", (RUBY_PROC*)&dll_rb_str_concat},\n    {\"rb_str_new\", (RUBY_PROC*)&dll_rb_str_new},\n# ifdef need_rb_str_new_cstr\n    {\"rb_str_new_cstr\", (RUBY_PROC*)&dll_rb_str_new_cstr},\n# else\n    {\"rb_str_new2\", (RUBY_PROC*)&dll_rb_str_new2},\n# endif\n# ifdef RUBY19_OR_LATER\n    {\"rb_errinfo\", (RUBY_PROC*)&dll_rb_errinfo},\n# else\n    {\"ruby_errinfo\", (RUBY_PROC*)&dll_ruby_errinfo},\n# endif\n    {\"ruby_init\", (RUBY_PROC*)&dll_ruby_init},\n    {\"ruby_init_loadpath\", (RUBY_PROC*)&dll_ruby_init_loadpath},\n# ifdef WIN3264\n#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER < 19\n    {\"NtInitialize\", (RUBY_PROC*)&dll_NtInitialize},\n#  else\n    {\"ruby_sysinit\", (RUBY_PROC*)&dll_ruby_sysinit},\n#  endif\n#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18\n    {\"rb_w32_snprintf\", (RUBY_PROC*)&dll_rb_w32_snprintf},\n#  endif\n# endif\n# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18\n    {\"rb_string_value_ptr\", (RUBY_PROC*)&dll_rb_string_value_ptr},\n#  if DYNAMIC_RUBY_VER <= 19\n    {\"rb_float_new\", (RUBY_PROC*)&dll_rb_float_new},\n#  else\n    {\"rb_float_new_in_heap\", (RUBY_PROC*)&dll_rb_float_new},\n#  endif\n    {\"rb_ary_new\", (RUBY_PROC*)&dll_rb_ary_new},\n    {\"rb_ary_push\", (RUBY_PROC*)&dll_rb_ary_push},\n# endif\n# ifdef RUBY19_OR_LATER\n    {\"rb_int2big\", (RUBY_PROC*)&dll_rb_int2big},\n    {\"ruby_script\", (RUBY_PROC*)&dll_ruby_script},\n    {\"rb_enc_find_index\", (RUBY_PROC*)&dll_rb_enc_find_index},\n    {\"rb_enc_find\", (RUBY_PROC*)&dll_rb_enc_find},\n    {\"rb_enc_str_new\", (RUBY_PROC*)&dll_rb_enc_str_new},\n    {\"rb_sprintf\", (RUBY_PROC*)&dll_rb_sprintf},\n    {\"rb_require\", (RUBY_PROC*)&dll_rb_require},\n    {\"ruby_options\", (RUBY_PROC*)&dll_ruby_options},\n# endif\n# if defined(RUBY19_OR_LATER) || defined(RUBY_INIT_STACK)\n#  ifdef __ia64\n    {\"rb_ia64_bsp\", (RUBY_PROC*)&dll_rb_ia64_bsp},\n#  endif\n    {\"ruby_init_stack\", (RUBY_PROC*)&dll_ruby_init_stack},\n# endif\n# if defined(USE_RGENGC) && USE_RGENGC\n#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER == 21\n    {\"rb_gc_writebarrier_unprotect_promoted\", (RUBY_PROC*)&dll_rb_gc_writebarrier_unprotect_promoted},\n#  else\n    {\"rb_gc_writebarrier_unprotect\", (RUBY_PROC*)&dll_rb_gc_writebarrier_unprotect},\n#  endif\n# endif\n    {\"\", NULL},\n};\n\n/*\n * Free ruby.dll\n */\n    static void\nend_dynamic_ruby(void)\n{\n    if (hinstRuby)\n    {\n\tclose_dll(hinstRuby);\n\thinstRuby = NULL;\n    }\n}\n\n/*\n * Load library and get all pointers.\n * Parameter 'libname' provides name of DLL.\n * Return OK or FAIL.\n */\n    static int\nruby_runtime_link_init(char *libname, int verbose)\n{\n    int i;\n\n    if (hinstRuby)\n\treturn OK;\n    hinstRuby = load_dll(libname);\n    if (!hinstRuby)\n    {\n\tif (verbose)\n\t    EMSG2(_(e_loadlib), libname);\n\treturn FAIL;\n    }\n\n    for (i = 0; ruby_funcname_table[i].ptr; ++i)\n    {\n\tif (!(*ruby_funcname_table[i].ptr = symbol_from_dll(hinstRuby,\n\t\t\truby_funcname_table[i].name)))\n\t{\n\t    close_dll(hinstRuby);\n\t    hinstRuby = NULL;\n\t    if (verbose)\n\t\tEMSG2(_(e_loadfunc), ruby_funcname_table[i].name);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * If ruby is enabled (there is installed ruby on Windows system) return TRUE,\n * else FALSE.\n */\n    int\nruby_enabled(int verbose)\n{\n    return ruby_runtime_link_init((char *)p_rubydll, verbose) == OK;\n}\n#endif /* defined(DYNAMIC_RUBY) || defined(PROTO) */\n\n    void\nruby_end(void)\n{\n#ifdef DYNAMIC_RUBY\n    end_dynamic_ruby();\n#endif\n}\n\nvoid ex_ruby(exarg_T *eap)\n{\n    int state;\n    char *script = NULL;\n\n    script = (char *)script_get(eap, eap->arg);\n    if (!eap->skip && ensure_ruby_initialized())\n    {\n\tif (script == NULL)\n\t    rb_eval_string_protect((char *)eap->arg, &state);\n\telse\n\t    rb_eval_string_protect(script, &state);\n\tif (state)\n\t    error_print(state);\n    }\n    vim_free(script);\n}\n\n/*\n *  In Ruby 1.9 or later, ruby String object has encoding.\n *  conversion buffer string of vim to ruby String object using\n *  VIM encoding option.\n */\n    static VALUE\nvim_str2rb_enc_str(const char *s)\n{\n#ifdef RUBY19_OR_LATER\n    int isnum;\n    long lval;\n    char_u *sval;\n    rb_encoding *enc;\n\n    isnum = get_option_value((char_u *)\"enc\", &lval, &sval, 0);\n    if (isnum == 0)\n    {\n\tenc = rb_enc_find((char *)sval);\n\tvim_free(sval);\n\tif (enc)\n\t{\n\t    return rb_enc_str_new(s, (long)strlen(s), enc);\n\t}\n    }\n#endif\n    return rb_str_new2(s);\n}\n\n    static VALUE\neval_enc_string_protect(const char *str, int *state)\n{\n#ifdef RUBY19_OR_LATER\n    int isnum;\n    long lval;\n    char_u *sval;\n    rb_encoding *enc;\n    VALUE v;\n\n    isnum = get_option_value((char_u *)\"enc\", &lval, &sval, 0);\n    if (isnum == 0)\n    {\n\tenc = rb_enc_find((char *)sval);\n\tvim_free(sval);\n\tif (enc)\n\t{\n\t    v = rb_sprintf(\"#-*- coding:%s -*-\\n%s\", rb_enc_name(enc), str);\n\t    return rb_eval_string_protect(StringValuePtr(v), state);\n\t}\n    }\n#endif\n    return rb_eval_string_protect(str, state);\n}\n\nvoid ex_rubydo(exarg_T *eap)\n{\n    int state;\n    linenr_T i;\n    buf_T   *was_curbuf = curbuf;\n\n    if (ensure_ruby_initialized())\n    {\n\tif (u_save(eap->line1 - 1, eap->line2 + 1) != OK)\n\t    return;\n\tfor (i = eap->line1; i <= eap->line2; i++)\n\t{\n\t    VALUE line;\n\n\t    if (i > curbuf->b_ml.ml_line_count)\n\t\tbreak;\n\t    line = vim_str2rb_enc_str((char *)ml_get(i));\n\t    rb_lastline_set(line);\n\t    eval_enc_string_protect((char *) eap->arg, &state);\n\t    if (state)\n\t    {\n\t\terror_print(state);\n\t\tbreak;\n\t    }\n\t    if (was_curbuf != curbuf)\n\t\tbreak;\n\t    line = rb_lastline_get();\n\t    if (!NIL_P(line))\n\t    {\n\t\tif (TYPE(line) != T_STRING)\n\t\t{\n\t\t    EMSG(_(\"E265: $_ must be an instance of String\"));\n\t\t    return;\n\t\t}\n\t\tml_replace(i, (char_u *) StringValuePtr(line), 1);\n\t\tchanged();\n#ifdef SYNTAX_HL\n\t\tsyn_changed(i); /* recompute syntax hl. for this line */\n#endif\n\t    }\n\t}\n\tcheck_cursor();\n\tupdate_curbuf(NOT_VALID);\n    }\n}\n\nvoid ex_rubyfile(exarg_T *eap)\n{\n    int state;\n\n    if (ensure_ruby_initialized())\n    {\n\trb_load_protect(rb_str_new2((char *) eap->arg), 0, &state);\n\tif (state) error_print(state);\n    }\n}\n\nvoid ruby_buffer_free(buf_T *buf)\n{\n    if (buf->b_ruby_ref)\n    {\n\trb_hash_aset(objtbl, rb_obj_id((VALUE) buf->b_ruby_ref), Qnil);\n\tRDATA(buf->b_ruby_ref)->data = NULL;\n    }\n}\n\nvoid ruby_window_free(win_T *win)\n{\n    if (win->w_ruby_ref)\n    {\n\trb_hash_aset(objtbl, rb_obj_id((VALUE) win->w_ruby_ref), Qnil);\n\tRDATA(win->w_ruby_ref)->data = NULL;\n    }\n}\n\nstatic int ensure_ruby_initialized(void)\n{\n    if (!ruby_initialized)\n    {\n#ifdef DYNAMIC_RUBY\n\tif (ruby_enabled(TRUE))\n\t{\n#endif\n#ifdef _WIN32\n\t    /* suggested by Ariya Mizutani */\n\t    int argc = 1;\n\t    char *argv[] = {\"gvim.exe\"};\n\t    char **argvp = argv;\n# ifdef RUBY19_OR_LATER\n\t    ruby_sysinit(&argc, &argvp);\n# else\n\t    NtInitialize(&argc, &argvp);\n# endif\n#endif\n\t    {\n#if defined(RUBY19_OR_LATER) || defined(RUBY_INIT_STACK)\n\t\truby_init_stack(ruby_stack_start);\n#endif\n\t\truby_init();\n\t    }\n#ifdef RUBY19_OR_LATER\n\t    {\n\t\tint dummy_argc = 2;\n\t\tchar *dummy_argv[] = {\"vim-ruby\", \"-e0\"};\n\t\truby_options(dummy_argc, dummy_argv);\n\t    }\n\t    ruby_script(\"vim-ruby\");\n#else\n\t    ruby_init_loadpath();\n#endif\n\t    ruby_io_init();\n\t    ruby_vim_init();\n\t    ruby_initialized = 1;\n#ifdef DYNAMIC_RUBY\n\t}\n\telse\n\t{\n\t    EMSG(_(\"E266: Sorry, this command is disabled, the Ruby library could not be loaded.\"));\n\t    return 0;\n\t}\n#endif\n    }\n    return ruby_initialized;\n}\n\nstatic void error_print(int state)\n{\n#ifndef DYNAMIC_RUBY\n#if !(defined(RUBY_VERSION) && RUBY_VERSION >= 19) \\\n    && !(defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19)\n    RUBYEXTERN VALUE ruby_errinfo;\n#endif\n#endif\n    VALUE eclass;\n    VALUE einfo;\n    char buff[BUFSIZ];\n\n#define TAG_RETURN\t0x1\n#define TAG_BREAK\t0x2\n#define TAG_NEXT\t0x3\n#define TAG_RETRY\t0x4\n#define TAG_REDO\t0x5\n#define TAG_RAISE\t0x6\n#define TAG_THROW\t0x7\n#define TAG_FATAL\t0x8\n#define TAG_MASK\t0xf\n\n    switch (state)\n    {\n    case TAG_RETURN:\n\tEMSG(_(\"E267: unexpected return\"));\n\tbreak;\n    case TAG_NEXT:\n\tEMSG(_(\"E268: unexpected next\"));\n\tbreak;\n    case TAG_BREAK:\n\tEMSG(_(\"E269: unexpected break\"));\n\tbreak;\n    case TAG_REDO:\n\tEMSG(_(\"E270: unexpected redo\"));\n\tbreak;\n    case TAG_RETRY:\n\tEMSG(_(\"E271: retry outside of rescue clause\"));\n\tbreak;\n    case TAG_RAISE:\n    case TAG_FATAL:\n#ifdef RUBY19_OR_LATER\n\teclass = CLASS_OF(rb_errinfo());\n\teinfo = rb_obj_as_string(rb_errinfo());\n#else\n\teclass = CLASS_OF(ruby_errinfo);\n\teinfo = rb_obj_as_string(ruby_errinfo);\n#endif\n\tif (eclass == rb_eRuntimeError && RSTRING_LEN(einfo) == 0)\n\t{\n\t    EMSG(_(\"E272: unhandled exception\"));\n\t}\n\telse\n\t{\n\t    VALUE epath;\n\t    char *p;\n\n\t    epath = rb_class_path(eclass);\n\t    vim_snprintf(buff, BUFSIZ, \"%s: %s\",\n\t\t     RSTRING_PTR(epath), RSTRING_PTR(einfo));\n\t    p = strchr(buff, '\\n');\n\t    if (p) *p = '\\0';\n\t    EMSG(buff);\n\t}\n\tbreak;\n    default:\n\tvim_snprintf(buff, BUFSIZ, _(\"E273: unknown longjmp status %d\"), state);\n\tEMSG(buff);\n\tbreak;\n    }\n}\n\nstatic VALUE vim_message(VALUE self UNUSED, VALUE str)\n{\n    char *buff, *p;\n\n    str = rb_obj_as_string(str);\n    if (RSTRING_LEN(str) > 0)\n    {\n\t/* Only do this when the string isn't empty, alloc(0) causes trouble. */\n\tbuff = ALLOCA_N(char, RSTRING_LEN(str));\n\tstrcpy(buff, RSTRING_PTR(str));\n\tp = strchr(buff, '\\n');\n\tif (p) *p = '\\0';\n\tMSG(buff);\n    }\n    else\n    {\n\tMSG(\"\");\n    }\n    return Qnil;\n}\n\nstatic VALUE vim_set_option(VALUE self UNUSED, VALUE str)\n{\n    do_set((char_u *)StringValuePtr(str), 0);\n    update_screen(NOT_VALID);\n    return Qnil;\n}\n\nstatic VALUE vim_command(VALUE self UNUSED, VALUE str)\n{\n    do_cmdline_cmd((char_u *)StringValuePtr(str));\n    return Qnil;\n}\n\n#ifdef FEAT_EVAL\nstatic VALUE vim_to_ruby(typval_T *tv)\n{\n    VALUE result = Qnil;\n\n    if (tv->v_type == VAR_STRING)\n    {\n\tresult = rb_str_new2(tv->vval.v_string == NULL\n\t\t\t\t\t  ? \"\" : (char *)(tv->vval.v_string));\n    }\n    else if (tv->v_type == VAR_NUMBER)\n    {\n\tresult = INT2NUM(tv->vval.v_number);\n    }\n# ifdef FEAT_FLOAT\n    else if (tv->v_type == VAR_FLOAT)\n    {\n\tresult = rb_float_new(tv->vval.v_float);\n    }\n# endif\n    else if (tv->v_type == VAR_LIST)\n    {\n\tlist_T      *list = tv->vval.v_list;\n\tlistitem_T  *curr;\n\n\tresult = rb_ary_new();\n\n\tif (list != NULL)\n\t{\n\t    for (curr = list->lv_first; curr != NULL; curr = curr->li_next)\n\t    {\n\t\trb_ary_push(result, vim_to_ruby(&curr->li_tv));\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_DICT)\n    {\n\tresult = rb_hash_new();\n\n\tif (tv->vval.v_dict != NULL)\n\t{\n\t    hashtab_T   *ht = &tv->vval.v_dict->dv_hashtab;\n\t    long_u      todo = ht->ht_used;\n\t    hashitem_T  *hi;\n\t    dictitem_T  *di;\n\n\t    for (hi = ht->ht_array; todo > 0; ++hi)\n\t    {\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    --todo;\n\n\t\t    di = dict_lookup(hi);\n\t\t    rb_hash_aset(result, rb_str_new2((char *)hi->hi_key),\n\t\t\t\t\t\t     vim_to_ruby(&di->di_tv));\n\t\t}\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_SPECIAL)\n    {\n\tif (tv->vval.v_number <= VVAL_TRUE)\n\t    result = INT2NUM(tv->vval.v_number);\n    } /* else return Qnil; */\n\n    return result;\n}\n#endif\n\nstatic VALUE vim_evaluate(VALUE self UNUSED, VALUE str)\n{\n#ifdef FEAT_EVAL\n    typval_T    *tv;\n    VALUE       result;\n\n    tv = eval_expr((char_u *)StringValuePtr(str), NULL);\n    if (tv == NULL)\n    {\n\treturn Qnil;\n    }\n    result = vim_to_ruby(tv);\n\n    free_tv(tv);\n\n    return result;\n#else\n    return Qnil;\n#endif\n}\n\n#ifdef USE_TYPEDDATA\nstatic size_t buffer_dsize(const void *buf);\n\nstatic const rb_data_type_t buffer_type = {\n    \"vim_buffer\",\n    {0, 0, buffer_dsize, {0, 0}},\n    0, 0,\n# ifdef RUBY_TYPED_FREE_IMMEDIATELY\n    0,\n# endif\n};\n\nstatic size_t buffer_dsize(const void *buf UNUSED)\n{\n    return sizeof(buf_T);\n}\n#endif\n\nstatic VALUE buffer_new(buf_T *buf)\n{\n    if (buf->b_ruby_ref)\n    {\n\treturn (VALUE) buf->b_ruby_ref;\n    }\n    else\n    {\n#ifdef USE_TYPEDDATA\n\tVALUE obj = TypedData_Wrap_Struct(cBuffer, &buffer_type, buf);\n#else\n\tVALUE obj = Data_Wrap_Struct(cBuffer, 0, 0, buf);\n#endif\n\tbuf->b_ruby_ref = (void *) obj;\n\trb_hash_aset(objtbl, rb_obj_id(obj), obj);\n\treturn obj;\n    }\n}\n\nstatic buf_T *get_buf(VALUE obj)\n{\n    buf_T *buf;\n\n#ifdef USE_TYPEDDATA\n    TypedData_Get_Struct(obj, buf_T, &buffer_type, buf);\n#else\n    Data_Get_Struct(obj, buf_T, buf);\n#endif\n    if (buf == NULL)\n\trb_raise(eDeletedBufferError, \"attempt to refer to deleted buffer\");\n    return buf;\n}\n\nstatic VALUE buffer_s_current(void)\n{\n    return buffer_new(curbuf);\n}\n\nstatic VALUE buffer_s_count(void)\n{\n    buf_T *b;\n    int n = 0;\n\n    FOR_ALL_BUFFERS(b)\n    {\n\t/*  Deleted buffers should not be counted\n\t *    SegPhault - 01/07/05 */\n\tif (b->b_p_bl)\n\t    n++;\n    }\n\n    return INT2NUM(n);\n}\n\nstatic VALUE buffer_s_aref(VALUE self UNUSED, VALUE num)\n{\n    buf_T *b;\n    int n = NUM2INT(num);\n\n    FOR_ALL_BUFFERS(b)\n    {\n\t/*  Deleted buffers should not be counted\n\t *    SegPhault - 01/07/05 */\n\tif (!b->b_p_bl)\n\t    continue;\n\n\tif (n == 0)\n\t    return buffer_new(b);\n\n\tn--;\n    }\n    return Qnil;\n}\n\nstatic VALUE buffer_name(VALUE self)\n{\n    buf_T *buf = get_buf(self);\n\n    return buf->b_ffname ? rb_str_new2((char *)buf->b_ffname) : Qnil;\n}\n\nstatic VALUE buffer_number(VALUE self)\n{\n    buf_T *buf = get_buf(self);\n\n    return INT2NUM(buf->b_fnum);\n}\n\nstatic VALUE buffer_count(VALUE self)\n{\n    buf_T *buf = get_buf(self);\n\n    return INT2NUM(buf->b_ml.ml_line_count);\n}\n\nstatic VALUE get_buffer_line(buf_T *buf, linenr_T n)\n{\n    if (n <= 0 || n > buf->b_ml.ml_line_count)\n\trb_raise(rb_eIndexError, \"line number %ld out of range\", (long)n);\n    return vim_str2rb_enc_str((char *)ml_get_buf(buf, n, FALSE));\n}\n\nstatic VALUE buffer_aref(VALUE self, VALUE num)\n{\n    buf_T *buf = get_buf(self);\n\n    if (buf != NULL)\n\treturn get_buffer_line(buf, (linenr_T)NUM2LONG(num));\n    return Qnil; /* For stop warning */\n}\n\nstatic VALUE set_buffer_line(buf_T *buf, linenr_T n, VALUE str)\n{\n    char\t*line = StringValuePtr(str);\n    aco_save_T\taco;\n\n    if (n > 0 && n <= buf->b_ml.ml_line_count && line != NULL)\n    {\n\t/* set curwin/curbuf for \"buf\" and save some things */\n\taucmd_prepbuf(&aco, buf);\n\n\tif (u_savesub(n) == OK)\n\t{\n\t    ml_replace(n, (char_u *)line, TRUE);\n\t    changed();\n#ifdef SYNTAX_HL\n\t    syn_changed(n); /* recompute syntax hl. for this line */\n#endif\n\t}\n\n\t/* restore curwin/curbuf and a few other things */\n\taucmd_restbuf(&aco);\n\t/* Careful: autocommands may have made \"buf\" invalid! */\n\n\tupdate_curbuf(NOT_VALID);\n    }\n    else\n    {\n\trb_raise(rb_eIndexError, \"line number %ld out of range\", (long)n);\n    }\n    return str;\n}\n\nstatic VALUE buffer_aset(VALUE self, VALUE num, VALUE str)\n{\n    buf_T *buf = get_buf(self);\n\n    if (buf != NULL)\n\treturn set_buffer_line(buf, (linenr_T)NUM2LONG(num), str);\n    return str;\n}\n\nstatic VALUE buffer_delete(VALUE self, VALUE num)\n{\n    buf_T\t*buf = get_buf(self);\n    long\tn = NUM2LONG(num);\n    aco_save_T\taco;\n\n    if (n > 0 && n <= buf->b_ml.ml_line_count)\n    {\n\t/* set curwin/curbuf for \"buf\" and save some things */\n\taucmd_prepbuf(&aco, buf);\n\n\tif (u_savedel(n, 1) == OK)\n\t{\n\t    ml_delete(n, 0);\n\n\t    /* Changes to non-active buffers should properly refresh\n\t     *   SegPhault - 01/09/05 */\n\t    deleted_lines_mark(n, 1L);\n\n\t    changed();\n\t}\n\n\t/* restore curwin/curbuf and a few other things */\n\taucmd_restbuf(&aco);\n\t/* Careful: autocommands may have made \"buf\" invalid! */\n\n\tupdate_curbuf(NOT_VALID);\n    }\n    else\n    {\n\trb_raise(rb_eIndexError, \"line number %ld out of range\", n);\n    }\n    return Qnil;\n}\n\nstatic VALUE buffer_append(VALUE self, VALUE num, VALUE str)\n{\n    buf_T\t*buf = get_buf(self);\n    char\t*line = StringValuePtr(str);\n    long\tn = NUM2LONG(num);\n    aco_save_T\taco;\n\n    if (line == NULL)\n    {\n\trb_raise(rb_eIndexError, \"NULL line\");\n    }\n    else if (n >= 0 && n <= buf->b_ml.ml_line_count)\n    {\n\t/* set curwin/curbuf for \"buf\" and save some things */\n\taucmd_prepbuf(&aco, buf);\n\n\tif (u_inssub(n + 1) == OK)\n\t{\n\t    ml_append(n, (char_u *) line, (colnr_T) 0, FALSE);\n\n\t    /*  Changes to non-active buffers should properly refresh screen\n\t     *    SegPhault - 12/20/04 */\n\t    appended_lines_mark(n, 1L);\n\n\t    changed();\n\t}\n\n\t/* restore curwin/curbuf and a few other things */\n\taucmd_restbuf(&aco);\n\t/* Careful: autocommands may have made \"buf\" invalid! */\n\n\tupdate_curbuf(NOT_VALID);\n    }\n    else\n    {\n\trb_raise(rb_eIndexError, \"line number %ld out of range\", n);\n    }\n    return str;\n}\n\n#ifdef USE_TYPEDDATA\nstatic size_t window_dsize(const void *buf);\n\nstatic const rb_data_type_t window_type = {\n    \"vim_window\",\n    {0, 0, window_dsize, {0, 0}},\n    0, 0,\n# ifdef RUBY_TYPED_FREE_IMMEDIATELY\n    0,\n# endif\n};\n\nstatic size_t window_dsize(const void *win UNUSED)\n{\n    return sizeof(win_T);\n}\n#endif\n\nstatic VALUE window_new(win_T *win)\n{\n    if (win->w_ruby_ref)\n    {\n\treturn (VALUE) win->w_ruby_ref;\n    }\n    else\n    {\n#ifdef USE_TYPEDDATA\n\tVALUE obj = TypedData_Wrap_Struct(cVimWindow, &window_type, win);\n#else\n\tVALUE obj = Data_Wrap_Struct(cVimWindow, 0, 0, win);\n#endif\n\twin->w_ruby_ref = (void *) obj;\n\trb_hash_aset(objtbl, rb_obj_id(obj), obj);\n\treturn obj;\n    }\n}\n\nstatic win_T *get_win(VALUE obj)\n{\n    win_T *win;\n\n#ifdef USE_TYPEDDATA\n    TypedData_Get_Struct(obj, win_T, &window_type, win);\n#else\n    Data_Get_Struct(obj, win_T, win);\n#endif\n    if (win == NULL)\n\trb_raise(eDeletedWindowError, \"attempt to refer to deleted window\");\n    return win;\n}\n\nstatic VALUE window_s_current(void)\n{\n    return window_new(curwin);\n}\n\n/*\n * Added line manipulation functions\n *    SegPhault - 03/07/05\n */\nstatic VALUE line_s_current(void)\n{\n    return get_buffer_line(curbuf, curwin->w_cursor.lnum);\n}\n\nstatic VALUE set_current_line(VALUE self UNUSED, VALUE str)\n{\n    return set_buffer_line(curbuf, curwin->w_cursor.lnum, str);\n}\n\nstatic VALUE current_line_number(void)\n{\n    return INT2FIX((int)curwin->w_cursor.lnum);\n}\n\n\n\nstatic VALUE window_s_count(void)\n{\n#ifdef FEAT_WINDOWS\n    win_T\t*w;\n    int n = 0;\n\n    FOR_ALL_WINDOWS(w)\n\tn++;\n    return INT2NUM(n);\n#else\n    return INT2NUM(1);\n#endif\n}\n\nstatic VALUE window_s_aref(VALUE self UNUSED, VALUE num)\n{\n    win_T *w;\n    int n = NUM2INT(num);\n\n#ifndef FEAT_WINDOWS\n    w = curwin;\n#else\n    for (w = firstwin; w != NULL; w = w->w_next, --n)\n#endif\n\tif (n == 0)\n\t    return window_new(w);\n    return Qnil;\n}\n\nstatic VALUE window_buffer(VALUE self)\n{\n    win_T *win = get_win(self);\n\n    return buffer_new(win->w_buffer);\n}\n\nstatic VALUE window_height(VALUE self)\n{\n    win_T *win = get_win(self);\n\n    return INT2NUM(win->w_height);\n}\n\nstatic VALUE window_set_height(VALUE self, VALUE height)\n{\n    win_T *win = get_win(self);\n    win_T *savewin = curwin;\n\n    curwin = win;\n    win_setheight(NUM2INT(height));\n    curwin = savewin;\n    return height;\n}\n\nstatic VALUE window_width(VALUE self UNUSED)\n{\n    return INT2NUM(W_WIDTH(get_win(self)));\n}\n\nstatic VALUE window_set_width(VALUE self UNUSED, VALUE width)\n{\n#ifdef FEAT_WINDOWS\n    win_T *win = get_win(self);\n    win_T *savewin = curwin;\n\n    curwin = win;\n    win_setwidth(NUM2INT(width));\n    curwin = savewin;\n#endif\n    return width;\n}\n\nstatic VALUE window_cursor(VALUE self)\n{\n    win_T *win = get_win(self);\n\n    return rb_assoc_new(INT2NUM(win->w_cursor.lnum), INT2NUM(win->w_cursor.col));\n}\n\nstatic VALUE window_set_cursor(VALUE self, VALUE pos)\n{\n    VALUE lnum, col;\n    win_T *win = get_win(self);\n\n    Check_Type(pos, T_ARRAY);\n    if (RARRAY_LEN(pos) != 2)\n\trb_raise(rb_eArgError, \"array length must be 2\");\n    lnum = RARRAY_PTR(pos)[0];\n    col = RARRAY_PTR(pos)[1];\n    win->w_cursor.lnum = NUM2LONG(lnum);\n    win->w_cursor.col = NUM2UINT(col);\n    check_cursor();\t\t    /* put cursor on an existing line */\n    update_screen(NOT_VALID);\n    return Qnil;\n}\n\nstatic VALUE f_nop(VALUE self UNUSED)\n{\n    return Qnil;\n}\n\nstatic VALUE f_p(int argc, VALUE *argv, VALUE self UNUSED)\n{\n    int i;\n    VALUE str = rb_str_new(\"\", 0);\n\n    for (i = 0; i < argc; i++)\n    {\n\tif (i > 0) rb_str_cat(str, \", \", 2);\n\trb_str_concat(str, rb_inspect(argv[i]));\n    }\n    MSG(RSTRING_PTR(str));\n    return Qnil;\n}\n\nstatic void ruby_io_init(void)\n{\n#ifndef DYNAMIC_RUBY\n    RUBYEXTERN VALUE rb_stdout;\n#endif\n\n    rb_stdout = rb_obj_alloc(rb_cObject);\n    rb_define_singleton_method(rb_stdout, \"write\", vim_message, 1);\n    rb_define_singleton_method(rb_stdout, \"flush\", f_nop, 0);\n    rb_define_global_function(\"p\", f_p, -1);\n}\n\nstatic void ruby_vim_init(void)\n{\n    objtbl = rb_hash_new();\n    rb_global_variable(&objtbl);\n\n    /* The Vim module used to be called \"VIM\", but \"Vim\" is better.  Make an\n     * alias \"VIM\" for backwards compatibility. */\n    mVIM = rb_define_module(\"Vim\");\n    rb_define_const(rb_cObject, \"VIM\", mVIM);\n    rb_define_const(mVIM, \"VERSION_MAJOR\", INT2NUM(VIM_VERSION_MAJOR));\n    rb_define_const(mVIM, \"VERSION_MINOR\", INT2NUM(VIM_VERSION_MINOR));\n    rb_define_const(mVIM, \"VERSION_BUILD\", INT2NUM(VIM_VERSION_BUILD));\n    rb_define_const(mVIM, \"VERSION_PATCHLEVEL\", INT2NUM(VIM_VERSION_PATCHLEVEL));\n    rb_define_const(mVIM, \"VERSION_SHORT\", rb_str_new2(VIM_VERSION_SHORT));\n    rb_define_const(mVIM, \"VERSION_MEDIUM\", rb_str_new2(VIM_VERSION_MEDIUM));\n    rb_define_const(mVIM, \"VERSION_LONG\", rb_str_new2(VIM_VERSION_LONG));\n    rb_define_const(mVIM, \"VERSION_LONG_DATE\", rb_str_new2(VIM_VERSION_LONG_DATE));\n    rb_define_module_function(mVIM, \"message\", vim_message, 1);\n    rb_define_module_function(mVIM, \"set_option\", vim_set_option, 1);\n    rb_define_module_function(mVIM, \"command\", vim_command, 1);\n    rb_define_module_function(mVIM, \"evaluate\", vim_evaluate, 1);\n\n    eDeletedBufferError = rb_define_class_under(mVIM, \"DeletedBufferError\",\n\t\t\t\t\t\trb_eStandardError);\n    eDeletedWindowError = rb_define_class_under(mVIM, \"DeletedWindowError\",\n\t\t\t\t\t\trb_eStandardError);\n\n    cBuffer = rb_define_class_under(mVIM, \"Buffer\", rb_cObject);\n    rb_define_singleton_method(cBuffer, \"current\", buffer_s_current, 0);\n    rb_define_singleton_method(cBuffer, \"count\", buffer_s_count, 0);\n    rb_define_singleton_method(cBuffer, \"[]\", buffer_s_aref, 1);\n    rb_define_method(cBuffer, \"name\", buffer_name, 0);\n    rb_define_method(cBuffer, \"number\", buffer_number, 0);\n    rb_define_method(cBuffer, \"count\", buffer_count, 0);\n    rb_define_method(cBuffer, \"length\", buffer_count, 0);\n    rb_define_method(cBuffer, \"[]\", buffer_aref, 1);\n    rb_define_method(cBuffer, \"[]=\", buffer_aset, 2);\n    rb_define_method(cBuffer, \"delete\", buffer_delete, 1);\n    rb_define_method(cBuffer, \"append\", buffer_append, 2);\n\n    /* Added line manipulation functions\n     *   SegPhault - 03/07/05 */\n    rb_define_method(cBuffer, \"line_number\", current_line_number, 0);\n    rb_define_method(cBuffer, \"line\", line_s_current, 0);\n    rb_define_method(cBuffer, \"line=\", set_current_line, 1);\n\n\n    cVimWindow = rb_define_class_under(mVIM, \"Window\", rb_cObject);\n    rb_define_singleton_method(cVimWindow, \"current\", window_s_current, 0);\n    rb_define_singleton_method(cVimWindow, \"count\", window_s_count, 0);\n    rb_define_singleton_method(cVimWindow, \"[]\", window_s_aref, 1);\n    rb_define_method(cVimWindow, \"buffer\", window_buffer, 0);\n    rb_define_method(cVimWindow, \"height\", window_height, 0);\n    rb_define_method(cVimWindow, \"height=\", window_set_height, 1);\n    rb_define_method(cVimWindow, \"width\", window_width, 0);\n    rb_define_method(cVimWindow, \"width=\", window_set_width, 1);\n    rb_define_method(cVimWindow, \"cursor\", window_cursor, 0);\n    rb_define_method(cVimWindow, \"cursor=\", window_set_cursor, 1);\n\n    rb_define_virtual_variable(\"$curbuf\", buffer_s_current, 0);\n    rb_define_virtual_variable(\"$curwin\", window_s_current, 0);\n}\n\nvoid vim_ruby_init(void *stack_start)\n{\n    /* should get machine stack start address early in main function */\n    ruby_stack_start = stack_start;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/if_python3.c": "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved    by Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * Python extensions by Paul Moore.\n * Changes for Unix by David Leonard.\n *\n * This consists of four parts:\n * 1. Python interpreter main program\n * 2. Python output stream: writes output via [e]msg().\n * 3. Implementation of the Vim module for Python\n * 4. Utility functions for handling the interface between Vim and Python.\n */\n\n/*\n * Roland Puntaier 2009/sept/16:\n * Adaptations to support both python3.x and python2.x\n */\n\n/* uncomment this if used with the debug version of python */\n/* #define Py_DEBUG */\n/* Note: most of time you can add -DPy_DEBUG to CFLAGS in place of uncommenting\n */\n/* uncomment this if used with the debug version of python, but without its\n * allocator */\n/* #define Py_DEBUG_NO_PYMALLOC */\n\n#include \"vim.h\"\n\n#include <limits.h>\n\n/* Python.h defines _POSIX_THREADS itself (if needed) */\n#ifdef _POSIX_THREADS\n# undef _POSIX_THREADS\n#endif\n\n#if defined(_WIN32) && defined(HAVE_FCNTL_H)\n# undef HAVE_FCNTL_H\n#endif\n\n#ifdef _DEBUG\n# undef _DEBUG\n#endif\n\n#ifdef F_BLANK\n# undef F_BLANK\n#endif\n\n#ifdef HAVE_STRFTIME\n# undef HAVE_STRFTIME\n#endif\n#ifdef HAVE_STRING_H\n# undef HAVE_STRING_H\n#endif\n#ifdef HAVE_PUTENV\n# undef HAVE_PUTENV\n#endif\n#ifdef HAVE_STDARG_H\n# undef HAVE_STDARG_H   /* Python's config.h defines it as well. */\n#endif\n#ifdef _POSIX_C_SOURCE  /* defined in feature.h */\n# undef _POSIX_C_SOURCE\n#endif\n#ifdef _XOPEN_SOURCE\n# undef _XOPEN_SOURCE\t/* pyconfig.h defines it as well. */\n#endif\n\n#define PY_SSIZE_T_CLEAN\n\n#include <Python.h>\n\n#if defined(MACOS) && !defined(MACOS_X_UNIX)\n# include \"macglue.h\"\n# include <CodeFragments.h>\n#endif\n#undef main /* Defined in python.h - aargh */\n#undef HAVE_FCNTL_H /* Clash with os_win32.h */\n\n/* The \"surrogateescape\" error handler is new in Python 3.1 */\n#if PY_VERSION_HEX >= 0x030100f0\n# define CODEC_ERROR_HANDLER \"surrogateescape\"\n#else\n# define CODEC_ERROR_HANDLER NULL\n#endif\n\n/* Python 3 does not support CObjects, always use Capsules */\n#define PY_USE_CAPSULE\n\n#define PyInt Py_ssize_t\n#ifndef PyString_Check\n# define PyString_Check(obj) PyUnicode_Check(obj)\n#endif\n#define PyString_FromString(repr) \\\n    PyUnicode_Decode(repr, STRLEN(repr), ENC_OPT, NULL)\n#define PyString_FromFormat PyUnicode_FromFormat\n#ifndef PyInt_Check\n# define PyInt_Check(obj) PyLong_Check(obj)\n#endif\n#define PyInt_FromLong(i) PyLong_FromLong(i)\n#define PyInt_AsLong(obj) PyLong_AsLong(obj)\n#define Py_ssize_t_fmt \"n\"\n#define Py_bytes_fmt \"y\"\n\n#define PyIntArgFunc\tssizeargfunc\n#define PyIntObjArgProc\tssizeobjargproc\n\n/*\n * PySlice_GetIndicesEx(): first argument type changed from PySliceObject\n * to PyObject in Python 3.2 or later.\n */\n#if PY_VERSION_HEX >= 0x030200f0\ntypedef PyObject PySliceObject_T;\n#else\ntypedef PySliceObject PySliceObject_T;\n#endif\n\n#if defined(DYNAMIC_PYTHON3) || defined(PROTO)\n\n# ifndef WIN3264\n#  include <dlfcn.h>\n#  define FARPROC void*\n#  define HINSTANCE void*\n#  if defined(PY_NO_RTLD_GLOBAL) && defined(PY3_NO_RTLD_GLOBAL)\n#   define load_dll(n) dlopen((n), RTLD_LAZY)\n#  else\n#   define load_dll(n) dlopen((n), RTLD_LAZY|RTLD_GLOBAL)\n#  endif\n#  define close_dll dlclose\n#  define symbol_from_dll dlsym\n# else\n#  define load_dll vimLoadLib\n#  define close_dll FreeLibrary\n#  define symbol_from_dll GetProcAddress\n# endif\n/*\n * Wrapper defines\n */\n# undef PyArg_Parse\n# define PyArg_Parse py3_PyArg_Parse\n# undef PyArg_ParseTuple\n# define PyArg_ParseTuple py3_PyArg_ParseTuple\n# define PyMem_Free py3_PyMem_Free\n# define PyMem_Malloc py3_PyMem_Malloc\n# define PyDict_SetItemString py3_PyDict_SetItemString\n# define PyErr_BadArgument py3_PyErr_BadArgument\n# define PyErr_Clear py3_PyErr_Clear\n# define PyErr_Format py3_PyErr_Format\n# define PyErr_PrintEx py3_PyErr_PrintEx\n# define PyErr_NoMemory py3_PyErr_NoMemory\n# define PyErr_Occurred py3_PyErr_Occurred\n# define PyErr_SetNone py3_PyErr_SetNone\n# define PyErr_SetString py3_PyErr_SetString\n# define PyErr_SetObject py3_PyErr_SetObject\n# define PyErr_ExceptionMatches py3_PyErr_ExceptionMatches\n# define PyEval_InitThreads py3_PyEval_InitThreads\n# define PyEval_RestoreThread py3_PyEval_RestoreThread\n# define PyEval_SaveThread py3_PyEval_SaveThread\n# define PyGILState_Ensure py3_PyGILState_Ensure\n# define PyGILState_Release py3_PyGILState_Release\n# define PyLong_AsLong py3_PyLong_AsLong\n# define PyLong_FromLong py3_PyLong_FromLong\n# define PyList_GetItem py3_PyList_GetItem\n# define PyList_Append py3_PyList_Append\n# define PyList_Insert py3_PyList_Insert\n# define PyList_New py3_PyList_New\n# define PyList_SetItem py3_PyList_SetItem\n# define PyList_Size py3_PyList_Size\n# define PySequence_Check py3_PySequence_Check\n# define PySequence_Size py3_PySequence_Size\n# define PySequence_GetItem py3_PySequence_GetItem\n# define PySequence_Fast py3_PySequence_Fast\n# define PyTuple_Size py3_PyTuple_Size\n# define PyTuple_GetItem py3_PyTuple_GetItem\n# define PySlice_GetIndicesEx py3_PySlice_GetIndicesEx\n# define PyImport_ImportModule py3_PyImport_ImportModule\n# define PyObject_Init py3__PyObject_Init\n# define PyDict_New py3_PyDict_New\n# define PyDict_GetItemString py3_PyDict_GetItemString\n# define PyDict_Next py3_PyDict_Next\n# define PyMapping_Check py3_PyMapping_Check\n# ifndef PyMapping_Keys\n#  define PyMapping_Keys py3_PyMapping_Keys\n# endif\n# define PyIter_Next py3_PyIter_Next\n# define PyObject_GetIter py3_PyObject_GetIter\n# define PyObject_Repr py3_PyObject_Repr\n# define PyObject_GetItem py3_PyObject_GetItem\n# define PyObject_IsTrue py3_PyObject_IsTrue\n# define PyModule_GetDict py3_PyModule_GetDict\n#undef PyRun_SimpleString\n# define PyRun_SimpleString py3_PyRun_SimpleString\n#undef PyRun_String\n# define PyRun_String py3_PyRun_String\n# define PyObject_GetAttrString py3_PyObject_GetAttrString\n# define PyObject_HasAttrString py3_PyObject_HasAttrString\n# define PyObject_SetAttrString py3_PyObject_SetAttrString\n# define PyObject_CallFunctionObjArgs py3_PyObject_CallFunctionObjArgs\n# define _PyObject_CallFunction_SizeT py3__PyObject_CallFunction_SizeT\n# define PyObject_Call py3_PyObject_Call\n# define PyEval_GetLocals py3_PyEval_GetLocals\n# define PyEval_GetGlobals py3_PyEval_GetGlobals\n# define PySys_SetObject py3_PySys_SetObject\n# define PySys_GetObject py3_PySys_GetObject\n# define PySys_SetArgv py3_PySys_SetArgv\n# define PyType_Ready py3_PyType_Ready\n#undef Py_BuildValue\n# define Py_BuildValue py3_Py_BuildValue\n# define Py_SetPythonHome py3_Py_SetPythonHome\n# define Py_Initialize py3_Py_Initialize\n# define Py_Finalize py3_Py_Finalize\n# define Py_IsInitialized py3_Py_IsInitialized\n# define _Py_NoneStruct (*py3__Py_NoneStruct)\n# define _Py_FalseStruct (*py3__Py_FalseStruct)\n# define _Py_TrueStruct (*py3__Py_TrueStruct)\n# define _PyObject_NextNotImplemented (*py3__PyObject_NextNotImplemented)\n# define PyModule_AddObject py3_PyModule_AddObject\n# define PyImport_AppendInittab py3_PyImport_AppendInittab\n# define PyImport_AddModule py3_PyImport_AddModule\n# if PY_VERSION_HEX >= 0x030300f0\n#  undef _PyUnicode_AsString\n#  define _PyUnicode_AsString py3_PyUnicode_AsUTF8\n# else\n#  define _PyUnicode_AsString py3__PyUnicode_AsString\n# endif\n# undef PyUnicode_AsEncodedString\n# define PyUnicode_AsEncodedString py3_PyUnicode_AsEncodedString\n# undef PyBytes_AsString\n# define PyBytes_AsString py3_PyBytes_AsString\n# ifndef PyBytes_AsStringAndSize\n#  define PyBytes_AsStringAndSize py3_PyBytes_AsStringAndSize\n# endif\n# undef PyBytes_FromString\n# define PyBytes_FromString py3_PyBytes_FromString\n# define PyFloat_FromDouble py3_PyFloat_FromDouble\n# define PyFloat_AsDouble py3_PyFloat_AsDouble\n# define PyObject_GenericGetAttr py3_PyObject_GenericGetAttr\n# define PyType_Type (*py3_PyType_Type)\n# define PySlice_Type (*py3_PySlice_Type)\n# define PyFloat_Type (*py3_PyFloat_Type)\n# define PyNumber_Check (*py3_PyNumber_Check)\n# define PyNumber_Long (*py3_PyNumber_Long)\n# define PyBool_Type (*py3_PyBool_Type)\n# define PyErr_NewException py3_PyErr_NewException\n# ifdef Py_DEBUG\n#  define _Py_NegativeRefcount py3__Py_NegativeRefcount\n#  define _Py_RefTotal (*py3__Py_RefTotal)\n#  define _Py_Dealloc py3__Py_Dealloc\n#  define PyModule_Create2TraceRefs py3_PyModule_Create2TraceRefs\n# else\n#  define PyModule_Create2 py3_PyModule_Create2\n# endif\n# if defined(Py_DEBUG) && !defined(Py_DEBUG_NO_PYMALLOC)\n#  define _PyObject_DebugMalloc py3__PyObject_DebugMalloc\n#  define _PyObject_DebugFree py3__PyObject_DebugFree\n# else\n#  define PyObject_Malloc py3_PyObject_Malloc\n#  define PyObject_Free py3_PyObject_Free\n# endif\n# define _PyObject_GC_New py3__PyObject_GC_New\n# define PyObject_GC_Del py3_PyObject_GC_Del\n# define PyObject_GC_UnTrack py3_PyObject_GC_UnTrack\n# define PyType_GenericAlloc py3_PyType_GenericAlloc\n# define PyType_GenericNew py3_PyType_GenericNew\n# undef PyUnicode_FromString\n# define PyUnicode_FromString py3_PyUnicode_FromString\n# ifndef PyUnicode_FromFormat\n#  define PyUnicode_FromFormat py3_PyUnicode_FromFormat\n# else\n#  define Py_UNICODE_USE_UCS_FUNCTIONS\n#  ifdef Py_UNICODE_WIDE\n#   define PyUnicodeUCS4_FromFormat py3_PyUnicodeUCS4_FromFormat\n#  else\n#   define PyUnicodeUCS2_FromFormat py3_PyUnicodeUCS2_FromFormat\n#  endif\n# endif\n# undef PyUnicode_Decode\n# define PyUnicode_Decode py3_PyUnicode_Decode\n# define PyType_IsSubtype py3_PyType_IsSubtype\n# define PyCapsule_New py3_PyCapsule_New\n# define PyCapsule_GetPointer py3_PyCapsule_GetPointer\n\n# if defined(Py_DEBUG) && !defined(Py_DEBUG_NO_PYMALLOC)\n#  undef PyObject_NEW\n#  define PyObject_NEW(type, typeobj) \\\n( (type *) PyObject_Init( \\\n\t(PyObject *) _PyObject_DebugMalloc( _PyObject_SIZE(typeobj) ), (typeobj)) )\n# endif\n\n/*\n * Pointers for dynamic link\n */\nstatic int (*py3_PySys_SetArgv)(int, wchar_t **);\nstatic void (*py3_Py_SetPythonHome)(wchar_t *home);\nstatic void (*py3_Py_Initialize)(void);\nstatic PyObject* (*py3_PyList_New)(Py_ssize_t size);\nstatic PyGILState_STATE (*py3_PyGILState_Ensure)(void);\nstatic void (*py3_PyGILState_Release)(PyGILState_STATE);\nstatic int (*py3_PySys_SetObject)(char *, PyObject *);\nstatic PyObject* (*py3_PySys_GetObject)(char *);\nstatic int (*py3_PyList_Append)(PyObject *, PyObject *);\nstatic int (*py3_PyList_Insert)(PyObject *, int, PyObject *);\nstatic Py_ssize_t (*py3_PyList_Size)(PyObject *);\nstatic int (*py3_PySequence_Check)(PyObject *);\nstatic Py_ssize_t (*py3_PySequence_Size)(PyObject *);\nstatic PyObject* (*py3_PySequence_GetItem)(PyObject *, Py_ssize_t);\nstatic PyObject* (*py3_PySequence_Fast)(PyObject *, const char *);\nstatic Py_ssize_t (*py3_PyTuple_Size)(PyObject *);\nstatic PyObject* (*py3_PyTuple_GetItem)(PyObject *, Py_ssize_t);\nstatic int (*py3_PyMapping_Check)(PyObject *);\nstatic PyObject* (*py3_PyMapping_Keys)(PyObject *);\nstatic int (*py3_PySlice_GetIndicesEx)(PySliceObject_T *r, Py_ssize_t length,\n\t\t     Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step,\n\t\t     Py_ssize_t *slicelen);\nstatic PyObject* (*py3_PyErr_NoMemory)(void);\nstatic void (*py3_Py_Finalize)(void);\nstatic void (*py3_PyErr_SetString)(PyObject *, const char *);\nstatic void (*py3_PyErr_SetObject)(PyObject *, PyObject *);\nstatic int (*py3_PyErr_ExceptionMatches)(PyObject *);\nstatic int (*py3_PyRun_SimpleString)(char *);\nstatic PyObject* (*py3_PyRun_String)(char *, int, PyObject *, PyObject *);\nstatic PyObject* (*py3_PyObject_GetAttrString)(PyObject *, const char *);\nstatic int (*py3_PyObject_HasAttrString)(PyObject *, const char *);\nstatic int (*py3_PyObject_SetAttrString)(PyObject *, const char *, PyObject *);\nstatic PyObject* (*py3_PyObject_CallFunctionObjArgs)(PyObject *, ...);\nstatic PyObject* (*py3__PyObject_CallFunction_SizeT)(PyObject *, char *, ...);\nstatic PyObject* (*py3_PyObject_Call)(PyObject *, PyObject *, PyObject *);\nstatic PyObject* (*py3_PyEval_GetGlobals)();\nstatic PyObject* (*py3_PyEval_GetLocals)();\nstatic PyObject* (*py3_PyList_GetItem)(PyObject *, Py_ssize_t);\nstatic PyObject* (*py3_PyImport_ImportModule)(const char *);\nstatic PyObject* (*py3_PyImport_AddModule)(const char *);\nstatic int (*py3_PyErr_BadArgument)(void);\nstatic PyObject* (*py3_PyErr_Occurred)(void);\nstatic PyObject* (*py3_PyModule_GetDict)(PyObject *);\nstatic int (*py3_PyList_SetItem)(PyObject *, Py_ssize_t, PyObject *);\nstatic PyObject* (*py3_PyDict_GetItemString)(PyObject *, const char *);\nstatic int (*py3_PyDict_Next)(PyObject *, Py_ssize_t *, PyObject **, PyObject **);\nstatic PyObject* (*py3_PyLong_FromLong)(long);\nstatic PyObject* (*py3_PyDict_New)(void);\nstatic PyObject* (*py3_PyIter_Next)(PyObject *);\nstatic PyObject* (*py3_PyObject_GetIter)(PyObject *);\nstatic PyObject* (*py3_PyObject_Repr)(PyObject *);\nstatic PyObject* (*py3_PyObject_GetItem)(PyObject *, PyObject *);\nstatic int (*py3_PyObject_IsTrue)(PyObject *);\nstatic PyObject* (*py3_Py_BuildValue)(char *, ...);\nstatic int (*py3_PyType_Ready)(PyTypeObject *type);\nstatic int (*py3_PyDict_SetItemString)(PyObject *dp, char *key, PyObject *item);\nstatic PyObject* (*py3_PyUnicode_FromString)(const char *u);\n# ifndef Py_UNICODE_USE_UCS_FUNCTIONS\nstatic PyObject* (*py3_PyUnicode_FromFormat)(const char *u, ...);\n# else\n#  ifdef Py_UNICODE_WIDE\nstatic PyObject* (*py3_PyUnicodeUCS4_FromFormat)(const char *u, ...);\n#  else\nstatic PyObject* (*py3_PyUnicodeUCS2_FromFormat)(const char *u, ...);\n#  endif\n# endif\nstatic PyObject* (*py3_PyUnicode_Decode)(const char *u, Py_ssize_t size,\n\tconst char *encoding, const char *errors);\nstatic long (*py3_PyLong_AsLong)(PyObject *);\nstatic void (*py3_PyErr_SetNone)(PyObject *);\nstatic void (*py3_PyEval_InitThreads)(void);\nstatic void(*py3_PyEval_RestoreThread)(PyThreadState *);\nstatic PyThreadState*(*py3_PyEval_SaveThread)(void);\nstatic int (*py3_PyArg_Parse)(PyObject *, char *, ...);\nstatic int (*py3_PyArg_ParseTuple)(PyObject *, char *, ...);\nstatic int (*py3_PyMem_Free)(void *);\nstatic void* (*py3_PyMem_Malloc)(size_t);\nstatic int (*py3_Py_IsInitialized)(void);\nstatic void (*py3_PyErr_Clear)(void);\nstatic PyObject* (*py3_PyErr_Format)(PyObject *, const char *, ...);\nstatic void (*py3_PyErr_PrintEx)(int);\nstatic PyObject*(*py3__PyObject_Init)(PyObject *, PyTypeObject *);\nstatic iternextfunc py3__PyObject_NextNotImplemented;\nstatic PyObject* py3__Py_NoneStruct;\nstatic PyObject* py3__Py_FalseStruct;\nstatic PyObject* py3__Py_TrueStruct;\nstatic int (*py3_PyModule_AddObject)(PyObject *m, const char *name, PyObject *o);\nstatic int (*py3_PyImport_AppendInittab)(const char *name, PyObject* (*initfunc)(void));\n# if PY_VERSION_HEX >= 0x030300f0\nstatic char* (*py3_PyUnicode_AsUTF8)(PyObject *unicode);\n# else\nstatic char* (*py3__PyUnicode_AsString)(PyObject *unicode);\n# endif\nstatic PyObject* (*py3_PyUnicode_AsEncodedString)(PyObject *unicode, const char* encoding, const char* errors);\nstatic char* (*py3_PyBytes_AsString)(PyObject *bytes);\nstatic int (*py3_PyBytes_AsStringAndSize)(PyObject *bytes, char **buffer, Py_ssize_t *length);\nstatic PyObject* (*py3_PyBytes_FromString)(char *str);\nstatic PyObject* (*py3_PyFloat_FromDouble)(double num);\nstatic double (*py3_PyFloat_AsDouble)(PyObject *);\nstatic PyObject* (*py3_PyObject_GenericGetAttr)(PyObject *obj, PyObject *name);\nstatic PyObject* (*py3_PyType_GenericAlloc)(PyTypeObject *type, Py_ssize_t nitems);\nstatic PyObject* (*py3_PyType_GenericNew)(PyTypeObject *type, PyObject *args, PyObject *kwds);\nstatic PyTypeObject* py3_PyType_Type;\nstatic PyTypeObject* py3_PySlice_Type;\nstatic PyTypeObject* py3_PyFloat_Type;\nstatic PyTypeObject* py3_PyBool_Type;\nstatic int (*py3_PyNumber_Check)(PyObject *);\nstatic PyObject* (*py3_PyNumber_Long)(PyObject *);\nstatic PyObject* (*py3_PyErr_NewException)(char *name, PyObject *base, PyObject *dict);\nstatic PyObject* (*py3_PyCapsule_New)(void *, char *, PyCapsule_Destructor);\nstatic void* (*py3_PyCapsule_GetPointer)(PyObject *, char *);\n# ifdef Py_DEBUG\nstatic void (*py3__Py_NegativeRefcount)(const char *fname, int lineno, PyObject *op);\nstatic Py_ssize_t* py3__Py_RefTotal;\nstatic void (*py3__Py_Dealloc)(PyObject *obj);\nstatic PyObject* (*py3_PyModule_Create2TraceRefs)(struct PyModuleDef* module, int module_api_version);\n# else\nstatic PyObject* (*py3_PyModule_Create2)(struct PyModuleDef* module, int module_api_version);\n# endif\n# if defined(Py_DEBUG) && !defined(Py_DEBUG_NO_PYMALLOC)\nstatic void (*py3__PyObject_DebugFree)(void*);\nstatic void* (*py3__PyObject_DebugMalloc)(size_t);\n# else\nstatic void (*py3_PyObject_Free)(void*);\nstatic void* (*py3_PyObject_Malloc)(size_t);\n# endif\nstatic PyObject*(*py3__PyObject_GC_New)(PyTypeObject *);\nstatic void(*py3_PyObject_GC_Del)(void *);\nstatic void(*py3_PyObject_GC_UnTrack)(void *);\nstatic int (*py3_PyType_IsSubtype)(PyTypeObject *, PyTypeObject *);\n\nstatic HINSTANCE hinstPy3 = 0; /* Instance of python.dll */\n\n/* Imported exception objects */\nstatic PyObject *p3imp_PyExc_AttributeError;\nstatic PyObject *p3imp_PyExc_IndexError;\nstatic PyObject *p3imp_PyExc_KeyError;\nstatic PyObject *p3imp_PyExc_KeyboardInterrupt;\nstatic PyObject *p3imp_PyExc_TypeError;\nstatic PyObject *p3imp_PyExc_ValueError;\nstatic PyObject *p3imp_PyExc_SystemExit;\nstatic PyObject *p3imp_PyExc_RuntimeError;\nstatic PyObject *p3imp_PyExc_ImportError;\nstatic PyObject *p3imp_PyExc_OverflowError;\n\n# define PyExc_AttributeError p3imp_PyExc_AttributeError\n# define PyExc_IndexError p3imp_PyExc_IndexError\n# define PyExc_KeyError p3imp_PyExc_KeyError\n# define PyExc_KeyboardInterrupt p3imp_PyExc_KeyboardInterrupt\n# define PyExc_TypeError p3imp_PyExc_TypeError\n# define PyExc_ValueError p3imp_PyExc_ValueError\n# define PyExc_SystemExit p3imp_PyExc_SystemExit\n# define PyExc_RuntimeError p3imp_PyExc_RuntimeError\n# define PyExc_ImportError p3imp_PyExc_ImportError\n# define PyExc_OverflowError p3imp_PyExc_OverflowError\n\n/*\n * Table of name to function pointer of python.\n */\n# define PYTHON_PROC FARPROC\nstatic struct\n{\n    char *name;\n    PYTHON_PROC *ptr;\n} py3_funcname_table[] =\n{\n    {\"PySys_SetArgv\", (PYTHON_PROC*)&py3_PySys_SetArgv},\n    {\"Py_SetPythonHome\", (PYTHON_PROC*)&py3_Py_SetPythonHome},\n    {\"Py_Initialize\", (PYTHON_PROC*)&py3_Py_Initialize},\n    {\"_PyArg_ParseTuple_SizeT\", (PYTHON_PROC*)&py3_PyArg_ParseTuple},\n    {\"_Py_BuildValue_SizeT\", (PYTHON_PROC*)&py3_Py_BuildValue},\n    {\"PyMem_Free\", (PYTHON_PROC*)&py3_PyMem_Free},\n    {\"PyMem_Malloc\", (PYTHON_PROC*)&py3_PyMem_Malloc},\n    {\"PyList_New\", (PYTHON_PROC*)&py3_PyList_New},\n    {\"PyGILState_Ensure\", (PYTHON_PROC*)&py3_PyGILState_Ensure},\n    {\"PyGILState_Release\", (PYTHON_PROC*)&py3_PyGILState_Release},\n    {\"PySys_SetObject\", (PYTHON_PROC*)&py3_PySys_SetObject},\n    {\"PySys_GetObject\", (PYTHON_PROC*)&py3_PySys_GetObject},\n    {\"PyList_Append\", (PYTHON_PROC*)&py3_PyList_Append},\n    {\"PyList_Insert\", (PYTHON_PROC*)&py3_PyList_Insert},\n    {\"PyList_Size\", (PYTHON_PROC*)&py3_PyList_Size},\n    {\"PySequence_Check\", (PYTHON_PROC*)&py3_PySequence_Check},\n    {\"PySequence_Size\", (PYTHON_PROC*)&py3_PySequence_Size},\n    {\"PySequence_GetItem\", (PYTHON_PROC*)&py3_PySequence_GetItem},\n    {\"PySequence_Fast\", (PYTHON_PROC*)&py3_PySequence_Fast},\n    {\"PyTuple_Size\", (PYTHON_PROC*)&py3_PyTuple_Size},\n    {\"PyTuple_GetItem\", (PYTHON_PROC*)&py3_PyTuple_GetItem},\n    {\"PySlice_GetIndicesEx\", (PYTHON_PROC*)&py3_PySlice_GetIndicesEx},\n    {\"PyErr_NoMemory\", (PYTHON_PROC*)&py3_PyErr_NoMemory},\n    {\"Py_Finalize\", (PYTHON_PROC*)&py3_Py_Finalize},\n    {\"PyErr_SetString\", (PYTHON_PROC*)&py3_PyErr_SetString},\n    {\"PyErr_SetObject\", (PYTHON_PROC*)&py3_PyErr_SetObject},\n    {\"PyErr_ExceptionMatches\", (PYTHON_PROC*)&py3_PyErr_ExceptionMatches},\n    {\"PyRun_SimpleString\", (PYTHON_PROC*)&py3_PyRun_SimpleString},\n    {\"PyRun_String\", (PYTHON_PROC*)&py3_PyRun_String},\n    {\"PyObject_GetAttrString\", (PYTHON_PROC*)&py3_PyObject_GetAttrString},\n    {\"PyObject_HasAttrString\", (PYTHON_PROC*)&py3_PyObject_HasAttrString},\n    {\"PyObject_SetAttrString\", (PYTHON_PROC*)&py3_PyObject_SetAttrString},\n    {\"PyObject_CallFunctionObjArgs\", (PYTHON_PROC*)&py3_PyObject_CallFunctionObjArgs},\n    {\"_PyObject_CallFunction_SizeT\", (PYTHON_PROC*)&py3__PyObject_CallFunction_SizeT},\n    {\"PyObject_Call\", (PYTHON_PROC*)&py3_PyObject_Call},\n    {\"PyEval_GetGlobals\", (PYTHON_PROC*)&py3_PyEval_GetGlobals},\n    {\"PyEval_GetLocals\", (PYTHON_PROC*)&py3_PyEval_GetLocals},\n    {\"PyList_GetItem\", (PYTHON_PROC*)&py3_PyList_GetItem},\n    {\"PyImport_ImportModule\", (PYTHON_PROC*)&py3_PyImport_ImportModule},\n    {\"PyImport_AddModule\", (PYTHON_PROC*)&py3_PyImport_AddModule},\n    {\"PyErr_BadArgument\", (PYTHON_PROC*)&py3_PyErr_BadArgument},\n    {\"PyErr_Occurred\", (PYTHON_PROC*)&py3_PyErr_Occurred},\n    {\"PyModule_GetDict\", (PYTHON_PROC*)&py3_PyModule_GetDict},\n    {\"PyList_SetItem\", (PYTHON_PROC*)&py3_PyList_SetItem},\n    {\"PyDict_GetItemString\", (PYTHON_PROC*)&py3_PyDict_GetItemString},\n    {\"PyDict_Next\", (PYTHON_PROC*)&py3_PyDict_Next},\n    {\"PyMapping_Check\", (PYTHON_PROC*)&py3_PyMapping_Check},\n    {\"PyMapping_Keys\", (PYTHON_PROC*)&py3_PyMapping_Keys},\n    {\"PyIter_Next\", (PYTHON_PROC*)&py3_PyIter_Next},\n    {\"PyObject_GetIter\", (PYTHON_PROC*)&py3_PyObject_GetIter},\n    {\"PyObject_Repr\", (PYTHON_PROC*)&py3_PyObject_Repr},\n    {\"PyObject_GetItem\", (PYTHON_PROC*)&py3_PyObject_GetItem},\n    {\"PyObject_IsTrue\", (PYTHON_PROC*)&py3_PyObject_IsTrue},\n    {\"PyLong_FromLong\", (PYTHON_PROC*)&py3_PyLong_FromLong},\n    {\"PyDict_New\", (PYTHON_PROC*)&py3_PyDict_New},\n    {\"PyType_Ready\", (PYTHON_PROC*)&py3_PyType_Ready},\n    {\"PyDict_SetItemString\", (PYTHON_PROC*)&py3_PyDict_SetItemString},\n    {\"PyLong_AsLong\", (PYTHON_PROC*)&py3_PyLong_AsLong},\n    {\"PyErr_SetNone\", (PYTHON_PROC*)&py3_PyErr_SetNone},\n    {\"PyEval_InitThreads\", (PYTHON_PROC*)&py3_PyEval_InitThreads},\n    {\"PyEval_RestoreThread\", (PYTHON_PROC*)&py3_PyEval_RestoreThread},\n    {\"PyEval_SaveThread\", (PYTHON_PROC*)&py3_PyEval_SaveThread},\n    {\"_PyArg_Parse_SizeT\", (PYTHON_PROC*)&py3_PyArg_Parse},\n    {\"Py_IsInitialized\", (PYTHON_PROC*)&py3_Py_IsInitialized},\n    {\"_PyObject_NextNotImplemented\", (PYTHON_PROC*)&py3__PyObject_NextNotImplemented},\n    {\"_Py_NoneStruct\", (PYTHON_PROC*)&py3__Py_NoneStruct},\n    {\"_Py_FalseStruct\", (PYTHON_PROC*)&py3__Py_FalseStruct},\n    {\"_Py_TrueStruct\", (PYTHON_PROC*)&py3__Py_TrueStruct},\n    {\"PyErr_Clear\", (PYTHON_PROC*)&py3_PyErr_Clear},\n    {\"PyErr_Format\", (PYTHON_PROC*)&py3_PyErr_Format},\n    {\"PyErr_PrintEx\", (PYTHON_PROC*)&py3_PyErr_PrintEx},\n    {\"PyObject_Init\", (PYTHON_PROC*)&py3__PyObject_Init},\n    {\"PyModule_AddObject\", (PYTHON_PROC*)&py3_PyModule_AddObject},\n    {\"PyImport_AppendInittab\", (PYTHON_PROC*)&py3_PyImport_AppendInittab},\n# if PY_VERSION_HEX >= 0x030300f0\n    {\"PyUnicode_AsUTF8\", (PYTHON_PROC*)&py3_PyUnicode_AsUTF8},\n# else\n    {\"_PyUnicode_AsString\", (PYTHON_PROC*)&py3__PyUnicode_AsString},\n# endif\n# ifndef Py_UNICODE_USE_UCS_FUNCTIONS\n    {\"PyUnicode_FromFormat\", (PYTHON_PROC*)&py3_PyUnicode_FromFormat},\n# else\n#  ifdef Py_UNICODE_WIDE\n    {\"PyUnicodeUCS4_FromFormat\", (PYTHON_PROC*)&py3_PyUnicodeUCS4_FromFormat},\n#  else\n    {\"PyUnicodeUCS2_FromFormat\", (PYTHON_PROC*)&py3_PyUnicodeUCS2_FromFormat},\n#  endif\n# endif\n    {\"PyBytes_AsString\", (PYTHON_PROC*)&py3_PyBytes_AsString},\n    {\"PyBytes_AsStringAndSize\", (PYTHON_PROC*)&py3_PyBytes_AsStringAndSize},\n    {\"PyBytes_FromString\", (PYTHON_PROC*)&py3_PyBytes_FromString},\n    {\"PyFloat_FromDouble\", (PYTHON_PROC*)&py3_PyFloat_FromDouble},\n    {\"PyFloat_AsDouble\", (PYTHON_PROC*)&py3_PyFloat_AsDouble},\n    {\"PyObject_GenericGetAttr\", (PYTHON_PROC*)&py3_PyObject_GenericGetAttr},\n    {\"PyType_GenericAlloc\", (PYTHON_PROC*)&py3_PyType_GenericAlloc},\n    {\"PyType_GenericNew\", (PYTHON_PROC*)&py3_PyType_GenericNew},\n    {\"PyType_Type\", (PYTHON_PROC*)&py3_PyType_Type},\n    {\"PySlice_Type\", (PYTHON_PROC*)&py3_PySlice_Type},\n    {\"PyFloat_Type\", (PYTHON_PROC*)&py3_PyFloat_Type},\n    {\"PyBool_Type\", (PYTHON_PROC*)&py3_PyBool_Type},\n    {\"PyNumber_Check\", (PYTHON_PROC*)&py3_PyNumber_Check},\n    {\"PyNumber_Long\", (PYTHON_PROC*)&py3_PyNumber_Long},\n    {\"PyErr_NewException\", (PYTHON_PROC*)&py3_PyErr_NewException},\n# ifdef Py_DEBUG\n    {\"_Py_NegativeRefcount\", (PYTHON_PROC*)&py3__Py_NegativeRefcount},\n    {\"_Py_RefTotal\", (PYTHON_PROC*)&py3__Py_RefTotal},\n    {\"_Py_Dealloc\", (PYTHON_PROC*)&py3__Py_Dealloc},\n    {\"PyModule_Create2TraceRefs\", (PYTHON_PROC*)&py3_PyModule_Create2TraceRefs},\n# else\n    {\"PyModule_Create2\", (PYTHON_PROC*)&py3_PyModule_Create2},\n# endif\n# if defined(Py_DEBUG) && !defined(Py_DEBUG_NO_PYMALLOC)\n    {\"_PyObject_DebugFree\", (PYTHON_PROC*)&py3__PyObject_DebugFree},\n    {\"_PyObject_DebugMalloc\", (PYTHON_PROC*)&py3__PyObject_DebugMalloc},\n# else\n    {\"PyObject_Malloc\", (PYTHON_PROC*)&py3_PyObject_Malloc},\n    {\"PyObject_Free\", (PYTHON_PROC*)&py3_PyObject_Free},\n# endif\n    {\"_PyObject_GC_New\", (PYTHON_PROC*)&py3__PyObject_GC_New},\n    {\"PyObject_GC_Del\", (PYTHON_PROC*)&py3_PyObject_GC_Del},\n    {\"PyObject_GC_UnTrack\", (PYTHON_PROC*)&py3_PyObject_GC_UnTrack},\n    {\"PyType_IsSubtype\", (PYTHON_PROC*)&py3_PyType_IsSubtype},\n    {\"PyCapsule_New\", (PYTHON_PROC*)&py3_PyCapsule_New},\n    {\"PyCapsule_GetPointer\", (PYTHON_PROC*)&py3_PyCapsule_GetPointer},\n    {\"\", NULL},\n};\n\n/*\n * Free python.dll\n */\n    static void\nend_dynamic_python3(void)\n{\n    if (hinstPy3 != 0)\n    {\n\tclose_dll(hinstPy3);\n\thinstPy3 = 0;\n    }\n}\n\n/*\n * Load library and get all pointers.\n * Parameter 'libname' provides name of DLL.\n * Return OK or FAIL.\n */\n    static int\npy3_runtime_link_init(char *libname, int verbose)\n{\n    int i;\n    void *ucs_from_string, *ucs_decode, *ucs_as_encoded_string;\n\n# if !(defined(PY_NO_RTLD_GLOBAL) && defined(PY3_NO_RTLD_GLOBAL)) && defined(UNIX) && defined(FEAT_PYTHON)\n    /* Can't have Python and Python3 loaded at the same time.\n     * It cause a crash, because RTLD_GLOBAL is needed for\n     * standard C extension libraries of one or both python versions. */\n    if (python_loaded())\n    {\n\tif (verbose)\n\t    EMSG(_(\"E837: This Vim cannot execute :py3 after using :python\"));\n\treturn FAIL;\n    }\n# endif\n\n    if (hinstPy3 != 0)\n\treturn OK;\n    hinstPy3 = load_dll(libname);\n\n    if (!hinstPy3)\n    {\n\tif (verbose)\n\t    EMSG2(_(e_loadlib), libname);\n\treturn FAIL;\n    }\n\n    for (i = 0; py3_funcname_table[i].ptr; ++i)\n    {\n\tif ((*py3_funcname_table[i].ptr = symbol_from_dll(hinstPy3,\n\t\t\tpy3_funcname_table[i].name)) == NULL)\n\t{\n\t    close_dll(hinstPy3);\n\t    hinstPy3 = 0;\n\t    if (verbose)\n\t\tEMSG2(_(e_loadfunc), py3_funcname_table[i].name);\n\t    return FAIL;\n\t}\n    }\n\n    /* Load unicode functions separately as only the ucs2 or the ucs4 functions\n     * will be present in the library. */\n# if PY_VERSION_HEX >= 0x030300f0\n    ucs_from_string = symbol_from_dll(hinstPy3, \"PyUnicode_FromString\");\n    ucs_decode = symbol_from_dll(hinstPy3, \"PyUnicode_Decode\");\n    ucs_as_encoded_string = symbol_from_dll(hinstPy3,\n\t    \"PyUnicode_AsEncodedString\");\n# else\n    ucs_from_string = symbol_from_dll(hinstPy3, \"PyUnicodeUCS2_FromString\");\n    ucs_decode = symbol_from_dll(hinstPy3,\n\t    \"PyUnicodeUCS2_Decode\");\n    ucs_as_encoded_string = symbol_from_dll(hinstPy3,\n\t    \"PyUnicodeUCS2_AsEncodedString\");\n    if (!ucs_from_string || !ucs_decode || !ucs_as_encoded_string)\n    {\n\tucs_from_string = symbol_from_dll(hinstPy3,\n\t\t\"PyUnicodeUCS4_FromString\");\n\tucs_decode = symbol_from_dll(hinstPy3,\n\t\t\"PyUnicodeUCS4_Decode\");\n\tucs_as_encoded_string = symbol_from_dll(hinstPy3,\n\t\t\"PyUnicodeUCS4_AsEncodedString\");\n    }\n# endif\n    if (ucs_from_string && ucs_decode && ucs_as_encoded_string)\n    {\n\tpy3_PyUnicode_FromString = ucs_from_string;\n\tpy3_PyUnicode_Decode = ucs_decode;\n\tpy3_PyUnicode_AsEncodedString = ucs_as_encoded_string;\n    }\n    else\n    {\n\tclose_dll(hinstPy3);\n\thinstPy3 = 0;\n\tif (verbose)\n\t    EMSG2(_(e_loadfunc), \"PyUnicode_UCSX_*\");\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * If python is enabled (there is installed python on Windows system) return\n * TRUE, else FALSE.\n */\n    int\npython3_enabled(int verbose)\n{\n    return py3_runtime_link_init((char *)p_py3dll, verbose) == OK;\n}\n\n/* Load the standard Python exceptions - don't import the symbols from the\n * DLL, as this can cause errors (importing data symbols is not reliable).\n */\nstatic void get_py3_exceptions(void);\n\n    static void\nget_py3_exceptions(void)\n{\n    PyObject *exmod = PyImport_ImportModule(\"builtins\");\n    PyObject *exdict = PyModule_GetDict(exmod);\n    p3imp_PyExc_AttributeError = PyDict_GetItemString(exdict, \"AttributeError\");\n    p3imp_PyExc_IndexError = PyDict_GetItemString(exdict, \"IndexError\");\n    p3imp_PyExc_KeyError = PyDict_GetItemString(exdict, \"KeyError\");\n    p3imp_PyExc_KeyboardInterrupt = PyDict_GetItemString(exdict, \"KeyboardInterrupt\");\n    p3imp_PyExc_TypeError = PyDict_GetItemString(exdict, \"TypeError\");\n    p3imp_PyExc_ValueError = PyDict_GetItemString(exdict, \"ValueError\");\n    p3imp_PyExc_SystemExit = PyDict_GetItemString(exdict, \"SystemExit\");\n    p3imp_PyExc_RuntimeError = PyDict_GetItemString(exdict, \"RuntimeError\");\n    p3imp_PyExc_ImportError = PyDict_GetItemString(exdict, \"ImportError\");\n    p3imp_PyExc_OverflowError = PyDict_GetItemString(exdict, \"OverflowError\");\n    Py_XINCREF(p3imp_PyExc_AttributeError);\n    Py_XINCREF(p3imp_PyExc_IndexError);\n    Py_XINCREF(p3imp_PyExc_KeyError);\n    Py_XINCREF(p3imp_PyExc_KeyboardInterrupt);\n    Py_XINCREF(p3imp_PyExc_TypeError);\n    Py_XINCREF(p3imp_PyExc_ValueError);\n    Py_XINCREF(p3imp_PyExc_SystemExit);\n    Py_XINCREF(p3imp_PyExc_RuntimeError);\n    Py_XINCREF(p3imp_PyExc_ImportError);\n    Py_XINCREF(p3imp_PyExc_OverflowError);\n    Py_XDECREF(exmod);\n}\n#endif /* DYNAMIC_PYTHON3 */\n\nstatic int py3initialised = 0;\n\n#define PYINITIALISED py3initialised\n\n#define DESTRUCTOR_FINISH(self) Py_TYPE(self)->tp_free((PyObject*)self)\n\n#define WIN_PYTHON_REF(win) win->w_python3_ref\n#define BUF_PYTHON_REF(buf) buf->b_python3_ref\n#define TAB_PYTHON_REF(tab) tab->tp_python3_ref\n\n    static void\ncall_PyObject_Free(void *p)\n{\n#if defined(Py_DEBUG) && !defined(Py_DEBUG_NO_PYMALLOC)\n    _PyObject_DebugFree(p);\n#else\n    PyObject_Free(p);\n#endif\n}\n\n    static PyObject *\ncall_PyType_GenericNew(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    return PyType_GenericNew(type,args,kwds);\n}\n\n    static PyObject *\ncall_PyType_GenericAlloc(PyTypeObject *type, Py_ssize_t nitems)\n{\n    return PyType_GenericAlloc(type,nitems);\n}\n\nstatic PyObject *OutputGetattro(PyObject *, PyObject *);\nstatic int OutputSetattro(PyObject *, PyObject *, PyObject *);\nstatic PyObject *BufferGetattro(PyObject *, PyObject *);\nstatic int BufferSetattro(PyObject *, PyObject *, PyObject *);\nstatic PyObject *TabPageGetattro(PyObject *, PyObject *);\nstatic PyObject *WindowGetattro(PyObject *, PyObject *);\nstatic int WindowSetattro(PyObject *, PyObject *, PyObject *);\nstatic PyObject *RangeGetattro(PyObject *, PyObject *);\nstatic PyObject *CurrentGetattro(PyObject *, PyObject *);\nstatic int CurrentSetattro(PyObject *, PyObject *, PyObject *);\nstatic PyObject *DictionaryGetattro(PyObject *, PyObject *);\nstatic int DictionarySetattro(PyObject *, PyObject *, PyObject *);\nstatic PyObject *ListGetattro(PyObject *, PyObject *);\nstatic int ListSetattro(PyObject *, PyObject *, PyObject *);\nstatic PyObject *FunctionGetattro(PyObject *, PyObject *);\n\nstatic PyObject *VimPathHook(PyObject *, PyObject *);\n\nstatic struct PyModuleDef vimmodule;\n\n#define PY_CAN_RECURSE\n\n/*\n * Include the code shared with if_python.c\n */\n#include \"if_py_both.h\"\n\n#define GET_ATTR_STRING(name, nameobj) \\\n    char\t*name = \"\"; \\\n    if (PyUnicode_Check(nameobj)) \\\n\tname = _PyUnicode_AsString(nameobj)\n\n#define PY3OBJ_DELETED(obj) (obj->ob_base.ob_refcnt<=0)\n\n/******************************************************\n * Internal function prototypes.\n */\n\nstatic PyObject *Py3Init_vim(void);\n\n/******************************************************\n * 1. Python interpreter main program.\n */\n\n    void\npython3_end(void)\n{\n    static int recurse = 0;\n\n    /* If a crash occurs while doing this, don't try again. */\n    if (recurse != 0)\n\treturn;\n\n    ++recurse;\n\n#ifdef DYNAMIC_PYTHON3\n    if (hinstPy3)\n#endif\n    if (Py_IsInitialized())\n    {\n\t// acquire lock before finalizing\n\tPyGILState_Ensure();\n\n\tPy_Finalize();\n    }\n\n#ifdef DYNAMIC_PYTHON3\n    end_dynamic_python3();\n#endif\n\n    --recurse;\n}\n\n#if (defined(DYNAMIC_PYTHON3) && defined(DYNAMIC_PYTHON) && defined(FEAT_PYTHON) && defined(UNIX)) || defined(PROTO)\n    int\npython3_loaded(void)\n{\n    return (hinstPy3 != 0);\n}\n#endif\n\n    static int\nPython3_Init(void)\n{\n    if (!py3initialised)\n    {\n#ifdef DYNAMIC_PYTHON3\n\tif (!python3_enabled(TRUE))\n\t{\n\t    EMSG(_(\"E263: Sorry, this command is disabled, the Python library could not be loaded.\"));\n\t    goto fail;\n\t}\n#endif\n\n\tinit_structs();\n\n\n#ifdef PYTHON3_HOME\n# ifdef DYNAMIC_PYTHON3\n\tif (mch_getenv((char_u *)\"PYTHONHOME\") == NULL)\n# endif\n\t    Py_SetPythonHome(PYTHON3_HOME);\n#endif\n\n\tPyImport_AppendInittab(\"vim\", Py3Init_vim);\n\n#if !defined(MACOS) || defined(MACOS_X_UNIX)\n\tPy_Initialize();\n#else\n\tPyMac_Initialize();\n#endif\n\t/* Initialise threads, and below save the state using\n\t * PyEval_SaveThread.  Without the call to PyEval_SaveThread, thread\n\t * specific state (such as the system trace hook), will be lost\n\t * between invocations of Python code. */\n\tPyEval_InitThreads();\n#ifdef DYNAMIC_PYTHON3\n\tget_py3_exceptions();\n#endif\n\n\tif (PythonIO_Init_io())\n\t    goto fail;\n\n\tglobals = PyModule_GetDict(PyImport_AddModule(\"__main__\"));\n\n\t/* Remove the element from sys.path that was added because of our\n\t * argv[0] value in Py3Init_vim().  Previously we used an empty\n\t * string, but depending on the OS we then get an empty entry or\n\t * the current directory in sys.path.\n\t * Only after vim has been imported, the element does exist in\n\t * sys.path.\n\t */\n\tPyRun_SimpleString(\"import vim; import sys; sys.path = list(filter(lambda x: not x.endswith('must>not&exist'), sys.path))\");\n\n\t/* lock is created and acquired in PyEval_InitThreads() and thread\n\t * state is created in Py_Initialize()\n\t * there _PyGILState_NoteThreadState() also sets gilcounter to 1\n\t * (python must have threads enabled!)\n\t * so the following does both: unlock GIL and save thread state in TLS\n\t * without deleting thread state\n\t */\n\tPyEval_SaveThread();\n\n\tpy3initialised = 1;\n    }\n\n    return 0;\n\nfail:\n    /* We call PythonIO_Flush() here to print any Python errors.\n     * This is OK, as it is possible to call this function even\n     * if PythonIO_Init_io() has not completed successfully (it will\n     * not do anything in this case).\n     */\n    PythonIO_Flush();\n    return -1;\n}\n\n/*\n * External interface\n */\n    static void\nDoPyCommand(const char *cmd, rangeinitializer init_range, runner run, void *arg)\n{\n#if defined(MACOS) && !defined(MACOS_X_UNIX)\n    GrafPtr\t\toldPort;\n#endif\n#if defined(HAVE_LOCALE_H) || defined(X_LOCALE)\n    char\t\t*saved_locale;\n#endif\n    PyObject\t\t*cmdstr;\n    PyObject\t\t*cmdbytes;\n    PyGILState_STATE\tpygilstate;\n\n#if defined(MACOS) && !defined(MACOS_X_UNIX)\n    GetPort(&oldPort);\n    /* Check if the Python library is available */\n    if ((Ptr)PyMac_Initialize == (Ptr)kUnresolvedCFragSymbolAddress)\n\tgoto theend;\n#endif\n    if (Python3_Init())\n\tgoto theend;\n\n    init_range(arg);\n\n    Python_Release_Vim();\t    /* leave vim */\n\n#if defined(HAVE_LOCALE_H) || defined(X_LOCALE)\n    /* Python only works properly when the LC_NUMERIC locale is \"C\". */\n    saved_locale = setlocale(LC_NUMERIC, NULL);\n    if (saved_locale == NULL || STRCMP(saved_locale, \"C\") == 0)\n\tsaved_locale = NULL;\n    else\n    {\n\t/* Need to make a copy, value may change when setting new locale. */\n\tsaved_locale = (char *)vim_strsave((char_u *)saved_locale);\n\t(void)setlocale(LC_NUMERIC, \"C\");\n    }\n#endif\n\n    pygilstate = PyGILState_Ensure();\n\n    /* PyRun_SimpleString expects a UTF-8 string. Wrong encoding may cause\n     * SyntaxError (unicode error). */\n    cmdstr = PyUnicode_Decode(cmd, strlen(cmd),\n\t\t\t\t\t(char *)ENC_OPT, CODEC_ERROR_HANDLER);\n    cmdbytes = PyUnicode_AsEncodedString(cmdstr, \"utf-8\", CODEC_ERROR_HANDLER);\n    Py_XDECREF(cmdstr);\n\n    run(PyBytes_AsString(cmdbytes), arg, &pygilstate);\n    Py_XDECREF(cmdbytes);\n\n    PyGILState_Release(pygilstate);\n\n#if defined(HAVE_LOCALE_H) || defined(X_LOCALE)\n    if (saved_locale != NULL)\n    {\n\t(void)setlocale(LC_NUMERIC, saved_locale);\n\tvim_free(saved_locale);\n    }\n#endif\n\n    Python_Lock_Vim();\t\t    /* enter vim */\n    PythonIO_Flush();\n#if defined(MACOS) && !defined(MACOS_X_UNIX)\n    SetPort(oldPort);\n#endif\n\ntheend:\n    return;\t    /* keeps lint happy */\n}\n\n/*\n * \":py3\"\n */\n    void\nex_py3(exarg_T *eap)\n{\n    char_u *script;\n\n    if (p_pyx == 0)\n\tp_pyx = 3;\n\n    script = script_get(eap, eap->arg);\n    if (!eap->skip)\n    {\n\tDoPyCommand(script == NULL ? (char *) eap->arg : (char *) script,\n\t\t(rangeinitializer) init_range_cmd,\n\t\t(runner) run_cmd,\n\t\t(void *) eap);\n    }\n    vim_free(script);\n}\n\n#define BUFFER_SIZE 2048\n\n/*\n * \":py3file\"\n */\n    void\nex_py3file(exarg_T *eap)\n{\n    static char buffer[BUFFER_SIZE];\n    const char *file;\n    char *p;\n    int i;\n\n    if (p_pyx == 0)\n\tp_pyx = 3;\n\n    /* Have to do it like this. PyRun_SimpleFile requires you to pass a\n     * stdio file pointer, but Vim and the Python DLL are compiled with\n     * different options under Windows, meaning that stdio pointers aren't\n     * compatible between the two. Yuk.\n     *\n     * construct: exec(compile(open('a_filename', 'rb').read(), 'a_filename', 'exec'))\n     *\n     * Using bytes so that Python can detect the source encoding as it normally\n     * does. The doc does not say \"compile\" accept bytes, though.\n     *\n     * We need to escape any backslashes or single quotes in the file name, so that\n     * Python won't mangle the file name.\n     */\n\n    strcpy(buffer, \"exec(compile(open('\");\n    p = buffer + 19; /* size of \"exec(compile(open('\" */\n\n    for (i=0; i<2; ++i)\n    {\n\tfile = (char *)eap->arg;\n\twhile (*file && p < buffer + (BUFFER_SIZE - 3))\n\t{\n\t    if (*file == '\\\\' || *file == '\\'')\n\t\t*p++ = '\\\\';\n\t    *p++ = *file++;\n\t}\n\t/* If we didn't finish the file name, we hit a buffer overflow */\n\tif (*file != '\\0')\n\t    return;\n\tif (i==0)\n\t{\n\t    strcpy(p,\"','rb').read(),'\");\n\t    p += 16;\n\t}\n\telse\n\t{\n\t    strcpy(p,\"','exec'))\");\n\t    p += 10;\n\t}\n    }\n\n\n    /* Execute the file */\n    DoPyCommand(buffer,\n\t    (rangeinitializer) init_range_cmd,\n\t    (runner) run_cmd,\n\t    (void *) eap);\n}\n\n    void\nex_py3do(exarg_T *eap)\n{\n    if (p_pyx == 0)\n\tp_pyx = 3;\n\n    DoPyCommand((char *)eap->arg,\n\t    (rangeinitializer)init_range_cmd,\n\t    (runner)run_do,\n\t    (void *)eap);\n}\n\n/******************************************************\n * 2. Python output stream: writes output via [e]msg().\n */\n\n/* Implementation functions\n */\n\n    static PyObject *\nOutputGetattro(PyObject *self, PyObject *nameobj)\n{\n    GET_ATTR_STRING(name, nameobj);\n\n    if (strcmp(name, \"softspace\") == 0)\n\treturn PyLong_FromLong(((OutputObject *)(self))->softspace);\n    else if (strcmp(name, \"errors\") == 0)\n\treturn PyString_FromString(\"strict\");\n    else if (strcmp(name, \"encoding\") == 0)\n\treturn PyString_FromString(ENC_OPT);\n\n    return PyObject_GenericGetAttr(self, nameobj);\n}\n\n    static int\nOutputSetattro(PyObject *self, PyObject *nameobj, PyObject *val)\n{\n    GET_ATTR_STRING(name, nameobj);\n\n    return OutputSetattr((OutputObject *)(self), name, val);\n}\n\n/******************************************************\n * 3. Implementation of the Vim module for Python\n */\n\n/* Window type - Implementation functions\n * --------------------------------------\n */\n\n#define WindowType_Check(obj) ((obj)->ob_base.ob_type == &WindowType)\n\n/* Buffer type - Implementation functions\n * --------------------------------------\n */\n\n#define BufferType_Check(obj) ((obj)->ob_base.ob_type == &BufferType)\n\nstatic PyObject* BufferSubscript(PyObject *self, PyObject *idx);\nstatic Py_ssize_t BufferAsSubscript(PyObject *self, PyObject *idx, PyObject *val);\n\n/* Line range type - Implementation functions\n * --------------------------------------\n */\n\n#define RangeType_Check(obj) ((obj)->ob_base.ob_type == &RangeType)\n\nstatic PyObject* RangeSubscript(PyObject *self, PyObject *idx);\nstatic Py_ssize_t RangeAsItem(PyObject *, Py_ssize_t, PyObject *);\nstatic Py_ssize_t RangeAsSubscript(PyObject *self, PyObject *idx, PyObject *val);\n\n/* Current objects type - Implementation functions\n * -----------------------------------------------\n */\n\nstatic PySequenceMethods BufferAsSeq = {\n    (lenfunc)\t\tBufferLength,\t    /* sq_length,    len(x)   */\n    (binaryfunc)\t0,\t\t    /* sq_concat,    x+y      */\n    (ssizeargfunc)\t0,\t\t    /* sq_repeat,    x*n      */\n    (ssizeargfunc)\tBufferItem,\t    /* sq_item,      x[i]     */\n    0,\t\t\t\t\t    /* was_sq_slice,\t x[i:j]   */\n    0,\t\t\t\t\t    /* sq_ass_item,  x[i]=v   */\n    0,\t\t\t\t\t    /* sq_ass_slice, x[i:j]=v */\n    0,\t\t\t\t\t    /* sq_contains */\n    0,\t\t\t\t\t    /* sq_inplace_concat */\n    0,\t\t\t\t\t    /* sq_inplace_repeat */\n};\n\nstatic PyMappingMethods BufferAsMapping = {\n    /* mp_length\t*/ (lenfunc)BufferLength,\n    /* mp_subscript     */ (binaryfunc)BufferSubscript,\n    /* mp_ass_subscript */ (objobjargproc)BufferAsSubscript,\n};\n\n\n/* Buffer object\n */\n\n    static PyObject *\nBufferGetattro(PyObject *self, PyObject *nameobj)\n{\n    PyObject *r;\n\n    GET_ATTR_STRING(name, nameobj);\n\n    if ((r = BufferAttrValid((BufferObject *)(self), name)))\n\treturn r;\n\n    if (CheckBuffer((BufferObject *)(self)))\n\treturn NULL;\n\n    r = BufferAttr((BufferObject *)(self), name);\n    if (r || PyErr_Occurred())\n\treturn r;\n    else\n\treturn PyObject_GenericGetAttr(self, nameobj);\n}\n\n    static int\nBufferSetattro(PyObject *self, PyObject *nameobj, PyObject *val)\n{\n    GET_ATTR_STRING(name, nameobj);\n\n    return BufferSetattr((BufferObject *)(self), name, val);\n}\n\n/******************/\n\n    static PyObject *\nBufferSubscript(PyObject *self, PyObject* idx)\n{\n    if (PyLong_Check(idx))\n    {\n\tlong _idx = PyLong_AsLong(idx);\n\treturn BufferItem((BufferObject *)(self), _idx);\n    } else if (PySlice_Check(idx))\n    {\n\tPy_ssize_t start, stop, step, slicelen;\n\n\tif (CheckBuffer((BufferObject *) self))\n\t    return NULL;\n\n\tif (PySlice_GetIndicesEx((PySliceObject_T *)idx,\n\t      (Py_ssize_t)((BufferObject *)(self))->buf->b_ml.ml_line_count,\n\t      &start, &stop,\n\t      &step, &slicelen) < 0)\n\t{\n\t    return NULL;\n\t}\n\treturn BufferSlice((BufferObject *)(self), start, stop);\n    }\n    else\n    {\n\tRAISE_INVALID_INDEX_TYPE(idx);\n\treturn NULL;\n    }\n}\n\n    static Py_ssize_t\nBufferAsSubscript(PyObject *self, PyObject* idx, PyObject* val)\n{\n    if (PyLong_Check(idx))\n    {\n\tlong n = PyLong_AsLong(idx);\n\treturn RBAsItem((BufferObject *)(self), n, val, 1,\n\t\t    (Py_ssize_t)((BufferObject *)(self))->buf->b_ml.ml_line_count,\n\t\t    NULL);\n    } else if (PySlice_Check(idx))\n    {\n\tPy_ssize_t start, stop, step, slicelen;\n\n\tif (CheckBuffer((BufferObject *) self))\n\t    return -1;\n\n\tif (PySlice_GetIndicesEx((PySliceObject_T *)idx,\n\t      (Py_ssize_t)((BufferObject *)(self))->buf->b_ml.ml_line_count,\n\t      &start, &stop,\n\t      &step, &slicelen) < 0)\n\t{\n\t    return -1;\n\t}\n\treturn RBAsSlice((BufferObject *)(self), start, stop, val, 1,\n\t\t\t  (PyInt)((BufferObject *)(self))->buf->b_ml.ml_line_count,\n\t\t\t  NULL);\n    }\n    else\n    {\n\tRAISE_INVALID_INDEX_TYPE(idx);\n\treturn -1;\n    }\n}\n\nstatic PySequenceMethods RangeAsSeq = {\n    (lenfunc)\t\tRangeLength,\t /* sq_length,\t  len(x)   */\n    (binaryfunc)\t0,\t\t /* RangeConcat, sq_concat,  x+y   */\n    (ssizeargfunc)\t0,\t\t /* RangeRepeat, sq_repeat,  x*n   */\n    (ssizeargfunc)\tRangeItem,\t /* sq_item,\t  x[i]\t   */\n    0,\t\t\t\t\t /* was_sq_slice,     x[i:j]   */\n    (ssizeobjargproc)\tRangeAsItem,\t /* sq_as_item,  x[i]=v   */\n    0,\t\t\t\t\t /* sq_ass_slice, x[i:j]=v */\n    0,\t\t\t\t\t /* sq_contains */\n    0,\t\t\t\t\t /* sq_inplace_concat */\n    0,\t\t\t\t\t /* sq_inplace_repeat */\n};\n\nstatic PyMappingMethods RangeAsMapping = {\n    /* mp_length\t*/ (lenfunc)RangeLength,\n    /* mp_subscript     */ (binaryfunc)RangeSubscript,\n    /* mp_ass_subscript */ (objobjargproc)RangeAsSubscript,\n};\n\n/* Line range object - Implementation\n */\n\n    static PyObject *\nRangeGetattro(PyObject *self, PyObject *nameobj)\n{\n    GET_ATTR_STRING(name, nameobj);\n\n    if (strcmp(name, \"start\") == 0)\n\treturn Py_BuildValue(\"n\", ((RangeObject *)(self))->start - 1);\n    else if (strcmp(name, \"end\") == 0)\n\treturn Py_BuildValue(\"n\", ((RangeObject *)(self))->end - 1);\n    else\n\treturn PyObject_GenericGetAttr(self, nameobj);\n}\n\n/****************/\n\n    static Py_ssize_t\nRangeAsItem(PyObject *self, Py_ssize_t n, PyObject *val)\n{\n    return RBAsItem(((RangeObject *)(self))->buf, n, val,\n\t\t    ((RangeObject *)(self))->start,\n\t\t    ((RangeObject *)(self))->end,\n\t\t    &((RangeObject *)(self))->end);\n}\n\n    static Py_ssize_t\nRangeAsSlice(PyObject *self, Py_ssize_t lo, Py_ssize_t hi, PyObject *val)\n{\n    return RBAsSlice(((RangeObject *)(self))->buf, lo, hi, val,\n\t\t    ((RangeObject *)(self))->start,\n\t\t    ((RangeObject *)(self))->end,\n\t\t    &((RangeObject *)(self))->end);\n}\n\n    static PyObject *\nRangeSubscript(PyObject *self, PyObject* idx)\n{\n    if (PyLong_Check(idx))\n    {\n\tlong _idx = PyLong_AsLong(idx);\n\treturn RangeItem((RangeObject *)(self), _idx);\n    } else if (PySlice_Check(idx))\n    {\n\tPy_ssize_t start, stop, step, slicelen;\n\n\tif (PySlice_GetIndicesEx((PySliceObject_T *)idx,\n\t\t((RangeObject *)(self))->end-((RangeObject *)(self))->start+1,\n\t\t&start, &stop,\n\t\t&step, &slicelen) < 0)\n\t{\n\t    return NULL;\n\t}\n\treturn RangeSlice((RangeObject *)(self), start, stop);\n    }\n    else\n    {\n\tRAISE_INVALID_INDEX_TYPE(idx);\n\treturn NULL;\n    }\n}\n\n    static Py_ssize_t\nRangeAsSubscript(PyObject *self, PyObject *idx, PyObject *val)\n{\n    if (PyLong_Check(idx))\n    {\n\tlong n = PyLong_AsLong(idx);\n\treturn RangeAsItem(self, n, val);\n    } else if (PySlice_Check(idx))\n    {\n\tPy_ssize_t start, stop, step, slicelen;\n\n\tif (PySlice_GetIndicesEx((PySliceObject_T *)idx,\n\t\t((RangeObject *)(self))->end-((RangeObject *)(self))->start+1,\n\t\t&start, &stop,\n\t\t&step, &slicelen) < 0)\n\t{\n\t    return -1;\n\t}\n\treturn RangeAsSlice(self, start, stop, val);\n    }\n    else\n    {\n\tRAISE_INVALID_INDEX_TYPE(idx);\n\treturn -1;\n    }\n}\n\n/* TabPage object - Implementation\n */\n\n    static PyObject *\nTabPageGetattro(PyObject *self, PyObject *nameobj)\n{\n    PyObject *r;\n\n    GET_ATTR_STRING(name, nameobj);\n\n    if ((r = TabPageAttrValid((TabPageObject *)(self), name)))\n\treturn r;\n\n    if (CheckTabPage((TabPageObject *)(self)))\n\treturn NULL;\n\n    r = TabPageAttr((TabPageObject *)(self), name);\n    if (r || PyErr_Occurred())\n\treturn r;\n    else\n\treturn PyObject_GenericGetAttr(self, nameobj);\n}\n\n/* Window object - Implementation\n */\n\n    static PyObject *\nWindowGetattro(PyObject *self, PyObject *nameobj)\n{\n    PyObject *r;\n\n    GET_ATTR_STRING(name, nameobj);\n\n    if ((r = WindowAttrValid((WindowObject *)(self), name)))\n\treturn r;\n\n    if (CheckWindow((WindowObject *)(self)))\n\treturn NULL;\n\n    r = WindowAttr((WindowObject *)(self), name);\n    if (r || PyErr_Occurred())\n\treturn r;\n    else\n\treturn PyObject_GenericGetAttr(self, nameobj);\n}\n\n    static int\nWindowSetattro(PyObject *self, PyObject *nameobj, PyObject *val)\n{\n    GET_ATTR_STRING(name, nameobj);\n\n    return WindowSetattr((WindowObject *)(self), name, val);\n}\n\n/* Tab page list object - Definitions\n */\n\nstatic PySequenceMethods TabListAsSeq = {\n    (lenfunc)\t     TabListLength,\t    /* sq_length,    len(x)   */\n    (binaryfunc)     0,\t\t\t    /* sq_concat,    x+y      */\n    (ssizeargfunc)   0,\t\t\t    /* sq_repeat,    x*n      */\n    (ssizeargfunc)   TabListItem,\t    /* sq_item,      x[i]     */\n    0,\t\t\t\t\t    /* sq_slice,     x[i:j]   */\n    (ssizeobjargproc)0,\t\t\t    /* sq_as_item,  x[i]=v   */\n    0,\t\t\t\t\t    /* sq_ass_slice, x[i:j]=v */\n    0,\t\t\t\t\t    /* sq_contains */\n    0,\t\t\t\t\t    /* sq_inplace_concat */\n    0,\t\t\t\t\t    /* sq_inplace_repeat */\n};\n\n/* Window list object - Definitions\n */\n\nstatic PySequenceMethods WinListAsSeq = {\n    (lenfunc)\t     WinListLength,\t    /* sq_length,    len(x)   */\n    (binaryfunc)     0,\t\t\t    /* sq_concat,    x+y      */\n    (ssizeargfunc)   0,\t\t\t    /* sq_repeat,    x*n      */\n    (ssizeargfunc)   WinListItem,\t    /* sq_item,      x[i]     */\n    0,\t\t\t\t\t    /* sq_slice,     x[i:j]   */\n    (ssizeobjargproc)0,\t\t\t    /* sq_as_item,  x[i]=v   */\n    0,\t\t\t\t\t    /* sq_ass_slice, x[i:j]=v */\n    0,\t\t\t\t\t    /* sq_contains */\n    0,\t\t\t\t\t    /* sq_inplace_concat */\n    0,\t\t\t\t\t    /* sq_inplace_repeat */\n};\n\n/* Current items object - Implementation\n */\n    static PyObject *\nCurrentGetattro(PyObject *self, PyObject *nameobj)\n{\n    PyObject\t*r;\n    GET_ATTR_STRING(name, nameobj);\n    if (!(r = CurrentGetattr(self, name)))\n\treturn PyObject_GenericGetAttr(self, nameobj);\n    return r;\n}\n\n    static int\nCurrentSetattro(PyObject *self, PyObject *nameobj, PyObject *value)\n{\n    GET_ATTR_STRING(name, nameobj);\n    return CurrentSetattr(self, name, value);\n}\n\n/* Dictionary object - Definitions\n */\n\n    static PyObject *\nDictionaryGetattro(PyObject *self, PyObject *nameobj)\n{\n    DictionaryObject\t*this = ((DictionaryObject *) (self));\n\n    GET_ATTR_STRING(name, nameobj);\n\n    if (strcmp(name, \"locked\") == 0)\n\treturn PyLong_FromLong(this->dict->dv_lock);\n    else if (strcmp(name, \"scope\") == 0)\n\treturn PyLong_FromLong(this->dict->dv_scope);\n\n    return PyObject_GenericGetAttr(self, nameobj);\n}\n\n    static int\nDictionarySetattro(PyObject *self, PyObject *nameobj, PyObject *val)\n{\n    GET_ATTR_STRING(name, nameobj);\n    return DictionarySetattr((DictionaryObject *)(self), name, val);\n}\n\n/* List object - Definitions\n */\n\n    static PyObject *\nListGetattro(PyObject *self, PyObject *nameobj)\n{\n    GET_ATTR_STRING(name, nameobj);\n\n    if (strcmp(name, \"locked\") == 0)\n\treturn PyLong_FromLong(((ListObject *) (self))->list->lv_lock);\n\n    return PyObject_GenericGetAttr(self, nameobj);\n}\n\n    static int\nListSetattro(PyObject *self, PyObject *nameobj, PyObject *val)\n{\n    GET_ATTR_STRING(name, nameobj);\n    return ListSetattr((ListObject *)(self), name, val);\n}\n\n/* Function object - Definitions\n */\n\n    static PyObject *\nFunctionGetattro(PyObject *self, PyObject *nameobj)\n{\n    PyObject\t\t*r;\n    FunctionObject\t*this = (FunctionObject *)(self);\n\n    GET_ATTR_STRING(name, nameobj);\n\n    r = FunctionAttr(this, name);\n    if (r || PyErr_Occurred())\n\treturn r;\n    else\n\treturn PyObject_GenericGetAttr(self, nameobj);\n}\n\n/* External interface\n */\n\n    void\npython3_buffer_free(buf_T *buf)\n{\n    if (BUF_PYTHON_REF(buf) != NULL)\n    {\n\tBufferObject *bp = BUF_PYTHON_REF(buf);\n\tbp->buf = INVALID_BUFFER_VALUE;\n\tBUF_PYTHON_REF(buf) = NULL;\n    }\n}\n\n#if defined(FEAT_WINDOWS) || defined(PROTO)\n    void\npython3_window_free(win_T *win)\n{\n    if (WIN_PYTHON_REF(win) != NULL)\n    {\n\tWindowObject *wp = WIN_PYTHON_REF(win);\n\twp->win = INVALID_WINDOW_VALUE;\n\tWIN_PYTHON_REF(win) = NULL;\n    }\n}\n\n    void\npython3_tabpage_free(tabpage_T *tab)\n{\n    if (TAB_PYTHON_REF(tab) != NULL)\n    {\n\tTabPageObject *tp = TAB_PYTHON_REF(tab);\n\ttp->tab = INVALID_TABPAGE_VALUE;\n\tTAB_PYTHON_REF(tab) = NULL;\n    }\n}\n#endif\n\n    static PyObject *\nPy3Init_vim(void)\n{\n    /* The special value is removed from sys.path in Python3_Init(). */\n    static wchar_t *(argv[2]) = {L\"/must>not&exist/foo\", NULL};\n\n    if (init_types())\n\treturn NULL;\n\n    /* Set sys.argv[] to avoid a crash in warn(). */\n    PySys_SetArgv(1, argv);\n\n    if ((vim_module = PyModule_Create(&vimmodule)) == NULL)\n\treturn NULL;\n\n    if (populate_module(vim_module))\n\treturn NULL;\n\n    if (init_sys_path())\n\treturn NULL;\n\n    return vim_module;\n}\n\n/*************************************************************************\n * 4. Utility functions for handling the interface between Vim and Python.\n */\n\n/* Convert a Vim line into a Python string.\n * All internal newlines are replaced by null characters.\n *\n * On errors, the Python exception data is set, and NULL is returned.\n */\n    static PyObject *\nLineToString(const char *str)\n{\n    PyObject *result;\n    Py_ssize_t len = strlen(str);\n    char *tmp,*p;\n\n    tmp = (char *)alloc((unsigned)(len+1));\n    p = tmp;\n    if (p == NULL)\n    {\n\tPyErr_NoMemory();\n\treturn NULL;\n    }\n\n    while (*str)\n    {\n\tif (*str == '\\n')\n\t    *p = '\\0';\n\telse\n\t    *p = *str;\n\n\t++p;\n\t++str;\n    }\n    *p = '\\0';\n\n    result = PyUnicode_Decode(tmp, len, (char *)ENC_OPT, CODEC_ERROR_HANDLER);\n\n    vim_free(tmp);\n    return result;\n}\n\n    void\ndo_py3eval (char_u *str, typval_T *rettv)\n{\n    DoPyCommand((char *) str,\n\t    (rangeinitializer) init_range_eval,\n\t    (runner) run_eval,\n\t    (void *) rettv);\n    switch(rettv->v_type)\n    {\n\tcase VAR_DICT: ++rettv->vval.v_dict->dv_refcount; break;\n\tcase VAR_LIST: ++rettv->vval.v_list->lv_refcount; break;\n\tcase VAR_FUNC: func_ref(rettv->vval.v_string);    break;\n\tcase VAR_PARTIAL: ++rettv->vval.v_partial->pt_refcount; break;\n\tcase VAR_UNKNOWN:\n\t    rettv->v_type = VAR_NUMBER;\n\t    rettv->vval.v_number = 0;\n\t    break;\n\tcase VAR_NUMBER:\n\tcase VAR_STRING:\n\tcase VAR_FLOAT:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\t    break;\n    }\n}\n\n    int\nset_ref_in_python3 (int copyID)\n{\n    return set_ref_in_py(copyID);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/if_lua.c": "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Lua interface by Luis Carvalho\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n#include <lua.h>\n#include <lualib.h>\n#include <lauxlib.h>\n\n/* Only do the following when the feature is enabled.  Needed for \"make\n * depend\". */\n#if defined(FEAT_LUA) || defined(PROTO)\n\n#define LUAVIM_CHUNKNAME \"vim chunk\"\n#define LUAVIM_NAME \"vim\"\n#define LUAVIM_EVALNAME \"luaeval\"\n#define LUAVIM_EVALHEADER \"local _A=select(1,...) return \"\n\ntypedef buf_T *luaV_Buffer;\ntypedef win_T *luaV_Window;\ntypedef dict_T *luaV_Dict;\ntypedef list_T *luaV_List;\ntypedef void (*msgfunc_T)(char_u *);\n\nstatic const char LUAVIM_DICT[] = \"dict\";\nstatic const char LUAVIM_LIST[] = \"list\";\nstatic const char LUAVIM_BUFFER[] = \"buffer\";\nstatic const char LUAVIM_WINDOW[] = \"window\";\nstatic const char LUAVIM_FREE[] = \"luaV_free\";\nstatic const char LUAVIM_LUAEVAL[] = \"luaV_luaeval\";\nstatic const char LUAVIM_SETREF[] = \"luaV_setref\";\n\n/* most functions are closures with a cache table as first upvalue;\n * get/setudata manage references to vim userdata in cache table through\n * object pointers (light userdata) */\n#define luaV_getudata(L, v) \\\n    lua_pushlightuserdata((L), (void *) (v)); \\\n    lua_rawget((L), lua_upvalueindex(1))\n#define luaV_setudata(L, v) \\\n    lua_pushlightuserdata((L), (void *) (v)); \\\n    lua_pushvalue((L), -2); \\\n    lua_rawset((L), lua_upvalueindex(1))\n#define luaV_getfield(L, s) \\\n    lua_pushlightuserdata((L), (void *)(s)); \\\n    lua_rawget((L), LUA_REGISTRYINDEX)\n#define luaV_checksandbox(L) \\\n    if (sandbox) luaL_error((L), \"not allowed in sandbox\")\n#define luaV_msg(L) luaV_msgfunc((L), (msgfunc_T) msg)\n#define luaV_emsg(L) luaV_msgfunc((L), (msgfunc_T) emsg)\n\nstatic luaV_List *luaV_pushlist (lua_State *L, list_T *lis);\nstatic luaV_Dict *luaV_pushdict (lua_State *L, dict_T *dic);\n\n#if LUA_VERSION_NUM <= 501\n#define luaV_openlib(L, l, n) luaL_openlib(L, NULL, l, n)\n#define luaL_typeerror luaL_typerror\n#else\n#define luaV_openlib luaL_setfuncs\n#endif\n\n#ifdef DYNAMIC_LUA\n\n#ifndef WIN3264\n# include <dlfcn.h>\n# define HANDLE void*\n# define load_dll(n) dlopen((n), RTLD_LAZY|RTLD_GLOBAL)\n# define symbol_from_dll dlsym\n# define close_dll dlclose\n#else\n# define load_dll vimLoadLib\n# define symbol_from_dll GetProcAddress\n# define close_dll FreeLibrary\n#endif\n\n/* lauxlib */\n#if LUA_VERSION_NUM <= 501\n#define luaL_register dll_luaL_register\n#define luaL_prepbuffer dll_luaL_prepbuffer\n#define luaL_openlib dll_luaL_openlib\n#define luaL_typerror dll_luaL_typerror\n#define luaL_loadfile dll_luaL_loadfile\n#define luaL_loadbuffer dll_luaL_loadbuffer\n#else\n#define luaL_prepbuffsize dll_luaL_prepbuffsize\n#define luaL_setfuncs dll_luaL_setfuncs\n#define luaL_loadfilex dll_luaL_loadfilex\n#define luaL_loadbufferx dll_luaL_loadbufferx\n#define luaL_argerror dll_luaL_argerror\n#endif\n#define luaL_checkany dll_luaL_checkany\n#define luaL_checklstring dll_luaL_checklstring\n#define luaL_checkinteger dll_luaL_checkinteger\n#define luaL_optinteger dll_luaL_optinteger\n#define luaL_checktype dll_luaL_checktype\n#define luaL_error dll_luaL_error\n#define luaL_newstate dll_luaL_newstate\n#define luaL_buffinit dll_luaL_buffinit\n#define luaL_addlstring dll_luaL_addlstring\n#define luaL_pushresult dll_luaL_pushresult\n/* lua */\n#if LUA_VERSION_NUM <= 501\n#define lua_tonumber dll_lua_tonumber\n#define lua_tointeger dll_lua_tointeger\n#define lua_call dll_lua_call\n#define lua_pcall dll_lua_pcall\n#else\n#define lua_tonumberx dll_lua_tonumberx\n#define lua_tointegerx dll_lua_tointegerx\n#define lua_callk dll_lua_callk\n#define lua_pcallk dll_lua_pcallk\n#define lua_getglobal dll_lua_getglobal\n#define lua_setglobal dll_lua_setglobal\n#endif\n#if LUA_VERSION_NUM <= 502\n#define lua_replace dll_lua_replace\n#define lua_remove dll_lua_remove\n#endif\n#if LUA_VERSION_NUM >= 503\n#define lua_rotate dll_lua_rotate\n#define lua_copy dll_lua_copy\n#endif\n#define lua_typename dll_lua_typename\n#define lua_close dll_lua_close\n#define lua_gettop dll_lua_gettop\n#define lua_settop dll_lua_settop\n#define lua_pushvalue dll_lua_pushvalue\n#define lua_isnumber dll_lua_isnumber\n#define lua_isstring dll_lua_isstring\n#define lua_type dll_lua_type\n#define lua_rawequal dll_lua_rawequal\n#define lua_toboolean dll_lua_toboolean\n#define lua_tolstring dll_lua_tolstring\n#define lua_touserdata dll_lua_touserdata\n#define lua_pushnil dll_lua_pushnil\n#define lua_pushnumber dll_lua_pushnumber\n#define lua_pushinteger dll_lua_pushinteger\n#define lua_pushlstring dll_lua_pushlstring\n#define lua_pushstring dll_lua_pushstring\n#define lua_pushfstring dll_lua_pushfstring\n#define lua_pushcclosure dll_lua_pushcclosure\n#define lua_pushboolean dll_lua_pushboolean\n#define lua_pushlightuserdata dll_lua_pushlightuserdata\n#define lua_getfield dll_lua_getfield\n#define lua_rawget dll_lua_rawget\n#define lua_rawgeti dll_lua_rawgeti\n#define lua_createtable dll_lua_createtable\n#define lua_newuserdata dll_lua_newuserdata\n#define lua_getmetatable dll_lua_getmetatable\n#define lua_setfield dll_lua_setfield\n#define lua_rawset dll_lua_rawset\n#define lua_rawseti dll_lua_rawseti\n#define lua_setmetatable dll_lua_setmetatable\n#define lua_next dll_lua_next\n/* libs */\n#define luaopen_base dll_luaopen_base\n#define luaopen_table dll_luaopen_table\n#define luaopen_string dll_luaopen_string\n#define luaopen_math dll_luaopen_math\n#define luaopen_io dll_luaopen_io\n#define luaopen_os dll_luaopen_os\n#define luaopen_package dll_luaopen_package\n#define luaopen_debug dll_luaopen_debug\n#define luaL_openlibs dll_luaL_openlibs\n\n/* lauxlib */\n#if LUA_VERSION_NUM <= 501\nvoid (*dll_luaL_register) (lua_State *L, const char *libname, const luaL_Reg *l);\nchar *(*dll_luaL_prepbuffer) (luaL_Buffer *B);\nvoid (*dll_luaL_openlib) (lua_State *L, const char *libname, const luaL_Reg *l, int nup);\nint (*dll_luaL_typerror) (lua_State *L, int narg, const char *tname);\nint (*dll_luaL_loadfile) (lua_State *L, const char *filename);\nint (*dll_luaL_loadbuffer) (lua_State *L, const char *buff, size_t sz, const char *name);\n#else\nchar *(*dll_luaL_prepbuffsize) (luaL_Buffer *B, size_t sz);\nvoid (*dll_luaL_setfuncs) (lua_State *L, const luaL_Reg *l, int nup);\nint (*dll_luaL_loadfilex) (lua_State *L, const char *filename, const char *mode);\nint (*dll_luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz, const char *name, const char *mode);\nint (*dll_luaL_argerror) (lua_State *L, int numarg, const char *extramsg);\n#endif\nvoid (*dll_luaL_checkany) (lua_State *L, int narg);\nconst char *(*dll_luaL_checklstring) (lua_State *L, int numArg, size_t *l);\nlua_Integer (*dll_luaL_checkinteger) (lua_State *L, int numArg);\nlua_Integer (*dll_luaL_optinteger) (lua_State *L, int nArg, lua_Integer def);\nvoid (*dll_luaL_checktype) (lua_State *L, int narg, int t);\nint (*dll_luaL_error) (lua_State *L, const char *fmt, ...);\nlua_State *(*dll_luaL_newstate) (void);\nvoid (*dll_luaL_buffinit) (lua_State *L, luaL_Buffer *B);\nvoid (*dll_luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);\nvoid (*dll_luaL_pushresult) (luaL_Buffer *B);\n/* lua */\n#if LUA_VERSION_NUM <= 501\nlua_Number (*dll_lua_tonumber) (lua_State *L, int idx);\nlua_Integer (*dll_lua_tointeger) (lua_State *L, int idx);\nvoid (*dll_lua_call) (lua_State *L, int nargs, int nresults);\nint (*dll_lua_pcall) (lua_State *L, int nargs, int nresults, int errfunc);\n#else\nlua_Number (*dll_lua_tonumberx) (lua_State *L, int idx, int *isnum);\nlua_Integer (*dll_lua_tointegerx) (lua_State *L, int idx, int *isnum);\nvoid (*dll_lua_callk) (lua_State *L, int nargs, int nresults, int ctx,\n\tlua_CFunction k);\nint (*dll_lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc,\n\tint ctx, lua_CFunction k);\nvoid (*dll_lua_getglobal) (lua_State *L, const char *var);\nvoid (*dll_lua_setglobal) (lua_State *L, const char *var);\n#endif\n#if LUA_VERSION_NUM <= 502\nvoid (*dll_lua_replace) (lua_State *L, int idx);\nvoid (*dll_lua_remove) (lua_State *L, int idx);\n#endif\n#if LUA_VERSION_NUM >= 503\nvoid  (*dll_lua_rotate) (lua_State *L, int idx, int n);\nvoid (*dll_lua_copy) (lua_State *L, int fromidx, int toidx);\n#endif\nconst char *(*dll_lua_typename) (lua_State *L, int tp);\nvoid       (*dll_lua_close) (lua_State *L);\nint (*dll_lua_gettop) (lua_State *L);\nvoid (*dll_lua_settop) (lua_State *L, int idx);\nvoid (*dll_lua_pushvalue) (lua_State *L, int idx);\nint (*dll_lua_isnumber) (lua_State *L, int idx);\nint (*dll_lua_isstring) (lua_State *L, int idx);\nint (*dll_lua_type) (lua_State *L, int idx);\nint (*dll_lua_rawequal) (lua_State *L, int idx1, int idx2);\nint (*dll_lua_toboolean) (lua_State *L, int idx);\nconst char *(*dll_lua_tolstring) (lua_State *L, int idx, size_t *len);\nvoid *(*dll_lua_touserdata) (lua_State *L, int idx);\nvoid (*dll_lua_pushnil) (lua_State *L);\nvoid (*dll_lua_pushnumber) (lua_State *L, lua_Number n);\nvoid (*dll_lua_pushinteger) (lua_State *L, lua_Integer n);\nvoid (*dll_lua_pushlstring) (lua_State *L, const char *s, size_t l);\nvoid (*dll_lua_pushstring) (lua_State *L, const char *s);\nconst char *(*dll_lua_pushfstring) (lua_State *L, const char *fmt, ...);\nvoid (*dll_lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);\nvoid (*dll_lua_pushboolean) (lua_State *L, int b);\nvoid (*dll_lua_pushlightuserdata) (lua_State *L, void *p);\nvoid (*dll_lua_getfield) (lua_State *L, int idx, const char *k);\nvoid (*dll_lua_rawget) (lua_State *L, int idx);\nvoid (*dll_lua_rawgeti) (lua_State *L, int idx, int n);\nvoid (*dll_lua_createtable) (lua_State *L, int narr, int nrec);\nvoid *(*dll_lua_newuserdata) (lua_State *L, size_t sz);\nint (*dll_lua_getmetatable) (lua_State *L, int objindex);\nvoid (*dll_lua_setfield) (lua_State *L, int idx, const char *k);\nvoid (*dll_lua_rawset) (lua_State *L, int idx);\nvoid (*dll_lua_rawseti) (lua_State *L, int idx, int n);\nint (*dll_lua_setmetatable) (lua_State *L, int objindex);\nint (*dll_lua_next) (lua_State *L, int idx);\n/* libs */\nint (*dll_luaopen_base) (lua_State *L);\nint (*dll_luaopen_table) (lua_State *L);\nint (*dll_luaopen_string) (lua_State *L);\nint (*dll_luaopen_math) (lua_State *L);\nint (*dll_luaopen_io) (lua_State *L);\nint (*dll_luaopen_os) (lua_State *L);\nint (*dll_luaopen_package) (lua_State *L);\nint (*dll_luaopen_debug) (lua_State *L);\nvoid (*dll_luaL_openlibs) (lua_State *L);\n\ntypedef void **luaV_function;\ntypedef struct {\n    const char *name;\n    luaV_function func;\n} luaV_Reg;\n\nstatic const luaV_Reg luaV_dll[] = {\n    /* lauxlib */\n#if LUA_VERSION_NUM <= 501\n    {\"luaL_register\", (luaV_function) &dll_luaL_register},\n    {\"luaL_prepbuffer\", (luaV_function) &dll_luaL_prepbuffer},\n    {\"luaL_openlib\", (luaV_function) &dll_luaL_openlib},\n    {\"luaL_typerror\", (luaV_function) &dll_luaL_typerror},\n    {\"luaL_loadfile\", (luaV_function) &dll_luaL_loadfile},\n    {\"luaL_loadbuffer\", (luaV_function) &dll_luaL_loadbuffer},\n#else\n    {\"luaL_prepbuffsize\", (luaV_function) &dll_luaL_prepbuffsize},\n    {\"luaL_setfuncs\", (luaV_function) &dll_luaL_setfuncs},\n    {\"luaL_loadfilex\", (luaV_function) &dll_luaL_loadfilex},\n    {\"luaL_loadbufferx\", (luaV_function) &dll_luaL_loadbufferx},\n    {\"luaL_argerror\", (luaV_function) &dll_luaL_argerror},\n#endif\n    {\"luaL_checkany\", (luaV_function) &dll_luaL_checkany},\n    {\"luaL_checklstring\", (luaV_function) &dll_luaL_checklstring},\n    {\"luaL_checkinteger\", (luaV_function) &dll_luaL_checkinteger},\n    {\"luaL_optinteger\", (luaV_function) &dll_luaL_optinteger},\n    {\"luaL_checktype\", (luaV_function) &dll_luaL_checktype},\n    {\"luaL_error\", (luaV_function) &dll_luaL_error},\n    {\"luaL_newstate\", (luaV_function) &dll_luaL_newstate},\n    {\"luaL_buffinit\", (luaV_function) &dll_luaL_buffinit},\n    {\"luaL_addlstring\", (luaV_function) &dll_luaL_addlstring},\n    {\"luaL_pushresult\", (luaV_function) &dll_luaL_pushresult},\n    /* lua */\n#if LUA_VERSION_NUM <= 501\n    {\"lua_tonumber\", (luaV_function) &dll_lua_tonumber},\n    {\"lua_tointeger\", (luaV_function) &dll_lua_tointeger},\n    {\"lua_call\", (luaV_function) &dll_lua_call},\n    {\"lua_pcall\", (luaV_function) &dll_lua_pcall},\n#else\n    {\"lua_tonumberx\", (luaV_function) &dll_lua_tonumberx},\n    {\"lua_tointegerx\", (luaV_function) &dll_lua_tointegerx},\n    {\"lua_callk\", (luaV_function) &dll_lua_callk},\n    {\"lua_pcallk\", (luaV_function) &dll_lua_pcallk},\n    {\"lua_getglobal\", (luaV_function) &dll_lua_getglobal},\n    {\"lua_setglobal\", (luaV_function) &dll_lua_setglobal},\n#endif\n#if LUA_VERSION_NUM <= 502\n    {\"lua_replace\", (luaV_function) &dll_lua_replace},\n    {\"lua_remove\", (luaV_function) &dll_lua_remove},\n#endif\n#if LUA_VERSION_NUM >= 503\n    {\"lua_rotate\", (luaV_function) &dll_lua_rotate},\n    {\"lua_copy\", (luaV_function) &dll_lua_copy},\n#endif\n    {\"lua_typename\", (luaV_function) &dll_lua_typename},\n    {\"lua_close\", (luaV_function) &dll_lua_close},\n    {\"lua_gettop\", (luaV_function) &dll_lua_gettop},\n    {\"lua_settop\", (luaV_function) &dll_lua_settop},\n    {\"lua_pushvalue\", (luaV_function) &dll_lua_pushvalue},\n    {\"lua_isnumber\", (luaV_function) &dll_lua_isnumber},\n    {\"lua_isstring\", (luaV_function) &dll_lua_isstring},\n    {\"lua_type\", (luaV_function) &dll_lua_type},\n    {\"lua_rawequal\", (luaV_function) &dll_lua_rawequal},\n    {\"lua_toboolean\", (luaV_function) &dll_lua_toboolean},\n    {\"lua_tolstring\", (luaV_function) &dll_lua_tolstring},\n    {\"lua_touserdata\", (luaV_function) &dll_lua_touserdata},\n    {\"lua_pushnil\", (luaV_function) &dll_lua_pushnil},\n    {\"lua_pushnumber\", (luaV_function) &dll_lua_pushnumber},\n    {\"lua_pushinteger\", (luaV_function) &dll_lua_pushinteger},\n    {\"lua_pushlstring\", (luaV_function) &dll_lua_pushlstring},\n    {\"lua_pushstring\", (luaV_function) &dll_lua_pushstring},\n    {\"lua_pushfstring\", (luaV_function) &dll_lua_pushfstring},\n    {\"lua_pushcclosure\", (luaV_function) &dll_lua_pushcclosure},\n    {\"lua_pushboolean\", (luaV_function) &dll_lua_pushboolean},\n    {\"lua_pushlightuserdata\", (luaV_function) &dll_lua_pushlightuserdata},\n    {\"lua_getfield\", (luaV_function) &dll_lua_getfield},\n    {\"lua_rawget\", (luaV_function) &dll_lua_rawget},\n    {\"lua_rawgeti\", (luaV_function) &dll_lua_rawgeti},\n    {\"lua_createtable\", (luaV_function) &dll_lua_createtable},\n    {\"lua_newuserdata\", (luaV_function) &dll_lua_newuserdata},\n    {\"lua_getmetatable\", (luaV_function) &dll_lua_getmetatable},\n    {\"lua_setfield\", (luaV_function) &dll_lua_setfield},\n    {\"lua_rawset\", (luaV_function) &dll_lua_rawset},\n    {\"lua_rawseti\", (luaV_function) &dll_lua_rawseti},\n    {\"lua_setmetatable\", (luaV_function) &dll_lua_setmetatable},\n    {\"lua_next\", (luaV_function) &dll_lua_next},\n    /* libs */\n    {\"luaopen_base\", (luaV_function) &dll_luaopen_base},\n    {\"luaopen_table\", (luaV_function) &dll_luaopen_table},\n    {\"luaopen_string\", (luaV_function) &dll_luaopen_string},\n    {\"luaopen_math\", (luaV_function) &dll_luaopen_math},\n    {\"luaopen_io\", (luaV_function) &dll_luaopen_io},\n    {\"luaopen_os\", (luaV_function) &dll_luaopen_os},\n    {\"luaopen_package\", (luaV_function) &dll_luaopen_package},\n    {\"luaopen_debug\", (luaV_function) &dll_luaopen_debug},\n    {\"luaL_openlibs\", (luaV_function) &dll_luaL_openlibs},\n    {NULL, NULL}\n};\n\nstatic HANDLE hinstLua = NULL;\n\n    static void\nend_dynamic_lua(void)\n{\n    if (hinstLua)\n    {\n\tclose_dll(hinstLua);\n\thinstLua = 0;\n    }\n}\n\n    static int\nlua_link_init(char *libname, int verbose)\n{\n    const luaV_Reg *reg;\n    if (hinstLua) return OK;\n    hinstLua = load_dll(libname);\n    if (!hinstLua)\n    {\n\tif (verbose)\n\t    EMSG2(_(e_loadlib), libname);\n\treturn FAIL;\n    }\n    for (reg = luaV_dll; reg->func; reg++)\n    {\n\tif ((*reg->func = symbol_from_dll(hinstLua, reg->name)) == NULL)\n\t{\n\t    close_dll(hinstLua);\n\t    hinstLua = 0;\n\t    if (verbose)\n\t\tEMSG2(_(e_loadfunc), reg->name);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n#endif /* DYNAMIC_LUA */\n\n#if defined(DYNAMIC_LUA) || defined(PROTO)\n    int\nlua_enabled(int verbose)\n{\n    return lua_link_init((char *)p_luadll, verbose) == OK;\n}\n#endif\n\n#if LUA_VERSION_NUM > 501\n    static int\nluaL_typeerror (lua_State *L, int narg, const char *tname)\n{\n    const char *msg = lua_pushfstring(L, \"%s expected, got %s\",\n\t    tname, luaL_typename(L, narg));\n    return luaL_argerror(L, narg, msg);\n}\n#endif\n\n\n/* =======   Internal   ======= */\n\n    static void\nluaV_newmetatable(lua_State *L, const char *tname)\n{\n    lua_newtable(L);\n    lua_pushlightuserdata(L, (void *) tname);\n    lua_pushvalue(L, -2);\n    lua_rawset(L, LUA_REGISTRYINDEX);\n}\n\n    static void *\nluaV_toudata(lua_State *L, int ud, const char *tname)\n{\n    void *p = lua_touserdata(L, ud);\n\n    if (p != NULL) /* value is userdata? */\n    {\n\tif (lua_getmetatable(L, ud)) /* does it have a metatable? */\n\t{\n\t    luaV_getfield(L, tname); /* get metatable */\n\t    if (lua_rawequal(L, -1, -2)) /* MTs match? */\n\t    {\n\t\tlua_pop(L, 2); /* MTs */\n\t\treturn p;\n\t    }\n\t}\n    }\n    return NULL;\n}\n\n    static void *\nluaV_checkcache(lua_State *L, void *p)\n{\n    luaV_getudata(L, p);\n    if (lua_isnil(L, -1)) luaL_error(L, \"invalid object\");\n    lua_pop(L, 1);\n    return p;\n}\n\n#define luaV_unbox(L,luatyp,ud) (*((luatyp *) lua_touserdata((L),(ud))))\n\n#define luaV_checkvalid(L,luatyp,ud) \\\n    luaV_checkcache((L), (void *) luaV_unbox((L),luatyp,(ud)))\n\n    static void *\nluaV_checkudata(lua_State *L, int ud, const char *tname)\n{\n    void *p = luaV_toudata(L, ud, tname);\n    if (p == NULL) luaL_typeerror(L, ud, tname);\n    return p;\n}\n\n    static void\nluaV_pushtypval(lua_State *L, typval_T *tv)\n{\n    if (tv == NULL)\n    {\n\tlua_pushnil(L);\n\treturn;\n    }\n    switch (tv->v_type)\n    {\n\tcase VAR_STRING:\n\t    lua_pushstring(L, tv->vval.v_string == NULL\n\t\t\t\t\t    ? \"\" : (char *)tv->vval.v_string);\n\t    break;\n\tcase VAR_NUMBER:\n\t    lua_pushinteger(L, (int) tv->vval.v_number);\n\t    break;\n#ifdef FEAT_FLOAT\n\tcase VAR_FLOAT:\n\t    lua_pushnumber(L, (lua_Number) tv->vval.v_float);\n\t    break;\n#endif\n\tcase VAR_LIST:\n\t    luaV_pushlist(L, tv->vval.v_list);\n\t    break;\n\tcase VAR_DICT:\n\t    luaV_pushdict(L, tv->vval.v_dict);\n\t    break;\n\tcase VAR_SPECIAL:\n\t    if (tv->vval.v_number <= VVAL_TRUE)\n\t\tlua_pushinteger(L, (int) tv->vval.v_number);\n\t    else\n\t\tlua_pushnil(L);\n\t    break;\n\tdefault:\n\t    lua_pushnil(L);\n    }\n}\n\n/* converts lua value at 'pos' to typval 'tv' */\n    static void\nluaV_totypval (lua_State *L, int pos, typval_T *tv)\n{\n    switch(lua_type(L, pos)) {\n\tcase LUA_TBOOLEAN:\n\t    tv->v_type = VAR_SPECIAL;\n\t    tv->vval.v_number = (varnumber_T) lua_toboolean(L, pos);\n\t    break;\n\tcase LUA_TSTRING:\n\t    tv->v_type = VAR_STRING;\n\t    tv->vval.v_string = vim_strsave((char_u *) lua_tostring(L, pos));\n\t    break;\n\tcase LUA_TNUMBER:\n#ifdef FEAT_FLOAT\n\t    tv->v_type = VAR_FLOAT;\n\t    tv->vval.v_float = (float_T) lua_tonumber(L, pos);\n#else\n\t    tv->v_type = VAR_NUMBER;\n\t    tv->vval.v_number = (varnumber_T) lua_tointeger(L, pos);\n#endif\n\t    break;\n\tcase LUA_TUSERDATA: {\n\t    void *p = lua_touserdata(L, pos);\n\t    if (lua_getmetatable(L, pos)) /* has metatable? */\n\t    {\n\t\t/* check list */\n\t\tluaV_getfield(L, LUAVIM_LIST);\n\t\tif (lua_rawequal(L, -1, -2))\n\t\t{\n\t\t    tv->v_type = VAR_LIST;\n\t\t    tv->vval.v_list = *((luaV_List *) p);\n\t\t    ++tv->vval.v_list->lv_refcount;\n\t\t    lua_pop(L, 2); /* MTs */\n\t\t    return;\n\t\t}\n\t\t/* check dict */\n\t\tluaV_getfield(L, LUAVIM_DICT);\n\t\tif (lua_rawequal(L, -1, -3))\n\t\t{\n\t\t    tv->v_type = VAR_DICT;\n\t\t    tv->vval.v_dict = *((luaV_Dict *) p);\n\t\t    ++tv->vval.v_dict->dv_refcount;\n\t\t    lua_pop(L, 3); /* MTs */\n\t\t    return;\n\t\t}\n\t\tlua_pop(L, 3); /* MTs */\n\t    }\n\t    break;\n\t}\n\tdefault:\n\t    tv->v_type = VAR_NUMBER;\n\t    tv->vval.v_number = 0;\n    }\n}\n\n/* similar to luaL_addlstring, but replaces \\0 with \\n if toline and\n * \\n with \\0 otherwise */\n    static void\nluaV_addlstring(luaL_Buffer *b, const char *s, size_t l, int toline)\n{\n    while (l--)\n    {\n\tif (*s == '\\0' && toline)\n\t    luaL_addchar(b, '\\n');\n\telse if (*s == '\\n' && !toline)\n\t    luaL_addchar(b, '\\0');\n\telse\n\t    luaL_addchar(b, *s);\n\ts++;\n    }\n}\n\n    static void\nluaV_pushline(lua_State *L, buf_T *buf, linenr_T n)\n{\n    const char *s = (const char *) ml_get_buf(buf, n, FALSE);\n    luaL_Buffer b;\n    luaL_buffinit(L, &b);\n    luaV_addlstring(&b, s, strlen(s), 0);\n    luaL_pushresult(&b);\n}\n\n    static char_u *\nluaV_toline(lua_State *L, int pos)\n{\n    size_t l;\n    const char *s = lua_tolstring(L, pos, &l);\n\n    luaL_Buffer b;\n    luaL_buffinit(L, &b);\n    luaV_addlstring(&b, s, l, 1);\n    luaL_pushresult(&b);\n    return (char_u *) lua_tostring(L, -1);\n}\n\n/* pops a string s from the top of the stack and calls mf(t) for pieces t of\n * s separated by newlines */\n    static void\nluaV_msgfunc(lua_State *L, msgfunc_T mf)\n{\n    luaL_Buffer b;\n    size_t l;\n    const char *p, *s = lua_tolstring(L, -1, &l);\n    luaL_buffinit(L, &b);\n    luaV_addlstring(&b, s, l, 0);\n    luaL_pushresult(&b);\n    /* break string */\n    p = s = lua_tolstring(L, -1, &l);\n    while (l--)\n    {\n\tif (*p++ == '\\0') /* break? */\n\t{\n\t    mf((char_u *) s);\n\t    s = p;\n\t}\n    }\n    mf((char_u *) s);\n    lua_pop(L, 2); /* original and modified strings */\n}\n\n#define luaV_newtype(typ,tname,luatyp,luatname) \\\n\tstatic luatyp * \\\n    luaV_new##tname (lua_State *L, typ *obj) \\\n    { \\\n\tluatyp *o = (luatyp *) lua_newuserdata(L, sizeof(luatyp)); \\\n\t*o = obj; \\\n\tluaV_setudata(L, obj); /* cache[obj] = udata */ \\\n\tluaV_getfield(L, luatname); \\\n\tlua_setmetatable(L, -2); \\\n\treturn o; \\\n    }\n\n#define luaV_pushtype(typ,tname,luatyp) \\\n\tstatic luatyp * \\\n    luaV_push##tname (lua_State *L, typ *obj) \\\n    { \\\n\tluatyp *o = NULL; \\\n\tif (obj == NULL) \\\n\t    lua_pushnil(L); \\\n\telse { \\\n\t    luaV_getudata(L, obj); \\\n\t    if (lua_isnil(L, -1)) /* not interned? */ \\\n\t    { \\\n\t\tlua_pop(L, 1); \\\n\t\to = luaV_new##tname(L, obj); \\\n\t    } \\\n\t    else \\\n\t\to = (luatyp *) lua_touserdata(L, -1); \\\n\t} \\\n\treturn o; \\\n    }\n\n#define luaV_type_tostring(tname,luatname) \\\n\tstatic int \\\n    luaV_##tname##_tostring (lua_State *L) \\\n    { \\\n\tlua_pushfstring(L, \"%s: %p\", luatname, lua_touserdata(L, 1)); \\\n\treturn 1; \\\n    }\n\n/* =======   List type   ======= */\n\n    static luaV_List *\nluaV_newlist (lua_State *L, list_T *lis)\n{\n    luaV_List *l = (luaV_List *) lua_newuserdata(L, sizeof(luaV_List));\n    *l = lis;\n    lis->lv_refcount++; /* reference in Lua */\n    luaV_setudata(L, lis); /* cache[lis] = udata */\n    luaV_getfield(L, LUAVIM_LIST);\n    lua_setmetatable(L, -2);\n    return l;\n}\n\nluaV_pushtype(list_T, list, luaV_List)\nluaV_type_tostring(list, LUAVIM_LIST)\n\n    static int\nluaV_list_len (lua_State *L)\n{\n    list_T *l = luaV_unbox(L, luaV_List, 1);\n    lua_pushinteger(L, (l == NULL) ? 0 : (int) l->lv_len);\n    return 1;\n}\n\n    static int\nluaV_list_iter (lua_State *L)\n{\n    listitem_T *li = (listitem_T *) lua_touserdata(L, lua_upvalueindex(2));\n    if (li == NULL) return 0;\n    luaV_pushtypval(L, &li->li_tv);\n    lua_pushlightuserdata(L, (void *) li->li_next);\n    lua_replace(L, lua_upvalueindex(2));\n    return 1;\n}\n\n    static int\nluaV_list_call (lua_State *L)\n{\n    list_T *l = luaV_unbox(L, luaV_List, 1);\n    lua_pushvalue(L, lua_upvalueindex(1)); /* pass cache table along */\n    lua_pushlightuserdata(L, (void *) l->lv_first);\n    lua_pushcclosure(L, luaV_list_iter, 2);\n    return 1;\n}\n\n    static int\nluaV_list_index (lua_State *L)\n{\n    list_T *l = luaV_unbox(L, luaV_List, 1);\n    if (lua_isnumber(L, 2)) /* list item? */\n    {\n\tlistitem_T *li = list_find(l, (long) luaL_checkinteger(L, 2));\n\tif (li == NULL)\n\t    lua_pushnil(L);\n\telse\n\t    luaV_pushtypval(L, &li->li_tv);\n    }\n    else if (lua_isstring(L, 2)) /* method? */\n    {\n\tconst char *s = lua_tostring(L, 2);\n\tif (strncmp(s, \"add\", 3) == 0\n\t\t|| strncmp(s, \"insert\", 6) == 0)\n\t{\n\t    lua_getmetatable(L, 1);\n\t    lua_getfield(L, -1, s);\n\t}\n\telse\n\t    lua_pushnil(L);\n    }\n    else\n\tlua_pushnil(L);\n    return 1;\n}\n\n    static int\nluaV_list_newindex (lua_State *L)\n{\n    list_T *l = luaV_unbox(L, luaV_List, 1);\n    long n = (long) luaL_checkinteger(L, 2);\n    listitem_T *li;\n    if (l->lv_lock)\n\tluaL_error(L, \"list is locked\");\n    li = list_find(l, n);\n    if (li == NULL) return 0;\n    if (lua_isnil(L, 3)) /* remove? */\n    {\n\tvimlist_remove(l, li, li);\n\tclear_tv(&li->li_tv);\n\tvim_free(li);\n    }\n    else\n    {\n\ttypval_T v;\n\tluaV_totypval(L, 3, &v);\n\tclear_tv(&li->li_tv);\n\tcopy_tv(&v, &li->li_tv);\n\tclear_tv(&v);\n    }\n    return 0;\n}\n\n    static int\nluaV_list_add (lua_State *L)\n{\n    luaV_List *lis = luaV_checkudata(L, 1, LUAVIM_LIST);\n    list_T *l = (list_T *) luaV_checkcache(L, (void *) *lis);\n    typval_T v;\n    if (l->lv_lock)\n\tluaL_error(L, \"list is locked\");\n    lua_settop(L, 2);\n    luaV_totypval(L, 2, &v);\n    if (list_append_tv(l, &v) == FAIL)\n    {\n\tclear_tv(&v);\n\tluaL_error(L, \"Failed to add item to list\");\n    }\n    clear_tv(&v);\n    lua_settop(L, 1);\n    return 1;\n}\n\n    static int\nluaV_list_insert (lua_State *L)\n{\n    luaV_List *lis = luaV_checkudata(L, 1, LUAVIM_LIST);\n    list_T *l = (list_T *) luaV_checkcache(L, (void *) *lis);\n    long pos = (long) luaL_optinteger(L, 3, 0);\n    listitem_T *li = NULL;\n    typval_T v;\n    if (l->lv_lock)\n\tluaL_error(L, \"list is locked\");\n    if (pos < l->lv_len)\n    {\n\tli = list_find(l, pos);\n\tif (li == NULL)\n\t    luaL_error(L, \"invalid position\");\n    }\n    lua_settop(L, 2);\n    luaV_totypval(L, 2, &v);\n    if (list_insert_tv(l, &v, li) == FAIL)\n    {\n\tclear_tv(&v);\n\tluaL_error(L, \"Failed to add item to list\");\n    }\n    clear_tv(&v);\n    lua_settop(L, 1);\n    return 1;\n}\n\nstatic const luaL_Reg luaV_List_mt[] = {\n    {\"__tostring\", luaV_list_tostring},\n    {\"__len\", luaV_list_len},\n    {\"__call\", luaV_list_call},\n    {\"__index\", luaV_list_index},\n    {\"__newindex\", luaV_list_newindex},\n    {\"add\", luaV_list_add},\n    {\"insert\", luaV_list_insert},\n    {NULL, NULL}\n};\n\n\n/* =======   Dict type   ======= */\n\n    static luaV_Dict *\nluaV_newdict (lua_State *L, dict_T *dic)\n{\n    luaV_Dict *d = (luaV_Dict *) lua_newuserdata(L, sizeof(luaV_Dict));\n    *d = dic;\n    dic->dv_refcount++; /* reference in Lua */\n    luaV_setudata(L, dic); /* cache[dic] = udata */\n    luaV_getfield(L, LUAVIM_DICT);\n    lua_setmetatable(L, -2);\n    return d;\n}\n\nluaV_pushtype(dict_T, dict, luaV_Dict)\nluaV_type_tostring(dict, LUAVIM_DICT)\n\n    static int\nluaV_dict_len (lua_State *L)\n{\n    dict_T *d = luaV_unbox(L, luaV_Dict, 1);\n    lua_pushinteger(L, (d == NULL) ? 0 : (int) d->dv_hashtab.ht_used);\n    return 1;\n}\n\n    static int\nluaV_dict_iter (lua_State *L UNUSED)\n{\n#ifdef FEAT_EVAL\n    hashitem_T *hi = (hashitem_T *) lua_touserdata(L, lua_upvalueindex(2));\n    int n = lua_tointeger(L, lua_upvalueindex(3));\n    dictitem_T *di;\n    if (n <= 0) return 0;\n    while (HASHITEM_EMPTY(hi)) hi++;\n    di = dict_lookup(hi);\n    lua_pushstring(L, (char *) hi->hi_key);\n    luaV_pushtypval(L, &di->di_tv);\n    lua_pushlightuserdata(L, (void *) (hi + 1));\n    lua_replace(L, lua_upvalueindex(2));\n    lua_pushinteger(L, n - 1);\n    lua_replace(L, lua_upvalueindex(3));\n    return 2;\n#else\n    return 0;\n#endif\n}\n\n    static int\nluaV_dict_call (lua_State *L)\n{\n    dict_T *d = luaV_unbox(L, luaV_Dict, 1);\n    hashtab_T *ht = &d->dv_hashtab;\n    lua_pushvalue(L, lua_upvalueindex(1)); /* pass cache table along */\n    lua_pushlightuserdata(L, (void *) ht->ht_array);\n    lua_pushinteger(L, ht->ht_used); /* # remaining items */\n    lua_pushcclosure(L, luaV_dict_iter, 3);\n    return 1;\n}\n\n    static int\nluaV_dict_index (lua_State *L)\n{\n    dict_T *d = luaV_unbox(L, luaV_Dict, 1);\n    char_u *key = (char_u *) luaL_checkstring(L, 2);\n    dictitem_T *di = dict_find(d, key, -1);\n    if (di == NULL)\n\tlua_pushnil(L);\n    else\n\tluaV_pushtypval(L, &di->di_tv);\n    return 1;\n}\n\n    static int\nluaV_dict_newindex (lua_State *L)\n{\n    dict_T *d = luaV_unbox(L, luaV_Dict, 1);\n    char_u *key = (char_u *) luaL_checkstring(L, 2);\n    dictitem_T *di;\n    if (d->dv_lock)\n\tluaL_error(L, \"dict is locked\");\n    di = dict_find(d, key, -1);\n    if (di == NULL) /* non-existing key? */\n    {\n\tif (lua_isnil(L, 3)) return 0;\n\tdi = dictitem_alloc(key);\n\tif (di == NULL) return 0;\n\tif (dict_add(d, di) == FAIL)\n\t{\n\t\tvim_free(di);\n\t\treturn 0;\n\t}\n    }\n    else\n\tclear_tv(&di->di_tv);\n    if (lua_isnil(L, 3)) /* remove? */\n    {\n\thashitem_T *hi = hash_find(&d->dv_hashtab, di->di_key);\n\thash_remove(&d->dv_hashtab, hi);\n\tdictitem_free(di);\n    }\n    else {\n\ttypval_T v;\n\tluaV_totypval(L, 3, &v);\n\tcopy_tv(&v, &di->di_tv);\n\tclear_tv(&v);\n    }\n    return 0;\n}\n\nstatic const luaL_Reg luaV_Dict_mt[] = {\n    {\"__tostring\", luaV_dict_tostring},\n    {\"__len\", luaV_dict_len},\n    {\"__call\", luaV_dict_call},\n    {\"__index\", luaV_dict_index},\n    {\"__newindex\", luaV_dict_newindex},\n    {NULL, NULL}\n};\n\n\n/* =======   Buffer type   ======= */\n\nluaV_newtype(buf_T, buffer, luaV_Buffer, LUAVIM_BUFFER)\nluaV_pushtype(buf_T, buffer, luaV_Buffer)\nluaV_type_tostring(buffer, LUAVIM_BUFFER)\n\n    static int\nluaV_buffer_len(lua_State *L)\n{\n    buf_T *b = (buf_T *) luaV_checkvalid(L, luaV_Buffer, 1);\n    lua_pushinteger(L, b->b_ml.ml_line_count);\n    return 1;\n}\n\n    static int\nluaV_buffer_call(lua_State *L)\n{\n    buf_T *b = (buf_T *) luaV_checkvalid(L, luaV_Buffer, 1);\n    lua_settop(L, 1);\n    set_curbuf(b, DOBUF_SPLIT);\n    return 1;\n}\n\n    static int\nluaV_buffer_index(lua_State *L)\n{\n    buf_T *b = (buf_T *) luaV_checkvalid(L, luaV_Buffer, 1);\n    linenr_T n = (linenr_T) lua_tointeger(L, 2);\n    if (n > 0 && n <= b->b_ml.ml_line_count)\n\tluaV_pushline(L, b, n);\n    else if (lua_isstring(L, 2))\n    {\n\tconst char *s = lua_tostring(L, 2);\n\tif (strncmp(s, \"name\", 4) == 0)\n\t    lua_pushstring(L, (char *) b->b_sfname);\n\telse if (strncmp(s, \"fname\", 5) == 0)\n\t    lua_pushstring(L, (char *) b->b_ffname);\n\telse if (strncmp(s, \"number\", 6) == 0)\n\t    lua_pushinteger(L, b->b_fnum);\n\t/* methods */\n\telse if (strncmp(s,   \"insert\", 6) == 0\n\t\t|| strncmp(s, \"next\", 4) == 0\n\t\t|| strncmp(s, \"previous\", 8) == 0\n\t\t|| strncmp(s, \"isvalid\", 7) == 0)\n\t{\n\t    lua_getmetatable(L, 1);\n\t    lua_getfield(L, -1, s);\n\t}\n\telse\n\t    lua_pushnil(L);\n    }\n    else\n\tlua_pushnil(L);\n    return 1;\n}\n\n    static int\nluaV_buffer_newindex(lua_State *L)\n{\n    buf_T *b = (buf_T *) luaV_checkvalid(L, luaV_Buffer, 1);\n    linenr_T n = (linenr_T) luaL_checkinteger(L, 2);\n#ifdef HAVE_SANDBOX\n    luaV_checksandbox(L);\n#endif\n    if (n < 1 || n > b->b_ml.ml_line_count)\n\tluaL_error(L, \"invalid line number\");\n    if (lua_isnil(L, 3)) /* delete line */\n    {\n\tbuf_T *buf = curbuf;\n\tcurbuf = b;\n\tif (u_savedel(n, 1L) == FAIL)\n\t{\n\t    curbuf = buf;\n\t    luaL_error(L, \"cannot save undo information\");\n\t}\n\telse if (ml_delete(n, FALSE) == FAIL)\n\t{\n\t    curbuf = buf;\n\t    luaL_error(L, \"cannot delete line\");\n\t}\n\telse {\n\t    deleted_lines_mark(n, 1L);\n\t    if (b == curwin->w_buffer) /* fix cursor in current window? */\n\t    {\n\t\tif (curwin->w_cursor.lnum >= n)\n\t\t{\n\t\t    if (curwin->w_cursor.lnum > n)\n\t\t    {\n\t\t\tcurwin->w_cursor.lnum -= 1;\n\t\t\tcheck_cursor_col();\n\t\t    }\n\t\t    else check_cursor();\n\t\t    changed_cline_bef_curs();\n\t\t}\n\t\tinvalidate_botline();\n\t    }\n\t}\n\tcurbuf = buf;\n    }\n    else if (lua_isstring(L, 3)) /* update line */\n    {\n\tbuf_T *buf = curbuf;\n\tcurbuf = b;\n\tif (u_savesub(n) == FAIL)\n\t{\n\t    curbuf = buf;\n\t    luaL_error(L, \"cannot save undo information\");\n\t}\n\telse if (ml_replace(n, luaV_toline(L, 3), TRUE) == FAIL)\n\t{\n\t    curbuf = buf;\n\t    luaL_error(L, \"cannot replace line\");\n\t}\n\telse changed_bytes(n, 0);\n\tcurbuf = buf;\n\tif (b == curwin->w_buffer)\n\t    check_cursor_col();\n    }\n    else\n\tluaL_error(L, \"wrong argument to change line\");\n    return 0;\n}\n\n    static int\nluaV_buffer_insert(lua_State *L)\n{\n    luaV_Buffer *lb = luaV_checkudata(L, 1, LUAVIM_BUFFER);\n    buf_T *b = (buf_T *) luaV_checkcache(L, (void *) *lb);\n    linenr_T last = b->b_ml.ml_line_count;\n    linenr_T n = (linenr_T) luaL_optinteger(L, 3, last);\n    buf_T *buf;\n    luaL_checktype(L, 2, LUA_TSTRING);\n#ifdef HAVE_SANDBOX\n    luaV_checksandbox(L);\n#endif\n    /* fix insertion line */\n    if (n < 0) n = 0;\n    if (n > last) n = last;\n    /* insert */\n    buf = curbuf;\n    curbuf = b;\n    if (u_save(n, n + 1) == FAIL)\n    {\n\tcurbuf = buf;\n\tluaL_error(L, \"cannot save undo information\");\n    }\n    else if (ml_append(n, luaV_toline(L, 2), 0, FALSE) == FAIL)\n    {\n\tcurbuf = buf;\n\tluaL_error(L, \"cannot insert line\");\n    }\n    else\n\tappended_lines_mark(n, 1L);\n    curbuf = buf;\n    update_screen(VALID);\n    return 0;\n}\n\n    static int\nluaV_buffer_next(lua_State *L)\n{\n    luaV_Buffer *b = luaV_checkudata(L, 1, LUAVIM_BUFFER);\n    buf_T *buf = (buf_T *) luaV_checkcache(L, (void *) *b);\n    luaV_pushbuffer(L, buf->b_next);\n    return 1;\n}\n\n    static int\nluaV_buffer_previous(lua_State *L)\n{\n    luaV_Buffer *b = luaV_checkudata(L, 1, LUAVIM_BUFFER);\n    buf_T *buf = (buf_T *) luaV_checkcache(L, (void *) *b);\n    luaV_pushbuffer(L, buf->b_prev);\n    return 1;\n}\n\n    static int\nluaV_buffer_isvalid(lua_State *L)\n{\n    luaV_Buffer *b = luaV_checkudata(L, 1, LUAVIM_BUFFER);\n    luaV_getudata(L, *b);\n    lua_pushboolean(L, !lua_isnil(L, -1));\n    return 1;\n}\n\nstatic const luaL_Reg luaV_Buffer_mt[] = {\n    {\"__tostring\", luaV_buffer_tostring},\n    {\"__len\", luaV_buffer_len},\n    {\"__call\", luaV_buffer_call},\n    {\"__index\", luaV_buffer_index},\n    {\"__newindex\", luaV_buffer_newindex},\n    {\"insert\", luaV_buffer_insert},\n    {\"next\", luaV_buffer_next},\n    {\"previous\", luaV_buffer_previous},\n    {\"isvalid\", luaV_buffer_isvalid},\n    {NULL, NULL}\n};\n\n\n/* =======   Window type   ======= */\n\nluaV_newtype(win_T, window, luaV_Window, LUAVIM_WINDOW)\nluaV_pushtype(win_T, window, luaV_Window)\nluaV_type_tostring(window, LUAVIM_WINDOW)\n\n    static int\nluaV_window_call(lua_State *L)\n{\n    win_T *w = (win_T *) luaV_checkvalid(L, luaV_Window, 1);\n    lua_settop(L, 1);\n    win_goto(w);\n    return 1;\n}\n\n    static int\nluaV_window_index(lua_State *L)\n{\n    win_T *w = (win_T *) luaV_checkvalid(L, luaV_Window, 1);\n    const char *s = luaL_checkstring(L, 2);\n    if (strncmp(s, \"buffer\", 6) == 0)\n\tluaV_pushbuffer(L, w->w_buffer);\n    else if (strncmp(s, \"line\", 4) == 0)\n\tlua_pushinteger(L, w->w_cursor.lnum);\n    else if (strncmp(s, \"col\", 3) == 0)\n\tlua_pushinteger(L, w->w_cursor.col + 1);\n#ifdef FEAT_WINDOWS\n    else if (strncmp(s, \"width\", 5) == 0)\n\tlua_pushinteger(L, W_WIDTH(w));\n#endif\n    else if (strncmp(s, \"height\", 6) == 0)\n\tlua_pushinteger(L, w->w_height);\n    /* methods */\n    else if (strncmp(s,   \"next\", 4) == 0\n\t    || strncmp(s, \"previous\", 8) == 0\n\t    || strncmp(s, \"isvalid\", 7) == 0)\n    {\n\tlua_getmetatable(L, 1);\n\tlua_getfield(L, -1, s);\n    }\n    else\n\tlua_pushnil(L);\n    return 1;\n}\n\n    static int\nluaV_window_newindex (lua_State *L)\n{\n    win_T *w = (win_T *) luaV_checkvalid(L, luaV_Window, 1);\n    const char *s = luaL_checkstring(L, 2);\n    int v = luaL_checkinteger(L, 3);\n    if (strncmp(s, \"line\", 4) == 0)\n    {\n#ifdef HAVE_SANDBOX\n\tluaV_checksandbox(L);\n#endif\n\tif (v < 1 || v > w->w_buffer->b_ml.ml_line_count)\n\t    luaL_error(L, \"line out of range\");\n\tw->w_cursor.lnum = v;\n\tupdate_screen(VALID);\n    }\n    else if (strncmp(s, \"col\", 3) == 0)\n    {\n#ifdef HAVE_SANDBOX\n\tluaV_checksandbox(L);\n#endif\n\tw->w_cursor.col = v - 1;\n\tupdate_screen(VALID);\n    }\n#ifdef FEAT_WINDOWS\n    else if (strncmp(s, \"width\", 5) == 0)\n    {\n\twin_T *win = curwin;\n#ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n#endif\n\tcurwin = w;\n\twin_setwidth(v);\n\tcurwin = win;\n    }\n#endif\n    else if (strncmp(s, \"height\", 6) == 0)\n    {\n\twin_T *win = curwin;\n#ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n#endif\n\tcurwin = w;\n\twin_setheight(v);\n\tcurwin = win;\n    }\n    else\n\tluaL_error(L, \"invalid window property: `%s'\", s);\n    return 0;\n}\n\n    static int\nluaV_window_next(lua_State *L)\n{\n    luaV_Window *w = luaV_checkudata(L, 1, LUAVIM_WINDOW);\n    win_T *win = (win_T *) luaV_checkcache(L, (void *) *w);\n    luaV_pushwindow(L, win->w_next);\n    return 1;\n}\n\n    static int\nluaV_window_previous(lua_State *L)\n{\n    luaV_Window *w = luaV_checkudata(L, 1, LUAVIM_WINDOW);\n    win_T *win = (win_T *) luaV_checkcache(L, (void *) *w);\n    luaV_pushwindow(L, win->w_prev);\n    return 1;\n}\n\n    static int\nluaV_window_isvalid(lua_State *L)\n{\n    luaV_Window *w = luaV_checkudata(L, 1, LUAVIM_WINDOW);\n    luaV_getudata(L, *w);\n    lua_pushboolean(L, !lua_isnil(L, -1));\n    return 1;\n}\n\nstatic const luaL_Reg luaV_Window_mt[] = {\n    {\"__tostring\", luaV_window_tostring},\n    {\"__call\", luaV_window_call},\n    {\"__index\", luaV_window_index},\n    {\"__newindex\", luaV_window_newindex},\n    {\"next\", luaV_window_next},\n    {\"previous\", luaV_window_previous},\n    {\"isvalid\", luaV_window_isvalid},\n    {NULL, NULL}\n};\n\n\n/* =======   Vim module   ======= */\n\n    static int\nluaV_print(lua_State *L)\n{\n    int i, n = lua_gettop(L); /* nargs */\n    const char *s;\n    size_t l;\n    luaL_Buffer b;\n    luaL_buffinit(L, &b);\n    lua_getglobal(L, \"tostring\");\n    for (i = 1; i <= n; i++)\n    {\n\tlua_pushvalue(L, -1); /* tostring */\n\tlua_pushvalue(L, i); /* arg */\n\tlua_call(L, 1, 1);\n\ts = lua_tolstring(L, -1, &l);\n\tif (s == NULL)\n\t    return luaL_error(L, \"cannot convert to string\");\n\tif (i > 1) luaL_addchar(&b, ' '); /* use space instead of tab */\n\tluaV_addlstring(&b, s, l, 0);\n\tlua_pop(L, 1);\n    }\n    luaL_pushresult(&b);\n    luaV_msg(L);\n    return 0;\n}\n\n    static int\nluaV_debug(lua_State *L)\n{\n    lua_settop(L, 0);\n    lua_getglobal(L, \"vim\");\n    lua_getfield(L, -1, \"eval\");\n    lua_remove(L, -2); /* vim.eval at position 1 */\n    for (;;)\n    {\n\tconst char *input;\n\tsize_t l;\n\tlua_pushvalue(L, 1); /* vim.eval */\n\tlua_pushliteral(L, \"input('lua_debug> ')\");\n\tlua_call(L, 1, 1); /* return string */\n\tinput = lua_tolstring(L, -1, &l);\n\tif (l == 0 || strcmp(input, \"cont\") == 0)\n\t    return 0;\n\tmsg_putchar('\\n'); /* avoid outputting on input line */\n\tif (luaL_loadbuffer(L, input, l, \"=(debug command)\")\n\t\t|| lua_pcall(L, 0, 0, 0))\n\t    luaV_emsg(L);\n\tlua_settop(L, 1); /* remove eventual returns, but keep vim.eval */\n    }\n}\n\n    static int\nluaV_command(lua_State *L)\n{\n    do_cmdline_cmd((char_u *) luaL_checkstring(L, 1));\n    update_screen(VALID);\n    return 0;\n}\n\n    static int\nluaV_eval(lua_State *L)\n{\n    typval_T *tv = eval_expr((char_u *) luaL_checkstring(L, 1), NULL);\n    if (tv == NULL) luaL_error(L, \"invalid expression\");\n    luaV_pushtypval(L, tv);\n    free_tv(tv);\n    return 1;\n}\n\n    static int\nluaV_beep(lua_State *L UNUSED)\n{\n    vim_beep(BO_LANG);\n    return 0;\n}\n\n    static int\nluaV_line(lua_State *L)\n{\n    luaV_pushline(L, curbuf, curwin->w_cursor.lnum);\n    return 1;\n}\n\n    static int\nluaV_list(lua_State *L)\n{\n    list_T *l = list_alloc();\n    if (l == NULL)\n\tlua_pushnil(L);\n    else\n\tluaV_newlist(L, l);\n    return 1;\n}\n\n    static int\nluaV_dict(lua_State *L)\n{\n    dict_T *d = dict_alloc();\n    if (d == NULL)\n\tlua_pushnil(L);\n    else\n\tluaV_newdict(L, d);\n    return 1;\n}\n\n    static int\nluaV_buffer(lua_State *L)\n{\n    buf_T *buf;\n    if (lua_isstring(L, 1)) /* get by number or name? */\n    {\n\tif (lua_isnumber(L, 1)) /* by number? */\n\t{\n\t    int n = lua_tointeger(L, 1);\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_fnum == n) break;\n\t}\n\telse { /* by name */\n\t    size_t l;\n\t    const char *s = lua_tolstring(L, 1, &l);\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (buf->b_ffname == NULL || buf->b_sfname == NULL)\n\t\t{\n\t\t    if (l == 0) break;\n\t\t}\n\t\telse if (strncmp(s, (char *)buf->b_ffname, l) == 0\n\t\t\t|| strncmp(s, (char *)buf->b_sfname, l) == 0)\n\t\t    break;\n\t    }\n\t}\n    }\n    else\n\tbuf = (lua_toboolean(L, 1)) ? firstbuf : curbuf; /* first buffer? */\n    luaV_pushbuffer(L, buf);\n    return 1;\n}\n\n    static int\nluaV_window(lua_State *L)\n{\n    win_T *win;\n    if (lua_isnumber(L, 1)) /* get by number? */\n    {\n\tint n = lua_tointeger(L, 1);\n\tfor (win = firstwin; win != NULL; win = win->w_next, n--)\n\t    if (n == 1) break;\n    }\n    else\n\twin = (lua_toboolean(L, 1)) ? firstwin : curwin; /* first window? */\n    luaV_pushwindow(L, win);\n    return 1;\n}\n\n    static int\nluaV_open(lua_State *L)\n{\n    char_u *s = NULL;\n#ifdef HAVE_SANDBOX\n    luaV_checksandbox(L);\n#endif\n    if (lua_isstring(L, 1)) s = (char_u *) lua_tostring(L, 1);\n    luaV_pushbuffer(L, buflist_new(s, NULL, 1L, BLN_LISTED));\n    return 1;\n}\n\n    static int\nluaV_type(lua_State *L)\n{\n    luaL_checkany(L, 1);\n    if (lua_type(L, 1) == LUA_TUSERDATA) /* check vim udata? */\n    {\n\tlua_settop(L, 1);\n\tif (lua_getmetatable(L, 1))\n\t{\n\t    luaV_getfield(L, LUAVIM_LIST);\n\t    if (lua_rawequal(L, -1, 2))\n\t    {\n\t\tlua_pushstring(L, \"list\");\n\t\treturn 1;\n\t    }\n\t    luaV_getfield(L, LUAVIM_DICT);\n\t    if (lua_rawequal(L, -1, 2))\n\t    {\n\t\tlua_pushstring(L, \"dict\");\n\t\treturn 1;\n\t    }\n\t    luaV_getfield(L, LUAVIM_BUFFER);\n\t    if (lua_rawequal(L, -1, 2))\n\t    {\n\t\tlua_pushstring(L, \"buffer\");\n\t\treturn 1;\n\t    }\n\t    luaV_getfield(L, LUAVIM_WINDOW);\n\t    if (lua_rawequal(L, -1, 2))\n\t    {\n\t\tlua_pushstring(L, \"window\");\n\t\treturn 1;\n\t    }\n\t}\n    }\n    lua_pushstring(L, luaL_typename(L, 1)); /* fallback */\n    return 1;\n}\n\nstatic const luaL_Reg luaV_module[] = {\n    {\"command\", luaV_command},\n    {\"eval\", luaV_eval},\n    {\"beep\", luaV_beep},\n    {\"line\", luaV_line},\n    {\"list\", luaV_list},\n    {\"dict\", luaV_dict},\n    {\"buffer\", luaV_buffer},\n    {\"window\", luaV_window},\n    {\"open\", luaV_open},\n    {\"type\", luaV_type},\n    {NULL, NULL}\n};\n\n/* for freeing list, dict, buffer and window objects; lightuserdata as arg */\n    static int\nluaV_free(lua_State *L)\n{\n    lua_pushnil(L);\n    luaV_setudata(L, lua_touserdata(L, 1));\n    return 0;\n}\n\n    static int\nluaV_luaeval (lua_State *L)\n{\n    luaL_Buffer b;\n    size_t l;\n    const char *str = lua_tolstring(L, 1, &l);\n    typval_T *arg = (typval_T *) lua_touserdata(L, 2);\n    typval_T *rettv = (typval_T *) lua_touserdata(L, 3);\n    luaL_buffinit(L, &b);\n    luaL_addlstring(&b, LUAVIM_EVALHEADER, sizeof(LUAVIM_EVALHEADER) - 1);\n    luaL_addlstring(&b, str, l);\n    luaL_pushresult(&b);\n    str = lua_tolstring(L, -1, &l);\n    if (luaL_loadbuffer(L, str, l, LUAVIM_EVALNAME)) /* compile error? */\n    {\n\tluaV_emsg(L);\n\treturn 0;\n    }\n    luaV_pushtypval(L, arg);\n    if (lua_pcall(L, 1, 1, 0)) /* running error? */\n    {\n\tluaV_emsg(L);\n\treturn 0;\n    }\n    luaV_totypval(L, -1, rettv);\n    return 0;\n}\n\n    static int\nluaV_setref (lua_State *L)\n{\n    int\t\tcopyID = lua_tointeger(L, 1);\n    int\t\tabort = FALSE;\n    typval_T\ttv;\n\n    luaV_getfield(L, LUAVIM_LIST);\n    luaV_getfield(L, LUAVIM_DICT);\n    lua_pushnil(L);\n    /* traverse cache table */\n    while (!abort && lua_next(L, lua_upvalueindex(1)) != 0)\n    {\n\tlua_getmetatable(L, -1);\n\tif (lua_rawequal(L, -1, 2)) /* list? */\n\t{\n\t    tv.v_type = VAR_LIST;\n\t    tv.vval.v_list = (list_T *) lua_touserdata(L, 4); /* key */\n\t    abort = set_ref_in_item(&tv, copyID, NULL, NULL);\n\t}\n\telse if (lua_rawequal(L, -1, 3)) /* dict? */\n\t{\n\t    tv.v_type = VAR_DICT;\n\t    tv.vval.v_dict = (dict_T *) lua_touserdata(L, 4); /* key */\n\t    abort = set_ref_in_item(&tv, copyID, NULL, NULL);\n\t}\n\tlua_pop(L, 2); /* metatable and value */\n    }\n    lua_pushinteger(L, abort);\n    return 1;\n}\n\n    static int\nluaopen_vim(lua_State *L)\n{\n    /* set cache table */\n    lua_newtable(L);\n    lua_newtable(L);\n    lua_pushstring(L, \"v\");\n    lua_setfield(L, -2, \"__mode\");\n    lua_setmetatable(L, -2); /* cache is weak-valued */\n    /* print */\n    lua_pushcfunction(L, luaV_print);\n    lua_setglobal(L, \"print\");\n    /* debug.debug */\n    lua_getglobal(L, \"debug\");\n    lua_pushcfunction(L, luaV_debug);\n    lua_setfield(L, -2, \"debug\");\n    lua_pop(L, 1);\n    /* free */\n    lua_pushlightuserdata(L, (void *) LUAVIM_FREE);\n    lua_pushvalue(L, 1); /* cache table */\n    lua_pushcclosure(L, luaV_free, 1);\n    lua_rawset(L, LUA_REGISTRYINDEX);\n    /* luaeval */\n    lua_pushlightuserdata(L, (void *) LUAVIM_LUAEVAL);\n    lua_pushvalue(L, 1); /* cache table */\n    lua_pushcclosure(L, luaV_luaeval, 1);\n    lua_rawset(L, LUA_REGISTRYINDEX);\n    /* setref */\n    lua_pushlightuserdata(L, (void *) LUAVIM_SETREF);\n    lua_pushvalue(L, 1); /* cache table */\n    lua_pushcclosure(L, luaV_setref, 1);\n    lua_rawset(L, LUA_REGISTRYINDEX);\n    /* register */\n    luaV_newmetatable(L, LUAVIM_LIST);\n    lua_pushvalue(L, 1);\n    luaV_openlib(L, luaV_List_mt, 1);\n    luaV_newmetatable(L, LUAVIM_DICT);\n    lua_pushvalue(L, 1);\n    luaV_openlib(L, luaV_Dict_mt, 1);\n    luaV_newmetatable(L, LUAVIM_BUFFER);\n    lua_pushvalue(L, 1); /* cache table */\n    luaV_openlib(L, luaV_Buffer_mt, 1);\n    luaV_newmetatable(L, LUAVIM_WINDOW);\n    lua_pushvalue(L, 1); /* cache table */\n    luaV_openlib(L, luaV_Window_mt, 1);\n    lua_newtable(L); /* vim table */\n    lua_pushvalue(L, 1); /* cache table */\n    luaV_openlib(L, luaV_module, 1);\n    lua_setglobal(L, LUAVIM_NAME);\n    return 0;\n}\n\n    static lua_State *\nluaV_newstate(void)\n{\n    lua_State *L = luaL_newstate();\n    luaL_openlibs(L); /* core libs */\n    lua_pushcfunction(L, luaopen_vim); /* vim */\n    lua_call(L, 0, 0);\n    return L;\n}\n\n    static void\nluaV_setrange(lua_State *L, int line1, int line2)\n{\n    lua_getglobal(L, LUAVIM_NAME);\n    lua_pushinteger(L, line1);\n    lua_setfield(L, -2, \"firstline\");\n    lua_pushinteger(L, line2);\n    lua_setfield(L, -2, \"lastline\");\n    lua_pop(L, 1); /* vim table */\n}\n\n\n/* =======   Interface   ======= */\n\nstatic lua_State *L = NULL;\n\n    static int\nlua_isopen(void)\n{\n    return L != NULL;\n}\n\n    static int\nlua_init(void)\n{\n    if (!lua_isopen())\n    {\n#ifdef DYNAMIC_LUA\n\tif (!lua_enabled(TRUE))\n\t{\n\t    EMSG(_(\"Lua library cannot be loaded.\"));\n\t    return FAIL;\n\t}\n#endif\n\tL = luaV_newstate();\n    }\n    return OK;\n}\n\n    void\nlua_end(void)\n{\n    if (lua_isopen())\n    {\n\tlua_close(L);\n\tL = NULL;\n#ifdef DYNAMIC_LUA\n\tend_dynamic_lua();\n#endif\n    }\n}\n\n/* ex commands */\n    void\nex_lua(exarg_T *eap)\n{\n    char *script;\n    if (lua_init() == FAIL) return;\n    script = (char *) script_get(eap, eap->arg);\n    if (!eap->skip)\n    {\n\tchar *s = (script) ? script :  (char *) eap->arg;\n\tluaV_setrange(L, eap->line1, eap->line2);\n\tif (luaL_loadbuffer(L, s, strlen(s), LUAVIM_CHUNKNAME)\n\t\t|| lua_pcall(L, 0, 0, 0))\n\t    luaV_emsg(L);\n    }\n    if (script != NULL) vim_free(script);\n}\n\n    void\nex_luado(exarg_T *eap)\n{\n    linenr_T l;\n    const char *s = (const char *) eap->arg;\n    luaL_Buffer b;\n    size_t len;\n    buf_T *was_curbuf = curbuf;\n\n    if (lua_init() == FAIL) return;\n    if (u_save(eap->line1 - 1, eap->line2 + 1) == FAIL)\n    {\n\tEMSG(_(\"cannot save undo information\"));\n\treturn;\n    }\n    luaV_setrange(L, eap->line1, eap->line2);\n    luaL_buffinit(L, &b);\n    luaL_addlstring(&b, \"return function(line, linenr) \", 30); /* header */\n    luaL_addlstring(&b, s, strlen(s));\n    luaL_addlstring(&b, \" end\", 4); /* footer */\n    luaL_pushresult(&b);\n    s = lua_tolstring(L, -1, &len);\n    if (luaL_loadbuffer(L, s, len, LUAVIM_CHUNKNAME))\n    {\n\tluaV_emsg(L);\n\tlua_pop(L, 1); /* function body */\n\treturn;\n    }\n    lua_call(L, 0, 1);\n    lua_replace(L, -2); /* function -> body */\n    for (l = eap->line1; l <= eap->line2; l++)\n    {\n\t/* Check the line number, the command my have deleted lines. */\n\tif (l > curbuf->b_ml.ml_line_count)\n\t    break;\n\n\tlua_pushvalue(L, -1); /* function */\n\tluaV_pushline(L, curbuf, l); /* current line as arg */\n\tlua_pushinteger(L, l); /* current line number as arg */\n\tif (lua_pcall(L, 2, 1, 0))\n\t{\n\t    luaV_emsg(L);\n\t    break;\n\t}\n\t/* Catch the command switching to another buffer. */\n\tif (curbuf != was_curbuf)\n\t    break;\n\tif (lua_isstring(L, -1)) /* update line? */\n\t{\n#ifdef HAVE_SANDBOX\n\t    luaV_checksandbox(L);\n#endif\n\t    ml_replace(l, luaV_toline(L, -1), TRUE);\n\t    changed_bytes(l, 0);\n\t    lua_pop(L, 1); /* result from luaV_toline */\n\t}\n\tlua_pop(L, 1); /* line */\n    }\n    lua_pop(L, 1); /* function */\n    check_cursor();\n    update_screen(NOT_VALID);\n}\n\n    void\nex_luafile(exarg_T *eap)\n{\n    if (lua_init() == FAIL)\n\treturn;\n    if (!eap->skip)\n    {\n\tluaV_setrange(L, eap->line1, eap->line2);\n\tif (luaL_loadfile(L, (char *) eap->arg) || lua_pcall(L, 0, 0, 0))\n\t    luaV_emsg(L);\n    }\n}\n\n#define luaV_freetype(typ,tname) \\\n\tvoid \\\n    lua_##tname##_free(typ *o) \\\n    { \\\n\tif (!lua_isopen()) return; \\\n\tluaV_getfield(L, LUAVIM_FREE); \\\n\tlua_pushlightuserdata(L, (void *) o); \\\n\tlua_call(L, 1, 0); \\\n    }\n\nluaV_freetype(buf_T, buffer)\nluaV_freetype(win_T, window)\n\n    void\ndo_luaeval (char_u *str, typval_T *arg, typval_T *rettv)\n{\n    lua_init();\n    luaV_getfield(L, LUAVIM_LUAEVAL);\n    lua_pushstring(L, (char *) str);\n    lua_pushlightuserdata(L, (void *) arg);\n    lua_pushlightuserdata(L, (void *) rettv);\n    lua_call(L, 3, 0);\n}\n\n    int\nset_ref_in_lua (int copyID)\n{\n    int aborted = 0;\n\n    if (lua_isopen())\n    {\n\tluaV_getfield(L, LUAVIM_SETREF);\n\t/* call the function with 1 arg, getting 1 result back */\n\tlua_pushinteger(L, copyID);\n\tlua_call(L, 1, 1);\n\t/* get the result */\n\taborted = lua_tointeger(L, -1);\n\t/* pop result off the stack */\n\tlua_pop(L, 1);\n    }\n    return aborted;\n}\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/READMEdir/Xxd.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/READMEdir/README_ami.txt.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/READMEdir/README_amisrc.txt.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/READMEdir/README_amibin.txt.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/READMEdir/Vim.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/READMEdir/README.txt.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/READMEdir/Contents.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/READMEdir/runtime.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/READMEdir/src.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/READMEdir/vimdir.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/farsi/fonts/UNIXs/far-a01.pcf.Z",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/farsi/fonts/UNIXs/far-a01.f16",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/farsi/fonts/UNIXs/far-a01.pcf.gz",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/farsi/fonts/DOS/far-a01.com",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/farsi/fonts/SunOs/far-a01.fb",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/farsi/fonts/WINDOWS/far-a01.fon",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/hangulin.c",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/vim_info.ico",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/tools.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/os_beos.rsrc",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/vim_alert.ico",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/tearoff.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/vim_error.ico",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/vim_quest.ico",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/digraph.c",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/vim.tlb",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/vim.ico",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/cs.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/zh_CN.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/ja.euc-jp.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/ru.cp1251.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/ko.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/sk.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/cs.cp1250.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/zh_CN.cp936.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/pl.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/zh_TW.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/ca.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/sk.cp1250.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/ga.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/sv.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/uk.cp1251.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/nb.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/it.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/pl.cp1250.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/README.txt",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/no.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/pt_BR.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/ja.sjis.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/af.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/fr.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/de.po",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/po/README_mingw.txt",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test58.ok",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test44.in",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test_increment_dbcs.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test39.ok",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test58.in",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test52.in",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test_regexp_latin.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test59.in",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test99.in",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test42.ok",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test_farsi.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test36.ok",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test36.in",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test52.ok",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test39.in",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test_mksession.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/testdir/test42.in",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/VisVim/VisVim.dll",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/VisVim/Res/ToolbarL.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/VisVim/Res/ToolbarM.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/xpm/x86/lib/libXpm.a",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/xpm/x86/lib/libXpm.lib",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/xpm/x86/lib-vc14/libXpm.lib",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/xpm/x64/lib/libXpm.a",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/xpm/x64/lib/libXpm.lib",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/xpm/x64/lib-vc14/libXpm.lib",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/GvimExt/gvimext_ming.rc",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/GvimExt/gvimext.rc",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/os_mac_rsrc/doc.icns",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/os_mac_rsrc/app.icns",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/src/os_mac_rsrc/doc-txt.icns",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/vimlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/hi22-action-make.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/vim32x32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/vimlogo.cdr",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/icons.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/hi16-action-make.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tools.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/vim16x16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/vim48x48.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/macros.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/vim16x16.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/vim32x32.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/vim48x48.gif",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/vimlogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/icons/Vim_8ColorsLace.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/icons/Vim_4ColorsLace.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/icons/Vim_32Colors.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/icons/README.txt.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/icons/Vim_8Colors.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/moo.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/tilde.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/pascal.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/rtf.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/sas.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/groff.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/lout.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/forth.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/nroff.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/css.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/rpl.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/fortran.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/initng.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/iss.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/mmix.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/elf.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/syntax/robots.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/ftplugin/ocaml.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/ftplugin/rpl.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/ftplugin/erlang.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/hebrewp_utf-8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/greek_cp737.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/canfr-win.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/serbian_cp1251.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/slovak_iso-8859-2.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/greek_iso-8859-7.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/hebrew_iso-8859-8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/serbian_iso-8859-5.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/accents.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/serbian_cp1250.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/esperanto_utf-8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/croatian_iso-8859-2.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/serbian_iso-8859-2.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/greek_utf-8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/croatian_cp1250.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/greek_cp1253.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/hebrewp_cp1255.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/keymap/slovak_cp1250.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_sr_rs.iso_8859-2.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_uk_ua.koi8-u.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_sr_rs.iso_8859-5.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_sk_sk.iso_8859-2.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_sl_si.latin2.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_af_af.latin1.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_ja_jp.euc-jp.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_pt_br.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_chinese_taiwan.950.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_polish_poland.1250.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_ko_kr.euckr.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_chinese_gb.936.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_fr_fr.latin1.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_zh_cn.gb2312.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_ca_es.latin1.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_it_it.latin1.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_czech_czech_republic.1250.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_slovak_slovak_republic.1250.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_es_es.latin1.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_no_no.latin1.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_pt_pt.latin1.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_pt_pt.utf-8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_hu_hu.iso_8859-2.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_pl_pl.iso_8859-2.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_japanese_japan.932.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_pt_pt.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_uk_ua.cp1251.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_fi_fi.latin1.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_cs_cz.iso_8859-2.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_nl_nl.latin1.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_sl_si.cp1250.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_ru_ru.koi8-r.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_sv_se.latin1.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_de_de.latin1.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_ca.utf-8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/lang/menu_ca_es.utf-8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/indent/tilde.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/indent/rpl.vim",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tools/vimspell.sh",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.sr.cp1250",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.fr",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.cs.cp1250",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.ja.euc",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.tr.iso9",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.es",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.sk.cp1250",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.hr",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.bar",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.hu.cp1250",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.hu",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.zh.euc",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.nb",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.pl.cp1250",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.ja.sjis",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.el",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.ko.euc",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.hr.cp1250",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.no",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.pt",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.it",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/README.txt.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.eo",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.sv",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.el.cp737",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.de",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.ru",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.ca",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.sk",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/README.el.cp737.txt",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.nl",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.pl",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/README.el.txt",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.cs",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.zh.big5",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/tutor/tutor.ru.cp1251",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/macros/hanoi.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/macros/urm.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/macros/README.txt.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/macros/maze.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/macros/urm/README.txt.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/macros/life/click.me.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/macros/maze/maze_5.78.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/macros/maze/poster.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/macros/maze/README.txt.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/macros/hanoi/poster.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/macros/hanoi/click.me.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/quotes.txt",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/vimtutor-ru.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/help.txt.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/vim-ru.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/map.txt",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/version6.txt",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/spell.txt",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/xxd-ru.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/vim-it.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/mlang.txt",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/evim-fr.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/eval.txt",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/vim-de.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/xxd-fr.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/vimdiff-it.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/makehtml.awk",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/xxd-pl.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/vim.man.info",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/evim-ru.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/vimdiff-pl.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/vim-fr.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/usr_24.txt",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/evim-pl.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/vimtutor-fr.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/evim-it.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/vimdiff-fr.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/vimtutor-pl.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/xxd-it.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/vim-pl.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/vimtutor-it.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/vimdiff-ru.1",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/os_vms.txt",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/doc/farsi.txt",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/en.ascii.spl",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/en.latin1.sug",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/en.utf-8.sug",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/en.ascii.sug",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/en.utf-8.spl",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/en.latin1.spl",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/gd/gd_GB.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/hr/hr_HR.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/nl/nl_NL.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/hu/hu_HU.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/tl/tl_PH.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/ca/ca_ES.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/es/es_MX.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/es/es_ES.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/ku/ku_TR.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/af/af_ZA.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/ru/ru_YO.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/ru/ru_RU.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/el/el_GR.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/tet/tet_ID.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/uk/uk_UA.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/nb/nb_NO.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/cs/cs_CZ.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/nn/nn_NO.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/fr/main.aap",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/fr/fr_FR.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/de/de_DE.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/de/de_20.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/de/de_AT.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/de/de_CH.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/de/de_19.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/sl/sl_SI.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/sw/sw_KE.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/tn/tn_ZA.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/da/da_DK.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/check/check_aa.aff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/check/check_bb.aff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/he/he_IL.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/la/la.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/mi/mi_NZ.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/pt/pt_BR.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/en/en_NZ.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/en/en_AU.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/ga/ga_IE.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/yi/yi_tr.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/it/it_IT.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/pl/pl_PL.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/gl/gl_ES.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/rw/rw_RW.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/bg/bg_BG.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/id/id_ID.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/sv/sv_SE.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/ms/ms_MY.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/fo/fo_FO.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/sk/sk_SK.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/runtime/spell/mg/mg_MG.diff",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/nsis/icons/vim_uninst_16c.ico",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/nsis/icons/enabled.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/nsis/icons/vim_16c.ico",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/nsis/icons/disabled.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/pixmaps/stock_vim_save_all.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/pixmaps/stock_vim_session_load.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/pixmaps/stock_vim_window_maximize.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/pixmaps/stock_vim_build_tags.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/pixmaps/stock_vim_shell.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/pixmaps/stock_vim_session_new.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/pixmaps/stock_vim_window_minimize.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/pixmaps/stock_vim_window_minimize_width.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/pixmaps/stock_vim_window_maximize_width.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/pixmaps/stock_vim_find_help.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/pixmaps/stock_vim_window_split.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/pixmaps/stock_vim_session_save.png",
        "/tmp/vanessa/spack-stage/spack-stage-vim-8.0.0503-zrw5ye5aiahnk75pd67y6nse2bx4hdoc/spack-src/pixmaps/stock_vim_window_split_vertical.png"
    ],
    "total_files": 2724
}