{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/glue-codes/openfast-cpp/src/OpenFAST.cpp": "#include \"OpenFAST.H\"\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nint fast::OpenFAST::AbortErrLev = ErrID_Fatal; // abort error level; compare with NWTC Library\n\n//Constructor \nfast::fastInputs::fastInputs():\nnTurbinesGlob(0),\ndryRun(false),\ndebug(false),\ntStart(-1.0),\nnEveryCheckPoint(-1),\ntMax(0.0),\ndtFAST(0.0),\nscStatus(false),\nscLibFile(\"\"),\nnumScInputs(0),\nnumScOutputs(0)\n{\n  //Nothing to do here\n}\n\n\n//Constructor\nfast::OpenFAST::OpenFAST():\nnTurbinesGlob(0),\nnTurbinesProc(0),\nscStatus(false),\nsimStart(fast::init),\ntimeZero(false)\n{\n}\n\ninline bool fast::OpenFAST::checkFileExists(const std::string& name) {\n  struct stat buffer;   \n  return (stat (name.c_str(), &buffer) == 0); \n}\n\nvoid fast::OpenFAST::init() {\n  // Temporary buffer to pass filenames to OpenFAST fortran subroutines\n  char currentFileName[INTERFACE_STRING_LENGTH];\n\n  allocateMemory();\n\n  if (!dryRun) {\n    switch (simStart) {\n\n    case fast::trueRestart:\n\n     for (int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n       /* note that this will set nt_global inside the FAST library */\n       std::copy(CheckpointFileRoot[iTurb].data(),\n                 CheckpointFileRoot[iTurb].data() + (CheckpointFileRoot[iTurb].size() + 1),\n                 currentFileName);\n       FAST_OpFM_Restart(\n           &iTurb, currentFileName, &AbortErrLev, &dtFAST, &numBlades[iTurb],\n           &numVelPtsBlade[iTurb], &ntStart, &cDriver_Input_from_FAST[iTurb],\n           &cDriver_Output_to_FAST[iTurb], &cDriverSC_Input_from_FAST[iTurb],\n           &cDriverSC_Output_to_FAST[iTurb], &ErrStat, ErrMsg);\n       checkError(ErrStat, ErrMsg);\n       nt_global = ntStart;\n\n       int nfpts = get_numForcePtsLoc(iTurb);\n       forceNodeVel[iTurb].resize(nfpts);\n       for (int k = 0; k < nfpts; k++) forceNodeVel[iTurb][k].resize(3) ;\n\n     }\n\n     if (nTurbinesProc > 0) velNodeDataFile = openVelocityDataFile(false);\n\n     if(scStatus) {\n\t sc->readRestartFile(nt_global);\n     }\n     \n     break ;\n   \n    case fast::init:\n     \n      // this calls the Init() routines of each module\n\n     for (int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n       std::copy(FASTInputFileName[iTurb].data(),\n                 FASTInputFileName[iTurb].data() + (FASTInputFileName[iTurb].size() + 1),\n                 currentFileName);\n       FAST_OpFM_Init(&iTurb, &tMax, currentFileName, &TurbID[iTurb],\n                      &numScOutputs, &numScInputs, &numForcePtsBlade[iTurb],\n                      &numForcePtsTwr[iTurb], TurbineBasePos[iTurb].data(),\n                      &AbortErrLev, &dtFAST, &numBlades[iTurb],\n                      &numVelPtsBlade[iTurb], &cDriver_Input_from_FAST[iTurb],\n                      &cDriver_Output_to_FAST[iTurb],\n                      &cDriverSC_Input_from_FAST[iTurb],\n                      &cDriverSC_Output_to_FAST[iTurb], &ErrStat, ErrMsg);\n       checkError(ErrStat, ErrMsg);\n\n       timeZero = true;\n\n       numVelPtsTwr[iTurb] = cDriver_Output_to_FAST[iTurb].u_Len - numBlades[iTurb]*numVelPtsBlade[iTurb] - 1;\n       if(numVelPtsTwr[iTurb] == 0) {\n           numForcePtsTwr[iTurb] = 0;\n           std::cout << \"Aerodyn doesn't want to calculate forces on the tower. All actuator points on the tower are turned off for turbine \" << turbineMapProcToGlob[iTurb] << \".\" << std::endl ;\n       }\n           \n\n       int nfpts = get_numForcePtsLoc(iTurb);\n       forceNodeVel[iTurb].resize(nfpts);\n       for (int k = 0; k < nfpts; k++) forceNodeVel[iTurb][k].resize(3) ;\n      \n       if ( isDebug() ) {\n       \t for (int iNode=0; iNode < get_numVelPtsLoc(iTurb); iNode++) {\n       \t   std::cout << \"Node \" << iNode << \" Position = \" << cDriver_Input_from_FAST[iTurb].pxVel[iNode] << \" \" << cDriver_Input_from_FAST[iTurb].pyVel[iNode] << \" \" << cDriver_Input_from_FAST[iTurb].pzVel[iNode] << \" \" << std::endl ;\n       \t }\n       }\n     }\n\n     if (nTurbinesProc > 0) velNodeDataFile = openVelocityDataFile(true);\n\n     break ;\n\n    case fast::restartDriverInitFAST:\n\n     for (int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n       std::copy(FASTInputFileName[iTurb].data(),\n                 FASTInputFileName[iTurb].data() + (FASTInputFileName[iTurb].size() + 1),\n                 currentFileName);\n       FAST_OpFM_Init(&iTurb, &tMax, currentFileName, &TurbID[iTurb],\n                      &numScOutputs, &numScInputs, &numForcePtsBlade[iTurb],\n                      &numForcePtsTwr[iTurb], TurbineBasePos[iTurb].data(),\n                      &AbortErrLev, &dtFAST, &numBlades[iTurb],\n                      &numVelPtsBlade[iTurb], &cDriver_Input_from_FAST[iTurb],\n                      &cDriver_Output_to_FAST[iTurb],\n                      &cDriverSC_Input_from_FAST[iTurb],\n                      &cDriverSC_Output_to_FAST[iTurb], &ErrStat, ErrMsg);\n       checkError(ErrStat, ErrMsg);\n\n       timeZero = true;\n\n       numVelPtsTwr[iTurb] = cDriver_Output_to_FAST[iTurb].u_Len - numBlades[iTurb]*numVelPtsBlade[iTurb] - 1;\n\n       int nfpts = get_numForcePtsLoc(iTurb);\n       forceNodeVel[iTurb].resize(nfpts);\n       for (int k = 0; k < nfpts; k++) forceNodeVel[iTurb][k].resize(3) ;\n\n       if ( isDebug() ) {\n       \t for (int iNode=0; iNode < get_numVelPtsLoc(iTurb); iNode++) {\n       \t   std::cout << \"Node \" << iNode << \" Position = \" << cDriver_Input_from_FAST[iTurb].pxVel[iNode] << \" \" << cDriver_Input_from_FAST[iTurb].pyVel[iNode] << \" \" << cDriver_Input_from_FAST[iTurb].pzVel[iNode] << \" \" << std::endl ;\n       \t }\n       }\n     }\n\n     int nTimesteps;\n     \n     if (nTurbinesProc > 0) {\n       readVelocityData(ntStart);\n     }\n     for (int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n       applyVelocityData(0, iTurb, cDriver_Output_to_FAST[iTurb], velNodeData[iTurb]);\n     }\n     solution0() ;\n\n     for (int iPrestart=0 ; iPrestart < ntStart; iPrestart++) {\n       for (int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n\t applyVelocityData(iPrestart, iTurb, cDriver_Output_to_FAST[iTurb], velNodeData[iTurb]);\n       }\n       stepNoWrite();\n     }\n\n     if (nTurbinesProc > 0) velNodeDataFile = openVelocityDataFile(false);\n\n     break;\n      \n    case fast::simStartType_END:\n\n      break;\n     \n    }\n\n  }\n}\n\nvoid fast::OpenFAST::solution0() {\n\n  if (!dryRun) {\n       // set wind speeds at initial locations\n    // for (int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n    //     setOutputsToFAST(cDriver_Input_from_FAST[iTurb], cDriver_Output_to_FAST[iTurb]);\n    // }\n     \n     if(scStatus) {\n\n       sc->init(nTurbinesGlob, numScInputs, numScOutputs);\n\n       sc->calcOutputs(scOutputsGlob);\n       fillScOutputsLoc();\n     }\n\n     for (int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n\n       FAST_OpFM_Solution0(&iTurb, &ErrStat, ErrMsg);\n       checkError(ErrStat, ErrMsg);\n\n     }\n\n     timeZero = false;\n\n     if (scStatus) {\n       fillScInputsGlob(); // Update inputs to super controller\n     }\n  }\n\n}\n\nvoid fast::OpenFAST::step() {\n\n  /* ******************************\n     set inputs from this code and call FAST:\n  ********************************* */\n\n   if(scStatus) {\n     sc->calcOutputs(scOutputsGlob);\n     fillScOutputsLoc();\n   }\n\n   for (int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n\n     //  set wind speeds at original locations \n     //     setOutputsToFAST(cDriver_Input_from_FAST[iTurb], cDriver_Output_to_FAST[iTurb]);\n\t \n     // this advances the states, calls CalcOutput, and solves for next inputs. Predictor-corrector loop is imbeded here:\n     // (note OpenFOAM could do subcycling around this step)\n\n     writeVelocityData(velNodeDataFile, iTurb, nt_global, cDriver_Input_from_FAST[iTurb], cDriver_Output_to_FAST[iTurb]);\n\n     if ( isDebug() ) {\n\n       std::ofstream fastcpp_velocity_file;\n       fastcpp_velocity_file.open(\"fastcpp_velocity.csv\") ;\n       fastcpp_velocity_file << \"# x, y, z, Vx, Vy, Vz\" << std::endl ;\n       for (int iNode=0; iNode < get_numVelPtsLoc(iTurb); iNode++) {\n\t fastcpp_velocity_file << cDriver_Input_from_FAST[iTurb].pxVel[iNode] << \", \" << cDriver_Input_from_FAST[iTurb].pyVel[iNode] << \", \" << cDriver_Input_from_FAST[iTurb].pzVel[iNode] << \", \" << cDriver_Output_to_FAST[iTurb].u[iNode] << \", \" << cDriver_Output_to_FAST[iTurb].v[iNode] << \", \" << cDriver_Output_to_FAST[iTurb].w[iNode] << \" \" << std::endl ;           \n       }\n       fastcpp_velocity_file.close() ;\n       \n     }\n     \n     FAST_OpFM_Step(&iTurb, &ErrStat, ErrMsg);\n     checkError(ErrStat, ErrMsg);\n\n     // Compute the force from the nacelle only if the drag coefficient is\n     //   greater than zero\n     if (nacelle_cd[iTurb]>0.) {\n\n                             calc_nacelle_force (\n                             \n                                 cDriver_Output_to_FAST[iTurb].u[0], \n                                 cDriver_Output_to_FAST[iTurb].v[0], \n                                 cDriver_Output_to_FAST[iTurb].w[0], \n                                 nacelle_cd[iTurb], \n                                 nacelle_area[iTurb], \n                                 air_density[iTurb], \n                                 cDriver_Input_from_FAST[iTurb].fx[0], \n                                 cDriver_Input_from_FAST[iTurb].fy[0], \n                                 cDriver_Input_from_FAST[iTurb].fz[0]\n\n                             );\n\n        }\n     \n     if ( isDebug() ) {\n       std::ofstream actuatorForcesFile;\n       actuatorForcesFile.open(\"actuator_forces.csv\") ;\n       actuatorForcesFile << \"# x, y, z, fx, fy, fz\" << std::endl ;\n       for (int iNode=0; iNode < get_numForcePtsLoc(iTurb); iNode++) {\n\t actuatorForcesFile << cDriver_Input_from_FAST[iTurb].pxForce[iNode] << \", \" << cDriver_Input_from_FAST[iTurb].pyForce[iNode] << \", \" << cDriver_Input_from_FAST[iTurb].pzForce[iNode] << \", \" << cDriver_Input_from_FAST[iTurb].fx[iNode] << \", \" << cDriver_Input_from_FAST[iTurb].fy[iNode] << \", \" << cDriver_Input_from_FAST[iTurb].fz[iNode] << \" \" << std::endl ;           \n       }\n       actuatorForcesFile.close() ;\n     }\n\n   }\n\n   if(scStatus) {\n     sc->updateStates(scInputsGlob); // Go from 'n' to 'n+1' based on input at previous time step\n     fillScInputsGlob(); // Update inputs to super controller for 'n+1'\n   }\n\n   nt_global = nt_global + 1;\n  \n  if ( (((nt_global - ntStart) % nEveryCheckPoint) == 0 )  && (nt_global != ntStart) ) {\n    // Use default FAST naming convention for checkpoint file\n    // <RootName>.<nt_global>\n    char dummyCheckPointRoot[INTERFACE_STRING_LENGTH] = \" \";\n    // Ensure that we have a null character\n    dummyCheckPointRoot[1] = 0;\n\n    if (nTurbinesProc > 0) backupVelocityDataFile(nt_global, velNodeDataFile);\n\n    for (int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n      FAST_CreateCheckpoint(&iTurb, dummyCheckPointRoot, &ErrStat, ErrMsg);\n      checkError(ErrStat, ErrMsg);\n    }\n    if(scStatus) {\n      if (fastMPIRank == 0) {\n          sc->writeRestartFile(nt_global);\n      }\n    }\n  }\n\n}\n\nvoid fast::OpenFAST::stepNoWrite() {\n\n  /* ******************************\n     set inputs from this code and call FAST:\n  ********************************* */\n\n   if(scStatus) {\n     sc->calcOutputs(scOutputsGlob);\n     fillScOutputsLoc();\n   }\n\n   for (int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n\n     //  set wind speeds at original locations \n     //     setOutputsToFAST(cDriver_Input_from_FAST[iTurb], cDriver_Output_to_FAST[iTurb]);\n\n     // this advances the states, calls CalcOutput, and solves for next inputs. Predictor-corrector loop is imbeded here:\n     // (note OpenFOAM could do subcycling around this step)\n     FAST_OpFM_Step(&iTurb, &ErrStat, ErrMsg);\n     checkError(ErrStat, ErrMsg);\n\n   }\n\n   if(scStatus) {\n     sc->updateStates(scInputsGlob); // Go from 'n' to 'n+1' based on input at previous time step\n     fillScInputsGlob(); // Update inputs to super controller for 'n+1'\n   }\n\n   nt_global = nt_global + 1;\n  \n}\n\nfast::OpenFAST::~OpenFAST(){\n}\n\nvoid fast::OpenFAST::calc_nacelle_force(\n        const float & u, \n        const float & v, \n        const float & w, \n        const float & cd, \n        const float & area, \n        const float & rho,\n        float & fx, \n        float & fy, \n        float & fz) {\n            // Calculate the force on the nacelle (fx,fy,fz) given the \n            //   velocity sampled at the nacelle point (u,v,w), \n            //   drag coefficient 'cd' and nacelle area 'area'\n    \n            // The velocity magnitude\n            float Vmag = std::sqrt(u * u + v * v + w * w);\n    \n            // Velocity correction based on Martinez-Tossas PhD Thesis 2017\n            // The correction samples the velocity at the center of the\n            // Gaussian kernel and scales it to obtain the inflow velocity \n            float epsilon_d = std::sqrt(2.0 / M_PI * cd * area);\n            float correction = 1. / (1.0 - cd * area /\n                                        (4.0 * M_PI * epsilon_d * epsilon_d));\n    \n            // Compute the force for each velocity component\n            fx = rho * 1./2. * cd * area * Vmag * u * correction * correction;\n            fy = rho * 1./2. * cd * area * Vmag * v * correction * correction;\n            fz = rho * 1./2. * cd * area * Vmag * w * correction * correction;\n        }\n\nvoid fast::OpenFAST::setInputs(const fast::fastInputs & fi ) {\n\n\n  mpiComm = fi.comm;\n\n  MPI_Comm_rank(mpiComm, &worldMPIRank);\n  MPI_Comm_group(mpiComm, &worldMPIGroup);\n\n  nTurbinesGlob = fi.nTurbinesGlob;\n\n    if (nTurbinesGlob > 0) {\n      \n      dryRun = fi.dryRun;\n      \n      debug = fi.debug;\n\n      tStart = fi.tStart;\n      simStart = fi.simStart;\n      nEveryCheckPoint = fi.nEveryCheckPoint;\n      tMax = fi.tMax;\n      loadSuperController(fi);\n      dtFAST = fi.dtFAST;\n      \n      ntStart = int(tStart/dtFAST);\n      \n      if (simStart == fast::restartDriverInitFAST) {\n\tnt_global = 0;\n      } else {\n\tnt_global = ntStart;\n      }\n      \n      globTurbineData.resize(nTurbinesGlob);\n      globTurbineData = fi.globTurbineData;\n\n    } else {\n      throw std::runtime_error(\"Number of turbines < 0 \");\n    }\n    \n}\n\nvoid fast::OpenFAST::checkError(const int ErrStat, const char * ErrMsg){\n\n   if (ErrStat != ErrID_None){\n\n      if (ErrStat >= AbortErrLev){\n\tthrow std::runtime_error(ErrMsg);\n      }\n\n   }\n\n}\n\nvoid fast::OpenFAST::setOutputsToFAST(OpFM_InputType_t cDriver_Input_from_FAST, OpFM_OutputType_t cDriver_Output_to_FAST){\n\n   // routine sets the u-v-w wind speeds used in FAST and the SuperController inputs\n\n   for (int j = 0; j < cDriver_Output_to_FAST.u_Len; j++){\n      cDriver_Output_to_FAST.u[j] = (float) 10.0*pow((cDriver_Input_from_FAST.pzVel[j] / 90.0), 0.2); // 0.2 power law wind profile using reference 10 m/s at 90 meters\n      cDriver_Output_to_FAST.v[j] = 0.0;\n      cDriver_Output_to_FAST.w[j] = 0.0;\n   }\n\n   // // call supercontroller\n   // for (int j = 0; j < cDriver_Output_to_FAST.SuperController_Len; j++){\n   //    cDriver_Output_to_FAST.SuperController[j] = (float) j; // set it somehow.... (would be set from the SuperController outputs)\n   // }\n\n}\n\nvoid fast::OpenFAST::getApproxHubPos(double* currentCoords, int iTurbGlob, int nSize) {\n\n  assert(nSize==3);\n  // Get hub position of Turbine 'iTurbGlob'\n  for(int i =0; i<nSize; ++i){\n    currentCoords[i] = globTurbineData[iTurbGlob].TurbineHubPos[i];\n  }\n}\n\n\nvoid fast::OpenFAST::getHubPos(double* currentCoords, int iTurbGlob, int nSize) {\n\n  assert(nSize==3);\n  // Get hub position of Turbine 'iTurbGlob'\n  int iTurbLoc = get_localTurbNo(iTurbGlob);\n  currentCoords[0] = cDriver_Input_from_FAST[iTurbLoc].pxVel[0] + TurbineBasePos[iTurbLoc][0] ;\n  currentCoords[1] = cDriver_Input_from_FAST[iTurbLoc].pyVel[0] + TurbineBasePos[iTurbLoc][1] ;\n  currentCoords[2] = cDriver_Input_from_FAST[iTurbLoc].pzVel[0] + TurbineBasePos[iTurbLoc][2] ;\n  \n}\n\nvoid fast::OpenFAST::getHubShftDir(double* hubShftVec, int iTurbGlob, int nSize) {\n\n  assert(nSize==3);\n  // Get hub shaft direction of current turbine - pointing downwind\n  int iTurbLoc = get_localTurbNo(iTurbGlob);\n  for(int i=0; i<nSize; i++){\n    hubShftVec[i] = cDriver_Input_from_FAST[iTurbLoc].pOrientation[i*3] ;\n  }\n}\n\n\nvoid fast::OpenFAST::getVelNodeCoordinates(double* currentCoords, int iNode, int iTurbGlob, int nSize) {\n\n  assert(nSize==3);\n  // Set coordinates at current node of current turbine \n  int iTurbLoc = get_localTurbNo(iTurbGlob);\n  for(int j=0; j < iTurbLoc; j++) iNode = iNode - get_numVelPtsLoc(iTurbLoc);\n  currentCoords[0] = cDriver_Input_from_FAST[iTurbLoc].pxVel[iNode] + TurbineBasePos[iTurbLoc][0] ;\n  currentCoords[1] = cDriver_Input_from_FAST[iTurbLoc].pyVel[iNode] + TurbineBasePos[iTurbLoc][1] ;\n  currentCoords[2] = cDriver_Input_from_FAST[iTurbLoc].pzVel[iNode] + TurbineBasePos[iTurbLoc][2] ;\n  \n}\n\nvoid fast::OpenFAST::getForceNodeCoordinates(double* currentCoords, int iNode, int iTurbGlob, int nSize) {\n\n  assert(nSize==3);\n  // Set coordinates at current node of current turbine \n  int iTurbLoc = get_localTurbNo(iTurbGlob);\n  currentCoords[0] = cDriver_Input_from_FAST[iTurbLoc].pxForce[iNode] + TurbineBasePos[iTurbLoc][0] ;\n  currentCoords[1] = cDriver_Input_from_FAST[iTurbLoc].pyForce[iNode] + TurbineBasePos[iTurbLoc][1] ;\n  currentCoords[2] = cDriver_Input_from_FAST[iTurbLoc].pzForce[iNode] + TurbineBasePos[iTurbLoc][2] ;\n\n}\n\nvoid fast::OpenFAST::getForceNodeOrientation(double* currentOrientation, int iNode, int iTurbGlob, int nSize) {\n\n  assert(nSize==9);\n  // Set orientation at current node of current turbine \n  int iTurbLoc = get_localTurbNo(iTurbGlob);\n  for(int j=0; j < iTurbLoc; j++) iNode = iNode - get_numForcePtsLoc(iTurbLoc);\n  for(int i=0;i<9;i++) {\n    currentOrientation[i] = cDriver_Input_from_FAST[iTurbLoc].pOrientation[iNode*9+i] ;\n  }\n\n}\n\nvoid fast::OpenFAST::getRelativeVelForceNode(double* currentVelocity, int iNode, int iTurbGlob, int nSize) {\n\n  assert(nSize==3);\n  // Get relative velocity at current node of current turbine\n  int iTurbLoc = get_localTurbNo(iTurbGlob);\n  for(int j=0; j < iTurbLoc; j++) iNode = iNode - get_numForcePtsLoc(iTurbLoc);\n\n  currentVelocity[0] = forceNodeVel[iTurbLoc][iNode][0] - cDriver_Input_from_FAST[iTurbLoc].xdotForce[iNode];\n  currentVelocity[1] = forceNodeVel[iTurbLoc][iNode][1] - cDriver_Input_from_FAST[iTurbLoc].ydotForce[iNode];\n  currentVelocity[2] = forceNodeVel[iTurbLoc][iNode][2] - cDriver_Input_from_FAST[iTurbLoc].zdotForce[iNode];\n}\n\n\nvoid fast::OpenFAST::getForce(double* currentForce, int iNode, int iTurbGlob, int nSize) {\n\n  assert(nSize==3);\n  // Set forces at current node of current turbine \n  int iTurbLoc = get_localTurbNo(iTurbGlob);\n  for(int j=0; j < iTurbLoc; j++) iNode = iNode - get_numForcePtsLoc(iTurbLoc);\n  currentForce[0] = -cDriver_Input_from_FAST[iTurbLoc].fx[iNode] ;\n  currentForce[1] = -cDriver_Input_from_FAST[iTurbLoc].fy[iNode] ;\n  currentForce[2] = -cDriver_Input_from_FAST[iTurbLoc].fz[iNode] ;\n\n}\n\ndouble fast::OpenFAST::getChord(int iNode, int iTurbGlob) {\n\n  // Return blade chord/tower diameter at current node of current turbine \n  int iTurbLoc = get_localTurbNo(iTurbGlob);\n  for(int j=0; j < iTurbLoc; j++) iNode = iNode - get_numForcePtsLoc(iTurbLoc);\n  return cDriver_Input_from_FAST[iTurbLoc].forceNodesChord[iNode] ;\n\n}\n\nvoid fast::OpenFAST::setVelocity(double* currentVelocity, int iNode, int iTurbGlob, int nSize) {\n\n  assert(nSize==3);\n  // Set velocity at current node of current turbine - \n  int iTurbLoc = get_localTurbNo(iTurbGlob);\n  for(int j=0; j < iTurbLoc; j++) iNode = iNode - get_numVelPtsLoc(iTurbLoc);\n  cDriver_Output_to_FAST[iTurbLoc].u[iNode] = currentVelocity[0];\n  cDriver_Output_to_FAST[iTurbLoc].v[iNode] = currentVelocity[1];\n  cDriver_Output_to_FAST[iTurbLoc].w[iNode] = currentVelocity[2];\n}\n\nvoid fast::OpenFAST::setVelocityForceNode(double* currentVelocity, int iNode, int iTurbGlob, int nSize) {\n\n  assert(nSize==3);\n  // Set velocity at current node of current turbine - \n  int iTurbLoc = get_localTurbNo(iTurbGlob);\n  for(int j=0; j < iTurbLoc; j++) iNode = iNode - get_numForcePtsLoc(iTurbLoc);\n\n  for(int i=0; i<nSize; ++i){\n    forceNodeVel[iTurbLoc][iNode][i] = currentVelocity[i];\n  }\n}\n\nvoid fast::OpenFAST::interpolateVel_ForceToVelNodes() {\n\n  // Interpolates the velocity from the force nodes to the velocity nodes\n  \n  for(int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n    // Hub location\n    cDriver_Output_to_FAST[iTurb].u[0] = forceNodeVel[iTurb][0][0];\n    cDriver_Output_to_FAST[iTurb].v[0] = forceNodeVel[iTurb][0][1];\n    cDriver_Output_to_FAST[iTurb].w[0] = forceNodeVel[iTurb][0][2];\n\n    if ( isDebug() ) {\n       std::ofstream actuatorVelFile;\n       actuatorVelFile.open(\"actuator_velocity.csv\") ;\n       actuatorVelFile << \"# x, y, z, Vx, Vy, Vz\" << std::endl ;\n       for (int iNode=0; iNode < get_numForcePtsLoc(iTurb); iNode++) {\n\t actuatorVelFile << cDriver_Input_from_FAST[iTurb].pxForce[iNode] << \", \" << cDriver_Input_from_FAST[iTurb].pyForce[iNode] << \", \" << cDriver_Input_from_FAST[iTurb].pzForce[iNode] << \", \" << forceNodeVel[iTurb][iNode][0] << \", \" << forceNodeVel[iTurb][iNode][1] << \", \" << forceNodeVel[iTurb][iNode][2] << \" \" << std::endl ;\n       }\n       actuatorVelFile.close() ;\n    }\n\n    // Do the blades first\n    int nBlades = get_numBladesLoc(iTurb);\n    for(int iBlade=0; iBlade < nBlades; iBlade++) {\n\n      // Create interpolating parameter - Distance from hub\n      int nForcePtsBlade = get_numForcePtsBladeLoc(iTurb);\n      std::vector<double> rDistForce(nForcePtsBlade) ;\n      for(int j=0; j < nForcePtsBlade; j++) {\n\tint iNodeForce = 1 + iBlade * nForcePtsBlade + j ; //The number of actuator force points is always the same for all blades\n\trDistForce[j] = std::sqrt( \n                             (cDriver_Input_from_FAST[iTurb].pxForce[iNodeForce] - cDriver_Input_from_FAST[iTurb].pxForce[0])*(cDriver_Input_from_FAST[iTurb].pxForce[iNodeForce] - cDriver_Input_from_FAST[iTurb].pxForce[0])  \n\t\t           + (cDriver_Input_from_FAST[iTurb].pyForce[iNodeForce] - cDriver_Input_from_FAST[iTurb].pyForce[0])*(cDriver_Input_from_FAST[iTurb].pyForce[iNodeForce] - cDriver_Input_from_FAST[iTurb].pyForce[0])  \n\t\t           + (cDriver_Input_from_FAST[iTurb].pzForce[iNodeForce] - cDriver_Input_from_FAST[iTurb].pzForce[0])*(cDriver_Input_from_FAST[iTurb].pzForce[iNodeForce] - cDriver_Input_from_FAST[iTurb].pzForce[0])  \t\t\t\n\t\t\t    );\n      }\n\n      // Interpolate to the velocity nodes\n      int nVelPtsBlade = get_numVelPtsBladeLoc(iTurb);\n      for(int j=0; j < nVelPtsBlade; j++) {\n\tint iNodeVel = 1 + iBlade * nVelPtsBlade + j ; //Assumes the same number of velocity (Aerodyn) nodes for all blades\n\tdouble rDistVel = std::sqrt( \n\t\t\t      (cDriver_Input_from_FAST[iTurb].pxVel[iNodeVel] - cDriver_Input_from_FAST[iTurb].pxVel[0])*(cDriver_Input_from_FAST[iTurb].pxVel[iNodeVel] - cDriver_Input_from_FAST[iTurb].pxVel[0])  \n\t\t            + (cDriver_Input_from_FAST[iTurb].pyVel[iNodeVel] - cDriver_Input_from_FAST[iTurb].pyVel[0])*(cDriver_Input_from_FAST[iTurb].pyVel[iNodeVel] - cDriver_Input_from_FAST[iTurb].pyVel[0])  \n\t\t            + (cDriver_Input_from_FAST[iTurb].pzVel[iNodeVel] - cDriver_Input_from_FAST[iTurb].pzVel[0])*(cDriver_Input_from_FAST[iTurb].pzVel[iNodeVel] - cDriver_Input_from_FAST[iTurb].pzVel[0])  \t\t\t\n\t\t\t      );\n\t//Find nearest two force nodes\n\tint jForceLower = 0;\n\twhile ( (rDistForce[jForceLower+1] < rDistVel) && ( jForceLower < (nForcePtsBlade-2)) )   {\n\t  jForceLower = jForceLower + 1;\n\t}\n\tint iNodeForceLower = 1 + iBlade * nForcePtsBlade + jForceLower ; \n\tdouble rInterp = (rDistVel - rDistForce[jForceLower])/(rDistForce[jForceLower+1]-rDistForce[jForceLower]);\n\tcDriver_Output_to_FAST[iTurb].u[iNodeVel] = forceNodeVel[iTurb][iNodeForceLower][0] + rInterp * (forceNodeVel[iTurb][iNodeForceLower+1][0] - forceNodeVel[iTurb][iNodeForceLower][0] );\n\tcDriver_Output_to_FAST[iTurb].v[iNodeVel] = forceNodeVel[iTurb][iNodeForceLower][1] + rInterp * (forceNodeVel[iTurb][iNodeForceLower+1][1] - forceNodeVel[iTurb][iNodeForceLower][1] );\n\tcDriver_Output_to_FAST[iTurb].w[iNodeVel] = forceNodeVel[iTurb][iNodeForceLower][2] + rInterp * (forceNodeVel[iTurb][iNodeForceLower+1][2] - forceNodeVel[iTurb][iNodeForceLower][2] );\n      }\n    }\n\n    // Now the tower if present and used\n    int nVelPtsTower = get_numVelPtsTwrLoc(iTurb);\n    if ( nVelPtsTower > 0 ) {\n\n      // Create interpolating parameter - Distance from first node from ground\n      int nForcePtsTower = get_numForcePtsTwrLoc(iTurb);\n      std::vector<double> hDistForce(nForcePtsTower) ;\n      int iNodeBotTowerForce = 1 + nBlades * get_numForcePtsBladeLoc(iTurb); // The number of actuator force points is always the same for all blades\n      for(int j=0; j < nForcePtsTower; j++) {\n\tint iNodeForce = iNodeBotTowerForce + j ; \n\thDistForce[j] = std::sqrt( \n\t\t\t     (cDriver_Input_from_FAST[iTurb].pxForce[iNodeForce] - cDriver_Input_from_FAST[iTurb].pxForce[iNodeBotTowerForce])*(cDriver_Input_from_FAST[iTurb].pxForce[iNodeForce] - cDriver_Input_from_FAST[iTurb].pxForce[iNodeBotTowerForce])  \n                           + (cDriver_Input_from_FAST[iTurb].pyForce[iNodeForce] - cDriver_Input_from_FAST[iTurb].pyForce[iNodeBotTowerForce])*(cDriver_Input_from_FAST[iTurb].pyForce[iNodeForce] - cDriver_Input_from_FAST[iTurb].pyForce[iNodeBotTowerForce])  \n\t\t\t   + (cDriver_Input_from_FAST[iTurb].pzForce[iNodeForce] - cDriver_Input_from_FAST[iTurb].pzForce[iNodeBotTowerForce])*(cDriver_Input_from_FAST[iTurb].pzForce[iNodeForce] - cDriver_Input_from_FAST[iTurb].pzForce[iNodeBotTowerForce])\t\n\t\t\t    );\n      }\n      \n      \n      int iNodeBotTowerVel = 1 + nBlades * get_numVelPtsBladeLoc(iTurb); // Assumes the same number of velocity (Aerodyn) nodes for all blades\n      for(int j=0; j < nVelPtsTower; j++) {\n\tint iNodeVel = iNodeBotTowerVel + j ; \n\tdouble hDistVel = std::sqrt( \n\t\t\t       (cDriver_Input_from_FAST[iTurb].pxVel[iNodeVel] - cDriver_Input_from_FAST[iTurb].pxVel[iNodeBotTowerVel])*(cDriver_Input_from_FAST[iTurb].pxVel[iNodeVel] - cDriver_Input_from_FAST[iTurb].pxVel[iNodeBotTowerVel])  \n                             + (cDriver_Input_from_FAST[iTurb].pyVel[iNodeVel] - cDriver_Input_from_FAST[iTurb].pyVel[iNodeBotTowerVel])*(cDriver_Input_from_FAST[iTurb].pyVel[iNodeVel] - cDriver_Input_from_FAST[iTurb].pyVel[iNodeBotTowerVel])  \n                             + (cDriver_Input_from_FAST[iTurb].pzVel[iNodeVel] - cDriver_Input_from_FAST[iTurb].pzVel[iNodeBotTowerVel])*(cDriver_Input_from_FAST[iTurb].pzVel[iNodeVel] - cDriver_Input_from_FAST[iTurb].pzVel[iNodeBotTowerVel])  \t\t\t\n\t                      );\n\t//Find nearest two force nodes\n\tint jForceLower = 0;\n\twhile ( (hDistForce[jForceLower+1] < hDistVel) && ( jForceLower < (nForcePtsTower-2)) )   {\n\t  jForceLower = jForceLower + 1;\n\t}\n\tint iNodeForceLower = iNodeBotTowerForce + jForceLower ; \n\tdouble rInterp = (hDistVel - hDistForce[jForceLower])/(hDistForce[jForceLower+1]-hDistForce[jForceLower]);\n\tcDriver_Output_to_FAST[iTurb].u[iNodeVel] = forceNodeVel[iTurb][iNodeForceLower][0] + rInterp * (forceNodeVel[iTurb][iNodeForceLower+1][0] - forceNodeVel[iTurb][iNodeForceLower][0] );\n\tcDriver_Output_to_FAST[iTurb].v[iNodeVel] = forceNodeVel[iTurb][iNodeForceLower][1] + rInterp * (forceNodeVel[iTurb][iNodeForceLower+1][1] - forceNodeVel[iTurb][iNodeForceLower][1] );\n\tcDriver_Output_to_FAST[iTurb].w[iNodeVel] = forceNodeVel[iTurb][iNodeForceLower][2] + rInterp * (forceNodeVel[iTurb][iNodeForceLower+1][2] - forceNodeVel[iTurb][iNodeForceLower][2] );\n      }\n    }    \n    \n  }\n  \n}\n\nvoid fast::OpenFAST::computeTorqueThrust(int iTurbGlob, std::vector<double> & torque, std::vector<double> & thrust) {\n\n    //Compute the torque and thrust based on the forces at the actuator nodes\n    std::vector<double> relLoc(3,0.0);\n    std::vector<double> rPerpShft(3);\n    thrust[0] = 0.0; thrust[1] = 0.0; thrust[2] = 0.0;\n    torque[0] = 0.0; torque[1] = 0.0; torque[2] = 0.0;    \n    \n    std::vector<double> hubShftVec(3);\n    getHubShftDir(hubShftVec, iTurbGlob);\n\n    int iTurbLoc = get_localTurbNo(iTurbGlob) ;\n    for (int k=0; k < get_numBladesLoc(iTurbLoc); k++) {\n        for (int j=0; j < numForcePtsBlade[iTurbLoc]; j++) {\n            int iNode = 1 + numForcePtsBlade[iTurbLoc]*k + j ;\n            \n            thrust[0] = thrust[0] + cDriver_Input_from_FAST[iTurbLoc].fx[iNode] ;\n            thrust[1] = thrust[1] + cDriver_Input_from_FAST[iTurbLoc].fy[iNode] ;\n            thrust[2] = thrust[2] + cDriver_Input_from_FAST[iTurbLoc].fz[iNode] ;\n\n            relLoc[0] = cDriver_Input_from_FAST[iTurbLoc].pxForce[iNode] - cDriver_Input_from_FAST[iTurbLoc].pxForce[0] ;\n            relLoc[1] = cDriver_Input_from_FAST[iTurbLoc].pyForce[iNode] - cDriver_Input_from_FAST[iTurbLoc].pyForce[0];\n            relLoc[2] = cDriver_Input_from_FAST[iTurbLoc].pzForce[iNode] - cDriver_Input_from_FAST[iTurbLoc].pzForce[0];            \n\t    \n\t    double rDotHubShftVec = relLoc[0]*hubShftVec[0] + relLoc[1]*hubShftVec[1] + relLoc[2]*hubShftVec[2]; \n\t    for (int j=0; j < 3; j++)  rPerpShft[j] = relLoc[j] - rDotHubShftVec * hubShftVec[j];\n\n            torque[0] = torque[0] + rPerpShft[1] * cDriver_Input_from_FAST[iTurbLoc].fz[iNode] - rPerpShft[2] * cDriver_Input_from_FAST[iTurbLoc].fy[iNode] + cDriver_Input_from_FAST[iTurbLoc].momentx[iNode] ;\n            torque[1] = torque[1] + rPerpShft[2] * cDriver_Input_from_FAST[iTurbLoc].fx[iNode] - rPerpShft[0] * cDriver_Input_from_FAST[iTurbLoc].fz[iNode] + cDriver_Input_from_FAST[iTurbLoc].momenty[iNode] ;\n            torque[2] = torque[2] + rPerpShft[0] * cDriver_Input_from_FAST[iTurbLoc].fy[iNode] - rPerpShft[1] * cDriver_Input_from_FAST[iTurbLoc].fx[iNode] + cDriver_Input_from_FAST[iTurbLoc].momentz[iNode] ;\n            \n        }\n    }\n}\n\nfast::ActuatorNodeType fast::OpenFAST::getVelNodeType(int iTurbGlob, int iNode) {\n  // Return the type of velocity node for the given node number. The node ordering (from FAST) is \n  // Node 0 - Hub node\n  // Blade 1 nodes\n  // Blade 2 nodes\n  // Blade 3 nodes\n  // Tower nodes\n\n  int iTurbLoc = get_localTurbNo(iTurbGlob);\n  for(int j=0; j < iTurbLoc; j++) iNode = iNode - get_numVelPtsLoc(iTurbGlob);\n  if (iNode) {\n    if ( (iNode + 1 - (get_numVelPts(iTurbLoc) - get_numVelPtsTwr(iTurbLoc)) ) > 0) {\n      return TOWER; \n    }\n    else {\n      return BLADE;\n    }\n  }\n  else {\n    return HUB; \n  }\n  \n}\n\nfast::ActuatorNodeType fast::OpenFAST::getForceNodeType(int iTurbGlob, int iNode) {\n  // Return the type of actuator force node for the given node number. The node ordering (from FAST) is \n  // Node 0 - Hub node\n  // Blade 1 nodes\n  // Blade 2 nodes\n  // Blade 3 nodes\n  // Tower nodes\n\n  int iTurbLoc = get_localTurbNo(iTurbGlob);\n  for(int j=0; j < iTurbLoc; j++) iNode = iNode - get_numForcePtsLoc(iTurbGlob);\n  if (iNode) {\n    if ( (iNode + 1 - (get_numForcePts(iTurbLoc) - get_numForcePtsTwr(iTurbLoc)) ) > 0) {\n      return TOWER; \n    }\n    else {\n      return BLADE;\n    }\n  }\n  else {\n    return HUB; \n  }\n  \n}\n\nvoid fast::OpenFAST::allocateMemory() {\n\t\n  for (int iTurb=0; iTurb < nTurbinesGlob; iTurb++) {\n    if (dryRun) {\n      if(worldMPIRank == 0) {\n\tstd::cout << \"iTurb = \" << iTurb << \" turbineMapGlobToProc[iTurb] = \" << turbineMapGlobToProc[iTurb] << std::endl ;\n      }\n    }\n    if(worldMPIRank == turbineMapGlobToProc[iTurb]) {\n      turbineMapProcToGlob[nTurbinesProc] = iTurb;\n      reverseTurbineMapProcToGlob[iTurb] = nTurbinesProc;\n      nTurbinesProc++ ;\n    }\n    turbineSetProcs.insert(turbineMapGlobToProc[iTurb]);\n  }\n\n  int nProcsWithTurbines=0;\n  turbineProcs.resize(turbineSetProcs.size());\n\n  for (std::set<int>::const_iterator p = turbineSetProcs.begin(); p != turbineSetProcs.end(); p++) {\n    turbineProcs[nProcsWithTurbines] = *p;\n    nProcsWithTurbines++ ;\n  }\n\n  if (dryRun) {\n    if (nTurbinesProc > 0) {\n      std::ofstream turbineAllocFile;\n      turbineAllocFile.open(\"turbineAlloc.\" + std::to_string(worldMPIRank) + \".txt\") ;\n      for (int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n\tturbineAllocFile << \"Proc \" << worldMPIRank << \" loc iTurb \" << iTurb << \" glob iTurb \" << turbineMapProcToGlob[iTurb] << std::endl ;\n      }\n      turbineAllocFile.flush();\n      turbineAllocFile.close() ;\n    }\n  \n  }\n\n    \n  // Construct a group containing all procs running atleast 1 turbine in FAST\n  MPI_Group_incl(worldMPIGroup, nProcsWithTurbines, &turbineProcs[0], &fastMPIGroup) ;\n  int fastMPIcommTag = MPI_Comm_create(mpiComm, fastMPIGroup, &fastMPIComm);\n  if (MPI_COMM_NULL != fastMPIComm) {\n    MPI_Comm_rank(fastMPIComm, &fastMPIRank);\n  }\n\n  TurbID.resize(nTurbinesProc);\n  TurbineBasePos.resize(nTurbinesProc);\n  FASTInputFileName.resize(nTurbinesProc);\n  CheckpointFileRoot.resize(nTurbinesProc);\n  nacelle_cd.resize(nTurbinesProc);\n  nacelle_area.resize(nTurbinesProc);\n  air_density.resize(nTurbinesProc);\n  numBlades.resize(nTurbinesProc);\n  numForcePtsBlade.resize(nTurbinesProc);\n  numForcePtsTwr.resize(nTurbinesProc);\n  numVelPtsBlade.resize(nTurbinesProc);\n  numVelPtsTwr.resize(nTurbinesProc);\n  forceNodeVel.resize(nTurbinesProc);\n  \n  for (int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n    \n    TurbineBasePos[iTurb].resize(3);\n\n    int globProc = turbineMapProcToGlob[iTurb];\n    TurbID[iTurb] = globTurbineData[globProc].TurbID;\n    FASTInputFileName[iTurb] = globTurbineData[globProc].FASTInputFileName ;\n    CheckpointFileRoot[iTurb] = globTurbineData[globProc].FASTRestartFileName ;\n    for(int i=0;i<3;i++) {\n      TurbineBasePos[iTurb][i] = globTurbineData[globProc].TurbineBasePos[i];\n    }\n    numForcePtsBlade[iTurb] = globTurbineData[globProc].numForcePtsBlade;\n    numForcePtsTwr[iTurb] = globTurbineData[globProc].numForcePtsTwr;\n    nacelle_cd[iTurb] = globTurbineData[globProc].nacelle_cd;\n    nacelle_area[iTurb] = globTurbineData[globProc].nacelle_area;\n    air_density[iTurb] = globTurbineData[globProc].air_density;\n\n  }\n\n  // Allocate memory for Turbine datastructure for all turbines\n  FAST_AllocateTurbines(&nTurbinesProc, &ErrStat, ErrMsg);\n  \n  // Allocate memory for OpFM Input types in FAST\n  cDriver_Input_from_FAST.resize(nTurbinesProc) ;\n  cDriver_Output_to_FAST.resize(nTurbinesProc) ;\n  \n  cDriverSC_Input_from_FAST.resize(nTurbinesProc) ;\n  cDriverSC_Output_to_FAST.resize(nTurbinesProc) ;\n\n}\n\nvoid fast::OpenFAST::allocateTurbinesToProcsSimple() {\n  \n  // Allocate turbines to each processor - round robin fashion\n  int nProcs ;\n  MPI_Comm_size(mpiComm, &nProcs);\n  for(int j = 0; j < nTurbinesGlob; j++)  turbineMapGlobToProc[j] = j % nProcs ;\n  \n}\n\nvoid fast::OpenFAST::end() {\n\n  // Deallocate types we allocated earlier\n  \n  if (nTurbinesProc > 0) closeVelocityDataFile(nt_global, velNodeDataFile);\n  \n  if ( !dryRun) {\n    bool stopTheProgram = false;\n    for (int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n      FAST_End(&iTurb, &stopTheProgram);\n    }\n    FAST_DeallocateTurbines(&ErrStat, ErrMsg);\n  }\n  \n  MPI_Group_free(&fastMPIGroup);\n  if (MPI_COMM_NULL != fastMPIComm) {\n    MPI_Comm_free(&fastMPIComm);\n  }\n  MPI_Group_free(&worldMPIGroup);\n  \n  if(scStatus) {\n    \n    destroy_SuperController(sc) ;\n    \n    if(scLibHandle != NULL) {\n      // close the library\n      std::cout << \"Closing library...\\n\";\n      dlclose(scLibHandle);\n    }\n    \n  }\n  \n}\n\nvoid fast::OpenFAST::readVelocityData(int nTimesteps) {\n  \n  int nTurbines;\n  \n  hid_t velDataFile = H5Fopen((\"velDatafile.\" + std::to_string(worldMPIRank) + \".h5\").c_str(), H5F_ACC_RDWR, H5P_DEFAULT);\n  \n  {\n    hid_t attr = H5Aopen(velDataFile, \"nTurbines\", H5P_DEFAULT);\n    herr_t ret = H5Aread(attr, H5T_NATIVE_INT, &nTurbines) ;\n    H5Aclose(attr);\n\n  }\n\n  // Allocate memory and read the velocity data. \n  velNodeData.resize(nTurbines);\n  for (int iTurb=0; iTurb < nTurbines; iTurb++) {\n    int nVelPts = get_numVelPtsLoc(iTurb) ;\n    velNodeData[iTurb].resize(nTimesteps*nVelPts*6) ;\n    hid_t dset_id = H5Dopen2(velDataFile, (\"/turbine\" + std::to_string(iTurb)).c_str(), H5P_DEFAULT);\n    hid_t dspace_id = H5Dget_space(dset_id);\n\n    hsize_t start[3]; start[1] = 0; start[2] = 0;\n    hsize_t count[3]; count[0] = 1; count[1] = nVelPts; count[2] = 6;\n    hid_t mspace_id = H5Screate_simple(3, count, NULL); \n\n    for (int iStep=0; iStep < nTimesteps; iStep++) {\n      start[0] = iStep;\n      H5Sselect_hyperslab(dspace_id, H5S_SELECT_SET, start, NULL, count, NULL);\n      herr_t status = H5Dread(dset_id, H5T_NATIVE_DOUBLE, mspace_id, dspace_id, H5P_DEFAULT, &velNodeData[iTurb][iStep*nVelPts*6] );\n    }\n    herr_t status = H5Dclose(dset_id);\n\n\n  }\n  \n}\n\nhid_t fast::OpenFAST::openVelocityDataFile(bool createFile) {\n\n  hid_t velDataFile;\n  if (createFile) {\n    // Open the file in create mode\n    velDataFile = H5Fcreate((\"velDatafile.\" + std::to_string(worldMPIRank) + \".h5\").c_str(), H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);\n\n    {\n      hsize_t dims[1];\n      dims[0] = 1;\n      hid_t dataSpace = H5Screate_simple(1, dims, NULL);\n      hid_t attr = H5Acreate2(velDataFile, \"nTurbines\", H5T_NATIVE_INT, dataSpace, H5P_DEFAULT, H5P_DEFAULT) ;\n      herr_t status = H5Awrite(attr, H5T_NATIVE_INT, &nTurbinesProc);\n      status = H5Aclose(attr);\n      status = H5Sclose(dataSpace);\n      \n      dataSpace = H5Screate_simple(1, dims, NULL);\n      attr = H5Acreate2(velDataFile, \"nTimesteps\", H5T_NATIVE_INT, dataSpace, H5P_DEFAULT, H5P_DEFAULT) ;\n      status = H5Aclose(attr);\n      status = H5Sclose(dataSpace);\n    }\n\n    int ntMax = tMax/dtFAST ;\n\n    for (int iTurb = 0; iTurb < nTurbinesProc; iTurb++) {\n      int nVelPts = get_numVelPtsLoc(iTurb);\n      hsize_t dims[3];\n      dims[0] = ntMax; dims[1] = nVelPts; dims[2] = 6 ;\n\n      hsize_t chunk_dims[3];\n      chunk_dims[0] = 1; chunk_dims[1] = nVelPts; chunk_dims[2] = 6;\n      hid_t dcpl_id = H5Pcreate(H5P_DATASET_CREATE);\n      H5Pset_chunk(dcpl_id, 3, chunk_dims);\n\n      hid_t dataSpace = H5Screate_simple(3, dims, NULL);\n      hid_t dataSet = H5Dcreate(velDataFile, (\"/turbine\" + std::to_string(iTurb)).c_str(), H5T_NATIVE_DOUBLE, dataSpace, H5P_DEFAULT, dcpl_id, H5P_DEFAULT);    \n\n      herr_t status = H5Pclose(dcpl_id);\n      status = H5Dclose(dataSet);\n      status = H5Sclose(dataSpace);\n    }\n    \n  } else {\n    // Open the file in append mode\n    velDataFile = H5Fopen((\"velDatafile.\" + std::to_string(worldMPIRank) + \".h5\").c_str(), H5F_ACC_RDWR, H5P_DEFAULT);\n  }\n\n  return velDataFile;\n\n}\n\nherr_t fast::OpenFAST::closeVelocityDataFile(int nt_global, hid_t velDataFile) {\n\n  herr_t status = H5Fclose(velDataFile) ;\n  return status;\n}\n\n\nvoid fast::OpenFAST::backupVelocityDataFile(int curTimeStep, hid_t & velDataFile) {\n\n    closeVelocityDataFile(curTimeStep, velDataFile);\n        \n    std::ifstream source(\"velDatafile.\" + std::to_string(worldMPIRank) + \".h5\", std::ios::binary);\n    std::ofstream dest(\"velDatafile.\" + std::to_string(worldMPIRank) + \".h5.\" + std::to_string(curTimeStep) + \".bak\", std::ios::binary);\n\n    dest << source.rdbuf();\n    source.close();\n    dest.close();\n\n    velDataFile = openVelocityDataFile(false);\n}\n\nvoid fast::OpenFAST::writeVelocityData(hid_t h5File, int iTurb, int iTimestep, OpFM_InputType_t iData, OpFM_OutputType_t oData) {\n\n  hsize_t start[3]; start[0] = iTimestep; start[1] = 0; start[2] = 0;\n  int nVelPts = get_numVelPtsLoc(iTurb) ;\n  hsize_t count[3]; count[0] = 1; count[1] = nVelPts; count[2] = 6;\n\n  std::vector<double> tmpVelData;\n  tmpVelData.resize(nVelPts * 6);\n\n  for (int iNode=0 ; iNode < nVelPts; iNode++) {\n    tmpVelData[iNode*6 + 0] = iData.pxVel[iNode];\n    tmpVelData[iNode*6 + 1] = iData.pyVel[iNode];\n    tmpVelData[iNode*6 + 2] = iData.pzVel[iNode];\n    tmpVelData[iNode*6 + 3] = oData.u[iNode];\n    tmpVelData[iNode*6 + 4] = oData.v[iNode];\n    tmpVelData[iNode*6 + 5] = oData.w[iNode];\n  }\n  \n  hid_t dset_id = H5Dopen2(h5File, (\"/turbine\" + std::to_string(iTurb)).c_str(), H5P_DEFAULT);\n  hid_t dspace_id = H5Dget_space(dset_id);\n  H5Sselect_hyperslab(dspace_id, H5S_SELECT_SET, start, NULL, count, NULL);\n  hid_t mspace_id = H5Screate_simple(3, count, NULL);  \n  H5Dwrite(dset_id, H5T_NATIVE_DOUBLE, mspace_id, dspace_id, H5P_DEFAULT, tmpVelData.data());\n\n  H5Dclose(dset_id);\n  H5Sclose(dspace_id);\n  H5Sclose(mspace_id);\n\n  hid_t attr_id = H5Aopen_by_name(h5File, \".\", \"nTimesteps\", H5P_DEFAULT, H5P_DEFAULT);\n  herr_t status = H5Awrite(attr_id, H5T_NATIVE_INT, &iTimestep);\n  status = H5Aclose(attr_id);\n\n}\n\nvoid fast::OpenFAST::applyVelocityData(int iPrestart, int iTurb, OpFM_OutputType_t cDriver_Output_to_FAST, std::vector<double> & velData) {\n\n  int nVelPts = get_numVelPtsLoc(iTurb);\n  for (int j = 0; j < nVelPts; j++){\n    cDriver_Output_to_FAST.u[j] = velData[(iPrestart*nVelPts+j)*6 + 3]; \n    cDriver_Output_to_FAST.v[j] = velData[(iPrestart*nVelPts+j)*6 + 4];\n    cDriver_Output_to_FAST.w[j] = velData[(iPrestart*nVelPts+j)*6 + 5];\n   }\n\n}\n\nvoid fast::OpenFAST::loadSuperController(const fast::fastInputs & fi) {\n\n  if(fi.scStatus) {\n\n    scStatus = fi.scStatus;\n    scLibFile = fi.scLibFile;\n\n    // open the library\n    scLibHandle = dlopen(scLibFile.c_str(), RTLD_LAZY);\n    if (!scLibHandle) {\n      std::cerr << \"Cannot open library: \" << dlerror() << '\\n';\n    }\n    \n    create_SuperController = (create_sc_t*) dlsym(scLibHandle, \"create_sc\");\n    // reset errors\n    dlerror();\n    const char *dlsym_error = dlerror();\n    if (dlsym_error) {\n      std::cerr << \"Cannot load symbol 'create_sc': \" << dlsym_error << '\\n';\n      dlclose(scLibHandle);\n    }\n\n    destroy_SuperController = (destroy_sc_t*) dlsym(scLibHandle, \"destroy_sc\");\n    // reset errors\n    dlerror();\n    const char *dlsym_error_us = dlerror();\n    if (dlsym_error_us) {\n      std::cerr << \"Cannot load symbol 'destroy_sc': \" << dlsym_error_us << '\\n';\n      dlclose(scLibHandle);\n    }\n\n    sc = create_SuperController() ;\n\n    numScInputs = fi.numScInputs;\n    numScOutputs = fi.numScOutputs;\n\n    if ( (numScInputs > 0) && (numScOutputs > 0)) {\n      scOutputsGlob.resize(nTurbinesGlob*numScOutputs) ;\n      scInputsGlob.resize(nTurbinesGlob*numScInputs) ;\n      for (int iTurb=0; iTurb < nTurbinesGlob; iTurb++) {\n\tfor(int iInput=0; iInput < numScInputs; iInput++) {\n\t  scInputsGlob[iTurb*numScInputs + iInput] = 0.0 ; // Initialize to zero\n\t}\n\tfor(int iOutput=0; iOutput < numScOutputs; iOutput++) {\n\t  scOutputsGlob[iTurb*numScOutputs + iOutput] = 0.0 ; // Initialize to zero\n\t}\n      }\n\n    } else {\n      std::cerr <<  \"Make sure numScInputs and numScOutputs are greater than zero\" << std::endl;\n    }\n    \n   } else {\n    scStatus = false;\n    numScInputs = 0;\n    numScOutputs = 0;\n   }\n\n}\n\n\nvoid fast::OpenFAST::fillScInputsGlob() {\n  \n  // Fills the global array containing inputs to the supercontroller from all turbines\n\n  for(int iTurb=0; iTurb < nTurbinesGlob; iTurb++) {\n    for(int iInput=0; iInput < numScInputs; iInput++) {\n      scInputsGlob[iTurb*numScInputs + iInput] = 0.0; // Initialize to zero \n    }\n  }\n  \n  for(int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n    for(int iInput=0; iInput < numScInputs; iInput++) {\n      scInputsGlob[turbineMapProcToGlob[iTurb]*numScInputs + iInput] = cDriverSC_Input_from_FAST[iTurb].toSC[iInput] ;\n    }\n  }\n  \n  if (MPI_COMM_NULL != fastMPIComm) {\n    MPI_Allreduce(MPI_IN_PLACE, scInputsGlob.data(), numScInputs*nTurbinesGlob, MPI_DOUBLE, MPI_SUM, fastMPIComm) ;\n  }\n\n}\n\n\nvoid fast::OpenFAST::fillScOutputsLoc() {\n  \n  // Fills the local array containing outputs from the supercontroller to each turbine\n  \n  for(int iTurb=0; iTurb < nTurbinesProc; iTurb++) {\n    for(int iOutput=0; iOutput < numScOutputs; iOutput++) {\n      cDriverSC_Output_to_FAST[iTurb].fromSC[iOutput] = scOutputsGlob[turbineMapProcToGlob[iTurb]*numScOutputs + iOutput] ;\n    }\n  }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/modules/icefloe/src/interfaces/Console/NWTC_Base_reduced.f90": "!**********************************************************************************************************************************\n! LICENSING\n! Copyright (C) 2013  National Renewable Energy Laboratory\n!\n!    This file is part of the NWTC Subroutine Library.\n!\n! Licensed under the Apache License, Version 2.0 (the \"License\");\n! you may not use this file except in compliance with the License.\n! You may obtain a copy of the License at\n!\n!     http://www.apache.org/licenses/LICENSE-2.0\n!\n! Unless required by applicable law or agreed to in writing, software\n! distributed under the License is distributed on an \"AS IS\" BASIS,\n! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n! See the License for the specific language governing permissions and\n! limitations under the License.\n!\n!**********************************************************************************************************************************\n! File last committed: $Date: 2013-12-23 14:04:45 -0800 (Mon, 23 Dec 2013) $\n! (File) Revision #: $Rev: 117 $\n! URL: $HeadURL: http://sel1004.verit.dnv.com:8080/svn/LoadSimCtl_SurfaceIce/trunk/IceDyn_IntelFortran/IceDyn/source/NWTC_Lib/NWTC_Base.f90 $\n!**********************************************************************************************************************************\nMODULE NWTC_Base\n\n\n      ! This module stores basic constants and routines that are not system-specific, but may be used in the system-specific routines.\n!   USE, INTRINSIC               :: ISO_C_Binding\n   USE                             Precision\n\n   IMPLICIT  NONE\n\n!=======================================================================\n\n      ! General constants:\n\n!   INTEGER, PARAMETER            :: BITS_IN_ADDR  = C_INTPTR_T*8                  ! The number of bits in an address (32-bit or 64-bit).\n\n   INTEGER(IntKi), PARAMETER     :: ChanLen   = 10                                ! The allowable length of channel names (i.e., width of output columns) in the FAST framework\n\n   LOGICAL,PARAMETER             :: NWTC_VerboseComments = .TRUE.\n\n      ! Global Error-level variables:\n\n   INTEGER(IntKi), PARAMETER     :: ErrID_None   = 0\n   INTEGER(IntKi), PARAMETER     :: ErrID_Info   = 1\n   INTEGER(IntKi), PARAMETER     :: ErrID_Warn   = 2\n   INTEGER(IntKi), PARAMETER     :: ErrID_Severe = 3\n   INTEGER(IntKi), PARAMETER     :: ErrID_Fatal  = 4\n\n   INTEGER(IntKi)                :: AbortErrLev  = ErrID_Fatal                     ! Note that this is not a PARAMETER\n\n\n      ! Type definition for dynamically loaded libraries:\n      !  Note that changes here may need to be reflected in DLLTypePack() DLLTypeUnPack(), and the FAST Registry.exe\n\n!   TYPE DLL_Type\n!\n!      INTEGER(C_INTPTR_T)       :: FileAddr                                        ! The address of file FileName.         (RETURN value from LoadLibrary ) [Windows]\n!      TYPE(C_PTR)               :: FileAddrX                                       ! The address of file FileName.         (RETURN value dlopen ) [Linux]\n!      TYPE(C_FUNPTR)            :: ProcAddr                                        ! The address of procedure ProcName.    (RETURN value from GetProcAddress or dlsym)\n!\n!      CHARACTER(1024)           :: FileName                                        ! The name of the DLL file including the full path to the current working directory.\n!      CHARACTER(1024)           :: ProcName                                        ! The name of the procedure in the DLL that will be called.\n!\n!   END TYPE DLL_Type\n\n\nEND MODULE NWTC_Base\n",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/modules/nwtc-library/src/SysGnuLinux.f90": "!**********************************************************************************************************************************\n! LICENSING\n! Copyright (C) 2013  National Renewable Energy Laboratory\n!\n!    This file is part of the NWTC Subroutine Library.\n!\n! Licensed under the Apache License, Version 2.0 (the \"License\");\n! you may not use this file except in compliance with the License.\n! You may obtain a copy of the License at\n!\n!     http://www.apache.org/licenses/LICENSE-2.0\n!\n! Unless required by applicable law or agreed to in writing, software\n! distributed under the License is distributed on an \"AS IS\" BASIS,\n! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n! See the License for the specific language governing permissions and\n! limitations under the License.\n!**********************************************************************************************************************************\nMODULE SysSubs\n\n   ! This module contains routines with system-specific logic and references, including all references to the console unit, CU.\n   ! It also contains standard (but not system-specific) routines it uses.\n   ! SysGnuLinux.f90 is specifically for the GNU Fortran (gfortran) compiler on Linux and macOS.\n   ! It contains the following routines:\n   !     FUNCTION    FileSize( Unit )                                         ! Returns the size (in bytes) of an open file.\n   !     FUNCTION    Is_NaN( DblNum )                                         ! Please use IEEE_IS_NAN() instead\n   !     FUNCTION    NWTC_ERF( x )\n   !     FUNCTION    NWTC_gamma( x )                                          ! Returns the gamma value of its argument.   \n   !     SUBROUTINE  FlushOut ( Unit )\n   !     SUBROUTINE  GET_CWD( DirName, Status )\n   !     SUBROUTINE  MKDIR( new_directory_path )\n   !     SUBROUTINE  OpenCon\n   !     SUBROUTINE  OpenUnfInpBEFile ( Un, InFile, RecLen, Error )\n   !     SUBROUTINE  ProgExit ( StatCode )\n   !     SUBROUTINE  Set_IEEE_Constants( NaN_D, Inf_D, NaN, Inf, NaN_S, Inf_S )   \n   !     SUBROUTINE  UsrAlarm\n   !     SUBROUTINE  WrNR ( Str )\n   !     SUBROUTINE  WrOver ( Str )\n   !     SUBROUTINE  WriteScr ( Str, Frm )\n   !     SUBROUTINE LoadDynamicLib( DLL, ErrStat, ErrMsg )\n   !     SUBROUTINE FreeDynamicLib( DLL, ErrStat, ErrMsg )\n\n   USE NWTC_Base\n\n   IMPLICIT NONE\n\n   INTERFACE NWTC_ERF ! Returns the ERF value of its argument\n      MODULE PROCEDURE NWTC_ERFR4\n      MODULE PROCEDURE NWTC_ERFR8\n      MODULE PROCEDURE NWTC_ERFR16\n   END INTERFACE\n\n   INTERFACE NWTC_gamma ! Returns the gamma value of its argument\n         ! note: gamma is part of the F08 standard, but may not be implemented everywhere...\n      MODULE PROCEDURE NWTC_gammaR4\n      MODULE PROCEDURE NWTC_gammaR8\n      MODULE PROCEDURE NWTC_gammaR16\n   END INTERFACE\n\n   INTEGER, PARAMETER            :: ConRecL     = 120                               ! The record length for console output.\n   INTEGER, PARAMETER            :: CU          = 6                                 ! The I/O unit for the console.  Unit 6 causes ADAMS to crash.\n   INTEGER, PARAMETER            :: MaxWrScrLen = 98                                ! The maximum number of characters allowed to be written to a line in WrScr\n   LOGICAL, PARAMETER            :: KBInputOK   = .TRUE.                            ! A flag to tell the program that keyboard input is allowed in the environment.\n   CHARACTER(*),  PARAMETER      :: NewLine     = ACHAR(10)                         ! The delimiter for New Lines [ Windows is CHAR(13)//CHAR(10); MAC is CHAR(13); Unix is CHAR(10) {CHAR(13)=\\r is a line feed, CHAR(10)=\\n is a new line}]\n   CHARACTER(*),  PARAMETER      :: OS_Desc     = 'GNU Fortran for Linux'           ! Description of the language/OS\n   CHARACTER( 1), PARAMETER      :: PathSep     = '/'                               ! The path separator.\n   CHARACTER( 1), PARAMETER      :: SwChar      = '-'                               ! The switch character for command-line options.\n   CHARACTER(11), PARAMETER      :: UnfForm     = 'UNFORMATTED'                     ! The string to specify unformatted I/O files.\n\nCONTAINS\n\n!=======================================================================\nFUNCTION FileSize( Unit )\n\n   ! This function calls the portability routine, FSTAT, to obtain the file size\n   ! in bytes corresponding to a file unit number or returns -1 on error.\n\n   INTEGER(B8Ki)                             :: FileSize                      ! The size of the file in bytes to be returned.\n   INTEGER, INTENT(IN)                       :: Unit                          ! The I/O unit number of the pre-opened file.\n   INTEGER(4)                                :: StatArray(13)                 ! An array returned by FSTAT that includes the file size.\n   INTEGER(4)                                :: Status                        ! The status returned by\n\n   Status = FSTAT( INT( Unit, B4Ki ), StatArray )\n\n   IF ( Status /= 0 ) THEN\n      FileSize = -1\n   ELSE\n      FileSize = StatArray(8)\n   END IF\n\n   RETURN\nEND FUNCTION FileSize ! ( Unit )\n!=======================================================================\nFUNCTION Is_NaN( DblNum )\n\n   ! This routine determines if a REAL(DbKi) variable holds a proper number.\n   ! BJJ: this routine is used in CRUNCH.\n   ! Note that IsNaN does not exist in earlier versions of gfortran (e.g., 4.2.1),\n   ! but does exist in version 4.4. It should be replaced with the standard\n   ! IEEE_IS_NAN when gfortran implements it.\n\n   REAL(DbKi), INTENT(IN)       :: DblNum\n   LOGICAL                      :: Is_Nan\n\n   Is_NaN = IsNaN( DblNum )\n\n   RETURN\nEND FUNCTION Is_NaN ! ( DblNum )\n!=======================================================================\nFUNCTION NWTC_ERFR4( x )\n\n   ! Returns the ERF value of its argument. The result has a value equal  \n   ! to the error function: 2/pi * integral_from_0_to_x of e^(-t^2) dt. \n\n   REAL(SiKi), INTENT(IN)     :: x           ! input \n   REAL(SiKi)                 :: NWTC_ERFR4  ! result\n   \n   NWTC_ERFR4 = ERF( x )\n\nEND FUNCTION NWTC_ERFR4\n!=======================================================================\nFUNCTION NWTC_ERFR8( x )\n\n   ! Returns the ERF value of its argument. The result has a value equal  \n   ! to the error function: 2/pi * integral_from_0_to_x of e^(-t^2) dt. \n\n   REAL(R8Ki), INTENT(IN)     :: x             ! input \n   REAL(R8Ki)                 :: NWTC_ERFR8    ! result\n   \n   NWTC_ERFR8 = ERF( x )\n\nEND FUNCTION NWTC_ERFR8\n!=======================================================================\nFUNCTION NWTC_ERFR16( x )\n\n   ! Returns the ERF value of its argument. The result has a value equal  \n   ! to the error function: 2/pi * integral_from_0_to_x of e^(-t^2) dt. \n\n   REAL(QuKi), INTENT(IN)     :: x             ! input \n   REAL(QuKi)                 :: NWTC_ERFR16   ! result\n   \n   NWTC_ERFR16 = ERF( x )\n\nEND FUNCTION NWTC_ERFR16\n!=======================================================================\nFUNCTION NWTC_GammaR4( x )\n\n   ! Returns the gamma value of its argument. The result has a value equal  \n   ! to a processor-dependent approximation to the gamma function of x. \n\n   REAL(SiKi), INTENT(IN)     :: x             ! input \n   REAL(SiKi)                 :: NWTC_GammaR4  ! result\n   \n   NWTC_GammaR4 = gamma( x )\n\nEND FUNCTION NWTC_GammaR4\n!=======================================================================\nFUNCTION NWTC_GammaR8( x )\n\n   ! Returns the gamma value of its argument. The result has a value equal  \n   ! to a processor-dependent approximation to the gamma function of x. \n\n   REAL(R8Ki), INTENT(IN)     :: x             ! input \n   REAL(R8Ki)                 :: NWTC_GammaR8  ! result\n   \n   NWTC_GammaR8 = gamma( x )\n\nEND FUNCTION NWTC_GammaR8\n!=======================================================================\nFUNCTION NWTC_GammaR16( x )\n\n   ! Returns the gamma value of its argument. The result has a value equal  \n   ! to a processor-dependent approximation to the gamma function of x. \n\n   REAL(QuKi), INTENT(IN)     :: x             ! input \n   REAL(QuKi)                 :: NWTC_GammaR16  ! result\n   \n   NWTC_GammaR16 = gamma( x )\n\nEND FUNCTION NWTC_GammaR16\n!=======================================================================\nSUBROUTINE FlushOut ( Unit )\n\n   ! This subroutine flushes the buffer on the specified Unit.\n   ! It is especially useful when printing \"running...\" type messages.\n   \n   INTEGER, INTENT(IN)          :: Unit                                         ! The unit number of the file being flushed.\n\n   ! CALL FLUSH ( Unit )\n\n   RETURN\nEND SUBROUTINE FlushOut ! ( Unit )\n!=======================================================================\n!bjj note: this subroutine is not tested for this compiler\nSUBROUTINE Get_CWD ( DirName, Status )\n\n   ! This routine retrieves the path of the current working directory.\n\n   IMPLICIT NONE\n\n   CHARACTER(*), INTENT(OUT)    :: DirName                                         ! A CHARACTER string containing the path of the current working directory.\n   INTEGER,      INTENT(OUT)    :: Status                                          ! Status returned by the call to a portability routine.\n\n   Status = GETCWD ( DirName )\n\n   RETURN\nEND SUBROUTINE Get_CWD\n!=======================================================================\nSUBROUTINE MKDIR ( new_directory_path )\n\n   ! This routine creates a given directory if it does not exist.\n\n   implicit none\n\n   character(*), intent(in) :: new_directory_path\n   character(1024)          :: make_command\n   logical                  :: directory_exists\n\n   ! Check if the directory exists first\n   inquire( file=trim(new_directory_path), exist=directory_exists )\n\n   if ( .NOT. directory_exists ) then\n      make_command = 'mkdir -p '//trim(new_directory_path)\n      call system( make_command )\n   endif\n\nEND SUBROUTINE MKDIR\n!=======================================================================\nSUBROUTINE OpenCon\n\n   ! This routine opens the console for standard output.\n\n!bjj: Because CU = 6 now, this statement is not necessary\n!   OPEN ( CU , FILE='/dev/stdout' , STATUS='OLD' )\n\n!   CALL FlushOut ( CU )\n\n   RETURN\nEND SUBROUTINE OpenCon\n!=======================================================================\nSUBROUTINE OpenUnfInpBEFile ( Un, InFile, RecLen, Error )\n\n   ! This routine opens a binary input file with data stored in Big Endian format (created on a UNIX machine.)\n   ! Data are stored in RecLen-byte records.\n\n   IMPLICIT                        NONE\n\n   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the input file.\n   CHARACTER(*), INTENT(IN)     :: InFile                                       ! Name of the input file.\n   INTEGER, INTENT(IN)          :: RecLen                                       ! Size of records in the input file, in bytes.\n   LOGICAL, INTENT(OUT)         :: Error                                        ! Flag to indicate the open failed.\n   INTEGER                      :: IOS                                          ! I/O status of OPEN.\n\n   ! Open input file.  Make sure it worked.\n\n   ! The non-standard CONVERT keyword allows us to read UNIX binary files, whose bytes are in reverse order (i.e., stored in BIG ENDIAN format).\n   ! NOTE: using RecLen in bytes requires using the /assume:byterecl compiler option!\n   OPEN ( Un, FILE=TRIM( InFile ), STATUS='OLD', FORM='UNFORMATTED', ACCESS='DIRECT', RECL=RecLen, IOSTAT=IOS, &\n                  ACTION='READ'  )                                              ! Use this for UNIX systems.\n   !            ACTION='READ', CONVERT='BIG_ENDIAN' )                         ! Use this for PC systems.\n\n   IF ( IOS /= 0 )  THEN\n      Error = .TRUE.\n   ELSE\n      Error = .FALSE.\n   END IF\n\n   RETURN\nEND SUBROUTINE OpenUnfInpBEFile\n!=======================================================================\nSUBROUTINE ProgExit ( StatCode )\n\n   ! This routine stops the program.  If the compiler supports the EXIT routine,\n   ! pass the program status to it.  Otherwise, do a STOP.\n\n   INTEGER, INTENT(IN)          :: StatCode                                      ! The status code to pass to the OS.\n\n   CALL EXIT ( StatCode )\n\n   ! IF ( StatCode == 0 ) THEN\n   !    STOP 0\n   ! ELSE\n   !    IF ( StatCode < 0 ) THEN\n   !       CALL WrScr( 'Invalid STOP code.' )\n   !    END IF\n   !    STOP 1\n   ! END IF\n\nEND SUBROUTINE ProgExit ! ( StatCode )\n!=======================================================================\nSUBROUTINE Set_IEEE_Constants( NaN_D, Inf_D, NaN, Inf, NaN_S, Inf_S )   \n      \n   ! routine that sets the values of NaN_D, Inf_D, NaN, Inf (IEEE \n   ! values for not-a-number and infinity in sindle and double \n   ! precision) F03 has standard intrinsic routines to do this,  \n   ! but Gnu has not yet implemented it. This code will fail if  \n   ! the compiler checks for floating-point-error, hence the  \n   ! compiler directive FPE_TRAP_ENABLED.\n\n   REAL(DbKi), INTENT(inout)           :: Inf_D          ! IEEE value for NaN (not-a-number) in double precision\n   REAL(DbKi), INTENT(inout)           :: NaN_D          ! IEEE value for Inf (infinity) in double precision\n   REAL(ReKi), INTENT(inout)           :: Inf            ! IEEE value for NaN (not-a-number)\n   REAL(ReKi), INTENT(inout)           :: NaN            ! IEEE value for Inf (infinity)\n   REAL(SiKi), INTENT(inout)           :: Inf_S          ! IEEE value for NaN (not-a-number) in single precision\n   REAL(SiKi), INTENT(inout)           :: NaN_S          ! IEEE value for Inf (infinity) in single precision\n\n      ! local variables for getting values of NaN and Inf (not necessary when using ieee_arithmetic)\n   REAL(DbKi)                          :: Neg_D          ! a negative real(DbKi) number\n   REAL(ReKi)                          :: Neg            ! a negative real(ReKi) number\n   REAL(SiKi)                          :: Neg_S          ! a negative real(SiKi) number\n\n   \n      ! if compiling with floating-point-exception traps, this will not work, so we've added a compiler directive.\n      !  note that anything that refers to NaN or Inf will be incorrect in that case.\n      \n#ifndef FPE_TRAP_ENABLED      \n      ! set variables to negative numbers to calculate NaNs (compilers may complain when taking sqrt of negative constants)\n   Neg_D = -1.0_DbKi\n   Neg   = -1.0_ReKi\n   Neg_S = -1.0_SiKi\n\n   NaN_D = SQRT ( Neg_D )\n   NaN   = SQRT ( Neg )\n   NaN_S = SQRT ( Neg_S )\n\n      ! set variables to zero to calculate Infs (using division by zero)\n   Neg_D = 0.0_DbKi\n   Neg   = 0.0_ReKi\n   Neg_S = 0.0_SiKi\n   \n   Inf_D = 1.0_DbKi / Neg_D\n   Inf   = 1.0_ReKi / Neg\n   Inf_S = 1.0_SiKi / Neg_S\n#endif \n\nEND SUBROUTINE Set_IEEE_Constants\n!=======================================================================\nSUBROUTINE UsrAlarm\n\n   ! This routine generates an alarm to warn the user that something went wrong.\n\n   CALL WrNR ( CHAR( 7 ) )\n\n   RETURN\nEND SUBROUTINE UsrAlarm\n!=======================================================================\nSUBROUTINE WrNR ( Str )\n\n   ! This routine writes out a string to the screen without following it with a new line.\n\n   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to write to the screen.\n\n   WRITE (CU,'(A)',ADVANCE='NO')  Str\n\n   RETURN\nEND SUBROUTINE WrNR ! ( Str )\n!=======================================================================\nSUBROUTINE WrOver ( Str )\n\n   ! This routine writes out a string that overwrites the previous line.\n\n   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to write to the screen.\n   INTEGER(IntKi)               :: NChars                                       ! Number of characters to write\n   CHARACTER(1), PARAMETER      :: CR = ACHAR( 13 )                             ! The carriage return character.\n   CHARACTER(25)                :: Fmt = '(2A,   (\" \"))'                        ! The format specifier for the output.\n\n   NChars = MaxWrScrLen - LEN( Str )\n\n   IF ( NChars > 0 ) THEN\n      ! bjj: note that this will produce an error if NChars > 999\n      WRITE (Fmt(5:7),'(I3)')  NChars\n      WRITE (CU,Fmt,ADVANCE='NO')  CR, Str\n   ELSE\n      ! bjj: note that this will almost certainly write more than MaxWrScrLen characters on a line\n      WRITE (CU,'(2A)',ADVANCE='NO')  CR, Str\n   END IF\n\n   RETURN\nEND SUBROUTINE WrOver ! ( Str )\n!=======================================================================\nSUBROUTINE WriteScr ( Str, Frm )\n\n   ! This routine writes out a string to the screen.\n\n   IMPLICIT NONE\n\n   CHARACTER(*), INTENT(IN)     :: Str                                         ! The input string to write to the screen.\n   CHARACTER(*), INTENT(IN)     :: Frm                                         ! Format specifier for the output.\n   INTEGER                      :: ErrStat                                     ! Error status of write operation (so code doesn't crash)\n\n   IF ( LEN_TRIM(Str)  < 1 ) THEN\n      WRITE ( CU, '()', IOSTAT=ErrStat )\n   ELSE\n      WRITE ( CU, Frm, IOSTAT=ErrStat ) TRIM(Str)\n   END IF\n\n   IF ( ErrStat /= 0 ) THEN\n         print *, ' WriteScr produced an error. Please inform the programmer.'\n   ENDIF\n\nEND SUBROUTINE WriteScr ! ( Str )\n!=======================================================================\nSUBROUTINE LoadDynamicLib ( DLL, ErrStat, ErrMsg )\n\n   ! This SUBROUTINE is used to dynamically load a DLL.\n\n   TYPE (DLL_Type),           INTENT(INOUT)  :: DLL         ! The DLL to be loaded.\n   INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat     ! Error status of the operation\n   CHARACTER(*),              INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None\n\n#ifdef USE_DLL_INTERFACE         \n\n!bjj: these are values I found on the web; I have no idea if they actually work...\n!bjj: hopefully we can find them pre-defined in a header somewhere\n   INTEGER(C_INT), PARAMETER :: RTLD_LAZY=1            ! \"Perform lazy binding. Only resolve symbols as the code that references them is executed. If the symbol is never referenced, then it is never resolved. (Lazy binding is only performed for function references; references to variables are always immediately bound when the library is loaded.) \"\n   INTEGER(C_INT), PARAMETER :: RTLD_NOW=2             ! \"If this value is specified, or the environment variable LD_BIND_NOW is set to a nonempty string, all undefined symbols in the library are resolved before dlopen() returns. If this cannot be done, an error is returned.\"\n   INTEGER(C_INT), PARAMETER :: RTLD_GLOBAL=256        ! \"The symbols defined by this library will be made available for symbol resolution of subsequently loaded libraries\"\n   INTEGER(C_INT), PARAMETER :: RTLD_LOCAL=0           ! \"This is the converse of RTLD_GLOBAL, and the default if neither flag is specified. Symbols defined in this library are not made available to resolve references in subsequently loaded libraries.\"\n\n   INTERFACE !linux API routines\n      !bjj see http://linux.die.net/man/3/dlopen\n      !    and https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/dlopen.3.html\n\n      FUNCTION dlOpen(filename,mode) BIND(C,NAME=\"dlopen\")\n      ! void *dlopen(const char *filename, int mode);\n         USE ISO_C_BINDING\n         IMPLICIT NONE\n         TYPE(C_PTR)                   :: dlOpen\n         CHARACTER(C_CHAR), INTENT(IN) :: filename(*)\n         INTEGER(C_INT), VALUE         :: mode\n      END FUNCTION\n\n   END INTERFACE\n\n   ErrStat = ErrID_None\n   ErrMsg = ''\n\n   ! Load the DLL and get the file address:\n\n   DLL%FileAddrX = dlOpen( TRIM(DLL%FileName)//C_NULL_CHAR, RTLD_LAZY )  !the \"C_NULL_CHAR\" converts the Fortran string to a C-type string (i.e., adds //CHAR(0) to the end)\n\n   IF( .NOT. C_ASSOCIATED(DLL%FileAddrX) ) THEN\n      ErrStat = ErrID_Fatal\n      WRITE(ErrMsg,'(I2)') BITS_IN_ADDR\n      ErrMsg  = 'The dynamic library '//TRIM(DLL%FileName)//' could not be loaded. Check that the file '// &\n               'exists in the specified location and that it is compiled for '//TRIM(ErrMsg)//'-bit applications.'\n      RETURN\n   END IF\n\n   ! Get the procedure address:\n\n   CALL LoadDynamicLibProc ( DLL, ErrStat, ErrMsg )\n#else\n\n   ErrStat = ErrID_Fatal\n   ErrMsg = ' LoadDynamicLib: Not compiled with -DUSE_DLL_INTERFACE for '//TRIM(OS_Desc)\n\n#endif\n\n   RETURN\nEND SUBROUTINE LoadDynamicLib\n!=======================================================================\nSUBROUTINE LoadDynamicLibProc ( DLL, ErrStat, ErrMsg )\n\n   ! This SUBROUTINE is used to dynamically load a procedure from a DLL.\n\n   TYPE (DLL_Type),           INTENT(INOUT)  :: DLL         ! The DLL to be loaded.\n   INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat     ! Error status of the operation\n   CHARACTER(*),              INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None\n   INTEGER(IntKi)                            :: i\n\n#ifdef USE_DLL_INTERFACE           \n\n   INTERFACE !linux API routines\n\n      !bjj see http://linux.die.net/man/3/dlsym\n      !    and https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/dlsym.3.html\n      \n      FUNCTION dlSym(handle,name) BIND(C,NAME=\"dlsym\")\n      ! void *dlsym(void *handle, const char *name);\n         USE ISO_C_BINDING\n         IMPLICIT NONE\n         TYPE(C_FUNPTR)                :: dlSym ! A function pointer\n         TYPE(C_PTR), VALUE            :: handle\n         CHARACTER(C_CHAR), INTENT(IN) :: name(*)\n      END FUNCTION\n\n   END INTERFACE\n\n   ErrStat = ErrID_None\n   ErrMsg = ''\n\n   do i=1,NWTC_MAX_DLL_PROC\n      if ( len_trim( DLL%ProcName(i) ) > 0 ) then\n   \n         DLL%ProcAddr(i) = dlSym( DLL%FileAddrX, TRIM(DLL%ProcName(i))//C_NULL_CHAR )  !the \"C_NULL_CHAR\" converts the Fortran string to a C-type string (i.e., adds //CHAR(0) to the end)\n\n         IF(.NOT. C_ASSOCIATED(DLL%ProcAddr(i))) THEN\n            ErrStat = ErrID_Fatal + i - 1\n            ErrMsg  = 'The procedure '//TRIM(DLL%ProcName(i))//' in file '//TRIM(DLL%FileName)//' could not be loaded.'\n            RETURN\n         END IF\n         \n      end if\n   end do\n   \n#else\n\n   ErrStat = ErrID_Fatal\n   ErrMsg = ' LoadDynamicLibProc: Not compiled with -DUSE_DLL_INTERFACE for '//TRIM(OS_Desc)\n   \n#endif\n\n   RETURN\nEND SUBROUTINE LoadDynamicLibProc\n!=======================================================================\nSUBROUTINE FreeDynamicLib ( DLL, ErrStat, ErrMsg )\n\n   ! This SUBROUTINE is used to free a dynamically loaded DLL (loaded in LoadDynamicLib).\n\n   TYPE (DLL_Type),           INTENT(INOUT)  :: DLL         ! The DLL to be freed.\n   INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat     ! Error status of the operation\n   CHARACTER(*),              INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None\n   INTEGER(C_INT)                            :: Success     ! Whether or not the call to dlClose was successful\n   INTEGER(C_INT), PARAMETER                 :: TRUE  = 0\n\n#ifdef USE_DLL_INTERFACE           \n!bjj: note that this is not tested.\n\n   INTERFACE !linux API routine\n      !bjj see http://linux.die.net/man/3/dlclose\n      !    and https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/dlclose.3.html\n\n      FUNCTION dlClose(handle) BIND(C,NAME=\"dlclose\")\n      ! int dlclose(void *handle);\n         USE ISO_C_BINDING\n         IMPLICIT NONE\n         INTEGER(C_INT)       :: dlClose\n         TYPE(C_PTR), VALUE   :: handle\n      END FUNCTION\n\n   END INTERFACE\n\n   ! Close the library:\n\n   IF( .NOT. C_ASSOCIATED(DLL%FileAddrX) ) RETURN\n   Success = dlClose( DLL%FileAddrX ) !The function dlclose() returns 0 on success, and nonzero on error.\n\n   IF ( Success /= TRUE ) THEN !bjj: note that this is not the same as LOGICAL .TRUE.\n      ErrStat = ErrID_Fatal\n      ErrMsg  = 'The dynamic library could not be freed.'\n      RETURN\n   ELSE\n      ErrStat = ErrID_None\n      ErrMsg = ''\n      DLL%FileAddrX = C_NULL_PTR\n   END IF\n   \n#else\n\n   ErrStat = ErrID_Fatal\n   ErrMsg = ' FreeDynamicLib: Not compiled with -DUSE_DLL_INTERFACE for '//TRIM(OS_Desc)\n      \n#endif\n\n   RETURN\nEND SUBROUTINE FreeDynamicLib\n!=======================================================================\nEND MODULE SysSubs\n",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/modules/nwtc-library/src/SysMatlabLinuxIntel.f90": "!**********************************************************************************************************************************\n! LICENSING\n! Copyright (C) 2013-2015  National Renewable Energy Laboratory\n!\n!    This file is part of the NWTC Subroutine Library.\n!\n! Licensed under the Apache License, Version 2.0 (the \"License\");\n! you may not use this file except in compliance with the License.\n! You may obtain a copy of the License at\n!\n!     http://www.apache.org/licenses/LICENSE-2.0\n!\n! Unless required by applicable law or agreed to in writing, software\n! distributed under the License is distributed on an \"AS IS\" BASIS,\n! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n! See the License for the specific language governing permissions and\n! limitations under the License.\n!\n!**********************************************************************************************************************************\nMODULE SysSubs\n\n   ! This module contains routines with system-specific logic and references, including all references to the console unit, CU.\n   ! It also contains standard (but not system-specific) routines it uses.\n   ! This system configuration requires linking with the matlab library, libmex.dll or libmex.dylib or libmex.so, from the matlab\n   ! installation directory.\n   ! SysMatlabLinux.f90 is specifically for the Intel fortran compiler (ifort) on Linux and macOS.\n   ! It contains the following routines:\n   !     FUNCTION    FileSize( Unit )                                         ! Returns the size (in bytes) of an open file.\n   !     FUNCTION    Is_NaN( DblNum )                                         ! Please use IEEE_IS_NAN() instead\n   !     FUNCTION    NWTC_ERF( x )\n   !     FUNCTION    NWTC_gamma( x )                                          ! Returns the gamma value of its argument.   \n   !     SUBROUTINE  FlushOut ( Unit )\n   !     SUBROUTINE  GET_CWD( DirName, Status )\n   !     SUBROUTINE  MKDIR( new_directory_path )\n   !     SUBROUTINE  OpenCon\n   !     SUBROUTINE  OpenUnfInpBEFile ( Un, InFile, RecLen, Error )\n   !     SUBROUTINE  ProgExit ( StatCode )\n   !     SUBROUTINE  Set_IEEE_Constants( NaN_D, Inf_D, NaN, Inf )   \n   !     SUBROUTINE  UsrAlarm\n   !     SUBROUTINE  WrNR ( Str )\n   !     SUBROUTINE  WrOver ( Str )\n   !     SUBROUTINE  WriteScr ( Str, Frm )\n   !     SUBROUTINE LoadDynamicLib( DLL, ErrStat, ErrMsg )\n   !     SUBROUTINE FreeDynamicLib( DLL, ErrStat, ErrMsg )\n\n   USE NWTC_Base\n\n   IMPLICIT NONE\n\n   INTERFACE NWTC_ERF ! Returns the ERF value of its argument\n      MODULE PROCEDURE NWTC_ERFR4\n      MODULE PROCEDURE NWTC_ERFR8\n      MODULE PROCEDURE NWTC_ERFR16\n   END INTERFACE\n\n   INTERFACE NWTC_gamma ! Returns the gamma value of its argument\n         ! note: gamma is part of the F08 standard, but may not be implemented everywhere...\n      MODULE PROCEDURE NWTC_gammaR4\n      MODULE PROCEDURE NWTC_gammaR8\n      MODULE PROCEDURE NWTC_gammaR16\n   END INTERFACE\n\n   INTEGER, PARAMETER            :: ConRecL     = 120                               ! The record length for console output.\n   INTEGER, PARAMETER            :: CU          = 6                                 ! The I/O unit for the console.  Unit 6 causes ADAMS to crash.\n   INTEGER, PARAMETER            :: MaxWrScrLen = 98                                ! The maximum number of characters allowed to be written to a line in WrScr\n   LOGICAL, PARAMETER            :: KBInputOK   = .FALSE.                           ! A flag to tell the program that keyboard input is allowed in the environment.\n   CHARACTER(*),  PARAMETER      :: NewLine     = ACHAR(10)                         ! The delimiter for New Lines [ Windows is CHAR(13)//CHAR(10); MAC is CHAR(13); Unix is CHAR(10) {CHAR(13)=\\r is a line feed, CHAR(10)=\\n is a new line}]\n   CHARACTER(*),  PARAMETER      :: OS_Desc     = 'Intel Fortran for Linux with Matlab' ! Description of the language/OS\n   CHARACTER( 1), PARAMETER      :: PathSep     = '/'                               ! The path separator.\n   CHARACTER( 1), PARAMETER      :: SwChar      = '-'                               ! The switch character for command-line options.\n   CHARACTER(11), PARAMETER      :: UnfForm     = 'UNFORMATTED'                     ! The string to specify unformatted I/O files.\n\nCONTAINS\n\n!=======================================================================\nFUNCTION FileSize( Unit )\n\n   ! This function calls the portability routine, FSTAT, to obtain the file size\n   ! in bytes corresponding to a file unit number or returns -1 on error.\n\n   USE IFPORT\n\n   INTEGER(B8Ki)                             :: FileSize                      ! The size of the file in bytes to be returned.\n   INTEGER, INTENT(IN)                       :: Unit                          ! The I/O unit number of the pre-opened file.\n   INTEGER                                   :: StatArray(12)                 ! An array returned by FSTAT that includes the file size.\n   INTEGER                                   :: Status                        ! The status returned by\n\n   Status = FSTAT( INT( Unit, B4Ki ), StatArray )\n\n   IF ( Status /= 0 ) THEN\n      FileSize = -1\n   ELSE\n      FileSize = StatArray(8)\n   END IF\n\n   RETURN\nEND FUNCTION FileSize ! ( Unit )\n!=======================================================================\nFUNCTION Is_NaN( DblNum )\n\n   ! This routine determines if a REAL(DbKi) variable holds a proper number.\n   ! BJJ: this routine is used in CRUNCH.\n   ! It should be replaced with IEEE_IS_NAN in new code, but remains here for\n   ! backwards compatibility.\n\n   USE, INTRINSIC :: ieee_arithmetic\n\n   REAL(DbKi), INTENT(IN)       :: DblNum\n   LOGICAL                      :: Is_Nan\n\n   Is_NaN = IEEE_IS_NAN( DblNum )\n\n   RETURN\nEND FUNCTION Is_NaN ! ( DblNum )\n!=======================================================================\nFUNCTION NWTC_ERFR4( x )\n\n   ! Returns the ERF value of its argument. The result has a value equal  \n   ! to the error function: 2/pi * integral_from_0_to_x of e^(-t^2) dt. \n\n   REAL(SiKi), INTENT(IN)     :: x           ! input \n   REAL(SiKi)                 :: NWTC_ERFR4  ! result\n\n   NWTC_ERFR4 = ERF( x )\n\nEND FUNCTION NWTC_ERFR4\n!=======================================================================\nFUNCTION NWTC_ERFR8( x )\n\n   ! Returns the ERF value of its argument. The result has a value equal  \n   ! to the error function: 2/pi * integral_from_0_to_x of e^(-t^2) dt. \n\n   REAL(R8Ki), INTENT(IN)     :: x             ! input \n   REAL(R8Ki)                 :: NWTC_ERFR8    ! result\n\n   NWTC_ERFR8 = ERF( x )\n\nEND FUNCTION NWTC_ERFR8\n!=======================================================================\nFUNCTION NWTC_ERFR16( x )\n\n   ! Returns the ERF value of its argument. The result has a value equal  \n   ! to the error function: 2/pi * integral_from_0_to_x of e^(-t^2) dt. \n\n   REAL(QuKi), INTENT(IN)     :: x             ! input \n   REAL(QuKi)                 :: NWTC_ERFR16   ! result\n\n   NWTC_ERFR16 = ERF( x )\n\nEND FUNCTION NWTC_ERFR16\n!=======================================================================\nFUNCTION NWTC_GammaR4( x )\n\n   ! Returns the gamma value of its argument. The result has a value equal  \n   ! to a processor-dependent approximation to the gamma function of x. \n\n   REAL(SiKi), INTENT(IN)     :: x             ! input \n   REAL(SiKi)                 :: NWTC_GammaR4  ! result\n   \n   NWTC_GammaR4 = gamma( x )\n\nEND FUNCTION NWTC_GammaR4\n!=======================================================================\nFUNCTION NWTC_GammaR8( x )\n\n   ! Returns the gamma value of its argument. The result has a value equal  \n   ! to a processor-dependent approximation to the gamma function of x. \n\n   REAL(R8Ki), INTENT(IN)     :: x             ! input \n   REAL(R8Ki)                 :: NWTC_GammaR8  ! result\n   \n   NWTC_GammaR8 = gamma( x )\n\nEND FUNCTION NWTC_GammaR8\n!=======================================================================\nFUNCTION NWTC_GammaR16( x )\n\n   ! Returns the gamma value of its argument. The result has a value equal  \n   ! to a processor-dependent approximation to the gamma function of x. \n\n   REAL(QuKi), INTENT(IN)     :: x             ! input \n   REAL(QuKi)                 :: NWTC_GammaR16 ! result\n   \n   NWTC_GammaR16 = gamma( x )\n\nEND FUNCTION NWTC_GammaR16\n!=======================================================================\nSUBROUTINE FlushOut ( Unit )\n\n   ! This subroutine flushes the buffer on the specified Unit.\n   ! It is especially useful when printing \"running...\" type messages.\n\n   USE IFPORT\n\n   INTEGER, INTENT(IN)          :: Unit  ! The unit number of the file being flushed.\n\n   CALL FLUSH ( INT(Unit, B4Ki) )\n\n   RETURN\nEND SUBROUTINE FlushOut ! ( Unit )\n!=======================================================================\nSUBROUTINE Get_CWD ( DirName, Status )\n\n   USE IFPORT, ONLY: GETCWD\n\n   IMPLICIT NONE\n\n   CHARACTER(*), INTENT(OUT)    :: DirName                                         ! A CHARACTER string containing the path of the current working directory.\n   INTEGER,      INTENT(OUT)    :: Status                                          ! Status returned by the call to a portability routine.\n\n   Status = GETCWD ( DirName )\n\n   RETURN\nEND SUBROUTINE Get_CWD\n!=======================================================================\nSUBROUTINE MKDIR ( new_directory_path )\n\n   ! This routine creates a given directory if it does not exist.\n\n   implicit none\n\n   character(*), intent(in) :: new_directory_path\n   character(1024)          :: make_command\n   logical                  :: directory_exists\n\n   ! Check if the directory exists first\n   inquire( directory=trim(new_directory_path), exist=directory_exists )\n\n   if ( .NOT. directory_exists ) then\n      make_command = 'mkdir -p '//trim(new_directory_path)\n      call system( make_command )\n   endif\n\nEND SUBROUTINE MKDIR\n!=======================================================================\nSUBROUTINE OpenCon\n\n   ! This routine opens the console for standard output.\n\n   USE IFPORT\n\n!bjj: Because CU = 6 now, this statement is not necessary\n!   OPEN ( CU , FILE='/dev/stdout' , STATUS='UNKNOWN' , CARRIAGECONTROL='FORTRAN', RECL=ConRecL )\n\n   CALL FlushOut ( CU )\n\n   RETURN\nEND SUBROUTINE OpenCon\n!=======================================================================\nSUBROUTINE OpenUnfInpBEFile ( Un, InFile, RecLen, Error )\n\n   ! This routine opens a binary input file with data stored in Big Endian format (created on a UNIX machine.)\n   ! Data are stored in RecLen-byte records.\n\n   IMPLICIT NONE\n\n   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the input file.\n   CHARACTER(*), INTENT(IN)     :: InFile                                       ! Name of the input file.\n   INTEGER, INTENT(IN)          :: RecLen                                       ! Size of records in the input file, in bytes.\n   LOGICAL, INTENT(OUT)         :: Error                                        ! Flag to indicate the open failed.\n   INTEGER                      :: IOS                                          ! I/O status of OPEN.\n\n   ! Open input file.  Make sure it worked.\n\n   ! The non-standard CONVERT keyword allows us to read UNIX binary files, whose bytes are in reverse order (i.e., stored in BIG ENDIAN format).\n   ! NOTE: using RecLen in bytes requires using the /assume:byterecl compiler option!\n   OPEN ( Un, FILE=TRIM( InFile ), STATUS='OLD', FORM='UNFORMATTED', ACCESS='DIRECT', RECL=RecLen, IOSTAT=IOS, &\n                  ACTION='READ'  )                                              ! Use this for UNIX systems.\n!                  ACTION='READ', CONVERT='BIG_ENDIAN' )                         ! Use this for PC systems.\n\n   IF ( IOS /= 0 )  THEN\n      Error = .TRUE.\n   ELSE\n      Error = .FALSE.\n   END IF\n\n   RETURN\nEND SUBROUTINE OpenUnfInpBEFile\n!=======================================================================\nSUBROUTINE ProgExit ( StatCode )\n\n   ! This routine stops the program.  If the compiler supports the EXIT routine,\n   ! pass the program status to it.  Otherwise, do a STOP.\n\n   INTEGER, INTENT(IN)          :: StatCode                                      ! The status code to pass to the OS.\n\n   ! CALL EXIT ( StatCode )\n\n   ! IF ( StatCode == 0 ) THEN\n   !    STOP 0\n   ! ELSE\n   !    IF ( StatCode < 0 ) THEN\n   !       CALL WrScr( 'Invalid STOP code.' )\n   !    END IF\n   !    STOP 1\n   ! END IF\n\nEND SUBROUTINE ProgExit ! ( StatCode )\n!=======================================================================\nSUBROUTINE Set_IEEE_Constants( NaN_D, Inf_D, NaN, Inf )   \n\n   ! routine that sets the values of NaN_D, Inf_D, NaN, Inf (IEEE \n   ! values for not-a-number and infinity in sindle and double \n   ! precision) This uses standard F03 intrinsic routines,  \n   ! however Gnu has not yet implemented it, so we've placed this\n   ! routine in the system-specific code.\n\n   USE, INTRINSIC :: ieee_arithmetic  ! use this for compilers that have implemented ieee_arithmetic from F03 standard (otherwise see logic in SysGnu*.f90)\n\n   REAL(DbKi), INTENT(inout)           :: Inf_D          ! IEEE value for NaN (not-a-number) in double precision\n   REAL(DbKi), INTENT(inout)           :: NaN_D          ! IEEE value for Inf (infinity) in double precision\n\n   REAL(ReKi), INTENT(inout)           :: Inf            ! IEEE value for NaN (not-a-number)\n   REAL(ReKi), INTENT(inout)           :: NaN            ! IEEE value for Inf (infinity)\n\n   \n   NaN_D = ieee_value(0.0_DbKi, ieee_quiet_nan)\n   Inf_D = ieee_value(0.0_DbKi, ieee_positive_inf)\n\n   NaN   = ieee_value(0.0_ReKi, ieee_quiet_nan)\n   Inf   = ieee_value(0.0_ReKi, ieee_positive_inf)   \n\nEND SUBROUTINE Set_IEEE_Constants  \n!=======================================================================\nSUBROUTINE UsrAlarm\n\n   ! This routine generates an alarm to warn the user that something went wrong.\n   ! This routine does nothing for the MATLAB environment.\n\n   ! CALL WrNR ( CHAR( 7 ) )\n\n   RETURN\nEND SUBROUTINE UsrAlarm\n!=======================================================================\nSUBROUTINE WrNR ( Str )\n\n      ! This routine writes out a string to the screen without following it with a new line.\n\n   CHARACTER(*), INTENT(IN)     :: Str       ! The string to write to the screen.\n   INTEGER                      :: Stat      ! Number of characters printed\n   INTEGER, EXTERNAL            :: mexPrintF ! Matlab function to print to the command window\n   CHARACTER(1024), SAVE        :: Str2      ! bjj: need static variable to print to Matlab command window\n\n   Str2 = ' '//Str\n   Stat = mexPrintF( Str2 )\n   \n   RETURN\nEND SUBROUTINE WrNR ! ( Str )\n!=======================================================================\nSUBROUTINE WrOver ( Str )\n\n   ! This routine writes out a string that overwrites the previous line\n\n   CHARACTER(*), INTENT(IN) :: Str ! The string to write to the screen.\n\n   CALL WriteScr( Str, '(A)' )\n\n   RETURN\nEND SUBROUTINE WrOver ! ( Str )\n!=======================================================================\nSUBROUTINE WriteScr ( Str, Frm )\n\n   ! This routine writes out a string to the screen.\n\n   IMPLICIT NONE\n\n   CHARACTER(*), INTENT(IN)     :: Str       ! The input string to write to the screen.\n   CHARACTER(*), INTENT(IN)     :: Frm       ! Format specifier for the output.\n   INTEGER                      :: ErrStat   ! Error status of write operation (so code doesn't crash)\n   INTEGER, EXTERNAL            :: mexPrintF ! Matlab function to print to the command window\n   INTEGER                      :: Stat      ! Number of characters printed to the screen\n   CHARACTER( 1024 ), SAVE      :: Str2      ! A temporary string (Str written with the Frm Format specification) (bjj: this apparently needs to be a static variable so it writes to the Matlab command window)\n\n   IF ( LEN_TRIM(Str)  < 1 ) THEN\n      Str2=''\n   ELSE\n      WRITE (Str2,Frm, IOSTAT=Stat)  ADJUSTL( Str )\n   END IF\n\n   Str2 = trim(Str2)//NewLine\n   Stat = mexPrintF( Str2 )\n\nEND SUBROUTINE WriteScr ! ( Str )\n!=======================================================================\nSUBROUTINE LoadDynamicLib ( DLL, ErrStat, ErrMsg )\n\n   ! This SUBROUTINE is used to dynamically load a DLL.\n\n   TYPE (DLL_Type),           INTENT(INOUT)  :: DLL         ! The DLL to be loaded.\n   INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat     ! Error status of the operation\n   CHARACTER(*),              INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None\n\n#ifdef USE_DLL_INTERFACE         \n\n!bjj: these are values I found on the web; I have no idea if they actually work...\n!bjj: hopefully we can find them pre-defined in a header somewhere\n   INTEGER(C_INT), PARAMETER :: RTLD_LAZY=1            ! \"Perform lazy binding. Only resolve symbols as the code that references them is executed. If the symbol is never referenced, then it is never resolved. (Lazy binding is only performed for function references; references to variables are always immediately bound when the library is loaded.) \"\n   INTEGER(C_INT), PARAMETER :: RTLD_NOW=2             ! \"If this value is specified, or the environment variable LD_BIND_NOW is set to a nonempty string, all undefined symbols in the library are resolved before dlopen() returns. If this cannot be done, an error is returned.\"\n   INTEGER(C_INT), PARAMETER :: RTLD_GLOBAL=256        ! \"The symbols defined by this library will be made available for symbol resolution of subsequently loaded libraries\"\n   INTEGER(C_INT), PARAMETER :: RTLD_LOCAL=0           ! \"This is the converse of RTLD_GLOBAL, and the default if neither flag is specified. Symbols defined in this library are not made available to resolve references in subsequently loaded libraries.\"\n\n   INTERFACE !linux API routines\n      !bjj see http://linux.die.net/man/3/dlopen\n      !    and https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/dlopen.3.html\n\n      FUNCTION dlOpen(filename,mode) BIND(C,NAME=\"dlopen\")\n      ! void *dlopen(const char *filename, int mode);\n         USE ISO_C_BINDING\n         IMPLICIT NONE\n         TYPE(C_PTR)                   :: dlOpen\n         CHARACTER(C_CHAR), INTENT(IN) :: filename(*)\n         INTEGER(C_INT), VALUE         :: mode\n      END FUNCTION\n\n   END INTERFACE\n\n   ErrStat = ErrID_None\n   ErrMsg = ''\n\n   ! Load the DLL and get the file address:\n\n   DLL%FileAddrX = dlOpen( TRIM(DLL%FileName)//C_NULL_CHAR, RTLD_LAZY )  !the \"C_NULL_CHAR\" converts the Fortran string to a C-type string (i.e., adds //CHAR(0) to the end)\n\n   IF( .NOT. C_ASSOCIATED(DLL%FileAddrX) ) THEN\n      ErrStat = ErrID_Fatal\n      WRITE(ErrMsg,'(I2)') BITS_IN_ADDR\n      ErrMsg  = 'The dynamic library '//TRIM(DLL%FileName)//' could not be loaded. Check that the file '// &\n                'exists in the specified location and that it is compiled for '//TRIM(ErrMsg)//'-bit applications.'\n      RETURN\n   END IF\n\n   ! Get the procedure address:\n\n   CALL LoadDynamicLibProc ( DLL, ErrStat, ErrMsg )\n#else\n\n   ErrStat = ErrID_Fatal\n   ErrMsg = ' LoadDynamicLib: Not compiled with -DUSE_DLL_INTERFACE for '//TRIM(OS_Desc)\n      \n#endif\n   \n   RETURN\nEND SUBROUTINE LoadDynamicLib\n!=======================================================================\nSUBROUTINE LoadDynamicLibProc ( DLL, ErrStat, ErrMsg )\n\n   ! This SUBROUTINE is used to dynamically load a procedure from a DLL.\n\n   TYPE (DLL_Type),           INTENT(INOUT)  :: DLL         ! The DLL to be loaded.\n   INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat     ! Error status of the operation\n   CHARACTER(*),              INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None\n   INTEGER(IntKi)                            :: i\n\n#ifdef USE_DLL_INTERFACE           \n\n   INTERFACE !linux API routines\n\n      !bjj see http://linux.die.net/man/3/dlsym\n      !    and https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/dlsym.3.html\n      \n      FUNCTION dlSym(handle,name) BIND(C,NAME=\"dlsym\")\n      ! void *dlsym(void *handle, const char *name);\n         USE ISO_C_BINDING\n         IMPLICIT NONE\n         TYPE(C_FUNPTR)                :: dlSym ! A function pointer\n         TYPE(C_PTR), VALUE            :: handle\n         CHARACTER(C_CHAR), INTENT(IN) :: name(*)\n      END FUNCTION\n\n   END INTERFACE\n\n   ErrStat = ErrID_None\n   ErrMsg = ''\n\n   do i=1,NWTC_MAX_DLL_PROC\n      if ( len_trim( DLL%ProcName(i) ) > 0 ) then\n   \n         DLL%ProcAddr(i) = dlSym( DLL%FileAddrX, TRIM(DLL%ProcName(i))//C_NULL_CHAR )  !the \"C_NULL_CHAR\" converts the Fortran string to a C-type string (i.e., adds //CHAR(0) to the end)\n\n         IF(.NOT. C_ASSOCIATED(DLL%ProcAddr(i))) THEN\n            ErrStat = ErrID_Fatal + i - 1\n            ErrMsg  = 'The procedure '//TRIM(DLL%ProcName(i))//' in file '//TRIM(DLL%FileName)//' could not be loaded.'\n            RETURN\n         END IF\n         \n      end if\n   end do\n      \n#else\n\n   ErrStat = ErrID_Fatal\n   ErrMsg = ' LoadDynamicLibProc: Not compiled with -DUSE_DLL_INTERFACE for '//TRIM(OS_Desc)\n      \n#endif\n   \n   RETURN\nEND SUBROUTINE LoadDynamicLibProc\n!=======================================================================\nSUBROUTINE FreeDynamicLib ( DLL, ErrStat, ErrMsg )\n\n      ! This SUBROUTINE is used to free a dynamically loaded DLL (loaded in LoadDynamicLib).\n\n      TYPE (DLL_Type),           INTENT(INOUT)  :: DLL         ! The DLL to be freed.\n      INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat     ! Error status of the operation\n      CHARACTER(*),              INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None\n      INTEGER(C_INT)                            :: Success     ! Whether or not the call to dlClose was successful\n      INTEGER(C_INT), PARAMETER                 :: TRUE  = 0\n\n#ifdef USE_DLL_INTERFACE           \n!bjj: note that this is not tested.\n\n   INTERFACE !linux API routine\n      !bjj see http://linux.die.net/man/3/dlclose\n      !    and https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/dlclose.3.html\n\n      FUNCTION dlClose(handle) BIND(C,NAME=\"dlclose\")\n      ! int dlclose(void *handle);\n         USE ISO_C_BINDING\n         IMPLICIT NONE\n         INTEGER(C_INT)       :: dlClose\n         TYPE(C_PTR), VALUE   :: handle\n      END FUNCTION\n\n   END INTERFACE\n\n   ! Close the library:\n\n   IF( .NOT. C_ASSOCIATED(DLL%FileAddrX) ) RETURN\n   Success = dlClose( DLL%FileAddrX ) !The function dlclose() returns 0 on success, and nonzero on error.\n\n   IF ( Success /= TRUE ) THEN !bjj: note that this is not the same as LOGICAL .TRUE.\n      ErrStat = ErrID_Fatal\n      ErrMsg  = 'The dynamic library could not be freed.'\n      RETURN\n   ELSE\n      ErrStat = ErrID_None\n      ErrMsg = ''\n      DLL%FileAddrX = C_NULL_PTR\n   END IF\n   \n#else\n\n      ErrStat = ErrID_Fatal\n      ErrMsg = ' FreeDynamicLib: Not compiled with -DUSE_DLL_INTERFACE for '//TRIM(OS_Desc)\n         \n#endif\n   \n      RETURN\nEND SUBROUTINE FreeDynamicLib\n!=======================================================================\nEND MODULE SysSubs\n",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/modules/nwtc-library/src/SysIFL.f90": "!**********************************************************************************************************************************\n! LICENSING\n! Copyright (C) 2013  National Renewable Energy Laboratory\n!\n!    This file is part of the NWTC Subroutine Library.\n!\n! Licensed under the Apache License, Version 2.0 (the \"License\");\n! you may not use this file except in compliance with the License.\n! You may obtain a copy of the License at\n!\n!     http://www.apache.org/licenses/LICENSE-2.0\n!\n! Unless required by applicable law or agreed to in writing, software\n! distributed under the License is distributed on an \"AS IS\" BASIS,\n! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n! See the License for the specific language governing permissions and\n! limitations under the License.\n!**********************************************************************************************************************************\nMODULE SysSubs\n\n   ! This module contains routines with system-specific logic and references, including all references to the console unit, CU.\n   ! It also contains standard (but not system-specific) routines it uses.\n   ! SysIFL.f90 is specifically for the Intel Fortran for Linux compiler.\n   ! It contains the following routines:\n   !     FUNCTION    FileSize( Unit )                                         ! Returns the size (in bytes) of an open file.\n   !     FUNCTION    Is_NaN( DblNum )                                         ! Please use IEEE_IS_NAN() instead\n   !     FUNCTION    NWTC_ERF( x )\n   !     FUNCTION    NWTC_gamma( x )                                          ! Returns the gamma value of its argument.   \n   !     SUBROUTINE  FlushOut ( Unit )\n   !     SUBROUTINE  GET_CWD( DirName, Status )\n   !     SUBROUTINE  MKDIR( new_directory_path )\n   !     SUBROUTINE  OpenCon\n   !     SUBROUTINE  OpenUnfInpBEFile ( Un, InFile, RecLen, Error )\n   !     SUBROUTINE  ProgExit ( StatCode )\n   !     SUBROUTINE  Set_IEEE_Constants( NaN_D, Inf_D, NaN, Inf, NaN_S, Inf_S )   \n   !     SUBROUTINE  UsrAlarm\n   !     SUBROUTINE  WrNR ( Str )\n   !     SUBROUTINE  WrOver ( Str )\n   !     SUBROUTINE  WriteScr ( Str, Frm )\n   !     SUBROUTINE LoadDynamicLib( DLL, ErrStat, ErrMsg )\n   !     SUBROUTINE FreeDynamicLib( DLL, ErrStat, ErrMsg )\n   \n   USE NWTC_Base\n\n   IMPLICIT NONE\n\n   INTERFACE NWTC_ERF ! Returns the ERF value of its argument\n      MODULE PROCEDURE NWTC_ERFR4\n      MODULE PROCEDURE NWTC_ERFR8\n      MODULE PROCEDURE NWTC_ERFR16\n   END INTERFACE\n\n   INTERFACE NWTC_gamma ! Returns the gamma value of its argument\n         ! note: gamma is part of the F08 standard, but may not be implemented everywhere...\n      MODULE PROCEDURE NWTC_gammaR4\n      MODULE PROCEDURE NWTC_gammaR8\n      MODULE PROCEDURE NWTC_gammaR16\n   END INTERFACE\n\n   INTEGER, PARAMETER            :: ConRecL     = 120                               ! The record length for console output.\n   INTEGER, PARAMETER            :: CU          = 6                                 ! The I/O unit for the console.  Unit 6 causes ADAMS to crash.\n   INTEGER, PARAMETER            :: MaxWrScrLen = 98                                ! The maximum number of characters allowed to be written to a line in WrScr\n   LOGICAL, PARAMETER            :: KBInputOK   = .TRUE.                            ! A flag to tell the program that keyboard input is allowed in the environment.\n   CHARACTER(*),  PARAMETER      :: NewLine     = ACHAR(10)                         ! The delimiter for New Lines [ Windows is CHAR(13)//CHAR(10); MAC is CHAR(13); Unix is CHAR(10) {CHAR(13)=\\r is a line feed, CHAR(10)=\\n is a new line}]\n   CHARACTER(*),  PARAMETER      :: OS_Desc     = 'Intel Fortran for Linux'         ! Description of the language/OS\n   CHARACTER( 1), PARAMETER      :: PathSep     = '/'                               ! The path separator.\n   CHARACTER( 1), PARAMETER      :: SwChar      = '-'                               ! The switch character for command-line options.\n   CHARACTER(11), PARAMETER      :: UnfForm     = 'UNFORMATTED'                     ! The string to specify unformatted I/O files.   \n\nCONTAINS\n\n!=======================================================================\nFUNCTION FileSize( Unit )\n\n   ! This function calls the portability routine, FSTAT, to obtain the file size\n   ! in bytes corresponding to a file unit number or returns -1 on error.\n\n   USE IFPORT\n\n   INTEGER(B8Ki)                             :: FileSize                      ! The size of the file in bytes to be returned.\n   INTEGER, INTENT(IN)                       :: Unit                          ! The I/O unit number of the pre-opened file.\n   INTEGER                                   :: StatArray(12)                 ! An array returned by FSTAT that includes the file size.\n   INTEGER                                   :: Status                        ! The status returned by\n\n   Status = FSTAT( INT( Unit, B4Ki ), StatArray )\n\n   IF ( Status /= 0 ) THEN\n      FileSize = -1\n   ELSE\n      FileSize = StatArray(8)\n   END IF\n\n   RETURN\nEND FUNCTION FileSize ! ( Unit )\n!=======================================================================\nFUNCTION Is_NaN( DblNum )\n\n   ! This routine determines if a REAL(DbKi) variable holds a proper number.\n   ! BJJ: this routine is used in CRUNCH.\n   ! It should be replaced with IEEE_IS_NAN in new code, but remains here for\n   ! backwards compatibility.\n\n   USE, INTRINSIC :: ieee_arithmetic\n\n   REAL(DbKi), INTENT(IN)       :: DblNum\n   LOGICAL                      :: Is_Nan\n\n   Is_NaN = IEEE_IS_NAN( DblNum )\n\n   RETURN\nEND FUNCTION Is_NaN ! ( DblNum )\n!=======================================================================\nFUNCTION NWTC_ERFR4( x )\n\n   ! Returns the ERF value of its argument. The result has a value equal  \n   ! to the error function: 2/pi * integral_from_0_to_x of e^(-t^2) dt. \n\n   REAL(SiKi), INTENT(IN)     :: x           ! input \n   REAL(SiKi)                 :: NWTC_ERFR4  ! result\n\n   NWTC_ERFR4 = ERF( x )\n\nEND FUNCTION NWTC_ERFR4\n!=======================================================================\nFUNCTION NWTC_ERFR8( x )\n\n   ! Returns the ERF value of its argument. The result has a value equal  \n   ! to the error function: 2/pi * integral_from_0_to_x of e^(-t^2) dt. \n\n   REAL(R8Ki), INTENT(IN)     :: x             ! input \n   REAL(R8Ki)                 :: NWTC_ERFR8    ! result\n\n   NWTC_ERFR8 = ERF( x )\n\nEND FUNCTION NWTC_ERFR8\n!=======================================================================\nFUNCTION NWTC_ERFR16( x )\n\n   ! Returns the ERF value of its argument. The result has a value equal  \n   ! to the error function: 2/pi * integral_from_0_to_x of e^(-t^2) dt. \n\n   REAL(QuKi), INTENT(IN)     :: x             ! input \n   REAL(QuKi)                 :: NWTC_ERFR16   ! result\n\n   NWTC_ERFR16 = ERF( x )\n\nEND FUNCTION NWTC_ERFR16\n!=======================================================================\nFUNCTION NWTC_GammaR4( x )\n\n   ! Returns the gamma value of its argument. The result has a value equal  \n   ! to a processor-dependent approximation to the gamma function of x. \n\n   REAL(SiKi), INTENT(IN)     :: x             ! input \n   REAL(SiKi)                 :: NWTC_GammaR4  ! result\n   \n   NWTC_GammaR4 = gamma( x )\n\nEND FUNCTION NWTC_GammaR4\n!=======================================================================\nFUNCTION NWTC_GammaR8( x )\n\n   ! Returns the gamma value of its argument. The result has a value equal  \n   ! to a processor-dependent approximation to the gamma function of x. \n\n   REAL(R8Ki), INTENT(IN)     :: x             ! input \n   REAL(R8Ki)                 :: NWTC_GammaR8  ! result\n   \n   NWTC_GammaR8 = gamma( x )\n\nEND FUNCTION NWTC_GammaR8\n!=======================================================================\nFUNCTION NWTC_GammaR16( x )\n\n   ! Returns the gamma value of its argument. The result has a value equal  \n   ! to a processor-dependent approximation to the gamma function of x. \n\n   REAL(QuKi), INTENT(IN)     :: x             ! input \n   REAL(QuKi)                 :: NWTC_GammaR16  ! result\n   \n   NWTC_GammaR16 = gamma( x )\n\nEND FUNCTION NWTC_GammaR16\n!=======================================================================\nSUBROUTINE FlushOut ( Unit )\n\n   ! This subroutine flushes the buffer on the specified Unit.\n   ! It is especially useful when printing \"running...\" type messages.\n\n   USE IFPORT\n\n   INTEGER, INTENT(IN)          :: Unit                                         ! The unit number of the file being flushed.\n\n   CALL FLUSH ( INT(Unit, B4Ki) )\n\n   RETURN\nEND SUBROUTINE FlushOut ! ( Unit )\n!=======================================================================\nSUBROUTINE Get_CWD ( DirName, Status )\n\n   USE IFPORT, ONLY: GETCWD\n\n   IMPLICIT                        NONE\n\n   CHARACTER(*), INTENT(OUT)    :: DirName                                         ! A CHARACTER string containing the path of the current working directory.\n   INTEGER,      INTENT(OUT)    :: Status                                          ! Status returned by the call to a portability routine.\n\n   Status = GETCWD ( DirName )\n\n   RETURN\nEND SUBROUTINE Get_CWD\n!=======================================================================\nSUBROUTINE MKDIR ( new_directory_path )\n\n   ! This routine creates a given directory if it does not exist.\n\n   implicit none\n\n   character(*), intent(in) :: new_directory_path\n   character(1024)          :: make_command\n   logical                  :: directory_exists\n\n   ! Check if the directory exists first\n   inquire( directory=trim(new_directory_path), exist=directory_exists )\n\n   if ( .NOT. directory_exists ) then\n      make_command = 'mkdir -p '//trim(new_directory_path)\n      call system( make_command )\n   endif\n\nEND SUBROUTINE MKDIR\n!=======================================================================\nSUBROUTINE OpenCon\n\n   ! This routine opens the console for standard output.\n\n   USE IFPORT\n\n!bjj: Because CU = 6 now, this statement is not necessary\n!   OPEN ( CU , FILE='/dev/stdout' , STATUS='UNKNOWN' , CARRIAGECONTROL='FORTRAN', RECL=ConRecL )\n\n!   CALL FlushOut ( CU )\n\n   RETURN\nEND SUBROUTINE OpenCon\n!=======================================================================\nSUBROUTINE OpenUnfInpBEFile ( Un, InFile, RecLen, Error )\n\n   ! This routine opens a binary input file with data stored in Big Endian format (created on a UNIX machine.)\n   ! Data are stored in RecLen-byte records.\n\n   IMPLICIT NONE\n\n   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the input file.\n   CHARACTER(*), INTENT(IN)     :: InFile                                       ! Name of the input file.\n   INTEGER, INTENT(IN)          :: RecLen                                       ! Size of records in the input file, in bytes.\n   LOGICAL, INTENT(OUT)         :: Error                                        ! Flag to indicate the open failed.\n   INTEGER                      :: IOS                                          ! I/O status of OPEN.\n\n   ! Open input file.  Make sure it worked.\n\n   ! The non-standard CONVERT keyword allows us to read UNIX binary files, whose bytes are in reverse order (i.e., stored in BIG ENDIAN format).\n   ! NOTE: using RecLen in bytes requires using the /assume:byterecl compiler option!\n   OPEN ( Un, FILE=TRIM( InFile ), STATUS='OLD', FORM='UNFORMATTED', ACCESS='DIRECT', RECL=RecLen, IOSTAT=IOS, &\n                  ACTION='READ'  )                                              ! Use this for UNIX systems.\n!                  ACTION='READ', CONVERT='BIG_ENDIAN' )                         ! Use this for PC systems.\n\n   IF ( IOS /= 0 )  THEN\n      Error = .TRUE.\n   ELSE\n      Error = .FALSE.\n   END IF\n\n   RETURN\nEND SUBROUTINE OpenUnfInpBEFile\n!=======================================================================\nSUBROUTINE ProgExit ( StatCode )\n\n   ! This routine stops the program.  If the compiler supports the EXIT routine,\n   ! pass the program status to it.  Otherwise, do a STOP.\n\n   INTEGER, INTENT(IN)          :: StatCode                                      ! The status code to pass to the OS.\n\n   CALL EXIT ( StatCode )\n\n   ! IF ( StatCode == 0 ) THEN\n   !    STOP 0\n   ! ELSE\n   !    IF ( StatCode < 0 ) THEN\n   !       CALL WrScr( 'Invalid STOP code.' )\n   !    END IF\n   !    STOP 1\n   ! END IF\n\nEND SUBROUTINE ProgExit ! ( StatCode )\n!=======================================================================\nSUBROUTINE Set_IEEE_Constants( NaN_D, Inf_D, NaN, Inf, NaN_S, Inf_S )   \n\n   ! routine that sets the values of NaN_D, Inf_D, NaN, Inf (IEEE \n   ! values for not-a-number and infinity in sindle and double \n   ! precision) This uses standard F03 intrinsic routines,  \n   ! however Gnu has not yet implemented it, so we've placed this\n   ! routine in the system-specific code.\n\n   USE, INTRINSIC :: ieee_arithmetic  ! use this for compilers that have implemented ieee_arithmetic from F03 standard (otherwise see logic in SysGnu*.f90)\n\n   REAL(DbKi), INTENT(inout)           :: Inf_D          ! IEEE value for NaN (not-a-number) in double precision\n   REAL(DbKi), INTENT(inout)           :: NaN_D          ! IEEE value for Inf (infinity) in double precision\n\n   REAL(ReKi), INTENT(inout)           :: Inf            ! IEEE value for NaN (not-a-number)\n   REAL(ReKi), INTENT(inout)           :: NaN            ! IEEE value for Inf (infinity)\n\n   REAL(SiKi), INTENT(inout)           :: Inf_S          ! IEEE value for NaN (not-a-number) in single precision\n   REAL(SiKi), INTENT(inout)           :: NaN_S          ! IEEE value for Inf (infinity) in single precision\n   \n\n   NaN_D = ieee_value(0.0_DbKi, ieee_quiet_nan)\n   Inf_D = ieee_value(0.0_DbKi, ieee_positive_inf)\n\n   NaN   = ieee_value(0.0_ReKi, ieee_quiet_nan)\n   Inf   = ieee_value(0.0_ReKi, ieee_positive_inf)   \n\n   NaN_S = ieee_value(0.0_SiKi, ieee_quiet_nan)\n   Inf_S = ieee_value(0.0_SiKi, ieee_positive_inf)\n\nEND SUBROUTINE Set_IEEE_Constants  \n!=======================================================================\nSUBROUTINE UsrAlarm\n\n   ! This routine generates an alarm to warn the user that something went wrong.\n\n   CALL WrNR ( CHAR( 7 ) )\n\n   RETURN\nEND SUBROUTINE UsrAlarm\n!=======================================================================\nSUBROUTINE WrNR ( Str )\n\n   ! This routine writes out a string to the screen without following it with a new line.\n\n   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to write to the screen.\n\n   WRITE (CU,'(1X,A)',ADVANCE='NO')  Str\n\n   RETURN\nEND SUBROUTINE WrNR ! ( Str )\n!=======================================================================\nSUBROUTINE WrOver ( Str )\n\n   ! This routine writes out a string that overwrites the previous line\n\n   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to write to the screen.\n\n   WRITE (CU,'(''+'',A)')  Str\n\n   RETURN\nEND SUBROUTINE WrOver ! ( Str )\n!=======================================================================\nSUBROUTINE WriteScr ( Str, Frm )\n\n   ! This routine writes out a string to the screen.\n\n   IMPLICIT NONE\n\n   CHARACTER(*), INTENT(IN)     :: Str                                         ! The input string to write to the screen.\n   CHARACTER(*), INTENT(IN)     :: Frm                                         ! Format specifier for the output.\n   INTEGER                      :: ErrStat                                     ! Error status of write operation (so code doesn't crash)\n\n   IF ( LEN_TRIM(Str)  < 1 ) THEN\n      WRITE ( CU, '()', IOSTAT=ErrStat )\n   ELSE\n      WRITE ( CU, Frm, IOSTAT=ErrStat ) TRIM(Str)\n   END IF\n\n   IF ( ErrStat /= 0 ) THEN\n      print *, ' WriteScr produced an error. Please inform the programmer.'\n   ENDIF\n\nEND SUBROUTINE WriteScr ! ( Str )\n!=======================================================================\nSUBROUTINE LoadDynamicLib ( DLL, ErrStat, ErrMsg )\n\n   ! This SUBROUTINE is used to dynamically load a DLL.\n\n   TYPE (DLL_Type),           INTENT(INOUT)  :: DLL         ! The DLL to be loaded.\n   INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat     ! Error status of the operation\n   CHARACTER(*),              INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None\n\n#ifdef USE_DLL_INTERFACE         \n\n!bjj: these are values I found on the web; I have no idea if they actually work...\n!bjj: hopefully we can find them pre-defined in a header somewhere\n   INTEGER(C_INT), PARAMETER :: RTLD_LAZY=1            ! \"Perform lazy binding. Only resolve symbols as the code that references them is executed. If the symbol is never referenced, then it is never resolved. (Lazy binding is only performed for function references; references to variables are always immediately bound when the library is loaded.) \"\n   INTEGER(C_INT), PARAMETER :: RTLD_NOW=2             ! \"If this value is specified, or the environment variable LD_BIND_NOW is set to a nonempty string, all undefined symbols in the library are resolved before dlopen() returns. If this cannot be done, an error is returned.\"\n   INTEGER(C_INT), PARAMETER :: RTLD_GLOBAL=256        ! \"The symbols defined by this library will be made available for symbol resolution of subsequently loaded libraries\"\n   INTEGER(C_INT), PARAMETER :: RTLD_LOCAL=0           ! \"This is the converse of RTLD_GLOBAL, and the default if neither flag is specified. Symbols defined in this library are not made available to resolve references in subsequently loaded libraries.\"\n\n   INTERFACE !linux API routines\n      !bjj see http://linux.die.net/man/3/dlopen\n      !    and https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/dlopen.3.html\n\n      FUNCTION dlOpen(filename,mode) BIND(C,NAME=\"dlopen\")\n      ! void *dlopen(const char *filename, int mode);\n         USE ISO_C_BINDING\n         IMPLICIT NONE\n         TYPE(C_PTR)                   :: dlOpen\n         CHARACTER(C_CHAR), INTENT(IN) :: filename(*)\n         INTEGER(C_INT), VALUE         :: mode\n      END FUNCTION\n\n   END INTERFACE\n\n   ErrStat = ErrID_None\n   ErrMsg = ''\n\n   ! Load the DLL and get the file address:\n\n   DLL%FileAddrX = dlOpen( TRIM(DLL%FileName)//C_NULL_CHAR, RTLD_LAZY )  !the \"C_NULL_CHAR\" converts the Fortran string to a C-type string (i.e., adds //CHAR(0) to the end)\n\n   IF( .NOT. C_ASSOCIATED(DLL%FileAddrX) ) THEN\n      ErrStat = ErrID_Fatal\n      WRITE(ErrMsg,'(I2)') BITS_IN_ADDR\n      ErrMsg  = 'The dynamic library '//TRIM(DLL%FileName)//' could not be loaded. Check that the file '// &\n                'exists in the specified location and that it is compiled for '//TRIM(ErrMsg)//'-bit applications.'\n      RETURN\n   END IF\n\n   ! Get the procedure address:\n\n   CALL LoadDynamicLibProc ( DLL, ErrStat, ErrMsg )\n#else\n\n   ErrStat = ErrID_Fatal\n   ErrMsg = ' LoadDynamicLib: Not compiled with -DUSE_DLL_INTERFACE for '//TRIM(OS_Desc)\n      \n#endif\n   \n   RETURN\nEND SUBROUTINE LoadDynamicLib\n!=======================================================================\nSUBROUTINE LoadDynamicLibProc ( DLL, ErrStat, ErrMsg )\n\n   ! This SUBROUTINE is used to dynamically load a procedure from a DLL.\n\n   TYPE (DLL_Type),           INTENT(INOUT)  :: DLL         ! The DLL to be loaded.\n   INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat     ! Error status of the operation\n   CHARACTER(*),              INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None\n   INTEGER(IntKi)                            :: i\n\n#ifdef USE_DLL_INTERFACE           \n\n   INTERFACE !linux API routines\n\n      !bjj see http://linux.die.net/man/3/dlsym\n      !    and https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/dlsym.3.html\n      \n      FUNCTION dlSym(handle,name) BIND(C,NAME=\"dlsym\")\n      ! void *dlsym(void *handle, const char *name);\n         USE ISO_C_BINDING\n         IMPLICIT NONE\n         TYPE(C_FUNPTR)                :: dlSym ! A function pointer\n         TYPE(C_PTR), VALUE            :: handle\n         CHARACTER(C_CHAR), INTENT(IN) :: name(*)\n      END FUNCTION\n\n   END INTERFACE\n\n   ErrStat = ErrID_None\n   ErrMsg = ''\n\n   do i=1,NWTC_MAX_DLL_PROC\n      if ( len_trim( DLL%ProcName(i) ) > 0 ) then\n   \n         DLL%ProcAddr(i) = dlSym( DLL%FileAddrX, TRIM(DLL%ProcName(i))//C_NULL_CHAR )  !the \"C_NULL_CHAR\" converts the Fortran string to a C-type string (i.e., adds //CHAR(0) to the end)\n\n         IF(.NOT. C_ASSOCIATED(DLL%ProcAddr(i))) THEN\n            ErrStat = ErrID_Fatal + i - 1\n            ErrMsg  = 'The procedure '//TRIM(DLL%ProcName(i))//' in file '//TRIM(DLL%FileName)//' could not be loaded.'\n            RETURN\n         END IF\n         \n      end if\n   end do\n      \n#else\n\n   ErrStat = ErrID_Fatal\n   ErrMsg = ' LoadDynamicLibProc: Not compiled with -DUSE_DLL_INTERFACE for '//TRIM(OS_Desc)\n      \n#endif\n   \n   RETURN\nEND SUBROUTINE LoadDynamicLibProc\n!=======================================================================\nSUBROUTINE FreeDynamicLib ( DLL, ErrStat, ErrMsg )\n\n      ! This SUBROUTINE is used to free a dynamically loaded DLL (loaded in LoadDynamicLib).\n\n      TYPE (DLL_Type),           INTENT(INOUT)  :: DLL         ! The DLL to be freed.\n      INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat     ! Error status of the operation\n      CHARACTER(*),              INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None\n      INTEGER(C_INT)                            :: Success     ! Whether or not the call to dlClose was successful\n      INTEGER(C_INT), PARAMETER                 :: TRUE  = 0\n\n#ifdef USE_DLL_INTERFACE           \n!bjj: note that this is not tested.\n\n   INTERFACE !linux API routine\n      !bjj see http://linux.die.net/man/3/dlclose\n      !    and https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/dlclose.3.html\n\n      FUNCTION dlClose(handle) BIND(C,NAME=\"dlclose\")\n      ! int dlclose(void *handle);\n         USE ISO_C_BINDING\n         IMPLICIT NONE\n         INTEGER(C_INT)       :: dlClose\n         TYPE(C_PTR), VALUE   :: handle\n      END FUNCTION\n\n   END INTERFACE\n\n   ! Close the library:\n\n   IF( .NOT. C_ASSOCIATED(DLL%FileAddrX) ) RETURN\n   Success = dlClose( DLL%FileAddrX ) !The function dlclose() returns 0 on success, and nonzero on error.\n\n   IF ( Success /= TRUE ) THEN !bjj: note that this is not the same as LOGICAL .TRUE.\n      ErrStat = ErrID_Fatal\n      ErrMsg  = 'The dynamic library could not be freed.'\n      RETURN\n   ELSE\n      ErrStat = ErrID_None\n      ErrMsg = ''\n      DLL%FileAddrX = C_NULL_PTR\n   END IF\n   \n#else\n\n      ErrStat = ErrID_Fatal\n      ErrMsg = ' FreeDynamicLib: Not compiled with -DUSE_DLL_INTERFACE for '//TRIM(OS_Desc)\n         \n#endif\n   \n      RETURN\n   END SUBROUTINE FreeDynamicLib\n!=======================================================================\nEND MODULE SysSubs\n",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/modules/nwtc-library/src/NWTC_Base.f90": "!**********************************************************************************************************************************\n! LICENSING\n! Copyright (C) 2013-2016  National Renewable Energy Laboratory\n!\n!    This file is part of the NWTC Subroutine Library.\n!\n! Licensed under the Apache License, Version 2.0 (the \"License\");\n! you may not use this file except in compliance with the License.\n! You may obtain a copy of the License at\n!\n!     http://www.apache.org/licenses/LICENSE-2.0\n!\n! Unless required by applicable law or agreed to in writing, software\n! distributed under the License is distributed on an \"AS IS\" BASIS,\n! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n! See the License for the specific language governing permissions and\n! limitations under the License.\n!\n!**********************************************************************************************************************************\n!> This module stores basic constants and routines that are not system-specific, but may be used in the system-specific routines.\nMODULE NWTC_Base\n\n\n   USE, INTRINSIC               :: ISO_C_Binding\n   USE                             Precision\n\n   IMPLICIT  NONE\n\n!=======================================================================\n\n   !logical :: debug_print = .false.\n   \n      ! General constants:\n\n   INTEGER, PARAMETER            :: BITS_IN_ADDR  = C_INTPTR_T*8                  !< The number of bits in an address (32-bit or 64-bit).\n   INTEGER, PARAMETER            :: ErrMsgLen = 1024                              !< The maximum number of characters in an error message in the FAST framework\n   \n   INTEGER(IntKi), PARAMETER     :: ChanLen   = 20                                !< The maximum allowable length of channel names (i.e., width of output columns) in the FAST framework\n   INTEGER(IntKi), PARAMETER     :: MinChanLen = 10                               !< The min allowable length of channel names (i.e., width of output columns), used because some modules (like Bladed DLL outputs) have excessively long names\n   INTEGER(IntKi), PARAMETER     :: LinChanLen = 200                              !< The allowable length of row/column names in linearization files\n\n   INTEGER(IntKi), PARAMETER     :: NWTC_Verbose = 10                             !< The maximum level of verbosity\n   INTEGER(IntKi), PARAMETER     :: NWTC_VerboseLevel = 5                         !< a number in [0, NWTC_Verbose]: 0 = no output; NWTC_Verbose=verbose; \n\n      ! Global Error-level variables:\n\n   INTEGER(IntKi), PARAMETER     :: ErrID_None   = 0                              !< ErrStat parameter indicating \"no error\"\n   INTEGER(IntKi), PARAMETER     :: ErrID_Info   = 1                              !< ErrStat parameter indicating \"informational message\"\n   INTEGER(IntKi), PARAMETER     :: ErrID_Warn   = 2                              !< ErrStat parameter indicating \"warning\"\n   INTEGER(IntKi), PARAMETER     :: ErrID_Severe = 3                              !< ErrStat parameter indicating \"severe error\"; \n   INTEGER(IntKi), PARAMETER     :: ErrID_Fatal  = 4                              !< ErrStat parameter indicating \"fatal error\"; simulation should end\n\n   INTEGER(IntKi)                :: AbortErrLev  = ErrID_Fatal                    !< ErrStat that indicates the error level when program should end; ErrID_Fatal by default. Note that this is not a PARAMETER\n\n   \n   INTEGER(IntKi), PARAMETER     :: NWTC_MAX_DLL_PROC  = 3                        !< maximum number of procedures that can be dynamically loaded from a DLL (see DLL_Type nwtc_base::dll_type)\n   \n\n      !> Type definition for dynamically loaded libraries:\n      !! Note that changes here may need to be reflected in DLLTypePack() (nwtc_io::dlltypepack) DLLTypeUnPack() (nwtc_io::dlltypeunpack), \n      !! and the FAST Registry executable.\n   \n   TYPE DLL_Type \n\n      INTEGER(C_INTPTR_T)       :: FileAddr                                        !< The address of file FileName.         (RETURN value from LoadLibrary ) [Windows]\n      TYPE(C_PTR)               :: FileAddrX = C_NULL_PTR                          !< The address of file FileName.         (RETURN value from dlopen ) [Linux]\n      TYPE(C_FUNPTR)            :: ProcAddr(NWTC_MAX_DLL_PROC)  = C_NULL_FUNPTR    !< The address of procedure ProcName.    (RETURN value from GetProcAddress or dlsym) [initialized to Null for pack/unpack]\n\n      CHARACTER(1024)           :: FileName                                        !< The name of the DLL file including the full path to the current working directory.\n      CHARACTER(1024)           :: ProcName(NWTC_MAX_DLL_PROC)  = \"\"               !< The name of the procedure in the DLL that will be called.\n\n   END TYPE DLL_Type\n\n\nEND MODULE NWTC_Base\n",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/modules/nwtc-library/src/SysMatlabLinuxGnu.f90": "!**********************************************************************************************************************************\n! LICENSING\n! Copyright (C) 2013-2015  National Renewable Energy Laboratory\n!\n!    This file is part of the NWTC Subroutine Library.\n!\n! Licensed under the Apache License, Version 2.0 (the \"License\");\n! you may not use this file except in compliance with the License.\n! You may obtain a copy of the License at\n!\n!     http://www.apache.org/licenses/LICENSE-2.0\n!\n! Unless required by applicable law or agreed to in writing, software\n! distributed under the License is distributed on an \"AS IS\" BASIS,\n! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n! See the License for the specific language governing permissions and\n! limitations under the License.\n!\n!**********************************************************************************************************************************\nMODULE SysSubs\n\n   ! This module contains routines with system-specific logic and references, including all references to the console unit, CU.\n   ! It also contains standard (but not system-specific) routines it uses.\n   ! This system configuration requires linking with the matlab library, libmex.dll or libmex.dylib or libmex.so, from the matlab\n   ! installation directory.\n   ! SysMatlabGnuLinux.f90 is specifically for the GNU Fortran (gfortran) compiler on Linux and macOS.\n   ! It contains the following routines:\n   !     FUNCTION    FileSize( Unit )                                         ! Returns the size (in bytes) of an open file.\n   !     FUNCTION    Is_NaN( DblNum )                                         ! Please use IEEE_IS_NAN() instead\n   !     FUNCTION    NWTC_ERF( x )\n   !     FUNCTION    NWTC_gamma( x )                                          ! Returns the gamma value of its argument.   \n   !     SUBROUTINE  FlushOut ( Unit )\n   !     SUBROUTINE  GET_CWD( DirName, Status )\n   !     SUBROUTINE  MKDIR( new_directory_path )\n   !     SUBROUTINE  OpenCon\n   !     SUBROUTINE  OpenUnfInpBEFile ( Un, InFile, RecLen, Error )\n   !     SUBROUTINE  ProgExit ( StatCode )\n   !     SUBROUTINE  Set_IEEE_Constants( NaN_D, Inf_D, NaN, Inf )   \n   !     SUBROUTINE  UsrAlarm\n   !     SUBROUTINE  WrNR ( Str )\n   !     SUBROUTINE  WrOver ( Str )\n   !     SUBROUTINE  WriteScr ( Str, Frm )\n   !     SUBROUTINE LoadDynamicLib( DLL, ErrStat, ErrMsg )\n   !     SUBROUTINE FreeDynamicLib( DLL, ErrStat, ErrMsg )\n\n   USE NWTC_Base\n\n   IMPLICIT NONE\n\n   INTERFACE NWTC_ERF ! Returns the ERF value of its argument\n      MODULE PROCEDURE NWTC_ERFR4\n      MODULE PROCEDURE NWTC_ERFR8\n      MODULE PROCEDURE NWTC_ERFR16\n   END INTERFACE\n\n   INTERFACE NWTC_gamma ! Returns the gamma value of its argument\n         ! note: gamma is part of the F08 standard, but may not be implemented everywhere...\n      MODULE PROCEDURE NWTC_gammaR4\n      MODULE PROCEDURE NWTC_gammaR8\n      MODULE PROCEDURE NWTC_gammaR16\n   END INTERFACE\n\n   INTEGER, PARAMETER            :: ConRecL     = 120                               ! The record length for console output.\n   INTEGER, PARAMETER            :: CU          = 6                                 ! The I/O unit for the console.  Unit 6 causes ADAMS to crash.\n   INTEGER, PARAMETER            :: MaxWrScrLen = 98                                ! The maximum number of characters allowed to be written to a line in WrScr\n   LOGICAL, PARAMETER            :: KBInputOK   = .FALSE.                           ! A flag to tell the program that keyboard input is allowed in the environment.\n   CHARACTER(*),  PARAMETER      :: NewLine     = ACHAR(10)                         ! The delimiter for New Lines [ Windows is CHAR(13)//CHAR(10); MAC is CHAR(13); Unix is CHAR(10) {CHAR(13)=\\r is a line feed, CHAR(10)=\\n is a new line}]\n   CHARACTER(*),  PARAMETER      :: OS_Desc     = 'GNU Fortran for Linux with Matlab'           ! Description of the language/OS\n   CHARACTER( 1), PARAMETER      :: PathSep     = '/'                               ! The path separator.\n   CHARACTER( 1), PARAMETER      :: SwChar      = '-'                               ! The switch character for command-line options.\n   CHARACTER(11), PARAMETER      :: UnfForm     = 'UNFORMATTED'                     ! The string to specify unformatted I/O files.\n\nCONTAINS\n\n!=======================================================================\nFUNCTION FileSize( Unit )\n\n   ! This function calls the portability routine, FSTAT, to obtain the file size\n   ! in bytes corresponding to a file unit number or returns -1 on error.\n\n   INTEGER(B8Ki)                             :: FileSize                      ! The size of the file in bytes to be returned.\n   INTEGER, INTENT(IN)                       :: Unit                          ! The I/O unit number of the pre-opened file.\n   INTEGER(4)                                :: StatArray(13)                 ! An array returned by FSTAT that includes the file size.\n   INTEGER(4)                                :: Status                        ! The status returned by\n\n   Status = FSTAT( INT( Unit, B4Ki ), StatArray )\n\n   IF ( Status /= 0 ) THEN\n      FileSize = -1\n   ELSE\n      FileSize = StatArray(8)\n   END IF\n\n   RETURN\nEND FUNCTION FileSize ! ( Unit )\n!=======================================================================\nFUNCTION Is_NaN( DblNum )\n\n   ! This routine determines if a REAL(DbKi) variable holds a proper number.\n   ! BJJ: this routine is used in CRUNCH.\n   ! Note that IsNaN does not exist in earlier versions of gfortran (e.g., 4.2.1),\n   ! but does exist in version 4.4. It should be replaced with the standard\n   ! IEEE_IS_NAN when gfortran implements it.\n\n   REAL(DbKi), INTENT(IN)       :: DblNum\n   LOGICAL                      :: Is_Nan\n\n   Is_NaN = IsNaN( DblNum )\n\n   RETURN\nEND FUNCTION Is_NaN ! ( DblNum )\n!=======================================================================\nFUNCTION NWTC_ERFR4( x )\n\n   ! Returns the ERF value of its argument. The result has a value equal  \n   ! to the error function: 2/pi * integral_from_0_to_x of e^(-t^2) dt. \n\n   REAL(SiKi), INTENT(IN)     :: x           ! input \n   REAL(SiKi)                 :: NWTC_ERFR4  ! result\n   \n   NWTC_ERFR4 = ERF( x )\n\nEND FUNCTION NWTC_ERFR4\n!=======================================================================\nFUNCTION NWTC_ERFR8( x )\n\n   ! Returns the ERF value of its argument. The result has a value equal  \n   ! to the error function: 2/pi * integral_from_0_to_x of e^(-t^2) dt. \n\n   REAL(R8Ki), INTENT(IN)     :: x             ! input \n   REAL(R8Ki)                 :: NWTC_ERFR8    ! result\n   \n   NWTC_ERFR8 = ERF( x )\n\nEND FUNCTION NWTC_ERFR8\n!=======================================================================\nFUNCTION NWTC_ERFR16( x )\n\n   ! Returns the ERF value of its argument. The result has a value equal  \n   ! to the error function: 2/pi * integral_from_0_to_x of e^(-t^2) dt. \n\n   REAL(QuKi), INTENT(IN)     :: x             ! input \n   REAL(QuKi)                 :: NWTC_ERFR16   ! result\n   \n   NWTC_ERFR16 = ERF( x )\n\nEND FUNCTION NWTC_ERFR16\n!=======================================================================\nFUNCTION NWTC_GammaR4( x )\n\n   ! Returns the gamma value of its argument. The result has a value equal  \n   ! to a processor-dependent approximation to the gamma function of x. \n\n   REAL(SiKi), INTENT(IN)     :: x             ! input \n   REAL(SiKi)                 :: NWTC_GammaR4  ! result\n   \n   NWTC_GammaR4 = gamma( x )\n\nEND FUNCTION NWTC_GammaR4\n!=======================================================================\nFUNCTION NWTC_GammaR8( x )\n\n   ! Returns the gamma value of its argument. The result has a value equal  \n   ! to a processor-dependent approximation to the gamma function of x. \n\n   REAL(R8Ki), INTENT(IN)     :: x             ! input \n   REAL(R8Ki)                 :: NWTC_GammaR8  ! result\n   \n   NWTC_GammaR8 = gamma( x )\n\nEND FUNCTION NWTC_GammaR8\n!=======================================================================\nFUNCTION NWTC_GammaR16( x )\n\n   ! Returns the gamma value of its argument. The result has a value equal  \n   ! to a processor-dependent approximation to the gamma function of x. \n\n   REAL(QuKi), INTENT(IN)     :: x             ! input \n   REAL(QuKi)                 :: NWTC_GammaR16  ! result\n   \n   NWTC_GammaR16 = gamma( x )\n\nEND FUNCTION NWTC_GammaR16\n!=======================================================================\nSUBROUTINE FlushOut ( Unit )\n\n   ! This subroutine flushes the buffer on the specified Unit.\n   ! It is especially useful when printing \"running...\" type messages.\n   \n   INTEGER, INTENT(IN)          :: Unit                                         ! The unit number of the file being flushed.\n\n   ! CALL FLUSH ( Unit )\n\n   RETURN\nEND SUBROUTINE FlushOut ! ( Unit )\n!=======================================================================\n!bjj note: this subroutine is not tested for this compiler\nSUBROUTINE Get_CWD ( DirName, Status )\n\n   ! This routine retrieves the path of the current working directory.\n\n   IMPLICIT NONE\n\n   CHARACTER(*), INTENT(OUT)    :: DirName                                         ! A CHARACTER string containing the path of the current working directory.\n   INTEGER,      INTENT(OUT)    :: Status                                          ! Status returned by the call to a portability routine.\n\n   Status = GETCWD ( DirName )\n\n   RETURN\nEND SUBROUTINE Get_CWD\n!=======================================================================\nSUBROUTINE MKDIR ( new_directory_path )\n\n   ! This routine creates a given directory if it does not exist.\n\n   implicit none\n\n   character(*), intent(in) :: new_directory_path\n   character(1024)          :: make_command\n   logical                  :: directory_exists\n\n   ! Check if the directory exists first\n   inquire( file=trim(new_directory_path), exist=directory_exists )\n\n   if ( .NOT. directory_exists ) then\n      make_command = 'mkdir -p '//trim(new_directory_path)\n      call system( make_command )\n   endif\n\nEND SUBROUTINE MKDIR\n!=======================================================================\nSUBROUTINE OpenCon\n\n   ! This routine opens the console for standard output.\n\n!bjj: Because CU = 6 now, this statement is not necessary\n!   OPEN ( CU , FILE='/dev/stdout' , STATUS='OLD' )\n\n!   CALL FlushOut ( CU )\n\n   RETURN\nEND SUBROUTINE OpenCon\n!=======================================================================\nSUBROUTINE OpenUnfInpBEFile ( Un, InFile, RecLen, Error )\n\n   ! This routine opens a binary input file with data stored in Big Endian format (created on a UNIX machine.)\n   ! Data are stored in RecLen-byte records.\n\n   IMPLICIT                        NONE\n\n   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the input file.\n   CHARACTER(*), INTENT(IN)     :: InFile                                       ! Name of the input file.\n   INTEGER, INTENT(IN)          :: RecLen                                       ! Size of records in the input file, in bytes.\n   LOGICAL, INTENT(OUT)         :: Error                                        ! Flag to indicate the open failed.\n   INTEGER                      :: IOS                                          ! I/O status of OPEN.\n\n   ! Open input file.  Make sure it worked.\n\n   ! The non-standard CONVERT keyword allows us to read UNIX binary files, whose bytes are in reverse order (i.e., stored in BIG ENDIAN format).\n   ! NOTE: using RecLen in bytes requires using the /assume:byterecl compiler option!\n   OPEN ( Un, FILE=TRIM( InFile ), STATUS='OLD', FORM='UNFORMATTED', ACCESS='DIRECT', RECL=RecLen, IOSTAT=IOS, &\n                  ACTION='READ'  )                                              ! Use this for UNIX systems.\n   !            ACTION='READ', CONVERT='BIG_ENDIAN' )                         ! Use this for PC systems.\n\n   IF ( IOS /= 0 )  THEN\n      Error = .TRUE.\n   ELSE\n      Error = .FALSE.\n   END IF\n\n   RETURN\nEND SUBROUTINE OpenUnfInpBEFile\n!=======================================================================\nSUBROUTINE ProgExit ( StatCode )\n\n   ! This routine stops the program.  If the compiler supports the EXIT routine,\n   ! pass the program status to it.  Otherwise, do a STOP.\n\n   INTEGER, INTENT(IN)          :: StatCode                                      ! The status code to pass to the OS.\n\n   ! CALL EXIT ( StatCode )\n\n   ! IF ( StatCode == 0 ) THEN\n   !    STOP 0\n   ! ELSE\n   !    IF ( StatCode < 0 ) THEN\n   !       CALL WrScr( 'Invalid STOP code.' )\n   !    END IF\n   !    STOP 1\n   ! END IF\n\nEND SUBROUTINE ProgExit ! ( StatCode )\n!=======================================================================\nSUBROUTINE Set_IEEE_Constants( NaN_D, Inf_D, NaN, Inf )   \n      \n   ! routine that sets the values of NaN_D, Inf_D, NaN, Inf (IEEE \n   ! values for not-a-number and infinity in sindle and double \n   ! precision) F03 has standard intrinsic routines to do this,  \n   ! but Gnu has not yet implemented it. This code will fail if  \n   ! the compiler checks for floating-point-error, hence the  \n   ! compiler directive FPE_TRAP_ENABLED.\n\n   REAL(DbKi), INTENT(inout)           :: Inf_D          ! IEEE value for NaN (not-a-number) in double precision\n   REAL(DbKi), INTENT(inout)           :: NaN_D          ! IEEE value for Inf (infinity) in double precision\n   REAL(ReKi), INTENT(inout)           :: Inf            ! IEEE value for NaN (not-a-number)\n   REAL(ReKi), INTENT(inout)           :: NaN            ! IEEE value for Inf (infinity)\n\n      ! local variables for getting values of NaN and Inf (not necessary when using ieee_arithmetic)\n   REAL(DbKi)                          :: Neg_D          ! a negative real(DbKi) number\n   REAL(ReKi)                          :: Neg            ! a negative real(ReKi) number\n\n   \n      ! if compiling with floating-point-exception traps, this will not work, so we've added a compiler directive.\n      !  note that anything that refers to NaN or Inf will be incorrect in that case.\n      \n#ifndef FPE_TRAP_ENABLED      \n      ! set variables to negative numbers to calculate NaNs (compilers may complain when taking sqrt of negative constants)\n   Neg_D = -1.0_DbKi\n   Neg   = -1.0_ReKi\n\n   NaN_D = SQRT ( Neg_D )\n   NaN   = SQRT ( Neg )\n\n      ! set variables to zero to calculate Infs (using division by zero)\n   Neg_D = 0.0_DbKi\n   Neg   = 0.0_ReKi\n   \n   Inf_D = 1.0_DbKi / Neg_D\n   Inf   = 1.0_ReKi / Neg\n#endif \n\nEND SUBROUTINE Set_IEEE_Constants\n!=======================================================================\nSUBROUTINE UsrAlarm\n\n   ! This routine generates an alarm to warn the user that something went wrong.\n\n   CALL WrNR ( CHAR( 7 ) )\n\n   RETURN\nEND SUBROUTINE UsrAlarm\n!=======================================================================\nSUBROUTINE WrNR ( Str )\n\n      ! This routine writes out a string to the screen without following it with a new line.\n\n   CHARACTER(*), INTENT(IN)     :: Str       ! The string to write to the screen.\n   INTEGER                      :: Stat      ! Number of characters printed\n   INTEGER, EXTERNAL            :: mexPrintF ! Matlab function to print to the command window\n   CHARACTER(1024), SAVE        :: Str2      ! bjj: need static variable to print to Matlab command window\n\n   Str2 = ' '//Str\n   Stat = mexPrintF( Str2 )\n   \n   RETURN\nEND SUBROUTINE WrNR ! ( Str )\n!=======================================================================\nSUBROUTINE WrOver ( Str )\n\n   ! This routine writes out a string that overwrites the previous line\n\n   CHARACTER(*), INTENT(IN) :: Str ! The string to write to the screen.\n\n   CALL WriteScr( Str, '(A)' )\n\n   RETURN\nEND SUBROUTINE WrOver ! ( Str )\n!=======================================================================\nSUBROUTINE WriteScr ( Str, Frm )\n\n   ! This routine writes out a string to the screen.\n\n   IMPLICIT NONE\n\n   CHARACTER(*), INTENT(IN)     :: Str       ! The input string to write to the screen.\n   CHARACTER(*), INTENT(IN)     :: Frm       ! Format specifier for the output.\n   INTEGER                      :: ErrStat   ! Error status of write operation (so code doesn't crash)\n   INTEGER, EXTERNAL            :: mexPrintF ! Matlab function to print to the command window\n   INTEGER                      :: Stat      ! Number of characters printed to the screen\n   CHARACTER( 1024 ), SAVE      :: Str2      ! A temporary string (Str written with the Frm Format specification) (bjj: this apparently needs to be a static variable so it writes to the Matlab command window)\n\n   IF ( LEN_TRIM(Str)  < 1 ) THEN\n      Str2=''\n   ELSE\n      WRITE (Str2,Frm, IOSTAT=Stat)  ADJUSTL( Str )\n   END IF\n\n   Str2 = trim(Str2)//NewLine\n   Stat = mexPrintF( Str2 )\n\nEND SUBROUTINE WriteScr ! ( Str )\n!=======================================================================\nSUBROUTINE LoadDynamicLib ( DLL, ErrStat, ErrMsg )\n\n   ! This SUBROUTINE is used to dynamically load a DLL.\n\n   TYPE (DLL_Type),           INTENT(INOUT)  :: DLL         ! The DLL to be loaded.\n   INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat     ! Error status of the operation\n   CHARACTER(*),              INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None\n\n#ifdef USE_DLL_INTERFACE         \n\n!bjj: these are values I found on the web; I have no idea if they actually work...\n!bjj: hopefully we can find them pre-defined in a header somewhere\n   INTEGER(C_INT), PARAMETER :: RTLD_LAZY=1            ! \"Perform lazy binding. Only resolve symbols as the code that references them is executed. If the symbol is never referenced, then it is never resolved. (Lazy binding is only performed for function references; references to variables are always immediately bound when the library is loaded.) \"\n   INTEGER(C_INT), PARAMETER :: RTLD_NOW=2             ! \"If this value is specified, or the environment variable LD_BIND_NOW is set to a nonempty string, all undefined symbols in the library are resolved before dlopen() returns. If this cannot be done, an error is returned.\"\n   INTEGER(C_INT), PARAMETER :: RTLD_GLOBAL=256        ! \"The symbols defined by this library will be made available for symbol resolution of subsequently loaded libraries\"\n   INTEGER(C_INT), PARAMETER :: RTLD_LOCAL=0           ! \"This is the converse of RTLD_GLOBAL, and the default if neither flag is specified. Symbols defined in this library are not made available to resolve references in subsequently loaded libraries.\"\n\n   INTERFACE !linux API routines\n      !bjj see http://linux.die.net/man/3/dlopen\n      !    and https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/dlopen.3.html\n\n      FUNCTION dlOpen(filename,mode) BIND(C,NAME=\"dlopen\")\n      ! void *dlopen(const char *filename, int mode);\n         USE ISO_C_BINDING\n         IMPLICIT NONE\n         TYPE(C_PTR)                   :: dlOpen\n         CHARACTER(C_CHAR), INTENT(IN) :: filename(*)\n         INTEGER(C_INT), VALUE         :: mode\n      END FUNCTION\n\n   END INTERFACE\n\n   ErrStat = ErrID_None\n   ErrMsg = ''\n\n   ! Load the DLL and get the file address:\n\n   DLL%FileAddrX = dlOpen( TRIM(DLL%FileName)//C_NULL_CHAR, RTLD_LAZY )  !the \"C_NULL_CHAR\" converts the Fortran string to a C-type string (i.e., adds //CHAR(0) to the end)\n\n   IF( .NOT. C_ASSOCIATED(DLL%FileAddrX) ) THEN\n      ErrStat = ErrID_Fatal\n      WRITE(ErrMsg,'(I2)') BITS_IN_ADDR\n      ErrMsg  = 'The dynamic library '//TRIM(DLL%FileName)//' could not be loaded. Check that the file '// &\n               'exists in the specified location and that it is compiled for '//TRIM(ErrMsg)//'-bit applications.'\n      RETURN\n   END IF\n\n   ! Get the procedure address:\n\n   CALL LoadDynamicLibProc ( DLL, ErrStat, ErrMsg )\n#else\n\n   ErrStat = ErrID_Fatal\n   ErrMsg = ' LoadDynamicLib: Not compiled with -DUSE_DLL_INTERFACE for '//TRIM(OS_Desc)\n\n#endif\n\n   RETURN\nEND SUBROUTINE LoadDynamicLib\n!=======================================================================\nSUBROUTINE LoadDynamicLibProc ( DLL, ErrStat, ErrMsg )\n\n   ! This SUBROUTINE is used to dynamically load a procedure from a DLL.\n\n   TYPE (DLL_Type),           INTENT(INOUT)  :: DLL         ! The DLL to be loaded.\n   INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat     ! Error status of the operation\n   CHARACTER(*),              INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None\n   INTEGER(IntKi)                            :: i\n\n#ifdef USE_DLL_INTERFACE           \n\n   INTERFACE !linux API routines\n\n      !bjj see http://linux.die.net/man/3/dlsym\n      !    and https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/dlsym.3.html\n      \n      FUNCTION dlSym(handle,name) BIND(C,NAME=\"dlsym\")\n      ! void *dlsym(void *handle, const char *name);\n         USE ISO_C_BINDING\n         IMPLICIT NONE\n         TYPE(C_FUNPTR)                :: dlSym ! A function pointer\n         TYPE(C_PTR), VALUE            :: handle\n         CHARACTER(C_CHAR), INTENT(IN) :: name(*)\n      END FUNCTION\n\n   END INTERFACE\n\n   ErrStat = ErrID_None\n   ErrMsg = ''\n\n   do i=1,NWTC_MAX_DLL_PROC\n      if ( len_trim( DLL%ProcName(i) ) > 0 ) then\n   \n         DLL%ProcAddr(i) = dlSym( DLL%FileAddrX, TRIM(DLL%ProcName(i))//C_NULL_CHAR )  !the \"C_NULL_CHAR\" converts the Fortran string to a C-type string (i.e., adds //CHAR(0) to the end)\n\n         IF(.NOT. C_ASSOCIATED(DLL%ProcAddr(i))) THEN\n            ErrStat = ErrID_Fatal + i - 1\n            ErrMsg  = 'The procedure '//TRIM(DLL%ProcName(i))//' in file '//TRIM(DLL%FileName)//' could not be loaded.'\n            RETURN\n         END IF\n         \n      end if\n   end do\n   \n#else\n\n   ErrStat = ErrID_Fatal\n   ErrMsg = ' LoadDynamicLibProc: Not compiled with -DUSE_DLL_INTERFACE for '//TRIM(OS_Desc)\n   \n#endif\n\n   RETURN\nEND SUBROUTINE LoadDynamicLibProc\n!=======================================================================\nSUBROUTINE FreeDynamicLib ( DLL, ErrStat, ErrMsg )\n\n   ! This SUBROUTINE is used to free a dynamically loaded DLL (loaded in LoadDynamicLib).\n\n   TYPE (DLL_Type),           INTENT(INOUT)  :: DLL         ! The DLL to be freed.\n   INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat     ! Error status of the operation\n   CHARACTER(*),              INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None\n   INTEGER(C_INT)                            :: Success     ! Whether or not the call to dlClose was successful\n   INTEGER(C_INT), PARAMETER                 :: TRUE  = 0\n\n#ifdef USE_DLL_INTERFACE           \n!bjj: note that this is not tested.\n\n   INTERFACE !linux API routine\n      !bjj see http://linux.die.net/man/3/dlclose\n      !    and https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/dlclose.3.html\n\n      FUNCTION dlClose(handle) BIND(C,NAME=\"dlclose\")\n      ! int dlclose(void *handle);\n         USE ISO_C_BINDING\n         IMPLICIT NONE\n         INTEGER(C_INT)       :: dlClose\n         TYPE(C_PTR), VALUE   :: handle\n      END FUNCTION\n\n   END INTERFACE\n\n   ! Close the library:\n\n   IF( .NOT. C_ASSOCIATED(DLL%FileAddrX) ) RETURN\n   Success = dlClose( DLL%FileAddrX ) !The function dlclose() returns 0 on success, and nonzero on error.\n\n   IF ( Success /= TRUE ) THEN !bjj: note that this is not the same as LOGICAL .TRUE.\n      ErrStat = ErrID_Fatal\n      ErrMsg  = 'The dynamic library could not be freed.'\n      RETURN\n   ELSE\n      ErrStat = ErrID_None\n      ErrMsg = ''\n      DLL%FileAddrX = C_NULL_PTR\n   END IF\n   \n#else\n\n   ErrStat = ErrID_Fatal\n   ErrMsg = ' FreeDynamicLib: Not compiled with -DUSE_DLL_INTERFACE for '//TRIM(OS_Desc)\n      \n#endif\n\n   RETURN\nEND SUBROUTINE FreeDynamicLib\n!=======================================================================\nEND MODULE SysSubs\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/.git/objects/pack/pack-77c3993ddb3626e469f76756a825ac423f92f54a.pack",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/.git/objects/pack/pack-77c3993ddb3626e469f76756a825ac423f92f54a.idx",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/dev/images/offshore_lapack.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-aeroacoustics/media/NoiseN002.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-aeroacoustics/media/NoiseN007.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-aeroacoustics/media/NoiseN011.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-aeroacoustics/media/NoiseN009.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-aeroacoustics/media/NoiseN003.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-aeroacoustics/media/NoiseN006.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-aeroacoustics/media/NoiseN010.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-aeroacoustics/media/NoiseN005.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-aeroacoustics/media/NoiseN012.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-aeroacoustics/media/NoiseN004.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-aeroacoustics/media/NoiseN008.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/subdyn/figs/global-cs.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/subdyn/figs/flowchart.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/subdyn/figs/extramoment.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/subdyn/figs/element-cs.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/subdyn/figs/self-extractor.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/subdyn/figs/FEJointPin.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/subdyn/figs/FEPreTension.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/subdyn/figs/flowchart2.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/subdyn/figs/ElementsDefinitions.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-olaf/Schematics/VortexLatticeMethod.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-olaf/Schematics/LagrangianMarkers.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-olaf/Schematics/VortexCodeWorkFlow.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-olaf/Schematics/FilamentRegularization.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-olaf/Schematics/FVWwithOpenFAST.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-olaf/Schematics/VortexLatticeMethod.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-olaf/Schematics/VortexCodeWorkFlow.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-olaf/Schematics/OpenFAST.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-olaf/Schematics/Stencil.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-olaf/Schematics/FVWwithOpenFAST.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-olaf/Schematics/OpenFAST.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-olaf/Schematics/LagrangianMarkers.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-olaf/Schematics/Stencil.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn-olaf/Schematics/FilamentRegularization.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/beamdyn/figs/blade_geometry.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/beamdyn/figs/frame.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/beamdyn/figs/geometry_member1.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/beamdyn/figs/bd_frame.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/beamdyn/figs/bd_output_channel.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/beamdyn/figs/n8.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/beamdyn/figs/bd_output_channel.docx",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/beamdyn/figs/flow_chart.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/beamdyn/figs/manual_plots.pptx",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/beamdyn/figs/geometry_member2.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/beamdyn/figs/n4.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn/figs/ad_blade_geom.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn/figs/ad_tower_geom.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn/figs/ad_blade_local_cs.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn/figs/ad_driver_geom.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/aerodyn/figs/ad_output_channel.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/source/user/servodyn-stc/Schematics/TLCD_Diagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/_static/openfastlogo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/_static/GitFlowFeatureBranches.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/_static/docs_options.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/OtherSupporting/OutListParameters.xlsx",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/OtherSupporting/OpenFAST_Algorithms/OpenFAST_Algorithms.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/docs/OtherSupporting/DCM_Interpolation/DCM_Interpolation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfast-develop-efmzqt4odarnt3cb7bannmk2diwyh6nn/spack-src/modules/aerodyn14/src/AD_RegistryEntries.xlsx"
    ],
    "total_files": 791
}