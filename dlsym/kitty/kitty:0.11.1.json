{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/kitty/desktop.c": "/*\n * desktop.c\n * Copyright (C) 2017 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the GPL3 license.\n */\n\n#include \"data-types.h\"\n#include <dlfcn.h>\n\n#define FUNC(name, restype, ...) typedef restype (*name##_func)(__VA_ARGS__); static name##_func name = NULL\n#define LOAD_FUNC(handle, name) {\\\n    *(void **) (&name) = dlsym(handle, #name); \\\n    const char* error = dlerror(); \\\n    if (error != NULL) { \\\n        PyErr_Format(PyExc_OSError, \"Failed to load the function %s with error: %s\", #name, error); dlclose(handle); handle = NULL; return NULL; \\\n    } \\\n}\n\nFUNC(sn_display_new, void*, void*, void*, void*);\nFUNC(sn_launchee_context_new_from_environment, void*, void*, int);\nFUNC(sn_launchee_context_new, void*, void*, int, const char*);\nFUNC(sn_display_unref, void, void*);\nFUNC(sn_launchee_context_setup_window, void, void*, int32_t);\nFUNC(sn_launchee_context_complete, void, void*);\nFUNC(sn_launchee_context_unref, void, void*);\n\nstatic void* libsn_handle = NULL;\n\nstatic PyObject*\ninit_x11_startup_notification(PyObject UNUSED *self, PyObject *args) {\n    static bool done = false;\n    static const char* libname = \"libstartup-notification-1.so\";\n    if (!done) {\n        done = true;\n\n        libsn_handle = dlopen(libname, RTLD_LAZY);\n        if (libsn_handle == NULL) {\n            PyErr_Format(PyExc_OSError, \"Failed to load %s with error: %s\", libname, dlerror());\n            return NULL;\n        }\n        dlerror();    /* Clear any existing error */\n#define F(name) LOAD_FUNC(libsn_handle, name)\n        F(sn_display_new);\n        F(sn_launchee_context_new_from_environment);\n        F(sn_launchee_context_new);\n        F(sn_display_unref);\n        F(sn_launchee_context_setup_window);\n        F(sn_launchee_context_complete);\n        F(sn_launchee_context_unref);\n#undef F\n    }\n\n    int window_id;\n    PyObject *dp;\n    char *startup_id = NULL;\n    if (!PyArg_ParseTuple(args, \"O!i|z\", &PyLong_Type, &dp, &window_id, &startup_id)) return NULL;\n    void* display = PyLong_AsVoidPtr(dp);\n    void* sn_display = sn_display_new(display, NULL, NULL);\n    if (!sn_display) { PyErr_SetString(PyExc_OSError, \"Failed to create SnDisplay\"); return NULL; }\n    void *ctx = startup_id ? sn_launchee_context_new(sn_display, 0, startup_id) : sn_launchee_context_new_from_environment(sn_display, 0);\n    sn_display_unref(sn_display);\n    if (!ctx) { PyErr_SetString(PyExc_OSError, \"Failed to create startup-notification context\"); return NULL; }\n    sn_launchee_context_setup_window(ctx, window_id);\n    return PyLong_FromVoidPtr(ctx);\n}\n\nstatic PyObject*\nend_x11_startup_notification(PyObject UNUSED *self, PyObject *args) {\n    if (!libsn_handle) Py_RETURN_NONE;\n    PyObject *dp;\n    if (!PyArg_ParseTuple(args, \"O!\", &PyLong_Type, &dp)) return NULL;\n    void *ctx = PyLong_AsVoidPtr(dp);\n    sn_launchee_context_complete(ctx);\n    sn_launchee_context_unref(ctx);\n\n    Py_RETURN_NONE;\n}\n\nstatic PyMethodDef module_methods[] = {\n    METHODB(init_x11_startup_notification, METH_VARARGS),\n    METHODB(end_x11_startup_notification, METH_VARARGS),\n\n    {NULL, NULL, 0, NULL}        /* Sentinel */\n};\n\nstatic void\nfinalize(void) {\n    if (libsn_handle) dlclose(libsn_handle);\n}\n\nbool\ninit_desktop(PyObject *m) {\n    if (PyModule_AddFunctions(m, module_methods) != 0) return false;\n    if (Py_AtExit(finalize) != 0) {\n        PyErr_SetString(PyExc_RuntimeError, \"Failed to register the desktop.c at exit handler\");\n        return false;\n    }\n    return true;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/kitty/glfw-wrapper.c": "\n#include \"data-types.h\"\n#include \"glfw-wrapper.h\"\n#include <dlfcn.h>\n\nstatic void* handle = NULL;\n\n#define fail(msg, ...) { snprintf(buf, sizeof(buf), msg, __VA_ARGS__); return buf; }\n\nconst char*\nload_glfw(const char* path) {\n    static char buf[2048];\n    handle = dlopen(path, RTLD_LAZY);\n    if (handle == NULL) fail(\"Failed to dlopen %s with error: %s\", path, dlerror());\n    dlerror();\n\n    *(void **) (&glfwInit_impl) = dlsym(handle, \"glfwInit\");\n    if (glfwInit_impl == NULL) fail(\"Failed to load glfw function glfwInit with error: %s\", dlerror());\n\n    *(void **) (&glfwTerminate_impl) = dlsym(handle, \"glfwTerminate\");\n    if (glfwTerminate_impl == NULL) fail(\"Failed to load glfw function glfwTerminate with error: %s\", dlerror());\n\n    *(void **) (&glfwInitHint_impl) = dlsym(handle, \"glfwInitHint\");\n    if (glfwInitHint_impl == NULL) fail(\"Failed to load glfw function glfwInitHint with error: %s\", dlerror());\n\n    *(void **) (&glfwGetVersion_impl) = dlsym(handle, \"glfwGetVersion\");\n    if (glfwGetVersion_impl == NULL) fail(\"Failed to load glfw function glfwGetVersion with error: %s\", dlerror());\n\n    *(void **) (&glfwGetVersionString_impl) = dlsym(handle, \"glfwGetVersionString\");\n    if (glfwGetVersionString_impl == NULL) fail(\"Failed to load glfw function glfwGetVersionString with error: %s\", dlerror());\n\n    *(void **) (&glfwGetError_impl) = dlsym(handle, \"glfwGetError\");\n    if (glfwGetError_impl == NULL) fail(\"Failed to load glfw function glfwGetError with error: %s\", dlerror());\n\n    *(void **) (&glfwSetErrorCallback_impl) = dlsym(handle, \"glfwSetErrorCallback\");\n    if (glfwSetErrorCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetErrorCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwGetMonitors_impl) = dlsym(handle, \"glfwGetMonitors\");\n    if (glfwGetMonitors_impl == NULL) fail(\"Failed to load glfw function glfwGetMonitors with error: %s\", dlerror());\n\n    *(void **) (&glfwGetPrimaryMonitor_impl) = dlsym(handle, \"glfwGetPrimaryMonitor\");\n    if (glfwGetPrimaryMonitor_impl == NULL) fail(\"Failed to load glfw function glfwGetPrimaryMonitor with error: %s\", dlerror());\n\n    *(void **) (&glfwGetMonitorPos_impl) = dlsym(handle, \"glfwGetMonitorPos\");\n    if (glfwGetMonitorPos_impl == NULL) fail(\"Failed to load glfw function glfwGetMonitorPos with error: %s\", dlerror());\n\n    *(void **) (&glfwGetMonitorPhysicalSize_impl) = dlsym(handle, \"glfwGetMonitorPhysicalSize\");\n    if (glfwGetMonitorPhysicalSize_impl == NULL) fail(\"Failed to load glfw function glfwGetMonitorPhysicalSize with error: %s\", dlerror());\n\n    *(void **) (&glfwGetMonitorContentScale_impl) = dlsym(handle, \"glfwGetMonitorContentScale\");\n    if (glfwGetMonitorContentScale_impl == NULL) fail(\"Failed to load glfw function glfwGetMonitorContentScale with error: %s\", dlerror());\n\n    *(void **) (&glfwGetMonitorName_impl) = dlsym(handle, \"glfwGetMonitorName\");\n    if (glfwGetMonitorName_impl == NULL) fail(\"Failed to load glfw function glfwGetMonitorName with error: %s\", dlerror());\n\n    *(void **) (&glfwSetMonitorUserPointer_impl) = dlsym(handle, \"glfwSetMonitorUserPointer\");\n    if (glfwSetMonitorUserPointer_impl == NULL) fail(\"Failed to load glfw function glfwSetMonitorUserPointer with error: %s\", dlerror());\n\n    *(void **) (&glfwGetMonitorUserPointer_impl) = dlsym(handle, \"glfwGetMonitorUserPointer\");\n    if (glfwGetMonitorUserPointer_impl == NULL) fail(\"Failed to load glfw function glfwGetMonitorUserPointer with error: %s\", dlerror());\n\n    *(void **) (&glfwSetMonitorCallback_impl) = dlsym(handle, \"glfwSetMonitorCallback\");\n    if (glfwSetMonitorCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetMonitorCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwGetVideoModes_impl) = dlsym(handle, \"glfwGetVideoModes\");\n    if (glfwGetVideoModes_impl == NULL) fail(\"Failed to load glfw function glfwGetVideoModes with error: %s\", dlerror());\n\n    *(void **) (&glfwGetVideoMode_impl) = dlsym(handle, \"glfwGetVideoMode\");\n    if (glfwGetVideoMode_impl == NULL) fail(\"Failed to load glfw function glfwGetVideoMode with error: %s\", dlerror());\n\n    *(void **) (&glfwSetGamma_impl) = dlsym(handle, \"glfwSetGamma\");\n    if (glfwSetGamma_impl == NULL) fail(\"Failed to load glfw function glfwSetGamma with error: %s\", dlerror());\n\n    *(void **) (&glfwGetGammaRamp_impl) = dlsym(handle, \"glfwGetGammaRamp\");\n    if (glfwGetGammaRamp_impl == NULL) fail(\"Failed to load glfw function glfwGetGammaRamp with error: %s\", dlerror());\n\n    *(void **) (&glfwSetGammaRamp_impl) = dlsym(handle, \"glfwSetGammaRamp\");\n    if (glfwSetGammaRamp_impl == NULL) fail(\"Failed to load glfw function glfwSetGammaRamp with error: %s\", dlerror());\n\n    *(void **) (&glfwDefaultWindowHints_impl) = dlsym(handle, \"glfwDefaultWindowHints\");\n    if (glfwDefaultWindowHints_impl == NULL) fail(\"Failed to load glfw function glfwDefaultWindowHints with error: %s\", dlerror());\n\n    *(void **) (&glfwWindowHint_impl) = dlsym(handle, \"glfwWindowHint\");\n    if (glfwWindowHint_impl == NULL) fail(\"Failed to load glfw function glfwWindowHint with error: %s\", dlerror());\n\n    *(void **) (&glfwWindowHintString_impl) = dlsym(handle, \"glfwWindowHintString\");\n    if (glfwWindowHintString_impl == NULL) fail(\"Failed to load glfw function glfwWindowHintString with error: %s\", dlerror());\n\n    *(void **) (&glfwCreateWindow_impl) = dlsym(handle, \"glfwCreateWindow\");\n    if (glfwCreateWindow_impl == NULL) fail(\"Failed to load glfw function glfwCreateWindow with error: %s\", dlerror());\n\n    *(void **) (&glfwDestroyWindow_impl) = dlsym(handle, \"glfwDestroyWindow\");\n    if (glfwDestroyWindow_impl == NULL) fail(\"Failed to load glfw function glfwDestroyWindow with error: %s\", dlerror());\n\n    *(void **) (&glfwWindowShouldClose_impl) = dlsym(handle, \"glfwWindowShouldClose\");\n    if (glfwWindowShouldClose_impl == NULL) fail(\"Failed to load glfw function glfwWindowShouldClose with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowShouldClose_impl) = dlsym(handle, \"glfwSetWindowShouldClose\");\n    if (glfwSetWindowShouldClose_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowShouldClose with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowTitle_impl) = dlsym(handle, \"glfwSetWindowTitle\");\n    if (glfwSetWindowTitle_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowTitle with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowIcon_impl) = dlsym(handle, \"glfwSetWindowIcon\");\n    if (glfwSetWindowIcon_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowIcon with error: %s\", dlerror());\n\n    *(void **) (&glfwGetWindowPos_impl) = dlsym(handle, \"glfwGetWindowPos\");\n    if (glfwGetWindowPos_impl == NULL) fail(\"Failed to load glfw function glfwGetWindowPos with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowPos_impl) = dlsym(handle, \"glfwSetWindowPos\");\n    if (glfwSetWindowPos_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowPos with error: %s\", dlerror());\n\n    *(void **) (&glfwGetWindowSize_impl) = dlsym(handle, \"glfwGetWindowSize\");\n    if (glfwGetWindowSize_impl == NULL) fail(\"Failed to load glfw function glfwGetWindowSize with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowSizeLimits_impl) = dlsym(handle, \"glfwSetWindowSizeLimits\");\n    if (glfwSetWindowSizeLimits_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowSizeLimits with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowAspectRatio_impl) = dlsym(handle, \"glfwSetWindowAspectRatio\");\n    if (glfwSetWindowAspectRatio_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowAspectRatio with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowSize_impl) = dlsym(handle, \"glfwSetWindowSize\");\n    if (glfwSetWindowSize_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowSize with error: %s\", dlerror());\n\n    *(void **) (&glfwGetFramebufferSize_impl) = dlsym(handle, \"glfwGetFramebufferSize\");\n    if (glfwGetFramebufferSize_impl == NULL) fail(\"Failed to load glfw function glfwGetFramebufferSize with error: %s\", dlerror());\n\n    *(void **) (&glfwGetWindowFrameSize_impl) = dlsym(handle, \"glfwGetWindowFrameSize\");\n    if (glfwGetWindowFrameSize_impl == NULL) fail(\"Failed to load glfw function glfwGetWindowFrameSize with error: %s\", dlerror());\n\n    *(void **) (&glfwGetWindowContentScale_impl) = dlsym(handle, \"glfwGetWindowContentScale\");\n    if (glfwGetWindowContentScale_impl == NULL) fail(\"Failed to load glfw function glfwGetWindowContentScale with error: %s\", dlerror());\n\n    *(void **) (&glfwGetWindowOpacity_impl) = dlsym(handle, \"glfwGetWindowOpacity\");\n    if (glfwGetWindowOpacity_impl == NULL) fail(\"Failed to load glfw function glfwGetWindowOpacity with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowOpacity_impl) = dlsym(handle, \"glfwSetWindowOpacity\");\n    if (glfwSetWindowOpacity_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowOpacity with error: %s\", dlerror());\n\n    *(void **) (&glfwIconifyWindow_impl) = dlsym(handle, \"glfwIconifyWindow\");\n    if (glfwIconifyWindow_impl == NULL) fail(\"Failed to load glfw function glfwIconifyWindow with error: %s\", dlerror());\n\n    *(void **) (&glfwRestoreWindow_impl) = dlsym(handle, \"glfwRestoreWindow\");\n    if (glfwRestoreWindow_impl == NULL) fail(\"Failed to load glfw function glfwRestoreWindow with error: %s\", dlerror());\n\n    *(void **) (&glfwMaximizeWindow_impl) = dlsym(handle, \"glfwMaximizeWindow\");\n    if (glfwMaximizeWindow_impl == NULL) fail(\"Failed to load glfw function glfwMaximizeWindow with error: %s\", dlerror());\n\n    *(void **) (&glfwShowWindow_impl) = dlsym(handle, \"glfwShowWindow\");\n    if (glfwShowWindow_impl == NULL) fail(\"Failed to load glfw function glfwShowWindow with error: %s\", dlerror());\n\n    *(void **) (&glfwHideWindow_impl) = dlsym(handle, \"glfwHideWindow\");\n    if (glfwHideWindow_impl == NULL) fail(\"Failed to load glfw function glfwHideWindow with error: %s\", dlerror());\n\n    *(void **) (&glfwFocusWindow_impl) = dlsym(handle, \"glfwFocusWindow\");\n    if (glfwFocusWindow_impl == NULL) fail(\"Failed to load glfw function glfwFocusWindow with error: %s\", dlerror());\n\n    *(void **) (&glfwRequestWindowAttention_impl) = dlsym(handle, \"glfwRequestWindowAttention\");\n    if (glfwRequestWindowAttention_impl == NULL) fail(\"Failed to load glfw function glfwRequestWindowAttention with error: %s\", dlerror());\n\n    *(void **) (&glfwWindowBell_impl) = dlsym(handle, \"glfwWindowBell\");\n    if (glfwWindowBell_impl == NULL) fail(\"Failed to load glfw function glfwWindowBell with error: %s\", dlerror());\n\n    *(void **) (&glfwGetWindowMonitor_impl) = dlsym(handle, \"glfwGetWindowMonitor\");\n    if (glfwGetWindowMonitor_impl == NULL) fail(\"Failed to load glfw function glfwGetWindowMonitor with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowMonitor_impl) = dlsym(handle, \"glfwSetWindowMonitor\");\n    if (glfwSetWindowMonitor_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowMonitor with error: %s\", dlerror());\n\n    *(void **) (&glfwGetWindowAttrib_impl) = dlsym(handle, \"glfwGetWindowAttrib\");\n    if (glfwGetWindowAttrib_impl == NULL) fail(\"Failed to load glfw function glfwGetWindowAttrib with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowAttrib_impl) = dlsym(handle, \"glfwSetWindowAttrib\");\n    if (glfwSetWindowAttrib_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowAttrib with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowUserPointer_impl) = dlsym(handle, \"glfwSetWindowUserPointer\");\n    if (glfwSetWindowUserPointer_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowUserPointer with error: %s\", dlerror());\n\n    *(void **) (&glfwGetWindowUserPointer_impl) = dlsym(handle, \"glfwGetWindowUserPointer\");\n    if (glfwGetWindowUserPointer_impl == NULL) fail(\"Failed to load glfw function glfwGetWindowUserPointer with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowPosCallback_impl) = dlsym(handle, \"glfwSetWindowPosCallback\");\n    if (glfwSetWindowPosCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowPosCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowSizeCallback_impl) = dlsym(handle, \"glfwSetWindowSizeCallback\");\n    if (glfwSetWindowSizeCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowSizeCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowCloseCallback_impl) = dlsym(handle, \"glfwSetWindowCloseCallback\");\n    if (glfwSetWindowCloseCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowCloseCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowRefreshCallback_impl) = dlsym(handle, \"glfwSetWindowRefreshCallback\");\n    if (glfwSetWindowRefreshCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowRefreshCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowFocusCallback_impl) = dlsym(handle, \"glfwSetWindowFocusCallback\");\n    if (glfwSetWindowFocusCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowFocusCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowIconifyCallback_impl) = dlsym(handle, \"glfwSetWindowIconifyCallback\");\n    if (glfwSetWindowIconifyCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowIconifyCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowMaximizeCallback_impl) = dlsym(handle, \"glfwSetWindowMaximizeCallback\");\n    if (glfwSetWindowMaximizeCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowMaximizeCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwSetFramebufferSizeCallback_impl) = dlsym(handle, \"glfwSetFramebufferSizeCallback\");\n    if (glfwSetFramebufferSizeCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetFramebufferSizeCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwSetWindowContentScaleCallback_impl) = dlsym(handle, \"glfwSetWindowContentScaleCallback\");\n    if (glfwSetWindowContentScaleCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetWindowContentScaleCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwPollEvents_impl) = dlsym(handle, \"glfwPollEvents\");\n    if (glfwPollEvents_impl == NULL) fail(\"Failed to load glfw function glfwPollEvents with error: %s\", dlerror());\n\n    *(void **) (&glfwWaitEvents_impl) = dlsym(handle, \"glfwWaitEvents\");\n    if (glfwWaitEvents_impl == NULL) fail(\"Failed to load glfw function glfwWaitEvents with error: %s\", dlerror());\n\n    *(void **) (&glfwWaitEventsTimeout_impl) = dlsym(handle, \"glfwWaitEventsTimeout\");\n    if (glfwWaitEventsTimeout_impl == NULL) fail(\"Failed to load glfw function glfwWaitEventsTimeout with error: %s\", dlerror());\n\n    *(void **) (&glfwPostEmptyEvent_impl) = dlsym(handle, \"glfwPostEmptyEvent\");\n    if (glfwPostEmptyEvent_impl == NULL) fail(\"Failed to load glfw function glfwPostEmptyEvent with error: %s\", dlerror());\n\n    *(void **) (&glfwGetInputMode_impl) = dlsym(handle, \"glfwGetInputMode\");\n    if (glfwGetInputMode_impl == NULL) fail(\"Failed to load glfw function glfwGetInputMode with error: %s\", dlerror());\n\n    *(void **) (&glfwSetInputMode_impl) = dlsym(handle, \"glfwSetInputMode\");\n    if (glfwSetInputMode_impl == NULL) fail(\"Failed to load glfw function glfwSetInputMode with error: %s\", dlerror());\n\n    *(void **) (&glfwGetKeyName_impl) = dlsym(handle, \"glfwGetKeyName\");\n    if (glfwGetKeyName_impl == NULL) fail(\"Failed to load glfw function glfwGetKeyName with error: %s\", dlerror());\n\n    *(void **) (&glfwGetKeyScancode_impl) = dlsym(handle, \"glfwGetKeyScancode\");\n    if (glfwGetKeyScancode_impl == NULL) fail(\"Failed to load glfw function glfwGetKeyScancode with error: %s\", dlerror());\n\n    *(void **) (&glfwGetKey_impl) = dlsym(handle, \"glfwGetKey\");\n    if (glfwGetKey_impl == NULL) fail(\"Failed to load glfw function glfwGetKey with error: %s\", dlerror());\n\n    *(void **) (&glfwGetMouseButton_impl) = dlsym(handle, \"glfwGetMouseButton\");\n    if (glfwGetMouseButton_impl == NULL) fail(\"Failed to load glfw function glfwGetMouseButton with error: %s\", dlerror());\n\n    *(void **) (&glfwGetCursorPos_impl) = dlsym(handle, \"glfwGetCursorPos\");\n    if (glfwGetCursorPos_impl == NULL) fail(\"Failed to load glfw function glfwGetCursorPos with error: %s\", dlerror());\n\n    *(void **) (&glfwSetCursorPos_impl) = dlsym(handle, \"glfwSetCursorPos\");\n    if (glfwSetCursorPos_impl == NULL) fail(\"Failed to load glfw function glfwSetCursorPos with error: %s\", dlerror());\n\n    *(void **) (&glfwCreateCursor_impl) = dlsym(handle, \"glfwCreateCursor\");\n    if (glfwCreateCursor_impl == NULL) fail(\"Failed to load glfw function glfwCreateCursor with error: %s\", dlerror());\n\n    *(void **) (&glfwCreateStandardCursor_impl) = dlsym(handle, \"glfwCreateStandardCursor\");\n    if (glfwCreateStandardCursor_impl == NULL) fail(\"Failed to load glfw function glfwCreateStandardCursor with error: %s\", dlerror());\n\n    *(void **) (&glfwDestroyCursor_impl) = dlsym(handle, \"glfwDestroyCursor\");\n    if (glfwDestroyCursor_impl == NULL) fail(\"Failed to load glfw function glfwDestroyCursor with error: %s\", dlerror());\n\n    *(void **) (&glfwSetCursor_impl) = dlsym(handle, \"glfwSetCursor\");\n    if (glfwSetCursor_impl == NULL) fail(\"Failed to load glfw function glfwSetCursor with error: %s\", dlerror());\n\n    *(void **) (&glfwSetKeyboardCallback_impl) = dlsym(handle, \"glfwSetKeyboardCallback\");\n    if (glfwSetKeyboardCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetKeyboardCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwSetMouseButtonCallback_impl) = dlsym(handle, \"glfwSetMouseButtonCallback\");\n    if (glfwSetMouseButtonCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetMouseButtonCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwSetCursorPosCallback_impl) = dlsym(handle, \"glfwSetCursorPosCallback\");\n    if (glfwSetCursorPosCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetCursorPosCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwSetCursorEnterCallback_impl) = dlsym(handle, \"glfwSetCursorEnterCallback\");\n    if (glfwSetCursorEnterCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetCursorEnterCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwSetScrollCallback_impl) = dlsym(handle, \"glfwSetScrollCallback\");\n    if (glfwSetScrollCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetScrollCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwSetDropCallback_impl) = dlsym(handle, \"glfwSetDropCallback\");\n    if (glfwSetDropCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetDropCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwJoystickPresent_impl) = dlsym(handle, \"glfwJoystickPresent\");\n    if (glfwJoystickPresent_impl == NULL) fail(\"Failed to load glfw function glfwJoystickPresent with error: %s\", dlerror());\n\n    *(void **) (&glfwGetJoystickAxes_impl) = dlsym(handle, \"glfwGetJoystickAxes\");\n    if (glfwGetJoystickAxes_impl == NULL) fail(\"Failed to load glfw function glfwGetJoystickAxes with error: %s\", dlerror());\n\n    *(void **) (&glfwGetJoystickButtons_impl) = dlsym(handle, \"glfwGetJoystickButtons\");\n    if (glfwGetJoystickButtons_impl == NULL) fail(\"Failed to load glfw function glfwGetJoystickButtons with error: %s\", dlerror());\n\n    *(void **) (&glfwGetJoystickHats_impl) = dlsym(handle, \"glfwGetJoystickHats\");\n    if (glfwGetJoystickHats_impl == NULL) fail(\"Failed to load glfw function glfwGetJoystickHats with error: %s\", dlerror());\n\n    *(void **) (&glfwGetJoystickName_impl) = dlsym(handle, \"glfwGetJoystickName\");\n    if (glfwGetJoystickName_impl == NULL) fail(\"Failed to load glfw function glfwGetJoystickName with error: %s\", dlerror());\n\n    *(void **) (&glfwGetJoystickGUID_impl) = dlsym(handle, \"glfwGetJoystickGUID\");\n    if (glfwGetJoystickGUID_impl == NULL) fail(\"Failed to load glfw function glfwGetJoystickGUID with error: %s\", dlerror());\n\n    *(void **) (&glfwSetJoystickUserPointer_impl) = dlsym(handle, \"glfwSetJoystickUserPointer\");\n    if (glfwSetJoystickUserPointer_impl == NULL) fail(\"Failed to load glfw function glfwSetJoystickUserPointer with error: %s\", dlerror());\n\n    *(void **) (&glfwGetJoystickUserPointer_impl) = dlsym(handle, \"glfwGetJoystickUserPointer\");\n    if (glfwGetJoystickUserPointer_impl == NULL) fail(\"Failed to load glfw function glfwGetJoystickUserPointer with error: %s\", dlerror());\n\n    *(void **) (&glfwJoystickIsGamepad_impl) = dlsym(handle, \"glfwJoystickIsGamepad\");\n    if (glfwJoystickIsGamepad_impl == NULL) fail(\"Failed to load glfw function glfwJoystickIsGamepad with error: %s\", dlerror());\n\n    *(void **) (&glfwSetJoystickCallback_impl) = dlsym(handle, \"glfwSetJoystickCallback\");\n    if (glfwSetJoystickCallback_impl == NULL) fail(\"Failed to load glfw function glfwSetJoystickCallback with error: %s\", dlerror());\n\n    *(void **) (&glfwUpdateGamepadMappings_impl) = dlsym(handle, \"glfwUpdateGamepadMappings\");\n    if (glfwUpdateGamepadMappings_impl == NULL) fail(\"Failed to load glfw function glfwUpdateGamepadMappings with error: %s\", dlerror());\n\n    *(void **) (&glfwGetGamepadName_impl) = dlsym(handle, \"glfwGetGamepadName\");\n    if (glfwGetGamepadName_impl == NULL) fail(\"Failed to load glfw function glfwGetGamepadName with error: %s\", dlerror());\n\n    *(void **) (&glfwGetGamepadState_impl) = dlsym(handle, \"glfwGetGamepadState\");\n    if (glfwGetGamepadState_impl == NULL) fail(\"Failed to load glfw function glfwGetGamepadState with error: %s\", dlerror());\n\n    *(void **) (&glfwSetClipboardString_impl) = dlsym(handle, \"glfwSetClipboardString\");\n    if (glfwSetClipboardString_impl == NULL) fail(\"Failed to load glfw function glfwSetClipboardString with error: %s\", dlerror());\n\n    *(void **) (&glfwGetClipboardString_impl) = dlsym(handle, \"glfwGetClipboardString\");\n    if (glfwGetClipboardString_impl == NULL) fail(\"Failed to load glfw function glfwGetClipboardString with error: %s\", dlerror());\n\n    *(void **) (&glfwGetTime_impl) = dlsym(handle, \"glfwGetTime\");\n    if (glfwGetTime_impl == NULL) fail(\"Failed to load glfw function glfwGetTime with error: %s\", dlerror());\n\n    *(void **) (&glfwSetTime_impl) = dlsym(handle, \"glfwSetTime\");\n    if (glfwSetTime_impl == NULL) fail(\"Failed to load glfw function glfwSetTime with error: %s\", dlerror());\n\n    *(void **) (&glfwGetTimerValue_impl) = dlsym(handle, \"glfwGetTimerValue\");\n    if (glfwGetTimerValue_impl == NULL) fail(\"Failed to load glfw function glfwGetTimerValue with error: %s\", dlerror());\n\n    *(void **) (&glfwGetTimerFrequency_impl) = dlsym(handle, \"glfwGetTimerFrequency\");\n    if (glfwGetTimerFrequency_impl == NULL) fail(\"Failed to load glfw function glfwGetTimerFrequency with error: %s\", dlerror());\n\n    *(void **) (&glfwMakeContextCurrent_impl) = dlsym(handle, \"glfwMakeContextCurrent\");\n    if (glfwMakeContextCurrent_impl == NULL) fail(\"Failed to load glfw function glfwMakeContextCurrent with error: %s\", dlerror());\n\n    *(void **) (&glfwGetCurrentContext_impl) = dlsym(handle, \"glfwGetCurrentContext\");\n    if (glfwGetCurrentContext_impl == NULL) fail(\"Failed to load glfw function glfwGetCurrentContext with error: %s\", dlerror());\n\n    *(void **) (&glfwSwapBuffers_impl) = dlsym(handle, \"glfwSwapBuffers\");\n    if (glfwSwapBuffers_impl == NULL) fail(\"Failed to load glfw function glfwSwapBuffers with error: %s\", dlerror());\n\n    *(void **) (&glfwSwapInterval_impl) = dlsym(handle, \"glfwSwapInterval\");\n    if (glfwSwapInterval_impl == NULL) fail(\"Failed to load glfw function glfwSwapInterval with error: %s\", dlerror());\n\n    *(void **) (&glfwExtensionSupported_impl) = dlsym(handle, \"glfwExtensionSupported\");\n    if (glfwExtensionSupported_impl == NULL) fail(\"Failed to load glfw function glfwExtensionSupported with error: %s\", dlerror());\n\n    *(void **) (&glfwGetProcAddress_impl) = dlsym(handle, \"glfwGetProcAddress\");\n    if (glfwGetProcAddress_impl == NULL) fail(\"Failed to load glfw function glfwGetProcAddress with error: %s\", dlerror());\n\n    *(void **) (&glfwVulkanSupported_impl) = dlsym(handle, \"glfwVulkanSupported\");\n    if (glfwVulkanSupported_impl == NULL) fail(\"Failed to load glfw function glfwVulkanSupported with error: %s\", dlerror());\n\n    *(void **) (&glfwGetRequiredInstanceExtensions_impl) = dlsym(handle, \"glfwGetRequiredInstanceExtensions\");\n    if (glfwGetRequiredInstanceExtensions_impl == NULL) fail(\"Failed to load glfw function glfwGetRequiredInstanceExtensions with error: %s\", dlerror());\n\n    *(void **) (&glfwGetCocoaWindow_impl) = dlsym(handle, \"glfwGetCocoaWindow\");\n\n    *(void **) (&glfwGetCocoaMonitor_impl) = dlsym(handle, \"glfwGetCocoaMonitor\");\n\n    *(void **) (&glfwSetCocoaTextInputFilter_impl) = dlsym(handle, \"glfwSetCocoaTextInputFilter\");\n\n    *(void **) (&glfwSetApplicationShouldHandleReopen_impl) = dlsym(handle, \"glfwSetApplicationShouldHandleReopen\");\n\n    *(void **) (&glfwGetCocoaKeyEquivalent_impl) = dlsym(handle, \"glfwGetCocoaKeyEquivalent\");\n\n    *(void **) (&glfwGetX11Display_impl) = dlsym(handle, \"glfwGetX11Display\");\n\n    *(void **) (&glfwGetX11Window_impl) = dlsym(handle, \"glfwGetX11Window\");\n\n    *(void **) (&glfwSetX11SelectionString_impl) = dlsym(handle, \"glfwSetX11SelectionString\");\n\n    *(void **) (&glfwGetX11SelectionString_impl) = dlsym(handle, \"glfwGetX11SelectionString\");\n\n    return NULL;\n}\n\nvoid\nunload_glfw() {\n    if (handle) { dlclose(handle); handle = NULL; }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/kitty/gl-wrapper.c": "#pragma GCC diagnostic ignored \"-Wpedantic\"\n/*\n    OpenGL loader generated by glad 0.1.20a0 on Fri May  4 18:11:55 2018.\n    Language/Generator: C/C++ Debug\n    Specification: gl\n    APIs: gl=3.3\n    Profile: core\n    Extensions:\n        GL_ARB_copy_image,\n        GL_ARB_multisample,\n        GL_ARB_robustness,\n        GL_ARB_texture_storage,\n        GL_KHR_debug\n    Loader: True\n    Local files: False\n    Omit khrplatform: False\n    Commandline:\n        --profile=\"core\" --api=\"gl=3.3\" --generator=\"c-debug\" --spec=\"gl\" --extensions=\"GL_ARB_copy_image,GL_ARB_multisample,GL_ARB_robustness,GL_ARB_texture_storage,GL_KHR_debug\"\n    Online:\n        http://glad.dav1d.de/#profile=core&language=c-debug&specification=gl&loader=on&api=gl%3D3.3&extensions=GL_ARB_copy_image&extensions=GL_ARB_multisample&extensions=GL_ARB_robustness&extensions=GL_ARB_texture_storage&extensions=GL_KHR_debug\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"gl-wrapper.h\"\nvoid _pre_call_callback_default(const char *name, void *funcptr, int len_args, ...) {\n    (void) name;\n    (void) funcptr;\n    (void) len_args;\n}\nvoid _post_call_callback_default(const char *name, void *funcptr, int len_args, ...) {\n    GLenum error_code;\n    (void) funcptr;\n    (void) len_args;\n    error_code = glad_glGetError();\n    if (error_code != GL_NO_ERROR) {\n        fprintf(stderr, \"ERROR %d in %s\\n\", error_code, name);\n    }\n}\nstatic GLADcallback _pre_call_callback = _pre_call_callback_default;\nvoid glad_set_pre_callback(GLADcallback cb) {\n    _pre_call_callback = cb;\n}\nstatic GLADcallback _post_call_callback = _post_call_callback_default;\nvoid glad_set_post_callback(GLADcallback cb) {\n    _post_call_callback = cb;\n}\nstatic void* get_proc(const char *namez);\n#if defined(_WIN32) || defined(__CYGWIN__)\n#include <windows.h>\nstatic HMODULE libGL;\ntypedef void* (APIENTRYP PFNWGLGETPROCADDRESSPROC_PRIVATE)(const char*);\nstatic PFNWGLGETPROCADDRESSPROC_PRIVATE gladGetProcAddressPtr;\n#ifdef _MSC_VER\n#ifdef __has_include\n  #if __has_include(<winapifamily.h>)\n    #define HAVE_WINAPIFAMILY 1\n  #endif\n#elif _MSC_VER >= 1700 && !_USING_V110_SDK71_\n  #define HAVE_WINAPIFAMILY 1\n#endif\n#endif\n#ifdef HAVE_WINAPIFAMILY\n  #include <winapifamily.h>\n  #if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)\n    #define IS_UWP 1\n  #endif\n#endif\nstatic\nint open_gl(void) {\n#ifndef IS_UWP\n    libGL = LoadLibraryW(L\"opengl32.dll\");\n    if(libGL != NULL) {\n        gladGetProcAddressPtr = (PFNWGLGETPROCADDRESSPROC_PRIVATE)GetProcAddress(\n                libGL, \"wglGetProcAddress\");\n        return gladGetProcAddressPtr != NULL;\n    }\n#endif\n    return 0;\n}\nstatic\nvoid close_gl(void) {\n    if(libGL != NULL) {\n        FreeLibrary((HMODULE) libGL);\n        libGL = NULL;\n    }\n}\n#else\n#include <dlfcn.h>\nstatic void* libGL;\n#ifndef __APPLE__\ntypedef void* (APIENTRYP PFNGLXGETPROCADDRESSPROC_PRIVATE)(const char*);\nstatic PFNGLXGETPROCADDRESSPROC_PRIVATE gladGetProcAddressPtr;\n#endif\nstatic\nint open_gl(void) {\n#ifdef __APPLE__\n    static const char *NAMES[] = {\n        \"../Frameworks/OpenGL.framework/OpenGL\",\n        \"/Library/Frameworks/OpenGL.framework/OpenGL\",\n        \"/System/Library/Frameworks/OpenGL.framework/OpenGL\",\n        \"/System/Library/Frameworks/OpenGL.framework/Versions/Current/OpenGL\"\n    };\n#else\n    static const char *NAMES[] = {\"libGL.so.1\", \"libGL.so\"};\n#endif\n    unsigned int index = 0;\n    for(index = 0; index < (sizeof(NAMES) / sizeof(NAMES[0])); index++) {\n        libGL = dlopen(NAMES[index], RTLD_NOW | RTLD_GLOBAL);\n        if(libGL != NULL) {\n#ifdef __APPLE__\n            return 1;\n#else\n            gladGetProcAddressPtr = (PFNGLXGETPROCADDRESSPROC_PRIVATE)dlsym(libGL,\n                \"glXGetProcAddressARB\");\n            return gladGetProcAddressPtr != NULL;\n#endif\n        }\n    }\n    return 0;\n}\nstatic\nvoid close_gl(void) {\n    if(libGL != NULL) {\n        dlclose(libGL);\n        libGL = NULL;\n    }\n}\n#endif\nstatic\nvoid* get_proc(const char *namez) {\n    void* result = NULL;\n    if(libGL == NULL) return NULL;\n#ifndef __APPLE__\n    if(gladGetProcAddressPtr != NULL) {\n        result = gladGetProcAddressPtr(namez);\n    }\n#endif\n    if(result == NULL) {\n#if defined(_WIN32) || defined(__CYGWIN__)\n        result = (void*)GetProcAddress((HMODULE) libGL, namez);\n#else\n        result = dlsym(libGL, namez);\n#endif\n    }\n    return result;\n}\nint gladLoadGL(void) {\n    int status = 0;\n    if(open_gl()) {\n        status = gladLoadGLLoader(&get_proc);\n        close_gl();\n    }\n    return status;\n}\nstruct gladGLversionStruct GLVersion;\n#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)\n#define _GLAD_IS_SOME_NEW_VERSION 1\n#endif\nstatic int max_loaded_major;\nstatic int max_loaded_minor;\nstatic const char *exts = NULL;\nstatic int num_exts_i = 0;\nstatic const char **exts_i = NULL;\nstatic int get_exts(void) {\n#ifdef _GLAD_IS_SOME_NEW_VERSION\n    if(max_loaded_major < 3) {\n#endif\n        exts = (const char *)glGetString(GL_EXTENSIONS);\n#ifdef _GLAD_IS_SOME_NEW_VERSION\n    } else {\n        unsigned int index;\n        num_exts_i = 0;\n        glGetIntegerv(GL_NUM_EXTENSIONS, &num_exts_i);\n        if (num_exts_i > 0) {\n            exts_i = (const char **)realloc((void *)exts_i, (size_t)num_exts_i * (sizeof *exts_i));\n        }\n        if (exts_i == NULL) {\n            return 0;\n        }\n        for(index = 0; index < (unsigned)num_exts_i; index++) {\n            const char *gl_str_tmp = (const char*)glGetStringi(GL_EXTENSIONS, index);\n            size_t len = strlen(gl_str_tmp);\n            char *local_str = (char*)malloc((len+1) * sizeof(char));\n            if(local_str != NULL) {\n#if _MSC_VER >= 1400\n                strncpy_s(local_str, len+1, gl_str_tmp, len);\n#else\n                strncpy(local_str, gl_str_tmp, len+1);\n#endif\n            }\n            exts_i[index] = local_str;\n        }\n    }\n#endif\n    return 1;\n}\nstatic void free_exts(void) {\n    if (exts_i != NULL) {\n        int index;\n        for(index = 0; index < num_exts_i; index++) {\n            free((char *)exts_i[index]);\n        }\n        free((void *)exts_i);\n        exts_i = NULL;\n    }\n}\nstatic int has_ext(const char *ext) {\n#ifdef _GLAD_IS_SOME_NEW_VERSION\n    if(max_loaded_major < 3) {\n#endif\n        const char *extensions;\n        const char *loc;\n        const char *terminator;\n        extensions = exts;\n        if(extensions == NULL || ext == NULL) {\n            return 0;\n        }\n        while(1) {\n            loc = strstr(extensions, ext);\n            if(loc == NULL) {\n                return 0;\n            }\n            terminator = loc + strlen(ext);\n            if((loc == extensions || *(loc - 1) == ' ') &&\n                (*terminator == ' ' || *terminator == '\\0')) {\n                return 1;\n            }\n            extensions = terminator;\n        }\n#ifdef _GLAD_IS_SOME_NEW_VERSION\n    } else {\n        int index;\n        if(exts_i == NULL) return 0;\n        for(index = 0; index < num_exts_i; index++) {\n            const char *e = exts_i[index];\n            if(exts_i[index] != NULL && strcmp(e, ext) == 0) {\n                return 1;\n            }\n        }\n    }\n#endif\n    return 0;\n}\nint GLAD_GL_VERSION_1_0;\nint GLAD_GL_VERSION_1_1;\nint GLAD_GL_VERSION_1_2;\nint GLAD_GL_VERSION_1_3;\nint GLAD_GL_VERSION_1_4;\nint GLAD_GL_VERSION_1_5;\nint GLAD_GL_VERSION_2_0;\nint GLAD_GL_VERSION_2_1;\nint GLAD_GL_VERSION_3_0;\nint GLAD_GL_VERSION_3_1;\nint GLAD_GL_VERSION_3_2;\nint GLAD_GL_VERSION_3_3;\nPFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i;\nvoid APIENTRY glad_debug_impl_glVertexAttribI4i(GLuint arg0, GLint arg1, GLint arg2, GLint arg3, GLint arg4) {\n    _pre_call_callback(\"glVertexAttribI4i\", (void*)glVertexAttribI4i, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glVertexAttribI4i(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glVertexAttribI4i\", (void*)glVertexAttribI4i, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLVERTEXATTRIBI4IPROC glad_debug_glVertexAttribI4i = glad_debug_impl_glVertexAttribI4i;\nPFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv;\nvoid APIENTRY glad_debug_impl_glVertexAttribI4ubv(GLuint arg0, const GLubyte * arg1) {\n    _pre_call_callback(\"glVertexAttribI4ubv\", (void*)glVertexAttribI4ubv, 2, arg0, arg1);\n     glad_glVertexAttribI4ubv(arg0, arg1);\n    _post_call_callback(\"glVertexAttribI4ubv\", (void*)glVertexAttribI4ubv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIBI4UBVPROC glad_debug_glVertexAttribI4ubv = glad_debug_impl_glVertexAttribI4ubv;\nPFNGLTEXCOORDP3UIVPROC glad_glTexCoordP3uiv;\nvoid APIENTRY glad_debug_impl_glTexCoordP3uiv(GLenum arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glTexCoordP3uiv\", (void*)glTexCoordP3uiv, 2, arg0, arg1);\n     glad_glTexCoordP3uiv(arg0, arg1);\n    _post_call_callback(\"glTexCoordP3uiv\", (void*)glTexCoordP3uiv, 2, arg0, arg1);\n}\nPFNGLTEXCOORDP3UIVPROC glad_debug_glTexCoordP3uiv = glad_debug_impl_glTexCoordP3uiv;\nPFNGLTEXPARAMETERIVPROC glad_glTexParameteriv;\nvoid APIENTRY glad_debug_impl_glTexParameteriv(GLenum arg0, GLenum arg1, const GLint * arg2) {\n    _pre_call_callback(\"glTexParameteriv\", (void*)glTexParameteriv, 3, arg0, arg1, arg2);\n     glad_glTexParameteriv(arg0, arg1, arg2);\n    _post_call_callback(\"glTexParameteriv\", (void*)glTexParameteriv, 3, arg0, arg1, arg2);\n}\nPFNGLTEXPARAMETERIVPROC glad_debug_glTexParameteriv = glad_debug_impl_glTexParameteriv;\nPFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv;\nvoid APIENTRY glad_debug_impl_glSamplerParameteriv(GLuint arg0, GLenum arg1, const GLint * arg2) {\n    _pre_call_callback(\"glSamplerParameteriv\", (void*)glSamplerParameteriv, 3, arg0, arg1, arg2);\n     glad_glSamplerParameteriv(arg0, arg1, arg2);\n    _post_call_callback(\"glSamplerParameteriv\", (void*)glSamplerParameteriv, 3, arg0, arg1, arg2);\n}\nPFNGLSAMPLERPARAMETERIVPROC glad_debug_glSamplerParameteriv = glad_debug_impl_glSamplerParameteriv;\nPFNGLFRONTFACEPROC glad_glFrontFace;\nvoid APIENTRY glad_debug_impl_glFrontFace(GLenum arg0) {\n    _pre_call_callback(\"glFrontFace\", (void*)glFrontFace, 1, arg0);\n     glad_glFrontFace(arg0);\n    _post_call_callback(\"glFrontFace\", (void*)glFrontFace, 1, arg0);\n}\nPFNGLFRONTFACEPROC glad_debug_glFrontFace = glad_debug_impl_glFrontFace;\nPFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange;\nvoid APIENTRY glad_debug_impl_glBindBufferRange(GLenum arg0, GLuint arg1, GLuint arg2, GLintptr arg3, GLsizeiptr arg4) {\n    _pre_call_callback(\"glBindBufferRange\", (void*)glBindBufferRange, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glBindBufferRange(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glBindBufferRange\", (void*)glBindBufferRange, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLBINDBUFFERRANGEPROC glad_debug_glBindBufferRange = glad_debug_impl_glBindBufferRange;\nPFNGLCLAMPCOLORPROC glad_glClampColor;\nvoid APIENTRY glad_debug_impl_glClampColor(GLenum arg0, GLenum arg1) {\n    _pre_call_callback(\"glClampColor\", (void*)glClampColor, 2, arg0, arg1);\n     glad_glClampColor(arg0, arg1);\n    _post_call_callback(\"glClampColor\", (void*)glClampColor, 2, arg0, arg1);\n}\nPFNGLCLAMPCOLORPROC glad_debug_glClampColor = glad_debug_impl_glClampColor;\nPFNGLVERTEXP4UIPROC glad_glVertexP4ui;\nvoid APIENTRY glad_debug_impl_glVertexP4ui(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glVertexP4ui\", (void*)glVertexP4ui, 2, arg0, arg1);\n     glad_glVertexP4ui(arg0, arg1);\n    _post_call_callback(\"glVertexP4ui\", (void*)glVertexP4ui, 2, arg0, arg1);\n}\nPFNGLVERTEXP4UIPROC glad_debug_glVertexP4ui = glad_debug_impl_glVertexP4ui;\nPFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4Nub(GLuint arg0, GLubyte arg1, GLubyte arg2, GLubyte arg3, GLubyte arg4) {\n    _pre_call_callback(\"glVertexAttrib4Nub\", (void*)glVertexAttrib4Nub, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glVertexAttrib4Nub(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glVertexAttrib4Nub\", (void*)glVertexAttrib4Nub, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLVERTEXATTRIB4NUBPROC glad_debug_glVertexAttrib4Nub = glad_debug_impl_glVertexAttrib4Nub;\nPFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4sv(GLuint arg0, const GLshort * arg1) {\n    _pre_call_callback(\"glVertexAttrib4sv\", (void*)glVertexAttrib4sv, 2, arg0, arg1);\n     glad_glVertexAttrib4sv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib4sv\", (void*)glVertexAttrib4sv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB4SVPROC glad_debug_glVertexAttrib4sv = glad_debug_impl_glVertexAttrib4sv;\nPFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4f(GLuint arg0, GLfloat arg1, GLfloat arg2, GLfloat arg3, GLfloat arg4) {\n    _pre_call_callback(\"glVertexAttrib4f\", (void*)glVertexAttrib4f, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glVertexAttrib4f(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glVertexAttrib4f\", (void*)glVertexAttrib4f, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLVERTEXATTRIB4FPROC glad_debug_glVertexAttrib4f = glad_debug_impl_glVertexAttrib4f;\nPFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog;\nvoid APIENTRY glad_debug_impl_glGetProgramInfoLog(GLuint arg0, GLsizei arg1, GLsizei * arg2, GLchar * arg3) {\n    _pre_call_callback(\"glGetProgramInfoLog\", (void*)glGetProgramInfoLog, 4, arg0, arg1, arg2, arg3);\n     glad_glGetProgramInfoLog(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetProgramInfoLog\", (void*)glGetProgramInfoLog, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETPROGRAMINFOLOGPROC glad_debug_glGetProgramInfoLog = glad_debug_impl_glGetProgramInfoLog;\nPFNGLMULTITEXCOORDP1UIPROC glad_glMultiTexCoordP1ui;\nvoid APIENTRY glad_debug_impl_glMultiTexCoordP1ui(GLenum arg0, GLenum arg1, GLuint arg2) {\n    _pre_call_callback(\"glMultiTexCoordP1ui\", (void*)glMultiTexCoordP1ui, 3, arg0, arg1, arg2);\n     glad_glMultiTexCoordP1ui(arg0, arg1, arg2);\n    _post_call_callback(\"glMultiTexCoordP1ui\", (void*)glMultiTexCoordP1ui, 3, arg0, arg1, arg2);\n}\nPFNGLMULTITEXCOORDP1UIPROC glad_debug_glMultiTexCoordP1ui = glad_debug_impl_glMultiTexCoordP1ui;\nPFNGLPOLYGONOFFSETPROC glad_glPolygonOffset;\nvoid APIENTRY glad_debug_impl_glPolygonOffset(GLfloat arg0, GLfloat arg1) {\n    _pre_call_callback(\"glPolygonOffset\", (void*)glPolygonOffset, 2, arg0, arg1);\n     glad_glPolygonOffset(arg0, arg1);\n    _post_call_callback(\"glPolygonOffset\", (void*)glPolygonOffset, 2, arg0, arg1);\n}\nPFNGLPOLYGONOFFSETPROC glad_debug_glPolygonOffset = glad_debug_impl_glPolygonOffset;\nPFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers;\nvoid APIENTRY glad_debug_impl_glGenFramebuffers(GLsizei arg0, GLuint * arg1) {\n    _pre_call_callback(\"glGenFramebuffers\", (void*)glGenFramebuffers, 2, arg0, arg1);\n     glad_glGenFramebuffers(arg0, arg1);\n    _post_call_callback(\"glGenFramebuffers\", (void*)glGenFramebuffers, 2, arg0, arg1);\n}\nPFNGLGENFRAMEBUFFERSPROC glad_debug_glGenFramebuffers = glad_debug_impl_glGenFramebuffers;\nPFNGLBINDTEXTUREPROC glad_glBindTexture;\nvoid APIENTRY glad_debug_impl_glBindTexture(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glBindTexture\", (void*)glBindTexture, 2, arg0, arg1);\n     glad_glBindTexture(arg0, arg1);\n    _post_call_callback(\"glBindTexture\", (void*)glBindTexture, 2, arg0, arg1);\n}\nPFNGLBINDTEXTUREPROC glad_debug_glBindTexture = glad_debug_impl_glBindTexture;\nPFNGLFENCESYNCPROC glad_glFenceSync;\nGLsync APIENTRY glad_debug_impl_glFenceSync(GLenum arg0, GLbitfield arg1) {\n    GLsync ret;\n    _pre_call_callback(\"glFenceSync\", (void*)glFenceSync, 2, arg0, arg1);\n    ret =  glad_glFenceSync(arg0, arg1);\n    _post_call_callback(\"glFenceSync\", (void*)glFenceSync, 2, arg0, arg1);\n    return ret;\n}\nPFNGLFENCESYNCPROC glad_debug_glFenceSync = glad_debug_impl_glFenceSync;\nPFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex;\nvoid APIENTRY glad_debug_impl_glDrawElementsInstancedBaseVertex(GLenum arg0, GLsizei arg1, GLenum arg2, const void * arg3, GLsizei arg4, GLint arg5) {\n    _pre_call_callback(\"glDrawElementsInstancedBaseVertex\", (void*)glDrawElementsInstancedBaseVertex, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n     glad_glDrawElementsInstancedBaseVertex(arg0, arg1, arg2, arg3, arg4, arg5);\n    _post_call_callback(\"glDrawElementsInstancedBaseVertex\", (void*)glDrawElementsInstancedBaseVertex, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n}\nPFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_debug_glDrawElementsInstancedBaseVertex = glad_debug_impl_glDrawElementsInstancedBaseVertex;\nPFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData;\nvoid APIENTRY glad_debug_impl_glGetBufferSubData(GLenum arg0, GLintptr arg1, GLsizeiptr arg2, void * arg3) {\n    _pre_call_callback(\"glGetBufferSubData\", (void*)glGetBufferSubData, 4, arg0, arg1, arg2, arg3);\n     glad_glGetBufferSubData(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetBufferSubData\", (void*)glGetBufferSubData, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETBUFFERSUBDATAPROC glad_debug_glGetBufferSubData = glad_debug_impl_glGetBufferSubData;\nPFNGLPOINTPARAMETERIPROC glad_glPointParameteri;\nvoid APIENTRY glad_debug_impl_glPointParameteri(GLenum arg0, GLint arg1) {\n    _pre_call_callback(\"glPointParameteri\", (void*)glPointParameteri, 2, arg0, arg1);\n     glad_glPointParameteri(arg0, arg1);\n    _post_call_callback(\"glPointParameteri\", (void*)glPointParameteri, 2, arg0, arg1);\n}\nPFNGLPOINTPARAMETERIPROC glad_debug_glPointParameteri = glad_debug_impl_glPointParameteri;\nPFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements;\nvoid APIENTRY glad_debug_impl_glDrawRangeElements(GLenum arg0, GLuint arg1, GLuint arg2, GLsizei arg3, GLenum arg4, const void * arg5) {\n    _pre_call_callback(\"glDrawRangeElements\", (void*)glDrawRangeElements, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n     glad_glDrawRangeElements(arg0, arg1, arg2, arg3, arg4, arg5);\n    _post_call_callback(\"glDrawRangeElements\", (void*)glDrawRangeElements, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n}\nPFNGLDRAWRANGEELEMENTSPROC glad_debug_glDrawRangeElements = glad_debug_impl_glDrawRangeElements;\nPFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays;\nvoid APIENTRY glad_debug_impl_glMultiDrawArrays(GLenum arg0, const GLint * arg1, const GLsizei * arg2, GLsizei arg3) {\n    _pre_call_callback(\"glMultiDrawArrays\", (void*)glMultiDrawArrays, 4, arg0, arg1, arg2, arg3);\n     glad_glMultiDrawArrays(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glMultiDrawArrays\", (void*)glMultiDrawArrays, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLMULTIDRAWARRAYSPROC glad_debug_glMultiDrawArrays = glad_debug_impl_glMultiDrawArrays;\nPFNGLDRAWARRAYSPROC glad_glDrawArrays;\nvoid APIENTRY glad_debug_impl_glDrawArrays(GLenum arg0, GLint arg1, GLsizei arg2) {\n    _pre_call_callback(\"glDrawArrays\", (void*)glDrawArrays, 3, arg0, arg1, arg2);\n     glad_glDrawArrays(arg0, arg1, arg2);\n    _post_call_callback(\"glDrawArrays\", (void*)glDrawArrays, 3, arg0, arg1, arg2);\n}\nPFNGLDRAWARRAYSPROC glad_debug_glDrawArrays = glad_debug_impl_glDrawArrays;\nPFNGLGENBUFFERSPROC glad_glGenBuffers;\nvoid APIENTRY glad_debug_impl_glGenBuffers(GLsizei arg0, GLuint * arg1) {\n    _pre_call_callback(\"glGenBuffers\", (void*)glGenBuffers, 2, arg0, arg1);\n     glad_glGenBuffers(arg0, arg1);\n    _post_call_callback(\"glGenBuffers\", (void*)glGenBuffers, 2, arg0, arg1);\n}\nPFNGLGENBUFFERSPROC glad_debug_glGenBuffers = glad_debug_impl_glGenBuffers;\nPFNGLNORMALP3UIPROC glad_glNormalP3ui;\nvoid APIENTRY glad_debug_impl_glNormalP3ui(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glNormalP3ui\", (void*)glNormalP3ui, 2, arg0, arg1);\n     glad_glNormalP3ui(arg0, arg1);\n    _post_call_callback(\"glNormalP3ui\", (void*)glNormalP3ui, 2, arg0, arg1);\n}\nPFNGLNORMALP3UIPROC glad_debug_glNormalP3ui = glad_debug_impl_glNormalP3ui;\nPFNGLENABLEIPROC glad_glEnablei;\nvoid APIENTRY glad_debug_impl_glEnablei(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glEnablei\", (void*)glEnablei, 2, arg0, arg1);\n     glad_glEnablei(arg0, arg1);\n    _post_call_callback(\"glEnablei\", (void*)glEnablei, 2, arg0, arg1);\n}\nPFNGLENABLEIPROC glad_debug_glEnablei = glad_debug_impl_glEnablei;\nPFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v;\nvoid APIENTRY glad_debug_impl_glGetQueryObjectui64v(GLuint arg0, GLenum arg1, GLuint64 * arg2) {\n    _pre_call_callback(\"glGetQueryObjectui64v\", (void*)glGetQueryObjectui64v, 3, arg0, arg1, arg2);\n     glad_glGetQueryObjectui64v(arg0, arg1, arg2);\n    _post_call_callback(\"glGetQueryObjectui64v\", (void*)glGetQueryObjectui64v, 3, arg0, arg1, arg2);\n}\nPFNGLGETQUERYOBJECTUI64VPROC glad_debug_glGetQueryObjectui64v = glad_debug_impl_glGetQueryObjectui64v;\nPFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4Nbv(GLuint arg0, const GLbyte * arg1) {\n    _pre_call_callback(\"glVertexAttrib4Nbv\", (void*)glVertexAttrib4Nbv, 2, arg0, arg1);\n     glad_glVertexAttrib4Nbv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib4Nbv\", (void*)glVertexAttrib4Nbv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB4NBVPROC glad_debug_glVertexAttrib4Nbv = glad_debug_impl_glVertexAttrib4Nbv;\nPFNGLISENABLEDIPROC glad_glIsEnabledi;\nGLboolean APIENTRY glad_debug_impl_glIsEnabledi(GLenum arg0, GLuint arg1) {\n    GLboolean ret;\n    _pre_call_callback(\"glIsEnabledi\", (void*)glIsEnabledi, 2, arg0, arg1);\n    ret =  glad_glIsEnabledi(arg0, arg1);\n    _post_call_callback(\"glIsEnabledi\", (void*)glIsEnabledi, 2, arg0, arg1);\n    return ret;\n}\nPFNGLISENABLEDIPROC glad_debug_glIsEnabledi = glad_debug_impl_glIsEnabledi;\nPFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D;\nvoid APIENTRY glad_debug_impl_glTexSubImage2D(GLenum arg0, GLint arg1, GLint arg2, GLint arg3, GLsizei arg4, GLsizei arg5, GLenum arg6, GLenum arg7, const void * arg8) {\n    _pre_call_callback(\"glTexSubImage2D\", (void*)glTexSubImage2D, 9, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n     glad_glTexSubImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n    _post_call_callback(\"glTexSubImage2D\", (void*)glTexSubImage2D, 9, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n}\nPFNGLTEXSUBIMAGE2DPROC glad_debug_glTexSubImage2D = glad_debug_impl_glTexSubImage2D;\nPFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v;\nvoid APIENTRY glad_debug_impl_glGetBufferParameteri64v(GLenum arg0, GLenum arg1, GLint64 * arg2) {\n    _pre_call_callback(\"glGetBufferParameteri64v\", (void*)glGetBufferParameteri64v, 3, arg0, arg1, arg2);\n     glad_glGetBufferParameteri64v(arg0, arg1, arg2);\n    _post_call_callback(\"glGetBufferParameteri64v\", (void*)glGetBufferParameteri64v, 3, arg0, arg1, arg2);\n}\nPFNGLGETBUFFERPARAMETERI64VPROC glad_debug_glGetBufferParameteri64v = glad_debug_impl_glGetBufferParameteri64v;\nPFNGLISVERTEXARRAYPROC glad_glIsVertexArray;\nGLboolean APIENTRY glad_debug_impl_glIsVertexArray(GLuint arg0) {\n    GLboolean ret;\n    _pre_call_callback(\"glIsVertexArray\", (void*)glIsVertexArray, 1, arg0);\n    ret =  glad_glIsVertexArray(arg0);\n    _post_call_callback(\"glIsVertexArray\", (void*)glIsVertexArray, 1, arg0);\n    return ret;\n}\nPFNGLISVERTEXARRAYPROC glad_debug_glIsVertexArray = glad_debug_impl_glIsVertexArray;\nPFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf;\nvoid APIENTRY glad_debug_impl_glSamplerParameterf(GLuint arg0, GLenum arg1, GLfloat arg2) {\n    _pre_call_callback(\"glSamplerParameterf\", (void*)glSamplerParameterf, 3, arg0, arg1, arg2);\n     glad_glSamplerParameterf(arg0, arg1, arg2);\n    _post_call_callback(\"glSamplerParameterf\", (void*)glSamplerParameterf, 3, arg0, arg1, arg2);\n}\nPFNGLSAMPLERPARAMETERFPROC glad_debug_glSamplerParameterf = glad_debug_impl_glSamplerParameterf;\nPFNGLFLUSHPROC glad_glFlush;\nvoid APIENTRY glad_debug_impl_glFlush(void) {\n    _pre_call_callback(\"glFlush\", (void*)glFlush, 0);\n     glad_glFlush();\n    _post_call_callback(\"glFlush\", (void*)glFlush, 0);\n}\nPFNGLFLUSHPROC glad_debug_glFlush = glad_debug_impl_glFlush;\nPFNGLUNIFORM2IVPROC glad_glUniform2iv;\nvoid APIENTRY glad_debug_impl_glUniform2iv(GLint arg0, GLsizei arg1, const GLint * arg2) {\n    _pre_call_callback(\"glUniform2iv\", (void*)glUniform2iv, 3, arg0, arg1, arg2);\n     glad_glUniform2iv(arg0, arg1, arg2);\n    _post_call_callback(\"glUniform2iv\", (void*)glUniform2iv, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORM2IVPROC glad_debug_glUniform2iv = glad_debug_impl_glUniform2iv;\nPFNGLTEXCOORDP1UIPROC glad_glTexCoordP1ui;\nvoid APIENTRY glad_debug_impl_glTexCoordP1ui(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glTexCoordP1ui\", (void*)glTexCoordP1ui, 2, arg0, arg1);\n     glad_glTexCoordP1ui(arg0, arg1);\n    _post_call_callback(\"glTexCoordP1ui\", (void*)glTexCoordP1ui, 2, arg0, arg1);\n}\nPFNGLTEXCOORDP1UIPROC glad_debug_glTexCoordP1ui = glad_debug_impl_glTexCoordP1ui;\nPFNGLISENABLEDPROC glad_glIsEnabled;\nGLboolean APIENTRY glad_debug_impl_glIsEnabled(GLenum arg0) {\n    GLboolean ret;\n    _pre_call_callback(\"glIsEnabled\", (void*)glIsEnabled, 1, arg0);\n    ret =  glad_glIsEnabled(arg0);\n    _post_call_callback(\"glIsEnabled\", (void*)glIsEnabled, 1, arg0);\n    return ret;\n}\nPFNGLISENABLEDPROC glad_debug_glIsEnabled = glad_debug_impl_glIsEnabled;\nPFNGLBUFFERDATAPROC glad_glBufferData;\nvoid APIENTRY glad_debug_impl_glBufferData(GLenum arg0, GLsizeiptr arg1, const void * arg2, GLenum arg3) {\n    _pre_call_callback(\"glBufferData\", (void*)glBufferData, 4, arg0, arg1, arg2, arg3);\n     glad_glBufferData(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glBufferData\", (void*)glBufferData, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLBUFFERDATAPROC glad_debug_glBufferData = glad_debug_impl_glBufferData;\nPFNGLTEXPARAMETERFPROC glad_glTexParameterf;\nvoid APIENTRY glad_debug_impl_glTexParameterf(GLenum arg0, GLenum arg1, GLfloat arg2) {\n    _pre_call_callback(\"glTexParameterf\", (void*)glTexParameterf, 3, arg0, arg1, arg2);\n     glad_glTexParameterf(arg0, arg1, arg2);\n    _post_call_callback(\"glTexParameterf\", (void*)glTexParameterf, 3, arg0, arg1, arg2);\n}\nPFNGLTEXPARAMETERFPROC glad_debug_glTexParameterf = glad_debug_impl_glTexParameterf;\nPFNGLGETINTEGERVPROC glad_glGetIntegerv;\nvoid APIENTRY glad_debug_impl_glGetIntegerv(GLenum arg0, GLint * arg1) {\n    _pre_call_callback(\"glGetIntegerv\", (void*)glGetIntegerv, 2, arg0, arg1);\n     glad_glGetIntegerv(arg0, arg1);\n    _post_call_callback(\"glGetIntegerv\", (void*)glGetIntegerv, 2, arg0, arg1);\n}\nPFNGLGETINTEGERVPROC glad_debug_glGetIntegerv = glad_debug_impl_glGetIntegerv;\nPFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv;\nvoid APIENTRY glad_debug_impl_glVertexAttribP3uiv(GLuint arg0, GLenum arg1, GLboolean arg2, const GLuint * arg3) {\n    _pre_call_callback(\"glVertexAttribP3uiv\", (void*)glVertexAttribP3uiv, 4, arg0, arg1, arg2, arg3);\n     glad_glVertexAttribP3uiv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glVertexAttribP3uiv\", (void*)glVertexAttribP3uiv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLVERTEXATTRIBP3UIVPROC glad_debug_glVertexAttribP3uiv = glad_debug_impl_glVertexAttribP3uiv;\nPFNGLUNIFORM4FPROC glad_glUniform4f;\nvoid APIENTRY glad_debug_impl_glUniform4f(GLint arg0, GLfloat arg1, GLfloat arg2, GLfloat arg3, GLfloat arg4) {\n    _pre_call_callback(\"glUniform4f\", (void*)glUniform4f, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glUniform4f(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glUniform4f\", (void*)glUniform4f, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLUNIFORM4FPROC glad_debug_glUniform4f = glad_debug_impl_glUniform4f;\nPFNGLUNIFORM2UIPROC glad_glUniform2ui;\nvoid APIENTRY glad_debug_impl_glUniform2ui(GLint arg0, GLuint arg1, GLuint arg2) {\n    _pre_call_callback(\"glUniform2ui\", (void*)glUniform2ui, 3, arg0, arg1, arg2);\n     glad_glUniform2ui(arg0, arg1, arg2);\n    _post_call_callback(\"glUniform2ui\", (void*)glUniform2ui, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORM2UIPROC glad_debug_glUniform2ui = glad_debug_impl_glUniform2ui;\nPFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex;\nvoid APIENTRY glad_debug_impl_glProvokingVertex(GLenum arg0) {\n    _pre_call_callback(\"glProvokingVertex\", (void*)glProvokingVertex, 1, arg0);\n     glad_glProvokingVertex(arg0);\n    _post_call_callback(\"glProvokingVertex\", (void*)glProvokingVertex, 1, arg0);\n}\nPFNGLPROVOKINGVERTEXPROC glad_debug_glProvokingVertex = glad_debug_impl_glProvokingVertex;\nPFNGLUNIFORM4IPROC glad_glUniform4i;\nvoid APIENTRY glad_debug_impl_glUniform4i(GLint arg0, GLint arg1, GLint arg2, GLint arg3, GLint arg4) {\n    _pre_call_callback(\"glUniform4i\", (void*)glUniform4i, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glUniform4i(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glUniform4i\", (void*)glUniform4i, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLUNIFORM4IPROC glad_debug_glUniform4i = glad_debug_impl_glUniform4i;\nPFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv;\nvoid APIENTRY glad_debug_impl_glTexParameterIiv(GLenum arg0, GLenum arg1, const GLint * arg2) {\n    _pre_call_callback(\"glTexParameterIiv\", (void*)glTexParameterIiv, 3, arg0, arg1, arg2);\n     glad_glTexParameterIiv(arg0, arg1, arg2);\n    _post_call_callback(\"glTexParameterIiv\", (void*)glTexParameterIiv, 3, arg0, arg1, arg2);\n}\nPFNGLTEXPARAMETERIIVPROC glad_debug_glTexParameterIiv = glad_debug_impl_glTexParameterIiv;\nPFNGLDEPTHMASKPROC glad_glDepthMask;\nvoid APIENTRY glad_debug_impl_glDepthMask(GLboolean arg0) {\n    _pre_call_callback(\"glDepthMask\", (void*)glDepthMask, 1, arg0);\n     glad_glDepthMask(arg0);\n    _post_call_callback(\"glDepthMask\", (void*)glDepthMask, 1, arg0);\n}\nPFNGLDEPTHMASKPROC glad_debug_glDepthMask = glad_debug_impl_glDepthMask;\nPFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate;\nvoid APIENTRY glad_debug_impl_glStencilFuncSeparate(GLenum arg0, GLenum arg1, GLint arg2, GLuint arg3) {\n    _pre_call_callback(\"glStencilFuncSeparate\", (void*)glStencilFuncSeparate, 4, arg0, arg1, arg2, arg3);\n     glad_glStencilFuncSeparate(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glStencilFuncSeparate\", (void*)glStencilFuncSeparate, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLSTENCILFUNCSEPARATEPROC glad_debug_glStencilFuncSeparate = glad_debug_impl_glStencilFuncSeparate;\nPFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog;\nvoid APIENTRY glad_debug_impl_glGetShaderInfoLog(GLuint arg0, GLsizei arg1, GLsizei * arg2, GLchar * arg3) {\n    _pre_call_callback(\"glGetShaderInfoLog\", (void*)glGetShaderInfoLog, 4, arg0, arg1, arg2, arg3);\n     glad_glGetShaderInfoLog(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetShaderInfoLog\", (void*)glGetShaderInfoLog, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETSHADERINFOLOGPROC glad_debug_glGetShaderInfoLog = glad_debug_impl_glGetShaderInfoLog;\nPFNGLACTIVETEXTUREPROC glad_glActiveTexture;\nvoid APIENTRY glad_debug_impl_glActiveTexture(GLenum arg0) {\n    _pre_call_callback(\"glActiveTexture\", (void*)glActiveTexture, 1, arg0);\n     glad_glActiveTexture(arg0);\n    _post_call_callback(\"glActiveTexture\", (void*)glActiveTexture, 1, arg0);\n}\nPFNGLACTIVETEXTUREPROC glad_debug_glActiveTexture = glad_debug_impl_glActiveTexture;\nPFNGLPOINTPARAMETERFPROC glad_glPointParameterf;\nvoid APIENTRY glad_debug_impl_glPointParameterf(GLenum arg0, GLfloat arg1) {\n    _pre_call_callback(\"glPointParameterf\", (void*)glPointParameterf, 2, arg0, arg1);\n     glad_glPointParameterf(arg0, arg1);\n    _post_call_callback(\"glPointParameterf\", (void*)glPointParameterf, 2, arg0, arg1);\n}\nPFNGLPOINTPARAMETERFPROC glad_debug_glPointParameterf = glad_debug_impl_glPointParameterf;\nPFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv;\nvoid APIENTRY glad_debug_impl_glUniformMatrix2fv(GLint arg0, GLsizei arg1, GLboolean arg2, const GLfloat * arg3) {\n    _pre_call_callback(\"glUniformMatrix2fv\", (void*)glUniformMatrix2fv, 4, arg0, arg1, arg2, arg3);\n     glad_glUniformMatrix2fv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glUniformMatrix2fv\", (void*)glUniformMatrix2fv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLUNIFORMMATRIX2FVPROC glad_debug_glUniformMatrix2fv = glad_debug_impl_glUniformMatrix2fv;\nPFNGLBINDBUFFERPROC glad_glBindBuffer;\nvoid APIENTRY glad_debug_impl_glBindBuffer(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glBindBuffer\", (void*)glBindBuffer, 2, arg0, arg1);\n     glad_glBindBuffer(arg0, arg1);\n    _post_call_callback(\"glBindBuffer\", (void*)glBindBuffer, 2, arg0, arg1);\n}\nPFNGLBINDBUFFERPROC glad_debug_glBindBuffer = glad_debug_impl_glBindBuffer;\nPFNGLUNIFORM3FVPROC glad_glUniform3fv;\nvoid APIENTRY glad_debug_impl_glUniform3fv(GLint arg0, GLsizei arg1, const GLfloat * arg2) {\n    _pre_call_callback(\"glUniform3fv\", (void*)glUniform3fv, 3, arg0, arg1, arg2);\n     glad_glUniform3fv(arg0, arg1, arg2);\n    _post_call_callback(\"glUniform3fv\", (void*)glUniform3fv, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORM3FVPROC glad_debug_glUniform3fv = glad_debug_impl_glUniform3fv;\nPFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender;\nvoid APIENTRY glad_debug_impl_glEndConditionalRender(void) {\n    _pre_call_callback(\"glEndConditionalRender\", (void*)glEndConditionalRender, 0);\n     glad_glEndConditionalRender();\n    _post_call_callback(\"glEndConditionalRender\", (void*)glEndConditionalRender, 0);\n}\nPFNGLENDCONDITIONALRENDERPROC glad_debug_glEndConditionalRender = glad_debug_impl_glEndConditionalRender;\nPFNGLMULTITEXCOORDP4UIPROC glad_glMultiTexCoordP4ui;\nvoid APIENTRY glad_debug_impl_glMultiTexCoordP4ui(GLenum arg0, GLenum arg1, GLuint arg2) {\n    _pre_call_callback(\"glMultiTexCoordP4ui\", (void*)glMultiTexCoordP4ui, 3, arg0, arg1, arg2);\n     glad_glMultiTexCoordP4ui(arg0, arg1, arg2);\n    _post_call_callback(\"glMultiTexCoordP4ui\", (void*)glMultiTexCoordP4ui, 3, arg0, arg1, arg2);\n}\nPFNGLMULTITEXCOORDP4UIPROC glad_debug_glMultiTexCoordP4ui = glad_debug_impl_glMultiTexCoordP4ui;\nPFNGLGETSHADERIVPROC glad_glGetShaderiv;\nvoid APIENTRY glad_debug_impl_glGetShaderiv(GLuint arg0, GLenum arg1, GLint * arg2) {\n    _pre_call_callback(\"glGetShaderiv\", (void*)glGetShaderiv, 3, arg0, arg1, arg2);\n     glad_glGetShaderiv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetShaderiv\", (void*)glGetShaderiv, 3, arg0, arg1, arg2);\n}\nPFNGLGETSHADERIVPROC glad_debug_glGetShaderiv = glad_debug_impl_glGetShaderiv;\nPFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv;\nvoid APIENTRY glad_debug_impl_glVertexAttribI3uiv(GLuint arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glVertexAttribI3uiv\", (void*)glVertexAttribI3uiv, 2, arg0, arg1);\n     glad_glVertexAttribI3uiv(arg0, arg1);\n    _post_call_callback(\"glVertexAttribI3uiv\", (void*)glVertexAttribI3uiv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIBI3UIVPROC glad_debug_glVertexAttribI3uiv = glad_debug_impl_glVertexAttribI3uiv;\nPFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender;\nvoid APIENTRY glad_debug_impl_glBeginConditionalRender(GLuint arg0, GLenum arg1) {\n    _pre_call_callback(\"glBeginConditionalRender\", (void*)glBeginConditionalRender, 2, arg0, arg1);\n     glad_glBeginConditionalRender(arg0, arg1);\n    _post_call_callback(\"glBeginConditionalRender\", (void*)glBeginConditionalRender, 2, arg0, arg1);\n}\nPFNGLBEGINCONDITIONALRENDERPROC glad_debug_glBeginConditionalRender = glad_debug_impl_glBeginConditionalRender;\nPFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui;\nvoid APIENTRY glad_debug_impl_glVertexAttribI2ui(GLuint arg0, GLuint arg1, GLuint arg2) {\n    _pre_call_callback(\"glVertexAttribI2ui\", (void*)glVertexAttribI2ui, 3, arg0, arg1, arg2);\n     glad_glVertexAttribI2ui(arg0, arg1, arg2);\n    _post_call_callback(\"glVertexAttribI2ui\", (void*)glVertexAttribI2ui, 3, arg0, arg1, arg2);\n}\nPFNGLVERTEXATTRIBI2UIPROC glad_debug_glVertexAttribI2ui = glad_debug_impl_glVertexAttribI2ui;\nPFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv;\nvoid APIENTRY glad_debug_impl_glGetQueryObjectuiv(GLuint arg0, GLenum arg1, GLuint * arg2) {\n    _pre_call_callback(\"glGetQueryObjectuiv\", (void*)glGetQueryObjectuiv, 3, arg0, arg1, arg2);\n     glad_glGetQueryObjectuiv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetQueryObjectuiv\", (void*)glGetQueryObjectuiv, 3, arg0, arg1, arg2);\n}\nPFNGLGETQUERYOBJECTUIVPROC glad_debug_glGetQueryObjectuiv = glad_debug_impl_glGetQueryObjectuiv;\nPFNGLCOLORP3UIVPROC glad_glColorP3uiv;\nvoid APIENTRY glad_debug_impl_glColorP3uiv(GLenum arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glColorP3uiv\", (void*)glColorP3uiv, 2, arg0, arg1);\n     glad_glColorP3uiv(arg0, arg1);\n    _post_call_callback(\"glColorP3uiv\", (void*)glColorP3uiv, 2, arg0, arg1);\n}\nPFNGLCOLORP3UIVPROC glad_debug_glColorP3uiv = glad_debug_impl_glColorP3uiv;\nPFNGLCOMPILESHADERPROC glad_glCompileShader;\nvoid APIENTRY glad_debug_impl_glCompileShader(GLuint arg0) {\n    _pre_call_callback(\"glCompileShader\", (void*)glCompileShader, 1, arg0);\n     glad_glCompileShader(arg0);\n    _post_call_callback(\"glCompileShader\", (void*)glCompileShader, 1, arg0);\n}\nPFNGLCOMPILESHADERPROC glad_debug_glCompileShader = glad_debug_impl_glCompileShader;\nPFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback;\nvoid APIENTRY glad_debug_impl_glEndTransformFeedback(void) {\n    _pre_call_callback(\"glEndTransformFeedback\", (void*)glEndTransformFeedback, 0);\n     glad_glEndTransformFeedback();\n    _post_call_callback(\"glEndTransformFeedback\", (void*)glEndTransformFeedback, 0);\n}\nPFNGLENDTRANSFORMFEEDBACKPROC glad_debug_glEndTransformFeedback = glad_debug_impl_glEndTransformFeedback;\nPFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage;\nvoid APIENTRY glad_debug_impl_glGetCompressedTexImage(GLenum arg0, GLint arg1, void * arg2) {\n    _pre_call_callback(\"glGetCompressedTexImage\", (void*)glGetCompressedTexImage, 3, arg0, arg1, arg2);\n     glad_glGetCompressedTexImage(arg0, arg1, arg2);\n    _post_call_callback(\"glGetCompressedTexImage\", (void*)glGetCompressedTexImage, 3, arg0, arg1, arg2);\n}\nPFNGLGETCOMPRESSEDTEXIMAGEPROC glad_debug_glGetCompressedTexImage = glad_debug_impl_glGetCompressedTexImage;\nPFNGLGENQUERIESPROC glad_glGenQueries;\nvoid APIENTRY glad_debug_impl_glGenQueries(GLsizei arg0, GLuint * arg1) {\n    _pre_call_callback(\"glGenQueries\", (void*)glGenQueries, 2, arg0, arg1);\n     glad_glGenQueries(arg0, arg1);\n    _post_call_callback(\"glGenQueries\", (void*)glGenQueries, 2, arg0, arg1);\n}\nPFNGLGENQUERIESPROC glad_debug_glGenQueries = glad_debug_impl_glGenQueries;\nPFNGLMULTITEXCOORDP3UIPROC glad_glMultiTexCoordP3ui;\nvoid APIENTRY glad_debug_impl_glMultiTexCoordP3ui(GLenum arg0, GLenum arg1, GLuint arg2) {\n    _pre_call_callback(\"glMultiTexCoordP3ui\", (void*)glMultiTexCoordP3ui, 3, arg0, arg1, arg2);\n     glad_glMultiTexCoordP3ui(arg0, arg1, arg2);\n    _post_call_callback(\"glMultiTexCoordP3ui\", (void*)glMultiTexCoordP3ui, 3, arg0, arg1, arg2);\n}\nPFNGLMULTITEXCOORDP3UIPROC glad_debug_glMultiTexCoordP3ui = glad_debug_impl_glMultiTexCoordP3ui;\nPFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D;\nvoid APIENTRY glad_debug_impl_glCopyTexSubImage1D(GLenum arg0, GLint arg1, GLint arg2, GLint arg3, GLint arg4, GLsizei arg5) {\n    _pre_call_callback(\"glCopyTexSubImage1D\", (void*)glCopyTexSubImage1D, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n     glad_glCopyTexSubImage1D(arg0, arg1, arg2, arg3, arg4, arg5);\n    _post_call_callback(\"glCopyTexSubImage1D\", (void*)glCopyTexSubImage1D, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n}\nPFNGLCOPYTEXSUBIMAGE1DPROC glad_debug_glCopyTexSubImage1D = glad_debug_impl_glCopyTexSubImage1D;\nPFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv;\nvoid APIENTRY glad_debug_impl_glUniformMatrix2x4fv(GLint arg0, GLsizei arg1, GLboolean arg2, const GLfloat * arg3) {\n    _pre_call_callback(\"glUniformMatrix2x4fv\", (void*)glUniformMatrix2x4fv, 4, arg0, arg1, arg2, arg3);\n     glad_glUniformMatrix2x4fv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glUniformMatrix2x4fv\", (void*)glUniformMatrix2x4fv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLUNIFORMMATRIX2X4FVPROC glad_debug_glUniformMatrix2x4fv = glad_debug_impl_glUniformMatrix2x4fv;\nPFNGLGETQUERYIVPROC glad_glGetQueryiv;\nvoid APIENTRY glad_debug_impl_glGetQueryiv(GLenum arg0, GLenum arg1, GLint * arg2) {\n    _pre_call_callback(\"glGetQueryiv\", (void*)glGetQueryiv, 3, arg0, arg1, arg2);\n     glad_glGetQueryiv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetQueryiv\", (void*)glGetQueryiv, 3, arg0, arg1, arg2);\n}\nPFNGLGETQUERYIVPROC glad_debug_glGetQueryiv = glad_debug_impl_glGetQueryiv;\nPFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv;\nvoid APIENTRY glad_debug_impl_glGetSamplerParameterfv(GLuint arg0, GLenum arg1, GLfloat * arg2) {\n    _pre_call_callback(\"glGetSamplerParameterfv\", (void*)glGetSamplerParameterfv, 3, arg0, arg1, arg2);\n     glad_glGetSamplerParameterfv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetSamplerParameterfv\", (void*)glGetSamplerParameterfv, 3, arg0, arg1, arg2);\n}\nPFNGLGETSAMPLERPARAMETERFVPROC glad_debug_glGetSamplerParameterfv = glad_debug_impl_glGetSamplerParameterfv;\nPFNGLGETSHADERSOURCEPROC glad_glGetShaderSource;\nvoid APIENTRY glad_debug_impl_glGetShaderSource(GLuint arg0, GLsizei arg1, GLsizei * arg2, GLchar * arg3) {\n    _pre_call_callback(\"glGetShaderSource\", (void*)glGetShaderSource, 4, arg0, arg1, arg2, arg3);\n     glad_glGetShaderSource(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetShaderSource\", (void*)glGetShaderSource, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETSHADERSOURCEPROC glad_debug_glGetShaderSource = glad_debug_impl_glGetShaderSource;\nPFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer;\nGLboolean APIENTRY glad_debug_impl_glIsRenderbuffer(GLuint arg0) {\n    GLboolean ret;\n    _pre_call_callback(\"glIsRenderbuffer\", (void*)glIsRenderbuffer, 1, arg0);\n    ret =  glad_glIsRenderbuffer(arg0);\n    _post_call_callback(\"glIsRenderbuffer\", (void*)glIsRenderbuffer, 1, arg0);\n    return ret;\n}\nPFNGLISRENDERBUFFERPROC glad_debug_glIsRenderbuffer = glad_debug_impl_glIsRenderbuffer;\nPFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor;\nvoid APIENTRY glad_debug_impl_glVertexAttribDivisor(GLuint arg0, GLuint arg1) {\n    _pre_call_callback(\"glVertexAttribDivisor\", (void*)glVertexAttribDivisor, 2, arg0, arg1);\n     glad_glVertexAttribDivisor(arg0, arg1);\n    _post_call_callback(\"glVertexAttribDivisor\", (void*)glVertexAttribDivisor, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIBDIVISORPROC glad_debug_glVertexAttribDivisor = glad_debug_impl_glVertexAttribDivisor;\nPFNGLCULLFACEPROC glad_glCullFace;\nvoid APIENTRY glad_debug_impl_glCullFace(GLenum arg0) {\n    _pre_call_callback(\"glCullFace\", (void*)glCullFace, 1, arg0);\n     glad_glCullFace(arg0);\n    _post_call_callback(\"glCullFace\", (void*)glCullFace, 1, arg0);\n}\nPFNGLCULLFACEPROC glad_debug_glCullFace = glad_debug_impl_glCullFace;\nPFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D;\nvoid APIENTRY glad_debug_impl_glCompressedTexSubImage2D(GLenum arg0, GLint arg1, GLint arg2, GLint arg3, GLsizei arg4, GLsizei arg5, GLenum arg6, GLsizei arg7, const void * arg8) {\n    _pre_call_callback(\"glCompressedTexSubImage2D\", (void*)glCompressedTexSubImage2D, 9, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n     glad_glCompressedTexSubImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n    _post_call_callback(\"glCompressedTexSubImage2D\", (void*)glCompressedTexSubImage2D, 9, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n}\nPFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_debug_glCompressedTexSubImage2D = glad_debug_impl_glCompressedTexSubImage2D;\nPFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate;\nvoid APIENTRY glad_debug_impl_glStencilOpSeparate(GLenum arg0, GLenum arg1, GLenum arg2, GLenum arg3) {\n    _pre_call_callback(\"glStencilOpSeparate\", (void*)glStencilOpSeparate, 4, arg0, arg1, arg2, arg3);\n     glad_glStencilOpSeparate(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glStencilOpSeparate\", (void*)glStencilOpSeparate, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLSTENCILOPSEPARATEPROC glad_debug_glStencilOpSeparate = glad_debug_impl_glStencilOpSeparate;\nPFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName;\nvoid APIENTRY glad_debug_impl_glGetActiveUniformName(GLuint arg0, GLuint arg1, GLsizei arg2, GLsizei * arg3, GLchar * arg4) {\n    _pre_call_callback(\"glGetActiveUniformName\", (void*)glGetActiveUniformName, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glGetActiveUniformName(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glGetActiveUniformName\", (void*)glGetActiveUniformName, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLGETACTIVEUNIFORMNAMEPROC glad_debug_glGetActiveUniformName = glad_debug_impl_glGetActiveUniformName;\nPFNGLBINDBUFFERBASEPROC glad_glBindBufferBase;\nvoid APIENTRY glad_debug_impl_glBindBufferBase(GLenum arg0, GLuint arg1, GLuint arg2) {\n    _pre_call_callback(\"glBindBufferBase\", (void*)glBindBufferBase, 3, arg0, arg1, arg2);\n     glad_glBindBufferBase(arg0, arg1, arg2);\n    _post_call_callback(\"glBindBufferBase\", (void*)glBindBufferBase, 3, arg0, arg1, arg2);\n}\nPFNGLBINDBUFFERBASEPROC glad_debug_glBindBufferBase = glad_debug_impl_glBindBufferBase;\nPFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f;\nvoid APIENTRY glad_debug_impl_glVertexAttrib3f(GLuint arg0, GLfloat arg1, GLfloat arg2, GLfloat arg3) {\n    _pre_call_callback(\"glVertexAttrib3f\", (void*)glVertexAttrib3f, 4, arg0, arg1, arg2, arg3);\n     glad_glVertexAttrib3f(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glVertexAttrib3f\", (void*)glVertexAttrib3f, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLVERTEXATTRIB3FPROC glad_debug_glVertexAttrib3f = glad_debug_impl_glVertexAttrib3f;\nPFNGLCLEARSTENCILPROC glad_glClearStencil;\nvoid APIENTRY glad_debug_impl_glClearStencil(GLint arg0) {\n    _pre_call_callback(\"glClearStencil\", (void*)glClearStencil, 1, arg0);\n     glad_glClearStencil(arg0);\n    _post_call_callback(\"glClearStencil\", (void*)glClearStencil, 1, arg0);\n}\nPFNGLCLEARSTENCILPROC glad_debug_glClearStencil = glad_debug_impl_glClearStencil;\nPFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation;\nvoid APIENTRY glad_debug_impl_glBindAttribLocation(GLuint arg0, GLuint arg1, const GLchar * arg2) {\n    _pre_call_callback(\"glBindAttribLocation\", (void*)glBindAttribLocation, 3, arg0, arg1, arg2);\n     glad_glBindAttribLocation(arg0, arg1, arg2);\n    _post_call_callback(\"glBindAttribLocation\", (void*)glBindAttribLocation, 3, arg0, arg1, arg2);\n}\nPFNGLBINDATTRIBLOCATIONPROC glad_debug_glBindAttribLocation = glad_debug_impl_glBindAttribLocation;\nPFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray;\nvoid APIENTRY glad_debug_impl_glBindVertexArray(GLuint arg0) {\n    _pre_call_callback(\"glBindVertexArray\", (void*)glBindVertexArray, 1, arg0);\n     glad_glBindVertexArray(arg0);\n    _post_call_callback(\"glBindVertexArray\", (void*)glBindVertexArray, 1, arg0);\n}\nPFNGLBINDVERTEXARRAYPROC glad_debug_glBindVertexArray = glad_debug_impl_glBindVertexArray;\nPFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4Nubv(GLuint arg0, const GLubyte * arg1) {\n    _pre_call_callback(\"glVertexAttrib4Nubv\", (void*)glVertexAttrib4Nubv, 2, arg0, arg1);\n     glad_glVertexAttrib4Nubv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib4Nubv\", (void*)glVertexAttrib4Nubv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB4NUBVPROC glad_debug_glVertexAttrib4Nubv = glad_debug_impl_glVertexAttrib4Nubv;\nPFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample;\nvoid APIENTRY glad_debug_impl_glRenderbufferStorageMultisample(GLenum arg0, GLsizei arg1, GLenum arg2, GLsizei arg3, GLsizei arg4) {\n    _pre_call_callback(\"glRenderbufferStorageMultisample\", (void*)glRenderbufferStorageMultisample, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glRenderbufferStorageMultisample(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glRenderbufferStorageMultisample\", (void*)glRenderbufferStorageMultisample, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_debug_glRenderbufferStorageMultisample = glad_debug_impl_glRenderbufferStorageMultisample;\nPFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample;\nvoid APIENTRY glad_debug_impl_glTexImage2DMultisample(GLenum arg0, GLsizei arg1, GLenum arg2, GLsizei arg3, GLsizei arg4, GLboolean arg5) {\n    _pre_call_callback(\"glTexImage2DMultisample\", (void*)glTexImage2DMultisample, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n     glad_glTexImage2DMultisample(arg0, arg1, arg2, arg3, arg4, arg5);\n    _post_call_callback(\"glTexImage2DMultisample\", (void*)glTexImage2DMultisample, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n}\nPFNGLTEXIMAGE2DMULTISAMPLEPROC glad_debug_glTexImage2DMultisample = glad_debug_impl_glTexImage2DMultisample;\nPFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv;\nvoid APIENTRY glad_debug_impl_glSamplerParameterfv(GLuint arg0, GLenum arg1, const GLfloat * arg2) {\n    _pre_call_callback(\"glSamplerParameterfv\", (void*)glSamplerParameterfv, 3, arg0, arg1, arg2);\n     glad_glSamplerParameterfv(arg0, arg1, arg2);\n    _post_call_callback(\"glSamplerParameterfv\", (void*)glSamplerParameterfv, 3, arg0, arg1, arg2);\n}\nPFNGLSAMPLERPARAMETERFVPROC glad_debug_glSamplerParameterfv = glad_debug_impl_glSamplerParameterfv;\nPFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv;\nvoid APIENTRY glad_debug_impl_glVertexAttribI4sv(GLuint arg0, const GLshort * arg1) {\n    _pre_call_callback(\"glVertexAttribI4sv\", (void*)glVertexAttribI4sv, 2, arg0, arg1);\n     glad_glVertexAttribI4sv(arg0, arg1);\n    _post_call_callback(\"glVertexAttribI4sv\", (void*)glVertexAttribI4sv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIBI4SVPROC glad_debug_glVertexAttribI4sv = glad_debug_impl_glVertexAttribI4sv;\nPFNGLCOLORMASKPROC glad_glColorMask;\nvoid APIENTRY glad_debug_impl_glColorMask(GLboolean arg0, GLboolean arg1, GLboolean arg2, GLboolean arg3) {\n    _pre_call_callback(\"glColorMask\", (void*)glColorMask, 4, arg0, arg1, arg2, arg3);\n     glad_glColorMask(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glColorMask\", (void*)glColorMask, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLCOLORMASKPROC glad_debug_glColorMask = glad_debug_impl_glColorMask;\nPFNGLBINDSAMPLERPROC glad_glBindSampler;\nvoid APIENTRY glad_debug_impl_glBindSampler(GLuint arg0, GLuint arg1) {\n    _pre_call_callback(\"glBindSampler\", (void*)glBindSampler, 2, arg0, arg1);\n     glad_glBindSampler(arg0, arg1);\n    _post_call_callback(\"glBindSampler\", (void*)glBindSampler, 2, arg0, arg1);\n}\nPFNGLBINDSAMPLERPROC glad_debug_glBindSampler = glad_debug_impl_glBindSampler;\nPFNGLTEXCOORDP4UIVPROC glad_glTexCoordP4uiv;\nvoid APIENTRY glad_debug_impl_glTexCoordP4uiv(GLenum arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glTexCoordP4uiv\", (void*)glTexCoordP4uiv, 2, arg0, arg1);\n     glad_glTexCoordP4uiv(arg0, arg1);\n    _post_call_callback(\"glTexCoordP4uiv\", (void*)glTexCoordP4uiv, 2, arg0, arg1);\n}\nPFNGLTEXCOORDP4UIVPROC glad_debug_glTexCoordP4uiv = glad_debug_impl_glTexCoordP4uiv;\nPFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv;\nvoid APIENTRY glad_debug_impl_glVertexAttribI1iv(GLuint arg0, const GLint * arg1) {\n    _pre_call_callback(\"glVertexAttribI1iv\", (void*)glVertexAttribI1iv, 2, arg0, arg1);\n     glad_glVertexAttribI1iv(arg0, arg1);\n    _post_call_callback(\"glVertexAttribI1iv\", (void*)glVertexAttribI1iv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIBI1IVPROC glad_debug_glVertexAttribI1iv = glad_debug_impl_glVertexAttribI1iv;\nPFNGLLINKPROGRAMPROC glad_glLinkProgram;\nvoid APIENTRY glad_debug_impl_glLinkProgram(GLuint arg0) {\n    _pre_call_callback(\"glLinkProgram\", (void*)glLinkProgram, 1, arg0);\n     glad_glLinkProgram(arg0);\n    _post_call_callback(\"glLinkProgram\", (void*)glLinkProgram, 1, arg0);\n}\nPFNGLLINKPROGRAMPROC glad_debug_glLinkProgram = glad_debug_impl_glLinkProgram;\nPFNGLUNIFORM2IPROC glad_glUniform2i;\nvoid APIENTRY glad_debug_impl_glUniform2i(GLint arg0, GLint arg1, GLint arg2) {\n    _pre_call_callback(\"glUniform2i\", (void*)glUniform2i, 3, arg0, arg1, arg2);\n     glad_glUniform2i(arg0, arg1, arg2);\n    _post_call_callback(\"glUniform2i\", (void*)glUniform2i, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORM2IPROC glad_debug_glUniform2i = glad_debug_impl_glUniform2i;\nPFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays;\nvoid APIENTRY glad_debug_impl_glDeleteVertexArrays(GLsizei arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glDeleteVertexArrays\", (void*)glDeleteVertexArrays, 2, arg0, arg1);\n     glad_glDeleteVertexArrays(arg0, arg1);\n    _post_call_callback(\"glDeleteVertexArrays\", (void*)glDeleteVertexArrays, 2, arg0, arg1);\n}\nPFNGLDELETEVERTEXARRAYSPROC glad_debug_glDeleteVertexArrays = glad_debug_impl_glDeleteVertexArrays;\nPFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D;\nvoid APIENTRY glad_debug_impl_glCompressedTexImage3D(GLenum arg0, GLint arg1, GLenum arg2, GLsizei arg3, GLsizei arg4, GLsizei arg5, GLint arg6, GLsizei arg7, const void * arg8) {\n    _pre_call_callback(\"glCompressedTexImage3D\", (void*)glCompressedTexImage3D, 9, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n     glad_glCompressedTexImage3D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n    _post_call_callback(\"glCompressedTexImage3D\", (void*)glCompressedTexImage3D, 9, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n}\nPFNGLCOMPRESSEDTEXIMAGE3DPROC glad_debug_glCompressedTexImage3D = glad_debug_impl_glCompressedTexImage3D;\nPFNGLCLEARBUFFERFIPROC glad_glClearBufferfi;\nvoid APIENTRY glad_debug_impl_glClearBufferfi(GLenum arg0, GLint arg1, GLfloat arg2, GLint arg3) {\n    _pre_call_callback(\"glClearBufferfi\", (void*)glClearBufferfi, 4, arg0, arg1, arg2, arg3);\n     glad_glClearBufferfi(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glClearBufferfi\", (void*)glClearBufferfi, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLCLEARBUFFERFIPROC glad_debug_glClearBufferfi = glad_debug_impl_glClearBufferfi;\nPFNGLVERTEXP3UIVPROC glad_glVertexP3uiv;\nvoid APIENTRY glad_debug_impl_glVertexP3uiv(GLenum arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glVertexP3uiv\", (void*)glVertexP3uiv, 2, arg0, arg1);\n     glad_glVertexP3uiv(arg0, arg1);\n    _post_call_callback(\"glVertexP3uiv\", (void*)glVertexP3uiv, 2, arg0, arg1);\n}\nPFNGLVERTEXP3UIVPROC glad_debug_glVertexP3uiv = glad_debug_impl_glVertexP3uiv;\nPFNGLVALIDATEPROGRAMPROC glad_glValidateProgram;\nvoid APIENTRY glad_debug_impl_glValidateProgram(GLuint arg0) {\n    _pre_call_callback(\"glValidateProgram\", (void*)glValidateProgram, 1, arg0);\n     glad_glValidateProgram(arg0);\n    _post_call_callback(\"glValidateProgram\", (void*)glValidateProgram, 1, arg0);\n}\nPFNGLVALIDATEPROGRAMPROC glad_debug_glValidateProgram = glad_debug_impl_glValidateProgram;\nPFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d;\nvoid APIENTRY glad_debug_impl_glVertexAttrib3d(GLuint arg0, GLdouble arg1, GLdouble arg2, GLdouble arg3) {\n    _pre_call_callback(\"glVertexAttrib3d\", (void*)glVertexAttrib3d, 4, arg0, arg1, arg2, arg3);\n     glad_glVertexAttrib3d(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glVertexAttrib3d\", (void*)glVertexAttrib3d, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLVERTEXATTRIB3DPROC glad_debug_glVertexAttrib3d = glad_debug_impl_glVertexAttrib3d;\nPFNGLREADPIXELSPROC glad_glReadPixels;\nvoid APIENTRY glad_debug_impl_glReadPixels(GLint arg0, GLint arg1, GLsizei arg2, GLsizei arg3, GLenum arg4, GLenum arg5, void * arg6) {\n    _pre_call_callback(\"glReadPixels\", (void*)glReadPixels, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n     glad_glReadPixels(arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n    _post_call_callback(\"glReadPixels\", (void*)glReadPixels, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n}\nPFNGLREADPIXELSPROC glad_debug_glReadPixels = glad_debug_impl_glReadPixels;\nPFNGLCOLORP4UIPROC glad_glColorP4ui;\nvoid APIENTRY glad_debug_impl_glColorP4ui(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glColorP4ui\", (void*)glColorP4ui, 2, arg0, arg1);\n     glad_glColorP4ui(arg0, arg1);\n    _post_call_callback(\"glColorP4ui\", (void*)glColorP4ui, 2, arg0, arg1);\n}\nPFNGLCOLORP4UIPROC glad_debug_glColorP4ui = glad_debug_impl_glColorP4ui;\nPFNGLCLEARPROC glad_glClear;\nvoid APIENTRY glad_debug_impl_glClear(GLbitfield arg0) {\n    _pre_call_callback(\"glClear\", (void*)glClear, 1, arg0);\n     glad_glClear(arg0);\n    _post_call_callback(\"glClear\", (void*)glClear, 1, arg0);\n}\nPFNGLCLEARPROC glad_debug_glClear = glad_debug_impl_glClear;\nPFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d;\nvoid APIENTRY glad_debug_impl_glVertexAttrib1d(GLuint arg0, GLdouble arg1) {\n    _pre_call_callback(\"glVertexAttrib1d\", (void*)glVertexAttrib1d, 2, arg0, arg1);\n     glad_glVertexAttrib1d(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib1d\", (void*)glVertexAttrib1d, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB1DPROC glad_debug_glVertexAttrib1d = glad_debug_impl_glVertexAttrib1d;\nPFNGLDRAWELEMENTSPROC glad_glDrawElements;\nvoid APIENTRY glad_debug_impl_glDrawElements(GLenum arg0, GLsizei arg1, GLenum arg2, const void * arg3) {\n    _pre_call_callback(\"glDrawElements\", (void*)glDrawElements, 4, arg0, arg1, arg2, arg3);\n     glad_glDrawElements(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glDrawElements\", (void*)glDrawElements, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLDRAWELEMENTSPROC glad_debug_glDrawElements = glad_debug_impl_glDrawElements;\nPFNGLPOLYGONMODEPROC glad_glPolygonMode;\nvoid APIENTRY glad_debug_impl_glPolygonMode(GLenum arg0, GLenum arg1) {\n    _pre_call_callback(\"glPolygonMode\", (void*)glPolygonMode, 2, arg0, arg1);\n     glad_glPolygonMode(arg0, arg1);\n    _post_call_callback(\"glPolygonMode\", (void*)glPolygonMode, 2, arg0, arg1);\n}\nPFNGLPOLYGONMODEPROC glad_debug_glPolygonMode = glad_debug_impl_glPolygonMode;\nPFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4Niv(GLuint arg0, const GLint * arg1) {\n    _pre_call_callback(\"glVertexAttrib4Niv\", (void*)glVertexAttrib4Niv, 2, arg0, arg1);\n     glad_glVertexAttrib4Niv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib4Niv\", (void*)glVertexAttrib4Niv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB4NIVPROC glad_debug_glVertexAttrib4Niv = glad_debug_impl_glVertexAttrib4Niv;\nPFNGLDELETEBUFFERSPROC glad_glDeleteBuffers;\nvoid APIENTRY glad_debug_impl_glDeleteBuffers(GLsizei arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glDeleteBuffers\", (void*)glDeleteBuffers, 2, arg0, arg1);\n     glad_glDeleteBuffers(arg0, arg1);\n    _post_call_callback(\"glDeleteBuffers\", (void*)glDeleteBuffers, 2, arg0, arg1);\n}\nPFNGLDELETEBUFFERSPROC glad_debug_glDeleteBuffers = glad_debug_impl_glDeleteBuffers;\nPFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex;\nGLuint APIENTRY glad_debug_impl_glGetUniformBlockIndex(GLuint arg0, const GLchar * arg1) {\n    GLuint ret;\n    _pre_call_callback(\"glGetUniformBlockIndex\", (void*)glGetUniformBlockIndex, 2, arg0, arg1);\n    ret =  glad_glGetUniformBlockIndex(arg0, arg1);\n    _post_call_callback(\"glGetUniformBlockIndex\", (void*)glGetUniformBlockIndex, 2, arg0, arg1);\n    return ret;\n}\nPFNGLGETUNIFORMBLOCKINDEXPROC glad_debug_glGetUniformBlockIndex = glad_debug_impl_glGetUniformBlockIndex;\nPFNGLPIXELSTOREFPROC glad_glPixelStoref;\nvoid APIENTRY glad_debug_impl_glPixelStoref(GLenum arg0, GLfloat arg1) {\n    _pre_call_callback(\"glPixelStoref\", (void*)glPixelStoref, 2, arg0, arg1);\n     glad_glPixelStoref(arg0, arg1);\n    _post_call_callback(\"glPixelStoref\", (void*)glPixelStoref, 2, arg0, arg1);\n}\nPFNGLPIXELSTOREFPROC glad_debug_glPixelStoref = glad_debug_impl_glPixelStoref;\nPFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced;\nvoid APIENTRY glad_debug_impl_glDrawElementsInstanced(GLenum arg0, GLsizei arg1, GLenum arg2, const void * arg3, GLsizei arg4) {\n    _pre_call_callback(\"glDrawElementsInstanced\", (void*)glDrawElementsInstanced, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glDrawElementsInstanced(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glDrawElementsInstanced\", (void*)glDrawElementsInstanced, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLDRAWELEMENTSINSTANCEDPROC glad_debug_glDrawElementsInstanced = glad_debug_impl_glDrawElementsInstanced;\nPFNGLCREATEPROGRAMPROC glad_glCreateProgram;\nGLuint APIENTRY glad_debug_impl_glCreateProgram(void) {\n    GLuint ret;\n    _pre_call_callback(\"glCreateProgram\", (void*)glCreateProgram, 0);\n    ret =  glad_glCreateProgram();\n    _post_call_callback(\"glCreateProgram\", (void*)glCreateProgram, 0);\n    return ret;\n}\nPFNGLCREATEPROGRAMPROC glad_debug_glCreateProgram = glad_debug_impl_glCreateProgram;\nPFNGLUSEPROGRAMPROC glad_glUseProgram;\nvoid APIENTRY glad_debug_impl_glUseProgram(GLuint arg0) {\n    _pre_call_callback(\"glUseProgram\", (void*)glUseProgram, 1, arg0);\n     glad_glUseProgram(arg0);\n    _post_call_callback(\"glUseProgram\", (void*)glUseProgram, 1, arg0);\n}\nPFNGLUSEPROGRAMPROC glad_debug_glUseProgram = glad_debug_impl_glUseProgram;\nPFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s;\nvoid APIENTRY glad_debug_impl_glVertexAttrib3s(GLuint arg0, GLshort arg1, GLshort arg2, GLshort arg3) {\n    _pre_call_callback(\"glVertexAttrib3s\", (void*)glVertexAttrib3s, 4, arg0, arg1, arg2, arg3);\n     glad_glVertexAttrib3s(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glVertexAttrib3s\", (void*)glVertexAttrib3s, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLVERTEXATTRIB3SPROC glad_debug_glVertexAttrib3s = glad_debug_impl_glVertexAttrib3s;\nPFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4fv(GLuint arg0, const GLfloat * arg1) {\n    _pre_call_callback(\"glVertexAttrib4fv\", (void*)glVertexAttrib4fv, 2, arg0, arg1);\n     glad_glVertexAttrib4fv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib4fv\", (void*)glVertexAttrib4fv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB4FVPROC glad_debug_glVertexAttrib4fv = glad_debug_impl_glVertexAttrib4fv;\nPFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4s(GLuint arg0, GLshort arg1, GLshort arg2, GLshort arg3, GLshort arg4) {\n    _pre_call_callback(\"glVertexAttrib4s\", (void*)glVertexAttrib4s, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glVertexAttrib4s(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glVertexAttrib4s\", (void*)glVertexAttrib4s, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLVERTEXATTRIB4SPROC glad_debug_glVertexAttrib4s = glad_debug_impl_glVertexAttrib4s;\nPFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v;\nvoid APIENTRY glad_debug_impl_glGetQueryObjecti64v(GLuint arg0, GLenum arg1, GLint64 * arg2) {\n    _pre_call_callback(\"glGetQueryObjecti64v\", (void*)glGetQueryObjecti64v, 3, arg0, arg1, arg2);\n     glad_glGetQueryObjecti64v(arg0, arg1, arg2);\n    _post_call_callback(\"glGetQueryObjecti64v\", (void*)glGetQueryObjecti64v, 3, arg0, arg1, arg2);\n}\nPFNGLGETQUERYOBJECTI64VPROC glad_debug_glGetQueryObjecti64v = glad_debug_impl_glGetQueryObjecti64v;\nPFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage;\nvoid APIENTRY glad_debug_impl_glSampleCoverage(GLfloat arg0, GLboolean arg1) {\n    _pre_call_callback(\"glSampleCoverage\", (void*)glSampleCoverage, 2, arg0, arg1);\n     glad_glSampleCoverage(arg0, arg1);\n    _post_call_callback(\"glSampleCoverage\", (void*)glSampleCoverage, 2, arg0, arg1);\n}\nPFNGLSAMPLECOVERAGEPROC glad_debug_glSampleCoverage = glad_debug_impl_glSampleCoverage;\nPFNGLENDQUERYPROC glad_glEndQuery;\nvoid APIENTRY glad_debug_impl_glEndQuery(GLenum arg0) {\n    _pre_call_callback(\"glEndQuery\", (void*)glEndQuery, 1, arg0);\n     glad_glEndQuery(arg0);\n    _post_call_callback(\"glEndQuery\", (void*)glEndQuery, 1, arg0);\n}\nPFNGLENDQUERYPROC glad_debug_glEndQuery = glad_debug_impl_glEndQuery;\nPFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv;\nvoid APIENTRY glad_debug_impl_glGetMultisamplefv(GLenum arg0, GLuint arg1, GLfloat * arg2) {\n    _pre_call_callback(\"glGetMultisamplefv\", (void*)glGetMultisamplefv, 3, arg0, arg1, arg2);\n     glad_glGetMultisamplefv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetMultisamplefv\", (void*)glGetMultisamplefv, 3, arg0, arg1, arg2);\n}\nPFNGLGETMULTISAMPLEFVPROC glad_debug_glGetMultisamplefv = glad_debug_impl_glGetMultisamplefv;\nPFNGLTEXCOORDP1UIVPROC glad_glTexCoordP1uiv;\nvoid APIENTRY glad_debug_impl_glTexCoordP1uiv(GLenum arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glTexCoordP1uiv\", (void*)glTexCoordP1uiv, 2, arg0, arg1);\n     glad_glTexCoordP1uiv(arg0, arg1);\n    _post_call_callback(\"glTexCoordP1uiv\", (void*)glTexCoordP1uiv, 2, arg0, arg1);\n}\nPFNGLTEXCOORDP1UIVPROC glad_debug_glTexCoordP1uiv = glad_debug_impl_glTexCoordP1uiv;\nPFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D;\nvoid APIENTRY glad_debug_impl_glCompressedTexSubImage1D(GLenum arg0, GLint arg1, GLint arg2, GLsizei arg3, GLenum arg4, GLsizei arg5, const void * arg6) {\n    _pre_call_callback(\"glCompressedTexSubImage1D\", (void*)glCompressedTexSubImage1D, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n     glad_glCompressedTexSubImage1D(arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n    _post_call_callback(\"glCompressedTexSubImage1D\", (void*)glCompressedTexSubImage1D, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n}\nPFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_debug_glCompressedTexSubImage1D = glad_debug_impl_glCompressedTexSubImage1D;\nPFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4bv(GLuint arg0, const GLbyte * arg1) {\n    _pre_call_callback(\"glVertexAttrib4bv\", (void*)glVertexAttrib4bv, 2, arg0, arg1);\n     glad_glVertexAttrib4bv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib4bv\", (void*)glVertexAttrib4bv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB4BVPROC glad_debug_glVertexAttrib4bv = glad_debug_impl_glVertexAttrib4bv;\nPFNGLBEGINQUERYPROC glad_glBeginQuery;\nvoid APIENTRY glad_debug_impl_glBeginQuery(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glBeginQuery\", (void*)glBeginQuery, 2, arg0, arg1);\n     glad_glBeginQuery(arg0, arg1);\n    _post_call_callback(\"glBeginQuery\", (void*)glBeginQuery, 2, arg0, arg1);\n}\nPFNGLBEGINQUERYPROC glad_debug_glBeginQuery = glad_debug_impl_glBeginQuery;\nPFNGLUNIFORM3UIPROC glad_glUniform3ui;\nvoid APIENTRY glad_debug_impl_glUniform3ui(GLint arg0, GLuint arg1, GLuint arg2, GLuint arg3) {\n    _pre_call_callback(\"glUniform3ui\", (void*)glUniform3ui, 4, arg0, arg1, arg2, arg3);\n     glad_glUniform3ui(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glUniform3ui\", (void*)glUniform3ui, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLUNIFORM3UIPROC glad_debug_glUniform3ui = glad_debug_impl_glUniform3ui;\nPFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders;\nvoid APIENTRY glad_debug_impl_glGetAttachedShaders(GLuint arg0, GLsizei arg1, GLsizei * arg2, GLuint * arg3) {\n    _pre_call_callback(\"glGetAttachedShaders\", (void*)glGetAttachedShaders, 4, arg0, arg1, arg2, arg3);\n     glad_glGetAttachedShaders(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetAttachedShaders\", (void*)glGetAttachedShaders, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETATTACHEDSHADERSPROC glad_debug_glGetAttachedShaders = glad_debug_impl_glGetAttachedShaders;\nPFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync;\nGLenum APIENTRY glad_debug_impl_glClientWaitSync(GLsync arg0, GLbitfield arg1, GLuint64 arg2) {\n    GLenum ret;\n    _pre_call_callback(\"glClientWaitSync\", (void*)glClientWaitSync, 3, arg0, arg1, arg2);\n    ret =  glad_glClientWaitSync(arg0, arg1, arg2);\n    _post_call_callback(\"glClientWaitSync\", (void*)glClientWaitSync, 3, arg0, arg1, arg2);\n    return ret;\n}\nPFNGLCLIENTWAITSYNCPROC glad_debug_glClientWaitSync = glad_debug_impl_glClientWaitSync;\nPFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv;\nvoid APIENTRY glad_debug_impl_glGetVertexAttribIuiv(GLuint arg0, GLenum arg1, GLuint * arg2) {\n    _pre_call_callback(\"glGetVertexAttribIuiv\", (void*)glGetVertexAttribIuiv, 3, arg0, arg1, arg2);\n     glad_glGetVertexAttribIuiv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetVertexAttribIuiv\", (void*)glGetVertexAttribIuiv, 3, arg0, arg1, arg2);\n}\nPFNGLGETVERTEXATTRIBIUIVPROC glad_debug_glGetVertexAttribIuiv = glad_debug_impl_glGetVertexAttribIuiv;\nPFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus;\nGLenum APIENTRY glad_debug_impl_glCheckFramebufferStatus(GLenum arg0) {\n    GLenum ret;\n    _pre_call_callback(\"glCheckFramebufferStatus\", (void*)glCheckFramebufferStatus, 1, arg0);\n    ret =  glad_glCheckFramebufferStatus(arg0);\n    _post_call_callback(\"glCheckFramebufferStatus\", (void*)glCheckFramebufferStatus, 1, arg0);\n    return ret;\n}\nPFNGLCHECKFRAMEBUFFERSTATUSPROC glad_debug_glCheckFramebufferStatus = glad_debug_impl_glCheckFramebufferStatus;\nPFNGLPOINTSIZEPROC glad_glPointSize;\nvoid APIENTRY glad_debug_impl_glPointSize(GLfloat arg0) {\n    _pre_call_callback(\"glPointSize\", (void*)glPointSize, 1, arg0);\n     glad_glPointSize(arg0);\n    _post_call_callback(\"glPointSize\", (void*)glPointSize, 1, arg0);\n}\nPFNGLPOINTSIZEPROC glad_debug_glPointSize = glad_debug_impl_glPointSize;\nPFNGLTEXPARAMETERIPROC glad_glTexParameteri;\nvoid APIENTRY glad_debug_impl_glTexParameteri(GLenum arg0, GLenum arg1, GLint arg2) {\n    _pre_call_callback(\"glTexParameteri\", (void*)glTexParameteri, 3, arg0, arg1, arg2);\n     glad_glTexParameteri(arg0, arg1, arg2);\n    _post_call_callback(\"glTexParameteri\", (void*)glTexParameteri, 3, arg0, arg1, arg2);\n}\nPFNGLTEXPARAMETERIPROC glad_debug_glTexParameteri = glad_debug_impl_glTexParameteri;\nPFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib1sv(GLuint arg0, const GLshort * arg1) {\n    _pre_call_callback(\"glVertexAttrib1sv\", (void*)glVertexAttrib1sv, 2, arg0, arg1);\n     glad_glVertexAttrib1sv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib1sv\", (void*)glVertexAttrib1sv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB1SVPROC glad_debug_glVertexAttrib1sv = glad_debug_impl_glVertexAttrib1sv;\nPFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f;\nvoid APIENTRY glad_debug_impl_glVertexAttrib1f(GLuint arg0, GLfloat arg1) {\n    _pre_call_callback(\"glVertexAttrib1f\", (void*)glVertexAttrib1f, 2, arg0, arg1);\n     glad_glVertexAttrib1f(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib1f\", (void*)glVertexAttrib1f, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB1FPROC glad_debug_glVertexAttrib1f = glad_debug_impl_glVertexAttrib1f;\nPFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays;\nvoid APIENTRY glad_debug_impl_glGenVertexArrays(GLsizei arg0, GLuint * arg1) {\n    _pre_call_callback(\"glGenVertexArrays\", (void*)glGenVertexArrays, 2, arg0, arg1);\n     glad_glGenVertexArrays(arg0, arg1);\n    _post_call_callback(\"glGenVertexArrays\", (void*)glGenVertexArrays, 2, arg0, arg1);\n}\nPFNGLGENVERTEXARRAYSPROC glad_debug_glGenVertexArrays = glad_debug_impl_glGenVertexArrays;\nPFNGLUNIFORM2UIVPROC glad_glUniform2uiv;\nvoid APIENTRY glad_debug_impl_glUniform2uiv(GLint arg0, GLsizei arg1, const GLuint * arg2) {\n    _pre_call_callback(\"glUniform2uiv\", (void*)glUniform2uiv, 3, arg0, arg1, arg2);\n     glad_glUniform2uiv(arg0, arg1, arg2);\n    _post_call_callback(\"glUniform2uiv\", (void*)glUniform2uiv, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORM2UIVPROC glad_debug_glUniform2uiv = glad_debug_impl_glUniform2uiv;\nPFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements;\nvoid APIENTRY glad_debug_impl_glMultiDrawElements(GLenum arg0, const GLsizei * arg1, GLenum arg2, const void *const* arg3, GLsizei arg4) {\n    _pre_call_callback(\"glMultiDrawElements\", (void*)glMultiDrawElements, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glMultiDrawElements(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glMultiDrawElements\", (void*)glMultiDrawElements, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLMULTIDRAWELEMENTSPROC glad_debug_glMultiDrawElements = glad_debug_impl_glMultiDrawElements;\nPFNGLUNIFORM1FPROC glad_glUniform1f;\nvoid APIENTRY glad_debug_impl_glUniform1f(GLint arg0, GLfloat arg1) {\n    _pre_call_callback(\"glUniform1f\", (void*)glUniform1f, 2, arg0, arg1);\n     glad_glUniform1f(arg0, arg1);\n    _post_call_callback(\"glUniform1f\", (void*)glUniform1f, 2, arg0, arg1);\n}\nPFNGLUNIFORM1FPROC glad_debug_glUniform1f = glad_debug_impl_glUniform1f;\nPFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv;\nvoid APIENTRY glad_debug_impl_glGetVertexAttribiv(GLuint arg0, GLenum arg1, GLint * arg2) {\n    _pre_call_callback(\"glGetVertexAttribiv\", (void*)glGetVertexAttribiv, 3, arg0, arg1, arg2);\n     glad_glGetVertexAttribiv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetVertexAttribiv\", (void*)glGetVertexAttribiv, 3, arg0, arg1, arg2);\n}\nPFNGLGETVERTEXATTRIBIVPROC glad_debug_glGetVertexAttribiv = glad_debug_impl_glGetVertexAttribiv;\nPFNGLSTENCILMASKPROC glad_glStencilMask;\nvoid APIENTRY glad_debug_impl_glStencilMask(GLuint arg0) {\n    _pre_call_callback(\"glStencilMask\", (void*)glStencilMask, 1, arg0);\n     glad_glStencilMask(arg0);\n    _post_call_callback(\"glStencilMask\", (void*)glStencilMask, 1, arg0);\n}\nPFNGLSTENCILMASKPROC glad_debug_glStencilMask = glad_debug_impl_glStencilMask;\nPFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate;\nvoid APIENTRY glad_debug_impl_glStencilMaskSeparate(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glStencilMaskSeparate\", (void*)glStencilMaskSeparate, 2, arg0, arg1);\n     glad_glStencilMaskSeparate(arg0, arg1);\n    _post_call_callback(\"glStencilMaskSeparate\", (void*)glStencilMaskSeparate, 2, arg0, arg1);\n}\nPFNGLSTENCILMASKSEPARATEPROC glad_debug_glStencilMaskSeparate = glad_debug_impl_glStencilMaskSeparate;\nPFNGLENABLEPROC glad_glEnable;\nvoid APIENTRY glad_debug_impl_glEnable(GLenum arg0) {\n    _pre_call_callback(\"glEnable\", (void*)glEnable, 1, arg0);\n     glad_glEnable(arg0);\n    _post_call_callback(\"glEnable\", (void*)glEnable, 1, arg0);\n}\nPFNGLENABLEPROC glad_debug_glEnable = glad_debug_impl_glEnable;\nPFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f;\nvoid APIENTRY glad_debug_impl_glVertexAttrib2f(GLuint arg0, GLfloat arg1, GLfloat arg2) {\n    _pre_call_callback(\"glVertexAttrib2f\", (void*)glVertexAttrib2f, 3, arg0, arg1, arg2);\n     glad_glVertexAttrib2f(arg0, arg1, arg2);\n    _post_call_callback(\"glVertexAttrib2f\", (void*)glVertexAttrib2f, 3, arg0, arg1, arg2);\n}\nPFNGLVERTEXATTRIB2FPROC glad_debug_glVertexAttrib2f = glad_debug_impl_glVertexAttrib2f;\nPFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui;\nvoid APIENTRY glad_debug_impl_glVertexAttribP4ui(GLuint arg0, GLenum arg1, GLboolean arg2, GLuint arg3) {\n    _pre_call_callback(\"glVertexAttribP4ui\", (void*)glVertexAttribP4ui, 4, arg0, arg1, arg2, arg3);\n     glad_glVertexAttribP4ui(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glVertexAttribP4ui\", (void*)glVertexAttribP4ui, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLVERTEXATTRIBP4UIPROC glad_debug_glVertexAttribP4ui = glad_debug_impl_glVertexAttribP4ui;\nPFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv;\nvoid APIENTRY glad_debug_impl_glGetTexParameterIiv(GLenum arg0, GLenum arg1, GLint * arg2) {\n    _pre_call_callback(\"glGetTexParameterIiv\", (void*)glGetTexParameterIiv, 3, arg0, arg1, arg2);\n     glad_glGetTexParameterIiv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetTexParameterIiv\", (void*)glGetTexParameterIiv, 3, arg0, arg1, arg2);\n}\nPFNGLGETTEXPARAMETERIIVPROC glad_debug_glGetTexParameterIiv = glad_debug_impl_glGetTexParameterIiv;\nPFNGLCOLORP3UIPROC glad_glColorP3ui;\nvoid APIENTRY glad_debug_impl_glColorP3ui(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glColorP3ui\", (void*)glColorP3ui, 2, arg0, arg1);\n     glad_glColorP3ui(arg0, arg1);\n    _post_call_callback(\"glColorP3ui\", (void*)glColorP3ui, 2, arg0, arg1);\n}\nPFNGLCOLORP3UIPROC glad_debug_glColorP3ui = glad_debug_impl_glColorP3ui;\nPFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D;\nvoid APIENTRY glad_debug_impl_glCopyTexImage2D(GLenum arg0, GLint arg1, GLenum arg2, GLint arg3, GLint arg4, GLsizei arg5, GLsizei arg6, GLint arg7) {\n    _pre_call_callback(\"glCopyTexImage2D\", (void*)glCopyTexImage2D, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n     glad_glCopyTexImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n    _post_call_callback(\"glCopyTexImage2D\", (void*)glCopyTexImage2D, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n}\nPFNGLCOPYTEXIMAGE2DPROC glad_debug_glCopyTexImage2D = glad_debug_impl_glCopyTexImage2D;\nPFNGLMAPBUFFERPROC glad_glMapBuffer;\nvoid * APIENTRY glad_debug_impl_glMapBuffer(GLenum arg0, GLenum arg1) {\n    void * ret;\n    _pre_call_callback(\"glMapBuffer\", (void*)glMapBuffer, 2, arg0, arg1);\n    ret =  glad_glMapBuffer(arg0, arg1);\n    _post_call_callback(\"glMapBuffer\", (void*)glMapBuffer, 2, arg0, arg1);\n    return ret;\n}\nPFNGLMAPBUFFERPROC glad_debug_glMapBuffer = glad_debug_impl_glMapBuffer;\nPFNGLUNIFORM1UIPROC glad_glUniform1ui;\nvoid APIENTRY glad_debug_impl_glUniform1ui(GLint arg0, GLuint arg1) {\n    _pre_call_callback(\"glUniform1ui\", (void*)glUniform1ui, 2, arg0, arg1);\n     glad_glUniform1ui(arg0, arg1);\n    _post_call_callback(\"glUniform1ui\", (void*)glUniform1ui, 2, arg0, arg1);\n}\nPFNGLUNIFORM1UIPROC glad_debug_glUniform1ui = glad_debug_impl_glUniform1ui;\nPFNGLREADBUFFERPROC glad_glReadBuffer;\nvoid APIENTRY glad_debug_impl_glReadBuffer(GLenum arg0) {\n    _pre_call_callback(\"glReadBuffer\", (void*)glReadBuffer, 1, arg0);\n     glad_glReadBuffer(arg0);\n    _post_call_callback(\"glReadBuffer\", (void*)glReadBuffer, 1, arg0);\n}\nPFNGLREADBUFFERPROC glad_debug_glReadBuffer = glad_debug_impl_glReadBuffer;\nPFNGLDRAWBUFFERSPROC glad_glDrawBuffers;\nvoid APIENTRY glad_debug_impl_glDrawBuffers(GLsizei arg0, const GLenum * arg1) {\n    _pre_call_callback(\"glDrawBuffers\", (void*)glDrawBuffers, 2, arg0, arg1);\n     glad_glDrawBuffers(arg0, arg1);\n    _post_call_callback(\"glDrawBuffers\", (void*)glDrawBuffers, 2, arg0, arg1);\n}\nPFNGLDRAWBUFFERSPROC glad_debug_glDrawBuffers = glad_debug_impl_glDrawBuffers;\nPFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture;\nvoid APIENTRY glad_debug_impl_glFramebufferTexture(GLenum arg0, GLenum arg1, GLuint arg2, GLint arg3) {\n    _pre_call_callback(\"glFramebufferTexture\", (void*)glFramebufferTexture, 4, arg0, arg1, arg2, arg3);\n     glad_glFramebufferTexture(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glFramebufferTexture\", (void*)glFramebufferTexture, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLFRAMEBUFFERTEXTUREPROC glad_debug_glFramebufferTexture = glad_debug_impl_glFramebufferTexture;\nPFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv;\nvoid APIENTRY glad_debug_impl_glVertexAttribI4bv(GLuint arg0, const GLbyte * arg1) {\n    _pre_call_callback(\"glVertexAttribI4bv\", (void*)glVertexAttribI4bv, 2, arg0, arg1);\n     glad_glVertexAttribI4bv(arg0, arg1);\n    _post_call_callback(\"glVertexAttribI4bv\", (void*)glVertexAttribI4bv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIBI4BVPROC glad_debug_glVertexAttribI4bv = glad_debug_impl_glVertexAttribI4bv;\nPFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv;\nvoid APIENTRY glad_debug_impl_glVertexAttribI4iv(GLuint arg0, const GLint * arg1) {\n    _pre_call_callback(\"glVertexAttribI4iv\", (void*)glVertexAttribI4iv, 2, arg0, arg1);\n     glad_glVertexAttribI4iv(arg0, arg1);\n    _post_call_callback(\"glVertexAttribI4iv\", (void*)glVertexAttribI4iv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIBI4IVPROC glad_debug_glVertexAttribI4iv = glad_debug_impl_glVertexAttribI4iv;\nPFNGLGETSTRINGIPROC glad_glGetStringi;\nconst GLubyte * APIENTRY glad_debug_impl_glGetStringi(GLenum arg0, GLuint arg1) {\n    const GLubyte * ret;\n    _pre_call_callback(\"glGetStringi\", (void*)glGetStringi, 2, arg0, arg1);\n    ret =  glad_glGetStringi(arg0, arg1);\n    _post_call_callback(\"glGetStringi\", (void*)glGetStringi, 2, arg0, arg1);\n    return ret;\n}\nPFNGLGETSTRINGIPROC glad_debug_glGetStringi = glad_debug_impl_glGetStringi;\nPFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv;\nvoid APIENTRY glad_debug_impl_glGetBufferPointerv(GLenum arg0, GLenum arg1, void ** arg2) {\n    _pre_call_callback(\"glGetBufferPointerv\", (void*)glGetBufferPointerv, 3, arg0, arg1, arg2);\n     glad_glGetBufferPointerv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetBufferPointerv\", (void*)glGetBufferPointerv, 3, arg0, arg1, arg2);\n}\nPFNGLGETBUFFERPOINTERVPROC glad_debug_glGetBufferPointerv = glad_debug_impl_glGetBufferPointerv;\nPFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv;\nvoid APIENTRY glad_debug_impl_glGetUniformuiv(GLuint arg0, GLint arg1, GLuint * arg2) {\n    _pre_call_callback(\"glGetUniformuiv\", (void*)glGetUniformuiv, 3, arg0, arg1, arg2);\n     glad_glGetUniformuiv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetUniformuiv\", (void*)glGetUniformuiv, 3, arg0, arg1, arg2);\n}\nPFNGLGETUNIFORMUIVPROC glad_debug_glGetUniformuiv = glad_debug_impl_glGetUniformuiv;\nPFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib3fv(GLuint arg0, const GLfloat * arg1) {\n    _pre_call_callback(\"glVertexAttrib3fv\", (void*)glVertexAttrib3fv, 2, arg0, arg1);\n     glad_glVertexAttrib3fv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib3fv\", (void*)glVertexAttrib3fv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB3FVPROC glad_debug_glVertexAttrib3fv = glad_debug_impl_glVertexAttrib3fv;\nPFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui;\nvoid APIENTRY glad_debug_impl_glVertexAttribI4ui(GLuint arg0, GLuint arg1, GLuint arg2, GLuint arg3, GLuint arg4) {\n    _pre_call_callback(\"glVertexAttribI4ui\", (void*)glVertexAttribI4ui, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glVertexAttribI4ui(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glVertexAttribI4ui\", (void*)glVertexAttribI4ui, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLVERTEXATTRIBI4UIPROC glad_debug_glVertexAttribI4ui = glad_debug_impl_glVertexAttribI4ui;\nPFNGLCLEARBUFFERFVPROC glad_glClearBufferfv;\nvoid APIENTRY glad_debug_impl_glClearBufferfv(GLenum arg0, GLint arg1, const GLfloat * arg2) {\n    _pre_call_callback(\"glClearBufferfv\", (void*)glClearBufferfv, 3, arg0, arg1, arg2);\n     glad_glClearBufferfv(arg0, arg1, arg2);\n    _post_call_callback(\"glClearBufferfv\", (void*)glClearBufferfv, 3, arg0, arg1, arg2);\n}\nPFNGLCLEARBUFFERFVPROC glad_debug_glClearBufferfv = glad_debug_impl_glClearBufferfv;\nPFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer;\nvoid APIENTRY glad_debug_impl_glFramebufferTextureLayer(GLenum arg0, GLenum arg1, GLuint arg2, GLint arg3, GLint arg4) {\n    _pre_call_callback(\"glFramebufferTextureLayer\", (void*)glFramebufferTextureLayer, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glFramebufferTextureLayer(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glFramebufferTextureLayer\", (void*)glFramebufferTextureLayer, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLFRAMEBUFFERTEXTURELAYERPROC glad_debug_glFramebufferTextureLayer = glad_debug_impl_glFramebufferTextureLayer;\nPFNGLMULTITEXCOORDP2UIPROC glad_glMultiTexCoordP2ui;\nvoid APIENTRY glad_debug_impl_glMultiTexCoordP2ui(GLenum arg0, GLenum arg1, GLuint arg2) {\n    _pre_call_callback(\"glMultiTexCoordP2ui\", (void*)glMultiTexCoordP2ui, 3, arg0, arg1, arg2);\n     glad_glMultiTexCoordP2ui(arg0, arg1, arg2);\n    _post_call_callback(\"glMultiTexCoordP2ui\", (void*)glMultiTexCoordP2ui, 3, arg0, arg1, arg2);\n}\nPFNGLMULTITEXCOORDP2UIPROC glad_debug_glMultiTexCoordP2ui = glad_debug_impl_glMultiTexCoordP2ui;\nPFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D;\nvoid APIENTRY glad_debug_impl_glCopyTexSubImage2D(GLenum arg0, GLint arg1, GLint arg2, GLint arg3, GLint arg4, GLint arg5, GLsizei arg6, GLsizei arg7) {\n    _pre_call_callback(\"glCopyTexSubImage2D\", (void*)glCopyTexSubImage2D, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n     glad_glCopyTexSubImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n    _post_call_callback(\"glCopyTexSubImage2D\", (void*)glCopyTexSubImage2D, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n}\nPFNGLCOPYTEXSUBIMAGE2DPROC glad_debug_glCopyTexSubImage2D = glad_debug_impl_glCopyTexSubImage2D;\nPFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib2sv(GLuint arg0, const GLshort * arg1) {\n    _pre_call_callback(\"glVertexAttrib2sv\", (void*)glVertexAttrib2sv, 2, arg0, arg1);\n     glad_glVertexAttrib2sv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib2sv\", (void*)glVertexAttrib2sv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB2SVPROC glad_debug_glVertexAttrib2sv = glad_debug_impl_glVertexAttrib2sv;\nPFNGLISQUERYPROC glad_glIsQuery;\nGLboolean APIENTRY glad_debug_impl_glIsQuery(GLuint arg0) {\n    GLboolean ret;\n    _pre_call_callback(\"glIsQuery\", (void*)glIsQuery, 1, arg0);\n    ret =  glad_glIsQuery(arg0);\n    _post_call_callback(\"glIsQuery\", (void*)glIsQuery, 1, arg0);\n    return ret;\n}\nPFNGLISQUERYPROC glad_debug_glIsQuery = glad_debug_impl_glIsQuery;\nPFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName;\nvoid APIENTRY glad_debug_impl_glGetActiveUniformBlockName(GLuint arg0, GLuint arg1, GLsizei arg2, GLsizei * arg3, GLchar * arg4) {\n    _pre_call_callback(\"glGetActiveUniformBlockName\", (void*)glGetActiveUniformBlockName, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glGetActiveUniformBlockName(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glGetActiveUniformBlockName\", (void*)glGetActiveUniformBlockName, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_debug_glGetActiveUniformBlockName = glad_debug_impl_glGetActiveUniformBlockName;\nPFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv;\nvoid APIENTRY glad_debug_impl_glGetTexLevelParameteriv(GLenum arg0, GLint arg1, GLenum arg2, GLint * arg3) {\n    _pre_call_callback(\"glGetTexLevelParameteriv\", (void*)glGetTexLevelParameteriv, 4, arg0, arg1, arg2, arg3);\n     glad_glGetTexLevelParameteriv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetTexLevelParameteriv\", (void*)glGetTexLevelParameteriv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETTEXLEVELPARAMETERIVPROC glad_debug_glGetTexLevelParameteriv = glad_debug_impl_glGetTexLevelParameteriv;\nPFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v;\nvoid APIENTRY glad_debug_impl_glGetInteger64i_v(GLenum arg0, GLuint arg1, GLint64 * arg2) {\n    _pre_call_callback(\"glGetInteger64i_v\", (void*)glGetInteger64i_v, 3, arg0, arg1, arg2);\n     glad_glGetInteger64i_v(arg0, arg1, arg2);\n    _post_call_callback(\"glGetInteger64i_v\", (void*)glGetInteger64i_v, 3, arg0, arg1, arg2);\n}\nPFNGLGETINTEGER64I_VPROC glad_debug_glGetInteger64i_v = glad_debug_impl_glGetInteger64i_v;\nPFNGLGETSYNCIVPROC glad_glGetSynciv;\nvoid APIENTRY glad_debug_impl_glGetSynciv(GLsync arg0, GLenum arg1, GLsizei arg2, GLsizei * arg3, GLint * arg4) {\n    _pre_call_callback(\"glGetSynciv\", (void*)glGetSynciv, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glGetSynciv(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glGetSynciv\", (void*)glGetSynciv, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLGETSYNCIVPROC glad_debug_glGetSynciv = glad_debug_impl_glGetSynciv;\nPFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv;\nvoid APIENTRY glad_debug_impl_glGetTexParameteriv(GLenum arg0, GLenum arg1, GLint * arg2) {\n    _pre_call_callback(\"glGetTexParameteriv\", (void*)glGetTexParameteriv, 3, arg0, arg1, arg2);\n     glad_glGetTexParameteriv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetTexParameteriv\", (void*)glGetTexParameteriv, 3, arg0, arg1, arg2);\n}\nPFNGLGETTEXPARAMETERIVPROC glad_debug_glGetTexParameteriv = glad_debug_impl_glGetTexParameteriv;\nPFNGLMULTITEXCOORDP3UIVPROC glad_glMultiTexCoordP3uiv;\nvoid APIENTRY glad_debug_impl_glMultiTexCoordP3uiv(GLenum arg0, GLenum arg1, const GLuint * arg2) {\n    _pre_call_callback(\"glMultiTexCoordP3uiv\", (void*)glMultiTexCoordP3uiv, 3, arg0, arg1, arg2);\n     glad_glMultiTexCoordP3uiv(arg0, arg1, arg2);\n    _post_call_callback(\"glMultiTexCoordP3uiv\", (void*)glMultiTexCoordP3uiv, 3, arg0, arg1, arg2);\n}\nPFNGLMULTITEXCOORDP3UIVPROC glad_debug_glMultiTexCoordP3uiv = glad_debug_impl_glMultiTexCoordP3uiv;\nPFNGLNORMALP3UIVPROC glad_glNormalP3uiv;\nvoid APIENTRY glad_debug_impl_glNormalP3uiv(GLenum arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glNormalP3uiv\", (void*)glNormalP3uiv, 2, arg0, arg1);\n     glad_glNormalP3uiv(arg0, arg1);\n    _post_call_callback(\"glNormalP3uiv\", (void*)glNormalP3uiv, 2, arg0, arg1);\n}\nPFNGLNORMALP3UIVPROC glad_debug_glNormalP3uiv = glad_debug_impl_glNormalP3uiv;\nPFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv;\nvoid APIENTRY glad_debug_impl_glGetActiveUniformsiv(GLuint arg0, GLsizei arg1, const GLuint * arg2, GLenum arg3, GLint * arg4) {\n    _pre_call_callback(\"glGetActiveUniformsiv\", (void*)glGetActiveUniformsiv, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glGetActiveUniformsiv(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glGetActiveUniformsiv\", (void*)glGetActiveUniformsiv, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLGETACTIVEUNIFORMSIVPROC glad_debug_glGetActiveUniformsiv = glad_debug_impl_glGetActiveUniformsiv;\nPFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex;\nvoid APIENTRY glad_debug_impl_glPrimitiveRestartIndex(GLuint arg0) {\n    _pre_call_callback(\"glPrimitiveRestartIndex\", (void*)glPrimitiveRestartIndex, 1, arg0);\n     glad_glPrimitiveRestartIndex(arg0);\n    _post_call_callback(\"glPrimitiveRestartIndex\", (void*)glPrimitiveRestartIndex, 1, arg0);\n}\nPFNGLPRIMITIVERESTARTINDEXPROC glad_debug_glPrimitiveRestartIndex = glad_debug_impl_glPrimitiveRestartIndex;\nPFNGLDEPTHFUNCPROC glad_glDepthFunc;\nvoid APIENTRY glad_debug_impl_glDepthFunc(GLenum arg0) {\n    _pre_call_callback(\"glDepthFunc\", (void*)glDepthFunc, 1, arg0);\n     glad_glDepthFunc(arg0);\n    _post_call_callback(\"glDepthFunc\", (void*)glDepthFunc, 1, arg0);\n}\nPFNGLDEPTHFUNCPROC glad_debug_glDepthFunc = glad_debug_impl_glDepthFunc;\nPFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui;\nvoid APIENTRY glad_debug_impl_glVertexAttribP3ui(GLuint arg0, GLenum arg1, GLboolean arg2, GLuint arg3) {\n    _pre_call_callback(\"glVertexAttribP3ui\", (void*)glVertexAttribP3ui, 4, arg0, arg1, arg2, arg3);\n     glad_glVertexAttribP3ui(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glVertexAttribP3ui\", (void*)glVertexAttribP3ui, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLVERTEXATTRIBP3UIPROC glad_debug_glVertexAttribP3ui = glad_debug_impl_glVertexAttribP3ui;\nPFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray;\nvoid APIENTRY glad_debug_impl_glDisableVertexAttribArray(GLuint arg0) {\n    _pre_call_callback(\"glDisableVertexAttribArray\", (void*)glDisableVertexAttribArray, 1, arg0);\n     glad_glDisableVertexAttribArray(arg0);\n    _post_call_callback(\"glDisableVertexAttribArray\", (void*)glDisableVertexAttribArray, 1, arg0);\n}\nPFNGLDISABLEVERTEXATTRIBARRAYPROC glad_debug_glDisableVertexAttribArray = glad_debug_impl_glDisableVertexAttribArray;\nPFNGLMULTITEXCOORDP2UIVPROC glad_glMultiTexCoordP2uiv;\nvoid APIENTRY glad_debug_impl_glMultiTexCoordP2uiv(GLenum arg0, GLenum arg1, const GLuint * arg2) {\n    _pre_call_callback(\"glMultiTexCoordP2uiv\", (void*)glMultiTexCoordP2uiv, 3, arg0, arg1, arg2);\n     glad_glMultiTexCoordP2uiv(arg0, arg1, arg2);\n    _post_call_callback(\"glMultiTexCoordP2uiv\", (void*)glMultiTexCoordP2uiv, 3, arg0, arg1, arg2);\n}\nPFNGLMULTITEXCOORDP2UIVPROC glad_debug_glMultiTexCoordP2uiv = glad_debug_impl_glMultiTexCoordP2uiv;\nPFNGLSTENCILOPPROC glad_glStencilOp;\nvoid APIENTRY glad_debug_impl_glStencilOp(GLenum arg0, GLenum arg1, GLenum arg2) {\n    _pre_call_callback(\"glStencilOp\", (void*)glStencilOp, 3, arg0, arg1, arg2);\n     glad_glStencilOp(arg0, arg1, arg2);\n    _post_call_callback(\"glStencilOp\", (void*)glStencilOp, 3, arg0, arg1, arg2);\n}\nPFNGLSTENCILOPPROC glad_debug_glStencilOp = glad_debug_impl_glStencilOp;\nPFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s;\nvoid APIENTRY glad_debug_impl_glVertexAttrib1s(GLuint arg0, GLshort arg1) {\n    _pre_call_callback(\"glVertexAttrib1s\", (void*)glVertexAttrib1s, 2, arg0, arg1);\n     glad_glVertexAttrib1s(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib1s\", (void*)glVertexAttrib1s, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB1SPROC glad_debug_glVertexAttrib1s = glad_debug_impl_glVertexAttrib1s;\nPFNGLSAMPLEMASKIPROC glad_glSampleMaski;\nvoid APIENTRY glad_debug_impl_glSampleMaski(GLuint arg0, GLbitfield arg1) {\n    _pre_call_callback(\"glSampleMaski\", (void*)glSampleMaski, 2, arg0, arg1);\n     glad_glSampleMaski(arg0, arg1);\n    _post_call_callback(\"glSampleMaski\", (void*)glSampleMaski, 2, arg0, arg1);\n}\nPFNGLSAMPLEMASKIPROC glad_debug_glSampleMaski = glad_debug_impl_glSampleMaski;\nPFNGLVERTEXP2UIVPROC glad_glVertexP2uiv;\nvoid APIENTRY glad_debug_impl_glVertexP2uiv(GLenum arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glVertexP2uiv\", (void*)glVertexP2uiv, 2, arg0, arg1);\n     glad_glVertexP2uiv(arg0, arg1);\n    _post_call_callback(\"glVertexP2uiv\", (void*)glVertexP2uiv, 2, arg0, arg1);\n}\nPFNGLVERTEXP2UIVPROC glad_debug_glVertexP2uiv = glad_debug_impl_glVertexP2uiv;\nPFNGLUNIFORM3IVPROC glad_glUniform3iv;\nvoid APIENTRY glad_debug_impl_glUniform3iv(GLint arg0, GLsizei arg1, const GLint * arg2) {\n    _pre_call_callback(\"glUniform3iv\", (void*)glUniform3iv, 3, arg0, arg1, arg2);\n     glad_glUniform3iv(arg0, arg1, arg2);\n    _post_call_callback(\"glUniform3iv\", (void*)glUniform3iv, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORM3IVPROC glad_debug_glUniform3iv = glad_debug_impl_glUniform3iv;\nPFNGLDELETESYNCPROC glad_glDeleteSync;\nvoid APIENTRY glad_debug_impl_glDeleteSync(GLsync arg0) {\n    _pre_call_callback(\"glDeleteSync\", (void*)glDeleteSync, 1, arg0);\n     glad_glDeleteSync(arg0);\n    _post_call_callback(\"glDeleteSync\", (void*)glDeleteSync, 1, arg0);\n}\nPFNGLDELETESYNCPROC glad_debug_glDeleteSync = glad_debug_impl_glDeleteSync;\nPFNGLBLENDEQUATIONPROC glad_glBlendEquation;\nvoid APIENTRY glad_debug_impl_glBlendEquation(GLenum arg0) {\n    _pre_call_callback(\"glBlendEquation\", (void*)glBlendEquation, 1, arg0);\n     glad_glBlendEquation(arg0);\n    _post_call_callback(\"glBlendEquation\", (void*)glBlendEquation, 1, arg0);\n}\nPFNGLBLENDEQUATIONPROC glad_debug_glBlendEquation = glad_debug_impl_glBlendEquation;\nPFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i;\nvoid APIENTRY glad_debug_impl_glVertexAttribI3i(GLuint arg0, GLint arg1, GLint arg2, GLint arg3) {\n    _pre_call_callback(\"glVertexAttribI3i\", (void*)glVertexAttribI3i, 4, arg0, arg1, arg2, arg3);\n     glad_glVertexAttribI3i(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glVertexAttribI3i\", (void*)glVertexAttribI3i, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLVERTEXATTRIBI3IPROC glad_debug_glVertexAttribI3i = glad_debug_impl_glVertexAttribI3i;\nPFNGLLOGICOPPROC glad_glLogicOp;\nvoid APIENTRY glad_debug_impl_glLogicOp(GLenum arg0) {\n    _pre_call_callback(\"glLogicOp\", (void*)glLogicOp, 1, arg0);\n     glad_glLogicOp(arg0);\n    _post_call_callback(\"glLogicOp\", (void*)glLogicOp, 1, arg0);\n}\nPFNGLLOGICOPPROC glad_debug_glLogicOp = glad_debug_impl_glLogicOp;\nPFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed;\nvoid APIENTRY glad_debug_impl_glBindFragDataLocationIndexed(GLuint arg0, GLuint arg1, GLuint arg2, const GLchar * arg3) {\n    _pre_call_callback(\"glBindFragDataLocationIndexed\", (void*)glBindFragDataLocationIndexed, 4, arg0, arg1, arg2, arg3);\n     glad_glBindFragDataLocationIndexed(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glBindFragDataLocationIndexed\", (void*)glBindFragDataLocationIndexed, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_debug_glBindFragDataLocationIndexed = glad_debug_impl_glBindFragDataLocationIndexed;\nPFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4usv(GLuint arg0, const GLushort * arg1) {\n    _pre_call_callback(\"glVertexAttrib4usv\", (void*)glVertexAttrib4usv, 2, arg0, arg1);\n     glad_glVertexAttrib4usv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib4usv\", (void*)glVertexAttrib4usv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB4USVPROC glad_debug_glVertexAttrib4usv = glad_debug_impl_glVertexAttrib4usv;\nPFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib;\nvoid APIENTRY glad_debug_impl_glGetActiveAttrib(GLuint arg0, GLuint arg1, GLsizei arg2, GLsizei * arg3, GLint * arg4, GLenum * arg5, GLchar * arg6) {\n    _pre_call_callback(\"glGetActiveAttrib\", (void*)glGetActiveAttrib, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n     glad_glGetActiveAttrib(arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n    _post_call_callback(\"glGetActiveAttrib\", (void*)glGetActiveAttrib, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n}\nPFNGLGETACTIVEATTRIBPROC glad_debug_glGetActiveAttrib = glad_debug_impl_glGetActiveAttrib;\nPFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv;\nvoid APIENTRY glad_debug_impl_glClearBufferuiv(GLenum arg0, GLint arg1, const GLuint * arg2) {\n    _pre_call_callback(\"glClearBufferuiv\", (void*)glClearBufferuiv, 3, arg0, arg1, arg2);\n     glad_glClearBufferuiv(arg0, arg1, arg2);\n    _post_call_callback(\"glClearBufferuiv\", (void*)glClearBufferuiv, 3, arg0, arg1, arg2);\n}\nPFNGLCLEARBUFFERUIVPROC glad_debug_glClearBufferuiv = glad_debug_impl_glClearBufferuiv;\nPFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange;\nvoid * APIENTRY glad_debug_impl_glMapBufferRange(GLenum arg0, GLintptr arg1, GLsizeiptr arg2, GLbitfield arg3) {\n    void * ret;\n    _pre_call_callback(\"glMapBufferRange\", (void*)glMapBufferRange, 4, arg0, arg1, arg2, arg3);\n    ret =  glad_glMapBufferRange(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glMapBufferRange\", (void*)glMapBufferRange, 4, arg0, arg1, arg2, arg3);\n    return ret;\n}\nPFNGLMAPBUFFERRANGEPROC glad_debug_glMapBufferRange = glad_debug_impl_glMapBufferRange;\nPFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v;\nvoid APIENTRY glad_debug_impl_glGetBooleani_v(GLenum arg0, GLuint arg1, GLboolean * arg2) {\n    _pre_call_callback(\"glGetBooleani_v\", (void*)glGetBooleani_v, 3, arg0, arg1, arg2);\n     glad_glGetBooleani_v(arg0, arg1, arg2);\n    _post_call_callback(\"glGetBooleani_v\", (void*)glGetBooleani_v, 3, arg0, arg1, arg2);\n}\nPFNGLGETBOOLEANI_VPROC glad_debug_glGetBooleani_v = glad_debug_impl_glGetBooleani_v;\nPFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage;\nvoid APIENTRY glad_debug_impl_glRenderbufferStorage(GLenum arg0, GLenum arg1, GLsizei arg2, GLsizei arg3) {\n    _pre_call_callback(\"glRenderbufferStorage\", (void*)glRenderbufferStorage, 4, arg0, arg1, arg2, arg3);\n     glad_glRenderbufferStorage(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glRenderbufferStorage\", (void*)glRenderbufferStorage, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLRENDERBUFFERSTORAGEPROC glad_debug_glRenderbufferStorage = glad_debug_impl_glRenderbufferStorage;\nPFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv;\nvoid APIENTRY glad_debug_impl_glPointParameterfv(GLenum arg0, const GLfloat * arg1) {\n    _pre_call_callback(\"glPointParameterfv\", (void*)glPointParameterfv, 2, arg0, arg1);\n     glad_glPointParameterfv(arg0, arg1);\n    _post_call_callback(\"glPointParameterfv\", (void*)glPointParameterfv, 2, arg0, arg1);\n}\nPFNGLPOINTPARAMETERFVPROC glad_debug_glPointParameterfv = glad_debug_impl_glPointParameterfv;\nPFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4d(GLuint arg0, GLdouble arg1, GLdouble arg2, GLdouble arg3, GLdouble arg4) {\n    _pre_call_callback(\"glVertexAttrib4d\", (void*)glVertexAttrib4d, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glVertexAttrib4d(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glVertexAttrib4d\", (void*)glVertexAttrib4d, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLVERTEXATTRIB4DPROC glad_debug_glVertexAttrib4d = glad_debug_impl_glVertexAttrib4d;\nPFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri;\nvoid APIENTRY glad_debug_impl_glSamplerParameteri(GLuint arg0, GLenum arg1, GLint arg2) {\n    _pre_call_callback(\"glSamplerParameteri\", (void*)glSamplerParameteri, 3, arg0, arg1, arg2);\n     glad_glSamplerParameteri(arg0, arg1, arg2);\n    _post_call_callback(\"glSamplerParameteri\", (void*)glSamplerParameteri, 3, arg0, arg1, arg2);\n}\nPFNGLSAMPLERPARAMETERIPROC glad_debug_glSamplerParameteri = glad_debug_impl_glSamplerParameteri;\nPFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4dv(GLuint arg0, const GLdouble * arg1) {\n    _pre_call_callback(\"glVertexAttrib4dv\", (void*)glVertexAttrib4dv, 2, arg0, arg1);\n     glad_glVertexAttrib4dv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib4dv\", (void*)glVertexAttrib4dv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB4DVPROC glad_debug_glVertexAttrib4dv = glad_debug_impl_glVertexAttrib4dv;\nPFNGLTEXBUFFERPROC glad_glTexBuffer;\nvoid APIENTRY glad_debug_impl_glTexBuffer(GLenum arg0, GLenum arg1, GLuint arg2) {\n    _pre_call_callback(\"glTexBuffer\", (void*)glTexBuffer, 3, arg0, arg1, arg2);\n     glad_glTexBuffer(arg0, arg1, arg2);\n    _post_call_callback(\"glTexBuffer\", (void*)glTexBuffer, 3, arg0, arg1, arg2);\n}\nPFNGLTEXBUFFERPROC glad_debug_glTexBuffer = glad_debug_impl_glTexBuffer;\nPFNGLTEXPARAMETERFVPROC glad_glTexParameterfv;\nvoid APIENTRY glad_debug_impl_glTexParameterfv(GLenum arg0, GLenum arg1, const GLfloat * arg2) {\n    _pre_call_callback(\"glTexParameterfv\", (void*)glTexParameterfv, 3, arg0, arg1, arg2);\n     glad_glTexParameterfv(arg0, arg1, arg2);\n    _post_call_callback(\"glTexParameterfv\", (void*)glTexParameterfv, 3, arg0, arg1, arg2);\n}\nPFNGLTEXPARAMETERFVPROC glad_debug_glTexParameterfv = glad_debug_impl_glTexParameterfv;\nPFNGLTEXCOORDP3UIPROC glad_glTexCoordP3ui;\nvoid APIENTRY glad_debug_impl_glTexCoordP3ui(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glTexCoordP3ui\", (void*)glTexCoordP3ui, 2, arg0, arg1);\n     glad_glTexCoordP3ui(arg0, arg1);\n    _post_call_callback(\"glTexCoordP3ui\", (void*)glTexCoordP3ui, 2, arg0, arg1);\n}\nPFNGLTEXCOORDP3UIPROC glad_debug_glTexCoordP3ui = glad_debug_impl_glTexCoordP3ui;\nPFNGLGETPROGRAMIVPROC glad_glGetProgramiv;\nvoid APIENTRY glad_debug_impl_glGetProgramiv(GLuint arg0, GLenum arg1, GLint * arg2) {\n    _pre_call_callback(\"glGetProgramiv\", (void*)glGetProgramiv, 3, arg0, arg1, arg2);\n     glad_glGetProgramiv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetProgramiv\", (void*)glGetProgramiv, 3, arg0, arg1, arg2);\n}\nPFNGLGETPROGRAMIVPROC glad_debug_glGetProgramiv = glad_debug_impl_glGetProgramiv;\nPFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D;\nvoid APIENTRY glad_debug_impl_glFramebufferTexture1D(GLenum arg0, GLenum arg1, GLenum arg2, GLuint arg3, GLint arg4) {\n    _pre_call_callback(\"glFramebufferTexture1D\", (void*)glFramebufferTexture1D, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glFramebufferTexture1D(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glFramebufferTexture1D\", (void*)glFramebufferTexture1D, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLFRAMEBUFFERTEXTURE1DPROC glad_debug_glFramebufferTexture1D = glad_debug_impl_glFramebufferTexture1D;\nPFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib2dv(GLuint arg0, const GLdouble * arg1) {\n    _pre_call_callback(\"glVertexAttrib2dv\", (void*)glVertexAttrib2dv, 2, arg0, arg1);\n     glad_glVertexAttrib2dv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib2dv\", (void*)glVertexAttrib2dv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB2DVPROC glad_debug_glVertexAttrib2dv = glad_debug_impl_glVertexAttrib2dv;\nPFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation;\nGLint APIENTRY glad_debug_impl_glGetUniformLocation(GLuint arg0, const GLchar * arg1) {\n    GLint ret;\n    _pre_call_callback(\"glGetUniformLocation\", (void*)glGetUniformLocation, 2, arg0, arg1);\n    ret =  glad_glGetUniformLocation(arg0, arg1);\n    _post_call_callback(\"glGetUniformLocation\", (void*)glGetUniformLocation, 2, arg0, arg1);\n    return ret;\n}\nPFNGLGETUNIFORMLOCATIONPROC glad_debug_glGetUniformLocation = glad_debug_impl_glGetUniformLocation;\nPFNGLUNIFORM1IPROC glad_glUniform1i;\nvoid APIENTRY glad_debug_impl_glUniform1i(GLint arg0, GLint arg1) {\n    _pre_call_callback(\"glUniform1i\", (void*)glUniform1i, 2, arg0, arg1);\n     glad_glUniform1i(arg0, arg1);\n    _post_call_callback(\"glUniform1i\", (void*)glUniform1i, 2, arg0, arg1);\n}\nPFNGLUNIFORM1IPROC glad_debug_glUniform1i = glad_debug_impl_glUniform1i;\nPFNGLBLENDFUNCPROC glad_glBlendFunc;\nvoid APIENTRY glad_debug_impl_glBlendFunc(GLenum arg0, GLenum arg1) {\n    _pre_call_callback(\"glBlendFunc\", (void*)glBlendFunc, 2, arg0, arg1);\n     glad_glBlendFunc(arg0, arg1);\n    _post_call_callback(\"glBlendFunc\", (void*)glBlendFunc, 2, arg0, arg1);\n}\nPFNGLBLENDFUNCPROC glad_debug_glBlendFunc = glad_debug_impl_glBlendFunc;\nPFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv;\nvoid APIENTRY glad_debug_impl_glGetSamplerParameterIiv(GLuint arg0, GLenum arg1, GLint * arg2) {\n    _pre_call_callback(\"glGetSamplerParameterIiv\", (void*)glGetSamplerParameterIiv, 3, arg0, arg1, arg2);\n     glad_glGetSamplerParameterIiv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetSamplerParameterIiv\", (void*)glGetSamplerParameterIiv, 3, arg0, arg1, arg2);\n}\nPFNGLGETSAMPLERPARAMETERIIVPROC glad_debug_glGetSamplerParameterIiv = glad_debug_impl_glGetSamplerParameterIiv;\nPFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib3dv(GLuint arg0, const GLdouble * arg1) {\n    _pre_call_callback(\"glVertexAttrib3dv\", (void*)glVertexAttrib3dv, 2, arg0, arg1);\n     glad_glVertexAttrib3dv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib3dv\", (void*)glVertexAttrib3dv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB3DVPROC glad_debug_glVertexAttrib3dv = glad_debug_impl_glVertexAttrib3dv;\nPFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced;\nvoid APIENTRY glad_debug_impl_glDrawArraysInstanced(GLenum arg0, GLint arg1, GLsizei arg2, GLsizei arg3) {\n    _pre_call_callback(\"glDrawArraysInstanced\", (void*)glDrawArraysInstanced, 4, arg0, arg1, arg2, arg3);\n     glad_glDrawArraysInstanced(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glDrawArraysInstanced\", (void*)glDrawArraysInstanced, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLDRAWARRAYSINSTANCEDPROC glad_debug_glDrawArraysInstanced = glad_debug_impl_glDrawArraysInstanced;\nPFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4Nusv(GLuint arg0, const GLushort * arg1) {\n    _pre_call_callback(\"glVertexAttrib4Nusv\", (void*)glVertexAttrib4Nusv, 2, arg0, arg1);\n     glad_glVertexAttrib4Nusv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib4Nusv\", (void*)glVertexAttrib4Nusv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB4NUSVPROC glad_debug_glVertexAttrib4Nusv = glad_debug_impl_glVertexAttrib4Nusv;\nPFNGLISPROGRAMPROC glad_glIsProgram;\nGLboolean APIENTRY glad_debug_impl_glIsProgram(GLuint arg0) {\n    GLboolean ret;\n    _pre_call_callback(\"glIsProgram\", (void*)glIsProgram, 1, arg0);\n    ret =  glad_glIsProgram(arg0);\n    _post_call_callback(\"glIsProgram\", (void*)glIsProgram, 1, arg0);\n    return ret;\n}\nPFNGLISPROGRAMPROC glad_debug_glIsProgram = glad_debug_impl_glIsProgram;\nPFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4Nuiv(GLuint arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glVertexAttrib4Nuiv\", (void*)glVertexAttrib4Nuiv, 2, arg0, arg1);\n     glad_glVertexAttrib4Nuiv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib4Nuiv\", (void*)glVertexAttrib4Nuiv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB4NUIVPROC glad_debug_glVertexAttrib4Nuiv = glad_debug_impl_glVertexAttrib4Nuiv;\nPFNGLDELETEPROGRAMPROC glad_glDeleteProgram;\nvoid APIENTRY glad_debug_impl_glDeleteProgram(GLuint arg0) {\n    _pre_call_callback(\"glDeleteProgram\", (void*)glDeleteProgram, 1, arg0);\n     glad_glDeleteProgram(arg0);\n    _post_call_callback(\"glDeleteProgram\", (void*)glDeleteProgram, 1, arg0);\n}\nPFNGLDELETEPROGRAMPROC glad_debug_glDeleteProgram = glad_debug_impl_glDeleteProgram;\nPFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib2fv(GLuint arg0, const GLfloat * arg1) {\n    _pre_call_callback(\"glVertexAttrib2fv\", (void*)glVertexAttrib2fv, 2, arg0, arg1);\n     glad_glVertexAttrib2fv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib2fv\", (void*)glVertexAttrib2fv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB2FVPROC glad_debug_glVertexAttrib2fv = glad_debug_impl_glVertexAttrib2fv;\nPFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib3sv(GLuint arg0, const GLshort * arg1) {\n    _pre_call_callback(\"glVertexAttrib3sv\", (void*)glVertexAttrib3sv, 2, arg0, arg1);\n     glad_glVertexAttrib3sv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib3sv\", (void*)glVertexAttrib3sv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB3SVPROC glad_debug_glVertexAttrib3sv = glad_debug_impl_glVertexAttrib3sv;\nPFNGLISBUFFERPROC glad_glIsBuffer;\nGLboolean APIENTRY glad_debug_impl_glIsBuffer(GLuint arg0) {\n    GLboolean ret;\n    _pre_call_callback(\"glIsBuffer\", (void*)glIsBuffer, 1, arg0);\n    ret =  glad_glIsBuffer(arg0);\n    _post_call_callback(\"glIsBuffer\", (void*)glIsBuffer, 1, arg0);\n    return ret;\n}\nPFNGLISBUFFERPROC glad_debug_glIsBuffer = glad_debug_impl_glIsBuffer;\nPFNGLHINTPROC glad_glHint;\nvoid APIENTRY glad_debug_impl_glHint(GLenum arg0, GLenum arg1) {\n    _pre_call_callback(\"glHint\", (void*)glHint, 2, arg0, arg1);\n     glad_glHint(arg0, arg1);\n    _post_call_callback(\"glHint\", (void*)glHint, 2, arg0, arg1);\n}\nPFNGLHINTPROC glad_debug_glHint = glad_debug_impl_glHint;\nPFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4ubv(GLuint arg0, const GLubyte * arg1) {\n    _pre_call_callback(\"glVertexAttrib4ubv\", (void*)glVertexAttrib4ubv, 2, arg0, arg1);\n     glad_glVertexAttrib4ubv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib4ubv\", (void*)glVertexAttrib4ubv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB4UBVPROC glad_debug_glVertexAttrib4ubv = glad_debug_impl_glVertexAttrib4ubv;\nPFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D;\nvoid APIENTRY glad_debug_impl_glTexSubImage1D(GLenum arg0, GLint arg1, GLint arg2, GLsizei arg3, GLenum arg4, GLenum arg5, const void * arg6) {\n    _pre_call_callback(\"glTexSubImage1D\", (void*)glTexSubImage1D, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n     glad_glTexSubImage1D(arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n    _post_call_callback(\"glTexSubImage1D\", (void*)glTexSubImage1D, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n}\nPFNGLTEXSUBIMAGE1DPROC glad_debug_glTexSubImage1D = glad_debug_impl_glTexSubImage1D;\nPFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv;\nvoid APIENTRY glad_debug_impl_glGetActiveUniformBlockiv(GLuint arg0, GLuint arg1, GLenum arg2, GLint * arg3) {\n    _pre_call_callback(\"glGetActiveUniformBlockiv\", (void*)glGetActiveUniformBlockiv, 4, arg0, arg1, arg2, arg3);\n     glad_glGetActiveUniformBlockiv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetActiveUniformBlockiv\", (void*)glGetActiveUniformBlockiv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_debug_glGetActiveUniformBlockiv = glad_debug_impl_glGetActiveUniformBlockiv;\nPFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv;\nvoid APIENTRY glad_debug_impl_glVertexAttribI2uiv(GLuint arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glVertexAttribI2uiv\", (void*)glVertexAttribI2uiv, 2, arg0, arg1);\n     glad_glVertexAttribI2uiv(arg0, arg1);\n    _post_call_callback(\"glVertexAttribI2uiv\", (void*)glVertexAttribI2uiv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIBI2UIVPROC glad_debug_glVertexAttribI2uiv = glad_debug_impl_glVertexAttribI2uiv;\nPFNGLDELETESHADERPROC glad_glDeleteShader;\nvoid APIENTRY glad_debug_impl_glDeleteShader(GLuint arg0) {\n    _pre_call_callback(\"glDeleteShader\", (void*)glDeleteShader, 1, arg0);\n     glad_glDeleteShader(arg0);\n    _post_call_callback(\"glDeleteShader\", (void*)glDeleteShader, 1, arg0);\n}\nPFNGLDELETESHADERPROC glad_debug_glDeleteShader = glad_debug_impl_glDeleteShader;\nPFNGLGETBOOLEANVPROC glad_glGetBooleanv;\nvoid APIENTRY glad_debug_impl_glGetBooleanv(GLenum arg0, GLboolean * arg1) {\n    _pre_call_callback(\"glGetBooleanv\", (void*)glGetBooleanv, 2, arg0, arg1);\n     glad_glGetBooleanv(arg0, arg1);\n    _post_call_callback(\"glGetBooleanv\", (void*)glGetBooleanv, 2, arg0, arg1);\n}\nPFNGLGETBOOLEANVPROC glad_debug_glGetBooleanv = glad_debug_impl_glGetBooleanv;\nPFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData;\nvoid APIENTRY glad_debug_impl_glCopyBufferSubData(GLenum arg0, GLenum arg1, GLintptr arg2, GLintptr arg3, GLsizeiptr arg4) {\n    _pre_call_callback(\"glCopyBufferSubData\", (void*)glCopyBufferSubData, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glCopyBufferSubData(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glCopyBufferSubData\", (void*)glCopyBufferSubData, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLCOPYBUFFERSUBDATAPROC glad_debug_glCopyBufferSubData = glad_debug_impl_glCopyBufferSubData;\nPFNGLCLEARCOLORPROC glad_glClearColor;\nvoid APIENTRY glad_debug_impl_glClearColor(GLfloat arg0, GLfloat arg1, GLfloat arg2, GLfloat arg3) {\n    _pre_call_callback(\"glClearColor\", (void*)glClearColor, 4, arg0, arg1, arg2, arg3);\n     glad_glClearColor(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glClearColor\", (void*)glClearColor, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLCLEARCOLORPROC glad_debug_glClearColor = glad_debug_impl_glClearColor;\nPFNGLSECONDARYCOLORP3UIPROC glad_glSecondaryColorP3ui;\nvoid APIENTRY glad_debug_impl_glSecondaryColorP3ui(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glSecondaryColorP3ui\", (void*)glSecondaryColorP3ui, 2, arg0, arg1);\n     glad_glSecondaryColorP3ui(arg0, arg1);\n    _post_call_callback(\"glSecondaryColorP3ui\", (void*)glSecondaryColorP3ui, 2, arg0, arg1);\n}\nPFNGLSECONDARYCOLORP3UIPROC glad_debug_glSecondaryColorP3ui = glad_debug_impl_glSecondaryColorP3ui;\nPFNGLDELETETEXTURESPROC glad_glDeleteTextures;\nvoid APIENTRY glad_debug_impl_glDeleteTextures(GLsizei arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glDeleteTextures\", (void*)glDeleteTextures, 2, arg0, arg1);\n     glad_glDeleteTextures(arg0, arg1);\n    _post_call_callback(\"glDeleteTextures\", (void*)glDeleteTextures, 2, arg0, arg1);\n}\nPFNGLDELETETEXTURESPROC glad_debug_glDeleteTextures = glad_debug_impl_glDeleteTextures;\nPFNGLQUERYCOUNTERPROC glad_glQueryCounter;\nvoid APIENTRY glad_debug_impl_glQueryCounter(GLuint arg0, GLenum arg1) {\n    _pre_call_callback(\"glQueryCounter\", (void*)glQueryCounter, 2, arg0, arg1);\n     glad_glQueryCounter(arg0, arg1);\n    _post_call_callback(\"glQueryCounter\", (void*)glQueryCounter, 2, arg0, arg1);\n}\nPFNGLQUERYCOUNTERPROC glad_debug_glQueryCounter = glad_debug_impl_glQueryCounter;\nPFNGLSTENCILFUNCPROC glad_glStencilFunc;\nvoid APIENTRY glad_debug_impl_glStencilFunc(GLenum arg0, GLint arg1, GLuint arg2) {\n    _pre_call_callback(\"glStencilFunc\", (void*)glStencilFunc, 3, arg0, arg1, arg2);\n     glad_glStencilFunc(arg0, arg1, arg2);\n    _post_call_callback(\"glStencilFunc\", (void*)glStencilFunc, 3, arg0, arg1, arg2);\n}\nPFNGLSTENCILFUNCPROC glad_debug_glStencilFunc = glad_debug_impl_glStencilFunc;\nPFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer;\nvoid APIENTRY glad_debug_impl_glBindFramebuffer(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glBindFramebuffer\", (void*)glBindFramebuffer, 2, arg0, arg1);\n     glad_glBindFramebuffer(arg0, arg1);\n    _post_call_callback(\"glBindFramebuffer\", (void*)glBindFramebuffer, 2, arg0, arg1);\n}\nPFNGLBINDFRAMEBUFFERPROC glad_debug_glBindFramebuffer = glad_debug_impl_glBindFramebuffer;\nPFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv;\nvoid APIENTRY glad_debug_impl_glUniformMatrix3x2fv(GLint arg0, GLsizei arg1, GLboolean arg2, const GLfloat * arg3) {\n    _pre_call_callback(\"glUniformMatrix3x2fv\", (void*)glUniformMatrix3x2fv, 4, arg0, arg1, arg2, arg3);\n     glad_glUniformMatrix3x2fv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glUniformMatrix3x2fv\", (void*)glUniformMatrix3x2fv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLUNIFORMMATRIX3X2FVPROC glad_debug_glUniformMatrix3x2fv = glad_debug_impl_glUniformMatrix3x2fv;\nPFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D;\nvoid APIENTRY glad_debug_impl_glCompressedTexImage1D(GLenum arg0, GLint arg1, GLenum arg2, GLsizei arg3, GLint arg4, GLsizei arg5, const void * arg6) {\n    _pre_call_callback(\"glCompressedTexImage1D\", (void*)glCompressedTexImage1D, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n     glad_glCompressedTexImage1D(arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n    _post_call_callback(\"glCompressedTexImage1D\", (void*)glCompressedTexImage1D, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n}\nPFNGLCOMPRESSEDTEXIMAGE1DPROC glad_debug_glCompressedTexImage1D = glad_debug_impl_glCompressedTexImage1D;\nPFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv;\nvoid APIENTRY glad_debug_impl_glSamplerParameterIuiv(GLuint arg0, GLenum arg1, const GLuint * arg2) {\n    _pre_call_callback(\"glSamplerParameterIuiv\", (void*)glSamplerParameterIuiv, 3, arg0, arg1, arg2);\n     glad_glSamplerParameterIuiv(arg0, arg1, arg2);\n    _post_call_callback(\"glSamplerParameterIuiv\", (void*)glSamplerParameterIuiv, 3, arg0, arg1, arg2);\n}\nPFNGLSAMPLERPARAMETERIUIVPROC glad_debug_glSamplerParameterIuiv = glad_debug_impl_glSamplerParameterIuiv;\nPFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer;\nvoid APIENTRY glad_debug_impl_glBindRenderbuffer(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glBindRenderbuffer\", (void*)glBindRenderbuffer, 2, arg0, arg1);\n     glad_glBindRenderbuffer(arg0, arg1);\n    _post_call_callback(\"glBindRenderbuffer\", (void*)glBindRenderbuffer, 2, arg0, arg1);\n}\nPFNGLBINDRENDERBUFFERPROC glad_debug_glBindRenderbuffer = glad_debug_impl_glBindRenderbuffer;\nPFNGLTEXCOORDP2UIVPROC glad_glTexCoordP2uiv;\nvoid APIENTRY glad_debug_impl_glTexCoordP2uiv(GLenum arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glTexCoordP2uiv\", (void*)glTexCoordP2uiv, 2, arg0, arg1);\n     glad_glTexCoordP2uiv(arg0, arg1);\n    _post_call_callback(\"glTexCoordP2uiv\", (void*)glTexCoordP2uiv, 2, arg0, arg1);\n}\nPFNGLTEXCOORDP2UIVPROC glad_debug_glTexCoordP2uiv = glad_debug_impl_glTexCoordP2uiv;\nPFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv;\nvoid APIENTRY glad_debug_impl_glVertexAttribP4uiv(GLuint arg0, GLenum arg1, GLboolean arg2, const GLuint * arg3) {\n    _pre_call_callback(\"glVertexAttribP4uiv\", (void*)glVertexAttribP4uiv, 4, arg0, arg1, arg2, arg3);\n     glad_glVertexAttribP4uiv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glVertexAttribP4uiv\", (void*)glVertexAttribP4uiv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLVERTEXATTRIBP4UIVPROC glad_debug_glVertexAttribP4uiv = glad_debug_impl_glVertexAttribP4uiv;\nPFNGLDELETEQUERIESPROC glad_glDeleteQueries;\nvoid APIENTRY glad_debug_impl_glDeleteQueries(GLsizei arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glDeleteQueries\", (void*)glDeleteQueries, 2, arg0, arg1);\n     glad_glDeleteQueries(arg0, arg1);\n    _post_call_callback(\"glDeleteQueries\", (void*)glDeleteQueries, 2, arg0, arg1);\n}\nPFNGLDELETEQUERIESPROC glad_debug_glDeleteQueries = glad_debug_impl_glDeleteQueries;\nPFNGLDETACHSHADERPROC glad_glDetachShader;\nvoid APIENTRY glad_debug_impl_glDetachShader(GLuint arg0, GLuint arg1) {\n    _pre_call_callback(\"glDetachShader\", (void*)glDetachShader, 2, arg0, arg1);\n     glad_glDetachShader(arg0, arg1);\n    _post_call_callback(\"glDetachShader\", (void*)glDetachShader, 2, arg0, arg1);\n}\nPFNGLDETACHSHADERPROC glad_debug_glDetachShader = glad_debug_impl_glDetachShader;\nPFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib1dv(GLuint arg0, const GLdouble * arg1) {\n    _pre_call_callback(\"glVertexAttrib1dv\", (void*)glVertexAttrib1dv, 2, arg0, arg1);\n     glad_glVertexAttrib1dv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib1dv\", (void*)glVertexAttrib1dv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB1DVPROC glad_debug_glVertexAttrib1dv = glad_debug_impl_glVertexAttrib1dv;\nPFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation;\nGLint APIENTRY glad_debug_impl_glGetAttribLocation(GLuint arg0, const GLchar * arg1) {\n    GLint ret;\n    _pre_call_callback(\"glGetAttribLocation\", (void*)glGetAttribLocation, 2, arg0, arg1);\n    ret =  glad_glGetAttribLocation(arg0, arg1);\n    _post_call_callback(\"glGetAttribLocation\", (void*)glGetAttribLocation, 2, arg0, arg1);\n    return ret;\n}\nPFNGLGETATTRIBLOCATIONPROC glad_debug_glGetAttribLocation = glad_debug_impl_glGetAttribLocation;\nPFNGLGENTEXTURESPROC glad_glGenTextures;\nvoid APIENTRY glad_debug_impl_glGenTextures(GLsizei arg0, GLuint * arg1) {\n    _pre_call_callback(\"glGenTextures\", (void*)glGenTextures, 2, arg0, arg1);\n     glad_glGenTextures(arg0, arg1);\n    _post_call_callback(\"glGenTextures\", (void*)glGenTextures, 2, arg0, arg1);\n}\nPFNGLGENTEXTURESPROC glad_debug_glGenTextures = glad_debug_impl_glGenTextures;\nPFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv;\nvoid APIENTRY glad_debug_impl_glGetTexLevelParameterfv(GLenum arg0, GLint arg1, GLenum arg2, GLfloat * arg3) {\n    _pre_call_callback(\"glGetTexLevelParameterfv\", (void*)glGetTexLevelParameterfv, 4, arg0, arg1, arg2, arg3);\n     glad_glGetTexLevelParameterfv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetTexLevelParameterfv\", (void*)glGetTexLevelParameterfv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETTEXLEVELPARAMETERFVPROC glad_debug_glGetTexLevelParameterfv = glad_debug_impl_glGetTexLevelParameterfv;\nPFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv;\nvoid APIENTRY glad_debug_impl_glUniformMatrix4x2fv(GLint arg0, GLsizei arg1, GLboolean arg2, const GLfloat * arg3) {\n    _pre_call_callback(\"glUniformMatrix4x2fv\", (void*)glUniformMatrix4x2fv, 4, arg0, arg1, arg2, arg3);\n     glad_glUniformMatrix4x2fv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glUniformMatrix4x2fv\", (void*)glUniformMatrix4x2fv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLUNIFORMMATRIX4X2FVPROC glad_debug_glUniformMatrix4x2fv = glad_debug_impl_glUniformMatrix4x2fv;\nPFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv;\nvoid APIENTRY glad_debug_impl_glUniformMatrix3x4fv(GLint arg0, GLsizei arg1, GLboolean arg2, const GLfloat * arg3) {\n    _pre_call_callback(\"glUniformMatrix3x4fv\", (void*)glUniformMatrix3x4fv, 4, arg0, arg1, arg2, arg3);\n     glad_glUniformMatrix3x4fv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glUniformMatrix3x4fv\", (void*)glUniformMatrix3x4fv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLUNIFORMMATRIX3X4FVPROC glad_debug_glUniformMatrix3x4fv = glad_debug_impl_glUniformMatrix3x4fv;\nPFNGLWAITSYNCPROC glad_glWaitSync;\nvoid APIENTRY glad_debug_impl_glWaitSync(GLsync arg0, GLbitfield arg1, GLuint64 arg2) {\n    _pre_call_callback(\"glWaitSync\", (void*)glWaitSync, 3, arg0, arg1, arg2);\n     glad_glWaitSync(arg0, arg1, arg2);\n    _post_call_callback(\"glWaitSync\", (void*)glWaitSync, 3, arg0, arg1, arg2);\n}\nPFNGLWAITSYNCPROC glad_debug_glWaitSync = glad_debug_impl_glWaitSync;\nPFNGLTEXIMAGE2DPROC glad_glTexImage2D;\nvoid APIENTRY glad_debug_impl_glTexImage2D(GLenum arg0, GLint arg1, GLint arg2, GLsizei arg3, GLsizei arg4, GLint arg5, GLenum arg6, GLenum arg7, const void * arg8) {\n    _pre_call_callback(\"glTexImage2D\", (void*)glTexImage2D, 9, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n     glad_glTexImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n    _post_call_callback(\"glTexImage2D\", (void*)glTexImage2D, 9, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n}\nPFNGLTEXIMAGE2DPROC glad_debug_glTexImage2D = glad_debug_impl_glTexImage2D;\nPFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv;\nvoid APIENTRY glad_debug_impl_glTexParameterIuiv(GLenum arg0, GLenum arg1, const GLuint * arg2) {\n    _pre_call_callback(\"glTexParameterIuiv\", (void*)glTexParameterIuiv, 3, arg0, arg1, arg2);\n     glad_glTexParameterIuiv(arg0, arg1, arg2);\n    _post_call_callback(\"glTexParameterIuiv\", (void*)glTexParameterIuiv, 3, arg0, arg1, arg2);\n}\nPFNGLTEXPARAMETERIUIVPROC glad_debug_glTexParameterIuiv = glad_debug_impl_glTexParameterIuiv;\nPFNGLISSYNCPROC glad_glIsSync;\nGLboolean APIENTRY glad_debug_impl_glIsSync(GLsync arg0) {\n    GLboolean ret;\n    _pre_call_callback(\"glIsSync\", (void*)glIsSync, 1, arg0);\n    ret =  glad_glIsSync(arg0);\n    _post_call_callback(\"glIsSync\", (void*)glIsSync, 1, arg0);\n    return ret;\n}\nPFNGLISSYNCPROC glad_debug_glIsSync = glad_debug_impl_glIsSync;\nPFNGLVERTEXP3UIPROC glad_glVertexP3ui;\nvoid APIENTRY glad_debug_impl_glVertexP3ui(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glVertexP3ui\", (void*)glVertexP3ui, 2, arg0, arg1);\n     glad_glVertexP3ui(arg0, arg1);\n    _post_call_callback(\"glVertexP3ui\", (void*)glVertexP3ui, 2, arg0, arg1);\n}\nPFNGLVERTEXP3UIPROC glad_debug_glVertexP3ui = glad_debug_impl_glVertexP3ui;\nPFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui;\nvoid APIENTRY glad_debug_impl_glVertexAttribI1ui(GLuint arg0, GLuint arg1) {\n    _pre_call_callback(\"glVertexAttribI1ui\", (void*)glVertexAttribI1ui, 2, arg0, arg1);\n     glad_glVertexAttribI1ui(arg0, arg1);\n    _post_call_callback(\"glVertexAttribI1ui\", (void*)glVertexAttribI1ui, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIBI1UIPROC glad_debug_glVertexAttribI1ui = glad_debug_impl_glVertexAttribI1ui;\nPFNGLMULTITEXCOORDP1UIVPROC glad_glMultiTexCoordP1uiv;\nvoid APIENTRY glad_debug_impl_glMultiTexCoordP1uiv(GLenum arg0, GLenum arg1, const GLuint * arg2) {\n    _pre_call_callback(\"glMultiTexCoordP1uiv\", (void*)glMultiTexCoordP1uiv, 3, arg0, arg1, arg2);\n     glad_glMultiTexCoordP1uiv(arg0, arg1, arg2);\n    _post_call_callback(\"glMultiTexCoordP1uiv\", (void*)glMultiTexCoordP1uiv, 3, arg0, arg1, arg2);\n}\nPFNGLMULTITEXCOORDP1UIVPROC glad_debug_glMultiTexCoordP1uiv = glad_debug_impl_glMultiTexCoordP1uiv;\nPFNGLUNIFORM3FPROC glad_glUniform3f;\nvoid APIENTRY glad_debug_impl_glUniform3f(GLint arg0, GLfloat arg1, GLfloat arg2, GLfloat arg3) {\n    _pre_call_callback(\"glUniform3f\", (void*)glUniform3f, 4, arg0, arg1, arg2, arg3);\n     glad_glUniform3f(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glUniform3f\", (void*)glUniform3f, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLUNIFORM3FPROC glad_debug_glUniform3f = glad_debug_impl_glUniform3f;\nPFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4uiv(GLuint arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glVertexAttrib4uiv\", (void*)glVertexAttrib4uiv, 2, arg0, arg1);\n     glad_glVertexAttrib4uiv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib4uiv\", (void*)glVertexAttrib4uiv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB4UIVPROC glad_debug_glVertexAttrib4uiv = glad_debug_impl_glVertexAttrib4uiv;\nPFNGLTEXCOORDP2UIPROC glad_glTexCoordP2ui;\nvoid APIENTRY glad_debug_impl_glTexCoordP2ui(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glTexCoordP2ui\", (void*)glTexCoordP2ui, 2, arg0, arg1);\n     glad_glTexCoordP2ui(arg0, arg1);\n    _post_call_callback(\"glTexCoordP2ui\", (void*)glTexCoordP2ui, 2, arg0, arg1);\n}\nPFNGLTEXCOORDP2UIPROC glad_debug_glTexCoordP2ui = glad_debug_impl_glTexCoordP2ui;\nPFNGLUNMAPBUFFERPROC glad_glUnmapBuffer;\nGLboolean APIENTRY glad_debug_impl_glUnmapBuffer(GLenum arg0) {\n    GLboolean ret;\n    _pre_call_callback(\"glUnmapBuffer\", (void*)glUnmapBuffer, 1, arg0);\n    ret =  glad_glUnmapBuffer(arg0);\n    _post_call_callback(\"glUnmapBuffer\", (void*)glUnmapBuffer, 1, arg0);\n    return ret;\n}\nPFNGLUNMAPBUFFERPROC glad_debug_glUnmapBuffer = glad_debug_impl_glUnmapBuffer;\nPFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv;\nvoid APIENTRY glad_debug_impl_glUniformMatrix2x3fv(GLint arg0, GLsizei arg1, GLboolean arg2, const GLfloat * arg3) {\n    _pre_call_callback(\"glUniformMatrix2x3fv\", (void*)glUniformMatrix2x3fv, 4, arg0, arg1, arg2, arg3);\n     glad_glUniformMatrix2x3fv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glUniformMatrix2x3fv\", (void*)glUniformMatrix2x3fv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLUNIFORMMATRIX2X3FVPROC glad_debug_glUniformMatrix2x3fv = glad_debug_impl_glUniformMatrix2x3fv;\nPFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D;\nvoid APIENTRY glad_debug_impl_glFramebufferTexture3D(GLenum arg0, GLenum arg1, GLenum arg2, GLuint arg3, GLint arg4, GLint arg5) {\n    _pre_call_callback(\"glFramebufferTexture3D\", (void*)glFramebufferTexture3D, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n     glad_glFramebufferTexture3D(arg0, arg1, arg2, arg3, arg4, arg5);\n    _post_call_callback(\"glFramebufferTexture3D\", (void*)glFramebufferTexture3D, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n}\nPFNGLFRAMEBUFFERTEXTURE3DPROC glad_debug_glFramebufferTexture3D = glad_debug_impl_glFramebufferTexture3D;\nPFNGLCLEARBUFFERIVPROC glad_glClearBufferiv;\nvoid APIENTRY glad_debug_impl_glClearBufferiv(GLenum arg0, GLint arg1, const GLint * arg2) {\n    _pre_call_callback(\"glClearBufferiv\", (void*)glClearBufferiv, 3, arg0, arg1, arg2);\n     glad_glClearBufferiv(arg0, arg1, arg2);\n    _post_call_callback(\"glClearBufferiv\", (void*)glClearBufferiv, 3, arg0, arg1, arg2);\n}\nPFNGLCLEARBUFFERIVPROC glad_debug_glClearBufferiv = glad_debug_impl_glClearBufferiv;\nPFNGLDEPTHRANGEPROC glad_glDepthRange;\nvoid APIENTRY glad_debug_impl_glDepthRange(GLdouble arg0, GLdouble arg1) {\n    _pre_call_callback(\"glDepthRange\", (void*)glDepthRange, 2, arg0, arg1);\n     glad_glDepthRange(arg0, arg1);\n    _post_call_callback(\"glDepthRange\", (void*)glDepthRange, 2, arg0, arg1);\n}\nPFNGLDEPTHRANGEPROC glad_debug_glDepthRange = glad_debug_impl_glDepthRange;\nPFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv;\nvoid APIENTRY glad_debug_impl_glGetQueryObjectiv(GLuint arg0, GLenum arg1, GLint * arg2) {\n    _pre_call_callback(\"glGetQueryObjectiv\", (void*)glGetQueryObjectiv, 3, arg0, arg1, arg2);\n     glad_glGetQueryObjectiv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetQueryObjectiv\", (void*)glGetQueryObjectiv, 3, arg0, arg1, arg2);\n}\nPFNGLGETQUERYOBJECTIVPROC glad_debug_glGetQueryObjectiv = glad_debug_impl_glGetQueryObjectiv;\nPFNGLTEXCOORDP4UIPROC glad_glTexCoordP4ui;\nvoid APIENTRY glad_debug_impl_glTexCoordP4ui(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glTexCoordP4ui\", (void*)glTexCoordP4ui, 2, arg0, arg1);\n     glad_glTexCoordP4ui(arg0, arg1);\n    _post_call_callback(\"glTexCoordP4ui\", (void*)glTexCoordP4ui, 2, arg0, arg1);\n}\nPFNGLTEXCOORDP4UIPROC glad_debug_glTexCoordP4ui = glad_debug_impl_glTexCoordP4ui;\nPFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv;\nvoid APIENTRY glad_debug_impl_glUniformMatrix4fv(GLint arg0, GLsizei arg1, GLboolean arg2, const GLfloat * arg3) {\n    _pre_call_callback(\"glUniformMatrix4fv\", (void*)glUniformMatrix4fv, 4, arg0, arg1, arg2, arg3);\n     glad_glUniformMatrix4fv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glUniformMatrix4fv\", (void*)glUniformMatrix4fv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLUNIFORMMATRIX4FVPROC glad_debug_glUniformMatrix4fv = glad_debug_impl_glUniformMatrix4fv;\nPFNGLSHADERSOURCEPROC glad_glShaderSource;\nvoid APIENTRY glad_debug_impl_glShaderSource(GLuint arg0, GLsizei arg1, const GLchar *const* arg2, const GLint * arg3) {\n    _pre_call_callback(\"glShaderSource\", (void*)glShaderSource, 4, arg0, arg1, arg2, arg3);\n     glad_glShaderSource(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glShaderSource\", (void*)glShaderSource, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLSHADERSOURCEPROC glad_debug_glShaderSource = glad_debug_impl_glShaderSource;\nPFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv;\nvoid APIENTRY glad_debug_impl_glUniformMatrix4x3fv(GLint arg0, GLsizei arg1, GLboolean arg2, const GLfloat * arg3) {\n    _pre_call_callback(\"glUniformMatrix4x3fv\", (void*)glUniformMatrix4x3fv, 4, arg0, arg1, arg2, arg3);\n     glad_glUniformMatrix4x3fv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glUniformMatrix4x3fv\", (void*)glUniformMatrix4x3fv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLUNIFORMMATRIX4X3FVPROC glad_debug_glUniformMatrix4x3fv = glad_debug_impl_glUniformMatrix4x3fv;\nPFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv;\nvoid APIENTRY glad_debug_impl_glVertexAttribP1uiv(GLuint arg0, GLenum arg1, GLboolean arg2, const GLuint * arg3) {\n    _pre_call_callback(\"glVertexAttribP1uiv\", (void*)glVertexAttribP1uiv, 4, arg0, arg1, arg2, arg3);\n     glad_glVertexAttribP1uiv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glVertexAttribP1uiv\", (void*)glVertexAttribP1uiv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLVERTEXATTRIBP1UIVPROC glad_debug_glVertexAttribP1uiv = glad_debug_impl_glVertexAttribP1uiv;\nPFNGLCREATESHADERPROC glad_glCreateShader;\nGLuint APIENTRY glad_debug_impl_glCreateShader(GLenum arg0) {\n    GLuint ret;\n    _pre_call_callback(\"glCreateShader\", (void*)glCreateShader, 1, arg0);\n    ret =  glad_glCreateShader(arg0);\n    _post_call_callback(\"glCreateShader\", (void*)glCreateShader, 1, arg0);\n    return ret;\n}\nPFNGLCREATESHADERPROC glad_debug_glCreateShader = glad_debug_impl_glCreateShader;\nPFNGLUNIFORM4UIPROC glad_glUniform4ui;\nvoid APIENTRY glad_debug_impl_glUniform4ui(GLint arg0, GLuint arg1, GLuint arg2, GLuint arg3, GLuint arg4) {\n    _pre_call_callback(\"glUniform4ui\", (void*)glUniform4ui, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glUniform4ui(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glUniform4ui\", (void*)glUniform4ui, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLUNIFORM4UIPROC glad_debug_glUniform4ui = glad_debug_impl_glUniform4ui;\nPFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex;\nGLint APIENTRY glad_debug_impl_glGetFragDataIndex(GLuint arg0, const GLchar * arg1) {\n    GLint ret;\n    _pre_call_callback(\"glGetFragDataIndex\", (void*)glGetFragDataIndex, 2, arg0, arg1);\n    ret =  glad_glGetFragDataIndex(arg0, arg1);\n    _post_call_callback(\"glGetFragDataIndex\", (void*)glGetFragDataIndex, 2, arg0, arg1);\n    return ret;\n}\nPFNGLGETFRAGDATAINDEXPROC glad_debug_glGetFragDataIndex = glad_debug_impl_glGetFragDataIndex;\nPFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D;\nvoid APIENTRY glad_debug_impl_glCompressedTexSubImage3D(GLenum arg0, GLint arg1, GLint arg2, GLint arg3, GLint arg4, GLsizei arg5, GLsizei arg6, GLsizei arg7, GLenum arg8, GLsizei arg9, const void * arg10) {\n    _pre_call_callback(\"glCompressedTexSubImage3D\", (void*)glCompressedTexSubImage3D, 11, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);\n     glad_glCompressedTexSubImage3D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);\n    _post_call_callback(\"glCompressedTexSubImage3D\", (void*)glCompressedTexSubImage3D, 11, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);\n}\nPFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_debug_glCompressedTexSubImage3D = glad_debug_impl_glCompressedTexSubImage3D;\nPFNGLUNIFORM1UIVPROC glad_glUniform1uiv;\nvoid APIENTRY glad_debug_impl_glUniform1uiv(GLint arg0, GLsizei arg1, const GLuint * arg2) {\n    _pre_call_callback(\"glUniform1uiv\", (void*)glUniform1uiv, 3, arg0, arg1, arg2);\n     glad_glUniform1uiv(arg0, arg1, arg2);\n    _post_call_callback(\"glUniform1uiv\", (void*)glUniform1uiv, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORM1UIVPROC glad_debug_glUniform1uiv = glad_debug_impl_glUniform1uiv;\nPFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding;\nvoid APIENTRY glad_debug_impl_glUniformBlockBinding(GLuint arg0, GLuint arg1, GLuint arg2) {\n    _pre_call_callback(\"glUniformBlockBinding\", (void*)glUniformBlockBinding, 3, arg0, arg1, arg2);\n     glad_glUniformBlockBinding(arg0, arg1, arg2);\n    _post_call_callback(\"glUniformBlockBinding\", (void*)glUniformBlockBinding, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORMBLOCKBINDINGPROC glad_debug_glUniformBlockBinding = glad_debug_impl_glUniformBlockBinding;\nPFNGLCLEARDEPTHPROC glad_glClearDepth;\nvoid APIENTRY glad_debug_impl_glClearDepth(GLdouble arg0) {\n    _pre_call_callback(\"glClearDepth\", (void*)glClearDepth, 1, arg0);\n     glad_glClearDepth(arg0);\n    _post_call_callback(\"glClearDepth\", (void*)glClearDepth, 1, arg0);\n}\nPFNGLCLEARDEPTHPROC glad_debug_glClearDepth = glad_debug_impl_glClearDepth;\nPFNGLLINEWIDTHPROC glad_glLineWidth;\nvoid APIENTRY glad_debug_impl_glLineWidth(GLfloat arg0) {\n    _pre_call_callback(\"glLineWidth\", (void*)glLineWidth, 1, arg0);\n     glad_glLineWidth(arg0);\n    _post_call_callback(\"glLineWidth\", (void*)glLineWidth, 1, arg0);\n}\nPFNGLLINEWIDTHPROC glad_debug_glLineWidth = glad_debug_impl_glLineWidth;\nPFNGLUNIFORM2FPROC glad_glUniform2f;\nvoid APIENTRY glad_debug_impl_glUniform2f(GLint arg0, GLfloat arg1, GLfloat arg2) {\n    _pre_call_callback(\"glUniform2f\", (void*)glUniform2f, 3, arg0, arg1, arg2);\n     glad_glUniform2f(arg0, arg1, arg2);\n    _post_call_callback(\"glUniform2f\", (void*)glUniform2f, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORM2FPROC glad_debug_glUniform2f = glad_debug_impl_glUniform2f;\nPFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex;\nvoid APIENTRY glad_debug_impl_glDrawElementsBaseVertex(GLenum arg0, GLsizei arg1, GLenum arg2, const void * arg3, GLint arg4) {\n    _pre_call_callback(\"glDrawElementsBaseVertex\", (void*)glDrawElementsBaseVertex, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glDrawElementsBaseVertex(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glDrawElementsBaseVertex\", (void*)glDrawElementsBaseVertex, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLDRAWELEMENTSBASEVERTEXPROC glad_debug_glDrawElementsBaseVertex = glad_debug_impl_glDrawElementsBaseVertex;\nPFNGLUNIFORM4IVPROC glad_glUniform4iv;\nvoid APIENTRY glad_debug_impl_glUniform4iv(GLint arg0, GLsizei arg1, const GLint * arg2) {\n    _pre_call_callback(\"glUniform4iv\", (void*)glUniform4iv, 3, arg0, arg1, arg2);\n     glad_glUniform4iv(arg0, arg1, arg2);\n    _post_call_callback(\"glUniform4iv\", (void*)glUniform4iv, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORM4IVPROC glad_debug_glUniform4iv = glad_debug_impl_glUniform4iv;\nPFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer;\nvoid APIENTRY glad_debug_impl_glBlitFramebuffer(GLint arg0, GLint arg1, GLint arg2, GLint arg3, GLint arg4, GLint arg5, GLint arg6, GLint arg7, GLbitfield arg8, GLenum arg9) {\n    _pre_call_callback(\"glBlitFramebuffer\", (void*)glBlitFramebuffer, 10, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n     glad_glBlitFramebuffer(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n    _post_call_callback(\"glBlitFramebuffer\", (void*)glBlitFramebuffer, 10, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n}\nPFNGLBLITFRAMEBUFFERPROC glad_debug_glBlitFramebuffer = glad_debug_impl_glBlitFramebuffer;\nPFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying;\nvoid APIENTRY glad_debug_impl_glGetTransformFeedbackVarying(GLuint arg0, GLuint arg1, GLsizei arg2, GLsizei * arg3, GLsizei * arg4, GLenum * arg5, GLchar * arg6) {\n    _pre_call_callback(\"glGetTransformFeedbackVarying\", (void*)glGetTransformFeedbackVarying, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n     glad_glGetTransformFeedbackVarying(arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n    _post_call_callback(\"glGetTransformFeedbackVarying\", (void*)glGetTransformFeedbackVarying, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n}\nPFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_debug_glGetTransformFeedbackVarying = glad_debug_impl_glGetTransformFeedbackVarying;\nPFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate;\nvoid APIENTRY glad_debug_impl_glBlendEquationSeparate(GLenum arg0, GLenum arg1) {\n    _pre_call_callback(\"glBlendEquationSeparate\", (void*)glBlendEquationSeparate, 2, arg0, arg1);\n     glad_glBlendEquationSeparate(arg0, arg1);\n    _post_call_callback(\"glBlendEquationSeparate\", (void*)glBlendEquationSeparate, 2, arg0, arg1);\n}\nPFNGLBLENDEQUATIONSEPARATEPROC glad_debug_glBlendEquationSeparate = glad_debug_impl_glBlendEquationSeparate;\nPFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings;\nvoid APIENTRY glad_debug_impl_glTransformFeedbackVaryings(GLuint arg0, GLsizei arg1, const GLchar *const* arg2, GLenum arg3) {\n    _pre_call_callback(\"glTransformFeedbackVaryings\", (void*)glTransformFeedbackVaryings, 4, arg0, arg1, arg2, arg3);\n     glad_glTransformFeedbackVaryings(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glTransformFeedbackVaryings\", (void*)glTransformFeedbackVaryings, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_debug_glTransformFeedbackVaryings = glad_debug_impl_glTransformFeedbackVaryings;\nPFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers;\nvoid APIENTRY glad_debug_impl_glGenRenderbuffers(GLsizei arg0, GLuint * arg1) {\n    _pre_call_callback(\"glGenRenderbuffers\", (void*)glGenRenderbuffers, 2, arg0, arg1);\n     glad_glGenRenderbuffers(arg0, arg1);\n    _post_call_callback(\"glGenRenderbuffers\", (void*)glGenRenderbuffers, 2, arg0, arg1);\n}\nPFNGLGENRENDERBUFFERSPROC glad_debug_glGenRenderbuffers = glad_debug_impl_glGenRenderbuffers;\nPFNGLDRAWBUFFERPROC glad_glDrawBuffer;\nvoid APIENTRY glad_debug_impl_glDrawBuffer(GLenum arg0) {\n    _pre_call_callback(\"glDrawBuffer\", (void*)glDrawBuffer, 1, arg0);\n     glad_glDrawBuffer(arg0);\n    _post_call_callback(\"glDrawBuffer\", (void*)glDrawBuffer, 1, arg0);\n}\nPFNGLDRAWBUFFERPROC glad_debug_glDrawBuffer = glad_debug_impl_glDrawBuffer;\nPFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D;\nvoid APIENTRY glad_debug_impl_glCompressedTexImage2D(GLenum arg0, GLint arg1, GLenum arg2, GLsizei arg3, GLsizei arg4, GLint arg5, GLsizei arg6, const void * arg7) {\n    _pre_call_callback(\"glCompressedTexImage2D\", (void*)glCompressedTexImage2D, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n     glad_glCompressedTexImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n    _post_call_callback(\"glCompressedTexImage2D\", (void*)glCompressedTexImage2D, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n}\nPFNGLCOMPRESSEDTEXIMAGE2DPROC glad_debug_glCompressedTexImage2D = glad_debug_impl_glCompressedTexImage2D;\nPFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv;\nvoid APIENTRY glad_debug_impl_glGetSamplerParameterIuiv(GLuint arg0, GLenum arg1, GLuint * arg2) {\n    _pre_call_callback(\"glGetSamplerParameterIuiv\", (void*)glGetSamplerParameterIuiv, 3, arg0, arg1, arg2);\n     glad_glGetSamplerParameterIuiv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetSamplerParameterIuiv\", (void*)glGetSamplerParameterIuiv, 3, arg0, arg1, arg2);\n}\nPFNGLGETSAMPLERPARAMETERIUIVPROC glad_debug_glGetSamplerParameterIuiv = glad_debug_impl_glGetSamplerParameterIuiv;\nPFNGLGETFLOATVPROC glad_glGetFloatv;\nvoid APIENTRY glad_debug_impl_glGetFloatv(GLenum arg0, GLfloat * arg1) {\n    _pre_call_callback(\"glGetFloatv\", (void*)glGetFloatv, 2, arg0, arg1);\n     glad_glGetFloatv(arg0, arg1);\n    _post_call_callback(\"glGetFloatv\", (void*)glGetFloatv, 2, arg0, arg1);\n}\nPFNGLGETFLOATVPROC glad_debug_glGetFloatv = glad_debug_impl_glGetFloatv;\nPFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv;\nvoid APIENTRY glad_debug_impl_glVertexAttribI1uiv(GLuint arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glVertexAttribI1uiv\", (void*)glVertexAttribI1uiv, 2, arg0, arg1);\n     glad_glVertexAttribI1uiv(arg0, arg1);\n    _post_call_callback(\"glVertexAttribI1uiv\", (void*)glVertexAttribI1uiv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIBI1UIVPROC glad_debug_glVertexAttribI1uiv = glad_debug_impl_glVertexAttribI1uiv;\nPFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform;\nvoid APIENTRY glad_debug_impl_glGetActiveUniform(GLuint arg0, GLuint arg1, GLsizei arg2, GLsizei * arg3, GLint * arg4, GLenum * arg5, GLchar * arg6) {\n    _pre_call_callback(\"glGetActiveUniform\", (void*)glGetActiveUniform, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n     glad_glGetActiveUniform(arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n    _post_call_callback(\"glGetActiveUniform\", (void*)glGetActiveUniform, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n}\nPFNGLGETACTIVEUNIFORMPROC glad_debug_glGetActiveUniform = glad_debug_impl_glGetActiveUniform;\nPFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D;\nvoid APIENTRY glad_debug_impl_glTexSubImage3D(GLenum arg0, GLint arg1, GLint arg2, GLint arg3, GLint arg4, GLsizei arg5, GLsizei arg6, GLsizei arg7, GLenum arg8, GLenum arg9, const void * arg10) {\n    _pre_call_callback(\"glTexSubImage3D\", (void*)glTexSubImage3D, 11, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);\n     glad_glTexSubImage3D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);\n    _post_call_callback(\"glTexSubImage3D\", (void*)glTexSubImage3D, 11, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);\n}\nPFNGLTEXSUBIMAGE3DPROC glad_debug_glTexSubImage3D = glad_debug_impl_glTexSubImage3D;\nPFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray;\nvoid APIENTRY glad_debug_impl_glEnableVertexAttribArray(GLuint arg0) {\n    _pre_call_callback(\"glEnableVertexAttribArray\", (void*)glEnableVertexAttribArray, 1, arg0);\n     glad_glEnableVertexAttribArray(arg0);\n    _post_call_callback(\"glEnableVertexAttribArray\", (void*)glEnableVertexAttribArray, 1, arg0);\n}\nPFNGLENABLEVERTEXATTRIBARRAYPROC glad_debug_glEnableVertexAttribArray = glad_debug_impl_glEnableVertexAttribArray;\nPFNGLUNIFORM1IVPROC glad_glUniform1iv;\nvoid APIENTRY glad_debug_impl_glUniform1iv(GLint arg0, GLsizei arg1, const GLint * arg2) {\n    _pre_call_callback(\"glUniform1iv\", (void*)glUniform1iv, 3, arg0, arg1, arg2);\n     glad_glUniform1iv(arg0, arg1, arg2);\n    _post_call_callback(\"glUniform1iv\", (void*)glUniform1iv, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORM1IVPROC glad_debug_glUniform1iv = glad_debug_impl_glUniform1iv;\nPFNGLVERTEXP4UIVPROC glad_glVertexP4uiv;\nvoid APIENTRY glad_debug_impl_glVertexP4uiv(GLenum arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glVertexP4uiv\", (void*)glVertexP4uiv, 2, arg0, arg1);\n     glad_glVertexP4uiv(arg0, arg1);\n    _post_call_callback(\"glVertexP4uiv\", (void*)glVertexP4uiv, 2, arg0, arg1);\n}\nPFNGLVERTEXP4UIVPROC glad_debug_glVertexP4uiv = glad_debug_impl_glVertexP4uiv;\nPFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap;\nvoid APIENTRY glad_debug_impl_glGenerateMipmap(GLenum arg0) {\n    _pre_call_callback(\"glGenerateMipmap\", (void*)glGenerateMipmap, 1, arg0);\n     glad_glGenerateMipmap(arg0);\n    _post_call_callback(\"glGenerateMipmap\", (void*)glGenerateMipmap, 1, arg0);\n}\nPFNGLGENERATEMIPMAPPROC glad_debug_glGenerateMipmap = glad_debug_impl_glGenerateMipmap;\nPFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange;\nvoid APIENTRY glad_debug_impl_glFlushMappedBufferRange(GLenum arg0, GLintptr arg1, GLsizeiptr arg2) {\n    _pre_call_callback(\"glFlushMappedBufferRange\", (void*)glFlushMappedBufferRange, 3, arg0, arg1, arg2);\n     glad_glFlushMappedBufferRange(arg0, arg1, arg2);\n    _post_call_callback(\"glFlushMappedBufferRange\", (void*)glFlushMappedBufferRange, 3, arg0, arg1, arg2);\n}\nPFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_debug_glFlushMappedBufferRange = glad_debug_impl_glFlushMappedBufferRange;\nPFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer;\nvoid APIENTRY glad_debug_impl_glFramebufferRenderbuffer(GLenum arg0, GLenum arg1, GLenum arg2, GLuint arg3) {\n    _pre_call_callback(\"glFramebufferRenderbuffer\", (void*)glFramebufferRenderbuffer, 4, arg0, arg1, arg2, arg3);\n     glad_glFramebufferRenderbuffer(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glFramebufferRenderbuffer\", (void*)glFramebufferRenderbuffer, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLFRAMEBUFFERRENDERBUFFERPROC glad_debug_glFramebufferRenderbuffer = glad_debug_impl_glFramebufferRenderbuffer;\nPFNGLCOLORP4UIVPROC glad_glColorP4uiv;\nvoid APIENTRY glad_debug_impl_glColorP4uiv(GLenum arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glColorP4uiv\", (void*)glColorP4uiv, 2, arg0, arg1);\n     glad_glColorP4uiv(arg0, arg1);\n    _post_call_callback(\"glColorP4uiv\", (void*)glColorP4uiv, 2, arg0, arg1);\n}\nPFNGLCOLORP4UIVPROC glad_debug_glColorP4uiv = glad_debug_impl_glColorP4uiv;\nPFNGLSECONDARYCOLORP3UIVPROC glad_glSecondaryColorP3uiv;\nvoid APIENTRY glad_debug_impl_glSecondaryColorP3uiv(GLenum arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glSecondaryColorP3uiv\", (void*)glSecondaryColorP3uiv, 2, arg0, arg1);\n     glad_glSecondaryColorP3uiv(arg0, arg1);\n    _post_call_callback(\"glSecondaryColorP3uiv\", (void*)glSecondaryColorP3uiv, 2, arg0, arg1);\n}\nPFNGLSECONDARYCOLORP3UIVPROC glad_debug_glSecondaryColorP3uiv = glad_debug_impl_glSecondaryColorP3uiv;\nPFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers;\nvoid APIENTRY glad_debug_impl_glDeleteFramebuffers(GLsizei arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glDeleteFramebuffers\", (void*)glDeleteFramebuffers, 2, arg0, arg1);\n     glad_glDeleteFramebuffers(arg0, arg1);\n    _post_call_callback(\"glDeleteFramebuffers\", (void*)glDeleteFramebuffers, 2, arg0, arg1);\n}\nPFNGLDELETEFRAMEBUFFERSPROC glad_debug_glDeleteFramebuffers = glad_debug_impl_glDeleteFramebuffers;\nPFNGLUNIFORM4UIVPROC glad_glUniform4uiv;\nvoid APIENTRY glad_debug_impl_glUniform4uiv(GLint arg0, GLsizei arg1, const GLuint * arg2) {\n    _pre_call_callback(\"glUniform4uiv\", (void*)glUniform4uiv, 3, arg0, arg1, arg2);\n     glad_glUniform4uiv(arg0, arg1, arg2);\n    _post_call_callback(\"glUniform4uiv\", (void*)glUniform4uiv, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORM4UIVPROC glad_debug_glUniform4uiv = glad_debug_impl_glUniform4uiv;\nPFNGLCOLORMASKIPROC glad_glColorMaski;\nvoid APIENTRY glad_debug_impl_glColorMaski(GLuint arg0, GLboolean arg1, GLboolean arg2, GLboolean arg3, GLboolean arg4) {\n    _pre_call_callback(\"glColorMaski\", (void*)glColorMaski, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glColorMaski(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glColorMaski\", (void*)glColorMaski, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLCOLORMASKIPROC glad_debug_glColorMaski = glad_debug_impl_glColorMaski;\nPFNGLUNIFORM2FVPROC glad_glUniform2fv;\nvoid APIENTRY glad_debug_impl_glUniform2fv(GLint arg0, GLsizei arg1, const GLfloat * arg2) {\n    _pre_call_callback(\"glUniform2fv\", (void*)glUniform2fv, 3, arg0, arg1, arg2);\n     glad_glUniform2fv(arg0, arg1, arg2);\n    _post_call_callback(\"glUniform2fv\", (void*)glUniform2fv, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORM2FVPROC glad_debug_glUniform2fv = glad_debug_impl_glUniform2fv;\nPFNGLVIEWPORTPROC glad_glViewport;\nvoid APIENTRY glad_debug_impl_glViewport(GLint arg0, GLint arg1, GLsizei arg2, GLsizei arg3) {\n    _pre_call_callback(\"glViewport\", (void*)glViewport, 4, arg0, arg1, arg2, arg3);\n     glad_glViewport(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glViewport\", (void*)glViewport, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLVIEWPORTPROC glad_debug_glViewport = glad_debug_impl_glViewport;\nPFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices;\nvoid APIENTRY glad_debug_impl_glGetUniformIndices(GLuint arg0, GLsizei arg1, const GLchar *const* arg2, GLuint * arg3) {\n    _pre_call_callback(\"glGetUniformIndices\", (void*)glGetUniformIndices, 4, arg0, arg1, arg2, arg3);\n     glad_glGetUniformIndices(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetUniformIndices\", (void*)glGetUniformIndices, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETUNIFORMINDICESPROC glad_debug_glGetUniformIndices = glad_debug_impl_glGetUniformIndices;\nPFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback;\nvoid APIENTRY glad_debug_impl_glBeginTransformFeedback(GLenum arg0) {\n    _pre_call_callback(\"glBeginTransformFeedback\", (void*)glBeginTransformFeedback, 1, arg0);\n     glad_glBeginTransformFeedback(arg0);\n    _post_call_callback(\"glBeginTransformFeedback\", (void*)glBeginTransformFeedback, 1, arg0);\n}\nPFNGLBEGINTRANSFORMFEEDBACKPROC glad_debug_glBeginTransformFeedback = glad_debug_impl_glBeginTransformFeedback;\nPFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui;\nvoid APIENTRY glad_debug_impl_glVertexAttribP1ui(GLuint arg0, GLenum arg1, GLboolean arg2, GLuint arg3) {\n    _pre_call_callback(\"glVertexAttribP1ui\", (void*)glVertexAttribP1ui, 4, arg0, arg1, arg2, arg3);\n     glad_glVertexAttribP1ui(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glVertexAttribP1ui\", (void*)glVertexAttribP1ui, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLVERTEXATTRIBP1UIPROC glad_debug_glVertexAttribP1ui = glad_debug_impl_glVertexAttribP1ui;\nPFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers;\nvoid APIENTRY glad_debug_impl_glDeleteRenderbuffers(GLsizei arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glDeleteRenderbuffers\", (void*)glDeleteRenderbuffers, 2, arg0, arg1);\n     glad_glDeleteRenderbuffers(arg0, arg1);\n    _post_call_callback(\"glDeleteRenderbuffers\", (void*)glDeleteRenderbuffers, 2, arg0, arg1);\n}\nPFNGLDELETERENDERBUFFERSPROC glad_debug_glDeleteRenderbuffers = glad_debug_impl_glDeleteRenderbuffers;\nPFNGLGETINTEGER64VPROC glad_glGetInteger64v;\nvoid APIENTRY glad_debug_impl_glGetInteger64v(GLenum arg0, GLint64 * arg1) {\n    _pre_call_callback(\"glGetInteger64v\", (void*)glGetInteger64v, 2, arg0, arg1);\n     glad_glGetInteger64v(arg0, arg1);\n    _post_call_callback(\"glGetInteger64v\", (void*)glGetInteger64v, 2, arg0, arg1);\n}\nPFNGLGETINTEGER64VPROC glad_debug_glGetInteger64v = glad_debug_impl_glGetInteger64v;\nPFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv;\nvoid APIENTRY glad_debug_impl_glGetVertexAttribdv(GLuint arg0, GLenum arg1, GLdouble * arg2) {\n    _pre_call_callback(\"glGetVertexAttribdv\", (void*)glGetVertexAttribdv, 3, arg0, arg1, arg2);\n     glad_glGetVertexAttribdv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetVertexAttribdv\", (void*)glGetVertexAttribdv, 3, arg0, arg1, arg2);\n}\nPFNGLGETVERTEXATTRIBDVPROC glad_debug_glGetVertexAttribdv = glad_debug_impl_glGetVertexAttribdv;\nPFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv;\nvoid APIENTRY glad_debug_impl_glVertexAttribI3iv(GLuint arg0, const GLint * arg1) {\n    _pre_call_callback(\"glVertexAttribI3iv\", (void*)glVertexAttribI3iv, 2, arg0, arg1);\n     glad_glVertexAttribI3iv(arg0, arg1);\n    _post_call_callback(\"glVertexAttribI3iv\", (void*)glVertexAttribI3iv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIBI3IVPROC glad_debug_glVertexAttribI3iv = glad_debug_impl_glVertexAttribI3iv;\nPFNGLPIXELSTOREIPROC glad_glPixelStorei;\nvoid APIENTRY glad_debug_impl_glPixelStorei(GLenum arg0, GLint arg1) {\n    _pre_call_callback(\"glPixelStorei\", (void*)glPixelStorei, 2, arg0, arg1);\n     glad_glPixelStorei(arg0, arg1);\n    _post_call_callback(\"glPixelStorei\", (void*)glPixelStorei, 2, arg0, arg1);\n}\nPFNGLPIXELSTOREIPROC glad_debug_glPixelStorei = glad_debug_impl_glPixelStorei;\nPFNGLISSHADERPROC glad_glIsShader;\nGLboolean APIENTRY glad_debug_impl_glIsShader(GLuint arg0) {\n    GLboolean ret;\n    _pre_call_callback(\"glIsShader\", (void*)glIsShader, 1, arg0);\n    ret =  glad_glIsShader(arg0);\n    _post_call_callback(\"glIsShader\", (void*)glIsShader, 1, arg0);\n    return ret;\n}\nPFNGLISSHADERPROC glad_debug_glIsShader = glad_debug_impl_glIsShader;\nPFNGLGENSAMPLERSPROC glad_glGenSamplers;\nvoid APIENTRY glad_debug_impl_glGenSamplers(GLsizei arg0, GLuint * arg1) {\n    _pre_call_callback(\"glGenSamplers\", (void*)glGenSamplers, 2, arg0, arg1);\n     glad_glGenSamplers(arg0, arg1);\n    _post_call_callback(\"glGenSamplers\", (void*)glGenSamplers, 2, arg0, arg1);\n}\nPFNGLGENSAMPLERSPROC glad_debug_glGenSamplers = glad_debug_impl_glGenSamplers;\nPFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv;\nvoid APIENTRY glad_debug_impl_glVertexAttribI2iv(GLuint arg0, const GLint * arg1) {\n    _pre_call_callback(\"glVertexAttribI2iv\", (void*)glVertexAttribI2iv, 2, arg0, arg1);\n     glad_glVertexAttribI2iv(arg0, arg1);\n    _post_call_callback(\"glVertexAttribI2iv\", (void*)glVertexAttribI2iv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIBI2IVPROC glad_debug_glVertexAttribI2iv = glad_debug_impl_glVertexAttribI2iv;\nPFNGLATTACHSHADERPROC glad_glAttachShader;\nvoid APIENTRY glad_debug_impl_glAttachShader(GLuint arg0, GLuint arg1) {\n    _pre_call_callback(\"glAttachShader\", (void*)glAttachShader, 2, arg0, arg1);\n     glad_glAttachShader(arg0, arg1);\n    _post_call_callback(\"glAttachShader\", (void*)glAttachShader, 2, arg0, arg1);\n}\nPFNGLATTACHSHADERPROC glad_debug_glAttachShader = glad_debug_impl_glAttachShader;\nPFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D;\nvoid APIENTRY glad_debug_impl_glFramebufferTexture2D(GLenum arg0, GLenum arg1, GLenum arg2, GLuint arg3, GLint arg4) {\n    _pre_call_callback(\"glFramebufferTexture2D\", (void*)glFramebufferTexture2D, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glFramebufferTexture2D(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glFramebufferTexture2D\", (void*)glFramebufferTexture2D, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLFRAMEBUFFERTEXTURE2DPROC glad_debug_glFramebufferTexture2D = glad_debug_impl_glFramebufferTexture2D;\nPFNGLFINISHPROC glad_glFinish;\nvoid APIENTRY glad_debug_impl_glFinish(void) {\n    _pre_call_callback(\"glFinish\", (void*)glFinish, 0);\n     glad_glFinish();\n    _post_call_callback(\"glFinish\", (void*)glFinish, 0);\n}\nPFNGLFINISHPROC glad_debug_glFinish = glad_debug_impl_glFinish;\nPFNGLDISABLEPROC glad_glDisable;\nvoid APIENTRY glad_debug_impl_glDisable(GLenum arg0) {\n    _pre_call_callback(\"glDisable\", (void*)glDisable, 1, arg0);\n     glad_glDisable(arg0);\n    _post_call_callback(\"glDisable\", (void*)glDisable, 1, arg0);\n}\nPFNGLDISABLEPROC glad_debug_glDisable = glad_debug_impl_glDisable;\nPFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv;\nvoid APIENTRY glad_debug_impl_glVertexAttribI4uiv(GLuint arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glVertexAttribI4uiv\", (void*)glVertexAttribI4uiv, 2, arg0, arg1);\n     glad_glVertexAttribI4uiv(arg0, arg1);\n    _post_call_callback(\"glVertexAttribI4uiv\", (void*)glVertexAttribI4uiv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIBI4UIVPROC glad_debug_glVertexAttribI4uiv = glad_debug_impl_glVertexAttribI4uiv;\nPFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer;\nvoid APIENTRY glad_debug_impl_glVertexAttribIPointer(GLuint arg0, GLint arg1, GLenum arg2, GLsizei arg3, const void * arg4) {\n    _pre_call_callback(\"glVertexAttribIPointer\", (void*)glVertexAttribIPointer, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glVertexAttribIPointer(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glVertexAttribIPointer\", (void*)glVertexAttribIPointer, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLVERTEXATTRIBIPOINTERPROC glad_debug_glVertexAttribIPointer = glad_debug_impl_glVertexAttribIPointer;\nPFNGLBLENDCOLORPROC glad_glBlendColor;\nvoid APIENTRY glad_debug_impl_glBlendColor(GLfloat arg0, GLfloat arg1, GLfloat arg2, GLfloat arg3) {\n    _pre_call_callback(\"glBlendColor\", (void*)glBlendColor, 4, arg0, arg1, arg2, arg3);\n     glad_glBlendColor(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glBlendColor\", (void*)glBlendColor, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLBLENDCOLORPROC glad_debug_glBlendColor = glad_debug_impl_glBlendColor;\nPFNGLBUFFERSUBDATAPROC glad_glBufferSubData;\nvoid APIENTRY glad_debug_impl_glBufferSubData(GLenum arg0, GLintptr arg1, GLsizeiptr arg2, const void * arg3) {\n    _pre_call_callback(\"glBufferSubData\", (void*)glBufferSubData, 4, arg0, arg1, arg2, arg3);\n     glad_glBufferSubData(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glBufferSubData\", (void*)glBufferSubData, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLBUFFERSUBDATAPROC glad_debug_glBufferSubData = glad_debug_impl_glBufferSubData;\nPFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample;\nvoid APIENTRY glad_debug_impl_glTexImage3DMultisample(GLenum arg0, GLsizei arg1, GLenum arg2, GLsizei arg3, GLsizei arg4, GLsizei arg5, GLboolean arg6) {\n    _pre_call_callback(\"glTexImage3DMultisample\", (void*)glTexImage3DMultisample, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n     glad_glTexImage3DMultisample(arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n    _post_call_callback(\"glTexImage3DMultisample\", (void*)glTexImage3DMultisample, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n}\nPFNGLTEXIMAGE3DMULTISAMPLEPROC glad_debug_glTexImage3DMultisample = glad_debug_impl_glTexImage3DMultisample;\nPFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv;\nvoid APIENTRY glad_debug_impl_glVertexAttribI4usv(GLuint arg0, const GLushort * arg1) {\n    _pre_call_callback(\"glVertexAttribI4usv\", (void*)glVertexAttribI4usv, 2, arg0, arg1);\n     glad_glVertexAttribI4usv(arg0, arg1);\n    _post_call_callback(\"glVertexAttribI4usv\", (void*)glVertexAttribI4usv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIBI4USVPROC glad_debug_glVertexAttribI4usv = glad_debug_impl_glVertexAttribI4usv;\nPFNGLUNIFORM3UIVPROC glad_glUniform3uiv;\nvoid APIENTRY glad_debug_impl_glUniform3uiv(GLint arg0, GLsizei arg1, const GLuint * arg2) {\n    _pre_call_callback(\"glUniform3uiv\", (void*)glUniform3uiv, 3, arg0, arg1, arg2);\n     glad_glUniform3uiv(arg0, arg1, arg2);\n    _post_call_callback(\"glUniform3uiv\", (void*)glUniform3uiv, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORM3UIVPROC glad_debug_glUniform3uiv = glad_debug_impl_glUniform3uiv;\nPFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv;\nvoid APIENTRY glad_debug_impl_glGetRenderbufferParameteriv(GLenum arg0, GLenum arg1, GLint * arg2) {\n    _pre_call_callback(\"glGetRenderbufferParameteriv\", (void*)glGetRenderbufferParameteriv, 3, arg0, arg1, arg2);\n     glad_glGetRenderbufferParameteriv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetRenderbufferParameteriv\", (void*)glGetRenderbufferParameteriv, 3, arg0, arg1, arg2);\n}\nPFNGLGETRENDERBUFFERPARAMETERIVPROC glad_debug_glGetRenderbufferParameteriv = glad_debug_impl_glGetRenderbufferParameteriv;\nPFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s;\nvoid APIENTRY glad_debug_impl_glVertexAttrib2s(GLuint arg0, GLshort arg1, GLshort arg2) {\n    _pre_call_callback(\"glVertexAttrib2s\", (void*)glVertexAttrib2s, 3, arg0, arg1, arg2);\n     glad_glVertexAttrib2s(arg0, arg1, arg2);\n    _post_call_callback(\"glVertexAttrib2s\", (void*)glVertexAttrib2s, 3, arg0, arg1, arg2);\n}\nPFNGLVERTEXATTRIB2SPROC glad_debug_glVertexAttrib2s = glad_debug_impl_glVertexAttrib2s;\nPFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv;\nvoid APIENTRY glad_debug_impl_glGetFramebufferAttachmentParameteriv(GLenum arg0, GLenum arg1, GLenum arg2, GLint * arg3) {\n    _pre_call_callback(\"glGetFramebufferAttachmentParameteriv\", (void*)glGetFramebufferAttachmentParameteriv, 4, arg0, arg1, arg2, arg3);\n     glad_glGetFramebufferAttachmentParameteriv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetFramebufferAttachmentParameteriv\", (void*)glGetFramebufferAttachmentParameteriv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_debug_glGetFramebufferAttachmentParameteriv = glad_debug_impl_glGetFramebufferAttachmentParameteriv;\nPFNGLGETERRORPROC glad_glGetError;\nGLenum APIENTRY glad_debug_impl_glGetError(void) {\n    GLenum ret;\n    _pre_call_callback(\"glGetError\", (void*)glGetError, 0);\n    ret =  glad_glGetError();\n    _post_call_callback(\"glGetError\", (void*)glGetError, 0);\n    return ret;\n}\nPFNGLGETERRORPROC glad_debug_glGetError = glad_debug_impl_glGetError;\nPFNGLDISABLEIPROC glad_glDisablei;\nvoid APIENTRY glad_debug_impl_glDisablei(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glDisablei\", (void*)glDisablei, 2, arg0, arg1);\n     glad_glDisablei(arg0, arg1);\n    _post_call_callback(\"glDisablei\", (void*)glDisablei, 2, arg0, arg1);\n}\nPFNGLDISABLEIPROC glad_debug_glDisablei = glad_debug_impl_glDisablei;\nPFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d;\nvoid APIENTRY glad_debug_impl_glVertexAttrib2d(GLuint arg0, GLdouble arg1, GLdouble arg2) {\n    _pre_call_callback(\"glVertexAttrib2d\", (void*)glVertexAttrib2d, 3, arg0, arg1, arg2);\n     glad_glVertexAttrib2d(arg0, arg1, arg2);\n    _post_call_callback(\"glVertexAttrib2d\", (void*)glVertexAttrib2d, 3, arg0, arg1, arg2);\n}\nPFNGLVERTEXATTRIB2DPROC glad_debug_glVertexAttrib2d = glad_debug_impl_glVertexAttrib2d;\nPFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv;\nvoid APIENTRY glad_debug_impl_glGetVertexAttribPointerv(GLuint arg0, GLenum arg1, void ** arg2) {\n    _pre_call_callback(\"glGetVertexAttribPointerv\", (void*)glGetVertexAttribPointerv, 3, arg0, arg1, arg2);\n     glad_glGetVertexAttribPointerv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetVertexAttribPointerv\", (void*)glGetVertexAttribPointerv, 3, arg0, arg1, arg2);\n}\nPFNGLGETVERTEXATTRIBPOINTERVPROC glad_debug_glGetVertexAttribPointerv = glad_debug_impl_glGetVertexAttribPointerv;\nPFNGLTEXIMAGE1DPROC glad_glTexImage1D;\nvoid APIENTRY glad_debug_impl_glTexImage1D(GLenum arg0, GLint arg1, GLint arg2, GLsizei arg3, GLint arg4, GLenum arg5, GLenum arg6, const void * arg7) {\n    _pre_call_callback(\"glTexImage1D\", (void*)glTexImage1D, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n     glad_glTexImage1D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n    _post_call_callback(\"glTexImage1D\", (void*)glTexImage1D, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n}\nPFNGLTEXIMAGE1DPROC glad_debug_glTexImage1D = glad_debug_impl_glTexImage1D;\nPFNGLGETSTRINGPROC glad_glGetString;\nconst GLubyte * APIENTRY glad_debug_impl_glGetString(GLenum arg0) {\n    const GLubyte * ret;\n    _pre_call_callback(\"glGetString\", (void*)glGetString, 1, arg0);\n    ret =  glad_glGetString(arg0);\n    _post_call_callback(\"glGetString\", (void*)glGetString, 1, arg0);\n    return ret;\n}\nPFNGLGETSTRINGPROC glad_debug_glGetString = glad_debug_impl_glGetString;\nPFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv;\nvoid APIENTRY glad_debug_impl_glGetSamplerParameteriv(GLuint arg0, GLenum arg1, GLint * arg2) {\n    _pre_call_callback(\"glGetSamplerParameteriv\", (void*)glGetSamplerParameteriv, 3, arg0, arg1, arg2);\n     glad_glGetSamplerParameteriv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetSamplerParameteriv\", (void*)glGetSamplerParameteriv, 3, arg0, arg1, arg2);\n}\nPFNGLGETSAMPLERPARAMETERIVPROC glad_debug_glGetSamplerParameteriv = glad_debug_impl_glGetSamplerParameteriv;\nPFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib1fv(GLuint arg0, const GLfloat * arg1) {\n    _pre_call_callback(\"glVertexAttrib1fv\", (void*)glVertexAttrib1fv, 2, arg0, arg1);\n     glad_glVertexAttrib1fv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib1fv\", (void*)glVertexAttrib1fv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB1FVPROC glad_debug_glVertexAttrib1fv = glad_debug_impl_glVertexAttrib1fv;\nPFNGLGETUNIFORMFVPROC glad_glGetUniformfv;\nvoid APIENTRY glad_debug_impl_glGetUniformfv(GLuint arg0, GLint arg1, GLfloat * arg2) {\n    _pre_call_callback(\"glGetUniformfv\", (void*)glGetUniformfv, 3, arg0, arg1, arg2);\n     glad_glGetUniformfv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetUniformfv\", (void*)glGetUniformfv, 3, arg0, arg1, arg2);\n}\nPFNGLGETUNIFORMFVPROC glad_debug_glGetUniformfv = glad_debug_impl_glGetUniformfv;\nPFNGLDELETESAMPLERSPROC glad_glDeleteSamplers;\nvoid APIENTRY glad_debug_impl_glDeleteSamplers(GLsizei arg0, const GLuint * arg1) {\n    _pre_call_callback(\"glDeleteSamplers\", (void*)glDeleteSamplers, 2, arg0, arg1);\n     glad_glDeleteSamplers(arg0, arg1);\n    _post_call_callback(\"glDeleteSamplers\", (void*)glDeleteSamplers, 2, arg0, arg1);\n}\nPFNGLDELETESAMPLERSPROC glad_debug_glDeleteSamplers = glad_debug_impl_glDeleteSamplers;\nPFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv;\nvoid APIENTRY glad_debug_impl_glVertexAttribP2uiv(GLuint arg0, GLenum arg1, GLboolean arg2, const GLuint * arg3) {\n    _pre_call_callback(\"glVertexAttribP2uiv\", (void*)glVertexAttribP2uiv, 4, arg0, arg1, arg2, arg3);\n     glad_glVertexAttribP2uiv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glVertexAttribP2uiv\", (void*)glVertexAttribP2uiv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLVERTEXATTRIBP2UIVPROC glad_debug_glVertexAttribP2uiv = glad_debug_impl_glVertexAttribP2uiv;\nPFNGLUNIFORM1FVPROC glad_glUniform1fv;\nvoid APIENTRY glad_debug_impl_glUniform1fv(GLint arg0, GLsizei arg1, const GLfloat * arg2) {\n    _pre_call_callback(\"glUniform1fv\", (void*)glUniform1fv, 3, arg0, arg1, arg2);\n     glad_glUniform1fv(arg0, arg1, arg2);\n    _post_call_callback(\"glUniform1fv\", (void*)glUniform1fv, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORM1FVPROC glad_debug_glUniform1fv = glad_debug_impl_glUniform1fv;\nPFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex;\nvoid APIENTRY glad_debug_impl_glDrawRangeElementsBaseVertex(GLenum arg0, GLuint arg1, GLuint arg2, GLsizei arg3, GLenum arg4, const void * arg5, GLint arg6) {\n    _pre_call_callback(\"glDrawRangeElementsBaseVertex\", (void*)glDrawRangeElementsBaseVertex, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n     glad_glDrawRangeElementsBaseVertex(arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n    _post_call_callback(\"glDrawRangeElementsBaseVertex\", (void*)glDrawRangeElementsBaseVertex, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n}\nPFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_debug_glDrawRangeElementsBaseVertex = glad_debug_impl_glDrawRangeElementsBaseVertex;\nPFNGLUNIFORM4FVPROC glad_glUniform4fv;\nvoid APIENTRY glad_debug_impl_glUniform4fv(GLint arg0, GLsizei arg1, const GLfloat * arg2) {\n    _pre_call_callback(\"glUniform4fv\", (void*)glUniform4fv, 3, arg0, arg1, arg2);\n     glad_glUniform4fv(arg0, arg1, arg2);\n    _post_call_callback(\"glUniform4fv\", (void*)glUniform4fv, 3, arg0, arg1, arg2);\n}\nPFNGLUNIFORM4FVPROC glad_debug_glUniform4fv = glad_debug_impl_glUniform4fv;\nPFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D;\nvoid APIENTRY glad_debug_impl_glCopyTexSubImage3D(GLenum arg0, GLint arg1, GLint arg2, GLint arg3, GLint arg4, GLint arg5, GLint arg6, GLsizei arg7, GLsizei arg8) {\n    _pre_call_callback(\"glCopyTexSubImage3D\", (void*)glCopyTexSubImage3D, 9, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n     glad_glCopyTexSubImage3D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n    _post_call_callback(\"glCopyTexSubImage3D\", (void*)glCopyTexSubImage3D, 9, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n}\nPFNGLCOPYTEXSUBIMAGE3DPROC glad_debug_glCopyTexSubImage3D = glad_debug_impl_glCopyTexSubImage3D;\nPFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer;\nGLboolean APIENTRY glad_debug_impl_glIsFramebuffer(GLuint arg0) {\n    GLboolean ret;\n    _pre_call_callback(\"glIsFramebuffer\", (void*)glIsFramebuffer, 1, arg0);\n    ret =  glad_glIsFramebuffer(arg0);\n    _post_call_callback(\"glIsFramebuffer\", (void*)glIsFramebuffer, 1, arg0);\n    return ret;\n}\nPFNGLISFRAMEBUFFERPROC glad_debug_glIsFramebuffer = glad_debug_impl_glIsFramebuffer;\nPFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv;\nvoid APIENTRY glad_debug_impl_glSamplerParameterIiv(GLuint arg0, GLenum arg1, const GLint * arg2) {\n    _pre_call_callback(\"glSamplerParameterIiv\", (void*)glSamplerParameterIiv, 3, arg0, arg1, arg2);\n     glad_glSamplerParameterIiv(arg0, arg1, arg2);\n    _post_call_callback(\"glSamplerParameterIiv\", (void*)glSamplerParameterIiv, 3, arg0, arg1, arg2);\n}\nPFNGLSAMPLERPARAMETERIIVPROC glad_debug_glSamplerParameterIiv = glad_debug_impl_glSamplerParameterIiv;\nPFNGLUNIFORM3IPROC glad_glUniform3i;\nvoid APIENTRY glad_debug_impl_glUniform3i(GLint arg0, GLint arg1, GLint arg2, GLint arg3) {\n    _pre_call_callback(\"glUniform3i\", (void*)glUniform3i, 4, arg0, arg1, arg2, arg3);\n     glad_glUniform3i(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glUniform3i\", (void*)glUniform3i, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLUNIFORM3IPROC glad_debug_glUniform3i = glad_debug_impl_glUniform3i;\nPFNGLMULTITEXCOORDP4UIVPROC glad_glMultiTexCoordP4uiv;\nvoid APIENTRY glad_debug_impl_glMultiTexCoordP4uiv(GLenum arg0, GLenum arg1, const GLuint * arg2) {\n    _pre_call_callback(\"glMultiTexCoordP4uiv\", (void*)glMultiTexCoordP4uiv, 3, arg0, arg1, arg2);\n     glad_glMultiTexCoordP4uiv(arg0, arg1, arg2);\n    _post_call_callback(\"glMultiTexCoordP4uiv\", (void*)glMultiTexCoordP4uiv, 3, arg0, arg1, arg2);\n}\nPFNGLMULTITEXCOORDP4UIVPROC glad_debug_glMultiTexCoordP4uiv = glad_debug_impl_glMultiTexCoordP4uiv;\nPFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i;\nvoid APIENTRY glad_debug_impl_glVertexAttribI1i(GLuint arg0, GLint arg1) {\n    _pre_call_callback(\"glVertexAttribI1i\", (void*)glVertexAttribI1i, 2, arg0, arg1);\n     glad_glVertexAttribI1i(arg0, arg1);\n    _post_call_callback(\"glVertexAttribI1i\", (void*)glVertexAttribI1i, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIBI1IPROC glad_debug_glVertexAttribI1i = glad_debug_impl_glVertexAttribI1i;\nPFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4iv(GLuint arg0, const GLint * arg1) {\n    _pre_call_callback(\"glVertexAttrib4iv\", (void*)glVertexAttrib4iv, 2, arg0, arg1);\n     glad_glVertexAttrib4iv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib4iv\", (void*)glVertexAttrib4iv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB4IVPROC glad_debug_glVertexAttrib4iv = glad_debug_impl_glVertexAttrib4iv;\nPFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv;\nvoid APIENTRY glad_debug_impl_glPointParameteriv(GLenum arg0, const GLint * arg1) {\n    _pre_call_callback(\"glPointParameteriv\", (void*)glPointParameteriv, 2, arg0, arg1);\n     glad_glPointParameteriv(arg0, arg1);\n    _post_call_callback(\"glPointParameteriv\", (void*)glPointParameteriv, 2, arg0, arg1);\n}\nPFNGLPOINTPARAMETERIVPROC glad_debug_glPointParameteriv = glad_debug_impl_glPointParameteriv;\nPFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv;\nvoid APIENTRY glad_debug_impl_glGetBufferParameteriv(GLenum arg0, GLenum arg1, GLint * arg2) {\n    _pre_call_callback(\"glGetBufferParameteriv\", (void*)glGetBufferParameteriv, 3, arg0, arg1, arg2);\n     glad_glGetBufferParameteriv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetBufferParameteriv\", (void*)glGetBufferParameteriv, 3, arg0, arg1, arg2);\n}\nPFNGLGETBUFFERPARAMETERIVPROC glad_debug_glGetBufferParameteriv = glad_debug_impl_glGetBufferParameteriv;\nPFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation;\nGLint APIENTRY glad_debug_impl_glGetFragDataLocation(GLuint arg0, const GLchar * arg1) {\n    GLint ret;\n    _pre_call_callback(\"glGetFragDataLocation\", (void*)glGetFragDataLocation, 2, arg0, arg1);\n    ret =  glad_glGetFragDataLocation(arg0, arg1);\n    _post_call_callback(\"glGetFragDataLocation\", (void*)glGetFragDataLocation, 2, arg0, arg1);\n    return ret;\n}\nPFNGLGETFRAGDATALOCATIONPROC glad_debug_glGetFragDataLocation = glad_debug_impl_glGetFragDataLocation;\nPFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation;\nvoid APIENTRY glad_debug_impl_glBindFragDataLocation(GLuint arg0, GLuint arg1, const GLchar * arg2) {\n    _pre_call_callback(\"glBindFragDataLocation\", (void*)glBindFragDataLocation, 3, arg0, arg1, arg2);\n     glad_glBindFragDataLocation(arg0, arg1, arg2);\n    _post_call_callback(\"glBindFragDataLocation\", (void*)glBindFragDataLocation, 3, arg0, arg1, arg2);\n}\nPFNGLBINDFRAGDATALOCATIONPROC glad_debug_glBindFragDataLocation = glad_debug_impl_glBindFragDataLocation;\nPFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv;\nvoid APIENTRY glad_debug_impl_glGetVertexAttribfv(GLuint arg0, GLenum arg1, GLfloat * arg2) {\n    _pre_call_callback(\"glGetVertexAttribfv\", (void*)glGetVertexAttribfv, 3, arg0, arg1, arg2);\n     glad_glGetVertexAttribfv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetVertexAttribfv\", (void*)glGetVertexAttribfv, 3, arg0, arg1, arg2);\n}\nPFNGLGETVERTEXATTRIBFVPROC glad_debug_glGetVertexAttribfv = glad_debug_impl_glGetVertexAttribfv;\nPFNGLSCISSORPROC glad_glScissor;\nvoid APIENTRY glad_debug_impl_glScissor(GLint arg0, GLint arg1, GLsizei arg2, GLsizei arg3) {\n    _pre_call_callback(\"glScissor\", (void*)glScissor, 4, arg0, arg1, arg2, arg3);\n     glad_glScissor(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glScissor\", (void*)glScissor, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLSCISSORPROC glad_debug_glScissor = glad_debug_impl_glScissor;\nPFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v;\nvoid APIENTRY glad_debug_impl_glGetIntegeri_v(GLenum arg0, GLuint arg1, GLint * arg2) {\n    _pre_call_callback(\"glGetIntegeri_v\", (void*)glGetIntegeri_v, 3, arg0, arg1, arg2);\n     glad_glGetIntegeri_v(arg0, arg1, arg2);\n    _post_call_callback(\"glGetIntegeri_v\", (void*)glGetIntegeri_v, 3, arg0, arg1, arg2);\n}\nPFNGLGETINTEGERI_VPROC glad_debug_glGetIntegeri_v = glad_debug_impl_glGetIntegeri_v;\nPFNGLGETTEXIMAGEPROC glad_glGetTexImage;\nvoid APIENTRY glad_debug_impl_glGetTexImage(GLenum arg0, GLint arg1, GLenum arg2, GLenum arg3, void * arg4) {\n    _pre_call_callback(\"glGetTexImage\", (void*)glGetTexImage, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glGetTexImage(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glGetTexImage\", (void*)glGetTexImage, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLGETTEXIMAGEPROC glad_debug_glGetTexImage = glad_debug_impl_glGetTexImage;\nPFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv;\nvoid APIENTRY glad_debug_impl_glGetVertexAttribIiv(GLuint arg0, GLenum arg1, GLint * arg2) {\n    _pre_call_callback(\"glGetVertexAttribIiv\", (void*)glGetVertexAttribIiv, 3, arg0, arg1, arg2);\n     glad_glGetVertexAttribIiv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetVertexAttribIiv\", (void*)glGetVertexAttribIiv, 3, arg0, arg1, arg2);\n}\nPFNGLGETVERTEXATTRIBIIVPROC glad_debug_glGetVertexAttribIiv = glad_debug_impl_glGetVertexAttribIiv;\nPFNGLTEXIMAGE3DPROC glad_glTexImage3D;\nvoid APIENTRY glad_debug_impl_glTexImage3D(GLenum arg0, GLint arg1, GLint arg2, GLsizei arg3, GLsizei arg4, GLsizei arg5, GLint arg6, GLenum arg7, GLenum arg8, const void * arg9) {\n    _pre_call_callback(\"glTexImage3D\", (void*)glTexImage3D, 10, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n     glad_glTexImage3D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n    _post_call_callback(\"glTexImage3D\", (void*)glTexImage3D, 10, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n}\nPFNGLTEXIMAGE3DPROC glad_debug_glTexImage3D = glad_debug_impl_glTexImage3D;\nPFNGLVERTEXP2UIPROC glad_glVertexP2ui;\nvoid APIENTRY glad_debug_impl_glVertexP2ui(GLenum arg0, GLuint arg1) {\n    _pre_call_callback(\"glVertexP2ui\", (void*)glVertexP2ui, 2, arg0, arg1);\n     glad_glVertexP2ui(arg0, arg1);\n    _post_call_callback(\"glVertexP2ui\", (void*)glVertexP2ui, 2, arg0, arg1);\n}\nPFNGLVERTEXP2UIPROC glad_debug_glVertexP2ui = glad_debug_impl_glVertexP2ui;\nPFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex;\nvoid APIENTRY glad_debug_impl_glMultiDrawElementsBaseVertex(GLenum arg0, const GLsizei * arg1, GLenum arg2, const void *const* arg3, GLsizei arg4, const GLint * arg5) {\n    _pre_call_callback(\"glMultiDrawElementsBaseVertex\", (void*)glMultiDrawElementsBaseVertex, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n     glad_glMultiDrawElementsBaseVertex(arg0, arg1, arg2, arg3, arg4, arg5);\n    _post_call_callback(\"glMultiDrawElementsBaseVertex\", (void*)glMultiDrawElementsBaseVertex, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n}\nPFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_debug_glMultiDrawElementsBaseVertex = glad_debug_impl_glMultiDrawElementsBaseVertex;\nPFNGLISTEXTUREPROC glad_glIsTexture;\nGLboolean APIENTRY glad_debug_impl_glIsTexture(GLuint arg0) {\n    GLboolean ret;\n    _pre_call_callback(\"glIsTexture\", (void*)glIsTexture, 1, arg0);\n    ret =  glad_glIsTexture(arg0);\n    _post_call_callback(\"glIsTexture\", (void*)glIsTexture, 1, arg0);\n    return ret;\n}\nPFNGLISTEXTUREPROC glad_debug_glIsTexture = glad_debug_impl_glIsTexture;\nPFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer;\nvoid APIENTRY glad_debug_impl_glVertexAttribPointer(GLuint arg0, GLint arg1, GLenum arg2, GLboolean arg3, GLsizei arg4, const void * arg5) {\n    _pre_call_callback(\"glVertexAttribPointer\", (void*)glVertexAttribPointer, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n     glad_glVertexAttribPointer(arg0, arg1, arg2, arg3, arg4, arg5);\n    _post_call_callback(\"glVertexAttribPointer\", (void*)glVertexAttribPointer, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n}\nPFNGLVERTEXATTRIBPOINTERPROC glad_debug_glVertexAttribPointer = glad_debug_impl_glVertexAttribPointer;\nPFNGLGETUNIFORMIVPROC glad_glGetUniformiv;\nvoid APIENTRY glad_debug_impl_glGetUniformiv(GLuint arg0, GLint arg1, GLint * arg2) {\n    _pre_call_callback(\"glGetUniformiv\", (void*)glGetUniformiv, 3, arg0, arg1, arg2);\n     glad_glGetUniformiv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetUniformiv\", (void*)glGetUniformiv, 3, arg0, arg1, arg2);\n}\nPFNGLGETUNIFORMIVPROC glad_debug_glGetUniformiv = glad_debug_impl_glGetUniformiv;\nPFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate;\nvoid APIENTRY glad_debug_impl_glBlendFuncSeparate(GLenum arg0, GLenum arg1, GLenum arg2, GLenum arg3) {\n    _pre_call_callback(\"glBlendFuncSeparate\", (void*)glBlendFuncSeparate, 4, arg0, arg1, arg2, arg3);\n     glad_glBlendFuncSeparate(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glBlendFuncSeparate\", (void*)glBlendFuncSeparate, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLBLENDFUNCSEPARATEPROC glad_debug_glBlendFuncSeparate = glad_debug_impl_glBlendFuncSeparate;\nPFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv;\nvoid APIENTRY glad_debug_impl_glUniformMatrix3fv(GLint arg0, GLsizei arg1, GLboolean arg2, const GLfloat * arg3) {\n    _pre_call_callback(\"glUniformMatrix3fv\", (void*)glUniformMatrix3fv, 4, arg0, arg1, arg2, arg3);\n     glad_glUniformMatrix3fv(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glUniformMatrix3fv\", (void*)glUniformMatrix3fv, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLUNIFORMMATRIX3FVPROC glad_debug_glUniformMatrix3fv = glad_debug_impl_glUniformMatrix3fv;\nPFNGLISSAMPLERPROC glad_glIsSampler;\nGLboolean APIENTRY glad_debug_impl_glIsSampler(GLuint arg0) {\n    GLboolean ret;\n    _pre_call_callback(\"glIsSampler\", (void*)glIsSampler, 1, arg0);\n    ret =  glad_glIsSampler(arg0);\n    _post_call_callback(\"glIsSampler\", (void*)glIsSampler, 1, arg0);\n    return ret;\n}\nPFNGLISSAMPLERPROC glad_debug_glIsSampler = glad_debug_impl_glIsSampler;\nPFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv;\nvoid APIENTRY glad_debug_impl_glGetTexParameterfv(GLenum arg0, GLenum arg1, GLfloat * arg2) {\n    _pre_call_callback(\"glGetTexParameterfv\", (void*)glGetTexParameterfv, 3, arg0, arg1, arg2);\n     glad_glGetTexParameterfv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetTexParameterfv\", (void*)glGetTexParameterfv, 3, arg0, arg1, arg2);\n}\nPFNGLGETTEXPARAMETERFVPROC glad_debug_glGetTexParameterfv = glad_debug_impl_glGetTexParameterfv;\nPFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv;\nvoid APIENTRY glad_debug_impl_glVertexAttrib4Nsv(GLuint arg0, const GLshort * arg1) {\n    _pre_call_callback(\"glVertexAttrib4Nsv\", (void*)glVertexAttrib4Nsv, 2, arg0, arg1);\n     glad_glVertexAttrib4Nsv(arg0, arg1);\n    _post_call_callback(\"glVertexAttrib4Nsv\", (void*)glVertexAttrib4Nsv, 2, arg0, arg1);\n}\nPFNGLVERTEXATTRIB4NSVPROC glad_debug_glVertexAttrib4Nsv = glad_debug_impl_glVertexAttrib4Nsv;\nPFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i;\nvoid APIENTRY glad_debug_impl_glVertexAttribI2i(GLuint arg0, GLint arg1, GLint arg2) {\n    _pre_call_callback(\"glVertexAttribI2i\", (void*)glVertexAttribI2i, 3, arg0, arg1, arg2);\n     glad_glVertexAttribI2i(arg0, arg1, arg2);\n    _post_call_callback(\"glVertexAttribI2i\", (void*)glVertexAttribI2i, 3, arg0, arg1, arg2);\n}\nPFNGLVERTEXATTRIBI2IPROC glad_debug_glVertexAttribI2i = glad_debug_impl_glVertexAttribI2i;\nPFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui;\nvoid APIENTRY glad_debug_impl_glVertexAttribP2ui(GLuint arg0, GLenum arg1, GLboolean arg2, GLuint arg3) {\n    _pre_call_callback(\"glVertexAttribP2ui\", (void*)glVertexAttribP2ui, 4, arg0, arg1, arg2, arg3);\n     glad_glVertexAttribP2ui(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glVertexAttribP2ui\", (void*)glVertexAttribP2ui, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLVERTEXATTRIBP2UIPROC glad_debug_glVertexAttribP2ui = glad_debug_impl_glVertexAttribP2ui;\nPFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv;\nvoid APIENTRY glad_debug_impl_glGetTexParameterIuiv(GLenum arg0, GLenum arg1, GLuint * arg2) {\n    _pre_call_callback(\"glGetTexParameterIuiv\", (void*)glGetTexParameterIuiv, 3, arg0, arg1, arg2);\n     glad_glGetTexParameterIuiv(arg0, arg1, arg2);\n    _post_call_callback(\"glGetTexParameterIuiv\", (void*)glGetTexParameterIuiv, 3, arg0, arg1, arg2);\n}\nPFNGLGETTEXPARAMETERIUIVPROC glad_debug_glGetTexParameterIuiv = glad_debug_impl_glGetTexParameterIuiv;\nPFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui;\nvoid APIENTRY glad_debug_impl_glVertexAttribI3ui(GLuint arg0, GLuint arg1, GLuint arg2, GLuint arg3) {\n    _pre_call_callback(\"glVertexAttribI3ui\", (void*)glVertexAttribI3ui, 4, arg0, arg1, arg2, arg3);\n     glad_glVertexAttribI3ui(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glVertexAttribI3ui\", (void*)glVertexAttribI3ui, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLVERTEXATTRIBI3UIPROC glad_debug_glVertexAttribI3ui = glad_debug_impl_glVertexAttribI3ui;\nPFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D;\nvoid APIENTRY glad_debug_impl_glCopyTexImage1D(GLenum arg0, GLint arg1, GLenum arg2, GLint arg3, GLint arg4, GLsizei arg5, GLint arg6) {\n    _pre_call_callback(\"glCopyTexImage1D\", (void*)glCopyTexImage1D, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n     glad_glCopyTexImage1D(arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n    _post_call_callback(\"glCopyTexImage1D\", (void*)glCopyTexImage1D, 7, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n}\nPFNGLCOPYTEXIMAGE1DPROC glad_debug_glCopyTexImage1D = glad_debug_impl_glCopyTexImage1D;\nPFNGLGETDOUBLEVPROC glad_glGetDoublev;\nvoid APIENTRY glad_debug_impl_glGetDoublev(GLenum arg0, GLdouble * arg1) {\n    _pre_call_callback(\"glGetDoublev\", (void*)glGetDoublev, 2, arg0, arg1);\n     glad_glGetDoublev(arg0, arg1);\n    _post_call_callback(\"glGetDoublev\", (void*)glGetDoublev, 2, arg0, arg1);\n}\nPFNGLGETDOUBLEVPROC glad_debug_glGetDoublev = glad_debug_impl_glGetDoublev;\nint GLAD_GL_ARB_multisample;\nint GLAD_GL_ARB_copy_image;\nint GLAD_GL_KHR_debug;\nint GLAD_GL_ARB_robustness;\nint GLAD_GL_ARB_texture_storage;\nPFNGLCOPYIMAGESUBDATAPROC glad_glCopyImageSubData;\nvoid APIENTRY glad_debug_impl_glCopyImageSubData(GLuint arg0, GLenum arg1, GLint arg2, GLint arg3, GLint arg4, GLint arg5, GLuint arg6, GLenum arg7, GLint arg8, GLint arg9, GLint arg10, GLint arg11, GLsizei arg12, GLsizei arg13, GLsizei arg14) {\n    _pre_call_callback(\"glCopyImageSubData\", (void*)glCopyImageSubData, 15, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);\n     glad_glCopyImageSubData(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);\n    _post_call_callback(\"glCopyImageSubData\", (void*)glCopyImageSubData, 15, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);\n}\nPFNGLCOPYIMAGESUBDATAPROC glad_debug_glCopyImageSubData = glad_debug_impl_glCopyImageSubData;\nPFNGLSAMPLECOVERAGEARBPROC glad_glSampleCoverageARB;\nvoid APIENTRY glad_debug_impl_glSampleCoverageARB(GLfloat arg0, GLboolean arg1) {\n    _pre_call_callback(\"glSampleCoverageARB\", (void*)glSampleCoverageARB, 2, arg0, arg1);\n     glad_glSampleCoverageARB(arg0, arg1);\n    _post_call_callback(\"glSampleCoverageARB\", (void*)glSampleCoverageARB, 2, arg0, arg1);\n}\nPFNGLSAMPLECOVERAGEARBPROC glad_debug_glSampleCoverageARB = glad_debug_impl_glSampleCoverageARB;\nPFNGLGETGRAPHICSRESETSTATUSARBPROC glad_glGetGraphicsResetStatusARB;\nGLenum APIENTRY glad_debug_impl_glGetGraphicsResetStatusARB(void) {\n    GLenum ret;\n    _pre_call_callback(\"glGetGraphicsResetStatusARB\", (void*)glGetGraphicsResetStatusARB, 0);\n    ret =  glad_glGetGraphicsResetStatusARB();\n    _post_call_callback(\"glGetGraphicsResetStatusARB\", (void*)glGetGraphicsResetStatusARB, 0);\n    return ret;\n}\nPFNGLGETGRAPHICSRESETSTATUSARBPROC glad_debug_glGetGraphicsResetStatusARB = glad_debug_impl_glGetGraphicsResetStatusARB;\nPFNGLGETNTEXIMAGEARBPROC glad_glGetnTexImageARB;\nvoid APIENTRY glad_debug_impl_glGetnTexImageARB(GLenum arg0, GLint arg1, GLenum arg2, GLenum arg3, GLsizei arg4, void * arg5) {\n    _pre_call_callback(\"glGetnTexImageARB\", (void*)glGetnTexImageARB, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n     glad_glGetnTexImageARB(arg0, arg1, arg2, arg3, arg4, arg5);\n    _post_call_callback(\"glGetnTexImageARB\", (void*)glGetnTexImageARB, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n}\nPFNGLGETNTEXIMAGEARBPROC glad_debug_glGetnTexImageARB = glad_debug_impl_glGetnTexImageARB;\nPFNGLREADNPIXELSARBPROC glad_glReadnPixelsARB;\nvoid APIENTRY glad_debug_impl_glReadnPixelsARB(GLint arg0, GLint arg1, GLsizei arg2, GLsizei arg3, GLenum arg4, GLenum arg5, GLsizei arg6, void * arg7) {\n    _pre_call_callback(\"glReadnPixelsARB\", (void*)glReadnPixelsARB, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n     glad_glReadnPixelsARB(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n    _post_call_callback(\"glReadnPixelsARB\", (void*)glReadnPixelsARB, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n}\nPFNGLREADNPIXELSARBPROC glad_debug_glReadnPixelsARB = glad_debug_impl_glReadnPixelsARB;\nPFNGLGETNCOMPRESSEDTEXIMAGEARBPROC glad_glGetnCompressedTexImageARB;\nvoid APIENTRY glad_debug_impl_glGetnCompressedTexImageARB(GLenum arg0, GLint arg1, GLsizei arg2, void * arg3) {\n    _pre_call_callback(\"glGetnCompressedTexImageARB\", (void*)glGetnCompressedTexImageARB, 4, arg0, arg1, arg2, arg3);\n     glad_glGetnCompressedTexImageARB(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetnCompressedTexImageARB\", (void*)glGetnCompressedTexImageARB, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETNCOMPRESSEDTEXIMAGEARBPROC glad_debug_glGetnCompressedTexImageARB = glad_debug_impl_glGetnCompressedTexImageARB;\nPFNGLGETNUNIFORMFVARBPROC glad_glGetnUniformfvARB;\nvoid APIENTRY glad_debug_impl_glGetnUniformfvARB(GLuint arg0, GLint arg1, GLsizei arg2, GLfloat * arg3) {\n    _pre_call_callback(\"glGetnUniformfvARB\", (void*)glGetnUniformfvARB, 4, arg0, arg1, arg2, arg3);\n     glad_glGetnUniformfvARB(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetnUniformfvARB\", (void*)glGetnUniformfvARB, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETNUNIFORMFVARBPROC glad_debug_glGetnUniformfvARB = glad_debug_impl_glGetnUniformfvARB;\nPFNGLGETNUNIFORMIVARBPROC glad_glGetnUniformivARB;\nvoid APIENTRY glad_debug_impl_glGetnUniformivARB(GLuint arg0, GLint arg1, GLsizei arg2, GLint * arg3) {\n    _pre_call_callback(\"glGetnUniformivARB\", (void*)glGetnUniformivARB, 4, arg0, arg1, arg2, arg3);\n     glad_glGetnUniformivARB(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetnUniformivARB\", (void*)glGetnUniformivARB, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETNUNIFORMIVARBPROC glad_debug_glGetnUniformivARB = glad_debug_impl_glGetnUniformivARB;\nPFNGLGETNUNIFORMUIVARBPROC glad_glGetnUniformuivARB;\nvoid APIENTRY glad_debug_impl_glGetnUniformuivARB(GLuint arg0, GLint arg1, GLsizei arg2, GLuint * arg3) {\n    _pre_call_callback(\"glGetnUniformuivARB\", (void*)glGetnUniformuivARB, 4, arg0, arg1, arg2, arg3);\n     glad_glGetnUniformuivARB(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetnUniformuivARB\", (void*)glGetnUniformuivARB, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETNUNIFORMUIVARBPROC glad_debug_glGetnUniformuivARB = glad_debug_impl_glGetnUniformuivARB;\nPFNGLGETNUNIFORMDVARBPROC glad_glGetnUniformdvARB;\nvoid APIENTRY glad_debug_impl_glGetnUniformdvARB(GLuint arg0, GLint arg1, GLsizei arg2, GLdouble * arg3) {\n    _pre_call_callback(\"glGetnUniformdvARB\", (void*)glGetnUniformdvARB, 4, arg0, arg1, arg2, arg3);\n     glad_glGetnUniformdvARB(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetnUniformdvARB\", (void*)glGetnUniformdvARB, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETNUNIFORMDVARBPROC glad_debug_glGetnUniformdvARB = glad_debug_impl_glGetnUniformdvARB;\nPFNGLGETNMAPDVARBPROC glad_glGetnMapdvARB;\nvoid APIENTRY glad_debug_impl_glGetnMapdvARB(GLenum arg0, GLenum arg1, GLsizei arg2, GLdouble * arg3) {\n    _pre_call_callback(\"glGetnMapdvARB\", (void*)glGetnMapdvARB, 4, arg0, arg1, arg2, arg3);\n     glad_glGetnMapdvARB(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetnMapdvARB\", (void*)glGetnMapdvARB, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETNMAPDVARBPROC glad_debug_glGetnMapdvARB = glad_debug_impl_glGetnMapdvARB;\nPFNGLGETNMAPFVARBPROC glad_glGetnMapfvARB;\nvoid APIENTRY glad_debug_impl_glGetnMapfvARB(GLenum arg0, GLenum arg1, GLsizei arg2, GLfloat * arg3) {\n    _pre_call_callback(\"glGetnMapfvARB\", (void*)glGetnMapfvARB, 4, arg0, arg1, arg2, arg3);\n     glad_glGetnMapfvARB(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetnMapfvARB\", (void*)glGetnMapfvARB, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETNMAPFVARBPROC glad_debug_glGetnMapfvARB = glad_debug_impl_glGetnMapfvARB;\nPFNGLGETNMAPIVARBPROC glad_glGetnMapivARB;\nvoid APIENTRY glad_debug_impl_glGetnMapivARB(GLenum arg0, GLenum arg1, GLsizei arg2, GLint * arg3) {\n    _pre_call_callback(\"glGetnMapivARB\", (void*)glGetnMapivARB, 4, arg0, arg1, arg2, arg3);\n     glad_glGetnMapivARB(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetnMapivARB\", (void*)glGetnMapivARB, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETNMAPIVARBPROC glad_debug_glGetnMapivARB = glad_debug_impl_glGetnMapivARB;\nPFNGLGETNPIXELMAPFVARBPROC glad_glGetnPixelMapfvARB;\nvoid APIENTRY glad_debug_impl_glGetnPixelMapfvARB(GLenum arg0, GLsizei arg1, GLfloat * arg2) {\n    _pre_call_callback(\"glGetnPixelMapfvARB\", (void*)glGetnPixelMapfvARB, 3, arg0, arg1, arg2);\n     glad_glGetnPixelMapfvARB(arg0, arg1, arg2);\n    _post_call_callback(\"glGetnPixelMapfvARB\", (void*)glGetnPixelMapfvARB, 3, arg0, arg1, arg2);\n}\nPFNGLGETNPIXELMAPFVARBPROC glad_debug_glGetnPixelMapfvARB = glad_debug_impl_glGetnPixelMapfvARB;\nPFNGLGETNPIXELMAPUIVARBPROC glad_glGetnPixelMapuivARB;\nvoid APIENTRY glad_debug_impl_glGetnPixelMapuivARB(GLenum arg0, GLsizei arg1, GLuint * arg2) {\n    _pre_call_callback(\"glGetnPixelMapuivARB\", (void*)glGetnPixelMapuivARB, 3, arg0, arg1, arg2);\n     glad_glGetnPixelMapuivARB(arg0, arg1, arg2);\n    _post_call_callback(\"glGetnPixelMapuivARB\", (void*)glGetnPixelMapuivARB, 3, arg0, arg1, arg2);\n}\nPFNGLGETNPIXELMAPUIVARBPROC glad_debug_glGetnPixelMapuivARB = glad_debug_impl_glGetnPixelMapuivARB;\nPFNGLGETNPIXELMAPUSVARBPROC glad_glGetnPixelMapusvARB;\nvoid APIENTRY glad_debug_impl_glGetnPixelMapusvARB(GLenum arg0, GLsizei arg1, GLushort * arg2) {\n    _pre_call_callback(\"glGetnPixelMapusvARB\", (void*)glGetnPixelMapusvARB, 3, arg0, arg1, arg2);\n     glad_glGetnPixelMapusvARB(arg0, arg1, arg2);\n    _post_call_callback(\"glGetnPixelMapusvARB\", (void*)glGetnPixelMapusvARB, 3, arg0, arg1, arg2);\n}\nPFNGLGETNPIXELMAPUSVARBPROC glad_debug_glGetnPixelMapusvARB = glad_debug_impl_glGetnPixelMapusvARB;\nPFNGLGETNPOLYGONSTIPPLEARBPROC glad_glGetnPolygonStippleARB;\nvoid APIENTRY glad_debug_impl_glGetnPolygonStippleARB(GLsizei arg0, GLubyte * arg1) {\n    _pre_call_callback(\"glGetnPolygonStippleARB\", (void*)glGetnPolygonStippleARB, 2, arg0, arg1);\n     glad_glGetnPolygonStippleARB(arg0, arg1);\n    _post_call_callback(\"glGetnPolygonStippleARB\", (void*)glGetnPolygonStippleARB, 2, arg0, arg1);\n}\nPFNGLGETNPOLYGONSTIPPLEARBPROC glad_debug_glGetnPolygonStippleARB = glad_debug_impl_glGetnPolygonStippleARB;\nPFNGLGETNCOLORTABLEARBPROC glad_glGetnColorTableARB;\nvoid APIENTRY glad_debug_impl_glGetnColorTableARB(GLenum arg0, GLenum arg1, GLenum arg2, GLsizei arg3, void * arg4) {\n    _pre_call_callback(\"glGetnColorTableARB\", (void*)glGetnColorTableARB, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glGetnColorTableARB(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glGetnColorTableARB\", (void*)glGetnColorTableARB, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLGETNCOLORTABLEARBPROC glad_debug_glGetnColorTableARB = glad_debug_impl_glGetnColorTableARB;\nPFNGLGETNCONVOLUTIONFILTERARBPROC glad_glGetnConvolutionFilterARB;\nvoid APIENTRY glad_debug_impl_glGetnConvolutionFilterARB(GLenum arg0, GLenum arg1, GLenum arg2, GLsizei arg3, void * arg4) {\n    _pre_call_callback(\"glGetnConvolutionFilterARB\", (void*)glGetnConvolutionFilterARB, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glGetnConvolutionFilterARB(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glGetnConvolutionFilterARB\", (void*)glGetnConvolutionFilterARB, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLGETNCONVOLUTIONFILTERARBPROC glad_debug_glGetnConvolutionFilterARB = glad_debug_impl_glGetnConvolutionFilterARB;\nPFNGLGETNSEPARABLEFILTERARBPROC glad_glGetnSeparableFilterARB;\nvoid APIENTRY glad_debug_impl_glGetnSeparableFilterARB(GLenum arg0, GLenum arg1, GLenum arg2, GLsizei arg3, void * arg4, GLsizei arg5, void * arg6, void * arg7) {\n    _pre_call_callback(\"glGetnSeparableFilterARB\", (void*)glGetnSeparableFilterARB, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n     glad_glGetnSeparableFilterARB(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n    _post_call_callback(\"glGetnSeparableFilterARB\", (void*)glGetnSeparableFilterARB, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n}\nPFNGLGETNSEPARABLEFILTERARBPROC glad_debug_glGetnSeparableFilterARB = glad_debug_impl_glGetnSeparableFilterARB;\nPFNGLGETNHISTOGRAMARBPROC glad_glGetnHistogramARB;\nvoid APIENTRY glad_debug_impl_glGetnHistogramARB(GLenum arg0, GLboolean arg1, GLenum arg2, GLenum arg3, GLsizei arg4, void * arg5) {\n    _pre_call_callback(\"glGetnHistogramARB\", (void*)glGetnHistogramARB, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n     glad_glGetnHistogramARB(arg0, arg1, arg2, arg3, arg4, arg5);\n    _post_call_callback(\"glGetnHistogramARB\", (void*)glGetnHistogramARB, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n}\nPFNGLGETNHISTOGRAMARBPROC glad_debug_glGetnHistogramARB = glad_debug_impl_glGetnHistogramARB;\nPFNGLGETNMINMAXARBPROC glad_glGetnMinmaxARB;\nvoid APIENTRY glad_debug_impl_glGetnMinmaxARB(GLenum arg0, GLboolean arg1, GLenum arg2, GLenum arg3, GLsizei arg4, void * arg5) {\n    _pre_call_callback(\"glGetnMinmaxARB\", (void*)glGetnMinmaxARB, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n     glad_glGetnMinmaxARB(arg0, arg1, arg2, arg3, arg4, arg5);\n    _post_call_callback(\"glGetnMinmaxARB\", (void*)glGetnMinmaxARB, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n}\nPFNGLGETNMINMAXARBPROC glad_debug_glGetnMinmaxARB = glad_debug_impl_glGetnMinmaxARB;\nPFNGLTEXSTORAGE1DPROC glad_glTexStorage1D;\nvoid APIENTRY glad_debug_impl_glTexStorage1D(GLenum arg0, GLsizei arg1, GLenum arg2, GLsizei arg3) {\n    _pre_call_callback(\"glTexStorage1D\", (void*)glTexStorage1D, 4, arg0, arg1, arg2, arg3);\n     glad_glTexStorage1D(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glTexStorage1D\", (void*)glTexStorage1D, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLTEXSTORAGE1DPROC glad_debug_glTexStorage1D = glad_debug_impl_glTexStorage1D;\nPFNGLTEXSTORAGE2DPROC glad_glTexStorage2D;\nvoid APIENTRY glad_debug_impl_glTexStorage2D(GLenum arg0, GLsizei arg1, GLenum arg2, GLsizei arg3, GLsizei arg4) {\n    _pre_call_callback(\"glTexStorage2D\", (void*)glTexStorage2D, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glTexStorage2D(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glTexStorage2D\", (void*)glTexStorage2D, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLTEXSTORAGE2DPROC glad_debug_glTexStorage2D = glad_debug_impl_glTexStorage2D;\nPFNGLTEXSTORAGE3DPROC glad_glTexStorage3D;\nvoid APIENTRY glad_debug_impl_glTexStorage3D(GLenum arg0, GLsizei arg1, GLenum arg2, GLsizei arg3, GLsizei arg4, GLsizei arg5) {\n    _pre_call_callback(\"glTexStorage3D\", (void*)glTexStorage3D, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n     glad_glTexStorage3D(arg0, arg1, arg2, arg3, arg4, arg5);\n    _post_call_callback(\"glTexStorage3D\", (void*)glTexStorage3D, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n}\nPFNGLTEXSTORAGE3DPROC glad_debug_glTexStorage3D = glad_debug_impl_glTexStorage3D;\nPFNGLDEBUGMESSAGECONTROLPROC glad_glDebugMessageControl;\nvoid APIENTRY glad_debug_impl_glDebugMessageControl(GLenum arg0, GLenum arg1, GLenum arg2, GLsizei arg3, const GLuint * arg4, GLboolean arg5) {\n    _pre_call_callback(\"glDebugMessageControl\", (void*)glDebugMessageControl, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n     glad_glDebugMessageControl(arg0, arg1, arg2, arg3, arg4, arg5);\n    _post_call_callback(\"glDebugMessageControl\", (void*)glDebugMessageControl, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n}\nPFNGLDEBUGMESSAGECONTROLPROC glad_debug_glDebugMessageControl = glad_debug_impl_glDebugMessageControl;\nPFNGLDEBUGMESSAGEINSERTPROC glad_glDebugMessageInsert;\nvoid APIENTRY glad_debug_impl_glDebugMessageInsert(GLenum arg0, GLenum arg1, GLuint arg2, GLenum arg3, GLsizei arg4, const GLchar * arg5) {\n    _pre_call_callback(\"glDebugMessageInsert\", (void*)glDebugMessageInsert, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n     glad_glDebugMessageInsert(arg0, arg1, arg2, arg3, arg4, arg5);\n    _post_call_callback(\"glDebugMessageInsert\", (void*)glDebugMessageInsert, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n}\nPFNGLDEBUGMESSAGEINSERTPROC glad_debug_glDebugMessageInsert = glad_debug_impl_glDebugMessageInsert;\nPFNGLDEBUGMESSAGECALLBACKPROC glad_glDebugMessageCallback;\nvoid APIENTRY glad_debug_impl_glDebugMessageCallback(GLDEBUGPROC arg0, const void * arg1) {\n    _pre_call_callback(\"glDebugMessageCallback\", (void*)glDebugMessageCallback, 2, arg0, arg1);\n     glad_glDebugMessageCallback(arg0, arg1);\n    _post_call_callback(\"glDebugMessageCallback\", (void*)glDebugMessageCallback, 2, arg0, arg1);\n}\nPFNGLDEBUGMESSAGECALLBACKPROC glad_debug_glDebugMessageCallback = glad_debug_impl_glDebugMessageCallback;\nPFNGLGETDEBUGMESSAGELOGPROC glad_glGetDebugMessageLog;\nGLuint APIENTRY glad_debug_impl_glGetDebugMessageLog(GLuint arg0, GLsizei arg1, GLenum * arg2, GLenum * arg3, GLuint * arg4, GLenum * arg5, GLsizei * arg6, GLchar * arg7) {\n    GLuint ret;\n    _pre_call_callback(\"glGetDebugMessageLog\", (void*)glGetDebugMessageLog, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n    ret =  glad_glGetDebugMessageLog(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n    _post_call_callback(\"glGetDebugMessageLog\", (void*)glGetDebugMessageLog, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n    return ret;\n}\nPFNGLGETDEBUGMESSAGELOGPROC glad_debug_glGetDebugMessageLog = glad_debug_impl_glGetDebugMessageLog;\nPFNGLPUSHDEBUGGROUPPROC glad_glPushDebugGroup;\nvoid APIENTRY glad_debug_impl_glPushDebugGroup(GLenum arg0, GLuint arg1, GLsizei arg2, const GLchar * arg3) {\n    _pre_call_callback(\"glPushDebugGroup\", (void*)glPushDebugGroup, 4, arg0, arg1, arg2, arg3);\n     glad_glPushDebugGroup(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glPushDebugGroup\", (void*)glPushDebugGroup, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLPUSHDEBUGGROUPPROC glad_debug_glPushDebugGroup = glad_debug_impl_glPushDebugGroup;\nPFNGLPOPDEBUGGROUPPROC glad_glPopDebugGroup;\nvoid APIENTRY glad_debug_impl_glPopDebugGroup(void) {\n    _pre_call_callback(\"glPopDebugGroup\", (void*)glPopDebugGroup, 0);\n     glad_glPopDebugGroup();\n    _post_call_callback(\"glPopDebugGroup\", (void*)glPopDebugGroup, 0);\n}\nPFNGLPOPDEBUGGROUPPROC glad_debug_glPopDebugGroup = glad_debug_impl_glPopDebugGroup;\nPFNGLOBJECTLABELPROC glad_glObjectLabel;\nvoid APIENTRY glad_debug_impl_glObjectLabel(GLenum arg0, GLuint arg1, GLsizei arg2, const GLchar * arg3) {\n    _pre_call_callback(\"glObjectLabel\", (void*)glObjectLabel, 4, arg0, arg1, arg2, arg3);\n     glad_glObjectLabel(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glObjectLabel\", (void*)glObjectLabel, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLOBJECTLABELPROC glad_debug_glObjectLabel = glad_debug_impl_glObjectLabel;\nPFNGLGETOBJECTLABELPROC glad_glGetObjectLabel;\nvoid APIENTRY glad_debug_impl_glGetObjectLabel(GLenum arg0, GLuint arg1, GLsizei arg2, GLsizei * arg3, GLchar * arg4) {\n    _pre_call_callback(\"glGetObjectLabel\", (void*)glGetObjectLabel, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glGetObjectLabel(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glGetObjectLabel\", (void*)glGetObjectLabel, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLGETOBJECTLABELPROC glad_debug_glGetObjectLabel = glad_debug_impl_glGetObjectLabel;\nPFNGLOBJECTPTRLABELPROC glad_glObjectPtrLabel;\nvoid APIENTRY glad_debug_impl_glObjectPtrLabel(const void * arg0, GLsizei arg1, const GLchar * arg2) {\n    _pre_call_callback(\"glObjectPtrLabel\", (void*)glObjectPtrLabel, 3, arg0, arg1, arg2);\n     glad_glObjectPtrLabel(arg0, arg1, arg2);\n    _post_call_callback(\"glObjectPtrLabel\", (void*)glObjectPtrLabel, 3, arg0, arg1, arg2);\n}\nPFNGLOBJECTPTRLABELPROC glad_debug_glObjectPtrLabel = glad_debug_impl_glObjectPtrLabel;\nPFNGLGETOBJECTPTRLABELPROC glad_glGetObjectPtrLabel;\nvoid APIENTRY glad_debug_impl_glGetObjectPtrLabel(const void * arg0, GLsizei arg1, GLsizei * arg2, GLchar * arg3) {\n    _pre_call_callback(\"glGetObjectPtrLabel\", (void*)glGetObjectPtrLabel, 4, arg0, arg1, arg2, arg3);\n     glad_glGetObjectPtrLabel(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetObjectPtrLabel\", (void*)glGetObjectPtrLabel, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETOBJECTPTRLABELPROC glad_debug_glGetObjectPtrLabel = glad_debug_impl_glGetObjectPtrLabel;\nPFNGLGETPOINTERVPROC glad_glGetPointerv;\nvoid APIENTRY glad_debug_impl_glGetPointerv(GLenum arg0, void ** arg1) {\n    _pre_call_callback(\"glGetPointerv\", (void*)glGetPointerv, 2, arg0, arg1);\n     glad_glGetPointerv(arg0, arg1);\n    _post_call_callback(\"glGetPointerv\", (void*)glGetPointerv, 2, arg0, arg1);\n}\nPFNGLGETPOINTERVPROC glad_debug_glGetPointerv = glad_debug_impl_glGetPointerv;\nPFNGLDEBUGMESSAGECONTROLKHRPROC glad_glDebugMessageControlKHR;\nvoid APIENTRY glad_debug_impl_glDebugMessageControlKHR(GLenum arg0, GLenum arg1, GLenum arg2, GLsizei arg3, const GLuint * arg4, GLboolean arg5) {\n    _pre_call_callback(\"glDebugMessageControlKHR\", (void*)glDebugMessageControlKHR, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n     glad_glDebugMessageControlKHR(arg0, arg1, arg2, arg3, arg4, arg5);\n    _post_call_callback(\"glDebugMessageControlKHR\", (void*)glDebugMessageControlKHR, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n}\nPFNGLDEBUGMESSAGECONTROLKHRPROC glad_debug_glDebugMessageControlKHR = glad_debug_impl_glDebugMessageControlKHR;\nPFNGLDEBUGMESSAGEINSERTKHRPROC glad_glDebugMessageInsertKHR;\nvoid APIENTRY glad_debug_impl_glDebugMessageInsertKHR(GLenum arg0, GLenum arg1, GLuint arg2, GLenum arg3, GLsizei arg4, const GLchar * arg5) {\n    _pre_call_callback(\"glDebugMessageInsertKHR\", (void*)glDebugMessageInsertKHR, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n     glad_glDebugMessageInsertKHR(arg0, arg1, arg2, arg3, arg4, arg5);\n    _post_call_callback(\"glDebugMessageInsertKHR\", (void*)glDebugMessageInsertKHR, 6, arg0, arg1, arg2, arg3, arg4, arg5);\n}\nPFNGLDEBUGMESSAGEINSERTKHRPROC glad_debug_glDebugMessageInsertKHR = glad_debug_impl_glDebugMessageInsertKHR;\nPFNGLDEBUGMESSAGECALLBACKKHRPROC glad_glDebugMessageCallbackKHR;\nvoid APIENTRY glad_debug_impl_glDebugMessageCallbackKHR(GLDEBUGPROCKHR arg0, const void * arg1) {\n    _pre_call_callback(\"glDebugMessageCallbackKHR\", (void*)glDebugMessageCallbackKHR, 2, arg0, arg1);\n     glad_glDebugMessageCallbackKHR(arg0, arg1);\n    _post_call_callback(\"glDebugMessageCallbackKHR\", (void*)glDebugMessageCallbackKHR, 2, arg0, arg1);\n}\nPFNGLDEBUGMESSAGECALLBACKKHRPROC glad_debug_glDebugMessageCallbackKHR = glad_debug_impl_glDebugMessageCallbackKHR;\nPFNGLGETDEBUGMESSAGELOGKHRPROC glad_glGetDebugMessageLogKHR;\nGLuint APIENTRY glad_debug_impl_glGetDebugMessageLogKHR(GLuint arg0, GLsizei arg1, GLenum * arg2, GLenum * arg3, GLuint * arg4, GLenum * arg5, GLsizei * arg6, GLchar * arg7) {\n    GLuint ret;\n    _pre_call_callback(\"glGetDebugMessageLogKHR\", (void*)glGetDebugMessageLogKHR, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n    ret =  glad_glGetDebugMessageLogKHR(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n    _post_call_callback(\"glGetDebugMessageLogKHR\", (void*)glGetDebugMessageLogKHR, 8, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n    return ret;\n}\nPFNGLGETDEBUGMESSAGELOGKHRPROC glad_debug_glGetDebugMessageLogKHR = glad_debug_impl_glGetDebugMessageLogKHR;\nPFNGLPUSHDEBUGGROUPKHRPROC glad_glPushDebugGroupKHR;\nvoid APIENTRY glad_debug_impl_glPushDebugGroupKHR(GLenum arg0, GLuint arg1, GLsizei arg2, const GLchar * arg3) {\n    _pre_call_callback(\"glPushDebugGroupKHR\", (void*)glPushDebugGroupKHR, 4, arg0, arg1, arg2, arg3);\n     glad_glPushDebugGroupKHR(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glPushDebugGroupKHR\", (void*)glPushDebugGroupKHR, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLPUSHDEBUGGROUPKHRPROC glad_debug_glPushDebugGroupKHR = glad_debug_impl_glPushDebugGroupKHR;\nPFNGLPOPDEBUGGROUPKHRPROC glad_glPopDebugGroupKHR;\nvoid APIENTRY glad_debug_impl_glPopDebugGroupKHR(void) {\n    _pre_call_callback(\"glPopDebugGroupKHR\", (void*)glPopDebugGroupKHR, 0);\n     glad_glPopDebugGroupKHR();\n    _post_call_callback(\"glPopDebugGroupKHR\", (void*)glPopDebugGroupKHR, 0);\n}\nPFNGLPOPDEBUGGROUPKHRPROC glad_debug_glPopDebugGroupKHR = glad_debug_impl_glPopDebugGroupKHR;\nPFNGLOBJECTLABELKHRPROC glad_glObjectLabelKHR;\nvoid APIENTRY glad_debug_impl_glObjectLabelKHR(GLenum arg0, GLuint arg1, GLsizei arg2, const GLchar * arg3) {\n    _pre_call_callback(\"glObjectLabelKHR\", (void*)glObjectLabelKHR, 4, arg0, arg1, arg2, arg3);\n     glad_glObjectLabelKHR(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glObjectLabelKHR\", (void*)glObjectLabelKHR, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLOBJECTLABELKHRPROC glad_debug_glObjectLabelKHR = glad_debug_impl_glObjectLabelKHR;\nPFNGLGETOBJECTLABELKHRPROC glad_glGetObjectLabelKHR;\nvoid APIENTRY glad_debug_impl_glGetObjectLabelKHR(GLenum arg0, GLuint arg1, GLsizei arg2, GLsizei * arg3, GLchar * arg4) {\n    _pre_call_callback(\"glGetObjectLabelKHR\", (void*)glGetObjectLabelKHR, 5, arg0, arg1, arg2, arg3, arg4);\n     glad_glGetObjectLabelKHR(arg0, arg1, arg2, arg3, arg4);\n    _post_call_callback(\"glGetObjectLabelKHR\", (void*)glGetObjectLabelKHR, 5, arg0, arg1, arg2, arg3, arg4);\n}\nPFNGLGETOBJECTLABELKHRPROC glad_debug_glGetObjectLabelKHR = glad_debug_impl_glGetObjectLabelKHR;\nPFNGLOBJECTPTRLABELKHRPROC glad_glObjectPtrLabelKHR;\nvoid APIENTRY glad_debug_impl_glObjectPtrLabelKHR(const void * arg0, GLsizei arg1, const GLchar * arg2) {\n    _pre_call_callback(\"glObjectPtrLabelKHR\", (void*)glObjectPtrLabelKHR, 3, arg0, arg1, arg2);\n     glad_glObjectPtrLabelKHR(arg0, arg1, arg2);\n    _post_call_callback(\"glObjectPtrLabelKHR\", (void*)glObjectPtrLabelKHR, 3, arg0, arg1, arg2);\n}\nPFNGLOBJECTPTRLABELKHRPROC glad_debug_glObjectPtrLabelKHR = glad_debug_impl_glObjectPtrLabelKHR;\nPFNGLGETOBJECTPTRLABELKHRPROC glad_glGetObjectPtrLabelKHR;\nvoid APIENTRY glad_debug_impl_glGetObjectPtrLabelKHR(const void * arg0, GLsizei arg1, GLsizei * arg2, GLchar * arg3) {\n    _pre_call_callback(\"glGetObjectPtrLabelKHR\", (void*)glGetObjectPtrLabelKHR, 4, arg0, arg1, arg2, arg3);\n     glad_glGetObjectPtrLabelKHR(arg0, arg1, arg2, arg3);\n    _post_call_callback(\"glGetObjectPtrLabelKHR\", (void*)glGetObjectPtrLabelKHR, 4, arg0, arg1, arg2, arg3);\n}\nPFNGLGETOBJECTPTRLABELKHRPROC glad_debug_glGetObjectPtrLabelKHR = glad_debug_impl_glGetObjectPtrLabelKHR;\nPFNGLGETPOINTERVKHRPROC glad_glGetPointervKHR;\nvoid APIENTRY glad_debug_impl_glGetPointervKHR(GLenum arg0, void ** arg1) {\n    _pre_call_callback(\"glGetPointervKHR\", (void*)glGetPointervKHR, 2, arg0, arg1);\n     glad_glGetPointervKHR(arg0, arg1);\n    _post_call_callback(\"glGetPointervKHR\", (void*)glGetPointervKHR, 2, arg0, arg1);\n}\nPFNGLGETPOINTERVKHRPROC glad_debug_glGetPointervKHR = glad_debug_impl_glGetPointervKHR;\nstatic void load_GL_VERSION_1_0(GLADloadproc load) {\n\tif(!GLAD_GL_VERSION_1_0) return;\n\tglad_glCullFace = (PFNGLCULLFACEPROC)load(\"glCullFace\");\n\tglad_glFrontFace = (PFNGLFRONTFACEPROC)load(\"glFrontFace\");\n\tglad_glHint = (PFNGLHINTPROC)load(\"glHint\");\n\tglad_glLineWidth = (PFNGLLINEWIDTHPROC)load(\"glLineWidth\");\n\tglad_glPointSize = (PFNGLPOINTSIZEPROC)load(\"glPointSize\");\n\tglad_glPolygonMode = (PFNGLPOLYGONMODEPROC)load(\"glPolygonMode\");\n\tglad_glScissor = (PFNGLSCISSORPROC)load(\"glScissor\");\n\tglad_glTexParameterf = (PFNGLTEXPARAMETERFPROC)load(\"glTexParameterf\");\n\tglad_glTexParameterfv = (PFNGLTEXPARAMETERFVPROC)load(\"glTexParameterfv\");\n\tglad_glTexParameteri = (PFNGLTEXPARAMETERIPROC)load(\"glTexParameteri\");\n\tglad_glTexParameteriv = (PFNGLTEXPARAMETERIVPROC)load(\"glTexParameteriv\");\n\tglad_glTexImage1D = (PFNGLTEXIMAGE1DPROC)load(\"glTexImage1D\");\n\tglad_glTexImage2D = (PFNGLTEXIMAGE2DPROC)load(\"glTexImage2D\");\n\tglad_glDrawBuffer = (PFNGLDRAWBUFFERPROC)load(\"glDrawBuffer\");\n\tglad_glClear = (PFNGLCLEARPROC)load(\"glClear\");\n\tglad_glClearColor = (PFNGLCLEARCOLORPROC)load(\"glClearColor\");\n\tglad_glClearStencil = (PFNGLCLEARSTENCILPROC)load(\"glClearStencil\");\n\tglad_glClearDepth = (PFNGLCLEARDEPTHPROC)load(\"glClearDepth\");\n\tglad_glStencilMask = (PFNGLSTENCILMASKPROC)load(\"glStencilMask\");\n\tglad_glColorMask = (PFNGLCOLORMASKPROC)load(\"glColorMask\");\n\tglad_glDepthMask = (PFNGLDEPTHMASKPROC)load(\"glDepthMask\");\n\tglad_glDisable = (PFNGLDISABLEPROC)load(\"glDisable\");\n\tglad_glEnable = (PFNGLENABLEPROC)load(\"glEnable\");\n\tglad_glFinish = (PFNGLFINISHPROC)load(\"glFinish\");\n\tglad_glFlush = (PFNGLFLUSHPROC)load(\"glFlush\");\n\tglad_glBlendFunc = (PFNGLBLENDFUNCPROC)load(\"glBlendFunc\");\n\tglad_glLogicOp = (PFNGLLOGICOPPROC)load(\"glLogicOp\");\n\tglad_glStencilFunc = (PFNGLSTENCILFUNCPROC)load(\"glStencilFunc\");\n\tglad_glStencilOp = (PFNGLSTENCILOPPROC)load(\"glStencilOp\");\n\tglad_glDepthFunc = (PFNGLDEPTHFUNCPROC)load(\"glDepthFunc\");\n\tglad_glPixelStoref = (PFNGLPIXELSTOREFPROC)load(\"glPixelStoref\");\n\tglad_glPixelStorei = (PFNGLPIXELSTOREIPROC)load(\"glPixelStorei\");\n\tglad_glReadBuffer = (PFNGLREADBUFFERPROC)load(\"glReadBuffer\");\n\tglad_glReadPixels = (PFNGLREADPIXELSPROC)load(\"glReadPixels\");\n\tglad_glGetBooleanv = (PFNGLGETBOOLEANVPROC)load(\"glGetBooleanv\");\n\tglad_glGetDoublev = (PFNGLGETDOUBLEVPROC)load(\"glGetDoublev\");\n\tglad_glGetError = (PFNGLGETERRORPROC)load(\"glGetError\");\n\tglad_glGetFloatv = (PFNGLGETFLOATVPROC)load(\"glGetFloatv\");\n\tglad_glGetIntegerv = (PFNGLGETINTEGERVPROC)load(\"glGetIntegerv\");\n\tglad_glGetString = (PFNGLGETSTRINGPROC)load(\"glGetString\");\n\tglad_glGetTexImage = (PFNGLGETTEXIMAGEPROC)load(\"glGetTexImage\");\n\tglad_glGetTexParameterfv = (PFNGLGETTEXPARAMETERFVPROC)load(\"glGetTexParameterfv\");\n\tglad_glGetTexParameteriv = (PFNGLGETTEXPARAMETERIVPROC)load(\"glGetTexParameteriv\");\n\tglad_glGetTexLevelParameterfv = (PFNGLGETTEXLEVELPARAMETERFVPROC)load(\"glGetTexLevelParameterfv\");\n\tglad_glGetTexLevelParameteriv = (PFNGLGETTEXLEVELPARAMETERIVPROC)load(\"glGetTexLevelParameteriv\");\n\tglad_glIsEnabled = (PFNGLISENABLEDPROC)load(\"glIsEnabled\");\n\tglad_glDepthRange = (PFNGLDEPTHRANGEPROC)load(\"glDepthRange\");\n\tglad_glViewport = (PFNGLVIEWPORTPROC)load(\"glViewport\");\n}\nstatic void load_GL_VERSION_1_1(GLADloadproc load) {\n\tif(!GLAD_GL_VERSION_1_1) return;\n\tglad_glDrawArrays = (PFNGLDRAWARRAYSPROC)load(\"glDrawArrays\");\n\tglad_glDrawElements = (PFNGLDRAWELEMENTSPROC)load(\"glDrawElements\");\n\tglad_glPolygonOffset = (PFNGLPOLYGONOFFSETPROC)load(\"glPolygonOffset\");\n\tglad_glCopyTexImage1D = (PFNGLCOPYTEXIMAGE1DPROC)load(\"glCopyTexImage1D\");\n\tglad_glCopyTexImage2D = (PFNGLCOPYTEXIMAGE2DPROC)load(\"glCopyTexImage2D\");\n\tglad_glCopyTexSubImage1D = (PFNGLCOPYTEXSUBIMAGE1DPROC)load(\"glCopyTexSubImage1D\");\n\tglad_glCopyTexSubImage2D = (PFNGLCOPYTEXSUBIMAGE2DPROC)load(\"glCopyTexSubImage2D\");\n\tglad_glTexSubImage1D = (PFNGLTEXSUBIMAGE1DPROC)load(\"glTexSubImage1D\");\n\tglad_glTexSubImage2D = (PFNGLTEXSUBIMAGE2DPROC)load(\"glTexSubImage2D\");\n\tglad_glBindTexture = (PFNGLBINDTEXTUREPROC)load(\"glBindTexture\");\n\tglad_glDeleteTextures = (PFNGLDELETETEXTURESPROC)load(\"glDeleteTextures\");\n\tglad_glGenTextures = (PFNGLGENTEXTURESPROC)load(\"glGenTextures\");\n\tglad_glIsTexture = (PFNGLISTEXTUREPROC)load(\"glIsTexture\");\n}\nstatic void load_GL_VERSION_1_2(GLADloadproc load) {\n\tif(!GLAD_GL_VERSION_1_2) return;\n\tglad_glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC)load(\"glDrawRangeElements\");\n\tglad_glTexImage3D = (PFNGLTEXIMAGE3DPROC)load(\"glTexImage3D\");\n\tglad_glTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC)load(\"glTexSubImage3D\");\n\tglad_glCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC)load(\"glCopyTexSubImage3D\");\n}\nstatic void load_GL_VERSION_1_3(GLADloadproc load) {\n\tif(!GLAD_GL_VERSION_1_3) return;\n\tglad_glActiveTexture = (PFNGLACTIVETEXTUREPROC)load(\"glActiveTexture\");\n\tglad_glSampleCoverage = (PFNGLSAMPLECOVERAGEPROC)load(\"glSampleCoverage\");\n\tglad_glCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC)load(\"glCompressedTexImage3D\");\n\tglad_glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC)load(\"glCompressedTexImage2D\");\n\tglad_glCompressedTexImage1D = (PFNGLCOMPRESSEDTEXIMAGE1DPROC)load(\"glCompressedTexImage1D\");\n\tglad_glCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)load(\"glCompressedTexSubImage3D\");\n\tglad_glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)load(\"glCompressedTexSubImage2D\");\n\tglad_glCompressedTexSubImage1D = (PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)load(\"glCompressedTexSubImage1D\");\n\tglad_glGetCompressedTexImage = (PFNGLGETCOMPRESSEDTEXIMAGEPROC)load(\"glGetCompressedTexImage\");\n}\nstatic void load_GL_VERSION_1_4(GLADloadproc load) {\n\tif(!GLAD_GL_VERSION_1_4) return;\n\tglad_glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC)load(\"glBlendFuncSeparate\");\n\tglad_glMultiDrawArrays = (PFNGLMULTIDRAWARRAYSPROC)load(\"glMultiDrawArrays\");\n\tglad_glMultiDrawElements = (PFNGLMULTIDRAWELEMENTSPROC)load(\"glMultiDrawElements\");\n\tglad_glPointParameterf = (PFNGLPOINTPARAMETERFPROC)load(\"glPointParameterf\");\n\tglad_glPointParameterfv = (PFNGLPOINTPARAMETERFVPROC)load(\"glPointParameterfv\");\n\tglad_glPointParameteri = (PFNGLPOINTPARAMETERIPROC)load(\"glPointParameteri\");\n\tglad_glPointParameteriv = (PFNGLPOINTPARAMETERIVPROC)load(\"glPointParameteriv\");\n\tglad_glBlendColor = (PFNGLBLENDCOLORPROC)load(\"glBlendColor\");\n\tglad_glBlendEquation = (PFNGLBLENDEQUATIONPROC)load(\"glBlendEquation\");\n}\nstatic void load_GL_VERSION_1_5(GLADloadproc load) {\n\tif(!GLAD_GL_VERSION_1_5) return;\n\tglad_glGenQueries = (PFNGLGENQUERIESPROC)load(\"glGenQueries\");\n\tglad_glDeleteQueries = (PFNGLDELETEQUERIESPROC)load(\"glDeleteQueries\");\n\tglad_glIsQuery = (PFNGLISQUERYPROC)load(\"glIsQuery\");\n\tglad_glBeginQuery = (PFNGLBEGINQUERYPROC)load(\"glBeginQuery\");\n\tglad_glEndQuery = (PFNGLENDQUERYPROC)load(\"glEndQuery\");\n\tglad_glGetQueryiv = (PFNGLGETQUERYIVPROC)load(\"glGetQueryiv\");\n\tglad_glGetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC)load(\"glGetQueryObjectiv\");\n\tglad_glGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC)load(\"glGetQueryObjectuiv\");\n\tglad_glBindBuffer = (PFNGLBINDBUFFERPROC)load(\"glBindBuffer\");\n\tglad_glDeleteBuffers = (PFNGLDELETEBUFFERSPROC)load(\"glDeleteBuffers\");\n\tglad_glGenBuffers = (PFNGLGENBUFFERSPROC)load(\"glGenBuffers\");\n\tglad_glIsBuffer = (PFNGLISBUFFERPROC)load(\"glIsBuffer\");\n\tglad_glBufferData = (PFNGLBUFFERDATAPROC)load(\"glBufferData\");\n\tglad_glBufferSubData = (PFNGLBUFFERSUBDATAPROC)load(\"glBufferSubData\");\n\tglad_glGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC)load(\"glGetBufferSubData\");\n\tglad_glMapBuffer = (PFNGLMAPBUFFERPROC)load(\"glMapBuffer\");\n\tglad_glUnmapBuffer = (PFNGLUNMAPBUFFERPROC)load(\"glUnmapBuffer\");\n\tglad_glGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC)load(\"glGetBufferParameteriv\");\n\tglad_glGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC)load(\"glGetBufferPointerv\");\n}\nstatic void load_GL_VERSION_2_0(GLADloadproc load) {\n\tif(!GLAD_GL_VERSION_2_0) return;\n\tglad_glBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC)load(\"glBlendEquationSeparate\");\n\tglad_glDrawBuffers = (PFNGLDRAWBUFFERSPROC)load(\"glDrawBuffers\");\n\tglad_glStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC)load(\"glStencilOpSeparate\");\n\tglad_glStencilFuncSeparate = (PFNGLSTENCILFUNCSEPARATEPROC)load(\"glStencilFuncSeparate\");\n\tglad_glStencilMaskSeparate = (PFNGLSTENCILMASKSEPARATEPROC)load(\"glStencilMaskSeparate\");\n\tglad_glAttachShader = (PFNGLATTACHSHADERPROC)load(\"glAttachShader\");\n\tglad_glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC)load(\"glBindAttribLocation\");\n\tglad_glCompileShader = (PFNGLCOMPILESHADERPROC)load(\"glCompileShader\");\n\tglad_glCreateProgram = (PFNGLCREATEPROGRAMPROC)load(\"glCreateProgram\");\n\tglad_glCreateShader = (PFNGLCREATESHADERPROC)load(\"glCreateShader\");\n\tglad_glDeleteProgram = (PFNGLDELETEPROGRAMPROC)load(\"glDeleteProgram\");\n\tglad_glDeleteShader = (PFNGLDELETESHADERPROC)load(\"glDeleteShader\");\n\tglad_glDetachShader = (PFNGLDETACHSHADERPROC)load(\"glDetachShader\");\n\tglad_glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC)load(\"glDisableVertexAttribArray\");\n\tglad_glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)load(\"glEnableVertexAttribArray\");\n\tglad_glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC)load(\"glGetActiveAttrib\");\n\tglad_glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC)load(\"glGetActiveUniform\");\n\tglad_glGetAttachedShaders = (PFNGLGETATTACHEDSHADERSPROC)load(\"glGetAttachedShaders\");\n\tglad_glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC)load(\"glGetAttribLocation\");\n\tglad_glGetProgramiv = (PFNGLGETPROGRAMIVPROC)load(\"glGetProgramiv\");\n\tglad_glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC)load(\"glGetProgramInfoLog\");\n\tglad_glGetShaderiv = (PFNGLGETSHADERIVPROC)load(\"glGetShaderiv\");\n\tglad_glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)load(\"glGetShaderInfoLog\");\n\tglad_glGetShaderSource = (PFNGLGETSHADERSOURCEPROC)load(\"glGetShaderSource\");\n\tglad_glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC)load(\"glGetUniformLocation\");\n\tglad_glGetUniformfv = (PFNGLGETUNIFORMFVPROC)load(\"glGetUniformfv\");\n\tglad_glGetUniformiv = (PFNGLGETUNIFORMIVPROC)load(\"glGetUniformiv\");\n\tglad_glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC)load(\"glGetVertexAttribdv\");\n\tglad_glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC)load(\"glGetVertexAttribfv\");\n\tglad_glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC)load(\"glGetVertexAttribiv\");\n\tglad_glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC)load(\"glGetVertexAttribPointerv\");\n\tglad_glIsProgram = (PFNGLISPROGRAMPROC)load(\"glIsProgram\");\n\tglad_glIsShader = (PFNGLISSHADERPROC)load(\"glIsShader\");\n\tglad_glLinkProgram = (PFNGLLINKPROGRAMPROC)load(\"glLinkProgram\");\n\tglad_glShaderSource = (PFNGLSHADERSOURCEPROC)load(\"glShaderSource\");\n\tglad_glUseProgram = (PFNGLUSEPROGRAMPROC)load(\"glUseProgram\");\n\tglad_glUniform1f = (PFNGLUNIFORM1FPROC)load(\"glUniform1f\");\n\tglad_glUniform2f = (PFNGLUNIFORM2FPROC)load(\"glUniform2f\");\n\tglad_glUniform3f = (PFNGLUNIFORM3FPROC)load(\"glUniform3f\");\n\tglad_glUniform4f = (PFNGLUNIFORM4FPROC)load(\"glUniform4f\");\n\tglad_glUniform1i = (PFNGLUNIFORM1IPROC)load(\"glUniform1i\");\n\tglad_glUniform2i = (PFNGLUNIFORM2IPROC)load(\"glUniform2i\");\n\tglad_glUniform3i = (PFNGLUNIFORM3IPROC)load(\"glUniform3i\");\n\tglad_glUniform4i = (PFNGLUNIFORM4IPROC)load(\"glUniform4i\");\n\tglad_glUniform1fv = (PFNGLUNIFORM1FVPROC)load(\"glUniform1fv\");\n\tglad_glUniform2fv = (PFNGLUNIFORM2FVPROC)load(\"glUniform2fv\");\n\tglad_glUniform3fv = (PFNGLUNIFORM3FVPROC)load(\"glUniform3fv\");\n\tglad_glUniform4fv = (PFNGLUNIFORM4FVPROC)load(\"glUniform4fv\");\n\tglad_glUniform1iv = (PFNGLUNIFORM1IVPROC)load(\"glUniform1iv\");\n\tglad_glUniform2iv = (PFNGLUNIFORM2IVPROC)load(\"glUniform2iv\");\n\tglad_glUniform3iv = (PFNGLUNIFORM3IVPROC)load(\"glUniform3iv\");\n\tglad_glUniform4iv = (PFNGLUNIFORM4IVPROC)load(\"glUniform4iv\");\n\tglad_glUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC)load(\"glUniformMatrix2fv\");\n\tglad_glUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC)load(\"glUniformMatrix3fv\");\n\tglad_glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC)load(\"glUniformMatrix4fv\");\n\tglad_glValidateProgram = (PFNGLVALIDATEPROGRAMPROC)load(\"glValidateProgram\");\n\tglad_glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC)load(\"glVertexAttrib1d\");\n\tglad_glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC)load(\"glVertexAttrib1dv\");\n\tglad_glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC)load(\"glVertexAttrib1f\");\n\tglad_glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC)load(\"glVertexAttrib1fv\");\n\tglad_glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC)load(\"glVertexAttrib1s\");\n\tglad_glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC)load(\"glVertexAttrib1sv\");\n\tglad_glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC)load(\"glVertexAttrib2d\");\n\tglad_glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC)load(\"glVertexAttrib2dv\");\n\tglad_glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC)load(\"glVertexAttrib2f\");\n\tglad_glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC)load(\"glVertexAttrib2fv\");\n\tglad_glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC)load(\"glVertexAttrib2s\");\n\tglad_glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC)load(\"glVertexAttrib2sv\");\n\tglad_glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC)load(\"glVertexAttrib3d\");\n\tglad_glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC)load(\"glVertexAttrib3dv\");\n\tglad_glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC)load(\"glVertexAttrib3f\");\n\tglad_glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC)load(\"glVertexAttrib3fv\");\n\tglad_glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC)load(\"glVertexAttrib3s\");\n\tglad_glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC)load(\"glVertexAttrib3sv\");\n\tglad_glVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC)load(\"glVertexAttrib4Nbv\");\n\tglad_glVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC)load(\"glVertexAttrib4Niv\");\n\tglad_glVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC)load(\"glVertexAttrib4Nsv\");\n\tglad_glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC)load(\"glVertexAttrib4Nub\");\n\tglad_glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC)load(\"glVertexAttrib4Nubv\");\n\tglad_glVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC)load(\"glVertexAttrib4Nuiv\");\n\tglad_glVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC)load(\"glVertexAttrib4Nusv\");\n\tglad_glVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC)load(\"glVertexAttrib4bv\");\n\tglad_glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC)load(\"glVertexAttrib4d\");\n\tglad_glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC)load(\"glVertexAttrib4dv\");\n\tglad_glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC)load(\"glVertexAttrib4f\");\n\tglad_glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC)load(\"glVertexAttrib4fv\");\n\tglad_glVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC)load(\"glVertexAttrib4iv\");\n\tglad_glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC)load(\"glVertexAttrib4s\");\n\tglad_glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC)load(\"glVertexAttrib4sv\");\n\tglad_glVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC)load(\"glVertexAttrib4ubv\");\n\tglad_glVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC)load(\"glVertexAttrib4uiv\");\n\tglad_glVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC)load(\"glVertexAttrib4usv\");\n\tglad_glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC)load(\"glVertexAttribPointer\");\n}\nstatic void load_GL_VERSION_2_1(GLADloadproc load) {\n\tif(!GLAD_GL_VERSION_2_1) return;\n\tglad_glUniformMatrix2x3fv = (PFNGLUNIFORMMATRIX2X3FVPROC)load(\"glUniformMatrix2x3fv\");\n\tglad_glUniformMatrix3x2fv = (PFNGLUNIFORMMATRIX3X2FVPROC)load(\"glUniformMatrix3x2fv\");\n\tglad_glUniformMatrix2x4fv = (PFNGLUNIFORMMATRIX2X4FVPROC)load(\"glUniformMatrix2x4fv\");\n\tglad_glUniformMatrix4x2fv = (PFNGLUNIFORMMATRIX4X2FVPROC)load(\"glUniformMatrix4x2fv\");\n\tglad_glUniformMatrix3x4fv = (PFNGLUNIFORMMATRIX3X4FVPROC)load(\"glUniformMatrix3x4fv\");\n\tglad_glUniformMatrix4x3fv = (PFNGLUNIFORMMATRIX4X3FVPROC)load(\"glUniformMatrix4x3fv\");\n}\nstatic void load_GL_VERSION_3_0(GLADloadproc load) {\n\tif(!GLAD_GL_VERSION_3_0) return;\n\tglad_glColorMaski = (PFNGLCOLORMASKIPROC)load(\"glColorMaski\");\n\tglad_glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC)load(\"glGetBooleani_v\");\n\tglad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC)load(\"glGetIntegeri_v\");\n\tglad_glEnablei = (PFNGLENABLEIPROC)load(\"glEnablei\");\n\tglad_glDisablei = (PFNGLDISABLEIPROC)load(\"glDisablei\");\n\tglad_glIsEnabledi = (PFNGLISENABLEDIPROC)load(\"glIsEnabledi\");\n\tglad_glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC)load(\"glBeginTransformFeedback\");\n\tglad_glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC)load(\"glEndTransformFeedback\");\n\tglad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC)load(\"glBindBufferRange\");\n\tglad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC)load(\"glBindBufferBase\");\n\tglad_glTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC)load(\"glTransformFeedbackVaryings\");\n\tglad_glGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)load(\"glGetTransformFeedbackVarying\");\n\tglad_glClampColor = (PFNGLCLAMPCOLORPROC)load(\"glClampColor\");\n\tglad_glBeginConditionalRender = (PFNGLBEGINCONDITIONALRENDERPROC)load(\"glBeginConditionalRender\");\n\tglad_glEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC)load(\"glEndConditionalRender\");\n\tglad_glVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC)load(\"glVertexAttribIPointer\");\n\tglad_glGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC)load(\"glGetVertexAttribIiv\");\n\tglad_glGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC)load(\"glGetVertexAttribIuiv\");\n\tglad_glVertexAttribI1i = (PFNGLVERTEXATTRIBI1IPROC)load(\"glVertexAttribI1i\");\n\tglad_glVertexAttribI2i = (PFNGLVERTEXATTRIBI2IPROC)load(\"glVertexAttribI2i\");\n\tglad_glVertexAttribI3i = (PFNGLVERTEXATTRIBI3IPROC)load(\"glVertexAttribI3i\");\n\tglad_glVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC)load(\"glVertexAttribI4i\");\n\tglad_glVertexAttribI1ui = (PFNGLVERTEXATTRIBI1UIPROC)load(\"glVertexAttribI1ui\");\n\tglad_glVertexAttribI2ui = (PFNGLVERTEXATTRIBI2UIPROC)load(\"glVertexAttribI2ui\");\n\tglad_glVertexAttribI3ui = (PFNGLVERTEXATTRIBI3UIPROC)load(\"glVertexAttribI3ui\");\n\tglad_glVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC)load(\"glVertexAttribI4ui\");\n\tglad_glVertexAttribI1iv = (PFNGLVERTEXATTRIBI1IVPROC)load(\"glVertexAttribI1iv\");\n\tglad_glVertexAttribI2iv = (PFNGLVERTEXATTRIBI2IVPROC)load(\"glVertexAttribI2iv\");\n\tglad_glVertexAttribI3iv = (PFNGLVERTEXATTRIBI3IVPROC)load(\"glVertexAttribI3iv\");\n\tglad_glVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC)load(\"glVertexAttribI4iv\");\n\tglad_glVertexAttribI1uiv = (PFNGLVERTEXATTRIBI1UIVPROC)load(\"glVertexAttribI1uiv\");\n\tglad_glVertexAttribI2uiv = (PFNGLVERTEXATTRIBI2UIVPROC)load(\"glVertexAttribI2uiv\");\n\tglad_glVertexAttribI3uiv = (PFNGLVERTEXATTRIBI3UIVPROC)load(\"glVertexAttribI3uiv\");\n\tglad_glVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC)load(\"glVertexAttribI4uiv\");\n\tglad_glVertexAttribI4bv = (PFNGLVERTEXATTRIBI4BVPROC)load(\"glVertexAttribI4bv\");\n\tglad_glVertexAttribI4sv = (PFNGLVERTEXATTRIBI4SVPROC)load(\"glVertexAttribI4sv\");\n\tglad_glVertexAttribI4ubv = (PFNGLVERTEXATTRIBI4UBVPROC)load(\"glVertexAttribI4ubv\");\n\tglad_glVertexAttribI4usv = (PFNGLVERTEXATTRIBI4USVPROC)load(\"glVertexAttribI4usv\");\n\tglad_glGetUniformuiv = (PFNGLGETUNIFORMUIVPROC)load(\"glGetUniformuiv\");\n\tglad_glBindFragDataLocation = (PFNGLBINDFRAGDATALOCATIONPROC)load(\"glBindFragDataLocation\");\n\tglad_glGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC)load(\"glGetFragDataLocation\");\n\tglad_glUniform1ui = (PFNGLUNIFORM1UIPROC)load(\"glUniform1ui\");\n\tglad_glUniform2ui = (PFNGLUNIFORM2UIPROC)load(\"glUniform2ui\");\n\tglad_glUniform3ui = (PFNGLUNIFORM3UIPROC)load(\"glUniform3ui\");\n\tglad_glUniform4ui = (PFNGLUNIFORM4UIPROC)load(\"glUniform4ui\");\n\tglad_glUniform1uiv = (PFNGLUNIFORM1UIVPROC)load(\"glUniform1uiv\");\n\tglad_glUniform2uiv = (PFNGLUNIFORM2UIVPROC)load(\"glUniform2uiv\");\n\tglad_glUniform3uiv = (PFNGLUNIFORM3UIVPROC)load(\"glUniform3uiv\");\n\tglad_glUniform4uiv = (PFNGLUNIFORM4UIVPROC)load(\"glUniform4uiv\");\n\tglad_glTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC)load(\"glTexParameterIiv\");\n\tglad_glTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC)load(\"glTexParameterIuiv\");\n\tglad_glGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC)load(\"glGetTexParameterIiv\");\n\tglad_glGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC)load(\"glGetTexParameterIuiv\");\n\tglad_glClearBufferiv = (PFNGLCLEARBUFFERIVPROC)load(\"glClearBufferiv\");\n\tglad_glClearBufferuiv = (PFNGLCLEARBUFFERUIVPROC)load(\"glClearBufferuiv\");\n\tglad_glClearBufferfv = (PFNGLCLEARBUFFERFVPROC)load(\"glClearBufferfv\");\n\tglad_glClearBufferfi = (PFNGLCLEARBUFFERFIPROC)load(\"glClearBufferfi\");\n\tglad_glGetStringi = (PFNGLGETSTRINGIPROC)load(\"glGetStringi\");\n\tglad_glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC)load(\"glIsRenderbuffer\");\n\tglad_glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC)load(\"glBindRenderbuffer\");\n\tglad_glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC)load(\"glDeleteRenderbuffers\");\n\tglad_glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC)load(\"glGenRenderbuffers\");\n\tglad_glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC)load(\"glRenderbufferStorage\");\n\tglad_glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC)load(\"glGetRenderbufferParameteriv\");\n\tglad_glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC)load(\"glIsFramebuffer\");\n\tglad_glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC)load(\"glBindFramebuffer\");\n\tglad_glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC)load(\"glDeleteFramebuffers\");\n\tglad_glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC)load(\"glGenFramebuffers\");\n\tglad_glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC)load(\"glCheckFramebufferStatus\");\n\tglad_glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC)load(\"glFramebufferTexture1D\");\n\tglad_glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC)load(\"glFramebufferTexture2D\");\n\tglad_glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC)load(\"glFramebufferTexture3D\");\n\tglad_glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC)load(\"glFramebufferRenderbuffer\");\n\tglad_glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)load(\"glGetFramebufferAttachmentParameteriv\");\n\tglad_glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC)load(\"glGenerateMipmap\");\n\tglad_glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC)load(\"glBlitFramebuffer\");\n\tglad_glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)load(\"glRenderbufferStorageMultisample\");\n\tglad_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC)load(\"glFramebufferTextureLayer\");\n\tglad_glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC)load(\"glMapBufferRange\");\n\tglad_glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC)load(\"glFlushMappedBufferRange\");\n\tglad_glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC)load(\"glBindVertexArray\");\n\tglad_glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC)load(\"glDeleteVertexArrays\");\n\tglad_glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC)load(\"glGenVertexArrays\");\n\tglad_glIsVertexArray = (PFNGLISVERTEXARRAYPROC)load(\"glIsVertexArray\");\n}\nstatic void load_GL_VERSION_3_1(GLADloadproc load) {\n\tif(!GLAD_GL_VERSION_3_1) return;\n\tglad_glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC)load(\"glDrawArraysInstanced\");\n\tglad_glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC)load(\"glDrawElementsInstanced\");\n\tglad_glTexBuffer = (PFNGLTEXBUFFERPROC)load(\"glTexBuffer\");\n\tglad_glPrimitiveRestartIndex = (PFNGLPRIMITIVERESTARTINDEXPROC)load(\"glPrimitiveRestartIndex\");\n\tglad_glCopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC)load(\"glCopyBufferSubData\");\n\tglad_glGetUniformIndices = (PFNGLGETUNIFORMINDICESPROC)load(\"glGetUniformIndices\");\n\tglad_glGetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC)load(\"glGetActiveUniformsiv\");\n\tglad_glGetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC)load(\"glGetActiveUniformName\");\n\tglad_glGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC)load(\"glGetUniformBlockIndex\");\n\tglad_glGetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC)load(\"glGetActiveUniformBlockiv\");\n\tglad_glGetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)load(\"glGetActiveUniformBlockName\");\n\tglad_glUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC)load(\"glUniformBlockBinding\");\n\tglad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC)load(\"glBindBufferRange\");\n\tglad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC)load(\"glBindBufferBase\");\n\tglad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC)load(\"glGetIntegeri_v\");\n}\nstatic void load_GL_VERSION_3_2(GLADloadproc load) {\n\tif(!GLAD_GL_VERSION_3_2) return;\n\tglad_glDrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC)load(\"glDrawElementsBaseVertex\");\n\tglad_glDrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)load(\"glDrawRangeElementsBaseVertex\");\n\tglad_glDrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)load(\"glDrawElementsInstancedBaseVertex\");\n\tglad_glMultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)load(\"glMultiDrawElementsBaseVertex\");\n\tglad_glProvokingVertex = (PFNGLPROVOKINGVERTEXPROC)load(\"glProvokingVertex\");\n\tglad_glFenceSync = (PFNGLFENCESYNCPROC)load(\"glFenceSync\");\n\tglad_glIsSync = (PFNGLISSYNCPROC)load(\"glIsSync\");\n\tglad_glDeleteSync = (PFNGLDELETESYNCPROC)load(\"glDeleteSync\");\n\tglad_glClientWaitSync = (PFNGLCLIENTWAITSYNCPROC)load(\"glClientWaitSync\");\n\tglad_glWaitSync = (PFNGLWAITSYNCPROC)load(\"glWaitSync\");\n\tglad_glGetInteger64v = (PFNGLGETINTEGER64VPROC)load(\"glGetInteger64v\");\n\tglad_glGetSynciv = (PFNGLGETSYNCIVPROC)load(\"glGetSynciv\");\n\tglad_glGetInteger64i_v = (PFNGLGETINTEGER64I_VPROC)load(\"glGetInteger64i_v\");\n\tglad_glGetBufferParameteri64v = (PFNGLGETBUFFERPARAMETERI64VPROC)load(\"glGetBufferParameteri64v\");\n\tglad_glFramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC)load(\"glFramebufferTexture\");\n\tglad_glTexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC)load(\"glTexImage2DMultisample\");\n\tglad_glTexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC)load(\"glTexImage3DMultisample\");\n\tglad_glGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC)load(\"glGetMultisamplefv\");\n\tglad_glSampleMaski = (PFNGLSAMPLEMASKIPROC)load(\"glSampleMaski\");\n}\nstatic void load_GL_VERSION_3_3(GLADloadproc load) {\n\tif(!GLAD_GL_VERSION_3_3) return;\n\tglad_glBindFragDataLocationIndexed = (PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)load(\"glBindFragDataLocationIndexed\");\n\tglad_glGetFragDataIndex = (PFNGLGETFRAGDATAINDEXPROC)load(\"glGetFragDataIndex\");\n\tglad_glGenSamplers = (PFNGLGENSAMPLERSPROC)load(\"glGenSamplers\");\n\tglad_glDeleteSamplers = (PFNGLDELETESAMPLERSPROC)load(\"glDeleteSamplers\");\n\tglad_glIsSampler = (PFNGLISSAMPLERPROC)load(\"glIsSampler\");\n\tglad_glBindSampler = (PFNGLBINDSAMPLERPROC)load(\"glBindSampler\");\n\tglad_glSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC)load(\"glSamplerParameteri\");\n\tglad_glSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC)load(\"glSamplerParameteriv\");\n\tglad_glSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC)load(\"glSamplerParameterf\");\n\tglad_glSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC)load(\"glSamplerParameterfv\");\n\tglad_glSamplerParameterIiv = (PFNGLSAMPLERPARAMETERIIVPROC)load(\"glSamplerParameterIiv\");\n\tglad_glSamplerParameterIuiv = (PFNGLSAMPLERPARAMETERIUIVPROC)load(\"glSamplerParameterIuiv\");\n\tglad_glGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC)load(\"glGetSamplerParameteriv\");\n\tglad_glGetSamplerParameterIiv = (PFNGLGETSAMPLERPARAMETERIIVPROC)load(\"glGetSamplerParameterIiv\");\n\tglad_glGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC)load(\"glGetSamplerParameterfv\");\n\tglad_glGetSamplerParameterIuiv = (PFNGLGETSAMPLERPARAMETERIUIVPROC)load(\"glGetSamplerParameterIuiv\");\n\tglad_glQueryCounter = (PFNGLQUERYCOUNTERPROC)load(\"glQueryCounter\");\n\tglad_glGetQueryObjecti64v = (PFNGLGETQUERYOBJECTI64VPROC)load(\"glGetQueryObjecti64v\");\n\tglad_glGetQueryObjectui64v = (PFNGLGETQUERYOBJECTUI64VPROC)load(\"glGetQueryObjectui64v\");\n\tglad_glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISORPROC)load(\"glVertexAttribDivisor\");\n\tglad_glVertexAttribP1ui = (PFNGLVERTEXATTRIBP1UIPROC)load(\"glVertexAttribP1ui\");\n\tglad_glVertexAttribP1uiv = (PFNGLVERTEXATTRIBP1UIVPROC)load(\"glVertexAttribP1uiv\");\n\tglad_glVertexAttribP2ui = (PFNGLVERTEXATTRIBP2UIPROC)load(\"glVertexAttribP2ui\");\n\tglad_glVertexAttribP2uiv = (PFNGLVERTEXATTRIBP2UIVPROC)load(\"glVertexAttribP2uiv\");\n\tglad_glVertexAttribP3ui = (PFNGLVERTEXATTRIBP3UIPROC)load(\"glVertexAttribP3ui\");\n\tglad_glVertexAttribP3uiv = (PFNGLVERTEXATTRIBP3UIVPROC)load(\"glVertexAttribP3uiv\");\n\tglad_glVertexAttribP4ui = (PFNGLVERTEXATTRIBP4UIPROC)load(\"glVertexAttribP4ui\");\n\tglad_glVertexAttribP4uiv = (PFNGLVERTEXATTRIBP4UIVPROC)load(\"glVertexAttribP4uiv\");\n\tglad_glVertexP2ui = (PFNGLVERTEXP2UIPROC)load(\"glVertexP2ui\");\n\tglad_glVertexP2uiv = (PFNGLVERTEXP2UIVPROC)load(\"glVertexP2uiv\");\n\tglad_glVertexP3ui = (PFNGLVERTEXP3UIPROC)load(\"glVertexP3ui\");\n\tglad_glVertexP3uiv = (PFNGLVERTEXP3UIVPROC)load(\"glVertexP3uiv\");\n\tglad_glVertexP4ui = (PFNGLVERTEXP4UIPROC)load(\"glVertexP4ui\");\n\tglad_glVertexP4uiv = (PFNGLVERTEXP4UIVPROC)load(\"glVertexP4uiv\");\n\tglad_glTexCoordP1ui = (PFNGLTEXCOORDP1UIPROC)load(\"glTexCoordP1ui\");\n\tglad_glTexCoordP1uiv = (PFNGLTEXCOORDP1UIVPROC)load(\"glTexCoordP1uiv\");\n\tglad_glTexCoordP2ui = (PFNGLTEXCOORDP2UIPROC)load(\"glTexCoordP2ui\");\n\tglad_glTexCoordP2uiv = (PFNGLTEXCOORDP2UIVPROC)load(\"glTexCoordP2uiv\");\n\tglad_glTexCoordP3ui = (PFNGLTEXCOORDP3UIPROC)load(\"glTexCoordP3ui\");\n\tglad_glTexCoordP3uiv = (PFNGLTEXCOORDP3UIVPROC)load(\"glTexCoordP3uiv\");\n\tglad_glTexCoordP4ui = (PFNGLTEXCOORDP4UIPROC)load(\"glTexCoordP4ui\");\n\tglad_glTexCoordP4uiv = (PFNGLTEXCOORDP4UIVPROC)load(\"glTexCoordP4uiv\");\n\tglad_glMultiTexCoordP1ui = (PFNGLMULTITEXCOORDP1UIPROC)load(\"glMultiTexCoordP1ui\");\n\tglad_glMultiTexCoordP1uiv = (PFNGLMULTITEXCOORDP1UIVPROC)load(\"glMultiTexCoordP1uiv\");\n\tglad_glMultiTexCoordP2ui = (PFNGLMULTITEXCOORDP2UIPROC)load(\"glMultiTexCoordP2ui\");\n\tglad_glMultiTexCoordP2uiv = (PFNGLMULTITEXCOORDP2UIVPROC)load(\"glMultiTexCoordP2uiv\");\n\tglad_glMultiTexCoordP3ui = (PFNGLMULTITEXCOORDP3UIPROC)load(\"glMultiTexCoordP3ui\");\n\tglad_glMultiTexCoordP3uiv = (PFNGLMULTITEXCOORDP3UIVPROC)load(\"glMultiTexCoordP3uiv\");\n\tglad_glMultiTexCoordP4ui = (PFNGLMULTITEXCOORDP4UIPROC)load(\"glMultiTexCoordP4ui\");\n\tglad_glMultiTexCoordP4uiv = (PFNGLMULTITEXCOORDP4UIVPROC)load(\"glMultiTexCoordP4uiv\");\n\tglad_glNormalP3ui = (PFNGLNORMALP3UIPROC)load(\"glNormalP3ui\");\n\tglad_glNormalP3uiv = (PFNGLNORMALP3UIVPROC)load(\"glNormalP3uiv\");\n\tglad_glColorP3ui = (PFNGLCOLORP3UIPROC)load(\"glColorP3ui\");\n\tglad_glColorP3uiv = (PFNGLCOLORP3UIVPROC)load(\"glColorP3uiv\");\n\tglad_glColorP4ui = (PFNGLCOLORP4UIPROC)load(\"glColorP4ui\");\n\tglad_glColorP4uiv = (PFNGLCOLORP4UIVPROC)load(\"glColorP4uiv\");\n\tglad_glSecondaryColorP3ui = (PFNGLSECONDARYCOLORP3UIPROC)load(\"glSecondaryColorP3ui\");\n\tglad_glSecondaryColorP3uiv = (PFNGLSECONDARYCOLORP3UIVPROC)load(\"glSecondaryColorP3uiv\");\n}\nstatic void load_GL_ARB_copy_image(GLADloadproc load) {\n\tif(!GLAD_GL_ARB_copy_image) return;\n\tglad_glCopyImageSubData = (PFNGLCOPYIMAGESUBDATAPROC)load(\"glCopyImageSubData\");\n}\nstatic void load_GL_ARB_multisample(GLADloadproc load) {\n\tif(!GLAD_GL_ARB_multisample) return;\n\tglad_glSampleCoverageARB = (PFNGLSAMPLECOVERAGEARBPROC)load(\"glSampleCoverageARB\");\n}\nstatic void load_GL_ARB_robustness(GLADloadproc load) {\n\tif(!GLAD_GL_ARB_robustness) return;\n\tglad_glGetGraphicsResetStatusARB = (PFNGLGETGRAPHICSRESETSTATUSARBPROC)load(\"glGetGraphicsResetStatusARB\");\n\tglad_glGetnTexImageARB = (PFNGLGETNTEXIMAGEARBPROC)load(\"glGetnTexImageARB\");\n\tglad_glReadnPixelsARB = (PFNGLREADNPIXELSARBPROC)load(\"glReadnPixelsARB\");\n\tglad_glGetnCompressedTexImageARB = (PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC)load(\"glGetnCompressedTexImageARB\");\n\tglad_glGetnUniformfvARB = (PFNGLGETNUNIFORMFVARBPROC)load(\"glGetnUniformfvARB\");\n\tglad_glGetnUniformivARB = (PFNGLGETNUNIFORMIVARBPROC)load(\"glGetnUniformivARB\");\n\tglad_glGetnUniformuivARB = (PFNGLGETNUNIFORMUIVARBPROC)load(\"glGetnUniformuivARB\");\n\tglad_glGetnUniformdvARB = (PFNGLGETNUNIFORMDVARBPROC)load(\"glGetnUniformdvARB\");\n\tglad_glGetnMapdvARB = (PFNGLGETNMAPDVARBPROC)load(\"glGetnMapdvARB\");\n\tglad_glGetnMapfvARB = (PFNGLGETNMAPFVARBPROC)load(\"glGetnMapfvARB\");\n\tglad_glGetnMapivARB = (PFNGLGETNMAPIVARBPROC)load(\"glGetnMapivARB\");\n\tglad_glGetnPixelMapfvARB = (PFNGLGETNPIXELMAPFVARBPROC)load(\"glGetnPixelMapfvARB\");\n\tglad_glGetnPixelMapuivARB = (PFNGLGETNPIXELMAPUIVARBPROC)load(\"glGetnPixelMapuivARB\");\n\tglad_glGetnPixelMapusvARB = (PFNGLGETNPIXELMAPUSVARBPROC)load(\"glGetnPixelMapusvARB\");\n\tglad_glGetnPolygonStippleARB = (PFNGLGETNPOLYGONSTIPPLEARBPROC)load(\"glGetnPolygonStippleARB\");\n\tglad_glGetnColorTableARB = (PFNGLGETNCOLORTABLEARBPROC)load(\"glGetnColorTableARB\");\n\tglad_glGetnConvolutionFilterARB = (PFNGLGETNCONVOLUTIONFILTERARBPROC)load(\"glGetnConvolutionFilterARB\");\n\tglad_glGetnSeparableFilterARB = (PFNGLGETNSEPARABLEFILTERARBPROC)load(\"glGetnSeparableFilterARB\");\n\tglad_glGetnHistogramARB = (PFNGLGETNHISTOGRAMARBPROC)load(\"glGetnHistogramARB\");\n\tglad_glGetnMinmaxARB = (PFNGLGETNMINMAXARBPROC)load(\"glGetnMinmaxARB\");\n}\nstatic void load_GL_ARB_texture_storage(GLADloadproc load) {\n\tif(!GLAD_GL_ARB_texture_storage) return;\n\tglad_glTexStorage1D = (PFNGLTEXSTORAGE1DPROC)load(\"glTexStorage1D\");\n\tglad_glTexStorage2D = (PFNGLTEXSTORAGE2DPROC)load(\"glTexStorage2D\");\n\tglad_glTexStorage3D = (PFNGLTEXSTORAGE3DPROC)load(\"glTexStorage3D\");\n}\nstatic void load_GL_KHR_debug(GLADloadproc load) {\n\tif(!GLAD_GL_KHR_debug) return;\n\tglad_glDebugMessageControl = (PFNGLDEBUGMESSAGECONTROLPROC)load(\"glDebugMessageControl\");\n\tglad_glDebugMessageInsert = (PFNGLDEBUGMESSAGEINSERTPROC)load(\"glDebugMessageInsert\");\n\tglad_glDebugMessageCallback = (PFNGLDEBUGMESSAGECALLBACKPROC)load(\"glDebugMessageCallback\");\n\tglad_glGetDebugMessageLog = (PFNGLGETDEBUGMESSAGELOGPROC)load(\"glGetDebugMessageLog\");\n\tglad_glPushDebugGroup = (PFNGLPUSHDEBUGGROUPPROC)load(\"glPushDebugGroup\");\n\tglad_glPopDebugGroup = (PFNGLPOPDEBUGGROUPPROC)load(\"glPopDebugGroup\");\n\tglad_glObjectLabel = (PFNGLOBJECTLABELPROC)load(\"glObjectLabel\");\n\tglad_glGetObjectLabel = (PFNGLGETOBJECTLABELPROC)load(\"glGetObjectLabel\");\n\tglad_glObjectPtrLabel = (PFNGLOBJECTPTRLABELPROC)load(\"glObjectPtrLabel\");\n\tglad_glGetObjectPtrLabel = (PFNGLGETOBJECTPTRLABELPROC)load(\"glGetObjectPtrLabel\");\n\tglad_glGetPointerv = (PFNGLGETPOINTERVPROC)load(\"glGetPointerv\");\n\tglad_glDebugMessageControlKHR = (PFNGLDEBUGMESSAGECONTROLKHRPROC)load(\"glDebugMessageControlKHR\");\n\tglad_glDebugMessageInsertKHR = (PFNGLDEBUGMESSAGEINSERTKHRPROC)load(\"glDebugMessageInsertKHR\");\n\tglad_glDebugMessageCallbackKHR = (PFNGLDEBUGMESSAGECALLBACKKHRPROC)load(\"glDebugMessageCallbackKHR\");\n\tglad_glGetDebugMessageLogKHR = (PFNGLGETDEBUGMESSAGELOGKHRPROC)load(\"glGetDebugMessageLogKHR\");\n\tglad_glPushDebugGroupKHR = (PFNGLPUSHDEBUGGROUPKHRPROC)load(\"glPushDebugGroupKHR\");\n\tglad_glPopDebugGroupKHR = (PFNGLPOPDEBUGGROUPKHRPROC)load(\"glPopDebugGroupKHR\");\n\tglad_glObjectLabelKHR = (PFNGLOBJECTLABELKHRPROC)load(\"glObjectLabelKHR\");\n\tglad_glGetObjectLabelKHR = (PFNGLGETOBJECTLABELKHRPROC)load(\"glGetObjectLabelKHR\");\n\tglad_glObjectPtrLabelKHR = (PFNGLOBJECTPTRLABELKHRPROC)load(\"glObjectPtrLabelKHR\");\n\tglad_glGetObjectPtrLabelKHR = (PFNGLGETOBJECTPTRLABELKHRPROC)load(\"glGetObjectPtrLabelKHR\");\n\tglad_glGetPointervKHR = (PFNGLGETPOINTERVKHRPROC)load(\"glGetPointervKHR\");\n}\nstatic int find_extensionsGL(void) {\n\tif (!get_exts()) return 0;\n\tGLAD_GL_ARB_copy_image = has_ext(\"GL_ARB_copy_image\");\n\tGLAD_GL_ARB_multisample = has_ext(\"GL_ARB_multisample\");\n\tGLAD_GL_ARB_robustness = has_ext(\"GL_ARB_robustness\");\n\tGLAD_GL_ARB_texture_storage = has_ext(\"GL_ARB_texture_storage\");\n\tGLAD_GL_KHR_debug = has_ext(\"GL_KHR_debug\");\n\tfree_exts();\n\treturn 1;\n}\nstatic void find_coreGL(void) {\n    /* Thank you @elmindreda\n     * https://github.com/elmindreda/greg/blob/master/templates/greg.c.in#L176\n     * https://github.com/glfw/glfw/blob/master/src/context.c#L36\n     */\n    int i, major, minor;\n    const char* version;\n    const char* prefixes[] = {\n        \"OpenGL ES-CM \",\n        \"OpenGL ES-CL \",\n        \"OpenGL ES \",\n        NULL\n    };\n    version = (const char*) glGetString(GL_VERSION);\n    if (!version) return;\n    for (i = 0;  prefixes[i];  i++) {\n        const size_t length = strlen(prefixes[i]);\n        if (strncmp(version, prefixes[i], length) == 0) {\n            version += length;\n            break;\n        }\n    }\n/* PR #18 */\n#ifdef _MSC_VER\n    sscanf_s(version, \"%d.%d\", &major, &minor);\n#else\n    sscanf(version, \"%d.%d\", &major, &minor);\n#endif\n    GLVersion.major = major; GLVersion.minor = minor;\n    max_loaded_major = major; max_loaded_minor = minor;\n\tGLAD_GL_VERSION_1_0 = (major == 1 && minor >= 0) || major > 1;\n\tGLAD_GL_VERSION_1_1 = (major == 1 && minor >= 1) || major > 1;\n\tGLAD_GL_VERSION_1_2 = (major == 1 && minor >= 2) || major > 1;\n\tGLAD_GL_VERSION_1_3 = (major == 1 && minor >= 3) || major > 1;\n\tGLAD_GL_VERSION_1_4 = (major == 1 && minor >= 4) || major > 1;\n\tGLAD_GL_VERSION_1_5 = (major == 1 && minor >= 5) || major > 1;\n\tGLAD_GL_VERSION_2_0 = (major == 2 && minor >= 0) || major > 2;\n\tGLAD_GL_VERSION_2_1 = (major == 2 && minor >= 1) || major > 2;\n\tGLAD_GL_VERSION_3_0 = (major == 3 && minor >= 0) || major > 3;\n\tGLAD_GL_VERSION_3_1 = (major == 3 && minor >= 1) || major > 3;\n\tGLAD_GL_VERSION_3_2 = (major == 3 && minor >= 2) || major > 3;\n\tGLAD_GL_VERSION_3_3 = (major == 3 && minor >= 3) || major > 3;\n\tif (GLVersion.major > 3 || (GLVersion.major >= 3 && GLVersion.minor >= 3)) {\n\t\tmax_loaded_major = 3;\n\t\tmax_loaded_minor = 3;\n\t}\n}\nint gladLoadGLLoader(GLADloadproc load) {\n\tGLVersion.major = 0; GLVersion.minor = 0;\n\tglGetString = (PFNGLGETSTRINGPROC)load(\"glGetString\");\n\tif(glGetString == NULL) return 0;\n\tif(glGetString(GL_VERSION) == NULL) return 0;\n\tfind_coreGL();\n\tload_GL_VERSION_1_0(load);\n\tload_GL_VERSION_1_1(load);\n\tload_GL_VERSION_1_2(load);\n\tload_GL_VERSION_1_3(load);\n\tload_GL_VERSION_1_4(load);\n\tload_GL_VERSION_1_5(load);\n\tload_GL_VERSION_2_0(load);\n\tload_GL_VERSION_2_1(load);\n\tload_GL_VERSION_3_0(load);\n\tload_GL_VERSION_3_1(load);\n\tload_GL_VERSION_3_2(load);\n\tload_GL_VERSION_3_3(load);\n\tif (!find_extensionsGL()) return 0;\n\tload_GL_ARB_copy_image(load);\n\tload_GL_ARB_multisample(load);\n\tload_GL_ARB_robustness(load);\n\tload_GL_ARB_texture_storage(load);\n\tload_GL_KHR_debug(load);\n\treturn GLVersion.major != 0 || GLVersion.minor != 0;\n}\nint\ninit_glad(GLADloadproc load, int debug) {\n    int ret = gladLoadGLLoader(load);\n    if (ret && !debug) {\n        glad_debug_glVertexAttribI4i = glad_glVertexAttribI4i;\n        glad_debug_glVertexAttribI4ubv = glad_glVertexAttribI4ubv;\n        glad_debug_glTexCoordP3uiv = glad_glTexCoordP3uiv;\n        glad_debug_glTexParameteriv = glad_glTexParameteriv;\n        glad_debug_glSamplerParameteriv = glad_glSamplerParameteriv;\n        glad_debug_glFrontFace = glad_glFrontFace;\n        glad_debug_glBindBufferRange = glad_glBindBufferRange;\n        glad_debug_glClampColor = glad_glClampColor;\n        glad_debug_glVertexP4ui = glad_glVertexP4ui;\n        glad_debug_glVertexAttrib4Nub = glad_glVertexAttrib4Nub;\n        glad_debug_glVertexAttrib4sv = glad_glVertexAttrib4sv;\n        glad_debug_glVertexAttrib4f = glad_glVertexAttrib4f;\n        glad_debug_glGetProgramInfoLog = glad_glGetProgramInfoLog;\n        glad_debug_glMultiTexCoordP1ui = glad_glMultiTexCoordP1ui;\n        glad_debug_glPolygonOffset = glad_glPolygonOffset;\n        glad_debug_glGenFramebuffers = glad_glGenFramebuffers;\n        glad_debug_glBindTexture = glad_glBindTexture;\n        glad_debug_glFenceSync = glad_glFenceSync;\n        glad_debug_glDrawElementsInstancedBaseVertex = glad_glDrawElementsInstancedBaseVertex;\n        glad_debug_glGetBufferSubData = glad_glGetBufferSubData;\n        glad_debug_glPointParameteri = glad_glPointParameteri;\n        glad_debug_glDrawRangeElements = glad_glDrawRangeElements;\n        glad_debug_glMultiDrawArrays = glad_glMultiDrawArrays;\n        glad_debug_glDrawArrays = glad_glDrawArrays;\n        glad_debug_glGenBuffers = glad_glGenBuffers;\n        glad_debug_glNormalP3ui = glad_glNormalP3ui;\n        glad_debug_glEnablei = glad_glEnablei;\n        glad_debug_glGetQueryObjectui64v = glad_glGetQueryObjectui64v;\n        glad_debug_glVertexAttrib4Nbv = glad_glVertexAttrib4Nbv;\n        glad_debug_glIsEnabledi = glad_glIsEnabledi;\n        glad_debug_glTexSubImage2D = glad_glTexSubImage2D;\n        glad_debug_glGetBufferParameteri64v = glad_glGetBufferParameteri64v;\n        glad_debug_glIsVertexArray = glad_glIsVertexArray;\n        glad_debug_glSamplerParameterf = glad_glSamplerParameterf;\n        glad_debug_glFlush = glad_glFlush;\n        glad_debug_glUniform2iv = glad_glUniform2iv;\n        glad_debug_glTexCoordP1ui = glad_glTexCoordP1ui;\n        glad_debug_glIsEnabled = glad_glIsEnabled;\n        glad_debug_glBufferData = glad_glBufferData;\n        glad_debug_glTexParameterf = glad_glTexParameterf;\n        glad_debug_glGetIntegerv = glad_glGetIntegerv;\n        glad_debug_glVertexAttribP3uiv = glad_glVertexAttribP3uiv;\n        glad_debug_glUniform4f = glad_glUniform4f;\n        glad_debug_glUniform2ui = glad_glUniform2ui;\n        glad_debug_glProvokingVertex = glad_glProvokingVertex;\n        glad_debug_glUniform4i = glad_glUniform4i;\n        glad_debug_glTexParameterIiv = glad_glTexParameterIiv;\n        glad_debug_glDepthMask = glad_glDepthMask;\n        glad_debug_glStencilFuncSeparate = glad_glStencilFuncSeparate;\n        glad_debug_glGetShaderInfoLog = glad_glGetShaderInfoLog;\n        glad_debug_glActiveTexture = glad_glActiveTexture;\n        glad_debug_glPointParameterf = glad_glPointParameterf;\n        glad_debug_glUniformMatrix2fv = glad_glUniformMatrix2fv;\n        glad_debug_glBindBuffer = glad_glBindBuffer;\n        glad_debug_glUniform3fv = glad_glUniform3fv;\n        glad_debug_glEndConditionalRender = glad_glEndConditionalRender;\n        glad_debug_glMultiTexCoordP4ui = glad_glMultiTexCoordP4ui;\n        glad_debug_glGetShaderiv = glad_glGetShaderiv;\n        glad_debug_glVertexAttribI3uiv = glad_glVertexAttribI3uiv;\n        glad_debug_glBeginConditionalRender = glad_glBeginConditionalRender;\n        glad_debug_glVertexAttribI2ui = glad_glVertexAttribI2ui;\n        glad_debug_glGetQueryObjectuiv = glad_glGetQueryObjectuiv;\n        glad_debug_glColorP3uiv = glad_glColorP3uiv;\n        glad_debug_glCompileShader = glad_glCompileShader;\n        glad_debug_glEndTransformFeedback = glad_glEndTransformFeedback;\n        glad_debug_glGetCompressedTexImage = glad_glGetCompressedTexImage;\n        glad_debug_glGenQueries = glad_glGenQueries;\n        glad_debug_glMultiTexCoordP3ui = glad_glMultiTexCoordP3ui;\n        glad_debug_glCopyTexSubImage1D = glad_glCopyTexSubImage1D;\n        glad_debug_glUniformMatrix2x4fv = glad_glUniformMatrix2x4fv;\n        glad_debug_glGetQueryiv = glad_glGetQueryiv;\n        glad_debug_glGetSamplerParameterfv = glad_glGetSamplerParameterfv;\n        glad_debug_glGetShaderSource = glad_glGetShaderSource;\n        glad_debug_glIsRenderbuffer = glad_glIsRenderbuffer;\n        glad_debug_glVertexAttribDivisor = glad_glVertexAttribDivisor;\n        glad_debug_glCullFace = glad_glCullFace;\n        glad_debug_glCompressedTexSubImage2D = glad_glCompressedTexSubImage2D;\n        glad_debug_glStencilOpSeparate = glad_glStencilOpSeparate;\n        glad_debug_glGetActiveUniformName = glad_glGetActiveUniformName;\n        glad_debug_glBindBufferBase = glad_glBindBufferBase;\n        glad_debug_glVertexAttrib3f = glad_glVertexAttrib3f;\n        glad_debug_glClearStencil = glad_glClearStencil;\n        glad_debug_glBindAttribLocation = glad_glBindAttribLocation;\n        glad_debug_glBindVertexArray = glad_glBindVertexArray;\n        glad_debug_glVertexAttrib4Nubv = glad_glVertexAttrib4Nubv;\n        glad_debug_glRenderbufferStorageMultisample = glad_glRenderbufferStorageMultisample;\n        glad_debug_glTexImage2DMultisample = glad_glTexImage2DMultisample;\n        glad_debug_glSamplerParameterfv = glad_glSamplerParameterfv;\n        glad_debug_glVertexAttribI4sv = glad_glVertexAttribI4sv;\n        glad_debug_glColorMask = glad_glColorMask;\n        glad_debug_glBindSampler = glad_glBindSampler;\n        glad_debug_glTexCoordP4uiv = glad_glTexCoordP4uiv;\n        glad_debug_glVertexAttribI1iv = glad_glVertexAttribI1iv;\n        glad_debug_glLinkProgram = glad_glLinkProgram;\n        glad_debug_glUniform2i = glad_glUniform2i;\n        glad_debug_glDeleteVertexArrays = glad_glDeleteVertexArrays;\n        glad_debug_glCompressedTexImage3D = glad_glCompressedTexImage3D;\n        glad_debug_glClearBufferfi = glad_glClearBufferfi;\n        glad_debug_glVertexP3uiv = glad_glVertexP3uiv;\n        glad_debug_glValidateProgram = glad_glValidateProgram;\n        glad_debug_glVertexAttrib3d = glad_glVertexAttrib3d;\n        glad_debug_glReadPixels = glad_glReadPixels;\n        glad_debug_glColorP4ui = glad_glColorP4ui;\n        glad_debug_glClear = glad_glClear;\n        glad_debug_glVertexAttrib1d = glad_glVertexAttrib1d;\n        glad_debug_glDrawElements = glad_glDrawElements;\n        glad_debug_glPolygonMode = glad_glPolygonMode;\n        glad_debug_glVertexAttrib4Niv = glad_glVertexAttrib4Niv;\n        glad_debug_glDeleteBuffers = glad_glDeleteBuffers;\n        glad_debug_glGetUniformBlockIndex = glad_glGetUniformBlockIndex;\n        glad_debug_glPixelStoref = glad_glPixelStoref;\n        glad_debug_glDrawElementsInstanced = glad_glDrawElementsInstanced;\n        glad_debug_glCreateProgram = glad_glCreateProgram;\n        glad_debug_glUseProgram = glad_glUseProgram;\n        glad_debug_glVertexAttrib3s = glad_glVertexAttrib3s;\n        glad_debug_glVertexAttrib4fv = glad_glVertexAttrib4fv;\n        glad_debug_glVertexAttrib4s = glad_glVertexAttrib4s;\n        glad_debug_glGetQueryObjecti64v = glad_glGetQueryObjecti64v;\n        glad_debug_glSampleCoverage = glad_glSampleCoverage;\n        glad_debug_glEndQuery = glad_glEndQuery;\n        glad_debug_glGetMultisamplefv = glad_glGetMultisamplefv;\n        glad_debug_glTexCoordP1uiv = glad_glTexCoordP1uiv;\n        glad_debug_glCompressedTexSubImage1D = glad_glCompressedTexSubImage1D;\n        glad_debug_glVertexAttrib4bv = glad_glVertexAttrib4bv;\n        glad_debug_glBeginQuery = glad_glBeginQuery;\n        glad_debug_glUniform3ui = glad_glUniform3ui;\n        glad_debug_glGetAttachedShaders = glad_glGetAttachedShaders;\n        glad_debug_glClientWaitSync = glad_glClientWaitSync;\n        glad_debug_glGetVertexAttribIuiv = glad_glGetVertexAttribIuiv;\n        glad_debug_glCheckFramebufferStatus = glad_glCheckFramebufferStatus;\n        glad_debug_glPointSize = glad_glPointSize;\n        glad_debug_glTexParameteri = glad_glTexParameteri;\n        glad_debug_glVertexAttrib1sv = glad_glVertexAttrib1sv;\n        glad_debug_glVertexAttrib1f = glad_glVertexAttrib1f;\n        glad_debug_glGenVertexArrays = glad_glGenVertexArrays;\n        glad_debug_glUniform2uiv = glad_glUniform2uiv;\n        glad_debug_glMultiDrawElements = glad_glMultiDrawElements;\n        glad_debug_glUniform1f = glad_glUniform1f;\n        glad_debug_glGetVertexAttribiv = glad_glGetVertexAttribiv;\n        glad_debug_glStencilMask = glad_glStencilMask;\n        glad_debug_glStencilMaskSeparate = glad_glStencilMaskSeparate;\n        glad_debug_glEnable = glad_glEnable;\n        glad_debug_glVertexAttrib2f = glad_glVertexAttrib2f;\n        glad_debug_glVertexAttribP4ui = glad_glVertexAttribP4ui;\n        glad_debug_glGetTexParameterIiv = glad_glGetTexParameterIiv;\n        glad_debug_glColorP3ui = glad_glColorP3ui;\n        glad_debug_glCopyTexImage2D = glad_glCopyTexImage2D;\n        glad_debug_glMapBuffer = glad_glMapBuffer;\n        glad_debug_glUniform1ui = glad_glUniform1ui;\n        glad_debug_glReadBuffer = glad_glReadBuffer;\n        glad_debug_glDrawBuffers = glad_glDrawBuffers;\n        glad_debug_glFramebufferTexture = glad_glFramebufferTexture;\n        glad_debug_glVertexAttribI4bv = glad_glVertexAttribI4bv;\n        glad_debug_glVertexAttribI4iv = glad_glVertexAttribI4iv;\n        glad_debug_glGetStringi = glad_glGetStringi;\n        glad_debug_glGetBufferPointerv = glad_glGetBufferPointerv;\n        glad_debug_glGetUniformuiv = glad_glGetUniformuiv;\n        glad_debug_glVertexAttrib3fv = glad_glVertexAttrib3fv;\n        glad_debug_glVertexAttribI4ui = glad_glVertexAttribI4ui;\n        glad_debug_glClearBufferfv = glad_glClearBufferfv;\n        glad_debug_glFramebufferTextureLayer = glad_glFramebufferTextureLayer;\n        glad_debug_glMultiTexCoordP2ui = glad_glMultiTexCoordP2ui;\n        glad_debug_glCopyTexSubImage2D = glad_glCopyTexSubImage2D;\n        glad_debug_glVertexAttrib2sv = glad_glVertexAttrib2sv;\n        glad_debug_glIsQuery = glad_glIsQuery;\n        glad_debug_glGetActiveUniformBlockName = glad_glGetActiveUniformBlockName;\n        glad_debug_glGetTexLevelParameteriv = glad_glGetTexLevelParameteriv;\n        glad_debug_glGetSynciv = glad_glGetSynciv;\n        glad_debug_glGetTexParameteriv = glad_glGetTexParameteriv;\n        glad_debug_glMultiTexCoordP3uiv = glad_glMultiTexCoordP3uiv;\n        glad_debug_glNormalP3uiv = glad_glNormalP3uiv;\n        glad_debug_glGetActiveUniformsiv = glad_glGetActiveUniformsiv;\n        glad_debug_glPrimitiveRestartIndex = glad_glPrimitiveRestartIndex;\n        glad_debug_glDepthFunc = glad_glDepthFunc;\n        glad_debug_glVertexAttribP3ui = glad_glVertexAttribP3ui;\n        glad_debug_glDisableVertexAttribArray = glad_glDisableVertexAttribArray;\n        glad_debug_glMultiTexCoordP2uiv = glad_glMultiTexCoordP2uiv;\n        glad_debug_glStencilOp = glad_glStencilOp;\n        glad_debug_glVertexAttrib1s = glad_glVertexAttrib1s;\n        glad_debug_glSampleMaski = glad_glSampleMaski;\n        glad_debug_glVertexP2uiv = glad_glVertexP2uiv;\n        glad_debug_glUniform3iv = glad_glUniform3iv;\n        glad_debug_glDeleteSync = glad_glDeleteSync;\n        glad_debug_glBlendEquation = glad_glBlendEquation;\n        glad_debug_glVertexAttribI3i = glad_glVertexAttribI3i;\n        glad_debug_glLogicOp = glad_glLogicOp;\n        glad_debug_glBindFragDataLocationIndexed = glad_glBindFragDataLocationIndexed;\n        glad_debug_glVertexAttrib4usv = glad_glVertexAttrib4usv;\n        glad_debug_glGetActiveAttrib = glad_glGetActiveAttrib;\n        glad_debug_glClearBufferuiv = glad_glClearBufferuiv;\n        glad_debug_glMapBufferRange = glad_glMapBufferRange;\n        glad_debug_glRenderbufferStorage = glad_glRenderbufferStorage;\n        glad_debug_glPointParameterfv = glad_glPointParameterfv;\n        glad_debug_glVertexAttrib4d = glad_glVertexAttrib4d;\n        glad_debug_glSamplerParameteri = glad_glSamplerParameteri;\n        glad_debug_glVertexAttrib4dv = glad_glVertexAttrib4dv;\n        glad_debug_glTexBuffer = glad_glTexBuffer;\n        glad_debug_glTexParameterfv = glad_glTexParameterfv;\n        glad_debug_glTexCoordP3ui = glad_glTexCoordP3ui;\n        glad_debug_glGetProgramiv = glad_glGetProgramiv;\n        glad_debug_glFramebufferTexture1D = glad_glFramebufferTexture1D;\n        glad_debug_glVertexAttrib2dv = glad_glVertexAttrib2dv;\n        glad_debug_glGetUniformLocation = glad_glGetUniformLocation;\n        glad_debug_glUniform1i = glad_glUniform1i;\n        glad_debug_glBlendFunc = glad_glBlendFunc;\n        glad_debug_glGetSamplerParameterIiv = glad_glGetSamplerParameterIiv;\n        glad_debug_glVertexAttrib3dv = glad_glVertexAttrib3dv;\n        glad_debug_glDrawArraysInstanced = glad_glDrawArraysInstanced;\n        glad_debug_glVertexAttrib4Nusv = glad_glVertexAttrib4Nusv;\n        glad_debug_glIsProgram = glad_glIsProgram;\n        glad_debug_glVertexAttrib4Nuiv = glad_glVertexAttrib4Nuiv;\n        glad_debug_glDeleteProgram = glad_glDeleteProgram;\n        glad_debug_glVertexAttrib2fv = glad_glVertexAttrib2fv;\n        glad_debug_glVertexAttrib3sv = glad_glVertexAttrib3sv;\n        glad_debug_glIsBuffer = glad_glIsBuffer;\n        glad_debug_glHint = glad_glHint;\n        glad_debug_glVertexAttrib4ubv = glad_glVertexAttrib4ubv;\n        glad_debug_glTexSubImage1D = glad_glTexSubImage1D;\n        glad_debug_glGetActiveUniformBlockiv = glad_glGetActiveUniformBlockiv;\n        glad_debug_glVertexAttribI2uiv = glad_glVertexAttribI2uiv;\n        glad_debug_glDeleteShader = glad_glDeleteShader;\n        glad_debug_glGetBooleanv = glad_glGetBooleanv;\n        glad_debug_glCopyBufferSubData = glad_glCopyBufferSubData;\n        glad_debug_glClearColor = glad_glClearColor;\n        glad_debug_glSecondaryColorP3ui = glad_glSecondaryColorP3ui;\n        glad_debug_glDeleteTextures = glad_glDeleteTextures;\n        glad_debug_glQueryCounter = glad_glQueryCounter;\n        glad_debug_glStencilFunc = glad_glStencilFunc;\n        glad_debug_glBindFramebuffer = glad_glBindFramebuffer;\n        glad_debug_glUniformMatrix3x2fv = glad_glUniformMatrix3x2fv;\n        glad_debug_glCompressedTexImage1D = glad_glCompressedTexImage1D;\n        glad_debug_glSamplerParameterIuiv = glad_glSamplerParameterIuiv;\n        glad_debug_glBindRenderbuffer = glad_glBindRenderbuffer;\n        glad_debug_glTexCoordP2uiv = glad_glTexCoordP2uiv;\n        glad_debug_glVertexAttribP4uiv = glad_glVertexAttribP4uiv;\n        glad_debug_glDeleteQueries = glad_glDeleteQueries;\n        glad_debug_glDetachShader = glad_glDetachShader;\n        glad_debug_glVertexAttrib1dv = glad_glVertexAttrib1dv;\n        glad_debug_glGetAttribLocation = glad_glGetAttribLocation;\n        glad_debug_glGenTextures = glad_glGenTextures;\n        glad_debug_glGetTexLevelParameterfv = glad_glGetTexLevelParameterfv;\n        glad_debug_glUniformMatrix4x2fv = glad_glUniformMatrix4x2fv;\n        glad_debug_glUniformMatrix3x4fv = glad_glUniformMatrix3x4fv;\n        glad_debug_glWaitSync = glad_glWaitSync;\n        glad_debug_glTexImage2D = glad_glTexImage2D;\n        glad_debug_glTexParameterIuiv = glad_glTexParameterIuiv;\n        glad_debug_glIsSync = glad_glIsSync;\n        glad_debug_glVertexP3ui = glad_glVertexP3ui;\n        glad_debug_glVertexAttribI1ui = glad_glVertexAttribI1ui;\n        glad_debug_glMultiTexCoordP1uiv = glad_glMultiTexCoordP1uiv;\n        glad_debug_glUniform3f = glad_glUniform3f;\n        glad_debug_glVertexAttrib4uiv = glad_glVertexAttrib4uiv;\n        glad_debug_glTexCoordP2ui = glad_glTexCoordP2ui;\n        glad_debug_glUnmapBuffer = glad_glUnmapBuffer;\n        glad_debug_glUniformMatrix2x3fv = glad_glUniformMatrix2x3fv;\n        glad_debug_glFramebufferTexture3D = glad_glFramebufferTexture3D;\n        glad_debug_glClearBufferiv = glad_glClearBufferiv;\n        glad_debug_glDepthRange = glad_glDepthRange;\n        glad_debug_glGetQueryObjectiv = glad_glGetQueryObjectiv;\n        glad_debug_glTexCoordP4ui = glad_glTexCoordP4ui;\n        glad_debug_glUniformMatrix4fv = glad_glUniformMatrix4fv;\n        glad_debug_glShaderSource = glad_glShaderSource;\n        glad_debug_glUniformMatrix4x3fv = glad_glUniformMatrix4x3fv;\n        glad_debug_glVertexAttribP1uiv = glad_glVertexAttribP1uiv;\n        glad_debug_glCreateShader = glad_glCreateShader;\n        glad_debug_glUniform4ui = glad_glUniform4ui;\n        glad_debug_glGetFragDataIndex = glad_glGetFragDataIndex;\n        glad_debug_glCompressedTexSubImage3D = glad_glCompressedTexSubImage3D;\n        glad_debug_glUniform1uiv = glad_glUniform1uiv;\n        glad_debug_glUniformBlockBinding = glad_glUniformBlockBinding;\n        glad_debug_glClearDepth = glad_glClearDepth;\n        glad_debug_glLineWidth = glad_glLineWidth;\n        glad_debug_glUniform2f = glad_glUniform2f;\n        glad_debug_glDrawElementsBaseVertex = glad_glDrawElementsBaseVertex;\n        glad_debug_glUniform4iv = glad_glUniform4iv;\n        glad_debug_glBlitFramebuffer = glad_glBlitFramebuffer;\n        glad_debug_glGetTransformFeedbackVarying = glad_glGetTransformFeedbackVarying;\n        glad_debug_glBlendEquationSeparate = glad_glBlendEquationSeparate;\n        glad_debug_glTransformFeedbackVaryings = glad_glTransformFeedbackVaryings;\n        glad_debug_glGenRenderbuffers = glad_glGenRenderbuffers;\n        glad_debug_glDrawBuffer = glad_glDrawBuffer;\n        glad_debug_glCompressedTexImage2D = glad_glCompressedTexImage2D;\n        glad_debug_glGetSamplerParameterIuiv = glad_glGetSamplerParameterIuiv;\n        glad_debug_glGetFloatv = glad_glGetFloatv;\n        glad_debug_glVertexAttribI1uiv = glad_glVertexAttribI1uiv;\n        glad_debug_glGetActiveUniform = glad_glGetActiveUniform;\n        glad_debug_glTexSubImage3D = glad_glTexSubImage3D;\n        glad_debug_glEnableVertexAttribArray = glad_glEnableVertexAttribArray;\n        glad_debug_glUniform1iv = glad_glUniform1iv;\n        glad_debug_glVertexP4uiv = glad_glVertexP4uiv;\n        glad_debug_glGenerateMipmap = glad_glGenerateMipmap;\n        glad_debug_glFlushMappedBufferRange = glad_glFlushMappedBufferRange;\n        glad_debug_glFramebufferRenderbuffer = glad_glFramebufferRenderbuffer;\n        glad_debug_glColorP4uiv = glad_glColorP4uiv;\n        glad_debug_glSecondaryColorP3uiv = glad_glSecondaryColorP3uiv;\n        glad_debug_glDeleteFramebuffers = glad_glDeleteFramebuffers;\n        glad_debug_glUniform4uiv = glad_glUniform4uiv;\n        glad_debug_glColorMaski = glad_glColorMaski;\n        glad_debug_glUniform2fv = glad_glUniform2fv;\n        glad_debug_glViewport = glad_glViewport;\n        glad_debug_glGetUniformIndices = glad_glGetUniformIndices;\n        glad_debug_glBeginTransformFeedback = glad_glBeginTransformFeedback;\n        glad_debug_glVertexAttribP1ui = glad_glVertexAttribP1ui;\n        glad_debug_glDeleteRenderbuffers = glad_glDeleteRenderbuffers;\n        glad_debug_glGetInteger64v = glad_glGetInteger64v;\n        glad_debug_glGetVertexAttribdv = glad_glGetVertexAttribdv;\n        glad_debug_glVertexAttribI3iv = glad_glVertexAttribI3iv;\n        glad_debug_glPixelStorei = glad_glPixelStorei;\n        glad_debug_glIsShader = glad_glIsShader;\n        glad_debug_glGenSamplers = glad_glGenSamplers;\n        glad_debug_glVertexAttribI2iv = glad_glVertexAttribI2iv;\n        glad_debug_glAttachShader = glad_glAttachShader;\n        glad_debug_glFramebufferTexture2D = glad_glFramebufferTexture2D;\n        glad_debug_glFinish = glad_glFinish;\n        glad_debug_glDisable = glad_glDisable;\n        glad_debug_glVertexAttribI4uiv = glad_glVertexAttribI4uiv;\n        glad_debug_glVertexAttribIPointer = glad_glVertexAttribIPointer;\n        glad_debug_glBlendColor = glad_glBlendColor;\n        glad_debug_glBufferSubData = glad_glBufferSubData;\n        glad_debug_glTexImage3DMultisample = glad_glTexImage3DMultisample;\n        glad_debug_glVertexAttribI4usv = glad_glVertexAttribI4usv;\n        glad_debug_glUniform3uiv = glad_glUniform3uiv;\n        glad_debug_glGetRenderbufferParameteriv = glad_glGetRenderbufferParameteriv;\n        glad_debug_glVertexAttrib2s = glad_glVertexAttrib2s;\n        glad_debug_glGetFramebufferAttachmentParameteriv = glad_glGetFramebufferAttachmentParameteriv;\n        glad_debug_glGetError = glad_glGetError;\n        glad_debug_glDisablei = glad_glDisablei;\n        glad_debug_glVertexAttrib2d = glad_glVertexAttrib2d;\n        glad_debug_glGetVertexAttribPointerv = glad_glGetVertexAttribPointerv;\n        glad_debug_glTexImage1D = glad_glTexImage1D;\n        glad_debug_glGetString = glad_glGetString;\n        glad_debug_glGetSamplerParameteriv = glad_glGetSamplerParameteriv;\n        glad_debug_glVertexAttrib1fv = glad_glVertexAttrib1fv;\n        glad_debug_glGetUniformfv = glad_glGetUniformfv;\n        glad_debug_glDeleteSamplers = glad_glDeleteSamplers;\n        glad_debug_glVertexAttribP2uiv = glad_glVertexAttribP2uiv;\n        glad_debug_glUniform1fv = glad_glUniform1fv;\n        glad_debug_glDrawRangeElementsBaseVertex = glad_glDrawRangeElementsBaseVertex;\n        glad_debug_glUniform4fv = glad_glUniform4fv;\n        glad_debug_glCopyTexSubImage3D = glad_glCopyTexSubImage3D;\n        glad_debug_glIsFramebuffer = glad_glIsFramebuffer;\n        glad_debug_glSamplerParameterIiv = glad_glSamplerParameterIiv;\n        glad_debug_glUniform3i = glad_glUniform3i;\n        glad_debug_glMultiTexCoordP4uiv = glad_glMultiTexCoordP4uiv;\n        glad_debug_glVertexAttribI1i = glad_glVertexAttribI1i;\n        glad_debug_glVertexAttrib4iv = glad_glVertexAttrib4iv;\n        glad_debug_glPointParameteriv = glad_glPointParameteriv;\n        glad_debug_glGetBufferParameteriv = glad_glGetBufferParameteriv;\n        glad_debug_glGetFragDataLocation = glad_glGetFragDataLocation;\n        glad_debug_glBindFragDataLocation = glad_glBindFragDataLocation;\n        glad_debug_glGetVertexAttribfv = glad_glGetVertexAttribfv;\n        glad_debug_glScissor = glad_glScissor;\n        glad_debug_glGetTexImage = glad_glGetTexImage;\n        glad_debug_glGetVertexAttribIiv = glad_glGetVertexAttribIiv;\n        glad_debug_glTexImage3D = glad_glTexImage3D;\n        glad_debug_glVertexP2ui = glad_glVertexP2ui;\n        glad_debug_glMultiDrawElementsBaseVertex = glad_glMultiDrawElementsBaseVertex;\n        glad_debug_glIsTexture = glad_glIsTexture;\n        glad_debug_glVertexAttribPointer = glad_glVertexAttribPointer;\n        glad_debug_glGetUniformiv = glad_glGetUniformiv;\n        glad_debug_glBlendFuncSeparate = glad_glBlendFuncSeparate;\n        glad_debug_glUniformMatrix3fv = glad_glUniformMatrix3fv;\n        glad_debug_glIsSampler = glad_glIsSampler;\n        glad_debug_glGetTexParameterfv = glad_glGetTexParameterfv;\n        glad_debug_glVertexAttrib4Nsv = glad_glVertexAttrib4Nsv;\n        glad_debug_glVertexAttribI2i = glad_glVertexAttribI2i;\n        glad_debug_glVertexAttribP2ui = glad_glVertexAttribP2ui;\n        glad_debug_glGetTexParameterIuiv = glad_glGetTexParameterIuiv;\n        glad_debug_glVertexAttribI3ui = glad_glVertexAttribI3ui;\n        glad_debug_glCopyTexImage1D = glad_glCopyTexImage1D;\n        glad_debug_glGetDoublev = glad_glGetDoublev;\n        glad_debug_glCopyImageSubData = glad_glCopyImageSubData;\n        glad_debug_glSampleCoverageARB = glad_glSampleCoverageARB;\n        glad_debug_glGetGraphicsResetStatusARB = glad_glGetGraphicsResetStatusARB;\n        glad_debug_glGetnTexImageARB = glad_glGetnTexImageARB;\n        glad_debug_glReadnPixelsARB = glad_glReadnPixelsARB;\n        glad_debug_glGetnCompressedTexImageARB = glad_glGetnCompressedTexImageARB;\n        glad_debug_glGetnUniformfvARB = glad_glGetnUniformfvARB;\n        glad_debug_glGetnUniformivARB = glad_glGetnUniformivARB;\n        glad_debug_glGetnUniformuivARB = glad_glGetnUniformuivARB;\n        glad_debug_glGetnUniformdvARB = glad_glGetnUniformdvARB;\n        glad_debug_glGetnMapdvARB = glad_glGetnMapdvARB;\n        glad_debug_glGetnMapfvARB = glad_glGetnMapfvARB;\n        glad_debug_glGetnMapivARB = glad_glGetnMapivARB;\n        glad_debug_glGetnPixelMapfvARB = glad_glGetnPixelMapfvARB;\n        glad_debug_glGetnPixelMapuivARB = glad_glGetnPixelMapuivARB;\n        glad_debug_glGetnPixelMapusvARB = glad_glGetnPixelMapusvARB;\n        glad_debug_glGetnPolygonStippleARB = glad_glGetnPolygonStippleARB;\n        glad_debug_glGetnColorTableARB = glad_glGetnColorTableARB;\n        glad_debug_glGetnConvolutionFilterARB = glad_glGetnConvolutionFilterARB;\n        glad_debug_glGetnSeparableFilterARB = glad_glGetnSeparableFilterARB;\n        glad_debug_glGetnHistogramARB = glad_glGetnHistogramARB;\n        glad_debug_glGetnMinmaxARB = glad_glGetnMinmaxARB;\n        glad_debug_glTexStorage1D = glad_glTexStorage1D;\n        glad_debug_glTexStorage2D = glad_glTexStorage2D;\n        glad_debug_glTexStorage3D = glad_glTexStorage3D;\n        glad_debug_glDebugMessageControl = glad_glDebugMessageControl;\n        glad_debug_glDebugMessageInsert = glad_glDebugMessageInsert;\n        glad_debug_glDebugMessageCallback = glad_glDebugMessageCallback;\n        glad_debug_glGetDebugMessageLog = glad_glGetDebugMessageLog;\n        glad_debug_glPushDebugGroup = glad_glPushDebugGroup;\n        glad_debug_glPopDebugGroup = glad_glPopDebugGroup;\n        glad_debug_glObjectLabel = glad_glObjectLabel;\n        glad_debug_glGetObjectLabel = glad_glGetObjectLabel;\n        glad_debug_glObjectPtrLabel = glad_glObjectPtrLabel;\n        glad_debug_glGetObjectPtrLabel = glad_glGetObjectPtrLabel;\n        glad_debug_glGetPointerv = glad_glGetPointerv;\n        glad_debug_glDebugMessageControlKHR = glad_glDebugMessageControlKHR;\n        glad_debug_glDebugMessageInsertKHR = glad_glDebugMessageInsertKHR;\n        glad_debug_glDebugMessageCallbackKHR = glad_glDebugMessageCallbackKHR;\n        glad_debug_glGetDebugMessageLogKHR = glad_glGetDebugMessageLogKHR;\n        glad_debug_glPushDebugGroupKHR = glad_glPushDebugGroupKHR;\n        glad_debug_glPopDebugGroupKHR = glad_glPopDebugGroupKHR;\n        glad_debug_glObjectLabelKHR = glad_glObjectLabelKHR;\n        glad_debug_glGetObjectLabelKHR = glad_glGetObjectLabelKHR;\n        glad_debug_glObjectPtrLabelKHR = glad_glObjectPtrLabelKHR;\n        glad_debug_glGetObjectPtrLabelKHR = glad_glGetObjectPtrLabelKHR;\n        glad_debug_glGetPointervKHR = glad_glGetPointervKHR;\n    }\n    return ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/glfw/egl_context.c": "//========================================================================\n// GLFW 3.3 EGL - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2016 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n\n// Return a description of the specified EGL error\n//\nstatic const char* getEGLErrorString(EGLint error)\n{\n    switch (error)\n    {\n        case EGL_SUCCESS:\n            return \"Success\";\n        case EGL_NOT_INITIALIZED:\n            return \"EGL is not or could not be initialized\";\n        case EGL_BAD_ACCESS:\n            return \"EGL cannot access a requested resource\";\n        case EGL_BAD_ALLOC:\n            return \"EGL failed to allocate resources for the requested operation\";\n        case EGL_BAD_ATTRIBUTE:\n            return \"An unrecognized attribute or attribute value was passed in the attribute list\";\n        case EGL_BAD_CONTEXT:\n            return \"An EGLContext argument does not name a valid EGL rendering context\";\n        case EGL_BAD_CONFIG:\n            return \"An EGLConfig argument does not name a valid EGL frame buffer configuration\";\n        case EGL_BAD_CURRENT_SURFACE:\n            return \"The current surface of the calling thread is a window, pixel buffer or pixmap that is no longer valid\";\n        case EGL_BAD_DISPLAY:\n            return \"An EGLDisplay argument does not name a valid EGL display connection\";\n        case EGL_BAD_SURFACE:\n            return \"An EGLSurface argument does not name a valid surface configured for GL rendering\";\n        case EGL_BAD_MATCH:\n            return \"Arguments are inconsistent\";\n        case EGL_BAD_PARAMETER:\n            return \"One or more argument values are invalid\";\n        case EGL_BAD_NATIVE_PIXMAP:\n            return \"A NativePixmapType argument does not refer to a valid native pixmap\";\n        case EGL_BAD_NATIVE_WINDOW:\n            return \"A NativeWindowType argument does not refer to a valid native window\";\n        case EGL_CONTEXT_LOST:\n            return \"The application must destroy all contexts and reinitialise\";\n        default:\n            return \"ERROR: UNKNOWN EGL ERROR\";\n    }\n}\n\n// Returns the specified attribute of the specified EGLConfig\n//\nstatic int getEGLConfigAttrib(EGLConfig config, int attrib)\n{\n    int value;\n    eglGetConfigAttrib(_glfw.egl.display, config, attrib, &value);\n    return value;\n}\n\n// Return the EGLConfig most closely matching the specified hints\n//\nstatic GLFWbool chooseEGLConfig(const _GLFWctxconfig* ctxconfig,\n                                const _GLFWfbconfig* desired,\n                                EGLConfig* result)\n{\n    EGLConfig* nativeConfigs;\n    _GLFWfbconfig* usableConfigs;\n    const _GLFWfbconfig* closest;\n    int i, nativeCount, usableCount;\n\n    eglGetConfigs(_glfw.egl.display, NULL, 0, &nativeCount);\n    if (!nativeCount)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"EGL: No EGLConfigs returned\");\n        return GLFW_FALSE;\n    }\n\n    nativeConfigs = calloc(nativeCount, sizeof(EGLConfig));\n    eglGetConfigs(_glfw.egl.display, nativeConfigs, nativeCount, &nativeCount);\n\n    usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));\n    usableCount = 0;\n\n    for (i = 0;  i < nativeCount;  i++)\n    {\n        const EGLConfig n = nativeConfigs[i];\n        _GLFWfbconfig* u = usableConfigs + usableCount;\n\n        // Only consider RGB(A) EGLConfigs\n        if (getEGLConfigAttrib(n, EGL_COLOR_BUFFER_TYPE) != EGL_RGB_BUFFER)\n            continue;\n\n        // Only consider window EGLConfigs\n        if (!(getEGLConfigAttrib(n, EGL_SURFACE_TYPE) & EGL_WINDOW_BIT))\n            continue;\n\n#if defined(_GLFW_X11)\n        XVisualInfo vi = {0};\n\n        // Only consider EGLConfigs with associated Visuals\n        vi.visualid = getEGLConfigAttrib(n, EGL_NATIVE_VISUAL_ID);\n        if (!vi.visualid)\n            continue;\n\n        if (desired->transparent)\n        {\n            int count;\n            XVisualInfo* vis = XGetVisualInfo(_glfw.x11.display,\n                                              VisualIDMask, &vi,\n                                              &count);\n            if (vis)\n            {\n                u->transparent = _glfwIsVisualTransparentX11(vis[0].visual);\n                XFree(vis);\n            }\n        }\n#endif // _GLFW_X11\n\n        if (ctxconfig->client == GLFW_OPENGL_ES_API)\n        {\n            if (ctxconfig->major == 1)\n            {\n                if (!(getEGLConfigAttrib(n, EGL_RENDERABLE_TYPE) & EGL_OPENGL_ES_BIT))\n                    continue;\n            }\n            else\n            {\n                if (!(getEGLConfigAttrib(n, EGL_RENDERABLE_TYPE) & EGL_OPENGL_ES2_BIT))\n                    continue;\n            }\n        }\n        else if (ctxconfig->client == GLFW_OPENGL_API)\n        {\n            if (!(getEGLConfigAttrib(n, EGL_RENDERABLE_TYPE) & EGL_OPENGL_BIT))\n                continue;\n        }\n\n        u->redBits = getEGLConfigAttrib(n, EGL_RED_SIZE);\n        u->greenBits = getEGLConfigAttrib(n, EGL_GREEN_SIZE);\n        u->blueBits = getEGLConfigAttrib(n, EGL_BLUE_SIZE);\n\n        u->alphaBits = getEGLConfigAttrib(n, EGL_ALPHA_SIZE);\n        u->depthBits = getEGLConfigAttrib(n, EGL_DEPTH_SIZE);\n        u->stencilBits = getEGLConfigAttrib(n, EGL_STENCIL_SIZE);\n\n        u->samples = getEGLConfigAttrib(n, EGL_SAMPLES);\n        u->doublebuffer = GLFW_TRUE;\n\n        u->handle = (uintptr_t) n;\n        usableCount++;\n    }\n\n    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);\n    if (closest)\n        *result = (EGLConfig) closest->handle;\n\n    free(nativeConfigs);\n    free(usableConfigs);\n\n    return closest != NULL;\n}\n\nstatic void makeContextCurrentEGL(_GLFWwindow* window)\n{\n    if (window)\n    {\n        if (!eglMakeCurrent(_glfw.egl.display,\n                            window->context.egl.surface,\n                            window->context.egl.surface,\n                            window->context.egl.handle))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"EGL: Failed to make context current: %s\",\n                            getEGLErrorString(eglGetError()));\n            return;\n        }\n    }\n    else\n    {\n        if (!eglMakeCurrent(_glfw.egl.display,\n                            EGL_NO_SURFACE,\n                            EGL_NO_SURFACE,\n                            EGL_NO_CONTEXT))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"EGL: Failed to clear current context: %s\",\n                            getEGLErrorString(eglGetError()));\n            return;\n        }\n    }\n\n    _glfwPlatformSetTls(&_glfw.contextSlot, window);\n}\n\nstatic void swapBuffersEGL(_GLFWwindow* window)\n{\n    if (window != _glfwPlatformGetTls(&_glfw.contextSlot))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"EGL: The context must be current on the calling thread when swapping buffers\");\n        return;\n    }\n\n    eglSwapBuffers(_glfw.egl.display, window->context.egl.surface);\n}\n\nstatic void swapIntervalEGL(int interval)\n{\n    eglSwapInterval(_glfw.egl.display, interval);\n}\n\nstatic int extensionSupportedEGL(const char* extension)\n{\n    const char* extensions = eglQueryString(_glfw.egl.display, EGL_EXTENSIONS);\n    if (extensions)\n    {\n        if (_glfwStringInExtensionString(extension, extensions))\n            return GLFW_TRUE;\n    }\n\n    return GLFW_FALSE;\n}\n\nstatic GLFWglproc getProcAddressEGL(const char* procname)\n{\n    _GLFWwindow* window = _glfwPlatformGetTls(&_glfw.contextSlot);\n\n    if (window->context.egl.client)\n    {\n        GLFWglproc proc = (GLFWglproc) _glfw_dlsym(window->context.egl.client,\n                                                   procname);\n        if (proc)\n            return proc;\n    }\n\n    return eglGetProcAddress(procname);\n}\n\nstatic void destroyContextEGL(_GLFWwindow* window)\n{\n#if defined(_GLFW_X11)\n    // NOTE: Do not unload libGL.so.1 while the X11 display is still open,\n    //       as it will make XCloseDisplay segfault\n    if (window->context.client != GLFW_OPENGL_API)\n#endif // _GLFW_X11\n    {\n        if (window->context.egl.client)\n        {\n            _glfw_dlclose(window->context.egl.client);\n            window->context.egl.client = NULL;\n        }\n    }\n\n    if (window->context.egl.surface)\n    {\n        eglDestroySurface(_glfw.egl.display, window->context.egl.surface);\n        window->context.egl.surface = EGL_NO_SURFACE;\n    }\n\n    if (window->context.egl.handle)\n    {\n        eglDestroyContext(_glfw.egl.display, window->context.egl.handle);\n        window->context.egl.handle = EGL_NO_CONTEXT;\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Initialize EGL\n//\nGLFWbool _glfwInitEGL(void)\n{\n    int i;\n    const char* sonames[] =\n    {\n#if defined(_GLFW_EGL_LIBRARY)\n        _GLFW_EGL_LIBRARY,\n#elif defined(_GLFW_WIN32)\n        \"libEGL.dll\",\n        \"EGL.dll\",\n#elif defined(_GLFW_COCOA)\n        \"libEGL.dylib\",\n#elif defined(__CYGWIN__)\n        \"libEGL-1.so\",\n#else\n        \"libEGL.so.1\",\n#endif\n        NULL\n    };\n\n    if (_glfw.egl.handle)\n        return GLFW_TRUE;\n\n    for (i = 0;  sonames[i];  i++)\n    {\n        _glfw.egl.handle = _glfw_dlopen(sonames[i]);\n        if (_glfw.egl.handle)\n            break;\n    }\n\n    if (!_glfw.egl.handle)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"EGL: Library not found\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.egl.prefix = (strncmp(sonames[i], \"lib\", 3) == 0);\n\n    _glfw.egl.GetConfigAttrib = (PFN_eglGetConfigAttrib)\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetConfigAttrib\");\n    _glfw.egl.GetConfigs = (PFN_eglGetConfigs)\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetConfigs\");\n    _glfw.egl.GetDisplay = (PFN_eglGetDisplay)\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetDisplay\");\n    _glfw.egl.GetError = (PFN_eglGetError)\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetError\");\n    _glfw.egl.Initialize = (PFN_eglInitialize)\n        _glfw_dlsym(_glfw.egl.handle, \"eglInitialize\");\n    _glfw.egl.Terminate = (PFN_eglTerminate)\n        _glfw_dlsym(_glfw.egl.handle, \"eglTerminate\");\n    _glfw.egl.BindAPI = (PFN_eglBindAPI)\n        _glfw_dlsym(_glfw.egl.handle, \"eglBindAPI\");\n    _glfw.egl.CreateContext = (PFN_eglCreateContext)\n        _glfw_dlsym(_glfw.egl.handle, \"eglCreateContext\");\n    _glfw.egl.DestroySurface = (PFN_eglDestroySurface)\n        _glfw_dlsym(_glfw.egl.handle, \"eglDestroySurface\");\n    _glfw.egl.DestroyContext = (PFN_eglDestroyContext)\n        _glfw_dlsym(_glfw.egl.handle, \"eglDestroyContext\");\n    _glfw.egl.CreateWindowSurface = (PFN_eglCreateWindowSurface)\n        _glfw_dlsym(_glfw.egl.handle, \"eglCreateWindowSurface\");\n    _glfw.egl.MakeCurrent = (PFN_eglMakeCurrent)\n        _glfw_dlsym(_glfw.egl.handle, \"eglMakeCurrent\");\n    _glfw.egl.SwapBuffers = (PFN_eglSwapBuffers)\n        _glfw_dlsym(_glfw.egl.handle, \"eglSwapBuffers\");\n    _glfw.egl.SwapInterval = (PFN_eglSwapInterval)\n        _glfw_dlsym(_glfw.egl.handle, \"eglSwapInterval\");\n    _glfw.egl.QueryString = (PFN_eglQueryString)\n        _glfw_dlsym(_glfw.egl.handle, \"eglQueryString\");\n    _glfw.egl.GetProcAddress = (PFN_eglGetProcAddress)\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetProcAddress\");\n\n    if (!_glfw.egl.GetConfigAttrib ||\n        !_glfw.egl.GetConfigs ||\n        !_glfw.egl.GetDisplay ||\n        !_glfw.egl.GetError ||\n        !_glfw.egl.Initialize ||\n        !_glfw.egl.Terminate ||\n        !_glfw.egl.BindAPI ||\n        !_glfw.egl.CreateContext ||\n        !_glfw.egl.DestroySurface ||\n        !_glfw.egl.DestroyContext ||\n        !_glfw.egl.CreateWindowSurface ||\n        !_glfw.egl.MakeCurrent ||\n        !_glfw.egl.SwapBuffers ||\n        !_glfw.egl.SwapInterval ||\n        !_glfw.egl.QueryString ||\n        !_glfw.egl.GetProcAddress)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"EGL: Failed to load required entry points\");\n\n        _glfwTerminateEGL();\n        return GLFW_FALSE;\n    }\n\n    _glfw.egl.display = eglGetDisplay(_GLFW_EGL_NATIVE_DISPLAY);\n    if (_glfw.egl.display == EGL_NO_DISPLAY)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"EGL: Failed to get EGL display: %s\",\n                        getEGLErrorString(eglGetError()));\n\n        _glfwTerminateEGL();\n        return GLFW_FALSE;\n    }\n\n    if (!eglInitialize(_glfw.egl.display, &_glfw.egl.major, &_glfw.egl.minor))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"EGL: Failed to initialize EGL: %s\",\n                        getEGLErrorString(eglGetError()));\n\n        _glfwTerminateEGL();\n        return GLFW_FALSE;\n    }\n\n    _glfw.egl.KHR_create_context =\n        extensionSupportedEGL(\"EGL_KHR_create_context\");\n    _glfw.egl.KHR_create_context_no_error =\n        extensionSupportedEGL(\"EGL_KHR_create_context_no_error\");\n    _glfw.egl.KHR_gl_colorspace =\n        extensionSupportedEGL(\"EGL_KHR_gl_colorspace\");\n    _glfw.egl.KHR_get_all_proc_addresses =\n        extensionSupportedEGL(\"EGL_KHR_get_all_proc_addresses\");\n    _glfw.egl.KHR_context_flush_control =\n        extensionSupportedEGL(\"EGL_KHR_context_flush_control\");\n\n    return GLFW_TRUE;\n}\n\n// Terminate EGL\n//\nvoid _glfwTerminateEGL(void)\n{\n    if (_glfw.egl.display)\n    {\n        eglTerminate(_glfw.egl.display);\n        _glfw.egl.display = EGL_NO_DISPLAY;\n    }\n\n    if (_glfw.egl.handle)\n    {\n        _glfw_dlclose(_glfw.egl.handle);\n        _glfw.egl.handle = NULL;\n    }\n}\n\n#define setAttrib(a, v) \\\n{ \\\n    assert((size_t) (index + 1) < sizeof(attribs) / sizeof(attribs[0])); \\\n    attribs[index++] = a; \\\n    attribs[index++] = v; \\\n}\n\n// Create the OpenGL or OpenGL ES context\n//\nGLFWbool _glfwCreateContextEGL(_GLFWwindow* window,\n                               const _GLFWctxconfig* ctxconfig,\n                               const _GLFWfbconfig* fbconfig)\n{\n    EGLint attribs[40];\n    EGLConfig config;\n    EGLContext share = NULL;\n    int index = 0;\n\n    if (!_glfw.egl.display)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"EGL: API not available\");\n        return GLFW_FALSE;\n    }\n\n    if (ctxconfig->share)\n        share = ctxconfig->share->context.egl.handle;\n\n    if (!chooseEGLConfig(ctxconfig, fbconfig, &config))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"EGL: Failed to find a suitable EGLConfig\");\n        return GLFW_FALSE;\n    }\n\n    if (ctxconfig->client == GLFW_OPENGL_ES_API)\n    {\n        if (!eglBindAPI(EGL_OPENGL_ES_API))\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"EGL: Failed to bind OpenGL ES: %s\",\n                            getEGLErrorString(eglGetError()));\n            return GLFW_FALSE;\n        }\n    }\n    else\n    {\n        if (!eglBindAPI(EGL_OPENGL_API))\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"EGL: Failed to bind OpenGL: %s\",\n                            getEGLErrorString(eglGetError()));\n            return GLFW_FALSE;\n        }\n    }\n\n    if (_glfw.egl.KHR_create_context)\n    {\n        int mask = 0, flags = 0;\n\n        if (ctxconfig->client == GLFW_OPENGL_API)\n        {\n            if (ctxconfig->forward)\n                flags |= EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR;\n\n            if (ctxconfig->profile == GLFW_OPENGL_CORE_PROFILE)\n                mask |= EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR;\n            else if (ctxconfig->profile == GLFW_OPENGL_COMPAT_PROFILE)\n                mask |= EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR;\n        }\n\n        if (ctxconfig->debug)\n            flags |= EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR;\n\n        if (ctxconfig->robustness)\n        {\n            if (ctxconfig->robustness == GLFW_NO_RESET_NOTIFICATION)\n            {\n                setAttrib(EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR,\n                          EGL_NO_RESET_NOTIFICATION_KHR);\n            }\n            else if (ctxconfig->robustness == GLFW_LOSE_CONTEXT_ON_RESET)\n            {\n                setAttrib(EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR,\n                          EGL_LOSE_CONTEXT_ON_RESET_KHR);\n            }\n\n            flags |= EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR;\n        }\n\n        if (ctxconfig->noerror)\n        {\n            if (_glfw.egl.KHR_create_context_no_error)\n                setAttrib(EGL_CONTEXT_OPENGL_NO_ERROR_KHR, GLFW_TRUE);\n        }\n\n        if (ctxconfig->major != 1 || ctxconfig->minor != 0)\n        {\n            setAttrib(EGL_CONTEXT_MAJOR_VERSION_KHR, ctxconfig->major);\n            setAttrib(EGL_CONTEXT_MINOR_VERSION_KHR, ctxconfig->minor);\n        }\n\n        if (mask)\n            setAttrib(EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR, mask);\n\n        if (flags)\n            setAttrib(EGL_CONTEXT_FLAGS_KHR, flags);\n    }\n    else\n    {\n        if (ctxconfig->client == GLFW_OPENGL_ES_API)\n            setAttrib(EGL_CONTEXT_CLIENT_VERSION, ctxconfig->major);\n    }\n\n    if (_glfw.egl.KHR_context_flush_control)\n    {\n        if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_NONE)\n        {\n            setAttrib(EGL_CONTEXT_RELEASE_BEHAVIOR_KHR,\n                      EGL_CONTEXT_RELEASE_BEHAVIOR_NONE_KHR);\n        }\n        else if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_FLUSH)\n        {\n            setAttrib(EGL_CONTEXT_RELEASE_BEHAVIOR_KHR,\n                      EGL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR);\n        }\n    }\n\n    setAttrib(EGL_NONE, EGL_NONE);\n\n    window->context.egl.handle = eglCreateContext(_glfw.egl.display,\n                                                  config, share, attribs);\n\n    if (window->context.egl.handle == EGL_NO_CONTEXT)\n    {\n        _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                        \"EGL: Failed to create context: %s\",\n                        getEGLErrorString(eglGetError()));\n        return GLFW_FALSE;\n    }\n\n    // Set up attributes for surface creation\n    {\n        int index = 0;\n\n        if (fbconfig->sRGB)\n        {\n            if (_glfw.egl.KHR_gl_colorspace)\n                setAttrib(EGL_GL_COLORSPACE_KHR, EGL_GL_COLORSPACE_SRGB_KHR);\n        }\n\n        setAttrib(EGL_NONE, EGL_NONE);\n    }\n\n    window->context.egl.surface =\n        eglCreateWindowSurface(_glfw.egl.display,\n                               config,\n                               _GLFW_EGL_NATIVE_WINDOW,\n                               attribs);\n    if (window->context.egl.surface == EGL_NO_SURFACE)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"EGL: Failed to create window surface: %s\",\n                        getEGLErrorString(eglGetError()));\n        return GLFW_FALSE;\n    }\n\n    window->context.egl.config = config;\n\n    // Load the appropriate client library\n    if (!_glfw.egl.KHR_get_all_proc_addresses)\n    {\n        int i;\n        const char** sonames;\n        const char* es1sonames[] =\n        {\n#if defined(_GLFW_GLESV1_LIBRARY)\n            _GLFW_GLESV1_LIBRARY,\n#elif defined(_GLFW_WIN32)\n            \"GLESv1_CM.dll\",\n            \"libGLES_CM.dll\",\n#elif defined(_GLFW_COCOA)\n            \"libGLESv1_CM.dylib\",\n#else\n            \"libGLESv1_CM.so.1\",\n            \"libGLES_CM.so.1\",\n#endif\n            NULL\n        };\n        const char* es2sonames[] =\n        {\n#if defined(_GLFW_GLESV2_LIBRARY)\n            _GLFW_GLESV2_LIBRARY,\n#elif defined(_GLFW_WIN32)\n            \"GLESv2.dll\",\n            \"libGLESv2.dll\",\n#elif defined(_GLFW_COCOA)\n            \"libGLESv2.dylib\",\n#elif defined(__CYGWIN__)\n            \"libGLESv2-2.so\",\n#else\n            \"libGLESv2.so.2\",\n#endif\n            NULL\n        };\n        const char* glsonames[] =\n        {\n#if defined(_GLFW_OPENGL_LIBRARY)\n            _GLFW_OPENGL_LIBRARY,\n#elif defined(_GLFW_WIN32)\n#elif defined(_GLFW_COCOA)\n#else\n            \"libGL.so.1\",\n#endif\n            NULL\n        };\n\n        if (ctxconfig->client == GLFW_OPENGL_ES_API)\n        {\n            if (ctxconfig->major == 1)\n                sonames = es1sonames;\n            else\n                sonames = es2sonames;\n        }\n        else\n            sonames = glsonames;\n\n        for (i = 0;  sonames[i];  i++)\n        {\n            // HACK: Match presence of lib prefix to increase chance of finding\n            //       a matching pair in the jungle that is Win32 EGL/GLES\n            if (_glfw.egl.prefix != (strncmp(sonames[i], \"lib\", 3) == 0))\n                continue;\n\n            window->context.egl.client = _glfw_dlopen(sonames[i]);\n            if (window->context.egl.client)\n                break;\n        }\n\n        if (!window->context.egl.client)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"EGL: Failed to load client library\");\n            return GLFW_FALSE;\n        }\n    }\n\n    window->context.makeCurrent = makeContextCurrentEGL;\n    window->context.swapBuffers = swapBuffersEGL;\n    window->context.swapInterval = swapIntervalEGL;\n    window->context.extensionSupported = extensionSupportedEGL;\n    window->context.getProcAddress = getProcAddressEGL;\n    window->context.destroy = destroyContextEGL;\n\n    return GLFW_TRUE;\n}\n\n#undef setAttrib\n\n// Returns the Visual and depth of the chosen EGLConfig\n//\n#if defined(_GLFW_X11)\nGLFWbool _glfwChooseVisualEGL(const _GLFWwndconfig* wndconfig,\n                              const _GLFWctxconfig* ctxconfig,\n                              const _GLFWfbconfig* fbconfig,\n                              Visual** visual, int* depth)\n{\n    XVisualInfo* result;\n    XVisualInfo desired;\n    EGLConfig native;\n    EGLint visualID = 0, count = 0;\n    const long vimask = VisualScreenMask | VisualIDMask;\n\n    if (!chooseEGLConfig(ctxconfig, fbconfig, &native))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"EGL: Failed to find a suitable EGLConfig\");\n        return GLFW_FALSE;\n    }\n\n    eglGetConfigAttrib(_glfw.egl.display, native,\n                       EGL_NATIVE_VISUAL_ID, &visualID);\n\n    desired.screen = _glfw.x11.screen;\n    desired.visualid = visualID;\n\n    result = XGetVisualInfo(_glfw.x11.display, vimask, &desired, &count);\n    if (!result)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"EGL: Failed to retrieve Visual for EGLConfig\");\n        return GLFW_FALSE;\n    }\n\n    *visual = result->visual;\n    *depth = result->depth;\n\n    XFree(result);\n    return GLFW_TRUE;\n}\n#endif // _GLFW_X11\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI EGLDisplay glfwGetEGLDisplay(void)\n{\n    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_DISPLAY);\n    return _glfw.egl.display;\n}\n\nGLFWAPI EGLContext glfwGetEGLContext(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_CONTEXT);\n\n    if (window->context.client == GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);\n        return EGL_NO_CONTEXT;\n    }\n\n    return window->context.egl.handle;\n}\n\nGLFWAPI EGLSurface glfwGetEGLSurface(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_SURFACE);\n\n    if (window->context.client == GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);\n        return EGL_NO_SURFACE;\n    }\n\n    return window->context.egl.surface;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/glfw/x11_platform.h": "//========================================================================\n// GLFW 3.3 X11 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2016 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include <unistd.h>\n#include <signal.h>\n#include <stdint.h>\n#include <dlfcn.h>\n#include <poll.h>\n\n#include <X11/Xlib.h>\n#include <X11/keysym.h>\n#include <X11/Xatom.h>\n#include <X11/Xcursor/Xcursor.h>\n\n// The xcb library is needed to work with libxkb\n#include <X11/Xlib-xcb.h>\n\n// The XRandR extension provides mode setting and gamma control\n#include <X11/extensions/Xrandr.h>\n\n// The Xkb extension provides improved keyboard support\n#include <X11/XKBlib.h>\n\n// The Xinerama extension provides legacy monitor indices\n#include <X11/extensions/Xinerama.h>\n\n// The XInput extension provides raw mouse motion input\n#include <X11/extensions/XInput2.h>\n\n// The libxkb library is used for improved keyboard support\n#include \"xkb_glfw.h\"\n\ntypedef XRRCrtcGamma* (* PFN_XRRAllocGamma)(int);\ntypedef void (* PFN_XRRFreeCrtcInfo)(XRRCrtcInfo*);\ntypedef void (* PFN_XRRFreeGamma)(XRRCrtcGamma*);\ntypedef void (* PFN_XRRFreeOutputInfo)(XRROutputInfo*);\ntypedef void (* PFN_XRRFreeScreenResources)(XRRScreenResources*);\ntypedef XRRCrtcGamma* (* PFN_XRRGetCrtcGamma)(Display*,RRCrtc);\ntypedef int (* PFN_XRRGetCrtcGammaSize)(Display*,RRCrtc);\ntypedef XRRCrtcInfo* (* PFN_XRRGetCrtcInfo) (Display*,XRRScreenResources*,RRCrtc);\ntypedef XRROutputInfo* (* PFN_XRRGetOutputInfo)(Display*,XRRScreenResources*,RROutput);\ntypedef RROutput (* PFN_XRRGetOutputPrimary)(Display*,Window);\ntypedef XRRScreenResources* (* PFN_XRRGetScreenResourcesCurrent)(Display*,Window);\ntypedef Bool (* PFN_XRRQueryExtension)(Display*,int*,int*);\ntypedef Status (* PFN_XRRQueryVersion)(Display*,int*,int*);\ntypedef void (* PFN_XRRSelectInput)(Display*,Window,int);\ntypedef Status (* PFN_XRRSetCrtcConfig)(Display*,XRRScreenResources*,RRCrtc,Time,int,int,RRMode,Rotation,RROutput*,int);\ntypedef void (* PFN_XRRSetCrtcGamma)(Display*,RRCrtc,XRRCrtcGamma*);\ntypedef int (* PFN_XRRUpdateConfiguration)(XEvent*);\n#define XRRAllocGamma _glfw.x11.randr.AllocGamma\n#define XRRFreeCrtcInfo _glfw.x11.randr.FreeCrtcInfo\n#define XRRFreeGamma _glfw.x11.randr.FreeGamma\n#define XRRFreeOutputInfo _glfw.x11.randr.FreeOutputInfo\n#define XRRFreeScreenResources _glfw.x11.randr.FreeScreenResources\n#define XRRGetCrtcGamma _glfw.x11.randr.GetCrtcGamma\n#define XRRGetCrtcGammaSize _glfw.x11.randr.GetCrtcGammaSize\n#define XRRGetCrtcInfo _glfw.x11.randr.GetCrtcInfo\n#define XRRGetOutputInfo _glfw.x11.randr.GetOutputInfo\n#define XRRGetOutputPrimary _glfw.x11.randr.GetOutputPrimary\n#define XRRGetScreenResourcesCurrent _glfw.x11.randr.GetScreenResourcesCurrent\n#define XRRQueryExtension _glfw.x11.randr.QueryExtension\n#define XRRQueryVersion _glfw.x11.randr.QueryVersion\n#define XRRSelectInput _glfw.x11.randr.SelectInput\n#define XRRSetCrtcConfig _glfw.x11.randr.SetCrtcConfig\n#define XRRSetCrtcGamma _glfw.x11.randr.SetCrtcGamma\n#define XRRUpdateConfiguration _glfw.x11.randr.UpdateConfiguration\n\ntypedef XcursorImage* (* PFN_XcursorImageCreate)(int,int);\ntypedef void (* PFN_XcursorImageDestroy)(XcursorImage*);\ntypedef Cursor (* PFN_XcursorImageLoadCursor)(Display*,const XcursorImage*);\n#define XcursorImageCreate _glfw.x11.xcursor.ImageCreate\n#define XcursorImageDestroy _glfw.x11.xcursor.ImageDestroy\n#define XcursorImageLoadCursor _glfw.x11.xcursor.ImageLoadCursor\n\ntypedef Bool (* PFN_XineramaIsActive)(Display*);\ntypedef Bool (* PFN_XineramaQueryExtension)(Display*,int*,int*);\ntypedef XineramaScreenInfo* (* PFN_XineramaQueryScreens)(Display*,int*);\n#define XineramaIsActive _glfw.x11.xinerama.IsActive\n#define XineramaQueryExtension _glfw.x11.xinerama.QueryExtension\n#define XineramaQueryScreens _glfw.x11.xinerama.QueryScreens\n\ntypedef struct xcb_connection_t xcb_connection_t;\n\ntypedef Bool (* PFN_XF86VidModeQueryExtension)(Display*,int*,int*);\ntypedef Bool (* PFN_XF86VidModeGetGammaRamp)(Display*,int,int,unsigned short*,unsigned short*,unsigned short*);\ntypedef Bool (* PFN_XF86VidModeSetGammaRamp)(Display*,int,int,unsigned short*,unsigned short*,unsigned short*);\ntypedef Bool (* PFN_XF86VidModeGetGammaRampSize)(Display*,int,int*);\n#define XF86VidModeQueryExtension _glfw.x11.vidmode.QueryExtension\n#define XF86VidModeGetGammaRamp _glfw.x11.vidmode.GetGammaRamp\n#define XF86VidModeSetGammaRamp _glfw.x11.vidmode.SetGammaRamp\n#define XF86VidModeGetGammaRampSize _glfw.x11.vidmode.GetGammaRampSize\n\ntypedef Status (* PFN_XIQueryVersion)(Display*,int*,int*);\ntypedef int (* PFN_XISelectEvents)(Display*,Window,XIEventMask*,int);\n#define XIQueryVersion _glfw.x11.xi.QueryVersion\n#define XISelectEvents _glfw.x11.xi.SelectEvents\n\ntypedef Bool (* PFN_XRenderQueryExtension)(Display*,int*,int*);\ntypedef Status (* PFN_XRenderQueryVersion)(Display*dpy,int*,int*);\ntypedef XRenderPictFormat* (* PFN_XRenderFindVisualFormat)(Display*,Visual const*);\n#define XRenderQueryExtension _glfw.x11.xrender.QueryExtension\n#define XRenderQueryVersion _glfw.x11.xrender.QueryVersion\n#define XRenderFindVisualFormat _glfw.x11.xrender.FindVisualFormat\n\ntypedef VkFlags VkXlibSurfaceCreateFlagsKHR;\ntypedef VkFlags VkXcbSurfaceCreateFlagsKHR;\n\ntypedef struct VkXlibSurfaceCreateInfoKHR\n{\n    VkStructureType             sType;\n    const void*                 pNext;\n    VkXlibSurfaceCreateFlagsKHR flags;\n    Display*                    dpy;\n    Window                      window;\n} VkXlibSurfaceCreateInfoKHR;\n\ntypedef struct VkXcbSurfaceCreateInfoKHR\n{\n    VkStructureType             sType;\n    const void*                 pNext;\n    VkXcbSurfaceCreateFlagsKHR  flags;\n    xcb_connection_t*           connection;\n    xcb_window_t                window;\n} VkXcbSurfaceCreateInfoKHR;\n\ntypedef VkResult (APIENTRY *PFN_vkCreateXlibSurfaceKHR)(VkInstance,const VkXlibSurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);\ntypedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice,uint32_t,Display*,VisualID);\ntypedef VkResult (APIENTRY *PFN_vkCreateXcbSurfaceKHR)(VkInstance,const VkXcbSurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);\ntypedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)(VkPhysicalDevice,uint32_t,xcb_connection_t*,xcb_visualid_t);\n\n#include \"posix_thread.h\"\n#include \"posix_time.h\"\n#include \"glx_context.h\"\n#include \"egl_context.h\"\n#include \"osmesa_context.h\"\n#if defined(__linux__)\n#include \"linux_joystick.h\"\n#else\n#include \"null_joystick.h\"\n#endif\n\n#define _glfw_dlopen(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL)\n#define _glfw_dlclose(handle) dlclose(handle)\n#define _glfw_dlsym(handle, name) dlsym(handle, name)\n\n#define _GLFW_EGL_NATIVE_WINDOW  ((EGLNativeWindowType) window->x11.handle)\n#define _GLFW_EGL_NATIVE_DISPLAY ((EGLNativeDisplayType) _glfw.x11.display)\n\n#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowX11  x11\n#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryX11 x11\n#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorX11 x11\n#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorX11  x11\n\n\n// X11-specific per-window data\n//\ntypedef struct _GLFWwindowX11\n{\n    Colormap        colormap;\n    Window          handle;\n\n    GLFWbool        overrideRedirect;\n    GLFWbool        iconified;\n    GLFWbool        maximized;\n\n    // Whether the visual supports framebuffer transparency\n    GLFWbool        transparent;\n\n    // Cached position and size used to filter out duplicate events\n    int             width, height;\n    int             xpos, ypos;\n\n    // The last received cursor position, regardless of source\n    int             lastCursorPosX, lastCursorPosY;\n    // The last position the cursor was warped to by GLFW\n    int             warpCursorPosX, warpCursorPosY;\n\n    // The time of the last KeyPress event\n    Time            lastKeyTime;\n\n} _GLFWwindowX11;\n\n// X11-specific global data\n//\ntypedef struct _GLFWlibraryX11\n{\n    Display*        display;\n    int             screen;\n    Window          root;\n\n    // System content scale\n    float           contentScaleX, contentScaleY;\n    // Helper window for IPC\n    Window          helperWindowHandle;\n    // Invisible cursor for hidden cursor mode\n    Cursor          hiddenCursorHandle;\n    // Context for mapping window XIDs to _GLFWwindow pointers\n    XContext        context;\n    // Most recent error code received by X error handler\n    int             errorCode;\n    // Primary selection string (while the primary selection is owned)\n    char*           primarySelectionString;\n    // Clipboard string (while the selection is owned)\n    char*           clipboardString;\n    // Where to place the cursor when re-enabled\n    double          restoreCursorPosX, restoreCursorPosY;\n    // The window whose disabled cursor mode is active\n    _GLFWwindow*    disabledCursorWindow;\n\n    // Window manager atoms\n    Atom            WM_PROTOCOLS;\n    Atom            WM_STATE;\n    Atom            WM_DELETE_WINDOW;\n    Atom            NET_WM_NAME;\n    Atom            NET_WM_ICON_NAME;\n    Atom            NET_WM_ICON;\n    Atom            NET_WM_PID;\n    Atom            NET_WM_PING;\n    Atom            NET_WM_WINDOW_TYPE;\n    Atom            NET_WM_WINDOW_TYPE_NORMAL;\n    Atom            NET_WM_STATE;\n    Atom            NET_WM_STATE_ABOVE;\n    Atom            NET_WM_STATE_FULLSCREEN;\n    Atom            NET_WM_STATE_MAXIMIZED_VERT;\n    Atom            NET_WM_STATE_MAXIMIZED_HORZ;\n    Atom            NET_WM_STATE_DEMANDS_ATTENTION;\n    Atom            NET_WM_BYPASS_COMPOSITOR;\n    Atom            NET_WM_FULLSCREEN_MONITORS;\n    Atom            NET_WM_WINDOW_OPACITY;\n    Atom            NET_WM_CM_Sx;\n    Atom            NET_ACTIVE_WINDOW;\n    Atom            NET_FRAME_EXTENTS;\n    Atom            NET_REQUEST_FRAME_EXTENTS;\n    Atom            MOTIF_WM_HINTS;\n\n    // Xdnd (drag and drop) atoms\n    Atom            XdndAware;\n    Atom            XdndEnter;\n    Atom            XdndPosition;\n    Atom            XdndStatus;\n    Atom            XdndActionCopy;\n    Atom            XdndDrop;\n    Atom            XdndFinished;\n    Atom            XdndSelection;\n    Atom            XdndTypeList;\n    Atom            text_uri_list;\n\n    // Selection (clipboard) atoms\n    Atom            TARGETS;\n    Atom            MULTIPLE;\n    Atom            INCR;\n    Atom            CLIPBOARD;\n    Atom            PRIMARY;\n    Atom            CLIPBOARD_MANAGER;\n    Atom            SAVE_TARGETS;\n    Atom            NULL_;\n    Atom            UTF8_STRING;\n    Atom            COMPOUND_STRING;\n    Atom            ATOM_PAIR;\n    Atom            GLFW_SELECTION;\n\n    // XRM database atom\n    Atom            RESOURCE_MANAGER;\n\n    struct {\n        GLFWbool    available;\n        void*       handle;\n        int         eventBase;\n        int         errorBase;\n        int         major;\n        int         minor;\n        GLFWbool    gammaBroken;\n        GLFWbool    monitorBroken;\n        PFN_XRRAllocGamma AllocGamma;\n        PFN_XRRFreeCrtcInfo FreeCrtcInfo;\n        PFN_XRRFreeGamma FreeGamma;\n        PFN_XRRFreeOutputInfo FreeOutputInfo;\n        PFN_XRRFreeScreenResources FreeScreenResources;\n        PFN_XRRGetCrtcGamma GetCrtcGamma;\n        PFN_XRRGetCrtcGammaSize GetCrtcGammaSize;\n        PFN_XRRGetCrtcInfo GetCrtcInfo;\n        PFN_XRRGetOutputInfo GetOutputInfo;\n        PFN_XRRGetOutputPrimary GetOutputPrimary;\n        PFN_XRRGetScreenResourcesCurrent GetScreenResourcesCurrent;\n        PFN_XRRQueryExtension QueryExtension;\n        PFN_XRRQueryVersion QueryVersion;\n        PFN_XRRSelectInput SelectInput;\n        PFN_XRRSetCrtcConfig SetCrtcConfig;\n        PFN_XRRSetCrtcGamma SetCrtcGamma;\n        PFN_XRRUpdateConfiguration UpdateConfiguration;\n    } randr;\n\n    _GLFWXKBData xkb;\n\n    struct {\n        int         count;\n        int         timeout;\n        int         interval;\n        int         blanking;\n        int         exposure;\n    } saver;\n\n    struct {\n        int         version;\n        Window      source;\n        Atom        format;\n    } xdnd;\n\n    struct {\n        void*       handle;\n        PFN_XcursorImageCreate ImageCreate;\n        PFN_XcursorImageDestroy ImageDestroy;\n        PFN_XcursorImageLoadCursor ImageLoadCursor;\n    } xcursor;\n\n    struct {\n        GLFWbool    available;\n        void*       handle;\n        int         major;\n        int         minor;\n        PFN_XineramaIsActive IsActive;\n        PFN_XineramaQueryExtension QueryExtension;\n        PFN_XineramaQueryScreens QueryScreens;\n    } xinerama;\n\n    struct {\n        GLFWbool    available;\n        void*       handle;\n        int         eventBase;\n        int         errorBase;\n        PFN_XF86VidModeQueryExtension QueryExtension;\n        PFN_XF86VidModeGetGammaRamp GetGammaRamp;\n        PFN_XF86VidModeSetGammaRamp SetGammaRamp;\n        PFN_XF86VidModeGetGammaRampSize GetGammaRampSize;\n    } vidmode;\n\n    struct {\n        GLFWbool    available;\n        void*       handle;\n        int         majorOpcode;\n        int         eventBase;\n        int         errorBase;\n        int         major;\n        int         minor;\n        PFN_XIQueryVersion QueryVersion;\n        PFN_XISelectEvents SelectEvents;\n    } xi;\n\n    struct {\n        GLFWbool    available;\n        void*       handle;\n        int         major;\n        int         minor;\n        int         eventBase;\n        int         errorBase;\n        PFN_XRenderQueryExtension QueryExtension;\n        PFN_XRenderQueryVersion QueryVersion;\n        PFN_XRenderFindVisualFormat FindVisualFormat;\n    } xrender;\n\n    struct {\n        struct pollfd fds[3];\n        int wakeupFds[2];\n    } eventLoopData;\n\n} _GLFWlibraryX11;\n\n// X11-specific per-monitor data\n//\ntypedef struct _GLFWmonitorX11\n{\n    RROutput        output;\n    RRCrtc          crtc;\n    RRMode          oldMode;\n\n    // Index of corresponding Xinerama screen,\n    // for EWMH full screen window placement\n    int             index;\n\n} _GLFWmonitorX11;\n\n// X11-specific per-cursor data\n//\ntypedef struct _GLFWcursorX11\n{\n    Cursor handle;\n\n} _GLFWcursorX11;\n\nvoid _glfwPollMonitorsX11(void);\nvoid _glfwSetVideoModeX11(_GLFWmonitor* monitor, const GLFWvidmode* desired);\nvoid _glfwRestoreVideoModeX11(_GLFWmonitor* monitor);\n\nCursor _glfwCreateCursorX11(const GLFWimage* image, int xhot, int yhot);\n\nunsigned long _glfwGetWindowPropertyX11(Window window,\n                                        Atom property,\n                                        Atom type,\n                                        unsigned char** value);\nGLFWbool _glfwIsVisualTransparentX11(Visual* visual);\n\nvoid _glfwGrabErrorHandlerX11(void);\nvoid _glfwReleaseErrorHandlerX11(void);\nvoid _glfwInputErrorX11(int error, const char* message);\n\nvoid _glfwGetSystemContentScaleX11(float* xscale, float* yscale, GLFWbool bypass_cache);\nvoid _glfwPushSelectionToManagerX11(void);\n",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/glfw/null_platform.h": "//========================================================================\n// GLFW 3.3 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2016 Google Inc.\n// Copyright (c) 2006-2016 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include <dlfcn.h>\n\n#define _GLFW_PLATFORM_WINDOW_STATE _GLFWwindowNull null\n\n#define _GLFW_PLATFORM_CONTEXT_STATE\n#define _GLFW_PLATFORM_MONITOR_STATE\n#define _GLFW_PLATFORM_CURSOR_STATE\n#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE\n#define _GLFW_EGL_CONTEXT_STATE\n#define _GLFW_EGL_LIBRARY_CONTEXT_STATE\n\n#include \"osmesa_context.h\"\n#include \"posix_time.h\"\n#include \"posix_thread.h\"\n#include \"null_joystick.h\"\n\n#if defined(_GLFW_WIN32)\n #define _glfw_dlopen(name) LoadLibraryA(name)\n #define _glfw_dlclose(handle) FreeLibrary((HMODULE) handle)\n #define _glfw_dlsym(handle, name) GetProcAddress((HMODULE) handle, name)\n#else\n #define _glfw_dlopen(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL)\n #define _glfw_dlclose(handle) dlclose(handle)\n #define _glfw_dlsym(handle, name) dlsym(handle, name)\n#endif\n\n// Null-specific per-window data\n//\ntypedef struct _GLFWwindowNull\n{\n    int width;\n    int height;\n} _GLFWwindowNull;\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/glfw/vulkan.c": "//========================================================================\n// GLFW 3.3 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2016 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define _GLFW_FIND_LOADER    1\n#define _GLFW_REQUIRE_LOADER 2\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWbool _glfwInitVulkan(int mode)\n{\n    VkResult err;\n    VkExtensionProperties* ep;\n    uint32_t i, count;\n\n    if (_glfw.vk.available)\n        return GLFW_TRUE;\n\n#if !defined(_GLFW_VULKAN_STATIC)\n#if defined(_GLFW_VULKAN_LIBRARY)\n    _glfw.vk.handle = _glfw_dlopen(_GLFW_VULKAN_LIBRARY);\n#elif defined(_GLFW_WIN32)\n    _glfw.vk.handle = _glfw_dlopen(\"vulkan-1.dll\");\n#elif defined(_GLFW_COCOA)\n    _glfw.vk.handle = _glfw_dlopen(\"libvulkan.1.dylib\");\n#else\n    _glfw.vk.handle = _glfw_dlopen(\"libvulkan.so.1\");\n#endif\n    if (!_glfw.vk.handle)\n    {\n        if (mode == _GLFW_REQUIRE_LOADER)\n            _glfwInputError(GLFW_API_UNAVAILABLE, \"Vulkan: Loader not found\");\n\n        return GLFW_FALSE;\n    }\n\n    _glfw.vk.GetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)\n        _glfw_dlsym(_glfw.vk.handle, \"vkGetInstanceProcAddr\");\n    if (!_glfw.vk.GetInstanceProcAddr)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"Vulkan: Loader does not export vkGetInstanceProcAddr\");\n\n        _glfwTerminateVulkan();\n        return GLFW_FALSE;\n    }\n\n    _glfw.vk.EnumerateInstanceExtensionProperties = (PFN_vkEnumerateInstanceExtensionProperties)\n        vkGetInstanceProcAddr(NULL, \"vkEnumerateInstanceExtensionProperties\");\n    if (!_glfw.vk.EnumerateInstanceExtensionProperties)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"Vulkan: Failed to retrieve vkEnumerateInstanceExtensionProperties\");\n\n        _glfwTerminateVulkan();\n        return GLFW_FALSE;\n    }\n#endif // _GLFW_VULKAN_STATIC\n\n    err = vkEnumerateInstanceExtensionProperties(NULL, &count, NULL);\n    if (err)\n    {\n        // NOTE: This happens on systems with a loader but without any Vulkan ICD\n        if (mode == _GLFW_REQUIRE_LOADER)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"Vulkan: Failed to query instance extension count: %s\",\n                            _glfwGetVulkanResultString(err));\n        }\n\n        _glfwTerminateVulkan();\n        return GLFW_FALSE;\n    }\n\n    ep = calloc(count, sizeof(VkExtensionProperties));\n\n    err = vkEnumerateInstanceExtensionProperties(NULL, &count, ep);\n    if (err)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"Vulkan: Failed to query instance extensions: %s\",\n                        _glfwGetVulkanResultString(err));\n\n        free(ep);\n        _glfwTerminateVulkan();\n        return GLFW_FALSE;\n    }\n\n    for (i = 0;  i < count;  i++)\n    {\n        if (strcmp(ep[i].extensionName, \"VK_KHR_surface\") == 0)\n            _glfw.vk.KHR_surface = GLFW_TRUE;\n#if defined(_GLFW_WIN32)\n        else if (strcmp(ep[i].extensionName, \"VK_KHR_win32_surface\") == 0)\n            _glfw.vk.KHR_win32_surface = GLFW_TRUE;\n#elif defined(_GLFW_COCOA)\n        else if (strcmp(ep[i].extensionName, \"VK_MVK_macos_surface\") == 0)\n            _glfw.vk.MVK_macos_surface = GLFW_TRUE;\n#elif defined(_GLFW_X11)\n        else if (strcmp(ep[i].extensionName, \"VK_KHR_xlib_surface\") == 0)\n            _glfw.vk.KHR_xlib_surface = GLFW_TRUE;\n        else if (strcmp(ep[i].extensionName, \"VK_KHR_xcb_surface\") == 0)\n            _glfw.vk.KHR_xcb_surface = GLFW_TRUE;\n#elif defined(_GLFW_WAYLAND)\n        else if (strcmp(ep[i].extensionName, \"VK_KHR_wayland_surface\") == 0)\n            _glfw.vk.KHR_wayland_surface = GLFW_TRUE;\n#elif defined(_GLFW_MIR)\n        else if (strcmp(ep[i].extensionName, \"VK_KHR_mir_surface\") == 0)\n            _glfw.vk.KHR_mir_surface = GLFW_TRUE;\n#endif\n    }\n\n    free(ep);\n\n    _glfw.vk.available = GLFW_TRUE;\n\n    _glfwPlatformGetRequiredInstanceExtensions(_glfw.vk.extensions);\n\n    return GLFW_TRUE;\n}\n\nvoid _glfwTerminateVulkan(void)\n{\n#if !defined(_GLFW_VULKAN_STATIC)\n    if (_glfw.vk.handle)\n        _glfw_dlclose(_glfw.vk.handle);\n#endif\n}\n\nconst char* _glfwGetVulkanResultString(VkResult result)\n{\n    switch (result)\n    {\n        case VK_SUCCESS:\n            return \"Success\";\n        case VK_NOT_READY:\n            return \"A fence or query has not yet completed\";\n        case VK_TIMEOUT:\n            return \"A wait operation has not completed in the specified time\";\n        case VK_EVENT_SET:\n            return \"An event is signaled\";\n        case VK_EVENT_RESET:\n            return \"An event is unsignaled\";\n        case VK_INCOMPLETE:\n            return \"A return array was too small for the result\";\n        case VK_ERROR_OUT_OF_HOST_MEMORY:\n            return \"A host memory allocation has failed\";\n        case VK_ERROR_OUT_OF_DEVICE_MEMORY:\n            return \"A device memory allocation has failed\";\n        case VK_ERROR_INITIALIZATION_FAILED:\n            return \"Initialization of an object could not be completed for implementation-specific reasons\";\n        case VK_ERROR_DEVICE_LOST:\n            return \"The logical or physical device has been lost\";\n        case VK_ERROR_MEMORY_MAP_FAILED:\n            return \"Mapping of a memory object has failed\";\n        case VK_ERROR_LAYER_NOT_PRESENT:\n            return \"A requested layer is not present or could not be loaded\";\n        case VK_ERROR_EXTENSION_NOT_PRESENT:\n            return \"A requested extension is not supported\";\n        case VK_ERROR_FEATURE_NOT_PRESENT:\n            return \"A requested feature is not supported\";\n        case VK_ERROR_INCOMPATIBLE_DRIVER:\n            return \"The requested version of Vulkan is not supported by the driver or is otherwise incompatible\";\n        case VK_ERROR_TOO_MANY_OBJECTS:\n            return \"Too many objects of the type have already been created\";\n        case VK_ERROR_FORMAT_NOT_SUPPORTED:\n            return \"A requested format is not supported on this device\";\n        case VK_ERROR_SURFACE_LOST_KHR:\n            return \"A surface is no longer available\";\n        case VK_SUBOPTIMAL_KHR:\n            return \"A swapchain no longer matches the surface properties exactly, but can still be used\";\n        case VK_ERROR_OUT_OF_DATE_KHR:\n            return \"A surface has changed in such a way that it is no longer compatible with the swapchain\";\n        case VK_ERROR_INCOMPATIBLE_DISPLAY_KHR:\n            return \"The display used by a swapchain does not use the same presentable image layout\";\n        case VK_ERROR_NATIVE_WINDOW_IN_USE_KHR:\n            return \"The requested window is already connected to a VkSurfaceKHR, or to some other non-Vulkan API\";\n        case VK_ERROR_VALIDATION_FAILED_EXT:\n            return \"A validation layer found an error\";\n        default:\n            return \"ERROR: UNKNOWN VULKAN ERROR\";\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW public API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI int glfwVulkanSupported(void)\n{\n    _GLFW_REQUIRE_INIT_OR_RETURN(GLFW_FALSE);\n    return _glfwInitVulkan(_GLFW_FIND_LOADER);\n}\n\nGLFWAPI const char** glfwGetRequiredInstanceExtensions(uint32_t* count)\n{\n    assert(count != NULL);\n\n    *count = 0;\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n\n    if (!_glfwInitVulkan(_GLFW_REQUIRE_LOADER))\n        return NULL;\n\n    if (!_glfw.vk.extensions[0])\n        return NULL;\n\n    *count = 2;\n    return (const char**) _glfw.vk.extensions;\n}\n\nGLFWAPI GLFWvkproc glfwGetInstanceProcAddress(VkInstance instance,\n                                              const char* procname)\n{\n    GLFWvkproc proc;\n    assert(procname != NULL);\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n\n    if (!_glfwInitVulkan(_GLFW_REQUIRE_LOADER))\n        return NULL;\n\n    proc = (GLFWvkproc) vkGetInstanceProcAddr(instance, procname);\n#if defined(_GLFW_VULKAN_STATIC)\n    if (!proc)\n    {\n        if (strcmp(procname, \"vkGetInstanceProcAddr\") == 0)\n            return (GLFWvkproc) vkGetInstanceProcAddr;\n    }\n#else\n    if (!proc)\n        proc = (GLFWvkproc) _glfw_dlsym(_glfw.vk.handle, procname);\n#endif\n\n    return proc;\n}\n\nGLFWAPI int glfwGetPhysicalDevicePresentationSupport(VkInstance instance,\n                                                     VkPhysicalDevice device,\n                                                     uint32_t queuefamily)\n{\n    assert(instance != VK_NULL_HANDLE);\n    assert(device != VK_NULL_HANDLE);\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(GLFW_FALSE);\n\n    if (!_glfwInitVulkan(_GLFW_REQUIRE_LOADER))\n        return GLFW_FALSE;\n\n    if (!_glfw.vk.extensions[0])\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"Vulkan: Window surface creation extensions not found\");\n        return GLFW_FALSE;\n    }\n\n    return _glfwPlatformGetPhysicalDevicePresentationSupport(instance,\n                                                             device,\n                                                             queuefamily);\n}\n\nGLFWAPI VkResult glfwCreateWindowSurface(VkInstance instance,\n                                         GLFWwindow* handle,\n                                         const VkAllocationCallbacks* allocator,\n                                         VkSurfaceKHR* surface)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    assert(instance != VK_NULL_HANDLE);\n    assert(window != NULL);\n    assert(surface != NULL);\n\n    *surface = VK_NULL_HANDLE;\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(VK_ERROR_INITIALIZATION_FAILED);\n\n    if (!_glfwInitVulkan(_GLFW_REQUIRE_LOADER))\n        return VK_ERROR_INITIALIZATION_FAILED;\n\n    if (!_glfw.vk.extensions[0])\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"Vulkan: Window surface creation extensions not found\");\n        return VK_ERROR_EXTENSION_NOT_PRESENT;\n    }\n\n    if (window->context.client != GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_INVALID_VALUE,\n                        \"Vulkan: Window surface creation requires the window to have the client API set to GLFW_NO_API\");\n        return VK_ERROR_NATIVE_WINDOW_IN_USE_KHR;\n    }\n\n    return _glfwPlatformCreateWindowSurface(instance, window, allocator, surface);\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/glfw/glfw.py": "#!/usr/bin/env python\n# vim:fileencoding=utf-8\n# License: GPL v3 Copyright: 2017, Kovid Goyal <kovid at kovidgoyal.net>\n\nimport json\nimport os\nimport re\nimport shutil\nimport sys\n\n_plat = sys.platform.lower()\nis_macos = 'darwin' in _plat\nis_freebsd = 'freebsd' in _plat\nis_netbsd = 'netbsd' in _plat\nis_dragonflybsd = 'dragonfly' in _plat\nis_bsd = is_freebsd or is_netbsd or is_dragonflybsd\nbase = os.path.dirname(os.path.abspath(__file__))\n\n\ndef wayland_protocol_file_name(base, ext='c'):\n    base = os.path.basename(base).rpartition('.')[0]\n    return 'wayland-{}-client-protocol.{}'.format(base, ext)\n\n\ndef init_env(env, pkg_config, at_least_version, module='x11'):\n    ans = env.copy()\n    ans.cflags = [\n        x for x in ans.cflags\n        if x not in '-Wpedantic -Wextra -pedantic-errors'.split()\n    ]\n    if not is_macos:\n        ans.cflags.append('-pthread')\n        ans.ldpaths.append('-pthread')\n    ans.cflags.append('-fpic')\n    ans.cflags.append('-D_GLFW_' + module.upper())\n    ans.cflags.append('-D_GLFW_BUILD_DLL')\n\n    if is_macos:\n        ans.ldpaths.extend(\n            \"-framework Cocoa -framework IOKit -framework CoreFoundation -framework CoreVideo\".\n            split()\n        )\n    else:\n        ans.ldpaths.extend('-lrt -lm -ldl'.split())\n    sinfo = json.load(open(os.path.join(base, 'source-info.json')))\n    module_sources = list(sinfo[module]['sources'])\n    if module in ('x11', 'wayland'):\n        remove = 'linux_joystick.c' if is_bsd else 'null_joystick.c'\n        module_sources.remove(remove)\n\n    ans.sources = sinfo['common']['sources'] + module_sources\n    ans.all_headers = [x for x in os.listdir(base) if x.endswith('.h')]\n\n    if module in ('x11', 'wayland'):\n        at_least_version('xkbcommon', 0, 5)\n\n    if module == 'x11':\n        for dep in 'x11 xrandr xinerama xcursor xkbcommon xkbcommon-x11 x11-xcb'.split():\n            ans.cflags.extend(pkg_config(dep, '--cflags-only-I'))\n            ans.ldpaths.extend(pkg_config(dep, '--libs'))\n\n    elif module == 'cocoa':\n        for f in 'Cocoa IOKit CoreFoundation CoreVideo'.split():\n            ans.ldpaths.extend(('-framework', f))\n\n    elif module == 'wayland':\n        at_least_version('wayland-protocols', *sinfo['wayland_protocols'])\n        ans.wayland_packagedir = os.path.abspath(pkg_config('wayland-protocols', '--variable=pkgdatadir')[0])\n        ans.wayland_scanner = os.path.abspath(pkg_config('wayland-scanner', '--variable=wayland_scanner')[0])\n        ans.wayland_protocols = tuple(sinfo[module]['protocols'])\n        for p in ans.wayland_protocols:\n            ans.sources.append(wayland_protocol_file_name(p))\n            ans.all_headers.append(wayland_protocol_file_name(p, 'h'))\n        for dep in 'wayland-egl wayland-client wayland-cursor xkbcommon'.split():\n            ans.cflags.extend(pkg_config(dep, '--cflags-only-I'))\n            ans.ldpaths.extend(pkg_config(dep, '--libs'))\n\n    return ans\n\n\ndef build_wayland_protocols(env, run_tool, emphasis, newer, dest_dir):\n    for protocol in env.wayland_protocols:\n        src = os.path.join(env.wayland_packagedir, protocol)\n        if not os.path.exists(src):\n            raise SystemExit('The wayland-protocols package on your system is missing the {} protocol definition file'.format(protocol))\n        for ext in 'hc':\n            dest = wayland_protocol_file_name(src, ext)\n            dest = os.path.join(dest_dir, dest)\n            if newer(dest, src):\n                q = 'client-header' if ext == 'h' else 'code'\n                run_tool([env.wayland_scanner, q, src, dest],\n                         desc='Generating {} ...'.format(emphasis(os.path.basename(dest))))\n\n\ndef collect_source_information():\n    raw = open('src/CMakeLists.txt').read()\n    mraw = open('CMakeLists.txt').read()\n\n    def extract_sources(group, start_pos=0):\n        for which in 'HEADERS SOURCES'.split():\n            yield which.lower(), list(filter(\n                lambda x: x[0] not in '\"$',\n                re.search(\n                    r'{0}_{1}\\s+([^)]+?)[)]'.format(group, which),\n                    raw[start_pos:]\n                ).group(1).strip().split()\n            ))\n\n    wayland_protocols = re.search(r'WaylandProtocols\\s+(\\S+)\\s+', mraw).group(1)\n    wayland_protocols = list(map(int, wayland_protocols.split('.')))\n    ans = {\n        'common': dict(extract_sources('common')),\n        'wayland_protocols': wayland_protocols,\n    }\n    for group in 'cocoa win32 x11 wayland osmesa'.split():\n        m = re.search('_GLFW_' + group.upper(), raw)\n        ans[group] = dict(extract_sources('glfw', m.start()))\n        if group in ('x11', 'wayland'):\n            for joystick in ('linux', 'null'):\n                ans[group]['headers'].append('{}_joystick.h'.format(joystick))\n                ans[group]['sources'].append('{}_joystick.c'.format(joystick))\n        if group == 'wayland':\n            ans[group]['protocols'] = p = []\n            for m in re.finditer(r'WAYLAND_PROTOCOLS_PKGDATADIR\\}/(.+?)\"?$', raw, flags=re.M):\n                p.append(m.group(1))\n    return ans\n\n\ndef patch_in_file(path, pfunc):\n    with open(path, 'r+') as f:\n        raw = f.read()\n        nraw = pfunc(raw)\n        if raw == nraw:\n            raise SystemExit('Patching of {} failed'.format(path))\n        f.seek(0), f.truncate()\n        f.write(nraw)\n\n\nclass Arg:\n\n    def __init__(self, decl):\n        self.type, self.name = decl.rsplit(' ', 1)\n        self.type = self.type.strip()\n        self.name = self.name.strip()\n        while self.name.startswith('*'):\n            self.name = self.name[1:]\n            self.type = self.type + '*'\n\n    def __repr__(self):\n        return 'Arg({}, {})'.format(self.type, self.name)\n\n\nclass Function:\n\n    def __init__(self, declaration, check_fail=True):\n        self.check_fail = check_fail\n        m = re.match(\n            r'(.+?)\\s+(glfw[A-Z][a-zA-Z0-9]+)[(](.+)[)]$', declaration\n        )\n        if m is None:\n            raise SystemExit('Failed to parse ' + repr(declaration))\n        self.restype = m.group(1).strip()\n        self.name = m.group(2)\n        args = m.group(3).strip().split(',')\n        args = [x.strip() for x in args]\n        self.args = []\n        for a in args:\n            if a == 'void':\n                continue\n            self.args.append(Arg(a))\n\n    def declaration(self):\n        return 'typedef {restype} (*{name}_func)({args});\\n{name}_func {name}_impl;\\n#define {name} {name}_impl'.format(\n            restype=self.restype,\n            name=self.name,\n            args=', '.join(a.type for a in self.args)\n        )\n\n    def load(self):\n        ans = '*(void **) (&{name}_impl) = dlsym(handle, \"{name}\");'.format(\n            name=self.name\n        )\n        if self.check_fail:\n            ans += '\\n    if ({name}_impl == NULL) fail(\"Failed to load glfw function {name} with error: %s\", dlerror());'.format(\n                name=self.name\n            )\n        return ans\n\n\ndef generate_wrappers(glfw_header, glfw_native_header):\n    src = open(glfw_header).read()\n    functions = []\n    first = None\n    for m in re.finditer(r'^GLFWAPI\\s+(.+[)]);\\s*$', src, flags=re.MULTILINE):\n        if first is None:\n            first = m.start()\n        decl = m.group(1)\n        if 'VkInstance' in decl:\n            continue\n        functions.append(Function(decl))\n    for line in '''\\\n    void* glfwGetCocoaWindow(GLFWwindow* window)\n    uint32_t glfwGetCocoaMonitor(GLFWmonitor* monitor)\n    GLFWcocoatextinputfilterfun glfwSetCocoaTextInputFilter(GLFWwindow* window, GLFWcocoatextinputfilterfun callback)\n    GLFWapplicationshouldhandlereopenfun glfwSetApplicationShouldHandleReopen(GLFWapplicationshouldhandlereopenfun callback)\n    void glfwGetCocoaKeyEquivalent(int glfw_key, int glfw_mods, void* cocoa_key, void* cocoa_mods)\n    void* glfwGetX11Display(void)\n    int32_t glfwGetX11Window(GLFWwindow* window)\n    void glfwSetX11SelectionString(const char* string)\n    const char* glfwGetX11SelectionString(void)\n'''.splitlines():\n        if line:\n            functions.append(Function(line.strip(), check_fail=False))\n\n    declarations = [f.declaration() for f in functions]\n    p = src.find(' * GLFW API tokens')\n    p = src.find('*/', p)\n    preamble = src[p + 2:first]\n    header = '''\\\n#pragma once\n#include <stddef.h>\n#include <stdint.h>\ntypedef int (* GLFWcocoatextinputfilterfun)(int,int,unsigned int);\ntypedef int (* GLFWapplicationshouldhandlereopenfun)(int);\n\n{}\n\n{}\n\nconst char* load_glfw(const char* path);\n'''.format(preamble, '\\n\\n'.join(declarations))\n    with open('../kitty/glfw-wrapper.h', 'w') as f:\n        f.write(header)\n\n    code = '''\n#include \"data-types.h\"\n#include \"glfw-wrapper.h\"\n#include <dlfcn.h>\n\nstatic void* handle = NULL;\n\n#define fail(msg, ...) { snprintf(buf, sizeof(buf), msg, __VA_ARGS__); return buf; }\n\nconst char*\nload_glfw(const char* path) {\n    static char buf[2048];\n    handle = dlopen(path, RTLD_LAZY);\n    if (handle == NULL) fail(\"Failed to dlopen %s with error: %s\", path, dlerror());\n    dlerror();\n\n    LOAD\n\n    return NULL;\n}\n\nvoid\nunload_glfw() {\n    if (handle) { dlclose(handle); handle = NULL; }\n}\n'''.replace('LOAD', '\\n\\n    '.join(f.load() for f in functions))\n    with open('../kitty/glfw-wrapper.c', 'w') as f:\n        f.write(code)\n\n\ndef main():\n    os.chdir(sys.argv[-1])\n    sinfo = collect_source_information()\n    files_to_copy = set()\n    for x in sinfo.values():\n        if isinstance(x, dict):\n            headers, sources = x['headers'], x['sources']\n            for name in headers + sources:\n                files_to_copy.add(os.path.abspath(os.path.join('src', name)))\n    glfw_header = os.path.abspath('include/GLFW/glfw3.h')\n    glfw_native_header = os.path.abspath('include/GLFW/glfw3native.h')\n    os.chdir(base)\n    for x in os.listdir('.'):\n        if x.rpartition('.') in ('c', 'h'):\n            os.unlink(x)\n    for src in files_to_copy:\n        shutil.copy2(src, '.')\n    shutil.copy2(glfw_header, '.')\n    patch_in_file('internal.h', lambda x: x.replace('../include/GLFW/', ''))\n    patch_in_file('cocoa_window.m', lambda x: re.sub(\n        r'[(]void[)]loadMainMenu.+?}', '(void)loadMainMenu\\n{ // removed by Kovid as it generated compiler warnings \\n}\\n', x, flags=re.DOTALL))\n    json.dump(\n        sinfo,\n        open('source-info.json', 'w'),\n        indent=2,\n        ensure_ascii=False,\n        sort_keys=True\n    )\n    generate_wrappers(glfw_header, glfw_native_header)\n\n\nif __name__ == '__main__':\n    main()\n",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/glfw/win32_platform.h": "//========================================================================\n// GLFW 3.3 Win32 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2016 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n// We don't need all the fancy stuff\n#ifndef NOMINMAX\n #define NOMINMAX\n#endif\n\n#ifndef VC_EXTRALEAN\n #define VC_EXTRALEAN\n#endif\n\n#ifndef WIN32_LEAN_AND_MEAN\n #define WIN32_LEAN_AND_MEAN\n#endif\n\n// This is a workaround for the fact that glfw3.h needs to export APIENTRY (for\n// example to allow applications to correctly declare a GL_ARB_debug_output\n// callback) but windows.h assumes no one will define APIENTRY before it does\n#undef APIENTRY\n\n// GLFW on Windows is Unicode only and does not work in MBCS mode\n#ifndef UNICODE\n #define UNICODE\n#endif\n\n// GLFW requires Windows XP or later\n#if WINVER < 0x0501\n #undef WINVER\n #define WINVER 0x0501\n#endif\n#if _WIN32_WINNT < 0x0501\n #undef _WIN32_WINNT\n #define _WIN32_WINNT 0x0501\n#endif\n\n// GLFW uses DirectInput8 interfaces\n#define DIRECTINPUT_VERSION 0x0800\n\n#include <wctype.h>\n#include <windows.h>\n#include <dinput.h>\n#include <xinput.h>\n#include <dbt.h>\n\n// HACK: Define macros that some windows.h variants don't\n#ifndef WM_MOUSEHWHEEL\n #define WM_MOUSEHWHEEL 0x020E\n#endif\n#ifndef WM_DWMCOMPOSITIONCHANGED\n #define WM_DWMCOMPOSITIONCHANGED 0x031E\n#endif\n#ifndef WM_COPYGLOBALDATA\n #define WM_COPYGLOBALDATA 0x0049\n#endif\n#ifndef WM_UNICHAR\n #define WM_UNICHAR 0x0109\n#endif\n#ifndef UNICODE_NOCHAR\n #define UNICODE_NOCHAR 0xFFFF\n#endif\n#ifndef WM_DPICHANGED\n #define WM_DPICHANGED 0x02E0\n#endif\n#ifndef GET_XBUTTON_WPARAM\n #define GET_XBUTTON_WPARAM(w) (HIWORD(w))\n#endif\n#ifndef EDS_ROTATEDMODE\n #define EDS_ROTATEDMODE 0x00000004\n#endif\n#ifndef DISPLAY_DEVICE_ACTIVE\n #define DISPLAY_DEVICE_ACTIVE 0x00000001\n#endif\n#ifndef _WIN32_WINNT_WINBLUE\n #define _WIN32_WINNT_WINBLUE 0x0602\n#endif\n\n#if WINVER < 0x0601\ntypedef struct\n{\n    DWORD cbSize;\n    DWORD ExtStatus;\n} CHANGEFILTERSTRUCT;\n#ifndef MSGFLT_ALLOW\n #define MSGFLT_ALLOW 1\n#endif\n#endif /*Windows 7*/\n\n#if WINVER < 0x0600\n#define DWM_BB_ENABLE 0x00000001\n#define DWM_BB_BLURREGION 0x00000002\ntypedef struct\n{\n    DWORD dwFlags;\n    BOOL fEnable;\n    HRGN hRgnBlur;\n    BOOL fTransitionOnMaximized;\n} DWM_BLURBEHIND;\n#else\n #include <dwmapi.h>\n#endif /*Windows Vista*/\n\n#ifndef DPI_ENUMS_DECLARED\ntypedef enum\n{\n    PROCESS_DPI_UNAWARE = 0,\n    PROCESS_SYSTEM_DPI_AWARE = 1,\n    PROCESS_PER_MONITOR_DPI_AWARE = 2\n} PROCESS_DPI_AWARENESS;\ntypedef enum\n{\n    MDT_EFFECTIVE_DPI = 0,\n    MDT_ANGULAR_DPI = 1,\n    MDT_RAW_DPI = 2,\n    MDT_DEFAULT = MDT_EFFECTIVE_DPI\n} MONITOR_DPI_TYPE;\n#endif /*DPI_ENUMS_DECLARED*/\n\n// HACK: Define versionhelpers.h functions manually as MinGW lacks the header\nBOOL IsWindowsVersionOrGreater(WORD major, WORD minor, WORD sp);\n#define IsWindowsVistaOrGreater()                              \\\n    IsWindowsVersionOrGreater(HIBYTE(_WIN32_WINNT_VISTA),      \\\n                              LOBYTE(_WIN32_WINNT_VISTA), 0)\n#define IsWindows7OrGreater()                                  \\\n    IsWindowsVersionOrGreater(HIBYTE(_WIN32_WINNT_WIN7),       \\\n                              LOBYTE(_WIN32_WINNT_WIN7), 0)\n#define IsWindows8OrGreater()                                  \\\n    IsWindowsVersionOrGreater(HIBYTE(_WIN32_WINNT_WIN8),       \\\n                              LOBYTE(_WIN32_WINNT_WIN8), 0)\n#define IsWindows8Point1OrGreater()                            \\\n    IsWindowsVersionOrGreater(HIBYTE(_WIN32_WINNT_WINBLUE),    \\\n                              LOBYTE(_WIN32_WINNT_WINBLUE), 0)\n\n// HACK: Define macros that some xinput.h variants don't\n#ifndef XINPUT_CAPS_WIRELESS\n #define XINPUT_CAPS_WIRELESS 0x0002\n#endif\n#ifndef XINPUT_DEVSUBTYPE_WHEEL\n #define XINPUT_DEVSUBTYPE_WHEEL 0x02\n#endif\n#ifndef XINPUT_DEVSUBTYPE_ARCADE_STICK\n #define XINPUT_DEVSUBTYPE_ARCADE_STICK 0x03\n#endif\n#ifndef XINPUT_DEVSUBTYPE_FLIGHT_STICK\n #define XINPUT_DEVSUBTYPE_FLIGHT_STICK 0x04\n#endif\n#ifndef XINPUT_DEVSUBTYPE_DANCE_PAD\n #define XINPUT_DEVSUBTYPE_DANCE_PAD 0x05\n#endif\n#ifndef XINPUT_DEVSUBTYPE_GUITAR\n #define XINPUT_DEVSUBTYPE_GUITAR 0x06\n#endif\n#ifndef XINPUT_DEVSUBTYPE_DRUM_KIT\n #define XINPUT_DEVSUBTYPE_DRUM_KIT 0x08\n#endif\n#ifndef XINPUT_DEVSUBTYPE_ARCADE_PAD\n #define XINPUT_DEVSUBTYPE_ARCADE_PAD 0x13\n#endif\n#ifndef XUSER_MAX_COUNT\n #define XUSER_MAX_COUNT 4\n#endif\n\n// HACK: Define macros that some dinput.h variants don't\n#ifndef DIDFT_OPTIONAL\n #define DIDFT_OPTIONAL\t0x80000000\n#endif\n\n// winmm.dll function pointer typedefs\ntypedef DWORD (WINAPI * PFN_timeGetTime)(void);\n#define timeGetTime _glfw.win32.winmm.GetTime\n\n// xinput.dll function pointer typedefs\ntypedef DWORD (WINAPI * PFN_XInputGetCapabilities)(DWORD,DWORD,XINPUT_CAPABILITIES*);\ntypedef DWORD (WINAPI * PFN_XInputGetState)(DWORD,XINPUT_STATE*);\n#define XInputGetCapabilities _glfw.win32.xinput.GetCapabilities\n#define XInputGetState _glfw.win32.xinput.GetState\n\n// dinput8.dll function pointer typedefs\ntypedef HRESULT (WINAPI * PFN_DirectInput8Create)(HINSTANCE,DWORD,REFIID,LPVOID*,LPUNKNOWN);\n#define DirectInput8Create _glfw.win32.dinput8.Create\n\n// user32.dll function pointer typedefs\ntypedef BOOL (WINAPI * PFN_SetProcessDPIAware)(void);\ntypedef BOOL (WINAPI * PFN_ChangeWindowMessageFilterEx)(HWND,UINT,DWORD,CHANGEFILTERSTRUCT*);\n#define SetProcessDPIAware _glfw.win32.user32.SetProcessDPIAware_\n#define ChangeWindowMessageFilterEx _glfw.win32.user32.ChangeWindowMessageFilterEx_\n\n// dwmapi.dll function pointer typedefs\ntypedef HRESULT (WINAPI * PFN_DwmIsCompositionEnabled)(BOOL*);\ntypedef HRESULT (WINAPI * PFN_DwmFlush)(VOID);\ntypedef HRESULT(WINAPI * PFN_DwmEnableBlurBehindWindow)(HWND,const DWM_BLURBEHIND*);\n#define DwmIsCompositionEnabled _glfw.win32.dwmapi.IsCompositionEnabled\n#define DwmFlush _glfw.win32.dwmapi.Flush\n#define DwmEnableBlurBehindWindow _glfw.win32.dwmapi.EnableBlurBehindWindow\n\n// shcore.dll function pointer typedefs\ntypedef HRESULT (WINAPI * PFN_SetProcessDpiAwareness)(PROCESS_DPI_AWARENESS);\ntypedef HRESULT (WINAPI * PFN_GetDpiForMonitor)(HMONITOR,MONITOR_DPI_TYPE,UINT*,UINT*);\n#define SetProcessDpiAwareness _glfw.win32.shcore.SetProcessDpiAwareness_\n#define GetDpiForMonitor _glfw.win32.shcore.GetDpiForMonitor_\n\ntypedef VkFlags VkWin32SurfaceCreateFlagsKHR;\n\ntypedef struct VkWin32SurfaceCreateInfoKHR\n{\n    VkStructureType                 sType;\n    const void*                     pNext;\n    VkWin32SurfaceCreateFlagsKHR    flags;\n    HINSTANCE                       hinstance;\n    HWND                            hwnd;\n} VkWin32SurfaceCreateInfoKHR;\n\ntypedef VkResult (APIENTRY *PFN_vkCreateWin32SurfaceKHR)(VkInstance,const VkWin32SurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);\ntypedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice,uint32_t);\n\n#include \"win32_joystick.h\"\n#include \"wgl_context.h\"\n#include \"egl_context.h\"\n#include \"osmesa_context.h\"\n\n#if !defined(_GLFW_WNDCLASSNAME)\n #define _GLFW_WNDCLASSNAME L\"GLFW30\"\n#endif\n\n#define _glfw_dlopen(name) LoadLibraryA(name)\n#define _glfw_dlclose(handle) FreeLibrary((HMODULE) handle)\n#define _glfw_dlsym(handle, name) GetProcAddress((HMODULE) handle, name)\n\n#define _GLFW_EGL_NATIVE_WINDOW  ((EGLNativeWindowType) window->win32.handle)\n#define _GLFW_EGL_NATIVE_DISPLAY EGL_DEFAULT_DISPLAY\n\n#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowWin32  win32\n#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryWin32 win32\n#define _GLFW_PLATFORM_LIBRARY_TIMER_STATE  _GLFWtimerWin32   win32\n#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorWin32 win32\n#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorWin32  win32\n#define _GLFW_PLATFORM_TLS_STATE            _GLFWtlsWin32     win32\n#define _GLFW_PLATFORM_MUTEX_STATE          _GLFWmutexWin32   win32\n\n\n// Win32-specific per-window data\n//\ntypedef struct _GLFWwindowWin32\n{\n    HWND                handle;\n    HICON               bigIcon;\n    HICON               smallIcon;\n\n    GLFWbool            cursorTracked;\n    GLFWbool            frameAction;\n    GLFWbool            iconified;\n    GLFWbool            maximized;\n    // Whether to enable framebuffer transparency on DWM\n    GLFWbool            transparent;\n\n    // The last received cursor position, regardless of source\n    int                 lastCursorPosX, lastCursorPosY;\n\n} _GLFWwindowWin32;\n\n// Win32-specific global data\n//\ntypedef struct _GLFWlibraryWin32\n{\n    HWND                helperWindowHandle;\n    HDEVNOTIFY          deviceNotificationHandle;\n    DWORD               foregroundLockTimeout;\n    int                 acquiredMonitorCount;\n    char*               clipboardString;\n    short int           keycodes[512];\n    short int           scancodes[GLFW_KEY_LAST + 1];\n    char                keynames[GLFW_KEY_LAST + 1][5];\n    // Where to place the cursor when re-enabled\n    double              restoreCursorPosX, restoreCursorPosY;\n    // The window whose disabled cursor mode is active\n    _GLFWwindow*        disabledCursorWindow;\n    RAWINPUT*           rawInput;\n    int                 rawInputSize;\n\n    struct {\n        HINSTANCE                       instance;\n        PFN_timeGetTime                 GetTime;\n    } winmm;\n\n    struct {\n        HINSTANCE                       instance;\n        PFN_DirectInput8Create          Create;\n        IDirectInput8W*                 api;\n    } dinput8;\n\n    struct {\n        HINSTANCE                       instance;\n        PFN_XInputGetCapabilities       GetCapabilities;\n        PFN_XInputGetState              GetState;\n    } xinput;\n\n    struct {\n        HINSTANCE                       instance;\n        PFN_SetProcessDPIAware          SetProcessDPIAware_;\n        PFN_ChangeWindowMessageFilterEx ChangeWindowMessageFilterEx_;\n    } user32;\n\n    struct {\n        HINSTANCE                       instance;\n        PFN_DwmIsCompositionEnabled     IsCompositionEnabled;\n        PFN_DwmFlush                    Flush;\n        PFN_DwmEnableBlurBehindWindow   EnableBlurBehindWindow;\n    } dwmapi;\n\n    struct {\n        HINSTANCE                       instance;\n        PFN_SetProcessDpiAwareness      SetProcessDpiAwareness_;\n        PFN_GetDpiForMonitor            GetDpiForMonitor_;\n    } shcore;\n\n} _GLFWlibraryWin32;\n\n// Win32-specific per-monitor data\n//\ntypedef struct _GLFWmonitorWin32\n{\n    HMONITOR            handle;\n    // This size matches the static size of DISPLAY_DEVICE.DeviceName\n    WCHAR               adapterName[32];\n    WCHAR               displayName[32];\n    char                publicAdapterName[32];\n    char                publicDisplayName[32];\n    GLFWbool            modesPruned;\n    GLFWbool            modeChanged;\n\n} _GLFWmonitorWin32;\n\n// Win32-specific per-cursor data\n//\ntypedef struct _GLFWcursorWin32\n{\n    HCURSOR             handle;\n\n} _GLFWcursorWin32;\n\n// Win32-specific global timer data\n//\ntypedef struct _GLFWtimerWin32\n{\n    GLFWbool            hasPC;\n    uint64_t            frequency;\n\n} _GLFWtimerWin32;\n\n// Win32-specific thread local storage data\n//\ntypedef struct _GLFWtlsWin32\n{\n    GLFWbool            allocated;\n    DWORD               index;\n\n} _GLFWtlsWin32;\n\n// Win32-specific mutex data\n//\ntypedef struct _GLFWmutexWin32\n{\n    GLFWbool            allocated;\n    CRITICAL_SECTION    section;\n\n} _GLFWmutexWin32;\n\n\nGLFWbool _glfwRegisterWindowClassWin32(void);\nvoid _glfwUnregisterWindowClassWin32(void);\nGLFWbool _glfwIsCompositionEnabledWin32(void);\n\nWCHAR* _glfwCreateWideStringFromUTF8Win32(const char* source);\nchar* _glfwCreateUTF8FromWideStringWin32(const WCHAR* source);\nvoid _glfwInputErrorWin32(int error, const char* description);\nvoid _glfwUpdateKeyNamesWin32(void);\n\nvoid _glfwInitTimerWin32(void);\n\nvoid _glfwPollMonitorsWin32(void);\nvoid _glfwSetVideoModeWin32(_GLFWmonitor* monitor, const GLFWvidmode* desired);\nvoid _glfwRestoreVideoModeWin32(_GLFWmonitor* monitor);\nvoid _glfwGetMonitorContentScaleWin32(HMONITOR handle, float* xscale, float* yscale);\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/glfw/glx_context.c": "//========================================================================\n// GLFW 3.3 GLX - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2016 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#ifndef GLXBadProfileARB\n #define GLXBadProfileARB 13\n#endif\n\n\n// Returns the specified attribute of the specified GLXFBConfig\n//\nstatic int getGLXFBConfigAttrib(GLXFBConfig fbconfig, int attrib)\n{\n    int value;\n    glXGetFBConfigAttrib(_glfw.x11.display, fbconfig, attrib, &value);\n    return value;\n}\n\n// Return the GLXFBConfig most closely matching the specified hints\n//\nstatic GLFWbool chooseGLXFBConfig(const _GLFWfbconfig* desired,\n                                  GLXFBConfig* result)\n{\n    GLXFBConfig* nativeConfigs;\n    _GLFWfbconfig* usableConfigs;\n    const _GLFWfbconfig* closest;\n    int i, nativeCount, usableCount;\n    const char* vendor;\n    GLFWbool trustWindowBit = GLFW_TRUE;\n\n    // HACK: This is a (hopefully temporary) workaround for Chromium\n    //       (VirtualBox GL) not setting the window bit on any GLXFBConfigs\n    vendor = glXGetClientString(_glfw.x11.display, GLX_VENDOR);\n    if (vendor && strcmp(vendor, \"Chromium\") == 0)\n        trustWindowBit = GLFW_FALSE;\n\n    nativeConfigs =\n        glXGetFBConfigs(_glfw.x11.display, _glfw.x11.screen, &nativeCount);\n    if (!nativeConfigs || !nativeCount)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: No GLXFBConfigs returned\");\n        return GLFW_FALSE;\n    }\n\n    usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));\n    usableCount = 0;\n\n    for (i = 0;  i < nativeCount;  i++)\n    {\n        const GLXFBConfig n = nativeConfigs[i];\n        _GLFWfbconfig* u = usableConfigs + usableCount;\n\n        // Only consider RGBA GLXFBConfigs\n        if (!(getGLXFBConfigAttrib(n, GLX_RENDER_TYPE) & GLX_RGBA_BIT))\n            continue;\n\n        // Only consider window GLXFBConfigs\n        if (!(getGLXFBConfigAttrib(n, GLX_DRAWABLE_TYPE) & GLX_WINDOW_BIT))\n        {\n            if (trustWindowBit)\n                continue;\n        }\n\n        if (desired->transparent)\n        {\n            XVisualInfo* vi = glXGetVisualFromFBConfig(_glfw.x11.display, n);\n            if (vi)\n            {\n                u->transparent = _glfwIsVisualTransparentX11(vi->visual);\n                XFree(vi);\n            }\n        }\n\n        u->redBits = getGLXFBConfigAttrib(n, GLX_RED_SIZE);\n        u->greenBits = getGLXFBConfigAttrib(n, GLX_GREEN_SIZE);\n        u->blueBits = getGLXFBConfigAttrib(n, GLX_BLUE_SIZE);\n\n        u->alphaBits = getGLXFBConfigAttrib(n, GLX_ALPHA_SIZE);\n        u->depthBits = getGLXFBConfigAttrib(n, GLX_DEPTH_SIZE);\n        u->stencilBits = getGLXFBConfigAttrib(n, GLX_STENCIL_SIZE);\n\n        u->accumRedBits = getGLXFBConfigAttrib(n, GLX_ACCUM_RED_SIZE);\n        u->accumGreenBits = getGLXFBConfigAttrib(n, GLX_ACCUM_GREEN_SIZE);\n        u->accumBlueBits = getGLXFBConfigAttrib(n, GLX_ACCUM_BLUE_SIZE);\n        u->accumAlphaBits = getGLXFBConfigAttrib(n, GLX_ACCUM_ALPHA_SIZE);\n\n        u->auxBuffers = getGLXFBConfigAttrib(n, GLX_AUX_BUFFERS);\n\n        if (getGLXFBConfigAttrib(n, GLX_STEREO))\n            u->stereo = GLFW_TRUE;\n        if (getGLXFBConfigAttrib(n, GLX_DOUBLEBUFFER))\n            u->doublebuffer = GLFW_TRUE;\n\n        if (_glfw.glx.ARB_multisample)\n            u->samples = getGLXFBConfigAttrib(n, GLX_SAMPLES);\n\n        if (_glfw.glx.ARB_framebuffer_sRGB || _glfw.glx.EXT_framebuffer_sRGB)\n            u->sRGB = getGLXFBConfigAttrib(n, GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB);\n\n        u->handle = (uintptr_t) n;\n        usableCount++;\n    }\n\n    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);\n    if (closest)\n        *result = (GLXFBConfig) closest->handle;\n\n    XFree(nativeConfigs);\n    free(usableConfigs);\n\n    return closest != NULL;\n}\n\n// Create the OpenGL context using legacy API\n//\nstatic GLXContext createLegacyContextGLX(_GLFWwindow* window,\n                                         GLXFBConfig fbconfig,\n                                         GLXContext share)\n{\n    return glXCreateNewContext(_glfw.x11.display,\n                               fbconfig,\n                               GLX_RGBA_TYPE,\n                               share,\n                               True);\n}\n\nstatic void makeContextCurrentGLX(_GLFWwindow* window)\n{\n    if (window)\n    {\n        if (!glXMakeCurrent(_glfw.x11.display,\n                            window->context.glx.window,\n                            window->context.glx.handle))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"GLX: Failed to make context current\");\n            return;\n        }\n    }\n    else\n    {\n        if (!glXMakeCurrent(_glfw.x11.display, None, NULL))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"GLX: Failed to clear current context\");\n            return;\n        }\n    }\n\n    _glfwPlatformSetTls(&_glfw.contextSlot, window);\n}\n\nstatic void swapBuffersGLX(_GLFWwindow* window)\n{\n    glXSwapBuffers(_glfw.x11.display, window->context.glx.window);\n}\n\nstatic void swapIntervalGLX(int interval)\n{\n    _GLFWwindow* window = _glfwPlatformGetTls(&_glfw.contextSlot);\n\n    if (_glfw.glx.EXT_swap_control)\n    {\n        _glfw.glx.SwapIntervalEXT(_glfw.x11.display,\n                                  window->context.glx.window,\n                                  interval);\n    }\n    else if (_glfw.glx.MESA_swap_control)\n        _glfw.glx.SwapIntervalMESA(interval);\n    else if (_glfw.glx.SGI_swap_control)\n    {\n        if (interval > 0)\n            _glfw.glx.SwapIntervalSGI(interval);\n    }\n}\n\nstatic int extensionSupportedGLX(const char* extension)\n{\n    const char* extensions =\n        glXQueryExtensionsString(_glfw.x11.display, _glfw.x11.screen);\n    if (extensions)\n    {\n        if (_glfwStringInExtensionString(extension, extensions))\n            return GLFW_TRUE;\n    }\n\n    return GLFW_FALSE;\n}\n\nstatic GLFWglproc getProcAddressGLX(const char* procname)\n{\n    if (_glfw.glx.GetProcAddress)\n        return _glfw.glx.GetProcAddress((const GLubyte*) procname);\n    else if (_glfw.glx.GetProcAddressARB)\n        return _glfw.glx.GetProcAddressARB((const GLubyte*) procname);\n    else\n        return _glfw_dlsym(_glfw.glx.handle, procname);\n}\n\n// Destroy the OpenGL context\n//\nstatic void destroyContextGLX(_GLFWwindow* window)\n{\n    if (window->context.glx.window)\n    {\n        glXDestroyWindow(_glfw.x11.display, window->context.glx.window);\n        window->context.glx.window = None;\n    }\n\n    if (window->context.glx.handle)\n    {\n        glXDestroyContext(_glfw.x11.display, window->context.glx.handle);\n        window->context.glx.handle = NULL;\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Initialize GLX\n//\nGLFWbool _glfwInitGLX(void)\n{\n    int i;\n    const char* sonames[] =\n    {\n#if defined(_GLFW_GLX_LIBRARY)\n        _GLFW_GLX_LIBRARY,\n#elif defined(__CYGWIN__)\n        \"libGL-1.so\",\n#else\n        \"libGL.so.1\",\n        \"libGL.so\",\n#endif\n        NULL\n    };\n\n    if (_glfw.glx.handle)\n        return GLFW_TRUE;\n\n    for (i = 0;  sonames[i];  i++)\n    {\n        _glfw.glx.handle = _glfw_dlopen(sonames[i]);\n        if (_glfw.glx.handle)\n            break;\n    }\n\n    if (!_glfw.glx.handle)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: Failed to load GLX\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.glx.GetFBConfigs =\n        _glfw_dlsym(_glfw.glx.handle, \"glXGetFBConfigs\");\n    _glfw.glx.GetFBConfigAttrib =\n        _glfw_dlsym(_glfw.glx.handle, \"glXGetFBConfigAttrib\");\n    _glfw.glx.GetClientString =\n        _glfw_dlsym(_glfw.glx.handle, \"glXGetClientString\");\n    _glfw.glx.QueryExtension =\n        _glfw_dlsym(_glfw.glx.handle, \"glXQueryExtension\");\n    _glfw.glx.QueryVersion =\n        _glfw_dlsym(_glfw.glx.handle, \"glXQueryVersion\");\n    _glfw.glx.DestroyContext =\n        _glfw_dlsym(_glfw.glx.handle, \"glXDestroyContext\");\n    _glfw.glx.MakeCurrent =\n        _glfw_dlsym(_glfw.glx.handle, \"glXMakeCurrent\");\n    _glfw.glx.SwapBuffers =\n        _glfw_dlsym(_glfw.glx.handle, \"glXSwapBuffers\");\n    _glfw.glx.QueryExtensionsString =\n        _glfw_dlsym(_glfw.glx.handle, \"glXQueryExtensionsString\");\n    _glfw.glx.CreateNewContext =\n        _glfw_dlsym(_glfw.glx.handle, \"glXCreateNewContext\");\n    _glfw.glx.CreateWindow =\n        _glfw_dlsym(_glfw.glx.handle, \"glXCreateWindow\");\n    _glfw.glx.DestroyWindow =\n        _glfw_dlsym(_glfw.glx.handle, \"glXDestroyWindow\");\n    _glfw.glx.GetProcAddress =\n        _glfw_dlsym(_glfw.glx.handle, \"glXGetProcAddress\");\n    _glfw.glx.GetProcAddressARB =\n        _glfw_dlsym(_glfw.glx.handle, \"glXGetProcAddressARB\");\n    _glfw.glx.GetVisualFromFBConfig =\n        _glfw_dlsym(_glfw.glx.handle, \"glXGetVisualFromFBConfig\");\n\n    if (!_glfw.glx.GetFBConfigs ||\n        !_glfw.glx.GetFBConfigAttrib ||\n        !_glfw.glx.GetClientString ||\n        !_glfw.glx.QueryExtension ||\n        !_glfw.glx.QueryVersion ||\n        !_glfw.glx.DestroyContext ||\n        !_glfw.glx.MakeCurrent ||\n        !_glfw.glx.SwapBuffers ||\n        !_glfw.glx.QueryExtensionsString ||\n        !_glfw.glx.CreateNewContext ||\n        !_glfw.glx.CreateWindow ||\n        !_glfw.glx.DestroyWindow ||\n        !_glfw.glx.GetProcAddress ||\n        !_glfw.glx.GetProcAddressARB ||\n        !_glfw.glx.GetVisualFromFBConfig)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to load required entry points\");\n        return GLFW_FALSE;\n    }\n\n    if (!glXQueryExtension(_glfw.x11.display,\n                           &_glfw.glx.errorBase,\n                           &_glfw.glx.eventBase))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: GLX extension not found\");\n        return GLFW_FALSE;\n    }\n\n    if (!glXQueryVersion(_glfw.x11.display, &_glfw.glx.major, &_glfw.glx.minor))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: Failed to query GLX version\");\n        return GLFW_FALSE;\n    }\n\n    if (_glfw.glx.major == 1 && _glfw.glx.minor < 3)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: GLX version 1.3 is required\");\n        return GLFW_FALSE;\n    }\n\n    if (extensionSupportedGLX(\"GLX_EXT_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)\n            getProcAddressGLX(\"glXSwapIntervalEXT\");\n\n        if (_glfw.glx.SwapIntervalEXT)\n            _glfw.glx.EXT_swap_control = GLFW_TRUE;\n    }\n\n    if (extensionSupportedGLX(\"GLX_SGI_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalSGI = (PFNGLXSWAPINTERVALSGIPROC)\n            getProcAddressGLX(\"glXSwapIntervalSGI\");\n\n        if (_glfw.glx.SwapIntervalSGI)\n            _glfw.glx.SGI_swap_control = GLFW_TRUE;\n    }\n\n    if (extensionSupportedGLX(\"GLX_MESA_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalMESA = (PFNGLXSWAPINTERVALMESAPROC)\n            getProcAddressGLX(\"glXSwapIntervalMESA\");\n\n        if (_glfw.glx.SwapIntervalMESA)\n            _glfw.glx.MESA_swap_control = GLFW_TRUE;\n    }\n\n    if (extensionSupportedGLX(\"GLX_ARB_multisample\"))\n        _glfw.glx.ARB_multisample = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_ARB_framebuffer_sRGB\"))\n        _glfw.glx.ARB_framebuffer_sRGB = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_EXT_framebuffer_sRGB\"))\n        _glfw.glx.EXT_framebuffer_sRGB = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_ARB_create_context\"))\n    {\n        _glfw.glx.CreateContextAttribsARB = (PFNGLXCREATECONTEXTATTRIBSARBPROC)\n            getProcAddressGLX(\"glXCreateContextAttribsARB\");\n\n        if (_glfw.glx.CreateContextAttribsARB)\n            _glfw.glx.ARB_create_context = GLFW_TRUE;\n    }\n\n    if (extensionSupportedGLX(\"GLX_ARB_create_context_robustness\"))\n        _glfw.glx.ARB_create_context_robustness = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_ARB_create_context_profile\"))\n        _glfw.glx.ARB_create_context_profile = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_EXT_create_context_es2_profile\"))\n        _glfw.glx.EXT_create_context_es2_profile = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_ARB_create_context_no_error\"))\n        _glfw.glx.ARB_create_context_no_error = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_ARB_context_flush_control\"))\n        _glfw.glx.ARB_context_flush_control = GLFW_TRUE;\n\n    return GLFW_TRUE;\n}\n\n// Terminate GLX\n//\nvoid _glfwTerminateGLX(void)\n{\n    // NOTE: This function must not call any X11 functions, as it is called\n    //       after XCloseDisplay (see _glfwPlatformTerminate for details)\n\n    if (_glfw.glx.handle)\n    {\n        _glfw_dlclose(_glfw.glx.handle);\n        _glfw.glx.handle = NULL;\n    }\n}\n\n#define setAttrib(a, v) \\\n{ \\\n    assert((size_t) (index + 1) < sizeof(attribs) / sizeof(attribs[0])); \\\n    attribs[index++] = a; \\\n    attribs[index++] = v; \\\n}\n\n// Create the OpenGL or OpenGL ES context\n//\nGLFWbool _glfwCreateContextGLX(_GLFWwindow* window,\n                               const _GLFWctxconfig* ctxconfig,\n                               const _GLFWfbconfig* fbconfig)\n{\n    int attribs[40];\n    GLXFBConfig native = NULL;\n    GLXContext share = NULL;\n\n    if (ctxconfig->share)\n        share = ctxconfig->share->context.glx.handle;\n\n    if (!chooseGLXFBConfig(fbconfig, &native))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"GLX: Failed to find a suitable GLXFBConfig\");\n        return GLFW_FALSE;\n    }\n\n    if (ctxconfig->client == GLFW_OPENGL_ES_API)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile ||\n            !_glfw.glx.EXT_create_context_es2_profile)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"GLX: OpenGL ES requested but GLX_EXT_create_context_es2_profile is unavailable\");\n            return GLFW_FALSE;\n        }\n    }\n\n    if (ctxconfig->forward)\n    {\n        if (!_glfw.glx.ARB_create_context)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: Forward compatibility requested but GLX_ARB_create_context_profile is unavailable\");\n            return GLFW_FALSE;\n        }\n    }\n\n    if (ctxconfig->profile)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: An OpenGL profile requested but GLX_ARB_create_context_profile is unavailable\");\n            return GLFW_FALSE;\n        }\n    }\n\n    _glfwGrabErrorHandlerX11();\n\n    if (_glfw.glx.ARB_create_context)\n    {\n        int index = 0, mask = 0, flags = 0;\n\n        if (ctxconfig->client == GLFW_OPENGL_API)\n        {\n            if (ctxconfig->forward)\n                flags |= GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB;\n\n            if (ctxconfig->profile == GLFW_OPENGL_CORE_PROFILE)\n                mask |= GLX_CONTEXT_CORE_PROFILE_BIT_ARB;\n            else if (ctxconfig->profile == GLFW_OPENGL_COMPAT_PROFILE)\n                mask |= GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB;\n        }\n        else\n            mask |= GLX_CONTEXT_ES2_PROFILE_BIT_EXT;\n\n        if (ctxconfig->debug)\n            flags |= GLX_CONTEXT_DEBUG_BIT_ARB;\n\n        if (ctxconfig->robustness)\n        {\n            if (_glfw.glx.ARB_create_context_robustness)\n            {\n                if (ctxconfig->robustness == GLFW_NO_RESET_NOTIFICATION)\n                {\n                    setAttrib(GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB,\n                              GLX_NO_RESET_NOTIFICATION_ARB);\n                }\n                else if (ctxconfig->robustness == GLFW_LOSE_CONTEXT_ON_RESET)\n                {\n                    setAttrib(GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB,\n                              GLX_LOSE_CONTEXT_ON_RESET_ARB);\n                }\n\n                flags |= GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB;\n            }\n        }\n\n        if (ctxconfig->release)\n        {\n            if (_glfw.glx.ARB_context_flush_control)\n            {\n                if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_NONE)\n                {\n                    setAttrib(GLX_CONTEXT_RELEASE_BEHAVIOR_ARB,\n                              GLX_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB);\n                }\n                else if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_FLUSH)\n                {\n                    setAttrib(GLX_CONTEXT_RELEASE_BEHAVIOR_ARB,\n                              GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB);\n                }\n            }\n        }\n\n        if (ctxconfig->noerror)\n        {\n            if (_glfw.glx.ARB_create_context_no_error)\n                setAttrib(GLX_CONTEXT_OPENGL_NO_ERROR_ARB, GLFW_TRUE);\n        }\n\n        // NOTE: Only request an explicitly versioned context when necessary, as\n        //       explicitly requesting version 1.0 does not always return the\n        //       highest version supported by the driver\n        if (ctxconfig->major != 1 || ctxconfig->minor != 0)\n        {\n            setAttrib(GLX_CONTEXT_MAJOR_VERSION_ARB, ctxconfig->major);\n            setAttrib(GLX_CONTEXT_MINOR_VERSION_ARB, ctxconfig->minor);\n        }\n\n        if (mask)\n            setAttrib(GLX_CONTEXT_PROFILE_MASK_ARB, mask);\n\n        if (flags)\n            setAttrib(GLX_CONTEXT_FLAGS_ARB, flags);\n\n        setAttrib(None, None);\n\n        window->context.glx.handle =\n            _glfw.glx.CreateContextAttribsARB(_glfw.x11.display,\n                                              native,\n                                              share,\n                                              True,\n                                              attribs);\n\n        // HACK: This is a fallback for broken versions of the Mesa\n        //       implementation of GLX_ARB_create_context_profile that fail\n        //       default 1.0 context creation with a GLXBadProfileARB error in\n        //       violation of the extension spec\n        if (!window->context.glx.handle)\n        {\n            if (_glfw.x11.errorCode == _glfw.glx.errorBase + GLXBadProfileARB &&\n                ctxconfig->client == GLFW_OPENGL_API &&\n                ctxconfig->profile == GLFW_OPENGL_ANY_PROFILE &&\n                ctxconfig->forward == GLFW_FALSE)\n            {\n                window->context.glx.handle =\n                    createLegacyContextGLX(window, native, share);\n            }\n        }\n    }\n    else\n    {\n        window->context.glx.handle =\n            createLegacyContextGLX(window, native, share);\n    }\n\n    _glfwReleaseErrorHandlerX11();\n\n    if (!window->context.glx.handle)\n    {\n        _glfwInputErrorX11(GLFW_VERSION_UNAVAILABLE, \"GLX: Failed to create context\");\n        return GLFW_FALSE;\n    }\n\n    window->context.glx.window =\n        glXCreateWindow(_glfw.x11.display, native, window->x11.handle, NULL);\n    if (!window->context.glx.window)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR, \"GLX: Failed to create window\");\n        return GLFW_FALSE;\n    }\n\n    window->context.makeCurrent = makeContextCurrentGLX;\n    window->context.swapBuffers = swapBuffersGLX;\n    window->context.swapInterval = swapIntervalGLX;\n    window->context.extensionSupported = extensionSupportedGLX;\n    window->context.getProcAddress = getProcAddressGLX;\n    window->context.destroy = destroyContextGLX;\n\n    return GLFW_TRUE;\n}\n\n#undef setAttrib\n\n// Returns the Visual and depth of the chosen GLXFBConfig\n//\nGLFWbool _glfwChooseVisualGLX(const _GLFWwndconfig* wndconfig,\n                              const _GLFWctxconfig* ctxconfig,\n                              const _GLFWfbconfig* fbconfig,\n                              Visual** visual, int* depth)\n{\n    GLXFBConfig native;\n    XVisualInfo* result;\n\n    if (!chooseGLXFBConfig(fbconfig, &native))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"GLX: Failed to find a suitable GLXFBConfig\");\n        return GLFW_FALSE;\n    }\n\n    result = glXGetVisualFromFBConfig(_glfw.x11.display, native);\n    if (!result)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to retrieve Visual for GLXFBConfig\");\n        return GLFW_FALSE;\n    }\n\n    *visual = result->visual;\n    *depth  = result->depth;\n\n    XFree(result);\n    return GLFW_TRUE;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI GLXContext glfwGetGLXContext(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n\n    if (window->context.client == GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);\n        return NULL;\n    }\n\n    return window->context.glx.handle;\n}\n\nGLFWAPI GLXWindow glfwGetGLXWindow(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(None);\n\n    if (window->context.client == GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);\n        return None;\n    }\n\n    return window->context.glx.window;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/glfw/x11_init.c": "//========================================================================\n// GLFW 3.3 X11 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2016 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#define _GNU_SOURCE\n#include \"internal.h\"\n#include \"backend_utils.h\"\n\n#include <X11/Xresource.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <locale.h>\n#include <fcntl.h>\n\n\n// Check whether the specified atom is supported\n//\nstatic Atom getSupportedAtom(Atom* supportedAtoms,\n                             unsigned long atomCount,\n                             const char* atomName)\n{\n    unsigned long i;\n    const Atom atom = XInternAtom(_glfw.x11.display, atomName, False);\n\n    for (i = 0;  i < atomCount;  i++)\n    {\n        if (supportedAtoms[i] == atom)\n            return atom;\n    }\n\n    return None;\n}\n\n// Check whether the running window manager is EWMH-compliant\n//\nstatic void detectEWMH(void)\n{\n    Window* windowFromRoot = NULL;\n    Window* windowFromChild = NULL;\n\n    // First we need a couple of atoms\n    const Atom supportingWmCheck =\n        XInternAtom(_glfw.x11.display, \"_NET_SUPPORTING_WM_CHECK\", False);\n    const Atom wmSupported =\n        XInternAtom(_glfw.x11.display, \"_NET_SUPPORTED\", False);\n\n    // Then we look for the _NET_SUPPORTING_WM_CHECK property of the root window\n    if (!_glfwGetWindowPropertyX11(_glfw.x11.root,\n                                   supportingWmCheck,\n                                   XA_WINDOW,\n                                   (unsigned char**) &windowFromRoot))\n    {\n        return;\n    }\n\n    _glfwGrabErrorHandlerX11();\n\n    // It should be the ID of a child window (of the root)\n    // Then we look for the same property on the child window\n    if (!_glfwGetWindowPropertyX11(*windowFromRoot,\n                                   supportingWmCheck,\n                                   XA_WINDOW,\n                                   (unsigned char**) &windowFromChild))\n    {\n        XFree(windowFromRoot);\n        return;\n    }\n\n    _glfwReleaseErrorHandlerX11();\n\n    // It should be the ID of that same child window\n    if (*windowFromRoot != *windowFromChild)\n    {\n        XFree(windowFromRoot);\n        XFree(windowFromChild);\n        return;\n    }\n\n    XFree(windowFromRoot);\n    XFree(windowFromChild);\n\n    // We are now fairly sure that an EWMH-compliant window manager is running\n\n    Atom* supportedAtoms;\n    unsigned long atomCount;\n\n    // Now we need to check the _NET_SUPPORTED property of the root window\n    // It should be a list of supported WM protocol and state atoms\n    atomCount = _glfwGetWindowPropertyX11(_glfw.x11.root,\n                                          wmSupported,\n                                          XA_ATOM,\n                                          (unsigned char**) &supportedAtoms);\n\n    // See which of the atoms we support that are supported by the WM\n    _glfw.x11.NET_WM_STATE =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE\");\n    _glfw.x11.NET_WM_STATE_ABOVE =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_ABOVE\");\n    _glfw.x11.NET_WM_STATE_FULLSCREEN =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_FULLSCREEN\");\n    _glfw.x11.NET_WM_STATE_MAXIMIZED_VERT =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_MAXIMIZED_VERT\");\n    _glfw.x11.NET_WM_STATE_MAXIMIZED_HORZ =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_MAXIMIZED_HORZ\");\n    _glfw.x11.NET_WM_STATE_DEMANDS_ATTENTION =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_DEMANDS_ATTENTION\");\n    _glfw.x11.NET_WM_FULLSCREEN_MONITORS =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_FULLSCREEN_MONITORS\");\n    _glfw.x11.NET_WM_WINDOW_TYPE =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_WINDOW_TYPE\");\n    _glfw.x11.NET_WM_WINDOW_TYPE_NORMAL =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_WINDOW_TYPE_NORMAL\");\n    _glfw.x11.NET_ACTIVE_WINDOW =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_ACTIVE_WINDOW\");\n    _glfw.x11.NET_FRAME_EXTENTS =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_FRAME_EXTENTS\");\n    _glfw.x11.NET_REQUEST_FRAME_EXTENTS =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_REQUEST_FRAME_EXTENTS\");\n\n    if (supportedAtoms)\n        XFree(supportedAtoms);\n}\n\n// Look for and initialize supported X11 extensions\n//\nstatic GLFWbool initExtensions(void)\n{\n    _glfw.x11.vidmode.handle = _glfw_dlopen(\"libXxf86vm.so.1\");\n    if (_glfw.x11.vidmode.handle)\n    {\n        _glfw.x11.vidmode.QueryExtension = (PFN_XF86VidModeQueryExtension)\n            _glfw_dlsym(_glfw.x11.vidmode.handle, \"XF86VidModeQueryExtension\");\n        _glfw.x11.vidmode.GetGammaRamp = (PFN_XF86VidModeGetGammaRamp)\n            _glfw_dlsym(_glfw.x11.vidmode.handle, \"XF86VidModeGetGammaRamp\");\n        _glfw.x11.vidmode.SetGammaRamp = (PFN_XF86VidModeSetGammaRamp)\n            _glfw_dlsym(_glfw.x11.vidmode.handle, \"XF86VidModeSetGammaRamp\");\n        _glfw.x11.vidmode.GetGammaRampSize = (PFN_XF86VidModeGetGammaRampSize)\n            _glfw_dlsym(_glfw.x11.vidmode.handle, \"XF86VidModeGetGammaRampSize\");\n\n        _glfw.x11.vidmode.available =\n            XF86VidModeQueryExtension(_glfw.x11.display,\n                                      &_glfw.x11.vidmode.eventBase,\n                                      &_glfw.x11.vidmode.errorBase);\n    }\n\n#if defined(__CYGWIN__)\n    _glfw.x11.xi.handle = _glfw_dlopen(\"libXi-6.so\");\n#else\n    _glfw.x11.xi.handle = _glfw_dlopen(\"libXi.so.6\");\n#endif\n    if (_glfw.x11.xi.handle)\n    {\n        _glfw.x11.xi.QueryVersion = (PFN_XIQueryVersion)\n            _glfw_dlsym(_glfw.x11.xi.handle, \"XIQueryVersion\");\n        _glfw.x11.xi.SelectEvents = (PFN_XISelectEvents)\n            _glfw_dlsym(_glfw.x11.xi.handle, \"XISelectEvents\");\n\n        if (XQueryExtension(_glfw.x11.display,\n                            \"XInputExtension\",\n                            &_glfw.x11.xi.majorOpcode,\n                            &_glfw.x11.xi.eventBase,\n                            &_glfw.x11.xi.errorBase))\n        {\n            _glfw.x11.xi.major = 2;\n            _glfw.x11.xi.minor = 0;\n\n            if (XIQueryVersion(_glfw.x11.display,\n                               &_glfw.x11.xi.major,\n                               &_glfw.x11.xi.minor) == Success)\n            {\n                _glfw.x11.xi.available = GLFW_TRUE;\n            }\n        }\n    }\n\n#if defined(__CYGWIN__)\n    _glfw.x11.randr.handle = _glfw_dlopen(\"libXrandr-2.so\");\n#else\n    _glfw.x11.randr.handle = _glfw_dlopen(\"libXrandr.so.2\");\n#endif\n    if (_glfw.x11.randr.handle)\n    {\n        _glfw.x11.randr.AllocGamma = (PFN_XRRAllocGamma)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRAllocGamma\");\n        _glfw.x11.randr.FreeGamma = (PFN_XRRFreeGamma)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRFreeGamma\");\n        _glfw.x11.randr.FreeCrtcInfo = (PFN_XRRFreeCrtcInfo)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRFreeCrtcInfo\");\n        _glfw.x11.randr.FreeGamma = (PFN_XRRFreeGamma)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRFreeGamma\");\n        _glfw.x11.randr.FreeOutputInfo = (PFN_XRRFreeOutputInfo)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRFreeOutputInfo\");\n        _glfw.x11.randr.FreeScreenResources = (PFN_XRRFreeScreenResources)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRFreeScreenResources\");\n        _glfw.x11.randr.GetCrtcGamma = (PFN_XRRGetCrtcGamma)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRGetCrtcGamma\");\n        _glfw.x11.randr.GetCrtcGammaSize = (PFN_XRRGetCrtcGammaSize)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRGetCrtcGammaSize\");\n        _glfw.x11.randr.GetCrtcInfo = (PFN_XRRGetCrtcInfo)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRGetCrtcInfo\");\n        _glfw.x11.randr.GetOutputInfo = (PFN_XRRGetOutputInfo)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRGetOutputInfo\");\n        _glfw.x11.randr.GetOutputPrimary = (PFN_XRRGetOutputPrimary)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRGetOutputPrimary\");\n        _glfw.x11.randr.GetScreenResourcesCurrent = (PFN_XRRGetScreenResourcesCurrent)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRGetScreenResourcesCurrent\");\n        _glfw.x11.randr.QueryExtension = (PFN_XRRQueryExtension)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRQueryExtension\");\n        _glfw.x11.randr.QueryVersion = (PFN_XRRQueryVersion)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRQueryVersion\");\n        _glfw.x11.randr.SelectInput = (PFN_XRRSelectInput)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRSelectInput\");\n        _glfw.x11.randr.SetCrtcConfig = (PFN_XRRSetCrtcConfig)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRSetCrtcConfig\");\n        _glfw.x11.randr.SetCrtcGamma = (PFN_XRRSetCrtcGamma)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRSetCrtcGamma\");\n        _glfw.x11.randr.UpdateConfiguration = (PFN_XRRUpdateConfiguration)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRUpdateConfiguration\");\n\n        if (XRRQueryExtension(_glfw.x11.display,\n                              &_glfw.x11.randr.eventBase,\n                              &_glfw.x11.randr.errorBase))\n        {\n            if (XRRQueryVersion(_glfw.x11.display,\n                                &_glfw.x11.randr.major,\n                                &_glfw.x11.randr.minor))\n            {\n                // The GLFW RandR path requires at least version 1.3\n                if (_glfw.x11.randr.major > 1 || _glfw.x11.randr.minor >= 3)\n                    _glfw.x11.randr.available = GLFW_TRUE;\n            }\n            else\n            {\n                _glfwInputError(GLFW_PLATFORM_ERROR,\n                                \"X11: Failed to query RandR version\");\n            }\n        }\n    }\n\n    if (_glfw.x11.randr.available)\n    {\n        XRRScreenResources* sr = XRRGetScreenResourcesCurrent(_glfw.x11.display,\n                                                              _glfw.x11.root);\n\n        if (!sr->ncrtc || !XRRGetCrtcGammaSize(_glfw.x11.display, sr->crtcs[0]))\n        {\n            // This is likely an older Nvidia driver with broken gamma support\n            // Flag it as useless and fall back to xf86vm gamma, if available\n            _glfw.x11.randr.gammaBroken = GLFW_TRUE;\n        }\n\n        if (!sr->ncrtc)\n        {\n            // A system without CRTCs is likely a system with broken RandR\n            // Disable the RandR monitor path and fall back to core functions\n            _glfw.x11.randr.monitorBroken = GLFW_TRUE;\n        }\n\n        XRRFreeScreenResources(sr);\n    }\n\n    if (_glfw.x11.randr.available && !_glfw.x11.randr.monitorBroken)\n    {\n        XRRSelectInput(_glfw.x11.display, _glfw.x11.root,\n                       RROutputChangeNotifyMask);\n    }\n\n#if defined(__CYGWIN__)\n    _glfw.x11.xcursor.handle = _glfw_dlopen(\"libXcursor-1.so\");\n#else\n    _glfw.x11.xcursor.handle = _glfw_dlopen(\"libXcursor.so.1\");\n#endif\n    if (_glfw.x11.xcursor.handle)\n    {\n        _glfw.x11.xcursor.ImageCreate = (PFN_XcursorImageCreate)\n            _glfw_dlsym(_glfw.x11.xcursor.handle, \"XcursorImageCreate\");\n        _glfw.x11.xcursor.ImageDestroy = (PFN_XcursorImageDestroy)\n            _glfw_dlsym(_glfw.x11.xcursor.handle, \"XcursorImageDestroy\");\n        _glfw.x11.xcursor.ImageLoadCursor = (PFN_XcursorImageLoadCursor)\n            _glfw_dlsym(_glfw.x11.xcursor.handle, \"XcursorImageLoadCursor\");\n    }\n\n#if defined(__CYGWIN__)\n    _glfw.x11.xinerama.handle = _glfw_dlopen(\"libXinerama-1.so\");\n#else\n    _glfw.x11.xinerama.handle = _glfw_dlopen(\"libXinerama.so.1\");\n#endif\n    if (_glfw.x11.xinerama.handle)\n    {\n        _glfw.x11.xinerama.IsActive = (PFN_XineramaIsActive)\n            _glfw_dlsym(_glfw.x11.xinerama.handle, \"XineramaIsActive\");\n        _glfw.x11.xinerama.QueryExtension = (PFN_XineramaQueryExtension)\n            _glfw_dlsym(_glfw.x11.xinerama.handle, \"XineramaQueryExtension\");\n        _glfw.x11.xinerama.QueryScreens = (PFN_XineramaQueryScreens)\n            _glfw_dlsym(_glfw.x11.xinerama.handle, \"XineramaQueryScreens\");\n\n        if (XineramaQueryExtension(_glfw.x11.display,\n                                   &_glfw.x11.xinerama.major,\n                                   &_glfw.x11.xinerama.minor))\n        {\n            if (XineramaIsActive(_glfw.x11.display))\n                _glfw.x11.xinerama.available = GLFW_TRUE;\n        }\n    }\n\n#if defined(__CYGWIN__)\n    _glfw.x11.xrender.handle = _glfw_dlopen(\"libXrender-1.so\");\n#else\n    _glfw.x11.xrender.handle = _glfw_dlopen(\"libXrender.so.1\");\n#endif\n    if (_glfw.x11.xrender.handle)\n    {\n        _glfw.x11.xrender.QueryExtension = (PFN_XRenderQueryExtension)\n            _glfw_dlsym(_glfw.x11.xrender.handle, \"XRenderQueryExtension\");\n        _glfw.x11.xrender.QueryVersion = (PFN_XRenderQueryVersion)\n            _glfw_dlsym(_glfw.x11.xrender.handle, \"XRenderQueryVersion\");\n        _glfw.x11.xrender.FindVisualFormat = (PFN_XRenderFindVisualFormat)\n            _glfw_dlsym(_glfw.x11.xrender.handle, \"XRenderFindVisualFormat\");\n\n        if (XRenderQueryExtension(_glfw.x11.display,\n                                  &_glfw.x11.xrender.errorBase,\n                                  &_glfw.x11.xrender.eventBase))\n        {\n            if (XRenderQueryVersion(_glfw.x11.display,\n                                    &_glfw.x11.xrender.major,\n                                    &_glfw.x11.xrender.minor))\n            {\n                _glfw.x11.xrender.available = GLFW_TRUE;\n            }\n        }\n    }\n\n    _glfw.x11.xkb.major = 1;\n    _glfw.x11.xkb.minor = 0;\n    _glfw.x11.xkb.available = XkbQueryExtension(_glfw.x11.display,\n            &_glfw.x11.xkb.majorOpcode,\n            &_glfw.x11.xkb.eventBase,\n            &_glfw.x11.xkb.errorBase,\n            &_glfw.x11.xkb.major,\n            &_glfw.x11.xkb.minor);\n\n    if (!_glfw.x11.xkb.available)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR, \"X11: Failed to load Xkb extension\");\n        return GLFW_FALSE;\n    }\n    Bool supported;\n    if (XkbSetDetectableAutoRepeat(_glfw.x11.display, True, &supported))\n    {\n        if (supported)\n            _glfw.x11.xkb.detectable = GLFW_TRUE;\n    }\n\n    if (!glfw_xkb_set_x11_events_mask()) return GLFW_FALSE;\n    if (!glfw_xkb_create_context(&_glfw.x11.xkb)) return GLFW_FALSE;\n    if (!glfw_xkb_update_x11_keyboard_id(&_glfw.x11.xkb)) return GLFW_FALSE;\n    if (!glfw_xkb_compile_keymap(&_glfw.x11.xkb, NULL)) return GLFW_FALSE;\n\n    // Detect whether an EWMH-conformant window manager is running\n    detectEWMH();\n\n    // String format atoms\n    _glfw.x11.NULL_ = XInternAtom(_glfw.x11.display, \"NULL\", False);\n    _glfw.x11.UTF8_STRING = XInternAtom(_glfw.x11.display, \"UTF8_STRING\", False);\n    _glfw.x11.ATOM_PAIR = XInternAtom(_glfw.x11.display, \"ATOM_PAIR\", False);\n\n    // Custom selection property atom\n    _glfw.x11.GLFW_SELECTION =\n        XInternAtom(_glfw.x11.display, \"GLFW_SELECTION\", False);\n\n    // ICCCM standard clipboard atoms\n    _glfw.x11.TARGETS = XInternAtom(_glfw.x11.display, \"TARGETS\", False);\n    _glfw.x11.MULTIPLE = XInternAtom(_glfw.x11.display, \"MULTIPLE\", False);\n    _glfw.x11.PRIMARY = XInternAtom(_glfw.x11.display, \"PRIMARY\", False);\n    _glfw.x11.INCR = XInternAtom(_glfw.x11.display, \"INCR\", False);\n    _glfw.x11.CLIPBOARD = XInternAtom(_glfw.x11.display, \"CLIPBOARD\", False);\n\n    // Clipboard manager atoms\n    _glfw.x11.CLIPBOARD_MANAGER =\n        XInternAtom(_glfw.x11.display, \"CLIPBOARD_MANAGER\", False);\n    _glfw.x11.SAVE_TARGETS =\n        XInternAtom(_glfw.x11.display, \"SAVE_TARGETS\", False);\n\n    // Xdnd (drag and drop) atoms\n    _glfw.x11.XdndAware = XInternAtom(_glfw.x11.display, \"XdndAware\", False);\n    _glfw.x11.XdndEnter = XInternAtom(_glfw.x11.display, \"XdndEnter\", False);\n    _glfw.x11.XdndPosition = XInternAtom(_glfw.x11.display, \"XdndPosition\", False);\n    _glfw.x11.XdndStatus = XInternAtom(_glfw.x11.display, \"XdndStatus\", False);\n    _glfw.x11.XdndActionCopy = XInternAtom(_glfw.x11.display, \"XdndActionCopy\", False);\n    _glfw.x11.XdndDrop = XInternAtom(_glfw.x11.display, \"XdndDrop\", False);\n    _glfw.x11.XdndFinished = XInternAtom(_glfw.x11.display, \"XdndFinished\", False);\n    _glfw.x11.XdndSelection = XInternAtom(_glfw.x11.display, \"XdndSelection\", False);\n    _glfw.x11.XdndTypeList = XInternAtom(_glfw.x11.display, \"XdndTypeList\", False);\n    _glfw.x11.text_uri_list = XInternAtom(_glfw.x11.display, \"text/uri-list\", False);\n\n    // ICCCM, EWMH and Motif window property atoms\n    // These can be set safely even without WM support\n    // The EWMH atoms that require WM support are handled in detectEWMH\n    _glfw.x11.WM_PROTOCOLS =\n        XInternAtom(_glfw.x11.display, \"WM_PROTOCOLS\", False);\n    _glfw.x11.WM_STATE =\n        XInternAtom(_glfw.x11.display, \"WM_STATE\", False);\n    _glfw.x11.WM_DELETE_WINDOW =\n        XInternAtom(_glfw.x11.display, \"WM_DELETE_WINDOW\", False);\n    _glfw.x11.NET_WM_ICON =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_ICON\", False);\n    _glfw.x11.NET_WM_PING =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_PING\", False);\n    _glfw.x11.NET_WM_PID =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_PID\", False);\n    _glfw.x11.NET_WM_NAME =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_NAME\", False);\n    _glfw.x11.NET_WM_ICON_NAME =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_ICON_NAME\", False);\n    _glfw.x11.NET_WM_BYPASS_COMPOSITOR =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_BYPASS_COMPOSITOR\", False);\n    _glfw.x11.NET_WM_WINDOW_OPACITY =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_WINDOW_OPACITY\", False);\n    _glfw.x11.MOTIF_WM_HINTS =\n        XInternAtom(_glfw.x11.display, \"_MOTIF_WM_HINTS\", False);\n\n    // The compositing manager selection name contains the screen number\n    {\n        char name[32];\n        snprintf(name, sizeof(name), \"_NET_WM_CM_S%u\", _glfw.x11.screen);\n        _glfw.x11.NET_WM_CM_Sx = XInternAtom(_glfw.x11.display, name, False);\n    }\n\n    return GLFW_TRUE;\n}\n\n// Retrieve system content scale via folklore heuristics\n//\nvoid _glfwGetSystemContentScaleX11(float* xscale, float* yscale, GLFWbool bypass_cache)\n{\n    // NOTE: Default to the display-wide DPI as we don't currently have a policy\n    //       for which monitor a window is considered to be on\n    float xdpi = DisplayWidth(_glfw.x11.display, _glfw.x11.screen) *\n        25.4f / DisplayWidthMM(_glfw.x11.display, _glfw.x11.screen);\n    float ydpi = DisplayHeight(_glfw.x11.display, _glfw.x11.screen) *\n        25.4f / DisplayHeightMM(_glfw.x11.display, _glfw.x11.screen);\n\n    // NOTE: Basing the scale on Xft.dpi where available should provide the most\n    //       consistent user experience (matches Qt, Gtk, etc), although not\n    //       always the most accurate one\n    char* rms = NULL;\n    char* owned_rms = NULL;\n\n    if (bypass_cache)\n    {\n        _glfwGetWindowPropertyX11(_glfw.x11.root,\n                                  _glfw.x11.RESOURCE_MANAGER,\n                                  XA_STRING,\n                                  (unsigned char**) &owned_rms);\n        rms = owned_rms;\n    } else {\n        rms = XResourceManagerString(_glfw.x11.display);\n    }\n\n    if (rms)\n    {\n        XrmDatabase db = XrmGetStringDatabase(rms);\n        if (db)\n        {\n            XrmValue value;\n            char* type = NULL;\n\n            if (XrmGetResource(db, \"Xft.dpi\", \"Xft.Dpi\", &type, &value))\n            {\n                if (type && strcmp(type, \"String\") == 0)\n                    xdpi = ydpi = atof(value.addr);\n            }\n\n            XrmDestroyDatabase(db);\n        }\n        XFree(owned_rms);\n    }\n\n    *xscale = xdpi / 96.f;\n    *yscale = ydpi / 96.f;\n}\n\n// Create a blank cursor for hidden and disabled cursor modes\n//\nstatic Cursor createHiddenCursor(void)\n{\n    unsigned char pixels[16 * 16 * 4] = { 0 };\n    GLFWimage image = { 16, 16, pixels };\n    return _glfwCreateCursorX11(&image, 0, 0);\n}\n\n// Create a helper window for IPC\n//\nstatic Window createHelperWindow(void)\n{\n    XSetWindowAttributes wa;\n    wa.event_mask = PropertyChangeMask;\n\n    return XCreateWindow(_glfw.x11.display, _glfw.x11.root,\n                         0, 0, 1, 1, 0, 0,\n                         InputOnly,\n                         DefaultVisual(_glfw.x11.display, _glfw.x11.screen),\n                         CWEventMask, &wa);\n}\n\n// X error handler\n//\nstatic int errorHandler(Display *display, XErrorEvent* event)\n{\n    _glfw.x11.errorCode = event->error_code;\n    return 0;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Sets the X error handler callback\n//\nvoid _glfwGrabErrorHandlerX11(void)\n{\n    _glfw.x11.errorCode = Success;\n    XSetErrorHandler(errorHandler);\n}\n\n// Clears the X error handler callback\n//\nvoid _glfwReleaseErrorHandlerX11(void)\n{\n    // Synchronize to make sure all commands are processed\n    XSync(_glfw.x11.display, False);\n    XSetErrorHandler(NULL);\n}\n\n// Reports the specified error, appending information about the last X error\n//\nvoid _glfwInputErrorX11(int error, const char* message)\n{\n    char buffer[_GLFW_MESSAGE_SIZE];\n    XGetErrorText(_glfw.x11.display, _glfw.x11.errorCode,\n                  buffer, sizeof(buffer));\n\n    _glfwInputError(error, \"%s: %s\", message, buffer);\n}\n\n// Creates a native cursor object from the specified image and hotspot\n//\nCursor _glfwCreateCursorX11(const GLFWimage* image, int xhot, int yhot)\n{\n    int i;\n    Cursor cursor;\n\n    if (!_glfw.x11.xcursor.handle)\n        return None;\n\n    XcursorImage* native = XcursorImageCreate(image->width, image->height);\n    if (native == NULL)\n        return None;\n\n    native->xhot = xhot;\n    native->yhot = yhot;\n\n    unsigned char* source = (unsigned char*) image->pixels;\n    XcursorPixel* target = native->pixels;\n\n    for (i = 0;  i < image->width * image->height;  i++, target++, source += 4)\n    {\n        unsigned int alpha = source[3];\n\n        *target = (alpha << 24) |\n                  ((unsigned char) ((source[0] * alpha) / 255) << 16) |\n                  ((unsigned char) ((source[1] * alpha) / 255) <<  8) |\n                  ((unsigned char) ((source[2] * alpha) / 255) <<  0);\n    }\n\n    cursor = XcursorImageLoadCursor(_glfw.x11.display, native);\n    XcursorImageDestroy(native);\n\n    return cursor;\n}\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nint _glfwPlatformInit(void)\n{\n    XInitThreads();\n    XrmInitialize();\n\n    if (pipe2(_glfw.x11.eventLoopData.wakeupFds, O_CLOEXEC | O_NONBLOCK) != 0)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                \"X11: failed to create self pipe\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.x11.display = XOpenDisplay(NULL);\n    if (!_glfw.x11.display)\n    {\n        const char* display = getenv(\"DISPLAY\");\n        if (display)\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"X11: Failed to open display %s\", display);\n        }\n        else\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"X11: The DISPLAY environment variable is missing\");\n        }\n\n        return GLFW_FALSE;\n    }\n\n    initPollData(_glfw.x11.eventLoopData.fds, _glfw.x11.eventLoopData.wakeupFds[0], ConnectionNumber(_glfw.x11.display));\n    _glfw.x11.eventLoopData.fds[2].events = POLLIN;\n\n    _glfw.x11.screen = DefaultScreen(_glfw.x11.display);\n    _glfw.x11.root = RootWindow(_glfw.x11.display, _glfw.x11.screen);\n    _glfw.x11.context = XUniqueContext();\n    _glfw.x11.RESOURCE_MANAGER = XInternAtom(_glfw.x11.display, \"RESOURCE_MANAGER\", True);\n    XSelectInput(_glfw.x11.display, _glfw.x11.root, PropertyChangeMask);\n\n    _glfwGetSystemContentScaleX11(&_glfw.x11.contentScaleX, &_glfw.x11.contentScaleY, GLFW_FALSE);\n\n    if (!initExtensions())\n        return GLFW_FALSE;\n\n    _glfw.x11.helperWindowHandle = createHelperWindow();\n    _glfw.x11.hiddenCursorHandle = createHiddenCursor();\n\n#if defined(__linux__)\n    if (!_glfwInitJoysticksLinux())\n        return GLFW_FALSE;\n#endif\n\n    _glfwInitTimerPOSIX();\n\n    _glfwPollMonitorsX11();\n    return GLFW_TRUE;\n}\n\nvoid _glfwPlatformTerminate(void)\n{\n    if (_glfw.x11.helperWindowHandle)\n    {\n        if (XGetSelectionOwner(_glfw.x11.display, _glfw.x11.CLIPBOARD) ==\n            _glfw.x11.helperWindowHandle)\n        {\n            _glfwPushSelectionToManagerX11();\n        }\n\n        XDestroyWindow(_glfw.x11.display, _glfw.x11.helperWindowHandle);\n        _glfw.x11.helperWindowHandle = None;\n    }\n\n    if (_glfw.x11.hiddenCursorHandle)\n    {\n        XFreeCursor(_glfw.x11.display, _glfw.x11.hiddenCursorHandle);\n        _glfw.x11.hiddenCursorHandle = (Cursor) 0;\n    }\n\n    glfw_xkb_release(&_glfw.x11.xkb);\n    free(_glfw.x11.primarySelectionString);\n    free(_glfw.x11.clipboardString);\n\n    if (_glfw.x11.display)\n    {\n        XCloseDisplay(_glfw.x11.display);\n        _glfw.x11.display = NULL;\n        _glfw.x11.eventLoopData.fds[0].fd = -1;\n    }\n\n    if (_glfw.x11.xcursor.handle)\n    {\n        _glfw_dlclose(_glfw.x11.xcursor.handle);\n        _glfw.x11.xcursor.handle = NULL;\n    }\n\n    if (_glfw.x11.randr.handle)\n    {\n        _glfw_dlclose(_glfw.x11.randr.handle);\n        _glfw.x11.randr.handle = NULL;\n    }\n\n    if (_glfw.x11.xinerama.handle)\n    {\n        _glfw_dlclose(_glfw.x11.xinerama.handle);\n        _glfw.x11.xinerama.handle = NULL;\n    }\n\n    if (_glfw.x11.xrender.handle)\n    {\n        _glfw_dlclose(_glfw.x11.xrender.handle);\n        _glfw.x11.xrender.handle = NULL;\n    }\n\n    if (_glfw.x11.vidmode.handle)\n    {\n        _glfw_dlclose(_glfw.x11.vidmode.handle);\n        _glfw.x11.vidmode.handle = NULL;\n    }\n\n    if (_glfw.x11.xi.handle)\n    {\n        _glfw_dlclose(_glfw.x11.xi.handle);\n        _glfw.x11.xi.handle = NULL;\n    }\n\n    // NOTE: These need to be unloaded after XCloseDisplay, as they register\n    //       cleanup callbacks that get called by that function\n    _glfwTerminateEGL();\n    _glfwTerminateGLX();\n\n#if defined(__linux__)\n    _glfwTerminateJoysticksLinux();\n#endif\n    closeFds(_glfw.x11.eventLoopData.wakeupFds, sizeof(_glfw.x11.eventLoopData.wakeupFds)/sizeof(_glfw.x11.eventLoopData.wakeupFds[0]));\n}\n\nconst char* _glfwPlatformGetVersionString(void)\n{\n    return _GLFW_VERSION_NUMBER \" X11 GLX EGL\"\n#if defined(_POSIX_TIMERS) && defined(_POSIX_MONOTONIC_CLOCK)\n        \" clock_gettime\"\n#else\n        \" gettimeofday\"\n#endif\n#if defined(__linux__)\n        \" evdev\"\n#endif\n#if defined(_GLFW_BUILD_DLL)\n        \" shared\"\n#endif\n        ;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/glfw/cocoa_platform.h": "//========================================================================\n// GLFW 3.3 macOS - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2009-2016 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include <stdint.h>\n#include <dlfcn.h>\n\n#if defined(__OBJC__)\n#import <Carbon/Carbon.h>\n#import <Cocoa/Cocoa.h>\n#else\n#include <Carbon/Carbon.h>\n#include <ApplicationServices/ApplicationServices.h>\ntypedef void* id;\n#endif\n\ntypedef VkFlags VkMacOSSurfaceCreateFlagsMVK;\ntypedef int (* GLFWcocoatextinputfilterfun)(int,int,int);\ntypedef int (* GLFWapplicationshouldhandlereopenfun)(int);\n\ntypedef struct VkMacOSSurfaceCreateInfoMVK\n{\n    VkStructureType                 sType;\n    const void*                     pNext;\n    VkMacOSSurfaceCreateFlagsMVK    flags;\n    const void*                     pView;\n} VkMacOSSurfaceCreateInfoMVK;\n\ntypedef VkResult (APIENTRY *PFN_vkCreateMacOSSurfaceMVK)(VkInstance,const VkMacOSSurfaceCreateInfoMVK*,const VkAllocationCallbacks*,VkSurfaceKHR*);\n\n#include \"posix_thread.h\"\n#include \"cocoa_joystick.h\"\n#include \"nsgl_context.h\"\n#include \"egl_context.h\"\n#include \"osmesa_context.h\"\n\n#define _glfw_dlopen(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL)\n#define _glfw_dlclose(handle) dlclose(handle)\n#define _glfw_dlsym(handle, name) dlsym(handle, name)\n\n#define _GLFW_EGL_NATIVE_WINDOW  ((EGLNativeWindowType) window->ns.view)\n#define _GLFW_EGL_NATIVE_DISPLAY EGL_DEFAULT_DISPLAY\n\n#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowNS  ns\n#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryNS ns\n#define _GLFW_PLATFORM_LIBRARY_TIMER_STATE  _GLFWtimerNS   ns\n#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorNS ns\n#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorNS  ns\n\n// HIToolbox.framework pointer typedefs\n#define kTISPropertyUnicodeKeyLayoutData _glfw.ns.tis.kPropertyUnicodeKeyLayoutData\ntypedef TISInputSourceRef (*PFN_TISCopyCurrentKeyboardLayoutInputSource)(void);\n#define TISCopyCurrentKeyboardLayoutInputSource _glfw.ns.tis.CopyCurrentKeyboardLayoutInputSource\ntypedef void* (*PFN_TISGetInputSourceProperty)(TISInputSourceRef,CFStringRef);\n#define TISGetInputSourceProperty _glfw.ns.tis.GetInputSourceProperty\ntypedef UInt8 (*PFN_LMGetKbdType)(void);\n#define LMGetKbdType _glfw.ns.tis.GetKbdType\n\n\n// Cocoa-specific per-window data\n//\ntypedef struct _GLFWwindowNS\n{\n    id              object;\n    id              delegate;\n    id              view;\n    id              layer;\n\n    GLFWbool        maximized;\n\n    // Cached window properties to filter out duplicate events\n    int             width, height;\n    int             fbWidth, fbHeight;\n    float           xscale, yscale;\n\n    // The total sum of the distances the cursor has been warped\n    // since the last cursor motion event was processed\n    // This is kept to counteract Cocoa doing the same internally\n    double          cursorWarpDeltaX, cursorWarpDeltaY;\n\n    // The text input filter callback\n    GLFWcocoatextinputfilterfun textInputFilterCallback;\n    // Dead key state\n    UInt32 deadKeyState;\n} _GLFWwindowNS;\n\n// Cocoa-specific global data\n//\ntypedef struct _GLFWlibraryNS\n{\n    CGEventSourceRef    eventSource;\n    id                  delegate;\n    id                  autoreleasePool;\n    GLFWbool            cursorHidden;\n    TISInputSourceRef   inputSource;\n    IOHIDManagerRef     hidManager;\n    id                  unicodeData;\n    id                  listener;\n\n    char                keyName[64];\n    char                text[256];\n    GLFWbool            debug_keyboard;\n    short int           keycodes[256];\n    short int           scancodes[GLFW_KEY_LAST + 1];\n    char*               clipboardString;\n    CGPoint             cascadePoint;\n    // Where to place the cursor when re-enabled\n    double              restoreCursorPosX, restoreCursorPosY;\n    // The window whose disabled cursor mode is active\n    _GLFWwindow*        disabledCursorWindow;\n\n    struct {\n        CFBundleRef     bundle;\n        PFN_TISCopyCurrentKeyboardLayoutInputSource CopyCurrentKeyboardLayoutInputSource;\n        PFN_TISGetInputSourceProperty GetInputSourceProperty;\n        PFN_LMGetKbdType GetKbdType;\n        CFStringRef     kPropertyUnicodeKeyLayoutData;\n    } tis;\n\n} _GLFWlibraryNS;\n\n// Cocoa-specific per-monitor data\n//\ntypedef struct _GLFWmonitorNS\n{\n    CGDirectDisplayID   displayID;\n    CGDisplayModeRef    previousMode;\n    uint32_t            unitNumber;\n    id                  screen;\n\n} _GLFWmonitorNS;\n\n// Cocoa-specific per-cursor data\n//\ntypedef struct _GLFWcursorNS\n{\n    id              object;\n\n} _GLFWcursorNS;\n\n// Cocoa-specific global timer data\n//\ntypedef struct _GLFWtimerNS\n{\n    uint64_t        frequency;\n\n} _GLFWtimerNS;\n\n\nvoid _glfwInitTimerNS(void);\n\nvoid _glfwPollMonitorsNS(void);\nvoid _glfwSetVideoModeNS(_GLFWmonitor* monitor, const GLFWvidmode* desired);\nvoid _glfwRestoreVideoModeNS(_GLFWmonitor* monitor);\n",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/glfw/osmesa_context.c": "//========================================================================\n// GLFW 3.3 OSMesa - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2016 Google Inc.\n// Copyright (c) 2006-2016 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"internal.h\"\n\n\nstatic void makeContextCurrentOSMesa(_GLFWwindow* window)\n{\n    if (window)\n    {\n        int width, height;\n        _glfwPlatformGetFramebufferSize(window, &width, &height);\n\n        // Check to see if we need to allocate a new buffer\n        if ((window->context.osmesa.buffer == NULL) ||\n            (width != window->context.osmesa.width) ||\n            (height != window->context.osmesa.height))\n        {\n            free(window->context.osmesa.buffer);\n\n            // Allocate the new buffer (width * height * 8-bit RGBA)\n            window->context.osmesa.buffer = calloc(4, width * height);\n            window->context.osmesa.width  = width;\n            window->context.osmesa.height = height;\n        }\n\n        if (!OSMesaMakeCurrent(window->context.osmesa.handle,\n                               window->context.osmesa.buffer,\n                               GL_UNSIGNED_BYTE,\n                               width, height))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"OSMesa: Failed to make context current\");\n            return;\n        }\n    }\n\n    _glfwPlatformSetTls(&_glfw.contextSlot, window);\n}\n\nstatic GLFWglproc getProcAddressOSMesa(const char* procname)\n{\n    return (GLFWglproc) OSMesaGetProcAddress(procname);\n}\n\nstatic void destroyContextOSMesa(_GLFWwindow* window)\n{\n    if (window->context.osmesa.handle)\n    {\n        OSMesaDestroyContext(window->context.osmesa.handle);\n        window->context.osmesa.handle = NULL;\n    }\n\n    if (window->context.osmesa.buffer)\n    {\n        free(window->context.osmesa.buffer);\n        window->context.osmesa.width = 0;\n        window->context.osmesa.height = 0;\n    }\n}\n\nstatic void swapBuffersOSMesa(_GLFWwindow* window)\n{\n    // No double buffering on OSMesa\n}\n\nstatic void swapIntervalOSMesa(int interval)\n{\n    // No swap interval on OSMesa\n}\n\nstatic int extensionSupportedOSMesa(const char* extension)\n{\n    // OSMesa does not have extensions\n    return GLFW_FALSE;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWbool _glfwInitOSMesa(void)\n{\n    int i;\n    const char* sonames[] =\n    {\n#if defined(_GLFW_OSMESA_LIBRARY)\n        _GLFW_OSMESA_LIBRARY,\n#elif defined(_WIN32)\n        \"libOSMesa.dll\",\n        \"OSMesa.dll\",\n#elif defined(__APPLE__)\n        \"libOSMesa.8.dylib\",\n#elif defined(__CYGWIN__)\n        \"libOSMesa-8.so\",\n#else\n        \"libOSMesa.so.8\",\n        \"libOSMesa.so.6\",\n#endif\n        NULL\n    };\n\n    if (_glfw.osmesa.handle)\n        return GLFW_TRUE;\n\n    for (i = 0;  sonames[i];  i++)\n    {\n        _glfw.osmesa.handle = _glfw_dlopen(sonames[i]);\n        if (_glfw.osmesa.handle)\n            break;\n    }\n\n    if (!_glfw.osmesa.handle)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"OSMesa: Library not found\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.osmesa.CreateContextExt = (PFN_OSMesaCreateContextExt)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaCreateContextExt\");\n    _glfw.osmesa.CreateContextAttribs = (PFN_OSMesaCreateContextAttribs)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaCreateContextAttribs\");\n    _glfw.osmesa.DestroyContext = (PFN_OSMesaDestroyContext)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaDestroyContext\");\n    _glfw.osmesa.MakeCurrent = (PFN_OSMesaMakeCurrent)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaMakeCurrent\");\n    _glfw.osmesa.GetColorBuffer = (PFN_OSMesaGetColorBuffer)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaGetColorBuffer\");\n    _glfw.osmesa.GetDepthBuffer = (PFN_OSMesaGetDepthBuffer)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaGetDepthBuffer\");\n    _glfw.osmesa.GetProcAddress = (PFN_OSMesaGetProcAddress)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaGetProcAddress\");\n\n    if (!_glfw.osmesa.CreateContextExt ||\n        !_glfw.osmesa.DestroyContext ||\n        !_glfw.osmesa.MakeCurrent ||\n        !_glfw.osmesa.GetColorBuffer ||\n        !_glfw.osmesa.GetDepthBuffer ||\n        !_glfw.osmesa.GetProcAddress)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"OSMesa: Failed to load required entry points\");\n\n        _glfwTerminateOSMesa();\n        return GLFW_FALSE;\n    }\n\n    return GLFW_TRUE;\n}\n\nvoid _glfwTerminateOSMesa(void)\n{\n    if (_glfw.osmesa.handle)\n    {\n        _glfw_dlclose(_glfw.osmesa.handle);\n        _glfw.osmesa.handle = NULL;\n    }\n}\n\n#define setAttrib(a, v) \\\n{ \\\n    assert((size_t) (index + 1) < sizeof(attribs) / sizeof(attribs[0])); \\\n    attribs[index++] = a; \\\n    attribs[index++] = v; \\\n}\n\nGLFWbool _glfwCreateContextOSMesa(_GLFWwindow* window,\n                                  const _GLFWctxconfig* ctxconfig,\n                                  const _GLFWfbconfig* fbconfig)\n{\n    OSMesaContext share = NULL;\n    const int accumBits = fbconfig->accumRedBits +\n                          fbconfig->accumGreenBits +\n                          fbconfig->accumBlueBits +\n                          fbconfig->accumAlphaBits;\n\n    if (ctxconfig->client == GLFW_OPENGL_ES_API)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"OSMesa: OpenGL ES is not available on OSMesa\");\n        return GLFW_FALSE;\n    }\n\n    if (ctxconfig->share)\n        share = ctxconfig->share->context.osmesa.handle;\n\n    if (OSMesaCreateContextAttribs)\n    {\n        int index = 0, attribs[40];\n\n        setAttrib(OSMESA_FORMAT, OSMESA_RGBA);\n        setAttrib(OSMESA_DEPTH_BITS, fbconfig->depthBits);\n        setAttrib(OSMESA_STENCIL_BITS, fbconfig->stencilBits);\n        setAttrib(OSMESA_ACCUM_BITS, accumBits);\n\n        if (ctxconfig->profile == GLFW_OPENGL_CORE_PROFILE)\n        {\n            setAttrib(OSMESA_PROFILE, OSMESA_CORE_PROFILE);\n        }\n        else if (ctxconfig->profile == GLFW_OPENGL_COMPAT_PROFILE)\n        {\n            setAttrib(OSMESA_PROFILE, OSMESA_COMPAT_PROFILE);\n        }\n\n        if (ctxconfig->major != 1 || ctxconfig->minor != 0)\n        {\n            setAttrib(OSMESA_CONTEXT_MAJOR_VERSION, ctxconfig->major);\n            setAttrib(OSMESA_CONTEXT_MINOR_VERSION, ctxconfig->minor);\n        }\n\n        if (ctxconfig->forward)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"OSMesa: Foward-compatible contexts not supported\");\n            return GLFW_FALSE;\n        }\n\n        setAttrib(0, 0);\n\n        window->context.osmesa.handle =\n            OSMesaCreateContextAttribs(attribs, share);\n    }\n    else\n    {\n        if (ctxconfig->profile)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"OSMesa: OpenGL profiles unavailable\");\n            return GLFW_FALSE;\n        }\n\n        window->context.osmesa.handle =\n            OSMesaCreateContextExt(OSMESA_RGBA,\n                                   fbconfig->depthBits,\n                                   fbconfig->stencilBits,\n                                   accumBits,\n                                   share);\n    }\n\n    if (window->context.osmesa.handle == NULL)\n    {\n        _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                        \"OSMesa: Failed to create context\");\n        return GLFW_FALSE;\n    }\n\n    window->context.makeCurrent = makeContextCurrentOSMesa;\n    window->context.swapBuffers = swapBuffersOSMesa;\n    window->context.swapInterval = swapIntervalOSMesa;\n    window->context.extensionSupported = extensionSupportedOSMesa;\n    window->context.getProcAddress = getProcAddressOSMesa;\n    window->context.destroy = destroyContextOSMesa;\n\n    return GLFW_TRUE;\n}\n\n#undef setAttrib\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI int glfwGetOSMesaColorBuffer(GLFWwindow* handle, int* width,\n                                     int* height, int* format, void** buffer)\n{\n    void* mesaBuffer;\n    GLint mesaWidth, mesaHeight, mesaFormat;\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    assert(window != NULL);\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(GLFW_FALSE);\n\n    if (!OSMesaGetColorBuffer(window->context.osmesa.handle,\n                              &mesaWidth, &mesaHeight,\n                              &mesaFormat, &mesaBuffer))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"OSMesa: Failed to retrieve color buffer\");\n        return GLFW_FALSE;\n    }\n\n    if (width)\n        *width = mesaWidth;\n    if (height)\n        *height = mesaHeight;\n    if (format)\n        *format = mesaFormat;\n    if (buffer)\n        *buffer = mesaBuffer;\n\n    return GLFW_TRUE;\n}\n\nGLFWAPI int glfwGetOSMesaDepthBuffer(GLFWwindow* handle,\n                                     int* width, int* height,\n                                     int* bytesPerValue,\n                                     void** buffer)\n{\n    void* mesaBuffer;\n    GLint mesaWidth, mesaHeight, mesaBytes;\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    assert(window != NULL);\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(GLFW_FALSE);\n\n    if (!OSMesaGetDepthBuffer(window->context.osmesa.handle,\n                              &mesaWidth, &mesaHeight,\n                              &mesaBytes, &mesaBuffer))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"OSMesa: Failed to retrieve depth buffer\");\n        return GLFW_FALSE;\n    }\n\n    if (width)\n        *width = mesaWidth;\n    if (height)\n        *height = mesaHeight;\n    if (bytesPerValue)\n        *bytesPerValue = mesaBytes;\n    if (buffer)\n        *buffer = mesaBuffer;\n\n    return GLFW_TRUE;\n}\n\nGLFWAPI OSMesaContext glfwGetOSMesaContext(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n\n    if (window->context.client == GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);\n        return NULL;\n    }\n\n    return window->context.osmesa.handle;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/glfw/wl_platform.h": "//========================================================================\n// GLFW 3.3 Wayland - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2014 Jonas \u00c5dahl <jadahl@gmail.com>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include <wayland-client.h>\n#include <dlfcn.h>\n#include <poll.h>\n\ntypedef VkFlags VkWaylandSurfaceCreateFlagsKHR;\n\ntypedef struct VkWaylandSurfaceCreateInfoKHR\n{\n    VkStructureType                 sType;\n    const void*                     pNext;\n    VkWaylandSurfaceCreateFlagsKHR  flags;\n    struct wl_display*              display;\n    struct wl_surface*              surface;\n} VkWaylandSurfaceCreateInfoKHR;\n\ntypedef VkResult (APIENTRY *PFN_vkCreateWaylandSurfaceKHR)(VkInstance,const VkWaylandSurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);\ntypedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice,uint32_t,struct wl_display*);\n\n#include \"posix_thread.h\"\n#include \"posix_time.h\"\n#ifdef __linux__\n#include \"linux_joystick.h\"\n#else\n#include \"null_joystick.h\"\n#endif\n#include \"xkb_glfw.h\"\n#include \"egl_context.h\"\n#include \"osmesa_context.h\"\n\n#include \"wayland-xdg-shell-client-protocol.h\"\n#include \"wayland-viewporter-client-protocol.h\"\n#include \"wayland-relative-pointer-unstable-v1-client-protocol.h\"\n#include \"wayland-pointer-constraints-unstable-v1-client-protocol.h\"\n#include \"wayland-idle-inhibit-unstable-v1-client-protocol.h\"\n\n#define _glfw_dlopen(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL)\n#define _glfw_dlclose(handle) dlclose(handle)\n#define _glfw_dlsym(handle, name) dlsym(handle, name)\n\n#define _GLFW_EGL_NATIVE_WINDOW         ((EGLNativeWindowType) window->wl.native)\n#define _GLFW_EGL_NATIVE_DISPLAY        ((EGLNativeDisplayType) _glfw.wl.display)\n\n#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowWayland  wl\n#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryWayland wl\n#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorWayland wl\n#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorWayland  wl\n\n#define _GLFW_PLATFORM_CONTEXT_STATE\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE\n\nstruct wl_cursor_image {\n    uint32_t width;\n    uint32_t height;\n    uint32_t hotspot_x;\n    uint32_t hotspot_y;\n    uint32_t delay;\n};\nstruct wl_cursor {\n    unsigned int image_count;\n    struct wl_cursor_image** images;\n    char* name;\n};\ntypedef struct wl_cursor_theme* (* PFN_wl_cursor_theme_load)(const char*, int, struct wl_shm*);\ntypedef void (* PFN_wl_cursor_theme_destroy)(struct wl_cursor_theme*);\ntypedef struct wl_cursor* (* PFN_wl_cursor_theme_get_cursor)(struct wl_cursor_theme*, const char*);\ntypedef struct wl_buffer* (* PFN_wl_cursor_image_get_buffer)(struct wl_cursor_image*);\n#define wl_cursor_theme_load _glfw.wl.cursor.theme_load\n#define wl_cursor_theme_destroy _glfw.wl.cursor.theme_destroy\n#define wl_cursor_theme_get_cursor _glfw.wl.cursor.theme_get_cursor\n#define wl_cursor_image_get_buffer _glfw.wl.cursor.image_get_buffer\n\ntypedef struct wl_egl_window* (* PFN_wl_egl_window_create)(struct wl_surface*, int, int);\ntypedef void (* PFN_wl_egl_window_destroy)(struct wl_egl_window*);\ntypedef void (* PFN_wl_egl_window_resize)(struct wl_egl_window*, int, int, int, int);\n#define wl_egl_window_create _glfw.wl.egl.window_create\n#define wl_egl_window_destroy _glfw.wl.egl.window_destroy\n#define wl_egl_window_resize _glfw.wl.egl.window_resize\n\n#define _GLFW_DECORATION_WIDTH 4\n#define _GLFW_DECORATION_TOP 24\n#define _GLFW_DECORATION_VERTICAL (_GLFW_DECORATION_TOP + _GLFW_DECORATION_WIDTH)\n#define _GLFW_DECORATION_HORIZONTAL (2 * _GLFW_DECORATION_WIDTH)\n\ntypedef enum _GLFWdecorationSideWayland\n{\n    mainWindow,\n    topDecoration,\n    leftDecoration,\n    rightDecoration,\n    bottomDecoration,\n\n} _GLFWdecorationSideWayland;\n\ntypedef struct _GLFWdecorationWayland\n{\n    struct wl_surface*          surface;\n    struct wl_subsurface*       subsurface;\n    struct wp_viewport*         viewport;\n\n} _GLFWdecorationWayland;\n\n// Wayland-specific per-window data\n//\ntypedef struct _GLFWwindowWayland\n{\n    int                         width, height;\n    GLFWbool                    visible;\n    GLFWbool                    maximized;\n    GLFWbool                    hovered;\n    GLFWbool                    transparent;\n    struct wl_surface*          surface;\n    struct wl_egl_window*       native;\n    struct wl_shell_surface*    shellSurface;\n    struct wl_callback*         callback;\n\n    struct {\n        struct xdg_surface*     surface;\n        struct xdg_toplevel*    toplevel;\n    } xdg;\n\n    _GLFWcursor*                currentCursor;\n    double                      cursorPosX, cursorPosY;\n\n    char*                       title;\n\n    // We need to track the monitors the window spans on to calculate the\n    // optimal scaling factor.\n    int                         scale;\n    _GLFWmonitor**              monitors;\n    int                         monitorsCount;\n    int                         monitorsSize;\n\n    struct {\n        struct zwp_relative_pointer_v1*    relativePointer;\n        struct zwp_locked_pointer_v1*      lockedPointer;\n    } pointerLock;\n\n    struct zwp_idle_inhibitor_v1*          idleInhibitor;\n\n    // This is a hack to prevent auto-iconification on creation.\n    GLFWbool                    justCreated;\n\n    struct {\n        struct wl_buffer*                  buffer;\n        _GLFWdecorationWayland             top, left, right, bottom;\n        int                                focus;\n    } decorations;\n\n} _GLFWwindowWayland;\n\n// Wayland-specific global data\n//\ntypedef struct _GLFWlibraryWayland\n{\n    struct wl_display*          display;\n    struct wl_registry*         registry;\n    struct wl_compositor*       compositor;\n    struct wl_subcompositor*    subcompositor;\n    struct wl_shell*            shell;\n    struct wl_shm*              shm;\n    struct wl_seat*             seat;\n    struct wl_pointer*          pointer;\n    struct wl_keyboard*         keyboard;\n    struct xdg_wm_base*         wmBase;\n    struct wp_viewporter*       viewporter;\n    struct zwp_relative_pointer_manager_v1* relativePointerManager;\n    struct zwp_pointer_constraints_v1*      pointerConstraints;\n    struct zwp_idle_inhibit_manager_v1*     idleInhibitManager;\n\n    int                         compositorVersion;\n    int                         seatVersion;\n\n    struct wl_cursor_theme*     cursorTheme;\n    struct wl_surface*          cursorSurface;\n    uint32_t                    pointerSerial;\n\n    int32_t                     keyboardRepeatRate;\n    int32_t                     keyboardRepeatDelay;\n    struct {\n        uint32_t                key;\n        double                  nextRepeatAt;\n        _GLFWwindow*            keyboardFocus;\n    } keyRepeatInfo;\n    _GLFWXKBData                xkb;\n\n    _GLFWwindow*                pointerFocus;\n    _GLFWwindow*                keyboardFocus;\n\n    struct {\n        void*                   handle;\n\n        PFN_wl_cursor_theme_load theme_load;\n        PFN_wl_cursor_theme_destroy theme_destroy;\n        PFN_wl_cursor_theme_get_cursor theme_get_cursor;\n        PFN_wl_cursor_image_get_buffer image_get_buffer;\n    } cursor;\n\n    struct {\n        void*                   handle;\n\n        PFN_wl_egl_window_create window_create;\n        PFN_wl_egl_window_destroy window_destroy;\n        PFN_wl_egl_window_resize window_resize;\n    } egl;\n\n    struct {\n        struct pollfd fds[2];\n        int wakeupFds[2];\n    } eventLoopData;\n\n} _GLFWlibraryWayland;\n\n// Wayland-specific per-monitor data\n//\ntypedef struct _GLFWmonitorWayland\n{\n    struct wl_output*           output;\n    int                         name;\n    int                         currentMode;\n\n    int                         x;\n    int                         y;\n    int                         scale;\n\n} _GLFWmonitorWayland;\n\n// Wayland-specific per-cursor data\n//\ntypedef struct _GLFWcursorWayland\n{\n    struct wl_cursor_image*     image;\n    struct wl_buffer*           buffer;\n    int                         width, height;\n    int                         xhot, yhot;\n} _GLFWcursorWayland;\n\n\nvoid _glfwAddOutputWayland(uint32_t name, uint32_t version);\n",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/glfw/wl_init.c": "//========================================================================\n// GLFW 3.3 Wayland - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2014 Jonas \u00c5dahl <jadahl@gmail.com>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#define _GNU_SOURCE\n#include \"internal.h\"\n#include \"backend_utils.h\"\n\n#include <assert.h>\n#include <linux/input.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <wayland-client.h>\n\n\nstatic inline int min(int n1, int n2)\n{\n    return n1 < n2 ? n1 : n2;\n}\n\nstatic _GLFWwindow* findWindowFromDecorationSurface(struct wl_surface* surface, int* which)\n{\n    int focus;\n    _GLFWwindow* window = _glfw.windowListHead;\n    if (!which)\n        which = &focus;\n    while (window)\n    {\n        if (surface == window->wl.decorations.top.surface)\n        {\n            *which = topDecoration;\n            break;\n        }\n        if (surface == window->wl.decorations.left.surface)\n        {\n            *which = leftDecoration;\n            break;\n        }\n        if (surface == window->wl.decorations.right.surface)\n        {\n            *which = rightDecoration;\n            break;\n        }\n        if (surface == window->wl.decorations.bottom.surface)\n        {\n            *which = bottomDecoration;\n            break;\n        }\n        window = window->next;\n    }\n    return window;\n}\n\nstatic void pointerHandleEnter(void* data,\n                               struct wl_pointer* pointer,\n                               uint32_t serial,\n                               struct wl_surface* surface,\n                               wl_fixed_t sx,\n                               wl_fixed_t sy)\n{\n    // Happens in the case we just destroyed the surface.\n    if (!surface)\n        return;\n\n    int focus = 0;\n    _GLFWwindow* window = wl_surface_get_user_data(surface);\n    if (!window)\n    {\n        window = findWindowFromDecorationSurface(surface, &focus);\n        if (!window)\n            return;\n    }\n\n    window->wl.decorations.focus = focus;\n    _glfw.wl.pointerSerial = serial;\n    _glfw.wl.pointerFocus = window;\n\n    window->wl.hovered = GLFW_TRUE;\n\n    _glfwPlatformSetCursor(window, window->wl.currentCursor);\n    _glfwInputCursorEnter(window, GLFW_TRUE);\n}\n\nstatic void pointerHandleLeave(void* data,\n                               struct wl_pointer* pointer,\n                               uint32_t serial,\n                               struct wl_surface* surface)\n{\n    _GLFWwindow* window = _glfw.wl.pointerFocus;\n\n    if (!window)\n        return;\n\n    window->wl.hovered = GLFW_FALSE;\n\n    _glfw.wl.pointerSerial = serial;\n    _glfw.wl.pointerFocus = NULL;\n    _glfwInputCursorEnter(window, GLFW_FALSE);\n}\n\nstatic void setCursor(const char* name)\n{\n    struct wl_buffer* buffer;\n    struct wl_cursor* cursor;\n    struct wl_cursor_image* image;\n    struct wl_surface* surface = _glfw.wl.cursorSurface;\n\n    cursor = wl_cursor_theme_get_cursor(_glfw.wl.cursorTheme,\n                                        name);\n    if (!cursor)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Wayland: Standard cursor not found\");\n        return;\n    }\n    image = cursor->images[0];\n\n    if (!image)\n        return;\n\n    buffer = wl_cursor_image_get_buffer(image);\n    if (!buffer)\n        return;\n    wl_pointer_set_cursor(_glfw.wl.pointer, _glfw.wl.pointerSerial,\n                          surface,\n                          image->hotspot_x,\n                          image->hotspot_y);\n    wl_surface_attach(surface, buffer, 0, 0);\n    wl_surface_damage(surface, 0, 0,\n                      image->width, image->height);\n    wl_surface_commit(surface);\n}\n\nstatic void pointerHandleMotion(void* data,\n                                struct wl_pointer* pointer,\n                                uint32_t time,\n                                wl_fixed_t sx,\n                                wl_fixed_t sy)\n{\n    _GLFWwindow* window = _glfw.wl.pointerFocus;\n    const char* cursorName;\n\n    if (!window)\n        return;\n\n    if (window->cursorMode == GLFW_CURSOR_DISABLED)\n        return;\n    else\n    {\n        window->wl.cursorPosX = wl_fixed_to_double(sx);\n        window->wl.cursorPosY = wl_fixed_to_double(sy);\n    }\n\n    switch (window->wl.decorations.focus)\n    {\n        case mainWindow:\n            _glfwInputCursorPos(window,\n                                wl_fixed_to_double(sx),\n                                wl_fixed_to_double(sy));\n            return;\n        case topDecoration:\n            if (window->wl.cursorPosY < _GLFW_DECORATION_WIDTH)\n                cursorName = \"n-resize\";\n            else\n                cursorName = \"left_ptr\";\n            break;\n        case leftDecoration:\n            if (window->wl.cursorPosY < _GLFW_DECORATION_WIDTH)\n                cursorName = \"nw-resize\";\n            else\n                cursorName = \"w-resize\";\n            break;\n        case rightDecoration:\n            if (window->wl.cursorPosY < _GLFW_DECORATION_WIDTH)\n                cursorName = \"ne-resize\";\n            else\n                cursorName = \"e-resize\";\n            break;\n        case bottomDecoration:\n            if (window->wl.cursorPosX < _GLFW_DECORATION_WIDTH)\n                cursorName = \"sw-resize\";\n            else if (window->wl.cursorPosX > window->wl.width + _GLFW_DECORATION_WIDTH)\n                cursorName = \"se-resize\";\n            else\n                cursorName = \"s-resize\";\n            break;\n        default:\n            assert(0);\n    }\n    setCursor(cursorName);\n}\n\nstatic void pointerHandleButton(void* data,\n                                struct wl_pointer* pointer,\n                                uint32_t serial,\n                                uint32_t time,\n                                uint32_t button,\n                                uint32_t state)\n{\n    _GLFWwindow* window = _glfw.wl.pointerFocus;\n    int glfwButton;\n\n    // Both xdg-shell and wl_shell use the same values.\n    uint32_t edges = WL_SHELL_SURFACE_RESIZE_NONE;\n\n    if (!window)\n        return;\n    if (button == BTN_LEFT)\n    {\n        switch (window->wl.decorations.focus)\n        {\n            case mainWindow:\n                break;\n            case topDecoration:\n                if (window->wl.cursorPosY < _GLFW_DECORATION_WIDTH)\n                    edges = WL_SHELL_SURFACE_RESIZE_TOP;\n                else\n                {\n                    if (window->wl.xdg.toplevel)\n                        xdg_toplevel_move(window->wl.xdg.toplevel, _glfw.wl.seat, serial);\n                    else\n                        wl_shell_surface_move(window->wl.shellSurface, _glfw.wl.seat, serial);\n                }\n                break;\n            case leftDecoration:\n                if (window->wl.cursorPosY < _GLFW_DECORATION_WIDTH)\n                    edges = WL_SHELL_SURFACE_RESIZE_TOP_LEFT;\n                else\n                    edges = WL_SHELL_SURFACE_RESIZE_LEFT;\n                break;\n            case rightDecoration:\n                if (window->wl.cursorPosY < _GLFW_DECORATION_WIDTH)\n                    edges = WL_SHELL_SURFACE_RESIZE_TOP_RIGHT;\n                else\n                    edges = WL_SHELL_SURFACE_RESIZE_RIGHT;\n                break;\n            case bottomDecoration:\n                if (window->wl.cursorPosX < _GLFW_DECORATION_WIDTH)\n                    edges = WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT;\n                else if (window->wl.cursorPosX > window->wl.width + _GLFW_DECORATION_WIDTH)\n                    edges = WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT;\n                else\n                    edges = WL_SHELL_SURFACE_RESIZE_BOTTOM;\n                break;\n            default:\n                assert(0);\n        }\n        if (edges != WL_SHELL_SURFACE_RESIZE_NONE)\n        {\n            if (window->wl.xdg.toplevel)\n                xdg_toplevel_resize(window->wl.xdg.toplevel, _glfw.wl.seat,\n                                    serial, edges);\n            else\n                wl_shell_surface_resize(window->wl.shellSurface, _glfw.wl.seat,\n                                        serial, edges);\n        }\n    }\n    else if (button == BTN_RIGHT)\n    {\n        if (window->wl.decorations.focus != mainWindow && window->wl.xdg.toplevel)\n        {\n            xdg_toplevel_show_window_menu(window->wl.xdg.toplevel,\n                                          _glfw.wl.seat, serial,\n                                          window->wl.cursorPosX,\n                                          window->wl.cursorPosY);\n            return;\n        }\n    }\n\n    // Don\u2019t pass the button to the user if it was related to a decoration.\n    if (window->wl.decorations.focus != mainWindow)\n        return;\n\n    _glfw.wl.pointerSerial = serial;\n\n    /* Makes left, right and middle 0, 1 and 2. Overall order follows evdev\n     * codes. */\n    glfwButton = button - BTN_LEFT;\n\n    _glfwInputMouseClick(window,\n                         glfwButton,\n                         state == WL_POINTER_BUTTON_STATE_PRESSED\n                                ? GLFW_PRESS\n                                : GLFW_RELEASE,\n                         _glfw.wl.xkb.modifiers);\n}\n\nstatic void pointerHandleAxis(void* data,\n                              struct wl_pointer* pointer,\n                              uint32_t time,\n                              uint32_t axis,\n                              wl_fixed_t value)\n{\n    _GLFWwindow* window = _glfw.wl.pointerFocus;\n    double x = 0.0, y = 0.0;\n    // Wayland scroll events are in pointer motion coordinate space (think two\n    // finger scroll).  The factor 10 is commonly used to convert to \"scroll\n    // step means 1.0.\n    const double scrollFactor = 1.0 / 10.0;\n\n    if (!window)\n        return;\n\n    assert(axis == WL_POINTER_AXIS_HORIZONTAL_SCROLL ||\n           axis == WL_POINTER_AXIS_VERTICAL_SCROLL);\n\n    if (axis == WL_POINTER_AXIS_HORIZONTAL_SCROLL)\n        x = wl_fixed_to_double(value) * scrollFactor;\n    else if (axis == WL_POINTER_AXIS_VERTICAL_SCROLL)\n        y = wl_fixed_to_double(value) * scrollFactor;\n\n    _glfwInputScroll(window, x, y);\n}\n\nstatic const struct wl_pointer_listener pointerListener = {\n    pointerHandleEnter,\n    pointerHandleLeave,\n    pointerHandleMotion,\n    pointerHandleButton,\n    pointerHandleAxis,\n};\n\nstatic void keyboardHandleKeymap(void* data,\n                                 struct wl_keyboard* keyboard,\n                                 uint32_t format,\n                                 int fd,\n                                 uint32_t size)\n{\n    char* mapStr;\n\n    if (format != WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1)\n    {\n        close(fd);\n        return;\n    }\n\n    mapStr = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);\n    if (mapStr == MAP_FAILED) {\n        close(fd);\n        return;\n    }\n    glfw_xkb_compile_keymap(&_glfw.wl.xkb, mapStr);\n    munmap(mapStr, size);\n    close(fd);\n\n}\n\nstatic void keyboardHandleEnter(void* data,\n                                struct wl_keyboard* keyboard,\n                                uint32_t serial,\n                                struct wl_surface* surface,\n                                struct wl_array* keys)\n{\n    // Happens in the case we just destroyed the surface.\n    if (!surface)\n        return;\n\n    _GLFWwindow* window = wl_surface_get_user_data(surface);\n    if (!window)\n    {\n        window = findWindowFromDecorationSurface(surface, NULL);\n        if (!window)\n            return;\n    }\n\n    _glfw.wl.keyboardFocus = window;\n    _glfwInputWindowFocus(window, GLFW_TRUE);\n}\n\nstatic void keyboardHandleLeave(void* data,\n                                struct wl_keyboard* keyboard,\n                                uint32_t serial,\n                                struct wl_surface* surface)\n{\n    _GLFWwindow* window = _glfw.wl.keyboardFocus;\n\n    if (!window)\n        return;\n\n    _glfw.wl.keyboardFocus = NULL;\n    _glfwInputWindowFocus(window, GLFW_FALSE);\n}\n\nstatic void keyboardHandleKey(void* data,\n                              struct wl_keyboard* keyboard,\n                              uint32_t serial,\n                              uint32_t time,\n                              uint32_t key,\n                              uint32_t state)\n{\n    _GLFWwindow* window = _glfw.wl.keyboardFocus;\n    if (!window)\n        return;\n    int action = state == WL_KEYBOARD_KEY_STATE_PRESSED ? GLFW_PRESS : GLFW_RELEASE;\n    glfw_xkb_handle_key_event(window, &_glfw.wl.xkb, key, action);\n    _glfw.wl.keyRepeatInfo.nextRepeatAt = 0;\n\n    if (action == GLFW_PRESS && _glfw.wl.keyboardRepeatRate > 0 && glfw_xkb_should_repeat(&_glfw.wl.xkb, key))\n    {\n        _glfw.wl.keyRepeatInfo.key = key;\n        _glfw.wl.keyRepeatInfo.nextRepeatAt = glfwGetTime() + (double)(_glfw.wl.keyboardRepeatDelay) / 1000.0;\n        _glfw.wl.keyRepeatInfo.keyboardFocus = window;\n    }\n}\n\nstatic void keyboardHandleModifiers(void* data,\n                                    struct wl_keyboard* keyboard,\n                                    uint32_t serial,\n                                    uint32_t modsDepressed,\n                                    uint32_t modsLatched,\n                                    uint32_t modsLocked,\n                                    uint32_t group)\n{\n    glfw_xkb_update_modifiers(&_glfw.wl.xkb, modsDepressed, modsLatched, modsLocked, 0, 0, group);\n}\n\nstatic void keyboardHandleRepeatInfo(void* data,\n                                     struct wl_keyboard* keyboard,\n                                     int32_t rate,\n                                     int32_t delay)\n{\n    if (keyboard != _glfw.wl.keyboard)\n        return;\n\n    _glfw.wl.keyboardRepeatRate = rate;\n    _glfw.wl.keyboardRepeatDelay = delay;\n}\n\nstatic const struct wl_keyboard_listener keyboardListener = {\n    keyboardHandleKeymap,\n    keyboardHandleEnter,\n    keyboardHandleLeave,\n    keyboardHandleKey,\n    keyboardHandleModifiers,\n    keyboardHandleRepeatInfo,\n};\n\nstatic void seatHandleCapabilities(void* data,\n                                   struct wl_seat* seat,\n                                   enum wl_seat_capability caps)\n{\n    if ((caps & WL_SEAT_CAPABILITY_POINTER) && !_glfw.wl.pointer)\n    {\n        _glfw.wl.pointer = wl_seat_get_pointer(seat);\n        wl_pointer_add_listener(_glfw.wl.pointer, &pointerListener, NULL);\n    }\n    else if (!(caps & WL_SEAT_CAPABILITY_POINTER) && _glfw.wl.pointer)\n    {\n        wl_pointer_destroy(_glfw.wl.pointer);\n        _glfw.wl.pointer = NULL;\n    }\n\n    if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !_glfw.wl.keyboard)\n    {\n        _glfw.wl.keyboard = wl_seat_get_keyboard(seat);\n        wl_keyboard_add_listener(_glfw.wl.keyboard, &keyboardListener, NULL);\n    }\n    else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && _glfw.wl.keyboard)\n    {\n        wl_keyboard_destroy(_glfw.wl.keyboard);\n        _glfw.wl.keyboard = NULL;\n    }\n}\n\nstatic void seatHandleName(void* data,\n                           struct wl_seat* seat,\n                           const char* name)\n{\n}\n\nstatic const struct wl_seat_listener seatListener = {\n    seatHandleCapabilities,\n    seatHandleName,\n};\n\nstatic void wmBaseHandlePing(void* data,\n                             struct xdg_wm_base* wmBase,\n                             uint32_t serial)\n{\n    xdg_wm_base_pong(wmBase, serial);\n}\n\nstatic const struct xdg_wm_base_listener wmBaseListener = {\n    wmBaseHandlePing\n};\n\nstatic void registryHandleGlobal(void* data,\n                                 struct wl_registry* registry,\n                                 uint32_t name,\n                                 const char* interface,\n                                 uint32_t version)\n{\n    if (strcmp(interface, \"wl_compositor\") == 0)\n    {\n        _glfw.wl.compositorVersion = min(3, version);\n        _glfw.wl.compositor =\n            wl_registry_bind(registry, name, &wl_compositor_interface,\n                             _glfw.wl.compositorVersion);\n    }\n    else if (strcmp(interface, \"wl_subcompositor\") == 0)\n    {\n        _glfw.wl.subcompositor =\n            wl_registry_bind(registry, name, &wl_subcompositor_interface, 1);\n    }\n    else if (strcmp(interface, \"wl_shm\") == 0)\n    {\n        _glfw.wl.shm =\n            wl_registry_bind(registry, name, &wl_shm_interface, 1);\n    }\n    else if (strcmp(interface, \"wl_shell\") == 0)\n    {\n        _glfw.wl.shell =\n            wl_registry_bind(registry, name, &wl_shell_interface, 1);\n    }\n    else if (strcmp(interface, \"wl_output\") == 0)\n    {\n        _glfwAddOutputWayland(name, version);\n    }\n    else if (strcmp(interface, \"wl_seat\") == 0)\n    {\n        if (!_glfw.wl.seat)\n        {\n            _glfw.wl.seatVersion = min(4, version);\n            _glfw.wl.seat =\n                wl_registry_bind(registry, name, &wl_seat_interface,\n                                 _glfw.wl.seatVersion);\n            wl_seat_add_listener(_glfw.wl.seat, &seatListener, NULL);\n        }\n    }\n    else if (strcmp(interface, \"xdg_wm_base\") == 0)\n    {\n        _glfw.wl.wmBase =\n            wl_registry_bind(registry, name, &xdg_wm_base_interface, 1);\n        xdg_wm_base_add_listener(_glfw.wl.wmBase, &wmBaseListener, NULL);\n    }\n    else if (strcmp(interface, \"wp_viewporter\") == 0)\n    {\n        _glfw.wl.viewporter =\n            wl_registry_bind(registry, name, &wp_viewporter_interface, 1);\n    }\n    else if (strcmp(interface, \"zwp_relative_pointer_manager_v1\") == 0)\n    {\n        _glfw.wl.relativePointerManager =\n            wl_registry_bind(registry, name,\n                             &zwp_relative_pointer_manager_v1_interface,\n                             1);\n    }\n    else if (strcmp(interface, \"zwp_pointer_constraints_v1\") == 0)\n    {\n        _glfw.wl.pointerConstraints =\n            wl_registry_bind(registry, name,\n                             &zwp_pointer_constraints_v1_interface,\n                             1);\n    }\n    else if (strcmp(interface, \"zwp_idle_inhibit_manager_v1\") == 0)\n    {\n        _glfw.wl.idleInhibitManager =\n            wl_registry_bind(registry, name,\n                             &zwp_idle_inhibit_manager_v1_interface,\n                             1);\n    }\n}\n\nstatic void registryHandleGlobalRemove(void *data,\n                                       struct wl_registry *registry,\n                                       uint32_t name)\n{\n    int i;\n    _GLFWmonitor* monitor;\n\n    for (i = 0; i < _glfw.monitorCount; ++i)\n    {\n        monitor = _glfw.monitors[i];\n        if (monitor->wl.name == name)\n        {\n            _glfwInputMonitor(monitor, GLFW_DISCONNECTED, 0);\n            return;\n        }\n    }\n}\n\n\nstatic const struct wl_registry_listener registryListener = {\n    registryHandleGlobal,\n    registryHandleGlobalRemove\n};\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nint _glfwPlatformInit(void)\n{\n    if (pipe2(_glfw.wl.eventLoopData.wakeupFds, O_CLOEXEC | O_NONBLOCK) != 0)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                \"Wayland: failed to create self pipe\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.wl.cursor.handle = _glfw_dlopen(\"libwayland-cursor.so.0\");\n    if (!_glfw.wl.cursor.handle)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Wayland: Failed to open libwayland-cursor\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.wl.cursor.theme_load = (PFN_wl_cursor_theme_load)\n        _glfw_dlsym(_glfw.wl.cursor.handle, \"wl_cursor_theme_load\");\n    _glfw.wl.cursor.theme_destroy = (PFN_wl_cursor_theme_destroy)\n        _glfw_dlsym(_glfw.wl.cursor.handle, \"wl_cursor_theme_destroy\");\n    _glfw.wl.cursor.theme_get_cursor = (PFN_wl_cursor_theme_get_cursor)\n        _glfw_dlsym(_glfw.wl.cursor.handle, \"wl_cursor_theme_get_cursor\");\n    _glfw.wl.cursor.image_get_buffer = (PFN_wl_cursor_image_get_buffer)\n        _glfw_dlsym(_glfw.wl.cursor.handle, \"wl_cursor_image_get_buffer\");\n\n    _glfw.wl.egl.handle = _glfw_dlopen(\"libwayland-egl.so.1\");\n    if (!_glfw.wl.egl.handle)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Wayland: Failed to open libwayland-egl\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.wl.egl.window_create = (PFN_wl_egl_window_create)\n        _glfw_dlsym(_glfw.wl.egl.handle, \"wl_egl_window_create\");\n    _glfw.wl.egl.window_destroy = (PFN_wl_egl_window_destroy)\n        _glfw_dlsym(_glfw.wl.egl.handle, \"wl_egl_window_destroy\");\n    _glfw.wl.egl.window_resize = (PFN_wl_egl_window_resize)\n        _glfw_dlsym(_glfw.wl.egl.handle, \"wl_egl_window_resize\");\n\n    _glfw.wl.display = wl_display_connect(NULL);\n    if (!_glfw.wl.display)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Wayland: Failed to connect to display\");\n        return GLFW_FALSE;\n    }\n    initPollData(_glfw.wl.eventLoopData.fds, _glfw.wl.eventLoopData.wakeupFds[0], wl_display_get_fd(_glfw.wl.display));\n\n    _glfw.wl.registry = wl_display_get_registry(_glfw.wl.display);\n    wl_registry_add_listener(_glfw.wl.registry, &registryListener, NULL);\n\n    if (!glfw_xkb_create_context(&_glfw.wl.xkb)) return GLFW_FALSE;\n\n    // Sync so we got all registry objects\n    wl_display_roundtrip(_glfw.wl.display);\n\n    // Sync so we got all initial output events\n    wl_display_roundtrip(_glfw.wl.display);\n\n#ifdef __linux__\n    if (!_glfwInitJoysticksLinux())\n        return GLFW_FALSE;\n#endif\n\n    _glfwInitTimerPOSIX();\n\n    if (_glfw.wl.pointer && _glfw.wl.shm)\n    {\n        _glfw.wl.cursorTheme = wl_cursor_theme_load(NULL, 32, _glfw.wl.shm);\n        if (!_glfw.wl.cursorTheme)\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"Wayland: Unable to load default cursor theme\");\n            return GLFW_FALSE;\n        }\n        _glfw.wl.cursorSurface =\n            wl_compositor_create_surface(_glfw.wl.compositor);\n    }\n\n    return GLFW_TRUE;\n}\n\nvoid _glfwPlatformTerminate(void)\n{\n#ifdef __linux__\n    _glfwTerminateJoysticksLinux();\n#endif\n    _glfwTerminateEGL();\n    if (_glfw.wl.egl.handle)\n    {\n        _glfw_dlclose(_glfw.wl.egl.handle);\n        _glfw.wl.egl.handle = NULL;\n    }\n\n    glfw_xkb_release(&_glfw.wl.xkb);\n\n    if (_glfw.wl.cursorTheme)\n        wl_cursor_theme_destroy(_glfw.wl.cursorTheme);\n    if (_glfw.wl.cursor.handle)\n    {\n        _glfw_dlclose(_glfw.wl.cursor.handle);\n        _glfw.wl.cursor.handle = NULL;\n    }\n\n    if (_glfw.wl.cursorSurface)\n        wl_surface_destroy(_glfw.wl.cursorSurface);\n    if (_glfw.wl.subcompositor)\n        wl_subcompositor_destroy(_glfw.wl.subcompositor);\n    if (_glfw.wl.compositor)\n        wl_compositor_destroy(_glfw.wl.compositor);\n    if (_glfw.wl.shm)\n        wl_shm_destroy(_glfw.wl.shm);\n    if (_glfw.wl.shell)\n        wl_shell_destroy(_glfw.wl.shell);\n    if (_glfw.wl.viewporter)\n        wp_viewporter_destroy(_glfw.wl.viewporter);\n    if (_glfw.wl.wmBase)\n        xdg_wm_base_destroy(_glfw.wl.wmBase);\n    if (_glfw.wl.pointer)\n        wl_pointer_destroy(_glfw.wl.pointer);\n    if (_glfw.wl.keyboard)\n        wl_keyboard_destroy(_glfw.wl.keyboard);\n    if (_glfw.wl.seat)\n        wl_seat_destroy(_glfw.wl.seat);\n    if (_glfw.wl.relativePointerManager)\n        zwp_relative_pointer_manager_v1_destroy(_glfw.wl.relativePointerManager);\n    if (_glfw.wl.pointerConstraints)\n        zwp_pointer_constraints_v1_destroy(_glfw.wl.pointerConstraints);\n    if (_glfw.wl.idleInhibitManager)\n        zwp_idle_inhibit_manager_v1_destroy(_glfw.wl.idleInhibitManager);\n    if (_glfw.wl.registry)\n        wl_registry_destroy(_glfw.wl.registry);\n    if (_glfw.wl.display)\n    {\n        wl_display_flush(_glfw.wl.display);\n        wl_display_disconnect(_glfw.wl.display);\n    }\n    closeFds(_glfw.wl.eventLoopData.wakeupFds, sizeof(_glfw.wl.eventLoopData.wakeupFds)/sizeof(_glfw.wl.eventLoopData.wakeupFds[0]));\n}\n\nconst char* _glfwPlatformGetVersionString(void)\n{\n    return _GLFW_VERSION_NUMBER \" Wayland EGL\"\n#if defined(_POSIX_TIMERS) && defined(_POSIX_MONOTONIC_CLOCK)\n        \" clock_gettime\"\n#else\n        \" gettimeofday\"\n#endif\n        \" evdev\"\n#if defined(_GLFW_BUILD_DLL)\n        \" shared\"\n#endif\n        ;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/kitty_tests/Lenna.png",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/kitty_tests/LiberationMono-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/kitty_tests/FiraCode-Medium.otf",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/docs/screenshots/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/docs/screenshots/diff.png",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/docs/screenshots/hints_mode.png",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/docs/screenshots/unicode.png",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/docs/screenshots/panel.png",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/logo/kitty.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-kitty-0.11.1-b2lnpfxhpsfqw7nyihfstqt4bcrxb5sy/spack-src/logo/kitty.png"
    ],
    "total_files": 266
}