{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Superstructure/Component/src/ESMCI_MethodTable.C": "// $Id$\n//\n// Earth System Modeling Framework\n// Copyright 2002-2018, University Corporation for Atmospheric Research, \n// Massachusetts Institute of Technology, Geophysical Fluid Dynamics \n// Laboratory, University of Michigan, National Centers for Environmental \n// Prediction, Los Alamos National Laboratory, Argonne National Laboratory, \n// NASA Goddard Space Flight Center.\n// Licensed under the University of Illinois-NCSA License.\n//\n//==============================================================================\n#define ESMC_FILENAME \"ESMCI_MethodTable.C\"\n//==============================================================================\n//\n// ESMCI MethodTable implementation (body) file\n//\n//-----------------------------------------------------------------------------\n//\n// !DESCRIPTION:\n//\n// The code in this file implements the C++ {\\tt MethodTable} methods \n// declared in the companion file {\\tt ESMCI\\_MethodTable.h}.  \n//\n//-----------------------------------------------------------------------------\n// include associated header file\n#include \"ESMCI_MethodTable.h\"\n\n// insert higher level, 3rd party or system includes\n#include <string>\n#include <sstream>\n#ifndef ESMF_NO_DLFCN\n#include <dlfcn.h>\n#endif\n\n// include ESMF headers\n#include \"ESMCI_Macros.h\"\n#include \"ESMCI_LogErr.h\"\n\n//==============================================================================\n//==============================================================================\n// MethodTable class implementation\n//==============================================================================\n//==============================================================================\n\nextern \"C\" {\n\n  // call to native class constructor\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtablecreate\"\n  void FTN_X(c_esmc_methodtablecreate)(ESMCI::MethodTable **ptr, int *rc){\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    (*ptr) = new ESMCI::MethodTable;\n    if (*ptr == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- MethodTable allocation\", ESMC_CONTEXT, \n        rc);  \n      return;\n    }\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // call to native class destructor\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtabledestroy\"\n  void FTN_X(c_esmc_methodtabledestroy)(ESMCI::MethodTable **ptr, int *rc){\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (*ptr == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- MethodTable deallocation\", ESMC_CONTEXT,\n        rc);  \n      return;\n    }\n    delete (*ptr);\n    *ptr = NULL;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtableadd\"\n  void FTN_X(c_esmc_methodtableadd)(ESMCI::MethodTable **ptr,\n    char const *labelArg, int *index, void *pointer, int *rc,\n    ESMCI_FortranStrLenArg labelLen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (labelLen>=0){\n      std::string label(labelArg, labelLen);\n      label.resize(label.find_last_not_of(\" \")+1);\n      if (index){\n        std::stringstream indexString;\n        indexString << \"::ESMF::index::\" << *index;\n        label += indexString.str();\n      }\n      localrc = (*ptr)->add(label, pointer);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- corrupt label string\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    // debugging---------\n//    localrc = (*ptr)->print();\n//    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n//    rc)) \n//      return;\n    // debugging---------\n    \n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtableaddshobj\"\n  void FTN_X(c_esmc_methodtableaddshobj)(ESMCI::MethodTable **ptr,\n    char const *labelArg, int *index, char const *nameArg,\n    char const *sharedObjArg,\n    int *rc, ESMCI_FortranStrLenArg labelLen, ESMCI_FortranStrLenArg nameLen,\n    ESMCI_FortranStrLenArg sharedObjLen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (labelLen>=0){\n      std::string label(labelArg, labelLen);\n      label.resize(label.find_last_not_of(\" \")+1);\n      if (index){\n        std::stringstream indexString;\n        indexString << \"::ESMF::index::\" << *index;\n        label += indexString.str();\n      }\n      std::string name(nameArg, nameLen);\n      name.resize(name.find_last_not_of(\" \")+1);\n      std::string sharedObj(sharedObjArg, sharedObjLen);\n      sharedObj.resize(sharedObj.find_last_not_of(\" \")+1);\n      localrc = (*ptr)->add(label, name, sharedObj);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- corrupt label string\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    // debugging---------\n//    localrc = (*ptr)->print();\n//    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n//    rc)) \n//      return;\n    // debugging---------\n    \n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtableremove\"\n  void FTN_X(c_esmc_methodtableremove)(ESMCI::MethodTable **ptr,\n    char const *labelArg, int *index, int *rc, ESMCI_FortranStrLenArg labelLen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (labelLen>=0){\n      std::string label(labelArg, labelLen);\n      label.resize(label.find_last_not_of(\" \")+1);\n      if (index){\n        std::stringstream indexString;\n        indexString << \"::ESMF::index::\" << *index;\n        label += indexString.str();\n      }\n      localrc = (*ptr)->remove(label);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- corrupt label string\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    // debugging---------\n//    localrc = (*ptr)->print();\n//    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n//    rc)) \n//     return;\n    // debugging---------\n    \n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtableexecute\"\n  void FTN_X(c_esmc_methodtableexecute)(ESMCI::MethodTable **ptr,\n    char const *labelArg, int *index, void *object, int *userRc, int *rc,\n    ESMCI_FortranStrLenArg labelLen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (labelLen>=0){\n      std::string label(labelArg, labelLen);\n      label.resize(label.find_last_not_of(\" \")+1);\n      if (index){\n        std::stringstream indexString;\n        indexString << \"::ESMF::index::\" << *index;\n        label += indexString.str();\n      }\n      localrc = (*ptr)->execute(label, object, userRc);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- corrupt label string\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    // debugging---------\n//    localrc = (*ptr)->print();\n//    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n//    rc)) \n//      return;\n    // debugging---------\n    \n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtableexecuteef\"\n  void FTN_X(c_esmc_methodtableexecuteef)(ESMCI::MethodTable **ptr,\n    char const *labelArg, int *index, void *object, ESMC_Logical *existflag,\n    int *userRc, int *rc,\n    ESMCI_FortranStrLenArg labelLen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (labelLen>=0){\n      bool existing;\n      std::string label(labelArg, labelLen);\n      label.resize(label.find_last_not_of(\" \")+1);\n      if (index){\n        std::stringstream indexString;\n        indexString << \"::ESMF::index::\" << *index;\n        label += indexString.str();\n      }\n      localrc = (*ptr)->execute(label, object, userRc, &existing);\n      if (existing)\n        *existflag = ESMF_TRUE;\n      else\n        *existflag = ESMF_FALSE;\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- corrupt label string\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    // debugging---------\n//    localrc = (*ptr)->print();\n//    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n//    rc)) \n//      return;\n    // debugging---------\n    \n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n} // extern \"C\"\n\n\n\nnamespace ESMCI {\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodElement::print()\"\n  int MethodElement::print(void)const{\n    int rc = ESMC_RC_NOT_IMPL;\n    printf(\"%s\\n\", label.c_str());\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodElement::execute()\"\n  int MethodElement::execute(void *object, int *userRc){\n    int rc = ESMC_RC_NOT_IMPL;\n    if (pointer){\n      typedef void (*FuncP)(void *, int *);\n      FuncP vf = (FuncP)pointer;\n      (*vf)(object, userRc);\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_PTR_NULL,\n        \" - invalid function pointer\", ESMC_CONTEXT, &rc);\n      return rc;\n      \n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodElement::resolve()\"\n  int MethodElement::resolve(void){\n    int rc = ESMC_RC_NOT_IMPL;\n#ifdef ESMF_NO_DLFCN\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_LIB, \n      \"- System does not support dynamic loading.\", ESMC_CONTEXT, &rc);\n    return rc;\n#else\n    void *lib;\n    if (shobj.length()>0)\n      lib = dlopen(shobj.c_str(), RTLD_LAZY);\n    else\n      lib = dlopen(NULL, RTLD_LAZY);  // search in executable\n    if (lib == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"shared object not found\", ESMC_CONTEXT, &rc);\n      return rc;\n    }\n    pointer = (void *)dlsym(lib, name.c_str());\n    if (pointer == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- named routine not found\", ESMC_CONTEXT, &rc);\n      return rc;\n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n#endif\n  }\n  \n// -----------------------------------------------------------------------------\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodTable::print()\"\n  int MethodTable::print(void)const{\n    int localrc = ESMC_RC_NOT_IMPL;\n    int rc = ESMC_RC_NOT_IMPL;\n    MethodElement *element = table; // initialize\n    while (element){\n      localrc = element->print();\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, &rc)) return rc; // bail out\n      element = element->nextElement;\n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodTable::add()\"\n  int MethodTable::add(std::string labelArg, void *pointer){\n    int rc = ESMC_RC_NOT_IMPL;\n    if (table){\n      MethodElement *element = table; // initialize\n      MethodElement *prev;\n      while (element){\n        if (element->label == labelArg){\n          ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n            \"- method with identical label already exists\", ESMC_CONTEXT, &rc);\n          return rc;\n        }\n        prev = element;\n        element = element->nextElement;\n      }\n      prev->nextElement = new MethodElement(labelArg, pointer);\n    }else{\n      table = new MethodElement(labelArg, pointer);\n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodTable::add()\"\n  int MethodTable::add(std::string labelArg, std::string name,\n    std::string sharedObj){\n    int localrc = ESMC_RC_NOT_IMPL;\n    int rc = ESMC_RC_NOT_IMPL;\n    MethodElement *element = table; // initialize\n    if (table){\n      MethodElement *prev;\n      while (element){\n        if (element->label == labelArg){\n          ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n            \"- method with identical label already exists\", ESMC_CONTEXT, &rc);\n          return rc;\n        }\n        prev = element;\n        element = element->nextElement;\n      }\n      prev->nextElement = new MethodElement(labelArg, name, sharedObj);\n      element = prev->nextElement;\n    }else{\n      table = new MethodElement(labelArg, name, sharedObj);\n      element = table;\n    }\n    localrc = element->resolve();\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      &rc)) return rc; // bail out\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodTable::remove()\"\n  int MethodTable::remove(std::string labelArg){\n    int rc = ESMC_RC_NOT_IMPL;\n    if (table){\n      MethodElement *element = table; // initialize\n      MethodElement *prev = table;  // initialize\n      while (element){\n        if (element->label == labelArg){\n          if (element == table)\n            table = element->nextElement;\n          else\n            prev->nextElement = element->nextElement;\n          delete element;\n          // return successfully\n          rc = ESMF_SUCCESS;\n          return rc;\n        }\n        prev = element;\n        element = element->nextElement;\n      }\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- method not found in method table\", ESMC_CONTEXT, &rc);\n      return rc;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- empty method table\", ESMC_CONTEXT, &rc);\n      return rc;\n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodTable::execute()\"\n  int MethodTable::execute(std::string labelArg, void *object, int *userRc,\n    bool *existflag){\n    int localrc = ESMC_RC_NOT_IMPL;\n    int rc = ESMC_RC_NOT_IMPL;\n    if (table){\n      MethodElement *element = table; // initialize\n      while (element){\n        if (element->label == labelArg){\n          if (existflag) *existflag = true;\n          localrc = element->execute(object, userRc);\n          if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n            ESMC_CONTEXT, &rc)) return rc; // bail out\n          // return successfully\n          rc = ESMF_SUCCESS;\n          return rc;\n        }\n        element = element->nextElement;\n      }\n      if (existflag){\n        *existflag = false;\n        if (userRc) *userRc = ESMF_SUCCESS;\n      }else{\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n          \"- method not found in method table\", ESMC_CONTEXT, &rc);\n        return rc;\n      }\n    }else{\n      if (existflag){\n        *existflag = false;\n        if (userRc) *userRc = ESMF_SUCCESS;\n      }else{\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n          \"- empty method table\", ESMC_CONTEXT, &rc);\n        return rc;\n      }\n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n  \n} // namespace ESMCI\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Superstructure/Component/src/ESMCI_FTable.C": "// $Id$\n//\n// Earth System Modeling Framework\n// Copyright 2002-2018, University Corporation for Atmospheric Research,\n// Massachusetts Institute of Technology, Geophysical Fluid Dynamics\n// Laboratory, University of Michigan, National Centers for Environmental\n// Prediction, Los Alamos National Laboratory, Argonne National Laboratory,\n// NASA Goddard Space Flight Center.\n// Licensed under the University of Illinois-NCSA License.\n//\n//==============================================================================\n#define ESMC_FILENAME \"ESMCI_FTable.C\"\n//==============================================================================\n//\n// ESMCI Function table implementation (body) file\n//\n//-----------------------------------------------------------------------------\n//\n// !DESCRIPTION:\n//\n// The code in this file implements the C++ {\\tt Function Table} methods\n// declared in the companion file {\\tt ESMCI\\_FTable.h}.\n//\n//-----------------------------------------------------------------------------\n// include associated header file\n#include \"ESMCI_FTable.h\"\n\n// insert higher level, 3rd party or system includes\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#ifndef ESMF_NO_DLFCN\n#include <dlfcn.h>\n#endif\n\n// include ESMF headers\n#include \"ESMCI_Base.h\"\n#include \"ESMCI_Comp.h\"\n#include \"ESMCI_CompTunnel.h\"\n#include \"ESMCI_LogErr.h\"\n\nusing std::string;\n\n//-----------------------------------------------------------------------------\n// leave the following line as-is; it will insert the cvs ident string\n// into the object file for tracking purposes.\nstatic const char *const version = \"$Id$\";\n//-----------------------------------------------------------------------------\n\n\n//==============================================================================\n// prototypes for Fortran interface routines called by C++ code below\n//TODO: eventually move these calls into the ESMCI::Comp class\nextern \"C\" {\n  void FTN_X(f_esmf_compsetvminfo)(ESMCI::Comp *compp, void *vm_info, int *rc);\n  void FTN_X(f_esmf_compresetvmreleased)(ESMCI::Comp *compp, int *rc);\n  void FTN_X(f_esmf_compinsertvm)(ESMCI::Comp *compp, void *vm, int *rc);\n  void FTN_X(f_esmf_compgetctype)(ESMCI::Comp *compp, ESMCI::CompType *ctype,\n    int *rc);\n  void FTN_X(f_esmf_compreplicate)(ESMCI::Comp *compp, ESMCI::Comp *compp_src,\n    void *vm, int *rc);\n  void FTN_X(f_esmf_comprefcopy)(ESMCI::Comp *compp, ESMCI::Comp *compp_src,\n    int *rc);\n  void FTN_X(f_esmf_compdelete)(ESMCI::Comp *compp, int *rc);\n\n  void FTN_X(f_esmf_fortranudtpointersize)(int *size);\n  void FTN_X(f_esmf_fortranudtpointercopy)(void *dst, void *src);\n\n  void FTN_X(esmf_complianceicregister)(void *comp, int *rc);\n\n#ifdef ESMF_NO_DLFCN\n  //for now, assume these are here in the case that dlopen is not available\n  void FTN_X(nuopc_model_complianceicr)(void *comp, int *rc);\n  void FTN_X(nuopc_driver_complianceicr)(void *comp, int *rc);\n  void FTN_X(nuopc_connector_complianceicr)(void *comp, int *rc);\n#endif\n}\n//==============================================================================\n\n\n\n//==============================================================================\n// FTable interfaces to be called from Fortran side (ESMF_Comp.F90)\n//\n// these interface subroutine names MUST be in lower case\n//\nextern \"C\" {\n\n  // call to native class constructor\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftablecreate\"\n  void FTN_X(c_esmc_ftablecreate)(ESMCI::FTable **ptr, int *rc) {\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    (*ptr) = new ESMCI::FTable;\n    if (*ptr == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- Ftable allocation\", ESMC_CONTEXT, rc);\n      return;\n    }\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // call to native class destructor\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftabledestroy\"\n  void FTN_X(c_esmc_ftabledestroy)(ESMCI::FTable **ptr, int *rc) {\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (*ptr == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- Ftable deallocation\", ESMC_CONTEXT, rc);\n      return;\n    }\n    delete (*ptr);\n    *ptr = NULL;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // set arguments for standard Component methods\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftablesetstateargs\"\n  void FTN_X(c_esmc_ftablesetstateargs)(ESMCI::FTable **ptr,\n    enum ESMCI::method *method, int *phase, void *comp,\n    ESMCI::State *importState, ESMCI::State *exportState, ESMCI::Clock **clock,\n    ESMCI::CompTunnel **compTunnel, int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    if (*compTunnel != NULL){\n      // this is a dual component which contains a valid actual component object\n      // -> set references to the passed in arguments and return\n      (*compTunnel)->setMethod(*method);\n      (*compTunnel)->setPhase(*phase);\n      (*compTunnel)->setImportState(importState);\n      (*compTunnel)->setExportState(exportState);\n      (*compTunnel)->setClock(clock);\n\n    }else{\n      // this is not a dual component, thus do the actual ftable encoding\n\n      char const *methodString = ESMCI::FTable::methodString(*method);\n\n      int slen = strlen(methodString);\n      char *fname;\n      ESMCI::FTable::newtrim(methodString, slen, phase, NULL, &fname);\n      //printf(\"after newtrim, name = '%s'\\n\", fname);\n\n      void *alist[4];\n      alist[0] = (void *)comp;\n      alist[1] = (void *)importState;\n      alist[2] = (void *)exportState;\n      alist[3] = (void *)clock;\n\n      ESMCI::FTable *ftable = *ptr; // incoming FTable\n\n      // only if the incoming FTable contains PET-local component copies\n      for (int i=0; i<ftable->componentcount; i++){\n        ESMCI::Comp *comp = ftable->component + i;      // component copy\n        ESMCI::FTable *ft = **(ESMCI::FTable ***)comp;  // assoc. FTable\n        localrc = ft->setFuncArgs(fname, 4, alist);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n          ESMC_CONTEXT, rc)) return;\n      }\n\n      delete[] fname;  // delete memory that \"newtrim\" allocated above\n    }\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // set the InternalState in FTable\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftablesetinternalstate\"\n  void FTN_X(c_esmc_ftablesetinternalstate)(ESMCI::FTable ***ptr,\n    char const *type, void **data, enum ESMCI::dtype *dtype, int *rc,\n    ESMCI_FortranStrLenArg slen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    char *name;\n    ESMCI::FTable::newtrim(type, slen, NULL, NULL, &name);\n    //printf(\"after newtrim, name = '%s'\\n\", name);\n\n    localrc = (**ptr)->setDataPtr(name, data, *dtype);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n\n    delete[] name;  // delete memory that \"newtrim\" allocated above\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // get the InternalState from FTable\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftablegetinternalstate\"\n  void FTN_X(c_esmc_ftablegetinternalstate)(ESMCI::FTable ***ptr,\n    char const *type, void **data, enum ESMCI::dtype *dtype, int *rc,\n      ESMCI_FortranStrLenArg slen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    char *name;\n    ESMCI::FTable::newtrim(type, slen, NULL, NULL, &name);\n    //printf(\"after newtrim, name = '%s'\\n\", name);\n\n    localrc = (**ptr)->getDataPtr(name, data, dtype);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n\n    delete[] name;  // delete memory that \"newtrim\" allocated above\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setvm\"\n  void FTN_X(c_esmc_setvm)(void *ptr, void (*func)(), int *userRc, int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setVM(ptr, func, userRc, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setvmshobj\"\n  void FTN_X(c_esmc_setvmshobj)(void *ptr, char const *routineArg,\n    char const *sharedObjArg, int *userRc, int *rc,\n    ESMCI_FortranStrLenArg rlen, ESMCI_FortranStrLenArg llen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n#ifdef ESMF_NO_DLFCN\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_LIB,\n      \"- System does not support dynamic loading.\", ESMC_CONTEXT, rc);\n    return;\n#else\n    void *lib;\n    if (llen>0){\n      string sharedObj(sharedObjArg, llen);\n      sharedObj.resize(sharedObj.find_last_not_of(\" \")+1);\n      lib = dlopen(sharedObj.c_str(), RTLD_LAZY);\n    }else\n      lib = dlopen(NULL, RTLD_LAZY);  // search in executable\n    if (lib == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"shared object not found\", ESMC_CONTEXT, rc);\n      return;\n    }\n    string routine(routineArg, rlen);\n    routine.resize(routine.find_last_not_of(\" \")+1);\n    void (*func)() = (void (*)())dlsym(lib, routine.c_str());\n    if ((void *)func == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"routine not found\", ESMC_CONTEXT, rc);\n      return;\n    }\n    ESMCI::FTable::setVM(ptr, func, userRc, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n#endif\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setservices\"\n  void FTN_X(c_esmc_setservices)(void *ptr, void (*func)(), int *userRc, int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setServices(ptr, func, userRc, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setservicesshobj\"\n  void FTN_X(c_esmc_setservicesshobj)(void *ptr, char const *routineArg,\n    char const *sharedObjArg, ESMC_Logical *foundRoutine, int *userRc, int *rc,\n    ESMCI_FortranStrLenArg rlen, ESMCI_FortranStrLenArg llen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n#ifdef ESMF_NO_DLFCN\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_LIB,\n      \"- System does not support dynamic loading.\", ESMC_CONTEXT, rc);\n    return;\n#else\n    *foundRoutine = ESMF_FALSE; // initialize\n    void *lib;\n    if (llen>0){\n      string sharedObj(sharedObjArg, llen);\n      sharedObj.resize(sharedObj.find_last_not_of(\" \")+1);\n      lib = dlopen(sharedObj.c_str(), RTLD_LAZY);\n    }else\n      lib = dlopen(NULL, RTLD_LAZY);  // search in executable\n    if (lib == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"shared object not found\", ESMC_CONTEXT, rc);\n      return;\n    }\n    string routine(routineArg, rlen);\n    routine.resize(routine.find_last_not_of(\" \")+1);\n    void (*func)() = (void (*)())dlsym(lib, routine.c_str());\n    if ((void *)func != NULL){\n      // Routine was found\n      *foundRoutine = ESMF_TRUE;\n      ESMCI::FTable::setServices(ptr, func, userRc, &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n        rc)) return;\n    }\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n#endif\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setservicescomp\"\n  void FTN_X(c_esmc_setservicescomp)(ESMCI::Comp *dualComp,\n    ESMCI::CompTunnel **compTunnel, ESMCI::Comp *localActualComp,\n    int *localActualCompRootPet, int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (*compTunnel != NULL){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n    }\n    // The compTunnel object must be created on all the PETs that execute\n    // this routine, which are potentially all parent PETs, not just those\n    // that eventually enter the child VM. This is so that all child component\n    // objects that exist on the parent VM with a valid entry of a child VM\n    // also have a valid compTunnel member.\n    *compTunnel = new ESMCI::CompTunnel(localActualComp,\n      *localActualCompRootPet);\n    if (*compTunnel == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- CompTunnel allocation\", ESMC_CONTEXT, rc);\n      return; // bail out\n    }\n    // call into setServices with the internal CompTunnel::SetServices wrapper\n    int userRc;\n    localrc =dualComp->setServices(ESMCI::CompTunnel::setServicesWrap, &userRc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n      return; // bail out\n    }\n    if (ESMC_LogDefault.MsgFoundError(userRc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n      return; // bail out on userRc b/c setServicesWrap is an internal routine\n    }\n\n    // Now that everything has returned successfully, mark the tunnel as\n    // connected.\n    // This must be done up on this level, so that _all_ PETs that call into\n    // SetServices() have the tunnel set to connected.\n    (*compTunnel)->setConnected(true);\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setservicessock\"\n  void FTN_X(c_esmc_setservicessock)(ESMCI::Comp *dualComp,\n    ESMCI::CompTunnel **compTunnel, int *port, char const *serverArg,\n    int *timeout, int *rc, ESMCI_FortranStrLenArg len){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (*compTunnel != NULL){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n    }\n    if (*port<1024 || *port>65535){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"- The port argument is outside valid range [1024, 65535]\",\n        ESMC_CONTEXT, rc);\n      return;\n    }\n    // server name\n    string server(serverArg, len);\n    // The compTunnel object must be created on all the PETs that execute\n    // this routine, which are potentially all parent PETs, not just those\n    // that eventually enter the child VM. This is so that all child component\n    // objects that exist on the parent VM with a valid entry of a child VM\n    // also have a valid compTunnel member.\n    *compTunnel = new ESMCI::CompTunnel(*port, server);\n    if (*compTunnel == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- CompTunnel allocation\", ESMC_CONTEXT, rc);\n      return; // bail out\n    }\n    (*compTunnel)->setTimeout(*timeout);  // set dual side timeout for setServ.\n    // call into setServices with the internal CompTunnel::SetServices wrapper\n    int userRc;\n    localrc =dualComp->setServices(ESMCI::CompTunnel::setServicesWrap, &userRc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n      return; // bail out\n    }\n    // CompTunnel::setServicesWrap() is a framework internal method, therefore\n    // the code returned in userRc is a framework internal return code and must\n    // be treated as such.\n    // Do not filter the RC_TIMEOUT at this level, since a timeout needs to\n    // bail out until it gets to the upper ESMF level, right before returning\n    // to the user, where the filtering is done according to the presence of\n    // a timeoutFlag argument.\n    if (ESMC_LogDefault.MsgFoundError(userRc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n      return; // bail out on userRc b/c setServicesWrap is an internal routine\n    }\n\n    // Now that everything has returned successfully, mark the tunnel as\n    // connected.\n    // This must be done up on this level, so that _all_ PETs that call into\n    // SetServices() have the tunnel set to connected.\n    (*compTunnel)->setConnected(true);\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setentrypoint\"\n  void FTN_X(c_esmc_setentrypoint)(void *ptr, enum ESMCI::method *method,\n    void *func, int *phase, int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    char const *methodString = ESMCI::FTable::methodString(*method);\n\n    int slen = strlen(methodString);\n    char *fname;\n    ESMCI::FTable::newtrim(methodString, slen, phase, NULL, &fname);\n\n    ESMCI::FTable *tabptr = **(ESMCI::FTable***)ptr;\n    localrc = (tabptr)->setFuncPtr(fname, func, ESMCI::FT_VOIDP4INTP);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n\n    delete[] fname;  // delete memory that \"newtrim\" allocated above\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_getentrypointphasecount\"\n  void FTN_X(c_esmc_getentrypointphasecount)(void *ptr,\n    enum ESMCI::method *method, int *phaseCount, ESMC_Logical *phaseZeroFlag,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    char const *methodString = ESMCI::FTable::methodString(*method);\n\n    ESMCI::FTable *tabptr = **(ESMCI::FTable***)ptr;\n\n    int slen = strlen(methodString);\n    int phase = 0;  // initialize\n    int i;\n\n    *phaseZeroFlag = ESMF_FALSE; // initialize\n\n    char *fname;\n    ESMCI::FTable::newtrim(methodString, slen, &phase, NULL, &fname);\n    i = tabptr->getEntry(fname, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return; // bail out\n    delete[] fname;  // delete memory that \"newtrim\" allocated above\n    if (i != -1)\n      *phaseZeroFlag = ESMF_TRUE;  // set the flag\n\n    do{\n      ++phase;\n      ESMCI::FTable::newtrim(methodString, slen, &phase, NULL, &fname);\n\n      i = tabptr->getEntry(fname, &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return; // bail out\n\n      delete[] fname;  // delete memory that \"newtrim\" allocated above\n\n    }while (i != -1);\n\n    *phaseCount = phase - 1;\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n} // extern \"C\"\n//==============================================================================\n\n\n//==============================================================================\n// these functions have no leading c_ and are ESMF and not ESMC because\n// they're intended to be called directly by F90 user code.\n//\n// also note they CANNOT have prototypes in fortran because the routine\n// types and data types are private/different for each call so there\n// is no correct prototype syntax which will work.\n//\n// and finally, note that they have an extra level of indirection,\n// because the first arg is actually being called with a component\n// pointer - and after one dereference we are at the component derived\n// type.  the second dereference finds the ftable pointer which must\n// be the first entry in the comp derived type.\n//\n// these interface subroutine names MUST be in lower case\nextern \"C\" {\n\n  // ---------- GridComp ---------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_gridcompsetinternalstate\"\n  void FTN_X(esmf_gridcompsetinternalstate)(ESMCI::FTable ***ptr, void **datap,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setDP(ptr, datap, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_gridcompgetinternalstate\"\n  void FTN_X(esmf_gridcompgetinternalstate)(ESMCI::FTable ***ptr, void **datap,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::getDP(ptr, datap, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // ---------- CplComp ---------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_cplcompsetinternalstate\"\n  void FTN_X(esmf_cplcompsetinternalstate)(ESMCI::FTable ***ptr, void **datap,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setDP(ptr, datap, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_cplcompgetinternalstate\"\n  void FTN_X(esmf_cplcompgetinternalstate)(ESMCI::FTable ***ptr, void **datap,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::getDP(ptr, datap, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // ---------- UserComp ---------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_usercompsetvm\"\n  void FTN_X(esmf_usercompsetvm)(void *ptr, void (*func)(), int *userRc,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setVM(ptr, func, userRc, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_usercompsetservices\"\n  void FTN_X(esmf_usercompsetservices)(void *ptr, void (*func)(), int *userRc,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setServices(ptr, func, userRc, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_usercompsetinternalstate\"\n  void FTN_X(esmf_usercompsetinternalstate)(ESMCI::FTable ***ptr,\n    char const *name, void **datap, int *rc,\n    ESMCI_FortranStrLenArg slen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    if ((ptr == ESMC_NULL_POINTER) || (*ptr == ESMC_NULL_POINTER)){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"null pointer found\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    char *tbuf;\n    ESMCI::FTable::newtrim(name, slen, NULL, NULL, &tbuf);\n    //printf(\"after newtrim, name = '%s'\\n\", tbuf);\n\n    enum ESMCI::dtype dtype = ESMCI::DT_FORTRAN_UDT_POINTER;\n    localrc = (**ptr)->setDataPtr(tbuf, datap, dtype);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n\n    delete[] tbuf;\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_usercompgetinternalstate\"\n  void FTN_X(esmf_usercompgetinternalstate)(ESMCI::FTable ***ptr,\n    char const *name, void **datap, int *rc,\n    ESMCI_FortranStrLenArg slen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    if ((ptr == ESMC_NULL_POINTER) || (*ptr == ESMC_NULL_POINTER)){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"null pointer found\", ESMC_CONTEXT,rc);\n      return;\n    }\n\n    char *tbuf;\n    ESMCI::FTable::newtrim(name, slen, NULL, NULL, &tbuf);\n    //printf(\"after newtrim, name = '%s'\\n\", tbuf);\n\n    enum ESMCI::dtype dtype;\n    localrc = (**ptr)->getDataPtr(tbuf, datap, &dtype);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n\n    delete[] tbuf;\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n} // extern \"C\"\n//==============================================================================\n\n\n//==============================================================================\n// VM-enabled CallBack loop\nextern \"C\" {\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI_FTableCallEntryPointVMHop\"\nvoid *ESMCI_FTableCallEntryPointVMHop(void *vm, void *cargoCast){\n  // This routine is the first level that gets instantiated in new VM\n  // The first argument must be of type (void *) and points to a derived\n  // ESMCI::VMK class object. The second argument is also of type (void *)\n  // and points to a cargotype structure.\n\n  // pull out info from cargo\n  ESMCI::cargotype *cargo = (ESMCI::cargotype *)cargoCast;\n  char *name = cargo->name;               // name of callback\n  ESMCI::FTable *ftable = cargo->ftable;  // ptr to ftable\n\n  int localrc;          // local return code\n  int esmfrc;           // ESMF return code of ESMCI::FTable::callVFuncPtr()\n  int userrc = -99999;  // user return code from the registered component method\n\n  // prepare return code members in cargo\n  int mypet = ((ESMCI::VM*)vm)->getMypet();\n  int mynthreads = ((ESMCI::VM*)vm)->getNthreads(mypet);\n  int mytid = ((ESMCI::VM*)vm)->getTid(mypet);\n  if (mytid==0){\n    // master thread -> allocate return code members in cargo for all threads\n    if (cargo->rcCount != mynthreads){\n      delete [] cargo->esmfrc;\n      delete [] cargo->userrc;\n      cargo->esmfrc = new int[mynthreads];\n      cargo->userrc = new int[mynthreads];\n      cargo->rcCount = mynthreads;\n    }\n  }\n  ((ESMCI::VM*)vm)->threadbarrier();  // synchronize all threads in local group\n\n  // get a pointer to the CompTunnel object\n  ESMCI::Comp *f90comp = cargo->f90comp;\n  ESMCI::CompTunnel *compTunnel;\n  localrc = f90comp->getTunnel(&compTunnel);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    &esmfrc)){\n    cargo->esmfrc[mytid] = esmfrc;\n    return NULL;\n  }\n\n  // determine whether this is a dual component that is ready to execute\n  bool dualConnected = false;  // initialize\n  if (compTunnel) dualConnected = compTunnel->isConnected();\n\n  if (dualConnected){\n    // this is a dual component with a compTunnel that is connected\n\n    //TODO: check whether \"name\" is found in dual components ftable. If so then\n    //TODO: consider that an override, and execute dual components method\n    //TODO: instead\n\n    localrc = compTunnel->execute(cargo);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      &esmfrc)){\n      cargo->esmfrc[mytid] = esmfrc;  // put esmf return code into cargo\n      return NULL;\n    }\n\n    // ...the user return code will not be available until wait() is called\n\n  }else{\n    // a regular component or a dual component that needs to connect still,\n    // use the local ftable for user code or system code callback\n    localrc = ftable->callVFuncPtr(name, (ESMCI::VM*)vm, &userrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      &esmfrc)){\n      cargo->esmfrc[mytid] = esmfrc;  // put esmf return code into cargo\n      return NULL;\n    }\n\n    // ...back from user code\n    cargo->userrc[mytid] = userrc;  // put the user return code into cargo\n  }\n\n  // return successfully\n  cargo->esmfrc[mytid] = ESMF_SUCCESS;\n  return NULL;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// call a function through VM\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftablecallentrypointvm\"\nvoid FTN_X(c_esmc_ftablecallentrypointvm)(\n  ESMCI::Comp *f90comp,       // pointer to Fortran component object\n  ESMCI::VM **ptr_vm_parent,  // p2 to the parent VM\n  ESMCI::VMPlan **ptr_vmplan, // p2 to the VMPlan for component's VM\n  void **vm_info,             // p2 to member which holds info returned by enter\n  void **vm_cargo,            // p2 to member which holds cargo\n  ESMCI::FTable **ptr,        // p2 to the ftable of this component\n  enum ESMCI::method *method, // method type\n  int *phase,                 // phase selector\n  int *port,                  // port number\n  int *timeout,               // time out in seconds\n  int *recursionCount,        // keeping track of recursion level of component\n  int *rc                     // return code\n  ){\n\n  // local variables\n  int localrc;              // local return code\n  char *name;               // trimmed type string\n\n  // check to make sure VM has really been started up for this Component\n  if (*vm_info == NULL){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_PTR_NULL,\n      \"No VM was started for this Component - missing SetServices() call?\",\n      ESMC_CONTEXT, rc);\n    return; // bail out\n  }\n\n  // Initialize return code; assume routine not implemented\n  if (rc) *rc = ESMC_RC_NOT_IMPL;\n  localrc = ESMC_RC_NOT_IMPL;\n\n  char const *methodString = ESMCI::FTable::methodString(*method);\n\n  int slen = strlen(methodString);\n  ESMCI::FTable::newtrim(methodString, slen, phase, NULL, &name);\n\n  // dereference double pointers to pointers\n  ESMCI::VM *vm_parent  = *ptr_vm_parent;     // pointer to parent VM\n  ESMCI::VMPlan *vmplan = *ptr_vmplan;        // pointer to VMPlan\n  ESMCI::FTable *ftable = *ptr;               // pointer to function table\n\n  int i = ftable->getEntry(name, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return; // bail out\n  enum ESMCI::method currentMethod = ESMCI::METHOD_NONE;  // default invalid\n  if (i > -1)\n    currentMethod = ftable->methodFromIndex(i);\n\n  // support for recursion _and_ re-entrance for non-blocking mode\n  // - recursion:   A component may call into any of its standard methods from\n  //                within the context of already executing a standard method.\n  //                There is no practical limit to the recursion depth.\n  // - re-entrance: This refers to the situation where there is an outstanding\n  //                non-blocking call, but the parent calls into the standard\n  //                child component method again. This really only happens\n  //                on the dual side of dual-actual pairs connected by a\n  //                component tunnel. The dual side then may re-enter with an\n  //                associated wait call.\n  bool newCargoFlag = true;   // initialize\n  if (recursionCount && *recursionCount==0 && *vm_cargo)\n    newCargoFlag = false; // this is not a recursion but a re-entrance\n\n  if (newCargoFlag){\n    ESMCI::cargotype *cargo = new ESMCI::cargotype;\n    strcpy(cargo->name, name);    // copy trimmed type string\n    cargo->f90comp = f90comp;     // pointer to Fortran component\n    cargo->ftable = ftable;       // pointer to function table\n    cargo->rcCount = 1;           // default\n    cargo->esmfrc = new int[1];\n    cargo->userrc = new int[1];\n    cargo->esmfrc[0] = ESMF_SUCCESS;  // initialize return code to SUCCESS\n    cargo->userrc[0] = ESMF_SUCCESS;  // initialize user return code to SUCCESS\n    cargo->previousCargo = *vm_cargo; // support recursion\n    cargo->previousParentFlag = vmplan->parentVMflag;  // support threaded rec.\n    cargo->currentMethod = currentMethod;\n    if (*method == ESMCI::METHOD_SERVICELOOP){\n      // for serviceloop method the currentPhase carries the port argument\n      cargo->currentPhase = *port;\n    }else{\n      // for all other methods the currentPhase is the current phase\n      if (phase)\n        cargo->currentPhase = *phase;\n      else\n        cargo->currentPhase = 1;    // default\n    }\n\n    // store pointer to the cargo structure\n    *vm_cargo=(void*)cargo;\n\n    if (cargo->previousCargo != NULL){\n      // this is a recursive method invocation\n      // use the parentVMflag to indicate running in already existing child VM\n      vmplan->parentVMflag = 1;\n    }\n  }\n  delete[] name;  // delete memory that \"newtrim\" allocated above\n\n  // store the current timeout in the cargo structure\n  ESMCI::cargotype *cargo = (ESMCI::cargotype *)*vm_cargo;\n  if (timeout)\n    cargo->timeout = *timeout;\n  else\n    cargo->timeout = -1;          // indicate invalid timeout\n\n  // increment recursionCount before entering child VM\n  if (recursionCount) (*recursionCount)++;\n\n  // enter the child VM -> resurface in ESMCI_FTableCallEntryPointVMHop()\n  localrc = vm_parent->enter(vmplan, *vm_info, *vm_cargo);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return; // bail out\n\n  // ... if the child VM uses threads (multi-threading or single-threading)\n  // then this parent PET continues running concurrently to the child PET in the\n  // same VAS! In that case the return codes in cargo are not valid here!\n  // The status returned by VM::enter() indicates that success of entering the\n  // child VM, not failure or success of the callback.\n  // The return code of the callback code will be valid in all cases (threading\n  // or no threading) _after_ VMK::exit() returns.\n\n  // decrement recursionCount again\n  if (recursionCount) (*recursionCount)--;\n\n  // return successfully\n  if (rc) *rc = ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_compwait\"\nvoid FTN_X(c_esmc_compwait)(\n  ESMCI::VM **ptr_vm_parent,  // p2 to the parent VM\n  ESMCI::VMPlan **ptr_vmplan, // p2 to the VMPlan for component's VM\n  void **vm_info,             // p2 to member which holds info\n  void **vm_cargo,            // p2 to member which holds cargo\n  int *timeout,               // time out in seconds\n  int *userrc,                // return code of the user component method\n  int *rc){                   // esmf internal return error code\n\n  // initialize the return codes\n  int localrc = ESMC_RC_NOT_IMPL;\n  if (rc) *rc = ESMC_RC_NOT_SET; // return code of ESMF callback code\n\n  // Things get a little confusing here with pointers, so I will define\n  // some temp. variables that make matters a little clearer I hope:\n  ESMCI::VM *vm_parent = *ptr_vm_parent;        // pointer to parent VM\n  ESMCI::VMPlan *vmplan = *ptr_vmplan;          // pointer to VMPlan\n  ESMCI::cargotype *cargo = (ESMCI::cargotype *)*vm_cargo;  // pointer to cargo\n\n  // return with errors if there is no cargo to obtain error codes\n  if (cargo == NULL){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_PTR_NULL,\n      \" - No cargo structure to obtain error codes\", ESMC_CONTEXT, rc);\n    return;\n  }\n\n  // get a pointer to the CompTunnel object\n  ESMCI::Comp *f90comp = cargo->f90comp;\n  ESMCI::CompTunnel *compTunnel;\n  localrc = f90comp->getTunnel(&compTunnel);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // determine whether this is a dual component that is ready to execute\n  bool dualConnected = false;  // initialize\n  if (compTunnel) dualConnected = compTunnel->isConnected();\n\n  if (dualConnected){\n    // this is a dual component with a compTunnel that is connected\n    // -> execute compTunnel::wait() on dual components VM.\n\n    if (timeout == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_PTR_NULL,\n        \" - Must provide valid timeout argument\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    ESMCI::State *is = compTunnel->getImportState();\n    ESMCI::State *es = compTunnel->getImportState();\n    ESMCI::Clock **clock = compTunnel->getClock();\n\n    ESMCI::Clock *clockP = NULL; // default initialize\n    if (clock) clockP = *clock;\n\n    int userRc = ESMC_RC_NOT_IMPL;\n\n    localrc = f90comp->execute(ESMCI::METHOD_WAIT, is, es, clockP,\n      ESMF_NONBLOCKING,       // nonblocking or else endless recursion!!!\n      1, *timeout, &userRc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // TODO: in case of threading the userRc in not immediatly available!\n    if (ESMC_LogDefault.MsgFoundError(userRc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return; // bail out too because this is for an internal routine\n  }\n\n  // Now call the vmk_exit function which will block respective PETs\n  vm_parent->exit(static_cast<ESMCI::VMKPlan *>(vmplan), *vm_info);\n\n  // obtain return codes out of cargo\n  //TODO: deal with multiple return codes coming back for multi-threaded VMs\n  localrc = cargo->esmfrc[0];\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n  if (userrc) *userrc = cargo->userrc[0];\n\n  // delete cargo structure and handle recursion\n  delete [] cargo->esmfrc;\n  delete [] cargo->userrc;\n  *vm_cargo = cargo->previousCargo; // bring back previous cargo structure\n  vmplan->parentVMflag = cargo->previousParentFlag;   // previous value\n  delete cargo;\n\n  // return successfully\n  if (rc) *rc = ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_compget\"\nvoid FTN_X(c_esmc_compget)(\n  void **vm_cargo,            // p2 to member which holds cargo\n  enum ESMCI::method *method, // method type\n  int *phase,                 // phase selector\n  int *timeout,               // timeout\n  int *rc){                   // esmf internal return error code\n\n  // initialize the return codes\n  if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n  ESMCI::cargotype *cargo = (ESMCI::cargotype *)*vm_cargo;\n\n  if (cargo){\n    *method = cargo->currentMethod;\n    *phase = cargo->currentPhase;\n    *timeout = cargo->timeout;\n  }else{\n    *method = ESMCI::METHOD_NONE;\n    *phase = 0;\n    *timeout = 0;\n  }\n\n  // return successfully\n  if (rc) *rc = ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n\n} // extern \"C\"\n//==============================================================================\n\n\n\n//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n//\n// This section implements the FTable class\n//\n//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n\nnamespace ESMCI {\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::getDP()\"\nvoid FTable::getDP(FTable ***ptr, void **datap, int *rc){\n  char const *name = \"localdata\";\n  enum dtype dtype;\n  int localrc;\n\n  // Initialize return code; assume routine not implemented\n  if (rc) *rc = ESMC_RC_NOT_IMPL;\n  localrc = ESMC_RC_NOT_IMPL;\n\n  //printf(\"ptr = 0x%08x\\n\", (ESMC_POINTER)ptr);\n  //printf(\"*ptr = 0x%08x\\n\", (ESMC_POINTER)(*(int*)ptr));\n  if ((ptr == ESMC_NULL_POINTER) || (*ptr == ESMC_NULL_POINTER)) {\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, rc);\n    return;\n  }\n\n  localrc = (**ptr)->getDataPtr(name, datap, &dtype);\n  if (rc) *rc = localrc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setDP()\"\nvoid FTable::setDP(FTable ***ptr, void **datap, int *rc){\n  char const *name = \"localdata\";\n  enum dtype dtype = DT_FORTRAN_UDT_POINTER;\n  int localrc;\n\n  // Initialize return code; assume routine not implemented\n  if (rc) *rc = ESMC_RC_NOT_IMPL;\n  localrc = ESMC_RC_NOT_IMPL;\n\n  //printf(\"ptr = 0x%08x\\n\", (ESMC_POINTER)ptr);\n  //printf(\"*ptr = 0x%08x\\n\", (ESMC_POINTER)(*(int*)ptr));\n  if ((ptr == ESMC_NULL_POINTER) || (*ptr == ESMC_NULL_POINTER)) {\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, rc);\n    return;\n  }\n\n  localrc = (**ptr)->setDataPtr(name, datap, dtype);\n  if (rc) *rc = localrc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::getDataPtr()\"\n//BOPI\n// !IROUTINE:  getDataPtr - get data pointer from name\n//\n// !INTERFACE:\nint FTable::getDataPtr(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      char const *namep,     // in, data name\n      void **datap,          // out, data address\n      enum dtype *dtype) {   // out, data type\n//\n// !DESCRIPTION:\n//    Returns the named data pointer\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  int i;\n\n  for (i=datacount-1; i>=0; i--) {    // go backwards for: \"last in first out\"\n    if (strcmp(namep, data[i].dataname)) continue;\n\n    *dtype = data[i].dtype;\n\n    if (*dtype == DT_VOIDP){\n      *datap = data[i].dataptr;\n    }else if (*dtype == DT_FORTRAN_UDT_POINTER){\n      FTN_X(f_esmf_fortranudtpointercopy)((void *)datap, data[i].dataptr);\n    }\n\n    return ESMF_SUCCESS;\n  }\n\n  return ESMF_FAILURE;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setDataPtr()\"\n//BOPI\n// !IROUTINE:  setDataPtr - set data pointer\n//\n// !INTERFACE:\nint FTable::setDataPtr(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      char const *namep,     // in, data name\n      void **datap,          // in, data address\n      enum dtype dtype) {    // in, data type\n//\n// !DESCRIPTION:\n//    Sets the named data pointer\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize return code; assume routine not implemented\n  int rc = ESMC_RC_NOT_IMPL;\n\n  if (datacount >= dataalloc){\n    data =\n      (datainfo *)realloc((void *)data, (datacount+4) * sizeof(datainfo));\n    dataalloc = datacount+4;\n  }\n  data[datacount].dataname = new char[strlen(namep)+1];\n  strcpy(data[datacount].dataname, namep);\n  data[datacount].dtype = dtype;\n\n  if (dtype == DT_VOIDP){\n    data[datacount].dataptr = *datap;\n  }else if (dtype == DT_FORTRAN_UDT_POINTER){\n    int datumSize;  // upper limit of (UDT, pointer) size\n    FTN_X(f_esmf_fortranudtpointersize)(&datumSize);\n    data[datacount].dataptr = (void *)new char[datumSize];\n    FTN_X(f_esmf_fortranudtpointercopy)(data[datacount].dataptr, (void *)datap);\n  }\n\n  datacount++;\n\n  rc = ESMF_SUCCESS;\n  return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::Ftable::setServices\"\nvoid FTable::setServices(void *ptr, void (*func)(), int *userRc, int *rc) {\n  int localrc = ESMC_RC_NOT_IMPL;         // local return code\n  if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;   // final return code\n\n  // Check input\n  if ((ptr == ESMC_NULL_POINTER) || ((*(void**)ptr) == ESMC_NULL_POINTER)){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, rc);\n    return;\n  }\n\n  // TODO: shouldn't need to expand the table here - should be done inside\n  // FTable code on demand.\n  ESMCI::FTable *tabptr = **(ESMCI::FTable***)ptr;\n  localrc = (tabptr)->extend(32, 2); // room for 32 funcs, 2 data\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // Set callback function and arguments\n  ESMCI::Comp *f90comp = (ESMCI::Comp *)ptr;\n  localrc = (tabptr)->setFuncPtr(methodString(METHOD_SETSERVICES),\n    (void *)func, f90comp);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // time to startup the VM for this component (if not already started)...\n  ESMCI::VM *vm_parent;\n  localrc = f90comp->getVmParent(&vm_parent);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n  ESMCI::VMPlan *vmplan_p;\n  localrc = f90comp->getVmPlan(&vmplan_p);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n  void *vm_info;\n  localrc = f90comp->getVmInfo(&vm_info);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n  if (vm_info==NULL){\n    // VM for this component has not been started yet\n    vm_info = vm_parent->startup(vmplan_p,\n      ESMCI_FTableCallEntryPointVMHop, NULL, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // keep vm_info in a safe place (in parent component) 'till it's used again\n    FTN_X(f_esmf_compsetvminfo)(f90comp, &vm_info, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n  }\n  // ...now the component's VM is started up and placed on hold.\n\n  // reset a flag in the component structure\n  FTN_X(f_esmf_compresetvmreleased)(f90comp, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // call into register routine using the component's VM\n  void *vm_cargo = NULL;\n  enum method reg = METHOD_SETSERVICES;\n  FTN_X(c_esmc_ftablecallentrypointvm)(f90comp, &vm_parent, &vmplan_p, &vm_info,\n    &vm_cargo, &tabptr, &reg, NULL, NULL, NULL, NULL, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // wait for the register routine to return\n  FTN_X(c_esmc_compwait)(&vm_parent, &vmplan_p, &vm_info, &vm_cargo, NULL,\n    userRc, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // return successfully\n  if (rc) *rc = ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::Ftable::setVM\"\nvoid FTable::setVM(void *ptr, void (*func)(), int *userRc, int *rc) {\n  int localrc = ESMC_RC_NOT_IMPL;         // local return code\n  if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;   // final return code\n\n  // Check input\n  if ((ptr == ESMC_NULL_POINTER) || ((*(void**)ptr) == ESMC_NULL_POINTER)){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, rc);\n    return;\n  }\n\n  // cast into ESMCI::Comp pointer\n  ESMCI::Comp *f90comp = (ESMCI::Comp *)ptr;\n\n  // check to see if VM already exists for this Component\n  void *vm_info;\n  localrc = f90comp->getVmInfo(&vm_info);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n  if (vm_info!=NULL){\n    // VM for this component already exists\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_NOT_VALID, \"- VM already exists\",\n      ESMC_CONTEXT, rc);\n    return;\n  }\n\n  // TODO: shouldn't need to expand the table here - should be done inside\n  // FTable code on demand.\n  ESMCI::FTable *tabptr = **(ESMCI::FTable***)ptr;\n  localrc = (tabptr)->extend(32, 2); // room for 32 funcs, 2 data\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // Set callback function and arguments\n  localrc = (tabptr)->setFuncPtr(\"setVM\", (void *)func, f90comp);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // Call into user code callback function\n  localrc = (tabptr)->callVFuncPtr(\"setVM\", NULL, userRc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // return successfully\n  if (rc) *rc = ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::getEntry()\"\n//BOPI\n// !IROUTINE:  getEntry - get FTable entry from name\n//\n// !INTERFACE:\nint FTable::getEntry(\n//\n// !RETURN VALUE:\n//    entry index, or -1 if not found.\n//\n// !ARGUMENTS:\n  char const *name,      // in, function name\n  int *rc) {             // out, return code\n//\n// !DESCRIPTION:\n//  Returns the index into the function table that matches \"name\". A linear\n//  search is used, which is sufficient for typically very small function\n//  table sizes.\n//  One added feature this look-up routine also provides is a secondary\n//  search for the actual method name in case that \"name\" was _not_ found,\n//  _and_ \"name\" contained the substring \"IC\" which indicates that this\n//  would have been a look-up for an interface component method.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize rc and localrc ; assume functions not implemented\n  if (*rc) *rc = ESMC_RC_NOT_IMPL;\n\n  // Check input\n  if (name == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, rc);\n    return -1;  // indicate entry not found\n  }\n\n  int i;\n  for (i=0; i<funccount; i++) {\n    if (!strcmp(name, funcs[i].funcname))\n      break;\n  }\n  if (i==funccount) i=-1; // indicate entry not found\n\n//if (i==-1)\n//printf(\"gjt: failed attempt to look up method: %s\\n\", name);\n\n  if (i == -1){\n    // name was not found in function table -> check if name contains \"IC\"\n    char const *ic = strstr(name, \"IC\");\n    if (ic){\n      // this was a failed attempt look up interface component method\n      // -> try actual component method instead\n      int len = strlen(name);\n      char *tempname = new char[len];\n      char *b = tempname;\n      char const *a = name;\n      for (int l=0; l<len+1; l++){\n        if (a!=ic && a!=ic+1){\n          *b = *a;\n          b++;\n        }\n        a++;\n      }\n//printf(\"gjt: failed attempt to look up IC method -> try actual method: %s\\n\",\n//tempname);\n\n      for (i=0; i<funccount; i++) {\n        if (!strcmp(tempname, funcs[i].funcname))\n          break;\n      }\n      if (i==funccount) i=-1; // indicate entry not found\n      delete [] tempname;\n//if (i==-1)\n//printf(\"gjt: failed 2nd attempt to look up method: %s\\n\", name);\n    }\n  }\n\n  // return successfully\n  if (rc!=NULL) *rc = ESMF_SUCCESS;\n  return i;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setFuncPtr()\"\n//BOPI\n// !IROUTINE:  setFuncPtr - set function pointer, no extra args\n//\n// !INTERFACE:\nint FTable::setFuncPtr(\n//\n// !RETURN VALUE:\n//  int error return code\n//\n// !ARGUMENTS:\n    char const *name,      // in, function name\n    void *func) {          // in, function address\n//\n// !DESCRIPTION:\n//    Sets the named function pointer\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize return code; assume routine not implemented\n  int rc = ESMC_RC_NOT_IMPL;\n\n  // Check input\n  if (name == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n  if (func == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n\n  // look for the name already existing in the table.  if found\n  // replace it.  otherwise add it to the end.\n  int i;\n  for (i=0; i<funccount; i++)\n    if (!strcmp(name, funcs[i].funcname)) break;\n\n  // we found the function, or we got to the end of the table.\n  // either way we are ready to add it.\n\n  int thisfunc = i;\n\n  // extend the table if needed\n  if (thisfunc >= funcalloc){\n    funcs = (funcinfo *)realloc((void *)funcs, (thisfunc+4) * sizeof(funcinfo));\n    funcalloc = thisfunc+4;\n  }\n  funcs[thisfunc].funcptr = func;\n  funcs[thisfunc].ftype = FT_NULL;\n  // do these only if not replacing an existing entry.\n  if (thisfunc == funccount){\n    funcs[thisfunc].funcname = new char[strlen(name)+1];\n    strcpy(funcs[thisfunc].funcname, name);\n    funccount++;\n  }\n\n  // return successfully\n  rc = ESMF_SUCCESS;\n  return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setFuncPtr()\"\n//BOPI\n// !IROUTINE:  setFuncPtr - set function pointer, type; no args yet.\n//\n// !INTERFACE:\nint FTable::setFuncPtr(\n//\n// !RETURN VALUE:\n//  int error return code\n//\n// !ARGUMENTS:\n    char const *name,      // in, function name\n    void *func,            // in, function address\n    enum ftype ftype) {    // in, function type\n//\n// !DESCRIPTION:\n//    Sets the named function pointer and type, but specifies no argument\n//    values.  Before this can be called successfully, the user must call\n//    FTable::setFuncArgs to fill in the argument list.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize return code; assume routine not implemented\n  int rc = ESMC_RC_NOT_IMPL;\n\n  // Check input\n  if (name == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n  if (func == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n\n  // look for the name already existing in the table.  if found\n  // replace it.  otherwise add it to the end.\n  int i;\n  for (i=0; i<funccount; i++)\n    if (!strcmp(name, funcs[i].funcname)) break;\n\n  // we found the function, or we got to the end of the table.\n  // either way we are ready to add it.\n\n  int thisfunc = i;\n\n  // extend the table if needed\n  if (thisfunc >= funcalloc){\n    funcs = (funcinfo *)realloc((void *)funcs, (thisfunc+4) * sizeof(funcinfo));\n    funcalloc = thisfunc+4;\n  }\n  funcs[thisfunc].funcptr = func;\n  funcs[thisfunc].ftype = ftype;\n  // do these only if not replacing an existing entry.\n  if (thisfunc == funccount) {\n    funcs[thisfunc].funcname = new char[strlen(name)+1];\n    strcpy(funcs[thisfunc].funcname, name);\n    funccount++;\n  }\n\n  // return successfully\n  rc = ESMF_SUCCESS;\n  return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setFuncPtr()\"\n//BOPI\n// !IROUTINE:  setFuncPtr - set voidp, intp specifically\n//\n// !INTERFACE:\nint FTable::setFuncPtr(\n//\n// !RETURN VALUE:\n//  int error return code\n//\n// !ARGUMENTS:\n    char const *name,     // in, function name\n    void *func,           // in, function address\n    void *arg){           // in, void *\n//\n// !DESCRIPTION:\n//    Sets the named function pointer and arg.  This is a common case\n//    so it has it's own interface.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize return code; assume routine not implemented\n  int rc = ESMC_RC_NOT_IMPL;\n\n  // Check input\n  if (name == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n  if (func == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n  if (arg == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n\n  // look for the name already existing in the table.  if found\n  // replace it.  otherwise add it to the end.\n  int i;\n  for (i=0; i<funccount; i++)\n    if (!strcmp(name, funcs[i].funcname)) break;\n\n  // we found the function, or we got to the end of the table.\n  // either way we are ready to add it.\n\n  int thisfunc = i;\n\n  // extend the table if needed\n  if (thisfunc >= funcalloc) {\n    funcs = (funcinfo *)realloc((void *)funcs, (thisfunc+4) * sizeof(funcinfo));\n    funcalloc = thisfunc+4;\n  }\n  funcs[thisfunc].funcptr = func;\n  funcs[thisfunc].ftype = FT_VOIDP1INTP;\n  funcs[thisfunc].funcarg[0] = arg;\n  // do these only if not replacing an existing entry.\n  if (thisfunc == funccount) {\n    funcs[thisfunc].funcname = new char[strlen(name)+1];\n    strcpy(funcs[thisfunc].funcname, name);\n    funccount++;\n  }\n\n  // return successfully\n  rc = ESMF_SUCCESS;\n  return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setFuncArgs()\"\n//BOPI\n// !IROUTINE:  setFuncArgs - set arglist for existing function\n//\n// !INTERFACE:\nint FTable::setFuncArgs(\n//\n// !RETURN VALUE:\n//  int error return code\n//\n// !ARGUMENTS:\n    char const *name,      // in, function name\n    int acount,            // in, count of args\n    void **arglist) {      // in, address of arg list\n//\n// !DESCRIPTION:\n//    Sets the named function args.  The function must already exist.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize return code; assume routine not implemented\n  int localrc = ESMC_RC_NOT_IMPL;\n  int rc = ESMC_RC_NOT_IMPL;\n\n  // find the \"name\" entry\n  int i = getEntry(name, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    &rc)) return rc; // bail out\n\n  if (i == -1){\n    char msg[80];\n    sprintf(msg, \"unknown function name: %s\", name);\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, msg, ESMC_CONTEXT, &rc);\n    return rc; // bail out\n  }\n\n  // Check arglist argument\n  if (arglist == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n\n  // fill in arguments\n  for(int j=0; j<acount; j++)\n    funcs[i].funcarg[j] = arglist[j];\n\n  // return successfully\n  return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::callVFuncPtr()\"\n//BOPI\n// !IROUTINE:  callVFuncPtr - call a function w/ proper args\n//\n// !INTERFACE:\nint FTable::callVFuncPtr(\n//\n// !RETURN VALUE:\n//    integer return code\n//\n// !ARGUMENTS:\n  char const *name,     // in, function name\n  VM *vm_pointer,       // in, optional, pointer to this PET's VM instance\n  int *userrc) {        // out, function return code\n//\n// !DESCRIPTION:\n//    Calls the named function pointer\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // initialize return code; assume routine not implemented\n  int localrc = ESMC_RC_NOT_IMPL;         // local return code\n  int rc = ESMC_RC_NOT_IMPL;              // final return code\n\n  // sanity check userrc\n  if (!userrc){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n      \"- userrc must not be NULL pointer!\", ESMC_CONTEXT, &rc);\n    return rc; // bail out\n  }\n\n  // try to find \"name\" entry in single FTable instance on parent PET\n  int i = getEntry(name, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    &rc)) return rc; // bail out\n\n  Comp *comp;       // pointer to PET-local component\n  funcinfo *func;   // pointer to PET-local function entry\n\n  // optionally insert vm and replicate Component object, according to situation\n  if (vm_pointer){\n    // vm_pointer was provided -> use to set VM in Component object\n    VM *vmm = vm_pointer;\n    VM **vm = &vmm;\n    int mypet = vm_pointer->getMypet();\n    int mynthreads = vm_pointer->getNthreads(mypet);\n    int mytid = vm_pointer->getTid(mypet);\n    if (componentcount==0){\n      // first time Component is entering its VM -> replicate Comp\n      if (i == -1){\n        // single FTable instance on parent PET must have contained name\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"unknown function name\", ESMC_CONTEXT, &rc);\n        return rc; // bail out\n      }\n      func = funcs + i; // determine PET-local function entry\n      vm_pointer->threadbarrier();  // wait for all the threads to have entered\n      if (mytid==0){\n        // master thread allocates component list in FTable\n        component = new Comp[mynthreads];\n        componentcount = mynthreads;\n        vm_pointer->threadbarrier();  // synchronize with slave threads\n        comp = component;   // determine PET-local component\n        // make a copy of the component reference\n        FTN_X(f_esmf_comprefcopy)(comp, (Comp *)(func->funcarg[0]), &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n          ESMC_CONTEXT, &rc)) return rc; // bail out\n        // insert child VM\n        FTN_X(f_esmf_compinsertvm)(comp, vm, &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n          ESMC_CONTEXT, &rc)) return rc; // bail out\n      }else{\n        // slave thread -> replicate component structure, insert child VM\n        vm_pointer->threadbarrier();  // synchronize with master thread\n        // replicate Component from the parent PET w/ private FTable, insert VM\n        comp = component + mytid; // determine PET-local component\n        FTN_X(f_esmf_compreplicate)(comp, (Comp *)(func->funcarg[0]), vm,\n          &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n          ESMC_CONTEXT, &rc)) return rc; // bail out\n      }\n    }else if (i>-1){\n      // not first time entry, but found name in FTable\n      // -> must be SetServices _again_\n      func = funcs + i; // determine PET-local function entry\n      comp = component + mytid; // determine PET-local component\n    }else if (componentcount == mynthreads){\n      // subsequent time Component is entering its VM -> obtain comp\n      comp = component + mytid; // determine PET-local component\n      FTable *ftable = **(FTable ***)comp;  // determine comp's FTable instance\n      int j = ftable->getEntry(name, &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, &rc)) return rc; // bail out\n      if (j == -1){\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"unknown function name\", ESMC_CONTEXT, &rc);\n        return rc; // bail out\n      }\n      func = ftable->funcs + j; // determine PET-local function entry\n    }else{\n      // fatal inconsistent situation\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"fatal inconsistency between Component and VM\", ESMC_CONTEXT, &rc);\n      return rc;\n    }\n  }else{\n    // vm_pointer was not provided -> simple call-back without VM insertion\n    func = funcs + i; // determine PET-local function entry\n    comp = (Comp *)(func->funcarg[0]);\n  }\n\n  // call-back into user code\n  switch (func->ftype){\n    case FT_VOIDP1INTP: {\n      //printf(\"calling out of case FT_VOIDP1INTP\\n\");\n      VoidP1IntPFunc vf = (VoidP1IntPFunc)func->funcptr;\n      (*vf)((void *)comp, userrc);\n      // conditionally set entry point for ServiceLoop\n      if (!strcmp(name, methodString(METHOD_SETSERVICES))){\n        localrc = comp->setEntryPoint(METHOD_SERVICELOOP, ServiceLoop);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n          ESMC_CONTEXT, &rc)) return rc; // bail out\n      }\n      // conditionally call into compliance IC for register\n      if (!strcmp(name, methodString(METHOD_SETSERVICES))){\n        char const *envVar = VM::getenv(\"ESMF_RUNTIME_COMPLIANCECHECK\");\n        bool complianceCheckFlag = false;  // default internal compl. check off\n        if (envVar != NULL){\n          string value(envVar);\n          // see if compliance checker should be turned on\n          complianceCheckFlag |= value.find(\"on\")!=string::npos;  // turn on\n          complianceCheckFlag |= value.find(\"ON\")!=string::npos;  // turn on\n        }\n\n        //if tracing enabled, turn on compliance checker\n        if (!complianceCheckFlag) {\n          envVar = VM::getenv(\"ESMF_RUNTIME_TRACE\");    \n          if (envVar != NULL){\n            string value(envVar);\n\n            if (value.find(\"on\")!=string::npos ||\n                value.find(\"ON\")!=string::npos) {\n\n              complianceCheckFlag = true;\n\n              //if component-level tracing is off, do not\n              //hook in compliance checker\n              envVar = VM::getenv(\"ESMF_RUNTIME_TRACE_COMPONENT\");\n              if (envVar != NULL) {\n                string valueComponent(envVar);\n                if (valueComponent.find(\"off\")!=string::npos ||\n                    valueComponent.find(\"OFF\")!=string::npos) {\n                  complianceCheckFlag = false;\n                }\n              }\n            }\n          }\n        }\n        \n        if (complianceCheckFlag){\n          int registerIcUserRc;\n\n          // inspect the ESMF_RUNTIME_COMPLIANCEICOBJECT attribute on comp\n          ESMC_Base *base;\n          localrc = comp->getBase(&base);\n          if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n            ESMC_CONTEXT, &rc)) return rc; // bail out\n          ESMC_Logical presentFlag;\n          base->ESMC_BaseGetRoot()->AttributeIsPresent(\"ESMF_RUNTIME_COMPLIANCEICREGISTER\",\n            &presentFlag);\n\n//#ifdef ESMF_NO_DLFCN\n          //if (presentFlag==ESMF_TRUE){\n          //  presentFlag==ESMF_FALSE;\n          //  ESMC_LogDefault.Write(\"Ignoring ESMF_RUNTIME_COMPLIANCEICREGISTER \"\n          //   \"Attribute due to no dynamic linking.\", ESMC_LOGMSG_WARN);\n          //}\n//#endif\n\n\n          if (presentFlag==ESMF_TRUE){\n\n            // access the attribute object in base\n            ESMCI::Attribute *attr=base->ESMC_BaseGetRoot()->AttributeGet(\n              \"ESMF_RUNTIME_COMPLIANCEICREGISTER\");\n\n            // retrieve the string value of the attribute\n            std::vector<string> value;\n            localrc = attr->get(&value);\n            if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n              ESMC_CONTEXT, &rc)) return rc; // bail out\n\n            // check the number of strings associated with the attribute\n            if (value.size()!=1){\n              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                \"Attribute must contain single string\", ESMC_CONTEXT, &rc);\n              return rc;\n            }\n\n            // convert routine name according to name mangeling mode\n            //TODO: this would be a good Util method to have\n#ifdef ESMF_LOWERCASE_DOUBLEUNDERSCORE\n            std::transform(value[0].begin(), value[0].end(), value[0].begin(),\n              ::tolower);\n            value[0]+=\"__\";\n#else\n            std::transform(value[0].begin(), value[0].end(), value[0].begin(),\n              ::tolower);\n            value[0]+=\"_\";\n#endif\n\n#if 0\nstd::cout << \"ESMF_RUNTIME_COMPLIANCEICREGISTER attribute:\" << value[0] <<\"\\n\";\n#endif\n\n#ifndef ESMF_NO_DLFCN\n            // check and see if an alternate compliance ic object was specified\n            envVar = VM::getenv(\"ESMF_RUNTIME_COMPLIANCEICOBJECT\");\n            void *lib;\n            lib = dlopen(envVar, RTLD_LAZY);  // envVar==NULL -> look into exe\n            if (lib == NULL){\n              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                \"- shared object not found\", ESMC_CONTEXT, &rc);\n              return rc;\n            }\n            void *pointer = (void *)dlsym(lib, value[0].c_str());\n            if (pointer == NULL){\n              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                \"- compliance IC register routine not found\", ESMC_CONTEXT, &rc);\n              return rc;\n            }\n\n            VoidP1IntPFunc vf = (VoidP1IntPFunc)pointer;\n            (*vf)((void *)comp, &registerIcUserRc);\n            // compliance IC for register is an internal routine -> look at rc\n            if (ESMC_LogDefault.MsgFoundError(registerIcUserRc,\n              ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &rc)) return rc; // bail out\n#else\n            //here the compliance register routine has been specified\n            //on the attribute, but we do not have dlopen available\n            //therefore, go for a blind call assuming the NUOPC register\n            //routines have been linked in, which is typically the case\n\n            //std::cout << \"ESMF_RUNTIME_COMPLIANCEICREGISTER attribute:\" << value[0] <<\"\\n\";\n            if (value[0].find(\"nuopc_model\") != std::string::npos) {\n                FTN_X(nuopc_model_complianceicr)((void *)comp, &registerIcUserRc);\n                if (ESMC_LogDefault.MsgFoundError(registerIcUserRc,\n                              ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &rc)) return rc; // bail out\n            }\n            else if (value[0].find(\"nuopc_driver\") != std::string::npos) {\n                FTN_X(nuopc_driver_complianceicr)((void *)comp, &registerIcUserRc);\n                if (ESMC_LogDefault.MsgFoundError(registerIcUserRc,\n                              ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &rc)) return rc; // bail out\n            }\n            else if (value[0].find(\"nuopc_connector\") != std::string::npos) {\n                FTN_X(nuopc_connector_complianceicr)((void *)comp, &registerIcUserRc);\n                if (ESMC_LogDefault.MsgFoundError(registerIcUserRc,\n                              ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &rc)) return rc; // bail out\n            }\n            else {\n                ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                   \"- compliance IC register routine not found\", ESMC_CONTEXT, &rc);\n                return rc;\n            }\n#endif\n\n          }else{\n            //TODO: In the long run the else branch could be refactored with\n            //TODO: the if branch. Both in principle should be using dlopen()\n            //TODO: for DLFCN based lookup. However, we do not currently build\n            //TODO: correct PIC on all combos for which we have DLFCN enabled,\n            //TODO: and so lookup inside the executable is not yet guaranteed.\n            //TODO: Until this is fixed, the else branch will use hardcoded\n            //TODO: Fortran function directly.\n#define ESMF_NO_DLFCNdummy\n\n#ifdef ESMF_NO_DLFCNdummy\n            FTN_X(esmf_complianceicregister)((void *)comp, &registerIcUserRc);\n\n#else\n#define QUOTEMACRO_(x) #x\n#define QUOTEMACRO(x) QUOTEMACRO_(x)\n\n            envVar = VM::getenv(\"ESMF_RUNTIME_COMPLIANCEICOBJECT\");\n            void *lib;\n            lib = dlopen(envVar, RTLD_LAZY);  // envVar==NULL -> look into exe\n            if (lib == NULL){\n              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                \"- shared object not found\", ESMC_CONTEXT, &rc);\n              return rc;\n            }\n            envVar = VM::getenv(\"ESMF_RUNTIME_COMPLIANCEICREGISTER\");\n            void *pointer;\n            if (envVar != NULL)\n              pointer = (void *)dlsym(lib, envVar);\n            else\n              pointer = (void *)dlsym(lib,\n                QUOTEMACRO(FTN(esmf_complianceicregister)) );\n            if (pointer == NULL){\n              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                \"- compliance IC register routine not found\", ESMC_CONTEXT, &rc);\n              return rc;\n            }\n\n            VoidP1IntPFunc vf = (VoidP1IntPFunc)pointer;\n            (*vf)((void *)comp, &registerIcUserRc);\n#endif\n\n            // compliance IC for register is an internal routine -> look at rc\n            if (ESMC_LogDefault.MsgFoundError(registerIcUserRc,\n              ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &rc)) return rc; // bail out\n          }\n        }\n      }\n\n      break;\n    }\n    case FT_VOIDP4INTP: {\n      //printf(\"calling out of case FT_VOIDP4INTP\\n\");\n      VoidP4IntPFunc vf = (VoidP4IntPFunc)func->funcptr;\n      (*vf)((void *)comp, func->funcarg[1], func->funcarg[2],\n        func->funcarg[3], userrc);\n      break;\n    }\n    default:\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"unknown function type\", ESMC_CONTEXT, &rc);\n      return rc;\n  }\n\n  // return successfully\n  return ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::extend()\"\n//BOPI\n// !IROUTINE:  extend - make space for additional functions/data\n//\n// !INTERFACE:\nint FTable::extend(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      int nfuncp,     // in, number of functions which will be added\n      int ndatap) {   // in, number of data pointers which will be added\n//\n// !DESCRIPTION:\n//\n//EOPI\n//-----------------------------------------------------------------------------\n    // Initialize return code; assume routine not implemented\n    int rc = ESMC_RC_NOT_IMPL;\n\n    // TODO: allocate space for N items, rounded up?\n    if (nfuncp > funcalloc) {\n        funcs = (funcinfo *)realloc((void *)funcs, nfuncp * sizeof(funcinfo));\n        funcalloc = nfuncp;\n    }\n    if (ndatap > dataalloc) {\n        data = (datainfo *)realloc((void *)data, ndatap * sizeof(datainfo));\n        dataalloc = ndatap;\n    }\n\n    //printf(\"TableExtend called, sizeof(funcinfo)=%d, sizeof(datainfo)=%d\\n\",\n    //                            sizeof(funcinfo), sizeof(datainfo));\n    rc = ESMF_SUCCESS;\n    return rc;\n\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::query()\"\n//BOPI\n// !IROUTINE:  query - return count of functions/data\n//\n// !INTERFACE:\nint FTable::query(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      int *nfuncp,     // out, number of functions which will be added\n      int *ndatap) {   // out, number of data pointers which will be added\n//\n// !DESCRIPTION:\n//\n//EOPI\n//-----------------------------------------------------------------------------\n    // Initialize return code; assume routine not implemented\n    int rc = ESMC_RC_NOT_IMPL;\n\n    // fill in values\n    *nfuncp = funccount;\n    *ndatap = datacount;\n\n    //printf(\"TableQuery method called \\n\");\n    rc = ESMF_SUCCESS;\n    return rc;\n\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::validate()\"\n//BOPI\n// !IROUTINE:  validate - internal consistency check for a Component\n//\n// !INTERFACE:\nint FTable::validate(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      char const *options) const {    // in - validate options\n//\n// !DESCRIPTION:\n//      Validates that a Component is internally consistent.\n//      Returns error code if problems are found.  Base class method.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n    // Initialize return code; assume routine not implemented\n    int rc = ESMC_RC_NOT_IMPL;\n\n    return ESMC_RC_NOT_IMPL;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::print()\"\n//BOPI\n// !IROUTINE:  print - print contents of a Component\n//\n// !INTERFACE:\nint FTable::print(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      char const *options) const {     //  in - print options\n//\n// !DESCRIPTION:\n//      Print information about a Component.  The options control the\n//      type of information and level of detail.  Base class method.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n    // Initialize return code; assume routine not implemented\n    int rc = ESMC_RC_NOT_IMPL;\n\n    return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable()\"\n//BOPI\n// !IROUTINE:  FTable - native C++ constructor\n//\n// !INTERFACE:\nFTable::FTable(\n//\n// !RETURN VALUE:\n//  none\n//\n// !ARGUMENTS:\n    void){\n//\n// !DESCRIPTION:\n//  Native constructor.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  //printf(\"in ftable constructor\\n\");\n  funccount = 0;\n  funcalloc = 0;\n  funcs = NULL;\n  datacount = 0;\n  dataalloc = 0;\n  data = NULL;\n  componentcount = 0;\n  component = NULL;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"~ESMCI::FTable()\"\n//BOPI\n// !IROUTINE:  ~FTable - native C++ destructor\n//\n// !INTERFACE:\nFTable::~FTable(void) {\n//\n// !RETURN VALUE:\n//  none\n//\n// !ARGUMENTS:\n//  none\n//\n// !DESCRIPTION:\n//  Native destructor - deleting internal allocations\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  for (int i=0; i<funccount; i++)\n    funcs[i].~funcinfo();\n  free(funcs);\n  funccount = 0;\n  funcalloc = 0;\n  funcs = NULL;\n\n  for (int i=0; i<datacount; i++)\n    data[i].~datainfo();\n  free(data);\n  datacount = 0;\n  dataalloc = 0;\n  data = NULL;\n\n  for (int i=1; i<componentcount; i++){\n    // skip i=0 since that is identical to the actual Component object\n    Comp *comp = component + i;\n    FTable *ftable = **(FTable ***)comp;\n    delete ftable;\n    ftable = NULL;\n    int localrc;\n    FTN_X(f_esmf_compdelete)(comp, &localrc);\n  }\n  delete [] component;\n  component = NULL;\n}\n//-----------------------------------------------------------------------------\n\n//==============================================================================\n//\n// this trim routine does several things:\n//\n// most importantly, it null terminates a counted-char string passed in\n// from fortran.  it's not guarenteed you can write into the N+1th\n// character location (if the string is full length in fortran, for example)\n// so we're forced to make a copy and copy into it.  this routine allocates,\n// so the char string created here MUST be deleted by the caller when finished.\n//\n// secondly, the phase number (init 1, init 2, etc) is passed in as an int.\n// if > 0 this routine turns it into a 2-char string filled with\n// leading 0s and tacks it onto the end of the name to make it unique.\n//\n// and finally, component routines can be called with either a single\n// state or a pair of states. we can require that the user specify the\n// interface at registration time, or we can decide at run time which\n// form was called and dispatch the corresponding entry point.\n// for now i'm going to fill both types of component entry points for each\n// registration.  i can always remove that code if we force the user\n// to specify at registration time what format the states are expected in.\n// so if nstate > 0, it gets the same treatment as phase: it's turned into\n// a single char string and tacked on the end.\n//\n// (we'd also at some point like to be able to pass back into fortran\n// a really type(State) F90 array - but the bytes on the stack are\n// compiler dependent - we'd have to create the array in fortran and\n// save a copy of it to be safe.  that code is *NOT* implemented at this\n// point, but i know it would sure seem natural from the user's viewpoint.)\n//\n\n// this is max of 2 char phase + 'P' + 1 char nstate + 'S' + trailing NULL\n#define MAXPAD 8\n\nvoid FTable::newtrim(char const *oldc, int clen, int *phase, int *nstate,\n  char **newc) {\n  char *cp, *ctmp;\n  int hasphase = 0;\n  int hasstate = 0;\n  char tspace[MAXPAD];\n  int pad=2;         // if neither phase nor nstate, still need term NULL\n\n  //printf(\"in newtrim, oldc = '%s', clen = %d\\n\", oldc, clen);\n\n  // warning - on the intel compiler, optional args come in\n  // as -1, not 0.  check for both before dereferencing.\n  if ((phase != NULL) && (phase != (int *)-1) && (*phase >= 0))  {\n    pad = MAXPAD;\n    hasphase++;\n  }\n\n  // warning - on the intel compiler, optional args come in\n  // as -1, not 0.  check for both before dereferencing.\n  // if state > 0, use it to alter the EP name.\n  if ((nstate != NULL) && (nstate != (int *)-1) && (*nstate > 0))  {\n    pad = MAXPAD;\n    hasstate++;\n  }\n\n  // make new space and leave room for at least a null terminator, more\n  // if it has either phase or num states or both.\n  ctmp = new char[clen+pad];\n  strncpy(ctmp, oldc, clen);\n  ctmp[clen] = '\\0';\n  for (cp = &ctmp[clen-1]; *cp == ' '; cp--)   // trim() trailing blanks\n    *cp = '\\0';\n\n  // tack on trailing numbers if phase or nstate\n  if (hasphase && hasstate) {\n    sprintf(tspace, \"%02dP%1dS\", *phase, *nstate);\n    strcat(ctmp, tspace);\n  } else if (hasphase) {\n    sprintf(tspace, \"%02dP\", *phase);\n    strcat(ctmp, tspace);\n  } else if (hasstate) {\n    sprintf(tspace, \"%1dS\", *nstate);\n    strcat(ctmp, tspace);\n  }\n\n  // set return pointer.  caller MUST free this when finished with it.\n  *newc = ctmp;\n  //printf(\"out newtrim, newc = '%s'\\n\", *newc);\n\n  return;\n}\n//==============================================================================\n\n\n//==============================================================================\nchar const *FTable::methodString(enum ESMCI::method method){\n  switch(method){\n  case ESMCI::METHOD_NONE:\n    return \"None\";\n    break;\n  case ESMCI::METHOD_INITIALIZE:\n    return \"Initialize\";\n    break;\n  case ESMCI::METHOD_RUN:\n    return \"Run\";\n    break;\n  case ESMCI::METHOD_FINALIZE:\n    return \"Finalize\";\n    break;\n  case ESMCI::METHOD_WRITERESTART:\n    return \"WriteRestart\";\n    break;\n  case ESMCI::METHOD_READRESTART:\n    return \"ReadRestart\";\n    break;\n  case ESMCI::METHOD_SERVICELOOP:\n    return \"ServiceLoop\";\n    break;\n  case ESMCI::METHOD_INITIALIZEIC:\n    return \"InitializeIC\";\n    break;\n  case ESMCI::METHOD_RUNIC:\n    return \"RunIC\";\n    break;\n  case ESMCI::METHOD_FINALIZEIC:\n    return \"FinalizeIC\";\n    break;\n  case ESMCI::METHOD_WRITERESTARTIC:\n    return \"WriteRestartIC\";\n    break;\n  case ESMCI::METHOD_READRESTARTIC:\n    return \"ReadRestartIC\";\n    break;\n  case ESMCI::METHOD_SERVICELOOPIC:\n    return \"ServiceLoopIC\";\n    break;\n  case ESMCI::METHOD_SETSERVICES:\n    return \"Register\";\n    break;\n  case ESMCI::METHOD_WAIT:\n    return \"Wait\";\n    break;\n  default:\n    return \"Unknown\";\n    break;\n  }\n  return NULL;\n}\n//==============================================================================\n\n//==============================================================================\nenum method FTable::methodFromString(char const *methodString){\n  if (!strncmp(methodString, \"InitializeIC\", strlen(\"InitializeIC\")))\n    return ESMCI::METHOD_INITIALIZEIC;\n  else if (!strncmp(methodString, \"RunIC\", strlen(\"RunIC\")))\n    return ESMCI::METHOD_RUNIC;\n  else if (!strncmp(methodString, \"FinalizeIC\", strlen(\"FinalizeIC\")))\n    return ESMCI::METHOD_FINALIZEIC;\n  else if (!strncmp(methodString, \"WriteRestartIC\", strlen(\"WriteRestartIC\")))\n    return ESMCI::METHOD_WRITERESTARTIC;\n  else if (!strncmp(methodString, \"ReadRestartIC\", strlen(\"ReadRestartIC\")))\n    return ESMCI::METHOD_READRESTARTIC;\n  else if (!strncmp(methodString, \"Initialize\", strlen(\"Initialize\")))\n    return ESMCI::METHOD_INITIALIZE;\n  else if (!strncmp(methodString, \"Run\", strlen(\"Run\")))\n    return ESMCI::METHOD_RUN;\n  else if (!strncmp(methodString, \"Finalize\", strlen(\"Finalize\")))\n    return ESMCI::METHOD_FINALIZE;\n  else if (!strncmp(methodString, \"WriteRestart\", strlen(\"WriteRestart\")))\n    return ESMCI::METHOD_WRITERESTART;\n  else if (!strncmp(methodString, \"ReadRestart\", strlen(\"ReadRestart\")))\n    return ESMCI::METHOD_READRESTART;\n  else if (!strncmp(methodString, \"Register\", strlen(\"Register\")))\n    return ESMCI::METHOD_SETSERVICES;\n  return ESMCI::METHOD_NONE;\n}\n//==============================================================================\n\n//==============================================================================\nenum method FTable::methodFromIndex(int i){\n  return methodFromString(funcs[i].funcname);\n}\n//==============================================================================\n\n} // namespace ESMCI\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile4.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/Field/tests/data/C48_mosaic.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile1.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile3.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/Field/tests/data/weights_generic.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile5.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile6.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile2.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/IO/tests/T42_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/IO/tests/io_netcdf_testdata.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/IO/tests/GRIDSPEC_320x160.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/Mesh/tests/data/ne4np4-pentagons.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/Mesh/tests/data/ne4np4-esmf.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/Mesh/examples/data/ne4np4-pentagons.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/Mesh/examples/data/ne4np4-esmf.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/Grid/tests/data/T42_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Infrastructure/Grid/examples/data/T42_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Superstructure/PreESMFMod/tests/data/T42_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Superstructure/PreESMFMod/tests/data/BT42_ugrid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Superstructure/PreESMFMod/tests/data/ll2.5deg_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/Superstructure/PreESMFMod/tests/data/BT42_ugrid_dual.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/prologue/tests/ESMF_F95PtrUTest.F90",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/test_harness/catalog/sample.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/addon/MAPL5_1/src/GMAO_Shared/MAPL_Base/TeX/figs/geos5_esmf.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/addon/MAPL5_1/src/GMAO_Shared/MAPL_Base/TeX/figs/esmf_sandwich.png",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/addon/MAPL/MAPL_Base/TeX/figs/geos5_esmf.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/addon/MAPL/MAPL_Base/TeX/figs/esmf_sandwich.png",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/addon/ESMPy/src/ESMF/util/enum/doc/enum.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/addon/ESMPy/src/ESMF/test/data/T42_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/addon/ESMPy/src/ESMF/test/data/gridspec1Dcoords.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/addon/ESMPy/src/ESMF/test/data/ne4np4-pentagons.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-7.1.0r-xnrnc5ta6xalo3sgq35cm3hcmarg4m63/spack-src/src/addon/ESMPy/src/ESMF/test/data/ne4np4-esmf.nc"
    ],
    "total_files": 3263
}