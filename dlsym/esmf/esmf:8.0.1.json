{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/build/common.mk": "#  $Id$\n#===============================================================================\n#\n#  GNUmake makefile - cannot be used with standard unix make!!\n#\n#  This file is included by all platforms and all builds, where all builds\n#  include the ESMF Framework, the ESMF Implementation Report, and the\n#  ESMF EVA codes.  Each of those builds has a separate ../makefile, so\n#  any targets or rules which are specific to only a single build should\n#  be in the top level makefile and not here.\n#\n#  If you have changes which only apply to a single platform, look in\n#  ../build_config/<platform>/build_rules.mk  for the flags and libraries\n#  which are included on a per-platform/compiler/specific-site basis. \n# \n#  Be very careful in making changes here; it is hard to make sure you\n#  have not broken anything without testing all three build systems.\n#  If you must, please look below for the comment section with the\n#  label \"HOWTO\" before you dive in.\n#\n#===============================================================================\n\n#-------------------------------------------------------------------------------\n# Test for obsolete environment variables, print error and stop build here\n#-------------------------------------------------------------------------------\n\nifeq ($(origin ESMF_ARCH), environment)\n$(error Obsolete environment variable ESMF_ARCH detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_PREC), environment)\n$(error Obsolete environment variable ESMF_PREC detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_TOP_DIR), environment)\n$(error Obsolete environment variable ESMF_TOP_DIR detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_NODES), environment)\n$(error Obsolete environment variable ESMF_NODES detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_C_COMPILER), environment)\n$(error Obsolete environment variable ESMF_C_COMPILER detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_C_LIBRARY), environment)\n$(error Obsolete environment variable ESMF_C_LIBRARY detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_CXX_LIBRARY_PATH), environment)\n$(error Obsolete environment variable ESMF_CXX_LIBRARY_PATH detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_CXX_LIBRARIES), environment)\n$(error Obsolete environment variable ESMF_CXX_LIBRARIES detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_COMPILER_VERSION), environment)\n$(error Obsolete environment variable ESMF_COMPILER_VERSION detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_STDCXX_LIBRARY), environment)\n$(error Obsolete environment variable ESMF_STDCXX_LIBRARY detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_F90_LIBRARY_PATH), environment)\n$(error Obsolete environment variable ESMF_F90_LIBRARY_PATH detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_F90_LIBRARIES), environment)\n$(error Obsolete environment variable ESMF_F90_LIBRARIES detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_NO_LD_LIBRARY_PATH), environment)\n$(error Obsolete environment variable ESMF_NO_LD_LIBRARY_PATH detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_PROJECT), environment)\n$(error Obsolete environment variable ESMF_PROJECT detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_LIB_INSTALL), environment)\n$(error Obsolete environment variable ESMF_LIB_INSTALL detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_MOD_INSTALL), environment)\n$(error Obsolete environment variable ESMF_MOD_INSTALL detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_H_INSTALL), environment)\n$(error Obsolete environment variable ESMF_H_INSTALL detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_NO_IOCODE), environment)\n$(error Obsolete environment variable ESMF_NO_IOCODE detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_EXHAUSTIVE), environment)\n$(error Obsolete environment variable ESMF_EXHAUSTIVE detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_BATCH), environment)\n$(error Obsolete environment variable ESMF_BATCH detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_BATCHOPTIONS), environment)\n$(error Obsolete environment variable ESMF_BATCHOPTIONS detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_MPI), environment)\n$(error Obsolete environment variable ESMF_MPI detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_MPIRUNOPTIONS), environment)\n$(error Obsolete environment variable ESMF_MPIRUNOPTIONS detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\nifeq ($(origin ESMF_TESTHARNESS), environment)\n$(error Obsolete environment variable ESMF_TESTHARNESS detected. Please see ESMF README and/or User's Guide for a current list of ESMF environment variables.)\nendif\n\n#-------------------------------------------------------------------------------\n# Set defaults for environment variables that are not set\n#-------------------------------------------------------------------------------\n\nifndef ESMF_BUILD\nexport ESMF_BUILD = default\nendif\n\nifndef ESMF_OS\nexport ESMF_OS = default\nendif\n\nifndef ESMF_MACHINE\nexport ESMF_MACHINE = default\nendif\n\nifndef ESMF_ABI\nexport ESMF_ABI = default\nendif\n\nifndef ESMF_COMM\nexport ESMF_COMM = default\nendif\n\nifndef ESMF_COMPILER\nexport ESMF_COMPILER = default\nendif\n\nifndef ESMF_BOPT\nexport ESMF_BOPT = default\nendif\n\nifndef ESMF_OPTLEVEL\nexport ESMF_OPTLEVEL = default\nendif\n\nifndef ESMF_SITE\nexport ESMF_SITE = default\nendif\n\nifndef ESMF_PTHREADS\nexport ESMF_PTHREADS = $(ESMF_PTHREADSDEFAULT)\nendif\n\nifndef ESMF_OPENMP\nexport ESMF_OPENMP = $(ESMF_OPENMPDEFAULT)\nendif\n\nifndef ESMF_OPENACC\nexport ESMF_OPENACC = $(ESMF_OPENACCDEFAULT)\nendif\n\nifndef ESMF_ARRAY_LITE\nexport ESMF_ARRAY_LITE = default\nendif\n\nifndef ESMF_NO_INTEGER_1_BYTE\nexport ESMF_NO_INTEGER_1_BYTE = default\nendif\n\nifndef ESMF_NO_INTEGER_2_BYTE\nexport ESMF_NO_INTEGER_2_BYTE = default\nendif\n\nifndef ESMF_MAPPER_BUILD\nexport ESMF_MAPPER_BUILD = default\nendif\n\nifndef ESMF_AUTO_LIB_BUILD\nexport ESMF_AUTO_LIB_BUILD = default\nendif\n\nifndef ESMF_DEFER_LIB_BUILD\nexport ESMF_DEFER_LIB_BUILD = default\nendif\n\nifndef ESMF_SHARED_LIB_BUILD\nexport ESMF_SHARED_LIB_BUILD = default\nendif\n\nifndef ESMF_TRACE_LIB_BUILD\nexport ESMF_TRACE_LIB_BUILD = default\nendif\n\nifndef ESMF_FORTRANSYMBOLS\nexport ESMF_FORTRANSYMBOLS = default\nendif\n\nifndef ESMF_TESTEXHAUSTIVE\nexport ESMF_TESTEXHAUSTIVE = default\nendif\n\nifndef ESMF_TESTCOMPTUNNEL\nexport ESMF_TESTCOMPTUNNEL = default\nendif\n\nifndef ESMF_TESTWITHTHREADS\nexport ESMF_TESTWITHTHREADS = default\nendif\n\nifndef ESMF_TESTMPMD\nexport ESMF_TESTMPMD = default\nendif\n\nifndef ESMF_TESTSHAREDOBJ\nexport ESMF_TESTSHAREDOBJ = default\nendif\n\nifndef ESMF_TESTFORCEOPENMP\nexport ESMF_TESTFORCEOPENMP = default\nendif\n\nifndef ESMF_TESTFORCEOPENACC\nexport ESMF_TESTFORCEOPENACC = default\nendif\n\nifndef ESMF_TESTHARNESS_ARRAY\nexport ESMF_TESTHARNESS_ARRAY = default\nendif\n\nifndef ESMF_TESTHARNESS_FIELD\nexport ESMF_TESTHARNESS_FIELD = default\nendif\n\nifndef ESMF_ETCDIR\nexport ESMF_ETCDIR = default\nendif\n\nifndef ESMF_MOAB\nexport ESMF_MOAB = default\nendif\n\nifndef ESMF_YAMLCPP\nexport ESMF_YAMLCPP = default\nendif\n\nifndef ESMF_ACC_SOFTWARE_STACK\nexport ESMF_ACC_SOFTWARE_STACK = none\nendif\n\nifndef ESMF_CXXSTD\nexport ESMF_CXXSTD = default\nendif\n\n#-------------------------------------------------------------------------------\n# For some variables having the literal string \"default\" is ok; \n# for others, look for this string and override it.\n#-------------------------------------------------------------------------------\n\nifeq ($(ESMF_BUILD),default)\nexport ESMF_BUILD := $(ESMF_DIR)\nendif\n\nifeq ($(ESMF_OS),default)\nexport ESMF_OS := $(shell $(ESMF_DIR)/scripts/esmf_os)\nendif\n\nifeq ($(ESMF_OS),Linux)\n# set ESMF_MACHINE for Linux\nifeq ($(ESMF_MACHINE),default)\nexport ESMF_MACHINE := $(shell uname -m)\nendif\nendif\n\nifeq ($(ESMF_OS),Cygwin)\n# set ESMF_MACHINE for Cygwin\nifeq ($(ESMF_MACHINE),default)\nexport ESMF_MACHINE := $(shell uname -m)\nendif\nendif\n\nifeq ($(ESMF_OS),MinGW)\n# set ESMF_MACHINE for MinGW\nifeq ($(ESMF_MACHINE),default)\nexport ESMF_MACHINE := $(shell uname -m)\nendif\nendif\n\nifeq ($(ESMF_OS),Darwin)\n# set ESMF_MACHINE for Darwin\nifeq ($(ESMF_MACHINE),default)\nexport ESMF_MACHINE := $(shell uname -m)\n# uname -m on Darwin (at least up to 8.11.1) is seriously broken and will\n# always return i386 on any Intel system (it's hardcoded!)\nifeq ($(shell sysctl -n hw.optional.x86_64 2>&1),1)\nexport ESMF_MACHINE = x86_64\nendif\nendif\nendif\n\nifeq ($(ESMF_OS),Unicos)\n# set ESMF_MACHINE for Unicos\nifeq ($(ESMF_MACHINE),default)\nexport ESMF_MACHINE := $(shell uname -m)\nendif\nendif\n\nifeq ($(ESMF_ABI),default)\n# start with 64-bit default for all architectures\nexport ESMF_ABI = 64\n\nifeq ($(ESMF_OS),Linux)\n# default on Linux is 32-bit\nexport ESMF_ABI = 32\nifeq ($(ESMF_MACHINE),ia64)\n# except for IA64\nexport ESMF_ABI = 64\nendif\nifeq ($(ESMF_MACHINE),x86_64)\n# and x86_64\nexport ESMF_ABI = 64\nendif\nifeq ($(ESMF_MACHINE),ppc64)\n# and ppc64\nexport ESMF_ABI = 64\nendif\nifeq ($(ESMF_MACHINE),ppc64le)\n# and ppc64 little endian\nexport ESMF_ABI = 64\nendif\nendif\n\nifeq ($(ESMF_OS),Darwin)\n# default on Darwin is 32-bit\nexport ESMF_ABI = 32\nifeq ($(ESMF_MACHINE),x86_64)\n# except x86_64\nexport ESMF_ABI = 64\nendif\nendif\n\nifeq ($(ESMF_OS),Cygwin)\n# default on Cygwin is 32-bit\nexport ESMF_ABI = 32\nifeq ($(ESMF_MACHINE),x86_64)\n# and x86_64\nexport ESMF_ABI = 64\nendif\nendif\n\nifeq ($(ESMF_OS),MinGW)\n# default on MinGW is 64-bit\nexport ESMF_ABI = 64\nendif\n\nendif\n\n# by default ABISTRING is simply ABI\nESMF_ABISTRING = $(ESMF_ABI)\n\nifeq ($(ESMF_COMPILER),default)\nifeq ($(ESMF_OS),Cygwin)\nexport ESMF_COMPILER = gfortran\nendif\nifeq ($(ESMF_OS),Darwin)\nexport ESMF_COMPILER = absoft\nifeq ($(ESMF_MACHINE),i386)\nexport ESMF_COMPILER = gfortran\nendif\nifeq ($(ESMF_MACHINE),x86_64)\nexport ESMF_COMPILER = gfortran\nendif\nendif\nifeq ($(ESMF_OS),Linux)\nexport ESMF_COMPILER = gfortran\nendif\nifeq ($(ESMF_OS),MinGW)\nexport ESMF_COMPILER = gfortran\nendif\nifeq ($(ESMF_OS),Unicos)\nifeq ($(ESMF_MACHINE),x86_64)\nexport ESMF_COMPILER = pgi\nendif\nendif\nendif\n\nifeq ($(ESMF_BOPT),default)\nexport ESMF_BOPT = O\nendif\n\nifneq ($(ESMF_ARRAY_LITE),TRUE)\nexport ESMF_ARRAY_LITE = FALSE\nendif\n\nifneq ($(ESMF_NO_INTEGER_1_BYTE),FALSE)\nexport ESMF_NO_INTEGER_1_BYTE = TRUE\nendif\n\nifneq ($(ESMF_NO_INTEGER_2_BYTE),FALSE)\nexport ESMF_NO_INTEGER_2_BYTE = TRUE\nendif\n\nifneq ($(ESMF_TESTEXHAUSTIVE),ON)\nexport ESMF_TESTEXHAUSTIVE = OFF\nendif\n\nifneq ($(ESMF_MAPPER_BUILD),ON)\nexport ESMF_MAPPER_BUILD = OFF\nendif\n\nifneq ($(ESMF_AUTO_LIB_BUILD),OFF)\nexport ESMF_AUTO_LIB_BUILD = ON\nendif\n\nifneq ($(ESMF_DEFER_LIB_BUILD),OFF)\nexport ESMF_DEFER_LIB_BUILD = ON\nendif\n\nifneq ($(ESMF_SHARED_LIB_BUILD),OFF)\nexport ESMF_SHARED_LIB_BUILD = ON\nendif\n\nifneq ($(ESMF_TRACE_LIB_BUILD),OFF)\nexport ESMF_TRACE_LIB_BUILD = ON\nendif\n\nifneq ($(ESMF_TESTCOMPTUNNEL),OFF)\nexport ESMF_TESTCOMPTUNNEL = ON\nendif\n\nifneq ($(ESMF_TESTWITHTHREADS),ON)\nexport ESMF_TESTWITHTHREADS = OFF\nendif\n\nifneq ($(ESMF_TESTMPMD),ON)\nexport ESMF_TESTMPMD = OFF\nendif\n\nifneq ($(ESMF_TESTSHAREDOBJ),ON)\nexport ESMF_TESTSHAREDOBJ = OFF\nendif\n\nifneq ($(ESMF_TESTFORCEOPENMP),ON)\nexport ESMF_TESTFORCEOPENMP = OFF\nendif\n\nifneq ($(ESMF_TESTFORCEOPENACC),ON)\nexport ESMF_TESTFORCEOPENACC = OFF\nendif\n\nifeq ($(ESMF_ETCDIR),default)\nexport ESMF_ETCDIR = $(ESMF_BUILD)/src/etc\nendif\n\nifeq ($(ESMF_MOAB),default)\nexport ESMF_MOAB = internal\nendif\n\nifeq ($(ESMF_YAMLCPP),default)\nexport ESMF_YAMLCPP = internal\nendif\n\n#-------------------------------------------------------------------------------\n# If INSTALL environment variables are not set give them default values\n#-------------------------------------------------------------------------------\n\nifndef ESMF_INSTALL_PREFIX\nESMF_INSTALL_PREFIX := ./DEFAULTINSTALLDIR\nendif\nESMF_INSTALL_PREFIX_ABSPATH := $(shell $(ESMF_DIR)/scripts/abspath $(ESMF_INSTALL_PREFIX))\n\nifndef ESMF_INSTALL_HEADERDIR\nESMF_INSTALL_HEADERDIR := include\nendif\npathtype := $(shell $(ESMF_DIR)/scripts/pathtype $(ESMF_INSTALL_HEADERDIR))\nifeq ($(pathtype),rel)\nexport ESMF_INSTALL_HEADERDIR_ABSPATH = $(ESMF_INSTALL_PREFIX_ABSPATH)/$(ESMF_INSTALL_HEADERDIR)\nelse\nexport ESMF_INSTALL_HEADERDIR_ABSPATH = $(ESMF_INSTALL_HEADERDIR)\nendif\n\nifndef ESMF_INSTALL_MODDIR\nESMF_INSTALL_MODDIR = mod/mod$(ESMF_BOPT)/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_ABI).$(ESMF_COMM).$(ESMF_SITE)\nendif\npathtype := $(shell $(ESMF_DIR)/scripts/pathtype $(ESMF_INSTALL_MODDIR))\nifeq ($(pathtype),rel)\nexport ESMF_INSTALL_MODDIR_ABSPATH = $(ESMF_INSTALL_PREFIX_ABSPATH)/$(ESMF_INSTALL_MODDIR)\nelse\nexport ESMF_INSTALL_MODDIR_ABSPATH = $(ESMF_INSTALL_MODDIR)\nendif\n\nifndef ESMF_INSTALL_LIBDIR\nESMF_INSTALL_LIBDIR = lib/lib$(ESMF_BOPT)/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_ABI).$(ESMF_COMM).$(ESMF_SITE)\nendif\npathtype := $(shell $(ESMF_DIR)/scripts/pathtype $(ESMF_INSTALL_LIBDIR))\nifeq ($(pathtype),rel)\nexport ESMF_INSTALL_LIBDIR_ABSPATH = $(ESMF_INSTALL_PREFIX_ABSPATH)/$(ESMF_INSTALL_LIBDIR)\nelse\nexport ESMF_INSTALL_LIBDIR_ABSPATH = $(ESMF_INSTALL_LIBDIR)\nendif\n\nifndef ESMF_INSTALL_BINDIR\nESMF_INSTALL_BINDIR = bin/bin$(ESMF_BOPT)/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_ABI).$(ESMF_COMM).$(ESMF_SITE)\nendif\npathtype := $(shell $(ESMF_DIR)/scripts/pathtype $(ESMF_INSTALL_BINDIR))\nifeq ($(pathtype),rel)\nexport ESMF_INSTALL_BINDIR_ABSPATH = $(ESMF_INSTALL_PREFIX_ABSPATH)/$(ESMF_INSTALL_BINDIR)\nelse\nexport ESMF_INSTALL_BINDIR_ABSPATH = $(ESMF_INSTALL_BINDIR)\nendif\n\nifndef ESMF_INSTALL_DOCDIR\nESMF_INSTALL_DOCDIR := doc\nendif\npathtype := $(shell $(ESMF_DIR)/scripts/pathtype $(ESMF_INSTALL_DOCDIR))\nifeq ($(pathtype),rel)\nexport ESMF_INSTALL_DOCDIR_ABSPATH = $(ESMF_INSTALL_PREFIX_ABSPATH)/$(ESMF_INSTALL_DOCDIR)\nelse\nexport ESMF_INSTALL_DOCDIR_ABSPATH = $(ESMF_INSTALL_DOCDIR)\nendif\n\n#-------------------------------------------------------------------------------\n# Set ESMFMKFILE here in order to be available for installcheck target\n#-------------------------------------------------------------------------------\nifneq ($(ESMF_TESTESMFMKFILE),ON)\nexport ESMFMKFILE = $(ESMF_INSTALL_LIBDIR_ABSPATH)/esmf.mk\nendif\n\n\n#-------------------------------------------------------------------------------\n# If BENCHMARK directory, Tolerance, Threshold are  not set give them a default value\n#-------------------------------------------------------------------------------\n\nifndef ESMF_BENCHMARK_PREFIX\nESMF_BENCHMARK_PREFIX := ./DEFAULTBENCHMARKDIR\nendif\nESMF_BENCHMARK_PREFIX_ABSPATH := $(shell $(ESMF_DIR)/scripts/abspath $(ESMF_BENCHMARK_PREFIX))\n\n\nifndef ESMF_BENCHMARK_TOLERANCE\nESMF_BENCHMARK_TOLERANCE := 20%\nendif\n\nifndef ESMF_BENCHMARK_THRESHOLD\nESMF_BENCHMARK_THRESHOLD_MSEC := 500\nendif\n\n#-------------------------------------------------------------------------------\n# Set ESMF Version variables\n#-------------------------------------------------------------------------------\nESMF_VERSION_STRING = `fgrep ESMF_VERSION_STRING $(ESMF_DIR)/src/Infrastructure/Util/include/ESMC_Macros.h | $(ESMF_SED) -e 's/.* \\\"//' -e 's/\\\"//' `\n\nESMF_VERSION_MAJOR = `fgrep ESMF_VERSION_MAJOR $(ESMF_DIR)/src/Infrastructure/Util/include/ESMC_Macros.h | $(ESMF_SED) -e 's/.* //' `\n\nESMF_VERSION_MINOR = `fgrep ESMF_VERSION_MINOR $(ESMF_DIR)/src/Infrastructure/Util/include/ESMC_Macros.h | $(ESMF_SED) -e 's/.* //' `\n\nESMF_VERSION_REVISION = `fgrep ESMF_VERSION_REVISION $(ESMF_DIR)/src/Infrastructure/Util/include/ESMC_Macros.h | $(ESMF_SED) -e 's/.* //' `\n\nESMF_VERSION_PATCHLEVEL = `fgrep ESMF_VERSION_PATCHLEVEL $(ESMF_DIR)/src/Infrastructure/Util/include/ESMC_Macros.h | $(ESMF_SED) -e 's/.* //' `\n\nESMF_VERSION_PUBLIC = `fgrep ESMF_VERSION_PUBLIC $(ESMF_DIR)/src/Infrastructure/Util/include/ESMC_Macros.h | $(ESMF_SED) -e 's/.* //' `\n\nESMF_VERSION_BETASNAPSHOT = `fgrep ESMF_VERSION_BETASNAPSHOT $(ESMF_DIR)/src/Infrastructure/Util/include/ESMC_Macros.h | $(ESMF_SED) -e 's/.* //' `\n\n#-------------------------------------------------------------------------------\n# TODO: in general ESMF_BUILD is respected - most generated files are created\n# underneath ESMF_BUILD and not ESMF_DIR.  but there are exceptions.\n# the ones i know about are:  \n# - in the build_config/platform-specific directories are config header files, \n# so if these config files are moved, a -I flag will also have to be updated to \n# point to the new location.  the complication is that since these are per-platform files\n# and since we promise to support building for multiple architectures from\n# the same source tree, these files cannot go into a generic include dir.\n# - the 'storeh:' target copies include files into src/include under the\n# distribution tree.  \n# - the system tests (not sure about the unit tests and examples) \n# are compiled with the current dir set to the src dir (this is\n# i think because if there are multiple .o files, it gets complicated to make\n# them, get their names to link them, and then remove just them if you are \n# working in the test or examples dir - but still, it should be fixed.)\n#-------------------------------------------------------------------------------\n\n\n#-------------------------------------------------------------------------------\n# Keep this variable for now until rules are fixed to work without.\nexport ESMF_BATCHDEPRECATED = false\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n# Common variables\n#-------------------------------------------------------------------------------\n\n# same as ESMF_LIBDIR\nESMF_LDIR\t= $(ESMF_BUILD)/lib/lib$(ESMF_BOPT)/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_ABI).$(ESMF_COMM).$(ESMF_SITE)\n\n# library directory\nESMF_LIBDIR     = $(ESMF_BUILD)/lib/lib$(ESMF_BOPT)/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_ABI).$(ESMF_COMM).$(ESMF_SITE)\n\n# f90 module directory\nESMF_MODDIR     = $(ESMF_BUILD)/mod/mod$(ESMF_BOPT)/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_ABI).$(ESMF_COMM).$(ESMF_SITE)\n\n# object directory\nifeq ($(ESMF_DEFER_LIB_BUILD),ON)\nESMF_OBJDIR     = $(ESMF_BUILD)/obj/obj$(ESMF_BOPT)/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_ABI).$(ESMF_COMM).$(ESMF_SITE)\nelse\nESMF_OBJDIR     = $(ESMF_MODDIR)\nendif\n\n# local obj dir\nESMF_LOCOBJDIR = $(ESMF_OBJDIR)/$(LOCDIR)\n\n# test executable directory\nESMF_TESTDIR    = $(ESMF_BUILD)/test/test$(ESMF_BOPT)/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_ABI).$(ESMF_COMM).$(ESMF_SITE)\n\n# example executable diretory\nESMF_EXDIR      = $(ESMF_BUILD)/examples/examples$(ESMF_BOPT)/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_ABI).$(ESMF_COMM).$(ESMF_SITE)\n\n# apps executable directory\nESMF_APPSDIR     = $(ESMF_BUILD)/apps/apps$(ESMF_BOPT)/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_ABI).$(ESMF_COMM).$(ESMF_SITE)\n\n# include file directory\nESMF_INCDIR     = $(ESMF_BUILD)/src/include\n\n# Infrastructure/Superstructure incs\nESMF_INTERNALINCDIRS  = -I$(ESMF_BUILD)/src/Infrastructure -I$(ESMF_BUILD)/src/Superstructure\n\n# documentation directory\nESMF_DOCDIR\t= $(ESMF_DIR)/doc\n\n# benchmark directory\nESMF_UT_BM_DIR    = $(ESMF_BENCHMARK_PREFIX)/test/test$(ESMF_BOPT)/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_ABI).$(ESMF_COMM).$(ESMF_SITE)\n\n# ???\nESMF_BUILD_DOCDIR = $(ESMF_BUILD)/build/doc\n\n# system test source directory\nESMF_STDIR      = $(ESMF_DIR)/src/system_tests\n\n# platform specific configuration directory\nESMF_CONFDIR    = $(ESMF_DIR)/build_config/$(ESMF_OS).$(ESMF_COMPILER).default\n\n# site specific configuration directory\nESMF_SITEDIR    = $(ESMF_DIR)/build_config/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_SITE)\n\n# use test cases source directory\nESMF_UTCDIR     = $(ESMF_DIR)/src/use_test_cases\n\n# use test cases scripts directory\nESMF_UTCSCRIPTS = $(ESMF_DIR)/src/use_test_cases/scripts\n\n# documentation scripts and tools\nESMF_TEMPLATES\t= $(ESMF_DIR)/scripts/doc_templates/templates\nPROTEX\t\t= $(ESMF_TEMPLATES)/protex \nCC_PROTEX       = $(ESMF_TEMPLATES)/scripts/do_ccprotex \nCH_PROTEX       = $(ESMF_TEMPLATES)/scripts/do_chprotex \nF_PROTEX        = $(ESMF_TEMPLATES)/scripts/do_fprotex \nDO_LATEX\t= $(ESMF_TEMPLATES)/scripts/do_latex\nDO_L2H\t\t= $(ESMF_TEMPLATES)/scripts/do_l2h\n\n# test script variables\nUNIT_TESTS_CONFIG   = $(ESMF_TESTDIR)/unit_tests.config\nMAPL_TESTS_CONFIG   = $(ESMF_TESTDIR)/mapl_tests.config\nSYS_TESTS_CONFIG    = $(ESMF_TESTDIR)/sys_tests.config\nEXAMPLES_CONFIG     = $(ESMF_EXDIR)/examples.config\nTEST_HARNESS_LIST   = $(ESMF_TESTDIR)/test_harness.list\nESMF_TESTSCRIPTS    = $(ESMF_DIR)/scripts/test_scripts\nDO_UT_RESULTS\t    = $(ESMF_TESTSCRIPTS)/do_ut_results.pl -h $(ESMF_TESTSCRIPTS) -d $(ESMF_TESTDIR) -b $(ESMF_BOPT) -e $(ESMF_COMM)\nDO_MT_RESULTS       = $(ESMF_TESTSCRIPTS)/do_mt_results.pl -h $(ESMF_TESTSCRIPTS) -e $(ESMF_DIR) -d $(ESMF_TESTDIR) -b $(ESMF_BOPT)\nDO_UT_ML_RESULTS    = $(ESMF_TESTSCRIPTS)/do_ut_ml_results.pl -h $(ESMF_TESTSCRIPTS) -d $(ESMF_TESTDIR) -b $(ESMF_BOPT)\nDO_UT_BM_RESULTS    = $(ESMF_TESTSCRIPTS)/do_ut_bm_results.pl -h $(ESMF_TESTSCRIPTS) -d $(ESMF_TESTDIR) -e $(ESMF_UT_BM_DIR) -f $(ESMF_BENCHMARK_TOLERANCE) -g $(ESMF_BENCHMARK_THRESHOLD_MSEC) -i $(ESMF_BOPT)\nDO_EX_RESULTS\t    = $(ESMF_TESTSCRIPTS)/do_ex_results.pl -h $(ESMF_TESTSCRIPTS) -d $(ESMF_EXDIR) -b $(ESMF_BOPT) -e $(ESMF_COMM)\nDO_EX_ML_RESULTS    = $(ESMF_TESTSCRIPTS)/do_ex_ml_results.pl -h $(ESMF_TESTSCRIPTS) -d $(ESMF_EXDIR) -b $(ESMF_BOPT)\nDO_ST_RESULTS\t    = $(ESMF_TESTSCRIPTS)/do_st_results.pl -h $(ESMF_TESTSCRIPTS) -d $(ESMF_TESTDIR) -b $(ESMF_BOPT) -e $(ESMF_COMM)\nDO_ST_ML_RESULTS    = $(ESMF_TESTSCRIPTS)/do_st_ml_results.pl -h $(ESMF_TESTSCRIPTS) -d $(ESMF_TESTDIR) -b $(ESMF_BOPT)\nDO_SUM_RESULTS\t    = $(ESMF_TESTSCRIPTS)/do_summary.pl -h $(ESMF_TESTSCRIPTS) -d $(ESMF_TESTDIR) -e $(ESMF_EXDIR) -b $(ESMF_BOPT) -f $(ESMF_COMM)\nDO_CK_SUM_RESULTS   = $(ESMF_TESTSCRIPTS)/do_ck_summary.pl -h $(ESMF_TESTSCRIPTS) -d $(ESMF_TESTDIR) -e $(ESMF_EXDIR) -b $(ESMF_BOPT) -f $(ESMF_COMM) \nDO_UTC_RESULTS\t    = $(ESMF_UTCSCRIPTS)/do_utc_results.pl -h $(ESMF_UTCSCRIPTS) -d $(ESMF_TESTDIR) -b $(ESMF_BOPT) -e $(ESMF_MAX_PROCS)\n\n# C specific variables\nESMC_OBJDIR\t= $(ESMF_OBJDIR)\nESMC_TESTDIR    = $(ESMF_TESTDIR)\nESMC_DOCDIR\t= $(ESMF_DOCDIR)\n\n#-------------------------------------------------------------------------------\n# Add preprocessing flags according to environment variables\nifeq ($(ESMF_ARRAY_LITE),TRUE)\nESMF_CPPFLAGS += -DESMF_NO_GREATER_THAN_4D\nendif           \nifeq ($(ESMF_NO_INTEGER_1_BYTE),TRUE)\nESMF_CPPFLAGS += -DESMF_NO_INTEGER_1_BYTE\nendif           \nifeq ($(ESMF_NO_INTEGER_2_BYTE),TRUE)\nESMF_CPPFLAGS += -DESMF_NO_INTEGER_2_BYTE\nendif           \n#-------------------------------------------------------------------------------\n\nifeq ($(shell $(ESMF_DIR)/scripts/available git),git)\nexport ESMF_VERSION_STRING_GIT := $(shell $(ESMF_DIR)/scripts/esmfversiongit)\nendif\n\nifdef ESMF_VERSION_STRING_GIT\nESMF_CPPFLAGS += -DESMFVERSIONGIT='\"$(ESMF_VERSION_STRING_GIT)\"'\nendif\n\n#-------------------------------------------------------------------------------\n# default settings for common.mk\n# the ESMF_xxxDEFAULT values are only used if ESMF_xxx is not defined in\n# user's environment.\n#-------------------------------------------------------------------------------\nESMF_PIODEFAULT             = internal\nESMF_PROJ4DEFAULT           = OFF\nESMF_PTHREADSDEFAULT        = ON\nESMF_OPENMPDEFAULT          = ON\nESMF_OPENACCDEFAULT         = OFF\n\nESMF_ARDEFAULT              = ar\nESMF_ARCREATEFLAGSDEFAULT   = cr\nESMF_ARCREATEPREFIX         =\nESMF_AREXTRACTDEFAULT       = $(ESMF_ARDEFAULT) -x\nESMF_RANLIBDEFAULT          = ranlib\nESMF_SEDDEFAULT             = sed\n# The gcc preprocessor is used for partially preprocessing .cppF90 files.\n# The -E option stops the gcc overcompiler after preprocessing, the -P\n# option prevents putting #line directives in the output, and -x c states\n# to use C-style preprocessing regardless of file name suffix. Option -C\n# does not discard C++-style comments, preventing URL mangling. Finally\n# for GCC range 4.8.5-4.9.x, -nostdinc is needed or else standard headers\n# are included that mess up the Fortran source code.\nESMF_CPPDEFAULT             = gcc -E -P -x c -C -nostdinc\n\nESMF_RM                     = rm -rf\nESMF_MV                     = mv -f\nESMF_WC                     = wc \nESMF_GREPV                  = grep -v\n\n# dummies here, expected to be overwritten in platform files if used\nESMF_F90RPATHPREFIX         = -L\nESMF_CXXRPATHPREFIX         = -L\n\nESMF_F90OPTFLAG_X           =\nESMF_CXXOPTFLAG_X           =\nESMF_F90OPTFLAG_G           = -g\nESMF_CXXOPTFLAG_G           = -g\n\n# setting default optimization flags is platform dependent\nifneq ($(origin ESMF_OPTLEVEL), environment)\nESMF_OPTLEVEL = $(ESMF_OPTLEVELDEFAULT)\nendif\n\nifneq ($(ESMF_OPTLEVEL),default)\n# if NEC, insert option before -O\nifeq ($(ESMF_COMPILER),sxcross)\nESMF_F90OPTFLAG_O =  -Wf\" -O $(ESMF_OPTLEVEL)\"\nelse\nESMF_F90OPTFLAG_O =  -O$(ESMF_OPTLEVEL)\nendif\nESMF_CXXOPTFLAG_O = -O$(ESMF_OPTLEVEL) -DNDEBUG\nelse\n# if NEC, insert option before -O\nifeq ($(ESMF_COMPILER),sxcross)\nESMF_F90OPTFLAG_O = -Wf -O\nelse\nESMF_F90OPTFLAG_O = -O\nendif\nESMF_CXXOPTFLAG_O = -O2 -DNDEBUG\nendif\n\n\n#-------------------------------------------------------------------------------\n# Set default ESMF_ variables which may be appended to or overridden in \n# platform specific build_rules.mk files.\n#-------------------------------------------------------------------------------\n\n# - F90COMPILER\nifneq ($(origin ESMF_F90COMPILER), environment)\nifeq ($(origin ESMF_F90), environment)\nESMF_F90COMPILER = $(ESMF_F90)\nelse\nESMF_F90COMPILER = $(ESMF_F90COMPILERDEFAULT)\nESMF_F90COMPILERDEFAULT = $(ESMF_F90DEFAULT)\nendif\nendif\nifneq ($(origin ESMF_F90IMOD), environment)\nESMF_F90IMOD = -I\nendif\nifneq ($(origin ESMF_F90MODDIR), environment)\nESMF_F90MODDIR = $(ESMF_MODDIR)\nendif\nifneq ($(origin ESMF_F90OPTFLAG), environment)\nESMF_F90OPTFLAG = $(ESMF_F90OPTFLAG_X)\nifeq ($(ESMF_BOPT),g)\nESMF_F90OPTFLAG = $(ESMF_F90OPTFLAG_G)\nendif\nifeq ($(ESMF_BOPT),O)\nESMF_F90OPTFLAG = $(ESMF_F90OPTFLAG_O)\nendif\nendif\n# - make sure environment variable gets prepended _once_\nifeq ($(origin ESMF_F90COMPILEOPTS), environment)\nexport ESMF_F90COMPILEOPTS_ENV := $(ESMF_F90COMPILEOPTS)\nunexport ESMF_F90COMPILEOPTS\nendif\nifeq ($(origin ESMF_F90COMPILEOPTS_ENV), environment)\nESMF_F90COMPILEOPTS = $(ESMF_F90COMPILEOPTS_ENV)\nendif\nESMF_F90COMPILEOPTS += $(ESMF_F90OPTFLAG) $(ESMF_SO_F90COMPILEOPTS)\n# - make sure environment variable gets prepended _once_\nifeq ($(origin ESMF_F90COMPILEPATHS), environment)\nexport ESMF_F90COMPILEPATHS_ENV := $(ESMF_F90COMPILEPATHS)\nunexport ESMF_F90COMPILEPATHS\nendif\nifeq ($(origin ESMF_F90COMPILEPATHS_ENV), environment)\nESMF_F90COMPILEPATHS = $(ESMF_F90COMPILEPATHS_ENV)\nendif\nESMF_F90COMPILEPATHS     += $(ESMF_F90IMOD)$(ESMF_F90MODDIR)\nESMF_F90COMPILEPATHSLOCAL =\nifneq ($(ESMF_SITE),default)\nESMF_F90COMPILEPATHSLOCAL += -I$(ESMF_SITEDIR)\nendif\nESMF_F90COMPILEPATHSLOCAL += -I$(ESMF_CONFDIR) $(ESMF_INTERNALINCDIRS)\nESMF_F90COMPILEPATHS      += -I$(ESMF_INCDIR) $(ESMF_F90COMPILEPATHSTHIRD)\nESMF_F90COMPILEFREECPP    +=\nESMF_F90COMPILEFREENOCPP  +=\nESMF_F90COMPILEFIXCPP     +=\nESMF_F90COMPILEFIXNOCPP   +=\nESMF_F90COMPILECPPFLAGS   += $(ESMF_FPPFLAGS)\n\n# - CXXCOMPILER\nifneq ($(origin ESMF_CXXCOMPILER), environment)\nifeq ($(origin ESMF_CXX), environment)\nESMF_CXXCOMPILER = $(ESMF_CXX)\nelse\nESMF_CXXCOMPILER = $(ESMF_CXXCOMPILERDEFAULT)\nESMF_CXXCOMPILERDEFAULT = $(ESMF_CXXDEFAULT)\nendif\nendif\nifneq ($(origin ESMF_CXXOPTFLAG), environment)\nESMF_CXXOPTFLAG = $(ESMF_CXXOPTFLAG_X)\nifeq ($(ESMF_BOPT),g)\nESMF_CXXOPTFLAG = $(ESMF_CXXOPTFLAG_G)\nendif\nifeq ($(ESMF_BOPT),O)\nESMF_CXXOPTFLAG = $(ESMF_CXXOPTFLAG_O)\nendif\nendif\n# - make sure environment variable gets prepended _once_\nifeq ($(origin ESMF_CXXCOMPILEOPTS), environment)\nexport ESMF_CXXCOMPILEOPTS_ENV := $(ESMF_CXXCOMPILEOPTS)\nunexport ESMF_CXXCOMPILEOPTS\nendif\nifeq ($(origin ESMF_CXXCOMPILEOPTS_ENV), environment)\nESMF_CXXCOMPILEOPTS = $(ESMF_CXXCOMPILEOPTS_ENV)\nendif\nESMF_CXXCOMPILEOPTS += $(ESMF_CXXSTDFLAG) $(ESMF_CXXOPTFLAG) $(ESMF_SO_CXXCOMPILEOPTS)\n# - make sure environment variable gets prepended _once_\nifeq ($(origin ESMF_CXXCOMPILEPATHS), environment)\nexport ESMF_CXXCOMPILEPATHS_ENV := $(ESMF_CXXCOMPILEPATHS)\nunexport ESMF_CXXCOMPILEPATHS\nendif\nifeq ($(origin ESMF_CXXCOMPILEPATHS_ENV), environment)\nESMF_CXXCOMPILEPATHS = $(ESMF_CXXCOMPILEPATHS_ENV)\nendif\nESMF_CXXCOMPILEPATHS      +=\nESMF_CXXCOMPILEPATHSLOCAL  = -I$(ESMF_DIR)/$(LOCDIR)\nESMF_CXXCOMPILEPATHSLOCAL += -I$(ESMF_DIR)/$(LOCDIR)/../include \nifneq ($(ESMF_SITE),default)\nESMF_CXXCOMPILEPATHSLOCAL += -I$(ESMF_SITEDIR)\nendif\nESMF_CXXCOMPILEPATHSLOCAL += -I$(ESMF_CONFDIR) $(ESMF_INTERNALINCDIRS)\nESMF_CXXCOMPILEPATHS      += -I$(ESMF_INCDIR)  $(ESMF_CXXCOMPILEPATHSTHIRD)\nESMF_CXXCOMPILECPPFLAGS   += $(ESMF_CPPFLAGS) -D__SDIR__='\"$(LOCDIR)\"'\n\n# - F90LINKER\nifneq ($(origin ESMF_F90LINKER), environment)\nifeq ($(origin ESMF_F90), environment)\nESMF_F90LINKER = $(ESMF_F90)\nelse\nESMF_F90LINKER = $(ESMF_F90LINKERDEFAULT)\nESMF_F90LINKERDEFAULT = $(ESMF_F90DEFAULT)\nendif\nendif\n# - make sure environment variable gets prepended _once_\nifeq ($(origin ESMF_F90LINKOPTS), environment)\nexport ESMF_F90LINKOPTS_ENV := $(ESMF_F90LINKOPTS)\nunexport ESMF_F90LINKOPTS\nendif\nifeq ($(origin ESMF_F90LINKOPTS_ENV), environment)\nESMF_F90LINKOPTS = $(ESMF_F90LINKOPTS_ENV)\nelse\nifeq ($(ESMF_BOPT),g)\nESMF_F90LINKOPTS += $(ESMF_LINKOPTFLAG_G)\nendif\nifeq ($(ESMF_BOPT),O)\nESMF_F90LINKOPTS += $(ESMF_LINKOPTFLAG_O)\nendif\nendif\nESMF_F90LINKOPTS     +=\n# - make sure environment variable gets prepended _once_\nifeq ($(origin ESMF_F90LINKPATHS), environment)\nexport ESMF_F90LINKPATHS_ENV := $(ESMF_F90LINKPATHS)\nunexport ESMF_F90LINKPATHS\nendif\nifeq ($(origin ESMF_F90LINKPATHS_ENV), environment)\nESMF_F90LINKPATHS = $(ESMF_F90LINKPATHS_ENV)\nendif\nESMF_F90LINKPATHS    += -L$(ESMF_LDIR) $(ESMF_F90LINKPATHSTHIRD)\n# - make sure environment variable gets prepended _once_\nifeq ($(origin ESMF_F90LINKRPATHS), environment)\nexport ESMF_F90LINKRPATHS_ENV := $(ESMF_F90LINKRPATHS)\nunexport ESMF_F90LINKRPATHS\nendif\nifeq ($(origin ESMF_F90LINKRPATHS_ENV), environment)\nESMF_F90LINKRPATHS = $(ESMF_F90LINKRPATHS_ENV)\nendif\nESMF_F90LINKRPATHS   += $(ESMF_F90RPATHPREFIX)$(ESMF_LDIR) $(ESMF_F90LINKRPATHSTHIRD)\n# - make sure environment variable gets prepended _once_\nifeq ($(origin ESMF_F90LINKLIBS), environment)\nexport ESMF_F90LINKLIBS_ENV := $(ESMF_F90LINKLIBS)\nunexport ESMF_F90LINKLIBS\nendif\nifeq ($(origin ESMF_F90LINKLIBS_ENV), environment)\nESMF_F90LINKLIBS = $(ESMF_F90LINKLIBS_ENV)\nendif\nESMF_F90LINKLIBS     +=\nESMF_F90ESMFLINKLIBS += -lesmf $(ESMF_F90LINKLIBS)\n\n# - CXXLINKER\nifneq ($(origin ESMF_CXXLINKER), environment)\nifeq ($(origin ESMF_CXX), environment)\nESMF_CXXLINKER = $(ESMF_CXX)\nelse\nESMF_CXXLINKER = $(ESMF_CXXLINKERDEFAULT)\nESMF_CXXLINKERDEFAULT = $(ESMF_CXXDEFAULT)\nendif\nendif\n# - make sure environment variable gets prepended _once_\nifeq ($(origin ESMF_CXXLINKOPTS), environment)\nexport ESMF_CXXLINKOPTS_ENV := $(ESMF_CXXLINKOPTS)\nunexport ESMF_CXXLINKOPTS\nendif\nifeq ($(origin ESMF_CXXLINKOPTS_ENV), environment)\nESMF_CXXLINKOPTS = $(ESMF_CXXLINKOPTS_ENV)\nelse\nifeq ($(ESMF_BOPT),g)\nESMF_CXXLINKOPTS += $(ESMF_LINKOPTFLAG_G)\nendif\nifeq ($(ESMF_BOPT),O)\nESMF_CXXLINKOPTS += $(ESMF_LINKOPTFLAG_O)\nendif\nendif\nESMF_CXXLINKOPTS     +=\n# - make sure environment variable gets prepended _once_\nifeq ($(origin ESMF_CXXLINKPATHS), environment)\nexport ESMF_CXXLINKPATHS_ENV := $(ESMF_CXXLINKPATHS)\nunexport ESMF_CXXLINKPATHS\nendif\nifeq ($(origin ESMF_CXXLINKPATHS_ENV), environment)\nESMF_CXXLINKPATHS = $(ESMF_CXXLINKPATHS_ENV)\nendif\nESMF_CXXLINKPATHS    += -L$(ESMF_LDIR) $(ESMF_CXXLINKPATHSTHIRD)\n# - make sure environment variable gets prepended _once_\nifeq ($(origin ESMF_CXXLINKRPATHS), environment)\nexport ESMF_CXXLINKRPATHS_ENV := $(ESMF_CXXLINKRPATHS)\nunexport ESMF_CXXLINKRPATHS\nendif\nifeq ($(origin ESMF_CXXLINKRPATHS_ENV), environment)\nESMF_CXXLINKRPATHS = $(ESMF_CXXLINKRPATHS_ENV)\nendif\nESMF_CXXLINKRPATHS   += $(ESMF_CXXRPATHPREFIX)$(ESMF_LDIR) $(ESMF_CXXLINKRPATHSTHIRD)\n# - make sure environment variable gets prepended _once_\nifeq ($(origin ESMF_CXXLINKLIBS), environment)\nexport ESMF_CXXLINKLIBS_ENV := $(ESMF_CXXLINKLIBS)\nunexport ESMF_CXXLINKLIBS\nendif\nifeq ($(origin ESMF_CXXLINKLIBS_ENV), environment)\nESMF_CXXLINKLIBS = $(ESMF_CXXLINKLIBS_ENV)\nendif\nESMF_CXXLINKLIBS     +=\nESMF_CXXESMFLINKLIBS += -lesmf $(ESMF_CXXLINKLIBS)\n\n# - tools: AR + RANLIB + ...\nifneq ($(origin ESMF_AR), environment)\nESMF_AR = $(ESMF_ARDEFAULT)\nendif\nifneq ($(origin ESMF_ARCREATEFLAGS), environment)\nESMF_ARCREATEFLAGS = $(ESMF_ARCREATEFLAGSDEFAULT)\nendif\nifneq ($(origin ESMF_AREXTRACT), environment)\nESMF_AREXTRACT = $(ESMF_AREXTRACTDEFAULT)\nendif\nifneq ($(origin ESMF_RANLIB), environment)\nESMF_RANLIB = $(ESMF_RANLIBDEFAULT)\nendif\nifneq ($(origin ESMF_CPP), environment)\nESMF_CPP = $(ESMF_CPPDEFAULT)\nendif\nifneq ($(origin ESMF_SED), environment)\nESMF_SED = $(ESMF_SEDDEFAULT)\nendif\n\n#-------------------------------------------------------------------------------\n# Add C++ standard string to compile options if non-system-default is chosen.\n# The ESMF default is currently C++11 because parts of ESMF require it.\n#-------------------------------------------------------------------------------\nifeq ($(ESMF_CXXSTD),default)\nESMF_CXXSTD = 11\nendif\n\nifneq ($(ESMF_CXXSTD),sysdefault)\n# Most compilers know the -std=c++XX flag. Overwrite in build_rules.mk if needed.\nESMF_CXXSTDFLAG         = -std=c++$(ESMF_CXXSTD)\nESMF_CXXCOMPILECPPFLAGS += -DESMF_CXXSTD=$(ESMF_CXXSTD)\nendif\n\n# - Archive library\nESMF_LIB_SUFFIX       = a\nifeq ($(ESMF_OS),MinGW)\nESMF_LIB_SUFFIX       = lib\nendif\n\n# - Shared library\nESMF_SL_SUFFIX        = so\nifeq ($(ESMF_OS),Darwin)\nESMF_SL_SUFFIX        = dylib\nendif\nifeq ($(ESMF_OS),Cygwin)\nESMF_SL_SUFFIX        = dll.a\nendif\nifeq ($(ESMF_OS),MinGW)\nESMF_SL_SUFFIX        = dll\nendif\nifeq ($(ESMF_SHARED_LIB_BUILD),ON)\nESMF_SL_LIBS_TO_MAKE  = libesmf\nendif\nESMF_SL_LIBLINKER     = $(ESMF_CXXCOMPILER)\nESMF_SL_LIBOPTS      +=\nESMF_SL_LIBLIBS      +=\n\n# - Shared objects\nESMF_SO_F90COMPILEOPTS  +=\nESMF_SO_F90LINKOPTS     +=\nESMF_SO_F90LINKOPTSEXE  +=\nESMF_SO_CXXCOMPILEOPTS  +=\nESMF_SO_CXXLINKOPTS     +=\nESMF_SO_CXXLINKOPTSEXE  +=\n\n# - OpenMP compiler and linker flags\nESMF_OPENMP_F90COMPILEOPTS  +=\nESMF_OPENMP_F90LINKOPTS     +=\nESMF_OPENMP_CXXCOMPILEOPTS  +=\nESMF_OPENMP_CXXLINKOPTS     +=\n\n# - OpenACC compiler and linker flags\nESMF_OPENACC_F90COMPILEOPTS  +=\nESMF_OPENACC_F90LINKOPTS     +=\nESMF_OPENACC_CXXCOMPILEOPTS  +=\nESMF_OPENACC_CXXLINKOPTS     +=\n\n# - MPIRUN\nifneq ($(origin ESMF_MPIRUN), environment)\nESMF_MPIRUN = $(ESMF_MPIRUNDEFAULT)\nendif\n\n# - MPIMPMDRUN\nifneq ($(origin ESMF_MPIMPMDRUN), environment)\nESMF_MPIMPMDRUN = $(ESMF_MPIMPMDRUNDEFAULT)\nendif\n\n# Variable that controls the output option for object files.  Note that\n# some compilers do not support specifying \"-o\" and \"-c\" together.  These\n# platforms are specified by NO_OCFLAG_LIST defined below.  In those cases\n# the object files are moved after the compile.\nNO_OCFLAG_LIST := \\\n\tIRIX64.default \\\n\tCygwin.intelgcc \\\n\tCygwin.intel \\\n\tMinGW.intel \\\n\tMinGW.intelcl\nWINTEL_OFFLAG_LIST := \\\n\tCygwin.intelgcc \\\n\tCygwin.intel \\\n\tMinGW.intel \\\n\tMinGW.intelcl\nifeq (,$(findstring $(ESMF_OS).$(ESMF_COMPILER),$(NO_OCFLAG_LIST)))\n  ESMF_OBJOUT_OPTION = -o $@\n  ESMF_EXEOUT_OPTION = -o $@\nelse\nifeq (,$(findstring $(ESMF_OS).$(ESMF_COMPILER),$(WINTEL_OFFLAG_LIST)))\n  ESMF_OBJOUT_OPTION = ; $(ESMF_MV) $*.o $@\n  ESMF_EXEOUT_OPTION = -o $@\nelse\n  ESMF_OBJOUT_OPTION = ; $(ESMF_MV) $*.obj $@\n  ESMF_EXEOUT_OPTION = -Fe`$(ESMF_DIR)/scripts/path_mingw2win $@.exe`\nendif\nendif\n\n\n#-------------------------------------------------------------------------------\n# Up to here there have only been definitions, no targets.  This is the \n# first (and therefore default) target.  The definition of what \"all\" is\n# should be defined in the top level makefile and not here.  If a different\n# default is desired, that can also be defined in the top level makefile,\n# before common.mk is included.\n#-------------------------------------------------------------------------------\n\ndefault: lib\n\n#-------------------------------------------------------------------------------\n#  Set up all defaults before here.   Next, include both the system dependent\n#  makefile fragment, and if present, the site-specific makefile fragment.\n#  These files can += to add on to existing defaults, or override settings\n#  by setting flags and variables with = to new values.\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n#  Include the default platform-specific makefile fragment.\n#-------------------------------------------------------------------------------\n\ninclude $(ESMF_CONFDIR)/build_rules.mk\n\n\n#-------------------------------------------------------------------------------\n#  Include site specific makefile fragment.  If we want to suppress a warning\n#  message if the site file is not found add a leading dash before the include\n#  keyword.  (If the file is not found it is a warning, not a fatal error.)\n#-------------------------------------------------------------------------------\n\nifneq ($(ESMF_SITE),default)\ninclude $(ESMF_SITEDIR)/build_rules.mk\nendif\n\n#-------------------------------------------------------------------------------\n#  Now all system-dependent files have been read.  Now anything\n#  below here is again common code.  Variables should no longer be overwritten\n#  with =, but should be appended to if neeeded with +=\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n# Mapper\n#-------------------------------------------------------------------------------\nifeq ($(ESMF_MAPPER_BUILD),ON)\nESMF_CPPFLAGS             += -DESMF_MAPPER=1\nendif\n\n#-------------------------------------------------------------------------------\n# 3rd Party libraries\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n# LAPACK\n#-------------------------------------------------------------------------------\nifndef ESMF_LAPACK\nifndef ESMF_LAPACK_OFF\nESMF_LAPACK = internal\nendif\nendif\n\nifeq ($(ESMF_LAPACK),OFF)\nESMF_LAPACK =\nexport ESMF_LAPACK_OFF = true\nendif\n\nifeq ($(ESMF_LAPACK),internal)\nESMF_LAPACK_INTERNAL = 1\nESMF_LAPACK_LIBPATH =\nESMF_LAPACK_LIBS =\nendif\n\nifeq ($(ESMF_LAPACK),system)\nifdef ESMF_LAPACKDEFAULT\nESMF_LAPACK = $(ESMF_LAPACKDEFAULT)\nendif\nendif\n\nifeq ($(ESMF_LAPACK),netlib)\nifndef ESMF_LAPACK_LIBS\nESMF_LAPACK_LIBS = -llapack -lblas\nendif\nendif\n\nifeq ($(ESMF_LAPACK),mkl)\nifndef ESMF_LAPACK_LIBS\nESMF_LAPACK_LIBS = -lmkl_lapack -lmkl\nendif\nendif\n\nifeq ($(ESMF_LAPACK),scsl)\nifndef ESMF_LAPACK_LIBS\nESMF_LAPACK_LIBS = -lscs\nendif\nendif\n\nifdef ESMF_LAPACK\nESMF_CPPFLAGS             += -DESMF_LAPACK=1\nifdef ESMF_LAPACK_INTERNAL\nESMF_CPPFLAGS             += -DESMF_LAPACK_INTERNAL=1\nendif\nifdef ESMF_LAPACK_LIBS\nESMF_CXXLINKLIBS          += $(ESMF_LAPACK_LIBS)\nESMF_CXXLINKRPATHSTHIRD   += $(addprefix $(ESMF_CXXRPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_LAPACK_LIBS))))\nESMF_F90LINKLIBS          += $(ESMF_LAPACK_LIBS)\nESMF_F90LINKRPATHSTHIRD   += $(addprefix $(ESMF_F90RPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_LAPACK_LIBS))))\nendif\nifdef ESMF_LAPACK_LIBPATH\nESMF_CXXLINKPATHSTHIRD    += -L$(ESMF_LAPACK_LIBPATH)\nESMF_F90LINKPATHSTHIRD    += -L$(ESMF_LAPACK_LIBPATH)\nESMF_CXXLINKRPATHSTHIRD   += $(ESMF_CXXRPATHPREFIX)$(ESMF_LAPACK_LIBPATH)\nESMF_F90LINKRPATHSTHIRD   += $(ESMF_F90RPATHPREFIX)$(ESMF_LAPACK_LIBPATH)\nendif\nendif\n\n#-------------------------------------------------------------------------------\n# MOAB\n#-------------------------------------------------------------------------------\nifeq ($(ESMF_MOAB),standard)\nifneq ($(origin ESMF_MOAB_LIBS), environment)\nESMF_MOAB_LIBS = -lMOAB\nendif\nendif\n\nifneq ($(ESMF_MOAB),OFF)\nESMF_CPPFLAGS             += -DESMF_MOAB=1\nifdef ESMF_MOAB_INCLUDE\nESMF_CXXCOMPILEPATHSTHIRD += -I$(ESMF_MOAB_INCLUDE)\nESMF_F90COMPILEPATHSTHIRD += -I$(ESMF_MOAB_INCLUDE)\nendif\nifdef ESMF_MOAB_LIBS\nESMF_CXXLINKLIBS          += $(ESMF_MOAB_LIBS)\nESMF_CXXLINKRPATHSTHIRD   += $(addprefix $(ESMF_CXXRPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_MOAB_LIBS))))\nESMF_F90LINKLIBS          += $(ESMF_MOAB_LIBS)\nESMF_F90LINKRPATHSTHIRD   += $(addprefix $(ESMF_F90RPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_MOAB_LIBS))))\nendif\nifdef ESMF_MOAB_LIBPATH\nESMF_CXXLINKPATHSTHIRD    += -L$(ESMF_MOAB_LIBPATH)\nESMF_F90LINKPATHSTHIRD    += -L$(ESMF_MOAB_LIBPATH)\nESMF_CXXLINKRPATHSTHIRD   += $(ESMF_CXXRPATHPREFIX)$(ESMF_MOAB_LIBPATH)\nESMF_F90LINKRPATHSTHIRD   += $(ESMF_F90RPATHPREFIX)$(ESMF_MOAB_LIBPATH)\nendif\nendif\n\n#-------------------------------------------------------------------------------\n# ESMF Accelerator Framework\n#-------------------------------------------------------------------------------\nifdef ESMF_ACC_SOFTWARE_STACK\n# FIXME: Differentiate between \n# 1. unsupported/unrecognized_framework\n#    (framework specified but not supported)\n# AND\n# 2. no_framework (none)\nifeq ($(ESMF_ACC_SOFTWARE_STACK),opencl)\nESMF_CPPFLAGS             += -DESMF_ACC_SOFTWARE_STACK=1\nendif\nifeq ($(ESMF_ACC_SOFTWARE_STACK),openacc)\nESMF_CPPFLAGS             += -DESMF_ACC_SOFTWARE_STACK=1\nendif\nifeq ($(ESMF_ACC_SOFTWARE_STACK),intelmic)\nESMF_CPPFLAGS             += -DESMF_ACC_SOFTWARE_STACK=1\nESMF_ARDEFAULT \t\t\t\t\t\t= xiar\nendif\nifeq ($(ESMF_ACC_SOFTWARE_STACK),openmp4)\nESMF_CPPFLAGS             += -DESMF_ACC_SOFTWARE_STACK=1\nifeq ($(ESMF_COMPILER),intel)\nESMF_ARDEFAULT \t\t\t\t\t\t= xiar\nendif\nendif\nifeq ($(ESMF_ACC_SOFTWARE_STACK),none)\nESMF_CPPFLAGS             += -DESMF_NO_ACC_SOFTWARE_STACK=1\nendif\nifdef ESMF_ACC_SOFTWARE_STACK_INCLUDE\nESMF_CXXCOMPILEPATHSTHIRD += -I$(ESMF_ACC_SOFTWARE_STACK_INCLUDE)\nESMF_F90COMPILEPATHSTHIRD += -I$(ESMF_ACC_SOFTWARE_STACK_INCLUDE)\nendif\nifdef ESMF_ACC_SOFTWARE_STACK_LIBS\nESMF_CXXLINKLIBS          += $(ESMF_ACC_SOFTWARE_STACK_LIBS)\nESMF_CXXLINKRPATHSTHIRD   += $(addprefix $(ESMF_CXXRPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_ACC_SOFTWARE_STACK_LIBS))))\nESMF_F90LINKLIBS          += $(ESMF_ACC_SOFTWARE_STACK_LIBS)\nESMF_F90LINKRPATHSTHIRD   += $(addprefix $(ESMF_F90RPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_ACC_SOFTWARE_STACK_LIBS))))\nendif\nifdef ESMF_ACC_SOFTWARE_STACK_LIBPATH\nESMF_CXXLINKPATHSTHIRD    += -L$(ESMF_ACC_SOFTWARE_STACK_LIBPATH)\nESMF_F90LINKPATHSTHIRD    += -L$(ESMF_ACC_SOFTWARE_STACK_LIBPATH)\nESMF_CXXLINKRPATHSTHIRD   += $(ESMF_CXXRPATHPREFIX)$(ESMF_ACC_SOFTWARE_STACK_LIBPATH)\nESMF_F90LINKRPATHSTHIRD   += $(ESMF_F90RPATHPREFIX)$(ESMF_ACC_SOFTWARE_STACK_LIBPATH)\nendif\nendif\n\n#-------------------------------------------------------------------------------\n# NETCDF\n#-------------------------------------------------------------------------------\n\n# Check if ESMF_NETCDF may be pointing to nc-config with absolute path.\n# For situations where PATH is not to be trusted for nc-config location.\npathtype := \"\"\nifdef ESMF_NETCDF\npathtype := $(shell $(ESMF_DIR)/scripts/pathtype $(ESMF_NETCDF))\nendif\nifeq ($(pathtype),abs)\n# use the $(ESMF_NETCDF) contents as nc-config\n# but must check if there is also nf-config available\nESMF_NCCONFIG = $(ESMF_NETCDF)\nifneq ($(origin ESMF_NFCONFIG), environment) \nESMF_NFCONFIG = $(shell $(ESMF_NETCDF) --prefix)/bin/nf-config\nifneq ($(shell $(ESMF_DIR)/scripts/exists $(ESMF_NFCONFIG)),$(ESMF_NFCONFIG))\nESMF_NFCONFIG := \nendif\nexport ESMF_NFCONFIG\nendif\nifneq ($(origin ESMF_NETCDF_INCLUDE), environment) \nESMF_NETCDF_INCLUDE := $(shell $(ESMF_NCCONFIG) --includedir)\nexport ESMF_NETCDF_INCLUDE\nendif\nifneq ($(origin ESMF_NETCDF_LIBS), environment)\nifdef ESMF_NFCONFIG\nESMF_NETCDF_LIBS    := $(shell $(ESMF_NFCONFIG) --flibs)\nelse\nESMF_NETCDF_LIBS    := $(shell $(ESMF_NCCONFIG) --flibs)\nendif\nESMF_NETCDF_CONFIG_LIBS := $(shell $(ESMF_NCCONFIG) --libs)\nESMF_NETCDF_LIBS   += $(ESMF_NETCDF_CONFIG_LIBS)\nendif\nexport ESMF_NETCDF_LIBS\nendif\n\n# Handle the regular case where nc-config comes without absolute path.\nifeq ($(ESMF_NETCDF),nc-config)\nESMF_NETCDF_CPATH = $(shell nc-config --prefix)\nESMF_NETCDF_INCLUDE = $(ESMF_NETCDF_CPATH)/include\nESMF_NETCDF_LIBPATH = $(ESMF_NETCDF_CPATH)/lib\n# Fortran API library might be in a different directory than the main C library.\nESMF_NETCDF_FPATH = $(shell nf-config --prefix 2>/dev/null)\nifeq ($(ESMF_NETCDF_FPATH),\"\")\nESMF_NETCDF_LIBS = -lnetcdf\nelse\nESMF_NETCDF_LIBS = -lnetcdff -lnetcdf\nifneq ($(ESMF_NETCDF_CPATH),$(ESMF_NETCDF_FPATH))\nESMF_NETCDF_INCLUDE += -I$(ESMF_NETCDF_FPATH)/include\nESMF_NETCDF_FLIBPATH = $(ESMF_NETCDF_FPATH)/lib\nendif\nendif\nendif\n\nifeq ($(ESMF_NETCDF),standard)\nifneq ($(origin ESMF_NETCDF_LIBS), environment)\nESMF_NETCDF_LIBS = -lnetcdf\nexport ESMF_NETCDF_LIBS\nendif\nendif\n\nifeq ($(ESMF_NETCDF),split)\nifneq ($(origin ESMF_NETCDF_LIBS), environment)\nESMF_NETCDF_LIBS = -lnetcdff -lnetcdf\nexport ESMF_NETCDF_LIBS\nendif\nendif\n\nifdef ESMF_NETCDF\nESMF_CPPFLAGS             += -DESMF_NETCDF=1\nifdef ESMF_NETCDF_INCLUDE\nESMF_CXXCOMPILEPATHSTHIRD += -I$(ESMF_NETCDF_INCLUDE)\nESMF_F90COMPILEPATHSTHIRD += -I$(ESMF_NETCDF_INCLUDE)\nendif\nifdef ESMF_NETCDF_LIBS\nESMF_CXXLINKLIBS          += $(ESMF_NETCDF_LIBS)\nESMF_CXXLINKRPATHSTHIRD   += $(addprefix $(ESMF_CXXRPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_NETCDF_LIBS))))\nESMF_F90LINKLIBS          += $(ESMF_NETCDF_LIBS)\nESMF_F90LINKRPATHSTHIRD   += $(addprefix $(ESMF_F90RPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_NETCDF_LIBS))))\nendif\nifdef ESMF_NETCDF_LIBPATH\nifdef ESMF_NETCDF_FPATH\nifneq ($(ESMF_NETCDF_CPATH),$(ESMF_NETCDF_FPATH))\nESMF_CXXLINKPATHSTHIRD    += -L$(ESMF_NETCDF_FLIBPATH)\nESMF_F90LINKPATHSTHIRD    += -L$(ESMF_NETCDF_FLIBPATH)\nESMF_CXXLINKRPATHSTHIRD   += $(ESMF_CXXRPATHPREFIX)$(ESMF_NETCDF_FLIBPATH)\nESMF_F90LINKRPATHSTHIRD   += $(ESMF_F90RPATHPREFIX)$(ESMF_NETCDF_FLIBPATH)\nendif\nendif\nESMF_CXXLINKPATHSTHIRD    += -L$(ESMF_NETCDF_LIBPATH)\nESMF_F90LINKPATHSTHIRD    += -L$(ESMF_NETCDF_LIBPATH)\nESMF_CXXLINKRPATHSTHIRD   += $(ESMF_CXXRPATHPREFIX)$(ESMF_NETCDF_LIBPATH)\nESMF_F90LINKRPATHSTHIRD   += $(ESMF_F90RPATHPREFIX)$(ESMF_NETCDF_LIBPATH)\nendif\nendif\n\n#-------------------------------------------------------------------------------\n# PNETCDF\n#-------------------------------------------------------------------------------\nifeq ($(ESMF_PNETCDF),pnetcdf-config)\nESMF_PNETCDF_INCLUDE = $(shell pnetcdf-config --includedir)\nESMF_PNETCDF_LIBPATH = $(shell pnetcdf-config --libdir)\nESMF_PNETCDF_LIBS = -lpnetcdf\nendif\n\nifeq ($(ESMF_PNETCDF),standard)\nifneq ($(origin ESMF_PNETCDF_LIBS), environment)\nESMF_PNETCDF_LIBS = -lpnetcdf\nendif\nendif\n\nifdef ESMF_PNETCDF\nESMF_CPPFLAGS             += -DESMF_PNETCDF=1\nifdef ESMF_PNETCDF_INCLUDE\nESMF_CXXCOMPILEPATHSTHIRD += -I$(ESMF_PNETCDF_INCLUDE)\nESMF_F90COMPILEPATHSTHIRD += -I$(ESMF_PNETCDF_INCLUDE)\nendif\nifdef ESMF_PNETCDF_LIBS\nESMF_CXXLINKLIBS          += $(ESMF_PNETCDF_LIBS)\nESMF_CXXLINKRPATHSTHIRD   += $(addprefix $(ESMF_CXXRPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_PNETCDF_LIBS))))\nESMF_F90LINKLIBS          += $(ESMF_PNETCDF_LIBS)\nESMF_F90LINKRPATHSTHIRD   += $(addprefix $(ESMF_F90RPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_PNETCDF_LIBS))))\nendif\nifdef ESMF_PNETCDF_LIBPATH\nESMF_CXXLINKPATHSTHIRD    += -L$(ESMF_PNETCDF_LIBPATH)\nESMF_F90LINKPATHSTHIRD    += -L$(ESMF_PNETCDF_LIBPATH)\nESMF_CXXLINKRPATHSTHIRD   += $(ESMF_CXXRPATHPREFIX)$(ESMF_PNETCDF_LIBPATH)\nESMF_F90LINKRPATHSTHIRD   += $(ESMF_F90RPATHPREFIX)$(ESMF_PNETCDF_LIBPATH)\nendif\nendif\n\n#-------------------------------------------------------------------------------\n# XERCES C++ XML API\n#-------------------------------------------------------------------------------\nifeq ($(ESMF_XERCES),standard)\nifneq ($(origin ESMF_XERCES_LIBS), environment)\nESMF_XERCES_LIBS = -lxerces-c\nendif\nendif\n\nifdef ESMF_XERCES\nESMF_CPPFLAGS                += -DESMF_XERCES=1\nifdef ESMF_XERCES_INCLUDE\nESMF_CXXCOMPILEPATHSTHIRD    += -I$(ESMF_XERCES_INCLUDE)\nESMF_F90COMPILEPATHSTHIRD    += -I$(ESMF_XERCES_INCLUDE)\nendif\nifdef ESMF_XERCES_LIBS\nESMF_CXXLINKLIBS          += $(ESMF_XERCES_LIBS)\nESMF_CXXLINKRPATHSTHIRD   += $(addprefix $(ESMF_CXXRPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_XERCES_LIBS))))\nESMF_F90LINKLIBS          += $(ESMF_XERCES_LIBS)\nESMF_F90LINKRPATHSTHIRD   += $(addprefix $(ESMF_F90RPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_XERCES_LIBS))))\nendif\nifdef ESMF_XERCES_LIBPATH\nESMF_CXXLINKPATHSTHIRD    += -L$(ESMF_XERCES_LIBPATH)\nESMF_F90LINKPATHSTHIRD    += -L$(ESMF_XERCES_LIBPATH)\nESMF_CXXLINKRPATHSTHIRD   += $(ESMF_CXXRPATHPREFIX)$(ESMF_XERCES_LIBPATH)\nESMF_F90LINKRPATHSTHIRD   += $(ESMF_F90RPATHPREFIX)$(ESMF_XERCES_LIBPATH)\nendif\nendif\n\n#-------------------------------------------------------------------------------\n# yaml-cpp C++ YAML API\n#-------------------------------------------------------------------------------\nifeq ($(ESMF_YAMLCPP),internal)\nESMF_YAMLCPP_PRESENT = TRUE\nESMF_CXXCOMPILEPATHS += -I$(ESMF_DIR)/src/prologue/yaml-cpp/include\nESMF_YAMLCPP_INCLUDE =\nESMF_YAMLCPP_LIBPATH =\nESMF_YAMLCPP_LIBS =\nendif\n\nifeq ($(ESMF_YAMLCPP),standard)\nESMF_YAMLCPP_PRESENT = TRUE\nifneq ($(origin ESMF_YAMLCPP_LIBS), environment)\nESMF_YAMLCPP_LIBS = -lyaml-cpp\nendif\nendif\n\nifeq ($(ESMF_YAMLCPP_PRESENT),TRUE)\nESMF_CPPFLAGS                += -DESMF_YAMLCPP=1 -DESMF_YAML=1\nifdef ESMF_YAMLCPP_INCLUDE\nESMF_CXXCOMPILEPATHSTHIRD    += -I$(ESMF_YAMLCPP_INCLUDE)\nESMF_F90COMPILEPATHSTHIRD    += -I$(ESMF_YAMLCPP_INCLUDE)\nendif\nifdef ESMF_YAMLCPP_LIBS\nESMF_CXXLINKLIBS          += $(ESMF_YAMLCPP_LIBS)\nESMF_CXXLINKRPATHSTHIRD   += $(addprefix $(ESMF_CXXRPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_YAMLCPP_LIBS))))\nESMF_F90LINKLIBS          += $(ESMF_YAMLCPP_LIBS)\nESMF_F90LINKRPATHSTHIRD   += $(addprefix $(ESMF_F90RPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_YAMLCPP_LIBS))))\nendif\nifdef ESMF_YAMLCPP_LIBPATH\nESMF_CXXLINKPATHSTHIRD    += -L$(ESMF_YAMLCPP_LIBPATH)\nESMF_F90LINKPATHSTHIRD    += -L$(ESMF_YAMLCPP_LIBPATH)\nESMF_CXXLINKRPATHSTHIRD   += $(ESMF_CXXRPATHPREFIX)$(ESMF_YAMLCPP_LIBPATH)\nESMF_F90LINKRPATHSTHIRD   += $(ESMF_F90RPATHPREFIX)$(ESMF_YAMLCPP_LIBPATH)\nendif\nendif\n\n#-------------------------------------------------------------------------------\n# PIO\n#-------------------------------------------------------------------------------\nifneq ($(origin ESMF_PIO), environment)\nifndef ESMF_PIO\nexport ESMF_PIO = $(ESMF_PIODEFAULT)\nendif\n\nifeq ($(ESMF_PIO),internal)\nifeq ($(ESMF_COMM),mpiuni)\n#TODO: This turns PIO off if it was set to internal from a default setting.\n#TODO: We need to do this while our internal PIO does not support mpiuni mode,\n#TODO: but want to allow external PIO or explicit ESMF_PIO setting for developm. #TODO: Eventually this should become unnecessary.\nESMF_PIO = OFF\nendif\nendif\n\nendif\n\nifeq ($(ESMF_PIO),OFF)\nESMF_PIO=\nendif\n\nifeq ($(ESMF_PIO),external)\nifneq ($(origin ESMF_PIO_LIBS), environment)\nESMF_PIO_LIBS = -lpio\nendif\nendif\n\nifdef ESMF_PIO\nESMF_CPPFLAGS                += -DESMF_PIO=1\nifdef ESMF_PIO_INCLUDE\nESMF_CXXCOMPILEPATHSTHIRD    += -I$(ESMF_PIO_INCLUDE)\nESMF_F90COMPILEPATHSTHIRD    += -I$(ESMF_PIO_INCLUDE)\nendif\nifdef ESMF_PIO_LIBS\nESMF_CXXLINKLIBS          += $(ESMF_PIO_LIBS)\nESMF_CXXLINKRPATHSTHIRD   += $(addprefix $(ESMF_CXXRPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_PIO_LIBS))))\nESMF_F90LINKLIBS          += $(ESMF_PIO_LIBS)\nESMF_F90LINKRPATHSTHIRD   += $(addprefix $(ESMF_F90RPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_PIO_LIBS))))\nendif\nifdef ESMF_PIO_LIBPATH\nESMF_CXXLINKPATHSTHIRD    += -L$(ESMF_PIO_LIBPATH)\nESMF_F90LINKPATHSTHIRD    += -L$(ESMF_PIO_LIBPATH)\nESMF_CXXLINKRPATHSTHIRD   += $(ESMF_CXXRPATHPREFIX)$(ESMF_PIO_LIBPATH)\nESMF_F90LINKRPATHSTHIRD   += $(ESMF_F90RPATHPREFIX)$(ESMF_PIO_LIBPATH)\nendif\nendif\n\nifneq ($(ESMF_COMM),mpiuni)\nifneq ($(ESMF_COMM),mvapich)\nexport ESMF_MPIIO = supported\nESMF_CPPFLAGS += -DESMF_MPIIO\nendif\nendif\n\n#-------------------------------------------------------------------------------\n# Proj.4\n#-------------------------------------------------------------------------------\nifneq ($(origin ESMF_PROJ4), environment)\nifdef ESMF_PROJ4DEFAULT\nexport ESMF_PROJ4 = $(ESMF_PROJ4DEFAULT)\nendif\nendif\n\nifeq ($(ESMF_PROJ4),OFF)\nESMF_PROJ4=\nendif\n\nifeq ($(ESMF_PROJ4),external)\nifneq ($(origin ESMF_PROJ4_LIBS), environment)\nESMF_PROJ4_LIBS = -lproj\nendif\nendif\n\nifdef ESMF_PROJ4\nESMF_CPPFLAGS                += -DESMF_PROJ4=1\nifdef ESMF_PROJ4_INCLUDE\nESMF_CXXCOMPILEPATHSTHIRD    += -I$(ESMF_PROJ4_INCLUDE)\nESMF_F90COMPILEPATHSTHIRD    += -I$(ESMF_PROJ4_INCLUDE)\nendif\nifdef ESMF_PROJ4_LIBS\nESMF_CXXLINKLIBS          += $(ESMF_PROJ4_LIBS)\nESMF_CXXLINKRPATHSTHIRD   += $(addprefix $(ESMF_CXXRPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_PROJ4_LIBS))))\nESMF_F90LINKLIBS          += $(ESMF_PROJ4_LIBS)\nESMF_F90LINKRPATHSTHIRD   += $(addprefix $(ESMF_F90RPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_PROJ4_LIBS))))\nendif\nifdef ESMF_PROJ4_LIBPATH\nESMF_CXXLINKPATHSTHIRD    += -L$(ESMF_PROJ4_LIBPATH)\nESMF_F90LINKPATHSTHIRD    += -L$(ESMF_PROJ4_LIBPATH)\nESMF_CXXLINKRPATHSTHIRD   += $(ESMF_CXXRPATHPREFIX)$(ESMF_PROJ4_LIBPATH)\nESMF_F90LINKRPATHSTHIRD   += $(ESMF_F90RPATHPREFIX)$(ESMF_PROJ4_LIBPATH)\nendif\nendif\n\n#-------------------------------------------------------------------------------\n# Babeltrace\n#-------------------------------------------------------------------------------\nifeq ($(ESMF_BABELTRACE),standard)\nifneq ($(origin ESMF_BABELTRACE_LIBS), environment)\nESMF_BABELTRACE_LIBS = -lbabeltrace-ctf\nendif\nendif\n\nifdef ESMF_BABELTRACE\nESMF_CPPFLAGS                += -DESMF_BABELTRACE=1\nifdef ESMF_BABELTRACE_INCLUDE\nESMF_CXXCOMPILEPATHSTHIRD    += -I$(ESMF_BABELTRACE_INCLUDE)\nESMF_F90COMPILEPATHSTHIRD    += -I$(ESMF_BABELTRACE_INCLUDE)\nendif\nifdef ESMF_BABELTRACE_LIBS\nESMF_CXXLINKLIBS          += $(ESMF_BABELTRACE_LIBS)\nESMF_CXXLINKRPATHSTHIRD   += $(addprefix $(ESMF_CXXRPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_BABELTRACE_LIBS))))\nESMF_F90LINKLIBS          += $(ESMF_BABELTRACE_LIBS)\nESMF_F90LINKRPATHSTHIRD   += $(addprefix $(ESMF_F90RPATHPREFIX),$(subst -L,,$(filter -L%,$(ESMF_BABELTRACE_LIBS))))\nendif\nifdef ESMF_BABELTRACE_LIBPATH\nESMF_CXXLINKPATHSTHIRD    += -L$(ESMF_BABELTRACE_LIBPATH)\nESMF_F90LINKPATHSTHIRD    += -L$(ESMF_BABELTRACE_LIBPATH)\nESMF_CXXLINKRPATHSTHIRD   += $(ESMF_CXXRPATHPREFIX)$(ESMF_BABELTRACE_LIBPATH)\nESMF_F90LINKRPATHSTHIRD   += $(ESMF_F90RPATHPREFIX)$(ESMF_BABELTRACE_LIBPATH)\nendif\nendif\n\n#-------------------------------------------------------------------------------\n# Set the correct MPIRUN command with appropriate options\n#-------------------------------------------------------------------------------\nESMF_MPIRUNCOMMAND  = $(shell $(ESMF_DIR)/scripts/mpirun.command $(ESMF_DIR)/scripts $(ESMF_MPIRUN))\nifeq ($(ESMF_MPIRUNCOMMAND),esmfscript)\nESMF_MPIRUN := $(ESMF_DIR)/scripts/$(ESMF_MPIRUN) $(ESMF_MPISCRIPTOPTIONS)\nendif\n\n#-------------------------------------------------------------------------------\n# ESMF_PTHREADS is passed (by CPP) into the library compilation to control the\n# dependency of the ESMF library on Pthreads.\n#-------------------------------------------------------------------------------\nifeq ($(ESMF_PTHREADS),OFF)\nESMF_CPPFLAGS       += -DESMF_NO_PTHREADS\nendif\n# even when compiling with ESMF_PTHREADS=ON we need to find common header\nESMF_CXXCOMPILEPATHSLOCAL += -I$(ESMF_DIR)/src/Infrastructure/stubs/pthread\n\n#-------------------------------------------------------------------------------\n# ESMF_OPENMP is passed (by CPP) into the library compilation to control the\n# dependency of the ESMF library on OpenMP.\n#-------------------------------------------------------------------------------\nifeq ($(ESMF_OPENMP),OFF)\nESMF_CPPFLAGS       += -DESMF_NO_OPENMP\nendif\n\nifeq ($(ESMF_OPENMP),ON)\nESMF_F90COMPILEOPTS += $(ESMF_OPENMP_F90COMPILEOPTS)\nESMF_F90LINKOPTS    += $(ESMF_OPENMP_F90LINKOPTS)\nESMF_CXXCOMPILEOPTS += $(ESMF_OPENMP_CXXCOMPILEOPTS)\nESMF_CXXLINKOPTS    += $(ESMF_OPENMP_CXXLINKOPTS)\nESMF_SL_LIBOPTS     += $(ESMF_OPENMP_CXXLINKOPTS)\nendif\n\n#-------------------------------------------------------------------------------\n# ESMF_OPENACC is passed (by CPP) into the library compilation to control the\n# dependency of the ESMF library on OpenACC.\n#-------------------------------------------------------------------------------\nifeq ($(ESMF_OPENACC),OFF)\nESMF_CPPFLAGS       += -DESMF_NO_OPENACC\nendif\n\nifeq ($(ESMF_OPENACC),ON)\nESMF_F90COMPILEOPTS += $(ESMF_OPENACC_F90COMPILEOPTS)\nESMF_F90LINKOPTS    += $(ESMF_OPENACC_F90LINKOPTS)\nESMF_CXXCOMPILEOPTS += $(ESMF_OPENACC_CXXCOMPILEOPTS)\nESMF_CXXLINKOPTS    += $(ESMF_OPENACC_CXXLINKOPTS)\nendif\n\n#-------------------------------------------------------------------------------\n# ESMF_TESTEXHAUSTIVE is passed (by CPP) into test programs to control the\n# number of tests that a test program will do.\n#-------------------------------------------------------------------------------\nifeq ($(ESMF_TESTEXHAUSTIVE),ON) \nESMF_CPPFLAGS       += -DESMF_TESTEXHAUSTIVE \nendif\n\n#-------------------------------------------------------------------------------\n# ESMF_BOPT is passed (by CPP) into test programs to control any differences\n# between the different BOPT modes.\n#-------------------------------------------------------------------------------\nESMF_CPPFLAGS       += -DESMF_BOPT_$(ESMF_BOPT)\n\n#-------------------------------------------------------------------------------\n# ESMF_TESTCOMPTUNNEL is passed (by CPP) into test programs to control the\n# dependency on ESMF-threading.\n#-------------------------------------------------------------------------------\nifeq ($(ESMF_TESTCOMPTUNNEL),ON)\nESMF_CPPFLAGS       += -DESMF_TESTCOMPTUNNEL\nendif\n\n#-------------------------------------------------------------------------------\n# ESMF_TESTWITHTHREADS is passed (by CPP) into test programs to control the\n# dependency on ESMF-threading.\n#-------------------------------------------------------------------------------\nifeq ($(ESMF_TESTWITHTHREADS),ON)\nESMF_CPPFLAGS       += -DESMF_TESTWITHTHREADS\nendif\n\n#-------------------------------------------------------------------------------\n# Add ESMF_ABISTRING to preprocessor flags\n#-------------------------------------------------------------------------------\n\nESMF_CPPFLAGS        +=-DS$(ESMF_ABISTRING)=1\n\n#-------------------------------------------------------------------------------\n# Add ESMF_OS to preprocessor flags\n#-------------------------------------------------------------------------------\n\nESMF_CPPFLAGS        +=-DESMF_OS_$(ESMF_OS)=1\n\n#-------------------------------------------------------------------------------\n# Add ESMF_COMM to preprocessor flags\n#-------------------------------------------------------------------------------\n\nESMF_CPPFLAGS        +=-DESMF_COMM=$(ESMF_COMM)\n\n#-------------------------------------------------------------------------------\n# Add ESMF_DIR to preprocessor flags\n#-------------------------------------------------------------------------------\n\nESMF_CPPFLAGS        +=-DESMF_DIR=$(ESMF_DIR)\n\n#-------------------------------------------------------------------------------\n# construct precompiler flags to be used on Fortran sources\n#-------------------------------------------------------------------------------\n\nESMF_FPPFLAGS        += $(addprefix $(ESMF_FPPPREFIX), $(ESMF_CPPFLAGS))\n\n#-------------------------------------------------------------------------------\n# common variables\nLIBNAME\t\t= $(ESMF_LIBDIR)/$(LIBBASE).$(ESMF_LIB_SUFFIX)\nESMFLIB\t\t= $(ESMF_LIBDIR)/libesmf.$(ESMF_LIB_SUFFIX)\nSOURCE\t\t= $(SOURCEC) $(SOURCEF)\nOBJS\t\t= $(OBJSC) $(OBJSF)\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n# Test an installation pointed to by ESMFMKFILE\n#-------------------------------------------------------------------------------\n\nifeq ($(ESMF_TESTESMFMKFILE),ON)\nifeq (\"$(wildcard $(ESMFMKFILE))\",\"\")\n$(error ESMF_TESTESMFMKFILE=ON, but the file indicated by ESMFMKFILE variable does not exist: $(ESMFMKFILE))\nendif\ninclude $(ESMFMKFILE)\nESMFLIB =\nESMF_LIBDIR = $(ESMF_LIBSDIR)\nESMF_APPSDIR = $(ESMF_BUILD)/apps/apps$(ESMF_BOPT)/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_ABI).$(ESMF_COMM).$(ESMF_SITE)\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Superstructure/WebServices/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Superstructure/ESMFMod/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Superstructure/State/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/Util/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/Base/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/VM/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/Attribute/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/Array/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/ArrayBundle/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/ArraySpec/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/DELayout/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/DistGrid/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/LocalArray/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/LogErr/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/Mesh/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/PointList/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/TimeMgr/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/Trace/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/Grid/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/Route/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/Infrastructure/Field/include\nESMF_INTERNALINCDIRS  += -I$(ESMF_BUILD)/src/epilogue/include\nexport ESMF_AUTO_LIB_BUILD=OFF\nifeq ($(ESMF_TESTEXHAUSTIVE),ON) \nESMF_F90COMPILEOPTS   += -DESMF_TESTEXHAUSTIVE \nESMF_CXXCOMPILEOPTS   += -DESMF_TESTEXHAUSTIVE \nendif\n\nendif\n\n#-------------------------------------------------------------------------------\n# Build variables for static wrapping and preloading functions for ESMF trace\n#-------------------------------------------------------------------------------\n\nESMF_TRACE_BUILD_SHARED := ON\n\nifeq ($(strip $(ESMF_SL_LIBS_TO_MAKE)),)\nESMF_TRACE_BUILD_SHARED := OFF\nendif\nifneq (,$(findstring ESMF_NO_DLFCN,$(ESMF_CXXCOMPILECPPFLAGS)))\nESMF_TRACE_BUILD_SHARED := OFF\nendif\nifeq ($(ESMF_OS),Cygwin)\n# Cygwin does not support RTLD_NEXT needed by dlsym\nESMF_TRACE_BUILD_SHARED := OFF\nendif\n\nifeq ($(ESMF_TRACE_BUILD_SHARED),ON)\nESMF_TRACE_LDPRELOAD := $(ESMF_LIBDIR)/libesmftrace_preload.$(ESMF_SL_SUFFIX)\nESMF_PRELOADSCRIPT = $(ESMF_LIBDIR)/preload.sh\n\nifneq ($(ESMF_OS),Darwin)\nESMF_ENV_PRELOAD = LD_PRELOAD\nelse\nESMF_ENV_PRELOAD = DYLD_INSERT_LIBRARIES\nendif\n\n# MPI implementations do not pick up LD_PRELOAD\n# so we pass a small script to each MPI task\nifneq (,$(findstring mpich,$(ESMF_COMM)))\nESMF_PRELOAD_SH = $(ESMF_PRELOADSCRIPT)\nendif\nifeq ($(ESMF_COMM),mpi)\nESMF_PRELOAD_SH = $(ESMF_PRELOADSCRIPT)\nendif\nifeq ($(ESMF_COMM),mpt)\nESMF_PRELOAD_SH = $(ESMF_PRELOADSCRIPT)\nendif\n\nendif\n\nbuild_preload_script:\n\t-@echo \"#!/bin/sh\" > $(ESMF_PRELOADDIR)/preload.sh\n\t-@echo \"# Script to preload ESMF dynamic trace library\" >> $(ESMF_PRELOADDIR)/preload.sh\n\t-@echo 'env LD_PRELOAD=\"$$LD_PRELOAD $(ESMF_PRELOADDIR)/libesmftrace_preload.$(ESMF_SL_SUFFIX)\" $$*' >> $(ESMF_PRELOADDIR)/preload.sh\n\tchmod 755 $(ESMF_PRELOADDIR)/preload.sh\n\nESMF_TRACE_STATICLINKLIBS := -lesmftrace_static\n\nESMF_TRACE_WRAPPERS_IO  := write writev pwrite read open\nESMF_TRACE_WRAPPERS_MPI := MPI_Allgather MPI_Allgatherv MPI_Allreduce MPI_Alltoall\nESMF_TRACE_WRAPPERS_MPI += MPI_Alltoallv MPI_Alltoallw MPI_Barrier MPI_Bcast\nESMF_TRACE_WRAPPERS_MPI += MPI_Gather MPI_Gatherv MPI_Recv MPI_Reduce\nESMF_TRACE_WRAPPERS_MPI += MPI_Scatter MPI_Send MPI_Sendrecv MPI_Wait\nESMF_TRACE_WRAPPERS_MPI += MPI_Waitall MPI_Waitany MPI_Waitsome\nESMF_TRACE_WRAPPERS_MPI += mpi_allgather_ mpi_allgather__ mpi_allgatherv_ mpi_allgatherv__\nESMF_TRACE_WRAPPERS_MPI += mpi_allreduce_ mpi_allreduce__ mpi_alltoall_ mpi_alltoall__\nESMF_TRACE_WRAPPERS_MPI += mpi_alltoallv_ mpi_alltoallv__ mpi_alltoallw_ mpi_alltoallw__\nESMF_TRACE_WRAPPERS_MPI += mpi_barrier_ mpi_barrier__ mpi_bcast_ mpi_bcast__\nESMF_TRACE_WRAPPERS_MPI += mpi_exscan_ mpi_exscan__ mpi_gather_ mpi_gather__\nESMF_TRACE_WRAPPERS_MPI += mpi_gatherv_ mpi_gatherv__ mpi_recv_ mpi_recv__\nESMF_TRACE_WRAPPERS_MPI += mpi_reduce_ mpi_reduce__ mpi_reduce_scatter_ mpi_reduce_scatter__\nESMF_TRACE_WRAPPERS_MPI += mpi_scatter_ mpi_scatter__ mpi_scatterv_ mpi_scatterv__\nESMF_TRACE_WRAPPERS_MPI += mpi_scan_ mpi_scan__ mpi_send_ mpi_send__\nESMF_TRACE_WRAPPERS_MPI += mpi_wait_ mpi_wait__ mpi_waitall_ mpi_waitall__\nESMF_TRACE_WRAPPERS_MPI += mpi_waitany_ mpi_waitany__\n\nCOMMA := ,\nESMF_TRACE_STATICLINKOPTS := -static -Wl,--wrap=c_esmftrace_notify_wrappers -Wl,--wrap=c_esmftrace_isinitialized\nESMF_TRACE_STATICLINKOPTS += $(addprefix -Wl$(COMMA)--wrap=, $(ESMF_TRACE_WRAPPERS_IO))\nESMF_TRACE_STATICLINKOPTS += $(addprefix -Wl$(COMMA)--wrap=, $(ESMF_TRACE_WRAPPERS_MPI))\n\n#-------------------------------------------------------------------------------\n#-------------------------------------------------------------------------------\n#-------------------------------------------------------------------------------\n\n\n#-------------------------------------------------------------------------------\n# HOWTO:  Warning: Here there be dragons.\n#\n# There is this file (build/common.mk), there are platform-dependent makefiles\n# (build_config/<platform+compiler>/build_rules.mk), and there are\n# makefiles in each subdir.  Needless to say, this makes things confusing\n# when trying to decide where to make changes.  \n# \n# Here are a few things to know about targets in this file:\n# \n# If you need to make a new target which should be called in each\n# of the possible source subdirectories, you will typically have to\n# add at least two targets:  \"fred:\" and \"tree_fred:\".  The plain\n# target is the one you invoke, and it should look like this:\n# \n# fred:\n# \tcd $(ESMF_DIR) ;\\\n# \t$(MAKE) ACTION=tree_fred tree\n# \n# \"tree\" is a preexisting target in this file which recursively descends \n# the build tree (using the DIR= settings in each individual makefile \n# to know which subdirs to descend into), and it calls 'make $ACTION' \n# in each of the subdirs.   Since you do not want to replicate the target\n# in each of the 100s of individual makefiles, typically you put the\n# tree_target here in this file as well, and it feeds off variables\n# which are set in the individual makefiles (e.g. SOURCEF, CLEANDIRS, etc).\n# Look at some of the existing tree_<xxx> rules for ideas on how to\n# add new targets.\n# \n# If you need to make a target which does not work on every subdirectory\n# you can still put the target here, but do not change to the top level\n# dir before executing the rule.\n# \n# Since the \"clean\" and \"clobber\" targets remove directories that are needed\n# the next time you build, there are chkdir_<fred> targets which ensure the \n# directories are created first, so the individual rules which follow can \n# just assume that those directories succeed.  Notice that the rules use\n# the -p option on mkdir which ensures intermediate directories are created\n# if they do not exist.\n# \n# Some of the library rules below are complicated by the fact that some\n# compilers will not let you control where .mod fortran module files are\n# created; they are created in the current directory.  Rather than try to\n# copy them into the target directory (which can be complicated by some\n# systems making .MOD files and some making .mod files), we instead cd into\n# the mod directory and then compile from there using full pathnames.\n# This also ensures that if multiple builds are running for different\n# target compilers they do not interfere with each other since each mod\n# directory is separate based on the platform and compiler.\n# \n# Another complication: we have to support the ability to build in a\n# different tree than the source files.  This might be used if the user\n# has a shared copy of the source checked out and does not have write\n# permission in those directories, or if the output has to appear in a\n# different set of directories, for example to merge with a larger build\n# system.  Users can set ESMF_BUILD to another location.  Any files which\n# are created should use variables which feed off ESMF_BUILD for output,\n# and use ESMF_DIR for files which were checked out of CVS and only\n# used as input.  ESMF_DIR is set to be ESMF_DIR for the framework\n# and EVA builds, and to ESMF_IMPL_DIR for the Implementation Report.\n# ESMF_BUILD always defaults to the same location as ESMF_DIR.\n#\n# Good luck.\n#\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n# Create various directories where files expect to be copied into.\n#-------------------------------------------------------------------------------\nchk_dir: chkdir_lib\n\nchkdir_lib:\n\t@if [ ! -d $(ESMF_LIBDIR) ]; then \\\n\t  echo Making directory $(ESMF_LIBDIR) for library; \\\n\t  mkdir -p $(ESMF_LIBDIR) ; fi\n\t@if [ ! -d $(ESMF_MODDIR) ]; then \\\n\t  echo Making directory $(ESMF_MODDIR) for *.mod files; \\\n\t  mkdir -p $(ESMF_MODDIR) ; fi\nifeq ($(ESMF_DEFER_LIB_BUILD),ON)\n\t@if [ ! -d $(ESMF_OBJDIR) ]; then \\\n\t  echo Making directory $(ESMF_OBJDIR) for *.o files; \\\n\t  mkdir -p $(ESMF_OBJDIR) ; fi\nendif\n\nchkdir_doc:\n\t@if [ ! -d $(ESMF_DOCDIR) ]; then \\\n\t  echo Making directory $(ESMF_DOCDIR) for documents; \\\n\t  mkdir -p $(ESMF_DOCDIR) ; fi\n\nchkdir_tests:\n\t@if [ ! -d $(ESMF_TESTDIR) ]; then \\\n\t  echo Making directory $(ESMF_TESTDIR) for test output; \\\n\t  mkdir -p $(ESMF_TESTDIR) ; fi\n\nchkdir_include:\n\t@if [ ! -d $(ESMF_INCDIR) ]; then \\\n\t  echo Making directory $(ESMF_INCDIR) for include files; \\\n\t  mkdir -p $(ESMF_INCDIR) ; fi\n\nchkdir_etc:\n\t@if [ ! -d $(ESMF_ETCDIR) ]; then \\\n\t  echo Making directory $(ESMF_ETCDIR) for Attribute package files; \\\n\t  mkdir -p $(ESMF_ETCDIR) ; fi\n\nchkdir_examples:\n\t@if [ ! -d $(ESMF_EXDIR) ]; then \\\n\t  echo Making directory $(ESMF_EXDIR) for examples output; \\\n\t  mkdir -p $(ESMF_EXDIR) ; fi\n\nchkdir_apps:\n\t@if [ ! -d $(ESMF_APPSDIR) ]; then \\\n\t  echo Making directory $(ESMF_APPSDIR) for apps output; \\\n\t  mkdir -p $(ESMF_APPSDIR) ; fi\n\nchkdir_locobj:\n\t@if [ ! -d $(ESMF_LOCOBJDIR) ]; then \\\n\t  echo Making directory $(ESMF_LOCOBJDIR) for apps output; \\\n\t  mkdir -p $(ESMF_LOCOBJDIR) ; fi\n\n# use these targets if the libdir, testdir, etc. must be there already. \n# this target prints a fail message and exits if not present.\nreqdir_lib:  \nifneq ($(ESMF_TESTESMFMKFILE),ON)\n\t@if [ ! -d $(ESMF_LIBDIR) ]; then \\\n\t  echo \"ESMF library directory not found:\" ; \\\n\t  echo \" $(ESMF_LIBDIR) \" ; \\\n\t  echo \"Library must be built first, or verify the current value of ESMF_BOPT\" ; \\\n          echo \" has the same setting as at library build time.\" ; \\\n\t  echo \"\" ; \\\n          $(MAKE) err ; fi\n\t@if [ ! -d $(ESMF_MODDIR) ]; then \\\n\t  echo \"ESMF module directory not found:\" ; \\\n\t  echo \" $(ESMF_MODDIR) \" ; \\\n\t  echo \"Library must be built first, or verify the current value of ESMF_BOPT\" ; \\\n          echo \" has the same setting as at library build time.\" ; \\\n\t  echo \"\" ; \\\n          $(MAKE) err ; fi\nendif\n\nreqdir_tests:  \n\t@if [ ! -d $(ESMF_TESTDIR) ]; then \\\n\t  echo \"ESMF test directory not found:\" ; \\\n\t  echo \" $(ESMF_TESTDIR) \" ; \\\n\t  echo \"Tests must be built first, or verify the current value of ESMF_BOPT\" ; \\\n          echo \" has the same setting as at test build time.\" ; \\\n\t  echo \"\" ; \\\n          $(MAKE) err ; fi\n\nreqdir_examples:  \n\t@if [ ! -d $(ESMF_EXDIR) ]; then \\\n\t  echo \"ESMF examples directory not found:\" ; \\\n\t  echo \" $(ESMF_EXDIR) \" ; \\\n\t  echo \"Examples must be built first, or verify the current value of ESMF_BOPT\" ; \\\n          echo \" has the same setting as at example build time.\" ; \\\n\t  echo \"\" ; \\\n          $(MAKE) err ; fi\n\n#-------------------------------------------------------------------------------\n# test to see if this will help our lack of real dependencies.  require that\n# the file libesmf.a exists in the lib dir; if not, build it.  if it is there,\n# call it success, even if a source file is more recent than the lib.\n\nreqfile_libesmf:\nifneq ($(ESMF_TESTESMFMKFILE),ON)\n\t@if [ ! -f $(ESMFLIB) ]; then \\\n\t  $(MAKE) lib ; fi\nendif\n\n#-------------------------------------------------------------------------------\n# This target used to check that variables which had to have settings\n# were indeed set.  All have been removed now, but this target is still\n# here keep from breaking other dependency rules.  At some point it can\n# go away.\nchkopts:\n\t@echo \"\"\n\n# Does nothing; needed for some rules that require actions.\nfoo:\n\n#-------------------------------------------------------------------------------\n# Builds ESMF recursively.\n#-------------------------------------------------------------------------------\n\n# The GNUMake variable VPATH specifies a list of directories that make should\n# search to find prerequisites and targets that are not in the current directory.\nVPATH = $(ESMF_DIR)/$(LOCDIR) $(ESMF_DIR)/$(LOCDIR)/../include \\\n\t$(ESMF_INCDIR) $(ESMF_CONFDIR) $(ESMF_SITEDIR)\n\nifeq ($(ESMF_DEFER_LIB_BUILD),ON)\nlibc: $(addprefix $(ESMF_OBJDIR)/,$(OBJSC))\nlibf: $(addprefix $(ESMF_OBJDIR)/,$(OBJSF))\nelse\nlibc:$(LIBNAME)($(OBJSC))\nlibf:$(LIBNAME)($(OBJSF))\nendif\n\n# TODO: the dependencies need fixing here.\n# the goal here is to only rebuild libesmf.a when a source file has\n# changed - but this rule invokes a traversal of the entire source\n# tree each time.   i guess what really needs to be done is that a\n# real 'make depend' rule needs to make libesmf.a dependent on all\n# the constituent .h, .C, and .F90 files without doing a full tree\n# traversal.  having this line commented in makes it try to call the\n# build_libs rule each time the unit tests, examples, or system tests\n# are built, whether it's needed or not.\n#\n## building the libesmf.a file\n#$(ESMFLIB):  build_libs\n\n\n# Build all of ESMF from the top.  This target can be called from any\n# subdir and it will go up to the top dir and build from there.\nlib: info\n\t@$(MAKE) build_libs\n\t@$(MAKE) build_tracelibs\n\t@$(MAKE) info_mk\n\t@echo \"ESMF library built successfully on \"`date`\n\t@echo \"To verify, build and run the unit and system tests with: $(MAKE) check\"\n\t@echo \" or the more extensive: $(MAKE) all_tests\"\n\nbuild_libs: chkdir_lib include_n_etc\n\tcd $(ESMF_DIR) ; $(MAKE) ACTION=tree_lib tree\nifeq ($(ESMF_DEFER_LIB_BUILD),ON)\n\tcd $(ESMF_DIR) ; $(MAKE) defer\nendif\n\tcd $(ESMF_DIR) ; $(MAKE) ranlib\nifneq ($(strip $(ESMF_SL_LIBS_TO_MAKE)),)\n\tcd $(ESMF_DIR) ; $(MAKE) shared\nendif\n\nbuild_tracelibs:\nifeq ($(ESMF_TRACE_LIB_BUILD),ON)\n\tcd $(ESMF_DIR)/src/Infrastructure/Trace/preload ;\\\n\t$(MAKE) tracelib_static\nifeq ($(ESMF_TRACE_BUILD_SHARED),ON)\n\tcd $(ESMF_DIR)/src/Infrastructure/Trace/preload ;\\\n\t$(MAKE) tracelib_preload\nendif\nendif\n\n# Build only stuff in and below the current dir.\nbuild_here: chkdir_lib chkdir_include chkdir_etc\n\t$(MAKE) ACTION=\"tree_include tree_etc\" tree\n\t$(MAKE) ACTION=tree_lib tree\nifeq ($(ESMF_DEFER_LIB_BUILD),ON)\n\t$(MAKE) defer\nendif\n\t$(MAKE) ranlib\nifneq ($(strip $(ESMF_SL_LIBS_TO_MAKE)),)\n\t$(MAKE) shared\nendif\n\n# Builds library - action for the 'tree' target.\ntree_lib:\n\tdir=`pwd`; cd $(ESMF_MODDIR); $(MAKE) -f $${dir}/makefile MAKEFILE=$${dir}/makefile esmflib\n\n# Builds library\nesmflib:: chkdir_lib $(SOURCE)\n\t@if [ \"$(SOURCEC)\" != \"\" ] ; then \\\n\t\t$(MAKE) -f $(MAKEFILE) libc ; fi\n\t@if [ \"$(SOURCEF)\" != \"\" ] ; then \\\n\t\t$(MAKE) -f $(MAKEFILE) libf ; fi\n\n# copy private include files into src/include directory.\ninclude: chkdir_include $(if $(findstring ON,$(ESMF_DEFER_LIB_BUILD)),chkdir_lib)\n\tcd $(ESMF_DIR) ;\\\n\t$(MAKE) ACTION=tree_include tree\n\n# action for 'tree' include target.\ntree_include:\n\t@for hfile in ${STOREH} foo ; do \\\n\t  if [ $$hfile != \"foo\" ]; then \\\n\t    cp -fp ../include/$$hfile $(ESMF_INCDIR) ; \\\n\t  fi ; \\\n\tdone\n\n# copy private attpack files into src/etc directory.\netc: chkdir_etc $(if $(findstring ON,$(ESMF_DEFER_LIB_BUILD)),chkdir_lib)\n\tcd $(ESMF_DIR) ;\\\n\t$(MAKE) ACTION=tree_etc tree\n\n# action for 'tree' etc target.\ntree_etc:\n\t@for etcfile in ${STOREETC} foo ; do \\\n\t  if [ $$etcfile != \"foo\" ]; then \\\n\t    cp -fp ../etc/$$etcfile $(ESMF_ETCDIR) ; \\\n\t  fi ; \\\n\tdone\n\n# combined include and etc target that walks the tree only once\ninclude_n_etc: chkdir_include chkdir_etc $(if $(findstring ON,$(ESMF_DEFER_LIB_BUILD)),chkdir_lib)\n\tcd $(ESMF_DIR) ;\\\n        $(MAKE) ACTION=\"tree_include tree_etc\" tree\n        \n# extra indirection to allow build_libs to be turned off in targets using it\nautobuild_libs:\nifeq ($(ESMF_AUTO_LIB_BUILD),OFF)\n\t$(MAKE) reqfile_libesmf\nelse\n\t$(MAKE) build_libs\nendif\n\n#-------------------------------------------------------------------------------\n# Clean and clobber targets.\n#  \n# The clean and clobber targets are controlled by the settings of the\n# variables CLEANFILES, CLEANDIRS and CLOBBERDIRS.  These variables\n# are set in the local makefiles.\n# \n#    CLEANFILES lists the files that should be removed during a clean.\n# \n#    CLEANDIRS lists the directories that should be removed during a\n#    clean.\n#\n#    CLOBBERDIRS lists the directories that should be removed during a\n#    clobber.\n#\n# The clean and clobber targets recursively call make with the tree\n# target.  The current directory and directories below will be cleaned\n# or clobbered.  The clobber target first calls gmake with the clean target\n# before the clobber actions are taken.\n# ------------------------------------------------------------------------------\n\n# default list of files and dirs to clean (and surprisingly to me, \n# you cannot enclose these in quotes - they are preserved and the quotes\n# prevent the wildcards from being expanded.)\n\nCLEAN_DEFDIRS = coredir.*\nCLEAN_DEFAULTS = *.o *.$(ESMF_SL_SUFFIX) *.mod core ESM*.stdout ESM*.Log PET*.Log *ESMF_LogFile\nCLEAN_TEXFILES = *.aux *.bbl *.blg *.log *.toc *.dvi *.ps *.ORIG *.out\n\nclean:\n\t$(MAKE) ACTION=tree_clean tree\n\n# the GNU standard target is 'distclean' but we have had clobber in here\n# for a long time, so for backward compatibility, leave them both.\n\ndistclean: clobber\n\n# figure out if the current dir is the same as ESMF_DIR.  set the inode\n# makefile variables here first, because it is easier to parse out the\n# first word of the output with makefile builtins rather than depend on\n# awk or some other command which must then be identical on every system \n# we try to support.   the -i on the ls command prints the numerical inode\n# number of the directory; do it in this indirect way because the simple\n# string comparison fails easily because of simple formatting differences\n# (e.g. trailing slash vs not)\n\nexport INODE1 = $(word 1, $(shell ls -di .) )\nexport INODE2 = $(word 1, $(shell ls -di $(ESMF_DIR)) )\n\nclobber:\n\t@if [ $(INODE1) != $(INODE2) ] ; then \\\n\t  echo \"\" ; \\\n\t  echo \"Must run distclean or clobber from ESMF_DIR\" ; \\\n\t  echo \"\" ; \\\n\t  echo \"Current physical directory is `pwd -P`\" ; \\\n\t  echo \"ESMF_DIR is $(ESMF_DIR)\" ; \\\n\t  echo \"\" ; \\\n\t  echo \"If dealing with symlinked directories, make sure that\" ; \\\n\t  echo \"ESMF_DIR is assigned the physical location, e.g. via 'pwd -P'.\" ; \\\n\t  echo \"\" ; \\\n\t  $(MAKE) err ; \\\n\tfi \n\t$(MAKE) clean \n\t@for DIR in $(CLOBBERDIRS) foo ; do \\\n\t   if [ $$DIR != \"foo\" ] ; then \\\n\t      $(ESMF_RM) -r $$DIR ;\\\n\t   fi ;\\\n\tdone\n\n\n# action for 'tree' target.\ntree_clean:\n\t@for DIR in $(CLEANDIRS) $(CLEAN_DEFDIRS) foo ; do \\\n\t   if [ $$DIR != \"foo\" ] ; then \\\n\t      $(ESMF_RM) -r $$DIR ;\\\n\t   fi ;\\\n\tdone\n\t$(ESMF_RM) $(CLEANFILES) $(CLEAN_DEFAULTS)\n        \ntree_cleanfiles:\n\t$(ESMF_RM) $(CLEANFILES) $(CLEAN_DEFAULTS)\n\n# target which does a light cleaning - remove files only under the src dir \n#  (logfiles, doc files, test output files, files made by preprocessing, etc)\n#  leaves the libs, executables, etc alone.\nmostlyclean:\n\t@cd $(ESMF_BUILD)/src ;\\\n\t$(MAKE) ACTION=tree_mostlyclean tree\n\ntree_mostlyclean:\n\t@for DIR in $(MOSTLYCLEANDIRS) foo ; do \\\n\t   if [ $$DIR != \"foo\" ] ; then \\\n\t      cd $$DIR; $(MAKE) ACTION=tree_clean tree ;\\\n\t   fi ;\\\n\tdone\n\n#-------------------------------------------------------------------------------\n# Generic target for building and running all tests and examples\n#-------------------------------------------------------------------------------\n\n# vars used below in the all_tests target, because these are in the pattern\n# (build, run), (build, run), ... not (build, build, ...) then (run, run, ...)\n\nTEST_TARGETS = build_unit_tests run_unit_tests \\\n               build_system_tests run_system_tests\n\nALLTEST_TARGETS = $(TEST_TARGETS) \\\n                  build_examples run_examples\n\nTEST_TARGETS_UNI = build_unit_tests run_unit_tests_uni \\\n                   build_system_tests run_system_tests_uni\n\nALLTEST_TARGETS_UNI = $(TEST_TARGETS_UNI) \\\n                      build_examples run_examples_uni\n\n\n# TODO: a bit more on what eventually these targets should be:\n#\n# according to the GNU conventions, 'gmake check' should test the build.\n# so check builds and runs the unit and system tests with TESTEXHAUSTIVE\n# pinned off.  this does a cursory check, not a full, exhaustive check.\n#\n# 'gmake all_tests' makes and runs the full set of tests, respecting the user\n# setting for TESTEXHAUSTIVE.  it runs the unit tests, system tests, and\n# examples.\n#\n# 'gmake validate' should probably do some numerical validation to make\n# sure we have something like bit reproducibility, that we are not going to\n# have wordsize problems, etc.   for now, we have no tests like that so it\n# just runs the unit tests.\n#\n\n# quick sanity check, defaulting to TESTEXHAUSTIVE OFF but respecting\n# the user setting if it already has a value.\ncheck: info\n\t@if [ $(ESMF_COMM) = \"mpiuni\" ] ; then \\\n\t  $(MAKE) clean_check $(TEST_TARGETS_UNI) results_ck_summary ;\\\n\telse \\\n\t  $(MAKE) clean_check $(TEST_TARGETS) results_ck_summary ;\\\n        fi\n\n\nbuild_check:\n\t$(MAKE) build_unit_tests build_system_tests \n\n\nrun_check:\n\t@if [ $(ESMF_COMM) = \"mpiuni\" ] ; then \\\n\t  $(MAKE) run_unit_tests_uni run_system_tests_uni ; \\\n\telse \\\n\t  $(MAKE) run_unit_tests run_system_tests ;\\\n        fi\n\n\nclean_check:\n\t$(MAKE) clean_unit_tests clean_system_tests\n\n\n# all tests, respecting user setting of TESTEXHAUSTIVE\nall_tests: info\n\t@if [ $(ESMF_COMM) = \"mpiuni\" ] ; then \\\n\t  $(MAKE) $(ALLTEST_TARGETS_UNI) results_summary ;\\\n\telse \\\n\t  $(MAKE) $(ALLTEST_TARGETS) results_summary ;\\\n        fi\n\nall_tests_uni: info\n\t$(MAKE) $(ALLTEST_TARGETS_UNI) results_summary\n\ndust_all_tests: dust_unit_tests dust_system_tests dust_examples\n\nbuild_all_tests: clean_if_exhaustive_flag_mismatch\n\t$(MAKE) build_unit_tests build_system_tests build_examples\n\nrun_all_tests:\n\t@if [ $(ESMF_COMM) = \"mpiuni\" ] ; then \\\n\t  $(MAKE) run_unit_tests_uni run_system_tests_uni \\\n                  run_examples_uni results_summary ;\\\n\telse \\\n\t  $(MAKE) run_unit_tests run_system_tests \\\n                  run_examples results_summary ;\\\n        fi\n\nrun_all_tests_uni:\n\t$(MAKE) run_unit_tests_uni run_system_tests_uni \\\n          run_examples_uni results_summary\n\nclean_all_tests:\n\t$(MAKE) clean_unit_tests clean_system_tests clean_examples\n\n\n# TODO: reserved for running any numerical validation tests, wordsize and\n# precision tests - things which might give wrong computational answers.\n# (currently just run the unit tests because these are not written yet.)\nvalidate:\n\t@if [ $(ESMF_COMM) = \"mpiuni\" ] ; then \\\n\t  $(MAKE) unit_tests_uni ;\\\n\telse \\\n\t  $(MAKE) unit_tests ;\\\n        fi\n\n\nbuild_validate:\n\t$(MAKE) build_unit_tests \n\n\nrun_validate:\n\t@if [ $(ESMF_COMM) = \"mpiuni\" ] ; then \\\n\t  $(MAKE) run_unit_tests_uni ;\\\n\telse \\\n\t  $(MAKE) run_unit_tests ;\\\n        fi\n\n\nclean_validate:\n\t$(MAKE) clean_unit_tests \n\n\n#-------------------------------------------------------------------------------\n# Targets for building apps.\n#-------------------------------------------------------------------------------\n\n#\n# build_apps\n#\nbuild_apps: test_esmfmkfile reqfile_libesmf reqdir_lib\n\tcd $(ESMF_DIR)/src/apps; $(MAKE) ACTION=tree_build_apps tree\n\t@echo \"ESMF apps built successfully.\"\n# Notice: the cd into \"$(ESMF_DIR)/src/apps\" before the tree target above\n# makes this a lot faster than a complete tree traversal starting at the root!\n\ntree_build_apps: $(APPS_BUILD)\n\n#\n#  Link rule for apps, switch between C and Fortran\n#\nifeq ($(APPS_MAINLANGUAGE),C)\n$(ESMF_APPSDIR)/% : $(addprefix $(ESMF_LOCOBJDIR)/,$(APPS_OBJ)) $(ESMFLIB)\n\t$(MAKE) chkdir_apps\n\t$(ESMF_CXXLINKER) $(ESMF_CXXLINKOPTS) $(ESMF_CXXLINKPATHS) $(ESMF_CXXLINKRPATHS) $(ESMF_EXEOUT_OPTION) $(addprefix $(ESMF_LOCOBJDIR)/,$(APPS_OBJ)) $(ESMF_CXXESMFLINKLIBS)\nelse        \n$(ESMF_APPSDIR)/% : $(addprefix $(ESMF_LOCOBJDIR)/,$(APPS_OBJ)) $(ESMFLIB)\n\t$(MAKE) chkdir_apps\n\t$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) $(ESMF_EXEOUT_OPTION) $(addprefix $(ESMF_LOCOBJDIR)/,$(APPS_OBJ)) $(ESMF_F90ESMFLINKLIBS)\nendif\n\n#-------------------------------------------------------------------------------\n# Targets for building and running system tests.\n#-------------------------------------------------------------------------------\n\nsystem_tests: test_esmfmkfile chkdir_tests autobuild_libs dust_system_tests\n\t@if [ -d $(ESMF_STDIR) ] ; then cd $(ESMF_STDIR); fi; \\\n\tif [ ! $(SYSTEM_TEST)foo = foo ] ; then \\\n\t   if [ -d $(SYSTEM_TEST) ] ; then \\\n\t       cd $(SYSTEM_TEST); \\\n           else \\\n               echo \"SYSTEM_TEST $(SYSTEM_TEST) does not exist.\"; \\\n               exit; \\\n\t   fi; \\\n\t   echo current working directory is now `pwd` ; \\\n        fi; \\\n\tif [ $(ESMF_COMM) = \"mpiuni\" ] ; then \\\n          echo \"Cannot run multiprocessor system tests when ESMF_COMM is mpiuni;\" ; \\\n\t  echo \"run system_tests_uni instead.\" ; \\\n\t  echo \"\" ; \\\n\t  $(MAKE) err ; \\\n          exit ; \\\n\tfi ; \\\n\t$(MAKE) MULTI=\"Multiprocessor\" config_sys_tests update_sys_tests_flags; \\\n\t$(MAKE) ACTION=tree_system_tests tree ; \\\n\t$(MAKE) check_system_tests\n\ntree_system_tests: tree_build_system_tests tree_run_system_tests\n\n#\n# system_tests_uni, build and run uni versions of the system tests\n#\nsystem_tests_uni: test_esmfmkfile chkdir_tests autobuild_libs dust_system_tests\n\t@if [ -d $(ESMF_STDIR) ] ; then cd $(ESMF_STDIR); fi; \\\n\tif [ ! $(SYSTEM_TEST)foo = foo ] ; then \\\n\t   if [ -d $(SYSTEM_TEST) ] ; then \\\n\t       cd $(SYSTEM_TEST); \\\n           else \\\n              echo \"SYSTEM_TEST $(SYSTEM_TEST) does not exist.\"; \\\n              exit; \\\n\t   fi; \\\n\t   echo current working directory is now `pwd` ; \\\n\tfi ; \\\n\t$(MAKE) MULTI=\"Uniprocessor\" config_sys_tests update_sys_tests_flags\n\t$(MAKE) ACTION=tree_system_tests_uni tree ; \\\n\t$(MAKE) check_system_tests\n\ntree_system_tests_uni: tree_build_system_tests tree_run_system_tests_uni\n\n#\n# build_system_tests\n#\nbuild_system_tests: test_esmfmkfile reqfile_libesmf reqdir_lib chkdir_tests \n\t@if [ -d $(ESMF_STDIR) ] ; then cd $(ESMF_STDIR) ; fi; \\\n\tif [ ! $(SYSTEM_TEST)foo = foo ] ; then \\\n\t   if [ -d $(SYSTEM_TEST) ] ; then \\\n\t       cd $(SYSTEM_TEST); \\\n           else \\\n              echo \"SYSTEM_TEST $(SYSTEM_TEST) does not exist.\"; \\\n              exit; \\\n\t   fi; \\\n\t   echo current working directory is now `pwd` ; \\\n        fi ; \\\n\t$(MAKE) config_sys_tests update_sys_tests_flags ;\\\n\t$(MAKE) ACTION=tree_build_system_tests tree\n\techo \"ESMF system tests built successfully.\"\n\ntree_build_system_tests: $(SYSTEM_TESTS_BUILD) \n\n\n#\n# TODO: the RM in the link rules below means that any system test which \n# includes additional .o files (which most do) will always rebuild even if \n# it is up-to-date.  but we remove the .o and .mod files because we also\n# are required to be able to build multiple architectures from a single\n# build tree.  we currently have a race-condition with the system tests\n# in that we build with the current directory being the src dir, which\n# means compilers can trample each others .o and .mod files.  the library\n# cds into the lib or mod dir before compiling, so .o and .mod files\n# are created in a compiler/platform directory and do not interfere with\n# each other.  \n# \n# the fix for this is either to cd into the test dir before compiling\n# and linking, or to create a temp subdir based on the compiler/platform/\n# BOPT/SITE settings - so compiles are truly independent.\n#\n# this also applies to the tests, and examples.\n#\n\n#\n#  Link rule for Fortran system tests.\n#\n$(ESMF_TESTDIR)/ESMF_%STest : ESMF_%STest.o $(SYSTEM_TESTS_OBJ) $(addsuffix .$(ESMF_SL_SUFFIX), $(SYSTEM_TESTS_SHOBJ)) $(ESMFLIB)\n\t$(MAKE) chkdir_tests\n\t$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) $(ESMF_EXEOUT_OPTION) $(SYSTEM_TESTS_OBJ) $< $(ESMF_F90ESMFLINKLIBS)\n\t$(ESMF_RM) -f *.o *.mod\n\n\n# debugging aid:  link the executable, standard output, and log file to\n# temporary names in the current directory (they are built in the test\n# directory which is a long ways away from the source.  debuggers work\n# better if the current directory is the source dir, not the executable dir.)\n# example use:  gmake TNAME=FieldExcl system_test_links\nsystem_test_links:\n\t$(ESMF_RM) t s l\n\tln -s $(ESMF_TESTDIR)/ESMF_$(TNAME)STest t\n\tln -s $(ESMF_TESTDIR)/ESMF_$(TNAME)STest.stdout s\n\tln -s $(ESMF_TESTDIR)/ESMF_$(TNAME)STest.Log l\n\n#\n#  Link rule for Fortran system tests (MPMD).\n#\n$(ESMF_TESTDIR)/ESMF_%STestA : $(SYSTEM_TESTS_OBJ_A) $(ESMFLIB) ESMF_%STestA.o\n\t$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) $(ESMF_EXEOUT_OPTION) $(SYSTEM_TESTS_OBJ_A) ESMF_$*STestA.o $(ESMF_F90ESMFLINKLIBS)\n$(ESMF_TESTDIR)/ESMF_%STestB : $(SYSTEM_TESTS_OBJ_B) $(ESMFLIB) ESMF_%STestB.o \n\t$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) $(ESMF_EXEOUT_OPTION) $(SYSTEM_TESTS_OBJ_B) ESMF_$*STestB.o $(ESMF_F90ESMFLINKLIBS)\n$(ESMF_TESTDIR)/ESMF_%STestC : $(SYSTEM_TESTS_OBJ_C) $(ESMFLIB) ESMF_%STestC.o \n\t$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) $(ESMF_EXEOUT_OPTION) $(SYSTEM_TESTS_OBJ_C) ESMF_$*STestC.o $(ESMF_F90ESMFLINKLIBS)\n$(ESMF_TESTDIR)/ESMF_%STestD : $(SYSTEM_TESTS_OBJ_D) $(ESMFLIB) ESMF_%STestD.o \n\t$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) $(ESMF_EXEOUT_OPTION) $(SYSTEM_TESTS_OBJ_D) ESMF_$*STestD.o $(ESMF_F90ESMFLINKLIBS)\n$(ESMF_TESTDIR)/ESMF_%STestE : $(SYSTEM_TESTS_OBJ_E) $(ESMFLIB) ESMF_%STestE.o \n\t$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) $(ESMF_EXEOUT_OPTION) $(SYSTEM_TESTS_OBJ_E) ESMF_$*STestE.o $(ESMF_F90ESMFLINKLIBS)\nMPMDCLEANUP:\n\t$(ESMF_RM) -f *.o *.mod\n\n#\n# dust_system_tests\n#\ndust_system_tests:\n\t$(ESMF_RM) $(ESMF_TESTDIR)/system_tests_results\n\t$(ESMF_RM) $(ESMF_TESTDIR)/system_tests_ml_results\n\t$(ESMF_RM) $(ESMF_TESTDIR)/*STest.Log\n\t$(ESMF_RM) $(ESMF_TESTDIR)/*STest.stdout\n\t$(ESMF_RM) $(ESMF_TESTDIR)/*.rc\n\t$(ESMF_RM) $(ESMF_TESTDIR)/*.nc\n\t$(ESMF_RM) $(ESMF_TESTDIR)/data\n\n#\n# run_system_tests\n#\nrun_system_tests: test_esmfmkfile reqdir_tests update_sys_tests_flags\n\t@if [ $(ESMF_DIR) = `pwd` ] ; then \\\n\t  $(MAKE) dust_system_tests ; \\\n\tfi\n\t@if [ -d $(ESMF_STDIR) ] ; then cd $(ESMF_STDIR) ; fi; \\\n\tif [ ! $(SYSTEM_TEST)foo = foo ] ; then \\\n\t   if [ -d $(SYSTEM_TEST) ] ; then \\\n\t       cd $(SYSTEM_TEST); \\\n           else \\\n              echo \"SYSTEM_TEST $(SYSTEM_TEST) does not exist.\"; \\\n              exit; \\\n\t   fi; \\\n\t   echo current working directory is now `pwd` ; \\\n        fi; \\\n\tif [ $(ESMF_COMM) = \"mpiuni\" ] ; then \\\n          echo \"Cannot run multiprocessor system tests when ESMF_COMM is mpiuni;\" ; \\\n\t  echo \"run run_system_tests_uni instead.\" ; \\\n\t  echo \"\" ; \\\n\t  $(MAKE) err ; \\\n          exit; \\\n\tfi; \\\n        if [ -f $(SYS_TESTS_CONFIG) ] ; then \\\n           $(ESMF_SED) -e 's/ [A-Za-z][A-Za-z]*processor/ Multiprocessor/' $(SYS_TESTS_CONFIG) > $(SYS_TESTS_CONFIG).temp; \\\n           $(ESMF_MV) $(SYS_TESTS_CONFIG).temp $(SYS_TESTS_CONFIG); \\\n        fi; \\\n\t$(MAKE) ACTION=tree_run_system_tests tree\n\t$(MAKE) check_system_tests\n\ntree_run_system_tests: $(SYSTEM_TESTS_RUN) \n\n#\n# run_system_tests_uni\n#\nrun_system_tests_uni: test_esmfmkfile reqdir_tests update_sys_tests_flags\n\t@if [ $(ESMF_DIR) = `pwd` ] ; then \\\n\t  $(MAKE) dust_system_tests ; \\\n\tfi\n\t@if [ -f $(SYS_TESTS_CONFIG) ] ; then \\\n           $(ESMF_SED) -e 's/ [A-Za-z][A-Za-z]*processor/ Uniprocessor/' $(SYS_TESTS_CONFIG) > $(SYS_TESTS_CONFIG).temp; \\\n           $(ESMF_MV) $(SYS_TESTS_CONFIG).temp $(SYS_TESTS_CONFIG); \\\n        fi; \\\n\tif [ -d $(ESMF_STDIR) ] ; then cd $(ESMF_STDIR) ; fi; \\\n\tif [ ! $(SYSTEM_TEST)foo = foo ] ; then \\\n\t   if [ -d $(SYSTEM_TEST) ] ; then \\\n\t       cd $(SYSTEM_TEST); \\\n           else \\\n              echo \"SYSTEM_TEST $(SYSTEM_TEST) does not exist.\"; \\\n              exit; \\\n\t   fi; \\\n\t   echo current working directory is now `pwd` ; \\\n        fi; \\\n\t$(MAKE) ACTION=tree_run_system_tests_uni tree\n\t$(MAKE) check_system_tests\n\ntree_run_system_tests_uni: $(SYSTEM_TESTS_RUN_UNI)\n\n#\n# echo into a file how the tests were last run, multi or uni, so when the perl\n# scripts run to check the results it can find the correct system tests.\n# Assume Nontestmpmd and Nonsharedobj, they will be updated subsequently.\n#\nconfig_sys_tests:\n\t@echo \"# This file used by test scripts, please do not delete.\" > $(SYS_TESTS_CONFIG)\nifeq ($(MULTI),)\n\t@echo \"Last run Nontestmpmd Nontestsharedobj ;  Noprocessor\" >> $(SYS_TESTS_CONFIG)\nelse\n\t@echo \"Last run Nontestmpmd Nontestsharedobj ;\" $(MULTI) >> $(SYS_TESTS_CONFIG)\nendif\n\n\n\n#\n# verify that either there is no SYS_TESTS_CONFIG file, or if one exists that\n# the string Testmpmd or Nontestmpmd matches the current setting of the\n# ESMF_TESTMPMD environment variable and that the string Testsharedobj or\n# Nontestsharedobj matches the current setting of the ESMF_TESTSHAREDOBJ\n# environment variable.\n#\nupdate_sys_tests_flags:\nifeq ($(ESMF_TESTMPMD),ON)\n\t$(ESMF_SED) -e 's/ [A-Za-z][A-Za-z]*estmpmd/ Testmpmd/' $(SYS_TESTS_CONFIG) > $(SYS_TESTS_CONFIG).temp; \\\n\t$(ESMF_MV) $(SYS_TESTS_CONFIG).temp $(SYS_TESTS_CONFIG);\nelse\n\t$(ESMF_SED) -e 's/ [A-Za-z][A-Za-z]*estmpmd/ Nontestmpmd/' $(SYS_TESTS_CONFIG) > $(SYS_TESTS_CONFIG).temp; \\\n\t$(ESMF_MV) $(SYS_TESTS_CONFIG).temp $(SYS_TESTS_CONFIG);\nendif\nifeq ($(ESMF_TESTSHAREDOBJ),ON)\n\t$(ESMF_SED) -e 's/ [A-Za-z][A-Za-z]*estsharedobj/ Testsharedobj/' $(SYS_TESTS_CONFIG) > $(SYS_TESTS_CONFIG).temp; \\\n\t$(ESMF_MV) $(SYS_TESTS_CONFIG).temp $(SYS_TESTS_CONFIG);\nelse\n\t$(ESMF_SED) -e 's/ [A-Za-z][A-Za-z]*estsharedobj/ Nontestsharedobj/' $(SYS_TESTS_CONFIG) > $(SYS_TESTS_CONFIG).temp; \\\n\t$(ESMF_MV) $(SYS_TESTS_CONFIG).temp $(SYS_TESTS_CONFIG);\nendif\n\n\n#\n# run the systests, either redirecting the stdout from the command line, or\n# relying on the mpirun script to redirect stdout from inside the batch script.\n# the test macros open PETx.name.Log files by default (set when the tests \n# call ESMF_Initialize()).  after the tests run, we cat all the per-pet \n# files together into a single log file. \n#\nstest:\n\t-@cd $(ESMF_TESTDIR) ; \\\n\t$(ESMF_RM) ./PET*$(TNAME)STest.Log ; \\\n\tif [ $(ESMF_BATCHDEPRECATED) = \"true\" ] ; then \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(TNAME)STest ; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(TNAME)STest ; \\\n\telse \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(TNAME)STest 1\\> ./ESMF_$(TNAME)STest.stdout 2\\>\\&1 ; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(TNAME)STest 1> ./ESMF_$(TNAME)STest.stdout 2>&1 ; \\\n\tfi ; \\\n\tcat ./PET*$(TNAME)STest.Log> ./ESMF_$(TNAME)STest.Log ; \\\n\t$(ESMF_RM) ./PET*$(TNAME)STest.Log\n\n#\n# this target deletes only the system test related files from the test subdir\n#\nclean_system_tests:\n\t$(ESMF_RM) $(ESMF_TESTDIR)/*STest*  $(SYS_TESTS_CONFIG)\n\t$(ESMF_RM) $(ESMF_TESTDIR)/system_tests_results\n\t$(ESMF_RM) $(ESMF_TESTDIR)/system_tests_ml_results\n\t$(MAKE) ACTION=tree_cleanfiles tree\n\n#\n# report statistics on system tests\n#\ncheck_system_tests: \n\t@$(DO_ST_RESULTS)\n\n\n#\n# run the system tests memory leak report.\n#\ncheck_system_tests_ml:\n\t@$(DO_ST_ML_RESULTS)\n\n\n\n#-------------------------------------------------------------------------------\n# Targets for building and running use test cases\n#-------------------------------------------------------------------------------\n\nuse_test_cases: test_esmfmkfile chkdir_tests\n\t@if [ -d $(ESMF_UTCDIR) ] ; then cd $(ESMF_UTCDIR); fi; \\\n\tif [ ! $(USE_TEST_CASE)foo = foo ] ; then \\\n\t   if [ -d $(USE_TEST_CASE) ] ; then \\\n\t       cd $(USE_TEST_CASE); \\\n           else \\\n               echo \"USE_TEST_CASE $(USE_TEST_CASE) does not exist.\"; \\\n               echo \"Check out use_test_cases at the $(ESMF_DIR)/src directory.\"; \\\n               exit; \\\n\t   fi; \\\n\t   echo current working directory is now `pwd` ; \\\n        fi; \\\n\tif [ $(ESMF_COMM) = \"mpiuni\" ] ; then \\\n          echo \"Cannot run multiprocessor use test cases when ESMF_COMM is mpiuni;\" ; \\\n\t  echo \"run use_test_cases_uni instead.\" ; \\\n\t  echo \"\" ; \\\n\t  $(MAKE) err ; \\\n          exit ; \\\n\tfi; \\\n\t$(MAKE) ACTION=tree_use_test_cases tree ; \\\n\t$(MAKE) check_use_test_cases\n\ntree_use_test_cases: tree_build_use_test_cases tree_dry_run_use_test_cases tree_run_use_test_cases\n\n#\n# use_test_cases_uni, build and run uni versions of the use test cases\n#\nuse_test_cases_uni: test_esmfmkfile chkdir_tests\n\t@if [ -d $(ESMF_UTCDIR) ] ; then cd $(ESMF_UTCDIR); fi; \\\n\tif [ ! $(USE_TEST_CASE)foo = foo ] ; then \\\n\t   if [ -d $(USE_TEST_CASE) ] ; then \\\n\t       cd $(USE_TEST_CASE); \\\n           else \\\n              echo \"USE_TEST_CASE $(USE_TEST_CASE) does not exist.\"; \\\n              exit; \\\n\t   fi; \\\n\t   echo current working directory is now `pwd` ; \\\n\tfi; \\\n\t$(MAKE) ACTION=tree_use_test_cases_uni tree ; \\\n\t$(MAKE) check_use_test_cases\n\ntree_use_test_cases_uni: tree_build_use_test_cases tree_dry_run_use_test_cases tree_run_use_test_cases_uni\n\n#\n# build_use_test_cases\n#\nbuild_use_test_cases: test_esmfmkfile reqfile_libesmf reqdir_lib chkdir_tests\n\t@if [ -d $(ESMF_UTCDIR) ] ; then cd $(ESMF_UTCDIR) ; fi; \\\n\tif [ ! $(USE_TEST_CASE)foo = foo ] ; then \\\n\t   if [ -d $(USE_TEST_CASE) ] ; then \\\n\t       cd $(USE_TEST_CASE); \\\n           else \\\n              echo \"USE_TEST_CASE $(USE_TEST_CASE) does not exist.\"; \\\n              exit; \\\n\t   fi; \\\n\t   echo current working directory is now `pwd` ; \\\n        fi; \\\n\t$(MAKE) ACTION=tree_build_use_test_cases tree ; \\\n\techo \"ESMF use test cases built successfully.\"\n\ntree_build_use_test_cases: chkdir_tests $(USE_TEST_CASES_BUILD)\n\n\n#\n# TODO: the RM in the link rules below means that any use test case which \n# includes additional .o files (which most do) will always rebuild even if \n# it is up-to-date.  but we remove the .o and .mod files because we also\n# are required to be able to build multiple architectures from a single\n# build tree.  we currently have a race-condition with the system tests\n# in that we build with the current directory being the src dir, which\n# means compilers can trample each others .o and .mod files.  the library\n# cds into the lib or mod dir before compiling, so .o and .mod files\n# are created in a compiler/platform directory and do not interfere with\n# each other.  \n# \n# the fix for this is either to cd into the test dir before compiling\n# and linking, or to create a temp subdir based on the compiler/platform/\n# BOPT/SITE settings - so compiles are truly independent.\n#\n# this also applies to the tests, and examples.\n#\n\n#\n#  Link rule for Fortran use test cases.\n#\n$(ESMF_TESTDIR)/ESMF_%UseTestCase : ESMF_%UseTestCase.o $(USE_TEST_CASES_OBJ) $(ESMFLIB)\n\t$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) $(ESMF_EXEOUT_OPTION) $(USE_TEST_CASES_OBJ) $< $(ESMF_F90ESMFLINKLIBS)\n\t$(ESMF_RM) -f *.o *.mod\n\n\n# debugging aid:  link the executable, standard output, and log file to\n# temporary names in the current directory (they are built in the test\n# directory which is a long ways away from the source.  debuggers work\n# better if the current directory is the source dir, not the executable dir.)\n# example use:  gmake TNAME=FieldExcl system_test_links\nuse_test_cases_links:\n\t$(ESMF_RM) t s l\n\tln -s $(ESMF_TESTDIR)/ESMF_$(TNAME)UseTestCase t\n\tln -s $(ESMF_TESTDIR)/ESMF_$(TNAME)UseTestCase.stdout s\n\tln -s $(ESMF_TESTDIR)/ESMF_$(TNAME)UseTestCase.Log l\n\n#\n#  Link rule for Fortran use test cases (MPMD).\n#\n$(ESMF_TESTDIR)/ESMF_%UseTestCaseA : $(USE_TEST_CASES_OBJ_A) $(ESMFLIB) ESMF_%UseTestCaseA.o\n\t$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) $(ESMF_EXEOUT_OPTION) $(USE_TEST_CASES_OBJ_A) ESMF_$*UseTestCaseA.o $(ESMF_F90ESMFLINKLIBS)\n$(ESMF_TESTDIR)/ESMF_%UseTestCaseB : $(USE_TEST_CASES_OBJ_B) $(ESMFLIB) ESMF_%UseTestCaseB.o \n\t$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) $(ESMF_EXEOUT_OPTION) $(USE_TEST_CASES_OBJ_B) ESMF_$*UseTestCaseB.o $(ESMF_F90ESMFLINKLIBS)\n$(ESMF_TESTDIR)/ESMF_%UseTestCaseC : $(USE_TEST_CASES_OBJ_C) $(ESMFLIB) ESMF_%UseTestCaseC.o \n\t$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) $(ESMF_EXEOUT_OPTION) $(USE_TEST_CASES_OBJ_C) ESMF_$*UseTestCaseC.o $(ESMF_F90ESMFLINKLIBS)\n$(ESMF_TESTDIR)/ESMF_%UseTestCaseD : $(USE_TEST_CASES_OBJ_D) $(ESMFLIB) ESMF_%UseTestCaseD.o \n\t$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) $(ESMF_EXEOUT_OPTION) $(USE_TEST_CASES_OBJ_D) ESMF_$*UseTestCaseD.o $(ESMF_F90ESMFLINKLIBS)\n$(ESMF_TESTDIR)/ESMF_%UseTestCaseE : $(USE_TEST_CASES_OBJ_E) $(ESMFLIB) ESMF_%UseTestCaseE.o \n\t$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) $(ESMF_EXEOUT_OPTION) $(USE_TEST_CASES_OBJ_E) ESMF_$*UseTestCaseE.o $(ESMF_F90ESMFLINKLIBS)\n\n#\n# run_use_test_cases\n#\nrun_use_test_cases: test_esmfmkfile reqdir_tests\n\t@if [ -d $(ESMF_UTCDIR) ] ; then cd $(ESMF_UTCDIR) ; fi; \\\n\tif [ ! $(USE_TEST_CASE)foo = foo ] ; then \\\n\t   if [ -d $(USE_TEST_CASE) ] ; then \\\n\t       cd $(USE_TEST_CASE); \\\n           else \\\n              echo \"USE_TEST_CASE $(USE_TEST_CASE) does not exist.\"; \\\n              echo \"Check out use_test_cases at the $(ESMF_DIR)/src directory.\"; \\\n              exit; \\\n\t   fi; \\\n\t   echo current working directory is now `pwd` ; \\\n        fi; \\\n\tif [ $(ESMF_COMM) = \"mpiuni\" ] ; then \\\n          echo \"Cannot run multiprocessor use test cases when ESMF_COMM is mpiuni;\" ; \\\n\t  echo \"run run_use_test_cases_uni instead.\" ; \\\n\t  echo \"\" ; \\\n\t  $(MAKE) err ; \\\n          exit ; \\\n\tfi; \\\n\t$(MAKE) ACTION=tree_run_use_test_cases tree ; \\\n\t$(MAKE) check_use_test_cases\n\ntree_run_use_test_cases: tree_dry_run_use_test_cases $(USE_TEST_CASES_RUN) \n\n#\n# run_use_test_cases_uni\n#\nrun_use_test_cases_uni: test_esmfmkfile reqdir_tests\n\t@if [ -d $(ESMF_UTCDIR) ] ; then cd $(ESMF_UTCDIR) ; fi; \\\n\tif [ ! $(USE_TEST_CASE)foo = foo ] ; then \\\n\t   if [ -d $(USE_TEST_CASE) ] ; then \\\n\t       cd $(USE_TEST_CASE); \\\n           else \\\n              echo \"USE_TEST_CASE  $(USE_TEST_CASE) does not exist.\"; \\\n               echo \"Checkout use_test_cases at the $(ESMF_DIR)/src directory.\"; \\\n              exit; \\\n\t   fi; \\\n\t   echo current working directory is now `pwd` ; \\\n        fi; \\\n\t$(MAKE) ACTION=tree_run_use_test_cases_uni tree ; \\\n\t$(MAKE) check_use_test_cases\n\ntree_run_use_test_cases_uni: tree_dry_run_use_test_cases $(USE_TEST_CASES_RUN_UNI)\n\n\n#\n# dry_run_use_test_cases\n#\ndry_run_use_test_cases: test_esmfmkfile \n\t@if [ -d $(ESMF_UTCDIR) ] ; then cd $(ESMF_UTCDIR) ; fi; \\\n        if [ ! $(USE_TEST_CASE)foo = foo ] ; then \\\n           if [ -d $(USE_TEST_CASE) ] ; then \\\n               cd $(USE_TEST_CASE); \\\n           else \\\n              echo \"USE_TEST_CASE  $(USE_TEST_CASE) does not exist.\"; \\\n               echo \"Checkout use_test_cases at the $(ESMF_DIR)/src directory.\"; \\\n              exit; \\\n           fi; \\\n           echo current working directory is now `pwd` ; \\\n        fi; \\\n        $(MAKE) ACTION=tree_dry_run_use_test_cases tree \n\ntree_dry_run_use_test_cases: $(USE_TEST_CASES_DRY_RUN)\n\n#\n# run the use test cases, either redirecting the stdout from the command line, or\n# relying on the mpirun script to redirect stdout from inside the batch script.\n#\nuctest:\n\t-@if [ $(ESMF_BATCHDEPRECATED) = \"true\" ] ; then \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) $(ESMF_TESTDIR)/ESMF_$(TNAME)UseTestCase ; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) $(ESMF_TESTDIR)/ESMF_$(TNAME)UseTestCase ; \\\n\telse \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) $(ESMF_TESTDIR)/ESMF_$(TNAME)UseTestCase 1\\> $(ESMF_TESTDIR)/ESMF_$(TNAME)UseTestCase.stdout 2\\>\\&1 ; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) $(ESMF_TESTDIR)/ESMF_$(TNAME)UseTestCase 1> $(ESMF_TESTDIR)/ESMF_$(TNAME)UseTestCase.stdout 2>&1 ; \\\n\tfi \n\n#\n# this target deletes only the use test cases related files from the test subdir\n#\nclean_use_test_cases:\n\t$(ESMF_RM) $(ESMF_TESTDIR)/*UseTestCase* \n\n#\n# report statistics on system tests\n#\ncheck_use_test_cases: \n\t@$(DO_UTC_RESULTS)\n\n\n#-------------------------------------------------------------------------------\n#  Targets for building and running unit tests.\n#-------------------------------------------------------------------------------\n\n# TODO: the run_unit_tests targets below a the dash before the make \n# subcommand ( -$(MAKE) xxx ) to ignore the return code from the command.\n# i would prefer to not do this, but on at least one important platform (AIX) \n# we cannot force the fortran programs to exit with a zero return code if\n# all is well (it comes out 128).  if this gets fixed in our code, the dashes\n# can be removed and make can correctly stop on error.\n\nunit_tests: test_esmfmkfile chkdir_tests autobuild_libs dust_unit_tests\n\t@if [ $(ESMF_COMM) = \"mpiuni\" ] ; then \\\n          echo \"Cannot run multiprocessor unit tests when ESMF_COMM is mpiuni;\" ; \\\n\t  echo \"run unit_tests_uni instead.\" ; \\\n\t  echo \"\" ; \\\n\t  $(MAKE) err ; \\\n\tfi\n\t$(MAKE) MULTI=\"Multiprocessor\" config_unit_tests\n\t-$(MAKE) ACTION=tree_unit_tests tree\n\t$(MAKE) check_unit_tests\n\ntree_unit_tests: tree_build_unit_tests tree_run_unit_tests\n\n#\n# tests_uni\n#\nunit_tests_uni: test_esmfmkfile chkdir_tests autobuild_libs dust_unit_tests\n\t$(MAKE) MULTI=\"Uniprocessor\" config_unit_tests\n\t-$(MAKE) ACTION=tree_unit_tests_uni tree\n\t$(MAKE) check_unit_tests\n\ntree_unit_tests_uni: tree_build_unit_tests tree_run_unit_tests_uni\n\n#\n# build_unit_tests\n#\nbuild_unit_tests: test_esmfmkfile reqfile_libesmf reqdir_lib chkdir_tests verify_exhaustive_flag\n\t$(MAKE) config_unit_tests \n\t$(MAKE) ACTION=tree_build_unit_tests tree\n\t@echo \"ESMF unit tests built successfully.\"\n\ntree_build_unit_tests: $(TESTS_BUILD)\n\n\n$(ESMF_TESTDIR)/ESMF_%UTest : ESMF_%UTest.o $(ESMFLIB)\n\t$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) $(ESMF_EXEOUT_OPTION) $(ESMF_UTEST_$(*)_OBJS) $(TESTS_OBJ) $< $(ESMF_F90ESMFLINKLIBS)\n\t$(ESMF_RM) -f *.o *.mod\n\n\n$(ESMF_TESTDIR)/ESMC_%UTest : ESMC_%UTest.o $(ESMFLIB)\n\t$(ESMF_CXXLINKER) $(ESMF_CXXLINKOPTS) $(ESMF_CXXLINKPATHS) $(ESMF_CXXLINKRPATHS) $(ESMF_EXEOUT_OPTION) $(ESMC_UTEST_$(*)_OBJS) $< $(ESMF_CXXESMFLINKLIBS)\n\t$(ESMF_RM) -f *.o *.mod\n\n$(ESMF_TESTDIR)/ESMCI_%UTest : ESMCI_%UTest.o $(ESMFLIB)\n\t$(ESMF_CXXLINKER) $(ESMF_CXXLINKOPTS) $(ESMF_CXXLINKPATHS) $(ESMF_CXXLINKRPATHS) $(ESMF_EXEOUT_OPTION) $(ESMCI_UTEST_$(*)_OBJS) $< $(ESMF_CXXESMFLINKLIBS)\n\t$(ESMF_RM) -f *.o *.mod\n\n# debugging aid:  link the executable, standard output, and log file to\n# temporary names in the current directory (they are built in the test\n# directory which is a long ways away from the source.  debuggers work\n# better if the current directory is the source dir, not the executable dir.)\n# example use:  gmake TNAME=Field unit_test_links\nunit_test_links:\n\trm -f t s l\n\tln -s $(ESMF_TESTDIR)/ESMF_$(TNAME)UTest t\n\tln -s $(ESMF_TESTDIR)/ESMF_$(TNAME)UTest.stdout s\n\tln -s $(ESMF_TESTDIR)/ESMF_$(TNAME)UTest.Log l\n\n#\n# dust_unit_tests\n#\ndust_unit_tests: dust_test_harness\n\t$(ESMF_RM) $(ESMF_TESTDIR)/unit_tests_results\n\t$(ESMF_RM) $(ESMF_TESTDIR)/*UTest.Log\n\t$(ESMF_RM) $(ESMF_TESTDIR)/*UTest.stdout\n\t$(ESMF_RM) $(ESMF_TESTDIR)/*.rc\n\t$(ESMF_RM) $(ESMF_TESTDIR)/*.nc\n\t$(ESMF_RM) $(ESMF_TESTDIR)/data\n\n#\n# run_unit_tests\n#\nrun_unit_tests: test_esmfmkfile reqdir_tests verify_exhaustive_flag\n\t@if [ $(ESMF_COMM) = \"mpiuni\" ] ; then \\\n          echo \"Cannot run multiprocessor unit tests when ESMF_COMM is mpiuni;\" ; \\\n\t  echo \"run run_unit_tests_uni instead.\" ; \\\n\t  echo \"\" ; \\\n\t  $(MAKE) err ; \\\n\tfi\n\t@if [ $(ESMF_DIR) = `pwd` ] ; then \\\n\t  $(MAKE) dust_unit_tests ; \\\n\tfi\n\t@if [ -f $(UNIT_TESTS_CONFIG) ] ; then \\\n\t   $(ESMF_SED) -e 's/ [A-Za-z][A-Za-z]*processor/ Multiprocessor/' $(UNIT_TESTS_CONFIG) > $(UNIT_TESTS_CONFIG).temp; \\\n           $(ESMF_MV) $(UNIT_TESTS_CONFIG).temp $(UNIT_TESTS_CONFIG); \\\n        fi\n\t-$(MAKE) ACTION=tree_run_unit_tests tree\n\t$(MAKE) check_unit_tests\n\ntree_run_unit_tests: $(TESTS_RUN) \n\n#\n# run_unit_tests_uni\n#\nrun_unit_tests_uni: test_esmfmkfile reqdir_tests verify_exhaustive_flag\n\t@if [ $(ESMF_DIR) = `pwd` ] ; then \\\n\t  $(MAKE) dust_unit_tests ; \\\n\tfi\n\t@if [ -f $(UNIT_TESTS_CONFIG) ] ; then \\\n\t   $(ESMF_SED) -e 's/ [A-Za-z][A-Za-z]*processor/ Uniprocessor/' $(UNIT_TESTS_CONFIG) > $(UNIT_TESTS_CONFIG).temp; \\\n           $(ESMF_MV) $(UNIT_TESTS_CONFIG).temp $(UNIT_TESTS_CONFIG); \\\n        fi\n\t-$(MAKE) ACTION=tree_run_unit_tests_uni tree \n\t$(MAKE) check_unit_tests\n\ntree_run_unit_tests_uni: $(TESTS_RUN_UNI)\n\n#\n# echo into a file how the tests were last built and run, so when the perl\n# scripts run to check the results it can compute the number of messages that\n# should be found.  it needs to know exhaustive vs non to know how many total\n# tests we expected to execute; it needs to know multi vs uni so it knows\n# how many messages per test are generated.\n#\nconfig_unit_tests:\n\t@echo \"# This file used by test scripts, please do not delete.\" > $(UNIT_TESTS_CONFIG)\nifeq ($(ESMF_TESTEXHAUSTIVE),ON) \nifeq ($(MULTI),) \n\t@echo \"Last built Exhaustive ;  Last run Noprocessor\" >> $(UNIT_TESTS_CONFIG)\nelse\n\t@echo \"Last built Exhaustive ;  Last run\" $(MULTI) >> $(UNIT_TESTS_CONFIG)\nendif\nelse\nifeq ($(MULTI),) \n\t@echo \"Last built Non-exhaustive ;  Last run Noprocessor\" >> $(UNIT_TESTS_CONFIG)\nelse\n\t@echo \"Last built Non-exhaustive ;  Last run\" $(MULTI) >> $(UNIT_TESTS_CONFIG)\nendif\nendif\n\n#\n# verify that either there is no UNIT_TESTS_CONFIG file, or if one exists that\n# the string Exhaustive or Non-exhaustive matches the current setting of the\n# ESMF_TESTEXHAUSTIVE environment variable.  this is used when trying to run\n# already-built unit tests, to be sure the user has not changed the setting\n# of exhaustive and then assumed that it will take effect.  unfortunately at\n# this time, the flag is compile-time and not run-time.   \n#\nverify_exhaustive_flag:\nifeq ($(ESMF_TESTEXHAUSTIVE),ON) \n\t@$(MAKE) UNIT_TEST_STRING=\"Exhaustive\" exhaustive_flag_check\nelse\n\t@$(MAKE) UNIT_TEST_STRING=\"Non-exhaustive\" exhaustive_flag_check\nendif\n\nexhaustive_flag_check:\n\t@if [ -s $(UNIT_TESTS_CONFIG) -a \\\n\t     `$(ESMF_SED) -ne '/$(UNIT_TEST_STRING)/p' $(UNIT_TESTS_CONFIG) | $(ESMF_WC) -l` -ne 1 ] ; then \\\n\t  echo \"The ESMF_TESTEXHAUSTIVE environment variable is a compile-time control for\" ;\\\n          echo \"whether a basic set or an exhaustive set of tests are built.\" ;\\\n\t  echo \"\" ;\\\n\t  echo \"The current setting of ESMF_TESTEXHAUSTIVE is \\\"$(ESMF_TESTEXHAUSTIVE)\\\", which\" ;\\\n\t  echo \"is not the same as when the unit tests were last built.\" ;\\\n\t  echo \"(This is based on the contents of the file:\" ;\\\n          echo \"$(UNIT_TESTS_CONFIG) \";\\\n\t  echo \"which contains: `$(ESMF_SED) -e '1d' $(UNIT_TESTS_CONFIG)` ).\" ;\\\n\t  echo \"\" ;\\\n\t  echo \"To rebuild and run the unit tests with the current ESMF_TESTEXHAUSTIVE value, run:\" ;\\\n\t  echo \"   $(MAKE) clean_unit_tests unit_tests\"  ;\\\n\t  echo \"or change ESMF_TESTEXHAUSTIVE to ON or OFF to match the build-time value.\" ;\\\n\t  echo \"\" ;\\\n\t  $(MAKE) err ;\\\n\tfi\n\n# call clean only if flags do not match\nclean_if_exhaustive_flag_mismatch:\nifeq ($(ESMF_TESTEXHAUSTIVE),ON) \n\t@$(MAKE) UNIT_TEST_STRING=\"Exhaustive\" exhaustive_flag_clobber\nelse\n\t@$(MAKE) UNIT_TEST_STRING=\"Non-exhaustive\" exhaustive_flag_clobber\nendif\n\nexhaustive_flag_clobber:\n\t@if [ -s $(UNIT_TESTS_CONFIG) -a \\\n\t     `$(ESMF_SED) -ne '/$(UNIT_TEST_STRING)/p' $(UNIT_TESTS_CONFIG) | $(ESMF_WC) -l` -ne 1 ] ; then \\\n\t  $(MAKE) clean_unit_tests ;\\\n\tfi\n\n#\n# this target deletes only the unit test related files from the test subdir\n# so we can rebuild them with the proper flags if that is what is needed.\n#\nclean_unit_tests:\n\t$(ESMF_RM) $(ESMF_TESTDIR)/*UTest* $(UNIT_TESTS_CONFIG) $(TEST_HARNESS_LIST)\n\t$(MAKE) ACTION=tree_cleanfiles tree\n\n#\n# install unit tests benchmark directory\n#\ninstall_unit_tests_benchmark: reqdir_tests\n\t-@echo \" \"\n\t-@echo \"Installing unit tests benchmark directory\"\n\t-@echo \" \"\n\tmkdir -p $(ESMF_BENCHMARK_PREFIX_ABSPATH)/test/test$(ESMF_BOPT)/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_ABI).$(ESMF_COMM).$(ESMF_SITE)\n\tcp -f $(ESMF_TESTDIR)/ESM*UTest.stdout $(ESMF_BENCHMARK_PREFIX_ABSPATH)/test/test$(ESMF_BOPT)/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_ABI).$(ESMF_COMM).$(ESMF_SITE)/. \n\tdate > bm_timestamp\n\tmv -f bm_timestamp $(ESMF_BENCHMARK_PREFIX_ABSPATH)/test/test$(ESMF_BOPT)/$(ESMF_OS).$(ESMF_COMPILER).$(ESMF_ABI).$(ESMF_COMM).$(ESMF_SITE)/.\n\n#\n# run unit test benchmarking\n# \nrun_unit_tests_benchmark:\n\t@$(DO_UT_BM_RESULTS)\n\n#\n# report statistics on tests\n#\ncheck_unit_tests:\n\t@$(DO_UT_RESULTS)\n\n#\n# report statistics on memoey leak tests\n#\ncheck_unit_tests_ml:\n\t@$(DO_UT_ML_RESULTS)\n\n\n#\n# internal targets used to actually run the fortran and c++ unit tests\n#\n#  the call in the local makefiles is something like:\n#    $(MAKE) TNAME=testname NP=4 ftest\n#\n# running a test is:  remove any old existing per-process log files, then\n# run the test with the right number of processors.  the standard output is\n# captured in a .stdout file; the test macros open PETx.name.Log files by\n# default (set when the tests call ESMF_Initialize()).  after the tests run,\n# we cat all the per-pet files together into a single log file.  (after the\n# log can collate output from different PETs all by itself, we can remove\n# the cat step.)\n#\nftest:\n\t-@cd $(ESMF_TESTDIR) ; \\\n\t$(ESMF_RM) ./PET*$(TNAME)UTest.Log ; \\\n\tif [ $(ESMF_BATCHDEPRECATED) = \"true\" ] ; then \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(TNAME)UTest ; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(TNAME)UTest ; \\\n\telse \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(TNAME)UTest 1\\> ./ESMF_$(TNAME)UTest.stdout 2\\>\\&1 ; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(TNAME)UTest 1> ./ESMF_$(TNAME)UTest.stdout 2>&1 ; \\\n\tfi ; \\\n\tcat ./PET*$(TNAME)UTest.Log > ./ESMF_$(TNAME)UTest.Log ; \\\n\t$(ESMF_RM) ./PET*$(TNAME)UTest.Log\n\n\n# same as ftest target above, except turns on profiling\n# region timings appear at the end of the log files and a trace is generated\nftest_profile: \n\t-@cd $(ESMF_TESTDIR) ; \\\n\t$(ESMF_RM) ./PET*$(TNAME)UTest.Log ; \\\n\t$(ESMF_RM) -rf ./ESMF_$(TNAME)UTest_traceout ; \\\n\techo env ESMF_RUNTIME_TRACE=ON $(ESMF_MPIRUN) -np $(NP) ./ESMF_$(TNAME)UTest 1\\> ./ESMF_$(TNAME)UTest.stdout 2\\>\\&1 ; \\\n\tenv ESMF_RUNTIME_TRACE=ON $(ESMF_MPIRUN) -np $(NP) ./ESMF_$(TNAME)UTest 1> ./ESMF_$(TNAME)UTest.stdout 2>&1 ; \\\n\tcat ./PET*$(TNAME)UTest.Log > ./ESMF_$(TNAME)UTest.Log ; \\\n\t$(ESMF_MV) ./traceout ./ESMF_$(TNAME)UTest_traceout ; \\\n\t$(ESMF_RM) ./PET*$(TNAME)UTest.Log\n\n# same as ftest_profile target above, except also uses\n# LD_PRELOAD to override MPI/IO symbols and time them\nftest_profile_preload: \n\t-@cd $(ESMF_TESTDIR) ; \\\n\t$(ESMF_RM) ./PET*$(TNAME)UTest.Log ; \\\n\t$(ESMF_RM) -rf ./ESMF_$(TNAME)UTest_traceout ; \\\n\tif [ -z $(ESMF_PRELOAD_SH) ] ; then \\\n\t  echo env ESMF_RUNTIME_TRACE=ON $(ESMF_ENV_PRELOAD)=$(ESMF_TRACE_LDPRELOAD) $(ESMF_MPIRUN) -np $(NP) ./ESMF_$(TNAME)UTest 1\\> ./ESMF_$(TNAME)UTest.stdout 2\\>\\&1 ; \\\n\t  env ESMF_RUNTIME_TRACE=ON $(ESMF_ENV_PRELOAD)=$(ESMF_TRACE_LDPRELOAD) $(ESMF_MPIRUN) -np $(NP) ./ESMF_$(TNAME)UTest 1> ./ESMF_$(TNAME)UTest.stdout 2>&1 ; \\\n\telse \\\n\t  echo env ESMF_RUNTIME_TRACE=ON $(ESMF_MPIRUN) -np $(NP) $(ESMF_PRELOAD_SH) ./ESMF_$(TNAME)UTest 1\\> ./ESMF_$(TNAME)UTest.stdout 2\\>\\&1 ; \\\n\t  env ESMF_RUNTIME_TRACE=ON $(ESMF_MPIRUN) -np $(NP) $(ESMF_PRELOAD_SH) ./ESMF_$(TNAME)UTest 1> ./ESMF_$(TNAME)UTest.stdout 2>&1 ; \\\n\tfi ; \\\n\tcat ./PET*$(TNAME)UTest.Log > ./ESMF_$(TNAME)UTest.Log ; \\\n\t$(ESMF_MV) ./traceout ./ESMF_$(TNAME)UTest_traceout ; \\\n\t$(ESMF_RM) ./PET*$(TNAME)UTest.Log\n\nhtest:\n\t-@cd $(ESMF_TESTDIR) ; \\\n\t$(ESMF_RM) ./PET*$(TNAME)UTest.Log ESMF_$(TNAME)UTest.stdout ; \\\n\tif [ $(ESMF_BATCHDEPRECATED) = \"true\" ] ; then \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(TNAME)UTest -case $(TESTHARNESSCASE)_test.rc -xml $(TESTHARNESSCASE).xml; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(TNAME)UTest -case $(TESTHARNESSCASE)_test.rc -xml $(TESTHARNESSCASE).xml ; \\\n\t  if [ -f $(ESMF_TESTDIR)/ESMF_$(TNAME)UTest.stdout ] ; then \\\n\t\tmv -f $(ESMF_TESTDIR)/ESMF_$(TNAME)UTest.stdout $(ESMF_TESTDIR)/ESMF_$(HNAME)UTest.stdout ; \\\n\t  fi ; \\\n\telse \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(TNAME)UTest -case $(TESTHARNESSCASE)_test.rc -xml $(TESTHARNESSCASE).xml; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(TNAME)UTest -case $(TESTHARNESSCASE)_test.rc -xml $(TESTHARNESSCASE).xml 1> ./ESMF_$(HNAME)UTest.stdout 2>&1 ; \\\n\t  if [ -f $(ESMF_TESTDIR)/ESMF_$(TNAME)UTest.stdout ] ; then \\\n\t\tmv -f $(ESMF_TESTDIR)/ESMF_$(TNAME)UTest.stdout $(ESMF_TESTDIR)/ESMF_$(HNAME)UTest.stdout ; \\\n\t   fi ; \\\n\tfi ; \\\n\tcat ./PET*$(TNAME)UTest.Log > ./ESMF_$(HNAME)UTest.Log ; \\\n\t$(ESMF_RM) ./PET*$(TNAME)UTest.Log ; \\\n\tif [ -f $(TESTHARNESSCASE).xml ] ; then \\\n\t\techo xsltproc -o $(TESTHARNESSCASE).html $(ESMF_DIR)/src/test_harness/src/HarnessHttp.xslt $(TESTHARNESSCASE).xml ; \\\n\t\txsltproc -o $(TESTHARNESSCASE).html $(ESMF_DIR)/src/test_harness/src/HarnessHttp.xslt $(TESTHARNESSCASE).xml ; \\\n\tfi\n\n### TNAME=TestHarness HNAME=$(TESTHARNESSCASE)_NP$(NP) TESTHARNESSPATH=$(PWD)\n\nctest:\n\t-@cd $(ESMF_TESTDIR) ; \\\n\t$(ESMF_RM) ./PET*$(TNAME)UTest.Log ; \\\n\tif [ $(ESMF_BATCHDEPRECATED) = \"true\" ] ; then \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMC_$(TNAME)UTest ; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMC_$(TNAME)UTest ; \\\n\telse \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMC_$(TNAME)UTest 1\\> ./ESMC_$(TNAME)UTest.stdout 2\\>\\&1 ; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMC_$(TNAME)UTest 1> ./ESMC_$(TNAME)UTest.stdout 2>&1 ; \\\n\tfi ; \\\n\tcat ./PET*$(TNAME)UTest.Log > ./ESMC_$(TNAME)UTest.Log ; \\\n\t$(ESMF_RM) ./PET*$(TNAME)UTest.Log\n\ncitest:\n\t-@cd $(ESMF_TESTDIR) ; \\\n\t$(ESMF_RM) ./PET*$(TNAME)UTest.Log ; \\\n\tif [ $(ESMF_BATCHDEPRECATED) = \"true\" ] ; then \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMCI_$(TNAME)UTest ; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMCI_$(TNAME)UTest ; \\\n\telse \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMCI_$(TNAME)UTest 1\\> ./ESMCI_$(TNAME)UTest.stdout 2\\>\\&1 ; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMCI_$(TNAME)UTest 1> ./ESMCI_$(TNAME)UTest.stdout 2>&1 ; \\\n\tfi ; \\\n\tcat ./PET*$(TNAME)UTest.Log > ./ESMCI_$(TNAME)UTest.Log ; \\\n\t$(ESMF_RM) ./PET*$(TNAME)UTest.Log\n\n##########################\n# prepare to run test harness\ndust_test_harness:\n\t$(ESMF_RM) $(ESMF_TESTDIR)/test_harness.*\n\n#\n# run test harness\n#    parameters\n#        TESTHARNESSCASE    test case name\n#        NP                 number of processors\n#\n#\n#    internal\n#        TNAME    test name (hardcoded TestHarness)\n#        HNAME    unique name base on suite and number of processors\n#\n#    environment\n#        MPIRUN        mpirun command\n#        ESMF_TESTDIR  test directory\n#\n# need UNI case, NP=UNI?\n#\n#\nrun_test_harness: \n\t$(MAKE) TNAME=TestHarness HNAME=$(TESTHARNESSCASE)_NP$(NP) run_test_harness_sec\n\n# target with expanded parameters\nrun_test_harness_sec:\n\t@if [ -f $(ESMF_TESTDIR)/test_harness.list ] ; then \\\n\t  if ! grep ESMF_$(HNAME)UTest $(ESMF_TESTDIR)/test_harness.list ; then \\\n\t    echo ESMF_$(HNAME)UTest >> $(ESMF_TESTDIR)/test_harness.list ; \\\n\t  fi ; \\\n\telse \\\n\t  echo ESMF_$(HNAME)UTest > $(ESMF_TESTDIR)/test_harness.list ; \\\n\tfi ; \\\n\tif [ -d harness_config ] ; then \\\n\t  if [ -f harness_config/$(TESTHARNESSCASE)_test.rc ] ; then \\\n\t    cp -f harness_config/$(TESTHARNESSCASE)_*.rc $(ESMF_TESTDIR) ; \\\n            cp -f harness_config/$(TESTHARNESSCASE)_test.rc $(ESMF_TESTDIR)/test_harness.rc ; \\\n\t    $(MAKE) htest ; \\\n\t  else \\\n\t    echo \"FAIL: missing file - harness_config/$(TESTHARNESSCASE)_test.rc\" ; \\\n\t  fi ; \\\n\telse \\\n\t  echo \"FAIL: missing directory - harness_config\" ; \\\n\tfi\n\n#-------------------------------------------------------------------------------\n#  Obsolete targets for building and running unit tests.  Echo an error\n#  and point users to updated target names.\n#-------------------------------------------------------------------------------\n\n.PHONY: tests build_tests run_tests tests_uni run_tests_uni check_tests err\n\ntests: ; $(error Obsolete target, use unit_tests now)\n\nbuild_tests: ; $(error Obsolete target, use build_unit_tests now)\n\nrun_tests: ; $(error Obsolete target, use run_unit_tests now)\n\ntests_uni: ; $(error Obsolete target, use unit_tests_uni now)\n\nrun_tests_uni: ; $(error Obsolete target, use run_unit_tests_uni now)\n\ncheck_tests: ; $(error Obsolete target, use check_unit_tests now)\n\nerr: ; $(error gnumake exiting)\n\n\n#-------------------------------------------------------------------------------\n# Targets for building and running examples\n#\n#  The example targets depend on variables set in the\n#  makefile in the example source code directory.  The \n#  variables are:\n#\n#      EXAMPLES_BUILD should list the full path all of the \n#      example executables to be made.  The example executables\n#      have to be built in $(ESMF_EXDIR).  \n#\n#      EXAMPLES_RUN and EXAMPLES_RUN_UNI list the run targets\n#      of the individual executables.  The run targets are defined\n#      in the source code makefiles.  EXAMPLES_RUN list the targets\n#      that run the examples on multiply processors.  EXAMPLES_RUN_UNI\n#      lists the targets that run the examples on single processors.\n#\n#-------------------------------------------------------------------------------      \n\n#\n# examples\n#\nexamples: test_esmfmkfile chkdir_examples autobuild_libs dust_examples\n\t@if [ $(ESMF_COMM) = \"mpiuni\" ] ; then \\\n          echo \"Cannot run multiprocessor examples when ESMF_COMM is mpiuni;\" ; \\\n\t  echo \"run examples_uni instead.\" ; \\\n\t  echo \"\" ; \\\n\t  $(MAKE) err ; \\\n\tfi\n\t$(MAKE) MULTI=\"Multiprocessor\" config_examples\n\t-$(MAKE) ACTION=tree_examples tree\n\t$(MAKE) check_examples\n\n\ntree_examples: tree_build_examples tree_run_examples\n\n#\n# examples_uni\n#\nexamples_uni: test_esmfmkfile chkdir_examples autobuild_libs dust_examples\n\t$(MAKE) MULTI=\"Uniprocessor\" config_examples\n\t-$(MAKE) ACTION=tree_examples_uni tree\n\t$(MAKE) check_examples\n\ntree_examples_uni: tree_build_examples tree_run_examples_uni\n\n#\n# build_examples\n#\nbuild_examples: test_esmfmkfile reqfile_libesmf reqdir_lib chkdir_examples\n\t$(MAKE) config_examples\n\t$(MAKE) ACTION=tree_build_examples tree\n\t@echo \"ESMF examples built successfully.\"\n\ntree_build_examples: $(EXAMPLES_BUILD) \n\n#\n#  Examples Link commands\n#\n$(ESMF_EXDIR)/ESMF_%Ex : ESMF_%Ex.o $(ESMFLIB)\n\t$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) $(ESMF_EXEOUT_OPTION) $(ESMF_EXAMPLE_$(*)_OBJS) $< $(ESMF_F90ESMFLINKLIBS)\n\t$(ESMF_RM) -f *.o *.mod\n\n\n$(ESMF_EXDIR)/ESMC_%Ex: ESMC_%Ex.o $(ESMFLIB)\n\t$(ESMF_CXXLINKER) $(ESMF_CXXLINKOPTS) $(ESMF_CXXLINKPATHS) $(ESMF_CXXLINKRPATHS) $(ESMF_EXEOUT_OPTION) $(ESMC_EXAMPLE_$(*)_OBJS) $< $(ESMF_CXXESMFLINKLIBS)\n\t$(ESMF_RM) $<\n\n#\n# dust_examples\n#\ndust_examples:\n\t$(ESMF_RM) $(ESMF_EXDIR)/examples_results\n\t$(ESMF_RM) $(ESMF_EXDIR)/*Ex.Log\n\t$(ESMF_RM) $(ESMF_EXDIR)/*Ex.stdout\n\t$(ESMF_RM) $(ESMF_EXDIR)/*.rc\n\t$(ESMF_RM) $(ESMF_EXDIR)/*.nc\n\t$(ESMF_RM) $(ESMF_EXDIR)/data\n\n#\n# run_examples\n#\nrun_examples: test_esmfmkfile reqdir_examples\n\t@if [ $(ESMF_COMM) = \"mpiuni\" ] ; then \\\n          echo \"Cannot run multiprocessor examples when ESMF_COMM is mpiuni;\" ; \\\n\t  echo \"run run_examples_uni instead.\" ; \\\n\t  echo \"\" ; \\\n\t  $(MAKE) err ; \\\n\tfi\n\t@if [ $(ESMF_DIR) = `pwd` ] ; then \\\n\t  $(MAKE) dust_examples ; \\\n\tfi\n\t@if [ -f $(EXAMPLES_CONFIG) ] ; then \\\n\t   $(ESMF_SED) -e 's/ [A-Za-z][A-Za-z]*processor/ Multiprocessor/' $(EXAMPLES_CONFIG) > $(EXAMPLES_CONFIG).temp; \\\n\t   $(ESMF_MV) $(EXAMPLES_CONFIG).temp $(EXAMPLES_CONFIG); \\\n\tfi\n\t-$(MAKE) ACTION=tree_run_examples tree\n\t$(MAKE) check_examples\n\ntree_run_examples: $(EXAMPLES_RUN) \n\n\n# run_examples_uni\n#\nrun_examples_uni: test_esmfmkfile reqdir_examples\n\t@if [ $(ESMF_DIR) = `pwd` ] ; then \\\n\t  $(MAKE) dust_examples ; \\\n\tfi\n\t@if [ -f $(EXAMPLES_CONFIG) ] ; then \\\n\t   $(ESMF_SED) -e 's/ [A-Za-z][A-Za-z]*processor/ Uniprocessor/' $(EXAMPLES_CONFIG) > $(EXAMPLES_CONFIG).temp; \\\n\t$(ESMF_MV) $(EXAMPLES_CONFIG).temp $(EXAMPLES_CONFIG); \\\n        fi\n\t-$(MAKE) ACTION=tree_run_examples_uni tree \n\t$(MAKE) check_examples\n\ntree_run_examples_uni: $(EXAMPLES_RUN_UNI)\n\n\n#\n# echo into a file how the examples were run, so when the perl scripts run \n# it needs to know multi vs uni so it knows what examples were run.\n#\nconfig_examples:\n\t@echo \"# This file used by test scripts, please do not delete.\" > $(EXAMPLES_CONFIG)\nifeq ($(MULTI),)\n\t@echo \" Last run Noprocessor\" >> $(EXAMPLES_CONFIG)\nelse\n\t@echo \" Last run\" $(MULTI) >> $(EXAMPLES_CONFIG)\nendif\n\n\n#\n# run the examples, either redirecting the stdout from the command line, or\n# relying on the mpirun script to redirect stdout from inside the batch script.\n#\nexfrun:\n\t-@cd $(ESMF_EXDIR) ; \\\n\t$(ESMF_RM) ./PET*$(EXNAME)Ex.Log ; \\\n\tif [ $(ESMF_BATCHDEPRECATED) = \"true\" ] ; then \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(EXNAME)Ex ; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(EXNAME)Ex ; \\\n\telse \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(EXNAME)Ex \\> ./ESMF_$(EXNAME)Ex.stdout 2\\>\\&1 ; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMF_$(EXNAME)Ex > ./ESMF_$(EXNAME)Ex.stdout 2>&1 ; \\\n\tfi ; \\\n\tcat ./PET*$(EXNAME)Ex*.Log> ./ESMF_$(EXNAME)Ex.Log ; \\\n\t$(ESMF_RM) ./PET*$(EXNAME)Ex*.Log\n\n\nexcrun:\n\t-@cd $(ESMF_EXDIR) ; \\\n\t$(ESMF_RM) ./PET*$(EXNAME)Ex.Log ; \\\n\tif [ $(ESMF_BATCHDEPRECATED) = \"true\" ] ; then \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMC_$(EXNAME)Ex ; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMC_$(EXNAME)Ex ; \\\n\telse \\\n\t  echo $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMC_$(EXNAME)Ex \\> ./ESMC_$(EXNAME)Ex.stdout 2\\>\\&1 ; \\\n\t  $(ESMF_MPIRUN) -np $(NP) $(ESMF_TOOLRUN) ./ESMC_$(EXNAME)Ex > ./ESMC_$(EXNAME)Ex.stdout 2>&1 ; \\\n\tfi ; \\\n\tcat ./PET*$(EXNAME)Ex*.Log> ./ESMC_$(EXNAME)Ex.Log ; \\\n\t$(ESMF_RM) ./PET*$(EXNAME)Ex*.Log\n\n\n#\n# this target deletes only the example related files from the example subdir\n#\nclean_examples:\n\t$(ESMF_RM) $(ESMF_EXDIR)/*\n\t$(MAKE) ACTION=tree_cleanfiles tree\n\n#\n# report statistics on examples\n#\ncheck_examples:\n\t@$(DO_EX_RESULTS)\n\n\n#\n# report memory leak statistics on examples\n#\ncheck_examples_ml:\n\t@$(DO_EX_ML_RESULTS)\n\n\n#-------------------------------------------------------------------------------\n# Targets for MAPL\n#-------------------------------------------------------------------------------\n\n#\n# install_mapl\n#\ninstall_mapl:\n\t-@echo \" \"\n\t-@echo \"Installing MAPL\"\n\t-@echo \" \"\n\tcd $(ESMF_DIR)/src/addon/MAPL5_1/src ;\\\n        $(MAKE) clean\n\tcd $(ESMF_DIR)/src/addon/MAPL5_1/src ;\\\n        $(MAKE) install\n\t-@echo \" \"\n\t-@echo \"MAPL installation complete.\"\n\t-@echo \" \"\n\n#\n# build_mapl_tests\n#\nbuild_mapl_tests: reqfile_libesmf reqdir_lib chkdir_tests verify_mapl_exhaustive_flag\n\t@echo \" \"\n\t@echo \"Building MAPL tests\"\n\t@echo \" \"\n\tcd $(ESMF_DIR)/src/addon/MAPL5_1/tests ;\\\n        $(MAKE) clean\n\t$(MAKE) config_mapl_tests \n\tcd $(ESMF_DIR)/src/addon/MAPL5_1/tests ;\\\n\t$(MAKE) ACTION=tree_build_unit_tests tree\n\t@echo \"MAPL tests built successfully.\"\n\t@echo \" \"\n\n\n#\n# run_mapl_tests\n#\nrun_mapl_tests:  reqdir_tests verify_mapl_exhaustive_flag\n\t@if [ $(ESMF_COMM) = \"mpiuni\" ] ; then \\\n\t  echo \"Cannot run multiprocessor mapl tests when ESMF_COMM is mpiuni;\" ; \\\n\t  echo \"run run_unit_tests_uni instead.\" ; \\\n\t  echo \"\" ; \\\n\t  $(MAKE) err ; \\\n        fi\n\t@if [ $(ESMF_DIR) = `pwd` ] ; then \\\n          $(MAKE) dust_unit_tests ; \\\n        fi\n\t@if [ -f $(MAPL_TESTS_CONFIG) ] ; then \\\n           $(ESMF_SED) -e 's/ [A-Za-z][A-Za-z]*processor/ Multiprocessor/' $(MAPL_TESTS_CONFIG) > $(MAPL_TESTS_CONFIG).temp; \\\n           $(ESMF_MV) $(MAPL_TESTS_CONFIG).temp $(MAPL_TESTS_CONFIG); \\\n        fi\n\tcd $(ESMF_DIR)/src/addon/MAPL5_1/tests ;\\\n\t$(MAKE) ACTION=tree_run_unit_tests tree\n\t$(MAKE) check_mapl_tests\n\n\n\n#\n# run_mapl_tests_uni\n#\nrun_mapl_tests_uni:  reqdir_tests verify_mapl_exhaustive_flag\n\t@if [ $(ESMF_DIR) = `pwd` ] ; then \\\n          $(MAKE) dust_unit_tests ; \\\n        fi\n\t@if [ -f $(MAPL_TESTS_CONFIG) ] ; then \\\n           $(ESMF_SED) -e 's/ [A-Za-z][A-Za-z]*processor/ Uniprocessor/' $(MAPL_TESTS_CONFIG) > $(MAPL_TESTS_CONFIG).temp; \\\n           $(ESMF_MV) $(MAPL_TESTS_CONFIG).temp $(MAPL_TESTS_CONFIG); \\\n        fi\n\tcd $(ESMF_DIR)/src/addon/MAPL5_1/tests ;\\\n\t$(MAKE) ACTION=tree_run_unit_tests_uni tree \n\t$(MAKE) check_mapl_tests\n\ntree_run_unit_tests_uni: $(TESTS_RUN_UNI)\n\n\n\n#\n# config_mapl_tests\n#\nconfig_mapl_tests:\n\t@echo \"# This file used by test scripts, please do not delete.\" > $(MAPL_TESTS_CONFIG)\nifeq ($(ESMF_TESTEXHAUSTIVE),ON)\nifeq ($(MULTI),)\n\t@echo \"Last built Exhaustive ;  Last run Noprocessor\" >> $(MAPL_TESTS_CONFIG)\nelse\n\t@echo \"Last built Exhaustive ;  Last run\" $(MULTI) >> $(MAPL_TESTS_CONFIG)\nendif\nelse\nifeq ($(MULTI),)\n\t@echo \"Last built Non-exhaustive ;  Last run Noprocessor\" >> $(MAPL_TESTS_CONFIG)\nelse\n\t@echo \"Last built Non-exhaustive ;  Last run\" $(MULTI) >> $(MAPL_TESTS_CONFIG)\nendif\nendif\n\n\n#\n# verify_mapl_exhausive_flag\n#\nverify_mapl_exhaustive_flag:\nifeq ($(ESMF_TESTEXHAUSTIVE),ON)\n\t@$(MAKE) MAPL_TEST_STRING=\"Exhaustive\" mapl_exhaustive_flag_check\nelse\n\t@$(MAKE) MAPL_TEST_STRING=\"Non-exhaustive\" mapl_exhaustive_flag_check\nendif\n\n#\n# mapl_exhaustive_flag_check\n#\nmapl_exhaustive_flag_check:\n\t@if [ -s $(MAPL_TESTS_CONFIG) -a \\\n             `$(ESMF_SED) -ne '/$(MAPL_TEST_STRING)/p' $(MAPL_TESTS_CONFIG) | $(ESMF_WC) -l` -ne 1 ] ; then \\\n          echo \"The ESMF_TESTEXHAUSTIVE environment variable is a compile-time control for\" ;\\\n          echo \"whether a basic set or an exhaustive set of tests are built.\" ;\\\n          echo \"\" ;\\\n          echo \"The current setting of ESMF_TESTEXHAUSTIVE is \\\"$(ESMF_TESTEXHAUSTIVE)\\\", which\" ;\\\n          echo \"is not the same as when the mapl tests were last built.\" ;\\\n          echo \"(This is based on the contents of the file:\" ;\\\n          echo \"$(MAPL_TESTS_CONFIG) \";\\\n          echo \"which contains: `$(ESMF_SED) -e '1d' $(MAPL_TESTS_CONFIG)` ).\" ;\\\n          echo \"\" ;\\\n          echo \"To rebuild and run the mapl tests with the current ESMF_TESTEXHAUSTIVE value, run:\" ;\\\n          echo \"   $(MAKE) clean_unit_tests unit_tests\"  ;\\\n          echo \"or change ESMF_TESTEXHAUSTIVE to ON or OFF to match the build-time value.\" ;\\\n          echo \"\" ;\\\n          $(MAKE) err ;\\\n        fi\n\n#\n# call clean only if flags do not match\n# clean_if_mapl_exhaustive_flag_mismatch\n#\n\nclean_if_mapl_exhaustive_flag_mismatch:\nifeq ($(ESMF_TESTEXHAUSTIVE),ON)\n\t@$(MAKE) MAPL_TEST_STRING=\"Exhaustive\" mapl_exhaustive_flag_clobber\nelse\n\t@$(MAKE) MAPL_TEST_STRING=\"Non-exhaustive\" mapl_exhaustive_flag_clobber\nendif\n\n#\n# mapl_exhaustive_flag_clobber\n#\nmapl_exhaustive_flag_clobber:\n\t@if [ -s $(MAPL_TESTS_CONFIG) -a \\\n             `$(ESMF_SED) -ne '/$(MAPL_TEST_STRING)/p' $(MAPL_TESTS_CONFIG) | $(ESMF_WC) -l` -ne 1 ] ; then \\\n          $(MAKE) clean_unit_tests ;\\\n        fi\n\n#\n# check_mapl_tests\n#\ncheck_mapl_tests:\n\t@$(DO_MT_RESULTS)\n\n#-------------------------------------------------------------------------------\n# Targets for checking the builds\n#-------------------------------------------------------------------------------\n\ncheck_results: check_unit_tests check_examples check_system_tests\n\nresults_summary:\n\t@$(DO_SUM_RESULTS)\n\nresults_ck_summary:\n\t@$(DO_CK_SUM_RESULTS)\n\n#-------------------------------------------------------------------------------\n# Quickstart targets\n#-------------------------------------------------------------------------------\n\nbuild_quick_start:\n\t$(MAKE) ACTION=tree_build_quick_start tree\n\ntree_build_quick_start:\n\t@if [ \"$(QUICKSTARTDIR)\" = \"YES\" ] ; then \\\n\t\t$(MAKE); fi\n\n#-------------------------------------------------------------------------------\n#  Doc targets\n#-------------------------------------------------------------------------------\n\ndoc:  chkdir_doc\n\t@echo \"=========================================\"\n\t@echo \"doc rule from common.mk\"\n\t@echo \"=========================================\" \n\t@if [ ! -d $(ESMF_DIR)/src/doc ] ; then \\\n          echo \"*** This version of the ESMF source tree does not contain documentation files. Please see http://www.earthsystemmodeling.org/ for ESMF documentation.\" ; \\\n          $(ESMF_RM) $(ESMF_DOCDIR) ; \\\n          $(MAKE) err; \\\n        fi;\n\tcd $(ESMF_DIR)/src/doc ;\\\n\t$(MAKE) dvi html pdf\n\t@echo \"Build doc completed.\"\n\n# 'doc' and 'alldoc' do identical things now.\nalldoc: doc\n\n# this new target should be called from an individual\n# subsystem doc directory and will build only that doc.\n# this is also the default if you call make from a doc subdir.\n\nlocaldoc:\n\t@if [ \"$(GRAPHFILES)\"foo != foo ] ; then \\\n          cp $(addprefix $(ESMF_BUILD)/src/doc/,$(GRAPHFILES)) .;\\\n\tfi;\n\t$(MAKE) $(TEXFILES_TO_MAKE)\n\t@if [ \"$(DVIFILES)\"foo != foo ] ; then \\\n          $(MAKE) $(DVIFILES);\\\n\tfi;\n\t@if [ \"$(PDFFILES)\"foo != foo ] ; then \\\n          $(MAKE) $(PDFFILES);\\\n\tfi;         \n\t@if [ \"$(HTMLFILES)\"foo != foo ] ; then \\\n          $(MAKE) $(HTMLFILES);\\\n\tfi;         \n        \nonedoc: chkdir_doc include tex\n\t@echo \"=========================================\"\n\t@echo \"Building Single Document\"\n\t@echo \"=========================================\"\n\t@$(MAKE) dvi pdf html\n\t@echo \"Build onedoc completed.\"\n\ntex: chkdir_doc include\n\tcd $(ESMF_DIR) ;\\\n\t$(MAKE) ACTION=tree_tex tree\n\ntree_tex: $(TEXFILES_TO_MAKE)\n\ndvi: chkdir_doc include tex\n\t@echo \"=========================================\"\n\t@echo \"dvi rule from common.mk, Building .dvi files\"\n\t@echo \"dvi files are:\" $(DVIFILES)\n\t@echo \"=========================================\"\n\t$(MAKE) $(DVIFILES)\n\ntree_dvi: chkdir_doc $(DVIFILES)\n\n\npdf: chkdir_doc\n\t@echo \"=========================================\"\n\t@echo \"pdf rule from common.mk, Building .pdf files\"\n\t@echo \"pdf files are:\" $(PDFFILES)\n\t@echo \"=========================================\"\n\t$(MAKE) $(PDFFILES)\n\ntree_pdf: chkdir_doc $(PDFFILES)\n\n\nhtml: chkdir_doc include tex\n\t@echo \"=========================================\"\n\t@echo \"html rule from common.mk, Building .html files\"\n\t@echo \"html files are:\" $(HTMLFILES)\n\t@echo \"=========================================\"\n\t$(MAKE) $(HTMLFILES)\n\ntree_html:chkdir_doc $(HTMLFILES)\n\nclean_doc:\n\t@cd $(ESMF_BUILD)/src/doc ;\\\n\t$(MAKE) tree_clean ; \\\n        $(ESMF_RM) $(ESMF_BUILD)/doc\n\n#-------------------------------------------------------------------------------\n# Recursive calls\n#-------------------------------------------------------------------------------\n\n# TODO: old tree target explicitly exited if the return code was not 0 but\n# this defeats the -k makeflag which ignores errors and continues as far\n# as possible.\n#tree: $(ACTION)\n#\t@if [ \"$(DIRS)\" != \"\" ]; then \\\n#\t  for dir in $(DIRS) foo ; do \\\n#            if [ -d $$dir ]; then \\\n#              (cd $$dir ; \\\n#              echo $(ACTION) in: `pwd`; \\\n#              $(MAKE) -f makefile tree ACTION=$(ACTION));\\\n#              if [ \"$$?\" != 0 ]; then \\\n#                exit 1; \\\n#              fi; \\\n#            fi; \\\n#\t  done; \\\n#        fi\n\n# TODO: maybe this can be simpler somehow - but it seems to work this way.\n# the findstring looks for the -k flag, which says to ignore errors.\n# if present, then do not test for the return of make, and let it \n# continue as far as it can.  without -k, if there is an error in the\n# call to make, exit from the tree command with a non-zero exit code\n# so the calling make rule will exit.\ntree: $(ACTION)\nifeq (,$(findstring k,$(MAKEFLAGS)))\n\t@if [ \"$(DIRS)\" != \"\" ]; then \\\n\t  for dir in $(DIRS) foo ; do \\\n            if [ -d $$dir ]; then \\\n              (cd $$dir ; \\\n              echo \"$(ACTION)\" in: `pwd`; \\\n              $(MAKE) -f makefile tree ACTION=\"$(ACTION)\");\\\n              if [ \"$$?\" != 0 ]; then \\\n                exit 1; \\\n              fi; \\\n            fi; \\\n\t  done; \\\n        fi\nelse\n\t@if [ \"$(DIRS)\" != \"\" ]; then \\\n\t  for dir in $(DIRS) foo ; do \\\n            if [ -d $$dir ]; then \\\n              (cd $$dir ; \\\n              echo \"$(ACTION)\" in: `pwd`; \\\n              $(MAKE) -f makefile tree ACTION=\"$(ACTION)\");\\\n            fi; \\\n\t  done; \\\n        fi\nendif\n\n\n#-------------------------------------------------------------------------------\n# Suffixes (TODO: seems that the last three have become obsolete *gjt*)\n#-------------------------------------------------------------------------------\n.SUFFIXES: .f .f90 .F .F90 .cppF90 .C .$(ESMF_SL_SUFFIX) .$(ESMF_LIB_SUFFIX) .cpp .cc .r .rm\n\n#-------------------------------------------------------------------------------\n#  Compile rules for F90, C++, and c files for both to .o and .a files\n#-------------------------------------------------------------------------------\n\n# TODO:  why were we not passing the mod dirpath to the .f and .f90 files?\n# they are fixed format, but that does not mean they cannot use mods.\n# i went ahead and added the mod dir to the rules but if this causes problems\n# it should be removed.  it was not here originally and had been this way\n# a long time.\n# TODO more: add CXXFLAGS\nESMF_F90COMPILEFREECPP_CMD = $(ESMF_F90COMPILER) -c $(ESMF_F90COMPILEOPTS) \\\n\t\t\t     $(ESMF_F90COMPILEPATHSLOCAL) $(ESMF_F90COMPILEPATHS) \\\n\t\t\t     $(ESMF_F90COMPILEFREECPP) $(ESMF_F90COMPILECPPFLAGS)\nESMF_F90COMPILEFREENOCPP_CMD = $(ESMF_F90COMPILER) -c $(ESMF_F90COMPILEOPTS) \\\n\t\t\t       $(ESMF_F90COMPILEPATHSLOCAL) $(ESMF_F90COMPILEPATHS) \\\n\t\t\t       $(ESMF_F90COMPILEFREENOCPP)\nESMF_F90COMPILEFIXCPP_CMD = $(ESMF_F90COMPILER) -c $(ESMF_F90COMPILEOPTS) \\\n\t\t\t    $(ESMF_F90COMPILEPATHSLOCAL) $(ESMF_F90COMPILEPATHS) \\\n\t\t\t    $(ESMF_F90COMPILEFIXCPP) $(ESMF_F90COMPILECPPFLAGS)\nESMF_F90COMPILEFIXNOCPP_CMD = $(ESMF_F90COMPILER) -c $(ESMF_F90COMPILEOPTS) \\\n\t\t\t      $(ESMF_F90COMPILEPATHSLOCAL) $(ESMF_F90COMPILEPATHS) \\\n\t\t\t      $(ESMF_F90COMPILEFIXNOCPP)\nESMF_CXXCOMPILE_CMD = $(ESMF_CXXCOMPILER) -c $(ESMF_CXXCOMPILEOPTS) \\\n\t\t      $(ESMF_CXXCOMPILEPATHSLOCAL) $(ESMF_CXXCOMPILEPATHS) \\\n\t\t      $(ESMF_CXXCOMPILECPPFLAGS)\n\n$(ESMF_OBJDIR)/%.o : %.F90\n\t$(ESMF_F90COMPILEFREECPP_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n$(ESMF_OBJDIR)/%.o : %.f90\n\t$(ESMF_F90COMPILEFREENOCPP_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n$(ESMF_OBJDIR)/%.o : %.F\n\t$(ESMF_F90COMPILEFIXCPP_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n$(ESMF_OBJDIR)/%.o : %.f\n\t$(ESMF_F90COMPILEFIXNOCPP_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n$(ESMF_OBJDIR)/%.o : %.c\n\t$(ESMF_CXXCOMPILE_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n$(ESMF_OBJDIR)/%.o : %.C\n\t$(ESMF_CXXCOMPILE_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n$(ESMF_OBJDIR)/%.o : %.cpp\n\t$(ESMF_CXXCOMPILE_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n$(ESMF_LOCOBJDIR)/%.o : %.F90\n\t$(MAKE) chkdir_locobj \n\t$(ESMF_F90COMPILEFREECPP_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n$(ESMF_LOCOBJDIR)/%.o : %.f90\n\t$(MAKE) chkdir_locobj \n\t$(ESMF_F90COMPILEFREENOCPP_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n$(ESMF_LOCOBJDIR)/%.o : %.F\n\t$(MAKE) chkdir_locobj \n\t$(ESMF_F90COMPILEFIXCPP_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n$(ESMF_LOCOBJDIR)/%.o : %.f\n\t$(MAKE) chkdir_locobj \n\t$(ESMF_F90COMPILEFIXNOCPP_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n$(ESMF_LOCOBJDIR)/%.o : %.c\n\t$(MAKE) chkdir_locobj \n\t$(ESMF_CXXCOMPILE_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n$(ESMF_LOCOBJDIR)/%.o : %.C\n\t$(MAKE) chkdir_locobj \n\t$(ESMF_CXXCOMPILE_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n$(ESMF_LOCOBJDIR)/%.o : %.cpp\n\t$(MAKE) chkdir_locobj \n\t$(ESMF_CXXCOMPILE_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n.F90.o:\n\t$(ESMF_F90COMPILEFREECPP_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n.f90.o:\n\t$(ESMF_F90COMPILEFREENOCPP_CMD) $<\n\n.F.o:\n\t$(ESMF_F90COMPILEFIXCPP_CMD) $<\n\n.f.o:\n\t$(ESMF_F90COMPILEFIXNOCPP_CMD) $<\n\n.c.o:\n\t$(ESMF_CXXCOMPILE_CMD) $<\n\n.C.o:\n\t$(ESMF_CXXCOMPILE_CMD) $< $(ESMF_OBJOUT_OPTION)\n\n.cpp.o:\n\t$(ESMF_CXXCOMPILE_CMD) $< $(ESMF_OBJOUT_OPTION)\n        \n.F90.$(ESMF_SL_SUFFIX):\n\t$(ESMF_F90COMPILEFREECPP_CMD) $(ESMF_SO_F90COMPILEOPTS) $<\n\t$(ESMF_F90LINKER) $(ESMF_SO_F90LINKOPTS) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) -o $@ $*.o $(ESMF_F90ESMFLINKLIBS)\n\n.F90.$(ESMF_LIB_SUFFIX):\n\t$(ESMF_F90COMPILEFREECPP_CMD) $<\n\t$(ESMF_AR) $(ESMF_ARCREATEFLAGS) $(ESMF_ARCREATEPREFIX)$(LIBNAME) $*.o\n\t$(ESMF_RM) $*.o\n\n.f90.$(ESMF_LIB_SUFFIX):\n\t$(ESMF_F90COMPILEFREENOCPP_CMD) $<\n\t$(ESMF_AR) $(ESMF_ARCREATEFLAGS) $(ESMF_ARCREATEPREFIX)$(LIBNAME) $*.o\n\t$(ESMF_RM) $*.o\n\n.F.$(ESMF_LIB_SUFFIX):\n\t$(ESMF_F90COMPILEFIXCPP_CMD) $<\n\t$(ESMF_AR) $(ESMF_ARCREATEFLAGS) $(ESMF_ARCREATEPREFIX)$(LIBNAME) $*.o\n\t$(ESMF_RM) $*.o\n\n.f.$(ESMF_LIB_SUFFIX):\n\t$(ESMF_F90COMPILEFIXNOCPP_CMD) $<\n\t$(ESMF_AR) $(ESMF_ARCREATEFLAGS) $(ESMF_ARCREATEPREFIX)$(LIBNAME) $*.o\n\t$(ESMF_RM) $*.o\n\n.c.$(ESMF_LIB_SUFFIX):\n\t$(ESMF_CXXCOMPILE_CMD) $<\n\t$(ESMF_AR) $(ESMF_ARCREATEFLAGS) $(ESMF_ARCREATEPREFIX)$(LIBNAME) $*.o\n\t$(ESMF_RM) $*.o\n\n.C.$(ESMF_LIB_SUFFIX):\n\t$(ESMF_CXXCOMPILE_CMD) $<\n\t$(ESMF_AR) $(ESMF_ARCREATEFLAGS) $(ESMF_ARCREATEPREFIX)$(LIBNAME) $*.o\n\t$(ESMF_RM) $*.o\n\n# The rules below generate a valid Fortran file using gcc for the first stage\n# of preprocessing.  The 'tr' command substitutes one-for-one, translating:\n#   @ into newline to separate lines in multiline macros (the output\n#     of the preprocessor is a single line which must be separated again)\n#   ^ into # so that other preprocessor commands are ready to be processed by\n#     the second runthrough of the preprocessor during the actual compile\n#     (These lines are: ^include \"fred.h\" in the original source to shield \n#     them from the first preprocess pass.)\n#   | into ' to be able to use single apostrophes in comments.\n# The 'sed' command removes any lines which start #pragma GCC . These are\n# generated by a couple versions of gcc and confuse the fortran compiler when\n# trying to compile the newly generated file.\n# The dir, notdir macros below are to be sure to create the .F90 file in the\n# original source directory, since the makefile has already changed dirs into\n# the mod dir to build.\n\nifeq ($(origin ESMF_CPPRULES),undefined)\n.cppF90.F90:\n\t$(ESMF_CPP) -I$(ESMF_INCDIR) $< | tr \"@^|\" \"\\n#'\" | $(ESMF_SED) -e '/^#pragma GCC/d' > $(dir $<)$(notdir $@)\nendif\n\n\n#-------------------------------------------------------------------------------\n#  Build shared library from regular archive\n#\n#     On systems where we know how to build shared libraries we go and do it. On\n#     those systems where we do not know how to build shared libraries the\n#     ESMF_SL_LIBS_TO_MAKE must be blanked out in the platform specific \n#     build_rules.mk file, which will essentially turn the \"shared\" target below\n#     into a noop.\n#\n#     We are building two shared ESMF libraries: \n#       - libesmf.so\n#       - libesmf_fullylinked.so\n#\n#     The \"libesmf.so\" only links in the bare minimum. Its purpose is to be\n#     linked into an executable, i.e. there is one more linking step that will\n#     ensure that all symbols are satisfied in the final executable. Prelinking\n#     libesmf.so with only the minimum of libraries has these advantages:\n#       1) It does NOT require that all of the dependency libraries are\n#          available in position-independent-code (PIC) format.\n#       2) It allows maximum flexibility in the final linking step, e.g. \n#          a backward compatible version of a library may be chosen by the\n#          executable.\n#       3) It leads to greater symmetry between linking an executable against\n#          the static library (or archive) version, libesmf.a, and libesmf.so.\n#\n#     The \"libesmf_fullylinked.so\" version links in everything that would be\n#     specified in the final link step when building an executable. This\n#     produces a fully self-contained shared library, which has the advantage\n#     of being suitable to be loaded e.g. by the Python layer on top of ESMF.\n#     However, it does require that ALL dependencies, including all of the \n#     3rd party libraries that are specified, MUST be available as \n#     position-independent-code (PIC). This can be difficult to ensure.\n#\n#-------------------------------------------------------------------------------\nshared:\n\t@if [ \"$(ESMF_SL_LIBS_TO_MAKE)\" != \"\" ] ; then \\\n\t\techo making shared libraries in $(ESMF_LDIR); \\\n\t\tcd $(ESMF_LDIR) ; \\\n\t\t$(ESMF_RM) -r tmp_* ; \\\n\t\tfor NEXTLIB in $(ESMF_SL_LIBS_TO_MAKE) foo ;\\\n\t\tdo \\\n\t\tif [ -f $$NEXTLIB.$(ESMF_LIB_SUFFIX) ] ; then \\\n\t\t    $(ESMF_RM) $$NEXTLIB.$(ESMF_SL_SUFFIX) ; \\\n\t\t    echo Converting $$NEXTLIB.a to $$NEXTLIB.$(ESMF_SL_SUFFIX) ;\\\n\t\t    mkdir tmp_$$NEXTLIB ;\\\n\t\t    cd tmp_$$NEXTLIB  ;\\\n\t                $(ESMF_AREXTRACT) ../$$NEXTLIB.$(ESMF_LIB_SUFFIX) ;\\\n                    echo $(ESMF_SL_LIBLINKER) $(ESMF_SL_LIBOPTS) -o $(ESMF_LDIR)/$$NEXTLIB.$(ESMF_SL_SUFFIX) *.o $(ESMF_SL_LIBLIBS) ;\\\n\t\t    $(ESMF_SL_LIBLINKER) $(ESMF_SL_LIBOPTS) -o $(ESMF_LDIR)/$$NEXTLIB.$(ESMF_SL_SUFFIX) *.o $(ESMF_SL_LIBLIBS) ;\\\n\t\t    echo Converting $$NEXTLIB.$$ESMF_LIB_SUFFIX to $$NEXTLIB\\_fullylinked.$(ESMF_SL_SUFFIX) ;\\\n                    echo $(ESMF_SL_LIBLINKER) $(ESMF_SL_LIBOPTS) -o $(ESMF_LDIR)/$$NEXTLIB\\_fullylinked.$(ESMF_SL_SUFFIX) *.o $(ESMF_CXXLINKOPTS) $(ESMF_CXXLINKPATHS) $(ESMF_CXXLINKRPATHS) $(ESMF_CXXLINKLIBS) ;\\\n\t\t    $(ESMF_SL_LIBLINKER) $(ESMF_SL_LIBOPTS) -o $(ESMF_LDIR)/$$NEXTLIB\\_fullylinked.$(ESMF_SL_SUFFIX) *.o $(ESMF_CXXLINKOPTS) $(ESMF_CXXLINKPATHS) $(ESMF_CXXLINKRPATHS) $(ESMF_CXXLINKLIBS) ;\\\n\t\t    cd .. ;\\\n\t\t    $(ESMF_RM) -r tmp_$$NEXTLIB ;\\\n\t\tfi ;\\\n\t\tdone ; \\\n\tfi\n\n\n#-------------------------------------------------------------------------------\n#  Build (deferred) static library from all objects\n#-------------------------------------------------------------------------------\ndefer:\nifeq ($(ESMF_OS),MinGW)\n\tcd $(ESMF_OBJDIR) ; \\\n\t$(ESMF_AR) $(ESMF_ARCREATEFLAGS) $(ESMF_ARCREATEPREFIX)`$(ESMF_DIR)/scripts/path_mingw2win $(ESMFLIB)` \\\n\t\t$(notdir $(wildcard $(ESMF_OBJDIR)/*.o))\nelse\n\tcd $(ESMF_OBJDIR) ; \\\n\t$(ESMF_AR) $(ESMF_ARCREATEFLAGS) $(ESMFLIB) \\\n\t\t$(notdir $(wildcard $(ESMF_OBJDIR)/*.o))\nendif\n\n\n#-------------------------------------------------------------------------------\n# Pattern rules for making Tex files using protex script.  Input to \n# protex script is Fortran, C or .h source code.\n#-------------------------------------------------------------------------------\n\n%_fapi.tex : $(TEXFILES_TO_MAKE_XDIR)/interface/%.F90\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : ../src/%.F \n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : ../src/%.F90\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : ../src/%.f\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : ../src/%.f90\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : ../interface/%.F \n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : ../interface/%.F90\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : ../interface/%.f\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : ../interface/%.f90\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_chapi.tex : ../include/%.h\n\texport PROTEX=$(PROTEX) ;\\\n\t$(CH_PROTEX) $* $<\n\n%_chapi.tex : ../include/%.inc\n\texport PROTEX=$(PROTEX) ;\\\n\t$(CH_PROTEX) $* $<\n\n%_ccapi.tex : ../src/%.C\n\texport PROTEX=$(PROTEX) ;\\\n\t$(CC_PROTEX) $* $<\n\n%_ccapi.tex : ../interface/%.C\n\texport PROTEX=$(PROTEX) ;\\\n\t$(CC_PROTEX) $* $<\n\n%_fapi.tex : ../examples/%.F \n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : ../examples/%.F90\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : ../examples/%.f\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : ../examples/%.f90\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_ccapi.tex : ../examples/%.C\n\texport PROTEX=$(PROTEX) ;\\\n\t$(CC_PROTEX) $* $<\n\n%_fapi.tex : $(TEXFILES_TO_MAKE_XDIR)/src/%.F \n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : $(TEXFILES_TO_MAKE_XDIR)/src/%.F90\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : $(TEXFILES_TO_MAKE_XDIR)/src/%.f\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : $(TEXFILES_TO_MAKE_XDIR)/src/%.f90\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : $(TEXFILES_TO_MAKE_XDIR)/interface/%.F \n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : $(TEXFILES_TO_MAKE_XDIR)/interface/%.F90\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : $(TEXFILES_TO_MAKE_XDIR)/interface/%.f\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : $(TEXFILES_TO_MAKE_XDIR)/interface/%.f90\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_chapi.tex : $(TEXFILES_TO_MAKE_XDIR)/include/%.h\n\texport PROTEX=$(PROTEX) ;\\\n\t$(CH_PROTEX) $* $<\n\n%_chapi.tex : $(TEXFILES_TO_MAKE_XDIR)/include/%.inc\n\texport PROTEX=$(PROTEX) ;\\\n\t$(CH_PROTEX) $* $<\n\n%_ccapi.tex : $(TEXFILES_TO_MAKE_XDIR)/src/%.C\n\texport PROTEX=$(PROTEX) ;\\\n\t$(CC_PROTEX) $* $<\n\n%_ccapi.tex : $(TEXFILES_TO_MAKE_XDIR)/interface/%.C\n\texport PROTEX=$(PROTEX) ;\\\n\t$(CC_PROTEX) $* $<\n\n%_fapi.tex : $(TEXFILES_TO_MAKE_XDIR)/examples/%.F \n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : $(TEXFILES_TO_MAKE_XDIR)/examples/%.F90\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : $(TEXFILES_TO_MAKE_XDIR)/examples/%.f\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_fapi.tex : $(TEXFILES_TO_MAKE_XDIR)/examples/%.f90\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $<\n\n%_ccapi.tex : $(TEXFILES_TO_MAKE_XDIR)/examples/%.C\n\texport PROTEX=$(PROTEX) ;\\\n\t$(CC_PROTEX) $* $<\n\n# special for the AppDriver dir. \n%SeqPrF_fapi.tex : ../seq_pairwise_fdriver_spmd/%.F90\n\texport PROTEX=$(PROTEX) ;\\\n\t$(F_PROTEX) $* $< SeqPrF\n\n\n\n#-------------------------------------------------------------------------------\n# Pattern rules for making dvi, pdf and html files.\n#-------------------------------------------------------------------------------\n\n# The variable TEXINPUTS_VALUE can be set in the makefiles of the\n# source code tree to list the directory paths of the .tex and\n# graphics files included by .tex sources files.  The paths listed in\n# TEXINPUTS_VALUE should be colon separated.  If TEXINPUTS_VALUE is\n# set, then the first path should a period for the local directory.  A\n# colon should trail the last path listed. If TEXINPUTS_VALUE is not\n# set, then only files in the local directory will be found by the\n# \\input and \\includegraphics LaTeX commands.\n#\n\nTEXINPUTS_VALUE = \".:$(ESMF_DIR)/src/doc:$(ESMF_BUILD_DOCDIR):\"\nexport TEXINPUTS_VALUE\n\n\n#-------------------------------------------------------------------------------\n#  dvi rules\n#-------------------------------------------------------------------------------\n\n%_refdoc.dvi : %_refdoc.ctex $(REFDOC_DEP_FILES)\n\t@echo \"=========================================\"\n\t@echo \"_refdoc.dvi rule from common.mk\"\n\t@echo \"=========================================\"\n\texport TEXINPUTS=$(TEXINPUTS_VALUE) ;\\\n\t$(DO_LATEX) $* ref\n\n%_crefdoc.dvi : %_crefdoc.ctex $(REFDOC_DEP_FILES)\n\t@echo \"=========================================\"\n\t@echo \"_crefdoc.dvi rule from common.mk\"\n\t@echo \"=========================================\"\n\texport TEXINPUTS=$(TEXINPUTS_VALUE) ;\\\n\t$(DO_LATEX) $* cref\n\n#-------------------------------------------------------------------------------\n#  pdf rules\n#-------------------------------------------------------------------------------\n\n$(ESMF_DOCDIR)/%.pdf: %.dvi\n\t@echo \"=========================================\"\n\t@echo \"ESMF_DOCDIR %pdf from %.dvi rule from common.mk\"\n\t@echo \"=========================================\"\n\texport TEXINPUTS=$(TEXINPUTS_VALUE) ;\\\n\tdvipdf $< $@\n\n%.pdf: %.dvi\n\t@echo \"=========================================\"\n\t@echo \"%pdf from %.dvi rule from common.mk\"\n\t@echo \"=========================================\"\n\texport TEXINPUTS=$(TEXINPUTS_VALUE) ;\\\n\tdvipdf $< $@\n\n#-------------------------------------------------------------------------------\n#  html rules\n#-------------------------------------------------------------------------------\n\n$(ESMF_DOCDIR)/%_refdoc: %_refdoc.ctex $(REFDOC_DEP_FILES)\n\t@echo \"=========================================\"\n\t@echo \"ESMF_DOCDIR _refdoc html rule from common.mk\"\n\t@echo \"=========================================\"\n\t@if [ $(TEXINPUTS_VALUE)foo != foo ] ; then \\\n\t  echo '$$TEXINPUTS = $(TEXINPUTS_VALUE)' > .latex2html-init ;\\\n\tfi;\n\t$(DO_L2H) $* ref\n\t$(ESMF_RM) .latex2html-init\n\t$(ESMF_MV) $(@F) $(ESMF_DOCDIR)\n\n$(ESMF_DOCDIR)/%_crefdoc: %_crefdoc.ctex $(REFDOC_DEP_FILES)\n\t@echo \"=========================================\"\n\t@echo \"ESMF_DOCDIR _crefdoc html rule from common.mk\"\n\t@echo \"=========================================\"\n\t@if [ $(TEXINPUTS_VALUE)foo != foo ] ; then \\\n\t  echo '$$TEXINPUTS = $(TEXINPUTS_VALUE)' > .latex2html-init ;\\\n\tfi;\n\t$(DO_L2H) $* cref\n\t$(ESMF_RM) .latex2html-init\n\t$(ESMF_MV) $(@F) $(ESMF_DOCDIR)\n\n%_refdoc: %_refdoc.ctex $(REFDOC_DEP_FILES)\n\t@echo \"=========================================\"\n\t@echo \"_refdoc html rule from common.mk\"\n\t@echo \"=========================================\"\n\t@if [ $(TEXINPUTS_VALUE)foo != foo ] ; then \\\n\t  echo '$$TEXINPUTS = $(TEXINPUTS_VALUE)' > .latex2html-init ;\\\n\tfi;\n\t$(DO_L2H) $* ref\n\t$(ESMF_RM) .latex2html-init\n\n%_crefdoc: %_crefdoc.ctex $(REFDOC_DEP_FILES)\n\t@echo \"=========================================\"\n\t@echo \"_crefdoc html rule from common.mk\"\n\t@echo \"=========================================\"\n\t@if [ $(TEXINPUTS_VALUE)foo != foo ] ; then \\\n\t  echo '$$TEXINPUTS = $(TEXINPUTS_VALUE)' > .latex2html-init ;\\\n\tfi;\n\t$(DO_L2H) $* cref\n\t$(ESMF_RM) .latex2html-init\n\n#-------------------------------------------------------------------------------\n#  These rules are for compiling the test examples.\n#-------------------------------------------------------------------------------\n.cc.rm .C.rm .F.rm .f.rm .c.rm:\n\t-@$(ESMF_RM) $* *.o *.$(ESMF_SL_SUFFIX) $*.mon.* gmon.out mon.out\n\n\n#-------------------------------------------------------------------------------\n# Keep .o and .$(ESMF_SL_SUFFIX) files\n#-------------------------------------------------------------------------------\n.PRECIOUS: %.o %.$(ESMF_SL_SUFFIX) $(addprefix $(ESMF_LOCOBJDIR)/,$(APPS_OBJ))\n\n\n#-------------------------------------------------------------------------------\n#-------------------------------------------------------------------------------\n# This section is for automatic generation of dependencies.\n#\n# During the tree_include phase the files defined by the SOURCE[CF] variables\n# in the class local makefile are parsed for module and include dependencies.\n# Only the include dependencies that are local (i.e., defined by SOURCEH or\n# located in ../include) are kept in the dependency list.  The dependencies\n# are written to a class local makefile fragment that is included (if it exists)\n# in the top-level makefile.\n#-------------------------------------------------------------------------------\n#-------------------------------------------------------------------------------\n# Class local dependency makefile fragment\nifeq ($(ESMF_DEFER_LIB_BUILD),ON)\n  # Uniquely named file generated in ESMF_OBJDIR directory\n  LOCAL_DEPEND_FILE = $(ESMF_OBJDIR)/$(subst /,_,$(LOCDIR))_depend.mk\nelse\n  # Commonly named file generated in LOCDIR directory\n  LOCAL_DEPEND_FILE = $(ESMF_DIR)/$(LOCDIR)/depend.mk\n  CLEAN_DEFAULTS += $(LOCAL_DEPEND_FILE)\nendif\n\n# Function for extracting an ESMF module dependency list from a Fortran source\n# file.  It is assumed that the module name occurs on the same line as the use\n# keyword.  Multiple use statements on the same line are not recognized.\ndefine MOD_FUNC\n$(filter-out $(addsuffix .o,$(basename $(1))), \\\n $(subst ESMF_.o,ESMF.o, \\\n  $(sort \\\n   $(addsuffix .o, \\\n      $(shell awk  '/^ *use  *ESMF_/' $(1) \\\n            | sed 's/^ *use  *ESMF_/ESMF_/' \\\n            | sed 's/Mod.*$$//' \\\n       ) \\\n      $(shell awk  '/^ *use  *NUOPC/' $(1) \\\n            | sed 's/^ *use  *NUOPC/NUOPC/' \\\n            | sed 's/,.*$$//' \\\n       ) \\\n      $(shell awk  '/^ *use  *pio/' $(1) \\\n            | sed 's/^ *use  *pio/pio/' \\\n            | sed 's/,.*$$//' \\\n       ) \\\n     ) \\\n   ) \\\n  ) \\\n )\nendef\n\n# Function for extracting an include dependency list.\n# - paths are stripped from include file names\ndefine INC_FUNC\n$(notdir $(sort \\\n  $(shell awk  '/^ *[#\\^] *include *[\"<]/' $(1) \\\n        | sed 's/^ *[#\\^] *include *[\"<]//' \\\n        | sed 's/[\">].*$$//' \\\n   ) \\\n ))\nendef\n\n# Function for generating the dependency list for a regular Fortran source file.\n# - filter include dependencies for local files\nifeq ($(ESMF_DEFER_LIB_BUILD),ON)\n  define SOURCEF_DEPEND_FUNC\n  $(addprefix $(ESMF_OBJDIR)/,$(addsuffix .o,$(basename $(1)))) : \\\n\t$(addprefix $(ESMF_OBJDIR)/,$(call MOD_FUNC,$(1))) \\\n\t$(filter $(LOCAL_INCLUDE_FILES),$(call INC_FUNC,$(1)))\n  endef\nelse\n  define SOURCEF_DEPEND_FUNC\n  $(addsuffix .o,$(basename $(1))) : \\\n\t$(call MOD_FUNC,$(1)) \\\n\t$(filter $(LOCAL_INCLUDE_FILES),$(call INC_FUNC,$(1)))\n  endef\nendif\n\n# Function for generating the dependency list for an autogen Fortran source file.\n# - the autogenerated file is included in the prerequisite list\n# - filter include dependencies for local files\nifeq ($(ESMF_DEFER_LIB_BUILD),ON)\n  define AUTOGEN_DEPEND_FUNC\n  $(addprefix $(ESMF_OBJDIR)/,$(addsuffix .o,$(basename $(1)))) : $(1) \\\n\t$(addprefix $(ESMF_OBJDIR)/,$(call MOD_FUNC,$(1))) \\\n\t$(filter $(LOCAL_INCLUDE_FILES),$(call INC_FUNC,$(1)))\n  endef\nelse\n  define AUTOGEN_DEPEND_FUNC\n  $(addsuffix .o,$(basename $(1))) : $(1) \\\n\t$(call MOD_FUNC,$(1)) \\\n\t$(filter $(LOCAL_INCLUDE_FILES),$(call INC_FUNC,$(1)))\n  endef\nendif\n\n# Function for generating the dependency list for a C/C++ source file.\n# - filter include dependencies for local files\nifeq ($(ESMF_DEFER_LIB_BUILD),ON)\n  define SOURCEC_DEPEND_FUNC\n  $(addprefix $(ESMF_OBJDIR)/,$(addsuffix .o,$(basename $(1)))) : \\\n\t$(filter $(LOCAL_INCLUDE_FILES),$(call INC_FUNC,$(1)))\n  endef\nelse\n  define SOURCEC_DEPEND_FUNC\n  $(addsuffix .o,$(basename $(1))) : \\\n\t$(filter $(LOCAL_INCLUDE_FILES),$(call INC_FUNC,$(1)))\n  endef\nendif\n\n# Generate local dependency file during tree_include action\n# - if SOURCEF or SOURCEC are non-empty\n# - define LOCAL_INCLUDE_FILES based on SOURCEH and ../include\n# - Fortran autogen source files are assumed to be named with the .cppF90 suffix\nifneq (,$(findstring tree_include,\"$(ACTION)\"))\n  ifneq (,$(strip $(SOURCEF) $(SOURCEC)))\n    LOCAL_INCLUDE_FILES = $(strip $(SOURCEH) $(notdir $(wildcard ../include/*)))\n    $(foreach f,$(filter-out $(AUTOGEN),$(SOURCEF)),\\\n      $(shell echo '$(call SOURCEF_DEPEND_FUNC,$(f))' >> $(LOCAL_DEPEND_FILE)))\n    $(foreach f,$(addsuffix .cppF90,$(basename $(AUTOGEN))),\\\n      $(shell echo '$(call AUTOGEN_DEPEND_FUNC,$(f))' >> $(LOCAL_DEPEND_FILE)))\n    $(foreach f,$(SOURCEC),\\\n      $(shell echo '$(call SOURCEC_DEPEND_FUNC,$(f))' >> $(LOCAL_DEPEND_FILE)))\n  endif\nendif\n#-------------------------------------------------------------------------------\n#-------------------------------------------------------------------------------\n",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Trace/preload/preload_io.C": "/**\n *\n * preload_io.c\n *\n * Functions that will be preloaded with LD_PRELOAD, thereby\n * overriding system library functions so we can call into our\n * wrapper function.\n *\n * Since we are using dynamic linking, the __real_<SYMBOL>\n * functions are looked up at runtime using dlsym().\n */\n\n#ifdef ESMF_PGIVERSION_MAJOR\n/* required for RTLD_NEXT */\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#endif\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#ifndef ESMF_OS_MinGW\n#include <sys/uio.h>\n#endif\n#include <unistd.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdarg.h>\n\n#include \"ESMCI_Macros.h\"\n#include \"ESMCI_Trace.h\"\n#include \"wrappers_io.h\"\n\nextern \"C\" {\n\n  /* write */\n  static ssize_t (*__real_ptr_write)(int fildes, const void *buf, size_t nbyte) = NULL;  \n  ssize_t __real_write(int fd, const void *buf, size_t nbytes) {   \n    if (__real_ptr_write == NULL) {\n      __real_ptr_write = (ssize_t (*)(int, const void *, size_t)) dlsym(RTLD_NEXT, \"write\");\n    }\n    return __real_ptr_write(fd, buf, nbytes);\n  }\n  \n  ssize_t write(int fd, const void *buf, size_t nbytes) {\n    return __wrap_write(fd, buf, nbytes);\n  }\n\n  /* writev */\n  static ssize_t (*__real_ptr_writev)(int fd, const struct iovec *iov, int iovcnt) = NULL;\n  ssize_t __real_writev(int fd, const struct iovec *iov, int iovcnt) {\n    if (__real_ptr_writev == NULL) {\n      __real_ptr_writev = (ssize_t (*)(int, const struct iovec *, int)) dlsym(RTLD_NEXT, \"writev\");\n    }\n    return __real_ptr_writev(fd, iov, iovcnt);\n  }\n\n  ssize_t writev(int fd, const struct iovec *iov, int iovcnt) {\n    return __wrap_writev(fd, iov, iovcnt);\n  }\n\n  /* pwrite */\n  static ssize_t (*__real_ptr_pwrite)(int fd, const void *buf, size_t nbytes, off_t offset) = NULL;\n  ssize_t __real_pwrite(int fd, const void *buf, size_t nbytes, off_t offset) {\n    if (__real_ptr_pwrite == NULL) {\n      __real_ptr_pwrite = (ssize_t (*)(int, const void *, size_t, off_t)) dlsym(RTLD_NEXT, \"pwrite\");\n    }\n    return __real_ptr_pwrite(fd, buf, nbytes, offset);\n  }\n\n  ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset) {\n    return __wrap_pwrite(fd, buf, nbytes, offset);\n  }\n  \n  /* read */\n  static ssize_t (*__real_ptr_read)(int fd, void *buf, size_t nbytes) = NULL;\n  ssize_t __real_read(int fd, void *buf, size_t nbytes) {\n    if (__real_ptr_read == NULL) {\n      __real_ptr_read = (ssize_t (*)(int, void *, size_t)) dlsym(RTLD_NEXT, \"read\");\n    }\n    return __real_ptr_read(fd, buf, nbytes);\n  }\n\n  ssize_t read(int fd, void *buf, size_t nbytes) {\n    return __wrap_read(fd, buf, nbytes);\n  }\n\n\n  /* open */\n  static int (*__real_ptr_open)(const char *path, int oflag, ...) = NULL;\n  int __real_open(const char *path, int oflag, ...) {\n    if (__real_ptr_open == NULL) {\n      __real_ptr_open = (int (*) (const char *, int, ...)) dlsym(RTLD_NEXT, \"open\");\n    }\n    \n    va_list args;\n    va_start(args, oflag);\n    mode_t mode = va_arg(args, int);\n    va_end(args);\n\n    return __real_ptr_open(path, oflag, mode);\n  }\n  \n  int open(const char *path, int oflag, ...) {\n    va_list args;\n    va_start(args, oflag);\n    mode_t mode = va_arg(args, int);\n    va_end(args);\n\n    return __wrap_open(path, oflag, mode);\n  }\n  \n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Trace/preload/preload_mpi.C": "\n/**\n *\n * preload_mpi.C\n *\n *  !! DO NOT EDIT !!\n *  This file was generated by gen_wrappers_mpi.py.\n *  !! DO NOT EDIT !!\n *\n * Functions that will be preloaded with LD_PRELOAD, thereby\n * overriding system library functions so we can call into our\n * wrapper function.\n *\n * Since we are using dynamic linking, the __real_<SYMBOL>\n * functions are looked up at runtime using dlsym().\n */\n\n#ifndef ESMF_MPIUNI\n\n#ifdef ESMF_PGIVERSION_MAJOR\n/* required for RTLD_NEXT */\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#endif\n\n#include <dlfcn.h>\n#include <mpi.h>\n\n#include \"ESMCI_Macros.h\"\n#include \"ESMCI_Trace.h\"\n#include \"wrappers_mpi.h\"\n\n#define xstr(s) str(s)\n#define str(s) #s\n\nextern \"C\" {\n\n  /*\n   * C MPI functions\n   */\n\n  \n    static int (*__real_ptr_MPI_Allgather)(ESMF_MPI_CONST void *sendbuf, int  sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, MPI_Comm comm) = NULL;\n\n    int __real_MPI_Allgather(ESMF_MPI_CONST void *sendbuf, int  sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, MPI_Comm comm) {\n      if (__real_ptr_MPI_Allgather == NULL) {\n        __real_ptr_MPI_Allgather = (int (*)(ESMF_MPI_CONST void *sendbuf, int  sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, MPI_Comm comm)) dlsym(RTLD_NEXT, \"MPI_Allgather\");\n      }\n      return __real_ptr_MPI_Allgather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, comm);\n    }\n\n    int MPI_Allgather(ESMF_MPI_CONST void *sendbuf, int  sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, MPI_Comm comm) {\n      return __wrap_MPI_Allgather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, comm);\n    }\n\n  \n    static int (*__real_ptr_MPI_Allgatherv)(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int displs[], MPI_Datatype recvtype, MPI_Comm comm) = NULL;\n\n    int __real_MPI_Allgatherv(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int displs[], MPI_Datatype recvtype, MPI_Comm comm) {\n      if (__real_ptr_MPI_Allgatherv == NULL) {\n        __real_ptr_MPI_Allgatherv = (int (*)(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int displs[], MPI_Datatype recvtype, MPI_Comm comm)) dlsym(RTLD_NEXT, \"MPI_Allgatherv\");\n      }\n      return __real_ptr_MPI_Allgatherv(sendbuf, sendcount, sendtype, recvbuf, recvcounts, displs, recvtype, comm);\n    }\n\n    int MPI_Allgatherv(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int displs[], MPI_Datatype recvtype, MPI_Comm comm) {\n      return __wrap_MPI_Allgatherv(sendbuf, sendcount, sendtype, recvbuf, recvcounts, displs, recvtype, comm);\n    }\n\n  \n    static int (*__real_ptr_MPI_Allreduce)(ESMF_MPI_CONST void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, MPI_Comm comm) = NULL;\n\n    int __real_MPI_Allreduce(ESMF_MPI_CONST void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, MPI_Comm comm) {\n      if (__real_ptr_MPI_Allreduce == NULL) {\n        __real_ptr_MPI_Allreduce = (int (*)(ESMF_MPI_CONST void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, MPI_Comm comm)) dlsym(RTLD_NEXT, \"MPI_Allreduce\");\n      }\n      return __real_ptr_MPI_Allreduce(sendbuf, recvbuf, count, datatype, op, comm);\n    }\n\n    int MPI_Allreduce(ESMF_MPI_CONST void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, MPI_Comm comm) {\n      return __wrap_MPI_Allreduce(sendbuf, recvbuf, count, datatype, op, comm);\n    }\n\n  \n    static int (*__real_ptr_MPI_Alltoall)(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, MPI_Comm comm) = NULL;\n\n    int __real_MPI_Alltoall(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, MPI_Comm comm) {\n      if (__real_ptr_MPI_Alltoall == NULL) {\n        __real_ptr_MPI_Alltoall = (int (*)(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, MPI_Comm comm)) dlsym(RTLD_NEXT, \"MPI_Alltoall\");\n      }\n      return __real_ptr_MPI_Alltoall(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, comm);\n    }\n\n    int MPI_Alltoall(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, MPI_Comm comm) {\n      return __wrap_MPI_Alltoall(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, comm);\n    }\n\n  \n    static int (*__real_ptr_MPI_Alltoallv)(ESMF_MPI_CONST void *sendbuf, ESMF_MPI_CONST int sendcounts[], ESMF_MPI_CONST int sdispls[], MPI_Datatype sendtype, void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int rdispls[], MPI_Datatype recvtype, MPI_Comm comm) = NULL;\n\n    int __real_MPI_Alltoallv(ESMF_MPI_CONST void *sendbuf, ESMF_MPI_CONST int sendcounts[], ESMF_MPI_CONST int sdispls[], MPI_Datatype sendtype, void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int rdispls[], MPI_Datatype recvtype, MPI_Comm comm) {\n      if (__real_ptr_MPI_Alltoallv == NULL) {\n        __real_ptr_MPI_Alltoallv = (int (*)(ESMF_MPI_CONST void *sendbuf, ESMF_MPI_CONST int sendcounts[], ESMF_MPI_CONST int sdispls[], MPI_Datatype sendtype, void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int rdispls[], MPI_Datatype recvtype, MPI_Comm comm)) dlsym(RTLD_NEXT, \"MPI_Alltoallv\");\n      }\n      return __real_ptr_MPI_Alltoallv(sendbuf, sendcounts, sdispls, sendtype, recvbuf, recvcounts, rdispls, recvtype, comm);\n    }\n\n    int MPI_Alltoallv(ESMF_MPI_CONST void *sendbuf, ESMF_MPI_CONST int sendcounts[], ESMF_MPI_CONST int sdispls[], MPI_Datatype sendtype, void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int rdispls[], MPI_Datatype recvtype, MPI_Comm comm) {\n      return __wrap_MPI_Alltoallv(sendbuf, sendcounts, sdispls, sendtype, recvbuf, recvcounts, rdispls, recvtype, comm);\n    }\n\n  \n    static int (*__real_ptr_MPI_Alltoallw)(ESMF_MPI_CONST void *sendbuf, ESMF_MPI_CONST int sendcounts[], ESMF_MPI_CONST int sdispls[], ESMF_MPI_CONST MPI_Datatype sendtypes[], void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int rdispls[], ESMF_MPI_CONST MPI_Datatype recvtypes[], MPI_Comm comm) = NULL;\n\n    int __real_MPI_Alltoallw(ESMF_MPI_CONST void *sendbuf, ESMF_MPI_CONST int sendcounts[], ESMF_MPI_CONST int sdispls[], ESMF_MPI_CONST MPI_Datatype sendtypes[], void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int rdispls[], ESMF_MPI_CONST MPI_Datatype recvtypes[], MPI_Comm comm) {\n      if (__real_ptr_MPI_Alltoallw == NULL) {\n        __real_ptr_MPI_Alltoallw = (int (*)(ESMF_MPI_CONST void *sendbuf, ESMF_MPI_CONST int sendcounts[], ESMF_MPI_CONST int sdispls[], ESMF_MPI_CONST MPI_Datatype sendtypes[], void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int rdispls[], ESMF_MPI_CONST MPI_Datatype recvtypes[], MPI_Comm comm)) dlsym(RTLD_NEXT, \"MPI_Alltoallw\");\n      }\n      return __real_ptr_MPI_Alltoallw(sendbuf, sendcounts, sdispls, sendtypes, recvbuf, recvcounts, rdispls, recvtypes, comm);\n    }\n\n    int MPI_Alltoallw(ESMF_MPI_CONST void *sendbuf, ESMF_MPI_CONST int sendcounts[], ESMF_MPI_CONST int sdispls[], ESMF_MPI_CONST MPI_Datatype sendtypes[], void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int rdispls[], ESMF_MPI_CONST MPI_Datatype recvtypes[], MPI_Comm comm) {\n      return __wrap_MPI_Alltoallw(sendbuf, sendcounts, sdispls, sendtypes, recvbuf, recvcounts, rdispls, recvtypes, comm);\n    }\n\n  \n    static int (*__real_ptr_MPI_Barrier)(MPI_Comm comm) = NULL;\n\n    int __real_MPI_Barrier(MPI_Comm comm) {\n      if (__real_ptr_MPI_Barrier == NULL) {\n        __real_ptr_MPI_Barrier = (int (*)(MPI_Comm comm)) dlsym(RTLD_NEXT, \"MPI_Barrier\");\n      }\n      return __real_ptr_MPI_Barrier(comm);\n    }\n\n    int MPI_Barrier(MPI_Comm comm) {\n      return __wrap_MPI_Barrier(comm);\n    }\n\n  \n    static int (*__real_ptr_MPI_Bcast)(void *buffer, int count, MPI_Datatype datatype, int root, MPI_Comm comm) = NULL;\n\n    int __real_MPI_Bcast(void *buffer, int count, MPI_Datatype datatype, int root, MPI_Comm comm) {\n      if (__real_ptr_MPI_Bcast == NULL) {\n        __real_ptr_MPI_Bcast = (int (*)(void *buffer, int count, MPI_Datatype datatype, int root, MPI_Comm comm)) dlsym(RTLD_NEXT, \"MPI_Bcast\");\n      }\n      return __real_ptr_MPI_Bcast(buffer, count, datatype, root, comm);\n    }\n\n    int MPI_Bcast(void *buffer, int count, MPI_Datatype datatype, int root, MPI_Comm comm) {\n      return __wrap_MPI_Bcast(buffer, count, datatype, root, comm);\n    }\n\n  \n    static int (*__real_ptr_MPI_Gather)(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, int root, MPI_Comm comm) = NULL;\n\n    int __real_MPI_Gather(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, int root, MPI_Comm comm) {\n      if (__real_ptr_MPI_Gather == NULL) {\n        __real_ptr_MPI_Gather = (int (*)(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, int root, MPI_Comm comm)) dlsym(RTLD_NEXT, \"MPI_Gather\");\n      }\n      return __real_ptr_MPI_Gather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm);\n    }\n\n    int MPI_Gather(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, int root, MPI_Comm comm) {\n      return __wrap_MPI_Gather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm);\n    }\n\n  \n    static int (*__real_ptr_MPI_Gatherv)(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int displs[], MPI_Datatype recvtype, int root, MPI_Comm comm) = NULL;\n\n    int __real_MPI_Gatherv(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int displs[], MPI_Datatype recvtype, int root, MPI_Comm comm) {\n      if (__real_ptr_MPI_Gatherv == NULL) {\n        __real_ptr_MPI_Gatherv = (int (*)(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int displs[], MPI_Datatype recvtype, int root, MPI_Comm comm)) dlsym(RTLD_NEXT, \"MPI_Gatherv\");\n      }\n      return __real_ptr_MPI_Gatherv(sendbuf, sendcount, sendtype, recvbuf, recvcounts, displs, recvtype, root, comm);\n    }\n\n    int MPI_Gatherv(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int displs[], MPI_Datatype recvtype, int root, MPI_Comm comm) {\n      return __wrap_MPI_Gatherv(sendbuf, sendcount, sendtype, recvbuf, recvcounts, displs, recvtype, root, comm);\n    }\n\n  \n    static int (*__real_ptr_MPI_Recv)(void *buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status) = NULL;\n\n    int __real_MPI_Recv(void *buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status) {\n      if (__real_ptr_MPI_Recv == NULL) {\n        __real_ptr_MPI_Recv = (int (*)(void *buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status)) dlsym(RTLD_NEXT, \"MPI_Recv\");\n      }\n      return __real_ptr_MPI_Recv(buf, count, datatype, source, tag, comm, status);\n    }\n\n    int MPI_Recv(void *buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status) {\n      return __wrap_MPI_Recv(buf, count, datatype, source, tag, comm, status);\n    }\n\n  \n    static int (*__real_ptr_MPI_Reduce)(ESMF_MPI_CONST void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, int root, MPI_Comm comm) = NULL;\n\n    int __real_MPI_Reduce(ESMF_MPI_CONST void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, int root, MPI_Comm comm) {\n      if (__real_ptr_MPI_Reduce == NULL) {\n        __real_ptr_MPI_Reduce = (int (*)(ESMF_MPI_CONST void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, int root, MPI_Comm comm)) dlsym(RTLD_NEXT, \"MPI_Reduce\");\n      }\n      return __real_ptr_MPI_Reduce(sendbuf, recvbuf, count, datatype, op, root, comm);\n    }\n\n    int MPI_Reduce(ESMF_MPI_CONST void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, int root, MPI_Comm comm) {\n      return __wrap_MPI_Reduce(sendbuf, recvbuf, count, datatype, op, root, comm);\n    }\n\n  \n    static int (*__real_ptr_MPI_Scatter)(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, int root, MPI_Comm comm) = NULL;\n\n    int __real_MPI_Scatter(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, int root, MPI_Comm comm) {\n      if (__real_ptr_MPI_Scatter == NULL) {\n        __real_ptr_MPI_Scatter = (int (*)(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, int root, MPI_Comm comm)) dlsym(RTLD_NEXT, \"MPI_Scatter\");\n      }\n      return __real_ptr_MPI_Scatter(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm);\n    }\n\n    int MPI_Scatter(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, int root, MPI_Comm comm) {\n      return __wrap_MPI_Scatter(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm);\n    }\n\n  \n    static int (*__real_ptr_MPI_Send)(ESMF_MPI_CONST void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm) = NULL;\n\n    int __real_MPI_Send(ESMF_MPI_CONST void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm) {\n      if (__real_ptr_MPI_Send == NULL) {\n        __real_ptr_MPI_Send = (int (*)(ESMF_MPI_CONST void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm)) dlsym(RTLD_NEXT, \"MPI_Send\");\n      }\n      return __real_ptr_MPI_Send(buf, count, datatype, dest, tag, comm);\n    }\n\n    int MPI_Send(ESMF_MPI_CONST void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm) {\n      return __wrap_MPI_Send(buf, count, datatype, dest, tag, comm);\n    }\n\n  \n    static int (*__real_ptr_MPI_Sendrecv)(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, int dest, int sendtag, void *recvbuf, int recvcount, MPI_Datatype recvtype, int source, int recvtag, MPI_Comm comm, MPI_Status *status) = NULL;\n\n    int __real_MPI_Sendrecv(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, int dest, int sendtag, void *recvbuf, int recvcount, MPI_Datatype recvtype, int source, int recvtag, MPI_Comm comm, MPI_Status *status) {\n      if (__real_ptr_MPI_Sendrecv == NULL) {\n        __real_ptr_MPI_Sendrecv = (int (*)(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, int dest, int sendtag, void *recvbuf, int recvcount, MPI_Datatype recvtype, int source, int recvtag, MPI_Comm comm, MPI_Status *status)) dlsym(RTLD_NEXT, \"MPI_Sendrecv\");\n      }\n      return __real_ptr_MPI_Sendrecv(sendbuf, sendcount, sendtype, dest, sendtag, recvbuf, recvcount, recvtype, source, recvtag, comm, status);\n    }\n\n    int MPI_Sendrecv(ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, int dest, int sendtag, void *recvbuf, int recvcount, MPI_Datatype recvtype, int source, int recvtag, MPI_Comm comm, MPI_Status *status) {\n      return __wrap_MPI_Sendrecv(sendbuf, sendcount, sendtype, dest, sendtag, recvbuf, recvcount, recvtype, source, recvtag, comm, status);\n    }\n\n  \n    static int (*__real_ptr_MPI_Wait)(MPI_Request *request, MPI_Status *status) = NULL;\n\n    int __real_MPI_Wait(MPI_Request *request, MPI_Status *status) {\n      if (__real_ptr_MPI_Wait == NULL) {\n        __real_ptr_MPI_Wait = (int (*)(MPI_Request *request, MPI_Status *status)) dlsym(RTLD_NEXT, \"MPI_Wait\");\n      }\n      return __real_ptr_MPI_Wait(request, status);\n    }\n\n    int MPI_Wait(MPI_Request *request, MPI_Status *status) {\n      return __wrap_MPI_Wait(request, status);\n    }\n\n  \n    static int (*__real_ptr_MPI_Waitall)(int count, MPI_Request array_of_requests[], MPI_Status *array_of_statuses) = NULL;\n\n    int __real_MPI_Waitall(int count, MPI_Request array_of_requests[], MPI_Status *array_of_statuses) {\n      if (__real_ptr_MPI_Waitall == NULL) {\n        __real_ptr_MPI_Waitall = (int (*)(int count, MPI_Request array_of_requests[], MPI_Status *array_of_statuses)) dlsym(RTLD_NEXT, \"MPI_Waitall\");\n      }\n      return __real_ptr_MPI_Waitall(count, array_of_requests, array_of_statuses);\n    }\n\n    int MPI_Waitall(int count, MPI_Request array_of_requests[], MPI_Status *array_of_statuses) {\n      return __wrap_MPI_Waitall(count, array_of_requests, array_of_statuses);\n    }\n\n  \n    static int (*__real_ptr_MPI_Waitany)(int count, MPI_Request array_of_requests[], int *index, MPI_Status *status) = NULL;\n\n    int __real_MPI_Waitany(int count, MPI_Request array_of_requests[], int *index, MPI_Status *status) {\n      if (__real_ptr_MPI_Waitany == NULL) {\n        __real_ptr_MPI_Waitany = (int (*)(int count, MPI_Request array_of_requests[], int *index, MPI_Status *status)) dlsym(RTLD_NEXT, \"MPI_Waitany\");\n      }\n      return __real_ptr_MPI_Waitany(count, array_of_requests, index, status);\n    }\n\n    int MPI_Waitany(int count, MPI_Request array_of_requests[], int *index, MPI_Status *status) {\n      return __wrap_MPI_Waitany(count, array_of_requests, index, status);\n    }\n\n  \n    static int (*__real_ptr_MPI_Waitsome)(int incount, MPI_Request array_of_requests[], int *outcount, int array_of_indices[], MPI_Status array_of_statuses[]) = NULL;\n\n    int __real_MPI_Waitsome(int incount, MPI_Request array_of_requests[], int *outcount, int array_of_indices[], MPI_Status array_of_statuses[]) {\n      if (__real_ptr_MPI_Waitsome == NULL) {\n        __real_ptr_MPI_Waitsome = (int (*)(int incount, MPI_Request array_of_requests[], int *outcount, int array_of_indices[], MPI_Status array_of_statuses[])) dlsym(RTLD_NEXT, \"MPI_Waitsome\");\n      }\n      return __real_ptr_MPI_Waitsome(incount, array_of_requests, outcount, array_of_indices, array_of_statuses);\n    }\n\n    int MPI_Waitsome(int incount, MPI_Request array_of_requests[], int *outcount, int array_of_indices[], MPI_Status array_of_statuses[]) {\n      return __wrap_MPI_Waitsome(incount, array_of_requests, outcount, array_of_indices, array_of_statuses);\n    }\n\n  \n\n  /*\n   * Fortran MPI functions\n   */\n\n  \n    static void (*FTN_X(__real_ptr_mpi_allgather))(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_allgather)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_allgather) == NULL) {\n        FTN_X(__real_ptr_mpi_allgather) = (void (*)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_allgather)));\n      }\n      FTN_X(__real_ptr_mpi_allgather)(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, comm, ierr);\n    }\n\n    void FTN_X(mpi_allgather)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_allgather)(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_allgatherv))(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *displs, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_allgatherv)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *displs, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_allgatherv) == NULL) {\n        FTN_X(__real_ptr_mpi_allgatherv) = (void (*)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *displs, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_allgatherv)));\n      }\n      FTN_X(__real_ptr_mpi_allgatherv)(sendbuf, sendcount, sendtype, recvbuf, recvcount, displs, recvtype, comm, ierr);\n    }\n\n    void FTN_X(mpi_allgatherv)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *displs, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_allgatherv)(sendbuf, sendcount, sendtype, recvbuf, recvcount, displs, recvtype, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_allreduce))(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_allreduce)(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_allreduce) == NULL) {\n        FTN_X(__real_ptr_mpi_allreduce) = (void (*)(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_allreduce)));\n      }\n      FTN_X(__real_ptr_mpi_allreduce)(sendbuf, recvbuf, count, datatype, op, comm, ierr);\n    }\n\n    void FTN_X(mpi_allreduce)(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_allreduce)(sendbuf, recvbuf, count, datatype, op, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_alltoall))(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_alltoall)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_alltoall) == NULL) {\n        FTN_X(__real_ptr_mpi_alltoall) = (void (*)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_alltoall)));\n      }\n      FTN_X(__real_ptr_mpi_alltoall)(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, comm, ierr);\n    }\n\n    void FTN_X(mpi_alltoall)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_alltoall)(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_alltoallv))(MPI_Fint *sendbuf, MPI_Fint *sendcounts, MPI_Fint *sdispls, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *rdispls, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_alltoallv)(MPI_Fint *sendbuf, MPI_Fint *sendcounts, MPI_Fint *sdispls, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *rdispls, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_alltoallv) == NULL) {\n        FTN_X(__real_ptr_mpi_alltoallv) = (void (*)(MPI_Fint *sendbuf, MPI_Fint *sendcounts, MPI_Fint *sdispls, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *rdispls, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_alltoallv)));\n      }\n      FTN_X(__real_ptr_mpi_alltoallv)(sendbuf, sendcounts, sdispls, sendtype, recvbuf, recvcounts, rdispls, recvtype, comm, ierr);\n    }\n\n    void FTN_X(mpi_alltoallv)(MPI_Fint *sendbuf, MPI_Fint *sendcounts, MPI_Fint *sdispls, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *rdispls, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_alltoallv)(sendbuf, sendcounts, sdispls, sendtype, recvbuf, recvcounts, rdispls, recvtype, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_alltoallw))(MPI_Fint *sendbuf, MPI_Fint *sendcounts, MPI_Fint *sdispls, MPI_Fint *sendtypes, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *rdispls, MPI_Fint *recvtypes, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_alltoallw)(MPI_Fint *sendbuf, MPI_Fint *sendcounts, MPI_Fint *sdispls, MPI_Fint *sendtypes, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *rdispls, MPI_Fint *recvtypes, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_alltoallw) == NULL) {\n        FTN_X(__real_ptr_mpi_alltoallw) = (void (*)(MPI_Fint *sendbuf, MPI_Fint *sendcounts, MPI_Fint *sdispls, MPI_Fint *sendtypes, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *rdispls, MPI_Fint *recvtypes, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_alltoallw)));\n      }\n      FTN_X(__real_ptr_mpi_alltoallw)(sendbuf, sendcounts, sdispls, sendtypes, recvbuf, recvcounts, rdispls, recvtypes, comm, ierr);\n    }\n\n    void FTN_X(mpi_alltoallw)(MPI_Fint *sendbuf, MPI_Fint *sendcounts, MPI_Fint *sdispls, MPI_Fint *sendtypes, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *rdispls, MPI_Fint *recvtypes, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_alltoallw)(sendbuf, sendcounts, sdispls, sendtypes, recvbuf, recvcounts, rdispls, recvtypes, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_barrier))(MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_barrier)(MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_barrier) == NULL) {\n        FTN_X(__real_ptr_mpi_barrier) = (void (*)(MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_barrier)));\n      }\n      FTN_X(__real_ptr_mpi_barrier)(comm, ierr);\n    }\n\n    void FTN_X(mpi_barrier)(MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_barrier)(comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_bcast))(MPI_Fint *buffer, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_bcast)(MPI_Fint *buffer, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_bcast) == NULL) {\n        FTN_X(__real_ptr_mpi_bcast) = (void (*)(MPI_Fint *buffer, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_bcast)));\n      }\n      FTN_X(__real_ptr_mpi_bcast)(buffer, count, datatype, root, comm, ierr);\n    }\n\n    void FTN_X(mpi_bcast)(MPI_Fint *buffer, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_bcast)(buffer, count, datatype, root, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_exscan))(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_exscan)(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_exscan) == NULL) {\n        FTN_X(__real_ptr_mpi_exscan) = (void (*)(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_exscan)));\n      }\n      FTN_X(__real_ptr_mpi_exscan)(sendbuf, recvbuf, count, datatype, op, comm, ierr);\n    }\n\n    void FTN_X(mpi_exscan)(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_exscan)(sendbuf, recvbuf, count, datatype, op, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_gather))(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_gather)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_gather) == NULL) {\n        FTN_X(__real_ptr_mpi_gather) = (void (*)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_gather)));\n      }\n      FTN_X(__real_ptr_mpi_gather)(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm, ierr);\n    }\n\n    void FTN_X(mpi_gather)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_gather)(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_gatherv))(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *displs, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_gatherv)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *displs, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_gatherv) == NULL) {\n        FTN_X(__real_ptr_mpi_gatherv) = (void (*)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *displs, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_gatherv)));\n      }\n      FTN_X(__real_ptr_mpi_gatherv)(sendbuf, sendcount, sendtype, recvbuf, recvcounts, displs, recvtype, root, comm, ierr);\n    }\n\n    void FTN_X(mpi_gatherv)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *displs, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_gatherv)(sendbuf, sendcount, sendtype, recvbuf, recvcounts, displs, recvtype, root, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_recv))(MPI_Fint *buf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *source, MPI_Fint *tag, MPI_Fint *comm, MPI_Fint *status, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_recv)(MPI_Fint *buf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *source, MPI_Fint *tag, MPI_Fint *comm, MPI_Fint *status, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_recv) == NULL) {\n        FTN_X(__real_ptr_mpi_recv) = (void (*)(MPI_Fint *buf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *source, MPI_Fint *tag, MPI_Fint *comm, MPI_Fint *status, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_recv)));\n      }\n      FTN_X(__real_ptr_mpi_recv)(buf, count, datatype, source, tag, comm, status, ierr);\n    }\n\n    void FTN_X(mpi_recv)(MPI_Fint *buf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *source, MPI_Fint *tag, MPI_Fint *comm, MPI_Fint *status, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_recv)(buf, count, datatype, source, tag, comm, status, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_reduce))(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_reduce)(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_reduce) == NULL) {\n        FTN_X(__real_ptr_mpi_reduce) = (void (*)(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_reduce)));\n      }\n      FTN_X(__real_ptr_mpi_reduce)(sendbuf, recvbuf, count, datatype, op, root, comm, ierr);\n    }\n\n    void FTN_X(mpi_reduce)(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_reduce)(sendbuf, recvbuf, count, datatype, op, root, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_reduce_scatter))(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_reduce_scatter)(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_reduce_scatter) == NULL) {\n        FTN_X(__real_ptr_mpi_reduce_scatter) = (void (*)(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_reduce_scatter)));\n      }\n      FTN_X(__real_ptr_mpi_reduce_scatter)(sendbuf, recvbuf, recvcounts, datatype, op, comm, ierr);\n    }\n\n    void FTN_X(mpi_reduce_scatter)(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_reduce_scatter)(sendbuf, recvbuf, recvcounts, datatype, op, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_scatter))(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_scatter)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_scatter) == NULL) {\n        FTN_X(__real_ptr_mpi_scatter) = (void (*)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_scatter)));\n      }\n      FTN_X(__real_ptr_mpi_scatter)(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm, ierr);\n    }\n\n    void FTN_X(mpi_scatter)(MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_scatter)(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_scatterv))(MPI_Fint *sendbuf, MPI_Fint *sendcounts, MPI_Fint *displs, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_scatterv)(MPI_Fint *sendbuf, MPI_Fint *sendcounts, MPI_Fint *displs, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_scatterv) == NULL) {\n        FTN_X(__real_ptr_mpi_scatterv) = (void (*)(MPI_Fint *sendbuf, MPI_Fint *sendcounts, MPI_Fint *displs, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_scatterv)));\n      }\n      FTN_X(__real_ptr_mpi_scatterv)(sendbuf, sendcounts, displs, sendtype, recvbuf, recvcount, recvtype, root, comm, ierr);\n    }\n\n    void FTN_X(mpi_scatterv)(MPI_Fint *sendbuf, MPI_Fint *sendcounts, MPI_Fint *displs, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_scatterv)(sendbuf, sendcounts, displs, sendtype, recvbuf, recvcount, recvtype, root, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_scan))(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_scan)(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_scan) == NULL) {\n        FTN_X(__real_ptr_mpi_scan) = (void (*)(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_scan)));\n      }\n      FTN_X(__real_ptr_mpi_scan)(sendbuf, recvbuf, count, datatype, op, comm, ierr);\n    }\n\n    void FTN_X(mpi_scan)(MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_scan)(sendbuf, recvbuf, count, datatype, op, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_send))(MPI_Fint *buf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *dest, MPI_Fint *tag, MPI_Fint *comm, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_send)(MPI_Fint *buf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *dest, MPI_Fint *tag, MPI_Fint *comm, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_send) == NULL) {\n        FTN_X(__real_ptr_mpi_send) = (void (*)(MPI_Fint *buf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *dest, MPI_Fint *tag, MPI_Fint *comm, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_send)));\n      }\n      FTN_X(__real_ptr_mpi_send)(buf, count, datatype, dest, tag, comm, ierr);\n    }\n\n    void FTN_X(mpi_send)(MPI_Fint *buf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *dest, MPI_Fint *tag, MPI_Fint *comm, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_send)(buf, count, datatype, dest, tag, comm, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_wait))(MPI_Fint *request, MPI_Fint *status, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_wait)(MPI_Fint *request, MPI_Fint *status, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_wait) == NULL) {\n        FTN_X(__real_ptr_mpi_wait) = (void (*)(MPI_Fint *request, MPI_Fint *status, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_wait)));\n      }\n      FTN_X(__real_ptr_mpi_wait)(request, status, ierr);\n    }\n\n    void FTN_X(mpi_wait)(MPI_Fint *request, MPI_Fint *status, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_wait)(request, status, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_waitall))(MPI_Fint *count, MPI_Fint *reqs, MPI_Fint *stats, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_waitall)(MPI_Fint *count, MPI_Fint *reqs, MPI_Fint *stats, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_waitall) == NULL) {\n        FTN_X(__real_ptr_mpi_waitall) = (void (*)(MPI_Fint *count, MPI_Fint *reqs, MPI_Fint *stats, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_waitall)));\n      }\n      FTN_X(__real_ptr_mpi_waitall)(count, reqs, stats, ierr);\n    }\n\n    void FTN_X(mpi_waitall)(MPI_Fint *count, MPI_Fint *reqs, MPI_Fint *stats, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_waitall)(count, reqs, stats, ierr);\n    }\n\n  \n    static void (*FTN_X(__real_ptr_mpi_waitany))(MPI_Fint *count, MPI_Fint *reqs, MPI_Fint *index, MPI_Fint *status, MPI_Fint *ierr) = NULL;\n\n    void FTN_X(__real_mpi_waitany)(MPI_Fint *count, MPI_Fint *reqs, MPI_Fint *index, MPI_Fint *status, MPI_Fint *ierr) {\n      if (FTN_X(__real_ptr_mpi_waitany) == NULL) {\n        FTN_X(__real_ptr_mpi_waitany) = (void (*)(MPI_Fint *count, MPI_Fint *reqs, MPI_Fint *index, MPI_Fint *status, MPI_Fint *ierr)) dlsym(RTLD_NEXT, xstr(FTN_X(mpi_waitany)));\n      }\n      FTN_X(__real_ptr_mpi_waitany)(count, reqs, index, status, ierr);\n    }\n\n    void FTN_X(mpi_waitany)(MPI_Fint *count, MPI_Fint *reqs, MPI_Fint *index, MPI_Fint *status, MPI_Fint *ierr) {\n      FTN_X(__wrap_mpi_waitany)(count, reqs, index, status, ierr);\n    }\n\n  \n\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Trace/preload/gen_wrappers_mpi.py": "#!/usr/bin/env/python\n#\n# Jinja2 is required:\n# http://jinja.pocoo.org/docs/2.10/intro/#installation\n#\n# See README in this directory.\n#\n\nfrom jinja2 import Environment\n\ntemplate_wrappers_mpi_h = \"\"\"\n/**\n *  wrappers_mpi.h\n *\n *  !! DO NOT EDIT !!\n *  This file was generated by gen_wrappers_mpi.py.\n *  !! DO NOT EDIT !!\n *\n *  Wrappers for MPI calls so we can trace them.\n *  These are linked statically into the executable using\n *  --wrap=SYMBOL flags to the linker.\n *\n */\n\n#ifndef _WRAPPERS_MPI_H\n#define _WRAPPERS_MPI_H\n\n#ifndef ESMF_MPIUNI\n\n#include <mpi.h>\n\n#ifdef MPICH2_CONST\n#define ESMF_MPI_CONST MPICH2_CONST\n#elif defined(OPEN_MPI) && OMPI_MAJOR_VERSION == 1 && OMPI_MINOR_VERSION == 7 && OMPI_RELEASE_VERSION <= 4 \n#define ESMF_MPI_CONST\n#elif defined(OPEN_MPI) && OMPI_MAJOR_VERSION == 1 && OMPI_MINOR_VERSION <= 6\n#define ESMF_MPI_CONST \n#else\n#define ESMF_MPI_CONST const\n#endif\n\nextern \"C\" {\n  {% for f in cfunc_list %}\n  {{f.ret}} __wrap_{{f.name}}({{f.params}});\n  {% endfor %}\n\n  {% for f in ffunc_list %}\n  void FTN_X(__wrap_{{f.name}})({{f.params}});\n  {% endfor %}\n}\n\n#endif\n#endif\n\"\"\"\n\n\ntemplate_wrappers_mpi = \"\"\"\n/**\n *  wrappers_mpi.C\n *\n *  !! DO NOT EDIT !!\n *  This file was generated by gen_wrappers_mpi.py.\n *  !! DO NOT EDIT !!\n *\n *  Wrappers for MPI calls so we can trace them.\n *  These are linked statically into the executable using\n *  --wrap=SYMBOL flags to the linker.\n *\n */\n\n#ifndef ESMF_MPIUNI\n#include <mpi.h>\n\n#include \"ESMCI_Macros.h\"\n#include \"ESMCI_Trace.h\"\n#include \"preload.h\"\n#include \"wrappers_mpi.h\"\n\nextern \"C\" {\n\n  static int insideMPIRegion = 0;\n  static int ignorerc = 0;\n  \n  /*\n   * C MPI functions\n   */\n\n  {% for f in cfunc_list %}\n    extern {{f.ret}} __real_{{f.name}}({{f.params}});    \n\n    {{f.ret}} __wrap_{{f.name}}({{f.params}}) {\n      if (c_esmftrace_isinitialized() == 1 && insideMPIRegion == 0) {\n        //printf(\"__wrap_{{f.name}} (C)\\\\n\");\n        insideMPIRegion = 1;\n        ESMCI::TraceEventRegionEnter(\"{{f.name}}\", &ignorerc);\n        {{f.ret}} ret = __real_{{f.name}}({{f.args}});\n        ESMCI::TraceEventRegionExit(\"{{f.name}}\", &ignorerc);\n        insideMPIRegion = 0;\n        return ret;\n      }\n      else {\n        return __real_{{f.name}}({{f.args}});\n      }\n    }\n  {% endfor %}\n\n  /*\n   * Fortran MPI functions\n   */\n\n  {% for f in ffunc_list %}\n    extern void FTN_X(__real_{{f.name}})({{f.params}});    \n\n    void FTN_X(__wrap_{{f.name}})({{f.params}}) {\n      if (c_esmftrace_isinitialized() == 1 && insideMPIRegion == 0) {\n        //printf(\"__wrap_{{f.name}}_ (Fortran)\\\\n\");\n        insideMPIRegion = 1;\n        ESMCI::TraceEventRegionEnter(\"{{f.name}}\", &ignorerc);\n        FTN_X(__real_{{f.name}})({{f.args}});\n        ESMCI::TraceEventRegionExit(\"{{f.name}}\", &ignorerc);\n        insideMPIRegion = 0;\n      }\n      else {\n        FTN_X(__real_{{f.name}})({{f.args}});\n      }\n    }\n  {% endfor %}\n\n}\n#endif\n\"\"\"\n\ntemplate_preload_mpi = \"\"\"\n/**\n *\n * preload_mpi.C\n *\n *  !! DO NOT EDIT !!\n *  This file was generated by gen_wrappers_mpi.py.\n *  !! DO NOT EDIT !!\n *\n * Functions that will be preloaded with LD_PRELOAD, thereby\n * overriding system library functions so we can call into our\n * wrapper function.\n *\n * Since we are using dynamic linking, the __real_<SYMBOL>\n * functions are looked up at runtime using dlsym().\n */\n\n#ifndef ESMF_MPIUNI\n\n#ifdef ESMF_PGIVERSION_MAJOR\n/* required for RTLD_NEXT */\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#endif\n\n#include <dlfcn.h>\n#include <mpi.h>\n\n#include \"ESMCI_Macros.h\"\n#include \"ESMCI_Trace.h\"\n#include \"wrappers_mpi.h\"\n\n#define xstr(s) str(s)\n#define str(s) #s\n\nextern \"C\" {\n\n  /*\n   * C MPI functions\n   */\n\n  {% for f in cfunc_list %}\n    static {{f.ret}} (*__real_ptr_{{f.name}})({{f.params}}) = NULL;\n\n    {{f.ret}} __real_{{f.name}}({{f.params}}) {\n      if (__real_ptr_{{f.name}} == NULL) {\n        __real_ptr_{{f.name}} = ({{f.ret}} (*)({{f.params}})) dlsym(RTLD_NEXT, \"{{f.name}}\");\n      }\n      return __real_ptr_{{f.name}}({{f.args}});\n    }\n\n    {{f.ret}} {{f.name}}({{f.params}}) {\n      return __wrap_{{f.name}}({{f.args}});\n    }\n\n  {% endfor %}\n\n  /*\n   * Fortran MPI functions\n   */\n\n  {% for f in ffunc_list %}\n    static void (*FTN_X(__real_ptr_{{f.name}}))({{f.params}}) = NULL;\n\n    void FTN_X(__real_{{f.name}})({{f.params}}) {\n      if (FTN_X(__real_ptr_{{f.name}}) == NULL) {\n        FTN_X(__real_ptr_{{f.name}}) = (void (*)({{f.params}})) dlsym(RTLD_NEXT, xstr(FTN_X({{f.name}})));\n      }\n      FTN_X(__real_ptr_{{f.name}})({{f.args}});\n    }\n\n    void FTN_X({{f.name}})({{f.params}}) {\n      FTN_X(__wrap_{{f.name}})({{f.args}});\n    }\n\n  {% endfor %}\n\n}\n\n#endif\n\n\"\"\"\n\ntemplate_static_linkopts=\"\"\"\nESMF_TRACE_WRAPPERS_MPI :={% for f in cfunc_list %} {{f.name}}{% if loop.index % 4 == 0 %}\\nESMF_TRACE_WRAPPERS_MPI +={% endif %}{% endfor %}\nESMF_TRACE_WRAPPERS_MPI +={% for f in ffunc_list %} {{f.name}}_ {{f.name}}__{% if loop.index % 2 == 0 %}\\nESMF_TRACE_WRAPPERS_MPI +={% endif %}{% endfor %}\n\"\"\"\n\n\n# C MPI Functions\ncfunc_list = [\n\n    {\n        'ret':'int', 'name':'MPI_Allgather',\n        'params':'ESMF_MPI_CONST void *sendbuf, int  sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, MPI_Comm comm',\n        'args':'sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, comm'\n    },\n\n    {\n        'ret':'int', 'name':'MPI_Allgatherv',\n        'params':'ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int displs[], MPI_Datatype recvtype, MPI_Comm comm',\n        'args':'sendbuf, sendcount, sendtype, recvbuf, recvcounts, displs, recvtype, comm'\n    },\n\n    \n    {\n        'ret':'int', 'name':'MPI_Allreduce',\n        'params':'ESMF_MPI_CONST void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, MPI_Comm comm',\n        'args':'sendbuf, recvbuf, count, datatype, op, comm'\n    },\n\n    {\n        'ret':'int', 'name':'MPI_Alltoall',\n        'params':'ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, MPI_Comm comm',\n        'args':'sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, comm'\n    },\n\n    {\n        'ret':'int', 'name':'MPI_Alltoallv',\n        'params':'ESMF_MPI_CONST void *sendbuf, ESMF_MPI_CONST int sendcounts[], ESMF_MPI_CONST int sdispls[], MPI_Datatype sendtype, void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int rdispls[], MPI_Datatype recvtype, MPI_Comm comm',\n        'args':'sendbuf, sendcounts, sdispls, sendtype, recvbuf, recvcounts, rdispls, recvtype, comm'\n    },\n\n    {\n        'ret':'int', 'name':'MPI_Alltoallw',\n        'params':'ESMF_MPI_CONST void *sendbuf, ESMF_MPI_CONST int sendcounts[], ESMF_MPI_CONST int sdispls[], ESMF_MPI_CONST MPI_Datatype sendtypes[], void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int rdispls[], ESMF_MPI_CONST MPI_Datatype recvtypes[], MPI_Comm comm',\n        'args':'sendbuf, sendcounts, sdispls, sendtypes, recvbuf, recvcounts, rdispls, recvtypes, comm'\n    },\n    \n    {\n        'ret':'int', 'name':'MPI_Barrier',\n        'params':'MPI_Comm comm',\n        'args':'comm'\n    },\n\n    {\n        'ret':'int', 'name':'MPI_Bcast',\n        'params':'void *buffer, int count, MPI_Datatype datatype, int root, MPI_Comm comm',\n        'args':'buffer, count, datatype, root, comm'\n    },\n    \n    {\n        'ret':'int', 'name':'MPI_Gather',\n        'params':'ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, int root, MPI_Comm comm',\n        'args':'sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm'\n    },\n\n    {\n        'ret':'int', 'name':'MPI_Gatherv',\n        'params':'ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, ESMF_MPI_CONST int recvcounts[], ESMF_MPI_CONST int displs[], MPI_Datatype recvtype, int root, MPI_Comm comm',\n        'args':'sendbuf, sendcount, sendtype, recvbuf, recvcounts, displs, recvtype, root, comm'\n    },\n\n    {\n        'ret':'int', 'name':'MPI_Recv',\n        'params':'void *buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status',\n        'args':'buf, count, datatype, source, tag, comm, status'\n    },\n\n    {\n        'ret':'int', 'name':'MPI_Reduce',\n        'params':'ESMF_MPI_CONST void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, int root, MPI_Comm comm',\n        'args':'sendbuf, recvbuf, count, datatype, op, root, comm'\n    },\n\n    {\n        'ret':'int', 'name':'MPI_Scatter',\n        'params':'ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, int root, MPI_Comm comm',\n        'args':'sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm'\n    },\n    \n    {\n        'ret':'int', 'name':'MPI_Send',\n        'params':'ESMF_MPI_CONST void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm',\n        'args':'buf, count, datatype, dest, tag, comm'\n    },\n    \n    {\n        'ret':'int', 'name':'MPI_Sendrecv',\n        'params':'ESMF_MPI_CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, int dest, int sendtag, void *recvbuf, int recvcount, MPI_Datatype recvtype, int source, int recvtag, MPI_Comm comm, MPI_Status *status',\n        'args':'sendbuf, sendcount, sendtype, dest, sendtag, recvbuf, recvcount, recvtype, source, recvtag, comm, status'\n    },\n    \n    {\n        'ret':'int', 'name':'MPI_Wait',\n        'params':'MPI_Request *request, MPI_Status *status',\n        'args':'request, status'\n    },\n\n    {\n        'ret':'int', 'name':'MPI_Waitall',\n        'params':'int count, MPI_Request array_of_requests[], MPI_Status *array_of_statuses',\n        'args':'count, array_of_requests, array_of_statuses'\n    },\n\n    {\n        'ret':'int', 'name':'MPI_Waitany',\n        'params':'int count, MPI_Request array_of_requests[], int *index, MPI_Status *status',\n        'args':'count, array_of_requests, index, status'\n    },\n\n    {\n        'ret':'int', 'name':'MPI_Waitsome',\n        'params':'int incount, MPI_Request array_of_requests[], int *outcount, int array_of_indices[], MPI_Status array_of_statuses[]',\n        'args':'incount, array_of_requests, outcount, array_of_indices, array_of_statuses'\n    }\n    \n]\n\n\n# Fortran MPI Functions\nffunc_list = [\n\n    {\n        'name':'mpi_allgather',\n        'params':'MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, comm, ierr'\n    },\n\n    {\n        'name':'mpi_allgatherv',\n        'params':'MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *displs, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'sendbuf, sendcount, sendtype, recvbuf, recvcount, displs, recvtype, comm, ierr'\n    },\n\n    {\n        'name':'mpi_allreduce',\n        'params':'MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'sendbuf, recvbuf, count, datatype, op, comm, ierr'\n    },\n\n    {\n        'name':'mpi_alltoall',\n        'params':'MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, comm, ierr'\n    },\n\n    {\n        'name':'mpi_alltoallv',\n        'params':'MPI_Fint *sendbuf, MPI_Fint *sendcounts, MPI_Fint *sdispls, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *rdispls, MPI_Fint *recvtype, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'sendbuf, sendcounts, sdispls, sendtype, recvbuf, recvcounts, rdispls, recvtype, comm, ierr'\n    },\n\n    {\n        'name':'mpi_alltoallw',\n        'params':'MPI_Fint *sendbuf, MPI_Fint *sendcounts, MPI_Fint *sdispls, MPI_Fint *sendtypes, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *rdispls, MPI_Fint *recvtypes, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'sendbuf, sendcounts, sdispls, sendtypes, recvbuf, recvcounts, rdispls, recvtypes, comm, ierr'\n    },\n    \n    {\n        'name':'mpi_barrier', 'params':'MPI_Fint *comm, MPI_Fint *ierr', 'args':'comm, ierr'\n    },\n\n    {\n        'name':'mpi_bcast',\n        'params':'MPI_Fint *buffer, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'buffer, count, datatype, root, comm, ierr'\n    },\n\n    {\n        'name':'mpi_exscan',\n        'params':'MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'sendbuf, recvbuf, count, datatype, op, comm, ierr'      \n    },\n    \n    {\n        'name':'mpi_gather',\n        'params':'MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm, ierr'\n    },\n\n    {\n        'name':'mpi_gatherv',\n        'params':'MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *displs, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'sendbuf, sendcount, sendtype, recvbuf, recvcounts, displs, recvtype, root, comm, ierr'\n    },\n\n    {\n        'name':'mpi_recv',\n        'params':'MPI_Fint *buf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *source, MPI_Fint *tag, MPI_Fint *comm, MPI_Fint *status, MPI_Fint *ierr',\n        'args':'buf, count, datatype, source, tag, comm, status, ierr'\n    },\n    \n    {\n        'name':'mpi_reduce',\n        'params':'MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'sendbuf, recvbuf, count, datatype, op, root, comm, ierr'      \n    },\n\n    {\n        'name':'mpi_reduce_scatter',\n        'params':'MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *recvcounts, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'sendbuf, recvbuf, recvcounts, datatype, op, comm, ierr'\n        \n    },\n    \n    {\n        'name': 'mpi_scatter',\n        'params': 'MPI_Fint *sendbuf, MPI_Fint *sendcount, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm, ierr'\n    },\n\n    {\n        'name': 'mpi_scatterv',\n        'params': 'MPI_Fint *sendbuf, MPI_Fint *sendcounts, MPI_Fint *displs, MPI_Fint *sendtype, MPI_Fint *recvbuf, MPI_Fint *recvcount, MPI_Fint *recvtype, MPI_Fint *root, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'sendbuf, sendcounts, displs, sendtype, recvbuf, recvcount, recvtype, root, comm, ierr'\n    },    \n\n    {\n        'name':'mpi_scan',\n        'params':'MPI_Fint *sendbuf, MPI_Fint *recvbuf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *op, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'sendbuf, recvbuf, count, datatype, op, comm, ierr'      \n    },\n\n    {\n        'name':'mpi_send',\n        'params':'MPI_Fint *buf, MPI_Fint *count, MPI_Fint *datatype, MPI_Fint *dest, MPI_Fint *tag, MPI_Fint *comm, MPI_Fint *ierr',\n        'args':'buf, count, datatype, dest, tag, comm, ierr'\n    },\n    \n    {\n        'name':'mpi_wait',\n        'params':'MPI_Fint *request, MPI_Fint *status, MPI_Fint *ierr',\n        'args':'request, status, ierr'\n    },\n\n    {\n        'name':'mpi_waitall',\n        'params':'MPI_Fint *count, MPI_Fint *reqs, MPI_Fint *stats, MPI_Fint *ierr',\n        'args':'count, reqs, stats, ierr'\n    },\n\n    {\n        'name':'mpi_waitany',\n        'params':'MPI_Fint *count, MPI_Fint *reqs, MPI_Fint *index, MPI_Fint *status, MPI_Fint *ierr',\n        'args':'count, reqs, index, status, ierr'\n    }\n    \n]\n\n\ndef gen():\n\n    template = Environment().from_string(template_wrappers_mpi_h)\n    text = template.render(cfunc_list=cfunc_list, ffunc_list=ffunc_list)\n\n    f = open('wrappers_mpi.h', 'w+')\n    f.write(text)\n    f.close()\n    print 'Generated wrappers_mpi.h'\n    \n    template = Environment().from_string(template_wrappers_mpi)\n    text = template.render(cfunc_list=cfunc_list, ffunc_list=ffunc_list)\n\n    f = open('wrappers_mpi.C', 'w+')\n    f.write(text)\n    f.close()\n    print 'Generated wrappers_mpi.C'\n\n    template = Environment().from_string(template_preload_mpi)\n    text = template.render(cfunc_list=cfunc_list, ffunc_list=ffunc_list)\n\n    f = open('preload_mpi.C', 'w+')\n    f.write(text)\n    f.close()\n    print 'Generated preload_mpi.C'\n\n    template = Environment().from_string(template_static_linkopts)\n    text = template.render(cfunc_list=cfunc_list, ffunc_list=ffunc_list) \n    print \"\\nFor use in $ESMF_DIR/build/common.mk:\\n\" + text\n    \n    \nif __name__ == '__main__':\n    gen()\n    \n",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Trace/src/ESMCI_Trace.C": "// $Id$\n/*\n * Writes trace events to the file system.\n *\n * Earth System Modeling Framework\n * Copyright 2002-2020, University Corporation for Atmospheric Research,\n * Massachusetts Institute of Technology, Geophysical Fluid Dynamics\n * Laboratory, University of Michigan, National Centers for Environmental\n * Prediction, Los Alamos National Laboratory, Argonne National Laboratory,\n * NASA Goddard Space Flight Center.\n * Licensed under the University of Illinois-NCSA License.\n */\n\n#include <iomanip>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <map>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#ifndef ESMF_OS_MinGW\n#include <unistd.h>\n#else\n#include <Winsock.h>\n#endif\n\n#ifndef ESMF_NO_DLFCN\n#include <dlfcn.h>\n#endif\n\n#include \"ESMCI_Macros.h\"\n#include \"ESMCI_Util.h\"\n#include \"ESMCI_LogErr.h\"\n#include \"ESMCI_VM.h\"\n#include \"ESMCI_Trace.h\"\n#include \"ESMCI_VMKernel.h\"\n#include \"ESMCI_HashMap.h\"\n#include \"ESMCI_RegionNode.h\"\n#include \"ESMCI_RegionSummary.h\"\n#include \"ESMCI_ComponentInfo.h\"\n#include \"ESMCI_TraceUtil.h\"\n#include \"ESMCI_Comp.h\"\n#include <esmftrc.h>\n\n#ifndef ESMF_OS_MinGW\n#define TRACE_DIR_PERMISSIONS (S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH)\n#else\n#define TRACE_DIR_PERMISSIONS (S_IRWXU)\n#endif\n\n#define EVENT_BUF_SIZE_DEFAULT 4096\n#define EVENT_BUF_SIZE_EAGER 1024\n#define REGION_HASHTABLE_SIZE 100\n#define VMID_MAP_SIZE 10000\n\nusing std::string;\nusing std::vector;\nusing std::stringstream;\nusing std::ofstream;\nusing std::map;\n\nnamespace ESMCI {\n\n  struct StringHashF {\n    unsigned long operator()(const string& s) const {\n      unsigned long hash = 5381;\n      int c;\n      const char *str = s.c_str();\n      while ((c = *str++))\n        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */\n      //printf(\"hash for %s = %d\\n\", s.c_str(), hash % REGION_HASHTABLE_SIZE);\n      return hash % REGION_HASHTABLE_SIZE;\n    }\n  };\n\n  struct ESMFPhaseHashF {\n    unsigned long operator()(const ESMFPhaseId& phaseId) const {\n      return phaseId.hashcode() % REGION_HASHTABLE_SIZE;\n    }\n  };\n\n  struct ESMFIdHashF {\n    unsigned long operator()(const ESMFId& esmfId) const {\n      return esmfId.hashcode() % REGION_HASHTABLE_SIZE;\n    }\n  };\n\n  static bool traceInitialized = false;  // is trace ready for events?\n  static bool traceLocalPet = false;     // is tracing on for this PET?\n  static bool profileLocalPet = false;   // is profiling on for this PET?\n  static bool profileOutputToLog = false;    // output to EMSF log?\n  static bool profileOutputToFile = false;   // output to text file?\n  static bool profileOutputToBinary = false; // output to binary trace?\n  static bool profileOutputSummary = false;   // output aggregate profile on root PET?\n\n  static uint16_t next_local_id() {\n    static uint16_t next = 1;\n    if (next > REGION_MAX_COUNT) {\n      throw std::range_error(\"Out of space for trace regions\");\n    }\n    return next++;\n  }\n\n  /*\n    Timed regions are defined by either:\n     1) a component phase represented by (vmid, baseid, method, phase), or\n     2) a user-defined region name (from ESMF_TraceRegionEnter()/Exit() calls)\n\n    Both are mapped to a single integer id for the region.  In the trace\n    we output a \"definition\" event for each region, which includes the\n    region id and either the user-defined name or the (vmid, baseid, method, phase)\n    tuple.  The trace post-processor can then translate the ids back to\n    meaningful names.  Using only integer ids reduces the size of the trace files.\n\n    userRegionMap:  maps from user-defined name to region id\n    phaseRegionMap:  maps from phase (vmid,baseid,method,phase) to region id\n\n    componentInfoMap:  maps from (vmid,baseid) to an object\n                       for keeping track of component information\n\n   */\n\n  static HashMap<string, uint16_t, REGION_HASHTABLE_SIZE, StringHashF> userRegionMap;\n  static HashMap<ESMFPhaseId, uint16_t, REGION_HASHTABLE_SIZE, ESMFPhaseHashF> phaseRegionMap;\n  static HashMap<ESMFId, ComponentInfo *, REGION_HASHTABLE_SIZE, ESMFIdHashF> componentInfoMap;\n\n  static RegionNode rootRegionNode(NULL, next_local_id(), false);\n  static RegionNode *currentRegionNode = &rootRegionNode;\n\n#ifndef ESMF_NO_DLFCN\n  static int (*notify_wrappers)(int initialized) = NULL;\n#endif\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceMapVmId()\"\n  int TraceMapVmId(VMId *vmid, int *rc) {\n\n    //this data structure used to map VMIds(vmKey,localid)\n    //to an integer id\n    static VMId vmIdMap[VMID_MAP_SIZE];\n    static int nextVmId = 0;\n\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    int foundIdx;\n    //search backward - vm more likely to be at the end\n    for (foundIdx=nextVmId-1; foundIdx >= 0; foundIdx--) {\n      if (VMIdCompare(vmid, &(vmIdMap[foundIdx]))) {\n        if (rc!=NULL) *rc = ESMF_SUCCESS;\n        return foundIdx;\n      }\n    }\n    if (nextVmId >= VMID_MAP_SIZE) {\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,\n                                    \"Out of VmIdMap space inside tracing\", ESMC_CONTEXT, rc);\n      return -1;\n    }\n    else {\n      localrc = (&vmIdMap[nextVmId])->create();\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n                                        ESMC_CONTEXT, rc))\n        return -1;\n      VMIdCopy(&(vmIdMap[nextVmId]), vmid);\n      foundIdx = nextVmId;\n      nextVmId++;\n\n      if (rc!=NULL) *rc=ESMF_SUCCESS;\n      return foundIdx;\n    }\n  }\n\n  bool TraceInitialized() {\n    return traceInitialized;\n  }\n\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::CheckPETList\"\n  static bool CheckPETList(string petList, int petToCheck, int *rc) {\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n\n    bool invalidFormat = false;\n    const vector<string> listItems = split(trim(petList), \" \");\n\n    for (unsigned i = 0; i < listItems.size(); i++) {\n      if (listItems.at(i).find(\"-\") != string::npos) {\n        vector<string> petRange = split(trim(listItems.at(i)), \"-\");\n        if (petRange.size() == 2) {\n          int low, high;\n          stringstream lowss(trim(petRange.at(0)));\n          stringstream highss(trim(petRange.at(1)));\n          if (!(lowss >> low).fail() && !(highss >> high).fail()) {\n            //printf(\"low=%d, high=%d\\n\", low, high);\n            if (petToCheck >= low && petToCheck <= high) {\n              return true;\n            }\n          }\n          else {\n            invalidFormat = true;\n          }\n        }\n        else {\n          invalidFormat = true;\n        }\n      }\n      else {\n        int pet = -1;\n        stringstream ss(trim(listItems.at(i)));\n        ss >> pet;\n        if(!(ss.fail())) {\n          if (petToCheck == pet) {\n            return true;\n          }\n        }\n        else {\n          invalidFormat = true;\n        }\n      }\n      if (invalidFormat) {\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                                      \"Invalid PET list format.\",\n                                      ESMC_CONTEXT, rc);\n        return false;\n      }\n\n    }\n\n    //pet not found in list\n    return false;\n}\n\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::GlobalProfileOptions()\"\n  static void GlobalProfileOptions(int *traceIsOn, int *profileIsOn, int *rc) {\n    *rc = ESMC_RC_NOT_IMPL;\n    if (traceIsOn != NULL) {\n      *traceIsOn = 0;\n      char const *envVar = VM::getenv(\"ESMF_RUNTIME_TRACE\");\n      if (envVar != NULL) {\n        std::string value(envVar);\n        size_t index;\n        index = value.find(\"on\");\n        if (index == std::string::npos)\n          index = value.find(\"ON\");\n        if (index != std::string::npos){\n          *traceIsOn=1;\n        }\n      }\n    }\n    if (profileIsOn != NULL) {\n      *profileIsOn = 0;\n      char const *envVar = VM::getenv(\"ESMF_RUNTIME_PROFILE\");\n      if (envVar != NULL) {\n        std::string value(envVar);\n        size_t index;\n        index = value.find(\"on\");\n        if (index == std::string::npos)\n          index = value.find(\"ON\");\n        if (index != std::string::npos){\n          *profileIsOn=1;\n        }\n      }\n    }\n    *rc = ESMF_SUCCESS;\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::ProfileIsEnabledForPET()\"\n  static bool ProfileIsEnabledForPET(int petToCheck, int *rc) {\n    int localrc;\n    if (rc != NULL) *rc = ESMF_SUCCESS;\n\n    int tracingEnabled = 0;\n    int profilingEnabled = 0;\n    GlobalProfileOptions(&tracingEnabled, &profilingEnabled, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n         ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n      return false;\n\n    if (profilingEnabled == 0) return false;\n\n    //always profile PET 0?\n    if (petToCheck == 0) return true;\n\n    char const *envVar = VM::getenv(\"ESMF_RUNTIME_PROFILE_PETLIST\");\n    if (envVar != NULL) {\n      string envStr(envVar);\n      bool inPetList = CheckPETList(envStr, petToCheck, &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc,\n           \"Invalid format in ESMF_RUNTIME_PROFILE_PETLIST environment variable.\", ESMC_CONTEXT, rc))\n        return false;\n      return inPetList;\n    }\n    else {\n      //default to profile all PETs\n      return true;\n    }\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceIsEnabledForPET()\"\n  static bool TraceIsEnabledForPET(int petToCheck, int *rc){\n    int localrc;\n    if (rc != NULL) *rc = ESMF_SUCCESS;\n\n    //first check if tracing is enabled\n    int tracingEnabled = 0;\n    int profilingEnabled = 0;\n    GlobalProfileOptions(&tracingEnabled, &profilingEnabled, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n         ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n      return false;\n\n    if (tracingEnabled == 0) return false;\n\n    //always trace PET 0\n    if (petToCheck == 0) return true;\n\n    char const *envVar = VM::getenv(\"ESMF_RUNTIME_TRACE_PETLIST\");\n    if (envVar != NULL) {\n      string envStr(envVar);\n      bool inPetList = CheckPETList(envStr, petToCheck, &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc,\n           \"Invalid format in ESMF_RUNTIME_TRACE_PETLIST environment variable.\", ESMC_CONTEXT, rc))\n        return false;\n      return inPetList;\n    }\n    else {\n      //default to trace all PETs\n      return true;\n    }\n\n  }\n\n  //global context\n  static struct esmftrc_platform_filesys_ctx *traceCtx = NULL;\n\n  static struct esmftrc_default_ctx *esmftrc_platform_get_default_ctx() {\n    return &traceCtx->ctx;\n  }\n\n  static void write_packet(struct esmftrc_platform_filesys_ctx *ctx) {\n    size_t nmemb = fwrite(esmftrc_packet_buf(&ctx->ctx),\n\t\t\t  esmftrc_packet_buf_size(&ctx->ctx), 1, ctx->fh);\n    assert(nmemb == 1);\n  }\n\n  static int is_backend_full(void *data) {\n    //assume file system never full\n    return 0;\n  }\n\n  static void open_packet(void *data) {\n    struct esmftrc_platform_filesys_ctx *ctx =\n      FROM_VOID_PTR(struct esmftrc_platform_filesys_ctx, data);\n\n    esmftrc_default_open_packet(&ctx->ctx, ctx->nodename, ctx->stream_id);\n  }\n\n  static void close_packet(void *data) {\n    struct esmftrc_platform_filesys_ctx *ctx =\n      FROM_VOID_PTR(struct esmftrc_platform_filesys_ctx, data);\n\n    // close packet now\n    esmftrc_default_close_packet(&ctx->ctx);\n\n    // write packet to file\n    write_packet(ctx);\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::write_metadata()\"\n  static void write_metadata(const char *trace_dir, int *rc) {\n\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n\n    string metadata_string = TraceGetMetadataString();\n    string filename(trace_dir);\n    filename += \"/metadata\";\n\n    std::ofstream ofs (filename.c_str(), std::ofstream::trunc);\n    if (ofs.is_open() && !ofs.fail()) {\n      ofs << metadata_string;\n      ofs.close();\n    }\n    else {\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_FILE_CREATE, \"Error writing trace metadata file\",\n                                    ESMC_CONTEXT, rc);\n    }\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::InitializeWrappers()\"\n  static void InitializeWrappers() {\n    int wrappersPresent = TRACE_WRAP_NONE;\n#ifndef ESMF_NO_DLFCN\n    void *preload_lib = dlopen(NULL, RTLD_LAZY);\n    if (preload_lib == NULL) {\n      ESMC_LogDefault.Write(\"ESMF Tracing/Profiling could not open shared library containing instrumentation.\", ESMC_LOGMSG_WARN);\n    }\n    else {\n      notify_wrappers = (int (*)(int)) dlsym(preload_lib, \"c_esmftrace_notify_wrappers\");\n      if (notify_wrappers != NULL) {\n        wrappersPresent = notify_wrappers(1);\n      }\n      else {\n        ESMC_LogDefault.Write(\"ESMF Tracing/Profiling could not load dynamic instrumentation functions.\", ESMC_LOGMSG_WARN);\n      }\n    }\n#else\n    wrappersPresent = c_esmftrace_notify_wrappers(1);\n#endif\n\n    if (wrappersPresent != TRACE_WRAP_NONE) {\n      stringstream logMsg;\n      logMsg << \"ESMF Tracing/Profiling enabled with \";\n      if (wrappersPresent == TRACE_WRAP_DYNAMIC) {\n        logMsg << \"DYNAMIC\";\n      }\n      else if (wrappersPresent == TRACE_WRAP_STATIC) {\n        logMsg << \"STATIC\";\n      }\n      logMsg << \" instrumentation.\";\n      ESMC_LogDefault.Write(logMsg.str().c_str(), ESMC_LOGMSG_INFO);\n      logMsg.str(\"  This option should only be used for profiling applications and NOT for production runs.\");\n      ESMC_LogDefault.Write(logMsg.str().c_str(), ESMC_LOGMSG_INFO);\n    }\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FinalizeWrappers()\"\n  static void FinalizeWrappers() {\n#ifndef ESMF_NO_DLFCN\n    if (notify_wrappers != NULL) {\n      notify_wrappers(0);\n    }\n#else\n    c_esmftrace_notify_wrappers(0);\n#endif\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceOpen()\"\n  void TraceOpen(std::string trace_dir, int *profileToLog, int *rc) {\n\n    int localrc;\n    stringstream logMsg;\n\n    if (rc != NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    VM *globalvm = VM::getGlobal(&localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n         ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n      return;\n\n    //determine if tracing is turned on for this PET\n    traceLocalPet = TraceIsEnabledForPET(globalvm->getLocalPet(), &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n         ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) {\n      traceLocalPet = false;\n      return;\n    }\n\n    //determine if profiling is turned on for this PET\n    //if tracing is enabled, automatically turn on profiling\n    profileLocalPet = traceLocalPet || ProfileIsEnabledForPET(globalvm->getLocalPet(), &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n         ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) {\n      profileLocalPet = false;\n      return;\n    }\n\n    //determine output method for profiling, if enabled\n    if (profileLocalPet) {\n      //always output binary if tracing is enabled\n      if (traceLocalPet) profileOutputToBinary = true;\n      char const *envProfileOutput = VM::getenv(\"ESMF_RUNTIME_PROFILE_OUTPUT\");\n      if (envProfileOutput != NULL && strlen(envProfileOutput) > 0) {\n        string profileOutput(envProfileOutput);\n        if ( (profileOutput.find(\"TEXT\") != string::npos) ||\n             (profileOutput.find(\"text\") != string::npos) ||\n             (profileOutput.find(\"Text\") != string::npos) ) {\n          if (profileToLog != NULL && *profileToLog == 1) {\n            profileOutputToLog = true;\n          }\n          else {\n            profileOutputToFile = true;\n          }\n        }\n        if ( (profileOutput.find(\"BINARY\") != string::npos) ||\n             (profileOutput.find(\"binary\") != string::npos) ||\n             (profileOutput.find(\"Binary\") != string::npos) ) {\n          profileOutputToBinary = true;\n        }\n        if ( (profileOutput.find(\"SUMMARY\") != string::npos) ||\n             (profileOutput.find(\"summary\") != string::npos) ||\n             (profileOutput.find(\"Summary\") != string::npos) ) {\n          profileOutputSummary = true;\n        }\n      }\n      else {\n        // if not specified, default is to output text\n        if (profileToLog != NULL && *profileToLog == 1) {\n          //printf(\"set output to log\\n\");\n          profileOutputToLog = true;\n        }\n        else {\n          //printf(\"set output to file\\n\");\n          profileOutputToFile = true;\n        }\n      }\n    }\n\n    if (traceLocalPet) {\n      ESMC_LogDefault.Write(\"ESMF Tracing Enabled\", ESMC_LOGMSG_INFO);\n    }\n    if (profileLocalPet) {\n      ESMC_LogDefault.Write(\"ESMF Profiling Enabled\", ESMC_LOGMSG_INFO);\n    }\n\n    // initialize the clock\n    struct esmftrc_platform_filesys_ctx *ctx;\n    if (traceLocalPet || profileLocalPet) {\n      ctx = FROM_VOID_PTR(struct esmftrc_platform_filesys_ctx, malloc(sizeof(*ctx)));\n      if (!ctx) {\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_MEM_ALLOCATE, \"Cannot allocate context\",\n                                      ESMC_CONTEXT, rc);\n        return;\n      }\n      ctx->latch_ts = 0;\n      ctx->fh == NULL;\n\n      //store as global context\n      traceCtx = ctx;\n\n      TraceInitializeClock(&localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc,\n           ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n        return;\n    }\n\n    // determine if we need to set up for binary output\n    if (traceLocalPet || profileOutputToBinary) {\n\n      // stream_id same as global pet id\n      int stream_id = globalvm->getLocalPet();\n      ctx->stream_id = stream_id;\n      //get node name\n      if (gethostname(ctx->nodename, NODENAME_LEN) < 0) {\n        ctx->nodename[0] = '\\0';\n      }\n\n      // set up callbacks\n      struct esmftrc_platform_callbacks cbs;\n      cbs.sys_clock_clock_get_value = TraceGetClock;\n      cbs.is_backend_full = is_backend_full;\n      cbs.open_packet = open_packet;\n      cbs.close_packet = close_packet;\n\n      //allocate event buffer\n      char const *envFlush = VM::getenv(\"ESMF_RUNTIME_TRACE_FLUSH\");\n      string strFlush = \"DEFAULT\";\n      int eventBufSize = EVENT_BUF_SIZE_DEFAULT;\n      if (envFlush != NULL) {\n        strFlush = envFlush;\n        if (trim(strFlush) == \"EAGER\" || trim(strFlush) == \"eager\" || trim(strFlush) == \"Eager\") {\n          eventBufSize = EVENT_BUF_SIZE_EAGER;\n          logMsg.str(\"ESMF Tracing set to EAGER flushing.\");\n          ESMC_LogDefault.Write(logMsg.str().c_str(), ESMC_LOGMSG_INFO);\n        }\n      }\n\n      uint8_t *buf = FROM_VOID_PTR(uint8_t, malloc(eventBufSize));\n      if (!buf) {\n        free(ctx);\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_MEM_ALLOCATE, \"Cannot allocate trace event buffer\",\n                                      ESMC_CONTEXT, rc);\n        return;\n      }\n      memset(buf, 0, eventBufSize);\n\n      //make relative path absolute if needed\n      string stream_dir_root;\n      if (trace_dir[0] != '/') {\n        char cwd[ESMC_MAXPATHLEN];\n        FTN_X(c_esmc_getcwd)(cwd, &localrc, ESMC_MAXPATHLEN);\n        if (ESMC_LogDefault.MsgFoundError(localrc,\n           \"Error getting working directory\", ESMC_CONTEXT, rc))\n          return;\n        stream_dir_root = string (cwd, ESMC_F90lentrim(cwd, ESMC_MAXPATHLEN)) + \"/\" + trace_dir;\n      }\n      else {\n        stream_dir_root = trace_dir;\n      }\n\n      struct stat st;\n      if (stream_id == 0) {\n        if (stat(stream_dir_root.c_str(), &st) == -1) {\n          ESMC_Logical relaxedFlag = ESMF_TRUE;\n          int dir_perms = TRACE_DIR_PERMISSIONS;\n          FTN_X(c_esmc_makedirectory)(stream_dir_root.c_str(), &dir_perms,\n                                      &relaxedFlag, &localrc, stream_dir_root.length());\n\n          if (ESMC_LogDefault.MsgFoundError(localrc,\n                 \"Error creating trace root directory\", ESMC_CONTEXT, rc))\n            return;\n        }\n      }\n\n      // all PETs wait for directory to be created\n      globalvm->barrier();\n\n      // my specific file\n      stringstream stream_file;\n      stream_file << stream_dir_root << \"/esmf_stream_\" << std::setfill('0') << std::setw(4) << stream_id;\n\n      ctx->fh = fopen(stream_file.str().c_str(), \"wb\");\n      if (!ctx->fh) {\n        free(ctx);\n        free(buf);\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_FILE_OPEN, \"Error opening trace output file\",\n                                      ESMC_CONTEXT, rc);\n        return;\n      }\n\n      //stream zero writes the metadata file\n      if (stream_id == 0) {\n        write_metadata(stream_dir_root.c_str(), &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc,\n             ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) {\n          return;\n        }\n      }\n\n      esmftrc_init(&ctx->ctx, buf, eventBufSize, cbs, ctx);\n      open_packet(ctx);\n\n    }\n    else {\n      // this PET either has no tracing/profiling or only profiling to log/text\n      globalvm->barrier();  //match barrier call above\n    }\n\n    if (traceLocalPet || profileLocalPet) {\n      traceInitialized = true;\n      // notify any function wrappers that trace is ready\n      InitializeWrappers();\n    }\n\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n\n  }\n\n  static string getPhaseNameFromPhaseId(ESMFPhaseId phaseId) {\n    ComponentInfo *ci = NULL;\n    bool present = componentInfoMap.get(phaseId.getESMFId(), ci);\n    if (present && ci != NULL) {\n      return ci->getPhaseName(phaseId);\n    }\n    return \"\";\n  }\n\n  static string getRegionNameFromId(uint16_t local_id) {\n    ESMFPhaseId phaseId;\n    bool present = phaseRegionMap.reverse(local_id, phaseId);\n    if (present) {\n      return getPhaseNameFromPhaseId(phaseId);\n    }\n    else {\n      string name;\n      present = userRegionMap.reverse(local_id, name);\n      if (present) return name;\n    }\n    return \"\";\n  }\n\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::populateRegionNames()\"\n  static void populateRegionNames(RegionNode *rn) {\n    if (rn == NULL) return;\n\n    string name = getRegionNameFromId(rn->getLocalId());\n    if (name.length() == 0) {\n      if (rn->isUserRegion()) {\n        name = \"UNKNOWN_USER_REGION\";\n      }\n      else {\n        name = \"UNKNOWN_ESMF_PHASE\";\n      }\n    }\n    rn->setName(name);\n\n    for (unsigned i = 0; i < rn->getChildren().size(); i++) {\n      populateRegionNames(rn->getChildren().at(i));\n    }\n  }\n\n  static size_t regionNamePadding(RegionSummary *rs, int depth) {\n    size_t maxSize = rs->getName().length() + (2*depth);\n    for (unsigned i = 0; i < rs->getChildren().size(); i++) {\n      size_t childSize = regionNamePadding(rs->getChildren().at(i), depth+1);\n      if (childSize > maxSize) maxSize = childSize;\n    }\n    return maxSize;\n  }\n\n  static size_t regionNamePadding(RegionNode *rn, int depth) {\n    size_t maxSize = rn->getName().length() + (2*depth);\n    for (unsigned i = 0; i < rn->getChildren().size(); i++) {\n      size_t childSize = regionNamePadding(rn->getChildren().at(i), depth+1);\n      if (childSize > maxSize) maxSize = childSize;\n    }\n    return maxSize;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::printProfile()\"\n#define STATLINE 512\n  static void printProfile(RegionNode *rn, bool printToLog, string prefix, ofstream &ofs, size_t namePadding, int *rc) {\n\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    if (rn->getParent() != NULL) {\n      char strbuf[STATLINE];\n      string name = rn->getName();\n      name.insert(0, prefix);\n\n      stringstream fmt;\n      fmt << \"%-\" << namePadding << \"s %-6lu %-11.4f %-11.4f %-11.4f %-11.4f %-11.4f\";\n\n      snprintf(strbuf, STATLINE, fmt.str().c_str(),\n               name.c_str(), rn->getCount(), rn->getTotal()*NANOS_TO_SECS,\n               rn->getSelfTime()*NANOS_TO_SECS, rn->getMean()*NANOS_TO_SECS,\n               rn->getMin()*NANOS_TO_SECS, rn->getMax()*NANOS_TO_SECS);\n      if (printToLog) {\n        ESMC_LogDefault.Write(strbuf, ESMC_LOGMSG_INFO);\n      }\n      else {\n        ofs << strbuf << \"\\n\";\n      }\n    }\n    rn->sortChildren();\n    for (unsigned i = 0; i < rn->getChildren().size(); i++) {\n      printProfile(rn->getChildren().at(i), printToLog, prefix + \"  \", ofs, namePadding, rc);\n    }\n    if (rc!=NULL) *rc=ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::printProfile()\"\n  static void printProfile(RegionNode *rn, bool printToLog, string filename, int *rc) {\n\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    ofstream ofs;\n    int localrc;\n\n    size_t namePadding = regionNamePadding(rn, 0)+1;\n    if (namePadding > 200) namePadding = 200;\n\n    stringstream fmt;\n    fmt << \"%-\" << namePadding << \"s %-6s %-11s %-11s %-11s %-11s %-11s\";\n\n    char strbuf[STATLINE];\n    snprintf(strbuf, STATLINE, fmt.str().c_str(),\n             \"Region\", \"Count\", \"Total (s)\", \"Self (s)\", \"Mean (s)\", \"Min (s)\", \"Max (s)\");\n\n    if (printToLog) {\n      ESMC_LogDefault.Write(\"**************** Region Timings *******************\", ESMC_LOGMSG_INFO);\n      ESMC_LogDefault.Write(strbuf, ESMC_LOGMSG_INFO);\n    }\n    else {\n      ofs.open(filename.c_str(), ofstream::trunc);\n      if (ofs.is_open() && !ofs.fail()) {\n        ofs << strbuf << \"\\n\";\n      }\n      else {\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_FILE_CREATE, \"Error opening profile output file\",\n           ESMC_CONTEXT, rc);\n        return;\n      }\n    }\n    printProfile(rn, printToLog, \"\", ofs, namePadding, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, \"Error writing profile output file\",\n         ESMC_CONTEXT, rc))\n      return;\n    if (!printToLog) {\n      ofs.close();\n    }\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::findImbalancedConnectors()\"\n  static void findImbalancedConnectors(RegionSummary *rs, vector<string> &connList, int *rc) {\n\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    rs->sortChildren();\n    for (unsigned i = 0; i < rs->getChildren().size(); i++) {\n      //TODO: find a cleaner way of determining the type of component\n      RegionSummary *child = rs->getChildren().at(i);\n      if (child->getName().find(\"-TO-\") != string::npos &&\n\t  child->getName().find(\"Run\") != string::npos) {\n\t//only report if normalized time shows > 5% imbalance\n\tif (child->getParent()->getTotalMax() > 0) {\n\t  double ndiff = (1.0*child->getTotalMax() / child->getParent()->getTotalMax()) -\n\t    (1.0*child->getTotalMin() / child->getParent()->getTotalMax());\n\t  if (ndiff > .05) {\n\t    connList.push_back(child->getName());\n\t  }\n\t}\n      }\n    }\n\n    for (unsigned i = 0; i < rs->getChildren().size(); i++) {\n      findImbalancedConnectors(rs->getChildren().at(i), connList, rc);\n    }\n\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::printSummaryProfileMessage()\"\n  static void printSummaryProfileMessage(RegionSummary *rs, ofstream &ofs, int *rc) {\n\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n    int localrc;\n    vector<string> connList;\n\n    findImbalancedConnectors(rs, connList, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n\t  ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n      return;\n\n    if (connList.size() > 0) {\n      string msg = \"********\";\n      msg += \"\\nIMPORTANT: Large deviations between Connector times on different PETs\\n\";\n      msg += \"are typically indicators of load imbalance in the system. The following\\n\";\n      msg += \"Connectors in this profile may indicate a load imbalance:\\n\";\n      for (unsigned i = 0; i < connList.size(); i++) {\n\tmsg += \"\\t - \" + connList.at(i) + \"\\n\";\n      }\n      ofs << msg << \"********\\n\\n\";\n    }\n\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::printSummaryProfile()\"\n  static void printSummaryProfile(RegionSummary *rs, string prefix, ofstream &ofs, size_t namePadding, int *rc) {\n\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    if (rs->getParent() != NULL) {\n      char strbuf[STATLINE];\n      string name = rs->getName();\n      name.insert(0, prefix);\n\n      char countstr[12];\n      if (rs->getCountsMatch()) {\n\tsnprintf(countstr, 12, \"%-6lu\", rs->getCountEach());\n      }\n      else {\n\tsnprintf(countstr, 12, \"%-8s\", \"MULTIPLE\");\n      }\n\n      stringstream fmt;\n      fmt << \"%-\" << namePadding << \"s %-6lu %-8s %-11.4f %-11.4f %-7d %-11.4f %-7d\";\n\n      snprintf(strbuf, STATLINE, fmt.str().c_str(),\n               name.c_str(), rs->getPetCount(), countstr,\n\t       rs->getTotalMean()*NANOS_TO_SECS,\n\t       rs->getTotalMin()*NANOS_TO_SECS, rs->getTotalMinPet(),\n\t       rs->getTotalMax()*NANOS_TO_SECS, rs->getTotalMaxPet());\n      ofs << strbuf << \"\\n\";\n    }\n    rs->sortChildren();\n    for (unsigned i = 0; i < rs->getChildren().size(); i++) {\n      printSummaryProfile(rs->getChildren().at(i), prefix + \"  \", ofs, namePadding, rc);\n    }\n    if (rc!=NULL) *rc=ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::printSummaryProfile()\"\n  static void printSummaryProfile(RegionSummary *rs, string filename, int *rc) {\n\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    ofstream ofs;\n    int localrc;\n\n    size_t namePadding = regionNamePadding(rs, 0)+1;\n    if (namePadding > 200) namePadding = 200;\n\n    stringstream fmt;\n    fmt << \"%-\" << namePadding << \"s %-6s %-8s %-11s %-11s %-7s %-11s %-7s\";\n\n    char strbuf[STATLINE];\n    snprintf(strbuf, STATLINE, fmt.str().c_str(),\n             \"Region\", \"PETs\", \"Count\", \"Mean (s)\", \"Min (s)\", \"Min PET\", \"Max (s)\", \"Max PET\");\n\n    ofs.open(filename.c_str(), ofstream::trunc);\n    if (ofs.is_open() && !ofs.fail()) {\n      printSummaryProfileMessage(rs, ofs, &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc, \"Error writing profile footer\",\n\t   ESMC_CONTEXT, rc))\n\treturn;\n      ofs << strbuf << \"\\n\";\n    }\n    else {\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_FILE_CREATE, \"Error opening profile output file\",\n\t\t\t\t    ESMC_CONTEXT, rc);\n      return;\n    }\n\n    printSummaryProfile(rs, \"\", ofs, namePadding, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, \"Error writing profile output file\",\n         ESMC_CONTEXT, rc))\n      return;\n    ofs.close();\n\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n  }\n\n\n\n  static void AddRegionProfilesToTrace(RegionNode *rn) {\n\n    esmftrc_default_trace_region_profile(\n        esmftrc_platform_get_default_ctx(),\n\trn->getGlobalId(),\n\trn->getParentGlobalId(),\n\trn->getTotal(),\n\trn->getSelfTime(),\n\trn->getCount(),\n\trn->getMax(),\n\trn->getMin(),\n\trn->getMean(),\n\trn->getStdDev());\n\n    for (unsigned i = 0; i < rn->getChildren().size(); i++) {\n      AddRegionProfilesToTrace(rn->getChildren().at(i));\n    }\n  }\n\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::GatherRegions()\"\n  static void GatherRegions(int *rc) {\n\n    int localrc;\n    VM *globalvm = VM::getGlobal(&localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n          ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n      return;\n\n    char *serializedTree = NULL;\n    size_t bufferSize = 0;\n\n    if (profileLocalPet && globalvm->getLocalPet() > 0) {\n      //std::cout << \"serialize from pet: \" << globalvm->getLocalPet() << \"\\n\";\n      try {\n        serializedTree = rootRegionNode.serialize(&bufferSize);\n      }\n      catch(std::exception& e) {\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,\n                                      e.what(), ESMC_CONTEXT, rc);\n        return;\n      }\n      //std::cout << \"sending profile from pet: \" << globalvm->getLocalPet() << \" (\" << bufferSize << \")\" << \"\\n\";\n      //send size of buffer\n      globalvm->send((void *) &bufferSize, sizeof(bufferSize), 0);\n      //send buffer itself\n      globalvm->send((void *) serializedTree, bufferSize, 0);\n\n      free(serializedTree);\n    }\n    else if (globalvm->getLocalPet() == 0) {\n\n      //clone root\n      //ESMCI::RegionNode *aggNode = new ESMCI::RegionNode(NULL, &rootRegionNode);\n      ESMCI::RegionSummary *sumNode = new ESMCI::RegionSummary(NULL);\n\n      //first add my own timing tree to the summary\n      sumNode->merge(rootRegionNode, globalvm->getLocalPet());\n\n      //then gather from other PETs\n      for (int p=1; p<globalvm->getPetCount(); p++) {\n\n        if (ProfileIsEnabledForPET(p, &localrc) || TraceIsEnabledForPET(p, &localrc)) {\n\n          bufferSize = 0;\n          globalvm->recv((void *) &bufferSize, sizeof(bufferSize), p);\n          //std::cout << \"receive profile from pet: \" << p << \" (\" << bufferSize << \")\" << \"\\n\";\n\n          serializedTree = (char *) malloc(bufferSize);\n          if (serializedTree == NULL) {\n            ESMC_LogDefault.MsgFoundError(ESMC_RC_MEM_ALLOCATE,\n                                        \"Error allocating memory when gather profiled regions\",\n                                        ESMC_CONTEXT, rc);\n          return;\n          }\n          memset(serializedTree, 0, bufferSize);\n\n          globalvm->recv(serializedTree, bufferSize, p);\n\n\n          try {\n\t    ESMCI::RegionNode *desNode = new ESMCI::RegionNode(serializedTree, bufferSize);\n\t    //merge statistics\n\t    sumNode->merge(*desNode, p);\n\t    delete desNode;\n\t  }\n          catch(std::exception& e) {\n            ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,\n                                          e.what(), ESMC_CONTEXT, rc);\n            return;\n          }\n\n          free(serializedTree);\n        }\n        else if (ESMC_LogDefault.MsgFoundError(localrc,\n                   ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) {\n          return;\n        }\n\n      }\n\n      //now we have received and merged\n      //profiles from all other PETs\n      printSummaryProfile(sumNode, \"ESMF_Profile.summary\", &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc,\n           ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n        return;\n\n      delete sumNode;\n    }\n\n  }\n\n\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceClose()\"\n  void TraceClose(int *rc) {\n\n    int localrc;\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    // allow calling multiple times, only closes\n    // on the first call, needed in testing\n    if (traceInitialized) {\n      traceInitialized = false;\n      FinalizeWrappers();\n\n      if (profileOutputToLog || profileOutputToFile || profileOutputSummary) {\n        populateRegionNames(&rootRegionNode);\n      }\n\n      if (profileOutputToLog) {\n        printProfile(&rootRegionNode, true, \"\", &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc,\n             ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n          return;\n      }\n\n      if (profileOutputToFile) {\n        VM *globalvm = VM::getGlobal(&localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc,\n             ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n          return;\n\n        stringstream fname;\n        fname << (globalvm->getPetCount() - 1);\n        int width = fname.str().length();\n        fname.str(\"\");\n        fname << \"ESMF_Profile.\" << std::setfill('0') << std::setw(width) << globalvm->getLocalPet();\n\n        printProfile(&rootRegionNode, false, fname.str(), &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc,\n             ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n          return;\n      }\n\n      if (profileOutputToBinary) {\n        AddRegionProfilesToTrace(&rootRegionNode);\n      }\n\n      if (profileOutputSummary) {\n        GatherRegions(&localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc,\n           ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n          return;\n      }\n\n      if (traceCtx != NULL) {\n        if (traceLocalPet || profileOutputToBinary) {\n          if (traceCtx->fh != NULL) {\n            if (esmftrc_packet_is_open(&traceCtx->ctx) &&\n                !esmftrc_packet_is_empty(&traceCtx->ctx)) {\n              close_packet(traceCtx);\n            }\n            fclose(traceCtx->fh);\n          }\n          free(esmftrc_packet_buf(&traceCtx->ctx));\n        }\n        free(traceCtx);\n        traceCtx = NULL;\n      }\n\n      vector<HashNode<ESMFId, ComponentInfo *> *> entries = componentInfoMap.getEntries();\n      vector<HashNode<ESMFId, ComponentInfo *> *>::iterator it;\n      for(it = entries.begin(); it != entries.end(); it++) {\n        delete (*it)->getValue();\n      }\n    }\n\n    if(rc != NULL) *rc = ESMF_SUCCESS;\n\n  }\n\n\n\n  ///////////////////// I/O Tracing //////////////////\n\n  //static std::string openFilename;\n  //static uint64_t openStartTimestamp = -1;\n\n  void TraceIOOpenStart(const char *path) {\n    /*\n      if (!traceLocalPet) return;\n      openStartTimestamp = TraceGetClock(NULL);\n      openFilename = string(path);\n    */\n  }\n\n  void TraceIOOpenEnd() {\n    /*\n    if (!traceLocalPet) return;\n    uint64_t openEndTimestamp = TraceGetClock(NULL);\n    uint64_t openTime = openEndTimestamp - openStartTimestamp;\n\n    esmftrc_default_trace_ioopen(esmftrc_platform_get_default_ctx(),\n                                 openFilename.c_str(), openTime);\n\n    openStartTimestamp = -1;\n    */\n  }\n\n  void TraceIOCloseStart() {\n  }\n\n  void TraceIOCloseEnd() {\n  }\n\n  void TraceIOWriteStart() {\n  }\n\n  void TraceIOWriteEnd(size_t nbytes) {\n  }\n\n  void TraceIOReadStart() {\n  }\n\n  void TraceIOReadEnd(size_t nbytes) {\n  }\n\n  /*\n  static void PopIOStats() {\n\n    size_t readBytes = readTotalBytes.back();\n    uint64_t readTime = readTotalTime.back();\n    readTotalBytes.pop_back();\n    readTotalTime.pop_back();\n    if (readBytes > 0) {\n      esmftrc_default_trace_ioread(esmftrc_platform_get_default_ctx(),\n                                    readBytes, readTime);\n    }\n\n    size_t writeBytes = writeTotalBytes.back();\n    uint64_t writeTime = writeTotalTime.back();\n    writeTotalBytes.pop_back();\n    writeTotalTime.pop_back();\n    if (writeBytes > 0) {\n      esmftrc_default_trace_iowrite(esmftrc_platform_get_default_ctx(),\n                                    writeBytes, writeTime);\n    }\n  }\n  */\n\n  ////////////////////////////////////////////////////\n\n  /////////////////// MPI /////////////////////\n\n  void TraceMPIWaitStart() {\n    if (profileLocalPet) {\n      currentRegionNode->enteredMPI(TraceGetClock(traceCtx));\n    }\n  }\n\n  void TraceMPIWaitEnd() {\n    if (profileLocalPet) {\n      currentRegionNode->exitedMPI(TraceGetClock(traceCtx));\n    }\n  }\n\n  /*\n   * This function used only in tests.\n   */\n  void TraceTest_GetMPIWaitStats(int *count, long long *time) {\n    if (!traceInitialized) return;\n    if (profileLocalPet) {\n      if (count != NULL)\n        *count = currentRegionNode->getCountMPI();\n      if (time != NULL)\n        *time = currentRegionNode->getTotalMPI();\n    }\n  }\n\n  void TraceTest_CheckMPIRegion(string name, int *exists) {\n    if (exists == NULL) return;\n    *exists = 0;\n    if (traceLocalPet || profileLocalPet) {\n      if (currentRegionNode == NULL) return;\n      uint16_t local_id = 0;\n      //bool present = userRegionMap.get(name, local_id);\n\n      std::transform(name.begin(), name.end(), name.begin(), ::tolower);\n      vector<HashNode<string, uint16_t> *> entries = userRegionMap.getEntries();\n      vector<HashNode<string, uint16_t> *>::iterator it;\n\n      bool present = false;\n      for(it = entries.begin(); it != entries.end(); it++) {\n        string regName = (*it)->getKey();\n\tstd::transform(regName.begin(), regName.end(), regName.begin(), ::tolower);\n\t//std::cout << \"Comparing: \" << name << \" to \" << regName << \"\\n\";\n\tif (regName == name) {\n\t  present = true;\n\t  local_id = (*it)->getValue();\n\t  break;\n\t}\n      }\n\n      if (!present) return;\n      RegionNode *child = currentRegionNode->getChild(local_id);\n      if (child != NULL) *exists = 1;\n    }\n  }\n\n\n  /////////////////////////////////////////////\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventPhaseEnter()\"\n  void TraceEventPhaseEnter(int *ep_vmid, int *ep_baseid, int *ep_method, int *ep_phase, int *rc) {\n\n    if (traceLocalPet || profileLocalPet) {\n\n      uint16_t local_id = 0;\n      ESMFPhaseId phaseId(ESMFId(*ep_vmid, *ep_baseid), *ep_method, *ep_phase);\n      bool present = phaseRegionMap.get(phaseId, local_id);\n      if (!present) {\n        local_id = next_local_id();\n        phaseRegionMap.put(phaseId, local_id);\n      }\n\n      if (currentRegionNode == NULL) {\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,\n                                      \"Trace regions not properly nested\", ESMC_CONTEXT, rc);\n        return;\n      }\n\n      bool added;\n      currentRegionNode = currentRegionNode->getOrAddChild(local_id, added);\n\n      //add region to trace output\n      if (added && (traceLocalPet || profileOutputToBinary)) {\n        esmftrc_default_trace_define_region(esmftrc_platform_get_default_ctx(),\n                                            currentRegionNode->getGlobalId(),\n                                            TRACE_REGIONTYPE_PHASE,\n                                            *ep_vmid, *ep_baseid, *ep_method, *ep_phase,\n                                            getRegionNameFromId(local_id).c_str());\n      }\n\n      TraceClockLatch(traceCtx);  /* lock in time on clock */\n      currentRegionNode->entered(traceCtx->latch_ts);\n\n      if (traceLocalPet) {\n        esmftrc_default_trace_regionid_enter(esmftrc_platform_get_default_ctx(),\n                                             currentRegionNode->getGlobalId());\n      }\n      TraceClockUnlatch(traceCtx);\n\n      //printf(\"OrigPhaseEnter: vmid=%d, bid=%d, method=%d, phase=%d\\n\", *ep_vmid, *ep_baseid, *ep_method, *ep_phase);\n\n    }\n\n    if (rc != NULL) *rc = ESMF_SUCCESS;\n\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodToEnum\"\n  static inline int MethodToEnum(enum ESMCI::method method) {\n      switch(method){\n      case ESMCI::METHOD_INITIALIZE:\n        return 0;\n        break;\n      case ESMCI::METHOD_RUN:\n        return 1;\n        break;\n      case ESMCI::METHOD_FINALIZE:\n        return 2;\n        break;\n      default:\n        return -1;\n        break;\n      }\n      return -1;\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventCompPhaseEnter()\"\n  void TraceEventCompPhaseEnter(Comp *comp, enum method *method, int *phase, int *rc) {\n\n    if (traceLocalPet || profileLocalPet) {\n      int localrc;\n\n      int methodid = MethodToEnum(*method);\n      if (methodid >= 0) {\n\n        VM *vm;\n        localrc = comp->getVm(&vm);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        VMId *vmid = vm->getVMId(&localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        int localvmid = TraceMapVmId(vmid, &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        ESMC_Base *base;\n        localrc = comp->getBase(&base);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n        int baseid = base->ESMC_BaseGetID();\n\n        TraceEventPhaseEnter(&localvmid, &baseid, &methodid, phase, &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        //printf(\"CompPhaseEnter: vmid=%d, bid=%d, method=%d, phase=%d\\n\", localvmid, baseid, methodid, *phase);\n      }\n    }\n\n    if (rc!=NULL) *rc=ESMF_SUCCESS;\n\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventCompPhaseExit()\"\n  void TraceEventCompPhaseExit(Comp *comp, enum method *method, int *phase, int *rc) {\n\n    if (traceLocalPet || profileLocalPet) {\n      int localrc;\n\n      if (*method == ESMCI::METHOD_SETSERVICES) {\n\n        //after SetServices, look to see if there are any\n        //phase map attributes available, and if so record\n        //these labels for displaying in the output\n\n        ESMC_Base *base;\n        localrc = comp->getBase(&base);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        VM *vm;\n        localrc = comp->getVm(&vm);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        VMId *vmid = vm->getVMId(&localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        int localvmid = TraceMapVmId(vmid, &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        int baseid = base->ESMC_BaseGetID();\n        char *compName = base->ESMC_BaseGetName();\n\n        vector<string> IPM;\n        vector<string> IIPM;\n        vector<string> RPM;\n        vector<string> FPM;\n\n        Attribute *attrRoot = base->ESMC_BaseGetRoot();\n        if (attrRoot != NULL) {\n\n          Attribute *attrPack = attrRoot->AttPackGet(\"NUOPC\", \"Instance\", \"comp\", \"\", ESMC_ATTNEST_ON);\n          if (attrPack != NULL) {\n\n            Attribute *attr;\n            attr = attrPack->AttPackGetAttribute(\"InitializePhaseMap\", ESMC_ATTNEST_ON);\n            if (attr != NULL && Attribute::isSet(attr)) {\n              localrc = attr->get(&IPM);\n              if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n            }\n            attr = attrPack->AttPackGetAttribute(\"InternalInitializePhaseMap\", ESMC_ATTNEST_ON);\n            if (attr != NULL && Attribute::isSet(attr)) {\n              localrc = attr->get(&IIPM);\n              if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n            }\n            attr = attrPack->AttPackGetAttribute(\"RunPhaseMap\", ESMC_ATTNEST_ON);\n            if (attr != NULL && Attribute::isSet(attr)) {\n              localrc = attr->get(&RPM);\n              if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n            }\n            attr = attrPack->AttPackGetAttribute(\"FinalizePhaseMap\", ESMC_ATTNEST_ON);\n            if (attr != NULL && Attribute::isSet(attr)) {\n              localrc = attr->get(&FPM);\n              if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n            }\n          }\n        }\n        TraceEventComponentInfo(&localvmid, &baseid, compName, IPM, IIPM, RPM, FPM);\n      }\n\n      int methodid = MethodToEnum(*method);\n      if (methodid >= 0) {\n\n        VM *vm;\n        localrc = comp->getVm(&vm);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        VMId *vmid = vm->getVMId(&localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        int localvmid = TraceMapVmId(vmid, &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        ESMC_Base *base;\n        localrc = comp->getBase(&base);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n        int baseid = base->ESMC_BaseGetID();\n\n        TraceEventPhaseExit(&localvmid, &baseid, &methodid, phase, &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        //printf(\"CompPhaseExit: vmid=%d, bid=%d, method=%d, phase=%d\\n\", localvmid, baseid, methodid, *phase);\n      }\n    }\n\n    if (rc!=NULL) *rc=ESMF_SUCCESS;\n\n  }\n\n\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI:TraceEventPhaseExit()\"\n  void TraceEventPhaseExit(int *ep_vmid, int *ep_baseid, int *ep_method, int *ep_phase, int *rc) {\n\n    if (traceLocalPet || profileLocalPet) {\n\n      TraceClockLatch(traceCtx);\n\n      uint16_t local_id = 0;\n      ESMFPhaseId phaseId(ESMFId(*ep_vmid, *ep_baseid), *ep_method, *ep_phase);\n      bool present = phaseRegionMap.get(phaseId, local_id);  /* should always be present */\n      if (!present) {\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,\n                                    \"Trace region not properly nested\", ESMC_CONTEXT, rc);\n        TraceClockUnlatch(traceCtx);\n        return;\n      }\n\n      if (currentRegionNode == NULL) {\n\tESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,\n\t\t\t\t      \"Trace regions not properly nested\", ESMC_CONTEXT, rc);\n\tTraceClockUnlatch(traceCtx);\n\treturn;\n      }\n      else if (currentRegionNode->getLocalId() != local_id) {\n        stringstream errMsg;\n        errMsg << \"Trace regions not properly nested exiting from region: \";\n        errMsg << getRegionNameFromId(local_id);\n        errMsg << \" Expected exit from: \";\n        errMsg << getRegionNameFromId(currentRegionNode->getLocalId());\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG, errMsg.str().c_str(), ESMC_CONTEXT, rc);\n\tTraceClockUnlatch(traceCtx);\n\treturn;\n      }\n\n      if (traceLocalPet) {\n        esmftrc_default_trace_regionid_exit(esmftrc_platform_get_default_ctx(),\n                                            currentRegionNode->getGlobalId());\n      }\n\n      currentRegionNode->exited(traceCtx->latch_ts);\n      currentRegionNode = currentRegionNode->getParent();\n\n      TraceClockUnlatch(traceCtx);\n    }\n\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n\n   }\n\n  void TraceEventPhasePrologueEnter(int *ep_vmid, int *ep_baseid, int *ep_method, int *ep_phase) {\n    if (!traceLocalPet) return;\n    esmftrc_default_trace_prologue_enter(esmftrc_platform_get_default_ctx(),\n                                         *ep_vmid, *ep_baseid, *ep_method, *ep_phase);\n  }\n\n  void TraceEventPhaseEpilogueExit(int *ep_vmid, int *ep_baseid, int *ep_method, int *ep_phase) {\n    if (!traceLocalPet) return;\n    esmftrc_default_trace_epilogue_exit(esmftrc_platform_get_default_ctx(),\n                                        *ep_vmid, *ep_baseid, *ep_method, *ep_phase);\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventRegionEnter()\"\n  void TraceEventRegionEnter(std::string name, int *rc) {\n\n    if (traceLocalPet || profileLocalPet) {\n\n      uint16_t local_id = 0;\n      bool present = userRegionMap.get(name, local_id);\n      if (!present) {\n        local_id = next_local_id();\n        userRegionMap.put(name, local_id);\n      }\n\n      if (currentRegionNode == NULL) {\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,\n                                      \"Trace regions not properly nested\", ESMC_CONTEXT, rc);\n        return;\n      }\n\n      bool added;\n      currentRegionNode = currentRegionNode->getOrAddChild(local_id, true, added);\n\n      //add region to trace output\n      if (added && (traceLocalPet || profileOutputToBinary)) {\n        esmftrc_default_trace_define_region(esmftrc_platform_get_default_ctx(),\n                                            currentRegionNode->getGlobalId(),\n                                            TRACE_REGIONTYPE_USER,\n                                            0, 0, 0, 0,\n                                            name.c_str());\n      }\n\n      TraceClockLatch(traceCtx);  /* lock in time on clock */\n      currentRegionNode->entered(traceCtx->latch_ts);\n\n      if (traceLocalPet) {\n        esmftrc_default_trace_regionid_enter(esmftrc_platform_get_default_ctx(),\n                                             currentRegionNode->getGlobalId());\n      }\n      TraceClockUnlatch(traceCtx);\n\n    }\n\n    if (rc != NULL) *rc = ESMF_SUCCESS;\n\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventRegionExit()\"\n  void TraceEventRegionExit(std::string name, int *rc) {\n\n    if (traceLocalPet || profileLocalPet) {\n      TraceClockLatch(traceCtx);\n      uint16_t local_id = 0;\n      bool present = userRegionMap.get(name, local_id);\n      if (!present) {\n        stringstream errMsg;\n        errMsg << \"Trace regions not properly nested. Attempt to exit region: \";\n        errMsg << name << \" that was never entered.\";\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG, errMsg.str().c_str(), ESMC_CONTEXT, rc);\n        TraceClockUnlatch(traceCtx);\n        return;\n      }\n\n      if (currentRegionNode == NULL) {\n        stringstream errMsg;\n        errMsg << \"Trace regions not properly nested when attempting to exit region: \";\n        errMsg << name << \".\";\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG, errMsg.str().c_str(), ESMC_CONTEXT, rc);\n\tTraceClockUnlatch(traceCtx);\n\treturn;\n      }\n      else if (currentRegionNode->getLocalId() != local_id) {\n        stringstream errMsg;\n        errMsg << \"Trace regions not properly nested exiting from region: \";\n        errMsg << getRegionNameFromId(local_id);\n        errMsg << \" Expected exit from: \";\n        errMsg << getRegionNameFromId(currentRegionNode->getLocalId());\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG, errMsg.str().c_str(), ESMC_CONTEXT, rc);\n\tTraceClockUnlatch(traceCtx);\n\treturn;\n      }\n\n      if (traceLocalPet) {\n        esmftrc_default_trace_regionid_exit(esmftrc_platform_get_default_ctx(),\n                                            currentRegionNode->getGlobalId());\n      }\n\n      currentRegionNode->exited(traceCtx->latch_ts);\n      currentRegionNode = currentRegionNode->getParent();\n\n      TraceClockUnlatch(traceCtx);\n    }\n\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n\n  }\n\n  //IPDv00p1=6||IPDv00p2=7||IPDv00p3=4||IPDv00p4=5\n  static void UpdateComponentInfoMap(vector<string> phaseMap, ESMFId esmfId, int method, string compName) {\n    ComponentInfo *ci = NULL;\n    bool present = componentInfoMap.get(esmfId, ci);\n    if (!present) {\n      ci = new ComponentInfo(esmfId, compName);\n      componentInfoMap.put(esmfId, ci);\n    }\n    if (ci !=NULL) {\n      for (unsigned i = 0; i < phaseMap.size(); i++) {\n        vector<string> phase = split(trim(phaseMap.at(i)), \"=\");\n        if (phase.size() == 2) {\n          int phasenum = -1;\n          stringstream ss(trim(phase.at(1)));\n          ss >> phasenum;\n          if(!(ss.fail())) {\n            ci->setPhaseName(ESMFPhaseId(esmfId, method, phasenum), phase.at(0));\n            //std::cout << \"Added region: \" + compName + \", \" + phase.at(0) + \"\\n\";\n          }\n        }\n      }\n    }\n  }\n\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::join\"\n  static string join(vector<string> v) {\n    string ret(\"\");\n    for (size_t i=0; i<v.size(); i++) {\n      if(ret.size() > 0) ret.append(\"||\");\n      ret.append(v.at(i));\n    }\n    return ret;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventComponentInfo()\"\n  void TraceEventComponentInfo(int *ep_vmid, int *ep_baseid,\n                               const char *ep_name,\n                               vector<string> IPM, vector<string> IIPM,\n                               vector<string> RPM, vector<string> FPM) {\n\n    if (traceLocalPet || profileOutputToBinary) {\n      string strIPM = join(IPM);\n      string strRPM = join(RPM);\n      string strFPM = join(FPM);\n      esmftrc_default_trace_comp(esmftrc_platform_get_default_ctx(),\n                                 *ep_vmid, *ep_baseid, ep_name,\n                                 strIPM.c_str(), strRPM.c_str(), strFPM.c_str());\n    }\n\n    if (profileLocalPet) {\n      string compName(ep_name);\n      ESMFId esmfId(*ep_vmid, *ep_baseid);\n      UpdateComponentInfoMap(IPM, esmfId, 0, compName);\n      UpdateComponentInfoMap(IIPM, esmfId, 0, compName);\n      UpdateComponentInfoMap(RPM, esmfId, 1, compName);\n      UpdateComponentInfoMap(FPM, esmfId, 2, compName);\n    }\n\n  }\n\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventMemInfo()\"\n  void TraceEventMemInfo() {\n\n    if (!traceLocalPet) return;\n\n    int localrc;\n    VM *globalvm = VM::getGlobal(&localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n          ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &localrc))\n      return;\n\n    int virtMem = -1;\n    int physMem = -1;\n    globalvm->getMemInfo(&virtMem, &physMem);\n\n    esmftrc_default_trace_mem(esmftrc_platform_get_default_ctx(),\n                              virtMem, physMem);\n\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventClock()\"\n  void TraceEventClock(int *ep_year, int *ep_month, int *ep_day,\n                       int *ep_hour, int *ep_minute, int *ep_second) {\n\n    if (!traceLocalPet) return;\n\n    esmftrc_default_trace_clk(esmftrc_platform_get_default_ctx(),\n                              *ep_year, *ep_month, *ep_day,\n                              *ep_hour, *ep_minute, *ep_second);\n\n  }\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Superstructure/Component/src/ESMCI_MethodTable.C": "// $Id$\n//\n// Earth System Modeling Framework\n// Copyright 2002-2020, University Corporation for Atmospheric Research, \n// Massachusetts Institute of Technology, Geophysical Fluid Dynamics \n// Laboratory, University of Michigan, National Centers for Environmental \n// Prediction, Los Alamos National Laboratory, Argonne National Laboratory, \n// NASA Goddard Space Flight Center.\n// Licensed under the University of Illinois-NCSA License.\n//\n//==============================================================================\n#define ESMC_FILENAME \"ESMCI_MethodTable.C\"\n//==============================================================================\n//\n// ESMCI MethodTable implementation (body) file\n//\n//-----------------------------------------------------------------------------\n//\n// !DESCRIPTION:\n//\n// The code in this file implements the C++ {\\tt MethodTable} methods \n// declared in the companion file {\\tt ESMCI\\_MethodTable.h}.  \n//\n//-----------------------------------------------------------------------------\n// include associated header file\n#include \"ESMCI_MethodTable.h\"\n\n// insert higher level, 3rd party or system includes\n#include <string>\n#include <sstream>\n#ifndef ESMF_NO_DLFCN\n#include <dlfcn.h>\n#endif\n\n// include ESMF headers\n#include \"ESMCI_Macros.h\"\n#include \"ESMCI_LogErr.h\"\n\n//==============================================================================\n//==============================================================================\n// MethodTable class implementation\n//==============================================================================\n//==============================================================================\n\nextern \"C\" {\n\n  // call to native class constructor\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtablecreate\"\n  void FTN_X(c_esmc_methodtablecreate)(ESMCI::MethodTable **ptr, int *rc){\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    (*ptr) = new ESMCI::MethodTable;\n    if (*ptr == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- MethodTable allocation\", ESMC_CONTEXT, \n        rc);  \n      return;\n    }\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // call to native class destructor\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtabledestroy\"\n  void FTN_X(c_esmc_methodtabledestroy)(ESMCI::MethodTable **ptr, int *rc){\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (*ptr == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- MethodTable deallocation\", ESMC_CONTEXT,\n        rc);  \n      return;\n    }\n    delete (*ptr);\n    *ptr = NULL;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtableadd\"\n  void FTN_X(c_esmc_methodtableadd)(ESMCI::MethodTable **ptr,\n    char const *labelArg, int *index, void *pointer, int *rc,\n    ESMCI_FortranStrLenArg labelLen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (labelLen>=0){\n      std::string label(labelArg, labelLen);\n      label.resize(label.find_last_not_of(\" \")+1);\n      if (index){\n        std::stringstream indexString;\n        indexString << \"::ESMF::index::\" << *index;\n        label += indexString.str();\n      }\n      localrc = (*ptr)->add(label, pointer);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- corrupt label string\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    // debugging---------\n//    localrc = (*ptr)->print();\n//    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n//    rc)) \n//      return;\n    // debugging---------\n    \n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtableaddshobj\"\n  void FTN_X(c_esmc_methodtableaddshobj)(ESMCI::MethodTable **ptr,\n    char const *labelArg, int *index, char const *nameArg,\n    char const *sharedObjArg,\n    int *rc, ESMCI_FortranStrLenArg labelLen, ESMCI_FortranStrLenArg nameLen,\n    ESMCI_FortranStrLenArg sharedObjLen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (labelLen>=0){\n      std::string label(labelArg, labelLen);\n      label.resize(label.find_last_not_of(\" \")+1);\n      if (index){\n        std::stringstream indexString;\n        indexString << \"::ESMF::index::\" << *index;\n        label += indexString.str();\n      }\n      std::string name(nameArg, nameLen);\n      name.resize(name.find_last_not_of(\" \")+1);\n      std::string sharedObj(sharedObjArg, sharedObjLen);\n      sharedObj.resize(sharedObj.find_last_not_of(\" \")+1);\n      localrc = (*ptr)->add(label, name, sharedObj);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- corrupt label string\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    // debugging---------\n//    localrc = (*ptr)->print();\n//    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n//    rc)) \n//      return;\n    // debugging---------\n    \n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtableremove\"\n  void FTN_X(c_esmc_methodtableremove)(ESMCI::MethodTable **ptr,\n    char const *labelArg, int *index, int *rc, ESMCI_FortranStrLenArg labelLen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (labelLen>=0){\n      std::string label(labelArg, labelLen);\n      label.resize(label.find_last_not_of(\" \")+1);\n      if (index){\n        std::stringstream indexString;\n        indexString << \"::ESMF::index::\" << *index;\n        label += indexString.str();\n      }\n      localrc = (*ptr)->remove(label);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- corrupt label string\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    // debugging---------\n//    localrc = (*ptr)->print();\n//    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n//    rc)) \n//     return;\n    // debugging---------\n    \n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtableexecute\"\n  void FTN_X(c_esmc_methodtableexecute)(ESMCI::MethodTable **ptr,\n    char const *labelArg, int *index, void *object, int *userRc, int *rc,\n    ESMCI_FortranStrLenArg labelLen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (labelLen>=0){\n      std::string label(labelArg, labelLen);\n      label.resize(label.find_last_not_of(\" \")+1);\n      if (index){\n        std::stringstream indexString;\n        indexString << \"::ESMF::index::\" << *index;\n        label += indexString.str();\n      }\n      localrc = (*ptr)->execute(label, object, userRc);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- corrupt label string\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    // debugging---------\n//    localrc = (*ptr)->print();\n//    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n//    rc)) \n//      return;\n    // debugging---------\n    \n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtableexecuteef\"\n  void FTN_X(c_esmc_methodtableexecuteef)(ESMCI::MethodTable **ptr,\n    char const *labelArg, int *index, void *object, ESMC_Logical *existflag,\n    int *userRc, int *rc,\n    ESMCI_FortranStrLenArg labelLen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (labelLen>=0){\n      bool existing;\n      std::string label(labelArg, labelLen);\n      label.resize(label.find_last_not_of(\" \")+1);\n      if (index){\n        std::stringstream indexString;\n        indexString << \"::ESMF::index::\" << *index;\n        label += indexString.str();\n      }\n      localrc = (*ptr)->execute(label, object, userRc, &existing);\n      if (existing)\n        *existflag = ESMF_TRUE;\n      else\n        *existflag = ESMF_FALSE;\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- corrupt label string\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    // debugging---------\n//    localrc = (*ptr)->print();\n//    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n//    rc)) \n//      return;\n    // debugging---------\n    \n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n} // extern \"C\"\n\n\n\nnamespace ESMCI {\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodElement::print()\"\n  int MethodElement::print(void)const{\n    int rc = ESMC_RC_NOT_IMPL;\n    printf(\"%s\\n\", label.c_str());\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodElement::execute()\"\n  int MethodElement::execute(void *object, int *userRc){\n    int rc = ESMC_RC_NOT_IMPL;\n    if (pointer){\n      typedef void (*FuncP)(void *, int *);\n      FuncP vf = (FuncP)pointer;\n      (*vf)(object, userRc);\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_PTR_NULL,\n        \" - invalid function pointer\", ESMC_CONTEXT, &rc);\n      return rc;\n      \n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodElement::resolve()\"\n  int MethodElement::resolve(void){\n    int rc = ESMC_RC_NOT_IMPL;\n#ifdef ESMF_NO_DLFCN\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_LIB, \n      \"- System does not support dynamic loading.\", ESMC_CONTEXT, &rc);\n    return rc;\n#else\n    void *lib;\n    if (shobj.length()>0)\n      lib = dlopen(shobj.c_str(), RTLD_LAZY);\n    else\n      lib = dlopen(NULL, RTLD_LAZY);  // search in executable\n    if (lib == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"shared object not found\", ESMC_CONTEXT, &rc);\n      return rc;\n    }\n    pointer = (void *)dlsym(lib, name.c_str());\n    if (pointer == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- named routine not found\", ESMC_CONTEXT, &rc);\n      return rc;\n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n#endif\n  }\n  \n// -----------------------------------------------------------------------------\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodTable::print()\"\n  int MethodTable::print(void)const{\n    int localrc = ESMC_RC_NOT_IMPL;\n    int rc = ESMC_RC_NOT_IMPL;\n    MethodElement *element = table; // initialize\n    while (element){\n      localrc = element->print();\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, &rc)) return rc; // bail out\n      element = element->nextElement;\n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodTable::add()\"\n  int MethodTable::add(std::string labelArg, void *pointer){\n    int rc = ESMC_RC_NOT_IMPL;\n    if (table){\n      MethodElement *element = table; // initialize\n      MethodElement *prev;\n      while (element){\n        if (element->label == labelArg){\n          ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n            \"- method with identical label already exists\", ESMC_CONTEXT, &rc);\n          return rc;\n        }\n        prev = element;\n        element = element->nextElement;\n      }\n      prev->nextElement = new MethodElement(labelArg, pointer);\n    }else{\n      table = new MethodElement(labelArg, pointer);\n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodTable::add()\"\n  int MethodTable::add(std::string labelArg, std::string name,\n    std::string sharedObj){\n    int localrc = ESMC_RC_NOT_IMPL;\n    int rc = ESMC_RC_NOT_IMPL;\n    MethodElement *element = table; // initialize\n    if (table){\n      MethodElement *prev;\n      while (element){\n        if (element->label == labelArg){\n          ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n            \"- method with identical label already exists\", ESMC_CONTEXT, &rc);\n          return rc;\n        }\n        prev = element;\n        element = element->nextElement;\n      }\n      prev->nextElement = new MethodElement(labelArg, name, sharedObj);\n      element = prev->nextElement;\n    }else{\n      table = new MethodElement(labelArg, name, sharedObj);\n      element = table;\n    }\n    localrc = element->resolve();\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      &rc)) return rc; // bail out\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodTable::remove()\"\n  int MethodTable::remove(std::string labelArg){\n    int rc = ESMC_RC_NOT_IMPL;\n    if (table){\n      MethodElement *element = table; // initialize\n      MethodElement *prev = table;  // initialize\n      while (element){\n        if (element->label == labelArg){\n          if (element == table)\n            table = element->nextElement;\n          else\n            prev->nextElement = element->nextElement;\n          delete element;\n          // return successfully\n          rc = ESMF_SUCCESS;\n          return rc;\n        }\n        prev = element;\n        element = element->nextElement;\n      }\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- method not found in method table\", ESMC_CONTEXT, &rc);\n      return rc;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- empty method table\", ESMC_CONTEXT, &rc);\n      return rc;\n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodTable::execute()\"\n  int MethodTable::execute(std::string labelArg, void *object, int *userRc,\n    bool *existflag){\n    int localrc = ESMC_RC_NOT_IMPL;\n    int rc = ESMC_RC_NOT_IMPL;\n    if (table){\n      MethodElement *element = table; // initialize\n      while (element){\n        if (element->label == labelArg){\n          if (existflag) *existflag = true;\n          localrc = element->execute(object, userRc);\n          if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n            ESMC_CONTEXT, &rc)) return rc; // bail out\n          // return successfully\n          rc = ESMF_SUCCESS;\n          return rc;\n        }\n        element = element->nextElement;\n      }\n      if (existflag){\n        *existflag = false;\n        if (userRc) *userRc = ESMF_SUCCESS;\n      }else{\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n          \"- method not found in method table\", ESMC_CONTEXT, &rc);\n        return rc;\n      }\n    }else{\n      if (existflag){\n        *existflag = false;\n        if (userRc) *userRc = ESMF_SUCCESS;\n      }else{\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n          \"- empty method table\", ESMC_CONTEXT, &rc);\n        return rc;\n      }\n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n  \n} // namespace ESMCI\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Superstructure/Component/src/ESMCI_FTable.C": "// $Id$\n//\n// Earth System Modeling Framework\n// Copyright 2002-2020, University Corporation for Atmospheric Research,\n// Massachusetts Institute of Technology, Geophysical Fluid Dynamics\n// Laboratory, University of Michigan, National Centers for Environmental\n// Prediction, Los Alamos National Laboratory, Argonne National Laboratory,\n// NASA Goddard Space Flight Center.\n// Licensed under the University of Illinois-NCSA License.\n//\n//==============================================================================\n#define ESMC_FILENAME \"ESMCI_FTable.C\"\n//==============================================================================\n//\n// ESMCI Function table implementation (body) file\n//\n//-----------------------------------------------------------------------------\n//\n// !DESCRIPTION:\n//\n// The code in this file implements the C++ {\\tt Function Table} methods\n// declared in the companion file {\\tt ESMCI\\_FTable.h}.\n//\n//-----------------------------------------------------------------------------\n// include associated header file\n#include \"ESMCI_FTable.h\"\n\n// insert higher level, 3rd party or system includes\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#ifndef ESMF_NO_DLFCN\n#include <dlfcn.h>\n#endif\n\n// include ESMF headers\n#include \"ESMCI_Base.h\"\n#include \"ESMCI_Comp.h\"\n#include \"ESMCI_CompTunnel.h\"\n#include \"ESMCI_LogErr.h\"\n#include \"ESMCI_TraceRegion.h\"\n\nusing std::string;\n\n//-----------------------------------------------------------------------------\n// leave the following line as-is; it will insert the cvs ident string\n// into the object file for tracking purposes.\nstatic const char *const version = \"$Id$\";\n//-----------------------------------------------------------------------------\n\n\n//==============================================================================\n// prototypes for Fortran interface routines called by C++ code below\n//TODO: eventually move these calls into the ESMCI::Comp class\nextern \"C\" {\n  void FTN_X(f_esmf_compsetvminfo)(ESMCI::Comp *compp, void *vm_info, int *rc);\n  void FTN_X(f_esmf_compresetvmreleased)(ESMCI::Comp *compp, int *rc);\n  void FTN_X(f_esmf_compinsertvm)(ESMCI::Comp *compp, void *vm, int *rc);\n  void FTN_X(f_esmf_compgetctype)(ESMCI::Comp *compp, ESMCI::CompType *ctype,\n    int *rc);\n  void FTN_X(f_esmf_compreplicate)(ESMCI::Comp *compp, ESMCI::Comp *compp_src,\n    void *vm, int *rc);\n  void FTN_X(f_esmf_comprefcopy)(ESMCI::Comp *compp, ESMCI::Comp *compp_src,\n    int *rc);\n  void FTN_X(f_esmf_compdelete)(ESMCI::Comp *compp, int *rc);\n\n  void FTN_X(f_esmf_fortranudtpointersize)(int *size);\n  void FTN_X(f_esmf_fortranudtpointercopy)(void *dst, void *src);\n\n  void FTN_X(esmf_complianceicregister)(void *comp, int *rc);\n\n#ifdef ESMF_NO_DLFCN\n  //for now, assume these are here in the case that dlopen is not available\n  void FTN_X(nuopc_model_complianceicr)(void *comp, int *rc);\n  void FTN_X(nuopc_driver_complianceicr)(void *comp, int *rc);\n  void FTN_X(nuopc_connector_complianceicr)(void *comp, int *rc);\n#endif\n}\n//==============================================================================\n\n\n\n//==============================================================================\n// FTable interfaces to be called from Fortran side (ESMF_Comp.F90)\n//\n// these interface subroutine names MUST be in lower case\n//\nextern \"C\" {\n\n  // call to native class constructor\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftablecreate\"\n  void FTN_X(c_esmc_ftablecreate)(ESMCI::FTable **ptr, int *rc) {\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    (*ptr) = new ESMCI::FTable;\n    if (*ptr == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- Ftable allocation\", ESMC_CONTEXT, rc);\n      return;\n    }\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // call to native class destructor\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftabledestroy\"\n  void FTN_X(c_esmc_ftabledestroy)(ESMCI::FTable **ptr, int *rc) {\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (*ptr == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- Ftable deallocation\", ESMC_CONTEXT, rc);\n      return;\n    }\n    delete (*ptr);\n    *ptr = NULL;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // set arguments for standard Component methods\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftablesetstateargs\"\n  void FTN_X(c_esmc_ftablesetstateargs)(ESMCI::FTable **ptr,\n    enum ESMCI::method *method, int *phase, void *comp,\n    ESMCI::State *importState, ESMCI::State *exportState, ESMCI::Clock **clock,\n    ESMCI::CompTunnel **compTunnel, int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    if (*compTunnel != NULL){\n      // this is a dual component which contains a valid actual component object\n      // -> set references to the passed in arguments and return\n      (*compTunnel)->setMethod(*method);\n      (*compTunnel)->setPhase(*phase);\n      (*compTunnel)->setImportState(importState);\n      (*compTunnel)->setExportState(exportState);\n      (*compTunnel)->setClock(clock);\n\n    }else{\n      // this is not a dual component, thus do the actual ftable encoding\n\n      char const *methodString = ESMCI::FTable::methodString(*method);\n\n      int slen = strlen(methodString);\n      char *fname;\n      ESMCI::FTable::newtrim(methodString, slen, phase, NULL, &fname);\n      //printf(\"after newtrim, name = '%s'\\n\", fname);\n\n      void *alist[4];\n      alist[0] = (void *)comp;\n      alist[1] = (void *)importState;\n      alist[2] = (void *)exportState;\n      alist[3] = (void *)clock;\n\n      ESMCI::FTable *ftable = *ptr; // incoming FTable\n\n      // only if the incoming FTable contains PET-local component copies\n      for (int i=0; i<ftable->componentcount; i++){\n        ESMCI::Comp *comp = ftable->component + i;      // component copy\n        ESMCI::FTable *ft = **(ESMCI::FTable ***)comp;  // assoc. FTable\n        localrc = ft->setFuncArgs(fname, 4, alist);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n          ESMC_CONTEXT, rc)) return;\n      }\n\n      delete[] fname;  // delete memory that \"newtrim\" allocated above\n    }\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // set the InternalState in FTable\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftablesetinternalstate\"\n  void FTN_X(c_esmc_ftablesetinternalstate)(ESMCI::FTable ***ptr,\n    char const *type, void **data, enum ESMCI::dtype *dtype, int *rc,\n    ESMCI_FortranStrLenArg slen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    char *name;\n    ESMCI::FTable::newtrim(type, slen, NULL, NULL, &name);\n    //printf(\"after newtrim, name = '%s'\\n\", name);\n\n    localrc = (**ptr)->setDataPtr(name, data, *dtype);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n\n    delete[] name;  // delete memory that \"newtrim\" allocated above\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // get the InternalState from FTable\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftablegetinternalstate\"\n  void FTN_X(c_esmc_ftablegetinternalstate)(ESMCI::FTable ***ptr,\n    char const *type, void **data, enum ESMCI::dtype *dtype, int *rc,\n      ESMCI_FortranStrLenArg slen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    char *name;\n    ESMCI::FTable::newtrim(type, slen, NULL, NULL, &name);\n    //printf(\"after newtrim, name = '%s'\\n\", name);\n\n    localrc = (**ptr)->getDataPtr(name, data, dtype);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n\n    delete[] name;  // delete memory that \"newtrim\" allocated above\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setvm\"\n  void FTN_X(c_esmc_setvm)(void *ptr, void (*func)(), int *userRc, int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setVM(ptr, func, userRc, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setvmshobj\"\n  void FTN_X(c_esmc_setvmshobj)(void *ptr, char const *routineArg,\n    char const *sharedObjArg, int *userRc, int *rc,\n    ESMCI_FortranStrLenArg rlen, ESMCI_FortranStrLenArg llen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n#ifdef ESMF_NO_DLFCN\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_LIB,\n      \"- System does not support dynamic loading.\", ESMC_CONTEXT, rc);\n    return;\n#else\n    void *lib;\n    if (llen>0){\n      string sharedObj(sharedObjArg, llen);\n      sharedObj.resize(sharedObj.find_last_not_of(\" \")+1);\n      lib = dlopen(sharedObj.c_str(), RTLD_LAZY);\n    }else\n      lib = dlopen(NULL, RTLD_LAZY);  // search in executable\n    if (lib == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"shared object not found\", ESMC_CONTEXT, rc);\n      return;\n    }\n    string routine(routineArg, rlen);\n    routine.resize(routine.find_last_not_of(\" \")+1);\n    void (*func)() = (void (*)())dlsym(lib, routine.c_str());\n    if ((void *)func == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"routine not found\", ESMC_CONTEXT, rc);\n      return;\n    }\n    ESMCI::FTable::setVM(ptr, func, userRc, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n#endif\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setservices\"\n  void FTN_X(c_esmc_setservices)(void *ptr, void (*func)(), int *userRc, int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setServices(ptr, func, userRc, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setservicesshobj\"\n  void FTN_X(c_esmc_setservicesshobj)(void *ptr, char const *routineArg,\n    char const *sharedObjArg, ESMC_Logical *foundRoutine, int *userRc, int *rc,\n    ESMCI_FortranStrLenArg rlen, ESMCI_FortranStrLenArg llen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n#ifdef ESMF_NO_DLFCN\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_LIB,\n      \"- System does not support dynamic loading.\", ESMC_CONTEXT, rc);\n    return;\n#else\n    *foundRoutine = ESMF_FALSE; // initialize\n    void *lib;\n    if (llen>0){\n      string sharedObj(sharedObjArg, llen);\n      sharedObj.resize(sharedObj.find_last_not_of(\" \")+1);\n      lib = dlopen(sharedObj.c_str(), RTLD_LAZY);\n    }else\n      lib = dlopen(NULL, RTLD_LAZY);  // search in executable\n    if (lib == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"shared object not found\", ESMC_CONTEXT, rc);\n      return;\n    }\n    string routine(routineArg, rlen);\n    routine.resize(routine.find_last_not_of(\" \")+1);\n    void (*func)() = (void (*)())dlsym(lib, routine.c_str());\n    if ((void *)func != NULL){\n      // Routine was found\n      *foundRoutine = ESMF_TRUE;\n      ESMCI::FTable::setServices(ptr, func, userRc, &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n        rc)) return;\n    }\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n#endif\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setservicescomp\"\n  void FTN_X(c_esmc_setservicescomp)(ESMCI::Comp *dualComp,\n    ESMCI::CompTunnel **compTunnel, ESMCI::Comp *localActualComp,\n    int *localActualCompRootPet, int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (*compTunnel != NULL){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n    }\n    // The compTunnel object must be created on all the PETs that execute\n    // this routine, which are potentially all parent PETs, not just those\n    // that eventually enter the child VM. This is so that all child component\n    // objects that exist on the parent VM with a valid entry of a child VM\n    // also have a valid compTunnel member.\n    *compTunnel = new ESMCI::CompTunnel(localActualComp,\n      *localActualCompRootPet);\n    if (*compTunnel == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- CompTunnel allocation\", ESMC_CONTEXT, rc);\n      return; // bail out\n    }\n    // call into setServices with the internal CompTunnel::SetServices wrapper\n    int userRc;\n    localrc =dualComp->setServices(ESMCI::CompTunnel::setServicesWrap, &userRc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n      return; // bail out\n    }\n    if (ESMC_LogDefault.MsgFoundError(userRc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n      return; // bail out on userRc b/c setServicesWrap is an internal routine\n    }\n\n    // Now that everything has returned successfully, mark the tunnel as\n    // connected.\n    // This must be done up on this level, so that _all_ PETs that call into\n    // SetServices() have the tunnel set to connected.\n    (*compTunnel)->setConnected(true);\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setservicessock\"\n  void FTN_X(c_esmc_setservicessock)(ESMCI::Comp *dualComp,\n    ESMCI::CompTunnel **compTunnel, int *port, char const *serverArg,\n    int *timeout, int *rc, ESMCI_FortranStrLenArg len){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (*compTunnel != NULL){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n    }\n    if (*port<1024 || *port>65535){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"- The port argument is outside valid range [1024, 65535]\",\n        ESMC_CONTEXT, rc);\n      return;\n    }\n    // server name\n    string server(serverArg, len);\n    // The compTunnel object must be created on all the PETs that execute\n    // this routine, which are potentially all parent PETs, not just those\n    // that eventually enter the child VM. This is so that all child component\n    // objects that exist on the parent VM with a valid entry of a child VM\n    // also have a valid compTunnel member.\n    *compTunnel = new ESMCI::CompTunnel(*port, server);\n    if (*compTunnel == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- CompTunnel allocation\", ESMC_CONTEXT, rc);\n      return; // bail out\n    }\n    (*compTunnel)->setTimeout(*timeout);  // set dual side timeout for setServ.\n    // call into setServices with the internal CompTunnel::SetServices wrapper\n    int userRc;\n    localrc =dualComp->setServices(ESMCI::CompTunnel::setServicesWrap, &userRc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n      return; // bail out\n    }\n    // CompTunnel::setServicesWrap() is a framework internal method, therefore\n    // the code returned in userRc is a framework internal return code and must\n    // be treated as such.\n    // Do not filter the RC_TIMEOUT at this level, since a timeout needs to\n    // bail out until it gets to the upper ESMF level, right before returning\n    // to the user, where the filtering is done according to the presence of\n    // a timeoutFlag argument.\n    if (ESMC_LogDefault.MsgFoundError(userRc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n      return; // bail out on userRc b/c setServicesWrap is an internal routine\n    }\n\n    // Now that everything has returned successfully, mark the tunnel as\n    // connected.\n    // This must be done up on this level, so that _all_ PETs that call into\n    // SetServices() have the tunnel set to connected.\n    (*compTunnel)->setConnected(true);\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setentrypoint\"\n  void FTN_X(c_esmc_setentrypoint)(void *ptr, enum ESMCI::method *method,\n    void *func, int *phase, int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    char const *methodString = ESMCI::FTable::methodString(*method);\n\n    int slen = strlen(methodString);\n    char *fname;\n    ESMCI::FTable::newtrim(methodString, slen, phase, NULL, &fname);\n\n    ESMCI::FTable *tabptr = **(ESMCI::FTable***)ptr;\n    localrc = (tabptr)->setFuncPtr(fname, func, ESMCI::FT_VOIDP4INTP);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n\n    delete[] fname;  // delete memory that \"newtrim\" allocated above\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_getentrypointphasecount\"\n  void FTN_X(c_esmc_getentrypointphasecount)(void *ptr,\n    enum ESMCI::method *method, int *phaseCount, ESMC_Logical *phaseZeroFlag,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    char const *methodString = ESMCI::FTable::methodString(*method);\n\n    ESMCI::FTable *tabptr = **(ESMCI::FTable***)ptr;\n\n    int slen = strlen(methodString);\n    int phase = 0;  // initialize\n    int i;\n\n    *phaseZeroFlag = ESMF_FALSE; // initialize\n\n    char *fname;\n    ESMCI::FTable::newtrim(methodString, slen, &phase, NULL, &fname);\n    i = tabptr->getEntry(fname, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return; // bail out\n    delete[] fname;  // delete memory that \"newtrim\" allocated above\n    if (i != -1)\n      *phaseZeroFlag = ESMF_TRUE;  // set the flag\n\n    do{\n      ++phase;\n      ESMCI::FTable::newtrim(methodString, slen, &phase, NULL, &fname);\n\n      i = tabptr->getEntry(fname, &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return; // bail out\n\n      delete[] fname;  // delete memory that \"newtrim\" allocated above\n\n    }while (i != -1);\n\n    *phaseCount = phase - 1;\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n} // extern \"C\"\n//==============================================================================\n\n\n//==============================================================================\n// these functions have no leading c_ and are ESMF and not ESMC because\n// they're intended to be called directly by F90 user code.\n//\n// also note they CANNOT have prototypes in fortran because the routine\n// types and data types are private/different for each call so there\n// is no correct prototype syntax which will work.\n//\n// and finally, note that they have an extra level of indirection,\n// because the first arg is actually being called with a component\n// pointer - and after one dereference we are at the component derived\n// type.  the second dereference finds the ftable pointer which must\n// be the first entry in the comp derived type.\n//\n// these interface subroutine names MUST be in lower case\nextern \"C\" {\n\n  // ---------- GridComp ---------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_gridcompsetinternalstate\"\n  void FTN_X(esmf_gridcompsetinternalstate)(ESMCI::FTable ***ptr, void **datap,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setDP(ptr, datap, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_gridcompgetinternalstate\"\n  void FTN_X(esmf_gridcompgetinternalstate)(ESMCI::FTable ***ptr, void **datap,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::getDP(ptr, datap, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // ---------- CplComp ---------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_cplcompsetinternalstate\"\n  void FTN_X(esmf_cplcompsetinternalstate)(ESMCI::FTable ***ptr, void **datap,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setDP(ptr, datap, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_cplcompgetinternalstate\"\n  void FTN_X(esmf_cplcompgetinternalstate)(ESMCI::FTable ***ptr, void **datap,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::getDP(ptr, datap, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // ---------- UserComp ---------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_usercompsetvm\"\n  void FTN_X(esmf_usercompsetvm)(void *ptr, void (*func)(), int *userRc,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setVM(ptr, func, userRc, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_usercompsetservices\"\n  void FTN_X(esmf_usercompsetservices)(void *ptr, void (*func)(), int *userRc,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setServices(ptr, func, userRc, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_usercompsetinternalstate\"\n  void FTN_X(esmf_usercompsetinternalstate)(ESMCI::FTable ***ptr,\n    char const *name, void **datap, int *rc,\n    ESMCI_FortranStrLenArg slen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    if ((ptr == ESMC_NULL_POINTER) || (*ptr == ESMC_NULL_POINTER)){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"null pointer found\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    char *tbuf;\n    ESMCI::FTable::newtrim(name, slen, NULL, NULL, &tbuf);\n    //printf(\"after newtrim, name = '%s'\\n\", tbuf);\n\n    enum ESMCI::dtype dtype = ESMCI::DT_FORTRAN_UDT_POINTER;\n    localrc = (**ptr)->setDataPtr(tbuf, datap, dtype);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n\n    delete[] tbuf;\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_usercompgetinternalstate\"\n  void FTN_X(esmf_usercompgetinternalstate)(ESMCI::FTable ***ptr,\n    char const *name, void **datap, int *rc,\n    ESMCI_FortranStrLenArg slen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    if ((ptr == ESMC_NULL_POINTER) || (*ptr == ESMC_NULL_POINTER)){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"null pointer found\", ESMC_CONTEXT,rc);\n      return;\n    }\n\n    char *tbuf;\n    ESMCI::FTable::newtrim(name, slen, NULL, NULL, &tbuf);\n    //printf(\"after newtrim, name = '%s'\\n\", tbuf);\n\n    enum ESMCI::dtype dtype;\n    localrc = (**ptr)->getDataPtr(tbuf, datap, &dtype);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n\n    delete[] tbuf;\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n} // extern \"C\"\n//==============================================================================\n\n\n//==============================================================================\n// VM-enabled CallBack loop\nextern \"C\" {\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI_FTableCallEntryPointVMHop\"\nvoid *ESMCI_FTableCallEntryPointVMHop(void *vm, void *cargoCast){\n  // This routine is the first level that gets instantiated in new VM\n  // The first argument must be of type (void *) and points to a derived\n  // ESMCI::VMK class object. The second argument is also of type (void *)\n  // and points to a cargotype structure.\n\n  // pull out info from cargo\n  ESMCI::cargotype *cargo = (ESMCI::cargotype *)cargoCast;\n  char *name = cargo->name;               // name of callback\n  ESMCI::FTable *ftable = cargo->ftable;  // ptr to ftable\n\n  int localrc;          // local return code\n  int esmfrc;           // ESMF return code of ESMCI::FTable::callVFuncPtr()\n  int userrc = -99999;  // user return code from the registered component method\n\n  // prepare return code members in cargo\n  int mypet = ((ESMCI::VM*)vm)->getMypet();\n  int mynthreads = ((ESMCI::VM*)vm)->getNthreads(mypet);\n  int mytid = ((ESMCI::VM*)vm)->getTid(mypet);\n  if (mytid==0){\n    // master thread -> allocate return code members in cargo for all threads\n    if (cargo->rcCount != mynthreads){\n      delete [] cargo->esmfrc;\n      delete [] cargo->userrc;\n      cargo->esmfrc = new int[mynthreads];\n      cargo->userrc = new int[mynthreads];\n      cargo->rcCount = mynthreads;\n    }\n  }\n  ((ESMCI::VM*)vm)->threadbarrier();  // synchronize all threads in local group\n\n  // get a pointer to the CompTunnel object\n  ESMCI::Comp *f90comp = cargo->f90comp;\n  ESMCI::CompTunnel *compTunnel;\n  localrc = f90comp->getTunnel(&compTunnel);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    &esmfrc)){\n    cargo->esmfrc[mytid] = esmfrc;\n    return NULL;\n  }\n\n  // determine whether this is a dual component that is ready to execute\n  bool dualConnected = false;  // initialize\n  if (compTunnel) dualConnected = compTunnel->isConnected();\n\n  if (dualConnected){\n    // this is a dual component with a compTunnel that is connected\n\n    //TODO: check whether \"name\" is found in dual components ftable. If so then\n    //TODO: consider that an override, and execute dual components method\n    //TODO: instead\n\n    localrc = compTunnel->execute(cargo);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      &esmfrc)){\n      cargo->esmfrc[mytid] = esmfrc;  // put esmf return code into cargo\n      return NULL;\n    }\n\n    // ...the user return code will not be available until wait() is called\n\n  }else{\n\n    TraceEventCompPhaseEnter(f90comp, &(cargo->currentMethod), &(cargo->currentPhase), &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n                                      &esmfrc)){\n      cargo->esmfrc[mytid] = esmfrc;  // put esmf return code into cargo\n      return NULL;\n    }\n    \n    // a regular component or a dual component that needs to connect still,\n    // use the local ftable for user code or system code callback\n    localrc = ftable->callVFuncPtr(name, (ESMCI::VM*)vm, &userrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      &esmfrc)){\n      cargo->esmfrc[mytid] = esmfrc;  // put esmf return code into cargo\n      return NULL;\n    }\n\n    TraceEventCompPhaseExit(f90comp, &(cargo->currentMethod), &(cargo->currentPhase), &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n                                      &esmfrc)){\n      cargo->esmfrc[mytid] = esmfrc;  // put esmf return code into cargo\n      return NULL;\n    }\n\n    // ...back from user code\n    cargo->userrc[mytid] = userrc;  // put the user return code into cargo\n  }\n\n  // return successfully\n  cargo->esmfrc[mytid] = ESMF_SUCCESS;\n  return NULL;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// call a function through VM\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftablecallentrypointvm\"\nvoid FTN_X(c_esmc_ftablecallentrypointvm)(\n  ESMCI::Comp *f90comp,       // pointer to Fortran component object\n  ESMCI::VM **ptr_vm_parent,  // p2 to the parent VM\n  ESMCI::VMPlan **ptr_vmplan, // p2 to the VMPlan for component's VM\n  void **vm_info,             // p2 to member which holds info returned by enter\n  void **vm_cargo,            // p2 to member which holds cargo\n  ESMCI::FTable **ptr,        // p2 to the ftable of this component\n  enum ESMCI::method *method, // method type\n  int *phase,                 // phase selector\n  int *port,                  // port number\n  int *timeout,               // time out in seconds\n  int *recursionCount,        // keeping track of recursion level of component\n  int *rc                     // return code\n  ){\n\n  // local variables\n  int localrc;              // local return code\n  char *name;               // trimmed type string\n\n  // check to make sure VM has really been started up for this Component\n  if (*vm_info == NULL){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_PTR_NULL,\n      \"No VM was started for this Component - missing SetServices() call?\",\n      ESMC_CONTEXT, rc);\n    return; // bail out\n  }\n\n  // Initialize return code; assume routine not implemented\n  if (rc) *rc = ESMC_RC_NOT_IMPL;\n  localrc = ESMC_RC_NOT_IMPL;\n\n  char const *methodString = ESMCI::FTable::methodString(*method);\n\n  int slen = strlen(methodString);\n  ESMCI::FTable::newtrim(methodString, slen, phase, NULL, &name);\n\n  // dereference double pointers to pointers\n  ESMCI::VM *vm_parent  = *ptr_vm_parent;     // pointer to parent VM\n  ESMCI::VMPlan *vmplan = *ptr_vmplan;        // pointer to VMPlan\n  ESMCI::FTable *ftable = *ptr;               // pointer to function table\n\n  int i = ftable->getEntry(name, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return; // bail out\n  enum ESMCI::method currentMethod = ESMCI::METHOD_NONE;  // default invalid\n  if (i > -1)\n    currentMethod = ftable->methodFromIndex(i);\n\n  // support for recursion _and_ re-entrance for non-blocking mode\n  // - recursion:   A component may call into any of its standard methods from\n  //                within the context of already executing a standard method.\n  //                There is no practical limit to the recursion depth.\n  // - re-entrance: This refers to the situation where there is an outstanding\n  //                non-blocking call, but the parent calls into the standard\n  //                child component method again. This really only happens\n  //                on the dual side of dual-actual pairs connected by a\n  //                component tunnel. The dual side then may re-enter with an\n  //                associated wait call.\n  bool newCargoFlag = true;   // initialize\n  if (recursionCount && *recursionCount==0 && *vm_cargo)\n    newCargoFlag = false; // this is not a recursion but a re-entrance\n\n#if 0\n  {\n    std::stringstream debugmsg;\n    debugmsg << \"inside c_esmc_ftablecallentrypointvm(): recursionCount=\" \n      <<  recursionCount << \" *recursionCount=\"\n      << (recursionCount ? *recursionCount : -1)\n      << \" vm_cargo=\" << vm_cargo << \" newCargoFlag=\" << newCargoFlag;\n    ESMC_LogDefault.Write(debugmsg.str(), ESMC_LOGMSG_INFO);\n  }\n#endif\n\n  if (newCargoFlag){\n    ESMCI::cargotype *cargo = new ESMCI::cargotype;\n    strcpy(cargo->name, name);    // copy trimmed type string\n    cargo->f90comp = f90comp;     // pointer to Fortran component\n    cargo->ftable = ftable;       // pointer to function table\n    cargo->rcCount = 1;           // default\n    cargo->esmfrc = new int[1];\n    cargo->userrc = new int[1];\n    cargo->esmfrc[0] = ESMF_SUCCESS;  // initialize return code to SUCCESS\n    cargo->userrc[0] = ESMF_SUCCESS;  // initialize user return code to SUCCESS\n    cargo->previousCargo = *vm_cargo; // support recursion\n    cargo->previousParentFlag = vmplan->parentVMflag;  // support threaded rec.\n    cargo->currentMethod = currentMethod;\n    if (*method == ESMCI::METHOD_SERVICELOOP){\n      // for serviceloop method the currentPhase carries the port argument\n      cargo->currentPhase = *port;\n    }else{\n      // for all other methods the currentPhase is the current phase\n      if (phase)\n        cargo->currentPhase = *phase;\n      else\n        cargo->currentPhase = 1;    // default\n    }\n\n    // store pointer to the cargo structure\n    *vm_cargo=(void*)cargo;\n\n    if (cargo->previousCargo != NULL){\n      // this is a recursive method invocation\n      // use the parentVMflag to indicate running in already existing child VM\n      vmplan->parentVMflag = 1;\n    }\n  }\n\n  delete[] name;  // delete memory that \"newtrim\" allocated above\n\n  // store the current timeout in the cargo structure\n  ESMCI::cargotype *cargo = (ESMCI::cargotype *)*vm_cargo;\n  if (timeout)\n    cargo->timeout = *timeout;\n  else\n    cargo->timeout = -1;          // indicate invalid timeout\n\n  // increment recursionCount before entering child VM\n  if (recursionCount) (*recursionCount)++;\n\n  // enter the child VM -> resurface in ESMCI_FTableCallEntryPointVMHop()\n#if 0\nstd::cout << \">>> calling into vm_parent->enter() with parentVMflag:\" \n  <<  vmplan->parentVMflag <<\"\\n\";\n#endif\n  localrc = vm_parent->enter(vmplan, *vm_info, *vm_cargo);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return; // bail out\n\n#if 0\nstd::cout << \"<<< parent thread returned from vm_parent->enter()\" << \"\\n\";\n#endif\n\n  // ... if the child VM uses threads (multi-threading or single-threading)\n  // then this parent PET continues running concurrently to the child PET in the\n  // same VAS! In that case the return codes in cargo are not valid here!\n  // The status returned by VM::enter() indicates that success of entering the\n  // child VM, not failure or success of the callback.\n  // The return code of the callback code will be valid in all cases (threading\n  // or no threading) _after_ VMK::exit() returns.\n\n  // get a pointer to the CompTunnel object\n  ESMCI::CompTunnel *compTunnel;\n  localrc = f90comp->getTunnel(&compTunnel);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // determine whether this is a dual component that is ready to execute\n  bool dualConnected = false;  // initialize\n  if (compTunnel) dualConnected = compTunnel->isConnected();\n\n  if (dualConnected){\n    // decrement recursionCount here for the dual side of a comp tunnel\n    // in general the decrement must happen during the wait, in case there\n    // are separate parent vs child threads running, but for comp tunnel must\n    // apply the decrement here\n    if (recursionCount) (*recursionCount)--;\n  }\n\n  // return successfully\n  if (rc) *rc = ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_compwait\"\nvoid FTN_X(c_esmc_compwait)(\n  ESMCI::VM **ptr_vm_parent,  // p2 to the parent VM\n  ESMCI::VMPlan **ptr_vmplan, // p2 to the VMPlan for component's VM\n  void **vm_info,             // p2 to member which holds info\n  void **vm_cargo,            // p2 to member which holds cargo\n  int *timeout,               // time out in seconds\n  int *recursionCount,        // keeping track of recursion level of component\n  int *userrc,                // return code of the user component method\n  int *rc){                   // esmf internal return error code\n\n  // initialize the return codes\n  int localrc = ESMC_RC_NOT_IMPL;\n  if (rc) *rc = ESMC_RC_NOT_SET; // return code of ESMF callback code\n\n  // Things get a little confusing here with pointers, so I will define\n  // some temp. variables that make matters a little clearer I hope:\n  ESMCI::VM *vm_parent = *ptr_vm_parent;        // pointer to parent VM\n  ESMCI::VMPlan *vmplan = *ptr_vmplan;          // pointer to VMPlan\n  ESMCI::cargotype *cargo = (ESMCI::cargotype *)*vm_cargo;  // pointer to cargo\n\n  // return with errors if there is no cargo to obtain error codes\n  if (cargo == NULL){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_PTR_NULL,\n      \" - No cargo structure to obtain error codes\", ESMC_CONTEXT, rc);\n    return;\n  }\n\n  // get a pointer to the CompTunnel object\n  ESMCI::Comp *f90comp = cargo->f90comp;\n  ESMCI::CompTunnel *compTunnel;\n  localrc = f90comp->getTunnel(&compTunnel);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // determine whether this is a dual component that is ready to execute\n  bool dualConnected = false;  // initialize\n  if (compTunnel) dualConnected = compTunnel->isConnected();\n\n  if (dualConnected){\n    // this is a dual component with a compTunnel that is connected\n    // -> execute compTunnel::wait() on dual components VM.\n\n    if (timeout == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_PTR_NULL,\n        \" - Must provide valid timeout argument\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    ESMCI::State *is = compTunnel->getImportState();\n    ESMCI::State *es = compTunnel->getImportState();\n    ESMCI::Clock **clock = compTunnel->getClock();\n\n    ESMCI::Clock *clockP = NULL; // default initialize\n    if (clock) clockP = *clock;\n\n    int userRc = ESMC_RC_NOT_IMPL;\n\n    localrc = f90comp->execute(ESMCI::METHOD_WAIT, is, es, clockP,\n      ESMF_NONBLOCKING,       // nonblocking or else endless recursion!!!\n      1, *timeout, &userRc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // TODO: in case of threading the userRc in not immediatly available!\n    if (ESMC_LogDefault.MsgFoundError(userRc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return; // bail out too because this is for an internal routine\n  }\n\n  // Now call the vmk_exit function which will block respective PETs\n  vm_parent->exit(static_cast<ESMCI::VMKPlan *>(vmplan), *vm_info);\n\n  // obtain return codes out of cargo\n  //TODO: deal with multiple return codes coming back for multi-threaded VMs\n  localrc = cargo->esmfrc[0];\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n  if (userrc) *userrc = cargo->userrc[0];\n\n  // delete cargo structure and handle recursion\n  delete [] cargo->esmfrc;\n  delete [] cargo->userrc;\n  *vm_cargo = cargo->previousCargo; // bring back previous cargo structure\n  vmplan->parentVMflag = cargo->previousParentFlag;   // previous value\n  delete cargo;\n\n  if (!dualConnected){\n    // decrement recursionCount here if not dual side of a comp tunnel\n    if (recursionCount) (*recursionCount)--;\n  }\n  \n  // return successfully\n  if (rc) *rc = ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_compget\"\nvoid FTN_X(c_esmc_compget)(\n  void **vm_cargo,            // p2 to member which holds cargo\n  enum ESMCI::method *method, // method type\n  int *phase,                 // phase selector\n  int *timeout,               // timeout\n  int *rc){                   // esmf internal return error code\n\n  // initialize the return codes\n  if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n  ESMCI::cargotype *cargo = (ESMCI::cargotype *)*vm_cargo;\n\n  if (cargo){\n    *method = cargo->currentMethod;\n    *phase = cargo->currentPhase;\n    *timeout = cargo->timeout;\n  }else{\n    *method = ESMCI::METHOD_NONE;\n    *phase = 0;\n    *timeout = 0;\n  }\n\n  // return successfully\n  if (rc) *rc = ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n\n} // extern \"C\"\n//==============================================================================\n\n\n\n//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n//\n// This section implements the FTable class\n//\n//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n\nnamespace ESMCI {\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::getDP()\"\nvoid FTable::getDP(FTable ***ptr, void **datap, int *rc){\n  char const *name = \"localdata\";\n  enum dtype dtype;\n  int localrc;\n\n  // Initialize return code; assume routine not implemented\n  if (rc) *rc = ESMC_RC_NOT_IMPL;\n  localrc = ESMC_RC_NOT_IMPL;\n\n  //printf(\"ptr = 0x%08x\\n\", (ESMC_POINTER)ptr);\n  //printf(\"*ptr = 0x%08x\\n\", (ESMC_POINTER)(*(int*)ptr));\n  if ((ptr == ESMC_NULL_POINTER) || (*ptr == ESMC_NULL_POINTER)) {\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, rc);\n    return;\n  }\n\n  localrc = (**ptr)->getDataPtr(name, datap, &dtype);\n  if (rc) *rc = localrc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setDP()\"\nvoid FTable::setDP(FTable ***ptr, void **datap, int *rc){\n  char const *name = \"localdata\";\n  enum dtype dtype = DT_FORTRAN_UDT_POINTER;\n  int localrc;\n\n  // Initialize return code; assume routine not implemented\n  if (rc) *rc = ESMC_RC_NOT_IMPL;\n  localrc = ESMC_RC_NOT_IMPL;\n\n  //printf(\"ptr = 0x%08x\\n\", (ESMC_POINTER)ptr);\n  //printf(\"*ptr = 0x%08x\\n\", (ESMC_POINTER)(*(int*)ptr));\n  if ((ptr == ESMC_NULL_POINTER) || (*ptr == ESMC_NULL_POINTER)) {\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, rc);\n    return;\n  }\n\n  localrc = (**ptr)->setDataPtr(name, datap, dtype);\n  if (rc) *rc = localrc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::getDataPtr()\"\n//BOPI\n// !IROUTINE:  getDataPtr - get data pointer from name\n//\n// !INTERFACE:\nint FTable::getDataPtr(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      char const *namep,     // in, data name\n      void **datap,          // out, data address\n      enum dtype *dtype) {   // out, data type\n//\n// !DESCRIPTION:\n//    Returns the named data pointer\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  int i;\n\n  for (i=datacount-1; i>=0; i--) {    // go backwards for: \"last in first out\"\n    if (strcmp(namep, data[i].dataname)) continue;\n\n    *dtype = data[i].dtype;\n\n    if (*dtype == DT_VOIDP){\n      *datap = data[i].dataptr;\n    }else if (*dtype == DT_FORTRAN_UDT_POINTER){\n      FTN_X(f_esmf_fortranudtpointercopy)((void *)datap, data[i].dataptr);\n    }\n\n    return ESMF_SUCCESS;\n  }\n\n  return ESMF_FAILURE;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setDataPtr()\"\n//BOPI\n// !IROUTINE:  setDataPtr - set data pointer\n//\n// !INTERFACE:\nint FTable::setDataPtr(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      char const *namep,     // in, data name\n      void **datap,          // in, data address\n      enum dtype dtype) {    // in, data type\n//\n// !DESCRIPTION:\n//    Sets the named data pointer\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize return code; assume routine not implemented\n  int rc = ESMC_RC_NOT_IMPL;\n\n  if (datacount >= dataalloc){\n    data =\n      (datainfo *)realloc((void *)data, (datacount+4) * sizeof(datainfo));\n    dataalloc = datacount+4;\n  }\n  data[datacount].dataname = new char[strlen(namep)+1];\n  strcpy(data[datacount].dataname, namep);\n  data[datacount].dtype = dtype;\n\n  if (dtype == DT_VOIDP){\n    data[datacount].dataptr = *datap;\n  }else if (dtype == DT_FORTRAN_UDT_POINTER){\n    int datumSize;  // upper limit of (UDT, pointer) size\n    FTN_X(f_esmf_fortranudtpointersize)(&datumSize);\n    data[datacount].dataptr = (void *)new char[datumSize];\n    FTN_X(f_esmf_fortranudtpointercopy)(data[datacount].dataptr, (void *)datap);\n  }\n\n  datacount++;\n\n  rc = ESMF_SUCCESS;\n  return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::Ftable::setServices\"\nvoid FTable::setServices(void *ptr, void (*func)(), int *userRc, int *rc) {\n  int localrc = ESMC_RC_NOT_IMPL;         // local return code\n  if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;   // final return code\n\n  // Check input\n  if ((ptr == ESMC_NULL_POINTER) || ((*(void**)ptr) == ESMC_NULL_POINTER)){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, rc);\n    return;\n  }\n\n  // TODO: shouldn't need to expand the table here - should be done inside\n  // FTable code on demand.\n  ESMCI::FTable *tabptr = **(ESMCI::FTable***)ptr;\n  localrc = (tabptr)->extend(32, 2); // room for 32 funcs, 2 data\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // Set callback function and arguments\n  ESMCI::Comp *f90comp = (ESMCI::Comp *)ptr;\n  localrc = (tabptr)->setFuncPtr(methodString(METHOD_SETSERVICES),\n    (void *)func, f90comp);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // time to startup the VM for this component (if not already started)...\n  ESMCI::VM *vm_parent;\n  localrc = f90comp->getVmParent(&vm_parent);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n  ESMCI::VMPlan *vmplan_p;\n  localrc = f90comp->getVmPlan(&vmplan_p);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n  void *vm_info;\n  localrc = f90comp->getVmInfo(&vm_info);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n  if (vm_info==NULL){\n    // VM for this component has not been started yet\n    vm_info = vm_parent->startup(vmplan_p,\n      ESMCI_FTableCallEntryPointVMHop, NULL, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // keep vm_info in a safe place (in parent component) 'till it's used again\n    FTN_X(f_esmf_compsetvminfo)(f90comp, &vm_info, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n  }\n  // ...now the component's VM is started up and placed on hold.\n\n  // reset a flag in the component structure\n  FTN_X(f_esmf_compresetvmreleased)(f90comp, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // call into register routine using the component's VM\n  void *vm_cargo = NULL;\n  enum method reg = METHOD_SETSERVICES;\n  FTN_X(c_esmc_ftablecallentrypointvm)(f90comp, &vm_parent, &vmplan_p, &vm_info,\n    &vm_cargo, &tabptr, &reg, NULL, NULL, NULL, NULL, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // wait for the register routine to return\n  FTN_X(c_esmc_compwait)(&vm_parent, &vmplan_p, &vm_info, &vm_cargo, NULL, NULL,\n    userRc, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // return successfully\n  if (rc) *rc = ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::Ftable::setVM\"\nvoid FTable::setVM(void *ptr, void (*func)(), int *userRc, int *rc) {\n  int localrc = ESMC_RC_NOT_IMPL;         // local return code\n  if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;   // final return code\n\n  // Check input\n  if ((ptr == ESMC_NULL_POINTER) || ((*(void**)ptr) == ESMC_NULL_POINTER)){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, rc);\n    return;\n  }\n\n  // cast into ESMCI::Comp pointer\n  ESMCI::Comp *f90comp = (ESMCI::Comp *)ptr;\n\n  // check to see if VM already exists for this Component\n  void *vm_info;\n  localrc = f90comp->getVmInfo(&vm_info);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n  if (vm_info!=NULL){\n    // VM for this component already exists\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_NOT_VALID, \"- VM already exists\",\n      ESMC_CONTEXT, rc);\n    return;\n  }\n\n  // TODO: shouldn't need to expand the table here - should be done inside\n  // FTable code on demand.\n  ESMCI::FTable *tabptr = **(ESMCI::FTable***)ptr;\n  localrc = (tabptr)->extend(32, 2); // room for 32 funcs, 2 data\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // Set callback function and arguments\n  localrc = (tabptr)->setFuncPtr(\"setVM\", (void *)func, f90comp);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // Call into user code callback function\n  localrc = (tabptr)->callVFuncPtr(\"setVM\", NULL, userRc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // return successfully\n  if (rc) *rc = ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::getEntry()\"\n//BOPI\n// !IROUTINE:  getEntry - get FTable entry from name\n//\n// !INTERFACE:\nint FTable::getEntry(\n//\n// !RETURN VALUE:\n//    entry index, or -1 if not found.\n//\n// !ARGUMENTS:\n  char const *name,      // in, function name\n  int *rc) {             // out, return code\n//\n// !DESCRIPTION:\n//  Returns the index into the function table that matches \"name\". A linear\n//  search is used, which is sufficient for typically very small function\n//  table sizes.\n//  One added feature this look-up routine also provides is a secondary\n//  search for the actual method name in case that \"name\" was _not_ found,\n//  _and_ \"name\" contained the substring \"IC\" which indicates that this\n//  would have been a look-up for an interface component method.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize rc and localrc ; assume functions not implemented\n  if (*rc) *rc = ESMC_RC_NOT_IMPL;\n\n  // Check input\n  if (name == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, rc);\n    return -1;  // indicate entry not found\n  }\n\n  int i;\n  for (i=0; i<funccount; i++) {\n    if (!strcmp(name, funcs[i].funcname))\n      break;\n  }\n  if (i==funccount) i=-1; // indicate entry not found\n\n//if (i==-1)\n//printf(\"gjt: failed attempt to look up method: %s\\n\", name);\n\n  if (i == -1){\n    // name was not found in function table -> check if name contains \"IC\"\n    char const *ic = strstr(name, \"IC\");\n    if (ic){\n      // this was a failed attempt look up interface component method\n      // -> try actual component method instead\n      int len = strlen(name);\n      char *tempname = new char[len];\n      char *b = tempname;\n      char const *a = name;\n      for (int l=0; l<len+1; l++){\n        if (a!=ic && a!=ic+1){\n          *b = *a;\n          b++;\n        }\n        a++;\n      }\n//printf(\"gjt: failed attempt to look up IC method -> try actual method: %s\\n\",\n//tempname);\n\n      for (i=0; i<funccount; i++) {\n        if (!strcmp(tempname, funcs[i].funcname))\n          break;\n      }\n      if (i==funccount) i=-1; // indicate entry not found\n      delete [] tempname;\n//if (i==-1)\n//printf(\"gjt: failed 2nd attempt to look up method: %s\\n\", name);\n    }\n  }\n\n  // return successfully\n  if (rc!=NULL) *rc = ESMF_SUCCESS;\n  return i;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setFuncPtr()\"\n//BOPI\n// !IROUTINE:  setFuncPtr - set function pointer, no extra args\n//\n// !INTERFACE:\nint FTable::setFuncPtr(\n//\n// !RETURN VALUE:\n//  int error return code\n//\n// !ARGUMENTS:\n    char const *name,      // in, function name\n    void *func) {          // in, function address\n//\n// !DESCRIPTION:\n//    Sets the named function pointer\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize return code; assume routine not implemented\n  int rc = ESMC_RC_NOT_IMPL;\n\n  // Check input\n  if (name == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n  if (func == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n\n  // look for the name already existing in the table.  if found\n  // replace it.  otherwise add it to the end.\n  int i;\n  for (i=0; i<funccount; i++)\n    if (!strcmp(name, funcs[i].funcname)) break;\n\n  // we found the function, or we got to the end of the table.\n  // either way we are ready to add it.\n\n  int thisfunc = i;\n\n  // extend the table if needed\n  if (thisfunc >= funcalloc){\n    funcs = (funcinfo *)realloc((void *)funcs, (thisfunc+4) * sizeof(funcinfo));\n    funcalloc = thisfunc+4;\n  }\n  funcs[thisfunc].funcptr = func;\n  funcs[thisfunc].ftype = FT_NULL;\n  // do these only if not replacing an existing entry.\n  if (thisfunc == funccount){\n    funcs[thisfunc].funcname = new char[strlen(name)+1];\n    strcpy(funcs[thisfunc].funcname, name);\n    funccount++;\n  }\n\n  // return successfully\n  rc = ESMF_SUCCESS;\n  return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setFuncPtr()\"\n//BOPI\n// !IROUTINE:  setFuncPtr - set function pointer, type; no args yet.\n//\n// !INTERFACE:\nint FTable::setFuncPtr(\n//\n// !RETURN VALUE:\n//  int error return code\n//\n// !ARGUMENTS:\n    char const *name,      // in, function name\n    void *func,            // in, function address\n    enum ftype ftype) {    // in, function type\n//\n// !DESCRIPTION:\n//    Sets the named function pointer and type, but specifies no argument\n//    values.  Before this can be called successfully, the user must call\n//    FTable::setFuncArgs to fill in the argument list.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize return code; assume routine not implemented\n  int rc = ESMC_RC_NOT_IMPL;\n\n  // Check input\n  if (name == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n  if (func == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n\n  // look for the name already existing in the table.  if found\n  // replace it.  otherwise add it to the end.\n  int i;\n  for (i=0; i<funccount; i++)\n    if (!strcmp(name, funcs[i].funcname)) break;\n\n  // we found the function, or we got to the end of the table.\n  // either way we are ready to add it.\n\n  int thisfunc = i;\n\n  // extend the table if needed\n  if (thisfunc >= funcalloc){\n    funcs = (funcinfo *)realloc((void *)funcs, (thisfunc+4) * sizeof(funcinfo));\n    funcalloc = thisfunc+4;\n  }\n  funcs[thisfunc].funcptr = func;\n  funcs[thisfunc].ftype = ftype;\n  // do these only if not replacing an existing entry.\n  if (thisfunc == funccount) {\n    funcs[thisfunc].funcname = new char[strlen(name)+1];\n    strcpy(funcs[thisfunc].funcname, name);\n    funccount++;\n  }\n\n  // return successfully\n  rc = ESMF_SUCCESS;\n  return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setFuncPtr()\"\n//BOPI\n// !IROUTINE:  setFuncPtr - set voidp, intp specifically\n//\n// !INTERFACE:\nint FTable::setFuncPtr(\n//\n// !RETURN VALUE:\n//  int error return code\n//\n// !ARGUMENTS:\n    char const *name,     // in, function name\n    void *func,           // in, function address\n    void *arg){           // in, void *\n//\n// !DESCRIPTION:\n//    Sets the named function pointer and arg.  This is a common case\n//    so it has it's own interface.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize return code; assume routine not implemented\n  int rc = ESMC_RC_NOT_IMPL;\n\n  // Check input\n  if (name == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n  if (func == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n  if (arg == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n\n  // look for the name already existing in the table.  if found\n  // replace it.  otherwise add it to the end.\n  int i;\n  for (i=0; i<funccount; i++)\n    if (!strcmp(name, funcs[i].funcname)) break;\n\n  // we found the function, or we got to the end of the table.\n  // either way we are ready to add it.\n\n  int thisfunc = i;\n\n  // extend the table if needed\n  if (thisfunc >= funcalloc) {\n    funcs = (funcinfo *)realloc((void *)funcs, (thisfunc+4) * sizeof(funcinfo));\n    funcalloc = thisfunc+4;\n  }\n  funcs[thisfunc].funcptr = func;\n  funcs[thisfunc].ftype = FT_VOIDP1INTP;\n  funcs[thisfunc].funcarg[0] = arg;\n  // do these only if not replacing an existing entry.\n  if (thisfunc == funccount) {\n    funcs[thisfunc].funcname = new char[strlen(name)+1];\n    strcpy(funcs[thisfunc].funcname, name);\n    funccount++;\n  }\n\n  // return successfully\n  rc = ESMF_SUCCESS;\n  return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setFuncArgs()\"\n//BOPI\n// !IROUTINE:  setFuncArgs - set arglist for existing function\n//\n// !INTERFACE:\nint FTable::setFuncArgs(\n//\n// !RETURN VALUE:\n//  int error return code\n//\n// !ARGUMENTS:\n    char const *name,      // in, function name\n    int acount,            // in, count of args\n    void **arglist) {      // in, address of arg list\n//\n// !DESCRIPTION:\n//    Sets the named function args.  The function must already exist.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize return code; assume routine not implemented\n  int localrc = ESMC_RC_NOT_IMPL;\n  int rc = ESMC_RC_NOT_IMPL;\n\n  // find the \"name\" entry\n  int i = getEntry(name, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    &rc)) return rc; // bail out\n\n  if (i == -1){\n    char msg[80];\n    sprintf(msg, \"unknown function name: %s\", name);\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, msg, ESMC_CONTEXT, &rc);\n    return rc; // bail out\n  }\n\n  // Check arglist argument\n  if (arglist == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n\n  // fill in arguments\n  for(int j=0; j<acount; j++)\n    funcs[i].funcarg[j] = arglist[j];\n\n  // return successfully\n  return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::callVFuncPtr()\"\n//BOPI\n// !IROUTINE:  callVFuncPtr - call a function w/ proper args\n//\n// !INTERFACE:\nint FTable::callVFuncPtr(\n//\n// !RETURN VALUE:\n//    integer return code\n//\n// !ARGUMENTS:\n  char const *name,     // in, function name\n  VM *vm_pointer,       // in, optional, pointer to this PET's VM instance\n  int *userrc) {        // out, function return code\n//\n// !DESCRIPTION:\n//    Calls the named function pointer\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // initialize return code; assume routine not implemented\n  int localrc = ESMC_RC_NOT_IMPL;         // local return code\n  int rc = ESMC_RC_NOT_IMPL;              // final return code\n\n  // sanity check userrc\n  if (!userrc){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n      \"- userrc must not be NULL pointer!\", ESMC_CONTEXT, &rc);\n    return rc; // bail out\n  }\n\n  // try to find \"name\" entry in single FTable instance on parent PET\n  int i = getEntry(name, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    &rc)) return rc; // bail out\n\n#if 0\nstd::cout << \"callVFuncPtr found i=\" << i << \"\\n\";\n#endif\n\n  Comp *comp;       // pointer to PET-local component\n  funcinfo *func;   // pointer to PET-local function entry\n\n  // optionally insert vm and replicate Component object, according to situation\n  if (vm_pointer){\n    // vm_pointer was provided -> use to set VM in Component object\n    VM *vmm = vm_pointer;\n    VM **vm = &vmm;\n    int mypet = vm_pointer->getMypet();\n    int mynthreads = vm_pointer->getNthreads(mypet);\n    int mytid = vm_pointer->getTid(mypet);\n#if 0\nstd::cout << \"vm_pointer present, mypet=\" << mypet << \" mynthreads=\" <<\n  mynthreads << \" mytid=\" << mytid <<\"\\n\";\n#endif\n    if (componentcount==0){\n      // first time Component is entering its VM -> replicate Comp\n      if (i == -1){\n        // single FTable instance on parent PET must have contained name\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"unknown function name\", ESMC_CONTEXT, &rc);\n        return rc; // bail out\n      }\n      func = funcs + i; // determine PET-local function entry\n      vm_pointer->threadbarrier();  // wait for all the threads to have entered\n      if (mytid==0){\n        // master thread allocates component list in FTable\n        component = new Comp[mynthreads];\n        componentcount = mynthreads;\n        vm_pointer->threadbarrier();  // synchronize with slave threads\n        comp = component;   // determine PET-local component\n        // make a copy of the component reference\n        FTN_X(f_esmf_comprefcopy)(comp, (Comp *)(func->funcarg[0]), &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n          ESMC_CONTEXT, &rc)) return rc; // bail out\n        // insert child VM\n        FTN_X(f_esmf_compinsertvm)(comp, vm, &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n          ESMC_CONTEXT, &rc)) return rc; // bail out\n      }else{\n        // slave thread -> replicate component structure, insert child VM\n        vm_pointer->threadbarrier();  // synchronize with master thread\n        // replicate Component from the parent PET w/ private FTable, insert VM\n        comp = component + mytid; // determine PET-local component\n        FTN_X(f_esmf_compreplicate)(comp, (Comp *)(func->funcarg[0]), vm,\n          &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n          ESMC_CONTEXT, &rc)) return rc; // bail out\n      }\n    }else if (i>-1){\n      // not first time entry, but found name in FTable\n      // -> must be SetServices _again_\n      func = funcs + i; // determine PET-local function entry\n      comp = component + mytid; // determine PET-local component\n    }else if (componentcount == mynthreads){\n      // subsequent time Component is entering its VM -> obtain comp\n      comp = component + mytid; // determine PET-local component\n      FTable *ftable = **(FTable ***)comp;  // determine comp's FTable instance\n      int j = ftable->getEntry(name, &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, &rc)) return rc; // bail out\n      if (j == -1){\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"unknown function name\", ESMC_CONTEXT, &rc);\n        return rc; // bail out\n      }\n      func = ftable->funcs + j; // determine PET-local function entry\n    }else{\n      // fatal inconsistent situation\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"fatal inconsistency between Component and VM\", ESMC_CONTEXT, &rc);\n      return rc;\n    }\n  }else{\n    // vm_pointer was not provided -> simple call-back without VM insertion\n    func = funcs + i; // determine PET-local function entry\n    comp = (Comp *)(func->funcarg[0]);\n  }\n\n  // call-back into user code\n  switch (func->ftype){\n    case FT_VOIDP1INTP: {\n#if 0\nstd::cout << \"calling out of case FT_VOIDP1INTP\" << \"\\n\";\n#endif\n      VoidP1IntPFunc vf = (VoidP1IntPFunc)func->funcptr;\n      (*vf)((void *)comp, userrc);\n      // conditionally set entry point for ServiceLoop\n      if (!strcmp(name, methodString(METHOD_SETSERVICES))){\n        localrc = comp->setEntryPoint(METHOD_SERVICELOOP, ServiceLoop);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n          ESMC_CONTEXT, &rc)) return rc; // bail out\n      }\n      // conditionally call into compliance IC for register\n      if (!strcmp(name, methodString(METHOD_SETSERVICES))){\n        char const *envVar = VM::getenv(\"ESMF_RUNTIME_COMPLIANCECHECK\");\n        bool complianceCheckFlag = false;  // default internal compl. check off\n        if (envVar != NULL){\n          string value(envVar);\n          // see if compliance checker should be turned on\n          complianceCheckFlag |= value.find(\"on\")!=string::npos;  // turn on\n          complianceCheckFlag |= value.find(\"ON\")!=string::npos;  // turn on\n        }\n\n        if (complianceCheckFlag){\n          int registerIcUserRc;\n\n          // inspect the ESMF_RUNTIME_COMPLIANCEICOBJECT attribute on comp\n          ESMC_Base *base;\n          localrc = comp->getBase(&base);\n          if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n            ESMC_CONTEXT, &rc)) return rc; // bail out\n          ESMC_Logical presentFlag;\n          base->ESMC_BaseGetRoot()->AttributeIsPresent(\"ESMF_RUNTIME_COMPLIANCEICREGISTER\",\n            &presentFlag);\n\n//#ifdef ESMF_NO_DLFCN\n          //if (presentFlag==ESMF_TRUE){\n          //  presentFlag==ESMF_FALSE;\n          //  ESMC_LogDefault.Write(\"Ignoring ESMF_RUNTIME_COMPLIANCEICREGISTER \"\n          //   \"Attribute due to no dynamic linking.\", ESMC_LOGMSG_WARN);\n          //}\n//#endif\n\n\n          if (presentFlag==ESMF_TRUE){\n\n            // access the attribute object in base\n            ESMCI::Attribute *attr=base->ESMC_BaseGetRoot()->AttributeGet(\n              \"ESMF_RUNTIME_COMPLIANCEICREGISTER\");\n\n            // retrieve the string value of the attribute\n            std::vector<string> value;\n            localrc = attr->get(&value);\n            if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n              ESMC_CONTEXT, &rc)) return rc; // bail out\n\n            // check the number of strings associated with the attribute\n            if (value.size()!=1){\n              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                \"Attribute must contain single string\", ESMC_CONTEXT, &rc);\n              return rc;\n            }\n\n            // convert routine name according to name mangeling mode\n            //TODO: this would be a good Util method to have\n#ifdef ESMF_LOWERCASE_DOUBLEUNDERSCORE\n            std::transform(value[0].begin(), value[0].end(), value[0].begin(),\n              ::tolower);\n            value[0]+=\"__\";\n#else\n            std::transform(value[0].begin(), value[0].end(), value[0].begin(),\n              ::tolower);\n            value[0]+=\"_\";\n#endif\n\n#if 0\nstd::cout << \"ESMF_RUNTIME_COMPLIANCEICREGISTER attribute:\" << value[0] <<\"\\n\";\n#endif\n\n#ifndef ESMF_NO_DLFCN\n            // check and see if an alternate compliance ic object was specified\n            envVar = VM::getenv(\"ESMF_RUNTIME_COMPLIANCEICOBJECT\");\n            void *lib;\n            lib = dlopen(envVar, RTLD_LAZY);  // envVar==NULL -> look into exe\n            if (lib == NULL){\n              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                \"- shared object not found\", ESMC_CONTEXT, &rc);\n              return rc;\n            }\n            void *pointer = (void *)dlsym(lib, value[0].c_str());\n            if (pointer == NULL){\n              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                \"- compliance IC register routine not found\", ESMC_CONTEXT, &rc);\n              return rc;\n            }\n\n            VoidP1IntPFunc vf = (VoidP1IntPFunc)pointer;\n            (*vf)((void *)comp, &registerIcUserRc);\n            // compliance IC for register is an internal routine -> look at rc\n            if (ESMC_LogDefault.MsgFoundError(registerIcUserRc,\n              ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &rc)) return rc; // bail out\n#else\n            //here the compliance register routine has been specified\n            //on the attribute, but we do not have dlopen available\n            //therefore, go for a blind call assuming the NUOPC register\n            //routines have been linked in, which is typically the case\n\n            //std::cout << \"ESMF_RUNTIME_COMPLIANCEICREGISTER attribute:\" << value[0] <<\"\\n\";\n            if (value[0].find(\"nuopc_model\") != std::string::npos) {\n                FTN_X(nuopc_model_complianceicr)((void *)comp, &registerIcUserRc);\n                if (ESMC_LogDefault.MsgFoundError(registerIcUserRc,\n                              ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &rc)) return rc; // bail out\n            }\n            else if (value[0].find(\"nuopc_driver\") != std::string::npos) {\n                FTN_X(nuopc_driver_complianceicr)((void *)comp, &registerIcUserRc);\n                if (ESMC_LogDefault.MsgFoundError(registerIcUserRc,\n                              ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &rc)) return rc; // bail out\n            }\n            else if (value[0].find(\"nuopc_connector\") != std::string::npos) {\n                FTN_X(nuopc_connector_complianceicr)((void *)comp, &registerIcUserRc);\n                if (ESMC_LogDefault.MsgFoundError(registerIcUserRc,\n                              ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &rc)) return rc; // bail out\n            }\n            else {\n                ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                   \"- compliance IC register routine not found\", ESMC_CONTEXT, &rc);\n                return rc;\n            }\n#endif\n\n          }else{\n            //TODO: In the long run the else branch could be refactored with\n            //TODO: the if branch. Both in principle should be using dlopen()\n            //TODO: for DLFCN based lookup. However, we do not currently build\n            //TODO: correct PIC on all combos for which we have DLFCN enabled,\n            //TODO: and so lookup inside the executable is not yet guaranteed.\n            //TODO: Until this is fixed, the else branch will use hardcoded\n            //TODO: Fortran function directly.\n#define ESMF_NO_DLFCNdummy\n\n#ifdef ESMF_NO_DLFCNdummy\n            FTN_X(esmf_complianceicregister)((void *)comp, &registerIcUserRc);\n\n#else\n#define QUOTEMACRO_(x) #x\n#define QUOTEMACRO(x) QUOTEMACRO_(x)\n\n            envVar = VM::getenv(\"ESMF_RUNTIME_COMPLIANCEICOBJECT\");\n            void *lib;\n            lib = dlopen(envVar, RTLD_LAZY);  // envVar==NULL -> look into exe\n            if (lib == NULL){\n              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                \"- shared object not found\", ESMC_CONTEXT, &rc);\n              return rc;\n            }\n            envVar = VM::getenv(\"ESMF_RUNTIME_COMPLIANCEICREGISTER\");\n            void *pointer;\n            if (envVar != NULL)\n              pointer = (void *)dlsym(lib, envVar);\n            else\n              pointer = (void *)dlsym(lib,\n                QUOTEMACRO(FTN(esmf_complianceicregister)) );\n            if (pointer == NULL){\n              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                \"- compliance IC register routine not found\", ESMC_CONTEXT, &rc);\n              return rc;\n            }\n\n            VoidP1IntPFunc vf = (VoidP1IntPFunc)pointer;\n            (*vf)((void *)comp, &registerIcUserRc);\n#endif\n\n            // compliance IC for register is an internal routine -> look at rc\n            if (ESMC_LogDefault.MsgFoundError(registerIcUserRc,\n              ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &rc)) return rc; // bail out\n          }\n        }\n      }\n\n      break;\n    }\n    case FT_VOIDP4INTP: {\n#if 0\nstd::cout << \"calling out of case FT_VOIDP4INTP\" << \"\\n\";\n#endif\n      VoidP4IntPFunc vf = (VoidP4IntPFunc)func->funcptr;\n      (*vf)((void *)comp, func->funcarg[1], func->funcarg[2],\n        func->funcarg[3], userrc);\n      break;\n    }\n    default:\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"unknown function type\", ESMC_CONTEXT, &rc);\n      return rc;\n  }\n\n  // return successfully\n  return ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::extend()\"\n//BOPI\n// !IROUTINE:  extend - make space for additional functions/data\n//\n// !INTERFACE:\nint FTable::extend(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      int nfuncp,     // in, number of functions which will be added\n      int ndatap) {   // in, number of data pointers which will be added\n//\n// !DESCRIPTION:\n//\n//EOPI\n//-----------------------------------------------------------------------------\n    // Initialize return code; assume routine not implemented\n    int rc = ESMC_RC_NOT_IMPL;\n\n    // TODO: allocate space for N items, rounded up?\n    if (nfuncp > funcalloc) {\n        funcs = (funcinfo *)realloc((void *)funcs, nfuncp * sizeof(funcinfo));\n        funcalloc = nfuncp;\n    }\n    if (ndatap > dataalloc) {\n        data = (datainfo *)realloc((void *)data, ndatap * sizeof(datainfo));\n        dataalloc = ndatap;\n    }\n\n    //printf(\"TableExtend called, sizeof(funcinfo)=%d, sizeof(datainfo)=%d\\n\",\n    //                            sizeof(funcinfo), sizeof(datainfo));\n    rc = ESMF_SUCCESS;\n    return rc;\n\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::query()\"\n//BOPI\n// !IROUTINE:  query - return count of functions/data\n//\n// !INTERFACE:\nint FTable::query(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      int *nfuncp,     // out, number of functions which will be added\n      int *ndatap) {   // out, number of data pointers which will be added\n//\n// !DESCRIPTION:\n//\n//EOPI\n//-----------------------------------------------------------------------------\n    // Initialize return code; assume routine not implemented\n    int rc = ESMC_RC_NOT_IMPL;\n\n    // fill in values\n    *nfuncp = funccount;\n    *ndatap = datacount;\n\n    //printf(\"TableQuery method called \\n\");\n    rc = ESMF_SUCCESS;\n    return rc;\n\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::validate()\"\n//BOPI\n// !IROUTINE:  validate - internal consistency check for a Component\n//\n// !INTERFACE:\nint FTable::validate(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      char const *options) const {    // in - validate options\n//\n// !DESCRIPTION:\n//      Validates that a Component is internally consistent.\n//      Returns error code if problems are found.  Base class method.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n    // Initialize return code; assume routine not implemented\n    int rc = ESMC_RC_NOT_IMPL;\n\n    return ESMC_RC_NOT_IMPL;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::print()\"\n//BOPI\n// !IROUTINE:  print - print contents of a Component\n//\n// !INTERFACE:\nint FTable::print(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      char const *options) const {     //  in - print options\n//\n// !DESCRIPTION:\n//      Print information about a Component.  The options control the\n//      type of information and level of detail.  Base class method.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n    // Initialize return code; assume routine not implemented\n    int rc = ESMC_RC_NOT_IMPL;\n\n    return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable()\"\n//BOPI\n// !IROUTINE:  FTable - native C++ constructor\n//\n// !INTERFACE:\nFTable::FTable(\n//\n// !RETURN VALUE:\n//  none\n//\n// !ARGUMENTS:\n    void){\n//\n// !DESCRIPTION:\n//  Native constructor.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  //printf(\"in ftable constructor\\n\");\n  funccount = 0;\n  funcalloc = 0;\n  funcs = NULL;\n  datacount = 0;\n  dataalloc = 0;\n  data = NULL;\n  componentcount = 0;\n  component = NULL;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"~ESMCI::FTable()\"\n//BOPI\n// !IROUTINE:  ~FTable - native C++ destructor\n//\n// !INTERFACE:\nFTable::~FTable(void) {\n//\n// !RETURN VALUE:\n//  none\n//\n// !ARGUMENTS:\n//  none\n//\n// !DESCRIPTION:\n//  Native destructor - deleting internal allocations\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  for (int i=0; i<funccount; i++)\n    funcs[i].~funcinfo();\n  free(funcs);\n  funccount = 0;\n  funcalloc = 0;\n  funcs = NULL;\n\n  for (int i=0; i<datacount; i++)\n    data[i].~datainfo();\n  free(data);\n  datacount = 0;\n  dataalloc = 0;\n  data = NULL;\n\n  for (int i=1; i<componentcount; i++){\n    // skip i=0 since that is identical to the actual Component object\n    Comp *comp = component + i;\n    FTable *ftable = **(FTable ***)comp;\n    delete ftable;\n    ftable = NULL;\n    int localrc;\n    FTN_X(f_esmf_compdelete)(comp, &localrc);\n  }\n  delete [] component;\n  component = NULL;\n}\n//-----------------------------------------------------------------------------\n\n//==============================================================================\n//\n// this trim routine does several things:\n//\n// most importantly, it null terminates a counted-char string passed in\n// from fortran.  it's not guarenteed you can write into the N+1th\n// character location (if the string is full length in fortran, for example)\n// so we're forced to make a copy and copy into it.  this routine allocates,\n// so the char string created here MUST be deleted by the caller when finished.\n//\n// secondly, the phase number (init 1, init 2, etc) is passed in as an int.\n// if > 0 this routine turns it into a 2-char string filled with\n// leading 0s and tacks it onto the end of the name to make it unique.\n//\n// and finally, component routines can be called with either a single\n// state or a pair of states. we can require that the user specify the\n// interface at registration time, or we can decide at run time which\n// form was called and dispatch the corresponding entry point.\n// for now i'm going to fill both types of component entry points for each\n// registration.  i can always remove that code if we force the user\n// to specify at registration time what format the states are expected in.\n// so if nstate > 0, it gets the same treatment as phase: it's turned into\n// a single char string and tacked on the end.\n//\n// (we'd also at some point like to be able to pass back into fortran\n// a really type(State) F90 array - but the bytes on the stack are\n// compiler dependent - we'd have to create the array in fortran and\n// save a copy of it to be safe.  that code is *NOT* implemented at this\n// point, but i know it would sure seem natural from the user's viewpoint.)\n//\n\n// this is max of 2 char phase + 'P' + 1 char nstate + 'S' + trailing NULL\n#define MAXPAD 8\n\nvoid FTable::newtrim(char const *oldc, int clen, int *phase, int *nstate,\n  char **newc) {\n  char *cp, *ctmp;\n  int hasphase = 0;\n  int hasstate = 0;\n  char tspace[MAXPAD];\n  int pad=2;         // if neither phase nor nstate, still need term NULL\n\n  //printf(\"in newtrim, oldc = '%s', clen = %d\\n\", oldc, clen);\n\n  // warning - on the intel compiler, optional args come in\n  // as -1, not 0.  check for both before dereferencing.\n  if ((phase != NULL) && (phase != (int *)-1) && (*phase >= 0))  {\n    pad = MAXPAD;\n    hasphase++;\n  }\n\n  // warning - on the intel compiler, optional args come in\n  // as -1, not 0.  check for both before dereferencing.\n  // if state > 0, use it to alter the EP name.\n  if ((nstate != NULL) && (nstate != (int *)-1) && (*nstate > 0))  {\n    pad = MAXPAD;\n    hasstate++;\n  }\n\n  // make new space and leave room for at least a null terminator, more\n  // if it has either phase or num states or both.\n  ctmp = new char[clen+pad];\n  strncpy(ctmp, oldc, clen);\n  ctmp[clen] = '\\0';\n  for (cp = &ctmp[clen-1]; *cp == ' '; cp--)   // trim() trailing blanks\n    *cp = '\\0';\n\n  // tack on trailing numbers if phase or nstate\n  if (hasphase && hasstate) {\n    sprintf(tspace, \"%02dP%1dS\", *phase, *nstate);\n    strcat(ctmp, tspace);\n  } else if (hasphase) {\n    sprintf(tspace, \"%02dP\", *phase);\n    strcat(ctmp, tspace);\n  } else if (hasstate) {\n    sprintf(tspace, \"%1dS\", *nstate);\n    strcat(ctmp, tspace);\n  }\n\n  // set return pointer.  caller MUST free this when finished with it.\n  *newc = ctmp;\n  //printf(\"out newtrim, newc = '%s'\\n\", *newc);\n\n  return;\n}\n//==============================================================================\n\n\n//==============================================================================\nchar const *FTable::methodString(enum ESMCI::method method){\n  switch(method){\n  case ESMCI::METHOD_NONE:\n    return \"None\";\n    break;\n  case ESMCI::METHOD_INITIALIZE:\n    return \"Initialize\";\n    break;\n  case ESMCI::METHOD_RUN:\n    return \"Run\";\n    break;\n  case ESMCI::METHOD_FINALIZE:\n    return \"Finalize\";\n    break;\n  case ESMCI::METHOD_WRITERESTART:\n    return \"WriteRestart\";\n    break;\n  case ESMCI::METHOD_READRESTART:\n    return \"ReadRestart\";\n    break;\n  case ESMCI::METHOD_SERVICELOOP:\n    return \"ServiceLoop\";\n    break;\n  case ESMCI::METHOD_INITIALIZEIC:\n    return \"InitializeIC\";\n    break;\n  case ESMCI::METHOD_RUNIC:\n    return \"RunIC\";\n    break;\n  case ESMCI::METHOD_FINALIZEIC:\n    return \"FinalizeIC\";\n    break;\n  case ESMCI::METHOD_WRITERESTARTIC:\n    return \"WriteRestartIC\";\n    break;\n  case ESMCI::METHOD_READRESTARTIC:\n    return \"ReadRestartIC\";\n    break;\n  case ESMCI::METHOD_SERVICELOOPIC:\n    return \"ServiceLoopIC\";\n    break;\n  case ESMCI::METHOD_SETSERVICES:\n    return \"Register\";\n    break;\n  case ESMCI::METHOD_WAIT:\n    return \"Wait\";\n    break;\n  default:\n    return \"Unknown\";\n    break;\n  }\n  return NULL;\n}\n//==============================================================================\n\n//==============================================================================\nenum method FTable::methodFromString(char const *methodString){\n  if (!strncmp(methodString, \"InitializeIC\", strlen(\"InitializeIC\")))\n    return ESMCI::METHOD_INITIALIZEIC;\n  else if (!strncmp(methodString, \"RunIC\", strlen(\"RunIC\")))\n    return ESMCI::METHOD_RUNIC;\n  else if (!strncmp(methodString, \"FinalizeIC\", strlen(\"FinalizeIC\")))\n    return ESMCI::METHOD_FINALIZEIC;\n  else if (!strncmp(methodString, \"WriteRestartIC\", strlen(\"WriteRestartIC\")))\n    return ESMCI::METHOD_WRITERESTARTIC;\n  else if (!strncmp(methodString, \"ReadRestartIC\", strlen(\"ReadRestartIC\")))\n    return ESMCI::METHOD_READRESTARTIC;\n  else if (!strncmp(methodString, \"Initialize\", strlen(\"Initialize\")))\n    return ESMCI::METHOD_INITIALIZE;\n  else if (!strncmp(methodString, \"Run\", strlen(\"Run\")))\n    return ESMCI::METHOD_RUN;\n  else if (!strncmp(methodString, \"Finalize\", strlen(\"Finalize\")))\n    return ESMCI::METHOD_FINALIZE;\n  else if (!strncmp(methodString, \"WriteRestart\", strlen(\"WriteRestart\")))\n    return ESMCI::METHOD_WRITERESTART;\n  else if (!strncmp(methodString, \"ReadRestart\", strlen(\"ReadRestart\")))\n    return ESMCI::METHOD_READRESTART;\n  else if (!strncmp(methodString, \"Register\", strlen(\"Register\")))\n    return ESMCI::METHOD_SETSERVICES;\n  return ESMCI::METHOD_NONE;\n}\n//==============================================================================\n\n//==============================================================================\nenum method FTable::methodFromIndex(int i){\n  return methodFromString(funcs[i].funcname);\n}\n//==============================================================================\n\n} // namespace ESMCI\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile4.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Field/tests/data/C48_mosaic.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile1.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile3.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Field/tests/data/weights_generic.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile5.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile6.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile2.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/IO/tests/T42_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/IO/tests/io_netcdf_testdata.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/IO/tests/GRIDSPEC_320x160.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Mesh/tests/data/ne4np4-pentagons.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Mesh/tests/data/ne4np4-esmf.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Mesh/examples/data/ne4np4-pentagons.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Mesh/examples/data/ne4np4-esmf.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Grid/tests/data/T42_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Grid/tests/data/GRIDSPEC_1x1.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Grid/tests/data/RCM3_CF_CART2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Grid/tests/data/horizontal_grid.tile6.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Infrastructure/Grid/examples/data/T42_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Superstructure/PreESMFMod/tests/data/T42_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Superstructure/PreESMFMod/tests/data/BT42_ugrid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Superstructure/PreESMFMod/tests/data/ll2.5deg_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/Superstructure/PreESMFMod/tests/data/BT42_ugrid_dual.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/prologue/tests/ESMF_F95PtrUTest.F90",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/test_harness/catalog/sample.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/addon/MAPL5_1/src/GMAO_Shared/MAPL_Base/TeX/figs/geos5_esmf.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/addon/MAPL5_1/src/GMAO_Shared/MAPL_Base/TeX/figs/esmf_sandwich.png",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/addon/MAPL/MAPL_Base/TeX/figs/geos5_esmf.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/addon/MAPL/MAPL_Base/TeX/figs/esmf_sandwich.png",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/addon/ESMPy/src/ESMF/util/enum/doc/enum.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/addon/ESMPy/src/ESMF/test/data/T42_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/addon/ESMPy/src/ESMF/test/data/gridspec1Dcoords.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/addon/ESMPy/src/ESMF/test/data/ne4np4-pentagons.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-y7i6fdf6pawfqnvdrigbemn5xtwtwyif/spack-src/src/addon/ESMPy/src/ESMF/test/data/ne4np4-esmf.nc"
    ],
    "total_files": 3654
}