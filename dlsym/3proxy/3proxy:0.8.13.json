{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-3proxy-0.8.13-2rv2nfmlvh24cbqdsu3hto3r76xetyxg/spack-src/src/conf.c": "#include \"proxy.h\"\n#ifndef _WIN32\n#include <sys/resource.h>\n#ifndef NOPLUGINS\n#include <dlfcn.h>\n#endif\n#endif\n\n#ifndef DEFAULTCONFIG\n#define DEFAULTCONFIG conf.stringtable[25]\n#endif\n\npthread_mutex_t bandlim_mutex;\npthread_mutex_t tc_mutex;\npthread_mutex_t pwl_mutex;\npthread_mutex_t hash_mutex;\npthread_mutex_t config_mutex;\n\nint haveerror = 0;\nint linenum = 0;\n\nFILE *writable;\nstruct counter_header cheader = {\"3CF\", (time_t)0};\nstruct counter_record crecord;\n\nint mainfunc (int argc, char** argv);\n\nstruct proxydef childdef = {NULL, 0, 0, S_NOSERVICE, \"\"};\n\n#define STRINGBUF 65535\n#define NPARAMS\t  4096\n\n#ifndef _WIN32\nchar *chrootp = NULL;\nstatic pthread_attr_t pa;\n#endif\nchar * curconf = NULL;\n\nFILE * confopen(){\n\tcurconf = conf.conffile;\n#ifndef _WIN32\n\tif(chrootp){\n\t\tif(strstr(curconf, chrootp) == curconf)\n\t\t\tcurconf += strlen(chrootp);\n\t}\n#endif\n\tif(writable) {\n\t\trewind(writable);\n\t\treturn writable;\n\t}\n\treturn fopen(curconf, \"r\");\n}\n\n\n#ifdef _WIN32\nDWORD WINAPI startsrv(LPVOID data) {\n#else\nvoid * startsrv(void * data) {\n#endif\n  struct child *d = (struct child *)data;\n  mainfunc(d->argc, (char **)d->argv);\n  return 0;\n}\n\nint included =0;\n\nint getrotate(char c){\n\tswitch(c){\n\tcase 'c':\n\tcase 'C':\n\t\treturn MINUTELY;\n\tcase 'h':\n\tcase 'H':\n\t\treturn HOURLY;\n\tcase 'd':\n\tcase 'D':\n\t\treturn DAILY;\n\tcase 'w':\n\tcase 'W':\n\t\treturn WEEKLY;\n\tcase 'y':\n\tcase 'Y':\n\t\treturn ANNUALLY;\n\tcase 'm':\n\tcase 'M':\n\t\treturn MONTHLY;\n\tdefault:\n\t\treturn NEVER;\n\t}\n}\n\n\nunsigned char * dologname (unsigned char *buf, unsigned char *name, const unsigned char *ext, ROTATION lt, time_t t) {\n\tstruct tm *ts;\n\n\tts = localtime(&t);\n\tif(strchr((char *)name, '%')){\n\t\tstruct clientparam fakecli;\n\n\t\tmemset(&fakecli, 0, sizeof(fakecli));\n\t\tdobuf2(&fakecli, buf, NULL, NULL, ts, (char *)name);\n\t}\n\telse switch(lt){\n\t\tcase NONE:\n\t\t\tsprintf((char *)buf, \"%s\", name);\n\t\t\tbreak;\n\t\tcase ANNUALLY:\n\t\t\tsprintf((char *)buf, \"%s.%04d\", name, ts->tm_year+1900);\n\t\t\tbreak;\n\t\tcase MONTHLY:\n\t\t\tsprintf((char *)buf, \"%s.%04d.%02d\", name, ts->tm_year+1900, ts->tm_mon+1);\n\t\t\tbreak;\n\t\tcase WEEKLY:\n\t\t\tt = t - (ts->tm_wday * (60*60*24));\n\t\t\tts = localtime(&t);\n\t\t\tsprintf((char *)buf, \"%s.%04d.%02d.%02d\", name, ts->tm_year+1900, ts->tm_mon+1, ts->tm_mday);\n\t\t\tbreak;\n\t\tcase DAILY:\n\t\t\tsprintf((char *)buf, \"%s.%04d.%02d.%02d\", name, ts->tm_year+1900, ts->tm_mon+1, ts->tm_mday);\n\t\t\tbreak;\n\t\tcase HOURLY:\n\t\t\tsprintf((char *)buf, \"%s.%04d.%02d.%02d-%02d\", name, ts->tm_year+1900, ts->tm_mon+1, ts->tm_mday, ts->tm_hour);\n\t\t\tbreak;\n\t\tcase MINUTELY:\n\t\t\tsprintf((char *)buf, \"%s.%04d.%02d.%02d-%02d.%02d\", name, ts->tm_year+1900, ts->tm_mon+1, ts->tm_mday, ts->tm_hour, ts->tm_min);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\tif(ext){\n\t\tstrcat((char *)buf, \".\");\n\t\tstrcat((char *)buf, (char *)ext);\n\t}\n\treturn buf;\n}\n\nint start_proxy_thread(struct child * chp){\n  pthread_t thread;\n#ifdef _WIN32\n  HANDLE h;\n#endif\n\n\tconf.threadinit = 1;\n#ifdef _WIN32\n#ifndef _WINCE\n\th = (HANDLE)_beginthreadex((LPSECURITY_ATTRIBUTES )NULL, 16384+conf.stacksize, (void *)startsrv, (void *) chp, (DWORD)0, &thread);\n#else\n\th = (HANDLE)CreateThread((LPSECURITY_ATTRIBUTES )NULL, 16384+conf.stacksize, (void *)startsrv, (void *) chp, (DWORD)0, &thread);\n#endif\n\tif(h)CloseHandle(h);\n#else\n\tpthread_attr_init(&pa);\n\tpthread_attr_setstacksize(&pa,PTHREAD_STACK_MIN + (16384+conf.stacksize));\n\tpthread_attr_setdetachstate(&pa,PTHREAD_CREATE_DETACHED);\n\tpthread_create(&thread, &pa, startsrv, (void *)chp);\n\tpthread_attr_destroy(&pa);\n#endif\n\twhile(conf.threadinit)usleep(SLEEPTIME);\n\tif(haveerror)  {\n\t\tfprintf(stderr, \"Service not started on line: %d\\n\", linenum);\n\t\treturn(40);\n\t}\n\treturn 0;\n}\n\nstatic int h_proxy(int argc, unsigned char ** argv){\n  struct child ch;\n\n\tch.argc = argc;\n\tch.argv = argv;\n\tif(!strcmp((char *)argv[0], \"proxy\")) {\n\t\tchilddef.pf = proxychild;\n\t\tchilddef.port = 3128;\n\t\tchilddef.isudp = 0;\n\t\tchilddef.service = S_PROXY;\n\t\tchilddef.helpmessage = \" -n - no NTLM support\\n\";\n#ifdef NOIPV6\n\t\tif(!resolvfunc || (resolvfunc == myresolver && !dns_table.hashsize)){\n\t\t\tfprintf(stderr, \"[line %d] Warning: no nserver/nscache configured, proxy may run very slow\\n\", linenum);\n\t\t}\n#endif\n\t}\n\telse if(!strcmp((char *)argv[0], \"pop3p\")) {\n\t\tchilddef.pf = pop3pchild;\n\t\tchilddef.port = 110;\n\t\tchilddef.isudp = 0;\n\t\tchilddef.service = S_POP3P;\n\t\tchilddef.helpmessage = \" -hdefault_host[:port] - use this host and port as default if no host specified\\n\";\n\t}\n\telse if(!strcmp((char *)argv[0], \"smtpp\")) {\n\t\tchilddef.pf = smtppchild;\n\t\tchilddef.port = 25;\n\t\tchilddef.isudp = 0;\n\t\tchilddef.service = S_SMTPP;\n\t\tchilddef.helpmessage = \" -hdefault_host[:port] - use this host and port as default if no host specified\\n\";\n\t}\n\telse if(!strcmp((char *)argv[0], \"ftppr\")) {\n\t\tchilddef.pf = ftpprchild;\n\t\tchilddef.port = 21;\n\t\tchilddef.isudp = 0;\n\t\tchilddef.service = S_FTPPR;\n\t\tchilddef.helpmessage = \" -hdefault_host[:port] - use this host and port as default if no host specified\\n\";\n\t}\n\telse if(!strcmp((char *)argv[0], \"socks\")) {\n\t\tchilddef.pf = sockschild;\n\t\tchilddef.port = 1080;\n\t\tchilddef.isudp = 0;\n\t\tchilddef.service = S_SOCKS;\n\t\tchilddef.helpmessage = \" -n - no NTLM support\\n\";\n#ifdef NOIPV6\n\t\tif(!resolvfunc || (resolvfunc == myresolver && !dns_table.hashsize)){\n\t\t\tfprintf(stderr, \"[line %d] Warning: no nserver/nscache configured, socks may run very slow\\n\", linenum);\n\t\t}\n#endif\n\t}\n\telse if(!strcmp((char *)argv[0], \"tcppm\")) {\n\t\tchilddef.pf = tcppmchild;\n\t\tchilddef.port = 0;\n\t\tchilddef.isudp = 0;\n\t\tchilddef.service = S_TCPPM;\n\t\tchilddef.helpmessage = \"\";\n\t}\n\telse if(!strcmp((char *)argv[0], \"icqpr\")) {\n\t\tchilddef.pf = icqprchild;\n\t\tchilddef.port = 0;\n\t\tchilddef.isudp = 0;\n\t\tchilddef.service = S_ICQPR;\n\t\tchilddef.helpmessage = \"\";\n\t}\n/*\n\telse if(!strcmp((char *)argv[0], \"msnpr\")) {\n\t\tchilddef.pf = msnprchild;\n\t\tchilddef.port = 0;\n\t\tchilddef.isudp = 0;\n\t\tchilddef.service = S_MSNPR;\n\t\tchilddef.helpmessage = \"\";\n\t}\n*/\n\telse if(!strcmp((char *)argv[0], \"udppm\")) {\n\t\tchilddef.pf = udppmchild;\n\t\tchilddef.port = 0;\n\t\tchilddef.isudp = 1;\n\t\tchilddef.service = S_UDPPM;\n\t\tchilddef.helpmessage = \" -s single packet UDP service for request/reply (DNS-like) services\\n\";\n\t}\n\telse if(!strcmp((char *)argv[0], \"admin\")) {\n\t\tchilddef.pf = adminchild;\n\t\tchilddef.port = 80;\n\t\tchilddef.isudp = 0;\n\t\tchilddef.service = S_ADMIN;\n\t}\n\telse if(!strcmp((char *)argv[0], \"dnspr\")) {\n\t\tchilddef.pf = dnsprchild;\n\t\tchilddef.port = 53;\n\t\tchilddef.isudp = 1;\n\t\tchilddef.service = S_DNSPR;\n\t\tchilddef.helpmessage = \" -s - simple DNS forwarding - do not use 3proxy resolver / name cache\\n\";\n#ifndef NOIPV6\n\t\tif(!resolvfunc || (resolvfunc == myresolver && !dns_table.hashsize) || resolvfunc == fakeresolver){\n\t\t\tfprintf(stderr, \"[line %d] Warning: no nserver/nscache configured, dnspr will not work as expected\\n\", linenum);\n\t\t}\n#endif\n\t}\n\treturn start_proxy_thread(&ch);\n}\n\nstatic int h_internal(int argc, unsigned char ** argv){\n\tgetip46(46, argv[1], (struct sockaddr *)&conf.intsa);\n\treturn 0;\n}\n\nstatic int h_external(int argc, unsigned char ** argv){\n\tint res;\n#ifndef NOIPV6\n\tstruct sockaddr_in6 sa6;\n\tmemset(&sa6, 0, sizeof(sa6));\n\tres = getip46(46, argv[1], (struct sockaddr *)&sa6);\n\tif(!res) return 1; \n\tif (*SAFAMILY(&sa6)==AF_INET) conf.extsa = sa6;\n\telse conf.extsa6 = sa6;\n#else\n\tres = getip46(46, argv[1], (struct sockaddr *)&conf.extsa);\n#endif\n\treturn 0;\n}\n\nstatic int h_log(int argc, unsigned char ** argv){ \n\tunsigned char tmpbuf[8192];\n\tconf.logfunc = logstdout;\n\tif(conf.logtarget){\n\t\tmyfree(conf.logtarget);\n\t\tconf.logtarget = NULL;\n\t}\n\tif(argc > 1) {\n\t\tconf.logtarget = (unsigned char *)mystrdup((char *)argv[1]);\n\t\tif(*argv[1]=='@'){\n#ifndef _WIN32\n\t\t\topenlog((char *)conf.logtarget+1, LOG_PID, LOG_DAEMON);\n\t\t\tconf.logfunc = logsyslog;\n#endif\n\t\t}\n#ifndef NOODBC\n\t\telse if(*argv[1]=='&'){\n\t\t\tpthread_mutex_lock(&log_mutex);\n\t\t\tclose_sql();\n\t\t\tinit_sql((char *)argv[1]+1);\n\t\t\tpthread_mutex_unlock(&log_mutex);\n\t\t\tconf.logfunc = logsql;\n\t\t}\n#endif\n\t\telse {\n\t\t\tFILE *fp;\n\t\t\tif(argc > 2) {\n\t\t\t\tconf.logtype = getrotate(*argv[2]);\n\t\t\t}\n\t\t\tconf.logtime = time(0);\n\t\t\tif(conf.logname)myfree(conf.logname);\n\t\t\tconf.logname = (unsigned char *)mystrdup((char *)argv[1]);\n\t\t\tfp = fopen((char *)dologname (tmpbuf, conf.logname, NULL, conf.logtype, conf.logtime), \"a\");\n\t\t\tif(!fp){\n\t\t\t\tperror((char *)tmpbuf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(conf.stdlog)fclose(conf.stdlog);\n\t\t\t\tconf.stdlog = fp;\n#ifdef _WINCE\n\t\t\t\tfreopen(tmpbuf, \"w\", stdout);\n\t\t\t\tfreopen(tmpbuf, \"w\", stderr);\n#endif\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int h_stacksize(int argc, unsigned char **argv){\n\tconf.stacksize = atoi((char *)argv[1]);\n\treturn 0;\n}\n\n\nstatic int h_force(int argc, unsigned char **argv){\n\tconf.noforce = 0;\n\treturn 0;\n}\n\nstatic int h_noforce(int argc, unsigned char **argv){\n\tconf.noforce = 1;\n\treturn 0;\n}\n\nstatic int h_service(int argc, unsigned char **argv){\n\treturn 0;\n}\n\nstatic int h_daemon(int argc, unsigned char **argv){\n\tif(!conf.demon)daemonize();\n\tconf.demon = 1;\n\treturn 0;\n}\n\nstatic int h_config(int argc, unsigned char **argv){\n\tif(conf.conffile)myfree(conf.conffile);\n\tconf.conffile = mystrdup((char *)argv[1]);\n\treturn 0;\n}\n\nstatic int h_include(int argc, unsigned char **argv){\n\tint res;\n\tFILE *fp1;\n\n\tfp1 = fopen((char *)argv[1], \"r\");\n\tif(!fp1){\n\t\tfprintf(stderr, \"Unable to open included file: %s\\n\", argv[1]);\n\t\treturn 1;\n\t}\n\tres = readconfig(fp1);\n\tfclose(fp1);\n\treturn res;\n}\n\nstatic int h_archiver(int argc, unsigned char **argv){\n\tint j;\n\n\tconf.archiver = myalloc(argc * sizeof(char *));\n\tif(conf.archiver) {\n\t\tconf.archiverc = argc;\n\t\tfor(j = 0; j < conf.archiverc; j++) conf.archiver[j] = (unsigned char *)mystrdup((char *)argv[j]);\n\t}\n\treturn 0;\n}\n\nstatic int h_counter(int argc, unsigned char **argv){\n\tstruct counter_header ch1;\n\tif(conf.counterd >=0)close(conf.counterd);\n\tif(!conf.trafcountfunc) conf.trafcountfunc = trafcountfunc;\n\tconf.counterd = open((char *)argv[1], O_BINARY|O_RDWR|O_CREAT, 0660);\n\tif(conf.counterd<0){\n\t\tfprintf(stderr, \"Unable to open counter file %s, line %d\\n\", argv[1], linenum);\n\t\treturn 1;\n\t}\n\tif(read(conf.counterd, &ch1, sizeof(ch1))==sizeof(ch1)){\n\t\tif(memcmp(&ch1, &cheader, 4)){\n\t\t\tfprintf(stderr, \"Not a counter file %s, line %d\\n\", argv[1], linenum);\n\t\t\treturn 2;\n\t\t}\n#ifdef _TIME64_T_DEFINED\n#ifdef _MAX__TIME64_T\n#define MAX_COUNTER_TIME (_MAX__TIME64_T)\n#elif defined (MAX__TIME64_T)\n#define MAX_COUNTER_TIME (MAX__TIME64_T)\n#else\n#define MAX_COUNTER_TIME (0x793406fff)\n#endif \n#else\n#define MAX_COUNTER_TIME ((sizeof(time_t)>4)?(time_t)0x793406fff:(time_t)0x7fffffff)\n#endif\n\n\t\tif(ch1.updated < 0 || ch1.updated >= MAX_COUNTER_TIME){\n\t\t\tfprintf(stderr, \"Invalid or corrupted counter file %s. Use countersutil utility to convert from older version\\n\", argv[1]);\n\t\t\treturn 3;\n\t\t}\n\t\tcheader.updated = ch1.updated;\n\t}\n\tif(argc >=4) {\n\t\tconf.countertype = getrotate(*argv[2]);\n\t\tif(conf.counterfile) myfree(conf.counterfile);\n\t\tconf.counterfile = mystrdup((char *)argv[3]);\n\t}\n\treturn 0;\n}\n\nstatic int h_rotate(int argc, unsigned char **argv){\n\tconf.rotate = atoi((char *)argv[1]);\n\treturn 0;\n}\n\nstatic int h_logformat(int argc, unsigned char **argv){\n\tif(conf.logformat) myfree(conf.logformat);\n\tconf.logformat = (unsigned char *)mystrdup((char *)argv[1]);\n\treturn 0;\n}\n\nstatic int h_timeouts(int argc, unsigned char **argv){\n\tint j;\n\n\tfor(j = 0; conf.timeouts[j] && j + 1 < argc; j++) {\n\t\tif((conf.timeouts[j] = atoi((char *)argv[j + 1])) <= 0 || conf.timeouts[j] > 2000000){\n\t\t\tfprintf(stderr, \"Invalid timeout: %s, line %d\\n\", argv[j + 1], linenum);\n\t\t\treturn(1);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int h_noop(int argc, unsigned char **argv){\n\treturn 0;\n}\n\nstatic int h_auth(int argc, unsigned char **argv){\n\tstruct auth *au, * newau;\n\t\n\tfreeauth(conf.authfuncs);\n\tconf.authfuncs = NULL;\n\tif(!conf.bandlimfunc)conf.bandlimfunc = bandlimitfunc;\n\tfor(argc--; argc; argc--){\n\t  for(au = authfuncs; au; au=au->next){\n\t\tif(!strcmp((char *)argv[argc], au->desc)){\n\t\t\tnewau = myalloc(sizeof(struct auth));\n\t\t\tnewau->next = conf.authfuncs;\n\t\t\tconf.authfuncs = newau;\n\t\t\tconf.authfuncs->desc = au->desc;\n\t\t\tconf.authfuncs->authenticate = au->authenticate;\n\t\t\tconf.authfuncs->authorize = au->authorize;\n\t\t\tbreak;\n\t\t}\n\t  }\n\t  if(!au) return 1;\n\t}\n\tconf.authfunc = doauth;\n\treturn 0;\n}\n\nstatic int h_users(int argc, unsigned char **argv){\n  int j;\n  unsigned char *arg;\n  struct passwords *pwl = NULL;\n\n\tfor (j = 1; j<argc; j++) {\n\t\tif(!(pwl = myalloc(sizeof(struct passwords)))) {\n\t\t\tfprintf(stderr, \"No memory for PWL entry, line %d\\n\", linenum);\n\t\t\treturn(1);\n\t\t}\n\t\tmemset(pwl, 0, sizeof(struct passwords));\n\n\t\targ = (unsigned char *)strchr((char *)argv[j], ':');\n\t\tif(!arg||!arg[1]||!arg[2]||arg[3]!=':')\t{\n\t\t\tpwl->user = (unsigned char *)mystrdup((char *)argv[j]);\n\t\t\tpwl->pwtype = SYS;\n\t\t}\n\t\telse {\n\t\t\t*arg = 0;\n\t\t\tpwl->user = (unsigned char *)mystrdup((char *)argv[j]);\n\t\t\tif((arg[1] == 'C' && arg[2] == 'L' && (pwl->pwtype = CL)) ||\n\t\t\t\t(arg[1] == 'C' && arg[2] == 'R' && (pwl->pwtype = CR)) ||\n\t\t\t\t(arg[1] == 'N' && arg[2] == 'T' && (pwl->pwtype = NT)) ||\n\t\t\t\t(arg[1] == 'L' && arg[2] == 'M' && (pwl->pwtype = LM))){\n\t\t\t\tpwl->password = (unsigned char *)mystrdup((char *)arg+4);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpwl->password = (unsigned char *) mystrdup((char *)arg + 1);\n\t\t\t\tpwl->pwtype = UN;\n\t\t\t}\n\t\t}\n\t\tpthread_mutex_lock(&pwl_mutex);\n\t\tpwl->next = conf.pwl;\n\t\tconf.pwl = pwl;\n\t\tpthread_mutex_unlock(&pwl_mutex);\n\n\n\t}\n\treturn 0;\n}\n\nstatic int h_maxconn(int argc, unsigned char **argv){\n\tconf.maxchild = atoi((char *)argv[1]);\n\tif(!conf.maxchild) {\n\t\treturn(1);\n\t}\n#ifndef _WIN32\n\t{\n\t\tstruct rlimit rl;\n\t\tif(!getrlimit(RLIMIT_NOFILE, &rl)){\n\t\t\tif((conf.maxchild<<1) > rl.rlim_cur)\n\t\t\t\tfprintf(stderr, \"[line %d] Warning: current open file ulimits are too low (cur: %d/max: %d),\"\n\t\t\t\t\t\t\" maxconn requires at least %d for every running service.\"\n\t\t\t\t\t\t\" Configure ulimits according to system documentation\\n\",\n\t\t\t\t\t\t  linenum, (int)rl.rlim_cur, (int)rl.rlim_max, (conf.maxchild<<1));\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int h_flush(int argc, unsigned char **argv){\n\tfreeacl(conf.acl);\n\tconf.acl = NULL;\n\treturn 0;\n}\n\n/*\nstatic int h_flushusers(int argc, unsigned char **argv){\n\tfreepwl(conf.pwl);\n\tconf.pwl = NULL;\n\treturn 0;\n}\n*/\n\nstatic int h_nserver(int argc, unsigned char **argv){\n  char *str;\n\n\tif(numservers < MAXNSERVERS) {\n\t\tif((str = strchr((char *)argv[1], '/')))\n\t\t\t*str = 0;\n\t\t*SAPORT(&nservers[numservers].addr) = htons(53);\n\t\tif(parsehost(46, argv[1], (struct sockaddr *)&nservers[numservers].addr)) return 1;\n\t\tif(str) {\n\t\t\tnservers[numservers].usetcp = strstr(str + 1, \"tcp\")? 1:0;\n\t\t\t*str = '/';\n\t\t}\n\t\tnumservers++;\n\n\t}\n\tresolvfunc = myresolver;\n\treturn 0;\n}\n\nstatic int h_authnserver(int argc, unsigned char **argv){\n  char *str;\n\n\tif((str = strchr((char *)argv[1], '/')))\n\t\t*str = 0;\n\tif(parsehost(46, argv[1], (struct sockaddr *)&authnserver.addr)) return 1;\n\t*SAPORT(&authnserver.addr) = htons(53);\n\tif(str) {\n\t\tauthnserver.usetcp = strstr(str + 1, \"tcp\")? 1:0;\n\t\t*str = '/';\n\t}\n\treturn 0;\n}\n\nstatic int h_fakeresolve(int argc, unsigned char **argv){\n\tresolvfunc = fakeresolver;\n\treturn 0;\n}\n\nstatic int h_nscache(int argc, unsigned char **argv){\n  int res;\n\n\tres = atoi((char *)argv[1]);\n\tif(res < 256) {\n\t\tfprintf(stderr, \"Invalid NS cache size: %d\\n\", res);\n\t\treturn 1;\n\t}\n\tif(inithashtable(&dns_table, (unsigned)res)){\n\t\tfprintf(stderr, \"Failed to initialize NS cache\\n\");\n\t\treturn 2;\n\t}\n\treturn 0;\n}\nstatic int h_nscache6(int argc, unsigned char **argv){\n  int res;\n\n\tres = atoi((char *)argv[1]);\n\tif(res < 256) {\n\t\tfprintf(stderr, \"Invalid NS cache size: %d\\n\", res);\n\t\treturn 1;\n\t}\n\tif(inithashtable(&dns6_table, (unsigned)res)){\n\t\tfprintf(stderr, \"Failed to initialize NS cache\\n\");\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nstatic int h_nsrecord(int argc, unsigned char **argv){\n#ifndef NOIPV6\n\tstruct sockaddr_in6 sa;\n#else\n\tstruct sockaddr_in sa;\n#endif\n\tmemset(&sa, 0, sizeof(sa));\n\tif(!getip46(46, argv[2], (struct sockaddr *)&sa)) return 1;\n\n\thashadd(*SAFAMILY(&sa)==AF_INET6?&dns6_table:&dns_table, argv[1], SAADDR(&sa), (time_t)0xffffffff);\n\treturn 0;\n}\n\nstatic int h_dialer(int argc, unsigned char **argv){\n\tif(conf.demanddialprog) myfree(conf.demanddialprog);\n\tconf.demanddialprog = mystrdup((char *)argv[1]);\n\treturn 0;\n}\n\nstatic int h_system(int argc, unsigned char **argv){\n  int res;\n\n\tif((res = system((char *)argv[1])) == -1){\n\t\tfprintf(stderr, \"Failed to start %s\\n\", argv[1]);\n\t\treturn(1);\n\t}\n\treturn 0;\n}\n\nstatic int h_pidfile(int argc, unsigned char **argv){\n  FILE *pidf;\n\n\tif(!(pidf = fopen((char *)argv[1], \"w\"))){\n\t\tfprintf(stderr, \"Failed to open pid file %s\\n\", argv[1]);\n\t\treturn(1);\n\t}\n\tfprintf(pidf,\"%u\", (unsigned)getpid());\n\tfclose(pidf);\n\treturn 0;\n}\n\nstatic int h_monitor(int argc, unsigned char **argv){\n  struct filemon * fm;\n\n\tfm = myalloc(sizeof (struct filemon));\n\tif(stat((char *)argv[1], &fm->sb)){\n\t\tmyfree(fm);\n\t\tfprintf(stderr, \"Warning: file %s doesn't exist on line %d\\n\", argv[1], linenum);\n\t}\n\telse {\n\t\tfm->path = mystrdup((char *)argv[1]);\n\t\tfm->next = conf.fmon;\n\t\tconf.fmon = fm;\n\t}\n\treturn 0;\n}\n\nstatic int h_parent(int argc, unsigned char **argv){\n  struct ace *acl = NULL;\n  struct chain *chains;\n\n\tacl = conf.acl;\n\twhile(acl && acl->next) acl = acl->next;\n\tif(!acl || (acl->action && acl->action != 2)) {\n\t\tfprintf(stderr, \"Chaining error: last ACL entry was not \\\"allow\\\" or \\\"redirect\\\" on line %d\\n\", linenum);\n\t\treturn(1);\n\t}\n\tacl->action = 2;\n\n\tchains = NULL;\n\tif(!acl->chains) {\n\t\tchains = acl->chains = myalloc(sizeof(struct chain));\n\t}\n\telse {\n\t\tchains = acl->chains;\n\t\twhile(chains->next)chains = chains->next;\n\t\tchains->next = myalloc(sizeof(struct chain));\n\t\tchains = chains->next;\n\t}\n\tmemset(chains, 0, sizeof(struct chain));\n\tif(!chains){\n\t\tfprintf(stderr, \"Chainig error: unable to allocate memory for chain\\n\");\n\t\treturn(2);\n\t}\n\tchains->weight = (unsigned)atoi((char *)argv[1]);\n\tif(chains->weight == 0 || chains->weight >1000) {\n\t\tfprintf(stderr, \"Chaining error: bad chain weight %u line %d\\n\", chains->weight, linenum);\n\t\treturn(3);\n\t}\n\tif(!strcmp((char *)argv[2], \"tcp\"))chains->type = R_TCP;\n\telse if(!strcmp((char *)argv[2], \"http\"))chains->type = R_HTTP;\n\telse if(!strcmp((char *)argv[2], \"connect\"))chains->type = R_CONNECT;\n\telse if(!strcmp((char *)argv[2], \"socks4\"))chains->type = R_SOCKS4;\n\telse if(!strcmp((char *)argv[2], \"socks5\"))chains->type = R_SOCKS5;\n\telse if(!strcmp((char *)argv[2], \"connect+\"))chains->type = R_CONNECTP;\n\telse if(!strcmp((char *)argv[2], \"socks4+\"))chains->type = R_SOCKS4P;\n\telse if(!strcmp((char *)argv[2], \"socks5+\"))chains->type = R_SOCKS5P;\n\telse if(!strcmp((char *)argv[2], \"socks4b\"))chains->type = R_SOCKS4B;\n\telse if(!strcmp((char *)argv[2], \"socks5b\"))chains->type = R_SOCKS5B;\n\telse if(!strcmp((char *)argv[2], \"pop3\"))chains->type = R_POP3;\n\telse if(!strcmp((char *)argv[2], \"ftp\"))chains->type = R_FTP;\n\telse if(!strcmp((char *)argv[2], \"admin\"))chains->type = R_ADMIN;\n\telse if(!strcmp((char *)argv[2], \"icq\"))chains->type = R_ICQ;\n\telse if(!strcmp((char *)argv[2], \"extip\"))chains->type = R_EXTIP;\n\telse if(!strcmp((char *)argv[2], \"smtp\"))chains->type = R_SMTP;\n\telse {\n\t\tfprintf(stderr, \"Chaining error: bad chain type (%s)\\n\", argv[2]);\n\t\treturn(4);\n\t}\n\tif(!getip46(46, argv[3], (struct sockaddr *)&chains->addr)) return 5;\n\t*SAPORT(&chains->addr) = htons((unsigned short)atoi((char *)argv[4]));\n\tif(argc > 5) chains->extuser = (unsigned char *)mystrdup((char *)argv[5]);\n\tif(argc > 6) chains->extpass = (unsigned char *)mystrdup((char *)argv[6]);\n\treturn 0;\n\t\n}\n\nstatic int h_nolog(int argc, unsigned char **argv){\n  struct ace *acl = NULL;\n\n\tacl = conf.acl;\n\tif(!acl) {\n\t\tfprintf(stderr, \"Chaining error: last ACL entry was not \\\"allow/deny\\\" on line %d\\n\", linenum);\n\t\treturn(1);\n\t}\n\twhile(acl->next) acl = acl->next;\n\tif(!strcmp((char *)argv[0],\"nolog\")) acl->nolog = 1;\n\telse acl->weight = atoi((char*)argv[1]);\n\treturn 0;\n}\n\nint scanipl(unsigned char *arg, struct iplist *dst){\n#ifndef NOIPV6\n\tstruct sockaddr_in6 sa;\n#else\n\tstruct sockaddr_in sa;\n#endif\n        char * slash, *dash;\n\tint masklen, addrlen;\n\tif((slash = strchr((char *)arg, '/'))) *slash = 0;\n\tif((dash = strchr((char *)arg,'-'))) *dash = 0;\n\t\n\tif(!getip46(46, arg, (struct sockaddr *)&sa)) return 1;\n\tmemcpy(&dst->ip_from, SAADDR(&sa), SAADDRLEN(&sa));\n\tdst->family = *SAFAMILY(&sa);\n\tif(dash){\n\t\tif(!getip46(46, (unsigned char *)dash+1, (struct sockaddr *)&sa)) return 2;\n\t\tmemcpy(&dst->ip_to, SAADDR(&sa), SAADDRLEN(&sa));\n\t\tif(*SAFAMILY(&sa) != dst->family || memcmp(&dst->ip_to, &dst->ip_from, SAADDRLEN(&sa)) < 0) return 3;\n\t\treturn 0;\n\t}\n\tmemcpy(&dst->ip_to, &dst->ip_from, SAADDRLEN(&sa));\n\tif(slash){\n\t\taddrlen = SAADDRLEN(&sa);\n\t\tmasklen = atoi(slash+1);\n\t\tif(masklen < 0 || masklen > (addrlen*8)) return 4;\n\t\telse {\n\t\t\tint i, nbytes = masklen / 8, nbits = (8 - (masklen % 8)) % 8;\n\n\t\t\tfor(i = addrlen; i>(nbytes + (nbits > 0)); i--){\n\t\t\t\t((unsigned char *)&dst->ip_from)[i-1] = 0x00;\n\t\t\t\t((unsigned char *)&dst->ip_to)[i-1] = 0xff;\n\t\t\t}\n\t\t\tfor(;nbits;nbits--){\n\t\t\t\t((unsigned char *)&dst->ip_from)[nbytes] &= ~(0x01<<(nbits-1));\n\t\t\t\t((unsigned char *)&dst->ip_to)[nbytes] |= (0x01<<(nbits-1));\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\t\t\n\treturn 0;\n}\n\nstruct ace * make_ace (int argc, unsigned char ** argv){\n\tstruct ace * acl;\n\tunsigned char *arg;\n\tstruct iplist *ipl=NULL;\n\tstruct portlist *portl=NULL;\n\tstruct userlist *userl=NULL;\n\tstruct hostname *hostnamel=NULL;\n\tint res;\n\n\tacl = myalloc(sizeof(struct ace));\n\tif(!acl) return acl;\n\tmemset(acl, 0, sizeof(struct ace));\n\t\tif(argc > 0 && strcmp(\"*\", (char *)argv[0])) {\n\t\t\targ = argv[0];\n\t\t\targ = (unsigned char *)strtok((char *)arg, \",\");\n\t\t\tdo {\n\t\t\t\tif(!acl->users) {\n\t\t\t\t\tacl->users = userl = myalloc(sizeof(struct userlist));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuserl->next = myalloc(sizeof(struct userlist));\n\t\t\t\t\tuserl = userl -> next;\n\t\t\t\t}\n\t\t\t\tif(!userl) {\n\t\t\t\t\tfprintf(stderr, \"No memory for ACL entry, line %d\\n\", linenum);\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t\tmemset(userl, 0, sizeof(struct userlist));\n\t\t\t\tuserl->user=(unsigned char*)mystrdup((char *)arg);\n\t\t\t} while((arg = (unsigned char *)strtok((char *)NULL, \",\")));\n\t\t}\n\t\tif(argc > 1  && strcmp(\"*\", (char *)argv[1])) {\n\t\t\targ = (unsigned char *)strtok((char *)argv[1], \",\");\n\t\t\tdo {\n\t\t\t\tif(!acl->src) {\n\t\t\t\t\tacl->src = ipl = myalloc(sizeof(struct iplist));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tipl->next = myalloc(sizeof(struct iplist));\n\t\t\t\t\tipl = ipl -> next;\n\t\t\t\t}\n\t\t\t\tif(!ipl) {\n\t\t\t\t\tfprintf(stderr, \"No memory for ACL entry, line %d\\n\", linenum);\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t\tmemset(ipl, 0, sizeof(struct iplist));\n\t\t\t\tif (scanipl(arg, ipl)) {\n\t\t\t\t\tfprintf(stderr, \"Invalid IP, IP range or CIDR, line %d\\n\", linenum);\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t} while((arg = (unsigned char *)strtok((char *)NULL, \",\")));\n\t\t}\n\t\tif(argc > 2 && strcmp(\"*\", (char *)argv[2])) {\n\t\t\targ = (unsigned char *)strtok((char *)argv[2], \",\");\n\t\t\tdo {\n\t\t\t int arglen;\n\t\t\t unsigned char *pattern;\n\t\t\t \n\t\t\t arglen = (int)strlen((char *)arg);\n\t\t\t if(arglen > 0 && (arg[arglen-1] < '0' || arg[arglen-1] > '9')){\n\t\t\t\tif(!acl->dstnames) {\n\t\t\t\t\tacl->dstnames = hostnamel = myalloc(sizeof(struct hostname));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thostnamel->next = myalloc(sizeof(struct hostname));\n\t\t\t\t\thostnamel = hostnamel -> next;\n\t\t\t\t}\n\t\t\t\tif(!hostnamel){\n\t\t\t\t\tfprintf(stderr, \"No memory for ACL entry, line %d\\n\", linenum);\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t\tmemset(hostnamel, 0, sizeof(struct hostname));\n\t\t\t\thostnamel->matchtype = 3;\n\t\t\t\tpattern = arg;\n\t\t\t\tif(pattern[arglen-1] == '*'){\n\t\t\t\t\targlen --;\n\t\t\t\t\tpattern[arglen] = 0;\n\t\t\t\t\thostnamel->matchtype ^= MATCHEND;\n\t\t\t\t}\n\t\t\t\tif(pattern[0] == '*'){\n\t\t\t\t\tpattern++;\n\t\t\t\t\targlen--;\n\t\t\t\t\thostnamel->matchtype ^= MATCHBEGIN;\n\t\t\t\t}\n\t\t\t\thostnamel->name = (unsigned char *) mystrdup( (char *)pattern);\n\t\t\t\tif(!hostnamel->name) {\n\t\t\t\t\tfprintf(stderr, \"No memory for ACL entry, line %d\\n\", linenum);\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t }\n\t\t\t else {\n\t\t\t\t\n\t\t\t\tif(!acl->dst) {\n\t\t\t\t\tacl->dst = ipl = myalloc(sizeof(struct iplist));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tipl->next = myalloc(sizeof(struct iplist));\n\t\t\t\t\tipl = ipl -> next;\n\t\t\t\t}\n\t\t\t\tif(!ipl) {\n\t\t\t\t\tfprintf(stderr, \"No memory for ACL entry, line %d\\n\", linenum);\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t\tmemset(ipl, 0, sizeof(struct iplist));\n\t\t\t\tif (scanipl(arg, ipl)) {\n\t\t\t\t\t\tfprintf(stderr, \"Invalid IP, IP range or CIDR, line %d\\n\", linenum);\n\t\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t }\n\t\t\t}while((arg = (unsigned char *)strtok((char *)NULL, \",\")));\n\t\t}\n\t\tif(argc > 3 && strcmp(\"*\", (char *)argv[3])) {\n\t\t\targ = (unsigned char *)strtok((char *)argv[3], \",\");\n\t\t\tdo {\n\t\t\t\tif(!acl->ports) {\n\t\t\t\t\tacl->ports = portl = myalloc(sizeof(struct portlist));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tportl->next = myalloc(sizeof(struct portlist));\n\t\t\t\t\tportl = portl -> next;\n\t\t\t\t}\n\t\t\t\tif(!portl) {\n\t\t\t\t\tfprintf(stderr, \"No memory for ACL entry, line %d\\n\", linenum);\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t\tmemset(portl, 0, sizeof(struct portlist));\n\t\t\t\tres = sscanf((char *)arg, \"%hu-%hu\", &portl->startport, &portl->endport);\n\t\t\t\tif(res < 1) {\n\t\t\t\t\tfprintf(stderr, \"Invalid port or port range, line %d\\n\", linenum);\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t\tif (res == 1) portl->endport = portl->startport;\n\t\t\t} while((arg = (unsigned char *)strtok((char *)NULL, \",\")));\n\t\t}\n\t\tif(argc > 4 && strcmp(\"*\", (char *)argv[4])) {\n\t\t\targ = (unsigned char *)strtok((char *)argv[4], \",\");\t\n\t\t\tdo {\n\t\t\t\tif(!strcmp((char *)arg, \"CONNECT\")){\n\t\t\t\t\tacl->operation |= CONNECT;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"BIND\")){\n\t\t\t\t\tacl->operation |= BIND;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"UDPASSOC\")){\n\t\t\t\t\tacl->operation |= UDPASSOC;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"ICMPASSOC\")){\n\t\t\t\t\tacl->operation |= ICMPASSOC;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"HTTP_GET\")){\n\t\t\t\t\tacl->operation |= HTTP_GET;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"HTTP_PUT\")){\n\t\t\t\t\tacl->operation |= HTTP_PUT;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"HTTP_POST\")){\n\t\t\t\t\tacl->operation |= HTTP_POST;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"HTTP_HEAD\")){\n\t\t\t\t\tacl->operation |= HTTP_HEAD;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"HTTP_OTHER\")){\n\t\t\t\t\tacl->operation |= HTTP_OTHER;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"HTTP_CONNECT\")){\n\t\t\t\t\tacl->operation |= HTTP_CONNECT;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"HTTP\")){\n\t\t\t\t\tacl->operation |= HTTP;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"HTTPS\")){\n\t\t\t\t\tacl->operation |= HTTPS;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"FTP_GET\")){\n\t\t\t\t\tacl->operation |= FTP_GET;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"FTP_PUT\")){\n\t\t\t\t\tacl->operation |= FTP_PUT;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"FTP_LIST\")){\n\t\t\t\t\tacl->operation |= FTP_LIST;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"FTP_DATA\")){\n\t\t\t\t\tacl->operation |= FTP_DATA;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"FTP\")){\n\t\t\t\t\tacl->operation |= FTP;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"ADMIN\")){\n\t\t\t\t\tacl->operation |= ADMIN;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"DNSRESOLVE\")){\n\t\t\t\t\tacl->operation |= DNSRESOLVE;\n\t\t\t\t}\n\t\t\t\telse if(!strcmp((char *)arg, \"ICQ\")){\n\t\t\t\t\tacl->operation |= IM_ICQ;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfprintf(stderr, \"Unknown operation type: %s line %d\\n\", arg, linenum);\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t} while((arg = (unsigned char *)strtok((char *)NULL, \",\")));\n\t\t}\n\t\tif(argc > 5){\n\t\t\tfor(arg = argv[5]; *arg;){\n\t\t\t\tint val, val1;\n\n\t\t\t\tif(!isnumber(*arg)){\n\t\t\t\t\targ++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tval1 = val = (*arg - '0');\n\t\t\t\targ++;\n\t\t\t\tif(*arg == '-' && isnumber(*(arg+1)) && (*(arg+1) - '0') > val) {\n\t\t\t\t\tval1 = (*(arg+1) - '0');\n\t\t\t\t\targ+=2;\n\t\t\t\t}\n\t\t\t\tfor(; val<=val1; val++) acl->wdays |= (1 << (val % 7));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(argc > 6){\n\t\t\tfor(arg = argv[6]; strlen((char *)arg) >= 17 &&\n\t\t\t\t\t\t\tisdigit(arg[0]) &&\n\t\t\t\t\t\t\tisdigit(arg[1]) &&\n\t\t\t\t\t\t\tisdigit(arg[3]) &&\n\t\t\t\t\t\t\tisdigit(arg[4]) &&\n\t\t\t\t\t\t\tisdigit(arg[6]) &&\n\t\t\t\t\t\t\tisdigit(arg[7]) &&\n\t\t\t\t\t\t\tisdigit(arg[9]) &&\n\t\t\t\t\t\t\tisdigit(arg[10]) &&\n\t\t\t\t\t\t\tisdigit(arg[12]) &&\n\t\t\t\t\t\t\tisdigit(arg[13]) &&\n\t\t\t\t\t\t\tisdigit(arg[15]) &&\n\t\t\t\t\t\t\tisdigit(arg[16])\n\t\t\t\t\t\t\t; arg+=18){\n\n\t\t\t\tint t1, t2;\n\t\t\t\tstruct period *sp;\n\n\t\t\t\tt1 = (arg[0] - '0') * 10 + (arg[1] - '0');\n\t\t\t\tt1 = (t1 * 60) + (arg[3] - '0') * 10 + (arg[4] - '0');\n\t\t\t\tt1 = (t1 * 60) + (arg[6] - '0') * 10 + (arg[7] - '0');\n\t\t\t\tt2 = (arg[9] - '0') * 10 + (arg[10] - '0');\n\t\t\t\tt2 = (t2 * 60) + (arg[12] - '0') * 10 + (arg[13] - '0');\n\t\t\t\tt2 = (t2 * 60) + (arg[15] - '0') * 10 + (arg[16] - '0');\n\t\t\t\tif(t2 < t1) break;\n\t\t\t\tsp = myalloc(sizeof(struct period));\n\t\t\t\tif(sp){\n\t\t\t\t\tsp->fromtime = t1;\n\t\t\t\t\tsp->totime = t2;\n\t\t\t\t\tsp->next = acl->periods;\n\t\t\t\t\tacl->periods = sp;\n\t\t\t\t}\n\t\t\t\tif(arg[17]!=',') break;\n\t\t\t}\n\t\t}\n\tif (argc > 7){\n\t\tacl->weight = atoi((char *)argv[7]);\n\t}\n\n\treturn acl;\n}\n\n\nstatic int h_ace(int argc, unsigned char **argv){\n  int res = 0;\n  int offset = 0;\n  struct ace *acl = NULL;\n  struct bandlim * nbl;\n  struct trafcount * tl;\n\n\tif(!strcmp((char *)argv[0], \"allow\")){\n\t\tres = ALLOW;\n\t}\n\telse if(!strcmp((char *)argv[0], \"deny\")){\n\t\tres = DENY;\n\t}\n\telse if(!strcmp((char *)argv[0], \"redirect\")){\n\t\tres = REDIRECT;\n\t\toffset = 2;\n\t}\n\telse if(!strcmp((char *)argv[0], \"bandlimin\")||!strcmp((char *)argv[0], \"bandlimout\")){\n\t\tres = BANDLIM;\n\t\toffset = 1;\n\t}\n\telse if(!strcmp((char *)argv[0], \"nobandlimin\")||!strcmp((char *)argv[0], \"nobandlimout\")){\n\t\tres = NOBANDLIM;\n\t}\n\telse if(!strcmp((char *)argv[0], \"countin\")){\n\t\tres = COUNTIN;\n\t\toffset = 3;\n\t}\n\telse if(!strcmp((char *)argv[0], \"nocountin\")){\n\t\tres = NOCOUNTIN;\n\t}\n\telse if(!strcmp((char *)argv[0], \"countout\")){\n\t\tres = COUNTOUT;\n\t\toffset = 3;\n\t}\n\telse if(!strcmp((char *)argv[0], \"nocountout\")){\n\t\tres = NOCOUNTOUT;\n\t}\n\tacl = make_ace(argc - (offset+1), argv + (offset + 1));\n\tif(!acl) {\n\t\tfprintf(stderr, \"Unable to parse ACL entry, line %d\\n\", linenum);\n\t\treturn(1);\n\t}\n\tacl->action = res;\n\tswitch(acl->action){\n\tcase REDIRECT:\n\t\tacl->chains = myalloc(sizeof(struct chain));\n\t\tmemset(acl->chains, 0, sizeof(struct chain)); \n\t\tif(!acl->chains) {\n\t\t\tfprintf(stderr, \"No memory for ACL entry, line %d\\n\", linenum);\n\t\t\treturn(2);\n\t\t}\n\t\tacl->chains->type = R_HTTP;\n\t\tif(!getip46(46, argv[1], (struct sockaddr *)&acl->chains->addr)) return 5;\n\t\t*SAPORT(&acl->chains->addr) = htons((unsigned short)atoi((char *)argv[2]));\n\t\tacl->chains->weight = 1000;\n\t\tacl->chains->extuser = NULL;\n\t\tacl->chains->extpass = NULL;\n\t\tacl->chains->next = NULL;\n\tcase ALLOW:\n\tcase DENY:\n\t\tif(!conf.acl){\n\t\t\tconf.acl = acl;\n\t\t}\n\t\telse {\n\t\t\tstruct ace * acei;\n\n\t\t\tfor(acei = conf.acl; acei->next; acei = acei->next);\n\t\t\tacei->next = acl;\n\t\t}\n\t\tbreak;\n\tcase BANDLIM:\n\tcase NOBANDLIM:\n\n\t\tnbl = myalloc(sizeof(struct bandlim));\n\t\tif(!nbl) {\n\t\t\tfprintf(stderr, \"No memory to create band limit filter\\n\");\n\t\t\treturn(3);\n\t\t}\n\t\tmemset(nbl, 0, sizeof(struct bandlim));\n\t\tnbl->ace = acl;\n\t\tif(acl->action == BANDLIM) {\n\t\t\tsscanf((char *)argv[1], \"%u\", &nbl->rate);\n\t\t\tif(nbl->rate < 300) {\n\t\t\t\tfprintf(stderr, \"Wrong bandwidth specified, line %d\\n\", linenum);\n\t\t\t\treturn(4);\n\t\t\t}\n\t\t}\n\t\tpthread_mutex_lock(&bandlim_mutex);\n\t\tif(!strcmp((char *)argv[0], \"bandlimin\") || !strcmp((char *)argv[0], \"nobandlimin\")){\n\t\t\tif(!conf.bandlimiter){\n\t\t\t\tconf.bandlimiter = nbl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstruct bandlim * bli;\n\n\t\t\t\tfor(bli = conf.bandlimiter; bli->next; bli = bli->next);\n\t\t\t\tbli->next = nbl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(!conf.bandlimiterout){\n\t\t\t\tconf.bandlimiterout = nbl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstruct bandlim * bli;\n\n\t\t\t\tfor(bli = conf.bandlimiterout; bli->next; bli = bli->next);\n\t\t\t\tbli->next = nbl;\n\t\t\t}\n\t\t}\n\n\t\tpthread_mutex_unlock(&bandlim_mutex);\t\t\t\n\t\tbreak;\n\n\tcase COUNTIN:\n\tcase NOCOUNTIN:\n\tcase COUNTOUT:\n\tcase NOCOUNTOUT:\n\t\ttl = myalloc(sizeof(struct trafcount));\n\t\tif(!tl) {\n\t\t\tfprintf(stderr, \"No memory to create traffic limit filter\\n\");\n\t\t\treturn(5);\n\t\t}\n\t\tmemset(tl, 0, sizeof(struct trafcount));\n\t\ttl->ace = acl;\n\t\n\t\tif((acl->action == COUNTIN)||(acl->action == COUNTOUT)) {\n\t\t\tunsigned long lim;\n\n\t\t\ttl->comment = ( char *)argv[1];\n\t\t\twhile(isdigit(*tl->comment))tl->comment++;\n\t\t\tif(*tl->comment== '/')tl->comment++;\n\t\t\ttl->comment = mystrdup(tl->comment);\n\n\t\t\tsscanf((char *)argv[1], \"%u\", &tl->number);\n\t\t\tsscanf((char *)argv[3], \"%lu\", &lim);\n\t\t\ttl->type = getrotate(*argv[2]);\n\t\t\ttl->traflim64 =  ((uint64_t)lim)*(1024*1024);\n\t\t\tif(!tl->traflim64) {\n\t\t\t\tfprintf(stderr, \"Wrong traffic limit specified, line %d\\n\", linenum);\n\t\t\t\treturn(6);\n\t\t\t}\n\t\t\tif(tl->number != 0 && conf.counterd >= 0) {\n\t\t\t\tlseek(conf.counterd, \n\t\t\t\t\tsizeof(struct counter_header) + (tl->number - 1) * sizeof(struct counter_record),\n\t\t\t\t\tSEEK_SET);\n\t\t\t\tmemset(&crecord, 0, sizeof(struct counter_record));\n\t\t\t\tread(conf.counterd, &crecord, sizeof(struct counter_record));\n\t\t\t\ttl->traf64 = crecord.traf64;\n\t\t\t\ttl->cleared = crecord.cleared;\n\t\t\t\ttl->updated = crecord.updated;\n\t\t\t\tif(tl->cleared < 0 || tl->cleared >=  MAX_COUNTER_TIME || tl->updated < 0 || tl->updated >=  MAX_COUNTER_TIME){\n\t\t\t\t\tfprintf(stderr, \"Invalid, incompatible or corrupted counter file.\\n\");\n\t\t\t\t\treturn(6);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpthread_mutex_lock(&tc_mutex);\n\t\tif(!conf.trafcounter){\n\t\t\tconf.trafcounter = tl;\n\t\t}\n\t\telse {\n\t\t\tstruct trafcount * ntl;\n\n\t\t\tfor(ntl = conf.trafcounter; ntl->next; ntl = ntl->next);\n\t\t\tntl->next = tl;\n\t\t}\n\t\tpthread_mutex_unlock(&tc_mutex);\n\t\t\t\n\t}\n\treturn 0;\n}\n\nstatic int h_logdump(int argc, unsigned char **argv){\n\tconf.logdumpsrv = (unsigned) atoi((char *) *(argv + 1));\n\tif(argc > 2) conf.logdumpcli = (unsigned) atoi((char *) *(argv + 2));\n\treturn 0;\n}\n\n\nstatic int h_filtermaxsize(int argc, unsigned char **argv){\n\tconf.filtermaxsize = atoi((char *) *(argv + 1));\n\treturn 0;\n}\n\nstatic int h_delimchar(int argc, unsigned char **argv){\n\tconf.delimchar = *argv[1];\n\treturn 0;\n}\n\nstatic int h_authcache(int argc, unsigned char **argv){\n\tconf.authcachetype = 0;\n\tif(strstr((char *) *(argv + 1), \"ip\")) conf.authcachetype |= 1;\n\tif(strstr((char *) *(argv + 1), \"user\")) conf.authcachetype |= 2;\n\tif(strstr((char *) *(argv + 1), \"pass\")) conf.authcachetype |= 4;\n\tif(argc > 2) conf.authcachetime = (unsigned) atoi((char *) *(argv + 2));\n\tif(!conf.authcachetype) conf.authcachetype = 6;\n\tif(!conf.authcachetime) conf.authcachetime = 600;\n\treturn 0;\n}\n\nstatic int h_plugin(int argc, unsigned char **argv){\n#ifdef NOPLUGINS\n\treturn 999;\n#else\n#ifdef _WIN32\n\tHINSTANCE hi;\n\tFARPROC fp;\n\n#ifdef _WINCE\n\thi = LoadLibraryW((LPCWSTR)CEToUnicode(argv[1]));\n#else\n\thi = LoadLibrary((char *)argv[1]);\n#endif\n\tif(!hi) {\n\t\tfprintf(stderr, \"Failed to load %s, code %d\\n\", argv[1], (int)GetLastError());\n\t\treturn 1;\n\t}\n#ifdef _WINCE\n\tfp = GetProcAddressW(hi, (LPCWSTR)CEToUnicode(argv[2]));\n#else\n\tfp = GetProcAddress(hi, (char *)argv[2]);\n#endif\n\tif(!fp) {\n\t\tprintf(\"%s not found in %s, code: %d\\n\", argv[2], argv[1], (int)GetLastError());\n\t\treturn 2;\n\t}\n\treturn (*(PLUGINFUNC)fp)(&pluginlink, argc - 2, (char **)argv + 2);\n#else\t\n\tvoid *hi, *fp;\n\thi = dlopen((char *)argv[1], RTLD_LAZY);\n\tif(!hi) return 1;\n\tfp = dlsym(hi, (char *)argv[2]);\n\tif(!fp) return 2;\n\treturn (*(PLUGINFUNC)fp)(&pluginlink, argc - 2, (char **)argv + 2);\n#endif\n#endif\n}\n\n#ifndef _WIN32\nstatic int h_setuid(int argc, unsigned char **argv){\n  int res;\n\tres = atoi((char *)argv[1]);\n\tif(!res || setreuid(res,res)) {\n\t\tfprintf(stderr, \"Unable to set uid %d\", res);\n\t\treturn(1);\n\t}\n\treturn 0;\n}\n\nstatic int h_setgid(int argc, unsigned char **argv){\n  int res;\n\n\tres = atoi((char *)argv[1]);\n\tif(!res || setregid(res,res)) {\n\t\tfprintf(stderr, \"Unable to set gid %d\", res);\n\t\treturn(1);\n\t}\n\treturn 0;\n}\n\n\nstatic int h_chroot(int argc, unsigned char **argv){\n\tif(!chrootp){\n\t\tchar *p;\n\t\tif(chroot((char *)argv[1])) {\n\t\t\tfprintf(stderr, \"Unable to chroot %s\", argv[1]);\n\t\t\treturn(1);\n\t\t}\n\t\tp = (char *)argv[1] + strlen((char *)argv[1]) ;\n\t\twhile (p > (char *)argv[1] && p[-1] == '/'){\n\t\t\tp--;\n\t\t\t*p = 0;\n\t\t}\n\t\tchrootp = mystrdup((char *)argv[1]);\n\t}\n\treturn 0;\n}\n#endif\n\n\nstruct commands specificcommands[]={\n#ifndef _WIN32\n\t{specificcommands+1, \"setuid\", h_setuid, 2, 2},\n\t{specificcommands+2, \"setgid\", h_setgid, 2, 2},\n\t{specificcommands+3, \"chroot\", h_chroot, 2, 2},\n#endif\n\t{NULL, \t\t\"\", h_noop, 1, 0}\n};\n\nstruct commands commandhandlers[]={\n\t{commandhandlers+1,  \"\", h_noop, 1, 0},\n\t{commandhandlers+2,  \"proxy\", h_proxy, 1, 0},\n\t{commandhandlers+3,  \"pop3p\", h_proxy, 1, 0},\n\t{commandhandlers+4,  \"ftppr\", h_proxy, 1, 0},\n\t{commandhandlers+5,  \"socks\", h_proxy, 1, 0},\n\t{commandhandlers+6,  \"tcppm\", h_proxy, 4, 0},\n\t{commandhandlers+7,  \"udppm\", h_proxy, 4, 0},\n\t{commandhandlers+8,  \"admin\", h_proxy, 1, 0},\n\t{commandhandlers+9,  \"dnspr\", h_proxy, 1, 0},\n\t{commandhandlers+10,  \"internal\", h_internal, 2, 2},\n\t{commandhandlers+11, \"external\", h_external, 2, 2},\n\t{commandhandlers+12, \"log\", h_log, 1, 0},\n\t{commandhandlers+13, \"service\", h_service, 1, 1},\n\t{commandhandlers+14, \"daemon\", h_daemon, 1, 1},\n\t{commandhandlers+15, \"config\", h_config, 2, 2},\n\t{commandhandlers+16, \"include\", h_include, 2, 2},\n\t{commandhandlers+17, \"archiver\", h_archiver, 3, 0},\n\t{commandhandlers+18, \"counter\", h_counter, 2, 4},\n\t{commandhandlers+19, \"rotate\", h_rotate, 2, 2},\n\t{commandhandlers+20, \"logformat\", h_logformat, 2, 2},\n\t{commandhandlers+21, \"timeouts\", h_timeouts, 2, 0},\n\t{commandhandlers+22, \"auth\", h_auth, 2, 0},\n\t{commandhandlers+23, \"users\", h_users, 2, 0},\n\t{commandhandlers+24, \"maxconn\", h_maxconn, 2, 2},\n\t{commandhandlers+25, \"flush\", h_flush, 1, 1},\n\t{commandhandlers+26, \"nserver\", h_nserver, 2, 2},\n\t{commandhandlers+27, \"fakeresolve\", h_fakeresolve, 1, 1},\n\t{commandhandlers+28, \"nscache\", h_nscache, 2, 2},\n\t{commandhandlers+29, \"nscache6\", h_nscache6, 2, 2},\n\t{commandhandlers+30, \"nsrecord\", h_nsrecord, 3, 3},\n\t{commandhandlers+31, \"dialer\", h_dialer, 2, 2},\n\t{commandhandlers+32, \"system\", h_system, 2, 2},\n\t{commandhandlers+33, \"pidfile\", h_pidfile, 2, 2},\n\t{commandhandlers+34, \"monitor\", h_monitor, 2, 2},\n\t{commandhandlers+35, \"parent\", h_parent, 5, 0},\n\t{commandhandlers+36, \"allow\", h_ace, 1, 0},\n\t{commandhandlers+37, \"deny\", h_ace, 1, 0},\n\t{commandhandlers+38, \"redirect\", h_ace, 3, 0},\n\t{commandhandlers+39, \"bandlimin\", h_ace, 2, 0},\n\t{commandhandlers+40, \"bandlimout\", h_ace, 2, 0},\n\t{commandhandlers+41, \"nobandlimin\", h_ace, 1, 0},\n\t{commandhandlers+42, \"nobandlimout\", h_ace, 1, 0},\n\t{commandhandlers+43, \"countin\", h_ace, 4, 0},\n\t{commandhandlers+44, \"nocountin\", h_ace, 1, 0},\n\t{commandhandlers+45, \"countout\", h_ace, 4, 0},\n\t{commandhandlers+46, \"nocountout\", h_ace, 1, 0},\n\t{commandhandlers+47, \"plugin\", h_plugin, 3, 0},\n\t{commandhandlers+48, \"logdump\", h_logdump, 2, 3},\n\t{commandhandlers+49, \"filtermaxsize\", h_filtermaxsize, 2, 2},\n\t{commandhandlers+50, \"nolog\", h_nolog, 1, 1},\n\t{commandhandlers+51, \"weight\", h_nolog, 2, 2},\n\t{commandhandlers+52, \"authcache\", h_authcache, 2, 3},\n\t{commandhandlers+53, \"smtpp\", h_proxy, 1, 0},\n\t{commandhandlers+54, \"icqpr\", h_proxy, 4, 0},\n\t{commandhandlers+55, \"msnpr\", h_proxy, 4, 0},\n\t{commandhandlers+56, \"delimchar\",h_delimchar, 2, 2},\n\t{commandhandlers+57, \"authnserver\", h_authnserver, 2, 2},\n\t{commandhandlers+58, \"stacksize\", h_stacksize, 2, 2},\n\t{commandhandlers+59, \"force\", h_force, 1, 1},\n\t{commandhandlers+60, \"noforce\", h_noforce, 1, 1},\n\t{specificcommands, \t \"\", h_noop, 1, 0}\n};\n\nint parsestr (unsigned char *str, unsigned char **argm, int nitems, unsigned char ** buff, int *inbuf, int *bufsize){\n#define buf (*buff)\n\tint argc = 0;\n\tint space = 1;\n\tint comment = 0;\n\tunsigned char * incbegin = 0;\n\tint fd;\n\tint res, len;\n\tunsigned char *str1;\n\n\tfor(;;str++){\n\t if(*str == '\\\"'){\n\t\tstr1 = str;\n\t\tdo {\n\t\t\t*str1 = *(str1 + 1);\n\t\t}while(*(str1++));\n\t\tif(!comment || *str != '\\\"'){\n\t\t\tcomment = !comment;\n\t\t}\n\t }\n         switch(*str){\n\t\tcase '\\0': \n\t\t\tif(comment) return -1;\n\t\t\targm[argc] = 0;\n\t\t\treturn argc;\n\t\tcase '$':\n\t\t\tif(comment){\n\t\t\t\tif(space){\n\t\t\t\t\targm[argc++] = str;\n\t\t\t\t\tif(argc >= nitems) return argc;\n\t\t\t\t\tspace = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(!included){\n\t\t\t\tincbegin = str;\n\t\t\t\t*str = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\r':\n\t\tcase '\\n':\n\t\tcase '\\t':\n\t\tcase ' ':\n\t\t\tif(!comment){\n\t\t\t\t*str = 0;\n\t\t\t\tspace = 1;\n\t\t\t\tif(incbegin){\n\t\t\t\t\targc--;\n\t\t\t\t\tif((fd = open((char *)incbegin+1, O_RDONLY)) <= 0){\n\t\t\t\t\t\tfprintf(stderr, \"Failed to open %s\\n\", incbegin+1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((*bufsize - *inbuf) <STRINGBUF){\n\t\t\t\t\t\t*bufsize += STRINGBUF;\n\t\t\t\t\t\tif(!(buf = myrealloc(buf, *bufsize))){\n\t\t\t\t\t\t\tfprintf(stderr, \"Failed to allocate memory for %s\\n\", incbegin+1);\n\t\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tif(argm[argc]!=(incbegin+1)) {\n\t\t\t\t\t\tlen = (int)strlen((char *)argm[argc]);\n\t\t\t\t\t\tmemmove(buf+*inbuf, argm[argc], len);\n\t\t\t\t\t}\n\t\t\t\t\tif((res = read(fd, buf+*inbuf+len, STRINGBUF-(1+len))) <= 0) {\n\t\t\t\t\t\tperror((char *)incbegin+1);\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tclose(fd);\n\t\t\t\t\tbuf[*inbuf+res+len] = 0;\n\t\t\t\t\tincbegin = buf + *inbuf;\n\t\t\t\t\t(*inbuf) += (res + len + 1);\n\t\t\t\t\tincluded++;\n\t\t\t\t\targc+=parsestr(incbegin, argm + argc, nitems - argc, buff, inbuf, bufsize);\n\t\t\t\t\tincluded--;\n\t\t\t\t\tincbegin = NULL;\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tif(space) {\n\t\t\t\tif(comment && *str == '\\\"' && str[1] != '\\\"'){\n\t\t\t\t\tstr++;\n\t\t\t\t\tcomment = 0;\n\t\t\t\t}\n\t\t\t\targm[argc++] = str;\n\t\t\t\tif(argc >= nitems) return argc;\n\t\t\t\tspace = 0;\n\t\t\t}\n\t }\n\t}\n#undef buf\n}\n\n\nint readconfig(FILE * fp){\n unsigned char ** argv = NULL;\n unsigned char * buf = NULL;\n  int bufsize = STRINGBUF*2;\n  int inbuf = 0;\n  int argc;\n  struct commands * cm;\n  int res = 0;\n\n  if( !(buf = myalloc(bufsize)) || ! (argv = myalloc((NPARAMS + 1) * sizeof(unsigned char *))) ) {\n\t\tfprintf(stderr, \"No memory for configuration\");\n\t\treturn(10);\n  }\n  for (linenum = 1; fgets((char *)buf, STRINGBUF, fp); linenum++){\n\tif(!*buf || isspace(*buf) || (*buf) == '#')continue;\n\n\tinbuf = (int)(strlen((char *)buf) + 1);\n\targc = parsestr (buf, argv, NPARAMS-1, &buf, &inbuf, &bufsize);\n\tif(argc < 1) {\n\t\tfprintf(stderr, \"Parse error line %d\\n\", linenum);\n\t\treturn(21);\n\t}\n\targv[argc] = NULL;\n\tif(!strcmp((char *)argv[0], \"end\") && argc == 1) {\t\n\t\tbreak;\n\t}\n\telse if(!strcmp((char *)argv[0], \"writable\") && argc == 1) {\t\n\t\tif(!writable){\n\t\t\twritable = freopen(curconf, \"r+\", fp);\n\t\t\tif(!writable){\n\t\t\t\tfprintf(stderr, \"Unable to reopen config for writing: %s\\n\", curconf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tcontinue;\n\t}\n\n\tres = 1;\n\tfor(cm = commandhandlers; cm; cm = cm->next){\n\t\tif(!strcmp((char *)argv[0], (char *)cm->command) && argc >= cm->minargs && (!cm->maxargs || argc <= cm->maxargs)){\n\t\t\tres = (*cm->handler)(argc, argv);\n\t\t\tif(res > 0){\n\t\t\t\tfprintf(stderr, \"Command: '%s' failed with code %d, line %d\\n\", argv[0], res, linenum);\n\t\t\t\treturn(linenum);\n\t\t\t}\n\t\t\tif(!res) break;\n\t\t}\n\t}\n\tif(res != 1)continue;\n\tfprintf(stderr, \"Unknown command: '%s' line %d\\n\", argv[0], linenum);\n\treturn(linenum);\n  }\n  myfree(buf);\n  myfree(argv);\n  return 0;\n\n}\n\n\n\nvoid freepwl(struct passwords *pwl){\n\tfor(; pwl; pwl = (struct passwords *)itfree(pwl, pwl->next)){\n\t\tif(pwl->user)myfree(pwl->user);\n\t\tif(pwl->password)myfree(pwl->password);\n\t}\n}\n\n\nvoid freeconf(struct extparam *confp){\n struct bandlim * bl;\n struct bandlim * blout;\n struct trafcount * tc;\n struct passwords *pw;\n struct ace *acl;\n struct filemon *fm;\n int counterd, archiverc;\n unsigned char *logname, *logtarget;\n unsigned char **archiver;\n unsigned char * logformat;\n\n int i;\n\n\n\n\n pthread_mutex_lock(&tc_mutex);\n confp->trafcountfunc = NULL;\n tc = confp->trafcounter;\n confp->trafcounter = NULL;\n counterd = confp->counterd;\n confp->counterd = -1;\n confp->countertype = NONE;\n pthread_mutex_unlock(&tc_mutex);\n\n pthread_mutex_lock(&bandlim_mutex);\n bl = confp->bandlimiter;\n blout = confp->bandlimiterout;\n confp->bandlimiter = NULL;\n confp->bandlimiterout = NULL;\n confp->bandlimfunc = NULL;\n pthread_mutex_unlock(&bandlim_mutex);\n\n pthread_mutex_lock(&pwl_mutex);\n pw = confp->pwl;\n confp->pwl = NULL;\n pthread_mutex_unlock(&pwl_mutex);\n\n\n logtarget = confp->logtarget;\n confp->logtarget = NULL;\n logformat = confp->logformat;\n confp->logformat = NULL;\n logname = confp->logname;\n confp->logname = NULL;\n confp->rotate = 0;\n confp->logtype = NONE;\n\n archiverc = confp->archiverc;\n confp->archiverc = 0;\n archiver = confp->archiver;\n confp->archiver = NULL;\n fm = confp->fmon;\n confp->fmon = NULL;\n confp->bandlimfunc = NULL;\n memset(&confp->intsa, 0, sizeof(confp->intsa));\n memset(&confp->extsa, 0, sizeof(confp->extsa));\n#ifndef NOIPV6\n memset(&confp->extsa6, 0, sizeof(confp->extsa6));\n *SAFAMILY(&confp->extsa6) = AF_INET6;\n#endif\n *SAFAMILY(&confp->intsa) = AF_INET;\n *SAFAMILY(&confp->extsa) = AF_INET;\n confp->singlepacket = 0;\n confp->maxchild = 100;\n resolvfunc = NULL;\n numservers = 0;\n acl = confp->acl;\n confp->acl = NULL;\n confp->logtime = confp->time = 0;\n\n usleep(SLEEPTIME);\n\n {\n\tchar * args[] = {\"auth\", \"iponly\", NULL};\n  \th_auth(2, (unsigned char **)args);\n }\n if(tc)dumpcounters(tc,counterd);\n for(; tc; tc = (struct trafcount *) itfree(tc, tc->next)){\n\tif(tc->comment)myfree(tc->comment);\n\tfreeacl(tc->ace);\n }\n\n \n freeacl(acl);\n freepwl(pw);\n for(; bl; bl = (struct bandlim *) itfree(bl, bl->next)) freeacl(bl->ace);\n for(; blout; blout = (struct bandlim *) itfree(blout, blout->next))freeacl(blout->ace);\n\n if(counterd != -1) {\n\tclose(counterd);\n }\n for(; fm; fm = (struct filemon *)itfree(fm, fm->next)){\n\tif(fm->path) myfree(fm->path);\n }\n if(logtarget) {\n\tmyfree(logtarget);\n }\n if(logname) {\n\tmyfree(logname);\n }\n if(logformat) {\n\tmyfree(logformat);\n }\n if(archiver) {\n\tfor(i = 0; i < archiverc; i++) myfree(archiver[i]);\n\tmyfree(archiver);\n }\n\n}\n\nint reload (void){\n\tFILE *fp;\n\tint error = -2;\n\n\tconf.paused++;\n\tfreeconf(&conf);\n\tconf.paused++;\n\n\tfp = confopen();\n\tif(fp){\n\t\terror = readconfig(fp);\n\t\tconf.version++;\n\t\tif(error) {\n\t\t\t freeconf(&conf);\n\t\t}\n\t\tif(!writable)fclose(fp);\n\t}\n\treturn error;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-3proxy-0.8.13-2rv2nfmlvh24cbqdsu3hto3r76xetyxg/spack-src/3proxy.ico",
        "/tmp/vanessa/spack-stage/spack-stage-3proxy-0.8.13-2rv2nfmlvh24cbqdsu3hto3r76xetyxg/spack-src/src/plugins/PamAuth/PAMAUTH.TXT",
        "/tmp/vanessa/spack-stage/spack-stage-3proxy-0.8.13-2rv2nfmlvh24cbqdsu3hto3r76xetyxg/spack-src/src/plugins/StringsPlugin/ReadMe.txt",
        "/tmp/vanessa/spack-stage/spack-stage-3proxy-0.8.13-2rv2nfmlvh24cbqdsu3hto3r76xetyxg/spack-src/src/plugins/LdapPlugin/ldapauth.c",
        "/tmp/vanessa/spack-stage/spack-stage-3proxy-0.8.13-2rv2nfmlvh24cbqdsu3hto3r76xetyxg/spack-src/src/plugins/LdapPlugin/ldapauth.txt",
        "/tmp/vanessa/spack-stage/spack-stage-3proxy-0.8.13-2rv2nfmlvh24cbqdsu3hto3r76xetyxg/spack-src/src/plugins/TrafficPlugin/ReadMe.txt",
        "/tmp/vanessa/spack-stage/spack-stage-3proxy-0.8.13-2rv2nfmlvh24cbqdsu3hto3r76xetyxg/spack-src/src/plugins/TrafficPlugin/Changelog.txt",
        "/tmp/vanessa/spack-stage/spack-stage-3proxy-0.8.13-2rv2nfmlvh24cbqdsu3hto3r76xetyxg/spack-src/src/plugins/TrafficPlugin/TrafficPlugin.c",
        "/tmp/vanessa/spack-stage/spack-stage-3proxy-0.8.13-2rv2nfmlvh24cbqdsu3hto3r76xetyxg/spack-src/cfg/sql/report.xls",
        "/tmp/vanessa/spack-stage/spack-stage-3proxy-0.8.13-2rv2nfmlvh24cbqdsu3hto3r76xetyxg/spack-src/doc/html/howtoe.html",
        "/tmp/vanessa/spack-stage/spack-stage-3proxy-0.8.13-2rv2nfmlvh24cbqdsu3hto3r76xetyxg/spack-src/doc/ru/example1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-3proxy-0.8.13-2rv2nfmlvh24cbqdsu3hto3r76xetyxg/spack-src/doc/ru/odbc.txt",
        "/tmp/vanessa/spack-stage/spack-stage-3proxy-0.8.13-2rv2nfmlvh24cbqdsu3hto3r76xetyxg/spack-src/doc/ru/iodbc.txt"
    ],
    "total_files": 166
}