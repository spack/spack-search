{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-dhf3djcroafxxgzw73ri4gkvkvqs6ets/spack-src/src/common/libflux/handle.c": "/************************************************************\\\n * Copyright 2014 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <assert.h>\n#include <string.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <dlfcn.h>\n#include <sys/epoll.h>\n#include <poll.h>\n#include <czmq.h>\n#if HAVE_CALIPER\n#include <caliper/cali.h>\n#include <sys/syscall.h>\n#endif\n\n#include \"handle.h\"\n#include \"reactor.h\"\n#include \"connector.h\"\n#include \"message.h\"\n#include \"tagpool.h\"\n#include \"msg_handler.h\" // for flux_sleep_on ()\n#include \"flog.h\"\n#include \"conf.h\"\n\n#include \"src/common/libutil/log.h\"\n#include \"src/common/libutil/msglist.h\"\n#include \"src/common/libutil/dirwalk.h\"\n#include \"src/common/libutil/aux.h\"\n#include \"src/common/libutil/errno_safe.h\"\n\n#if HAVE_CALIPER\nstruct profiling_context {\n    int initialized;\n    cali_id_t msg_type;\n    cali_id_t msg_seq;\n    cali_id_t msg_topic;\n    cali_id_t msg_sender;\n    cali_id_t msg_rpc;\n    cali_id_t msg_rpc_nodeid;\n    cali_id_t msg_rpc_resp_expected;\n    cali_id_t msg_action;\n    cali_id_t msg_match_type;\n    cali_id_t msg_match_tag;\n    cali_id_t msg_match_glob;\n};\n#endif\n\nstruct flux_handle_struct {\n    flux_t          *parent; // if FLUX_O_CLONE, my parent\n    struct aux_item *aux;\n    int             usecount;\n    int             flags;\n\n    /* element below are unused in cloned handles */\n    const struct flux_handle_ops *ops;\n    void            *impl;\n    void            *dso;\n    msglist_t       *queue;\n    int             pollfd;\n\n    struct tagpool  *tagpool;\n    flux_msgcounters_t msgcounters;\n    flux_fatal_f    fatal;\n    void            *fatal_arg;\n    bool            fatality;\n    bool            destroy_in_progress;\n#if HAVE_CALIPER\n    struct profiling_context prof;\n#endif\n};\n\nstatic flux_t *lookup_clone_ancestor (flux_t *h)\n{\n    while ((h->flags & FLUX_O_CLONE))\n        h = h->parent;\n    return h;\n}\n\nvoid tagpool_grow_notify (void *arg, uint32_t old, uint32_t new);\n\n#if HAVE_CALIPER\nvoid profiling_context_init (struct profiling_context* prof)\n{\n    prof->msg_type = cali_create_attribute (\"flux.message.type\",\n                                            CALI_TYPE_STRING,\n                                            CALI_ATTR_DEFAULT | CALI_ATTR_ASVALUE);\n    prof->msg_seq = cali_create_attribute (\"flux.message.seq\",\n                                           CALI_TYPE_INT,\n                                           CALI_ATTR_SKIP_EVENTS);\n    prof->msg_topic = cali_create_attribute (\"flux.message.topic\",\n                                             CALI_TYPE_STRING,\n                                             CALI_ATTR_DEFAULT | CALI_ATTR_ASVALUE);\n    prof->msg_sender = cali_create_attribute (\"flux.message.sender\",\n                                              CALI_TYPE_STRING,\n                                              CALI_ATTR_SKIP_EVENTS);\n    // if flux.message.rpc is set, we're inside an RPC, it will be set to a\n    // type, single or multi\n    prof->msg_rpc = cali_create_attribute (\"flux.message.rpc\",\n                                           CALI_TYPE_STRING,\n                                           CALI_ATTR_SKIP_EVENTS);\n    prof->msg_rpc_nodeid = cali_create_attribute (\"flux.message.rpc.nodeid\",\n                                                  CALI_TYPE_INT,\n                                                  CALI_ATTR_SKIP_EVENTS);\n    prof->msg_rpc_resp_expected =\n        cali_create_attribute (\"flux.message.response_expected\",\n                               CALI_TYPE_INT,\n                               CALI_ATTR_SKIP_EVENTS);\n    prof->msg_action = cali_create_attribute (\"flux.message.action\",\n                                              CALI_TYPE_STRING,\n                                              CALI_ATTR_DEFAULT | CALI_ATTR_ASVALUE);\n    prof->msg_match_type = cali_create_attribute (\"flux.message.match.type\",\n                                                  CALI_TYPE_INT,\n                                                  CALI_ATTR_SKIP_EVENTS);\n    prof->msg_match_tag = cali_create_attribute (\"flux.message.match.tag\",\n                                                 CALI_TYPE_INT,\n                                                 CALI_ATTR_SKIP_EVENTS);\n    prof->msg_match_glob = cali_create_attribute (\"flux.message.match.glob\",\n                                                  CALI_TYPE_STRING,\n                                                  CALI_ATTR_SKIP_EVENTS);\n    prof->initialized=1;\n}\n\nstatic void profiling_msg_snapshot (flux_t *h,\n                          const flux_msg_t *msg,\n                          int flags,\n                          const char *msg_action)\n{\n    h = lookup_clone_ancestor (h);\n    cali_id_t attributes[3];\n    const void * data[3];\n    size_t size[3];\n\n    // This can get called before the handle is really ready\n    if(! h->prof.initialized) return;\n\n    int len = 0;\n\n    if (msg_action) {\n        attributes[len] = h->prof.msg_action;\n        data[len] = msg_action;\n        size[len] = strlen(msg_action);\n        ++len;\n    }\n\n    int type;\n    flux_msg_get_type (msg, &type);\n    const char *msg_type = flux_msg_typestr (type);\n    if (msg_type) {\n        attributes[len] = h->prof.msg_type;\n        data[len] = msg_type;\n        size[len] = strlen(msg_type);\n        ++len;\n    }\n\n    const char *msg_topic;\n    if (type != FLUX_MSGTYPE_KEEPALIVE)\n        flux_msg_get_topic (msg, &msg_topic);\n    else\n        msg_topic = \"NONE\";\n    /* attributes[len] = h->prof.msg_topic; */\n    /* data[len] = msg_topic; */\n    /* size[len] = strlen(msg_topic); */\n    /* ++len; */\n\n    if (type == FLUX_MSGTYPE_EVENT) {\n        uint32_t seq;\n        flux_msg_get_seq (msg, &seq);\n        cali_begin_int (h->prof.msg_seq, seq);\n    }\n    cali_push_snapshot (CALI_SCOPE_PROCESS | CALI_SCOPE_THREAD,\n                        len /* n_entries */,\n                        attributes /* event_attributes */,\n                        data /* event_data */,\n                        size /* event_size */);\n    if (type == FLUX_MSGTYPE_EVENT)\n        cali_end (h->prof.msg_seq);\n}\n\n\n#endif\n\nstatic char *find_file (const char *name, const char *searchpath)\n{\n    char *path;\n    zlist_t *l;\n    if (!(l = dirwalk_find (searchpath, DIRWALK_REALPATH, name, 1, NULL, NULL)))\n        return NULL;\n    path = zlist_pop (l);\n    zlist_destroy (&l);\n    return path;\n}\n\nstatic connector_init_f *find_connector (const char *scheme, void **dsop)\n{\n    char name[PATH_MAX];\n    const char *searchpath = getenv (\"FLUX_CONNECTOR_PATH\");\n    char *path = NULL;\n    void *dso = NULL;\n    connector_init_f *connector_init = NULL;\n\n    if (!searchpath)\n        searchpath = flux_conf_builtin_get (\"connector_path\", FLUX_CONF_AUTO);\n    if (snprintf (name, sizeof (name), \"%s.so\", scheme) >= sizeof (name)) {\n        errno = ENAMETOOLONG;\n        return NULL;\n    }\n    if (!(path = find_file (name, searchpath))) {\n        errno = ENOENT;\n        goto error;\n    }\n    if (!(dso = dlopen (path, RTLD_LAZY | RTLD_LOCAL | FLUX_DEEPBIND))) {\n        errno = EINVAL;\n        goto error;\n    }\n    if (!(connector_init = dlsym (dso, \"connector_init\"))) {\n        errno = EINVAL;\n        goto error_dlopen;\n    }\n    *dsop = dso;\n    free (path);\n    return connector_init;\nerror_dlopen:\n    ERRNO_SAFE_WRAP (dlclose, dso);\nerror:\n    ERRNO_SAFE_WRAP (free, path);\n    return NULL;\n}\n\nstatic char *strtrim (char *s, const char *trim)\n{\n    char *p = s + strlen (s) - 1;\n    while (p >= s && strchr (trim, *p))\n        *p-- = '\\0';\n    return *s ? s : NULL;\n}\n\nflux_t *flux_open (const char *uri, int flags)\n{\n    char *default_uri = NULL;\n    char *path = NULL;\n    char *scheme = NULL;\n    void *dso = NULL;\n    connector_init_f *connector_init = NULL;\n    const char *s;\n    flux_t *h = NULL;\n\n    /* Try to get URI from (in descending precedence):\n     *   argument > environment > builtin\n     */\n    if (!uri)\n        uri = getenv (\"FLUX_URI\");\n    if (!uri) {\n        if (asprintf (&default_uri, \"local://%s/local\",\n                      flux_conf_builtin_get (\"rundir\",\n                                             FLUX_CONF_INSTALLED)) < 0)\n            goto error;\n        uri = default_uri;\n    }\n    if (!(scheme = strdup (uri)))\n        goto error;\n    path = strstr (scheme, \"://\");\n    if (path) {\n        *path = '\\0';\n        path = strtrim (path + 3, \" \\t\");\n    }\n    if (!(connector_init = find_connector (scheme, &dso)))\n        goto error;\n    if (getenv (\"FLUX_HANDLE_TRACE\"))\n        flags |= FLUX_O_TRACE;\n    if (getenv (\"FLUX_HANDLE_MATCHDEBUG\"))\n        flags |= FLUX_O_MATCHDEBUG;\n    if (!(h = connector_init (path, flags))) {\n        ERRNO_SAFE_WRAP (dlclose, dso);\n        goto error;\n    }\n    h->dso = dso;\n#if HAVE_CALIPER\n    profiling_context_init(&h->prof);\n#endif\n    if ((s = getenv (\"FLUX_HANDLE_USERID\"))) {\n        uint32_t userid = strtoul (s, NULL, 10);\n        if (flux_opt_set (h, FLUX_OPT_TESTING_USERID, &userid,\n                                                      sizeof (userid)) < 0)\n            goto error_handle;\n    }\n    if ((s = getenv (\"FLUX_HANDLE_ROLEMASK\"))) {\n        uint32_t rolemask = strtoul (s, NULL, 0);\n        if (flux_opt_set (h, FLUX_OPT_TESTING_ROLEMASK, &rolemask,\n                                                    sizeof (rolemask)) < 0)\n            goto error_handle;\n    }\n    free (scheme);\n    free (default_uri);\n    return h;\nerror_handle:\n    flux_handle_destroy (h);\nerror:\n    ERRNO_SAFE_WRAP (free, scheme);\n    ERRNO_SAFE_WRAP (free, default_uri);\n    return NULL;\n}\n\nvoid flux_close (flux_t *h)\n{\n    flux_handle_destroy (h);\n}\n\nflux_t *flux_handle_create (void *impl, const struct flux_handle_ops *ops, int flags)\n{\n    flux_t *h = malloc (sizeof (*h));\n    if (!h)\n        goto nomem;\n    memset (h, 0, sizeof (*h));\n    h->usecount = 1;\n    h->flags = flags;\n    h->ops = ops;\n    h->impl = impl;\n    if (!(h->tagpool = tagpool_create ()))\n        goto nomem;\n    tagpool_set_grow_cb (h->tagpool, tagpool_grow_notify, h);\n    if (!(h->queue = msglist_create ((msglist_free_f)flux_msg_destroy)))\n        goto nomem;\n    h->pollfd = -1;\n    return h;\nnomem:\n    flux_handle_destroy (h);\n    errno = ENOMEM;\n    return NULL;\n}\n\nflux_t *flux_clone (flux_t *orig)\n{\n    if (!orig) {\n        errno = EINVAL;\n        return NULL;\n    }\n    flux_t *h = calloc (1, sizeof (*h));\n    if (!h)\n        goto nomem;\n    h->parent = flux_incref (orig);\n    h->usecount = 1;\n    h->flags = orig->flags | FLUX_O_CLONE;\n    return h;\nnomem:\n    free (h);\n    errno = ENOMEM;\n    return NULL;\n}\n\nstatic void report_leaked_matchtags (struct tagpool *tp)\n{\n    uint32_t count = tagpool_getattr (tp, TAGPOOL_ATTR_SIZE) -\n                     tagpool_getattr (tp, TAGPOOL_ATTR_AVAIL);\n    if (count > 0)\n        fprintf (stderr,\n                 \"MATCHDEBUG: pool destroy with %d allocated\\n\", count);\n}\n\nvoid flux_handle_destroy (flux_t *h)\n{\n    if (h && --h->usecount == 0) {\n        int saved_errno = errno;\n        if (h->destroy_in_progress)\n            return;\n        h->destroy_in_progress = true;\n        aux_destroy (&h->aux);\n        if ((h->flags & FLUX_O_CLONE)) {\n            flux_handle_destroy (h->parent); // decr usecount\n        }\n        else {\n            if (h->ops->impl_destroy)\n                h->ops->impl_destroy (h->impl);\n            if ((h->flags & FLUX_O_MATCHDEBUG))\n                report_leaked_matchtags (h->tagpool);\n            tagpool_destroy (h->tagpool);\n#ifndef __SANITIZE_ADDRESS__\n            if (h->dso)\n                dlclose (h->dso);\n#endif\n            msglist_destroy (h->queue);\n            if (h->pollfd >= 0)\n                (void)close (h->pollfd);\n        }\n        free (h);\n        errno = saved_errno;\n    }\n}\n\nflux_t *flux_incref (flux_t *h)\n{\n    if (h)\n        h->usecount++;\n    return h;\n}\n\nvoid flux_decref (flux_t *h)\n{\n    flux_handle_destroy (h);\n}\n\nvoid flux_flags_set (flux_t *h, int flags)\n{\n    h->flags |= flags;\n}\n\nvoid flux_flags_unset (flux_t *h, int flags)\n{\n    h->flags &= ~flags;\n}\n\nint flux_flags_get (flux_t *h)\n{\n    return h->flags;\n}\n\nint flux_opt_get (flux_t *h, const char *option, void *val, size_t len)\n{\n    h = lookup_clone_ancestor (h);\n    if (!h->ops->getopt) {\n        errno = EINVAL;\n        return -1;\n    }\n    return h->ops->getopt (h->impl, option, val, len);\n}\n\nint flux_opt_set (flux_t *h, const char *option, const void *val, size_t len)\n{\n    h = lookup_clone_ancestor (h);\n    if (!h->ops->setopt) {\n        errno = EINVAL;\n        return -1;\n    }\n    return h->ops->setopt (h->impl, option, val, len);\n}\n\nvoid *flux_aux_get (flux_t *h, const char *name)\n{\n    if (!h) {\n        errno = EINVAL;\n        return NULL;\n    }\n    return aux_get (h->aux, name);\n}\n\nint flux_aux_set (flux_t *h, const char *name, void *aux, flux_free_f destroy)\n{\n    if (!h) {\n        errno = EINVAL;\n        return -1;\n    }\n    return aux_set (&h->aux, name, aux, destroy);\n}\n\nvoid flux_fatal_set (flux_t *h, flux_fatal_f fun, void *arg)\n{\n    h = lookup_clone_ancestor (h);\n    h->fatal = fun;\n    h->fatal_arg = arg;\n    h->fatality = false;\n}\n\nvoid flux_fatal_error (flux_t *h, const char *fun, const char *msg)\n{\n    h = lookup_clone_ancestor (h);\n    if (!h->fatality) {\n        h->fatality = true;\n        if (h->fatal) {\n            char buf[256];\n            snprintf (buf, sizeof (buf), \"%s: %s\", fun, msg);\n            h->fatal (buf, h->fatal_arg);\n        }\n    }\n}\n\nbool flux_fatality (flux_t *h)\n{\n    h = lookup_clone_ancestor (h);\n    return h->fatality;\n}\n\nvoid flux_get_msgcounters (flux_t *h, flux_msgcounters_t *mcs)\n{\n    h = lookup_clone_ancestor (h);\n    *mcs = h->msgcounters;\n}\n\nvoid flux_clr_msgcounters (flux_t *h)\n{\n    h = lookup_clone_ancestor (h);\n    memset (&h->msgcounters, 0, sizeof (h->msgcounters));\n}\n\nvoid tagpool_grow_notify (void *arg, uint32_t old, uint32_t new)\n{\n    flux_t *h = arg;\n    flux_log (h, LOG_INFO, \"tagpool expanded from %u to %u entries\", old, new);\n}\n\nuint32_t flux_matchtag_alloc (flux_t *h)\n{\n    h = lookup_clone_ancestor (h);\n    uint32_t tag;\n\n    tag = tagpool_alloc (h->tagpool);\n    if (tag == FLUX_MATCHTAG_NONE) {\n        flux_log (h, LOG_ERR, \"tagpool temporarily out of tags\");\n        errno = EBUSY; /* appropriate error? */\n    }\n    return tag;\n}\n\n/* Free matchtag, first deleting any queued matching responses.\n */\nvoid flux_matchtag_free (flux_t *h, uint32_t matchtag)\n{\n    h = lookup_clone_ancestor (h);\n    struct flux_match match = {\n        .typemask = FLUX_MSGTYPE_RESPONSE,\n        .topic_glob = NULL,\n        .matchtag = matchtag,\n    };\n    flux_msg_t *msg = msglist_first (h->queue);\n    while (msg) {\n        if (flux_msg_cmp (msg, match)) {\n            msglist_remove (h->queue, msg);\n            flux_msg_destroy (msg);\n        }\n        msg = msglist_next (h->queue);\n    }\n    tagpool_free (h->tagpool, matchtag);\n}\n\nuint32_t flux_matchtag_avail (flux_t *h)\n{\n    h = lookup_clone_ancestor (h);\n    return tagpool_getattr (h->tagpool, TAGPOOL_ATTR_AVAIL);\n}\n\nstatic void update_tx_stats (flux_t *h, const flux_msg_t *msg)\n{\n    int type;\n    if (flux_msg_get_type (msg, &type) == 0) {\n        switch (type) {\n            case FLUX_MSGTYPE_REQUEST:\n                h->msgcounters.request_tx++;\n                break;\n            case FLUX_MSGTYPE_RESPONSE:\n                h->msgcounters.response_tx++;\n                break;\n            case FLUX_MSGTYPE_EVENT:\n                h->msgcounters.event_tx++;\n                break;\n            case FLUX_MSGTYPE_KEEPALIVE:\n                h->msgcounters.keepalive_tx++;\n                break;\n        }\n    } else\n        errno = 0;\n}\n\nstatic void update_rx_stats (flux_t *h, const flux_msg_t *msg)\n{\n    int type;\n    if (flux_msg_get_type (msg, &type) == 0) {\n        switch (type) {\n            case FLUX_MSGTYPE_REQUEST:\n                h->msgcounters.request_rx++;\n                break;\n            case FLUX_MSGTYPE_RESPONSE:\n                h->msgcounters.response_rx++;\n                break;\n            case FLUX_MSGTYPE_EVENT:\n                h->msgcounters.event_rx++;\n                break;\n        case FLUX_MSGTYPE_KEEPALIVE:\n            h->msgcounters.keepalive_rx++;\n            break;\n        }\n    } else\n        errno = 0;\n}\n\nint flux_send (flux_t *h, const flux_msg_t *msg, int flags)\n{\n    h = lookup_clone_ancestor (h);\n    if (!h->ops->send || h->destroy_in_progress) {\n        errno = ENOSYS;\n        goto fatal;\n    }\n    flags |= h->flags;\n    update_tx_stats (h, msg);\n    if (flags & FLUX_O_TRACE)\n        flux_msg_fprint (stderr, msg);\n    if (h->ops->send (h->impl, msg, flags) < 0)\n        goto fatal;\n#if HAVE_CALIPER\n    profiling_msg_snapshot(h, msg, flags, \"send\");\n#endif\n    return 0;\nfatal:\n    FLUX_FATAL (h);\n    return -1;\n}\n\nstatic int defer_enqueue (zlist_t **l, flux_msg_t *msg)\n{\n    if ((!*l && !(*l = zlist_new ())) || zlist_append (*l, msg) < 0) {\n        errno = ENOMEM;\n        return -1;\n    }\n    return 0;\n}\n\nstatic int defer_requeue (zlist_t **l, flux_t *h)\n{\n    flux_msg_t *msg;\n    if (*l) {\n        while ((msg = zlist_pop (*l))) {\n            int rc = flux_requeue (h, msg, FLUX_RQ_TAIL);\n            flux_msg_destroy (msg);\n            if (rc < 0)\n                return -1;\n        }\n    }\n    return 0;\n}\n\nstatic void defer_destroy (zlist_t **l)\n{\n    flux_msg_t *msg;\n    if (*l) {\n        while ((msg = zlist_pop (*l)))\n            flux_msg_destroy (msg);\n        zlist_destroy (l);\n    }\n}\n\nstatic flux_msg_t *flux_recv_any (flux_t *h, int flags)\n{\n    flux_msg_t *msg = NULL;\n    if (msglist_count (h->queue) > 0)\n        msg = msglist_pop (h->queue);\n    else if (h->ops->recv)\n        msg = h->ops->recv (h->impl, flags);\n    else\n        errno = ENOSYS;\n    return msg;\n}\n\n/* N.B. the do loop below that reads messages and compares them to match\n * criteria may have to read a few non-matching messages before finding\n * a match.  On return, those non-matching messages have to be requeued\n * in the handle, hence the defer_*() helper calls.\n */\nflux_msg_t *flux_recv (flux_t *h, struct flux_match match, int flags)\n{\n    h = lookup_clone_ancestor (h);\n    zlist_t *l = NULL;\n    flux_msg_t *msg = NULL;\n    int saved_errno;\n\n    flags |= h->flags;\n    do {\n        if (!(msg = flux_recv_any (h, flags))) {\n            if (errno != EAGAIN && errno != EWOULDBLOCK)\n                goto fatal;\n            if (defer_requeue (&l, h) < 0)\n                goto fatal;\n            defer_destroy (&l);\n            errno = EWOULDBLOCK;\n            return NULL;\n        }\n        if (!flux_msg_cmp (msg, match)) {\n            if (defer_enqueue (&l, msg) < 0)\n                goto fatal;\n            msg = NULL;\n        }\n    } while (!msg);\n    update_rx_stats (h, msg);\n    if ((flags & FLUX_O_TRACE))\n        flux_msg_fprint (stderr, msg);\n    if (defer_requeue (&l, h) < 0)\n        goto fatal;\n    defer_destroy (&l);\n#if HAVE_CALIPER\n    cali_begin_int (h->prof.msg_match_type, match.typemask);\n    cali_begin_int (h->prof.msg_match_tag, match.matchtag);\n    cali_begin_string (h->prof.msg_match_glob,\n                       match.topic_glob ? match.topic_glob : \"NONE\");\n    char *sender = NULL;\n    flux_msg_get_route_first (msg, &sender);\n    if (sender)\n        cali_begin_string (h->prof.msg_sender, sender);\n    profiling_msg_snapshot (h, msg, flags, \"recv\");\n    if (sender)\n        cali_end (h->prof.msg_sender);\n    cali_end (h->prof.msg_match_type);\n    cali_end (h->prof.msg_match_tag);\n    cali_end (h->prof.msg_match_glob);\n\n    free (sender);\n#endif\n    return msg;\nfatal:\n    saved_errno = errno;\n    FLUX_FATAL (h);\n    if (msg)\n        flux_msg_destroy (msg);\n    defer_destroy (&l);\n    errno = saved_errno;\n    return NULL;\n}\n\n/* FIXME: FLUX_O_TRACE will show these messages being received again\n * So will message counters.\n */\nstatic int requeue (flux_t *h, flux_msg_t *msg, int flags)\n{\n    h = lookup_clone_ancestor (h);\n    int rc;\n\n    if (flags != FLUX_RQ_TAIL && flags != FLUX_RQ_HEAD) {\n        errno = EINVAL;\n        goto fatal;\n    }\n    if (flags == FLUX_RQ_TAIL)\n        rc = msglist_append (h->queue, msg);\n    else\n        rc = msglist_push (h->queue, msg);\n    if (rc < 0)\n        goto fatal;\n    return 0;\nfatal:\n    FLUX_FATAL (h);\n    return -1;\n}\n\nint flux_requeue (flux_t *h, const flux_msg_t *msg, int flags)\n{\n    flux_msg_t *cpy = NULL;\n\n    if (!(cpy = flux_msg_copy (msg, true))) {\n        FLUX_FATAL (h);\n        return -1;\n    }\n\n    if (requeue (h, cpy, flags) < 0) {\n        flux_msg_destroy (cpy);\n        return -1;\n    }\n\n    return 0;\n}\n\nint flux_requeue_nocopy (flux_t *h, flux_msg_t *msg, int flags)\n{\n    if (requeue (h, msg, flags) < 0)\n        return -1;\n\n    return 0;\n}\n\nint flux_event_subscribe (flux_t *h, const char *topic)\n{\n    h = lookup_clone_ancestor (h);\n    if (h->ops->event_subscribe) {\n        if (h->ops->event_subscribe (h->impl, topic) < 0)\n            goto fatal;\n    }\n    return 0;\nfatal:\n    FLUX_FATAL (h);\n    return -1;\n}\n\nint flux_event_unsubscribe (flux_t *h, const char *topic)\n{\n    h = lookup_clone_ancestor (h);\n    if (h->ops->event_unsubscribe) {\n        if (h->ops->event_unsubscribe (h->impl, topic) < 0)\n            goto fatal;\n    }\n    return 0;\nfatal:\n    FLUX_FATAL (h);\n    return -1;\n}\n\nint flux_pollfd (flux_t *h)\n{\n    h = lookup_clone_ancestor (h);\n    if (h->pollfd < 0) {\n        struct epoll_event ev = {\n            .events = EPOLLET | EPOLLIN | EPOLLOUT | EPOLLERR | EPOLLHUP,\n        };\n        if ((h->pollfd = epoll_create1 (EPOLL_CLOEXEC)) < 0)\n            goto fatal;\n        /* add queue pollfd */\n        ev.data.fd = msglist_pollfd (h->queue);\n        if (ev.data.fd < 0)\n            goto fatal;\n        if (epoll_ctl (h->pollfd, EPOLL_CTL_ADD, ev.data.fd, &ev) < 0)\n            goto fatal;\n        /* add connector pollfd (if defined) */\n        if (h->ops->pollfd) {\n            ev.data.fd = h->ops->pollfd (h->impl);\n            if (ev.data.fd < 0)\n                goto fatal;\n            if (epoll_ctl (h->pollfd, EPOLL_CTL_ADD, ev.data.fd, &ev) < 0)\n                goto fatal;\n        }\n    }\n    return h->pollfd;\nfatal:\n    if (h->pollfd >= 0) {\n        (void)close (h->pollfd);\n        h->pollfd = -1;\n    }\n    FLUX_FATAL (h);\n    return -1;\n}\n\nint flux_pollevents (flux_t *h)\n{\n    h = lookup_clone_ancestor (h);\n    int e, events = 0;\n\n    /* wait for handle event */\n    if (h->pollfd >= 0) {\n        struct epoll_event ev;\n        (void)epoll_wait (h->pollfd, &ev, 1, 0);\n    }\n    /* get connector events (if applicable) */\n    if (h->ops->pollevents) {\n        if ((events = h->ops->pollevents (h->impl)) < 0)\n            goto fatal;\n    }\n    /* get queue events */\n    if ((e = msglist_pollevents (h->queue)) < 0)\n        goto fatal;\n    if ((e & POLLIN))\n        events |= FLUX_POLLIN;\n    if ((e & POLLOUT))\n        events |= FLUX_POLLOUT;\n    if ((e & POLLERR))\n        events |= FLUX_POLLERR;\n    return events;\nfatal:\n    FLUX_FATAL (h);\n    return -1;\n}\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-dhf3djcroafxxgzw73ri4gkvkvqs6ets/spack-src/src/common/libflux/module.c": "/************************************************************\\\n * Copyright 2014 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <dlfcn.h>\n#include <argz.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <jansson.h>\n\n#include \"module.h\"\n#include \"message.h\"\n#include \"keepalive.h\"\n#include \"rpc.h\"\n\n#include \"src/common/libutil/log.h\"\n#include \"src/common/libutil/dirwalk.h\"\n\nstruct modfind_ctx {\n    const char *modname;\n    flux_moderr_f *cb;\n    void *arg;\n};\n\nchar *flux_modname (const char *path, flux_moderr_f *cb, void *arg)\n{\n    void *dso;\n    const char **np;\n    char *cpy = NULL;\n    int saved_errno;\n\n    if (!path) {\n        errno = EINVAL;\n        return NULL;\n    }\n    if (!(dso = dlopen (path, RTLD_LAZY | RTLD_LOCAL | FLUX_DEEPBIND))) {\n        if (cb)\n            cb (dlerror (), arg);\n        errno = ENOENT;\n        return NULL;\n    }\n    dlerror ();\n    if (!(np = dlsym (dso, \"mod_name\"))) {\n        char *errmsg;\n        if (cb && (errmsg = dlerror ()))\n            cb (errmsg, arg);\n        errno = EINVAL;\n        goto error;\n    }\n    if (!*np) {\n        errno = EINVAL;\n        goto error;\n    }\n    if (!(cpy = strdup (*np)))\n        goto error;\n    dlclose (dso);\n    return cpy;\nerror:\n    saved_errno = errno;\n    dlclose (dso);\n    errno = saved_errno;\n    return NULL;\n}\n\n/* dirwalk_filter_f callback for dirwalk_find()\n * This function should return 1 on match, 0 on no match.\n * dirwalk_find() will stop on first match since its count parameter is 1.\n */\nstatic int mod_find_f (dirwalk_t *d, void *arg)\n{\n    struct modfind_ctx *ctx = arg;\n    const char *path = dirwalk_path (d);\n    char *name;\n    int rc = 0;\n\n    if ((name = flux_modname (path, ctx->cb, ctx->arg))) {\n        if (!strcmp (name, ctx->modname))\n            rc = 1;\n        free (name);\n    }\n    return rc;\n}\n\nchar *flux_modfind (const char *searchpath, const char *modname,\n                    flux_moderr_f *cb, void *arg)\n{\n    char *result = NULL;\n    zlist_t *l;\n    struct modfind_ctx ctx;\n\n    if (!searchpath || !modname) {\n        errno = EINVAL;\n        return NULL;\n    }\n    ctx.modname = modname;\n    ctx.cb = cb;\n    ctx.arg = arg;\n\n    l = dirwalk_find (searchpath, 0, \"*.so\", 1, mod_find_f, &ctx);\n    if (l) {\n        result = zlist_pop (l);\n        zlist_destroy (&l);\n    }\n    if (!result)\n        errno = ENOENT;\n    return result;\n}\n\nbool flux_module_debug_test (flux_t *h, int flag, bool clear)\n{\n    int *flagsp = flux_aux_get (h, \"flux::debug_flags\");\n\n    if (!flagsp || !(*flagsp & flag))\n        return false;\n    if (clear)\n        *flagsp &= ~flag;\n    return true;\n}\n\nint flux_module_set_running (flux_t *h)\n{\n    flux_msg_t *msg;\n    int rc = -1;\n\n    if (!h) {\n        errno = EINVAL;\n        return -1;\n    }\n    if (!(msg = flux_keepalive_encode (0, FLUX_MODSTATE_RUNNING)))\n        return -1;\n    if (flux_send (h, msg, 0) < 0)\n        goto done;\n    rc = 0;\ndone:\n    flux_msg_decref (msg);\n    return rc;\n}\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-dhf3djcroafxxgzw73ri4gkvkvqs6ets/spack-src/src/common/libflux/module.h": "/************************************************************\\\n * Copyright 2014 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#ifndef _FLUX_CORE_MODULE_H\n#define _FLUX_CORE_MODULE_H\n\n/* Module management messages are constructed according to Flux RFC 5.\n * https://flux-framework.rtfd.io/projects/flux-rfc/en/latest/spec_5.html\n */\n\n#include <stdint.h>\n#include <stdbool.h>\n\n#include \"handle.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Module states, for embedding in keepalive messages (rfc 5)\n */\nenum {\n    FLUX_MODSTATE_INIT           = 0,\n    FLUX_MODSTATE_RUNNING        = 1,\n    FLUX_MODSTATE_FINALIZING     = 2,\n    FLUX_MODSTATE_EXITED         = 3,\n};\n\n/* Mandatory symbols for modules\n */\n#define MOD_NAME(x) const char *mod_name = x\ntypedef int (mod_main_f)(flux_t *h, int argc, char *argv[]);\n\ntypedef void (flux_moderr_f)(const char *errmsg, void *arg);\n\n/* Read the value of 'mod_name' from the specified module filename.\n * Caller must free the returned name.  Returns NULL on failure.\n * If 'cb' is non-NULL, any dlopen/dlsym errors are reported via callback.\n */\nchar *flux_modname (const char *filename, flux_moderr_f *cb, void *arg);\n\n/* Search a colon-separated list of directories (recursively) for a .so file\n * with the requested module name and return its path, or NULL on failure.\n * Caller must free the returned path.\n * If 'cb' is non-NULL, any dlopen/dlsym errors are reported via callback.\n */\nchar *flux_modfind (const char *searchpath, const char *modname,\n                    flux_moderr_f *cb, void *arg);\n\n/* Test and optionally clear module debug bit from within a module, as\n * described in RFC 5.  Return true if 'flag' bit is set.  If clear=true,\n * clear the bit after testing.  The flux-module(1) debug subcommand\n * manipulates these bits externally to set up test conditions.\n */\nbool flux_module_debug_test (flux_t *h, int flag, bool clear);\n\n/* Set module state to RUNNING.  This transition occurs automatically when the\n * reactor is entered, but this function can set the state to RUNNING early,\n * e.g. if flux module load must complete before the module enters the reactor.\n * Returns 0 on success, -1 on error with errno set.\n */\nint flux_module_set_running (flux_t *h);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* !FLUX_CORE_MODULE_H */\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-dhf3djcroafxxgzw73ri4gkvkvqs6ets/spack-src/src/common/libflux/plugin.c": "/************************************************************\\\n * Copyright 2019 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <errno.h>\n#include <string.h>\n#include <fnmatch.h>\n#include <dlfcn.h>\n#include <stdarg.h>\n#include <jansson.h>\n#include <czmq.h>\n#include <flux/core.h>\n\n#include \"src/common/libutil/aux.h\"\n\n#include \"plugin.h\"\n\nstruct flux_plugin {\n    char *path;\n    char *name;\n    json_t *conf;\n    char *conf_str;\n    struct aux_item *aux;\n    void *dso;\n    zlistx_t *handlers;\n    int flags;\n    char last_error [128];\n};\n\nstruct flux_plugin_arg {\n    json_error_t error;\n    json_t * in;\n    json_t * out;\n};\n\ntypedef const struct flux_plugin_handler *\n        (*find_handler_f) (flux_plugin_t *p, const char *topic);\n\nstatic void flux_plugin_handler_destroy (struct flux_plugin_handler *h)\n{\n    if (h) {\n        free (h->topic);\n        free (h);\n    }\n}\n\nstatic void handler_free (void **item)\n{\n    if (*item) {\n        struct flux_plugin_handler *h = *item;\n        flux_plugin_handler_destroy (h);\n        *item = NULL;\n    }\n}\n\nstatic const struct flux_plugin_handler * find_handler (flux_plugin_t *p,\n                                                        const char *string)\n{\n    struct flux_plugin_handler *h = zlistx_first (p->handlers);\n    while (h) {\n        if (strcmp (h->topic, string) == 0)\n            return h;\n        h = zlistx_next (p->handlers);\n    }\n    return NULL;\n}\n\nstatic const struct flux_plugin_handler * match_handler (flux_plugin_t *p,\n                                                         const char *string)\n{\n    struct flux_plugin_handler *h = zlistx_first (p->handlers);\n    while (h) {\n        if (fnmatch (h->topic, string, 0) == 0)\n            return h;\n        h = zlistx_next (p->handlers);\n    }\n    return NULL;\n}\n\nstatic struct flux_plugin_handler *\nflux_plugin_handler_create (const char *topic, flux_plugin_f cb, void *arg)\n{\n    struct flux_plugin_handler *h = calloc (1, sizeof (*h));\n    if (!h || !(h->topic = strdup (topic)))\n        goto error;\n    h->cb = cb;\n    h->data = arg;\n    return (h);\nerror:\n    flux_plugin_handler_destroy (h);\n    return NULL;\n}\n\nvoid flux_plugin_destroy (flux_plugin_t *p)\n{\n    if (p) {\n        int saved_errno = errno;\n        json_decref (p->conf);\n        zlistx_destroy (&p->handlers);\n        free (p->conf_str);\n        free (p->path);\n        free (p->name);\n        aux_destroy (&p->aux);\n#ifndef __SANITIZE_ADDRESS__\n        if (p->dso)\n            dlclose (p->dso);\n#endif\n        free (p);\n        errno = saved_errno;\n    }\n}\n\nstatic int plugin_seterror (flux_plugin_t *p, int errnum, const char *fmt, ...)\n{\n    if (p && fmt) {\n        va_list ap;\n        va_start (ap, fmt);\n        vsnprintf (p->last_error, sizeof (p->last_error), fmt, ap);\n        va_end (ap);\n    }\n    else if (p) {\n        snprintf (p->last_error,\n                  sizeof (p->last_error),\n                  \"%s\", strerror (errno));\n    }\n    errno = errnum;\n    return -1;\n}\n\nstatic inline void plugin_error_clear (flux_plugin_t *p)\n{\n    if (p)\n        p->last_error [0] = '\\0';\n}\n\nflux_plugin_t *flux_plugin_create (void)\n{\n    flux_plugin_t *p = calloc (1, sizeof (*p));\n    if (!p || !(p->handlers = zlistx_new ())) {\n        flux_plugin_destroy (p);\n        return NULL;\n    }\n    p->flags = FLUX_PLUGIN_RTLD_LAZY;\n    zlistx_set_destructor (p->handlers, handler_free);\n    return p;\n}\n\nstatic int flags_invalid (int flags)\n{\n    const int valid_flags =\n        FLUX_PLUGIN_RTLD_LAZY\n        | FLUX_PLUGIN_RTLD_NOW\n        | FLUX_PLUGIN_RTLD_GLOBAL\n        | FLUX_PLUGIN_RTLD_DEEPBIND;\n    return (flags & ~valid_flags);\n}\n\nint flux_plugin_set_flags (flux_plugin_t *p, int flags)\n{\n    if (!p || flags_invalid (flags)) {\n        errno = EINVAL;\n        return -1;\n    }\n    p->flags = flags;\n    return 0;\n}\n\nint flux_plugin_get_flags (flux_plugin_t *p)\n{\n    if (p) {\n        return p->flags;\n    }\n    return 0;\n}\n\nint flux_plugin_set_name (flux_plugin_t *p, const char *name)\n{\n    char *new = NULL;\n    plugin_error_clear (p);\n    if (!p || !name)\n        return plugin_seterror (p, EINVAL, NULL);\n    if (!(new = strdup (name)))\n        return -1;\n    free (p->name);\n    p->name = new;\n    return 0;\n}\n\nconst char * flux_plugin_get_name (flux_plugin_t *p)\n{\n    plugin_error_clear (p);\n    if (!p) {\n        errno = EINVAL;\n        return NULL;\n    }\n    return p->name;\n}\n\nint flux_plugin_aux_set (flux_plugin_t *p, const char *key,\n                         void *val, aux_free_f free_fn)\n{\n    return aux_set (&p->aux, key, val, free_fn);\n}\n\nvoid *flux_plugin_aux_get (flux_plugin_t *p, const char *key)\n{\n    return aux_get (p->aux, key);\n}\n\nconst char *flux_plugin_strerror (flux_plugin_t *p)\n{\n    return p->last_error;\n}\n\nstatic int open_flags (flux_plugin_t *p)\n{\n    int flags = 0;\n    if ((p->flags & FLUX_PLUGIN_RTLD_LAZY))\n        flags |= RTLD_LAZY;\n    if ((p->flags & FLUX_PLUGIN_RTLD_NOW))\n        flags |= RTLD_NOW;\n    if ((p->flags & FLUX_PLUGIN_RTLD_GLOBAL))\n        flags |= RTLD_GLOBAL;\n    else\n        flags |= RTLD_LOCAL;\n    if ((p->flags & FLUX_PLUGIN_RTLD_DEEPBIND))\n        flags |= FLUX_DEEPBIND;\n    return flags;\n}\n\nint flux_plugin_load_dso (flux_plugin_t *p, const char *path)\n{\n    flux_plugin_init_f init;\n    plugin_error_clear (p);\n    if (!p || !path)\n        return plugin_seterror (p, EINVAL, NULL);\n    if (access (path, R_OK) < 0)\n        return plugin_seterror (p, errno, \"%s: %s\", path, strerror (errno));\n    dlerror ();\n    if (!(p->dso = dlopen (path, open_flags (p))))\n        return plugin_seterror (p, errno, \"dlopen: %s\", dlerror ());\n\n    free (p->path);\n    free (p->name);\n    if (!(p->path = strdup (path)) || !(p->name = strdup (path)))\n        return plugin_seterror (p, ENOMEM, NULL);\n\n    if ((init = dlsym (p->dso, \"flux_plugin_init\")))\n        return (*init) (p);\n    return 0;\n}\n\nint flux_plugin_set_conf (flux_plugin_t *p, const char *json_str)\n{\n    json_error_t err;\n    plugin_error_clear (p);\n    if (!p || !json_str)\n        return plugin_seterror (p, EINVAL, NULL);\n    if (!(p->conf = json_loads (json_str, 0, &err))) {\n        return plugin_seterror (p, errno,\n                                \"parse error: col %d: %s\",\n                                 err.column, err.text);\n    }\n    if (p->conf_str) {\n        free (p->conf_str);\n        p->conf_str = NULL;\n    }\n    return 0;\n}\n\nconst char *flux_plugin_get_conf (flux_plugin_t *p)\n{\n    if (!p) {\n        plugin_seterror (p, EINVAL, NULL);\n        return NULL;\n    }\n    if (!p->conf_str) {\n        if (!p->conf) {\n            plugin_seterror (p, ENOENT, \"No plugin conf set\");\n            return NULL;\n        }\n        p->conf_str = json_dumps (p->conf, JSON_ENCODE_ANY|JSON_COMPACT);\n        if (!p->conf_str) {\n            plugin_seterror (p,\n                             errno,\n                             \"json_dumps failed: %s\",\n                             strerror (errno));\n            return NULL;\n        }\n    }\n    return p->conf_str;\n}\n\nint flux_plugin_conf_unpack (flux_plugin_t *p, const char *fmt, ...)\n{\n    json_error_t err;\n    va_list ap;\n    int rc;\n    plugin_error_clear (p);\n    if (!p || !fmt)\n        return plugin_seterror (p, EINVAL, NULL);\n    if (!p->conf)\n        return plugin_seterror (p, ENOENT, \"No plugin conf set\");\n    va_start (ap, fmt);\n    rc = json_vunpack_ex (p->conf, &err, 0, fmt, ap);\n    va_end (ap);\n    if (rc < 0)\n        return plugin_seterror (p, errno, \"unpack error: %s\", err.text);\n    return rc;\n}\n\nint flux_plugin_remove_handler (flux_plugin_t *p,\n                                const char *topic)\n{\n    plugin_error_clear (p);\n    if (!p || !topic)\n        return plugin_seterror (p, EINVAL, NULL);\n    if (find_handler (p, topic)) {\n        if (zlistx_delete (p->handlers, zlistx_cursor (p->handlers)) < 0)\n            return plugin_seterror (p, errno, NULL);\n    }\n    return 0;\n}\n\nstatic flux_plugin_f get_handler (flux_plugin_t *p,\n                                  const char *topic,\n                                  find_handler_f fn)\n{\n    const struct flux_plugin_handler *h;\n    plugin_error_clear (p);\n    if (!p || !topic) {\n        plugin_seterror (p, EINVAL, NULL);\n        return NULL;\n    }\n    if ((h = (*fn) (p, topic)))\n        return h->cb;\n    return NULL;\n}\n\nflux_plugin_f flux_plugin_get_handler (flux_plugin_t *p, const char *topic)\n{\n    return get_handler (p, topic, find_handler);\n}\n\nflux_plugin_f flux_plugin_match_handler (flux_plugin_t *p, const char *topic)\n{\n    return get_handler (p, topic, match_handler);\n}\n\n\nint flux_plugin_add_handler (flux_plugin_t *p,\n                             const char *topic,\n                             flux_plugin_f cb,\n                             void *arg)\n{\n    struct flux_plugin_handler *h = NULL;\n    plugin_error_clear (p);\n    if (!p || !topic)\n        return plugin_seterror (p, EINVAL, NULL);\n\n    if (!cb)\n        return flux_plugin_remove_handler (p, topic);\n\n    if (!(h = flux_plugin_handler_create (topic, cb, arg)))\n        return plugin_seterror (p, errno, NULL);\n\n    if (!(zlistx_add_end (p->handlers, h))) {\n        flux_plugin_handler_destroy (h);\n        return plugin_seterror (p, errno, NULL);\n    }\n\n    return 0;\n}\n\nint flux_plugin_register (flux_plugin_t *p,\n                          const char *name,\n                          const struct flux_plugin_handler t[])\n{\n    plugin_error_clear (p);\n    if (!p || !t)\n        return plugin_seterror (p, EINVAL, NULL);\n    if (name && flux_plugin_set_name (p, name))\n        return -1;\n    while (t->topic) {\n        if (flux_plugin_add_handler (p, t->topic, t->cb, t->data) < 0)\n            return -1;\n        t++;\n    }\n    return 0;\n}\n\nstatic int arg_seterror (flux_plugin_arg_t *arg, int errnum,\n                         const char *fmt, ...)\n{\n    if (fmt) {\n        va_list ap;\n        va_start (ap, fmt);\n        vsnprintf (arg->error.text, sizeof (arg->error.text), fmt, ap);\n        va_end (ap);\n    } else if (arg) {\n        snprintf (arg->error.text,\n                  sizeof (arg->error.text),\n                  \"%s\", strerror (errno));\n    }\n    errno = errnum;\n    return -1;\n}\n\nstatic inline void arg_clear_error (flux_plugin_arg_t *arg)\n{\n    if (arg)\n        arg->error.text[0] = '\\0';\n}\n\nconst char *flux_plugin_arg_strerror (flux_plugin_arg_t *args)\n{\n    if (!args)\n        return strerror (errno);\n    return args->error.text;\n}\n\nvoid flux_plugin_arg_destroy (flux_plugin_arg_t *args)\n{\n    if (args) {\n        json_decref (args->in);\n        json_decref (args->out);\n        free (args);\n    }\n}\n\nflux_plugin_arg_t *flux_plugin_arg_create (void)\n{\n    flux_plugin_arg_t *args = calloc (1, sizeof (*args));\n    return args;\n}\n\nstatic json_t **arg_get (flux_plugin_arg_t *args, int flags)\n{\n    return ((flags & FLUX_PLUGIN_ARG_OUT) ? &args->out : &args->in);\n}\n\nstatic int arg_set (flux_plugin_arg_t *args, int flags, json_t *o)\n{\n    json_t **dstp;\n    dstp = arg_get (args, flags);\n    if (flags & FLUX_PLUGIN_ARG_UPDATE && *dstp != NULL) {\n        /*  On update, the object 'o' is spiritually inherited by\n         *   args, so decref this object after attempting the update.\n         */\n        int rc = json_object_update (*dstp, o);\n        json_decref (o);\n        return rc;\n    }\n    json_decref (*dstp);\n    *dstp = o;\n    return 0;\n}\n\nint flux_plugin_arg_set (flux_plugin_arg_t *args, int flags,\n                         const char *json_str)\n{\n    json_t *o = NULL;\n    arg_clear_error (args);\n    if (!args)\n        return arg_seterror (args, EINVAL, NULL);\n    if (json_str && !(o = json_loads (json_str, 0, &args->error)))\n        return -1;\n    return arg_set (args, flags, o);\n}\n\nint flux_plugin_arg_get (flux_plugin_arg_t *args, int flags, char **json_str)\n{\n    json_t **op;\n    arg_clear_error (args);\n    if (!args || !json_str)\n        return arg_seterror (args, EINVAL, NULL);\n    op = arg_get (args, flags);\n    if (*op == NULL)\n        return arg_seterror (args, ENOENT, \"No args currently set\");\n    *json_str = json_dumps (*op, JSON_COMPACT);\n    return 0;\n}\n\nint flux_plugin_arg_vpack (flux_plugin_arg_t *args, int flags,\n                           const char *fmt, va_list ap)\n{\n    json_t *o;\n    arg_clear_error (args);\n    if (!args || !fmt)\n        return arg_seterror (args, EINVAL, NULL);\n    if (!(o = json_vpack_ex (&args->error, 0, fmt, ap)))\n        return -1;\n    return arg_set (args, flags, o);\n}\n\nint flux_plugin_arg_pack (flux_plugin_arg_t *args, int flags,\n                          const char *fmt, ...)\n{\n    int rc;\n    va_list ap;\n    va_start (ap, fmt);\n    rc = flux_plugin_arg_vpack (args, flags, fmt, ap);\n    va_end (ap);\n    return rc;\n}\n\nint flux_plugin_arg_vunpack (flux_plugin_arg_t *args, int flags,\n                             const char *fmt, va_list ap)\n{\n    json_t **op;\n    arg_clear_error (args);\n    if (!fmt || !args)\n        return arg_seterror (args, EINVAL, NULL);\n    op = arg_get (args, flags);\n    return json_vunpack_ex (*op, &args->error, 0, fmt, ap);\n}\n\nint flux_plugin_arg_unpack (flux_plugin_arg_t *args, int flags,\n                            const char *fmt, ...)\n{\n    int rc;\n    va_list ap;\n    va_start (ap, fmt);\n    rc = flux_plugin_arg_vunpack (args, flags, fmt, ap);\n    va_end (ap);\n    return rc;\n}\n\nint flux_plugin_call (flux_plugin_t *p, const char *string,\n                      flux_plugin_arg_t *args)\n{\n    const struct flux_plugin_handler *h = NULL;\n    plugin_error_clear (p);\n    if (!p || !string)\n        return plugin_seterror (p, EINVAL, NULL);\n    if (!(h = match_handler (p, string)))\n        return 0;\n    assert (h->cb);\n    if ((*h->cb) (p, string, args, h->data) < 0)\n        return -1;\n    return 1;\n}\n\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-dhf3djcroafxxgzw73ri4gkvkvqs6ets/spack-src/src/broker/broker.c": "/************************************************************\\\n * Copyright 2014 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <getopt.h>\n#include <libgen.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/signalfd.h>\n#include <sys/resource.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <stdbool.h>\n#include <dlfcn.h>\n#include <argz.h>\n#include <flux/core.h>\n#include <czmq.h>\n#include <jansson.h>\n#if HAVE_CALIPER\n#include <caliper/cali.h>\n#include <sys/syscall.h>\n#endif\n#if HAVE_VALGRIND\n# if HAVE_VALGRIND_H\n#  include <valgrind.h>\n# elif HAVE_VALGRIND_VALGRIND_H\n#  include <valgrind/valgrind.h>\n# endif\n#endif\n\n#include \"src/common/libutil/log.h\"\n#include \"src/common/libutil/oom.h\"\n#include \"src/common/libutil/xzmalloc.h\"\n#include \"src/common/libutil/cleanup.h\"\n#include \"src/common/libidset/idset.h\"\n#include \"src/common/libutil/ipaddr.h\"\n#include \"src/common/libutil/kary.h\"\n#include \"src/common/libutil/monotime.h\"\n#include \"src/common/libpmi/pmi.h\"\n#include \"src/common/libpmi/pmi_strerror.h\"\n#include \"src/common/libutil/fsd.h\"\n#include \"src/common/libutil/errno_safe.h\"\n\n#include \"module.h\"\n#include \"brokercfg.h\"\n#include \"overlay.h\"\n#include \"service.h\"\n#include \"attr.h\"\n#include \"log.h\"\n#include \"content-cache.h\"\n#include \"runat.h\"\n#include \"heaptrace.h\"\n#include \"exec.h\"\n#include \"ping.h\"\n#include \"rusage.h\"\n#include \"boot_config.h\"\n#include \"boot_pmi.h\"\n#include \"publisher.h\"\n#include \"state_machine.h\"\n\n#include \"broker.h\"\n\n\nstatic int broker_event_sendmsg (broker_ctx_t *ctx, const flux_msg_t *msg);\nstatic int broker_response_sendmsg (broker_ctx_t *ctx, const flux_msg_t *msg);\nstatic void broker_request_sendmsg (broker_ctx_t *ctx, const flux_msg_t *msg);\nstatic int broker_request_sendmsg_internal (broker_ctx_t *ctx,\n                                            const flux_msg_t *msg);\n\nstatic void parent_cb (struct overlay *ov, void *arg);\nstatic void child_cb (struct overlay *ov, void *arg);\nstatic void module_cb (module_t *p, void *arg);\nstatic void module_status_cb (module_t *p, int prev_state, void *arg);\nstatic void signal_cb (flux_reactor_t *r, flux_watcher_t *w,\n                       int revents, void *arg);\nstatic int broker_handle_signals (broker_ctx_t *ctx);\n\nstatic flux_msg_handler_t **broker_add_services (broker_ctx_t *ctx);\nstatic void broker_remove_services (flux_msg_handler_t *handlers[]);\n\nstatic int load_module_byname (broker_ctx_t *ctx, const char *name,\n                               const char *argz, size_t argz_len,\n                               const flux_msg_t *request);\nstatic int unload_module_byname (broker_ctx_t *ctx, const char *name,\n                                 const flux_msg_t *request);\n\nstatic void set_proctitle (uint32_t rank);\n\nstatic int create_rundir (attr_t *attrs);\nstatic int create_broker_rundir (struct overlay *ov, void *arg);\nstatic int create_dummyattrs (flux_t *h, uint32_t rank, uint32_t size);\n\nstatic int create_runat_phases (broker_ctx_t *ctx);\n\nstatic int handle_event (broker_ctx_t *ctx, const flux_msg_t *msg);\n\nstatic void init_attrs (attr_t *attrs, pid_t pid, struct flux_msg_cred *cred);\n\nstatic const struct flux_handle_ops broker_handle_ops;\n\n#define OPTIONS \"+vX:k:g:S:c:\"\nstatic const struct option longopts[] = {\n    {\"verbose\",         no_argument,        0, 'v'},\n    {\"module-path\",     required_argument,  0, 'X'},\n    {\"k-ary\",           required_argument,  0, 'k'},\n    {\"shutdown-grace\",  required_argument,  0, 'g'},\n    {\"setattr\",         required_argument,  0, 'S'},\n    {\"config-path\",     required_argument,  0, 'c'},\n    {0, 0, 0, 0},\n};\n\nstatic void usage (void)\n{\n    fprintf (stderr,\n\"Usage: flux-broker OPTIONS [initial-command ...]\\n\"\n\" -v,--verbose                 Be annoyingly verbose\\n\"\n\" -X,--module-path PATH        Set module search path (colon separated)\\n\"\n\" -k,--k-ary K                 Wire up in a k-ary tree\\n\"\n\" -S,--setattr ATTR=VAL        Set broker attribute\\n\"\n\" -c,--config-path PATH        Set broker config directory (default: none)\\n\"\n);\n    exit (1);\n}\n\nvoid parse_command_line_arguments (int argc, char *argv[], broker_ctx_t *ctx)\n{\n    int c;\n    int e;\n    char *endptr;\n\n    while ((c = getopt_long (argc, argv, OPTIONS, longopts, NULL)) != -1) {\n        switch (c) {\n        case 'v':   /* --verbose */\n            ctx->verbose++;\n            break;\n        case 'X':   /* --module-path PATH */\n            if (attr_set (ctx->attrs, \"conf.module_path\", optarg, true) < 0)\n                log_err_exit (\"setting conf.module_path attribute\");\n            break;\n        case 'k':   /* --k-ary k */\n            errno = 0;\n            ctx->tbon_k = strtoul (optarg, &endptr, 10);\n            if (errno || *endptr != '\\0')\n                log_err_exit (\"k-ary '%s'\", optarg);\n            if (ctx->tbon_k < 1)\n                usage ();\n            break;\n        case 'g':   /* --shutdown-grace */\n            log_msg (\"Warning: --shutdown-grace option is deprecated\");\n            break;\n        case 'S': { /* --setattr ATTR=VAL */\n            char *val, *attr = xstrdup (optarg);\n            if ((val = strchr (attr, '=')))\n                *val++ = '\\0';\n            if (attr_add (ctx->attrs, attr, val, 0) < 0)\n                if (attr_set (ctx->attrs, attr, val, true) < 0)\n                    log_err_exit (\"setattr %s=%s\", attr, val);\n            free (attr);\n            break;\n        }\n        case 'c': /* --config-path PATH */\n            ctx->config_path = optarg;\n            break;\n        default:\n            usage ();\n        }\n    }\n    if (optind < argc) {\n        if ((e = argz_create (argv + optind, &ctx->init_shell_cmd,\n                              &ctx->init_shell_cmd_len)) != 0)\n            log_errn_exit (e, \"argz_create\");\n    }\n}\n\nstatic int setup_profiling (const char *program, int rank)\n{\n#if HAVE_CALIPER\n    cali_begin_string_byname (\"flux.type\", \"main\");\n    cali_begin_int_byname (\"flux.tid\", syscall (SYS_gettid));\n    cali_begin_string_byname (\"binary\", program);\n    cali_begin_int_byname (\"flux.rank\", rank);\n    // TODO: this is a stopgap until we have better control over\n    // instrumemtation in child processes. If we want to see what children\n    // that load libflux are up to, this should be disabled\n    unsetenv (\"CALI_SERVICES_ENABLE\");\n    unsetenv (\"CALI_CONFIG_PROFILE\");\n#endif\n    return (0);\n}\n\nstatic int increase_rlimits (void)\n{\n    struct rlimit rlim;\n\n    /*  Increase number of open files to max to prevent potential failures\n     *   due to file descriptor exhaustion (e.g. failure to open /dev/urandom)\n     */\n    if (getrlimit (RLIMIT_NOFILE, &rlim) < 0) {\n        log_err (\"getrlimit\");\n        return -1;\n    }\n    rlim.rlim_cur = rlim.rlim_max;\n    if (setrlimit (RLIMIT_NOFILE, &rlim) < 0) {\n        log_err (\"Failed to increase nofile limit\");\n        return -1;\n    }\n    return 0;\n}\n\nint main (int argc, char *argv[])\n{\n    broker_ctx_t ctx;\n    sigset_t old_sigmask;\n    struct sigaction old_sigact_int;\n    struct sigaction old_sigact_term;\n    flux_msg_handler_t **handlers = NULL;\n    const flux_conf_t *conf;\n    double boot_elapsed_sec;\n    struct timespec boot_start_time;\n\n    memset (&ctx, 0, sizeof (ctx));\n    log_init (argv[0]);\n\n    ctx.exit_rc = 1;\n\n    if (!(ctx.sigwatchers = zlist_new ()))\n        oom ();\n    if (!(ctx.modhash = modhash_create ()))\n        oom ();\n    if (!(ctx.services = service_switch_create ()))\n        oom ();\n    if (!(ctx.attrs = attr_create ()))\n        oom ();\n    if (!(ctx.subscriptions = zlist_new ()))\n        oom ();\n    if (!(ctx.cache = content_cache_create ()))\n        oom ();\n    if (!(ctx.publisher = publisher_create ()))\n        oom ();\n\n    ctx.tbon_k = 2; /* binary TBON is default */\n    /* Record the instance owner: the effective uid of the broker. */\n    ctx.cred.userid = getuid ();\n    /* Set default rolemask for messages sent with flux_send()\n     * on the broker's internal handle. */\n    ctx.cred.rolemask = FLUX_ROLE_OWNER;\n\n    init_attrs (ctx.attrs, getpid (), &ctx.cred);\n\n    parse_command_line_arguments (argc, argv, &ctx);\n\n    /* Block all signals, saving old mask and actions for SIGINT, SIGTERM.\n     */\n    sigset_t sigmask;\n    sigfillset (&sigmask);\n    if (sigprocmask (SIG_SETMASK, &sigmask, &old_sigmask) < 0)\n        log_err_exit (\"sigprocmask\");\n    if (sigaction (SIGINT, NULL, &old_sigact_int) < 0)\n        log_err_exit (\"sigaction\");\n    if (sigaction (SIGTERM, NULL, &old_sigact_term) < 0)\n        log_err_exit (\"sigaction\");\n\n    /* Initailize zeromq context\n     */\n    if (!zsys_init ()) {\n        log_err (\"zsys_init\");\n        goto cleanup;\n    }\n    zsys_set_logstream (stderr);\n    zsys_set_logident (\"flux-broker\");\n    zsys_handler_set (NULL);\n    zsys_set_linger (5);\n    zsys_set_rcvhwm (0);\n    zsys_set_sndhwm (0);\n    zsys_set_ipv6 (1);\n\n    /* Set up the flux reactor.\n     */\n    if (!(ctx.reactor = flux_reactor_create (FLUX_REACTOR_SIGCHLD))) {\n        log_err (\"flux_reactor_create\");\n        goto cleanup;\n    }\n\n    /* Set up flux handle.\n     * The handle is used for simple purposes such as logging.\n     */\n    if (!(ctx.h = flux_handle_create (&ctx, &broker_handle_ops, 0))) {\n        log_err (\"flux_handle_create\");\n        goto cleanup;\n    }\n    if (flux_set_reactor (ctx.h, ctx.reactor) < 0) {\n        log_err (\"flux_set_reactor\");\n        goto cleanup;\n    }\n\n    /* Parse config.\n     */\n    if (!(ctx.config = brokercfg_create (ctx.h,\n                                         ctx.config_path,\n                                         ctx.attrs,\n                                         ctx.modhash)))\n        goto cleanup;\n    conf = flux_get_conf (ctx.h);\n\n    if (increase_rlimits () < 0)\n        goto cleanup;\n\n    /* Prepare signal handling\n     */\n    if (broker_handle_signals (&ctx) < 0) {\n        log_err (\"broker_handle_signals\");\n        goto cleanup;\n    }\n\n    if (!(ctx.overlay = overlay_create (ctx.h))) {\n        log_err (\"overlay_create\");\n        goto cleanup;\n    }\n    overlay_set_parent_cb (ctx.overlay, parent_cb, &ctx);\n    overlay_set_child_cb (ctx.overlay, child_cb, &ctx);\n\n    /* Arrange for the publisher to route event messages.\n     * handle_event - local subscribers (ctx.h)\n     */\n    if (publisher_set_flux (ctx.publisher, ctx.h) < 0) {\n        log_err (\"publisher_set_flux\");\n        goto cleanup;\n    }\n    if (publisher_set_sender (ctx.publisher, \"handle_event\",\n                              (publisher_send_f)handle_event, &ctx) < 0) {\n        log_err (\"publisher_set_sender\");\n        goto cleanup;\n    }\n\n    if (create_rundir (ctx.attrs) < 0)\n        goto cleanup;\n\n    /* Set & create broker.rundir *after* overlay initialization,\n     * when broker rank is determined.\n     */\n    overlay_set_init_callback (ctx.overlay, create_broker_rundir, ctx.attrs);\n\n    /* Execute broker network bootstrap.\n     * Default method is pmi.\n     * If [bootstrap] is defined in configuration, use static configuration.\n     */\n    monotime (&boot_start_time);\n    if (flux_conf_unpack (conf, NULL, \"{s:{}}\", \"bootstrap\") == 0) {\n        if (boot_config (ctx.h, ctx.overlay, ctx.attrs, ctx.tbon_k) < 0) {\n            log_msg (\"bootstrap failed\");\n            goto cleanup;\n        }\n    }\n    else { // PMI\n        if (boot_pmi (ctx.overlay, ctx.attrs, ctx.tbon_k) < 0) {\n            log_msg (\"bootstrap failed\");\n            goto cleanup;\n        }\n    }\n    boot_elapsed_sec = monotime_since (boot_start_time) / 1000;\n\n    ctx.rank = overlay_get_rank (ctx.overlay);\n    ctx.size = overlay_get_size (ctx.overlay);\n    snprintf (ctx.uuid, sizeof (ctx.uuid), \"%\"PRIu32, ctx.rank);\n\n    assert (ctx.size > 0);\n\n    /* Must be called after overlay setup */\n    if (overlay_register_attrs (ctx.overlay, ctx.attrs) < 0) {\n        log_err (\"registering overlay attributes\");\n        goto cleanup;\n    }\n\n    if (ctx.verbose) {\n        log_msg (\"boot: rank=%d size=%d time %.3fs\",\n                  ctx.rank,\n                  ctx.size,\n                  boot_elapsed_sec);\n    }\n\n    // Setup profiling\n    setup_profiling (argv[0], ctx.rank);\n\n    /* Initialize logging.\n     * OK to call flux_log*() after this.\n     */\n    logbuf_initialize (ctx.h, ctx.rank, ctx.attrs);\n\n    /* Allow flux_get_rank() and flux_get_size() to work in the broker.\n     */\n    if (create_dummyattrs (ctx.h, ctx.rank, ctx.size) < 0) {\n        log_err (\"creating dummy attributes\");\n        goto cleanup;\n    }\n\n    /* Registers message handlers and obtains rank.\n     */\n    if (content_cache_set_flux (ctx.cache, ctx.h) < 0) {\n        log_err (\"content_cache_set_flux\");\n        goto cleanup;\n    }\n    if (content_cache_register_attrs (ctx.cache, ctx.attrs) < 0) {\n        log_err (\"content cache attributes\");\n        goto cleanup;\n    }\n\n    if (ctx.verbose) {\n        const char *parent = overlay_get_parent_uri (ctx.overlay);\n        const char *child = overlay_get_bind_uri (ctx.overlay);\n        log_msg (\"parent: %s\", parent ? parent : \"none\");\n        log_msg (\"child: %s\", child ? child : \"none\");\n    }\n\n    set_proctitle (ctx.rank);\n\n    if (create_runat_phases (&ctx) < 0)\n        goto cleanup;\n\n    /* If Flux was launched by Flux, now that PMI bootstrap and runat\n     * initialization is complete, unset Flux job environment variables\n     * so that they don't leak into the jobs other children of this instance.\n     */\n    unsetenv (\"FLUX_JOB_ID\");\n    unsetenv (\"FLUX_JOB_SIZE\");\n    unsetenv (\"FLUX_JOB_NNODES\");\n\n    /* Wire up the overlay.\n     */\n    if (ctx.rank > 0) {\n        if (ctx.verbose)\n            log_msg (\"initializing overlay connect\");\n        if (overlay_connect (ctx.overlay) < 0) {\n            log_err (\"overlay_connect\");\n            goto cleanup;\n        }\n    }\n\n    /* Register internal services\n     */\n    if (attr_register_handlers (ctx.attrs, ctx.h) < 0) {\n        log_err (\"attr_register_handlers\");\n        goto cleanup;\n    }\n    if (heaptrace_initialize (ctx.h) < 0) {\n        log_err (\"heaptrace_initialize\");\n        goto cleanup;\n    }\n    if (exec_initialize (ctx.h, ctx.rank, ctx.attrs) < 0) {\n        log_err (\"exec_initialize\");\n        goto cleanup;\n    }\n    if (ping_initialize (ctx.h, \"broker\", ctx.uuid) < 0) {\n        log_err (\"ping_initialize\");\n        goto cleanup;\n    }\n    if (rusage_initialize (ctx.h, \"broker\") < 0) {\n        log_err (\"rusage_initialize\");\n        goto cleanup;\n    }\n\n    if (!(handlers = broker_add_services (&ctx))) {\n        log_err (\"broker_add_services\");\n        goto cleanup;\n    }\n\n    /* Initialize module infrastructure.\n     */\n    if (ctx.verbose > 1)\n        log_msg (\"initializing modules\");\n    modhash_set_rank (ctx.modhash, ctx.rank);\n    modhash_set_flux (ctx.modhash, ctx.h);\n\n    /* Configure broker state machine\n     */\n    if (!(ctx.state_machine = state_machine_create (&ctx))) {\n        log_err (\"error creating broker state machine\");\n        goto cleanup;\n    }\n    state_machine_post (ctx.state_machine, \"start\");\n\n    /* Load the local connector module.\n     * Other modules will be loaded in rc1 using flux module,\n     * which uses the local connector.\n     * The shutdown protocol unloads it.\n     */\n    if (ctx.verbose > 1)\n        log_msg (\"loading connector-local\");\n    if (load_module_byname (&ctx, \"connector-local\", NULL, 0, NULL) < 0) {\n        log_err (\"load_module connector-local\");\n        goto cleanup;\n    }\n\n    /* Event loop\n     */\n    if (ctx.verbose > 1)\n        log_msg (\"entering event loop\");\n    /* Once we enter the reactor, default exit_rc is now 0 */\n    ctx.exit_rc = 0;\n    if (flux_reactor_run (ctx.reactor, 0) < 0)\n        log_err (\"flux_reactor_run\");\n    if (ctx.verbose > 1)\n        log_msg (\"exited event loop\");\n\n    /* inform all lingering subprocesses we are tearing down.  Do this\n     * before any cleanup/teardown below, as this call will re-enter\n     * the reactor.\n     */\n    exec_terminate_subprocesses (ctx.h);\n\ncleanup:\n    if (ctx.verbose > 1)\n        log_msg (\"cleaning up\");\n\n    /* Restore default sigmask and actions for SIGINT, SIGTERM\n     */\n    if (sigprocmask (SIG_SETMASK, &old_sigmask, NULL) < 0)\n        log_err (\"sigprocmask\");\n    if (sigaction (SIGINT, &old_sigact_int, NULL) < 0)\n        log_err (\"sigaction\");\n    if (sigaction (SIGTERM, &old_sigact_term, NULL) < 0)\n        log_err (\"sigaction\");\n\n    /* Unregister builtin services\n     */\n    attr_destroy (ctx.attrs);\n    content_cache_destroy (ctx.cache);\n\n    modhash_destroy (ctx.modhash);\n    zlist_destroy (&ctx.sigwatchers);\n    state_machine_destroy (ctx.state_machine);\n    overlay_destroy (ctx.overlay);\n    service_switch_destroy (ctx.services);\n    broker_remove_services (handlers);\n    publisher_destroy (ctx.publisher);\n    brokercfg_destroy (ctx.config);\n    runat_destroy (ctx.runat);\n    flux_close (ctx.h);\n    flux_reactor_destroy (ctx.reactor);\n    zlist_destroy (&ctx.subscriptions);\n    free (ctx.init_shell_cmd);\n\n    return ctx.exit_rc;\n}\n\nstruct attrmap {\n    const char *env;\n    const char *attr;\n    uint8_t required:1;\n    uint8_t sanitize:1;\n};\n\nstatic struct attrmap attrmap[] = {\n    { \"FLUX_EXEC_PATH\",         \"conf.exec_path\",           1, 0 },\n    { \"FLUX_CONNECTOR_PATH\",    \"conf.connector_path\",      1, 0 },\n    { \"FLUX_MODULE_PATH\",       \"conf.module_path\",         1, 0 },\n    { \"FLUX_PMI_LIBRARY_PATH\",  \"conf.pmi_library_path\",    1, 0 },\n\n    { \"FLUX_URI\",               \"parent-uri\",               0, 1 },\n    { \"FLUX_KVS_NAMESPACE\",     \"parent-kvs-namespace\",     0, 1 },\n    { NULL, NULL, 0, 0 },\n};\n\nstatic void init_attrs_from_environment (attr_t *attrs)\n{\n    struct attrmap *m;\n    const char *val;\n    int flags = 0;  // XXX possibly these should be immutable?\n\n    for (m = &attrmap[0]; m->env != NULL; m++) {\n        val = getenv (m->env);\n        if (!val && m->required)\n            log_msg_exit (\"required environment variable %s is not set\", m->env);\n        if (attr_add (attrs, m->attr, val, flags) < 0)\n            log_err_exit (\"attr_add %s\", m->attr);\n        if (m->sanitize)\n            unsetenv (m->env);\n    }\n}\n\nstatic void init_attrs_broker_pid (attr_t *attrs, pid_t pid)\n{\n    char *attrname = \"broker.pid\";\n    char *pidval;\n\n    pidval = xasprintf (\"%u\", pid);\n    if (attr_add (attrs,\n                  attrname,\n                  pidval,\n                  FLUX_ATTRFLAG_IMMUTABLE) < 0)\n        log_err_exit (\"attr_add %s\", attrname);\n    free (pidval);\n}\n\nstatic void init_attrs_rc_paths (attr_t *attrs)\n{\n    if (attr_add (attrs,\n                  \"broker.rc1_path\",\n                  flux_conf_builtin_get (\"rc1_path\", FLUX_CONF_AUTO),\n                  0) < 0)\n        log_err_exit (\"attr_add rc1_path\");\n\n    if (attr_add (attrs,\n                  \"broker.rc3_path\",\n                  flux_conf_builtin_get (\"rc3_path\", FLUX_CONF_AUTO),\n                  0) < 0)\n        log_err_exit (\"attr_add rc3_path\");\n}\n\nstatic void init_attrs_shell_paths (attr_t *attrs)\n{\n    if (attr_add (attrs,\n                  \"conf.shell_pluginpath\",\n                  flux_conf_builtin_get (\"shell_pluginpath\", FLUX_CONF_AUTO),\n                  0) < 0)\n        log_err_exit (\"attr_add conf.shell_pluginpath\");\n    if (attr_add (attrs,\n                  \"conf.shell_initrc\",\n                  flux_conf_builtin_get (\"shell_initrc\", FLUX_CONF_AUTO),\n                  0) < 0)\n        log_err_exit (\"attr_add conf.shell_initrc\");\n}\n\nstatic void init_attrs (attr_t *attrs, pid_t pid, struct flux_msg_cred *cred)\n{\n    /* Initialize config attrs from environment set up by flux(1)\n     */\n    init_attrs_from_environment (attrs);\n\n    /* Initialize other miscellaneous attrs\n     */\n    init_attrs_broker_pid (attrs, pid);\n    init_attrs_rc_paths (attrs);\n    init_attrs_shell_paths (attrs);\n\n    if (attr_add (attrs, \"version\", FLUX_CORE_VERSION_STRING,\n                                            FLUX_ATTRFLAG_IMMUTABLE) < 0)\n        log_err_exit (\"attr_add version\");\n\n    char tmp[32];\n    snprintf (tmp, sizeof (tmp), \"%ju\", (uintmax_t)cred->userid);\n    if (attr_add (attrs, \"security.owner\", tmp, FLUX_ATTRFLAG_IMMUTABLE) < 0)\n        log_err_exit (\"attr_add owner\");\n}\n\nstatic void set_proctitle (uint32_t rank)\n{\n    static char proctitle[32];\n    snprintf (proctitle, sizeof (proctitle), \"flux-broker-%\"PRIu32, rank);\n    (void)prctl (PR_SET_NAME, proctitle, 0, 0, 0);\n}\n\nstatic int create_runat_rc2 (struct runat *r, const char *argz, size_t argz_len)\n{\n    if (argz == NULL) { // run interactive shell\n        if (runat_push_shell (r, \"rc2\") < 0)\n            return -1;\n    }\n    else if (argz_count (argz, argz_len) == 1) { // run shell -c \"command\"\n        if (runat_push_shell_command (r, \"rc2\", argz, false) < 0)\n            return -1;\n    }\n    else { // direct exec\n        if (runat_push_command (r, \"rc2\", argz, argz_len, false) < 0)\n            return -1;\n    }\n    return 0;\n}\n\nstatic int create_runat_phases (broker_ctx_t *ctx)\n{\n    const char *rc1, *rc3, *local_uri;\n    bool rc2_none = false;\n\n    if (attr_get (ctx->attrs, \"local-uri\", &local_uri, NULL) < 0) {\n        log_err (\"local-uri is not set\");\n        return -1;\n    }\n    if (attr_get (ctx->attrs, \"broker.rc1_path\", &rc1, NULL) < 0) {\n        log_err (\"broker.rc1_path is not set\");\n        return -1;\n    }\n    if (attr_get (ctx->attrs, \"broker.rc3_path\", &rc3, NULL) < 0) {\n        log_err (\"broker.rc3_path is not set\");\n        return -1;\n    }\n    if (attr_get (ctx->attrs, \"broker.rc2_none\", NULL, NULL) == 0)\n        rc2_none = true;\n\n    if (!(ctx->runat = runat_create (ctx->h, local_uri))) {\n        log_err (\"runat_create\");\n        return -1;\n    }\n\n    /* rc1 - initialization\n     */\n    if (rc1 && strlen (rc1) > 0) {\n        if (runat_push_shell_command (ctx->runat, \"rc1\", rc1, true) < 0) {\n            log_err (\"runat_push_shell_command rc1\");\n            return -1;\n        }\n    }\n\n    /* rc2 - initial program\n     */\n    if (ctx->rank == 0 && !rc2_none) {\n        if (create_runat_rc2 (ctx->runat, ctx->init_shell_cmd,\n                                          ctx->init_shell_cmd_len) < 0) {\n            log_err (\"create_runat_rc2\");\n            return -1;\n        }\n    }\n\n    /* rc3 - finalization\n     */\n    if (rc3 && strlen (rc3) > 0) {\n        if (runat_push_shell_command (ctx->runat, \"rc3\", rc3, true) < 0) {\n            log_err (\"runat_push_shell_command rc3\");\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic int create_dummyattrs (flux_t *h, uint32_t rank, uint32_t size)\n{\n    char *rank_str = NULL;\n    char *size_str = NULL;\n    int rc = -1;\n\n    if (asprintf (&rank_str, \"%\"PRIu32, rank) < 0)\n        goto cleanup;\n    if (flux_attr_set_cacheonly (h, \"rank\", rank_str) < 0)\n        goto cleanup;\n\n    if (asprintf (&size_str, \"%\"PRIu32, size) < 0)\n        goto cleanup;\n    if (flux_attr_set_cacheonly (h, \"size\", size_str) < 0)\n        goto cleanup;\n\n    rc = 0;\ncleanup:\n    free (rank_str);\n    free (size_str);\n    return rc;\n}\n\n/*  Handle global rundir attribute.\n *\n *  If not set, create a temporary directory and use it as the rundir.\n *  If set, attempt to create it if it doesn't exist. In either case,\n *  validate directory persmissions and set the rundir attribute\n *  immutable. If the rundir is created by this function it will be\n *  scheduled for later cleanup at broker exit. Pre-existing directories\n *  are left intact.\n */\nstatic int create_rundir (attr_t *attrs)\n{\n    const char *run_dir;\n    char *dir = NULL;\n    char *uri = NULL;\n    bool do_cleanup = true;\n    struct stat sb;\n    int rc = -1;\n\n    /*  If rundir attribute isn't set, then create a temp directory\n     *   and use that as rundir. If directory was set, try to create it if\n     *   it doesn't exist. If directory was pre-existing, do not schedule\n     *   the dir for auto-cleanup at broker exit.\n     */\n    if (attr_get (attrs, \"rundir\", &run_dir, NULL) < 0) {\n        const char *tmpdir = getenv (\"TMPDIR\");\n        if (asprintf (&dir, \"%s/flux-XXXXXX\", tmpdir ? tmpdir : \"/tmp\") < 0) {\n            log_err (\"out of memory\");\n            goto done;\n        }\n        if (!(run_dir = mkdtemp (dir))) {\n            log_err (\"cannot create directory in %s\", tmpdir);\n            goto done;\n        }\n        if (attr_add (attrs, \"rundir\", run_dir, 0) < 0) {\n            log_err (\"error setting rundir broker attribute\");\n            goto done;\n        }\n    }\n    else if (mkdir (run_dir, 0700) < 0) {\n        if (errno != EEXIST) {\n            log_err (\"error creating rundir %s \", run_dir);\n            goto done;\n        }\n        /* Do not cleanup directory if we did not create it here\n         */\n        do_cleanup = false;\n    }\n\n    /*  Ensure created or existing directory is writeable:\n     */\n    if (stat (run_dir, &sb) < 0) {\n        log_err (\"cannot stat rundir %s \", run_dir);\n        goto done;\n    }\n    if (!S_ISDIR (sb.st_mode)) {\n        errno = ENOTDIR;\n        log_err (\"rundir %s \", run_dir);\n        goto done;\n    }\n    if ((sb.st_mode & S_IRWXU) != S_IRWXU) {\n        log_msg (\"rundir %s does not have owner=rwx permissions\", run_dir);\n        errno = EPERM;\n        goto done;\n    }\n\n    /*  rundir is now fixed, so make the attribute immutable, and\n     *   schedule the dir for cleanup at exit if we created it here.\n     */\n    if (attr_set_flags (attrs, \"rundir\", FLUX_ATTRFLAG_IMMUTABLE) < 0) {\n        log_err (\"error setting rundir broker attribute flags\");\n        goto done;\n    }\n    if (do_cleanup)\n        cleanup_push_string (cleanup_directory_recursive, run_dir);\n    rc = 0;\ndone:\n    free (dir);\n    free (uri);\n    return rc;\n}\n\nstatic int create_broker_rundir (struct overlay *ov, void *arg)\n{\n    attr_t *attrs = arg;\n    uint32_t rank;\n    const char *rundir;\n    const char *local_uri;\n    char *broker_rundir = NULL;\n    char *uri = NULL;\n    int rv = -1;\n\n    if (attr_get (attrs, \"rundir\", &rundir, NULL) < 0) {\n        log_msg (\"create_broker_rundir: rundir attribute not set\");\n        goto cleanup;\n    }\n\n    rank = overlay_get_rank (ov);\n    if (asprintf (&broker_rundir, \"%s/%u\", rundir, rank) < 0) {\n        log_err (\"create_broker_rundir: asprintf\");\n        goto cleanup;\n    }\n    if (mkdir (broker_rundir, 0700) < 0) {\n        log_err (\"create_broker_rundir: mkdir (%s)\", broker_rundir);\n        goto cleanup;\n    }\n    if (attr_add (attrs, \"broker.rundir\", broker_rundir,\n                  FLUX_ATTRFLAG_IMMUTABLE) < 0) {\n        log_err (\"create_broker_rundir: attr_add broker.rundir\");\n        goto cleanup;\n    }\n\n    if (attr_get (attrs, \"local-uri\", &local_uri, NULL) < 0) {\n        if (asprintf (&uri, \"local://%s/local\", broker_rundir) < 0) {\n            log_err (\"create_broker_rundir: asprintf (uri)\");\n            goto cleanup;\n        }\n        if (attr_add (attrs, \"local-uri\", uri, FLUX_ATTRFLAG_IMMUTABLE) < 0) {\n            log_err (\"create_broker_rundir: attr_add (local-uri)\");\n            goto cleanup;\n        }\n    }\n    rv = 0;\ncleanup:\n    free (uri);\n    free (broker_rundir);\n    return rv;\n}\n\nstatic bool nodeset_member (const char *s, uint32_t rank)\n{\n    struct idset *ns = NULL;\n    bool member = true;\n\n    if (s) {\n        if (!(ns = idset_decode (s)))\n            log_msg_exit (\"malformed nodeset: %s\", s);\n        member = idset_test (ns, rank);\n        idset_destroy (ns);\n    }\n    return member;\n}\n\nstatic int mod_svc_cb (const flux_msg_t *msg, void *arg)\n{\n    module_t *p = arg;\n    int rc = module_sendmsg (p, msg);\n    return rc;\n}\n\n/* If a dlerror/dlsym error occurs during modfind/modname,\n * log it here.  Such messages can be helpful in diagnosing\n * dynamic binding problems for modules.\n */\nstatic void module_dlerror (const char *errmsg, void *arg)\n{\n    flux_t *h = arg;\n    flux_log (h, LOG_DEBUG, \"flux_modname: %s\", errmsg);\n}\n\n\nstatic int load_module_bypath (broker_ctx_t *ctx, const char *path,\n                               const char *argz, size_t argz_len,\n                               const flux_msg_t *request)\n{\n    module_t *p = NULL;\n    char *name, *arg;\n\n    if (!(name = flux_modname (path, module_dlerror, ctx->h))) {\n        errno = ENOENT;\n        goto error;\n    }\n    if (!(p = module_add (ctx->modhash, path)))\n        goto error;\n    if (service_add (ctx->services, module_get_name (p),\n                                    module_get_uuid (p), mod_svc_cb, p) < 0)\n        goto module_remove;\n    arg = argz_next (argz, argz_len, NULL);\n    while (arg) {\n        module_add_arg (p, arg);\n        arg = argz_next (argz, argz_len, arg);\n    }\n    module_set_poller_cb (p, module_cb, ctx);\n    module_set_status_cb (p, module_status_cb, ctx);\n    if (request && module_push_insmod (p, request) < 0) // response deferred\n        goto service_remove;\n    if (module_start (p) < 0)\n        goto service_remove;\n    flux_log (ctx->h, LOG_DEBUG, \"insmod %s\", name);\n    free (name);\n    return 0;\nservice_remove:\n    service_remove_byuuid (ctx->services, module_get_uuid (p));\nmodule_remove:\n    module_remove (ctx->modhash, p);\nerror:\n    free (name);\n    return -1;\n}\n\nstatic int load_module_byname (broker_ctx_t *ctx, const char *name,\n                               const char *argz, size_t argz_len,\n                               const flux_msg_t *request)\n{\n    const char *modpath;\n    char *path;\n\n    if (attr_get (ctx->attrs, \"conf.module_path\", &modpath, NULL) < 0) {\n        log_msg (\"conf.module_path is not set\");\n        return -1;\n    }\n    if (!(path = flux_modfind (modpath, name, module_dlerror, ctx->h))) {\n        log_msg (\"%s: not found in module search path\", name);\n        return -1;\n    }\n    if (load_module_bypath (ctx, path, argz, argz_len, request) < 0) {\n        free (path);\n        return -1;\n    }\n    free (path);\n    return 0;\n}\n\nstatic int unload_module_byname (broker_ctx_t *ctx, const char *name,\n                                 const flux_msg_t *request)\n{\n    module_t *p;\n\n    if (!(p = module_lookup_byname (ctx->modhash, name))) {\n        errno = ENOENT;\n        return -1;\n    }\n    if (module_stop (p) < 0)\n        return -1;\n    if (module_push_rmmod (p, request) < 0)\n        return -1;\n    flux_log (ctx->h, LOG_DEBUG, \"rmmod %s\", name);\n    return 0;\n}\n\nstatic void broker_destroy_sigwatcher (void *data)\n{\n    flux_watcher_t *w = data;\n    flux_watcher_stop (w);\n    flux_watcher_destroy (w);\n}\n\nstatic int broker_handle_signals (broker_ctx_t *ctx)\n{\n    int i, sigs[] = { SIGHUP, SIGINT, SIGQUIT, SIGTERM, SIGSEGV, SIGFPE,\n                      SIGALRM };\n    flux_watcher_t *w;\n\n    for (i = 0; i < sizeof (sigs) / sizeof (sigs[0]); i++) {\n        w = flux_signal_watcher_create (ctx->reactor, sigs[i], signal_cb, ctx);\n        if (!w) {\n            log_err (\"flux_signal_watcher_create\");\n            return -1;\n        }\n        if (zlist_push (ctx->sigwatchers, w) < 0) {\n            log_errn (ENOMEM, \"zlist_push\");\n            return -1;\n        }\n        zlist_freefn (ctx->sigwatchers, w, broker_destroy_sigwatcher, false);\n        flux_watcher_start (w);\n    }\n    return 0;\n}\n\n/**\n ** Built-in services\n **/\n\n/* Unload a module by name, asynchronously.\n * Message format is defined by RFC 5.\n * N.B. unload_module_byname() handles response, unless it fails early\n * and returns -1.\n */\nstatic void broker_rmmod_cb (flux_t *h, flux_msg_handler_t *mh,\n                             const flux_msg_t *msg, void *arg)\n{\n    broker_ctx_t *ctx = arg;\n    const char *name;\n\n    if (flux_request_unpack (msg, NULL, \"{s:s}\", \"name\", &name) < 0)\n        goto error;\n    if (unload_module_byname (ctx, name, msg) < 0)\n        goto error;\n    return;\nerror:\n    if (flux_respond_error (h, msg, errno, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond_error\", __FUNCTION__);\n}\n\n/* Load a module by name, asynchronously.\n * Message format is defined by RFC 5.\n * N.B. load_module_bypath() handles response, unless it returns -1.\n */\nstatic void broker_insmod_cb (flux_t *h, flux_msg_handler_t *mh,\n                              const flux_msg_t *msg, void *arg)\n{\n    broker_ctx_t *ctx = arg;\n    const char *path;\n    json_t *args;\n    size_t index;\n    json_t *value;\n    char *argz = NULL;\n    size_t argz_len = 0;\n    error_t e;\n\n    if (flux_request_unpack (msg, NULL, \"{s:s s:o}\", \"path\", &path,\n                                                     \"args\", &args) < 0)\n        goto error;\n    if (!json_is_array (args))\n        goto proto;\n    json_array_foreach (args, index, value) {\n        if (!json_is_string (value))\n            goto proto;\n        if ((e = argz_add (&argz, &argz_len, json_string_value (value)))) {\n            errno = e;\n            goto error;\n        }\n    }\n    if (load_module_bypath (ctx, path, argz, argz_len, msg) < 0)\n        goto error;\n    free (argz);\n    return;\nproto:\n    errno = EPROTO;\nerror:\n    if (flux_respond_error (h, msg, errno, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond_error\", __FUNCTION__);\n    free (argz);\n}\n\n/* Load a module by name.\n * Message format is defined by RFC 5.\n */\nstatic void broker_lsmod_cb (flux_t *h, flux_msg_handler_t *mh,\n                             const flux_msg_t *msg, void *arg)\n{\n    broker_ctx_t *ctx = arg;\n    json_t *mods = NULL;\n\n    if (flux_request_decode (msg, NULL, NULL) < 0)\n        goto error;\n    if (!(mods = module_get_modlist (ctx->modhash, ctx->services)))\n        goto error;\n    if (flux_respond_pack (h, msg, \"{s:O}\", \"mods\", mods) < 0)\n        flux_log_error (h, \"%s: flux_respond_pack\", __FUNCTION__);\n    json_decref (mods);\n    return;\nerror:\n    if (flux_respond_error (h, msg, errno, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond_error\", __FUNCTION__);\n}\n\n#if CODE_COVERAGE_ENABLED\nvoid __gcov_flush (void);\n#endif\n\nstatic void broker_panic_cb (flux_t *h, flux_msg_handler_t *mh,\n                             const flux_msg_t *msg, void *arg)\n{\n    const char *reason;\n    int flags; // reserved\n\n    if (flux_request_unpack (msg, NULL, \"{s:s s:i}\",\n                             \"reason\", &reason,\n                             \"flags\", &flags) < 0) {\n        flux_log_error (h, \"malformed broker.panic request\");\n        return;\n    }\n    fprintf (stderr, \"PANIC: %s\\n\", reason);\n#if CODE_COVERAGE_ENABLED\n    __gcov_flush ();\n#endif\n    _exit (1);\n    /*NOTREACHED*/\n}\n\nstatic void broker_disconnect_cb (flux_t *h, flux_msg_handler_t *mh,\n                               const flux_msg_t *msg, void *arg)\n{\n    char *sender = NULL;\n\n    if (flux_msg_get_route_first (msg, &sender) == 0) {\n        exec_terminate_subprocesses_by_uuid (h, sender);\n        free (sender);\n    }\n    /* no response */\n}\n\nstatic void broker_sub_cb (flux_t *h, flux_msg_handler_t *mh,\n                        const flux_msg_t *msg, void *arg)\n{\n    broker_ctx_t *ctx = arg;\n    char *uuid = NULL;\n    const char *topic;\n\n    if (flux_request_unpack (msg, NULL, \"{ s:s }\", \"topic\", &topic) < 0)\n        goto error;\n    if (flux_msg_get_route_first (msg, &uuid) < 0)\n        goto error;\n    if (!uuid) {\n        errno = EPROTO;\n        goto error;\n    }\n    if (module_subscribe (ctx->modhash, uuid, topic) < 0)\n        goto error;\n    if (flux_respond (h, msg, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond\", __FUNCTION__);\n    free (uuid);\n    return;\nerror:\n    if (flux_respond_error (h, msg, errno, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond_error\", __FUNCTION__);\n    free (uuid);\n}\n\nstatic void broker_unsub_cb (flux_t *h, flux_msg_handler_t *mh,\n                          const flux_msg_t *msg, void *arg)\n{\n    broker_ctx_t *ctx = arg;\n    char *uuid = NULL;\n    const char *topic;\n\n    if (flux_request_unpack (msg, NULL, \"{ s:s }\", \"topic\", &topic) < 0)\n        goto error;\n    if (flux_msg_get_route_first (msg, &uuid) < 0)\n        goto error;\n    if (!uuid) {\n        errno = EPROTO;\n        goto error;\n    }\n    if (module_unsubscribe (ctx->modhash, uuid, topic) < 0)\n        goto error;\n    if (flux_respond (h, msg, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond\", __FUNCTION__);\n    free (uuid);\n    return;\nerror:\n    if (flux_respond_error (h, msg, errno, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond_error\", __FUNCTION__);\n    free (uuid);\n}\n\nstatic int route_to_handle (const flux_msg_t *msg, void *arg)\n{\n    broker_ctx_t *ctx = arg;\n    if (flux_requeue (ctx->h, msg, FLUX_RQ_TAIL) < 0)\n        flux_log_error (ctx->h, \"%s: flux_requeue\\n\", __FUNCTION__);\n    return 0;\n}\n\n/* Check whether requestor 'cred' is authorized to add/remove service 'name'.\n * Allow a guest control over a service IFF it is prefixed with \"<userid>-\".\n * Return 0 on success, -1 with errno set on failure.\n */\nstatic int service_allow (struct flux_msg_cred cred, const char *name)\n{\n    char prefix[16];\n    if ((cred.rolemask & FLUX_ROLE_OWNER))\n        return 0;\n    snprintf (prefix, sizeof (prefix), \"%\" PRIu32 \"-\", cred.userid);\n    if (!strncmp (prefix, name, strlen (prefix)))\n        return 0;\n    errno = EPERM;\n    return -1;\n}\n\n/* Dynamic service registration.\n * These handlers need to appear in broker.c so that they have\n *  access to broker internals like modhash\n */\nstatic void service_add_cb (flux_t *h, flux_msg_handler_t *w,\n                            const flux_msg_t *msg, void *arg)\n{\n    broker_ctx_t *ctx = arg;\n    const char *name = NULL;\n    char *sender = NULL;\n    module_t *p;\n    struct flux_msg_cred cred;\n\n    if (flux_request_unpack (msg, NULL, \"{ s:s }\", \"service\", &name) < 0\n            || flux_msg_get_cred (msg, &cred) < 0)\n        goto error;\n    if (service_allow (cred, name) < 0)\n        goto error;\n    if (flux_msg_get_route_first (msg, &sender) < 0)\n        goto error;\n    if (!(p = module_lookup (ctx->modhash, sender))) {\n        errno = ENOENT;\n        goto error;\n    }\n    if (service_add (ctx->services, name, sender, mod_svc_cb, p) < 0)\n        goto error;\n    if (flux_respond (h, msg, NULL) < 0)\n        flux_log_error (h, \"service_add: flux_respond\");\n    free (sender);\n    return;\nerror:\n    if (flux_respond_error (h, msg, errno, NULL) < 0)\n        flux_log_error (h, \"service_add: flux_respond_error\");\n    free (sender);\n}\n\nstatic void service_remove_cb (flux_t *h, flux_msg_handler_t *w,\n                               const flux_msg_t *msg, void *arg)\n{\n    broker_ctx_t *ctx = arg;\n    const char *name;\n    const char *uuid;\n    char *sender = NULL;\n    struct flux_msg_cred cred;\n\n    if (flux_request_unpack (msg, NULL, \"{ s:s }\", \"service\", &name) < 0\n            || flux_msg_get_cred (msg, &cred) < 0)\n        goto error;\n    if (service_allow (cred, name) < 0)\n        goto error;\n    if (flux_msg_get_route_first (msg, &sender) < 0)\n        goto error;\n    if (!(uuid = service_get_uuid (ctx->services, name))) {\n        errno = ENOENT;\n        goto error;\n    }\n    if (strcmp (uuid, sender) != 0) {\n        errno = EINVAL;\n        goto error;\n    }\n    service_remove (ctx->services, name);\n    if (flux_respond (h, msg, NULL) < 0)\n        flux_log_error (h, \"service_remove: flux_respond\");\n    free (sender);\n    return;\nerror:\n    if (flux_respond_error (h, msg, errno, NULL) < 0)\n        flux_log_error (h, \"service_remove: flux_respond_error\");\n    free (sender);\n}\n\n\nstatic const struct flux_msg_handler_spec htab[] = {\n    {\n        FLUX_MSGTYPE_REQUEST,\n        \"broker.rmmod\",\n        broker_rmmod_cb,\n        0\n    },\n    {\n        FLUX_MSGTYPE_REQUEST,\n        \"broker.insmod\",\n        broker_insmod_cb,\n        0\n    },\n    {\n        FLUX_MSGTYPE_REQUEST,\n        \"broker.lsmod\",\n        broker_lsmod_cb,\n        0\n    },\n    {\n        FLUX_MSGTYPE_REQUEST,\n        \"broker.panic\",\n        broker_panic_cb,\n        0\n    },\n    {\n        FLUX_MSGTYPE_REQUEST,\n        \"broker.disconnect\",\n        broker_disconnect_cb,\n        0\n    },\n    {\n        FLUX_MSGTYPE_REQUEST,\n        \"broker.sub\",\n        broker_sub_cb,\n        0\n    },\n    {\n        FLUX_MSGTYPE_REQUEST,\n        \"broker.unsub\",\n        broker_unsub_cb,\n        0\n    },\n    {\n        FLUX_MSGTYPE_REQUEST,\n        \"service.add\",\n        service_add_cb,\n        FLUX_ROLE_USER,\n    },\n    {\n        FLUX_MSGTYPE_REQUEST,\n        \"service.remove\",\n        service_remove_cb,\n        FLUX_ROLE_USER,\n    },\n    FLUX_MSGHANDLER_TABLE_END,\n};\n\nstruct internal_service {\n    const char *name;\n    const char *nodeset;\n};\n\nstatic struct internal_service services[] = {\n    { \"broker\",             NULL }, // kind of a catch-all, slowly deprecating\n    { \"log\",                NULL },\n    { \"content\",            NULL },\n    { \"attr\",               NULL },\n    { \"heaptrace\",          NULL },\n    { \"event\",              \"[0]\" },\n    { \"service\",            NULL },\n    { \"overlay\",            NULL },\n    { \"config\",             NULL },\n    { \"runat\",              NULL },\n    { \"state-machine\",      NULL },\n    { NULL, NULL, },\n};\n\n/* Register builtin services (sharing ctx->h and broker thread).\n * Register message handlers for some broker services.  Others are registered\n * in their own initialization functions.\n */\nstatic flux_msg_handler_t **broker_add_services (broker_ctx_t *ctx)\n{\n    flux_msg_handler_t **handlers;\n    struct internal_service *svc;\n    for (svc = &services[0]; svc->name != NULL; svc++) {\n        if (!nodeset_member (svc->nodeset, ctx->rank))\n            continue;\n        if (service_add (ctx->services, svc->name, NULL,\n                         route_to_handle, ctx) < 0) {\n            log_err (\"error registering service for %s\", svc->name);\n            return NULL;\n        }\n    }\n\n    if (flux_msg_handler_addvec (ctx->h, htab, ctx, &handlers) < 0) {\n        log_err (\"error registering message handlers\");\n        return NULL;\n    }\n    return handlers;\n}\n\n/* Unregister message handlers\n */\nstatic void broker_remove_services (flux_msg_handler_t *handlers[])\n{\n    flux_msg_handler_delvec (handlers);\n}\n\n/**\n ** reactor callbacks\n **/\n\n\n/* Handle requests from overlay peers.\n */\nstatic void child_cb (struct overlay *ov, void *arg)\n{\n    broker_ctx_t *ctx = arg;\n    int type;\n    char *uuid = NULL;\n    flux_msg_t *msg = overlay_recvmsg_child (ctx->overlay);\n    int status = KEEPALIVE_STATUS_NORMAL;\n\n    if (!msg)\n        goto done;\n    if (flux_msg_get_type (msg, &type) < 0)\n        goto done;\n    if (flux_msg_get_route_last (msg, &uuid) < 0)\n        goto done;\n    if (type != FLUX_MSGTYPE_KEEPALIVE)\n        overlay_keepalive_child (ctx->overlay, uuid, status);\n    switch (type) {\n        case FLUX_MSGTYPE_KEEPALIVE:\n            if (flux_keepalive_decode (msg, NULL, &status) < 0)\n                goto done;\n            overlay_keepalive_child (ctx->overlay, uuid, status);\n            break;\n        case FLUX_MSGTYPE_REQUEST:\n            broker_request_sendmsg (ctx, msg);\n            break;\n        case FLUX_MSGTYPE_RESPONSE:\n            /* TRICKY:  Fix up ROUTER socket used in reverse direction.\n             * Request/response is designed for requests to travel\n             * ROUTER->DEALER (up) and responses DEALER-ROUTER (down).\n             * When used conventionally, the route stack is accumulated\n             * automatically as a request is routed up, and unwound\n             * automatically as a response is routed down.  When responses\n             * are routed up, ROUTER socket behavior must be subverted on\n             * the receiving end by popping two frames off of the stack and\n             * discarding.\n             */\n            (void)flux_msg_pop_route (msg, NULL);\n            (void)flux_msg_pop_route (msg, NULL);\n            if (broker_response_sendmsg (ctx, msg) < 0)\n                goto done;\n            break;\n        case FLUX_MSGTYPE_EVENT:\n            (void)broker_event_sendmsg (ctx, msg);\n            break;\n    }\ndone:\n    if (uuid)\n        free (uuid);\n    flux_msg_destroy (msg);\n}\n\n/* Handle events received by parent_cb.\n * On rank 0, publisher is wired to send events here also.\n */\nstatic int handle_event (broker_ctx_t *ctx, const flux_msg_t *msg)\n{\n    uint32_t seq;\n    const char *topic, *s;\n\n    if (flux_msg_get_seq (msg, &seq) < 0\n            || flux_msg_get_topic (msg, &topic) < 0) {\n        flux_log (ctx->h, LOG_ERR, \"dropping malformed event\");\n        return -1;\n    }\n    if (seq <= ctx->event_recv_seq) {\n        //flux_log (ctx->h, LOG_DEBUG, \"dropping duplicate event %d\", seq);\n        return -1;\n    }\n    if (ctx->event_recv_seq > 0) { /* don't log initial missed events */\n        int first = ctx->event_recv_seq + 1;\n        int count = seq - first;\n        if (count > 1)\n            flux_log (ctx->h, LOG_ERR, \"lost events %d-%d\", first, seq - 1);\n        else if (count == 1)\n            flux_log (ctx->h, LOG_ERR, \"lost event %d\", first);\n    }\n    ctx->event_recv_seq = seq;\n\n    /* Forward to this rank's children.\n     */\n    overlay_mcast_child (ctx->overlay, msg);\n\n    /* Internal services may install message handlers for events.\n     */\n    s = zlist_first (ctx->subscriptions);\n    while (s) {\n        if (!strncmp (s, topic, strlen (s))) {\n            if (flux_requeue (ctx->h, msg, FLUX_RQ_TAIL) < 0)\n                flux_log_error (ctx->h, \"%s: flux_requeue\\n\", __FUNCTION__);\n            break;\n        }\n        s = zlist_next (ctx->subscriptions);\n    }\n    /* Finally, route to local module subscribers.\n     */\n    return module_event_mcast (ctx->modhash, msg);\n}\n\n/* Handle messages from parent.\n */\nstatic void parent_cb (struct overlay *ov, void *arg)\n{\n    broker_ctx_t *ctx = arg;\n    flux_msg_t *msg = overlay_recvmsg_parent (ctx->overlay);\n    int type;\n\n    if (!msg)\n        goto done;\n    if (flux_msg_get_type (msg, &type) < 0)\n        goto done;\n    switch (type) {\n        case FLUX_MSGTYPE_RESPONSE:\n            if (broker_response_sendmsg (ctx, msg) < 0)\n                goto done;\n            break;\n        case FLUX_MSGTYPE_EVENT:\n            if (flux_msg_clear_route (msg) < 0) {\n                flux_log (ctx->h, LOG_ERR, \"dropping malformed event\");\n                goto done;\n            }\n            if (handle_event (ctx, msg) < 0)\n                goto done;\n            break;\n        case FLUX_MSGTYPE_REQUEST:\n            broker_request_sendmsg (ctx, msg);\n            break;\n        default:\n            flux_log (ctx->h, LOG_ERR, \"%s: unexpected %s\", __FUNCTION__,\n                      flux_msg_typestr (type));\n            break;\n    }\ndone:\n    flux_msg_destroy (msg);\n}\n\n/* Callback to send disconnect messages on behalf of unloading module.\n */\nvoid disconnect_send_cb (const flux_msg_t *msg, void *arg)\n{\n    broker_ctx_t *ctx = arg;\n    broker_request_sendmsg (ctx, msg);\n}\n\n/* Handle messages on the service socket of a module.\n */\nstatic void module_cb (module_t *p, void *arg)\n{\n    broker_ctx_t *ctx = arg;\n    flux_msg_t *msg = module_recvmsg (p);\n    int type;\n    int ka_errnum, ka_status;\n\n    if (!msg)\n        goto done;\n    if (flux_msg_get_type (msg, &type) < 0)\n        goto done;\n    switch (type) {\n        case FLUX_MSGTYPE_RESPONSE:\n            (void)broker_response_sendmsg (ctx, msg);\n            break;\n        case FLUX_MSGTYPE_REQUEST:\n            broker_request_sendmsg (ctx, msg);\n            if (flux_msg_get_route_count (msg) == 1\n                && module_disconnect_arm (p, msg, disconnect_send_cb, ctx) < 0) {\n                    flux_log_error (ctx->h,\n                                    \"%s: module_disconnect_arm\",\n                                    module_get_name (p));\n            }\n            break;\n        case FLUX_MSGTYPE_EVENT:\n            if (broker_event_sendmsg (ctx, msg) < 0) {\n                flux_log_error (ctx->h, \"%s(%s): broker_event_sendmsg %s\",\n                                __FUNCTION__, module_get_name (p),\n                                flux_msg_typestr (type));\n            }\n            break;\n        case FLUX_MSGTYPE_KEEPALIVE:\n            if (flux_keepalive_decode (msg, &ka_errnum, &ka_status) < 0) {\n                flux_log_error (ctx->h, \"%s: flux_keepalive_decode\",\n                                module_get_name (p));\n                break;\n            }\n            if (ka_status == FLUX_MODSTATE_FINALIZING) {\n                /* Module is finalizing and doesn't want any more messages.\n                 * mute the module and respond with the same keepalive\n                 * message for synchronization (module waits to proceed)\n                 */\n                module_mute (p);\n                if (module_sendmsg (p, msg) < 0)\n                    flux_log_error (ctx->h,\n                                    \"%s: reply to finalizing: module_sendmsg\",\n                                    module_get_name (p));\n            }\n            if (ka_status == FLUX_MODSTATE_EXITED)\n                module_set_errnum (p, ka_errnum);\n            module_set_status (p, ka_status);\n            break;\n        default:\n            flux_log (ctx->h, LOG_ERR, \"%s(%s): unexpected %s\",\n                      __FUNCTION__, module_get_name (p),\n                      flux_msg_typestr (type));\n            break;\n    }\ndone:\n    flux_msg_destroy (msg);\n}\n\nstatic int module_insmod_respond (flux_t *h, module_t *p)\n{\n    int rc;\n    int errnum = 0;\n    int status = module_get_status (p);\n    flux_msg_t *msg = module_pop_insmod (p);\n\n    if (msg == NULL)\n        return 0;\n\n    /* If the module is EXITED, return error to insmod if mod_main() < 0\n     */\n    if (status == FLUX_MODSTATE_EXITED)\n        errnum = module_get_errnum (p);\n    if (errnum == 0)\n        rc = flux_respond (h, msg, NULL);\n    else\n        rc = flux_respond_error (h, msg, errnum, NULL);\n\n    flux_msg_destroy (msg);\n    return rc;\n}\n\nstatic int module_rmmod_respond (flux_t *h, module_t *p)\n{\n    flux_msg_t *msg;\n    int rc = 0;\n    while ((msg = module_pop_rmmod (p))) {\n        if (flux_respond (h, msg, NULL) < 0)\n            rc = -1;\n        flux_msg_destroy (msg);\n    }\n    return rc;\n}\n\nstatic void module_status_cb (module_t *p, int prev_status, void *arg)\n{\n    broker_ctx_t *ctx = arg;\n    int status = module_get_status (p);\n    const char *name = module_get_name (p);\n\n    /* Transition from INIT\n     * If module started normally, i.e. INIT->RUNNING, then\n     * respond to insmod requests now. O/w, delay responses until\n     * EXITED, when any errnum is available.\n     */\n    if (prev_status == FLUX_MODSTATE_INIT\n        && status == FLUX_MODSTATE_RUNNING) {\n        if (module_insmod_respond (ctx->h, p) < 0)\n            flux_log_error (ctx->h, \"flux_respond to insmod %s\", name);\n    }\n\n    /* Transition to EXITED\n     * Remove service routes, respond to insmod & rmmod request(s), if any,\n     * and remove the module (which calls pthread_join).\n     */\n    if (status == FLUX_MODSTATE_EXITED) {\n        flux_log (ctx->h, LOG_DEBUG, \"module %s exited\", name);\n        service_remove_byuuid (ctx->services, module_get_uuid (p));\n\n        if (module_insmod_respond (ctx->h, p) < 0)\n            flux_log_error (ctx->h, \"flux_respond to insmod %s\", name);\n\n        if (module_rmmod_respond (ctx->h, p) < 0)\n            flux_log_error (ctx->h, \"flux_respond to rmmod %s\", name);\n\n        module_remove (ctx->modhash, p);\n    }\n}\n\nstatic void signal_cb (flux_reactor_t *r, flux_watcher_t *w,\n                         int revents, void *arg)\n{\n    broker_ctx_t *ctx = arg;\n    int signum = flux_signal_watcher_get_signum (w);\n\n    flux_log (ctx->h, LOG_INFO, \"signal %d\", signum);\n    state_machine_kill (ctx->state_machine, signum);\n}\n\n/* Send a request message down the TBON.\n * N.B. this message is going from ROUTER socket to DEALER socket.\n * Since ROUTER pops a route off the stack and uses it to select the peer,\n * we must push *two* routes on the stack: the identity of this broker,\n * then the identity the peer.  The parent_cb() can then accept the request\n * from DEALER as though it were received on ROUTER.\n */\nstatic int sendmsg_child_request (broker_ctx_t *ctx,\n                                  const flux_msg_t *msg,\n                                  uint32_t nodeid)\n{\n    flux_msg_t *cpy = flux_msg_copy (msg, true);\n    char uuid[16];\n    int rc = -1;\n\n    if (flux_msg_push_route (cpy, ctx->uuid) < 0)\n        goto done;\n    snprintf (uuid, sizeof (uuid), \"%\"PRIu32, nodeid);\n    if (flux_msg_push_route (cpy, uuid) < 0)\n        goto done;\n    if (overlay_sendmsg_child (ctx->overlay, cpy) < 0)\n        goto done;\n    rc = 0;\ndone:\n    flux_msg_destroy (cpy);\n    return rc;\n}\n\n/* Route request.\n * On success, return 0.  On failure, return -1 with errno set.\n */\nstatic int broker_request_sendmsg_internal (broker_ctx_t *ctx,\n                                            const flux_msg_t *msg)\n{\n    uint32_t nodeid;\n    uint8_t flags;\n\n    if (flux_msg_get_nodeid (msg, &nodeid) < 0)\n        return -1;\n    if (flux_msg_get_flags (msg, &flags) < 0)\n        return -1;\n    /* Route up TBON if destination if upstream of this broker.\n     */\n    if ((flags & FLUX_MSGFLAG_UPSTREAM) && nodeid == ctx->rank) {\n        if (overlay_sendmsg_parent (ctx->overlay, msg) < 0)\n            return -1;\n    }\n    /* Deliver to local service if destination *could* be this broker.\n     * If there is no such service locally (ENOSYS), route up TBON.\n     */\n    else if (((flags & FLUX_MSGFLAG_UPSTREAM) && nodeid != ctx->rank)\n                                              || nodeid == FLUX_NODEID_ANY) {\n        if (service_send (ctx->services, msg) < 0) {\n            if (errno != ENOSYS)\n                return -1;\n            if (overlay_sendmsg_parent (ctx->overlay, msg) < 0) {\n                if (errno == EHOSTUNREACH)\n                    errno = ENOSYS;\n                return -1;\n            }\n        }\n    }\n    /* Deliver to local service if this broker is the addressed rank.\n     */\n    else if (nodeid == ctx->rank) {\n        if (service_send (ctx->services, msg) < 0)\n            return -1;\n    }\n    /* Send the request up or down TBON as addressed.\n     */\n    else {\n        uint32_t down_rank;\n        down_rank = kary_child_route (ctx->tbon_k, ctx->size, ctx->rank, nodeid);\n        if (down_rank == KARY_NONE) { // up\n            if (overlay_sendmsg_parent (ctx->overlay, msg) < 0)\n                return -1;\n        }\n        else { // down\n            if (sendmsg_child_request (ctx, msg, down_rank) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}\n\n/* Route request.  If there is an error routing the request,\n * generate an error response.  Make an extra effort to return a useful\n * error message if ENOSYS indicates an unmatched service name.\n */\nstatic void broker_request_sendmsg (broker_ctx_t *ctx, const flux_msg_t *msg)\n{\n    if (broker_request_sendmsg_internal (ctx, msg) < 0) {\n        const char *topic;\n        char errbuf[64];\n        const char *errstr = NULL;\n\n        if (errno == ENOSYS && flux_msg_get_topic (msg, &topic) == 0) {\n            snprintf (errbuf,\n                      sizeof (errbuf),\n                      \"No service matching %s is registered\", topic);\n            errstr = errbuf;\n        }\n        if (flux_respond_error (ctx->h, msg, errno, errstr) < 0)\n            flux_log_error (ctx->h, \"flux_respond\");\n    }\n}\n\n/* Broker's use their rank in place of a UUID for message routing purposes.\n * Try to convert a UUID from a message to a rank.\n * It must be entirely numerical, and be less than 'size'.\n * If it works, assign result to 'rank' and return true.\n * If it doesn't return false.\n */\nstatic bool uuid_to_rank (const char *s, uint32_t size, uint32_t *rank)\n{\n    unsigned long num;\n    char *endptr;\n\n    if (!isdigit (*s))\n        return false;\n    errno = 0;\n    num = strtoul (s, &endptr, 10);\n    if (errno != 0)\n        return false;\n    if (*endptr != '\\0')\n        return false;\n    if (num >= size)\n        return false;\n    *rank = num;\n    return true;\n}\n\n/* Test whether the TBON parent of this broker is 'rank'.\n */\nstatic bool is_my_parent (broker_ctx_t *ctx, uint32_t rank)\n{\n    if (kary_parentof (ctx->tbon_k, ctx->rank) == rank)\n        return true;\n    return false;\n}\n\n/* Route a response message, determining next hop from route stack.\n * If there is no next hop, routing is complete to broker-resident service.\n * If the next hop is a rank, route up or down the TBON.\n * If not a rank, look up a module by uuid.\n */\nstatic int broker_response_sendmsg (broker_ctx_t *ctx, const flux_msg_t *msg)\n{\n    int rc = -1;\n    char *uuid = NULL;\n    uint32_t rank;\n\n    if (flux_msg_get_route_last (msg, &uuid) < 0)\n        goto done;\n    if (uuid == NULL) { // broker resident service\n        if (flux_requeue (ctx->h, msg, FLUX_RQ_TAIL) < 0)\n            goto done;\n    }\n    else if (uuid_to_rank (uuid, ctx->size, &rank)) {\n        if (is_my_parent (ctx, rank)) {\n            /* N.B. this message is going from DEALER socket to ROUTER socket.\n             * Instead of popping a route off the stack, ROUTER pushes one\n             * on, so the upstream broker must to detect this case and pop\n             * *two* off to maintain route stack integrity.  See child_cb().\n             */\n            if (overlay_sendmsg_parent (ctx->overlay, msg) < 0)\n                goto done;\n        }\n        else {\n            if (overlay_sendmsg_child (ctx->overlay, msg) < 0) {\n                if (errno == EINVAL)\n                    errno = EHOSTUNREACH;\n                goto done;\n            }\n        }\n    }\n    else {\n        if (module_response_sendmsg (ctx->modhash, msg) < 0)\n            goto done;\n    }\n    rc = 0;\ndone:\n    ERRNO_SAFE_WRAP (free, uuid);\n    return rc;\n}\n\n/* Events are forwarded up the TBON to rank 0, then published from there.\n * (This mechanism predates and is separate from the \"event.pub\" service).\n */\nstatic int broker_event_sendmsg (broker_ctx_t *ctx, const flux_msg_t *msg)\n{\n\n    if (ctx->rank > 0) {\n        flux_msg_t *cpy;\n        if (!(cpy = flux_msg_copy (msg, true)))\n            return -1;\n        if (flux_msg_enable_route (cpy) < 0) {\n            flux_msg_destroy (cpy);\n            return -1;\n        }\n        if (overlay_sendmsg_parent (ctx->overlay, cpy) < 0) {\n            flux_msg_destroy (cpy);\n            return -1;\n        }\n        flux_msg_destroy (cpy);\n    } else {\n        if (publisher_send (ctx->publisher, msg) < 0)\n            return -1;\n    }\n    return 0;\n}\n\n/**\n ** Broker's internal flux_t implementation\n ** N.B. recv() method is missing because messages are \"received\"\n ** when routing logic calls flux_requeue().\n **/\n\nstatic int broker_send (void *impl, const flux_msg_t *msg, int flags)\n{\n    broker_ctx_t *ctx = impl;\n    int type;\n    struct flux_msg_cred cred;\n    flux_msg_t *cpy = NULL;\n    int rc = -1;\n\n    if (!(cpy = flux_msg_copy (msg, true)))\n        goto done;\n    if (flux_msg_get_type (cpy, &type) < 0)\n        goto done;\n    if (flux_msg_get_cred (cpy, &cred) < 0)\n        goto done;\n    if (cred.userid == FLUX_USERID_UNKNOWN)\n        cred.userid = ctx->cred.userid;\n    if (cred.rolemask == FLUX_ROLE_NONE)\n        cred.rolemask = ctx->cred.rolemask;\n    if (flux_msg_set_cred (cpy, cred) < 0)\n        goto done;\n\n    switch (type) {\n        case FLUX_MSGTYPE_REQUEST:\n            rc = broker_request_sendmsg_internal (ctx, cpy);\n            break;\n        case FLUX_MSGTYPE_RESPONSE:\n            rc = broker_response_sendmsg (ctx, cpy);\n            break;\n        case FLUX_MSGTYPE_EVENT:\n            rc = broker_event_sendmsg (ctx, cpy);\n            break;\n        default:\n            errno = EINVAL;\n            break;\n    }\ndone:\n    flux_msg_destroy (cpy);\n    return rc;\n}\n\nstatic int broker_subscribe (void *impl, const char *topic)\n{\n    broker_ctx_t *ctx = impl;\n    char *cpy = NULL;\n\n    if (!(cpy = strdup (topic)))\n        goto nomem;\n    if (zlist_append (ctx->subscriptions, cpy) < 0)\n        goto nomem;\n    zlist_freefn (ctx->subscriptions, cpy, free, true);\n    return 0;\nnomem:\n    free (cpy);\n    errno = ENOMEM;\n    return -1;\n}\n\nstatic int broker_unsubscribe (void *impl, const char *topic)\n{\n    broker_ctx_t *ctx = impl;\n    char *s = zlist_first (ctx->subscriptions);\n    while (s) {\n        if (!strcmp (s, topic)) {\n            zlist_remove (ctx->subscriptions, s);\n            break;\n        }\n        s = zlist_next (ctx->subscriptions);\n    }\n    return 0;\n}\n\nstatic const struct flux_handle_ops broker_handle_ops = {\n    .send = broker_send,\n    .event_subscribe = broker_subscribe,\n    .event_unsubscribe = broker_unsubscribe,\n};\n\n\n#if HAVE_VALGRIND\n/* Disable dlclose() during valgrind operation\n */\nvoid I_WRAP_SONAME_FNNAME_ZZ(Za,dlclose)(void *dso) {}\n#endif\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-dhf3djcroafxxgzw73ri4gkvkvqs6ets/spack-src/src/broker/pmiutil.c": "/************************************************************\\\n * Copyright 2019 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <sys/param.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#include <assert.h>\n#include <czmq.h>\n\n#include \"src/common/libutil/log.h\"\n#include \"src/common/libutil/iterators.h\"\n#include \"src/common/libpmi/pmi.h\"\n#include \"src/common/libpmi/pmi_strerror.h\"\n#include \"src/common/libpmi/simple_client.h\"\n\n#include \"pmiutil.h\"\n#include \"liblist.h\"\n\ntypedef enum {\n    PMI_MODE_SINGLETON,\n    PMI_MODE_DLOPEN,\n    PMI_MODE_WIRE1,\n} pmi_mode_t;\n\nstruct pmi_dso {\n    void *dso;\n    int (*init) (int *spawned);\n    int (*finalize) (void);\n    int (*get_size) (int *size);\n    int (*get_rank) (int *rank);\n    int (*barrier) (void);\n    int (*kvs_get_my_name) (char *kvsname, int length);\n    int (*kvs_put) (const char *kvsname, const char *key, const char *value);\n    int (*kvs_commit) (const char *kvsname);\n    int (*kvs_get) (const char *kvsname, const char *key, char *value, int len);\n};\n\nstruct pmi_handle {\n    struct pmi_dso *dso;\n    struct pmi_simple_client *cli;\n    int debug;\n    pmi_mode_t mode;\n    int rank;\n};\n\nstatic void vdebugf (struct pmi_handle *pmi, const char *fmt, va_list ap)\n{\n\n    if (pmi->debug) {\n        char buf[1024];\n        (void)vsnprintf (buf, sizeof (buf), fmt, ap);\n        fprintf (stderr, \"pmi-debug-%s[%d]: %s\\n\",\n                pmi->mode == PMI_MODE_SINGLETON ? \"singleton\" :\n                pmi->mode == PMI_MODE_WIRE1 ? \"wire.1\" :\n                pmi->mode == PMI_MODE_DLOPEN ? \"dlopen\" : \"unknown\",\n                pmi->rank,\n                buf);\n    }\n}\n\nstatic void debugf (struct pmi_handle *pmi, const char *fmt, ...)\n{\n    va_list ap;\n    va_start (ap, fmt);\n    vdebugf (pmi, fmt, ap);\n    va_end (ap);\n}\n\nstatic void broker_pmi_dlclose (struct pmi_dso *dso)\n{\n    if (dso) {\n#ifndef __SANITIZE_ADDRESS__\n        if (dso->dso)\n            dlclose (dso->dso);\n#endif\n        free (dso);\n    }\n}\n\n/* Notes:\n * - Use RTLD_GLOBAL due to issue #432\n */\nstatic struct pmi_dso *broker_pmi_dlopen (const char *pmi_library, int debug)\n{\n    struct pmi_dso *dso;\n    zlist_t *libs = NULL;\n    char *name;\n\n    if (!(dso = calloc (1, sizeof (*dso))))\n        return NULL;\n    if (!pmi_library)\n        pmi_library = \"libpmi.so\";\n    if (!(libs = liblist_create (pmi_library)))\n        goto error;\n    FOREACH_ZLIST (libs, name) {\n        dlerror ();\n        if (!(dso->dso = dlopen (name, RTLD_NOW | RTLD_GLOBAL))) {\n            if (debug) {\n                char *errstr = dlerror ();\n                if (errstr)\n                    log_msg (\"pmi-debug-dlopen: %s\", errstr);\n                else\n                    log_msg (\"pmi-debug-dlopen: dlopen %s failed\", name);\n            }\n        }\n        else if (dlsym (dso->dso, \"flux_pmi_library\")) {\n            if (debug)\n                log_msg (\"pmi-debug-dlopen: skipping %s\", name);\n            dlclose (dso->dso);\n            dso->dso = NULL;\n        }\n        else {\n            if (debug)\n                log_msg (\"pmi-debug-dlopen: library name %s\", name);\n        }\n    }\n    liblist_destroy (libs);\n    libs = NULL;\n    if (!dso->dso)\n        goto error;\n    dso->init = dlsym (dso->dso, \"PMI_Init\");\n    dso->finalize = dlsym (dso->dso, \"PMI_Finalize\");\n    dso->get_size = dlsym (dso->dso, \"PMI_Get_size\");\n    dso->get_rank = dlsym (dso->dso, \"PMI_Get_rank\");\n    dso->barrier = dlsym (dso->dso, \"PMI_Barrier\");\n    dso->kvs_get_my_name = dlsym (dso->dso, \"PMI_KVS_Get_my_name\");\n    dso->kvs_put = dlsym (dso->dso, \"PMI_KVS_Put\");\n    dso->kvs_commit = dlsym (dso->dso, \"PMI_KVS_Commit\");\n    dso->kvs_get = dlsym (dso->dso, \"PMI_KVS_Get\");\n\n    if (!dso->init || !dso->finalize || !dso->get_size || !dso->get_rank\n            || !dso->barrier || !dso->kvs_get_my_name\n            || !dso->kvs_put || !dso->kvs_commit || !dso->kvs_get) {\n        log_msg (\"pmi-debug-dlopen: dlsym: %s is missing required symbols\",\n                 pmi_library);\n        goto error;\n    }\n    return dso;\nerror:\n    broker_pmi_dlclose (dso);\n    if (libs)\n        liblist_destroy (libs);\n    return NULL;\n}\n\nint broker_pmi_kvs_commit (struct pmi_handle *pmi, const char *kvsname)\n{\n    int ret = PMI_SUCCESS;\n\n    switch (pmi->mode) {\n        case PMI_MODE_SINGLETON:\n            break;\n        case PMI_MODE_WIRE1:\n            break;\n        case PMI_MODE_DLOPEN:\n            ret = pmi->dso->kvs_commit (kvsname);\n            break;\n    }\n    debugf (pmi,\n            \"kvs_commit (kvsname=%s) = %s\",\n            kvsname,\n            pmi_strerror (ret));\n    return ret;\n}\n\nint broker_pmi_kvs_put (struct pmi_handle *pmi,\n                        const char *kvsname,\n                        const char *key,\n                        const char *value)\n{\n    int ret = PMI_SUCCESS;\n\n    switch (pmi->mode) {\n        case PMI_MODE_SINGLETON:\n            break;\n        case PMI_MODE_WIRE1:\n            ret = pmi_simple_client_kvs_put (pmi->cli, kvsname, key, value);\n            break;\n        case PMI_MODE_DLOPEN:\n            ret = pmi->dso->kvs_put (kvsname, key, value);\n            break;\n    }\n    debugf (pmi,\n            \"kvs_put (kvsname=%s key=%s value=%s) = %s\",\n            kvsname,\n            key,\n            value,\n            pmi_strerror (ret));\n    return ret;\n}\n\nint broker_pmi_kvs_get (struct pmi_handle *pmi,\n                               const char *kvsname,\n                               const char *key,\n                               char *value,\n                               int len)\n{\n    int ret = PMI_FAIL;\n\n    switch (pmi->mode) {\n        case PMI_MODE_SINGLETON:\n            break;\n        case PMI_MODE_WIRE1:\n            ret = pmi_simple_client_kvs_get (pmi->cli, kvsname, key, value, len);\n            break;\n        case PMI_MODE_DLOPEN:\n            ret = pmi->dso->kvs_get (kvsname, key, value, len);\n            break;\n    }\n    debugf (pmi,\n            \"kvs_get (kvsname=%s key=%s value=%s) = %s\",\n            kvsname,\n            key,\n            ret == PMI_SUCCESS ? value : \"<none>\",\n            pmi_strerror (ret));\n    return ret;\n}\n\nint broker_pmi_barrier (struct pmi_handle *pmi)\n{\n    int ret = PMI_SUCCESS;\n\n    switch (pmi->mode) {\n        case PMI_MODE_SINGLETON:\n            break;\n        case PMI_MODE_WIRE1:\n            ret = pmi_simple_client_barrier (pmi->cli);\n            break;\n        case PMI_MODE_DLOPEN:\n            ret = pmi->dso->barrier();\n            break;\n    }\n    debugf (pmi, \"barrier = %s\", pmi_strerror (ret));\n    return ret;\n}\n\nint broker_pmi_get_params (struct pmi_handle *pmi,\n                           struct pmi_params *params)\n{\n    int ret = PMI_SUCCESS;\n\n    switch (pmi->mode) {\n        case PMI_MODE_SINGLETON:\n            params->rank = 0;\n            params->size = 1;\n            snprintf (params->kvsname, sizeof (params->kvsname), \"singleton\");\n            break;\n        case PMI_MODE_WIRE1:\n            params->rank = pmi->cli->rank;\n            params->size = pmi->cli->size;\n            ret = pmi_simple_client_kvs_get_my_name (pmi->cli,\n                                                     params->kvsname,\n                                                     sizeof (params->kvsname));\n            break;\n        case PMI_MODE_DLOPEN:\n            if ((ret = pmi->dso->get_rank (&params->rank)) != PMI_SUCCESS)\n                break;\n            if ((ret = pmi->dso->get_size (&params->size)) != PMI_SUCCESS)\n                break;\n            ret = pmi->dso->kvs_get_my_name (params->kvsname,\n                                             sizeof (params->kvsname));\n            break;\n    }\n    if (ret == PMI_SUCCESS)\n        pmi->rank = params->rank;\n    debugf (pmi,\n            \"get_params (rank=%d size=%d kvsname=%s) = %s\",\n            ret == PMI_SUCCESS ? params->rank : -1,\n            ret == PMI_SUCCESS ? params->size : -1,\n            ret == PMI_SUCCESS ? params->kvsname: \"<none>\",\n            pmi_strerror (ret));\n    return ret;\n}\n\nint broker_pmi_init (struct pmi_handle *pmi)\n{\n    int spawned;\n    int ret = PMI_SUCCESS;\n\n    switch (pmi->mode) {\n        case PMI_MODE_SINGLETON:\n            break;\n        case PMI_MODE_WIRE1:\n            ret = pmi_simple_client_init (pmi->cli);\n            break;\n        case PMI_MODE_DLOPEN:\n            ret = pmi->dso->init(&spawned);\n            break;\n    }\n    debugf (pmi, \"init = %s\", pmi_strerror (ret));\n    return ret;\n}\n\nint broker_pmi_finalize (struct pmi_handle *pmi)\n{\n    int ret = PMI_SUCCESS;\n\n    switch (pmi->mode) {\n        case PMI_MODE_SINGLETON:\n            break;\n        case PMI_MODE_WIRE1:\n            ret = pmi_simple_client_finalize (pmi->cli);\n            break;\n        case PMI_MODE_DLOPEN:\n            ret = pmi->dso->finalize ();\n            break;\n    }\n    debugf (pmi, \"finalize = %s\", pmi_strerror (ret));\n    return PMI_SUCCESS;\n}\n\nvoid broker_pmi_destroy (struct pmi_handle *pmi)\n{\n    if (pmi) {\n        int saved_errno = errno;\n        switch (pmi->mode) {\n            case PMI_MODE_SINGLETON:\n                break;\n            case PMI_MODE_WIRE1:\n                pmi_simple_client_destroy (pmi->cli);\n                break;\n            case PMI_MODE_DLOPEN:\n                broker_pmi_dlclose (pmi->dso);\n                break;\n        }\n        free (pmi);\n        errno = saved_errno;\n    }\n}\n\n/* Attempt to set up PMI-1 wire protocol client.\n * If that fails, try dlopen.\n * If that fails, singleton will be used.\n */\nstruct pmi_handle *broker_pmi_create (void)\n{\n    const char *pmi_debug;\n    struct pmi_handle *pmi = calloc (1, sizeof (*pmi));\n    if (!pmi)\n        return NULL;\n    pmi->rank = -1;\n    pmi_debug = getenv (\"FLUX_PMI_DEBUG\");\n    if (pmi_debug)\n        pmi->debug = strtol (pmi_debug, NULL, 10);\n    if ((pmi->cli = pmi_simple_client_create_fd (getenv (\"PMI_FD\"),\n                                                 getenv (\"PMI_RANK\"),\n                                                 getenv (\"PMI_SIZE\"),\n                                                 NULL))) {\n        pmi->mode = PMI_MODE_WIRE1;\n    }\n    /* N.B. SLURM boldly installs its libpmi.so into the system libdir,\n     * so it will be found here, even if not running in a SLURM job.\n     * Fortunately it emulates singleton in that case, in lieu of failing.\n     */\n    else if ((pmi->dso = broker_pmi_dlopen (getenv (\"PMI_LIBRARY\"),\n                                            pmi->debug))) {\n        pmi->mode = PMI_MODE_DLOPEN;\n    }\n    /* If neither pmi->cli nor pmi->dso is set, singleton is assumed.\n     */\n    else {\n        pmi->mode = PMI_MODE_SINGLETON;\n    }\n    return pmi;\n}\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-dhf3djcroafxxgzw73ri4gkvkvqs6ets/spack-src/src/broker/module.c": "/************************************************************\\\n * Copyright 2014 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <stdbool.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <stdarg.h>\n#include <dlfcn.h>\n#include <inttypes.h>\n#include <argz.h>\n#include <czmq.h>\n#include <uuid.h>\n#include <flux/core.h>\n#include <jansson.h>\n#if HAVE_CALIPER\n#include <caliper/cali.h>\n#include <sys/syscall.h>\n#endif\n\n#include \"src/common/libutil/log.h\"\n#include \"src/common/libutil/iterators.h\"\n\n#include \"module.h\"\n#include \"modservice.h\"\n\n#ifndef UUID_STR_LEN\n#define UUID_STR_LEN 37     // defined in later libuuid headers\n#endif\n\n\n#define MODULE_MAGIC    0xfeefbe01\nstruct broker_module {\n    int magic;\n\n    uint32_t rank;\n    flux_t *broker_h;\n    flux_watcher_t *broker_w;\n\n    double lastseen;\n\n    zsock_t *sock;          /* broker end of PAIR socket */\n    struct flux_msg_cred cred; /* cred of connection */\n\n    uuid_t uuid;            /* uuid for unique request sender identity */\n    char uuid_str[UUID_STR_LEN];\n    pthread_t t;            /* module thread */\n    mod_main_f *main;       /* dlopened mod_main() */\n    char *name;\n    void *dso;              /* reference on dlopened module */\n    int size;               /* size of .so file for lsmod */\n    char *digest;           /* digest of .so file for lsmod */\n    size_t argz_len;\n    char *argz;\n    int status;\n    int errnum;\n    bool muted;             /* module is under directive 42, no new messages */\n\n    modpoller_cb_f poller_cb;\n    void *poller_arg;\n    module_status_cb_f status_cb;\n    void *status_arg;\n\n    struct disconnect *disconnect;\n\n    zlist_t *rmmod;\n    flux_msg_t *insmod;\n\n    flux_t *h;               /* module's handle */\n\n    zlist_t *subs;          /* subscription strings */\n};\n\nstruct modhash {\n    zhash_t *zh_byuuid;\n    uint32_t rank;\n    flux_t *broker_h;\n};\n\nstatic int setup_module_profiling (module_t *p)\n{\n#if HAVE_CALIPER\n    cali_begin_string_byname (\"flux.type\", \"module\");\n    cali_begin_int_byname (\"flux.tid\", syscall (SYS_gettid));\n    cali_begin_int_byname (\"flux.rank\", p->rank);\n    cali_begin_string_byname (\"flux.name\", p->name);\n#endif\n    return (0);\n}\n\n/*  Synchronize the FINALIZING state with the broker, so the broker\n *   can stop messages to this module until we're fully shutdown.\n */\nstatic int module_finalizing (module_t *p)\n{\n    int rc = -1;\n    flux_msg_t *msg = NULL;\n    struct flux_match match = {\n        .typemask = FLUX_MSGTYPE_KEEPALIVE\n    };\n    /* Notify the broker we're finalizing, which will disable new\n     *  messages\n     */\n    if (!(msg = flux_keepalive_encode (0, FLUX_MODSTATE_FINALIZING))) {\n        flux_log_error (p->h, \"module_finalizing: flux_keepalive_encode\");\n        return -1;\n    }\n    if (flux_send (p->h, msg, 0) < 0) {\n        flux_log_error (p->h, \"module_finalizing: flux_send\");\n        goto done;\n    }\n    flux_msg_destroy (msg);\n\n    /* Synchronize with the broker using a blocking recv for keepalive\n     *  message. This should be the only time the broker sends a keepalive\n     *  to a module.\n     */\n    if (!(msg = flux_recv (p->h, match, 0)))\n        flux_log_error (p->h, \"module_finalizing: flux_recv\");\n    rc = 0;\ndone:\n    flux_msg_destroy (msg);\n    return rc;\n}\n\nstatic void *module_thread (void *arg)\n{\n    module_t *p = arg;\n    assert (p->magic == MODULE_MAGIC);\n    sigset_t signal_set;\n    int errnum;\n    char *uri = NULL;\n    char **av = NULL;\n    char *rankstr = NULL;\n    int ac;\n    int mod_main_errno = 0;\n    flux_msg_t *msg;\n    flux_conf_t *conf;\n\n    setup_module_profiling (p);\n\n    /* Connect to broker socket, enable logging, register built-in services\n     */\n    if (asprintf (&uri, \"shmem://%s\", p->uuid_str) < 0) {\n        log_err (\"asprintf\");\n        goto done;\n    }\n    if (!(p->h = flux_open (uri, 0))) {\n        log_err (\"flux_open %s\", uri);\n        goto done;\n    }\n    if (asprintf (&rankstr, \"%\"PRIu32, p->rank) < 0) {\n        log_err (\"asprintf\");\n        goto done;\n    }\n    if (flux_attr_set_cacheonly (p->h, \"rank\", rankstr) < 0) {\n        log_err (\"%s: error faking rank attribute\", p->name);\n        goto done;\n    }\n    flux_log_set_appname (p->h, p->name);\n    /* Copy the broker's config object so that modules\n     * can call flux_get_conf() and expect it to always succeed.\n     */\n    if (!(conf = flux_conf_copy (flux_get_conf (p->broker_h)))\n            || flux_set_conf (p->h, conf) < 0) {\n        flux_conf_decref (conf);\n        log_err (\"%s: error duplicating config object\", p->name);\n        goto done;\n    }\n    if (modservice_register (p->h, p) < 0) {\n        log_err (\"%s: modservice_register\", p->name);\n        goto done;\n    }\n\n    /* Block all signals\n     */\n    if (sigfillset (&signal_set) < 0) {\n        log_err (\"%s: sigfillset\", p->name);\n        goto done;\n    }\n    if ((errnum = pthread_sigmask (SIG_BLOCK, &signal_set, NULL)) != 0) {\n        log_errn (errnum, \"pthread_sigmask\");\n        goto done;\n    }\n\n    /* Run the module's main().\n     */\n    ac = argz_count (p->argz, p->argz_len);\n    if (!(av = calloc (1, sizeof (av[0]) * (ac + 1)))) {\n        log_errn (ENOMEM, \"calloc\");\n        goto done;\n    }\n    argz_extract (p->argz, p->argz_len, av);\n    if (p->main (p->h, ac, av) < 0) {\n        mod_main_errno = errno;\n        if (mod_main_errno == 0)\n            mod_main_errno = ECONNRESET;\n        flux_log (p->h, LOG_CRIT, \"fatal error: %s\", strerror (errno));\n    }\n\n    /* Before processing unhandled requests, ensure that this module\n     * is \"muted\" in the broker. This ensures the broker won't try to\n     * feed a message to this module after we've closed the handle,\n     * which could cause the broker to block.\n     */\n    if (module_finalizing (p) < 0)\n        flux_log_error (p->h, \"failed to set module state to finalizing\");\n\n    /* If any unhandled requests were received during shutdown,\n     * respond to them now with ENOSYS.\n     */\n    while ((msg = flux_recv (p->h, FLUX_MATCH_REQUEST, FLUX_O_NONBLOCK))) {\n        const char *topic = \"unknown\";\n        (void)flux_msg_get_topic (msg, &topic);\n        flux_log (p->h, LOG_DEBUG, \"responding to post-shutdown %s\", topic);\n        if (flux_respond_error (p->h, msg, ENOSYS, NULL) < 0)\n            flux_log_error (p->h, \"responding to post-shutdown %s\", topic);\n        flux_msg_destroy (msg);\n    }\n    if (!(msg = flux_keepalive_encode (mod_main_errno, FLUX_MODSTATE_EXITED))) {\n        flux_log_error (p->h, \"flux_keepalive_encode\");\n        goto done;\n    }\n    if (flux_send (p->h, msg, 0) < 0)\n        flux_log_error (p->h, \"flux_send\");\n    flux_msg_destroy (msg);\ndone:\n    free (uri);\n    free (rankstr);\n    if (av)\n        free (av);\n    flux_close (p->h);\n    p->h = NULL;\n    return NULL;\n}\n\nconst char *module_get_name (module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    return p->name;\n}\n\nconst char *module_get_uuid (module_t *p)\n{\n    return p->uuid_str;\n}\n\nstatic int module_get_idle (module_t *p)\n{\n    return flux_reactor_now (flux_get_reactor (p->broker_h)) - p->lastseen;\n}\n\nflux_msg_t *module_recvmsg (module_t *p)\n{\n    flux_msg_t *msg = NULL;\n    int type;\n    struct flux_msg_cred cred;\n\n    assert (p->magic == MODULE_MAGIC);\n\n    if (!(msg = flux_msg_recvzsock (p->sock)))\n        goto error;\n    if (flux_msg_get_type (msg, &type) < 0)\n        goto error;\n    switch (type) {\n        case FLUX_MSGTYPE_RESPONSE:\n            if (flux_msg_pop_route (msg, NULL) < 0)\n                goto error;\n            break;\n        case FLUX_MSGTYPE_REQUEST:\n        case FLUX_MSGTYPE_EVENT:\n            if (flux_msg_push_route (msg, p->uuid_str) < 0)\n                goto error;\n            break;\n        default:\n            break;\n    }\n    /* All shmem:// connections to the broker have FLUX_ROLE_OWNER\n     * and are \"authenticated\" as the instance owner.\n     * Allow modules so endowed to change the userid/rolemask on messages when\n     * sending on behalf of other users.  This is necessary for connectors\n     * implemented as DSOs.\n     */\n    assert ((p->cred.rolemask & FLUX_ROLE_OWNER));\n    if (flux_msg_get_cred (msg, &cred) < 0)\n        goto error;\n    if (cred.userid == FLUX_USERID_UNKNOWN)\n        cred.userid = p->cred.userid;\n    if (cred.rolemask == FLUX_ROLE_NONE)\n        cred.rolemask = p->cred.rolemask;\n    if (flux_msg_set_cred (msg, cred) < 0)\n        goto error;\n    return msg;\nerror:\n    flux_msg_destroy (msg);\n    return NULL;\n}\n\nint module_sendmsg (module_t *p, const flux_msg_t *msg)\n{\n    flux_msg_t *cpy = NULL;\n    int type;\n    int rc = -1;\n\n    if (!msg)\n        return 0;\n    if (flux_msg_get_type (msg, &type) < 0)\n        goto done;\n    if (p->muted && type != FLUX_MSGTYPE_KEEPALIVE) {\n        /* Muted modules only accept keepalive messages */\n        const char *topic;\n        (void) flux_msg_get_topic (msg, &topic);\n        errno = ENOSYS;\n        goto done;\n    }\n    switch (type) {\n        case FLUX_MSGTYPE_REQUEST: { /* simulate DEALER socket */\n            char uuid[16];\n            snprintf (uuid, sizeof (uuid), \"%\"PRIu32, p->rank);\n            if (!(cpy = flux_msg_copy (msg, true)))\n                goto done;\n            if (flux_msg_push_route (cpy, uuid) < 0)\n                goto done;\n            if (flux_msg_sendzsock (p->sock, cpy) < 0)\n                goto done;\n            break;\n        }\n        case FLUX_MSGTYPE_RESPONSE: { /* simulate ROUTER socket */\n            if (!(cpy = flux_msg_copy (msg, true)))\n                goto done;\n            if (flux_msg_pop_route (cpy, NULL) < 0)\n                goto done;\n            if (flux_msg_sendzsock (p->sock, cpy) < 0)\n                goto done;\n            break;\n        }\n        default:\n            if (flux_msg_sendzsock (p->sock, msg) < 0)\n                goto done;\n            break;\n    }\n    rc = 0;\ndone:\n    flux_msg_destroy (cpy);\n    return rc;\n}\n\nint module_response_sendmsg (modhash_t *mh, const flux_msg_t *msg)\n{\n    char *uuid = NULL;\n    int rc = -1;\n    module_t *p;\n\n    if (!msg)\n        return 0;\n    if (flux_msg_get_route_last (msg, &uuid) < 0)\n        goto done;\n    if (!uuid) {\n        errno = EPROTO;\n        goto done;\n    }\n    if (!(p = zhash_lookup (mh->zh_byuuid, uuid))) {\n        errno = ENOSYS;\n        goto done;\n    }\n    rc = module_sendmsg (p, msg);\ndone:\n    if (uuid)\n        free (uuid);\n    return rc;\n}\n\nint module_disconnect_arm (module_t *p,\n                           const flux_msg_t *msg,\n                           disconnect_send_f cb,\n                           void *arg)\n{\n    if (!p->disconnect) {\n        if (!(p->disconnect = disconnect_create (cb, arg)))\n            return -1;\n    }\n    if (disconnect_arm (p->disconnect, msg) < 0)\n        return -1;\n    return 0;\n}\n\nstatic void module_destroy (module_t *p)\n{\n    int e;\n    void *res;\n\n    if (!p)\n        return;\n\n    assert (p->magic == MODULE_MAGIC);\n\n    if (p->t) {\n        if ((e = pthread_join (p->t, &res)) != 0)\n            log_errn_exit (e, \"pthread_cancel\");\n    }\n\n    /* Send disconnect messages to services used by this module.\n     */\n    disconnect_destroy (p->disconnect);\n\n    flux_watcher_stop (p->broker_w);\n    flux_watcher_destroy (p->broker_w);\n    zsock_destroy (&p->sock);\n\n#ifndef __SANITIZE_ADDRESS__\n    dlclose (p->dso);\n#endif\n    free (p->digest);\n    free (p->argz);\n    free (p->name);\n    if (p->rmmod) {\n        flux_msg_t *msg;\n        while ((msg = zlist_pop (p->rmmod)))\n            flux_msg_destroy (msg);\n    }\n    flux_msg_destroy (p->insmod);\n    if (p->subs) {\n        char *s;\n        while ((s = zlist_pop (p->subs)))\n            free (s);\n        zlist_destroy (&p->subs);\n    }\n    zlist_destroy (&p->rmmod);\n    p->magic = ~MODULE_MAGIC;\n    free (p);\n}\n\n/* Send shutdown request, broker to module.\n */\nint module_stop (module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    char *topic = NULL;\n    flux_future_t *f = NULL;\n    int rc = -1;\n\n    if (asprintf (&topic, \"%s.shutdown\", p->name) < 0)\n        goto done;\n    if (!(f = flux_rpc (p->broker_h, topic, NULL,\n                          FLUX_NODEID_ANY, FLUX_RPC_NORESPONSE)))\n        goto done;\n    rc = 0;\ndone:\n    free (topic);\n    flux_future_destroy (f);\n    return rc;\n}\n\nvoid module_mute (module_t *p)\n{\n    p->muted = true;\n}\n\nstatic void module_cb (flux_reactor_t *r, flux_watcher_t *w,\n                       int revents, void *arg)\n{\n    module_t *p = arg;\n    assert (p->magic == MODULE_MAGIC);\n    p->lastseen = flux_reactor_now (r);\n    if (p->poller_cb)\n        p->poller_cb (p, p->poller_arg);\n}\n\nint module_start (module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    int errnum;\n    int rc = -1;\n\n    flux_watcher_start (p->broker_w);\n    if ((errnum = pthread_create (&p->t, NULL, module_thread, p))) {\n        errno = errnum;\n        goto done;\n    }\n    rc = 0;\ndone:\n    return rc;\n}\n\nvoid module_set_args (module_t *p, int argc, char * const argv[])\n{\n    int e;\n\n    assert (p->magic == MODULE_MAGIC);\n    if (p->argz) {\n        free (p->argz);\n        p->argz_len = 0;\n    }\n    if (argv && (e = argz_create (argv, &p->argz, &p->argz_len)) != 0)\n        log_errn_exit (e, \"argz_create\");\n}\n\nvoid module_add_arg (module_t *p, const char *arg)\n{\n    int e;\n\n    assert (p->magic == MODULE_MAGIC);\n    if ((e = argz_add (&p->argz, &p->argz_len, arg)) != 0)\n        log_errn_exit (e, \"argz_add\");\n}\n\nvoid module_set_poller_cb (module_t *p, modpoller_cb_f cb, void *arg)\n{\n    assert (p->magic == MODULE_MAGIC);\n    p->poller_cb = cb;\n    p->poller_arg = arg;\n}\n\nvoid module_set_status_cb (module_t *p, module_status_cb_f cb, void *arg)\n{\n    assert (p->magic == MODULE_MAGIC);\n    p->status_cb = cb;\n    p->status_arg = arg;\n}\n\nvoid module_set_status (module_t *p, int new_status)\n{\n    assert (p->magic == MODULE_MAGIC);\n    assert (new_status != FLUX_MODSTATE_INIT);  /* illegal state transition */\n    assert (p->status != FLUX_MODSTATE_EXITED); /* illegal state transition */\n    int prev_status = p->status;\n    p->status = new_status;\n    if (p->status_cb)\n        p->status_cb (p, prev_status, p->status_arg);\n}\n\nint module_get_status (module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    return p->status;\n}\n\nvoid module_set_errnum (module_t *p, int errnum)\n{\n    assert (p->magic == MODULE_MAGIC);\n    p->errnum = errnum;\n}\n\nint module_get_errnum (module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    return p->errnum;\n}\n\nint module_push_rmmod (module_t *p, const flux_msg_t *msg)\n{\n    flux_msg_t *cpy = flux_msg_copy (msg, false);\n    if (!cpy)\n        return -1;\n    if (zlist_push (p->rmmod, cpy) < 0) {\n        errno = ENOMEM;\n        return -1;\n    }\n    return 0;\n}\n\nflux_msg_t *module_pop_rmmod (module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    return zlist_pop (p->rmmod);\n}\n\n/* There can be only one.\n */\nint module_push_insmod (module_t *p, const flux_msg_t *msg)\n{\n    flux_msg_t *cpy = flux_msg_copy (msg, false);\n    if (!cpy)\n        return -1;\n    if (p->insmod)\n        flux_msg_destroy (p->insmod);\n    p->insmod = cpy;\n    return 0;\n}\n\nflux_msg_t *module_pop_insmod (module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    flux_msg_t *msg = p->insmod;\n    p->insmod = NULL;\n    return msg;\n}\n\nmodule_t *module_add (modhash_t *mh, const char *path)\n{\n    module_t *p;\n    void *dso;\n    const char **mod_namep;\n    mod_main_f *mod_main;\n    zfile_t *zf;\n    int rc;\n\n    dlerror ();\n    if (!(dso = dlopen (path, RTLD_NOW | RTLD_GLOBAL | FLUX_DEEPBIND))) {\n        log_msg (\"%s\", dlerror ());\n        errno = ENOENT;\n        return NULL;\n    }\n    mod_main = dlsym (dso, \"mod_main\");\n    mod_namep = dlsym (dso, \"mod_name\");\n    if (!mod_main || !mod_namep || !*mod_namep) {\n        dlclose (dso);\n        errno = ENOENT;\n        return NULL;\n    }\n    if (!(p = calloc (1, sizeof (*p)))) {\n        dlclose (dso);\n        errno = ENOMEM;\n        return NULL;\n    }\n    p->magic = MODULE_MAGIC;\n    p->main = mod_main;\n    p->dso = dso;\n    if (!(p->name = strdup (*mod_namep))) {\n        errno = ENOMEM;\n        goto cleanup;\n    }\n    zf = zfile_new (NULL, path);\n    if (!(p->digest = strdup (zfile_digest (zf)))) {\n        errno = ENOMEM;\n        goto cleanup;\n    }\n    p->size = (int)zfile_cursize (zf);\n    zfile_destroy (&zf);\n    uuid_generate (p->uuid);\n    uuid_unparse (p->uuid, p->uuid_str);\n    if (!(p->rmmod = zlist_new ())) {\n        errno = ENOMEM;\n        goto cleanup;\n    }\n    if (!(p->subs = zlist_new ())) {\n        errno = ENOMEM;\n        goto cleanup;\n    }\n\n    p->rank = mh->rank;\n    p->broker_h = mh->broker_h;\n\n    /* Broker end of PAIR socket is opened here.\n     */\n    if (!(p->sock = zsock_new_pair (NULL))) {\n        log_err (\"zsock_new_pair\");\n        goto cleanup;\n    }\n    if (zsock_bind (p->sock, \"inproc://%s\", module_get_uuid (p)) < 0) {\n        log_err (\"zsock_bind inproc://%s\", module_get_uuid (p));\n        goto cleanup;\n    }\n    if (!(p->broker_w = flux_zmq_watcher_create (flux_get_reactor (p->broker_h),\n                                                 p->sock, FLUX_POLLIN,\n                                                 module_cb, p))) {\n        log_err (\"flux_zmq_watcher_create\");\n        goto cleanup;\n    }\n    /* Set creds for connection.\n     * Since this is a point to point connection between broker threads,\n     * credentials are always those of the instance owner.\n     */\n    p->cred.userid = getuid ();\n    p->cred.rolemask = FLUX_ROLE_OWNER;\n\n    /* Update the modhash.\n     */\n    rc = zhash_insert (mh->zh_byuuid, module_get_uuid (p), p);\n    assert (rc == 0); /* uuids are by definition unique */\n    zhash_freefn (mh->zh_byuuid, module_get_uuid (p),\n                  (zhash_free_fn *)module_destroy);\n    return p;\n\ncleanup:\n    module_destroy (p);\n    return NULL;\n}\n\nvoid module_remove (modhash_t *mh, module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    zhash_delete (mh->zh_byuuid, module_get_uuid (p));\n}\n\nmodhash_t *modhash_create (void)\n{\n    modhash_t *mh = calloc (1, sizeof (*mh));\n    if (!mh) {\n        errno = ENOMEM;\n        return NULL;\n    }\n    if (!(mh->zh_byuuid = zhash_new ())) {\n        modhash_destroy (mh);\n        errno = ENOMEM;\n        return NULL;\n    }\n    return mh;\n}\n\nvoid modhash_destroy (modhash_t *mh)\n{\n    const char *uuid;\n    module_t *p;\n    int e;\n\n    if (mh) {\n        if (mh->zh_byuuid) {\n            FOREACH_ZHASH (mh->zh_byuuid, uuid, p) {\n                if (p->t) {\n                    if ((e = pthread_cancel (p->t)) != 0 && e != ESRCH)\n                        log_errn (e, \"pthread_cancel\");\n                }\n            }\n            zhash_destroy (&mh->zh_byuuid);\n        }\n        free (mh);\n    }\n}\n\nvoid modhash_set_rank (modhash_t *mh, uint32_t rank)\n{\n    mh->rank = rank;\n}\n\nvoid modhash_set_flux (modhash_t *mh, flux_t *h)\n{\n    mh->broker_h = h;\n}\n\njson_t *module_get_modlist (modhash_t *mh, struct service_switch *sw)\n{\n    json_t *mods = NULL;\n    zlist_t *uuids = NULL;\n    char *uuid;\n    module_t *p;\n\n    if (!(mods = json_array()))\n        goto nomem;\n    if (!(uuids = zhash_keys (mh->zh_byuuid)))\n        goto nomem;\n    uuid = zlist_first (uuids);\n    while (uuid) {\n        if ((p = zhash_lookup (mh->zh_byuuid, uuid))) {\n            json_t *svcs;\n            json_t *entry;\n\n            if (!(svcs  = service_list_byuuid (sw, uuid)))\n                goto nomem;\n            if (!(entry = json_pack (\"{s:s s:i s:s s:i s:i s:o}\",\n                                     \"name\", module_get_name (p),\n                                     \"size\", p->size,\n                                     \"digest\", p->digest,\n                                      \"idle\", module_get_idle (p),\n                                      \"status\", p->status,\n                                      \"services\", svcs))) {\n                json_decref (svcs);\n                goto nomem;\n            }\n            if (json_array_append_new (mods, entry) < 0) {\n                json_decref (entry);\n                goto nomem;\n            }\n        }\n        uuid = zlist_next (uuids);\n    }\n    zlist_destroy (&uuids);\n    return mods;\nnomem:\n    zlist_destroy (&uuids);\n    json_decref (mods);\n    errno = ENOMEM;\n    return NULL;\n}\n\nmodule_t *module_lookup (modhash_t *mh, const char *uuid)\n{\n    return zhash_lookup (mh->zh_byuuid, uuid);\n}\n\nmodule_t *module_lookup_byname (modhash_t *mh, const char *name)\n{\n    zlist_t *uuids;\n    char *uuid;\n    module_t *result = NULL;\n\n    if (!(uuids = zhash_keys (mh->zh_byuuid))) {\n        errno = ENOMEM;\n        return NULL;\n    }\n    uuid = zlist_first (uuids);\n    while (uuid) {\n        module_t *p = zhash_lookup (mh->zh_byuuid, uuid);\n        assert (p != NULL);\n        if (!strcmp (module_get_name (p), name)) {\n            result = p;\n            break;\n        }\n        uuid = zlist_next (uuids);\n        p = NULL;\n    }\n    zlist_destroy (&uuids);\n    return result;\n}\n\nint module_subscribe (modhash_t *mh, const char *uuid, const char *topic)\n{\n    module_t *p = zhash_lookup (mh->zh_byuuid, uuid);\n    char *cpy = NULL;\n    int rc = -1;\n\n    if (!p) {\n        errno = ENOENT;\n        goto done;\n    }\n    if (!(cpy = strdup (topic))) {\n        errno = ENOMEM;\n        goto done;\n    }\n    if (zlist_push (p->subs, cpy) < 0) {\n        free (cpy);\n        errno = ENOMEM;\n        goto done;\n    }\n    rc = 0;\ndone:\n    return rc;\n}\n\nint module_unsubscribe (modhash_t *mh, const char *uuid, const char *topic)\n{\n    module_t *p = zhash_lookup (mh->zh_byuuid, uuid);\n    char *s;\n    int rc = -1;\n\n    if (!p) {\n        errno = ENOENT;\n        goto done;\n    }\n    s = zlist_first (p->subs);\n    while (s) {\n        if (!strcmp (topic, s)) {\n            zlist_remove (p->subs, s);\n            free (s);\n            break;\n        }\n        s = zlist_next (p->subs);\n    }\n    rc = 0;\ndone:\n    return rc;\n}\n\nstatic bool match_sub (module_t *p, const char *topic)\n{\n    char *s = zlist_first (p->subs);\n\n    while (s) {\n        if (!strncmp (topic, s, strlen (s)))\n            return true;\n        s = zlist_next (p->subs);\n    }\n    return false;\n}\n\nint module_event_mcast (modhash_t *mh, const flux_msg_t *msg)\n{\n    const char *topic;\n    module_t *p;\n    int rc = -1;\n\n    if (flux_msg_get_topic (msg, &topic) < 0)\n        goto done;\n    p = zhash_first (mh->zh_byuuid);\n    while (p) {\n        if (match_sub (p, topic)) {\n            if (module_sendmsg (p, msg) < 0)\n                goto done;\n        }\n        p = zhash_next (mh->zh_byuuid);\n    }\n    rc = 0;\ndone:\n    return rc;\n}\n\nmodule_t *module_first (modhash_t *mh)\n{\n    return zhash_first (mh->zh_byuuid);\n}\n\nmodule_t *module_next (modhash_t *mh)\n{\n    return zhash_next (mh->zh_byuuid);\n}\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-dhf3djcroafxxgzw73ri4gkvkvqs6ets/spack-src/t/module/parent.c": "/************************************************************\\\n * Copyright 2014 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <libgen.h>\n#include <dlfcn.h>\n#include <argz.h>\n#include <flux/core.h>\n#include <czmq.h>\n#include <jansson.h>\n\n#include \"src/common/libutil/xzmalloc.h\"\n#include \"src/common/libutil/log.h\"\n#include \"src/common/libutil/oom.h\"\n\ntypedef struct {\n    char *name;\n    int size;\n    char *digest;\n    int idle;\n    int status;\n    void *dso;\n    mod_main_f *main;\n} module_t;\n\nstatic zhash_t *modules = NULL;\nstatic uint32_t rank;\n\n/* Calculate file digest using zfile() class from czmq.\n * Caller must free.\n */\nchar *digest (const char *path)\n{\n    zfile_t *zf = zfile_new (NULL, path);\n    char *digest = NULL;\n    if (zf)\n        digest = xstrdup (zfile_digest (zf));\n    zfile_destroy (&zf);\n    return digest;\n}\n\nstatic void module_destroy (module_t *m)\n{\n    if (m->name)\n        free (m->name);\n    if (m->digest)\n        free (m->digest);\n    if (m->dso)\n        dlclose (m->dso);\n    free (m);\n}\n\nstatic module_t *module_create (const char *path, char *argz, size_t argz_len)\n{\n    module_t *m = xzmalloc (sizeof (*m));\n    struct stat sb;\n    char **av = NULL;\n\n    if (stat (path, &sb) < 0 || !(m->name = flux_modname (path, NULL, NULL))\n                             || !(m->digest = digest (path))) {\n        module_destroy (m);\n        errno = ESRCH;\n        return NULL;\n    }\n    m->size = sb.st_size;\n    m->dso = dlopen (path, RTLD_NOW | RTLD_LOCAL);\n    if (!m->dso || !(m->main = dlsym (m->dso, \"mod_main\"))) {\n        module_destroy (m);\n        errno = EINVAL;\n        return NULL;\n    }\n    av = xzmalloc (sizeof (av[0]) * (argz_count (argz, argz_len) + 1));\n    argz_extract (argz, argz_len, av);\n    if (m->main (NULL, argz_count (argz, argz_len), av) < 0) {\n        module_destroy (m);\n        errno = EINVAL;\n        return NULL;\n    }\n    if (zhash_lookup (modules, m->name)) {\n        module_destroy (m);\n        errno = EEXIST;\n        return NULL;\n    }\n    zhash_update (modules, m->name, m);\n    zhash_freefn (modules, m->name, (zhash_free_fn *)module_destroy);\n    if (av)\n        free (av);\n    return m;\n}\n\n/* N.B. services is hardwired to test1,test2,testN, where N is the local\n * broker rank.  This is a specific setup for the flux-module test.  This\n * base component does not perform message routing to its extension modules.\n */\nstatic json_t *module_list (void)\n{\n    json_t *mods;\n    zlist_t *keys;\n    module_t *m;\n    char *name;\n    char rankstr[16];\n    int n;\n\n    if (!(mods = json_array ()))\n        oom ();\n    if (!(keys = zhash_keys (modules)))\n        oom ();\n    name = zlist_first (keys);\n    n = snprintf (rankstr, sizeof (rankstr), \"rank%d\", (int)rank);\n    assert (n < sizeof (rankstr));\n    while (name) {\n        json_t *o;\n        m = zhash_lookup (modules, name);\n        if (!(o = json_pack (\"{s:s s:i s:s s:i s:i s:[s,s,s]}\",\n                             \"name\", m->name,\n                             \"size\", m->size,\n                             \"digest\", m->digest,\n                             \"idle\", m->idle,\n                             \"status\", m->status,\n                             \"services\", \"test1\", \"test2\", rankstr)))\n            oom ();\n        if (json_array_append_new (mods, o) < 0)\n            oom ();\n        name = zlist_next (keys);\n    }\n    zlist_destroy (&keys);\n    return mods;\n}\n\nstatic void insmod_request_cb (flux_t *h, flux_msg_handler_t *mh,\n                               const flux_msg_t *msg, void *arg)\n{\n    const char *path;\n    json_t *args;\n    size_t index;\n    json_t *value;\n    char *argz = NULL;\n    size_t argz_len = 0;\n    module_t *m = NULL;\n    error_t e;\n\n    if (flux_request_unpack (msg, NULL, \"{s:s s:o}\", \"path\", &path,\n                                                     \"args\", &args) < 0)\n        goto error;\n    if (!json_is_array (args))\n        goto proto;\n    json_array_foreach (args, index, value) {\n        if (!json_is_string (value))\n            goto proto;\n        if ((e = argz_add (&argz, &argz_len, json_string_value (value)))) {\n            errno = e;\n            goto error;\n        }\n    }\n    if (!(m = module_create (path, argz, argz_len)))\n        goto error;\n    flux_log (h, LOG_DEBUG, \"insmod %s\", m->name);\n    if (flux_respond (h, msg, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond\", __FUNCTION__);\n    free (argz);\n    return;\nproto:\n    errno = EPROTO;\nerror:\n    if (flux_respond_error (h, msg, errno, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond_error\", __FUNCTION__);\n    free (argz);\n}\n\nstatic void rmmod_request_cb (flux_t *h, flux_msg_handler_t *mh,\n                              const flux_msg_t *msg, void *arg)\n{\n    const char *name;\n\n    if (flux_request_unpack (msg, NULL, \"{s:s}\", \"name\", &name) < 0)\n        goto error;\n    if (!zhash_lookup (modules, name)) {\n        errno = ENOENT;\n        goto error;\n    }\n    zhash_delete (modules, name);\n    flux_log (h, LOG_DEBUG, \"rmmod %s\", name);\n    if (flux_respond (h, msg, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond\", __FUNCTION__);\n    return;\nerror:\n    if (flux_respond_error (h, msg, errno, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond_error\", __FUNCTION__);\n}\n\nstatic void lsmod_request_cb (flux_t *h, flux_msg_handler_t *mh,\n                              const flux_msg_t *msg, void *arg)\n{\n    json_t *mods = NULL;\n\n    if (flux_request_decode (msg, NULL, NULL) < 0)\n        goto error;\n    mods = module_list ();\n    if (flux_respond_pack (h, msg, \"{s:O}\", \"mods\", mods) < 0)\n        flux_log_error (h, \"%s: flux_respond\", __FUNCTION__);\n    json_decref (mods);\n    return;\nerror:\n    if (flux_respond_error (h, msg, errno, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond_error\", __FUNCTION__);\n}\n\nconst struct flux_msg_handler_spec htab[] = {\n    { FLUX_MSGTYPE_REQUEST, \"parent.insmod\",         insmod_request_cb, 0 },\n    { FLUX_MSGTYPE_REQUEST, \"parent.rmmod\",          rmmod_request_cb, 0 },\n    { FLUX_MSGTYPE_REQUEST, \"parent.lsmod\",          lsmod_request_cb, 0 },\n    FLUX_MSGHANDLER_TABLE_END,\n};\n\nint mod_main (flux_t *h, int argc, char **argv)\n{\n    int saved_errno;\n    flux_msg_handler_t **handlers = NULL;\n\n    if (argc == 1 && !strcmp (argv[0], \"--init-failure\")) {\n        flux_log (h, LOG_INFO, \"aborting during init per test request\");\n        errno = EIO;\n        goto error;\n    }\n    if (!(modules = zhash_new ())) {\n        errno = ENOMEM;\n        goto error;\n    }\n    if (flux_get_rank (h, &rank) < 0)\n        goto error;\n    if (flux_msg_handler_addvec (h, htab, NULL, &handlers) < 0)\n        goto error;\n    if (flux_reactor_run (flux_get_reactor (h), 0) < 0) {\n        flux_log_error (h, \"flux_reactor_run\");\n        goto error;\n    }\n    zhash_destroy (&modules);\n    return 0;\nerror:\n    saved_errno = errno;\n    flux_msg_handler_delvec (handlers);\n    zhash_destroy (&modules);\n    errno = saved_errno;\n    return -1;\n}\n\nMOD_NAME (\"parent\");\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-dhf3djcroafxxgzw73ri4gkvkvqs6ets/spack-src/src/broker/doc/states_norm.png",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-dhf3djcroafxxgzw73ri4gkvkvqs6ets/spack-src/src/broker/doc/states.png",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-dhf3djcroafxxgzw73ri4gkvkvqs6ets/spack-src/.git/objects/pack/pack-5cc60094ffb264511b75e25a85dba285c841c5fb.pack",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-dhf3djcroafxxgzw73ri4gkvkvqs6ets/spack-src/.git/objects/pack/pack-5cc60094ffb264511b75e25a85dba285c841c5fb.idx"
    ],
    "total_files": 1610
}