{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-hepmc3-3.2.2-6qqtn7anzpcrfntqer2lmbktygju4jvm/spack-src/src/WriterPlugin.cc": "// -*- C++ -*-\n//\n// This file is part of HepMC\n// Copyright (C) 2014-2019 The HepMC collaboration (see AUTHORS for details)\n//\n///\n/// @file WriterPlugin.cc\n/// @brief Implementation of \\b class WriterPlugin\n///\n#ifdef WIN32\n#define WIN32_LEAN_AND_MEAN\n#define NOWINBASEINTERLOCK\n#define NOMINMAX\n#undef UNICODE\n#include <intrin.h>\n#include <windows.h>\n#endif\n#if defined(__linux__) || defined(__darwin__)\n#include <dlfcn.h>\n#endif\n#include <cstring>\n#include <sstream>\n#include \"HepMC3/WriterPlugin.h\"\n#include \"HepMC3/GenEvent.h\"\n\n\nnamespace HepMC3 {\n\nWriterPlugin::WriterPlugin(std::ostream & stream,const std::string &libname, const std::string &newwriter,std::shared_ptr<GenRunInfo> run) {\n\n#ifdef WIN32\n    dll_handle=nullptr;\n    dll_handle = LoadLibrary(libname.c_str());\n    if (!dll_handle) { printf(\"Error  while loading library %s. Error code %i\\n\",libname.c_str(),GetLastError()); m_writer=nullptr; return;  }\n    typedef Writer* (__stdcall *f_funci)(std::ostream & stream,shared_ptr<GenRunInfo>);\n    f_funci newWriter = (f_funci)GetProcAddress((HINSTANCE)(dll_handle), newwriter.c_str());\n    if (!newWriter) { printf(\"Error  while loading function %s from  library %s. Error code %i\\n\",newwriter.c_str(),libname.c_str(),GetLastError()); m_writer=nullptr; return;  }\n    m_writer=(Writer*)(newWriter(stream,run));\n#endif\n\n#if defined(__linux__) || defined(__darwin__)\n    dll_handle=nullptr;\n    dll_handle = dlopen(libname.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n    if (!dll_handle) { printf(\"Error  while loading library %s: %s\\n\",libname.c_str(),dlerror()); m_writer=nullptr; return;  }\n    Writer* (*newWriter)(std::ostream & stream,std::shared_ptr<GenRunInfo>);\n    newWriter=(Writer* (*)(std::ostream & stream,std::shared_ptr<GenRunInfo>))dlsym(dll_handle, newwriter.c_str());\n    if (!newWriter) { printf(\"Error  while loading function %s from  library %s: %s\\n\",newwriter.c_str(),libname.c_str(),dlerror()); m_writer=nullptr; return;   }\n    m_writer=(Writer*)(newWriter(stream,run));\n#endif\n\n\n}\nWriterPlugin::WriterPlugin(const std::string& filename,const std::string &libname, const std::string &newwriter,std::shared_ptr<GenRunInfo> run) {\n\n#ifdef WIN32\n    dll_handle=nullptr;\n    dll_handle = LoadLibrary(libname.c_str());\n    if (!dll_handle) { printf(\"Error  while loading library %s. Error code %i\\n\",libname.c_str(),GetLastError()); m_writer=nullptr; return;  }\n    typedef Writer* (__stdcall *f_funci)(const std::string&,shared_ptr<GenRunInfo>);\n    f_funci newWriter = (f_funci)GetProcAddress((HINSTANCE)(dll_handle), newwriter.c_str());\n    if (!newWriter) { printf(\"Error  while loading function %s from  library %s. Error code %i\\n\",newwriter.c_str(),libname.c_str(),GetLastError()); m_writer=nullptr; return;  }\n    m_writer=(Writer*)(newWriter(filename,run));\n#endif\n\n#if defined(__linux__) || defined(__darwin__)\n    dll_handle=nullptr;\n    dll_handle = dlopen(libname.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n    if (!dll_handle) { printf(\"Error  while loading library %s: %s\\n\",libname.c_str(),dlerror()); m_writer=nullptr; return;  }\n    Writer* (*newWriter)(const std::string&,std::shared_ptr<GenRunInfo>);\n    newWriter=(Writer* (*)(const std::string&,std::shared_ptr<GenRunInfo>))dlsym(dll_handle, newwriter.c_str());\n    if (!newWriter) { printf(\"Error  while loading function %s from  library %s: %s\\n\",newwriter.c_str(),libname.c_str(),dlerror()); m_writer=nullptr; return;   }\n    m_writer=(Writer*)(newWriter(filename,run));\n#endif\n}\n\nWriterPlugin::~WriterPlugin() {\n    if (m_writer) m_writer->close();\n    if (m_writer) delete m_writer;\n#ifdef WIN32\n    if(dll_handle) {\n        FreeLibrary((HINSTANCE)dll_handle);\n    }\n#endif\n#if defined(__linux__) || defined(__darwin__)\n    if(dll_handle) {\n        dlclose(dll_handle);\n        dll_handle = nullptr;\n    }\n#endif\n}\n} // namespace HepMC3\n",
        "/tmp/vanessa/spack-stage/spack-stage-hepmc3-3.2.2-6qqtn7anzpcrfntqer2lmbktygju4jvm/spack-src/src/ReaderPlugin.cc": "// -*- C++ -*-\n//\n// This file is part of HepMC\n// Copyright (C) 2014-2019 The HepMC collaboration (see AUTHORS for details)\n//\n///\n/// @file ReaderPlugin.cc\n/// @brief Implementation of \\b class ReaderPlugin\n///\n#ifdef WIN32\n#define WIN32_LEAN_AND_MEAN\n#define NOWINBASEINTERLOCK\n#define NOMINMAX\n#undef UNICODE\n#include <intrin.h>\n#include <windows.h>\n#endif\n#if defined(__linux__) || defined(__darwin__)\n#include <dlfcn.h>\n#endif\n#include <cstring>\n#include <sstream>\n#include \"HepMC3/ReaderPlugin.h\"\n#include \"HepMC3/GenEvent.h\"\n\nnamespace HepMC3 {\n\nReaderPlugin::ReaderPlugin(std::istream & stream,const std::string &libname, const std::string &newreader) {\n\n#ifdef WIN32\n    dll_handle=nullptr;\n    dll_handle = LoadLibrary(libname.c_str());\n    if (!dll_handle) { printf(\"Error  while loading library %s. Error code %i\\n\",libname.c_str(),GetLastError()); m_reader=nullptr; return;  }\n    typedef Reader* (__stdcall *f_funci)(std::istream & stream);\n    f_funci newReader = (f_funci)GetProcAddress((HINSTANCE)(dll_handle), newreader.c_str());\n    if (!newReader) { printf(\"Error  while loading function %s from  library %s. Error code %i\\n\",newreader.c_str(),libname.c_str(),GetLastError()); m_reader=nullptr; return;  }\n    m_reader=(Reader*)(newReader(stream));\n#endif\n\n#if defined(__linux__) || defined(__darwin__)\n    dll_handle=nullptr;\n    dll_handle = dlopen(libname.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n    if (!dll_handle) { printf(\"Error  while loading library %s: %s\\n\",libname.c_str(),dlerror()); m_reader=nullptr; return;  }\n    Reader* (*newReader)(std::istream & stream);\n    newReader=(Reader* (*)(std::istream & stream))dlsym(dll_handle, newreader.c_str());\n    if (!newReader) { printf(\"Error  while loading function %s from  library %s: %s\\n\",newreader.c_str(),libname.c_str(),dlerror()); m_reader=nullptr; return;   }\n    m_reader=(Reader*)(newReader(stream));\n#endif\n\n}\n/** @brief Constructor */\nReaderPlugin::ReaderPlugin(const std::string& filename,const std::string &libname, const std::string &newreader) {\n\n#ifdef WIN32\n    dll_handle=nullptr;\n    dll_handle = LoadLibrary(libname.c_str());\n    if (!dll_handle) { printf(\"Error  while loading library %s. Error code %i\\n\",libname.c_str(),GetLastError()); m_reader=nullptr; return;  }\n    typedef Reader* (__stdcall *f_funci)(const std::string&);\n    f_funci newReader = (f_funci)GetProcAddress((HINSTANCE)(dll_handle), newreader.c_str());\n    if (!newReader) { printf(\"Error  while loading function %s from  library %s. Error code %i\\n\",newreader.c_str(),libname.c_str(),GetLastError()); m_reader=nullptr; return;  }\n    m_reader=(Reader*)(newReader(filename));\n#endif\n\n#if defined(__linux__) || defined(__darwin__)\n    dll_handle=nullptr;\n    dll_handle = dlopen(libname.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n    if (!dll_handle) { printf(\"Error  while loading library %s: %s\\n\",libname.c_str(),dlerror()); m_reader=nullptr; return;  }\n    Reader* (*newReader)(const std::string&);\n    newReader=(Reader* (*)(const std::string&))dlsym(dll_handle, newreader.c_str());\n    if (!newReader) { printf(\"Error  while loading function %s from  library %s: %s\\n\",newreader.c_str(),libname.c_str(),dlerror()); m_reader=nullptr; return;   }\n    m_reader=(Reader*)(newReader(filename));\n#endif\n}\nReaderPlugin::~ReaderPlugin() {\n    if (m_reader) m_reader->close();\n    if (m_reader) delete m_reader;\n#ifdef WIN32\n    if(dll_handle) {\n        FreeLibrary((HINSTANCE)(dll_handle));\n    }\n#endif\n#if defined(__linux__) || defined(__darwin__)\n    if(dll_handle) {\n        dlclose(dll_handle);\n        dll_handle = nullptr;\n    }\n#endif\n}\n} // namespace HepMC3\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-hepmc3-3.2.2-6qqtn7anzpcrfntqer2lmbktygju4jvm/spack-src/python/test/inputIO4.root",
        "/tmp/vanessa/spack-stage/spack-stage-hepmc3-3.2.2-6qqtn7anzpcrfntqer2lmbktygju4jvm/spack-src/test/inputIO4.root",
        "/tmp/vanessa/spack-stage/spack-stage-hepmc3-3.2.2-6qqtn7anzpcrfntqer2lmbktygju4jvm/spack-src/test/inputRootTree300.root",
        "/tmp/vanessa/spack-stage/spack-stage-hepmc3-3.2.2-6qqtn7anzpcrfntqer2lmbktygju4jvm/spack-src/test/inputRoot300.root",
        "/tmp/vanessa/spack-stage/spack-stage-hepmc3-3.2.2-6qqtn7anzpcrfntqer2lmbktygju4jvm/spack-src/doc/doxygen/class_diagram_3.0.png",
        "/tmp/vanessa/spack-stage/spack-stage-hepmc3-3.2.2-6qqtn7anzpcrfntqer2lmbktygju4jvm/spack-src/doc/doxygen/class_diagram.png"
    ],
    "total_files": 373
}