{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-kcov-38-buvznlfizxm6ht7fd5lsx6caszkfgcea/spack-src/src/engines/bash-execve-redirector.c": "#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <dlfcn.h>\n\n// Peek the first few bytes of a file (i.e., #!/bin/sh etc)\nstatic int peek_file(const char *filename, char *buf, int bufSize)\n{\n\tFILE *fp = fopen(filename, \"r\");\n\tint rv;\n\n\tif (!fp)\n\t\treturn -1;\n\n\trv = fread(buf, 1, bufSize, fp);\n\n\tfclose(fp);\n\n\treturn rv;\n}\n\nstatic char *kcovBash;\nstatic int kcovUseDebugTrap;\n\nstatic int (*orig_execve)(const char *filename, char * const argv[], char * const envp[]);\nint execve(const char *filename, char * const argv[], char * const envp[])\n{\n\tchar startBytes[128];\n\tint sizeRead;\n\tconst char bashArg[3] =\n\t{ '-', 'x', '\\0' };\n\n\tif (!orig_execve)\n\t\torig_execve = dlsym(RTLD_NEXT, \"execve\");\n\n\tsizeRead = peek_file(filename, startBytes, sizeof(startBytes));\n\n\t// Make sure it's NULL-terminated\n\tstartBytes[sizeof(startBytes) - 1] = '\\0';\n\tif (sizeRead >= 0)\n\t\tstartBytes[sizeRead] = '\\0';\n\n\t// Shell script being executed?\n\tif (kcovBash && sizeRead >= 6\n\t\t\t&& (strstr(startBytes, \"/bin/sh\") != NULL || strstr(startBytes, \"/bin/bash\") != NULL\n\t\t\t\t\t|| strstr(startBytes, \"/bin/ash\") != NULL || strstr(startBytes, \"/bin/dash\") != NULL ))\n\t{\n\t\tchar **replacementArgv;\n\t\tunsigned i = 0;\n\n\t\t// Find end\n\t\tfor (i = 0; argv[i]; i++)\n\t\t\t;\n\n\t\tunsigned arg = 0;\n\n\t\treplacementArgv = malloc(sizeof(char*) * (i + 4));\n\t\treplacementArgv[arg++] = strdup(kcovBash);\n\t\tif (!kcovUseDebugTrap)\n\t\t\treplacementArgv[arg++] = strdup(bashArg);\n\t\treplacementArgv[arg++] = strdup(filename);\n\t\tfor (i = 0; argv[i]; i++)\n\t\t\treplacementArgv[i + arg] = strdup(argv[i]);\n\t\treplacementArgv[i + arg] = NULL;\n\n\t\tfilename = strdup(kcovBash);\n\n\t\targv = replacementArgv;\n\t}\n\n\treturn orig_execve(filename, argv, envp);\n}\n\nvoid __attribute__((constructor)) kcov_bash_execve_at_startup(void)\n{\n\tkcovBash = getenv(\"KCOV_BASH_COMMAND\");\n\tif (getenv(\"KCOV_BASH_USE_DEBUG_TRAP\"))\n\t\tkcovUseDebugTrap = 1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-kcov-38-buvznlfizxm6ht7fd5lsx6caszkfgcea/spack-src/src/solib-parser/lib.c": "#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include <phdr_data.h>\n\nstatic struct phdr_data *phdr_data;\n\nstatic int phdrCallback(struct dl_phdr_info *info, size_t size, void *data)\n{\n\t// the first entry is used to determine the executable's \"base address\"\n\t// (which is actually the relocation for PIE)\n\tif (phdr_data->n_entries == 0)\n\t{\n\t\tphdr_data->relocation = info->dlpi_addr;\n\t}\n\n\tphdr_data_add(phdr_data, info);\n\n\treturn 0;\n}\n\nstatic int phdrSizeCallback(struct dl_phdr_info *info, size_t size, void *data)\n{\n\tsize_t *ps = (size_t *)data;\n\n\t*ps += sizeof(struct phdr_data_entry);\n\n\treturn 0;\n}\n\nstatic void parse_solibs(void)\n{\n\tchar *kcov_solib_path;\n\tvoid *p;\n\tssize_t written;\n\tsize_t allocSize;\n\tsize_t sz;\n\tint fd;\n\n\tkcov_solib_path = getenv(\"KCOV_SOLIB_PATH\");\n\tif (!kcov_solib_path)\n\t\treturn;\n\n\tallocSize = sizeof(struct phdr_data);\n\tdl_iterate_phdr(phdrSizeCallback, &allocSize);\n\n\tphdr_data = phdr_data_new(allocSize);\n\tif (!phdr_data)\n\t{\n\t\tfprintf(stderr, \"kcov-solib: Can't allocate %zu bytes\\n\", allocSize);\n\t\treturn;\n\t}\n\n\n\tdl_iterate_phdr(phdrCallback, NULL);\n\n\tp = phdr_data_marshal(phdr_data, &sz);\n\n\tfd = open(kcov_solib_path, O_WRONLY);\n\tif (fd < 0)\n\t{\n\t\tfprintf(stderr, \"kcov-solib: Can't open %s\\n\", kcov_solib_path);\n\t\treturn;\n\t}\n\twritten = write(fd, p, sz);\n\n\tif (written != sz)\n\t\tfprintf(stderr, \"kcov-solib: Can't write to solib FIFO (%zu)\\n\", written);\n\n\tphdr_data_free(p);\n\n\tclose(fd);\n}\n\nstatic void force_breakpoint(void)\n{\n\tasm volatile(\n#if defined(__i386__) || defined(__x86_64__)\n\t\t\t\"int3\\n\"\n#elif defined(__powerpc__)\n\t\t\t\".long 0x7fe00008\\n\" /* trap instruction */\n#elif defined(__arm__)\n\t\t\t\".long 0xfedeffe7\\n\" /* undefined insn */\n#elif defined(__aarch64__)\n\t\t\t\".long 0xd4200000\\n\" /* From https://github.com/scottt/debugbreak */\n#else\n# error Unsupported architecture\n#endif\n\t\t\t);\n}\n\nstatic void *(*orig_dlopen)(const char *, int);\nvoid *dlopen(const char *filename, int flag)\n{\n\tvoid *out;\n\n\tif (!orig_dlopen)\n\t\torig_dlopen = dlsym(RTLD_NEXT, \"dlopen\");\n\n\tout = orig_dlopen(filename, flag);\n\n\tparse_solibs();\n\tforce_breakpoint();\n\n\treturn out;\n}\n\n\nvoid  __attribute__((constructor))kcov_solib_at_startup(void)\n{\n\tparse_solibs();\n\tforce_breakpoint();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-kcov-38-buvznlfizxm6ht7fd5lsx6caszkfgcea/spack-src/tests/dlopen/dlopen.cc": "#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid do_dlopen()\n{\n\tvoid *handle;\n\tint (*sym)(int);\n\n\thandle = dlopen(\"libshared_library.so\", RTLD_LAZY);\n\tif (!handle) {\n\t\tprintf(\"Can't dlopen\\n\");\n\t\texit(1);\n\t}\n\n\tdlerror();\n\tsym = (int (*)(int))dlsym(handle, \"vobb\");\n\tif (!sym) {\n\t\tprintf(\"No symbol\\n\");\n\t\tdlclose(handle);\n\t\texit(1);\n\t}\n\n\tint a = sym(5);\n\tprintf(\"from shared lib: %d\\n\", a);\n\n\tdlclose(handle);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-kcov-38-buvznlfizxm6ht7fd5lsx6caszkfgcea/spack-src/data/glass.png",
        "/tmp/vanessa/spack-stage/spack-stage-kcov-38-buvznlfizxm6ht7fd5lsx6caszkfgcea/spack-src/data/amber.png"
    ],
    "total_files": 283
}