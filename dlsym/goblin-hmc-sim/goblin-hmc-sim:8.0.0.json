{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/src/hmc_cmc.c": "/*\n * _HMC_CMC_C_\n *\n * Hybrid memory cube simulation library\n *\n * Custom memory cube functionality\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dlfcn.h>\n#include \"hmc_sim.h\"\n\n\n/* Function Prototypes */\nextern int hmcsim_trace_rqst( struct hmcsim_t *hmc,\n                              char *rqst,\n                              uint32_t dev,\n                              uint32_t quad,\n                              uint32_t vault,\n                              uint32_t bank,\n                              uint64_t addr,\n                              uint32_t size );\n\n\n/* conversion table for cmc request enums, opcodes and struct indices */\nstruct cmc_table{\n  hmc_rqst_t type;\n  uint32_t cmd;\n  uint32_t idx;\n};\n\nstruct cmc_table ctable[HMC_MAX_CMC] = {\n\n  {CMC04,4,0},\n  {CMC05,5,1},\n  {CMC06,6,2},\n  {CMC07,7,3},\n  {CMC20,20,4},\n  {CMC21,21,5},\n  {CMC22,22,6},\n  {CMC23,23,7},\n  {CMC32,32,8},\n  {CMC36,36,9},\n  {CMC37,37,10},\n  {CMC38,38,11},\n  {CMC39,39,12},\n  {CMC41,41,13},\n  {CMC42,42,14},\n  {CMC43,43,15},\n  {CMC44,44,16},\n  {CMC45,45,17},\n  {CMC46,46,18},\n  {CMC47,47,19},\n  {CMC56,56,20},\n  {CMC57,57,21},\n  {CMC58,58,22},\n  {CMC59,59,23},\n  {CMC60,60,24},\n  {CMC61,61,25},\n  {CMC62,62,26},\n  {CMC63,63,27},\n  {CMC69,69,28},\n  {CMC70,70,29},\n  {CMC71,71,30},\n  {CMC72,72,31},\n  {CMC73,73,32},\n  {CMC74,74,33},\n  {CMC75,75,34},\n  {CMC76,76,35},\n  {CMC77,77,36},\n  {CMC78,78,37},\n  {CMC85,85,38},\n  {CMC86,86,39},\n  {CMC87,87,40},\n  {CMC88,88,41},\n  {CMC89,89,42},\n  {CMC90,90,43},\n  {CMC91,91,44},\n  {CMC92,92,45},\n  {CMC93,93,46},\n  {CMC94,94,47},\n  {CMC102,102,48},\n  {CMC103,103,49},\n  {CMC107,107,50},\n  {CMC108,108,51},\n  {CMC109,109,52},\n  {CMC110,110,53},\n  {CMC111,111,54},\n  {CMC112,112,55},\n  {CMC113,113,56},\n  {CMC114,114,57},\n  {CMC115,115,58},\n  {CMC116,116,59},\n  {CMC117,117,60},\n  {CMC118,118,61},\n  {CMC120,120,62},\n  {CMC121,121,63},\n  {CMC122,122,64},\n  {CMC123,123,65},\n  {CMC124,124,66},\n  {CMC125,125,67},\n  {CMC126,126,68},\n  {CMC127,127,69}\n\n};\n\n\n/* ----------------------------------------------------- HMCSIM_CMC_RAWTOIDX */\nextern uint32_t hmcsim_cmc_rawtoidx( uint32_t raw ){\n  uint32_t i = 0;\n\n  for( i=0; i<HMC_MAX_CMC; i++ ){\n    if( ctable[i].cmd == raw ){\n      return i;\n    }\n  }\n  return HMC_MAX_CMC; /* redundant, but squashes gcc warning */\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_IDXTOCMD */\nextern hmc_rqst_t hmcsim_cmc_idxtocmd( uint32_t idx ){\n  return ctable[idx].type;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_CMDTOIDX */\nextern uint32_t hmcsim_cmc_cmdtoidx( hmc_rqst_t rqst ){\n  uint32_t i = 0;\n\n  for( i=0; i<HMC_MAX_CMC; i++ ){\n    if( ctable[i].type == rqst ){\n      return i;\n    }\n  }\n  return HMC_MAX_CMC; /* redundant, but squashes gcc warning */\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_TRACE_HEADER */\nextern void hmcsim_cmc_trace_header( struct hmcsim_t *hmc ){\n\n  /* vars */\n  uint32_t i      = 0;\n  uint32_t active = 0;\n  char str[256];\n  void (*cmc_str)(char *)  = NULL;\n  /* ---- */\n\n  for( i=0; i<HMC_MAX_CMC; i++ ){\n    active += hmc->cmcs[i].active;\n  }\n\n  if( active == 0 ){\n    /* nothing active, dump out */\n    return ;\n  }\n\n  /* print everything active */\n  fprintf( hmc->tfile, \"%s\\n\",    \"#---------------------------------------------------------\" );\n  fprintf( hmc->tfile, \"%s\\n\",    \"# CMC_OP:CMC_STR:RQST_LEN:RSP_LEN:RSP_CMD_CODE\" );\n  for( i=0; i<HMC_MAX_CMC; i++ ){\n    if( hmc->cmcs[i].active == 1 ){\n      cmc_str = hmc->cmcs[i].cmc_str;\n      (*cmc_str)(&(str[0]));\n      fprintf( hmc->tfile, \"%s%d%s%s%s%d%s%d%s%d\\n\",\n               \"#\",\n               hmc->cmcs[i].cmd,\n               \":\",\n               str,\n               \":\",\n               hmc->cmcs[i].rqst_len,\n               \":\",\n               hmc->cmcs[i].rsp_len,\n               \":\",\n               hmc->cmcs[i].rsp_cmd_code );\n    }\n  }\n  fprintf( hmc->tfile, \"%s\\n\",    \"#---------------------------------------------------------\" );\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_FUNCTIONS */\n/*\n * HMCSIM_REGISTER_FUNCTIONS\n *\n */\nstatic int    hmcsim_register_functions( struct hmcsim_t *hmc, char *cmc_lib ){\n\n  /* vars */\n  hmc_rqst_t rqst;\n  uint32_t cmd;\n  uint32_t idx;\n  uint32_t rqst_len;\n  uint32_t rsp_len;\n  hmc_response_t rsp_cmd;\n  uint8_t rsp_cmd_code;\n\n  void *handle = NULL;\n  int (*cmc_register)(hmc_rqst_t *,\n                      uint32_t *,\n                      uint32_t *,\n                      uint32_t *,\n                      hmc_response_t *,\n                      uint8_t *) = NULL;\n  int (*cmc_execute)(void *,\n                     uint32_t,\n                     uint32_t,\n                     uint32_t,\n                     uint32_t,\n                     uint64_t,\n                     uint32_t,\n                     uint64_t,\n                     uint64_t,\n                     uint64_t *,\n                     uint64_t *) = NULL;\n  void (*cmc_str)(char *) = NULL;\n  void (*cmc_power)(uint32_t *,float *) = NULL;\n  uint32_t (*cmc_dyn_rsp)() = NULL;\n  uint32_t (*cmc_dyn_rqst)() = NULL;\n  uint32_t (*cmc_dyn)() = NULL;\n  uint32_t dynamic = 0;\n  /* ---- */\n\n  /* attempt to load the library */\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"LOADING CMC LIBRARY\" );\n#endif\n  handle = dlopen( cmc_lib, RTLD_NOW );\n\n  if( handle == NULL ){\n#ifdef HMC_DEBUG\n    HMCSIM_PRINT_TRACE(dlerror());\n#endif\n    return -1;\n  }\n\n  /* library is loaded, resolve the functions */\n  /* -- hmcsim_register_cmc */\n  cmc_register = (int (*)(hmc_rqst_t *,\n                          uint32_t *,\n                          uint32_t *,\n                          uint32_t *,\n                          hmc_response_t *,\n                          uint8_t *))dlsym(handle,\"hmcsim_register_cmc\");\n  if( cmc_register == NULL ){\n    dlclose( handle );\n    return -1;\n  }\n\n  if( (*cmc_register)(&rqst,\n                      &cmd,\n                      &rqst_len,\n                      &rsp_len,\n                      &rsp_cmd,\n                      &rsp_cmd_code) != 0 ){\n    dlclose( handle );\n    return -1;\n  }\n\n  /* -- hmcsim_execute_cmc */\n  cmc_execute = (int (*)(void *,\n                     uint32_t,\n                     uint32_t,\n                     uint32_t,\n                     uint32_t,\n                     uint64_t,\n                     uint32_t,\n                     uint64_t,\n                     uint64_t,\n                     uint64_t *,\n                     uint64_t *))dlsym(handle,\"hmcsim_execute_cmc\");\n  if( cmc_execute == NULL ){\n    dlclose( handle );\n    return -1;\n  }\n\n  /* -- hmcsim_cmc_str */\n  cmc_str = (void (*)(char *))dlsym(handle,\"hmcsim_cmc_str\");\n  if( cmc_str == NULL ){\n    dlclose( handle );\n    return -1;\n  }\n\n  /* -- hmcsim_cmc_power */\n  cmc_power = (void (*)(uint32_t *,float *))dlsym(handle,\"hmcsim_cmc_power\");\n\n  /* hmcsim_cmc_dynamic */\n  cmc_dyn = (uint32_t (*)())dlsym(handle,\"hmcsim_cmc_dynamic\");\n  if( cmc_dyn != NULL ){\n    dynamic = (*cmc_dyn)();\n  }\n  if( dynamic ){\n    /* load the remainder of the dynamic rqst/rsp functions */\n    cmc_dyn_rsp = (uint32_t (*)())dlsym(handle,\"hmcsim_cmc_dynamic_rsp_len\");\n    cmc_dyn_rqst = (uint32_t (*)())dlsym(handle,\"hmcsim_cmc_dynamic_rqst_len\");\n  }\n\n\n  /* done loading functions */\n\n  idx = hmcsim_cmc_rawtoidx( cmd );\n#ifdef HMC_DEBUG\n  printf( \"HMCSIM_REGISTER_FUNCTIONS: Setting CMC command (%d) at IDX=%d to ACTIVE\\n\",\n          cmd,idx );\n#endif\n\n  if( hmc->cmcs[idx].active == 1 ){\n    /* previously activated, this is an error */\n    dlclose( handle );\n    return -1;\n  }\n\n  /* write the necessary references into the structure */\n  if( cmc_power != NULL ){\n    hmc->cmcs[idx].cmc_power    = cmc_power;\n    hmc->cmcs[idx].track_power  = 1;\n  }else{\n    hmc->cmcs[idx].cmc_power    = NULL;\n    hmc->cmcs[idx].track_power  = 0;\n  }\n  hmc->cmcs[idx].type         = rqst;\n  hmc->cmcs[idx].cmd          = cmd;\n  hmc->cmcs[idx].rqst_len     = rqst_len;\n  hmc->cmcs[idx].rsp_len      = rsp_len;\n  hmc->cmcs[idx].rsp_cmd      = rsp_cmd;\n\n  hmc->cmcs[idx].active       = 1;\n  hmc->cmcs[idx].handle       = handle;\n  hmc->cmcs[idx].cmc_register = cmc_register;\n  hmc->cmcs[idx].cmc_execute  = cmc_execute;\n  hmc->cmcs[idx].cmc_str      = cmc_str;\n\n  hmc->cmcs[idx].dynamic      = dynamic;\n  hmc->cmcs[idx].cmc_dyn_rsp  = cmc_dyn_rsp;\n  hmc->cmcs[idx].cmc_dyn_rqst = cmc_dyn_rqst;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_QUERY_CMC */\nextern int  hmcsim_query_cmc( struct hmcsim_t *hmc,\n                              hmc_rqst_t type,\n                              uint32_t *flits,\n                              uint8_t *cmd ){\n  /* vars */\n  uint32_t idx      = HMC_MAX_CMC;\n  uint32_t (*cmc_dyn_rqst)() = NULL;\n  /* ---- */\n\n  idx = hmcsim_cmc_cmdtoidx( type );\n\n#ifdef HMC_DEBUG\n  printf( \"HMCSIM_QUERY_CMC: RQST_TYPE = %d; IDX = %d\\n\",\n       type, idx );\n#endif\n\n  if( idx == HMC_MAX_CMC ){\n    return -1;\n  }else if( hmc->cmcs[idx].active == 0 ){\n#ifdef HMC_DEBUG\n    printf( \"ERROR : HMCSIM_QUERY_CMC: CMC OP AT IDX=%d IS INACTIVE\\n\",\n            idx );\n#endif\n    return -1;\n  }\n\n  *flits  = hmc->cmcs[idx].rqst_len;\n  *cmd    = hmc->cmcs[idx].cmd;\n\n  /* check for a dynamic command */\n  if( hmc->cmcs[idx].dynamic == 1){\n    // this cmc command has a dynamic request or response length\n    cmc_dyn_rqst = hmc->cmcs[idx].cmc_dyn_rqst;\n    *flits = (*cmc_dyn_rqst)();\n  }\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_PROCESS_CMC */\nextern int  hmcsim_process_cmc( struct hmcsim_t *hmc,\n                                uint32_t rawcmd,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *raw_rsp_cmd,\n                                uint32_t *row_ops,\n                                float *tpower ){\n\n  /* vars */\n  uint32_t idx  = 0;\n  int rtn       = 0;\n  char op_name[256];\n  int (*cmc_execute)(void *,\n                     uint32_t,\n                     uint32_t,\n                     uint32_t,\n                     uint32_t,\n                     uint64_t,\n                     uint32_t,\n                     uint64_t,\n                     uint64_t,\n                     uint64_t *,\n                     uint64_t *) = NULL;\n  void (*cmc_str)(char *);\n  void (*cmc_power)(uint32_t *,float *) = NULL;\n  uint32_t (*cmc_dyn_rsp)() = NULL;\n  /* ---- */\n\n  /* resolve the index of the cmc in the lookup table */\n  idx = hmcsim_cmc_rawtoidx( rawcmd );\n\n  if( idx == HMC_MAX_CMC ){\n    /* erroneous request */\n    return -1;\n  }else if( hmc->cmcs[idx].active == 0 ){\n    /* command not active */\n    return -1;\n  }\n\n  /* -- new power measurement items */\n  if( (row_ops == NULL) || (tpower == NULL) ){\n    return -1;\n  }\n\n  /* command is active, process it */\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"PROCESSING CMC PACKET\" );\n  printf( \"CMC RAWCMD:IDX = %d:%d\\n\", rawcmd,idx );\n#endif\n  cmc_execute = hmc->cmcs[idx].cmc_execute;\n  rtn = (*cmc_execute)( (void *)(hmc),\n                        dev,\n                        quad,\n                        vault,\n                        bank,\n                        addr,\n                        length,\n                        head,\n                        tail,\n                        rqst_payload,\n                        rsp_payload);\n\n  if( rtn == -1 ){\n    return HMC_ERROR;\n  }\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"DONE PROCESSING CMC PACKET\" );\n  HMCSIM_PRINT_TRACE( \"REGISTERING RESPONSES IF NECESSARY\" );\n#endif\n\n  /* register all the response data */\n  if( hmc->cmcs[idx].dynamic == 1 ){\n    cmc_dyn_rsp = hmc->cmcs[idx].cmc_dyn_rsp;\n    *rsp_len      = (*cmc_dyn_rsp)();\n  }else{\n    *rsp_len      = hmc->cmcs[idx].rsp_len;\n  }\n  *rsp_cmd      = hmc->cmcs[idx].rsp_cmd;\n\n  if( *rsp_len > 0 ){\n    if( *rsp_cmd == RSP_CMC ){\n      *raw_rsp_cmd  = hmc->cmcs[idx].rsp_cmd_code;\n    }else{\n      /* encode the normal reponse */\n      switch( *rsp_cmd ){\n      case RD_RS:\n        *raw_rsp_cmd = 0x38;\n        break;\n      case WR_RS:\n        *raw_rsp_cmd = 0x39;\n        break;\n      case MD_RD_RS:\n        *raw_rsp_cmd = 0x3A;\n        break;\n      case MD_WR_RS:\n        *raw_rsp_cmd = 0x3B;\n        break;\n      case RSP_ERROR:\n      default:\n        *raw_rsp_cmd = 0x00;\n        break;\n      }\n    }\n  }else{\n    *raw_rsp_cmd = 0x00;\n  }\n\n  /* trace it */\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"DUMPING TRACE DATA FOR CMC COMMAND\" );\n#endif\n  /* -- get the name of the op */\n  cmc_str = hmc->cmcs[idx].cmc_str;\n  (*cmc_str)(&(op_name[0]));\n\n  /* -- insert the trace */\n  hmcsim_trace_rqst( hmc,\n                     &(op_name[0]),\n                     dev,\n                     quad,\n                     vault,\n                     bank,\n                     addr,\n                     length );\n\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"DUMPING POWER/THERMAL DATA FOR CMC COMMAND\" );\n#endif\n  /* -- get the power */\n  if( hmc->cmcs[idx].track_power == 1 ){\n    cmc_power = hmc->cmcs[idx].cmc_power;\n    (*cmc_power)(row_ops,tpower);\n  }else{\n    *row_ops = 1;\n    *tpower  = 0.;\n  }\n\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"CMC PROCESSING COMPLETE\" );\n#endif\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_FREE_CMC */\n/*\n * HMCSIM_FREE_CMC\n *\n */\nextern int    hmcsim_free_cmc( struct hmcsim_t *hmc ){\n  uint32_t i = 0;\n\n  if( hmc == NULL ){\n    return -1;\n  }\n\n  if( hmc->cmcs == NULL ){\n    return -1;\n  }\n\n  for( i=0; i<HMC_MAX_CMC; i++ ){\n    if( hmc->cmcs[i].active == 1 ){\n      dlclose( hmc->cmcs[i].handle );\n    }\n  }\n\n  return 0;\n};\n\n/* ----------------------------------------------------- HMCSIM_LOAD_CMC */\n/*\n * HMCSIM_LOAD_CMC\n *\n */\nextern int      hmcsim_load_cmc( struct hmcsim_t *hmc, char *cmc_lib ){\n\n  if((hmc == NULL) || (cmc_lib == NULL)){\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"ERROR PROCESSING FUNCTION ARGUMENTS\" );\n#endif\n    return -1;\n  }\n\n#ifdef HMC_DEBUG\n  printf( \"ATTEMPTING TO LOAD CMC LIBRARY: %s\\n\", cmc_lib );\n#endif\n\n  /* register the library functions */\n  if( hmcsim_register_functions( hmc, cmc_lib ) != 0 ){\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"FAILED TO REGISTER CMC FUNCTIONS\" );\n#endif\n    return -1;\n  }\n\n  return 0;\n}\n\n/* EOF */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/test/dyn_cmc/src/.execute_test.c.swp"
    ],
    "total_files": 280
}