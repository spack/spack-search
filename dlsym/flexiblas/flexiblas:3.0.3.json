{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/src/xerbla.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Linking FlexiBLAS statically or dynamically with other modules is making a\n * combined work based on FlexiBLAS. Thus, the terms and conditions of the GNU\n * General Public License cover the whole combination.\n *\n * As a special exception, the copyright holders of FlexiBLAS give you permission\n * to combine FlexiBLAS program with free software programs or libraries that are\n * released under the GNU LGPL and with independent modules that communicate with\n * FlexiBLAS solely through the BLAS/LAPACK interface as provided by the\n * BLAS/LAPACK reference implementation. You may copy and distribute such a system\n * following the terms of the GNU GPL for FlexiBLAS and the licenses of the other\n * code concerned, provided that you include the source code of that other code\n * when and as the GNU GPL requires distribution of source code and provided that\n * you do not modify the BLAS/LAPACK interface.\n *\n * Note that people who make modified versions of FlexiBLAS are not obligated to\n * grant this special exception for their modified versions; it is their choice\n * whether to do so. The GNU General Public License gives permission to release a\n * modified version without this exception; this exception also makes it possible\n * to release a modified version which carries forward this exception. If you\n * modify the BLAS/LAPACK interface, this exception does not apply to your\n * modified version of FlexiBLAS, and you must remove this exception when you\n * distribute your modified version.\n *\n * This exception is an additional permission under section 7 of the GNU General\n * Public License, version 3 (\u201cGPLv3\u201d)\n *\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2013-2020\n */\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <complex.h>\n\n#include \"flexiblas.h\"\n#ifndef __WIN32__\n#include <dlfcn.h>\n#ifndef RTLD_DEFAULT\n# define RTLD_DEFAULT   ((void *) 0)\n#endif\n#endif\n\n// static int user_xerbla = 0;\nvoid flexiblas_internal_xerbla(char *SNAME, Int *Info, Int len);\n#ifdef FLEXIBLAS_ABI_IBM\n#ifdef __ELF__\n#pragma weak xerbla_\n#pragma weak xerbla\nvoid xerbla_(char *, Int *, Int) __attribute__ (( alias (\"flexiblas_internal_xerbla\")));\nvoid xerbla(char *, Int *, Int) __attribute__ (( alias (\"flexiblas_internal_xerbla\")));\n#else\nvoid xerbla_(char *SNAME, Int *Info, Int len) {\n\tflexiblas_internal_xerbla(SNAME, Info, len);\n}\nvoid xerbla(char *SNAME, Int *Info, Int len) {\n\tflexiblas_internal_xerbla(SNAME, Info, len);\n}\n#endif\n\n#else\n#ifdef __ELF__\nvoid xerbla_(char *, Int *, Int) __attribute__ ((weak, alias (\"flexiblas_internal_xerbla\")));\nvoid xerbla(char *, Int *, Int) __attribute__ ((weak, alias (\"flexiblas_internal_xerbla\")));\n#else\n#pragma weak xerbla_\n#pragma weak xerbla\nvoid xerbla_(char *SNAME, Int *Info, Int len) {\n\tflexiblas_internal_xerbla(SNAME, Info, len);\n}\nvoid xerbla(char *SNAME, Int *Info, Int len) {\n\tflexiblas_internal_xerbla(SNAME, Info, len);\n}\n#endif\n#endif\n\n\nint __flexiblas_setup_xerbla(flexiblas_backend_t *backend)\n{\n#ifndef __WIN32__\n\t/* Check if the user supplied a XERBLA function  */\n\t{\n        int user_xerbla = 0;\n\t\tvoid *xerbla_symbol1 = dlsym(backend->library_handle,\"xerbla_\");\n\t\tvoid *xerbla_symbol2 = dlsym(RTLD_DEFAULT,\"xerbla_\");\n\t\tvoid *internal = (void*) &flexiblas_internal_xerbla;\n\t\tDPRINTF(1, \"Available XERBLA ( backend: 0x%lx, user defined: 0x%lx, FlexiBLAS: 0x%lx )\\n\",\n\t\t\t\t(unsigned long)((void*)xerbla_symbol1),\n\t\t\t\t(unsigned long)((void*)xerbla_symbol2),\n\t\t\t\t(unsigned long)((void*)&flexiblas_internal_xerbla));\n\n\t\tif (internal == xerbla_symbol2) {\n\t\t\tuser_xerbla = 0;\n\t\t} else {\n\t\t\tuser_xerbla = 1;\n\t\t}\n\n\t\tif ( user_xerbla == 0 ){\n\t\t\tif (__flexiblas_verbose > 0 ) {\n\t\t\t\tfprintf(stderr, \"<\" PRINT_PREFIX \"> Use XERBLA of the BLAS backend.\\n\");\n\t\t\t}\n\t\t\tbackend->xerbla.f77_blas_function = xerbla_symbol1;\n\t\t} else {\n\t\t\tif (__flexiblas_verbose > 0 ) {\n\t\t\t\tfprintf(stderr, PRINT_PREFIX \"Use XERBLA supplied by the user.\\n\");\n\t\t\t}\n\t\t\tbackend->xerbla.f77_blas_function = xerbla_symbol2;\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\n#ifdef FLEXIBLAS_CBLAS\nextern void internal_cblas_xerbla(int info, const char *rout, const char *form, ...);\n\nint __flexiblas_setup_cblas_xerbla(flexiblas_backend_t *backend)\n{\n#ifndef __WIN32__\n\t/* Check if the user supplied a XERBLA function  */\n\t{\n        int user_xerbla = 0;\n\t\tvoid *xerbla_symbol1 = dlsym(backend->library_handle,\"cblas_xerbla\");\n\t\tvoid *xerbla_symbol2 = dlsym(RTLD_DEFAULT,\"cblas_xerbla\");\n\t\tvoid *internal = (void*) &flexiblas_internal_xerbla;\n\t\tDPRINTF(1, \"Available CBLAS_XERBLA ( backend: 0x%lx, user defined: 0x%lx, FlexiBLAS: 0x%lx )\\n\",\n\t\t\t\t(unsigned long)((void*)xerbla_symbol1),\n\t\t\t\t(unsigned long)((void*)xerbla_symbol2),\n\t\t\t\t(unsigned long)((void*)&internal_cblas_xerbla));\n\n\t\tif (internal == xerbla_symbol2) {\n\t\t\tuser_xerbla = 0;\n\t\t} else {\n\t\t\tuser_xerbla = 1;\n\t\t}\n\n\t\tif ( user_xerbla == 0 ){\n\t\t\tif (__flexiblas_verbose > 0 ) {\n\t\t\t\tfprintf(stderr, \"<\" PRINT_PREFIX \"> Use XERBLA of the BLAS backend.\\n\");\n\t\t\t}\n\t\t\tbackend->xerbla.cblas_function = xerbla_symbol1;\n\t\t} else {\n\t\t\tif (__flexiblas_verbose > 0 ) {\n\t\t\t\tfprintf(stderr, PRINT_PREFIX \"Use XERBLA supplied by the user.\\n\");\n\t\t\t}\n\t\t\tbackend->xerbla.cblas_function = xerbla_symbol2;\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\n\n\n#endif\n\nvoid flexiblas_internal_xerbla(char *SNAME, Int *Info, Int len)  {\n\tvoid (*fn) (char *SNAME, Int *info, Int len)  ;\n\tfn = current_backend->xerbla.f77_blas_function;\n\n\tif ( fn == NULL ) {\n\t\tint _info = (int) *Info;\n\t\tchar * ptr = malloc ( sizeof(char) * (len + 1));\n\t\tstrncpy(ptr, SNAME, len);\n\t\tptr[len] = '\\0';\n\t\tfprintf(stderr,\"XERBLA: Parameter %d was incorrect on entry to %s\\n\", _info , ptr);\n\t\tfree(ptr);\n\t\treturn;\n\t}\n\tfn (SNAME, Info, len);\n\treturn;\n}\n\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/src/flexiblas_api_standalone.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Linking FlexiBLAS statically or dynamically with other modules is making a\n * combined work based on FlexiBLAS. Thus, the terms and conditions of the GNU\n * General Public License cover the whole combination.\n *\n * As a special exception, the copyright holders of FlexiBLAS give you permission\n * to combine FlexiBLAS program with free software programs or libraries that are\n * released under the GNU LGPL and with independent modules that communicate with\n * FlexiBLAS solely through the BLAS/LAPACK interface as provided by the\n * BLAS/LAPACK reference implementation. You may copy and distribute such a system\n * following the terms of the GNU GPL for FlexiBLAS and the licenses of the other\n * code concerned, provided that you include the source code of that other code\n * when and as the GNU GPL requires distribution of source code and provided that\n * you do not modify the BLAS/LAPACK interface.\n *\n * Note that people who make modified versions of FlexiBLAS are not obligated to\n * grant this special exception for their modified versions; it is their choice\n * whether to do so. The GNU General Public License gives permission to release a\n * modified version without this exception; this exception also makes it possible\n * to release a modified version which carries forward this exception. If you\n * modify the BLAS/LAPACK interface, this exception does not apply to your\n * modified version of FlexiBLAS, and you must remove this exception when you\n * distribute your modified version.\n *\n * This exception is an additional permission under section 7 of the GNU General\n * Public License, version 3 (\u201cGPLv3\u201d)\n *\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2013-2020\n */\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <dlfcn.h>\n#ifndef RTLD_NEXT\n# define RTLD_NEXT  ((void *) -1l)\n#endif\n#ifndef RTLD_DEFAULT\n#define  RTLD_DEFAULT   ((void *) 0)\n#endif\n\n#include \"flexiblas_api.h\"\n\n\n\nint flexiblas_avail()\n{\n    int (*fnptr) ();\n    void *ptr_next    = dlsym(RTLD_NEXT, \"flexiblas_avail\");\n    void *ptr_default = dlsym(RTLD_DEFAULT, \"flexiblas_avail\");\n    void *ptr_self = &flexiblas_avail;\n\n    // printf(\"next: %lx \\t default: %lx \\t self: %lx\\n\", ptr_next, ptr_default, ptr_self);\n\n    /*  -lflexiblas_api -lflexiblas */\n    if ( ptr_next != NULL && ptr_next != ptr_self) {\n        fnptr = ptr_next;\n    }\n    /*   -lflexiblas -lflexiblas_api */\n    else if ( ptr_default != NULL && ptr_default != ptr_self) {\n        fnptr = ptr_default;\n    }\n    else {\n        return 0;\n    }\n    return fnptr();\n}\n\nint flexiblas_get_color_output() {\n    int (*fnptr)();\n    void *ptr_next    = dlsym(RTLD_NEXT, \"flexiblas_get_color_output\");\n    void *ptr_default = dlsym(RTLD_DEFAULT, \"flexiblas_get_color_output\");\n    void *ptr_self = &flexiblas_get_color_output;\n\n    /*  -lflexiblas_api -lflexiblas */\n    if ( ptr_next != NULL && ptr_next != ptr_self) {\n        fnptr = ptr_next;\n    }\n    /*   -lflexiblas -lflexiblas_api */\n    else if ( ptr_default != NULL && ptr_default != ptr_self) {\n        fnptr = ptr_default;\n    }\n    else {\n        return 0;\n    }\n    return fnptr();\n}\n\nvoid flexiblas_set_color_output(int s) {\n    void (*fnptr)(int);\n    void *ptr_next    = dlsym(RTLD_NEXT, \"flexiblas_set_color_output\");\n    void *ptr_default = dlsym(RTLD_DEFAULT, \"flexiblas_set_color_output\");\n    void *ptr_self = &flexiblas_get_color_output;\n\n    /*  -lflexiblas_api -lflexiblas */\n    if ( ptr_next != NULL && ptr_next != ptr_self) {\n        fnptr = ptr_next;\n    }\n    /*   -lflexiblas -lflexiblas_api */\n    else if ( ptr_default != NULL && ptr_default != ptr_self) {\n        fnptr = ptr_default;\n    }\n    else {\n        return ;\n    }\n    fnptr(s);\n    return;\n}\n\nvoid flexiblas_get_version(int *major, int *minor, int *patch)\n{\n    void (*fnptr) (int *, int*, int *);\n    void *ptr_next    = dlsym(RTLD_NEXT, \"flexiblas_get_version\");\n    void *ptr_default = dlsym(RTLD_DEFAULT, \"flexiblas_get_version\");\n    void *ptr_self = &flexiblas_get_version;\n\n    // printf(\"next: %lx \\t default: %lx \\t self: %lx\\n\", ptr_next, ptr_default, ptr_self);\n\n    /*  -lflexiblas_api -lflexiblas */\n    if ( ptr_next != NULL && ptr_next != ptr_self) {\n        fnptr = ptr_next;\n    }\n    /*   -lflexiblas -lflexiblas_api */\n    else if ( ptr_default != NULL && ptr_default != ptr_self) {\n        fnptr = ptr_default;\n    }\n    else {\n        *major = -1;\n        *minor = -1;\n        *patch = -1;\n        return ;\n    }\n    fnptr(major, minor, patch);\n    return;\n}\n\nvoid flexiblas_print_loaded_backends(FILE *fp)\n{\n    void (*fnptr) (FILE *);\n    void *ptr_next    = dlsym(RTLD_NEXT, \"flexiblas_print_loaded_backends\");\n    void *ptr_default = dlsym(RTLD_DEFAULT, \"flexiblas_print_loaded_backends\");\n    void *ptr_self = &flexiblas_print_loaded_backends;\n\n    // printf(\"next: %lx \\t default: %lx \\t self: %lx\\n\", ptr_next, ptr_default, ptr_self);\n\n    /*  -lflexiblas_api -lflexiblas */\n    if ( ptr_next != NULL && ptr_next != ptr_self) {\n        fnptr = ptr_next;\n    }\n    /*   -lflexiblas -lflexiblas_api */\n    else if ( ptr_default != NULL && ptr_default != ptr_self) {\n        fnptr = ptr_default;\n    }\n    else {\n        return ;\n    }\n    fnptr(fp);\n    return;\n\n}\n\nvoid flexiblas_print_avail_backends(FILE *fp)\n{\n    void (*fnptr) (FILE *);\n    void *ptr_next    = dlsym(RTLD_NEXT, \"flexiblas_print_avail_backends\");\n    void *ptr_default = dlsym(RTLD_DEFAULT, \"flexiblas_print_avail_backends\");\n    void *ptr_self = &flexiblas_print_avail_backends;\n\n    // printf(\"next: %lx \\t default: %lx \\t self: %lx\\n\", ptr_next, ptr_default, ptr_self);\n\n    /*  -lflexiblas_api -lflexiblas */\n    if ( ptr_next != NULL && ptr_next != ptr_self) {\n        fnptr = ptr_next;\n    }\n    /*   -lflexiblas -lflexiblas_api */\n    else if ( ptr_default != NULL && ptr_default != ptr_self) {\n        fnptr = ptr_default;\n    }\n    else {\n        return ;\n    }\n    fnptr(fp);\n    return;\n\n}\n\nvoid flexiblas_print_current_backend(FILE* fp)\n{\n    void (*fnptr) (FILE *);\n    void *ptr_next    = dlsym(RTLD_NEXT, \"flexiblas_print_current_backend\");\n    void *ptr_default = dlsym(RTLD_DEFAULT, \"flexiblas_print_current_backend\");\n    void *ptr_self = &flexiblas_print_current_backend;\n\n    // printf(\"next: %lx \\t default: %lx \\t self: %lx\\n\", ptr_next, ptr_default, ptr_self);\n\n    /*  -lflexiblas_api -lflexiblas */\n    if ( ptr_next != NULL && ptr_next != ptr_self) {\n        fnptr = ptr_next;\n    }\n    /*   -lflexiblas -lflexiblas_api */\n    else if ( ptr_default != NULL && ptr_default != ptr_self) {\n        fnptr = ptr_default;\n    }\n    else {\n        return ;\n    }\n    fnptr(fp);\n    return;\n\n}\n\n/* Handle Backends  */\nssize_t flexiblas_list(char *name, const size_t len, const ssize_t pos)\n{\n    ssize_t (*fnptr) (char *, size_t, ssize_t);\n    void *ptr_next    = dlsym(RTLD_NEXT, \"flexiblas_list\");\n    void *ptr_default = dlsym(RTLD_DEFAULT, \"flexiblas_list\");\n    void *ptr_self = &flexiblas_list;\n\n    // printf(\"next: %lx \\t default: %lx \\t self: %lx\\n\", ptr_next, ptr_default, ptr_self);\n\n    /*  -lflexiblas_api -lflexiblas */\n    if ( ptr_next != NULL && ptr_next != ptr_self) {\n        fnptr = ptr_next;\n    }\n    /*   -lflexiblas -lflexiblas_api */\n    else if ( ptr_default != NULL && ptr_default != ptr_self) {\n        fnptr = ptr_default;\n    }\n    else {\n        return -1;\n    }\n    return fnptr(name, len, pos);\n}\n\nssize_t flexiblas_list_loaded(char *name, size_t len, ssize_t pos)\n{\n    ssize_t (*fnptr) (char *, size_t, ssize_t);\n    void *ptr_next    = dlsym(RTLD_NEXT, \"flexiblas_list_loaded\");\n    void *ptr_default = dlsym(RTLD_DEFAULT, \"flexiblas_list_loaded\");\n    void *ptr_self = &flexiblas_list_loaded;\n\n    // printf(\"next: %lx \\t default: %lx \\t self: %lx\\n\", ptr_next, ptr_default, ptr_self);\n\n    /*  -lflexiblas_api -lflexiblas */\n    if ( ptr_next != NULL && ptr_next != ptr_self) {\n        fnptr = ptr_next;\n    }\n    /*   -lflexiblas -lflexiblas_api */\n    else if ( ptr_default != NULL && ptr_default != ptr_self) {\n        fnptr = ptr_default;\n    }\n    else {\n        return -1;\n    }\n    return fnptr(name, len, pos);\n\n}\n\nint flexiblas_load_backend(const char * name )\n{\n    int (*fnptr) (const char *);\n    void *ptr_next    = dlsym(RTLD_NEXT, \"flexiblas_load_backend\");\n    void *ptr_default = dlsym(RTLD_DEFAULT, \"flexiblas_load_backend\");\n    void *ptr_self = &flexiblas_load_backend;\n\n    // printf(\"next: %lx \\t default: %lx \\t self: %lx\\n\", ptr_next, ptr_default, ptr_self);\n\n    /*  -lflexiblas_api -lflexiblas */\n    if ( ptr_next != NULL && ptr_next != ptr_self) {\n        fnptr = ptr_next;\n    }\n    /*   -lflexiblas -lflexiblas_api */\n    else if ( ptr_default != NULL && ptr_default != ptr_self) {\n        fnptr = ptr_default;\n    }\n    else {\n        return -1;\n    }\n    return fnptr(name);\n}\n\nint flexiblas_load_backend_library(const char *libname)\n{\n    int (*fnptr) (const char *);\n    void *ptr_next    = dlsym(RTLD_NEXT, \"flexiblas_load_backend_library\");\n    void *ptr_default = dlsym(RTLD_DEFAULT, \"flexiblas_load_backend_library\");\n    void *ptr_self = &flexiblas_load_backend_library;\n\n    // printf(\"next: %lx \\t default: %lx \\t self: %lx\\n\", ptr_next, ptr_default, ptr_self);\n\n    /*  -lflexiblas_api -lflexiblas */\n    if ( ptr_next != NULL && ptr_next != ptr_self) {\n        fnptr = ptr_next;\n    }\n    /*   -lflexiblas -lflexiblas_api */\n    else if ( ptr_default != NULL && ptr_default != ptr_self) {\n        fnptr = ptr_default;\n    }\n    else {\n        return -1;\n    }\n    return fnptr(libname);\n\n}\n\nint flexiblas_switch(int id)\n{\n    int (*fnptr) (int);\n    void *ptr_next    = dlsym(RTLD_NEXT, \"flexiblas_switch\");\n    void *ptr_default = dlsym(RTLD_DEFAULT, \"flexiblas_switch\");\n    void *ptr_self = &flexiblas_switch;\n\n    // printf(\"next: %lx \\t default: %lx \\t self: %lx\\n\", ptr_next, ptr_default, ptr_self);\n\n    /*  -lflexiblas_api -lflexiblas */\n    if ( ptr_next != NULL && ptr_next != ptr_self) {\n        fnptr = ptr_next;\n    }\n    /*   -lflexiblas -lflexiblas_api */\n    else if ( ptr_default != NULL && ptr_default != ptr_self) {\n        fnptr = ptr_default;\n    }\n    else {\n        return -1;\n    }\n    return fnptr(id);\n\n}\n\nint flexiblas_current_backend(char *name, size_t len)\n{\n    int (*fnptr) (char *, size_t);\n    void *ptr_next    = dlsym(RTLD_NEXT, \"flexiblas_current_backend\");\n    void *ptr_default = dlsym(RTLD_DEFAULT, \"flexiblas_current_backend\");\n    void *ptr_self = &flexiblas_current_backend;\n\n    // printf(\"next: %lx \\t default: %lx \\t self: %lx\\n\", ptr_next, ptr_default, ptr_self);\n\n    /*  -lflexiblas_api -lflexiblas */\n    if ( ptr_next != NULL && ptr_next != ptr_self) {\n        fnptr = ptr_next;\n    }\n    /*   -lflexiblas -lflexiblas_api */\n    else if ( ptr_default != NULL && ptr_default != ptr_self) {\n        fnptr = ptr_default;\n    }\n    else {\n        return -1;\n    }\n    return fnptr(name,len);\n\n}\n\n/* Set number of threads  */\nvoid flexiblas_set_num_threads(int num)\n{\n    int (*fnptr) (int);\n    void *ptr_next    = dlsym(RTLD_NEXT, \"flexiblas_set_num_threads\");\n    void *ptr_default = dlsym(RTLD_DEFAULT, \"flexiblas_set_num_threads\");\n    void *ptr_self = &flexiblas_set_num_threads;\n\n    // printf(\"next: %lx \\t default: %lx \\t self: %lx\\n\", ptr_next, ptr_default, ptr_self);\n\n    /*  -lflexiblas_api -lflexiblas */\n    if ( ptr_next != NULL && ptr_next != ptr_self) {\n        fnptr = ptr_next;\n    }\n    /*   -lflexiblas -lflexiblas_api */\n    else if ( ptr_default != NULL && ptr_default != ptr_self) {\n        fnptr = ptr_default;\n    }\n    else {\n        return;\n    }\n    fnptr(num);\n    return;\n\n}\n\nvoid flexiblas_set_num_threads_(int* num)\n{\n    flexiblas_set_num_threads(*num);\n}\n\nvoid openblas_set_num_threads(int num)\n{\n    flexiblas_set_num_threads(num);\n}\n\nvoid openblas_set_num_threads_(int* num)\n{\n    flexiblas_set_num_threads(*num);\n}\n\nvoid mkl_set_num_threads(int num)\n{\n    flexiblas_set_num_threads(num);\n}\n\nvoid mkl_set_num_threads_(int* num)\n{\n    flexiblas_set_num_threads(*num);\n}\n\nvoid blas_set_num_threads(int num)\n{\n    flexiblas_set_num_threads(num);\n}\n\nvoid blas_set_num_threads_(int* num)\n{\n    flexiblas_set_num_threads(*num);\n\n}\n\nvoid acmlsetnumthreads(int num)\n{\n    flexiblas_set_num_threads(num);\n}\n\nvoid acmlsetnumthreads_(int* num)\n{\n    flexiblas_set_num_threads(*num);\n}\n\n/* Get number of threads  */\nint flexiblas_get_num_threads()\n{\n    int (*fnptr) ();\n    void *ptr_next    = dlsym(RTLD_NEXT, \"flexiblas_get_num_threads\");\n    void *ptr_default = dlsym(RTLD_DEFAULT, \"flexiblas_get_num_threads\");\n    void *ptr_self = &flexiblas_get_num_threads;\n\n    // printf(\"next: %lx \\t default: %lx \\t self: %lx\\n\", ptr_next, ptr_default, ptr_self);\n\n    /*  -lflexiblas_api -lflexiblas */\n    if ( ptr_next != NULL && ptr_next != ptr_self) {\n        fnptr = ptr_next;\n    }\n    /*   -lflexiblas -lflexiblas_api */\n    else if ( ptr_default != NULL && ptr_default != ptr_self) {\n        fnptr = ptr_default;\n    }\n    else {\n        return 1;\n    }\n    return fnptr();\n\n\n}\n\nint flexiblas_get_num_threads_()\n{\n    return flexiblas_get_num_threads();\n}\n\nint openblas_get_num_threads()\n{\n    return flexiblas_get_num_threads();\n}\n\nint openblas_get_num_threads_()\n{\n    return flexiblas_get_num_threads();\n}\n\nint mkl_get_num_threads()\n{\n    return flexiblas_get_num_threads();\n}\n\nint mkl_get_num_threads_()\n{\n    return flexiblas_get_num_threads();\n}\n\nint blas_get_num_threads()\n{\n    return flexiblas_get_num_threads();\n}\n\nint blas_get_num_threads_()\n{\n    return flexiblas_get_num_threads();\n}\n\nint acmlgetnumthreads()\n{\n    return flexiblas_get_num_threads();\n}\n\nint acmlgetnumthreads_()\n{\n    return flexiblas_get_num_threads();\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/src/hooks.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Linking FlexiBLAS statically or dynamically with other modules is making a\n * combined work based on FlexiBLAS. Thus, the terms and conditions of the GNU\n * General Public License cover the whole combination.\n *\n * As a special exception, the copyright holders of FlexiBLAS give you permission\n * to combine FlexiBLAS program with free software programs or libraries that are\n * released under the GNU LGPL and with independent modules that communicate with\n * FlexiBLAS solely through the BLAS/LAPACK interface as provided by the\n * BLAS/LAPACK reference implementation. You may copy and distribute such a system\n * following the terms of the GNU GPL for FlexiBLAS and the licenses of the other\n * code concerned, provided that you include the source code of that other code\n * when and as the GNU GPL requires distribution of source code and provided that\n * you do not modify the BLAS/LAPACK interface.\n *\n * Note that people who make modified versions of FlexiBLAS are not obligated to\n * grant this special exception for their modified versions; it is their choice\n * whether to do so. The GNU General Public License gives permission to release a\n * modified version without this exception; this exception also makes it possible\n * to release a modified version which carries forward this exception. If you\n * modify the BLAS/LAPACK interface, this exception does not apply to your\n * modified version of FlexiBLAS, and you must remove this exception when you\n * distribute your modified version.\n *\n * This exception is an additional permission under section 7 of the GNU General\n * Public License, version 3 (\u201cGPLv3\u201d)\n *\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2013-2020\n */\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <dlfcn.h>\n#include <ctype.h>\n\n#include \"cscutils/map.h\"\n\n#include \"flexiblas_backend.h\"\n#include \"hooks.h\"\n#include \"paths.h\"\n#include \"helper.h\"\n\nstatic csc_map_t * hook_map = NULL;\n\n\nHIDDEN void __flexiblas_list_hooks()\n{\n\n    int i ;\n    char *curpath;\n    DIR* folder;\n    struct dirent *dir_entry;\n    size_t len = strlen(\"libflexiblas_hook\");\n    struct stat st;\n    char *curfn;\n    size_t curfnl;\n    void * handle;\n    flexiblas_hook_register_t *reg;\n    flexiblas_option_t *opts;\n\n    for (i = 0; i < __flexiblas_count_additional_paths; i++) {\n        curpath = __flexiblas_additional_paths[i];\n\n        DPRINTF(0,\"Search in: %s\\n\", curpath);\n        folder = opendir(curpath);\n        if (!folder) continue;\n\n        while ((dir_entry = readdir(folder)) != NULL) {\n            if ( strncmp(dir_entry->d_name, \"..\", 2) == 0 ) continue;\n            if ( strncmp(dir_entry->d_name, \".\", 1) == 0 ) continue;\n            if ( strncmp(dir_entry->d_name, \"libflexiblas_hook\", len) != 0 ) continue;\n\n            curfnl  = (strlen(curpath) + strlen(dir_entry->d_name) + 5);\n            curfn = malloc(sizeof(char) * curfnl);\n\n            snprintf(curfn, curfnl, \"%s/%s\", curpath, dir_entry->d_name);\n            memset(&st, 0, sizeof(struct stat));\n            if ( stat(curfn, &st)) continue;\n            if ( ! ( S_ISREG(st.st_mode))) continue;\n\n            printf(\"%s\\n\", curfn);\n\n            handle  = __flexiblas_dlopen(curfn, RTLD_LAZY | RTLD_LOCAL , NULL);\n            if ( !handle) continue;\n\n            reg = dlsym(handle,\"flexiblas_register\");\n            if ( !reg ) {\n                DPRINTF(0, \"%s is not a hook\\n\");\n                dlclose(handle);\n                continue;\n            }\n\n            printf(\"Hook %s\\n\", curfn);\n            printf(\"-> Name:     %s\\n\", reg->name);\n            printf(\"-> Cfg-Name: %s\\n\", reg->cfg_name);\n            printf(\"-> Descr:    %s\\n\", reg->desc);\n            printf(\"-> Authors:  %s\\n\", reg->authors);\n\n            opts = dlsym(handle, \"flexiblas_options\");\n            if ( !opts) {\n                dlclose(handle);\n                continue;\n            }\n\n            while ( opts->name != NULL) {\n                printf(\"opts->name: %s\\n\", opts->name);\n                opts = opts + 1;\n\n            }\n\n\n            dlclose(handle);\n        }\n\n        closedir(folder);\n    }\n\n}\n\nstatic char *__struppercase(char *str) {\n\tchar *ret = str;\n\tif ( str == NULL ) return NULL;\n\twhile (*str != '\\0') {\n\t\t*str = toupper(*str);\n\t\tstr++;\n\t}\n\treturn ret;\n}\n\n\nHIDDEN void __flexiblas_add_hooks()\n{\n\n    int i ;\n    char *curpath;\n    DIR* folder;\n    struct dirent *dir_entry;\n    size_t len = strlen(\"libflexiblas_hook\");\n    struct stat st;\n    char *curfn;\n    size_t curfnl;\n    void * handle;\n    flexiblas_hook_register_t *reg;\n\n    hook_map = csc_map_new_string_key(257,free);\n\n    for (i = 0; i < __flexiblas_count_additional_paths; i++) {\n        curpath = __flexiblas_additional_paths[i];\n\n        folder = opendir(curpath);\n        if (!folder) continue;\n\n        while ((dir_entry = readdir(folder)) != NULL) {\n            if ( strncmp(dir_entry->d_name, \"..\", 2) == 0 ) continue;\n            if ( strncmp(dir_entry->d_name, \".\", 1) == 0 ) continue;\n            if ( strncmp(dir_entry->d_name, \"libflexiblas_hook\", len) != 0 ) continue;\n\n            curfnl  = (strlen(curpath) + strlen(dir_entry->d_name) + 5);\n            curfn = malloc(sizeof(char) * curfnl);\n\n            snprintf(curfn, curfnl, \"%s/%s\", curpath, dir_entry->d_name);\n            memset(&st, 0, sizeof(struct stat));\n            if ( stat(curfn, &st)) continue;\n            if ( ! ( S_ISREG(st.st_mode))) continue;\n\n            handle  = __flexiblas_dlopen(curfn, RTLD_LAZY | RTLD_LOCAL , NULL);\n            if ( !handle) continue;\n\n\n            reg = dlsym(handle,\"flexiblas_register\");\n            if ( !reg ) {\n                DPRINTF(1, \"%s is not a hook\\n\", dir_entry->d_name);\n                dlclose(handle);\n                continue;\n            }\n\n            DPRINTF(1, \"Hook \\\"%s/%s\\\" found in %s\\n\", reg->name, reg->cfg_name, curfn);\n            char * insert_str = __struppercase(strdup(reg->cfg_name));\n            csc_map_insert(hook_map, insert_str, strdup(curfn));\n\n            free(curfn);\n            dlclose(handle);\n        }\n\n        closedir(folder);\n    }\n\n}\n\nHIDDEN char *  __flexiblas_hook_add_from_file(char *path)\n{\n    void * handle;\n    flexiblas_hook_register_t *reg;\n    char *ret;\n\n    handle  = __flexiblas_dlopen(path, RTLD_LAZY | RTLD_LOCAL , NULL);\n    if ( !handle) return NULL;\n\n    reg = dlsym(handle, \"flexiblas_register\");\n    if ( !reg ) return NULL;\n\n    ret = strdup(reg->cfg_name);\n\n    if ( csc_map_has_key(hook_map, reg->cfg_name)) {\n        DPRINTF_WARN(0, \"Hook %s from %s already exists in the configuration.\\n\", reg->cfg_name, path);\n        DPRINTF_WARN(0, \"The previously found hook (%s) will be replaced.\\n\", csc_map_get(hook_map, reg->cfg_name));\n        csc_map_replace(hook_map, reg->cfg_name, strdup(path));\n    } else {\n        csc_map_insert(hook_map, reg->cfg_name, strdup(path));\n    }\n\n    dlclose(handle);\n    return ret;\n}\n\nHIDDEN int __flexiblas_hook_exists(char *name)\n{\n    char *upper_name = __struppercase(strdup(name));\n    int ret = csc_map_has_key(hook_map, (void *) upper_name);\n    free(upper_name);\n    return ret;\n}\n\nHIDDEN char * __flexiblas_hook_sofile(char *name)\n{\n    if (__flexiblas_hook_exists(name)) {\n        return csc_map_get(hook_map, (void *) name);\n    } else {\n        return NULL;\n    }\n}\n\nHIDDEN void __flexiblas_exit_hook( )\n{\n    csc_map_free(hook_map);\n}\n\nHIDDEN void __flexiblas_hook_list(int *nelem, char ***list, char ***list2)\n{\n    int len;\n    char **ilist;\n    char **ilist2;\n    void *iter = NULL;\n    char *key;\n    int i = 0;\n\n    len = csc_map_len(hook_map);\n    ilist = (char * *) malloc(sizeof(char *) * (len));\n    if ( list2 != NULL) {\n        ilist2 = (char * *) malloc(sizeof(char *) * (len));\n    }\n\n    while ( (key = csc_map_iterate_key(hook_map, &iter)) != NULL) {\n        ilist[i] = strdup(key);\n        if (ilist2 !=NULL) {\n            ilist2[i] = strdup(csc_map_get(hook_map, key));\n        }\n        i++;\n    }\n\n    *nelem = len;\n    *list = ilist;\n    if ( list2 ) * list2=ilist2;\n    return;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/src/sh_utils.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Linking FlexiBLAS statically or dynamically with other modules is making a\n * combined work based on FlexiBLAS. Thus, the terms and conditions of the GNU\n * General Public License cover the whole combination.\n *\n * As a special exception, the copyright holders of FlexiBLAS give you permission\n * to combine FlexiBLAS program with free software programs or libraries that are\n * released under the GNU LGPL and with independent modules that communicate with\n * FlexiBLAS solely through the BLAS/LAPACK interface as provided by the\n * BLAS/LAPACK reference implementation. You may copy and distribute such a system\n * following the terms of the GNU GPL for FlexiBLAS and the licenses of the other\n * code concerned, provided that you include the source code of that other code\n * when and as the GNU GPL requires distribution of source code and provided that\n * you do not modify the BLAS/LAPACK interface.\n *\n * Note that people who make modified versions of FlexiBLAS are not obligated to\n * grant this special exception for their modified versions; it is their choice\n * whether to do so. The GNU General Public License gives permission to release a\n * modified version without this exception; this exception also makes it possible\n * to release a modified version which carries forward this exception. If you\n * modify the BLAS/LAPACK interface, this exception does not apply to your\n * modified version of FlexiBLAS, and you must remove this exception when you\n * distribute your modified version.\n *\n * This exception is an additional permission under section 7 of the GNU General\n * Public License, version 3 (\u201cGPLv3\u201d)\n *\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2013-2020\n */\n\n\n\n\n#ifndef _DEFAULT_SOURCE\n#define _DEFAULT_SOURCE\n#endif\n#ifndef _XOPEN_SOURCE\n#define _XOPEN_SOURCE 500\n#endif\n\n#include \"flexiblas.h\"\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#ifndef __WIN32__\n#define DLOPEN_FLAGS (RTLD_NOW|RTLD_LOCAL)\n#else\n#define DLOPEN_FLAGS (0)\n#include <windows.h>\n#endif\n\n/*-----------------------------------------------------------------------------\n *  Return true if it is an absolute path.\n *-----------------------------------------------------------------------------*/\nstatic int is_absolute(const char * path )\n{\n\tif ( path == NULL) return 0;\n#ifdef __WIN32__\n\tif (strlen(path) < 2 ) return 0;\n\tif (( tolower(path[0]) >= 'a' && tolower(path[0]) <= 'z' && path[1]==':')\n\t\t\t|| ((path[0] == '\\\\' ) && (path[1] == '\\\\'))) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n#else\n\tif ( ((char)path[0]) == '/' ) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n#endif\n}\n\n\n/*-----------------------------------------------------------------------------\n *  Return true if it is at least an relative path.\n *-----------------------------------------------------------------------------*/\nstatic int is_relative(const char * path)\n{\n\tif ( path == NULL) return 0;\n    if ( strstr(path,\"/\") != NULL) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic int file_exists(const char * path )\n{\n\tstruct stat st_buf;\n\tmemset (&st_buf, 0, sizeof(struct stat));\n\tif ( stat( path, &st_buf) == 0){\n\t\tif ( (S_ISREG(st_buf.st_mode) || S_ISLNK (st_buf.st_mode) )){\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nHIDDEN void * __flexiblas_dlopen( const char *libname, int flags, char ** sofile ){\n\tchar *path = NULL;\n\tchar *filepath = NULL;\n\tsize_t len;\n\tvoid *handle;\n\tint found = 0 ;\n\tint path_count = 0;\n\n    if (libname == NULL) return NULL;\n\n\n\tif ( strstr(libname,\"/\") == NULL ) {\n        for ( path_count = -1 ; path_count < __flexiblas_count_additional_paths; path_count++){\n            if ( path_count == -1 ) {\n                if ( access(libname, R_OK) == 0 ) {\n                    filepath = strdup(libname);\n                } else {\n                    continue;\n                }\n            } else {\n    \t\t\tpath =  __flexiblas_additional_paths[path_count];\n\t    \t\tlen = strlen(path) + strlen(libname) + 5;\n\t\t    \tfilepath = malloc(len * sizeof ( char ));\n\t\t\t    snprintf(filepath, len -1, \"%s/%s\", path, libname);\n            }\n\t\t\tDPRINTF(1, \"Check if shared libary exist: %s\\n\", filepath);\n            if ( file_exists(filepath) ){\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfree(filepath);\n\t\t\t\tfilepath = NULL;\n\t\t\t}\n\t\t}\n\t} else if (is_absolute(libname)) {\n\t\tif ( file_exists(libname) ) {\n\t\t\tfound = 1;\n\t\t\tfilepath = strdup( libname);\n\t\t}\n\t} else if ( is_relative(libname)) {\n\t\tlong path_max;\n\t\tchar * resolvepath;\n#ifdef PATH_MAX\n\t\tpath_max = PATH_MAX;\n#else\n\t\tpath_max = pathconf(path, _PC_PATH_MAX);\n\t\tif (path_max <= 0)\n\t\t\tpath_max = 32768;\n#endif\n\t\tresolvepath = calloc(path_max, sizeof(char));\n\n\t\tif ( realpath(libname, resolvepath) == NULL ) {\n\t\t\tDPRINTF_ERROR(0,\"Cannot determine type to the path: %s or file does not exists.\\n\",libname );\n\t\t\tfound = 0;\n\t\t\tif (filepath) free(filepath);\n\t\t\tfilepath = NULL;\n\t\t\tfree(resolvepath);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\tfilepath = strdup(resolvepath);\n\t\t\tfree(resolvepath);\n\t\t\t/* DPRINTF_ERROR(2, \"Filepath: %s\\n\",filepath ); */\n\t\t}\n\t\tif (file_exists(filepath) ) {\n\t\t\tfound = 1;\n\t\t}\n\t} else {\n\t\tDPRINTF_ERROR(0,\"Cannot determine type to the path: %s\\n\",libname );\n\n\t\tfound = 0;\n\t\tif (filepath) free(filepath);\n\t\tfilepath = NULL;\n\t}\n\n\n\tif( found ) {\n#ifdef __WIN32__\n\t\thandle = LoadLibrary(filepath);\n#else\n\t\tvoid * ld_flags_sym_global;\n\t\tvoid * ld_flags_sym_lazy;\n\t\tint32_t ld_flags_global;\n\t\tint32_t ld_flags_lazy;\n#ifdef __linux__\n\t\tvoid * ld_flags_sym_deep = NULL;\n\t\tint32_t ld_flags_deep = 0 ;\n#endif\n\t\tif ( flags < 0 ) {\n\t\t\tdlerror();\n\t\t\thandle = dlopen(filepath, RTLD_LAZY | RTLD_LOCAL);\n\t\t\tif (!handle) {\n\t\t\t\tDPRINTF_ERROR(0, \"Failed to load %s - error: %s \\n\", filepath, dlerror());\n\t\t\t\tif ( filepath) free(filepath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tld_flags_sym_global = dlsym(handle, \"flexiblas_ld_global\");\n\t\t\tif ( ld_flags_sym_global == NULL) {\n\t\t\t\tld_flags_global = 0;\n\t\t\t} else {\n\t\t\t\tld_flags_global = *((int32_t*) ld_flags_sym_global);\n\t\t\t}\n\n\t\t\tld_flags_sym_lazy = dlsym(handle, \"flexiblas_ld_lazy\");\n\t\t\tif ( ld_flags_sym_lazy == NULL) {\n\t\t\t\tld_flags_lazy = 0;\n\t\t\t} else {\n\t\t\t\tld_flags_lazy = *((int32_t*) ld_flags_sym_lazy);\n\t\t\t}\n#ifdef __linux__\n\t\t\tld_flags_sym_deep = dlsym(handle, \"flexiblas_ld_deep\");\n\t\t\tif ( ld_flags_sym_deep == NULL) {\n\t\t\t\tld_flags_deep = 0;\n\t\t\t} else {\n\t\t\t\tld_flags_deep = *((int32_t*) ld_flags_sym_deep);\n\t\t\t}\n#endif\n\t\t\tdlclose(handle);\n\n\t\t\tif ( ld_flags_global != 0 ) {\n\t\t\t\tflags = RTLD_GLOBAL;\n\t\t\t\tDPRINTF(1, \"Load backend with RTLD_GLOBAL\\n\");\n\t\t\t} else {\n\t\t\t\tflags = RTLD_LOCAL;\n\t\t\t}\n\n\t\t\tif ( ld_flags_lazy != 0 ) {\n\t\t\t\tflags |= RTLD_LAZY;\n\t\t\t\tDPRINTF(1, \"Load backend with RTLD_LAZY\\n\");\n\t\t\t} else {\n\t\t\t\tflags |= RTLD_NOW;\n\t\t\t}\n\n#ifdef __linux__\n\t\t\tif ( ld_flags_deep != 0 ) {\n\t\t\t\tflags |= RTLD_DEEPBIND;\n\t\t\t\tDPRINTF(1, \"Load backend with RTLD_DEEPBIND\\n\");\n\t\t\t}\n#endif\n/* #if ( defined(__powerpc__) || defined(__powerpc64__)) && !defined(__IBMC__)\n\t\t\tflags |= RTLD_DEEPBIND;\n#endif  */\n\t\t}\n\n\t\thandle = dlopen(filepath, flags);\n#endif\n\n\n\n\t\tif (handle == NULL){\n#ifdef __WIN32__\n\t\t\tDPRINTF_ERROR(0, \"Unable to load library: %s\\r\\n\", filepath);\n#else\n\t\t\tDPRINTF_ERROR(0, \"dlopen: %s\\n\", dlerror());\n#endif\n\t\t}\n\t\tif (sofile != NULL) {\n\t\t\t*sofile = strdup(filepath);\n\t\t}\n\t\tfree(filepath);\n\t\treturn handle;\n\t} else {\n\t\tif ( filepath) free(filepath);\n\t\treturn NULL;\n\t}\n}\n\nHIDDEN int __flexiblas_dl_symbol_exist( const char *libname, const char *symbol_name )\n{\n\tchar *path = NULL;\n\tchar *filepath = NULL;\n\tsize_t len;\n\tvoid *handle;\n\tint found = 0 ;\n\tint path_count = 0;\n\n    if (libname == NULL) return 0;\n\n\n\tif ( strstr(libname,\"/\") == NULL ) {\n        for ( path_count = -1 ; path_count < __flexiblas_count_additional_paths; path_count++){\n            if ( path_count == -1 ) {\n                if ( access(libname, R_OK) == 0 ) {\n                    filepath = strdup(libname);\n                } else {\n                    continue;\n                }\n            } else {\n    \t\t\tpath =  __flexiblas_additional_paths[path_count];\n\t    \t\tlen = strlen(path) + strlen(libname) + 5;\n\t\t    \tfilepath = malloc(len * sizeof ( char ));\n\t\t\t    snprintf(filepath, len -1, \"%s/%s\", path, libname);\n            }\n\t\t\tDPRINTF(1, \"Check if shared libary exist: %s\\n\", filepath);\n            if ( file_exists(filepath) ){\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfree(filepath);\n\t\t\t\tfilepath = NULL;\n\t\t\t}\n\t\t}\n\t} else if (is_absolute(libname)) {\n\t\tif ( file_exists(libname) ) {\n\t\t\tfound = 1;\n\t\t\tfilepath = strdup( libname);\n\t\t}\n\t} else if ( is_relative(libname)) {\n\t\tlong path_max;\n\t\tchar * resolvepath;\n#ifdef PATH_MAX\n\t\tpath_max = PATH_MAX;\n#else\n\t\tpath_max = pathconf(path, _PC_PATH_MAX);\n\t\tif (path_max <= 0)\n\t\t\tpath_max = 32768;\n#endif\n\t\tresolvepath = calloc(path_max, sizeof(char));\n\n\t\tif ( realpath(libname, resolvepath) == NULL ) {\n\t\t\tDPRINTF_ERROR(0,\"Cannot determine type to the path: %s or file does not exists.\\n\",libname );\n\t\t\tfound = 0;\n\t\t\tif (filepath) free(filepath);\n\t\t\tfilepath = NULL;\n\t\t\tfree(resolvepath);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tfilepath = strdup(resolvepath);\n\t\t\tfree(resolvepath);\n\t\t\t/* DPRINTF_ERROR(2, \"Filepath: %s\\n\",filepath ); */\n\t\t}\n\t\tif (file_exists(filepath) ) {\n\t\t\tfound = 1;\n\t\t}\n\t} else {\n\t\tDPRINTF_ERROR(0,\"Cannot determine type to the path: %s\\n\",libname );\n\n\t\tfound = 0;\n\t\tif (filepath) free(filepath);\n\t\tfilepath = NULL;\n\t}\n\n\n\tif( found ) {\n        void *sym = NULL;\n        dlerror();\n        handle = dlopen(filepath, RTLD_LAZY | RTLD_LOCAL);\n        if (!handle) {\n            DPRINTF_ERROR(0, \"Failed to load %s - error: %s \\n\", filepath, dlerror());\n            if ( filepath) free(filepath);\n            return 0;\n        }\n        sym = dlsym(handle, symbol_name);\n        dlclose(handle);\n       \tif ( filepath) free(filepath);\n        return (sym == NULL) ? 0 : 1;\n    }\n\tif ( filepath) free(filepath);\n    return 0;\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/src/flexiblas.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Linking FlexiBLAS statically or dynamically with other modules is making a\n * combined work based on FlexiBLAS. Thus, the terms and conditions of the GNU\n * General Public License cover the whole combination.\n *\n * As a special exception, the copyright holders of FlexiBLAS give you permission\n * to combine FlexiBLAS program with free software programs or libraries that are\n * released under the GNU LGPL and with independent modules that communicate with\n * FlexiBLAS solely through the BLAS/LAPACK interface as provided by the\n * BLAS/LAPACK reference implementation. You may copy and distribute such a system\n * following the terms of the GNU GPL for FlexiBLAS and the licenses of the other\n * code concerned, provided that you include the source code of that other code\n * when and as the GNU GPL requires distribution of source code and provided that\n * you do not modify the BLAS/LAPACK interface.\n *\n * Note that people who make modified versions of FlexiBLAS are not obligated to\n * grant this special exception for their modified versions; it is their choice\n * whether to do so. The GNU General Public License gives permission to release a\n * modified version without this exception; this exception also makes it possible\n * to release a modified version which carries forward this exception. If you\n * modify the BLAS/LAPACK interface, this exception does not apply to your\n * modified version of FlexiBLAS, and you must remove this exception when you\n * distribute your modified version.\n *\n * This exception is an additional permission under section 7 of the GNU General\n * Public License, version 3 (\u201cGPLv3\u201d)\n *\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2013-2020\n */\n\n\n\n#ifdef __linux__\n#define __GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include \"flexiblas.h\"\n#include <errno.h>\n#include <stddef.h>\n#include <string.h>\n#include <strings.h>\n#include \"cscutils/strutils.h\"\n#include \"paths.h\"\n#include \"hooks.h\"\n\n#define DLOPEN_FLAGS_FROM_FILE -1\n#ifndef __WIN32__\n#include <dlfcn.h>\n#ifdef __linux__\n// Linux\n// #define DLOPEN_FLAGS (RTLD_LAZY)\n#define DLOPEN_FLAGS RTLD_LOCAL|RTLD_NOW\n#else\n// BSD\n#define DLOPEN_FLAGS (RTLD_LOCAL|RTLD_NOW)\n#endif\n#else\n// Windows\n#define DLOPEN_FLAGS (0)\n#define strtok_r strtok_s\n#include <windows.h>\n#endif\n\n/*  Initialize global variables. */\nHIDDEN int __flexiblas_initialized = 0;\nHIDDEN int __flexiblas_profile = 0;\nHIDDEN flexiblas_backend_t *current_backend = NULL;\nHIDDEN flexiblas_backend_t **loaded_backends = NULL;\nHIDDEN size_t                  nloaded_backends = 0;\nHIDDEN flexiblas_mgmt_t *__flexiblas_mgmt = NULL;\nHIDDEN flexiblas_hook_t *__flexiblas_hooks = NULL;\n\nHIDDEN flexiblas_exit_function_t hook_exit = NULL;\n\nHIDDEN void *__flexiblas_blas_fallback = NULL;\n#ifdef FLEXIBLAS_LAPACK\nHIDDEN void *__flexiblas_lapack_fallback = NULL;\n#endif\n\n// #include \"lapack_interface/syms-3.6.1.c\"\n/*-----------------------------------------------------------------------------\n *  Convert Chars to Upper Case\n *-----------------------------------------------------------------------------*/\nstatic char *uppercase(char *str) {\n    char *ret = str;\n    if ( str == NULL ) return NULL;\n    while (*str != '\\0') {\n        *str = (char)toupper(*str);\n        str++;\n    }\n    return ret;\n}\n\n\n\n/*-----------------------------------------------------------------------------\n *  Default Info Structure if none is given\n *-----------------------------------------------------------------------------*/\nstatic void h_info_default(flexiblas_info_t *info) {\n    info->flexiblas_integer_size = sizeof(Int);\n    info->backend_integer_size = 0;\n    info->intel_interface = 0 ;\n    info->post_init = 0;\n}\n\n\n\n\n\n\n\n/*-----------------------------------------------------------------------------\n *  Init the backend.\n *-----------------------------------------------------------------------------*/\nHIDDEN void __flexiblas_backend_init( flexiblas_backend_t * backend) {\n    int load = 0;\n    int failed = 0;\n\n\n    if (backend == NULL) {\n        DPRINTF(0, PRINT_PREFIX \" No current BLAS is set.\\n\");\n        abort();\n    }\n    pthread_mutex_lock(&(backend->post_init_mutex));\n    if ( backend->post_init != 0 ) {\n        if (backend->init_function != NULL) {\n            if ( backend->init_function() != 0 ) {\n                DPRINTF(0, PRINT_PREFIX \" Initialization of the backend library \\\"%s\\\" failed. \\n\", backend->name);\n                abort();\n            }\n        }\n        /*-----------------------------------------------------------------------------\n         *  Load FBLAS\n         *-----------------------------------------------------------------------------*/\n        __flexiblas_load_fblas(backend, &load, &failed);\n\n        /*-----------------------------------------------------------------------------\n         *  Load CBLAS\n         *-----------------------------------------------------------------------------*/\n        __flexiblas_load_cblas(backend);\n\n#ifdef FLEXIBLAS_LAPACK\n        /*-----------------------------------------------------------------------------\n         *  Load LAPACK\n         *-----------------------------------------------------------------------------*/\n        int nolapack = 0;\n        flexiblas_mgmt_location_t loc;\n        if ( getenv(ENV_FLEXIBLAS_NOLAPACK)) {\n            nolapack = atoi(getenv(ENV_FLEXIBLAS_NOLAPACK));\n        } else {\n            flexiblas_mgmt_get_active_property(__flexiblas_mgmt, &loc, FLEXIBLAS_PROP_NOLAPACK, &nolapack);\n        }\n        if ( nolapack ) {\n            DPRINTF(1,\"LAPACK is load from the fallback only. No LAPACK routines from the backend will be used.\\n\");\n            __flexiblas_load_flapack_fallback(backend, &load, &failed);\n        } else {\n            __flexiblas_load_flapack(backend, &load, &failed);\n        }\n#endif\n\n        /* Setup XERBLA */\n        __flexiblas_setup_xerbla(backend);\n#ifdef FLEXIBLAS_CBLAS\n        __flexiblas_setup_cblas_xerbla(backend);\n#endif\n        backend->post_init = 0;\n    }\n\n\n    pthread_mutex_unlock(&(backend->post_init_mutex));\n\n    if ( failed > 0) {\n        DPRINTF_ERROR(0,\" Failed to load the backend completely, some BLAS functions are missing. Abort!\\n\");\n        abort();\n    }\n}\n\n\n\n/*-----------------------------------------------------------------------------\n *  Load the Info section from the Backend\n *-----------------------------------------------------------------------------*/\nstatic void flexiblas_load_info(void *library, flexiblas_backend_t *backend)\n{\n    memset(&(backend->info),0,sizeof(flexiblas_info_t));\n    backend->info.flexiblas_integer_size = sizeof(Int);\n#ifdef __WIN32__\n    backend->info_function = (flexiblas_info_function_t) GetProcAddress(library, FLEXIBLAS_INFO_FUNCTION_NAME );\n    backend->init_function = (flexiblas_init_function_t) GetProcAddress(library, FLEXIBLAS_INIT_FUNCTION_NAME);\n    backend->exit_function = (flexiblas_exit_function_t) GetProcAddress(library, FLEXIBLAS_EXIT_FUNCTION_NAME);\n#else\n    backend->info_function = (flexiblas_info_function_t) dlsym(library, FLEXIBLAS_INFO_FUNCTION_NAME);\n    backend->init_function = (flexiblas_init_function_t) dlsym(library, FLEXIBLAS_INIT_FUNCTION_NAME);\n    backend->exit_function = (flexiblas_exit_function_t) dlsym(library, FLEXIBLAS_EXIT_FUNCTION_NAME);\n#endif\n\n    backend->library_handle = library;\n\n    /* Load the Environment information function   */\n    __flexiblas_load_set_num_threads(backend);\n    __flexiblas_load_get_num_threads(backend);\n    if ( backend->info_function ) {\n        backend->info_function(&(backend->info));\n    } else {\n        DPRINTF(1,\"No BLAS Info found in given backend. Using default.\\n\");\n        h_info_default(&(backend->info));\n    }\n}\n\n/*-----------------------------------------------------------------------------\n *  Print the Basic BLAS info\n *-----------------------------------------------------------------------------*/\nstatic void print_info(flexiblas_backend_t *backend)\n{\n    DPRINTF(1,\"BLAS info:\\n\");\n    DPRINTF(1,\" - intel_interface        = %d\\n\",backend->info.intel_interface);\n    DPRINTF(1,\" - flexiblas_integer_size = %d\\n\",backend->info.flexiblas_integer_size);\n    DPRINTF(1,\" - backend_integer_size   = %d\\n\",backend->info.backend_integer_size);\n    DPRINTF(1,\" - post_init              = %d\\n\",backend->info.post_init);\n}\n\nstatic flexiblas_backend_t * flexiblas_load_library_from_init (flexiblas_mgmt_t *config, char *blas_default_map ) {\n    char *env_FLEXIBLAS = NULL;\n    flexiblas_backend_t *backend = NULL;\n    void *library = NULL;\n    char name[FLEXIBLAS_MGMT_MAX_BUFFER_LEN];\n    char blas_name[FLEXIBLAS_MGMT_MAX_BUFFER_LEN];\n\n    if ( getenv(ENV_FLEXIBLAS) == NULL) {\n        env_FLEXIBLAS = NULL;\n    } else {\n        env_FLEXIBLAS = strdup(getenv(ENV_FLEXIBLAS));\n    }\n    /*-----------------------------------------------------------------------------\n     *  Analyze the FLEXIBLAS environment variable\n     *-----------------------------------------------------------------------------*/\n    if (env_FLEXIBLAS== NULL) {\n        char clibrary[FLEXIBLAS_MGMT_MAX_BUFFER_LEN];\n        flexiblas_mgmt_location_t loc;\n\n        if ( flexiblas_mgmt_get_active_default(config, &loc, blas_name)) {\n\n            DPRINTF_ERROR(0,\"Failed to get the default backend. Reset to FALLBACK.\\n\");\n            strncpy(blas_name, \"__FALLBACK__\", FLEXIBLAS_MGMT_MAX_BUFFER_LEN);\n        }\n\n        if ( flexiblas_mgmt_blas_get2(config, &loc, blas_name, clibrary, NULL)) {\n            DPRINTF_ERROR(0, \"Failed to get the BLAS backend (%s) from the configuration.\\n\", blas_name);\n            abort();\n        }\n\n        DPRINTF(1,\"Use default BLAS: %s - %s from %s\\n\", blas_name, clibrary, flexiblas_mgmt_location_to_string(loc) );\n        library = __flexiblas_dlopen(clibrary, DLOPEN_FLAGS_FROM_FILE , NULL);\n        strncpy(name, blas_name, FLEXIBLAS_MGMT_MAX_BUFFER_LEN);\n\n    } else {\n        /*-----------------------------------------------------------------------------\n         *  Try to open env_FLEXIBLAS directly and the get the value from the Hashtable\n         *-----------------------------------------------------------------------------*/\n        DPRINTF(1,\"Trying to use the content of \" ENV_FLEXIBLAS \": \\\"%s\\\" as shared library.\\n\", env_FLEXIBLAS);\n        library = __flexiblas_dlopen(env_FLEXIBLAS, DLOPEN_FLAGS_FROM_FILE, NULL);\n        strncpy(name, env_FLEXIBLAS, FLEXIBLAS_MGMT_MAX_BUFFER_LEN);\n\n        /*  if env_FLEXIBLAS does not contain an .so file we look into the configuration  */\n        if ( library == NULL) {\n            char *clibrary = NULL;\n            flexiblas_mgmt_location_t loc;\n            char *tmp = strdup(env_FLEXIBLAS);\n            tmp = uppercase(tmp);\n            DPRINTF_WARN(1,\"\\\"%s\\\" does not seem to a shared library. Search inside the FlexiBLAS configuration..\\n\", tmp);\n\n            clibrary = (char*) malloc(sizeof(char)*32768);\n            if ( flexiblas_mgmt_blas_get2(config, &loc, tmp, clibrary, NULL)) {\n                free(clibrary);\n                clibrary = NULL;\n            }\n\n            /* Load the default BLAS if the env_FLEXIBLAS implementation was not found in the configuration */\n            if (clibrary == NULL ) {\n                if ( flexiblas_mgmt_get_active_default(config, &loc, blas_name)) {\n                    DPRINTF_ERROR(0,\"Failed to get the default backend. Reset to FALLBACK.\\n\");\n                    strncpy(blas_name, \"__FALLBACK__\", FLEXIBLAS_MGMT_MAX_BUFFER_LEN);\n                }\n                DPRINTF_ERROR(0, \"BLAS backend  \\\"%s\\\" not found. Loading default (%s) instead.\\n\", tmp, blas_name);\n\n                clibrary = (char*) malloc(sizeof(char)*32768);\n                if ( flexiblas_mgmt_blas_get2(config, &loc, blas_name, clibrary, NULL)) {\n                    DPRINTF_ERROR(0, \"Failed to get the BLAS backend (%s) from the configuration.\\n\", blas_name);\n                    abort();\n                }\n\n                strncpy(name, blas_name, FLEXIBLAS_MGMT_MAX_BUFFER_LEN);\n                free(tmp);\n                tmp = strdup(blas_name);\n            }\n\n            DPRINTF(1,\"Trying to load  %s\\n\", clibrary );\n            library  = __flexiblas_dlopen(clibrary, DLOPEN_FLAGS_FROM_FILE , NULL);\n            if ( clibrary != NULL) free(clibrary);\n            free(tmp);\n        }\n    }\n\n    /* Load FallBack if non of the previously opened libraries worked. */\n    if ( library == NULL ) {\n        char *clibrary = NULL;\n        flexiblas_mgmt_location_t loc;\n        DPRINTF(0, \"No suitable BLAS backend could be loaded. Trying Fallback instead.\\n\");\n        clibrary = (char* ) malloc(sizeof(char) * 32768);\n        if ( flexiblas_mgmt_blas_get2(config, &loc, \"__FALLBACK__\", clibrary, NULL)) {\n            DPRINTF_ERROR(0, \"Failed to get the BLAS backend (__FALLBACK__) from the configuration.\\n\");\n            library = NULL;\n        } else {\n            library = __flexiblas_dlopen(clibrary,DLOPEN_FLAGS_FROM_FILE , NULL);\n        }\n        free(clibrary);\n        strncpy(name, \"__FALLBACK__\", FLEXIBLAS_MGMT_MAX_BUFFER_LEN);\n    }\n\n    if ( library == NULL ) {\n        fprintf(stderr, PRINT_PREFIX \"Unable to open any BLAS library (choosen: %s). Abort!\\n\",\n                (env_FLEXIBLAS == NULL)?blas_default_map:env_FLEXIBLAS);\n        abort();\n        return NULL;\n    }\n\n    backend = (flexiblas_backend_t*) malloc(sizeof(flexiblas_backend_t));\n    if ( backend == NULL ) {\n        DPRINTF(0, \" Failed to allocate space for backend structure.\\n\");\n        return NULL;\n    }\n\n    memset((void*) backend, 0, sizeof(flexiblas_backend_t));\n    pthread_mutex_init(&(backend->post_init_mutex),NULL);\n\n    backend->library_handle = library;\n    backend->name = strdup(name);\n    uppercase(backend->name);\n\n    if ( env_FLEXIBLAS != NULL) {\n        free(env_FLEXIBLAS);\n    }\n\n    /* load info */\n    flexiblas_load_info(library, backend);\n\n    /*-----------------------------------------------------------------------------\n     *  Get the integer size of the backend if not already set\n     *-----------------------------------------------------------------------------*/\n    if ( backend->info.backend_integer_size == 0 ) {\n#ifdef FLEXIBLAS_INTEGER8\n        backend->info.backend_integer_size = sizeof(int64_t);\n#else\n        backend->info.backend_integer_size = sizeof(int32_t);\n#endif\n    }\n\n    backend->post_init =  backend->info.post_init;\n\n\n    backend->hook_init = 0;\n\n    if ( backend->post_init == 0 ) {\n        backend->post_init = 1;\n        __flexiblas_backend_init(backend);\n    } else {\n        DPRINTF(0, \"BLAS backend uses post initialization.\\n\");\n    }\n\n    print_info(backend);\n    return backend;\n}\n\n\n/*-----------------------------------------------------------------------------\n *  Load additional BLAS\n *-----------------------------------------------------------------------------*/\nstatic flexiblas_backend_t * __flexiblas_load_backend_from_config(const char *blas_name)\n{\n    flexiblas_backend_t *backend = NULL;\n    void *library = NULL;\n    char clibrary[FLEXIBLAS_MGMT_MAX_BUFFER_LEN];\n    flexiblas_mgmt_location_t loc;\n\n    if ( flexiblas_mgmt_blas_get2(__flexiblas_mgmt, &loc, blas_name, clibrary, NULL) != 0) {\n        DPRINTF_ERROR(0, \"BLAS %s not found in config.\\n\", blas_name);\n        return NULL;\n    }\n\n    DPRINTF(2, \" Try to load %s - %s\\n\", blas_name, clibrary);\n    library = __flexiblas_dlopen(clibrary, DLOPEN_FLAGS_FROM_FILE, (char **) NULL);\n\n    if ( library == NULL ) {\n        DPRINTF(2, \" failed.\\n\");\n        return NULL;\n    }\n\n    backend = (flexiblas_backend_t*) malloc(sizeof(flexiblas_backend_t));\n    if ( backend == NULL ){\n        DPRINTF(0, \" Failed to allocate space for backend structure.\\n\");\n        return NULL;\n    }\n    memset((void*) backend, 0, sizeof(flexiblas_backend_t));\n    pthread_mutex_init(&(backend->post_init_mutex),NULL);\n\n    backend->library_handle = library;\n    backend->name = strdup(blas_name);\n\n    /* load info */\n    flexiblas_load_info(library, backend);\n\n\n    /*-----------------------------------------------------------------------------\n     *  Get the integer size of the backend if not already set\n     *-----------------------------------------------------------------------------*/\n    if ( backend->info.backend_integer_size == 0 ) {\n#ifdef FLEXIBLAS_INTEGER8\n        backend->info.backend_integer_size = sizeof(int64_t);\n#else\n        backend->info.backend_integer_size = sizeof(int32_t);\n#endif\n    }\n    print_info(backend);\n\n    backend->post_init =  backend->info.post_init;\n    backend->hook_init =  0;\n\n\n    if ( backend->post_init == 0 ) {\n        backend->post_init = 1;\n        __flexiblas_backend_init(backend);\n    } else {\n        DPRINTF(0, \"BLAS backend %s uses post initialization.\\n\", blas_name);\n    }\n    return backend;\n}\n\n/*-----------------------------------------------------------------------------\n *  Load BLAS by name from config (API VERSION)\n *-----------------------------------------------------------------------------*/\nint flexiblas_load_backend(const char *name )\n{\n    flexiblas_backend_t * new_backend = NULL;\n    size_t i;\n\n    for (i = 0; i < nloaded_backends; i++) {\n        if ( csc_strcasecmp(name , loaded_backends[i]->name) == 0) {\n            /* Already loaded */\n            return (int)i;\n        }\n    }\n\n    DPRINTF(1,\"Backend %s not loaded until now. - %d \\n\", name, -1);\n    /* Not loaded */\n    new_backend = __flexiblas_load_backend_from_config(name);\t\t\t/* FIXME does accept const char* (yet) */\n    if ( new_backend != NULL ) {\n        size_t new_backend_pos = nloaded_backends;\n        flexiblas_backend_t ** new_loaded;\n        nloaded_backends++;\n        new_loaded  = realloc(loaded_backends, sizeof(flexiblas_backend_t*) * nloaded_backends);\n        if (new_loaded == NULL) {\n            DPRINTF(0, \"Failed to allocate memory to load the new backend. Abort\\n\");\n            abort();\n        } else {\n            loaded_backends = new_loaded;\n        }\n        loaded_backends[new_backend_pos] = new_backend;\n        // csc_ini_setinteger((csc_ini_file_t*) __flexiblas_mgmt->host_config, name, \"__loaded__\", new_backend_pos);\n        return (int)new_backend_pos;\n    }\n\n    /* Fails to load */\n    return -1;\n}\n\n\n\nstatic flexiblas_backend_t * __flexiblas_load_backend_from_file(const char *blas_sofile)\n{\n    flexiblas_backend_t *backend = NULL;\n    void *library = NULL;\n\n    DPRINTF(2, PRINT_PREFIX \" Try to load %s \\n\", blas_sofile);\n    library = __flexiblas_dlopen(blas_sofile, DLOPEN_FLAGS_FROM_FILE, (char **) NULL);\n\n    if ( library == NULL ) {\n        DPRINTF(2, PRINT_PREFIX \" failed.\\n\");\n        return NULL;\n    }\n\n    backend = (flexiblas_backend_t*) malloc(sizeof(flexiblas_backend_t));\n    if ( backend == NULL ){\n        DPRINTF(0, \" Failed to allocate space for backend structure.\\n\");\n        return NULL;\n    }\n    memset((void*) backend, 0, sizeof(flexiblas_backend_t));\n    pthread_mutex_init(&(backend->post_init_mutex),NULL);\n\n    backend->library_handle = library;\n    backend->name = strdup(blas_sofile);\n\n    /* load info */\n    flexiblas_load_info(library, backend);\n\n    /*-----------------------------------------------------------------------------\n     *  Get the integer size of the backend if not already set\n     *-----------------------------------------------------------------------------*/\n    if ( backend->info.backend_integer_size == 0 ) {\n        DPRINTF(0, \"BLAS %s does not provide an integer size hint. Assuming 4 Byte.\\n\", blas_sofile);\n        backend->info.backend_integer_size = sizeof(int32_t);\n    }\n    backend->post_init =  backend->info.post_init;\n    backend->hook_init =  0;\n\n\n    if ( backend->post_init == 0 ) {\n        backend->post_init = 1;\n        __flexiblas_backend_init(backend);\n    } else {\n        DPRINTF(0, \"BLAS backend %s uses post initialization.\\n\", blas_sofile);\n    }\n\n    print_info(backend);\n    return backend;\n}\n\n/*-----------------------------------------------------------------------------\n * Load backend from FILE (API VERSION)\n *-----------------------------------------------------------------------------*/\nint flexiblas_load_backend_library(const char *libname)\n{\n    flexiblas_backend_t * new_backend = NULL;\n    size_t i;\n\n    for (i = 0; i < nloaded_backends; i++) {\n        if ( csc_strcasecmp(libname , loaded_backends[i]->name) == 0) {\n            /* Already loaded */\n            return i;\n        }\n    }\n\n    DPRINTF(1,\"Backend %s not loaded until now. - %d \\n\", libname, -1);\n    /* Not loaded  */\n    new_backend = __flexiblas_load_backend_from_file(libname);\n    if ( new_backend != NULL ) {\n        size_t new_backend_pos = nloaded_backends;\n        flexiblas_backend_t **new_loaded;\n        nloaded_backends++;\n        new_loaded = realloc(loaded_backends, sizeof(flexiblas_backend_t*) * nloaded_backends);\n        if (new_loaded == NULL) {\n            DPRINTF(0, \"Failed to allocate memory to load the new backend. Abort\\n\");\n            abort();\n        } else {\n            loaded_backends = new_loaded;\n        }\n\n        loaded_backends[new_backend_pos] = new_backend;\n        // csc_ini_setinteger((csc_ini_file_t*) __flexiblas_mgmt->host_config, libname, \"__loaded__\", new_backend_pos);\n        return new_backend_pos;\n    }\n\n    /* Fails to load */\n    return -1;\n}\n\n\n/*-----------------------------------------------------------------------------\n *  Init Routine\n *-----------------------------------------------------------------------------*/\n#ifndef __WIN32__\n__attribute__((constructor))\n#endif\n    void flexiblas_init() {\n        char blas_default_map[FLEXIBLAS_MGMT_MAX_BUFFER_LEN] ;\n        char path[FLEXIBLAS_MGMT_MAX_BUFFER_LEN];\n        flexiblas_backend_t  *backend = NULL;\n        flexiblas_mgmt_location_t loc;\n\n        /*-----------------------------------------------------------------------------\n         *  Read Environment Variables\n         *-----------------------------------------------------------------------------*/\n        char *env_FLEXIBLAS_VERBOSE=getenv(ENV_FLEXIBLAS_VERBOSE);\n        char *env_FLEXIBLAS_COLOR_OUTPUT=getenv(ENV_FLEXIBLAS_COLOR_OUTPUT);\n        char *env_FLEXIBLAS_HOOK=getenv(ENV_FLEXIBLAS_HOOK);\n\n        if ( __flexiblas_initialized != 0) return;\n        __flexiblas_initialized = 1;\n        __flexiblas_mgmt_init = 1;\n\n        (void) flexiblas_verbosity();\n\n        /* Color Output */\n        if (env_FLEXIBLAS_COLOR_OUTPUT != NULL) {\n            int s = atoi(env_FLEXIBLAS_COLOR_OUTPUT);\n            flexiblas_set_color_output(s);\n        }\n        /* Load environemt variables   */\n        if ( env_FLEXIBLAS_VERBOSE != NULL ) {\n            __flexiblas_verbose = atoi(env_FLEXIBLAS_VERBOSE);\n        }\n\n        memset(path, '\\0', FLEXIBLAS_MGMT_MAX_BUFFER_LEN);\n        /*-----------------------------------------------------------------------------\n         *  Read mapping file\n         *  1. /etc/flexiblasrc  or its counterpart in the build directory\n         *  3. $HOME/.flexiblasrc\n         *-----------------------------------------------------------------------------*/\n        __flexiblas_mgmt = flexiblas_mgmt_load_config();\n        if ( __flexiblas_mgmt == NULL) {\n            DPRINTF_ERROR(0, \"Cannot initialize/load the configuration.\\n\");\n            abort();\n        }\n\n        if ( env_FLEXIBLAS_VERBOSE == NULL) {\n            /* Load Properties */\n            flexiblas_mgmt_get_active_property(__flexiblas_mgmt, &loc, FLEXIBLAS_PROP_VERBOSE, &__flexiblas_verbose);\n        }\n\n\n\n        /* Add additional search paths */\n        __flexiblas_add_path_from_environment();\n        __flexiblas_add_path_from_config(__flexiblas_mgmt, FLEXIBLAS_ENV);\n        __flexiblas_add_path_from_config(__flexiblas_mgmt, FLEXIBLAS_HOST);\n        __flexiblas_add_path_from_config(__flexiblas_mgmt, FLEXIBLAS_USER);\n        __flexiblas_add_path_from_config(__flexiblas_mgmt, FLEXIBLAS_GLOBAL);\n        __flexiblas_init_default_paths();\n\n\n        /* Search all available hooks */\n        __flexiblas_add_hooks();\n\n\n        if (__flexiblas_insert_fallback_blas(__flexiblas_mgmt)) {\n            DPRINTF_ERROR(0, \"Failed to initialize the default and the fallback BLAS backend.\\n\");\n            abort();\n        }\n        /*  Load the active default BLAS */\n        if ( flexiblas_mgmt_get_active_default(__flexiblas_mgmt, &loc, blas_default_map) < 0 ) {\n            DPRINTF_ERROR(0, \"Failed to select the default BLAS backend.\\n\");\n            abort();\n        }\n\n        /*-----------------------------------------------------------------------------\n         *  Display Copyright\n         *-----------------------------------------------------------------------------*/\n        if ( __flexiblas_verbose) {\n            __flexiblas_print_copyright(1);\n        }\n\n        /*-----------------------------------------------------------------------------\n         *  Load Library\n         *-----------------------------------------------------------------------------*/\n        uppercase(blas_default_map);\n\n        /*-----------------------------------------------------------------------------\n         *  Load NETLIB Fallback\n         *-----------------------------------------------------------------------------*/\n        {\n            char *SO_EXTENSION = __flexiblas_getenv(FLEXIBLAS_ENV_SO_EXTENSION);\n            size_t len=strlen(FALLBACK_NAME)+strlen(SO_EXTENSION)+2;\n            char *blas_name = (char *) calloc(len,sizeof(char));\n            snprintf(blas_name,len, \"%s%s\", FALLBACK_NAME,SO_EXTENSION);\n            free(SO_EXTENSION);\n\n            __flexiblas_blas_fallback = __flexiblas_dlopen(blas_name, RTLD_LAZY | RTLD_GLOBAL , NULL);\n            if ( __flexiblas_blas_fallback == NULL ) {\n                DPRINTF_ERROR(0,\" Failed to load the BLAS fallback library.  Abort!\\n\");\n                abort();\n            }\n            free(blas_name);\n        }\n\n#ifdef FLEXIBLAS_LAPACK\n        /*-----------------------------------------------------------------------------\n         *  Load LAPACK Fallback\n         *-----------------------------------------------------------------------------*/\n        {\n            char *SO_EXTENSION = __flexiblas_getenv(FLEXIBLAS_ENV_SO_EXTENSION);\n            size_t len=strlen(LAPACK_FALLBACK_NAME)+strlen(SO_EXTENSION)+2;\n            char *lapack_name = (char *) calloc(len,sizeof(char));\n            snprintf(lapack_name,len, \"%s%s\", LAPACK_FALLBACK_NAME,SO_EXTENSION);\n            free(SO_EXTENSION);\n#ifdef LAPACK_DEEPBIND\n            __flexiblas_lapack_fallback = __flexiblas_dlopen(lapack_name, RTLD_LAZY | RTLD_DEEPBIND |  RTLD_GLOBAL , NULL);\n#else\n            __flexiblas_lapack_fallback = __flexiblas_dlopen(lapack_name, RTLD_LAZY | RTLD_GLOBAL , NULL);\n#endif\n            if ( __flexiblas_lapack_fallback == NULL ) {\n                DPRINTF_ERROR(0,\" Failed to load the LAPACK fallback library.  Abort!\\n\");\n                abort();\n            }\n            free(lapack_name);\n        }\n#endif\n\n\n        /*\n         * LOAD BLAS Backend.\n         */\n        backend = flexiblas_load_library_from_init(__flexiblas_mgmt, blas_default_map);\n        if ( backend == NULL ){\n            DPRINTF_ERROR(0, \"Loading Backend Failed.\\n\");\n            abort();\n        }\n        loaded_backends = (flexiblas_backend_t **) malloc(sizeof(flexiblas_backend_t*) * 1);\n        /* Set the loaded backend as default one.  */\n        nloaded_backends = 1;\n        loaded_backends[0] = backend;\n        current_backend  = backend;\n\n\n        /*\n         * Load Hooks\n         */\n        __flexiblas_hooks = (flexiblas_hook_t *) malloc(sizeof(flexiblas_hook_t) * (1));\n        if (!__flexiblas_hooks) {\n            DPRINTF_ERROR(0, \"Failed to allocate memory for hook management. Abort.\\n\");\n            abort();\n        }\n        memset(__flexiblas_hooks, 0, sizeof(flexiblas_hook_t));\n        __flexiblas_hooks->hooks_loaded = 0;\n        __flexiblas_hooks->initialized  = 0;\n\n        dlsym((void *) 0, \"flexiblas_verbosity\");\n\n        int hooks_to_load = 0;\n        char ** hook_load_list = NULL;\n        int ret = 0;\n        int i ;\n        if ( env_FLEXIBLAS_HOOK == NULL ){\n            // Load from Config\n            flexiblas_mgmt_location_t locx;\n            ret = flexiblas_mgmt_hook_get_active(__flexiblas_mgmt, &locx, &hooks_to_load, &hook_load_list);\n            if ( ret != 0 ) {\n                DPRINTF_ERROR(0, \"Failed to obtain list of enabled hooks from the configuration. Continue without hooks.\\n\");\n                goto continue_load;\n            }\n        } else {\n            // load from environment\n            char *nexttoken = NULL;\n            char *saveptr = NULL;\n            i = 0;\n            nexttoken = strtok_r(env_FLEXIBLAS_HOOK,\":,\", &saveptr);\n            while (nexttoken != NULL ){\n                i++;\n                if (!( __flexiblas_hook_exists(nexttoken))) {\n                    char *hook_name = __flexiblas_hook_add_from_file(nexttoken);\n                    if ( !hook_name) {\n                        DPRINTF_ERROR(0, \"Hook %s not found. Abort.\\n\", nexttoken);\n                        abort();\n                    }\n                    hook_load_list = realloc (hook_load_list, i * sizeof(char*));\n                    hook_load_list[i-1] = strdup(hook_name);\n\n                } else {\n                    hook_load_list = realloc (hook_load_list, i * sizeof(char*));\n                    hook_load_list[i-1] = strdup(nexttoken);\n                }\n                nexttoken = strtok_r(NULL,\":,\", &saveptr);\n            }\n            hooks_to_load = i;\n        }\n\n        int k = 0;\n        for (i = 0; i < hooks_to_load; i++) {\n            char * sofile;\n            void * handle = NULL;\n\n            sofile = __flexiblas_hook_sofile(hook_load_list[i]);\n            handle  = __flexiblas_dlopen(sofile, RTLD_LAZY | RTLD_LOCAL , NULL);\n            DPRINTF(1,\"Load hook: %s - %s\\n\", hook_load_list[i], sofile);\n            if ( ! handle ) {\n                DPRINTF_ERROR(0, \"Failed to load hook %s. Either it does not exists in the configuration or it is not a shared object.\\n\", hook_load_list[i]);\n                free(hook_load_list[i]);\n                continue;\n            }\n\n\n            __flexiblas_hooks->handles[k] = handle;\n            __flexiblas_hooks->hook_init[k] = (flexiblas_init_function_t) dlsym(handle, FLEXIBLAS_HOOK_INIT_FUNCTION_NAME);\n            __flexiblas_hooks->hook_exit[k] = (flexiblas_exit_function_t) dlsym(handle, FLEXIBLAS_HOOK_EXIT_FUNCTION_NAME);\n\n            __flexiblas_load_blas_hooks(__flexiblas_hooks, handle);\n\n            __flexiblas_hooks->hooks_loaded ++;\n            if ( __flexiblas_hooks->hooks_loaded >= FLEXIBLAS_MAX_HOOKS ) {\n                DPRINTF_ERROR(0, \"More than %d hook libraries loaded. Please reduce the number of hook libraries. Abort!\\n\", FLEXIBLAS_MAX_HOOKS);\n                abort();\n            }\n            k++;\n            free(hook_load_list[i]);\n        }\n        free(hook_load_list);\n\n        /* Init The Hook Library  */\n        if (__flexiblas_hooks->initialized == 0) {\n            __flexiblas_hooks->initialized = 1;\n            for (k = 0; k < __flexiblas_hooks->hooks_loaded; k++) {\n                __flexiblas_hooks->hook_init[k]();\n            }\n        }\n\n\n        continue_load:\n        return;\n\n\n\n\n\n    }\n\n\n\n/*-----------------------------------------------------------------------------\n *  Cleanup\n *-----------------------------------------------------------------------------*/\n#ifndef __WIN32__\n__attribute__((destructor))\n#endif\n    void flexiblas_exit() {\n        size_t i;\n        if (__flexiblas_verbose ) DPRINTF(1,\"cleanup\\n\");\n\n        int k;\n        for ( k = __flexiblas_hooks->hooks_loaded-1; k>=0; k--){\n            __flexiblas_hooks->hook_exit[k]();\n            dlclose(__flexiblas_hooks->handles[k]);\n        }\n        free(__flexiblas_hooks);\n        nloaded_backends = 0;\n        __flexiblas_free_paths();\n        __flexiblas_exit_hook();\n\n\n        for (i = 0; i < nloaded_backends ; i++) {\n            if ( loaded_backends[i]->exit_function != NULL) {\n                loaded_backends[i]->exit_function();\n            }\n            free(loaded_backends[i]->name);\n            if ( loaded_backends[i]->library_handle != NULL){\n#ifdef __WIN32__\n                FreeLibrary(loaded_backends[i]->library_handle);\n#else\n                dlclose(loaded_backends[i]->library_handle );\n#endif\n            }\n            free(loaded_backends[i]);\n        }\n        free(loaded_backends);\n\n        dlclose(__flexiblas_blas_fallback);\n#ifdef FLEXIBLAS_LAPACK\n        dlclose(__flexiblas_lapack_fallback);\n#endif\n        flexiblas_mgmt_free_config(__flexiblas_mgmt);\n    }\n\n\n\n\n\ndouble flexiblas_wtime()\n{\n    struct timeval tv;\n    gettimeofday (&tv, NULL);\n    return (double)tv.tv_sec + (double)tv.tv_usec / 1e6;\n}\n\n\nint flexiblas_verbosity()\n{\n    return __flexiblas_verbose;\n}\n\n\n#ifdef __WIN32__\n#include <windows.h>\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n{\n    switch (fdwReason)\n    {\n        case DLL_PROCESS_ATTACH:\n            /* Code path executed when DLL is loaded into a process's address space. */\n            flexiblas_init();\n            break;\n\n        case DLL_THREAD_ATTACH:\n            /* Code path executed when a new thread is created within the process. */\n            break;\n\n        case DLL_THREAD_DETACH:\n            /* Code path executed when a thread within the process has exited *cleanly*. */\n            break;\n\n        case DLL_PROCESS_DETACH:\n            /* Code path executed when DLL is unloaded from a process's address space. */\n            flexiblas_exit();\n            break;\n    }\n\n    return TRUE;\n}\n#endif\n\n\nflexiblas_mgmt_t * flexiblas_mgmt()\n{\n    return __flexiblas_mgmt;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/src/hook_loader.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Linking FlexiBLAS statically or dynamically with other modules is making a\n * combined work based on FlexiBLAS. Thus, the terms and conditions of the GNU\n * General Public License cover the whole combination.\n *\n * As a special exception, the copyright holders of FlexiBLAS give you permission\n * to combine FlexiBLAS program with free software programs or libraries that are\n * released under the GNU LGPL and with independent modules that communicate with\n * FlexiBLAS solely through the BLAS/LAPACK interface as provided by the\n * BLAS/LAPACK reference implementation. You may copy and distribute such a system\n * following the terms of the GNU GPL for FlexiBLAS and the licenses of the other\n * code concerned, provided that you include the source code of that other code\n * when and as the GNU GPL requires distribution of source code and provided that\n * you do not modify the BLAS/LAPACK interface.\n *\n * Note that people who make modified versions of FlexiBLAS are not obligated to\n * grant this special exception for their modified versions; it is their choice\n * whether to do so. The GNU General Public License gives permission to release a\n * modified version without this exception; this exception also makes it possible\n * to release a modified version which carries forward this exception. If you\n * modify the BLAS/LAPACK interface, this exception does not apply to your\n * modified version of FlexiBLAS, and you must remove this exception when you\n * distribute your modified version.\n *\n * This exception is an additional permission under section 7 of the GNU General\n * Public License, version 3 (\u201cGPLv3\u201d)\n *\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2013-2020\n */\n\n\n\n\n#include \"flexiblas.h\"\n#include <errno.h>\n\n\nstatic int __flexiblas_load_fortran_hook_function( void * handle , struct flexiblas_hook_fn *ptr, const char *name)\n{\n    char fname[40];\n    void * ptr_hsymbol = NULL;\n    int run = 0;\n\n    if ( handle == NULL) return 0;\n\n    /* Load Hook if available */\n\tDPRINTF(3, \"Look up hook: \");\n\tfor (run = 0; run < 3 ; run++) {\n\t\tif (run == 0) {\n\t\t\tsnprintf(fname, 39, \"hook_%s\", name);\n\t\t} else if ( run == 1 ){\n\t\t\tsnprintf(fname, 39, \"hook_%s_\", name);\n\t\t} else if ( run == 2 ){\n\t\t\tsnprintf(fname, 39, \"hook_%s__\", name);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tif ( __flexiblas_verbose > 2) {\n\t\t\tfprintf(stderr, \"%s \", fname);\n\t\t}\n\n\t\tptr_hsymbol = dlsym(handle, fname);\n\n        if (ptr_hsymbol!=NULL) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ( __flexiblas_verbose > 2) {\n\t\tfprintf(stderr, \"%s\\n\", (ptr_hsymbol==NULL)?(\"not found.\"):(\"found.\"));\n\t}\n    if ( ptr_hsymbol ) {\n        int p = ptr->nhook;\n        ptr->f77_hook_function[p] = ptr_hsymbol;\n        ptr->nhook++;\n        if ( ptr->nhook >= FLEXIBLAS_MAX_HOOKS) {\n            DPRINTF_WARN(0, \"Maximum number of installable hooks reached for %s. This may cause problems.\\n\");\n            ptr->nhook = FLEXIBLAS_MAX_HOOKS-1;\n        }\n    }\n\n    return 0;\n}\n\n\n#define LOAD_HOOK(backend, handle,part,name) do { \\\n    if ( __flexiblas_load_fortran_hook_function(handle, &(backend ->part),  #name ) > 0 ) { \\\n        DPRINTF_WARN(3,\"Cannot load hook for\" #name \"\\n\");\\\n    } \\\n} while(0);\n\n\nHIDDEN int __flexiblas_load_blas_hooks(flexiblas_hook_t *hooks, void *hook_handle) {\n\tLOAD_HOOK(hooks, hook_handle,caxpy,caxpy);\n\tLOAD_HOOK(hooks, hook_handle,ccopy,ccopy);\n\tLOAD_HOOK(hooks, hook_handle,cdotc,cdotc);\n\tLOAD_HOOK(hooks, hook_handle,cdotu,cdotu);\n\tLOAD_HOOK(hooks, hook_handle,cgbmv,cgbmv);\n\tLOAD_HOOK(hooks, hook_handle,cgemm,cgemm);\n\tLOAD_HOOK(hooks, hook_handle,cgemv,cgemv);\n\tLOAD_HOOK(hooks, hook_handle,cgerc,cgerc);\n\tLOAD_HOOK(hooks, hook_handle,cgeru,cgeru);\n\tLOAD_HOOK(hooks, hook_handle,chbmv,chbmv);\n\tLOAD_HOOK(hooks, hook_handle,chemm,chemm);\n\tLOAD_HOOK(hooks, hook_handle,chemv,chemv);\n\tLOAD_HOOK(hooks, hook_handle,cher,cher);\n\tLOAD_HOOK(hooks, hook_handle,cher2,cher2);\n\tLOAD_HOOK(hooks, hook_handle,cher2k,cher2k);\n\tLOAD_HOOK(hooks, hook_handle,cherk,cherk);\n\tLOAD_HOOK(hooks, hook_handle,chpmv,chpmv);\n\tLOAD_HOOK(hooks, hook_handle,chpr,chpr);\n\tLOAD_HOOK(hooks, hook_handle,chpr2,chpr2);\n\tLOAD_HOOK(hooks, hook_handle,crotg,crotg);\n\tLOAD_HOOK(hooks, hook_handle,cscal,cscal);\n\tLOAD_HOOK(hooks, hook_handle,csrot,csrot);\n\tLOAD_HOOK(hooks, hook_handle,csscal,csscal);\n\tLOAD_HOOK(hooks, hook_handle,cswap,cswap);\n\tLOAD_HOOK(hooks, hook_handle,csymm,csymm);\n\tLOAD_HOOK(hooks, hook_handle,csyr2k,csyr2k);\n\tLOAD_HOOK(hooks, hook_handle,csyrk,csyrk);\n\tLOAD_HOOK(hooks, hook_handle,ctbmv,ctbmv);\n\tLOAD_HOOK(hooks, hook_handle,ctbsv,ctbsv);\n\tLOAD_HOOK(hooks, hook_handle,ctpmv,ctpmv);\n\tLOAD_HOOK(hooks, hook_handle,ctpsv,ctpsv);\n\tLOAD_HOOK(hooks, hook_handle,ctrmm,ctrmm);\n\tLOAD_HOOK(hooks, hook_handle,ctrmv,ctrmv);\n\tLOAD_HOOK(hooks, hook_handle,ctrsm,ctrsm);\n\tLOAD_HOOK(hooks, hook_handle,ctrsv,ctrsv);\n\tLOAD_HOOK(hooks, hook_handle,dasum,dasum);\n\tLOAD_HOOK(hooks, hook_handle,daxpy,daxpy);\n\tLOAD_HOOK(hooks, hook_handle,dcopy,dcopy);\n\tLOAD_HOOK(hooks, hook_handle,ddot,ddot);\n\tLOAD_HOOK(hooks, hook_handle,dgbmv,dgbmv);\n\tLOAD_HOOK(hooks, hook_handle,dgemm,dgemm);\n\tLOAD_HOOK(hooks, hook_handle,dgemv,dgemv);\n\tLOAD_HOOK(hooks, hook_handle,dger,dger);\n\tLOAD_HOOK(hooks, hook_handle,dnrm2,dnrm2);\n\tLOAD_HOOK(hooks, hook_handle,drot,drot);\n\tLOAD_HOOK(hooks, hook_handle,drotg,drotg);\n\tLOAD_HOOK(hooks, hook_handle,drotm,drotm);\n\tLOAD_HOOK(hooks, hook_handle,drotmg,drotmg);\n\tLOAD_HOOK(hooks, hook_handle,dsbmv,dsbmv);\n\tLOAD_HOOK(hooks, hook_handle,dscal,dscal);\n\tLOAD_HOOK(hooks, hook_handle,dsdot,dsdot);\n\tLOAD_HOOK(hooks, hook_handle,dspmv,dspmv);\n\tLOAD_HOOK(hooks, hook_handle,dspr,dspr);\n\tLOAD_HOOK(hooks, hook_handle,dspr2,dspr2);\n\tLOAD_HOOK(hooks, hook_handle,dswap,dswap);\n\tLOAD_HOOK(hooks, hook_handle,dsymm,dsymm);\n\tLOAD_HOOK(hooks, hook_handle,dsymv,dsymv);\n\tLOAD_HOOK(hooks, hook_handle,dsyr,dsyr);\n\tLOAD_HOOK(hooks, hook_handle,dsyr2,dsyr2);\n\tLOAD_HOOK(hooks, hook_handle,dsyr2k,dsyr2k);\n\tLOAD_HOOK(hooks, hook_handle,dsyrk,dsyrk);\n\tLOAD_HOOK(hooks, hook_handle,dtbmv,dtbmv);\n\tLOAD_HOOK(hooks, hook_handle,dtbsv,dtbsv);\n\tLOAD_HOOK(hooks, hook_handle,dtpmv,dtpmv);\n\tLOAD_HOOK(hooks, hook_handle,dtpsv,dtpsv);\n\tLOAD_HOOK(hooks, hook_handle,dtrmm,dtrmm);\n\tLOAD_HOOK(hooks, hook_handle,dtrmv,dtrmv);\n\tLOAD_HOOK(hooks, hook_handle,dtrsm,dtrsm);\n\tLOAD_HOOK(hooks, hook_handle,dtrsv,dtrsv);\n\tLOAD_HOOK(hooks, hook_handle,dzasum,dzasum);\n\tLOAD_HOOK(hooks, hook_handle,dznrm2,dznrm2);\n\tLOAD_HOOK(hooks, hook_handle,icamax,icamax);\n\tLOAD_HOOK(hooks, hook_handle,idamax,idamax);\n\tLOAD_HOOK(hooks, hook_handle,isamax,isamax);\n\tLOAD_HOOK(hooks, hook_handle,izamax,izamax);\n\tLOAD_HOOK(hooks, hook_handle,sasum,sasum);\n\tLOAD_HOOK(hooks, hook_handle,saxpy,saxpy);\n\tLOAD_HOOK(hooks, hook_handle,scasum,scasum);\n\tLOAD_HOOK(hooks, hook_handle,scnrm2,scnrm2);\n\tLOAD_HOOK(hooks, hook_handle,scopy,scopy);\n\tLOAD_HOOK(hooks, hook_handle,sdot,sdot);\n\tLOAD_HOOK(hooks, hook_handle,sdsdot,sdsdot);\n\tLOAD_HOOK(hooks, hook_handle,sgbmv,sgbmv);\n\tLOAD_HOOK(hooks, hook_handle,sgemm,sgemm);\n\tLOAD_HOOK(hooks, hook_handle,sgemv,sgemv);\n\tLOAD_HOOK(hooks, hook_handle,sger,sger);\n\tLOAD_HOOK(hooks, hook_handle,snrm2,snrm2);\n\tLOAD_HOOK(hooks, hook_handle,srot,srot);\n\tLOAD_HOOK(hooks, hook_handle,srotg,srotg);\n\tLOAD_HOOK(hooks, hook_handle,srotm,srotm);\n\tLOAD_HOOK(hooks, hook_handle,srotmg,srotmg);\n\tLOAD_HOOK(hooks, hook_handle,ssbmv,ssbmv);\n\tLOAD_HOOK(hooks, hook_handle,sscal,sscal);\n\tLOAD_HOOK(hooks, hook_handle,sspmv,sspmv);\n\tLOAD_HOOK(hooks, hook_handle,sspr,sspr);\n\tLOAD_HOOK(hooks, hook_handle,sspr2,sspr2);\n\tLOAD_HOOK(hooks, hook_handle,sswap,sswap);\n\tLOAD_HOOK(hooks, hook_handle,ssymm,ssymm);\n\tLOAD_HOOK(hooks, hook_handle,ssymv,ssymv);\n\tLOAD_HOOK(hooks, hook_handle,ssyr,ssyr);\n\tLOAD_HOOK(hooks, hook_handle,ssyr2,ssyr2);\n\tLOAD_HOOK(hooks, hook_handle,ssyr2k,ssyr2k);\n\tLOAD_HOOK(hooks, hook_handle,ssyrk,ssyrk);\n\tLOAD_HOOK(hooks, hook_handle,stbmv,stbmv);\n\tLOAD_HOOK(hooks, hook_handle,stbsv,stbsv);\n\tLOAD_HOOK(hooks, hook_handle,stpmv,stpmv);\n\tLOAD_HOOK(hooks, hook_handle,stpsv,stpsv);\n\tLOAD_HOOK(hooks, hook_handle,strmm,strmm);\n\tLOAD_HOOK(hooks, hook_handle,strmv,strmv);\n\tLOAD_HOOK(hooks, hook_handle,strsm,strsm);\n\tLOAD_HOOK(hooks, hook_handle,strsv,strsv);\n\tLOAD_HOOK(hooks, hook_handle,zaxpy,zaxpy);\n\tLOAD_HOOK(hooks, hook_handle,zcopy,zcopy);\n\tLOAD_HOOK(hooks, hook_handle,zdotc,zdotc);\n\tLOAD_HOOK(hooks, hook_handle,zdotu,zdotu);\n\tLOAD_HOOK(hooks, hook_handle,zdrot,zdrot);\n\tLOAD_HOOK(hooks, hook_handle,zdscal,zdscal);\n\tLOAD_HOOK(hooks, hook_handle,zgbmv,zgbmv);\n\tLOAD_HOOK(hooks, hook_handle,zgemm,zgemm);\n\tLOAD_HOOK(hooks, hook_handle,zgemv,zgemv);\n\tLOAD_HOOK(hooks, hook_handle,zgerc,zgerc);\n\tLOAD_HOOK(hooks, hook_handle,zgeru,zgeru);\n\tLOAD_HOOK(hooks, hook_handle,zhbmv,zhbmv);\n\tLOAD_HOOK(hooks, hook_handle,zhemm,zhemm);\n\tLOAD_HOOK(hooks, hook_handle,zhemv,zhemv);\n\tLOAD_HOOK(hooks, hook_handle,zher,zher);\n\tLOAD_HOOK(hooks, hook_handle,zher2,zher2);\n\tLOAD_HOOK(hooks, hook_handle,zher2k,zher2k);\n\tLOAD_HOOK(hooks, hook_handle,zherk,zherk);\n\tLOAD_HOOK(hooks, hook_handle,zhpmv,zhpmv);\n\tLOAD_HOOK(hooks, hook_handle,zhpr,zhpr);\n\tLOAD_HOOK(hooks, hook_handle,zhpr2,zhpr2);\n\tLOAD_HOOK(hooks, hook_handle,zrotg,zrotg);\n\tLOAD_HOOK(hooks, hook_handle,zscal,zscal);\n\tLOAD_HOOK(hooks, hook_handle,zswap,zswap);\n\tLOAD_HOOK(hooks, hook_handle,zsymm,zsymm);\n\tLOAD_HOOK(hooks, hook_handle,zsyr2k,zsyr2k);\n\tLOAD_HOOK(hooks, hook_handle,zsyrk,zsyrk);\n\tLOAD_HOOK(hooks, hook_handle,ztbmv,ztbmv);\n\tLOAD_HOOK(hooks, hook_handle,ztbsv,ztbsv);\n\tLOAD_HOOK(hooks, hook_handle,ztpmv,ztpmv);\n\tLOAD_HOOK(hooks, hook_handle,ztpsv,ztpsv);\n\tLOAD_HOOK(hooks, hook_handle,ztrmm,ztrmm);\n\tLOAD_HOOK(hooks, hook_handle,ztrmv,ztrmv);\n\tLOAD_HOOK(hooks, hook_handle,ztrsm,ztrsm);\n    LOAD_HOOK(hooks, hook_handle,ztrsv,ztrsv);\n\n    /* ExtBLAS exte, posnsion */\n    LOAD_HOOK(hooks, hook_handle,caxpby,caxpby);\n    LOAD_HOOK(hooks, hook_handle,comatcopy,comatcopy);\n    LOAD_HOOK(hooks, hook_handle,cimatcopy,cimatcopy);\n    LOAD_HOOK(hooks, hook_handle,cgeadd,cgeadd);\n\n    LOAD_HOOK(hooks, hook_handle,daxpby,daxpby);\n    LOAD_HOOK(hooks, hook_handle,domatcopy,domatcopy);\n    LOAD_HOOK(hooks, hook_handle,dimatcopy,dimatcopy);\n    LOAD_HOOK(hooks, hook_handle,dgeadd,dgeadd);\n\n    LOAD_HOOK(hooks, hook_handle,saxpby,saxpby);\n    LOAD_HOOK(hooks, hook_handle,somatcopy,somatcopy);\n    LOAD_HOOK(hooks, hook_handle,simatcopy,simatcopy);\n    LOAD_HOOK(hooks, hook_handle,sgeadd,sgeadd);\n\n    LOAD_HOOK(hooks, hook_handle,zaxpby,zaxpby);\n    LOAD_HOOK(hooks, hook_handle,zomatcopy,zomatcopy);\n    LOAD_HOOK(hooks, hook_handle,zimatcopy,zimatcopy);\n    LOAD_HOOK(hooks, hook_handle,zgeadd,zgeadd);\n\n#ifdef FLEXIBLAS_LAPACK\n\tLOAD_HOOK(hooks,hook_handle,second,second);\n\tLOAD_HOOK(hooks,hook_handle,dsecnd,dsecnd);\n\tLOAD_HOOK(hooks,hook_handle,slamch,slamch);\n\tLOAD_HOOK(hooks,hook_handle,dlamch,dlamch);\n\tLOAD_HOOK(hooks,hook_handle,cbbcsd,cbbcsd);\n\tLOAD_HOOK(hooks,hook_handle,cbdsqr,cbdsqr);\n\tLOAD_HOOK(hooks,hook_handle,cgbbrd,cgbbrd);\n\tLOAD_HOOK(hooks,hook_handle,cgbcon,cgbcon);\n\tLOAD_HOOK(hooks,hook_handle,cgbequ,cgbequ);\n\tLOAD_HOOK(hooks,hook_handle,cgbequb,cgbequb);\n\tLOAD_HOOK(hooks,hook_handle,cgbrfs,cgbrfs);\n\tLOAD_HOOK(hooks,hook_handle,cgbsv,cgbsv);\n\tLOAD_HOOK(hooks,hook_handle,cgbsvx,cgbsvx);\n\tLOAD_HOOK(hooks,hook_handle,cgbtf2,cgbtf2);\n\tLOAD_HOOK(hooks,hook_handle,cgbtrf,cgbtrf);\n\tLOAD_HOOK(hooks,hook_handle,cgbtrs,cgbtrs);\n\tLOAD_HOOK(hooks,hook_handle,cgebak,cgebak);\n\tLOAD_HOOK(hooks,hook_handle,cgebal,cgebal);\n\tLOAD_HOOK(hooks,hook_handle,cgebd2,cgebd2);\n\tLOAD_HOOK(hooks,hook_handle,cgebrd,cgebrd);\n\tLOAD_HOOK(hooks,hook_handle,cgecon,cgecon);\n\tLOAD_HOOK(hooks,hook_handle,cgeequ,cgeequ);\n\tLOAD_HOOK(hooks,hook_handle,cgeequb,cgeequb);\n\tLOAD_HOOK(hooks,hook_handle,cgees,cgees);\n\tLOAD_HOOK(hooks,hook_handle,cgeesx,cgeesx);\n\tLOAD_HOOK(hooks,hook_handle,cgeev,cgeev);\n\tLOAD_HOOK(hooks,hook_handle,cgeevx,cgeevx);\n\tLOAD_HOOK(hooks,hook_handle,cgegs,cgegs);\n\tLOAD_HOOK(hooks,hook_handle,cgegv,cgegv);\n\tLOAD_HOOK(hooks,hook_handle,cgehd2,cgehd2);\n\tLOAD_HOOK(hooks,hook_handle,cgehrd,cgehrd);\n\tLOAD_HOOK(hooks,hook_handle,cgejsv,cgejsv);\n\tLOAD_HOOK(hooks,hook_handle,cgelq,cgelq);\n\tLOAD_HOOK(hooks,hook_handle,cgelq2,cgelq2);\n\tLOAD_HOOK(hooks,hook_handle,cgelqf,cgelqf);\n\tLOAD_HOOK(hooks,hook_handle,cgelqt,cgelqt);\n\tLOAD_HOOK(hooks,hook_handle,cgelqt3,cgelqt3);\n\tLOAD_HOOK(hooks,hook_handle,cgels,cgels);\n\tLOAD_HOOK(hooks,hook_handle,cgelsd,cgelsd);\n\tLOAD_HOOK(hooks,hook_handle,cgelss,cgelss);\n\tLOAD_HOOK(hooks,hook_handle,cgelsx,cgelsx);\n\tLOAD_HOOK(hooks,hook_handle,cgelsy,cgelsy);\n\tLOAD_HOOK(hooks,hook_handle,cgemlq,cgemlq);\n\tLOAD_HOOK(hooks,hook_handle,cgemlqt,cgemlqt);\n\tLOAD_HOOK(hooks,hook_handle,cgemqr,cgemqr);\n\tLOAD_HOOK(hooks,hook_handle,cgemqrt,cgemqrt);\n\tLOAD_HOOK(hooks,hook_handle,cgeql2,cgeql2);\n\tLOAD_HOOK(hooks,hook_handle,cgeqlf,cgeqlf);\n\tLOAD_HOOK(hooks,hook_handle,cgeqp3,cgeqp3);\n\tLOAD_HOOK(hooks,hook_handle,cgeqpf,cgeqpf);\n\tLOAD_HOOK(hooks,hook_handle,cgeqr,cgeqr);\n\tLOAD_HOOK(hooks,hook_handle,cgeqr2,cgeqr2);\n\tLOAD_HOOK(hooks,hook_handle,cgeqr2p,cgeqr2p);\n\tLOAD_HOOK(hooks,hook_handle,cgeqrf,cgeqrf);\n\tLOAD_HOOK(hooks,hook_handle,cgeqrfp,cgeqrfp);\n\tLOAD_HOOK(hooks,hook_handle,cgeqrt,cgeqrt);\n\tLOAD_HOOK(hooks,hook_handle,cgeqrt2,cgeqrt2);\n\tLOAD_HOOK(hooks,hook_handle,cgeqrt3,cgeqrt3);\n\tLOAD_HOOK(hooks,hook_handle,cgerfs,cgerfs);\n\tLOAD_HOOK(hooks,hook_handle,cgerq2,cgerq2);\n\tLOAD_HOOK(hooks,hook_handle,cgerqf,cgerqf);\n\tLOAD_HOOK(hooks,hook_handle,cgesc2,cgesc2);\n\tLOAD_HOOK(hooks,hook_handle,cgesdd,cgesdd);\n\tLOAD_HOOK(hooks,hook_handle,cgesv,cgesv);\n\tLOAD_HOOK(hooks,hook_handle,cgesvd,cgesvd);\n\tLOAD_HOOK(hooks,hook_handle,cgesvdq,cgesvdq);\n\tLOAD_HOOK(hooks,hook_handle,cgesvdx,cgesvdx);\n\tLOAD_HOOK(hooks,hook_handle,cgesvj,cgesvj);\n\tLOAD_HOOK(hooks,hook_handle,cgesvx,cgesvx);\n\tLOAD_HOOK(hooks,hook_handle,cgetc2,cgetc2);\n\tLOAD_HOOK(hooks,hook_handle,cgetf2,cgetf2);\n\tLOAD_HOOK(hooks,hook_handle,cgetrf,cgetrf);\n\tLOAD_HOOK(hooks,hook_handle,cgetrf2,cgetrf2);\n\tLOAD_HOOK(hooks,hook_handle,cgetri,cgetri);\n\tLOAD_HOOK(hooks,hook_handle,cgetrs,cgetrs);\n\tLOAD_HOOK(hooks,hook_handle,cgetsls,cgetsls);\n\tLOAD_HOOK(hooks,hook_handle,cggbak,cggbak);\n\tLOAD_HOOK(hooks,hook_handle,cggbal,cggbal);\n\tLOAD_HOOK(hooks,hook_handle,cgges,cgges);\n\tLOAD_HOOK(hooks,hook_handle,cgges3,cgges3);\n\tLOAD_HOOK(hooks,hook_handle,cggesx,cggesx);\n\tLOAD_HOOK(hooks,hook_handle,cggev,cggev);\n\tLOAD_HOOK(hooks,hook_handle,cggev3,cggev3);\n\tLOAD_HOOK(hooks,hook_handle,cggevx,cggevx);\n\tLOAD_HOOK(hooks,hook_handle,cggglm,cggglm);\n\tLOAD_HOOK(hooks,hook_handle,cgghd3,cgghd3);\n\tLOAD_HOOK(hooks,hook_handle,cgghrd,cgghrd);\n\tLOAD_HOOK(hooks,hook_handle,cgglse,cgglse);\n\tLOAD_HOOK(hooks,hook_handle,cggqrf,cggqrf);\n\tLOAD_HOOK(hooks,hook_handle,cggrqf,cggrqf);\n\tLOAD_HOOK(hooks,hook_handle,cggsvd,cggsvd);\n\tLOAD_HOOK(hooks,hook_handle,cggsvd3,cggsvd3);\n\tLOAD_HOOK(hooks,hook_handle,cggsvp,cggsvp);\n\tLOAD_HOOK(hooks,hook_handle,cggsvp3,cggsvp3);\n\tLOAD_HOOK(hooks,hook_handle,cgsvj0,cgsvj0);\n\tLOAD_HOOK(hooks,hook_handle,cgsvj1,cgsvj1);\n\tLOAD_HOOK(hooks,hook_handle,cgtcon,cgtcon);\n\tLOAD_HOOK(hooks,hook_handle,cgtrfs,cgtrfs);\n\tLOAD_HOOK(hooks,hook_handle,cgtsv,cgtsv);\n\tLOAD_HOOK(hooks,hook_handle,cgtsvx,cgtsvx);\n\tLOAD_HOOK(hooks,hook_handle,cgttrf,cgttrf);\n\tLOAD_HOOK(hooks,hook_handle,cgttrs,cgttrs);\n\tLOAD_HOOK(hooks,hook_handle,cgtts2,cgtts2);\n\tLOAD_HOOK(hooks,hook_handle,chb2st_kernels,chb2st_kernels);\n\tLOAD_HOOK(hooks,hook_handle,chbev,chbev);\n\tLOAD_HOOK(hooks,hook_handle,chbev_2stage,chbev_2stage);\n\tLOAD_HOOK(hooks,hook_handle,chbevd,chbevd);\n\tLOAD_HOOK(hooks,hook_handle,chbevd_2stage,chbevd_2stage);\n\tLOAD_HOOK(hooks,hook_handle,chbevx,chbevx);\n\tLOAD_HOOK(hooks,hook_handle,chbevx_2stage,chbevx_2stage);\n\tLOAD_HOOK(hooks,hook_handle,chbgst,chbgst);\n\tLOAD_HOOK(hooks,hook_handle,chbgv,chbgv);\n\tLOAD_HOOK(hooks,hook_handle,chbgvd,chbgvd);\n\tLOAD_HOOK(hooks,hook_handle,chbgvx,chbgvx);\n\tLOAD_HOOK(hooks,hook_handle,chbtrd,chbtrd);\n\tLOAD_HOOK(hooks,hook_handle,checon,checon);\n\tLOAD_HOOK(hooks,hook_handle,checon_3,checon_3);\n\tLOAD_HOOK(hooks,hook_handle,checon_rook,checon_rook);\n\tLOAD_HOOK(hooks,hook_handle,cheequb,cheequb);\n\tLOAD_HOOK(hooks,hook_handle,cheev,cheev);\n\tLOAD_HOOK(hooks,hook_handle,cheev_2stage,cheev_2stage);\n\tLOAD_HOOK(hooks,hook_handle,cheevd,cheevd);\n\tLOAD_HOOK(hooks,hook_handle,cheevd_2stage,cheevd_2stage);\n\tLOAD_HOOK(hooks,hook_handle,cheevr,cheevr);\n\tLOAD_HOOK(hooks,hook_handle,cheevr_2stage,cheevr_2stage);\n\tLOAD_HOOK(hooks,hook_handle,cheevx,cheevx);\n\tLOAD_HOOK(hooks,hook_handle,cheevx_2stage,cheevx_2stage);\n\tLOAD_HOOK(hooks,hook_handle,chegs2,chegs2);\n\tLOAD_HOOK(hooks,hook_handle,chegst,chegst);\n\tLOAD_HOOK(hooks,hook_handle,chegv,chegv);\n\tLOAD_HOOK(hooks,hook_handle,chegv_2stage,chegv_2stage);\n\tLOAD_HOOK(hooks,hook_handle,chegvd,chegvd);\n\tLOAD_HOOK(hooks,hook_handle,chegvx,chegvx);\n\tLOAD_HOOK(hooks,hook_handle,cherfs,cherfs);\n\tLOAD_HOOK(hooks,hook_handle,chesv,chesv);\n\tLOAD_HOOK(hooks,hook_handle,chesv_aa,chesv_aa);\n\tLOAD_HOOK(hooks,hook_handle,chesv_aa_2stage,chesv_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,chesv_rk,chesv_rk);\n\tLOAD_HOOK(hooks,hook_handle,chesv_rook,chesv_rook);\n\tLOAD_HOOK(hooks,hook_handle,chesvx,chesvx);\n\tLOAD_HOOK(hooks,hook_handle,cheswapr,cheswapr);\n\tLOAD_HOOK(hooks,hook_handle,chetd2,chetd2);\n\tLOAD_HOOK(hooks,hook_handle,chetf2,chetf2);\n\tLOAD_HOOK(hooks,hook_handle,chetf2_rk,chetf2_rk);\n\tLOAD_HOOK(hooks,hook_handle,chetf2_rook,chetf2_rook);\n\tLOAD_HOOK(hooks,hook_handle,chetrd,chetrd);\n\tLOAD_HOOK(hooks,hook_handle,chetrd_2stage,chetrd_2stage);\n\tLOAD_HOOK(hooks,hook_handle,chetrd_hb2st,chetrd_hb2st);\n\tLOAD_HOOK(hooks,hook_handle,chetrd_he2hb,chetrd_he2hb);\n\tLOAD_HOOK(hooks,hook_handle,chetrf,chetrf);\n\tLOAD_HOOK(hooks,hook_handle,chetrf_aa,chetrf_aa);\n\tLOAD_HOOK(hooks,hook_handle,chetrf_aa_2stage,chetrf_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,chetrf_rk,chetrf_rk);\n\tLOAD_HOOK(hooks,hook_handle,chetrf_rook,chetrf_rook);\n\tLOAD_HOOK(hooks,hook_handle,chetri,chetri);\n\tLOAD_HOOK(hooks,hook_handle,chetri2,chetri2);\n\tLOAD_HOOK(hooks,hook_handle,chetri2x,chetri2x);\n\tLOAD_HOOK(hooks,hook_handle,chetri_3,chetri_3);\n\tLOAD_HOOK(hooks,hook_handle,chetri_3x,chetri_3x);\n\tLOAD_HOOK(hooks,hook_handle,chetri_rook,chetri_rook);\n\tLOAD_HOOK(hooks,hook_handle,chetrs,chetrs);\n\tLOAD_HOOK(hooks,hook_handle,chetrs2,chetrs2);\n\tLOAD_HOOK(hooks,hook_handle,chetrs_3,chetrs_3);\n\tLOAD_HOOK(hooks,hook_handle,chetrs_aa,chetrs_aa);\n\tLOAD_HOOK(hooks,hook_handle,chetrs_aa_2stage,chetrs_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,chetrs_rook,chetrs_rook);\n\tLOAD_HOOK(hooks,hook_handle,chfrk,chfrk);\n\tLOAD_HOOK(hooks,hook_handle,chgeqz,chgeqz);\n\tLOAD_HOOK(hooks,hook_handle,chla_transtype,chla_transtype);\n\tLOAD_HOOK(hooks,hook_handle,chpcon,chpcon);\n\tLOAD_HOOK(hooks,hook_handle,chpev,chpev);\n\tLOAD_HOOK(hooks,hook_handle,chpevd,chpevd);\n\tLOAD_HOOK(hooks,hook_handle,chpevx,chpevx);\n\tLOAD_HOOK(hooks,hook_handle,chpgst,chpgst);\n\tLOAD_HOOK(hooks,hook_handle,chpgv,chpgv);\n\tLOAD_HOOK(hooks,hook_handle,chpgvd,chpgvd);\n\tLOAD_HOOK(hooks,hook_handle,chpgvx,chpgvx);\n\tLOAD_HOOK(hooks,hook_handle,chprfs,chprfs);\n\tLOAD_HOOK(hooks,hook_handle,chpsv,chpsv);\n\tLOAD_HOOK(hooks,hook_handle,chpsvx,chpsvx);\n\tLOAD_HOOK(hooks,hook_handle,chptrd,chptrd);\n\tLOAD_HOOK(hooks,hook_handle,chptrf,chptrf);\n\tLOAD_HOOK(hooks,hook_handle,chptri,chptri);\n\tLOAD_HOOK(hooks,hook_handle,chptrs,chptrs);\n\tLOAD_HOOK(hooks,hook_handle,chsein,chsein);\n\tLOAD_HOOK(hooks,hook_handle,chseqr,chseqr);\n\tLOAD_HOOK(hooks,hook_handle,clabrd,clabrd);\n\tLOAD_HOOK(hooks,hook_handle,clacgv,clacgv);\n\tLOAD_HOOK(hooks,hook_handle,clacn2,clacn2);\n\tLOAD_HOOK(hooks,hook_handle,clacon,clacon);\n\tLOAD_HOOK(hooks,hook_handle,clacp2,clacp2);\n\tLOAD_HOOK(hooks,hook_handle,clacpy,clacpy);\n\tLOAD_HOOK(hooks,hook_handle,clacrm,clacrm);\n\tLOAD_HOOK(hooks,hook_handle,clacrt,clacrt);\n\tLOAD_HOOK(hooks,hook_handle,cladiv,cladiv);\n\tLOAD_HOOK(hooks,hook_handle,claed0,claed0);\n\tLOAD_HOOK(hooks,hook_handle,claed7,claed7);\n\tLOAD_HOOK(hooks,hook_handle,claed8,claed8);\n\tLOAD_HOOK(hooks,hook_handle,claein,claein);\n\tLOAD_HOOK(hooks,hook_handle,claesy,claesy);\n\tLOAD_HOOK(hooks,hook_handle,claev2,claev2);\n\tLOAD_HOOK(hooks,hook_handle,clag2z,clag2z);\n\tLOAD_HOOK(hooks,hook_handle,clags2,clags2);\n\tLOAD_HOOK(hooks,hook_handle,clagtm,clagtm);\n\tLOAD_HOOK(hooks,hook_handle,clahef,clahef);\n\tLOAD_HOOK(hooks,hook_handle,clahef_aa,clahef_aa);\n\tLOAD_HOOK(hooks,hook_handle,clahef_rk,clahef_rk);\n\tLOAD_HOOK(hooks,hook_handle,clahef_rook,clahef_rook);\n\tLOAD_HOOK(hooks,hook_handle,clahqr,clahqr);\n\tLOAD_HOOK(hooks,hook_handle,clahr2,clahr2);\n\tLOAD_HOOK(hooks,hook_handle,clahrd,clahrd);\n\tLOAD_HOOK(hooks,hook_handle,claic1,claic1);\n\tLOAD_HOOK(hooks,hook_handle,clals0,clals0);\n\tLOAD_HOOK(hooks,hook_handle,clalsa,clalsa);\n\tLOAD_HOOK(hooks,hook_handle,clalsd,clalsd);\n\tLOAD_HOOK(hooks,hook_handle,clamswlq,clamswlq);\n\tLOAD_HOOK(hooks,hook_handle,clamtsqr,clamtsqr);\n\tLOAD_HOOK(hooks,hook_handle,clangb,clangb);\n\tLOAD_HOOK(hooks,hook_handle,clange,clange);\n\tLOAD_HOOK(hooks,hook_handle,clangt,clangt);\n\tLOAD_HOOK(hooks,hook_handle,clanhb,clanhb);\n\tLOAD_HOOK(hooks,hook_handle,clanhe,clanhe);\n\tLOAD_HOOK(hooks,hook_handle,clanhf,clanhf);\n\tLOAD_HOOK(hooks,hook_handle,clanhp,clanhp);\n\tLOAD_HOOK(hooks,hook_handle,clanhs,clanhs);\n\tLOAD_HOOK(hooks,hook_handle,clanht,clanht);\n\tLOAD_HOOK(hooks,hook_handle,clansb,clansb);\n\tLOAD_HOOK(hooks,hook_handle,clansp,clansp);\n\tLOAD_HOOK(hooks,hook_handle,clansy,clansy);\n\tLOAD_HOOK(hooks,hook_handle,clantb,clantb);\n\tLOAD_HOOK(hooks,hook_handle,clantp,clantp);\n\tLOAD_HOOK(hooks,hook_handle,clantr,clantr);\n\tLOAD_HOOK(hooks,hook_handle,clapll,clapll);\n\tLOAD_HOOK(hooks,hook_handle,clapmr,clapmr);\n\tLOAD_HOOK(hooks,hook_handle,clapmt,clapmt);\n\tLOAD_HOOK(hooks,hook_handle,claqgb,claqgb);\n\tLOAD_HOOK(hooks,hook_handle,claqge,claqge);\n\tLOAD_HOOK(hooks,hook_handle,claqhb,claqhb);\n\tLOAD_HOOK(hooks,hook_handle,claqhe,claqhe);\n\tLOAD_HOOK(hooks,hook_handle,claqhp,claqhp);\n\tLOAD_HOOK(hooks,hook_handle,claqp2,claqp2);\n\tLOAD_HOOK(hooks,hook_handle,claqps,claqps);\n\tLOAD_HOOK(hooks,hook_handle,claqr0,claqr0);\n\tLOAD_HOOK(hooks,hook_handle,claqr1,claqr1);\n\tLOAD_HOOK(hooks,hook_handle,claqr2,claqr2);\n\tLOAD_HOOK(hooks,hook_handle,claqr3,claqr3);\n\tLOAD_HOOK(hooks,hook_handle,claqr4,claqr4);\n\tLOAD_HOOK(hooks,hook_handle,claqr5,claqr5);\n\tLOAD_HOOK(hooks,hook_handle,claqsb,claqsb);\n\tLOAD_HOOK(hooks,hook_handle,claqsp,claqsp);\n\tLOAD_HOOK(hooks,hook_handle,claqsy,claqsy);\n\tLOAD_HOOK(hooks,hook_handle,clar1v,clar1v);\n\tLOAD_HOOK(hooks,hook_handle,clar2v,clar2v);\n\tLOAD_HOOK(hooks,hook_handle,clarcm,clarcm);\n\tLOAD_HOOK(hooks,hook_handle,clarf,clarf);\n\tLOAD_HOOK(hooks,hook_handle,clarfb,clarfb);\n\tLOAD_HOOK(hooks,hook_handle,clarfg,clarfg);\n\tLOAD_HOOK(hooks,hook_handle,clarfgp,clarfgp);\n\tLOAD_HOOK(hooks,hook_handle,clarft,clarft);\n\tLOAD_HOOK(hooks,hook_handle,clarfx,clarfx);\n\tLOAD_HOOK(hooks,hook_handle,clarfy,clarfy);\n\tLOAD_HOOK(hooks,hook_handle,clargv,clargv);\n\tLOAD_HOOK(hooks,hook_handle,clarnv,clarnv);\n\tLOAD_HOOK(hooks,hook_handle,clarrv,clarrv);\n\tLOAD_HOOK(hooks,hook_handle,clartg,clartg);\n\tLOAD_HOOK(hooks,hook_handle,clartv,clartv);\n\tLOAD_HOOK(hooks,hook_handle,clarz,clarz);\n\tLOAD_HOOK(hooks,hook_handle,clarzb,clarzb);\n\tLOAD_HOOK(hooks,hook_handle,clarzt,clarzt);\n\tLOAD_HOOK(hooks,hook_handle,clascl,clascl);\n\tLOAD_HOOK(hooks,hook_handle,claset,claset);\n\tLOAD_HOOK(hooks,hook_handle,clasr,clasr);\n\tLOAD_HOOK(hooks,hook_handle,classq,classq);\n\tLOAD_HOOK(hooks,hook_handle,claswlq,claswlq);\n\tLOAD_HOOK(hooks,hook_handle,claswp,claswp);\n\tLOAD_HOOK(hooks,hook_handle,clasyf,clasyf);\n\tLOAD_HOOK(hooks,hook_handle,clasyf_aa,clasyf_aa);\n\tLOAD_HOOK(hooks,hook_handle,clasyf_rk,clasyf_rk);\n\tLOAD_HOOK(hooks,hook_handle,clasyf_rook,clasyf_rook);\n\tLOAD_HOOK(hooks,hook_handle,clatbs,clatbs);\n\tLOAD_HOOK(hooks,hook_handle,clatdf,clatdf);\n\tLOAD_HOOK(hooks,hook_handle,clatps,clatps);\n\tLOAD_HOOK(hooks,hook_handle,clatrd,clatrd);\n\tLOAD_HOOK(hooks,hook_handle,clatrs,clatrs);\n\tLOAD_HOOK(hooks,hook_handle,clatrz,clatrz);\n\tLOAD_HOOK(hooks,hook_handle,clatsqr,clatsqr);\n\tLOAD_HOOK(hooks,hook_handle,clatzm,clatzm);\n\tLOAD_HOOK(hooks,hook_handle,claunhr_col_getrfnp,claunhr_col_getrfnp);\n\tLOAD_HOOK(hooks,hook_handle,claunhr_col_getrfnp2,claunhr_col_getrfnp2);\n\tLOAD_HOOK(hooks,hook_handle,clauu2,clauu2);\n\tLOAD_HOOK(hooks,hook_handle,clauum,clauum);\n\tLOAD_HOOK(hooks,hook_handle,cpbcon,cpbcon);\n\tLOAD_HOOK(hooks,hook_handle,cpbequ,cpbequ);\n\tLOAD_HOOK(hooks,hook_handle,cpbrfs,cpbrfs);\n\tLOAD_HOOK(hooks,hook_handle,cpbstf,cpbstf);\n\tLOAD_HOOK(hooks,hook_handle,cpbsv,cpbsv);\n\tLOAD_HOOK(hooks,hook_handle,cpbsvx,cpbsvx);\n\tLOAD_HOOK(hooks,hook_handle,cpbtf2,cpbtf2);\n\tLOAD_HOOK(hooks,hook_handle,cpbtrf,cpbtrf);\n\tLOAD_HOOK(hooks,hook_handle,cpbtrs,cpbtrs);\n\tLOAD_HOOK(hooks,hook_handle,cpftrf,cpftrf);\n\tLOAD_HOOK(hooks,hook_handle,cpftri,cpftri);\n\tLOAD_HOOK(hooks,hook_handle,cpftrs,cpftrs);\n\tLOAD_HOOK(hooks,hook_handle,cpocon,cpocon);\n\tLOAD_HOOK(hooks,hook_handle,cpoequ,cpoequ);\n\tLOAD_HOOK(hooks,hook_handle,cpoequb,cpoequb);\n\tLOAD_HOOK(hooks,hook_handle,cporfs,cporfs);\n\tLOAD_HOOK(hooks,hook_handle,cposv,cposv);\n\tLOAD_HOOK(hooks,hook_handle,cposvx,cposvx);\n\tLOAD_HOOK(hooks,hook_handle,cpotf2,cpotf2);\n\tLOAD_HOOK(hooks,hook_handle,cpotrf,cpotrf);\n\tLOAD_HOOK(hooks,hook_handle,cpotrf2,cpotrf2);\n\tLOAD_HOOK(hooks,hook_handle,cpotri,cpotri);\n\tLOAD_HOOK(hooks,hook_handle,cpotrs,cpotrs);\n\tLOAD_HOOK(hooks,hook_handle,cppcon,cppcon);\n\tLOAD_HOOK(hooks,hook_handle,cppequ,cppequ);\n\tLOAD_HOOK(hooks,hook_handle,cpprfs,cpprfs);\n\tLOAD_HOOK(hooks,hook_handle,cppsv,cppsv);\n\tLOAD_HOOK(hooks,hook_handle,cppsvx,cppsvx);\n\tLOAD_HOOK(hooks,hook_handle,cpptrf,cpptrf);\n\tLOAD_HOOK(hooks,hook_handle,cpptri,cpptri);\n\tLOAD_HOOK(hooks,hook_handle,cpptrs,cpptrs);\n\tLOAD_HOOK(hooks,hook_handle,cpstf2,cpstf2);\n\tLOAD_HOOK(hooks,hook_handle,cpstrf,cpstrf);\n\tLOAD_HOOK(hooks,hook_handle,cptcon,cptcon);\n\tLOAD_HOOK(hooks,hook_handle,cpteqr,cpteqr);\n\tLOAD_HOOK(hooks,hook_handle,cptrfs,cptrfs);\n\tLOAD_HOOK(hooks,hook_handle,cptsv,cptsv);\n\tLOAD_HOOK(hooks,hook_handle,cptsvx,cptsvx);\n\tLOAD_HOOK(hooks,hook_handle,cpttrf,cpttrf);\n\tLOAD_HOOK(hooks,hook_handle,cpttrs,cpttrs);\n\tLOAD_HOOK(hooks,hook_handle,cptts2,cptts2);\n\tLOAD_HOOK(hooks,hook_handle,crot,crot);\n\tLOAD_HOOK(hooks,hook_handle,cspcon,cspcon);\n\tLOAD_HOOK(hooks,hook_handle,cspmv,cspmv);\n\tLOAD_HOOK(hooks,hook_handle,cspr,cspr);\n\tLOAD_HOOK(hooks,hook_handle,csprfs,csprfs);\n\tLOAD_HOOK(hooks,hook_handle,cspsv,cspsv);\n\tLOAD_HOOK(hooks,hook_handle,cspsvx,cspsvx);\n\tLOAD_HOOK(hooks,hook_handle,csptrf,csptrf);\n\tLOAD_HOOK(hooks,hook_handle,csptri,csptri);\n\tLOAD_HOOK(hooks,hook_handle,csptrs,csptrs);\n\tLOAD_HOOK(hooks,hook_handle,csrscl,csrscl);\n\tLOAD_HOOK(hooks,hook_handle,cstedc,cstedc);\n\tLOAD_HOOK(hooks,hook_handle,cstegr,cstegr);\n\tLOAD_HOOK(hooks,hook_handle,cstein,cstein);\n\tLOAD_HOOK(hooks,hook_handle,cstemr,cstemr);\n\tLOAD_HOOK(hooks,hook_handle,csteqr,csteqr);\n\tLOAD_HOOK(hooks,hook_handle,csycon,csycon);\n\tLOAD_HOOK(hooks,hook_handle,csycon_3,csycon_3);\n\tLOAD_HOOK(hooks,hook_handle,csycon_rook,csycon_rook);\n\tLOAD_HOOK(hooks,hook_handle,csyconv,csyconv);\n\tLOAD_HOOK(hooks,hook_handle,csyconvf,csyconvf);\n\tLOAD_HOOK(hooks,hook_handle,csyconvf_rook,csyconvf_rook);\n\tLOAD_HOOK(hooks,hook_handle,csyequb,csyequb);\n\tLOAD_HOOK(hooks,hook_handle,csymv,csymv);\n\tLOAD_HOOK(hooks,hook_handle,csyr,csyr);\n\tLOAD_HOOK(hooks,hook_handle,csyrfs,csyrfs);\n\tLOAD_HOOK(hooks,hook_handle,csysv,csysv);\n\tLOAD_HOOK(hooks,hook_handle,csysv_aa,csysv_aa);\n\tLOAD_HOOK(hooks,hook_handle,csysv_aa_2stage,csysv_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,csysv_rk,csysv_rk);\n\tLOAD_HOOK(hooks,hook_handle,csysv_rook,csysv_rook);\n\tLOAD_HOOK(hooks,hook_handle,csysvx,csysvx);\n\tLOAD_HOOK(hooks,hook_handle,csyswapr,csyswapr);\n\tLOAD_HOOK(hooks,hook_handle,csytf2,csytf2);\n\tLOAD_HOOK(hooks,hook_handle,csytf2_rk,csytf2_rk);\n\tLOAD_HOOK(hooks,hook_handle,csytf2_rook,csytf2_rook);\n\tLOAD_HOOK(hooks,hook_handle,csytrf,csytrf);\n\tLOAD_HOOK(hooks,hook_handle,csytrf_aa,csytrf_aa);\n\tLOAD_HOOK(hooks,hook_handle,csytrf_aa_2stage,csytrf_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,csytrf_rk,csytrf_rk);\n\tLOAD_HOOK(hooks,hook_handle,csytrf_rook,csytrf_rook);\n\tLOAD_HOOK(hooks,hook_handle,csytri,csytri);\n\tLOAD_HOOK(hooks,hook_handle,csytri2,csytri2);\n\tLOAD_HOOK(hooks,hook_handle,csytri2x,csytri2x);\n\tLOAD_HOOK(hooks,hook_handle,csytri_3,csytri_3);\n\tLOAD_HOOK(hooks,hook_handle,csytri_3x,csytri_3x);\n\tLOAD_HOOK(hooks,hook_handle,csytri_rook,csytri_rook);\n\tLOAD_HOOK(hooks,hook_handle,csytrs,csytrs);\n\tLOAD_HOOK(hooks,hook_handle,csytrs2,csytrs2);\n\tLOAD_HOOK(hooks,hook_handle,csytrs_3,csytrs_3);\n\tLOAD_HOOK(hooks,hook_handle,csytrs_aa,csytrs_aa);\n\tLOAD_HOOK(hooks,hook_handle,csytrs_aa_2stage,csytrs_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,csytrs_rook,csytrs_rook);\n\tLOAD_HOOK(hooks,hook_handle,ctbcon,ctbcon);\n\tLOAD_HOOK(hooks,hook_handle,ctbrfs,ctbrfs);\n\tLOAD_HOOK(hooks,hook_handle,ctbtrs,ctbtrs);\n\tLOAD_HOOK(hooks,hook_handle,ctfsm,ctfsm);\n\tLOAD_HOOK(hooks,hook_handle,ctftri,ctftri);\n\tLOAD_HOOK(hooks,hook_handle,ctfttp,ctfttp);\n\tLOAD_HOOK(hooks,hook_handle,ctfttr,ctfttr);\n\tLOAD_HOOK(hooks,hook_handle,ctgevc,ctgevc);\n\tLOAD_HOOK(hooks,hook_handle,ctgex2,ctgex2);\n\tLOAD_HOOK(hooks,hook_handle,ctgexc,ctgexc);\n\tLOAD_HOOK(hooks,hook_handle,ctgsen,ctgsen);\n\tLOAD_HOOK(hooks,hook_handle,ctgsja,ctgsja);\n\tLOAD_HOOK(hooks,hook_handle,ctgsna,ctgsna);\n\tLOAD_HOOK(hooks,hook_handle,ctgsy2,ctgsy2);\n\tLOAD_HOOK(hooks,hook_handle,ctgsyl,ctgsyl);\n\tLOAD_HOOK(hooks,hook_handle,ctpcon,ctpcon);\n\tLOAD_HOOK(hooks,hook_handle,ctplqt,ctplqt);\n\tLOAD_HOOK(hooks,hook_handle,ctplqt2,ctplqt2);\n\tLOAD_HOOK(hooks,hook_handle,ctpmlqt,ctpmlqt);\n\tLOAD_HOOK(hooks,hook_handle,ctpmqrt,ctpmqrt);\n\tLOAD_HOOK(hooks,hook_handle,ctpqrt,ctpqrt);\n\tLOAD_HOOK(hooks,hook_handle,ctpqrt2,ctpqrt2);\n\tLOAD_HOOK(hooks,hook_handle,ctprfb,ctprfb);\n\tLOAD_HOOK(hooks,hook_handle,ctprfs,ctprfs);\n\tLOAD_HOOK(hooks,hook_handle,ctptri,ctptri);\n\tLOAD_HOOK(hooks,hook_handle,ctptrs,ctptrs);\n\tLOAD_HOOK(hooks,hook_handle,ctpttf,ctpttf);\n\tLOAD_HOOK(hooks,hook_handle,ctpttr,ctpttr);\n\tLOAD_HOOK(hooks,hook_handle,ctrcon,ctrcon);\n\tLOAD_HOOK(hooks,hook_handle,ctrevc,ctrevc);\n\tLOAD_HOOK(hooks,hook_handle,ctrevc3,ctrevc3);\n\tLOAD_HOOK(hooks,hook_handle,ctrexc,ctrexc);\n\tLOAD_HOOK(hooks,hook_handle,ctrrfs,ctrrfs);\n\tLOAD_HOOK(hooks,hook_handle,ctrsen,ctrsen);\n\tLOAD_HOOK(hooks,hook_handle,ctrsna,ctrsna);\n\tLOAD_HOOK(hooks,hook_handle,ctrsyl,ctrsyl);\n\tLOAD_HOOK(hooks,hook_handle,ctrti2,ctrti2);\n\tLOAD_HOOK(hooks,hook_handle,ctrtri,ctrtri);\n\tLOAD_HOOK(hooks,hook_handle,ctrtrs,ctrtrs);\n\tLOAD_HOOK(hooks,hook_handle,ctrttf,ctrttf);\n\tLOAD_HOOK(hooks,hook_handle,ctrttp,ctrttp);\n\tLOAD_HOOK(hooks,hook_handle,ctzrqf,ctzrqf);\n\tLOAD_HOOK(hooks,hook_handle,ctzrzf,ctzrzf);\n\tLOAD_HOOK(hooks,hook_handle,cunbdb,cunbdb);\n\tLOAD_HOOK(hooks,hook_handle,cunbdb1,cunbdb1);\n\tLOAD_HOOK(hooks,hook_handle,cunbdb2,cunbdb2);\n\tLOAD_HOOK(hooks,hook_handle,cunbdb3,cunbdb3);\n\tLOAD_HOOK(hooks,hook_handle,cunbdb4,cunbdb4);\n\tLOAD_HOOK(hooks,hook_handle,cunbdb5,cunbdb5);\n\tLOAD_HOOK(hooks,hook_handle,cunbdb6,cunbdb6);\n\tLOAD_HOOK(hooks,hook_handle,cuncsd,cuncsd);\n\tLOAD_HOOK(hooks,hook_handle,cuncsd2by1,cuncsd2by1);\n\tLOAD_HOOK(hooks,hook_handle,cung2l,cung2l);\n\tLOAD_HOOK(hooks,hook_handle,cung2r,cung2r);\n\tLOAD_HOOK(hooks,hook_handle,cungbr,cungbr);\n\tLOAD_HOOK(hooks,hook_handle,cunghr,cunghr);\n\tLOAD_HOOK(hooks,hook_handle,cungl2,cungl2);\n\tLOAD_HOOK(hooks,hook_handle,cunglq,cunglq);\n\tLOAD_HOOK(hooks,hook_handle,cungql,cungql);\n\tLOAD_HOOK(hooks,hook_handle,cungqr,cungqr);\n\tLOAD_HOOK(hooks,hook_handle,cungr2,cungr2);\n\tLOAD_HOOK(hooks,hook_handle,cungrq,cungrq);\n\tLOAD_HOOK(hooks,hook_handle,cungtr,cungtr);\n\tLOAD_HOOK(hooks,hook_handle,cungtsqr,cungtsqr);\n\tLOAD_HOOK(hooks,hook_handle,cunhr_col,cunhr_col);\n\tLOAD_HOOK(hooks,hook_handle,cunm22,cunm22);\n\tLOAD_HOOK(hooks,hook_handle,cunm2l,cunm2l);\n\tLOAD_HOOK(hooks,hook_handle,cunm2r,cunm2r);\n\tLOAD_HOOK(hooks,hook_handle,cunmbr,cunmbr);\n\tLOAD_HOOK(hooks,hook_handle,cunmhr,cunmhr);\n\tLOAD_HOOK(hooks,hook_handle,cunml2,cunml2);\n\tLOAD_HOOK(hooks,hook_handle,cunmlq,cunmlq);\n\tLOAD_HOOK(hooks,hook_handle,cunmql,cunmql);\n\tLOAD_HOOK(hooks,hook_handle,cunmqr,cunmqr);\n\tLOAD_HOOK(hooks,hook_handle,cunmr2,cunmr2);\n\tLOAD_HOOK(hooks,hook_handle,cunmr3,cunmr3);\n\tLOAD_HOOK(hooks,hook_handle,cunmrq,cunmrq);\n\tLOAD_HOOK(hooks,hook_handle,cunmrz,cunmrz);\n\tLOAD_HOOK(hooks,hook_handle,cunmtr,cunmtr);\n\tLOAD_HOOK(hooks,hook_handle,cupgtr,cupgtr);\n\tLOAD_HOOK(hooks,hook_handle,cupmtr,cupmtr);\n\tLOAD_HOOK(hooks,hook_handle,dbbcsd,dbbcsd);\n\tLOAD_HOOK(hooks,hook_handle,dbdsdc,dbdsdc);\n\tLOAD_HOOK(hooks,hook_handle,dbdsqr,dbdsqr);\n\tLOAD_HOOK(hooks,hook_handle,dbdsvdx,dbdsvdx);\n\tLOAD_HOOK(hooks,hook_handle,dcombssq,dcombssq);\n\tLOAD_HOOK(hooks,hook_handle,ddisna,ddisna);\n\tLOAD_HOOK(hooks,hook_handle,dgbbrd,dgbbrd);\n\tLOAD_HOOK(hooks,hook_handle,dgbcon,dgbcon);\n\tLOAD_HOOK(hooks,hook_handle,dgbequ,dgbequ);\n\tLOAD_HOOK(hooks,hook_handle,dgbequb,dgbequb);\n\tLOAD_HOOK(hooks,hook_handle,dgbrfs,dgbrfs);\n\tLOAD_HOOK(hooks,hook_handle,dgbsv,dgbsv);\n\tLOAD_HOOK(hooks,hook_handle,dgbsvx,dgbsvx);\n\tLOAD_HOOK(hooks,hook_handle,dgbtf2,dgbtf2);\n\tLOAD_HOOK(hooks,hook_handle,dgbtrf,dgbtrf);\n\tLOAD_HOOK(hooks,hook_handle,dgbtrs,dgbtrs);\n\tLOAD_HOOK(hooks,hook_handle,dgebak,dgebak);\n\tLOAD_HOOK(hooks,hook_handle,dgebal,dgebal);\n\tLOAD_HOOK(hooks,hook_handle,dgebd2,dgebd2);\n\tLOAD_HOOK(hooks,hook_handle,dgebrd,dgebrd);\n\tLOAD_HOOK(hooks,hook_handle,dgecon,dgecon);\n\tLOAD_HOOK(hooks,hook_handle,dgeequ,dgeequ);\n\tLOAD_HOOK(hooks,hook_handle,dgeequb,dgeequb);\n\tLOAD_HOOK(hooks,hook_handle,dgees,dgees);\n\tLOAD_HOOK(hooks,hook_handle,dgeesx,dgeesx);\n\tLOAD_HOOK(hooks,hook_handle,dgeev,dgeev);\n\tLOAD_HOOK(hooks,hook_handle,dgeevx,dgeevx);\n\tLOAD_HOOK(hooks,hook_handle,dgegs,dgegs);\n\tLOAD_HOOK(hooks,hook_handle,dgegv,dgegv);\n\tLOAD_HOOK(hooks,hook_handle,dgehd2,dgehd2);\n\tLOAD_HOOK(hooks,hook_handle,dgehrd,dgehrd);\n\tLOAD_HOOK(hooks,hook_handle,dgejsv,dgejsv);\n\tLOAD_HOOK(hooks,hook_handle,dgelq,dgelq);\n\tLOAD_HOOK(hooks,hook_handle,dgelq2,dgelq2);\n\tLOAD_HOOK(hooks,hook_handle,dgelqf,dgelqf);\n\tLOAD_HOOK(hooks,hook_handle,dgelqt,dgelqt);\n\tLOAD_HOOK(hooks,hook_handle,dgelqt3,dgelqt3);\n\tLOAD_HOOK(hooks,hook_handle,dgels,dgels);\n\tLOAD_HOOK(hooks,hook_handle,dgelsd,dgelsd);\n\tLOAD_HOOK(hooks,hook_handle,dgelss,dgelss);\n\tLOAD_HOOK(hooks,hook_handle,dgelsx,dgelsx);\n\tLOAD_HOOK(hooks,hook_handle,dgelsy,dgelsy);\n\tLOAD_HOOK(hooks,hook_handle,dgemlq,dgemlq);\n\tLOAD_HOOK(hooks,hook_handle,dgemlqt,dgemlqt);\n\tLOAD_HOOK(hooks,hook_handle,dgemqr,dgemqr);\n\tLOAD_HOOK(hooks,hook_handle,dgemqrt,dgemqrt);\n\tLOAD_HOOK(hooks,hook_handle,dgeql2,dgeql2);\n\tLOAD_HOOK(hooks,hook_handle,dgeqlf,dgeqlf);\n\tLOAD_HOOK(hooks,hook_handle,dgeqp3,dgeqp3);\n\tLOAD_HOOK(hooks,hook_handle,dgeqpf,dgeqpf);\n\tLOAD_HOOK(hooks,hook_handle,dgeqr,dgeqr);\n\tLOAD_HOOK(hooks,hook_handle,dgeqr2,dgeqr2);\n\tLOAD_HOOK(hooks,hook_handle,dgeqr2p,dgeqr2p);\n\tLOAD_HOOK(hooks,hook_handle,dgeqrf,dgeqrf);\n\tLOAD_HOOK(hooks,hook_handle,dgeqrfp,dgeqrfp);\n\tLOAD_HOOK(hooks,hook_handle,dgeqrt,dgeqrt);\n\tLOAD_HOOK(hooks,hook_handle,dgeqrt2,dgeqrt2);\n\tLOAD_HOOK(hooks,hook_handle,dgeqrt3,dgeqrt3);\n\tLOAD_HOOK(hooks,hook_handle,dgerfs,dgerfs);\n\tLOAD_HOOK(hooks,hook_handle,dgerq2,dgerq2);\n\tLOAD_HOOK(hooks,hook_handle,dgerqf,dgerqf);\n\tLOAD_HOOK(hooks,hook_handle,dgesc2,dgesc2);\n\tLOAD_HOOK(hooks,hook_handle,dgesdd,dgesdd);\n\tLOAD_HOOK(hooks,hook_handle,dgesv,dgesv);\n\tLOAD_HOOK(hooks,hook_handle,dgesvd,dgesvd);\n\tLOAD_HOOK(hooks,hook_handle,dgesvdq,dgesvdq);\n\tLOAD_HOOK(hooks,hook_handle,dgesvdx,dgesvdx);\n\tLOAD_HOOK(hooks,hook_handle,dgesvj,dgesvj);\n\tLOAD_HOOK(hooks,hook_handle,dgesvx,dgesvx);\n\tLOAD_HOOK(hooks,hook_handle,dgetc2,dgetc2);\n\tLOAD_HOOK(hooks,hook_handle,dgetf2,dgetf2);\n\tLOAD_HOOK(hooks,hook_handle,dgetrf,dgetrf);\n\tLOAD_HOOK(hooks,hook_handle,dgetrf2,dgetrf2);\n\tLOAD_HOOK(hooks,hook_handle,dgetri,dgetri);\n\tLOAD_HOOK(hooks,hook_handle,dgetrs,dgetrs);\n\tLOAD_HOOK(hooks,hook_handle,dgetsls,dgetsls);\n\tLOAD_HOOK(hooks,hook_handle,dggbak,dggbak);\n\tLOAD_HOOK(hooks,hook_handle,dggbal,dggbal);\n\tLOAD_HOOK(hooks,hook_handle,dgges,dgges);\n\tLOAD_HOOK(hooks,hook_handle,dgges3,dgges3);\n\tLOAD_HOOK(hooks,hook_handle,dggesx,dggesx);\n\tLOAD_HOOK(hooks,hook_handle,dggev,dggev);\n\tLOAD_HOOK(hooks,hook_handle,dggev3,dggev3);\n\tLOAD_HOOK(hooks,hook_handle,dggevx,dggevx);\n\tLOAD_HOOK(hooks,hook_handle,dggglm,dggglm);\n\tLOAD_HOOK(hooks,hook_handle,dgghd3,dgghd3);\n\tLOAD_HOOK(hooks,hook_handle,dgghrd,dgghrd);\n\tLOAD_HOOK(hooks,hook_handle,dgglse,dgglse);\n\tLOAD_HOOK(hooks,hook_handle,dggqrf,dggqrf);\n\tLOAD_HOOK(hooks,hook_handle,dggrqf,dggrqf);\n\tLOAD_HOOK(hooks,hook_handle,dggsvd,dggsvd);\n\tLOAD_HOOK(hooks,hook_handle,dggsvd3,dggsvd3);\n\tLOAD_HOOK(hooks,hook_handle,dggsvp,dggsvp);\n\tLOAD_HOOK(hooks,hook_handle,dggsvp3,dggsvp3);\n\tLOAD_HOOK(hooks,hook_handle,dgsvj0,dgsvj0);\n\tLOAD_HOOK(hooks,hook_handle,dgsvj1,dgsvj1);\n\tLOAD_HOOK(hooks,hook_handle,dgtcon,dgtcon);\n\tLOAD_HOOK(hooks,hook_handle,dgtrfs,dgtrfs);\n\tLOAD_HOOK(hooks,hook_handle,dgtsv,dgtsv);\n\tLOAD_HOOK(hooks,hook_handle,dgtsvx,dgtsvx);\n\tLOAD_HOOK(hooks,hook_handle,dgttrf,dgttrf);\n\tLOAD_HOOK(hooks,hook_handle,dgttrs,dgttrs);\n\tLOAD_HOOK(hooks,hook_handle,dgtts2,dgtts2);\n\tLOAD_HOOK(hooks,hook_handle,dhgeqz,dhgeqz);\n\tLOAD_HOOK(hooks,hook_handle,dhsein,dhsein);\n\tLOAD_HOOK(hooks,hook_handle,dhseqr,dhseqr);\n\tLOAD_HOOK(hooks,hook_handle,disnan,disnan);\n\tLOAD_HOOK(hooks,hook_handle,dlabad,dlabad);\n\tLOAD_HOOK(hooks,hook_handle,dlabrd,dlabrd);\n\tLOAD_HOOK(hooks,hook_handle,dlacn2,dlacn2);\n\tLOAD_HOOK(hooks,hook_handle,dlacon,dlacon);\n\tLOAD_HOOK(hooks,hook_handle,dlacpy,dlacpy);\n\tLOAD_HOOK(hooks,hook_handle,dladiv,dladiv);\n\tLOAD_HOOK(hooks,hook_handle,dladiv1,dladiv1);\n\tLOAD_HOOK(hooks,hook_handle,dladiv2,dladiv2);\n\tLOAD_HOOK(hooks,hook_handle,dlae2,dlae2);\n\tLOAD_HOOK(hooks,hook_handle,dlaebz,dlaebz);\n\tLOAD_HOOK(hooks,hook_handle,dlaed0,dlaed0);\n\tLOAD_HOOK(hooks,hook_handle,dlaed1,dlaed1);\n\tLOAD_HOOK(hooks,hook_handle,dlaed2,dlaed2);\n\tLOAD_HOOK(hooks,hook_handle,dlaed3,dlaed3);\n\tLOAD_HOOK(hooks,hook_handle,dlaed4,dlaed4);\n\tLOAD_HOOK(hooks,hook_handle,dlaed5,dlaed5);\n\tLOAD_HOOK(hooks,hook_handle,dlaed6,dlaed6);\n\tLOAD_HOOK(hooks,hook_handle,dlaed7,dlaed7);\n\tLOAD_HOOK(hooks,hook_handle,dlaed8,dlaed8);\n\tLOAD_HOOK(hooks,hook_handle,dlaed9,dlaed9);\n\tLOAD_HOOK(hooks,hook_handle,dlaeda,dlaeda);\n\tLOAD_HOOK(hooks,hook_handle,dlaein,dlaein);\n\tLOAD_HOOK(hooks,hook_handle,dlaev2,dlaev2);\n\tLOAD_HOOK(hooks,hook_handle,dlaexc,dlaexc);\n\tLOAD_HOOK(hooks,hook_handle,dlag2,dlag2);\n\tLOAD_HOOK(hooks,hook_handle,dlag2s,dlag2s);\n\tLOAD_HOOK(hooks,hook_handle,dlags2,dlags2);\n\tLOAD_HOOK(hooks,hook_handle,dlagtf,dlagtf);\n\tLOAD_HOOK(hooks,hook_handle,dlagtm,dlagtm);\n\tLOAD_HOOK(hooks,hook_handle,dlagts,dlagts);\n\tLOAD_HOOK(hooks,hook_handle,dlagv2,dlagv2);\n\tLOAD_HOOK(hooks,hook_handle,dlahqr,dlahqr);\n\tLOAD_HOOK(hooks,hook_handle,dlahr2,dlahr2);\n\tLOAD_HOOK(hooks,hook_handle,dlahrd,dlahrd);\n\tLOAD_HOOK(hooks,hook_handle,dlaic1,dlaic1);\n\tLOAD_HOOK(hooks,hook_handle,dlaisnan,dlaisnan);\n\tLOAD_HOOK(hooks,hook_handle,dlaln2,dlaln2);\n\tLOAD_HOOK(hooks,hook_handle,dlals0,dlals0);\n\tLOAD_HOOK(hooks,hook_handle,dlalsa,dlalsa);\n\tLOAD_HOOK(hooks,hook_handle,dlalsd,dlalsd);\n\tLOAD_HOOK(hooks,hook_handle,dlamrg,dlamrg);\n\tLOAD_HOOK(hooks,hook_handle,dlamswlq,dlamswlq);\n\tLOAD_HOOK(hooks,hook_handle,dlamtsqr,dlamtsqr);\n\tLOAD_HOOK(hooks,hook_handle,dlaneg,dlaneg);\n\tLOAD_HOOK(hooks,hook_handle,dlangb,dlangb);\n\tLOAD_HOOK(hooks,hook_handle,dlange,dlange);\n\tLOAD_HOOK(hooks,hook_handle,dlangt,dlangt);\n\tLOAD_HOOK(hooks,hook_handle,dlanhs,dlanhs);\n\tLOAD_HOOK(hooks,hook_handle,dlansb,dlansb);\n\tLOAD_HOOK(hooks,hook_handle,dlansf,dlansf);\n\tLOAD_HOOK(hooks,hook_handle,dlansp,dlansp);\n\tLOAD_HOOK(hooks,hook_handle,dlanst,dlanst);\n\tLOAD_HOOK(hooks,hook_handle,dlansy,dlansy);\n\tLOAD_HOOK(hooks,hook_handle,dlantb,dlantb);\n\tLOAD_HOOK(hooks,hook_handle,dlantp,dlantp);\n\tLOAD_HOOK(hooks,hook_handle,dlantr,dlantr);\n\tLOAD_HOOK(hooks,hook_handle,dlanv2,dlanv2);\n\tLOAD_HOOK(hooks,hook_handle,dlaorhr_col_getrfnp,dlaorhr_col_getrfnp);\n\tLOAD_HOOK(hooks,hook_handle,dlaorhr_col_getrfnp2,dlaorhr_col_getrfnp2);\n\tLOAD_HOOK(hooks,hook_handle,dlapll,dlapll);\n\tLOAD_HOOK(hooks,hook_handle,dlapmr,dlapmr);\n\tLOAD_HOOK(hooks,hook_handle,dlapmt,dlapmt);\n\tLOAD_HOOK(hooks,hook_handle,dlapy2,dlapy2);\n\tLOAD_HOOK(hooks,hook_handle,dlapy3,dlapy3);\n\tLOAD_HOOK(hooks,hook_handle,dlaqgb,dlaqgb);\n\tLOAD_HOOK(hooks,hook_handle,dlaqge,dlaqge);\n\tLOAD_HOOK(hooks,hook_handle,dlaqp2,dlaqp2);\n\tLOAD_HOOK(hooks,hook_handle,dlaqps,dlaqps);\n\tLOAD_HOOK(hooks,hook_handle,dlaqr0,dlaqr0);\n\tLOAD_HOOK(hooks,hook_handle,dlaqr1,dlaqr1);\n\tLOAD_HOOK(hooks,hook_handle,dlaqr2,dlaqr2);\n\tLOAD_HOOK(hooks,hook_handle,dlaqr3,dlaqr3);\n\tLOAD_HOOK(hooks,hook_handle,dlaqr4,dlaqr4);\n\tLOAD_HOOK(hooks,hook_handle,dlaqr5,dlaqr5);\n\tLOAD_HOOK(hooks,hook_handle,dlaqsb,dlaqsb);\n\tLOAD_HOOK(hooks,hook_handle,dlaqsp,dlaqsp);\n\tLOAD_HOOK(hooks,hook_handle,dlaqsy,dlaqsy);\n\tLOAD_HOOK(hooks,hook_handle,dlaqtr,dlaqtr);\n\tLOAD_HOOK(hooks,hook_handle,dlar1v,dlar1v);\n\tLOAD_HOOK(hooks,hook_handle,dlar2v,dlar2v);\n\tLOAD_HOOK(hooks,hook_handle,dlarf,dlarf);\n\tLOAD_HOOK(hooks,hook_handle,dlarfb,dlarfb);\n\tLOAD_HOOK(hooks,hook_handle,dlarfg,dlarfg);\n\tLOAD_HOOK(hooks,hook_handle,dlarfgp,dlarfgp);\n\tLOAD_HOOK(hooks,hook_handle,dlarft,dlarft);\n\tLOAD_HOOK(hooks,hook_handle,dlarfx,dlarfx);\n\tLOAD_HOOK(hooks,hook_handle,dlarfy,dlarfy);\n\tLOAD_HOOK(hooks,hook_handle,dlargv,dlargv);\n\tLOAD_HOOK(hooks,hook_handle,dlarnv,dlarnv);\n\tLOAD_HOOK(hooks,hook_handle,dlarra,dlarra);\n\tLOAD_HOOK(hooks,hook_handle,dlarrb,dlarrb);\n\tLOAD_HOOK(hooks,hook_handle,dlarrc,dlarrc);\n\tLOAD_HOOK(hooks,hook_handle,dlarrd,dlarrd);\n\tLOAD_HOOK(hooks,hook_handle,dlarre,dlarre);\n\tLOAD_HOOK(hooks,hook_handle,dlarrf,dlarrf);\n\tLOAD_HOOK(hooks,hook_handle,dlarrj,dlarrj);\n\tLOAD_HOOK(hooks,hook_handle,dlarrk,dlarrk);\n\tLOAD_HOOK(hooks,hook_handle,dlarrr,dlarrr);\n\tLOAD_HOOK(hooks,hook_handle,dlarrv,dlarrv);\n\tLOAD_HOOK(hooks,hook_handle,dlartg,dlartg);\n\tLOAD_HOOK(hooks,hook_handle,dlartgp,dlartgp);\n\tLOAD_HOOK(hooks,hook_handle,dlartgs,dlartgs);\n\tLOAD_HOOK(hooks,hook_handle,dlartv,dlartv);\n\tLOAD_HOOK(hooks,hook_handle,dlaruv,dlaruv);\n\tLOAD_HOOK(hooks,hook_handle,dlarz,dlarz);\n\tLOAD_HOOK(hooks,hook_handle,dlarzb,dlarzb);\n\tLOAD_HOOK(hooks,hook_handle,dlarzt,dlarzt);\n\tLOAD_HOOK(hooks,hook_handle,dlas2,dlas2);\n\tLOAD_HOOK(hooks,hook_handle,dlascl,dlascl);\n\tLOAD_HOOK(hooks,hook_handle,dlasd0,dlasd0);\n\tLOAD_HOOK(hooks,hook_handle,dlasd1,dlasd1);\n\tLOAD_HOOK(hooks,hook_handle,dlasd2,dlasd2);\n\tLOAD_HOOK(hooks,hook_handle,dlasd3,dlasd3);\n\tLOAD_HOOK(hooks,hook_handle,dlasd4,dlasd4);\n\tLOAD_HOOK(hooks,hook_handle,dlasd5,dlasd5);\n\tLOAD_HOOK(hooks,hook_handle,dlasd6,dlasd6);\n\tLOAD_HOOK(hooks,hook_handle,dlasd7,dlasd7);\n\tLOAD_HOOK(hooks,hook_handle,dlasd8,dlasd8);\n\tLOAD_HOOK(hooks,hook_handle,dlasda,dlasda);\n\tLOAD_HOOK(hooks,hook_handle,dlasdq,dlasdq);\n\tLOAD_HOOK(hooks,hook_handle,dlasdt,dlasdt);\n\tLOAD_HOOK(hooks,hook_handle,dlaset,dlaset);\n\tLOAD_HOOK(hooks,hook_handle,dlasq1,dlasq1);\n\tLOAD_HOOK(hooks,hook_handle,dlasq2,dlasq2);\n\tLOAD_HOOK(hooks,hook_handle,dlasq3,dlasq3);\n\tLOAD_HOOK(hooks,hook_handle,dlasq4,dlasq4);\n\tLOAD_HOOK(hooks,hook_handle,dlasq5,dlasq5);\n\tLOAD_HOOK(hooks,hook_handle,dlasq6,dlasq6);\n\tLOAD_HOOK(hooks,hook_handle,dlasr,dlasr);\n\tLOAD_HOOK(hooks,hook_handle,dlasrt,dlasrt);\n\tLOAD_HOOK(hooks,hook_handle,dlassq,dlassq);\n\tLOAD_HOOK(hooks,hook_handle,dlasv2,dlasv2);\n\tLOAD_HOOK(hooks,hook_handle,dlaswlq,dlaswlq);\n\tLOAD_HOOK(hooks,hook_handle,dlaswp,dlaswp);\n\tLOAD_HOOK(hooks,hook_handle,dlasy2,dlasy2);\n\tLOAD_HOOK(hooks,hook_handle,dlasyf,dlasyf);\n\tLOAD_HOOK(hooks,hook_handle,dlasyf_aa,dlasyf_aa);\n\tLOAD_HOOK(hooks,hook_handle,dlasyf_rk,dlasyf_rk);\n\tLOAD_HOOK(hooks,hook_handle,dlasyf_rook,dlasyf_rook);\n\tLOAD_HOOK(hooks,hook_handle,dlat2s,dlat2s);\n\tLOAD_HOOK(hooks,hook_handle,dlatbs,dlatbs);\n\tLOAD_HOOK(hooks,hook_handle,dlatdf,dlatdf);\n\tLOAD_HOOK(hooks,hook_handle,dlatps,dlatps);\n\tLOAD_HOOK(hooks,hook_handle,dlatrd,dlatrd);\n\tLOAD_HOOK(hooks,hook_handle,dlatrs,dlatrs);\n\tLOAD_HOOK(hooks,hook_handle,dlatrz,dlatrz);\n\tLOAD_HOOK(hooks,hook_handle,dlatsqr,dlatsqr);\n\tLOAD_HOOK(hooks,hook_handle,dlatzm,dlatzm);\n\tLOAD_HOOK(hooks,hook_handle,dlauu2,dlauu2);\n\tLOAD_HOOK(hooks,hook_handle,dlauum,dlauum);\n\tLOAD_HOOK(hooks,hook_handle,dopgtr,dopgtr);\n\tLOAD_HOOK(hooks,hook_handle,dopmtr,dopmtr);\n\tLOAD_HOOK(hooks,hook_handle,dorbdb,dorbdb);\n\tLOAD_HOOK(hooks,hook_handle,dorbdb1,dorbdb1);\n\tLOAD_HOOK(hooks,hook_handle,dorbdb2,dorbdb2);\n\tLOAD_HOOK(hooks,hook_handle,dorbdb3,dorbdb3);\n\tLOAD_HOOK(hooks,hook_handle,dorbdb4,dorbdb4);\n\tLOAD_HOOK(hooks,hook_handle,dorbdb5,dorbdb5);\n\tLOAD_HOOK(hooks,hook_handle,dorbdb6,dorbdb6);\n\tLOAD_HOOK(hooks,hook_handle,dorcsd,dorcsd);\n\tLOAD_HOOK(hooks,hook_handle,dorcsd2by1,dorcsd2by1);\n\tLOAD_HOOK(hooks,hook_handle,dorg2l,dorg2l);\n\tLOAD_HOOK(hooks,hook_handle,dorg2r,dorg2r);\n\tLOAD_HOOK(hooks,hook_handle,dorgbr,dorgbr);\n\tLOAD_HOOK(hooks,hook_handle,dorghr,dorghr);\n\tLOAD_HOOK(hooks,hook_handle,dorgl2,dorgl2);\n\tLOAD_HOOK(hooks,hook_handle,dorglq,dorglq);\n\tLOAD_HOOK(hooks,hook_handle,dorgql,dorgql);\n\tLOAD_HOOK(hooks,hook_handle,dorgqr,dorgqr);\n\tLOAD_HOOK(hooks,hook_handle,dorgr2,dorgr2);\n\tLOAD_HOOK(hooks,hook_handle,dorgrq,dorgrq);\n\tLOAD_HOOK(hooks,hook_handle,dorgtr,dorgtr);\n\tLOAD_HOOK(hooks,hook_handle,dorgtsqr,dorgtsqr);\n\tLOAD_HOOK(hooks,hook_handle,dorhr_col,dorhr_col);\n\tLOAD_HOOK(hooks,hook_handle,dorm22,dorm22);\n\tLOAD_HOOK(hooks,hook_handle,dorm2l,dorm2l);\n\tLOAD_HOOK(hooks,hook_handle,dorm2r,dorm2r);\n\tLOAD_HOOK(hooks,hook_handle,dormbr,dormbr);\n\tLOAD_HOOK(hooks,hook_handle,dormhr,dormhr);\n\tLOAD_HOOK(hooks,hook_handle,dorml2,dorml2);\n\tLOAD_HOOK(hooks,hook_handle,dormlq,dormlq);\n\tLOAD_HOOK(hooks,hook_handle,dormql,dormql);\n\tLOAD_HOOK(hooks,hook_handle,dormqr,dormqr);\n\tLOAD_HOOK(hooks,hook_handle,dormr2,dormr2);\n\tLOAD_HOOK(hooks,hook_handle,dormr3,dormr3);\n\tLOAD_HOOK(hooks,hook_handle,dormrq,dormrq);\n\tLOAD_HOOK(hooks,hook_handle,dormrz,dormrz);\n\tLOAD_HOOK(hooks,hook_handle,dormtr,dormtr);\n\tLOAD_HOOK(hooks,hook_handle,dpbcon,dpbcon);\n\tLOAD_HOOK(hooks,hook_handle,dpbequ,dpbequ);\n\tLOAD_HOOK(hooks,hook_handle,dpbrfs,dpbrfs);\n\tLOAD_HOOK(hooks,hook_handle,dpbstf,dpbstf);\n\tLOAD_HOOK(hooks,hook_handle,dpbsv,dpbsv);\n\tLOAD_HOOK(hooks,hook_handle,dpbsvx,dpbsvx);\n\tLOAD_HOOK(hooks,hook_handle,dpbtf2,dpbtf2);\n\tLOAD_HOOK(hooks,hook_handle,dpbtrf,dpbtrf);\n\tLOAD_HOOK(hooks,hook_handle,dpbtrs,dpbtrs);\n\tLOAD_HOOK(hooks,hook_handle,dpftrf,dpftrf);\n\tLOAD_HOOK(hooks,hook_handle,dpftri,dpftri);\n\tLOAD_HOOK(hooks,hook_handle,dpftrs,dpftrs);\n\tLOAD_HOOK(hooks,hook_handle,dpocon,dpocon);\n\tLOAD_HOOK(hooks,hook_handle,dpoequ,dpoequ);\n\tLOAD_HOOK(hooks,hook_handle,dpoequb,dpoequb);\n\tLOAD_HOOK(hooks,hook_handle,dporfs,dporfs);\n\tLOAD_HOOK(hooks,hook_handle,dposv,dposv);\n\tLOAD_HOOK(hooks,hook_handle,dposvx,dposvx);\n\tLOAD_HOOK(hooks,hook_handle,dpotf2,dpotf2);\n\tLOAD_HOOK(hooks,hook_handle,dpotrf,dpotrf);\n\tLOAD_HOOK(hooks,hook_handle,dpotrf2,dpotrf2);\n\tLOAD_HOOK(hooks,hook_handle,dpotri,dpotri);\n\tLOAD_HOOK(hooks,hook_handle,dpotrs,dpotrs);\n\tLOAD_HOOK(hooks,hook_handle,dppcon,dppcon);\n\tLOAD_HOOK(hooks,hook_handle,dppequ,dppequ);\n\tLOAD_HOOK(hooks,hook_handle,dpprfs,dpprfs);\n\tLOAD_HOOK(hooks,hook_handle,dppsv,dppsv);\n\tLOAD_HOOK(hooks,hook_handle,dppsvx,dppsvx);\n\tLOAD_HOOK(hooks,hook_handle,dpptrf,dpptrf);\n\tLOAD_HOOK(hooks,hook_handle,dpptri,dpptri);\n\tLOAD_HOOK(hooks,hook_handle,dpptrs,dpptrs);\n\tLOAD_HOOK(hooks,hook_handle,dpstf2,dpstf2);\n\tLOAD_HOOK(hooks,hook_handle,dpstrf,dpstrf);\n\tLOAD_HOOK(hooks,hook_handle,dptcon,dptcon);\n\tLOAD_HOOK(hooks,hook_handle,dpteqr,dpteqr);\n\tLOAD_HOOK(hooks,hook_handle,dptrfs,dptrfs);\n\tLOAD_HOOK(hooks,hook_handle,dptsv,dptsv);\n\tLOAD_HOOK(hooks,hook_handle,dptsvx,dptsvx);\n\tLOAD_HOOK(hooks,hook_handle,dpttrf,dpttrf);\n\tLOAD_HOOK(hooks,hook_handle,dpttrs,dpttrs);\n\tLOAD_HOOK(hooks,hook_handle,dptts2,dptts2);\n\tLOAD_HOOK(hooks,hook_handle,drscl,drscl);\n\tLOAD_HOOK(hooks,hook_handle,dsb2st_kernels,dsb2st_kernels);\n\tLOAD_HOOK(hooks,hook_handle,dsbev,dsbev);\n\tLOAD_HOOK(hooks,hook_handle,dsbev_2stage,dsbev_2stage);\n\tLOAD_HOOK(hooks,hook_handle,dsbevd,dsbevd);\n\tLOAD_HOOK(hooks,hook_handle,dsbevd_2stage,dsbevd_2stage);\n\tLOAD_HOOK(hooks,hook_handle,dsbevx,dsbevx);\n\tLOAD_HOOK(hooks,hook_handle,dsbevx_2stage,dsbevx_2stage);\n\tLOAD_HOOK(hooks,hook_handle,dsbgst,dsbgst);\n\tLOAD_HOOK(hooks,hook_handle,dsbgv,dsbgv);\n\tLOAD_HOOK(hooks,hook_handle,dsbgvd,dsbgvd);\n\tLOAD_HOOK(hooks,hook_handle,dsbgvx,dsbgvx);\n\tLOAD_HOOK(hooks,hook_handle,dsbtrd,dsbtrd);\n\tLOAD_HOOK(hooks,hook_handle,dsfrk,dsfrk);\n\tLOAD_HOOK(hooks,hook_handle,dsgesv,dsgesv);\n\tLOAD_HOOK(hooks,hook_handle,dspcon,dspcon);\n\tLOAD_HOOK(hooks,hook_handle,dspev,dspev);\n\tLOAD_HOOK(hooks,hook_handle,dspevd,dspevd);\n\tLOAD_HOOK(hooks,hook_handle,dspevx,dspevx);\n\tLOAD_HOOK(hooks,hook_handle,dspgst,dspgst);\n\tLOAD_HOOK(hooks,hook_handle,dspgv,dspgv);\n\tLOAD_HOOK(hooks,hook_handle,dspgvd,dspgvd);\n\tLOAD_HOOK(hooks,hook_handle,dspgvx,dspgvx);\n\tLOAD_HOOK(hooks,hook_handle,dsposv,dsposv);\n\tLOAD_HOOK(hooks,hook_handle,dsprfs,dsprfs);\n\tLOAD_HOOK(hooks,hook_handle,dspsv,dspsv);\n\tLOAD_HOOK(hooks,hook_handle,dspsvx,dspsvx);\n\tLOAD_HOOK(hooks,hook_handle,dsptrd,dsptrd);\n\tLOAD_HOOK(hooks,hook_handle,dsptrf,dsptrf);\n\tLOAD_HOOK(hooks,hook_handle,dsptri,dsptri);\n\tLOAD_HOOK(hooks,hook_handle,dsptrs,dsptrs);\n\tLOAD_HOOK(hooks,hook_handle,dstebz,dstebz);\n\tLOAD_HOOK(hooks,hook_handle,dstedc,dstedc);\n\tLOAD_HOOK(hooks,hook_handle,dstegr,dstegr);\n\tLOAD_HOOK(hooks,hook_handle,dstein,dstein);\n\tLOAD_HOOK(hooks,hook_handle,dstemr,dstemr);\n\tLOAD_HOOK(hooks,hook_handle,dsteqr,dsteqr);\n\tLOAD_HOOK(hooks,hook_handle,dsterf,dsterf);\n\tLOAD_HOOK(hooks,hook_handle,dstev,dstev);\n\tLOAD_HOOK(hooks,hook_handle,dstevd,dstevd);\n\tLOAD_HOOK(hooks,hook_handle,dstevr,dstevr);\n\tLOAD_HOOK(hooks,hook_handle,dstevx,dstevx);\n\tLOAD_HOOK(hooks,hook_handle,dsycon,dsycon);\n\tLOAD_HOOK(hooks,hook_handle,dsycon_3,dsycon_3);\n\tLOAD_HOOK(hooks,hook_handle,dsycon_rook,dsycon_rook);\n\tLOAD_HOOK(hooks,hook_handle,dsyconv,dsyconv);\n\tLOAD_HOOK(hooks,hook_handle,dsyconvf,dsyconvf);\n\tLOAD_HOOK(hooks,hook_handle,dsyconvf_rook,dsyconvf_rook);\n\tLOAD_HOOK(hooks,hook_handle,dsyequb,dsyequb);\n\tLOAD_HOOK(hooks,hook_handle,dsyev,dsyev);\n\tLOAD_HOOK(hooks,hook_handle,dsyev_2stage,dsyev_2stage);\n\tLOAD_HOOK(hooks,hook_handle,dsyevd,dsyevd);\n\tLOAD_HOOK(hooks,hook_handle,dsyevd_2stage,dsyevd_2stage);\n\tLOAD_HOOK(hooks,hook_handle,dsyevr,dsyevr);\n\tLOAD_HOOK(hooks,hook_handle,dsyevr_2stage,dsyevr_2stage);\n\tLOAD_HOOK(hooks,hook_handle,dsyevx,dsyevx);\n\tLOAD_HOOK(hooks,hook_handle,dsyevx_2stage,dsyevx_2stage);\n\tLOAD_HOOK(hooks,hook_handle,dsygs2,dsygs2);\n\tLOAD_HOOK(hooks,hook_handle,dsygst,dsygst);\n\tLOAD_HOOK(hooks,hook_handle,dsygv,dsygv);\n\tLOAD_HOOK(hooks,hook_handle,dsygv_2stage,dsygv_2stage);\n\tLOAD_HOOK(hooks,hook_handle,dsygvd,dsygvd);\n\tLOAD_HOOK(hooks,hook_handle,dsygvx,dsygvx);\n\tLOAD_HOOK(hooks,hook_handle,dsyrfs,dsyrfs);\n\tLOAD_HOOK(hooks,hook_handle,dsysv,dsysv);\n\tLOAD_HOOK(hooks,hook_handle,dsysv_aa,dsysv_aa);\n\tLOAD_HOOK(hooks,hook_handle,dsysv_aa_2stage,dsysv_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,dsysv_rk,dsysv_rk);\n\tLOAD_HOOK(hooks,hook_handle,dsysv_rook,dsysv_rook);\n\tLOAD_HOOK(hooks,hook_handle,dsysvx,dsysvx);\n\tLOAD_HOOK(hooks,hook_handle,dsyswapr,dsyswapr);\n\tLOAD_HOOK(hooks,hook_handle,dsytd2,dsytd2);\n\tLOAD_HOOK(hooks,hook_handle,dsytf2,dsytf2);\n\tLOAD_HOOK(hooks,hook_handle,dsytf2_rk,dsytf2_rk);\n\tLOAD_HOOK(hooks,hook_handle,dsytf2_rook,dsytf2_rook);\n\tLOAD_HOOK(hooks,hook_handle,dsytrd,dsytrd);\n\tLOAD_HOOK(hooks,hook_handle,dsytrd_2stage,dsytrd_2stage);\n\tLOAD_HOOK(hooks,hook_handle,dsytrd_sb2st,dsytrd_sb2st);\n\tLOAD_HOOK(hooks,hook_handle,dsytrd_sy2sb,dsytrd_sy2sb);\n\tLOAD_HOOK(hooks,hook_handle,dsytrf,dsytrf);\n\tLOAD_HOOK(hooks,hook_handle,dsytrf_aa,dsytrf_aa);\n\tLOAD_HOOK(hooks,hook_handle,dsytrf_aa_2stage,dsytrf_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,dsytrf_rk,dsytrf_rk);\n\tLOAD_HOOK(hooks,hook_handle,dsytrf_rook,dsytrf_rook);\n\tLOAD_HOOK(hooks,hook_handle,dsytri,dsytri);\n\tLOAD_HOOK(hooks,hook_handle,dsytri2,dsytri2);\n\tLOAD_HOOK(hooks,hook_handle,dsytri2x,dsytri2x);\n\tLOAD_HOOK(hooks,hook_handle,dsytri_3,dsytri_3);\n\tLOAD_HOOK(hooks,hook_handle,dsytri_3x,dsytri_3x);\n\tLOAD_HOOK(hooks,hook_handle,dsytri_rook,dsytri_rook);\n\tLOAD_HOOK(hooks,hook_handle,dsytrs,dsytrs);\n\tLOAD_HOOK(hooks,hook_handle,dsytrs2,dsytrs2);\n\tLOAD_HOOK(hooks,hook_handle,dsytrs_3,dsytrs_3);\n\tLOAD_HOOK(hooks,hook_handle,dsytrs_aa,dsytrs_aa);\n\tLOAD_HOOK(hooks,hook_handle,dsytrs_aa_2stage,dsytrs_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,dsytrs_rook,dsytrs_rook);\n\tLOAD_HOOK(hooks,hook_handle,dtbcon,dtbcon);\n\tLOAD_HOOK(hooks,hook_handle,dtbrfs,dtbrfs);\n\tLOAD_HOOK(hooks,hook_handle,dtbtrs,dtbtrs);\n\tLOAD_HOOK(hooks,hook_handle,dtfsm,dtfsm);\n\tLOAD_HOOK(hooks,hook_handle,dtftri,dtftri);\n\tLOAD_HOOK(hooks,hook_handle,dtfttp,dtfttp);\n\tLOAD_HOOK(hooks,hook_handle,dtfttr,dtfttr);\n\tLOAD_HOOK(hooks,hook_handle,dtgevc,dtgevc);\n\tLOAD_HOOK(hooks,hook_handle,dtgex2,dtgex2);\n\tLOAD_HOOK(hooks,hook_handle,dtgexc,dtgexc);\n\tLOAD_HOOK(hooks,hook_handle,dtgsen,dtgsen);\n\tLOAD_HOOK(hooks,hook_handle,dtgsja,dtgsja);\n\tLOAD_HOOK(hooks,hook_handle,dtgsna,dtgsna);\n\tLOAD_HOOK(hooks,hook_handle,dtgsy2,dtgsy2);\n\tLOAD_HOOK(hooks,hook_handle,dtgsyl,dtgsyl);\n\tLOAD_HOOK(hooks,hook_handle,dtpcon,dtpcon);\n\tLOAD_HOOK(hooks,hook_handle,dtplqt,dtplqt);\n\tLOAD_HOOK(hooks,hook_handle,dtplqt2,dtplqt2);\n\tLOAD_HOOK(hooks,hook_handle,dtpmlqt,dtpmlqt);\n\tLOAD_HOOK(hooks,hook_handle,dtpmqrt,dtpmqrt);\n\tLOAD_HOOK(hooks,hook_handle,dtpqrt,dtpqrt);\n\tLOAD_HOOK(hooks,hook_handle,dtpqrt2,dtpqrt2);\n\tLOAD_HOOK(hooks,hook_handle,dtprfb,dtprfb);\n\tLOAD_HOOK(hooks,hook_handle,dtprfs,dtprfs);\n\tLOAD_HOOK(hooks,hook_handle,dtptri,dtptri);\n\tLOAD_HOOK(hooks,hook_handle,dtptrs,dtptrs);\n\tLOAD_HOOK(hooks,hook_handle,dtpttf,dtpttf);\n\tLOAD_HOOK(hooks,hook_handle,dtpttr,dtpttr);\n\tLOAD_HOOK(hooks,hook_handle,dtrcon,dtrcon);\n\tLOAD_HOOK(hooks,hook_handle,dtrevc,dtrevc);\n\tLOAD_HOOK(hooks,hook_handle,dtrevc3,dtrevc3);\n\tLOAD_HOOK(hooks,hook_handle,dtrexc,dtrexc);\n\tLOAD_HOOK(hooks,hook_handle,dtrrfs,dtrrfs);\n\tLOAD_HOOK(hooks,hook_handle,dtrsen,dtrsen);\n\tLOAD_HOOK(hooks,hook_handle,dtrsna,dtrsna);\n\tLOAD_HOOK(hooks,hook_handle,dtrsyl,dtrsyl);\n\tLOAD_HOOK(hooks,hook_handle,dtrti2,dtrti2);\n\tLOAD_HOOK(hooks,hook_handle,dtrtri,dtrtri);\n\tLOAD_HOOK(hooks,hook_handle,dtrtrs,dtrtrs);\n\tLOAD_HOOK(hooks,hook_handle,dtrttf,dtrttf);\n\tLOAD_HOOK(hooks,hook_handle,dtrttp,dtrttp);\n\tLOAD_HOOK(hooks,hook_handle,dtzrqf,dtzrqf);\n\tLOAD_HOOK(hooks,hook_handle,dtzrzf,dtzrzf);\n\tLOAD_HOOK(hooks,hook_handle,dzsum1,dzsum1);\n\tLOAD_HOOK(hooks,hook_handle,icmax1,icmax1);\n\tLOAD_HOOK(hooks,hook_handle,ieeeck,ieeeck);\n\tLOAD_HOOK(hooks,hook_handle,ilaclc,ilaclc);\n\tLOAD_HOOK(hooks,hook_handle,ilaclr,ilaclr);\n\tLOAD_HOOK(hooks,hook_handle,iladiag,iladiag);\n\tLOAD_HOOK(hooks,hook_handle,iladlc,iladlc);\n\tLOAD_HOOK(hooks,hook_handle,iladlr,iladlr);\n\tLOAD_HOOK(hooks,hook_handle,ilaenv,ilaenv);\n\tLOAD_HOOK(hooks,hook_handle,ilaenv2stage,ilaenv2stage);\n\tLOAD_HOOK(hooks,hook_handle,ilaprec,ilaprec);\n\tLOAD_HOOK(hooks,hook_handle,ilaslc,ilaslc);\n\tLOAD_HOOK(hooks,hook_handle,ilaslr,ilaslr);\n\tLOAD_HOOK(hooks,hook_handle,ilatrans,ilatrans);\n\tLOAD_HOOK(hooks,hook_handle,ilauplo,ilauplo);\n\tLOAD_HOOK(hooks,hook_handle,ilazlc,ilazlc);\n\tLOAD_HOOK(hooks,hook_handle,ilazlr,ilazlr);\n\tLOAD_HOOK(hooks,hook_handle,iparam2stage,iparam2stage);\n\tLOAD_HOOK(hooks,hook_handle,iparmq,iparmq);\n\tLOAD_HOOK(hooks,hook_handle,izmax1,izmax1);\n\tLOAD_HOOK(hooks,hook_handle,sbbcsd,sbbcsd);\n\tLOAD_HOOK(hooks,hook_handle,sbdsdc,sbdsdc);\n\tLOAD_HOOK(hooks,hook_handle,sbdsqr,sbdsqr);\n\tLOAD_HOOK(hooks,hook_handle,sbdsvdx,sbdsvdx);\n\tLOAD_HOOK(hooks,hook_handle,scombssq,scombssq);\n\tLOAD_HOOK(hooks,hook_handle,scsum1,scsum1);\n\tLOAD_HOOK(hooks,hook_handle,sdisna,sdisna);\n\tLOAD_HOOK(hooks,hook_handle,sgbbrd,sgbbrd);\n\tLOAD_HOOK(hooks,hook_handle,sgbcon,sgbcon);\n\tLOAD_HOOK(hooks,hook_handle,sgbequ,sgbequ);\n\tLOAD_HOOK(hooks,hook_handle,sgbequb,sgbequb);\n\tLOAD_HOOK(hooks,hook_handle,sgbrfs,sgbrfs);\n\tLOAD_HOOK(hooks,hook_handle,sgbsv,sgbsv);\n\tLOAD_HOOK(hooks,hook_handle,sgbsvx,sgbsvx);\n\tLOAD_HOOK(hooks,hook_handle,sgbtf2,sgbtf2);\n\tLOAD_HOOK(hooks,hook_handle,sgbtrf,sgbtrf);\n\tLOAD_HOOK(hooks,hook_handle,sgbtrs,sgbtrs);\n\tLOAD_HOOK(hooks,hook_handle,sgebak,sgebak);\n\tLOAD_HOOK(hooks,hook_handle,sgebal,sgebal);\n\tLOAD_HOOK(hooks,hook_handle,sgebd2,sgebd2);\n\tLOAD_HOOK(hooks,hook_handle,sgebrd,sgebrd);\n\tLOAD_HOOK(hooks,hook_handle,sgecon,sgecon);\n\tLOAD_HOOK(hooks,hook_handle,sgeequ,sgeequ);\n\tLOAD_HOOK(hooks,hook_handle,sgeequb,sgeequb);\n\tLOAD_HOOK(hooks,hook_handle,sgees,sgees);\n\tLOAD_HOOK(hooks,hook_handle,sgeesx,sgeesx);\n\tLOAD_HOOK(hooks,hook_handle,sgeev,sgeev);\n\tLOAD_HOOK(hooks,hook_handle,sgeevx,sgeevx);\n\tLOAD_HOOK(hooks,hook_handle,sgegs,sgegs);\n\tLOAD_HOOK(hooks,hook_handle,sgegv,sgegv);\n\tLOAD_HOOK(hooks,hook_handle,sgehd2,sgehd2);\n\tLOAD_HOOK(hooks,hook_handle,sgehrd,sgehrd);\n\tLOAD_HOOK(hooks,hook_handle,sgejsv,sgejsv);\n\tLOAD_HOOK(hooks,hook_handle,sgelq,sgelq);\n\tLOAD_HOOK(hooks,hook_handle,sgelq2,sgelq2);\n\tLOAD_HOOK(hooks,hook_handle,sgelqf,sgelqf);\n\tLOAD_HOOK(hooks,hook_handle,sgelqt,sgelqt);\n\tLOAD_HOOK(hooks,hook_handle,sgelqt3,sgelqt3);\n\tLOAD_HOOK(hooks,hook_handle,sgels,sgels);\n\tLOAD_HOOK(hooks,hook_handle,sgelsd,sgelsd);\n\tLOAD_HOOK(hooks,hook_handle,sgelss,sgelss);\n\tLOAD_HOOK(hooks,hook_handle,sgelsx,sgelsx);\n\tLOAD_HOOK(hooks,hook_handle,sgelsy,sgelsy);\n\tLOAD_HOOK(hooks,hook_handle,sgemlq,sgemlq);\n\tLOAD_HOOK(hooks,hook_handle,sgemlqt,sgemlqt);\n\tLOAD_HOOK(hooks,hook_handle,sgemqr,sgemqr);\n\tLOAD_HOOK(hooks,hook_handle,sgemqrt,sgemqrt);\n\tLOAD_HOOK(hooks,hook_handle,sgeql2,sgeql2);\n\tLOAD_HOOK(hooks,hook_handle,sgeqlf,sgeqlf);\n\tLOAD_HOOK(hooks,hook_handle,sgeqp3,sgeqp3);\n\tLOAD_HOOK(hooks,hook_handle,sgeqpf,sgeqpf);\n\tLOAD_HOOK(hooks,hook_handle,sgeqr,sgeqr);\n\tLOAD_HOOK(hooks,hook_handle,sgeqr2,sgeqr2);\n\tLOAD_HOOK(hooks,hook_handle,sgeqr2p,sgeqr2p);\n\tLOAD_HOOK(hooks,hook_handle,sgeqrf,sgeqrf);\n\tLOAD_HOOK(hooks,hook_handle,sgeqrfp,sgeqrfp);\n\tLOAD_HOOK(hooks,hook_handle,sgeqrt,sgeqrt);\n\tLOAD_HOOK(hooks,hook_handle,sgeqrt2,sgeqrt2);\n\tLOAD_HOOK(hooks,hook_handle,sgeqrt3,sgeqrt3);\n\tLOAD_HOOK(hooks,hook_handle,sgerfs,sgerfs);\n\tLOAD_HOOK(hooks,hook_handle,sgerq2,sgerq2);\n\tLOAD_HOOK(hooks,hook_handle,sgerqf,sgerqf);\n\tLOAD_HOOK(hooks,hook_handle,sgesc2,sgesc2);\n\tLOAD_HOOK(hooks,hook_handle,sgesdd,sgesdd);\n\tLOAD_HOOK(hooks,hook_handle,sgesv,sgesv);\n\tLOAD_HOOK(hooks,hook_handle,sgesvd,sgesvd);\n\tLOAD_HOOK(hooks,hook_handle,sgesvdq,sgesvdq);\n\tLOAD_HOOK(hooks,hook_handle,sgesvdx,sgesvdx);\n\tLOAD_HOOK(hooks,hook_handle,sgesvj,sgesvj);\n\tLOAD_HOOK(hooks,hook_handle,sgesvx,sgesvx);\n\tLOAD_HOOK(hooks,hook_handle,sgetc2,sgetc2);\n\tLOAD_HOOK(hooks,hook_handle,sgetf2,sgetf2);\n\tLOAD_HOOK(hooks,hook_handle,sgetrf,sgetrf);\n\tLOAD_HOOK(hooks,hook_handle,sgetrf2,sgetrf2);\n\tLOAD_HOOK(hooks,hook_handle,sgetri,sgetri);\n\tLOAD_HOOK(hooks,hook_handle,sgetrs,sgetrs);\n\tLOAD_HOOK(hooks,hook_handle,sgetsls,sgetsls);\n\tLOAD_HOOK(hooks,hook_handle,sggbak,sggbak);\n\tLOAD_HOOK(hooks,hook_handle,sggbal,sggbal);\n\tLOAD_HOOK(hooks,hook_handle,sgges,sgges);\n\tLOAD_HOOK(hooks,hook_handle,sgges3,sgges3);\n\tLOAD_HOOK(hooks,hook_handle,sggesx,sggesx);\n\tLOAD_HOOK(hooks,hook_handle,sggev,sggev);\n\tLOAD_HOOK(hooks,hook_handle,sggev3,sggev3);\n\tLOAD_HOOK(hooks,hook_handle,sggevx,sggevx);\n\tLOAD_HOOK(hooks,hook_handle,sggglm,sggglm);\n\tLOAD_HOOK(hooks,hook_handle,sgghd3,sgghd3);\n\tLOAD_HOOK(hooks,hook_handle,sgghrd,sgghrd);\n\tLOAD_HOOK(hooks,hook_handle,sgglse,sgglse);\n\tLOAD_HOOK(hooks,hook_handle,sggqrf,sggqrf);\n\tLOAD_HOOK(hooks,hook_handle,sggrqf,sggrqf);\n\tLOAD_HOOK(hooks,hook_handle,sggsvd,sggsvd);\n\tLOAD_HOOK(hooks,hook_handle,sggsvd3,sggsvd3);\n\tLOAD_HOOK(hooks,hook_handle,sggsvp,sggsvp);\n\tLOAD_HOOK(hooks,hook_handle,sggsvp3,sggsvp3);\n\tLOAD_HOOK(hooks,hook_handle,sgsvj0,sgsvj0);\n\tLOAD_HOOK(hooks,hook_handle,sgsvj1,sgsvj1);\n\tLOAD_HOOK(hooks,hook_handle,sgtcon,sgtcon);\n\tLOAD_HOOK(hooks,hook_handle,sgtrfs,sgtrfs);\n\tLOAD_HOOK(hooks,hook_handle,sgtsv,sgtsv);\n\tLOAD_HOOK(hooks,hook_handle,sgtsvx,sgtsvx);\n\tLOAD_HOOK(hooks,hook_handle,sgttrf,sgttrf);\n\tLOAD_HOOK(hooks,hook_handle,sgttrs,sgttrs);\n\tLOAD_HOOK(hooks,hook_handle,sgtts2,sgtts2);\n\tLOAD_HOOK(hooks,hook_handle,shgeqz,shgeqz);\n\tLOAD_HOOK(hooks,hook_handle,shsein,shsein);\n\tLOAD_HOOK(hooks,hook_handle,shseqr,shseqr);\n\tLOAD_HOOK(hooks,hook_handle,sisnan,sisnan);\n\tLOAD_HOOK(hooks,hook_handle,slabad,slabad);\n\tLOAD_HOOK(hooks,hook_handle,slabrd,slabrd);\n\tLOAD_HOOK(hooks,hook_handle,slacn2,slacn2);\n\tLOAD_HOOK(hooks,hook_handle,slacon,slacon);\n\tLOAD_HOOK(hooks,hook_handle,slacpy,slacpy);\n\tLOAD_HOOK(hooks,hook_handle,sladiv,sladiv);\n\tLOAD_HOOK(hooks,hook_handle,sladiv1,sladiv1);\n\tLOAD_HOOK(hooks,hook_handle,sladiv2,sladiv2);\n\tLOAD_HOOK(hooks,hook_handle,slae2,slae2);\n\tLOAD_HOOK(hooks,hook_handle,slaebz,slaebz);\n\tLOAD_HOOK(hooks,hook_handle,slaed0,slaed0);\n\tLOAD_HOOK(hooks,hook_handle,slaed1,slaed1);\n\tLOAD_HOOK(hooks,hook_handle,slaed2,slaed2);\n\tLOAD_HOOK(hooks,hook_handle,slaed3,slaed3);\n\tLOAD_HOOK(hooks,hook_handle,slaed4,slaed4);\n\tLOAD_HOOK(hooks,hook_handle,slaed5,slaed5);\n\tLOAD_HOOK(hooks,hook_handle,slaed6,slaed6);\n\tLOAD_HOOK(hooks,hook_handle,slaed7,slaed7);\n\tLOAD_HOOK(hooks,hook_handle,slaed8,slaed8);\n\tLOAD_HOOK(hooks,hook_handle,slaed9,slaed9);\n\tLOAD_HOOK(hooks,hook_handle,slaeda,slaeda);\n\tLOAD_HOOK(hooks,hook_handle,slaein,slaein);\n\tLOAD_HOOK(hooks,hook_handle,slaev2,slaev2);\n\tLOAD_HOOK(hooks,hook_handle,slaexc,slaexc);\n\tLOAD_HOOK(hooks,hook_handle,slag2,slag2);\n\tLOAD_HOOK(hooks,hook_handle,slag2d,slag2d);\n\tLOAD_HOOK(hooks,hook_handle,slags2,slags2);\n\tLOAD_HOOK(hooks,hook_handle,slagtf,slagtf);\n\tLOAD_HOOK(hooks,hook_handle,slagtm,slagtm);\n\tLOAD_HOOK(hooks,hook_handle,slagts,slagts);\n\tLOAD_HOOK(hooks,hook_handle,slagv2,slagv2);\n\tLOAD_HOOK(hooks,hook_handle,slahqr,slahqr);\n\tLOAD_HOOK(hooks,hook_handle,slahr2,slahr2);\n\tLOAD_HOOK(hooks,hook_handle,slahrd,slahrd);\n\tLOAD_HOOK(hooks,hook_handle,slaic1,slaic1);\n\tLOAD_HOOK(hooks,hook_handle,slaisnan,slaisnan);\n\tLOAD_HOOK(hooks,hook_handle,slaln2,slaln2);\n\tLOAD_HOOK(hooks,hook_handle,slals0,slals0);\n\tLOAD_HOOK(hooks,hook_handle,slalsa,slalsa);\n\tLOAD_HOOK(hooks,hook_handle,slalsd,slalsd);\n\tLOAD_HOOK(hooks,hook_handle,slamrg,slamrg);\n\tLOAD_HOOK(hooks,hook_handle,slamswlq,slamswlq);\n\tLOAD_HOOK(hooks,hook_handle,slamtsqr,slamtsqr);\n\tLOAD_HOOK(hooks,hook_handle,slaneg,slaneg);\n\tLOAD_HOOK(hooks,hook_handle,slangb,slangb);\n\tLOAD_HOOK(hooks,hook_handle,slange,slange);\n\tLOAD_HOOK(hooks,hook_handle,slangt,slangt);\n\tLOAD_HOOK(hooks,hook_handle,slanhs,slanhs);\n\tLOAD_HOOK(hooks,hook_handle,slansb,slansb);\n\tLOAD_HOOK(hooks,hook_handle,slansf,slansf);\n\tLOAD_HOOK(hooks,hook_handle,slansp,slansp);\n\tLOAD_HOOK(hooks,hook_handle,slanst,slanst);\n\tLOAD_HOOK(hooks,hook_handle,slansy,slansy);\n\tLOAD_HOOK(hooks,hook_handle,slantb,slantb);\n\tLOAD_HOOK(hooks,hook_handle,slantp,slantp);\n\tLOAD_HOOK(hooks,hook_handle,slantr,slantr);\n\tLOAD_HOOK(hooks,hook_handle,slanv2,slanv2);\n\tLOAD_HOOK(hooks,hook_handle,slaorhr_col_getrfnp,slaorhr_col_getrfnp);\n\tLOAD_HOOK(hooks,hook_handle,slaorhr_col_getrfnp2,slaorhr_col_getrfnp2);\n\tLOAD_HOOK(hooks,hook_handle,slapll,slapll);\n\tLOAD_HOOK(hooks,hook_handle,slapmr,slapmr);\n\tLOAD_HOOK(hooks,hook_handle,slapmt,slapmt);\n\tLOAD_HOOK(hooks,hook_handle,slapy2,slapy2);\n\tLOAD_HOOK(hooks,hook_handle,slapy3,slapy3);\n\tLOAD_HOOK(hooks,hook_handle,slaqgb,slaqgb);\n\tLOAD_HOOK(hooks,hook_handle,slaqge,slaqge);\n\tLOAD_HOOK(hooks,hook_handle,slaqp2,slaqp2);\n\tLOAD_HOOK(hooks,hook_handle,slaqps,slaqps);\n\tLOAD_HOOK(hooks,hook_handle,slaqr0,slaqr0);\n\tLOAD_HOOK(hooks,hook_handle,slaqr1,slaqr1);\n\tLOAD_HOOK(hooks,hook_handle,slaqr2,slaqr2);\n\tLOAD_HOOK(hooks,hook_handle,slaqr3,slaqr3);\n\tLOAD_HOOK(hooks,hook_handle,slaqr4,slaqr4);\n\tLOAD_HOOK(hooks,hook_handle,slaqr5,slaqr5);\n\tLOAD_HOOK(hooks,hook_handle,slaqsb,slaqsb);\n\tLOAD_HOOK(hooks,hook_handle,slaqsp,slaqsp);\n\tLOAD_HOOK(hooks,hook_handle,slaqsy,slaqsy);\n\tLOAD_HOOK(hooks,hook_handle,slaqtr,slaqtr);\n\tLOAD_HOOK(hooks,hook_handle,slar1v,slar1v);\n\tLOAD_HOOK(hooks,hook_handle,slar2v,slar2v);\n\tLOAD_HOOK(hooks,hook_handle,slarf,slarf);\n\tLOAD_HOOK(hooks,hook_handle,slarfb,slarfb);\n\tLOAD_HOOK(hooks,hook_handle,slarfg,slarfg);\n\tLOAD_HOOK(hooks,hook_handle,slarfgp,slarfgp);\n\tLOAD_HOOK(hooks,hook_handle,slarft,slarft);\n\tLOAD_HOOK(hooks,hook_handle,slarfx,slarfx);\n\tLOAD_HOOK(hooks,hook_handle,slarfy,slarfy);\n\tLOAD_HOOK(hooks,hook_handle,slargv,slargv);\n\tLOAD_HOOK(hooks,hook_handle,slarnv,slarnv);\n\tLOAD_HOOK(hooks,hook_handle,slarra,slarra);\n\tLOAD_HOOK(hooks,hook_handle,slarrb,slarrb);\n\tLOAD_HOOK(hooks,hook_handle,slarrc,slarrc);\n\tLOAD_HOOK(hooks,hook_handle,slarrd,slarrd);\n\tLOAD_HOOK(hooks,hook_handle,slarre,slarre);\n\tLOAD_HOOK(hooks,hook_handle,slarrf,slarrf);\n\tLOAD_HOOK(hooks,hook_handle,slarrj,slarrj);\n\tLOAD_HOOK(hooks,hook_handle,slarrk,slarrk);\n\tLOAD_HOOK(hooks,hook_handle,slarrr,slarrr);\n\tLOAD_HOOK(hooks,hook_handle,slarrv,slarrv);\n\tLOAD_HOOK(hooks,hook_handle,slartg,slartg);\n\tLOAD_HOOK(hooks,hook_handle,slartgp,slartgp);\n\tLOAD_HOOK(hooks,hook_handle,slartgs,slartgs);\n\tLOAD_HOOK(hooks,hook_handle,slartv,slartv);\n\tLOAD_HOOK(hooks,hook_handle,slaruv,slaruv);\n\tLOAD_HOOK(hooks,hook_handle,slarz,slarz);\n\tLOAD_HOOK(hooks,hook_handle,slarzb,slarzb);\n\tLOAD_HOOK(hooks,hook_handle,slarzt,slarzt);\n\tLOAD_HOOK(hooks,hook_handle,slas2,slas2);\n\tLOAD_HOOK(hooks,hook_handle,slascl,slascl);\n\tLOAD_HOOK(hooks,hook_handle,slasd0,slasd0);\n\tLOAD_HOOK(hooks,hook_handle,slasd1,slasd1);\n\tLOAD_HOOK(hooks,hook_handle,slasd2,slasd2);\n\tLOAD_HOOK(hooks,hook_handle,slasd3,slasd3);\n\tLOAD_HOOK(hooks,hook_handle,slasd4,slasd4);\n\tLOAD_HOOK(hooks,hook_handle,slasd5,slasd5);\n\tLOAD_HOOK(hooks,hook_handle,slasd6,slasd6);\n\tLOAD_HOOK(hooks,hook_handle,slasd7,slasd7);\n\tLOAD_HOOK(hooks,hook_handle,slasd8,slasd8);\n\tLOAD_HOOK(hooks,hook_handle,slasda,slasda);\n\tLOAD_HOOK(hooks,hook_handle,slasdq,slasdq);\n\tLOAD_HOOK(hooks,hook_handle,slasdt,slasdt);\n\tLOAD_HOOK(hooks,hook_handle,slaset,slaset);\n\tLOAD_HOOK(hooks,hook_handle,slasq1,slasq1);\n\tLOAD_HOOK(hooks,hook_handle,slasq2,slasq2);\n\tLOAD_HOOK(hooks,hook_handle,slasq3,slasq3);\n\tLOAD_HOOK(hooks,hook_handle,slasq4,slasq4);\n\tLOAD_HOOK(hooks,hook_handle,slasq5,slasq5);\n\tLOAD_HOOK(hooks,hook_handle,slasq6,slasq6);\n\tLOAD_HOOK(hooks,hook_handle,slasr,slasr);\n\tLOAD_HOOK(hooks,hook_handle,slasrt,slasrt);\n\tLOAD_HOOK(hooks,hook_handle,slassq,slassq);\n\tLOAD_HOOK(hooks,hook_handle,slasv2,slasv2);\n\tLOAD_HOOK(hooks,hook_handle,slaswlq,slaswlq);\n\tLOAD_HOOK(hooks,hook_handle,slaswp,slaswp);\n\tLOAD_HOOK(hooks,hook_handle,slasy2,slasy2);\n\tLOAD_HOOK(hooks,hook_handle,slasyf,slasyf);\n\tLOAD_HOOK(hooks,hook_handle,slasyf_aa,slasyf_aa);\n\tLOAD_HOOK(hooks,hook_handle,slasyf_rk,slasyf_rk);\n\tLOAD_HOOK(hooks,hook_handle,slasyf_rook,slasyf_rook);\n\tLOAD_HOOK(hooks,hook_handle,slatbs,slatbs);\n\tLOAD_HOOK(hooks,hook_handle,slatdf,slatdf);\n\tLOAD_HOOK(hooks,hook_handle,slatps,slatps);\n\tLOAD_HOOK(hooks,hook_handle,slatrd,slatrd);\n\tLOAD_HOOK(hooks,hook_handle,slatrs,slatrs);\n\tLOAD_HOOK(hooks,hook_handle,slatrz,slatrz);\n\tLOAD_HOOK(hooks,hook_handle,slatsqr,slatsqr);\n\tLOAD_HOOK(hooks,hook_handle,slatzm,slatzm);\n\tLOAD_HOOK(hooks,hook_handle,slauu2,slauu2);\n\tLOAD_HOOK(hooks,hook_handle,slauum,slauum);\n\tLOAD_HOOK(hooks,hook_handle,sopgtr,sopgtr);\n\tLOAD_HOOK(hooks,hook_handle,sopmtr,sopmtr);\n\tLOAD_HOOK(hooks,hook_handle,sorbdb,sorbdb);\n\tLOAD_HOOK(hooks,hook_handle,sorbdb1,sorbdb1);\n\tLOAD_HOOK(hooks,hook_handle,sorbdb2,sorbdb2);\n\tLOAD_HOOK(hooks,hook_handle,sorbdb3,sorbdb3);\n\tLOAD_HOOK(hooks,hook_handle,sorbdb4,sorbdb4);\n\tLOAD_HOOK(hooks,hook_handle,sorbdb5,sorbdb5);\n\tLOAD_HOOK(hooks,hook_handle,sorbdb6,sorbdb6);\n\tLOAD_HOOK(hooks,hook_handle,sorcsd,sorcsd);\n\tLOAD_HOOK(hooks,hook_handle,sorcsd2by1,sorcsd2by1);\n\tLOAD_HOOK(hooks,hook_handle,sorg2l,sorg2l);\n\tLOAD_HOOK(hooks,hook_handle,sorg2r,sorg2r);\n\tLOAD_HOOK(hooks,hook_handle,sorgbr,sorgbr);\n\tLOAD_HOOK(hooks,hook_handle,sorghr,sorghr);\n\tLOAD_HOOK(hooks,hook_handle,sorgl2,sorgl2);\n\tLOAD_HOOK(hooks,hook_handle,sorglq,sorglq);\n\tLOAD_HOOK(hooks,hook_handle,sorgql,sorgql);\n\tLOAD_HOOK(hooks,hook_handle,sorgqr,sorgqr);\n\tLOAD_HOOK(hooks,hook_handle,sorgr2,sorgr2);\n\tLOAD_HOOK(hooks,hook_handle,sorgrq,sorgrq);\n\tLOAD_HOOK(hooks,hook_handle,sorgtr,sorgtr);\n\tLOAD_HOOK(hooks,hook_handle,sorgtsqr,sorgtsqr);\n\tLOAD_HOOK(hooks,hook_handle,sorhr_col,sorhr_col);\n\tLOAD_HOOK(hooks,hook_handle,sorm22,sorm22);\n\tLOAD_HOOK(hooks,hook_handle,sorm2l,sorm2l);\n\tLOAD_HOOK(hooks,hook_handle,sorm2r,sorm2r);\n\tLOAD_HOOK(hooks,hook_handle,sormbr,sormbr);\n\tLOAD_HOOK(hooks,hook_handle,sormhr,sormhr);\n\tLOAD_HOOK(hooks,hook_handle,sorml2,sorml2);\n\tLOAD_HOOK(hooks,hook_handle,sormlq,sormlq);\n\tLOAD_HOOK(hooks,hook_handle,sormql,sormql);\n\tLOAD_HOOK(hooks,hook_handle,sormqr,sormqr);\n\tLOAD_HOOK(hooks,hook_handle,sormr2,sormr2);\n\tLOAD_HOOK(hooks,hook_handle,sormr3,sormr3);\n\tLOAD_HOOK(hooks,hook_handle,sormrq,sormrq);\n\tLOAD_HOOK(hooks,hook_handle,sormrz,sormrz);\n\tLOAD_HOOK(hooks,hook_handle,sormtr,sormtr);\n\tLOAD_HOOK(hooks,hook_handle,spbcon,spbcon);\n\tLOAD_HOOK(hooks,hook_handle,spbequ,spbequ);\n\tLOAD_HOOK(hooks,hook_handle,spbrfs,spbrfs);\n\tLOAD_HOOK(hooks,hook_handle,spbstf,spbstf);\n\tLOAD_HOOK(hooks,hook_handle,spbsv,spbsv);\n\tLOAD_HOOK(hooks,hook_handle,spbsvx,spbsvx);\n\tLOAD_HOOK(hooks,hook_handle,spbtf2,spbtf2);\n\tLOAD_HOOK(hooks,hook_handle,spbtrf,spbtrf);\n\tLOAD_HOOK(hooks,hook_handle,spbtrs,spbtrs);\n\tLOAD_HOOK(hooks,hook_handle,spftrf,spftrf);\n\tLOAD_HOOK(hooks,hook_handle,spftri,spftri);\n\tLOAD_HOOK(hooks,hook_handle,spftrs,spftrs);\n\tLOAD_HOOK(hooks,hook_handle,spocon,spocon);\n\tLOAD_HOOK(hooks,hook_handle,spoequ,spoequ);\n\tLOAD_HOOK(hooks,hook_handle,spoequb,spoequb);\n\tLOAD_HOOK(hooks,hook_handle,sporfs,sporfs);\n\tLOAD_HOOK(hooks,hook_handle,sposv,sposv);\n\tLOAD_HOOK(hooks,hook_handle,sposvx,sposvx);\n\tLOAD_HOOK(hooks,hook_handle,spotf2,spotf2);\n\tLOAD_HOOK(hooks,hook_handle,spotrf,spotrf);\n\tLOAD_HOOK(hooks,hook_handle,spotrf2,spotrf2);\n\tLOAD_HOOK(hooks,hook_handle,spotri,spotri);\n\tLOAD_HOOK(hooks,hook_handle,spotrs,spotrs);\n\tLOAD_HOOK(hooks,hook_handle,sppcon,sppcon);\n\tLOAD_HOOK(hooks,hook_handle,sppequ,sppequ);\n\tLOAD_HOOK(hooks,hook_handle,spprfs,spprfs);\n\tLOAD_HOOK(hooks,hook_handle,sppsv,sppsv);\n\tLOAD_HOOK(hooks,hook_handle,sppsvx,sppsvx);\n\tLOAD_HOOK(hooks,hook_handle,spptrf,spptrf);\n\tLOAD_HOOK(hooks,hook_handle,spptri,spptri);\n\tLOAD_HOOK(hooks,hook_handle,spptrs,spptrs);\n\tLOAD_HOOK(hooks,hook_handle,spstf2,spstf2);\n\tLOAD_HOOK(hooks,hook_handle,spstrf,spstrf);\n\tLOAD_HOOK(hooks,hook_handle,sptcon,sptcon);\n\tLOAD_HOOK(hooks,hook_handle,spteqr,spteqr);\n\tLOAD_HOOK(hooks,hook_handle,sptrfs,sptrfs);\n\tLOAD_HOOK(hooks,hook_handle,sptsv,sptsv);\n\tLOAD_HOOK(hooks,hook_handle,sptsvx,sptsvx);\n\tLOAD_HOOK(hooks,hook_handle,spttrf,spttrf);\n\tLOAD_HOOK(hooks,hook_handle,spttrs,spttrs);\n\tLOAD_HOOK(hooks,hook_handle,sptts2,sptts2);\n\tLOAD_HOOK(hooks,hook_handle,srscl,srscl);\n\tLOAD_HOOK(hooks,hook_handle,ssb2st_kernels,ssb2st_kernels);\n\tLOAD_HOOK(hooks,hook_handle,ssbev,ssbev);\n\tLOAD_HOOK(hooks,hook_handle,ssbev_2stage,ssbev_2stage);\n\tLOAD_HOOK(hooks,hook_handle,ssbevd,ssbevd);\n\tLOAD_HOOK(hooks,hook_handle,ssbevd_2stage,ssbevd_2stage);\n\tLOAD_HOOK(hooks,hook_handle,ssbevx,ssbevx);\n\tLOAD_HOOK(hooks,hook_handle,ssbevx_2stage,ssbevx_2stage);\n\tLOAD_HOOK(hooks,hook_handle,ssbgst,ssbgst);\n\tLOAD_HOOK(hooks,hook_handle,ssbgv,ssbgv);\n\tLOAD_HOOK(hooks,hook_handle,ssbgvd,ssbgvd);\n\tLOAD_HOOK(hooks,hook_handle,ssbgvx,ssbgvx);\n\tLOAD_HOOK(hooks,hook_handle,ssbtrd,ssbtrd);\n\tLOAD_HOOK(hooks,hook_handle,ssfrk,ssfrk);\n\tLOAD_HOOK(hooks,hook_handle,sspcon,sspcon);\n\tLOAD_HOOK(hooks,hook_handle,sspev,sspev);\n\tLOAD_HOOK(hooks,hook_handle,sspevd,sspevd);\n\tLOAD_HOOK(hooks,hook_handle,sspevx,sspevx);\n\tLOAD_HOOK(hooks,hook_handle,sspgst,sspgst);\n\tLOAD_HOOK(hooks,hook_handle,sspgv,sspgv);\n\tLOAD_HOOK(hooks,hook_handle,sspgvd,sspgvd);\n\tLOAD_HOOK(hooks,hook_handle,sspgvx,sspgvx);\n\tLOAD_HOOK(hooks,hook_handle,ssprfs,ssprfs);\n\tLOAD_HOOK(hooks,hook_handle,sspsv,sspsv);\n\tLOAD_HOOK(hooks,hook_handle,sspsvx,sspsvx);\n\tLOAD_HOOK(hooks,hook_handle,ssptrd,ssptrd);\n\tLOAD_HOOK(hooks,hook_handle,ssptrf,ssptrf);\n\tLOAD_HOOK(hooks,hook_handle,ssptri,ssptri);\n\tLOAD_HOOK(hooks,hook_handle,ssptrs,ssptrs);\n\tLOAD_HOOK(hooks,hook_handle,sstebz,sstebz);\n\tLOAD_HOOK(hooks,hook_handle,sstedc,sstedc);\n\tLOAD_HOOK(hooks,hook_handle,sstegr,sstegr);\n\tLOAD_HOOK(hooks,hook_handle,sstein,sstein);\n\tLOAD_HOOK(hooks,hook_handle,sstemr,sstemr);\n\tLOAD_HOOK(hooks,hook_handle,ssteqr,ssteqr);\n\tLOAD_HOOK(hooks,hook_handle,ssterf,ssterf);\n\tLOAD_HOOK(hooks,hook_handle,sstev,sstev);\n\tLOAD_HOOK(hooks,hook_handle,sstevd,sstevd);\n\tLOAD_HOOK(hooks,hook_handle,sstevr,sstevr);\n\tLOAD_HOOK(hooks,hook_handle,sstevx,sstevx);\n\tLOAD_HOOK(hooks,hook_handle,ssycon,ssycon);\n\tLOAD_HOOK(hooks,hook_handle,ssycon_3,ssycon_3);\n\tLOAD_HOOK(hooks,hook_handle,ssycon_rook,ssycon_rook);\n\tLOAD_HOOK(hooks,hook_handle,ssyconv,ssyconv);\n\tLOAD_HOOK(hooks,hook_handle,ssyconvf,ssyconvf);\n\tLOAD_HOOK(hooks,hook_handle,ssyconvf_rook,ssyconvf_rook);\n\tLOAD_HOOK(hooks,hook_handle,ssyequb,ssyequb);\n\tLOAD_HOOK(hooks,hook_handle,ssyev,ssyev);\n\tLOAD_HOOK(hooks,hook_handle,ssyev_2stage,ssyev_2stage);\n\tLOAD_HOOK(hooks,hook_handle,ssyevd,ssyevd);\n\tLOAD_HOOK(hooks,hook_handle,ssyevd_2stage,ssyevd_2stage);\n\tLOAD_HOOK(hooks,hook_handle,ssyevr,ssyevr);\n\tLOAD_HOOK(hooks,hook_handle,ssyevr_2stage,ssyevr_2stage);\n\tLOAD_HOOK(hooks,hook_handle,ssyevx,ssyevx);\n\tLOAD_HOOK(hooks,hook_handle,ssyevx_2stage,ssyevx_2stage);\n\tLOAD_HOOK(hooks,hook_handle,ssygs2,ssygs2);\n\tLOAD_HOOK(hooks,hook_handle,ssygst,ssygst);\n\tLOAD_HOOK(hooks,hook_handle,ssygv,ssygv);\n\tLOAD_HOOK(hooks,hook_handle,ssygv_2stage,ssygv_2stage);\n\tLOAD_HOOK(hooks,hook_handle,ssygvd,ssygvd);\n\tLOAD_HOOK(hooks,hook_handle,ssygvx,ssygvx);\n\tLOAD_HOOK(hooks,hook_handle,ssyrfs,ssyrfs);\n\tLOAD_HOOK(hooks,hook_handle,ssysv,ssysv);\n\tLOAD_HOOK(hooks,hook_handle,ssysv_aa,ssysv_aa);\n\tLOAD_HOOK(hooks,hook_handle,ssysv_aa_2stage,ssysv_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,ssysv_rk,ssysv_rk);\n\tLOAD_HOOK(hooks,hook_handle,ssysv_rook,ssysv_rook);\n\tLOAD_HOOK(hooks,hook_handle,ssysvx,ssysvx);\n\tLOAD_HOOK(hooks,hook_handle,ssyswapr,ssyswapr);\n\tLOAD_HOOK(hooks,hook_handle,ssytd2,ssytd2);\n\tLOAD_HOOK(hooks,hook_handle,ssytf2,ssytf2);\n\tLOAD_HOOK(hooks,hook_handle,ssytf2_rk,ssytf2_rk);\n\tLOAD_HOOK(hooks,hook_handle,ssytf2_rook,ssytf2_rook);\n\tLOAD_HOOK(hooks,hook_handle,ssytrd,ssytrd);\n\tLOAD_HOOK(hooks,hook_handle,ssytrd_2stage,ssytrd_2stage);\n\tLOAD_HOOK(hooks,hook_handle,ssytrd_sb2st,ssytrd_sb2st);\n\tLOAD_HOOK(hooks,hook_handle,ssytrd_sy2sb,ssytrd_sy2sb);\n\tLOAD_HOOK(hooks,hook_handle,ssytrf,ssytrf);\n\tLOAD_HOOK(hooks,hook_handle,ssytrf_aa,ssytrf_aa);\n\tLOAD_HOOK(hooks,hook_handle,ssytrf_aa_2stage,ssytrf_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,ssytrf_rk,ssytrf_rk);\n\tLOAD_HOOK(hooks,hook_handle,ssytrf_rook,ssytrf_rook);\n\tLOAD_HOOK(hooks,hook_handle,ssytri,ssytri);\n\tLOAD_HOOK(hooks,hook_handle,ssytri2,ssytri2);\n\tLOAD_HOOK(hooks,hook_handle,ssytri2x,ssytri2x);\n\tLOAD_HOOK(hooks,hook_handle,ssytri_3,ssytri_3);\n\tLOAD_HOOK(hooks,hook_handle,ssytri_3x,ssytri_3x);\n\tLOAD_HOOK(hooks,hook_handle,ssytri_rook,ssytri_rook);\n\tLOAD_HOOK(hooks,hook_handle,ssytrs,ssytrs);\n\tLOAD_HOOK(hooks,hook_handle,ssytrs2,ssytrs2);\n\tLOAD_HOOK(hooks,hook_handle,ssytrs_3,ssytrs_3);\n\tLOAD_HOOK(hooks,hook_handle,ssytrs_aa,ssytrs_aa);\n\tLOAD_HOOK(hooks,hook_handle,ssytrs_aa_2stage,ssytrs_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,ssytrs_rook,ssytrs_rook);\n\tLOAD_HOOK(hooks,hook_handle,stbcon,stbcon);\n\tLOAD_HOOK(hooks,hook_handle,stbrfs,stbrfs);\n\tLOAD_HOOK(hooks,hook_handle,stbtrs,stbtrs);\n\tLOAD_HOOK(hooks,hook_handle,stfsm,stfsm);\n\tLOAD_HOOK(hooks,hook_handle,stftri,stftri);\n\tLOAD_HOOK(hooks,hook_handle,stfttp,stfttp);\n\tLOAD_HOOK(hooks,hook_handle,stfttr,stfttr);\n\tLOAD_HOOK(hooks,hook_handle,stgevc,stgevc);\n\tLOAD_HOOK(hooks,hook_handle,stgex2,stgex2);\n\tLOAD_HOOK(hooks,hook_handle,stgexc,stgexc);\n\tLOAD_HOOK(hooks,hook_handle,stgsen,stgsen);\n\tLOAD_HOOK(hooks,hook_handle,stgsja,stgsja);\n\tLOAD_HOOK(hooks,hook_handle,stgsna,stgsna);\n\tLOAD_HOOK(hooks,hook_handle,stgsy2,stgsy2);\n\tLOAD_HOOK(hooks,hook_handle,stgsyl,stgsyl);\n\tLOAD_HOOK(hooks,hook_handle,stpcon,stpcon);\n\tLOAD_HOOK(hooks,hook_handle,stplqt,stplqt);\n\tLOAD_HOOK(hooks,hook_handle,stplqt2,stplqt2);\n\tLOAD_HOOK(hooks,hook_handle,stpmlqt,stpmlqt);\n\tLOAD_HOOK(hooks,hook_handle,stpmqrt,stpmqrt);\n\tLOAD_HOOK(hooks,hook_handle,stpqrt,stpqrt);\n\tLOAD_HOOK(hooks,hook_handle,stpqrt2,stpqrt2);\n\tLOAD_HOOK(hooks,hook_handle,stprfb,stprfb);\n\tLOAD_HOOK(hooks,hook_handle,stprfs,stprfs);\n\tLOAD_HOOK(hooks,hook_handle,stptri,stptri);\n\tLOAD_HOOK(hooks,hook_handle,stptrs,stptrs);\n\tLOAD_HOOK(hooks,hook_handle,stpttf,stpttf);\n\tLOAD_HOOK(hooks,hook_handle,stpttr,stpttr);\n\tLOAD_HOOK(hooks,hook_handle,strcon,strcon);\n\tLOAD_HOOK(hooks,hook_handle,strevc,strevc);\n\tLOAD_HOOK(hooks,hook_handle,strevc3,strevc3);\n\tLOAD_HOOK(hooks,hook_handle,strexc,strexc);\n\tLOAD_HOOK(hooks,hook_handle,strrfs,strrfs);\n\tLOAD_HOOK(hooks,hook_handle,strsen,strsen);\n\tLOAD_HOOK(hooks,hook_handle,strsna,strsna);\n\tLOAD_HOOK(hooks,hook_handle,strsyl,strsyl);\n\tLOAD_HOOK(hooks,hook_handle,strti2,strti2);\n\tLOAD_HOOK(hooks,hook_handle,strtri,strtri);\n\tLOAD_HOOK(hooks,hook_handle,strtrs,strtrs);\n\tLOAD_HOOK(hooks,hook_handle,strttf,strttf);\n\tLOAD_HOOK(hooks,hook_handle,strttp,strttp);\n\tLOAD_HOOK(hooks,hook_handle,stzrqf,stzrqf);\n\tLOAD_HOOK(hooks,hook_handle,stzrzf,stzrzf);\n\tLOAD_HOOK(hooks,hook_handle,xerbla_array,xerbla_array);\n\tLOAD_HOOK(hooks,hook_handle,zbbcsd,zbbcsd);\n\tLOAD_HOOK(hooks,hook_handle,zbdsqr,zbdsqr);\n\tLOAD_HOOK(hooks,hook_handle,zcgesv,zcgesv);\n\tLOAD_HOOK(hooks,hook_handle,zcposv,zcposv);\n\tLOAD_HOOK(hooks,hook_handle,zdrscl,zdrscl);\n\tLOAD_HOOK(hooks,hook_handle,zgbbrd,zgbbrd);\n\tLOAD_HOOK(hooks,hook_handle,zgbcon,zgbcon);\n\tLOAD_HOOK(hooks,hook_handle,zgbequ,zgbequ);\n\tLOAD_HOOK(hooks,hook_handle,zgbequb,zgbequb);\n\tLOAD_HOOK(hooks,hook_handle,zgbrfs,zgbrfs);\n\tLOAD_HOOK(hooks,hook_handle,zgbsv,zgbsv);\n\tLOAD_HOOK(hooks,hook_handle,zgbsvx,zgbsvx);\n\tLOAD_HOOK(hooks,hook_handle,zgbtf2,zgbtf2);\n\tLOAD_HOOK(hooks,hook_handle,zgbtrf,zgbtrf);\n\tLOAD_HOOK(hooks,hook_handle,zgbtrs,zgbtrs);\n\tLOAD_HOOK(hooks,hook_handle,zgebak,zgebak);\n\tLOAD_HOOK(hooks,hook_handle,zgebal,zgebal);\n\tLOAD_HOOK(hooks,hook_handle,zgebd2,zgebd2);\n\tLOAD_HOOK(hooks,hook_handle,zgebrd,zgebrd);\n\tLOAD_HOOK(hooks,hook_handle,zgecon,zgecon);\n\tLOAD_HOOK(hooks,hook_handle,zgeequ,zgeequ);\n\tLOAD_HOOK(hooks,hook_handle,zgeequb,zgeequb);\n\tLOAD_HOOK(hooks,hook_handle,zgees,zgees);\n\tLOAD_HOOK(hooks,hook_handle,zgeesx,zgeesx);\n\tLOAD_HOOK(hooks,hook_handle,zgeev,zgeev);\n\tLOAD_HOOK(hooks,hook_handle,zgeevx,zgeevx);\n\tLOAD_HOOK(hooks,hook_handle,zgegs,zgegs);\n\tLOAD_HOOK(hooks,hook_handle,zgegv,zgegv);\n\tLOAD_HOOK(hooks,hook_handle,zgehd2,zgehd2);\n\tLOAD_HOOK(hooks,hook_handle,zgehrd,zgehrd);\n\tLOAD_HOOK(hooks,hook_handle,zgejsv,zgejsv);\n\tLOAD_HOOK(hooks,hook_handle,zgelq,zgelq);\n\tLOAD_HOOK(hooks,hook_handle,zgelq2,zgelq2);\n\tLOAD_HOOK(hooks,hook_handle,zgelqf,zgelqf);\n\tLOAD_HOOK(hooks,hook_handle,zgelqt,zgelqt);\n\tLOAD_HOOK(hooks,hook_handle,zgelqt3,zgelqt3);\n\tLOAD_HOOK(hooks,hook_handle,zgels,zgels);\n\tLOAD_HOOK(hooks,hook_handle,zgelsd,zgelsd);\n\tLOAD_HOOK(hooks,hook_handle,zgelss,zgelss);\n\tLOAD_HOOK(hooks,hook_handle,zgelsx,zgelsx);\n\tLOAD_HOOK(hooks,hook_handle,zgelsy,zgelsy);\n\tLOAD_HOOK(hooks,hook_handle,zgemlq,zgemlq);\n\tLOAD_HOOK(hooks,hook_handle,zgemlqt,zgemlqt);\n\tLOAD_HOOK(hooks,hook_handle,zgemqr,zgemqr);\n\tLOAD_HOOK(hooks,hook_handle,zgemqrt,zgemqrt);\n\tLOAD_HOOK(hooks,hook_handle,zgeql2,zgeql2);\n\tLOAD_HOOK(hooks,hook_handle,zgeqlf,zgeqlf);\n\tLOAD_HOOK(hooks,hook_handle,zgeqp3,zgeqp3);\n\tLOAD_HOOK(hooks,hook_handle,zgeqpf,zgeqpf);\n\tLOAD_HOOK(hooks,hook_handle,zgeqr,zgeqr);\n\tLOAD_HOOK(hooks,hook_handle,zgeqr2,zgeqr2);\n\tLOAD_HOOK(hooks,hook_handle,zgeqr2p,zgeqr2p);\n\tLOAD_HOOK(hooks,hook_handle,zgeqrf,zgeqrf);\n\tLOAD_HOOK(hooks,hook_handle,zgeqrfp,zgeqrfp);\n\tLOAD_HOOK(hooks,hook_handle,zgeqrt,zgeqrt);\n\tLOAD_HOOK(hooks,hook_handle,zgeqrt2,zgeqrt2);\n\tLOAD_HOOK(hooks,hook_handle,zgeqrt3,zgeqrt3);\n\tLOAD_HOOK(hooks,hook_handle,zgerfs,zgerfs);\n\tLOAD_HOOK(hooks,hook_handle,zgerq2,zgerq2);\n\tLOAD_HOOK(hooks,hook_handle,zgerqf,zgerqf);\n\tLOAD_HOOK(hooks,hook_handle,zgesc2,zgesc2);\n\tLOAD_HOOK(hooks,hook_handle,zgesdd,zgesdd);\n\tLOAD_HOOK(hooks,hook_handle,zgesv,zgesv);\n\tLOAD_HOOK(hooks,hook_handle,zgesvd,zgesvd);\n\tLOAD_HOOK(hooks,hook_handle,zgesvdq,zgesvdq);\n\tLOAD_HOOK(hooks,hook_handle,zgesvdx,zgesvdx);\n\tLOAD_HOOK(hooks,hook_handle,zgesvj,zgesvj);\n\tLOAD_HOOK(hooks,hook_handle,zgesvx,zgesvx);\n\tLOAD_HOOK(hooks,hook_handle,zgetc2,zgetc2);\n\tLOAD_HOOK(hooks,hook_handle,zgetf2,zgetf2);\n\tLOAD_HOOK(hooks,hook_handle,zgetrf,zgetrf);\n\tLOAD_HOOK(hooks,hook_handle,zgetrf2,zgetrf2);\n\tLOAD_HOOK(hooks,hook_handle,zgetri,zgetri);\n\tLOAD_HOOK(hooks,hook_handle,zgetrs,zgetrs);\n\tLOAD_HOOK(hooks,hook_handle,zgetsls,zgetsls);\n\tLOAD_HOOK(hooks,hook_handle,zggbak,zggbak);\n\tLOAD_HOOK(hooks,hook_handle,zggbal,zggbal);\n\tLOAD_HOOK(hooks,hook_handle,zgges,zgges);\n\tLOAD_HOOK(hooks,hook_handle,zgges3,zgges3);\n\tLOAD_HOOK(hooks,hook_handle,zggesx,zggesx);\n\tLOAD_HOOK(hooks,hook_handle,zggev,zggev);\n\tLOAD_HOOK(hooks,hook_handle,zggev3,zggev3);\n\tLOAD_HOOK(hooks,hook_handle,zggevx,zggevx);\n\tLOAD_HOOK(hooks,hook_handle,zggglm,zggglm);\n\tLOAD_HOOK(hooks,hook_handle,zgghd3,zgghd3);\n\tLOAD_HOOK(hooks,hook_handle,zgghrd,zgghrd);\n\tLOAD_HOOK(hooks,hook_handle,zgglse,zgglse);\n\tLOAD_HOOK(hooks,hook_handle,zggqrf,zggqrf);\n\tLOAD_HOOK(hooks,hook_handle,zggrqf,zggrqf);\n\tLOAD_HOOK(hooks,hook_handle,zggsvd,zggsvd);\n\tLOAD_HOOK(hooks,hook_handle,zggsvd3,zggsvd3);\n\tLOAD_HOOK(hooks,hook_handle,zggsvp,zggsvp);\n\tLOAD_HOOK(hooks,hook_handle,zggsvp3,zggsvp3);\n\tLOAD_HOOK(hooks,hook_handle,zgsvj0,zgsvj0);\n\tLOAD_HOOK(hooks,hook_handle,zgsvj1,zgsvj1);\n\tLOAD_HOOK(hooks,hook_handle,zgtcon,zgtcon);\n\tLOAD_HOOK(hooks,hook_handle,zgtrfs,zgtrfs);\n\tLOAD_HOOK(hooks,hook_handle,zgtsv,zgtsv);\n\tLOAD_HOOK(hooks,hook_handle,zgtsvx,zgtsvx);\n\tLOAD_HOOK(hooks,hook_handle,zgttrf,zgttrf);\n\tLOAD_HOOK(hooks,hook_handle,zgttrs,zgttrs);\n\tLOAD_HOOK(hooks,hook_handle,zgtts2,zgtts2);\n\tLOAD_HOOK(hooks,hook_handle,zhb2st_kernels,zhb2st_kernels);\n\tLOAD_HOOK(hooks,hook_handle,zhbev,zhbev);\n\tLOAD_HOOK(hooks,hook_handle,zhbev_2stage,zhbev_2stage);\n\tLOAD_HOOK(hooks,hook_handle,zhbevd,zhbevd);\n\tLOAD_HOOK(hooks,hook_handle,zhbevd_2stage,zhbevd_2stage);\n\tLOAD_HOOK(hooks,hook_handle,zhbevx,zhbevx);\n\tLOAD_HOOK(hooks,hook_handle,zhbevx_2stage,zhbevx_2stage);\n\tLOAD_HOOK(hooks,hook_handle,zhbgst,zhbgst);\n\tLOAD_HOOK(hooks,hook_handle,zhbgv,zhbgv);\n\tLOAD_HOOK(hooks,hook_handle,zhbgvd,zhbgvd);\n\tLOAD_HOOK(hooks,hook_handle,zhbgvx,zhbgvx);\n\tLOAD_HOOK(hooks,hook_handle,zhbtrd,zhbtrd);\n\tLOAD_HOOK(hooks,hook_handle,zhecon,zhecon);\n\tLOAD_HOOK(hooks,hook_handle,zhecon_3,zhecon_3);\n\tLOAD_HOOK(hooks,hook_handle,zhecon_rook,zhecon_rook);\n\tLOAD_HOOK(hooks,hook_handle,zheequb,zheequb);\n\tLOAD_HOOK(hooks,hook_handle,zheev,zheev);\n\tLOAD_HOOK(hooks,hook_handle,zheev_2stage,zheev_2stage);\n\tLOAD_HOOK(hooks,hook_handle,zheevd,zheevd);\n\tLOAD_HOOK(hooks,hook_handle,zheevd_2stage,zheevd_2stage);\n\tLOAD_HOOK(hooks,hook_handle,zheevr,zheevr);\n\tLOAD_HOOK(hooks,hook_handle,zheevr_2stage,zheevr_2stage);\n\tLOAD_HOOK(hooks,hook_handle,zheevx,zheevx);\n\tLOAD_HOOK(hooks,hook_handle,zheevx_2stage,zheevx_2stage);\n\tLOAD_HOOK(hooks,hook_handle,zhegs2,zhegs2);\n\tLOAD_HOOK(hooks,hook_handle,zhegst,zhegst);\n\tLOAD_HOOK(hooks,hook_handle,zhegv,zhegv);\n\tLOAD_HOOK(hooks,hook_handle,zhegv_2stage,zhegv_2stage);\n\tLOAD_HOOK(hooks,hook_handle,zhegvd,zhegvd);\n\tLOAD_HOOK(hooks,hook_handle,zhegvx,zhegvx);\n\tLOAD_HOOK(hooks,hook_handle,zherfs,zherfs);\n\tLOAD_HOOK(hooks,hook_handle,zhesv,zhesv);\n\tLOAD_HOOK(hooks,hook_handle,zhesv_aa,zhesv_aa);\n\tLOAD_HOOK(hooks,hook_handle,zhesv_aa_2stage,zhesv_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,zhesv_rk,zhesv_rk);\n\tLOAD_HOOK(hooks,hook_handle,zhesv_rook,zhesv_rook);\n\tLOAD_HOOK(hooks,hook_handle,zhesvx,zhesvx);\n\tLOAD_HOOK(hooks,hook_handle,zheswapr,zheswapr);\n\tLOAD_HOOK(hooks,hook_handle,zhetd2,zhetd2);\n\tLOAD_HOOK(hooks,hook_handle,zhetf2,zhetf2);\n\tLOAD_HOOK(hooks,hook_handle,zhetf2_rk,zhetf2_rk);\n\tLOAD_HOOK(hooks,hook_handle,zhetf2_rook,zhetf2_rook);\n\tLOAD_HOOK(hooks,hook_handle,zhetrd,zhetrd);\n\tLOAD_HOOK(hooks,hook_handle,zhetrd_2stage,zhetrd_2stage);\n\tLOAD_HOOK(hooks,hook_handle,zhetrd_hb2st,zhetrd_hb2st);\n\tLOAD_HOOK(hooks,hook_handle,zhetrd_he2hb,zhetrd_he2hb);\n\tLOAD_HOOK(hooks,hook_handle,zhetrf,zhetrf);\n\tLOAD_HOOK(hooks,hook_handle,zhetrf_aa,zhetrf_aa);\n\tLOAD_HOOK(hooks,hook_handle,zhetrf_aa_2stage,zhetrf_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,zhetrf_rk,zhetrf_rk);\n\tLOAD_HOOK(hooks,hook_handle,zhetrf_rook,zhetrf_rook);\n\tLOAD_HOOK(hooks,hook_handle,zhetri,zhetri);\n\tLOAD_HOOK(hooks,hook_handle,zhetri2,zhetri2);\n\tLOAD_HOOK(hooks,hook_handle,zhetri2x,zhetri2x);\n\tLOAD_HOOK(hooks,hook_handle,zhetri_3,zhetri_3);\n\tLOAD_HOOK(hooks,hook_handle,zhetri_3x,zhetri_3x);\n\tLOAD_HOOK(hooks,hook_handle,zhetri_rook,zhetri_rook);\n\tLOAD_HOOK(hooks,hook_handle,zhetrs,zhetrs);\n\tLOAD_HOOK(hooks,hook_handle,zhetrs2,zhetrs2);\n\tLOAD_HOOK(hooks,hook_handle,zhetrs_3,zhetrs_3);\n\tLOAD_HOOK(hooks,hook_handle,zhetrs_aa,zhetrs_aa);\n\tLOAD_HOOK(hooks,hook_handle,zhetrs_aa_2stage,zhetrs_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,zhetrs_rook,zhetrs_rook);\n\tLOAD_HOOK(hooks,hook_handle,zhfrk,zhfrk);\n\tLOAD_HOOK(hooks,hook_handle,zhgeqz,zhgeqz);\n\tLOAD_HOOK(hooks,hook_handle,zhpcon,zhpcon);\n\tLOAD_HOOK(hooks,hook_handle,zhpev,zhpev);\n\tLOAD_HOOK(hooks,hook_handle,zhpevd,zhpevd);\n\tLOAD_HOOK(hooks,hook_handle,zhpevx,zhpevx);\n\tLOAD_HOOK(hooks,hook_handle,zhpgst,zhpgst);\n\tLOAD_HOOK(hooks,hook_handle,zhpgv,zhpgv);\n\tLOAD_HOOK(hooks,hook_handle,zhpgvd,zhpgvd);\n\tLOAD_HOOK(hooks,hook_handle,zhpgvx,zhpgvx);\n\tLOAD_HOOK(hooks,hook_handle,zhprfs,zhprfs);\n\tLOAD_HOOK(hooks,hook_handle,zhpsv,zhpsv);\n\tLOAD_HOOK(hooks,hook_handle,zhpsvx,zhpsvx);\n\tLOAD_HOOK(hooks,hook_handle,zhptrd,zhptrd);\n\tLOAD_HOOK(hooks,hook_handle,zhptrf,zhptrf);\n\tLOAD_HOOK(hooks,hook_handle,zhptri,zhptri);\n\tLOAD_HOOK(hooks,hook_handle,zhptrs,zhptrs);\n\tLOAD_HOOK(hooks,hook_handle,zhsein,zhsein);\n\tLOAD_HOOK(hooks,hook_handle,zhseqr,zhseqr);\n\tLOAD_HOOK(hooks,hook_handle,zlabrd,zlabrd);\n\tLOAD_HOOK(hooks,hook_handle,zlacgv,zlacgv);\n\tLOAD_HOOK(hooks,hook_handle,zlacn2,zlacn2);\n\tLOAD_HOOK(hooks,hook_handle,zlacon,zlacon);\n\tLOAD_HOOK(hooks,hook_handle,zlacp2,zlacp2);\n\tLOAD_HOOK(hooks,hook_handle,zlacpy,zlacpy);\n\tLOAD_HOOK(hooks,hook_handle,zlacrm,zlacrm);\n\tLOAD_HOOK(hooks,hook_handle,zlacrt,zlacrt);\n\tLOAD_HOOK(hooks,hook_handle,zladiv,zladiv);\n\tLOAD_HOOK(hooks,hook_handle,zlaed0,zlaed0);\n\tLOAD_HOOK(hooks,hook_handle,zlaed7,zlaed7);\n\tLOAD_HOOK(hooks,hook_handle,zlaed8,zlaed8);\n\tLOAD_HOOK(hooks,hook_handle,zlaein,zlaein);\n\tLOAD_HOOK(hooks,hook_handle,zlaesy,zlaesy);\n\tLOAD_HOOK(hooks,hook_handle,zlaev2,zlaev2);\n\tLOAD_HOOK(hooks,hook_handle,zlag2c,zlag2c);\n\tLOAD_HOOK(hooks,hook_handle,zlags2,zlags2);\n\tLOAD_HOOK(hooks,hook_handle,zlagtm,zlagtm);\n\tLOAD_HOOK(hooks,hook_handle,zlahef,zlahef);\n\tLOAD_HOOK(hooks,hook_handle,zlahef_aa,zlahef_aa);\n\tLOAD_HOOK(hooks,hook_handle,zlahef_rk,zlahef_rk);\n\tLOAD_HOOK(hooks,hook_handle,zlahef_rook,zlahef_rook);\n\tLOAD_HOOK(hooks,hook_handle,zlahqr,zlahqr);\n\tLOAD_HOOK(hooks,hook_handle,zlahr2,zlahr2);\n\tLOAD_HOOK(hooks,hook_handle,zlahrd,zlahrd);\n\tLOAD_HOOK(hooks,hook_handle,zlaic1,zlaic1);\n\tLOAD_HOOK(hooks,hook_handle,zlals0,zlals0);\n\tLOAD_HOOK(hooks,hook_handle,zlalsa,zlalsa);\n\tLOAD_HOOK(hooks,hook_handle,zlalsd,zlalsd);\n\tLOAD_HOOK(hooks,hook_handle,zlamswlq,zlamswlq);\n\tLOAD_HOOK(hooks,hook_handle,zlamtsqr,zlamtsqr);\n\tLOAD_HOOK(hooks,hook_handle,zlangb,zlangb);\n\tLOAD_HOOK(hooks,hook_handle,zlange,zlange);\n\tLOAD_HOOK(hooks,hook_handle,zlangt,zlangt);\n\tLOAD_HOOK(hooks,hook_handle,zlanhb,zlanhb);\n\tLOAD_HOOK(hooks,hook_handle,zlanhe,zlanhe);\n\tLOAD_HOOK(hooks,hook_handle,zlanhf,zlanhf);\n\tLOAD_HOOK(hooks,hook_handle,zlanhp,zlanhp);\n\tLOAD_HOOK(hooks,hook_handle,zlanhs,zlanhs);\n\tLOAD_HOOK(hooks,hook_handle,zlanht,zlanht);\n\tLOAD_HOOK(hooks,hook_handle,zlansb,zlansb);\n\tLOAD_HOOK(hooks,hook_handle,zlansp,zlansp);\n\tLOAD_HOOK(hooks,hook_handle,zlansy,zlansy);\n\tLOAD_HOOK(hooks,hook_handle,zlantb,zlantb);\n\tLOAD_HOOK(hooks,hook_handle,zlantp,zlantp);\n\tLOAD_HOOK(hooks,hook_handle,zlantr,zlantr);\n\tLOAD_HOOK(hooks,hook_handle,zlapll,zlapll);\n\tLOAD_HOOK(hooks,hook_handle,zlapmr,zlapmr);\n\tLOAD_HOOK(hooks,hook_handle,zlapmt,zlapmt);\n\tLOAD_HOOK(hooks,hook_handle,zlaqgb,zlaqgb);\n\tLOAD_HOOK(hooks,hook_handle,zlaqge,zlaqge);\n\tLOAD_HOOK(hooks,hook_handle,zlaqhb,zlaqhb);\n\tLOAD_HOOK(hooks,hook_handle,zlaqhe,zlaqhe);\n\tLOAD_HOOK(hooks,hook_handle,zlaqhp,zlaqhp);\n\tLOAD_HOOK(hooks,hook_handle,zlaqp2,zlaqp2);\n\tLOAD_HOOK(hooks,hook_handle,zlaqps,zlaqps);\n\tLOAD_HOOK(hooks,hook_handle,zlaqr0,zlaqr0);\n\tLOAD_HOOK(hooks,hook_handle,zlaqr1,zlaqr1);\n\tLOAD_HOOK(hooks,hook_handle,zlaqr2,zlaqr2);\n\tLOAD_HOOK(hooks,hook_handle,zlaqr3,zlaqr3);\n\tLOAD_HOOK(hooks,hook_handle,zlaqr4,zlaqr4);\n\tLOAD_HOOK(hooks,hook_handle,zlaqr5,zlaqr5);\n\tLOAD_HOOK(hooks,hook_handle,zlaqsb,zlaqsb);\n\tLOAD_HOOK(hooks,hook_handle,zlaqsp,zlaqsp);\n\tLOAD_HOOK(hooks,hook_handle,zlaqsy,zlaqsy);\n\tLOAD_HOOK(hooks,hook_handle,zlar1v,zlar1v);\n\tLOAD_HOOK(hooks,hook_handle,zlar2v,zlar2v);\n\tLOAD_HOOK(hooks,hook_handle,zlarcm,zlarcm);\n\tLOAD_HOOK(hooks,hook_handle,zlarf,zlarf);\n\tLOAD_HOOK(hooks,hook_handle,zlarfb,zlarfb);\n\tLOAD_HOOK(hooks,hook_handle,zlarfg,zlarfg);\n\tLOAD_HOOK(hooks,hook_handle,zlarfgp,zlarfgp);\n\tLOAD_HOOK(hooks,hook_handle,zlarft,zlarft);\n\tLOAD_HOOK(hooks,hook_handle,zlarfx,zlarfx);\n\tLOAD_HOOK(hooks,hook_handle,zlarfy,zlarfy);\n\tLOAD_HOOK(hooks,hook_handle,zlargv,zlargv);\n\tLOAD_HOOK(hooks,hook_handle,zlarnv,zlarnv);\n\tLOAD_HOOK(hooks,hook_handle,zlarrv,zlarrv);\n\tLOAD_HOOK(hooks,hook_handle,zlartg,zlartg);\n\tLOAD_HOOK(hooks,hook_handle,zlartv,zlartv);\n\tLOAD_HOOK(hooks,hook_handle,zlarz,zlarz);\n\tLOAD_HOOK(hooks,hook_handle,zlarzb,zlarzb);\n\tLOAD_HOOK(hooks,hook_handle,zlarzt,zlarzt);\n\tLOAD_HOOK(hooks,hook_handle,zlascl,zlascl);\n\tLOAD_HOOK(hooks,hook_handle,zlaset,zlaset);\n\tLOAD_HOOK(hooks,hook_handle,zlasr,zlasr);\n\tLOAD_HOOK(hooks,hook_handle,zlassq,zlassq);\n\tLOAD_HOOK(hooks,hook_handle,zlaswlq,zlaswlq);\n\tLOAD_HOOK(hooks,hook_handle,zlaswp,zlaswp);\n\tLOAD_HOOK(hooks,hook_handle,zlasyf,zlasyf);\n\tLOAD_HOOK(hooks,hook_handle,zlasyf_aa,zlasyf_aa);\n\tLOAD_HOOK(hooks,hook_handle,zlasyf_rk,zlasyf_rk);\n\tLOAD_HOOK(hooks,hook_handle,zlasyf_rook,zlasyf_rook);\n\tLOAD_HOOK(hooks,hook_handle,zlat2c,zlat2c);\n\tLOAD_HOOK(hooks,hook_handle,zlatbs,zlatbs);\n\tLOAD_HOOK(hooks,hook_handle,zlatdf,zlatdf);\n\tLOAD_HOOK(hooks,hook_handle,zlatps,zlatps);\n\tLOAD_HOOK(hooks,hook_handle,zlatrd,zlatrd);\n\tLOAD_HOOK(hooks,hook_handle,zlatrs,zlatrs);\n\tLOAD_HOOK(hooks,hook_handle,zlatrz,zlatrz);\n\tLOAD_HOOK(hooks,hook_handle,zlatsqr,zlatsqr);\n\tLOAD_HOOK(hooks,hook_handle,zlatzm,zlatzm);\n\tLOAD_HOOK(hooks,hook_handle,zlaunhr_col_getrfnp,zlaunhr_col_getrfnp);\n\tLOAD_HOOK(hooks,hook_handle,zlaunhr_col_getrfnp2,zlaunhr_col_getrfnp2);\n\tLOAD_HOOK(hooks,hook_handle,zlauu2,zlauu2);\n\tLOAD_HOOK(hooks,hook_handle,zlauum,zlauum);\n\tLOAD_HOOK(hooks,hook_handle,zpbcon,zpbcon);\n\tLOAD_HOOK(hooks,hook_handle,zpbequ,zpbequ);\n\tLOAD_HOOK(hooks,hook_handle,zpbrfs,zpbrfs);\n\tLOAD_HOOK(hooks,hook_handle,zpbstf,zpbstf);\n\tLOAD_HOOK(hooks,hook_handle,zpbsv,zpbsv);\n\tLOAD_HOOK(hooks,hook_handle,zpbsvx,zpbsvx);\n\tLOAD_HOOK(hooks,hook_handle,zpbtf2,zpbtf2);\n\tLOAD_HOOK(hooks,hook_handle,zpbtrf,zpbtrf);\n\tLOAD_HOOK(hooks,hook_handle,zpbtrs,zpbtrs);\n\tLOAD_HOOK(hooks,hook_handle,zpftrf,zpftrf);\n\tLOAD_HOOK(hooks,hook_handle,zpftri,zpftri);\n\tLOAD_HOOK(hooks,hook_handle,zpftrs,zpftrs);\n\tLOAD_HOOK(hooks,hook_handle,zpocon,zpocon);\n\tLOAD_HOOK(hooks,hook_handle,zpoequ,zpoequ);\n\tLOAD_HOOK(hooks,hook_handle,zpoequb,zpoequb);\n\tLOAD_HOOK(hooks,hook_handle,zporfs,zporfs);\n\tLOAD_HOOK(hooks,hook_handle,zposv,zposv);\n\tLOAD_HOOK(hooks,hook_handle,zposvx,zposvx);\n\tLOAD_HOOK(hooks,hook_handle,zpotf2,zpotf2);\n\tLOAD_HOOK(hooks,hook_handle,zpotrf,zpotrf);\n\tLOAD_HOOK(hooks,hook_handle,zpotrf2,zpotrf2);\n\tLOAD_HOOK(hooks,hook_handle,zpotri,zpotri);\n\tLOAD_HOOK(hooks,hook_handle,zpotrs,zpotrs);\n\tLOAD_HOOK(hooks,hook_handle,zppcon,zppcon);\n\tLOAD_HOOK(hooks,hook_handle,zppequ,zppequ);\n\tLOAD_HOOK(hooks,hook_handle,zpprfs,zpprfs);\n\tLOAD_HOOK(hooks,hook_handle,zppsv,zppsv);\n\tLOAD_HOOK(hooks,hook_handle,zppsvx,zppsvx);\n\tLOAD_HOOK(hooks,hook_handle,zpptrf,zpptrf);\n\tLOAD_HOOK(hooks,hook_handle,zpptri,zpptri);\n\tLOAD_HOOK(hooks,hook_handle,zpptrs,zpptrs);\n\tLOAD_HOOK(hooks,hook_handle,zpstf2,zpstf2);\n\tLOAD_HOOK(hooks,hook_handle,zpstrf,zpstrf);\n\tLOAD_HOOK(hooks,hook_handle,zptcon,zptcon);\n\tLOAD_HOOK(hooks,hook_handle,zpteqr,zpteqr);\n\tLOAD_HOOK(hooks,hook_handle,zptrfs,zptrfs);\n\tLOAD_HOOK(hooks,hook_handle,zptsv,zptsv);\n\tLOAD_HOOK(hooks,hook_handle,zptsvx,zptsvx);\n\tLOAD_HOOK(hooks,hook_handle,zpttrf,zpttrf);\n\tLOAD_HOOK(hooks,hook_handle,zpttrs,zpttrs);\n\tLOAD_HOOK(hooks,hook_handle,zptts2,zptts2);\n\tLOAD_HOOK(hooks,hook_handle,zrot,zrot);\n\tLOAD_HOOK(hooks,hook_handle,zspcon,zspcon);\n\tLOAD_HOOK(hooks,hook_handle,zspmv,zspmv);\n\tLOAD_HOOK(hooks,hook_handle,zspr,zspr);\n\tLOAD_HOOK(hooks,hook_handle,zsprfs,zsprfs);\n\tLOAD_HOOK(hooks,hook_handle,zspsv,zspsv);\n\tLOAD_HOOK(hooks,hook_handle,zspsvx,zspsvx);\n\tLOAD_HOOK(hooks,hook_handle,zsptrf,zsptrf);\n\tLOAD_HOOK(hooks,hook_handle,zsptri,zsptri);\n\tLOAD_HOOK(hooks,hook_handle,zsptrs,zsptrs);\n\tLOAD_HOOK(hooks,hook_handle,zstedc,zstedc);\n\tLOAD_HOOK(hooks,hook_handle,zstegr,zstegr);\n\tLOAD_HOOK(hooks,hook_handle,zstein,zstein);\n\tLOAD_HOOK(hooks,hook_handle,zstemr,zstemr);\n\tLOAD_HOOK(hooks,hook_handle,zsteqr,zsteqr);\n\tLOAD_HOOK(hooks,hook_handle,zsycon,zsycon);\n\tLOAD_HOOK(hooks,hook_handle,zsycon_3,zsycon_3);\n\tLOAD_HOOK(hooks,hook_handle,zsycon_rook,zsycon_rook);\n\tLOAD_HOOK(hooks,hook_handle,zsyconv,zsyconv);\n\tLOAD_HOOK(hooks,hook_handle,zsyconvf,zsyconvf);\n\tLOAD_HOOK(hooks,hook_handle,zsyconvf_rook,zsyconvf_rook);\n\tLOAD_HOOK(hooks,hook_handle,zsyequb,zsyequb);\n\tLOAD_HOOK(hooks,hook_handle,zsymv,zsymv);\n\tLOAD_HOOK(hooks,hook_handle,zsyr,zsyr);\n\tLOAD_HOOK(hooks,hook_handle,zsyrfs,zsyrfs);\n\tLOAD_HOOK(hooks,hook_handle,zsysv,zsysv);\n\tLOAD_HOOK(hooks,hook_handle,zsysv_aa,zsysv_aa);\n\tLOAD_HOOK(hooks,hook_handle,zsysv_aa_2stage,zsysv_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,zsysv_rk,zsysv_rk);\n\tLOAD_HOOK(hooks,hook_handle,zsysv_rook,zsysv_rook);\n\tLOAD_HOOK(hooks,hook_handle,zsysvx,zsysvx);\n\tLOAD_HOOK(hooks,hook_handle,zsyswapr,zsyswapr);\n\tLOAD_HOOK(hooks,hook_handle,zsytf2,zsytf2);\n\tLOAD_HOOK(hooks,hook_handle,zsytf2_rk,zsytf2_rk);\n\tLOAD_HOOK(hooks,hook_handle,zsytf2_rook,zsytf2_rook);\n\tLOAD_HOOK(hooks,hook_handle,zsytrf,zsytrf);\n\tLOAD_HOOK(hooks,hook_handle,zsytrf_aa,zsytrf_aa);\n\tLOAD_HOOK(hooks,hook_handle,zsytrf_aa_2stage,zsytrf_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,zsytrf_rk,zsytrf_rk);\n\tLOAD_HOOK(hooks,hook_handle,zsytrf_rook,zsytrf_rook);\n\tLOAD_HOOK(hooks,hook_handle,zsytri,zsytri);\n\tLOAD_HOOK(hooks,hook_handle,zsytri2,zsytri2);\n\tLOAD_HOOK(hooks,hook_handle,zsytri2x,zsytri2x);\n\tLOAD_HOOK(hooks,hook_handle,zsytri_3,zsytri_3);\n\tLOAD_HOOK(hooks,hook_handle,zsytri_3x,zsytri_3x);\n\tLOAD_HOOK(hooks,hook_handle,zsytri_rook,zsytri_rook);\n\tLOAD_HOOK(hooks,hook_handle,zsytrs,zsytrs);\n\tLOAD_HOOK(hooks,hook_handle,zsytrs2,zsytrs2);\n\tLOAD_HOOK(hooks,hook_handle,zsytrs_3,zsytrs_3);\n\tLOAD_HOOK(hooks,hook_handle,zsytrs_aa,zsytrs_aa);\n\tLOAD_HOOK(hooks,hook_handle,zsytrs_aa_2stage,zsytrs_aa_2stage);\n\tLOAD_HOOK(hooks,hook_handle,zsytrs_rook,zsytrs_rook);\n\tLOAD_HOOK(hooks,hook_handle,ztbcon,ztbcon);\n\tLOAD_HOOK(hooks,hook_handle,ztbrfs,ztbrfs);\n\tLOAD_HOOK(hooks,hook_handle,ztbtrs,ztbtrs);\n\tLOAD_HOOK(hooks,hook_handle,ztfsm,ztfsm);\n\tLOAD_HOOK(hooks,hook_handle,ztftri,ztftri);\n\tLOAD_HOOK(hooks,hook_handle,ztfttp,ztfttp);\n\tLOAD_HOOK(hooks,hook_handle,ztfttr,ztfttr);\n\tLOAD_HOOK(hooks,hook_handle,ztgevc,ztgevc);\n\tLOAD_HOOK(hooks,hook_handle,ztgex2,ztgex2);\n\tLOAD_HOOK(hooks,hook_handle,ztgexc,ztgexc);\n\tLOAD_HOOK(hooks,hook_handle,ztgsen,ztgsen);\n\tLOAD_HOOK(hooks,hook_handle,ztgsja,ztgsja);\n\tLOAD_HOOK(hooks,hook_handle,ztgsna,ztgsna);\n\tLOAD_HOOK(hooks,hook_handle,ztgsy2,ztgsy2);\n\tLOAD_HOOK(hooks,hook_handle,ztgsyl,ztgsyl);\n\tLOAD_HOOK(hooks,hook_handle,ztpcon,ztpcon);\n\tLOAD_HOOK(hooks,hook_handle,ztplqt,ztplqt);\n\tLOAD_HOOK(hooks,hook_handle,ztplqt2,ztplqt2);\n\tLOAD_HOOK(hooks,hook_handle,ztpmlqt,ztpmlqt);\n\tLOAD_HOOK(hooks,hook_handle,ztpmqrt,ztpmqrt);\n\tLOAD_HOOK(hooks,hook_handle,ztpqrt,ztpqrt);\n\tLOAD_HOOK(hooks,hook_handle,ztpqrt2,ztpqrt2);\n\tLOAD_HOOK(hooks,hook_handle,ztprfb,ztprfb);\n\tLOAD_HOOK(hooks,hook_handle,ztprfs,ztprfs);\n\tLOAD_HOOK(hooks,hook_handle,ztptri,ztptri);\n\tLOAD_HOOK(hooks,hook_handle,ztptrs,ztptrs);\n\tLOAD_HOOK(hooks,hook_handle,ztpttf,ztpttf);\n\tLOAD_HOOK(hooks,hook_handle,ztpttr,ztpttr);\n\tLOAD_HOOK(hooks,hook_handle,ztrcon,ztrcon);\n\tLOAD_HOOK(hooks,hook_handle,ztrevc,ztrevc);\n\tLOAD_HOOK(hooks,hook_handle,ztrevc3,ztrevc3);\n\tLOAD_HOOK(hooks,hook_handle,ztrexc,ztrexc);\n\tLOAD_HOOK(hooks,hook_handle,ztrrfs,ztrrfs);\n\tLOAD_HOOK(hooks,hook_handle,ztrsen,ztrsen);\n\tLOAD_HOOK(hooks,hook_handle,ztrsna,ztrsna);\n\tLOAD_HOOK(hooks,hook_handle,ztrsyl,ztrsyl);\n\tLOAD_HOOK(hooks,hook_handle,ztrti2,ztrti2);\n\tLOAD_HOOK(hooks,hook_handle,ztrtri,ztrtri);\n\tLOAD_HOOK(hooks,hook_handle,ztrtrs,ztrtrs);\n\tLOAD_HOOK(hooks,hook_handle,ztrttf,ztrttf);\n\tLOAD_HOOK(hooks,hook_handle,ztrttp,ztrttp);\n\tLOAD_HOOK(hooks,hook_handle,ztzrqf,ztzrqf);\n\tLOAD_HOOK(hooks,hook_handle,ztzrzf,ztzrzf);\n\tLOAD_HOOK(hooks,hook_handle,zunbdb,zunbdb);\n\tLOAD_HOOK(hooks,hook_handle,zunbdb1,zunbdb1);\n\tLOAD_HOOK(hooks,hook_handle,zunbdb2,zunbdb2);\n\tLOAD_HOOK(hooks,hook_handle,zunbdb3,zunbdb3);\n\tLOAD_HOOK(hooks,hook_handle,zunbdb4,zunbdb4);\n\tLOAD_HOOK(hooks,hook_handle,zunbdb5,zunbdb5);\n\tLOAD_HOOK(hooks,hook_handle,zunbdb6,zunbdb6);\n\tLOAD_HOOK(hooks,hook_handle,zuncsd,zuncsd);\n\tLOAD_HOOK(hooks,hook_handle,zuncsd2by1,zuncsd2by1);\n\tLOAD_HOOK(hooks,hook_handle,zung2l,zung2l);\n\tLOAD_HOOK(hooks,hook_handle,zung2r,zung2r);\n\tLOAD_HOOK(hooks,hook_handle,zungbr,zungbr);\n\tLOAD_HOOK(hooks,hook_handle,zunghr,zunghr);\n\tLOAD_HOOK(hooks,hook_handle,zungl2,zungl2);\n\tLOAD_HOOK(hooks,hook_handle,zunglq,zunglq);\n\tLOAD_HOOK(hooks,hook_handle,zungql,zungql);\n\tLOAD_HOOK(hooks,hook_handle,zungqr,zungqr);\n\tLOAD_HOOK(hooks,hook_handle,zungr2,zungr2);\n\tLOAD_HOOK(hooks,hook_handle,zungrq,zungrq);\n\tLOAD_HOOK(hooks,hook_handle,zungtr,zungtr);\n\tLOAD_HOOK(hooks,hook_handle,zungtsqr,zungtsqr);\n\tLOAD_HOOK(hooks,hook_handle,zunhr_col,zunhr_col);\n\tLOAD_HOOK(hooks,hook_handle,zunm22,zunm22);\n\tLOAD_HOOK(hooks,hook_handle,zunm2l,zunm2l);\n\tLOAD_HOOK(hooks,hook_handle,zunm2r,zunm2r);\n\tLOAD_HOOK(hooks,hook_handle,zunmbr,zunmbr);\n\tLOAD_HOOK(hooks,hook_handle,zunmhr,zunmhr);\n\tLOAD_HOOK(hooks,hook_handle,zunml2,zunml2);\n\tLOAD_HOOK(hooks,hook_handle,zunmlq,zunmlq);\n\tLOAD_HOOK(hooks,hook_handle,zunmql,zunmql);\n\tLOAD_HOOK(hooks,hook_handle,zunmqr,zunmqr);\n\tLOAD_HOOK(hooks,hook_handle,zunmr2,zunmr2);\n\tLOAD_HOOK(hooks,hook_handle,zunmr3,zunmr3);\n\tLOAD_HOOK(hooks,hook_handle,zunmrq,zunmrq);\n\tLOAD_HOOK(hooks,hook_handle,zunmrz,zunmrz);\n\tLOAD_HOOK(hooks,hook_handle,zunmtr,zunmtr);\n\tLOAD_HOOK(hooks,hook_handle,zupgtr,zupgtr);\n\tLOAD_HOOK(hooks,hook_handle,zupmtr,zupmtr);\n#endif\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/src/set_num_threads.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Linking FlexiBLAS statically or dynamically with other modules is making a\n * combined work based on FlexiBLAS. Thus, the terms and conditions of the GNU\n * General Public License cover the whole combination.\n *\n * As a special exception, the copyright holders of FlexiBLAS give you permission\n * to combine FlexiBLAS program with free software programs or libraries that are\n * released under the GNU LGPL and with independent modules that communicate with\n * FlexiBLAS solely through the BLAS/LAPACK interface as provided by the\n * BLAS/LAPACK reference implementation. You may copy and distribute such a system\n * following the terms of the GNU GPL for FlexiBLAS and the licenses of the other\n * code concerned, provided that you include the source code of that other code\n * when and as the GNU GPL requires distribution of source code and provided that\n * you do not modify the BLAS/LAPACK interface.\n *\n * Note that people who make modified versions of FlexiBLAS are not obligated to\n * grant this special exception for their modified versions; it is their choice\n * whether to do so. The GNU General Public License gives permission to release a\n * modified version without this exception; this exception also makes it possible\n * to release a modified version which carries forward this exception. If you\n * modify the BLAS/LAPACK interface, this exception does not apply to your\n * modified version of FlexiBLAS, and you must remove this exception when you\n * distribute your modified version.\n *\n * This exception is an additional permission under section 7 of the GNU General\n * Public License, version 3 (\u201cGPLv3\u201d)\n *\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2013-2020\n */\n\n\n\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <complex.h>\n#include <math.h>\n\n#include \"flexiblas.h\"\n\n\n/*-----------------------------------------------------------------------------\n *  Set the numner of threads from C\n *-----------------------------------------------------------------------------*/\nvoid flexiblas_set_num_threads(int num)\n{\n    flexiblas_set_num_threads_function_t fn;\n    DPRINTF(2, \"Set number of threads: %d  C-fn: %lx F77-fn: %lx\\n\", num,\n            (unsigned long) current_backend->set_num_threads_function[0],\n            (unsigned long) current_backend->set_num_threads_function[1]);\n    if ( current_backend->set_num_threads_function[0] == NULL\n         && current_backend->set_num_threads_function[1] != NULL ) {\n        flexiblas_set_num_threads_(&num);\n        return;\n    }\n    fn = current_backend->set_num_threads_function[0];\n    if ( fn == NULL) return;\n    fn (num);\n    return;\n}\n\nvoid openblas_set_num_threads(int num) __attribute__((weak,alias(\"flexiblas_set_num_threads\")));\nvoid mkl_set_num_threads(int num) __attribute__((weak,alias(\"flexiblas_set_num_threads\")));\nvoid acmlsetnumthreads(int num) __attribute__((weak,alias(\"flexiblas_set_num_threads\")));\nvoid blas_set_num_threads(int num) __attribute__((weak,alias(\"flexiblas_set_num_threads\")));\n\n/* BLIS Interface */\nvoid bli_thread_set_num_threads(Int num) {\n    int _num = num;\n    flexiblas_set_num_threads(_num);\n    return;\n}\n\n/*-----------------------------------------------------------------------------\n *  Get the current number of threads from C\n *-----------------------------------------------------------------------------*/\nint flexiblas_get_num_threads()\n{\n    flexiblas_get_num_threads_function_t fn;\n    DPRINTF(2, \"Get number of threads:  C-fn: %lx F77-fn: %lx\\n\",\n            (unsigned long) current_backend->get_num_threads_function[0],\n            (unsigned long) current_backend->get_num_threads_function[1]);\n    if ( current_backend->get_num_threads_function[0] == NULL\n         && current_backend->get_num_threads_function[1] != NULL ) {\n        return flexiblas_get_num_threads_();\n    }\n    fn = current_backend->get_num_threads_function[0];\n    if ( fn == NULL) return 1;\n    return fn ();\n}\n\nint  openblas_get_num_threads() __attribute__((weak,alias(\"flexiblas_get_num_threads\")));\nint  mkl_get_num_threads() __attribute__((weak,alias(\"flexiblas_get_num_threads\")));\nint  acmlgetnumthreads() __attribute__((weak,alias(\"flexiblas_get_num_threads\")));\nint  blas_get_num_threads() __attribute__((weak,alias(\"flexiblas_get_num_threads\")));\n\n/*  Blis Interface  */\nInt bli_thread_get_num_threads() {\n    Int _num;\n    _num = (Int) flexiblas_get_num_threads();\n    return _num;\n}\n\n/*-----------------------------------------------------------------------------\n *  Set the number of threads from Fortran\n *-----------------------------------------------------------------------------*/\nvoid flexiblas_set_num_threads_(int* num)\n{\n    Int num_threads;\n    flexiblas_set_num_threads_function_t fn;\n    void (*fn2) (Int *);\n    DPRINTF(2, \"Set number of threads: %d  C-fn: %lx F77-fn: %lx\\n\", *num,\n            (unsigned long) current_backend->set_num_threads_function[0],\n            (unsigned long) current_backend->set_num_threads_function[1]);\n\n    if ( current_backend->set_num_threads_function[1] == NULL\n         && current_backend->set_num_threads_function[0] != NULL ) {\n        flexiblas_set_num_threads(*num);\n        return;\n    }\n    fn = current_backend->set_num_threads_function[1];\n    num_threads = *num;\n    if (fn == NULL) return;\n    fn2 =(void*)fn;\n    fn2 (&num_threads);\n    return;\n}\n\nvoid openblas_set_num_threads_(int *num) __attribute__((weak, alias(\"flexiblas_set_num_threads_\")));\nvoid mkl_set_num_threads_(int *num) __attribute__((weak,alias(\"flexiblas_set_num_threads_\")));\nvoid acmlsetnumthreads_(int *num) __attribute__((weak,alias(\"flexiblas_set_num_threads_\")));\nvoid blas_set_num_threads_(int *num) __attribute__((weak,alias(\"flexiblas_set_num_threads_\")));\n\n\n/*-----------------------------------------------------------------------------\n *  Get number of threads from fortran\n *-----------------------------------------------------------------------------*/\nInt flexiblas_get_num_threads_()\n{\n    flexiblas_get_num_threads_function_t fn;\n    DPRINTF(2, \"Get number of threads: C-fn: %lx F77-fn: %lx\\n\",\n            (unsigned long) current_backend->get_num_threads_function[0],\n            (unsigned long) current_backend->get_num_threads_function[1]);\n\n    if ( current_backend->get_num_threads_function[1] == NULL\n         && current_backend->get_num_threads_function[0] != NULL ) {\n        return flexiblas_get_num_threads();\n    }\n    fn = current_backend->get_num_threads_function[1];\n    if (fn == NULL) return 1;\n    return fn ();\n}\n\nInt  openblas_get_num_threads_() __attribute__((weak, alias(\"flexiblas_get_num_threads_\")));\nInt  mkl_get_num_threads_() __attribute__((weak,alias(\"flexiblas_get_num_threads_\")));\nInt  acmlgetnumthreads_() __attribute__((weak,alias(\"flexiblas_get_num_threads_\")));\nInt  blas_get_num_threads_() __attribute__((weak,alias(\"flexiblas_get_num_threads_\")));\n\n\n\n/*-----------------------------------------------------------------------------\n *  Search for the set number of threads function\n *-----------------------------------------------------------------------------*/\nvoid __flexiblas_load_set_num_threads(flexiblas_backend_t * backend)\n{\n    void *ptr = NULL;\n    void *ptr2 = NULL;\n    char fn_name[128];\n    char fn2_name[130];\n    int i = 0;\n\n    for (i = 0; i < 5; i++) {\n        if (i == 0 )\n            strncpy(fn_name, \"hook_set_num_threads\",127);\n        else if ( i == 1) {\n            strncpy(fn_name, \"MKL_Set_Num_Threads\",127);\n            strncpy(fn2_name, \"mkl_set_num_threads_\",127);\n        } else if ( i == 2)\n            strncpy(fn_name, \"openblas_set_num_threads\",127);\n        else if ( i == 3)\n            strncpy(fn_name, \"acmlsetnumthreads\",127);\n        else if ( i == 4 )\n            strncpy(fn_name, \"bli_thread_set_num_threads\", 127);\n        fn_name[127] = '\\0';\n        if ( i != 1 ) {\n            snprintf(fn2_name, 130, \"%s_\", fn_name);\n        }\n    \tptr  = dlsym(backend->library_handle, fn_name);\n        ptr2  = dlsym(backend->library_handle, fn2_name);\n\n        if (ptr != NULL || ptr2 != NULL)\n            break;\n    }\n    backend->set_num_threads_function[0] = (flexiblas_set_num_threads_function_t ) ptr;\n    backend->set_num_threads_function[1] = (flexiblas_set_num_threads_function_t ) ptr2;\n\n    if ( ptr ) {\n        DPRINTF(1, \"Set thread number function found ( func_name = %s ) at 0x%lx\\n\", fn_name,  (unsigned long)ptr);\n    }\n    if ( ptr2 ) {\n        DPRINTF(1, \"Set thread number function found ( func_name = %s ) at 0x%lx\\n\", fn2_name, (unsigned long)ptr2);\n    }\n\n    return;\n}\n\n\n/*-----------------------------------------------------------------------------\n *  Search for the get number of threads function\n *-----------------------------------------------------------------------------*/\nvoid __flexiblas_load_get_num_threads(flexiblas_backend_t * backend)\n{\n    void *ptr = NULL;\n    void *ptr2 = NULL;\n    char fn_name[128];\n    char fn2_name[130];\n    int i = 0;\n\n    for (i = 0; i < 5; i++) {\n        if (i == 0 )\n            strncpy(fn_name, \"hook_get_num_threads\",127);\n        else if ( i == 1) {\n            strncpy(fn_name, \"MKL_Get_Max_Threads\",127);\n            strncpy(fn2_name, \"mkl_get_max_threads_\",127);\n        } else if ( i == 2)\n            strncpy(fn_name, \"openblas_get_num_threads\",127);\n        else if ( i == 3)\n            strncpy(fn_name, \"acmlgetnumthreads\",127);\n        else if ( i == 4 )\n            strncpy(fn_name, \"bli_thread_get_num_threads\",127);\n\n        fn_name[127] = '\\0';\n        if ( i != 1 )\n            snprintf(fn2_name, 130, \"%s_\", fn_name);\n\n       \tptr  = dlsym(backend->library_handle, fn_name);\n        ptr2  = dlsym(backend->library_handle, fn2_name);\n\n        if (ptr != NULL || ptr2 != NULL)\n            break;\n    }\n    backend->get_num_threads_function[0] = (flexiblas_get_num_threads_function_t ) ptr;\n    backend->get_num_threads_function[1] = (flexiblas_get_num_threads_function_t ) ptr2;\n\n    if ( ptr ) {\n        DPRINTF(1, \"Get thread number function ( func_name = %s )  at 0x%lx\\n\", fn_name, (unsigned long)ptr);\n    }\n    if ( ptr2 ) {\n        DPRINTF(1, \"Get thread number function ( func_name = %s )  at 0x%lx\\n\", fn2_name, (unsigned long)ptr2);\n    }\n\n    return;\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/src/wrap_cblas.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Linking FlexiBLAS statically or dynamically with other modules is making a\n * combined work based on FlexiBLAS. Thus, the terms and conditions of the GNU\n * General Public License cover the whole combination.\n *\n * As a special exception, the copyright holders of FlexiBLAS give you permission\n * to combine FlexiBLAS program with free software programs or libraries that are\n * released under the GNU LGPL and with independent modules that communicate with\n * FlexiBLAS solely through the BLAS/LAPACK interface as provided by the\n * BLAS/LAPACK reference implementation. You may copy and distribute such a system\n * following the terms of the GNU GPL for FlexiBLAS and the licenses of the other\n * code concerned, provided that you include the source code of that other code\n * when and as the GNU GPL requires distribution of source code and provided that\n * you do not modify the BLAS/LAPACK interface.\n *\n * Note that people who make modified versions of FlexiBLAS are not obligated to\n * grant this special exception for their modified versions; it is their choice\n * whether to do so. The GNU General Public License gives permission to release a\n * modified version without this exception; this exception also makes it possible\n * to release a modified version which carries forward this exception. If you\n * modify the BLAS/LAPACK interface, this exception does not apply to your\n * modified version of FlexiBLAS, and you must remove this exception when you\n * distribute your modified version.\n *\n * This exception is an additional permission under section 7 of the GNU General\n * Public License, version 3 (\u201cGPLv3\u201d)\n *\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2013-2020\n */\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <math.h>\n#include <complex.h>\n\n#include \"flexiblas.h\"\n\n#ifdef EXTBLAS_ENABLED\n#endif\n\n\n\nHIDDEN int __flexiblas_load_cblas(flexiblas_backend_t *backend)\n{\n    void * cblas_in_blis = dlsym(backend->library_handle, \"bli_info_get_enable_cblas\");\n    if ( cblas_in_blis ) {\n        DPRINTF_WARN(1, \"The desired BLAS library is BLIS. We do not load their CBLAS wrapper since it might alter the behavior of your programs.\");\n        return 0;\n    }\n\t/*-----------------------------------------------------------------------------\n\t *  Integer and XERBLA routine\n\t *-----------------------------------------------------------------------------*/\n\tLOAD_CBLAS(backend,blas.icamax,icamax);\n\tLOAD_CBLAS(backend,blas.idamax,idamax);\n\tLOAD_CBLAS(backend,blas.isamax,isamax);\n\tLOAD_CBLAS(backend,blas.izamax,izamax);\n    LOAD_CBLAS(backend,xerbla,xerbla);\n\n\t/*-----------------------------------------------------------------------------\n\t *  Single Precision Routines\n\t *-----------------------------------------------------------------------------*/\n\tLOAD_CBLAS(backend,blas.sasum,sasum );\n\tLOAD_CBLAS(backend,blas.saxpy,saxpy);\n\tLOAD_CBLAS(backend,blas.scasum,scasum);\n\tLOAD_CBLAS(backend,blas.scnrm2,scnrm2);\n\tLOAD_CBLAS(backend,blas.scopy,scopy);\n\tLOAD_CBLAS(backend,blas.sdot,sdot);\n\tLOAD_CBLAS(backend,blas.sdsdot,sdsdot);\n\tLOAD_CBLAS(backend,blas.sgbmv,sgbmv);\n\tLOAD_CBLAS(backend,blas.sgemm,sgemm);\n\tLOAD_CBLAS(backend,blas.sgemv,sgemv);\n\tLOAD_CBLAS(backend,blas.sger,sger);\n\tLOAD_CBLAS(backend,blas.snrm2,snrm2);\n\tLOAD_CBLAS(backend,blas.srot,srot);\n\tLOAD_CBLAS(backend,blas.srotg,srotg);\n\tLOAD_CBLAS(backend,blas.srotm,srotm);\n\tLOAD_CBLAS(backend,blas.srotmg,srotmg);\n\tLOAD_CBLAS(backend,blas.ssbmv,ssbmv);\n\tLOAD_CBLAS(backend,blas.sscal,sscal);\n\tLOAD_CBLAS(backend,blas.sspmv,sspmv);\n\tLOAD_CBLAS(backend,blas.sspr2,sspr2);\n\tLOAD_CBLAS(backend,blas.sspr,sspr);\n\tLOAD_CBLAS(backend,blas.sswap,sswap);\n\tLOAD_CBLAS(backend,blas.ssymm,ssymm);\n\tLOAD_CBLAS(backend,blas.ssymv,ssymv);\n\tLOAD_CBLAS(backend,blas.ssyr2,ssyr2);\n\tLOAD_CBLAS(backend,blas.ssyr2k,ssyr2k);\n\tLOAD_CBLAS(backend,blas.ssyr,ssyr);\n\tLOAD_CBLAS(backend,blas.ssyrk,ssyrk);\n\tLOAD_CBLAS(backend,blas.stbmv,stbmv);\n\tLOAD_CBLAS(backend,blas.stbsv,stbsv);\n\tLOAD_CBLAS(backend,blas.stpmv,stpmv);\n\tLOAD_CBLAS(backend,blas.stpsv,stpsv);\n\tLOAD_CBLAS(backend,blas.strmm,strmm);\n\tLOAD_CBLAS(backend,blas.strmv,strmv);\n\tLOAD_CBLAS(backend,blas.strsm,strsm);\n\tLOAD_CBLAS(backend,blas.strsv,strsv);\n\n\n\t/*-----------------------------------------------------------------------------\n\t *  Double Precision Routines\n\t *-----------------------------------------------------------------------------*/\n\tLOAD_CBLAS(backend,blas.dasum,dasum);\n\tLOAD_CBLAS(backend,blas.daxpy,daxpy);\n\tLOAD_CBLAS(backend,blas.dcopy,dcopy);\n\tLOAD_CBLAS(backend,blas.ddot,ddot);\n\tLOAD_CBLAS(backend,blas.dgbmv,dgbmv);\n\tLOAD_CBLAS(backend,blas.dgemm,dgemm);\n\tLOAD_CBLAS(backend,blas.dgemv,dgemv);\n\tLOAD_CBLAS(backend,blas.dger,dger);\n\tLOAD_CBLAS(backend,blas.dnrm2,dnrm2);\n\tLOAD_CBLAS(backend,blas.drot,drot);\n\tLOAD_CBLAS(backend,blas.drotg,drotg);\n\tLOAD_CBLAS(backend,blas.drotm,drotm);\n\tLOAD_CBLAS(backend,blas.drotmg,drotmg);\n\tLOAD_CBLAS(backend,blas.dsbmv,dsbmv);\n\tLOAD_CBLAS(backend,blas.dscal,dscal);\n\tLOAD_CBLAS(backend,blas.dsdot,dsdot);\n\tLOAD_CBLAS(backend,blas.dspmv,dspmv);\n\tLOAD_CBLAS(backend,blas.dspr2,dspr2);\n\tLOAD_CBLAS(backend,blas.dspr,dspr);\n\tLOAD_CBLAS(backend,blas.dswap,dswap);\n\tLOAD_CBLAS(backend,blas.dsymm,dsymm);\n\tLOAD_CBLAS(backend,blas.dsymv,dsymv);\n\tLOAD_CBLAS(backend,blas.dsyr2,dsyr2);\n\tLOAD_CBLAS(backend,blas.dsyr2k,dsyr2k);\n\tLOAD_CBLAS(backend,blas.dsyr,dsyr);\n\tLOAD_CBLAS(backend,blas.dsyrk,dsyrk);\n\tLOAD_CBLAS(backend,blas.dtbmv,dtbmv);\n\tLOAD_CBLAS(backend,blas.dtbsv,dtbsv);\n\tLOAD_CBLAS(backend,blas.dtpmv,dtpmv);\n\tLOAD_CBLAS(backend,blas.dtpsv,dtpsv);\n\tLOAD_CBLAS(backend,blas.dtrmm,dtrmm);\n\tLOAD_CBLAS(backend,blas.dtrmv,dtrmv);\n\tLOAD_CBLAS(backend,blas.dtrsm,dtrsm);\n\tLOAD_CBLAS(backend,blas.dtrsv,dtrsv);\n\tLOAD_CBLAS(backend,blas.dzasum,dzasum);\n\tLOAD_CBLAS(backend,blas.dznrm2,dznrm2);\n\n\n\t/*-----------------------------------------------------------------------------\n\t *  Complex Routines\n\t *-----------------------------------------------------------------------------*/\n\tLOAD_CBLAS(backend,blas.caxpy,caxpy);\n\tLOAD_CBLAS(backend,blas.ccopy,ccopy);\n\tLOAD_CBLAS(backend,blas.cdotc,cdotc_sub);\n\tLOAD_CBLAS(backend,blas.cdotu,cdotu_sub);\n\tLOAD_CBLAS(backend,blas.cgbmv,cgbmv);\n\tLOAD_CBLAS(backend,blas.cgemm,cgemm);\n\tLOAD_CBLAS(backend,blas.cgemv,cgemv);\n\tLOAD_CBLAS(backend,blas.cgerc,cgerc);\n\tLOAD_CBLAS(backend,blas.cgeru,cgeru);\n\tLOAD_CBLAS(backend,blas.chbmv,chbmv);\n\tLOAD_CBLAS(backend,blas.chemm,chemm);\n\tLOAD_CBLAS(backend,blas.chemv,chemv);\n\tLOAD_CBLAS(backend,blas.cher2,cher2);\n\tLOAD_CBLAS(backend,blas.cher2k,cher2k);\n\tLOAD_CBLAS(backend,blas.cher,cher);\n\tLOAD_CBLAS(backend,blas.cherk,cherk);\n\tLOAD_CBLAS(backend,blas.chpmv,chpmv);\n\tLOAD_CBLAS(backend,blas.chpr2,chpr2);\n\tLOAD_CBLAS(backend,blas.chpr,chpr);\n\tLOAD_CBLAS(backend,blas.crotg,crotg);\n\tLOAD_CBLAS(backend,blas.cscal,cscal);\n\tLOAD_CBLAS(backend,blas.csrot,csrot);\n\tLOAD_CBLAS(backend,blas.csscal,csscal);\n\tLOAD_CBLAS(backend,blas.cswap,cswap);\n\tLOAD_CBLAS(backend,blas.csymm,csymm);\n\tLOAD_CBLAS(backend,blas.csyr2k,csyr2k);\n\tLOAD_CBLAS(backend,blas.csyrk,csyrk);\n\tLOAD_CBLAS(backend,blas.ctbmv,ctbmv);\n\tLOAD_CBLAS(backend,blas.ctbsv,ctbsv);\n\tLOAD_CBLAS(backend,blas.ctpmv,ctpmv);\n\tLOAD_CBLAS(backend,blas.ctpsv,ctpsv);\n\tLOAD_CBLAS(backend,blas.ctrmm,ctrmm);\n\tLOAD_CBLAS(backend,blas.ctrmv,ctrmv);\n\tLOAD_CBLAS(backend,blas.ctrsm,ctrsm);\n\tLOAD_CBLAS(backend,blas.ctrsv,ctrsv);\n\n\n\t/*-----------------------------------------------------------------------------\n\t *  Complex*16 Routines\n\t *-----------------------------------------------------------------------------*/\n\tLOAD_CBLAS(backend,blas.zaxpy,zaxpy);\n\tLOAD_CBLAS(backend,blas.zcopy,zcopy);\n\tLOAD_CBLAS(backend,blas.zdotc,zdotc_sub);\n\tLOAD_CBLAS(backend,blas.zdotu,zdotu_sub);\n\tLOAD_CBLAS(backend,blas.zdrot,zdrot);\n\tLOAD_CBLAS(backend,blas.zdscal,zdscal);\n\tLOAD_CBLAS(backend,blas.zgbmv,zgbmv);\n\tLOAD_CBLAS(backend,blas.zgemm,zgemm);\n\tLOAD_CBLAS(backend,blas.zgemv,zgemv);\n\tLOAD_CBLAS(backend,blas.zgerc,zgerc);\n\tLOAD_CBLAS(backend,blas.zgeru,zgeru);\n\tLOAD_CBLAS(backend,blas.zhbmv,zhbmv);\n\tLOAD_CBLAS(backend,blas.zhemm,zhemm);\n\tLOAD_CBLAS(backend,blas.zhemv,zhemv);\n\tLOAD_CBLAS(backend,blas.zher2,zher2);\n\tLOAD_CBLAS(backend,blas.zher2k,zher2k);\n\tLOAD_CBLAS(backend,blas.zher,zher);\n\tLOAD_CBLAS(backend,blas.zherk,zherk);\n\tLOAD_CBLAS(backend,blas.zhpmv,zhpmv);\n\tLOAD_CBLAS(backend,blas.zhpr2,zhpr2);\n\tLOAD_CBLAS(backend,blas.zhpr,zhpr);\n\tLOAD_CBLAS(backend,blas.zrotg,zrotg);\n\tLOAD_CBLAS(backend,blas.zscal,zscal);\n\tLOAD_CBLAS(backend,blas.zswap,zswap);\n\tLOAD_CBLAS(backend,blas.zsymm,zsymm);\n\tLOAD_CBLAS(backend,blas.zsyr2k,zsyr2k);\n\tLOAD_CBLAS(backend,blas.zsyrk,zsyrk);\n\tLOAD_CBLAS(backend,blas.ztbmv,ztbmv);\n\tLOAD_CBLAS(backend,blas.ztbsv,ztbsv);\n\tLOAD_CBLAS(backend,blas.ztpmv,ztpmv);\n\tLOAD_CBLAS(backend,blas.ztpsv,ztpsv);\n\tLOAD_CBLAS(backend,blas.ztrmm,ztrmm);\n\tLOAD_CBLAS(backend,blas.ztrmv,ztrmv);\n\tLOAD_CBLAS(backend,blas.ztrsm,ztrsm);\n\tLOAD_CBLAS(backend,blas.ztrsv,ztrsv);\n\n\treturn 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/src/loader.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Linking FlexiBLAS statically or dynamically with other modules is making a\n * combined work based on FlexiBLAS. Thus, the terms and conditions of the GNU\n * General Public License cover the whole combination.\n *\n * As a special exception, the copyright holders of FlexiBLAS give you permission\n * to combine FlexiBLAS program with free software programs or libraries that are\n * released under the GNU LGPL and with independent modules that communicate with\n * FlexiBLAS solely through the BLAS/LAPACK interface as provided by the\n * BLAS/LAPACK reference implementation. You may copy and distribute such a system\n * following the terms of the GNU GPL for FlexiBLAS and the licenses of the other\n * code concerned, provided that you include the source code of that other code\n * when and as the GNU GPL requires distribution of source code and provided that\n * you do not modify the BLAS/LAPACK interface.\n *\n * Note that people who make modified versions of FlexiBLAS are not obligated to\n * grant this special exception for their modified versions; it is their choice\n * whether to do so. The GNU General Public License gives permission to release a\n * modified version without this exception; this exception also makes it possible\n * to release a modified version which carries forward this exception. If you\n * modify the BLAS/LAPACK interface, this exception does not apply to your\n * modified version of FlexiBLAS, and you must remove this exception when you\n * distribute your modified version.\n *\n * This exception is an additional permission under section 7 of the GNU General\n * Public License, version 3 (\u201cGPLv3\u201d)\n *\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2013-2020\n */\n\n\n\n#include \"flexiblas.h\"\n#include <errno.h>\n\n/*-----------------------------------------------------------------------------\n *  Load CBLAS\n *-----------------------------------------------------------------------------*/\nHIDDEN int __flexiblas_load_cblas_function( void * handle , struct flexiblas_blasfn * fn, const char *name)\n{\n#ifdef FLEXIBLAS_CBLAS\n\tvoid *ptr_csymbol = NULL;\n\tchar cname[40];\n\n\t/* Quick return  */\n\tif ( handle == NULL ) {\n\t\treturn 1;\n\t}\n\n\n\tsnprintf(cname, 39, \"cblas_%s\", name);\n\tDPRINTF(3, \"Look up: %18s\", cname);\n    ptr_csymbol = dlsym(handle, cname);\n\n\tfn -> cblas_real = ptr_csymbol;\n    fn -> cblas_function = ptr_csymbol;\n\n\tif ( __flexiblas_verbose > 2) {\n\t\tfprintf(stderr, \" %s.\\n\",(fn->cblas_function == NULL)?\"failed\":\"sucess\");\n\t}\n\n\tif (fn->cblas_function == NULL) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n#else\n\tfn->cblas_real = NULL;\n    fn->cblas_function = NULL;\n    return 0;\n#endif\n}\n\n/*-----------------------------------------------------------------------------\n *  Fortran Loader\n *-----------------------------------------------------------------------------*/\nHIDDEN int __flexiblas_load_fortran_function( void * handle , struct flexiblas_blasfn * fn, const char *name)\n{\n\tvoid *ptr_fsymbol = NULL;\n\tchar fname[40];\n\tint run = 0;\n\n\t/* Quick return  */\n\tif ( handle == NULL ) {\n\t\tfn ->f77_blas_function = NULL;\n\t\treturn 1;\n\t}\n\n\tDPRINTF(3, \"Look up: \");\n\tfor (run = 0; run < 2 ; run++) {\n\t\tif (run == 0) {\n\t\t\tsnprintf(fname, 39, \"%s_\", name);\n\t\t} else if ( run == 1 ){\n\t\t\tsnprintf(fname, 39, \"%s\", name);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tif ( __flexiblas_verbose > 2) {\n\t\t\tfprintf(stderr, \"%10s \", fname);\n\t\t}\n\n#ifdef __WIN32__\n\t\tptr_fsymbol = GetProcAddress(handle, fname);\n#else\n\t\tptr_fsymbol = dlsym(handle, fname);\n#endif\n\t\tif (ptr_fsymbol!=NULL) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfn -> f77_blas_function = ptr_fsymbol;\n\n\tif ( __flexiblas_verbose > 2 ) {\n\t\tfprintf(stderr, \" %s.\\n\",(fn->f77_blas_function == NULL)?\"failed\":\"sucess\");\n\t}\n\tif (fn->f77_blas_function == NULL) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n\n\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/src/tool/hookhandling.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Linking FlexiBLAS statically or dynamically with other modules is making a\n * combined work based on FlexiBLAS. Thus, the terms and conditions of the GNU\n * General Public License cover the whole combination.\n *\n * As a special exception, the copyright holders of FlexiBLAS give you permission\n * to combine FlexiBLAS program with free software programs or libraries that are\n * released under the GNU LGPL and with independent modules that communicate with\n * FlexiBLAS solely through the BLAS/LAPACK interface as provided by the\n * BLAS/LAPACK reference implementation. You may copy and distribute such a system\n * following the terms of the GNU GPL for FlexiBLAS and the licenses of the other\n * code concerned, provided that you include the source code of that other code\n * when and as the GNU GPL requires distribution of source code and provided that\n * you do not modify the BLAS/LAPACK interface.\n *\n * Note that people who make modified versions of FlexiBLAS are not obligated to\n * grant this special exception for their modified versions; it is their choice\n * whether to do so. The GNU General Public License gives permission to release a\n * modified version without this exception; this exception also makes it possible\n * to release a modified version which carries forward this exception. If you\n * modify the BLAS/LAPACK interface, this exception does not apply to your\n * modified version of FlexiBLAS, and you must remove this exception when you\n * distribute your modified version.\n *\n * This exception is an additional permission under section 7 of the GNU General\n * Public License, version 3 (\u201cGPLv3\u201d)\n *\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2013-2020\n */\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <dlfcn.h>\n#ifdef __linux__\n#define _GNU_SOURCE\n#endif\n\n#include \"flexiblas.h\"\n#include \"flexiblas_config.h\"\n#include \"paths.h\"\n#include \"helper.h\"\n#include \"hooks.h\"\n#include \"cscutils/strutils.h\"\n#include \"tool.h\"\n\nint disable_all_hooks(flexiblas_mgmt_location_t loc)\n{\n    flexiblas_mgmt_t *config;\n    int     ret = 0;\n\n    config = flexiblas_mgmt_load_config();\n    if (config == NULL) {\n        printf(\"Failed to open configuration files. Abort.\\n\");\n        return 1;\n    }\n\n    flexiblas_mgmt_hook_disable_all(config, loc);\n\n    ret = flexiblas_mgmt_write_config2(config, loc);\n    flexiblas_mgmt_free_config(config);\n    if ( ret ) {\n        printf(\"Failed to write the configuration to %s.\\n\", flexiblas_mgmt_location_to_string(loc));\n        return 1;\n    }\n    return 0 ;\n\n}\n\nint disable_hook(flexiblas_mgmt_location_t loc, const char *name)\n{\n    flexiblas_mgmt_t *config;\n    int ret = 0;\n\n    config = flexiblas_mgmt_load_config();\n    if (config == NULL) {\n        printf(\"Failed to open configuration files. Abort.\\n\");\n        return 1;\n    }\n    if ( flexiblas_mgmt_hook_disable(config, loc, name)) {\n        printf(\"Disabling hook %s failed.\\n\", name);\n    } else {\n        printf(\"Disable hook %s successful.\\n\", name);\n        ret = flexiblas_mgmt_write_config2(config,loc);\n        if ( ret ) {\n            flexiblas_mgmt_free_config(config);\n            printf(\"Failed to write the configuration to %s.\\n\", flexiblas_mgmt_location_to_string(loc));\n            return 1;\n        }\n\n    }\n    flexiblas_mgmt_free_config(config);\n    return 0 ;\n}\n\nint enable_hook(flexiblas_mgmt_location_t loc, char *name)\n{\n    flexiblas_mgmt_t *config;\n    int ret = 0;\n    int ecode = 0;\n\n    if ( loc == FLEXIBLAS_GLOBAL) {\n        fprintf(stderr, \"Enabling global hooks is not allowed.\\n\");\n        exit(-1);\n    }\n\n    config = flexiblas_mgmt_load_config();\n    if (config == NULL) {\n        printf(\"Failed to open configuration files. Abort.\\n\");\n        return 1;\n    }\n\n    if (!  __flexiblas_hook_exists(name)) {\n         printf(\"Hook %s does not exists.\\n\", name);\n         ecode = 1; goto fin;\n    }\n\n    if ( flexiblas_mgmt_hook_enable(config, loc, name)) {\n        printf(\"Enabling hook %s failed.\\n\", name);\n    } else {\n        printf(\"Enable hook %s successful.\\n\", name);\n        ret = flexiblas_mgmt_write_config2(config,loc);\n        if ( ret ) {\n            printf(\"Failed to write the configuration to %s.\\n\", flexiblas_mgmt_location_to_string(loc));\n            ecode = 1; goto fin;\n        }\n    }\n\nfin:\n    flexiblas_mgmt_free_config(config);\n    return ecode;\n}\n\nint  show_hook(char *name)\n{\n    char *sofile;\n    int ecode = 0;\n    void *handle = NULL;\n\n    if (! __flexiblas_hook_exists(name)) {\n         printf(\"No hook named %s is found.\\n\", name);\n         ecode = 1;\n         goto fin;\n    }\n\n    sofile = __flexiblas_hook_sofile(name);\n    if (!sofile) {\n         printf(\"No hook named %s is found.\\n\", name);\n         ecode = 1;\n         goto fin;\n    }\n\n    dlerror();\n    handle = __flexiblas_dlopen(sofile, RTLD_LAZY | RTLD_LOCAL, NULL);\n    if ( !handle) {\n        printf(\"Cannot open %s as shared library. (error = %s)\\n\", sofile, dlerror());\n        ecode = 1;\n        goto fin;\n    }\n\n    flexiblas_hook_register_t *reg = (flexiblas_hook_register_t *) dlsym(handle, \"flexiblas_register\");\n\n    printf(\"Name:          %s\\n\", reg->name);\n    printf(\"Configuration: %s\\n\", reg->cfg_name);\n    printf(\"Author(s):     %s\\n\", reg->authors);\n    printf(\"Description:   %s\\n\", reg->desc);\n\n    int cnt = 0;\n    int nopts = 0;\n    flexiblas_option_t *opts = (flexiblas_option_t *) dlsym(handle, \"flexiblas_options\");\n    if ( opts == NULL)\n        nopts = 0;\n    else {\n        cnt = 0;\n        while(opts[cnt].name != NULL) cnt++;\n        nopts = cnt;\n    }\n\n    for (cnt = 0; cnt < nopts; cnt++) {\n        printf(\"\\n\");\n        printf(\"Option:      %s\\n\", opts[cnt].name);\n        printf(\"Description: %s\\n\", opts[cnt].desc);\n        printf(\"Type:        \");\n        switch(opts[cnt].type) {\n            case FLEXIBLAS_OPTIONS_INT:\n                printf(\"Integer\\n\"); break;\n            case FLEXIBLAS_OPTIONS_STRING:\n                printf(\"String\\n\"); break;\n            case FLEXIBLAS_OPTIONS_FLOAT:\n                printf(\"Float\\n\");break;\n            default:\n                ;\n        }\n        printf(\"Default:     %s\\n\", opts[cnt].def);\n    }\nfin:\n    if ( handle != NULL) dlclose(handle);\n    return ecode;\n\n}\n\n\n\n\n\n\nint list_all_hooks()\n{\n    char **list1;\n    char **list2;\n    int nelem;\n    int i;\n\n    if ( !pipe_output ) printf(\"Available hooks:\\n\");\n    __flexiblas_hook_list(&nelem, &list1, &list2);\n    for ( i = 0 ; i < nelem; i++ ) {\n        if (pipe_output) {\n            printf(\"%s|%s\\n\", list1[i], list2[i]);\n        } else {\n            printf(\"  %s (%s)\\n\", list1[i], list2[i]);\n        }\n        free(list1[i]);\n        free(list2[i]);\n    }\n    free(list1);\n    free(list2);\n    return 0;\n\n}\n\nint list_enabled_hooks()\n{\n    int i, j;\n    flexiblas_mgmt_location_t loc;\n    flexiblas_mgmt_t *config;\n    int nelem;\n    char ** list;\n\n    config = flexiblas_mgmt_load_config();\n\n    if ( ! config ) return -1;\n\n    for ( i = 0; i < 3; i++)\n    {\n        if ( i == 0 )\n            loc = FLEXIBLAS_USER;\n        else if ( i == 1 )\n            loc = FLEXIBLAS_HOST;\n        else if ( i == 2 )\n            loc = FLEXIBLAS_ENV;\n\n        if ( flexiblas_mgmt_hook_get_active_internal(config, loc, &nelem, &list))\n            continue;\n\n        if (! pipe_output ) {\n            printf(\"Enabled Hooks in %s:\\n\", flexiblas_mgmt_location_to_string(loc));\n        } else {\n            if ( loc == FLEXIBLAS_USER)\n                printf(\"user|\");\n            else if ( loc == FLEXIBLAS_HOST )\n                printf(\"host|\");\n            else if ( loc == FLEXIBLAS_ENV )\n                printf(\"env|\");\n        }\n\n        for ( j = 0; j < nelem; j++) {\n            if (!pipe_output) {\n                printf(\"- %s\\n\", list[j]);\n            } else {\n                printf(\"%s\", list[j]);\n                if ( j < nelem-1 )\n                    printf(\"|\");\n            }\n            free(list[j]);\n        }\n\n        if (pipe_output) printf(\"\\n\");\n        free(list);\n    }\n\n    if ( config ) flexiblas_mgmt_free_config(config);\n    return 0;\n\n}\n\nint list_active_hooks()\n{\n    int j;\n    flexiblas_mgmt_location_t loc;\n    flexiblas_mgmt_t *config;\n    int nelem;\n    char ** list;\n\n    config = flexiblas_mgmt_load_config();\n\n    if ( ! config ) return -1;\n\n    if ( flexiblas_mgmt_hook_get_active(config, &loc, &nelem, &list))\n    {\n        if ( pipe_output ) printf(\"none\\n\");\n        else printf(\"No hooks enabled.\\n\");\n        return 0;\n    }\n\n    if (! pipe_output ) {\n        printf(\"Currently active hooks from %s:\\n\", flexiblas_mgmt_location_to_string(loc));\n        if ( nelem == 0 ) {\n            printf(\"Hooks are explicitly disabled in the %s configuration.\\n\", flexiblas_mgmt_location_to_string(loc));\n            printf(\"You can remove the setting using the \\\"disableall\\\" subcommand.\\n\");\n        }\n    } else {\n        if ( loc == FLEXIBLAS_USER)\n            printf(\"user|\");\n        else if ( loc == FLEXIBLAS_HOST )\n            printf(\"host|\");\n        else if ( loc == FLEXIBLAS_ENV )\n            printf(\"env|\");\n    }\n\n    for ( j = 0; j < nelem; j++) {\n        if (!pipe_output) {\n            printf(\"- %s\\n\", list[j]);\n        } else {\n            printf(\"%s\", list[j]);\n            if ( j < nelem-1 )\n                printf(\"|\");\n        }\n        free(list[j]);\n    }\n\n    if (pipe_output) printf(\"\\n\");\n    free(list);\n\n    if ( config ) flexiblas_mgmt_free_config(config);\n    return 0;\n\n}\n\n\n\nint hook_option_set(flexiblas_mgmt_location_t loc, char *hookname, char *option, char *value)\n{\n\n    char *sofile;\n    void *handle;\n    flexiblas_hook_register_t *reg = NULL;\n    flexiblas_option_t * opts = NULL;\n    int nopts, i, found;\n    int ecode = 0;\n    char *help;\n    flexiblas_mgmt_t *config = NULL ;\n\n\n\n    if ( ! __flexiblas_hook_exists(hookname)) {\n        printf(\"Hook %s does not exist.\\n\", hookname);\n        return -1;\n    }\n\n    sofile = __flexiblas_hook_sofile(hookname);\n    if (!sofile) {\n         printf(\"No hook named %s is found.\\n\", hookname);\n         return -1;\n    }\n\n    handle = __flexiblas_dlopen(sofile, RTLD_LAZY | RTLD_LOCAL, NULL);\n    if ( !handle) {\n        printf(\"Opening hook %s/%s failed.\\n\", hookname, sofile);\n        return -1;\n    }\n    reg = (flexiblas_hook_register_t *) dlsym(handle, \"flexiblas_register\");\n    opts = (flexiblas_option_t *) dlsym(handle, \"flexiblas_options\");\n\n    if ( reg == NULL) {\n        printf(\"The shared object %s is not a hook.\\n\", sofile);\n        dlclose(handle);\n        return -1;\n    }\n    if ( opts == NULL) {\n        printf(\"The hook %s does not have any options.\\n\", reg->cfg_name);\n        dlclose(handle);\n        return -1;\n    }\n\n    nopts = 0;\n    while(opts[nopts].name != NULL) nopts++;\n\n    found = -1;\n    for (i = 0; i < nopts; i++) {\n        if ( strcmp(opts[i].name, option) == 0 ) {\n            found = i;\n        }\n    }\n    if (found < 0) {\n        printf(\"Option %s not found in hook %s\\n\", option, hookname);\n        dlclose(handle);\n        return -1;\n    }\n\n    config = flexiblas_mgmt_load_config();\n    if ( !config) {\n        printf(\"Failed to load config.\\n\");\n        ecode = -1;\n        goto fin;\n    }\n\n    switch ( opts[found].type) {\n        case FLEXIBLAS_OPTIONS_INT:\n            {\n                int v;\n                help = NULL;\n                v = strtol (value, &help, 10);\n                if ( help && !(help[0] == '\\0')) {\n                    printf(\"The option is required to be an integer but something different was provided. (value = %s, err = '%s')\\n\", value, help);\n                    ecode = 1;\n                    goto fin;\n                }\n                ecode = flexiblas_mgmt_hook_option_set_int(config, loc, reg->cfg_name, option, v);\n            }\n            break;\n        case FLEXIBLAS_OPTIONS_FLOAT:\n            {\n                double v;\n                v = strtod (value, &help);\n                if ( help == value || help[0] != '\\0') {\n                    printf(\"The option is required to be a float but something different was provided. (value = %s, err = '%s')\\n\", value, help);\n                    ecode = 1;\n                    goto fin;\n                }\n                ecode = flexiblas_mgmt_hook_option_set_float(config, loc, reg->cfg_name, option, v);\n            }\n            break;\n        case FLEXIBLAS_OPTIONS_STRING:\n            ecode = flexiblas_mgmt_hook_option_set_string(config, loc, reg->cfg_name, option, value);\n            break;\n        default:\n            ;\n\n    }\n    if (!ecode) {\n        ecode = flexiblas_mgmt_write_config2(config, loc);\n        if ( ecode ) {\n            printf(\"Failed to write the configuration to %s.\\n\", flexiblas_mgmt_location_to_string(loc));\n\n        }\n    }\n\nfin:\n    if ( config ) flexiblas_mgmt_free_config(config);\n    dlclose(handle);\n    return ecode;\n}\n\nint hook_option_unset(flexiblas_mgmt_location_t loc, char *hookname, char *option)\n{\n\n    int ecode = 0;\n    flexiblas_mgmt_t *config = NULL ;\n\n\n\n    if ( ! __flexiblas_hook_exists(hookname)) {\n        printf(\"Hook %s does not exist.\\n\", hookname);\n        return -1;\n    }\n\n    config = flexiblas_mgmt_load_config();\n    if ( !config) {\n        printf(\"Failed to load config.\\n\");\n        ecode = -1;\n        goto fin;\n    }\n\n    ecode = flexiblas_mgmt_hook_option_unset(config, loc, hookname, option);\n    if (ecode == -2) {\n        ecode = 0;\n    }\n\n    if (!ecode) {\n        ecode = flexiblas_mgmt_write_config2(config, loc);\n        if ( ecode ) {\n            printf(\"Failed to write the configuration to %s.\\n\", flexiblas_mgmt_location_to_string(loc));\n\n        }\n    }\n\nfin:\n    if ( config ) flexiblas_mgmt_free_config(config);\n    return ecode;\n\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/libcscutils/contrib/lua/src/loadlib.c": "/*\n** $Id: loadlib.c,v 1.130.1.1 2017/04/19 17:20:42 roberto Exp $\n** Dynamic library loader for Lua\n** See Copyright Notice in lua.h\n**\n** This module contains an implementation of loadlib for Unix systems\n** that have dlfcn, an implementation for Windows, and a stub for other\n** systems.\n*/\n\n#define loadlib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/*\n** LUA_IGMARK is a mark to ignore all before it when building the\n** luaopen_ function name.\n*/\n#if !defined (LUA_IGMARK)\n#define LUA_IGMARK\t\t\"-\"\n#endif\n\n\n/*\n** LUA_CSUBSEP is the character that replaces dots in submodule names\n** when searching for a C loader.\n** LUA_LSUBSEP is the character that replaces dots in submodule names\n** when searching for a Lua loader.\n*/\n#if !defined(LUA_CSUBSEP)\n#define LUA_CSUBSEP\t\tLUA_DIRSEP\n#endif\n\n#if !defined(LUA_LSUBSEP)\n#define LUA_LSUBSEP\t\tLUA_DIRSEP\n#endif\n\n\n/* prefix for open functions in C libraries */\n#define LUA_POF\t\t\"luaopen_\"\n\n/* separator for open functions in C libraries */\n#define LUA_OFSEP\t\"_\"\n\n\n/*\n** unique key for table in the registry that keeps handles\n** for all loaded C libraries\n*/\nstatic const int CLIBS = 0;\n\n#define LIB_FAIL\t\"open\"\n\n\n#define setprogdir(L)           ((void)0)\n\n\n/*\n** system-dependent functions\n*/\n\n/*\n** unload library 'lib'\n*/\nstatic void lsys_unloadlib (void *lib);\n\n/*\n** load C library in file 'path'. If 'seeglb', load with all names in\n** the library global.\n** Returns the library; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb);\n\n/*\n** Try to find a function named 'sym' in library 'lib'.\n** Returns the function; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym);\n\n\n\n\n#if defined(LUA_USE_DLOPEN)\t/* { */\n/*\n** {========================================================================\n** This is an implementation of loadlib based on the dlfcn interface.\n** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,\n** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least\n** as an emulation layer on top of native functions.\n** =========================================================================\n*/\n\n#include <dlfcn.h>\n\n/*\n** Macro to convert pointer-to-void* to pointer-to-function. This cast\n** is undefined according to ISO C, but POSIX assumes that it works.\n** (The '__extension__' in gnu compilers is only to avoid warnings.)\n*/\n#if defined(__GNUC__)\n#define cast_func(p) (__extension__ (lua_CFunction)(p))\n#else\n#define cast_func(p) ((lua_CFunction)(p))\n#endif\n\n\nstatic void lsys_unloadlib (void *lib) {\n  dlclose(lib);\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  void *lib = dlopen(path, RTLD_NOW | (seeglb ? RTLD_GLOBAL : RTLD_LOCAL));\n  if (lib == NULL) lua_pushstring(L, dlerror());\n  return lib;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = cast_func(dlsym(lib, sym));\n  if (f == NULL) lua_pushstring(L, dlerror());\n  return f;\n}\n\n/* }====================================================== */\n\n\n\n#elif defined(LUA_DL_DLL)\t/* }{ */\n/*\n** {======================================================================\n** This is an implementation of loadlib for Windows using native functions.\n** =======================================================================\n*/\n\n#include <windows.h>\n\n\n/*\n** optional flags for LoadLibraryEx\n*/\n#if !defined(LUA_LLE_FLAGS)\n#define LUA_LLE_FLAGS\t0\n#endif\n\n\n#undef setprogdir\n\n\n/*\n** Replace in the path (on the top of the stack) any occurrence\n** of LUA_EXEC_DIR with the executable's path.\n*/\nstatic void setprogdir (lua_State *L) {\n  char buff[MAX_PATH + 1];\n  char *lb;\n  DWORD nsize = sizeof(buff)/sizeof(char);\n  DWORD n = GetModuleFileNameA(NULL, buff, nsize);  /* get exec. name */\n  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\\\')) == NULL)\n    luaL_error(L, \"unable to get ModuleFileName\");\n  else {\n    *lb = '\\0';  /* cut name on the last '\\\\' to get the path */\n    luaL_gsub(L, lua_tostring(L, -1), LUA_EXEC_DIR, buff);\n    lua_remove(L, -2);  /* remove original string */\n  }\n}\n\n\n\n\nstatic void pusherror (lua_State *L) {\n  int error = GetLastError();\n  char buffer[128];\n  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, buffer, sizeof(buffer)/sizeof(char), NULL))\n    lua_pushstring(L, buffer);\n  else\n    lua_pushfstring(L, \"system error %d\\n\", error);\n}\n\nstatic void lsys_unloadlib (void *lib) {\n  FreeLibrary((HMODULE)lib);\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  HMODULE lib = LoadLibraryExA(path, NULL, LUA_LLE_FLAGS);\n  (void)(seeglb);  /* not used: symbols are 'global' by default */\n  if (lib == NULL) pusherror(L);\n  return lib;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)GetProcAddress((HMODULE)lib, sym);\n  if (f == NULL) pusherror(L);\n  return f;\n}\n\n/* }====================================================== */\n\n\n#else\t\t\t\t/* }{ */\n/*\n** {======================================================\n** Fallback for other systems\n** =======================================================\n*/\n\n#undef LIB_FAIL\n#define LIB_FAIL\t\"absent\"\n\n\n#define DLMSG\t\"dynamic libraries not enabled; check your Lua installation\"\n\n\nstatic void lsys_unloadlib (void *lib) {\n  (void)(lib);  /* not used */\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  (void)(path); (void)(seeglb);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  (void)(lib); (void)(sym);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n/* }====================================================== */\n#endif\t\t\t\t/* } */\n\n\n/*\n** {==================================================================\n** Set Paths\n** ===================================================================\n*/\n\n/*\n** LUA_PATH_VAR and LUA_CPATH_VAR are the names of the environment\n** variables that Lua check to set its paths.\n*/\n#if !defined(LUA_PATH_VAR)\n#define LUA_PATH_VAR    \"LUA_PATH\"\n#endif\n\n#if !defined(LUA_CPATH_VAR)\n#define LUA_CPATH_VAR   \"LUA_CPATH\"\n#endif\n\n\n#define AUXMARK         \"\\1\"\t/* auxiliary mark */\n\n\n/*\n** return registry.LUA_NOENV as a boolean\n*/\nstatic int noenv (lua_State *L) {\n  int b;\n  lua_getfield(L, LUA_REGISTRYINDEX, \"LUA_NOENV\");\n  b = lua_toboolean(L, -1);\n  lua_pop(L, 1);  /* remove value */\n  return b;\n}\n\n\n/*\n** Set a path\n*/\nstatic void setpath (lua_State *L, const char *fieldname,\n                                   const char *envname,\n                                   const char *dft) {\n  const char *nver = lua_pushfstring(L, \"%s%s\", envname, LUA_VERSUFFIX);\n  const char *path = getenv(nver);  /* use versioned name */\n  if (path == NULL)  /* no environment variable? */\n    path = getenv(envname);  /* try unversioned name */\n  if (path == NULL || noenv(L))  /* no environment variable? */\n    lua_pushstring(L, dft);  /* use default */\n  else {\n    /* replace \";;\" by \";AUXMARK;\" and then AUXMARK by default path */\n    path = luaL_gsub(L, path, LUA_PATH_SEP LUA_PATH_SEP,\n                              LUA_PATH_SEP AUXMARK LUA_PATH_SEP);\n    luaL_gsub(L, path, AUXMARK, dft);\n    lua_remove(L, -2); /* remove result from 1st 'gsub' */\n  }\n  setprogdir(L);\n  lua_setfield(L, -3, fieldname);  /* package[fieldname] = path value */\n  lua_pop(L, 1);  /* pop versioned variable name */\n}\n\n/* }================================================================== */\n\n\n/*\n** return registry.CLIBS[path]\n*/\nstatic void *checkclib (lua_State *L, const char *path) {\n  void *plib;\n  lua_rawgetp(L, LUA_REGISTRYINDEX, &CLIBS);\n  lua_getfield(L, -1, path);\n  plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */\n  lua_pop(L, 2);  /* pop CLIBS table and 'plib' */\n  return plib;\n}\n\n\n/*\n** registry.CLIBS[path] = plib        -- for queries\n** registry.CLIBS[#CLIBS + 1] = plib  -- also keep a list of all libraries\n*/\nstatic void addtoclib (lua_State *L, const char *path, void *plib) {\n  lua_rawgetp(L, LUA_REGISTRYINDEX, &CLIBS);\n  lua_pushlightuserdata(L, plib);\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -3, path);  /* CLIBS[path] = plib */\n  lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */\n  lua_pop(L, 1);  /* pop CLIBS table */\n}\n\n\n/*\n** __gc tag method for CLIBS table: calls 'lsys_unloadlib' for all lib\n** handles in list CLIBS\n*/\nstatic int gctm (lua_State *L) {\n  lua_Integer n = luaL_len(L, 1);\n  for (; n >= 1; n--) {  /* for each handle, in reverse order */\n    lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */\n    lsys_unloadlib(lua_touserdata(L, -1));\n    lua_pop(L, 1);  /* pop handle */\n  }\n  return 0;\n}\n\n\n\n/* error codes for 'lookforfunc' */\n#define ERRLIB\t\t1\n#define ERRFUNC\t\t2\n\n/*\n** Look for a C function named 'sym' in a dynamically loaded library\n** 'path'.\n** First, check whether the library is already loaded; if not, try\n** to load it.\n** Then, if 'sym' is '*', return true (as library has been loaded).\n** Otherwise, look for symbol 'sym' in the library and push a\n** C function with that symbol.\n** Return 0 and 'true' or a function in the stack; in case of\n** errors, return an error code and an error message in the stack.\n*/\nstatic int lookforfunc (lua_State *L, const char *path, const char *sym) {\n  void *reg = checkclib(L, path);  /* check loaded C libraries */\n  if (reg == NULL) {  /* must load library? */\n    reg = lsys_load(L, path, *sym == '*');  /* global symbols if 'sym'=='*' */\n    if (reg == NULL) return ERRLIB;  /* unable to load library */\n    addtoclib(L, path, reg);\n  }\n  if (*sym == '*') {  /* loading only library (no function)? */\n    lua_pushboolean(L, 1);  /* return 'true' */\n    return 0;  /* no errors */\n  }\n  else {\n    lua_CFunction f = lsys_sym(L, reg, sym);\n    if (f == NULL)\n      return ERRFUNC;  /* unable to find function */\n    lua_pushcfunction(L, f);  /* else create new function */\n    return 0;  /* no errors */\n  }\n}\n\n\nstatic int ll_loadlib (lua_State *L) {\n  const char *path = luaL_checkstring(L, 1);\n  const char *init = luaL_checkstring(L, 2);\n  int stat = lookforfunc(L, path, init);\n  if (stat == 0)  /* no errors? */\n    return 1;  /* return the loaded function */\n  else {  /* error; error message is on stack top */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : \"init\");\n    return 3;  /* return nil, error message, and where */\n  }\n}\n\n\n\n/*\n** {======================================================\n** 'require' function\n** =======================================================\n*/\n\n\nstatic int readable (const char *filename) {\n  FILE *f = fopen(filename, \"r\");  /* try to open file */\n  if (f == NULL) return 0;  /* open failed */\n  fclose(f);\n  return 1;\n}\n\n\nstatic const char *pushnexttemplate (lua_State *L, const char *path) {\n  const char *l;\n  while (*path == *LUA_PATH_SEP) path++;  /* skip separators */\n  if (*path == '\\0') return NULL;  /* no more templates */\n  l = strchr(path, *LUA_PATH_SEP);  /* find next separator */\n  if (l == NULL) l = path + strlen(path);\n  lua_pushlstring(L, path, l - path);  /* template */\n  return l;\n}\n\n\nstatic const char *searchpath (lua_State *L, const char *name,\n                                             const char *path,\n                                             const char *sep,\n                                             const char *dirsep) {\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  if (*sep != '\\0')  /* non-empty separator? */\n    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */\n  while ((path = pushnexttemplate(L, path)) != NULL) {\n    const char *filename = luaL_gsub(L, lua_tostring(L, -1),\n                                     LUA_PATH_MARK, name);\n    lua_remove(L, -2);  /* remove path template */\n    if (readable(filename))  /* does file exist and is readable? */\n      return filename;  /* return that file name */\n    lua_pushfstring(L, \"\\n\\tno file '%s'\", filename);\n    lua_remove(L, -2);  /* remove file name */\n    luaL_addvalue(&msg);  /* concatenate error msg. entry */\n  }\n  luaL_pushresult(&msg);  /* create error message */\n  return NULL;  /* not found */\n}\n\n\nstatic int ll_searchpath (lua_State *L) {\n  const char *f = searchpath(L, luaL_checkstring(L, 1),\n                                luaL_checkstring(L, 2),\n                                luaL_optstring(L, 3, \".\"),\n                                luaL_optstring(L, 4, LUA_DIRSEP));\n  if (f != NULL) return 1;\n  else {  /* error message is on top of the stack */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    return 2;  /* return nil + error message */\n  }\n}\n\n\nstatic const char *findfile (lua_State *L, const char *name,\n                                           const char *pname,\n                                           const char *dirsep) {\n  const char *path;\n  lua_getfield(L, lua_upvalueindex(1), pname);\n  path = lua_tostring(L, -1);\n  if (path == NULL)\n    luaL_error(L, \"'package.%s' must be a string\", pname);\n  return searchpath(L, name, path, \".\", dirsep);\n}\n\n\nstatic int checkload (lua_State *L, int stat, const char *filename) {\n  if (stat) {  /* module loaded successfully? */\n    lua_pushstring(L, filename);  /* will be 2nd argument to module */\n    return 2;  /* return open function and file name */\n  }\n  else\n    return luaL_error(L, \"error loading module '%s' from file '%s':\\n\\t%s\",\n                          lua_tostring(L, 1), filename, lua_tostring(L, -1));\n}\n\n\nstatic int searcher_Lua (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  filename = findfile(L, name, \"path\", LUA_LSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);\n}\n\n\n/*\n** Try to find a load function for module 'modname' at file 'filename'.\n** First, change '.' to '_' in 'modname'; then, if 'modname' has\n** the form X-Y (that is, it has an \"ignore mark\"), build a function\n** name \"luaopen_X\" and look for it. (For compatibility, if that\n** fails, it also tries \"luaopen_Y\".) If there is no ignore mark,\n** look for a function named \"luaopen_modname\".\n*/\nstatic int loadfunc (lua_State *L, const char *filename, const char *modname) {\n  const char *openfunc;\n  const char *mark;\n  modname = luaL_gsub(L, modname, \".\", LUA_OFSEP);\n  mark = strchr(modname, *LUA_IGMARK);\n  if (mark) {\n    int stat;\n    openfunc = lua_pushlstring(L, modname, mark - modname);\n    openfunc = lua_pushfstring(L, LUA_POF\"%s\", openfunc);\n    stat = lookforfunc(L, filename, openfunc);\n    if (stat != ERRFUNC) return stat;\n    modname = mark + 1;  /* else go ahead and try old-style name */\n  }\n  openfunc = lua_pushfstring(L, LUA_POF\"%s\", modname);\n  return lookforfunc(L, filename, openfunc);\n}\n\n\nstatic int searcher_C (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  const char *filename = findfile(L, name, \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (loadfunc(L, filename, name) == 0), filename);\n}\n\n\nstatic int searcher_Croot (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  const char *p = strchr(name, '.');\n  int stat;\n  if (p == NULL) return 0;  /* is root */\n  lua_pushlstring(L, name, p - name);\n  filename = findfile(L, lua_tostring(L, -1), \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* root not found */\n  if ((stat = loadfunc(L, filename, name)) != 0) {\n    if (stat != ERRFUNC)\n      return checkload(L, 0, filename);  /* real error */\n    else {  /* open function not found */\n      lua_pushfstring(L, \"\\n\\tno module '%s' in file '%s'\", name, filename);\n      return 1;\n    }\n  }\n  lua_pushstring(L, filename);  /* will be 2nd argument to module */\n  return 2;\n}\n\n\nstatic int searcher_preload (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_getfield(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);\n  if (lua_getfield(L, -1, name) == LUA_TNIL)  /* not found? */\n    lua_pushfstring(L, \"\\n\\tno field package.preload['%s']\", name);\n  return 1;\n}\n\n\nstatic void findloader (lua_State *L, const char *name) {\n  int i;\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  /* push 'package.searchers' to index 3 in the stack */\n  if (lua_getfield(L, lua_upvalueindex(1), \"searchers\") != LUA_TTABLE)\n    luaL_error(L, \"'package.searchers' must be a table\");\n  /*  iterate over available searchers to find a loader */\n  for (i = 1; ; i++) {\n    if (lua_rawgeti(L, 3, i) == LUA_TNIL) {  /* no more searchers? */\n      lua_pop(L, 1);  /* remove nil */\n      luaL_pushresult(&msg);  /* create error message */\n      luaL_error(L, \"module '%s' not found:%s\", name, lua_tostring(L, -1));\n    }\n    lua_pushstring(L, name);\n    lua_call(L, 1, 2);  /* call it */\n    if (lua_isfunction(L, -2))  /* did it find a loader? */\n      return;  /* module loader found */\n    else if (lua_isstring(L, -2)) {  /* searcher returned error message? */\n      lua_pop(L, 1);  /* remove extra return */\n      luaL_addvalue(&msg);  /* concatenate error message */\n    }\n    else\n      lua_pop(L, 2);  /* remove both returns */\n  }\n}\n\n\nstatic int ll_require (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_settop(L, 1);  /* LOADED table will be at index 2 */\n  lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n  lua_getfield(L, 2, name);  /* LOADED[name] */\n  if (lua_toboolean(L, -1))  /* is it there? */\n    return 1;  /* package is already loaded */\n  /* else must load package */\n  lua_pop(L, 1);  /* remove 'getfield' result */\n  findloader(L, name);\n  lua_pushstring(L, name);  /* pass name as argument to module loader */\n  lua_insert(L, -2);  /* name is 1st argument (before search data) */\n  lua_call(L, 2, 1);  /* run loader to load module */\n  if (!lua_isnil(L, -1))  /* non-nil return? */\n    lua_setfield(L, 2, name);  /* LOADED[name] = returned value */\n  if (lua_getfield(L, 2, name) == LUA_TNIL) {   /* module set no value? */\n    lua_pushboolean(L, 1);  /* use true as result */\n    lua_pushvalue(L, -1);  /* extra copy to be returned */\n    lua_setfield(L, 2, name);  /* LOADED[name] = true */\n  }\n  return 1;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** 'module' function\n** =======================================================\n*/\n#if defined(LUA_COMPAT_MODULE)\n\n/*\n** changes the environment variable of calling function\n*/\nstatic void set_env (lua_State *L) {\n  lua_Debug ar;\n  if (lua_getstack(L, 1, &ar) == 0 ||\n      lua_getinfo(L, \"f\", &ar) == 0 ||  /* get calling function */\n      lua_iscfunction(L, -1))\n    luaL_error(L, \"'module' not called from a Lua function\");\n  lua_pushvalue(L, -2);  /* copy new environment table to top */\n  lua_setupvalue(L, -2, 1);\n  lua_pop(L, 1);  /* remove function */\n}\n\n\nstatic void dooptions (lua_State *L, int n) {\n  int i;\n  for (i = 2; i <= n; i++) {\n    if (lua_isfunction(L, i)) {  /* avoid 'calling' extra info. */\n      lua_pushvalue(L, i);  /* get option (a function) */\n      lua_pushvalue(L, -2);  /* module */\n      lua_call(L, 1, 0);\n    }\n  }\n}\n\n\nstatic void modinit (lua_State *L, const char *modname) {\n  const char *dot;\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -2, \"_M\");  /* module._M = module */\n  lua_pushstring(L, modname);\n  lua_setfield(L, -2, \"_NAME\");\n  dot = strrchr(modname, '.');  /* look for last dot in module name */\n  if (dot == NULL) dot = modname;\n  else dot++;\n  /* set _PACKAGE as package name (full module name minus last part) */\n  lua_pushlstring(L, modname, dot - modname);\n  lua_setfield(L, -2, \"_PACKAGE\");\n}\n\n\nstatic int ll_module (lua_State *L) {\n  const char *modname = luaL_checkstring(L, 1);\n  int lastarg = lua_gettop(L);  /* last parameter */\n  luaL_pushmodule(L, modname, 1);  /* get/create module table */\n  /* check whether table already has a _NAME field */\n  if (lua_getfield(L, -1, \"_NAME\") != LUA_TNIL)\n    lua_pop(L, 1);  /* table is an initialized module */\n  else {  /* no; initialize it */\n    lua_pop(L, 1);\n    modinit(L, modname);\n  }\n  lua_pushvalue(L, -1);\n  set_env(L);\n  dooptions(L, lastarg);\n  return 1;\n}\n\n\nstatic int ll_seeall (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  if (!lua_getmetatable(L, 1)) {\n    lua_createtable(L, 0, 1); /* create new metatable */\n    lua_pushvalue(L, -1);\n    lua_setmetatable(L, 1);\n  }\n  lua_pushglobaltable(L);\n  lua_setfield(L, -2, \"__index\");  /* mt.__index = _G */\n  return 0;\n}\n\n#endif\n/* }====================================================== */\n\n\n\nstatic const luaL_Reg pk_funcs[] = {\n  {\"loadlib\", ll_loadlib},\n  {\"searchpath\", ll_searchpath},\n#if defined(LUA_COMPAT_MODULE)\n  {\"seeall\", ll_seeall},\n#endif\n  /* placeholders */\n  {\"preload\", NULL},\n  {\"cpath\", NULL},\n  {\"path\", NULL},\n  {\"searchers\", NULL},\n  {\"loaded\", NULL},\n  {NULL, NULL}\n};\n\n\nstatic const luaL_Reg ll_funcs[] = {\n#if defined(LUA_COMPAT_MODULE)\n  {\"module\", ll_module},\n#endif\n  {\"require\", ll_require},\n  {NULL, NULL}\n};\n\n\nstatic void createsearcherstable (lua_State *L) {\n  static const lua_CFunction searchers[] =\n    {searcher_preload, searcher_Lua, searcher_C, searcher_Croot, NULL};\n  int i;\n  /* create 'searchers' table */\n  lua_createtable(L, sizeof(searchers)/sizeof(searchers[0]) - 1, 0);\n  /* fill it with predefined searchers */\n  for (i=0; searchers[i] != NULL; i++) {\n    lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */\n    lua_pushcclosure(L, searchers[i], 1);\n    lua_rawseti(L, -2, i+1);\n  }\n#if defined(LUA_COMPAT_LOADERS)\n  lua_pushvalue(L, -1);  /* make a copy of 'searchers' table */\n  lua_setfield(L, -3, \"loaders\");  /* put it in field 'loaders' */\n#endif\n  lua_setfield(L, -2, \"searchers\");  /* put it in field 'searchers' */\n}\n\n\n/*\n** create table CLIBS to keep track of loaded C libraries,\n** setting a finalizer to close all libraries when closing state.\n*/\nstatic void createclibstable (lua_State *L) {\n  lua_newtable(L);  /* create CLIBS table */\n  lua_createtable(L, 0, 1);  /* create metatable for CLIBS */\n  lua_pushcfunction(L, gctm);\n  lua_setfield(L, -2, \"__gc\");  /* set finalizer for CLIBS table */\n  lua_setmetatable(L, -2);\n  lua_rawsetp(L, LUA_REGISTRYINDEX, &CLIBS);  /* set CLIBS table in registry */\n}\n\n\nLUAMOD_API int luaopen_package (lua_State *L) {\n  createclibstable(L);\n  luaL_newlib(L, pk_funcs);  /* create 'package' table */\n  createsearcherstable(L);\n  /* set paths */\n  setpath(L, \"path\", LUA_PATH_VAR, LUA_PATH_DEFAULT);\n  setpath(L, \"cpath\", LUA_CPATH_VAR, LUA_CPATH_DEFAULT);\n  /* store config information */\n  lua_pushliteral(L, LUA_DIRSEP \"\\n\" LUA_PATH_SEP \"\\n\" LUA_PATH_MARK \"\\n\"\n                     LUA_EXEC_DIR \"\\n\" LUA_IGMARK \"\\n\");\n  lua_setfield(L, -2, \"config\");\n  /* set field 'loaded' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n  lua_setfield(L, -2, \"loaded\");\n  /* set field 'preload' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);\n  lua_setfield(L, -2, \"preload\");\n  lua_pushglobaltable(L);\n  lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */\n  luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */\n  lua_pop(L, 1);  /* pop global table */\n  return 1;  /* return 'package' table */\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/tools/lapack_checks/lapack-check.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2016\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dlfcn.h>\n#include \"cscutils/strutils.h\"\n\n#include \"lapack-3.0.h\"\n#include \"lapack-3.1.0.h\"\n#include \"lapack-3.1.1.h\"\n#include \"lapack-3.2.0.h\"\n#include \"lapack-3.2.1.h\"\n#include \"lapack-3.2.2.h\"\n#include \"lapack-3.3.0.h\"\n#include \"lapack-3.3.1.h\"\n#include \"lapack-3.4.0.h\"\n#include \"lapack-3.4.1.h\"\n#include \"lapack-3.4.2.h\"\n#include \"lapack-3.5.0.h\"\n#include \"lapack-3.6.0.h\"\n#include \"lapack-3.6.1.h\"\n#include \"lapack-3.7.0.h\"\n#include \"lapack-3.8.0.h\"\n\n#define LAPACK_3_0_0 0x01\n#define LAPACK_3_1_0 0x02\n#define LAPACK_3_1_1 0x03\n#define LAPACK_3_2_0 0x04\n#define LAPACK_3_2_1 0x05\n#define LAPACK_3_2_2 0x06\n#define LAPACK_3_3_0 0x07\n#define LAPACK_3_3_1 0x08\n#define LAPACK_3_4_0 0x09\n#define LAPACK_3_4_1 0x0A\n#define LAPACK_3_4_2 0x0B\n#define LAPACK_3_5_0 0x0C\n#define LAPACK_3_6_0 0x0D\n#define LAPACK_3_6_0_DPRC 0x0E\n#define LAPACK_3_6_1 0x0F\n#define LAPACK_3_6_1_DPRC 0x10\n#define LAPACK_3_7_0 0x11\n#define LAPACK_3_7_0_DPRC 0x12\n#define LAPACK_3_8_0 0x13\n#define LAPACK_3_8_0_DPRC 0x14\n\nchar * lapack_name(int ver) {\n    switch (ver) {\n        case LAPACK_3_0_0:\n            return \"3.0\";\n        case LAPACK_3_1_0:\n            return \"3.1.0\";\n        case LAPACK_3_1_1:\n            return \"3.1.1\";\n        case LAPACK_3_2_0:\n            return \"3.2.0\";\n        case LAPACK_3_2_1:\n            return \"3.2.1\";\n        case LAPACK_3_2_2:\n            return \"3.2.2\";\n        case LAPACK_3_3_0:\n            return \"3.3.0\";\n        case LAPACK_3_3_1:\n            return \"3.3.1\";\n        case LAPACK_3_4_0:\n            return \"3.4.0\";\n        case LAPACK_3_4_1:\n            return \"3.4.1\";\n        case LAPACK_3_4_2:\n            return \"3.4.2\";\n        case LAPACK_3_5_0:\n            return \"3.5.0\";\n        case LAPACK_3_6_0:\n            return \"3.6.0\";\n        case LAPACK_3_6_0_DPRC:\n            return \"3.6.0-DPRC\";\n        case LAPACK_3_6_1:\n            return \"3.6.1\";\n        case LAPACK_3_6_1_DPRC:\n            return \"3.6.1-DPRC\";\n        case LAPACK_3_7_0:\n            return \"3.7.0\";\n        case LAPACK_3_7_0_DPRC:\n            return \"3.7.0-DPRC\";\n        case LAPACK_3_8_0:\n            return \"3.8.0\";\n        case LAPACK_3_8_0_DPRC:\n            return \"3.8.0-DPRC\";\n\n        default:\n            return \"X.X.X\";\n    }\n    return \"X.X.X\";\n}\n\n\n\nchar *ignore_list [] = {\n    \"dlamc1\",\n    \"dlamc2\",\n    \"dlamc3\",\n    \"dlamc4\",\n    \"dlamc5\",\n    \"slamc1\",\n    \"slamc2\",\n    \"slamc3\",\n    \"slamc4\",\n    \"slamc5\",\n    \"dlasd9\",    /* Old relict from LAPACK < 3.0 but existing in 3.0  although not needed. */\n    \"slasd9\",\n    NULL\n};\n\nint is_in_list(char **haystack, char *needle)\n{\n    int i = 0;\n    while(haystack[i] != NULL) {\n        if (csc_strcasecmp(haystack[i], needle) == 0 ) return -1;\n        i++;\n    }\n    return 0;\n}\n\nvoid check_symbols(char **list, void *lib, int *found, int *missing, int *ignore)\n{\n    int i;\n    char name[128];\n    i = 0;\n    *found = 0;\n    *missing = 0;\n    *ignore = 0;\n\n\n    while ( list[i] != NULL )\n    {\n        void *sym1, *sym2;\n        snprintf(name, 128, \"%s_\", list[i]);\n        sym1 = dlsym ( lib, list[i] );\n        sym2 = dlsym ( lib, name );\n        if ( sym1 == NULL && sym2 == NULL) {\n            if ( ! is_in_list(ignore_list, list[i]) ) {\n                *missing = *missing +1;\n                printf(\"MISS : %s\\n\", list[i]);\n            } else {\n                *ignore = *ignore +1;\n                // printf(\"IGNORE: %s\\n\", list[i]);\n            }\n        } else {\n            *found = *found +1;\n            // printf(\"FOUND: %s at %lx\\n\", list[i], (long unsigned int) ((sym1==NULL)?sym2:sym1));\n        }\n        i++;\n    }\n}\n\nint main(int argc, char **argv)\n{\n    void *ptr;\n    int f = 0;\n    int m = 0;\n    int ign = 0;\n    char **symbolset;\n    int lapack_number;\n    int lapack_save = -1;\n\n\n    if ( argc != 2 )\n    {\n        printf(\"Usage: %s <sofile>\\n\", argv[0]);\n        return -1;\n    }\n\n    ptr = dlopen(argv[1], RTLD_LOCAL | RTLD_LAZY);\n    if ( ptr == NULL ) {\n        printf(\"Failed to open :%s\\n\", argv[1]);\n        return -1;\n    }\n    for (lapack_number = 1; lapack_number <= LAPACK_3_7_0_DPRC; lapack_number++) {\n        switch(lapack_number) {\n            case LAPACK_3_0_0:\n                symbolset = lapack_3_0;\n                break;\n            case LAPACK_3_1_0:\n                symbolset = lapack_3_1_0;\n                break;\n            case LAPACK_3_1_1:\n                symbolset = lapack_3_1_1;\n                break;\n            case LAPACK_3_2_0:\n                symbolset = lapack_3_2_0;\n                break;\n            case LAPACK_3_2_1:\n                symbolset = lapack_3_2_1;\n                break;\n            case LAPACK_3_2_2:\n                symbolset = lapack_3_2_2;\n                break;\n            case LAPACK_3_3_0:\n                symbolset = lapack_3_3_0;\n                break;\n            case LAPACK_3_3_1:\n                symbolset = lapack_3_3_1;\n                break;\n            case LAPACK_3_4_0:\n                symbolset = lapack_3_4_0;\n                break;\n            case LAPACK_3_4_1:\n                symbolset = lapack_3_4_1;\n                break;\n            case LAPACK_3_4_2:\n                symbolset = lapack_3_4_2;\n                break;\n            case LAPACK_3_5_0:\n                symbolset = lapack_3_5_0;\n                break;\n            case LAPACK_3_6_0_DPRC:\n                symbolset = lapack_3_6_0_full;\n                break;\n            case LAPACK_3_6_0:\n                symbolset = lapack_3_6_0;\n                break;\n            case LAPACK_3_6_1_DPRC:\n                symbolset = lapack_3_6_1_full;\n                break;\n            case LAPACK_3_6_1:\n                symbolset = lapack_3_6_1;\n                break;\n            case LAPACK_3_7_0_DPRC:\n                symbolset = lapack_3_7_0_full;\n                break;\n            case LAPACK_3_7_0:\n                symbolset = lapack_3_7_0;\n                break;\n            case LAPACK_3_8_0_DPRC:\n                symbolset = lapack_3_8_0_full;\n                break;\n            case LAPACK_3_8_0:\n                symbolset = lapack_3_8_0;\n                break;\n\n            default:\n                symbolset = NULL;\n\n        }\n\n        printf(\"Check for LAPACK %s\\n\", lapack_name(lapack_number));\n        check_symbols(symbolset, ptr, &f, &m, &ign);\n\n        if ( m == 0 ) {\n            lapack_save = lapack_number;\n        }\n\n        printf(\"%s - f = %d \\t m = %d\\n\", argv[1], f, m );\n\n    }\n\n    if ( lapack_save > 0 ) {\n        printf(\"%s is compatible to LAPACK %s\\n\", argv[1], lapack_name(lapack_save));\n    }\n\n    dlclose(ptr);\n    return 0;\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.9.0/DOCS/lapack.png",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.9.0/DOCS/lapacke.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.6.1/DOCS/lapack.png",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.6.1/DOCS/lapacke.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.7.0/DOCS/lapack.png",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.7.0/DOCS/lapacke.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.8.0/DOCS/lapack.png",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.8.0/DOCS/lapacke.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/libcscutils/contrib/lua/doc/logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/libcscutils/contrib/lua/doc/osi-certified-72x60.png"
    ],
    "total_files": 16005
}