{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.2-nxttfe2rxn7kioxkg2cdxrj7lmztj3cp/spack-src/configure.self": "#!/bin/bash\n#\n\nmkl_meta_set \"description\" \"name\"      \"librdkafka\"\nmkl_meta_set \"description\" \"oneline\"   \"The Apache Kafka C/C++ library\"\nmkl_meta_set \"description\" \"long\"      \"Full Apache Kafka protocol support, including producer and consumer\"\nmkl_meta_set \"description\" \"copyright\" \"Copyright (c) 2012-2019 Magnus Edenhill\"\n\n# Enable generation of pkg-config .pc file\nmkl_mkvar_set \"\" GEN_PKG_CONFIG y\n\n\nmkl_require cxx\nmkl_require lib\nmkl_require pic\nmkl_require atomics\nmkl_require good_cflags\nmkl_require socket\nmkl_require zlib\nmkl_require libzstd\nmkl_require libssl\nmkl_require libsasl2\n\n# Generate version variables from rdkafka.h hex version define\n# so we can use it as string version when generating a pkg-config file.\n\nverdef=$(grep '^#define  *RD_KAFKA_VERSION  *0x' src/rdkafka.h | sed 's/^#define  *RD_KAFKA_VERSION  *\\(0x[a-f0-9]*\\)\\.*$/\\1/')\nmkl_require parseversion hex2str \"%d.%d.%d\" \"$verdef\" RDKAFKA_VERSION_STR\n\n\nmkl_toggle_option \"Development\" ENABLE_DEVEL \"--enable-devel\" \"Enable development asserts, checks, etc\" \"n\"\nmkl_toggle_option \"Development\" ENABLE_VALGRIND \"--enable-valgrind\" \"Enable in-code valgrind suppressions\" \"n\"\n\nmkl_toggle_option \"Development\" ENABLE_REFCNT_DEBUG \"--enable-refcnt-debug\" \"Enable refcnt debugging\" \"n\"\n\nmkl_toggle_option \"Development\" ENABLE_SHAREDPTR_DEBUG \"--enable-sharedptr-debug\" \"Enable sharedptr debugging\" \"n\"\n\nmkl_toggle_option \"Feature\" ENABLE_LZ4_EXT \"--enable-lz4-ext\" \"Enable external LZ4 library support (builtin version 1.9.2)\" \"y\"\nmkl_toggle_option \"Feature\" ENABLE_LZ4_EXT \"--enable-lz4\" \"Deprecated: alias for --enable-lz4-ext\" \"y\"\n\n# librdkafka with TSAN won't work with glibc C11 threads on Ubuntu 19.04.\n# This option allows disabling libc-based C11 threads and instead\n# use the builtin tinycthread alternative.\nmkl_toggle_option \"Feature\" ENABLE_C11THREADS \"--enable-c11threads\" \"Enable detection of C11 threads support in libc\" \"y\"\n\nmkl_toggle_option \"Feature\" ENABLE_SYSLOG \"--enable-syslog\" \"Enable logging to syslog\" \"y\"\n\n\nfunction checks {\n\n    # -lrt is needed on linux for clock_gettime: link it if it exists.\n    mkl_lib_check \"librt\" \"\" cont CC \"-lrt\"\n\n    # pthreads required (even if C11 threads available) for rwlocks.\n    mkl_lib_check \"libpthread\" \"\" fail CC \"-lpthread\" \\\n                  \"#include <pthread.h>\"\n\n    if [[ $ENABLE_C11THREADS == \"y\" ]]; then\n        # Use internal tinycthread if C11 threads not available.\n        # Requires -lpthread on glibc c11 threads, thus the use of $LIBS.\n        mkl_lib_check \"c11threads\" WITH_C11THREADS disable CC \"$LIBS\" \\\n                      \"\n#include <threads.h>\n\n\nstatic int start_func (void *arg) {\n   int iarg = *(int *)arg;\n   return iarg;\n}\n\nvoid foo (void) {\n    thrd_t thr;\n    int arg = 1;\n    if (thrd_create(&thr, start_func, (void *)&arg) != thrd_success) {\n      ;\n    }\n}\n\"\n    fi\n\n    # Check if dlopen() is available\n    mkl_lib_check \"libdl\" \"WITH_LIBDL\" disable CC \"-ldl\" \\\n\"\n#include <stdlib.h>\n#include <dlfcn.h>\nvoid foo (void) {\n   void *h = dlopen(\\\"__bad_lib\\\", 0);\n   void *p = dlsym(h, \\\"sym\\\");\n   if (p)\n     p = NULL;\n   dlclose(h);\n}\"\n\n    if [[ $WITH_LIBDL == \"y\" ]]; then\n        mkl_allvar_set WITH_PLUGINS WITH_PLUGINS y\n    fi\n\n    # optional libs\n    mkl_check \"zlib\" disable\n    mkl_check \"libssl\" disable\n    mkl_check \"libsasl2\" disable\n    mkl_check \"libzstd\" disable\n\n    if mkl_lib_check \"libm\" \"\" disable CC \"-lm\" \\\n                     \"#include <math.h>\"; then\n        mkl_allvar_set WITH_HDRHISTOGRAM WITH_HDRHISTOGRAM y\n    fi\n\n    # Use builtin lz4 if linking statically or if --disable-lz4-ext is used.\n    if [[ $MKL_SOURCE_DEPS_ONLY != y ]] && [[ $WITH_STATIC_LINKING != y ]] && [[ $ENABLE_LZ4_EXT == y ]]; then\n        mkl_meta_set \"liblz4\" \"static\" \"liblz4.a\"\n        mkl_lib_check \"liblz4\" \"WITH_LZ4_EXT\" disable CC \"-llz4\" \\\n                      \"#include <lz4frame.h>\"\n    fi\n\n    if [[ $ENABLE_SYSLOG == y ]]; then\n        mkl_compile_check \"syslog\" \"WITH_SYSLOG\" disable CC \"\" \\\n                          '\n#include <syslog.h>\nvoid foo (void) {\n    syslog(LOG_INFO, \"test\");\n}'\n    fi\n\n    # rapidjson (>=1.1.0) is used in tests to verify statistics data, not used\n    # by librdkafka itself.\n    mkl_compile_check \"rapidjson\" \"WITH_RAPIDJSON\" disable CXX \"\" \\\n                      \"#include <rapidjson/schema.h>\"\n\n    # Snappy support is built-in\n    mkl_allvar_set WITH_SNAPPY WITH_SNAPPY y\n\n    # Enable sockem (tests)\n    mkl_allvar_set WITH_SOCKEM WITH_SOCKEM y\n\n    if [[ \"$ENABLE_SASL\" == \"y\" ]]; then\n        mkl_meta_set \"libsasl2\" \"deb\" \"libsasl2-dev\"\n        mkl_meta_set \"libsasl2\" \"rpm\" \"cyrus-sasl\"\n        if ! mkl_lib_check \"libsasl2\" \"WITH_SASL_CYRUS\" disable CC \"-lsasl2\" \"#include <sasl/sasl.h>\" ; then\n            mkl_lib_check \"libsasl\" \"WITH_SASL_CYRUS\" disable CC \"-lsasl\" \\\n                          \"#include <sasl/sasl.h>\"\n        fi\n    fi\n\n    if [[ \"$WITH_SSL\" == \"y\" ]]; then\n        # SASL SCRAM requires base64 encoding from OpenSSL\n        mkl_allvar_set WITH_SASL_SCRAM WITH_SASL_SCRAM y\n        # SASL OAUTHBEARER's default unsecured JWS implementation\n        # requires base64 encoding from OpenSSL\n        mkl_allvar_set WITH_SASL_OAUTHBEARER WITH_SASL_OAUTHBEARER y\n    fi\n\n    # CRC32C: check for crc32 instruction support.\n    #         This is also checked during runtime using cpuid.\n    mkl_compile_check crc32chw WITH_CRC32C_HW disable CC \"\" \\\n                      \"\n#include <inttypes.h>\n#include <stdio.h>\n#define LONGx1 \\\"8192\\\"\n#define LONGx2 \\\"16384\\\"\nvoid foo (void) {\n   const char *n = \\\"abcdefghijklmnopqrstuvwxyz0123456789\\\";\n   uint64_t c0 = 0, c1 = 1, c2 = 2;\n   uint64_t s;\n   uint32_t eax = 1, ecx;\n   __asm__(\\\"cpuid\\\"\n           : \\\"=c\\\"(ecx)\n           : \\\"a\\\"(eax)\n           : \\\"%ebx\\\", \\\"%edx\\\");\n   __asm__(\\\"crc32b\\t\\\" \\\"(%1), %0\\\"\n           : \\\"=r\\\"(c0)\n           : \\\"r\\\"(n), \\\"0\\\"(c0));\n   __asm__(\\\"crc32q\\t\\\" \\\"(%3), %0\\n\\t\\\"\n           \\\"crc32q\\t\\\" LONGx1 \\\"(%3), %1\\n\\t\\\"\n           \\\"crc32q\\t\\\" LONGx2 \\\"(%3), %2\\\"\n           : \\\"=r\\\"(c0), \\\"=r\\\"(c1), \\\"=r\\\"(c2)\n           : \\\"r\\\"(n), \\\"0\\\"(c0), \\\"1\\\"(c1), \\\"2\\\"(c2));\n  s = c0 + c1 + c2;\n  printf(\\\"avoiding unused code removal by printing %d, %d, %d\\n\\\", (int)s, (int)eax, (int)ecx);\n}\n\"\n\n\n    # Check for libc regex\n    mkl_compile_check \"regex\" \"HAVE_REGEX\" disable CC \"\" \\\n\"\n#include <stddef.h>\n#include <regex.h>\nvoid foo (void) {\n   regcomp(NULL, NULL, 0);\n   regexec(NULL, NULL, 0, NULL, 0);\n   regerror(0, NULL, NULL, 0);\n   regfree(NULL);\n}\"\n\n\n    # Older g++ (<=4.1?) gives invalid warnings for the C++ code.\n    mkl_mkvar_append CXXFLAGS CXXFLAGS \"-Wno-non-virtual-dtor\"\n\n    # Required on SunOS\n    if [[ $MKL_DISTRO == \"sunos\" ]]; then\n\tmkl_mkvar_append CPPFLAGS CPPFLAGS \"-D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D__EXTENSIONS__\"\n\t# Source defines _POSIX_C_SOURCE to 200809L for Solaris, and this is\n\t# incompatible on that platform with compilers < c99.\n\tmkl_mkvar_append CFLAGS CFLAGS \"-std=c99\"\n    fi\n\n    # Check if strndup() is available (isn't on Solaris 10)\n    mkl_compile_check \"strndup\" \"HAVE_STRNDUP\" disable CC \"\" \\\n\"#include <string.h>\nint foo (void) {\n   return strndup(\\\"hi\\\", 2) ? 0 : 1;\n}\"\n\n    # Check if strlcpy() is available\n    mkl_compile_check \"strlcpy\" \"HAVE_STRLCPY\" disable CC \"\" \\\n\"\n#define _DARWIN_C_SOURCE\n#include <string.h>\nint foo (void) {\n    char dest[4];\n   return strlcpy(dest, \\\"something\\\", sizeof(dest));\n}\"\n\n    # Check if strerror_r() is available.\n    # The check for GNU vs XSI is done in rdposix.h since\n    # we can't rely on all defines to be set here (_GNU_SOURCE).\n    mkl_compile_check \"strerror_r\" \"HAVE_STRERROR_R\" disable CC \"\" \\\n\"#include <string.h>\nconst char *foo (void) {\n   static char buf[64];\n   strerror_r(1, buf, sizeof(buf));\n   return buf;\n}\"\n\n\n    # See if GNU's pthread_setname_np() is available, and in what form.\n    mkl_compile_check \"pthread_setname_gnu\" \"HAVE_PTHREAD_SETNAME_GNU\" disable CC \"-D_GNU_SOURCE -lpthread\" \\\n'\n#include <pthread.h>\n\nvoid foo (void) {\n  pthread_setname_np(pthread_self(), \"abc\");\n}\n' || \\\n    mkl_compile_check \"pthread_setname_darwin\" \"HAVE_PTHREAD_SETNAME_DARWIN\" disable CC \"-D_DARWIN_C_SOURCE -lpthread\" \\\n'\n#include <pthread.h>\n\nvoid foo (void) {\n  pthread_setname_np(\"abc\");\n}\n'\n\n    # Figure out what tool to use for dumping public symbols.\n    # We rely on configure.cc setting up $NM if it exists.\n    if mkl_env_check \"nm\" \"\" cont \"NM\" ; then\n\t# nm by future mk var\n\tif [[ $MKL_DISTRO == \"osx\" || $MKL_DISTRO == \"aix\" ]]; then\n\t    mkl_mkvar_set SYMDUMPER SYMDUMPER '$(NM) -g'\n\telse\n\t    mkl_mkvar_set SYMDUMPER SYMDUMPER '$(NM) -D'\n\tfi\n    else\n\t# Fake symdumper\n\tmkl_mkvar_set SYMDUMPER SYMDUMPER 'echo'\n    fi\n\n    # The linker-script generator (lds-gen.py) requires python3\n    if [[ $WITH_LDS == y ]]; then\n        if ! mkl_command_check python3 \"HAVE_PYTHON\" \"disable\" \"python3 -V\"; then\n            mkl_err \"disabling linker-script since python3 is not available\"\n            mkl_mkvar_set WITH_LDS WITH_LDS \"n\"\n        fi\n    fi\n\n    if [[ \"$ENABLE_VALGRIND\" == \"y\" ]]; then\n\tmkl_compile_check valgrind WITH_VALGRIND disable CC \"\" \\\n\t\t\t  \"#include <valgrind/memcheck.h>\"\n    fi\n\n    # getrusage() is used by the test framework\n    mkl_compile_check \"getrusage\" \"HAVE_GETRUSAGE\" disable CC \"\" \\\n'\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n\n\nvoid foo (void) {\n  struct rusage ru;\n  if (getrusage(RUSAGE_SELF, &ru) == -1)\n    return;\n  printf(\"ut %ld, st %ld, maxrss %ld, nvcsw %ld\\n\",\n         (long int)ru.ru_utime.tv_usec,\n         (long int)ru.ru_stime.tv_usec,\n         (long int)ru.ru_maxrss,\n         (long int)ru.ru_nvcsw);\n}'\n\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.2-nxttfe2rxn7kioxkg2cdxrj7lmztj3cp/spack-src/src/rddl.c": "/*\n * librdkafka - The Apache Kafka C/C++ library\n *\n * Copyright (c) 2017 Magnus Edenhill\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"rd.h\"\n#include \"rddl.h\"\n\n#if WITH_LIBDL\n#include <dlfcn.h>\n\n#elif defined( _MSC_VER)\n\n#else\n#error \"Dynamic library loading not supported on this platform\"\n#endif\n\n\n\n/**\n * @brief Latest thread-local dl error, normalized to suit our logging.\n * @returns a newly allocated string that must be freed\n */\nstatic char *rd_dl_error (void) {\n#if WITH_LIBDL\n        char *errstr;\n        char *s;\n        errstr = dlerror();\n        if (!errstr)\n                return rd_strdup(\"No error returned from dlerror()\");\n\n        errstr = rd_strdup(errstr);\n        /* Change newlines to separators. */\n        while ((s = strchr(errstr, '\\n')))\n                *s = '.';\n\n        return errstr;\n\n#elif defined(_MSC_VER)\n        char buf[1024];\n        rd_strerror_w32(GetLastError(), buf, sizeof(buf));\n        return rd_strdup(buf);\n#endif\n}\n\n/**\n * @brief Attempt to load library \\p path.\n * @returns the library handle (platform dependent, thus opaque) on success,\n *          else NULL.\n */\nstatic rd_dl_hnd_t *\nrd_dl_open0 (const char *path, char *errstr, size_t errstr_size) {\n        void *handle;\n        const char *loadfunc;\n#if WITH_LIBDL\n        loadfunc = \"dlopen()\";\n        handle = dlopen(path, RTLD_NOW | RTLD_LOCAL);\n#elif defined(_MSC_VER)\n        loadfunc = \"LoadLibrary()\";\n        handle = (void *)LoadLibraryA(path);\n#endif\n        if (!handle) {\n                char *dlerrstr = rd_dl_error();\n                rd_snprintf(errstr, errstr_size, \"%s failed: %s\",\n                            loadfunc, dlerrstr);\n                rd_free(dlerrstr);\n        }\n        return (rd_dl_hnd_t *)handle;\n}\n\n\n/**\n * @brief Attempt to load library \\p path, possibly with a filename extension\n *        which will be automatically resolved depending on platform.\n * @returns the library handle (platform dependent, thus opaque) on success,\n *          else NULL.\n */\nrd_dl_hnd_t *rd_dl_open (const char *path, char *errstr, size_t errstr_size) {\n        rd_dl_hnd_t *handle;\n        char *extpath;\n        size_t pathlen;\n        const char *td, *fname;\n        const char *solib_ext = SOLIB_EXT;\n\n        /* Try original path first. */\n        handle = rd_dl_open0(path, errstr, errstr_size);\n        if (handle)\n                return handle;\n\n        /* Original path not found, see if we can append the solib_ext\n         * filename extension. */\n\n        /* Get filename and filename extension.\n         * We can't rely on basename(3) since it is not portable */\n        fname = strrchr(path, '/');\n#ifdef _MSC_VER\n        td = strrchr(path, '\\\\');\n        if (td > fname)\n                fname = td;\n#endif\n        if (!fname)\n                fname = path;\n\n        td = strrchr(fname, '.');\n\n        /* If there is a filename extension ('.' within the last characters)\n         * then bail out, we will not append an extension in this case. */\n        if (td && td >= fname + strlen(fname) - strlen(SOLIB_EXT))\n                return NULL;\n\n        /* Append platform-specific library extension. */\n        pathlen = strlen(path);\n        extpath = rd_alloca(pathlen + strlen(solib_ext) + 1);\n        memcpy(extpath, path, pathlen);\n        memcpy(extpath+pathlen, solib_ext, strlen(solib_ext) + 1);\n\n        /* Try again with extension */\n        return rd_dl_open0(extpath, errstr, errstr_size);\n}\n\n\n/**\n * @brief Close handle previously returned by rd_dl_open()\n * @remark errors are ignored (what can we do anyway?)\n */\nvoid rd_dl_close (rd_dl_hnd_t *handle) {\n#if WITH_LIBDL\n        dlclose((void *)handle);\n#elif defined(_MSC_VER)\n        FreeLibrary((HMODULE)handle);\n#endif\n}\n\n/**\n * @brief look up address of \\p symbol in library handle \\p handle\n * @returns the function pointer on success or NULL on error.\n */\nvoid *\nrd_dl_sym (rd_dl_hnd_t *handle, const char *symbol,\n           char *errstr, size_t errstr_size) {\n        void *func;\n#if WITH_LIBDL\n        func = dlsym((void *)handle, symbol);\n#elif defined(_MSC_VER)\n        func = GetProcAddress((HMODULE)handle, symbol);\n#endif\n        if (!func) {\n                char *dlerrstr = rd_dl_error();\n                rd_snprintf(errstr, errstr_size,\n                            \"Failed to load symbol \\\"%s\\\": %s\",\n                            symbol, dlerrstr);\n                rd_free(dlerrstr);\n        }\n        return func;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.2-nxttfe2rxn7kioxkg2cdxrj7lmztj3cp/spack-src/tests/sockem.c": "/*\n * sockem - socket-level network emulation\n *\n * Copyright (c) 2016, Magnus Edenhill, Andreas Smas\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#define _GNU_SOURCE /* for strdupa() and RTLD_NEXT */\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <poll.h>\n#include <assert.h>\n#include <netinet/in.h>\n#include <dlfcn.h>\n\n#include \"sockem.h\"\n\n#include <sys/queue.h>\n\n#ifdef __APPLE__\n#include <sys/time.h> /* for gettimeofday() */\n#endif\n\n#ifdef _MSC_VER\n#define socket_errno() WSAGetLastError()\n#else\n#define socket_errno() errno\n#define SOCKET_ERROR -1\n#endif\n\n#ifndef strdupa\n#define strdupa(s)                                                      \\\n        ({                                                              \\\n                const char *_s = (s);                                   \\\n                size_t _len = strlen(_s)+1;                             \\\n                char *_d = (char *)alloca(_len);                        \\\n                (char *)memcpy(_d, _s, _len);                           \\\n        })\n#endif\n\n#include <pthread.h>\ntypedef pthread_mutex_t mtx_t;\n#define mtx_init(M) pthread_mutex_init(M, NULL)\n#define mtx_destroy(M) pthread_mutex_destroy(M)\n#define mtx_lock(M) pthread_mutex_lock(M)\n#define mtx_unlock(M) pthread_mutex_unlock(M)\n\ntypedef pthread_t thrd_t;\n#define thrd_create(THRD,START_ROUTINE,ARG) \\\n  pthread_create(THRD, NULL, START_ROUTINE, ARG)\n#define thrd_join0(THRD)                  \\\n        pthread_join(THRD, NULL)\n\n\nstatic mtx_t sockem_lock;\nstatic LIST_HEAD(, sockem_s) sockems;\n\nstatic pthread_once_t sockem_once = PTHREAD_ONCE_INIT;\nstatic char *sockem_conf_str = \"\";\n\ntypedef int64_t sockem_ts_t;\n\n\n#ifdef LIBSOCKEM_PRELOAD\nstatic int (*sockem_orig_connect) (int, const struct sockaddr *, socklen_t);\nstatic int (*sockem_orig_close) (int);\n\n#define sockem_close0(S)        (sockem_orig_close(S))\n#define sockem_connect0(S,A,AL) (sockem_orig_connect(S,A,AL))\n#else\n#define sockem_close0(S)        close(S)\n#define sockem_connect0(S,A,AL) connect(S,A,AL)\n#endif\n\n\nstruct sockem_conf {\n        /* FIXME: these needs to be implemented */\n        int tx_thruput;  /* app->peer bytes/second */\n        int rx_thruput;  /* peer->app bytes/second */\n        int delay;       /* latency in ms */\n        int jitter;      /* latency variation in ms */\n        int debug;       /* enable sockem printf debugging */\n        size_t recv_bufsz;    /* recv chunk/buffer size */\n        int direct;      /* direct forward, no delay or rate-limiting */\n};\n\n\ntypedef struct sockem_buf_s {\n        TAILQ_ENTRY(sockem_buf_s) sb_link;\n        size_t  sb_size;\n        size_t  sb_of;\n        char   *sb_data;\n        int64_t sb_at;  /* Transmit at this absolute time. */\n} sockem_buf_t;\n\n\nstruct sockem_s {\n        LIST_ENTRY(sockem_s) link;\n\n        enum {\n                /* Forwarder thread run states */\n                SOCKEM_INIT,\n                SOCKEM_START,\n                SOCKEM_RUN,\n                SOCKEM_TERM\n        } run;\n\n        int as;        /* application's socket. */\n        int ls;        /* internal application listen socket */\n        int ps;        /* internal peer socket connecting sockem to the peer.*/\n\n        void *recv_buf;     /* Receive buffer */\n        size_t recv_bufsz;  /* .. size */\n\n        int linked;    /* On sockems list */\n\n        thrd_t thrd;   /* Forwarder thread */\n\n        mtx_t  lock;\n\n        struct sockem_conf conf;  /* application-set config.\n                                   * protected by .lock */\n\n        struct sockem_conf use;   /* last copy of .conf\n                                   * local to skm thread */\n\n        TAILQ_HEAD(, sockem_buf_s) bufs; /* Buffers in queue waiting for\n                                          * transmission (delayed) */\n\n        size_t bufs_size; /* Total number of bytes currently enqueued\n                           * for transmission */\n        size_t bufs_size_max; /* Soft max threshold for bufs_size,\n                               * when this value is exceeded the app fd\n                               * is removed from the poll set until\n                               * bufs_size falls below the threshold again. */\n        int poll_fd_cnt;\n        int64_t ts_last_fwd;  /* For rate-limiter: timestamp of last forward */\n};\n\n\nstatic int sockem_vset (sockem_t *skm, va_list ap);\n\n\n/**\n * A microsecond monotonic clock\n */\nstatic __attribute__((unused)) __inline int64_t sockem_clock (void) {\n#ifdef __APPLE__\n        /* No monotonic clock on Darwin */\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        return ((int64_t)tv.tv_sec * 1000000LLU) + (int64_t)tv.tv_usec;\n#elif _MSC_VER\n        return (int64_t)GetTickCount64() * 1000LLU;\n#else\n        struct timespec ts;\n        clock_gettime(CLOCK_MONOTONIC, &ts);\n        return ((int64_t)ts.tv_sec * 1000000LLU) +\n                ((int64_t)ts.tv_nsec / 1000LLU);\n#endif\n}\n\n/**\n * @brief Initialize libsockem once.\n */\nstatic void sockem_init (void) {\n        mtx_init(&sockem_lock);\n        sockem_conf_str = getenv(\"SOCKEM_CONF\");\n        if (!sockem_conf_str)\n                sockem_conf_str = \"\";\n        if (strstr(sockem_conf_str, \"debug\"))\n                fprintf(stderr, \"%% libsockem pre-loaded (%s)\\n\",\n                        sockem_conf_str);\n#ifdef LIBSOCKEM_PRELOAD\n        sockem_orig_connect = dlsym(RTLD_NEXT, \"connect\");\n        sockem_orig_close = dlsym(RTLD_NEXT, \"close\");\n#endif\n}\n\n\n/**\n * @returns the maximum waittime in ms for poll(), at most 1000 ms.\n * @remark lock must be held\n */\nstatic int sockem_calc_waittime (sockem_t *skm, int64_t now) {\n        const sockem_buf_t *sb;\n        int64_t r;\n\n        if (!(sb = TAILQ_FIRST(&skm->bufs)))\n                return 1000;\n        else if (now >= sb->sb_at || skm->use.direct)\n                return 0;\n        else if ((r = (sb->sb_at - now)) < 1000000) {\n                if (r < 1000)\n                        return 1; /* Ceil to 1 to avoid busy-loop during\n                                   * last millisecond. */\n                else\n                        return (int)(r / 1000);\n        } else\n                return 1000;\n}\n\n\n/**\n * @brief Unlink and destroy a buffer\n */\nstatic void sockem_buf_destroy (sockem_t *skm, sockem_buf_t *sb) {\n        skm->bufs_size -= sb->sb_size - sb->sb_of;\n        TAILQ_REMOVE(&skm->bufs, sb, sb_link);\n        free(sb);\n}\n\n/**\n * @brief Add delayed buffer to transmit.\n */\nstatic sockem_buf_t *sockem_buf_add (sockem_t *skm,\n                                     size_t size, const void *data) {\n        sockem_buf_t *sb;\n\n        skm->bufs_size += size;\n        if (skm->bufs_size > skm->bufs_size_max) {\n                /* No more buffer space, halt recv fd until\n                 * queued buffers drop below threshold. */\n                skm->poll_fd_cnt = 1;\n        }\n\n        sb = malloc(sizeof(*sb) + size);\n\n        sb->sb_of   = 0;\n        sb->sb_size = size;\n        sb->sb_data = (char *)(sb+1);\n        sb->sb_at   = sockem_clock() +\n                ((skm->use.delay +\n                  (skm->use.jitter / 2)/*FIXME*/) * 1000);\n        memcpy(sb->sb_data, data, size);\n\n        TAILQ_INSERT_TAIL(&skm->bufs, sb, sb_link);\n\n        return sb;\n}\n\n\n/**\n * @brief Forward any delayed buffers that have passed their deadline\n * @remark lock must be held but will be released momentarily while\n *         performing send syscall.\n */\nstatic int sockem_fwd_bufs (sockem_t *skm, int ofd) {\n        sockem_buf_t *sb;\n        int64_t now = sockem_clock();\n        size_t to_write;\n        int64_t elapsed;\n\n\n        if (skm->use.direct)\n                to_write = 1024*1024*100;\n        else if ((elapsed = now - skm->ts_last_fwd)) {\n                /* Calculate how many bytes to send to adhere to rate-limit */\n                to_write = (size_t)((double)skm->use.tx_thruput *\n                                    ((double)elapsed / 1000000.0));\n        } else\n                return 0;\n\n        while (to_write > 0 &&\n               (sb = TAILQ_FIRST(&skm->bufs)) &&\n               (skm->use.direct || sb->sb_at <= now)) {\n                ssize_t r;\n                size_t remain = sb->sb_size - sb->sb_of;\n                size_t wr = to_write < remain ? to_write : remain;\n\n                if (wr == 0)\n                        break;\n\n                mtx_unlock(&skm->lock);\n\n                r = send(ofd, sb->sb_data+sb->sb_of, wr, 0);\n\n                mtx_lock(&skm->lock);\n\n                if (r == -1) {\n                        if (errno == ENOBUFS || errno == EAGAIN ||\n                            errno == EWOULDBLOCK)\n                                return 0;\n                        return -1;\n                }\n\n                skm->ts_last_fwd = now;\n\n                sb->sb_of += r;\n                to_write  -= r;\n\n                if (sb->sb_of < sb->sb_size)\n                        break;\n\n                sockem_buf_destroy(skm, sb);\n\n                now = sockem_clock();\n        }\n\n        /* Re-enable app fd poll if queued buffers are below threshold */\n        if (skm->bufs_size < skm->bufs_size_max)\n                skm->poll_fd_cnt = 2;\n\n        return 0;\n}\n\n\n/**\n * @brief read from \\p ifd, write to \\p ofd in a blocking fashion.\n *\n * @returns the number of bytes forwarded, or -1 on error.\n */\nstatic int sockem_recv_fwd (sockem_t *skm, int ifd, int ofd, int direct) {\n        ssize_t r, wr;\n\n        r = recv(ifd, skm->recv_buf, skm->recv_bufsz, MSG_DONTWAIT);\n        if (r == -1) {\n                int serr = socket_errno();\n                if (serr == EAGAIN || serr == EWOULDBLOCK)\n                        return 0;\n                return -1;\n\n        } else if (r == 0) {\n                /* Socket closed */\n                return -1;\n        }\n\n        if (direct) {\n                /* No delay, rate limit, or buffered data: send right away */\n                wr = send(ofd, skm->recv_buf, r, 0);\n                if (wr < r)\n                        return -1;\n\n                return wr;\n        } else {\n                sockem_buf_add(skm, r, skm->recv_buf);\n                return r;\n        }\n}\n\n\n/**\n * @brief Close all sockets and unsets ->run.\n * @remark Preserves caller's errno.\n * @remark lock must be held.\n */\nstatic void sockem_close_all (sockem_t *skm) {\n        int serr = socket_errno();\n\n        if (skm->ls != -1) {\n                sockem_close0(skm->ls);\n                skm->ls = -1;\n        }\n\n        if (skm->ps != -1) {\n                sockem_close0(skm->ps);\n                skm->ps = -1;\n        }\n\n        skm->run = SOCKEM_TERM;\n\n        errno = serr;\n}\n\n\n/**\n * @brief Copy desired (app) config to internally use(d) configuration.\n * @remark lock must be held\n */\nstatic __inline void sockem_conf_use (sockem_t *skm) {\n        skm->use = skm->conf;\n        /* Figure out if direct forward is to be used */\n        skm->use.direct = !(skm->use.delay || skm->use.jitter ||\n                            (skm->use.tx_thruput < (1 << 30)));\n}\n\n/**\n * @brief sockem internal per-socket forwarder thread\n */\nstatic void *sockem_run (void *arg) {\n        sockem_t *skm = arg;\n        int cs = -1;\n        int ls;\n        struct pollfd pfd[2];\n\n        mtx_lock(&skm->lock);\n        if (skm->run == SOCKEM_START)\n                skm->run = SOCKEM_RUN;\n        sockem_conf_use(skm);\n        ls = skm->ls;\n        mtx_unlock(&skm->lock);\n\n        skm->recv_bufsz = skm->use.recv_bufsz;\n        skm->recv_buf = malloc(skm->recv_bufsz);\n\n        /* Accept connection from sockfd in sockem_connect() */\n        cs = accept(ls, NULL, 0);\n        if (cs == -1) {\n                mtx_lock(&skm->lock);\n                if (skm->run == SOCKEM_TERM) {\n                        /* App socket was closed. */\n                        goto done;\n                }\n                fprintf(stderr, \"%% sockem: accept(%d) failed: %s\\n\",\n                        ls, strerror(socket_errno()));\n                assert(cs != -1);\n        }\n\n        /* Set up poll (blocking IO) */\n        memset(pfd, 0, sizeof(pfd));\n        pfd[1].fd = cs;\n        pfd[1].events = POLLIN;\n\n        mtx_lock(&skm->lock);\n        pfd[0].fd = skm->ps;\n        mtx_unlock(&skm->lock);\n        pfd[0].events = POLLIN;\n\n        skm->poll_fd_cnt = 2;\n\n        mtx_lock(&skm->lock);\n        while (skm->run == SOCKEM_RUN) {\n                int r;\n                int i;\n                int waittime = sockem_calc_waittime(skm, sockem_clock());\n\n                mtx_unlock(&skm->lock);\n                r = poll(pfd, skm->poll_fd_cnt, waittime);\n                if (r == -1)\n                        break;\n\n                /* Send/forward delayed buffers */\n                mtx_lock(&skm->lock);\n                sockem_conf_use(skm);\n\n                if (sockem_fwd_bufs(skm, skm->ps) == -1) {\n                        mtx_unlock(&skm->lock);\n                        skm->run = SOCKEM_TERM;\n                        break;\n                }\n                mtx_unlock(&skm->lock);\n\n                for (i = 0 ; r > 0 && i < 2 ; i++) {\n                        if (pfd[i].revents & (POLLHUP|POLLERR)) {\n                                skm->run = SOCKEM_TERM;\n\n                        } else if (pfd[i].revents & POLLIN) {\n                                if (sockem_recv_fwd(\n                                            skm,\n                                            pfd[i].fd,\n                                            pfd[i^1].fd,\n                                            /* direct mode for app socket\n                                             * without delay, and always for\n                                             * peer socket (receive channel) */\n                                            i == 0 ||\n                                            (skm->use.direct &&\n                                             skm->bufs_size == 0)) == -1) {\n                                        skm->run = SOCKEM_TERM;\n                                        break;\n                                }\n                        }\n                }\n\n                mtx_lock(&skm->lock);\n        }\n done:\n        if (cs != -1)\n                sockem_close0(cs);\n        sockem_close_all(skm);\n\n        mtx_unlock(&skm->lock);\n        free(skm->recv_buf);\n\n\n        return NULL;\n}\n\n\n\n/**\n * @brief Connect socket \\p s to \\p addr\n */\nstatic int sockem_do_connect (int s, const struct sockaddr *addr,\n                              socklen_t addrlen) {\n        int r;\n\n        r = sockem_connect0(s, addr, addrlen);\n        if (r == SOCKET_ERROR) {\n                int serr = socket_errno();\n                if (serr != EINPROGRESS\n#ifdef _MSC_VER\n                    && serr != WSAEWOULDBLOCK\n#endif\n                        ) {\n#ifndef _MSC_VER\n                        errno = serr;\n#endif\n                        return -1;\n                }\n        }\n\n        return 0;\n}\n\n\nsockem_t *sockem_connect (int sockfd, const struct sockaddr *addr,\n                          socklen_t addrlen, ...) {\n        sockem_t *skm;\n        int ls, ps;\n        struct sockaddr_in6 sin6 = { .sin6_family = addr->sa_family };\n        socklen_t addrlen2 = addrlen;\n        va_list ap;\n\n        pthread_once(&sockem_once, sockem_init);\n\n        /* Create internal app listener socket */\n        ls = socket(addr->sa_family, SOCK_STREAM, IPPROTO_TCP);\n        if (ls == -1)\n                return NULL;\n\n        if (bind(ls, (struct sockaddr *)&sin6, addrlen) == -1) {\n                sockem_close0(ls);\n                return NULL;\n        }\n\n        /* Get bound address */\n        if (getsockname(ls, (struct sockaddr *)&sin6, &addrlen2) == -1) {\n                sockem_close0(ls);\n                return NULL;\n        }\n\n        if (listen(ls, 1) == -1) {\n                sockem_close0(ls);\n                return NULL;\n        }\n\n        /* Create internal peer socket */\n        ps = socket(addr->sa_family, SOCK_STREAM, IPPROTO_TCP);\n        if (ps == -1) {\n                sockem_close0(ls);\n                return NULL;\n        }\n\n        /* Connect to peer */\n        if (sockem_do_connect(ps, addr, addrlen) == -1) {\n                sockem_close0(ls);\n                sockem_close0(ps);\n                return NULL;\n        }\n\n        /* Create sockem handle */\n        skm = calloc(1, sizeof(*skm));\n        skm->as = sockfd;\n        skm->ls = ls;\n        skm->ps = ps;\n        skm->bufs_size_max = 16 * 1024 * 1024; /* 16kb of queue buffer */\n        TAILQ_INIT(&skm->bufs);\n        mtx_init(&skm->lock);\n\n        /* Default config */\n        skm->conf.rx_thruput = 1 << 30;\n        skm->conf.tx_thruput = 1 << 30;\n        skm->conf.delay = 0;\n        skm->conf.jitter = 0;\n        skm->conf.recv_bufsz = 1024*1024;\n        skm->conf.direct = 1;\n\n        /* Apply passed configuration */\n        va_start(ap, addrlen);\n        if (sockem_vset(skm, ap) == -1) {\n                va_end(ap);\n                sockem_close(skm);\n                return NULL;\n        }\n        va_end(ap);\n\n        mtx_lock(&skm->lock);\n        skm->run = SOCKEM_START;\n\n        /* Create pipe thread */\n        if (thrd_create(&skm->thrd, sockem_run, skm) != 0) {\n                mtx_unlock(&skm->lock);\n                sockem_close(skm);\n                return NULL;\n        }\n        mtx_unlock(&skm->lock);\n\n        /* Connect application socket to listen socket */\n        if (sockem_do_connect(sockfd,\n                              (struct sockaddr *)&sin6, addrlen2) == -1) {\n                sockem_close(skm);\n                return NULL;\n        }\n\n        mtx_lock(&sockem_lock);\n        LIST_INSERT_HEAD(&sockems, skm, link);\n        mtx_lock(&skm->lock);\n        skm->linked = 1;\n        mtx_unlock(&skm->lock);\n        mtx_unlock(&sockem_lock);\n\n        return skm;\n}\n\n\n/**\n * @brief Purge/drop all queued buffers\n */\nstatic void sockem_bufs_purge (sockem_t *skm) {\n        sockem_buf_t *sb;\n\n        while ((sb = TAILQ_FIRST(&skm->bufs)))\n                sockem_buf_destroy(skm, sb);\n}\n\n\nvoid sockem_close (sockem_t *skm) {\n        mtx_lock(&sockem_lock);\n        mtx_lock(&skm->lock);\n        if (skm->linked)\n                LIST_REMOVE(skm, link);\n        mtx_unlock(&sockem_lock);\n\n        /* If thread is running let it close the sockets\n         * to avoid race condition. */\n        if (skm->run == SOCKEM_START ||\n            skm->run == SOCKEM_RUN)\n                skm->run = SOCKEM_TERM;\n        else\n                sockem_close_all(skm);\n\n        mtx_unlock(&skm->lock);\n\n        thrd_join0(skm->thrd);\n\n        sockem_bufs_purge(skm);\n\n        mtx_destroy(&skm->lock);\n\n\n        free(skm);\n}\n\n\n/**\n * @brief Set single conf key.\n * @remark lock must be held.\n * @returns 0 on success or -1 if key is unknown\n */\nstatic int sockem_set0 (sockem_t *skm, const char *key, int val) {\n        if (!strcmp(key, \"rx.thruput\") ||\n            !strcmp(key, \"rx.throughput\"))\n                skm->conf.rx_thruput = val;\n        else if (!strcmp(key, \"tx.thruput\") ||\n                 !strcmp(key, \"tx.throughput\"))\n                skm->conf.tx_thruput = val;\n        else if (!strcmp(key, \"delay\"))\n                skm->conf.delay = val;\n        else if (!strcmp(key, \"jitter\"))\n                skm->conf.jitter = val;\n        else if (!strcmp(key, \"rx.bufsz\"))\n                skm->conf.recv_bufsz = val;\n        else if (!strcmp(key, \"debug\"))\n                skm->conf.debug = val;\n        else if (!strcmp(key, \"true\"))\n                ; /* dummy key for allowing non-empty but default config */\n        else if (!strchr(key, ',')) {\n                char *s = strdupa(key);\n                while (*s) {\n                        char *t = strchr(s, ',');\n                        char *d = strchr(s, '=');\n                        if (t)\n                                *t = '\\0';\n                        if (!d)\n                                return -1;\n                        *(d++) = '\\0';\n\n                        if (sockem_set0(skm, s, atoi(d)) == -1)\n                                return -1;\n\n                        if (!t)\n                                break;\n                        s += 1;\n                }\n        } else\n                return -1;\n\n        return 0;\n}\n\n\n/**\n * @brief Set sockem config parameters\n */\nstatic int sockem_vset (sockem_t *skm, va_list ap) {\n        const char *key;\n        int val;\n\n        mtx_lock(&skm->lock);\n        while ((key = va_arg(ap, const char *))) {\n                val = va_arg(ap, int);\n                if (sockem_set0(skm, key, val) == -1) {\n                        mtx_unlock(&skm->lock);\n                        return -1;\n                }\n        }\n        mtx_unlock(&skm->lock);\n\n        return 0;\n}\n\nint sockem_set (sockem_t *skm, ...) {\n        va_list ap;\n        int r;\n\n        va_start(ap, skm);\n        r = sockem_vset(skm, ap);\n        va_end(ap);\n\n        return r;\n}\n\n\nsockem_t *sockem_find (int sockfd) {\n        sockem_t *skm;\n\n        pthread_once(&sockem_once, sockem_init);\n\n        mtx_lock(&sockem_lock);\n        LIST_FOREACH(skm, &sockems, link)\n                if (skm->as == sockfd)\n                        break;\n        mtx_unlock(&sockem_lock);\n\n        return skm;\n}\n\n\n#ifdef LIBSOCKEM_PRELOAD\n/**\n * Provide overloading socket APIs and conf bootstrapping from env vars.\n *\n */\n\n\n\n/**\n * @brief connect(2) overload\n */\nint connect (int sockfd, const struct sockaddr *addr, socklen_t addrlen) {\n        sockem_t *skm;\n\n        pthread_once(&sockem_once, sockem_init);\n\n        skm = sockem_connect(sockfd, addr, addrlen, sockem_conf_str, 0, NULL);\n        if (!skm)\n                return -1;\n\n        return 0;\n}\n\n/**\n * @brief close(2) overload\n */\nint close (int fd) {\n        sockem_t *skm;\n\n        pthread_once(&sockem_once, sockem_init);\n\n        mtx_lock(&sockem_lock);\n        skm = sockem_find(fd);\n\n        if (skm)\n                sockem_close(skm);\n        mtx_unlock(&sockem_lock);\n\n        return sockem_close0(fd);\n}\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.2-nxttfe2rxn7kioxkg2cdxrj7lmztj3cp/spack-src/src/librdkafka_cgrp_synch.png",
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.2-nxttfe2rxn7kioxkg2cdxrj7lmztj3cp/spack-src/packaging/nuget/common/p-common__plat-windows__arch-win32__bldtype-Release/msvcr120.zip",
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.2-nxttfe2rxn7kioxkg2cdxrj7lmztj3cp/spack-src/packaging/nuget/common/p-common__plat-windows__arch-x64__bldtype-Release/msvcr120.zip"
    ],
    "total_files": 505
}