{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-r-igraph-1.0.1-ilkfvz4bbtrxvmsc5vcghslxiqzaajlv/spack-src/src/glpk/glpenv08.c": "/* glpenv08.c (shared library support) */\n\n/***********************************************************************\n*  This code is part of GLPK (GNU Linear Programming Kit).\n*\n*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,\n*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.\n*  E-mail: <mao@gnu.org>.\n*\n*  GLPK is free software: you can redistribute it and/or modify it\n*  under the terms of the GNU General Public License as published by\n*  the Free Software Foundation, either version 3 of the License, or\n*  (at your option) any later version.\n*\n*  GLPK is distributed in the hope that it will be useful, but WITHOUT\n*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n*  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n*  License for more details.\n*\n*  You should have received a copy of the GNU General Public License\n*  along with GLPK. If not, see <http://www.gnu.org/licenses/>.\n***********************************************************************/\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"glpenv.h\"\n\n/* GNU version ********************************************************/\n\n#if defined(HAVE_LTDL)\n\n#include <ltdl.h>\n\nvoid *xdlopen(const char *module)\n{     void *h = NULL;\n      if (lt_dlinit() != 0)\n      {  lib_err_msg(lt_dlerror());\n         goto done;\n      }\n      h = lt_dlopen(module);\n      if (h == NULL)\n      {  lib_err_msg(lt_dlerror());\n         if (lt_dlexit() != 0)\n            xerror(\"xdlopen: %s\\n\", lt_dlerror());\n      }\ndone: return h;\n}\n\nvoid *xdlsym(void *h, const char *symbol)\n{     void *ptr;\n      xassert(h != NULL);\n      ptr = lt_dlsym(h, symbol);\n      if (ptr == NULL)\n         xerror(\"xdlsym: %s: %s\\n\", symbol, lt_dlerror());\n      return ptr;\n}\n\nvoid xdlclose(void *h)\n{     xassert(h != NULL);\n      if (lt_dlclose(h) != 0)\n         xerror(\"xdlclose: %s\\n\", lt_dlerror());\n      if (lt_dlexit() != 0)\n         xerror(\"xdlclose: %s\\n\", lt_dlerror());\n      return;\n}\n\n/* POSIX version ******************************************************/\n\n#elif defined(HAVE_DLFCN)\n\n#include <dlfcn.h>\n\nvoid *xdlopen(const char *module)\n{     void *h;\n      h = dlopen(module, RTLD_NOW);\n      if (h == NULL)\n         lib_err_msg(dlerror());\n      return h;\n}\n\nvoid *xdlsym(void *h, const char *symbol)\n{     void *ptr;\n      xassert(h != NULL);\n      ptr = dlsym(h, symbol);\n      if (ptr == NULL)\n         xerror(\"xdlsym: %s: %s\\n\", symbol, dlerror());\n      return ptr;\n}\n\nvoid xdlclose(void *h)\n{     xassert(h != NULL);\n      if (dlclose(h) != 0)\n         xerror(\"xdlclose: %s\\n\", dlerror());\n      return;\n}\n\n/* Windows version ****************************************************/\n\n#elif defined(__WOE__)\n\n#include <windows.h>\n\nvoid *xdlopen(const char *module)\n{     void *h;\n      h = LoadLibrary(module);\n      if (h == NULL)\n      {  char msg[20];\n         sprintf(msg, \"Error %d\", GetLastError());\n         lib_err_msg(msg);\n      }\n      return h;\n}\n\nvoid *xdlsym(void *h, const char *symbol)\n{     void *ptr;\n      xassert(h != NULL);\n      ptr = GetProcAddress(h, symbol);\n      if (ptr == NULL)\n         xerror(\"xdlsym: %s: Error %d\\n\", symbol, GetLastError());\n      return ptr;\n}\n\nvoid xdlclose(void *h)\n{     xassert(h != NULL);\n      if (!FreeLibrary(h))\n         xerror(\"xdlclose: Error %d\\n\", GetLastError());\n      return;\n}\n\n/* NULL version *******************************************************/\n\n#else\n\nvoid *xdlopen(const char *module)\n{     xassert(module == module);\n      lib_err_msg(\"Shared libraries not supported\");\n      return NULL;\n}\n\nvoid *xdlsym(void *h, const char *symbol)\n{     xassert(h != h);\n      xassert(symbol != symbol);\n      return NULL;\n}\n\nvoid xdlclose(void *h)\n{     xassert(h != h);\n      return;\n}\n\n#endif\n\n/* eof */\n",
        "/tmp/vanessa/spack-stage/spack-stage-r-igraph-1.0.1-ilkfvz4bbtrxvmsc5vcghslxiqzaajlv/spack-src/src/glpk/glpsql.c": "/* glpsql.c */\n\n/***********************************************************************\n*  This code is part of GLPK (GNU Linear Programming Kit).\n*\n*  Author: Heinrich Schuchardt <xypron.glpk@gmx.de>.\n*\n*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,\n*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.\n*  E-mail: <mao@gnu.org>.\n*\n*  GLPK is free software: you can redistribute it and/or modify it\n*  under the terms of the GNU General Public License as published by\n*  the Free Software Foundation, either version 3 of the License, or\n*  (at your option) any later version.\n*\n*  GLPK is distributed in the hope that it will be useful, but WITHOUT\n*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n*  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n*  License for more details.\n*\n*  You should have received a copy of the GNU General Public License\n*  along with GLPK. If not, see <http://www.gnu.org/licenses/>.\n***********************************************************************/\n\n#ifdef __clang__\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#endif\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"glpmpl.h\"\n#include \"glpsql.h\"\n\n#ifdef ODBC_DLNAME\n#define HAVE_ODBC\n#define libodbc ODBC_DLNAME\n#define h_odbc (get_env_ptr()->h_odbc)\n#endif\n\n#ifdef MYSQL_DLNAME\n#define HAVE_MYSQL\n#define libmysql MYSQL_DLNAME\n#define h_mysql (get_env_ptr()->h_mysql)\n#endif\n\nstatic void *db_iodbc_open_int(TABDCA *dca, int mode, const char\n      **sqllines);\nstatic void *db_mysql_open_int(TABDCA *dca, int mode, const char\n      **sqllines);\n\n/**********************************************************************/\n\n#if defined(HAVE_ODBC) || defined(HAVE_MYSQL)\n\n#define SQL_FIELD_MAX 100\n/* maximal field count */\n\n#define SQL_FDLEN_MAX 255\n/* maximal field length */\n\n/***********************************************************************\n*  NAME\n*\n*  args_concat - concatenate arguments\n*\n*  SYNOPSIS\n*\n*  static char **args_concat(TABDCA *dca);\n*\n*  DESCRIPTION\n*\n*  The arguments passed in dca are SQL statements. A SQL statement may\n*  be split over multiple arguments. The last argument of a SQL\n*  statement will be terminated with a semilocon. Each SQL statement is\n*  merged into a single zero terminated string. Boundaries between\n*  arguments are replaced by space.\n*\n*  RETURNS\n*\n*  Buffer with SQL statements */\n\nstatic char **args_concat(TABDCA *dca)\n{\n   const char  *arg;\n   int          i;\n   int          j;\n   int          j0;\n   int          j1;\n   int          len;\n   int          lentot;\n   int          narg;\n   int          nline = 0;\n   void        *ret;\n   char       **sqllines = NULL;\n\n   narg = mpl_tab_num_args(dca);\n   /* The SQL statements start with argument 3. */\n   if (narg < 3)\n      return NULL;\n   /* Count the SQL statements */\n   for (j = 3; j <= narg; j++)\n   {\n      arg = mpl_tab_get_arg(dca, j);\n      len = strlen(arg);\n      if (arg[len-1] == ';' || j == narg)\n        nline ++;\n   }\n   /* Allocate string buffer. */\n   sqllines = (char **) xmalloc((nline+1) * sizeof(char **));\n   /* Join arguments */\n   sqllines[0] = NULL;\n   j0     = 3;\n   i      = 0;\n   lentot = 0;\n   for (j = 3; j <= narg; j++)\n   {\n      arg = mpl_tab_get_arg(dca, j);\n      len = strlen(arg);\n      lentot += len;\n      if (arg[len-1] == ';' || j == narg)\n      {  /* Join arguments for a single SQL statement */\n         sqllines[i] = xmalloc(lentot+1);\n         sqllines[i+1] = NULL;\n         sqllines[i][0] = 0x00;\n         for (j1 = j0; j1 <= j; j1++)\n         {  if(j1>j0)\n               strcat(sqllines[i], \" \");\n            strcat(sqllines[i], mpl_tab_get_arg(dca, j1));\n         }\n         len = strlen(sqllines[i]);\n         if (sqllines[i][len-1] == ';')\n            sqllines[i][len-1] = 0x00;\n         j0 = j+1;\n         i++;\n         lentot = 0;\n      }\n   }\n   return sqllines;\n}\n\n/***********************************************************************\n*  NAME\n*\n*  free_buffer - free multiline string buffer\n*\n*  SYNOPSIS\n*\n*  static void free_buffer(char **buf);\n*\n*  DESCRIPTION\n*\n*  buf is a list of strings terminated by NULL.\n*  The memory for the strings and for the list is released. */\n\nstatic void free_buffer(char **buf)\n{  int i;\n\n   for(i = 0; buf[i] != NULL; i++)\n      xfree(buf[i]);\n   xfree(buf);\n}\n\nstatic int db_escaped_string_length(const char* from)\n/* length of escaped string */\n{\n   int         count;\n   const char *pointer;\n\n    for (pointer = from, count = 0; *pointer != (char) '\\0'; pointer++,\n         count++)\n    {\n      switch (*pointer)\n      {\n         case '\\'':\n            count++;\n            break;\n      }\n    }\n\n    return count;\n}\n\nstatic int db_escape_string (char *to, const char *from)\n/* escape string*/\n{\n   const char *source = from;\n   char *target = to;\n   unsigned int remaining;\n\n   remaining = strlen(from);\n\n   if (to == NULL)\n     to = (char *) (from + remaining);\n\n   while (remaining > 0)\n   {\n      switch (*source)\n      {\n         case '\\'':\n            *target = '\\'';\n            target++;\n            *target = '\\'';\n            break;\n\n         default:\n            *target = *source;\n            }\n      source++;\n      target++;\n      remaining--;\n      }\n\n   /* Write the terminating NUL character. */\n   *target = '\\0';\n\n   return target - to;\n}\n\nstatic char *db_generate_select_stmt(TABDCA *dca)\n/* generate select statement */\n{\n   char        *arg;\n   char const  *field;\n   char        *query;\n   int          j;\n   int          narg;\n   int          nf;\n   int          total;\n\n   total = 50;\n   nf = mpl_tab_num_flds(dca);\n   narg = mpl_tab_num_args(dca);\n   for (j=1; j <= nf && j <= SQL_FIELD_MAX; j++)\n   {\n      field = mpl_tab_get_name(dca, j);\n      total += strlen(field);\n      total += 2;\n   }\n   arg = (char *) mpl_tab_get_arg(dca, narg);\n   total += strlen(arg);\n   query = xmalloc( total * sizeof(char));\n   strcpy (query, \"SELECT \");\n   for (j=1; j <= nf && j <= SQL_FIELD_MAX; j++)\n   {\n      field = mpl_tab_get_name(dca, j);\n      strcat(query, field);\n      if ( j < nf )\n         strcat(query, \", \");\n   }\n   strcat(query, \" FROM \");\n   strcat(query, arg);\n   return query;\n}\n\nstatic char *db_generate_insert_stmt(TABDCA *dca)\n/* generate insert statement */\n{\n   char        *arg;\n   char const  *field;\n   char        *query;\n   int          j;\n   int          narg;\n   int          nf;\n   int          total;\n\n   total = 50;\n   nf = mpl_tab_num_flds(dca);\n   narg = mpl_tab_num_args(dca);\n   for (j=1; j <= nf && j <= SQL_FIELD_MAX; j++)\n   {\n      field = mpl_tab_get_name(dca, j);\n      total += strlen(field);\n      total += 5;\n   }\n   arg = (char *) mpl_tab_get_arg(dca, narg);\n   total += strlen(arg);\n   query = xmalloc( (total+1) * sizeof(char));\n   strcpy (query, \"INSERT INTO \");\n   strcat(query, arg);\n   strcat(query, \" ( \");\n   for (j=1; j <= nf && j <= SQL_FIELD_MAX; j++)\n   {\n      field = mpl_tab_get_name(dca, j);\n      strcat(query, field);\n      if ( j < nf )\n         strcat(query, \", \");\n   }\n   strcat(query, \" ) VALUES ( \");\n   for (j=1; j <= nf && j <= SQL_FIELD_MAX; j++)\n   {\n      strcat(query, \"?\");\n      if ( j < nf )\n         strcat(query, \", \");\n   }\n   strcat(query, \" )\");\n   return query;\n}\n\n#endif\n\n/**********************************************************************/\n\n#ifndef HAVE_ODBC\n\nvoid *db_iodbc_open(TABDCA *dca, int mode)\n{     xassert(dca == dca);\n      xassert(mode == mode);\n      xprintf(\"iODBC table driver not supported\\n\");\n      return NULL;\n}\n\nint db_iodbc_read(TABDCA *dca, void *link)\n{     xassert(dca != dca);\n      xassert(link != link);\n      return 0;\n}\n\nint db_iodbc_write(TABDCA *dca, void *link)\n{     xassert(dca != dca);\n      xassert(link != link);\n      return 0;\n}\n\nint db_iodbc_close(TABDCA *dca, void *link)\n{     xassert(dca != dca);\n      xassert(link != link);\n      return 0;\n}\n\n#else\n\n#if defined(__CYGWIN__) || defined(__MINGW32__) || defined(__WOE__)\n#include <windows.h>\n#endif\n\n#include <sql.h>\n#include <sqlext.h>\n\nstruct db_odbc\n{\n   int              mode;         /*'R' = Read, 'W' = Write*/\n   SQLHDBC          hdbc;         /*connection handle*/\n   SQLHENV          henv;         /*environment handle*/\n   SQLHSTMT         hstmt;        /*statement handle*/\n   SQLSMALLINT      nresultcols;  /* columns in result*/\n   SQLULEN          collen[SQL_FIELD_MAX+1];\n   SQLLEN           outlen[SQL_FIELD_MAX+1];\n   SQLSMALLINT      coltype[SQL_FIELD_MAX+1];\n   SQLCHAR          data[SQL_FIELD_MAX+1][SQL_FDLEN_MAX+1];\n   SQLCHAR          colname[SQL_FIELD_MAX+1][SQL_FDLEN_MAX+1];\n   int              isnumeric[SQL_FIELD_MAX+1];\n   int              nf;\n   /* number of fields in the csv file */\n   int              ref[1+SQL_FIELD_MAX];\n   /* ref[k] = k', if k-th field of the csv file corresponds to\n      k'-th field in the table statement; if ref[k] = 0, k-th field\n      of the csv file is ignored */\n   SQLCHAR         *query;\n   /* query generated by db_iodbc_open */\n};\n\nSQLRETURN SQL_API dl_SQLAllocHandle (\n   SQLSMALLINT           HandleType,\n   SQLHANDLE             InputHandle,\n   SQLHANDLE            *OutputHandle)\n{\n      typedef SQLRETURN SQL_API ep_SQLAllocHandle(\n         SQLSMALLINT           HandleType,\n         SQLHANDLE             InputHandle,\n         SQLHANDLE            *OutputHandle);\n\n      ep_SQLAllocHandle *fn;\n      fn = (ep_SQLAllocHandle *) xdlsym(h_odbc, \"SQLAllocHandle\");\n      xassert(fn != NULL);\n      return (*fn)(HandleType, InputHandle, OutputHandle);\n}\n\nSQLRETURN SQL_API dl_SQLBindCol (\n   SQLHSTMT              StatementHandle,\n   SQLUSMALLINT          ColumnNumber,\n   SQLSMALLINT           TargetType,\n   SQLPOINTER            TargetValue,\n   SQLLEN                BufferLength,\n   SQLLEN               *StrLen_or_Ind)\n{\n      typedef SQLRETURN SQL_API ep_SQLBindCol(\n         SQLHSTMT              StatementHandle,\n         SQLUSMALLINT          ColumnNumber,\n         SQLSMALLINT           TargetType,\n         SQLPOINTER            TargetValue,\n         SQLLEN                BufferLength,\n         SQLLEN               *StrLen_or_Ind);\n      ep_SQLBindCol *fn;\n      fn = (ep_SQLBindCol *) xdlsym(h_odbc, \"SQLBindCol\");\n      xassert(fn != NULL);\n      return (*fn)(StatementHandle, ColumnNumber, TargetType,\n         TargetValue, BufferLength, StrLen_or_Ind);\n}\n\nSQLRETURN SQL_API dl_SQLCloseCursor (\n   SQLHSTMT              StatementHandle)\n{\n      typedef SQLRETURN SQL_API ep_SQLCloseCursor (\n         SQLHSTMT              StatementHandle);\n\n      ep_SQLCloseCursor *fn;\n      fn = (ep_SQLCloseCursor *) xdlsym(h_odbc, \"SQLCloseCursor\");\n      xassert(fn != NULL);\n      return (*fn)(StatementHandle);\n}\n\n\nSQLRETURN SQL_API dl_SQLDisconnect (\n   SQLHDBC               ConnectionHandle)\n{\n      typedef SQLRETURN SQL_API ep_SQLDisconnect(\n         SQLHDBC               ConnectionHandle);\n\n      ep_SQLDisconnect *fn;\n      fn = (ep_SQLDisconnect *) xdlsym(h_odbc, \"SQLDisconnect\");\n      xassert(fn != NULL);\n      return (*fn)(ConnectionHandle);\n}\n\nSQLRETURN SQL_API dl_SQLDriverConnect (\n   SQLHDBC               hdbc,\n   SQLHWND               hwnd,\n   SQLCHAR              *szConnStrIn,\n   SQLSMALLINT           cbConnStrIn,\n   SQLCHAR              *szConnStrOut,\n   SQLSMALLINT           cbConnStrOutMax,\n   SQLSMALLINT          *pcbConnStrOut,\n   SQLUSMALLINT          fDriverCompletion)\n{\n      typedef SQLRETURN SQL_API ep_SQLDriverConnect(\n         SQLHDBC               hdbc,\n         SQLHWND               hwnd,\n         SQLCHAR             * szConnStrIn,\n         SQLSMALLINT           cbConnStrIn,\n         SQLCHAR             * szConnStrOut,\n         SQLSMALLINT           cbConnStrOutMax,\n         SQLSMALLINT         * pcbConnStrOut,\n         SQLUSMALLINT          fDriverCompletion);\n\n      ep_SQLDriverConnect *fn;\n      fn = (ep_SQLDriverConnect *) xdlsym(h_odbc, \"SQLDriverConnect\");\n      xassert(fn != NULL);\n      return (*fn)(hdbc, hwnd, szConnStrIn, cbConnStrIn, szConnStrOut,\n         cbConnStrOutMax, pcbConnStrOut, fDriverCompletion);\n}\n\nSQLRETURN SQL_API dl_SQLEndTran (\n   SQLSMALLINT           HandleType,\n   SQLHANDLE             Handle,\n   SQLSMALLINT           CompletionType)\n{\n      typedef SQLRETURN SQL_API ep_SQLEndTran (\n         SQLSMALLINT           HandleType,\n         SQLHANDLE             Handle,\n         SQLSMALLINT           CompletionType);\n\n      ep_SQLEndTran *fn;\n      fn = (ep_SQLEndTran *) xdlsym(h_odbc, \"SQLEndTran\");\n      xassert(fn != NULL);\n      return (*fn)(HandleType, Handle, CompletionType);\n}\n\nSQLRETURN SQL_API dl_SQLExecDirect (\n   SQLHSTMT              StatementHandle,\n   SQLCHAR             * StatementText,\n   SQLINTEGER            TextLength)\n{\n      typedef SQLRETURN SQL_API ep_SQLExecDirect (\n         SQLHSTMT              StatementHandle,\n         SQLCHAR             * StatementText,\n         SQLINTEGER            TextLength);\n\n      ep_SQLExecDirect *fn;\n      fn = (ep_SQLExecDirect *) xdlsym(h_odbc, \"SQLExecDirect\");\n      xassert(fn != NULL);\n      return (*fn)(StatementHandle, StatementText, TextLength);\n}\n\nSQLRETURN SQL_API dl_SQLFetch (\n   SQLHSTMT              StatementHandle)\n{\n      typedef SQLRETURN SQL_API ep_SQLFetch (\n         SQLHSTMT              StatementHandle);\n\n      ep_SQLFetch *fn;\n      fn = (ep_SQLFetch*) xdlsym(h_odbc, \"SQLFetch\");\n      xassert(fn != NULL);\n      return (*fn)(StatementHandle);\n}\n\nSQLRETURN SQL_API dl_SQLFreeHandle (\n   SQLSMALLINT           HandleType,\n   SQLHANDLE             Handle)\n{\n      typedef SQLRETURN SQL_API ep_SQLFreeHandle (\n         SQLSMALLINT           HandleType,\n         SQLHANDLE             Handle);\n\n      ep_SQLFreeHandle *fn;\n      fn = (ep_SQLFreeHandle *) xdlsym(h_odbc, \"SQLFreeHandle\");\n      xassert(fn != NULL);\n      return (*fn)(HandleType, Handle);\n}\n\nSQLRETURN SQL_API dl_SQLDescribeCol (\n   SQLHSTMT              StatementHandle,\n   SQLUSMALLINT          ColumnNumber,\n   SQLCHAR             * ColumnName,\n   SQLSMALLINT           BufferLength,\n   SQLSMALLINT         * NameLength,\n   SQLSMALLINT         * DataType,\n   SQLULEN             * ColumnSize,\n   SQLSMALLINT         * DecimalDigits,\n   SQLSMALLINT         * Nullable)\n{\n      typedef SQLRETURN SQL_API ep_SQLDescribeCol (\n         SQLHSTMT              StatementHandle,\n         SQLUSMALLINT          ColumnNumber,\n         SQLCHAR              *ColumnName,\n         SQLSMALLINT           BufferLength,\n         SQLSMALLINT          *NameLength,\n         SQLSMALLINT          *DataType,\n         SQLULEN              *ColumnSize,\n         SQLSMALLINT          *DecimalDigits,\n         SQLSMALLINT          *Nullable);\n\n      ep_SQLDescribeCol *fn;\n      fn = (ep_SQLDescribeCol *) xdlsym(h_odbc, \"SQLDescribeCol\");\n      xassert(fn != NULL);\n      return (*fn)(StatementHandle, ColumnNumber, ColumnName,\n         BufferLength, NameLength,\n         DataType, ColumnSize, DecimalDigits, Nullable);\n}\n\nSQLRETURN SQL_API dl_SQLGetDiagRec (\n   SQLSMALLINT           HandleType,\n   SQLHANDLE             Handle,\n   SQLSMALLINT           RecNumber,\n   SQLCHAR              *Sqlstate,\n   SQLINTEGER           *NativeError,\n   SQLCHAR              *MessageText,\n   SQLSMALLINT           BufferLength,\n   SQLSMALLINT          *TextLength)\n{\n      typedef SQLRETURN SQL_API ep_SQLGetDiagRec (\n         SQLSMALLINT           HandleType,\n         SQLHANDLE             Handle,\n         SQLSMALLINT           RecNumber,\n         SQLCHAR              *Sqlstate,\n         SQLINTEGER           *NativeError,\n         SQLCHAR              *MessageText,\n         SQLSMALLINT           BufferLength,\n         SQLSMALLINT          *TextLength);\n\n      ep_SQLGetDiagRec *fn;\n      fn = (ep_SQLGetDiagRec *) xdlsym(h_odbc, \"SQLGetDiagRec\");\n      xassert(fn != NULL);\n      return (*fn)(HandleType, Handle, RecNumber, Sqlstate,\n         NativeError, MessageText, BufferLength, TextLength);\n}\n\nSQLRETURN SQL_API dl_SQLGetInfo (\n   SQLHDBC               ConnectionHandle,\n   SQLUSMALLINT          InfoType,\n   SQLPOINTER            InfoValue,\n   SQLSMALLINT           BufferLength,\n   SQLSMALLINT          *StringLength)\n{\n      typedef SQLRETURN SQL_API ep_SQLGetInfo (\n         SQLHDBC               ConnectionHandle,\n         SQLUSMALLINT          InfoType,\n         SQLPOINTER            InfoValue,\n         SQLSMALLINT           BufferLength,\n         SQLSMALLINT          *StringLength);\n\n      ep_SQLGetInfo *fn;\n      fn = (ep_SQLGetInfo *) xdlsym(h_odbc, \"SQLGetInfo\");\n      xassert(fn != NULL);\n      return (*fn)(ConnectionHandle, InfoType, InfoValue, BufferLength,\n         StringLength);\n}\n\nSQLRETURN SQL_API dl_SQLNumResultCols (\n   SQLHSTMT              StatementHandle,\n   SQLSMALLINT          *ColumnCount)\n{\n      typedef SQLRETURN SQL_API ep_SQLNumResultCols (\n         SQLHSTMT              StatementHandle,\n         SQLSMALLINT          *ColumnCount);\n\n      ep_SQLNumResultCols *fn;\n      fn = (ep_SQLNumResultCols *) xdlsym(h_odbc, \"SQLNumResultCols\");\n      xassert(fn != NULL);\n      return (*fn)(StatementHandle, ColumnCount);\n}\n\nSQLRETURN SQL_API dl_SQLSetConnectAttr (\n   SQLHDBC               ConnectionHandle,\n   SQLINTEGER            Attribute,\n   SQLPOINTER            Value,\n   SQLINTEGER            StringLength)\n{\n      typedef SQLRETURN SQL_API ep_SQLSetConnectAttr (\n         SQLHDBC               ConnectionHandle,\n         SQLINTEGER            Attribute,\n         SQLPOINTER            Value,\n         SQLINTEGER            StringLength);\n\n      ep_SQLSetConnectAttr *fn;\n     fn = (ep_SQLSetConnectAttr *) xdlsym(h_odbc, \"SQLSetConnectAttr\");\n      xassert(fn != NULL);\n      return (*fn)(ConnectionHandle, Attribute, Value, StringLength);\n}\n\nSQLRETURN SQL_API dl_SQLSetEnvAttr (\n   SQLHENV               EnvironmentHandle,\n   SQLINTEGER            Attribute,\n   SQLPOINTER            Value,\n   SQLINTEGER            StringLength)\n{\n      typedef SQLRETURN SQL_API ep_SQLSetEnvAttr (\n         SQLHENV               EnvironmentHandle,\n         SQLINTEGER            Attribute,\n         SQLPOINTER            Value,\n         SQLINTEGER            StringLength);\n\n      ep_SQLSetEnvAttr *fn;\n      fn = (ep_SQLSetEnvAttr *) xdlsym(h_odbc, \"SQLSetEnvAttr\");\n      xassert(fn != NULL);\n      return (*fn)(EnvironmentHandle, Attribute, Value, StringLength);\n}\n\nstatic void extract_error(\n   char *fn,\n   SQLHANDLE handle,\n   SQLSMALLINT type);\n\nstatic int is_numeric(\n    SQLSMALLINT coltype);\n\n/***********************************************************************\n*  NAME\n*\n*  db_iodbc_open - open connection to ODBC data base\n*\n*  SYNOPSIS\n*\n*  #include \"glpsql.h\"\n*  void *db_iodbc_open(TABDCA *dca, int mode);\n*\n*  DESCRIPTION\n*\n*  The routine db_iodbc_open opens a connection to an ODBC data base.\n*  It then executes the sql statements passed.\n*\n*  In the case of table read the SELECT statement is executed.\n*\n*  In the case of table write the INSERT statement is prepared.\n*  RETURNS\n*\n*  The routine returns a pointer to data storage area created. */\nvoid *db_iodbc_open(TABDCA *dca, int mode)\n{  void  *ret;\n   char **sqllines;\n\n   sqllines = args_concat(dca);\n   if (sqllines == NULL)\n   {  xprintf(\"Missing arguments in table statement.\\n\"\n              \"Please, supply table driver, dsn, and query.\\n\");\n      return NULL;\n   }\n   ret = db_iodbc_open_int(dca, mode, (const char **) sqllines);\n   free_buffer(sqllines);\n   return ret;\n}\n\nstatic void *db_iodbc_open_int(TABDCA *dca, int mode, const char\n   **sqllines)\n{\n   struct db_odbc    *sql;\n   SQLRETURN          ret;\n   SQLCHAR FAR       *dsn;\n   SQLCHAR            info[256];\n   SQLSMALLINT        colnamelen;\n   SQLSMALLINT        nullable;\n   SQLSMALLINT        scale;\n   const char        *arg;\n   int                narg;\n   int                i, j;\n   int                total;\n\n   if (libodbc == NULL)\n   {\n      xprintf(\"No loader for shared ODBC library available\\n\");\n      return NULL;\n   }\n\n   if (h_odbc == NULL)\n   {\n      h_odbc = xdlopen(libodbc);\n      if (h_odbc == NULL)\n      {  xprintf(\"unable to open library %s\\n\", libodbc);\n         xprintf(\"%s\\n\", xerrmsg());\n         return NULL;\n      }\n   }\n\n   sql = (struct db_odbc *) xmalloc(sizeof(struct db_odbc));\n   if (sql == NULL)\n         return NULL;\n\n   sql->mode  = mode;\n   sql->hdbc  = NULL;\n   sql->henv  = NULL;\n   sql->hstmt = NULL;\n   sql->query = NULL;\n   narg = mpl_tab_num_args(dca);\n\n   dsn = (SQLCHAR FAR *) mpl_tab_get_arg(dca, 2);\n   /* allocate an environment handle */\n   ret = dl_SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE,\n      &(sql->henv));\n   /* set attribute to enable application to run as ODBC 3.0\n      application */\n   ret = dl_SQLSetEnvAttr(sql->henv, SQL_ATTR_ODBC_VERSION,\n      (void *) SQL_OV_ODBC3, 0);\n   /* allocate a connection handle */\n   ret = dl_SQLAllocHandle(SQL_HANDLE_DBC, sql->henv, &(sql->hdbc));\n   /* connect */\n   ret = dl_SQLDriverConnect(sql->hdbc, NULL, dsn, SQL_NTS, NULL, 0,\n      NULL, SQL_DRIVER_COMPLETE);\n   if (SQL_SUCCEEDED(ret))\n   {  /* output information about data base connection */\n      xprintf(\"Connected to \");\n      dl_SQLGetInfo(sql->hdbc, SQL_DBMS_NAME, (SQLPOINTER)info,\n         sizeof(info), NULL);\n      xprintf(\"%s \", info);\n      dl_SQLGetInfo(sql->hdbc, SQL_DBMS_VER, (SQLPOINTER)info,\n         sizeof(info), NULL);\n      xprintf(\"%s - \", info);\n      dl_SQLGetInfo(sql->hdbc, SQL_DATABASE_NAME, (SQLPOINTER)info,\n         sizeof(info), NULL);\n      xprintf(\"%s\\n\", info);\n   }\n   else\n   {  /* describe error */\n      xprintf(\"Failed to connect\\n\");\n      extract_error(\"SQLDriverConnect\", sql->hdbc, SQL_HANDLE_DBC);\n      dl_SQLFreeHandle(SQL_HANDLE_DBC, sql->hdbc);\n      dl_SQLFreeHandle(SQL_HANDLE_ENV, sql->henv);\n      xfree(sql);\n      return NULL;\n   }\n   /* set AUTOCOMMIT on*/\n   ret = dl_SQLSetConnectAttr(sql->hdbc, SQL_ATTR_AUTOCOMMIT,\n      (SQLPOINTER)SQL_AUTOCOMMIT_ON, 0);\n   /* allocate a statement handle */\n   ret = dl_SQLAllocHandle(SQL_HANDLE_STMT, sql->hdbc, &(sql->hstmt));\n\n   /* initialization queries */\n   for(j = 0; sqllines[j+1] != NULL; j++)\n   {\n      sql->query = (SQLCHAR *) sqllines[j];\n      xprintf(\"%s\\n\", sql->query);\n      ret = dl_SQLExecDirect(sql->hstmt, sql->query, SQL_NTS);\n      switch (ret)\n      {\n         case SQL_SUCCESS:\n         case SQL_SUCCESS_WITH_INFO:\n         case SQL_NO_DATA_FOUND:\n            break;\n         default:\n            xprintf(\"db_iodbc_open: Query\\n\\\"%s\\\"\\nfailed.\\n\",\n               sql->query);\n            extract_error(\"SQLExecDirect\", sql->hstmt, SQL_HANDLE_STMT);\n            dl_SQLFreeHandle(SQL_HANDLE_STMT, sql->hstmt);\n            dl_SQLDisconnect(sql->hdbc);\n            dl_SQLFreeHandle(SQL_HANDLE_DBC, sql->hdbc);\n            dl_SQLFreeHandle(SQL_HANDLE_ENV, sql->henv);\n            xfree(sql);\n            return NULL;\n      }\n      /* commit statement */\n      dl_SQLEndTran(SQL_HANDLE_ENV, sql->henv, SQL_COMMIT);\n   }\n\n   if ( sql->mode == 'R' )\n   {  sql->nf = mpl_tab_num_flds(dca);\n      for(j = 0; sqllines[j] != NULL; j++)\n         arg = sqllines[j];\n      total = strlen(arg);\n      if (total > 7 && 0 == strncmp(arg, \"SELECT \", 7))\n      {\n         total = strlen(arg);\n         sql->query = xmalloc( (total+1) * sizeof(char));\n         strcpy (sql->query, arg);\n      }\n      else\n      {\n         sql->query = db_generate_select_stmt(dca);\n      }\n      xprintf(\"%s\\n\", sql->query);\n      if (dl_SQLExecDirect(sql->hstmt, sql->query, SQL_NTS) !=\n         SQL_SUCCESS)\n      {\n         xprintf(\"db_iodbc_open: Query\\n\\\"%s\\\"\\nfailed.\\n\", sql->query);\n         extract_error(\"SQLExecDirect\", sql->hstmt, SQL_HANDLE_STMT);\n         dl_SQLFreeHandle(SQL_HANDLE_STMT, sql->hstmt);\n         dl_SQLDisconnect(sql->hdbc);\n         dl_SQLFreeHandle(SQL_HANDLE_DBC, sql->hdbc);\n         dl_SQLFreeHandle(SQL_HANDLE_ENV, sql->henv);\n         xfree(sql->query);\n            xfree(sql);\n         return NULL;\n      }\n      xfree(sql->query);\n      /* determine number of result columns */\n      ret = dl_SQLNumResultCols(sql->hstmt, &sql->nresultcols);\n      total = sql->nresultcols;\n      if (total > SQL_FIELD_MAX)\n      {  xprintf(\"db_iodbc_open: Too many fields (> %d) in query.\\n\"\n            \"\\\"%s\\\"\\n\", SQL_FIELD_MAX, sql->query);\n         dl_SQLFreeHandle(SQL_HANDLE_STMT, sql->hstmt);\n         dl_SQLDisconnect(sql->hdbc);\n         dl_SQLFreeHandle(SQL_HANDLE_DBC, sql->hdbc);\n         dl_SQLFreeHandle(SQL_HANDLE_ENV, sql->henv);\n         xfree(sql->query);\n         return NULL;\n      }\n      for (i = 1; i <= total; i++)\n      {  /* return a set of attributes for a column */\n         ret = dl_SQLDescribeCol(sql->hstmt, (SQLSMALLINT) i,\n            sql->colname[i], SQL_FDLEN_MAX,\n            &colnamelen, &(sql->coltype[i]), &(sql->collen[i]), &scale,\n            &nullable);\n         sql->isnumeric[i] = is_numeric(sql->coltype[i]);\n         /* bind columns to program vars, converting all types to CHAR*/\n         dl_SQLBindCol(sql->hstmt, i, SQL_CHAR, sql->data[i],\n            SQL_FDLEN_MAX, &(sql->outlen[i]));\n         for (j = sql->nf; j >= 1; j--)\n         {  if (strcmp(mpl_tab_get_name(dca, j), sql->colname[i]) == 0)\n            break;\n         }\n         sql->ref[i] = j;\n      }\n   }\n   else if ( sql->mode == 'W' )\n   {  for(j = 0; sqllines[j] != NULL; j++)\n         arg = sqllines[j];\n      if (  NULL != strchr(arg, '?') )\n      {\n         total = strlen(arg);\n         sql->query = xmalloc( (total+1) * sizeof(char));\n         strcpy (sql->query, arg);\n         }\n      else\n      {\n         sql->query = db_generate_insert_stmt(dca);\n      }\n      xprintf(\"%s\\n\", sql->query);\n   }\n   return sql;\n}\n\nint db_iodbc_read(TABDCA *dca, void *link)\n{\n   struct db_odbc  *sql;\n   SQLRETURN        ret;\n   char             buf[SQL_FDLEN_MAX+1];\n   int              i;\n   int              len;\n   double           num;\n\n   sql = (struct db_odbc *) link;\n\n   xassert(sql != NULL);\n   xassert(sql->mode == 'R');\n\n   ret=dl_SQLFetch(sql->hstmt);\n   if (ret== SQL_ERROR)\n      return -1;\n   if (ret== SQL_NO_DATA_FOUND)\n      return -1; /*EOF*/\n   for (i=1; i <= sql->nresultcols; i++)\n   {\n      if (sql->ref[i] > 0)\n      {\n         len = sql->outlen[i];\n         if (len != SQL_NULL_DATA)\n         {\n            if (len > SQL_FDLEN_MAX)\n               len = SQL_FDLEN_MAX;\n            else if (len < 0)\n               len = 0;\n            strncpy(buf, (const char *) sql->data[i], len);\n            buf[len] = 0x00;\n            if (0 != (sql->isnumeric[i]))\n            {  strspx(buf); /* remove spaces*/\n               if (str2num(buf, &num) != 0)\n               {  xprintf(\"'%s' cannot be converted to a number.\\n\",\n                     buf);\n                  return 1;\n               }\n               mpl_tab_set_num(dca, sql->ref[i], num);\n            }\n            else\n            {  mpl_tab_set_str(dca, sql->ref[i], strtrim(buf));\n            }\n         }\n      }\n   }\n   return 0;\n}\n\nint db_iodbc_write(TABDCA *dca, void *link)\n{\n   struct db_odbc  *sql;\n   char            *part;\n   char            *query;\n   char            *template;\n   char             num[50];\n   int              k;\n   int              len;\n   int              nf;\n\n   sql = (struct db_odbc *) link;\n   xassert(sql != NULL);\n   xassert(sql->mode == 'W');\n\n   len      = strlen(sql->query);\n   template = (char *) xmalloc( (len + 1) * sizeof(char) );\n   strcpy(template, sql->query);\n\n   nf = mpl_tab_num_flds(dca);\n   for (k = 1; k <= nf; k++)\n   {     switch (mpl_tab_get_type(dca, k))\n      {  case 'N':\n            len += 20;\n            break;\n         case 'S':\n            len += db_escaped_string_length(mpl_tab_get_str(dca, k));\n            len += 2;\n            break;\n              default:\n                        xassert(dca != dca);\n         }\n   }\n   query = xmalloc( (len + 1 ) * sizeof(char) );\n   query[0] = 0x00;\n   for (k = 1, part = strtok (template, \"?\"); (part != NULL);\n      part = strtok (NULL, \"?\"), k++)\n   {\n      if (k > nf) break;\n      strcat( query, part );\n      switch (mpl_tab_get_type(dca, k))\n      {  case 'N':\n#if 0 /* 02/XI-2010 by xypron */\n            sprintf(num, \"%-18g\",mpl_tab_get_num(dca, k));\n#else\n            sprintf(num, \"%.*g\", DBL_DIG, mpl_tab_get_num(dca, k));\n#endif\n            strcat( query, num );\n            break;\n         case 'S':\n            strcat( query, \"'\");\n            db_escape_string( query + strlen(query),\n               mpl_tab_get_str(dca, k) );\n            strcat( query, \"'\");\n            break;\n              default:\n                        xassert(dca != dca);\n         }\n   }\n   if (part != NULL)\n      strcat(query, part);\n   if (dl_SQLExecDirect(sql->hstmt, (SQLCHAR *) query, SQL_NTS)\n      != SQL_SUCCESS)\n   {\n      xprintf(\"db_iodbc_write: Query\\n\\\"%s\\\"\\nfailed.\\n\", query);\n      extract_error(\"SQLExecDirect\", sql->hdbc, SQL_HANDLE_DBC);\n      xfree(query);\n      xfree(template);\n      return 1;\n      }\n\n   xfree(query);\n   xfree(template);\n   return 0;\n}\n\nint db_iodbc_close(TABDCA *dca, void *link)\n{\n   struct db_odbc *sql;\n\n   sql = (struct db_odbc *) link;\n   xassert(sql != NULL);\n   /* Commit */\n   if ( sql->mode == 'W' )\n      dl_SQLEndTran(SQL_HANDLE_ENV, sql->henv, SQL_COMMIT);\n   if ( sql->mode == 'R' )\n      dl_SQLCloseCursor(sql->hstmt);\n\n   dl_SQLFreeHandle(SQL_HANDLE_STMT, sql->hstmt);\n   dl_SQLDisconnect(sql->hdbc);\n   dl_SQLFreeHandle(SQL_HANDLE_DBC, sql->hdbc);\n   dl_SQLFreeHandle(SQL_HANDLE_ENV, sql->henv);\n   if ( sql->mode == 'W' )\n      xfree(sql->query);\n   xfree(sql);\n   dca->link = NULL;\n   return 0;\n}\n\nstatic void extract_error(\n   char *fn,\n   SQLHANDLE handle,\n   SQLSMALLINT type)\n{\n   SQLINTEGER   i = 0;\n   SQLINTEGER   native;\n   SQLCHAR   state[ 7 ];\n   SQLCHAR   text[256];\n   SQLSMALLINT  len;\n   SQLRETURN    ret;\n\n   xprintf(\"\\nThe driver reported the following diagnostics whilst \"\n      \"running %s\\n\", fn);\n\n   do\n   {\n      ret = dl_SQLGetDiagRec(type, handle, ++i, state, &native, text,\n         sizeof(text), &len );\n      if (SQL_SUCCEEDED(ret))\n         xprintf(\"%s:%ld:%ld:%s\\n\", state, i, native, text);\n   }\n   while( ret == SQL_SUCCESS );\n}\n\nstatic int is_numeric(SQLSMALLINT coltype)\n{\n   int ret = 0;\n   switch (coltype)\n   {\n      case SQL_DECIMAL:\n      case SQL_NUMERIC:\n      case SQL_SMALLINT:\n      case SQL_INTEGER:\n      case SQL_REAL:\n      case SQL_FLOAT:\n      case SQL_DOUBLE:\n      case SQL_TINYINT:\n      case SQL_BIGINT:\n         ret = 1;\n         break;\n   }\n   return ret;\n}\n\n#endif\n\n/**********************************************************************/\n\n#ifndef HAVE_MYSQL\n\nvoid *db_mysql_open(TABDCA *dca, int mode)\n{     xassert(dca == dca);\n      xassert(mode == mode);\n      xprintf(\"MySQL table driver not supported\\n\");\n      return NULL;\n}\n\nint db_mysql_read(TABDCA *dca, void *link)\n{     xassert(dca != dca);\n      xassert(link != link);\n      return 0;\n}\n\nint db_mysql_write(TABDCA *dca, void *link)\n{     xassert(dca != dca);\n      xassert(link != link);\n      return 0;\n}\n\nint db_mysql_close(TABDCA *dca, void *link)\n{     xassert(dca != dca);\n      xassert(link != link);\n      return 0;\n}\n\n#else\n\n#if defined(__CYGWIN__) || defined(__MINGW32__) || defined(__WOE__)\n#include <windows.h>\n#endif\n\n#ifdef __CYGWIN__\n#define byte_defined 1\n#endif\n\n#include <my_global.h>\n#include <my_sys.h>\n#include <mysql.h>\n\nstruct db_mysql\n{\n   int              mode;  /*'R' = Read, 'W' = Write*/\n   MYSQL           *con;   /*connection*/\n   MYSQL_RES       *res;    /*result*/\n   int              nf;\n   /* number of fields in the csv file */\n   int              ref[1+SQL_FIELD_MAX];\n   /* ref[k] = k', if k-th field of the csv file corresponds to\n      k'-th field in the table statement; if ref[k] = 0, k-th field\n      of the csv file is ignored */\n   char            *query;\n   /* query generated by db_mysql_open */\n};\n\nvoid STDCALL dl_mysql_close(MYSQL *sock)\n{\n      typedef void STDCALL ep_mysql_close(MYSQL *sock);\n\n      ep_mysql_close *fn;\n      fn = (ep_mysql_close *) xdlsym(h_mysql, \"mysql_close\");\n      xassert(fn != NULL);\n      return (*fn)(sock);\n}\n\nconst char * STDCALL dl_mysql_error(MYSQL *mysql)\n{\n      typedef const char * STDCALL ep_mysql_error(MYSQL *mysql);\n\n      ep_mysql_error *fn;\n      fn = (ep_mysql_error *) xdlsym(h_mysql, \"mysql_error\");\n      xassert(fn != NULL);\n      return (*fn)(mysql);\n}\n\nMYSQL_FIELD * STDCALL dl_mysql_fetch_fields(MYSQL_RES *res)\n{\n      typedef MYSQL_FIELD * STDCALL\n         ep_mysql_fetch_fields(MYSQL_RES *res);\n\n      ep_mysql_fetch_fields *fn;\n   fn = (ep_mysql_fetch_fields *) xdlsym(h_mysql, \"mysql_fetch_fields\");\n      xassert(fn != NULL);\n      return (*fn)(res);\n}\n\nunsigned long * STDCALL dl_mysql_fetch_lengths(MYSQL_RES *result)\n{\n      typedef unsigned long * STDCALL\n         ep_mysql_fetch_lengths(MYSQL_RES *result);\n\n      ep_mysql_fetch_lengths *fn;\n      fn = (ep_mysql_fetch_lengths *) xdlsym(h_mysql,\n         \"mysql_fetch_lengths\");\n      xassert(fn != NULL);\n      return (*fn)(result);\n}\n\nMYSQL_ROW STDCALL dl_mysql_fetch_row(MYSQL_RES *result)\n{\n      typedef MYSQL_ROW STDCALL ep_mysql_fetch_row(MYSQL_RES *result);\n\n      ep_mysql_fetch_row *fn;\n      fn = (ep_mysql_fetch_row *) xdlsym(h_mysql, \"mysql_fetch_row\");\n      xassert(fn != NULL);\n      return (*fn)(result);\n}\n\nunsigned int STDCALL dl_mysql_field_count(MYSQL *mysql)\n{\n      typedef unsigned int STDCALL ep_mysql_field_count(MYSQL *mysql);\n\n      ep_mysql_field_count *fn;\n     fn = (ep_mysql_field_count *) xdlsym(h_mysql, \"mysql_field_count\");\n      xassert(fn != NULL);\n      return (*fn)(mysql);\n}\n\nMYSQL * STDCALL dl_mysql_init(MYSQL *mysql)\n{\n      typedef MYSQL * STDCALL ep_mysql_init(MYSQL *mysql);\n\n      ep_mysql_init *fn;\n      fn = (ep_mysql_init *) xdlsym(h_mysql, \"mysql_init\");\n      xassert(fn != NULL);\n      return (*fn)(mysql);\n}\n\nunsigned int STDCALL dl_mysql_num_fields(MYSQL_RES *res)\n{\n      typedef unsigned int STDCALL ep_mysql_num_fields(MYSQL_RES *res);\n\n      ep_mysql_num_fields *fn;\n      fn = (ep_mysql_num_fields *) xdlsym(h_mysql, \"mysql_num_fields\");\n      xassert(fn != NULL);\n      return (*fn)(res);\n}\n\nint STDCALL dl_mysql_query(MYSQL *mysql, const char *q)\n{\n      typedef int STDCALL ep_mysql_query(MYSQL *mysql, const char *q);\n\n      ep_mysql_query *fn;\n      fn = (ep_mysql_query *) xdlsym(h_mysql, \"mysql_query\");\n      xassert(fn != NULL);\n      return (*fn)(mysql, q);\n}\n\nMYSQL * STDCALL dl_mysql_real_connect(MYSQL *mysql, const char *host,\n                                           const char *user,\n                                           const char *passwd,\n                                           const char *db,\n                                           unsigned int port,\n                                           const char *unix_socket,\n                                           unsigned long clientflag)\n{\n      typedef MYSQL * STDCALL ep_mysql_real_connect(MYSQL *mysql,\n            const char *host,\n            const char *user,\n            const char *passwd,\n            const char *db,\n            unsigned int port,\n            const char *unix_socket,\n            unsigned long clientflag);\n\n      ep_mysql_real_connect *fn;\n      fn = (ep_mysql_real_connect *) xdlsym(h_mysql,\n         \"mysql_real_connect\");\n      xassert(fn != NULL);\n      return (*fn)(mysql, host, user, passwd, db, port, unix_socket,\n         clientflag);\n}\n\nMYSQL_RES * STDCALL dl_mysql_use_result(MYSQL *mysql)\n{\n      typedef MYSQL_RES * STDCALL ep_mysql_use_result(MYSQL *mysql);\n      ep_mysql_use_result *fn;\n      fn = (ep_mysql_use_result *) xdlsym(h_mysql, \"mysql_use_result\");\n      xassert(fn != NULL);\n      return (*fn)(mysql);\n}\n\n/***********************************************************************\n*  NAME\n*\n*  db_mysql_open - open connection to ODBC data base\n*\n*  SYNOPSIS\n*\n*  #include \"glpsql.h\"\n*  void *db_mysql_open(TABDCA *dca, int mode);\n*\n*  DESCRIPTION\n*\n*  The routine db_mysql_open opens a connection to a MySQL data base.\n*  It then executes the sql statements passed.\n*\n*  In the case of table read the SELECT statement is executed.\n*\n*  In the case of table write the INSERT statement is prepared.\n*  RETURNS\n*\n*  The routine returns a pointer to data storage area created. */\n\nvoid *db_mysql_open(TABDCA *dca, int mode)\n{  void  *ret;\n   char **sqllines;\n\n   sqllines = args_concat(dca);\n   if (sqllines == NULL)\n   {  xprintf(\"Missing arguments in table statement.\\n\"\n              \"Please, supply table driver, dsn, and query.\\n\");\n      return NULL;\n   }\n   ret = db_mysql_open_int(dca, mode, (const char **) sqllines);\n   free_buffer(sqllines);\n   return ret;\n}\n\nstatic void *db_mysql_open_int(TABDCA *dca, int mode, const char\n   **sqllines)\n{\n   struct db_mysql *sql = NULL;\n   char            *arg = NULL;\n   const char      *field;\n   MYSQL_FIELD     *fields;\n   char            *keyword;\n   char            *value;\n   char            *query;\n   char            *dsn;\n/* \"Server=[server_name];Database=[database_name];UID=[username];*/\n/* PWD=[password];Port=[port]\"*/\n   char            *server   = NULL;        /* Server */\n   char            *user     = NULL;        /* UID */\n   char            *password = NULL;        /* PWD */\n   char            *database = NULL;        /* Database */\n   unsigned int     port = 0;               /* Port */\n   int              narg;\n   int              i, j, total;\n\n   if (libmysql == NULL)\n   {\n      xprintf(\"No loader for shared MySQL library available\\n\");\n      return NULL;\n   }\n\n   if (h_mysql == NULL)\n   {\n      h_mysql = xdlopen(libmysql);\n      if (h_mysql == NULL)\n      {  xprintf(\"unable to open library %s\\n\", libmysql);\n         xprintf(\"%s\\n\", xerrmsg());\n         return NULL;\n      }\n   }\n\n   sql = (struct db_mysql *) xmalloc(sizeof(struct db_mysql));\n   if (sql == NULL)\n         return NULL;\n   sql->mode = mode;\n   sql->res = NULL;\n   sql->query = NULL;\n   sql->nf = mpl_tab_num_flds(dca);\n\n   narg = mpl_tab_num_args(dca);\n   if (narg < 3 )\n      xprintf(\"MySQL driver: string list too short \\n\");\n\n   /* get connection string*/\n   dsn = (char *) mpl_tab_get_arg(dca, 2);\n      /* copy connection string*/\n   i = strlen(dsn);\n   i++;\n   arg = xmalloc(i * sizeof(char));\n   strcpy(arg, dsn);\n   /*tokenize connection string*/\n   for (i = 1, keyword = strtok (arg, \"=\"); (keyword != NULL);\n      keyword = strtok (NULL, \"=\"), i++)\n   {\n         value = strtok (NULL, \";\");\n      if (value==NULL)\n         {\n            xprintf(\"db_mysql_open: Missing value for keyword %s\\n\",\n               keyword);\n            xfree(arg);\n            xfree(sql);\n            return NULL;\n      }\n      if (0 == strcmp(keyword, \"Server\"))\n            server = value;\n      else if (0 == strcmp(keyword, \"Database\"))\n             database = value;\n      else if (0 == strcmp(keyword, \"UID\"))\n             user = value;\n      else if (0 == strcmp(keyword, \"PWD\"))\n             password = value;\n      else if (0 == strcmp(keyword, \"Port\"))\n             port = (unsigned int) atol(value);\n   }\n   /* Connect to database */\n   sql->con = dl_mysql_init(NULL);\n  if (!dl_mysql_real_connect(sql->con, server, user, password, database,\n      port, NULL, 0))\n   {\n      xprintf(\"db_mysql_open: Connect failed\\n\");\n      xprintf(\"%s\\n\", dl_mysql_error(sql->con));\n      xfree(arg);\n      xfree(sql);\n      return NULL;\n   }\n   xfree(arg);\n\n   for(j = 0; sqllines[j+1] != NULL; j++)\n   {  query = (char *) sqllines[j];\n      xprintf(\"%s\\n\", query);\n      if (dl_mysql_query(sql->con, query))\n      {\n         xprintf(\"db_mysql_open: Query\\n\\\"%s\\\"\\nfailed.\\n\", query);\n         xprintf(\"%s\\n\",dl_mysql_error(sql->con));\n         dl_mysql_close(sql->con);\n         xfree(sql);\n         return NULL;\n      }\n   }\n\n   if ( sql->mode == 'R' )\n   {  sql->nf = mpl_tab_num_flds(dca);\n      for(j = 0; sqllines[j] != NULL; j++)\n         arg = (char *) sqllines[j];\n      total = strlen(arg);\n      if (total > 7 && 0 == strncmp(arg, \"SELECT \", 7))\n      {\n         total = strlen(arg);\n         query = xmalloc( (total+1) * sizeof(char));\n         strcpy (query, arg);\n      }\n      else\n      {\n         query = db_generate_select_stmt(dca);\n      }\n      xprintf(\"%s\\n\", query);\n      if (dl_mysql_query(sql->con, query))\n      {\n         xprintf(\"db_mysql_open: Query\\n\\\"%s\\\"\\nfailed.\\n\", query);\n         xprintf(\"%s\\n\",dl_mysql_error(sql->con));\n         dl_mysql_close(sql->con);\n         xfree(query);\n         xfree(sql);\n         return NULL;\n      }\n      xfree(query);\n      sql->res = dl_mysql_use_result(sql->con);\n      if (sql->res)\n      {\n         /* create references between query results and table fields*/\n         total = dl_mysql_num_fields(sql->res);\n         if (total > SQL_FIELD_MAX)\n         {  xprintf(\"db_mysql_open: Too many fields (> %d) in query.\\n\"\n               \"\\\"%s\\\"\\n\", SQL_FIELD_MAX, query);\n            xprintf(\"%s\\n\",dl_mysql_error(sql->con));\n            dl_mysql_close(sql->con);\n            xfree(query);\n                 xfree(sql);\n            return NULL;\n         }\n         fields = dl_mysql_fetch_fields(sql->res);\n         for (i = 1; i <= total; i++)\n         {\n               for (j = sql->nf; j >= 1; j--)\n            {\n               if (strcmp(mpl_tab_get_name(dca, j), fields[i-1].name)\n                  == 0)\n               break;\n            }\n            sql->ref[i] = j;\n         }\n      }\n      else\n      {\n         if(dl_mysql_field_count(sql->con) == 0)\n            {\n            xprintf(\"db_mysql_open: Query was not a SELECT\\n\\\"%s\\\"\\n\",\n               query);\n            xprintf(\"%s\\n\",dl_mysql_error(sql->con));\n            xfree(query);\n            xfree(sql);\n            return NULL;\n         }\n         else\n         {\n            xprintf(\"db_mysql_open: Query\\n\\\"%s\\\"\\nfailed.\\n\", query);\n            xprintf(\"%s\\n\",dl_mysql_error(sql->con));\n            xfree(query);\n            xfree(sql);\n            return NULL;\n         }\n      }\n   }\n   else if ( sql->mode == 'W' )\n   {  for(j = 0; sqllines[j] != NULL; j++)\n         arg = (char *) sqllines[j];\n      if (  NULL != strchr(arg, '?') )\n      {\n         total = strlen(arg);\n         query = xmalloc( (total+1) * sizeof(char));\n         strcpy (query, arg);\n         }\n      else\n         query = db_generate_insert_stmt(dca);\n      sql->query = query;\n      xprintf(\"%s\\n\", query);\n   }\n   return sql;\n}\n\nint db_mysql_read(TABDCA *dca, void *link)\n{  struct db_mysql *sql;\n   char            buf[255+1];\n   char            **row;\n   unsigned long   *lengths;\n   MYSQL_FIELD     *fields;\n   double          num;\n   int             len;\n   unsigned long   num_fields;\n   int             i;\n\n   sql = (struct db_mysql *) link;\n\n   xassert(sql != NULL);\n   xassert(sql->mode == 'R');\n   if (NULL == sql->res)\n   {\n      xprintf(\"db_mysql_read: no result set available\");\n      return 1;\n   }\n   if (NULL==(row = (char **)dl_mysql_fetch_row(sql->res))) {\n       return -1; /*EOF*/\n   }\n   lengths = dl_mysql_fetch_lengths(sql->res);\n   fields = dl_mysql_fetch_fields(sql->res);\n   num_fields = dl_mysql_num_fields(sql->res);\n   for (i=1; i <= num_fields; i++)\n   {\n      if (row[i-1] != NULL)\n      {  len = (size_t) lengths[i-1];\n         if (len > 255)\n            len = 255;\n         strncpy(buf, (const char *) row[i-1], len);\n         buf[len] = 0x00;\n         if (0 != (fields[i-1].flags & NUM_FLAG))\n         {  strspx(buf); /* remove spaces*/\n            if (str2num(buf, &num) != 0)\n            {  xprintf(\"'%s' cannot be converted to a number.\\n\", buf);\n               return 1;\n            }\n            if (sql->ref[i] > 0)\n               mpl_tab_set_num(dca, sql->ref[i], num);\n         }\n         else\n         {  if (sql->ref[i] > 0)\n               mpl_tab_set_str(dca, sql->ref[i], strtrim(buf));\n         }\n      }\n   }\n   return 0;\n}\n\nint db_mysql_write(TABDCA *dca, void *link)\n{\n   struct db_mysql *sql;\n   char            *part;\n   char            *query;\n   char            *template;\n   char             num[50];\n   int              k;\n   int              len;\n   int              nf;\n\n   sql = (struct db_mysql *) link;\n   xassert(sql != NULL);\n   xassert(sql->mode == 'W');\n\n   len      = strlen(sql->query);\n   template = (char *) xmalloc( (len + 1) * sizeof(char) );\n   strcpy(template, sql->query);\n\n   nf = mpl_tab_num_flds(dca);\n   for (k = 1; k <= nf; k++)\n   {     switch (mpl_tab_get_type(dca, k))\n      {  case 'N':\n            len += 20;\n            break;\n         case 'S':\n            len += db_escaped_string_length(mpl_tab_get_str(dca, k));\n            len += 2;\n            break;\n              default:\n                        xassert(dca != dca);\n         }\n   }\n   query = xmalloc( (len + 1 ) * sizeof(char) );\n   query[0] = 0x00;\n   for (k = 1, part = strtok (template, \"?\"); (part != NULL);\n      part = strtok (NULL, \"?\"), k++)\n   {\n      if (k > nf) break;\n      strcat( query, part );\n      switch (mpl_tab_get_type(dca, k))\n      {  case 'N':\n#if 0 /* 02/XI-2010 by xypron */\n            sprintf(num, \"%-18g\",mpl_tab_get_num(dca, k));\n#else\n            sprintf(num, \"%.*g\", DBL_DIG, mpl_tab_get_num(dca, k));\n#endif\n            strcat( query, num );\n            break;\n         case 'S':\n            strcat( query, \"'\");\n            db_escape_string( query + strlen(query),\n               mpl_tab_get_str(dca, k) );\n            strcat( query, \"'\");\n            break;\n              default:\n                        xassert(dca != dca);\n         }\n   }\n   if (part != NULL)\n      strcat(query, part);\n   if (dl_mysql_query(sql->con, query))\n   {\n      xprintf(\"db_mysql_write: Query\\n\\\"%s\\\"\\nfailed.\\n\", query);\n      xprintf(\"%s\\n\",dl_mysql_error(sql->con));\n      xfree(query);\n      xfree(template);\n      return 1;\n      }\n\n   xfree(query);\n   xfree(template);\n   return 0;\n   }\n\nint db_mysql_close(TABDCA *dca, void *link)\n{\n   struct db_mysql *sql;\n\n   sql = (struct db_mysql *) link;\n   xassert(sql != NULL);\n   dl_mysql_close(sql->con);\n   if ( sql->mode == 'W' )\n      xfree(sql->query);\n   xfree(sql);\n   dca->link = NULL;\n   return 0;\n}\n\n#endif\n\n/* eof */\n",
        "/tmp/vanessa/spack-stage/spack-stage-r-igraph-1.0.1-ilkfvz4bbtrxvmsc5vcghslxiqzaajlv/spack-src/src/glpk/glpenv.h": "/* glpenv.h (GLPK environment) */\n\n/***********************************************************************\n*  This code is part of GLPK (GNU Linear Programming Kit).\n*\n*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,\n*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.\n*  E-mail: <mao@gnu.org>.\n*\n*  GLPK is free software: you can redistribute it and/or modify it\n*  under the terms of the GNU General Public License as published by\n*  the Free Software Foundation, either version 3 of the License, or\n*  (at your option) any later version.\n*\n*  GLPK is distributed in the hope that it will be useful, but WITHOUT\n*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n*  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n*  License for more details.\n*\n*  You should have received a copy of the GNU General Public License\n*  along with GLPK. If not, see <http://www.gnu.org/licenses/>.\n***********************************************************************/\n\n#ifndef GLPENV_H\n#define GLPENV_H\n\n#include \"glpstd.h\"\n#include \"glplib.h\"\n\ntypedef struct ENV ENV;\ntypedef struct MEM MEM;\ntypedef struct XFILE XFILE;\n\n#define ENV_MAGIC 0x454E5631\n/* environment block magic value */\n\n#define TERM_BUF_SIZE 4096\n/* terminal output buffer size, in bytes */\n\n#define IOERR_MSG_SIZE 1024\n/* i/o error message buffer size, in bytes */\n\n#define MEM_MAGIC 0x4D454D31\n/* memory block descriptor magic value */\n\nstruct ENV\n{     /* environment block */\n      int magic;\n      /* magic value used for debugging */\n      char version[7+1];\n      /* version string returned by the routine glp_version */\n      /*--------------------------------------------------------------*/\n      /* terminal output */\n      char *term_buf; /* char term_buf[TERM_BUF_SIZE]; */\n      /* terminal output buffer */\n      int term_out;\n      /* flag to enable/disable terminal output */\n      int (*term_hook)(void *info, const char *s);\n      /* user-defined routine to intercept terminal output */\n      void *term_info;\n      /* transit pointer (cookie) passed to the routine term_hook */\n      FILE *tee_file;\n      /* output stream used to copy terminal output */\n      /*--------------------------------------------------------------*/\n      /* error handling */\n      const char *err_file;\n      /* value of the __FILE__ macro passed to glp_error */\n      int err_line;\n      /* value of the __LINE__ macro passed to glp_error */\n      void (*err_hook)(void *info);\n      /* user-defined routine to intercept abnormal termination */\n      void *err_info;\n      /* transit pointer (cookie) passed to the routine err_hook */\n      /*--------------------------------------------------------------*/\n      /* memory allocation */\n      glp_long mem_limit;\n      /* maximal amount of memory (in bytes) available for dynamic\n         allocation */\n      MEM *mem_ptr;\n      /* pointer to the linked list of allocated memory blocks */\n      int mem_count;\n      /* total number of currently allocated memory blocks */\n      int mem_cpeak;\n      /* peak value of mem_count */\n      glp_long mem_total;\n      /* total amount of currently allocated memory (in bytes; is the\n         sum of the size field over all memory block descriptors) */\n      glp_long mem_tpeak;\n      /* peak value of mem_total */\n      /*--------------------------------------------------------------*/\n      /* stream input/output */\n      XFILE *file_ptr;\n      /* pointer to the linked list of active stream descriptors */\n      char *ioerr_msg; /* char ioerr_msg[IOERR_MSG_SIZE]; */\n      /* input/output error message buffer */\n      /*--------------------------------------------------------------*/\n      /* shared libraries support */\n      void *h_odbc;\n      /* handle to ODBC shared library */\n      void *h_mysql;\n      /* handle to MySQL shared library */\n};\n\nstruct MEM\n{     /* memory block descriptor */\n      int flag;\n      /* descriptor flag */\n      int size;\n      /* size of block (in bytes, including descriptor) */\n      MEM *prev;\n      /* pointer to previous memory block descriptor */\n      MEM *next;\n      /* pointer to next memory block descriptor */\n};\n\nstruct XFILE\n{     /* input/output stream descriptor */\n      int type;\n      /* stream handle type: */\n#define FH_FILE   0x11  /* FILE   */\n#define FH_ZLIB   0x22  /* gzFile */\n      void *fh;\n      /* pointer to stream handle */\n      XFILE *prev;\n      /* pointer to previous stream descriptor */\n      XFILE *next;\n      /* pointer to next stream descriptor */\n};\n\n#define XEOF (-1)\n\n#define get_env_ptr _glp_get_env_ptr\nENV *get_env_ptr(void);\n/* retrieve pointer to environment block */\n\n#define tls_set_ptr _glp_tls_set_ptr\nvoid tls_set_ptr(void *ptr);\n/* store global pointer in TLS */\n\n#define tls_get_ptr _glp_tls_get_ptr\nvoid *tls_get_ptr(void);\n/* retrieve global pointer from TLS */\n\n#define xprintf glp_printf\nvoid glp_printf(const char *fmt, ...);\n/* write formatted output to the terminal */\n\n#define xvprintf glp_vprintf\nvoid glp_vprintf(const char *fmt, va_list arg);\n/* write formatted output to the terminal */\n\n#ifndef GLP_ERROR_DEFINED\n#define GLP_ERROR_DEFINED\ntypedef void (*_glp_error)(const char *fmt, ...);\n#endif\n\n#define xerror glp_error_(__FILE__, __LINE__)\n_glp_error glp_error_(const char *file, int line);\n/* display error message and terminate execution */\n\n#define xassert(expr) \\\n      ((void)((expr) || (glp_assert_(#expr, __FILE__, __LINE__), 1)))\nvoid glp_assert_(const char *expr, const char *file, int line);\n/* check for logical condition */\n\n#define xmalloc glp_malloc\nvoid *glp_malloc(int size);\n/* allocate memory block */\n\n#define xcalloc glp_calloc\nvoid *glp_calloc(int n, int size);\n/* allocate memory block */\n\n#define xfree glp_free\nvoid glp_free(void *ptr);\n/* free memory block */\n\n#define xtime glp_time\nglp_long glp_time(void);\n/* determine current universal time */\n\n#define xdifftime glp_difftime\ndouble glp_difftime(glp_long t1, glp_long t0);\n/* compute difference between two time values, in seconds */\n\n#define lib_err_msg _glp_lib_err_msg\nvoid lib_err_msg(const char *msg);\n\n#define xerrmsg _glp_lib_xerrmsg\nconst char *xerrmsg(void);\n\n#define xfopen _glp_lib_xfopen\nXFILE *xfopen(const char *fname, const char *mode);\n\n#define xferror _glp_lib_xferror\nint xferror(XFILE *file);\n\n#define xfeof _glp_lib_xfeof\nint xfeof(XFILE *file);\n\n#define xfgetc _glp_lib_xfgetc\nint xfgetc(XFILE *file);\n\n#define xfputc _glp_lib_xfputc\nint xfputc(int c, XFILE *file);\n\n#define xfflush _glp_lib_xfflush\nint xfflush(XFILE *fp);\n\n#define xfclose _glp_lib_xfclose\nint xfclose(XFILE *file);\n\n#define xfprintf _glp_lib_xfprintf\nint xfprintf(XFILE *file, const char *fmt, ...);\n\n#define xdlopen _glp_xdlopen\nvoid *xdlopen(const char *module);\n\n#define xdlsym _glp_xdlsym\nvoid *xdlsym(void *h, const char *symbol);\n\n#define xdlclose _glp_xdlclose\nvoid xdlclose(void *h);\n\n#endif\n\n/* eof */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-r-igraph-1.0.1-ilkfvz4bbtrxvmsc5vcghslxiqzaajlv/spack-src/src/NetRoutines.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-r-igraph-1.0.1-ilkfvz4bbtrxvmsc5vcghslxiqzaajlv/spack-src/src/pottsmodel_2.h",
        "/tmp/vanessa/spack-stage/spack-stage-r-igraph-1.0.1-ilkfvz4bbtrxvmsc5vcghslxiqzaajlv/spack-src/src/NetDataTypes.h",
        "/tmp/vanessa/spack-stage/spack-stage-r-igraph-1.0.1-ilkfvz4bbtrxvmsc5vcghslxiqzaajlv/spack-src/src/NetDataTypes.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-r-igraph-1.0.1-ilkfvz4bbtrxvmsc5vcghslxiqzaajlv/spack-src/src/NetRoutines.h",
        "/tmp/vanessa/spack-stage/spack-stage-r-igraph-1.0.1-ilkfvz4bbtrxvmsc5vcghslxiqzaajlv/spack-src/src/pottsmodel_2.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-r-igraph-1.0.1-ilkfvz4bbtrxvmsc5vcghslxiqzaajlv/spack-src/inst/igraph2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-r-igraph-1.0.1-ilkfvz4bbtrxvmsc5vcghslxiqzaajlv/spack-src/inst/igraph.gif",
        "/tmp/vanessa/spack-stage/spack-stage-r-igraph-1.0.1-ilkfvz4bbtrxvmsc5vcghslxiqzaajlv/spack-src/inst/tests/celegansneural.gml.gz",
        "/tmp/vanessa/spack-stage/spack-stage-r-igraph-1.0.1-ilkfvz4bbtrxvmsc5vcghslxiqzaajlv/spack-src/inst/tests/power.gml.gz",
        "/tmp/vanessa/spack-stage/spack-stage-r-igraph-1.0.1-ilkfvz4bbtrxvmsc5vcghslxiqzaajlv/spack-src/inst/tests/football.gml.gz",
        "/tmp/vanessa/spack-stage/spack-stage-r-igraph-1.0.1-ilkfvz4bbtrxvmsc5vcghslxiqzaajlv/spack-src/inst/tkigraph_help/tkigraph-main.gif"
    ],
    "total_files": 1366
}