{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rocm-opencl-3.9.0-aid4fe4bzxzmtnxmc7gl7shdijtrlayu/spack-src/amdocl/cl_gl_amd.hpp": "/* Copyright (c) 2010-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#ifndef CL_GL_AMD_HPP_\n#define CL_GL_AMD_HPP_\n\n#ifdef _WIN32\n#include <windows.h>\n#else //!_WIN32\n#include <dlfcn.h>\n#endif //!_WIN32\n\n#include <GL/gl.h>\n#include <GL/glext.h>\n#include \"CL/cl_gl.h\"\n#ifndef _WIN32\n#include <GL/glx.h>\n#endif //!_WIN32\n\n#include <EGL/egl.h>\n#include <EGL/eglext.h>\n#include <EGL/eglplatform.h>\n\n#include \"platform/context.hpp\"\n#include \"platform/command.hpp\"\n\nnamespace amd\n{\n\n//! Class GLObject keeps all the info about the GL object\n//! from which the CL object is created\nclass GLObject : public InteropObject\n{\nprotected:\n    cl_gl_object_type   clGLType_;  //!< CL GL object type\n    GLenum  glTarget_;\n    GLuint  gluiName_;\n    GLint   gliMipLevel_;\n    GLenum  glInternalFormat_;\n    GLint   gliWidth_;\n    GLint   gliHeight_;\n    GLint   gliDepth_;\n    GLenum  glCubemapFace_;\n    GLsizei glNumSamples_;\n\npublic:\n//! GLObject constructor initializes member variables\n    GLObject(\n        GLenum  glTarget,\n        GLuint  gluiName,\n        GLint   gliMipLevel,\n        GLenum  glInternalFormat,\n        GLint   gliWidth,\n        GLint   gliHeight,\n        GLint   gliDepth,\n        cl_gl_object_type   clGLType,\n        GLenum  glCubemapFace,\n        GLsizei glNumSamples\n    ): // Initialization of member variables\n            clGLType_(clGLType),\n            glTarget_(glTarget),\n            gluiName_(gluiName),\n            gliMipLevel_(gliMipLevel),\n            glInternalFormat_(glInternalFormat),\n            gliWidth_(gliWidth),\n            gliHeight_(gliHeight),\n            gliDepth_(gliDepth),\n            glCubemapFace_(glCubemapFace),\n            glNumSamples_(glNumSamples)\n    {\n    }\n\n    virtual ~GLObject() {}\n    virtual GLObject* asGLObject() {return this;}\n\n//! GLObject query functions to get GL info from member variables\n    GLenum  getGLTarget() const {return glTarget_;}\n    GLuint  getGLName() const {return gluiName_;}\n    GLint   getGLMipLevel() const {return gliMipLevel_;}\n    GLenum  getGLInternalFormat() const {return glInternalFormat_;}\n    GLint   getGLSize() const {return gliWidth_;}\n    GLint   getGLWidth() const {return gliWidth_;}\n    GLint   getGLHeight() const {return gliHeight_;}\n    GLint   getGLDepth() const {return gliDepth_;}\n    cl_gl_object_type getCLGLObjectType() const { return clGLType_; }\n    GLenum  getCubemapFace() const {return glCubemapFace_;}\n    GLsizei getNumSamples() const { return glNumSamples_;}\n};\n\n\n//! Class BufferGL is drived from classes Buffer and GLObject\n//! where the former keeps all data for CL object and\n//! the latter keeps all data for GL object\nclass BufferGL : public Buffer, public GLObject\n{\nprotected:\n    //! Initializes the device memory array which is nested\n    // after'BufferGL' object in memory layout.\n    virtual void initDeviceMemory();\npublic:\n//! BufferGL constructor just calls constructors of base classes\n//! to pass down the parameters\n    BufferGL(\n        Context&        amdContext,\n        cl_mem_flags    clFlags,\n        size_t          uiSizeInBytes,\n        GLenum          glTarget,\n        GLuint          gluiName)\n        : // Call base classes constructors\n            Buffer(\n                amdContext,\n                clFlags,\n                uiSizeInBytes\n            ),\n            GLObject(\n                glTarget,\n                gluiName,\n                0,                  // Mipmap level default\n                GL_ARRAY_BUFFER,    // Just init to some value\n                (GLint) uiSizeInBytes,\n                1,\n                1,\n                CL_GL_OBJECT_BUFFER,\n                0,\n                0\n            )\n    {\n        setInteropObj(this);\n    }\n    virtual ~BufferGL() {}\n\n    virtual BufferGL* asBufferGL() { return this; }\n};\n\n\n//! Class ImageGL is derived from classes Image and GLObject\n//! where the former keeps all data for CL object and\n//! the latter keeps all data for GL object\nclass ImageGL : public Image, public GLObject\n{\npublic:\n    //! ImageGL constructor just calls constructors of base classes\n    //! to pass down the parameters\n    ImageGL(\n        Context&            amdContext,\n        cl_mem_object_type  clType,\n        cl_mem_flags        clFlags,\n        const Format&       format,\n        size_t              width,\n        size_t              height,\n        size_t              depth,\n        GLenum              glTarget,\n        GLuint              gluiName,\n        GLint               gliMipLevel,\n        GLenum              glInternalFormat,\n        cl_gl_object_type   clGLType,\n        GLsizei             numSamples,\n        GLenum              glCubemapFace = 0)\n        : Image(amdContext, clType, clFlags, format, width, height, depth,\n            Format(format).getElementSize() * width,    \n            Format(format).getElementSize() * width * depth)\n        , GLObject(glTarget, gluiName, gliMipLevel, glInternalFormat,\n            static_cast<GLint>(width), static_cast<GLint>(height),\n            static_cast<GLint>(depth), clGLType, glCubemapFace,numSamples)\n    {\n        setInteropObj(this);\n    }\n\n    virtual ~ImageGL() {}\n\nprotected:\n    //! Initializes the device memory array which is nested\n    // after'BufferGL' object in memory layout.\n    virtual void initDeviceMemory();\n};\n\n#ifdef _WIN32\n#define APICALL WINAPI\n#define GETPROCADDRESS      GetProcAddress\n#define API_GETPROCADDR     \"wglGetProcAddress\"\n#define FCN_STR_TYPE        LPCSTR\n    typedef PROC (WINAPI* PFN_xxxGetProcAddress) (LPCSTR fcnName);\n    typedef HGLRC (APICALL* PFN_wglCreateContext) (HDC hdc);\n    typedef HGLRC (APICALL* PFN_wglGetCurrentContext) (void);\n    typedef HDC   (APICALL* PFN_wglGetCurrentDC) (void);\n    typedef BOOL  (APICALL* PFN_wglDeleteContext) (HGLRC hglrc);\n    typedef BOOL  (APICALL* PFN_wglMakeCurrent) (HDC hdc, HGLRC hglrc);\n    typedef BOOL  (APICALL* PFN_wglShareLists) (HGLRC hglrc1, HGLRC hglrc2);\n#else //!_WIN32\n#define APICALL // __stdcall   //??? todo odintsov\n#define API_GETPROCADDR     \"glXGetProcAddress\"\n#define GETPROCADDRESS      dlsym\n#define FCN_STR_TYPE        const GLubyte*\n#define WINAPI\n#define PROC void*\n    typedef void* (*PFN_xxxGetProcAddress) (const GLubyte* procName);\n    // X11 typedef\n    typedef Display* (*PFNXOpenDisplay)(_Xconst char* display_name );\n    typedef int (*PFNXCloseDisplay)(Display* display );\n\n    //glx typedefs\n    typedef GLXDrawable (*PFNglXGetCurrentDrawable)();\n    typedef Display* (*PFNglXGetCurrentDisplay)();\n    typedef GLXContext (*PFNglXGetCurrentContext)( void );\n    typedef XVisualInfo* (*PFNglXChooseVisual)(Display *dpy, int screen, int *attribList);\n    typedef GLXContext(*PFNglXCreateContext)(Display* dpy,XVisualInfo* vis,GLXContext shareList,Bool direct);\n    typedef void(*PFNglXDestroyContext)(Display* dpy, GLXContext ctx);\n    typedef Bool(*PFNglXMakeCurrent)( Display* dpy, GLXDrawable drawable, GLXContext ctx);\n    typedef void* HMODULE;\n#endif //!_WIN32\n\n#define GLPREFIX(rtype, fcn, dclargs) \\\n    typedef rtype (APICALL* PFN_##fcn) dclargs;\n\n// Declare prototypes for GL functions\n#include \"gl_functions.hpp\"\n\nclass GLFunctions\n{\npublic:\n    //! Locks any access to the virtual GPUs\n    class SetIntEnv : public amd::StackObject {\n    public:\n        //! Default constructor\n        SetIntEnv(GLFunctions* env);\n\n        //! Destructor\n        ~SetIntEnv();\n\n        //! Checks if the environment setup was successful\n        bool isValid() const { return isValid_; }\n\n    private:\n        GLFunctions*    env_;       //!< GL environment\n        bool            isValid_;   //!< If TRUE, then it's a valid setup\n    };\n\nprivate:\n    HMODULE libHandle_;\n    int missed_;    // Indicates how many GL functions not init'ed, if any\n\n    amd::Monitor lock_;\n\n    EGLDisplay eglDisplay_;\n    EGLContext eglOriginalContext_;\n    EGLContext eglInternalContext_;\n    EGLContext eglTempContext_;\n    bool isEGL_;\n\n#ifdef _WIN32\n    HGLRC       hOrigGLRC_;\n    HDC         hDC_;\n    HGLRC       hIntGLRC_;  // handle for internal GLRC to access shared context\n    HDC         tempDC_;\n    HGLRC       tempGLRC_;\n\n    PFN_wglCreateContext     wglCreateContext_;\n    PFN_wglGetCurrentContext wglGetCurrentContext_;\n    PFN_wglGetCurrentDC      wglGetCurrentDC_;\n    PFN_wglDeleteContext     wglDeleteContext_;\n    PFN_wglMakeCurrent       wglMakeCurrent_;\n    PFN_wglShareLists        wglShareLists_;\n#else\npublic:\n    Display*    Dpy_;\n    GLXDrawable Drawable_;\n    GLXContext  origCtx_;\n    Display*    intDpy_;\n    Window      intDrawable_;\n    GLXContext  intCtx_;\n    Display*    tempDpy_;\n    GLXDrawable tempDrawable_;\n    GLXContext  tempCtx_;\n\n    //pointers to X11 functions\n    PFNXOpenDisplay XOpenDisplay_;\n    PFNXCloseDisplay XCloseDisplay_;\n\n    //pointers to GLX functions\n    PFNglXGetCurrentDrawable glXGetCurrentDrawable_;\n    PFNglXGetCurrentDisplay glXGetCurrentDisplay_;\n    PFNglXGetCurrentContext glXGetCurrentContext_;\n    PFNglXChooseVisual glXChooseVisual_;\n    PFNglXCreateContext glXCreateContext_;\n    PFNglXDestroyContext glXDestroyContext_;\n    PFNglXMakeCurrent glXMakeCurrent_;\n#endif\npublic:\n\n    GLFunctions(HMODULE h, bool isEGL);\n    ~GLFunctions();\n\n    // Query CL-GL context association\n    bool isAssociated() const\n    {\n        if (isEGL_ && eglDisplay_ && eglOriginalContext_) return true;\n#ifdef _WIN32\n        if(hDC_ && hOrigGLRC_) return true;\n#else //!_WIN32\n        if(Dpy_ && origCtx_) return true;\n#endif //!_WIN32\n        return false;\n    }\n    bool isEGL() const\n    {\n        return isEGL_;\n    }\n    // Accessor methods\n#ifdef _WIN32\n    HGLRC getOrigGLRC() const {return hOrigGLRC_;}\n    HDC getDC() const {return hDC_;}\n    HGLRC getIntGLRC() const {return hIntGLRC_;}\n#else //!_WIN32\n    Display* getDpy() const {return Dpy_;}\n    GLXDrawable getDrawable() const {return Drawable_;}\n    GLXContext getOrigCtx() const {return origCtx_;}\n\n    Display* getIntDpy() const {return intDpy_;}\n    GLXDrawable getIntDrawable() const {return intDrawable_;}\n    GLXContext getIntCtx() const {return intCtx_;}\n\n    EGLDisplay getEglDpy() const { return eglDisplay_; }\n    EGLContext getEglOrigCtx() const { return eglOriginalContext_; }\n#endif //!_WIN32\n\n    // Initialize GL dynamic library and function pointers\n    bool init(intptr_t hdc, intptr_t hglrc);\n\n    // Return true if successful, false - if error occurred\n    bool setIntEnv();\n    bool restoreEnv();\n\n    amd::Monitor& getLock() { return lock_; }\n\n    PFN_xxxGetProcAddress GetProcAddress_;\n\n#define GLPREFIX(rtype, fcn, dclargs)   \\\n    PFN_##fcn fcn##_;\n// Declare pointers to GL functions\n#include \"gl_functions.hpp\"\n};\n\n//! Functions for executing the GL related stuff\ncl_mem clCreateFromGLBufferAMD(Context& amdContext, cl_mem_flags flags,\n    GLuint bufobj, cl_int* errcode_ret);\ncl_mem clCreateFromGLTextureAMD(Context& amdContext, cl_mem_flags flags,\n    GLenum target, GLint miplevel, GLuint texture, int* errcode_ret);\ncl_mem clCreateFromGLRenderbufferAMD(Context& amdContext, cl_mem_flags flags,\n    GLuint renderbuffer, int* errcode_ret);\n\nbool\ngetCLFormatFromGL(\n    const Context& amdContext,\n    GLint gliInternalFormat,\n    cl_image_format* pclImageFormat,\n    int* piBytesPerPixel,\n    cl_mem_flags flags\n);\n\n} //namespace amd\n\n#endif //CL_GL_AMD_HPP_\n",
        "/tmp/vanessa/spack-stage/spack-stage-rocm-opencl-3.9.0-aid4fe4bzxzmtnxmc7gl7shdijtrlayu/spack-src/amdocl/cl_icd.cpp": "/* Copyright (c) 2008-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#include \"cl_common.hpp\"\n#include \"vdi_common.hpp\"\n#ifdef _WIN32\n#include <d3d10_1.h>\n#include \"cl_d3d9_amd.hpp\"\n#include \"cl_d3d10_amd.hpp\"\n#include \"cl_d3d11_amd.hpp\"\n#endif  //_WIN32\n\n#include <icd/loader/icd_dispatch.h>\n\n#include <mutex>\n\namd::PlatformIDS amd::PlatformID::Platform =  //{ NULL };\n    {amd::ICDDispatchedObject::icdVendorDispatch_};\n\nstatic cl_int CL_API_CALL icdGetPlatformInfo(cl_platform_id platform, cl_platform_info param_name,\n                                             size_t param_value_size, void* param_value,\n                                             size_t* param_value_size_ret) {\n  return clGetPlatformInfo(NULL, param_name, param_value_size, param_value, param_value_size_ret);\n}\n\nstatic cl_int CL_API_CALL icdGetDeviceIDs(cl_platform_id platform, cl_device_type device_type,\n                                          cl_uint num_entries, cl_device_id* devices,\n                                          cl_uint* num_devices) {\n  return clGetDeviceIDs(NULL, device_type, num_entries, devices, num_devices);\n}\n\nstatic cl_int CL_API_CALL icdGetDeviceInfo(cl_device_id device, cl_device_info param_name,\n                                           size_t param_value_size, void* param_value,\n                                           size_t* param_value_size_ret) {\n  if (param_name == CL_DEVICE_PLATFORM) {\n    // Return the ICD platform instead of the default NULL platform.\n    cl_platform_id platform = reinterpret_cast<cl_platform_id>(&amd::PlatformID::Platform);\n    return amd::clGetInfo(platform, param_value_size, param_value, param_value_size_ret);\n  }\n\n  return clGetDeviceInfo(device, param_name, param_value_size, param_value, param_value_size_ret);\n}\n\ncl_icd_dispatch amd::ICDDispatchedObject::icdVendorDispatch_[] = {\n    {NULL /* should not get called */, icdGetPlatformInfo, icdGetDeviceIDs, icdGetDeviceInfo,\n     clCreateContext, clCreateContextFromType, clRetainContext, clReleaseContext, clGetContextInfo,\n     clCreateCommandQueue, clRetainCommandQueue, clReleaseCommandQueue, clGetCommandQueueInfo,\n     clSetCommandQueueProperty, clCreateBuffer, clCreateImage2D, clCreateImage3D, clRetainMemObject,\n     clReleaseMemObject, clGetSupportedImageFormats, clGetMemObjectInfo, clGetImageInfo,\n     clCreateSampler, clRetainSampler, clReleaseSampler, clGetSamplerInfo,\n     clCreateProgramWithSource, clCreateProgramWithBinary, clRetainProgram, clReleaseProgram,\n     clBuildProgram, clUnloadCompiler, clGetProgramInfo, clGetProgramBuildInfo, clCreateKernel,\n     clCreateKernelsInProgram, clRetainKernel, clReleaseKernel, clSetKernelArg, clGetKernelInfo,\n     clGetKernelWorkGroupInfo, clWaitForEvents, clGetEventInfo, clRetainEvent, clReleaseEvent,\n     clGetEventProfilingInfo, clFlush, clFinish, clEnqueueReadBuffer, clEnqueueWriteBuffer,\n     clEnqueueCopyBuffer, clEnqueueReadImage, clEnqueueWriteImage, clEnqueueCopyImage,\n     clEnqueueCopyImageToBuffer, clEnqueueCopyBufferToImage, clEnqueueMapBuffer, clEnqueueMapImage,\n     clEnqueueUnmapMemObject, clEnqueueNDRangeKernel, clEnqueueTask, clEnqueueNativeKernel,\n     clEnqueueMarker, clEnqueueWaitForEvents, clEnqueueBarrier, clGetExtensionFunctionAddress,\n     clCreateFromGLBuffer, clCreateFromGLTexture2D, clCreateFromGLTexture3D,\n     clCreateFromGLRenderbuffer, clGetGLObjectInfo, clGetGLTextureInfo, clEnqueueAcquireGLObjects,\n     clEnqueueReleaseGLObjects, clGetGLContextInfoKHR,\n     WINDOWS_SWITCH(clGetDeviceIDsFromD3D10KHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10BufferKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10Texture2DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10Texture3DKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueAcquireD3D10ObjectsKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueReleaseD3D10ObjectsKHR, NULL), clSetEventCallback, clCreateSubBuffer,\n     clSetMemObjectDestructorCallback, clCreateUserEvent, clSetUserEventStatus,\n     clEnqueueReadBufferRect, clEnqueueWriteBufferRect, clEnqueueCopyBufferRect,\n     NULL, NULL, NULL, clCreateEventFromGLsyncKHR,\n\n     /* OpenCL 1.2*/\n     clCreateSubDevices, clRetainDevice, clReleaseDevice, clCreateImage,\n     clCreateProgramWithBuiltInKernels, clCompileProgram, clLinkProgram, clUnloadPlatformCompiler,\n     clGetKernelArgInfo, clEnqueueFillBuffer, clEnqueueFillImage, clEnqueueMigrateMemObjects,\n     clEnqueueMarkerWithWaitList, clEnqueueBarrierWithWaitList,\n     clGetExtensionFunctionAddressForPlatform, clCreateFromGLTexture,\n\n     WINDOWS_SWITCH(clGetDeviceIDsFromD3D11KHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11BufferKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11Texture2DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11Texture3DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromDX9MediaSurfaceKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueAcquireD3D11ObjectsKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueReleaseD3D11ObjectsKHR, NULL),\n\n     WINDOWS_SWITCH(clGetDeviceIDsFromDX9MediaAdapterKHR,\n                    NULL),  // KHRpfn_clGetDeviceIDsFromDX9MediaAdapterKHR\n                            // clGetDeviceIDsFromDX9MediaAdapterKHR;\n     WINDOWS_SWITCH(\n         clEnqueueAcquireDX9MediaSurfacesKHR,\n         NULL),  // KHRpfn_clEnqueueAcquireDX9MediaSurfacesKHR clEnqueueAcquireDX9MediaSurfacesKHR;\n     WINDOWS_SWITCH(\n         clEnqueueReleaseDX9MediaSurfacesKHR,\n         NULL),  // KHRpfn_clEnqueueReleaseDX9MediaSurfacesKHR clEnqueueReleaseDX9MediaSurfacesKHR;\n\n     NULL,\n     NULL, NULL, NULL,\n\n     clCreateCommandQueueWithProperties, clCreatePipe, clGetPipeInfo, clSVMAlloc, clSVMFree,\n     clEnqueueSVMFree, clEnqueueSVMMemcpy, clEnqueueSVMMemFill, clEnqueueSVMMap, clEnqueueSVMUnmap,\n     clCreateSamplerWithProperties, clSetKernelArgSVMPointer, clSetKernelExecInfo,\n     clGetKernelSubGroupInfo,\n     clCloneKernel,\n     clCreateProgramWithIL,\n     clEnqueueSVMMigrateMem,\n     clGetDeviceAndHostTimer,\n     clGetHostTimer,\n     clGetKernelSubGroupInfo,\n     clSetDefaultDeviceCommandQueue,\n\n     clSetProgramReleaseCallback,\n     clSetProgramSpecializationConstant }};\n\n#if defined(ATI_OS_WIN)\n#include <Shlwapi.h>\n\n#pragma comment(lib, \"shlwapi.lib\")\n\nstatic bool ShouldLoadPlatform() {\n  // Get the OpenCL ICD registry values\n  HKEY platformsKey = NULL;\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Khronos\\\\OpenCL\\\\Vendors\", 0, KEY_READ,\n                    &platformsKey) != ERROR_SUCCESS)\n    return true;\n\n  std::vector<std::string> registryValues;\n  DWORD dwIndex = 0;\n  while (true) {\n    char cszLibraryName[1024] = {0};\n    DWORD dwLibraryNameSize = sizeof(cszLibraryName);\n    DWORD dwLibraryNameType = 0;\n    DWORD dwValue = 0;\n    DWORD dwValueSize = sizeof(dwValue);\n\n    if (RegEnumValueA(platformsKey, dwIndex++, cszLibraryName, &dwLibraryNameSize, NULL,\n                      &dwLibraryNameType, (LPBYTE)&dwValue, &dwValueSize) != ERROR_SUCCESS)\n      break;\n    // Require that the value be a DWORD and equal zero\n    if (dwLibraryNameType != REG_DWORD || dwValue != 0) {\n      continue;\n    }\n    registryValues.push_back(cszLibraryName);\n  }\n  RegCloseKey(platformsKey);\n\n  HMODULE hm = NULL;\n  if (!GetModuleHandleExA(\n          GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n          (LPCSTR)&ShouldLoadPlatform, &hm))\n    return true;\n\n  char cszDllPath[1024] = {0};\n  if (!GetModuleFileNameA(hm, cszDllPath, sizeof(cszDllPath))) return true;\n\n  // If we are loaded from the DriverStore, then there should be a registry\n  // value matching our current module absolute path.\n  if (std::find(registryValues.begin(), registryValues.end(), cszDllPath) == registryValues.end())\n    return true;\n\n  LPSTR cszFileName;\n  char buffer[1024] = {0};\n  if (!GetFullPathNameA(cszDllPath, sizeof(buffer), buffer, &cszFileName)) return true;\n\n  // We found an absolute path in the registry that matched this DLL, now\n  // check if there is also an entry with the same filename.\n  if (std::find(registryValues.begin(), registryValues.end(), cszFileName) == registryValues.end())\n    return true;\n\n  // Lastly, check if there is a DLL with the same name in the System folder.\n  char cszSystemPath[1024] = {0};\n#if defined(ATI_BITS_32)\n  if (!GetSystemWow64DirectoryA(cszSystemPath, sizeof(cszSystemPath)))\n#endif  // defined(ATI_BITS_32)\n    if (!GetSystemDirectoryA(cszSystemPath, sizeof(cszSystemPath))) return true;\n\n  std::string systemDllPath;\n  systemDllPath.append(cszSystemPath).append(\"\\\\\").append(cszFileName);\n  if (!PathFileExistsA(systemDllPath.c_str())) {\n    return true;\n  }\n\n  // If we get here, then all 3 conditions are true:\n  // - An entry in the registry with an absolute path matches the current DLL\n  // - An entry in the registry with a relative path matches the current DLL\n  // - A DLL with the same name was found in the system directory\n  //\n  // We should not load this platform!\n\n  return false;\n}\n\n#else\n\n#include <dlfcn.h>\n\n// If there is only one platform, load it.\n// If there is more than one platform, only load platforms that have visible devices\n// If all platforms have no devices available, only load the PAL platform\nstatic bool ShouldLoadPlatform() {\n  bool shouldLoad = true;\n\n  if (!amd::Runtime::initialized()) {\n    amd::Runtime::init();\n  }\n  const int numDevices = amd::Device::numDevices(CL_DEVICE_TYPE_GPU, false);\n\n  void *otherPlatform = nullptr;\n  if (amd::IS_LEGACY) {\n    otherPlatform = dlopen(\"libamdocl64.so\", RTLD_LAZY);\n    if (otherPlatform != nullptr) { // Present platform exists\n      shouldLoad = numDevices > 0;\n    }\n  } else {\n    otherPlatform = dlopen(\"libamdocl-orca64.so\", RTLD_LAZY);\n    if (otherPlatform != nullptr) { // Legacy platform exists\n      // gcc4.8 doesn't support casting void* to a function pointer\n      // Work around this by creating a typedef untill we upgrade the compiler\n      typedef void*(*clGetFunctionAddress_t)(const char *);\n      typedef cl_int(*clIcdGetPlatformIDs_t)(cl_uint, cl_platform_id *, cl_uint *);\n\n      clGetFunctionAddress_t legacyGetFunctionAddress =\n        reinterpret_cast<clGetFunctionAddress_t>(dlsym(otherPlatform, \"clGetExtensionFunctionAddress\"));\n      clIcdGetPlatformIDs_t legacyGetPlatformIDs =\n        reinterpret_cast<clIcdGetPlatformIDs_t>(legacyGetFunctionAddress(\"clIcdGetPlatformIDsKHR\"));\n\n      cl_uint numLegacyPlatforms = 0;\n      legacyGetPlatformIDs(0, nullptr, &numLegacyPlatforms);\n\n      shouldLoad = (numDevices > 0) || (numLegacyPlatforms == 0);\n    }\n  }\n\n  if (otherPlatform != nullptr) {\n    dlclose(otherPlatform);\n  }\n\n  return shouldLoad;\n}\n\n#endif // defined(ATI_OS_WIN)\n\nCL_API_ENTRY cl_int CL_API_CALL clIcdGetPlatformIDsKHR(cl_uint num_entries,\n                                                       cl_platform_id* platforms,\n                                                       cl_uint* num_platforms) {\n  if (((num_entries > 0 || num_platforms == NULL) && platforms == NULL) ||\n      (num_entries == 0 && platforms != NULL)) {\n    return CL_INVALID_VALUE;\n  }\n\n  static bool shouldLoad = true;\n\n  static std::once_flag initOnce;\n  std::call_once(initOnce, [](){ shouldLoad = ShouldLoadPlatform(); });\n\n  if (!shouldLoad) {\n    *not_null(num_platforms) = 0;\n    return CL_SUCCESS;\n  }\n\n  if (!amd::Runtime::initialized()) {\n    amd::Runtime::init();\n  }\n\n  if (num_platforms != NULL && platforms == NULL) {\n    *num_platforms = 1;\n    return CL_SUCCESS;\n  }\n\n  assert(platforms != NULL && \"check the code above\");\n  *platforms = reinterpret_cast<cl_platform_id>(&amd::PlatformID::Platform);\n\n  *not_null(num_platforms) = 1;\n  return CL_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-rocm-opencl-3.9.0-aid4fe4bzxzmtnxmc7gl7shdijtrlayu/spack-src/tests/ocltst/env/ocltst.cpp": "/* Copyright (c) 2010-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n/////////////////////////////////////////////////////////////////////////////\n\n#include <CL/cl.h>\n\n#ifdef ATI_OS_WIN\n#include <windows.h>\n\n#include \"Window.h\"\ntypedef HMODULE ModuleHandle;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n\n#ifdef ATI_OS_LINUX\n#include <dlfcn.h>\ntypedef void* ModuleHandle;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n\n#include \"BaseTestImp.h\"\n#include \"Module.h\"\n#include \"OCLLog.h\"\n#include \"OCLTest.h\"\n#include \"OCLTestImp.h\"\n#include \"OCLTestList.h\"\n#include \"OCLWrapper.h\"\n#include \"Timer.h\"\n#include \"Worker.h\"\n#include \"getopt.h\"\n#include \"oclsysinfo.h\"\n#include \"pfm.h\"\n\n//! Including OCLutilities Thread utility\n#include \"OCL/Thread.h\"\n\n//! Lock that needs to be obtained to access the global\n//! module variable\nstatic OCLutil::Lock moduleLock;\n\n#include <assert.h>\n#include <stdio.h>\n\n#include <algorithm>\n#include <memory>\n#include <string>\n#include <vector>\n\n/////////////////////////////////////////////////////////////////////////////\n\n#ifdef ATI_OS_WIN\nstatic LONG WINAPI xFilter(LPEXCEPTION_POINTERS xEP);\nvoid serviceStubCall();\n#endif\n\n#define MAX_DEVICES 16\n#undef CHECK_RESULT\n#define CHECK_RESULT(test, msg) \\\n  if ((test)) {                 \\\n    printf(\"\\n%s\\n\", msg);      \\\n    exit(1);                    \\\n  }\n\n//! Declaration of a function that find devices of a specific type for the\n//! chosen platform\nint findAdapters(unsigned int platformIdx, bool useCPU, cl_platform_id*);\n\n//! class App that is used to run the tests on the system\nclass App {\n public:\n  static bool m_reRunFailed;\n  static bool m_svcMsg;\n  //! Constructor for App\n  App(unsigned int platform)\n      : m_list(false),\n        m_console(true),\n        m_useCPU(false),\n        m_dump(false),\n        m_perflab(false),\n        m_noSysInfoPrint(false),\n        m_numItr(1),\n        mp_testOrder(NULL),\n        m_rndOrder(false),\n        m_spawned(0),\n        m_threads(1),\n        m_runthread(0),\n        m_width(512),\n        m_height(512),\n        m_window(0),\n        m_platform(platform) {\n    // initialize OCLWrapper reference\n    m_wrapper = new OCLWrapper();\n\n    // m_workers = Set of worker objects that are used to run a subtest from a\n    // module\n    for (unsigned int i = 0; i < 256; i++) m_workers[i] = 0;\n\n    // Setting the number of devices\n    /*\n     * Force caltst to use 1 thread at a time in Windows\n     * only contextual calls are thread safe currently\n     */\n    m_numDevices = findAdapters(m_platform, m_useCPU, NULL);\n    // m_numDevices = 1;\n\n    // Report structure used to store the results of the tests\n#if 0\n            testReport = (Report **)malloc(sizeof(Report *) * m_numDevices);\n            for(unsigned int i = 0; i < m_numDevices; i++)\n            {\n                testReport[i] = new Report;\n            }\n#else\n    testReport = (Report**)malloc(sizeof(Report*));\n    testReport[0] = new Report;\n#endif\n  }\n\n  //! Destructor for App\n  ~App() {\n    // Deleting the Worker objects\n    for (unsigned int i = 0; i < 256; i++) {\n      if (m_workers[i]) {\n        delete m_workers[i];\n        m_workers[i] = 0;\n      }\n    }\n\n    // Deleting the report structures\n    // for(unsigned int i = 0; i < m_numDevices; i++)\n    for (unsigned int i = 0; i < 1; i++) {\n      delete testReport[i];\n    }\n    free(testReport);\n    m_wrapper->clUnloadPlatformAMD(mpform_id);\n\n    delete m_wrapper;\n  }\n\n  //! Function used to create a worker object corresponding to a subtest in a\n  //! module\n  void SetWorker(unsigned int index, OCLWrapper* wrapper, Module* module,\n                 TestMethod run, unsigned int id, unsigned int subtest,\n                 unsigned int test, bool dump, bool view, bool useCPU,\n                 void* window, unsigned int x, unsigned int y, bool perflab,\n                 unsigned int deviceId, unsigned int platform) {\n    if (index >= 256) return;\n\n    if (m_workers[index]) delete m_workers[index];\n\n    m_workers[index] =\n        new Worker(wrapper, module, run, id, subtest, test, dump, view, useCPU,\n                   window, x, y, perflab, deviceId, platform);\n\n    assert(m_workers[index] != 0);\n    // oclTestLog(OCLTEST_LOG_ALWAYS, \"Worker Device Id = %d\\n\",\n    // m_workers[index]->getDeviceId());\n  }\n\n  //! Function to return the 'index'th m_workers\n  Worker* GetWorker(unsigned int index) {\n    if (index >= 256) return 0;\n\n    return m_workers[index];\n  }\n\n  //! Create a thread to run the subtest\n  void AddThread(unsigned int workerindex, unsigned int usage) {\n    Worker* worker = GetWorker(workerindex);\n    if (worker == 0) {\n      return;\n    }\n\n    // usage = Whether to use threads or not\n    if (usage != 0) {\n      // Creating a thread\n      // getTestMethod = runSubTest here\n      // which takes a Worker object as an argument\n      m_pool[workerindex].create(worker->getTestMethod(), (void*)(worker));\n      m_spawned++;\n    } else {\n      // Same as above without using threads\n      TestMethod run = worker->getTestMethod();\n      if (run) {\n        run(worker);\n        UpdateTestReport(workerindex, worker->getResult());\n      }\n    }\n    return;\n  }\n\n  //! Function which waits for all threads to execute and also updates the\n  //! report\n  void WaitAllThreads() {\n    for (unsigned int w = 0; w < m_spawned; w++) {\n      m_pool[w].join();\n      UpdateTestReport(w, m_workers[w]->getResult());\n    }\n    m_spawned = 0;\n  }\n\n  //! Function to add a worker thread so as to run a subtest of a module\n  //! @param run = runSubtest function\n  //! @param index = index of the module in m_modules\n  //! @param subtest = the subtest number to run\n  //! @param usage = whether to use threads or not\n  //! @param test = The test in the module to be executed\n  void AddWorkerThread(unsigned int index, unsigned int subtest,\n                       unsigned int test, unsigned int usage, TestMethod run) {\n    if (m_spawned > m_threads) {\n      WaitAllThreads();\n    }\n\n    // Creating a worker thread for each device\n#if 0\n            for(unsigned int i = 0; i < m_numDevices; i++)\n            {\n                SetWorker(i,\n                          m_wrapper,\n                          &m_modules[index],\n                          run,\n                          m_spawned,\n                          subtest,\n                          test,\n                          m_dump,\n                          !m_console,\n                          m_useCPU,\n                          m_window,\n                          m_width,\n                          m_height,\n                          m_perflab,\n                          i,\n                          m_platform);            \n            }\n#else\n    for (unsigned int i = 0; i < 1; i++) {\n      SetWorker(i, m_wrapper, &m_modules[index], run, m_spawned, subtest, test,\n                m_dump, !m_console, m_useCPU, m_window, m_width, m_height,\n                m_perflab, m_deviceId, m_platform);\n    }\n#endif\n\n    // Creating and executing a thread for each device\n    // for(unsigned int i = 0; i < m_numDevices; i++)\n    for (unsigned int i = 0; i < 1; i++) {\n      AddThread(i, usage);\n    }\n  }\n\n  void printOCLinfo(void);\n\n  //! Function to process the commandline arguments\n  void CommandLine(unsigned int argc, char** argv);\n\n  //! Function to scan for the different tests in the module\n  void ScanForTests();\n\n  //! Function to run all the specified tests\n  void RunAllTests();\n\n  //! Free memory\n  void CleanUp();\n\n  //! Function to set the order in which test are executed.\n  void SetTestRunOrder(int);\n\n  //! Function to print the test order\n  void PrintTestOrder(int);\n\n  //! Function to get the number of iterations.\n  int GetNumItr(void) { return m_numItr; }\n\n private:\n  typedef std::vector<unsigned int> TestIndexList;\n  typedef std::vector<std::string> StringList;\n\n  void AddToList(StringList& strlist, const char* str);\n  void LoadList(StringList& strlist, const char* filename);\n\n  bool TestInList(StringList& strlist, const char* testname);\n\n  //! Array storing the report for each device\n  Report** testReport;\n\n  //! Function to update the result of each device\n  void UpdateTestReport(int index, TestResult* result) {\n    if (result != NULL) {\n      if (result->passed) {\n        if (testReport[index]->max->value < result->value) {\n          testReport[index]->max->value = result->value;\n          testReport[index]->max->resultString = result->resultString;\n        }\n        if (testReport[index]->min->value > result->value) {\n          testReport[index]->min->value = result->value;\n          testReport[index]->min->resultString = result->resultString;\n        }\n      } else {\n        testReport[index]->numFailedTests++;\n        testReport[index]->success = false;\n      }\n    } else {\n      testReport[index]->numFailedTests++;\n      testReport[index]->success = false;\n    }\n  }\n\n  //! Functions used to find the range of the tests to be run\n  void GetTestIndexList(TestIndexList& testIndices, StringList& testList,\n                        const char* szModuleTestname, int maxIndex);\n  void PruneTestIndexList(TestIndexList& testIndices,\n                          TestIndexList& avoidIndices,\n                          TestIndexList& erasedIndices);\n\n  StringList m_paths;\n  StringList m_tests;\n  StringList m_avoid;\n  std::vector<Module> m_modules;\n  bool m_list;\n  bool m_console;\n  bool m_useCPU;\n  bool m_dump;\n  bool m_perflab;\n  bool m_noSysInfoPrint;\n  int m_numItr;\n  int* mp_testOrder;\n  bool m_rndOrder;\n\n  //! m_pool = Various threads created to execute tests on multiple devices\n  OCLutil::Thread m_pool[256];\n\n  Worker* m_workers[256];\n\n  //! Number of threads spawned\n  unsigned int m_spawned;\n\n  //! Upper limit on the number of threads that can be spawned\n  unsigned int m_threads;\n  unsigned int m_runthread;\n  unsigned int m_width;\n  unsigned int m_height;\n  void* m_window;\n\n  //! which index/platform id from the platforms vector returned by\n  //! cl::Platform::get we should run on\n  unsigned int m_platform;\n  cl_platform_id mpform_id;\n\n  //! Number of devices on the system\n  unsigned int m_numDevices;\n  //\n  //! Device ID to use on the system\n  unsigned int m_deviceId;\n\n  // OCLWrapper reference\n  OCLWrapper* m_wrapper;\n};\n\nvoid App::printOCLinfo(void) {\n  std::string calinfo;\n  if (!m_noSysInfoPrint) {\n    oclSysInfo(calinfo, m_useCPU, m_deviceId, m_platform);\n    oclTestLog(OCLTEST_LOG_ALWAYS, calinfo.c_str());\n  }\n}\n\n/*-----------------------------------------------------\nFunction to randomize the order in which tests are executed\n-------------------------------------------------------*/\n#ifdef ATI_OS_WIN\n#include <time.h>\n#endif\n// void App::SetTestRunOrder(int test_count)\nvoid App::SetTestRunOrder(int mod_index) {\n  assert(mp_testOrder != NULL);\n  unsigned int test_count = m_modules[mod_index].get_count();\n\n  StringList uniqueTests;\n  for (unsigned int i = 0; i < m_tests.size(); ++i) {\n    // see if the tests are being run using indices\n    size_t nFirstBracket = m_tests[i].find(\"[\");\n    // set the test name\n    std::string szTestName = m_tests[i];\n\n    // order of execution is set based on base name so get the base name\n    if (nFirstBracket != std::string::npos)\n      szTestName = szTestName.substr(0, nFirstBracket);\n\n    bool bTestExists = false;\n    for (unsigned int j = 0; j < uniqueTests.size(); ++j) {\n      if (strcmp(szTestName.c_str(), uniqueTests[j].c_str()) == 0) {\n        bTestExists = true;\n        break;\n      }\n    }\n\n    if (!bTestExists) {\n      AddToList(uniqueTests, szTestName.c_str());\n    }\n  }\n\n  for (unsigned int i = 0; i < test_count && i < uniqueTests.size(); i++) {\n    for (unsigned int j = 0; j < test_count; j++) {\n      unsigned int index = i;\n      // add all the prev test indices\n      for (int k = 0; k < mod_index; k++) index += m_modules[k].get_count();\n\n      std::string szTestName = uniqueTests[index];\n\n      if (strcmp(szTestName.c_str(), m_modules[mod_index].get_name(j)) == 0) {\n        mp_testOrder[i] = j;\n        break;\n      }\n    }\n  }\n\n  if (m_rndOrder) {\n    srand((unsigned int)time(NULL));\n    for (unsigned int i = 0; i < test_count; i++) {\n      // find two random indices\n      int index1 = (int)((float)test_count * (rand() / (RAND_MAX + 1.0)));\n      int index2 = (int)((float)test_count * (rand() / (RAND_MAX + 1.0)));\n      // swap the data\n      int tmp = mp_testOrder[index1];\n      mp_testOrder[index1] = mp_testOrder[index2];\n      mp_testOrder[index2] = tmp;\n    }\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\n// Process device string. Returns true if there is a primary ATI Radeon device\n// adapter, false otherwise\nstatic bool procDevString(const char* devString) {\n  // Search for the string \"Radeon\" inside the device string\n  if (strstr(devString, \"Radeon\") || strstr(devString, \"R600\") ||\n      strstr(devString, \"RV630\") || strstr(devString, \"RV670\") ||\n      (strstr(devString, \"Stream\") && strstr(devString, \"Processor\"))) {\n    // Ignore if the device is a secondary device, i.e., not an adapter\n    if (strstr(devString, \"Secondary\")) {\n      return false;\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n}\n\n//!\n//! Function to find the total number of adapters on the system\n//!\nint findAdapters(unsigned int platformIdx, bool useCPU,\n                 cl_platform_id* mpform) {\n  unsigned int numOfAdapters = 0;\n  cl_int error = 0;\n  cl_uint numPlatforms = 0;\n\n  error = clGetPlatformIDs(0, NULL, &numPlatforms);\n  CHECK_RESULT((error != CL_SUCCESS), \"clGetPlatformIDs failed\");\n\n  CHECK_RESULT((platformIdx >= numPlatforms), \"Invalid platform\");\n\n  cl_platform_id* platforms = new cl_platform_id[numPlatforms];\n  error = clGetPlatformIDs(numPlatforms, platforms, NULL);\n  CHECK_RESULT(error != CL_SUCCESS, \"clGetPlatformIDs failed\");\n\n  cl_platform_id platform = 0;\n\n  platform = platforms[platformIdx];\n\n  delete[] platforms;\n\n  cl_device_type devType = CL_DEVICE_TYPE_GPU;\n  if (useCPU) devType = CL_DEVICE_TYPE_CPU;\n  error = clGetDeviceIDs(platform, devType, 0, 0, &numOfAdapters);\n  CHECK_RESULT((error != CL_SUCCESS), \"clGetDeviceIDs failed\");\n  if (mpform) {\n    (*mpform) = platform;\n  }\n\n  return (int)numOfAdapters;\n}\n\nint calibrate(OCLTest* test) {\n  int n = 1;\n\n#if 0\n    while (1)\n    {\n        double timer = run(test, n);\n        if (timer > 2.)\n        {\n            break;\n        }\n        n *= 2;\n    }\n#endif\n\n  return n;\n}\n\nvoid* dummyThread(void* argv) {\n  unsigned int counter = 0;\n  while (counter < 1000000) counter++;\n\n  return argv;\n}\n\n//! Function used to run the test specified\n//! It would look something like OCLPerfInputspeed[0]\ndouble run(OCLTest* test, int passes) {\n  CPerfCounter counter;\n\n  counter.Reset();\n  counter.Start();\n  int i;\n  for (i = 0; i < passes; i++) {\n    test->run();\n  }\n  counter.Stop();\n  double timer = counter.GetElapsedTime();\n  counter.Reset();\n\n  return timer;\n}\n\n//! Function to display the result after a test is finished\n//! It also stores the result in a TestResult object\nvoid report(Worker* w, const char* testname, int testnum, unsigned int crc,\n            const char* errorMsg, float timer, TestResult* tr,\n            const char* testDesc) {\n  unsigned int thread = w->getId();\n  bool perflab = w->getPerflab();\n  unsigned int deviceId = w->getDeviceId();\n\n  char tmpUnits[256];\n  if (perflab) {\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"%10.3f\\n\", timer);\n  } else {\n    const char* passedOrFailed[] = {\"FAILED\", \"PASSED\"};\n\n    // char teststring[256];\n    // sprintf(teststring, \"%s[%d]\", testname, testnum);\n    // sprintf(tmpUnits, \"Device[%d]:\\t%-32s:\\t%s\\n\", deviceId, teststring,\n    // ((tr->passed) ? passedOrFailed[1] : passedOrFailed[0]));\n    // If crc is not 0 or errorMsg is not empty, print the full stats\n    if ((crc != 0) || (errorMsg && (errorMsg[0] != '\\0'))) {\n      sprintf(tmpUnits,\n              \"%s %s: %s[%d] T[%1d] [%3d], %10.3f %-20s (chksum 0x%08x)\\n\",\n              testDesc, ((tr->passed) ? passedOrFailed[1] : passedOrFailed[0]),\n              w->isCPUEnabled() ? \"CPU\" : \"GPU\", deviceId, thread, testnum,\n              timer, errorMsg, crc);\n    } else {\n      sprintf(tmpUnits, \"%s %s: %s[%d] T[%1d] [%3d], %10.3f\\n\", testDesc,\n              ((tr->passed) ? passedOrFailed[1] : passedOrFailed[0]),\n              w->isCPUEnabled() ? \"CPU\" : \"GPU\", deviceId, thread, testnum,\n              timer);\n    }\n\n    oclTestLog(OCLTEST_LOG_ALWAYS, tmpUnits);\n\n    tr->value = timer;\n    tr->resultString.assign(tmpUnits);\n\n    if (App::m_svcMsg && !tr->passed) {\n      char escaped[2 * sizeof(tmpUnits)];\n\n      char* ptr = escaped;\n      for (int i = 0; tmpUnits[i] != '\\0'; ++i) {\n        switch (tmpUnits[i]) {\n          case '\\n':\n            *ptr++ = '|';\n            *ptr++ = 'n';\n            break;\n          case '\\r':\n            *ptr++ = '|';\n            *ptr++ = 'r';\n            break;\n          case '\\'':\n          case '|':\n          case ']':\n          case '[':\n            *ptr++ = '|';\n          default:\n            *ptr++ = tmpUnits[i];\n        }\n      }\n      *ptr = '\\0';\n\n      oclTestLog(OCLTEST_LOG_ALWAYS,\n                 \"##teamcity[testFailed name='%s.%s.%d' message='FAILED' \"\n                 \"details='%s']\\n\",\n                 w->getModule()->get_libname(), testname, testnum, escaped);\n    }\n  }\n}\n\n//! Thread Entry point\nvoid* runSubtest(void* worker) {\n  char units[256];\n  double conversion;\n  unsigned int crc = 0;\n  bool second_run = false;\n\n  // Getting the worker object that is running in this thread\n  Worker* w = (Worker*)worker;\n\n  if (w == 0) return NULL;\n\n  unsigned int test = w->getTestIndex();\n  unsigned int subtest = w->getSubTest();\n  unsigned int deviceId = w->getDeviceId();\n  unsigned int platformIndex = w->getPlatformID();\n  TestResult* result = w->getResult();\n\nRERUN_TEST:\n  // Acquiring lock on the 'module' object common to all threads\n  moduleLock.lock();\n  Module* m = w->getModule();\n  if (m == 0 || m->create_test == 0) return NULL;\n  // If we can, used the cached version,\n  // otherwise create the test.\n  OCLTest* pt = (m->cached_test ? m->cached_test[subtest] : NULL);\n  if (!pt) {\n    pt = m->create_test(subtest);\n    if (pt->cache_test() && m->cached_test) {\n      m->cached_test[subtest] = pt;\n    }\n  }\n  pt->clearError();\n  OCLTestImp* tmp = pt->toOCLTestImp();\n  if (tmp) {\n    tmp->setOCLWrapper(w->getOCLWrapper());\n  }\n  std::string subtestName = m->get_name(subtest);\n  moduleLock.unlock();\n\n  if (pt == 0) return NULL;\n\n  pt->resetDescString();\n  if (App::m_svcMsg) {\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"##teamcity[testStarted name='%s.%s.%d' \"\n               \"captureStandardOutput='true']\\n\",\n               m->get_libname(), subtestName.c_str(), test);\n  }\n  // setting the type to CPU.\n  if (w->isCPUEnabled()) {\n    pt->useCPU();\n  }\n  // Setting the device according to the worker thread\n  pt->setDeviceId(w->getDeviceId());\n  pt->setPlatformIndex(w->getPlatformID());\n  // Opening the 'test'th subtest of 'pt'\n  pt->open(test, units, conversion, deviceId);\n  pt->clearPerfInfo();\n\n  char buffer[256];\n  sprintf(buffer, \"%s[%3d]\", subtestName.c_str(), test);\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"%-32s\", buffer);\n\n  if (pt->hasErrorOccured()) {\n    result->passed = false;\n    report(w, subtestName.c_str(), test, crc, pt->getErrorMsg(),\n           pt->getPerfInfo(), result, pt->testDescString.c_str());\n  } else {\n    unsigned int n = calibrate(pt);\n    double timer = run(pt, n);\n    crc = pt->close();\n\n    if (pt->hasErrorOccured()) {\n      // run second time if the test fails the first time.\n      if (!second_run && App::m_reRunFailed && !App::m_svcMsg) {\n        second_run = true;\n\n        // Destroying a test object\n        moduleLock.lock();\n        if (!pt->cache_test()) {\n          m->destroy_test(pt);\n        }\n        moduleLock.unlock();\n\n        pt->clearError();\n        goto RERUN_TEST;\n      }\n    }\n    result->passed = !pt->hasErrorOccured();\n    /// print conditional pass if it is passes the second time.\n    if (second_run && result->passed) {\n      report(w, subtestName.c_str(), test, crc, \"Conditional PASS\",\n             pt->getPerfInfo(), result, pt->testDescString.c_str());\n    } else {\n      report(w, subtestName.c_str(), test, crc, pt->getErrorMsg(),\n             pt->getPerfInfo(), result, pt->testDescString.c_str());\n    }\n  }\n  if (App::m_svcMsg) {\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"##teamcity[testFinished name='%s.%s.%d']\\n\",\n               m->get_libname(), subtestName.c_str(), test);\n  }\n\n  // Make sure we clear the error after we report that there was an error.\n  pt->clearError();\n\n  // Destroying a test object\n  moduleLock.lock();\n  if (!pt->cache_test()) {\n    m->destroy_test(pt);\n  }\n  moduleLock.unlock();\n  return NULL;\n}\n\nvoid App::PrintTestOrder(int mod_index) {\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"Module: %s (%d tests)\\n\",\n             m_modules[mod_index].name.c_str(),\n             m_modules[mod_index].get_count());\n\n  for (unsigned int j = 0; j < m_modules[mod_index].get_count(); j++) {\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"%s\\n\",\n               m_modules[mod_index].get_name(mp_testOrder[j]));\n  }\n}\n\n//! Function that runs all the tests specified in the command-line\nvoid App::RunAllTests() {\n#ifdef ATI_OS_WIN\n\n  if (!m_console) m_window = new Window(\"Test\", 100, 100, m_width, m_height, 0);\n#endif\n\n  //\n  //  Add all tests to run list if none specified\n  //\n  if (m_tests.size() < 1) {\n    for (unsigned int i = 0; i < m_modules.size(); i++) {\n      for (unsigned int j = 0; j < m_modules[i].get_count(); j++) {\n        AddToList(m_tests, m_modules[i].get_name(j));\n      }\n    }\n  }\n\n  unsigned int num_passes = 0;\n  unsigned int num_failures = 0;\n\n  if (App::m_svcMsg) {\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"##teamcity[testSuiteStarted name='ocltst']\\n\");\n  }\n\n  //\n  //  Run each test\n  //\n  for (unsigned int i = 0; i < m_modules.size(); i++) {\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"\\n-------------------------------------------------\\n\");\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"The OpenCL Testing Module %s Version = %d \\n\",\n               m_modules[i].get_libname(), m_modules[i].get_version());\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"------------------------------\\n\");\n\n    // array to keep track of order of test execution.\n    int test_count = m_modules[i].get_count();\n    mp_testOrder = new int[test_count];\n    memset((void*)mp_testOrder, 0, sizeof(*mp_testOrder) * test_count);\n    SetTestRunOrder(i);\n\n    //\n    //  List all tests first if the option was turned on\n    //\n    if (m_list) {\n      PrintTestOrder(i);\n      delete[] mp_testOrder;\n      continue;\n      // return;\n    }\n\n    for (unsigned int itr_var = 0; itr_var < m_modules[i].get_count();\n         itr_var++) {\n      // done for random order generation\n      unsigned int subtest = mp_testOrder[itr_var];\n\n      const char* name = m_modules[i].get_name(subtest);\n      if (itr_var < m_tests.size() && TestInList(m_tests, name)) {\n        OCLTest* pt = NULL;\n        if (m_modules[i].cached_test) {\n          pt = m_modules[i].cached_test[subtest];\n        }\n        // Try to use the cached version first!\n        if (!pt) {\n          pt = m_modules[i].create_test(subtest);\n          if (pt->cache_test() && m_modules[i].cached_test) {\n            m_modules[i].cached_test[subtest] = pt;\n          }\n        }\n\n        int numSubTests = pt->getNumSubTests();\n        assert(numSubTests > 0);\n\n        TestIndexList testIndices;\n        GetTestIndexList(testIndices, m_tests, name, numSubTests - 1);\n\n        TestIndexList avoidIndices;\n        GetTestIndexList(avoidIndices, m_avoid, name, numSubTests - 1);\n\n        TestIndexList erasedIndices;\n        PruneTestIndexList(testIndices, avoidIndices, erasedIndices);\n\n        int numTestsRun = 0;\n        for (unsigned int j = 0; j < testIndices.size(); j++) {\n          unsigned int test = testIndices[j];\n\n          WaitAllThreads();\n          AddWorkerThread(i, subtest, test, pt->getThreadUsage(), runSubtest);\n\n          for (unsigned int thread = 1;\n               (thread < m_threads) && (thread < m_modules.size()); thread++) {\n            AddWorkerThread(thread, subtest, test, pt->getThreadUsage(),\n                            dummyThread);\n          }\n\n          numTestsRun++;\n        }\n\n        WaitAllThreads();\n        // Printing the test report\n        // First checking whether the number of subtests is greater than 1.\n        // No point printing report for a one subtest test\n\n        if (numTestsRun > 0) {\n          if (testReport[0]->success) {\n            num_passes++;\n          } else {\n            num_failures++;\n          }\n        }\n        if (App::m_svcMsg) {\n          for (unsigned int j = 0; j < erasedIndices.size(); j++) {\n            oclTestLog(OCLTEST_LOG_ALWAYS,\n                       \"##teamcity[testIgnored name='%s.%s.%d']\\n\",\n                       m_modules[i].get_libname(), name, erasedIndices[j]);\n          }\n        }\n\n        // Resetting the values of the test reports\n        // for(unsigned int j = 0; j < m_numDevices; j++)\n        for (unsigned int j = 0; j < 1; j++) {\n          testReport[j]->reset();\n        }\n        m_modules[i].destroy_test(pt);\n        if (m_modules[i].cached_test) {\n          m_modules[i].cached_test[subtest] = NULL;\n        }\n      }\n    }\n\n    // print the order in which the test are executed if they are\n    // randomized.\n    if (m_rndOrder) {\n      PrintTestOrder(i);\n    }\n    // deleting the test order\n    delete[] mp_testOrder;\n  }\n\n  if (App::m_svcMsg) {\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"##teamcity[testSuiteFinished name='ocltst']\\n\");\n  }\n\n#ifdef ATI_OS_WIN\n  if (!m_console && m_window) {\n    ((Window*)m_window)->ConsumeEvents();\n  }\n#endif\n  float total_tests = (float)(num_passes + num_failures);\n\n  float percent_passed = 0.0f;\n  float percent_failed = 0.0f;\n  float percent_total = 0.0f;\n  if (total_tests > 0) {\n    percent_passed = 100.0f * ((float)num_passes / total_tests);\n    percent_failed = 100.0f * ((float)num_failures / total_tests);\n    percent_total = 100.0f * ((float)total_tests / total_tests);\n  }\n\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"\\n\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"----------------------------------------\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"Total Passed Tests:  %8d (%6.2f%s)\\n\",\n             num_passes, percent_passed, \"%\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"Total Failed Tests:  %8d (%6.2f%s)\\n\",\n             num_failures, percent_failed, \"%\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"----------------------------------------\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"Total Run Tests:     %8d (%6.2f%s)\\n\",\n             (int)total_tests, percent_total, \"%\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"\\n\\n\");\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\nvoid App::AddToList(StringList& strlist, const char* str) {\n  std::string s(str);\n\n  strlist.push_back(s);\n}\n\nvoid App::LoadList(StringList& strlist, const char* filename) {\n  char buffer[1024];\n\n  FILE* fp = fopen(filename, \"r\");\n\n  if (fp == NULL) return;\n\n  while (fgets(buffer, 1000, fp) != NULL) {\n    size_t length = strlen(buffer);\n    if (length > 0) {\n      if (buffer[length - 1] != '\\n') {\n        length++;\n      }\n      buffer[length - 1] = 0;\n      AddToList(strlist, buffer);\n    }\n  }\n\n  fclose(fp);\n}\n\nstatic void Help(const char* name) {\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"%s (-w | -v | -m | -M | -l | -t | -T | -p | -d | -x | -y | -g| \"\n             \"-o | -n )\\n\",\n             name);\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"   -w            : enable window mode\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -v            : enable TeamCity service messages\\n\");\n  oclTestLog(\n      OCLTEST_LOG_ALWAYS,\n      \"   -d            : dump test output to portable float map (pfm)\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -m <module>   : specify a DLL module with tests\\n\");\n  oclTestLog(\n      OCLTEST_LOG_ALWAYS,\n      \"   -M <filename> : specify a text file with one DLL module per line\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -l            : list test names in DLL modules and exit\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -s <count>    : number of threads to spawn\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"   -t <testname> : run test\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -T <filename> : specify a text file with one test per line\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -a <testname> : specify a test to avoid\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -A <filename> : specify a text file of tests to avoid with \"\n             \"one test per line\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -p <platform> : specify a platform to run on, 'amd','nvidia' \"\n             \"or 'intel'\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"   -h            : this help text\\n\");\n  oclTestLog(\n      OCLTEST_LOG_ALWAYS,\n      \"   -x            : x dimension for debug output image (and window)\\n\");\n  oclTestLog(\n      OCLTEST_LOG_ALWAYS,\n      \"   -y            : y dimension for debug output image (and window)\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -P            : Perflab mode (just print the result without \"\n             \"any supplementary information)\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -n #number    : run the tests specified with -m, -M, -t or -T \"\n             \"options multiple times\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -r            : Option to Randomize the order in which the \"\n             \"tests are executed.\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -R            : Option to ReRun failed tests for conditional \"\n             \"pass.\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -i            : Don't print system information\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -g <GPUid>    : GPUid to run the tests on\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -o <filename> : dump the output to a specified file\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -c            : Run the test on the CPU device.\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"                 : \\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"                 : To run only one subtest of a test, append the \"\n             \"subtest to\\n\");\n  oclTestLog(\n      OCLTEST_LOG_ALWAYS,\n      \"                 : the end of the test name in brackets. i.e. test[1]\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"\\n\");\n\n  exit(0);\n}\n\nunsigned int getPlatformID(const char* str) {\n  std::string strOfCLVendor(str);\n  std::string strOfCLPlatformName;\n  unsigned int platform = 0;\n\n  // currently, the only input values amd,nvidia and intel are supported\n  if (strOfCLVendor == \"amd\") {\n    strOfCLPlatformName = \"Advanced Micro Devices, Inc.\";\n  } else if (strOfCLVendor == \"intel\") {\n    strOfCLPlatformName = \"Intel(R) Corporation\";\n  } else if (strOfCLVendor == \"nvidia\") {\n    strOfCLPlatformName = \"NVIDIA Corporation\";\n  } else {\n    // fall-back on platform index 0\n    return platform;\n  }\n\n  cl_int status;\n  cl_uint numPlatforms = 0;\n\n  status = clGetPlatformIDs(0, NULL, &numPlatforms);\n  if (status != CL_SUCCESS) {\n    return platform;\n  }\n\n  cl_platform_id* platforms = new cl_platform_id[numPlatforms];\n  status = clGetPlatformIDs(numPlatforms, platforms, NULL);\n\n  if (status == CL_SUCCESS) {\n    unsigned int i;\n    for (i = 0; i < numPlatforms; ++i) {\n      char buff[200];\n      status = clGetPlatformInfo(platforms[i], CL_PLATFORM_VENDOR, sizeof(buff),\n                                 buff, NULL);\n      if (status != CL_SUCCESS) {\n        break;\n      }\n      if (strcmp(buff, strOfCLPlatformName.c_str()) == 0) {\n        platform = i;\n        break;\n      }\n    }\n  }\n\n  delete[] platforms;\n  return platform;\n}\n\nunsigned int parseCommandLineForPlatform(unsigned int argc, char** argv) {\n  int c;\n  unsigned int platform = 0;\n\n  while ((c = getopt(argc, argv, \"dg:lm:M:o:Ps:t:T:a:A:p:v:wxy:in:rcRV\")) !=\n         -1) {\n    switch (c) {\n      case 'p':\n        platform = getPlatformID(optarg);\n        break;\n      default:\n        break;\n    }\n  }\n  return platform;\n}\n\nvoid App::CommandLine(unsigned int argc, char** argv) {\n  unsigned int i = 1;\n  int c;\n  bool hasOption = false;\n  unsigned int tmpNumDevices = 0;\n  unsigned int tmpDeviceId = 0;\n  m_deviceId = 0;\n  int tmp;\n\n  while ((c = getopt(argc, argv, \"dg:lm:M:o:Ps:t:T:a:A:p:v:wxy:in:rcRV\")) !=\n         -1) {\n    switch (c) {\n      case 'c':\n        m_useCPU = true;\n        break;\n\n      case 'p':\n        break;\n\n      case 'w':\n        m_console = false;\n        hasOption = true;\n        break;\n\n      case 'V':\n        m_svcMsg = true;\n        break;\n\n      case 'd':\n        m_dump = true;\n        hasOption = true;\n        break;\n\n      case 'm':\n        AddToList(m_paths, optarg);\n        hasOption = true;\n        break;\n\n      case 'M':\n        LoadList(m_paths, optarg);\n        hasOption = true;\n        break;\n\n      case 'a':\n        AddToList(m_avoid, optarg);\n        hasOption = true;\n        break;\n\n      case 'A':\n        LoadList(m_avoid, optarg);\n        hasOption = true;\n        break;\n\n      case 'l':\n        m_list = true;\n        hasOption = true;\n        break;\n\n      // command line switch to loop execution of any specified test or tests n\n      // number of times\n      case 'n':\n        m_numItr = atoi(optarg);\n        break;\n\n      // command line switch to randomize the order of test execution in OCLTest\n      case 'r':\n        m_rndOrder = true;\n        break;\n\n      // command line switch to rerun the failed tests to see if they pass on\n      // second run\n      case 'R': {\n        m_reRunFailed = true;\n        break;\n      }\n      case 't':\n        AddToList(m_tests, optarg);\n        hasOption = true;\n        break;\n\n      case 'T':\n        LoadList(m_tests, optarg);\n        hasOption = true;\n        break;\n\n      case 's':\n        m_threads = atoi(optarg);\n        hasOption = true;\n        break;\n\n      case 'h':\n        Help(argv[0]);\n        break;\n\n      case 'x':\n        m_width = atoi(optarg);\n        hasOption = true;\n        break;\n\n      case 'y':\n        m_height = atoi(optarg);\n        hasOption = true;\n        break;\n\n      case 'P':\n        m_perflab = true;\n        hasOption = true;\n        break;\n      case 'g':\n#if 0\n            tmpNumDevices = (unsigned int)atoi(optarg);\n            if(m_numDevices < tmpNumDevices)\n            {\n                oclTestLog(OCLTEST_LOG_ALWAYS, \"Number of Devices(%d) less than specified by the user(%d).  Using %d devices.\\n\", m_numDevices, tmpNumDevices, m_numDevices);\n            }\n            else\n            {\n                m_numDevices = tmpNumDevices;\n            }\n#else\n        tmpDeviceId = (unsigned int)atoi(optarg);\n#endif\n        break;\n      case 'v':\n        tmp = atoi(optarg);\n        if (tmp >= 0 && tmp < 100) {\n          oclTestSetLogLevel(atoi(optarg));\n        } else {\n          oclTestLog(OCLTEST_LOG_ALWAYS, \"Invalid verbose level\\n\");\n        }\n        break;\n      case 'o': {\n        hasOption = true;\n        oclTestEnableLogToFile(optarg);\n      } break;\n      case 'i':\n        m_noSysInfoPrint = true;\n        break;\n      default:\n        Help(argv[0]);\n        break;\n    }\n  }\n\n  // Reset devices in case user overrode defaults\n  m_numDevices = findAdapters(m_platform, m_useCPU, &mpform_id);\n  if (m_numDevices < (tmpDeviceId + 1)) {\n    m_deviceId = 0;\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"User specified deviceId(%d) exceedes the number of \"\n               \"Devices(%d).  Using device %d.\\n\",\n               tmpDeviceId, m_numDevices, m_deviceId);\n  } else {\n    m_deviceId = tmpDeviceId;\n  }\n\n  if (!hasOption) {\n    Help(argv[0]);\n  }\n}\n\nbool App::TestInList(StringList& strlist, const char* szModuleTestname) {\n  if (szModuleTestname == NULL) {\n    return false;\n  }\n  for (unsigned int i = 0; i < strlist.size(); i++) {\n    // check to see if an index is specified for this test name\n    int nIndex = -1;\n    std::string szTestName = strlist[i];\n    if (szTestName.find(\"[\") != std::string::npos) {\n      size_t nFirstBracket = szTestName.find(\"[\");\n      size_t nLastBracket = szTestName.find(\"]\");\n      if ((nFirstBracket != std::string::npos) &&\n          (nLastBracket != std::string::npos) &&\n          (nLastBracket > nFirstBracket)) {\n        szTestName = szTestName.substr(0, nFirstBracket);\n      }\n    }\n    if (strcmp(szModuleTestname, szTestName.c_str()) == 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvoid App::GetTestIndexList(TestIndexList& testIndices, StringList& testList,\n                           const char* szModuleTestname, int maxIndex) {\n  for (unsigned int i = 0; i < testList.size(); i++) {\n    IndicesRange nIndex = {0, maxIndex};\n\n    // If the test name string ends with [...] parse the text\n    // between the brackets to determine the index range.\n    std::string szTestName = testList[i];\n    if (szTestName.find(\"[\") != std::string::npos) {\n      size_t nFirstBracket = szTestName.find(\"[\");\n      size_t nLastBracket = szTestName.find(\"]\");\n      if ((nFirstBracket != std::string::npos) &&\n          (nLastBracket != std::string::npos) &&\n          (nLastBracket > nFirstBracket)) {\n        // Getting the string between the brackets '[' and ']'\n        // The values can be one of the following:-\n        // [a-b] - Run tests from a to b\n        // [a-] - Run tests from subtest a to subtest total_tests\n        // [-b] - Run tests from subtest 0 to subtest b\n        // a and b are indices of the tests to run\n\n        std::string nIndexString = szTestName.substr(\n            nFirstBracket + 1, nLastBracket - nFirstBracket - 1);\n        size_t nIntermediateHyphen = szTestName.find(\"-\");\n        if ((nIntermediateHyphen != std::string::npos) &&\n            (nIntermediateHyphen < nLastBracket) &&\n            (nIntermediateHyphen > nFirstBracket)) {\n          // Getting the start index\n          if ((nIntermediateHyphen - 1) == nFirstBracket) {\n            nIndex.startIndex = 0;\n          } else {\n            nIndex.startIndex =\n                atoi(szTestName\n                         .substr(nFirstBracket + 1,\n                                 nIntermediateHyphen - nFirstBracket - 1)\n                         .c_str());\n          }\n\n          // Getting the end index\n          if ((nIntermediateHyphen + 1) == nLastBracket) {\n            nIndex.endIndex = maxIndex;\n          } else {\n            nIndex.endIndex =\n                atoi(szTestName\n                         .substr(nIntermediateHyphen + 1,\n                                 nLastBracket - nIntermediateHyphen - 1)\n                         .c_str());\n          }\n        } else {\n          nIndex.startIndex = atoi(\n              szTestName\n                  .substr(nFirstBracket + 1, nLastBracket - nFirstBracket - 1)\n                  .c_str());\n          nIndex.endIndex = nIndex.startIndex;\n        }\n      }\n\n      szTestName = szTestName.substr(0, nFirstBracket);\n    }\n\n    if (strcmp(szModuleTestname, szTestName.c_str()) == 0) {\n      // If the values are out of order, swap them.\n      if (nIndex.startIndex > nIndex.endIndex) {\n        int tmp = nIndex.startIndex;\n        nIndex.startIndex = nIndex.endIndex;\n        nIndex.endIndex = tmp;\n      }\n\n      // Add the indices in the specified range to the list.\n      for (int i = nIndex.startIndex; i <= nIndex.endIndex; ++i) {\n        if (i <= maxIndex) {\n          testIndices.push_back(i);\n        } else {\n          oclTestLog(OCLTEST_LOG_ALWAYS,\n                     \"Error: Invalid test index for subtest: %s!\\n\",\n                     szModuleTestname);\n        }\n      }\n\n      // Now sort and prune duplicates.\n      std::sort(testIndices.begin(), testIndices.end());\n      std::unique(testIndices.begin(), testIndices.end());\n    }\n  }\n}\n\nvoid App::PruneTestIndexList(TestIndexList& testIndices,\n                             TestIndexList& avoidIndices,\n                             TestIndexList& erasedIndices) {\n  for (TestIndexList::iterator it = testIndices.begin();\n       it != testIndices.end();) {\n    unsigned int index = *it;\n    TestIndexList::iterator result =\n        std::find(avoidIndices.begin(), avoidIndices.end(), index);\n    if (result != avoidIndices.end()) {\n      it = testIndices.erase(it);\n      erasedIndices.push_back(index);\n    } else {\n      ++it;\n    }\n  }\n}\n\nvoid App::ScanForTests() {\n  for (unsigned int i = 0; i < m_paths.size(); i++) {\n    Module mod;\n\n#ifdef ATI_OS_WIN\n    std::string::iterator myIter;\n    myIter = m_paths[i].end();\n    myIter--;\n    if (*myIter == 0x0a) m_paths[i].erase(myIter);\n\n    mod.hmodule = LoadLibrary(m_paths[i].c_str());\n#endif\n#ifdef ATI_OS_LINUX\n    mod.hmodule = dlopen(m_paths[i].c_str(), RTLD_NOW);\n#endif\n\n    if (mod.hmodule == NULL) {\n      fprintf(stderr, \"Could not load module: %s\\n\", m_paths[i].c_str());\n#ifdef ATI_OS_LINUX\n      fprintf(stderr, \"Error : %s\\n\", dlerror());\n#else\n#endif\n    } else {\n      mod.name = m_paths[i];\n\n#ifdef ATI_OS_WIN\n      mod.get_count = (TestCountFuncPtr)GetProcAddress(mod.hmodule,\n                                                       \"OCLTestList_TestCount\");\n      mod.get_name =\n          (TestNameFuncPtr)GetProcAddress(mod.hmodule, \"OCLTestList_TestName\");\n      mod.create_test = (CreateTestFuncPtr)GetProcAddress(\n          mod.hmodule, \"OCLTestList_CreateTest\");\n      mod.destroy_test = (DestroyTestFuncPtr)GetProcAddress(\n          mod.hmodule, \"OCLTestList_DestroyTest\");\n      mod.get_version = (TestVersionFuncPtr)GetProcAddress(\n          mod.hmodule, \"OCLTestList_TestLibVersion\");\n      mod.get_libname = (TestLibNameFuncPtr)GetProcAddress(\n          mod.hmodule, \"OCLTestList_TestLibName\");\n#endif\n#ifdef ATI_OS_LINUX\n      mod.get_count =\n          (TestCountFuncPtr)dlsym(mod.hmodule, \"OCLTestList_TestCount\");\n      mod.get_name =\n          (TestNameFuncPtr)dlsym(mod.hmodule, \"OCLTestList_TestName\");\n      mod.create_test =\n          (CreateTestFuncPtr)dlsym(mod.hmodule, \"OCLTestList_CreateTest\");\n      mod.destroy_test =\n          (DestroyTestFuncPtr)dlsym(mod.hmodule, \"OCLTestList_DestroyTest\");\n      mod.get_version =\n          (TestVersionFuncPtr)dlsym(mod.hmodule, \"OCLTestList_TestLibVersion\");\n      mod.get_libname =\n          (TestLibNameFuncPtr)dlsym(mod.hmodule, \"OCLTestList_TestLibName\");\n#endif\n      mod.cached_test = new OCLTest*[mod.get_count()];\n      for (int x = 0, y = mod.get_count(); x < y; ++x) {\n        mod.cached_test[x] = NULL;\n      }\n      m_modules.push_back(mod);\n    }\n  }\n}\n\nvoid App::CleanUp() {\n  for (unsigned int i = 0; i < m_modules.size(); i++) {\n    if (m_modules[i].cached_test) {\n      delete[] m_modules[i].cached_test;\n    }\n#ifdef ATI_OS_WIN\n    FreeLibrary(m_modules[i].hmodule);\n#endif\n#ifdef ATI_OS_LINUX\n    dlclose(m_modules[i].hmodule);\n#endif\n  }\n\n#ifdef ATI_OS_WIN\n  if (m_window) delete m_window;\n  m_window = 0;\n#endif\n}\n\nextern int optind;\n/////////////////////////////////////////////////////////////////////////////\nbool App::m_reRunFailed = false;\nbool App::m_svcMsg = false;\nint main(int argc, char** argv) {\n  unsigned int platform = 0;\n  platform = parseCommandLineForPlatform(argc, argv);\n  // reset optind as we really didn't parse the full command line\n  optind = 0;\n  App app(platform);\n#ifdef ATI_OS_WIN\n  // this function is registers windows service routine when ocltst is launched\n  // by the OS on service initialization. On other scenarios, this function does\n  // nothing.\n  serviceStubCall();\n  // SetErrorMode(SEM_NOGPFAULTERRORBOX);\n  // const LPTOP_LEVEL_EXCEPTION_FILTER oldFilter =\n  // SetUnhandledExceptionFilter(xFilter);\n#endif  // ATI_OS_WIN\n#ifdef AUTO_REGRESS\n  try {\n#endif /* AUTO_REGRESS */\n    app.CommandLine(argc, argv);\n    app.printOCLinfo();\n    app.ScanForTests();\n    for (int i = 0; i < app.GetNumItr(); i++) {\n      app.RunAllTests();\n    }\n    app.CleanUp();\n#ifdef AUTO_REGRESS\n  } catch (...) {\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"Exiting due to unhandled exception!\\n\");\n    return (-1);\n  }\n#endif /* AUTO_REGRESS */\n\n  return 0;\n}\n\n#ifdef ATI_OS_WIN\n\n#include <dbghelp.h>\n\ntypedef unsigned int uint32;\ntypedef size_t uintp;\n\nstruct StackEntry {\n  uintp addr;\n  uint32 line;\n  uint32 disp;\n  char symbol[128];\n  char file[128];\n};\n\nstatic const unsigned int MAX_DEPTH_PER_NODE = 24;\nstruct Info {\n  bool operator==(const Info& b) const { return key == b.key; }\n\n  uintp key;  // pointer, handle, whatever\n  StackEntry stack[MAX_DEPTH_PER_NODE];\n};\n\nstatic void dumpTraceBack(CONTEXT& context) {\n  Info info;\n\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"Exception: exiting!\\n\");\n  HANDLE process = GetCurrentProcess();\n\n  STACKFRAME64 stackframe;\n  memset(&stackframe, 0, sizeof(STACKFRAME64));\n\n#if defined(_WIN64)\n  stackframe.AddrPC.Offset = context.Rip;\n  stackframe.AddrPC.Mode = AddrModeFlat;\n  stackframe.AddrStack.Offset = context.Rsp;\n  stackframe.AddrStack.Mode = AddrModeFlat;\n  stackframe.AddrFrame.Offset = context.Rbp;\n  stackframe.AddrFrame.Mode = AddrModeFlat;\n#else\n  stackframe.AddrPC.Offset = context.Eip;\n  stackframe.AddrPC.Mode = AddrModeFlat;\n  stackframe.AddrStack.Offset = context.Esp;\n  stackframe.AddrStack.Mode = AddrModeFlat;\n  stackframe.AddrFrame.Offset = context.Ebp;\n  stackframe.AddrFrame.Mode = AddrModeFlat;\n#endif\n  unsigned int depth = 0;\n\n  if (SymInitialize(process, NULL, true)) {\n    while ((depth < MAX_DEPTH_PER_NODE) &&\n           StackWalk64(IMAGE_FILE_MACHINE_I386, process, GetCurrentThread(),\n                       &stackframe, &context, NULL, SymFunctionTableAccess64,\n                       SymGetModuleBase64, NULL)) {\n      if (stackframe.AddrPC.Offset != 0) {\n        //\n        //  we don't want to evaluate the names/lines yet\n        //  so just record the address\n        //\n        info.stack[depth].addr = (uintp)stackframe.AddrPC.Offset;\n\n        DWORD64 disp64;\n        DWORD disp;\n        IMAGEHLP_SYMBOL64* symInfo;\n        IMAGEHLP_LINE64 lineInfo;\n        uintp addr = (uintp)stackframe.AddrPC.Offset;\n        char buffer[128];\n\n        symInfo = (IMAGEHLP_SYMBOL64*)&buffer[0];\n        symInfo->SizeOfStruct = sizeof(symInfo);\n        symInfo->MaxNameLength = (sizeof(buffer) - sizeof(IMAGEHLP_SYMBOL64));\n\n        lineInfo.SizeOfStruct = sizeof(lineInfo);\n\n        if (SymGetSymFromAddr64(process, addr, &disp64, symInfo)) {\n          sprintf(info.stack[depth].symbol, \"%s\", symInfo->Name);\n          info.stack[depth].disp = (uint32)disp64;\n        } else {\n          sprintf(info.stack[depth].symbol, \"\");\n        }\n\n        if (SymGetLineFromAddr64(process, addr, &disp, &lineInfo)) {\n          sprintf(info.stack[depth].file, \"%s\", lineInfo.FileName);\n          info.stack[depth].line = lineInfo.LineNumber;\n        } else {\n          info.stack[depth].file[0] = '\\0';\n        }\n        depth++;\n      }\n    }\n  }\n\n  SymCleanup(process);\n\n  int j = 0;\n  while (j < MAX_DEPTH_PER_NODE && info.stack[j].addr != 0) {\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"        %s()+%d (0x%.8x)  %s:%d\\n\",\n               info.stack[j].symbol, info.stack[j].disp, info.stack[j].addr,\n               info.stack[j].file, info.stack[j].line);\n\n    j++;\n  }\n}\n\nstatic LONG WINAPI xFilter(LPEXCEPTION_POINTERS xEP) {\n  CONTEXT context;\n  CONTEXT* xCtx = &context;\n  memset(xCtx, 0, sizeof(CONTEXT));\n  context.ContextFlags = CONTEXT_FULL;\n  memcpy(xCtx, xEP->ContextRecord, sizeof(CONTEXT));\n\n  dumpTraceBack(context);\n\n  return (EXCEPTION_EXECUTE_HANDLER);\n}\n#undef CHECK_RESULT\n#endif  // WIN_OS\n\n/////////////////////////////////////////////////////////////////////////////\n",
        "/tmp/vanessa/spack-stage/spack-stage-rocm-opencl-3.9.0-aid4fe4bzxzmtnxmc7gl7shdijtrlayu/spack-src/khronos/icd/loader/linux/icd_linux.c": "/*\n * Copyright (c) 2016-2019 The Khronos Group Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * OpenCL is a trademark of Apple Inc. used under license by Khronos.\n */\n\n#include \"icd.h\"\n#include \"icd_envvars.h\"\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <pthread.h>\n\nstatic pthread_once_t initialized = PTHREAD_ONCE_INIT;\n\n/*\n * \n * Vendor enumeration functions\n *\n */\n\n// go through the list of vendors in the two configuration files\nvoid khrIcdOsVendorsEnumerate(void)\n{\n    DIR *dir = NULL;\n    struct dirent *dirEntry = NULL;\n    char* vendorPath = ICD_VENDOR_PATH;\n    char* envPath = NULL;\n\n    khrIcdVendorsEnumerateEnv();\n\n    envPath = khrIcd_secure_getenv(\"OCL_ICD_VENDORS\");\n    if (NULL != envPath)\n    {\n        vendorPath = envPath;\n    }\n\n    dir = opendir(vendorPath);\n    if (NULL == dir) \n    {\n        KHR_ICD_TRACE(\"Failed to open path %s, continuing\\n\", vendorPath);\n    }\n    else\n    {\n        // attempt to load all files in the directory\n        for (dirEntry = readdir(dir); dirEntry; dirEntry = readdir(dir) )\n        {\n            switch(dirEntry->d_type)\n            {\n            case DT_UNKNOWN:\n            case DT_REG:\n            case DT_LNK:\n                {\n                    const char* extension = \".icd\";\n                    FILE *fin = NULL;\n                    char* fileName = NULL;\n                    char* buffer = NULL;\n                    long bufferSize = 0;\n\n                    // make sure the file name ends in .icd\n                    if (strlen(extension) > strlen(dirEntry->d_name) )\n                    {\n                        break;\n                    }\n                    if (strcmp(dirEntry->d_name + strlen(dirEntry->d_name) - strlen(extension), extension) )\n                    {\n                        break;\n                    }\n\n                    // allocate space for the full path of the vendor library name\n                    fileName = malloc(strlen(dirEntry->d_name) + strlen(vendorPath) + 1);\n                    if (!fileName)\n                    {\n                        KHR_ICD_TRACE(\"Failed allocate space for ICD file path\\n\");\n                        break;\n                    }\n                    sprintf(fileName, \"%s%s\", vendorPath, dirEntry->d_name);\n\n                    // open the file and read its contents\n                    fin = fopen(fileName, \"r\");\n                    if (!fin)\n                    {\n                        free(fileName);\n                        break;\n                    }\n                    fseek(fin, 0, SEEK_END);\n                    bufferSize = ftell(fin);\n\n                    buffer = malloc(bufferSize+1);\n                    if (!buffer)\n                    {\n                        free(fileName);\n                        fclose(fin);\n                        break;\n                    }\n                    memset(buffer, 0, bufferSize+1);\n                    fseek(fin, 0, SEEK_SET);\n                    if (bufferSize != (long)fread(buffer, 1, bufferSize, fin) )\n                    {\n                        free(fileName);\n                        free(buffer);\n                        fclose(fin);\n                        break;\n                    }\n                    // ignore a newline at the end of the file\n                    if (buffer[bufferSize-1] == '\\n') buffer[bufferSize-1] = '\\0';\n\n                    // load the string read from the file\n                    khrIcdVendorAdd(buffer);\n\n                    free(fileName);\n                    free(buffer);\n                    fclose(fin);\n                }\n                break;\n            default:\n                break;\n            }\n        }\n\n        closedir(dir);\n    }\n\n    if (NULL != envPath)\n    {\n        khrIcd_free_getenv(envPath);\n    }\n}\n\n// go through the list of vendors only once\nvoid khrIcdOsVendorsEnumerateOnce(void)\n{\n    pthread_once(&initialized, khrIcdOsVendorsEnumerate);\n}\n\n/*\n * \n * Dynamic library loading functions\n *\n */\n\n// dynamically load a library.  returns NULL on failure\nvoid *khrIcdOsLibraryLoad(const char *libraryName)\n{\n    void *retVal = dlopen (libraryName, RTLD_NOW);\n\n    if (NULL == retVal) {\n        printf(\"dlerror: %s\\n\", dlerror());\n    }\n\n    return retVal;\n}\n\n// get a function pointer from a loaded library.  returns NULL on failure.\nvoid *khrIcdOsLibraryGetFunctionAddress(void *library, const char *functionName)\n{\n    return dlsym(library, functionName);\n}\n\n// unload a library\nvoid khrIcdOsLibraryUnload(void *library)\n{\n    dlclose(library);\n}\n"
    },
    "skipped": [],
    "total_files": 491
}